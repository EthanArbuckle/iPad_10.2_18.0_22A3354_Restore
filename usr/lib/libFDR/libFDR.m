uint64_t aks_ref_key_create_with_blob(int a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t v4;
  void *v9;
  uint64_t v10;
  void *v12;

  v4 = 3758097090;
  if (a2)
  {
    if (a3)
    {
      if (der_get_sizeof((uint64_t)a2) == a3)
      {
        v4 = 3758604298;
        v9 = calloc(0x50uLL, 1uLL);
        v12 = v9;
        if (v9)
        {
          v10 = (uint64_t)v9;
          memset_s(v9, 0x50uLL, 0, 0x50uLL);
          *(_DWORD *)(v10 + 40) = a1;
          if (_set_blob(v10, a2, a3))
          {
            aks_ref_key_free((uint64_t *)&v12);
          }
          else
          {
            v4 = 0;
            *a4 = v10;
          }
        }
      }
    }
  }
  return v4;
}

uint64_t _set_blob(uint64_t a1, const void *a2, size_t a3)
{
  void *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  if (!der_dict_find_value((uint64_t)der_key_ref_key, &v8, &v9))
    return 3758097090;
  if (*(_QWORD *)a1)
  {
    memset_s(*(void **)a1, *(_QWORD *)(a1 + 8), 0, *(_QWORD *)(a1 + 8));
    free(*(void **)a1);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
  }
  v6 = calloc(a3, 1uLL);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + 8) = a3;
  if (!v6)
    return 3758604298;
  memcpy(v6, a2, a3);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  if (der_dict_find_value((uint64_t)der_key_ref_key, &v8, &v9))
    *(_QWORD *)(a1 + 32) = v8;
  if ((der_dict_find_value((uint64_t)der_key_external_data, &v8, &v9) & 1) != 0
    || (result = der_dict_find_value((uint64_t)der_key_auth_data, &v8, &v9), (_DWORD)result))
  {
    result = 0;
    *(_QWORD *)(a1 + 24) = v8;
  }
  return result;
}

uint64_t der_dict_find_value(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (a1)
  {
    der_dict_iterate();
    if (a2)
    {
      if (a3)
      {
        *a2 = 0;
        *a3 = 0;
      }
    }
  }
  return 0;
}

uint64_t der_dict_iterate()
{
  uint64_t result;

  result = ccder_blob_decode_range();
  if ((_DWORD)result)
  {
    if (ccder_blob_decode_sequence_tl())
    {
      result = ccder_blob_decode_tl();
      if ((_DWORD)result)
        return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

BOOL _dict_find_value_cb(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL4 v8;

  v8 = der_equal(*(const void **)a5, *(_QWORD *)a5 + *(unsigned __int8 *)(*(_QWORD *)a5 + 1) + 2, a1);
  if (v8)
  {
    *(_BYTE *)(a5 + 24) = 1;
    *(_QWORD *)(a5 + 8) = a3;
    *(_QWORD *)(a5 + 16) = a3 + a4;
  }
  return !v8;
}

BOOL der_equal(const void *a1, uint64_t a2, const void *a3)
{
  size_t v5;

  v5 = der_get_sizeof((uint64_t)a1);
  return v5 == der_get_sizeof((uint64_t)a3) && memcmp(a1, a3, v5) == 0;
}

uint64_t der_get_sizeof(uint64_t a1)
{
  if (ccder_blob_decode_tag() && ccder_blob_decode_len())
    return a1 - a1;
  else
    return 0;
}

uint64_t _merge_dict_cb(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  unsigned __int8 *v8;
  uint64_t v9;

  v8 = (unsigned __int8 *)der_key_validate(a1);
  if (v8)
  {
    v9 = (uint64_t)v8;
    if (!encode_list_remove_key(a5, v8) && !encode_list_add_der(a5, v9, a3, a3 + a4))
      return 1;
  }
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s fail%s\n", "aks", "", "", "", "_merge_dict_cb", ":", 647, "", 0, "", "");
  return 0;
}

uint64_t encode_list_add_der(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  size_t v6;
  char *v7;
  char *v8;
  int v9;
  char *v10;
  int v11;
  char *v12;
  _QWORD *v14;
  _QWORD *v15;
  char *v16;
  char *v17;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3 && a4)
  {
    if (der_get_sizeof(a3) <= (unint64_t)(a4 - a3))
    {
      v6 = ccder_sizeof();
      v7 = (char *)calloc(v6, 1uLL);
      if (!v7)
        return 4294967279;
      v8 = v7;
      v16 = &v7[v6];
      if (ccder_blob_encode_body())
      {
        v9 = ccder_blob_encode_body();
        v10 = v16;
        if (!v9)
          v10 = 0;
        v17 = v10;
        v11 = ccder_blob_encode_tl();
        v12 = v17;
        if (!v11)
          v12 = 0;
        if (v12 && v12 == v8)
        {
          v14 = calloc(0x18uLL, 1uLL);
          if (v14)
          {
            v15 = v14;
            result = 0;
            v15[1] = v8;
            v15[2] = v6;
            *v15 = *a1;
            *a1 = v15;
            return result;
          }
        }
      }
      memset_s(v8, v6, 0, v6);
      free(v8);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t der_key_validate(uint64_t a1)
{
  if ((ccder_blob_decode_tl() & 1) == 0)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s bad 1%s\n", "aks", "", "", "", "der_key_validate");
    return 0;
  }
  return a1;
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  uint64_t result;
  unint64_t v12[4];

  v12[3] = *MEMORY[0x24BDAC8D0];
  memset(v12, 170, 24);
  result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!(_DWORD)result)
  {
    if (v12[0] == 0x2000000000000010)
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    else
      return 2;
  }
  return result;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int16 v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t result;
  unsigned __int16 v17;
  __int16 v18;
  unint64_t v19;
  char *v21;
  uint64_t v23;
  unint64_t v24;
  __int16 *v25;
  unint64_t v26;
  __int16 v27;
  unint64_t v28;
  char *v29;
  unint64_t v31[3];
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v32 = 0;
  if (a6)
  {
    if (a6 > a5)
      goto LABEL_59;
    bzero((void *)a4, a6);
  }
  v10 = *a1;
  v11 = a1[1];
  if (__CFADD__(*a1, v11))
    goto LABEL_58;
  v12 = v10 + v11;
  if (v10 > v12)
LABEL_59:
    __break(0x5519u);
  v32 = *a1;
  v33 = v12;
  if (a2)
  {
    v13 = 0;
    v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      v15 = v32;
      v14 = v33;
      result = DERDecodeSeqNext(&v32, v31);
      if ((_DWORD)result)
        break;
      if (a2 <= v13)
        return 2;
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3)
          goto LABEL_58;
        v17 = v13;
        v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(_QWORD *)(a3 + 24 * v13 + 8))
          break;
        result = 2;
        if ((v18 & 1) != 0)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1))
            continue;
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        v19 = *(_QWORD *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5)
          return 7;
        if (v19 > ~a4)
          goto LABEL_58;
        v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4)
          goto LABEL_59;
        *(_OWORD *)v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((_QWORD *)v21 + 1) <= v14 - v15)
            {
              *(_QWORD *)v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29)
            goto LABEL_59;
          v23 = *((_QWORD *)v21 + 1);
          v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15)
            goto LABEL_59;
          *(_QWORD *)v21 = v15;
          *((_QWORD *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            v10 = v31[1] + v31[2];
            v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        v10 = v32;
        v12 = v33;
        goto LABEL_47;
      }
    }
    if ((_DWORD)result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        v25 = (__int16 *)(a3 + 24 * v13 + 16);
        v26 = a2 - (unint64_t)v13;
        result = 0;
        while (1)
        {
          v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0)
            break;
          if (!--v26)
            return result;
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12)
      return 0;
    else
      return 3;
  }
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD v10[3];

  v10[2] = *MEMORY[0x24BDAC8D0];
  v10[0] = 0;
  v2 = *a1;
  v3 = a1[1];
  if (*a1 >= v3)
    return 1;
  v10[0] = *a1;
  v10[1] = v3 - v2;
  result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!(_DWORD)result)
  {
    v8 = a2[1];
    v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  unsigned __int8 *v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  BOOL v10;
  unint64_t v11;
  char *v12;
  unsigned __int8 v13;
  _BYTE *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned int v24;
  BOOL v25;
  char v26;
  unint64_t v27;
  _BYTE *v28;

  v3 = *(_QWORD *)(result + 8);
  if (v3 < 2)
    return 3;
  v4 = *(_BYTE **)result;
  if (*(_QWORD *)result == -1)
    goto LABEL_68;
  v5 = &v4[v3];
  v6 = v4 + 1;
  v7 = v3 - 1;
  v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4)
        goto LABEL_69;
      v14 = v12 + 1;
      v15 = *v12;
      v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15)
            v17 = *v12;
          else
            v17 = v7 - 1;
          v10 = v5 >= v14;
          v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3)
              return 0;
LABEL_34:
            result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8)
        return 3;
      if ((v15 & 0x7F) == 0 || v16 < v19)
        return 3;
      if (v14 >= v5 || v14 < v4)
        goto LABEL_69;
      if (!*v14)
        return 3;
      v15 = 0;
      v21 = (v19 - 1);
      v22 = v7 - v21 - 2;
      v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (_BYTE *)-1)
      {
        if (v14 >= v5)
          goto LABEL_69;
        v10 = v16-- != 0;
        if (!v10)
          goto LABEL_70;
        v24 = *v14++;
        v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!(_DWORD)v19)
        {
          if (a3)
            v25 = 0;
          else
            v25 = v15 > v22;
          v26 = v25;
          result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0)
            return result;
          if (v15 >= v22)
            v27 = v22;
          else
            v27 = v15;
          v10 = (unint64_t)v5 >= v23;
          v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28)
            goto LABEL_69;
          a2[1] = v23;
          a2[2] = v27;
          if (a3)
            goto LABEL_34;
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  v9 = *v6;
  v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10)
    return 3;
  v8 = 0;
  result = 3;
  while (v7 >= 2)
  {
    v11 = v8;
    if (v8 >> 57)
      break;
    if (v6 == (unsigned __int8 *)-1)
      goto LABEL_68;
    if (v6 >= v5 || v6 < v4)
      goto LABEL_69;
    v12 = (char *)(v6 + 1);
    --v7;
    v13 = *v6;
    v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54)
        return 3;
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t DERDecodeSeqInit(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8[4];

  v8[3] = *MEMORY[0x24BDAC8D0];
  memset(v8, 170, 24);
  result = DERDecodeItemPartialBufferGetLength(a1, v8, 0);
  if (!(_DWORD)result)
  {
    v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }
      else
      {
        v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          result = 0;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t DEREncodeSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6, unint64_t a7, unint64_t *a8)
{
  unint64_t v8;
  unint64_t v11;
  uint64_t result;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _BYTE *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  const void **v27;
  __int16 v28;
  unint64_t v30;
  unint64_t v31;
  char v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  size_t v36;
  unint64_t v37;
  size_t v39;
  BOOL v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v44;
  unint64_t v45[2];

  v45[1] = *MEMORY[0x24BDAC8D0];
  v8 = ~a6;
  if (~a6 < a7)
    goto LABEL_73;
  v11 = *a8;
  v44 = a7;
  v45[0] = 0;
  if (v11 < a7)
    goto LABEL_74;
  result = DEREncodeTag(a1, a6, &v44);
  if ((_DWORD)result)
    return result;
  if (v44 > v8)
    goto LABEL_73;
  v17 = a7 - v44;
  if (a7 < v44)
    goto LABEL_75;
  v18 = a6 + a7;
  v19 = a6 + v44;
  if (a6 + v44 < v18)
  {
    result = DERContentLengthOfEncodedSequence(a2, a3, a4, a5, v45);
    if ((_DWORD)result)
      return result;
    v44 = v17;
    if (v19 > a6 + v11 || v19 < a6 || v17 > a6 + v11 - v19)
      goto LABEL_74;
    v42 = a6 + v11;
    v20 = v45[0];
    result = DEREncodeLengthSized(v45[0], v19, v17, (uint64_t *)&v44);
    if ((_DWORD)result)
      return result;
    v21 = v42;
    if (__CFADD__(v19, v44))
    {
LABEL_73:
      __break(0x5513u);
      goto LABEL_74;
    }
    v22 = v17 - v44;
    if (v17 >= v44)
    {
      v23 = (_BYTE *)(v19 + v44);
      if (!__CFADD__(v19 + v44, v20))
      {
        if ((unint64_t)&v23[v20] > v18)
          return 7;
        if (a4)
        {
          v24 = 0;
          v25 = a2 + a3;
          v41 = 24 * a4;
          while (1)
          {
            if (v24 > ~a5)
              goto LABEL_73;
            v26 = *(_QWORD *)(a5 + v24);
            if (v26 > ~a2)
              goto LABEL_73;
            v27 = (const void **)(a2 + v26);
            v28 = *(_WORD *)(a5 + v24 + 16);
            if ((v28 & 0x200) != 0)
              break;
            if ((v28 & 1) == 0)
              goto LABEL_29;
            if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
              goto LABEL_74;
            if (v27[1])
            {
LABEL_29:
              v44 = v22;
              if ((unint64_t)v23 > v21 || (unint64_t)v23 < a6 || v22 > v21 - (unint64_t)v23)
                goto LABEL_74;
              result = DEREncodeTag(*(_QWORD *)(a5 + v24 + 8), (unint64_t)v23, &v44);
              if ((_DWORD)result)
                return result;
              if (__CFADD__(v23, v44))
                goto LABEL_73;
              v30 = v22 - v44;
              if (v22 < v44)
                goto LABEL_75;
              if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
                goto LABEL_74;
              v31 = (unint64_t)v27[1];
              v45[0] = v31;
              v32 = 1;
              if ((v28 & 0x100) != 0 && v31 && *(char *)*v27 < 0)
              {
                v32 = 0;
                v45[0] = ++v31;
              }
              v33 = (unint64_t)&v23[v44];
              v44 = v30;
              if (v33 > v42 || v33 < a6 || v30 > v42 - v33)
                goto LABEL_74;
              result = DEREncodeLengthSized(v31, v33, v30, (uint64_t *)&v44);
              if ((_DWORD)result)
                return result;
              v34 = v44;
              if (__CFADD__(v33, v44))
                goto LABEL_73;
              v35 = v30 - v44;
              if (v30 < v44)
                goto LABEL_75;
              v23 = (_BYTE *)(v33 + v44);
              if ((v32 & 1) == 0)
              {
                if (v23 == (_BYTE *)-1)
                  goto LABEL_73;
                if ((unint64_t)v23 >= v42 || (unint64_t)v23 < a6)
                  goto LABEL_74;
                *v23 = 0;
                --v35;
                if (v30 == v34)
                  goto LABEL_75;
                ++v23;
              }
              if ((unint64_t)v23 > v42)
                goto LABEL_74;
              if ((unint64_t)v23 < a6)
                goto LABEL_74;
              v36 = (size_t)v27[1];
              if (v36 > v42 - (unint64_t)v23)
                goto LABEL_74;
              result = (uint64_t)memmove(v23, *v27, v36);
              v21 = v42;
              v37 = (unint64_t)v27[1];
              if (__CFADD__(v23, v37))
                goto LABEL_73;
              v22 = v35 - v37;
              if (v35 < v37)
                goto LABEL_75;
              goto LABEL_69;
            }
LABEL_70:
            v24 += 24;
            if (v41 == v24)
              goto LABEL_71;
          }
          if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
            goto LABEL_74;
          if ((unint64_t)v23 > v21)
            goto LABEL_74;
          if ((unint64_t)v23 < a6)
            goto LABEL_74;
          v39 = (size_t)v27[1];
          if (v39 > v21 - (unint64_t)v23)
            goto LABEL_74;
          result = (uint64_t)memmove(v23, *v27, v39);
          v21 = v42;
          v37 = (unint64_t)v27[1];
          if (__CFADD__(v23, v37))
            goto LABEL_73;
          v40 = v22 >= v37;
          v22 -= v37;
          if (!v40)
            goto LABEL_75;
LABEL_69:
          v23 += v37;
          goto LABEL_70;
        }
LABEL_71:
        if ((unint64_t)&v23[-a6] <= *a8)
        {
          result = 0;
          *a8 = (unint64_t)&v23[-a6];
          return result;
        }
LABEL_74:
        __break(0x5519u);
      }
      goto LABEL_73;
    }
LABEL_75:
    __break(0x5515u);
    return result;
  }
  return 7;
}

uint64_t DEREncodeTag(uint64_t result, unint64_t a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  unint64_t v11;

  v3 = result & 0x1FFFFFFFFFFFFFFFLL;
  if ((result & 0x1FFFFFFFFFFFFFFFuLL) < 0x1F)
  {
    if (*a3)
    {
      *(_BYTE *)a2 = HIBYTE(result) & 0xE0 | result;
      v8 = 1;
      goto LABEL_17;
    }
    return 7;
  }
  v4 = 0;
  v5 = result & 0x1FFFFFFFFFFFFFFFLL;
  do
  {
    ++v4;
    v6 = v5 > 0x7F;
    v5 >>= 7;
  }
  while (v6);
  v7 = *a3;
  if (v4 >= *a3)
    return 7;
  if (v4 >= ~a2 || (*(_BYTE *)a2 = HIBYTE(result) | 0x1F, a2 + v4 == -2))
  {
LABEL_20:
    __break(0x5513u);
    goto LABEL_21;
  }
  if (a2 + v4 >= a2)
  {
    v8 = v4 + 1;
    *(_BYTE *)(a2 + v4) = result & 0x7F;
    if (v3 >= 0x80)
    {
      v9 = (_BYTE *)(a2 + v4 - 1);
      v10 = (_BYTE *)(a2 + v7);
      while (v9 != (_BYTE *)-2)
      {
        if (v9 >= v10 || (unint64_t)v9 < a2)
          goto LABEL_21;
        v11 = v3 >> 14;
        v3 >>= 7;
        *v9-- = v3 | 0x80;
        if (!v11)
          goto LABEL_17;
      }
      goto LABEL_20;
    }
LABEL_17:
    if (v8 <= *a3)
    {
      result = 0;
      *a3 = v8;
      return result;
    }
  }
LABEL_21:
  __break(0x5519u);
  return result;
}

unint64_t DEREncodeLengthSized(unint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;

  if (result >= 0x80)
  {
    v5 = 0;
    v6 = result;
    do
    {
      --v5;
      v7 = v6 > 0xFF;
      v6 >>= 8;
    }
    while (v7);
    v8 = -v5;
    v9 = 7;
    if (-v5 < a3 && v8 <= 0x7E)
    {
      if (*a4)
      {
        v4 = 1 - v5;
        *(_BYTE *)a2 = -(char)v5 | 0x80;
        if (v8 < ~a2)
        {
          v10 = (_BYTE *)(a2 - v5);
          if (a2 - v5 != -2)
          {
            v11 = (_BYTE *)(a2 + *a4);
            while (v10 != (_BYTE *)-1)
            {
              if (v10 >= v11 || (unint64_t)v10 < a2)
                goto LABEL_23;
              *v10-- = result;
              v7 = result > 0xFF;
              result >>= 8;
              if (!v7)
              {
                if (v8 >= *a4)
                  goto LABEL_23;
                goto LABEL_19;
              }
            }
          }
        }
        __break(0x5513u);
      }
      goto LABEL_23;
    }
    return v9;
  }
  if (!a3)
    return 7;
  if (*a4)
  {
    *(_BYTE *)a2 = result;
    if (*a4)
    {
      v4 = 1;
LABEL_19:
      v9 = 0;
      *a4 = v4;
      return v9;
    }
  }
LABEL_23:
  __break(0x5519u);
  return result;
}

void __get_aks_client_connection_block_invoke()
{
  if (!get_aks_client_connection_connection)
    get_aks_client_connection_connection = _copy_aks_client_connection("IOService:/IOResources/AppleKeyStore", "AppleKeyStore");
}

uint64_t _copy_aks_client_connection(char *path, const char *a2)
{
  mach_port_t v3;
  io_service_t v4;
  task_port_t *v5;
  io_object_t v6;
  kern_return_t v7;
  const __CFDictionary *v8;
  io_service_t MatchingService;
  io_object_t v10;
  uint64_t result;
  kern_return_t v12;
  io_connect_t connect;

  connect = 0;
  v3 = *MEMORY[0x24BDD8B20];
  v4 = IORegistryEntryFromPath(*MEMORY[0x24BDD8B20], path);
  v5 = (task_port_t *)MEMORY[0x24BDAEC58];
  if (!v4 || (v6 = v4, v7 = IOServiceOpen(v4, *MEMORY[0x24BDAEC58], 0, &connect), IOObjectRelease(v6), v7))
  {
    v8 = IOServiceMatching(a2);
    MatchingService = IOServiceGetMatchingService(v3, v8);
    if (MatchingService)
    {
      v10 = MatchingService;
      IOServiceOpen(MatchingService, *v5, 0, &connect);
      IOObjectRelease(v10);
    }
  }
  result = connect;
  if (connect)
  {
    v12 = IOConnectCallMethod(connect, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    result = connect;
    if (v12)
    {
      IOServiceClose(connect);
      return 0;
    }
  }
  return result;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  uint64_t result;
  unint64_t v4[2];

  v4[1] = *MEMORY[0x24BDAC8D0];
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  result = DERParseInteger64(a1, v4);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v4[0]))
    {
      return 7;
    }
    else
    {
      result = 0;
      *a2 = v4[0];
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2;
  unsigned __int8 *v3;
  uint64_t result;
  unint64_t v5;
  unsigned int v6;

  v2 = (unint64_t)a1[1];
  if (!v2)
    return 3;
  v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0)
    return 3;
  if (**a1)
  {
    if (v2 > 8)
      return 7;
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0)
      return 3;
    if (v2 > 9)
      return 7;
  }
LABEL_10:
  v5 = 0;
  do
  {
    v6 = *v3++;
    v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  result = 0;
  *a2 = v5;
  return result;
}

uint64_t DERLengthOfEncodedSequence(uint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5[2];

  v5[1] = *MEMORY[0x24BDAC8D0];
  v5[0] = 0;
  if ((a2 | 0x7FFFFFFFFFFFFFFFLL) < a2)
    __break(0x5519u);
  if (DERLengthOfEncodedSequenceFromObject(a1, a2, ~a2 & 0x7FFFFFFFFFFFFFFFLL, a3, a4, v5))
    return 0;
  else
    return v5[0];
}

unint64_t DERLengthOfEncodedSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t *a6)
{
  unint64_t result;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x24BDAC8D0];
  v17[0] = 0;
  result = DERContentLengthOfEncodedSequence(a2, a3, a4, a5, v17);
  if (!(_DWORD)result)
  {
    v9 = a1 & 0x1FFFFFFFFFFFFFFFLL;
    v10 = 1;
    if ((a1 & 0x1FFFFFFFFFFFFFFFuLL) >= 0x1F)
    {
      do
      {
        ++v10;
        v11 = v9 > 0x7F;
        v9 >>= 7;
      }
      while (v11);
    }
    v12 = 1;
    if (v17[0] >= 0x80uLL)
    {
      v13 = v17[0];
      do
      {
        ++v12;
        v11 = v13 > 0xFF;
        v13 >>= 8;
      }
      while (v11);
    }
    v14 = __CFADD__(v10, v12);
    v15 = v10 + v12;
    if (v14 || (v14 = __CFADD__(v15, v17[0]), v16 = v15 + v17[0], v14))
    {
      __break(0x5500u);
    }
    else
    {
      result = 0;
      *a6 = v16;
    }
  }
  return result;
}

unint64_t DERContentLengthOfEncodedSequence(unint64_t result, unint64_t a2, int a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  unsigned __int8 **v10;
  __int16 v11;
  unint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned __int8 *v20;
  unint64_t v21;
  uint64_t v22;

  v5 = 0;
  if (!a3)
  {
LABEL_38:
    result = 0;
LABEL_40:
    *a5 = v5;
    return result;
  }
  v6 = 0;
  v7 = result + a2;
  while (24 * (unint64_t)v6 <= ~a4)
  {
    v8 = *(_QWORD *)(a4 + 24 * v6);
    v9 = v8 > 0xFFFFFFFFFFFFFFEFLL || v8 + 16 > a2;
    if (v9)
    {
      v5 = 0;
      result = 7;
      goto LABEL_40;
    }
    if (v8 > ~result)
      break;
    v10 = (unsigned __int8 **)(result + v8);
    v11 = *(_WORD *)(a4 + 24 * v6 + 16);
    if ((v11 & 0x200) == 0)
    {
      if ((v11 & 1) != 0)
      {
        if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
          goto LABEL_43;
        if (!v10[1])
          goto LABEL_37;
      }
      v13 = *(_QWORD *)(a4 + 24 * v6 + 8) & 0x1FFFFFFFFFFFFFFFLL;
      v14 = 1;
      if (v13 >= 0x1F)
      {
        do
        {
          ++v14;
          v9 = v13 > 0x7F;
          v13 >>= 7;
        }
        while (v9);
      }
      v15 = __CFADD__(v5, v14);
      v16 = v5 + v14;
      if (v15)
        goto LABEL_42;
      if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
        goto LABEL_43;
      v17 = (unint64_t)v10[1];
      if ((*(_WORD *)(a4 + 24 * v6 + 16) & 0x100) != 0)
      {
        if (v17)
        {
          v17 += (unint64_t)**v10 >> 7;
          goto LABEL_24;
        }
LABEL_25:
        v18 = 1;
      }
      else
      {
LABEL_24:
        if (v17 < 0x80)
          goto LABEL_25;
        v18 = 1;
        v21 = v17;
        do
        {
          ++v18;
          v9 = v21 > 0xFF;
          v21 >>= 8;
        }
        while (v9);
      }
      v15 = __CFADD__(v16, v18);
      v22 = v16 + v18;
      if (v15)
        goto LABEL_42;
      v15 = __CFADD__(v22, v17);
      v5 = v22 + v17;
      if (v15)
        goto LABEL_42;
      goto LABEL_37;
    }
    if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
      goto LABEL_43;
    v20 = v10[1];
    v15 = __CFADD__(v5, v20);
    v5 += (uint64_t)v20;
    if (v15)
      goto LABEL_42;
LABEL_37:
    if (++v6 == a3)
      goto LABEL_38;
  }
  __break(0x5513u);
LABEL_42:
  __break(0x5500u);
LABEL_43:
  __break(0x5519u);
  return result;
}

uint64_t aks_ref_key_sign(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  void *v8;
  void **v9;
  void *__s;
  rsize_t __n;

  v7 = 3758097090;
  v8 = der_key_op_sign;
  v9 = (void **)calloc(8uLL, 1uLL);
  *v9 = 0;
  encode_list_add_key(v9, (uint64_t)der_key_op, (uint64_t)v8);
  __s = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v9, a2))
  {
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_data);
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_data(v9, (uint64_t)der_key_data, a4)
      && !encode_list_add_der(v9, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v9, &__s, &__n))
    {
      v7 = _aks_operation();
    }
  }
  encode_list_free(v9);
  memset_s(v9, 8uLL, 0, 8uLL);
  free(v9);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v7;
}

uint64_t encode_list_remove_key(_QWORD *a1, unsigned __int8 *a2)
{
  _QWORD **v2;
  uint64_t result;
  uint64_t v4;
  _QWORD *i;
  void *v6;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = (_QWORD **)a1;
  result = (uint64_t)_encode_list_find_key(a1, a2);
  if (result)
  {
    v4 = result;
    for (i = *v2; i != (_QWORD *)result; i = (_QWORD *)*i)
      v2 = (_QWORD **)i;
    *v2 = *(_QWORD **)result;
    v6 = *(void **)(result + 8);
    if (v6)
    {
      memset_s(v6, *(_QWORD *)(v4 + 16), 0, *(_QWORD *)(v4 + 16));
      free(*(void **)(v4 + 8));
    }
    memset_s((void *)v4, 0x18uLL, 0, 0x18uLL);
    free((void *)v4);
    return 0;
  }
  return result;
}

_QWORD *_encode_list_find_key(_QWORD *a1, unsigned __int8 *a2)
{
  _QWORD *v2;
  const void *v5;

  if (!a1)
    return 0;
  v2 = (_QWORD *)*a1;
  if (*a1)
  {
    do
    {
      v5 = (const void *)v2[1];
      if (ccder_blob_decode_sequence_tl() && der_equal(a2, (uint64_t)&a2[a2[1] + 2], v5))
        break;
      v2 = (_QWORD *)*v2;
    }
    while (v2);
  }
  return v2;
}

uint64_t encode_list_free(void **a1)
{
  void *v2;
  void *v3;

  if (!a1)
    return 0xFFFFFFFFLL;
  while (1)
  {
    v2 = *a1;
    if (!*a1)
      break;
    v3 = (void *)*((_QWORD *)v2 + 1);
    *a1 = *(void **)v2;
    if (v3)
    {
      memset_s(v3, *((_QWORD *)v2 + 2), 0, *((_QWORD *)v2 + 2));
      free(*((void **)v2 + 1));
    }
    memset_s(v2, 0x18uLL, 0, 0x18uLL);
    free(v2);
  }
  return 0;
}

uint64_t _aks_operation()
{
  int v0;
  size_t *v1;
  size_t *v2;
  _QWORD *v3;
  _QWORD *v4;
  size_t v5;
  size_t v6;
  const void *v7;
  const void *v8;
  int v9;
  mach_port_t aks_client_connection;
  mach_port_t v11;
  uint64_t v12;
  void *v13;
  size_t __count;
  uint64_t input;
  _BYTE __src[32768];
  uint64_t v18;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v9 = v0;
  v18 = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v8)
    {
      v11 = aks_client_connection;
      v12 = 3758097090;
      if (der_get_sizeof((uint64_t)v8) == v6)
      {
        bzero(__src, 0x8000uLL);
        __count = 0x8000;
        input = v9;
        v12 = IOConnectCallMethod(v11, 0x2Bu, &input, 1u, v8, v6, 0, 0, __src, &__count);
        if (!(_DWORD)v12 && v4 && v2)
        {
          v13 = calloc(__count, 1uLL);
          *v4 = v13;
          if (v13)
          {
            memcpy(v13, __src, __count);
            v12 = 0;
            *v2 = __count;
          }
          else
          {
            v12 = 3758097085;
          }
        }
      }
    }
    else
    {
      v12 = 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_aks_operation", ":", 457, "", 0, "", "");
    v12 = 3758097084;
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  return v12;
}

uint64_t encode_list_dict(_QWORD *a1, _QWORD *a2, size_t *a3)
{
  uint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  rsize_t v11;
  void *v12;
  void *v13;
  _QWORD *v14;
  _OWORD *v15;
  size_t v16;
  char *v17;
  void *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v22;
  char v23;
  char *v25;
  char *v26;

  v3 = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        v7 = (_QWORD *)*a1;
        if (*a1)
        {
          v8 = 0;
          v9 = 0;
          v10 = 0;
          do
          {
            v10 += v7[2];
            v7 = (_QWORD *)*v7;
            v9 -= 16;
            --v8;
          }
          while (v7);
          if (v8 >= 0xF000000000000001 && (v11 = -v9, (v12 = calloc(-v9, 1uLL)) != 0))
          {
            v13 = v12;
            v14 = (_QWORD *)*a1;
            if (*a1)
            {
              v15 = v12;
              do
              {
                *v15++ = *(_OWORD *)(v14 + 1);
                v14 = (_QWORD *)*v14;
              }
              while (v14);
            }
            qsort(v12, -(uint64_t)v8, 0x10uLL, (int (__cdecl *)(const void *, const void *))_qsort_compare);
            v16 = ccder_sizeof();
            v17 = (char *)calloc(v16, 1uLL);
            v18 = v17;
            if (v17)
            {
              v25 = v17;
              v26 = &v17[v16];
              v19 = v8 - 1;
              v20 = (uint64_t)v13 - v9 - 8;
              while (!__CFADD__(v19++, 1))
              {
                v22 = v20 - 16;
                v23 = ccder_blob_encode_body();
                v20 = v22;
                if ((v23 & 1) == 0)
                  goto LABEL_16;
              }
              if (!ccder_blob_encode_tl() || v25 != v26)
              {
LABEL_16:
                v3 = 0xFFFFFFFFLL;
                goto LABEL_20;
              }
              v3 = 0;
              *a2 = v18;
              *a3 = v16;
              v18 = 0;
            }
            else
            {
              v3 = 4294967279;
            }
LABEL_20:
            memset_s(v13, v11, 0, v11);
            free(v13);
            if (v18)
            {
              memset_s(v18, v16, 0, v16);
              free(v18);
            }
          }
          else
          {
            return 0xFFFFFFFFLL;
          }
        }
      }
    }
  }
  return v3;
}

uint64_t encode_list_add_data(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  size_t v5;
  char *v6;
  char *v7;
  int v8;
  char *v9;
  int v10;
  char *v11;
  BOOL v12;
  _QWORD *v13;
  _QWORD *v14;
  char *v15;
  char *v16;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    ccder_sizeof();
    v5 = ccder_sizeof();
    v6 = (char *)calloc(v5, 1uLL);
    if (v6)
    {
      v7 = v6;
      v15 = &v6[v5];
      if (!ccder_blob_encode_body() || !ccder_blob_encode_tl())
        goto LABEL_19;
      v8 = ccder_blob_encode_body();
      v9 = v15;
      if (!v8)
        v9 = 0;
      v16 = v9;
      v10 = ccder_blob_encode_tl();
      v11 = v16;
      if (!v10)
        v11 = 0;
      v12 = v11 && v11 == v7;
      if (v12 && (v13 = calloc(0x18uLL, 1uLL)) != 0)
      {
        v14 = v13;
        result = 0;
        v14[1] = v7;
        v14[2] = v5;
        *v14 = *a1;
        *a1 = v14;
      }
      else
      {
LABEL_19:
        memset_s(v7, v5, 0, v5);
        free(v7);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t _get_merged_params(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;

  v3 = 3758604298;
  if (a1
    && (!*(_QWORD *)(a1 + 48) || !encode_list_merge_dict((uint64_t)a2))
    && (!a3 || !encode_list_merge_dict((uint64_t)a2)))
  {
    encode_list_remove_key(a2, (unsigned __int8 *)der_key_external_data);
    return 0;
  }
  return v3;
}

uint64_t encode_list_merge_dict(uint64_t a1)
{
  if (a1)
    return der_dict_iterate() - 1;
  else
    return 4294967285;
}

uint64_t get_aks_client_connection()
{
  uint64_t result;

  if (get_aks_client_dispatch_queue_onceToken != -1)
    dispatch_once(&get_aks_client_dispatch_queue_onceToken, &__block_literal_global_168);
  dispatch_sync((dispatch_queue_t)get_aks_client_dispatch_queue_connection_queue, &__block_literal_global_150);
  result = get_aks_client_connection_connection;
  if (!get_aks_client_connection_connection)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStore");
    return get_aks_client_connection_connection;
  }
  return result;
}

uint64_t encode_list_add_key(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return encode_list_add_der(a1, a2, a3, a3 + *(unsigned __int8 *)(a3 + 1) + 2);
}

uint64_t aks_params_free(void ***a1)
{
  uint64_t result;
  void **v3;

  result = 3758097090;
  if (a1)
  {
    v3 = *a1;
    if (*a1)
    {
      *a1 = 0;
      encode_list_free(v3);
      memset_s(v3, 8uLL, 0, 8uLL);
      free(v3);
      return 0;
    }
  }
  return result;
}

uint64_t aks_ref_key_get_type(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;

  if (!*(_QWORD *)(a1 + 32))
    return 0;
  v2 = 0;
  v3 = 0;
  result = der_dict_find_value((uint64_t)der_key_type, &v2, &v3);
  if ((_DWORD)result)
    return der_get_number();
  return result;
}

uint64_t der_get_number()
{
  ccder_blob_decode_tl();
  return 0;
}

uint64_t AMFDRCopyDeviceKeys(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t result;
  unint64_t v6;

  if (!a2 || !a3)
  {
    v6 = 0x2549B1000;
    result = 1;
LABEL_9:
    *(_DWORD *)(v6 + 1872) = result;
    return result;
  }
  if (*MEMORY[0x24BDE9080] != a1)
  {
    v6 = 0x2549B1000uLL;
    result = 9;
    goto LABEL_9;
  }
  if (AMFDRCopyDeviceKeys_onceToken != -1)
    dispatch_once(&AMFDRCopyDeviceKeys_onceToken, &__block_literal_global);
  *a2 = AMSupportSafeRetain();
  *a3 = AMSupportSafeRetain();
  return AMFDRCopyDeviceKeys_error;
}

void *CryptoBufferAllocate()
{
  _OWORD *v0;
  void *memptr;

  memptr = 0;
  if (!malloc_type_posix_memalign(&memptr, 0x10uLL, 0x40uLL, 0xA612416EuLL))
  {
    v0 = memptr;
    *(_OWORD *)memptr = 0u;
    v0[1] = 0u;
    v0[2] = 0u;
    v0[3] = 0u;
  }
  return memptr;
}

_QWORD *AMFDRDeviceRefKeyCreate(const __CFAllocator *a1)
{
  return _AMFDRDeviceRefKeyCreateInternal(a1, 0);
}

_QWORD *_AMFDRDeviceRefKeyCreateInternal(const __CFAllocator *a1, CFDataRef theData)
{
  const UInt8 *BytePtr;
  CFIndex v5;
  void **v6;
  const __CFBoolean *v7;
  const __CFBoolean *v8;
  CFTypeID v9;
  unsigned int v10;
  void **v11;
  CFDataRef v12;
  const UInt8 *public_key;
  CFDataRef v14;
  _QWORD *Instance;
  _QWORD *v16;
  CFTypeRef v17;
  void **v18;
  uint64_t v20;
  void **v21;
  uint64_t v22;
  void *v23;
  CFIndex v24;
  void **v25;
  CFIndex length;
  UInt8 *v27;

  v27 = 0;
  v25 = 0;
  length = 0;
  v23 = 0;
  v24 = 0;
  v21 = 0;
  v22 = 0;
  v20 = 1;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    v5 = CFDataGetLength(theData);
    if (aks_ref_key_create_with_blob(0, BytePtr, v5, (uint64_t *)&v25))
    {
      AMSupportLogInternal();
      v6 = 0;
      v12 = 0;
      v7 = 0;
      goto LABEL_45;
    }
    v6 = 0;
    v7 = 0;
  }
  else
  {
    v8 = (const __CFBoolean *)MGCopyAnswer();
    v7 = v8;
    if (!v8 || (v9 = CFGetTypeID(v8), v9 != CFBooleanGetTypeID()))
    {
      AMSupportLogInternal();
      v6 = 0;
LABEL_44:
      v12 = 0;
      goto LABEL_45;
    }
    if (CFBooleanGetValue(v7))
      v10 = 5;
    else
      v10 = 4;
    v11 = (void **)aks_params_create(0);
    v6 = v11;
    v21 = v11;
    if (!v11
      || aks_params_set_number(v11, 9, &v20)
      || aks_params_get_der(v6, &v23, &v22)
      || aks_ref_key_create(-1, 13, v10, (uint64_t)v23, v22, &v25))
    {
LABEL_43:
      AMSupportLogInternal();
      goto LABEL_44;
    }
  }
  if (!v25
    || aks_sik_attest((uint64_t *)v25, (uint64_t)v23, v22, (uint64_t)&v27, (uint64_t)&length)
    || !v27
    || !length)
  {
    goto LABEL_43;
  }
  v12 = CFDataCreate(a1, v27, length);
  if (!v12)
  {
    AMSupportLogInternal();
LABEL_45:
    v14 = 0;
    goto LABEL_46;
  }
  public_key = (const UInt8 *)aks_ref_key_get_public_key(v25, &v24);
  if (!public_key || !v24)
    goto LABEL_45;
  v14 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], public_key, v24);
  if (v14)
  {
    pthread_once(&_AMFDRDeviceRefKeyClassInitializeOnce, (void (*)(void))_AMFDRDeviceRefKeyClassInitialize);
    Instance = (_QWORD *)_CFRuntimeCreateInstance();
    if (Instance)
    {
      v16 = Instance;
      Instance[2] = 0;
      Instance[3] = 0;
      Instance[4] = 0;
      v17 = CFRetain(v12);
      v18 = v25;
      v16[2] = v17;
      v16[3] = v18;
      v25 = 0;
      v16[4] = v14;
      v14 = 0;
      if (!v6)
        goto LABEL_24;
      goto LABEL_23;
    }
  }
  else
  {
    AMSupportLogInternal();
  }
LABEL_46:
  if (v25)
    aks_ref_key_free((uint64_t *)&v25);
  v16 = 0;
  if (v6)
LABEL_23:
    aks_params_free(&v21);
LABEL_24:
  if (v14)
    CFRelease(v14);
  if (v7)
    CFRelease(v7);
  if (v12)
    CFRelease(v12);
  if (v27)
  {
    free(v27);
    v27 = 0;
  }
  if (v23)
    free(v23);
  return v16;
}

_QWORD *AMFDRDeviceRefKeyCreateWithData(const __CFAllocator *a1, const __CFData *a2)
{
  if (a2)
    return _AMFDRDeviceRefKeyCreateInternal(a1, a2);
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDRDeviceRefKeySign(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __int128 v5;
  _OWORD v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = v5;
  v9[1] = v5;
  if (a1 && a2 && a3 && a4 && a5)
  {
    ccsha256_di();
    ccdigest();
    aks_ref_key_sign(*(uint64_t **)(a1 + 24), 0, 0, (uint64_t)v9);
    AMSupportLogInternal();
    return 6;
  }
  else
  {
    AMSupportLogInternal();
    return 1;
  }
}

CFTypeRef AMFDRDeviceRefKeyCopyAttestation(uint64_t a1)
{
  const void *v1;

  if (a1)
  {
    v1 = *(const void **)(a1 + 16);
    if (v1)
      return CFRetain(v1);
  }
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDRDeviceRefKeyGetPublicKey(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 32);
  AMSupportLogInternal();
  return 0;
}

CFDataRef AMFDRDeviceCopySikPub(const __CFAllocator *a1)
{
  CFDataRef SikPubDigestIfNecessary;
  CFIndex length;
  UInt8 *bytes;

  length = 0;
  bytes = 0;
  if (!aks_system_key_get_public(1u, 1u, 0, 0, &bytes, &length) && bytes && length)
  {
    SikPubDigestIfNecessary = AMFDRDataCreateSikPubDigestIfNecessary(a1, bytes, length);
  }
  else
  {
    AMSupportLogInternal();
    SikPubDigestIfNecessary = 0;
  }
  if (bytes)
    free(bytes);
  return SikPubDigestIfNecessary;
}

CFDataRef AMFDRDeviceRefKeyCopyKeyBlob(uint64_t a1)
{
  uint64_t *v1;
  const UInt8 *blob;
  CFDataRef result;
  CFIndex length;

  length = 0;
  if (!a1
    || (v1 = *(uint64_t **)(a1 + 24)) == 0
    || (blob = (const UInt8 *)aks_ref_key_get_blob(v1, &length)) == 0
    || (result = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], blob, length)) == 0)
  {
    AMSupportLogInternal();
    return 0;
  }
  return result;
}

uint64_t _AMFDRDeviceRefKeyClassInitialize()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  _AMFDRDeviceRefKeyTypeID = result;
  return result;
}

void _AMFDRDeviceRefKeyClassFinalize(_QWORD *a1)
{
  const void *v2;
  _QWORD *v3;
  const void *v4;

  if (!a1)
    _AMFDRDeviceRefKeyClassFinalize_cold_1();
  v3 = a1 + 2;
  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    *v3 = 0;
  }
  if (a1[3])
  {
    aks_ref_key_free(a1 + 3);
    a1[3] = 0;
  }
  v4 = (const void *)a1[4];
  if (v4)
    CFRelease(v4);
  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
}

const __CFString *_AMFDRDeviceRefKeyCopyFormattingDescription(uint64_t a1)
{
  _QWORD *v1;
  const UInt8 *public_key;
  const __CFAllocator *v3;
  CFDataRef v4;
  CFDataRef v5;
  uint64_t v6;
  const void *v7;
  CFStringRef v8;
  CFStringRef v9;
  const __CFString *v10;
  CFIndex length;

  length = 0;
  if (!a1)
    _AMFDRDeviceRefKeyCopyFormattingDescription_cold_1();
  v1 = *(_QWORD **)(a1 + 24);
  if (!v1)
    return CFSTR("Invalid AMFDRDeviceRefKey");
  public_key = (const UInt8 *)aks_ref_key_get_public_key(v1, &length);
  if (!public_key)
    return CFSTR("Invalid AMFDRDeviceRefKey");
  if (!length)
    return CFSTR("Invalid AMFDRDeviceRefKey");
  v3 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], public_key, length);
  if (!v4)
    return CFSTR("Invalid AMFDRDeviceRefKey");
  v5 = v4;
  v6 = AMSupportCopyHexStringFromData();
  if (!v6)
  {
    v10 = CFSTR("Invalid AMFDRDeviceRefKey");
    v9 = (CFStringRef)v5;
LABEL_10:
    CFRelease(v9);
    return v10;
  }
  v7 = (const void *)v6;
  v8 = CFStringCreateWithFormat(v3, 0, CFSTR("AMFDRDeviceRefKey: %@"), v6);
  v9 = v8;
  if (v8)
    v10 = (const __CFString *)CFRetain(v8);
  else
    v10 = CFSTR("Invalid AMFDRDeviceRefKey");
  CFRelease(v5);
  CFRelease(v7);
  if (v9)
    goto LABEL_10;
  return v10;
}

uint64_t AMFDRCopyDisposableKeys(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  char v5;
  uint64_t v6;
  int key;
  size_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  UInt8 *v12;
  UInt8 *v13;
  const __CFAllocator *v14;
  _BYTE __b[2112];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  memset(__b, 170, sizeof(__b));
  v5 = 0;
  v6 = 1;
  if (!a2 || !a3)
    goto LABEL_15;
  ccrng();
  key = ccrsa_generate_key();
  AMSupportLogInternal();
  if (key)
  {
    v5 = 0;
    v6 = 6;
    goto LABEL_15;
  }
  v8 = ccrsa_export_priv_size();
  v9 = malloc_type_malloc(v8, 0x6725E0A8uLL);
  v10 = ccrsa_ctx_public();
  v11 = MEMORY[0x212BA0F3C](v10);
  v12 = (UInt8 *)malloc_type_malloc(v11, 0xBB46C6AAuLL);
  v13 = v12;
  if (v9 && v12)
  {
    if (ccrsa_export_priv()
      || (ccrsa_ctx_public(), ccrsa_export_pub())
      || AMSupportRsaCreatePemFromData())
    {
      v5 = 0;
      v6 = 6;
    }
    else
    {
      v14 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      *a3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0);
      AMSupportLogInternal();
      if (*a3 && (*a2 = CFDataCreate(v14, v13, v11), AMSupportLogInternal(), *a2))
      {
        v6 = 0;
        v5 = 1;
      }
      else
      {
        v5 = 0;
        v6 = 2;
      }
    }
    goto LABEL_12;
  }
  v5 = 0;
  v6 = 2;
  if (v9)
LABEL_12:
    free(v9);
  if (v13)
    free(v13);
LABEL_15:
  if ((v5 & 1) == 0)
  {
    if (*a2)
    {
      CFRelease(*a2);
      *a2 = 0;
    }
    if (*a3)
    {
      CFRelease(*a3);
      *a3 = 0;
    }
  }
  return v6;
}

CFDataRef AMFDRCryptoCreateCsr(uint64_t a1, const __CFString *a2)
{
  CFDataRef PemFromData;
  const __CFData *PrivateKey;
  CFDataRef v5;
  CFTypeID v6;
  _QWORD *v7;
  unsigned int (*v8)(CFDataRef, CFTypeRef *, CFDataRef *, _QWORD);
  CFTypeID v9;
  const void *v10;
  CFTypeID v11;
  CFTypeRef v12;
  _QWORD *v13;
  uint64_t (*v14)(CFDataRef, _QWORD);
  CFDataRef SignedCsr;
  CFDataRef v16;
  CFTypeRef cf;
  CFDataRef theData;
  unsigned int v20;

  PemFromData = (CFDataRef)a1;
  v20 = 0;
  cf = 0;
  theData = 0;
  if (!a1)
  {
    AMSupportLogInternal();
    goto LABEL_25;
  }
  if (AMFDRCryptoGetCryptoVersion(a1, 2u, (int *)&v20))
    goto LABEL_24;
  if ((v20 & 0x10000) != 0)
  {
    v13 = (_QWORD *)*((_QWORD *)PemFromData + 17);
    if (*v13 >= 0x29uLL && (v14 = (uint64_t (*)(CFDataRef, _QWORD))v13[5]) != 0)
    {
      v12 = (CFTypeRef)v14(PemFromData, *((_QWORD *)PemFromData + 18));
      cf = v12;
      if (v12)
        goto LABEL_19;
    }
    else
    {
      cf = 0;
    }
LABEL_24:
    AMSupportLogInternal();
    PemFromData = 0;
    goto LABEL_25;
  }
  PrivateKey = (const __CFData *)AMFDRCryptoGetPrivateKey((uint64_t)PemFromData);
  theData = PrivateKey;
  if (!PrivateKey || (v5 = PrivateKey, v6 = CFGetTypeID(PrivateKey), v6 != CFDataGetTypeID()))
  {
    v7 = (_QWORD *)*((_QWORD *)PemFromData + 17);
    if (*v7 < 0x51uLL)
      goto LABEL_24;
    v8 = (unsigned int (*)(CFDataRef, CFTypeRef *, CFDataRef *, _QWORD))v7[10];
    if (!v8)
      goto LABEL_24;
    if (v8(PemFromData, &cf, &theData, *((_QWORD *)PemFromData + 18)))
      goto LABEL_24;
    v5 = theData;
    if (!theData)
      goto LABEL_24;
  }
  v9 = CFGetTypeID(v5);
  if (v9 != CFDataGetTypeID())
    goto LABEL_24;
  v10 = cf;
  if (!cf)
  {
    CFDataGetBytePtr(theData);
    CFDataGetLength(theData);
    if (AMSupportRsaCreatePublicKeyFromPrivateKeyPEMBuffer())
      goto LABEL_24;
    v10 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0);
    cf = v10;
    if (!v10)
      goto LABEL_24;
  }
  v11 = CFGetTypeID(v10);
  if (v11 != CFDataGetTypeID())
    goto LABEL_24;
  v12 = cf;
LABEL_19:
  SignedCsr = AMFDRCryptoCreateSignedCsr((const __CFDictionary **)PemFromData, v20, a2, (const __CFData *)v12, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))AMFDRCryptoCreateCsrSignature, (uint64_t)PemFromData);
  if (!SignedCsr)
    goto LABEL_24;
  v16 = SignedCsr;
  PemFromData = AMFDRCryptoCreatePemFromData((uint64_t)SignedCsr, 1);
  if (!PemFromData)
    AMSupportLogInternal();
  CFRelease(v16);
LABEL_25:
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  return PemFromData;
}

uint64_t AMFDRCryptoCreateDataSignature(int a1, uint64_t a2, uint64_t a3, void **a4, _QWORD *a5, CFTypeRef cf)
{
  CFTypeID v12;
  uint64_t PrivateKeyFromPEMBuffer;
  const __CFData *PrivateKey;
  const __CFData *v15;
  CFTypeID v16;
  uint64_t v17;
  _QWORD *v18;
  unsigned int (*v19)(CFTypeRef, uint64_t, uint64_t, void **, uint64_t *, _QWORD);
  uint64_t v21;
  void *v22;

  v21 = 0;
  v22 = 0;
  if (!cf)
    goto LABEL_36;
  v12 = CFGetTypeID(cf);
  if (v12 != AMFDRGetTypeID() || !a2 || !a3 || !a4 || !a5)
    goto LABEL_36;
  PrivateKeyFromPEMBuffer = 103;
  if (a1 != 66050 && a1 != 66562)
  {
    PrivateKey = (const __CFData *)AMFDRCryptoGetPrivateKey((uint64_t)cf);
    if (!PrivateKey)
      goto LABEL_36;
    v15 = PrivateKey;
    v16 = CFGetTypeID(PrivateKey);
    if (v16 != CFDataGetTypeID())
      goto LABEL_36;
    CFDataGetBytePtr(v15);
    CFDataGetLength(v15);
    PrivateKeyFromPEMBuffer = AMSupportRsaCreatePrivateKeyFromPEMBuffer();
    if ((_DWORD)PrivateKeyFromPEMBuffer)
      goto LABEL_26;
  }
  if (a1 > 1024)
  {
    if (a1 != 66562 && a1 != 66050)
    {
      PrivateKeyFromPEMBuffer = 105;
      if (a1 != 1025)
        goto LABEL_27;
LABEL_36:
      AMSupportLogInternal();
      PrivateKeyFromPEMBuffer = 103;
      goto LABEL_27;
    }
    v18 = (_QWORD *)*((_QWORD *)cf + 17);
    if (*v18 >= 0x39uLL)
    {
      v19 = (unsigned int (*)(CFTypeRef, uint64_t, uint64_t, void **, uint64_t *, _QWORD))v18[7];
      if (v19)
      {
        if (!v19(cf, a2, a3, &v22, &v21, *((_QWORD *)cf + 18)))
        {
          if (v22)
          {
            v17 = v21;
            if (v21)
            {
              *a4 = v22;
              v22 = 0;
              PrivateKeyFromPEMBuffer = 100;
              *a5 = v17;
              return PrivateKeyFromPEMBuffer;
            }
          }
        }
      }
    }
LABEL_26:
    AMSupportLogInternal();
    goto LABEL_27;
  }
  if (a1 == 257)
    goto LABEL_36;
  PrivateKeyFromPEMBuffer = 105;
  if (a1 == 513)
    goto LABEL_36;
LABEL_27:
  if (v22)
  {
    free(v22);
    v22 = 0;
  }
  return PrivateKeyFromPEMBuffer;
}

uint64_t AMFDRCreateRsaSignature(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, uint64_t *a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  __int128 v14;
  _OWORD *v15;
  __int128 v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v10 = ccrsa_import_priv_n();
  MEMORY[0x24BDAC7A8]();
  v12 = (uint64_t *)((char *)&v21 - v11);
  if (v13 >= 0x20)
  {
    *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v15 = (_OWORD *)((char *)&v21 - v11);
    do
    {
      *v15 = v14;
      v15[1] = v14;
      v15 += 2;
      v11 -= 32;
    }
    while (v11);
  }
  *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24 = v16;
  v25 = v16;
  v23 = v16;
  v22 = 0xAAAAAAAAAAAAAAAALL;
  *v12 = v10;
  if (ccrsa_import_priv())
    return 6;
  v22 = 8 * v10;
  v17 = malloc_type_calloc(1uLL, 8 * v10, 0xD1C17806uLL);
  if (!v17)
    return 6;
  v18 = v17;
  switch(a1)
  {
    case 1025:
      ccsha384_di();
      ccdigest();
      break;
    case 513:
      ccsha256_di();
      ccdigest();
      break;
    case 257:
      ccsha1_di();
      ccdigest();
      break;
    default:
      v19 = 105;
LABEL_15:
      free(v18);
      return v19;
  }
  if (ccrsa_sign_pkcs1v15())
  {
    v19 = 6;
    goto LABEL_15;
  }
  v19 = 0;
  *a6 = v18;
  *a7 = v22;
  return v19;
}

uint64_t AMFDRCryptoCreateLocalSignedDataSignature(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DataFromPem;
  uint64_t v6;
  uint64_t v8;
  void *v9;

  v8 = 0;
  v9 = 0;
  if (!a2 || !a3 || !a4 || !a5)
    goto LABEL_14;
  if ((a1 & 3) != 1 && (a1 & 3) != 2)
    return 105;
  DataFromPem = AMSupportRsaCreateDataFromPem();
  if (!(_DWORD)DataFromPem)
  {
LABEL_14:
    AMSupportLogInternal();
    return 103;
  }
  v6 = DataFromPem;
  AMSupportLogInternal();
  return v6;
}

uint64_t AMFDRCreateEcDsaSignature(int a1)
{
  int SignatureSha384;

  if (a1 == 66562)
  {
    SignatureSha384 = AMSupportEcDsaCreateSignatureSha384();
  }
  else
  {
    if (a1 != 66050)
      return 6;
    SignatureSha384 = AMSupportEcDsaCreateSignatureSha256();
  }
  if (SignatureSha384)
    return 6;
  else
    return 0;
}

uint64_t AMFDRCryptoCreateLocalSignedCertificateData(char a1, _QWORD *a2, _DWORD *a3)
{
  const char *v5;
  size_t v6;
  void *v7;
  uint64_t result;

  if (a2 && a3)
  {
    if ((a1 & 3) == 1)
    {
      v5 = "-----BEGIN CERTIFICATE-----\n"
           "MIIEKTCCAxGgAwIBAgIJAIpZXkx8FEc8MA0GCSqGSIb3DQEBBQUAMIGbMQswCQYD\n"
           "VQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTESMBAGA1UEBwwJQ3VwZXJ0aW5v\n"
           "MRMwEQYDVQQKDApBcHBsZSBJbmMuMQ8wDQYDVQQLDAZDb3JlT1MxFTATBgNVBAMM\n"
           "DEZEUi1MT0NBTC1WMTEmMCQGCSqGSIb3DQEJARYXZmRyLWRldkBncm91cC5hcHBs\n"
           "ZS5jb20wHhcNMjIwNTA5MTUyOTQxWhcNMzIwNTA2MTUyOTQxWjCBmzELMAkGA1UE\n"
           "BhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCUN1cGVydGlubzET\n"
           "MBEGA1UECgwKQXBwbGUgSW5jLjEPMA0GA1UECwwGQ29yZU9TMRUwEwYDVQQDDAxG\n"
           "RFItTE9DQUwtVjExJjAkBgkqhkiG9w0BCQEWF2Zkci1kZXZAZ3JvdXAuYXBwbGUu\n"
           "Y29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqDSCzDVLKL1ti0A5\n"
           "6ddmfyNhDRWpSTQM1eWgkOXeOrmXGuUF0l183cNLHmCDLCQF/gN2ZDOlH/mGv4DU\n"
           "KsVWZ4MV0fmoBUddlXlMH3lYT+4ZvWlH0bp5OX5UmVKxfvKMBl5jKkmANEZYmHu7\n"
           "VFiy3/7S4ca064Lfq1lNefMc0OM9oxulXlAICBwiwxiJKoPOa3/fgdx61lzMnWRa\n"
           "U72XCh8jZdDBJDd5wFgPVGYJMFCbAlgKrEvLPT0Ih9TiWZO97YlnvTeO2PrJtztb\n"
           "c3coQKfq9fOkLL9CyUrMUY4q7IJGBI1z4pB+UBS/ZgJ3/cBNvdhW5is2JVx113hl\n"
           "IskfCQIDAQABo24wbDAdBgNVHQ4EFgQU0QoF+nE1hlJxSQU0TutWjH2N2dUwCQYD\n"
           "VR0TBAIwADALBgNVHQ8EBAMCBeAwGgYJKoZIhvdjZAYQBA0MC3Blcm1pc3Npb25z\n"
           "MBcGCSqGSIb3Y2QGEQQKDAhjbGllbnRpZDANBgkqhkiG9w0BAQUFAAOCAQEAFjVa\n"
           "sSNfZOzLK10c16i06IRkqLx7xRo7ycnbSazwgNLxsGYNqzueBKI634nX4/MkFzgn\n"
           "sIz3rayMogDSgcZmrMe63JmvKJwOWYNFQDs2fTCFNyHBU3lQRL67dddJ8vKKUgPF\n"
           "4zLSbg80sYVkMAxpAjdIxDoXAGZX9ss8l4Z7QtbNHEUZoihXz5dWhjTUHfsNZsG4\n"
           "MxCIO9wniOpG5C/bUquZXq+Q75j4P4fC/KEfC70G/LVXzCTii+vEE6WTz8XhG2Ek\n"
           "oZt6eUiXbC8LjA4Iss8POlr9oTj1y9zsZwdUN7E6/crQhtc68El3XcGWTvveMWIw\n"
           "/Ry4bOUy5w0BVWlJEA==\n"
           "-----END CERTIFICATE-----";
      v6 = 1505;
    }
    else
    {
      if ((a1 & 3) != 2)
        return 9;
      v5 = "-----BEGIN CERTIFICATE-----\n"
           "MIIDzDCCAbSgAwIBAgIGAflWiCu0MA0GCSqGSIb3DQEBCwUAMEcxEzARBgNVBAgM\n"
           "CkNhbGlmb3JuaWExEzARBgNVBAoMCkFwcGxlIEluYy4xGzAZBgNVBAMMEkZEUi1D\n"
           "QTEtUk9PVC1MT0NBTDAeFw0yMjA0MjEwODQ0MTFaFw0zMjA0MTgwODQ0MTFaMEgx\n"
           "CzAJBgNVBAYTAlVTMRMwEQYDVQQKDApBcHBsZSBJbmMuMRAwDgYDVQQLDAdEZXZp\n"
           "Y2VzMRIwEAYDVQQDDAlGRFItTE9DQUwwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNC\n"
           "AATstM3jcCQWuq9Bg83QA8IlrIKWDtWxssWc1c4hdDg/wsmD6Xb+xb45NCRgFnBW\n"
           "SS1+dvn52D3WUU5HVS412NMxo4GHMIGEMFoGCiqGSIb3Y2QGAQ8ETDFK/4T6iZRQ\n"
           "QzBBFgRPQkpQMTn/hKKdplQMMAoWBERHU1SgAgUA/4absdJkDDAKFgRjbGlkoAIF\n"
           "AP+Gy7nmdAwwChYEaW5zdKACBQAwEAYJKoZIhvdjZAYQBAMMASowFAYJKoZIhvdj\n"
           "ZAYRBAcMBUxvY2FsMA0GCSqGSIb3DQEBCwUAA4ICAQBvsxDEZweOcEo10OpMUpx2\n"
           "NZTy4BvSNqKOlv1nHTLqESHYTfik/L3mqTeOoWe20UkMY/e3vKwJWbgavzw7WOxb\n"
           "65bQ+ixU5VQUZzy1XlaQkIW49Tqid1WViSNNlqEXJLTj8lsplpuy5iT/WndNWczq\n"
           "opM3SkdS5YgjAqP4r8qoOAK7pSoMvLd6LTijbp9pTKDTseoXoJsVgPA/LNbW0FvR\n"
           "QxJyVVYkFnN1jtZB2ge5tqpuEuXwyCa/1bC9H8WE49uHyABIzfRaLEs7JbYvIaDH\n"
           "rgcoErGtyADmR/OvhMXryBz+USUG8bZtD/VoCsoIhoJFSVOBNDZXD59arISbjl8q\n"
           "8lbmCloZmocbUPMRinXDbpwMcAfQhv2sV/J6T5+TFAeRdSORhnwnle+56sedvugJ\n"
           "e8QOz85eTifA/KIuSTh+uKkrod3chBgHrh0PvJafOhcmYqhRbqV4guMXi53UrTLi\n"
           "VP68jydKSP2+gLinzYw/J0G/fE88SoWNBcihGjgNrfn8MIAZpVVEQ34PLozWKiXq\n"
           "hZ1VOA54XfeKlNp9Fxuuif0ZNPZ4q7ztbeR3aALN8lVkh/AfmpHNi6oN6LBu0zJw\n"
           "Z9AX2sUNOH0DOOMdojFblTdyuINrt2Tr4ccpHS1htnNR0ro82kZpkJH/zES/oYTA\n"
           "h0Sm4iIj1I5P1NFGq/jR8A==\n"
           "-----END CERTIFICATE-----";
      v6 = 1379;
    }
    v7 = malloc_type_calloc(1uLL, v6, 0x73EAED92uLL);
    *a2 = v7;
    if (v7)
    {
      memcpy(v7, v5, v6);
      result = 0;
      *a3 = v6;
      return result;
    }
  }
  AMSupportLogInternal();
  return 199;
}

uint64_t AMFDRCryptoCopyAttestation(_QWORD *a1)
{
  CFTypeID v2;
  _QWORD *v3;
  uint64_t (*v4)(_QWORD *, _QWORD);

  if (a1 && (v2 = CFGetTypeID(a1), v2 == AMFDRGetTypeID()))
  {
    v3 = (_QWORD *)a1[17];
    if (*v3 >= 0x31uLL)
    {
      v4 = (uint64_t (*)(_QWORD *, _QWORD))v3[6];
      if (v4)
        return v4(a1, a1[18]);
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  return 0;
}

uint64_t AMFDRCryptoCopyRefKeyPub(_QWORD *a1)
{
  CFTypeID v2;
  _QWORD *v3;
  uint64_t (*v4)(_QWORD *, _QWORD);

  if (a1 && (v2 = CFGetTypeID(a1), v2 == AMFDRGetTypeID()))
  {
    v3 = (_QWORD *)a1[17];
    if (*v3 >= 0x29uLL)
    {
      v4 = (uint64_t (*)(_QWORD *, _QWORD))v3[5];
      if (v4)
        return v4(a1, a1[18]);
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  return 0;
}

BOOL AMFDRDigestMd5(uint64_t a1)
{
  if (a1)
  {
    ccmd5_di();
    ccdigest();
  }
  else
  {
    AMSupportLogInternal();
  }
  return a1 != 0;
}

uint64_t FDREncodeReStitchManifest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _DWORD *a6)
{
  uint64_t v6;

  v6 = 1;
  if (a1 && a3 && a5 && a6)
  {
    if (Img4DecodeInit() || Img4EncodeStitchManifest() != 100)
    {
      AMSupportLogInternal();
      return 16;
    }
    else if (*a5 && *a6)
    {
      return 0;
    }
    else
    {
      AMSupportLogInternal();
      return 10;
    }
  }
  return v6;
}

uint64_t FDREncodeCreateCombinedFast(uint64_t a1, int a2, void *a3, unsigned int a4, const void *a5, unsigned int a6, char **a7, _DWORD *a8)
{
  uint64_t result;
  BOOL v16;
  __int128 v17;
  size_t v18;
  void *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  size_t v39;
  char *v40;
  char *v41;
  _BYTE *v42;
  _BYTE *v43;
  _BYTE *v44;
  _BYTE *v45;
  _BYTE *v46;
  _BYTE *v47;
  _BYTE *v48;
  _DWORD *v49;
  _BYTE *v50;
  _BYTE *v51;
  char *v52;
  char *v53;
  char *v54;
  _BYTE *v55;
  char *v56;
  char *v57;
  char **v58;
  _DWORD *v59;
  size_t v60;
  size_t v61;
  size_t __n;
  void *v63;
  const void *v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  _QWORD v68[2];
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  unint64_t v97;
  uint64_t v98;

  v98 = *MEMORY[0x24BDAC8D0];
  v68[0] = 0;
  v66 = 0u;
  v67 = 0u;
  v65 = 0u;
  result = 1;
  if (a1 && a2 && (!a3 || a4))
  {
    v16 = a6 || a5 == 0;
    if (v16 && a7 && a8)
    {
      v97 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v95 = v17;
      v96 = v17;
      v93 = v17;
      v94 = v17;
      v91 = v17;
      v92 = v17;
      v89 = v17;
      v90 = v17;
      v87 = v17;
      v88 = v17;
      v85 = v17;
      v86 = v17;
      v83 = v17;
      v84 = v17;
      v81 = v17;
      v82 = v17;
      v79 = v17;
      v80 = v17;
      v77 = v17;
      v78 = v17;
      v75 = v17;
      v76 = v17;
      v73 = v17;
      v74 = v17;
      v71 = v17;
      v72 = v17;
      v69 = v17;
      v70 = v17;
      if (Img4DecodeInit())
      {
        AMSupportLogInternal();
        return 16;
      }
      if (a3)
        v18 = a4;
      else
        v18 = v71;
      if (a3)
        v19 = a3;
      else
        v19 = (void *)*((_QWORD *)&v70 + 1);
      v20 = _FDREncodeLength(&v65, v18);
      if (!v20)
        return 3;
      v21 = v20;
      v22 = v20 + v18 + v70 + 7;
      v23 = _FDREncodeLength((_BYTE *)&v65 + 8, v22);
      if (!v23)
        return 3;
      v24 = v23;
      v63 = v19;
      v25 = v23 + v22;
      v26 = v23 + v22 + 1;
      v27 = _FDREncodeLength(&v66, v25 + 1);
      if (!v27)
        return 3;
      v28 = v27;
      __n = v18;
      v64 = a5;
      v29 = v26 + v27 + 7;
      v30 = _FDREncodeLength((_BYTE *)&v66 + 8, v29);
      if (!v30)
        return 3;
      v31 = v30;
      v58 = a7;
      v59 = a8;
      if (v64)
      {
        v32 = _FDREncodeLength(&v67, a6);
        if (!v32)
          return 3;
        v33 = a6 + v32 + 7;
        v60 = v32;
      }
      else
      {
        v60 = 0;
        v33 = 6;
      }
      v34 = _FDREncodeLength((_BYTE *)&v67 + 8, v33);
      if (v34)
      {
        v35 = v34;
        v36 = v29 + v31 + v33 + v34 + 8;
        v37 = _FDREncodeLength(v68, v36);
        if (v37)
        {
          v38 = v37;
          v39 = v36 + v37 + 1;
          v40 = (char *)malloc_type_calloc(1uLL, v39, 0x3B2F231uLL);
          if (!v40)
            return 2;
          v41 = v40;
          v61 = v39;
          *v40 = 48;
          v42 = v40 + 1;
          memcpy(v40 + 1, v68, v38);
          v43 = &v42[v38];
          *(_WORD *)v43 = 1046;
          *(_DWORD *)(v43 + 2) = *(_DWORD *)"comb";
          v44 = v43 + 7;
          v43[6] = 48;
          memcpy(v43 + 7, (char *)&v66 + 8, v31);
          v45 = &v44[v31];
          *(_WORD *)v45 = 1046;
          *(_DWORD *)(v45 + 2) = *(_DWORD *)"fdrd";
          v46 = v45 + 7;
          v45[6] = 4;
          memcpy(v45 + 7, &v66, v28);
          v47 = &v46[v28];
          *v47++ = 48;
          memcpy(v47, (char *)&v65 + 8, v24);
          v48 = &v47[v24];
          v49 = (_DWORD *)MEMORY[0x24BEDA2C0];
          *(_WORD *)v48 = 1046;
          *(_DWORD *)(v48 + 2) = *v49;
          v50 = v48 + 6;
          memcpy(v48 + 6, *((const void **)&v69 + 1), v70);
          v51 = &v50[v70];
          *v51++ = -96;
          memcpy(v51, &v65, v21);
          v52 = &v51[v21];
          memcpy(v52, v63, __n);
          v53 = &v52[__n];
          *v53++ = 48;
          memcpy(v53, (char *)&v67 + 8, v35);
          v54 = &v53[v35];
          *(_WORD *)v54 = 1046;
          *(_DWORD *)(v54 + 2) = *(_DWORD *)"secb";
          if (v64)
          {
            v55 = v54 + 7;
            v54[6] = 4;
            memcpy(v54 + 7, &v67, v60);
            v56 = &v55[v60];
            memcpy(v56, v64, a6);
            v57 = &v56[a6];
          }
          else
          {
            v57 = v54 + 6;
          }
          if (&v57[-v61] == v41)
          {
            result = 0;
            *v58 = v41;
            *v59 = v61;
          }
          else
          {
            AMSupportLogInternal();
            free(v41);
            return 10;
          }
          return result;
        }
      }
      return 3;
    }
  }
  return result;
}

_BYTE *_FDREncodeLength(_BYTE *result, unsigned int a2)
{
  _BYTE *v2;
  uint64_t v3;
  BOOL v4;
  _QWORD v5[2];

  v5[1] = *MEMORY[0x24BDAC8D0];
  if (result)
  {
    if (a2 > 0x7F)
    {
      v3 = 0;
      v5[0] = 0;
      do
      {
        *((_BYTE *)v5 + v3++) = a2;
        v4 = a2 > 0xFF;
        a2 >>= 8;
      }
      while (v4);
      LODWORD(v2) = (_DWORD)result;
      if (v3 <= 7)
      {
        *result = v3 | 0x80;
        v2 = result + 1;
        if ((_DWORD)v3)
        {
          do
            *v2++ = *((_BYTE *)&v5[-1] + v3-- + 7);
          while (v3);
        }
      }
    }
    else
    {
      *result = a2;
      LODWORD(v2) = (_DWORD)result + 1;
    }
    return (_BYTE *)((_DWORD)v2 - (_DWORD)result);
  }
  return result;
}

uint64_t FDREncoderAddSequenceProperty(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5;

  if (a1 && a2 && (a3 || !a4) && DEREncoderCreate())
  {
    if (DEREncoderAddDataNoCopy()
      || a3 && DEREncoderAddDataNoCopy()
      || DEREncoderAddSequenceFromEncoder())
    {
      AMSupportLogInternal();
      v5 = 3;
      AMSupportLogInternal();
    }
    else
    {
      v5 = 0;
    }
    DEREncoderDestroy();
  }
  else
  {
    v5 = 3;
    AMSupportLogInternal();
  }
  return v5;
}

uint64_t FDREncodeCreateFDR2Data(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = DEREncoderCreate();
  if (!v8)
    return 2;
  v9 = v8;
  if (DEREncoderAddDataNoCopy())
  {
    v12 = 3;
  }
  else
  {
    v10 = FDREncoderAddSequenceProperty(v9, (uint64_t)"fdrd", a1, a2);
    if ((_DWORD)v10)
    {
      v12 = v10;
    }
    else
    {
      v11 = FDREncoderAddSequenceProperty(v9, (uint64_t)"mft2", a3, a4);
      if (!(_DWORD)v11)
      {
        if (DEREncoderCreate())
        {
          if (DEREncoderAddSequenceFromEncoder() || DEREncoderCreateEncodedBuffer())
          {
            v12 = 3;
            AMSupportLogInternal();
          }
          else
          {
            v12 = 0;
          }
          DEREncoderDestroy();
        }
        else
        {
          AMSupportLogInternal();
          v12 = 2;
        }
        goto LABEL_10;
      }
      v12 = v11;
    }
  }
  AMSupportLogInternal();
LABEL_10:
  DEREncoderDestroy();
  return v12;
}

uint64_t FDREncodeSealingRequest(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  if (!a1)
    return 1;
  v8 = DEREncoderCreate();
  if (!v8)
    return 2;
  v9 = v8;
  v10 = *a1;
  if (!*a1)
  {
    v11 = (uint64_t *)malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
    *a1 = v11;
    if (!v11 || (**a1 = DEREncoderCreate()) == 0)
    {
      v12 = 2;
      goto LABEL_14;
    }
    if (DEREncoderAddData())
    {
      v12 = 3;
      goto LABEL_23;
    }
    v10 = *a1;
  }
  if (!*v10)
    goto LABEL_21;
  v12 = 0;
  if (!a4 || !a5)
    goto LABEL_14;
  v13 = FDREncoderAddSequenceProperty(v9, MEMORY[0x24BEDA2B8], a4, a5);
  if ((_DWORD)v13)
  {
    v12 = v13;
LABEL_23:
    AMSupportLogInternal();
    goto LABEL_14;
  }
  if (DEREncoderAddSequenceFromEncoder())
  {
LABEL_21:
    AMSupportLogInternal();
    v12 = 10;
    goto LABEL_14;
  }
  v12 = 0;
LABEL_14:
  DEREncoderDestroy();
  return v12;
}

uint64_t FDREncodeSealingRequestEnd(_QWORD **a1, _QWORD *a2, _DWORD *a3)
{
  _QWORD *v4;
  uint64_t v6;
  uint64_t v8;

  if (!a1)
    return 1;
  v4 = *a1;
  if (!v4)
    return 1;
  v6 = 1;
  if (a3 && a2 && *v4)
  {
    v8 = DEREncoderCreate();
    v4 = *a1;
    if (v8)
    {
      if (DEREncoderAddSequenceFromEncoder())
      {
        v6 = 3;
      }
      else if (DEREncoderCreateEncodedBuffer())
      {
        v6 = 2;
      }
      else if (*a2)
      {
        if (*a3)
        {
          v6 = 0;
          goto LABEL_12;
        }
        v6 = 10;
      }
      else
      {
        v6 = 10;
      }
      AMSupportLogInternal();
LABEL_12:
      DEREncoderDestroy();
      v4 = *a1;
      if (!*a1)
        return v6;
      goto LABEL_13;
    }
    v6 = 2;
    if (!v4)
      return v6;
  }
LABEL_13:
  if (!*v4 || (DEREncoderDestroy(), **a1 = 0, (v4 = *a1) != 0))
  {
    free(v4);
    *a1 = 0;
  }
  return v6;
}

uint64_t AMFDREncodeProducerIDBegin(_QWORD *a1)
{
  void *v2;

  if (!a1)
    return 1;
  v2 = malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  *a1 = v2;
  if (!v2)
    return 2;
  *(_QWORD *)*a1 = DEREncoderCreate();
  return 2 * (*(_QWORD *)*a1 == 0);
}

uint64_t AMFDREncodeProducerIDAddDigest(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t v3;

  if (!a1 || !*a1)
    return 1;
  v3 = 1;
  if (a3)
  {
    if (a2)
    {
      if (*(_QWORD *)*a1)
      {
        v3 = 0;
        if (DEREncoderAddData())
        {
          v3 = 3;
          AMSupportLogInternal();
        }
      }
    }
  }
  return v3;
}

uint64_t AMFDREncodeProducerIDAddDigestFromData(_QWORD *a1, int *a2, uint64_t a3, unsigned int a4)
{
  void *v8;
  void *v9;
  uint64_t v10;

  v8 = malloc_type_calloc(1uLL, 0x30uLL, 0xB54F4942uLL);
  if (!v8)
    return 2;
  v9 = v8;
  v10 = 1;
  if (a3 && a4)
  {
    if (_FDREncodeDigestCompute(a3, a4, (uint64_t)v8, *(_QWORD *)a2, (unint64_t *)a2))
      v10 = 6;
    else
      v10 = AMFDREncodeProducerIDAddDigest(a1, (uint64_t)v9, *a2);
  }
  free(v9);
  return v10;
}

uint64_t _FDREncodeDigestCompute(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t *a5)
{
  uint64_t result;

  result = 6;
  if (a1 && a2 && a3 && a5 && *a5 <= a4)
  {
    if (DEROidCompare(a5[1], (uint64_t)&oidSha1))
    {
      if (!AMSupportDigestSha1())
        return 0;
    }
    else if (DEROidCompare(a5[1], (uint64_t)&oidSha256))
    {
      if (!AMSupportDigestSha256())
        return 0;
    }
    else
    {
      if (!DEROidCompare(a5[1], (uint64_t)&oidSha384))
        return 4;
      if (!AMSupportDigestSha384())
        return 0;
    }
    return 3;
  }
  return result;
}

uint64_t AMFDREncodeProducerIDEnd(_QWORD **a1, _QWORD *a2, _DWORD *a3)
{
  _QWORD *v4;
  uint64_t v6;
  uint64_t v8;

  if (!a1)
    return 1;
  v4 = *a1;
  if (!v4)
    return 1;
  v6 = 1;
  if (a3 && a2 && *v4)
  {
    v8 = DEREncoderCreate();
    v4 = *a1;
    if (v8)
    {
      if (DEREncoderAddSequenceFromEncoder())
      {
        v6 = 3;
      }
      else if (DEREncoderCreateEncodedBuffer())
      {
        v6 = 2;
      }
      else if (*a2)
      {
        if (*a3)
        {
          v6 = 0;
          goto LABEL_12;
        }
        v6 = 10;
      }
      else
      {
        v6 = 10;
      }
      AMSupportLogInternal();
LABEL_12:
      DEREncoderDestroy();
      v4 = *a1;
      if (!*a1)
        return v6;
      goto LABEL_13;
    }
    v6 = 2;
    if (!v4)
      return v6;
  }
LABEL_13:
  if (!*v4 || (DEREncoderDestroy(), **a1 = 0, (v4 = *a1) != 0))
  {
    free(v4);
    *a1 = 0;
  }
  return v6;
}

uint64_t FDREncodeExtendedProperties(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;
  uint64_t i;
  _QWORD *v14;

  if (!a1)
    return 1;
  result = 101;
  if (a2 && a3 && a4 && a5)
  {
    for (i = 0; i != a2; ++i)
    {
      if (!*(_DWORD *)(a3 + 4 * i) || !*(_QWORD *)(a4 + 8 * i) || !*(_DWORD *)(a5 + 4 * i))
        return 101;
    }
    v14 = *(_QWORD **)a1;
    if (!*(_QWORD *)a1)
    {
      v14 = malloc_type_calloc(1uLL, 0x28uLL, 0x10D004042747809uLL);
      *(_QWORD *)a1 = v14;
    }
    result = 0;
    *(_DWORD *)v14 = a2;
    v14[1] = a3;
    *(_QWORD *)(*(_QWORD *)a1 + 16) = a4;
    *(_QWORD *)(*(_QWORD *)a1 + 24) = a5;
    *(_QWORD *)(*(_QWORD *)a1 + 32) = a6;
  }
  return result;
}

uint64_t FDREncodeCreateSignedManifest()
{
  uint64_t v1;

  if (AMSupportRsaCreateDataFromPem())
  {
    v1 = 3;
    AMSupportLogInternal();
  }
  else if (Img4EncodeCreateManifest() == 100)
  {
    AMSupportLogInternal();
    return 10;
  }
  else
  {
    AMSupportLogInternal();
    return 16;
  }
  return v1;
}

uint64_t _FDREncodeAddManifestProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char *v5;
  char *v6;
  uint64_t i;
  unsigned int *v8;
  unint64_t j;
  int v10;
  uint64_t v11;

  v3 = 101;
  if (!a1)
    goto LABEL_31;
  if (!a2)
    goto LABEL_31;
  if (!a3)
    goto LABEL_31;
  v3 = Img4EncodeItemBegin();
  if ((_DWORD)v3 != 100)
    goto LABEL_31;
  v5 = (char *)malloc_type_malloc(0x20uLL, 0x1D56B548uLL);
  if (!v5)
  {
    AMSupportLogInternal();
    v3 = 2;
LABEL_31:
    Img4EncodeItemDestroy();
    return v3;
  }
  v6 = v5;
  for (i = 0; i != 32; i += 4)
    *(_DWORD *)&v6[i] = arc4random();
  v3 = Img4EncodeItemPropertyData();
  if ((_DWORD)v3 == 100)
  {
    if (!*(_QWORD *)a3 || !*(_DWORD *)(a3 + 8) || (v3 = Img4EncodeItemPropertyData(), (_DWORD)v3 == 100))
    {
      if (!*(_QWORD *)(a3 + 16) || !*(_DWORD *)(a3 + 24) || (v3 = Img4EncodeItemPropertyData(), (_DWORD)v3 == 100))
      {
        v3 = Img4EncodeItemPropertyBool();
        if ((_DWORD)v3 == 100)
        {
          v8 = *(unsigned int **)(a3 + 48);
          if (v8 && *v8)
          {
            for (j = 0; j < *v8; ++j)
            {
              v10 = *(_DWORD *)(*((_QWORD *)v8 + 4) + 4 * j);
              if (v10)
              {
                if (v10 != 1 || *(_DWORD *)(*((_QWORD *)v8 + 3) + 4 * j) != 8)
                {
                  AMSupportLogInternal();
                  v3 = 101;
                  goto LABEL_28;
                }
                v11 = Img4EncodeItemPropertyInt64();
              }
              else
              {
                v11 = Img4EncodeItemPropertyData();
              }
              v3 = v11;
              if ((_DWORD)v11 != 100)
                goto LABEL_28;
              v8 = *(unsigned int **)(a3 + 48);
            }
          }
          v3 = Img4EncodeItemEnd();
          if ((_DWORD)v3 == 100)
            v3 = Img4EncodeItemCopyBuffer();
        }
      }
    }
  }
LABEL_28:
  Img4EncodeItemDestroy();
  free(v6);
  return v3;
}

uint64_t _FDREncodeAddObjectProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = 101;
  if (a1 && a2)
  {
    if (a3)
    {
      if (!*(_DWORD *)(a3 + 32))
      {
LABEL_21:
        v3 = Img4EncodeItemCopyBuffer();
        goto LABEL_22;
      }
      v5 = 0;
      v6 = 0;
      while (1)
      {
        v7 = *(_QWORD *)(a3 + 40);
        v8 = Img4EncodeItemBegin();
        if ((_DWORD)v8 != 100)
          break;
        v8 = Img4EncodeItemPropertyData();
        if ((_DWORD)v8 != 100)
          break;
        v8 = Img4EncodeItemPropertyData();
        if ((_DWORD)v8 != 100)
          break;
        v8 = Img4EncodeItemPropertyData();
        if ((_DWORD)v8 != 100)
          break;
        if (*(_QWORD *)(v7 + v5 + 48))
        {
          v8 = Img4EncodeItemPropertyData();
          if ((_DWORD)v8 != 100)
            break;
        }
        if (*(_QWORD *)(v7 + v5 + 64))
        {
          v8 = Img4EncodeItemPropertyData();
          if ((_DWORD)v8 != 100)
            break;
        }
        if (*(_QWORD *)(v7 + v5 + 80))
        {
          v8 = Img4EncodeItemPropertyData();
          if ((_DWORD)v8 != 100)
            break;
        }
        v8 = Img4EncodeItemEnd();
        if ((_DWORD)v8 != 100)
          break;
        ++v6;
        v5 += 96;
        if (v6 >= *(unsigned int *)(a3 + 32))
          goto LABEL_21;
      }
      v3 = v8;
    }
    AMSupportLogInternal();
  }
LABEL_22:
  Img4EncodeItemDestroy();
  return v3;
}

uint64_t FDREncodeCreateSignedData(uint64_t a1, uint64_t a2, char *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  int *v19;
  __int128 v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t (*v25)(void **, int *, uint64_t);
  uint64_t v26;
  uint64_t DataFromPem;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _OWORD *v32;
  _OWORD v33[19];
  _QWORD v34[3];
  _QWORD *v35;
  char __dst[4];
  char v37;
  int v38;
  void *v39;
  int v40;
  uint64_t v41;
  void *v42;
  int v43;
  void *v44;
  int v45;
  void *v46;
  unsigned int v47;
  void *v48;

  v48 = 0;
  v47 = 0;
  v46 = 0;
  v45 = 0;
  v44 = 0;
  v43 = 0;
  v41 = 0;
  v42 = 0;
  v40 = 0;
  v19 = *(int **)(a1 + 24);
  v39 = 0;
  v38 = 0;
  v37 = 0;
  *(_DWORD *)__dst = 0;
  v35 = 0;
  memset(v34, 170, sizeof(v34));
  *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v33[17] = v20;
  v33[18] = v20;
  v33[15] = v20;
  v33[16] = v20;
  v33[13] = v20;
  v33[14] = v20;
  v33[11] = v20;
  v33[12] = v20;
  v33[9] = v20;
  v33[10] = v20;
  v33[7] = v20;
  v33[8] = v20;
  v33[5] = v20;
  v33[6] = v20;
  v33[3] = v20;
  v33[4] = v20;
  v33[1] = v20;
  v33[2] = v20;
  v33[0] = v20;
  v32 = v33;
  v21 = malloc_type_calloc(1uLL, 0x30uLL, 0xAD7C1F45uLL);
  if (!v21)
  {
    AMSupportLogInternal();
    v22 = 2;
    goto LABEL_13;
  }
  if (a4 == 4)
  {
    strncpy(__dst, a3, 4uLL);
    if (Img4EncodeCreatePayload() == 100)
    {
      if (!v48 || !v47)
        goto LABEL_12;
      v22 = _FDREncodeDigestCompute((uint64_t)v48, v47, (uint64_t)v21, **(_QWORD **)(a1 + 16), *(unint64_t **)(a1 + 16));
      if ((_DWORD)v22)
        goto LABEL_13;
      v23 = AMFDREncodeProducerIDBegin(&v35);
      if ((_DWORD)v23)
      {
        v22 = v23;
LABEL_9:
        AMSupportLogInternal();
        goto LABEL_13;
      }
      v25 = *(uint64_t (**)(void **, int *, uint64_t))(a1 + 40);
      if (!v25)
        goto LABEL_37;
      v26 = v25(&v39, &v38, a2);
      if ((_DWORD)v26)
      {
        v22 = v26;
        goto LABEL_9;
      }
      if (!v39 || !v38)
        goto LABEL_37;
      DataFromPem = AMSupportRsaCreateDataFromPem();
      if ((_DWORD)DataFromPem)
      {
        v22 = DataFromPem;
LABEL_34:
        AMSupportLogInternal();
        goto LABEL_13;
      }
      if (AMFDRDecodeIterateCertChainBegin(v34, (uint64_t)v42, v41)
        || (AMFDRDecodeIterateCertChainNext((uint64_t)v34, &v32, &v40), v28))
      {
LABEL_37:
        AMSupportLogInternal();
LABEL_38:
        v22 = 0;
        goto LABEL_13;
      }
      while (v32)
      {
        v29 = AMFDREncodeProducerIDAddDigestFromData(&v35, v19, *((_QWORD *)v32 + 18), *((_DWORD *)v32 + 38));
        if ((_DWORD)v29
          || (v29 = AMFDREncodeProducerIDAddDigestFromData(&v35, v19, *((_QWORD *)v32 + 32), *((_DWORD *)v32 + 66)),
              (_DWORD)v29))
        {
          v22 = v29;
          goto LABEL_34;
        }
        v22 = AMFDREncodeProducerIDAddDigestFromData(&v35, v19, *((_QWORD *)v32 + 34), *((_DWORD *)v32 + 70));
        if ((_DWORD)v22)
          AMSupportLogInternal();
        AMFDRDecodeIterateCertChainNext((uint64_t)v34, &v32, &v40);
        if (v30)
          goto LABEL_34;
      }
      v31 = AMFDREncodeProducerIDEnd(&v35, &v44, &v43);
      if ((_DWORD)v31)
      {
        v22 = v31;
        goto LABEL_34;
      }
      AMFDRTagsStringToTag((unsigned int *)a3);
      if (!FDREncodeCreateSignedManifest())
      {
        if (!v46 || !v45)
          goto LABEL_12;
        if (Img4EncodeStitchManifest() == 100)
        {
          if (a14 && a15)
            goto LABEL_38;
LABEL_12:
          AMSupportLogInternal();
          v22 = 10;
          goto LABEL_13;
        }
      }
    }
    AMSupportLogInternal();
    v22 = 16;
    goto LABEL_13;
  }
  AMSupportLogInternal();
  v22 = 199;
LABEL_13:
  if (v48)
  {
    free(v48);
    v48 = 0;
  }
  if (v46)
    free(v46);
  if (v44)
  {
    free(v44);
    v44 = 0;
  }
  if (v42)
  {
    free(v42);
    v42 = 0;
  }
  if (v21)
    free(v21);
  if (v39)
  {
    free(v39);
    v39 = 0;
  }
  if (v35)
    AMFDREncodeProducerIDEnd(&v35, &v44, &v43);
  return v22;
}

uint64_t FDREncodeCreateOfflineSignedData(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char *a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  char __dst[4];
  char v25;
  int v26;
  void *v27;
  unsigned int v28;
  void *v29;
  int v30;
  void *v31;

  v29 = 0;
  v28 = 0;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  *(_DWORD *)__dst = 0;
  v18 = malloc_type_calloc(1uLL, 0x30uLL, 0x60B855FCuLL);
  if (!v18)
  {
    AMSupportLogInternal();
    v21 = 0;
    v22 = 0;
LABEL_9:
    v20 = 2;
    goto LABEL_14;
  }
  if (a6 == 4)
  {
    strncpy(__dst, a5, 4uLL);
    if (Img4EncodeCreatePayload() != 100)
    {
      AMSupportLogInternal();
      v21 = 0;
      v22 = 0;
      goto LABEL_11;
    }
    if (!v29 || !v28)
    {
      AMSupportLogInternal();
      v21 = 0;
      v22 = 0;
      goto LABEL_13;
    }
    v19 = _FDREncodeDigestCompute((uint64_t)v29, v28, (uint64_t)v18, **(_QWORD **)(a1 + 16), *(unint64_t **)(a1 + 16));
    if ((_DWORD)v19)
    {
      v20 = v19;
      v21 = 0;
      v22 = 0;
      goto LABEL_14;
    }
    AMFDRTagsStringToTag((unsigned int *)a5);
    v22 = 0;
    if (!a3 || !a4)
    {
LABEL_30:
      v31 = 0;
      v30 = 0;
      if (Img4EncodeCreateManifest() == 100 && (v21 = v31) != 0 && v30)
      {
        if (Img4EncodeStitchManifest() == 100)
        {
          if (a12 && a13)
          {
            v20 = 0;
            goto LABEL_14;
          }
          AMSupportLogInternal();
LABEL_13:
          v20 = 10;
          goto LABEL_14;
        }
        AMSupportLogInternal();
      }
      else
      {
        AMSupportLogInternal();
        if (v31)
          free(v31);
        AMSupportLogInternal();
        v21 = 0;
      }
LABEL_11:
      v20 = 16;
      goto LABEL_14;
    }
    v22 = DEREncoderCreate();
    if (!v22)
      goto LABEL_45;
    if (!DEREncoderAddDataNoCopy())
    {
      if (!DEREncoderCreateEncodedBuffer())
        goto LABEL_30;
      AMSupportLogInternal();
LABEL_45:
      v21 = 0;
      goto LABEL_9;
    }
    v20 = 3;
    AMSupportLogInternal();
    v21 = 0;
  }
  else
  {
    AMSupportLogInternal();
    v21 = 0;
    v22 = 0;
    v20 = 199;
  }
LABEL_14:
  if (v29)
  {
    free(v29);
    v29 = 0;
  }
  if (v21)
    free(v21);
  if (v18)
    free(v18);
  if (v22)
    DEREncoderDestroy();
  if (v27)
    free(v27);
  return v20;
}

uint64_t AMFDREncodeMultiRequestBegin(uint64_t a1, int a2)
{
  void *v3;
  uint64_t v4;

  if (!a2)
    return 1;
  v3 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
  *(_QWORD *)a1 = v3;
  if (v3
    && (**(_QWORD **)a1 = DEREncoderCreate()) != 0
    && (*(_QWORD *)(*(_QWORD *)a1 + 8) = DEREncoderCreate()) != 0
    && (*(_QWORD *)(*(_QWORD *)a1 + 16) = DEREncoderCreate()) != 0)
  {
    v4 = 0;
    if (DEREncoderAddData())
    {
      v4 = 3;
      AMSupportLogInternal();
    }
  }
  else
  {
    AMSupportLogInternal();
    return 2;
  }
  return v4;
}

uint64_t AMFDREncodeMultiRequestAddRecord(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7)
{
  uint64_t v7;

  if (!a1 || !*(_QWORD *)a1)
    return 1;
  v7 = 1;
  if (a3 && a2 && *(_QWORD *)(*(_QWORD *)a1 + 16))
  {
    if (a4)
    {
      if (!a5)
        goto LABEL_32;
    }
    else if (a5)
    {
      goto LABEL_32;
    }
    if (a6)
    {
      if (!a7)
        goto LABEL_32;
LABEL_14:
      if (DEREncoderCreate())
      {
        if (DEREncoderCreate())
        {
          if (DEREncoderAddDataNoCopy()
            || a4 && (DEREncoderAddDataNoCopy() || DEREncoderAddDataFromEncoder())
            || a6 && DEREncoderAddDataNoCopy()
            || DEREncoderAddSequenceFromEncoder())
          {
            v7 = 3;
            AMSupportLogInternal();
          }
          else
          {
            v7 = 0;
          }
          DEREncoderDestroy();
          DEREncoderDestroy();
          return v7;
        }
        AMSupportLogInternal();
        DEREncoderDestroy();
      }
      else
      {
        AMSupportLogInternal();
      }
      return 2;
    }
    if (!a7)
      goto LABEL_14;
LABEL_32:
    AMSupportLogInternal();
  }
  return v7;
}

uint64_t AMFDREncodeMultiRequestEnd(_QWORD *a1, _QWORD *a2, _DWORD *a3)
{
  _QWORD *v4;
  uint64_t v6;

  if (!a1 || (v4 = (_QWORD *)*a1) == 0 || !*v4 || !v4[1])
  {
    v6 = 1;
    goto LABEL_17;
  }
  v6 = 1;
  if (a3 && a2 && v4[2])
  {
    if (!DEREncoderCreate())
    {
      AMSupportLogInternal();
      v6 = 2;
      goto LABEL_17;
    }
    if (DEREncoderAddSetFromEncoder())
    {
      v6 = 3;
    }
    else if (DEREncoderAddSequenceFromEncoder() || DEREncoderAddSequenceFromEncoder())
    {
      v6 = 3;
    }
    else if (DEREncoderCreateEncodedBuffer())
    {
      v6 = 3;
    }
    else if (*a2)
    {
      if (*a3)
      {
        v6 = 0;
LABEL_16:
        DEREncoderDestroy();
        goto LABEL_17;
      }
      v6 = 199;
    }
    else
    {
      v6 = 199;
    }
    AMSupportLogInternal();
    goto LABEL_16;
  }
LABEL_17:
  AMFDREncodeMultiRequestDestroy((uint64_t)a1);
  return v6;
}

void AMFDREncodeMultiRequestDestroy(uint64_t a1)
{
  _QWORD *v2;

  if (a1)
  {
    v2 = *(_QWORD **)a1;
    if (v2)
    {
      if (*v2)
      {
        DEREncoderDestroy();
        **(_QWORD **)a1 = 0;
        v2 = *(_QWORD **)a1;
      }
      if (v2[1])
      {
        DEREncoderDestroy();
        *(_QWORD *)(*(_QWORD *)a1 + 8) = 0;
        v2 = *(_QWORD **)a1;
      }
      if (!v2[2] || (DEREncoderDestroy(), *(_QWORD *)(*(_QWORD *)a1 + 16) = 0, (v2 = *(_QWORD **)a1) != 0))
        free(v2);
      *(_QWORD *)a1 = 0;
    }
  }
}

uint64_t AMFDREncodeMultiResponseBegin(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
  *(_QWORD *)a1 = v2;
  if (v2
    && (**(_QWORD **)a1 = DEREncoderCreate()) != 0
    && (*(_QWORD *)(*(_QWORD *)a1 + 8) = DEREncoderCreate()) != 0
    && (*(_QWORD *)(*(_QWORD *)a1 + 16) = DEREncoderCreate()) != 0)
  {
    v3 = 0;
    if (DEREncoderAddData())
    {
      v3 = 3;
      AMSupportLogInternal();
    }
  }
  else
  {
    AMSupportLogInternal();
    return 2;
  }
  return v3;
}

uint64_t AMFDREncodeMultiResponseAddRecord(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, uint64_t a8, int a9)
{
  uint64_t v9;

  if (!a1 || !*(_QWORD *)a1)
    return 1;
  v9 = 1;
  if (a5 && a4 && a3 && a2 && *(_QWORD *)(*(_QWORD *)a1 + 16))
  {
    if (a6)
    {
      if (!a7)
        goto LABEL_33;
    }
    else if (a7)
    {
LABEL_33:
      AMSupportLogInternal();
      return v9;
    }
    if (a8)
    {
      if (!a9)
        goto LABEL_34;
    }
    else if (a9)
    {
LABEL_34:
      AMSupportLogInternal();
      return 1;
    }
    if (DEREncoderCreate())
    {
      if (DEREncoderCreate())
      {
        if (DEREncoderAddDataNoCopy()
          || DEREncoderAddDataNoCopy()
          || DEREncoderAddDataFromEncoder()
          || a6 && DEREncoderAddDataNoCopy()
          || a8 && DEREncoderAddDataNoCopy()
          || DEREncoderAddSequenceFromEncoder())
        {
          v9 = 3;
          AMSupportLogInternal();
        }
        else
        {
          v9 = 0;
        }
        DEREncoderDestroy();
        DEREncoderDestroy();
        return v9;
      }
      AMSupportLogInternal();
      DEREncoderDestroy();
    }
    else
    {
      AMSupportLogInternal();
    }
    return 2;
  }
  return v9;
}

uint64_t AMFDREncodeMultiResponseEnd(uint64_t *a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v4;
  uint64_t v6;

  if (!a1 || (v4 = *a1) == 0 || !*(_QWORD *)(v4 + 8))
  {
    v6 = 1;
    goto LABEL_19;
  }
  v6 = 1;
  if (a3 && a2 && *(_QWORD *)(v4 + 16))
  {
    if (!DEREncoderCreate())
    {
      AMSupportLogInternal();
      v6 = 2;
      goto LABEL_19;
    }
    if (!DEREncoderCreate())
    {
      AMSupportLogInternal();
      v6 = 2;
      goto LABEL_18;
    }
    if (DEREncoderAddSetFromEncoder())
    {
      v6 = 3;
    }
    else if (DEREncoderAddDataFromEncoder())
    {
      v6 = 3;
    }
    else if (DEREncoderAddSequenceFromEncoder() || DEREncoderAddSequenceFromEncoder())
    {
      v6 = 3;
    }
    else if (DEREncoderCreateEncodedBuffer())
    {
      v6 = 3;
    }
    else if (*a2)
    {
      if (*a3)
      {
        v6 = 0;
LABEL_17:
        DEREncoderDestroy();
LABEL_18:
        DEREncoderDestroy();
        goto LABEL_19;
      }
      v6 = 199;
    }
    else
    {
      v6 = 199;
    }
    AMSupportLogInternal();
    goto LABEL_17;
  }
LABEL_19:
  AMFDREncodeMultiRequestDestroy((uint64_t)a1);
  return v6;
}

uint64_t AMFDREncodeMetadataBegin(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t result;

  v2 = malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  *a1 = v2;
  if (!v2 || (v3 = DEREncoderCreate(), result = 0, (*(_QWORD *)*a1 = v3) == 0))
  {
    AMSupportLogInternal();
    return 2;
  }
  return result;
}

uint64_t AMFDREncodeMetadataAddRecord(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;

  if (!a1 || !*a1)
    return 1;
  v5 = 1;
  if (a3 && a2 && *(_QWORD *)*a1)
  {
    if (a4)
    {
      if (!a5)
        goto LABEL_21;
    }
    else if (a5)
    {
LABEL_21:
      AMSupportLogInternal();
      return v5;
    }
    if (DEREncoderCreate())
    {
      if (DEREncoderAddDataNoCopy()
        || a4 && DEREncoderAddDataNoCopy()
        || DEREncoderAddSequenceFromEncoder())
      {
        v5 = 3;
        AMSupportLogInternal();
      }
      else
      {
        v5 = 0;
      }
      DEREncoderDestroy();
    }
    else
    {
      AMSupportLogInternal();
      return 2;
    }
  }
  return v5;
}

uint64_t AMFDREncodeMetadataEnd(_QWORD **a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v5;

  if (!a1 || !*a1)
  {
    v5 = 1;
    goto LABEL_13;
  }
  v5 = 1;
  if (a3 && a2 && **a1)
  {
    if (!DEREncoderCreate())
    {
      AMSupportLogInternal();
      v5 = 2;
      goto LABEL_13;
    }
    if (DEREncoderAddSetFromEncoder())
    {
      v5 = 3;
    }
    else if (DEREncoderCreateEncodedBuffer())
    {
      v5 = 3;
    }
    else if (*a2)
    {
      if (*a3)
      {
        v5 = 0;
LABEL_12:
        DEREncoderDestroy();
        goto LABEL_13;
      }
      v5 = 199;
    }
    else
    {
      v5 = 199;
    }
    AMSupportLogInternal();
    goto LABEL_12;
  }
LABEL_13:
  AMFDREncodeMetadataDestroy(a1);
  return v5;
}

void AMFDREncodeMetadataDestroy(_QWORD **a1)
{
  _QWORD *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      if (!*v2 || (DEREncoderDestroy(), **a1 = 0, (v2 = *a1) != 0))
        free(v2);
      *a1 = 0;
    }
  }
}

uint64_t AMFDREncodeMetaPropertyBegin(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t result;

  v2 = malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  *a1 = v2;
  if (!v2 || (v3 = DEREncoderCreate(), result = 0, (*(_QWORD *)*a1 = v3) == 0))
  {
    AMSupportLogInternal();
    return 2;
  }
  return result;
}

uint64_t AMFDREncodeMetaPropertyAddData(int a1, _QWORD *a2, uint64_t a3, int a4)
{
  uint64_t v4;

  if (!a2 || !*a2 || !*(_QWORD *)*a2)
    return 1;
  if (a1)
    return 0;
  if (a3)
  {
    if (a4)
    {
      v4 = 0;
      if (!DEREncoderAddData())
        return v4;
      v4 = 3;
    }
    else
    {
      v4 = 1;
    }
LABEL_15:
    AMSupportLogInternal();
    return v4;
  }
  if (a4)
  {
    v4 = 1;
    goto LABEL_15;
  }
  return 0;
}

uint64_t AMFDREncodeMetaPropertyEnd(_QWORD **a1, uint64_t a2, uint64_t a3, _QWORD *a4, _DWORD *a5)
{
  uint64_t v7;
  uint64_t v9;

  if (!a1 || !*a1)
  {
    v7 = 1;
    goto LABEL_19;
  }
  v7 = 1;
  if (!a5 || !a4 || !**a1)
    goto LABEL_19;
  if (!DEREncoderCreate())
  {
    AMSupportLogInternal();
    v7 = 2;
    goto LABEL_19;
  }
  if (DEREncoderAddDataNoCopy())
  {
    v7 = 3;
LABEL_25:
    AMSupportLogInternal();
    goto LABEL_18;
  }
  if (DEREncoderAddSequenceFromEncoder())
  {
    v7 = 3;
    goto LABEL_25;
  }
  if (!DEREncoderCreate())
  {
    v7 = 2;
    goto LABEL_25;
  }
  if (DEREncoderAddSequenceFromEncoder())
  {
    v9 = 0;
LABEL_27:
    v7 = 3;
    goto LABEL_32;
  }
  v9 = DEREncoderCreate();
  if (!v9)
  {
    v7 = 2;
    goto LABEL_32;
  }
  if (DEREncoderAddSequenceFromEncoder())
    goto LABEL_27;
  if (DEREncoderCreateEncodedBuffer())
  {
    v7 = 3;
  }
  else if (*a4)
  {
    if (*a5)
    {
      v7 = 0;
      goto LABEL_17;
    }
    v7 = 199;
  }
  else
  {
    v7 = 199;
  }
LABEL_32:
  AMSupportLogInternal();
LABEL_17:
  DEREncoderDestroy();
  DEREncoderDestroy();
  if (v9)
LABEL_18:
    DEREncoderDestroy();
LABEL_19:
  AMFDREncodeMetadataDestroy(a1);
  return v7;
}

uint64_t AMFDREncodeCreateOfflineBlob(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int a6, _QWORD *a7, _DWORD *a8)
{
  uint64_t result;
  uint64_t v12;

  result = 1;
  if (a1 && a2 && a3 && a4 && a5 && a6 && a7 && a8)
  {
    if (DEREncoderCreate())
    {
      if (DEREncoderCreate())
      {
        if (DEREncoderAddDataNoCopy())
        {
          v12 = 3;
        }
        else if (DEREncoderAddDataNoCopy())
        {
          v12 = 3;
        }
        else if (DEREncoderAddDataNoCopy() || DEREncoderAddSequenceFromEncoder())
        {
          v12 = 3;
        }
        else if (DEREncoderCreateEncodedBuffer())
        {
          v12 = 3;
        }
        else if (*a7)
        {
          if (*a8)
          {
            v12 = 0;
LABEL_19:
            DEREncoderDestroy();
            DEREncoderDestroy();
            return v12;
          }
          v12 = 199;
        }
        else
        {
          v12 = 199;
        }
        AMSupportLogInternal();
        goto LABEL_19;
      }
      AMSupportLogInternal();
      DEREncoderDestroy();
    }
    else
    {
      AMSupportLogInternal();
    }
    return 2;
  }
  return result;
}

uint64_t AMFDREncodeCertificateRequestBegin(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t result;

  if (!a1)
    return 1;
  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
  *(_QWORD *)a1 = v2;
  if (!v2
    || (**(_QWORD **)a1 = DEREncoderCreate()) == 0
    || (*(_QWORD *)(*(_QWORD *)a1 + 8) = DEREncoderCreate()) == 0
    || (v3 = DEREncoderCreate(), result = 0, (*(_QWORD *)(*(_QWORD *)a1 + 16) = v3) == 0))
  {
    AMSupportLogInternal();
    return 2;
  }
  return result;
}

uint64_t AMFDREncodeCertificateRequestAddSubject(uint64_t a1, char *a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  int v7;
  void *v8;
  int v10;
  void *v11;

  v11 = 0;
  v10 = 0;
  v5 = 1;
  if (a1 && a2 && a3 && a4 && a5)
  {
    if (DEREncoderCreate())
    {
      if (DEREncoderCreate())
      {
        v7 = _FDREncodeCreateDataFromOid(a2, &v11, &v10);
        v8 = v11;
        if (v7)
        {
          v5 = 3;
        }
        else if (DEREncoderAddDataNoCopy()
               || DEREncoderAddDataNoCopy()
               || DEREncoderAddSequenceFromEncoder()
               || DEREncoderAddSetFromEncoder())
        {
          v5 = 3;
          AMSupportLogInternal();
        }
        else
        {
          v5 = 0;
        }
        if (v8)
          free(v8);
        DEREncoderDestroy();
      }
      else
      {
        AMSupportLogInternal();
        v5 = 2;
      }
      DEREncoderDestroy();
    }
    else
    {
      AMSupportLogInternal();
      return 2;
    }
  }
  return v5;
}

uint64_t _FDREncodeCreateDataFromOid(char *a1, _QWORD *a2, _DWORD *a3)
{
  _BYTE *v6;
  _BYTE *v7;
  size_t v8;
  void *v9;
  size_t v10;
  char *v11;
  char *v12;
  int v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  char v17;
  int v18;
  int v19;
  uint64_t v20;
  int i;
  BOOL v22;
  uint64_t v23;
  char *__lasts;

  __lasts = a1;
  v6 = malloc_type_malloc(0x100uLL, 0x4D0B734DuLL);
  if (!v6)
  {
    AMSupportLogInternal();
    return 2;
  }
  v7 = v6;
  v8 = strlen(a1);
  v9 = malloc_type_malloc(v8 + 1, 0x67518CEEuLL);
  if (!v9)
  {
    AMSupportLogInternal();
    v23 = 2;
    goto LABEL_24;
  }
  v10 = strlen(a1);
  memcpy(v9, a1, v10 + 1);
  v11 = strtok_r((char *)v9, ".", &__lasts);
  if (v11)
  {
    v12 = v11;
    v13 = 0;
    v14 = 0;
    while (1)
    {
      *__error() = 0;
      v15 = strtoul(v12, 0, 10);
      if (*__error() || HIDWORD(v15))
        break;
      if (v13)
      {
        if (v13 != 1)
        {
          v16 = 0;
          v17 = 0;
          v18 = 0;
          v19 = v14;
          while (1)
          {
            v20 = v16;
            for (i = v19; v20; --v20)
            {
              v7[i] = v7[i - 1];
              --i;
            }
            v7[v14] = v15 & 0x7F | v17;
            if ((++v18 + v14) >= 0x100)
              goto LABEL_23;
            ++v16;
            ++v19;
            v17 = 0x80;
            v22 = v15 >= 0x80;
            v15 >>= 7;
            if (!v22)
            {
              v14 += v18;
              goto LABEL_17;
            }
          }
        }
        v7[v14] = v15 + 40 * v7[v14];
        ++v14;
      }
      else
      {
        v7[v14] = v15;
      }
LABEL_17:
      ++v13;
      v12 = strtok_r(0, ".", &__lasts);
      if (!v12)
        goto LABEL_20;
    }
LABEL_23:
    v23 = 3;
    AMSupportLogInternal();
LABEL_24:
    free(v7);
    if (!v9)
      return v23;
    goto LABEL_21;
  }
  v14 = 0;
LABEL_20:
  v23 = 0;
  *a2 = v7;
  *a3 = v14;
LABEL_21:
  free(v9);
  return v23;
}

uint64_t AMFDREncodeCertificateRequestAddAttribute(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  int v13;
  void *v14;
  int v16;
  void *v17;
  int v18;
  void *v19;

  v6 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v7 = 1;
  if (!a1 || !a2 || !a4)
  {
    v9 = 0;
    v10 = 0;
    goto LABEL_20;
  }
  v9 = 0;
  v10 = 0;
  if (!a5)
    goto LABEL_20;
  v10 = DEREncoderCreate();
  if (!v10)
  {
    AMSupportLogInternal();
    v6 = 0;
    v9 = 0;
LABEL_33:
    v7 = 2;
    goto LABEL_20;
  }
  v9 = DEREncoderCreate();
  if (!v9)
  {
    AMSupportLogInternal();
    v6 = 0;
    goto LABEL_33;
  }
  v6 = DEREncoderCreate();
  if (!v6)
  {
    AMSupportLogInternal();
    goto LABEL_33;
  }
  v13 = _FDREncodeCreateDataFromOid(a2, &v17, &v16);
  v14 = v17;
  if (v13)
  {
    v7 = 3;
  }
  else if (DEREncoderAddDataNoCopy()
         || a6 && DEREncoderAddBoolean()
         || !a3 && (DEREncoderAddDataNoCopy() || DEREncoderCreateEncodedBuffer())
         || DEREncoderAddDataNoCopy()
         || DEREncoderAddSequenceFromEncoder())
  {
    v7 = 3;
    AMSupportLogInternal();
  }
  else
  {
    v7 = 0;
  }
  if (v14)
    free(v14);
LABEL_20:
  if (v19)
  {
    free(v19);
    v19 = 0;
  }
  if (v10)
    DEREncoderDestroy();
  if (v9)
    DEREncoderDestroy();
  if (v6)
    DEREncoderDestroy();
  return v7;
}

uint64_t AMFDREncodeCertificateRequestCreateUnsginedData(uint64_t a1, const void *a2, unsigned int a3, char *a4, char *a5, _QWORD *a6, _DWORD *a7)
{
  uint64_t v7;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v17;
  void *v18;
  int v19;
  int v20;
  uint64_t v21;
  int EncodedBuffer;
  uint64_t v23;
  int v25;
  unsigned int v27;
  int v29;
  void *v30;
  char v31;
  void *v32;
  int v33;

  v7 = 0;
  v31 = 2;
  v30 = 0;
  v29 = 0;
  v27 = 1;
  if (!a1 || !a2 || !a3 || !a4 || !a6)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    goto LABEL_45;
  }
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if (!a7)
    goto LABEL_45;
  v14 = DEREncoderCreate();
  if (!v14)
  {
    AMSupportLogInternal();
    v7 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
LABEL_69:
    v25 = 2;
LABEL_74:
    v27 = v25;
LABEL_45:
    v23 = v27;
    if (!v14)
      goto LABEL_47;
    goto LABEL_46;
  }
  v13 = DEREncoderCreate();
  if (!v13)
  {
    AMSupportLogInternal();
    v7 = 0;
    v11 = 0;
    v12 = 0;
    goto LABEL_69;
  }
  v12 = DEREncoderCreate();
  if (!v12)
  {
    AMSupportLogInternal();
    v7 = 0;
    v11 = 0;
    goto LABEL_69;
  }
  v11 = DEREncoderCreate();
  if (!v11)
  {
    AMSupportLogInternal();
    v7 = 0;
    goto LABEL_69;
  }
  v7 = DEREncoderCreate();
  if (!v7)
    goto LABEL_68;
  if (DEREncoderAddDataNoCopy() || DEREncoderAddSequenceFromEncoder())
    goto LABEL_44;
  v17 = _FDREncodeCreateDataFromOid(a4, &v30, &v29);
  v18 = v30;
  if (v17)
  {
LABEL_71:
    if (v18)
    {
      free(v18);
      v30 = 0;
    }
    v25 = 3;
    goto LABEL_74;
  }
  if (DEREncoderAddData())
    goto LABEL_70;
  if (v18)
  {
    free(v18);
    v30 = 0;
  }
  if (!a5)
  {
    if (!DEREncoderAddDataNoCopy())
      goto LABEL_24;
LABEL_44:
    v27 = 3;
    AMSupportLogInternal();
    goto LABEL_45;
  }
  v19 = _FDREncodeCreateDataFromOid(a5, &v30, &v29);
  v18 = v30;
  if (v19)
    goto LABEL_71;
  if (DEREncoderAddData())
  {
LABEL_70:
    AMSupportLogInternal();
    goto LABEL_71;
  }
  if (v18)
  {
    free(v18);
    v30 = 0;
  }
LABEL_24:
  if (DEREncoderAddSequenceFromEncoder()
    || AMFDREncodeAddBitString(v12, a2, a3)
    || DEREncoderAddSequenceFromEncoder())
  {
    goto LABEL_44;
  }
  DEREncoderDestroy();
  v13 = DEREncoderCreate();
  if (!v13)
  {
LABEL_68:
    AMSupportLogInternal();
    goto LABEL_69;
  }
  v20 = _FDREncodeCreateDataFromOid("1.2.840.113549.1.9.14", &v30, &v29);
  v18 = v30;
  if (v20)
    goto LABEL_71;
  if (DEREncoderAddData())
    goto LABEL_70;
  if (v18)
  {
    free(v18);
    v30 = 0;
  }
  v21 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  v33 = 0;
  v32 = 0;
  if (!v21)
    goto LABEL_44;
  EncodedBuffer = DEREncoderCreateEncodedBuffer();
  if (!EncodedBuffer)
    EncodedBuffer = DEREncoderAddData();
  if (v32)
    free(v32);
  if (EncodedBuffer
    || DEREncoderAddSetFromEncoder()
    || DEREncoderAddSequenceFromEncoder()
    || DEREncoderAddDataFromEncoder()
    || DEREncoderAddSequenceFromEncoder()
    || DEREncoderCreateEncodedBuffer())
  {
    goto LABEL_44;
  }
  v23 = 0;
  *a6 = 0;
  *a7 = 0;
LABEL_46:
  DEREncoderDestroy();
LABEL_47:
  if (v13)
    DEREncoderDestroy();
  if (v12)
    DEREncoderDestroy();
  if (v11)
    DEREncoderDestroy();
  if (v7)
    DEREncoderDestroy();
  return v23;
}

uint64_t AMFDREncodeAddBitString(uint64_t a1, const void *a2, unsigned int a3)
{
  _BYTE *v5;
  void *v6;
  uint64_t v7;

  v5 = malloc_type_malloc(a3 + 1, 0x3D5FB60BuLL);
  if (!v5)
    return 2;
  v6 = v5;
  *v5 = 0;
  memcpy(v5 + 1, a2, a3);
  v7 = DEREncoderAddData();
  free(v6);
  return v7;
}

uint64_t AMFDREncodeCertificateRequestEnd(uint64_t a1, const void *a2, unsigned int a3, char *a4, char *a5, char a6, _QWORD *a7, _DWORD *a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v16;
  int v19;
  void *v20;
  int v21;
  int v24;
  void *v25;

  v8 = a1;
  v9 = 0;
  v25 = 0;
  v24 = 0;
  v10 = 1;
  if (!a1 || !a2 || !a3 || !a4 || !a7)
  {
    v16 = 0;
    goto LABEL_40;
  }
  v16 = 0;
  if (!a8)
    goto LABEL_40;
  v16 = DEREncoderCreate();
  if (!v16)
  {
    AMSupportLogInternal();
    v9 = 0;
LABEL_32:
    v10 = 2;
LABEL_33:
    v8 = a1;
    goto LABEL_40;
  }
  v9 = DEREncoderCreate();
  if (!v9)
  {
    AMSupportLogInternal();
    goto LABEL_32;
  }
  v19 = _FDREncodeCreateDataFromOid(a4, &v25, &v24);
  v20 = v25;
  if (v19)
    goto LABEL_37;
  if (DEREncoderAddData())
  {
LABEL_36:
    AMSupportLogInternal();
    goto LABEL_37;
  }
  if (v20)
  {
    free(v20);
    v25 = 0;
  }
  if (a5)
  {
    v21 = _FDREncodeCreateDataFromOid(a5, &v25, &v24);
    v20 = v25;
    if (!v21)
    {
      if (!DEREncoderAddData())
      {
        if (v20)
        {
          free(v20);
          v25 = 0;
        }
        goto LABEL_20;
      }
      goto LABEL_36;
    }
LABEL_37:
    v8 = a1;
    if (v20)
    {
      free(v20);
      v25 = 0;
    }
    v10 = 3;
    goto LABEL_40;
  }
  if ((a6 & 1) == 0 && DEREncoderAddDataNoCopy())
  {
    v10 = 3;
    AMSupportLogInternal();
    goto LABEL_33;
  }
LABEL_20:
  v8 = a1;
  if (!DEREncoderAddSequenceFromEncoder()
    && !AMFDREncodeAddBitString(*(_QWORD *)(*(_QWORD *)a1 + 16), a2, a3)
    && !DEREncoderAddSequenceFromEncoder()
    && !DEREncoderCreateEncodedBuffer())
  {
    v10 = 0;
    *a7 = 0;
    *a8 = 0;
LABEL_25:
    DEREncoderDestroy();
    goto LABEL_26;
  }
  v10 = 3;
  AMSupportLogInternal();
LABEL_40:
  if (v16)
    goto LABEL_25;
LABEL_26:
  if (v9)
    DEREncoderDestroy();
  AMFDREncodeMultiRequestDestroy(v8);
  return v10;
}

uint64_t AMFDREncodeCreatePayloadAndDigest(uint64_t a1, const char *a2, int a3, uint64_t a4, uint64_t a5, void **a6, unsigned int *a7, _QWORD *a8, _DWORD *a9)
{
  void *v15;
  uint64_t v16;
  char __dst[4];
  char v19;
  unsigned int v20;
  void *v21;

  v21 = 0;
  v20 = 0;
  v19 = 0;
  *(_DWORD *)__dst = 0;
  v15 = malloc_type_calloc(1uLL, 0x30uLL, 0x2DE0F186uLL);
  if (v15)
  {
    if (a3 == 4)
    {
      strncpy(__dst, a2, 4uLL);
      if (Img4EncodeCreatePayload() == 100)
      {
        if (v21
          && v20
          && !_FDREncodeDigestCompute((uint64_t)v21, v20, (uint64_t)v15, **(_QWORD **)(a1 + 16), *(unint64_t **)(a1 + 16)))
        {
          if (a6 && a7)
          {
            *a6 = v21;
            *a7 = v20;
            v21 = 0;
          }
          v16 = 0;
          if (a8 && a9)
          {
            v16 = 0;
            *a8 = v15;
            *a9 = **(_QWORD **)(a1 + 16);
            v15 = 0;
          }
        }
        else
        {
          AMSupportLogInternal();
          v16 = 10;
        }
      }
      else
      {
        AMSupportLogInternal();
        v16 = 16;
      }
    }
    else
    {
      AMSupportLogInternal();
      v16 = 199;
    }
  }
  else
  {
    AMSupportLogInternal();
    v16 = 2;
  }
  if (v21)
    free(v21);
  if (v15)
    free(v15);
  return v16;
}

uint64_t AMFDREncodeRepairConfigurationBegin(_QWORD *a1)
{
  void *v2;
  uint64_t v3;

  if (!a1)
  {
    v3 = 1;
LABEL_8:
    AMSupportLogInternal();
    return v3;
  }
  v2 = malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  *a1 = v2;
  if (!v2)
  {
    v3 = 2;
    goto LABEL_8;
  }
  v3 = 0;
  *(_QWORD *)*a1 = DEREncoderCreate();
  if (!*(_QWORD *)*a1)
  {
    v3 = 2;
    goto LABEL_8;
  }
  return v3;
}

uint64_t AMFDREncodeRepairConfigurationAddSequence(uint64_t **a1, uint64_t **a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if ((_AMFDREncodeIsRepairConfigurationContextValid(a1) & 1) != 0
    && (v4 = **a1, (_AMFDREncodeIsRepairConfigurationContextValid(a2) & 1) != 0))
  {
    if (a1 == a2)
    {
      v5 = DEREncoderCreate();
      if (!v5)
      {
        AMSupportLogInternal();
        return 2;
      }
      v6 = v5;
      if (DEREncoderAddSequenceFromEncoder())
      {
        DEREncoderDestroy();
LABEL_15:
        v7 = 3;
        AMSupportLogInternal();
        return v7;
      }
      **a1 = v6;
      if (v4)
        DEREncoderDestroy();
    }
    else if (DEREncoderAddSequenceFromEncoder())
    {
      goto LABEL_15;
    }
    return 0;
  }
  else
  {
    AMSupportLogInternal();
    return 1;
  }
}

uint64_t _AMFDREncodeIsRepairConfigurationContextValid(_QWORD *a1)
{
  if (a1 && *a1 && *(_QWORD *)*a1)
    return 1;
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDREncodeRepairConfigurationAddSequenceWithKey(uint64_t **a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if ((_AMFDREncodeIsRepairConfigurationContextValid(a1) & 1) != 0)
  {
    v2 = **a1;
    v3 = DEREncoderCreate();
    if (v3)
    {
      v4 = v3;
      if (DEREncoderAddDataNoCopy() || DEREncoderAddSequenceFromEncoder())
      {
        DEREncoderDestroy();
        v5 = 3;
        AMSupportLogInternal();
      }
      else
      {
        **a1 = v4;
        if (v2)
          DEREncoderDestroy();
        return 0;
      }
    }
    else
    {
      AMSupportLogInternal();
      return 2;
    }
  }
  else
  {
    AMSupportLogInternal();
    return 1;
  }
  return v5;
}

uint64_t AMFDREncodeRepairConfigurationAddSetWithKey(uint64_t **a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if ((_AMFDREncodeIsRepairConfigurationContextValid(a1) & 1) != 0)
  {
    v2 = **a1;
    v3 = DEREncoderCreate();
    if (v3)
    {
      v4 = v3;
      if (DEREncoderAddDataNoCopy() || DEREncoderAddSetFromEncoder())
      {
        DEREncoderDestroy();
        v5 = 3;
        AMSupportLogInternal();
      }
      else
      {
        **a1 = v4;
        if (v2)
          DEREncoderDestroy();
        return 0;
      }
    }
    else
    {
      AMSupportLogInternal();
      return 2;
    }
  }
  else
  {
    AMSupportLogInternal();
    return 1;
  }
  return v5;
}

uint64_t AMFDREncodeRepairConfigurationAddData(_QWORD *a1, int a2, uint64_t a3, int a4)
{
  uint64_t v7;

  if ((_AMFDREncodeIsRepairConfigurationContextValid(a1) & 1) != 0 && a4 && a3)
  {
    switch(a2)
    {
      case 0:
      case 1:
      case 2:
        if (!DEREncoderAddData())
          goto LABEL_7;
        goto LABEL_10;
      case 3:
        if (DEREncoderAddUInt32())
        {
LABEL_10:
          v7 = 3;
          AMSupportLogInternal();
        }
        else
        {
LABEL_7:
          v7 = 0;
        }
        break;
      default:
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    AMSupportLogInternal();
    return 1;
  }
  return v7;
}

uint64_t AMFDREncodeRepairConfigurationEnd(_QWORD *a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v5;

  if (!_AMFDREncodeIsRepairConfigurationContextValid(a1))
  {
    v5 = 1;
LABEL_15:
    AMSupportLogInternal();
    return v5;
  }
  if (!a2)
  {
    v5 = 1;
    goto LABEL_15;
  }
  if (!a3)
  {
    v5 = 1;
    goto LABEL_15;
  }
  if (DEREncoderCreateEncodedBuffer())
  {
    v5 = 3;
    goto LABEL_15;
  }
  if (!*a2)
  {
    v5 = 199;
    goto LABEL_15;
  }
  if (!*a3)
  {
    v5 = 199;
    goto LABEL_15;
  }
  return 0;
}

uint64_t AMFDREncodeMultiCombinedDataPayloadBegin(_QWORD *a1)
{
  void *v2;
  uint64_t v3;

  if (!a1)
  {
    v3 = 199;
LABEL_9:
    AMSupportLogInternal();
    return v3;
  }
  v2 = malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  *a1 = v2;
  if (!v2)
  {
    v3 = 2;
    goto LABEL_9;
  }
  v3 = 0;
  *(_QWORD *)*a1 = DEREncoderCreate();
  if (!*(_QWORD *)*a1)
  {
    v3 = 2;
    goto LABEL_9;
  }
  return v3;
}

uint64_t AMFDREncodeMultiCombinedDataPayloadAddData(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, uint64_t a8, int a9)
{
  uint64_t v9;

  if (!a1 || !*a1)
    return 1;
  v9 = 1;
  if (a5 && a4 && a3 && a2 && *(_QWORD *)*a1)
  {
    if (a6)
    {
      if (!a7)
        goto LABEL_29;
    }
    else if (a7)
    {
LABEL_29:
      AMSupportLogInternal();
      return v9;
    }
    if (a8)
    {
      if (!a9)
        goto LABEL_30;
    }
    else if (a9)
    {
LABEL_30:
      AMSupportLogInternal();
      return 1;
    }
    if (DEREncoderCreate())
    {
      if (DEREncoderAddDataNoCopy()
        || DEREncoderAddDataNoCopy()
        || a6 && DEREncoderAddDataNoCopy()
        || a8 && DEREncoderAddDataNoCopy()
        || DEREncoderAddSequenceFromEncoder())
      {
        v9 = 3;
        AMSupportLogInternal();
      }
      else
      {
        v9 = 0;
      }
      DEREncoderDestroy();
    }
    else
    {
      AMSupportLogInternal();
      return 2;
    }
  }
  return v9;
}

uint64_t AMFDREncodeMultiCombinedDataPayloadEnd(_QWORD **a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t v6;

  if (!a1)
  {
    v6 = 1;
    goto LABEL_14;
  }
  if (!*a1)
  {
    v5 = 0;
    v6 = 1;
    goto LABEL_20;
  }
  v5 = 0;
  v6 = 1;
  if (!a3 || !a2 || !**a1)
  {
LABEL_20:
    if (!v5)
      goto LABEL_14;
    goto LABEL_13;
  }
  v5 = DEREncoderCreate();
  if (!v5)
  {
    AMSupportLogInternal();
    v6 = 2;
    goto LABEL_20;
  }
  if (DEREncoderAddSetFromEncoder() || DEREncoderCreateEncodedBuffer())
  {
    v6 = 3;
    AMSupportLogInternal();
    goto LABEL_20;
  }
  if (Img4EncodeCreatePayload() != 100 || !*a2 || !*a3)
  {
    AMSupportLogInternal();
    v6 = 199;
    goto LABEL_20;
  }
  v6 = 0;
LABEL_13:
  DEREncoderDestroy();
LABEL_14:
  AMFDREncodeMetadataDestroy(a1);
  return v6;
}

uint64_t AMFDREncodeSubCCDigestsBegin(_QWORD *a1)
{
  void *v2;
  uint64_t v3;

  if (!a1)
  {
    v3 = 199;
LABEL_8:
    AMSupportLogInternal();
    return v3;
  }
  v2 = malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  *a1 = v2;
  if (!v2)
  {
    v3 = 2;
    goto LABEL_8;
  }
  v3 = 0;
  *(_QWORD *)*a1 = DEREncoderCreate();
  if (!*(_QWORD *)*a1)
  {
    v3 = 2;
    goto LABEL_8;
  }
  return v3;
}

uint64_t AMFDREncodeSubCCDigestsAddData(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;

  if (!a1 || !*a1)
    return 1;
  v5 = 1;
  if (a5 && a4 && a3 && a2 && *(_QWORD *)*a1)
  {
    if (DEREncoderCreate())
    {
      if (DEREncoderAddDataNoCopy()
        || DEREncoderAddDataNoCopy()
        || DEREncoderAddSequenceFromEncoder())
      {
        v5 = 3;
        AMSupportLogInternal();
      }
      else
      {
        v5 = 0;
      }
      DEREncoderDestroy();
    }
    else
    {
      AMSupportLogInternal();
      return 2;
    }
  }
  return v5;
}

uint64_t AMFDREncodeSubCCDigestsEnd(_QWORD **a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v5;

  if (!a1 || !*a1)
  {
    v5 = 1;
    goto LABEL_13;
  }
  v5 = 1;
  if (a3 && a2 && **a1)
  {
    if (!DEREncoderCreate())
    {
      AMSupportLogInternal();
      v5 = 2;
      goto LABEL_13;
    }
    if (DEREncoderAddSetFromEncoder())
    {
      v5 = 3;
    }
    else if (DEREncoderCreateEncodedBuffer())
    {
      v5 = 3;
    }
    else if (*a2)
    {
      if (*a3)
      {
        v5 = 0;
LABEL_12:
        DEREncoderDestroy();
        goto LABEL_13;
      }
      v5 = 199;
    }
    else
    {
      v5 = 199;
    }
    AMSupportLogInternal();
    goto LABEL_12;
  }
LABEL_13:
  AMFDREncodeMetadataDestroy(a1);
  return v5;
}

uint64_t AMFDRTagsStringToTag(unsigned int *a1)
{
  return bswap32(*a1);
}

uint64_t AMFDRErrorPushInternal(uint64_t a1, CFIndex a2, const __CFNumber *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, void *value, void *a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, CFStringRef format, char a17)
{
  CFNumberRef v22;
  const __CFAllocator *v25;
  CFStringRef v26;
  __CFDictionary *Mutable;
  __CFDictionary *v28;
  CFIndex code;
  const __CFNumber *valuePtr;

  v22 = a3;
  valuePtr = a3;
  v25 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v26 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, format, &a17);
  if (v26)
    AMSupportLogInternal();
  if (!a1)
  {
    v28 = 0;
    v22 = 0;
    if (!v26)
      goto LABEL_39;
    goto LABEL_38;
  }
  code = a2;
  Mutable = CFDictionaryCreateMutable(v25, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v28 = Mutable;
  if (!Mutable)
  {
    v22 = 0;
    a1 = 0;
    if (!v26)
      goto LABEL_39;
LABEL_38:
    CFRelease(v26);
    goto LABEL_39;
  }
  if (v26)
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x24BDBD378], v26);
  if (v22)
  {
    v22 = CFNumberCreate(v25, kCFNumberSInt64Type, &valuePtr);
    if (v22)
    {
      AMSupportLogInternal();
      CFDictionaryAddValue(v28, CFSTR("AMFDRTrustError"), v22);
    }
  }
  if (a4)
    CFDictionarySetValue(v28, CFSTR("MissingDataInstances"), a4);
  if (a5)
    CFDictionarySetValue(v28, CFSTR("MissingMultiManifests"), a5);
  if (a6)
    CFDictionarySetValue(v28, CFSTR("DigestMismatchedDataInstances"), a6);
  if (a7)
    CFDictionarySetValue(v28, CFSTR("UnverifiedCombinedManifests"), a7);
  if (a8)
    CFDictionarySetValue(v28, CFSTR("UnverifiedDataInstances"), a8);
  if (value)
    CFDictionarySetValue(v28, CFSTR("MultiRequestErrors"), value);
  if (a10)
    CFDictionarySetValue(v28, CFSTR("MissingMinimalManifests"), a10);
  if (a11)
    CFDictionarySetValue(v28, CFSTR("UnverifiedMinimalManifests"), a11);
  if (a12)
    CFDictionarySetValue(v28, CFSTR("MissingMinimalSealingInstances"), a12);
  if (a13)
    CFDictionarySetValue(v28, CFSTR("MissingSubCCDataInstances"), a13);
  if (a14)
    CFDictionarySetValue(v28, CFSTR("MismatchedProperties"), a14);
  if (*(_QWORD *)a1)
  {
    CFDictionaryAddValue(v28, (const void *)*MEMORY[0x24BDBD3B0], *(const void **)a1);
    if (*(_QWORD *)a1)
    {
      CFRelease(*(CFTypeRef *)a1);
      *(_QWORD *)a1 = 0;
    }
  }
  *(_QWORD *)a1 = CFErrorCreate(v25, CFSTR("AMFDRError"), code, v28);
  a1 = 1;
  if (v26)
    goto LABEL_38;
LABEL_39:
  if (v28)
    CFRelease(v28);
  if (v22)
    CFRelease(v22);
  return a1;
}

uint64_t AMFDRGetTypeID()
{
  pthread_once(&_AMFDRClassInitializeOnce, (void (*)(void))_AMFDRClassInitialize);
  return _AMFDRTypeID;
}

uint64_t _AMFDRClassInitialize()
{
  _AMFDRTypeID = _CFRuntimeRegisterClass();
  return AMFDRCryptoInit();
}

_QWORD *AMFDRCreateWithImplementation(const __CFAllocator *a1, CFDictionaryRef theDict, _QWORD *a3, uint64_t a4)
{
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v9;
  uint64_t Instance;
  _QWORD *v11;
  CFMutableDictionaryRef v12;
  CFMutableDictionaryRef v13;
  CFMutableDictionaryRef v14;
  CFMutableDictionaryRef Mutable;

  if (!theDict || (MutableCopy = CFDictionaryCreateMutableCopy(a1, 0, theDict)) == 0)
  {
    AMSupportLogInternal();
    return 0;
  }
  v9 = MutableCopy;
  pthread_once(&_AMFDRClassInitializeOnce, (void (*)(void))_AMFDRClassInitialize);
  Instance = _CFRuntimeCreateInstance();
  v11 = (_QWORD *)Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 144) = 0;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_QWORD *)(Instance + 48) = AMFDRLocalStore;
    AMFDRPlatformSetImplementation(Instance, a3, a4);
    if (!CFDictionaryGetValue(theDict, CFSTR("DSURL")))
      CFDictionarySetValue(v9, CFSTR("DSURL"), CFSTR("https://skl.apple.com"));
    if (!CFDictionaryGetValue(theDict, CFSTR("CAURL")))
      CFDictionarySetValue(v9, CFSTR("CAURL"), CFSTR("https://gg.apple.com"));
    if (!CFDictionaryGetValue(theDict, CFSTR("SealingURL")))
      CFDictionarySetValue(v9, CFSTR("SealingURL"), CFSTR("https://ig.apple.com"));
    if ((AMFDRSetOptions((uint64_t)v11, v9) & 1) != 0)
    {
      AMFDRCryptoGetPrivateKey((uint64_t)v11);
      AMFDRCryptoGetCert((uint64_t)v11);
      if (v11[9]
        || (v12 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]), (v11[9] = v12) != 0))
      {
        if (v11[13]
          || (v13 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]), (v11[13] = v13) != 0))
        {
          if (v11[14]
            || (v14 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]), (v11[14] = v14) != 0))
          {
            if (v11[16])
              goto LABEL_20;
            Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
            v11[16] = Mutable;
            if (Mutable)
              goto LABEL_20;
          }
        }
      }
    }
    else
    {
      CFRelease(v11);
      v11 = 0;
    }
  }
  AMSupportLogInternal();
LABEL_20:
  CFRelease(v9);
  return v11;
}

uint64_t AMFDRSetOptions(uint64_t a1, CFTypeRef cf)
{
  const void *v4;
  const __CFString *Value;
  const __CFString *v6;
  CFTypeID TypeID;
  uint64_t v8;
  CFMutableDictionaryRef Mutable;
  uint64_t (**v10)(int, int, int, int);

  if (!a1 || !cf)
  {
LABEL_20:
    AMSupportLogInternal();
    return 0;
  }
  v4 = *(const void **)(a1 + 16);
  if (v4)
    CFRelease(v4);
  *(_QWORD *)(a1 + 16) = cf;
  CFRetain(cf);
  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("DataStore"));
  if (!Value)
    return 1;
  v6 = Value;
  TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(v6))
    return 1;
  if (CFStringCompare(v6, CFSTR("Remote"), 1uLL) == kCFCompareEqualTo)
  {
    v10 = AMFDRHTTPStore;
LABEL_17:
    *(_QWORD *)(a1 + 48) = v10;
    return 1;
  }
  if (CFStringCompare(v6, CFSTR("Local"), 1uLL) == kCFCompareEqualTo)
  {
    v10 = AMFDRLocalStore;
    goto LABEL_17;
  }
  v8 = 1;
  if (CFStringCompare(v6, CFSTR("Memory"), 1uLL) == kCFCompareEqualTo)
  {
    *(_QWORD *)(a1 + 48) = &AMFDRMemoryStore;
    if (CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("MemoryStoreURL")))
      AMFDRLoadMemoryStoreFromFile(a1);
    if (!*(_QWORD *)(a1 + 80))
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      *(_QWORD *)(a1 + 80) = Mutable;
      if (!Mutable)
        goto LABEL_20;
    }
    return 1;
  }
  return v8;
}

_QWORD *AMFDRCreateWithOptions(const __CFAllocator *a1, const __CFDictionary *a2)
{
  return AMFDRCreateWithImplementation(a1, a2, 0, 0);
}

_QWORD *AMFDRCreateTypeWithOptions(CFAllocatorRef allocator, const void *a2, const __CFDictionary *a3)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v6;
  _QWORD *v7;

  if (a2
    && (!a3
      ? (Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]))
      : (Mutable = CFDictionaryCreateMutableCopy(allocator, 0, a3)),
        (v6 = Mutable) != 0))
  {
    CFDictionarySetValue(Mutable, CFSTR("DataStore"), a2);
    v7 = AMFDRCreateWithImplementation(allocator, v6, 0, 0);
  }
  else
  {
    AMSupportLogInternal();
    v7 = 0;
  }
  AMSupportSafeRelease();
  return v7;
}

uint64_t AMFDRSetOption(uint64_t cf, const void *a2, const __CFString *a3)
{
  const __CFAllocator *v6;
  __CFDictionary *MutableCopy;
  __CFDictionary *v8;
  const __CFString *Value;
  const void *v10;
  _QWORD *v11;
  void *v12;
  uint64_t (*v13)(_QWORD);
  uint64_t v14;
  const void *v15;

  if (!cf)
    goto LABEL_28;
  if (!*(_QWORD *)(cf + 16))
    goto LABEL_28;
  if (!a2)
    goto LABEL_28;
  v6 = CFGetAllocator((CFTypeRef)cf);
  MutableCopy = CFDictionaryCreateMutableCopy(v6, 0, *(CFDictionaryRef *)(cf + 16));
  v8 = MutableCopy;
  if (!MutableCopy)
    goto LABEL_28;
  if (a3)
  {
    if (CFEqual(a2, CFSTR("Permissions")))
    {
      Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("Permissions"));
      if (Value)
      {
        if (CFStringCompare(a3, Value, 0))
        {
          v10 = *(const void **)(cf + 32);
          if (v10)
          {
            CFRelease(v10);
            *(_QWORD *)(cf + 32) = 0;
          }
        }
      }
    }
    CFDictionarySetValue(v8, a2, a3);
  }
  else
  {
    CFDictionaryRemoveValue(MutableCopy, a2);
  }
  if ((AMFDRSetOptions(cf, v8) & 1) == 0)
    goto LABEL_28;
  if (CFEqual(a2, CFSTR("PrivateKey")))
  {
    v11 = &kAMFDRPlatformImplementationStation;
    if (*(_UNKNOWN **)(cf + 136) == &kAMFDRPlatformImplementationStation)
    {
      if (_AMFDRPlatformDefaultRelease)
      {
        v12 = *(void **)(cf + 144);
        if (v12)
        {
          _AMFDRPlatformDefaultRelease(v12);
          *(_QWORD *)(cf + 144) = 0;
          v11 = *(_QWORD **)(cf + 136);
        }
      }
      v13 = (uint64_t (*)(_QWORD))v11[2];
      if (v13)
        v14 = v13(0);
      else
        v14 = 0;
      *(_QWORD *)(cf + 144) = v14;
      AMFDRCryptoGetPrivateKey(cf);
      return AMSupportSafeRelease();
    }
LABEL_28:
    AMSupportLogInternal();
    return AMSupportSafeRelease();
  }
  if (CFEqual(a2, CFSTR("Certificate")))
  {
    v15 = *(const void **)(cf + 32);
    if (v15)
    {
      CFRelease(v15);
      *(_QWORD *)(cf + 32) = 0;
    }
    AMFDRCryptoGetCert(cf);
  }
  return AMSupportSafeRelease();
}

uint64_t AMFDRLoadMemoryStoreFromFile(uint64_t a1)
{
  uint64_t v1;
  const __CFDictionary *v2;
  uint64_t URLFromString;
  BOOL v4;
  BOOL v5;
  char v7;
  CFDictionaryRef theDict;

  v1 = a1;
  theDict = 0;
  if (!a1)
  {
    AMSupportLogInternal();
    goto LABEL_15;
  }
  v2 = *(const __CFDictionary **)(a1 + 16);
  if (!v2 || !CFDictionaryGetValue(v2, CFSTR("MemoryStoreURL")))
  {
    AMSupportLogInternal();
    v1 = 0;
    goto LABEL_15;
  }
  URLFromString = AMSupportCreateURLFromString();
  if (!URLFromString)
    goto LABEL_18;
  v7 = 0;
  if (MEMORY[0x212BA048C](URLFromString, &v7))
    v4 = 0;
  else
    v4 = v7 == 1;
  if (v4)
  {
    if (AMSupportCreateDictionaryFromFileURL())
      v5 = 1;
    else
      v5 = theDict == 0;
    if (!v5)
    {
      v1 = AMFDRSetMemoryStore(v1, theDict);
      goto LABEL_15;
    }
LABEL_18:
    AMSupportLogInternal();
    v1 = 0;
    goto LABEL_15;
  }
  AMSupportLogInternal();
  v1 = 1;
LABEL_15:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v1;
}

void AMFDRSetAssemblyIdentifierToVerify(uint64_t a1, void *key, const __CFString *a3)
{
  __CFDictionary *v4;
  CFTypeID v7;

  if (a1 && (v4 = *(__CFDictionary **)(a1 + 104)) != 0 && key)
  {
    CFDictionaryRemoveValue(v4, key);
    if (a3)
    {
      v7 = CFGetTypeID(a3);
      if (v7 == CFStringGetTypeID() && CFStringGetLength(a3) >= 1)
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), key, a3);
    }
  }
  else
  {
    AMSupportLogInternal();
  }
}

const void *AMFDRGetAssemblyIDToVerify(uint64_t a1, const void *a2)
{
  const __CFDictionary *v2;

  if (a1)
  {
    v2 = *(const __CFDictionary **)(a1 + 104);
    if (v2)
    {
      if (a2)
        return CFDictionaryGetValue(v2, a2);
    }
  }
  AMSupportLogInternal();
  return 0;
}

void AMFDRSetSubCCDigestsToVerify(uint64_t a1, void *key, const void *a3)
{
  __CFDictionary *v4;
  CFTypeID v7;

  if (a1 && (v4 = *(__CFDictionary **)(a1 + 128)) != 0 && key)
  {
    CFDictionaryRemoveValue(v4, key);
    if (a3)
    {
      v7 = CFGetTypeID(a3);
      if (v7 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)a3) >= 1)
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 128), key, a3);
    }
  }
  else
  {
    AMSupportLogInternal();
  }
}

const void *AMFDRGetSubCCDigestsToVerify(uint64_t a1, const void *a2)
{
  const __CFDictionary *v2;

  if (a1)
  {
    v2 = *(const __CFDictionary **)(a1 + 128);
    if (v2)
    {
      if (a2)
        return CFDictionaryGetValue(v2, a2);
    }
  }
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDRGetOptions(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 16);
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDRGetInfo(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 72);
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDRGetCert(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 32);
  AMSupportLogInternal();
  return 0;
}

void AMFDRIncrementStat(CFMutableDictionaryRef *a1, void *key)
{
  const __CFDictionary *v3;
  const __CFNumber *Value;
  uint64_t v6;
  const __CFAllocator *v7;
  CFNumberRef v8;
  CFNumberRef v9;
  uint64_t valuePtr;

  valuePtr = 0;
  if (!a1 || (v3 = a1[9]) == 0 || !key)
  {
    AMSupportLogInternal();
    return;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(v3, key);
  if (!Value)
  {
    v6 = 1;
LABEL_8:
    valuePtr = v6;
    v7 = CFGetAllocator(a1);
    v8 = CFNumberCreate(v7, kCFNumberLongType, &valuePtr);
    if (v8)
    {
      v9 = v8;
      CFDictionarySetValue(a1[9], key, v8);
      CFRelease(v9);
      return;
    }
    goto LABEL_11;
  }
  if (CFNumberGetValue(Value, kCFNumberLongType, &valuePtr))
  {
    v6 = valuePtr + 1;
    goto LABEL_8;
  }
LABEL_11:
  AMSupportLogInternal();
}

void AMFDRSetStat(CFMutableDictionaryRef *cf, const void *a2, uint64_t a3)
{
  const __CFAllocator *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  uint64_t valuePtr;

  valuePtr = a3;
  if (cf && cf[9] && a2)
  {
    v5 = CFGetAllocator(cf);
    v6 = CFNumberCreate(v5, kCFNumberLongType, &valuePtr);
    if (v6)
    {
      v7 = v6;
      CFDictionarySetValue(cf[9], a2, v6);
      CFRelease(v7);
    }
    else
    {
      AMSupportLogInternal();
    }
  }
  else
  {
    AMSupportLogInternal();
  }
}

void AMFDRCopyStatString(CFMutableDictionaryRef *cf, const void *a2, const __CFString *a3)
{
  const __CFAllocator *v6;
  CFStringRef Copy;
  CFStringRef v8;

  if (cf && cf[9] && a2 && a3 && (v6 = CFGetAllocator(cf), (Copy = CFStringCreateCopy(v6, a3)) != 0))
  {
    v8 = Copy;
    CFDictionarySetValue(cf[9], a2, Copy);
    CFRelease(v8);
  }
  else
  {
    AMSupportLogInternal();
  }
}

uint64_t AMFDRGetMemoryStore(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 80);
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDRFlushMemoryStoreToFile(uint64_t a1)
{
  const __CFDictionary *v2;
  uint64_t Value;

  if (!a1)
    goto LABEL_12;
  v2 = *(const __CFDictionary **)(a1 + 16);
  if (!v2)
    goto LABEL_12;
  Value = (uint64_t)CFDictionaryGetValue(v2, CFSTR("MemoryStoreURL"));
  if (!Value)
  {
    AMSupportLogInternal();
    goto LABEL_8;
  }
  if (!*(_QWORD *)(a1 + 80) || !AMSupportCreateURLFromString() || AMSupportWriteDictionarytoFileURL())
  {
LABEL_12:
    AMSupportLogInternal();
    Value = 0;
    goto LABEL_8;
  }
  AMSupportLogInternal();
  Value = 1;
LABEL_8:
  AMSupportSafeRelease();
  return Value;
}

uint64_t AMFDRSetMemoryStore(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFDictionary *v4;
  const void *v5;
  CFMutableDictionaryRef MutableCopy;

  if (a1 && theDict)
  {
    v4 = *(const __CFDictionary **)(a1 + 80);
    if (v4)
    {
      CFDictionaryGetCount(v4);
      AMSupportLogInternal();
      v5 = *(const void **)(a1 + 80);
      if (v5)
        CFRelease(v5);
      *(_QWORD *)(a1 + 80) = 0;
    }
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, theDict);
    *(_QWORD *)(a1 + 80) = MutableCopy;
    if (MutableCopy)
      return 1;
  }
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDRClearMemoryStore(uint64_t a1)
{
  const __CFDictionary *v2;
  const void *v3;
  CFMutableDictionaryRef Mutable;

  if (a1)
  {
    v2 = *(const __CFDictionary **)(a1 + 80);
    if (v2)
    {
      CFDictionaryGetCount(v2);
      AMSupportLogInternal();
      v3 = *(const void **)(a1 + 80);
      if (v3)
        CFRelease(v3);
      *(_QWORD *)(a1 + 80) = 0;
    }
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    *(_QWORD *)(a1 + 80) = Mutable;
    if (Mutable)
      return 1;
  }
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDRSetCopyMGOverrideCallback(uint64_t a1, uint64_t a2)
{
  if ((AMFDREntitlementIsEntitled(CFSTR("com.apple.libFDR.AllowIdentifierOverride")) & 1) != 0 && a1)
  {
    *(_QWORD *)(a1 + 88) = a2;
    return 1;
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
}

uint64_t AMFDRPerformManifestCheck(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 40);
}

uint64_t AMFDRCopyClientId(uint64_t a1)
{
  _QWORD *v1;
  uint64_t (*v2)(uint64_t, _QWORD);

  if (a1
    && (v1 = *(_QWORD **)(a1 + 136), *v1 >= 0x59uLL)
    && (v2 = (uint64_t (*)(uint64_t, _QWORD))v1[11]) != 0)
  {
    return v2(a1, *(_QWORD *)(a1 + 144));
  }
  else
  {
    return 0;
  }
}

uint64_t AMFDRCopyCertifyClientId(_QWORD *a1)
{
  const __CFDictionary *v2;
  const void *Value;
  const void *v4;
  _QWORD *v5;
  uint64_t (*v6)(_QWORD *, _QWORD);

  if (!a1)
    return 0;
  v2 = (const __CFDictionary *)a1[2];
  if (!v2 || (Value = CFDictionaryGetValue(v2, CFSTR("CertifyClientId"))) == 0)
  {
    v5 = (_QWORD *)a1[17];
    if (*v5 >= 0x59uLL)
    {
      v6 = (uint64_t (*)(_QWORD *, _QWORD))v5[11];
      if (v6)
        return v6(a1, a1[18]);
    }
    return 0;
  }
  v4 = Value;
  CFRetain(Value);
  return (uint64_t)v4;
}

CFStringRef AMFDRCopyCertifyClientIdSik(_QWORD *a1)
{
  const __CFDictionary *v2;
  const __CFData *Value;
  const __CFData *v4;
  CFTypeID v5;
  const __CFAllocator *v6;
  UInt8 *BytePtr;
  CFIndex Length;
  const __CFString *SikPubDigestIfNecessary;
  const __CFAllocator *v10;
  CFStringRef v11;
  uint64_t v12;
  uint64_t SikPub;
  uint64_t v14;
  const __CFAllocator *v15;
  CFStringRef v16;
  CFStringRef v17;

  if (!a1)
    goto LABEL_14;
  v2 = (const __CFDictionary *)a1[2];
  if (v2 && (Value = (const __CFData *)CFDictionaryGetValue(v2, CFSTR("CertifySikPub"))) != 0)
  {
    v4 = Value;
    v5 = CFGetTypeID(Value);
    if (v5 != CFDataGetTypeID())
      goto LABEL_14;
    v6 = CFGetAllocator(a1);
    BytePtr = (UInt8 *)CFDataGetBytePtr(v4);
    Length = CFDataGetLength(v4);
    SikPubDigestIfNecessary = (const __CFString *)AMFDRDataCreateSikPubDigestIfNecessary(v6, BytePtr, Length);
    if (!SikPubDigestIfNecessary)
      goto LABEL_14;
    v10 = CFGetAllocator(a1);
    v11 = AMFDRCreateInstanceString(v10, SikPubDigestIfNecessary);
    if (!v11)
      goto LABEL_14;
    v12 = (uint64_t)v11;
  }
  else
  {
    SikPub = AMFDRCryptoGetSikPub((uint64_t)a1);
    if (!SikPub)
    {
LABEL_14:
      AMSupportLogInternal();
      v17 = 0;
      goto LABEL_13;
    }
    v12 = SikPub;
  }
  v14 = AMFDRCopyCertifyClientId(a1);
  if (!v14)
    goto LABEL_14;
  v15 = CFGetAllocator(a1);
  v16 = CFStringCreateWithFormat(v15, 0, CFSTR("sik-%@-%@"), v14, v12);
  if (!v16)
    goto LABEL_14;
  v17 = v16;
LABEL_13:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v17;
}

const __CFString *AMFDRCopyLibraryVersionString()
{
  const __CFString *v0;
  CFTypeRef v1;
  __CFString *MutableCopy;
  __CFString *v3;

  v0 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), "@(#)PROGRAM:FDR  PROJECT:libFDR-1300.0.17\n");
  if (!v0)
    return CFSTR("libFDR-??");
  v1 = v0;
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, v0);
  if (MutableCopy)
  {
    v3 = MutableCopy;
    CFStringTrimWhitespace(MutableCopy);
    CFRelease(v1);
    v1 = CFRetain(v3);
    CFRelease(v3);
  }
  return (const __CFString *)v1;
}

uint64_t AMFDRGetTrustError(__CFError *a1)
{
  CFDictionaryRef v1;
  const __CFDictionary *v2;
  const void *v3;
  const __CFNumber *Value;
  __CFError *v5;
  __CFError *v6;
  uint64_t valuePtr;

  valuePtr = 0;
  if (a1)
  {
    v1 = CFErrorCopyUserInfo(a1);
    if (v1)
    {
      v2 = v1;
      v3 = (const void *)*MEMORY[0x24BDBD3B0];
      do
      {
        Value = (const __CFNumber *)CFDictionaryGetValue(v2, CFSTR("AMFDRTrustError"));
        v5 = (__CFError *)CFDictionaryGetValue(v2, v3);
        if (!v5)
          break;
        v6 = v5;
        CFRelease(v2);
        v2 = CFErrorCopyUserInfo(v6);
      }
      while (v2);
      if (Value)
        CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
      if (v2)
        CFRelease(v2);
    }
  }
  return valuePtr;
}

uint64_t AMFDRCopyUnderlyingDictionary(__CFError *a1, const void *a2)
{
  CFDictionaryRef v3;
  const __CFDictionary *v4;
  const void *v5;
  __CFError *Value;

  if (a1)
  {
    v3 = CFErrorCopyUserInfo(a1);
    if (v3)
    {
      v4 = v3;
      v5 = (const void *)*MEMORY[0x24BDBD3B0];
      do
      {
        CFDictionaryGetValue(v4, a2);
        Value = (__CFError *)CFDictionaryGetValue(v4, v5);
        CFRelease(v4);
        if (!Value)
          break;
        v4 = CFErrorCopyUserInfo(Value);
      }
      while (v4);
    }
  }
  return AMSupportSafeRetain();
}

const __CFArray *AMFDRNonEmptyArrayValueExists(CFDictionaryRef theDict, const void *a2)
{
  const __CFArray *result;
  const __CFArray *v4;
  CFTypeID v5;

  result = 0;
  if (theDict)
  {
    if (a2)
    {
      result = (const __CFArray *)CFDictionaryGetValue(theDict, a2);
      if (result)
      {
        v4 = result;
        v5 = CFGetTypeID(result);
        if (v5 == CFArrayGetTypeID())
          return (const __CFArray *)(CFArrayGetCount(v4) > 0);
        else
          return 0;
      }
    }
  }
  return result;
}

BOOL AMFDRSetSsoCreateServiceTicketCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    *(_QWORD *)(a1 + 56) = a2;
    *(_QWORD *)(a1 + 64) = a3;
  }
  else
  {
    AMSupportLogInternal();
  }
  return a1 != 0;
}

BOOL AMFDROptionsGetBooleanValue(uint64_t a1, const void *a2, uint64_t a3)
{
  const __CFDictionary *v4;
  const __CFBoolean *Value;
  const __CFBoolean *v6;
  CFTypeID v7;

  v4 = *(const __CFDictionary **)(a1 + 16);
  if (v4)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v4, a2);
    if (Value)
    {
      v6 = Value;
      v7 = CFGetTypeID(Value);
      if (v7 == CFBooleanGetTypeID())
        return CFBooleanGetValue(v6) != 0;
    }
  }
  return a3;
}

uint64_t AMFDRIsSupported()
{
  return 1;
}

uint64_t _CFDictionaryAddDictionary(__CFDictionary *a1, CFDictionaryRef theDict)
{
  CFIndex Count;
  const void **v5;
  const void **v6;
  const void **v7;
  const void **v8;
  const void *v9;
  const void *v10;
  const void *v11;

  if (!theDict || !a1)
  {
    AMSupportLogInternal();
    return 0;
  }
  Count = CFDictionaryGetCount(theDict);
  v5 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  v6 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  CFDictionaryGetKeysAndValues(theDict, v5, v6);
  if (Count >= 1)
  {
    v7 = v5;
    v8 = v6;
    do
    {
      v10 = *v7++;
      v9 = v10;
      v11 = *v8++;
      CFDictionarySetValue(a1, v9, v11);
      --Count;
    }
    while (Count);
    goto LABEL_8;
  }
  if (v5)
LABEL_8:
    free(v5);
  if (v6)
    free(v6);
  return 1;
}

uint64_t AMFDRRegisterModuleChallengeCallback(_QWORD *a1, CFStringRef theString2, const __CFString *a3)
{
  uint64_t v6;
  CFStringRef *v7;
  CFStringRef *v8;
  const __CFAllocator *v9;
  CFStringRef Copy;
  const __CFString *v11;

  if (!theString2 || !a3)
    goto LABEL_11;
  v6 = a1[12];
  if (v6)
  {
    while (CFStringCompare(*(CFStringRef *)v6, theString2, 0))
    {
      v6 = *(_QWORD *)(v6 + 16);
      if (!v6)
        goto LABEL_6;
    }
    *(_QWORD *)(v6 + 8) = a3;
    AMSupportLogInternal();
    return 1;
  }
LABEL_6:
  v7 = (CFStringRef *)malloc_type_malloc(0x18uLL, 0xE00403260BBE2uLL);
  if (v7)
  {
    v8 = v7;
    v9 = CFGetAllocator(a1);
    Copy = CFStringCreateCopy(v9, theString2);
    *v8 = Copy;
    if (Copy)
    {
      v11 = (const __CFString *)a1[12];
      v8[1] = a3;
      v8[2] = v11;
      a1[12] = v8;
      return 1;
    }
    AMSupportLogInternal();
    free(v8);
  }
  else
  {
LABEL_11:
    AMSupportLogInternal();
  }
  return 0;
}

__CFString *AMFDRCreateRecoveryPermissions(__CFString *a1, const __CFString *a2, const __CFString *a3, CFArrayRef theArray, const __CFArray *a5, uint64_t a6)
{
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  char v14;
  CFIndex v15;
  __CFString *PermissionsString;
  const __CFString *ValueAtIndex;
  const __CFString *v18;
  CFTypeID v19;
  const __CFString *v20;
  const __CFString *v21;
  CFTypeID v22;
  const __CFString *format;
  const __CFString *v25;
  char v26;

  if (!a1)
  {
    v25 = CFSTR("amfdr is NULL");
LABEL_37:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCreateRecoveryPermissions", v25, v26);
    return 0;
  }
  if (!a2)
  {
    v25 = CFSTR("sealedDataClass is NULL");
    goto LABEL_37;
  }
  if (!a3)
  {
    v25 = CFSTR("sealedDataInstance is NULL");
    goto LABEL_37;
  }
  if (!theArray)
  {
    v25 = CFSTR("dataClasses is NULL");
    goto LABEL_37;
  }
  if (!a5)
  {
    v25 = CFSTR("dataInstances is NULL");
    goto LABEL_37;
  }
  Count = CFArrayGetCount(theArray);
  v12 = CFArrayGetCount(a5);
  v13 = CFArrayGetCount(theArray);
  v14 = v13;
  if (Count != v12)
  {
    CFArrayGetCount(a5);
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCreateRecoveryPermissions", CFSTR("CFArrayGetCount(dataClasses) (%ld) != CFArrayGetCount(dataInstances) (%ld)"), v14);
    return 0;
  }
  if (v13 >= 1)
  {
    v15 = 0;
    PermissionsString = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v15);
      if (!ValueAtIndex)
      {
        format = CFSTR("dataClass is NULL");
LABEL_27:
        AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCreateRecoveryPermissions", format, v26);
        goto LABEL_28;
      }
      v18 = ValueAtIndex;
      v19 = CFGetTypeID(ValueAtIndex);
      if (v19 != CFStringGetTypeID())
      {
        AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCreateRecoveryPermissions", CFSTR("Object of unexpected type '%@' for key dataClass, expected CFString"), (char)v18);
        goto LABEL_28;
      }
      v20 = (const __CFString *)CFArrayGetValueAtIndex(a5, v15);
      if (!v20)
      {
        format = CFSTR("dataInstance is NULL");
        goto LABEL_27;
      }
      v21 = v20;
      v22 = CFGetTypeID(v20);
      if (v22 != CFStringGetTypeID())
      {
        v26 = (char)v21;
        format = CFSTR("Object of unexpected type '%@' for key dataInstance, expected CFString");
        goto LABEL_27;
      }
      if (PermissionsString)
      {
        if ((AMFDRDataAppendPermissionsString(a1, 0, v18, v21, PermissionsString) & 1) == 0)
        {
          AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCreateRecoveryPermissions", CFSTR("Failed to append permissions string with data class '%@', data instance '%@', action '%d'"), (char)v18);
          goto LABEL_29;
        }
      }
      else
      {
        PermissionsString = (__CFString *)AMFDRDataCreatePermissionsString(a1, 0, v18, v21);
        if (!PermissionsString)
        {
          AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCreateRecoveryPermissions", CFSTR("Failed to create permissions string for data class '%@', data instance '%@', action '%d'"), (char)v18);
          return PermissionsString;
        }
      }
      if (++v15 >= CFArrayGetCount(theArray))
        goto LABEL_20;
    }
  }
  PermissionsString = 0;
LABEL_20:
  if ((AMFDRDataAppendPermissionsString(a1, 0, a2, a3, PermissionsString) & 1) == 0
    || (AMFDRDataAppendPermissionsString(a1, 5u, a2, a3, PermissionsString) & 1) == 0)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCreateRecoveryPermissions", CFSTR("Failed to append permissions string with data class '%@', data instance '%@', action '%d'"), (char)a2);
LABEL_28:
    if (PermissionsString)
    {
LABEL_29:
      CFRelease(PermissionsString);
      return 0;
    }
  }
  return PermissionsString;
}

unint64_t AMFDRSetDigest(CFTypeRef cf, uint64_t a2, uint64_t a3, const void *a4)
{
  unint64_t v4;
  const __CFAllocator *v8;
  CFStringRef FullKey;
  CFStringRef v10;
  __CFDictionary *v11;

  v4 = (unint64_t)cf;
  if (cf)
  {
    if (a2 && a3 && (v8 = CFGetAllocator(cf), (FullKey = AMFDRDataLocalCreateFullKey(v8, a2, a3)) != 0))
    {
      v10 = FullKey;
      v11 = *(__CFDictionary **)(v4 + 112);
      v4 = v11 != 0;
      if (v11)
      {
        if (a4)
          CFDictionarySetValue(v11, v10, a4);
        else
          CFDictionaryRemoveValue(v11, v10);
      }
      else
      {
        AMSupportLogInternal();
      }
      CFRelease(v10);
    }
    else
    {
      AMSupportLogInternal();
      return 0;
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  return v4;
}

BOOL AMFDRCreateDataSignature(CFTypeRef cf, int a2, uint64_t a3, uint64_t a4, void **a5, _QWORD *a6)
{
  int DataSignature;

  DataSignature = AMFDRCryptoCreateDataSignature(a2, a3, a4, a5, a6, cf);
  if (DataSignature != 100)
    AMSupportLogInternal();
  return DataSignature == 100;
}

_QWORD *AMFDRGetSikOverride(_QWORD *cf, uint64_t a2, uint64_t a3)
{
  _QWORD *Value;
  const __CFAllocator *v6;
  CFStringRef FullKey;
  CFStringRef v8;
  const __CFDictionary *v9;

  Value = cf;
  if (!cf)
    return Value;
  if ((*(_BYTE *)(cf[17] + 8) & 2) != 0)
    return 0;
  if (!a2 || !a3 || (v6 = CFGetAllocator(cf), (FullKey = AMFDRDataLocalCreateFullKey(v6, a2, a3)) == 0))
  {
    AMSupportLogInternal();
    return 0;
  }
  v8 = FullKey;
  v9 = (const __CFDictionary *)Value[15];
  if (v9)
    Value = CFDictionaryGetValue(v9, v8);
  else
    Value = 0;
  CFRelease(v8);
  return Value;
}

void AMFDRSetRestorePeriodOptions(CFTypeRef a1)
{
  const void *v1;

  v1 = (const void *)_restorePeriodOptions;
  if ((CFTypeRef)_restorePeriodOptions != a1)
  {
    if (a1)
      a1 = CFRetain(a1);
    _restorePeriodOptions = (uint64_t)a1;
    if (v1)
      CFRelease(v1);
  }
}

uint64_t AMFDRGetRestorePeriodOptions()
{
  return _restorePeriodOptions;
}

uint64_t AMFDRSetRestorePeriodSsoCallback(uint64_t result, uint64_t a2)
{
  _restorePeriodSsoCallback = result;
  _restorePeriodSsoContext = a2;
  return result;
}

uint64_t AMFDREnableRestorePeriodSsoCallback(uint64_t a1)
{
  BOOL v1;
  uint64_t v2;
  uint64_t v3;

  if (a1)
    v1 = _restorePeriodSsoCallback == 0;
  else
    v1 = 1;
  v2 = !v1;
  if (!v1)
  {
    v3 = _restorePeriodSsoContext;
    *(_QWORD *)(a1 + 56) = _restorePeriodSsoCallback;
    *(_QWORD *)(a1 + 64) = v3;
  }
  return v2;
}

uint64_t AMFDRAddMinimalManifestPropertyItemsToVerify(uint64_t a1, const __CFDictionary *cf)
{
  uint64_t v2;
  CFTypeID v4;
  const __CFDictionary *Value;
  const __CFDictionary *v6;
  CFTypeID v7;
  const __CFAllocator *v8;
  CFMutableDictionaryRef MutableCopy;
  const __CFAllocator *v10;
  __CFString *v11;
  CFIndex Count;
  const void **v13;
  const void **v14;
  const void **v15;
  uint64_t v16;
  const void *v17;
  CFTypeID v18;
  const void *v19;
  CFTypeID v20;
  const __CFArray *v21;
  const __CFArray *v22;
  const __CFArray *v23;
  CFTypeID v24;
  const __CFAllocator *v25;
  CFMutableArrayRef v26;
  __CFArray *v27;
  const void **v28;
  uint64_t v29;
  CFIndex v30;
  const void *ValueAtIndex;
  const void *v32;
  CFTypeID v33;
  __CFArray *v34;
  CFIndex v36;
  __CFString *v37;
  CFRange v38;

  v2 = a1;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 16)
      && cf
      && (v4 = CFGetTypeID(cf), v4 == CFDictionaryGetTypeID())
      && CFDictionaryGetCount(cf) > 0)
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 16), CFSTR("MinimalManifestPropertyCheck"));
      if (Value && (v6 = Value, v7 = CFGetTypeID(Value), v7 == CFDictionaryGetTypeID()))
      {
        v8 = CFGetAllocator((CFTypeRef)v2);
        MutableCopy = CFDictionaryCreateMutableCopy(v8, 0, v6);
      }
      else
      {
        v10 = CFGetAllocator((CFTypeRef)v2);
        MutableCopy = CFDictionaryCreateMutable(v10, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      }
      v11 = (__CFString *)MutableCopy;
      if (MutableCopy)
      {
        Count = CFDictionaryGetCount(cf);
        v13 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
        v14 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
        v15 = v14;
        if (v13)
        {
          if (v14)
          {
            CFDictionaryGetKeysAndValues(cf, v13, v14);
            if (Count < 1)
            {
LABEL_38:
              AMFDRSetOption(v2, CFSTR("MinimalManifestPropertyCheck"), v11);
              v2 = 1;
              goto LABEL_41;
            }
            v16 = 0;
            v36 = Count;
            v37 = v11;
            while (1)
            {
              v17 = v13[v16];
              if (!v17)
                break;
              v18 = CFGetTypeID(v17);
              if (v18 != CFStringGetTypeID())
                break;
              v19 = v15[v16];
              if (!v19)
                break;
              v20 = CFGetTypeID(v19);
              if (v20 != CFArrayGetTypeID())
                break;
              v21 = (const __CFArray *)v15[v16];
              if (CFDictionaryContainsKey((CFDictionaryRef)v11, v13[v16]))
              {
                v22 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v11, v13[v16]);
                if (!v22)
                  break;
                v23 = v22;
                v24 = CFGetTypeID(v22);
                if (v24 != CFArrayGetTypeID())
                  break;
                v25 = CFGetAllocator((CFTypeRef)v2);
                v26 = CFArrayCreateMutableCopy(v25, 0, v23);
                if (!v26)
                  break;
                v27 = v26;
                if (CFArrayGetCount(v21) >= 1)
                {
                  v28 = v15;
                  v29 = v2;
                  v30 = 0;
                  do
                  {
                    ValueAtIndex = CFArrayGetValueAtIndex(v21, v30);
                    if (ValueAtIndex)
                    {
                      v32 = ValueAtIndex;
                      v33 = CFGetTypeID(ValueAtIndex);
                      if (v33 == CFStringGetTypeID())
                      {
                        v38.length = CFArrayGetCount(v23);
                        v38.location = 0;
                        if (!CFArrayContainsValue(v23, v38, v32))
                          CFArrayAppendValue(v27, v32);
                      }
                    }
                    ++v30;
                  }
                  while (v30 < CFArrayGetCount(v21));
                  v2 = v29;
                  v15 = v28;
                  Count = v36;
                  v11 = v37;
                }
              }
              else
              {
                v27 = 0;
              }
              if (v27)
                v34 = v27;
              else
                v34 = v21;
              CFDictionarySetValue((CFMutableDictionaryRef)v11, v13[v16], v34);
              if (v27)
                CFRelease(v27);
              if (++v16 == Count)
                goto LABEL_38;
            }
          }
        }
      }
      AMSupportLogInternal();
    }
    else
    {
      AMSupportLogInternal();
      v11 = 0;
    }
    v2 = 0;
  }
  else
  {
    AMSupportLogInternal();
    v11 = 0;
  }
LABEL_41:
  AMSupportSafeFree();
  AMSupportSafeFree();
  if (v11)
    CFRelease(v11);
  return v2;
}

uint64_t AMFDRMigrateCredentials(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  const __CFDictionary *v5;
  const __CFString *Value;
  const __CFString *v7;
  void (*v8)(void);
  uint64_t v9;
  uint64_t (*v10)(uint64_t);
  const __CFString *v12;
  char v13;

  if (!a1)
  {
    v12 = CFSTR("amfdr is NULL");
LABEL_19:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRMigrateCredentials", v12, v13);
    return 0;
  }
  if (!a2)
  {
    v12 = CFSTR("amfdrSource is NULL");
    goto LABEL_19;
  }
  v5 = (const __CFDictionary *)a2[2];
  if (!v5)
  {
    v12 = CFSTR("amfdrSource optionsDict is NULL");
    goto LABEL_19;
  }
  if (*(_QWORD *)(a1 + 136) != a2[17])
  {
    v12 = CFSTR("amfdr and amfdrSource have different platform implementations");
    goto LABEL_19;
  }
  Value = (const __CFString *)CFDictionaryGetValue(v5, CFSTR("Permissions"));
  if (Value)
    AMFDRSetOption(a1, CFSTR("Permissions"), Value);
  v7 = (const __CFString *)a2[4];
  if (v7)
    AMFDRSetOption(a1, CFSTR("Certificate"), v7);
  v8 = *(void (**)(void))(*(_QWORD *)(a1 + 136) + 24);
  if (v8 && *(_QWORD *)(a1 + 144))
  {
    v8();
    *(_QWORD *)(a1 + 144) = 0;
  }
  v9 = a2[18];
  v10 = *(uint64_t (**)(uint64_t))(a2[17] + 16);
  if (v10)
    v9 = v10(v9);
  *(_QWORD *)(a1 + 144) = v9;
  return 1;
}

CFTypeRef AMFDRCreateCopyWithOptionsOverride(uint64_t a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;
  _QWORD *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  uint64_t v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  CFTypeRef v23;
  _QWORD context[2];

  context[1] = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    AMSupportLogInternal();
    return 0;
  }
  v4 = CFGetAllocator((CFTypeRef)a1);
  v5 = AMFDRCreateWithImplementation(v4, *(CFDictionaryRef *)(a1 + 16), 0, 0);
  v6 = (const void *)v5[3];
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(a1 + 24);
  v5[3] = v7;
  if (v7)
    CFRetain(v7);
  v8 = (const void *)v5[4];
  if (v8)
    CFRelease(v8);
  v9 = *(const void **)(a1 + 32);
  v5[4] = v9;
  if (v9)
    CFRetain(v9);
  *((_WORD *)v5 + 20) = *(_WORD *)(a1 + 40);
  *(_OWORD *)(v5 + 7) = *(_OWORD *)(a1 + 56);
  v10 = (const void *)v5[9];
  if (v10)
    CFRelease(v10);
  v11 = *(const void **)(a1 + 72);
  v5[9] = v11;
  if (v11)
    CFRetain(v11);
  v12 = (const void *)v5[10];
  if (v12)
    CFRelease(v12);
  v13 = *(const void **)(a1 + 80);
  v5[10] = v13;
  if (v13)
    CFRetain(v13);
  v5[11] = *(_QWORD *)(a1 + 88);
  v14 = *(_QWORD *)(a1 + 96);
  if (!v14)
  {
LABEL_21:
    v15 = (const void *)v5[13];
    if (v15)
      CFRelease(v15);
    v16 = *(const void **)(a1 + 104);
    v5[13] = v16;
    if (v16)
      CFRetain(v16);
    v17 = (const void *)v5[14];
    if (v17)
      CFRelease(v17);
    v18 = *(const void **)(a1 + 112);
    v5[14] = v18;
    if (v18)
      CFRetain(v18);
    v19 = (const void *)v5[15];
    if (v19)
      CFRelease(v19);
    v20 = *(const void **)(a1 + 120);
    v5[15] = v20;
    if (v20)
      CFRetain(v20);
    v21 = (const void *)v5[16];
    if (v21)
      CFRelease(v21);
    v22 = *(const void **)(a1 + 128);
    v5[16] = v22;
    if (v22)
      CFRetain(v22);
    if ((AMFDRPlatformSetImplementation((uint64_t)v5, *(_QWORD **)(a1 + 136), *(_QWORD *)(a1 + 144)) & 1) != 0)
    {
      if (a2)
      {
        context[0] = v5;
        CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)_AMFDRSetCFDictionaryOptionCallback, context);
      }
      v23 = CFRetain(v5);
    }
    else
    {
      AMSupportLogInternal();
      v23 = 0;
    }
LABEL_41:
    CFRelease(v5);
    return v23;
  }
  while (AMFDRRegisterModuleChallengeCallback(v5, *(CFStringRef *)v14, *(const __CFString **)(v14 + 8)))
  {
    v14 = *(_QWORD *)(v14 + 16);
    if (!v14)
      goto LABEL_21;
  }
  AMSupportLogInternal();
  AMSupportLogInternal();
  v23 = 0;
  if (v5)
    goto LABEL_41;
  return v23;
}

uint64_t _AMFDRSetCFDictionaryOptionCallback(const void *a1, const __CFString *a2, uint64_t *a3)
{
  return AMFDRSetOption(*a3, a1, a2);
}

CFTypeRef AMFDRCreateCopy(uint64_t a1)
{
  return AMFDRCreateCopyWithOptionsOverride(a1, 0);
}

double _AMFDRFinalize(_QWORD *a1)
{
  const void *v2;
  _QWORD *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  void (*v12)(void);
  uint64_t v13;
  double result;

  if (!a1)
    _AMFDRFinalize_cold_1();
  v3 = a1 + 2;
  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    *v3 = 0;
  }
  v4 = (const void *)a1[3];
  if (v4)
  {
    CFRelease(v4);
    a1[3] = 0;
  }
  v5 = (const void *)a1[4];
  if (v5)
  {
    CFRelease(v5);
    a1[4] = 0;
  }
  v6 = (const void *)a1[9];
  if (v6)
  {
    CFRelease(v6);
    a1[9] = 0;
  }
  v7 = (const void *)a1[10];
  if (v7)
  {
    CFRelease(v7);
    a1[10] = 0;
  }
  v8 = (const void *)a1[13];
  if (v8)
  {
    CFRelease(v8);
    a1[13] = 0;
  }
  v9 = (const void *)a1[14];
  if (v9)
  {
    CFRelease(v9);
    a1[14] = 0;
  }
  v10 = (const void *)a1[15];
  if (v10)
  {
    CFRelease(v10);
    a1[15] = 0;
  }
  v11 = (const void *)a1[16];
  if (v11)
  {
    CFRelease(v11);
    a1[16] = 0;
  }
  v12 = *(void (**)(void))(a1[17] + 24);
  if (v12 && a1[18])
  {
    v12();
    a1[18] = 0;
  }
  while (1)
  {
    v13 = a1[12];
    if (!v13)
      break;
    a1[12] = *(_QWORD *)(v13 + 16);
    if (*(_QWORD *)v13)
      CFRelease(*(CFTypeRef *)v13);
    *(_QWORD *)v13 = 0;
    *(_QWORD *)(v13 + 8) = 0;
    *(_QWORD *)(v13 + 16) = 0;
    free((void *)v13);
  }
  v3[16] = 0;
  result = 0.0;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  return result;
}

CFStringRef _AMFDRCopyFormattingDescription(uint64_t a1)
{
  if (!a1)
    _AMFDRCopyFormattingDescription_cold_1();
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("optionsDict=%@"), *(_QWORD *)(a1 + 16));
}

__SecTask *AMFDREntitlementIsEntitled(const __CFString *a1)
{
  __SecTask *v2;
  __SecTask *v3;
  const __CFBoolean *v4;
  const __CFBoolean *v5;
  BOOL v6;
  CFTypeID v7;
  _BOOL8 v8;
  CFErrorRef error;

  error = 0;
  v2 = SecTaskCreateFromSelf(0);
  v3 = v2;
  if (!v2)
    return v3;
  v4 = (const __CFBoolean *)SecTaskCopyValueForEntitlement(v2, a1, &error);
  v5 = v4;
  if (error)
    v6 = 1;
  else
    v6 = v4 == 0;
  if (v6 || (v7 = CFGetTypeID(v4), v7 != CFBooleanGetTypeID()))
  {
    AMSupportLogInternal();
    CFRelease(v3);
    v8 = 0;
    v3 = 0;
    if (!v5)
      goto LABEL_10;
  }
  else
  {
    v8 = CFBooleanGetValue(v5) != 0;
    CFRelease(v3);
  }
  CFRelease(v5);
  v3 = (__SecTask *)v8;
LABEL_10:
  if (error)
    CFRelease(error);
  return v3;
}

CFTypeRef AMFDRPlatformCopyDefaultClientIdByInterface(const void *a1)
{
  uint64_t i;
  size_t v3;
  CFTypeRef v4;
  if_nameindex *v5;
  if_nameindex *v6;
  char *if_name;
  char **p_if_name;
  size_t v9;
  CFTypeRef v10;
  char *v11;
  CFTypeRef v12;

  if (a1)
  {
    for (i = 0; i != 4; ++i)
    {
      v3 = strlen(off_24C69EC98[i]);
      v4 = _CopyClientIdForAdapter(a1, off_24C69EC98[i], v3);
      if (v4)
      {
        v12 = v4;
        AMSupportLogInternal();
        return v12;
      }
    }
    v5 = if_nameindex();
    if (!v5)
      goto LABEL_17;
    v6 = v5;
    if_name = v5->if_name;
    if (if_name)
    {
      p_if_name = &v5[1].if_name;
      do
      {
        if (!strncmp(if_name, "lo0", 3uLL))
        {
          AMSupportLogInternal();
        }
        else
        {
          v9 = strlen(if_name);
          v10 = _CopyClientIdForAdapter(a1, if_name, v9);
          if (v10)
          {
            v12 = v10;
            AMSupportLogInternal();
            goto LABEL_15;
          }
        }
        v11 = *p_if_name;
        p_if_name += 2;
        if_name = v11;
      }
      while (v11);
    }
    AMSupportLogInternal();
    v12 = 0;
LABEL_15:
    MEMORY[0x212BA108C](v6);
  }
  else
  {
LABEL_17:
    AMSupportLogInternal();
    return 0;
  }
  return v12;
}

CFTypeRef _CopyClientIdForAdapter(const void *a1, char *a2, size_t a3)
{
  unsigned __int8 *v6;
  uint64_t v7;
  int v8;
  CFTypeRef v9;
  ifaddrs *v10;
  unsigned __int8 *v11;
  sockaddr *ifa_addr;
  const __CFAllocator *v13;
  CFStringRef v14;
  CFStringRef v15;
  size_t size;
  ifaddrs *v18;
  int v19[6];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v18 = 0;
  memset(v19, 170, sizeof(v19));
  size = 0xAAAAAAAAAAAAAAAALL;
  if (!a1 || !a2 || !a3)
  {
    AMSupportLogInternal();
LABEL_24:
    v9 = 0;
    v6 = 0;
    goto LABEL_17;
  }
  *(_OWORD *)v19 = xmmword_20D397970;
  v19[4] = 3;
  v19[5] = if_nametoindex(a2);
  if (!v19[5] || sysctl(v19, 6u, 0, &size, 0, 0) < 0)
    goto LABEL_24;
  v6 = (unsigned __int8 *)malloc_type_malloc(size, 0xB277081FuLL);
  if (!v6 || sysctl(v19, 6u, v6, &size, 0, 0) < 0)
    goto LABEL_14;
  v7 = v6[117];
  v8 = getifaddrs(&v18);
  v9 = 0;
  v10 = v18;
  if (!v8 && v18)
  {
    v11 = &v6[v7 + 120];
    while (1)
    {
      if (!strncmp(a2, v10->ifa_name, a3))
      {
        ifa_addr = v10->ifa_addr;
        if (ifa_addr->sa_family == 2)
          break;
      }
      v10 = v10->ifa_next;
      if (!v10)
        goto LABEL_14;
    }
    v13 = CFGetAllocator(a1);
    v14 = CFStringCreateWithFormat(v13, 0, CFSTR("%02x:%02x:%02x:%02x:%02x:%02x/%u.%u.%u.%u"), *v11, v11[1], v11[2], v11[3], v11[4], v11[5], ifa_addr->sa_data[2], ifa_addr->sa_data[3], ifa_addr->sa_data[4], ifa_addr->sa_data[5]);
    if (v14)
    {
      v15 = v14;
      v9 = CFRetain(v14);
      CFRelease(v15);
      goto LABEL_17;
    }
LABEL_14:
    v9 = 0;
LABEL_17:
    v10 = v18;
  }
  if (v10)
  {
    MEMORY[0x212BA1050](v10);
    v18 = 0;
  }
  if (v6)
    free(v6);
  return v9;
}

uint64_t AMFDRPlatformCopyDefaultClientIdByECID()
{
  const __CFString *v0;
  const __CFString *v1;
  const __CFAllocator *v2;
  CFStringRef v3;
  CFStringRef v4;
  const __CFString *v5;
  CFStringRef v6;
  CFStringRef v7;
  CFStringRef v8;
  uint64_t v9;

  v0 = AMFDRSealingMapCallMGCopyAnswer(CFSTR("UniqueChipID"), 0);
  if (!v0)
  {
    AMSupportLogInternal();
    return 0;
  }
  v1 = v0;
  v2 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v3 = AMFDRCreateInstanceString((const __CFAllocator *)*MEMORY[0x24BDBD240], v0);
  if (!v3)
  {
    AMSupportLogInternal();
    CFRelease(v1);
    return 0;
  }
  v4 = v3;
  v5 = AMFDRSealingMapCallMGCopyAnswer(CFSTR("ChipID"), 0);
  if (v5)
  {
    v6 = AMFDRCreateInstanceString(v2, v5);
    v7 = v6;
    if (v6)
    {
      v8 = CFStringCreateWithFormat(v2, 0, CFSTR("%@-%@"), v6, v4);
      if (v8)
      {
        v9 = AMSupportSafeRetain();
      }
      else
      {
        AMSupportLogInternal();
        v9 = 0;
      }
      goto LABEL_7;
    }
    AMSupportLogInternal();
    v9 = 0;
  }
  else
  {
    AMSupportLogInternal();
    v9 = 0;
    v7 = 0;
  }
  v8 = 0;
LABEL_7:
  CFRelease(v4);
  CFRelease(v1);
  if (v5)
    CFRelease(v5);
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  return v9;
}

uint64_t AMFDRPlatformCopyDefaultDataDirectoryAppendingPathComponent(const void *a1)
{
  uid_t v2;
  passwd *v3;
  const char *pw_dir;
  const __CFAllocator *v5;
  CFIndex v6;
  CFURLRef v7;
  const __CFURL *v8;
  const __CFAllocator *v9;
  CFURLRef v10;
  CFURLRef v11;

  v2 = getuid();
  v3 = getpwuid(v2);
  if (v3)
  {
    pw_dir = v3->pw_dir;
    if (pw_dir)
    {
      v5 = CFGetAllocator(a1);
      v6 = strlen(pw_dir);
      v7 = CFURLCreateFromFileSystemRepresentation(v5, (const UInt8 *)pw_dir, v6, 0);
      if (v7)
      {
        v8 = v7;
        v9 = CFGetAllocator(a1);
        v10 = CFURLCreateCopyAppendingPathComponent(v9, v8, CFSTR("Library/Application Support/FDR"), 1u);
        if (v10)
        {
          v11 = v10;
          if (!MEMORY[0x212BA04D4]())
          {
            CFGetAllocator(a1);
            AMSupportCopyURLWithAppendedComponent();
          }
          CFRelease(v8);
        }
        else
        {
          v11 = v8;
        }
        CFRelease(v11);
      }
    }
  }
  return 0;
}

CFURLRef AMFDRPlatformCopyDefaultDataStoragePath()
{
  const char *v0;
  CFIndex v1;
  CFURLRef v2;
  const __CFBoolean *v3;
  const __CFAllocator *v4;
  const __CFString *v5;

  if (MEMORY[0x24BE63548])
  {
    v0 = (const char *)malloc_type_calloc(1uLL, 0x400uLL, 0x4FE1BD39uLL);
    if (!v0 || lookupPathForPersistentData())
      goto LABEL_11;
    v1 = strlen(v0);
    v2 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x24BDBD240], (const UInt8 *)v0, v1, 0);
  }
  else
  {
    v3 = (const __CFBoolean *)MGCopyAnswer();
    v4 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v5 = CFSTR("/System/Library/Caches/com.apple.factorydata");
    if (v3 && CFBooleanGetValue(v3) == 1)
      v5 = CFSTR("/mnt1/System/Library/Caches/com.apple.factorydata");
    v2 = CFURLCreateWithFileSystemPath(v4, v5, kCFURLPOSIXPathStyle, 1u);
  }
  if (!v2)
  {
LABEL_11:
    AMSupportLogInternal();
    v2 = 0;
  }
  AMSupportSafeFree();
  AMSupportSafeRelease();
  return v2;
}

CFStringRef AMFDRDataCreateString(const __CFAllocator *a1, const __CFString *cf, int a3)
{
  CFTypeID v6;
  CFTypeID v7;
  CFIndex Length;
  CFIndex v9;
  BOOL v10;
  CFIndex v11;
  int CharacterAtIndex;
  uint64_t v14;
  CFStringRef result;
  CFTypeID v16;
  CFTypeID v17;
  const char *v18;
  CFTypeID v19;
  unint64_t ByteSize;
  int v21;
  unint64_t v22;
  int valuePtr;

  if (!cf)
    return 0;
  v6 = CFGetTypeID(cf);
  if (v6 == CFStringGetTypeID())
  {
    if (!a3)
      return CFStringCreateCopy(a1, cf);
    v7 = CFGetTypeID(cf);
    if (v7 == CFStringGetTypeID())
    {
      Length = CFStringGetLength(cf);
      if ((unint64_t)(Length - 211) < 0xFFFFFFFFFFFFFF2ELL)
      {
        AMSupportLogInternal();
      }
      else
      {
        v9 = Length;
        v10 = 0;
        v11 = 0;
        do
        {
          CharacterAtIndex = CFStringGetCharacterAtIndex(cf, v11);
          if ((CharacterAtIndex - 48) >= 0xA && (CharacterAtIndex & 0xFFFFFFDF) - 65 >= 0x1A)
          {
            v14 = 0;
            while (CharacterAtIndex != asc_20D39F97B[v14])
            {
              if (++v14 == 4)
                goto LABEL_16;
            }
          }
          v10 = ++v11 >= v9;
        }
        while (v11 != v9);
LABEL_16:
        if (v10)
          return CFStringCreateCopy(a1, cf);
      }
    }
    goto LABEL_37;
  }
  v16 = CFGetTypeID(cf);
  if (v16 == CFDataGetTypeID())
    return (CFStringRef)AMSupportCopyHexStringFromData();
  v17 = CFGetTypeID(cf);
  if (v17 == CFBooleanGetTypeID())
  {
    if ((const __CFString *)*MEMORY[0x24BDBD270] == cf)
      v18 = "1";
    else
      v18 = "0";
    return CFStringCreateWithFormat(a1, 0, CFSTR("%s"), v18);
  }
  v19 = CFGetTypeID(cf);
  if (v19 != CFNumberGetTypeID() || CFNumberIsFloatType((CFNumberRef)cf))
    goto LABEL_37;
  ByteSize = CFNumberGetByteSize((CFNumberRef)cf);
  if (ByteSize <= 4)
  {
    valuePtr = -1431655766;
    if (CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, &valuePtr))
      goto LABEL_29;
    goto LABEL_43;
  }
  if (ByteSize != 8)
  {
LABEL_37:
    AMSupportLogInternal();
    return 0;
  }
  v22 = 0xAAAAAAAAAAAAAAAALL;
  if (CFNumberGetValue((CFNumberRef)cf, kCFNumberLongLongType, &v22))
  {
    if (HIDWORD(v22))
    {
      result = (CFStringRef)AMSupportCopyHexStringFromUInt64();
      goto LABEL_30;
    }
LABEL_29:
    result = (CFStringRef)AMSupportCopyHexStringFromUInt32();
LABEL_30:
    v21 = 1;
    goto LABEL_31;
  }
LABEL_43:
  result = (CFStringRef)AMSupportLogInternal();
  v21 = 4;
LABEL_31:
  if (v21 == 4)
    return 0;
  return result;
}

CFStringRef AMFDRCreateInstanceString(const __CFAllocator *a1, const __CFString *a2)
{
  return AMFDRDataCreateString(a1, a2, 1);
}

const __CFString *AMFDRDataCreateSikInstanceString(const __CFAllocator *a1, uint64_t a2)
{
  __CFString *v3;
  const __CFString *SikInstanceStringInternal;

  v3 = (__CFString *)AMFDRCreateTypeWithOptions(a1, CFSTR("Local"), 0);
  if (v3)
  {
    SikInstanceStringInternal = AMFDRDataCreateSikInstanceStringInternal(v3, 0, a2);
  }
  else
  {
    AMSupportLogInternal();
    SikInstanceStringInternal = 0;
  }
  AMSupportSafeRelease();
  return SikInstanceStringInternal;
}

const __CFString *AMFDRDataCreateSikInstanceStringInternal(__CFString *cf, uint64_t a2, uint64_t a3)
{
  const __CFString *v3;
  uint64_t SikPub;
  const __CFAllocator *v6;
  const __CFString *v7;
  const __CFString *v8;

  v3 = cf;
  if (cf)
  {
    if (a3
      && (a2 && (SikPub = (uint64_t)AMFDRGetSikOverride(cf, a2, a3)) != 0
       || (SikPub = AMFDRCryptoGetSikPub((uint64_t)v3)) != 0)
      && (v6 = CFGetAllocator(v3),
          v7 = CFStringCreateWithFormat(v6, 0, CFSTR("sik-%@-%@"), a3, SikPub),
          (v8 = v7) != 0)
      && CFStringGetLength(v7) < 211)
    {
      v3 = v8;
    }
    else
    {
      AMSupportLogInternal();
      v3 = 0;
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  AMSupportSafeRelease();
  return v3;
}

const __CFString *AMFDRDataCreateInstanceString(__CFString *a1, uint64_t a2, const void *a3)
{
  if (a3)
  {
    if (AMFDRDataInstanceUseSikFormat((uint64_t)a1))
      return AMFDRDataCreateSikInstanceStringInternal(a1, a2, (uint64_t)a3);
    else
      return (const __CFString *)CFRetain(a3);
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
}

BOOL AMFDRDataInstanceUseSikFormat(uint64_t a1)
{
  uint64_t v2;
  _BOOL8 v3;
  const __CFDictionary *v4;
  const __CFBoolean *Value;

  if (!a1)
    return AMFDRSealingMapGetFDRDataVersionForDeviceInternal(0) == 2;
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8);
  if ((v2 & 8) != 0)
  {
    v3 = 1;
    if ((v2 & 2) != 0)
      return 0;
  }
  else
  {
    v3 = AMFDRSealingMapGetFDRDataVersionForDeviceInternal(a1) == 2;
    if ((*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) & 2) != 0)
      return 0;
  }
  v4 = (const __CFDictionary *)AMFDRGetOptions(a1);
  if (v4)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v4, CFSTR("UseSikDataInstance"));
    if (Value)
      return CFBooleanGetValue(Value) != 0;
  }
  else
  {
    AMSupportLogInternal();
  }
  return v3;
}

const __CFString *AMFDRDataCreatePermissionsString(__CFString *cf, unsigned int a2, const __CFString *a3, const __CFString *a4)
{
  const __CFString *v4;
  const __CFAllocator *v8;
  __CFString *Mutable;
  __CFString *v10;

  v4 = a4;
  if (a4)
  {
    if (cf)
      v8 = CFGetAllocator(cf);
    else
      v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    Mutable = CFStringCreateMutable(v8, 0);
    if (Mutable)
    {
      v10 = Mutable;
      if ((AMFDRDataAppendPermissionsString(cf, a2, a3, v4, Mutable) & 1) != 0)
      {
        v4 = (const __CFString *)CFRetain(v10);
      }
      else
      {
        AMSupportLogInternal();
        v4 = 0;
      }
      CFRelease(v10);
    }
    else
    {
      AMSupportLogInternal();
      return 0;
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  return v4;
}

uint64_t AMFDRDataAppendPermissionsString(__CFString *cf, unsigned int a2, const __CFString *a3, const __CFString *a4, __CFString *a5)
{
  uint64_t v10;
  const __CFString *SikInstanceStringInternal;
  const __CFString *v12;
  const __CFString *InstanceString;

  if (!a4)
    goto LABEL_16;
  if (a2 == 10)
    goto LABEL_7;
  if (a2 != 8)
  {
    InstanceString = AMFDRDataCreateInstanceString(cf, (uint64_t)a3, a4);
    if (InstanceString)
    {
      v12 = InstanceString;
      if ((AMFDRAppendPermissionsString(a2, a3, InstanceString, a5) & 1) == 0)
      {
LABEL_17:
        AMSupportLogInternal();
        v10 = 0;
        goto LABEL_14;
      }
LABEL_13:
      v10 = 1;
LABEL_14:
      CFRelease(v12);
      return v10;
    }
LABEL_16:
    AMSupportLogInternal();
    return 0;
  }
  if (!AMFDRSealingMapEntryHasAttributeForClassInternal((uint64_t)cf, a3, CFSTR("ChallengeClaim"), 0))
  {
LABEL_7:
    SikInstanceStringInternal = AMFDRDataCreateSikInstanceStringInternal(cf, (uint64_t)a3, (uint64_t)a4);
    if (SikInstanceStringInternal)
    {
      v12 = SikInstanceStringInternal;
      if ((AMFDRAppendPermissionsString(1u, a3, SikInstanceStringInternal, a5) & 1) == 0
        || (AMFDRAppendPermissionsString(0, a3, a4, a5) & 1) == 0)
      {
        goto LABEL_17;
      }
      goto LABEL_13;
    }
    goto LABEL_16;
  }
  if ((AMFDRAppendPermissionsString(8u, a3, a4, a5) & 1) == 0)
    goto LABEL_16;
  return 1;
}

const __CFString *AMFDRCreatePermissionsString(const __CFAllocator *a1, unsigned int a2, const __CFString *a3, const __CFString *a4)
{
  const __CFString *v4;
  __CFString *Mutable;
  __CFString *v8;

  if (!a3)
    goto LABEL_10;
  v4 = a4;
  if (!a4)
  {
    AMSupportLogInternal();
    return v4;
  }
  Mutable = CFStringCreateMutable(a1, 0);
  if (!Mutable)
  {
LABEL_10:
    AMSupportLogInternal();
    return 0;
  }
  v8 = Mutable;
  if ((AMFDRAppendPermissionsString(a2, a3, v4, Mutable) & 1) != 0)
  {
    v4 = (const __CFString *)CFRetain(v8);
  }
  else
  {
    AMSupportLogInternal();
    v4 = 0;
  }
  CFRelease(v8);
  return v4;
}

uint64_t AMFDRAppendPermissionsString(unsigned int a1, CFStringRef theString, const __CFString *a3, __CFString *a4)
{
  __CFString *v9;
  const __CFString *v10;
  CFIndex Length;
  const __CFString *v12;
  const __CFString *v13;

  if (!theString
    || !a3
    || !a4
    || a1 >= 0xF
    || ((0x7BFFu >> a1) & 1) == 0
    || (v9 = off_24C69ED38[a1], !CFStringGetLength(theString))
    || !CFStringGetLength(a3))
  {
    AMSupportLogInternal();
    return 0;
  }
  if (a1 == 13)
  {
    Length = CFStringGetLength(a4);
    v12 = CFSTR(";%@/Mothership");
    v13 = CFSTR("%@/Mothership");
  }
  else
  {
    if (a1 != 7 || CFStringCompare(theString, CFSTR("*"), 0) || CFStringCompare(a3, CFSTR("*"), 0))
    {
      if (CFStringGetLength(a4))
        v10 = CFSTR(";%@/%@:%@");
      else
        v10 = CFSTR("%@/%@:%@");
      CFStringAppendFormat(a4, 0, v10, v9, theString, a3);
      return 1;
    }
    Length = CFStringGetLength(a4);
    v12 = CFSTR(";%@/*");
    v13 = CFSTR("%@/*");
  }
  if (Length)
    CFStringAppendFormat(a4, 0, v12, v9);
  else
    CFStringAppendFormat(a4, 0, v13, v9);
  return 1;
}

uint64_t _AMFDRApTicketIsAppleSigned(const __CFData *a1)
{
  __int128 v1;
  const __CFString *v3;
  const __CFNumber *v4;
  CFTypeID v5;
  const __CFString *v6;
  const __CFNumber *v7;
  CFTypeID v8;
  uint64_t inited;
  uint64_t v10;
  unint64_t v12;
  unint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  unint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v42 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v1 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40 = v1;
  v41 = v1;
  v38 = v1;
  v39 = v1;
  v36 = v1;
  v37 = v1;
  v34 = v1;
  v35 = v1;
  v32 = v1;
  v33 = v1;
  v30 = v1;
  v31 = v1;
  v28 = v1;
  v29 = v1;
  v26 = v1;
  v27 = v1;
  v24 = v1;
  v25 = v1;
  v22 = v1;
  v23 = v1;
  v20 = v1;
  v21 = v1;
  v18 = v1;
  v19 = v1;
  v16 = v1;
  v17 = v1;
  v14 = v1;
  v15 = v1;
  v12 = 0xAAAAAAAAAAAAAAAALL;
  v13 = 0xAAAAAAAAAAAAAAAALL;
  if (!a1)
  {
    AMSupportLogInternal();
    v10 = 6;
    goto LABEL_10;
  }
  v3 = AMFDRSealingMapCallMGCopyAnswer(CFSTR("ChipID"), 0);
  v4 = (const __CFNumber *)v3;
  if (!v3 || (v5 = CFGetTypeID(v3), v5 != CFNumberGetTypeID()))
  {
    AMSupportLogInternal();
LABEL_15:
    v10 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  v6 = AMFDRSealingMapCallMGCopyAnswer(CFSTR("UniqueChipID"), 0);
  v7 = (const __CFNumber *)v6;
  if (!v6
    || (v8 = CFGetTypeID(v6), v8 != CFNumberGetTypeID())
    || !CFNumberGetValue(v4, kCFNumberSInt64Type, &v12)
    || !CFNumberGetValue(v7, kCFNumberSInt64Type, &v13))
  {
    AMSupportLogInternal();
    goto LABEL_15;
  }
  CFDataGetBytePtr(a1);
  CFDataGetLength(a1);
  inited = Img4DecodeInitManifest();
  if ((_DWORD)inited)
  {
    v10 = inited;
    AMSupportLogInternal();
  }
  else
  {
    v10 = Img4DecodePerformTrustEvaluation();
  }
LABEL_10:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v10;
}

uint64_t _AMFDRApTicketPropertyCallback(int a1, uint64_t a2, int a3, uint64_t *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t PropertyInteger64;
  uint64_t v9;

  if (a4)
  {
    if (a3)
      return 0;
    v6 = *a4;
    v7 = a4[1];
    if (a1 != 1162037572 && a1 != 1128810832)
      return 0;
    PropertyInteger64 = Img4DecodeGetPropertyInteger64();
    if (!(_DWORD)PropertyInteger64)
    {
      if (a1 == 1128810832)
      {
        if (v6)
          goto LABEL_11;
      }
      else if (v7)
      {
LABEL_11:
        AMSupportLogInternal();
        return 1;
      }
      return 0;
    }
    v9 = PropertyInteger64;
    AMSupportLogInternal();
    return v9;
  }
  else
  {
    AMSupportLogInternal();
    return 6;
  }
}

uint64_t AMFDRDataApTicketIsTrusted(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  uint64_t v3;
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  const __CFBoolean *Value;
  const __CFBoolean *v7;
  CFTypeID v8;
  const __CFString *v9;
  const __CFString *v10;
  size_t v11;
  const UInt8 *BytePtr;
  const __CFBoolean *v13;
  const __CFBoolean *v14;
  CFTypeID v15;
  const __CFString *v16;
  const __CFData *v17;
  const UInt8 *v18;
  uint64_t v19;
  _OWORD __s1[3];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __s1[1] = v2;
  __s1[2] = v2;
  __s1[0] = v2;
  if (!a1)
    goto LABEL_33;
  v3 = a2;
  if (!a2)
  {
    AMSupportLogInternal();
    goto LABEL_29;
  }
  v4 = (const __CFDictionary *)AMFDRGetOptions(a1);
  v5 = v4;
  if (!v4)
    goto LABEL_33;
  Value = (const __CFBoolean *)CFDictionaryGetValue(v4, CFSTR("APTicketAllowUntrusted"));
  if (!Value || (v7 = Value, v8 = CFGetTypeID(Value), v8 != CFBooleanGetTypeID()) || CFBooleanGetValue(v7) != 1)
  {
    v9 = AMFDRSealingMapCallMGCopyAnswer(CFSTR("BootManifestHash"), 0);
    if (v9)
    {
      v10 = AMFDRSealingMapCallMGCopyAnswer(CFSTR("Image4CryptoHashMethod"), 0);
      if (v10)
      {
        if (CFStringCompare(v10, CFSTR("sha2-384"), 1uLL))
        {
          AMSupportLogInternal();
          CFDataGetBytePtr((CFDataRef)v3);
          CFDataGetLength((CFDataRef)v3);
          v11 = 20;
          if (!AMSupportDigestSha1())
            goto LABEL_12;
        }
        else
        {
          CFDataGetBytePtr((CFDataRef)v3);
          CFDataGetLength((CFDataRef)v3);
          v11 = 48;
          if (!AMSupportDigestSha384())
          {
LABEL_12:
            BytePtr = CFDataGetBytePtr((CFDataRef)v9);
            if (!memcmp(__s1, BytePtr, v11))
              goto LABEL_27;
            AMSupportLogInternal();
            AMSupportLogDumpMemory();
            CFDataGetBytePtr((CFDataRef)v9);
            CFDataGetLength((CFDataRef)v9);
            AMSupportLogDumpMemory();
            v13 = (const __CFBoolean *)CFDictionaryGetValue(v5, CFSTR("APTicketAllowDigestMismatch"));
            if (v13 && (v14 = v13, v15 = CFGetTypeID(v13), v15 == CFBooleanGetTypeID()) && CFBooleanGetValue(v14) == 1
              || os_variant_is_recovery())
            {
              AMSupportLogInternal();
            }
            else
            {
              v16 = _AMFDRCopyDataFromDeviceTree("IODeviceTree:/chosen", CFSTR("mix-n-match-prevention-status"));
              v17 = (const __CFData *)v16;
              if (!v16)
              {
LABEL_34:
                v3 = 0;
                goto LABEL_29;
              }
              v18 = CFDataGetBytePtr((CFDataRef)v16);
              if (CFDataGetLength(v17) >= 1)
              {
                v19 = 0;
                while (!v18[v19])
                {
                  if (++v19 >= CFDataGetLength(v17))
                    goto LABEL_26;
                }
LABEL_30:
                AMSupportLogInternal();
                goto LABEL_34;
              }
            }
LABEL_26:
            if (!_AMFDRApTicketIsAppleSigned((const __CFData *)v3))
            {
LABEL_27:
              AMSupportLogInternal();
              goto LABEL_28;
            }
            goto LABEL_30;
          }
        }
      }
    }
LABEL_33:
    AMSupportLogInternal();
    goto LABEL_34;
  }
  AMSupportLogInternal();
LABEL_28:
  v3 = 1;
LABEL_29:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v3;
}

const __CFString *_AMFDRCopyDataFromDeviceTree(char *path, const __CFString *a2)
{
  const __CFString *v2;
  io_registry_entry_t v3;
  io_object_t v4;
  CFTypeRef CFProperty;
  const void *v6;
  CFTypeID v7;

  v2 = a2;
  if (a2)
  {
    v3 = IORegistryEntryFromPath(*MEMORY[0x24BDD8B18], path);
    if (v3)
    {
      v4 = v3;
      CFProperty = IORegistryEntryCreateCFProperty(v3, v2, (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
      v6 = CFProperty;
      if (CFProperty && (v7 = CFGetTypeID(CFProperty), v7 == CFDataGetTypeID()))
      {
        v2 = (const __CFString *)CFRetain(v6);
      }
      else
      {
        AMSupportLogInternal();
        v2 = 0;
      }
      IOObjectRelease(v4);
    }
    else
    {
      AMSupportLogInternal();
      v2 = 0;
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  AMSupportSafeRelease();
  return v2;
}

uint64_t AMFDRDataApTicketPopulate(uint64_t a1)
{
  uint64_t v1;
  const __CFDictionary *v2;
  const __CFBoolean *v3;
  uint64_t v4;
  const void *Value;
  const __CFString *v6;
  _QWORD block[5];
  const __CFString *v9;

  v1 = a1;
  v9 = 0;
  if (!a1)
  {
    AMSupportLogInternal();
    goto LABEL_11;
  }
  v2 = *(const __CFDictionary **)(a1 + 16);
  if (!v2)
  {
    AMSupportLogInternal();
    v1 = 0;
    goto LABEL_11;
  }
  if (CFDictionaryContainsKey(v2, CFSTR("APTicket")) || (*(_BYTE *)(*(_QWORD *)(v1 + 136) + 8) & 1) != 0)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v1 + 16), CFSTR("APTicket"));
    v6 = (const __CFString *)CFRetain(Value);
    v9 = v6;
  }
  else
  {
    v3 = (const __CFBoolean *)MGCopyAnswer();
    if (v3 && !CFBooleanGetValue(v3))
    {
      block[0] = MEMORY[0x24BDAC760];
      block[1] = 0x40000000;
      block[2] = __AMFDRDataApTicketPopulate_block_invoke;
      block[3] = &__block_descriptor_tmp_0;
      block[4] = v1;
      if (AMFDRDataApTicketPopulate_onceToken != -1)
        dispatch_once(&AMFDRDataApTicketPopulate_onceToken, block);
      v4 = AMSupportSafeRetain();
    }
    else
    {
      v4 = (uint64_t)_AMFDRDataApTicketCopyURL();
    }
    if (!v4 || AMSupportCreateDataFromFileURL())
      goto LABEL_20;
    CFDataGetLength((CFDataRef)v9);
    AMSupportLogInternal();
    AMFDRSetOption(v1, CFSTR("APTicket"), v9);
    v6 = v9;
  }
  if ((AMFDRDataApTicketIsTrusted(v1, (uint64_t)v6) & 1) == 0)
  {
LABEL_20:
    AMSupportLogInternal();
    v1 = 0;
    goto LABEL_11;
  }
  v1 = 1;
LABEL_11:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v1;
}

CFURLRef _AMFDRDataApTicketCopyURL()
{
  char *v0;
  char *v1;
  CFIndex v2;
  CFURLRef v3;

  if (!MEMORY[0x24BE63558])
    return CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x24BDBD240], (const UInt8 *)"/System/Library/Caches/apticket.der", 36, 0);
  v0 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0xC8DDA17FuLL);
  if (v0)
  {
    v1 = v0;
    if (lookupPathForPersonalizedData())
    {
      AMSupportLogInternal();
      v3 = 0;
    }
    else
    {
      v2 = strlen(v1);
      v3 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x24BDBD240], (const UInt8 *)v1, v2, 0);
    }
    free(v1);
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
  return v3;
}

CFDataRef AMFDRDataApTicketCopyObjectProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFDictionary *v3;
  const __CFData *Value;
  const __CFData *v5;
  CFDataRef result;

  if (!a1
    || (v3 = *(const __CFDictionary **)(a1 + 16)) == 0
    || !a2
    || !a3
    || (Value = (const __CFData *)CFDictionaryGetValue(v3, CFSTR("APTicket"))) == 0
    || (v5 = Value, CFDataGetBytePtr(Value), CFDataGetLength(v5), Img4DecodeInitManifest())
    || Img4DecodeGetObjectPropertyData()
    || (result = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0xAAAAAAAAAAAAAAAALL)) == 0)
  {
    AMSupportLogInternal();
    return 0;
  }
  return result;
}

CFDataRef AMFDRDataApTicketCopyTrustObjectDigest(uint64_t a1)
{
  const __CFString *v2;
  const __CFString *v3;
  uint64_t v4;
  CFDataRef v5;

  v2 = AMFDRSealingMapCallMGCopyAnswer(CFSTR("RestoreOSBuild"), 0);
  if (!v2)
    return AMFDRDataApTicketCopyObjectProperty(a1, 1718903152, 1145525076);
  v3 = v2;
  if (CFBooleanGetValue((CFBooleanRef)v2) == 1)
    v4 = 1919317089;
  else
    v4 = 1718903152;
  v5 = AMFDRDataApTicketCopyObjectProperty(a1, v4, 1145525076);
  CFRelease(v3);
  return v5;
}

uint64_t AMFDRDataSetApTicketAndGetNewestTrustObject(const __CFString *a1, uint64_t a2, _QWORD *cf)
{
  __int128 v4;
  uint64_t v6;
  const __CFString *v7;
  const __CFString *v8;
  CFAllocatorRef *v9;
  CFDataRef v10;
  CFDataRef v11;
  _QWORD *v12;
  _QWORD *v13;
  CFDataRef theData;
  UInt8 bytes[16];
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)bytes = v4;
  v17 = v4;
  theData = 0;
  if (!a1)
    goto LABEL_30;
  if (!a2)
    goto LABEL_29;
  v6 = (uint64_t)cf;
  if (!cf)
  {
    AMSupportLogInternal();
    goto LABEL_23;
  }
  if (!*(_QWORD *)(a2 + 16) || !cf[2])
  {
LABEL_29:
    AMSupportLogInternal();
    v6 = 0;
    goto LABEL_23;
  }
  AMFDRSetOption((uint64_t)cf, CFSTR("APTicket"), a1);
  AMFDRSetOption(a2, CFSTR("APTicket"), a1);
  v7 = (const __CFString *)AMFDRDataApTicketCopyObjectProperty(a2, 1919317089, 1145525076);
  if (!v7)
    goto LABEL_30;
  AMFDRSetOption(a2, CFSTR("TrustObjectDigest"), v7);
  AMFDRSetOption(v6, CFSTR("TrustObjectDigest"), v7);
  if (AMFDRIsNonDefaultDemotionState_onceToken != -1)
    dispatch_once(&AMFDRIsNonDefaultDemotionState_onceToken, &__block_literal_global_0);
  if (AMFDRIsNonDefaultDemotionState_result)
  {
    AMSupportLogInternal();
    v8 = (const __CFString *)*MEMORY[0x24BDBD270];
    AMFDRSetOption(a2, CFSTR("SkipVerifySik"), (const __CFString *)*MEMORY[0x24BDBD270]);
    AMFDRSetOption(v6, CFSTR("SkipVerifySik"), v8);
  }
  (*(void (**)(uint64_t, _QWORD, CFDataRef *, _QWORD))(*(_QWORD *)(a2 + 48) + 56))(a2, 0, &theData, 0);
  v9 = (CFAllocatorRef *)MEMORY[0x24BDBD240];
  if (!theData)
    goto LABEL_36;
  CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  if (AMSupportDigestSha256())
    goto LABEL_30;
  v10 = CFDataCreate(*v9, bytes, 32);
  if (!v10)
    goto LABEL_30;
  AMSupportLogInternal();
  if (!theData || !CFEqual(v7, v10))
  {
LABEL_36:
    AMSupportLogInternal();
    AMSupportSafeRelease();
    theData = 0;
    (*(void (**)(uint64_t, _QWORD, CFDataRef *, _QWORD))(*(_QWORD *)(v6 + 48) + 56))(v6, 0, &theData, 0);
    if (!theData)
      goto LABEL_30;
  }
  AMSupportSafeRelease();
  CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  if (AMSupportDigestSha256()
    || (v11 = CFDataCreate(*v9, bytes, 32)) == 0
    || !CFEqual(v7, v11)
    || (v12 = AMFDRCreateCopy(a2), (v13 = v12) == 0)
    || (AMFDRSetOption((uint64_t)v12, CFSTR("SignData"), (const __CFString *)*MEMORY[0x24BDBD268]),
        ((*(uint64_t (**)(_QWORD *, CFDataRef, _QWORD))(v13[6] + 64))(v13, theData, 0) & 1) == 0))
  {
LABEL_30:
    AMSupportLogInternal();
    v6 = 0;
    goto LABEL_23;
  }
  AMFDRSetOption(a2, CFSTR("TrustObject"), (const __CFString *)theData);
  AMFDRSetOption(v6, CFSTR("TrustObject"), (const __CFString *)theData);
  v6 = 1;
LABEL_23:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v6;
}

uint64_t AMFDRIsNonDefaultDemotionState()
{
  if (AMFDRIsNonDefaultDemotionState_onceToken != -1)
    dispatch_once(&AMFDRIsNonDefaultDemotionState_onceToken, &__block_literal_global_0);
  return AMFDRIsNonDefaultDemotionState_result;
}

uint64_t AMFDRDataCopyTrustObject(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 56))();
}

uint64_t AMFDRDataPutTrustObject(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 64))();
}

uint64_t AMFDRAllowIncompleteData(uint64_t a1)
{
  const __CFDictionary *v2;
  const __CFBoolean *Value;
  const __CFBoolean *v4;
  CFTypeID v5;

  v2 = (const __CFDictionary *)AMFDRGetOptions(a1);
  if (v2)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v2, CFSTR("AllowIncompleteData"));
    if (Value)
    {
      v4 = Value;
      v5 = CFGetTypeID(Value);
      if (v5 == CFBooleanGetTypeID() && CFBooleanGetValue(v4) == 1)
        return 1;
    }
  }
  if ((_AMFDRAPTicketHasBooleanEntitlement(a1) & 1) != 0)
    return 1;
  else
    return _AMFDRAPTicketHasBooleanEntitlement(a1);
}

uint64_t _AMFDRAPTicketHasBooleanEntitlement(uint64_t a1)
{
  const __CFDictionary *v2;
  const __CFData *Value;
  const __CFData *v4;
  int BooleanFromSection;
  uint64_t result;

  if (!a1)
    goto LABEL_10;
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 136) + 8) & 1) != 0)
    return 0;
  v2 = (const __CFDictionary *)AMFDRGetOptions(a1);
  if (!v2
    || (Value = (const __CFData *)CFDictionaryGetValue(v2, CFSTR("APTicket"))) == 0
    || (v4 = Value, (AMFDRDataApTicketIsTrusted(a1, (uint64_t)Value) & 1) == 0)
    || (CFDataGetBytePtr(v4), CFDataGetLength(v4), Img4DecodeInitManifest()))
  {
LABEL_10:
    AMSupportLogInternal();
    return 0;
  }
  BooleanFromSection = Img4DecodeGetBooleanFromSection();
  result = 0;
  if (!BooleanFromSection)
    return 0;
  return result;
}

uint64_t AMFDRAPTicketAllowsUnsealedData(uint64_t a1)
{
  return _AMFDRAPTicketHasBooleanEntitlement(a1);
}

uint64_t AMFDRAPTicketAllowsIncompleteData(uint64_t a1)
{
  return _AMFDRAPTicketHasBooleanEntitlement(a1);
}

BOOL AMFDRIsProtoDevice()
{
  const __CFString *v0;
  const __CFData *v1;
  const UInt8 *BytePtr;
  int Length;
  _BOOL8 v4;

  v0 = _AMFDRCopyDataFromDeviceTree("IODeviceTree:/arm-io/isp", CFSTR("cam-connections-scheme"));
  if (v0)
  {
    v1 = (const __CFData *)v0;
    BytePtr = CFDataGetBytePtr((CFDataRef)v0);
    Length = CFDataGetLength(v1);
    if (BytePtr && Length)
    {
      v4 = (*BytePtr & 0xEF) == 32;
    }
    else
    {
      AMSupportLogInternal();
      v4 = 0;
    }
    CFRelease(v1);
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
  return v4;
}

BOOL AMFDRDigestEnabled(uint64_t a1, BOOL *a2)
{
  const void *Value;
  _BOOL8 v5;
  CFTypeID v6;
  const __CFBoolean *v7;
  const __CFBoolean *v8;
  CFTypeID v9;
  BOOL v10;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("EnableDigest"));
  v5 = (_BOOL8)Value;
  if (Value)
  {
    v6 = CFGetTypeID(Value);
    if (v6 != CFBooleanGetTypeID())
    {
      v5 = 0;
      if (!a2)
        return v5;
      goto LABEL_7;
    }
    v5 = CFBooleanGetValue((CFBooleanRef)v5) != 0;
  }
  if (!a2)
    return v5;
LABEL_7:
  v7 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("EnableGetManifest"));
  v10 = v7 && (v8 = v7, v9 = CFGetTypeID(v7), v9 == CFBooleanGetTypeID()) && CFBooleanGetValue(v8) != 0;
  *a2 = v10;
  return v5;
}

uint64_t AMFDRDataIsDiagnosticMode()
{
  if (AMFDRDataIsDiagnosticMode_onceToken != -1)
    dispatch_once(&AMFDRDataIsDiagnosticMode_onceToken, &__block_literal_global_167);
  return AMFDRDataIsDiagnosticMode_result;
}

CFTypeRef _AMFDRDataCreateUnsignedValueNoCopy(const __CFAllocator *a1, CFDataRef theData, _BYTE *a3, uint64_t a4)
{
  const UInt8 *BytePtr;
  unsigned int Length;
  const UInt8 *v10;
  unsigned int v11;
  const UInt8 *v12;
  unsigned int v13;
  CFDataRef v14;
  CFDataRef v15;
  CFTypeRef v16;
  const __CFString *v18;
  char v19;
  unsigned int v20;
  const UInt8 *v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  const UInt8 *v27;

  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  if (!theData)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateUnsignedValueNoCopy", CFSTR("valueData is NULL"), v19);
    return 0;
  }
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (AMFDRDecodeCombined((uint64_t)BytePtr, Length, &v25, &v24, &v27, &v26)
    && (v10 = CFDataGetBytePtr(theData),
        v11 = CFDataGetLength(theData),
        AMFDRDecodeFDR2Data((uint64_t)v10, v11, &v27, &v26, &v23, &v22)))
  {
    v12 = CFDataGetBytePtr(theData);
    v13 = CFDataGetLength(theData);
  }
  else
  {
    v12 = v27;
    v13 = v26;
  }
  if (!v12)
  {
    v18 = CFSTR("dataToStrip is NULL");
LABEL_22:
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateUnsignedValueNoCopy", v18, v19);
    return 0;
  }
  if (!v13)
  {
    v18 = CFSTR("dataToStripLength is 0");
    goto LABEL_22;
  }
  if (AMFDRDecodeGetImg4RawData((uint64_t)v12, v13, &v21, &v20))
    goto LABEL_13;
  v12 = v21;
  if (!v21)
  {
    v18 = CFSTR("strippedData is NULL");
    goto LABEL_22;
  }
  v13 = v20;
  if (!v20)
  {
    v18 = CFSTR("strippedDataLength is 0");
    goto LABEL_22;
  }
  if (a3)
    *a3 = 1;
LABEL_13:
  v14 = CFDataCreateWithBytesNoCopy(a1, v12, v13, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
  if (!v14)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateUnsignedValueNoCopy", CFSTR("resultData is NULL"), v19);
    return 0;
  }
  v15 = v14;
  v16 = CFRetain(v14);
  CFRelease(v15);
  return v16;
}

uint64_t AMFDRDataCopyExtraManifests(const void *a1, CFDataRef theData, _QWORD *a3, CFTypeRef *a4, uint64_t a5)
{
  const __CFData *v6;
  const UInt8 *BytePtr;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  const __CFAllocator *v15;
  __int128 v16;
  uint64_t v17;
  const __CFAllocator *v18;
  CFDataRef v19;
  CFDataRef v20;
  const __CFString *v22;
  char v23;
  CFTypeRef cf;
  _DWORD v25[4];
  _DWORD length[3];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  unint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  memset(length, 0, sizeof(length));
  *(_QWORD *)&v25[1] = 0;
  v25[0] = 0;
  cf = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyExtraManifests", CFSTR("amfdr is NULL"), v23);
    return 0;
  }
  v6 = theData;
  if (!theData)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyExtraManifests", CFSTR("valueData is NULL"), v23);
    goto LABEL_37;
  }
  BytePtr = CFDataGetBytePtr(theData);
  v11 = CFDataGetLength(v6);
  v12 = AMFDRDecodeFDR2Data((uint64_t)BytePtr, v11, &length[1], length, &v25[1], v25);
  v13 = v12;
  if (!a3)
  {
    v6 = 0;
    goto LABEL_17;
  }
  if (v12 || !*(_QWORD *)&length[1] || !length[0])
  {
    v55 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v53 = v16;
    v54 = v16;
    v51 = v16;
    v52 = v16;
    v49 = v16;
    v50 = v16;
    v47 = v16;
    v48 = v16;
    v45 = v16;
    v46 = v16;
    v43 = v16;
    v44 = v16;
    v41 = v16;
    v42 = v16;
    v39 = v16;
    v40 = v16;
    v37 = v16;
    v38 = v16;
    v35 = v16;
    v36 = v16;
    v33 = v16;
    v34 = v16;
    v31 = v16;
    v32 = v16;
    v29 = v16;
    v30 = v16;
    v27 = v16;
    v28 = v16;
    CFDataGetBytePtr(v6);
    CFDataGetLength(v6);
    if (!Img4DecodeInit())
    {
      v6 = (const __CFData *)CFRetain(v6);
      if (!v6)
        goto LABEL_17;
      goto LABEL_14;
    }
    goto LABEL_12;
  }
  v55 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v53 = v14;
  v54 = v14;
  v51 = v14;
  v52 = v14;
  v49 = v14;
  v50 = v14;
  v47 = v14;
  v48 = v14;
  v45 = v14;
  v46 = v14;
  v43 = v14;
  v44 = v14;
  v41 = v14;
  v42 = v14;
  v39 = v14;
  v40 = v14;
  v37 = v14;
  v38 = v14;
  v35 = v14;
  v36 = v14;
  v33 = v14;
  v34 = v14;
  v31 = v14;
  v32 = v14;
  v29 = v14;
  v30 = v14;
  v27 = v14;
  v28 = v14;
  v15 = CFGetAllocator(a1);
  v6 = CFDataCreate(v15, *(const UInt8 **)&length[1], length[0]);
  if (!v6)
  {
    v22 = CFSTR("img4Data is NULL");
LABEL_35:
    AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyExtraManifests", v22, v23);
    goto LABEL_37;
  }
  if (!Img4DecodeInitManifest())
  {
    *a3 = v6;
LABEL_12:
    v6 = 0;
  }
  if (v6)
  {
LABEL_14:
    if ((_AMFDRDataCopyImg4Manifest(a1, v6, (CFDataRef *)&cf, a5) & 1) != 0)
    {
      if (cf)
      {
        *a3 = CFRetain(cf);
        goto LABEL_17;
      }
      v22 = CFSTR("deviceManifest is NULL");
      goto LABEL_35;
    }
    AMFDRErrorPushInternal(a5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyExtraManifests", CFSTR("_AMFDRDataCopyImg4Manifest failed"), v23);
LABEL_37:
    v17 = 0;
    goto LABEL_23;
  }
LABEL_17:
  v17 = 1;
  if (!a4 || v13 || !*(_QWORD *)&v25[1] || !v25[0])
    goto LABEL_23;
  v18 = CFGetAllocator(a1);
  v19 = CFDataCreate(v18, *(const UInt8 **)&v25[1], v25[0]);
  if (!v19)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyExtraManifests", CFSTR("stationManifest is NULL"), v23);
    goto LABEL_37;
  }
  v20 = v19;
  *a4 = CFRetain(v19);
  CFRelease(v20);
LABEL_23:
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v6)
    CFRelease(v6);
  return v17;
}

uint64_t _AMFDRDataCopyImg4Manifest(const void *a1, CFDataRef theData, CFDataRef *a3, uint64_t a4)
{
  const UInt8 *BytePtr;
  int Length;
  const __CFAllocator *v10;
  const __CFString *v12;
  char v13;
  unsigned int v14;
  const UInt8 *v15;

  v15 = 0;
  v14 = 0;
  if (!a1)
  {
    v12 = CFSTR("amfdr is NULL");
LABEL_10:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyImg4Manifest", v12, v13);
    return 0;
  }
  if (!theData)
  {
    v12 = CFSTR("valueData is NULL");
    goto LABEL_10;
  }
  if (!a3)
  {
    v12 = CFSTR("outValueData is NULL");
    goto LABEL_10;
  }
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (AMFDRDecodeGetImg4Manifest((uint64_t)BytePtr, Length, &v15, &v14))
  {
    AMFDRErrorPushInternal(a4, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyImg4Manifest", CFSTR("AMFDRDecodeGetImg4Manifest failed"), v13);
    return 0;
  }
  v10 = CFGetAllocator(a1);
  *a3 = CFDataCreate(v10, v15, v14);
  return 1;
}

uint64_t AMFDRDataCopyDigest(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 48))();
}

uint64_t AMFDRDataPresent(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 8))();
}

CFDataRef AMFDRDataCopy(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  const __CFData *v8;
  const __CFString *v10;
  char v11;

  if (!a1)
  {
    v10 = CFSTR("amfdr is NULL");
LABEL_9:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopy", v10, v11);
    return 0;
  }
  if (!a2)
  {
    v10 = CFSTR("dataClassStr is NULL");
    goto LABEL_9;
  }
  if (!a3)
  {
    v10 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_9;
  }
  v8 = (const __CFData *)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  if (v8)
    return _AMFDRDataCopyFormatted((CFDictionaryRef *)a1, a2, a3, v8, a4);
  AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopy", CFSTR("%@:%@ get data failed - foundData is NULL"), (char)a2);
  return 0;
}

CFDataRef _AMFDRDataCopyFormatted(CFDictionaryRef *a1, const __CFString *a2, const __CFString *a3, CFDataRef ExternalRepresentation, uint64_t a5)
{
  const __CFDictionary *v8;
  const __CFBoolean *Value;
  const __CFBoolean *v11;
  CFTypeID v12;
  const __CFBoolean *v13;
  const __CFBoolean *v14;
  CFTypeID v15;
  uint64_t v16;
  const __CFBoolean *v17;
  const __CFBoolean *v18;
  CFTypeID v19;
  int v20;
  const __CFString *v21;
  CFDataRef v22;
  _BOOL4 v23;
  _BOOL4 v24;
  char v25;
  const __CFBoolean *v26;
  const __CFData *v27;
  _BOOL4 v28;
  CFDataRef *v29;
  CFTypeID v30;
  CFDataRef v31;
  const __CFAllocator *v32;
  const __CFAllocator *v33;
  const UInt8 *BytePtr;
  int Length;
  char Combined;
  const __CFString *v37;
  const __CFString *v38;
  const __CFString *v40;
  const __CFString *v41;
  char v42;
  CFDataRef theData;
  unint64_t v45;
  CFDataRef v46;
  CFTypeRef v47;

  v46 = 0;
  v47 = 0;
  theData = 0;
  v45 = 0xAAAAAAAAAAAAAAAALL;
  if (!a1)
  {
    v37 = CFSTR("amfdr is NULL");
LABEL_62:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormatted", v37, (char)v40);
LABEL_17:
    if (ExternalRepresentation)
    {
      CFRelease(ExternalRepresentation);
LABEL_19:
      v22 = 0;
LABEL_49:
      ExternalRepresentation = 0;
      goto LABEL_72;
    }
    goto LABEL_71;
  }
  v8 = a1[2];
  if (!v8)
  {
    v37 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_62;
  }
  if (!a2)
  {
    v37 = CFSTR("dataClassStr is NULL");
    goto LABEL_62;
  }
  if (!a3)
  {
    v37 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_62;
  }
  Value = (const __CFBoolean *)CFDictionaryGetValue(v8, CFSTR("VerifyData"));
  v11 = Value;
  if (Value)
  {
    v12 = CFGetTypeID(Value);
    if (v12 != CFBooleanGetTypeID())
    {
      v40 = CFSTR("VerifyData");
LABEL_61:
      v37 = CFSTR("Invalid type for '%@'. Expected CFBoolean.");
      goto LABEL_62;
    }
  }
  v13 = (const __CFBoolean *)CFDictionaryGetValue(a1[2], CFSTR("StripImg4"));
  v14 = v13;
  if (v13)
  {
    v15 = CFGetTypeID(v13);
    if (v15 != CFBooleanGetTypeID())
    {
      v40 = CFSTR("StripImg4");
      goto LABEL_61;
    }
  }
  v16 = a5;
  v17 = (const __CFBoolean *)CFDictionaryGetValue(a1[2], CFSTR("GetCombined"));
  v18 = v17;
  if (v17)
  {
    v19 = CFGetTypeID(v17);
    if (v19 != CFBooleanGetTypeID())
    {
      v41 = CFSTR("GetCombined");
      v21 = CFSTR("Invalid type for '%@'. Expected CFBoolean.");
      goto LABEL_16;
    }
  }
  if (v14 && (v20 = CFBooleanGetValue(v14), v18) && v20)
  {
    if (CFBooleanGetValue(v18))
    {
      v41 = CFSTR("StripImg4");
      v21 = CFSTR("Cannot specify both %@ and %@ with value TRUE");
LABEL_16:
      AMFDRErrorPushInternal(v16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormatted", v21, (char)v41);
      goto LABEL_17;
    }
  }
  else if (!v18)
  {
    v23 = 0;
    if (v14)
      goto LABEL_22;
    goto LABEL_24;
  }
  v23 = CFBooleanGetValue(v18) != 0;
  if (v14)
  {
LABEL_22:
    v24 = CFBooleanGetValue(v14) != 0;
    goto LABEL_25;
  }
LABEL_24:
  v24 = 0;
LABEL_25:
  v25 = _AMFDRDataCopyUnCombinedValue(a1, v24, ExternalRepresentation, &v46, v16);
  if (ExternalRepresentation)
    CFRelease(ExternalRepresentation);
  if ((v25 & 1) == 0)
  {
    AMFDRErrorPushInternal(v16, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormatted", CFSTR("_AMFDRDataCopyUnCombinedValue failed"), (char)v40);
    goto LABEL_19;
  }
  if (!v46)
  {
    v42 = (char)a2;
    v38 = CFSTR("%@:%@ get data failed - uncombinedData is NULL");
    goto LABEL_68;
  }
  if (v11 && !CFBooleanGetValue(v11))
  {
    v31 = v46;
    v45 = (unint64_t)v46;
    if (!v23)
      goto LABEL_48;
  }
  else
  {
    v26 = (const __CFBoolean *)CFDictionaryGetValue(a1[2], CFSTR("VerifyAsidInSubCC"));
    v27 = v46;
    if (v26)
      v28 = CFBooleanGetValue(v26) != 0;
    else
      v28 = 0;
    if (v23)
      v29 = 0;
    else
      v29 = (CFDataRef *)&v47;
    if ((AMFDRDataVerifyInternal((uint64_t)a1, a2, a3, 0, v27, 0, v28, v29, v16) & 1) == 0)
      AMFDRErrorPushInternal(v16, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormatted", CFSTR("%@:%@ Data verification failed"), (char)a2);
    if (!v23)
    {
      if (v47)
      {
        v30 = CFGetTypeID(v47);
        if (v30 == CFDataGetTypeID())
        {
          v31 = (CFDataRef)v47;
          v45 = (unint64_t)v47;
LABEL_48:
          v22 = (CFDataRef)CFRetain(v31);
          goto LABEL_49;
        }
        v42 = (char)a2;
        v38 = CFSTR("%@:%@ Invalid type for rawValueData. Expected CFData.");
      }
      else
      {
        v42 = (char)a2;
        v38 = CFSTR("%@:%@ rawValueData is NULL");
      }
LABEL_68:
      AMFDRErrorPushInternal(v16, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormatted", v38, v42);
      goto LABEL_19;
    }
  }
  v32 = CFGetAllocator(a1);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v32, a3, 0x8000100u, 0x20u);
  if (!ExternalRepresentation)
  {
    AMFDRErrorPushInternal(v16, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormatted", CFSTR("dataInstanceData is NULL"), (char)v40);
LABEL_71:
    v22 = 0;
    goto LABEL_72;
  }
  v33 = CFGetAllocator(a1);
  if ((AMFDRDataStripExtraManifest(v33, v46, (CFTypeRef *)&theData, 0, v16) & 1) == 0)
  {
    AMFDRErrorPushInternal(v16, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormatted", CFSTR("AMFDRDataStripExtraManifest failed"), (char)v40);
    goto LABEL_71;
  }
  AMSupportSafeRelease();
  v46 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (AMFDRDecodeGetImg4RawData((uint64_t)BytePtr, Length, 0, 0))
  {
    AMSupportLogInternal();
    v22 = (CFDataRef)CFRetain(theData);
    goto LABEL_72;
  }
  Combined = AMFDRDataCreateCombined(a1, theData, 0, (CFDataRef *)&v45, v16);
  theData = 0;
  if ((Combined & 1) == 0)
  {
    AMFDRErrorPushInternal(v16, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormatted", CFSTR("AMFDRDataCreateCombined failed"), (char)v40);
    goto LABEL_71;
  }
  v22 = (CFDataRef)v45;
  if (!v45)
    AMFDRErrorPushInternal(v16, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormatted", CFSTR("AMFDRDataCreateCombined returned returnData == NULL"), (char)v40);
LABEL_72:
  if (v47)
  {
    CFRelease(v47);
    v47 = 0;
  }
  if (v46)
  {
    CFRelease(v46);
    v46 = 0;
  }
  if (theData)
  {
    CFRelease(theData);
    theData = 0;
  }
  if (ExternalRepresentation)
    CFRelease(ExternalRepresentation);
  return v22;
}

uint64_t AMFDRDataCopyRawAndFormatted(uint64_t a1, const __CFString *a2, const __CFString *a3, CFTypeRef *a4, CFTypeRef *a5, uint64_t a6)
{
  const __CFData *v12;
  const __CFData *v13;
  const __CFString *v15;
  char v16;

  if (!a1)
  {
    v15 = CFSTR("amfdr is NULL");
LABEL_10:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyRawAndFormatted", v15, v16);
    return 0;
  }
  if (!a2)
  {
    v15 = CFSTR("dataClassStr is NULL");
    goto LABEL_10;
  }
  if (!a3)
  {
    v15 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_10;
  }
  v12 = (const __CFData *)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  if (v12)
  {
    v13 = v12;
    if ((_AMFDRDataCopyFormattedRawAndImg4((CFDictionaryRef *)a1, a2, a3, a4, a5, v12, a6) & 1) != 0)
      return 1;
    AMFDRErrorPushInternal(a6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyRawAndFormatted", CFSTR("_AMFDRDataCopyFormattedRawAndImg4 failed"), v16);
    CFRelease(v13);
  }
  else
  {
    AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyRawAndFormatted", CFSTR("%@:%@ get data failed - foundData is NULL"), (char)a2);
  }
  return 0;
}

uint64_t _AMFDRDataCopyFormattedRawAndImg4(CFDictionaryRef *a1, const __CFString *a2, const __CFString *a3, CFTypeRef *a4, CFTypeRef *a5, CFDataRef ExternalRepresentation, uint64_t a7)
{
  const __CFDictionary *v10;
  const __CFBoolean *Value;
  const __CFBoolean *v14;
  CFTypeID v15;
  const __CFBoolean *v16;
  const __CFBoolean *v17;
  CFTypeID v18;
  int v19;
  const __CFString *v20;
  uint64_t v21;
  BOOL v22;
  _BOOL4 v23;
  char v24;
  const __CFBoolean *v25;
  const __CFData *v26;
  _BOOL4 v27;
  const __CFAllocator *v28;
  const __CFAllocator *v29;
  const UInt8 *BytePtr;
  int Length;
  CFTypeRef v32;
  CFTypeID v33;
  CFDataRef v34;
  CFTypeRef *v35;
  char Combined;
  CFTypeRef v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  char v42;
  CFDataRef theData;
  CFTypeRef cf;
  CFDataRef v47;
  CFDataRef v48;

  v47 = 0;
  v48 = 0;
  theData = 0;
  cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  if (!a1)
  {
    v20 = CFSTR("amfdr is NULL");
    goto LABEL_14;
  }
  v10 = a1[2];
  if (!v10)
  {
    v20 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_14;
  }
  if (!a2)
  {
    v20 = CFSTR("dataClassStr is NULL");
    goto LABEL_14;
  }
  if (!a3)
  {
    v20 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_14;
  }
  Value = (const __CFBoolean *)CFDictionaryGetValue(v10, CFSTR("StripImg4"));
  v14 = Value;
  if (Value)
  {
    v15 = CFGetTypeID(Value);
    if (v15 != CFBooleanGetTypeID())
    {
      v41 = CFSTR("StripImg4");
LABEL_62:
      v20 = CFSTR("Invalid type for '%@'. Expected CFBoolean.");
      goto LABEL_14;
    }
  }
  v16 = (const __CFBoolean *)CFDictionaryGetValue(a1[2], CFSTR("GetCombined"));
  v17 = v16;
  if (v16)
  {
    v18 = CFGetTypeID(v16);
    if (v18 != CFBooleanGetTypeID())
    {
      v41 = CFSTR("GetCombined");
      goto LABEL_62;
    }
  }
  if (v14 && (v19 = CFBooleanGetValue(v14), v17) && v19)
  {
    if (CFBooleanGetValue(v17))
    {
      v41 = CFSTR("StripImg4");
      v20 = CFSTR("Cannot specify both %@ and %@ with value TRUE");
LABEL_14:
      AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormattedRawAndImg4", v20, (char)v41);
      if (!ExternalRepresentation)
      {
LABEL_17:
        v21 = 0;
        goto LABEL_42;
      }
      CFRelease(ExternalRepresentation);
LABEL_16:
      ExternalRepresentation = 0;
      goto LABEL_17;
    }
  }
  else if (!v17)
  {
    v22 = 0;
    if (v14)
      goto LABEL_20;
    goto LABEL_22;
  }
  v22 = CFBooleanGetValue(v17) != 0;
  if (v14)
  {
LABEL_20:
    v23 = CFBooleanGetValue(v14) != 0;
    goto LABEL_23;
  }
LABEL_22:
  v23 = 0;
LABEL_23:
  v24 = _AMFDRDataCopyUnCombinedValue(a1, v23, ExternalRepresentation, &v47, a7);
  if (ExternalRepresentation)
    CFRelease(ExternalRepresentation);
  if ((v24 & 1) == 0)
  {
    AMFDRErrorPushInternal(a7, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormattedRawAndImg4", CFSTR("_AMFDRDataCopyUnCombinedValue failed"), (char)v41);
    goto LABEL_16;
  }
  if (!v47)
  {
    v42 = (char)a2;
    v39 = CFSTR("%@:%@ get data failed - uncombinedData is NULL");
    goto LABEL_67;
  }
  v25 = (const __CFBoolean *)CFDictionaryGetValue(a1[2], CFSTR("VerifyAsidInSubCC"));
  v26 = v47;
  if (v25)
    v27 = CFBooleanGetValue(v25) != 0;
  else
    v27 = 0;
  if ((AMFDRDataVerifyInternal((uint64_t)a1, a2, a3, 0, v26, 0, v27, &v48, a7) & 1) == 0)
    AMFDRErrorPushInternal(a7, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormattedRawAndImg4", CFSTR("%@:%@ Data verification failed"), (char)a2);
  if (!v22)
  {
    if (v48)
    {
      v33 = CFGetTypeID(v48);
      if (v33 == CFDataGetTypeID())
      {
        v34 = v47;
        cf = v47;
        *a4 = CFRetain(v48);
        v32 = CFRetain(v34);
        ExternalRepresentation = 0;
        goto LABEL_40;
      }
      v42 = (char)a2;
      v39 = CFSTR("%@:%@ Invalid type for rawValueData. Expected CFData.");
    }
    else
    {
      v42 = (char)a2;
      v39 = CFSTR("%@:%@ rawValueData is NULL");
    }
LABEL_67:
    AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormattedRawAndImg4", v39, v42);
    goto LABEL_16;
  }
  cf = v47;
  v28 = CFGetAllocator(a1);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v28, a3, 0x8000100u, 0x20u);
  if (!ExternalRepresentation)
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormattedRawAndImg4", CFSTR("dataInstanceData is NULL"), (char)v41);
    goto LABEL_17;
  }
  v29 = CFGetAllocator(a1);
  if ((AMFDRDataStripExtraManifest(v29, v47, (CFTypeRef *)&theData, 0, a7) & 1) == 0)
  {
    v40 = CFSTR("AMFDRDataStripExtraManifest failed");
    goto LABEL_71;
  }
  AMSupportSafeRelease();
  v47 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (!AMFDRDecodeGetImg4RawData((uint64_t)BytePtr, Length, 0, 0))
  {
    Combined = AMFDRDataCreateCombined(a1, theData, 0, (CFDataRef *)&cf, a7);
    theData = 0;
    if ((Combined & 1) == 0)
    {
      AMFDRErrorPushInternal(a7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormattedRawAndImg4", CFSTR("AMFDRDataCreateCombined failed"), (char)v41);
      goto LABEL_17;
    }
    v38 = cf;
    if (cf)
    {
      *a5 = cf;
      v32 = CFRetain(v38);
      v35 = a4;
      goto LABEL_41;
    }
    v40 = CFSTR("AMFDRDataCreateCombined returned returnData == NULL");
LABEL_71:
    AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyFormattedRawAndImg4", v40, (char)v41);
    goto LABEL_17;
  }
  AMSupportLogInternal();
  *a4 = CFRetain(theData);
  v32 = CFRetain(theData);
LABEL_40:
  v35 = a5;
LABEL_41:
  *v35 = v32;
  v21 = 1;
LABEL_42:
  if (v48)
  {
    CFRelease(v48);
    v48 = 0;
  }
  if (v47)
  {
    CFRelease(v47);
    v47 = 0;
  }
  if (theData)
  {
    CFRelease(theData);
    theData = 0;
  }
  if (ExternalRepresentation)
    CFRelease(ExternalRepresentation);
  return v21;
}

const __CFString *AMFDRDataGetMultiActionDescription(unsigned int a1)
{
  if (a1 > 4)
    return CFSTR("Unknown");
  else
    return off_24C69EDB0[a1];
}

CFTypeRef AMFDRDataMultiCopy(_QWORD *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  return _AMFDRDataMultiCopyInternal(a1, a2, a3, 0, 0, a4);
}

CFTypeRef _AMFDRDataMultiCopyInternal(_QWORD *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, CFTypeRef *a6)
{
  uint64_t v12;
  CFTypeRef v13;
  const void *v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  const __CFDictionary *Value;
  const __CFDictionary *v18;
  const __CFAllocator *v19;
  const __CFAllocator *v20;
  const __CFDictionary *Mutable;
  const __CFString *format;
  char v24;
  CFDictionaryRef theDict;
  CFDictionaryRef v26;
  _QWORD context[4];

  context[3] = *MEMORY[0x24BDAC8D0];
  theDict = 0;
  v26 = 0;
  memset(context, 170, 24);
  if (!a1)
  {
    format = CFSTR("amfdr is NULL");
LABEL_35:
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyInternal", format, v24);
LABEL_10:
    v13 = 0;
    goto LABEL_46;
  }
  if (!a2)
  {
    format = CFSTR("dataClassArray is NULL");
    goto LABEL_35;
  }
  if (!a3)
  {
    format = CFSTR("dataInstanceArray is NULL");
    goto LABEL_35;
  }
  if (a6 && *a6)
  {
    CFRelease(*a6);
    *a6 = 0;
  }
  switch(a4)
  {
    case 0:
      v12 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, CFTypeRef *))(a1[6] + 88))(a1, a2, a3, a6);
      break;
    case 1:
      v12 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, CFTypeRef *))(a1[6] + 136))(a1, a2, a3, a5, a6);
      break;
    case 2:
      v12 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, CFTypeRef *))(a1[6] + 152))(a1, a2, a3, a6);
      break;
    case 3:
      v12 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, CFTypeRef *))(a1[6] + 168))(a1, a2, a3, a6);
      break;
    case 4:
      v12 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, CFTypeRef *))(a1[6] + 224))(a1, a2, a3, a6);
      break;
    default:
      AMFDRErrorPushInternal((uint64_t)a6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyInternal", CFSTR("Unsupported multi action: %d"), a4);
      goto LABEL_10;
  }
  v14 = (const void *)v12;
  if (!v12)
  {
    AMSupportLogInternal();
    goto LABEL_10;
  }
  if (a6 && *a6)
  {
    if (CFErrorGetCode((CFErrorRef)*a6) == 21)
    {
      v15 = CFErrorCopyUserInfo((CFErrorRef)*a6);
      if (v15)
      {
        v16 = v15;
        Value = (const __CFDictionary *)CFDictionaryGetValue(v15, CFSTR("MultiRequestErrors"));
        theDict = Value;
        if (!Value)
        {
          AMFDRErrorPushInternal((uint64_t)a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyInternal", CFSTR("MultiRequestErrors not in userInfo"), v24);
          v13 = 0;
          goto LABEL_43;
        }
        v18 = (const __CFDictionary *)CFRetain(Value);
        theDict = v18;
        if (!a4)
          goto LABEL_22;
LABEL_26:
        v26 = (CFDictionaryRef)CFRetain(v14);
        goto LABEL_27;
      }
      AMFDRErrorPushInternal((uint64_t)a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyInternal", CFSTR("userInfo is NULL"), v24);
    }
    else
    {
      AMSupportLogInternal();
    }
LABEL_49:
    v13 = 0;
    goto LABEL_44;
  }
  v20 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v20, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  theDict = Mutable;
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyInternal", CFSTR("multiRequestErrors is NULL"), v24);
    goto LABEL_49;
  }
  v18 = Mutable;
  v16 = 0;
  if (a4)
    goto LABEL_26;
LABEL_22:
  v19 = CFGetAllocator(a1);
  v26 = CFDictionaryCreateMutable(v19, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v26)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyInternal", CFSTR("formattedDict is NULL"), v24);
    goto LABEL_42;
  }
  context[0] = a1;
  context[1] = &v26;
  context[2] = &theDict;
  CFDictionaryApplyFunction((CFDictionaryRef)v14, (CFDictionaryApplierFunction)_AMFDRDataMultiCopyCallbak, context);
  v18 = theDict;
LABEL_27:
  if (CFDictionaryGetCount(v18) >= 1)
    AMFDRErrorPushInternal((uint64_t)a6, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyInternal", CFSTR("_AMFDRDataMultiCopyCallbak got errors"), v24);
  if (CFDictionaryGetCount(v26) < 1)
  {
LABEL_42:
    v13 = 0;
    if (!v16)
      goto LABEL_44;
    goto LABEL_43;
  }
  v13 = CFRetain(v26);
  if (v16)
LABEL_43:
    CFRelease(v16);
LABEL_44:
  CFRelease(v14);
  if (v26)
  {
    CFRelease(v26);
    v26 = 0;
  }
LABEL_46:
  if (theDict)
    CFRelease(theDict);
  return v13;
}

uint64_t AMFDRDataStripExtraManifest(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3, CFTypeRef *a4, uint64_t a5)
{
  __int128 v7;
  const UInt8 *BytePtr;
  unsigned int v12;
  const void *v13;
  CFDataRef v14;
  uint64_t v15;
  char v17;
  _DWORD v18[4];
  _DWORD length[3];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  unint64_t v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  memset(length, 0, sizeof(length));
  *(_QWORD *)&v18[1] = 0;
  v18[0] = 0;
  v48 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v46 = v7;
  v47 = v7;
  v44 = v7;
  v45 = v7;
  v42 = v7;
  v43 = v7;
  v40 = v7;
  v41 = v7;
  v38 = v7;
  v39 = v7;
  v36 = v7;
  v37 = v7;
  v34 = v7;
  v35 = v7;
  v32 = v7;
  v33 = v7;
  v30 = v7;
  v31 = v7;
  v28 = v7;
  v29 = v7;
  v27 = v7;
  v25 = v7;
  v26 = v7;
  v23 = v7;
  v24 = v7;
  v21 = v7;
  v22 = v7;
  v20 = v7;
  if (!a1)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataStripExtraManifest", CFSTR("amfdr is NULL"), v17);
    v15 = 0;
    goto LABEL_13;
  }
  if (!theData)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataStripExtraManifest", CFSTR("valueData is NULL"), v17);
LABEL_19:
    v15 = 0;
    goto LABEL_13;
  }
  BytePtr = CFDataGetBytePtr(theData);
  v12 = CFDataGetLength(theData);
  if (AMFDRDecodeFDR2Data((uint64_t)BytePtr, v12, &length[1], length, &v18[1], v18)
    || Img4DecodeInit()
    || Img4DecodeInitManifest())
  {
    v13 = CFRetain(theData);
    v14 = 0;
    goto LABEL_7;
  }
  v13 = CFDataCreate(a1, *(const UInt8 **)&length[1], length[0]);
  if (!v13)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataStripExtraManifest", CFSTR("img4Data is NULL"), v17);
    goto LABEL_19;
  }
  v14 = CFDataCreate(a1, *(const UInt8 **)&v18[1], v18[0]);
  if (!v14)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataStripExtraManifest", CFSTR("strippedManifest is NULL"), v17);
    v15 = 0;
    goto LABEL_13;
  }
LABEL_7:
  if (a3 && v13)
    *a3 = CFRetain(v13);
  v15 = 1;
  if (a4 && v14)
    *a4 = CFRetain(v14);
LABEL_13:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v15;
}

CFTypeRef AMFDRDataCopyForPut(uint64_t a1, const __CFString *a2, const void *a3, const __CFData *a4, __CFString *a5, uint64_t a6)
{
  return _AMFDRDataCopyForPutWithManifest(a1, a2, a3, a4, a5, 0, 0, a6);
}

CFTypeRef _AMFDRDataCopyForPutWithManifest(uint64_t a1, const __CFString *a2, const void *a3, const __CFData *a4, __CFString *cf, char a6, const __CFData *a7, uint64_t a8)
{
  __CFString *v14;
  CFTypeID v15;
  CFTypeID v16;
  const void *Value;
  const void *v18;
  CFTypeID v19;
  CFTypeID v20;
  int v21;
  const __CFData *v22;
  CFTypeID v23;
  __CFString *v24;
  CFTypeID v25;
  CFTypeID v26;
  const __CFString *v27;
  const __CFBoolean *v28;
  const __CFBoolean *v29;
  CFTypeID v30;
  int v31;
  const __CFAllocator *v32;
  const __CFData *v33;
  CFTypeRef v34;
  const __CFString *v36;
  const __CFString *v37;
  const __CFString *v38;
  CFTypeRef v40;
  CFTypeRef cfa;
  CFDataRef v42;
  const __CFData *v43;

  v42 = 0;
  v43 = 0;
  v40 = 0;
  cfa = 0;
  if (!a1)
  {
    v27 = CFSTR("amfdr is NULL");
    goto LABEL_69;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v27 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_69;
  }
  if (!a2)
  {
    v27 = CFSTR("dataClassStr is NULL");
    goto LABEL_69;
  }
  if (!a3)
  {
    v27 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_69;
  }
  if (!a4)
  {
    v27 = CFSTR("valueData is NULL");
    goto LABEL_69;
  }
  v14 = cf;
  if (cf)
  {
    v15 = CFGetTypeID(cf);
    if (v15 != CFNullGetTypeID())
    {
      v16 = CFGetTypeID(v14);
      if (v16 != CFDictionaryGetTypeID())
      {
        v27 = CFSTR("options has invalid type");
        goto LABEL_69;
      }
    }
  }
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("SignData"));
  if (!Value)
  {
    if (_AMFDRDataCopyUnCombinedValue((CFDictionaryRef *)a1, 1, a4, &v43, a8))
    {
      v22 = v43;
      if (!v14)
        goto LABEL_26;
      goto LABEL_18;
    }
    goto LABEL_56;
  }
  v18 = Value;
  v19 = CFGetTypeID(Value);
  if (v19 != CFBooleanGetTypeID())
  {
    v38 = CFSTR("SignData");
LABEL_68:
    v27 = CFSTR("Invalid type for '%@'. Expected CFBoolean.");
    goto LABEL_69;
  }
  v20 = CFGetTypeID(v18);
  if (v20 != CFBooleanGetTypeID())
  {
    if (_AMFDRDataCopyUnCombinedValue((CFDictionaryRef *)a1, 0, a4, &v43, a8))
    {
      v22 = v43;
      goto LABEL_28;
    }
    goto LABEL_56;
  }
  v21 = CFBooleanGetValue((CFBooleanRef)v18);
  if ((_AMFDRDataCopyUnCombinedValue((CFDictionaryRef *)a1, v21 != 0, a4, &v43, a8) & 1) == 0)
  {
LABEL_56:
    v36 = CFSTR("_AMFDRDataCopyUnCombinedValue failed");
LABEL_61:
    AMFDRErrorPushInternal(a8, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyForPutWithManifest", v36, (char)v38);
    goto LABEL_70;
  }
  v22 = v43;
  if (!v21)
    goto LABEL_28;
  if (!v14)
    goto LABEL_26;
LABEL_18:
  v23 = CFGetTypeID(v14);
  if (v23 != CFDictionaryGetTypeID())
  {
    v14 = 0;
    goto LABEL_26;
  }
  v24 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)v14, CFSTR("AssemblyID"));
  v14 = v24;
  if (v24)
  {
    v25 = CFGetTypeID(v24);
    if (v25 != CFNullGetTypeID())
    {
      v26 = CFGetTypeID(v14);
      if (v26 != CFStringGetTypeID())
      {
        v27 = CFSTR("assemblyID has invalid type");
LABEL_69:
        AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyForPutWithManifest", v27, (char)v38);
        goto LABEL_70;
      }
    }
  }
LABEL_26:
  if ((AMFDRDataLocalSign(a1, a2, a3, v22, 0, 0, v14, 0, &v42, a8) & 1) == 0)
  {
    LOBYTE(v38) = (_BYTE)a2;
    v36 = CFSTR("failed to sign data %@:%@");
    goto LABEL_61;
  }
  v22 = v42;
  if (!v42)
  {
    LOBYTE(v38) = (_BYTE)a2;
    v37 = CFSTR("signedValueData is NULL %@:%@");
    goto LABEL_65;
  }
LABEL_28:
  if ((a6 & 1) == 0)
  {
    v28 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("PutCombined"));
    if (!v28)
      goto LABEL_34;
    v29 = v28;
    v30 = CFGetTypeID(v28);
    if (v30 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v29))
        goto LABEL_32;
LABEL_34:
      v31 = 0;
      goto LABEL_35;
    }
    v38 = CFSTR("VerifyData");
    goto LABEL_68;
  }
LABEL_32:
  if (*(uint64_t (***)(int, int, int, int))(a1 + 48) == AMFDRHTTPStore)
  {
    v37 = CFSTR("Cannnot store combined data to remote data store");
    goto LABEL_65;
  }
  v31 = 1;
LABEL_35:
  if (*(uint64_t (***)(int, int, int, int))(a1 + 48) != AMFDRHTTPStore)
  {
    v32 = CFGetAllocator((CFTypeRef)a1);
    if ((AMFDRDataStripExtraManifest(v32, v22, &v40, 0, a8) & 1) != 0)
    {
      v22 = (const __CFData *)v40;
      goto LABEL_38;
    }
    v37 = CFSTR("AMFDRDataStripExtraManifest failed");
LABEL_65:
    AMFDRErrorPushInternal(a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyForPutWithManifest", v37, (char)v38);
    goto LABEL_70;
  }
LABEL_38:
  if (!v31)
  {
LABEL_41:
    v34 = CFRetain(v22);
    goto LABEL_42;
  }
  v33 = (const __CFData *)CFRetain(v22);
  if ((AMFDRDataCreateCombined((CFDictionaryRef *)a1, v33, a7, (CFDataRef *)&cfa, a8) & 1) != 0)
  {
    v22 = (const __CFData *)cfa;
    if (cfa)
      goto LABEL_41;
    v37 = CFSTR("AMFDRDataCreateCombined returned combinedValueData == NULL");
    goto LABEL_65;
  }
  AMFDRErrorPushInternal(a8, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyForPutWithManifest", CFSTR("AMFDRDataCreateCombined failed"), (char)v38);
LABEL_70:
  v34 = 0;
LABEL_42:
  if (v42)
  {
    CFRelease(v42);
    v42 = 0;
  }
  if (cfa)
  {
    CFRelease(cfa);
    cfa = 0;
  }
  if (v43)
  {
    CFRelease(v43);
    v43 = 0;
  }
  if (v40)
    CFRelease(v40);
  return v34;
}

uint64_t AMFDRDataPutWithOptions(uint64_t a1, const __CFString *a2, const void *a3, const __CFData *a4, __CFString *a5, uint64_t a6)
{
  CFTypeRef v11;
  const void *v12;
  uint64_t v13;
  const __CFString *v15;
  char v16;

  if (!a1)
  {
    v15 = CFSTR("amfdr is NULL");
LABEL_12:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPutWithOptions", v15, v16);
    return 0;
  }
  if (!a2)
  {
    v15 = CFSTR("dataClassStr is NULL");
    goto LABEL_12;
  }
  if (!a3)
  {
    v15 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_12;
  }
  if (a4)
  {
    v11 = _AMFDRDataCopyForPutWithManifest(a1, a2, a3, a4, a5, 0, 0, a6);
    if (v11)
    {
      v12 = v11;
      v13 = (*(uint64_t (**)(uint64_t, const __CFString *, const void *, CFTypeRef, __CFString *, uint64_t))(*(_QWORD *)(a1 + 48) + 24))(a1, a2, a3, v11, a5, a6);
      CFRelease(v12);
      return v13;
    }
    v15 = CFSTR("dataToPut is NULL");
    goto LABEL_12;
  }
  AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPutWithOptions", CFSTR("valueData is NULL"), v16);
  return 0;
}

uint64_t AMFDRDataPut(uint64_t a1, const __CFString *a2, const void *a3, const __CFData *a4, uint64_t a5)
{
  return AMFDRDataPutWithOptions(a1, a2, a3, a4, 0, a5);
}

uint64_t AMFDRDataMultiPutWithOptions(_QWORD *a1, CFArrayRef theArray, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, uint64_t a6)
{
  CFIndex Count;
  CFIndex v11;
  const __CFAllocator *v12;
  CFMutableArrayRef Mutable;
  __CFArray *v14;
  CFIndex v15;
  const void *v16;
  const __CFString *ValueAtIndex;
  const __CFString *v18;
  const void *v19;
  const void *v20;
  const __CFData *v21;
  const __CFData *v22;
  __CFString *v23;
  CFTypeRef v24;
  uint64_t v25;
  const __CFString *v27;
  const __CFString *v28;
  uint64_t v29;
  CFIndex v30;
  void *value[2];
  void *v32[2];
  __int128 v33;
  const __CFString *v34;

  if (!a1)
  {
    v28 = CFSTR("amfdr is NULL");
LABEL_43:
    v34 = v28;
    *(_OWORD *)v32 = 0u;
    v33 = 0u;
    *(_OWORD *)value = 0u;
    v29 = a6;
    v30 = 1;
    goto LABEL_44;
  }
  if (!theArray)
  {
    v28 = CFSTR("dataClassArray is NULL");
    goto LABEL_43;
  }
  if (!a3)
  {
    v28 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_43;
  }
  if (!a4)
  {
    v28 = CFSTR("valueDataArray is NULL");
    goto LABEL_43;
  }
  Count = CFArrayGetCount(theArray);
  if (!Count)
  {
    v28 = CFSTR("Invalid dataClassArray count");
    goto LABEL_43;
  }
  v11 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v28 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_43;
  }
  if (CFArrayGetCount(a4) != v11)
  {
    v28 = CFSTR("Invalid dataValueArray count");
    goto LABEL_43;
  }
  if (a5 && CFArrayGetCount(a5) != v11)
  {
    v28 = CFSTR("Invalid optionsArray count");
    goto LABEL_43;
  }
  v12 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v12, v11, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    v34 = CFSTR("dataToPut is NULL");
    *(_OWORD *)v32 = 0u;
    v33 = 0u;
    *(_OWORD *)value = 0u;
    v29 = a6;
    v30 = 2;
LABEL_44:
    AMFDRErrorPushInternal(v29, v30, 0, 0, 0, 0, 0, 0, value[0], value[1], v32[0], v32[1], (void *)v33, *((void **)&v33 + 1), (uint64_t)"AMFDRDataMultiPutWithOptions", v34, a6);
    return 0;
  }
  v14 = Mutable;
  if (v11 >= 1)
  {
    v15 = 0;
    v16 = 0;
    while (1)
    {
      if (v16)
        CFRelease(v16);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v15);
      if (!ValueAtIndex)
      {
        v27 = CFSTR("dataClassStr is NULL");
        goto LABEL_32;
      }
      v18 = ValueAtIndex;
      v19 = CFArrayGetValueAtIndex(a3, v15);
      if (!v19)
      {
        v27 = CFSTR("dataInstanceStr is NULL");
        goto LABEL_32;
      }
      v20 = v19;
      v21 = (const __CFData *)CFArrayGetValueAtIndex(a4, v15);
      if (!v21)
      {
        v27 = CFSTR("valueData is NULL");
        goto LABEL_32;
      }
      v22 = v21;
      v23 = a5 ? (__CFString *)CFArrayGetValueAtIndex(a5, v15) : 0;
      v24 = _AMFDRDataCopyForPutWithManifest((uint64_t)a1, v18, v20, v22, v23, 0, 0, a6);
      if (!v24)
        break;
      v16 = v24;
      CFArrayAppendValue(v14, v24);
      if (v11 == ++v15)
        goto LABEL_25;
    }
    v27 = CFSTR("dataToPut is NULL");
LABEL_32:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiPutWithOptions", v27, a6);
    CFRelease(v14);
    return 0;
  }
  v16 = 0;
LABEL_25:
  v25 = (*(uint64_t (**)(_QWORD *, CFArrayRef, const __CFArray *, __CFArray *, const __CFArray *, uint64_t))(a1[6] + 96))(a1, theArray, a3, v14, a5, a6);
  CFRelease(v14);
  if (v16)
    CFRelease(v16);
  return v25;
}

uint64_t AMFDRDataMultiPut(_QWORD *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, uint64_t a5)
{
  return AMFDRDataMultiPutWithOptions(a1, a2, a3, a4, 0, a5);
}

CFTypeRef AMFDRDataPopulate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v6;
  const void *v7;
  const void *v8;
  CFTypeRef v9;
  const __CFString *v11;
  char v12;

  if (!a1)
  {
    v11 = CFSTR("amfdr is NULL");
LABEL_9:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPopulate", v11, v12);
    return 0;
  }
  v6 = a2;
  if (!a2)
  {
    v11 = CFSTR("dataClassStr is NULL");
    goto LABEL_9;
  }
  if (!a3)
  {
    v11 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_9;
  }
  v7 = (const void *)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 128))();
  if (v7)
  {
    v8 = v7;
    v9 = CFRetain(v7);
    CFRelease(v8);
    return v9;
  }
  AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPopulate", CFSTR("%@:%@ populate data failed - foundData is NULL"), v6);
  return 0;
}

CFTypeRef AMFDRDataMultiPopulate(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  return _AMFDRDataMultiCopyInternal(a1, a2, a3, 1, a4, a5);
}

uint64_t AMFDRDataCommitWithPopulateAddition(_QWORD *a1, const __CFString *a2, const void *a3, const __CFData *a4, int a5, const __CFData *a6, CFTypeRef cf, CFIndex *a8, uint64_t a9)
{
  const __CFData *v11;
  CFTypeID v17;
  const __CFBoolean *v18;
  const __CFBoolean *v19;
  CFTypeID v20;
  const __CFDictionary *v21;
  const __CFBoolean *v22;
  const __CFBoolean *v23;
  CFTypeID v24;
  _BOOL4 v25;
  const __CFData *v26;
  const __CFData *v27;
  CFIndex Length;
  const __CFAllocator *v29;
  __CFDictionary *Mutable;
  char v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  const __CFString *v36;
  char v37;
  BOOL v38;
  CFDataRef theData;
  void *value;

  theData = 0;
  value = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCommitWithPopulateAddition", CFSTR("amfdr is NULL"), v37);
    return 0;
  }
  if (!a2)
  {
    v36 = CFSTR("dataClassStr is NULL");
LABEL_43:
    AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCommitWithPopulateAddition", v36, v37);
LABEL_46:
    v34 = 0;
    v11 = 0;
    goto LABEL_35;
  }
  if (!a3)
  {
    v36 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_43;
  }
  v11 = a4;
  if (a4)
  {
    v38 = cf
       && (v17 = CFGetTypeID(cf), v17 == CFDictionaryGetTypeID())
       && CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("CombinedManifest"))
       && (v18 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("DeviceManifestMissing"))) != 0
       && (v19 = v18, v20 = CFGetTypeID(v18), v20 == CFBooleanGetTypeID())
       && CFBooleanGetValue(v19) != 0;
    v21 = (const __CFDictionary *)a1[2];
    v25 = v21
       && (v22 = (const __CFBoolean *)CFDictionaryGetValue(v21, CFSTR("DiscardExtraManifests"))) != 0
       && (v23 = v22, v24 = CFGetTypeID(v22), v24 == CFBooleanGetTypeID())
       && CFBooleanGetValue(v23) != 0;
    v26 = (const __CFData *)_AMFDRDataCopyForPutWithManifest((uint64_t)a1, a2, a3, v11, 0, a5, a6, a9);
    if (v26)
    {
      v27 = v26;
      Length = CFDataGetLength(v26);
      if ((AMFDRDataCopyExtraManifests(a1, v11, &value, (CFTypeRef *)&theData, a9) & 1) != 0)
      {
        v29 = CFGetAllocator(a1);
        Mutable = CFDictionaryCreateMutable(v29, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        v11 = Mutable;
        if (Mutable)
        {
          if (((v25 | a5 ^ 1) & 1) == 0)
          {
            v31 = v38;
            if (!value)
              v31 = 1;
            if ((v31 & 1) == 0)
            {
              CFDictionarySetValue(Mutable, CFSTR("DeviceManifest"), value);
              Length += CFDataGetLength((CFDataRef)value);
            }
          }
          if (theData)
            v32 = v25;
          else
            v32 = 1;
          if ((v32 & 1) == 0)
          {
            CFDictionarySetValue(v11, CFSTR("StationManifest"), theData);
            Length += CFDataGetLength(theData);
          }
          v33 = (*(uint64_t (**)(_QWORD *, const __CFString *, const void *, const __CFData *, const __CFData *, uint64_t))(a1[6] + 144))(a1, a2, a3, v27, v11, a9);
          v34 = v33;
          if (a8 && (_DWORD)v33)
          {
            *a8 = Length;
            v34 = 1;
          }
        }
        else
        {
          AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCommitWithPopulateAddition", CFSTR("additionToCommit is NULL"), v37);
          v34 = 0;
        }
      }
      else
      {
        AMFDRErrorPushInternal(a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCommitWithPopulateAddition", CFSTR("failed to copy extra manifests"), v37);
        v34 = 0;
        v11 = 0;
      }
      CFRelease(v27);
      if (value)
      {
        CFRelease(value);
        value = 0;
      }
      goto LABEL_35;
    }
    AMFDRErrorPushInternal(a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCommitWithPopulateAddition", CFSTR("dataToPut is NULL"), v37);
    goto LABEL_46;
  }
  AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCommitWithPopulateAddition", CFSTR("valueData is NULL"), v37);
  v34 = 0;
LABEL_35:
  if (theData)
  {
    CFRelease(theData);
    theData = 0;
  }
  if (v11)
    CFRelease(v11);
  return v34;
}

CFTypeRef AMFDRDataMultiCopyDigest(_QWORD *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  return _AMFDRDataMultiCopyInternal(a1, a2, a3, 2, 0, a4);
}

uint64_t AMFDRDataCopyManifest(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 160))();
}

CFTypeRef AMFDRDataMultiCopyManifest(_QWORD *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  return _AMFDRDataMultiCopyInternal(a1, a2, a3, 3, 0, a4);
}

CFTypeRef AMFDRDataMultiCopyAsidMetadata(_QWORD *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  return _AMFDRDataMultiCopyInternal(a1, a2, a3, 4, 0, a4);
}

uint64_t AMFDRDataDelete(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 32))();
}

uint64_t AMFDRDataMultiDelete(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 104))();
}

uint64_t AMFDRDataPrefetch(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 40))();
}

uint64_t AMFDRDataExport(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 48))();
}

uint64_t AMFDRDataMultiExport(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 112))();
}

uint64_t AMFDRDataIterate(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 72))();
}

uint64_t AMFDRDataMultiClaim(uint64_t a1, const __CFArray *a2, const __CFArray *a3, CFTypeRef *a4, uint64_t a5)
{
  return AMFDRDataMultiClaimWithOptions(a1, 0, a2, a3, a4, a5);
}

uint64_t AMFDRDataMultiClaimWithOptions(uint64_t a1, const __CFDictionary *a2, const __CFArray *a3, const __CFArray *a4, CFTypeRef *a5, uint64_t a6)
{
  CFErrorRef *v6;
  const __CFArray *v7;
  const __CFArray *Value;
  const __CFArray *v11;
  CFTypeID v12;
  const __CFArray *v13;
  const __CFArray *v14;
  CFTypeID v15;
  BOOL v16;
  const __CFArray *v17;
  uint64_t v18;
  const __CFString *v19;
  const __CFAllocator *v20;
  CFMutableArrayRef Mutable;
  const __CFAllocator *v22;
  const __CFAllocator *v23;
  const __CFAllocator *v24;
  __CFArray *v25;
  const __CFString *v26;
  const __CFDictionary *v27;
  const __CFDictionary *v28;
  CFIndex v29;
  CFStringRef v30;
  const __CFString *ValueAtIndex;
  const __CFString *v32;
  const __CFAllocator *v33;
  const __CFData *v34;
  const __CFData *v35;
  uint64_t v36;
  const __CFString *v37;
  const __CFAllocator *v38;
  uint64_t v39;
  int v40;
  const void *v41;
  __CFError *v42;
  const __CFData *v43;
  const void *v44;
  uint64_t v45;
  const void *v46;
  const void *v47;
  __CFString *v48;
  char v49;
  CFIndex Count;
  uint64_t v51;
  const __CFString *v53;
  const __CFString *format;
  char v55;
  CFTypeRef *v56;
  __CFArray *v58;
  __CFArray *v59;
  __CFArray *v60;
  __CFArray *v61;
  const __CFDictionary *v62;
  const __CFDictionary *v63;
  const __CFArray *v64;
  _BOOL4 v65;
  const __CFArray *v66;
  const __CFArray *theArray;
  int v69;
  CFTypeRef v70;
  CFTypeRef v71;
  const void *v72;
  CFTypeRef v73;
  CFDataRef v74;
  CFDataRef v75;
  const __CFData *v76;
  CFRange v77;
  CFRange v78;

  v6 = (CFErrorRef *)a6;
  v75 = 0;
  v76 = 0;
  v73 = 0;
  v74 = 0;
  v71 = 0;
  v72 = 0;
  v70 = 0;
  v69 = 2;
  if (!a1)
  {
    v19 = CFSTR("amfdr is NULL");
    goto LABEL_106;
  }
  v7 = a3;
  if (!a3)
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", CFSTR("dataClassArray is NULL"), v55);
LABEL_107:
    v51 = 0;
    goto LABEL_83;
  }
  if (!a4)
  {
    v19 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_106;
  }
  if (*(uint64_t (***)(int, int, int, int))(a1 + 48) != AMFDRHTTPStore)
  {
    v19 = CFSTR("Claim is only supported by HTTP store");
    goto LABEL_106;
  }
  if (!AMFDRDataInstanceUseSikFormat(a1))
  {
    v19 = CFSTR("kAMFDROptionUseSikDataInstance is set to false");
    goto LABEL_106;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v19 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_106;
  }
  if (!a2)
  {
    v64 = 0;
LABEL_14:
    v17 = 0;
    v18 = a1;
    goto LABEL_15;
  }
  Value = (const __CFArray *)CFDictionaryGetValue(a2, CFSTR("DeviceOnlySigningDataClasses"));
  v11 = Value;
  if (Value)
  {
    v12 = CFGetTypeID(Value);
    if (v12 != CFArrayGetTypeID())
    {
      v19 = CFSTR("Invalid kAMFDRDataClaimOptionDeviceOnlySigningDataClasses option is set");
      goto LABEL_106;
    }
  }
  v64 = v11;
  v13 = (const __CFArray *)CFDictionaryGetValue(a2, CFSTR("ServerOnlySigningDataClasses"));
  if (!v13)
    goto LABEL_14;
  v14 = v13;
  v15 = CFGetTypeID(v13);
  v16 = v15 == CFArrayGetTypeID();
  v17 = v14;
  v18 = a1;
  if (!v16)
  {
    v19 = CFSTR("Invalid kAMFDRDataClaimOptionServerOnlySigningDataClasses option is set");
LABEL_106:
    AMFDRErrorPushInternal((uint64_t)v6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", v19, v55);
    goto LABEL_107;
  }
LABEL_15:
  v20 = CFGetAllocator((CFTypeRef)v18);
  Mutable = CFArrayCreateMutable(v20, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    v19 = CFSTR("dataToClaim is NULL");
    goto LABEL_106;
  }
  v22 = CFGetAllocator((CFTypeRef)v18);
  v60 = CFArrayCreateMutable(v22, 0, MEMORY[0x24BDBD690]);
  if (!v60)
  {
    v19 = CFSTR("dataClassToClaim is NULL");
    goto LABEL_106;
  }
  v23 = CFGetAllocator((CFTypeRef)v18);
  v59 = CFArrayCreateMutable(v23, 0, MEMORY[0x24BDBD690]);
  if (!v59)
  {
    AMFDRErrorPushInternal((uint64_t)v6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", CFSTR("dataInstanceToClaim is NULL"), v55);
    v51 = 0;
    goto LABEL_83;
  }
  v24 = CFGetAllocator((CFTypeRef)v18);
  v25 = CFArrayCreateMutable(v24, 0, MEMORY[0x24BDBD690]);
  if (!v25)
  {
    AMFDRErrorPushInternal((uint64_t)v6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", CFSTR("missingDataClassInstance is NULL"), v55);
LABEL_109:
    v51 = 0;
    goto LABEL_83;
  }
  v66 = v7;
  theArray = v17;
  v26 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v18 + 16), CFSTR("UseSikDataInstance"));
  AMFDRSetOption(v18, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD268]);
  v27 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, const __CFArray *, const __CFArray *, CFErrorRef *))(*(_QWORD *)(v18 + 48) + 88))(v18, v7, a4, v6);
  if (v6 && *v6)
  {
    if (CFErrorGetCode(*v6) != 21)
    {
      AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", CFSTR("AMFDRDataMultiCopy got unexpected error"), v55);
      goto LABEL_109;
    }
    v28 = (const __CFDictionary *)AMFDRCopyUnderlyingDictionary(*v6, CFSTR("MultiRequestErrors"));
    if (*v6)
    {
      CFRelease(*v6);
      *v6 = 0;
    }
  }
  else
  {
    v28 = 0;
  }
  AMFDRSetOption(v18, CFSTR("UseSikDataInstance"), v26);
  if (!AMFDRDataGetSigningVersion(v18, &v69))
  {
    AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", CFSTR("AMFDRDataGetSigningVersion failed"), v55);
    goto LABEL_109;
  }
  v56 = a5;
  v58 = Mutable;
  if (CFArrayGetCount(v7) >= 1)
  {
    v29 = 0;
    v30 = 0;
    v61 = v25;
    v62 = v28;
    v63 = v27;
    do
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v29);
      v32 = (const __CFString *)CFArrayGetValueAtIndex(a4, v29);
      if (v30)
        CFRelease(v30);
      if (v75)
      {
        CFRelease(v75);
        v75 = 0;
      }
      if (v76)
      {
        CFRelease(v76);
        v76 = 0;
      }
      if (v74)
      {
        CFRelease(v74);
        v74 = 0;
      }
      if (v73)
      {
        CFRelease(v73);
        v73 = 0;
      }
      if (v72)
      {
        CFRelease(v72);
        v72 = 0;
      }
      if (v71)
      {
        CFRelease(v71);
        v71 = 0;
      }
      if (v70)
      {
        CFRelease(v70);
        v70 = 0;
      }
      if (theArray
        && (v77.length = CFArrayGetCount(theArray), v77.location = 0,
                                                    CFArrayContainsValue(theArray, v77, ValueAtIndex)))
      {
        AMSupportLogInternal();
        v30 = 0;
      }
      else
      {
        if (v64)
        {
          v78.length = CFArrayGetCount(v64);
          v78.location = 0;
          v65 = CFArrayContainsValue(v64, v78, ValueAtIndex) != 0;
        }
        else
        {
          v65 = 0;
        }
        v33 = CFGetAllocator((CFTypeRef)v18);
        v30 = CFStringCreateWithFormat(v33, 0, CFSTR("%@-%@"), ValueAtIndex, v32);
        if (!v27 || (v34 = (const __CFData *)CFDictionaryGetValue(v27, v30)) == 0)
        {
          if (!v28)
          {
            v53 = CFSTR("data is missing but multiRequestErrors is NULL");
            goto LABEL_88;
          }
          v42 = (__CFError *)CFDictionaryGetValue(v28, v30);
          if (!v42)
          {
            v55 = (char)v30;
            format = CFSTR("%@ is missing but multiRequestError is NULL");
            goto LABEL_86;
          }
          if (CFErrorGetCode(v42) != 701)
          {
            v55 = (char)v30;
            v53 = CFSTR("Unexpected error and underlying error for %@: %ld");
LABEL_88:
            AMFDRErrorPushInternal((uint64_t)v6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", v53, v55);
LABEL_89:
            v51 = 0;
            goto LABEL_83;
          }
          AMSupportLogInternal();
          CFArrayAppendValue(v25, v30);
          goto LABEL_62;
        }
        v35 = v34;
        v36 = (uint64_t)v6;
        v37 = (const __CFString *)AMFDRGetAssemblyIDToVerify(v18, ValueAtIndex);
        v38 = CFGetAllocator((CFTypeRef)v18);
        v39 = v36;
        if ((AMFDRDataStripExtraManifest(v38, v35, &v71, &v73, v36) & 1) == 0)
        {
          AMFDRErrorPushInternal(v36, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", CFSTR("AMFDRDataStripExtraManifest failed"), v55);
          v51 = 0;
          goto LABEL_83;
        }
        v40 = AMFDRSealingMapEntryHasSubCCListForClassInternal(v18, ValueAtIndex);
        v41 = AMFDRGetSubCCDigestsToVerify(v18, ValueAtIndex);
        if (!AMFDRDataVerifyImg4Integrity((const void *)v18, ValueAtIndex, v32, v37, (const __CFData *)v71, v40, (uint64_t)&v70))
        {
          AMSupportLogInternal();
          v25 = v61;
          CFArrayAppendValue(v61, v30);
LABEL_61:
          v6 = (CFErrorRef *)v39;
          v28 = v62;
          v27 = v63;
LABEL_62:
          v7 = v66;
          goto LABEL_63;
        }
        CFArrayAppendValue(v60, ValueAtIndex);
        CFArrayAppendValue(v59, v32);
        if (v69 == 1)
        {
          CFArrayAppendValue(v58, v35);
          v25 = v61;
          goto LABEL_61;
        }
        v43 = (const __CFData *)v73;
        if (v73)
        {
          v73 = 0;
          v74 = v43;
          v44 = (const void *)v18;
          v45 = v39;
        }
        else
        {
          v46 = (const void *)v18;
          v44 = (const void *)v18;
          v45 = v39;
          if ((_AMFDRDataCopyImg4Manifest(v46, (CFDataRef)v71, &v74, v39) & 1) == 0)
          {
            AMFDRErrorPushInternal(v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", CFSTR("_AMFDRDataCopyImg4StrippedValue failed"), v55);
            v51 = 0;
            goto LABEL_83;
          }
        }
        v47 = v41;
        v27 = v63;
        if ((_AMFDRDataCopyImg4StrippedValue(v44, (CFDataRef)v71, &v76, v45) & 1) == 0)
        {
          AMFDRErrorPushInternal(v45, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", CFSTR("_AMFDRDataCopyImg4StrippedValue failed"), v55);
          v51 = 0;
          goto LABEL_83;
        }
        if (v40)
          v48 = 0;
        else
          v48 = (__CFString *)v37;
        v49 = AMFDRDataLocalSign((uint64_t)v44, ValueAtIndex, v32, v76, 0, 0, v48, v47, &v75, v45);
        v6 = (CFErrorRef *)v45;
        v28 = v62;
        if ((v49 & 1) == 0)
        {
          AMFDRErrorPushInternal(v45, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", CFSTR("AMFDRDataLocalSign failed"), v55);
          v51 = 0;
          goto LABEL_83;
        }
        v25 = v61;
        if (v65)
        {
          AMSupportLogInternal();
          CFArrayAppendValue(v58, v75);
          v18 = a1;
          goto LABEL_62;
        }
        v18 = a1;
        v7 = v66;
        if ((AMFDRDataCreateFDR2Data(a1, v75, v74, (uint64_t)&v72, (uint64_t)v6) & 1) == 0)
        {
          format = CFSTR("AMFDRDataCreateFDR2Data failed");
LABEL_86:
          AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiClaimWithOptions", format, v55);
          goto LABEL_89;
        }
        CFArrayAppendValue(v58, v72);
      }
LABEL_63:
      ++v29;
    }
    while (v29 < CFArrayGetCount(v7));
  }
  Count = CFArrayGetCount(v25);
  if (v56 && Count >= 1)
    *v56 = CFRetain(v25);
  if (CFArrayGetCount(v58))
    v51 = (*(uint64_t (**)(uint64_t, __CFArray *, __CFArray *, __CFArray *, _QWORD, CFErrorRef *))(*(_QWORD *)(v18 + 48) + 96))(v18, v60, v59, v58, 0, v6);
  else
    v51 = 1;
LABEL_83:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v51;
}

uint64_t AMFDRDataGetSigningVersion(uint64_t a1, int *a2)
{
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  const __CFNumber *Value;
  const __CFNumber *v7;
  const __CFString *v8;
  const __CFBoolean *v9;
  _BOOL4 DeprecateGIDSigning;
  CFTypeID v11;
  _BOOL4 v12;
  CFTypeID v13;
  CFComparisonResult v14;
  int FDRDataVersionForDeviceInternal;
  int valuePtr;

  valuePtr = 0;
  if (!a1)
    goto LABEL_20;
  if (!a2)
    goto LABEL_20;
  v4 = (const __CFDictionary *)AMFDRGetOptions(a1);
  if (!v4)
    goto LABEL_20;
  v5 = v4;
  Value = (const __CFNumber *)CFDictionaryGetValue(v4, CFSTR("DataVersion"));
  if (!Value)
    goto LABEL_13;
  v7 = Value;
  v8 = (const __CFString *)CFDictionaryGetValue(v5, CFSTR("OrganizationalUnit"));
  v9 = (const __CFBoolean *)CFDictionaryGetValue(v5, CFSTR("LocalSigning"));
  DeprecateGIDSigning = AMFDRSealingMapGetDeprecateGIDSigning(a1);
  if (v9 && (v11 = CFGetTypeID(v9), v11 == CFBooleanGetTypeID()))
  {
    v12 = CFBooleanGetValue(v9) != 0;
    if (!v8)
      goto LABEL_15;
  }
  else
  {
    v12 = 0;
    if (!v8)
      goto LABEL_15;
  }
  v13 = CFGetTypeID(v8);
  if (v13 == CFStringGetTypeID())
  {
    v14 = CFStringCompare(v8, CFSTR("Devices - Stations"), 0);
    if (DeprecateGIDSigning && !v12 && v14 == kCFCompareEqualTo)
    {
LABEL_13:
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 136) + 8) & 8) != 0)
        FDRDataVersionForDeviceInternal = 1;
      else
        FDRDataVersionForDeviceInternal = AMFDRSealingMapGetFDRDataVersionForDeviceInternal(a1);
      valuePtr = FDRDataVersionForDeviceInternal;
      if (FDRDataVersionForDeviceInternal)
        goto LABEL_17;
      goto LABEL_20;
    }
  }
LABEL_15:
  if (CFNumberGetValue(v7, kCFNumberIntType, &valuePtr))
  {
    FDRDataVersionForDeviceInternal = valuePtr;
    if (valuePtr)
    {
LABEL_17:
      *a2 = FDRDataVersionForDeviceInternal;
      return 1;
    }
  }
LABEL_20:
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDRDataVerifyImg4Integrity(const void *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFData *a5, int a6, uint64_t a7)
{
  __int128 v10;
  const __CFAllocator *v15;
  const __CFData *ExternalRepresentation;
  const __CFData *v17;
  const __CFAllocator *v18;
  const __CFData *v19;
  const __CFData *v20;
  CFTypeID v21;
  const __CFAllocator *v22;
  const __CFData *v23;
  const __CFData *v24;
  const UInt8 *BytePtr;
  char *v26;
  const __CFArray *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const __CFString *v31;
  const __CFString *v33;
  char v34;
  unsigned int v35;
  void *v36;
  int v37;
  uint64_t v38;
  _BYTE v39[144];
  _OWORD v40[9];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40[7] = v10;
  v40[8] = v10;
  v40[5] = v10;
  v40[6] = v10;
  v40[3] = v10;
  v40[4] = v10;
  v40[1] = v10;
  v40[2] = v10;
  *(_OWORD *)&v39[128] = v10;
  v40[0] = v10;
  *(_OWORD *)&v39[112] = v10;
  *(_OWORD *)&v39[80] = v10;
  *(_OWORD *)&v39[96] = v10;
  *(_OWORD *)&v39[48] = v10;
  *(_OWORD *)&v39[64] = v10;
  *(_OWORD *)&v39[16] = v10;
  *(_OWORD *)&v39[32] = v10;
  *(_OWORD *)v39 = v10;
  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyImg4Integrity", CFSTR("amfdr is NULL"), v34);
LABEL_42:
    v29 = 2;
    goto LABEL_22;
  }
  if (!a2)
  {
    v31 = CFSTR("dataClass is NULL");
LABEL_30:
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyImg4Integrity", v31, v34);
    v29 = 2;
LABEL_31:
    AMFDRErrorPushInternal(a7, 18, (const __CFNumber *)v29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyImg4Integrity", CFSTR("trust verification error code=0x%016llX"), v29);
    goto LABEL_32;
  }
  if (!a3)
  {
    v31 = CFSTR("dataInstance is NULL");
    goto LABEL_30;
  }
  if (!a5)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyImg4Integrity", CFSTR("valueData is NULL"), v34);
    goto LABEL_42;
  }
  memset((char *)v40 + 8, 0, 136);
  memset(&v39[8], 0, 136);
  *(_QWORD *)&v40[0] = 66;
  if (AMFDRAllowIncompleteData((uint64_t)a1))
    *(_QWORD *)&v40[0] = 16450;
  *(_QWORD *)v39 = CFDataGetBytePtr(a5);
  *(_DWORD *)&v39[8] = CFDataGetLength(a5);
  v15 = CFGetAllocator(a1);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v15, a2, 0x8000100u, 0x20u);
  v17 = ExternalRepresentation;
  if (!ExternalRepresentation)
  {
    v29 = 2;
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyImg4Integrity", CFSTR("dataClassData is NULL"), v34);
    goto LABEL_22;
  }
  *(_QWORD *)&v39[64] = CFDataGetBytePtr(ExternalRepresentation);
  *(_DWORD *)&v39[72] = CFDataGetLength(v17);
  v18 = CFGetAllocator(a1);
  v19 = CFStringCreateExternalRepresentation(v18, a3, 0x8000100u, 0x20u);
  v20 = v19;
  if (!v19)
  {
    v29 = 2;
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyImg4Integrity", CFSTR("dataInstanceData is NULL"), v34);
    goto LABEL_22;
  }
  *(_QWORD *)&v39[80] = CFDataGetBytePtr(v19);
  *(_DWORD *)&v39[88] = CFDataGetLength(v20);
  if (a4 && (v21 = CFGetTypeID(a4), v21 == CFStringGetTypeID()) && CFStringGetLength(a4) >= 1)
  {
    v22 = CFGetAllocator(a1);
    v23 = CFStringCreateExternalRepresentation(v22, a4, 0x8000100u, 0x5Fu);
    v24 = v23;
    if (!v23)
    {
      v33 = CFSTR("CFStringCreateExternalRepresentation(assemblyID) failed");
LABEL_41:
      AMFDRErrorPushInternal(a7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyImg4Integrity", v33, v34);
      goto LABEL_42;
    }
    BytePtr = CFDataGetBytePtr(v23);
    if (a6)
    {
      *(_QWORD *)&v40[7] = BytePtr;
      DWORD2(v40[7]) = CFDataGetLength(v24);
      *(_QWORD *)&v39[128] = 0;
      v26 = &v39[136];
      goto LABEL_17;
    }
    *(_QWORD *)&v39[128] = BytePtr;
    *(_DWORD *)&v39[136] = CFDataGetLength(v24);
  }
  else
  {
    *(_QWORD *)&v39[128] = 0;
    *(_DWORD *)&v39[136] = 0;
  }
  *(_QWORD *)&v40[7] = 0;
  v26 = (char *)&v40[7] + 8;
LABEL_17:
  *(_DWORD *)v26 = 0;
  v27 = (const __CFArray *)AMFDRGetSubCCDigestsToVerify((uint64_t)a1, a2);
  if (v27)
  {
    if (_AMFDRDataCreatePtrFromTagStringCFArray(v27, &v36, &v35))
    {
      *(_QWORD *)&v40[8] = v36;
      DWORD2(v40[8]) = v35;
      goto LABEL_20;
    }
    v33 = CFSTR("cannot convert subCCsToVerifyDigest to uint32_t ptr");
    goto LABEL_41;
  }
LABEL_20:
  v28 = AMFDRDecodeTrustEvaluation((uint64_t *)v39, &v38, &v37);
  if (!v28)
  {
    v30 = 1;
    goto LABEL_33;
  }
  v29 = v28;
LABEL_22:
  if (!a2 || !a3)
    goto LABEL_31;
  AMFDRErrorPushInternal(a7, 18, (const __CFNumber *)v29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyImg4Integrity", CFSTR("trust verification error code=0x%016llX for %@:%@"), v29);
LABEL_32:
  v30 = 0;
LABEL_33:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (v36)
    free(v36);
  return v30;
}

uint64_t _AMFDRDataCopyImg4StrippedValue(const void *a1, CFDataRef theData, _QWORD *a3, uint64_t a4)
{
  const UInt8 *BytePtr;
  int Length;
  void *v9;
  const __CFAllocator *v10;
  const __CFString *v12;
  char v13;
  unsigned int v14;
  const UInt8 *v15;

  v15 = 0;
  v14 = 0;
  if (!a1)
  {
    v12 = CFSTR("amfdr is NULL");
LABEL_12:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyImg4StrippedValue", v12, v13);
    return 0;
  }
  if (!theData)
  {
    v12 = CFSTR("valueData is NULL");
    goto LABEL_12;
  }
  if (!a3)
  {
    v12 = CFSTR("outValueData is NULL");
    goto LABEL_12;
  }
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (AMFDRDecodeGetImg4RawData((uint64_t)BytePtr, Length, &v15, &v14))
  {
    v9 = (void *)CFRetain(theData);
  }
  else
  {
    v10 = CFGetAllocator(a1);
    v9 = CFDataCreate(v10, v15, v14);
  }
  *a3 = v9;
  return 1;
}

uint64_t AMFDRDataCreateFDR2Data(uint64_t a1, CFDataRef theData, const __CFData *a3, uint64_t a4, uint64_t a5)
{
  const UInt8 *BytePtr;
  int Length;
  const UInt8 *v10;
  int v11;
  const __CFString *v12;
  char v14;

  if (!a1)
  {
    v12 = CFSTR("amfdr is NULL");
LABEL_9:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateFDR2Data", v12, v14);
    return 0;
  }
  if (!theData)
  {
    v12 = CFSTR("value is NULL");
    goto LABEL_9;
  }
  if (!a3)
  {
    v12 = CFSTR("outValueData is NULL");
    goto LABEL_9;
  }
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v10 = CFDataGetBytePtr(a3);
  v11 = CFDataGetLength(a3);
  if (FDREncodeCreateFDR2Data((uint64_t)BytePtr, Length, (uint64_t)v10, v11))
    AMFDRErrorPushInternal(a5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateFDR2Data", CFSTR("FDREncodeCreateCombined failed"), v14);
  else
    AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateFDR2Data", CFSTR("combinedData is NULL"), v14);
  return 0;
}

CFDataRef AMFDRDataMake(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  uint64_t v8;
  const __CFData *v9;
  const __CFString *v10;
  int v11;
  const __CFString *v13;
  char v14;

  if (!a1)
  {
    v13 = CFSTR("amfdr is NULL");
LABEL_10:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMake", v13, v14);
    return 0;
  }
  if (!a2)
  {
    v13 = CFSTR("dataClassStr is NULL");
    goto LABEL_10;
  }
  if (!a3)
  {
    v13 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_10;
  }
  v8 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 80))();
  if (v8)
  {
    v9 = (const __CFData *)v8;
    v10 = (const __CFString *)AMFDRGetAssemblyIDToVerify(a1, a2);
    v11 = AMFDRSealingMapEntryHasSubCCListForClassInternal(a1, a2);
    if (AMFDRDataVerifyImg4Integrity((const void *)a1, a2, a3, v10, v9, v11, a4))
      return _AMFDRDataCopyFormatted((CFDictionaryRef *)a1, a2, a3, v9, a4);
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMake", CFSTR("AMFDRDataVerifyImg4Integrity with %@:%@ failed"), (char)a2);
    CFRelease(v9);
  }
  else
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMake", CFSTR("%@:%@ make data failed - foundData is NULL"), (char)a2);
  }
  return 0;
}

CFTypeRef AMFDRDataMultiMake(_QWORD *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  const __CFDictionary *Value;
  const __CFAllocator *v13;
  const __CFAllocator *v14;
  CFTypeRef v15;
  const __CFString *v16;
  CFDictionaryRef theDict;
  CFDictionaryRef Mutable;
  _QWORD context[4];

  context[3] = *MEMORY[0x24BDAC8D0];
  theDict = 0;
  Mutable = 0;
  memset(context, 170, 24);
  if (!a1)
  {
    v16 = CFSTR("amfdr is NULL");
LABEL_24:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiMake", v16, (char)theDict);
LABEL_26:
    v15 = 0;
    goto LABEL_32;
  }
  if (!a2)
  {
    v16 = CFSTR("dataClassArray is NULL");
    goto LABEL_24;
  }
  if (!a3)
  {
    v16 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_24;
  }
  if (a4 && *a4)
  {
    CFRelease(*a4);
    *a4 = 0;
  }
  v8 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, CFTypeRef *))(a1[6] + 120))(a1, a2, a3, a4);
  if (!v8)
  {
    AMSupportLogInternal();
    goto LABEL_26;
  }
  v9 = (const __CFDictionary *)v8;
  if (!a4 || !*a4)
  {
    v13 = CFGetAllocator(a1);
    v11 = 0;
    theDict = CFDictionaryCreateMutable(v13, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (theDict)
      goto LABEL_15;
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiMake", CFSTR("multiRequestErrors is NULL"), 0);
LABEL_38:
    v15 = 0;
    goto LABEL_30;
  }
  if (CFErrorGetCode((CFErrorRef)*a4) != 21)
  {
    AMSupportLogInternal();
    goto LABEL_38;
  }
  v10 = CFErrorCopyUserInfo((CFErrorRef)*a4);
  if (!v10)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiMake", CFSTR("userInfo is NULL"), (char)theDict);
    goto LABEL_38;
  }
  v11 = v10;
  Value = (const __CFDictionary *)CFDictionaryGetValue(v10, CFSTR("MultiRequestErrors"));
  theDict = Value;
  if (!Value)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiMake", CFSTR("MultiRequestErrors not in userInfo"), 0);
    v15 = 0;
    goto LABEL_29;
  }
  theDict = (CFDictionaryRef)CFRetain(Value);
LABEL_15:
  v14 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v14, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiMake", CFSTR("formattedDict is NULL"), (char)theDict);
    goto LABEL_28;
  }
  context[0] = a1;
  context[1] = &Mutable;
  context[2] = &theDict;
  CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)_AMFDRDataMultiMakeCallbak, context);
  if (CFDictionaryGetCount(theDict) >= 1)
    AMFDRErrorPushInternal((uint64_t)a4, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiMake", CFSTR("_AMFDRDataMultiMakeCallbak got errors"), (char)theDict);
  if (CFDictionaryGetCount(Mutable) < 1)
  {
LABEL_28:
    v15 = 0;
    if (!v11)
      goto LABEL_30;
    goto LABEL_29;
  }
  v15 = CFRetain(Mutable);
  if (v11)
LABEL_29:
    CFRelease(v11);
LABEL_30:
  CFRelease(v9);
  if (Mutable)
  {
    CFRelease(Mutable);
    Mutable = 0;
  }
LABEL_32:
  if (theDict)
    CFRelease(theDict);
  return v15;
}

void _AMFDRDataMultiMakeCallbak(const __CFString *a1, const __CFData *a2, uint64_t a3)
{
  const __CFData *v3;
  CFMutableDictionaryRef *v5;
  CFMutableDictionaryRef *v6;
  void *v7;
  const __CFAllocator *v8;
  const __CFString *v9;
  int v10;
  char v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFData *v14;
  const __CFString *v15;
  void *v16[2];
  void *v17[2];
  __int128 v18;
  const __CFString *format;
  char v20;
  char v21;
  void *value;
  const __CFString *v23;
  const __CFString *v24;

  v23 = 0;
  v24 = 0;
  value = 0;
  if (!a1)
  {
    AMSupportLogInternal();
    v3 = 0;
    goto LABEL_13;
  }
  v3 = a2;
  v5 = *(CFMutableDictionaryRef **)(a3 + 16);
  if (!a2)
  {
    AMFDRErrorPushInternal((uint64_t)&value, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiMakeCallbak", CFSTR("rawData is NULL"), v20);
    goto LABEL_9;
  }
  v6 = *(CFMutableDictionaryRef **)(a3 + 8);
  if (!v6)
  {
    v15 = CFSTR("formattedDict is NULL");
LABEL_26:
    AMFDRErrorPushInternal((uint64_t)&value, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiMakeCallbak", v15, v20);
LABEL_30:
    v3 = 0;
    goto LABEL_9;
  }
  if (!*v6)
  {
    v15 = CFSTR("formattedDict is uninitailized");
    goto LABEL_26;
  }
  v7 = *(void **)a3;
  v8 = CFGetAllocator(*(CFTypeRef *)a3);
  if ((AMFDRDataLocalDecomposeFullKey(v8, a1, (CFTypeRef *)&v24, (CFTypeRef *)&v23) & 1) == 0)
  {
    format = CFSTR("AMFDRDataLocalDecomposeFullKey failed with %@");
    v21 = (char)a1;
    *(_OWORD *)v17 = 0u;
    v18 = 0u;
    *(_OWORD *)v16 = 0u;
LABEL_29:
    AMFDRErrorPushInternal((uint64_t)&value, 10, 0, 0, 0, 0, 0, 0, v16[0], v16[1], v17[0], v17[1], (void *)v18, *((void **)&v18 + 1), (uint64_t)"_AMFDRDataMultiMakeCallbak", format, v21);
    goto LABEL_30;
  }
  v9 = (const __CFString *)AMFDRGetAssemblyIDToVerify((uint64_t)v7, v24);
  v10 = AMFDRSealingMapEntryHasSubCCListForClassInternal((uint64_t)v7, v24);
  v11 = AMFDRDataVerifyImg4Integrity(v7, v24, v23, v9, v3, v10, (uint64_t)&value);
  v13 = v23;
  v12 = v24;
  if ((v11 & 1) == 0)
  {
    v21 = (char)v24;
    format = CFSTR("AMFDRDataVerifyImg4Integrity with %@:%@ failed");
    *(_OWORD *)v17 = 0u;
    v18 = 0u;
    *(_OWORD *)v16 = 0u;
    goto LABEL_29;
  }
  v14 = (const __CFData *)CFRetain(v3);
  v3 = _AMFDRDataCopyFormatted((CFDictionaryRef *)v7, v12, v13, v14, (uint64_t)&value);
  if (v3)
    CFDictionaryAddValue(*v6, a1, v3);
  else
    AMFDRErrorPushInternal((uint64_t)&value, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiMakeCallbak", CFSTR("_AMFDRDataCopyFormatted failed with %@"), (char)a1);
LABEL_9:
  if (value && v5 && *v5)
    CFDictionarySetValue(*v5, a1, value);
LABEL_13:
  if (v24)
  {
    CFRelease(v24);
    v24 = 0;
  }
  if (v23)
  {
    CFRelease(v23);
    v23 = 0;
  }
  if (v3)
    CFRelease(v3);
  if (value)
    CFRelease(value);
}

CFTypeRef AMFDRDataPatch(_QWORD *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return _AMFDRDataPatchInternal(a1, a2, a3, a4, 0, a5, 0, a6);
}

CFTypeRef _AMFDRDataPatchInternal(_QWORD *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  const __CFString *v15;
  CFTypeRef v16;
  const __CFString *v18;
  uint64_t v19;
  CFIndex v20;
  void *value[2];
  void *v22[2];
  __int128 v23;
  const __CFString *v24;
  char v25;

  if (!a1)
  {
    v18 = CFSTR("amfdr is NULL");
LABEL_18:
    v24 = v18;
    *(_OWORD *)v22 = 0u;
    v23 = 0u;
    *(_OWORD *)value = 0u;
    v19 = a8;
    v20 = 1;
LABEL_20:
    AMFDRErrorPushInternal(v19, v20, 0, 0, 0, 0, 0, 0, value[0], value[1], v22[0], v22[1], (void *)v23, *((void **)&v23 + 1), (uint64_t)"_AMFDRDataPatchInternal", v24, v25);
    return 0;
  }
  if (!a2)
  {
    v18 = CFSTR("dataClassStr is NULL");
    goto LABEL_18;
  }
  if (!a3)
  {
    v18 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_18;
  }
  if (!a6)
  {
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataPatchInternal", CFSTR("patchDict is NULL"), v25);
    return 0;
  }
  if (!(a4 | a5))
  {
    v18 = CFSTR("valueData is NULL");
    goto LABEL_18;
  }
  v12 = 176;
  if (!a4)
    v12 = 192;
  v13 = (*(uint64_t (**)(void))(a1[6] + v12))();
  if (!v13)
  {
    v25 = (char)a2;
    v24 = CFSTR("failed to patch data for %@-%@");
    *(_OWORD *)v22 = 0u;
    v23 = 0u;
    *(_OWORD *)value = 0u;
    v19 = a8;
    v20 = 10;
    goto LABEL_20;
  }
  v14 = (const void *)v13;
  v15 = (const __CFString *)AMFDRGetAssemblyIDToVerify((uint64_t)a1, a2);
  if ((AMFDRDataVerifyImg4Integrity(a1, a2, a3, v15, (const __CFData *)v14, 1, a8) & 1) != 0)
  {
    v16 = CFRetain(v14);
  }
  else
  {
    AMFDRErrorPushInternal(a8, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataPatchInternal", CFSTR("failed to verify img4 data for %@-%@"), (char)a2);
    v16 = 0;
  }
  CFRelease(v14);
  return v16;
}

CFTypeRef AMFDRDataCommitPatch(_QWORD *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return _AMFDRDataPatchInternal(a1, a2, a3, 0, a4, a5, 0, a6);
}

CFTypeRef AMFDRDataMultiPatch(_QWORD *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, CFErrorRef *a6)
{
  return _AMFDRDataMultiPatchInternal(a1, a2, a3, a4, 0, a5, a6);
}

CFTypeRef _AMFDRDataMultiPatchInternal(_QWORD *a1, CFArrayRef theArray, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, const __CFArray *a6, CFErrorRef *a7)
{
  CFIndex Count;
  CFIndex v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  const void *v21;
  void *value;
  const __CFAllocator *v23;
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v25;
  CFMutableDictionaryRef v26;
  CFMutableDictionaryRef v27;
  CFTypeRef v28;
  const __CFString *v29;
  _QWORD context[4];

  context[3] = *MEMORY[0x24BDAC8D0];
  memset(context, 170, 24);
  if (!a1)
  {
    v29 = CFSTR("amfdr is NULL");
LABEL_38:
    AMFDRErrorPushInternal((uint64_t)a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiPatchInternal", v29, context[0]);
    return 0;
  }
  if (!theArray)
  {
    v29 = CFSTR("dataClassArray is NULL");
    goto LABEL_38;
  }
  if (!a3)
  {
    v29 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_38;
  }
  if (!a6)
  {
    v29 = CFSTR("patchDictArray is NULL");
    goto LABEL_38;
  }
  if (a4)
    a5 = a4;
  if (!a5)
  {
    v29 = CFSTR("dataArray is NULL");
    goto LABEL_38;
  }
  Count = CFArrayGetCount(theArray);
  if (!Count)
  {
    v29 = CFSTR("Invalid dataClassArray count");
    goto LABEL_38;
  }
  v15 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v29 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_38;
  }
  if (CFArrayGetCount(a5) != v15)
  {
    v29 = CFSTR("Invalid originalDataArray count");
    goto LABEL_38;
  }
  if (CFArrayGetCount(a6) != v15)
  {
    v29 = CFSTR("Invalid patchDictArray count");
    goto LABEL_38;
  }
  v16 = 184;
  if (!a4)
    v16 = 200;
  v17 = (*(uint64_t (**)(_QWORD *, CFArrayRef, const __CFArray *, const __CFArray *, const __CFArray *, _QWORD, CFErrorRef *))(a1[6] + v16))(a1, theArray, a3, a5, a6, 0, a7);
  if (!v17)
  {
    AMSupportLogInternal();
    return 0;
  }
  v18 = (const void *)v17;
  if (!a7 || !*a7)
  {
    v23 = CFGetAllocator(a1);
    Mutable = CFDictionaryCreateMutable(v23, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (Mutable)
    {
      value = Mutable;
      v20 = 0;
      goto LABEL_24;
    }
    AMFDRErrorPushInternal((uint64_t)a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiPatchInternal", CFSTR("multiRequestErrors is NULL"), context[0]);
    goto LABEL_53;
  }
  if (CFErrorGetCode(*a7) != 21)
  {
    AMSupportLogInternal();
LABEL_53:
    CFRelease(v18);
    return 0;
  }
  v19 = CFErrorCopyUserInfo(*a7);
  if (!v19)
  {
    AMFDRErrorPushInternal((uint64_t)a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiPatchInternal", CFSTR("userInfo is NULL"), context[0]);
    goto LABEL_53;
  }
  v20 = v19;
  v21 = CFDictionaryGetValue(v19, CFSTR("MultiRequestErrors"));
  if (!v21)
  {
    AMFDRErrorPushInternal((uint64_t)a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiPatchInternal", CFSTR("MultiRequestErrors not in userInfo"), context[0]);
    CFRelease(v18);
    v27 = 0;
    value = 0;
    v28 = 0;
    goto LABEL_44;
  }
  value = (void *)CFRetain(v21);
LABEL_24:
  v25 = CFGetAllocator(a1);
  v26 = CFDictionaryCreateMutable(v25, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v27 = v26;
  if (v26)
  {
    context[0] = a1;
    context[1] = v26;
    context[2] = value;
    CFDictionaryApplyFunction((CFDictionaryRef)v18, (CFDictionaryApplierFunction)_AMFDRDataMultiPatchCallback, context);
    if (CFDictionaryGetCount((CFDictionaryRef)value) >= 1)
      AMFDRErrorPushInternal((uint64_t)a7, 21, 0, 0, 0, 0, 0, 0, value, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiPatchInternal", CFSTR("_AMFDRDataMultiPatchCallback got errors"), context[0]);
    if (CFDictionaryGetCount(v27) >= 1)
    {
      v28 = CFRetain(v27);
      goto LABEL_43;
    }
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiPatchInternal", CFSTR("patchedDataDict is NULL"), context[0]);
  }
  v28 = 0;
LABEL_43:
  CFRelease(v18);
  if (v20)
LABEL_44:
    CFRelease(v20);
  if (value)
    CFRelease(value);
  if (v27)
    CFRelease(v27);
  return v28;
}

CFTypeRef AMFDRDataMultiCommitPatch(_QWORD *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, CFErrorRef *a6)
{
  return _AMFDRDataMultiPatchInternal(a1, a2, a3, 0, a4, a5, a6);
}

uint64_t AMFDRDataDictCopy(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  char v5;
  const __CFData *v7;
  const __CFData *v8;
  _QWORD v10[6];
  uint64_t v11;

  v5 = (char)a2;
  v11 = 0;
  v7 = AMFDRDataCopy(a1, a2, a3, a4);
  if (v7)
  {
    v8 = v7;
    v10[0] = a1;
    v10[1] = 0xAAAAAAAAAAAAAA01;
    v10[2] = 0;
    v10[3] = 0;
    v10[4] = &v11;
    v10[5] = a4;
    _AMFDRDataDictConvertFromData(0, v7, (uint64_t)v10);
    if (!v11)
      AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictCopyInternal", CFSTR("failed to convert value for %@-%@"), v5);
    CFRelease(v8);
    return v11;
  }
  else
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictCopyInternal", CFSTR("failed to copy payload data for %@-%@"), v5);
    return 0;
  }
}

CFTypeRef AMFDRDataDictMultiCopy(_QWORD *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  CFTypeRef v6;
  const void *v7;
  CFIndex Code;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const void *v11;
  void *value;
  const __CFAllocator *v13;
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v15;
  CFMutableDictionaryRef v16;
  CFMutableDictionaryRef v17;
  CFTypeRef v18;
  const __CFString *v20;
  char v21;
  _QWORD context[6];

  v6 = _AMFDRDataMultiCopyInternal(a1, a2, a3, 0, 0, a4);
  if (!v6)
  {
    AMSupportLogInternal();
    return 0;
  }
  v7 = v6;
  if (!a4 || !*a4)
  {
    v13 = CFGetAllocator(a1);
    Mutable = CFDictionaryCreateMutable(v13, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (Mutable)
    {
      value = Mutable;
      v10 = 0;
      goto LABEL_10;
    }
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictMultiCopyInternal", CFSTR("multiErrors is NULL"), v21);
    goto LABEL_29;
  }
  Code = CFErrorGetCode((CFErrorRef)*a4);
  if (Code != 21)
  {
    v21 = Code;
    v20 = CFSTR("invalid multi-request error code: %ld");
LABEL_28:
    AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictMultiCopyInternal", v20, v21);
LABEL_29:
    CFRelease(v7);
    return 0;
  }
  v9 = CFErrorCopyUserInfo((CFErrorRef)*a4);
  if (!v9)
  {
    v20 = CFSTR("userInfo is NULL");
    goto LABEL_28;
  }
  v10 = v9;
  v11 = CFDictionaryGetValue(v9, CFSTR("MultiRequestErrors"));
  if (!v11)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictMultiCopyInternal", CFSTR("MultiRequestErrors not in userInfo"), v21);
    value = 0;
    v17 = 0;
    v18 = 0;
    goto LABEL_19;
  }
  value = (void *)CFRetain(v11);
LABEL_10:
  v15 = CFGetAllocator(a1);
  v16 = CFDictionaryCreateMutable(v15, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v17 = v16;
  if (v16)
  {
    context[0] = a1;
    context[1] = 0xAAAAAAAAAAAAAA01;
    context[2] = v16;
    context[3] = value;
    context[4] = 0;
    context[5] = 0;
    CFDictionaryApplyFunction((CFDictionaryRef)v7, (CFDictionaryApplierFunction)_AMFDRDataDictConvertFromData, context);
    if (CFDictionaryGetCount((CFDictionaryRef)value) >= 1)
      AMFDRErrorPushInternal((uint64_t)a4, 21, 0, 0, 0, 0, 0, 0, value, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictMultiCopyInternal", CFSTR("_AMFDRDataDictConvertFromData got errors"), v21);
    if (CFDictionaryGetCount(v17) >= 1)
    {
      v18 = CFRetain(v17);
      if (!v10)
        goto LABEL_20;
      goto LABEL_19;
    }
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictMultiCopyInternal", CFSTR("multiDict is NULL"), v21);
  }
  v18 = 0;
  if (v10)
LABEL_19:
    CFRelease(v10);
LABEL_20:
  CFRelease(v7);
  if (v17)
    CFRelease(v17);
  if (value)
    CFRelease(value);
  return v18;
}

uint64_t AMFDRDataDictPut(const void *a1, const __CFString *a2, const void *a3, const __CFDictionary *a4, __CFString *a5, uint64_t a6)
{
  uint64_t v12;
  void *v13;
  const __CFData *v14;
  const __CFData *v15;
  uint64_t v16;
  char v18;

  if (a1)
  {
    CFGetAllocator(a1);
    AMFDRSysconfigCreate();
    if (v12)
    {
      v13 = (void *)v12;
      AMFDRSysconfigSetDataClass(v12, a2);
      v14 = _AMFDRDataDictCopyForPut(v13, a4, a6);
      if (v14)
      {
        v15 = v14;
        v16 = AMFDRDataPutWithOptions((uint64_t)a1, a2, a3, v14, a5, a6);
        CFRelease(v13);
        CFRelease(v15);
        return v16;
      }
      AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictPutInternal", CFSTR("failed to copy dict value to put"), v18);
      CFRelease(v13);
    }
    else
    {
      AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictPutInternal", CFSTR("sysconfig is NULL"), v18);
    }
  }
  else
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictPutInternal", CFSTR("amfdr is NULL"), v18);
  }
  return 0;
}

uint64_t AMFDRDataDictMultiPut(_QWORD *a1, CFArrayRef theArray, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, uint64_t a6)
{
  uint64_t Count;
  const __CFAllocator *v12;
  const __CFArray *Mutable;
  __CFArray *v14;
  CFIndex v15;
  CFDataRef v16;
  void *v17;
  const void *ValueAtIndex;
  const void *v19;
  CFTypeID v20;
  CFTypeID v21;
  uint64_t v22;
  CFDataRef v23;
  uint64_t v24;
  const __CFString *format;
  const __CFString *v27;
  char v28;
  char v29;
  const __CFArray *v30;
  const __CFArray *v31;

  if (!a1)
  {
    v27 = CFSTR("amfdr is NULL");
LABEL_35:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictMultiPutInternal", v27, v28);
    return 0;
  }
  if (!theArray)
  {
    v27 = CFSTR("dataClassArray is NULL");
    goto LABEL_35;
  }
  if (!a4)
  {
    v27 = CFSTR("valueDictArray is NULL");
    goto LABEL_35;
  }
  Count = CFArrayGetCount(theArray);
  if (Count != CFArrayGetCount(a4))
  {
    v27 = CFSTR("valueDictArray size is invalid");
    goto LABEL_35;
  }
  if (!Count)
    return 1;
  v12 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v12, Count, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictMultiPutInternal", CFSTR("dataArrayToPut is NULL"), v28);
    return 0;
  }
  v14 = Mutable;
  if (Count < 1)
  {
    v24 = AMFDRDataMultiPutWithOptions(a1, theArray, a3, Mutable, a5, a6);
  }
  else
  {
    v30 = a3;
    v31 = a5;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a4, v15);
      v19 = CFArrayGetValueAtIndex(theArray, v15);
      if (v17)
        CFRelease(v17);
      if (v16)
        CFRelease(v16);
      if (!ValueAtIndex || (v20 = CFGetTypeID(ValueAtIndex), v20 != CFDictionaryGetTypeID()))
      {
        v29 = v15;
        format = CFSTR("valueDictArray has invalid element #%ld");
LABEL_27:
        AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictMultiPutInternal", format, v29);
        goto LABEL_29;
      }
      if (!v19 || (v21 = CFGetTypeID(v19), v21 != CFStringGetTypeID()))
      {
        v29 = v15;
        format = CFSTR("dataClassArray has invalid element #%ld");
        goto LABEL_27;
      }
      CFGetAllocator(a1);
      AMFDRSysconfigCreate();
      if (!v22)
      {
        AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictMultiPutInternal", CFSTR("sysconfig is NULL"), v28);
        goto LABEL_29;
      }
      v17 = (void *)v22;
      AMFDRSysconfigSetDataClass(v22, v19);
      v23 = _AMFDRDataDictCopyForPut(v17, (const __CFDictionary *)ValueAtIndex, a6);
      if (!v23)
        break;
      v16 = v23;
      CFArrayAppendValue(v14, v23);
      if (Count == ++v15)
      {
        v24 = AMFDRDataMultiPutWithOptions(a1, theArray, v30, v14, v31, a6);
        CFRelease(v17);
        CFRelease(v16);
        goto LABEL_23;
      }
    }
    AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictMultiPutInternal", CFSTR("failed to copy #%ld to put"), v15);
    CFRelease(v17);
LABEL_29:
    v24 = 0;
  }
LABEL_23:
  CFRelease(v14);
  return v24;
}

uint64_t AMFDRDataRevert(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 232))();
}

uint64_t AMFDRDataGetManifestVersion(uint64_t a1, unsigned int *a2)
{
  const __CFDictionary *v4;
  const __CFNumber *Value;
  unsigned int v6;
  unsigned int valuePtr;

  valuePtr = 0;
  if (!a1)
    goto LABEL_13;
  if (!a2)
    goto LABEL_13;
  v4 = (const __CFDictionary *)AMFDRGetOptions(a1);
  if (!v4)
    goto LABEL_13;
  Value = (const __CFNumber *)CFDictionaryGetValue(v4, CFSTR("ManifestVersion"));
  if (Value)
  {
    if (!CFNumberGetValue(Value, kCFNumberIntType, &valuePtr))
      goto LABEL_13;
    v6 = valuePtr;
  }
  else
  {
    v6 = (*(_BYTE *)(*(_QWORD *)(a1 + 136) + 8) & 8) == 0 && AMFDRSealingMapGetFDRManifestVersionForDeviceInternal(a1);
    valuePtr = v6;
  }
  if (v6 < 2)
  {
    *a2 = v6;
    return 1;
  }
LABEL_13:
  AMSupportLogInternal();
  return 0;
}

uint64_t AMFDRDataGetMinimalManifestVersion(uint64_t a1, int *a2)
{
  const __CFDictionary *v4;
  const __CFNumber *Value;
  int FDRMinimalManifestVersionForDeviceInternal;
  int valuePtr;

  valuePtr = 0;
  if (!a1)
    goto LABEL_13;
  if (!a2)
    goto LABEL_13;
  v4 = (const __CFDictionary *)AMFDRGetOptions(a1);
  if (!v4)
    goto LABEL_13;
  Value = (const __CFNumber *)CFDictionaryGetValue(v4, CFSTR("MinimalManifestVersion"));
  if (Value)
  {
    if (!CFNumberGetValue(Value, kCFNumberIntType, &valuePtr))
      goto LABEL_13;
    FDRMinimalManifestVersionForDeviceInternal = valuePtr;
  }
  else
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 136) + 8) & 8) != 0)
      FDRMinimalManifestVersionForDeviceInternal = 1;
    else
      FDRMinimalManifestVersionForDeviceInternal = AMFDRSealingMapGetFDRMinimalManifestVersionForDeviceInternal(a1);
    valuePtr = FDRMinimalManifestVersionForDeviceInternal;
  }
  if ((FDRMinimalManifestVersionForDeviceInternal - 3) > 0xFFFFFFFD)
  {
    *a2 = FDRMinimalManifestVersionForDeviceInternal;
    return 1;
  }
LABEL_13:
  AMSupportLogInternal();
  return 0;
}

BOOL _AMFDRDataCreatePtrFromTagStringCFArray(const __CFArray *a1, _QWORD *a2, unsigned int *a3)
{
  unsigned int Count;
  unsigned int v7;
  void *v8;
  void *v9;
  unint64_t v10;
  BOOL v11;
  const __CFData *v12;
  const __CFAllocator *v13;
  const __CFString *ValueAtIndex;
  const __CFData *ExternalRepresentation;
  unsigned int *BytePtr;

  if (a2
    && a3
    && (Count = CFArrayGetCount(a1), (v7 = Count) != 0)
    && (v8 = malloc_type_malloc(4 * Count, 0x100004052888210uLL)) != 0)
  {
    v9 = v8;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, v10);
      if (v12)
        CFRelease(v12);
      ExternalRepresentation = CFStringCreateExternalRepresentation(v13, ValueAtIndex, 0x8000100u, 0x5Fu);
      if (!ExternalRepresentation)
        break;
      v12 = ExternalRepresentation;
      if (CFDataGetLength(ExternalRepresentation) != 4)
      {
        AMSupportLogInternal();
        free(v9);
        goto LABEL_12;
      }
      BytePtr = (unsigned int *)CFDataGetBytePtr(v12);
      *((_DWORD *)v9 + v10++) = AMFDRTagsStringToTag(BytePtr);
      v11 = v10 >= v7;
      if (v7 == v10)
      {
        *a2 = v9;
        *a3 = v7;
        v11 = 1;
LABEL_12:
        CFRelease(v12);
        return v11;
      }
    }
    AMSupportLogInternal();
    free(v9);
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
  return v11;
}

uint64_t AMFDRDataVerifyInternal(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFData *a5, const __CFString *a6, int a7, CFDataRef *a8, uint64_t a9)
{
  const __CFString *v9;
  const __CFString *v10;
  uint64_t v11;
  __int128 v12;
  const __CFDictionary *v14;
  const __CFData *v15;
  const __CFData *Value;
  const __CFData *v20;
  const __CFAllocator *v21;
  const __CFAllocator *v22;
  const __CFAllocator *v23;
  const __CFData *v24;
  const __CFData *v25;
  const UInt8 *BytePtr;
  const __CFData *v27;
  const __CFString *v28;
  const __CFString *v29;
  const __CFAllocator *v30;
  const __CFData *v31;
  const __CFData *v32;
  const __CFBoolean *v33;
  const __CFBoolean *v34;
  CFTypeID v35;
  const void *v36;
  const __CFData *v37;
  const __CFString *SikPub;
  const __CFAllocator *v39;
  const __CFData *v40;
  const __CFData *v41;
  const __CFAllocator *v42;
  const __CFData *v43;
  const __CFString *v44;
  const __CFArray *v45;
  const __CFString *v46;
  CFTypeID v47;
  const __CFAllocator *v48;
  const __CFData *v49;
  const __CFData *v50;
  const UInt8 *v51;
  unsigned int v52;
  const UInt8 *v53;
  unsigned int v54;
  const UInt8 *v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  const __CFAllocator *v60;
  const void *v61;
  const void *v62;
  CFTypeID v63;
  BOOL v64;
  CFTypeID v65;
  const __CFString *v66;
  const __CFString *v67;
  const __CFAllocator *v68;
  const __CFData *v69;
  const __CFAllocator *v70;
  const __CFData *v71;
  const __CFData *v72;
  uint64_t v73;
  const __CFData *v74;
  uint64_t v75;
  const __CFString *format;
  const __CFString *v78;
  const __CFString *v79;
  char v80;
  const __CFData *v81;
  const __CFData *v82;
  const __CFData *v83;
  const __CFData *cf;
  CFDataRef ExternalRepresentation;
  const __CFData *theData;
  unsigned int v89;
  void *v90;
  int v91;
  CFDataRef v92;
  _DWORD length[3];
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;

  v9 = a3;
  v10 = a2;
  v11 = a9;
  v112 = *MEMORY[0x24BDAC8D0];
  memset(length, 0, sizeof(length));
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v110 = v12;
  v111 = v12;
  v108 = v12;
  v109 = v12;
  v106 = v12;
  v107 = v12;
  v104 = v12;
  v105 = v12;
  v102 = v12;
  v103 = v12;
  v100 = v12;
  v101 = v12;
  v98 = v12;
  v99 = v12;
  v96 = v12;
  v97 = v12;
  v94 = v12;
  v95 = v12;
  v92 = 0;
  v91 = 0;
  v90 = 0;
  v89 = 0;
  if (!a1)
  {
    format = CFSTR("amfdr is NULL");
LABEL_117:
    AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", format, v80);
    v50 = 0;
    v49 = 0;
    SikPub = 0;
    v82 = 0;
    v83 = 0;
    cf = 0;
    theData = 0;
    v27 = 0;
LABEL_129:
    v15 = 0;
    goto LABEL_130;
  }
  v14 = *(const __CFDictionary **)(a1 + 16);
  if (!v14)
  {
    format = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_117;
  }
  if (!a2)
  {
    v78 = CFSTR("dataClassStr is NULL");
LABEL_120:
    AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", v78, v80);
    v72 = 0;
    v15 = 0;
    v27 = 0;
    v71 = 0;
    v83 = 0;
    cf = 0;
    v82 = 0;
    SikPub = 0;
    v49 = 0;
    v50 = 0;
    v59 = 2;
    goto LABEL_89;
  }
  if (!a3)
  {
    v78 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_120;
  }
  v15 = a5;
  if (!a5)
  {
    AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("valueData is NULL"), v80);
    v50 = 0;
    v49 = 0;
    SikPub = 0;
    v82 = 0;
    v83 = 0;
    cf = 0;
    theData = 0;
    v27 = 0;
LABEL_130:
    v81 = 0;
    goto LABEL_145;
  }
  v110 = 0u;
  v111 = 0u;
  v108 = 0u;
  v109 = 0u;
  v106 = 0u;
  v107 = 0u;
  v104 = 0u;
  v105 = 0u;
  v102 = 0u;
  v103 = 0u;
  v100 = 0u;
  v101 = 0u;
  v98 = 0u;
  v99 = 0u;
  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  Value = (const __CFData *)CFDictionaryGetValue(v14, CFSTR("TrustObjectDigest"));
  if (Value)
  {
    v20 = Value;
    *(_QWORD *)&v97 = CFDataGetBytePtr(Value);
    DWORD2(v97) = CFDataGetLength(v20);
  }
  v21 = CFGetAllocator((CFTypeRef)a1);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v21, v10, 0x8000100u, 0x20u);
  if (!ExternalRepresentation)
  {
    v59 = 2;
    AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("dataClassData is NULL"), v80);
    v50 = 0;
    v49 = 0;
    SikPub = 0;
    v82 = 0;
    v83 = 0;
    cf = 0;
    theData = 0;
    v27 = 0;
    v15 = 0;
    v81 = 0;
    v9 = a3;
    goto LABEL_84;
  }
  v22 = CFGetAllocator((CFTypeRef)a1);
  v9 = a3;
  theData = CFStringCreateExternalRepresentation(v22, a3, 0x8000100u, 0x20u);
  if (!theData)
  {
    v59 = 2;
    AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("dataInstanceData is NULL"), v80);
    v50 = 0;
    v49 = 0;
    SikPub = 0;
    v82 = 0;
    v83 = 0;
    cf = 0;
    theData = 0;
LABEL_126:
    v15 = 0;
    v81 = 0;
    v27 = ExternalRepresentation;
    goto LABEL_84;
  }
  if (!a6)
  {
    a6 = (const __CFString *)AMFDRGetAssemblyIDToVerify(a1, v10);
    if (!a6)
    {
      cf = 0;
      v27 = ExternalRepresentation;
      goto LABEL_17;
    }
  }
  v23 = CFGetAllocator((CFTypeRef)a1);
  v24 = CFStringCreateExternalRepresentation(v23, a6, 0x8000100u, 0x20u);
  if (!v24)
  {
    v59 = 2;
    AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("assemblyIDData is NULL"), v80);
    v50 = 0;
    v49 = 0;
    SikPub = 0;
    v82 = 0;
    v83 = 0;
    cf = 0;
    goto LABEL_126;
  }
  v25 = v24;
  BytePtr = CFDataGetBytePtr(v24);
  v27 = ExternalRepresentation;
  cf = v25;
  if (a7)
  {
    *(_QWORD *)&v110 = BytePtr;
    DWORD2(v110) = CFDataGetLength(v25);
  }
  else
  {
    *(_QWORD *)&v102 = BytePtr;
    DWORD2(v102) = CFDataGetLength(v25);
  }
LABEL_17:
  v28 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("INST"));
  if (v28)
  {
    v29 = v28;
    v30 = CFGetAllocator((CFTypeRef)a1);
    v31 = CFStringCreateExternalRepresentation(v30, v29, 0x8000100u, 0x20u);
    if (v31)
    {
      v32 = v31;
      *(_QWORD *)&v100 = CFDataGetBytePtr(v31);
      v81 = v32;
      DWORD2(v100) = CFDataGetLength(v32);
      goto LABEL_21;
    }
    AMFDRErrorPushInternal(a9, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("Failed to convert sealedDataInstance to CFDataRef"), v80);
    v50 = 0;
    v49 = 0;
    SikPub = 0;
    v82 = 0;
    v83 = 0;
    goto LABEL_129;
  }
  v81 = 0;
LABEL_21:
  if ((AMFDRDataGetSigningVersion(a1, &v91) & 1) == 0)
  {
    AMFDRErrorPushInternal(a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("AMFDRDataGetSigningVersion failed"), v80);
LABEL_134:
    v50 = 0;
    v49 = 0;
    SikPub = 0;
    goto LABEL_135;
  }
  if (v91 != 2)
  {
    v83 = 0;
    v36 = 0;
LABEL_39:
    v37 = 0;
    goto LABEL_40;
  }
  v33 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("SkipVerifySik"));
  if (v33)
  {
    v34 = v33;
    v35 = CFGetTypeID(v33);
    if (v35 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v34))
      {
        v36 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("kAMFDROptionOfflineSigning"));
        v83 = 0;
        v37 = 0;
        v11 = a9;
        goto LABEL_40;
      }
    }
  }
  SikPub = (const __CFString *)AMFDRCryptoGetSikPub(a1);
  if (!SikPub)
  {
    AMFDRErrorPushInternal(a9, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("sikPub is NULL"), v80);
    v50 = 0;
    v49 = 0;
LABEL_135:
    v82 = 0;
    v83 = 0;
LABEL_144:
    v15 = 0;
    goto LABEL_145;
  }
  if (!a4)
    a4 = (const __CFString *)AMFDRGetSikOverride((_QWORD *)a1, (uint64_t)v10, (uint64_t)a3);
  v36 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("kAMFDROptionOfflineSigning"));
  v39 = CFGetAllocator((CFTypeRef)a1);
  v40 = CFStringCreateExternalRepresentation(v39, SikPub, 0x8000100u, 0x20u);
  if (!v40)
  {
    AMFDRErrorPushInternal(a9, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("Failed to convert sikPub to CFDataRef"), v80);
    goto LABEL_134;
  }
  v41 = v40;
  *(_QWORD *)&v101 = CFDataGetBytePtr(v40);
  v11 = a9;
  v83 = v41;
  if (!(_QWORD)v101)
  {
    v79 = CFSTR("sik is NULL");
LABEL_139:
    AMFDRErrorPushInternal(a9, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", v79, v80);
    v50 = 0;
    v49 = 0;
    SikPub = 0;
    v82 = 0;
    goto LABEL_144;
  }
  DWORD2(v101) = CFDataGetLength(v41);
  if (!DWORD2(v101))
  {
    v79 = CFSTR("sikLength is 0");
    goto LABEL_139;
  }
  if (!a4)
    goto LABEL_39;
  v42 = CFGetAllocator((CFTypeRef)a1);
  v43 = CFStringCreateExternalRepresentation(v42, a4, 0x8000100u, 0x20u);
  if (!v43)
  {
    v79 = CFSTR("Failed to convert sikOverride to CFDataRef");
    goto LABEL_139;
  }
  v37 = v43;
  *(_QWORD *)&v107 = CFDataGetBytePtr(v43);
  if (!(_QWORD)v107)
  {
    v82 = v37;
    v44 = CFSTR("sikOverride is NULL");
    goto LABEL_142;
  }
  DWORD2(v107) = CFDataGetLength(v37);
  if (!DWORD2(v107))
  {
    v82 = v37;
    v44 = CFSTR("sikOverrideLength is 0");
LABEL_142:
    AMFDRErrorPushInternal(a9, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", v44, v80);
    goto LABEL_143;
  }
LABEL_40:
  v45 = (const __CFArray *)AMFDRGetSubCCDigestsToVerify(a1, v10);
  v82 = v37;
  if (v45)
  {
    if (!_AMFDRDataCreatePtrFromTagStringCFArray(v45, &v90, &v89))
    {
      AMFDRErrorPushInternal(v11, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("cannot convert subCCsToVerifyDigest to uint32_t ptr"), v80);
      goto LABEL_143;
    }
    *(_QWORD *)&v111 = v90;
    DWORD2(v111) = v89;
  }
  v46 = v10;
  if (v36)
  {
    v47 = CFGetTypeID(v36);
    if (v47 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue((CFBooleanRef)v36))
      {
        v48 = CFGetAllocator((CFTypeRef)a1);
        SikPub = CFStringCreateWithFormat(v48, 0, CFSTR("%@.offline"), a3);
        if (SikPub)
        {
          v49 = (const __CFData *)(*(uint64_t (**)(uint64_t, const __CFString *, const __CFString *, uint64_t))(*(_QWORD *)(a1 + 48) + 16))(a1, v10, SikPub, a9);
          if (v49)
          {
            v50 = AMFDROfflineBlobVerify(a1, v49, a9);
            if (v50)
            {
              v51 = CFDataGetBytePtr(v15);
              v52 = CFDataGetLength(v15);
              v53 = CFDataGetBytePtr(theData);
              v54 = CFDataGetLength(theData);
              v55 = CFDataGetBytePtr(v50);
              v56 = CFDataGetLength(v50);
              v57 = v54;
              v58 = (uint64_t)v55;
              v27 = ExternalRepresentation;
              v9 = a3;
              v59 = AMFDRDecodeEvaluateTrustOffline((uint64_t)v51, v52, (uint64_t)v53, v57, v58, v56, &length[1], length);
              v15 = 0;
              v10 = v46;
              goto LABEL_79;
            }
            v59 = 2;
            AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("Failed to verify offline blob"), v80);
          }
          else
          {
            v59 = 2;
            AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("offlineBlob is NULL"), v80);
            v50 = 0;
          }
          v15 = 0;
        }
        else
        {
          v59 = 2;
          AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("offlineDataInstanceStr is NULL"), v80);
          v50 = 0;
          v49 = 0;
          v15 = 0;
        }
LABEL_84:
        if (v10 && v9)
        {
          AMFDRErrorPushInternal(a9, 18, (const __CFNumber *)v59, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("trust verification error code=0x%016llX for %@:%@"), v59);
          v71 = theData;
          v72 = v81;
          goto LABEL_90;
        }
        v71 = theData;
        v72 = v81;
LABEL_89:
        AMFDRErrorPushInternal(a9, 18, (const __CFNumber *)v59, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("trust verification error code=0x%016llX"), v59);
LABEL_90:
        v73 = 0;
        v75 = 0;
        v74 = v82;
        if (!v27)
          goto LABEL_92;
        goto LABEL_91;
      }
    }
  }
  v60 = CFGetAllocator((CFTypeRef)a1);
  if ((AMFDRDataStripExtraManifest(v60, v15, (CFTypeRef *)&v92, 0, v11) & 1) == 0)
  {
    AMFDRErrorPushInternal(v11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("AMFDRDataStripExtraManifest failed"), v80);
LABEL_143:
    v50 = 0;
    v49 = 0;
    SikPub = 0;
    goto LABEL_144;
  }
  v61 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("SealingManifest"));
  v62 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("TrustObject"));
  if (v61)
  {
    v63 = CFGetTypeID(v61);
    v64 = v63 == CFDataGetTypeID();
    v10 = v46;
    if (v64)
    {
      *(_QWORD *)&v96 = CFDataGetBytePtr((CFDataRef)v61);
      DWORD2(v96) = CFDataGetLength((CFDataRef)v61);
    }
  }
  if (v62)
  {
    v65 = CFGetTypeID(v62);
    v64 = v65 == CFDataGetTypeID();
    v10 = v46;
    if (v64)
    {
      *(_QWORD *)&v95 = CFDataGetBytePtr((CFDataRef)v62);
      DWORD2(v95) = CFDataGetLength((CFDataRef)v62);
    }
  }
  *(_QWORD *)&v94 = CFDataGetBytePtr(v92);
  DWORD2(v94) = CFDataGetLength(v92);
  *(_QWORD *)&v98 = CFDataGetBytePtr(v27);
  DWORD2(v98) = CFDataGetLength(v27);
  *(_QWORD *)&v99 = CFDataGetBytePtr(theData);
  DWORD2(v99) = CFDataGetLength(theData);
  if (AMFDROptionsGetBooleanValue(a1, CFSTR("CopyAllowUnsealed"), 1)
    && _AMFDRAPTicketHasBooleanEntitlement(a1))
  {
    *(_QWORD *)&v103 = v103 | 2;
  }
  if (AMFDROptionsGetBooleanValue(a1, CFSTR("CopyAllowRawData"), 0))
    *(_QWORD *)&v103 = v103 | 8;
  if (AMFDROptionsGetBooleanValue(a1, CFSTR("CopyAllowOfflineSigning"), 0))
    *(_QWORD *)&v103 = v103 | 0x10;
  if (AMFDROptionsGetBooleanValue(a1, CFSTR("SealingManifestIsMinimal"), 0))
  {
    *(_QWORD *)&v103 = v103 | 0x100;
    v66 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("MinimalSealingDataInstance"));
    if (v66)
    {
      v67 = v66;
      v68 = CFGetAllocator((CFTypeRef)a1);
      v69 = CFStringCreateExternalRepresentation(v68, v67, 0x8000100u, 0x20u);
      v15 = v69;
      if (v69)
      {
        *(_QWORD *)&v108 = CFDataGetBytePtr(v69);
        DWORD2(v108) = CFDataGetLength(v15);
        goto LABEL_71;
      }
      AMFDRErrorPushInternal(v11, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifyInternal", CFSTR("failed to create minimalSealingDataInstanceData"), v80);
      v50 = 0;
      v49 = 0;
      SikPub = 0;
LABEL_145:
      v59 = 2;
      goto LABEL_84;
    }
  }
  v15 = 0;
LABEL_71:
  if (v91 == 2 && !AMFDROptionsGetBooleanValue(a1, CFSTR("AllowVersionMismatch"), 0))
    *(_QWORD *)&v103 = v103 | 0x20;
  if ((_AMFDRDataAllowStagedSealing(a1) & 1) == 0)
    *(_QWORD *)&v103 = v103 | 0x400;
  if (AMFDRIsProtoDevice())
  {
    AMSupportLogInternal();
    *(_QWORD *)&v103 = v103 | 0x4000;
  }
  v59 = AMFDRDecodeTrustEvaluation((uint64_t *)&v94, &length[1], length);
  SikPub = 0;
  v49 = 0;
  v50 = 0;
LABEL_79:
  AMSupportLogInternal();
  if (a8 && *(_QWORD *)&length[1] && length[0])
  {
    v70 = CFGetAllocator((CFTypeRef)a1);
    *a8 = CFDataCreate(v70, *(const UInt8 **)&length[1], length[0]);
  }
  if (v59)
    goto LABEL_84;
  v73 = 1;
  v71 = theData;
  v72 = v81;
  v74 = v82;
LABEL_91:
  CFRelease(v27);
  v75 = v73;
LABEL_92:
  if (v71)
    CFRelease(v71);
  if (cf)
    CFRelease(cf);
  if (SikPub)
    CFRelease(SikPub);
  if (v72)
    CFRelease(v72);
  if (v15)
    CFRelease(v15);
  if (v83)
    CFRelease(v83);
  if (v74)
    CFRelease(v74);
  if (v92)
  {
    CFRelease(v92);
    v92 = 0;
  }
  if (v50)
    CFRelease(v50);
  if (v49)
    CFRelease(v49);
  if (v90)
    free(v90);
  return v75;
}

uint64_t _AMFDRDataAllowStagedSealing(uint64_t a1)
{
  if (AMFDROptionsGetBooleanValue(a1, CFSTR("EnableStagedSealing"), 0))
    return 1;
  if (AMFDRDataIsDiagnosticMode_onceToken != -1)
    dispatch_once(&AMFDRDataIsDiagnosticMode_onceToken, &__block_literal_global_167);
  return AMFDRDataIsDiagnosticMode_result;
}

uint64_t AMFDRDataVerifySealingManifestInternal(uint64_t cf, const __CFData *a2, const __CFString *a3, uint64_t a4)
{
  const __CFAllocator *v8;
  CFDataRef ExternalRepresentation;
  CFDataRef v10;
  const __CFData *v11;
  uint64_t SikPub;
  const __CFString *v13;
  const __CFAllocator *v14;
  uint64_t v15;
  const __CFString *Value;
  const __CFAllocator *v17;
  const __CFData *v18;
  const __CFData *v19;
  const __CFData *v20;
  const __CFData *v21;
  const __CFData *v22;
  const __CFData *v23;
  const __CFNumber *v24;
  uint64_t v25;
  const __CFString *v27;
  const __CFString *v28;
  char v29;
  int v30;
  uint64_t v31;
  int v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v32 = 0;
  v31 = 0;
  v30 = 0;
  if (!cf)
  {
    v27 = CFSTR("amfdr is NULL");
LABEL_41:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifySealingManifestInternal", v27, v29);
    return 0;
  }
  if (!*(_QWORD *)(cf + 16))
  {
    v27 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_41;
  }
  if (!a2)
  {
    v27 = CFSTR("manifestData is NULL");
    goto LABEL_41;
  }
  if (!a3)
  {
    v27 = CFSTR("sealedDataInstance is NULL");
    goto LABEL_41;
  }
  v8 = CFGetAllocator((CFTypeRef)cf);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v8, a3, 0x8000100u, 0x20u);
  if (!ExternalRepresentation)
  {
    AMFDRErrorPushInternal(a4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifySealingManifestInternal", CFSTR("failed to create sealedDataInstanceData"), v29);
    return 0;
  }
  v10 = ExternalRepresentation;
  if ((AMFDRDataGetSigningVersion(cf, &v32) & 1) == 0)
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifySealingManifestInternal", CFSTR("AMFDRDataGetSigningVersion failed"), v29);
LABEL_48:
    CFRelease(v10);
    return 0;
  }
  if (v32 == 2 && !AMFDROptionsGetBooleanValue(cf, CFSTR("SkipVerifySik"), 0))
  {
    SikPub = AMFDRCryptoGetSikPub(cf);
    if (SikPub)
    {
      v13 = (const __CFString *)SikPub;
      v14 = CFGetAllocator((CFTypeRef)cf);
      v11 = CFStringCreateExternalRepresentation(v14, v13, 0x8000100u, 0x20u);
      if (v11)
        goto LABEL_12;
      v28 = CFSTR("Failed to convert sikPub to CFDataRef");
    }
    else
    {
      v28 = CFSTR("sikPub is NULL");
    }
    AMFDRErrorPushInternal(a4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifySealingManifestInternal", v28, v29);
    goto LABEL_48;
  }
  v11 = 0;
LABEL_12:
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v40 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v33 = 0u;
  v15 = 128;
  *(_QWORD *)&v42 = 128;
  if (AMFDROptionsGetBooleanValue(cf, CFSTR("SealingManifestIsMinimal"), 0)
    && (v15 = 384,
        *(_QWORD *)&v42 = 384,
        (Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("MinimalSealingDataInstance"))) != 0))
  {
    v17 = CFGetAllocator((CFTypeRef)cf);
    v18 = CFStringCreateExternalRepresentation(v17, Value, 0x8000100u, 0x20u);
    v19 = v18;
    if (!v18)
    {
      AMFDRErrorPushInternal(a4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifySealingManifestInternal", CFSTR("failed to create minimalSealingDataInstanceData"), v29);
      goto LABEL_30;
    }
    *(_QWORD *)&v47 = CFDataGetBytePtr(v18);
    DWORD2(v47) = CFDataGetLength(v19);
    v15 = 384;
  }
  else
  {
    v19 = 0;
  }
  if (v32 == 2 && !AMFDROptionsGetBooleanValue(cf, CFSTR("AllowVersionMismatch"), 0))
  {
    v15 |= 0x20uLL;
    *(_QWORD *)&v42 = v15;
  }
  if ((_AMFDRDataAllowStagedSealing(cf) & 1) == 0)
    *(_QWORD *)&v42 = v15 | 0x400;
  *(_QWORD *)&v33 = CFDataGetBytePtr(a2);
  DWORD2(v33) = CFDataGetLength(a2);
  *(_QWORD *)&v39 = CFDataGetBytePtr(v10);
  DWORD2(v39) = CFDataGetLength(v10);
  v20 = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("TrustObject"));
  if (v20)
  {
    v21 = v20;
    *(_QWORD *)&v34 = CFDataGetBytePtr(v20);
    DWORD2(v34) = CFDataGetLength(v21);
  }
  v22 = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("TrustObjectDigest"));
  if (v22)
  {
    v23 = v22;
    *(_QWORD *)&v36 = CFDataGetBytePtr(v22);
    DWORD2(v36) = CFDataGetLength(v23);
  }
  if (v11)
  {
    *(_QWORD *)&v40 = CFDataGetBytePtr(v11);
    DWORD2(v40) = CFDataGetLength(v11);
  }
  v24 = (const __CFNumber *)AMFDRDecodeTrustEvaluation((uint64_t *)&v33, &v31, &v30);
  if (!v24)
  {
    v25 = 1;
    goto LABEL_32;
  }
  AMFDRErrorPushInternal(a4, 18, v24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataVerifySealingManifestInternal", CFSTR("trust verification error code=0x%016llX for %@:%@"), (char)v24);
LABEL_30:
  v25 = 0;
LABEL_32:
  CFRelease(v10);
  if (v11)
    CFRelease(v11);
  if (v19)
    CFRelease(v19);
  return v25;
}

uint64_t AMFDRDataCreateCombined(CFDictionaryRef *a1, CFDataRef theData, const __CFData *a3, CFDataRef *a4, uint64_t a5)
{
  const UInt8 *BytePtr;
  unsigned int Length;
  const __CFData *Value;
  const __CFData *v13;
  const UInt8 *v14;
  unsigned int v15;
  UInt8 *v16;
  unsigned int v17;
  unsigned int v18;
  const __CFAllocator *v19;
  CFDataRef v20;
  uint64_t v21;
  const __CFString *v23;
  const __CFString *v24;
  char v25;
  unsigned int v26;
  const UInt8 *v27;
  unsigned int v28;
  const UInt8 *v29;
  unsigned int v30;
  UInt8 *v31;

  v31 = 0;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27 = 0;
  v26 = 0;
  if (!a1)
  {
    v24 = CFSTR("amfdr is NULL");
LABEL_37:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateCombined", v24, v25);
    goto LABEL_38;
  }
  if (!theData)
  {
    v24 = CFSTR("value is NULL");
    goto LABEL_37;
  }
  if (!a4)
  {
    v24 = CFSTR("outValueData is NULL");
    goto LABEL_37;
  }
  v31 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (AMFDRDecodeCombined((uint64_t)BytePtr, Length, &v29, &v28, &v27, &v26))
    goto LABEL_7;
  BytePtr = v27;
  if (!v27)
  {
    v24 = CFSTR("foundData is NULL");
    goto LABEL_37;
  }
  Length = v26;
  if (!v26)
  {
    v24 = CFSTR("foundDataLength is 0");
    goto LABEL_37;
  }
LABEL_7:
  Value = (const __CFData *)CFDictionaryGetValue(a1[2], CFSTR("TrustObject"));
  if (Value)
  {
    v13 = Value;
    v14 = CFDataGetBytePtr(Value);
    v15 = CFDataGetLength(v13);
    if (a3)
      goto LABEL_12;
  }
  else
  {
    v14 = v29;
    v15 = v28;
    if (a3)
      goto LABEL_12;
  }
  a3 = (const __CFData *)CFDictionaryGetValue(a1[2], CFSTR("SealingManifest"));
  if (!a3)
  {
    AMSupportLogInternal();
    v16 = 0;
    v18 = 0;
    if (BytePtr)
      goto LABEL_15;
LABEL_23:
    v23 = CFSTR("valueData is NULL");
LABEL_34:
    AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateCombined", v23, v25);
    goto LABEL_38;
  }
LABEL_12:
  v16 = (UInt8 *)CFDataGetBytePtr(a3);
  v17 = CFDataGetLength(a3);
  if (!v16)
  {
    v23 = CFSTR("sealingManifest is NULL");
    goto LABEL_34;
  }
  v18 = v17;
  if (!v17)
  {
    v23 = CFSTR("sealingManifestLength is 0");
    goto LABEL_34;
  }
  if (!BytePtr)
    goto LABEL_23;
LABEL_15:
  if (!Length)
  {
    v23 = CFSTR("valueDataLength has size of 0");
    goto LABEL_34;
  }
  if (FDREncodeCreateCombinedFast((uint64_t)BytePtr, Length, v16, v18, v14, v15, (char **)&v31, &v30))
  {
    AMFDRErrorPushInternal(a5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateCombined", CFSTR("FDREncodeCreateCombined failed"), v25);
    goto LABEL_38;
  }
  if (!v31)
  {
    v23 = CFSTR("combinedData is NULL");
    goto LABEL_34;
  }
  if (!v30)
  {
    v23 = CFSTR("combinedData has size of 0");
    goto LABEL_34;
  }
  AMSupportSafeRelease();
  v19 = CFGetAllocator(a1);
  v20 = CFDataCreateWithBytesNoCopy(v19, v31, v30, (CFAllocatorRef)*MEMORY[0x24BDBD248]);
  *a4 = v20;
  if (v20)
  {
    v31 = 0;
    v21 = 1;
    goto LABEL_21;
  }
  AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateCombined", CFSTR("*outCombinedData is NULL"), v25);
LABEL_38:
  if (v31)
  {
    free(v31);
    v21 = 0;
    v31 = 0;
  }
  else
  {
    v21 = 0;
  }
LABEL_21:
  AMSupportSafeRelease();
  return v21;
}

uint64_t AMFDRDataErrorIsBenign(uint64_t a1, char a2, CFErrorRef *a3)
{
  uint64_t v3;
  uint64_t v6;
  const __CFDictionary *v7;
  char v8;
  char v10;

  v3 = (uint64_t)a3;
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataErrorIsBenign", CFSTR("amfdr is NULL"), v10);
    return 0;
  }
  if (!a3)
  {
    AMFDRErrorPushInternal(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataErrorIsBenign", CFSTR("outError is NULL"), v10);
    return v3;
  }
  if (!*a3)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataErrorIsBenign", CFSTR("%@ failed but did not return an error"), a2);
    return 0;
  }
  v6 = AMFDRGetUnderlyingErrorCode(a1, a3);
  v7 = CFErrorCopyUserInfo(*(CFErrorRef *)v3);
  if ((AMFDRNonEmptyArrayValueExists(v7, CFSTR("MissingDataInstances")) & 1) == 0
    && (AMFDRNonEmptyArrayValueExists(v7, CFSTR("MissingMultiManifests")) & 1) == 0)
  {
    AMFDRErrorPushInternal(v3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataErrorIsBenign", CFSTR("%@ failed to report what data is missing"), a2);
    goto LABEL_21;
  }
  v8 = AMFDRAllowIncompleteData(a1);
  if (v6 == 20)
    goto LABEL_9;
  if (v6 != 28)
  {
    AMFDRErrorPushInternal(v3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataErrorIsBenign", CFSTR("Failed to recover required data from FDR DataStore with fatal error code: %ld"), v6);
    goto LABEL_21;
  }
  if ((v8 & 1) == 0)
  {
    AMFDRErrorPushInternal(v3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataErrorIsBenign", CFSTR("Required data missing from FDR DataStore but neither 'Allow incomplete data' nor 'Allow unsealed data' is present in AP or Sealing Manifests."), v10);
LABEL_21:
    v3 = 0;
    if (!v7)
      return v3;
    goto LABEL_12;
  }
LABEL_9:
  AMSupportLogInternal();
  if (*(_QWORD *)v3)
  {
    CFRelease(*(CFTypeRef *)v3);
    *(_QWORD *)v3 = 0;
  }
  v3 = 1;
  if (v7)
LABEL_12:
    CFRelease(v7);
  return v3;
}

uint64_t _AMFDRDataClaimInternal(const void *a1, const __CFArray *a2, const __CFArray *a3, const void *a4, const void *a5, const __CFArray *a6, const __CFArray *a7, CFTypeRef *a8)
{
  const __CFAllocator *v15;
  const __CFAllocator *v16;
  const __CFAllocator *v17;
  CFMutableArrayRef v18;
  __CFArray *v19;
  const __CFAllocator *v20;
  CFMutableArrayRef v21;
  __CFArray *v22;
  const __CFAllocator *v23;
  const __CFAllocator *v24;
  CFMutableDictionaryRef v25;
  __CFString *v26;
  __CFString *v27;
  const __CFString *v28;
  CFIndex Count;
  CFIndex v30;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const __CFString *v33;
  const __CFString *v34;
  CFIndex v35;
  CFIndex v36;
  CFIndex v37;
  const void *v38;
  const __CFString *PermissionsString;
  const __CFString *v40;
  const __CFString *v41;
  const __CFString *v42;
  CFTypeRef v43;
  const __CFString *v44;
  uint64_t v45;
  const __CFString *format;
  char v48;
  const void *v49;
  const void *v50;
  CFTypeRef cf;
  __CFDictionary *v52;
  CFTypeRef *v53;
  __CFArray *Mutable;
  CFMutableStringRef v55;
  __CFArray *theArray;
  int v58;
  CFTypeRef v59[2];
  CFRange v60;
  CFRange v61;

  v59[0] = 0;
  v15 = CFGetAllocator(a1);
  theArray = CFArrayCreateMutable(v15, 0, MEMORY[0x24BDBD690]);
  if (!theArray)
  {
    format = CFSTR("dataClassesToReq is NULL");
LABEL_66:
    AMFDRErrorPushInternal((uint64_t)a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataClaimInternal", format, v48);
    v38 = 0;
    v25 = 0;
LABEL_67:
    v27 = 0;
    goto LABEL_73;
  }
  v16 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v16, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    format = CFSTR("dataInstancesToReq is NULL");
    goto LABEL_66;
  }
  v17 = CFGetAllocator(a1);
  v18 = CFArrayCreateMutable(v17, 0, MEMORY[0x24BDBD690]);
  if (!v18)
  {
    format = CFSTR("dataClassesChallengeClaim is NULL");
    goto LABEL_66;
  }
  v19 = v18;
  v50 = a4;
  v20 = CFGetAllocator(a1);
  v21 = CFArrayCreateMutable(v20, 0, MEMORY[0x24BDBD690]);
  if (!v21)
  {
    format = CFSTR("dataInstancesChallengeClaim is NULL");
    goto LABEL_66;
  }
  v22 = v21;
  v23 = CFGetAllocator(a1);
  v55 = CFStringCreateMutable(v23, 0);
  if (!v55)
  {
    format = CFSTR("claimPermissions is NULL");
    goto LABEL_66;
  }
  v24 = CFGetAllocator(a1);
  v25 = CFDictionaryCreateMutable(v24, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v25)
  {
    AMFDRErrorPushInternal((uint64_t)a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataClaimInternal", CFSTR("claimOptions is NULL"), v48);
    v38 = 0;
    goto LABEL_67;
  }
  cf = a1;
  v26 = (__CFString *)AMFDRCreateCopy((uint64_t)a1);
  v27 = v26;
  if (!v26)
  {
    AMFDRErrorPushInternal((uint64_t)a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataClaimInternal", CFSTR("cannot create a separate amfdr object for data claiming"), v48);
    v38 = 0;
    goto LABEL_73;
  }
  v49 = a5;
  v52 = v25;
  v53 = a8;
  v28 = (const __CFString *)*MEMORY[0x24BDBD268];
  AMFDRSetOption((uint64_t)v26, CFSTR("PersistCertificate"), (const __CFString *)*MEMORY[0x24BDBD268]);
  AMFDRSetOption((uint64_t)v27, CFSTR("GetCombined"), v28);
  AMFDRSetOption((uint64_t)v27, CFSTR("PutCombined"), v28);
  AMFDRSetOption((uint64_t)v27, CFSTR("VerifyData"), v28);
  AMFDRSetOption((uint64_t)v27, CFSTR("SignData"), v28);
  Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    v30 = Count;
    for (i = 0; v30 != i; ++i)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, i);
      v60.length = CFArrayGetCount(a7);
      v60.location = 0;
      if (CFArrayContainsValue(a7, v60, ValueAtIndex))
      {
        v33 = (const __CFString *)CFArrayGetValueAtIndex(a3, i);
        if (!v33)
          goto LABEL_54;
        v34 = v33;
        if (a6 && (v61.length = CFArrayGetCount(a6), v61.location = 0, CFArrayContainsValue(a6, v61, ValueAtIndex)))
        {
          CFArrayAppendValue(v19, ValueAtIndex);
          CFArrayAppendValue(v22, v34);
        }
        else
        {
          CFArrayAppendValue(theArray, ValueAtIndex);
          CFArrayAppendValue(Mutable, v34);
          if ((AMFDRDataAppendPermissionsString(v27, 0xAu, ValueAtIndex, v34, v55) & 1) == 0)
          {
            a8 = v53;
            AMFDRErrorPushInternal((uint64_t)v53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataClaimInternal", CFSTR("AMFDRDataAppendPermissionsString failed"), (char)v49);
            goto LABEL_59;
          }
        }
      }
    }
  }
  if (CFArrayGetCount(v19) < 1 || (v35 = CFArrayGetCount(v19), v35 < 1))
  {
    v38 = 0;
LABEL_31:
    if (CFArrayGetCount(theArray) < 1)
    {
      AMSupportLogInternal();
      v25 = v52;
      a8 = v53;
      goto LABEL_43;
    }
    v58 = 2;
    v25 = v52;
    a8 = v53;
    if ((AMFDRDataGetSigningVersion((uint64_t)v27, &v58) & 1) != 0)
    {
      if (v58 == 1)
        AMFDRSetOption((uint64_t)v27, CFSTR("OrganizationalUnit"), CFSTR("Devices - Stations"));
      AMFDRSetOption((uint64_t)v27, CFSTR("Permissions"), v55);
      if ((AMFDRPermissionsRequest((uint64_t)v27, v53) & 1) == 0)
      {
        v44 = CFSTR("Permissions request failed.");
        goto LABEL_72;
      }
      if (v50)
        CFDictionarySetValue(v52, CFSTR("DeviceOnlySigningDataClasses"), v50);
      if (v49)
        CFDictionarySetValue(v52, CFSTR("ServerOnlySigningDataClasses"), v49);
      if ((AMFDRDataMultiClaimWithOptions((uint64_t)v27, v52, theArray, Mutable, 0, (uint64_t)v53) & 1) == 0)
      {
        v44 = CFSTR("AMFDRDataMultiClaimWithOptions failed");
LABEL_72:
        AMFDRErrorPushInternal((uint64_t)v53, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataClaimInternal", v44, (char)v49);
        goto LABEL_73;
      }
LABEL_43:
      AMFDRSetOption((uint64_t)cf, CFSTR("ClaimDataClasses"), 0);
      v45 = 1;
      goto LABEL_44;
    }
    AMFDRErrorPushInternal((uint64_t)v53, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataClaimInternal", CFSTR("AMFDRDataGetSigningVersion failed"), (char)v49);
LABEL_73:
    v45 = 0;
    goto LABEL_44;
  }
  v36 = v35;
  v37 = 0;
  v38 = 0;
  PermissionsString = 0;
  while (1)
  {
    if (v38)
      CFRelease(v38);
    if (PermissionsString)
      CFRelease(PermissionsString);
    v40 = (const __CFString *)CFArrayGetValueAtIndex(v19, v37);
    v41 = (const __CFString *)CFArrayGetValueAtIndex(v22, v37);
    if (!v41)
      break;
    v42 = v41;
    AMSupportLogInternal();
    PermissionsString = AMFDRDataCreatePermissionsString(v27, 8u, v40, v42);
    if (!PermissionsString)
    {
      a8 = v53;
      AMFDRErrorPushInternal((uint64_t)v53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataClaimInternal", CFSTR("AMFDRDataCreatePermissionsString failed"), (char)v49);
      goto LABEL_59;
    }
    AMFDRSetOption((uint64_t)v27, CFSTR("Permissions"), PermissionsString);
    v43 = AMFDRDataHTTPChallengeClaim((uint64_t)v27, v40, v42, v59);
    v38 = v43;
    if (v59[0])
    {
      AMFDRErrorPushInternal((uint64_t)v59, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataClaimInternal", CFSTR("AMFDRDataHTTPChallengeClaim failed"), (char)v49);
      v45 = 0;
      v25 = v52;
      a8 = v53;
      goto LABEL_44;
    }
    if (!v43)
    {
      a8 = v53;
      AMFDRErrorPushInternal((uint64_t)v53, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataClaimInternal", CFSTR("responseClaimData is NULL"), (char)v49);
      goto LABEL_60;
    }
    if (v36 == ++v37)
      goto LABEL_31;
  }
LABEL_54:
  a8 = v53;
  AMFDRErrorPushInternal((uint64_t)v53, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataClaimInternal", CFSTR("malformed dataInstanceArray"), (char)v49);
LABEL_59:
  v38 = 0;
LABEL_60:
  v45 = 0;
  v25 = v52;
LABEL_44:
  if (a8 && v59[0])
    *a8 = CFRetain(v59[0]);
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (v38)
    CFRelease(v38);
  if (v25)
    CFRelease(v25);
  if (v27)
    CFRelease(v27);
  return v45;
}

uint64_t AMFDRDataAddDataClassesToClaim(CFDictionaryRef *a1, const __CFArray *cf)
{
  CFTypeID v4;
  const __CFArray *Value;
  const __CFAllocator *v6;
  CFMutableArrayRef Mutable;
  const __CFArray *v8;
  CFIndex v9;
  const void *ValueAtIndex;
  CFRange v12;

  if (a1
    && a1[2]
    && cf
    && (v4 = CFGetTypeID(cf), v4 == CFArrayGetTypeID())
    && ((Value = (const __CFArray *)CFDictionaryGetValue(a1[2], CFSTR("ClaimDataClasses")),
         v6 = CFGetAllocator(a1),
         !Value)
      ? (Mutable = CFArrayCreateMutable(v6, 0, MEMORY[0x24BDBD690]))
      : (Mutable = CFArrayCreateMutableCopy(v6, 0, Value)),
        (v8 = Mutable) != 0))
  {
    if (CFArrayGetCount(cf) >= 1)
    {
      v9 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(cf, v9);
        v12.length = CFArrayGetCount(v8);
        v12.location = 0;
        if (!CFArrayContainsValue(v8, v12, ValueAtIndex))
          CFArrayAppendValue(v8, ValueAtIndex);
        ++v9;
      }
      while (v9 < CFArrayGetCount(cf));
    }
    AMFDRSetOption((uint64_t)a1, CFSTR("ClaimDataClasses"), (const __CFString *)v8);
    CFRelease(v8);
    return 1;
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
}

uint64_t AMFDRDataRecover(const void *a1, uint64_t a2, const void *a3, const void *a4, CFTypeRef cf, const void *a6, int a7, CFTypeRef *a8, uint64_t a9)
{
  CFTypeID v16;
  CFTypeID v17;
  CFIndex Count;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  const __CFString *v23;
  const __CFString *v24;
  char v25;

  if (!a1)
  {
    v23 = CFSTR("amfdrLocal is NULL");
LABEL_21:
    AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataRecover", v23, v25);
    return 0;
  }
  if (!a2)
  {
    v23 = CFSTR("amfdrRemote is NULL");
    goto LABEL_21;
  }
  if (!cf)
  {
    v23 = CFSTR("dataClassArray is NULL");
    goto LABEL_21;
  }
  if (!a6)
  {
    v23 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_21;
  }
  v16 = CFGetTypeID(cf);
  if (v16 != CFArrayGetTypeID())
  {
    v23 = CFSTR("dataClassArray must be a CFArrayRef");
    goto LABEL_21;
  }
  v17 = CFGetTypeID(a6);
  if (v17 != CFArrayGetTypeID())
  {
    v23 = CFSTR("dataInstanceArray must be a CFArrayRef");
    goto LABEL_21;
  }
  Count = CFArrayGetCount((CFArrayRef)cf);
  if (Count != CFArrayGetCount((CFArrayRef)a6))
  {
    v25 = CFArrayGetCount((CFArrayRef)cf);
    CFArrayGetCount((CFArrayRef)a6);
    v23 = CFSTR("dataClassArray length (%ld) does not match dataInstanceArray (%ld)");
    goto LABEL_21;
  }
  CFGetAllocator(a1);
  AMFDRSealedDataCreate();
  if (!v19)
  {
    AMFDRErrorPushInternal(a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataRecover", CFSTR("Failed to create sealedData. Data Recovery failed."), v25);
    return 0;
  }
  v20 = v19;
  if ((AMFDRSealedDataSetDataClassInstance(v19, a3, a4, cf, a6, a9) & 1) == 0)
  {
    v24 = CFSTR("AMFDRSealedDataSetDataClassInstance failed");
LABEL_26:
    AMFDRErrorPushInternal(a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataRecover", v24, v25);
    v21 = 0;
    goto LABEL_12;
  }
  if ((AMFDRSealingMapConfigSealedData(v20, a1, a9) & 1) == 0)
  {
    v24 = CFSTR("AMFDRSealingMapConfigSealedData failed.");
    goto LABEL_26;
  }
  v21 = AMFDRSealedDataRecover((uint64_t)v20, (uint64_t)a1, a2, 1, a8, a9);
LABEL_12:
  CFRelease(v20);
  return v21;
}

uint64_t _AMFDRCopySealingManifestObjectTag(const void *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4, int a5)
{
  const __CFDictionary *v8;
  const __CFData *Value;
  const __CFData *v10;
  __int128 v11;
  uint64_t result;
  const __CFAllocator *v13;
  CFNumberRef v14;
  CFNumberRef v15;
  uint64_t valuePtr;
  CFIndex v17;
  const UInt8 *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  unint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  valuePtr = 0;
  if (!a1)
    goto LABEL_11;
  if (!a2)
    goto LABEL_11;
  if (!a3)
    goto LABEL_11;
  if (!a4)
    goto LABEL_11;
  v8 = (const __CFDictionary *)AMFDRGetOptions((uint64_t)a1);
  if (!v8)
    goto LABEL_11;
  Value = (const __CFData *)CFDictionaryGetValue(v8, CFSTR("SealingManifest"));
  if (!Value)
    goto LABEL_11;
  v10 = Value;
  v47 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v45 = v11;
  v46 = v11;
  v43 = v11;
  v44 = v11;
  v41 = v11;
  v42 = v11;
  v39 = v11;
  v40 = v11;
  v37 = v11;
  v38 = v11;
  v35 = v11;
  v36 = v11;
  v33 = v11;
  v34 = v11;
  v31 = v11;
  v32 = v11;
  v29 = v11;
  v30 = v11;
  v27 = v11;
  v28 = v11;
  v26 = v11;
  v24 = v11;
  v25 = v11;
  v22 = v11;
  v23 = v11;
  v20 = v11;
  v21 = v11;
  v19 = v11;
  v17 = 0xAAAAAAAAAAAAAAAALL;
  v18 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
  CFDataGetBytePtr(Value);
  CFDataGetLength(v10);
  if (Img4DecodeInitManifest())
    goto LABEL_11;
  if (a5)
  {
    result = Img4DecodeGetObjectPropertyInteger64();
    if ((_DWORD)result)
      goto LABEL_10;
LABEL_13:
    v13 = CFGetAllocator(a1);
    if (a5)
      v14 = CFNumberCreate(v13, kCFNumberSInt64Type, &valuePtr);
    else
      v14 = CFDataCreate(v13, v18, v17);
    v15 = v14;
    if (!v14)
      goto LABEL_11;
    *a4 = CFRetain(v14);
    CFRelease(v15);
    return 1;
  }
  result = Img4DecodeGetObjectPropertyData();
  if (!(_DWORD)result)
    goto LABEL_13;
LABEL_10:
  if ((_DWORD)result != 1)
  {
LABEL_11:
    AMSupportLogInternal();
    return 0;
  }
  return result;
}

uint64_t AMFDRDataCopySealingManifestProperty(const void *a1, const __CFString *a2, uint64_t a3)
{
  return _AMFDRDataCopySealingManifestPropertyInternal(a1, a2, 0, a3);
}

uint64_t _AMFDRDataCopySealingManifestPropertyInternal(const void *a1, const __CFString *a2, int a3, uint64_t a4)
{
  uint64_t v5;
  const __CFAllocator *v8;
  const __CFData *ExternalRepresentation;
  const __CFData *v10;
  unsigned int *BytePtr;
  unsigned int v12;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
    goto LABEL_16;
  v5 = a4;
  if (!a4)
  {
    AMSupportLogInternal();
    return v5;
  }
  v8 = CFGetAllocator(a1);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v8, a2, 0x8000100u, 0x5Fu);
  if (!ExternalRepresentation)
  {
LABEL_16:
    AMSupportLogInternal();
    return 0;
  }
  v10 = ExternalRepresentation;
  if (CFDataGetLength(ExternalRepresentation) == 4
    && (BytePtr = (unsigned int *)CFDataGetBytePtr(v10),
        v12 = AMFDRTagsStringToTag(BytePtr),
        (_AMFDRCopySealingManifestObjectTag(a1, 1296125520, v12, &cf, a3) & 1) != 0))
  {
    if (cf)
      *(_QWORD *)v5 = CFRetain(cf);
    v5 = 1;
  }
  else
  {
    AMSupportLogInternal();
    v5 = 0;
  }
  CFRelease(v10);
  if (cf)
    CFRelease(cf);
  return v5;
}

uint64_t AMFDRDataCopySealingManifestIntegerProperty(const void *a1, const __CFString *a2, uint64_t a3)
{
  return _AMFDRDataCopySealingManifestPropertyInternal(a1, a2, 1, a3);
}

uint64_t AMFDRDataAddSealingPropertiesOverride(CFDictionaryRef *a1, const __CFDictionary *cf)
{
  CFTypeID v4;
  const __CFDictionary *Value;
  const __CFAllocator *v6;
  __CFDictionary *Mutable;
  const __CFString *v8;

  if (a1
    && a1[2]
    && cf
    && (v4 = CFGetTypeID(cf), v4 == CFDictionaryGetTypeID())
    && ((Value = (const __CFDictionary *)CFDictionaryGetValue(a1[2], CFSTR("SealingPropertiesOverride")),
         v6 = CFGetAllocator(a1),
         !Value)
      ? (Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]))
      : (Mutable = CFDictionaryCreateMutableCopy(v6, 0, Value)),
        (v8 = (const __CFString *)Mutable) != 0))
  {
    _CFDictionaryAddDictionary(Mutable, cf);
    AMFDRSetOption((uint64_t)a1, CFSTR("SealingPropertiesOverride"), v8);
    CFRelease(v8);
    return 1;
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
}

uint64_t AMFDRWriteDataToFileURL(CFTypeRef cf, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;

  if (!cf)
  {
    v4 = 1;
    goto LABEL_14;
  }
  v4 = 1;
  if (a3 && a2 && *((_QWORD *)cf + 2))
  {
    if (a4)
    {
      if (AMSupportRemoveFile())
      {
        v4 = 4;
        AMSupportLogInternal();
        goto LABEL_14;
      }
    }
    else
    {
      CFGetAllocator(cf);
      if (AMSupportCopyPreserveFileURL())
      {
        v4 = 4;
        goto LABEL_18;
      }
    }
    if (AMFDROptionsGetBooleanValue((uint64_t)cf, CFSTR("WriteUncached"), 0))
    {
      if (AMSupportPlatformWriteDataToFileURLUncached())
      {
        v4 = 4;
LABEL_18:
        AMSupportLogInternal();
        goto LABEL_14;
      }
    }
    else if (AMSupportPlatformWriteDataToFileURL())
    {
      v4 = 4;
      goto LABEL_18;
    }
    v4 = 0;
  }
LABEL_14:
  AMSupportSafeRelease();
  return v4;
}

CFArrayRef AMFDRDataCopySslRoots(const __CFAllocator *a1, CFDataRef theData, uint64_t a3)
{
  const UInt8 *BytePtr;
  unsigned int Length;
  uint64_t v8;
  __CFArray *Mutable;
  uint64_t v10;
  CFDataRef v11;
  CFDataRef v12;
  CFArrayRef Copy;
  char v15;
  _OWORD v16[9];
  unsigned int v17;
  const UInt8 *v18;

  memset(v16, 0, sizeof(v16));
  if (!theData)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopySslRoots", CFSTR("trustObjectData is NULL"), v15);
    return 0;
  }
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v8 = AMFDRDecodeTrustObject(v16, (uint64_t)BytePtr, Length);
  if (v8)
  {
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopySslRoots", CFSTR("Could not decode trust object (decodestatus=%llu)"), v8);
    return 0;
  }
  v18 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
  v17 = -1431655766;
  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x24BDBD690]);
  if (!AMFDRDecodeIterateTrustObjectSslRootBegin((uint64_t)v16))
  {
    while (1)
    {
      v10 = AMFDRDecodeIterateTrustObjectSslRootNext((uint64_t)v16, &v18, &v17);
      if (v10 || !v18 || !v17)
        break;
      v11 = CFDataCreate(a1, v18, v17);
      if (!v11)
        goto LABEL_16;
      v12 = v11;
      CFArrayAppendValue(Mutable, v11);
      CFRelease(v12);
    }
    if (!v10 && CFArrayGetCount(Mutable) > 0)
    {
      Copy = CFArrayCreateCopy(a1, Mutable);
      if (!Mutable)
        goto LABEL_13;
      goto LABEL_12;
    }
  }
LABEL_16:
  AMSupportLogInternal();
  Copy = 0;
  if (Mutable)
LABEL_12:
    CFRelease(Mutable);
LABEL_13:
  if (!Copy)
    AMFDRErrorPushInternal(a3, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopySslRoots", CFSTR("No SSL Root found in trust object"), v15);
  return Copy;
}

CFTypeRef AMFDRDataInstanceCopyNonSik(const void *a1, CFStringRef theString)
{
  CFTypeRef v2;
  const __CFAllocator *v4;
  __CFString *Mutable;
  const __CFAllocator *v6;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  uint64_t v11;
  uint64_t i;
  const __CFString *ValueAtIndex;

  v2 = a1;
  if (!a1)
  {
    AMSupportLogInternal();
    goto LABEL_12;
  }
  if (!theString)
    goto LABEL_14;
  if (!CFStringHasPrefix(theString, CFSTR("sik-")))
  {
    v2 = CFRetain(theString);
    goto LABEL_12;
  }
  v4 = CFGetAllocator(v2);
  Mutable = CFStringCreateMutable(v4, 0);
  v6 = CFGetAllocator(v2);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v6, theString, CFSTR("-"));
  v8 = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings)
  {
LABEL_14:
    AMSupportLogInternal();
    v2 = 0;
    goto LABEL_12;
  }
  Count = CFArrayGetCount(ArrayBySeparatingStrings);
  if (Count >= 3)
  {
    v10 = Count;
    v11 = Count - 2;
    for (i = 2; i != v10; ++i)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, i - 1);
      CFStringAppend(Mutable, ValueAtIndex);
      if (i - 1 < v11)
        CFStringAppend(Mutable, CFSTR("-"));
    }
  }
  v2 = CFRetain(Mutable);
LABEL_12:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v2;
}

uint64_t AMFDRDataDecodeAndSetSealingManifest(_QWORD *a1, CFDataRef theData, uint64_t a3, CFTypeRef *a4, CFTypeRef *a5, uint64_t a6)
{
  uint64_t BytePtr;
  unsigned int Length;
  unsigned int v14;
  const __CFAllocator *v15;
  const __CFDictionary *Mutable;
  const __CFAllocator *v17;
  CFMutableDictionaryRef v18;
  const __CFDictionary *v19;
  const __CFAllocator *v20;
  uint64_t FullKey;
  const __CFString *v22;
  CFStringRef v23;
  const __CFString *v24;
  __CFDictionary *v25;
  CFTypeID v26;
  CFTypeID TypeID;
  CFTypeID v28;
  const __CFAllocator *v29;
  CFTypeID v30;
  CFIndex v31;
  const void *v32;
  CFTypeRef *v33;
  const void *ValueAtIndex;
  const void *v35;
  const __CFAllocator *v36;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  char v42;
  CFTypeRef *v43;
  uint64_t v44;
  char v45;
  CFTypeRef cf;
  CFTypeRef v47;
  void *v48;
  CFTypeRef v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v48 = 0;
  v49 = 0;
  cf = 0;
  v47 = 0;
  if (!a1)
  {
    v38 = CFSTR("amfdr is NULL");
LABEL_73:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", v38, v42);
LABEL_77:
    v32 = 0;
    v25 = 0;
    v22 = 0;
    BytePtr = 0;
    goto LABEL_54;
  }
  if (!a1[2])
  {
    v39 = CFSTR("amfdr option is NULL");
LABEL_76:
    AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", v39, v42);
    goto LABEL_77;
  }
  if (!theData)
  {
    v38 = CFSTR("rawManifestData is NULL");
    goto LABEL_73;
  }
  BytePtr = (uint64_t)CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (!BytePtr)
  {
    AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", CFSTR("sealingManifest is NULL"), v42);
    v32 = 0;
    v25 = 0;
    v22 = 0;
    goto LABEL_54;
  }
  v14 = Length;
  if (!Length)
  {
    v39 = CFSTR("sealingManifestLength is 0");
    goto LABEL_76;
  }
  v44 = a6;
  if (!AMFDRDecodeManifestBody(&v48))
  {
    v22 = (const __CFString *)CFRetain(theData);
    v23 = 0;
    Mutable = 0;
    v19 = 0;
    goto LABEL_19;
  }
  v45 = 0;
  v50 = 0u;
  v51 = 0u;
  v15 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v15, kAMFDRDefaultMultiSealingMaxRequest, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", CFSTR("multiSealingRequestErrors is NULL"), v42);
    v23 = 0;
    v19 = 0;
LABEL_91:
    BytePtr = 0;
    v22 = 0;
    v25 = 0;
    goto LABEL_92;
  }
  v17 = CFGetAllocator(a1);
  v18 = CFDictionaryCreateMutable(v17, kAMFDRDefaultMultiSealingMaxRequest, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v19 = v18;
  if (!v18)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", CFSTR("valueDataDict is NULL"), v42);
LABEL_87:
    v23 = 0;
    goto LABEL_91;
  }
  *(_QWORD *)&v50 = a1;
  *((_QWORD *)&v50 + 1) = v18;
  *(_QWORD *)&v51 = Mutable;
  *((_QWORD *)&v51 + 1) = &v49;
  if (AMFDRDecodeMultiSealingResponse(BytePtr, v14, &v45, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t))_AMFDRHttpMultiSealingCallback, (uint64_t)&v50))
  {
    v41 = CFSTR("AMFDRDecodeMultiResponse failed");
LABEL_86:
    AMFDRErrorPushInternal(a6, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", v41, v42);
    goto LABEL_87;
  }
  if (v45 != kAMFDRHTTPMultiRequestActionSealing)
  {
    v42 = v45;
    v41 = CFSTR("actionCode returned is %d");
    goto LABEL_86;
  }
  if (a3)
  {
    v20 = CFGetAllocator(a1);
    FullKey = (uint64_t)AMFDRDataLocalCreateFullKey(v20, (uint64_t)CFSTR("sreq"), a3);
  }
  else
  {
    FullKey = AMSupportSafeRetain();
  }
  v23 = (CFStringRef)FullKey;
  if (!FullKey)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", CFSTR("failed to create data instancestring"), v42);
    goto LABEL_91;
  }
  if (CFDictionaryGetCount(Mutable))
  {
    AMFDRErrorPushInternal(a6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", CFSTR("Unexpected multi-sealing error from server: %@"), (char)Mutable);
    goto LABEL_91;
  }
  v24 = (const __CFString *)_CFDictionaryCopyValue(v19, v23);
  if (!v24)
  {
    AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", CFSTR("mainManifest is NULL"), v42);
    goto LABEL_91;
  }
  v22 = v24;
LABEL_19:
  AMFDRSetOption((uint64_t)a1, CFSTR("SealingManifest"), v22);
  v25 = 0;
  if (!_AMFDRDataCopySealingManifestPropertyInternal(a1, CFSTR("meta"), 0, (uint64_t)&cf)
    || !cf
    || (v26 = CFGetTypeID(cf), TypeID = CFDataGetTypeID(), v25 = 0, !v19)
    || v26 != TypeID)
  {
    v32 = 0;
    if (a4)
      goto LABEL_43;
    goto LABEL_45;
  }
  v28 = CFGetTypeID(v19);
  if (v28 != CFDictionaryGetTypeID())
  {
    v25 = 0;
    goto LABEL_42;
  }
  v29 = CFGetAllocator(a1);
  v25 = CFDictionaryCreateMutable(v29, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v25)
  {
    if (AMFDRDataDecodeMetaProperty((const __CFData *)cf, &v47))
    {
      if (v47)
      {
        v30 = CFGetTypeID(v47);
        if (v30 == CFArrayGetTypeID())
        {
          v43 = a4;
          if (CFArrayGetCount((CFArrayRef)v47) >= 1)
          {
            v31 = 0;
            v32 = 0;
            while (1)
            {
              if (v32)
                CFRelease(v32);
              v33 = a5;
              if (v23)
                CFRelease(v23);
              ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v47, v31);
              if (!ValueAtIndex)
              {
                AMFDRErrorPushInternal(v44, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", CFSTR("dataInstance is NULL"), v42);
                BytePtr = 0;
                v23 = 0;
                goto LABEL_92;
              }
              v35 = ValueAtIndex;
              v36 = CFGetAllocator(a1);
              v23 = AMFDRDataLocalCreateFullKey(v36, (uint64_t)CFSTR("minimal-manifest"), (uint64_t)v35);
              if (!v23)
              {
                v40 = CFSTR("failed to create data instancestring for minimal manifest");
                goto LABEL_80;
              }
              v32 = _CFDictionaryCopyValue(v19, v23);
              if (!v32)
                break;
              CFDictionarySetValue(v25, v35, v32);
              ++v31;
              a5 = v33;
              if (v31 >= CFArrayGetCount((CFArrayRef)v47))
                goto LABEL_68;
            }
            AMFDRErrorPushInternal(v44, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", CFSTR("%@:%@ is NULL"), (char)CFSTR("minimal-manifest"));
            BytePtr = 0;
            goto LABEL_48;
          }
          v32 = 0;
LABEL_68:
          AMSupportLogInternal();
          AMFDRSetOption((uint64_t)a1, CFSTR("MinimalSealingManifests"), (const __CFString *)v25);
          a4 = v43;
          if (!v43)
            goto LABEL_45;
          goto LABEL_43;
        }
      }
LABEL_42:
      v32 = 0;
      if (a4)
      {
LABEL_43:
        if (v22)
          *a4 = CFRetain(v22);
      }
LABEL_45:
      BytePtr = 1;
      if (a5 && v19)
        *a5 = CFRetain(v19);
      goto LABEL_48;
    }
    v40 = CFSTR("AMFDRDataDecodeMetaProperty failed");
  }
  else
  {
    v40 = CFSTR("minimalManifests create failed");
  }
LABEL_80:
  AMFDRErrorPushInternal(v44, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDecodeAndSetSealingManifest", v40, v42);
  BytePtr = 0;
LABEL_92:
  v32 = 0;
LABEL_48:
  if (Mutable)
    CFRelease(Mutable);
  if (v19)
    CFRelease(v19);
  if (v23)
    CFRelease(v23);
LABEL_54:
  if (v49)
  {
    CFRelease(v49);
    v49 = 0;
  }
  if (v22)
    CFRelease(v22);
  if (v25)
    CFRelease(v25);
  if (v47)
  {
    CFRelease(v47);
    v47 = 0;
  }
  if (v32)
    CFRelease(v32);
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  AMFDRDecodeManifestBodyDestroy(v48);
  return BytePtr;
}

BOOL AMFDRDataDecodeMetaProperty(const __CFData *a1, CFTypeRef *a2)
{
  const UInt8 *BytePtr;
  unsigned int Length;
  uint64_t v6;
  _BOOL8 v7;
  CFMutableArrayRef cf;

  cf = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  if (cf)
  {
    BytePtr = CFDataGetBytePtr(a1);
    Length = CFDataGetLength(a1);
    v6 = AMFDRDecodeMetaProperty((uint64_t)BytePtr, Length, (uint64_t (*)(_QWORD))AMFDRDataDecodeMetaPropertyCallback);
    v7 = v6 == 0;
    if (v6)
    {
      AMSupportLogInternal();
    }
    else if (a2)
    {
      *a2 = CFRetain(cf);
    }
    CFRelease(cf);
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
  return v7;
}

CFDataRef AMFDRDataCreateSikPubDigestIfNecessary(CFAllocatorRef allocator, UInt8 *bytes, unint64_t length)
{
  UInt8 *v4;
  UInt8 *v5;
  CFDataRef result;

  if (length < 0x42)
    return CFDataCreate(allocator, bytes, length);
  v4 = (UInt8 *)malloc_type_calloc(1uLL, 0x30uLL, 0xD972C054uLL);
  if (v4)
  {
    v5 = v4;
    if (AMSupportDigestSha384())
    {
      AMSupportLogInternal();
    }
    else
    {
      result = CFDataCreateWithBytesNoCopy(allocator, v5, 48, (CFAllocatorRef)*MEMORY[0x24BDBD248]);
      if (result)
        return result;
    }
    free(v5);
  }
  else
  {
    AMSupportLogInternal();
  }
  return 0;
}

uint64_t AMFDRDataDecodeMetaPropertyCallback(int a1, const UInt8 *a2, CFIndex numBytes, const UInt8 *a4, unsigned int a5, CFMutableArrayRef *a6)
{
  uint64_t v6;
  const __CFAllocator *v10;
  CFStringRef v11;
  CFStringRef v12;
  CFStringRef v13;
  CFStringRef v14;
  CFTypeID v15;
  CFStringRef v16;

  if (!a6)
    goto LABEL_16;
  if (!a1)
  {
    if (a2)
    {
      v10 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      v11 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], a2, numBytes, 0x8000100u, 0);
      if (!v11)
      {
        AMSupportLogInternal();
        return 2;
      }
      v12 = v11;
      if (a4)
      {
        v13 = CFStringCreateWithBytes(v10, a4, a5, 0x8000100u, 0);
        if (v13)
        {
          v14 = v13;
          if (*a6 && (v15 = CFGetTypeID(*a6), v15 == CFArrayGetTypeID()))
          {
            CFArrayAppendValue(*a6, v14);
            v6 = 0;
          }
          else
          {
            AMSupportLogInternal();
            v6 = 2;
          }
          CFRelease(v12);
          v16 = v14;
          goto LABEL_12;
        }
        v6 = 2;
      }
      else
      {
        v6 = 1;
      }
      AMSupportLogInternal();
      v16 = v12;
LABEL_12:
      CFRelease(v16);
      return v6;
    }
LABEL_16:
    AMSupportLogInternal();
    return 1;
  }
  return 0;
}

uint64_t AMFDRDataPutForRestore(const __CFString *a1, const __CFString *a2, const __CFData *a3, const __CFDictionary *a4, uint64_t a5)
{
  const __CFString *v8;
  const __CFString *v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  CFTypeID v13;
  const __CFAllocator *v14;
  CFDictionaryRef *v15;
  CFDictionaryRef *v16;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v18;
  const __CFNumber *v19;
  const __CFNumber *v20;
  CFTypeID v21;
  const void **v22;
  const __CFString *v23;
  uint64_t v24;
  const __CFString *v26;
  char v27;
  int valuePtr;

  valuePtr = 1;
  if (!a1)
  {
    v26 = CFSTR("dataClass is NULL");
LABEL_49:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPutForRestore", v26, v27);
    return 0;
  }
  if (!a3)
  {
    v26 = CFSTR("valueData is NULL");
    goto LABEL_49;
  }
  v8 = a2;
  if (a2)
  {
    v10 = 0;
    goto LABEL_6;
  }
  v8 = (const __CFString *)AMFDRSealingMapCopyInstanceForClass(a1, a5);
  v10 = v8;
  if (!v8)
  {
    v26 = CFSTR("failed to query dataInstance");
    goto LABEL_49;
  }
LABEL_6:
  v11 = (const __CFDictionary *)AMFDRGetRestorePeriodOptions();
  v12 = v11;
  if (v11)
  {
    v13 = CFGetTypeID(v11);
    if (v13 != CFDictionaryGetTypeID())
    {
      AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPutForRestore", CFSTR("fdrRestoreOptions is malformed"), v27);
LABEL_46:
      v18 = 0;
      v23 = 0;
      v20 = 0;
      v24 = 0;
      if (!v10)
        goto LABEL_29;
      goto LABEL_28;
    }
    CFDictionaryGetCount(v12);
    AMSupportLogInternal();
  }
  v14 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v15 = (CFDictionaryRef *)AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Remote"), v12);
  if (!v15)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPutForRestore", CFSTR("amfdr is NULL"), v27);
    goto LABEL_46;
  }
  v16 = v15;
  if (!v15[2])
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPutForRestore", CFSTR("amfdr->optionsDict is NULL"), v27);
    v24 = 0;
    v20 = 0;
    v23 = 0;
    v18 = 0;
    goto LABEL_27;
  }
  if (AMFDREnableRestorePeriodSsoCallback((uint64_t)v15))
    AMSupportLogInternal();
  MutableCopy = CFDictionaryCreateMutableCopy(v14, 0, v16[2]);
  v18 = MutableCopy;
  if (!MutableCopy)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPutForRestore", CFSTR("fdrOptions is NULL"), v27);
    v24 = 0;
    v20 = 0;
LABEL_44:
    v23 = 0;
    goto LABEL_27;
  }
  if (a4)
    _CFDictionaryAddDictionary(MutableCopy, a4);
  v19 = (const __CFNumber *)_CFDictionaryCopyValue(v18, CFSTR("DataVersion"));
  if (v19)
  {
    v20 = v19;
    v21 = CFGetTypeID(v19);
    if (v21 == CFNumberGetTypeID())
    {
      if (!CFNumberGetValue(v20, kCFNumberIntType, &valuePtr))
      {
        AMFDRErrorPushInternal(a5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPutForRestore", CFSTR("failed to convert versionOption"), v27);
LABEL_43:
        v24 = 0;
        goto LABEL_44;
      }
      goto LABEL_23;
    }
    CFRelease(v20);
  }
  v20 = CFNumberCreate(v14, kCFNumberIntType, &valuePtr);
  if (!v20)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPutForRestore", CFSTR("versionOption is NULL"), v27);
    goto LABEL_43;
  }
  CFDictionarySetValue(v18, CFSTR("DataVersion"), v20);
LABEL_23:
  v22 = (const void **)MEMORY[0x24BDBD268];
  if (valuePtr == 1)
  {
    CFDictionarySetValue(v18, CFSTR("OrganizationalUnit"), CFSTR("Devices - Stations"));
    CFDictionarySetValue(v18, CFSTR("UseSikDataInstance"), *v22);
  }
  v23 = AMFDRCreatePermissionsString(v14, 1u, a1, v8);
  if (v23)
  {
    CFDictionarySetValue(v18, CFSTR("Permissions"), v23);
    CFDictionarySetValue(v18, CFSTR("PersistCertificate"), *v22);
    AMFDRSetOptions((uint64_t)v16, v18);
    v24 = AMFDRDataPutWithOptions((uint64_t)v16, a1, v8, a3, 0, a5);
  }
  else
  {
    AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPutForRestore", CFSTR("failed to create PUT permission"), v27);
    v24 = 0;
  }
LABEL_27:
  CFRelease(v16);
  if (v10)
LABEL_28:
    CFRelease(v10);
LABEL_29:
  if (v20)
    CFRelease(v20);
  if (v23)
    CFRelease(v23);
  if (v18)
    CFRelease(v18);
  return v24;
}

uint64_t AMFDRDataDictCreateFromData(uint64_t a1, const __CFData *a2, char a3, uint64_t a4)
{
  uint64_t result;
  char v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v13 = 0;
  if (a2)
  {
    v7 = a1;
    v8 = 0xAAAAAAAAAAAAAAAALL;
    LOBYTE(v8) = a3;
    v9 = 0;
    v10 = 0;
    v11 = &v13;
    v12 = a4;
    _AMFDRDataDictConvertFromData(0, a2, (uint64_t)&v7);
    result = v13;
    if (!v13)
    {
      AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDictCreateFromData", CFSTR("failed to convert value"), v6);
      return v13;
    }
  }
  else
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataDictCreateFromData", CFSTR("valueData is NULL"), v6);
    return 0;
  }
  return result;
}

void _AMFDRDataDictConvertFromData(const void *a1, const __CFData *a2, uint64_t a3)
{
  const __CFData *UnsignedValueNoCopy;
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  CFArrayRef *v8;
  CFArrayRef *v9;
  CFTypeRef v10;
  const void *v11;
  __CFDictionary *v12;
  __CFDictionary *v13;
  char v14;
  const void *v15;

  v15 = 0;
  if (!a3)
  {
    AMSupportLogInternal();
    return;
  }
  if (!*(_QWORD *)a3)
  {
    AMFDRErrorPushInternal((uint64_t)&v15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictConvertFromData", CFSTR("ctx->amfdr is NULL"), v14);
    UnsignedValueNoCopy = 0;
LABEL_34:
    v9 = 0;
LABEL_36:
    v11 = 0;
    goto LABEL_15;
  }
  UnsignedValueNoCopy = a2;
  if (!a2)
  {
    AMFDRErrorPushInternal((uint64_t)&v15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictConvertFromData", CFSTR("value is NULL"), v14);
    goto LABEL_34;
  }
  v6 = CFGetAllocator(*(CFTypeRef *)a3);
  UnsignedValueNoCopy = (const __CFData *)_AMFDRDataCreateUnsignedValueNoCopy(v6, UnsignedValueNoCopy, 0, (uint64_t)&v15);
  if (!UnsignedValueNoCopy)
  {
    AMFDRErrorPushInternal((uint64_t)&v15, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictConvertFromData", CFSTR("failed to extract img4 payload"), v14);
    goto LABEL_34;
  }
  v7 = CFGetAllocator(*(CFTypeRef *)a3);
  v8 = (CFArrayRef *)AMFDRSysconfigCreateFromData(v7, UnsignedValueNoCopy, (uint64_t)&v15);
  v9 = v8;
  if (!v8)
  {
    AMFDRErrorPushInternal((uint64_t)&v15, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictConvertFromData", CFSTR("failed to decode as sysconfig format"), v14);
    goto LABEL_36;
  }
  if (*(_BYTE *)(a3 + 8))
  {
    v10 = AMFDRSysconfigCopyValues(v8, (uint64_t)&v15);
    v11 = v10;
    if (!v10)
    {
      AMFDRErrorPushInternal((uint64_t)&v15, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictConvertFromData", CFSTR("failed to copy sysconfig entries"), v14);
      goto LABEL_15;
    }
    if (!a1)
    {
LABEL_13:
      if (*(_QWORD *)(a3 + 32))
        **(_QWORD **)(a3 + 32) = CFRetain(v10);
      goto LABEL_15;
    }
  }
  else
  {
    v11 = 0;
    v10 = v8;
    if (!a1)
      goto LABEL_13;
  }
  v12 = *(__CFDictionary **)(a3 + 16);
  if (!v12)
    goto LABEL_13;
  CFDictionarySetValue(v12, a1, v10);
LABEL_15:
  if (v15)
  {
    if (a1 && (v13 = *(__CFDictionary **)(a3 + 24)) != 0)
    {
      CFDictionarySetValue(v13, a1, v15);
    }
    else if (*(_QWORD *)(a3 + 40))
    {
      **(_QWORD **)(a3 + 40) = CFRetain(v15);
    }
  }
  if (UnsignedValueNoCopy)
    CFRelease(UnsignedValueNoCopy);
  if (v9)
    CFRelease(v9);
  if (v11)
    CFRelease(v11);
  if (v15)
    CFRelease(v15);
}

CFTypeRef AMFDRDataCopyDataForPatch(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFDictionary *cf, uint64_t *a5)
{
  const __CFBoolean *v10;
  CFTypeID v11;
  const __CFData *v12;
  CFDataRef v13;
  CFTypeID v14;
  CFTypeID v15;
  const __CFBoolean *v16;
  const __CFBoolean *v17;
  CFTypeID v18;
  const __CFString *v19;
  const __CFData *v20;
  uint64_t v21;
  CFArrayRef *v22;
  const __CFArray *v23;
  CFIndex Count;
  uint64_t v25;
  CFIndex v26;
  CFIndex v27;
  const void *ValueAtIndex;
  const void *v29;
  int v30;
  BOOL v31;
  _BOOL4 v32;
  const __CFDictionary *v33;
  CFArrayRef *v34;
  const __CFString *v35;
  const void *v36;
  const void *v37;
  CFTypeID v38;
  CFTypeID v39;
  uint64_t v40;
  const __CFAllocator *v41;
  __CFDictionary *Mutable;
  __CFDictionary *v43;
  const __CFDictionary *v44;
  const CFDictionaryKeyCallBacks *v45;
  const CFDictionaryValueCallBacks *v46;
  const void *v47;
  const __CFAllocator *v48;
  __CFDictionary *v49;
  const __CFAllocator *v50;
  const void *v51;
  const __CFString *v53;
  CFErrorRef *v54;
  CFIndex v55;
  const __CFString *v56;
  void *v57[2];
  void *v58[2];
  __int128 v59;
  const __CFString *v60;
  char v61;
  const __CFBoolean *v62;
  uint64_t *v63;
  CFArrayRef *v64;
  const __CFString *v65;
  const __CFData *v66;
  CFTypeRef value;
  CFErrorRef v68;
  CFTypeRef v69;
  CFTypeRef v70;
  CFRange v71;

  v69 = 0;
  v70 = 0;
  v68 = 0;
  if (!a1)
  {
    v53 = CFSTR("amfdr is NULL");
LABEL_102:
    v60 = v53;
    *(_OWORD *)v58 = 0u;
    v59 = 0u;
    *(_OWORD *)v57 = 0u;
    v54 = &v68;
LABEL_103:
    v55 = 1;
LABEL_112:
    AMFDRErrorPushInternal((uint64_t)v54, v55, 0, 0, 0, 0, 0, 0, v57[0], v57[1], v58[0], v58[1], (void *)v59, *((void **)&v59 + 1), (uint64_t)"AMFDRDataCopyDataForPatch", v60, v61);
    v20 = 0;
    v22 = 0;
    goto LABEL_113;
  }
  if (!a2)
  {
    v53 = CFSTR("dataClassStr is NULL");
    goto LABEL_102;
  }
  if (!a3)
  {
    v53 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_102;
  }
  if (*(uint64_t (***)(int, int, int, int))(a1 + 48) != AMFDRHTTPStore)
  {
    v56 = CFSTR("Only supports remote amfdr");
    goto LABEL_111;
  }
  v10 = (const __CFBoolean *)*MEMORY[0x24BDBD268];
  if (cf && (v11 = CFGetTypeID(cf), v11 == CFDictionaryGetTypeID()))
  {
    v12 = (const __CFData *)CFDictionaryGetValue(cf, CFSTR("GrammarID"));
    v13 = v12;
    if (v12)
    {
      v14 = CFGetTypeID(v12);
      if (v14 != CFNullGetTypeID())
      {
        v15 = CFGetTypeID(v13);
        if (v15 != CFStringGetTypeID())
        {
          v19 = CFSTR("grammarID has invalid type");
          goto LABEL_120;
        }
      }
    }
    v16 = (const __CFBoolean *)CFDictionaryGetValue(cf, CFSTR("ForceAllowSchemaMismatch"));
    if (v16)
    {
      v17 = v16;
      v18 = CFGetTypeID(v16);
      v10 = v17;
      if (v18 != CFBooleanGetTypeID())
      {
        v19 = CFSTR("allowSchemaMismatch has invalid type");
LABEL_120:
        v60 = v19;
        *(_OWORD *)v58 = 0u;
        v59 = 0u;
        *(_OWORD *)v57 = 0u;
        v54 = (CFErrorRef *)a5;
        goto LABEL_103;
      }
    }
  }
  else
  {
    v13 = 0;
  }
  v20 = (const __CFData *)(*(uint64_t (**)(uint64_t, const __CFString *, const __CFString *, CFErrorRef *))(*(_QWORD *)(a1 + 48) + 16))(a1, a2, a3, &v68);
  v65 = a3;
  if (!v20)
  {
    v25 = AMFDRGetUnderlyingErrorCode(a1, &v68);
    if (v25 == 404)
    {
      v22 = 0;
      value = 0;
      goto LABEL_38;
    }
    v61 = v25;
    v56 = CFSTR("Unexpected error=%ld to handle");
LABEL_111:
    v60 = v56;
    *(_OWORD *)v58 = 0u;
    v59 = 0u;
    *(_OWORD *)v57 = 0u;
    v54 = &v68;
    v55 = 10;
    goto LABEL_112;
  }
  v21 = AMFDRDataDictCreateFromData(a1, v20, 0, (uint64_t)&v68);
  v22 = (CFArrayRef *)v21;
  if (!v21)
  {
    AMFDRErrorPushInternal((uint64_t)a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("origSysconfig of %@ is NULL"), (char)a2);
    goto LABEL_113;
  }
  v23 = *(const __CFArray **)(v21 + 48);
  if (v23)
  {
    if (*(_QWORD *)(v21 + 56))
    {
      Count = CFArrayGetCount(*(CFArrayRef *)(v21 + 48));
      if (Count != CFArrayGetCount(v22[7]))
      {
        AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("invalid number of metadata values"), v61);
LABEL_113:
        v34 = 0;
        v33 = 0;
        v51 = 0;
        v13 = 0;
        v43 = 0;
        if (!a5)
          goto LABEL_77;
LABEL_76:
        *a5 = AMSupportSafeRetain();
        goto LABEL_77;
      }
      v23 = v22[6];
      if (!v23)
        goto LABEL_35;
    }
    else
    {
      Count = 0;
    }
    v71.length = CFArrayGetCount(v23);
    v71.location = 0;
    if (CFArrayContainsValue(v23, v71, CFSTR("grmr")))
    {
      v63 = a5;
      v26 = Count - 1;
      if (Count < 1)
      {
LABEL_34:
        value = 0;
        v32 = 0;
        v13 = 0;
        v33 = 0;
        v34 = 0;
        a5 = v63;
        v35 = v65;
        goto LABEL_55;
      }
      v62 = v10;
      v27 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v22[6], v27);
        v29 = CFArrayGetValueAtIndex(v22[7], v27);
        v30 = CFEqual(ValueAtIndex, CFSTR("grmr"));
        if (v13)
        {
          if (v30)
            break;
        }
        if (v30)
          v31 = 1;
        else
          v31 = v26 == v27;
        ++v27;
        if (v31)
          goto LABEL_34;
      }
      v35 = v65;
      if (CFEqual(v29, v13))
      {
        value = 0;
        v32 = 0;
        v13 = 0;
        v33 = 0;
        v34 = 0;
        a5 = v63;
        goto LABEL_55;
      }
      value = CFRetain(v29);
      AMSupportLogInternal();
      v10 = v62;
      a5 = v63;
      goto LABEL_37;
    }
  }
LABEL_35:
  v35 = v65;
  if (!v13)
  {
    value = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    goto LABEL_55;
  }
  AMSupportLogInternal();
  value = 0;
LABEL_37:
  if (!CFBooleanGetValue(v10))
  {
    AMSupportLogInternal();
    v13 = 0;
    v33 = 0;
    v34 = 0;
    v32 = 1;
    goto LABEL_63;
  }
LABEL_38:
  v36 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("SignData"));
  if (v36)
  {
    v37 = v36;
    v38 = CFGetTypeID(v36);
    if (v38 == CFBooleanGetTypeID())
    {
      v39 = CFGetTypeID(v37);
      if (v39 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)v37))
        goto LABEL_42;
      AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("signDataBool is required to true to sign base payload."), v61);
    }
    else
    {
      AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("Invalid type for '%@'. Expected CFBoolean."), (char)CFSTR("SignData"));
    }
    v13 = 0;
    v33 = 0;
    v34 = 0;
    goto LABEL_49;
  }
LABEL_42:
  CFGetAllocator((CFTypeRef)a1);
  AMFDRSysconfigCreate();
  v34 = (CFArrayRef *)v40;
  if (v40)
  {
    AMFDRSysconfigSetDataClass(v40, a2);
    v32 = v20 != 0;
    if (v13)
    {
      v41 = CFGetAllocator((CFTypeRef)a1);
      Mutable = CFDictionaryCreateMutable(v41, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      v33 = Mutable;
      v35 = v65;
      if (!Mutable)
      {
        AMFDRErrorPushInternal((uint64_t)a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("metaDataDict is NULL"), v61);
        goto LABEL_117;
      }
      CFDictionaryAddValue(Mutable, CFSTR("grmr"), v13);
      if (!AMFDRSysconfigSetMetaValues(v34, v33, (uint64_t)&v68))
      {
        AMFDRErrorPushInternal((uint64_t)&v68, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("failed to set metaData"), v61);
LABEL_117:
        v13 = 0;
        goto LABEL_63;
      }
    }
    else
    {
      v33 = 0;
      v35 = v65;
    }
    v13 = _AMFDRDataDictCopyForPut(v34, 0, (uint64_t)&v68);
    if (!v13)
    {
      AMFDRErrorPushInternal((uint64_t)&v68, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("failed to generate base dict value to patch"), v61);
      goto LABEL_63;
    }
    v20 = (const __CFData *)_AMFDRDataCopyForPutWithManifest(a1, a2, v35, v13, 0, 0, 0, (uint64_t)&v68);
    if (!v20)
    {
      AMFDRErrorPushInternal((uint64_t)&v68, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("dataToPatch is NULL"), v61);
      goto LABEL_63;
    }
LABEL_55:
    if ((_AMFDRDataCopyFormattedRawAndImg4((CFDictionaryRef *)a1, a2, v35, &v69, &v70, v20, (uint64_t)&v68) & 1) == 0)
    {
      AMFDRErrorPushInternal((uint64_t)a5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("_AMFDRDataCopyFormattedRawAndImg4 failed"), v61);
      goto LABEL_63;
    }
    if (v68)
    {
      if (CFErrorGetCode(v68) == 18)
      {
        AMSupportLogInternal();
        if (v68)
        {
          CFRelease(v68);
          v20 = 0;
          v68 = 0;
          goto LABEL_63;
        }
      }
      else if (v68)
      {
        AMFDRErrorPushInternal((uint64_t)&v68, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("AMFDRDataCopyRawAndFormatted failed, can't copy original data"), v61);
      }
    }
    v20 = 0;
    goto LABEL_63;
  }
  AMFDRErrorPushInternal((uint64_t)&v68, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyDataForPatch", CFSTR("sysconfig is NULL"), v61);
  v13 = 0;
  v33 = 0;
LABEL_49:
  v32 = v20 != 0;
LABEL_63:
  v43 = 0;
  if (!v32 || v68)
  {
    v51 = value;
    if (!a5)
      goto LABEL_77;
    goto LABEL_76;
  }
  v64 = v34;
  v66 = v13;
  v44 = v33;
  v45 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
  v46 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
  v47 = (const void *)*MEMORY[0x24BDBD378];
  while (1)
  {
    v48 = CFGetAllocator((CFTypeRef)a1);
    v49 = CFDictionaryCreateMutable(v48, 0, v45, v46);
    v43 = v49;
    if (v49)
    {
      CFDictionarySetValue(v49, v47, CFSTR("new grmr received from option is mismatched the grmr of data"));
      if (value)
        CFDictionarySetValue(v43, CFSTR("ExistingSchemaHash"), value);
      v50 = CFGetAllocator((CFTypeRef)a1);
      v68 = CFErrorCreate(v50, CFSTR("AMFDRError"), 34, v43);
      if (v68)
        break;
    }
    AMSupportLogInternal();
    v45 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
    v46 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
    if (v68)
    {
      v51 = value;
      v33 = v44;
      goto LABEL_75;
    }
  }
  v33 = v44;
  v51 = value;
LABEL_75:
  v34 = v64;
  v13 = v66;
  if (a5)
    goto LABEL_76;
LABEL_77:
  if (v69)
  {
    CFRelease(v69);
    v69 = 0;
  }
  if (v13)
    CFRelease(v13);
  if (v20)
    CFRelease(v20);
  if (v68)
  {
    CFRelease(v68);
    v68 = 0;
  }
  if (v33)
    CFRelease(v33);
  if (v22)
    CFRelease(v22);
  if (v34)
    CFRelease(v34);
  if (v43)
    CFRelease(v43);
  if (v51)
    CFRelease(v51);
  return v70;
}

CFDataRef _AMFDRDataDictCopyForPut(void *cf, const __CFDictionary *a2, uint64_t a3)
{
  CFDataRef result;
  const __CFString *v6;
  char v7;

  if (a2 && !AMFDRSysconfigSetValues((CFArrayRef *)cf, a2, a3))
  {
    v6 = CFSTR("failed to modify sysconfig");
  }
  else
  {
    result = AMFDRSysconfigCreateEncodedData(cf, a3);
    if (result)
      return result;
    v6 = CFSTR("failed to encode sysconfig");
  }
  AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataDictCopyForPut", v6, v7);
  return 0;
}

CFArrayRef AMFDRDataMultiCopyDataForPatch(const __CFArray *a1, CFTypeRef cf, const void *a3, uint64_t a4, _QWORD *a5)
{
  CFArrayRef Copy;
  CFTypeID v10;
  CFTypeID v11;
  uint64_t Count;
  const __CFDictionary *v13;
  CFDataRef v14;
  const __CFArray *v15;
  const __CFAllocator *v16;
  CFMutableArrayRef Mutable;
  CFTypeRef v18;
  CFIndex v19;
  void *v20;
  CFStringRef FullKey;
  const __CFString *ValueAtIndex;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFAllocator *v26;
  const void *v27;
  const __CFData *v28;
  __CFError *v29;
  const void *v30;
  const void *v31;
  CFTypeID v32;
  CFTypeID v33;
  uint64_t v34;
  const __CFAllocator *v35;
  const __CFString *v36;
  const __CFString *v38;
  const __CFString *v39;
  uint64_t v40;
  CFDataRef cfa;
  __CFArray *v42;
  const __CFArray *theArray;
  const __CFDictionary *Value;
  const __CFDictionary *theDict;
  CFTypeRef v46;
  CFTypeRef v47;
  __CFError *v48;
  CFTypeRef v49[2];

  Copy = a1;
  v48 = 0;
  v49[0] = 0;
  v46 = 0;
  v47 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)&v48, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("amfdr is NULL"), (char)v39);
    theDict = 0;
    v15 = 0;
LABEL_104:
    FullKey = 0;
    v28 = 0;
    v20 = 0;
    v14 = 0;
LABEL_105:
    cfa = 0;
    goto LABEL_56;
  }
  if (!cf || (v10 = CFGetTypeID(cf), v10 != CFArrayGetTypeID()))
  {
    v38 = CFSTR("dataClassArray is NULL");
LABEL_102:
    AMFDRErrorPushInternal((uint64_t)&v48, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", v38, (char)v39);
    theDict = 0;
LABEL_103:
    v15 = 0;
    Copy = 0;
    goto LABEL_104;
  }
  if (!a3 || (v11 = CFGetTypeID(a3), v11 != CFArrayGetTypeID()))
  {
    v38 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_102;
  }
  if (*((uint64_t (***)(int, int, int, int))Copy + 6) != AMFDRHTTPStore)
  {
    v38 = CFSTR("Only supports remote amfdr");
    goto LABEL_102;
  }
  if (a4)
  {
    v38 = CFSTR("optionsArray isn't supported!!");
    goto LABEL_102;
  }
  Count = CFArrayGetCount((CFArrayRef)cf);
  if (CFArrayGetCount((CFArrayRef)a3) != Count)
  {
    v38 = CFSTR("dataInstanceEntries count mismatch");
    goto LABEL_102;
  }
  theDict = (const __CFDictionary *)_AMFDRDataMultiCopyInternal(Copy, (uint64_t)cf, (uint64_t)a3, 1, (uint64_t)v49, (CFTypeRef *)&v48);
  if (!v48)
  {
    v14 = 0;
    Value = 0;
    goto LABEL_15;
  }
  if (CFErrorGetCode(v48) != 21)
  {
    AMSupportLogInternal();
    goto LABEL_103;
  }
  v13 = CFErrorCopyUserInfo(v48);
  v14 = v13;
  if (!v13)
  {
    AMFDRErrorPushInternal((uint64_t)&v48, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("userInfo is NULL"), (char)v39);
    v15 = 0;
    Copy = 0;
    FullKey = 0;
    v28 = 0;
    v20 = 0;
    goto LABEL_105;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(v13, CFSTR("MultiRequestErrors"));
  if (!Value)
  {
    cfa = v14;
    AMFDRErrorPushInternal((uint64_t)&v48, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("cannot get multiResponseErrors"), (char)v39);
    v15 = 0;
LABEL_107:
    Copy = 0;
    FullKey = 0;
    v28 = 0;
    v20 = 0;
    v14 = 0;
    goto LABEL_56;
  }
LABEL_15:
  v16 = CFGetAllocator(Copy);
  Mutable = CFArrayCreateMutable(v16, Count, MEMORY[0x24BDBD690]);
  v15 = Mutable;
  cfa = v14;
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)&v48, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("originalDataArray is NULL"), (char)v39);
    goto LABEL_107;
  }
  v40 = (uint64_t)a5;
  if (Count < 1)
  {
    FullKey = 0;
    v20 = 0;
    v14 = 0;
LABEL_49:
    v35 = CFGetAllocator(Copy);
    Copy = CFArrayCreateCopy(v35, v15);
    if (v48)
    {
      CFRelease(v48);
      v28 = 0;
      v48 = 0;
    }
    else
    {
      v28 = 0;
    }
  }
  else
  {
    v42 = Mutable;
    theArray = (const __CFArray *)a3;
    v18 = 0;
    v19 = 0;
    v14 = 0;
    v20 = 0;
    FullKey = 0;
    while (1)
    {
      if (FullKey)
        CFRelease(FullKey);
      if (v18)
      {
        CFRelease(v18);
        v47 = 0;
      }
      if (v46)
      {
        CFRelease(v46);
        v46 = 0;
      }
      if (v14)
        CFRelease(v14);
      if (v20)
        CFRelease(v20);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, v19);
      if (!ValueAtIndex)
        break;
      v23 = ValueAtIndex;
      v24 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v19);
      if (!v24)
      {
        AMFDRErrorPushInternal((uint64_t)&v48, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("dataInstanceStr is NULL"), (char)v39);
        Copy = 0;
        FullKey = 0;
        goto LABEL_92;
      }
      v25 = v24;
      v26 = CFGetAllocator(Copy);
      FullKey = AMFDRDataLocalCreateFullKey(v26, (uint64_t)v23, (uint64_t)v25);
      if (!FullKey)
      {
        AMFDRErrorPushInternal((uint64_t)&v48, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("dataClassInstance is NULL"), (char)v39);
        goto LABEL_91;
      }
      if (theDict && (v27 = CFDictionaryGetValue(theDict, FullKey)) != 0)
      {
        v28 = (const __CFData *)CFRetain(v27);
        if (!v28)
        {
          AMSupportLogInternal();
          Copy = 0;
          goto LABEL_93;
        }
        v14 = 0;
        v20 = 0;
      }
      else
      {
        if (Value)
        {
          v29 = (__CFError *)CFDictionaryGetValue(Value, FullKey);
          if (v29)
          {
            if (CFErrorGetCode(v29) != 701)
            {
              AMFDRErrorPushInternal((uint64_t)&v48, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("AMFDRDataMultiCopyDataForPatch failed for %@: %@"), (char)FullKey);
LABEL_91:
              Copy = 0;
LABEL_92:
              v28 = 0;
LABEL_93:
              v20 = 0;
LABEL_94:
              v14 = 0;
LABEL_95:
              a5 = (_QWORD *)v40;
LABEL_55:
              v15 = v42;
              goto LABEL_56;
            }
          }
        }
        v30 = CFDictionaryGetValue(*((CFDictionaryRef *)Copy + 2), CFSTR("SignData"));
        if (v30)
        {
          v31 = v30;
          v32 = CFGetTypeID(v30);
          if (v32 != CFBooleanGetTypeID())
          {
            v39 = CFSTR("SignData");
            v36 = CFSTR("Invalid type for '%@'. Expected CFBoolean.");
            goto LABEL_54;
          }
          v33 = CFGetTypeID(v31);
          if (v33 != CFBooleanGetTypeID() || !CFBooleanGetValue((CFBooleanRef)v31))
          {
            v36 = CFSTR("signDataBool is required to true to sign base payload.");
LABEL_54:
            a5 = (_QWORD *)v40;
            AMFDRErrorPushInternal(v40, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", v36, (char)v39);
            Copy = 0;
            v28 = 0;
            v20 = 0;
            v14 = 0;
            goto LABEL_55;
          }
        }
        CFGetAllocator(Copy);
        AMFDRSysconfigCreate();
        v20 = (void *)v34;
        if (!v34)
        {
          AMFDRErrorPushInternal((uint64_t)&v48, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("sysconfig is NULL"), (char)v39);
          Copy = 0;
          v28 = 0;
          goto LABEL_94;
        }
        AMFDRSysconfigSetDataClass(v34, v23);
        v14 = _AMFDRDataDictCopyForPut(v20, 0, (uint64_t)&v48);
        if (!v14)
        {
          AMFDRErrorPushInternal((uint64_t)&v48, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("failed to generate base dict value to patch"), (char)v39);
          Copy = 0;
          v28 = 0;
          goto LABEL_95;
        }
        v28 = (const __CFData *)_AMFDRDataCopyForPutWithManifest((uint64_t)Copy, v23, v25, v14, 0, 0, 0, (uint64_t)&v48);
        if (!v28)
        {
          AMFDRErrorPushInternal((uint64_t)&v48, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("dataToPatch is NULL"), (char)v39);
          Copy = 0;
          goto LABEL_95;
        }
      }
      if ((_AMFDRDataCopyFormattedRawAndImg4((CFDictionaryRef *)Copy, v23, v25, &v46, &v47, v28, (uint64_t)&v48) & 1) == 0)
      {
        a5 = (_QWORD *)v40;
        AMFDRErrorPushInternal(v40, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("_AMFDRDataCopyFormattedRawAndImg4 failed"), (char)v39);
        Copy = 0;
        goto LABEL_55;
      }
      v18 = v47;
      v15 = v42;
      CFArrayAppendValue(v42, v47);
      if (Count == ++v19)
        goto LABEL_49;
    }
    AMFDRErrorPushInternal((uint64_t)&v48, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiCopyDataForPatch", CFSTR("dataClassStr is NULL"), (char)v39);
    Copy = 0;
    FullKey = 0;
    v28 = 0;
    v20 = 0;
    v14 = 0;
  }
  a5 = (_QWORD *)v40;
LABEL_56:
  if (a5)
    *a5 = AMSupportSafeRetain();
  if (v15)
    CFRelease(v15);
  if (theDict)
    CFRelease(theDict);
  if (FullKey)
    CFRelease(FullKey);
  if (v20)
    CFRelease(v20);
  if (v14)
    CFRelease(v14);
  if (v28)
    CFRelease(v28);
  if (v46)
  {
    CFRelease(v46);
    v46 = 0;
  }
  if (v47)
  {
    CFRelease(v47);
    v47 = 0;
  }
  if (v49[0])
  {
    CFRelease(v49[0]);
    v49[0] = 0;
  }
  if (cfa)
    CFRelease(cfa);
  if (v48)
    CFRelease(v48);
  return Copy;
}

__CFString *AMFDRDataPatchWithOptions(uint64_t a1, CFArrayRef *a2, const __CFString *a3, const __CFData *a4, const __CFDictionary *a5, CFTypeRef cf, uint64_t a7)
{
  __CFString *v7;
  __int128 v8;
  CFArrayRef *v9;
  CFStringRef v10;
  const __CFData *v11;
  const __CFBoolean *v14;
  CFTypeID v15;
  const __CFString *Value;
  const __CFString *v17;
  CFTypeID v18;
  CFTypeID v19;
  const __CFString *v20;
  const __CFString *v21;
  CFTypeID v22;
  CFTypeID v23;
  const __CFBoolean *v24;
  const __CFBoolean *v25;
  CFTypeID v26;
  __CFDictionary *v27;
  __CFDictionary *v28;
  CFTypeID v29;
  CFTypeID v30;
  CFIndex v31;
  __CFArray *Mutable;
  const __CFAllocator *v33;
  const CFArrayCallBacks *v34;
  const void *ValueAtIndex;
  const void *v36;
  uint64_t v37;
  const __CFArray *v38;
  CFIndex Count;
  CFIndex v40;
  const void *v41;
  const __CFString *v42;
  const __CFAllocator *v43;
  __CFString *v44;
  CFIndex v45;
  const void *v46;
  const void *v47;
  CFTypeID v48;
  const __CFString *v49;
  const __CFString *v50;
  CFTypeID v51;
  CFTypeID v52;
  CFTypeID v53;
  const __CFAllocator *v54;
  const __CFData *ExternalRepresentation;
  const __CFAllocator *v56;
  __CFDictionary *v57;
  const __CFString *v58;
  CFComparisonResult v59;
  const __CFString *v60;
  __CFString *v61;
  _QWORD *v62;
  const __CFAllocator *v63;
  __CFDictionary *MutableCopy;
  uint64_t v65;
  const __CFString *v66;
  const void *v67;
  const __CFString *format;
  const __CFAllocator *v69;
  BOOL v70;
  char v71;
  const __CFDictionary *v72;
  __CFString *v73;
  const __CFAllocator *v74;
  int v75;
  unsigned __int8 v76;
  CFTypeRef v77;
  const __CFString *v79;
  char v80;
  const __CFString *v81;
  const __CFString *v82;
  const __CFBoolean *BOOLean;
  uint64_t v84;
  __CFArray *v88;
  CFTypeRef v89;
  CFTypeRef cfa;
  CFTypeRef v91;
  _OWORD v92[3];
  _OWORD v93[2];
  uint64_t v94;
  CFRange v95;

  v7 = (__CFString *)a1;
  v94 = *MEMORY[0x24BDAC8D0];
  v89 = 0;
  cfa = 0;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v93[0] = v8;
  v93[1] = v8;
  v92[1] = v8;
  v92[2] = v8;
  v92[0] = v8;
  if (!a1)
  {
    v62 = (_QWORD *)a7;
    AMFDRErrorPushInternal((uint64_t)&v89, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("amfdr is NULL"), v80);
    v10 = 0;
    v67 = 0;
    Mutable = 0;
    v28 = 0;
    v17 = 0;
    v44 = 0;
    v11 = 0;
    v88 = 0;
    v9 = 0;
    goto LABEL_130;
  }
  v9 = a2;
  if (!a2)
  {
    v62 = (_QWORD *)a7;
    AMFDRErrorPushInternal((uint64_t)&v89, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("dataClassStr is NULL"), v80);
    v10 = 0;
    v67 = 0;
    Mutable = 0;
    v28 = 0;
    v17 = 0;
    v44 = 0;
    v11 = 0;
    v88 = 0;
    goto LABEL_95;
  }
  v10 = a3;
  if (!a3)
  {
    v62 = (_QWORD *)a7;
    AMFDRErrorPushInternal((uint64_t)&v89, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("dataInstanceStr is NULL"), v80);
    goto LABEL_183;
  }
  v11 = a4;
  if (!a4)
  {
    v62 = (_QWORD *)a7;
    AMFDRErrorPushInternal((uint64_t)&v89, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("originalData is NULL"), v80);
    v10 = 0;
    v67 = 0;
    Mutable = 0;
    v28 = 0;
    v17 = 0;
    v44 = 0;
LABEL_185:
    v88 = 0;
    v9 = 0;
    goto LABEL_95;
  }
  if (*(uint64_t (***)(int, int, int, int))(a1 + 48) != AMFDRHTTPStore)
  {
    v62 = (_QWORD *)a7;
    AMFDRErrorPushInternal((uint64_t)&v89, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("Only supports remote amfdr"), v80);
LABEL_182:
    v10 = 0;
LABEL_183:
    v67 = 0;
    Mutable = 0;
LABEL_184:
    v28 = 0;
    v17 = 0;
    v44 = 0;
    v11 = 0;
    goto LABEL_185;
  }
  v14 = (const __CFBoolean *)*MEMORY[0x24BDBD268];
  if (!cf || (v15 = CFGetTypeID(cf), v15 != CFDictionaryGetTypeID()))
  {
    BOOLean = v14;
    v17 = 0;
    v21 = 0;
    v28 = 0;
    goto LABEL_30;
  }
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AssemblyID"));
  v17 = Value;
  if (Value)
  {
    v18 = CFGetTypeID(Value);
    if (v18 != CFNullGetTypeID())
    {
      v19 = CFGetTypeID(v17);
      if (v19 != CFStringGetTypeID())
      {
        v79 = CFSTR("assemblyID has invalid type");
        goto LABEL_181;
      }
    }
  }
  v20 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("GrammarID"));
  v21 = v20;
  if (v20)
  {
    v22 = CFGetTypeID(v20);
    if (v22 != CFNullGetTypeID())
    {
      v23 = CFGetTypeID(v21);
      if (v23 != CFStringGetTypeID())
      {
        v79 = CFSTR("grammarID has invalid type");
        goto LABEL_181;
      }
    }
  }
  v24 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("LocalValidation"));
  if (v24)
  {
    v25 = v24;
    v26 = CFGetTypeID(v24);
    v14 = v25;
    if (v26 != CFBooleanGetTypeID())
    {
      v79 = CFSTR("validation has invalid type");
LABEL_181:
      v62 = (_QWORD *)a7;
      AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", v79, v80);
      goto LABEL_182;
    }
  }
  BOOLean = v14;
  v27 = (__CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("RequiredSubCCDgst"));
  v28 = v27;
  if (!v27)
    goto LABEL_30;
  v29 = CFGetTypeID(v27);
  if (v29 != CFNullGetTypeID())
  {
    v30 = CFGetTypeID(v28);
    if (v30 != CFArrayGetTypeID())
    {
      v79 = CFSTR("requiredDgstArray has invalid type");
      goto LABEL_181;
    }
  }
  if (CFArrayGetCount(v28) >= 1)
  {
    v31 = 0;
    Mutable = 0;
    v33 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v34 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v28, v31);
      if (CFDictionaryContainsKey(a5, ValueAtIndex))
      {
        if (!Mutable)
        {
          Mutable = CFArrayCreateMutable(v33, 0, v34);
          if (!Mutable)
          {
            v62 = (_QWORD *)a7;
            AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("cannot allocate subCCsToVerifyDigest"), v80);
            v10 = 0;
            v67 = 0;
            goto LABEL_184;
          }
        }
        v36 = CFArrayGetValueAtIndex(v28, v31);
        CFArrayAppendValue(Mutable, v36);
      }
      ++v31;
    }
    while (v31 < CFArrayGetCount(v28));
    if (Mutable && CFArrayGetCount(Mutable) >= 1)
      AMFDRSetSubCCDigestsToVerify((uint64_t)v7, a2, Mutable);
    goto LABEL_31;
  }
LABEL_30:
  Mutable = 0;
LABEL_31:
  v88 = Mutable;
  v37 = AMFDRDataDictCreateFromData((uint64_t)v7, v11, 0, (uint64_t)&v89);
  v9 = (CFArrayRef *)v37;
  if (!v37)
  {
    v62 = (_QWORD *)a7;
    AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("origSysconfig of %@ is NULL"), (char)a2);
    goto LABEL_93;
  }
  v38 = *(const __CFArray **)(v37 + 48);
  v84 = (uint64_t)v11;
  if (!v38)
    goto LABEL_44;
  if (*(_QWORD *)(v37 + 56))
  {
    Count = CFArrayGetCount(v38);
    if (Count != CFArrayGetCount(v9[7]))
    {
      format = CFSTR("invalid number of metadata values");
      goto LABEL_92;
    }
    v38 = v9[6];
    if (!v38)
      goto LABEL_44;
  }
  else
  {
    Count = 0;
  }
  v95.length = CFArrayGetCount(v38);
  v95.location = 0;
  if (!CFArrayContainsValue(v38, v95, CFSTR("grmr")))
  {
LABEL_44:
    if (!v21)
      goto LABEL_45;
    goto LABEL_91;
  }
  if (Count < 1)
  {
    v42 = v21;
  }
  else
  {
    v81 = v17;
    v40 = 0;
    while (1)
    {
      v41 = CFArrayGetValueAtIndex(v9[6], v40);
      v42 = (const __CFString *)CFArrayGetValueAtIndex(v9[7], v40);
      if (CFEqual(v41, CFSTR("grmr")))
        break;
      if (Count == ++v40)
      {
        v42 = v21;
        goto LABEL_97;
      }
    }
    if (v21)
    {
      v17 = v81;
      if (!CFEqual(v42, v21))
      {
LABEL_91:
        AMSupportLogInternal();
        format = CFSTR("grammar hash mismatched, check the grammar ID");
LABEL_92:
        v62 = (_QWORD *)a7;
        AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", format, v80);
LABEL_93:
        v10 = 0;
        v67 = 0;
        Mutable = 0;
        v28 = 0;
        v17 = 0;
        v44 = 0;
LABEL_94:
        v11 = 0;
LABEL_95:
        v7 = 0;
        goto LABEL_130;
      }
      goto LABEL_99;
    }
    AMSupportLogInternal();
LABEL_97:
    v17 = v81;
  }
  v21 = v42;
  if (!v42)
    goto LABEL_45;
LABEL_99:
  if (!CFBooleanGetValue(BOOLean))
  {
LABEL_45:
    if (v28)
    {
      if (CFArrayGetCount(v28) >= 1)
      {
        v43 = CFGetAllocator(v7);
        v44 = CFStringCreateMutable(v43, 0);
        if (v44)
        {
          v82 = v17;
          if (CFArrayGetCount(v28) >= 1)
          {
            v45 = 0;
            v11 = 0;
            Mutable = 0;
            while (1)
            {
              v46 = CFArrayGetValueAtIndex(v28, v45);
              v47 = v46;
              if (!v46)
                break;
              v48 = CFGetTypeID(v46);
              if (v48 != CFStringGetTypeID())
                break;
              if (Mutable)
                CFRelease(Mutable);
              if (v11)
                CFRelease(v11);
              v49 = (const __CFString *)CFDictionaryGetValue(a5, v47);
              v50 = v49;
              if (!v49
                || (v51 = CFGetTypeID(v49), v51 != CFDataGetTypeID())
                && (v52 = CFGetTypeID(v50), v52 != CFStringGetTypeID()))
              {
                AMSupportLogInternal();
                v10 = 0;
                v67 = 0;
                Mutable = 0;
                v28 = 0;
                v17 = 0;
                goto LABEL_128;
              }
              v53 = CFGetTypeID(v50);
              if (v53 == CFStringGetTypeID())
              {
                v54 = CFGetAllocator(v7);
                ExternalRepresentation = CFStringCreateExternalRepresentation(v54, v50, 0x8000100u, 0x20u);
              }
              else
              {
                ExternalRepresentation = (const __CFData *)CFRetain(v50);
              }
              v11 = ExternalRepresentation;
              CFDataGetBytePtr(ExternalRepresentation);
              CFDataGetLength(v11);
              if (AMSupportDigestSha384())
              {
                AMSupportLogInternal();
                v10 = 0;
                v67 = 0;
                Mutable = 0;
                goto LABEL_160;
              }
              Mutable = (__CFArray *)_AMFDRCopyHashHexString((unsigned __int8 *)v92, 0x30u);
              if (!Mutable)
                break;
              if (v45)
                CFStringAppend(v44, CFSTR(","));
              CFStringAppendFormat(v44, 0, CFSTR("%@:%@"), v47, Mutable);
              if (++v45 >= CFArrayGetCount(v28))
                goto LABEL_72;
            }
            AMSupportLogInternal();
            v10 = 0;
            v67 = 0;
LABEL_160:
            v28 = 0;
            v17 = 0;
            goto LABEL_129;
          }
          Mutable = 0;
          v11 = 0;
LABEL_72:
          v56 = CFGetAllocator(v7);
          v57 = CFDictionaryCreateMutable(v56, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
          v28 = v57;
          if (!v57)
          {
            v62 = (_QWORD *)a7;
            AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("metadataDict create failed"), v80);
            goto LABEL_175;
          }
          CFDictionarySetValue(v57, CFSTR("x-fdr-patch-required-subcc-dgst"), v44);
          v17 = v82;
LABEL_74:
          v58 = (const __CFString *)CFDictionaryGetValue(a5, CFSTR("asid"));
          if (v17)
          {
            if (v58)
            {
              v59 = CFStringCompare(v17, v58, 0);
              v60 = v17;
              v17 = 0;
              v61 = (__CFString *)a2;
              if (v59)
              {
                v62 = (_QWORD *)a7;
                AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("assemblyID in option not equals asid in patchDict"), v80);
LABEL_175:
                v10 = 0;
                v67 = 0;
                v17 = 0;
                goto LABEL_95;
              }
            }
            else
            {
              v60 = v17;
              v63 = CFGetAllocator(v7);
              MutableCopy = CFDictionaryCreateMutableCopy(v63, 0, a5);
              v17 = (const __CFString *)MutableCopy;
              if (!MutableCopy)
              {
                v62 = (_QWORD *)a7;
                AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("asidPatchDict create failed"), v80);
                v10 = 0;
                v67 = 0;
                goto LABEL_95;
              }
              CFDictionarySetValue(MutableCopy, CFSTR("asid"), v60);
              v61 = (__CFString *)a2;
            }
          }
          else
          {
            v60 = v58;
            v61 = (__CFString *)a2;
            if (!v58)
              goto LABEL_83;
          }
          AMFDRSetAssemblyIdentifierToVerify((uint64_t)v7, v61, v60);
LABEL_83:
          if (v17)
            v65 = (uint64_t)v17;
          else
            v65 = (uint64_t)a5;
          v66 = v61;
          v62 = (_QWORD *)a7;
          v7 = (__CFString *)_AMFDRDataPatchInternal(v7, v66, a3, v84, 0, v65, (uint64_t)v28, a7);
          v10 = 0;
          v67 = 0;
          goto LABEL_130;
        }
        v62 = (_QWORD *)a7;
        AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("requiredSubCCs create failed"), v80);
        v10 = 0;
        v67 = 0;
        Mutable = 0;
        v28 = 0;
        v17 = 0;
        goto LABEL_94;
      }
      Mutable = 0;
      v28 = 0;
    }
    else
    {
      Mutable = 0;
    }
    v44 = 0;
    v11 = 0;
    goto LABEL_74;
  }
  v69 = CFGetAllocator(v7);
  v10 = CFStringCreateWithFormat(v69, 0, CFSTR("%@-%@"), CFSTR("grmr"), v21);
  v70 = AMFDRLoadPersistent((uint64_t)v7, (uint64_t)CFSTR("GrammarHash"), (uint64_t)v10, (uint64_t)&cfa);
  v67 = 0;
  v71 = 0;
  while (1)
  {
    if (v67)
      CFRelease(v67);
    if (!v70)
      break;
LABEL_118:
    CFDataGetBytePtr((CFDataRef)cfa);
    CFDataGetLength((CFDataRef)cfa);
    if (AMSupportDigestSha256())
    {
      AMSupportLogInternal();
      goto LABEL_163;
    }
    v67 = _AMFDRCopyHashHexString((unsigned __int8 *)v93, 0x20u);
    if (v67)
    {
      v75 = CFEqual(v21, v67);
      v70 = 0;
      v76 = v71 ^ 1;
      v71 = 1;
      if (((v75 == 0) & v76) != 0)
        continue;
    }
    AMSupportLogInternal();
    goto LABEL_127;
  }
  if (cfa)
  {
    CFRelease(cfa);
    cfa = 0;
  }
  v91 = 0;
  v72 = (const __CFDictionary *)AMFDRGetOptions((uint64_t)v7);
  if (v72)
  {
    v73 = (__CFString *)CFDictionaryGetValue(v72, CFSTR("Permissions"));
    if (v73)
    {
      v74 = CFGetAllocator(v7);
      v73 = CFStringCreateMutableCopy(v74, 0, v73);
      if ((AMFDRDataAppendPermissionsString(v7, 0, CFSTR("grmr"), v21, v73) & 1) != 0)
      {
        AMFDRSetOption((uint64_t)v7, CFSTR("Permissions"), v73);
        v67 = AMFDRDataCopy((uint64_t)v7, CFSTR("grmr"), v21, (uint64_t)&v91);
        goto LABEL_110;
      }
      AMFDRErrorPushInternal((uint64_t)&v91, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRCopyGrmr", CFSTR("Append GET permission string failed"), v80);
    }
    else
    {
      AMFDRErrorPushInternal((uint64_t)&v91, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRCopyGrmr", CFSTR("oldPerm is NULL"), v80);
    }
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)&v91, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRCopyGrmr", CFSTR("options is NULL"), v80);
    v73 = 0;
  }
  v67 = 0;
LABEL_110:
  v89 = (CFTypeRef)AMSupportSafeRetain();
  if (v73)
    CFRelease(v73);
  if (v91)
    CFRelease(v91);
  cfa = v67;
  if (!v67)
  {
    AMFDRErrorPushInternal((uint64_t)&v89, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("grmrData is NULL"), v80);
    goto LABEL_127;
  }
  if ((AMFDRSavePersistent(v7, CFSTR("GrammarHash"), v10, v67) & 1) != 0)
  {
    if (v89)
    {
      CFRelease(v89);
      v89 = 0;
    }
    goto LABEL_118;
  }
  AMFDRErrorPushInternal((uint64_t)&v89, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataPatchWithOptions", CFSTR("can't save grammar file"), v80);
LABEL_163:
  v67 = 0;
LABEL_127:
  Mutable = 0;
  v28 = 0;
  v17 = 0;
  v44 = 0;
LABEL_128:
  v11 = 0;
LABEL_129:
  v7 = 0;
  v62 = (_QWORD *)a7;
LABEL_130:
  v77 = v89;
  if (v62)
  {
    *v62 = AMSupportSafeRetain();
    v77 = v89;
  }
  if (v77)
  {
    CFRelease(v77);
    v89 = 0;
  }
  if (v9)
    CFRelease(v9);
  if (cfa)
  {
    CFRelease(cfa);
    cfa = 0;
  }
  if (v10)
    CFRelease(v10);
  if (v67)
    CFRelease(v67);
  if (v28)
    CFRelease(v28);
  if (v44)
    CFRelease(v44);
  if (Mutable)
    CFRelease(Mutable);
  if (v11)
    CFRelease(v11);
  if (v88)
    CFRelease(v88);
  if (v17)
    CFRelease(v17);
  return v7;
}

CFStringRef _AMFDRCopyHashHexString(unsigned __int8 *a1, unsigned int a2)
{
  uint64_t v2;
  unsigned int v3;
  _OWORD v5[8];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  memset(v5, 0, sizeof(v5));
  v2 = 0;
  if (a2)
  {
    do
    {
      v3 = *a1++;
      *((_BYTE *)v5 + v2) = _AMFDRCopyHashHexString_kAsciiHexChars[(unint64_t)v3 >> 4];
      *((_BYTE *)v5 + (v2 + 1)) = _AMFDRCopyHashHexString_kAsciiHexChars[v3 & 0xF];
      v2 += 2;
    }
    while (2 * a2 != v2);
    v2 = v2;
  }
  *((_BYTE *)v5 + v2) = 0;
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], (const char *)v5, 0x8000100u);
}

CFTypeRef AMFDRDataMultiPatchWithOptions(_QWORD *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, uint64_t a6, CFErrorRef *a7)
{
  char vars0;

  if (!a6)
    return _AMFDRDataMultiPatchInternal(a1, a2, a3, a4, 0, a5, a7);
  if (a7)
    AMFDRErrorPushInternal((uint64_t)a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMultiPatchWithOptions", CFSTR("optionsArray isn't supported!!"), vars0);
  return 0;
}

uint64_t AMFDRDataUpdateMetadataWithOptions(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 208))();
}

uint64_t AMFDRDataMultiUpdateMetadataWithOptions(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 216))();
}

CFTypeRef AMFDRDataCreateRepairConfigurationAsidMetadata(const __CFArray *cf, char a2, const __CFArray *a3, uint64_t a4)
{
  const __CFArray *v4;
  CFTypeID v5;
  const __CFAllocator *v6;
  __CFDictionary *Mutable;
  const __CFArray *v8;
  CFDataRef v9;
  CFStringRef v10;
  const __CFArray *v11;
  CFIndex v12;
  int v13;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  CFTypeID v16;
  const __CFString *v17;
  const __CFString *v18;
  CFTypeID v19;
  int v20;
  const __CFString *v21;
  const __CFString *v22;
  CFTypeID v23;
  const __CFArray *ArrayBySeparatingStrings;
  const void *v25;
  const void *v26;
  CFStringRef v27;
  const void *v28;
  CFDataRef ExternalRepresentation;
  CFTypeID v30;
  const UInt8 *BytePtr;
  int Length;
  int v33;
  const __CFString *v34;
  const __CFString *v35;
  CFTypeID v36;
  CFDataRef v37;
  CFTypeID v38;
  const UInt8 *v39;
  int v40;
  int v41;
  const void *v42;
  const void *v43;
  CFTypeID v44;
  const __CFDictionary *v45;
  const __CFDictionary *v46;
  CFTypeID v47;
  CFIndex v48;
  const void **v49;
  const void **v50;
  uint64_t v51;
  const __CFData *v52;
  const __CFAllocator *v53;
  const __CFString *v54;
  CFTypeID v55;
  const __CFData *v56;
  const UInt8 *v57;
  int v58;
  const __CFNumber *v59;
  CFTypeID v60;
  CFDataRef v61;
  CFTypeID v62;
  char v63;
  const void *v64;
  const void *v65;
  CFTypeID v66;
  const void *v67;
  const void *v68;
  CFTypeID v69;
  int v70;
  int v71;
  const UInt8 *v72;
  CFIndex v73;
  CFDataRef v74;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const void *Value;
  const void *v78;
  CFTypeRef v79;
  CFDataRef v80;
  const __CFData *v81;
  const __CFArray *v82;
  CFTypeID v83;
  CFTypeRef v84;
  const __CFString *format;
  const __CFString *v87;
  char v88;
  char v89;
  const __CFArray *v91;
  __CFDictionary *v92;
  const __CFString *v93;
  CFStringRef v94;
  const __CFData *v96;
  const __CFData *v97;
  CFDataRef cfa;
  const __CFArray *v100;
  const __CFArray *v101;
  CFIndex Count;
  CFIndex v103;
  const __CFAllocator *v104;
  char IntValue;
  unsigned int v106;
  void *v107;
  uint64_t *v108;
  int valuePtr;
  uint64_t *v110;
  uint64_t *v111;
  uint64_t *v112;
  CFRange v113;
  CFRange v114;
  CFRange v115;

  v4 = cf;
  v107 = 0;
  v108 = 0;
  v106 = 0;
  if (!cf || (v5 = CFGetTypeID(cf), v5 != CFArrayGetTypeID()))
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("asidMetadataInternalBlob has wrong type %@"), (char)v4);
    v8 = 0;
    v82 = 0;
    v94 = 0;
    v79 = 0;
    Mutable = 0;
    goto LABEL_124;
  }
  v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("outAsidMetadata create failed"), v88);
    v8 = 0;
LABEL_169:
    v82 = 0;
    v94 = 0;
    v79 = 0;
    goto LABEL_124;
  }
  v8 = CFArrayCreateMutable(v6, 0, MEMORY[0x24BDBD690]);
  if (!v8)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("missingSupm create failed"), v88);
    goto LABEL_169;
  }
  v101 = v4;
  Count = CFArrayGetCount(v4);
  if (Count < 1)
  {
    v11 = 0;
    v10 = 0;
    v9 = 0;
    cfa = 0;
LABEL_113:
    v97 = v9;
    v94 = v10;
    v100 = v11;
    if (CFArrayGetCount(v8) >= 1)
    {
      AMSupportLogInternal();
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, i);
          Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("DataClassInstance"));
          v78 = CFDictionaryGetValue(ValueAtIndex, CFSTR("supm"));
          v115.length = CFArrayGetCount(v8);
          v115.location = 0;
          if (CFArrayContainsValue(v8, v115, v78))
          {
            CFDictionaryRemoveValue(Mutable, Value);
            AMSupportLogInternal();
          }
          v4 = v101;
        }
      }
    }
    v79 = CFRetain(Mutable);
    v9 = v97;
LABEL_120:
    v80 = cfa;
    if (!v9)
      goto LABEL_122;
    goto LABEL_121;
  }
  v104 = v6;
  cfa = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v91 = v8;
  v92 = Mutable;
  while (1)
  {
    AMFDREncodeMetadataDestroy(&v108);
    v13 = AMFDREncodeRepairConfigurationBegin(&v108);
    if (v13)
    {
      v94 = v10;
      v100 = v11;
      AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("AMFDREncodeRepairConfigurationBegin for Collection failed 0x%X"), v13);
      goto LABEL_142;
    }
    v14 = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, v12);
    v15 = v14;
    if (!v14 || (v16 = CFGetTypeID(v14), v16 != CFDictionaryGetTypeID()))
    {
      v94 = v10;
      v100 = v11;
      AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("asidMetadata has wrong type %@"), (char)v15);
LABEL_142:
      v79 = 0;
      goto LABEL_120;
    }
    v17 = (const __CFString *)CFDictionaryGetValue(v15, CFSTR("Version"));
    v18 = v17;
    if (!v17 || (v19 = CFGetTypeID(v17), v19 != CFStringGetTypeID()))
    {
      v94 = v10;
      v100 = v11;
      AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("versionStr has wrong type %@"), (char)v18);
      goto LABEL_142;
    }
    IntValue = -86;
    IntValue = CFStringGetIntValue(v18);
    v20 = AMFDREncodeRepairConfigurationAddData(&v108, 2, (uint64_t)&IntValue, 1);
    if (v20)
    {
      v94 = v10;
      v100 = v11;
      AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("add version failed 0x%X"), v20);
      goto LABEL_162;
    }
    v103 = v12;
    v21 = (const __CFString *)CFDictionaryGetValue(v15, CFSTR("DataClassInstance"));
    v22 = v21;
    if (!v21 || (v23 = CFGetTypeID(v21), v23 != CFStringGetTypeID()))
    {
      v94 = v10;
      v100 = v11;
      v89 = (char)v22;
      format = CFSTR("dataClassInstance has wrong type %@");
      goto LABEL_147;
    }
    if (v11)
      CFRelease(v11);
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v104, v22, CFSTR(":"));
    v11 = ArrayBySeparatingStrings;
    if (!ArrayBySeparatingStrings || CFArrayGetCount(ArrayBySeparatingStrings) != 2)
    {
      v94 = v10;
      v100 = v11;
      AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("Could not split dataClassInstance"), v88);
      goto LABEL_162;
    }
    if (v10)
      CFRelease(v10);
    v25 = CFArrayGetValueAtIndex(v11, 0);
    v26 = CFArrayGetValueAtIndex(v11, 1);
    v27 = CFStringCreateWithFormat(v104, 0, CFSTR("%@-%@"), v25, v26);
    if (!v27)
    {
      v100 = v11;
      AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("tmpDataClassInstance allocation failed"), v88);
      v94 = 0;
      goto LABEL_162;
    }
    v10 = v27;
    if (a3)
    {
      v113.length = CFArrayGetCount(a3);
      v113.location = 0;
      if (CFArrayContainsValue(a3, v113, v10))
        break;
    }
    v100 = v11;
    if (v9)
      CFRelease(v9);
    ExternalRepresentation = CFStringCreateExternalRepresentation(v104, v22, 0x8000100u, 0x20u);
    v9 = ExternalRepresentation;
    if (!ExternalRepresentation || (v30 = CFGetTypeID(ExternalRepresentation), v30 != CFDataGetTypeID()))
    {
LABEL_139:
      v94 = v10;
      v89 = (char)v9;
      format = CFSTR("valueData has wrong type %@");
LABEL_147:
      AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", format, v89);
      goto LABEL_162;
    }
    BytePtr = CFDataGetBytePtr(v9);
    Length = CFDataGetLength(v9);
    v33 = AMFDREncodeRepairConfigurationAddData(&v108, 0, (uint64_t)BytePtr, Length);
    if (v33)
    {
      v94 = v10;
      AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("add data class failed 0x%X"), v33);
      goto LABEL_162;
    }
    v34 = (const __CFString *)CFDictionaryGetValue(v15, CFSTR("type"));
    v35 = v34;
    if (!v34 || (v36 = CFGetTypeID(v34), v36 != CFStringGetTypeID()))
    {
      v94 = v10;
      v89 = (char)v35;
      format = CFSTR("type has wrong type %@");
      goto LABEL_147;
    }
    CFRelease(v9);
    v37 = CFStringCreateExternalRepresentation(v104, v35, 0x8000100u, 0x20u);
    v9 = v37;
    if (!v37)
      goto LABEL_139;
    v38 = CFGetTypeID(v37);
    if (v38 != CFDataGetTypeID())
      goto LABEL_139;
    v39 = CFDataGetBytePtr(v9);
    v40 = CFDataGetLength(v9);
    v41 = AMFDREncodeRepairConfigurationAddData(&v108, 0, (uint64_t)v39, v40);
    if (v41)
    {
      v94 = v10;
      AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("add type failed 0x%X"), v41);
      goto LABEL_162;
    }
    v42 = CFDictionaryGetValue(v15, CFSTR("dcls"));
    v43 = v42;
    if (!v42 || (v44 = CFGetTypeID(v42), v44 != CFArrayGetTypeID()))
    {
      v94 = v10;
      v89 = (char)v43;
      format = CFSTR("dcls has wrong type %@");
      goto LABEL_147;
    }
    if ((_AMFDRDataPrepareRepairConfigurationContextArrayData(CFSTR("dcls"), v43, (const __CFData *)&v108) & 1) == 0)
    {
      v94 = v10;
      v87 = CFSTR("create dcls failed");
      goto LABEL_161;
    }
    if (CFStringCompare(v35, CFSTR("Primary"), 0))
      goto LABEL_77;
    v45 = (const __CFDictionary *)CFDictionaryGetValue(v15, CFSTR("pdct"));
    v46 = v45;
    v111 = 0;
    v112 = 0;
    v110 = 0;
    v96 = v9;
    if (!v45
      || (v47 = CFGetTypeID(v45), v47 != CFDictionaryGetTypeID())
      || !v108
      || (v112 = v108, AMFDREncodeRepairConfigurationBegin(&v111)))
    {
      AMSupportLogInternal();
      v49 = 0;
      goto LABEL_103;
    }
    v48 = CFDictionaryGetCount(v46);
    v49 = (const void **)malloc_type_malloc(8 * v48, 0x80040B8603338uLL);
    if (!v49)
    {
      AMSupportLogInternal();
LABEL_103:
      v50 = 0;
LABEL_104:
      v52 = 0;
      goto LABEL_111;
    }
    v50 = (const void **)malloc_type_malloc(8 * v48, 0x80040B8603338uLL);
    if (!v50)
    {
      AMSupportLogInternal();
      goto LABEL_104;
    }
    CFDictionaryGetKeysAndValues(v46, v49, v50);
    if (v48 < 1)
    {
      v53 = v104;
      if (AMFDREncodeRepairConfigurationAddSequence(&v111, &v111))
      {
        v52 = 0;
      }
      else
      {
LABEL_65:
        v61 = CFStringCreateExternalRepresentation(v53, CFSTR("pdct"), 0x8000100u, 0x20u);
        v52 = v61;
        if (v61)
        {
          v62 = CFGetTypeID(v61);
          if (v62 == CFDataGetTypeID())
          {
            CFDataGetBytePtr(v52);
            CFDataGetLength(v52);
            if (!AMFDREncodeRepairConfigurationAddSequenceWithKey(&v111)
              && !AMFDREncodeRepairConfigurationAddSequence(&v111, &v112))
            {
              v63 = 1;
              goto LABEL_70;
            }
          }
        }
      }
    }
    else
    {
      v93 = v10;
      v51 = 0;
      v52 = 0;
      v53 = v104;
      do
      {
        AMFDREncodeMetadataDestroy(&v110);
        if (AMFDREncodeRepairConfigurationBegin(&v110))
          goto LABEL_98;
        v54 = (const __CFString *)v49[v51];
        if (!v54)
          goto LABEL_98;
        v55 = CFGetTypeID(v49[v51]);
        if (v55 != CFStringGetTypeID())
          goto LABEL_98;
        if (v52)
          CFRelease(v52);
        v56 = CFStringCreateExternalRepresentation(v53, v54, 0x8000100u, 0x20u);
        v52 = v56;
        if (!v56
          || (v57 = CFDataGetBytePtr(v56),
              v58 = CFDataGetLength(v52),
              AMFDREncodeRepairConfigurationAddData(&v110, 0, (uint64_t)v57, v58))
          || (v59 = (const __CFNumber *)v50[v51]) == 0
          || (v60 = CFGetTypeID(v50[v51]), v60 != CFNumberGetTypeID())
          || (valuePtr = 0, !CFNumberGetValue(v59, kCFNumberIntType, &valuePtr))
          || AMFDREncodeRepairConfigurationAddData(&v110, 3, (uint64_t)&valuePtr, 1)
          || (v53 = v104, AMFDREncodeRepairConfigurationAddSequence(&v110, &v111)))
        {
LABEL_98:
          AMSupportLogInternal();
          v63 = 0;
          v10 = v93;
          goto LABEL_70;
        }
        ++v51;
      }
      while (v48 != v51);
      if (!AMFDREncodeRepairConfigurationAddSequence(&v111, &v111))
      {
        CFRelease(v52);
        v10 = v93;
        goto LABEL_65;
      }
      v10 = v93;
    }
    AMSupportLogInternal();
LABEL_111:
    v63 = 0;
LABEL_70:
    AMFDREncodeMetadataDestroy(&v111);
    AMFDREncodeMetadataDestroy(&v110);
    if (v49)
      free(v49);
    if (v50)
      free(v50);
    if (v52)
      CFRelease(v52);
    v8 = v91;
    Mutable = v92;
    v9 = v96;
    if ((v63 & 1) == 0)
    {
      v94 = v10;
      v87 = CFSTR("_AMFDRDataPrepareRepairConfigurationContextPdct failed");
      goto LABEL_161;
    }
LABEL_77:
    v64 = CFDictionaryGetValue(v15, CFSTR("manp"));
    if (v64)
    {
      v65 = v64;
      v66 = CFGetTypeID(v64);
      if (v66 == CFArrayGetTypeID()
        && (_AMFDRDataPrepareRepairConfigurationContextArrayData(CFSTR("manp"), v65, (const __CFData *)&v108) & 1) == 0)
      {
        v94 = v10;
        v87 = CFSTR("create manp failed");
LABEL_161:
        AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", v87, v88);
        goto LABEL_162;
      }
    }
    v67 = CFDictionaryGetValue(v15, CFSTR("asid"));
    if (v67)
    {
      v68 = v67;
      v69 = CFGetTypeID(v67);
      if (v69 == CFArrayGetTypeID()
        && (_AMFDRDataPrepareRepairConfigurationContextArrayData(CFSTR("asid"), v68, (const __CFData *)&v108) & 1) == 0)
      {
        v94 = v10;
        AMSupportLogInternal();
        goto LABEL_162;
      }
    }
    v70 = AMFDREncodeRepairConfigurationAddSequence(&v108, &v108);
    if (v70)
    {
      v94 = v10;
      AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("AMFDREncodeRepairConfigurationAddSequence failed 0x%X"), v70);
      goto LABEL_162;
    }
    if (v107)
    {
      free(v107);
      v107 = 0;
    }
    v71 = AMFDREncodeRepairConfigurationEnd(&v108, &v107, &v106);
    if (v71)
    {
      v94 = v10;
      AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("AMFDREncodeRepairConfigurationEnd failed 0x%X"), v71);
      goto LABEL_162;
    }
    v72 = (const UInt8 *)v107;
    if (!v107)
      goto LABEL_95;
    v73 = v106;
    v11 = v100;
    if (v106)
    {
      if (cfa)
      {
        CFRelease(cfa);
        v72 = (const UInt8 *)v107;
        v73 = v106;
      }
      v74 = CFDataCreate(v104, v72, v73);
      if (!v74)
      {
        v94 = v10;
        AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("failed to create repairConfigurationData"), v88);
        v80 = 0;
        goto LABEL_163;
      }
      v112 = 0;
      cfa = v74;
      AMSupportBase64Encode();
      if (!v112)
      {
        v94 = v10;
        AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("asidMetadata AMSupportBase64Encode failed"), v88);
        goto LABEL_162;
      }
      CFDictionaryAddValue(Mutable, v22, v112);
      if (v112)
        CFRelease(v112);
LABEL_95:
      v11 = v100;
    }
LABEL_96:
    v4 = v101;
    v12 = v103 + 1;
    if (v103 + 1 == Count)
      goto LABEL_113;
  }
  if ((a2 & 1) != 0)
  {
    AMSupportLogInternal();
    v28 = CFDictionaryGetValue(v15, CFSTR("supm"));
    v114.length = CFArrayGetCount(v8);
    v114.location = 0;
    if (!CFArrayContainsValue(v8, v114, v28))
      CFArrayAppendValue(v8, v28);
    goto LABEL_96;
  }
  v100 = v11;
  v94 = v10;
  AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("'%@' is missing"), (char)v10);
LABEL_162:
  v80 = cfa;
LABEL_163:
  v79 = 0;
  if (v9)
  {
LABEL_121:
    v81 = v80;
    CFRelease(v9);
    v80 = v81;
  }
LABEL_122:
  v82 = v100;
  if (v80)
    CFRelease(v80);
LABEL_124:
  if (v107)
  {
    free(v107);
    v107 = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v94)
    CFRelease(v94);
  if (v8)
    CFRelease(v8);
  if (v82)
    CFRelease(v82);
  AMFDREncodeMetadataDestroy(&v108);
  if (v79)
  {
    v83 = CFGetTypeID(v79);
    if (v83 == CFDictionaryGetTypeID())
    {
      v84 = CFRetain(v79);
    }
    else
    {
      AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("asidMetadata has wrong type %@"), (char)v79);
      v84 = 0;
    }
    CFRelease(v79);
  }
  else
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateRepairConfigurationAsidMetadata", CFSTR("asidMetadata has wrong type %@"), 0);
    return 0;
  }
  return v84;
}

CFDataRef AMFDRDataCreateRepairConfigurationSupmData(CFTypeRef cf)
{
  CFTypeID v2;
  const __CFString *Value;
  const __CFString *v4;
  CFTypeID v5;
  const __CFArray *v6;
  const __CFArray *v7;
  CFTypeID v8;
  const __CFArray *v9;
  const __CFArray *v10;
  CFTypeID v11;
  CFDataRef v12;
  void *v13;
  const __CFAllocator *v14;
  char IntValue;
  _DWORD length[3];
  int v18[2];

  *(_QWORD *)v18 = 0;
  memset(length, 0, sizeof(length));
  if (!cf)
    goto LABEL_23;
  v2 = CFGetTypeID(cf);
  if (v2 != CFDictionaryGetTypeID())
    goto LABEL_23;
  if (AMFDREncodeRepairConfigurationBegin(v18))
    goto LABEL_23;
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("Version"));
  v4 = Value;
  if (!Value)
    goto LABEL_23;
  v5 = CFGetTypeID(Value);
  if (v5 != CFStringGetTypeID())
    goto LABEL_23;
  IntValue = CFStringGetIntValue(v4);
  if (AMFDREncodeRepairConfigurationAddData(v18, 2, (uint64_t)&IntValue, 1))
    goto LABEL_23;
  v6 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("RepairConfigurationAsidMetadata"));
  v7 = v6;
  if (!v6)
    goto LABEL_23;
  v8 = CFGetTypeID(v6);
  if (v8 != CFArrayGetTypeID())
    goto LABEL_23;
  if (_AMFDRDataPrepareRepairConfigurationContextSupmSetData(*(uint64_t **)v18, v7, CFSTR("dcls")))
    goto LABEL_23;
  v9 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("RepairConfigurationAsidExceptionList"));
  if (v9)
  {
    v10 = v9;
    v11 = CFGetTypeID(v9);
    if (v11 != CFArrayGetTypeID()
      || _AMFDRDataPrepareRepairConfigurationContextSupmSetData(*(uint64_t **)v18, v10, CFSTR("xcld")))
    {
      goto LABEL_23;
    }
  }
  if (AMFDREncodeRepairConfigurationAddSequence((uint64_t **)v18, (uint64_t **)v18)
    || AMFDREncodeRepairConfigurationEnd(v18, &length[1], length))
  {
LABEL_23:
    AMSupportLogInternal();
    v12 = 0;
LABEL_19:
    v13 = *(void **)&length[1];
    goto LABEL_20;
  }
  v12 = 0;
  v13 = *(void **)&length[1];
  if (*(_QWORD *)&length[1] && length[0])
  {
    v14 = CFGetAllocator((CFTypeRef)*MEMORY[0x24BDBD240]);
    v12 = CFDataCreate(v14, *(const UInt8 **)&length[1], length[0]);
    if (!v12)
      AMSupportLogInternal();
    goto LABEL_19;
  }
LABEL_20:
  if (v13)
  {
    free(v13);
    *(_QWORD *)&length[1] = 0;
  }
  AMFDREncodeMetadataDestroy((_QWORD **)v18);
  return v12;
}

uint64_t _AMFDRDataPrepareRepairConfigurationContextSupmSetData(uint64_t *a1, CFArrayRef theArray, const __CFString *a3)
{
  CFIndex Count;
  uint64_t v6;
  const __CFAllocator *v7;
  CFIndex v8;
  CFDataRef v9;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v11;
  CFTypeID v12;
  const __CFString *Value;
  const __CFString *v14;
  CFTypeID v15;
  CFDataRef ExternalRepresentation;
  CFTypeID v17;
  const UInt8 *BytePtr;
  int Length;
  uint64_t v20;
  CFDataRef v21;
  const __CFData *v22;
  CFTypeID v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;

  v28 = 0;
  v29 = a1;
  Count = CFArrayGetCount(theArray);
  v6 = AMFDREncodeRepairConfigurationBegin(&v28);
  if ((_DWORD)v6)
  {
    v25 = v6;
    AMSupportLogInternal();
    v9 = 0;
LABEL_25:
    AMFDREncodeMetadataDestroy(&v28);
    goto LABEL_21;
  }
  v7 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if (Count >= 1)
  {
    v8 = 0;
    v9 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v8);
      v11 = ValueAtIndex;
      if (!ValueAtIndex)
        goto LABEL_24;
      v12 = CFGetTypeID(ValueAtIndex);
      if (v12 != CFDictionaryGetTypeID())
        goto LABEL_24;
      Value = (const __CFString *)CFDictionaryGetValue(v11, CFSTR("Tag"));
      v14 = Value;
      if (!Value)
        goto LABEL_24;
      v15 = CFGetTypeID(Value);
      if (v15 != CFStringGetTypeID())
        goto LABEL_24;
      if (v9)
        CFRelease(v9);
      ExternalRepresentation = CFStringCreateExternalRepresentation(v7, v14, 0x8000100u, 0x20u);
      v9 = ExternalRepresentation;
      if (!ExternalRepresentation || (v17 = CFGetTypeID(ExternalRepresentation), v17 != CFDataGetTypeID()))
      {
LABEL_24:
        AMSupportLogInternal();
        v25 = 0;
        goto LABEL_25;
      }
      BytePtr = CFDataGetBytePtr(v9);
      Length = CFDataGetLength(v9);
      v20 = AMFDREncodeRepairConfigurationAddData(&v28, 1, (uint64_t)BytePtr, Length);
      if ((_DWORD)v20)
        break;
      if (Count == ++v8)
        goto LABEL_16;
    }
    v27 = v20;
    AMSupportLogInternal();
    v25 = v27;
    goto LABEL_25;
  }
  v9 = 0;
LABEL_16:
  v21 = CFStringCreateExternalRepresentation(v7, a3, 0x8000100u, 0x20u);
  v22 = v21;
  if (v21)
  {
    v23 = CFGetTypeID(v21);
    if (v23 == CFDataGetTypeID())
    {
      CFDataGetBytePtr(v22);
      CFDataGetLength(v22);
      v24 = AMFDREncodeRepairConfigurationAddSetWithKey(&v28);
      if ((_DWORD)v24)
      {
        v25 = v24;
      }
      else
      {
        v25 = AMFDREncodeRepairConfigurationAddSequence(&v28, &v29);
        if (!(_DWORD)v25)
        {
LABEL_20:
          AMFDREncodeMetadataDestroy(&v28);
          CFRelease(v22);
          goto LABEL_21;
        }
      }
      AMSupportLogInternal();
      goto LABEL_20;
    }
    AMSupportLogInternal();
    v25 = 0;
    goto LABEL_20;
  }
  AMSupportLogInternal();
  AMFDREncodeMetadataDestroy(&v28);
  v25 = 0;
LABEL_21:
  if (v9)
    CFRelease(v9);
  return v25;
}

BOOL AMFDRDataAppendPermissionUpdateAsidMetadata(const __CFArray *a1, const __CFArray *a2, uint64_t a3, __CFString *a4, uint64_t a5)
{
  CFMutableStringRef Mutable;
  __CFString *v11;
  CFTypeID v12;
  CFTypeID v13;
  CFIndex Count;
  BOOL v15;
  CFIndex v16;
  const __CFString *ValueAtIndex;
  const __CFString *v18;
  CFTypeID v19;
  const __CFString *v20;
  const __CFString *v21;
  CFTypeID v22;
  const __CFString *v24;
  const __CFString *v25;
  uint64_t v26;
  CFIndex v27;
  void *value[2];
  void *v29[2];
  __int128 v30;
  const __CFString *v31;
  char v32;
  char v33;
  uint64_t v34;
  __CFString *theString;

  if (!a3)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataAppendPermissionUpdateAsidMetadata", CFSTR("amfdrRemote is NULL"), v32);
    return 0;
  }
  if (*(uint64_t (***)(int, int, int, int))(a3 + 48) != AMFDRHTTPStore)
  {
    v25 = CFSTR("amfdr is not remote");
LABEL_35:
    v31 = v25;
    *(_OWORD *)v29 = 0u;
    v30 = 0u;
    *(_OWORD *)value = 0u;
    v26 = a5;
    v27 = 1;
LABEL_37:
    AMFDRErrorPushInternal(v26, v27, 0, 0, 0, 0, 0, 0, value[0], value[1], v29[0], v29[1], (void *)v30, *((void **)&v30 + 1), (uint64_t)"AMFDRDataAppendPermissionUpdateAsidMetadata", v31, v32);
    return 0;
  }
  if (!*(_QWORD *)(a3 + 16))
  {
    v25 = CFSTR("invalid optionsDict");
    goto LABEL_35;
  }
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  if (!Mutable)
  {
    v31 = CFSTR("permissions allocation failed");
    *(_OWORD *)v29 = 0u;
    v30 = 0u;
    *(_OWORD *)value = 0u;
    v26 = a5;
    v27 = 2;
    goto LABEL_37;
  }
  v11 = Mutable;
  if (a1 && (v12 = CFGetTypeID(a1), v12 == CFArrayGetTypeID()))
  {
    if (a2 && (v13 = CFGetTypeID(a2), v13 == CFArrayGetTypeID()))
    {
      Count = CFArrayGetCount(a1);
      if (Count == CFArrayGetCount(a2))
      {
        theString = a4;
        if (Count < 1)
        {
          v15 = 1;
LABEL_20:
          if (CFStringGetLength(theString))
            CFStringAppend(theString, CFSTR(";"));
          CFStringAppend(theString, v11);
        }
        else
        {
          v34 = a5;
          v15 = 0;
          v16 = 0;
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, v16);
            v18 = ValueAtIndex;
            if (!ValueAtIndex || (v19 = CFGetTypeID(ValueAtIndex), v19 != CFStringGetTypeID()))
            {
              v33 = (char)v18;
              v24 = CFSTR("dataClass has wrong type '%@");
LABEL_27:
              AMFDRErrorPushInternal(v34, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataAppendPermissionUpdateAsidMetadata", v24, v33);
              goto LABEL_23;
            }
            v20 = (const __CFString *)CFArrayGetValueAtIndex(a2, v16);
            v21 = v20;
            if (!v20 || (v22 = CFGetTypeID(v20), v22 != CFStringGetTypeID()))
            {
              v33 = (char)v21;
              v24 = CFSTR("dataInstance has wrong type '%@");
              goto LABEL_27;
            }
            if ((AMFDRDataAppendPermissionsString((__CFString *)a3, 0xCu, v18, v21, v11) & 1) == 0)
              break;
            v15 = ++v16 >= Count;
            if (Count == v16)
              goto LABEL_20;
          }
          AMFDRErrorPushInternal(v34, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataAppendPermissionUpdateAsidMetadata", CFSTR("AMFDRDataAppendPermissionsString failed"), v32);
        }
        goto LABEL_23;
      }
      AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataAppendPermissionUpdateAsidMetadata", CFSTR("input array count mismatched"), v32);
    }
    else
    {
      AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataAppendPermissionUpdateAsidMetadata", CFSTR("dataInstances has wrong type %@"), (char)a2);
    }
  }
  else
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataAppendPermissionUpdateAsidMetadata", CFSTR("dataClasses has wrong type %@"), (char)a1);
  }
  v15 = 0;
LABEL_23:
  CFRelease(v11);
  return v15;
}

uint64_t AMFDRDataUpdateAsidMetadata(const void *a1, const void *a2, const void *a3, const void *a4, uint64_t a5, const __CFString *a6, uint64_t a7)
{
  const __CFDictionary *v10;
  const __CFString *v15;
  CFTypeID v16;
  CFTypeID v17;
  CFTypeID v18;
  CFTypeID v19;
  CFTypeID v20;
  CFIndex Count;
  const __CFBoolean *Value;
  const __CFBoolean *v23;
  CFTypeID v24;
  char v25;
  uint64_t v26;
  const __CFString *v28;
  const __CFString *v29;
  char v30;
  CFTypeRef cf;

  cf = 0;
  if (!a5)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataUpdateAsidMetadata", CFSTR("amfdrRemote is NULL"), v30);
    return 0;
  }
  if (*(uint64_t (***)(int, int, int, int))(a5 + 48) != AMFDRHTTPStore)
  {
    v29 = CFSTR("amfdr is not remote");
LABEL_42:
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataUpdateAsidMetadata", v29, v30);
    v15 = 0;
    goto LABEL_38;
  }
  v10 = *(const __CFDictionary **)(a5 + 16);
  if (!v10)
  {
    v29 = CFSTR("invalid optionsDict");
    goto LABEL_42;
  }
  v15 = (const __CFString *)_CFDictionaryCopyValue(v10, CFSTR("Permissions"));
  if (!a6 || (v16 = CFGetTypeID(a6), v16 != CFStringGetTypeID()))
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataUpdateAsidMetadata", CFSTR("permissions has wrong type %@"), (char)a6);
    goto LABEL_38;
  }
  if (!a1 || (v17 = CFGetTypeID(a1), v17 != CFArrayGetTypeID()))
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataUpdateAsidMetadata", CFSTR("dataclasses has wrong type %@"), (char)a1);
    goto LABEL_38;
  }
  if (!a2 || (v18 = CFGetTypeID(a2), v18 != CFArrayGetTypeID()))
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataUpdateAsidMetadata", CFSTR("dataInstances has wrong type %@"), (char)a2);
    goto LABEL_38;
  }
  if (!a3 || (v19 = CFGetTypeID(a3), v19 != CFArrayGetTypeID()))
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataUpdateAsidMetadata", CFSTR("metadata has wrong type %@"), (char)a3);
    goto LABEL_38;
  }
  if (!a4 || (v20 = CFGetTypeID(a4), v20 != CFArrayGetTypeID()))
  {
    v30 = (char)a4;
    v28 = CFSTR("metadataOptions has wrong type %@");
    goto LABEL_37;
  }
  Count = CFArrayGetCount((CFArrayRef)a1);
  if (Count != CFArrayGetCount((CFArrayRef)a2)
    || Count != CFArrayGetCount((CFArrayRef)a3)
    || Count != CFArrayGetCount((CFArrayRef)a4))
  {
    v28 = CFSTR("input array count mismatched");
LABEL_37:
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataUpdateAsidMetadata", v28, v30);
    goto LABEL_38;
  }
  AMFDRSetOption(a5, CFSTR("Permissions"), a6);
  Value = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a5 + 16), CFSTR("UseSikDataInstance"));
  if (Value)
  {
    v23 = Value;
    v24 = CFGetTypeID(Value);
    if (v24 == CFBooleanGetTypeID())
      CFBooleanGetValue(v23);
  }
  AMSupportLogInternal();
  v25 = (*(uint64_t (**)(uint64_t, const void *, const void *, const void *, const void *, CFTypeRef *))(*(_QWORD *)(a5 + 48) + 216))(a5, a1, a2, a3, a4, &cf);
  if (!cf && (v25 & 1) != 0)
  {
    v26 = 1;
    goto LABEL_23;
  }
  AMFDRErrorPushInternal(a7, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataUpdateAsidMetadata", CFSTR("AMFDRDataMultiUpdateMetadataWithOptions failed with error %@"), (char)cf);
LABEL_38:
  v26 = 0;
LABEL_23:
  if (*(uint64_t (***)(int, int, int, int))(a5 + 48) == AMFDRHTTPStore && *(_QWORD *)(a5 + 16))
    AMFDRSetOption(a5, CFSTR("Permissions"), v15);
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v15)
    CFRelease(v15);
  return v26;
}

BOOL AMFDRDataCopyAsidMetadataParameters(CFTypeRef cf, CFTypeRef *a2, CFTypeRef *a3, CFTypeRef *a4, CFTypeRef *a5, uint64_t a6)
{
  CFTypeID v11;
  uint64_t Count;
  const __CFAllocator *v13;
  CFMutableArrayRef v14;
  CFMutableArrayRef v15;
  const void **v16;
  BOOL v17;
  uint64_t v18;
  CFMutableDictionaryRef v19;
  __CFDictionary *v20;
  CFArrayRef ArrayBySeparatingStrings;
  const CFDictionaryValueCallBacks *v22;
  const __CFString *v23;
  const void *ValueAtIndex;
  const void *v25;
  CFTypeID v26;
  const void *v27;
  const void *v28;
  CFTypeID v29;
  __CFDictionary *v30;
  const void *v31;
  CFTypeID v32;
  const __CFString *format;
  const __CFString *v35;
  char v36;
  char v37;
  char v38;
  uint64_t v39;
  CFTypeRef *v40;
  CFTypeRef *v41;
  CFTypeRef *v42;
  CFMutableArrayRef theArray;
  const void **v45;
  __CFArray *v46;
  CFMutableArrayRef v47;
  CFMutableArrayRef Mutable;
  void *v49;

  if (!cf || (v11 = CFGetTypeID(cf), v11 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", CFSTR("asidMetadata has wrong type %@"), (char)cf);
    return 0;
  }
  v40 = a3;
  v41 = a4;
  v42 = a5;
  Count = CFDictionaryGetCount((CFDictionaryRef)cf);
  v13 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", CFSTR("dataClasses allocation failed"), v36);
    return 0;
  }
  v47 = CFArrayCreateMutable(v13, 0, MEMORY[0x24BDBD690]);
  if (!v47)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", CFSTR("dataInstances allocation failed"), v36);
    CFRelease(Mutable);
    return 0;
  }
  v14 = CFArrayCreateMutable(v13, Count, MEMORY[0x24BDBD690]);
  if (!v14)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", CFSTR("multiUpdateMetadataOptions allocation failed"), v36);
    ArrayBySeparatingStrings = 0;
    v15 = 0;
LABEL_67:
    v20 = 0;
    v19 = 0;
    v17 = 0;
    goto LABEL_38;
  }
  v15 = CFArrayCreateMutable(v13, Count, MEMORY[0x24BDBD690]);
  if (!v15)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", CFSTR("multiUpdateMetadata allocation failed"), v36);
    ArrayBySeparatingStrings = 0;
    goto LABEL_67;
  }
  v46 = v14;
  v49 = malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  if (!v49)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", CFSTR("dictKeysBuffer allocation failed"), v36);
LABEL_70:
    ArrayBySeparatingStrings = 0;
    v20 = 0;
    v19 = 0;
    v17 = 0;
    goto LABEL_38;
  }
  v16 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  if (!v16)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", CFSTR("dictValuesBuffer allocation failed"), v36);
    free(v49);
    goto LABEL_70;
  }
  theArray = v15;
  v45 = v16;
  CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, (const void **)v49, v16);
  if (Count < 1)
  {
    ArrayBySeparatingStrings = 0;
    v20 = 0;
    v19 = 0;
    v17 = 1;
LABEL_29:
    if (a2)
      *a2 = CFRetain(Mutable);
    v14 = v46;
    v15 = theArray;
    if (v40)
      *v40 = CFRetain(v47);
    if (v41)
      *v41 = CFRetain(theArray);
    if (v42)
      *v42 = CFRetain(v46);
    goto LABEL_37;
  }
  v39 = a6;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  ArrayBySeparatingStrings = 0;
  v22 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
  while (1)
  {
    v23 = (const __CFString *)*((_QWORD *)v49 + v18);
    if (ArrayBySeparatingStrings)
      CFRelease(ArrayBySeparatingStrings);
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v13, v23, CFSTR(":"));
    if (CFArrayGetCount(ArrayBySeparatingStrings) != 2)
    {
      v38 = CFArrayGetCount(ArrayBySeparatingStrings);
      AMFDRErrorPushInternal(v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", CFSTR("dataClassInstance has wrong size '%ld"), v38);
      goto LABEL_52;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
    v25 = ValueAtIndex;
    if (!ValueAtIndex || (v26 = CFGetTypeID(ValueAtIndex), v26 != CFStringGetTypeID()))
    {
      v37 = (char)v25;
      format = CFSTR("dataClass has wrong type '%@");
LABEL_51:
      AMFDRErrorPushInternal(v39, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", format, v37);
LABEL_52:
      v17 = 0;
LABEL_54:
      v14 = v46;
      goto LABEL_59;
    }
    CFArrayAppendValue(Mutable, v25);
    v27 = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 1);
    v28 = v27;
    if (!v27 || (v29 = CFGetTypeID(v27), v29 != CFStringGetTypeID()))
    {
      v37 = (char)v28;
      format = CFSTR("dataInstance has wrong type '%@");
      goto LABEL_51;
    }
    CFArrayAppendValue(v47, v28);
    if (v20)
      CFRelease(v20);
    v30 = CFDictionaryCreateMutable(v13, 0, MEMORY[0x24BDBD6A0], v22);
    v20 = v30;
    v14 = v46;
    if (!v30)
      break;
    CFDictionaryAddValue(v30, CFSTR("MetadataType"), CFSTR("System"));
    CFArrayAppendValue(v46, v20);
    if (v19)
      CFRelease(v19);
    v19 = CFDictionaryCreateMutable(v13, 0, MEMORY[0x24BDBD6A0], v22);
    if (!v19)
    {
      v35 = CFSTR("metadataDict allocation failed");
      goto LABEL_58;
    }
    v31 = v45[v18];
    if (!v31 || (v32 = CFGetTypeID(v45[v18]), v32 != CFStringGetTypeID()))
    {
      AMFDRErrorPushInternal(v39, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", CFSTR("b64Metadata has wrong type %@"), (char)v31);
      goto LABEL_54;
    }
    CFDictionaryAddValue(v19, CFSTR("asid"), v31);
    CFArrayAppendValue(theArray, v19);
    v17 = ++v18 >= Count;
    if (Count == v18)
      goto LABEL_29;
  }
  v35 = CFSTR("metaOptions allocation failed");
LABEL_58:
  AMFDRErrorPushInternal(v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyAsidMetadataParameters", v35, v36);
  v17 = 0;
LABEL_59:
  v15 = theArray;
LABEL_37:
  free(v49);
  free(v45);
LABEL_38:
  CFRelease(Mutable);
  CFRelease(v47);
  if (ArrayBySeparatingStrings)
    CFRelease(ArrayBySeparatingStrings);
  if (v14)
    CFRelease(v14);
  if (v15)
    CFRelease(v15);
  if (v20)
    CFRelease(v20);
  if (v19)
    CFRelease(v19);
  return v17;
}

uint64_t AMFDRDataCopyRawDataAndManifests(_QWORD *a1, uint64_t a2, uint64_t a3, int a4, CFTypeRef *a5, CFTypeRef *a6, uint64_t *a7, uint64_t a8)
{
  const void *v9;
  char v10;
  const __CFData *v15;
  const __CFData *v16;
  uint64_t v17;
  const __CFString *v19;
  char v20;
  CFTypeRef cf;
  CFTypeRef v22;
  CFTypeRef v23;

  v9 = a1;
  v23 = 0;
  cf = 0;
  v22 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyRawDataAndManifests", CFSTR("amfdr is NULL"), v20);
    v17 = 0;
    goto LABEL_19;
  }
  v10 = a2;
  if (!a2)
  {
    v19 = CFSTR("dataClass is NULL");
LABEL_31:
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyRawDataAndManifests", v19, v20);
LABEL_33:
    v17 = 0;
    v9 = 0;
    goto LABEL_19;
  }
  if (!a3)
  {
    v19 = CFSTR("dataInstance is NULL");
    goto LABEL_31;
  }
  if (!a5)
  {
    v19 = CFSTR("outData is NULL");
    goto LABEL_31;
  }
  if (!a6)
  {
    v19 = CFSTR("outDeviceManifest is NULL");
    goto LABEL_31;
  }
  v15 = (const __CFData *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(a1[6] + 16))(a1, a2, a3, a8);
  if (!v15)
  {
    AMFDRErrorPushInternal(a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyRawDataAndManifests", CFSTR("failed to copy %@-%@"), v10);
    goto LABEL_33;
  }
  v16 = v15;
  if ((AMFDRDataCopyExtraManifests(v9, v15, &v23, &v22, a8) & 1) != 0)
  {
    if (v23)
    {
      if (a4)
      {
        v9 = (const void *)AMFDRDataDictCreateFromData((uint64_t)v9, v16, 1, a8);
        if (!v9)
        {
          AMFDRErrorPushInternal(a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyRawDataAndManifests", CFSTR("failed to copy dict for %@-%@"), v10);
          v17 = 0;
          goto LABEL_17;
        }
LABEL_14:
        *a5 = CFRetain(v9);
        *a6 = CFRetain(v23);
        if (a7)
          *a7 = AMSupportSafeRetain();
        v17 = 1;
        goto LABEL_17;
      }
      if ((_AMFDRDataCopyImg4StrippedValue(v9, v16, &cf, a8) & 1) != 0)
      {
        v9 = CFRetain(cf);
        goto LABEL_14;
      }
      AMFDRErrorPushInternal(a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyRawDataAndManifests", CFSTR("failed to copy data payload for %@-%@"), v10);
    }
    else
    {
      AMFDRErrorPushInternal(a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyRawDataAndManifests", CFSTR("AMFDRDataCopyExtraManifests failed to copy device manifest for %@-%@"), v10);
    }
  }
  else
  {
    AMFDRErrorPushInternal(a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCopyRawDataAndManifests", CFSTR(" AMFDRDataCopyExtraManifests failed to copy manifest for %@-%@"), v10);
  }
  v17 = 0;
  v9 = 0;
LABEL_17:
  CFRelease(v16);
  if (v23)
  {
    CFRelease(v23);
    v23 = 0;
  }
LABEL_19:
  if (v22)
  {
    CFRelease(v22);
    v22 = 0;
  }
  if (v9)
    CFRelease(v9);
  if (cf)
    CFRelease(cf);
  return v17;
}

uint64_t _AMFDRDataCopyUnCombinedValue(CFDictionaryRef *a1, int a2, CFDataRef theData, _QWORD *a4, uint64_t a5)
{
  const __CFData *v7;
  const UInt8 *BytePtr;
  unsigned int Length;
  uint64_t v12;
  const UInt8 *v13;
  unsigned int v14;
  const __CFData *v15;
  const __CFString *v16;
  const __CFAllocator *v17;
  const __CFData *v18;
  uint64_t MutableCopy;
  const __CFAllocator *v20;
  const __CFAllocator *v21;
  CFDataRef v22;
  CFDataRef v23;
  const __CFString *v25;
  const __CFString *v26;
  char v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  const UInt8 *v31;
  unsigned int v32;
  const UInt8 *v33;
  const __CFData *v34;

  v33 = 0;
  v34 = 0;
  v32 = 0;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  if (!a1)
  {
    v25 = CFSTR("amfdr is NULL");
LABEL_39:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyUnCombinedValue", v25, v27);
LABEL_44:
    MutableCopy = 0;
    v7 = 0;
    goto LABEL_30;
  }
  if (!a1[2])
  {
    v25 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_39;
  }
  v7 = theData;
  if (!theData)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyUnCombinedValue", CFSTR("valueData is NULL"), v27);
LABEL_49:
    MutableCopy = 0;
    goto LABEL_30;
  }
  if (!a4)
  {
    v25 = CFSTR("outValueData is NULL");
    goto LABEL_39;
  }
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(v7);
  v12 = AMFDRDecodeCombined((uint64_t)BytePtr, Length, &v33, &v32, &v31, &v30);
  if (a2 && v12)
  {
    v13 = CFDataGetBytePtr(v7);
    v14 = CFDataGetLength(v7);
    v12 = AMFDRDecodeFDR2Data((uint64_t)v13, v14, &v31, &v30, &v29, &v28);
  }
  if (v12)
  {
    if (a2)
    {
      if ((_AMFDRDataCopyImg4StrippedValue(a1, v7, &v34, a5) & 1) == 0)
      {
        AMFDRErrorPushInternal(a5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyUnCombinedValue", CFSTR("_AMFDRDataCopyImg4StrippedValue failed"), v27);
        goto LABEL_44;
      }
      v15 = v34;
      if (!v34)
      {
        v16 = CFSTR("strippedData is NULL");
LABEL_42:
        AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyUnCombinedValue", v16, v27);
        goto LABEL_44;
      }
    }
    else
    {
      v15 = v7;
    }
    v7 = 0;
    *a4 = CFRetain(v15);
LABEL_29:
    MutableCopy = 1;
    goto LABEL_30;
  }
  if (!v31)
  {
    v16 = CFSTR("foundData is NULL");
    goto LABEL_42;
  }
  if (!v30)
  {
    v16 = CFSTR("foundDataLength is 0");
    goto LABEL_42;
  }
  v17 = CFGetAllocator(a1);
  v18 = CFDataCreate(v17, v31, v30);
  v7 = v18;
  if (!a2)
  {
    v7 = 0;
    goto LABEL_23;
  }
  if (!v18)
  {
    v26 = CFSTR("dataToStrip is NULL");
LABEL_47:
    AMFDRErrorPushInternal(a5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyUnCombinedValue", v26, v27);
    goto LABEL_49;
  }
  if ((_AMFDRDataCopyImg4StrippedValue(a1, v18, &v34, a5) & 1) == 0)
  {
    v26 = CFSTR("_AMFDRDataCopyImg4StrippedValue failed");
    goto LABEL_47;
  }
  if (!v34)
  {
    AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataCopyUnCombinedValue", CFSTR("strippedData is NULL"), v27);
    goto LABEL_49;
  }
  v18 = (const __CFData *)CFRetain(v34);
LABEL_23:
  *a4 = v18;
  MutableCopy = 1;
  if (!CFDictionaryGetValue(a1[2], CFSTR("TrustObject")) && v33 && v32)
  {
    v20 = CFGetAllocator(a1);
    MutableCopy = (uint64_t)CFDictionaryCreateMutableCopy(v20, 0, a1[2]);
    if (MutableCopy)
    {
      v21 = CFGetAllocator(a1);
      v22 = CFDataCreate(v21, v33, v32);
      if (v22)
      {
        v23 = v22;
        CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, CFSTR("TrustObject"), v22);
        CFRelease(a1[2]);
        a1[2] = (CFDictionaryRef)CFRetain((CFTypeRef)MutableCopy);
        CFRelease((CFTypeRef)MutableCopy);
        CFRelease(v23);
        goto LABEL_29;
      }
      AMSupportLogInternal();
      CFRelease((CFTypeRef)MutableCopy);
      goto LABEL_49;
    }
    AMSupportLogInternal();
  }
LABEL_30:
  if (v34)
  {
    CFRelease(v34);
    v34 = 0;
  }
  if (v7)
    CFRelease(v7);
  return MutableCopy;
}

void _AMFDRDataMultiCopyCallbak(const __CFString *a1, const __CFData *a2, CFDictionaryRef **a3)
{
  CFDataRef v3;
  CFMutableDictionaryRef *v5;
  CFMutableDictionaryRef *v6;
  CFDictionaryRef *v7;
  const __CFAllocator *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFData *v11;
  const __CFString *format;
  char v13;
  void *value;
  CFTypeRef cf;
  const __CFString *v16;

  v16 = 0;
  value = 0;
  cf = 0;
  if (!a1)
  {
    AMSupportLogInternal();
    v3 = 0;
    goto LABEL_12;
  }
  v3 = a2;
  v5 = a3[2];
  if (!a2)
  {
    AMFDRErrorPushInternal((uint64_t)&value, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyCallbak", CFSTR("rawData is NULL"), v13);
    goto LABEL_8;
  }
  v6 = a3[1];
  if (!v6)
  {
    format = CFSTR("formattedDict is NULL");
LABEL_25:
    AMFDRErrorPushInternal((uint64_t)&value, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyCallbak", format, v13);
LABEL_27:
    v3 = 0;
    goto LABEL_8;
  }
  if (!*v6)
  {
    format = CFSTR("formattedDict is uninitailized");
    goto LABEL_25;
  }
  v7 = *a3;
  v8 = CFGetAllocator(*a3);
  if ((AMFDRDataLocalDecomposeFullKey(v8, a1, (CFTypeRef *)&v16, &cf) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)&value, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyCallbak", CFSTR("AMFDRDataLocalDecomposeFullKey failed with %@"), (char)a1);
    goto LABEL_27;
  }
  v9 = v16;
  v10 = (const __CFString *)cf;
  v11 = (const __CFData *)CFRetain(v3);
  v3 = _AMFDRDataCopyFormatted(v7, v9, v10, v11, (uint64_t)&value);
  if (v3)
    CFDictionaryAddValue(*v6, a1, v3);
  else
    AMFDRErrorPushInternal((uint64_t)&value, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiCopyCallbak", CFSTR("_AMFDRDataCopyFormatted failed with %@"), (char)a1);
LABEL_8:
  if (value && v5 && *v5)
    CFDictionarySetValue(*v5, a1, value);
LABEL_12:
  if (v16)
  {
    CFRelease(v16);
    v16 = 0;
  }
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v3)
    CFRelease(v3);
  if (value)
    CFRelease(value);
}

void _AMFDRDataMultiPatchCallback(const __CFString *a1, const void *a2, uint64_t a3)
{
  __CFDictionary *v3;
  const void *v4;
  __CFDictionary *v5;
  const __CFAllocator *v8;
  const __CFString *v9;
  const __CFString *format;
  char v11;
  void *value;
  const __CFString *v13;
  const __CFString *v14;

  v4 = *(const void **)a3;
  v3 = *(__CFDictionary **)(a3 + 8);
  v5 = *(__CFDictionary **)(a3 + 16);
  v13 = 0;
  v14 = 0;
  value = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)&value, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiPatchCallback", CFSTR("dataClassInstance is NULL"), v11);
    goto LABEL_10;
  }
  if (!a2)
  {
    format = CFSTR("img4Data is NULL");
LABEL_20:
    AMFDRErrorPushInternal((uint64_t)&value, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiPatchCallback", format, v11);
    goto LABEL_7;
  }
  if (!v3)
  {
    format = CFSTR("patchedDataDict is NULL");
    goto LABEL_20;
  }
  v8 = CFGetAllocator(v4);
  if ((AMFDRDataLocalDecomposeFullKey(v8, a1, (CFTypeRef *)&v14, (CFTypeRef *)&v13) & 1) != 0)
  {
    v9 = (const __CFString *)AMFDRGetAssemblyIDToVerify((uint64_t)v4, v14);
    if ((AMFDRDataVerifyImg4Integrity(v4, v14, v13, v9, (const __CFData *)a2, 1, (uint64_t)&value) & 1) != 0)
      CFDictionarySetValue(v3, a1, a2);
    else
      AMFDRErrorPushInternal((uint64_t)&value, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiPatchCallback", CFSTR("failed to verify img4 data for %@"), (char)a1);
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)&value, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMultiPatchCallback", CFSTR("AMFDRDataLocalDecomposeFullKey failed with %@"), (char)a1);
  }
LABEL_7:
  if (value && v5)
    CFDictionarySetValue(v5, a1, value);
LABEL_10:
  if (v14)
  {
    CFRelease(v14);
    v14 = 0;
  }
  if (v13)
  {
    CFRelease(v13);
    v13 = 0;
  }
  if (value)
    CFRelease(value);
}

uint64_t _AMFDRDataPrepareRepairConfigurationContextArrayData(const __CFString *cf, const void *a2, const __CFData *a3)
{
  CFTypeID v6;
  CFTypeID v7;
  CFIndex Count;
  const __CFAllocator *v9;
  CFIndex v10;
  CFIndex v11;
  const __CFString *ValueAtIndex;
  const __CFString *v13;
  CFTypeID v14;
  const __CFData *ExternalRepresentation;
  const UInt8 *BytePtr;
  int Length;
  const __CFData *v18;
  const __CFData *v19;
  uint64_t v20;
  uint64_t *v22;
  uint64_t *v23;

  v22 = 0;
  v23 = 0;
  if (!cf)
    goto LABEL_32;
  v6 = CFGetTypeID(cf);
  if (v6 != CFStringGetTypeID())
    goto LABEL_32;
  if (!a2)
    goto LABEL_32;
  v7 = CFGetTypeID(a2);
  if (v7 != CFArrayGetTypeID())
    goto LABEL_32;
  if (!a3)
  {
LABEL_26:
    AMSupportLogInternal();
    goto LABEL_27;
  }
  if (!*(_QWORD *)a3 || (v23 = *(uint64_t **)a3, AMFDREncodeRepairConfigurationBegin(&v22)))
  {
LABEL_32:
    AMSupportLogInternal();
    a3 = 0;
LABEL_27:
    AMFDREncodeMetadataDestroy(&v22);
    v20 = 0;
    if (!a3)
      return v20;
    goto LABEL_24;
  }
  Count = CFArrayGetCount((CFArrayRef)a2);
  v9 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if (Count >= 1)
  {
    v10 = Count;
    v11 = 0;
    a3 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a2, v11);
      v13 = ValueAtIndex;
      if (!ValueAtIndex)
        goto LABEL_26;
      v14 = CFGetTypeID(ValueAtIndex);
      if (v14 != CFStringGetTypeID())
        goto LABEL_26;
      if (a3)
        CFRelease(a3);
      ExternalRepresentation = CFStringCreateExternalRepresentation(v9, v13, 0x8000100u, 0x20u);
      a3 = ExternalRepresentation;
      if (!ExternalRepresentation)
        goto LABEL_26;
      BytePtr = CFDataGetBytePtr(ExternalRepresentation);
      Length = CFDataGetLength(a3);
      if (AMFDREncodeRepairConfigurationAddData(&v22, 1, (uint64_t)BytePtr, Length))
        goto LABEL_26;
      if (v10 == ++v11)
        goto LABEL_19;
    }
  }
  a3 = 0;
LABEL_19:
  v18 = CFStringCreateExternalRepresentation(v9, cf, 0x8000100u, 0x20u);
  if (!v18)
    goto LABEL_26;
  v19 = v18;
  CFDataGetBytePtr(v18);
  CFDataGetLength(v19);
  if (AMFDREncodeRepairConfigurationAddSequenceWithKey(&v22)
    || AMFDREncodeRepairConfigurationAddSequence(&v22, &v23))
  {
    AMSupportLogInternal();
    v20 = 0;
  }
  else
  {
    v20 = 1;
  }
  AMFDREncodeMetadataDestroy(&v22);
  CFRelease(v19);
  if (a3)
LABEL_24:
    CFRelease(a3);
  return v20;
}

CFStringRef AMFDRDataLocalCreateFullKey(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  if (a3)
    return CFStringCreateWithFormat(a1, 0, CFSTR("%@-%@"), a2, a3);
  else
    return CFStringCreateWithFormat(a1, 0, CFSTR("%@"), a2);
}

uint64_t AMFDRDataLocalDecomposeFullKey(const __CFAllocator *a1, CFStringRef theString, CFTypeRef *a3, CFTypeRef *a4)
{
  CFIndex v8;

  if (CFStringHasPrefix(theString, CFSTR("minimal-manifest")))
    v8 = 2;
  else
    v8 = 1;
  return AMFDRDataLocalDecomposeFullKeyInternal(a1, v8, theString, a3, a4);
}

uint64_t AMFDRDataLocalDecomposeFullKeyInternal(const __CFAllocator *a1, CFIndex a2, CFStringRef theString, CFTypeRef *a4, CFTypeRef *a5)
{
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v11;
  __CFArray *Mutable;
  const __CFArray *v13;
  const __CFString *v14;
  const __CFString *v15;
  CFIndex Length;
  CFStringRef v17;
  uint64_t v18;
  CFRange v20;
  CFRange v21;

  if (!theString)
    goto LABEL_14;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, theString, CFSTR("-"));
  v11 = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings)
    goto LABEL_14;
  if (a2 < 1)
    goto LABEL_14;
  if (CFArrayGetCount(ArrayBySeparatingStrings) <= a2)
    goto LABEL_14;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  v13 = Mutable;
  if (!Mutable)
    goto LABEL_14;
  v20.location = 0;
  v20.length = a2;
  CFArrayAppendArray(Mutable, v11, v20);
  v14 = CFStringCreateByCombiningStrings(a1, v13, CFSTR("-"));
  v15 = v14;
  if (!v14)
    goto LABEL_14;
  Length = CFStringGetLength(v14);
  v21.length = CFStringGetLength(theString) + ~Length;
  v21.location = Length + 1;
  v17 = CFStringCreateWithSubstring(a1, theString, v21);
  if (v17)
  {
    if (a4)
      *a4 = CFRetain(v15);
    if (a5)
      *a5 = CFRetain(v17);
    v18 = 1;
  }
  else
  {
LABEL_14:
    AMSupportLogInternal();
    v18 = 0;
  }
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v18;
}

CFTypeRef AMFDRDataLocalCopyDataDirectoryPath(_QWORD *a1, uint64_t a2)
{
  const __CFDictionary *v4;
  const void *v5;
  const void *v6;
  CFTypeID v7;
  CFTypeRef v8;
  _QWORD *v9;
  uint64_t (*v10)(_QWORD *, _QWORD);
  const void *v11;
  CFTypeID v12;
  char v14;

  if (!a1)
  {
    AMSupportLogInternal();
LABEL_15:
    v8 = 0;
    goto LABEL_12;
  }
  v4 = (const __CFDictionary *)a1[2];
  if (!v4)
  {
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyDataDirectoryPath", CFSTR("options on amfdr are NULL"), v14);
    goto LABEL_15;
  }
  CFDictionaryGetValue(v4, CFSTR("DataDirectory"));
  v5 = (const void *)AMSupportSafeRetain();
  if (!v5)
  {
    v9 = (_QWORD *)a1[17];
    if (*v9 >= 0x69uLL)
    {
      v10 = (uint64_t (*)(_QWORD *, _QWORD))v9[13];
      if (v10)
      {
        v11 = (const void *)v10(a1, a1[18]);
        v6 = v11;
        if (v11)
        {
          v12 = CFGetTypeID(v11);
          if (v12 == CFURLGetTypeID())
            goto LABEL_5;
        }
      }
    }
    AMFDRErrorPushInternal(a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyDataDirectoryPath", CFSTR("CopyDefaultDataPath did not return a CFURL"), v14);
LABEL_11:
    v8 = 0;
    goto LABEL_12;
  }
  v6 = v5;
  v7 = CFGetTypeID(v5);
  if (v7 != CFURLGetTypeID())
  {
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyDataDirectoryPath", CFSTR("%@ must be a CFURL"), (char)CFSTR("DataDirectory"));
    goto LABEL_11;
  }
LABEL_5:
  v8 = CFRetain(v6);
LABEL_12:
  AMSupportSafeRelease();
  return v8;
}

uint64_t AMFDRDataLocalCopyDataStoragePath(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef v8;
  const void *v9;
  const __CFAllocator *v10;
  CFStringRef FullKey;
  CFStringRef v12;
  const __CFString *v13;
  const __CFString *v15;
  char v16;

  v8 = AMFDRDataLocalCopyDataDirectoryPath(a1, a4);
  if (!v8)
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyDataStoragePath", CFSTR("Could not determine data directory URL"), v16);
    return 0;
  }
  v9 = v8;
  if (MEMORY[0x212BA04D4]())
  {
    v13 = CFSTR("AMSupportMakeDirectory failed");
LABEL_9:
    AMFDRErrorPushInternal(a4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyDataStoragePath", v13, v16);
    CFRelease(v9);
    return 0;
  }
  v10 = CFGetAllocator(a1);
  FullKey = AMFDRDataLocalCreateFullKey(v10, a2, a3);
  if (!FullKey)
  {
    v16 = a2;
    v13 = CFSTR("failed to create fullKey from %@, %@");
    goto LABEL_9;
  }
  v12 = FullKey;
  CFGetAllocator(a1);
  if (AMSupportCopyURLWithAppendedComponent())
  {
    v15 = CFSTR("AMSupportCopyURLWithAppendedComponent failed");
  }
  else
  {
    v16 = (char)v9;
    v15 = CFSTR("failed to create filePath from %@, %@, %@");
  }
  AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyDataStoragePath", v15, v16);
  CFRelease(v9);
  CFRelease(v12);
  return 0;
}

uint64_t AMFDRDataLocalSign(uint64_t a1, const __CFString *a2, const void *a3, const __CFData *a4, char a5, const void *a6, __CFString *a7, const void *a8, CFDataRef *a9, uint64_t a10)
{
  __CFString *v10;
  uint64_t v11;
  CFDataRef *v13;
  const __CFDictionary *v14;
  const __CFBoolean *Value;
  const __CFBoolean *v20;
  CFTypeID v21;
  BOOL v22;
  int v23;
  unsigned int v24;
  const __CFString *v25;
  const __CFAllocator *v26;
  CFDataRef ExternalRepresentation;
  CFDataRef v28;
  const __CFString *InstanceString;
  const __CFAllocator *v30;
  CFTypeID v31;
  const __CFAllocator *v32;
  const __CFData *v33;
  CFTypeID v34;
  unsigned int Count;
  const __CFAllocator *v36;
  CFDataRef *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  CFTypeID v41;
  CFTypeID v42;
  uint64_t v43;
  const __CFAllocator *v44;
  CFArrayRef *v45;
  CFArrayRef *v46;
  const __CFDictionary *v47;
  const __CFDictionary *v48;
  int v49;
  CFIndex v50;
  CFDataRef v51;
  const __CFData *v52;
  const __CFAllocator *v53;
  const __CFString *ValueAtIndex;
  const __CFString *v55;
  const __CFString *v56;
  CFTypeID v57;
  const __CFData *v58;
  CFTypeID v59;
  int v60;
  const UInt8 *v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  char v66;
  unsigned int v67;
  char **v68;
  char **v69;
  const __CFAllocator *v70;
  const __CFData *v71;
  int v72;
  const void *v73;
  const __CFData *v74;
  const __CFData *v75;
  const UInt8 *v76;
  int v77;
  char *v78;
  int v79;
  const UInt8 *v80;
  CFIndex v81;
  const UInt8 *v82;
  uint64_t v83;
  char *v84;
  int v85;
  const UInt8 *v86;
  CFIndex v87;
  const UInt8 *v88;
  const __CFAllocator *v89;
  CFDataRef v90;
  const __CFString *format;
  void *v92;
  const __CFString *v94;
  const __CFDictionary *v95;
  uint64_t value_8;
  uint64_t v97;
  const __CFString *v98;
  char v99;
  CFArrayRef *cf;
  char **cfa;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t v104;
  char v105;
  CFDataRef *v106;
  CFDataRef *v107;
  const __CFData *v108;
  const __CFData *v109;
  __CFString *v111;
  BOOL v112;
  const __CFData *v113;
  const __CFString *v114;
  __CFString *v115;
  void *v116;
  CFMutableArrayRef Mutable;
  const __CFData *v118;
  void *v120;
  int v121;
  void *v122;
  unsigned int v123;
  UInt8 *v124;
  char v125;
  int v126;
  uint64_t v127;
  _QWORD *v128;
  __int128 context;
  __int128 v130;
  __int128 v131;
  char *v132;
  uint64_t v133;
  uint64_t v134;

  v10 = (__CFString *)a1;
  v11 = a10;
  v134 = *MEMORY[0x24BDAC8D0];
  v125 = 0;
  v124 = 0;
  v123 = 0;
  v122 = 0;
  v121 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a10, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("amfdr is NULL"), (char)v98);
LABEL_105:
    v13 = 0;
    goto LABEL_106;
  }
  if (!a2)
  {
    v25 = CFSTR("dataClassStr is NULL");
    goto LABEL_101;
  }
  if (!a3)
  {
    AMFDRErrorPushInternal(a10, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("dataInstanceStr is NULL."), (char)v98);
LABEL_104:
    v10 = 0;
    goto LABEL_105;
  }
  if (!a4)
  {
    AMFDRErrorPushInternal(a10, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("valueData is NULL."), (char)v98);
    goto LABEL_104;
  }
  v13 = a9;
  if (!a9)
  {
    AMFDRErrorPushInternal(a10, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("outSignedValueData is NULL."), (char)v98);
    v10 = 0;
LABEL_106:
    a7 = 0;
    v39 = 0;
    v92 = 0;
    v40 = 0;
    goto LABEL_123;
  }
  v14 = *(const __CFDictionary **)(a1 + 16);
  if (!v14)
  {
    v25 = CFSTR("options on amfdr are NULL");
    goto LABEL_101;
  }
  Value = (const __CFBoolean *)CFDictionaryGetValue(v14, CFSTR("kAMFDROptionOfflineSigning"));
  if (!Value || (v20 = Value, v21 = CFGetTypeID(Value), v22 = v21 == CFBooleanGetTypeID(), v11 = a10, !v22))
  {
    _isLocalSign((uint64_t)v10);
    v112 = 0;
    goto LABEL_14;
  }
  v23 = CFBooleanGetValue(v20);
  v112 = v23 != 0;
  v24 = _isLocalSign((uint64_t)v10);
  if (v23 && v24)
  {
    v98 = CFSTR("kAMFDROptionOfflineSigning");
    v25 = CFSTR("Cannot specify both %@ and %@ with value TRUE");
LABEL_101:
    AMFDRErrorPushInternal(v11, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", v25, (char)v98);
    goto LABEL_104;
  }
LABEL_14:
  if ((AMFDRDataGetSigningVersion((uint64_t)v10, &v121) & 1) == 0)
  {
    AMFDRErrorPushInternal(v11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("AMFDRDataGetSigningVersion failed"), (char)v98);
    goto LABEL_104;
  }
  v105 = a5;
  v26 = CFGetAllocator(v10);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v26, a2, 0x8000100u, 0x5Fu);
  if (!ExternalRepresentation)
  {
    AMFDRErrorPushInternal(v11, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("CFStringCreateExternalRepresentation(dataClassData) failed"), (char)v98);
    goto LABEL_104;
  }
  v28 = ExternalRepresentation;
  v104 = (uint64_t)a2;
  InstanceString = AMFDRDataCreateInstanceString(v10, 0, a3);
  v30 = CFGetAllocator(v10);
  v118 = CFStringCreateExternalRepresentation(v30, InstanceString, 0x8000100u, 0x5Fu);
  if (!v118)
  {
    AMFDRErrorPushInternal(v11, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("CFStringCreateExternalRepresentation(dataInstanceData) failed"), (char)v98);
    v71 = 0;
    v73 = 0;
    v10 = 0;
    v13 = 0;
    a7 = 0;
    v39 = 0;
    v120 = 0;
    v113 = 0;
    v40 = 0;
LABEL_114:
    CFRelease(v28);
    goto LABEL_115;
  }
  if (!a7)
    goto LABEL_23;
  v31 = CFGetTypeID(a7);
  if (v31 != CFStringGetTypeID() || CFStringGetLength(a7) < 1)
  {
    a7 = 0;
LABEL_23:
    Length = 0;
    BytePtr = 0;
    goto LABEL_24;
  }
  v32 = CFGetAllocator(v10);
  v33 = CFStringCreateExternalRepresentation(v32, a7, 0x8000100u, 0x5Fu);
  a7 = (__CFString *)v33;
  if (!v33)
  {
    AMFDRErrorPushInternal(v11, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("CFStringCreateExternalRepresentation(assemblyIDData) failed"), (char)v98);
    v40 = 0;
    v111 = 0;
    v113 = 0;
    v120 = 0;
    v39 = 0;
    v13 = 0;
    v10 = 0;
    v73 = 0;
    v71 = 0;
    goto LABEL_149;
  }
  BytePtr = CFDataGetBytePtr(v33);
  Length = CFDataGetLength((CFDataRef)a7);
LABEL_24:
  v114 = InstanceString;
  v111 = a7;
  if (!a6 || (v34 = CFGetTypeID(a6), v34 != CFDictionaryGetTypeID()))
  {
    v38 = 0;
    v115 = 0;
    v116 = 0;
    v13 = 0;
    Mutable = 0;
    goto LABEL_39;
  }
  Count = CFDictionaryGetCount((CFDictionaryRef)a6);
  if (Count)
  {
    v36 = CFGetAllocator(v10);
    Mutable = CFArrayCreateMutable(v36, Count, MEMORY[0x24BDBD690]);
    if (Mutable)
    {
      v120 = malloc_type_malloc(4 * Count, 0x100004052888210uLL);
      if (v120)
      {
        v116 = malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
        if (v116)
        {
          v11 = a10;
          v115 = (__CFString *)malloc_type_malloc(4 * Count, 0x100004052888210uLL);
          if (!v115)
          {
            AMFDRErrorPushInternal(a10, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("propertyValueLengths is NULL"), (char)v98);
            v40 = 0;
            v113 = 0;
            a7 = 0;
            v13 = 0;
            v73 = 0;
            v71 = 0;
            v39 = v116;
            goto LABEL_157;
          }
          v37 = (CFDataRef *)malloc_type_malloc(4 * Count, 0x100004052888210uLL);
          v13 = v37;
          if (!v37)
          {
            AMFDRErrorPushInternal(a10, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("propertyValueTypes is NULL"), (char)v98);
            v40 = 0;
            v113 = 0;
            v73 = 0;
            v71 = 0;
            a7 = v115;
            v39 = v116;
            goto LABEL_157;
          }
          v125 = 1;
          v38 = v120;
          *(_QWORD *)&context = v10;
          *((_QWORD *)&context + 1) = v120;
          a7 = v115;
          v39 = v116;
          *(_QWORD *)&v130 = v116;
          *((_QWORD *)&v130 + 1) = v115;
          *(_QWORD *)&v131 = v37;
          *((_QWORD *)&v131 + 1) = Mutable;
          v132 = &v125;
          v133 = a10;
          CFDictionaryApplyFunction((CFDictionaryRef)a6, (CFDictionaryApplierFunction)_appendManifestProperties, &context);
          if (!v125)
            goto LABEL_35;
          if (FDREncodeExtendedProperties((uint64_t)&v122, Count, (uint64_t)v120, (uint64_t)v116, (uint64_t)v115, (uint64_t)v13))
          {
            AMFDRErrorPushInternal(a10, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("FDREncodeExtendedProperties failed"), (char)v98);
            a7 = v115;
            v39 = v116;
LABEL_35:
            v40 = 0;
            v113 = 0;
LABEL_154:
            v73 = 0;
            v71 = 0;
LABEL_157:
            InstanceString = v114;
            goto LABEL_112;
          }
          goto LABEL_38;
        }
        AMFDRErrorPushInternal(a10, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("propertyValues is NULL"), (char)v98);
        v40 = 0;
        v113 = 0;
      }
      else
      {
        AMFDRErrorPushInternal(a10, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("propertyTags is NULL"), (char)v98);
        v40 = 0;
        v113 = 0;
        v120 = 0;
      }
      v39 = 0;
      a7 = 0;
      v13 = 0;
      goto LABEL_154;
    }
    AMFDRErrorPushInternal(a10, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("propertyDataArray is NULL"), (char)v98);
    v40 = 0;
    v113 = 0;
    v120 = 0;
    v39 = 0;
    a7 = 0;
    v13 = 0;
    v10 = 0;
    v73 = 0;
    v71 = 0;
    InstanceString = v114;
LABEL_149:
    v74 = v118;
    goto LABEL_113;
  }
  v38 = 0;
  v115 = 0;
  v116 = 0;
  v13 = 0;
  Mutable = 0;
LABEL_38:
  InstanceString = v114;
LABEL_39:
  v120 = v38;
  if (!a8)
  {
    v65 = 0;
    goto LABEL_72;
  }
  v41 = CFGetTypeID(a8);
  if (v41 != CFArrayGetTypeID() || !CFArrayGetCount((CFArrayRef)a8))
  {
    v65 = 0;
    LODWORD(a8) = 0;
    goto LABEL_72;
  }
  v130 = 0u;
  v131 = 0u;
  context = 0u;
  v127 = 0;
  v128 = 0;
  v126 = 0;
  v42 = CFGetTypeID(a8);
  if (v42 != CFArrayGetTypeID())
  {
    AMFDRErrorPushInternal(v11, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalCreateSubCCDigestObjP", CFSTR("subCCListWithDigest is malformed"), (char)v98);
LABEL_164:
    AMFDREncodeMetadataDestroy(&v128);
LABEL_165:
    AMFDRErrorPushInternal(v11, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("subCC digest encoding failed for %@"), v104);
    goto LABEL_110;
  }
  v108 = v28;
  v43 = CFArrayGetCount((CFArrayRef)a8);
  if (!v43)
  {
    AMFDRErrorPushInternal(v11, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalCreateSubCCDigestObjP", CFSTR("subCCListWithDigest contains no element"), (char)v98);
LABEL_163:
    v28 = v108;
    goto LABEL_164;
  }
  v44 = CFGetAllocator(v10);
  v45 = (CFArrayRef *)AMFDRSysconfigCreateFromData(v44, a4, v11);
  if (!v45)
  {
    AMFDRErrorPushInternal(v11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalCreateSubCCDigestObjP", CFSTR("cannot create sysconfig from valueData"), (char)v98);
    goto LABEL_163;
  }
  v46 = v45;
  v47 = (const __CFDictionary *)AMFDRSysconfigCopyValues(v45, v11);
  if (!v47)
  {
    AMFDRErrorPushInternal(v11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalCreateSubCCDigestObjP", CFSTR("cannot create copy values from sysconfig"), (char)v98);
    v95 = (const __CFDictionary *)v46;
LABEL_162:
    CFRelease(v95);
    goto LABEL_163;
  }
  v48 = v47;
  v49 = AMFDREncodeSubCCDigestsBegin(&v128);
  if (v49)
  {
    AMFDRErrorPushInternal(v11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalCreateSubCCDigestObjP", CFSTR("AMFDREncodeSubCCDigestsBegin failed 0x%X"), v49);
    CFRelease(v46);
    v95 = v48;
    goto LABEL_162;
  }
  cf = v46;
  v106 = v13;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  do
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a8, v50);
    if (v51)
      CFRelease(v51);
    v51 = CFStringCreateExternalRepresentation(v53, ValueAtIndex, 0x8000100u, 0x5Fu);
    v55 = (const __CFString *)CFDictionaryGetValue(v48, ValueAtIndex);
    if (v55)
    {
      v56 = v55;
      if (v52)
        CFRelease(v52);
      v57 = CFGetTypeID(v56);
      if (v57 == CFStringGetTypeID())
      {
        v58 = CFStringCreateExternalRepresentation(v53, v56, 0x8000100u, 0x5Fu);
      }
      else
      {
        v59 = CFGetTypeID(v56);
        if (v59 != CFDataGetTypeID())
        {
          v11 = a10;
          AMFDRErrorPushInternal(a10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalCreateSubCCDigestObjP", CFSTR("unknown data type for the subCC value"), (char)v98);
          v65 = 0;
          LODWORD(a8) = 0;
          v52 = 0;
          goto LABEL_66;
        }
        v58 = (const __CFData *)CFRetain(v56);
      }
      v52 = v58;
      CFDataGetBytePtr(v58);
      CFDataGetLength(v52);
      v60 = AMSupportDigestSha384();
      if (v60)
      {
        v99 = v60;
        format = CFSTR("AMSupportDigestSha384 failed 0x%X");
LABEL_93:
        v11 = a10;
        AMFDRErrorPushInternal(a10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalCreateSubCCDigestObjP", format, v99);
        goto LABEL_94;
      }
      v61 = CFDataGetBytePtr(v51);
      v62 = CFDataGetLength(v51);
      v63 = AMFDREncodeSubCCDigestsAddData(&v128, (uint64_t)v61, v62, (uint64_t)&context, 48);
      if (v63)
      {
        v99 = v63;
        format = CFSTR("AMFDREncodeSubCCDigestsAddData failed 0x%X");
        goto LABEL_93;
      }
    }
    else
    {
      AMSupportLogInternal();
    }
    ++v50;
  }
  while (v43 != v50);
  v64 = AMFDREncodeSubCCDigestsEnd(&v128, &v127, &v126);
  v11 = a10;
  if (!v64)
  {
    v65 = v127;
    v66 = 1;
    LODWORD(a8) = v126;
    goto LABEL_67;
  }
  AMFDRErrorPushInternal(a10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalCreateSubCCDigestObjP", CFSTR("AMFDREncodeSubCCDigestsEnd failed 0x%X"), v64);
LABEL_94:
  v65 = 0;
  LODWORD(a8) = 0;
LABEL_66:
  v66 = 0;
LABEL_67:
  v28 = v108;
  CFRelease(cf);
  CFRelease(v48);
  if (v52)
    CFRelease(v52);
  if (v51)
    CFRelease(v51);
  AMFDREncodeMetadataDestroy(&v128);
  InstanceString = v114;
  v13 = v106;
  if ((v66 & 1) == 0)
    goto LABEL_165;
LABEL_72:
  LODWORD(context) = 0;
  if ((AMFDRDataGetSigningVersion((uint64_t)v10, (int *)&context) & 1) == 0)
  {
    AMSupportLogInternal();
LABEL_109:
    AMFDRErrorPushInternal(v11, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("cannot get encode implementation"), (char)v98);
LABEL_110:
    v40 = 0;
    v113 = 0;
    v73 = 0;
    v71 = 0;
    goto LABEL_111;
  }
  v67 = _isLocalSign((uint64_t)v10);
  if ((_DWORD)context != 2)
  {
    if ((_DWORD)context == 1)
    {
      v68 = &FDREncodeImplementationSha1;
      v69 = &FDREncodeImplementationLocalSignSha1;
      goto LABEL_77;
    }
    goto LABEL_109;
  }
  v68 = &FDREncodeImplementationSha384;
  v69 = &FDREncodeImplementationLocalSignSha384;
LABEL_77:
  if (v67)
    v68 = v69;
  cfa = v68;
  v107 = v13;
  v109 = v28;
  if (v112)
  {
    v70 = CFGetAllocator(v10);
    v71 = (const __CFData *)CFStringCreateWithFormat(v70, 0, CFSTR("%@.offline"), a3);
    if (v71)
    {
      v73 = (const void *)AMFDROfflineBlobCreate(v10, v104, (uint64_t)a3, v11);
      v74 = v118;
      v113 = v71;
      if (v73)
      {
        if (AMFDRDataLocalPutWithOptions(v10, v104, (uint64_t)v71, (_BOOL8)v73, v72, v11))
        {
          v75 = (const __CFData *)AMFDRCryptoCopyRefKeyPub(v10);
          v71 = v75;
          if (v75)
          {
            v76 = CFDataGetBytePtr(v75);
            v77 = CFDataGetLength(v71);
            v78 = (char *)CFDataGetBytePtr(v28);
            v79 = CFDataGetLength(v28);
            v80 = CFDataGetBytePtr(v118);
            v81 = CFDataGetLength(v118);
            v82 = CFDataGetBytePtr(a4);
            BYTE4(value_8) = v105;
            LODWORD(value_8) = CFDataGetLength(a4);
            if (FDREncodeCreateOfflineSignedData((uint64_t)cfa, (uint64_t)v10, (uint64_t)v76, v77, v78, v79, (uint64_t)v80, v81, (uint64_t)v82, value_8, (uint64_t)v122, (uint64_t)&v124, (uint64_t)&v123))
            {
              AMFDRErrorPushInternal(a10, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("FDREncodeCreateOfflineSignedData failed"), (char)v98);
              v40 = 0;
              InstanceString = v114;
              a7 = v115;
              v13 = v107;
              v28 = v109;
              v10 = (__CFString *)Mutable;
              v74 = v118;
              v39 = v116;
              goto LABEL_113;
            }
            InstanceString = v114;
            v28 = v109;
            v74 = v118;
            v83 = a10;
            goto LABEL_88;
          }
          AMFDRErrorPushInternal(v11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("refPubKey is NULL"), (char)v98);
          v40 = 0;
LABEL_145:
          a7 = v115;
          v39 = v116;
          v10 = (__CFString *)Mutable;
          goto LABEL_113;
        }
        v94 = CFSTR("put offline blob file failed");
      }
      else
      {
        v94 = CFSTR("refKeyBlob is NULL");
      }
      AMFDRErrorPushInternal(v11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", v94, (char)v98);
      v40 = 0;
      v71 = 0;
      goto LABEL_145;
    }
    AMFDRErrorPushInternal(v11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("offlineDataInstanceStr is NULL"), (char)v98);
    v40 = 0;
    v113 = 0;
    v73 = 0;
LABEL_111:
    a7 = v115;
    v39 = v116;
LABEL_112:
    v10 = (__CFString *)Mutable;
    v74 = v118;
    goto LABEL_113;
  }
  v84 = (char *)CFDataGetBytePtr(v28);
  v85 = CFDataGetLength(v28);
  v86 = CFDataGetBytePtr(v118);
  v87 = CFDataGetLength(v118);
  v88 = CFDataGetBytePtr(a4);
  BYTE4(v97) = v105;
  LODWORD(v97) = CFDataGetLength(a4);
  LODWORD(value_8) = (_DWORD)a8;
  if (FDREncodeCreateSignedData((uint64_t)cfa, (uint64_t)v10, v84, v85, (uint64_t)v86, v87, (uint64_t)BytePtr, Length, v65, value_8, (uint64_t)v88, v97, (uint64_t)v122, (uint64_t)&v124, (uint64_t)&v123))
  {
    AMFDRErrorPushInternal(a10, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("FDREncodeCreateSignedData failed"), (char)v98);
    v40 = 0;
    v113 = 0;
    v73 = 0;
    v71 = 0;
    v13 = v107;
    v28 = v109;
    v39 = v116;
    v10 = (__CFString *)Mutable;
    v74 = v118;
    InstanceString = v114;
    a7 = v115;
    goto LABEL_113;
  }
  v113 = 0;
  v73 = 0;
  v71 = 0;
  v28 = v109;
  v74 = v118;
  v83 = a10;
  InstanceString = v114;
LABEL_88:
  v89 = CFGetAllocator(v10);
  v90 = CFDataCreate(v89, v124, v123);
  *a9 = v90;
  v10 = (__CFString *)Mutable;
  v13 = v107;
  if (v90)
  {
    v40 = 1;
  }
  else
  {
    AMFDRErrorPushInternal(v83, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalSign", CFSTR("failed to create outSignedValueData"), (char)v98);
    v40 = 0;
  }
  a7 = v115;
  v39 = v116;
LABEL_113:
  CFRelease(v28);
  CFRelease(v74);
  v28 = (CFDataRef)v111;
  if (v111)
    goto LABEL_114;
LABEL_115:
  if (InstanceString)
    CFRelease(InstanceString);
  if (v73)
    CFRelease(v73);
  if (v71)
    CFRelease(v71);
  v92 = v120;
  if (v113)
    CFRelease(v113);
LABEL_123:
  if (v124)
  {
    free(v124);
    v124 = 0;
  }
  if (v92)
    free(v92);
  if (v39)
    free(v39);
  if (a7)
    free(a7);
  if (v13)
    free(v13);
  if (v122)
  {
    free(v122);
    v122 = 0;
  }
  if (v10)
    CFRelease(v10);
  return v40;
}

const __CFDictionary *_isLocalSign(uint64_t a1)
{
  const __CFDictionary *result;
  const __CFBoolean *Value;
  const __CFBoolean *v5;
  CFTypeID v6;

  if (a1)
  {
    result = *(const __CFDictionary **)(a1 + 16);
    if (!result)
      return result;
    Value = (const __CFBoolean *)CFDictionaryGetValue(result, CFSTR("LocalSigning"));
    if (*(uint64_t (***)(int, int, int, int))(a1 + 48) != AMFDRHTTPStore && Value != 0)
    {
      v5 = Value;
      v6 = CFGetTypeID(Value);
      if (v6 == CFBooleanGetTypeID())
        return (const __CFDictionary *)(CFBooleanGetValue(v5) != 0);
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  return 0;
}

void _appendManifestProperties(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  _BYTE *v3;
  _DWORD *v6;
  const void *v7;
  const UInt8 **v8;
  __CFArray *v9;
  _DWORD *v10;
  CFTypeID TypeID;
  const __CFAllocator *v13;
  const __CFData *ExternalRepresentation;
  const __CFData *v15;
  CFTypeID v16;
  const __CFData *v17;
  CFTypeID v18;
  CFDataRef v19;
  CFTypeID v20;
  const __CFAllocator *v21;
  unsigned int *BytePtr;
  uint64_t v23;
  CFDataRef v24;
  const __CFString *v25;
  const __CFString *v26;
  char v27;
  uint64_t v28;
  _DWORD *v29;
  uint64_t valuePtr;

  v3 = *(_BYTE **)(a3 + 48);
  if (v3 && *v3)
  {
    v7 = *(const void **)a3;
    v6 = *(_DWORD **)(a3 + 8);
    v8 = *(const UInt8 ***)(a3 + 16);
    v10 = *(_DWORD **)(a3 + 32);
    v9 = *(__CFArray **)(a3 + 40);
    v28 = *(_QWORD *)(a3 + 56);
    v29 = *(_DWORD **)(a3 + 24);
    *v3 = 0;
    if (a1 && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(a1)))
    {
      v13 = CFGetAllocator(v7);
      ExternalRepresentation = CFStringCreateExternalRepresentation(v13, a1, 0x8000100u, 0x5Fu);
      if (ExternalRepresentation)
      {
        v15 = ExternalRepresentation;
        if (CFDataGetLength(ExternalRepresentation) == 4)
        {
          if (a2)
          {
            v16 = CFGetTypeID(a2);
            if (v16 == CFDataGetTypeID())
            {
              v17 = (const __CFData *)CFRetain(a2);
LABEL_15:
              v19 = v17;
              *v10 = 0;
LABEL_16:
              if (v19)
              {
                CFArrayAppendValue(v9, v19);
                BytePtr = (unsigned int *)CFDataGetBytePtr(v15);
                *v6 = AMFDRTagsStringToTag(BytePtr);
                *v8 = CFDataGetBytePtr(v19);
                *v29 = CFDataGetLength(v19);
                v23 = *(_QWORD *)(a3 + 16) + 8;
                *(_QWORD *)(a3 + 8) += 4;
                *(_QWORD *)(a3 + 16) = v23;
                *(int64x2_t *)(a3 + 24) = vaddq_s64(*(int64x2_t *)(a3 + 24), vdupq_n_s64(4uLL));
                *v3 = 1;
                CFRelease(v15);
                v24 = v19;
LABEL_21:
                CFRelease(v24);
                return;
              }
              v25 = CFSTR("keyValueData is NULL");
              goto LABEL_19;
            }
            v18 = CFGetTypeID(a2);
            if (v18 == CFNumberGetTypeID())
            {
              valuePtr = 0;
              if (!CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt64Type, &valuePtr))
              {
                AMSupportLogInternal();
                goto LABEL_20;
              }
              v19 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], (const UInt8 *)&valuePtr, 8);
              *v10 = 1;
              goto LABEL_16;
            }
            v20 = CFGetTypeID(a2);
            if (v20 == CFStringGetTypeID())
            {
              v21 = CFGetAllocator(v7);
              v17 = CFStringCreateExternalRepresentation(v21, a2, 0x8000100u, 0x5Fu);
              goto LABEL_15;
            }
          }
          v25 = CFSTR("Unexpected propertyValue type");
        }
        else
        {
          v25 = CFSTR("keyNameData length is not 4");
        }
LABEL_19:
        AMFDRErrorPushInternal(v28, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_appendManifestProperties", v25, v27);
LABEL_20:
        v24 = v15;
        goto LABEL_21;
      }
      v26 = CFSTR("keyNameData is NULL");
    }
    else
    {
      v26 = CFSTR("Unexpected propertyTag type");
    }
    AMFDRErrorPushInternal(v28, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_appendManifestProperties", v26, v27);
  }
}

BOOL AMFDRDataLocalPutWithOptions(_QWORD *a1, uint64_t a2, uint64_t a3, _BOOL8 a4, int a5, uint64_t a6)
{
  _BOOL8 v7;
  uint64_t v9;
  const void *v10;
  unsigned int v11;
  const __CFString *v13;
  uint64_t v14;
  CFIndex v15;
  void *value[2];
  void *v17[2];
  __int128 v18;
  const __CFString *format;
  char v20;

  if (!a1)
  {
    v13 = CFSTR("amfdr is NULL");
LABEL_12:
    format = v13;
    *(_OWORD *)v17 = 0u;
    v18 = 0u;
    *(_OWORD *)value = 0u;
    v14 = a6;
    v15 = 1;
LABEL_16:
    AMFDRErrorPushInternal(v14, v15, 0, 0, 0, 0, 0, 0, value[0], value[1], v17[0], v17[1], (void *)v18, *((void **)&v18 + 1), (uint64_t)"AMFDRDataLocalPutWithOptions", format, v20);
    return 0;
  }
  if (!a2)
  {
    v13 = CFSTR("dataClassStr is NULL");
    goto LABEL_12;
  }
  if (!a3)
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPutWithOptions", CFSTR("dataInstanceStr is NULL."), v20);
    return 0;
  }
  v7 = a4;
  if (!a4)
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPutWithOptions", CFSTR("valueData is NULL"), v20);
    return v7;
  }
  v9 = AMFDRDataLocalCopyDataStoragePath(a1, a2, a3, a6);
  if (!v9)
  {
    format = CFSTR("missing data storage path");
    *(_OWORD *)v17 = 0u;
    v18 = 0u;
    *(_OWORD *)value = 0u;
    v14 = a6;
    v15 = 4;
    goto LABEL_16;
  }
  v10 = (const void *)v9;
  v11 = AMFDRWriteDataToFileURL(a1, v7, v9, 1);
  v7 = v11 == 0;
  if (v11)
    AMFDRErrorPushInternal(a6, v11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPutWithOptions", CFSTR("failed to write data to %@"), (char)v10);
  CFRelease(v10);
  return v7;
}

CFTypeRef AMFDRDataLocalCreateDataWithManifests(const void *a1, const __CFData *a2, const __CFData *a3, const __CFData *a4, char a5, uint64_t a6)
{
  char v7;

  v7 = a5;
  return AMFDRDataLocalCreateDataWithManifestsInternal(a1, a2, a3, a4, &v7, 0, a6);
}

CFTypeRef AMFDRDataLocalCreateDataWithManifestsInternal(const void *a1, CFDataRef theData, const __CFData *a3, const __CFData *a4, _BYTE *a5, CFTypeRef *a6, uint64_t a7)
{
  __int128 v13;
  _BOOL4 v14;
  const UInt8 *BytePtr;
  int v16;
  const UInt8 *v17;
  unsigned int v18;
  _BOOL4 v19;
  const __CFAllocator *v20;
  CFDataRef v21;
  uint64_t v22;
  uint64_t v23;
  const UInt8 *v24;
  CFIndex v25;
  const __CFAllocator *v26;
  const __CFData *v27;
  const __CFAllocator *v28;
  int v29;
  const __CFString *v31;
  char v32;
  _DWORD length[4];
  _DWORD v34[4];
  int v35;
  uint64_t v36;
  _DWORD v37[3];
  CFTypeRef v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  unint64_t v67;
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  v38 = 0;
  memset(v37, 0, sizeof(v37));
  v36 = 0;
  v35 = 0;
  *(_QWORD *)&v34[1] = 0;
  v34[0] = 0;
  v67 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v65 = v13;
  v66 = v13;
  v63 = v13;
  v64 = v13;
  v61 = v13;
  v62 = v13;
  v59 = v13;
  v60 = v13;
  v57 = v13;
  v58 = v13;
  v55 = v13;
  v56 = v13;
  v53 = v13;
  v54 = v13;
  v51 = v13;
  v52 = v13;
  v49 = v13;
  v50 = v13;
  v47 = v13;
  v48 = v13;
  v45 = v13;
  v46 = v13;
  v43 = v13;
  v44 = v13;
  v41 = v13;
  v42 = v13;
  v39 = v13;
  v40 = v13;
  if (a5)
  {
    v14 = *a5 != 0;
    BytePtr = CFDataGetBytePtr(theData);
    *(_QWORD *)&v34[1] = BytePtr;
    v16 = CFDataGetLength(theData);
    v34[0] = v16;
    if (!v14)
      goto LABEL_16;
  }
  else
  {
    v17 = CFDataGetBytePtr(theData);
    v18 = CFDataGetLength(theData);
    v19 = AMFDRDecodeCombined((uint64_t)v17, v18, &v36, &v35, &v34[1], v34) == 0;
    BytePtr = *(const UInt8 **)&v34[1];
    v16 = v34[0];
    if (!v19)
    {
LABEL_16:
      v27 = (const __CFData *)CFRetain(theData);
      goto LABEL_19;
    }
  }
  if (!BytePtr || !v16)
    goto LABEL_16;
  if (!a6)
  {
    if (a3)
      goto LABEL_12;
LABEL_18:
    v28 = CFGetAllocator(a1);
    v27 = CFDataCreate(v28, *(const UInt8 **)&v34[1], v34[0]);
    if (v27)
      goto LABEL_19;
    v31 = CFSTR("failed to extract img4 data");
LABEL_32:
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateDataWithManifestsInternal", v31, v32);
    goto LABEL_24;
  }
  *(_QWORD *)&length[1] = 0;
  length[0] = 0;
  if (AMFDRDecodeGetImg4Manifest((uint64_t)BytePtr, v16, &length[1], length) || !*(_QWORD *)&length[1])
  {
    AMFDRErrorPushInternal(a7, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateDataWithManifestsInternal", CFSTR("failed to parse manifest from combined format"), v32);
    goto LABEL_24;
  }
  v20 = CFGetAllocator(a1);
  v21 = CFDataCreate(v20, *(const UInt8 **)&length[1], length[0]);
  if (!v21)
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateDataWithManifestsInternal", CFSTR("failed to allocate reStitchedManifest"), v32);
    goto LABEL_24;
  }
  *a6 = CFRetain(v21);
  if (!a3)
    goto LABEL_18;
LABEL_12:
  v22 = *(_QWORD *)&v34[1];
  v23 = v34[0];
  v24 = CFDataGetBytePtr(a3);
  v25 = CFDataGetLength(a3);
  if (FDREncodeReStitchManifest(v22, v23, (uint64_t)v24, v25, &v37[1], v37) || !*(_QWORD *)&v37[1])
  {
    AMFDRErrorPushInternal(a7, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateDataWithManifestsInternal", CFSTR("failed to restitch device manifest"), v32);
    goto LABEL_24;
  }
  v26 = CFGetAllocator(a1);
  v27 = CFDataCreateWithBytesNoCopy(v26, *(const UInt8 **)&v37[1], v37[0], (CFAllocatorRef)*MEMORY[0x24BDBD248]);
  if (!v27)
  {
    v31 = CFSTR("img4Data is NULL");
    goto LABEL_32;
  }
  *(_QWORD *)&v37[1] = 0;
LABEL_19:
  CFDataGetBytePtr(v27);
  CFDataGetLength(v27);
  v29 = Img4DecodeInit();
  if (!a4 || v29)
  {
    v38 = CFRetain(v27);
  }
  else if ((AMFDRDataCreateFDR2Data((uint64_t)a1, v27, a4, (uint64_t)&v38, a7) & 1) == 0)
  {
    AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateDataWithManifestsInternal", CFSTR("Failed to create FDR2 data"), v32);
  }
LABEL_24:
  AMSupportSafeRelease();
  if (*(_QWORD *)&v37[1])
  {
    free(*(void **)&v37[1]);
    *(_QWORD *)&v37[1] = 0;
  }
  AMSupportSafeRelease();
  return v38;
}

const __CFString *AMFDRDataLocalPatchCreatePayloadAndDigest(const void *a1, const __CFString *a2, const __CFData *a3, CFTypeRef *a4, CFTypeRef *a5, uint64_t a6)
{
  const __CFString *v7;
  const __CFAllocator *v12;
  const __CFData *ExternalRepresentation;
  const char *BytePtr;
  int v15;
  const UInt8 *v16;
  CFIndex v17;
  unsigned int PayloadAndDigest;
  const __CFAllocator *v19;
  CFDataRef v20;
  CFDataRef v21;
  const __CFString *v22;
  const __CFAllocator *v23;
  __CFString *MutableCopy;
  __CFString *v25;
  const __CFAllocator *v26;
  CFDataRef v27;
  CFDataRef v28;
  uint64_t v29;
  const __CFString *v31;
  const __CFString *v32;
  const __CFString *v33;
  char v34;
  _DWORD length[4];
  unsigned int v36[3];

  memset(v36, 0, sizeof(v36));
  *(_QWORD *)&length[1] = 0;
  length[0] = 0;
  if (!a1)
  {
    v31 = CFSTR("amfdr is NULL");
LABEL_31:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreatePayloadAndDigest", v31, v34);
LABEL_40:
    v7 = 0;
    goto LABEL_23;
  }
  v7 = a2;
  if (!a2)
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreatePayloadAndDigest", CFSTR("dataClass is NULL"), v34);
    goto LABEL_23;
  }
  if (!a3)
  {
    v31 = CFSTR("rawData is NULL");
    goto LABEL_31;
  }
  v12 = CFGetAllocator(a1);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v12, v7, 0x8000100u, 0x20u);
  v7 = (const __CFString *)ExternalRepresentation;
  if (!ExternalRepresentation)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreatePayloadAndDigest", CFSTR("dataClassData is NULL"), v34);
    goto LABEL_23;
  }
  if (CFDataGetLength(ExternalRepresentation) != 4)
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreatePayloadAndDigest", CFSTR("dataClass length is invalid"), v34);
LABEL_39:
    CFRelease(v7);
    goto LABEL_40;
  }
  BytePtr = (const char *)CFDataGetBytePtr((CFDataRef)v7);
  v15 = CFDataGetLength((CFDataRef)v7);
  v16 = CFDataGetBytePtr(a3);
  v17 = CFDataGetLength(a3);
  PayloadAndDigest = AMFDREncodeCreatePayloadAndDigest((uint64_t)&FDREncodeImplementationSha384, BytePtr, v15, (uint64_t)v16, v17, (void **)&v36[1], v36, &length[1], length);
  if (PayloadAndDigest)
  {
    AMFDRErrorPushInternal(a6, PayloadAndDigest, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreatePayloadAndDigest", CFSTR("failed to create payload digest"), v34);
    goto LABEL_39;
  }
  if (!*(_QWORD *)&v36[1] || !v36[0])
  {
    v32 = CFSTR("payload is invalid");
LABEL_37:
    AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreatePayloadAndDigest", v32, v34);
    goto LABEL_39;
  }
  if (!*(_QWORD *)&length[1] || !length[0])
  {
    v32 = CFSTR("digest is invalid");
    goto LABEL_37;
  }
  v19 = CFGetAllocator(a1);
  v20 = CFDataCreateWithBytesNoCopy(v19, *(const UInt8 **)&length[1], length[0], (CFAllocatorRef)*MEMORY[0x24BDBD258]);
  if (!v20)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreatePayloadAndDigest", CFSTR("digestData is NULL"), v34);
    goto LABEL_39;
  }
  v21 = v20;
  CFGetAllocator(a1);
  v22 = (const __CFString *)AMSupportCopyHexStringFromData();
  if (v22)
  {
    v23 = CFGetAllocator(a1);
    MutableCopy = CFStringCreateMutableCopy(v23, 0, v22);
    v25 = MutableCopy;
    if (MutableCopy)
    {
      CFStringLowercase(MutableCopy, 0);
      v26 = CFGetAllocator(a1);
      v27 = CFDataCreateWithBytesNoCopy(v26, *(const UInt8 **)&v36[1], v36[0], (CFAllocatorRef)*MEMORY[0x24BDBD248]);
      if (v27)
      {
        v28 = v27;
        *(_QWORD *)&v36[1] = 0;
        if (a4)
          *a4 = CFRetain(v27);
        if (a5)
          *a5 = CFRetain(v25);
        CFRelease(v7);
        CFRelease(v28);
        CFRelease(v21);
        v29 = 1;
        goto LABEL_20;
      }
      v33 = CFSTR("payloadData is NULL");
    }
    else
    {
      v33 = CFSTR("lowercaseDigest is NULL");
    }
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreatePayloadAndDigest", v33, v34);
  }
  else
  {
    AMFDRErrorPushInternal(a6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreatePayloadAndDigest", CFSTR("failed to convert digest string"), v34);
    v25 = 0;
  }
  CFRelease(v7);
  CFRelease(v21);
  v29 = 0;
  v7 = 0;
  if (v22)
  {
LABEL_20:
    CFRelease(v22);
    v7 = (const __CFString *)v29;
  }
  if (v25)
    CFRelease(v25);
LABEL_23:
  if (*(_QWORD *)&v36[1])
  {
    free(*(void **)&v36[1]);
    *(_QWORD *)&v36[1] = 0;
  }
  if (*(_QWORD *)&length[1])
    free(*(void **)&length[1]);
  return v7;
}

uint64_t AMFDRDataLocalPatchCreateSignedData(int a1, const __CFData *a2, CFDataRef theData, uint64_t a4)
{
  int inited;
  int v8;
  const __CFString *v10;
  const __CFString *v11;
  char v12;

  if (!a2)
  {
    v10 = CFSTR("payloadData is NULL");
LABEL_8:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreateSignedData", v10, v12);
    return 0;
  }
  if (!theData)
  {
    v10 = CFSTR("manifestData is NULL");
    goto LABEL_8;
  }
  CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  inited = Img4DecodeInitManifest();
  if (inited)
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreateSignedData", CFSTR("failed to decode manifest: %d"), inited);
  }
  else
  {
    CFDataGetBytePtr(a2);
    CFDataGetLength(a2);
    CFDataGetBytePtr(theData);
    CFDataGetLength(theData);
    v8 = Img4EncodeStitchManifest();
    if (v8 == 100)
    {
      v11 = CFSTR("img4 data is NULL");
    }
    else
    {
      v12 = v8;
      v11 = CFSTR("failed to create img4 data: %d");
    }
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatchCreateSignedData", v11, v12);
  }
  return 0;
}

CFDataRef AMFDRDataLocalCreateMultiCombinedData(const __CFArray *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFData *a5, const __CFData *a6, uint64_t a7)
{
  const __CFArray *v8;
  const __CFArray *v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex v14;
  int v15;
  CFIndex v16;
  const __CFData *v17;
  const __CFData *v18;
  const __CFString *ValueAtIndex;
  const __CFData *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFData *ExternalRepresentation;
  const __CFData *v24;
  const UInt8 *BytePtr;
  const __CFData *v26;
  int Length;
  const UInt8 *v28;
  int v29;
  const UInt8 *v30;
  const UInt8 *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  UInt8 *v36;
  unsigned int v37;
  const UInt8 *v38;
  unsigned int v39;
  int v40;
  CFDataRef v41;
  const __CFString *format;
  char v44;
  uint64_t v45;
  const __CFData *theData;
  const __CFData *v47;
  const __CFArray *v48;
  const __CFArray *v49;
  const __CFAllocator *alloc;
  CFDataRef cf;
  unsigned int v54;
  UInt8 *v55;
  int v56;
  void *v57;
  int v58;
  void *v59;
  _QWORD *v60[2];

  v59 = 0;
  v60[0] = (_QWORD *)0xAAAAAAAAAAAAAAAALL;
  v58 = 0;
  v57 = 0;
  v56 = 0;
  v55 = 0;
  v54 = 0;
  if (!a1)
  {
    format = CFSTR("dataClasses is NULL");
LABEL_63:
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateMultiCombinedData", format, v44);
LABEL_64:
    v41 = 0;
    v18 = 0;
    v17 = 0;
    cf = 0;
    goto LABEL_41;
  }
  v8 = a2;
  if (!a2)
  {
    format = CFSTR("dataInstances is NULL");
    goto LABEL_63;
  }
  if (!a3)
  {
    format = CFSTR("subCCs is NULL");
    goto LABEL_63;
  }
  if (!a4)
  {
    format = CFSTR("dataBlobs is NULL");
    goto LABEL_63;
  }
  v11 = a1;
  if (CFArrayGetCount(a1) <= 0)
  {
    format = CFSTR("at least one data should be specified");
    goto LABEL_63;
  }
  Count = CFArrayGetCount(v11);
  if (Count != CFArrayGetCount(v8))
  {
    format = CFSTR("dataInstances length does not match dataClasses");
    goto LABEL_63;
  }
  v13 = CFArrayGetCount(v11);
  if (v13 != CFArrayGetCount(a3))
  {
    format = CFSTR("subCCs length does not match dataClasses");
    goto LABEL_63;
  }
  v14 = CFArrayGetCount(v11);
  if (v14 != CFArrayGetCount(a4))
  {
    format = CFSTR("dataBlobs length does not match dataClasses");
    goto LABEL_63;
  }
  v15 = AMFDREncodeMultiCombinedDataPayloadBegin(v60);
  if (v15)
  {
    AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateMultiCombinedData", CFSTR("AMFDREncodeMultiCombinedDataPayloadBegin failed 0x%X"), v15);
    goto LABEL_64;
  }
  theData = a5;
  v47 = a6;
  v45 = a7;
  if (CFArrayGetCount(v11) >= 1)
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    alloc = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    cf = 0;
    v48 = v11;
    v49 = v8;
    while (1)
    {
      if (v18)
        CFRelease(v18);
      if (v17)
        CFRelease(v17);
      if (cf)
        CFRelease(cf);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v11, v16);
      v20 = (const __CFData *)CFArrayGetValueAtIndex(a4, v16);
      v21 = (const __CFString *)CFArrayGetValueAtIndex(v8, v16);
      v22 = (const __CFString *)CFArrayGetValueAtIndex(a3, v16);
      ExternalRepresentation = CFStringCreateExternalRepresentation(alloc, ValueAtIndex, 0x8000100u, 0x5Fu);
      if (v21 && CFStringCompare(v21, &stru_24C6A3418, 0))
      {
        v24 = CFStringCreateExternalRepresentation(alloc, v21, 0x8000100u, 0x5Fu);
        if (!v22)
          goto LABEL_25;
      }
      else
      {
        v24 = 0;
        if (!v22)
          goto LABEL_25;
      }
      if (CFStringCompare(v22, &stru_24C6A3418, 0))
      {
        cf = CFStringCreateExternalRepresentation(alloc, v22, 0x8000100u, 0x5Fu);
        goto LABEL_26;
      }
LABEL_25:
      cf = 0;
LABEL_26:
      BytePtr = CFDataGetBytePtr(ExternalRepresentation);
      v26 = ExternalRepresentation;
      Length = CFDataGetLength(ExternalRepresentation);
      v28 = CFDataGetBytePtr(v20);
      v29 = CFDataGetLength(v20);
      if (v24)
      {
        v30 = CFDataGetBytePtr(v24);
        v17 = v24;
        LODWORD(v24) = CFDataGetLength(v24);
      }
      else
      {
        v17 = 0;
        v30 = 0;
      }
      v31 = (const UInt8 *)cf;
      if (cf)
      {
        v31 = CFDataGetBytePtr(cf);
        v32 = CFDataGetLength(cf);
      }
      else
      {
        v32 = 0;
      }
      v33 = AMFDREncodeMultiCombinedDataPayloadAddData(v60, (uint64_t)BytePtr, Length, (uint64_t)v28, v29, (uint64_t)v30, (int)v24, (uint64_t)v31, v32);
      if (v33)
      {
        AMFDRErrorPushInternal(v45, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateMultiCombinedData", CFSTR("AMFDREncodeMultiCombinedDataPayloadAddData failed 0x%X"), v33);
        v41 = 0;
        v18 = v26;
        goto LABEL_41;
      }
      ++v16;
      v11 = v48;
      v18 = v26;
      v8 = v49;
      if (v16 >= CFArrayGetCount(v48))
        goto LABEL_36;
    }
  }
  v18 = 0;
  v17 = 0;
  cf = 0;
LABEL_36:
  v34 = AMFDREncodeMultiCombinedDataPayloadEnd(v60, &v59, &v58);
  if (v34)
  {
    AMFDRErrorPushInternal(v45, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateMultiCombinedData", CFSTR("AMFDREncodeMultiCombinedDataPayloadEnd failed 0x%X"), v34);
LABEL_68:
    v41 = 0;
    goto LABEL_41;
  }
  v35 = Img4EncodeStitchManifest();
  if (v35 != 100)
  {
    AMFDRErrorPushInternal(v45, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateMultiCombinedData", CFSTR("Img4EncodeStitchManifest failed 0x%X"), v35);
    goto LABEL_68;
  }
  v36 = (UInt8 *)CFDataGetBytePtr(theData);
  v37 = CFDataGetLength(theData);
  v38 = CFDataGetBytePtr(v47);
  v39 = CFDataGetLength(v47);
  v40 = FDREncodeCreateCombinedFast((uint64_t)v57, v56, v36, v37, v38, v39, (char **)&v55, &v54);
  if (v40)
  {
    AMFDRErrorPushInternal(v45, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateMultiCombinedData", CFSTR("AMFDREncodeMultiRequestEnd failed 0x%X"), v40);
    v41 = 0;
  }
  else
  {
    v41 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], v55, v54);
    if (!v41)
      AMFDRErrorPushInternal(v45, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCreateMultiCombinedData", CFSTR("outData is NULL"), v44);
  }
LABEL_41:
  if (v59)
  {
    free(v59);
    v59 = 0;
  }
  if (v57)
  {
    free(v57);
    v57 = 0;
  }
  if (v55)
  {
    free(v55);
    v55 = 0;
  }
  if (v18)
    CFRelease(v18);
  if (v17)
    CFRelease(v17);
  if (cf)
    CFRelease(cf);
  AMFDREncodeMetadataDestroy(v60);
  return v41;
}

CFDataRef AMFDRDataLocalCopyDigest(const __CFData *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFDataRef v5;
  const __CFData *v6;
  const __CFData *v7;
  const UInt8 *BytePtr;
  const __CFAllocator *v9;
  uint64_t v11;
  CFIndex v12;
  const __CFString *v13;
  void *value[2];
  void *v15[2];
  __int128 v16;
  const __CFString *v17;
  char v18;
  UInt8 bytes[16];
  uint64_t v20;

  v5 = a1;
  v20 = *MEMORY[0x24BDAC8D0];
  memset(bytes, 170, sizeof(bytes));
  if (!a1)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyDigest", CFSTR("amfdr is NULL"), v18);
    return v5;
  }
  if (!a2)
  {
    v17 = CFSTR("dataClassStr is NULL");
    *(_OWORD *)v15 = 0u;
    v16 = 0u;
    *(_OWORD *)value = 0u;
    v11 = a4;
    v12 = 1;
LABEL_13:
    AMFDRErrorPushInternal(v11, v12, 0, 0, 0, 0, 0, 0, value[0], value[1], v15[0], v15[1], (void *)v16, *((void **)&v16 + 1), (uint64_t)"AMFDRDataLocalCopyDigest", v17, v18);
    return 0;
  }
  if (!a3)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyDigest", CFSTR("dataInstanceStr is NULL."), v18);
    return 0;
  }
  v6 = (const __CFData *)AMFDRDataLocalPopulate(a1, a2, a3, 0, a4);
  if (!v6)
  {
    v17 = CFSTR("Failed to read data");
    *(_OWORD *)v15 = 0u;
    v16 = 0u;
    *(_OWORD *)value = 0u;
    v11 = a4;
    v12 = 4;
    goto LABEL_13;
  }
  v7 = v6;
  BytePtr = CFDataGetBytePtr(v6);
  CFDataGetLength(v7);
  if (!AMFDRDigestMd5((uint64_t)BytePtr))
  {
    v13 = CFSTR("Failed to compute md5");
LABEL_17:
    AMFDRErrorPushInternal(a4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyDigest", v13, v18);
    v5 = 0;
    goto LABEL_7;
  }
  v9 = CFGetAllocator(v5);
  v5 = CFDataCreate(v9, bytes, 16);
  if (!v5)
  {
    v13 = CFSTR("CFDataCreate failed to create md5 data");
    goto LABEL_17;
  }
LABEL_7:
  CFRelease(v7);
  return v5;
}

BOOL AMFDRDataLocalPresent(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  const void *v6;
  int v7;
  const __CFString *v9;
  uint64_t v10;
  CFIndex v11;
  void *value[2];
  void *v13[2];
  __int128 v14;
  const __CFString *v15;
  char v16;
  unsigned __int8 v17;

  v17 = 0;
  if (!a1)
  {
    v9 = CFSTR("amfdr is NULL");
LABEL_11:
    v15 = v9;
    *(_OWORD *)v13 = 0u;
    v14 = 0u;
    *(_OWORD *)value = 0u;
    v10 = a4;
    v11 = 1;
LABEL_14:
    AMFDRErrorPushInternal(v10, v11, 0, 0, 0, 0, 0, 0, value[0], value[1], v13[0], v13[1], (void *)v14, *((void **)&v14 + 1), (uint64_t)"AMFDRDataLocalPresent", v15, v16);
    goto LABEL_15;
  }
  if (!a2)
  {
    v9 = CFSTR("dataClassStr is NULL");
    goto LABEL_11;
  }
  if (!a3)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPresent", CFSTR("dataInstanceStr is NULL."), v16);
LABEL_15:
    v7 = 0;
    return v7 != 0;
  }
  v5 = AMFDRDataLocalCopyDataStoragePath(a1, a2, a3, a4);
  if (!v5)
  {
    v15 = CFSTR("missing data storage path");
    *(_OWORD *)v13 = 0u;
    v14 = 0u;
    *(_OWORD *)value = 0u;
    v10 = a4;
    v11 = 4;
    goto LABEL_14;
  }
  v6 = (const void *)v5;
  if (MEMORY[0x212BA048C](v5, &v17))
  {
    AMFDRErrorPushInternal(a4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPresent", CFSTR("Failed to read data"), v16);
    v7 = 0;
  }
  else
  {
    v7 = v17;
  }
  CFRelease(v6);
  return v7 != 0;
}

uint64_t AMFDRDataLocalCopy(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  const void *v7;
  const __CFString *v9;
  const __CFString *v10;
  char v11;

  if (!a1)
  {
    v9 = CFSTR("amfdr is NULL");
LABEL_10:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopy", v9, v11);
    return 0;
  }
  if (!a2)
  {
    v9 = CFSTR("dataClassStr is NULL");
    goto LABEL_10;
  }
  if (a3)
  {
    v6 = AMFDRDataLocalCopyDataStoragePath(a1, a2, a3, a4);
    if (v6)
    {
      v7 = (const void *)v6;
      CFGetAllocator(a1);
      if (AMSupportCreateDataFromFileURL())
      {
        v10 = CFSTR("Failed to read data");
      }
      else
      {
        v11 = (char)v7;
        v10 = CFSTR("Failed to read data from %@");
      }
      AMFDRErrorPushInternal(a4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopy", v10, v11);
      CFRelease(v7);
    }
    else
    {
      AMFDRErrorPushInternal(a4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopy", CFSTR("missing data storage path"), v11);
    }
  }
  else
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopy", CFSTR("dataInstanceStr is NULL."), v11);
  }
  return 0;
}

BOOL AMFDRDataLocalDelete(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL8 v5;
  uint64_t v8;
  const __CFString *v9;
  const __CFBoolean *Value;
  const __CFBoolean *v11;
  CFTypeID v12;
  const __CFAllocator *v13;
  CFStringRef v14;
  CFStringRef v15;
  const void *v16;
  int v17;
  CFStringRef v18;
  char v20;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalDelete", CFSTR("amfdr is NULL"), v20);
    return 0;
  }
  v5 = a2;
  if (a2)
  {
    if (a3)
    {
      v8 = AMFDRDataLocalCopyDataStoragePath((_QWORD *)a1, a2, a3, a4);
      if (v8)
      {
        v9 = (const __CFString *)v8;
        if (AMSupportRemoveFile())
        {
          AMFDRErrorPushInternal(a4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalDelete", CFSTR("failed to delete data at %@"), (char)v9);
        }
        else
        {
          if ((AMFDRDataLocalDeleteExtraManifest((_QWORD *)a1, 1, v5, a3, (uint64_t)&cf) & 1) == 0)
            AMSupportLogInternal();
          if ((AMFDRDataLocalDeleteExtraManifest((_QWORD *)a1, 0, v5, a3, (uint64_t)&cf) & 1) == 0)
            AMSupportLogInternal();
          Value = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("kAMFDROptionOfflineSigning"));
          if (!Value || (v11 = Value, v12 = CFGetTypeID(Value), v12 != CFBooleanGetTypeID()) || !CFBooleanGetValue(v11))
          {
            v5 = 1;
LABEL_20:
            v18 = v9;
LABEL_21:
            CFRelease(v18);
            goto LABEL_22;
          }
          v13 = CFGetAllocator((CFTypeRef)a1);
          v14 = CFStringCreateWithFormat(v13, 0, CFSTR("%@.offline"), a3);
          if (v14)
          {
            v15 = v14;
            v16 = (const void *)AMFDRDataLocalCopyDataStoragePath((_QWORD *)a1, v5, (uint64_t)v14, a4);
            v17 = AMSupportRemoveFile();
            v5 = v17 == 0;
            if (v17)
              AMFDRErrorPushInternal(a4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalDelete", CFSTR("failed to delete data at %@"), (char)v9);
            CFRelease(v9);
            if (v16)
              CFRelease(v16);
            v18 = v15;
            goto LABEL_21;
          }
          AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalDelete", CFSTR("offlineDataInstanceStr is NULL"), v20);
        }
        v5 = 0;
        goto LABEL_20;
      }
      AMFDRErrorPushInternal(a4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalDelete", CFSTR("missing data storage path"), v20);
    }
    else
    {
      AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalDelete", CFSTR("dataInstanceStr is NULL."), v20);
    }
    v5 = 0;
  }
  else
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalDelete", CFSTR("dataClassStr is NULL"), v20);
  }
LABEL_22:
  if (cf)
    CFRelease(cf);
  return v5;
}

uint64_t AMFDRDataLocalPrefetch(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPrefetch", CFSTR("AMFDRDataLocalPrefetch is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataLocalExport(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalExport", CFSTR("AMFDRDataLocalExport is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataLocalCopyTrustObject(_QWORD *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  const __CFDictionary *v6;
  uint64_t v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  const __CFString *v13;
  char v14;

  if (!a1)
  {
    v13 = CFSTR("amfdr is NULL");
LABEL_16:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyTrustObject", v13, v14);
    return 0;
  }
  v6 = (const __CFDictionary *)a1[2];
  if (!v6)
  {
    v13 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_16;
  }
  if (!CFDictionaryGetValue(v6, CFSTR("TrustObjectDigest")))
  {
    v9 = 0;
    goto LABEL_8;
  }
  v8 = AMSupportCopyHexStringFromData();
  if (!v8)
  {
    AMFDRErrorPushInternal(a4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyTrustObject", CFSTR("Failed to convert trust object digest to hex"), v14);
    return 0;
  }
  v9 = (const void *)v8;
  v10 = AMFDRDataLocalCopy(a1, (uint64_t)CFSTR("trustobject"), v8, a4);
  if (v10)
    goto LABEL_9;
LABEL_8:
  v10 = AMFDRDataLocalCopy(a1, (uint64_t)CFSTR("trustobject"), (uint64_t)CFSTR("current"), a4);
  if (v10)
  {
LABEL_9:
    *a3 = v10;
    v11 = 1;
    if (!v9)
      return v11;
    goto LABEL_12;
  }
  v11 = 0;
  if (v9)
LABEL_12:
    CFRelease(v9);
  return v11;
}

BOOL AMFDRDataLocalPutTrustObject(_QWORD *a1, CFDataRef theData, uint64_t a3)
{
  __int128 v4;
  const __CFAllocator *v7;
  CFDataRef v8;
  CFDataRef v9;
  uint64_t v10;
  int v11;
  const void *v12;
  _BOOL8 v13;
  const __CFString *v15;
  UInt8 bytes[16];
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)bytes = v4;
  v17 = v4;
  if (!a1)
  {
    v15 = CFSTR("amfdr is NULL");
LABEL_10:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPutTrustObject", v15, bytes[0]);
    return 0;
  }
  if (!theData)
  {
    v15 = CFSTR("valueData is NULL");
    goto LABEL_10;
  }
  CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  if (AMSupportDigestSha256())
  {
    AMFDRErrorPushInternal(a3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPutTrustObject", CFSTR("Failed to get digest of trustobject"), bytes[0]);
    return 0;
  }
  v7 = CFGetAllocator(a1);
  v8 = CFDataCreateWithBytesNoCopy(v7, bytes, 32, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
  if (!v8)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPutTrustObject", CFSTR("Failed to create trustobjectDigestData"), bytes[0]);
    return 0;
  }
  v9 = v8;
  v10 = AMSupportCopyHexStringFromData();
  if (!v10)
  {
    AMFDRErrorPushInternal(a3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPutTrustObject", CFSTR("Failed to convert trust object digest to hex"), bytes[0]);
    CFRelease(v9);
    return 0;
  }
  v12 = (const void *)v10;
  v13 = AMFDRDataLocalPutWithOptions(a1, (uint64_t)CFSTR("trustobject"), v10, (_BOOL8)theData, v11, a3);
  CFRelease(v9);
  CFRelease(v12);
  return v13;
}

uint64_t AMFDRDataLocalIterate(_QWORD *a1, unsigned int (*a2)(const __CFString *, CFTypeRef, CFDataRef, CFTypeRef, uint64_t), uint64_t a3, uint64_t a4)
{
  CFTypeRef v8;
  CFTypeRef v9;
  CFAllocatorRef v10;
  uint64_t v11;
  uint64_t v12;
  const __CFString *PathComponent;
  const __CFAllocator *v14;
  CFIndex v15;
  CFDataRef v16;
  uint64_t v17;
  char v19;
  uint64_t v20;
  CFURLRef url;
  char v22;
  CFTypeRef cf;
  const __CFString *v24;
  CFTypeRef v25;
  CFTypeRef v26;

  v25 = 0;
  v26 = 0;
  v24 = 0;
  cf = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalIterate", CFSTR("amfdr is NULL"), v19);
    v17 = 0;
    goto LABEL_28;
  }
  v8 = AMFDRDataLocalCopyDataDirectoryPath(a1, a3);
  v9 = v8;
  if (!v8)
  {
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalIterate", CFSTR("Could not determine data directory URL"), v19);
LABEL_34:
    v17 = 0;
    goto LABEL_28;
  }
  v22 = 0;
  if (MEMORY[0x212BA048C](v8, &v22))
  {
    AMFDRErrorPushInternal(a3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalIterate", CFSTR("Could not determine if data directory %@ exists"), (char)v9);
    goto LABEL_34;
  }
  if (v22)
  {
    v10 = CFGetAllocator(a1);
    v11 = MEMORY[0x212BA0AA4](v10, v9, 0, 0);
    if (v11)
    {
      v20 = a3;
      while (1)
      {
        while (1)
        {
          url = 0;
          v12 = MEMORY[0x212BA0AB0](v11, &url, &v26);
          if (v12 == 2)
          {
LABEL_26:
            v17 = 1;
            goto LABEL_28;
          }
          if (v12 == 3)
          {
            AMFDRErrorPushInternal(v20, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalIterate", CFSTR("Failed to enumerate path: %@"), (char)v26);
            v17 = 0;
            goto LABEL_28;
          }
          PathComponent = CFURLCopyLastPathComponent(url);
          if (!PathComponent)
          {
            AMFDRErrorPushInternal(v20, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalIterate", CFSTR("Could not get filename of URL '%@'"), (char)url);
            v17 = 0;
            goto LABEL_28;
          }
          v14 = CFGetAllocator(a1);
          v15 = CFStringHasPrefix(PathComponent, CFSTR("minimal-manifest")) ? 2 : 1;
          if ((AMFDRDataLocalDecomposeFullKeyInternal(v14, v15, PathComponent, (CFTypeRef *)&v24, &cf) & 1) != 0)
            break;
          AMSupportLogInternal();
          CFRelease(PathComponent);
        }
        v16 = AMFDRDataCopy((uint64_t)a1, v24, (const __CFString *)cf, (uint64_t)&v25);
        if (!v16)
          break;
        if (!a2(v24, cf, v16, v25, a4))
          goto LABEL_26;
        if (v26)
        {
          CFRelease(v26);
          v26 = 0;
        }
        CFRelease(PathComponent);
        if (v24)
        {
          CFRelease(v24);
          v24 = 0;
        }
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        CFRelease(v16);
        if (v25)
        {
          CFRelease(v25);
          v25 = 0;
        }
      }
      AMSupportLogInternal();
      v17 = 0;
    }
    else
    {
      AMFDRErrorPushInternal(a3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalIterate", CFSTR("Could not create directory enumerator at '%@'"), (char)v9);
      v17 = 0;
    }
  }
  else
  {
    v17 = 1;
  }
LABEL_28:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v17;
}

uint64_t AMFDRDataLocalMake(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMake", CFSTR("AMFDRDataLocalMake is not implemented"), vars0);
  return 0;
}

const void *AMFDRDataLocalMultiCopy(_QWORD *a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4)
{
  return _AMFDRDataLocalMultiCopyInternal(a1, a2, a3, 0, 0, a4);
}

uint64_t AMFDRDataLocalMultiPutWithOptions(_QWORD *a1, CFArrayRef theArray, const __CFArray *a3, const __CFArray *a4, uint64_t a5, uint64_t a6)
{
  CFIndex Count;
  CFIndex v11;
  const __CFAllocator *v12;
  CFIndex v13;
  CFStringRef v14;
  const void *ValueAtIndex;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  _BOOL8 v19;
  const __CFAllocator *v20;
  CFStringRef v21;
  int v22;
  const __CFString *format;
  const __CFString *v25;
  char v26;
  __CFDictionary *theDict;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
  {
    v25 = CFSTR("amfdr is NULL");
LABEL_43:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiPutWithOptions", v25, v26);
    return 0;
  }
  if (!theArray)
  {
    v25 = CFSTR("dataClassArray is NULL");
    goto LABEL_43;
  }
  if (!a3)
  {
    v25 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_43;
  }
  if (!a4)
  {
    v25 = CFSTR("valueDataArray is NULL");
    goto LABEL_43;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v25 = CFSTR("Invalid dataClassArray count");
    goto LABEL_43;
  }
  v11 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v25 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_43;
  }
  if (CFArrayGetCount(a4) != v11)
  {
    v25 = CFSTR("Invalid dataValueArray count");
    goto LABEL_43;
  }
  v12 = CFGetAllocator(a1);
  theDict = CFDictionaryCreateMutable(v12, v11, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiPutWithOptions", CFSTR("multiRequestErrors is NULL"), v26);
    return 0;
  }
  v13 = 0;
  v14 = 0;
  while (1)
  {
    if (v14)
      CFRelease(v14);
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v13);
    if (!ValueAtIndex)
    {
      format = CFSTR("dataClassStr is NULL");
LABEL_31:
      AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiPutWithOptions", format, v26);
      goto LABEL_33;
    }
    v16 = (uint64_t)ValueAtIndex;
    v17 = (uint64_t)CFArrayGetValueAtIndex(a3, v13);
    if (!v17)
    {
      AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiPutWithOptions", CFSTR("dataInstanceStr is NULL"), v26);
      goto LABEL_25;
    }
    v18 = CFArrayGetValueAtIndex(a4, v13);
    if (!v18)
    {
      format = CFSTR("valueData is NULL");
      goto LABEL_31;
    }
    v19 = (_BOOL8)v18;
    v20 = CFGetAllocator(a1);
    v21 = CFStringCreateWithFormat(v20, 0, CFSTR("%@-%@"), v16, v17);
    if (!v21)
      break;
    v14 = v21;
    if (!AMFDRDataLocalPutWithOptions(a1, v16, v17, v19, v22, a6))
    {
      AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiPutWithOptions", CFSTR("AMFDRDataLocalPut failed"), v26);
      if (!cf)
      {
        AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiPutWithOptions", CFSTR("internalError is NULL"), v26);
        goto LABEL_35;
      }
      CFDictionaryAddValue(theDict, v14, cf);
    }
    if (v11 == ++v13)
    {
      if (!CFDictionaryGetCount(theDict))
      {
        v17 = 1;
LABEL_24:
        CFRelease(v14);
        goto LABEL_25;
      }
      AMFDRErrorPushInternal(a6, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiPutWithOptions", CFSTR("got multiRequestErrors"), v26);
LABEL_35:
      v17 = 0;
      goto LABEL_24;
    }
  }
  AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiPutWithOptions", CFSTR("currDataInstance is NULL"), v26);
LABEL_33:
  v17 = 0;
LABEL_25:
  CFRelease(theDict);
  if (cf)
    CFRelease(cf);
  return v17;
}

uint64_t AMFDRDataLocalMultiDelete(const void *a1, CFArrayRef theArray, const __CFArray *a3, uint64_t a4)
{
  CFIndex Count;
  CFIndex v9;
  const __CFAllocator *v10;
  CFIndex v11;
  CFStringRef v12;
  const void *ValueAtIndex;
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  const __CFAllocator *v17;
  CFStringRef v18;
  uint64_t v19;
  const __CFString *v21;
  uint64_t v22;
  CFIndex v23;
  const __CFString *v24;
  void *value[6];
  CFStringRef format;
  CFMutableDictionaryRef theDict;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
  {
    v24 = CFSTR("amfdr is NULL");
LABEL_37:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiDelete", v24, (char)theDict);
    return 0;
  }
  if (!theArray)
  {
    v24 = CFSTR("dataClassStr is NULL");
    goto LABEL_37;
  }
  if (!a3)
  {
    v24 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_37;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v24 = CFSTR("Invalid dataClassArray count");
    goto LABEL_37;
  }
  v9 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v24 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_37;
  }
  v10 = CFGetAllocator(a1);
  theDict = CFDictionaryCreateMutable(v10, v9, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiDelete", CFSTR("multiRequestErrors is NULL"), 0);
    return 0;
  }
  v11 = 0;
  v12 = 0;
  while (1)
  {
    if (v12)
      CFRelease(v12);
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v11);
    if (!ValueAtIndex)
    {
      v21 = CFSTR("dataClassStr is NULL");
LABEL_27:
      AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiDelete", v21, (char)theDict);
      goto LABEL_29;
    }
    v14 = (uint64_t)ValueAtIndex;
    v15 = CFArrayGetValueAtIndex(a3, v11);
    if (!v15)
    {
      v21 = CFSTR("dataInstanceStr is NULL");
      goto LABEL_27;
    }
    v16 = (uint64_t)v15;
    v17 = CFGetAllocator(a1);
    v18 = CFStringCreateWithFormat(v17, 0, CFSTR("%@-%@"), v14, v16);
    if (!v18)
      break;
    v12 = v18;
    if (!AMFDRDataLocalDelete((uint64_t)a1, v14, v16, a4))
    {
      AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiDelete", CFSTR("AMFDRDataLocalDelete failed"), (char)theDict);
      if (!cf)
      {
        format = CFSTR("internalError is NULL");
        memset(value, 0, sizeof(value));
        v22 = a4;
        v23 = 2;
        goto LABEL_31;
      }
      CFDictionaryAddValue(theDict, v12, cf);
    }
    if (v9 == ++v11)
    {
      if (!CFDictionaryGetCount(theDict))
      {
        v19 = 1;
LABEL_21:
        CFRelease(v12);
        goto LABEL_22;
      }
      format = CFSTR("got multiRequestErrors");
      memset(&value[1], 0, 40);
      value[0] = theDict;
      v22 = a4;
      v23 = 21;
LABEL_31:
      AMFDRErrorPushInternal(v22, v23, 0, 0, 0, 0, 0, 0, value[0], value[1], value[2], value[3], value[4], value[5], (uint64_t)"AMFDRDataLocalMultiDelete", format, (char)theDict);
      v19 = 0;
      goto LABEL_21;
    }
  }
  AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiDelete", CFSTR("currDataInstance is NULL"), (char)theDict);
LABEL_29:
  v19 = 0;
LABEL_22:
  CFRelease(theDict);
  if (cf)
    CFRelease(cf);
  return v19;
}

uint64_t AMFDRDataLocalMultiExport(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiExport", CFSTR("AMFDRDataLocalMultiExport is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataLocalMultiMake(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiMake", CFSTR("AMFDRDataLocalMultiMake is not implemented"), vars0);
  return 0;
}

CFTypeRef AMFDRDataLocalPopulate(_QWORD *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4, uint64_t a5)
{
  const __CFData *v10;
  CFTypeRef DataWithManifestsInternal;
  const __CFAllocator *v12;
  __CFDictionary *Mutable;
  __CFDictionary *v14;
  void *value;
  const __CFData *v17;
  const __CFData *v18;
  uint64_t v19;

  v18 = 0;
  v19 = 0;
  value = 0;
  v17 = 0;
  v10 = (const __CFData *)AMFDRDataLocalCopy(a1, a2, a3, a5);
  if (v10)
  {
    if ((AMFDRDataLocalCopyExtraManifest(a1, 1, a2, a3, (uint64_t)&v18, (uint64_t)&v19) & 1) == 0)
      AMSupportLogInternal();
    if ((AMFDRDataLocalCopyExtraManifest(a1, 0, a2, a3, (uint64_t)&v17, (uint64_t)&v19) & 1) == 0)
      AMSupportLogInternal();
    DataWithManifestsInternal = AMFDRDataLocalCreateDataWithManifestsInternal(a1, v10, v18, v17, 0, (CFTypeRef *)&value, a5);
    if (DataWithManifestsInternal)
    {
      if (a4)
      {
        v12 = CFGetAllocator(a1);
        Mutable = CFDictionaryCreateMutable(v12, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        v14 = Mutable;
        if (Mutable)
        {
          if (value)
          {
            CFDictionarySetValue(Mutable, CFSTR("CombinedManifest"), value);
            if (!v18)
              CFDictionarySetValue(v14, CFSTR("DeviceManifestMissing"), (const void *)*MEMORY[0x24BDBD270]);
          }
          *a4 = CFRetain(v14);
        }
        else
        {
          AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPopulate", CFSTR("populateInfo is NULL"), (char)value);
        }
      }
    }
    else
    {
      AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPopulate", CFSTR("Failed to populate local data with manifests"), (char)value);
    }
  }
  else
  {
    AMFDRErrorPushInternal(a5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPopulate", CFSTR("Failed to populate local data"), (char)value);
    DataWithManifestsInternal = 0;
  }
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return DataWithManifestsInternal;
}

const void *AMFDRDataLocalMultiPopulate(_QWORD *a1, const __CFArray *a2, const __CFArray *a3, CFTypeRef *a4, uint64_t a5)
{
  return _AMFDRDataLocalMultiCopyInternal(a1, a2, a3, 1, a4, a5);
}

BOOL AMFDRDataLocalCommit(_QWORD *a1, uint64_t a2, uint64_t a3, _BOOL8 a4, const __CFDictionary *a5, uint64_t a6)
{
  _BOOL8 v11;
  const void *Value;
  const void *v13;
  char v15;
  CFTypeRef v16;

  v16 = 0;
  v11 = AMFDRDataLocalPutWithOptions(a1, a2, a3, a4, (int)a5, a6);
  if (v11)
  {
    if (a5)
    {
      Value = CFDictionaryGetValue(a5, CFSTR("DeviceManifest"));
      if ((AMFDRDataLocalPutExtraManifest(a1, 1, Value, a2, a3, (uint64_t)&v16) & 1) == 0)
        AMSupportLogInternal();
      v13 = CFDictionaryGetValue(a5, CFSTR("StationManifest"));
      if ((AMFDRDataLocalPutExtraManifest(a1, 0, v13, a2, a3, (uint64_t)&v16) & 1) == 0)
        AMSupportLogInternal();
      if (v16)
        CFRelease(v16);
    }
  }
  else
  {
    AMFDRErrorPushInternal(a6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCommit", CFSTR("Failed to commit local data"), v15);
  }
  return v11;
}

const void *AMFDRDataLocalMultiCopyDigest(_QWORD *a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4)
{
  return _AMFDRDataLocalMultiCopyInternal(a1, a2, a3, 2, 0, a4);
}

uint64_t AMFDRDataLocalCopyManifest(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v12;
  const __CFString *v14;
  const __CFString *v15;
  CFTypeRef cf;
  CFTypeRef v17;

  v17 = 0;
  cf = 0;
  if (!a1)
  {
    v14 = CFSTR("amfdr is NULL");
LABEL_19:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyManifest", v14, (char)cf);
LABEL_23:
    v12 = 0;
    goto LABEL_11;
  }
  if (!a2)
  {
    v14 = CFSTR("dataClassStr is NULL");
    goto LABEL_19;
  }
  if (!a3)
  {
    v14 = CFSTR("dataInstanceStr is NULL.");
    goto LABEL_19;
  }
  if ((AMFDRDataLocalCopyExtraManifest(a1, 1, a2, a3, (uint64_t)&v17, a6) & 1) == 0)
  {
    v15 = CFSTR("Failed to copy device manifest");
LABEL_22:
    AMFDRErrorPushInternal(a6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyManifest", v15, (char)cf);
    goto LABEL_23;
  }
  if ((AMFDRDataLocalCopyExtraManifest(a1, 0, a2, a3, (uint64_t)&cf, a6) & 1) == 0)
  {
    v15 = CFSTR("Failed to copy station manifest");
    goto LABEL_22;
  }
  if (a4)
    *a4 = AMSupportSafeRetain();
  if (a5)
    *a5 = AMSupportSafeRetain();
  v12 = 1;
LABEL_11:
  if (v17)
  {
    CFRelease(v17);
    v17 = 0;
  }
  if (cf)
    CFRelease(cf);
  return v12;
}

const void *AMFDRDataLocalMultiCopyManifest(_QWORD *a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4)
{
  return _AMFDRDataLocalMultiCopyInternal(a1, a2, a3, 3, 0, a4);
}

CFTypeRef AMFDRDataLocalPatch(_QWORD *a1, const __CFString *a2, const void *a3, CFArrayRef *a4, const __CFDictionary *a5, uint64_t a6, uint64_t a7)
{
  char vars0;

  if (!a6)
    return _AMFDRDataLocalPatchInternal(a1, a2, a3, a4, 0, a5, a7);
  AMFDRErrorPushInternal(a7, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPatch", CFSTR("metadataDict is not supported for local patch"), vars0);
  return 0;
}

CFTypeRef AMFDRDataLocalMultiPatch(const void *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, uint64_t a6, uint64_t a7)
{
  char vars0;

  if (!a6)
    return _AMFDRDataLocalMultiPatchInternal(a1, a2, a3, a4, 0, a5, a7);
  AMFDRErrorPushInternal(a7, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiPatch", CFSTR("metadataDictArray is not supported for local patch"), vars0);
  return 0;
}

CFTypeRef AMFDRDataLocalCommitPatch(_QWORD *a1, const __CFString *a2, const void *a3, const __CFData *a4, const __CFDictionary *a5, uint64_t a6, uint64_t a7)
{
  char vars0;

  if (!a6)
    return _AMFDRDataLocalPatchInternal(a1, a2, a3, 0, a4, a5, a7);
  AMFDRErrorPushInternal(a7, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCommitPatch", CFSTR("metadataDict is not supported for local patch"), vars0);
  return 0;
}

CFTypeRef AMFDRDataLocalMultiCommitPatch(const void *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, uint64_t a6, uint64_t a7)
{
  char vars0;

  if (!a6)
    return _AMFDRDataLocalMultiPatchInternal(a1, a2, a3, 0, a4, a5, a7);
  AMFDRErrorPushInternal(a7, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiCommitPatch", CFSTR("metadataDictArray is not supported for local patch"), vars0);
  return 0;
}

uint64_t AMFDRDataLocalUpdateMetadataWithOptions(int a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  char vars0;

  AMFDRErrorPushInternal(a6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalUpdateMetadataWithOptions", CFSTR("AMFDRDataLocalUpdateMetadataWithOptions is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataLocalMultiUpdateMetadataWithOptions(int a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  char vars0;

  AMFDRErrorPushInternal(a6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiUpdateMetadataWithOptions", CFSTR("AMFDRDataLocalMultiUpdateMetadataWithOptions is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataLocalMultiCopyAsidMetadata(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalMultiCopyAsidMetadata", CFSTR("AMFDRDataLocalMultiCopyAsidMetadata is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataLocalRevert(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalRevert", CFSTR("AMFDRDataLocalRevert is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataLocalDeleteExtraManifest(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  char v7;
  uint64_t v8;
  char v10;
  char v11;

  v11 = 0;
  v6 = AMFDRDataLocalCopyExtraManifestPath(a1, a2, a3, a4, a5);
  v7 = v6;
  if (!v6)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalDeleteExtraManifest", CFSTR("manifestURL is NULL"), v10);
LABEL_8:
    v8 = 0;
    goto LABEL_5;
  }
  v8 = 1;
  if (!MEMORY[0x212BA048C](v6, &v11) && v11 == 1 && AMSupportRemoveFile())
  {
    AMFDRErrorPushInternal(a5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalDeleteExtraManifest", CFSTR("failed to delete manifest: %@"), v7);
    goto LABEL_8;
  }
LABEL_5:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v8;
}

uint64_t AMFDRDataLocalCopyExtraManifestPath(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const __CFString *v9;
  const __CFAllocator *v10;
  CFStringRef v11;
  uint64_t v12;
  char v14;

  if (a2)
    v9 = CFSTR("mandev");
  else
    v9 = CFSTR("mansta");
  v10 = CFGetAllocator(a1);
  v11 = CFStringCreateWithFormat(v10, 0, CFSTR("%@-%@"), v9, a3);
  if (v11)
  {
    v12 = AMFDRDataLocalCopyDataStoragePath(a1, (uint64_t)v11, a4, a5);
  }
  else
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyExtraManifestPath", CFSTR("manifestPrefix is NULL"), v14);
    v12 = 0;
  }
  AMSupportSafeRelease();
  return v12;
}

const void *_AMFDRDataLocalMultiCopyInternal(_QWORD *a1, CFArrayRef theArray, const __CFArray *a3, int a4, CFTypeRef *a5, uint64_t a6)
{
  CFIndex Count;
  CFIndex v12;
  const __CFAllocator *v13;
  const __CFAllocator *v14;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v16;
  const __CFAllocator *v17;
  CFMutableDictionaryRef v18;
  const void *v19;
  void *v20;
  __CFDictionary *v21;
  CFIndex v22;
  CFStringRef v23;
  const void *ValueAtIndex;
  uint64_t v25;
  const __CFAllocator *v26;
  CFStringRef v27;
  uint64_t v28;
  const __CFAllocator *v29;
  CFMutableDictionaryRef v30;
  const __CFString *format;
  char v33;
  uint64_t v34;
  CFTypeRef *v35;
  __CFDictionary *value;
  CFMutableDictionaryRef theDict;
  __CFDictionary *v38;
  CFTypeRef cf;
  const void *v41;
  CFTypeRef v42;
  const void *v43[2];

  cf = 0;
  v42 = 0;
  v43[0] = 0;
  v41 = 0;
  if (!a1)
  {
    format = CFSTR("amfdr is NULL");
LABEL_81:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", format, v33);
LABEL_82:
    v19 = 0;
    v21 = 0;
    goto LABEL_58;
  }
  if (!theArray)
  {
    format = CFSTR("dataClassArray is NULL");
    goto LABEL_81;
  }
  if (!a3)
  {
    format = CFSTR("dataInstanceArray is NULL");
    goto LABEL_81;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    format = CFSTR("Invalid dataClassArray count");
    goto LABEL_81;
  }
  v12 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    format = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_81;
  }
  v13 = CFGetAllocator(a1);
  theDict = CFDictionaryCreateMutable(v13, v12, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("valueDataDict is NULL"), v33);
    goto LABEL_82;
  }
  v14 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v14, v12, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("errorDict is NULL"), v33);
    CFRelease(theDict);
    goto LABEL_82;
  }
  v16 = Mutable;
  if (a4 == 1)
  {
    v17 = CFGetAllocator(a1);
    v18 = CFDictionaryCreateMutable(v17, v12, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (!v18)
    {
      AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("populateInfoDict is NULL"), v33);
      v19 = 0;
      v20 = 0;
      v21 = 0;
      goto LABEL_56;
    }
  }
  else
  {
    v18 = 0;
  }
  v35 = a5;
  value = v16;
  v38 = v18;
  v34 = a6;
  v22 = 0;
  v23 = 0;
  v20 = 0;
  while (2)
  {
    if (v23)
      CFRelease(v23);
    if (v20)
      CFRelease(v20);
    if (v42)
    {
      CFRelease(v42);
      v42 = 0;
    }
    if (v41)
    {
      CFRelease(v41);
      v41 = 0;
    }
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    if (v43[0])
    {
      CFRelease(v43[0]);
      v43[0] = 0;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v22);
    if (!ValueAtIndex)
    {
      AMFDRErrorPushInternal(v34, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("dataClassStr is NULL"), v33);
LABEL_72:
      v19 = 0;
      goto LABEL_73;
    }
    v25 = (uint64_t)ValueAtIndex;
    v19 = CFArrayGetValueAtIndex(a3, v22);
    if (!v19)
    {
      AMFDRErrorPushInternal(v34, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("dataInstanceStr is NULL"), v33);
LABEL_73:
      v20 = 0;
      v21 = v38;
      v16 = value;
      goto LABEL_56;
    }
    v26 = CFGetAllocator(a1);
    v27 = CFStringCreateWithFormat(v26, 0, CFSTR("%@-%@"), v25, v19);
    if (!v27)
    {
      AMFDRErrorPushInternal(v34, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("currDataInstance is NULL"), v33);
      goto LABEL_72;
    }
    v23 = v27;
    switch(a4)
    {
      case 0:
        v28 = AMFDRDataLocalCopy(a1, v25, (uint64_t)v19, (uint64_t)v43);
        goto LABEL_32;
      case 1:
        v28 = (uint64_t)AMFDRDataLocalPopulate(a1, v25, (uint64_t)v19, &v42, (uint64_t)v43);
        goto LABEL_32;
      case 2:
        v28 = (uint64_t)AMFDRDataLocalCopyDigest((const __CFData *)a1, v25, (uint64_t)v19, (uint64_t)v43);
LABEL_32:
        v20 = (void *)v28;
        if (v28)
          goto LABEL_33;
        goto LABEL_44;
      case 3:
        v29 = CFGetAllocator(a1);
        v30 = CFDictionaryCreateMutable(v29, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        if (v30)
        {
          v20 = v30;
          if (AMFDRDataLocalCopyManifest(a1, v25, (uint64_t)v19, (uint64_t *)&v41, (uint64_t *)&cf, (uint64_t)v43))
          {
            if (v41)
              CFDictionarySetValue((CFMutableDictionaryRef)v20, CFSTR("mandev"), v41);
            if (cf)
              CFDictionarySetValue((CFMutableDictionaryRef)v20, CFSTR("mansta"), cf);
          }
LABEL_33:
          if (v43[0])
          {
            AMFDRErrorPushInternal(v34, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("internalError is not NULL"), v33);
            goto LABEL_54;
          }
          CFDictionaryAddValue(theDict, v23, v20);
          if (v38 && v42 && CFDictionaryGetCount((CFDictionaryRef)v42) >= 1)
            CFDictionarySetValue(v38, v23, v42);
          goto LABEL_46;
        }
LABEL_44:
        AMFDRErrorPushInternal((uint64_t)v43, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("AMFDRDataLocalCopy failed"), v33);
        if (v43[0])
        {
          CFDictionaryAddValue(value, v23, v43[0]);
          v20 = 0;
LABEL_46:
          if (v12 == ++v22)
          {
            v16 = value;
            if (CFDictionaryGetCount(value) >= 1)
              AMFDRErrorPushInternal(v34, 21, 0, 0, 0, 0, 0, 0, value, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("Previous AMFDRDataLocalCopy got errors"), v33);
            v19 = CFRetain(theDict);
            v21 = v38;
            if (v35 && v38)
              *v35 = CFRetain(v38);
            goto LABEL_55;
          }
          continue;
        }
        AMFDRErrorPushInternal(v34, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("internalError is NULL"), v33);
LABEL_53:
        v20 = 0;
LABEL_54:
        v19 = 0;
        v21 = v38;
        v16 = value;
LABEL_55:
        CFRelease(v23);
LABEL_56:
        CFRelease(v16);
        CFRelease(theDict);
        if (v20)
          CFRelease(v20);
LABEL_58:
        if (v43[0])
        {
          CFRelease(v43[0]);
          v43[0] = 0;
        }
        if (v42)
        {
          CFRelease(v42);
          v42 = 0;
        }
        if (v21)
          CFRelease(v21);
        if (v41)
        {
          CFRelease(v41);
          v41 = 0;
        }
        if (cf)
          CFRelease(cf);
        return v19;
      default:
        AMFDRErrorPushInternal(v34, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiCopyInternal", CFSTR("Unsupported multi local action: %d"), a4);
        goto LABEL_53;
    }
  }
}

uint64_t AMFDRDataLocalCopyExtraManifest(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  char v9;
  uint64_t v10;
  char v12;
  char v13;

  v13 = 0;
  v8 = AMFDRDataLocalCopyExtraManifestPath(a1, a2, a3, a4, a6);
  v9 = v8;
  if (!v8)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyExtraManifest", CFSTR("manifestURL is NULL"), v12);
    goto LABEL_7;
  }
  v10 = 1;
  if (!MEMORY[0x212BA048C](v8, &v13) && v13 == 1)
  {
    CFGetAllocator(a1);
    AMSupportCreateDataFromFileURL();
    AMFDRErrorPushInternal(a6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalCopyExtraManifest", CFSTR("failed to read manifest: %@"), v9);
LABEL_7:
    v10 = 0;
  }
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v10;
}

uint64_t AMFDRDataLocalPutExtraManifest(_QWORD *a1, int a2, CFTypeRef cf, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeID v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  char v17;

  if (cf && (v12 = CFGetTypeID(cf), v12 == CFDataGetTypeID()))
  {
    v13 = AMFDRDataLocalCopyExtraManifestPath(a1, a2, a4, a5, a6);
    if (!v13)
    {
      AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPutExtraManifest", CFSTR("manifestURL is NULL"), v17);
      goto LABEL_9;
    }
    v14 = 1;
    v15 = AMFDRWriteDataToFileURL(a1, (uint64_t)cf, v13, 1);
    if (v15)
    {
      AMFDRErrorPushInternal(a6, v15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataLocalPutExtraManifest", CFSTR("failed to write manifest"), v17);
LABEL_9:
      v14 = 0;
    }
  }
  else
  {
    v14 = 1;
  }
  AMSupportSafeRelease();
  return v14;
}

CFTypeRef _AMFDRDataLocalPatchInternal(_QWORD *a1, const __CFString *a2, const void *a3, CFArrayRef *a4, const __CFData *a5, const __CFDictionary *a6, uint64_t a7)
{
  const __CFDictionary *v10;
  CFArrayRef *v11;
  const __CFAllocator *v14;
  const __CFData *UnsignedValueNoCopy;
  const __CFAllocator *v16;
  CFArrayRef *v17;
  const __CFData *EncodedData;
  const __CFString *v19;
  int v20;
  CFTypeRef v21;
  const __CFString *v23;
  const __CFString *v24;
  char v25;
  CFDataRef v26;

  v26 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalPatchInternal", CFSTR("amfdr is NULL"), v25);
    return 0;
  }
  if (!a2)
  {
    v23 = CFSTR("dataClassStr is NULL");
LABEL_33:
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalPatchInternal", v23, v25);
    a5 = 0;
LABEL_44:
    v10 = 0;
    goto LABEL_45;
  }
  if (!a3)
  {
    v23 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_33;
  }
  v10 = a6;
  if (!a6)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalPatchInternal", CFSTR("patchDict is NULL"), v25);
    a5 = 0;
LABEL_45:
    v21 = 0;
    goto LABEL_23;
  }
  v11 = a4;
  if (a4)
    a5 = (const __CFData *)a4;
  if (!a5)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalPatchInternal", CFSTR("valueData is NULL"), v25);
    goto LABEL_44;
  }
  v14 = CFGetAllocator(a1);
  UnsignedValueNoCopy = (const __CFData *)_AMFDRDataCreateUnsignedValueNoCopy(v14, a5, 0, a7);
  a5 = UnsignedValueNoCopy;
  if (!UnsignedValueNoCopy)
  {
    AMFDRErrorPushInternal(a7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalPatchInternal", CFSTR("failed to strip data for %@-%@"), (char)a2);
    goto LABEL_44;
  }
  if (!v11)
  {
    EncodedData = (const __CFData *)CFRetain(UnsignedValueNoCopy);
    goto LABEL_16;
  }
  v16 = CFGetAllocator(a1);
  v17 = (CFArrayRef *)AMFDRSysconfigCreateFromData(v16, a5, a7);
  if (!v17)
  {
    AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalPatchInternal", CFSTR("failed to decode original data"), v25);
    goto LABEL_44;
  }
  v11 = v17;
  if (!AMFDRSysconfigSetValues(v17, v10, a7))
  {
    v19 = CFSTR("failed to patch data");
    goto LABEL_47;
  }
  EncodedData = AMFDRSysconfigCreateEncodedData(v11, a7);
  if (!EncodedData)
  {
    v19 = CFSTR("failed to encode patched data");
LABEL_47:
    AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalPatchInternal", v19, v25);
    v10 = 0;
    v21 = 0;
    goto LABEL_22;
  }
LABEL_16:
  v10 = EncodedData;
  if (!AMFDRDataLocalSign((uint64_t)a1, a2, a3, EncodedData, 0, 0, 0, 0, &v26, a7) || !v26)
  {
    v24 = CFSTR("failed to sign data to put");
    goto LABEL_41;
  }
  if ((AMFDRDataLocalDeleteExtraManifest(a1, 0, (uint64_t)a2, (uint64_t)a3, a7) & 1) == 0)
  {
    v24 = CFSTR("failed to remove station manifest");
    goto LABEL_41;
  }
  if ((AMFDRDataLocalDeleteExtraManifest(a1, 1, (uint64_t)a2, (uint64_t)a3, a7) & 1) == 0)
  {
    v24 = CFSTR("failed to remove device manifest");
    goto LABEL_41;
  }
  if (!AMFDRDataLocalPutWithOptions(a1, (uint64_t)a2, (uint64_t)a3, (_BOOL8)v26, v20, a7))
  {
    v24 = CFSTR("failed to put patched data");
LABEL_41:
    AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalPatchInternal", v24, v25);
    v21 = 0;
    if (!v11)
      goto LABEL_23;
    goto LABEL_22;
  }
  v21 = CFRetain(v26);
  if (v11)
LABEL_22:
    CFRelease(v11);
LABEL_23:
  if (v26)
  {
    CFRelease(v26);
    v26 = 0;
  }
  if (v10)
    CFRelease(v10);
  if (a5)
    CFRelease(a5);
  return v21;
}

CFTypeRef _AMFDRDataLocalMultiPatchInternal(const void *a1, CFArrayRef theArray, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, const __CFArray *a6, uint64_t a7)
{
  const __CFArray *v8;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v12;
  const __CFAllocator *v13;
  const __CFAllocator *v14;
  CFIndex v15;
  CFStringRef v16;
  CFTypeRef v17;
  const __CFData *ValueAtIndex;
  const __CFDictionary *v19;
  const __CFString *v20;
  const void *v21;
  const void *v22;
  const __CFArray *v23;
  CFArrayRef *v24;
  const __CFAllocator *v25;
  CFStringRef v26;
  __CFDictionary *v27;
  CFStringRef v28;
  CFTypeRef v29;
  CFMutableDictionaryRef v30;
  CFTypeRef v31;
  CFTypeRef v32;
  const __CFString *format;
  const __CFString *v35;
  char v36;
  uint64_t v37;
  CFMutableDictionaryRef theDict;
  CFMutableDictionaryRef Mutable;
  _QWORD *cf;
  const __CFArray *theArraya;
  CFTypeRef v45;

  v45 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiPatchInternal", CFSTR("amfdr is NULL"), v36);
    return 0;
  }
  v8 = theArray;
  if (!theArray)
  {
    v35 = CFSTR("dataClassArray is NULL");
LABEL_65:
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiPatchInternal", v35, v36);
LABEL_66:
    v32 = 0;
    goto LABEL_43;
  }
  if (!a3)
  {
    v35 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_65;
  }
  if (!a6)
  {
    v35 = CFSTR("patchDictArray is NULL");
    goto LABEL_65;
  }
  v9 = a4;
  if (!a4)
    v9 = a5;
  theArraya = v9;
  if (!v9)
  {
    v35 = CFSTR("input data array is NULL");
    goto LABEL_65;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v35 = CFSTR("Invalid dataClassArray count");
    goto LABEL_65;
  }
  v12 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v35 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_65;
  }
  if (CFArrayGetCount(theArraya) != v12)
  {
    v35 = CFSTR("Invalid dataArray count");
    goto LABEL_65;
  }
  if (CFArrayGetCount(a6) != v12)
  {
    v35 = CFSTR("Invalid patchDictArray count");
    goto LABEL_65;
  }
  v13 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v13, v12, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiPatchInternal", CFSTR("valueDataDict is NULL"), v36);
    goto LABEL_66;
  }
  v14 = CFGetAllocator(a1);
  theDict = CFDictionaryCreateMutable(v14, v12, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiPatchInternal", CFSTR("errorDict is NULL"), v36);
    CFRelease(Mutable);
    goto LABEL_66;
  }
  cf = a1;
  v37 = a7;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(theArraya, v15);
    v19 = (const __CFDictionary *)CFArrayGetValueAtIndex(a6, v15);
    v20 = (const __CFString *)CFArrayGetValueAtIndex(v8, v15);
    v21 = CFArrayGetValueAtIndex(a3, v15);
    if (!ValueAtIndex)
    {
      format = CFSTR("inputData is NULL");
      goto LABEL_50;
    }
    if (!v19)
    {
      format = CFSTR("patchDict is NULL");
      goto LABEL_50;
    }
    if (!v20)
    {
      format = CFSTR("dataClassStr is NULL");
      goto LABEL_50;
    }
    v22 = v21;
    if (!v21)
    {
      format = CFSTR("dataInstanceStr is NULL");
LABEL_50:
      AMFDRErrorPushInternal(v37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiPatchInternal", format, v36);
      v31 = 0;
      v32 = 0;
      v30 = theDict;
      if (!v16)
        goto LABEL_41;
LABEL_40:
      CFRelease(v16);
      v32 = v31;
      goto LABEL_41;
    }
    v23 = v8;
    if (a4)
      v24 = (CFArrayRef *)ValueAtIndex;
    else
      v24 = 0;
    if (a4)
      ValueAtIndex = 0;
    if (v16)
      CFRelease(v16);
    if (v17)
      CFRelease(v17);
    if (v45)
    {
      CFRelease(v45);
      v45 = 0;
    }
    v25 = CFGetAllocator(cf);
    v26 = CFStringCreateWithFormat(v25, 0, CFSTR("%@-%@"), v20, v22);
    if (!v26)
      break;
    v16 = v26;
    v17 = _AMFDRDataLocalPatchInternal(cf, v20, v22, v24, ValueAtIndex, v19, (uint64_t)&v45);
    if (!v17)
    {
      AMFDRErrorPushInternal((uint64_t)&v45, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiPatchInternal", CFSTR("_AMFDRDataLocalPatchInternal failed"), v36);
      v29 = v45;
      if (v45)
      {
        v8 = v23;
        v27 = theDict;
        v28 = v16;
        goto LABEL_36;
      }
      AMFDRErrorPushInternal(v37, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiPatchInternal", CFSTR("internalError is NULL"), v36);
      v17 = 0;
      goto LABEL_55;
    }
    if (v45)
    {
      AMFDRErrorPushInternal(v37, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiPatchInternal", CFSTR("internalError is not NULL"), v36);
LABEL_55:
      v31 = 0;
      v30 = theDict;
      goto LABEL_40;
    }
    v8 = v23;
    v27 = Mutable;
    v28 = v16;
    v29 = v17;
LABEL_36:
    CFDictionaryAddValue(v27, v28, v29);
    if (v12 == ++v15)
    {
      v30 = theDict;
      if (CFDictionaryGetCount(theDict) >= 1)
        AMFDRErrorPushInternal(v37, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiPatchInternal", CFSTR("Previous AMFDRDataLocalPatch got errors"), v36);
      v31 = CFRetain(Mutable);
      goto LABEL_40;
    }
  }
  AMFDRErrorPushInternal(v37, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataLocalMultiPatchInternal", CFSTR("currDataInstance is NULL"), v36);
  v17 = 0;
  v32 = 0;
  v30 = theDict;
LABEL_41:
  CFRelease(v30);
  CFRelease(Mutable);
  if (v17)
    CFRelease(v17);
LABEL_43:
  if (v45)
    CFRelease(v45);
  return v32;
}

uint64_t _AMFDRDecodeComputeDigest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  _QWORD *v8;

  result = 6;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a5)
        {
          v8 = *(_QWORD **)(a5 + 32);
          if (v8)
          {
            if (*v8 == a4)
            {
              if (DEROidCompare(v8[1], (uint64_t)&oidSha1))
              {
                if (!AMSupportDigestSha1())
                  return 0;
              }
              else if (DEROidCompare(*(_QWORD *)(*(_QWORD *)(a5 + 32) + 8), (uint64_t)&oidSha256))
              {
                if (!AMSupportDigestSha256())
                  return 0;
              }
              else
              {
                if (!DEROidCompare(*(_QWORD *)(*(_QWORD *)(a5 + 32) + 8), (uint64_t)&oidSha384))
                  return 4;
                if (!AMSupportDigestSha384())
                  return 0;
              }
              return 3;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t _AMFDRDecodeVerifyChain(uint64_t a1, uint64_t a2, DERByte **a3, DERSize *a4, DERByte **a5, DERSize *a6, uint64_t a7, uint64_t a8)
{
  DERItem v8;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  DERSize *v29;
  int i;
  int v31;
  uint64_t length;
  unsigned int v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  DERItem *v37;
  uint64_t v38;
  int v39;
  DERItem *v40;
  uint64_t v41;
  uint64_t v42;
  DERItem v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  DERItem v47;
  _OWORD v48[4];
  DERItem *v49;
  _OWORD v50[19];
  DERItem v51;
  DERItem v52;
  DERItem v53;
  DERItem v54;
  DERItem v55;
  DERItem v56;
  DERItem v57;
  DERItem v58;
  DERItem v59;
  DERItem v60;
  DERItem v61;
  DERItem v62;
  DERItem v63;
  DERItem v64;
  DERItem v65;
  DERItem v66;
  DERItem v67;
  DERItem v68;
  DERItem v69;
  _QWORD v70[3];
  int v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;

  v71 = 0;
  memset(v70, 170, sizeof(v70));
  v8.data = (DERByte *)0xAAAAAAAAAAAAAAAALL;
  v8.length = 0xAAAAAAAAAAAAAAAALL;
  v68 = v8;
  v69 = v8;
  v66 = v8;
  v67 = v8;
  v64 = v8;
  v65 = v8;
  v62 = v8;
  v63 = v8;
  v60 = v8;
  v61 = v8;
  v58 = v8;
  v59 = v8;
  v56 = v8;
  v57 = v8;
  v54 = v8;
  v55 = v8;
  v52 = v8;
  v53 = v8;
  v50[18] = v8;
  v51 = v8;
  v50[16] = v8;
  v50[17] = v8;
  v50[14] = v8;
  v50[15] = v8;
  v50[12] = v8;
  v50[13] = v8;
  v50[10] = v8;
  v50[11] = v8;
  v50[8] = v8;
  v50[9] = v8;
  v50[6] = v8;
  v50[7] = v8;
  v50[4] = v8;
  v50[5] = v8;
  v50[2] = v8;
  v50[3] = v8;
  v50[0] = v8;
  v50[1] = v8;
  v49 = (DERItem *)v50;
  if (a8)
  {
    if (a1 && a2 && a5 && a6)
    {
      if (!(_DWORD)a2)
      {
        v18 = 3;
        AMSupportLogInternal();
        v20 = *(_QWORD *)a8 | 1;
        goto LABEL_54;
      }
      v70[1] = a2;
      v70[2] = 0;
      v70[0] = a1;
      AMFDRDecodeIterateCertChainNextWithOptions((uint64_t)v70, *(_QWORD *)(a8 + 2016), (_OWORD **)&v49, &v71);
      v15 = v14;
      if (v14 || !v49)
      {
        v18 = 3;
        AMSupportLogInternal();
        v20 = *(_QWORD *)a8 | v15;
LABEL_54:
        *(_QWORD *)a8 = v20;
        return v18;
      }
      if (!*(_QWORD *)(a8 + 1944) || !*(_QWORD *)(a8 + 1952))
      {
        AMSupportLogInternal();
        *(_QWORD *)a8 |= 0x200100uLL;
LABEL_51:
        v37 = v49;
        v49 = &v51;
        AMFDRDecodeIterateCertChainNextWithOptions((uint64_t)v70, *(_QWORD *)(a8 + 2016), (_OWORD **)&v49, &v71);
        if (v38)
        {
          v17 = v38;
          goto LABEL_53;
        }
        v39 = 1;
        while (1)
        {
          if (!v49)
          {
            *a3 = v37[13].data;
            *a4 = v37[13].length;
            *a5 = v37[18].data;
            *a6 = v37[18].length;
            v43 = v37[15];
            *(DERItem *)(a8 + 312) = v37[14];
            *(DERItem *)(a8 + 328) = v43;
            AMSupportLogInternal();
            return 0;
          }
          AMSupportLogInternal();
          if (AMFDRDecodeVerifyCertIssuerWithOptions((uint64_t)v49, (uint64_t)v37, a8 + 1768, *(_QWORD *)(a8 + 2016), (_QWORD *)a8))
          {
            break;
          }
          AMSupportLogInternal();
          ++v39;
          v40 = v49;
          v49 = v37;
          AMFDRDecodeIterateCertChainNextWithOptions((uint64_t)v70, *(_QWORD *)(a8 + 2016), (_OWORD **)&v49, &v71);
          v37 = v40;
          if (v41)
          {
            v42 = v41;
            v18 = 3;
            AMSupportLogInternal();
            v20 = *(_QWORD *)a8 | v42;
            goto LABEL_54;
          }
        }
        AMSupportLogInternal();
        v44 = *(_QWORD *)a8 | 0x40000000000;
        goto LABEL_62;
      }
      if ((*(_BYTE *)(a8 + 2017) & 1) == 0)
      {
        v16 = AMFDRDecodeIterateTrustObjectTrustedBegin(a8 + 1768);
        if (v16)
        {
          v17 = v16;
LABEL_53:
          v18 = 3;
          AMSupportLogInternal();
          v20 = *(_QWORD *)a8 | v17;
          goto LABEL_54;
        }
        v29 = a4;
        for (i = 0; ; ++i)
        {
          v47 = (DERItem)0;
          *(_QWORD *)&v48[0] = 0;
          v31 = DERDecodeSeqNext((unint64_t *)(a8 + 1832), (unint64_t *)&v47);
          if (v31)
            break;
          length = v47.length;
          v33 = v48[0];
          if (v47.length)
            v34 = LODWORD(v48[0]) == 0;
          else
            v34 = 1;
          if (v34)
            goto LABEL_49;
          AMSupportLogInternal();
          v35 = AMFDRDecodeCertificate((unint64_t)&v51, length, v33);
          if (v35)
          {
            v46 = v35;
            AMSupportLogInternal();
            v44 = *(_QWORD *)a8 | v46;
            goto LABEL_62;
          }
          v36 = AMFDRDecodeVerifyCertIssuerWithOptions((uint64_t)v49, (uint64_t)&v51, a8 + 1768, 0, 0);
          if (v36 != 0x20000000000)
          {
            v45 = v36;
            if (!v36)
            {
              AMSupportLogInternal();
              goto LABEL_50;
            }
            AMSupportLogInternal();
            v44 = *(_QWORD *)a8 | v45;
            goto LABEL_62;
          }
        }
        if (v31 == 1)
        {
LABEL_49:
          AMSupportLogInternal();
          *(_QWORD *)a8 |= 0x100uLL;
LABEL_50:
          a4 = v29;
          goto LABEL_51;
        }
        AMSupportLogInternal();
        v44 = *(_QWORD *)a8 | 0x400000;
LABEL_62:
        *(_QWORD *)a8 = v44;
        return 3;
      }
      memset(v48, 0, sizeof(v48));
      v47 = (DERItem)0;
      v21 = AMFDRDecodeIterateTrustObjectTrustedKeyBegin(a8 + 1768);
      if (v21 == 0x40000000000000)
      {
        AMSupportLogInternal();
      }
      else if (v21)
      {
        *(_QWORD *)a8 |= v21;
LABEL_72:
        AMSupportLogInternal();
        return 3;
      }
      v22 = 0;
LABEL_24:
      while (1)
      {
        v72 = 0;
        v73 = 0;
        v74 = 0;
        v23 = DERDecodeSeqNext((unint64_t *)(a8 + 1896), &v72);
        if (v23)
          break;
        v24 = v73;
        v25 = v74;
        if (v73)
          v26 = (_DWORD)v74 == 0;
        else
          v26 = 1;
        if (v26)
          goto LABEL_38;
        AMSupportLogInternal();
        v27 = AMFDRDecodePublicKey((uint64_t)&v47, v24, v25);
        if (v27)
        {
          AMSupportLogInternal();
          v44 = *(_QWORD *)a8 | v27;
          goto LABEL_62;
        }
        while (!DEROidCompare((uint64_t)&v49[1], (*(_QWORD **)((char *)&kAMFDRDecodeEcdsaInfoList + v27))[3])
             || !DEROidCompare((uint64_t)v48, (*(_QWORD **)((char *)&kAMFDRDecodeEcdsaInfoList + v27))[2]))
        {
          v27 += 8;
          if (v27 == 24)
          {
            ++v22;
            goto LABEL_24;
          }
        }
        v68 = (DERItem)0;
        v69 = (DERItem)0;
        v67 = (DERItem)0;
        v62 = (DERItem)0;
        v63 = (DERItem)0;
        v60 = (DERItem)0;
        v61 = (DERItem)0;
        v58 = (DERItem)0;
        v59 = (DERItem)0;
        v56 = (DERItem)0;
        v57 = (DERItem)0;
        v54 = (DERItem)0;
        v55 = (DERItem)0;
        v52 = (DERItem)0;
        v53 = (DERItem)0;
        v51 = (DERItem)0;
        v64 = v47;
        v65 = oidEcPubKey;
        v66 = (DERItem)v48[0];
        v28 = AMFDRDecodeVerifyCertIssuerWithOptions((uint64_t)v49, (uint64_t)&v51, a8 + 1768, *(_QWORD *)(a8 + 2016), (_QWORD *)a8);
        if (v28 != 0x20000000000)
        {
          if (!v28)
          {
            AMSupportLogInternal();
            goto LABEL_51;
          }
          goto LABEL_71;
        }
      }
      if (v23 == 1)
      {
LABEL_38:
        AMSupportLogInternal();
        *(_QWORD *)a8 |= 0x100uLL;
        goto LABEL_51;
      }
      v28 = 0x400000;
LABEL_71:
      *(_QWORD *)a8 |= v28;
      goto LABEL_72;
    }
    AMSupportLogInternal();
    *(_QWORD *)a8 |= 1uLL;
  }
  else
  {
    AMSupportLogInternal();
  }
  return 6;
}

uint64_t _AMFDRDecodeVerifySignature(const void *a1, size_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  DERItem v15;

  if (!a1 || !a2 || !a3 || !a4 || !a5 || !a6 || !a7 || !*(_QWORD *)(a7 + 40) || **(_QWORD **)(a7 + 32) != a6)
    goto LABEL_13;
  if (!DEROidCompare(a8 + 312, (uint64_t)&oidEcPubKey))
  {
    if (DEROidCompare(*(_QWORD *)(a7 + 40), (uint64_t)&oidSha1Rsa))
    {
      if (!DEROidCompare(a8 + 312, (uint64_t)&oidRsa))
        goto LABEL_40;
      result = AMSupportRsaVerifySignatureSha1();
    }
    else if (DEROidCompare(*(_QWORD *)(a7 + 40), (uint64_t)&oidSha256Rsa))
    {
      if (!DEROidCompare(a8 + 312, (uint64_t)&oidRsa))
        goto LABEL_40;
      result = AMSupportRsaVerifySignatureSha256();
    }
    else
    {
      if (!DEROidCompare(*(_QWORD *)(a7 + 40), (uint64_t)&oidSha384Rsa))
      {
        result = 4;
LABEL_14:
        if (!a8)
          return result;
        goto LABEL_15;
      }
      if (!DEROidCompare(a8 + 312, (uint64_t)&oidRsa))
        goto LABEL_40;
      result = AMSupportRsaVerifySignatureSha384();
    }
    if ((_DWORD)result == 2)
    {
      *(_QWORD *)a8 |= 0x80000000000000uLL;
      result = 3;
LABEL_15:
      *(_QWORD *)a8 |= 0x1000000000000uLL;
      return result;
    }
    goto LABEL_41;
  }
  if ((uint64_t (**)())a7 != kAMFDRDecodeImplementationSha384
    && (uint64_t (**)())a7 != kAMFDRDecodeImplementationOffline)
  {
LABEL_13:
    AMSupportLogInternal();
    result = 6;
    goto LABEL_14;
  }
  v15 = oidEcPrime256v1;
  if ((*(_BYTE *)(a8 + 2017) & 1) == 0)
  {
    if (!AMSupportDigestSha256())
      goto LABEL_38;
LABEL_40:
    result = 3;
    goto LABEL_14;
  }
  if (!*(_QWORD *)(a8 + 336))
    goto LABEL_13;
  v13 = 0;
  v15 = *(DERItem *)(a8 + 328);
  while (!DEROidCompare((uint64_t)&v15, (*(_QWORD **)((char *)&kAMFDRDecodeEcdsaInfoList + v13))[2]))
  {
    v13 += 8;
    if (v13 == 24)
      goto LABEL_13;
  }
  v14 = *(uint64_t *)((char *)&kAMFDRDecodeEcdsaInfoList + v13);
  if (!*(_DWORD *)(v14 + 8))
    goto LABEL_13;
  if (AMFDRDecodeDigestByLength(*(_QWORD *)(a8 + 664), *(_QWORD *)(a8 + 672), a8 + 776, *(unsigned int *)(v14 + 8)))goto LABEL_40;
LABEL_38:
  result = AMFDRDecodeEcdsaVerifySignature(a1, a2);
  if ((_DWORD)result == 2)
  {
    *(_QWORD *)a8 |= 0x80000000000000uLL;
    goto LABEL_40;
  }
LABEL_41:
  if ((_DWORD)result)
    goto LABEL_40;
  return result;
}

uint64_t _AMFDRDecodeEvaluateCertificateProperties(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v15;
  __int128 v16;
  unint64_t v17[3];
  unint64_t v18[3];
  unint64_t v19;
  unint64_t v20[5];

  memset(v20, 170, 32);
  memset(v18, 170, sizeof(v18));
  memset(v17, 170, sizeof(v17));
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16 = v3;
  v4 = 6;
  if (!a1 || !a2)
  {
LABEL_30:
    if (!a2)
      return v4;
    goto LABEL_31;
  }
  if (!*(_QWORD *)(a1 + 320) || (v6 = a1 + 312, !*(_QWORD *)(a1 + 312)))
  {
    v4 = 0;
    v13 = 0x200000000000;
LABEL_20:
    *(_QWORD *)a2 |= v13;
    return v4;
  }
  v19 = 0xAAAAAAAAAAAAAAAALL;
  v7 = DERDecodeSeqInit(v6, &v19, &v20[2]);
  if ((_DWORD)v7)
  {
    v4 = v7;
    AMSupportLogInternal();
LABEL_31:
    v13 = 0x800000000000;
    goto LABEL_20;
  }
  if (v19 != 0x2000000000000011)
  {
    v4 = 2;
    goto LABEL_31;
  }
  v8 = 0;
  do
  {
    v9 = DERDecodeSeqNext(&v20[2], v18);
    if (v9)
    {
      if (v9 == 1 && v8)
        return 0;
      goto LABEL_26;
    }
    ++v8;
    if (v18[0] == 0xE00000004D414E50)
      break;
    if (v18[0] != 0xE00000004F424A50)
      goto LABEL_28;
  }
  while ((*(_BYTE *)(a2 + 2016) & 0x80) != 0);
  v10 = DERImg4DecodeProperty();
  if ((_DWORD)v10)
  {
    v4 = v10;
  }
  else
  {
    if (*((_QWORD *)&v16 + 1) != 0x2000000000000011)
      goto LABEL_29;
    v11 = DERDecodeSeqContentInit((unint64_t *)&v15 + 1, v20);
    if (!(_DWORD)v11)
    {
      if (!DERDecodeSeqNext(v20, v17))
      {
        v12 = DERImg4DecodeProperty();
        if (!(_DWORD)v12)
        {
          DERImg4DecodeContentFindItemWithTag();
LABEL_28:
          AMSupportLogInternal();
LABEL_29:
          v4 = 2;
          goto LABEL_30;
        }
        v4 = v12;
        goto LABEL_39;
      }
LABEL_26:
      AMSupportLogInternal();
      v4 = 0xFFFFFFFFLL;
      if (a2)
        goto LABEL_31;
      return v4;
    }
    v4 = (uint64_t)v11;
  }
LABEL_39:
  AMSupportLogInternal();
  if (a2)
    goto LABEL_31;
  return v4;
}

uint64_t _AMFDRDecodeVerifyChainOffline(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _OWORD v17[13];
  void *__s1[2];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  unint64_t v24[3];
  _QWORD v25[2];

  memset(v24, 170, sizeof(v24));
  if (a8)
  {
    *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v22 = v11;
    v23 = v11;
    v20 = v11;
    v21 = v11;
    *(_OWORD *)__s1 = v11;
    v19 = v11;
    v17[11] = v11;
    v17[12] = v11;
    v17[9] = v11;
    v17[10] = v11;
    v17[7] = v11;
    v17[8] = v11;
    v17[5] = v11;
    v17[6] = v11;
    v17[3] = v11;
    v17[4] = v11;
    v17[1] = v11;
    v17[2] = v11;
    v17[0] = v11;
    v25[0] = a1;
    v25[1] = a2;
    if (!DERDecodeItem((uint64_t)v25, v24))
    {
      if (v24[0] != 2)
      {
        v12 = 3;
        AMSupportLogInternal();
        v13 = *(_QWORD *)a8 | 0x40;
        goto LABEL_12;
      }
      if (!AMFDRDecodeCertificate((unint64_t)v17, *(_QWORD *)(a8 + 296), *(_DWORD *)(a8 + 304)))
      {
        *(_QWORD *)a8 |= 0x100uLL;
        v14 = v24[2];
        if ((void *)v24[2] == __s1[1])
        {
          v15 = v24[1];
          if (!memcmp(__s1[0], (const void *)v24[1], v24[2]))
          {
            v12 = 0;
            *a3 = v15;
            *a4 = v14;
            *(DERItem *)(a8 + 312) = oidEcPubKey;
            return v12;
          }
        }
        v12 = 3;
        AMSupportLogInternal();
        v13 = *(_QWORD *)a8 | 0x20000000000000;
        goto LABEL_12;
      }
    }
    v12 = 3;
    AMSupportLogInternal();
    v13 = *(_QWORD *)a8 | 0x40000000000;
LABEL_12:
    *(_QWORD *)a8 = v13;
    return v12;
  }
  AMSupportLogInternal();
  return 6;
}

uint64_t _AMFDRDecodeEvaluateTestStationCertificateProperties()
{
  return 0;
}

uint64_t _AMFDRDecodeVerifyDataCallback(int a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t PropertyData;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  const void *v22;
  unsigned int *v23;
  int v24;
  void *v25;
  size_t v26;
  void *__s1;
  size_t __n;
  void *__s2;
  unsigned int v31;

  v31 = 0;
  __s2 = 0;
  if (!a4)
  {
    AMSupportLogInternal();
    return 6;
  }
  if (!a2)
  {
    AMSupportLogInternal();
    *(_QWORD *)a4 |= 1uLL;
    return 6;
  }
  if (a1 <= 1634953571)
  {
    if (a1 > 1400000108)
    {
      if (a1 == 1400000109)
        return 0;
      if (a1 == 1400010324)
      {
        PropertyData = Img4DecodeGetPropertyData();
        if (!(_DWORD)PropertyData)
        {
          AMSupportLogInternal();
          v6 = 0;
          v20 = *(_QWORD *)a4 | 0x200;
          goto LABEL_85;
        }
        v6 = PropertyData;
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    if (a1 == 1145525076)
    {
      if ((*(_BYTE *)(a4 + 2017) & 0x10) != 0)
        goto LABEL_47;
      v11 = Img4DecodeGetPropertyData();
      if ((_DWORD)v11)
      {
        v6 = v11;
      }
      else
      {
        if (*(_BYTE *)(a4 + 400)
          && **(_QWORD **)(*(_QWORD *)(a4 + 2008) + 32) == v31
          && !memcmp(__s2, (const void *)(a4 + 584), v31))
        {
          return 0;
        }
        v6 = 3;
      }
    }
    else
    {
      if (a1 != 1396917319)
      {
LABEL_36:
        v13 = 1;
        while (v13 != 48)
        {
          v14 = kFDRKnownTag[v13++];
          if (v14 == a1)
          {
            if ((unint64_t)(v13 - 2) < 0x2F)
              return 0;
            goto LABEL_47;
          }
        }
        goto LABEL_47;
      }
      v7 = Img4DecodeGetPropertyData();
      if (!(_DWORD)v7)
      {
        v19 = v31;
        *(_QWORD *)(a4 + 360) = __s2;
        *(_QWORD *)(a4 + 368) = v19;
        if ((*(_BYTE *)(a4 + 2017) & 0x10) != 0)
        {
          if (*(_QWORD *)(a4 + 128))
          {
            v23 = *(unsigned int **)(a4 + 120);
            if (v23)
            {
              __s1 = 0;
              __n = 0;
              v24 = AMFDRTagsStringToTag(v23);
              if (_AMFDRDecodeSearchEntryFromPropertyList(*(_QWORD *)(a4 + 360), *(_QWORD *)(a4 + 368), v24, &__s1))
              {
                v6 = 0;
              }
              else if (*(_BYTE *)(a4 + 400))
              {
                if (__n == **(_QWORD **)(*(_QWORD *)(a4 + 2008) + 32))
                {
                  if (!memcmp(__s1, (const void *)(a4 + 584), __n))
                  {
                    AMSupportLogInternal();
                    v6 = 0;
                    *(_BYTE *)(a4 + 376) = 1;
                    return v6;
                  }
                  v6 = 3;
                }
                else
                {
                  v6 = 3;
                }
              }
              else
              {
                v6 = 3;
              }
              AMSupportLogInternal();
              v20 = *(_QWORD *)a4 | 0x1000000000000000;
              goto LABEL_85;
            }
          }
          *(_QWORD *)a4 |= 0x1000000000000000uLL;
        }
        goto LABEL_47;
      }
      v6 = v7;
    }
    AMSupportLogInternal();
    v20 = *(_QWORD *)a4 | 0x8000;
    goto LABEL_85;
  }
  if (a1 <= 1717660002)
  {
    if (a1 == 1634953572)
    {
      v12 = Img4DecodeGetPropertyData();
      if ((_DWORD)v12)
      {
        v6 = v12;
        goto LABEL_35;
      }
      v21 = *(_QWORD *)(a4 + 224);
      if (v21)
      {
        if (v21 != v31 || (v22 = *(const void **)(a4 + 216)) == 0 || memcmp(v22, __s2, v21))
        {
          v6 = 3;
          AMSupportLogInternal();
          v20 = *(_QWORD *)a4 | 0x200000000000000;
          goto LABEL_85;
        }
        return 0;
      }
      goto LABEL_47;
    }
    if (a1 != 1668047219)
      goto LABEL_36;
    Img4DecodeGetPropertyData();
    v6 = 3;
    AMSupportLogInternal();
    v20 = *(_QWORD *)a4 | 0x400;
LABEL_85:
    *(_QWORD *)a4 = v20;
    return v6;
  }
  if (a1 == 1717660003)
  {
    LOBYTE(__s1) = 0;
    if (!Img4DecodeGetPropertyBoolean())
    {
      v6 = 0;
      *(_BYTE *)(a4 + 2004) = (_BYTE)__s1;
      return v6;
    }
    v6 = 3;
    AMSupportLogInternal();
    v20 = *(_QWORD *)a4 | 0x400000000;
    goto LABEL_85;
  }
  if (a1 != 1768846196)
  {
    if (a1 == 1886546276)
    {
      v5 = Img4DecodeGetPropertyData();
      if ((_DWORD)v5)
      {
        v6 = v5;
LABEL_35:
        AMSupportLogInternal();
        v20 = *(_QWORD *)a4 | 0x2000;
        goto LABEL_85;
      }
      v15 = __s2;
      v16 = v31;
      *(_QWORD *)(a4 + 200) = __s2;
      *(_QWORD *)(a4 + 208) = v16;
      if (!*(_QWORD *)(a4 + 1944) || !*(_QWORD *)(a4 + 1952))
      {
        AMSupportLogInternal();
        v6 = 0;
        v20 = *(_QWORD *)a4 | 0x200000;
        goto LABEL_85;
      }
      v17 = AMFDRDecodeCheckProducerIDRevocation(a4 + 1768, (uint64_t)v15, v16);
      if (v17)
      {
        v18 = v17;
        v6 = 3;
        AMSupportLogInternal();
        v20 = *(_QWORD *)a4 | v18;
        goto LABEL_85;
      }
      return 0;
    }
    goto LABEL_36;
  }
  v10 = Img4DecodeGetPropertyData();
  if ((_DWORD)v10)
  {
    v6 = v10;
    AMSupportLogInternal();
LABEL_29:
    v20 = *(_QWORD *)a4 | 0x4000;
    goto LABEL_85;
  }
  if (a3 == 1)
  {
    v25 = *(void **)(a4 + 104);
    if (v25)
    {
      v26 = *(_QWORD *)(a4 + 112);
      if (v26)
      {
        if ((_AMFDRDecodeInstPropertyMatchingWithType(__s2, v31, v25, v26, *(const void **)(a4 + 184), *(_QWORD *)(a4 + 192), 1, (_QWORD *)a4) & 1) != 0)return 0;
        goto LABEL_77;
      }
    }
    if ((*(_BYTE *)(a4 + 2017) & 0x20) == 0)
    {
LABEL_77:
      AMSupportLogInternal();
      v6 = 0;
      goto LABEL_29;
    }
LABEL_47:
    AMSupportLogInternal();
    return 0;
  }
  if (a3)
    return 0;
  v6 = 0;
  if ((_AMFDRDecodeInstPropertyMatchingWithType(__s2, v31, *(void **)(a4 + 136), *(_QWORD *)(a4 + 144), *(const void **)(a4 + 168), *(_QWORD *)(a4 + 176), 0, (_QWORD *)a4) & 1) == 0)
  {
    AMSupportLogInternal();
    v6 = 0;
    v20 = *(_QWORD *)a4 | 0x40000000;
    goto LABEL_85;
  }
  return v6;
}

uint64_t _AMFDRDecodeGetExpectedManifestHash(uint64_t a1, uint64_t a2)
{
  if (a2)
    return *(_QWORD *)(a2 + 2024);
  AMSupportLogInternal();
  return 0;
}

uint64_t _AMFDRDecodePropertiesFilterCallback(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  unint64_t *v6;
  uint64_t PropertyInSequence;
  uint64_t v8;
  char v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v14[2];
  unint64_t *v15;
  unint64_t v16;

  v15 = (unint64_t *)a5;
  v16 = 0xAAAAAAAAAAAA0000;
  v14[0] = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = 0xAAAAAAAAAAAAAAAALL;
  if (!a5)
    goto LABEL_22;
  if (!*(_QWORD *)(a5 + 104) || !*(_QWORD *)(a5 + 112))
  {
    if ((*(_BYTE *)(a5 + 2017) & 0x20) != 0)
    {
      v5 = 1;
      goto LABEL_7;
    }
LABEL_22:
    AMSupportLogInternal();
    return 6;
  }
  v5 = 0;
LABEL_7:
  v6 = DERDecodeSeqContentInit(a1, v14);
  if (!(_DWORD)v6)
  {
    while (1)
    {
      if ((_BYTE)v16)
        goto LABEL_24;
      PropertyInSequence = DERImg4DecodeFindPropertyInSequence();
      if ((_DWORD)PropertyInSequence == 1)
        break;
      v8 = PropertyInSequence;
      if ((_DWORD)PropertyInSequence)
        goto LABEL_32;
      if (BYTE1(v16))
        v9 = v5;
      else
        v9 = 0;
      if ((v9 & 1) != 0)
      {
        AMSupportLogInternal();
        if ((_BYTE)v16)
          return 0;
        v8 = 0;
        v11 = v15;
        v12 = *v15 | 0x4000;
LABEL_26:
        *v11 = v12;
        return v8;
      }
      v10 = Img4DecodeEvaluateDictionaryProperties();
      if ((_DWORD)v10)
      {
        v8 = v10;
        goto LABEL_32;
      }
    }
    if (BYTE1(v16))
      AMSupportLogInternal();
    if ((_BYTE)v16)
    {
      if (!v5)
        return 0;
    }
    else
    {
      *v15 |= 0x4000uLL;
LABEL_24:
      if ((v5 & 1) == 0)
        return 0;
    }
    AMSupportLogInternal();
    v8 = 0;
    v11 = v15;
    v12 = *v15 & 0xFFFFFFFFFFFFBFFFLL;
    goto LABEL_26;
  }
  v8 = (uint64_t)v6;
LABEL_32:
  AMSupportLogInternal();
  return v8;
}

uint64_t AMFDRDecodeTrustObject(_QWORD *a1, uint64_t a2, unsigned int a3)
{
  _QWORD v5[2];

  v5[0] = a2;
  v5[1] = a3;
  if (!DERParseSequenceToObject((uint64_t)v5, 5u, (uint64_t)&DERFDRTrustObjectItemSpecs, (unint64_t)a1, 0x90uLL, 0)&& *a1&& a1[1] == 4&& *(_DWORD *)*a1 == *(_DWORD *)"secb")
  {
    return 0;
  }
  AMSupportLogInternal();
  return 0x400000;
}

uint64_t AMFDRDecodeIterateTrustObjectTrustedBegin(uint64_t a1)
{
  unint64_t *v1;
  unint64_t v3;
  _DWORD *v4;
  uint64_t v5;

  if (!a1)
    return 1;
  v3 = 0;
  v4 = 0;
  v1 = (unint64_t *)(a1 + 64);
  v5 = 0;
  if (!DERDecodeSeqContentInit((unint64_t *)(a1 + 16), (unint64_t *)(a1 + 64))
    && !DERDecodeSeqNext(v1, &v3)
    && v4
    && v5 == 4
    && *v4 == *(_DWORD *)"trst")
  {
    return 0;
  }
  AMSupportLogInternal();
  return 0x400000;
}

uint64_t AMFDRDecodeIterateTrustObjectTrustedKeyBegin(uint64_t a1)
{
  unint64_t *v1;
  int v3;
  unint64_t v4;
  _DWORD *v5;
  uint64_t v6;

  if (!a1)
    return 1;
  v4 = 0;
  v5 = 0;
  v1 = (unint64_t *)(a1 + 128);
  v6 = 0;
  if (DERDecodeSeqContentInit((unint64_t *)(a1 + 112), (unint64_t *)(a1 + 128)))
  {
LABEL_3:
    AMSupportLogInternal();
    return 0x400000;
  }
  v3 = DERDecodeSeqNext(v1, &v4);
  if (v3)
  {
    if (v3 != 1)
      goto LABEL_3;
    return 0x40000000000000;
  }
  else
  {
    if (!v5 || v6 != 4 || *v5 != *(_DWORD *)"trpk")
      goto LABEL_3;
    return 0;
  }
}

uint64_t AMFDRDecodeIterateTrustObjectRevokedBegin(uint64_t a1)
{
  unint64_t *v1;
  unint64_t v3;
  _DWORD *v4;
  uint64_t v5;

  if (!a1)
    return 1;
  v3 = 0;
  v4 = 0;
  v1 = (unint64_t *)(a1 + 80);
  v5 = 0;
  if (!DERDecodeSeqContentInit((unint64_t *)(a1 + 48), (unint64_t *)(a1 + 80))
    && !DERDecodeSeqNext(v1, &v3)
    && v4
    && v5 == 4
    && *v4 == *(_DWORD *)"rvok")
  {
    return 0;
  }
  AMSupportLogInternal();
  return 0x400000;
}

uint64_t AMFDRDecodeIterateTrustObjectRevokedNext(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t result;
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  result = 1;
  if (a1 && a2 && a3)
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v7 = DERDecodeSeqNext((unint64_t *)(a1 + 80), &v10);
    if (v7)
    {
      if (v7 == 1)
      {
        v8 = 0;
        v9 = 0;
        goto LABEL_9;
      }
    }
    else
    {
      v8 = v12;
      if (v12 == 32)
      {
        v9 = v11;
LABEL_9:
        result = 0;
        *a2 = v9;
        *a3 = v8;
        return result;
      }
    }
    return 0x400000;
  }
  return result;
}

uint64_t AMFDRDecodeIterateTrustObjectSslRootBegin(uint64_t a1)
{
  unint64_t *v1;
  unint64_t v3;
  _DWORD *v4;
  uint64_t v5;

  if (!a1)
    return 1;
  v3 = 0;
  v4 = 0;
  v1 = (unint64_t *)(a1 + 96);
  v5 = 0;
  if (!DERDecodeSeqContentInit((unint64_t *)(a1 + 32), (unint64_t *)(a1 + 96))
    && !DERDecodeSeqNext(v1, &v3)
    && v4
    && v5 == 4
    && *v4 == *(_DWORD *)"rssl")
  {
    return 0;
  }
  AMSupportLogInternal();
  return 0x400000;
}

uint64_t AMFDRDecodeIterateTrustObjectSslRootNext(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t result;
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  result = 1;
  if (a1 && a2 && a3)
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v7 = DERDecodeSeqNext((unint64_t *)(a1 + 96), &v10);
    if (v7)
    {
      if (v7 == 1)
      {
        v8 = 0;
        v9 = 0;
        goto LABEL_9;
      }
    }
    else
    {
      v8 = v12;
      if (v12)
      {
        v9 = v11;
LABEL_9:
        result = 0;
        *a2 = v9;
        *a3 = v8;
        return result;
      }
    }
    return 0x400000;
  }
  return result;
}

uint64_t AMFDRDecodeIterateProducerIDBegin(_QWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  unint64_t v5;
  _QWORD v6[2];

  result = 1;
  if (a1 && a2 && a3)
  {
    v5 = 0xAAAAAAAAAAAAAAAALL;
    v6[0] = a2;
    v6[1] = a3;
    if (DERDecodeSeqInit((uint64_t)v6, &v5, a1))
    {
      AMSupportLogInternal();
      return 0x80000000000;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t AMFDRDecodeCheckProducerIDRevocation(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v7;
  int v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void *__s2;
  unsigned int __n;
  unint64_t __n_4[2];
  unint64_t v17;
  const void *v18;
  uint64_t v19;

  __n_4[0] = 0xAAAAAAAAAAAAAAAALL;
  __n_4[1] = 0xAAAAAAAAAAAAAAAALL;
  v3 = 1;
  if (!a1 || !a2 || !a3)
    return v3;
  AMSupportLogInternal();
  v7 = AMFDRDecodeIterateProducerIDBegin(__n_4, a2, a3);
  if (v7)
  {
    v3 = v7;
LABEL_6:
    AMSupportLogInternal();
    return v3;
  }
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v8 = DERDecodeSeqNext(__n_4, &v17);
  if (v8)
  {
    if (v8 != 1)
    {
      v3 = 0x80000000000;
      goto LABEL_6;
    }
    return 0;
  }
  v9 = v18;
  if (!v18)
    return 0;
  while (2)
  {
    __n = 0;
    __s2 = 0;
    v10 = AMFDRDecodeIterateTrustObjectRevokedBegin(a1);
    if (v10)
    {
      v3 = v10;
      goto LABEL_6;
    }
    while (1)
    {
      v11 = AMFDRDecodeIterateTrustObjectRevokedNext(a1, &__s2, &__n);
      if (v11)
      {
        v3 = v11;
        goto LABEL_6;
      }
      if (!__s2)
        break;
      if (!memcmp(v9, __s2, __n))
      {
        AMSupportLogInternal();
        return 0x10000000000;
      }
    }
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v12 = DERDecodeSeqNext(__n_4, &v17);
    if (v12)
    {
      if (v12 != 1)
      {
        v3 = 0x80000000000;
        goto LABEL_6;
      }
      return 0;
    }
    v3 = 0;
    v9 = v18;
    if (v18)
      continue;
    return v3;
  }
}

uint64_t AMFDRDecodeEvaluateTrustInternal(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  char v8;
  uint64_t v9;
  int v10;
  const void *v11;
  size_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *__s2;
  unsigned int __n;
  char __n_7;
  unsigned int v23;
  int v24;
  void *v25;

  if (!*(_QWORD *)(a1 + 72) || !*(_QWORD *)(a1 + 80))
    *(_QWORD *)a1 |= 0x40000uLL;
  if ((!*(_QWORD *)(a1 + 104) || !*(_QWORD *)(a1 + 112)) && (*(_BYTE *)(a1 + 2017) & 0x20) == 0)
  {
    AMSupportLogInternal();
    result = *(_QWORD *)a1 | 1;
LABEL_12:
    *(_QWORD *)a1 = result;
    return result;
  }
  if (*(_QWORD *)(a1 + 8) && *(_QWORD *)(a1 + 16))
  {
    if (_AMFDRDecodeCombined(a1))
    {
      AMSupportLogInternal();
      v3 = *(_QWORD *)a1;
      *(_QWORD *)(a1 + 1912) = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 1920) = *(_QWORD *)(a1 + 16);
      result = v3 | 0x5A01C00;
      goto LABEL_12;
    }
  }
  else if (!*(_QWORD *)(a1 + 1944) || !*(_QWORD *)(a1 + 1952))
  {
    *(_QWORD *)a1 |= 0x200000uLL;
  }
  v4 = _AMFDRDecodeVerifyTrustObject(a1);
  if (v4)
    *(_QWORD *)a1 |= v4;
  v5 = _AMFDRDecodeVerifyData((uint64_t *)a1);
  if (v5)
    *(_QWORD *)a1 |= v5;
  v25 = 0;
  v24 = 0;
  if ((!*(_QWORD *)(a1 + 344) || !*(_DWORD *)(a1 + 352)) && (!*(_QWORD *)(a1 + 232) || !*(_QWORD *)(a1 + 240)))
  {
LABEL_48:
    AMSupportLogInternal();
    goto LABEL_52;
  }
  v6 = AMFDRDecodeIterateSysconfigBegin(*(_QWORD *)(a1 + 1912), *(_DWORD *)(a1 + 1920), &v25, &v24);
  v7 = v25;
  if (!v25 || v6)
  {
LABEL_49:
    AMSupportLogInternal();
    v17 = *(_QWORD *)a1 | 0x400000000000000;
    goto LABEL_51;
  }
  v8 = 0;
  while (1)
  {
    v23 = 0;
    __n_7 = 0;
    __n = 0;
    __s2 = 0;
    v9 = AMFDRDecodeIterateSysconfigPayloadNext((uint64_t)v7, &v23, &__n_7, &__s2, &__n, 0);
    if (v9)
    {
      if (v9 == 0x40000000000000)
      {
        if (!*(_QWORD *)(a1 + 232) || (*(_QWORD *)(a1 + 240) == 0) | v8 & 1)
          goto LABEL_52;
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    v10 = AMFDRTagsStringToTag(&v23);
    if (v10 == 1634953572)
    {
      v11 = *(const void **)(a1 + 232);
      if (v11)
      {
        v12 = *(_QWORD *)(a1 + 240);
        if (v12)
        {
          if (v12 != __n)
          {
            AMSupportLogInternal();
            *(_QWORD *)a1 |= 0x200000000000000uLL;
            v11 = *(const void **)(a1 + 232);
            v12 = __n;
          }
          if (memcmp(v11, __s2, v12))
          {
            AMSupportLogInternal();
            *(_QWORD *)a1 |= 0x200000000000000uLL;
          }
          v8 = 1;
        }
      }
    }
    if (*(_QWORD *)(a1 + 344))
    {
      v13 = *(unsigned int *)(a1 + 352);
      if ((_DWORD)v13)
        break;
    }
LABEL_47:
    v7 = v25;
  }
  v14 = 0;
  while (*(_DWORD *)(*(_QWORD *)(a1 + 344) + 4 * v14) != v10)
  {
LABEL_46:
    if (++v14 >= v13)
      goto LABEL_47;
  }
  v15 = *(_QWORD *)(a1 + 360);
  if (v15)
  {
    v16 = *(_QWORD *)(a1 + 368);
    if (v16)
    {
      v18 = 0;
      v19 = 0;
      if (!_AMFDRDecodeSearchEntryFromPropertyList(v15, v16, v10, &v18) && v19 && v18)
      {
        v13 = *(unsigned int *)(a1 + 352);
        goto LABEL_46;
      }
    }
  }
  AMSupportLogInternal();
  v17 = *(_QWORD *)a1 | 0x1000000000000000;
LABEL_51:
  *(_QWORD *)a1 = v17;
LABEL_52:
  if (v25)
    free(v25);
  return *(_QWORD *)a1;
}

uint64_t AMFDRDecodeEvaluateTrustOffline(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned int a6, _QWORD *a7, _DWORD *a8)
{
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  v16 = (uint64_t *)malloc_type_malloc(0x7F8uLL, 0x10F0040823DC3CEuLL);
  if (v16)
  {
    v17 = v16;
    bzero(v16, 0x7F8uLL);
    if (!a7 || !a8)
    {
      AMSupportLogInternal();
      v19 = 1;
LABEL_13:
      free(v17);
      return v19;
    }
    v17[13] = a3;
    v17[14] = a4;
    v17[3] = a1;
    v17[4] = a2;
    v17[37] = a5;
    v17[38] = a6;
    v17[251] = (uint64_t)kAMFDRDecodeImplementationOffline;
    if (a3 && a4)
    {
      v18 = _AMFDRDecodeVerifyData(v17);
      v19 = *v17;
      if (!v18)
      {
LABEL_12:
        *a7 = v17[239];
        *a8 = v17[240];
        goto LABEL_13;
      }
      v19 |= v18;
    }
    else
    {
      AMSupportLogInternal();
      v19 = *v17 | 1;
    }
    *v17 = v19;
    goto LABEL_12;
  }
  AMSupportLogInternal();
  return 0x80000000000000;
}

uint64_t AMFDRDecodeCombined(uint64_t a1, unsigned int a2, _QWORD *a3, _DWORD *a4, _QWORD *a5, _DWORD *a6)
{
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;

  v12 = malloc_type_malloc(0x7F8uLL, 0x10F0040823DC3CEuLL);
  if (v12)
  {
    v13 = v12;
    bzero(v12, 0x7F8uLL);
    if (a1 && a2 && a3 && a4 && a5 && a6)
    {
      v13[1] = a1;
      v13[2] = a2;
      v14 = _AMFDRDecodeCombined((uint64_t)v13);
      if (!v14)
      {
        *a3 = v13[243];
        *a4 = v13[244];
        v15 = v13[4];
        *a5 = v13[3];
        *a6 = v15;
      }
    }
    else
    {
      AMSupportLogInternal();
      v14 = 1;
    }
    free(v13);
  }
  else
  {
    AMSupportLogInternal();
    return 0x80000000000000;
  }
  return v14;
}

uint64_t _AMFDRDecodeCombined(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  unint64_t v15[3];
  unint64_t v16[3];

  memset(v16, 170, sizeof(v16));
  v14 = 0u;
  *(_OWORD *)v15 = 0u;
  v13 = 0u;
  if (DERDecodeItem(a1 + 8, v16))
  {
    AMSupportLogInternal();
    *(_QWORD *)a1 |= 0x80uLL;
    return 128;
  }
  if (v16[0] != 0x2000000000000010)
  {
    AMSupportLogInternal();
    *(_QWORD *)a1 |= 0x10000uLL;
    return 0x10000;
  }
  v3 = *(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16);
  if (v3 < v16[1] + v16[2])
  {
    AMSupportLogInternal();
    *(_QWORD *)a1 |= 4uLL;
    return 4;
  }
  if (v3 > v16[1] + v16[2])
  {
    AMSupportLogInternal();
    *(_QWORD *)a1 |= 8uLL;
    return 8;
  }
  if (DERParseSequenceContentToObject(&v16[1], 3u, (uint64_t)&DERFDRCombinedItemSpecs, (unint64_t)&v13, 0x30uLL, 0))goto LABEL_29;
  if (!(_QWORD)v13 || *((_QWORD *)&v13 + 1) != 4)
    goto LABEL_28;
  if (*(_DWORD *)v13 != *(_DWORD *)"comb")
  {
LABEL_29:
    *(_QWORD *)a1 |= 0x20000uLL;
    return 0x20000;
  }
  if ((_QWORD)v14 && *((_QWORD *)&v14 + 1))
  {
    v11 = 0u;
    v12 = 0u;
    if (DERParseSequenceContentToObject((unint64_t *)&v14, 2u, (uint64_t)&DERFDRItemSpecs, (unint64_t)&v11, 0x20uLL, 0)|| !(_QWORD)v11|| *((_QWORD *)&v11 + 1) != 4|| *(_DWORD *)v11 != *(_DWORD *)"fdrd")
    {
LABEL_28:
      AMSupportLogInternal();
      goto LABEL_29;
    }
    v8 = *((_QWORD *)&v12 + 1);
    *(_QWORD *)(a1 + 24) = v12;
    *(_QWORD *)(a1 + 32) = v8;
    if ((*(_BYTE *)(a1 + 2017) & 8) != 0)
    {
      v2 = _AMFDRDecodeMultiCombined(a1);
      if (v2)
      {
        AMSupportLogInternal();
        v10 = *((_QWORD *)&v12 + 1);
        *(_QWORD *)(a1 + 24) = v12;
        *(_QWORD *)(a1 + 32) = v10;
      }
    }
    else
    {
      v2 = 0;
    }
  }
  else
  {
    *(_QWORD *)a1 |= 0x200uLL;
    v2 = 512;
  }
  if (!v15[0] || !v15[1])
  {
    v6 = *(_QWORD *)a1 | 0x200000;
LABEL_35:
    *(_QWORD *)a1 = v6;
    return v2;
  }
  v11 = 0u;
  v12 = 0u;
  if (DERParseSequenceContentToObject(v15, 2u, (uint64_t)&DERFDRItemSpecs, (unint64_t)&v11, 0x20uLL, 0)|| !(_QWORD)v11|| *((_QWORD *)&v11 + 1) != 4|| *(_DWORD *)v11 != *(_DWORD *)"secb")
  {
    AMSupportLogInternal();
    v7 = 0x20000;
    v2 = 0x20000;
LABEL_34:
    v6 = *(_QWORD *)a1 | v7;
    goto LABEL_35;
  }
  v9 = v12;
  *(_OWORD *)(a1 + 1944) = v12;
  v7 = 0x200000;
  if (!(_QWORD)v9 || !*((_QWORD *)&v9 + 1))
    goto LABEL_34;
  return v2;
}

uint64_t AMFDRDecodePublicKey(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  unint64_t v5;
  __int128 v6;

  result = 1;
  if (a1 && a2 && a3)
  {
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    v6 = 0uLL;
    v5 = 0;
    *(_QWORD *)(a1 + 32) = a2;
    *(_QWORD *)(a1 + 40) = a3;
    if (_AMFDRDecodePubKey(a1 + 32, (unint64_t *)a1, a1 + 48))
      goto LABEL_11;
    if (!DEROidCompare(a1 + 48, (uint64_t)&oidEcPubKey))
    {
      AMSupportLogInternal();
      return 64;
    }
    if (DERDecodeItem(a1 + 64, &v5))
    {
LABEL_11:
      AMSupportLogInternal();
      return 16;
    }
    else
    {
      result = 0;
      *(_OWORD *)(a1 + 16) = v6;
    }
  }
  return result;
}

uint64_t _AMFDRDecodePubKey(uint64_t a1, unint64_t *a2, unint64_t a3)
{
  __int128 v5;
  uint64_t result;
  char v7;
  __int128 v8;
  __int128 v9;

  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8 = v5;
  v9 = v5;
  v7 = -86;
  result = DERParseSequenceToObject(a1, (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs, (uint64_t)&DERSubjPubKeyInfoItemSpecs, (unint64_t)&v8, 0x20uLL, 0x20uLL);
  if (!(_DWORD)result)
  {
    result = DERParseSequenceContentToObject((unint64_t *)&v8, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, a3, 0x20uLL, 0x20uLL);
    if (!(_DWORD)result)
    {
      if (DEROidCompare(a3, (uint64_t)&oidRsa) || DEROidCompare(a3, (uint64_t)&oidEcPubKey))
      {
        result = DERParseBitString((uint64_t)&v9, a2, &v7);
        if (!(_DWORD)result)
        {
          if (v7)
            return 3;
          else
            return 0;
        }
      }
      else
      {
        return 2;
      }
    }
  }
  return result;
}

uint64_t AMFDRDecodeCertificate(unint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  _BYTE *v5;
  _BYTE *v6;
  unint64_t v7;

  result = 1;
  if (a1 && a2 && a3)
  {
    *(_OWORD *)(a1 + 272) = 0u;
    *(_OWORD *)(a1 + 288) = 0u;
    *(_OWORD *)(a1 + 240) = 0u;
    *(_OWORD *)(a1 + 256) = 0u;
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_QWORD *)(a1 + 256) = a2;
    *(_QWORD *)(a1 + 264) = a3;
    if (DERParseSequenceToObject(a1 + 256, (unsigned __int16)DERNumSignedCertCrlItemSpecs, (uint64_t)&DERSignedCertCrlItemSpecs, a1, 0x30uLL, 0x30uLL)|| DERParseSequenceToObject(a1, 0xAu, (uint64_t)&FDRDERTBSCertItemSpecs, a1 + 48, 0xA0uLL, 0xA0uLL)|| _AMFDRDecodePubKey(a1 + 144, (unint64_t *)(a1 + 208), a1 + 224))
    {
      return 0x40000000000;
    }
    if (*(_QWORD *)(a1 + 248))
    {
      if (DEROidCompare(a1 + 224, (uint64_t)&oidEcPubKey))
      {
        if (*(_QWORD *)(a1 + 248) != 10)
          return 0x40000000000;
        v5 = *(_BYTE **)(a1 + 240);
        if (*v5 != 6 || v5[1] != 8 || memcmp(v5 + 2, &_oidEcPrime256v1, 8uLL))
          return 0x40000000000;
      }
      else if (DEROidCompare(a1 + 224, (uint64_t)&oidRsa))
      {
        if (*(_QWORD *)(a1 + 248) != 2)
          return 0x40000000000;
        v6 = *(_BYTE **)(a1 + 240);
        if (*v6 != 5 || v6[1])
          return 0x40000000000;
      }
    }
    v7 = 0xAAAAAAAAAAAAAAAALL;
    if (_AMFDRDecodeParseExtension(a1 + 48, (uint64_t)&___oidAppleFDRClientID, &v7, (_QWORD *)(a1 + 272), 1))
    {
      AMSupportLogInternal();
    }
    else if (v7 != 12)
    {
      return 0x40000000000;
    }
    if (_AMFDRDecodeParseExtension(a1 + 48, (uint64_t)&___oidAppleSecureBootCertificateProperties, &v7, (_QWORD *)(a1 + 288), 0))
    {
      AMSupportLogInternal();
      return 0;
    }
    if (v7 == 0x2000000000000011)
      return 0;
    return 0x40000000000;
  }
  return result;
}

uint64_t _AMFDRDecodeParseExtension(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, int a5)
{
  __int128 v5;
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v13;
  unint64_t v15[3];
  _OWORD v16[2];
  __int128 v17;
  unint64_t v18[3];
  unint64_t v19;
  unint64_t v20[2];

  v20[0] = 0xAAAAAAAAAAAAAAAALL;
  v20[1] = 0xAAAAAAAAAAAAAAAALL;
  memset(v18, 170, sizeof(v18));
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[1] = v5;
  v17 = v5;
  memset(v15, 170, sizeof(v15));
  v6 = 1;
  v16[0] = v5;
  if (a1 && a2 && a4)
  {
    *a4 = 0;
    a4[1] = 0;
    if (*(_QWORD *)(a1 + 152) && (v10 = *(_QWORD *)(a1 + 144), v9 = a1 + 144, v10))
    {
      v19 = 0xAAAAAAAAAAAAAAAALL;
      v6 = 16;
      if (!DERDecodeSeqInit(v9, &v19, v20) && v19 == 0x2000000000000010)
      {
        v6 = 2;
        while (!DERDecodeSeqNext(v20, v18))
        {
          if (v18[0] != 0x2000000000000010
            || DERParseSequenceContentToObject(&v18[1], (unsigned __int16)DERNumExtensionItemSpecs, (uint64_t)&DERExtensionItemSpecs, (unint64_t)v16, 0x30uLL, 0x30uLL))
          {
            return 16;
          }
          if (DEROidCompare(a2, (uint64_t)v16))
          {
            if (DERDecodeItem((uint64_t)&v17, v15))
              return 0x40000000000;
            v6 = 0;
            *a3 = v15[0];
            if (a5)
              v13 = &v15[1];
            else
              v13 = (unint64_t *)&v17;
            *(_OWORD *)a4 = *(_OWORD *)v13;
            return v6;
          }
        }
      }
    }
    else
    {
      return 512;
    }
  }
  return v6;
}

double AMFDRDecodeImage4Certificate(_OWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double result;
  __int128 *v11;
  __int128 v12;
  __int128 v13;
  unint64_t v14;
  __int128 v15;
  unint64_t v16;
  unint64_t v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _OWORD v22[2];
  __int128 v23;
  __int128 v24;
  __int128 v25;

  if (a1 && a2 && a3)
  {
    a1[17] = 0u;
    a1[18] = 0u;
    a1[15] = 0u;
    a1[16] = 0u;
    a1[13] = 0u;
    a1[14] = 0u;
    a1[11] = 0u;
    a1[12] = 0u;
    a1[9] = 0u;
    a1[10] = 0u;
    a1[7] = 0u;
    a1[8] = 0u;
    a1[5] = 0u;
    a1[6] = 0u;
    a1[3] = 0u;
    a1[4] = 0u;
    a1[1] = 0u;
    a1[2] = 0u;
    *a1 = 0u;
    v23 = 0u;
    v24 = 0u;
    memset(v22, 0, sizeof(v22));
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v17[0] = 0;
    v17[1] = 0;
    v16 = 0;
    v14 = 0;
    v15 = 0uLL;
    *(_QWORD *)&v25 = a2;
    *((_QWORD *)&v25 + 1) = a3;
    if (DERParseSequenceToObject((uint64_t)&v25, 4u, (uint64_t)&DERFDRImage4CertItemSpecs, (unint64_t)v22, 0x40uLL, 0x40uLL)|| !*(_QWORD *)&v22[0]|| *((_QWORD *)&v22[0] + 1) != 4|| **(_DWORD **)&v22[0] != *(_DWORD *)"IM4C"|| DERDecodeItem((uint64_t)&v23, &v16)|| v16 != 0x2000000000000011|| DERParseSequenceContentToObject(v17, 2u, (uint64_t)&DERFDRImage4CertSignedSectionItemSpecs, (unint64_t)&v20, 0x20uLL, 0x20uLL)|| DERDecodeItem((uint64_t)&v21, &v14)
      || DERParseSequenceToObject((uint64_t)&v20, 2u, (uint64_t)&DERFDRImage4CertPropertyItemSpecs, (unint64_t)&v18, 0x20uLL, 0x20uLL)|| !(_QWORD)v18|| *((_QWORD *)&v18 + 1) != 4|| *(_DWORD *)v18 != *(_DWORD *)"CRTP")
    {
      goto LABEL_27;
    }
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = 0;
      v7 = (uint64_t)*(&kAMFDRDecodeEcdsaInfoList + v4);
      while (*((_QWORD *)&v24 + 1) != *(_DWORD *)(v7 + 4) + (_DWORD)v6)
      {
        if (++v6 == 3)
          goto LABEL_22;
      }
      v5 = *(_OWORD **)(v7 + 24);
LABEL_22:
      ++v4;
    }
    while (v4 != 3);
    if (!v5)
      goto LABEL_27;
    v8 = 0;
    while (1)
    {
      v9 = *(uint64_t *)((char *)&kAMFDRDecodeEcdsaInfoList + v8);
      if (*((_QWORD *)&v15 + 1) == *(_DWORD *)v9)
        break;
      v8 += 8;
      if (v8 == 24)
        goto LABEL_27;
    }
    v11 = *(__int128 **)(v9 + 16);
    if (v11)
    {
      *a1 = v23;
      a1[2] = v24;
      a1[1] = *v5;
      a1[13] = v15;
      a1[14] = oidEcPubKey;
      v12 = *v11;
      a1[18] = v19;
      v13 = v25;
      a1[15] = v12;
      a1[16] = v13;
      result = *(double *)&v15;
      a1[9] = v15;
    }
    else
    {
LABEL_27:
      AMSupportLogInternal();
    }
  }
  return result;
}

uint64_t AMFDRDecodeIterateCertChainBegin(_QWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;

  result = 1;
  if (a1 && a2)
  {
    if (a3)
    {
      result = 0;
      *a1 = a2;
      a1[1] = a3;
      a1[2] = 0;
    }
  }
  return result;
}

void AMFDRDecodeIterateCertChainNext(uint64_t a1, _OWORD **a2, _DWORD *a3)
{
  AMFDRDecodeIterateCertChainNextWithOptions(a1, 0, a2, a3);
}

void AMFDRDecodeIterateCertChainNextWithOptions(uint64_t a1, __int16 a2, _OWORD **a3, _DWORD *a4)
{
  uint64_t v7;
  unint64_t v9;
  _OWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;

  v15 = 0;
  if (a1 && a3 && *(_QWORD *)a1)
  {
    v7 = *(_QWORD *)(a1 + 8);
    if (v7)
    {
      if (!AMFDRDecodeParseDERLengthFromBuffer(*(_QWORD *)a1, v7, &v15))
      {
        v9 = *(_QWORD *)(a1 + 8);
        if (v9 >= v15)
        {
          v10 = *a3;
          v11 = *(_QWORD *)a1;
          if ((a2 & 0x100) != 0)
            AMFDRDecodeImage4Certificate(v10, v11, v9);
          else
            v12 = AMFDRDecodeCertificate((unint64_t)v10, v11, v9);
          if (!v12)
          {
            v13 = *(unsigned __int16 *)(a1 + 16);
            *(_WORD *)(a1 + 16) = v13 + 1;
            *a4 = v13;
            v14 = *(_QWORD *)(a1 + 8) - v15;
            *(_QWORD *)a1 += v15;
            *(_QWORD *)(a1 + 8) = v14;
          }
        }
      }
    }
    else
    {
      *a3 = 0;
    }
  }
}

uint64_t AMFDRDecodeCheckCertRevocation(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  unsigned int v5;
  uint64_t v6;
  int v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  void *__s2;
  unsigned int __n;
  _OWORD __n_4[2];
  _OWORD v15[2];
  _OWORD __s1[2];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  __n = 0;
  __s2 = 0;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __s1[0] = v4;
  __s1[1] = v4;
  v15[0] = v4;
  v15[1] = v4;
  __n_4[0] = v4;
  __n_4[1] = v4;
  v5 = AMSupportDigestSha256();
  if (v5)
    goto LABEL_3;
  v5 = AMSupportDigestSha256();
  if (v5)
    goto LABEL_3;
  if (*(_QWORD *)(a2 + 272) && *(_QWORD *)(a2 + 280))
  {
    v5 = AMSupportDigestSha256();
    if (v5)
    {
LABEL_3:
      v6 = v5;
LABEL_4:
      AMSupportLogInternal();
      return v6;
    }
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  v9 = AMFDRDecodeIterateTrustObjectRevokedBegin(a1);
  if (v9)
  {
    v6 = v9;
    goto LABEL_4;
  }
  v10 = AMFDRDecodeIterateTrustObjectRevokedNext(a1, &__s2, &__n);
  if (v10)
  {
    v6 = v10;
    goto LABEL_4;
  }
  while (1)
  {
    v6 = (uint64_t)__s2;
    if (!__s2)
      return v6;
    v11 = __n;
    if (!memcmp(__s1, __s2, __n))
    {
      v6 = 0x10000000000;
      goto LABEL_4;
    }
    if (!memcmp(v15, (const void *)v6, v11))
    {
      v6 = 0x10000000000;
      goto LABEL_4;
    }
    if (v8 && !memcmp(__n_4, (const void *)v6, v11))
    {
      v6 = 0x10000000000;
      goto LABEL_4;
    }
    v6 = AMFDRDecodeIterateTrustObjectRevokedNext(a1, &__s2, &__n);
    if (v6)
      goto LABEL_4;
  }
}

uint64_t AMFDRDecodeVerifyCertIssuerWithOptions(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4, _QWORD *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a3)
  {
    AMSupportLogInternal();
    return 1;
  }
  if ((a4 & 0x100) == 0)
    return _AMFDRDecodeVerifyCertIssuerInternal(a1, a2, a3, a5);
  v8 = *(_QWORD *)(a1 + 24);
  if (!v8)
  {
    v10 = 0x40000000000;
    goto LABEL_9;
  }
  v9 = *(_QWORD *)(a1 + 40);
  if (!v9)
  {
    v10 = 0x40000000000;
    goto LABEL_9;
  }
  if (_AMFDRDecodeVerifySignatureDataWithOid(*(const void **)(a2 + 208), *(_DWORD *)(a2 + 216), *(_QWORD *)(a1 + 32), v9, *(_QWORD *)a1, *(unsigned int *)(a1 + 8), *(_QWORD *)(a1 + 16), v8, a2 + 240, 1, a5))
  {
    v10 = 0x20000000000;
LABEL_9:
    AMSupportLogInternal();
    return v10;
  }
  AMSupportLogInternal();
  v10 = AMFDRDecodeCheckCertRevocation(a3, a1);
  if (v10)
    goto LABEL_9;
  return v10;
}

uint64_t _AMFDRDecodeVerifyCertIssuerInternal(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  __int128 v7;
  size_t v8;
  _OWORD *v10;
  _OWORD *v11;
  uint64_t v12;
  uint64_t v14;
  unint64_t v15;
  char v16;
  _OWORD v17[2];

  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[0] = v7;
  v17[1] = v7;
  v14 = 0xAAAAAAAAAAAAAAAALL;
  v15 = 0xAAAAAAAAAAAAAAAALL;
  v8 = *(_QWORD *)(a2 + 136);
  if (v8 != *(_QWORD *)(a1 + 104) || memcmp(*(const void **)(a2 + 128), *(const void **)(a1 + 96), v8))
  {
    AMSupportLogInternal();
    v10 = malloc_type_malloc(0x100uLL, 0xC5EEB387uLL);
    _AMFDRDecodeSequenceString(*(_QWORD *)(a2 + 128), *(_QWORD *)(a2 + 136), v10);
    v11 = malloc_type_malloc(0x100uLL, 0x835E80AEuLL);
    _AMFDRDecodeSequenceString(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), v11);
    AMSupportLogInternal();
    if (v10)
      free(v10);
    if (v11)
      free(v11);
    return 0x20000000000;
  }
  v16 = -86;
  if (DERParseSequenceContentToObject((unint64_t *)(a1 + 16), (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)v17, 0x20uLL, 0x20uLL)|| DERParseBitString(a1 + 32, (unint64_t *)&v14, &v16)|| v16)
  {
    AMSupportLogInternal();
    return 0x40000000000;
  }
  if (_AMFDRDecodeVerifySignatureDataWithOid(*(const void **)(a2 + 208), *(_DWORD *)(a2 + 216), v14, v15, *(_QWORD *)a1, *(unsigned int *)(a1 + 8), *(uint64_t *)&v17[0], DWORD2(v17[0]), a1 + 240, 0, a4))
  {
    AMSupportLogInternal();
    return 0x20000000000;
  }
  AMSupportLogInternal();
  if (!a3)
    return 0;
  v12 = AMFDRDecodeCheckCertRevocation(a3, a1);
  if (v12)
    AMSupportLogInternal();
  return v12;
}

uint64_t AMFDRDecodeParseDERLengthFromBuffer(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  uint64_t result;
  unint64_t v6[3];
  _QWORD v7[2];

  memset(v6, 170, sizeof(v6));
  result = 1;
  if (a1 && a3)
  {
    v7[0] = a1;
    v7[1] = a2;
    if (DERDecodeItemPartialBufferGetLength((uint64_t)v7, v6, 0))
    {
      AMSupportLogInternal();
      return 2;
    }
    else
    {
      result = 0;
      *a3 = LODWORD(v6[2]) - a1 + LODWORD(v6[1]);
    }
  }
  return result;
}

uint64_t AMFDRDecodeMultiSealingResponse(uint64_t a1, unsigned int a2, _BYTE *a3, uint64_t (*a4)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t), uint64_t a5)
{
  uint64_t v5;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _OWORD v15[2];

  v5 = 1;
  if (a1 && a2 && a3)
  {
    memset(v15, 0, sizeof(v15));
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    *(_QWORD *)&v11 = a1;
    *((_QWORD *)&v11 + 1) = a2;
    if (DERParseSequenceToObject((uint64_t)&v11, 2u, (uint64_t)&DERFDRMultiResponseItemSpecs, (unint64_t)v15, 0x20uLL, 0)|| (v11 = v15[0], DERParseSequenceContentToObject((unint64_t *)&v11, 3u, (uint64_t)&DERFDRMultiSealingResponsePayloadItemSpecs, (unint64_t)&v12, 0x30uLL, 0)))
    {
      AMSupportLogInternal();
      return 16;
    }
    else if ((_QWORD)v13 && (v10 = _AMFDRDecodeMultiSealingResposeRecords(1, (unint64_t *)&v13, a4, a5)) != 0
           || (_QWORD)v14 && (v10 = _AMFDRDecodeMultiSealingResposeRecords(0, (unint64_t *)&v14, a4, a5)) != 0)
    {
      v5 = v10;
      AMSupportLogInternal();
    }
    else if ((_QWORD)v12 && *((_QWORD *)&v12 + 1) == 1)
    {
      v5 = 0;
      *a3 = *(_BYTE *)v12;
    }
    else
    {
      AMSupportLogInternal();
      return 32;
    }
  }
  return v5;
}

uint64_t _AMFDRDecodeMultiSealingResposeRecords(uint64_t a1, unint64_t *a2, uint64_t (*a3)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t), uint64_t a4)
{
  uint64_t v7;
  __int128 v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  unint64_t v21;
  __int128 v22;
  unint64_t v23[2];
  __int128 v24;

  *(_QWORD *)&v24 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if (!a2 || !*a2 || !a2[1])
    return 1;
  v23[0] = 0;
  v23[1] = 0;
  v22 = 0uLL;
  v21 = 0;
  if (DERDecodeSeqContentInit(a2, v23))
  {
LABEL_5:
    AMSupportLogInternal();
    return 16;
  }
  else
  {
    v8 = 0uLL;
    v7 = 16;
    while (1)
    {
      v17 = v8;
      v18 = v8;
      v19 = v8;
      v20 = v8;
      v15 = v8;
      v16 = v8;
      v9 = DERDecodeSeqNext(v23, &v21);
      if (v9)
        break;
      if (!*((_QWORD *)&v22 + 1))
        return v7;
      if (v21 != 0x2000000000000010)
        goto LABEL_34;
      v24 = v22;
      if (DERParseSequenceContentToObject((unint64_t *)&v24, 4u, (uint64_t)&DERFDRMultiResponseRecordItemSpecs, (unint64_t)&v17, 0x40uLL, 0))goto LABEL_5;
      if ((_QWORD)v18)
      {
        v24 = v18;
        if (DERDecodeItem((uint64_t)&v24, &v21))
          goto LABEL_34;
        if (v21 != 4)
        {
          AMSupportLogInternal();
          return 64;
        }
        v10 = v22;
        if (!(_QWORD)v22 || (v11 = *((_QWORD *)&v22 + 1)) == 0)
        {
LABEL_34:
          AMSupportLogInternal();
          return 32;
        }
      }
      else
      {
        v10 = 0;
        v11 = 0;
      }
      if ((_QWORD)v20)
      {
        v24 = v20;
        if (DERParseSequenceToObject((uint64_t)&v24, 2u, (uint64_t)&DERFDRMultiResponseErrorItemSpecs, (unint64_t)&v15, 0x20uLL, 0))goto LABEL_5;
        if (!(_QWORD)v15 || *((_QWORD *)&v15 + 1) != 1)
          goto LABEL_34;
      }
      if (a3)
      {
        v12 = a3(v17, DWORD2(v17), v10, v11, v19, DWORD2(v19), a1, v15, DWORD2(v15), v16, DWORD2(v16), a4);
        if (v12)
        {
          v14 = v12;
          AMSupportLogInternal();
          return v14;
        }
      }
      v8 = 0uLL;
    }
    if (v9 == 1)
      return 0;
  }
  return v7;
}

uint64_t AMFDRDecodeMultiResponse(uint64_t a1, unsigned int a2, _BYTE *a3, uint64_t (*a4)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t), uint64_t a5)
{
  uint64_t v5;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _OWORD v15[2];

  v5 = 1;
  if (a1 && a2 && a3)
  {
    memset(v15, 0, sizeof(v15));
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    *(_QWORD *)&v11 = a1;
    *((_QWORD *)&v11 + 1) = a2;
    if (DERParseSequenceToObject((uint64_t)&v11, 2u, (uint64_t)&DERFDRMultiResponseItemSpecs, (unint64_t)v15, 0x20uLL, 0)|| (v11 = v15[0], DERParseSequenceContentToObject((unint64_t *)&v11, 3u, (uint64_t)&DERFDRMultiResponsePayloadItemSpecs, (unint64_t)&v12, 0x30uLL, 0)))
    {
      AMSupportLogInternal();
      return 16;
    }
    else if ((_QWORD)v13 && (v10 = _AMFDRDecodeMultiResposeRecords(1, &v13, a4, a5)) != 0
           || (_QWORD)v14 && (v10 = _AMFDRDecodeMultiResposeRecords(0, &v14, a4, a5)) != 0)
    {
      v5 = v10;
      AMSupportLogInternal();
    }
    else if ((_QWORD)v12 && *((_QWORD *)&v12 + 1) == 1)
    {
      v5 = 0;
      *a3 = *(_BYTE *)v12;
    }
    else
    {
      AMSupportLogInternal();
      return 32;
    }
  }
  return v5;
}

uint64_t _AMFDRDecodeMultiResposeRecords(uint64_t a1, _QWORD *a2, uint64_t (*a3)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t), uint64_t a4)
{
  uint64_t v7;
  __int128 v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  unint64_t v21;
  __int128 v22;
  unint64_t v23[2];
  __int128 v24;
  uint64_t v25;

  *((_QWORD *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v25 = 0;
  *(_QWORD *)&v24 = 0xAAAAAAAAAAAAAAAALL;
  if (!a2 || !*a2 || !a2[1])
    return 1;
  v23[0] = 0;
  v23[1] = 0;
  v22 = 0uLL;
  v21 = 0;
  if (DERDecodeSeqInit((uint64_t)a2, &v25, v23))
  {
LABEL_5:
    AMSupportLogInternal();
    return 16;
  }
  else if (v25 == 0x2000000000000011)
  {
    v8 = 0uLL;
    v7 = 16;
    while (1)
    {
      v17 = v8;
      v18 = v8;
      v19 = v8;
      v20 = v8;
      v15 = v8;
      v16 = v8;
      v9 = DERDecodeSeqNext(v23, &v21);
      if (v9)
        break;
      if (!*((_QWORD *)&v22 + 1))
        return v7;
      if (v21 != 0x2000000000000010)
        goto LABEL_26;
      v24 = v22;
      if (DERParseSequenceContentToObject((unint64_t *)&v24, 4u, (uint64_t)&DERFDRMultiResponseRecordItemSpecs, (unint64_t)&v17, 0x40uLL, 0))goto LABEL_5;
      if ((_QWORD)v18)
      {
        v24 = v18;
        if (DERDecodeItem((uint64_t)&v24, &v21))
          goto LABEL_26;
        if (v21 != 4)
        {
          AMSupportLogInternal();
          return 64;
        }
        v10 = v22;
        if (!(_QWORD)v22)
          goto LABEL_26;
        v11 = *((_QWORD *)&v22 + 1);
        if (!*((_QWORD *)&v22 + 1))
          goto LABEL_26;
      }
      else
      {
        v10 = 0;
        v11 = 0;
      }
      if ((_QWORD)v20)
      {
        v24 = v20;
        if (DERParseSequenceToObject((uint64_t)&v24, 2u, (uint64_t)&DERFDRMultiResponseErrorItemSpecs, (unint64_t)&v15, 0x20uLL, 0))goto LABEL_5;
        if (!(_QWORD)v15 || *((_QWORD *)&v15 + 1) != 1)
          goto LABEL_26;
      }
      if (a3)
      {
        v12 = a3(v17, DWORD2(v17), v10, v11, v19, DWORD2(v19), a1, v15, DWORD2(v15), v16, DWORD2(v16), a4);
        if (v12)
        {
          v14 = v12;
          AMSupportLogInternal();
          return v14;
        }
      }
      v8 = 0uLL;
    }
    if (v9 == 1)
      return 0;
  }
  else
  {
LABEL_26:
    AMSupportLogInternal();
    return 32;
  }
  return v7;
}

uint64_t AMFDRDecodeMetadata(unint64_t a1, unsigned int a2, uint64_t (*a3)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t), uint64_t a4)
{
  uint64_t v4;
  __int128 v7;
  int v8;
  uint64_t v9;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17[2];
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = 0;
  v4 = 1;
  if (a1 && a2)
  {
    v17[0] = 0;
    v17[1] = 0;
    v15 = 0;
    v16 = 0;
    v14 = 0;
    v18 = a1;
    v19 = a2;
    if (DERDecodeSeqInit((uint64_t)&v18, &v20, v17))
    {
LABEL_4:
      AMSupportLogInternal();
      return 16;
    }
    else if (v20 == 0x2000000000000011)
    {
      v7 = 0uLL;
      v4 = 16;
      while (1)
      {
        v12 = v7;
        v13 = v7;
        v8 = DERDecodeSeqNext(v17, &v14);
        if (v8)
          break;
        if (!v16)
          return 512;
        if (v14 != 0x2000000000000010)
          goto LABEL_14;
        v18 = v15;
        v19 = v16;
        if (DERParseSequenceContentToObject(&v18, 2u, (uint64_t)&DERFDRMetadataRecordItemSpecs, (unint64_t)&v12, 0x20uLL, 0))goto LABEL_4;
        if (a3)
        {
          v9 = a3(v12, DWORD2(v12), v13, DWORD2(v13), a4);
          if (v9)
          {
            v11 = v9;
            AMSupportLogInternal();
            return v11;
          }
        }
        v7 = 0uLL;
      }
      if (v8 == 1)
        return 0;
    }
    else
    {
LABEL_14:
      AMSupportLogInternal();
      return 32;
    }
  }
  return v4;
}

uint64_t AMFDRDecodeGetImg4RawData(uint64_t a1, int a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t v4;

  v4 = 1;
  if (a1 && a2)
  {
    if (Img4DecodeInit())
    {
      return 0x2000;
    }
    else
    {
      v4 = 0;
      if (a3 && a4)
      {
        v4 = 0;
        *a3 = 0xAAAAAAAAAAAAAAAALL;
        *a4 = -1431655766;
      }
    }
  }
  return v4;
}

uint64_t AMFDRDecodeGetImg4Manifest(uint64_t a1, int a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t v4;

  v4 = 1;
  if (a1 && a2)
  {
    if (Img4DecodeInit())
    {
      AMSupportLogInternal();
      return 0x2000;
    }
    else
    {
      v4 = 0;
      if (a3 && a4)
      {
        v4 = 0;
        *a3 = 0xAAAAAAAAAAAAAAAALL;
        *a4 = -1431655766;
      }
    }
  }
  return v4;
}

uint64_t AMFDRDecodeFDR2Data(uint64_t a1, unsigned int a2, _QWORD *a3, _DWORD *a4, _QWORD *a5, _DWORD *a6)
{
  uint64_t v10;
  int v13;
  int v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  unint64_t v19[3];
  uint64_t v20;
  uint64_t v21;
  unint64_t v22[3];

  v18 = 0u;
  *(_OWORD *)v19 = 0u;
  v17 = 0u;
  v20 = a1;
  v21 = a2;
  memset(v22, 170, sizeof(v22));
  if (DERDecodeItem((uint64_t)&v20, v22))
  {
    AMSupportLogInternal();
    return 128;
  }
  if (v22[0] != 0x2000000000000010)
  {
    AMSupportLogInternal();
    return 0x4000000000000;
  }
  if (v20 + v21 < v22[1] + v22[2])
  {
    AMSupportLogInternal();
    return 4;
  }
  if (v20 + v21 > v22[1] + v22[2])
  {
    AMSupportLogInternal();
    return 8;
  }
  if (DERParseSequenceContentToObject(&v22[1], 3u, (uint64_t)&DERFDR2DataItemSpecs, (unint64_t)&v17, 0x30uLL, 0))return 0x8000000000000;
  if (!(_QWORD)v17 || *((_QWORD *)&v17 + 1) != 4 || *(_DWORD *)v17 != *(_DWORD *)"fdr2")
  {
LABEL_14:
    AMSupportLogInternal();
    return 0x8000000000000;
  }
  v10 = 512;
  if ((_QWORD)v18 && *((_QWORD *)&v18 + 1))
  {
    v15 = 0u;
    v16 = 0u;
    if (DERParseSequenceContentToObject((unint64_t *)&v18, 2u, (uint64_t)&DERFDRItemSpecs, (unint64_t)&v15, 0x20uLL, 0)|| !(_QWORD)v15|| *((_QWORD *)&v15 + 1) != 4|| *(_DWORD *)v15 != *(_DWORD *)"fdrd")
    {
      goto LABEL_14;
    }
    v10 = 0;
    v13 = DWORD2(v16);
    *a3 = v16;
    *a4 = v13;
  }
  if (v19[0] && v19[1])
  {
    v15 = 0u;
    v16 = 0u;
    if (!DERParseSequenceContentToObject(v19, 2u, (uint64_t)&DERFDRItemSpecs, (unint64_t)&v15, 0x20uLL, 0)&& (_QWORD)v15&& *((_QWORD *)&v15 + 1) == 4&& *(_DWORD *)v15 == *(_DWORD *)"mft2")
    {
      v14 = DWORD2(v16);
      *a5 = v16;
      *a6 = v14;
      return v10;
    }
    goto LABEL_14;
  }
  return v10;
}

uint64_t AMFDRDecodeOfflineBlob(uint64_t a1, unsigned int a2, _QWORD *a3, _DWORD *a4, _QWORD *a5, _DWORD *a6, _QWORD *a7, _DWORD *a8)
{
  uint64_t v14;
  int v16;
  int v17;
  int v18;
  unint64_t v19[2];
  unint64_t v20[4];
  _QWORD v21[2];

  memset(v20, 170, sizeof(v20));
  v19[0] = 0xAAAAAAAAAAAAAAAALL;
  v19[1] = 0xAAAAAAAAAAAAAAAALL;
  v21[0] = a1;
  v21[1] = a2;
  if (DERDecodeSeqInit((uint64_t)v21, v20, v19) || DERDecodeSeqNext(v19, &v20[1]))
    goto LABEL_3;
  if (v20[1] != 2)
  {
LABEL_13:
    v14 = 32;
    goto LABEL_4;
  }
  v16 = v20[3];
  *a3 = v20[2];
  *a4 = v16;
  if (!DERDecodeSeqNext(v19, &v20[1]))
  {
    if (v20[1] != 2)
      goto LABEL_13;
    v17 = v20[3];
    *a5 = v20[2];
    *a6 = v17;
    if (!DERDecodeSeqNext(v19, &v20[1]))
    {
      if (v20[1] == 2)
      {
        v18 = v20[3];
        *a7 = v20[2];
        *a8 = v18;
        if (DERDecodeSeqNext(v19, &v20[1]) == 1)
          return 0;
        goto LABEL_3;
      }
      goto LABEL_13;
    }
  }
LABEL_3:
  v14 = 16;
LABEL_4:
  AMSupportLogInternal();
  return v14;
}

uint64_t AMFDRDecodeTrustEvaluation(uint64_t *a1, _QWORD *a2, _DWORD *a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  BOOL v27;
  uint64_t (**v28)();
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v6 = malloc_type_malloc(0x7F8uLL, 0x10F0040823DC3CEuLL);
  if (v6)
  {
    v7 = (uint64_t)v6;
    bzero(v6, 0x7F8uLL);
    if (a1 && (v8 = *a1) != 0 && (v9 = *((unsigned int *)a1 + 2), (_DWORD)v9) && a2 && a3)
    {
      v10 = a1[18];
      if ((v10 & 0x801) != 0)
      {
        *(_QWORD *)(v7 + 8) = v8;
        *(_QWORD *)(v7 + 16) = v9;
      }
      else
      {
        *(_QWORD *)(v7 + 1944) = a1[2];
        *(_QWORD *)(v7 + 1952) = *((unsigned int *)a1 + 6);
        *(_QWORD *)(v7 + 24) = v8;
        *(_QWORD *)(v7 + 32) = v9;
        v13 = *((unsigned int *)a1 + 10);
        *(_QWORD *)(v7 + 280) = a1[4];
        *(_QWORD *)(v7 + 288) = v13;
      }
      v14 = *((unsigned int *)a1 + 14);
      *(_QWORD *)(v7 + 72) = a1[6];
      *(_QWORD *)(v7 + 80) = v14;
      v15 = *((unsigned int *)a1 + 18);
      *(_QWORD *)(v7 + 88) = a1[8];
      *(_QWORD *)(v7 + 96) = v15;
      v16 = 12;
      if ((v10 & 0x80) == 0)
        v16 = 10;
      v17 = 13;
      if ((v10 & 0x80) == 0)
        v17 = 11;
      v18 = LODWORD(a1[v17]);
      *(_QWORD *)(v7 + 104) = a1[v16];
      *(_QWORD *)(v7 + 112) = v18;
      v19 = *((unsigned int *)a1 + 34);
      *(_QWORD *)(v7 + 216) = a1[16];
      *(_QWORD *)(v7 + 224) = v19;
      v20 = *((unsigned int *)a1 + 66);
      *(_QWORD *)(v7 + 232) = a1[32];
      *(_QWORD *)(v7 + 240) = v20;
      v21 = *((unsigned int *)a1 + 26);
      *(_QWORD *)(v7 + 136) = a1[12];
      *(_QWORD *)(v7 + 144) = v21;
      v22 = a1[14];
      v23 = *((unsigned int *)a1 + 30);
      *(_QWORD *)(v7 + 168) = v22;
      *(_QWORD *)(v7 + 176) = v23;
      v24 = a1[26];
      if (v24 && (v25 = *((unsigned int *)a1 + 54), (_DWORD)v25))
      {
        *(_QWORD *)(v7 + 184) = v24;
        v23 = v25;
      }
      else
      {
        *(_QWORD *)(v7 + 184) = v22;
      }
      *(_QWORD *)(v7 + 192) = v23;
      *(_QWORD *)(v7 + 2016) = v10;
      if (v22)
        v26 = 1;
      else
        v26 = (_DWORD)v14 == 48;
      v27 = !v26 && (v10 & 0x20) == 0;
      v28 = kAMFDRDecodeImplementationSha1;
      if (!v27)
        v28 = kAMFDRDecodeImplementationSha384;
      *(_QWORD *)(v7 + 2008) = v28;
      if ((v10 & 0x100) != 0)
      {
        *(_QWORD *)(v7 + 2008) = kAMFDRDecodeImplementationSha384;
        v29 = *((unsigned int *)a1 + 58);
        *(_QWORD *)(v7 + 152) = a1[28];
        *(_QWORD *)(v7 + 160) = v29;
      }
      if ((v10 & 0x1000) != 0)
      {
        v30 = *((unsigned int *)a1 + 62);
        *(_QWORD *)(v7 + 120) = a1[30];
        *(_QWORD *)(v7 + 128) = v30;
      }
      *(_QWORD *)(v7 + 2024) = a1[19];
      v31 = a1[34];
      if (v31)
      {
        v32 = *((_DWORD *)a1 + 70);
        if (v32)
        {
          *(_QWORD *)(v7 + 344) = v31;
          *(_DWORD *)(v7 + 352) = v32;
        }
      }
      v11 = AMFDRDecodeEvaluateTrustInternal(v7);
      *a2 = *(_QWORD *)(v7 + 1912);
      *a3 = *(_QWORD *)(v7 + 1920);
      if (*(_BYTE *)(v7 + 2032))
      {
        v33 = *(_OWORD *)(v7 + 728);
        v34 = *(_OWORD *)(v7 + 760);
        *((_OWORD *)a1 + 11) = *(_OWORD *)(v7 + 744);
        *((_OWORD *)a1 + 12) = v34;
        *((_OWORD *)a1 + 10) = v33;
      }
      v35 = a1[18];
      if ((v35 & 2) != 0 && (v11 & 0x2600000000100) != 0)
      {
        AMSupportLogInternal();
        v11 &= 0xFFFD9FFFFFFFFEFFLL;
        v35 = a1[18];
      }
      if ((v35 & 4) != 0 && (v11 & 0x140000) != 0)
      {
        AMSupportLogInternal();
        v11 &= 0xFFFFFFFFFFEBFFFFLL;
        v35 = a1[18];
      }
      if ((v35 & 8) != 0)
      {
        v36 = 0x8005A33C80;
        if ((v35 & 1) == 0)
          v36 = 0x8005A03C00;
        v37 = v36 & v11;
        if ((v36 & v11) != 0)
        {
          AMSupportLogInternal();
          v11 ^= v37;
          v35 = a1[18];
        }
      }
      if ((v35 & 0x10) != 0 && (v11 & 0x1040000300000) != 0)
      {
        AMSupportLogInternal();
        v11 &= 0xFFFEFBFFFFCFFFFFLL;
        v35 = a1[18];
      }
      if ((v35 & 0x40) != 0 && (v11 & 0x2C0100) != 0)
      {
        AMSupportLogInternal();
        v11 &= 0xFFFFFFFFFFD3FEFFLL;
        v35 = a1[18];
      }
      if ((v35 & 0x4000) != 0 && (v11 & 0x1000000000000000) != 0)
      {
        AMSupportLogInternal();
        v11 &= ~0x1000000000000000uLL;
      }
    }
    else
    {
      AMSupportLogInternal();
      v11 = 1;
    }
    free((void *)v7);
  }
  else
  {
    AMSupportLogInternal();
    return 0x80000000000000;
  }
  return v11;
}

uint64_t AMFDRDecodeMetaProperty(uint64_t a1, unsigned int a2, uint64_t (*a3)(_QWORD))
{
  uint64_t v3;
  int v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  unint64_t v12;
  __int128 v13;
  unint64_t v14[2];
  __int128 v15;

  v3 = 1;
  if (a1 && a2)
  {
    v14[0] = 0;
    v14[1] = 0;
    v13 = 0uLL;
    v12 = 0;
    *(_QWORD *)&v15 = a1;
    *((_QWORD *)&v15 + 1) = a2;
    if (DERDecodeSeqContentInit((unint64_t *)&v15, v14)
      || DERDecodeSeqNext(v14, &v12)
      || (v15 = v13, DERDecodeSeqContentInit((unint64_t *)&v15, v14))
      || DERDecodeSeqNext(v14, &v12)
      || (v15 = v13,
          v10 = 0u,
          v11 = 0u,
          DERParseSequenceContentToObject((unint64_t *)&v15, 2u, (uint64_t)&DERFDRMetaPropertyItemSpecs, (unint64_t)&v10, 0x20uLL, 0))|| (v15 = v11, DERDecodeSeqContentInit((unint64_t *)&v15, v14)))
    {
      AMSupportLogInternal();
      return 16;
    }
    else
    {
      v3 = 34;
      while (1)
      {
        v6 = DERDecodeSeqNext(v14, &v12);
        if (v6)
          break;
        if (!*((_QWORD *)&v13 + 1))
          return 512;
        if (a3)
        {
          if (!(_QWORD)v10
            || *((_QWORD *)&v10 + 1) != 16
            || (*(_QWORD *)v10 == 0x2D6C616D696E696DLL ? (v7 = *(_QWORD *)(v10 + 8) == 0x74736566696E616DLL) : (v7 = 0),
                !v7))
          {
            AMSupportLogInternal();
            return v3;
          }
          v8 = a3(0);
          v3 = 32;
          if (v8)
          {
            v9 = v8;
            AMSupportLogInternal();
            return v9;
          }
        }
      }
      if (v6 == 1)
        return 0;
      else
        return 16;
    }
  }
  return v3;
}

uint64_t AMFDRDecodeManifestBody(_QWORD *a1)
{
  __int128 v2;
  char *v3;
  int v5;
  unint64_t v6[3];
  __int128 v7;
  _BYTE v8[32];

  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v8 = v2;
  *(_OWORD *)&v8[16] = v2;
  v7 = v2;
  memset(v6, 170, sizeof(v6));
  v5 = 0;
  v3 = (char *)malloc_type_malloc(0x1D8uLL, 0x10100404982B0ADuLL);
  *a1 = v3;
  if (!Img4DecodeInitManifest()
    && !DERDecodeItem((uint64_t)(v3 + 280), v6)
    && v6[0] == 0x2000000000000011
    && !DERParseInteger((char **)v3 + 33, &v5)
    && !DERImg4DecodeFindProperty())
  {
    *(_OWORD *)(v3 + 56) = *(_OWORD *)&v8[8];
    if (!DERDecodeSeqContentInit((unint64_t *)v3 + 7, (unint64_t *)v3))
      return 0;
  }
  AMSupportLogInternal();
  return 2;
}

uint64_t AMFDRDecodeManifestBodyNext(unint64_t **a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, _DWORD *a5)
{
  unint64_t *v5;
  int v6;
  int ObjectPropertyData;
  unint64_t v9;
  __int128 v10;

  v9 = 0;
  v10 = 0uLL;
  v5 = *a1;
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  v6 = DERDecodeSeqNext(v5, &v9);
  if (v6 == 1)
    return 0x40000000000000;
  if (v6)
    goto LABEL_10;
  ObjectPropertyData = Img4DecodeGetObjectPropertyData();
  if (ObjectPropertyData == 1)
    return 0;
  if (!ObjectPropertyData
    && !DERImg4DecodePropertyWithItem()
    && !Img4DecodeEvaluateDictionaryProperties())
  {
    return 0;
  }
LABEL_10:
  AMSupportLogInternal();
  return 2;
}

uint64_t _AMFDRDecodeGetDataInstCallback(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t PropertyData;

  if (!a4)
  {
    PropertyData = 6;
LABEL_6:
    AMSupportLogInternal();
    return PropertyData;
  }
  if (a1 != 1768846196)
    return 0;
  PropertyData = Img4DecodeGetPropertyData();
  if ((_DWORD)PropertyData)
    goto LABEL_6;
  return PropertyData;
}

uint64_t AMFDRDecodeManifestBodyDestroy(void *a1)
{
  if (a1)
    free(a1);
  return 0;
}

void AMFDRDecodeIterateSysconfigDestroy(void **a1)
{
  void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      free(v2);
      *a1 = 0;
    }
  }
}

uint64_t AMFDRDecodeIterateSysconfigBegin(uint64_t a1, unsigned int a2, _QWORD *a3, _BYTE *a4)
{
  uint64_t v4;
  _BYTE *v7;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t i;
  int v12;
  uint64_t v14;
  _QWORD v15[2];

  v14 = 0;
  v4 = 1;
  if (!a1)
    return v4;
  if (!a2)
    return v4;
  if (!a3)
    return v4;
  v7 = a4;
  if (!a4)
    return v4;
  v9 = (_QWORD *)*a3;
  v10 = (_QWORD *)*a3;
  if (!*a3)
  {
    v10 = malloc_type_malloc(0x78uLL, 0x101004079CA27EEuLL);
    if (!v10)
      return 0x80000000000000;
  }
  v10[14] = 0;
  *((_OWORD *)v10 + 5) = 0u;
  *((_OWORD *)v10 + 6) = 0u;
  *((_OWORD *)v10 + 3) = 0u;
  *((_OWORD *)v10 + 4) = 0u;
  *((_OWORD *)v10 + 1) = 0u;
  *((_OWORD *)v10 + 2) = 0u;
  *(_OWORD *)v10 = 0u;
  v15[0] = a1;
  v15[1] = a2;
  if (DERParseSequenceToObject((uint64_t)v15, 5u, (uint64_t)&DERSysconfigItemSpecs, (unint64_t)(v10 + 1), 0x50uLL, 0))
  {
    AMSupportLogInternal();
    v4 = 0x400000000000000;
    goto LABEL_29;
  }
  if (v10[2] != 4)
  {
    AMSupportLogInternal();
    v4 = 0x400000000000020;
    goto LABEL_29;
  }
  for (i = 3; i != -1; --i)
    *v7++ = *(_BYTE *)(v10[1] + i);
  if (v10[4] != 4 || (v12 = *(_DWORD *)v10[3], !(_BYTE)v12) || (v12 & 0xFFFF00) != 0x30000)
  {
    AMSupportLogInternal();
    v4 = 0x402000000000000;
    goto LABEL_29;
  }
  if (DERDecodeSeqInit((uint64_t)(v10 + 5), &v14, v10 + 11))
  {
    v4 = 0x400000000000010;
    goto LABEL_27;
  }
  if (v14 == 0x2000000000000011)
  {
    if (!DERDecodeSeqInit((uint64_t)(v10 + 7), &v14, v10 + 13))
    {
      if (v14 == 0x2000000000000011)
      {
        v4 = 0;
        *(_BYTE *)v10 = 1;
        *a3 = v10;
        return v4;
      }
      goto LABEL_28;
    }
    v4 = 0x400000000000010;
LABEL_27:
    AMSupportLogInternal();
    goto LABEL_29;
  }
LABEL_28:
  AMSupportLogInternal();
  v4 = 0x400000000000040;
LABEL_29:
  if (!v9)
    free(v10);
  return v4;
}

uint64_t AMFDRDecodeIterateSysconfigPayloadNext(uint64_t a1, _BYTE *a2, _BYTE *a3, _QWORD *a4, _DWORD *a5, _BYTE *a6)
{
  uint64_t v6;
  _BYTE *v7;
  int v12;
  uint64_t v13;
  uint64_t i;
  int v16;
  int v17;
  BOOL v18;
  _OWORD v19[2];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  unint64_t v23;
  unint64_t v24[2];

  v23 = 0;
  v24[0] = 0;
  v24[1] = 0;
  v21 = 0u;
  v22 = 0u;
  v20 = 0u;
  memset(v19, 0, sizeof(v19));
  v6 = 1;
  v18 = 0;
  if (a3)
  {
    if (a1)
    {
      v7 = a2;
      if (a2)
      {
        if (a4 && a5)
        {
          if (!*(_BYTE *)a1)
            goto LABEL_27;
          v12 = DERDecodeSeqNext((unint64_t *)(a1 + 88), &v23);
          if (v12 == 1)
            return 0x40000000000000;
          if (v12 || v23 != 0x2000000000000010)
          {
            AMSupportLogInternal();
            return 0x400000000000040;
          }
          if (DERParseSequenceContentToObject(v24, 5u, (uint64_t)&DERSysconfigPayloadItemSpecs, (unint64_t)v19, 0x50uLL, 0))
          {
            v6 = 0x400000000000010;
            AMSupportLogInternal();
            return v6;
          }
          if (*((_QWORD *)&v19[0] + 1) != 4)
          {
            AMSupportLogInternal();
            return 0x400000000000020;
          }
          v13 = *(_QWORD *)&v19[0];
          for (i = 3; i != -1; --i)
            *v7++ = *(_BYTE *)(v13 + i);
          if (DERParseBooleanWithDefault((unsigned __int8 **)&v22, 0, &v18))
          {
LABEL_27:
            AMSupportLogInternal();
            return 0x400000000000000;
          }
          if (v18)
          {
            v6 = 0;
            *a3 = 1;
          }
          else
          {
            v16 = DWORD2(v21);
            if (*((_QWORD *)&v21 + 1))
            {
              *a4 = v21;
              *a5 = v16;
              v6 = 0;
              if (a6)
                *a6 = 1;
            }
            else
            {
              v6 = 0;
              v17 = DWORD2(v20);
              *a4 = v20;
              *a5 = v17;
            }
          }
        }
      }
    }
  }
  return v6;
}

uint64_t AMFDRDecodeIterateSysconfigMetadataNext(uint64_t a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, _DWORD *a5, _BYTE *a6)
{
  uint64_t v6;
  int v12;
  int v13;
  int v14;
  int v15;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  unint64_t v20;
  unint64_t v21[2];

  v20 = 0;
  v21[0] = 0;
  v21[1] = 0;
  v18 = 0u;
  v19 = 0u;
  v17 = 0u;
  v6 = 1;
  if (a1 && a2 && a3 && a4 && a5)
  {
    if (*(_BYTE *)a1)
    {
      v12 = DERDecodeSeqNext((unint64_t *)(a1 + 104), &v20);
      if (v12 == 1)
      {
        return 0x40000000000000;
      }
      else if (v12 || v20 != 0x2000000000000010)
      {
        AMSupportLogInternal();
        return 0x400000000000040;
      }
      else if (DERParseSequenceContentToObject(v21, 3u, (uint64_t)&DERSysconfigMetadataItemSpecs, (unint64_t)&v17, 0x30uLL, 0))
      {
        v6 = 0x400000000000010;
        AMSupportLogInternal();
      }
      else
      {
        v13 = DWORD2(v17);
        *a2 = v17;
        *a3 = v13;
        v14 = DWORD2(v19);
        if (*((_QWORD *)&v19 + 1))
        {
          *a4 = v19;
          *a5 = v14;
          v6 = 0;
          if (a6)
            *a6 = 1;
        }
        else
        {
          v6 = 0;
          v15 = DWORD2(v18);
          *a4 = v18;
          *a5 = v15;
        }
      }
    }
    else
    {
      AMSupportLogInternal();
      return 0x400000000000000;
    }
  }
  return v6;
}

uint64_t _AMFDRDecodeVerifyTrustObject(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v6;
  uint64_t v7;
  _OWORD __s2[3];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 1944);
  if (!v2)
  {
    AMSupportLogInternal();
    v4 = 0x200000;
    goto LABEL_5;
  }
  v3 = AMFDRDecodeTrustObject((_QWORD *)(a1 + 1768), v2, *(_DWORD *)(a1 + 1952));
  if (!v3)
  {
    if (!*(_QWORD *)(a1 + 72))
    {
      AMSupportLogInternal();
      v4 = 0x40000;
      goto LABEL_5;
    }
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __s2[1] = v6;
    __s2[2] = v6;
    __s2[0] = v6;
    v7 = *(_QWORD *)(a1 + 80);
    if (v7 == 48)
    {
      if (AMSupportDigestSha384())
      {
LABEL_15:
        AMSupportLogInternal();
        v4 = 0x100000;
        goto LABEL_5;
      }
    }
    else
    {
      if (v7 != 32)
      {
        AMSupportLogInternal();
        v4 = 0x80000;
        goto LABEL_5;
      }
      if (AMSupportDigestSha256())
        goto LABEL_15;
    }
    if (!memcmp(*(const void **)(a1 + 72), __s2, *(_QWORD *)(a1 + 80)))
      return 0;
    goto LABEL_15;
  }
  v4 = v3;
  AMSupportLogInternal();
LABEL_5:
  *(_QWORD *)a1 |= v4;
  return v4;
}

uint64_t _AMFDRDecodeFilterDataInstanceCallback(int a1, uint64_t a2, int a3, _WORD *a4)
{
  uint64_t PropertyData;
  uint64_t v7;

  if (!*(_QWORD *)a4)
  {
    AMSupportLogInternal();
    return 6;
  }
  if (!a2)
  {
    AMSupportLogInternal();
    **(_QWORD **)a4 |= 1uLL;
    return 6;
  }
  if (a1 != 1768846196)
    return 0;
  PropertyData = Img4DecodeGetPropertyData();
  if ((_DWORD)PropertyData)
  {
    v7 = PropertyData;
    AMSupportLogInternal();
    **(_QWORD **)a4 |= 0x4000uLL;
    return v7;
  }
  if (a3 != 1)
  {
    AMSupportLogInternal();
    return 0;
  }
  if ((_AMFDRDecodeInstPropertyMatchingWithType((_DWORD *)0xAAAAAAAAAAAAAAAALL, 0, *(void **)(*(_QWORD *)a4 + 104), *(_QWORD *)(*(_QWORD *)a4 + 112), *(const void **)(*(_QWORD *)a4 + 184), *(_QWORD *)(*(_QWORD *)a4 + 192), 1, *(_QWORD **)a4) & 1) != 0)
  {
    AMSupportLogInternal();
    v7 = 0;
    a4[4] = 1;
  }
  else
  {
    AMSupportLogInternal();
    v7 = 0;
    a4[4] = 256;
  }
  return v7;
}

uint64_t _AMFDRDecodeInstPropertyMatchingWithType(_DWORD *a1, unsigned int a2, void *__s2, size_t __n, const void *a5, size_t a6, int a7, _QWORD *a8)
{
  uint64_t v11;
  size_t v12;
  _DWORD *v13;
  uint64_t result;

  if (a8)
  {
    v11 = a8[252];
    if ((v11 & 0x100) != 0 && a8[19] && a8[20] && (!a7 || (v11 & 0x80) != 0))
    {
      a6 = 0;
      a5 = 0;
      __n = a8[20];
      __s2 = (void *)a8[19];
    }
  }
  if (a2 < 5 || *a1 != 762014067)
  {
    if (__n != a2 || memcmp(a1, __s2, __n))
    {
LABEL_16:
      AMSupportLogInternal();
      return 0;
    }
    return 1;
  }
  v12 = a2 - 4;
  if (__n >= v12)
    goto LABEL_16;
  v13 = a1 + 1;
  if (memcmp(a1 + 1, __s2, __n) || *((_BYTE *)v13 + __n) != 45)
    goto LABEL_16;
  result = 1;
  if (a6 && a5)
  {
    if (a6 != (_DWORD)v12 + ~(_DWORD)__n || memcmp((char *)v13 + __n + 1, a5, a6))
      goto LABEL_16;
    return 1;
  }
  return result;
}

uint64_t _AMFDRDecodeSearchEntryFromPropertyList(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  __int128 v6;
  uint64_t result;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  unint64_t v11;
  unint64_t v12[2];
  unint64_t v13[2];
  uint64_t v14;
  _QWORD v15[2];

  v15[0] = a1;
  v15[1] = a2;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9 = v6;
  v10 = v6;
  v14 = 0;
  v13[0] = 0;
  v13[1] = 0;
  v12[0] = 0;
  v12[1] = 0;
  v11 = 0;
  if (!DERDecodeSeqInit((uint64_t)v15, &v14, v13)
    && v14 == 0x2000000000000011
    && !DERDecodeSeqNext(v13, &v11))
  {
    do
    {
      v9 = 0u;
      v10 = 0u;
      if (DERParseSequenceContentToObject(v12, 2u, (uint64_t)&DERFDRItemSpecs, (unint64_t)&v9, 0x20uLL, 0))break;
      if (*((_QWORD *)&v9 + 1) == 4 && AMFDRTagsStringToTag((unsigned int *)v9) == a3)
      {
        if (a4)
        {
          result = 0;
          v8 = *((_QWORD *)&v10 + 1);
          *a4 = v10;
          a4[1] = v8;
        }
        else
        {
          AMSupportLogInternal();
          return 1;
        }
        return result;
      }
    }
    while (!DERDecodeSeqNext(v13, &v11));
  }
  AMSupportLogInternal();
  return 2;
}

uint64_t _AMFDRDecodeVerifyData(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t (**v12)();
  uint64_t (**v13)();
  unsigned __int16 *v14;
  int v15;
  int v16;
  BOOL v17;
  uint64_t (**v18)();
  uint64_t v19;
  int v20;
  int v21;

  v21 = 0;
  v2 = a1[252];
  if ((~*((_DWORD *)a1 + 504) & 0x1080) == 0)
    goto LABEL_63;
  if ((v2 & 0x80) != 0)
  {
    if (Img4DecodeInitManifest())
      goto LABEL_17;
LABEL_5:
    v2 = a1[252];
    goto LABEL_9;
  }
  v3 = a1[3];
  v4 = a1[4];
  if ((v2 & 0x1000) == 0)
  {
    if (Img4DecodeInit())
      goto LABEL_17;
    goto LABEL_5;
  }
  a1[106] = 0;
  *((_OWORD *)a1 + 51) = 0u;
  *((_OWORD *)a1 + 52) = 0u;
  *((_OWORD *)a1 + 49) = 0u;
  *((_OWORD *)a1 + 50) = 0u;
  *((_OWORD *)a1 + 47) = 0u;
  *((_OWORD *)a1 + 48) = 0u;
  *((_OWORD *)a1 + 45) = 0u;
  *((_OWORD *)a1 + 46) = 0u;
  *((_OWORD *)a1 + 43) = 0u;
  *((_OWORD *)a1 + 44) = 0u;
  *((_OWORD *)a1 + 41) = 0u;
  *((_OWORD *)a1 + 42) = 0u;
  *((_OWORD *)a1 + 39) = 0u;
  *((_OWORD *)a1 + 40) = 0u;
  *((_OWORD *)a1 + 37) = 0u;
  *((_OWORD *)a1 + 38) = 0u;
  *((_OWORD *)a1 + 35) = 0u;
  *((_OWORD *)a1 + 36) = 0u;
  *((_OWORD *)a1 + 33) = 0u;
  *((_OWORD *)a1 + 34) = 0u;
  *((_OWORD *)a1 + 31) = 0u;
  *((_OWORD *)a1 + 32) = 0u;
  *((_OWORD *)a1 + 29) = 0u;
  *((_OWORD *)a1 + 30) = 0u;
  *((_OWORD *)a1 + 27) = 0u;
  *((_OWORD *)a1 + 28) = 0u;
  *((_OWORD *)a1 + 25) = 0u;
  *((_OWORD *)a1 + 26) = 0u;
  a1[51] = v3;
  a1[52] = v4;
  a1[61] = (uint64_t)"IM4P";
  a1[62] = 4;
  a1[67] = v3;
  a1[68] = v4;
LABEL_9:
  v5 = a1[35];
  if ((v2 & 0x1000) != 0)
  {
    if (v5)
      goto LABEL_16;
LABEL_63:
    AMSupportLogInternal();
    result = *a1 | 1;
    goto LABEL_34;
  }
  if (!v5)
  {
    if ((v2 & 0x1000) == 0)
      goto LABEL_12;
LABEL_20:
    v21 = AMFDRTagsStringToTag((unsigned int *)a1[11]);
    goto LABEL_21;
  }
LABEL_16:
  *(_OWORD *)(a1 + 53) = *(_OWORD *)(a1 + 35);
  if (DERImg4DecodeManifest())
  {
LABEL_17:
    AMSupportLogInternal();
    v6 = *a1;
    v7 = 83901440;
LABEL_18:
    result = v6 | v7;
    *a1 = v6 | v7;
    v9 = a1[4];
    a1[239] = a1[3];
    a1[240] = v9;
    return result;
  }
  v2 = a1[252];
  if ((v2 & 0x1000) != 0)
    goto LABEL_20;
LABEL_12:
  if ((v2 & 0x80) == 0)
  {
    if (Img4DecodeGetPayloadType())
      goto LABEL_17;
    if (a1[66] != 3
      || ((v14 = (unsigned __int16 *)a1[65], v15 = *v14, v16 = *((unsigned __int8 *)v14 + 2), v15 == 11825)
        ? (v17 = v16 == 48)
        : (v17 = 0),
          !v17))
    {
      AMSupportLogInternal();
      v6 = *a1;
      v7 = 0x8005001C00;
      goto LABEL_18;
    }
  }
LABEL_21:
  v10 = (unsigned int *)a1[11];
  if (v10 && ((unint64_t)(a1[12] - 3) >= 2 || AMFDRTagsStringToTag(v10) != v21))
  {
    AMSupportLogInternal();
    result = *a1 | 0x100000004000C00;
LABEL_34:
    *a1 = result;
    return result;
  }
  v11 = *a1;
  if ((a1[252] & 0x80) != 0)
  {
    if (!Img4DecodePerformManifestTrustEvaluationWithCallbacks())
      goto LABEL_56;
  }
  else if (!Img4DecodePerformTrustEvaluationWithCallbacks())
  {
    goto LABEL_56;
  }
  if ((*a1 & 0x1000000000000) == 0)
  {
LABEL_51:
    AMSupportLogInternal();
    if (!*a1)
      *a1 = 0x100000000000;
    goto LABEL_58;
  }
  v12 = (uint64_t (**)())a1[251];
  if (v12 == kAMFDRDecodeImplementationSha1)
  {
    v13 = kAMFDRDecodeImplementationSha384;
    goto LABEL_42;
  }
  if (v12 == kAMFDRDecodeImplementationSha384)
  {
    v13 = kAMFDRDecodeImplementationSha1;
LABEL_42:
    a1[251] = (uint64_t)v13;
    AMSupportLogInternal();
  }
  v18 = (uint64_t (**)())a1[251];
  if (v18 != kAMFDRDecodeImplementationSha1 && v18 != kAMFDRDecodeImplementationSha384)
    goto LABEL_51;
  v19 = *a1;
  *a1 = v11;
  *((_BYTE *)a1 + 400) = 0;
  if ((a1[252] & 0x80) != 0)
    v20 = Img4DecodePerformManifestTrustEvaluationWithCallbacks();
  else
    v20 = Img4DecodePerformTrustEvaluationWithCallbacks();
  if (v20)
  {
    AMSupportLogInternal();
    *a1 = v19;
    goto LABEL_51;
  }
  if ((a1[252] & 0x20) != 0)
  {
    AMSupportLogInternal();
    *a1 |= 0x2000000000000uLL;
  }
  else
  {
    AMSupportLogInternal();
  }
LABEL_56:
  if (*((_BYTE *)a1 + 401))
    *((_BYTE *)a1 + 2032) = 1;
LABEL_58:
  if ((*((_BYTE *)a1 + 2017) & 0x10) != 0)
  {
    result = *a1;
    if (!*((_BYTE *)a1 + 376))
    {
      result |= 0x1000000000000000uLL;
      *a1 = result;
    }
  }
  else
  {
    result = *a1;
  }
  a1[239] = a1[67];
  a1[240] = a1[68];
  return result;
}

uint64_t _AMFDRDecodeMultiCombined(uint64_t a1)
{
  __int128 v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  int v6;
  char v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  size_t v12;
  uint64_t v13;
  void *__s1[2];
  __int128 v15;
  size_t v16[2];
  size_t __n[2];
  unint64_t v18[3];
  int v19;
  unint64_t v20;
  unsigned int v21;
  _QWORD v22[2];
  unint64_t v23;
  unint64_t v24[2];
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  unint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  v22[0] = 0xAAAAAAAAAAAAAAAALL;
  v22[1] = 0xAAAAAAAAAAAAAAAALL;
  v56 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v54 = v2;
  v55 = v2;
  v52 = v2;
  v53 = v2;
  v50 = v2;
  v51 = v2;
  v48 = v2;
  v49 = v2;
  v46 = v2;
  v47 = v2;
  v44 = v2;
  v45 = v2;
  v42 = v2;
  v43 = v2;
  v40 = v2;
  v41 = v2;
  v38 = v2;
  v39 = v2;
  v36 = v2;
  v37 = v2;
  v34 = v2;
  v35 = v2;
  v32 = v2;
  v33 = v2;
  v30 = v2;
  v31 = v2;
  v28 = v2;
  v29 = v2;
  v21 = 0;
  v20 = 0xAAAAAAAAAAAAAAAALL;
  v19 = 0;
  memset(v18, 170, sizeof(v18));
  *(_OWORD *)v16 = v2;
  *(_OWORD *)__n = v2;
  *(_OWORD *)__s1 = v2;
  v15 = v2;
  v26 = 0;
  v27 = 0;
  v24[1] = 0;
  v25 = 0;
  v23 = 0;
  v24[0] = 0;
  if (DERDecodeItem(a1 + 24, &v25))
  {
    AMSupportLogInternal();
    *(_QWORD *)a1 |= 0x80uLL;
    return 128;
  }
  if (v25 != 0x2000000000000010)
  {
    AMSupportLogInternal();
    *(_QWORD *)a1 |= 0x10000uLL;
    return 0x10000;
  }
  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 32);
  if (v4 + v5 < (unint64_t)(v26 + v27))
  {
    AMSupportLogInternal();
    *(_QWORD *)a1 |= 4uLL;
    return 4;
  }
  if (v4 + v5 > (unint64_t)(v26 + v27))
  {
    AMSupportLogInternal();
    *(_QWORD *)a1 |= 8uLL;
    return 8;
  }
  v6 = Img4DecodeInit();
  if (v6 || Img4DecodeGetManifest() || Img4DecodeGetPayloadType())
    goto LABEL_13;
  if (v19 != AMFDRTagsStringToTag((unsigned int *)"mcmb"))
    goto LABEL_17;
  if (Img4DecodeGetPayload())
  {
LABEL_13:
    AMSupportLogInternal();
    return 0x2000;
  }
  if (DERDecodeSeqInit((uint64_t)v22, &v18[2], v18) || v18[2] != 0x2000000000000011)
  {
LABEL_17:
    AMSupportLogInternal();
    return 0x20000;
  }
  if (*(_QWORD *)(a1 + 104) && *(_QWORD *)(a1 + 112))
  {
    v7 = 0;
  }
  else
  {
    if ((*(_BYTE *)(a1 + 2017) & 0x20) == 0)
    {
      AMSupportLogInternal();
      return 1;
    }
    v7 = 1;
  }
  if (DERDecodeSeqNext(v18, &v23))
    goto LABEL_53;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  while (1)
  {
    while (1)
    {
      *(_OWORD *)v16 = 0u;
      *(_OWORD *)__n = 0u;
      *(_OWORD *)__s1 = 0u;
      v15 = 0u;
      if (DERParseSequenceContentToObject(v24, 4u, (uint64_t)&DERFDRMultiCombinedItemSpecs, (unint64_t)__s1, 0x40uLL, 0))goto LABEL_17;
      if (__s1[1] != *(void **)(a1 + 96)
        || memcmp(__s1[0], *(const void **)(a1 + 88), (size_t)__s1[1])
        || (v7 & 1) == 0
        && (v16[1] != *(_QWORD *)(a1 + 112) || memcmp((const void *)v16[0], *(const void **)(a1 + 104), v16[1]))
        || __n[1] != *(_QWORD *)(a1 + 128))
      {
        goto LABEL_30;
      }
      v11 = *(const void **)(a1 + 120);
      if (__n[0])
        break;
      if (!v11)
        goto LABEL_42;
LABEL_30:
      if (DERDecodeSeqNext(v18, &v23))
      {
        if ((v8 & 1) == 0)
          goto LABEL_53;
        goto LABEL_47;
      }
    }
    if (!v11 || memcmp((const void *)__n[0], v11, __n[1]))
      goto LABEL_30;
LABEL_42:
    if ((v7 & 1) == 0)
    {
      AMSupportLogInternal();
      v9 = *((_QWORD *)&v15 + 1);
      v10 = v15;
LABEL_47:
      result = 0;
      v13 = v21;
      *(_QWORD *)(a1 + 280) = v20;
      *(_QWORD *)(a1 + 288) = v13;
      *(_QWORD *)(a1 + 24) = v10;
      *(_QWORD *)(a1 + 32) = v9;
      return result;
    }
    if ((v8 & 1) != 0)
      break;
    v12 = v16[1];
    *(_QWORD *)(a1 + 104) = v16[0];
    *(_QWORD *)(a1 + 112) = v12;
    AMSupportLogInternal();
    v9 = *((_QWORD *)&v15 + 1);
    v10 = v15;
    v8 = 1;
    if (DERDecodeSeqNext(v18, &v23))
      goto LABEL_47;
  }
  AMSupportLogInternal();
  *(_QWORD *)a1 |= 0x4000uLL;
LABEL_53:
  AMSupportLogInternal();
  return 512;
}

uint64_t _AMFDRDecodeVerifySignatureDataWithOid(const void *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, uint64_t a9, char a10, _QWORD *a11)
{
  uint64_t result;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  size_t v18;
  const void *v19;
  unint64_t v20;
  __int128 v21;
  _OWORD v22[3];
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v22[0] = a7;
  *((_QWORD *)&v22[0] + 1) = a8;
  if (DEROidCompare((uint64_t)v22, (uint64_t)&oidSha1Rsa))
  {
    memset(&v22[1], 170, 20);
    if (AMSupportDigestSha1())
      return 0xFFFFFFFFLL;
    result = AMSupportRsaVerifySignatureSha1();
    if (!a11)
      goto LABEL_36;
LABEL_33:
    if ((_DWORD)result != 2)
      goto LABEL_36;
    *a11 |= 0x80000000000000uLL;
    return 0xFFFFFFFFLL;
  }
  if (DEROidCompare((uint64_t)v22, (uint64_t)&oidSha256Rsa))
  {
    *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v22[1] = v14;
    v22[2] = v14;
    if (AMSupportDigestSha256())
      return 0xFFFFFFFFLL;
    result = AMSupportRsaVerifySignatureSha256();
    if (a11)
      goto LABEL_33;
    goto LABEL_36;
  }
  if (!DEROidCompare((uint64_t)v22, (uint64_t)&oidSha384Rsa))
  {
    if (DEROidCompare((uint64_t)v22, (uint64_t)&oidSha256Ecdsa))
    {
      *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v22[1] = v16;
      v22[2] = v16;
      v20 = 0;
      v21 = 0uLL;
      if (a9)
      {
        if (!a10)
        {
          if (DERDecodeItem(a9, &v20))
            return 0xFFFFFFFFLL;
          goto LABEL_26;
        }
        if (*(_QWORD *)(a9 + 8))
        {
          v21 = *(_OWORD *)a9;
LABEL_26:
          if (AMSupportDigestSha256())
            return 0xFFFFFFFFLL;
          v18 = a2;
          v19 = a1;
          goto LABEL_32;
        }
LABEL_38:
        AMSupportLogInternal();
        return 6;
      }
    }
    else
    {
      if (!DEROidCompare((uint64_t)v22, (uint64_t)&oidSha384Ecdsa))
        return 4;
      *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v22[2] = v17;
      v23 = v17;
      v22[1] = v17;
      v20 = 0;
      v21 = 0uLL;
      if (a9)
      {
        if (a10)
        {
          if (!*(_QWORD *)(a9 + 8))
            goto LABEL_38;
          v21 = *(_OWORD *)a9;
        }
        else if (DERDecodeItem(a9, &v20))
        {
          return 0xFFFFFFFFLL;
        }
        if (AMSupportDigestSha384())
          return 0xFFFFFFFFLL;
        v18 = a2;
        v19 = a1;
LABEL_32:
        result = AMFDRDecodeEcdsaVerifySignature(v19, v18);
        if (!a11)
          goto LABEL_36;
        goto LABEL_33;
      }
    }
    AMSupportLogInternal();
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v22[2] = v15;
  v23 = v15;
  v22[1] = v15;
  if (AMSupportDigestSha384())
    return 0xFFFFFFFFLL;
  result = AMSupportRsaVerifySignatureSha384();
  if (a11)
    goto LABEL_33;
LABEL_36:
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t AMFDRDecodeEcdsaVerifySignature(const void *a1, size_t a2)
{
  uint64_t result;
  _BYTE *v5;
  void *v6;
  uint64_t v7;

  result = 1;
  if (a1 && a2)
  {
    if ((a2 & 1) != 0)
    {
      return AMSupportEcDsaVerifySignature();
    }
    else
    {
      v5 = malloc_type_malloc(a2 + 1, 0x98214BB1uLL);
      if (v5)
      {
        v6 = v5;
        *v5 = 4;
        memcpy(v5 + 1, a1, a2);
        v7 = AMSupportEcDsaVerifySignature();
        free(v6);
        return v7;
      }
      else
      {
        return 2;
      }
    }
  }
  return result;
}

uint64_t _AMFDRDecodeSequenceString(unint64_t a1, unint64_t a2, _OWORD *a3)
{
  unint64_t *v4;
  uint64_t v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  unint64_t v17;
  __int128 v18;
  unint64_t v19[2];
  unint64_t v20[2];

  v20[0] = a1;
  v20[1] = a2;
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v18 = 0uLL;
  v17 = 0;
  v19[0] = 0;
  v19[1] = 0;
  v15 = 0u;
  v16 = 0u;
  if (a3)
  {
    a3[14] = 0uLL;
    a3[15] = 0uLL;
    a3[12] = 0uLL;
    a3[13] = 0uLL;
    a3[10] = 0uLL;
    a3[11] = 0uLL;
    a3[8] = 0uLL;
    a3[9] = 0uLL;
    a3[6] = 0uLL;
    a3[7] = 0uLL;
    a3[4] = 0uLL;
    a3[5] = 0uLL;
    a3[2] = 0uLL;
    a3[3] = 0uLL;
    *a3 = 0uLL;
    a3[1] = 0uLL;
    v4 = DERDecodeSeqContentInit(v20, v19);
    if ((_DWORD)v4)
    {
      v12 = (uint64_t)v4;
    }
    else
    {
      v5 = 0;
      v6 = 255;
      while (1)
      {
        do
        {
          while (1)
          {
            v7 = DERDecodeSeqNext(v19, &v17);
            if ((_DWORD)v7)
            {
              v12 = v7;
              if ((_DWORD)v7 != 1)
                goto LABEL_26;
              return 0;
            }
            v14 = v18;
            if (v17 == 0x2000000000000011)
              break;
            AMSupportLogInternal();
          }
          v15 = 0u;
          v16 = 0u;
          v8 = DERParseSequenceToObject((uint64_t)&v14, (unsigned __int16)DERNumAttributeTypeAndValueItemSpecs, (uint64_t)&DERAttributeTypeAndValueItemSpecs, (unint64_t)&v15, 0x20uLL, 0);
          if ((_DWORD)v8)
          {
            v12 = v8;
            goto LABEL_26;
          }
        }
        while (!(_QWORD)v16);
        v14 = v16;
        v18 = 0uLL;
        v17 = 0;
        v9 = DERDecodeItem((uint64_t)&v14, &v17);
        if ((_DWORD)v9)
          break;
        if (v17 == 19 || v17 == 12)
        {
          if (v5)
          {
            if (!v6)
              return 0;
            *((_BYTE *)a3 + v5++) = 32;
            --v6;
          }
          v10 = (char *)a3 + v5;
          v11 = *((_QWORD *)&v18 + 1);
          if (v6 < *((_QWORD *)&v18 + 1))
          {
            memcpy(v10, (const void *)v18, v6);
            return 0;
          }
          v6 -= *((_QWORD *)&v18 + 1);
          memcpy(v10, (const void *)v18, *((size_t *)&v18 + 1));
          v5 += v11;
        }
      }
      v12 = v9;
    }
  }
  else
  {
    v12 = 3;
  }
LABEL_26:
  AMSupportLogInternal();
  return v12;
}

uint64_t AMFDRDecodeDigestByLength(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 == 48)
    return AMSupportDigestSha384();
  if (a4 == 32)
    return AMSupportDigestSha256();
  return 1;
}

uint64_t AMFDRSealingMapSetMGCopyAnswer()
{
  return AMSupportLogInternal();
}

uint64_t AMFDRSealingMapSetKeyQueryRetry(uint64_t result)
{
  gKeyQueryRetry = result;
  return result;
}

uint64_t CFArrayRetainAllowNULLCallBack(uint64_t a1, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(void))(MEMORY[0x24BDBD690] + 8))();
  else
    return 0;
}

uint64_t CFArrayReleaseAllowNULLCallBack(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(void))(MEMORY[0x24BDBD690] + 16))();
  return result;
}

const __CFString *CFArrayCopyDescriptionAllowNULLCallBack(uint64_t a1)
{
  if (a1)
    return (const __CFString *)(*(uint64_t (**)(void))(MEMORY[0x24BDBD690] + 24))();
  else
    return &stru_24C6A3418;
}

uint64_t CFArrayEqualAllowNULLCallBack()
{
  return (*(uint64_t (**)(void))(MEMORY[0x24BDBD690] + 32))();
}

const __CFString *AMFDRSealingMapCallMGCopyAnswer(const __CFString *a1, uint64_t a2)
{
  return AMFDRSealingMapCallMGCopyAnswerInternal(a1, a2, 0);
}

const __CFString *AMFDRSealingMapCallMGCopyAnswerInternal(CFStringRef theString, uint64_t a2, uint64_t a3)
{
  const __CFAllocator *v6;
  CFIndex Length;
  CFIndex v8;
  CFStringRef v9;
  CFStringRef v10;
  uint64_t v11;
  unsigned int v12;
  const __CFString *v13;
  int v14;
  int v15;
  BOOL v16;
  unsigned int v17;
  BOOL v18;
  int v21;
  CFTypeID v22;
  CFNumberRef v23;
  CFNumberRef v24;
  CFDictionaryRef v25;
  uint64_t (*ZhuGeCopyValueWithErrorSymbolLoc)(CFStringRef, uint64_t, int *);
  const __CFString *v27;
  const __CFString *format;
  char v30;
  int v31;
  uint64_t v32;
  int v33;
  int valuePtr;
  void *values[2];
  void *keys[2];
  uint64_t v37;
  CFRange v38;

  v37 = *MEMORY[0x24BDAC8D0];
  if (!theString || !CFStringHasPrefix(theString, CFSTR("ZG:")))
  {
    v32 = 0;
    v31 = -1;
    goto LABEL_11;
  }
  v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Length = CFStringGetLength(CFSTR("ZG:"));
  v8 = CFStringGetLength(theString);
  v38.length = v8 - CFStringGetLength(CFSTR("ZG:"));
  v38.location = Length;
  v9 = CFStringCreateWithSubstring(v6, theString, v38);
  v32 = 0;
  v31 = -1;
  if (!v9)
  {
LABEL_11:
    v12 = 0;
    do
    {
      v13 = (const __CFString *)MGCopyAnswerWithError();
      v14 = gKeyQueryRetry;
      v15 = v31;
      if (gKeyQueryRetry)
        v16 = v31 == 12;
      else
        v16 = 0;
      if (v16)
      {
        usleep(0x3D090u);
        v14 = gKeyQueryRetry;
        v15 = v31;
      }
      v17 = v12 + 1;
      if (v14)
        v18 = v15 == 12;
      else
        v18 = 0;
    }
    while (v18 && v13 == 0 && v12++ < 0x14);
    v10 = 0;
    v21 = 1;
    if (!v13)
      goto LABEL_55;
    goto LABEL_30;
  }
  v10 = v9;
  if (gKeyQueryRetry)
  {
    if (_isAppleDeviceQueryFrameworkAvailable_onceToken != -1)
      dispatch_once(&_isAppleDeviceQueryFrameworkAvailable_onceToken, &__block_literal_global_845);
    if (_isAppleDeviceQueryFrameworkAvailable_isAvailable == 1 && MEMORY[0x24BE06038])
    {
      v11 = ZhuGeCopyValue();
LABEL_53:
      v13 = (const __CFString *)v11;
      goto LABEL_54;
    }
    if (_isZhuGeLegacyAvailable_onceToken != -1)
      dispatch_once(&_isZhuGeLegacyAvailable_onceToken, &__block_literal_global_848);
    if (_isZhuGeLegacyAvailable_isAvailable)
    {
      ZhuGeCopyValueWithErrorSymbolLoc = (uint64_t (*)(CFStringRef, uint64_t, int *))getZhuGeCopyValueWithErrorSymbolLoc();
      if (!ZhuGeCopyValueWithErrorSymbolLoc)
        AMFDRSealingMapCallMGCopyAnswerInternal_cold_1();
      v11 = ZhuGeCopyValueWithErrorSymbolLoc(v10, a2, &v31);
      goto LABEL_53;
    }
    format = CFSTR("ZhuGeCopyValueWithError symbol is not supported");
LABEL_63:
    AMFDRErrorPushInternal(a3, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCallMGCopyAnswerInternal", format, v30);
LABEL_64:
    v13 = 0;
LABEL_65:
    CFRelease(v10);
    goto LABEL_66;
  }
  if (_isAppleDeviceQueryFrameworkAvailable_onceToken != -1)
    dispatch_once(&_isAppleDeviceQueryFrameworkAvailable_onceToken, &__block_literal_global_845);
  if (_isAppleDeviceQueryFrameworkAvailable_isAvailable != 1 || !MEMORY[0x24BE06038])
  {
    format = CFSTR("ZhuGeCopyValue symbol is not supported");
    goto LABEL_63;
  }
  v33 = 250;
  valuePtr = 0;
  v23 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
  v24 = CFNumberCreate(v6, kCFNumberSInt32Type, &v33);
  if (v23 && v24)
  {
    *(_OWORD *)keys = xmmword_24C69F1A8;
    values[0] = v23;
    values[1] = v24;
    v25 = CFDictionaryCreate(v6, (const void **)keys, (const void **)values, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  }
  else
  {
    AMSupportLogInternal();
    v25 = 0;
  }
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (!v25)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCallMGCopyAnswerInternal", CFSTR("_createZhuGePreferences failed"), v30);
    goto LABEL_64;
  }
  v13 = (const __CFString *)ZhuGeCopyValue();
  AMSupportSafeRelease();
LABEL_54:
  v21 = 0;
  v17 = 0;
  if (!v13)
  {
LABEL_55:
    if (v21)
    {
      if (v17 <= 0x13)
        v27 = CFSTR("failed");
      else
        v27 = CFSTR("timed out waiting");
      AMFDRErrorPushInternal(a3, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCallMGCopyAnswerInternal", CFSTR("AMFDRSealingMapCallMGCopyAnswer %@ for %@, error=%d."), (char)v27);
      v13 = 0;
      goto LABEL_66;
    }
    if (gKeyQueryRetry)
      AMFDRErrorPushInternal((uint64_t)&v32, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCallMGCopyAnswerInternal", CFSTR("ZhuGeCopyValueWithError failed: %d"), v31);
    v30 = (char)theString;
    format = CFSTR("AMFDRSealingMapCallMGCopyAnswer failed for %@, error=%@.");
    goto LABEL_63;
  }
LABEL_30:
  if (v17 >= 2 && !v31)
    AMSupportLogInternal();
  v22 = CFGetTypeID(v13);
  if (v22 == CFStringGetTypeID() && (!CFStringGetLength(v13) || !CFStringGetCharacterAtIndex(v13, 0)))
  {
    AMFDRErrorPushInternal(a3, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCallMGCopyAnswerInternal", CFSTR("AMFDRSealingMapCallMGCopyAnswer received empty string for %@"), (char)theString);
    CFRelease(v13);
    v13 = 0;
  }
  if ((v21 & 1) == 0)
    goto LABEL_65;
LABEL_66:
  AMSupportSafeRelease();
  return v13;
}

void AMFDRSetSealingMap(CFTypeRef cf)
{
  if (gSealingMap)
  {
    CFRelease((CFTypeRef)gSealingMap);
    gSealingMap = 0;
  }
  if (cf)
    gSealingMap = (uint64_t)CFRetain(cf);
}

uint64_t AMFDRGetSealingMap()
{
  uint64_t result;

  result = gSealingMap;
  if (!gSealingMap)
  {
    if (sealingMapCacheQueue_onceToken != -1)
      dispatch_once(&sealingMapCacheQueue_onceToken, &__block_literal_global_860);
    dispatch_sync((dispatch_queue_t)sealingMapCacheQueue_sealingMapCacheQueue, &__block_literal_global_1);
    return fileSystemSealingMap;
  }
  return result;
}

uint64_t copyFDRSealingMapFromFilesystem()
{
  const __CFAllocator *v0;
  CFURLRef v1;

  v0 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v1 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("/System/Library/FDR/FDRSealingMap.plist"), kCFURLPOSIXPathStyle, 0);
  if (AMSupportCreateDictionaryFromFileURL())
  {
    AMSupportLogInternal();
    if (v1)
      CFRelease(v1);
    v1 = CFURLCreateWithFileSystemPath(v0, CFSTR("/usr/lib/FDRSealingMap.plist"), kCFURLPOSIXPathStyle, 0);
    AMSupportCreateDictionaryFromFileURL();
  }
  AMSupportLogInternal();
  if (v1)
    CFRelease(v1);
  return 0;
}

uint64_t CFDictionaryValueRetainAllowNULLCallBack(uint64_t a1, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(void))(MEMORY[0x24BDBD690] + 8))();
  else
    return 0;
}

uint64_t CFDictionaryValueReleaseAllowNULLCallBack(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(void))(MEMORY[0x24BDBD690] + 16))();
  return result;
}

const __CFString *CFDictionaryValueCopyDescriptionAllowNULLCallBack(uint64_t a1)
{
  if (a1)
    return (const __CFString *)(*(uint64_t (**)(void))(MEMORY[0x24BDBD690] + 24))();
  else
    return &stru_24C6A3418;
}

uint64_t CFDictionaryValueEqualAllowNULLCallBack(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
    return (*(uint64_t (**)(void))(MEMORY[0x24BDBD690] + 32))();
  else
    return (a1 | a2) == 0;
}

uint64_t AMFDRSetRecoveryVerifier(uint64_t result)
{
  gRecoveryVerifier = result;
  return result;
}

CFStringRef AMFDRSealingMapCopyDataInstanceForSealingMapEntry(const __CFAllocator *a1, const void *a2, const __CFDictionary *a3, uint64_t a4)
{
  return _copyIdentifierListForSealingMapEntry(a1, a2, a3, 0, 0, a4);
}

CFStringRef _copyIdentifierListForSealingMapEntry(const __CFAllocator *a1, CFTypeRef cf, const __CFDictionary *a3, int a4, int a5, uint64_t a6)
{
  CFTypeID v11;
  const void *Value;
  const void *v13;
  CFMutableArrayRef Mutable;
  __CFArray *v15;
  CFTypeID v16;
  CFIndex v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFDictionary *v21;
  const void *v22;
  CFTypeID v23;
  CFIndex v24;
  CFIndex v25;
  const __CFString *v26;
  const __CFString *String;
  const __CFString *v28;
  __CFString *v29;
  __CFString *v30;
  const __CFString *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const __CFString *v35;
  const void *v36;
  CFTypeID v38;
  CFIndex Count;
  CFIndex v40;
  CFIndex v41;
  CFMutableStringRef MutableCopy;
  const __CFString *ValueAtIndex;
  const __CFString *v44;
  const __CFString *format;
  const __CFString *v46;
  const __CFString *v47;
  const __CFString *v48;
  char v49;
  const __CFString *v50;
  const __CFString *v51;
  CFIndex v53;
  CFIndex v54;
  int v55;

  v11 = CFGetTypeID(cf);
  if (v11 != CFDictionaryGetTypeID())
  {
    v46 = CFSTR("Value in sealing map has wrong type");
LABEL_99:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", v46, (char)v48);
    return 0;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("MultiDataInstanceIdentifierList"));
  if (!Value)
  {
    if ((a4 & 1) != 0)
    {
      v32 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AssemblyIdentifierList"));
      v33 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AsidSubCCIdentifierList"));
      v34 = v33;
      if (v32)
      {
        if (v33 || (v34 = v32, CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AsidSubCCIdOptionalVerifyList"))))
        {
          v50 = CFSTR("AssemblyIdentifierList");
LABEL_102:
          AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", CFSTR("Both '%@' and '%@' exist in sealing map entry "), (char)v50);
          return 0;
        }
      }
      else
      {
        if (!v33 && a5)
          v34 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AsidSubCCIdOptionalVerifyList"));
        if (!v34)
          return CFStringCreateWithCString(a1, "", 0x8000100u);
      }
LABEL_49:
      v38 = CFGetTypeID(v34);
      if (v38 == CFArrayGetTypeID())
      {
        v55 = a4;
        Count = CFArrayGetCount((CFArrayRef)v34);
        if (Count >= 1)
        {
          v40 = Count;
          v41 = 0;
          MutableCopy = 0;
          v51 = CFSTR("Could not create dataInstanceListString");
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v34, v41);
            v44 = ValueAtIndex;
            if (a3)
            {
              if (CFDictionaryContainsKey(a3, ValueAtIndex))
              {
                v20 = (const __CFString *)_CFDictionaryCopyValue(a3, v44);
                AMSupportLogInternal();
                if (!v20)
                  goto LABEL_86;
              }
              else
              {
                v20 = AMFDRSealingMapCallMGCopyAnswerInternal(v44, 0, a6);
                CFDictionaryAddValue(a3, v44, v20);
                if (!v20)
                {
LABEL_86:
                  AMFDRErrorPushInternal(a6, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", CFSTR("Could not query MobileGestalt for key '%@'"), (char)v44);
                  String = 0;
                  v15 = 0;
                  if (MutableCopy)
                    goto LABEL_77;
                  goto LABEL_78;
                }
              }
            }
            else
            {
              v20 = AMFDRSealingMapCallMGCopyAnswerInternal(ValueAtIndex, 0, a6);
              if (!v20)
                goto LABEL_86;
            }
            String = AMFDRDataCreateString(a1, v20, v55 ^ 1u);
            if (!String)
            {
              AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", CFSTR("Could not get data instance string for identifier '%@'"), (char)v20);
              v15 = 0;
              goto LABEL_76;
            }
            if (MutableCopy)
            {
              CFStringAppend(MutableCopy, CFSTR("-"));
              CFStringAppend(MutableCopy, String);
            }
            else
            {
              MutableCopy = CFStringCreateMutableCopy(a1, 0, String);
              if (!MutableCopy)
              {
                v15 = 0;
LABEL_90:
                AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", v51, (char)v48);
                CFRelease(v20);
                CFRelease(String);
LABEL_91:
                String = 0;
                goto LABEL_78;
              }
            }
            CFRelease(v20);
            CFRelease(String);
            if (v40 == ++v41)
            {
              if ((v55 & 1) != 0 || CFStringGetLength(MutableCopy) < 211)
              {
                String = (const __CFString *)CFRetain(MutableCopy);
                v15 = 0;
              }
              else
              {
                AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", CFSTR("Instance %@ is too long"), (char)MutableCopy);
                v15 = 0;
                String = 0;
              }
              goto LABEL_77;
            }
          }
        }
        v48 = CFSTR("DataInstanceIdentifierList");
        v46 = CFSTR("Missing value for key '%@' or %@' or %@' in sealing map entry ");
      }
      else
      {
        v48 = CFSTR("DataInstanceIdentifierList");
        v46 = CFSTR("Value in key '%@' or %@' or %@' has wrong type");
      }
      goto LABEL_99;
    }
    v35 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("DataInstanceIdentifier"));
    v36 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("DataInstanceIdentifierList"));
    v34 = v36;
    if (v35)
    {
      if (v36)
      {
        v50 = CFSTR("DataInstanceIdentifier");
        goto LABEL_102;
      }
      if (a3)
      {
        if (CFDictionaryContainsKey(a3, v35))
        {
          v20 = (const __CFString *)_CFDictionaryCopyValue(a3, v35);
          AMSupportLogInternal();
        }
        else
        {
          v20 = AMFDRSealingMapCallMGCopyAnswerInternal(v35, 0, a6);
          CFDictionaryAddValue(a3, v35, v20);
        }
      }
      else
      {
        v20 = AMFDRSealingMapCallMGCopyAnswerInternal(v35, 0, a6);
      }
      if (v20)
      {
        String = AMFDRCreateInstanceString(a1, v20);
        if (!String)
          AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", CFSTR("Could not get data instance string for identifier '%@'"), (char)v20);
        v15 = 0;
LABEL_75:
        MutableCopy = 0;
LABEL_76:
        CFRelease(v20);
        if (MutableCopy)
LABEL_77:
          CFRelease(MutableCopy);
LABEL_78:
        if (!v15)
          return String;
        goto LABEL_79;
      }
      AMFDRErrorPushInternal(a6, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", CFSTR("Could not query MobileGestalt for key '%@'"), (char)v35);
    }
    else
    {
      if (v36)
        goto LABEL_49;
      AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", CFSTR("'%@', '%@', '%@', '%@', '%@' not exists in sealing map entry"), (char)CFSTR("DataInstanceIdentifier"));
    }
    return 0;
  }
  v13 = Value;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    v46 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_99;
  }
  v15 = Mutable;
  v16 = CFGetTypeID(v13);
  if (v16 == CFArrayGetTypeID())
  {
    v53 = CFArrayGetCount((CFArrayRef)v13);
    if (v53 >= 1)
    {
      v17 = 0;
      v54 = 0;
      v51 = CFSTR("Could not createdataInstanceListString");
      while (1)
      {
        v18 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v13, v17);
        v19 = v18;
        if (a3)
        {
          if (CFDictionaryContainsKey(a3, v18))
          {
            v20 = (const __CFString *)_CFDictionaryCopyValue(a3, v19);
            AMSupportLogInternal();
            if (!v20)
              goto LABEL_83;
          }
          else
          {
            v20 = AMFDRSealingMapCallMGCopyAnswerInternal(v19, 0, a6);
            CFDictionaryAddValue(a3, v19, v20);
            if (!v20)
            {
LABEL_83:
              AMFDRErrorPushInternal(a6, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", CFSTR("Could not query MobileGestaltfor key '%@'"), (char)v19);
              goto LABEL_91;
            }
          }
        }
        else
        {
          v20 = AMFDRSealingMapCallMGCopyAnswerInternal(v18, 0, a6);
          if (!v20)
            goto LABEL_83;
        }
        v21 = a3;
        v22 = v13;
        v23 = CFGetTypeID(v20);
        if (v23 != CFArrayGetTypeID())
        {
          v49 = (char)v19;
          format = CFSTR("Could not queryMobileGestalt for key '%@', expected CFArray");
          goto LABEL_85;
        }
        v24 = CFArrayGetCount((CFArrayRef)v20);
        if (v17)
        {
          if (v54 != v24)
          {
            v49 = v54;
            format = CFSTR("array count is not equal to first dataInstanceArrayCount: %ld");
LABEL_85:
            AMFDRErrorPushInternal(a6, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", format, v49);
LABEL_68:
            MutableCopy = 0;
            String = 0;
            goto LABEL_76;
          }
        }
        else
        {
          v54 = v24;
        }
        if (CFArrayGetCount((CFArrayRef)v20) >= 1)
        {
          v25 = 0;
          while (1)
          {
            v26 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v20, v25);
            String = AMFDRCreateInstanceString(a1, v26);
            if (!String)
            {
              AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", CFSTR("Could not get data instance string for dataInstanceIdentifier '%@'"), (char)v20);
              goto LABEL_75;
            }
            if (v25 < CFArrayGetCount(v15) && (v28 = (const __CFString *)CFArrayGetValueAtIndex(v15, v25)) != 0)
            {
              v29 = CFStringCreateMutableCopy(a1, 0, v28);
              if (!v29)
                goto LABEL_90;
              v30 = v29;
              CFStringAppend(v29, CFSTR("-"));
              CFStringAppend(v30, String);
              CFArraySetValueAtIndex(v15, v25, v30);
              CFRelease(v30);
            }
            else
            {
              CFArrayAppendValue(v15, String);
            }
            CFRelease(String);
            if (v17 == v53 - 1)
            {
              v31 = (const __CFString *)CFArrayGetValueAtIndex(v15, v25);
              if (CFStringGetLength(v31) >= 211)
                break;
            }
            if (++v25 >= CFArrayGetCount((CFArrayRef)v20))
              goto LABEL_30;
          }
          AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", CFSTR("Instance %@ is too long"), (char)v31);
          goto LABEL_68;
        }
LABEL_30:
        CFRelease(v20);
        ++v17;
        v13 = v22;
        a3 = v21;
        if (v17 == v53)
        {
          String = (const __CFString *)CFRetain(v15);
          goto LABEL_78;
        }
      }
    }
    v47 = CFSTR("Missing value for key '%@' in sealing map entry ");
  }
  else
  {
    v47 = CFSTR("Value inkey '%@' has wrong type");
  }
  AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyIdentifierListForSealingMapEntry", v47, (char)CFSTR("MultiDataInstanceIdentifierList"));
  String = 0;
LABEL_79:
  CFRelease(v15);
  return String;
}

CFTypeRef AMFDRSealingMapCopyAssemblyIdentifierListForSealingMapEntry(const __CFAllocator *a1, CFTypeRef cf, const __CFDictionary *a3, uint64_t a4)
{
  CFTypeID v8;
  const void *Value;
  const void *v10;
  CFTypeID v11;
  CFMutableArrayRef Mutable;
  __CFArray *v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex v16;
  const __CFString *ValueAtIndex;
  const __CFString *v18;
  const __CFString *v19;
  CFStringRef String;
  CFStringRef v21;
  CFTypeRef v22;
  const __CFString *format;
  const __CFString *v25;

  v8 = CFGetTypeID(cf);
  if (v8 != CFDictionaryGetTypeID())
  {
    format = CFSTR("Value in sealing map has wrong type");
    goto LABEL_23;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AssemblyIdentifierList"));
  v10 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AsidSubCCIdentifierList"));
  if (v10 || (v10 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AsidSubCCIdOptionalVerifyList"))) != 0)
  {
    if (!Value)
      goto LABEL_5;
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyAssemblyIdentifierListForSealingMapEntry", CFSTR("Both '%@' and '%@' exist in sealing map entry"), (char)CFSTR("AssemblyIdentifierList"));
    return 0;
  }
  v10 = Value;
  if (!Value)
  {
    v25 = CFSTR("AssemblyIdentifierList");
    format = CFSTR("Both '%@' and '%@' do not exist in sealing map entry");
LABEL_23:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyAssemblyIdentifierListForSealingMapEntry", format, (char)v25);
    return 0;
  }
LABEL_5:
  v11 = CFGetTypeID(v10);
  if (v11 != CFArrayGetTypeID())
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyAssemblyIdentifierListForSealingMapEntry", CFSTR("Value in key '%@' has wrong type"), (char)CFSTR("AssemblyIdentifierList"));
    return 0;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyAssemblyIdentifierListForSealingMapEntry", CFSTR("assemblyInstanceArray is NULL"), (char)v25);
    return 0;
  }
  v13 = Mutable;
  Count = CFArrayGetCount((CFArrayRef)v10);
  if (Count < 1)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyAssemblyIdentifierListForSealingMapEntry", CFSTR("Missing value for key '%@' in sealing map entry "), (char)CFSTR("AssemblyIdentifierList"));
  }
  else
  {
    v15 = Count;
    v16 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v10, v16);
      v18 = ValueAtIndex;
      if (a3)
      {
        if (CFDictionaryContainsKey(a3, ValueAtIndex))
        {
          v19 = (const __CFString *)_CFDictionaryCopyValue(a3, v18);
          AMSupportLogInternal();
          if (!v19)
            goto LABEL_25;
        }
        else
        {
          v19 = AMFDRSealingMapCallMGCopyAnswerInternal(v18, 0, a4);
          CFDictionaryAddValue(a3, v18, v19);
          if (!v19)
          {
LABEL_25:
            AMFDRErrorPushInternal(a4, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyAssemblyIdentifierListForSealingMapEntry", CFSTR("Could not query MobileGestalt for key '%@'"), (char)v18);
            goto LABEL_27;
          }
        }
      }
      else
      {
        v19 = AMFDRSealingMapCallMGCopyAnswerInternal(ValueAtIndex, 0, a4);
        if (!v19)
          goto LABEL_25;
      }
      String = AMFDRDataCreateString(a1, v19, 0);
      if (!String)
        break;
      v21 = String;
      CFArrayAppendValue(v13, String);
      CFRelease(v19);
      CFRelease(v21);
      if (v15 == ++v16)
      {
        v22 = CFRetain(v13);
        goto LABEL_19;
      }
    }
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_copyAssemblyIdentifierListForSealingMapEntry", CFSTR("Could not get data instance string for identifier '%@'"), (char)v19);
    CFRelease(v19);
  }
LABEL_27:
  v22 = 0;
LABEL_19:
  CFRelease(v13);
  return v22;
}

uint64_t AMFDRSealingMapGetEntriesForDevice()
{
  return AMFDRSealingMapGetEntriesForDeviceInternal(0);
}

uint64_t AMFDRSealingMapGetEntriesForDeviceInternal(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(uint64_t, _QWORD);
  const void *v3;
  const void *v4;
  const void *Entries;
  _QWORD block[5];

  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 136);
    if ((*(_BYTE *)(v1 + 8) & 8) != 0)
      return 0;
    if ((_UNKNOWN *)v1 != &kAMFDRPlatformImplementationNative)
    {
      if (*(_QWORD *)v1 >= 0x21uLL)
      {
        v2 = *(uint64_t (**)(uint64_t, _QWORD))(v1 + 32);
        if (v2)
        {
          v3 = (const void *)v2(a1, *(_QWORD *)(a1 + 144));
          if (v3)
          {
            v4 = v3;
            Entries = _AMFDRSealingMapGetEntries(v3);
            CFRelease(v4);
            return (uint64_t)Entries;
          }
        }
      }
      AMSupportLogInternal();
      return 0;
    }
  }
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = __AMFDRSealingMapGetEntriesForDeviceInternal_block_invoke;
  block[3] = &__block_descriptor_tmp_143;
  block[4] = a1;
  if (AMFDRSealingMapGetEntriesForDeviceInternal_onceToken != -1)
    dispatch_once(&AMFDRSealingMapGetEntriesForDeviceInternal_onceToken, block);
  return AMFDRSealingMapGetEntriesForDeviceInternal_deviceSealingMap;
}

uint64_t copyProductType(uint64_t a1)
{
  _QWORD *v1;
  uint64_t (*v2)(uint64_t, _QWORD);

  if (!a1)
    return _AMFDRPlatformDefaultCopyProductTypeNative();
  v1 = *(_QWORD **)(a1 + 136);
  if (*v1 >= 0x21uLL && (v2 = (uint64_t (*)(uint64_t, _QWORD))v1[4]) != 0)
    return v2(a1, *(_QWORD *)(a1 + 144));
  else
    return 0;
}

const void *_AMFDRSealingMapGetEntries(const void *a1)
{
  const __CFDictionary *FDRSealingMapFromCache;
  const __CFDictionary *v3;
  const void *Value;
  const void *v5;
  CFTypeID v6;
  CFTypeID v8;

  if (!a1)
    goto LABEL_7;
  FDRSealingMapFromCache = (const __CFDictionary *)_getFDRSealingMapFromCache((uint64_t)a1);
  if (!FDRSealingMapFromCache)
    goto LABEL_7;
  v3 = FDRSealingMapFromCache;
  Value = CFDictionaryGetValue(FDRSealingMapFromCache, a1);
  v5 = Value;
  if (!Value)
  {
    AMSupportLogInternal();
    return v5;
  }
  v6 = CFGetTypeID(Value);
  if (v6 == CFStringGetTypeID())
    return CFDictionaryGetValue(v3, v5);
  v8 = CFGetTypeID(v5);
  if (v8 != CFArrayGetTypeID())
  {
LABEL_7:
    AMSupportLogInternal();
    return 0;
  }
  return v5;
}

const __CFDictionary *AMFDRSealingMapGetEntry(const __CFString *a1)
{
  return AMFDRSealingMapGetEntryInternal(0, a1, 0, 0);
}

const __CFDictionary *AMFDRSealingMapGetEntryInternal(uint64_t a1, const __CFString *a2, const __CFString *a3, const void *a4)
{
  const __CFArray *EntriesForDeviceInternal;
  const __CFArray *v8;
  const __CFString *v9;
  CFIndex v10;
  const __CFAllocator *v11;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v13;
  CFTypeID v14;
  const __CFString *Value;
  const __CFString *v16;
  CFTypeID v17;
  CFComparisonResult v18;
  CFStringRef v19;
  CFTypeID v20;
  CFTypeID v21;
  CFRange v23;

  EntriesForDeviceInternal = (const __CFArray *)AMFDRSealingMapGetEntriesForDeviceInternal(a1);
  if (!EntriesForDeviceInternal)
  {
LABEL_28:
    AMSupportLogInternal();
    return 0;
  }
  v8 = EntriesForDeviceInternal;
  if (CFArrayGetCount(EntriesForDeviceInternal) >= 1)
  {
    v9 = 0;
    v10 = 0;
    v11 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    while (1)
    {
      if (v9)
        CFRelease(v9);
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v10);
      v13 = ValueAtIndex;
      if (!ValueAtIndex)
        goto LABEL_28;
      v14 = CFGetTypeID(ValueAtIndex);
      if (v14 != CFDictionaryGetTypeID())
        goto LABEL_28;
      if (a4 && !CFDictionaryContainsKey(v13, a4))
      {
        v9 = 0;
      }
      else
      {
        Value = (const __CFString *)CFDictionaryGetValue(v13, CFSTR("Tag"));
        v16 = Value;
        if (!Value)
          goto LABEL_28;
        v17 = CFGetTypeID(Value);
        if (v17 != CFStringGetTypeID())
          goto LABEL_28;
        v18 = CFStringCompare(v16, a2, 0);
        v9 = 0;
        if (v18 == kCFCompareEqualTo)
        {
          if (!a3)
            return v13;
          v19 = _copyIdentifierListForSealingMapEntry(v11, v13, 0, 0, 0, 0);
          v9 = v19;
          if (v19)
          {
            v20 = CFGetTypeID(v19);
            if (v20 == CFStringGetTypeID())
            {
              if (CFStringCompare(v9, a3, 0) == kCFCompareEqualTo)
                goto LABEL_23;
            }
            else
            {
              v21 = CFGetTypeID(v9);
              if (v21 == CFArrayGetTypeID())
              {
                v23.length = CFArrayGetCount((CFArrayRef)v9);
                v23.location = 0;
                if (CFArrayContainsValue((CFArrayRef)v9, v23, a3))
                {
LABEL_23:
                  CFRelease(v9);
                  return v13;
                }
              }
            }
          }
        }
      }
      if (++v10 >= CFArrayGetCount(v8))
      {
        if (v9)
          CFRelease(v9);
        return 0;
      }
    }
  }
  return 0;
}

BOOL AMFDRSealingMapEntryHasAttribute(const __CFString *a1, const void *a2, uint64_t a3)
{
  const __CFDictionary *EntryInternal;

  EntryInternal = AMFDRSealingMapGetEntryInternal(0, a1, 0, 0);
  return AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, a2, a3);
}

BOOL AMFDRSealingMapEntryHasAttributeForClassInternal(uint64_t a1, const __CFString *a2, const void *a3, uint64_t a4)
{
  const __CFDictionary *EntryInternal;

  EntryInternal = AMFDRSealingMapGetEntryInternal(a1, a2, 0, 0);
  return AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, a3, a4);
}

BOOL AMFDRSealingMapEntryHasAttributeInternal(int a1, CFDictionaryRef theDict, const void *a3, uint64_t a4)
{
  const __CFArray *Value;
  const __CFArray *v7;
  CFTypeID TypeID;
  CFRange v10;

  if (theDict)
  {
    if (a3)
    {
      Value = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("Attributes"));
      if (Value)
      {
        v7 = Value;
        TypeID = CFArrayGetTypeID();
        if (TypeID == CFGetTypeID(v7))
        {
          v10.length = CFArrayGetCount(v7);
          v10.location = 0;
          return CFArrayContainsValue(v7, v10, a3) != 0;
        }
      }
    }
  }
  return a4;
}

const __CFDictionary *AMFDRSealingMapEntryHasSubCCListForClassInternal(uint64_t a1, const __CFString *a2)
{
  const __CFDictionary *result;
  const __CFDictionary *v3;
  CFTypeID TypeID;

  result = AMFDRSealingMapGetEntryInternal(a1, a2, 0, 0);
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("SubCCList"));
    if (result)
    {
      v3 = result;
      TypeID = CFArrayGetTypeID();
      return (const __CFDictionary *)(TypeID == CFGetTypeID(v3));
    }
  }
  return result;
}

uint64_t AMFDRSealingMapGetFDRDataVersionForDevice()
{
  const __CFDictionary *EntryInternal;

  EntryInternal = AMFDRSealingMapGetEntryInternal(0, CFSTR("seal"), 0, 0);
  if (AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, CFSTR("Version2"), 0))
    return 2;
  else
    return 1;
}

uint64_t AMFDRSealingMapGetFDRDataVersionForDeviceInternal(uint64_t a1)
{
  const __CFDictionary *EntryInternal;

  EntryInternal = AMFDRSealingMapGetEntryInternal(a1, CFSTR("seal"), 0, 0);
  if (AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, CFSTR("Version2"), 0))
    return 2;
  else
    return 1;
}

BOOL AMFDRSealingMapGetFDRManifestVersionForDevice()
{
  const __CFDictionary *EntryInternal;

  EntryInternal = AMFDRSealingMapGetEntryInternal(0, CFSTR("seal"), 0, 0);
  return AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, CFSTR("ManifestVersion2"), 0);
}

BOOL AMFDRSealingMapGetFDRManifestVersionForDeviceInternal(uint64_t a1)
{
  const __CFDictionary *EntryInternal;

  EntryInternal = AMFDRSealingMapGetEntryInternal(a1, CFSTR("seal"), 0, 0);
  return AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, CFSTR("ManifestVersion2"), 0);
}

uint64_t AMFDRSealingMapGetFDRMinimalManifestVersionForDeviceInternal(uint64_t a1)
{
  const __CFDictionary *EntryInternal;

  EntryInternal = AMFDRSealingMapGetEntryInternal(a1, CFSTR("seal"), 0, 0);
  if (AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, CFSTR("MinimalManifestVersion2"), 0))
  {
    return 2;
  }
  else
  {
    return 1;
  }
}

BOOL AMFDRSealingMapGetDeprecateGIDSigning(uint64_t a1)
{
  const __CFDictionary *EntryInternal;

  EntryInternal = AMFDRSealingMapGetEntryInternal(a1, CFSTR("seal"), 0, 0);
  return AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, CFSTR("DeprecateGIDSigning"), 0);
}

__CFString *AMFDRSealingMapCreateRecoveryPermissions(uint64_t a1)
{
  return _AMFDRSealingMapCreatePermissions(0, a1);
}

__CFString *_AMFDRSealingMapCreatePermissions(__CFString *a1, uint64_t a2)
{
  uint64_t EntriesForDeviceInternal;
  const __CFArray *v4;
  const __CFDictionary *v5;
  const __CFArray *Value;
  const __CFArray *v7;
  CFTypeID v8;
  int v9;
  __CFString *PermissionsString;
  CFIndex v11;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v13;
  CFTypeID v14;
  const __CFString *v15;
  const __CFString *v16;
  CFTypeID v17;
  CFStringRef v18;
  const __CFString *v19;
  CFTypeID v20;
  CFTypeID v21;
  CFIndex Count;
  CFIndex v23;
  CFIndex i;
  const __CFString *v25;
  char v27;
  char v28;
  const __CFAllocator *v29;
  const __CFDictionary *Mutable;
  CFRange v32;

  EntriesForDeviceInternal = AMFDRSealingMapGetEntriesForDeviceInternal((uint64_t)a1);
  if (!EntriesForDeviceInternal)
  {
    v9 = 1;
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCreatePermissions", CFSTR("Could not get sealing map"), v27);
    PermissionsString = 0;
    goto LABEL_42;
  }
  v4 = (const __CFArray *)EntriesForDeviceInternal;
  v29 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  if (Mutable)
  {
    if (a1 && (v5 = (const __CFDictionary *)AMFDRGetOptions((uint64_t)a1)) != 0)
    {
      Value = (const __CFArray *)CFDictionaryGetValue(v5, CFSTR("SkipRecoverDataClasses"));
      v7 = Value;
      if (Value)
      {
        v8 = CFGetTypeID(Value);
        if (v8 != CFArrayGetTypeID())
        {
          v9 = 1;
          AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCreatePermissions", CFSTR("malformed skipDataClasses"), v27);
          PermissionsString = 0;
          goto LABEL_42;
        }
      }
    }
    else
    {
      v7 = 0;
    }
    if (CFArrayGetCount(v4) >= 1)
    {
      v11 = 0;
      PermissionsString = 0;
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, v11);
        v13 = ValueAtIndex;
        if (!ValueAtIndex || (v14 = CFGetTypeID(ValueAtIndex), v14 != CFDictionaryGetTypeID()))
        {
          v9 = 1;
          AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCreatePermissions", CFSTR("Object of unexpected type '%@'"), (char)v13);
          goto LABEL_42;
        }
        v15 = (const __CFString *)CFDictionaryGetValue(v13, CFSTR("Tag"));
        if (!v15)
        {
          v9 = 1;
          AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCreatePermissions", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
          goto LABEL_42;
        }
        v16 = v15;
        v17 = CFGetTypeID(v15);
        if (v17 != CFStringGetTypeID())
        {
          v28 = (char)v16;
          v9 = 1;
          AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCreatePermissions", CFSTR("Object of unexpected type '%@' for key '%@' in sealing map entry"), v28);
          goto LABEL_42;
        }
        if (v7 && (v32.length = CFArrayGetCount(v7), v32.location = 0, CFArrayContainsValue(v7, v32, v16)))
        {
          if (_isSealingClass((_BOOL8)v16))
          {
            AMFDRErrorPushInternal(a2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCreatePermissions", CFSTR("Could not skip seal class '%@'"), (char)v16);
            goto LABEL_49;
          }
        }
        else
        {
          v18 = _copyIdentifierListForSealingMapEntry(v29, v13, Mutable, 0, 0, a2);
          if (v18)
          {
            v19 = v18;
            v20 = CFGetTypeID(v18);
            if (v20 == CFStringGetTypeID())
            {
              if (PermissionsString)
              {
                if ((AMFDRDataAppendPermissionsString(a1, 0, v16, v19, PermissionsString) & 1) == 0)
                {
LABEL_47:
                  AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCreatePermissions", CFSTR("Failed to append permissions string with data class '%@', data instance '%@',  action '%d'"), (char)v16);
                  goto LABEL_49;
                }
              }
              else
              {
                PermissionsString = (__CFString *)AMFDRDataCreatePermissionsString(a1, 0, v16, v19);
                if (!PermissionsString)
                {
LABEL_48:
                  AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCreatePermissions", CFSTR("Failed to create permissions string for     data class '%@', data instance '%@', action '%d'"), (char)v16);
                  goto LABEL_49;
                }
              }
            }
            else
            {
              v21 = CFGetTypeID(v19);
              if (v21 != CFArrayGetTypeID() || (Count = CFArrayGetCount((CFArrayRef)v19), Count < 1))
              {
                AMSupportLogInternal();
                goto LABEL_49;
              }
              v23 = Count;
              for (i = 0; i != v23; ++i)
              {
                v25 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v19, i);
                if (PermissionsString)
                {
                  if ((AMFDRDataAppendPermissionsString(a1, 0, v16, v25, PermissionsString) & 1) == 0)
                    goto LABEL_47;
                }
                else
                {
                  PermissionsString = (__CFString *)AMFDRDataCreatePermissionsString(a1, 0, v16, v25);
                  if (!PermissionsString)
                    goto LABEL_48;
                }
              }
            }
            if (_isSealingClass((_BOOL8)v16)
              && (AMFDRDataAppendPermissionsString(a1, 5u, v16, v19, PermissionsString) & 1) == 0)
            {
              AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCreatePermissions", CFSTR("Failed to append permissions string with data class '%@', data instance '%@', action '%d'"), (char)v16);
              goto LABEL_49;
            }
            CFRelease(v19);
          }
          else
          {
            AMSupportLogInternal();
          }
        }
        if (++v11 >= CFArrayGetCount(v4))
          goto LABEL_41;
      }
    }
    PermissionsString = 0;
LABEL_41:
    v9 = 0;
  }
  else
  {
    AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCreatePermissions", CFSTR("queryCache is NULL"), v27);
    PermissionsString = 0;
LABEL_49:
    v9 = 1;
  }
LABEL_42:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (v9 && PermissionsString)
  {
    CFRelease(PermissionsString);
    return 0;
  }
  return PermissionsString;
}

__CFString *AMFDRSealingMapCreateRecoveryPermissionsWithOption(__CFString *a1, uint64_t a2)
{
  char v2;

  if (a1)
    return _AMFDRSealingMapCreatePermissions(a1, a2);
  AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRecoveryPermissionsWithOption", CFSTR("amfdr is NULL"), v2);
  return 0;
}

CFTypeRef AMFDRSealingMapCopyMultiInstanceForClass(const void *a1, uint64_t a2)
{
  uint64_t EntriesForDeviceInternal;
  const __CFArray *v5;
  const __CFAllocator *v6;
  CFMutableArrayRef Mutable;
  CFIndex v8;
  CFStringRef v9;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v11;
  CFTypeID v12;
  const void *Value;
  const void *v14;
  CFTypeID v15;
  CFStringRef v16;
  CFTypeID v17;
  CFTypeID v18;
  CFTypeRef v19;
  const __CFString *format;
  char v22;

  EntriesForDeviceInternal = AMFDRSealingMapGetEntriesForDeviceInternal(0);
  if (!a1)
  {
    format = CFSTR("dataClass is NULL");
LABEL_41:
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceForClass", format, v22);
    return 0;
  }
  v5 = (const __CFArray *)EntriesForDeviceInternal;
  if (!EntriesForDeviceInternal)
  {
    format = CFSTR("Could not get sealing map");
    goto LABEL_41;
  }
  v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  if (CFArrayGetCount(v5) < 1)
  {
    v9 = 0;
    if (Mutable)
    {
LABEL_22:
      if (CFArrayGetCount(Mutable) >= 1)
      {
        v19 = CFRetain(Mutable);
        if (!v9)
          goto LABEL_30;
        goto LABEL_29;
      }
    }
LABEL_25:
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceForClass", CFSTR("Could not find key '%@' in sealing map."), (char)a1);
    v19 = 0;
    if (!v9)
    {
LABEL_30:
      if (Mutable)
LABEL_31:
        CFRelease(Mutable);
      return v19;
    }
LABEL_29:
    CFRelease(v9);
    goto LABEL_30;
  }
  v8 = 0;
  v9 = 0;
  while (1)
  {
    if (v9)
      CFRelease(v9);
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v5, v8);
    v11 = ValueAtIndex;
    if (!ValueAtIndex || (v12 = CFGetTypeID(ValueAtIndex), v12 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceForClass", CFSTR("Object of unexpected type '%@'"), (char)v11);
      goto LABEL_37;
    }
    Value = CFDictionaryGetValue(v11, CFSTR("Tag"));
    if (!Value)
    {
      AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceForClass", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
      goto LABEL_37;
    }
    v14 = Value;
    v15 = CFGetTypeID(Value);
    if (v15 != CFStringGetTypeID())
    {
      AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceForClass", CFSTR("Object of unexpected type '%@' for key '%@' in sealing map entry"), (char)a1);
      goto LABEL_37;
    }
    if (CFEqual(a1, v14))
      break;
    v9 = 0;
LABEL_18:
    if (++v8 >= CFArrayGetCount(v5))
    {
      if (Mutable)
        goto LABEL_22;
      goto LABEL_25;
    }
  }
  v16 = _copyIdentifierListForSealingMapEntry(v6, v11, 0, 0, 0, a2);
  if (v16)
  {
    v9 = v16;
    v17 = CFGetTypeID(v16);
    if (v17 == CFStringGetTypeID())
    {
      CFArrayAppendValue(Mutable, v9);
    }
    else
    {
      v18 = CFGetTypeID(v9);
      if (v18 == CFArrayGetTypeID())
      {
        if (CFArrayGetCount((CFArrayRef)v9) <= 0)
        {
          AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceForClass", CFSTR("outData array count is zero"), v22);
          v19 = 0;
        }
        else
        {
          v19 = CFRetain(v9);
        }
        goto LABEL_29;
      }
      AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceForClass", CFSTR("malformed data instance for key '%@' in sealing map."), (char)a1);
    }
    goto LABEL_18;
  }
  AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceForClass", CFSTR("outData from AMFDRSealingMapCopyDataInstanceForSealingMapEntry is NULL"), v22);
LABEL_37:
  v19 = 0;
  if (Mutable)
    goto LABEL_31;
  return v19;
}

const __CFString *AMFDRSealingMapCopyAssemblyIdentifierForClass(const void *a1, uint64_t a2)
{
  const __CFString *v2;
  const __CFString *v3;

  v2 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(a1, a2, 1, 1);
  v3 = v2;
  if (v2 && !CFStringGetLength(v2))
  {
    CFRelease(v3);
    return 0;
  }
  return v3;
}

uint64_t _AMFDRSealingMapCopyIdentifierListForClass(const void *a1, uint64_t a2, int a3, int a4)
{
  const __CFArray *EntriesForDeviceInternal;
  const __CFArray *v9;
  CFIndex v10;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v12;
  CFTypeID v13;
  const void *Value;
  const void *v15;
  CFTypeID v16;
  const __CFString *v17;
  uint64_t result;
  int v19;
  int v20;
  CFStringRef v21;
  CFStringRef v22;
  CFTypeID v23;
  uint64_t v24;
  CFTypeID v25;
  uint64_t v26;
  char v27;

  if (!a1)
  {
    v17 = CFSTR("dataClass is NULL");
    goto LABEL_12;
  }
  EntriesForDeviceInternal = (const __CFArray *)AMFDRSealingMapGetEntriesForDeviceInternal(0);
  if (!EntriesForDeviceInternal)
  {
    v17 = CFSTR("Could not get sealing map");
    goto LABEL_12;
  }
  v9 = EntriesForDeviceInternal;
  if (CFArrayGetCount(EntriesForDeviceInternal) < 1)
  {
LABEL_11:
    v27 = (char)a1;
    v17 = CFSTR("Could not find key '%@' in sealing map.");
LABEL_12:
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyIdentifierListForClass", v17, v27);
    return 0;
  }
  v10 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, v10);
    v12 = ValueAtIndex;
    if (!ValueAtIndex || (v13 = CFGetTypeID(ValueAtIndex), v13 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyIdentifierListForClass", CFSTR("Object of unexpected type '%@'"), (char)v12);
      return 0;
    }
    Value = CFDictionaryGetValue(v12, CFSTR("Tag"));
    if (!Value)
    {
      AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyIdentifierListForClass", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
      return 0;
    }
    v15 = Value;
    v16 = CFGetTypeID(Value);
    if (v16 != CFStringGetTypeID())
      break;
    if (CFEqual(a1, v15))
    {
      if (a3)
      {
        v19 = 1;
        v20 = a4;
      }
      else
      {
        v19 = 0;
        v20 = 0;
      }
      v21 = _copyIdentifierListForSealingMapEntry((const __CFAllocator *)*MEMORY[0x24BDBD240], v12, 0, v19, v20, a2);
      v22 = v21;
      if (!v21)
        goto LABEL_23;
      v23 = CFGetTypeID(v21);
      if (v23 == CFStringGetTypeID())
      {
        v24 = (uint64_t)CFRetain(v22);
        goto LABEL_22;
      }
      v25 = CFGetTypeID(v22);
      if (v25 == CFArrayGetTypeID())
      {
        CFArrayGetValueAtIndex((CFArrayRef)v22, 0);
        v24 = AMSupportSafeRetain();
LABEL_22:
        v26 = v24;
      }
      else
      {
LABEL_23:
        AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyIdentifierListForClass", CFSTR("Neither CFString nor CFArray, malformed format."), v27);
        v26 = 0;
        result = 0;
        if (!v22)
          return result;
      }
      CFRelease(v22);
      return v26;
    }
    if (++v10 >= CFArrayGetCount(v9))
      goto LABEL_11;
  }
  AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyIdentifierListForClass", CFSTR("Object of unexpected type '%@' for key '%@' in sealing map entry"), (char)a1);
  return 0;
}

uint64_t AMFDRSealingMapCopyInstanceForClass(const void *a1, uint64_t a2)
{
  return _AMFDRSealingMapCopyIdentifierListForClass(a1, a2, 0, 0);
}

const __CFArray *AMFDRSealingMapCopyInstanceWithIdentifiers(const void *a1, const void *a2, const __CFDictionary *a3, uint64_t a4)
{
  const __CFArray *Entries;
  const __CFAllocator *v8;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v10;
  CFIndex Count;
  const void **v12;
  const void **v13;
  const void **v14;
  const void **v15;
  const void *v16;
  const void *v17;
  const void *v18;
  CFIndex v19;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v21;
  CFTypeID v22;
  const void *Value;
  const void *v24;
  CFTypeID v25;
  CFStringRef v26;
  const void **v27;
  CFStringRef v28;
  CFTypeID v29;
  CFTypeID v30;
  const __CFString *v31;
  const __CFString *v33;
  char v34;
  const void **v35;
  uint64_t v36;

  if (!a1)
  {
    v33 = CFSTR("dataClass is NULL");
LABEL_40:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyInstanceWithIdentifiers", v33, v34);
    return 0;
  }
  if (!a2)
  {
    v33 = CFSTR("productType is NULL");
    goto LABEL_40;
  }
  if (!a3)
  {
    v33 = CFSTR("identifiers is NULL");
    goto LABEL_40;
  }
  Entries = (const __CFArray *)_AMFDRSealingMapGetEntries(a2);
  if (!Entries)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyInstanceWithIdentifiers", CFSTR("Could not get sealing map"), v34);
    return Entries;
  }
  v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyInstanceWithIdentifiers", CFSTR("queryCache is NULL"), v34);
    return 0;
  }
  v10 = Mutable;
  v36 = a4;
  Count = CFDictionaryGetCount(a3);
  v12 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  v13 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  CFDictionaryGetKeysAndValues(a3, v12, v13);
  if (Count >= 1)
  {
    v14 = v12;
    v15 = v13;
    do
    {
      v17 = *v14++;
      v16 = v17;
      v18 = *v15++;
      CFDictionarySetValue(v10, v16, v18);
      --Count;
    }
    while (Count);
  }
  v35 = v13;
  if (CFArrayGetCount(Entries) < 1)
  {
LABEL_17:
    AMFDRErrorPushInternal(v36, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyInstanceWithIdentifiers", CFSTR("Could not find key '%@' in sealing map."), (char)a1);
LABEL_18:
    Entries = 0;
    v26 = 0;
    v27 = v35;
    goto LABEL_27;
  }
  v19 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Entries, v19);
    v21 = ValueAtIndex;
    if (!ValueAtIndex || (v22 = CFGetTypeID(ValueAtIndex), v22 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(v36, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyInstanceWithIdentifiers", CFSTR("Object of unexpected type '%@'"), (char)v21);
      goto LABEL_18;
    }
    Value = CFDictionaryGetValue(v21, CFSTR("Tag"));
    if (!Value)
    {
      AMFDRErrorPushInternal(v36, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyInstanceWithIdentifiers", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
      goto LABEL_18;
    }
    v24 = Value;
    v25 = CFGetTypeID(Value);
    if (v25 != CFStringGetTypeID())
    {
      AMFDRErrorPushInternal(v36, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyInstanceWithIdentifiers", CFSTR("Object of unexpected type '%@' for key '%@' in sealing map entry"), (char)a1);
      goto LABEL_18;
    }
    if (CFEqual(a1, v24))
      break;
    if (++v19 >= CFArrayGetCount(Entries))
      goto LABEL_17;
  }
  v28 = _copyIdentifierListForSealingMapEntry(v8, v21, v10, 0, 0, v36);
  v26 = v28;
  v27 = v35;
  if (!v28)
    goto LABEL_25;
  v29 = CFGetTypeID(v28);
  if (v29 != CFStringGetTypeID())
  {
    v30 = CFGetTypeID(v26);
    if (v30 == CFArrayGetTypeID())
    {
      v31 = CFSTR("Not support for CFArray format in AMFDRSealingMapCopyInstanceWithIdentifiers");
LABEL_26:
      AMFDRErrorPushInternal(v36, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyInstanceWithIdentifiers", v31, v34);
      Entries = 0;
      goto LABEL_27;
    }
LABEL_25:
    v31 = CFSTR("Neither CFString nor CFArray, malformed format.");
    goto LABEL_26;
  }
  Entries = (const __CFArray *)CFRetain(v26);
  if (!Entries)
    AMFDRErrorPushInternal(v36, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyInstanceWithIdentifiers", CFSTR("AMFDRSealingMapCopyDataInstanceForSealingMapEntry returned NULL"), v34);
LABEL_27:
  CFRelease(v10);
  if (v12)
    free(v12);
  if (v27)
    free(v27);
  if (v26)
    CFRelease(v26);
  return Entries;
}

CFTypeRef AMFDRSealingMapCopyMultiInstanceWithIdentifiers(const void *a1, const void *a2, const __CFDictionary *a3, uint64_t a4)
{
  CFTypeRef v4;
  const __CFArray *Entries;
  const __CFArray *v7;
  const __CFAllocator *v8;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v10;
  CFIndex Count;
  const void **v12;
  const void **v13;
  const void **v14;
  const void **v15;
  const void *v16;
  const void *v17;
  const void *v18;
  CFIndex v19;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v21;
  CFTypeID v22;
  const void *Value;
  const void *v24;
  CFTypeID v25;
  CFStringRef v26;
  CFStringRef v27;
  const __CFString *v29;
  char v30;
  const __CFAllocator *v31;

  v4 = a1;
  if (!a1)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceWithIdentifiers", CFSTR("dataClass is NULL"), v30);
    return v4;
  }
  if (!a2)
  {
    v29 = CFSTR("productType is NULL");
LABEL_37:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceWithIdentifiers", v29, v30);
    return 0;
  }
  if (!a3)
  {
    v29 = CFSTR("identifiers is NULL");
    goto LABEL_37;
  }
  Entries = (const __CFArray *)_AMFDRSealingMapGetEntries(a2);
  if (!Entries)
  {
    v29 = CFSTR("Could not get sealing map");
    goto LABEL_37;
  }
  v7 = Entries;
  v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceWithIdentifiers", CFSTR("queryCache is NULL"), v30);
    return 0;
  }
  v10 = Mutable;
  v31 = v8;
  Count = CFDictionaryGetCount(a3);
  v12 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  v13 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  CFDictionaryGetKeysAndValues(a3, v12, v13);
  if (Count >= 1)
  {
    v14 = v12;
    v15 = v13;
    do
    {
      v17 = *v14++;
      v16 = v17;
      v18 = *v15++;
      CFDictionarySetValue(v10, v16, v18);
      --Count;
    }
    while (Count);
  }
  if (CFArrayGetCount(v7) < 1)
  {
LABEL_21:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceWithIdentifiers", CFSTR("Could not find key '%@' in sealing map."), (char)v4);
LABEL_22:
    v4 = 0;
    v27 = 0;
  }
  else
  {
    v19 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v19);
      v21 = ValueAtIndex;
      if (!ValueAtIndex || (v22 = CFGetTypeID(ValueAtIndex), v22 != CFDictionaryGetTypeID()))
      {
        AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceWithIdentifiers", CFSTR("Object of unexpected type '%@'"), (char)v21);
        goto LABEL_22;
      }
      Value = CFDictionaryGetValue(v21, CFSTR("Tag"));
      if (!Value)
      {
        AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceWithIdentifiers", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
        goto LABEL_22;
      }
      v24 = Value;
      v25 = CFGetTypeID(Value);
      if (v25 != CFStringGetTypeID())
      {
        AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceWithIdentifiers", CFSTR("Object of unexpected type '%@' for key '%@' in sealing map entry"), (char)v4);
        goto LABEL_22;
      }
      if (CFEqual(v4, v24))
        break;
      if (++v19 >= CFArrayGetCount(v7))
        goto LABEL_21;
    }
    v26 = _copyIdentifierListForSealingMapEntry(v31, v21, v10, 0, 0, a4);
    if (!v26)
      goto LABEL_21;
    v27 = v26;
    v4 = CFRetain(v26);
    if (!v4)
      AMFDRErrorPushInternal(a4, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMultiInstanceWithIdentifiers", CFSTR("AMFDRSealingMapCopyDataInstanceForSealingMapEntry returned NULL"), v30);
  }
  CFRelease(v10);
  if (v12)
    free(v12);
  if (v13)
    free(v13);
  if (v27)
    CFRelease(v27);
  return v4;
}

void *AMFDRSealingMapCopyPropertyWithTag(const void *a1, const __CFString *cf, uint64_t a3)
{
  CFTypeID v6;
  const __CFArray *ManifestPropertyEntriesForDevice;
  const __CFArray *v8;
  CFIndex v9;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v11;
  CFTypeID v12;
  const __CFString *Value;
  const __CFString *v14;
  void *result;
  const __CFAllocator *v16;
  char v17;

  if (!cf || (v6 = CFGetTypeID(cf), v6 != CFStringGetTypeID()) || CFStringGetLength(cf) != 4)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyPropertyWithTag", CFSTR("invalid propertyTag '%@'"), (char)cf);
    return 0;
  }
  ManifestPropertyEntriesForDevice = (const __CFArray *)_AMFDRSealingMapGetManifestPropertyEntriesForDevice((uint64_t)a1);
  if (!ManifestPropertyEntriesForDevice)
  {
    v14 = CFSTR("Could not get manifest properties");
    goto LABEL_12;
  }
  v8 = ManifestPropertyEntriesForDevice;
  if (CFArrayGetCount(ManifestPropertyEntriesForDevice) < 1)
  {
LABEL_11:
    v17 = (char)cf;
    v14 = CFSTR("Could not find tag '%@' in manifest properties");
LABEL_12:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyPropertyWithTag", v14, v17);
    return 0;
  }
  v9 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v9);
    v11 = ValueAtIndex;
    if (!ValueAtIndex || (v12 = CFGetTypeID(ValueAtIndex), v12 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyPropertyWithTag", CFSTR("Invalid entry '%@' in manifest property entries"), (char)v11);
      return 0;
    }
    Value = (const __CFString *)CFDictionaryGetValue(v11, CFSTR("Tag"));
    if (CFStringCompare(cf, Value, 0) == kCFCompareEqualTo)
      break;
    if (++v9 >= CFArrayGetCount(v8))
      goto LABEL_11;
  }
  v16 = CFGetAllocator(a1);
  result = _copyMGValuePropertyEntry(v16, v11, 0);
  if (result)
    return result;
  AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyPropertyWithTag", CFSTR("Failed to get value on device for property tag '%@'"), (char)cf);
  return 0;
}

uint64_t _AMFDRSealingMapGetManifestPropertyEntriesForDevice(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(uint64_t, _QWORD);
  const void *v3;
  const void *v4;
  const __CFDictionary *ManifestPropertiesEntries;
  _QWORD block[5];

  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 136);
    if ((*(_BYTE *)(v1 + 8) & 8) != 0)
      return 0;
    if ((_UNKNOWN *)v1 != &kAMFDRPlatformImplementationNative)
    {
      if (*(_QWORD *)v1 >= 0x21uLL)
      {
        v2 = *(uint64_t (**)(uint64_t, _QWORD))(v1 + 32);
        if (v2)
        {
          v3 = (const void *)v2(a1, *(_QWORD *)(a1 + 144));
          if (v3)
          {
            v4 = v3;
            ManifestPropertiesEntries = _AMFDRSealingMapGetManifestPropertiesEntries(v3);
            CFRelease(v4);
            return (uint64_t)ManifestPropertiesEntries;
          }
        }
      }
      AMSupportLogInternal();
      return 0;
    }
  }
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___AMFDRSealingMapGetManifestPropertyEntriesForDevice_block_invoke;
  block[3] = &__block_descriptor_tmp_922;
  block[4] = a1;
  if (_AMFDRSealingMapGetManifestPropertyEntriesForDevice_onceToken != -1)
    dispatch_once(&_AMFDRSealingMapGetManifestPropertyEntriesForDevice_onceToken, block);
  return _AMFDRSealingMapGetManifestPropertyEntriesForDevice_deviceManifestProperties;
}

void *_copyMGValuePropertyEntry(const __CFAllocator *a1, CFTypeRef cf, const __CFDictionary *a3)
{
  CFTypeID v6;
  const __CFString *Value;
  const __CFString *v8;
  CFTypeID v9;
  const __CFString *v10;
  CFTypeID v11;
  CFTypeID v12;
  void *String;
  CFTypeID v14;
  void *v15;

  v6 = CFGetTypeID(cf);
  if (v6 != CFDictionaryGetTypeID()
    || (Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("PropertyIdentifier"))) == 0
    || (v8 = Value, v9 = CFGetTypeID(Value), v9 != CFStringGetTypeID())
    || (!a3 || (v10 = (const __CFString *)_CFDictionaryCopyValue(a3, v8)) == 0)
    && (v10 = AMFDRSealingMapCallMGCopyAnswerInternal(v8, 0, 0)) == 0)
  {
    AMSupportLogInternal();
    return 0;
  }
  if (!_propertyEntryHasAttribute((const __CFDictionary *)cf, CFSTR("StoreAsData"), 0))
  {
    if (!_propertyEntryHasAttribute((const __CFDictionary *)cf, CFSTR("StoreAsInteger"), 0))
    {
      String = (void *)AMFDRDataCreateString(a1, v10, 0);
LABEL_15:
      v15 = String;
      if (!String)
        AMSupportLogInternal();
      goto LABEL_17;
    }
    v14 = CFGetTypeID(v10);
    if (v14 != CFNumberGetTypeID())
      goto LABEL_20;
LABEL_13:
    String = (void *)CFRetain(v10);
    goto LABEL_15;
  }
  v11 = CFGetTypeID(v10);
  if (v11 == CFDataGetTypeID())
    goto LABEL_13;
  v12 = CFGetTypeID(v10);
  if (v12 == CFStringGetTypeID())
  {
    String = CFStringCreateExternalRepresentation(a1, v10, 0x8000100u, 0x5Fu);
    goto LABEL_15;
  }
LABEL_20:
  AMSupportLogInternal();
  v15 = 0;
LABEL_17:
  CFRelease(v10);
  return v15;
}

CFTypeRef AMFDRSealingMapCopyRequiredIdentifiers(const void *a1, const void *a2, uint64_t a3)
{
  const __CFArray *Entries;
  const __CFArray *v6;
  CFMutableArrayRef Mutable;
  const __CFArray *v8;
  CFIndex v9;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v11;
  CFTypeID v12;
  const void *Value;
  const void *v14;
  CFTypeID v15;
  const void *v16;
  const __CFArray *v17;
  const __CFArray *v18;
  CFTypeID v19;
  uint64_t Count;
  CFTypeRef v21;
  const __CFString *v23;
  const __CFString *v24;
  char v25;
  CFRange v26;

  if (!a1)
  {
    v24 = CFSTR("dataClass is NULL");
LABEL_33:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyRequiredIdentifiers", v24, v25);
    return 0;
  }
  if (!a2)
  {
    v24 = CFSTR("productType is NULL");
    goto LABEL_33;
  }
  Entries = (const __CFArray *)_AMFDRSealingMapGetEntries(a2);
  if (!Entries)
  {
    v24 = CFSTR("Could not get sealing map");
    goto LABEL_33;
  }
  v6 = Entries;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyRequiredIdentifiers", CFSTR("identifiers is NULL"), v25);
    return 0;
  }
  v8 = Mutable;
  if (CFArrayGetCount(v6) < 1)
  {
LABEL_21:
    if (CFArrayGetCount(v8) <= 0)
    {
      AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyRequiredIdentifiers", CFSTR("Could not find key '%@' in sealing map."), (char)a1);
      goto LABEL_29;
    }
    v21 = CFRetain(v8);
    goto LABEL_23;
  }
  v9 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, v9);
    v11 = ValueAtIndex;
    if (!ValueAtIndex || (v12 = CFGetTypeID(ValueAtIndex), v12 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyRequiredIdentifiers", CFSTR("Object of unexpected type '%@'"), (char)v11);
      goto LABEL_29;
    }
    Value = CFDictionaryGetValue(v11, CFSTR("Tag"));
    if (!Value)
    {
      AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyRequiredIdentifiers", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
      goto LABEL_29;
    }
    v14 = Value;
    v15 = CFGetTypeID(Value);
    if (v15 != CFStringGetTypeID())
    {
      v25 = (char)a1;
      v23 = CFSTR("Object of unexpected type '%@' for key '%@' in sealing map entry");
      goto LABEL_28;
    }
    if (CFEqual(a1, v14))
      break;
    if (++v9 >= CFArrayGetCount(v6))
      goto LABEL_21;
  }
  v16 = CFDictionaryGetValue(v11, CFSTR("DataInstanceIdentifier"));
  v17 = (const __CFArray *)CFDictionaryGetValue(v11, CFSTR("DataInstanceIdentifierList"));
  v18 = v17;
  if (!v16)
  {
    if (!v17)
      goto LABEL_21;
    v19 = CFGetTypeID(v17);
    if (v19 != CFArrayGetTypeID())
    {
      AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyRequiredIdentifiers", CFSTR("Value in key %@ has wrong type"), (char)CFSTR("DataInstanceIdentifierList"));
      goto LABEL_29;
    }
    Count = CFArrayGetCount(v18);
    if (Count > 0)
    {
      v26.length = Count;
      v26.location = 0;
      CFArrayAppendArray(v8, v18, v26);
      goto LABEL_21;
    }
    v23 = CFSTR("length of gestaltKeyList is 0");
LABEL_28:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyRequiredIdentifiers", v23, v25);
    goto LABEL_29;
  }
  if (!v17)
  {
    CFArrayAppendValue(v8, v16);
    goto LABEL_21;
  }
  AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyRequiredIdentifiers", CFSTR("Both '%@' and '%@' exist in sealing map entry "), (char)CFSTR("DataInstanceIdentifier"));
LABEL_29:
  v21 = 0;
LABEL_23:
  CFRelease(v8);
  return v21;
}

uint64_t AMFDRSealingMapCopyLocalDataForClass(__CFString *a1, const __CFDictionary *a2, uint64_t a3)
{
  const __CFString *v6;
  uint64_t v7;
  char v9;

  if (!a1)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalDataForClass", CFSTR("dataClass is NULL"), v9);
LABEL_7:
    v7 = 0;
    goto LABEL_4;
  }
  v6 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(a1, a3, 0, 0);
  if (!v6)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalDataForClass", CFSTR("dataInstance is NULL"), v9);
    goto LABEL_7;
  }
  v7 = AMFDRSealingMapCopyLocalData(a1, v6, a2, a3);
LABEL_4:
  AMSupportSafeRelease();
  return v7;
}

uint64_t AMFDRSealingMapCopyLocalData(__CFString *a1, const __CFString *a2, const __CFDictionary *a3, uint64_t a4)
{
  const __CFString *v8;
  uint64_t v9;

  v8 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(a1, a4, 1, 0);
  if (v8)
  {
    v9 = _AMFDRSealingMapCopyLocalDataInternal(a1, a2, v8, 0, 0, a3, a4);
  }
  else
  {
    AMSupportLogInternal();
    v9 = 0;
  }
  AMSupportSafeRelease();
  return v9;
}

uint64_t _AMFDRSealingMapCopyLocalDataInternal(__CFString *a1, const __CFString *a2, const __CFString *a3, int a4, int a5, const __CFDictionary *a6, uint64_t a7)
{
  const __CFDictionary *v9;
  _QWORD *v13;
  _QWORD *v14;
  const __CFAllocator *v15;
  CFMutableDictionaryRef Mutable;
  const void *v17;
  const __CFBoolean *Value;
  const __CFDictionary *EntryInternal;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFDictionary *v23;
  const __CFAllocator *v24;
  CFStringRef v25;
  CFStringRef v26;
  const void *v27;
  const __CFString *v28;
  const __CFString *v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  int v34;
  const __CFString *v35;
  const __CFString *v36;

  if (!a1)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalDataInternal", CFSTR("dataClass is NULL"), v33);
    v31 = 0;
    goto LABEL_46;
  }
  if (!a2)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalDataInternal", CFSTR("dataInstance is NULL"), v33);
LABEL_51:
    v31 = 0;
    Mutable = 0;
    goto LABEL_44;
  }
  v9 = a6;
  v13 = AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Local"), a6);
  v14 = v13;
  if (!v13)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalDataInternal", CFSTR("amfdr is NULL"), v33);
    goto LABEL_51;
  }
  v15 = CFGetAllocator(v13);
  Mutable = CFDictionaryCreateMutable(v15, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalDataInternal", CFSTR("failed to allocate sikOverrideDict"), v33);
LABEL_54:
    v31 = 0;
    goto LABEL_44;
  }
  if ((AMFDRSealingMapSetSikOverride(v14, Mutable, a1, a2, a7) & 1) == 0)
  {
    AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalDataInternal", CFSTR("AMFDRSealingMapSetSikOverride failed"), v33);
    goto LABEL_54;
  }
  v17 = (const void *)v14[15];
  if (v17)
    CFRelease(v17);
  v14[15] = Mutable;
  CFRetain(Mutable);
  if (v9)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v9, CFSTR("VerifyData"));
    v9 = (const __CFDictionary *)CFDictionaryGetValue(v9, CFSTR("GetCombined"));
    if ((AMFDRDataApTicketPopulate((uint64_t)v14) & 1) == 0)
    {
      if (Value && !CFBooleanGetValue(Value))
      {
        v36 = (const __CFString *)Value;
        AMSupportLogInternal();
        goto LABEL_21;
      }
      goto LABEL_16;
    }
  }
  else
  {
    Value = 0;
    if (!AMFDRDataApTicketPopulate((uint64_t)v14))
    {
LABEL_16:
      v36 = (const __CFString *)Value;
      AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalDataInternal", CFSTR("Unable to read AP Ticket"), v33);
      goto LABEL_21;
    }
  }
  EntryInternal = AMFDRSealingMapGetEntryInternal(0, a1, 0, 0);
  if (AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, CFSTR("LocalCopyForceBootedOSTrustObject"), 0))
  {
    v20 = (const __CFString *)AMFDRDataApTicketCopyObjectProperty((uint64_t)v14, 1718903152, 1145525076);
  }
  else
  {
    v20 = (const __CFString *)AMFDRDataApTicketCopyTrustObjectDigest((uint64_t)v14);
  }
  if (!v20)
    goto LABEL_55;
  AMFDRSetOption((uint64_t)v14, CFSTR("TrustObjectDigest"), v20);
  v36 = (const __CFString *)Value;
  if (AMFDRIsNonDefaultDemotionState())
  {
    AMSupportLogInternal();
    AMFDRSetOption((uint64_t)v14, CFSTR("SkipVerifySik"), (const __CFString *)*MEMORY[0x24BDBD270]);
  }
LABEL_21:
  v21 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(CFSTR("seal"), a7, 0, 0);
  if (!v21)
  {
LABEL_55:
    AMSupportLogInternal();
    v31 = 0;
    goto LABEL_44;
  }
  v35 = (const __CFString *)v9;
  AMFDRSetOption((uint64_t)v14, CFSTR("INST"), v21);
  v22 = (const __CFString *)*MEMORY[0x24BDBD268];
  AMFDRSetOption((uint64_t)v14, CFSTR("VerifyData"), (const __CFString *)*MEMORY[0x24BDBD268]);
  AMFDRSetOption((uint64_t)v14, CFSTR("GetCombined"), v22);
  AMFDRDataCopyTrustObject((uint64_t)v14);
  AMSupportLogInternal();
  v23 = AMFDRSealingMapGetEntryInternal(0, a1, 0, 0);
  v34 = a5;
  if (!AMFDRSealingMapEntryHasAttributeInternal((int)v23, v23, CFSTR("MultiSealing"), 0))
  {
    v28 = (const __CFString *)AMFDRDataCopy((uint64_t)v14, CFSTR("seal"), v21, 0);
    if (v28)
      AMFDRSetOption((uint64_t)v14, CFSTR("SealingManifest"), v28);
    else
      AMSupportLogInternal();
    v26 = 0;
    v27 = 0;
    goto LABEL_32;
  }
  v24 = CFGetAllocator(v14);
  v25 = CFStringCreateWithFormat(v24, 0, CFSTR("%@-%@"), CFSTR("manifest"), a1);
  if (v25)
  {
    v26 = v25;
    v27 = (const void *)AMFDRDataLocalCopyDataStoragePath(v14, (uint64_t)v25, (uint64_t)a2, a7);
    if (!v27)
    {
      AMFDRErrorPushInternal(a7, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalDataInternal", CFSTR("missing data storage path"), v33);
      v31 = 0;
LABEL_41:
      CFRelease(v26);
LABEL_42:
      if (v27)
        CFRelease(v27);
      goto LABEL_44;
    }
    CFGetAllocator(v14);
    AMSupportCreateDataFromFileURL();
    v29 = (const __CFString *)AMFDRDataCopy((uint64_t)v14, CFSTR("seal"), v21, 0);
    if (v29)
      AMFDRSetOption((uint64_t)v14, CFSTR("SealingManifest"), v29);
    else
      AMSupportLogInternal();
LABEL_32:
    AMFDRSetOption((uint64_t)v14, CFSTR("VerifyData"), v36);
    AMFDRSetOption((uint64_t)v14, CFSTR("GetCombined"), v35);
    if (a3)
    {
      AMFDRSetAssemblyIdentifierToVerify((uint64_t)v14, a1, a3);
      if (AMFDRSealingMapEntryHasSubCCListForClassInternal((uint64_t)v14, a1))
        AMFDRSetOption((uint64_t)v14, CFSTR("VerifyAsidInSubCC"), (const __CFString *)*MEMORY[0x24BDBD270]);
    }
    if (a4)
    {
      v30 = (uint64_t)AMFDRDataPopulate((uint64_t)v14, (uint64_t)a1, (uint64_t)a2, 0, a7);
    }
    else if (v34)
    {
      v30 = AMFDRDataDictCopy((uint64_t)v14, a1, a2, a7);
    }
    else
    {
      v30 = (uint64_t)AMFDRDataCopy((uint64_t)v14, a1, a2, a7);
    }
    v31 = v30;
    if (!v26)
      goto LABEL_42;
    goto LABEL_41;
  }
  AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalDataInternal", CFSTR("multiManifestDataClass create failed"), v33);
  v31 = 0;
LABEL_44:
  if (Mutable)
    CFRelease(Mutable);
LABEL_46:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v31;
}

CFDataRef AMFDRSealingMapCopyLocalMinimalManifestForInstance(const __CFString *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  CFDataRef v6;
  char v8;

  v4 = AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Local"), 0);
  v5 = (uint64_t)v4;
  if (v4)
  {
    AMFDRSetOption((uint64_t)v4, CFSTR("VerifyData"), (const __CFString *)*MEMORY[0x24BDBD268]);
    v6 = AMFDRDataCopy(v5, CFSTR("minimal-manifest"), a1, a2);
  }
  else
  {
    AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMinimalManifestForInstance", CFSTR("amfdr is NULL"), v8);
    v6 = 0;
  }
  AMSupportSafeRelease();
  return v6;
}

uint64_t AMFDRSealingMapCopyLocalDataByPopulate(__CFString *a1, const __CFDictionary *a2, uint64_t a3)
{
  const __CFString *v6;
  const __CFString *v7;
  uint64_t v8;
  char v10;

  if (!a1)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalDataByPopulate", CFSTR("dataClass is NULL"), v10);
LABEL_10:
    v8 = 0;
    goto LABEL_5;
  }
  v6 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(a1, a3, 0, 0);
  if (!v6)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalDataByPopulate", CFSTR("dataInstance is NULL"), v10);
    goto LABEL_10;
  }
  v7 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(a1, a3, 1, 0);
  if (!v7)
  {
    AMSupportLogInternal();
    goto LABEL_10;
  }
  v8 = _AMFDRSealingMapCopyLocalDataInternal(a1, v6, v7, 1, 0, a2, a3);
LABEL_5:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v8;
}

uint64_t AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute(void *a1, int a2, const __CFArray *a3, const __CFArray *a4, const void *a5, CFTypeRef *a6, CFTypeRef *a7, CFTypeRef *a8, uint64_t a9)
{
  void *v13;
  const __CFAllocator *v14;
  const CFArrayCallBacks *v15;
  CFMutableArrayRef Mutable;
  const __CFAllocator *v17;
  const __CFArray *v18;
  const __CFAllocator *v19;
  CFMutableArrayRef v20;
  CFMutableArrayRef v21;
  BOOL v22;
  const __CFDictionary *v24;
  const __CFArray *v25;
  const __CFArray *v26;
  __CFArray *v27;
  CFTypeID v28;
  uint64_t EntriesForDeviceInternal;
  const __CFArray *v30;
  const __CFAllocator *v31;
  CFIndex v32;
  int v33;
  const char *v34;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v36;
  CFTypeID v37;
  const __CFString *Value;
  const __CFString *v39;
  const char *v40;
  CFTypeID v41;
  const __CFDictionary *EntryInternal;
  const void *v43;
  CFIndex LastIndexOfValue;
  const void *v45;
  const void *v46;
  CFTypeID v47;
  const void *v48;
  const __CFAllocator *v49;
  CFStringRef v50;
  const __CFArray *v51;
  CFTypeID v52;
  CFIndex v53;
  const void *v54;
  const __CFAllocator *v55;
  CFIndex Count;
  CFIndex v57;
  uint64_t v58;
  const __CFString *format;
  const __CFString *v61;
  char v62;
  char v63;
  CFTypeRef *v64;
  CFTypeRef *v65;
  CFTypeRef *v66;
  void *v67;
  __CFArray *v68;
  const __CFDictionary *v70;
  const __CFArray *v71;
  const __CFArray *v72;
  int v74;
  CFRange v76;
  CFRange v77;

  v13 = a1;
  v14 = CFGetAllocator(a1);
  v15 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  Mutable = CFArrayCreateMutable(v14, 0, MEMORY[0x24BDBD690]);
  v17 = CFGetAllocator(v13);
  v18 = CFArrayCreateMutable(v17, 0, v15);
  v19 = CFGetAllocator(v13);
  v20 = CFArrayCreateMutable(v19, 0, v15);
  v21 = v20;
  if (Mutable)
    v22 = v18 == 0;
  else
    v22 = 1;
  if (v22 || v20 == 0)
  {
    AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", CFSTR("failed to allocate data class/instance arrays"), v62);
LABEL_81:
    v51 = 0;
    v58 = 0;
    goto LABEL_61;
  }
  v24 = (const __CFDictionary *)AMFDRGetOptions((uint64_t)v13);
  if (!v24)
  {
    AMFDRErrorPushInternal(a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", CFSTR("amfdr options is NULL"), v62);
    goto LABEL_81;
  }
  v25 = (const __CFArray *)_CFDictionaryCopyValue(v24, CFSTR("SkipRecoverDataClasses"));
  v26 = v25;
  v71 = v25;
  if (v25)
  {
    v27 = v21;
    v28 = CFGetTypeID(v25);
    v22 = v28 == CFArrayGetTypeID();
    v21 = v27;
    v26 = v71;
    if (!v22)
    {
      v61 = CFSTR("malformed skipDataClasses");
LABEL_80:
      AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", v61, v62);
      goto LABEL_81;
    }
  }
  EntriesForDeviceInternal = AMFDRSealingMapGetEntriesForDeviceInternal((uint64_t)v13);
  if (!EntriesForDeviceInternal)
  {
    v61 = CFSTR("Could not get sealing map");
    goto LABEL_80;
  }
  v30 = (const __CFArray *)EntriesForDeviceInternal;
  v31 = CFGetAllocator(v13);
  v70 = CFDictionaryCreateMutable(v31, 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  if (!v70)
  {
    AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", CFSTR("queryCache is NULL"), v62);
    goto LABEL_81;
  }
  v64 = a6;
  v65 = a7;
  v66 = a8;
  v72 = Mutable;
  if (CFArrayGetCount(v30) < 1)
  {
LABEL_50:
    if (CFArrayGetCount(v72) && CFArrayGetCount(v18))
    {
      Count = CFArrayGetCount(v72);
      if (Count != CFArrayGetCount(v18))
      {
        AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", CFSTR("Must have a data instance for each data class to recover"), v62);
        v51 = 0;
        v58 = 0;
        goto LABEL_61;
      }
      if (v64)
        *v64 = CFRetain(v72);
      if (v65)
        *v65 = CFRetain(v18);
      if (v66)
      {
        *v66 = CFRetain(v21);
        if (CFArrayGetCount(v21) >= 1)
        {
          v57 = CFArrayGetCount(v21);
          AMFDRSetStat((CFMutableDictionaryRef *)v13, CFSTR("FDRMissingDataInstance"), v57);
        }
      }
    }
    v51 = 0;
    v58 = 1;
    goto LABEL_61;
  }
  v32 = 0;
  if (v26)
    v33 = a2;
  else
    v33 = 0;
  v74 = v33;
  v34 = "adding %@ : %@ into array for multi instance";
  v67 = v13;
  v68 = v21;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v30, v32);
    v36 = ValueAtIndex;
    if (!ValueAtIndex || (v37 = CFGetTypeID(ValueAtIndex), v37 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", CFSTR("Object of unexpected type '%@' in sealing map"), (char)v36);
      goto LABEL_71;
    }
    Value = (const __CFString *)CFDictionaryGetValue(v36, CFSTR("Tag"));
    if (!Value)
    {
      AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
      goto LABEL_71;
    }
    v39 = Value;
    v40 = v34;
    v41 = CFGetTypeID(Value);
    if (v41 != CFStringGetTypeID())
    {
      v62 = (char)v39;
      format = CFSTR("Object of unexpected type '%@' for key '%@' in sealing map entry");
LABEL_70:
      AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", format, v62);
      goto LABEL_71;
    }
    EntryInternal = AMFDRSealingMapGetEntryInternal((uint64_t)v13, v39, 0, 0);
    v34 = v40;
    if (AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, a5, 0))
      break;
LABEL_49:
    if (++v32 >= CFArrayGetCount(v30))
      goto LABEL_50;
  }
  if (v74)
  {
    v76.length = CFArrayGetCount(v26);
    v76.location = 0;
    if (CFArrayContainsValue(v26, v76, v39))
    {
      AMSupportLogInternal();
      goto LABEL_49;
    }
  }
  v43 = a3;
  if (a3)
  {
    v77.length = CFArrayGetCount(a3);
    v77.location = 0;
    LastIndexOfValue = CFArrayGetLastIndexOfValue(a3, v77, v39);
    if (LastIndexOfValue < 0)
    {
      v43 = 0;
    }
    else
    {
      v45 = CFArrayGetValueAtIndex(a4, LastIndexOfValue);
      if (!v45)
      {
        format = CFSTR("dataInstance is NULL");
        goto LABEL_70;
      }
      v46 = v45;
      v47 = CFGetTypeID(v45);
      if (v47 != CFStringGetTypeID())
      {
        AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", CFSTR("malformed dataInstance"), v62);
        v51 = 0;
        goto LABEL_75;
      }
      AMSupportLogInternal();
      v43 = CFRetain(v46);
      v26 = v71;
    }
  }
  v48 = CFDictionaryGetValue(v36, CFSTR("MultiDataInstanceIdentifierList"));
  if (v43 || !v48)
  {
    if (v43
      || (v55 = CFGetAllocator(v13), (v43 = _copyIdentifierListForSealingMapEntry(v55, v36, v70, 0, 0, a9)) != 0))
    {
      CFArrayAppendValue(v72, v39);
      CFArrayAppendValue(v18, v43);
      CFRelease(v43);
LABEL_48:
      v34 = v40;
      goto LABEL_49;
    }
    if (!AMFDRAllowIncompleteData((uint64_t)v13))
    {
      v63 = (char)v39;
LABEL_67:
      AMFDRErrorPushInternal(a9, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", CFSTR("Could not get data instance for data class '%@'"), v63);
LABEL_71:
      v51 = 0;
      v58 = 0;
      goto LABEL_61;
    }
LABEL_47:
    AMSupportLogInternal();
    CFArrayAppendValue(v21, v39);
    goto LABEL_48;
  }
  v49 = CFGetAllocator(v13);
  v50 = _copyIdentifierListForSealingMapEntry(v49, v36, v70, 0, 0, a9);
  if (!v50)
  {
    if (!AMFDRAllowIncompleteData((uint64_t)v13))
    {
      v63 = (char)v39;
      goto LABEL_67;
    }
    goto LABEL_47;
  }
  v51 = (const __CFArray *)v50;
  v52 = CFGetTypeID(v50);
  if (v52 == CFArrayGetTypeID())
  {
    if (CFArrayGetCount(v51) >= 1)
    {
      v53 = 0;
      do
      {
        v54 = CFArrayGetValueAtIndex(v51, v53);
        CFArrayAppendValue(v72, v39);
        CFArrayAppendValue(v18, v54);
        AMSupportLogInternal();
        ++v53;
      }
      while (v53 < CFArrayGetCount(v51));
    }
    CFRelease(v51);
    v13 = v67;
    v21 = v68;
    v26 = v71;
    goto LABEL_48;
  }
  AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute", CFSTR("malformed dataInstance, expected CFArray"), v62);
LABEL_75:
  v58 = 0;
LABEL_61:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (v51)
    CFRelease(v51);
  return v58;
}

uint64_t AMFDRSealingMapSetSikOverride(const void *a1, void *a2, const __CFString *a3, const __CFString *a4, uint64_t a5)
{
  const __CFString *v6;
  const __CFDictionary *EntryInternal;
  char v13;

  v6 = CFSTR("dataClass/dataInstance is NULL");
  if (a3 && a4)
  {
    EntryInternal = AMFDRSealingMapGetEntryInternal((uint64_t)a1, a3, a4, CFSTR("SikOverride"));
    if (!EntryInternal || _AMFDRSealingMapEntrySetSikOverride(a1, a2, EntryInternal, (uint64_t)a3, (uint64_t)a4, a5))
      return 1;
    v6 = CFSTR("_AMFDRSealingMapEntrySetSikOverride failed");
  }
  AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapSetSikOverride", v6, v13);
  return 0;
}

BOOL _AMFDRSealingMapEntrySetSikOverride(CFTypeRef cf, void *a2, CFDictionaryRef theDict, uint64_t a4, uint64_t a5, uint64_t a6)
{
  const __CFAllocator *v12;
  CFTypeID v13;
  const __CFString *v14;
  const __CFString *v15;
  CFTypeID v16;
  CFTypeID TypeID;
  _BOOL8 v18;
  CFTypeID v19;
  const __CFString *v20;
  const __CFData *v21;
  CFTypeID v22;
  UInt8 *BytePtr;
  CFIndex Length;
  const __CFString *SikPubDigestIfNecessary;
  const __CFString *v26;
  CFStringRef v27;
  CFStringRef v28;
  CFStringRef v29;
  CFStringRef v30;
  uint64_t v32;
  CFIndex v33;
  void *value[2];
  void *v35[2];
  __int128 v36;
  const __CFString *v37;
  char v38;

  if (!theDict)
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapEntrySetSikOverride", CFSTR("sealingMapEntry is NULL"), v38);
    return 0;
  }
  if (!a4 || !a5)
  {
    v37 = CFSTR("dataClass/dataInstance is NULL");
    *(_OWORD *)v35 = 0u;
    v36 = 0u;
    *(_OWORD *)value = 0u;
    v32 = a6;
    v33 = 1;
    goto LABEL_23;
  }
  v12 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if (cf)
  {
    v13 = CFGetTypeID(cf);
    if (v13 == AMFDRGetTypeID())
      v12 = CFGetAllocator(cf);
  }
  v14 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("SikOverride"));
  if (!v14)
    return 1;
  v15 = v14;
  v16 = CFGetTypeID(v14);
  TypeID = CFStringGetTypeID();
  v18 = 1;
  if (a2)
  {
    if (v16 == TypeID)
    {
      v19 = CFGetTypeID(a2);
      if (v19 == CFDictionaryGetTypeID())
      {
        v20 = AMFDRSealingMapCallMGCopyAnswerInternal(v15, 0, 0);
        if (v20)
        {
          v21 = (const __CFData *)v20;
          v22 = CFGetTypeID(v20);
          if (v22 == CFDataGetTypeID())
          {
            BytePtr = (UInt8 *)CFDataGetBytePtr(v21);
            Length = CFDataGetLength(v21);
            SikPubDigestIfNecessary = (const __CFString *)AMFDRDataCreateSikPubDigestIfNecessary(v12, BytePtr, Length);
            if (SikPubDigestIfNecessary)
            {
              v26 = SikPubDigestIfNecessary;
              v27 = AMFDRCreateInstanceString(v12, SikPubDigestIfNecessary);
              if (v27)
              {
                v28 = v27;
                v29 = CFStringCreateWithFormat(v12, 0, CFSTR("%@-%@"), a4, a5);
                v18 = v29 != 0;
                if (v29)
                {
                  v30 = v29;
                  CFDictionarySetValue((CFMutableDictionaryRef)a2, v29, v28);
                  CFRelease(v30);
                }
                else
                {
                  AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapEntrySetSikOverride", CFSTR("sikOverrideKey create failed"), v38);
                }
                CFRelease(v28);
              }
              else
              {
                AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapEntrySetSikOverride", CFSTR("sikPub is NULL"), v38);
                v18 = 0;
              }
              CFRelease(v21);
              CFRelease(v26);
              return v18;
            }
            AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapEntrySetSikOverride", CFSTR("sikPubDigest is NULL"), v38);
          }
          else
          {
            AMFDRErrorPushInternal(a6, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapEntrySetSikOverride", CFSTR("sikPubData NULL or malformed sikPub from ZG, expected CFData"), v38);
          }
          CFRelease(v21);
          return 0;
        }
        v37 = CFSTR("sikPubData NULL or malformed sikPub from ZG, expected CFData");
        *(_OWORD *)v35 = 0u;
        v36 = 0u;
        *(_OWORD *)value = 0u;
        v32 = a6;
        v33 = 29;
LABEL_23:
        AMFDRErrorPushInternal(v32, v33, 0, 0, 0, 0, 0, 0, value[0], value[1], v35[0], v35[1], (void *)v36, *((void **)&v36 + 1), (uint64_t)"_AMFDRSealingMapEntrySetSikOverride", v37, v38);
        return 0;
      }
    }
  }
  return v18;
}

BOOL _AMFDRSealingMapCopyDataClassesAndInstancesInternal(void *a1, const __CFArray *a2, int a3, const void *a4, int a5, const __CFArray *a6, const __CFArray *a7, CFTypeRef *a8, CFTypeRef *a9, CFTypeRef *a10, CFTypeRef *a11, CFTypeRef *a12, CFTypeRef *a13, CFTypeRef cf, uint64_t a15)
{
  void *v17;
  const __CFAllocator *v18;
  const CFArrayCallBacks *v19;
  __CFArray *Mutable;
  const __CFAllocator *v21;
  __CFArray *v22;
  const __CFAllocator *v23;
  CFMutableArrayRef v24;
  __CFArray *v25;
  BOOL v26;
  const __CFAllocator *v28;
  CFMutableDictionaryRef v29;
  const __CFArray *MutableCopy;
  CFMutableArrayRef v31;
  const __CFAllocator *v32;
  const __CFAllocator *v33;
  const __CFDictionary *v34;
  const __CFArray *v35;
  const __CFArray *v36;
  CFTypeID v37;
  CFTypeID v38;
  const __CFAllocator *v39;
  const __CFArray *v40;
  CFIndex v41;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v43;
  CFTypeID v44;
  CFTypeID TypeID;
  CFTypeID v46;
  __CFString *v47;
  __CFString *Value;
  CFTypeID v49;
  _BOOL8 HasAttributeInternal;
  __CFArray *v51;
  CFIndex LastIndexOfValue;
  CFIndex v53;
  const void *v54;
  const void *v55;
  __CFArray *v56;
  __CFArray *v57;
  CFTypeID v58;
  uint64_t v59;
  const __CFDictionary *EntryInternal;
  const __CFAllocator *v61;
  CFStringRef v62;
  const void *v63;
  const __CFAllocator *v64;
  CFStringRef v65;
  const __CFArray *v66;
  CFTypeID v67;
  CFIndex v68;
  const void *v69;
  const __CFString *v70;
  const __CFAllocator *v71;
  CFStringRef v72;
  const __CFAllocator *v73;
  int v74;
  uint64_t v75;
  CFTypeRef v76;
  const __CFAllocator *v77;
  CFStringRef v78;
  CFStringRef v79;
  int v80;
  CFIndex Count;
  CFIndex v82;
  CFTypeID v83;
  int v84;
  const __CFString *format;
  CFTypeID v86;
  int v87;
  char v89;
  const __CFArray *v90;
  __CFDictionary *v92;
  CFTypeRef v93;
  CFTypeRef v95;
  CFTypeRef v96;
  int v97;
  __CFArray *theArray;
  const __CFArray *v99;
  const __CFDictionary *v100;
  const __CFArray *v101;
  const void *v103;
  const void *v104;
  const __CFString *v107;
  CFRange v108;
  CFRange v109;
  CFRange v110;

  v17 = a1;
  v18 = CFGetAllocator(a1);
  v19 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  Mutable = CFArrayCreateMutable(v18, 0, MEMORY[0x24BDBD690]);
  v21 = CFGetAllocator(v17);
  v22 = CFArrayCreateMutable(v21, 0, v19);
  v23 = CFGetAllocator(v17);
  v24 = CFArrayCreateMutable(v23, 0, v19);
  v25 = v24;
  if (Mutable)
    v26 = v22 == 0;
  else
    v26 = 1;
  if (v26 || v24 == 0)
  {
    AMFDRErrorPushInternal(a15, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("failed to allocate data class/instance arrays"), v89);
    v55 = 0;
    v107 = 0;
    v66 = 0;
    v29 = 0;
LABEL_177:
    MutableCopy = 0;
    v101 = 0;
LABEL_187:
    v93 = 0;
    goto LABEL_142;
  }
  v28 = CFGetAllocator(v17);
  v29 = CFDictionaryCreateMutable(v28, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v29)
  {
    AMFDRErrorPushInternal(a15, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("failed to allocate sikOverrideDict"), v89);
    v55 = 0;
    v107 = 0;
    v66 = 0;
    goto LABEL_177;
  }
  MutableCopy = 0;
  if (a6)
  {
    v31 = 0;
    if (a7)
    {
      v32 = CFGetAllocator(v17);
      MutableCopy = CFArrayCreateMutableCopy(v32, 0, a6);
      v33 = CFGetAllocator(v17);
      v31 = CFArrayCreateMutableCopy(v33, 0, a7);
      if (!MutableCopy || !v31)
      {
        v101 = v31;
        AMFDRErrorPushInternal(a15, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("failed to allocate mutable copy of override data class/instance array"), v89);
LABEL_179:
        v55 = 0;
        v107 = 0;
        v66 = 0;
        goto LABEL_187;
      }
    }
  }
  else
  {
    v31 = 0;
  }
  v101 = v31;
  v34 = (const __CFDictionary *)AMFDRGetOptions((uint64_t)v17);
  if (!v34)
  {
    AMFDRErrorPushInternal(a15, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("amfdr options is NULL"), v89);
    goto LABEL_179;
  }
  v35 = (const __CFArray *)_CFDictionaryCopyValue(v34, CFSTR("SkipRecoverDataClasses"));
  v36 = v35;
  if (v35)
  {
    v37 = CFGetTypeID(v35);
    if (v37 != CFArrayGetTypeID())
    {
      AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("malformed skipDataClasses"), v89);
      goto LABEL_186;
    }
  }
  if (cf)
  {
    v38 = CFGetTypeID(cf);
    if (v38 == CFDictionaryGetTypeID())
    {
      v100 = (const __CFDictionary *)cf;
      CFRetain(cf);
      goto LABEL_22;
    }
    AMFDRErrorPushInternal(a15, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("queryCache has wrong type %@"), (char)cf);
LABEL_186:
    v55 = 0;
    v107 = 0;
    v66 = 0;
    goto LABEL_187;
  }
  v39 = CFGetAllocator(v17);
  v100 = CFDictionaryCreateMutable(v39, 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  if (!v100)
  {
    AMFDRErrorPushInternal(a15, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("internalQueryCache allocation failed"), v89);
    goto LABEL_186;
  }
LABEL_22:
  v92 = v29;
  v97 = AMFDRAPTicketAllowsUnsealedData((uint64_t)v17);
  v40 = a2;
  theArray = v25;
  if (CFArrayGetCount(a2) >= 1)
  {
    v95 = 0;
    v96 = 0;
    v41 = 0;
    v93 = 0;
    v107 = 0;
    v104 = v17;
    v99 = v36;
    v90 = MutableCopy;
    v103 = a4;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v40, v41);
      v43 = ValueAtIndex;
      if (!ValueAtIndex || (v44 = CFGetTypeID(ValueAtIndex), TypeID = CFDictionaryGetTypeID(), v44 != TypeID))
      {
        AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("Object of unexpected type '%@' in sealing map"), (char)v43);
        goto LABEL_149;
      }
      if (a4)
      {
        v46 = CFGetTypeID(a4);
        TypeID = CFStringGetTypeID();
        if (v46 == TypeID)
        {
          LODWORD(TypeID) = AMFDRSealingMapEntryHasAttributeInternal(TypeID, v43, a4, 0);
          if (!(_DWORD)TypeID)
            goto LABEL_91;
        }
      }
      v47 = CFSTR("minimal-manifest");
      if ((a3 & 1) == 0)
      {
        Value = (__CFString *)CFDictionaryGetValue(v43, CFSTR("Tag"));
        if (!Value)
        {
          AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
          goto LABEL_149;
        }
        v47 = Value;
        v49 = CFGetTypeID(Value);
        TypeID = CFStringGetTypeID();
        if (v49 != TypeID)
        {
          AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("Object of unexpected type '%@' for key '%@' in sealing map entry"), (char)v47);
          goto LABEL_149;
        }
      }
      if (v36
        && (v108.length = CFArrayGetCount(v36),
            v108.location = 0,
            LODWORD(TypeID) = CFArrayContainsValue(v36, v108, v47),
            (_DWORD)TypeID))
      {
        v40 = a2;
        if (_isSealingClass((_BOOL8)v47))
        {
          AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("Could not skip seal class '%@'"), (char)v47);
          goto LABEL_149;
        }
        if (v97)
        {
          AMSupportLogInternal();
          CFArrayAppendValue(v25, v47);
        }
        else
        {
          EntryInternal = AMFDRSealingMapGetEntryInternal(0, v47, 0, 0);
          if (AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, CFSTR("RequiredToSeal"), 0))
          {
            AMFDRErrorPushInternal(a15, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("Could not skip data class '%@' without unsealed data entitlement"), (char)v47);
LABEL_149:
            v55 = 0;
            goto LABEL_150;
          }
          AMSupportLogInternal();
        }
        a4 = v103;
      }
      else
      {
        HasAttributeInternal = AMFDRSealingMapEntryHasAttributeInternal(TypeID, v43, CFSTR("NonPoR"), 0);
        if (HasAttributeInternal)
        {
          if (!AMFDROptionsGetBooleanValue((uint64_t)v17, CFSTR("AttemptToRecoverNonPoRData"), 0))
            goto LABEL_90;
          AMSupportLogInternal();
        }
        if (a6)
        {
          v109.length = CFArrayGetCount(MutableCopy);
          v51 = MutableCopy;
          v109.location = 0;
          LastIndexOfValue = CFArrayGetLastIndexOfValue(MutableCopy, v109, v47);
          if (LastIndexOfValue < 0)
          {
            v110.length = CFArrayGetCount(a6);
            v110.location = 0;
            if (CFArrayContainsValue(a6, v110, v47))
            {
              AMSupportLogInternal();
              v36 = v99;
LABEL_90:
              a4 = v103;
LABEL_91:
              v40 = a2;
              goto LABEL_109;
            }
            v55 = 0;
          }
          else
          {
            v53 = LastIndexOfValue;
            v54 = CFArrayGetValueAtIndex(v101, LastIndexOfValue);
            v55 = v54;
            if (!v54)
            {
              AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("dataInstance is NULL"), v89);
              v66 = 0;
              HasAttributeInternal = 0;
LABEL_181:
              v29 = v92;
              MutableCopy = v51;
              goto LABEL_153;
            }
            v56 = v22;
            v57 = Mutable;
            v58 = CFGetTypeID(v54);
            if (v58 != CFStringGetTypeID())
            {
              AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("malformed dataInstance"), v89);
              v55 = 0;
              v66 = 0;
              HasAttributeInternal = 0;
              goto LABEL_181;
            }
            AMSupportLogInternal();
            v55 = CFRetain(v55);
            CFArrayRemoveValueAtIndex(v51, v53);
            CFArrayRemoveValueAtIndex(v101, v53);
            AMFDRGetAssemblyIDToVerify((uint64_t)v104, v47);
            v59 = AMSupportSafeRetain();
            if (v59)
            {
              v107 = (const __CFString *)v59;
              Mutable = v57;
            }
            else
            {
              v61 = CFGetAllocator(v104);
              v62 = CFStringCreateWithCString(v61, "", 0x8000100u);
              Mutable = v57;
              if (!v62)
              {
                AMFDRErrorPushInternal(a15, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("failed to create currentAssemblyID"), v89);
                v107 = 0;
                v66 = 0;
                HasAttributeInternal = 0;
                goto LABEL_181;
              }
              v107 = v62;
            }
            v22 = v56;
            v25 = theArray;
          }
          MutableCopy = v51;
          v36 = v99;
        }
        else
        {
          v55 = 0;
        }
        v63 = CFDictionaryGetValue(v43, CFSTR("MultiDataInstanceIdentifierList"));
        if (v55 || !v63)
        {
          if (!v55)
          {
            v71 = CFGetAllocator(v104);
            v55 = _copyIdentifierListForSealingMapEntry(v71, v43, v100, 0, 0, a15);
          }
          v72 = v107;
          if (!v107)
          {
            v73 = CFGetAllocator(v104);
            v72 = _copyIdentifierListForSealingMapEntry(v73, v43, v100, 1, 1, a15);
          }
          v107 = v72;
          if (v55 && v72)
          {
            if (_isSealingClass((_BOOL8)v47))
            {
              if (v96 && v95)
              {
                AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("Encountered '%@' data class twice"), (char)v47);
LABEL_150:
                v66 = 0;
LABEL_151:
                HasAttributeInternal = 0;
LABEL_152:
                v29 = v92;
                goto LABEL_153;
              }
              v96 = CFRetain(v47);
              v95 = CFRetain(v55);
              goto LABEL_104;
            }
            if (_AMFDRSealingMapEntrySetSikOverride(v104, v92, v43, (uint64_t)v47, (uint64_t)v55, a15))
            {
              CFArrayAppendValue(Mutable, v47);
              CFArrayAppendValue(v22, v55);
              AMFDRSetAssemblyIdentifierToVerify((uint64_t)v104, v47, v107);
              v75 = (uint64_t)v93;
              v40 = a2;
              if (v93)
                CFRelease(v93);
              v76 = AMFDRSealingMapCopySubCCNameListWithAttributeForSealingMapEntry(v75, v43, CFSTR("RequireSubCCDigest"));
              if (v76)
              {
                v93 = v76;
                AMFDRSetSubCCDigestsToVerify((uint64_t)v104, v47, v76);
              }
              else
              {
                v93 = 0;
              }
              MutableCopy = v90;
            }
            else
            {
              v77 = CFGetAllocator(v104);
              v78 = CFStringCreateWithFormat(v77, 0, CFSTR("%@-%@"), v47, v55);
              if (!v78)
              {
                AMFDRErrorPushInternal(a15, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("dataClassInstanceWithoutSikPub create failed"), v89);
                v66 = 0;
                HasAttributeInternal = 0;
                v29 = v92;
                MutableCopy = v90;
                goto LABEL_153;
              }
              v79 = v78;
              CFArrayAppendValue(theArray, v78);
              CFRelease(v79);
              if (a5 && AMFDRSealingMapEntryHasAttributeInternal(v80, v43, CFSTR("AllowSikPubMissingWhenUnseal"), 0))
              {
                AMSupportLogInternal();
                MutableCopy = v90;
              }
              else
              {
                MutableCopy = v90;
                if (!(HasAttributeInternal | AMFDRAllowIncompleteData((uint64_t)v104)))
                {
                  AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("_AMFDRSealingMapEntrySetSikOverride failed"), v89);
                  v66 = 0;
                  HasAttributeInternal = 0;
                  v29 = v92;
                  goto LABEL_153;
                }
              }
              v25 = theArray;
              v36 = v99;
LABEL_104:
              v40 = a2;
            }
            CFRelease(v55);
            v70 = v107;
            a4 = v103;
            v17 = (void *)v104;
            goto LABEL_108;
          }
          v74 = AMFDRAllowIncompleteData((uint64_t)v104);
          if (((a3 & a5 | v74) & 1) == 0)
          {
            if (a5)
            {
              if (!AMFDRSealingMapEntryHasAttributeInternal(v74, v43, CFSTR("FusedByRestore"), 0)
                && !HasAttributeInternal)
              {
                goto LABEL_147;
              }
            }
            else if (!HasAttributeInternal)
            {
LABEL_147:
              AMFDRErrorPushInternal(a15, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("Could not get data instance for data class '%@'"), (char)v47);
              goto LABEL_150;
            }
          }
          AMSupportLogInternal();
          CFArrayAppendValue(v25, v47);
          if (v55)
            CFRelease(v55);
          v40 = a2;
          a4 = v103;
          if (v107)
            CFRelease(v107);
          v107 = 0;
          v17 = (void *)v104;
        }
        else
        {
          v17 = (void *)v104;
          v64 = CFGetAllocator(v104);
          v65 = _copyIdentifierListForSealingMapEntry(v64, v43, v100, 0, 0, a15);
          if (!v65)
          {
            if (!AMFDRAllowIncompleteData((uint64_t)v104) && !HasAttributeInternal)
            {
              AMFDRErrorPushInternal(a15, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("Could not get data instance for data class '%@'"), (char)v47);
              v55 = 0;
              v66 = 0;
              goto LABEL_152;
            }
            AMSupportLogInternal();
            CFArrayAppendValue(v25, v47);
            goto LABEL_90;
          }
          v66 = (const __CFArray *)v65;
          v67 = CFGetTypeID(v65);
          if (v67 != CFArrayGetTypeID())
          {
            AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("malformed dataInstance, expected CFArray"), v89);
            v55 = 0;
            goto LABEL_151;
          }
          if (CFArrayGetCount(v66) >= 1)
          {
            v68 = 0;
            do
            {
              v69 = CFArrayGetValueAtIndex(v66, v68);
              CFArrayAppendValue(Mutable, v47);
              CFArrayAppendValue(v22, v69);
              AMSupportLogInternal();
              ++v68;
            }
            while (v68 < CFArrayGetCount(v66));
          }
          CFRelease(v66);
          v70 = v107;
          if (v107)
          {
            a4 = v103;
            v17 = (void *)v104;
            v40 = a2;
            v25 = theArray;
            v36 = v99;
LABEL_108:
            CFRelease(v70);
            v107 = 0;
            goto LABEL_109;
          }
          v107 = 0;
          a4 = v103;
          v17 = (void *)v104;
          v40 = a2;
          v25 = theArray;
          v36 = v99;
        }
      }
LABEL_109:
      if (++v41 >= CFArrayGetCount(v40))
        goto LABEL_112;
    }
  }
  v107 = 0;
  v93 = 0;
  v95 = 0;
  v96 = 0;
LABEL_112:
  if (!CFArrayGetCount(Mutable))
  {
    v29 = v92;
    if (!a4 || (v83 = CFGetTypeID(a4), v83 != CFStringGetTypeID()))
    {
      v84 = AMFDRAllowIncompleteData((uint64_t)v17);
      if ((a3 & a5 & 1) == 0 && !v84)
      {
        format = CFSTR("No data classes to recover");
LABEL_140:
        AMFDRErrorPushInternal(a15, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", format, v89);
LABEL_141:
        v55 = 0;
        v66 = 0;
LABEL_142:
        HasAttributeInternal = 0;
        goto LABEL_153;
      }
    }
LABEL_146:
    AMSupportLogInternal();
    v55 = 0;
    v66 = 0;
    HasAttributeInternal = 1;
    goto LABEL_153;
  }
  v29 = v92;
  if (!CFArrayGetCount(v22))
  {
    if (!a4 || (v86 = CFGetTypeID(a4), v86 != CFStringGetTypeID()))
    {
      v87 = AMFDRAllowIncompleteData((uint64_t)v17);
      if ((a3 & a5 & 1) == 0 && !v87)
      {
        format = CFSTR("No data instances to recover");
        goto LABEL_140;
      }
    }
    goto LABEL_146;
  }
  Count = CFArrayGetCount(Mutable);
  if (Count != CFArrayGetCount(v22))
  {
    AMFDRErrorPushInternal(a15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstancesInternal", CFSTR("Must have a data instance for each data class to recover"), v89);
    goto LABEL_141;
  }
  if (a8 && v96)
    *a8 = CFRetain(v96);
  if (a9 && v95)
    *a9 = CFRetain(v95);
  if (a10)
    *a10 = CFRetain(Mutable);
  if (a11)
    *a11 = CFRetain(v22);
  if (a12)
  {
    *a12 = CFRetain(theArray);
    if (CFArrayGetCount(theArray) >= 1)
    {
      v82 = CFArrayGetCount(theArray);
      AMFDRSetStat((CFMutableDictionaryRef *)v17, CFSTR("FDRMissingDataInstance"), v82);
    }
  }
  v55 = 0;
  v66 = 0;
  if (a13)
    *a13 = CFRetain(v92);
  HasAttributeInternal = 1;
LABEL_153:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (v66)
    CFRelease(v66);
  if (v55)
    CFRelease(v55);
  if (v107)
    CFRelease(v107);
  if (v29)
    CFRelease(v29);
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (v101)
    CFRelease(v101);
  if (v93)
    CFRelease(v93);
  return HasAttributeInternal;
}

BOOL _isSealingClass(_BOOL8 result)
{
  const __CFString *v1;
  const __CFString *v2;
  const __CFString *v3;
  CFComparisonResult v4;

  if (result)
  {
    v1 = (const __CFString *)result;
    v2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], "seal", 0x8000100u);
    if (v2)
    {
      v3 = v2;
      v4 = CFStringCompare(v1, v2, 0);
      CFRelease(v3);
      return v4 == kCFCompareEqualTo;
    }
    else
    {
      AMSupportLogInternal();
      return 0;
    }
  }
  return result;
}

CFTypeRef AMFDRSealingMapCopySubCCNameListWithAttributeForSealingMapEntry(uint64_t a1, const __CFDictionary *a2, const void *a3)
{
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  const void *Value;
  const void *v8;
  CFTypeID TypeID;
  CFIndex v10;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v12;
  CFTypeID v13;
  const void *v14;
  const void *v15;
  CFTypeID v16;
  CFTypeID v17;
  CFTypeRef v18;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMSupportLogInternal();
    return 0;
  }
  v6 = Mutable;
  if (!a2)
    goto LABEL_17;
  Value = CFDictionaryGetValue(a2, CFSTR("SubCCList"));
  if (!Value)
    goto LABEL_17;
  v8 = Value;
  TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(v8))
    goto LABEL_17;
  if (CFArrayGetCount((CFArrayRef)v8) >= 1)
  {
    v10 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v8, v10);
      v12 = ValueAtIndex;
      if (!ValueAtIndex)
        break;
      v13 = CFGetTypeID(ValueAtIndex);
      if (v13 != CFDictionaryGetTypeID())
        break;
      v14 = CFDictionaryGetValue(v12, CFSTR("Tag"));
      if (!v14)
        break;
      v15 = v14;
      v16 = CFGetTypeID(v14);
      v17 = CFStringGetTypeID();
      if (v16 != v17)
        break;
      if (AMFDRSealingMapEntryHasAttributeInternal(v17, v12, a3, 0))
        CFArrayAppendValue(v6, v15);
      if (++v10 >= CFArrayGetCount((CFArrayRef)v8))
        goto LABEL_14;
    }
LABEL_17:
    AMSupportLogInternal();
    v18 = 0;
    goto LABEL_15;
  }
LABEL_14:
  v18 = CFRetain(v6);
LABEL_15:
  CFRelease(v6);
  return v18;
}

const __CFDictionary *AMFDRSealingMapGetPairedSoCs(uint64_t a1)
{
  const __CFDictionary *result;

  result = AMFDRSealingMapGetEntryInternal(a1, CFSTR("seal"), 0, 0);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("PairedSoC"));
  return result;
}

uint64_t AMFDRSealingMapCopyMinimalManifestDataInstancesWithAttribute(void *a1, const void *a2, CFTypeRef *a3, CFTypeRef *a4, uint64_t a5)
{
  const __CFAllocator *v10;
  const CFArrayCallBacks *v11;
  CFMutableArrayRef Mutable;
  const __CFAllocator *v13;
  CFMutableArrayRef v14;
  const __CFArray *EntriesForDeviceInternal;
  const __CFArray *v16;
  CFIndex v17;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v19;
  CFTypeID v20;
  const __CFArray *Value;
  const __CFArray *v22;
  const __CFArray *v23;
  const __CFArray *v24;
  CFIndex Count;
  uint64_t v26;
  char v28;
  CFTypeRef *v29;
  CFTypeRef *v30;
  CFTypeRef v31;
  CFTypeRef v32;
  CFRange v33;
  CFRange v34;

  v31 = 0;
  v32 = 0;
  v10 = CFGetAllocator(a1);
  v11 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x24BDBD690]);
  v13 = CFGetAllocator(a1);
  v14 = CFArrayCreateMutable(v13, 0, v11);
  EntriesForDeviceInternal = (const __CFArray *)AMFDRSealingMapGetEntriesForDeviceInternal(0);
  if (!EntriesForDeviceInternal)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMinimalManifestDataInstancesWithAttribute", CFSTR("Could not get sealing map"), v28);
    v26 = 0;
    goto LABEL_24;
  }
  v16 = EntriesForDeviceInternal;
  v29 = a3;
  v30 = a4;
  if (CFArrayGetCount(EntriesForDeviceInternal) < 1)
  {
LABEL_16:
    if (CFArrayGetCount(Mutable))
    {
      if (v29)
        *v29 = CFRetain(Mutable);
      if (v30)
      {
        *v30 = CFRetain(v14);
        if (CFArrayGetCount(v14) >= 1)
        {
          Count = CFArrayGetCount(v14);
          AMFDRSetStat((CFMutableDictionaryRef *)a1, CFSTR("FDRMissingDataInstance"), Count);
        }
      }
      v26 = 1;
    }
    else
    {
      v26 = 1;
    }
    goto LABEL_24;
  }
  v17 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v16, v17);
    v19 = ValueAtIndex;
    if (!ValueAtIndex || (v20 = CFGetTypeID(ValueAtIndex), v20 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMinimalManifestDataInstancesWithAttribute", CFSTR("Object of unexpected type '%@' in sealing map"), (char)v19);
      goto LABEL_35;
    }
    Value = (const __CFArray *)CFDictionaryGetValue(v19, CFSTR("MinimalSealingManifest"));
    if (Value)
      break;
LABEL_15:
    if (++v17 >= CFArrayGetCount(v16))
      goto LABEL_16;
  }
  v22 = Value;
  if (v32)
  {
    CFRelease(v32);
    v32 = 0;
  }
  if (v31)
  {
    CFRelease(v31);
    v31 = 0;
  }
  if (_AMFDRSealingMapCopyDataClassesAndInstancesInternal(a1, v22, 1, a2, 0, 0, 0, 0, 0, 0, &v32, &v31, 0, 0, a5))
  {
    if (v32 && CFArrayGetCount((CFArrayRef)v32))
    {
      v23 = (const __CFArray *)v32;
      v33.length = CFArrayGetCount((CFArrayRef)v32);
      v33.location = 0;
      CFArrayAppendArray(Mutable, v23, v33);
      v24 = (const __CFArray *)v31;
      v34.length = CFArrayGetCount((CFArrayRef)v31);
      v34.location = 0;
      CFArrayAppendArray(v14, v24, v34);
    }
    goto LABEL_15;
  }
  AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyMinimalManifestDataInstancesWithAttribute", CFSTR("_AMFDRSealingMapCopyDataClassesAndInstancesInternal failed"), v28);
LABEL_35:
  v26 = 0;
LABEL_24:
  if (v32)
  {
    CFRelease(v32);
    v32 = 0;
  }
  if (v31)
  {
    CFRelease(v31);
    v31 = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v14)
    CFRelease(v14);
  return v26;
}

uint64_t AMFDRSealingMapCopyManifestPropertiesForDevice(CFDictionaryRef *a1, const __CFDictionary *a2, CFTypeRef *a3, CFTypeRef *a4, uint64_t a5)
{
  const void *Value;
  unint64_t v10;
  unint64_t v11;
  CFTypeID v12;
  CFTypeID v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex v16;
  const void *ValueAtIndex;
  CFTypeID v18;
  CFTypeID v19;
  CFIndex v20;
  CFIndex v21;
  CFIndex v22;
  const void *v23;
  CFTypeID v24;
  const __CFAllocator *v25;
  CFMutableDictionaryRef MutableCopy;
  const __CFString *format;
  uint64_t v28;
  CFMutableDictionaryRef v29;
  const __CFAllocator *v30;
  CFMutableArrayRef Mutable;
  const __CFArray *ManifestPropertyEntriesForDevice;
  const __CFArray *v33;
  CFIndex v34;
  const __CFDictionary *v35;
  const __CFDictionary *v36;
  CFTypeID v37;
  const __CFString *v38;
  const __CFString *v39;
  CFTypeID v40;
  _BOOL4 v41;
  _BOOL4 v42;
  const __CFAllocator *v43;
  void *v44;
  const void *v45;
  CFTypeID v46;
  char v48;
  uint64_t v49;
  CFTypeRef *v50;
  CFTypeRef cf;
  CFMutableArrayRef v52;
  CFRange v54;
  CFRange v55;

  if (!a3)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("outManifestProperties is NULL"), v48);
    goto LABEL_24;
  }
  Value = CFDictionaryGetValue(a1[2], CFSTR("SealingUpdateProperties"));
  v10 = (unint64_t)CFDictionaryGetValue(a1[2], CFSTR("SealingExcludeProperties"));
  v11 = (unint64_t)CFDictionaryGetValue(a1[2], CFSTR("SealingPropertiesOverride"));
  cf = CFDictionaryGetValue(a1[2], CFSTR("AllowPropertyMismatch"));
  if (v11 | v10)
  {
    if ((AMFDREntitlementIsEntitled(CFSTR("com.apple.libFDR.AllowIdentifierOverride")) & 1) == 0)
    {
      AMFDRErrorPushInternal(a5, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("Missing AllowIdentifierOverride entitlement"), v48);
      goto LABEL_24;
    }
    if (v11)
    {
      v12 = CFGetTypeID((CFTypeRef)v11);
      if (v12 != CFDictionaryGetTypeID())
      {
        format = CFSTR("propertiesOverride is not a dictionary");
        goto LABEL_23;
      }
    }
    if (v10)
    {
      v13 = CFGetTypeID((CFTypeRef)v10);
      if (v13 != CFArrayGetTypeID())
      {
        format = CFSTR("propertiesToExclude is not an array");
        goto LABEL_23;
      }
      Count = CFArrayGetCount((CFArrayRef)v10);
      if (Count >= 1)
      {
        v15 = Count;
        v16 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v10, v16);
          if (!ValueAtIndex)
            break;
          v18 = CFGetTypeID(ValueAtIndex);
          if (v18 != CFStringGetTypeID())
            break;
          if (v15 == ++v16)
            goto LABEL_13;
        }
        AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("Object at index %ld in SealingExcludeProperties is not a string"), v16);
LABEL_24:
        v28 = 0;
        goto LABEL_64;
      }
    }
  }
LABEL_13:
  if (Value)
  {
    v19 = CFGetTypeID(Value);
    if (v19 == CFArrayGetTypeID())
    {
      v20 = CFArrayGetCount((CFArrayRef)Value);
      if (v20 >= 1)
      {
        v21 = v20;
        v22 = 0;
        while (1)
        {
          v23 = CFArrayGetValueAtIndex((CFArrayRef)Value, v22);
          if (!v23)
            break;
          v24 = CFGetTypeID(v23);
          if (v24 != CFStringGetTypeID())
            break;
          if (v21 == ++v22)
            goto LABEL_20;
        }
        format = CFSTR("malformed property");
        goto LABEL_23;
      }
      goto LABEL_20;
    }
    format = CFSTR("kAMFDROptionUpdateProperties is not array");
LABEL_23:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", format, v48);
    goto LABEL_24;
  }
LABEL_20:
  v25 = CFGetAllocator(a1);
  if (v11)
    MutableCopy = CFDictionaryCreateMutableCopy(v25, 0, (CFDictionaryRef)v11);
  else
    MutableCopy = CFDictionaryCreateMutable(v25, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v29 = MutableCopy;
  if (!MutableCopy)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("Failed to allocate manifestProperties "), v48);
    goto LABEL_24;
  }
  v30 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v30, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("Failed to allocate missingPropertyTags "), v48);
    goto LABEL_24;
  }
  ManifestPropertyEntriesForDevice = (const __CFArray *)_AMFDRSealingMapGetManifestPropertyEntriesForDevice((uint64_t)a1);
  if (!ManifestPropertyEntriesForDevice)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("Could not get manifest properties"), v48);
    goto LABEL_24;
  }
  v33 = ManifestPropertyEntriesForDevice;
  v50 = a4;
  v52 = Mutable;
  v49 = a5;
  if (CFArrayGetCount(ManifestPropertyEntriesForDevice) < 1)
  {
LABEL_56:
    if (CFDictionaryGetCount(v29))
    {
      if (CFDictionaryGetCount(v29))
        *a3 = CFRetain(v29);
      if (v50 && CFArrayGetCount(v52))
        *v50 = CFRetain(v52);
      v28 = 1;
    }
    else
    {
      v28 = 1;
    }
    goto LABEL_64;
  }
  v34 = 0;
  while (1)
  {
    v35 = (const __CFDictionary *)CFArrayGetValueAtIndex(v33, v34);
    v36 = v35;
    if (!v35 || (v37 = CFGetTypeID(v35), v37 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(v49, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("Object of unexpected type '%@' in manifest property entries"), (char)v36);
      goto LABEL_70;
    }
    v38 = (const __CFString *)CFDictionaryGetValue(v36, CFSTR("Tag"));
    if (!v38)
    {
      AMFDRErrorPushInternal(v49, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("Missing key '%@' in manifest property entry"), (char)CFSTR("Tag"));
      goto LABEL_70;
    }
    v39 = v38;
    v40 = CFGetTypeID(v38);
    if (v40 != CFStringGetTypeID())
    {
      AMFDRErrorPushInternal(v49, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("Object of unexpected type '%@' for key '%@' in manifest property entry"), (char)v39);
      goto LABEL_70;
    }
    if (CFStringGetLength(v39) != 4)
      break;
    if (Value)
    {
      v54.length = CFArrayGetCount((CFArrayRef)Value);
      v54.location = 0;
      v41 = CFArrayContainsValue((CFArrayRef)Value, v54, v39) != 0;
      if (!v10)
        goto LABEL_42;
    }
    else
    {
      v41 = 1;
      if (!v10)
        goto LABEL_42;
    }
    v55.length = CFArrayGetCount((CFArrayRef)v10);
    v55.location = 0;
    if (CFArrayContainsValue((CFArrayRef)v10, v55, v39))
    {
      AMSupportLogInternal();
      CFDictionaryContainsKey(v29, v39);
      goto LABEL_55;
    }
LABEL_42:
    if (CFDictionaryContainsKey(v29, v39))
      v42 = 0;
    else
      v42 = v41;
    if (v42)
    {
      v43 = CFGetAllocator(a1);
      v44 = _copyMGValuePropertyEntry(v43, v36, a2);
      if (v44)
      {
        v45 = v44;
        CFDictionaryAddValue(v29, v39, v44);
        CFRelease(v45);
      }
      else
      {
        if (_propertyEntryHasAttribute(v36, CFSTR("Required"), 0))
        {
          if ((AMFDRAllowIncompleteData((uint64_t)a1) & 1) == 0)
          {
            if (!cf || (v46 = CFGetTypeID(cf), v46 != CFBooleanGetTypeID()) || !CFBooleanGetValue((CFBooleanRef)cf))
            {
              AMFDRErrorPushInternal(v49, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("missing required property %@"), (char)v39);
              goto LABEL_24;
            }
          }
          AMSupportLogInternal();
        }
        AMSupportLogInternal();
        CFArrayAppendValue(v52, v39);
      }
    }
LABEL_55:
    if (++v34 >= CFArrayGetCount(v33))
      goto LABEL_56;
  }
  AMFDRErrorPushInternal(v49, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestPropertiesForDevice", CFSTR("Key '%@' length should be 4 for '%@' in manifest property entry"), (char)v39);
LABEL_70:
  v28 = 0;
LABEL_64:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v28;
}

BOOL _propertyEntryHasAttribute(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  const __CFArray *Value;
  const __CFArray *v6;
  CFTypeID TypeID;
  CFRange v9;

  Value = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("PropertyAttributes"));
  if (Value)
  {
    v6 = Value;
    TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(v6))
    {
      v9.length = CFArrayGetCount(v6);
      v9.location = 0;
      return CFArrayContainsValue(v6, v9, a2) != 0;
    }
  }
  return a3;
}

BOOL AMFDRSealingMapPropertyHasAttribute(uint64_t a1, const __CFString *cf, const void *a3, uint64_t a4)
{
  CFTypeID v8;
  const __CFArray *ManifestPropertyEntriesForDevice;
  const __CFArray *v10;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v13;
  CFTypeID v14;
  const __CFString *Value;

  if (a1)
  {
    if (cf)
    {
      v8 = CFGetTypeID(cf);
      if (v8 == CFStringGetTypeID() && CFStringGetLength(cf) == 4)
      {
        ManifestPropertyEntriesForDevice = (const __CFArray *)_AMFDRSealingMapGetManifestPropertyEntriesForDevice(a1);
        if (ManifestPropertyEntriesForDevice)
        {
          v10 = ManifestPropertyEntriesForDevice;
          if (CFArrayGetCount(ManifestPropertyEntriesForDevice) >= 1)
          {
            for (i = 0; i < CFArrayGetCount(v10); ++i)
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, i);
              v13 = ValueAtIndex;
              if (!ValueAtIndex)
                break;
              v14 = CFGetTypeID(ValueAtIndex);
              if (v14 != CFDictionaryGetTypeID())
                break;
              Value = (const __CFString *)CFDictionaryGetValue(v13, CFSTR("Tag"));
              if (CFStringCompare(cf, Value, 0) == kCFCompareEqualTo)
                return _propertyEntryHasAttribute(v13, a3, a4);
            }
          }
        }
      }
    }
  }
  AMSupportLogInternal();
  return a4;
}

uint64_t AMFDRSealingMapPopulateMinimalSealingManifest(CFDictionaryRef *a1, _QWORD *a2, uint64_t a3)
{
  const __CFDictionary *v5;
  __CFDictionary *v7;
  __CFDictionary *Mutable;
  __CFDictionary *v9;
  CFDictionaryRef Copy;
  CFDataRef v11;
  int v12;
  CFTypeRef v13;
  uint64_t v14;
  CFTypeID v15;
  const __CFAllocator *v16;
  const __CFAllocator *v17;
  __CFDictionary *MutableCopy;
  const void *v19;
  const __CFAllocator *v20;
  CFTypeID v21;
  CFIndex v22;
  const __CFString *ValueAtIndex;
  const __CFString *v24;
  CFDataRef v25;
  CFTypeID v27;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  CFTypeRef v31;
  CFTypeRef cf;

  v31 = 0;
  cf = 0;
  if (!a1)
  {
    v28 = CFSTR("amfdr is NULL");
LABEL_49:
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapPopulateMinimalSealingManifest", v28, (char)v30);
    v14 = 0;
    goto LABEL_50;
  }
  v5 = a1[2];
  if (!v5)
  {
    v28 = CFSTR("amfdr option is NULL");
    goto LABEL_49;
  }
  v7 = (__CFDictionary *)_CFDictionaryCopyValue(v5, CFSTR("MinimalSealingManifests"));
  if (v7)
  {
    Mutable = v7;
    v9 = 0;
    Copy = 0;
    v11 = 0;
    if (a2)
      *a2 = CFRetain(v7);
LABEL_22:
    v14 = 1;
    goto LABEL_23;
  }
  v12 = AMFDRDataCopySealingManifestProperty(a1, CFSTR("meta"), (uint64_t)&cf);
  Copy = 0;
  v13 = cf;
  v14 = 1;
  if (v12 && cf)
  {
    v15 = CFGetTypeID(cf);
    if (v15 == CFDataGetTypeID())
    {
      v16 = CFGetAllocator(a1);
      Copy = CFDictionaryCreateCopy(v16, a1[2]);
      if (Copy)
      {
        v17 = CFGetAllocator(a1);
        MutableCopy = CFDictionaryCreateMutableCopy(v17, 0, a1[2]);
        v9 = MutableCopy;
        if (!MutableCopy)
        {
          AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapPopulateMinimalSealingManifest", CFSTR("newOptions is NULL"), (char)v30);
          v14 = 0;
          goto LABEL_25;
        }
        v19 = (const void *)*MEMORY[0x24BDBD268];
        CFDictionarySetValue(MutableCopy, CFSTR("VerifyData"), (const void *)*MEMORY[0x24BDBD268]);
        CFDictionarySetValue(v9, CFSTR("SignData"), v19);
        CFDictionarySetValue(v9, CFSTR("GetCombined"), v19);
        AMFDRSetOptions((uint64_t)a1, v9);
        v20 = CFGetAllocator(a1);
        Mutable = CFDictionaryCreateMutable(v20, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        if (!AMFDRDataDecodeMetaProperty((const __CFData *)cf, &v31))
        {
          AMFDRSetOptions((uint64_t)a1, Copy);
          v29 = CFSTR("AMFDRDataDecodeMetaProperty failed");
          goto LABEL_54;
        }
        if (v31 && (v21 = CFGetTypeID(v31), v21 == CFArrayGetTypeID()))
        {
          if (CFArrayGetCount((CFArrayRef)v31) >= 1)
          {
            v22 = 0;
            v11 = 0;
            while (1)
            {
              if (v11)
                CFRelease(v11);
              ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v31, v22);
              if (!ValueAtIndex)
              {
                v29 = CFSTR("dataInstance is NULL");
                goto LABEL_54;
              }
              v24 = ValueAtIndex;
              v25 = AMFDRDataCopy((uint64_t)a1, CFSTR("minimal-manifest"), ValueAtIndex, a3);
              if (!v25)
                break;
              v11 = v25;
              CFDictionarySetValue(Mutable, v24, v25);
              if (++v22 >= CFArrayGetCount((CFArrayRef)v31))
                goto LABEL_45;
            }
            AMFDRSetOptions((uint64_t)a1, Copy);
            v30 = CFSTR("minimal-manifest");
            v29 = CFSTR("%@:%@ is NULL");
LABEL_54:
            AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapPopulateMinimalSealingManifest", v29, (char)v30);
            v14 = 0;
            if (Mutable)
            {
              v11 = 0;
LABEL_23:
              CFRelease(Mutable);
              if (!v11)
                goto LABEL_25;
              goto LABEL_24;
            }
            goto LABEL_25;
          }
          v11 = 0;
LABEL_45:
          AMSupportLogInternal();
          if (!a2)
          {
LABEL_38:
            AMFDRSetOptions((uint64_t)a1, Copy);
            if (Mutable)
            {
              v27 = CFGetTypeID(Mutable);
              if (v27 == CFDictionaryGetTypeID() && CFDictionaryGetCount(Mutable) >= 1)
                AMFDRSetOption((uint64_t)a1, CFSTR("MinimalSealingManifests"), (const __CFString *)Mutable);
              goto LABEL_22;
            }
            v14 = 1;
            if (v11)
LABEL_24:
              CFRelease(v11);
LABEL_25:
            v13 = cf;
            if (!cf)
              goto LABEL_27;
            goto LABEL_26;
          }
        }
        else
        {
          v11 = 0;
          if (!a2)
            goto LABEL_38;
        }
        *a2 = AMSupportSafeRetain();
        goto LABEL_38;
      }
      AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapPopulateMinimalSealingManifest", CFSTR("originalOptions is NULL"), (char)v30);
      v14 = 0;
LABEL_51:
      v9 = 0;
      goto LABEL_25;
    }
LABEL_50:
    Copy = 0;
    goto LABEL_51;
  }
  v9 = 0;
  if (cf)
  {
LABEL_26:
    CFRelease(v13);
    cf = 0;
  }
LABEL_27:
  if (v9)
    CFRelease(v9);
  if (Copy)
    CFRelease(Copy);
  if (v31)
    CFRelease(v31);
  return v14;
}

uint64_t AMFDRSealingMapPopulateSealingManifest(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  const __CFDictionary *v5;
  const __CFString *v7;
  const __CFString *v8;
  __CFDictionary *MutableCopy;
  CFDictionaryRef Copy;
  uint64_t v11;
  const __CFAllocator *v12;
  const __CFAllocator *v13;
  const __CFString *v14;
  uint64_t v15;
  const __CFString *PermissionsString;
  const void *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  char v24;

  if (!a1)
  {
    v21 = CFSTR("amfdr is NULL");
LABEL_33:
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapPopulateSealingManifest", v21, v24);
    return 0;
  }
  v5 = *(const __CFDictionary **)(a1 + 16);
  if (!v5)
  {
    v21 = CFSTR("amfdr option is NULL");
    goto LABEL_33;
  }
  v7 = (const __CFString *)_CFDictionaryCopyValue(v5, CFSTR("SealingManifest"));
  if (v7)
  {
    v8 = v7;
    MutableCopy = 0;
    Copy = 0;
    if (a2)
      *a2 = CFRetain(v7);
    v15 = 1;
    goto LABEL_25;
  }
  v11 = _AMFDRSealingMapCopyIdentifierListForClass(CFSTR("seal"), a3, 0, 0);
  if (!v11)
  {
    v21 = CFSTR("Could not get Sealed Data Instance");
    goto LABEL_33;
  }
  v8 = (const __CFString *)v11;
  v12 = CFGetAllocator((CFTypeRef)a1);
  Copy = CFDictionaryCreateCopy(v12, *(CFDictionaryRef *)(a1 + 16));
  if (!Copy)
  {
    MutableCopy = 0;
    v22 = CFSTR("originalOptions is NULL");
LABEL_38:
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapPopulateSealingManifest", v22, v24);
    v15 = 0;
    goto LABEL_25;
  }
  v13 = CFGetAllocator((CFTypeRef)a1);
  MutableCopy = CFDictionaryCreateMutableCopy(v13, 0, *(CFDictionaryRef *)(a1 + 16));
  if (!MutableCopy)
  {
    v22 = CFSTR("newOptions is NULL");
    goto LABEL_38;
  }
  if (*(uint64_t (***)(int, int, int, int))(a1 + 48) != AMFDRHTTPStore)
  {
    v14 = 0;
    goto LABEL_14;
  }
  PermissionsString = AMFDRDataCreatePermissionsString((__CFString *)a1, 0, CFSTR("seal"), v8);
  if (!PermissionsString)
  {
    v22 = CFSTR("permission is NULL");
    goto LABEL_38;
  }
  v14 = PermissionsString;
  CFDictionarySetValue(MutableCopy, CFSTR("Permissions"), PermissionsString);
LABEL_14:
  v17 = (const void *)*MEMORY[0x24BDBD268];
  CFDictionarySetValue(MutableCopy, CFSTR("VerifyData"), (const void *)*MEMORY[0x24BDBD268]);
  CFDictionarySetValue(MutableCopy, CFSTR("SignData"), v17);
  CFDictionarySetValue(MutableCopy, CFSTR("GetCombined"), v17);
  AMFDRSetOptions(a1, MutableCopy);
  v18 = (const __CFString *)AMFDRDataCopy(a1, CFSTR("seal"), v8, a3);
  AMFDRSetOptions(a1, Copy);
  if (!v18)
  {
    v23 = CFSTR("sealingManifest is NULL");
LABEL_40:
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapPopulateSealingManifest", v23, v24);
    v15 = 0;
    goto LABEL_22;
  }
  if (*(uint64_t (***)(int, int, int, int))(a1 + 48) != AMFDRHTTPStore)
  {
    AMFDRSetOption(a1, CFSTR("SealingManifest"), v18);
    goto LABEL_18;
  }
  if ((AMFDRDataDecodeAndSetSealingManifest((_QWORD *)a1, (CFDataRef)v18, (uint64_t)v8, 0, 0, a3) & 1) == 0)
  {
    AMFDRSetOptions(a1, Copy);
    v23 = CFSTR("AMFDRDataDecodeAndSetSealingManifest failed");
    goto LABEL_40;
  }
LABEL_18:
  if (a2)
  {
    CFRelease(v18);
    v19 = (const __CFString *)_CFDictionaryCopyValue(*(const __CFDictionary **)(a1 + 16), CFSTR("SealingManifest"));
    v18 = v19;
    if (v19)
      *a2 = CFRetain(v19);
  }
  v15 = 1;
LABEL_22:
  CFRelease(v8);
  if (v14)
    CFRelease(v14);
  v8 = v18;
  if (v18)
  {
LABEL_25:
    CFRelease(v8);
    if (!MutableCopy)
      goto LABEL_27;
  }
  CFRelease(MutableCopy);
LABEL_27:
  if (Copy)
    CFRelease(Copy);
  return v15;
}

uint64_t AMFDRSealingMapRevertCurrentDevice(uint64_t a1, uint64_t a2)
{
  const __CFString *v4;
  __CFString *v5;
  uint64_t v6;
  const __CFString *PermissionsString;
  uint64_t v8;
  char v10;

  if (!a1)
  {
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRevertCurrentDevice", CFSTR("amfdr is NULL"), v10);
    v8 = 0;
    goto LABEL_7;
  }
  v4 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(CFSTR("seal"), a2, 0, 0);
  if (!v4)
  {
    AMFDRErrorPushInternal(a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRevertCurrentDevice", CFSTR("sealedDataInstance is NULL"), v10);
    v8 = 0;
    goto LABEL_7;
  }
  v5 = (__CFString *)AMFDRCreateCopy(a1);
  v6 = (uint64_t)v5;
  if (!v5)
  {
    AMFDRErrorPushInternal(a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRevertCurrentDevice", CFSTR("cannot create a separate amfdr object for revert"), v10);
    v8 = 0;
    goto LABEL_7;
  }
  PermissionsString = AMFDRDataCreatePermissionsString(v5, 0xEu, CFSTR("seal"), v4);
  if (!PermissionsString)
  {
    AMSupportLogInternal();
LABEL_14:
    v8 = 0;
    goto LABEL_7;
  }
  AMFDRSetOption(v6, CFSTR("Permissions"), PermissionsString);
  if ((AMFDRDataRevert(v6) & 1) == 0)
  {
    AMFDRErrorPushInternal(a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRevertCurrentDevice", CFSTR("AMFDRDataRevert return false"), v10);
    goto LABEL_14;
  }
  v8 = 1;
LABEL_7:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v8;
}

uint64_t AMFDRSealingMapRecoverCurrentDevice(CFMutableDictionaryRef *a1, CFMutableDictionaryRef *a2, int a3, uint64_t a4)
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v9;
  CFTypeID v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  const void *v13;
  const void *v14;
  const __CFBoolean *v15;
  unint64_t v16;
  const __CFArray *v17;
  const __CFArray *v18;
  const __CFString *v19;
  _QWORD *v20;
  uint64_t v21;
  CFTypeID v22;
  CFTypeID v23;
  CFIndex Count;
  CFTypeID v25;
  CFTypeID v26;
  CFTypeID v27;
  int v28;
  char v29;
  _BOOL4 v30;
  CFMutableDictionaryRef *v31;
  CFTypeRef *v32;
  uint64_t v33;
  const __CFBoolean *v34;
  const __CFBoolean *v35;
  CFTypeID v36;
  const void *v37;
  const void *v38;
  CFTypeID v39;
  const void *RepairConfigurationEntries;
  const void *v41;
  CFTypeID v42;
  char v43;
  __CFDictionary *RepairConfigurationAsidMetadataInternalBlob;
  __CFDictionary *v45;
  CFTypeID v46;
  const void *v47;
  const __CFAllocator *v48;
  const CFArrayCallBacks *v49;
  __CFArray *v50;
  const __CFAllocator *v51;
  CFMutableArrayRef v52;
  const void *v53;
  __CFArray *v54;
  const __CFAllocator *v55;
  CFMutableArrayRef v56;
  const __CFAllocator *v57;
  const __CFDictionary *v58;
  CFIndex v59;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v61;
  CFTypeID v62;
  const __CFString *v63;
  const __CFString *v64;
  CFTypeID v65;
  const __CFAllocator *v66;
  CFStringRef v67;
  CFStringRef v68;
  CFIndex v69;
  const __CFArray *v70;
  CFIndex v71;
  char v72;
  CFMutableDictionaryRef v73;
  const __CFAllocator *v74;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v76;
  const __CFAllocator *v77;
  CFMutableDictionaryRef v78;
  uint64_t v79;
  CFIndex v80;
  const void *v81;
  CFTypeRef v82;
  CFMutableDictionaryRef v83;
  CFTypeRef v84;
  __CFString *v85;
  const __CFDictionary *v86;
  const __CFString *v87;
  const __CFDictionary *v88;
  const __CFString *v89;
  uint64_t v90;
  const void *v92;
  CFTypeRef v93;
  const __CFAllocator *v94;
  const __CFDictionary *v95;
  const __CFAllocator *v96;
  const __CFAllocator *v97;
  const __CFArray *v98;
  __CFArray *v99;
  const __CFArray *v100;
  const __CFAllocator *v101;
  const __CFAllocator *v102;
  const __CFArray *v103;
  __CFArray *v104;
  const __CFAllocator *v105;
  CFMutableArrayRef v106;
  uint64_t ManifestPropertyEntriesForDevice;
  const __CFArray *v108;
  CFIndex v109;
  const __CFDictionary *v110;
  const __CFDictionary *v111;
  CFTypeID v112;
  const __CFString *v113;
  const __CFString *v114;
  CFTypeID v115;
  const __CFArray *v116;
  int v117;
  const __CFAllocator *v118;
  const __CFAllocator *v119;
  const __CFString *v120;
  const __CFString *v121;
  const __CFString *v122;
  const __CFString *v123;
  const __CFString *v124;
  const __CFString *v125;
  void *value[2];
  void *v127[2];
  void *v128[2];
  const __CFString *format;
  const __CFString *formata;
  char v131;
  const __CFString *v132;
  const __CFString *v133;
  unsigned int v134;
  int v135;
  unint64_t v136;
  CFMutableDictionaryRef v137;
  _BOOL4 theArray;
  __CFArray *theArraya;
  _QWORD *v140;
  unint64_t cf;
  int v142[2];
  const void *v143;
  char v144;
  const __CFArray *v145;
  CFMutableDictionaryRef *v146;
  CFTypeRef *v147;
  CFMutableDictionaryRef *v148;
  CFTypeRef v149;
  char v150;
  uint64_t v151;
  const __CFDictionary *v152;
  const __CFArray *v153;
  CFTypeRef v154;
  CFTypeRef v155;
  CFTypeRef v156;
  const __CFArray *v157;
  const __CFArray *v158;
  const __CFString *v159;
  const __CFString *v160;
  CFTypeRef v161[2];
  CFRange v162;
  CFRange v163;

  v159 = 0;
  v160 = 0;
  v157 = 0;
  v158 = 0;
  v155 = 0;
  v156 = 0;
  v153 = 0;
  v154 = 0;
  v151 = 0;
  v152 = 0;
  v150 = 0;
  v149 = 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  v9 = Mutable;
  if (!Mutable || (v10 = CFGetTypeID(Mutable), v10 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", CFSTR("queryCache allocation failed"), v131);
    goto LABEL_209;
  }
  AMFDRSetStat(a1, CFSTR("FDRSealingMapRecover"), 1);
  AMFDRSetStat(a2, CFSTR("FDRSealingMapRecover"), 1);
  v11 = (const __CFDictionary *)AMFDRGetOptions((uint64_t)a2);
  v12 = v11;
  if (!v11)
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", CFSTR("amfdrRemote options is NULL"), v131);
    goto LABEL_209;
  }
  v146 = a1;
  v147 = (CFTypeRef *)a4;
  v137 = v9;
  v13 = CFDictionaryGetValue(v11, CFSTR("SealingManifestOverride"));
  v14 = CFDictionaryGetValue(v12, CFSTR("ForceSealing"));
  v15 = (const __CFBoolean *)CFDictionaryGetValue(v12, CFSTR("AllowCSRForbidden"));
  cf = (unint64_t)CFDictionaryGetValue(v12, CFSTR("SealingUpdateDataClasses"));
  v136 = (unint64_t)CFDictionaryGetValue(v12, CFSTR("SealingUpdateProperties"));
  *(_QWORD *)v142 = CFDictionaryGetValue(v12, CFSTR("DataClassesOverride"));
  v16 = (unint64_t)CFDictionaryGetValue(v12, CFSTR("DataInstancesOverride"));
  v148 = a2;
  v144 = AMFDRAPTicketAllowsUnsealedData((uint64_t)a2);
  v17 = (const __CFArray *)CFDictionaryGetValue(v12, CFSTR("GetIntraFactoryData"));
  v18 = v17;
  if (v17)
    theArray = CFArrayGetCount(v17) != 0;
  else
    theArray = 0;
  if (AMFDRIsNonDefaultDemotionState())
  {
    AMSupportLogInternal();
    v19 = (const __CFString *)*MEMORY[0x24BDBD270];
    AMFDRSetOption((uint64_t)v146, CFSTR("SkipVerifySik"), (const __CFString *)*MEMORY[0x24BDBD270]);
    AMFDRSetOption((uint64_t)a2, CFSTR("SkipVerifySik"), v19);
  }
  CFGetAllocator(v146);
  AMFDRSealedDataCreate();
  v21 = (uint64_t)v20;
  if (!v20)
  {
    AMFDRErrorPushInternal((uint64_t)v147, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", CFSTR("Failed to create sealedData. Data Recovery failed."), v131);
LABEL_224:
    v90 = 0;
    goto LABEL_133;
  }
  v140 = v20;
  if (!(*(_QWORD *)v142 | v16))
    goto LABEL_18;
  if ((AMFDREntitlementIsEntitled(CFSTR("com.apple.libFDR.AllowIdentifierOverride")) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)v147, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", CFSTR("Missing AllowIdentifierOverride entitlement"), v131);
    goto LABEL_224;
  }
  if (!*(_QWORD *)v142 || !v16)
  {
    v122 = CFSTR("dataClassesOverride and dataInstancesOverride do not match");
LABEL_223:
    AMFDRErrorPushInternal((uint64_t)v147, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", v122, v131);
    goto LABEL_224;
  }
  v22 = CFGetTypeID(*(CFTypeRef *)v142);
  if (v22 != CFArrayGetTypeID())
  {
    v122 = CFSTR("dataClassesOverride is not an array");
    goto LABEL_223;
  }
  v23 = CFGetTypeID((CFTypeRef)v16);
  if (v23 != CFArrayGetTypeID())
  {
    v122 = CFSTR("dataInstancesOverride is not an array");
    goto LABEL_223;
  }
  Count = CFArrayGetCount(*(CFArrayRef *)v142);
  if (Count != CFArrayGetCount((CFArrayRef)v16))
  {
    v122 = CFSTR("different length of dataClassesOverride and dataInstancesOverride");
    goto LABEL_223;
  }
  AMSupportLogInternal();
  v13 = (const void *)*MEMORY[0x24BDBD270];
LABEL_18:
  v135 = a3;
  if (!v13 || (v25 = CFGetTypeID(v13), v25 != CFBooleanGetTypeID()) || CFBooleanGetValue((CFBooleanRef)v13) != 1)
  {
    if (!v14 || (v26 = CFGetTypeID(v14), v26 != CFBooleanGetTypeID()) || CFBooleanGetValue((CFBooleanRef)v14) != 1)
    {
      if (v15 && (v27 = CFGetTypeID(v15), v27 == CFBooleanGetTypeID()))
      {
        v28 = CFBooleanGetValue(v15);
        v29 = v144;
        if (v28 == 1)
          v29 = 1;
        if ((v29 & 1) == 0)
        {
LABEL_29:
          v30 = theArray;
          if (cf)
            v30 = 0;
          if (!v30 || v136)
          {
            AMSupportLogInternal();
            v31 = v146;
            v32 = v147;
            v33 = (uint64_t)v148;
            if (!(cf | v136))
            {
              if ((AMFDRSealingMapPopulateSealingManifest((uint64_t)v146, 0, (uint64_t)&v151) & 1) != 0
                && (_AMFDRSealingManifestTrustEvaluation((uint64_t)v146, (uint64_t)&v151) & 1) != 0
                && (AMFDRSealingMapPopulateMinimalSealingManifest(v146, 0, (uint64_t)&v151) & 1) != 0
                && (AMFDRSealingManifestVerifyMinimalManifest(v146, &v151) & 1) != 0
                && _AMFDRSealingManifestCopyDataClassesAndInstances((uint64_t)v146, *(const __CFArray **)v142, (const __CFArray *)v16, 0, &v160, (CFTypeRef *)&v159, (CFTypeRef *)&v158, (CFTypeRef *)&v157, (uint64_t *)&v156, (uint64_t *)&v155, (uint64_t *)&v154, &v149, &v151))
              {
                goto LABEL_108;
              }
              AMSupportLogInternal();
            }
            goto LABEL_106;
          }
          goto LABEL_42;
        }
      }
      else if ((v144 & 1) == 0)
      {
        goto LABEL_29;
      }
    }
  }
  if (cf | v136)
  {
    AMSupportLogInternal();
    v31 = v146;
    v32 = v147;
    v33 = (uint64_t)v148;
LABEL_106:
    if ((AMFDRSealingMapPopulateSealingManifest(v33, 0, (uint64_t)v32) & 1) != 0)
    {
      if (_AMFDRSealingManifestCopyDataClassesAndInstances(v33, *(const __CFArray **)v142, (const __CFArray *)v16, (const void *)cf, &v160, (CFTypeRef *)&v159, (CFTypeRef *)&v158, (CFTypeRef *)&v157, (uint64_t *)&v156, (uint64_t *)&v155, (uint64_t *)&v154, &v149, v32))
      {
LABEL_108:
        v145 = 0;
        if (!AMFDRSealedDataPopulatedFromManifest(v21, 1, (uint64_t)v32))
        {
          v90 = 0;
          goto LABEL_133;
        }
        v143 = 0;
        v70 = 0;
        goto LABEL_110;
      }
      v123 = CFSTR("_AMFDRSealingManifestCopyDataClassesAndInstances failed");
    }
    else
    {
      v123 = CFSTR("AMFDRSealingMapPopulateSealingManifest failed on amfdrRemote");
    }
    AMFDRErrorPushInternal((uint64_t)v32, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", v123, v131);
LABEL_230:
    v90 = 0;
    goto LABEL_133;
  }
LABEL_42:
  AMSupportLogInternal();
  v32 = v147;
  if ((_AMFDRSealingMapCopyDataClassesAndInstances(v148, *(const __CFArray **)v142, (const __CFArray *)v16, (CFTypeRef *)&v160, (CFTypeRef *)&v159, (CFTypeRef *)&v158, (CFTypeRef *)&v157, (CFTypeRef *)&v153, (uint64_t *)&v156, (uint64_t *)&v155, (uint64_t *)&v154, &v150, &v149, a3 ^ 1u, v137, (uint64_t)v147) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)v147, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", CFSTR("_AMFDRSealingMapCopyDataClassesAndInstances failed"), v131);
    goto LABEL_230;
  }
  v34 = (const __CFBoolean *)CFDictionaryGetValue(v12, CFSTR("SealingUpdateRepairConfigurationAsidMetadata"));
  if (!v34)
  {
    v33 = (uint64_t)v148;
    goto LABEL_59;
  }
  v35 = v34;
  v36 = CFGetTypeID(v34);
  v33 = (uint64_t)v148;
  if (v36 == CFBooleanGetTypeID() && CFBooleanGetValue(v35))
  {
    v37 = (const void *)copyProductType((uint64_t)v146);
    v38 = v37;
    if (v37)
    {
      v39 = CFGetTypeID(v37);
      if (v39 == CFStringGetTypeID())
      {
        RepairConfigurationEntries = _AMFDRSealingMapGetRepairConfigurationEntries(v38);
        if (RepairConfigurationEntries)
        {
          v41 = RepairConfigurationEntries;
          v42 = CFGetTypeID(RepairConfigurationEntries);
          if (v42 == CFDictionaryGetTypeID())
          {
            if ((AMFDRSealedDataSetRepairConfiguration(v21, v41, (uint64_t)v147) & 1) == 0)
            {
              AMFDRErrorPushInternal((uint64_t)v147, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", CFSTR("AMFDRSealedDataSetRepairConfiguration failed."), v131);
              v90 = 0;
              goto LABEL_133;
            }
            v43 = AMFDRAllowIncompleteData((uint64_t)v146);
            RepairConfigurationAsidMetadataInternalBlob = AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob(0, 0, v41, v43, v137, v147);
            v45 = RepairConfigurationAsidMetadataInternalBlob;
            if (!RepairConfigurationAsidMetadataInternalBlob
              || (v46 = CFGetTypeID(RepairConfigurationAsidMetadataInternalBlob), v46 != CFArrayGetTypeID()))
            {
              AMFDRErrorPushInternal((uint64_t)v147, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", CFSTR("asidMetadataInternalBlob has wrong type %@"), (char)v45);
              v90 = 0;
              goto LABEL_133;
            }
            v47 = *(const void **)(v21 + 232);
            if (v47)
              CFRelease(v47);
            *(_QWORD *)(v21 + 232) = v45;
            CFRetain(v45);
          }
        }
        goto LABEL_59;
      }
    }
    AMFDRErrorPushInternal((uint64_t)v147, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", CFSTR("currentDevice has wrong type '%@'"), (char)v38);
LABEL_209:
    v90 = 0;
    goto LABEL_133;
  }
LABEL_59:
  if (!theArray)
  {
    v143 = 0;
    v145 = 0;
    v70 = 0;
    v31 = v146;
    goto LABEL_89;
  }
  if (!v33)
  {
    AMFDRErrorPushInternal((uint64_t)v147, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyIntraFactoryClassesAndInstances", CFSTR("amfdr is NULL"), v131);
    v143 = 0;
    v145 = 0;
    v70 = 0;
    v72 = 0;
LABEL_102:
    v31 = v146;
    goto LABEL_87;
  }
  if (!v18)
  {
    AMFDRErrorPushInternal((uint64_t)v147, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyIntraFactoryClassesAndInstances", CFSTR("intraFactoryDataMap is NULL"), v131);
    v143 = 0;
    v145 = 0;
    v70 = 0;
    v72 = 0;
    goto LABEL_102;
  }
  v48 = CFGetAllocator((CFTypeRef)v33);
  v49 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  v50 = CFArrayCreateMutable(v48, 0, MEMORY[0x24BDBD690]);
  v51 = CFGetAllocator((CFTypeRef)v33);
  v52 = CFArrayCreateMutable(v51, 0, v49);
  v53 = (const void *)v33;
  v54 = v52;
  v55 = CFGetAllocator(v53);
  v56 = CFArrayCreateMutable(v55, 0, v49);
  theArraya = v56;
  if (!v50 || !v54 || !v56)
  {
    AMFDRErrorPushInternal((uint64_t)v147, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyIntraFactoryClassesAndInstances", CFSTR("failed to allocate data classes/instances/missingDataIdentifiers"), v131);
    v143 = 0;
    v145 = 0;
    v70 = 0;
    v72 = 0;
    goto LABEL_102;
  }
  v57 = CFGetAllocator(v148);
  v58 = CFDictionaryCreateMutable(v57, 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  if (!v58)
  {
    AMFDRErrorPushInternal((uint64_t)v147, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyIntraFactoryClassesAndInstances", CFSTR("queryCache is NULL"), v131);
    v143 = 0;
    v145 = 0;
    v70 = 0;
    v72 = 0;
    goto LABEL_102;
  }
  if (CFArrayGetCount(v18) >= 1)
  {
    v59 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v18, v59);
      v61 = ValueAtIndex;
      if (!ValueAtIndex || (v62 = CFGetTypeID(ValueAtIndex), v62 != CFDictionaryGetTypeID()))
      {
        LOBYTE(v132) = (_BYTE)v61;
        v120 = CFSTR("Object of unexpected type '%@' in intraFactoryDataMap");
LABEL_203:
        format = v120;
        *(_OWORD *)v127 = 0u;
        *(_OWORD *)v128 = 0u;
        *(_OWORD *)value = 0u;
        goto LABEL_204;
      }
      v63 = (const __CFString *)CFDictionaryGetValue(v61, CFSTR("Tag"));
      if (!v63 || (v64 = v63, CFStringGetCharacterAtIndex(v63, 0) != 48) || CFStringGetLength(v64) != 4)
      {
        v132 = CFSTR("Tag");
        v120 = CFSTR("Missing key '%@' in intraFactoryDataMapEntry");
        goto LABEL_203;
      }
      v65 = CFGetTypeID(v64);
      if (v65 != CFStringGetTypeID())
        break;
      v66 = CFGetAllocator(v148);
      v32 = v147;
      v67 = _copyIdentifierListForSealingMapEntry(v66, v61, v58, 0, 0, (uint64_t)v147);
      if (v67)
      {
        v68 = v67;
        CFArrayAppendValue(v50, v64);
        CFArrayAppendValue(v54, v68);
        CFRelease(v68);
      }
      else
      {
        if (!AMFDRAllowIncompleteData((uint64_t)v148))
        {
          format = CFSTR("Could not get data instance for intra factory data class '%@'");
          LOBYTE(v132) = (_BYTE)v64;
          *(_OWORD *)v127 = 0u;
          *(_OWORD *)v128 = 0u;
          *(_OWORD *)value = 0u;
          v79 = (uint64_t)v147;
          v80 = 24;
          goto LABEL_101;
        }
        AMSupportLogInternal();
        CFArrayAppendValue(theArraya, v64);
      }
      if (++v59 >= CFArrayGetCount(v18))
        goto LABEL_79;
    }
    LOBYTE(v132) = (_BYTE)v64;
    format = CFSTR("Object of unexpectedtype '%@' for key '%@' in intraFactoryDataMapEntry");
    *(_OWORD *)v127 = 0u;
    *(_OWORD *)v128 = 0u;
    *(_OWORD *)value = 0u;
    v32 = v147;
LABEL_204:
    v79 = (uint64_t)v32;
    v80 = 1;
LABEL_101:
    AMFDRErrorPushInternal(v79, v80, 0, 0, 0, 0, 0, 0, value[0], value[1], v127[0], v127[1], v128[0], v128[1], (uint64_t)"_AMFDRSealingMapCopyIntraFactoryClassesAndInstances", format, (char)v132);
    v143 = 0;
    v145 = 0;
    v70 = 0;
    v72 = 0;
    goto LABEL_102;
  }
LABEL_79:
  if (CFArrayGetCount(v50) >= 1)
  {
    v69 = CFArrayGetCount(v50);
    v31 = v146;
    if (v69 == CFArrayGetCount(v54))
    {
      v145 = (const __CFArray *)AMSupportSafeRetain();
      v143 = (const void *)AMSupportSafeRetain();
      v70 = (const __CFArray *)CFRetain(theArraya);
      if (CFArrayGetCount(theArraya) >= 1)
      {
        v71 = CFArrayGetCount(theArraya);
        AMFDRSetStat(v148, CFSTR("FDRMissingDataInstance"), v71);
      }
      goto LABEL_86;
    }
    AMFDRErrorPushInternal((uint64_t)v32, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyIntraFactoryClassesAndInstances", CFSTR("Must have a data instance for each data class to recover"), v131);
LABEL_247:
    v143 = 0;
    v145 = 0;
    v70 = 0;
    v72 = 0;
    goto LABEL_87;
  }
  v31 = v146;
  if (!AMFDRAllowIncompleteData((uint64_t)v148))
    goto LABEL_247;
  AMSupportLogInternal();
  v143 = 0;
  v145 = 0;
  v70 = 0;
LABEL_86:
  v72 = 1;
LABEL_87:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if ((v72 & 1) == 0)
  {
    formata = CFSTR("_AMFDRSealingMapCopyIntraFactoryClassesAndInstances failed");
    goto LABEL_212;
  }
  v21 = (uint64_t)v140;
  v33 = (uint64_t)v148;
LABEL_89:
  v73 = v31[13];
  if (v73)
  {
    CFRelease(v73);
    v31[13] = 0;
  }
  if (*(_QWORD *)(v33 + 104))
  {
    AMSupportLogInternal();
    v74 = CFGetAllocator(v31);
    MutableCopy = CFDictionaryCreateMutableCopy(v74, 0, *(CFDictionaryRef *)(v33 + 104));
    v31[13] = MutableCopy;
    if (!MutableCopy)
    {
      v125 = CFSTR("failed copy asidDict from amfdrRemote to amfdrLocal");
LABEL_236:
      AMFDRErrorPushInternal((uint64_t)v32, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", v125, v131);
      goto LABEL_252;
    }
  }
  v76 = v31[16];
  if (v76)
  {
    CFRelease(v76);
    v31[16] = 0;
  }
  if (*(_QWORD *)(v33 + 128))
  {
    AMSupportLogInternal();
    v77 = CFGetAllocator(v31);
    v78 = CFDictionaryCreateMutableCopy(v77, 0, *(CFDictionaryRef *)(v33 + 128));
    v31[16] = v78;
    if (!v78)
    {
      v125 = CFSTR("failed copy subCCDigestDict from amfdrRemote to amfdrLocal");
      goto LABEL_236;
    }
  }
  if (!AMFDRSealedDataPopulatedFromManifest(v21, 0, (uint64_t)v32))
    goto LABEL_252;
LABEL_110:
  v81 = *(const void **)(v33 + 120);
  if (v81)
    CFRelease(v81);
  v82 = v149;
  *(_QWORD *)(v33 + 120) = v149;
  if (v82)
    CFRetain(v82);
  v83 = v31[15];
  if (v83)
    CFRelease(v83);
  v84 = v149;
  v31[15] = (CFMutableDictionaryRef)v149;
  if (v84)
    CFRetain(v84);
  if (!AMFDRGetOptions((uint64_t)v31))
  {
    formata = CFSTR("amfdrLocal options is NULL");
LABEL_212:
    AMFDRErrorPushInternal((uint64_t)v32, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", formata, v131);
    goto LABEL_252;
  }
  if (!v158 || !CFArrayGetCount(v158))
  {
    v90 = 1;
    goto LABEL_133;
  }
  v85 = AMFDRCreateRecoveryPermissions((__CFString *)v33, v160, v159, v158, v157, (uint64_t)v32);
  if (!v85)
  {
LABEL_252:
    v90 = 0;
    goto LABEL_133;
  }
  v86 = (const __CFDictionary *)AMFDRGetOptions((uint64_t)v31);
  if (!v86)
  {
    v124 = CFSTR("amfdrLocal options is NULL");
LABEL_251:
    AMFDRErrorPushInternal((uint64_t)v32, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", v124, v131);
    goto LABEL_252;
  }
  v87 = (const __CFString *)CFDictionaryGetValue(v86, CFSTR("Permissions"));
  if (!v87 || CFStringCompare(v87, v85, 0))
  {
    AMSupportLogInternal();
    AMFDRSetOption((uint64_t)v31, CFSTR("Permissions"), v85);
  }
  v88 = (const __CFDictionary *)AMFDRGetOptions(v33);
  if (!v88)
  {
    v124 = CFSTR("amfdrRemote options is NULL");
    goto LABEL_251;
  }
  v89 = (const __CFString *)CFDictionaryGetValue(v88, CFSTR("Permissions"));
  if (!v89 || CFStringCompare(v89, v85, 0))
  {
    AMSupportLogInternal();
    AMFDRSetOption(v33, CFSTR("Permissions"), v85);
  }
  if (gRecoveryVerifier)
  {
    v90 = (*(uint64_t (**)(uint64_t, const __CFString *))(gRecoveryVerifier + 16))(gRecoveryVerifier, v160);
    goto LABEL_133;
  }
  if (v32 && *v32)
  {
    CFRelease(*v32);
    *v32 = 0;
  }
  if ((AMFDRSealedDataSetDataClassInstance(v140, v160, v159, v158, v157, (uint64_t)v32) & 1) == 0)
  {
    v124 = CFSTR("AMFDRSealedDataSetDataClassInstance failed");
    goto LABEL_251;
  }
  if ((AMFDRSealedDataSetMinimalManifestClassInstance(v140, v156, v155, v154, (uint64_t)v32) & 1) == 0)
  {
    v124 = CFSTR("AMFDRSealedDataSetMinimalManifestClassInstance failed");
    goto LABEL_251;
  }
  v92 = (const void *)v140[16];
  if (v92)
    CFRelease(v92);
  v93 = v149;
  v140[16] = v149;
  if (v93)
    CFRetain(v93);
  if (v145
    && CFArrayGetCount(v145)
    && (AMFDRSealedDataSetIntraFactoryDataClassInstance((uint64_t)v140, v145, v143, (uint64_t)v32) & 1) == 0)
  {
    v124 = CFSTR("AMFDRSealedDataSetIntraFactoryDataClassInstance failed");
    goto LABEL_251;
  }
  if ((AMFDRSealingMapConfigSealedData(v140, v31, (uint64_t)v32) & 1) == 0)
  {
    v124 = CFSTR("AMFDRSealingMapConfigSealedData failed.");
    goto LABEL_251;
  }
  v134 = AMFDRSealedDataRecover((uint64_t)v140, (uint64_t)v31, v33, v135, (CFTypeRef *)&v152, (uint64_t)v32);
  if (v152)
  {
    v94 = CFGetAllocator(v31);
    v95 = CFDictionaryCreateMutableCopy(v94, 0, v152);
  }
  else
  {
    v95 = 0;
  }
  if (v153
    && CFArrayGetCount(v153) >= 1
    && (v95
     || (v96 = CFGetAllocator(v31),
         (v95 = CFDictionaryCreateMutable(v96, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0])) != 0)))
  {
    if (CFDictionaryContainsKey(v95, CFSTR("MissingDataInstances")))
    {
      v97 = CFGetAllocator(v31);
      v98 = (const __CFArray *)CFDictionaryGetValue(v95, CFSTR("MissingDataInstances"));
      v99 = CFArrayCreateMutableCopy(v97, 0, v98);
      v100 = v153;
      v162.length = CFArrayGetCount(v153);
      v31 = v146;
      v162.location = 0;
      CFArrayAppendArray(v99, v100, v162);
    }
    else
    {
      v99 = v153;
    }
    CFDictionarySetValue(v95, CFSTR("MissingDataInstances"), v99);
    if (v70)
    {
LABEL_160:
      if (CFArrayGetCount(v70) >= 1)
      {
        if (v95
          || (v101 = CFGetAllocator(v31),
              (v95 = CFDictionaryCreateMutable(v101, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0])) != 0))
        {
          if (CFDictionaryContainsKey(v95, CFSTR("MissingIntraFactoryDataInstances")))
          {
            v102 = CFGetAllocator(v31);
            v103 = (const __CFArray *)CFDictionaryGetValue(v95, CFSTR("MissingIntraFactoryDataInstances"));
            v104 = CFArrayCreateMutableCopy(v102, 0, v103);
            v163.length = CFArrayGetCount(v70);
            v163.location = 0;
            CFArrayAppendArray(v104, v70, v163);
            v31 = v146;
            CFDictionarySetValue(v95, CFSTR("MissingIntraFactoryDataInstances"), v104);
          }
          else
          {
            CFDictionarySetValue(v95, CFSTR("MissingIntraFactoryDataInstances"), v70);
          }
        }
      }
    }
  }
  else if (v70)
  {
    goto LABEL_160;
  }
  if (!v135)
  {
LABEL_194:
    if (v32 && v95)
    {
      if (*v32)
      {
        CFDictionarySetValue(v95, (const void *)*MEMORY[0x24BDBD3B0], *v32);
        if (*v32)
        {
          CFRelease(*v32);
          *v32 = 0;
        }
      }
      v119 = CFGetAllocator(v31);
      *v32 = CFErrorCreate(v119, CFSTR("AMFDRError"), 19, v95);
    }
    goto LABEL_200;
  }
  v161[0] = 0;
  v105 = CFGetAllocator(v31);
  v106 = CFArrayCreateMutable(v105, 0, MEMORY[0x24BDBD690]);
  ManifestPropertyEntriesForDevice = _AMFDRSealingMapGetManifestPropertyEntriesForDevice((uint64_t)v31);
  if (!ManifestPropertyEntriesForDevice)
  {
    v116 = 0;
    v117 = 1;
    goto LABEL_188;
  }
  v108 = (const __CFArray *)ManifestPropertyEntriesForDevice;
  if (!AMFDRSealingMapPopulateSealingManifest((uint64_t)v31, 0, (uint64_t)v32))
  {
    v32 = v147;
    AMFDRErrorPushInternal((uint64_t)v147, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMissingPropertyTags", CFSTR("AMFDRSealingMapPopulateSealingManifest failed"), v131);
    goto LABEL_217;
  }
  if (CFArrayGetCount(v108) < 1)
  {
LABEL_185:
    v116 = (const __CFArray *)CFRetain(v106);
    v117 = 1;
    v32 = v147;
    goto LABEL_188;
  }
  v109 = 0;
  while (1)
  {
    if (v161[0])
    {
      CFRelease(v161[0]);
      v161[0] = 0;
    }
    v110 = (const __CFDictionary *)CFArrayGetValueAtIndex(v108, v109);
    v111 = v110;
    if (!v110 || (v112 = CFGetTypeID(v110), v112 != CFDictionaryGetTypeID()))
    {
      LOBYTE(v133) = (_BYTE)v111;
      v121 = CFSTR("Object of unexpected type '%@' in manifest property entries");
      goto LABEL_216;
    }
    v113 = (const __CFString *)CFDictionaryGetValue(v111, CFSTR("Tag"));
    if (!v113)
    {
      v133 = CFSTR("Tag");
      v121 = CFSTR("Missing key '%@' in manifest property entry");
      goto LABEL_216;
    }
    v114 = v113;
    v115 = CFGetTypeID(v113);
    if (v115 != CFStringGetTypeID())
    {
      v32 = v147;
      AMFDRErrorPushInternal((uint64_t)v147, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMissingPropertyTags", CFSTR("Object of unexpected type '%@' for key '%@' in manifest property entry"), (char)v114);
      v116 = 0;
      v117 = 0;
      v31 = v146;
      goto LABEL_188;
    }
    v31 = v146;
    if (CFStringGetLength(v114) != 4)
      break;
    if (_propertyEntryHasAttribute(v111, CFSTR("StoreAsInteger"), 0))
    {
      if (!AMFDRDataCopySealingManifestIntegerProperty(v146, v114, (uint64_t)v161))
        goto LABEL_183;
    }
    else if (!AMFDRDataCopySealingManifestProperty(v146, v114, (uint64_t)v161))
    {
      goto LABEL_183;
    }
    if (!v161[0])
    {
LABEL_183:
      AMSupportLogInternal();
      CFArrayAppendValue(v106, v114);
    }
    if (++v109 >= CFArrayGetCount(v108))
      goto LABEL_185;
  }
  LOBYTE(v133) = (_BYTE)v114;
  v121 = CFSTR("Key '%@' length should be 4 for '%@' in manifest property entry");
LABEL_216:
  v32 = v147;
  AMFDRErrorPushInternal((uint64_t)v147, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMissingPropertyTags", v121, (char)v133);
LABEL_217:
  v116 = 0;
  v117 = 0;
LABEL_188:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (v117)
  {
    if (!v116 || CFArrayGetCount(v116) < 1)
      goto LABEL_194;
    if (v95
      || (v118 = CFGetAllocator(v31),
          (v95 = CFDictionaryCreateMutable(v118, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0])) != 0))
    {
      CFDictionarySetValue(v95, CFSTR("MissingSealingProperties"), v116);
      goto LABEL_194;
    }
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)v32, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapRecoverCurrentDevice", CFSTR("Failed to get missing properties."), v131);
  }
LABEL_200:
  v90 = v134;
LABEL_133:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v90;
}

uint64_t _AMFDRSealingMapCopyDataClassesAndInstances(void *a1, const __CFArray *a2, const __CFArray *a3, CFTypeRef *a4, CFTypeRef *a5, CFTypeRef *a6, CFTypeRef *a7, CFTypeRef *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, _BYTE *a12, CFTypeRef *a13, unsigned __int8 a14, CFTypeRef cf, uint64_t a16)
{
  const __CFArray *EntriesForDeviceInternal;
  const __CFString *v26;
  char v27;

  EntriesForDeviceInternal = (const __CFArray *)AMFDRSealingMapGetEntriesForDeviceInternal(0);
  if (EntriesForDeviceInternal)
  {
    if (_AMFDRSealingMapCopyDataClassesAndInstancesInternal(a1, EntriesForDeviceInternal, 0, 0, a14, a2, a3, a4, a5, a6, a7, a8, a13, cf, a16))
    {
      if ((AMFDRAPTicketAllowsUnsealedData((uint64_t)a1) & 1) != 0)
      {
        AMSupportLogInternal();
        return 1;
      }
      if ((_AMFDRSealingMapCopyMinimalManifestClassesAndInstances(a1, a14, a9, a10, a11, a12, a16) & 1) != 0)
        return 1;
      v26 = CFSTR("_AMFDRSealingMapCopyMinimalManifestClassesAndInstances failed");
    }
    else
    {
      v26 = CFSTR("_AMFDRSealingMapCopyDataClassesAndInstancesInternal failed");
    }
    AMFDRErrorPushInternal(a16, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstances", v26, v27);
  }
  else
  {
    AMFDRErrorPushInternal(a16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyDataClassesAndInstances", CFSTR("Could not get sealing map"), v27);
  }
  return 0;
}

const void *_AMFDRSealingMapGetRepairConfigurationEntries(CFTypeRef cf)
{
  CFTypeID v2;
  const __CFDictionary *v3;
  CFTypeID v4;
  const void *Value;
  const void *v6;
  CFTypeID v7;
  const void *v8;
  const void *v9;
  CFTypeID v10;

  if (!cf)
    goto LABEL_12;
  v2 = CFGetTypeID(cf);
  if (v2 != CFStringGetTypeID())
    goto LABEL_12;
  if (sealingMapRepairConfigurationCacheQueue_onceToken != -1)
    dispatch_once(&sealingMapRepairConfigurationCacheQueue_onceToken, &__block_literal_global_973);
  dispatch_sync((dispatch_queue_t)sealingMapRepairConfigurationCacheQueue_sealingMapRepairConfigurationCacheQueue, &__block_literal_global_971);
  v3 = (const __CFDictionary *)fileSystemSealingMapRepairConfiguration;
  if (!fileSystemSealingMapRepairConfiguration
    || (v4 = CFGetTypeID((CFTypeRef)fileSystemSealingMapRepairConfiguration), v4 != CFDictionaryGetTypeID())
    || (Value = CFDictionaryGetValue(v3, cf)) == 0
    || (v6 = Value, v7 = CFGetTypeID(Value), v7 != CFStringGetTypeID())
    || (v8 = CFDictionaryGetValue(v3, v6), (v9 = v8) == 0)
    || (v10 = CFGetTypeID(v8), v10 != CFDictionaryGetTypeID()))
  {
LABEL_12:
    AMSupportLogInternal();
    return 0;
  }
  return v9;
}

__CFDictionary *AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob(const __CFString *a1, const __CFString *a2, CFTypeRef cf, char a4, const void *a5, CFTypeRef *a6)
{
  CFTypeID v10;
  const __CFArray *v11;
  const __CFArray *v12;
  CFTypeID v13;
  const void *v14;
  const void *v15;
  CFTypeID v16;
  CFTypeID v17;
  __CFDictionary *v18;
  uint64_t v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  CFTypeID v23;
  CFIndex v24;
  const __CFString *v25;
  CFStringRef v26;
  CFStringRef v27;
  CFStringRef v28;
  __CFDictionary *v29;
  __CFDictionary *v30;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v32;
  CFTypeID v33;
  const __CFString *v34;
  char v35;
  CFTypeID v36;
  BOOL v37;
  const __CFString *v38;
  CFStringRef v39;
  CFTypeID v40;
  const __CFArray *v41;
  const __CFArray *v42;
  CFTypeID v43;
  __CFArray *v44;
  CFTypeRef v45;
  CFIndex v46;
  CFStringRef v47;
  CFMutableDictionaryRef v48;
  __CFDictionary *v49;
  const __CFDictionary *v50;
  const __CFDictionary *v51;
  CFTypeID v52;
  const void *v53;
  const void *v54;
  CFTypeID v55;
  CFStringRef v56;
  CFStringRef v57;
  CFTypeID v58;
  __CFArray *v59;
  CFStringRef v60;
  __CFArray *v61;
  const void *v62;
  const void *v63;
  const __CFDictionary *v64;
  CFTypeRef v65;
  const void *v66;
  CFTypeID v67;
  const __CFArray *v68;
  const __CFArray *v69;
  CFTypeID v70;
  const __CFArray *v71;
  CFIndex v72;
  CFIndex v73;
  CFMutableArrayRef v74;
  CFIndex v75;
  const __CFDictionary *v76;
  const __CFDictionary *v77;
  CFTypeID v78;
  const __CFString *v79;
  const __CFString *v80;
  const __CFString *v81;
  const __CFString *v82;
  CFTypeID v83;
  void *v84;
  void *v85;
  CFStringRef v86;
  CFTypeID v87;
  const void *v88;
  const void *v89;
  CFTypeRef v90;
  const void *v91;
  CFTypeID v92;
  __CFDictionary *v93;
  CFIndex v94;
  __CFArray *v95;
  __CFArray *v96;
  __CFDictionary *v97;
  __CFArray *v98;
  __CFArray *v99;
  __CFArray *v100;
  CFStringRef v101;
  CFStringRef v102;
  const __CFString *format;
  const __CFString *v105;
  const __CFString *v106;
  const __CFString *v107;
  const __CFString *v108;
  const __CFString *v109;
  const __CFString *v110;
  char v111;
  char v112;
  char v113;
  char v114;
  const void *v115;
  const __CFString *v116;
  __CFDictionary *value;
  CFMutableArrayRef Mutable;
  const __CFString *v119;
  __CFDictionary *theDict;
  const __CFArray *theArray;
  CFIndex Count;
  CFIndex v125;
  const __CFString *theString2;
  CFMutableArrayRef cfa;
  const __CFString *v128;
  const void *v129;
  const __CFArray *v130;
  CFIndex v131;
  const void *v132;
  const __CFString *v133;
  __CFDictionary *v134;
  const void *v135;
  __CFArray *v136;
  CFTypeRef *v137;
  __CFArray *v138;
  const __CFString *v139;
  const __CFAllocator *v140;
  CFRange v141;

  if (!cf || (v10 = CFGetTypeID(cf), v10 != CFDictionaryGetTypeID()))
  {
    v114 = (char)cf;
    v108 = CFSTR("repairConfiguration has wrong type %@");
LABEL_208:
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", v108, v114);
    return 0;
  }
  v11 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("RepairConfigurationAsidMetadata"));
  v12 = v11;
  if (!v11 || (v13 = CFGetTypeID(v11), v13 != CFArrayGetTypeID()))
  {
    v114 = (char)v12;
    v108 = CFSTR("asidMetadataEntry has wrong type %@");
    goto LABEL_208;
  }
  v14 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("Version"));
  v15 = v14;
  if (!v14 || (v16 = CFGetTypeID(v14), v16 != CFStringGetTypeID()))
  {
    v114 = (char)v15;
    v108 = CFSTR("version has wrong type %@");
    goto LABEL_208;
  }
  Count = CFArrayGetCount(v12);
  v140 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("asidMetadataInternalBlob create failed"), (char)v110);
    return 0;
  }
  if (!a1 && a2)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("target class is NULL but instance is non-NULL"), (char)v110);
    goto LABEL_219;
  }
  if (!a5 || (v17 = CFGetTypeID(a5), v17 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("queryCache has wrong type %@"), (char)a5);
LABEL_219:
    v20 = 0;
    v18 = 0;
    goto LABEL_174;
  }
  v18 = CFDictionaryCreateMutable(v140, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v18)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("productInfoDict create failed"), (char)v110);
    v20 = 0;
    goto LABEL_174;
  }
  v129 = v15;
  theArray = v12;
  v119 = a2;
  v19 = 0;
  v20 = 0;
  do
  {
    if (v20)
      CFRelease(v20);
    v21 = off_24C69F0B8[v19];
    v22 = AMFDRSealingMapCallMGCopyAnswerInternal(v21, 0, 0);
    v20 = v22;
    if (!v22 || (v23 = CFGetTypeID(v22), v23 != CFNumberGetTypeID()))
    {
      CFGetTypeID(v20);
      AMFDRErrorPushInternal((uint64_t)a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("query %@ failed, productInfoValue is %@, typeID is %lu"), (char)v21);
LABEL_174:
      v30 = 0;
      CFRelease(Mutable);
      goto LABEL_168;
    }
    CFDictionaryAddValue(v18, off_24C69F0D0[v19++], v20);
  }
  while (v19 != 3);
  v116 = v20;
  value = v18;
  if (Count < 1)
  {
    v138 = 0;
    v132 = 0;
    v25 = 0;
    v135 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    cfa = 0;
    v29 = 0;
    v30 = 0;
    v136 = 0;
    goto LABEL_143;
  }
  v138 = 0;
  v24 = 0;
  v132 = 0;
  v25 = 0;
  v135 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  cfa = 0;
  v29 = 0;
  v30 = 0;
  v136 = 0;
  v137 = a6;
  v115 = a5;
  while (1)
  {
    v125 = v24;
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v24);
    v32 = ValueAtIndex;
    if (!ValueAtIndex || (v33 = CFGetTypeID(ValueAtIndex), v33 != CFDictionaryGetTypeID()))
    {
      theDict = v30;
      v113 = (char)v32;
      v106 = CFSTR("primaryDataDict has wrong type %@");
LABEL_190:
      AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", v106, v113);
      goto LABEL_191;
    }
    v34 = (const __CFString *)CFDictionaryGetValue(v32, CFSTR("Tag"));
    v35 = (char)v34;
    if (!v34
      || (theString2 = v34, v36 = CFGetTypeID(v34), v37 = v36 == CFStringGetTypeID(), v35 = (char)theString2, !v37))
    {
      theDict = v30;
      v113 = v35;
      v106 = CFSTR("primaryDataClass has wrong type %@");
      goto LABEL_190;
    }
    if (a1 && CFStringCompare(a1, theString2, 0))
      goto LABEL_139;
    if (v30)
      CFRelease(v30);
    v30 = CFDictionaryCreateMutable(v140, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (!v30)
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("primaryModule create failed"), (char)v110);
      v95 = v136;
      v96 = v138;
      if (v138)
        goto LABEL_149;
      goto LABEL_150;
    }
    if (v25)
      CFRelease(v25);
    v38 = _copyIdentifierListForSealingMapEntry(v140, v32, (const __CFDictionary *)a5, 0, 0, (uint64_t)a6);
    if (!v38)
    {
      if ((a4 & 1) != 0)
      {
        AMSupportLogInternal();
        v25 = 0;
        if (!a6)
          goto LABEL_139;
        v45 = *a6;
        if (!*a6)
          goto LABEL_139;
LABEL_133:
        CFRelease(v45);
        *a6 = 0;
        goto LABEL_139;
      }
      AMFDRErrorPushInternal((uint64_t)a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("failed to get instance of dataClass %@"), (char)theString2);
      v97 = v30;
      v30 = 0;
      v25 = 0;
LABEL_212:
      v95 = v136;
      v96 = v138;
      goto LABEL_147;
    }
    v25 = v38;
    if (v119 && CFStringCompare(v119, v38, 0))
      goto LABEL_139;
    if (v28)
      CFRelease(v28);
    v39 = CFStringCreateWithFormat(v140, 0, CFSTR("%@:%@"), theString2, v25);
    v28 = v39;
    if (!v39 || (v40 = CFGetTypeID(v39), v40 != CFStringGetTypeID()))
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("primaryDataClassInstance create failed"), (char)v110);
      goto LABEL_211;
    }
    CFDictionarySetValue(v30, CFSTR("DataClassInstance"), v28);
    CFDictionarySetValue(v30, CFSTR("type"), CFSTR("Primary"));
    CFDictionarySetValue(v30, CFSTR("Version"), v129);
    CFDictionarySetValue(v30, CFSTR("supm"), v28);
    v41 = (const __CFArray *)CFDictionaryGetValue(v32, CFSTR("dcls"));
    v42 = v41;
    v130 = v41;
    if (v41)
    {
      v43 = CFGetTypeID(v41);
      v37 = v43 == CFArrayGetTypeID();
      v42 = v130;
      if (!v37)
      {
        AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("dcls has wrong type %@"), (char)v130);
LABEL_211:
        v97 = v30;
        v30 = 0;
        goto LABEL_212;
      }
    }
    if (v138)
      CFRelease(v138);
    v44 = CFArrayCreateMutable(v140, 0, MEMORY[0x24BDBD690]);
    if (!v44)
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("primaryData for dcls create failed"), (char)v110);
      v96 = 0;
      v97 = v30;
      v30 = 0;
      v95 = v136;
      goto LABEL_147;
    }
    v138 = v44;
    CFArrayAppendValue(v44, v28);
    if (v42)
      v131 = CFArrayGetCount(v42);
    else
      v131 = 0;
    if (cfa)
      CFRelease(cfa);
    cfa = CFArrayCreateMutable(v140, 0, MEMORY[0x24BDBD690]);
    if (!cfa)
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("secondaryModules create failed"), (char)v110);
      v97 = v30;
      v30 = 0;
      cfa = 0;
      goto LABEL_212;
    }
    theDict = v30;
    v139 = v28;
    if (v131 >= 1)
      break;
LABEL_92:
    CFDictionarySetValue(theDict, CFSTR("dcls"), v138);
    v68 = (const __CFArray *)CFDictionaryGetValue(v32, CFSTR("manp"));
    if (!v68)
    {
LABEL_112:
      v88 = CFDictionaryGetValue(v32, CFSTR("AssemblyIdentifierList"));
      v89 = CFDictionaryGetValue(v32, CFSTR("AsidSubCCIdentifierList"));
      if (v89 || (v89 = CFDictionaryGetValue(v32, CFSTR("AsidSubCCIdOptionalVerifyList"))) != 0)
      {
        if (!v88)
          goto LABEL_115;
        v110 = CFSTR("AssemblyIdentifierList");
        v109 = CFSTR("Both '%@' and '%@' exist in primaryDataClass %@");
LABEL_223:
        AMFDRErrorPushInternal((uint64_t)a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", v109, (char)v110);
LABEL_191:
        v30 = 0;
LABEL_144:
        v95 = v136;
        goto LABEL_145;
      }
      LOBYTE(v89) = (_BYTE)v88;
      if (!v88)
      {
        v93 = theDict;
        goto LABEL_120;
      }
LABEL_115:
      if (v135)
        CFRelease(v135);
      v90 = AMFDRSealingMapCopyAssemblyIdentifierListForSealingMapEntry(v140, v32, (const __CFDictionary *)a5, (uint64_t)a6);
      if (v90)
      {
        v91 = v90;
        v92 = CFGetTypeID(v90);
        v135 = v91;
        if (v92 != CFArrayGetTypeID())
        {
          LOBYTE(v110) = (_BYTE)v91;
          v109 = CFSTR("asidSeparatedValues has wrong type %@");
          goto LABEL_223;
        }
        v93 = theDict;
        CFDictionarySetValue(theDict, CFSTR("asid"), v91);
LABEL_120:
        CFDictionaryAddValue(v93, CFSTR("pdct"), value);
        CFArrayAppendValue(Mutable, v93);
        v141.length = CFArrayGetCount(cfa);
        v141.location = 0;
        CFArrayAppendArray(Mutable, cfa, v141);
        v30 = v93;
        v94 = v125;
        if (!a1)
          goto LABEL_140;
        goto LABEL_143;
      }
      if ((a4 & 1) == 0)
      {
        AMFDRErrorPushInternal((uint64_t)a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("failed to get value of asid %@"), (char)v89);
        v135 = 0;
        goto LABEL_191;
      }
      AMSupportLogInternal();
      if (a6)
      {
        v135 = 0;
LABEL_132:
        v45 = *a6;
        v30 = theDict;
        if (!*a6)
          goto LABEL_139;
        goto LABEL_133;
      }
      v135 = 0;
LABEL_138:
      v30 = theDict;
      goto LABEL_139;
    }
    v69 = v68;
    v70 = CFGetTypeID(v68);
    if (v70 != CFArrayGetTypeID())
    {
      LOBYTE(v110) = (_BYTE)v69;
      v109 = CFSTR("manp has wrong type %@");
      goto LABEL_223;
    }
    v71 = v69;
    v72 = CFArrayGetCount(v69);
    if (v72 <= 0)
    {
      v109 = CFSTR("manpCount cannot be zero");
      goto LABEL_223;
    }
    v73 = v72;
    CFRelease(v138);
    v74 = CFArrayCreateMutable(v140, 0, MEMORY[0x24BDBD690]);
    if (!v74)
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("primaryData for manp create failed"), (char)v110);
      v30 = 0;
      v96 = 0;
      v95 = v136;
      goto LABEL_146;
    }
    v138 = v74;
    v134 = v29;
    v75 = 0;
    while (1)
    {
      v76 = (const __CFDictionary *)CFArrayGetValueAtIndex(v71, v75);
      v77 = v76;
      if (!v76 || (v78 = CFGetTypeID(v76), v78 != CFDictionaryGetTypeID()))
      {
        v112 = (char)v77;
        v105 = CFSTR("propertyEntry has wrong type %@");
LABEL_194:
        AMFDRErrorPushInternal((uint64_t)v137, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", v105, v112);
        goto LABEL_195;
      }
      v79 = (const __CFString *)CFDictionaryGetValue(v77, CFSTR("Tag"));
      v80 = v79;
      if (!v79
        || (v81 = v27, v82 = v25, v83 = CFGetTypeID(v79), v37 = v83 == CFStringGetTypeID(), v25 = v82, v27 = v81, !v37))
      {
        v112 = (char)v80;
        v105 = CFSTR("propertyTag has wrong type %@");
        goto LABEL_194;
      }
      if (CFStringGetLength(v80) != 4)
      {
        v112 = (char)v80;
        v105 = CFSTR("propertyTag '%@' length should be 4");
        goto LABEL_194;
      }
      if (v132)
        CFRelease(v132);
      v84 = _copyMGValuePropertyEntry(v140, v77, 0);
      if (!v84)
        break;
      if (v26)
      {
        v85 = v84;
        CFRelease(v26);
        v84 = v85;
      }
      v132 = v84;
      v86 = CFStringCreateWithFormat(v140, 0, CFSTR("%@:%@"), v80, v84);
      v26 = v86;
      if (!v86 || (v87 = CFGetTypeID(v86), v87 != CFStringGetTypeID()))
      {
        AMFDRErrorPushInternal((uint64_t)v137, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("propertyTagValue has wrong type %@"), (char)v26);
LABEL_195:
        v30 = 0;
        v28 = v139;
        v95 = v136;
        v29 = v134;
        goto LABEL_145;
      }
      CFArrayAppendValue(v138, v26);
      if (v73 == ++v75)
      {
        CFDictionarySetValue(theDict, CFSTR("manp"), v138);
        v28 = v139;
        v29 = v134;
        a6 = v137;
        a5 = v115;
        goto LABEL_112;
      }
    }
    if ((a4 & 1) == 0)
    {
      AMFDRErrorPushInternal((uint64_t)v137, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("failed to get value of property %@"), (char)v80);
      v132 = 0;
      goto LABEL_195;
    }
    AMSupportLogInternal();
    v28 = v139;
    a6 = v137;
    if (!v137)
    {
      v132 = 0;
      v29 = v134;
      v30 = theDict;
      v94 = v125;
      a5 = v115;
      goto LABEL_140;
    }
    v132 = 0;
    v45 = *v137;
    v29 = v134;
    v30 = theDict;
    a5 = v115;
    if (*v137)
      goto LABEL_133;
LABEL_139:
    v94 = v125;
LABEL_140:
    v24 = v94 + 1;
    if (v24 == Count)
    {
LABEL_143:
      theDict = v30;
      v30 = (__CFDictionary *)CFRetain(Mutable);
      goto LABEL_144;
    }
  }
  v46 = 0;
  v128 = v26;
  while (2)
  {
    v47 = v25;
    if (v29)
      CFRelease(v29);
    v48 = CFDictionaryCreateMutable(v140, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (!v48)
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("secondaryModule create failed"), (char)v110);
      v29 = 0;
      v30 = 0;
      v95 = v136;
      goto LABEL_181;
    }
    v49 = v48;
    v50 = (const __CFDictionary *)CFArrayGetValueAtIndex(v42, v46);
    v51 = v50;
    if (!v50 || (v52 = CFGetTypeID(v50), v52 != CFDictionaryGetTypeID()))
    {
      v111 = (char)v51;
      format = CFSTR("secondaryDataDict has wrong type %@");
LABEL_177:
      AMFDRErrorPushInternal((uint64_t)v137, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", format, v111);
      goto LABEL_179;
    }
    v53 = CFDictionaryGetValue(v51, CFSTR("Tag"));
    v54 = v53;
    if (!v53 || (v55 = CFGetTypeID(v53), v55 != CFStringGetTypeID()))
    {
      v111 = (char)v54;
      format = CFSTR("secondaryDataClass has wrong type %@");
      goto LABEL_177;
    }
    CFRelease(v47);
    v56 = _copyIdentifierListForSealingMapEntry(v140, v51, (const __CFDictionary *)a5, 0, 0, (uint64_t)v137);
    if (!v56)
    {
      v29 = v49;
      if ((a4 & 1) == 0)
      {
        AMFDRErrorPushInternal((uint64_t)v137, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("failed to get instance of dataClass %@"), (char)v54);
        v25 = 0;
        v30 = 0;
        v95 = v136;
        goto LABEL_182;
      }
      AMSupportLogInternal();
      a6 = v137;
      v28 = v139;
      v25 = 0;
      if (v137)
        goto LABEL_132;
      goto LABEL_138;
    }
    v47 = v56;
    if (v27)
      CFRelease(v27);
    v57 = CFStringCreateWithFormat(v140, 0, CFSTR("%@:%@"), v54, v47);
    v27 = v57;
    if (v57)
    {
      v58 = CFGetTypeID(v57);
      if (v58 == CFStringGetTypeID())
      {
        CFArrayAppendValue(v138, v27);
        v133 = v27;
        CFDictionarySetValue(v49, CFSTR("DataClassInstance"), v27);
        CFDictionarySetValue(v49, CFSTR("supm"), v139);
        CFDictionarySetValue(v49, CFSTR("type"), CFSTR("Secondary"));
        CFDictionarySetValue(v49, CFSTR("Version"), v129);
        if (v136)
          CFRelease(v136);
        v59 = CFArrayCreateMutable(v140, 0, MEMORY[0x24BDBD690]);
        if (!v59)
        {
          AMFDRErrorPushInternal((uint64_t)v137, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("secondaryData create failed"), (char)v110);
          v95 = 0;
          v30 = 0;
          v26 = v128;
          goto LABEL_180;
        }
        v60 = v47;
        v61 = v59;
        CFArrayAppendValue(v59, v139);
        v136 = v61;
        CFDictionarySetValue(v49, CFSTR("dcls"), v61);
        v62 = CFDictionaryGetValue(v51, CFSTR("AssemblyIdentifierList"));
        v63 = CFDictionaryGetValue(v51, CFSTR("AsidSubCCIdentifierList"));
        if (v63 || (v63 = CFDictionaryGetValue(v51, CFSTR("AsidSubCCIdOptionalVerifyList"))) != 0)
        {
          if (!v62)
            goto LABEL_76;
          AMFDRErrorPushInternal((uint64_t)v137, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("Both '%@' and '%@' exist in secondaryDataClass %@"), (char)CFSTR("AssemblyIdentifierList"));
          v30 = 0;
          v28 = v139;
          v95 = v136;
          v107 = v60;
          v26 = v128;
          v27 = v133;
          v29 = v49;
          v25 = v107;
LABEL_145:
          v96 = v138;
          goto LABEL_146;
        }
        LOBYTE(v63) = (_BYTE)v62;
        if (!v62)
        {
          v28 = v139;
          v29 = v49;
          a6 = v137;
LABEL_81:
          CFArrayAppendValue(cfa, v29);
          v25 = v60;
          v42 = v130;
LABEL_91:
          ++v46;
          v26 = v128;
          v27 = v133;
          if (v131 == v46)
            goto LABEL_92;
          continue;
        }
LABEL_76:
        if (v135)
          CFRelease(v135);
        v64 = v51;
        a6 = v137;
        v65 = AMFDRSealingMapCopyAssemblyIdentifierListForSealingMapEntry(v140, v64, (const __CFDictionary *)a5, (uint64_t)v137);
        if (v65)
        {
          v66 = v65;
          v67 = CFGetTypeID(v65);
          v29 = v49;
          v135 = v66;
          if (v67 == CFArrayGetTypeID())
          {
            CFDictionarySetValue(v49, CFSTR("asid"), v66);
            v28 = v139;
            goto LABEL_81;
          }
          AMFDRErrorPushInternal((uint64_t)v137, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("asidSeparatedValues has wrong type %@"), (char)v66);
        }
        else
        {
          v29 = v49;
          v42 = v130;
          if ((a4 & 1) != 0)
          {
            AMSupportLogInternal();
            if (v137)
            {
              v28 = v139;
              if (*v137)
              {
                CFRelease(*v137);
                v135 = 0;
                *v137 = 0;
              }
              else
              {
                v135 = 0;
              }
            }
            else
            {
              v135 = 0;
              v28 = v139;
            }
            v25 = v60;
            goto LABEL_91;
          }
          AMFDRErrorPushInternal((uint64_t)v137, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("failed to get value of asid %@"), (char)v63);
          v135 = 0;
        }
        v30 = 0;
        v28 = v139;
        v95 = v136;
        v25 = v60;
        v26 = v128;
        v27 = v133;
        goto LABEL_145;
      }
    }
    break;
  }
  AMFDRErrorPushInternal((uint64_t)v137, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob", CFSTR("secondaryDataClassInstance has wrong type %@"), (char)v27);
LABEL_179:
  v30 = 0;
  v95 = v136;
LABEL_180:
  v29 = v49;
LABEL_181:
  v25 = v47;
LABEL_182:
  v96 = v138;
  v28 = v139;
LABEL_146:
  v97 = theDict;
  if (theDict)
  {
LABEL_147:
    v98 = v95;
    v99 = v96;
    CFRelease(v97);
    v96 = v99;
    v95 = v98;
  }
  if (v96)
  {
LABEL_149:
    v100 = v95;
    CFRelease(v96);
    v95 = v100;
  }
LABEL_150:
  if (v95)
    CFRelease(v95);
  if (v29)
    CFRelease(v29);
  v101 = v27;
  v102 = v26;
  CFRelease(Mutable);
  if (v28)
    CFRelease(v28);
  v20 = v116;
  v18 = value;
  if (v101)
    CFRelease(v101);
  if (v102)
    CFRelease(v102);
  if (v135)
    CFRelease(v135);
  if (v25)
    CFRelease(v25);
  if (v132)
    CFRelease(v132);
  if (cfa)
    CFRelease(cfa);
LABEL_168:
  if (v20)
    CFRelease(v20);
  if (v18)
    CFRelease(v18);
  return v30;
}

uint64_t _AMFDRSealingManifestTrustEvaluation(uint64_t a1, uint64_t a2)
{
  const __CFDictionary *v4;
  const __CFData *Value;
  const void *v6;
  const void *v7;
  const __CFString *v8;
  uint64_t v9;
  const __CFString *v11;
  char v12;

  if (!a1)
  {
    v11 = CFSTR("amfdr is NULL");
LABEL_14:
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestTrustEvaluation", v11, v12);
    v9 = 0;
    goto LABEL_8;
  }
  v4 = *(const __CFDictionary **)(a1 + 16);
  if (!v4)
  {
    v11 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_14;
  }
  Value = (const __CFData *)CFDictionaryGetValue(v4, CFSTR("SealingManifest"));
  v6 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("TrustObject"));
  v7 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("TrustObjectDigest"));
  if (!Value)
  {
    v11 = CFSTR("manifestData is NULL");
    goto LABEL_14;
  }
  if (!v6)
  {
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestTrustEvaluation", CFSTR("trustObject is NULL"), v12);
LABEL_16:
    v9 = 0;
    goto LABEL_8;
  }
  if (!v7)
  {
    v11 = CFSTR("trustObjectDigest is NULL");
    goto LABEL_14;
  }
  v8 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(CFSTR("seal"), a2, 0, 0);
  if (!v8)
  {
    AMFDRErrorPushInternal(a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestTrustEvaluation", CFSTR("failed to copy seal data instance"), v12);
    goto LABEL_16;
  }
  v9 = AMFDRDataVerifySealingManifestInternal(a1, Value, v8, a2);
LABEL_8:
  AMSupportSafeRelease();
  return v9;
}

uint64_t AMFDRSealingManifestVerifyMinimalManifest(const __CFDictionary **a1, _QWORD *a2)
{
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeRef v8;
  CFIndex Count;
  CFIndex v10;
  const __CFString *ValueAtIndex;
  const __CFData *Value;
  uint64_t v13;
  CFTypeRef v14;
  const __CFString *v16;
  char v17;
  CFTypeRef cf;
  CFTypeRef v19;

  cf = 0;
  v19 = 0;
  if (!_AMFDRSealingManifestCopyMinimalManifestClassesAndInstances(a1, (uint64_t *)&cf, 0, 0, a2))
  {
    v5 = 0;
    v8 = 0;
    v16 = CFSTR("_AMFDRSealingManifestCopyMinimalManifestClassesAndInstances failed");
LABEL_32:
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestVerifyMinimalManifest", v16, v17);
    v13 = 0;
LABEL_17:
    v14 = v19;
    if (!v19)
      goto LABEL_19;
    goto LABEL_18;
  }
  v4 = (const __CFDictionary *)_CFDictionaryCopyValue(a1[2], CFSTR("MinimalSealingManifests"));
  v5 = v4;
  if (!v4 || (v6 = CFGetTypeID(v4), v6 != CFDictionaryGetTypeID()) || CFDictionaryGetCount(v5) < 1)
  {
    v8 = 0;
    goto LABEL_16;
  }
  if (!cf || (v7 = CFGetTypeID(cf), v7 != CFArrayGetTypeID()))
  {
    v8 = 0;
    v16 = CFSTR("minimalSealingDataInstances is NULL/malformed");
    goto LABEL_32;
  }
  v8 = AMFDRCreateCopy((uint64_t)a1);
  if (!v8)
  {
    v16 = CFSTR("cannot create a separate amfdr object for verifying minimal sealing manifests");
    goto LABEL_32;
  }
  Count = CFArrayGetCount((CFArrayRef)cf);
  AMFDRSetOption((uint64_t)v8, CFSTR("SealingManifestIsMinimal"), (const __CFString *)*MEMORY[0x24BDBD270]);
  if (Count < 1)
  {
LABEL_16:
    v13 = 1;
    goto LABEL_17;
  }
  v10 = 0;
  while (1)
  {
    if (v19)
    {
      CFRelease(v19);
      v19 = 0;
    }
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, v10);
    Value = (const __CFData *)CFDictionaryGetValue(v5, ValueAtIndex);
    AMFDRSetOption((uint64_t)v8, CFSTR("MinimalSealingDataInstance"), ValueAtIndex);
    if ((AMFDRDataVerifySealingManifestInternal((uint64_t)v8, Value, ValueAtIndex, (uint64_t)&v19) & 1) == 0)
      break;
    AMSupportLogInternal();
    if (Count == ++v10)
      goto LABEL_16;
  }
  v14 = v19;
  if (!v19)
  {
    v16 = CFSTR("verifyError is NULL");
    goto LABEL_32;
  }
  v13 = 0;
LABEL_18:
  CFRelease(v14);
  v19 = 0;
LABEL_19:
  if (v5)
    CFRelease(v5);
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v8)
    CFRelease(v8);
  return v13;
}

BOOL _AMFDRSealingManifestCopyDataClassesAndInstances(uint64_t a1, const __CFArray *a2, const __CFArray *a3, const void *a4, _QWORD *a5, CFTypeRef *a6, CFTypeRef *a7, CFTypeRef *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, CFTypeRef *a12, _QWORD *a13)
{
  const void *v18;
  CFTypeID v19;
  const __CFAllocator *v20;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v22;
  const __CFAllocator *v23;
  CFMutableArrayRef v24;
  __CFArray *v25;
  const __CFAllocator *v26;
  CFMutableDictionaryRef v27;
  uint64_t v28;
  const __CFDictionary *v29;
  const __CFData *Value;
  const __CFData *v31;
  const UInt8 *BytePtr;
  int Length;
  CFIndex Count;
  CFStringRef v35;
  const void *v36;
  CFTypeRef v37;
  int v38;
  const __CFAllocator *v39;
  CFStringRef v40;
  const __CFAllocator *v41;
  CFTypeRef v42;
  const __CFAllocator *v43;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v45;
  CFIndex v46;
  const void *v47;
  const void *SikPub;
  CFTypeID v49;
  const __CFAllocator *v50;
  CFStringRef v51;
  CFIndex LastIndexOfValue;
  const void *ValueAtIndex;
  const void *v54;
  CFTypeID v55;
  BOOL v56;
  CFIndex v57;
  CFStringRef v58;
  CFTypeID v59;
  __CFDictionary *v60;
  CFTypeID v61;
  CFIndex v62;
  const __CFString *format;
  const __CFString *v65;
  const __CFString *v66;
  const __CFString *v67;
  const __CFString *v68;
  const __CFString *v69;
  const void *value_8;
  char v71;
  _QWORD *v72;
  CFTypeRef *v73;
  CFTypeRef *v74;
  CFTypeRef v76;
  const __CFArray *theArray;
  CFTypeRef cf;
  int v80;
  CFTypeRef v81;
  __CFDictionary *v82;
  const __CFArray *v83;
  CFIndex v84;
  unsigned int v85;
  const UInt8 *v86;
  unsigned int v87;
  const UInt8 *v88;
  unint64_t *v89[2];
  CFRange v90;
  CFRange v91;

  v88 = 0;
  v89[0] = 0;
  v87 = 0;
  v86 = 0;
  v85 = 0;
  if (!a1)
  {
    v66 = CFSTR("amfdr is NULL");
LABEL_141:
    AMFDRErrorPushInternal((uint64_t)a13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", v66, v71);
    goto LABEL_144;
  }
  v18 = (const void *)a1;
  if (!AMFDRSealingMapGetEntryInternal(a1, CFSTR("seal"), 0, 0))
  {
    v67 = CFSTR("sealingMapEntry for seal key is NULL");
LABEL_143:
    AMFDRErrorPushInternal((uint64_t)a13, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", v67, v71);
    goto LABEL_144;
  }
  if ((a9 || a10 || a11)
    && (_AMFDRSealingManifestCopyMinimalManifestClassesAndInstances(v18, a9, a10, a11, a13) & 1) == 0)
  {
    v67 = CFSTR("_AMFDRSealingManifestCopyMinimalManifestClassesAndInstances failed");
    goto LABEL_143;
  }
  if (a4)
  {
    v19 = CFGetTypeID(a4);
    if (v19 != CFArrayGetTypeID())
    {
      v66 = CFSTR("updateDataClasses is not an array");
      goto LABEL_141;
    }
  }
  v20 = CFGetAllocator(v18);
  Mutable = CFArrayCreateMutable(v20, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a13, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", CFSTR("failed to allocate mutableDataClasses arrays"), v71);
LABEL_144:
    v56 = 0;
    goto LABEL_104;
  }
  v22 = Mutable;
  v23 = CFGetAllocator(v18);
  v24 = CFArrayCreateMutable(v23, 0, MEMORY[0x24BDBD690]);
  if (!v24)
  {
    AMFDRErrorPushInternal((uint64_t)a13, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", CFSTR("failed to allocate mutableDataInstances arrays"), v71);
    CFRelease(v22);
    goto LABEL_144;
  }
  v25 = v24;
  v74 = a7;
  v26 = CFGetAllocator(v18);
  v27 = CFDictionaryCreateMutable(v26, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v82 = v27;
  if (!v27)
  {
    AMFDRErrorPushInternal((uint64_t)a13, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", CFSTR("failed to allocate sikOverrideDict"), v71);
LABEL_133:
    v56 = 0;
    goto LABEL_100;
  }
  v28 = AMFDRGetOptions((uint64_t)v18);
  if (!v28)
  {
    v68 = CFSTR("amfdr options is NULL");
LABEL_132:
    AMFDRErrorPushInternal((uint64_t)a13, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", v68, v71);
    v27 = 0;
    goto LABEL_133;
  }
  v29 = (const __CFDictionary *)v28;
  v76 = (CFTypeRef)_AMFDRSealingMapCopyIdentifierListForClass(CFSTR("seal"), (uint64_t)a13, 0, 0);
  if (!v76)
  {
    v68 = CFSTR("Could not get Sealed Data Instance");
    goto LABEL_132;
  }
  Value = (const __CFData *)CFDictionaryGetValue(v29, CFSTR("SealingManifest"));
  if (!Value)
  {
LABEL_111:
    AMSupportLogInternal();
LABEL_139:
    v27 = 0;
    v56 = 0;
    goto LABEL_99;
  }
  v31 = Value;
  v72 = a5;
  v73 = a8;
  BytePtr = CFDataGetBytePtr(Value);
  Length = CFDataGetLength(v31);
  if (!BytePtr)
  {
    v69 = CFSTR("sealingManifest is NULL");
LABEL_138:
    AMFDRErrorPushInternal((uint64_t)a13, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", v69, v71);
    goto LABEL_139;
  }
  if (!Length)
  {
    v69 = CFSTR("sealingManifestLength is 0");
    goto LABEL_138;
  }
  if (a4)
    Count = CFArrayGetCount((CFArrayRef)a4);
  else
    Count = 0;
  if (AMFDRDecodeManifestBody(v89))
  {
    v69 = CFSTR("amfdr AMFDRDecodeManifestBody failed");
    goto LABEL_138;
  }
  v83 = (const __CFArray *)a4;
  v84 = Count;
  if (!AMFDRDecodeManifestBodyNext(v89, &v88, &v87, &v86, &v85))
  {
    v37 = 0;
    v36 = 0;
    v35 = 0;
    v38 = 0;
    theArray = a2;
    cf = v18;
    while (1)
    {
      if (v36)
        CFRelease(v36);
      if (v35)
        CFRelease(v35);
      if (v37)
        CFRelease(v37);
      v35 = 0;
      if (v88 && v87 && v86 && v85)
      {
        v39 = CFGetAllocator(v18);
        v40 = CFStringCreateWithBytes(v39, v88, v87, 0x8000100u, 0);
        if (!v40)
          goto LABEL_111;
        v36 = v40;
        v41 = CFGetAllocator(v18);
        v35 = CFStringCreateWithBytes(v41, v86, v85, 0x8000100u, 0);
        if (!v35)
          goto LABEL_123;
        v42 = AMFDRDataInstanceCopyNonSik(v18, v35);
        if (!v42)
          goto LABEL_113;
        v80 = v38;
        if (CFStringHasPrefix(v35, CFSTR("sik-")))
        {
          v43 = CFGetAllocator(v18);
          ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v43, v35, CFSTR("-"));
          v45 = ArrayBySeparatingStrings;
          if (!ArrayBySeparatingStrings)
          {
LABEL_113:
            AMSupportLogInternal();
            goto LABEL_122;
          }
          v46 = CFArrayGetCount(ArrayBySeparatingStrings);
          if (v46 < 1)
          {
            v47 = 0;
          }
          else
          {
            CFArrayGetValueAtIndex(v45, v46 - 1);
            v47 = (const void *)AMSupportSafeRetain();
          }
        }
        else
        {
          v47 = 0;
        }
        SikPub = (const void *)AMFDRCryptoGetSikPub((uint64_t)v18);
        v49 = CFGetTypeID(v27);
        if (v49 == CFDictionaryGetTypeID() && v47)
        {
          v27 = v82;
          if (SikPub && !CFEqual(SikPub, v47))
          {
            v50 = CFGetAllocator(cf);
            v51 = CFStringCreateWithFormat(v50, 0, CFSTR("%@-%@"), v36, v42);
            if (!v51)
            {
              AMFDRErrorPushInternal((uint64_t)a13, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestSetSikOverride", CFSTR("sikOverrideKey create failed"), v71);
LABEL_122:
              AMSupportSafeRelease();
              AMSupportSafeRelease();
              AMSupportSafeRelease();
              AMSupportSafeRelease();
LABEL_123:
              AMSupportLogInternal();
              v56 = 0;
              v37 = 0;
              goto LABEL_124;
            }
            CFDictionarySetValue(v82, v51, v47);
          }
        }
        else
        {
          v27 = v82;
        }
        AMSupportSafeRelease();
        AMSupportSafeRelease();
        AMSupportSafeRelease();
        AMSupportSafeRelease();
        v18 = cf;
        v37 = AMFDRDataInstanceCopyNonSik(cf, v35);
        if (!v37)
        {
          AMSupportLogInternal();
          goto LABEL_120;
        }
        if (theArray)
        {
          v90.length = CFArrayGetCount(theArray);
          v90.location = 0;
          LastIndexOfValue = CFArrayGetLastIndexOfValue(theArray, v90, v36);
          if (LastIndexOfValue < 0)
          {
            v38 = 0;
          }
          else
          {
            ValueAtIndex = CFArrayGetValueAtIndex(a3, LastIndexOfValue);
            if (!ValueAtIndex)
            {
              v65 = CFSTR("dataInstance is NULL");
              goto LABEL_119;
            }
            v54 = ValueAtIndex;
            v55 = CFGetTypeID(ValueAtIndex);
            if (v55 != CFStringGetTypeID())
            {
              v65 = CFSTR("melformed dataInstance");
              goto LABEL_119;
            }
            AMSupportLogInternal();
            AMSupportSafeRelease();
            v37 = CFRetain(v54);
            v38 = 1;
          }
        }
        else
        {
          v38 = v80;
        }
        Count = v84;
        if (v84 >= 1 && (v91.location = 0, v91.length = v84, CFArrayContainsValue(v83, v91, v36)))
        {
          if ((v38 & 1) != 0)
          {
            v65 = CFSTR("DataClassOverride and UpdateDataClasses contains same dataClass");
LABEL_119:
            AMFDRErrorPushInternal((uint64_t)a13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", v65, v71);
LABEL_120:
            v56 = 0;
LABEL_124:
            v27 = 0;
            goto LABEL_94;
          }
          AMSupportLogInternal();
          v38 = 0;
        }
        else
        {
          CFArrayAppendValue(v22, v36);
          CFArrayAppendValue(v25, v37);
        }
      }
      else
      {
        v36 = 0;
        v37 = 0;
      }
      if (AMFDRDecodeManifestBodyNext(v89, &v88, &v87, &v86, &v85))
        goto LABEL_66;
    }
  }
  v35 = 0;
  v36 = 0;
  v37 = 0;
LABEL_66:
  v81 = v37;
  if (Count < 1)
  {
    v56 = 1;
LABEL_83:
    if (v72)
      *v72 = CFSTR("seal");
    if (a6)
      *a6 = CFRetain(v76);
    if (v74)
      *v74 = CFRetain(v22);
    if (v73)
      *v73 = CFRetain(v25);
    v27 = 0;
    if (a12)
      *a12 = CFRetain(v82);
    goto LABEL_93;
  }
  v56 = 0;
  v57 = 0;
  v58 = v35;
  while (1)
  {
    if (v36)
      CFRelease(v36);
    if (v58)
      CFRelease(v58);
    CFArrayGetValueAtIndex(v83, v57);
    v36 = (const void *)AMSupportSafeRetain();
    v59 = CFGetTypeID(v36);
    if (v59 != CFStringGetTypeID())
    {
      format = CFSTR("dataClassStr is not string");
LABEL_108:
      AMFDRErrorPushInternal((uint64_t)a13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", format, v71);
      v27 = 0;
      goto LABEL_110;
    }
    if (_isSealingClass((_BOOL8)v36))
    {
      format = CFSTR("dataClassStr is seal");
      goto LABEL_108;
    }
    v60 = (__CFDictionary *)AMFDRSealingMapCopyMultiInstanceForClass(v36, (uint64_t)a13);
    v27 = v60;
    if (!v60)
      break;
    v61 = CFGetTypeID(v60);
    if (v61 != CFArrayGetTypeID() || CFArrayGetCount(v27) < 1)
    {
      AMFDRErrorPushInternal((uint64_t)a13, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", CFSTR("Could not copy data instance array for %@, array count is zero"), (char)v27);
      goto LABEL_110;
    }
    if (CFArrayGetCount(v27) >= 1)
    {
      v62 = 0;
      do
      {
        value_8 = CFArrayGetValueAtIndex(v27, v62);
        AMSupportLogInternal();
        CFArrayAppendValue(v22, v36);
        CFArrayAppendValue(v25, value_8);
        ++v62;
      }
      while (v62 < CFArrayGetCount(v27));
    }
    CFRelease(v27);
    v58 = 0;
    v35 = 0;
    v56 = ++v57 >= v84;
    if (v57 == v84)
      goto LABEL_83;
  }
  AMFDRErrorPushInternal((uint64_t)a13, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyDataClassesAndInstances", CFSTR("Could not copy data instance for %@"), 0);
LABEL_110:
  v35 = 0;
LABEL_93:
  v37 = v81;
  if (v36)
LABEL_94:
    CFRelease(v36);
  if (v35)
    CFRelease(v35);
  if (v37)
    CFRelease(v37);
LABEL_99:
  CFRelease(v76);
LABEL_100:
  CFRelease(v22);
  CFRelease(v25);
  if (v27)
    CFRelease(v27);
  if (v82)
    CFRelease(v82);
LABEL_104:
  AMFDRDecodeManifestBodyDestroy(v89[0]);
  return v56;
}

uint64_t AMFDRSealingMapConfigSealedData(_QWORD *a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v6;
  __CFString *v7;
  CFTypeRef *v8;
  CFTypeRef v9;
  const void *v10;
  const __CFDictionary *PairedSoCs;
  const __CFDictionary *EntryInternal;
  const __CFBoolean *v13;
  const void *v14;
  CFTypeRef v15;
  uint64_t v16;
  const __CFString *v18;
  char v19;
  CFTypeRef v20;
  CFTypeRef cfa;
  _QWORD v22[9];

  v22[8] = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  cfa = 0;
  if (a1)
  {
    v6 = 0;
    v22[0] = a1 + 30;
    v22[1] = a1 + 31;
    v22[2] = a1 + 32;
    v22[3] = a1 + 33;
    v22[4] = a1 + 37;
    v22[5] = a1 + 35;
    v22[6] = a1 + 34;
    v22[7] = a1 + 36;
    do
    {
      if (cfa)
      {
        CFRelease(cfa);
        cfa = 0;
      }
      v7 = off_24C69F078[v6];
      if (!AMFDRSealingMapCopyDataClassesWithAttributeInternal(cf, v7, &cfa, a3))
      {
        v19 = (char)v7;
        v18 = CFSTR("Failed to copy data classes with attribute %@");
        goto LABEL_31;
      }
      v8 = (CFTypeRef *)v22[v6];
      if (*v8)
        CFRelease(*v8);
      v9 = cfa;
      *v8 = cfa;
      if (v9)
        CFRetain(v9);
      ++v6;
    }
    while (v6 != 8);
    v10 = (const void *)a1[25];
    if (v10)
      CFRelease(v10);
    PairedSoCs = AMFDRSealingMapGetPairedSoCs((uint64_t)cf);
    a1[25] = PairedSoCs;
    if (PairedSoCs)
      CFRetain(PairedSoCs);
    EntryInternal = AMFDRSealingMapGetEntryInternal((uint64_t)cf, CFSTR("seal"), 0, 0);
    if (AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, CFSTR("DeprecateVersion1"), 0))
      a1[27] = *MEMORY[0x24BDBD270];
    v13 = (const __CFBoolean *)a1[26];
    if (!v13 || CFBooleanGetValue(v13))
      goto LABEL_24;
    if ((AMFDRSealingMapCopySubCCDataClasses(cf, CFSTR("RequiredToSeal"), &v20, a3) & 1) != 0)
    {
      v14 = (const void *)a1[21];
      if (v14)
        CFRelease(v14);
      v15 = v20;
      a1[21] = v20;
      if (v15)
        CFRetain(v15);
LABEL_24:
      v16 = 1;
      goto LABEL_25;
    }
    v18 = CFSTR("Failed to copy subcc list");
LABEL_31:
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapConfigSealedData", v18, v19);
  }
  else
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapConfigSealedData", CFSTR("sealedData is NULL"), v19);
  }
  v16 = 0;
LABEL_25:
  if (cfa)
  {
    CFRelease(cfa);
    cfa = 0;
  }
  if (v20)
    CFRelease(v20);
  return v16;
}

uint64_t AMFDRSealingMapVerifySealing(CFDictionaryRef *a1, CFErrorRef *a2)
{
  int v4;
  const __CFString **v5;
  const __CFString *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const void *Value;
  const void *v10;
  const void *v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  _QWORD *v15;
  _QWORD *v16;
  CFTypeID v17;
  CFTypeID v18;
  CFIndex Count;
  CFTypeID v20;
  CFTypeID v21;
  CFTypeID v22;
  char v23;
  const void *v24;
  CFTypeRef v25;
  const __CFAllocator *v26;
  __CFDictionary *Mutable;
  const __CFDictionary *v28;
  const __CFString *v29;
  uint64_t v30;
  uint64_t IsBenign;
  const __CFString *v33;
  const __CFString *v34;
  const __CFString *v35;
  const __CFString *v36;
  const __CFString *v37;
  char v38;
  const void *v39;
  CFTypeRef cf;
  const __CFString *v41;
  CFTypeRef v42;
  CFTypeRef v43;
  CFTypeRef v44;
  int v45[2];
  unint64_t v46;
  CFTypeRef v47;
  CFTypeRef v48[2];

  v47 = 0;
  v48[0] = 0;
  v46 = 0;
  v44 = 0;
  *(_QWORD *)v45 = 0;
  v42 = 0;
  v43 = 0;
  cf = 0;
  v41 = 0;
  if (!a1)
  {
    v33 = CFSTR("amfdr is NULL");
LABEL_74:
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", v33, v38);
LABEL_75:
    IsBenign = 0;
    v16 = 0;
    goto LABEL_67;
  }
  if (!AMFDRGetOptions((uint64_t)a1))
  {
    v33 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_74;
  }
  v4 = CFDictionaryContainsKey(a1[2], CFSTR("TrustObjectDigest"));
  v5 = (const __CFString **)MEMORY[0x24BDBD270];
  if (v4)
    goto LABEL_9;
  if (!CFDictionaryContainsKey(a1[2], CFSTR("APTicket")) && (AMFDRDataApTicketPopulate((uint64_t)a1) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", CFSTR("Failed to load AP Ticket"), v38);
    goto LABEL_75;
  }
  v6 = (const __CFString *)AMFDRDataApTicketCopyTrustObjectDigest((uint64_t)a1);
  if (!v6)
  {
    AMSupportLogInternal();
    goto LABEL_93;
  }
  AMFDRSetOption((uint64_t)a1, CFSTR("TrustObjectDigest"), v6);
  if (AMFDRIsNonDefaultDemotionState())
  {
    AMSupportLogInternal();
    AMFDRSetOption((uint64_t)a1, CFSTR("SkipVerifySik"), *v5);
  }
LABEL_9:
  v7 = (const __CFDictionary *)AMFDRGetOptions((uint64_t)a1);
  if (!v7)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", CFSTR("amfdr options is NULL"), v38);
LABEL_93:
    IsBenign = 0;
    v16 = 0;
    goto LABEL_67;
  }
  v8 = v7;
  Value = CFDictionaryGetValue(v7, CFSTR("SealingManifestOverride"));
  v10 = CFDictionaryGetValue(v8, CFSTR("ForceSealing"));
  v11 = CFDictionaryGetValue(v8, CFSTR("AllowCSRForbidden"));
  v12 = (unint64_t)CFDictionaryGetValue(v8, CFSTR("DataClassesOverride"));
  v13 = (unint64_t)CFDictionaryGetValue(v8, CFSTR("DataInstancesOverride"));
  v39 = CFDictionaryGetValue(v8, CFSTR("SealingUpdateDataClasses"));
  v14 = AMFDRAPTicketAllowsUnsealedData((uint64_t)a1);
  CFGetAllocator(a1);
  AMFDRSealedDataCreate();
  v16 = v15;
  if (!v15)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", CFSTR("Failed to create AMFDRSealedData object"), (char)v39);
LABEL_96:
    IsBenign = 0;
    goto LABEL_67;
  }
  if (!(v12 | v13))
    goto LABEL_18;
  if ((AMFDREntitlementIsEntitled(CFSTR("com.apple.libFDR.AllowIdentifierOverride")) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", CFSTR("Missing AllowIdentifierOverride entitlement"), (char)v39);
    goto LABEL_96;
  }
  if (!v12 || !v13)
  {
    v36 = CFSTR("dataClassesOverride and dataInstancesOverride do not match");
LABEL_90:
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", v36, (char)v39);
    goto LABEL_96;
  }
  v17 = CFGetTypeID((CFTypeRef)v12);
  if (v17 != CFArrayGetTypeID())
  {
    v36 = CFSTR("dataClassesOverride is not an array");
    goto LABEL_90;
  }
  v18 = CFGetTypeID((CFTypeRef)v13);
  if (v18 != CFArrayGetTypeID())
  {
    v36 = CFSTR("dataInstancesOverride is not an array");
    goto LABEL_90;
  }
  Count = CFArrayGetCount((CFArrayRef)v12);
  if (Count != CFArrayGetCount((CFArrayRef)v13))
  {
    v36 = CFSTR("different length of dataClassesOverride and dataInstancesOverride");
    goto LABEL_90;
  }
LABEL_18:
  if (Value)
  {
    v20 = CFGetTypeID(Value);
    if (v20 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)Value) == 1)
      goto LABEL_36;
  }
  if (v10)
  {
    v21 = CFGetTypeID(v10);
    if (v21 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)v10) == 1)
      goto LABEL_36;
  }
  if (!v11 || (v22 = CFGetTypeID(v11), v22 != CFBooleanGetTypeID()))
  {
    if (!v14)
      goto LABEL_30;
LABEL_36:
    AMSupportLogInternal();
    if ((_AMFDRSealingMapCopyDataClassesAndInstances(a1, (const __CFArray *)v12, (const __CFArray *)v13, v48, &v47, (CFTypeRef *)&v46, (CFTypeRef *)v45, 0, (uint64_t *)&v44, (uint64_t *)&v43, (uint64_t *)&v42, 0, &cf, 0, 0, (uint64_t)a2) & 1) != 0)
    {
      if (!AMFDRSealedDataPopulatedFromManifest((uint64_t)v16, 0, (uint64_t)a2))
      {
LABEL_82:
        IsBenign = 0;
        goto LABEL_67;
      }
      goto LABEL_38;
    }
    v35 = CFSTR("_AMFDRSealingMapCopyDataClassesAndInstances failed");
    goto LABEL_95;
  }
  if (CFBooleanGetValue((CFBooleanRef)v11) == 1)
    v23 = 1;
  else
    v23 = v14;
  if ((v23 & 1) != 0)
    goto LABEL_36;
LABEL_30:
  AMSupportLogInternal();
  if ((AMFDRSealingMapPopulateSealingManifest((uint64_t)a1, 0, (uint64_t)a2) & 1) == 0)
  {
    v35 = CFSTR("AMFDRSealingMapPopulateSealingManifest failed on amfdr");
LABEL_95:
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", v35, (char)v39);
    goto LABEL_96;
  }
  if ((AMFDRSealingMapPopulateMinimalSealingManifest(a1, 0, (uint64_t)a2) & 1) == 0)
  {
    v34 = CFSTR("AMFDRSealingMapPopulateMinimalSealingManifest failed on amfdr");
    goto LABEL_81;
  }
  if (!_AMFDRSealingManifestCopyDataClassesAndInstances((uint64_t)a1, (const __CFArray *)v12, (const __CFArray *)v13, v39, v48, &v47, (CFTypeRef *)&v46, (CFTypeRef *)v45, (uint64_t *)&v44, (uint64_t *)&v43, (uint64_t *)&v42, &cf, a2))
  {
    v34 = CFSTR("_AMFDRSealingManifestCopyDataClassesAndInstances failed");
    goto LABEL_81;
  }
  if (!AMFDRSealedDataPopulatedFromManifest((uint64_t)v16, 1, (uint64_t)a2))
    goto LABEL_82;
LABEL_38:
  if ((AMFDRSealedDataSetMinimalManifestClassInstance(v16, v44, v43, v42, (uint64_t)a2) & 1) == 0)
  {
    v34 = CFSTR("AMFDRSealedDataSetMinimalManifestClassInstance failed");
LABEL_81:
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", v34, (char)v39);
    goto LABEL_82;
  }
  v24 = (const void *)v16[16];
  if (v24)
    CFRelease(v24);
  v25 = cf;
  v16[16] = cf;
  if (v25)
    CFRetain(v25);
  if ((AMFDRSealingMapConfigSealedData(v16, a1, (uint64_t)a2) & 1) == 0)
  {
    v34 = CFSTR("AMFDRSealingMapConfigSealedData failed.");
    goto LABEL_81;
  }
  if ((AMFDRSealedDataConfigureOptionsForRecover((uint64_t)v16, (CFTypeRef *)a1, 0, v47, (uint64_t)a2) & 1) == 0)
  {
    v34 = CFSTR("AMFDRSealedDataConfigureOptionsForRecover failed.");
    goto LABEL_81;
  }
  if (a2 && *a2)
  {
    CFRelease(*a2);
    *a2 = 0;
  }
  v26 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v26, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v28 = Mutable;
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", CFSTR("Failed to allocate privateOptions"), (char)v39);
    goto LABEL_66;
  }
  CFDictionarySetValue(Mutable, CFSTR("SkipExtraManifests"), (const void *)*MEMORY[0x24BDBD270]);
  if ((__AMFDRSealedDataPopulatePrivate(v28, (uint64_t)v16, (uint64_t)a1, (unint64_t)v48[0], (unint64_t)v47, v46, *(unint64_t *)v45, (uint64_t)a2) & 1) == 0)
  {
    if ((AMFDRDataErrorIsBenign((uint64_t)a1, (char)CFSTR("AMFDRSealingMapVerifySealing"), a2) & 1) == 0)
    {
      v37 = CFSTR("AMFDRSealingMapVerifySealing Failed to populate sealed data");
LABEL_100:
      AMFDRErrorPushInternal((uint64_t)a2, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", v37, (char)v39);
      goto LABEL_66;
    }
    if (a2 && *a2)
    {
      CFRelease(*a2);
      *a2 = 0;
    }
  }
  if (AMFDRSealedDataIsEmpty((uint64_t)v16) && AMFDRAllowIncompleteData((uint64_t)a1))
  {
LABEL_64:
    AMSupportLogInternal();
    IsBenign = 1;
    goto LABEL_67;
  }
  v29 = (const __CFString *)v16[2];
  if (!v29)
  {
    if (AMFDRAPTicketAllowsUnsealedData((uint64_t)a1))
      goto LABEL_64;
    AMFDRErrorPushInternal((uint64_t)a2, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealing", CFSTR("No sealing manifest in data store"), (char)v39);
LABEL_66:
    IsBenign = 0;
    goto LABEL_67;
  }
  AMFDRSetOption((uint64_t)a1, CFSTR("SealingManifest"), v29);
  if (!CFDictionaryContainsKey(a1[2], CFSTR("TrustObject")))
  {
    if ((AMFDRDataCopyTrustObject((uint64_t)a1) & 1) != 0)
    {
      AMFDRSetOption((uint64_t)a1, CFSTR("TrustObject"), v41);
      goto LABEL_60;
    }
    v37 = CFSTR("No trust object in options or in data store");
    goto LABEL_100;
  }
LABEL_60:
  v30 = AMFDRSealedDataVerify(v16, (uint64_t)a1, (uint64_t)a2);
  IsBenign = v30;
  if (a2 && (v30 & 1) == 0)
    IsBenign = AMFDRSealedDataVerificationErrorIsBenign((int)v16, a1, 0, 0, 0, *a2);
LABEL_67:
  AMFDRSealedDataRestoreOptions((uint64_t)v16, (uint64_t)a1, 0);
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (a2 && (_DWORD)IsBenign && *a2)
  {
    CFRelease(*a2);
    *a2 = 0;
  }
  return IsBenign;
}

uint64_t AMFDRSealingMapCreateAndPopulateSealedData(void *a1, CFTypeRef *a2, CFErrorRef *a3)
{
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  const void *Value;
  const void *v9;
  const void *v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  const __CFDictionary *v14;
  CFTypeID v15;
  CFTypeID v16;
  CFIndex Count;
  CFTypeID v18;
  CFTypeID v19;
  CFTypeID v20;
  char v21;
  const void *v22;
  CFTypeRef v23;
  uint64_t v24;
  const __CFString *v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  const void *v31;
  CFTypeRef *v32;
  CFTypeRef cf;
  CFTypeRef v34;
  CFTypeRef v35;
  CFTypeRef v36;
  int v37[2];
  unint64_t v38;
  CFTypeRef v39;
  unint64_t v40;

  v39 = 0;
  v40 = 0;
  v38 = 0;
  v36 = 0;
  *(_QWORD *)v37 = 0;
  v34 = 0;
  v35 = 0;
  cf = 0;
  if (!a1)
  {
    v26 = CFSTR("amfdr is NULL");
LABEL_51:
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateAndPopulateSealedData", v26, (char)v31);
    v24 = 0;
    v7 = 0;
    goto LABEL_48;
  }
  if (!AMFDRGetOptions((uint64_t)a1))
  {
    v26 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_51;
  }
  v32 = a2;
  v6 = (const __CFDictionary *)AMFDRGetOptions((uint64_t)a1);
  v7 = v6;
  if (!v6)
  {
    v27 = CFSTR("amfdr options is NULL");
LABEL_65:
    v30 = v27;
LABEL_70:
    AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateAndPopulateSealedData", v30, (char)v31);
    goto LABEL_71;
  }
  Value = CFDictionaryGetValue(v6, CFSTR("SealingManifestOverride"));
  v9 = CFDictionaryGetValue(v7, CFSTR("ForceSealing"));
  v10 = CFDictionaryGetValue(v7, CFSTR("AllowCSRForbidden"));
  v11 = (unint64_t)CFDictionaryGetValue(v7, CFSTR("DataClassesOverride"));
  v12 = (unint64_t)CFDictionaryGetValue(v7, CFSTR("DataInstancesOverride"));
  v31 = CFDictionaryGetValue(v7, CFSTR("SealingUpdateDataClasses"));
  v13 = AMFDRAPTicketAllowsUnsealedData((uint64_t)a1);
  CFGetAllocator(a1);
  AMFDRSealedDataCreate();
  v7 = v14;
  if (!v14)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateAndPopulateSealedData", CFSTR("Failed to create AMFDRSealedData object"), (char)v31);
    goto LABEL_71;
  }
  if (!(v11 | v12))
    goto LABEL_12;
  if ((AMFDREntitlementIsEntitled(CFSTR("com.apple.libFDR.AllowIdentifierOverride")) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateAndPopulateSealedData", CFSTR("Missing AllowIdentifierOverride entitlement"), (char)v31);
    goto LABEL_71;
  }
  if (!v11 || !v12)
  {
    v29 = CFSTR("dataClassesOverride and dataInstancesOverride do not match");
LABEL_63:
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateAndPopulateSealedData", v29, (char)v31);
    goto LABEL_71;
  }
  v15 = CFGetTypeID((CFTypeRef)v11);
  if (v15 != CFArrayGetTypeID())
  {
    v29 = CFSTR("dataClassesOverride is not an array");
    goto LABEL_63;
  }
  v16 = CFGetTypeID((CFTypeRef)v12);
  if (v16 != CFArrayGetTypeID())
  {
    v29 = CFSTR("dataInstancesOverride is not an array");
    goto LABEL_63;
  }
  Count = CFArrayGetCount((CFArrayRef)v11);
  if (Count != CFArrayGetCount((CFArrayRef)v12))
  {
    v29 = CFSTR("different length of dataClassesOverride and dataInstancesOverride");
    goto LABEL_63;
  }
LABEL_12:
  if (Value)
  {
    v18 = CFGetTypeID(Value);
    if (v18 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)Value) == 1)
      goto LABEL_30;
  }
  if (v9)
  {
    v19 = CFGetTypeID(v9);
    if (v19 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)v9) == 1)
      goto LABEL_30;
  }
  if (!v10 || (v20 = CFGetTypeID(v10), v20 != CFBooleanGetTypeID()))
  {
    if (!v13)
      goto LABEL_24;
    goto LABEL_30;
  }
  v21 = CFBooleanGetValue((CFBooleanRef)v10) == 1 ? 1 : v13;
  if ((v21 & 1) != 0)
  {
LABEL_30:
    AMSupportLogInternal();
    if ((_AMFDRSealingMapCopyDataClassesAndInstances(a1, 0, 0, (CFTypeRef *)&v40, &v39, (CFTypeRef *)&v38, (CFTypeRef *)v37, 0, (uint64_t *)&v36, (uint64_t *)&v35, (uint64_t *)&v34, 0, &cf, 0, 0, (uint64_t)a3) & 1) == 0)
    {
      v28 = CFSTR("_AMFDRSealingMapCopyDataClassesAndInstances failed");
LABEL_69:
      v30 = v28;
      goto LABEL_70;
    }
    if (AMFDRSealedDataPopulatedFromManifest((uint64_t)v7, 0, (uint64_t)a3))
      goto LABEL_32;
LABEL_71:
    v24 = 0;
    goto LABEL_48;
  }
LABEL_24:
  AMSupportLogInternal();
  if ((AMFDRSealingMapPopulateSealingManifest((uint64_t)a1, 0, (uint64_t)a3) & 1) == 0)
  {
    v28 = CFSTR("AMFDRSealingMapPopulateSealingManifest failed on amfdr");
    goto LABEL_69;
  }
  if ((AMFDRSealingMapPopulateMinimalSealingManifest((CFDictionaryRef *)a1, 0, (uint64_t)a3) & 1) == 0)
  {
    v28 = CFSTR("AMFDRSealingMapPopulateMinimalSealingManifest failed on amfdr");
    goto LABEL_69;
  }
  if (!_AMFDRSealingManifestCopyDataClassesAndInstances((uint64_t)a1, (const __CFArray *)v11, (const __CFArray *)v12, v31, &v40, &v39, (CFTypeRef *)&v38, (CFTypeRef *)v37, (uint64_t *)&v36, (uint64_t *)&v35, (uint64_t *)&v34, &cf, a3))
  {
    v28 = CFSTR("_AMFDRSealingManifestCopyDataClassesAndInstances failed");
    goto LABEL_69;
  }
  if (!AMFDRSealedDataPopulatedFromManifest((uint64_t)v7, 1, (uint64_t)a3))
    goto LABEL_71;
LABEL_32:
  if ((AMFDRSealedDataSetMinimalManifestClassInstance(v7, v36, v35, v34, (uint64_t)a3) & 1) == 0)
  {
    v27 = CFSTR("AMFDRSealedDataSetMinimalManifestClassInstance failed");
    goto LABEL_65;
  }
  v22 = (const void *)*((_QWORD *)v7 + 16);
  if (v22)
    CFRelease(v22);
  v23 = cf;
  *((_QWORD *)v7 + 16) = cf;
  if (v23)
    CFRetain(v23);
  if ((AMFDRSealingMapConfigSealedData(v7, a1, (uint64_t)a3) & 1) == 0)
  {
    v27 = CFSTR("AMFDRSealingMapConfigSealedData failed.");
    goto LABEL_65;
  }
  if ((AMFDRSealedDataConfigureOptionsForRecover((uint64_t)v7, (CFTypeRef *)a1, 0, v39, (uint64_t)a3) & 1) == 0)
  {
    v27 = CFSTR("AMFDRSealedDataConfigureOptionsForRecover failed.");
    goto LABEL_65;
  }
  if (a3 && *a3)
  {
    CFRelease(*a3);
    *a3 = 0;
  }
  if ((AMFDRSealedDataPopulate((uint64_t)v7, (uint64_t)a1, v40, (unint64_t)v39, v38, *(unint64_t *)v37, (uint64_t)a3) & 1) != 0)goto LABEL_47;
  if ((AMFDRDataErrorIsBenign((uint64_t)a1, (char)CFSTR("AMFDRSealingMapVerifySealing"), a3) & 1) == 0)
  {
    v27 = CFSTR("AMFDRSealingMapVerifySealing Failed to populate sealed data");
    goto LABEL_65;
  }
  if (a3 && *a3)
  {
    CFRelease(*a3);
    *a3 = 0;
  }
LABEL_47:
  *v32 = CFRetain(v7);
  v24 = 1;
LABEL_48:
  AMFDRSealedDataRestoreOptions((uint64_t)v7, (uint64_t)a1, 0);
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v24;
}

uint64_t AMFDRSealingMapVerifyAndCommitSealedData(CFDictionaryRef *a1, uint64_t a2, __CFError **a3)
{
  char v6;
  const __CFBoolean *Value;
  const __CFBoolean *v8;
  CFTypeID v9;
  int v10;
  _BOOL4 v11;
  char v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  uint64_t v15;
  const __CFString *v17;
  const __CFString *v18;
  char v19;

  if (!a1)
  {
    v17 = CFSTR("amfdr is NULL");
LABEL_34:
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAndCommitSealedData", v17, v19);
LABEL_41:
    AMFDRSealedDataRestoreOptions(a2, (uint64_t)a1, 0);
    return 0;
  }
  if (!AMFDRGetOptions((uint64_t)a1))
  {
    v17 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_34;
  }
  if (!a2)
  {
    v17 = CFSTR("sealedData is NULL");
    goto LABEL_34;
  }
  if (!*(_QWORD *)(a2 + 80))
  {
    v17 = CFSTR("sealedData->sealedDataInstance is NULL");
    goto LABEL_34;
  }
  if ((AMFDRSealingMapConfigSealedData((_QWORD *)a2, a1, (uint64_t)a3) & 1) == 0)
  {
    v18 = CFSTR("AMFDRSealingMapConfigSealedData failed.");
LABEL_40:
    AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAndCommitSealedData", v18, v19);
    goto LABEL_41;
  }
  if ((AMFDRSealedDataConfigureOptionsForRecover(a2, (CFTypeRef *)a1, 0, *(const void **)(a2 + 80), (uint64_t)a3) & 1) == 0)
  {
    v18 = CFSTR("AMFDRSealedDataConfigureOptionsForRecover failed.");
    goto LABEL_40;
  }
  if (AMFDRIsNonDefaultDemotionState())
  {
    AMSupportLogInternal();
    AMFDRSetOption((uint64_t)a1, CFSTR("SkipVerifySik"), (const __CFString *)*MEMORY[0x24BDBD270]);
  }
  v6 = AMFDRSealedDataVerify((_QWORD *)a2, (uint64_t)a1, (uint64_t)a3);
  Value = (const __CFBoolean *)CFDictionaryGetValue(a1[2], CFSTR("ForceCommit"));
  if (!Value || (v8 = Value, v9 = CFGetTypeID(Value), v9 != CFBooleanGetTypeID()))
  {
    v11 = a3 == 0;
LABEL_19:
    if ((v6 & 1) != 0)
      goto LABEL_20;
    if (v11)
    {
      v18 = CFSTR("AMFDRSealedDataVerify failed without returning outError");
    }
    else if ((AMFDRSealedDataVerificationErrorIsBenign(a2, a1, 1, 0, 0, *a3) & 1) != 0)
    {
      v14 = (const __CFDictionary *)AMFDRCopyUnderlyingDictionary(*a3, CFSTR("UnverifiedDataInstances"));
      if (v14)
      {
        v13 = v14;
        CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)_checkVerification, (void *)a2);
        goto LABEL_25;
      }
      v18 = CFSTR("AMFDRSealedDataVerify failed without returning unverifiedDataInstances in outError");
    }
    else
    {
      v18 = CFSTR("AMFDRSealedDataVerify failed with unrecoverable errors");
    }
    goto LABEL_40;
  }
  v10 = CFBooleanGetValue(v8);
  v11 = a3 == 0;
  if (a3)
    v12 = v6;
  else
    v12 = 1;
  if ((v12 & 1) != 0 || !v10)
    goto LABEL_19;
  AMFDRSealedDataVerificationErrorIsBenign(a2, a1, 1, 0, 0, *a3);
  AMSupportLogInternal();
  if (!*a3)
  {
LABEL_20:
    v13 = 0;
    goto LABEL_25;
  }
  CFRelease(*a3);
  v13 = 0;
  *a3 = 0;
LABEL_25:
  v15 = AMFDRSealedDataCommit(a2, (uint64_t)a1, 0, (uint64_t)a3);
  if ((v15 & 1) == 0)
    AMFDRErrorPushInternal((uint64_t)a3, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAndCommitSealedData", CFSTR("AMFDRSealedDataCommit failed."), v19);
  AMFDRSealedDataRestoreOptions(a2, (uint64_t)a1, 0);
  if (v13)
    CFRelease(v13);
  return v15;
}

void _checkVerification(const void *a1, uint64_t a2, CFArrayRef *a3)
{
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v9;
  const __CFAllocator *v10;
  CFStringRef FullKey;

  Count = CFArrayGetCount(a3[4]);
  if (Count >= 1)
  {
    v6 = Count;
    for (i = 0; i != v6; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a3[4], i);
      v9 = CFArrayGetValueAtIndex(a3[5], i);
      v10 = CFGetAllocator(a3);
      FullKey = AMFDRDataLocalCreateFullKey(v10, (uint64_t)ValueAtIndex, (uint64_t)v9);
      if (CFEqual(FullKey, a1))
      {
        AMSupportLogInternal();
        CFArraySetValueAtIndex(a3[8], i, 0);
      }
      if (FullKey)
        CFRelease(FullKey);
    }
  }
}

uint64_t AMFDRSealingMapRecoverCurrentDeviceWithMemoryStore(const __CFString *a1, CFTypeRef cf, uint64_t a3, CFTypeRef *a4, CFTypeRef a5)
{
  CFTypeID v10;
  CFTypeID v11;
  const __CFAllocator *v12;
  CFDictionaryRef *v13;
  const __CFDictionary *v14;
  CFMutableDictionaryRef *v15;
  uint64_t v16;
  CFMutableDictionaryRef *v17;
  const void *v18;
  CFDataRef v19;
  CFErrorRef error;
  CFTypeRef cfa;
  uint64_t v23;

  cfa = 0;
  v23 = 0;
  error = 0;
  if (!a1)
    goto LABEL_31;
  if (cf)
  {
    v10 = CFGetTypeID(cf);
    if (v10 != CFDataGetTypeID())
      goto LABEL_31;
  }
  if (a5)
  {
    v11 = CFGetTypeID(a5);
    if (v11 != CFDictionaryGetTypeID())
      goto LABEL_31;
  }
  if (!a3)
  {
    AMSupportLogInternal();
    goto LABEL_28;
  }
  v12 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v13 = (CFDictionaryRef *)AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Memory"), (const __CFDictionary *)a5);
  if (!v13)
  {
LABEL_31:
    AMSupportLogInternal();
    a3 = 0;
    goto LABEL_28;
  }
  v14 = (const __CFDictionary *)CFPropertyListCreateWithData(v12, (CFDataRef)cf, 0, 0, &error);
  if (error)
  {
    AMSupportLogInternal();
    AMSupportSafeRelease();
    error = 0;
  }
  if (v14 && (AMFDRSetMemoryStore((uint64_t)v13, v14) & 1) == 0)
    goto LABEL_32;
  v15 = (CFMutableDictionaryRef *)AMFDRCreateTypeWithOptions(v12, CFSTR("Remote"), (const __CFDictionary *)a5);
  if (!v15 || (AMFDRDataSetApTicketAndGetNewestTrustObject(a1, (uint64_t)v13, v15) & 1) == 0)
    goto LABEL_32;
  if (AMFDRSealingMapVerifySealing(v13, (CFErrorRef *)&cfa))
  {
    CFDictionaryGetCount(v13[10]);
    AMSupportLogInternal();
    if ((AMFDRSealingMapCreateAndPopulateSealedData(v13, (CFTypeRef *)&v23, (CFErrorRef *)&cfa) & 1) == 0)
      goto LABEL_32;
    if ((AMFDRClearMemoryStore((uint64_t)v13) & 1) == 0)
      goto LABEL_32;
    v16 = v23;
    if ((AMFDRSealingMapVerifyAndCommitSealedData(v13, v23, (__CFError **)&cfa) & 1) == 0)
      goto LABEL_32;
    if (!AMFDRSealedDataIsEmpty(v16))
      goto LABEL_21;
  }
  AMSupportLogInternal();
  CFRelease(v13);
  v17 = (CFMutableDictionaryRef *)AMFDRCreateTypeWithOptions(v12, CFSTR("Memory"), (const __CFDictionary *)a5);
  v13 = v17;
  if (!v17 || (AMFDRSealingMapRecoverCurrentDevice(v17, v15, 1, (uint64_t)&cfa) & 1) == 0)
  {
LABEL_32:
    AMSupportLogInternal();
    a3 = 0;
    goto LABEL_28;
  }
LABEL_21:
  CFDictionaryGetCount(v13[10]);
  AMSupportLogInternal();
  if (cfa)
    AMSupportLogInternal();
  v18 = (const void *)AMFDRGetMemoryStore((uint64_t)v13);
  v19 = CFPropertyListCreateData(v12, v18, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  if (!v19 || error)
    goto LABEL_32;
  *(_QWORD *)a3 = CFRetain(v19);
  a3 = 1;
  if (a4 && cfa)
    *a4 = CFRetain(cfa);
LABEL_28:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return a3;
}

uint64_t AMFDRSealingManifestCopyDataClassesInstancesAndProperties(const __CFData *a1, CFTypeRef *a2, CFTypeRef *a3, CFTypeRef *a4, _QWORD *a5)
{
  _QWORD *v10;
  _QWORD *v11;
  CFTypeRef v12;
  uint64_t v13;
  const __CFString *v15;
  const __CFString *v16;
  CFTypeRef cf;
  CFTypeRef v18;

  v18 = 0;
  cf = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyDataClassesInstancesAndProperties", CFSTR("sealingManifest is NULL"), (char)cf);
    v13 = 0;
    goto LABEL_10;
  }
  if (!a2)
  {
    v15 = CFSTR("outManifestProperties is NULL");
LABEL_15:
    AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyDataClassesInstancesAndProperties", v15, (char)cf);
    v13 = 0;
    goto LABEL_10;
  }
  if (!a3)
  {
    v15 = CFSTR("outDataClasses is NULL");
    goto LABEL_15;
  }
  if (!a4)
  {
    v15 = CFSTR("outDataInstances is NULL");
    goto LABEL_15;
  }
  v10 = AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Local"), 0);
  v11 = v10;
  if (!v10)
  {
    AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyDataClassesInstancesAndProperties", CFSTR("amfdr is NULL"), (char)cf);
LABEL_18:
    v13 = 0;
    goto LABEL_10;
  }
  if ((AMFDRDataDecodeAndSetSealingManifest(v10, a1, 0, 0, 0, (uint64_t)a5) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyDataClassesInstancesAndProperties", CFSTR("AMFDRDataDecodeAndSetSealingManifest failed"), (char)cf);
    goto LABEL_18;
  }
  v12 = AMFDRSealingMapCopyManifestProperties(v11, (uint64_t)a5);
  if (!v12)
  {
    v16 = CFSTR("AMFDRSealingMapCopyManifestProperties failed");
LABEL_22:
    AMFDRErrorPushInternal((uint64_t)a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyDataClassesInstancesAndProperties", v16, (char)cf);
    v13 = 0;
    goto LABEL_10;
  }
  if (!_AMFDRSealingManifestCopyDataClassesAndInstances((uint64_t)v11, 0, 0, 0, 0, 0, &v18, &cf, 0, 0, 0, 0, a5))
  {
    v16 = CFSTR("_AMFDRSealingManifestCopyDataClassesAndInstances failed");
    goto LABEL_22;
  }
  *a2 = CFRetain(v12);
  *a3 = CFRetain(v18);
  *a4 = CFRetain(cf);
  v13 = 1;
LABEL_10:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v13;
}

CFTypeRef AMFDRSealingMapCopyManifestProperties(_QWORD *cf, uint64_t a2)
{
  CFTypeRef v3;
  const __CFAllocator *v4;
  __CFDictionary *Mutable;
  uint64_t ManifestPropertyEntriesForDevice;
  const __CFArray *v7;
  CFIndex v8;
  CFStringRef v9;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v11;
  CFTypeID v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFAllocator *v15;
  const __CFString *v17;
  uint64_t v18;
  CFIndex v19;
  void *value[2];
  void *v21[2];
  __int128 v22;
  const __CFString *format;
  const __CFString *v24;
  uint64_t v25;
  CFTypeRef cfa;

  v3 = cf;
  cfa = 0;
  if (!cf)
  {
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestProperties", CFSTR("amfdr is NULL"), (char)v24);
    goto LABEL_31;
  }
  if (!cf[2])
  {
    AMFDRErrorPushInternal(a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestProperties", CFSTR("amfdr->optionsDict is NULL"), (char)v24);
LABEL_39:
    v3 = 0;
    goto LABEL_31;
  }
  v4 = CFGetAllocator(cf);
  Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestProperties", CFSTR("manifestProperties is NULL"), (char)v24);
    goto LABEL_39;
  }
  ManifestPropertyEntriesForDevice = _AMFDRSealingMapGetManifestPropertyEntriesForDevice((uint64_t)v3);
  if (!ManifestPropertyEntriesForDevice)
  {
    format = CFSTR("Could not get manifest properties");
    *(_OWORD *)v21 = 0u;
    v22 = 0u;
    *(_OWORD *)value = 0u;
    v18 = a2;
LABEL_35:
    v19 = 1;
    goto LABEL_38;
  }
  v7 = (const __CFArray *)ManifestPropertyEntriesForDevice;
  if (!AMFDRSealingMapPopulateSealingManifest((uint64_t)v3, 0, a2))
  {
    format = CFSTR("AMFDRSealingMapPopulateSealingManifest failed");
    *(_OWORD *)v21 = 0u;
    v22 = 0u;
    *(_OWORD *)value = 0u;
    v18 = a2;
LABEL_37:
    v19 = 10;
LABEL_38:
    AMFDRErrorPushInternal(v18, v19, 0, 0, 0, 0, 0, 0, value[0], value[1], v21[0], v21[1], (void *)v22, *((void **)&v22 + 1), (uint64_t)"AMFDRSealingMapCopyManifestProperties", format, (char)v24);
    goto LABEL_39;
  }
  if (CFArrayGetCount(v7) >= 1)
  {
    v25 = a2;
    v8 = 0;
    v9 = 0;
    while (1)
    {
      if (cfa)
      {
        CFRelease(cfa);
        cfa = 0;
      }
      if (v9)
        CFRelease(v9);
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v8);
      v11 = ValueAtIndex;
      if (!ValueAtIndex || (v12 = CFGetTypeID(ValueAtIndex), v12 != CFDictionaryGetTypeID()))
      {
        LOBYTE(v24) = (_BYTE)v11;
        v17 = CFSTR("Object of unexpected type '%@' in manifest property entries");
LABEL_34:
        format = v17;
        *(_OWORD *)v21 = 0u;
        v22 = 0u;
        *(_OWORD *)value = 0u;
        v18 = v25;
        goto LABEL_35;
      }
      v13 = (const __CFString *)CFDictionaryGetValue(v11, CFSTR("Tag"));
      if (!v13)
      {
        v24 = CFSTR("Tag");
        v17 = CFSTR("Missing key '%@' in manifest property entry");
        goto LABEL_34;
      }
      v14 = v13;
      if (_propertyEntryHasAttribute(v11, CFSTR("StoreAsInteger"), 0))
      {
        if ((AMFDRDataCopySealingManifestIntegerProperty(v3, v14, (uint64_t)&cfa) & 1) == 0)
          goto LABEL_36;
      }
      else if ((AMFDRDataCopySealingManifestProperty(v3, v14, (uint64_t)&cfa) & 1) == 0)
      {
LABEL_36:
        format = CFSTR("AMFDRDataCopySealingManifestProperty failed");
        *(_OWORD *)v21 = 0u;
        v22 = 0u;
        *(_OWORD *)value = 0u;
        v18 = v25;
        goto LABEL_37;
      }
      if (!cfa)
        break;
      if (_propertyEntryHasAttribute(v11, CFSTR("StoreAsData"), 0)
        || _propertyEntryHasAttribute(v11, CFSTR("StoreAsInteger"), 0))
      {
        CFDictionaryAddValue(Mutable, v14, cfa);
LABEL_24:
        v9 = 0;
        goto LABEL_25;
      }
      v15 = CFGetAllocator(v3);
      v9 = CFStringCreateFromExternalRepresentation(v15, (CFDataRef)cfa, 0x8000100u);
      if (!v9)
      {
        AMFDRErrorPushInternal(v25, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyManifestProperties", CFSTR("Error to create string from property data for %@"), (char)v14);
        goto LABEL_39;
      }
      CFDictionaryAddValue(Mutable, v14, v9);
LABEL_25:
      if (++v8 >= CFArrayGetCount(v7))
        goto LABEL_29;
    }
    AMSupportLogInternal();
    goto LABEL_24;
  }
LABEL_29:
  v3 = CFRetain(Mutable);
  if (!CFDictionaryGetCount(Mutable))
    AMSupportLogInternal();
LABEL_31:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v3;
}

uint64_t AMFDRSealingMapVerifySealingManifestProperties(const void *a1, const void *a2, uint64_t a3)
{
  return AMFDRSealingMapVerifySealingManifestPropertiesInternal(a1, a2, 0, a3);
}

uint64_t AMFDRSealingMapVerifySealingManifestPropertiesInternal(CFTypeRef cf, CFTypeRef a2, CFTypeRef *a3, uint64_t a4)
{
  CFTypeID v8;
  const __CFAllocator *v9;
  CFMutableArrayRef Mutable;
  const __CFArray *ManifestPropertyEntriesForDevice;
  const __CFArray *v12;
  CFIndex Count;
  CFIndex v14;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v16;
  uint64_t Value;
  const __CFAllocator *v18;
  const __CFString *v19;
  CFTypeID v20;
  CFTypeID v21;
  const __CFString *v22;
  BOOL HasAttribute;
  const __CFAllocator *v24;
  const __CFString *v25;
  const __CFString *format;
  char v28;
  CFTypeRef *v29;
  __CFArray *theArray;
  const __CFString *v31;
  CFRange v32;

  v31 = 0;
  if (!cf)
  {
    format = CFSTR("amfdr is NULL");
LABEL_48:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealingManifestPropertiesInternal", format, v28);
    goto LABEL_49;
  }
  if (a2)
  {
    v8 = CFGetTypeID(a2);
    if (v8 != CFArrayGetTypeID())
    {
      format = CFSTR("ingoreProperties is not a CFArray");
      goto LABEL_48;
    }
  }
  v9 = CFGetAllocator(cf);
  Mutable = CFArrayCreateMutable(v9, 0, MEMORY[0x24BDBD690]);
  ManifestPropertyEntriesForDevice = (const __CFArray *)_AMFDRSealingMapGetManifestPropertyEntriesForDevice((uint64_t)cf);
  if (!ManifestPropertyEntriesForDevice)
  {
    AMFDRErrorPushInternal(a4, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealingManifestPropertiesInternal", CFSTR("_AMFDRSealingMapGetManifestPropertyEntriesForDevice failed"), v28);
    goto LABEL_49;
  }
  v12 = ManifestPropertyEntriesForDevice;
  Count = CFArrayGetCount(ManifestPropertyEntriesForDevice);
  if (!AMFDRSealingMapPopulateSealingManifest((uint64_t)cf, 0, a4))
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealingManifestPropertiesInternal", CFSTR("AMFDRSealingMapPopulateSealingManifest failed"), v28);
    goto LABEL_49;
  }
  v29 = a3;
  theArray = Mutable;
  if (Count >= 1)
  {
    v14 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v12, v14);
      if (!ValueAtIndex)
      {
        AMFDRErrorPushInternal(a4, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealingManifestPropertiesInternal", CFSTR("Cannot get entry at index %ld"), v14);
        Value = 0;
        goto LABEL_50;
      }
      v16 = ValueAtIndex;
      Value = (uint64_t)CFDictionaryGetValue(ValueAtIndex, CFSTR("Tag"));
      if (!Value)
      {
        AMFDRErrorPushInternal(a4, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealingManifestPropertiesInternal", CFSTR("Cannot get property tag from entry %ld"), v14);
        goto LABEL_50;
      }
      v18 = CFGetAllocator(cf);
      v19 = (const __CFString *)_copyMGValuePropertyEntry(v18, v16, 0);
      if (_propertyEntryHasAttribute(v16, CFSTR("StoreAsInteger"), 0))
        break;
      if ((AMFDRDataCopySealingManifestProperty(cf, (const __CFString *)Value, (uint64_t)&v31) & 1) == 0)
        goto LABEL_14;
LABEL_15:
      if (v19 && v31)
      {
        v20 = CFGetTypeID(v19);
        if (v20 == CFDataGetTypeID() || (v21 = CFGetTypeID(v19), v21 == CFNumberGetTypeID()))
        {
          v22 = 0;
          if (!CFEqual(v19, v31))
            goto LABEL_27;
        }
        else
        {
          v24 = CFGetAllocator(cf);
          v25 = CFStringCreateFromExternalRepresentation(v24, (CFDataRef)v31, 0x8000100u);
          v22 = v25;
          if (!v25 || CFStringCompare(v25, v19, 0))
            goto LABEL_27;
        }
      }
      else
      {
        if (v19 != v31)
        {
          v22 = 0;
LABEL_27:
          if (!a2
            || (v32.length = CFArrayGetCount((CFArrayRef)a2),
                v32.location = 0,
                !CFArrayContainsValue((CFArrayRef)a2, v32, (const void *)Value)))
          {
            CFArrayAppendValue(theArray, (const void *)Value);
          }
          AMSupportLogInternal();
          goto LABEL_31;
        }
        HasAttribute = _propertyEntryHasAttribute(v16, CFSTR("Required"), 0);
        v22 = 0;
        if (HasAttribute)
          goto LABEL_27;
      }
LABEL_31:
      if (v31)
      {
        CFRelease(v31);
        v31 = 0;
      }
      if (v22)
        CFRelease(v22);
      if (v19)
        CFRelease(v19);
      if (Count == ++v14)
        goto LABEL_38;
    }
    if ((AMFDRDataCopySealingManifestIntegerProperty(cf, (const __CFString *)Value, (uint64_t)&v31) & 1) != 0)
      goto LABEL_15;
LABEL_14:
    AMSupportLogInternal();
    goto LABEL_15;
  }
LABEL_38:
  if (!CFArrayGetCount(theArray))
  {
    Value = 1;
    goto LABEL_50;
  }
  AMFDRErrorPushInternal(a4, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifySealingManifestPropertiesInternal", CFSTR("Mismatched properties: %@"), (char)theArray);
  if (!v29)
  {
LABEL_49:
    Value = 0;
    goto LABEL_50;
  }
  Value = 0;
  *v29 = CFRetain(theArray);
LABEL_50:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return Value;
}

uint64_t AMFDRSealingMapVerifySealingManifestPropertyMatching(const void *a1, uint64_t a2)
{
  return AMFDRSealingMapVerifySealingManifestPropertiesInternal(a1, 0, 0, a2);
}

uint64_t AMFDRSealingMapAutoChallengeClaim(uint64_t a1, uint64_t a2, int a3, CFTypeRef *a4)
{
  uint64_t v5;
  __CFString *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const __CFString *PermissionsString;
  const void *v13;
  __CFString *v14;
  __CFString *ValueAtIndex;
  CFTypeID v16;
  const void *v17;
  CFTypeID v18;
  uint64_t v19;
  uint64_t v20;
  __CFString *v21;
  const __CFString *v23;
  char v24;
  CFTypeRef cf;
  CFArrayRef v26;
  CFArrayRef theArray;
  CFTypeRef v28;

  v5 = a2;
  v28 = 0;
  v26 = 0;
  theArray = 0;
  cf = 0;
  if (!a2)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapAutoChallengeClaim", CFSTR("amfdrRemote is NULL"), v24);
    v14 = 0;
    v13 = 0;
    PermissionsString = 0;
    v8 = 0;
    goto LABEL_31;
  }
  v8 = (__CFString *)AMFDRCreateCopy(a2);
  if (!v8)
  {
    v23 = CFSTR("cannot create a separate amfdrRemote object for challenge claim");
    goto LABEL_57;
  }
  if ((AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute((void *)v5, 0, 0, 0, CFSTR("ChallengeClaim"), (CFTypeRef *)&theArray, (CFTypeRef *)&v26, 0, (uint64_t)a4) & 1) == 0)
  {
    v23 = CFSTR("AMFDRSealingMapCopyDataClassesAndInstancesWithAttribute failed");
LABEL_57:
    AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapAutoChallengeClaim", v23, v24);
LABEL_49:
    v5 = 0;
LABEL_50:
    v14 = 0;
LABEL_51:
    v13 = 0;
    PermissionsString = 0;
    goto LABEL_31;
  }
  if (theArray)
  {
    Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      v10 = Count;
      v11 = 0;
      PermissionsString = 0;
      v13 = 0;
      v14 = 0;
      while (1)
      {
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        if (v13)
          CFRelease(v13);
        if (v14)
          CFRelease(v14);
        if (PermissionsString)
          CFRelease(PermissionsString);
        ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(theArray, v11);
        v14 = ValueAtIndex;
        if (!ValueAtIndex)
        {
          AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapAutoChallengeClaim", CFSTR("dataClass is NULL"), v24);
          v5 = 0;
          goto LABEL_51;
        }
        v16 = CFGetTypeID(ValueAtIndex);
        if (v16 != CFStringGetTypeID())
        {
          AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapAutoChallengeClaim", CFSTR("Object of unexpected type '%@' for key dataClass, expected CFString"), (char)v14);
          goto LABEL_49;
        }
        v17 = CFArrayGetValueAtIndex(v26, v11);
        v5 = (uint64_t)v17;
        if (!v17)
        {
          AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapAutoChallengeClaim", CFSTR("dataInstance is NULL"), v24);
          goto LABEL_50;
        }
        v18 = CFGetTypeID(v17);
        if (v18 != CFStringGetTypeID())
        {
          AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapAutoChallengeClaim", CFSTR("Object of unexpected type '%@' for key dataInstance, expected CFString"), v5);
          goto LABEL_49;
        }
        v13 = (const void *)AMFDRSealingMapCopyLocalData(v14, (const __CFString *)v5, *(const __CFDictionary **)(a1 + 16), (uint64_t)&cf);
        if (!cf
          || (v19 = AMFDRGetUnderlyingErrorCode(a1, (CFErrorRef *)&cf), v20 = AMFDRGetTrustError((__CFError *)cf), a3)
          && v19 == 18
          && (v20 & 0xFFFD9FFFFFFFFEFFLL) == 0)
        {
          AMSupportLogInternal();
          v14 = 0;
          PermissionsString = 0;
        }
        else
        {
          AMSupportLogInternal();
          PermissionsString = AMFDRDataCreatePermissionsString(v8, 8u, v14, (const __CFString *)v5);
          if (!PermissionsString)
          {
            AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapAutoChallengeClaim", CFSTR("AMFDRDataCreatePermissionsString failed"), v24);
            v5 = 0;
            v14 = 0;
            goto LABEL_31;
          }
          AMFDRSetOption((uint64_t)v8, CFSTR("Permissions"), PermissionsString);
          v21 = (__CFString *)AMFDRDataHTTPChallengeClaim((uint64_t)v8, v14, (const void *)v5, &v28);
          v14 = v21;
          if (v28)
          {
            AMFDRErrorPushInternal((uint64_t)&v28, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapAutoChallengeClaim", CFSTR("AMFDRDataHTTPChallengeClaim failed"), v24);
            v5 = 0;
            goto LABEL_31;
          }
          if (!v21)
          {
            AMFDRErrorPushInternal((uint64_t)a4, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapAutoChallengeClaim", CFSTR("responseClaimData is NULL"), v24);
            v5 = 0;
            goto LABEL_31;
          }
        }
        if (v10 == ++v11)
        {
          v5 = 1;
          goto LABEL_31;
        }
      }
    }
  }
  v14 = 0;
  v13 = 0;
  PermissionsString = 0;
  v5 = 1;
LABEL_31:
  if (a4 && v28)
    *a4 = CFRetain(v28);
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v13)
    CFRelease(v13);
  if (v14)
    CFRelease(v14);
  if (PermissionsString)
    CFRelease(PermissionsString);
  if (v8)
    CFRelease(v8);
  return v5;
}

uint64_t AMFDRSealingMapCopyDataClassesWithAttribute(uint64_t a1, const void *a2, CFTypeRef *a3, uint64_t a4)
{
  return AMFDRSealingMapCopyDataClassesWithAttributeInternal(0, a2, a3, a4);
}

uint64_t AMFDRSealingMapCopyDataClassesWithAttributeInternal(CFTypeRef cf, const void *a2, CFTypeRef *a3, uint64_t a4)
{
  const __CFAllocator *v8;
  const __CFArray *Mutable;
  const __CFArray *EntriesForDeviceInternal;
  const __CFArray *v11;
  CFIndex v12;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v14;
  CFTypeID v15;
  const void *Value;
  const void *v17;
  CFTypeID v18;
  CFTypeID TypeID;
  CFIndex Count;
  uint64_t v21;
  const __CFString *v23;
  const __CFString *v24;
  CFRange v25;

  if (cf)
    v8 = CFGetAllocator(cf);
  else
    v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesWithAttributeInternal", CFSTR("Failed to allocate dataClasses"), (char)v24);
    goto LABEL_24;
  }
  EntriesForDeviceInternal = (const __CFArray *)AMFDRSealingMapGetEntriesForDeviceInternal((uint64_t)cf);
  if (!EntriesForDeviceInternal)
  {
    v23 = CFSTR("Failed to get sealing map");
LABEL_23:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDataClassesWithAttributeInternal", v23, (char)v24);
LABEL_24:
    v21 = 0;
    goto LABEL_19;
  }
  v11 = EntriesForDeviceInternal;
  if (CFArrayGetCount(EntriesForDeviceInternal) >= 1)
  {
    v12 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v11, v12);
      v14 = ValueAtIndex;
      if (!ValueAtIndex || (v15 = CFGetTypeID(ValueAtIndex), v15 != CFDictionaryGetTypeID()))
      {
        LOBYTE(v24) = (_BYTE)v14;
        v23 = CFSTR("Unexpected type '%@' in sealing map");
        goto LABEL_23;
      }
      Value = CFDictionaryGetValue(v14, CFSTR("Tag"));
      if (!Value)
      {
        v24 = CFSTR("Tag");
        v23 = CFSTR("Missing key '%@' in sealing map entry");
        goto LABEL_23;
      }
      v17 = Value;
      v18 = CFGetTypeID(Value);
      TypeID = CFStringGetTypeID();
      if (v18 != TypeID)
        break;
      if (AMFDRSealingMapEntryHasAttributeInternal(TypeID, v14, a2, 0))
      {
        v25.length = CFArrayGetCount(Mutable);
        v25.location = 0;
        if (!CFArrayContainsValue(Mutable, v25, v17))
          CFArrayAppendValue(Mutable, v17);
      }
      if (++v12 >= CFArrayGetCount(v11))
        goto LABEL_16;
    }
    LOBYTE(v24) = (_BYTE)v17;
    v23 = CFSTR("Unexpected type '%@' for key '%@' in sealing map entry");
    goto LABEL_23;
  }
LABEL_16:
  Count = CFArrayGetCount(Mutable);
  v21 = 1;
  if (a3 && Count)
    *a3 = CFRetain(Mutable);
LABEL_19:
  AMSupportSafeRelease();
  return v21;
}

uint64_t AMFDRSealingMapCopySubCCDataClasses(CFTypeRef cf, const void *a2, CFTypeRef *a3, uint64_t a4)
{
  const __CFAllocator *v8;
  const __CFAllocator *v9;
  const __CFDictionary *v10;
  const __CFArray *Value;
  CFTypeID v12;
  CFMutableDictionaryRef Mutable;
  const __CFArray *EntriesForDeviceInternal;
  const __CFArray *v15;
  CFIndex v16;
  CFMutableArrayRef v17;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v19;
  CFTypeID v20;
  const __CFArray *v21;
  const __CFArray *v22;
  CFTypeID v23;
  const void *v24;
  const void *v25;
  CFTypeID v26;
  CFStringRef v27;
  uint64_t v28;
  CFIndex v29;
  const __CFDictionary *v30;
  const __CFDictionary *v31;
  CFTypeID v32;
  const void *v33;
  const void *v34;
  CFTypeID v35;
  CFTypeID TypeID;
  CFIndex Count;
  uint64_t v38;
  char v40;
  uint64_t v41;
  CFTypeRef *v42;
  const __CFAllocator *allocator;
  const __CFDictionary *theDict;
  const __CFAllocator *v45;
  const __CFArray *theArray;
  CFStringRef FullKey;
  const void *v48;
  CFTypeRef v49[2];
  CFRange v50;

  v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v49[0] = 0;
  if (cf)
  {
    v9 = CFGetAllocator(cf);
    v10 = (const __CFDictionary *)AMFDRGetOptions((uint64_t)cf);
    if (v10 && (Value = (const __CFArray *)CFDictionaryGetValue(v10, CFSTR("SkipRecoverDataClasses"))) != 0)
    {
      theArray = Value;
      v12 = CFGetTypeID(Value);
      if (v12 != CFArrayGetTypeID())
      {
        AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("malformed skipDataClasses"), v40);
LABEL_60:
        v38 = 0;
        goto LABEL_56;
      }
    }
    else
    {
      theArray = 0;
    }
  }
  else
  {
    theArray = 0;
    v9 = v8;
  }
  Mutable = CFDictionaryCreateMutable(v9, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("Failed to allocate subCCListDict"), v40);
    goto LABEL_60;
  }
  EntriesForDeviceInternal = (const __CFArray *)AMFDRSealingMapGetEntriesForDeviceInternal((uint64_t)cf);
  if (!EntriesForDeviceInternal)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("Failed to get sealing map"), v40);
    goto LABEL_60;
  }
  v15 = EntriesForDeviceInternal;
  v42 = a3;
  theDict = Mutable;
  if (CFArrayGetCount(EntriesForDeviceInternal) < 1)
  {
LABEL_45:
    Count = CFDictionaryGetCount(theDict);
    v38 = 1;
    if (v42 && Count)
      *v42 = CFRetain(theDict);
    goto LABEL_56;
  }
  allocator = v9;
  v45 = v8;
  v41 = a4;
  v16 = 0;
  FullKey = 0;
  v48 = 0;
  v17 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, v16);
    v19 = ValueAtIndex;
    if (!ValueAtIndex || (v20 = CFGetTypeID(ValueAtIndex), v20 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(v41, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("Unexpected type '%@' in sealing map"), (char)v19);
      goto LABEL_55;
    }
    v21 = (const __CFArray *)CFDictionaryGetValue(v19, CFSTR("SubCCList"));
    if (v21)
      break;
LABEL_44:
    if (++v16 >= CFArrayGetCount(v15))
      goto LABEL_45;
  }
  v22 = v21;
  v23 = CFGetTypeID(v21);
  if (v23 != CFArrayGetTypeID())
  {
    AMFDRErrorPushInternal(v41, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("unexpected subcclist array type"), v40);
    goto LABEL_55;
  }
  v24 = CFDictionaryGetValue(v19, CFSTR("Tag"));
  if (!v24)
  {
    AMFDRErrorPushInternal(v41, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
    goto LABEL_55;
  }
  v25 = v24;
  v26 = CFGetTypeID(v24);
  if (v26 != CFStringGetTypeID())
  {
    AMFDRErrorPushInternal(v41, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("Unexpected type '%@' for key '%@' in sealing map entry"), (char)v25);
    goto LABEL_55;
  }
  if (theArray)
  {
    v50.length = CFArrayGetCount(theArray);
    v50.location = 0;
    if (CFArrayContainsValue(theArray, v50, v25))
    {
      if (_isSealingClass((_BOOL8)v25))
      {
        AMFDRErrorPushInternal(v41, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("Could not skip seal class '%@'"), (char)v25);
        goto LABEL_55;
      }
      goto LABEL_44;
    }
  }
  if (v48)
    CFRelease(v48);
  if (v49[0])
  {
    CFRelease(v49[0]);
    v49[0] = 0;
  }
  v27 = _copyIdentifierListForSealingMapEntry(v45, v19, 0, 0, 0, (uint64_t)v49);
  if (!v27)
  {
    AMSupportLogInternal();
    v48 = 0;
    goto LABEL_44;
  }
  v28 = (uint64_t)v27;
  if (FullKey)
    CFRelease(FullKey);
  FullKey = AMFDRDataLocalCreateFullKey(v45, (uint64_t)v25, v28);
  if (v17)
    CFRelease(v17);
  v48 = (const void *)v28;
  v17 = CFArrayCreateMutable(allocator, 0, MEMORY[0x24BDBD690]);
  if (!v17)
  {
    AMFDRErrorPushInternal(v41, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("Failed to allocate subCCdataClasses"), v40);
    goto LABEL_55;
  }
  if (CFArrayGetCount(v22) < 1)
  {
LABEL_42:
    CFDictionarySetValue(theDict, FullKey, v17);
    goto LABEL_44;
  }
  v29 = 0;
  while (1)
  {
    v30 = (const __CFDictionary *)CFArrayGetValueAtIndex(v22, v29);
    v31 = v30;
    if (!v30 || (v32 = CFGetTypeID(v30), v32 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(v41, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("Unexpected type '%@' in subcc list"), (char)v31);
      goto LABEL_55;
    }
    v33 = CFDictionaryGetValue(v31, CFSTR("Tag"));
    if (!v33)
    {
      AMFDRErrorPushInternal(v41, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("Missing key '%@' in subcc list entry"), (char)CFSTR("Tag"));
      goto LABEL_55;
    }
    v34 = v33;
    v35 = CFGetTypeID(v33);
    TypeID = CFStringGetTypeID();
    if (v35 != TypeID)
      break;
    if (AMFDRSealingMapEntryHasAttributeInternal(TypeID, v31, a2, 0))
      CFArrayAppendValue(v17, v34);
    else
      AMSupportLogInternal();
    if (++v29 >= CFArrayGetCount(v22))
      goto LABEL_42;
  }
  AMFDRErrorPushInternal(v41, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopySubCCDataClasses", CFSTR("Unexpected type '%@' for key '%@' in subcc list entry"), (char)v34);
LABEL_55:
  v38 = 0;
LABEL_56:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v38;
}

uint64_t AMFDRSealingMapCopyPropertyTagsWithAttribute(uint64_t a1, const void *a2, uint64_t *a3, uint64_t a4)
{
  return AMFDRSealingMapCopyPropertyTagsWithAttributeInternal(0, a2, a3, a4);
}

uint64_t AMFDRSealingMapCopyPropertyTagsWithAttributeInternal(const void *a1, const void *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t ManifestPropertyEntriesForDevice;
  const __CFArray *v9;
  const __CFAllocator *v10;
  __CFArray *Mutable;
  CFIndex v12;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v14;
  CFTypeID v15;
  const __CFString *Value;
  const __CFString *v17;
  CFTypeID v18;
  uint64_t v19;
  const __CFString *v21;
  char v22;
  const __CFString *v23;
  uint64_t v24;

  ManifestPropertyEntriesForDevice = _AMFDRSealingMapGetManifestPropertyEntriesForDevice((uint64_t)a1);
  v9 = (const __CFArray *)ManifestPropertyEntriesForDevice;
  if (a1)
  {
    v10 = CFGetAllocator(a1);
    if (!v9)
    {
LABEL_21:
      if (a3)
        goto LABEL_18;
      goto LABEL_19;
    }
  }
  else
  {
    v10 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    if (!ManifestPropertyEntriesForDevice)
      goto LABEL_21;
  }
  if (CFArrayGetCount(v9) < 1)
    goto LABEL_21;
  v24 = a4;
  Mutable = 0;
  v12 = 0;
  do
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, v12);
    v14 = ValueAtIndex;
    if (!ValueAtIndex || (v15 = CFGetTypeID(ValueAtIndex), v15 != CFDictionaryGetTypeID()))
    {
      LOBYTE(v23) = (_BYTE)v14;
      v21 = CFSTR("Object of unexpected type '%@' in manifest property entries");
LABEL_27:
      AMFDRErrorPushInternal(v24, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyPropertyTagsWithAttributeInternal", v21, (char)v23);
LABEL_28:
      v19 = 0;
      goto LABEL_20;
    }
    Value = (const __CFString *)CFDictionaryGetValue(v14, CFSTR("Tag"));
    if (!Value)
    {
      v23 = CFSTR("Tag");
      v21 = CFSTR("Missing key '%@' in manifest property entry");
      goto LABEL_27;
    }
    v17 = Value;
    v18 = CFGetTypeID(Value);
    if (v18 != CFStringGetTypeID())
    {
      LOBYTE(v23) = (_BYTE)v17;
      v21 = CFSTR("Object of unexpected type '%@' for key '%@' in manifest property entry");
      goto LABEL_27;
    }
    if (CFStringGetLength(v17) != 4)
    {
      LOBYTE(v23) = (_BYTE)v17;
      v21 = CFSTR("Key '%@' length should be 4 for '%@' in manifest property entry");
      goto LABEL_27;
    }
    if (_propertyEntryHasAttribute(v14, a2, 0))
    {
      if (!Mutable)
      {
        Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x24BDBD690]);
        if (!Mutable)
        {
          AMFDRErrorPushInternal(v24, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyPropertyTagsWithAttributeInternal", CFSTR("propertyTags is NULL"), v22);
          goto LABEL_28;
        }
      }
      CFArrayAppendValue(Mutable, v17);
    }
    ++v12;
  }
  while (v12 < CFArrayGetCount(v9));
  if (!a3)
    goto LABEL_19;
LABEL_18:
  *a3 = AMSupportSafeRetain();
LABEL_19:
  v19 = 1;
LABEL_20:
  AMSupportSafeRelease();
  return v19;
}

__CFDictionary *AMFDRSealingMapCopyPropertyTagsAndIdentifiers(uint64_t a1)
{
  uint64_t ManifestPropertyEntriesForDevice;
  const __CFArray *v3;
  __CFDictionary *Mutable;
  CFIndex v5;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v7;
  CFTypeID v8;
  const void *Value;
  const void *v10;
  CFTypeID v11;
  const void *v12;
  const void *v13;
  CFTypeID v14;
  __CFDictionary *v15;
  const __CFString *v17;
  char v18;
  char v19;

  ManifestPropertyEntriesForDevice = _AMFDRSealingMapGetManifestPropertyEntriesForDevice(0);
  if (!ManifestPropertyEntriesForDevice)
  {
    AMFDRErrorPushInternal(a1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyPropertyTagsAndIdentifiersWithAttribute", CFSTR("Failed to query manifest property entries"), v18);
    v15 = 0;
    goto LABEL_13;
  }
  v3 = (const __CFArray *)ManifestPropertyEntriesForDevice;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyPropertyTagsAndIdentifiersWithAttribute", CFSTR("propertyInfo is NULL"), v18);
LABEL_18:
    v15 = 0;
    goto LABEL_13;
  }
  if (CFArrayGetCount(v3) >= 1)
  {
    v5 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, v5);
      v7 = ValueAtIndex;
      if (!ValueAtIndex || (v8 = CFGetTypeID(ValueAtIndex), v8 != CFDictionaryGetTypeID()))
      {
        v19 = (char)v7;
        v17 = CFSTR("Object of unexpected type '%@' in manifest property entries");
        goto LABEL_17;
      }
      Value = CFDictionaryGetValue(v7, CFSTR("Tag"));
      if (!Value || (v10 = Value, v11 = CFGetTypeID(Value), v11 != CFStringGetTypeID()))
      {
        v19 = v5;
        v17 = CFSTR("Unexpected type for property tag %ld");
        goto LABEL_17;
      }
      v12 = CFDictionaryGetValue(v7, CFSTR("PropertyIdentifier"));
      if (!v12)
        break;
      v13 = v12;
      v14 = CFGetTypeID(v12);
      if (v14 != CFStringGetTypeID())
        break;
      CFDictionarySetValue(Mutable, v10, v13);
      if (++v5 >= CFArrayGetCount(v3))
        goto LABEL_12;
    }
    v19 = v5;
    v17 = CFSTR("Unexpected type for property identifier %ld");
LABEL_17:
    AMFDRErrorPushInternal(a1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyPropertyTagsAndIdentifiersWithAttribute", v17, v19);
    goto LABEL_18;
  }
LABEL_12:
  v15 = Mutable;
LABEL_13:
  AMSupportSafeRelease();
  return v15;
}

CFTypeRef AMFDRSealingManifestCopyInstanceForClass(const void *a1, const __CFDictionary *a2, _QWORD *a3)
{
  _QWORD *v5;
  uint64_t v6;
  CFIndex v7;
  const void *ValueAtIndex;
  const __CFString *v9;
  CFTypeRef v10;
  const void *v11;
  const __CFString *v13;
  char v14;
  const __CFArray *v15;
  const __CFArray *v16;

  v15 = 0;
  v16 = 0;
  v5 = AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Local"), a2);
  v6 = (uint64_t)v5;
  if (!v5)
  {
    v9 = CFSTR("Create amfdr failed");
    goto LABEL_9;
  }
  if ((AMFDRSealingMapPopulateSealingManifest((uint64_t)v5, 0, (uint64_t)a3) & 1) == 0)
  {
    v13 = CFSTR("AMFDRSealingMapPopulateSealingManifest failed");
    goto LABEL_18;
  }
  if (!_AMFDRSealingManifestCopyDataClassesAndInstances(v6, 0, 0, 0, 0, 0, (CFTypeRef *)&v16, (CFTypeRef *)&v15, 0, 0, 0, 0, a3))
  {
    v13 = CFSTR("_AMFDRSealingManifestCopyDataClassesAndInstances failed");
    goto LABEL_18;
  }
  if (CFArrayGetCount(v16) >= 1)
  {
    v7 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v16, v7);
      if (CFEqual(a1, ValueAtIndex))
        break;
      if (++v7 >= CFArrayGetCount(v16))
        goto LABEL_8;
    }
    v11 = CFArrayGetValueAtIndex(v15, v7);
    if (v11)
    {
      v10 = CFRetain(v11);
      if (v10)
        goto LABEL_13;
      goto LABEL_8;
    }
    v13 = CFSTR("dataInstance is NULL");
LABEL_18:
    AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyInstanceForClass", v13, v14);
    goto LABEL_10;
  }
LABEL_8:
  v14 = (char)a1;
  v9 = CFSTR("Could not find dataClass '%@' in sealing manifest, outDataInstance is NULL");
LABEL_9:
  AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyInstanceForClass", v9, v14);
LABEL_10:
  v10 = 0;
LABEL_13:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v10;
}

CFTypeRef AMFDRSealingManifestCopyMultiInstanceForClass(const void *a1, const __CFDictionary *a2, _QWORD *a3)
{
  const __CFAllocator *v5;
  _QWORD *v6;
  uint64_t v7;
  __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v11;
  CFTypeRef v12;
  const __CFString *v13;
  const __CFString *v15;
  char v16;
  const __CFArray *v17;
  const __CFArray *v18;

  v17 = 0;
  v18 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyMultiInstanceForClass", CFSTR("dataClass is NULL"), v16);
LABEL_16:
    v12 = 0;
    goto LABEL_17;
  }
  v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v6 = AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Local"), a2);
  v7 = (uint64_t)v6;
  if (!v6)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyMultiInstanceForClass", CFSTR("Create amfdr failed"), v16);
    goto LABEL_16;
  }
  if ((AMFDRSealingMapPopulateSealingManifest((uint64_t)v6, 0, (uint64_t)a3) & 1) == 0)
  {
    v15 = CFSTR("AMFDRSealingMapPopulateSealingManifest failed");
LABEL_23:
    AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyMultiInstanceForClass", v15, v16);
    goto LABEL_16;
  }
  if (!_AMFDRSealingManifestCopyDataClassesAndInstances(v7, 0, 0, 0, 0, 0, (CFTypeRef *)&v18, (CFTypeRef *)&v17, 0, 0, 0, 0, a3))
  {
    v15 = CFSTR("_AMFDRSealingManifestCopyDataClassesAndInstances failed");
    goto LABEL_23;
  }
  Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    v13 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_15;
  }
  if (CFArrayGetCount(v18) >= 1)
  {
    for (i = 0; i < CFArrayGetCount(v18); ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v18, i);
      if (CFEqual(a1, ValueAtIndex))
      {
        v11 = CFArrayGetValueAtIndex(v17, i);
        if (!v11)
        {
          AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyMultiInstanceForClass", CFSTR("dataInstance is NULL"), v16);
          goto LABEL_16;
        }
        CFArrayAppendValue(Mutable, v11);
      }
    }
  }
  if (CFArrayGetCount(Mutable) < 1)
  {
    v16 = (char)a1;
    v13 = CFSTR("Could not find key '%@' in sealing manifest.");
LABEL_15:
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyMultiInstanceForClass", v13, v16);
    goto LABEL_16;
  }
  v12 = CFRetain(Mutable);
LABEL_17:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v12;
}

uint64_t AMFDRSealingManifestCopyLocalDataForClass(__CFString *a1, const __CFDictionary *a2, _QWORD *a3)
{
  const __CFString *v6;
  uint64_t v7;
  char v9;

  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyLocalDataForClass", CFSTR("dataClass is NULL"), v9);
LABEL_7:
    v7 = 0;
    goto LABEL_4;
  }
  v6 = (const __CFString *)AMFDRSealingManifestCopyInstanceForClass(a1, a2, a3);
  if (!v6)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyLocalDataForClass", CFSTR("Failed to copy dataInstance from SealingManifest"), v9);
    goto LABEL_7;
  }
  v7 = _AMFDRSealingMapCopyLocalDataInternal(a1, v6, 0, 0, 0, a2, (uint64_t)a3);
LABEL_4:
  AMSupportSafeRelease();
  return v7;
}

const __CFString *AMFDRSealingMapCopyDictFromCombinedData(const __CFData *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, int a5, _QWORD *a6)
{
  const __CFString *v8;
  const __CFAllocator *v11;
  _QWORD *v12;
  uint64_t v13;
  const __CFString *v14;
  _QWORD *v15;
  uint64_t v16;
  const __CFString *v18;
  char v19;

  if (!a1)
  {
    v18 = CFSTR("dataBlob is NULL");
LABEL_20:
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDictFromCombinedData", v18, v19);
    v8 = 0;
    goto LABEL_15;
  }
  if (!a2)
  {
    v18 = CFSTR("dataClass is NULL");
    goto LABEL_20;
  }
  v8 = a3;
  if (!a3)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDictFromCombinedData", CFSTR("dataInstance is NULL"), v19);
    goto LABEL_15;
  }
  if (!a4)
  {
    v18 = CFSTR("manifestInstance is NULL");
    goto LABEL_20;
  }
  v11 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v12 = AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Local"), 0);
  v13 = (uint64_t)v12;
  if (!v12)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDictFromCombinedData", CFSTR("Failed to create amfdrLocal"), v19);
LABEL_24:
    v8 = 0;
    goto LABEL_15;
  }
  if ((AMFDRDataApTicketPopulate((uint64_t)v12) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDictFromCombinedData", CFSTR("Failed to get ApTicket"), v19);
    goto LABEL_24;
  }
  v14 = (const __CFString *)AMFDRDataApTicketCopyObjectProperty(v13, 1718903152, 1145525076);
  if (!v14)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDictFromCombinedData", CFSTR("Unable to extract trust object digest from AP Ticket"), v19);
LABEL_28:
    v8 = 0;
    goto LABEL_15;
  }
  AMFDRSetOption(v13, CFSTR("TrustObjectDigest"), v14);
  if ((AMFDRDataCopyTrustObject(v13) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDictFromCombinedData", CFSTR("Failed to get trustObjData"), v19);
    goto LABEL_28;
  }
  v15 = AMFDRCreateTypeWithOptions(v11, CFSTR("Memory"), 0);
  v16 = (uint64_t)v15;
  if (!v15)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyDictFromCombinedData", CFSTR("Failed to create amfdrMemory"), v19);
    goto LABEL_14;
  }
  AMFDRSetOption((uint64_t)v15, CFSTR("TrustObjectDigest"), v14);
  AMFDRSetOption(v16, CFSTR("TrustObject"), 0);
  AMFDRSetOption(v16, CFSTR("INST"), a4);
  AMFDRSetOption(v16, CFSTR("SkipVerifySik"), (const __CFString *)*MEMORY[0x24BDBD270]);
  AMFDRSetOption(v16, CFSTR("SignData"), (const __CFString *)*MEMORY[0x24BDBD268]);
  if ((AMFDRDataPutWithOptions(v16, a2, v8, a1, 0, (uint64_t)a6) & 1) == 0)
  {
    AMSupportLogInternal();
    goto LABEL_14;
  }
  v8 = (const __CFString *)AMFDRDataDictCopy(v16, a2, v8, (uint64_t)a6);
  if (a6 && *a6)
  {
    AMSupportSafeRelease();
LABEL_14:
    v8 = 0;
  }
LABEL_15:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v8;
}

uint64_t AMFDRSealingMapCopyLocalDict(__CFString *a1, const __CFString *a2, const __CFDictionary *a3, uint64_t a4)
{
  const __CFString *v8;
  uint64_t v9;
  const __CFString *v11;
  char v12;

  if (!a1)
  {
    v11 = CFSTR("dataClass is NULL");
LABEL_8:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalDict", v11, v12);
LABEL_10:
    v9 = 0;
    goto LABEL_5;
  }
  if (!a2)
  {
    v11 = CFSTR("dataInstance is NULL");
    goto LABEL_8;
  }
  v8 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(a1, a4, 1, 0);
  if (!v8)
  {
    AMSupportLogInternal();
    goto LABEL_10;
  }
  v9 = _AMFDRSealingMapCopyLocalDataInternal(a1, a2, v8, 0, 1, a3, a4);
LABEL_5:
  AMSupportSafeRelease();
  return v9;
}

uint64_t AMFDRSealingMapCopyLocalDictForClass(__CFString *a1, const __CFDictionary *a2, uint64_t a3)
{
  const __CFString *v6;
  uint64_t v7;
  char v9;

  if (!a1)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalDictForClass", CFSTR("dataClass is NULL"), v9);
LABEL_7:
    v7 = 0;
    goto LABEL_4;
  }
  v6 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(a1, a3, 0, 0);
  if (!v6)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalDictForClass", CFSTR("dataInstance is NULL"), v9);
    goto LABEL_7;
  }
  v7 = AMFDRSealingMapCopyLocalDict(a1, v6, a2, a3);
LABEL_4:
  AMSupportSafeRelease();
  return v7;
}

uint64_t AMFDRSealingManifestCopyLocalDictForClass(__CFString *a1, const __CFDictionary *a2, _QWORD *a3)
{
  const __CFString *v6;
  uint64_t v7;
  char v9;

  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyLocalDictForClass", CFSTR("dataClass is NULL"), v9);
LABEL_7:
    v7 = 0;
    goto LABEL_4;
  }
  v6 = (const __CFString *)AMFDRSealingManifestCopyInstanceForClass(a1, a2, a3);
  if (!v6)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyLocalDictForClass", CFSTR("Failed to copy dataInstance from SealingManifest"), v9);
    goto LABEL_7;
  }
  v7 = _AMFDRSealingMapCopyLocalDataInternal(a1, v6, 0, 0, 1, a2, (uint64_t)a3);
LABEL_4:
  AMSupportSafeRelease();
  return v7;
}

uint64_t AMFDRSealingMapCopyMinimalManifestClassesAndInstances(void *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  return _AMFDRSealingMapCopyMinimalManifestClassesAndInstances(a1, 0, a2, a3, a4, 0, a5);
}

uint64_t _AMFDRSealingMapCopyMinimalManifestClassesAndInstances(void *a1, int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, _BYTE *a6, uint64_t a7)
{
  uint64_t EntriesForDeviceInternal;
  const __CFArray *v10;
  const __CFAllocator *v11;
  const CFArrayCallBacks *v12;
  CFMutableArrayRef Mutable;
  const __CFAllocator *v14;
  CFMutableArrayRef v15;
  CFMutableArrayRef v16;
  const __CFAllocator *v17;
  __CFArray *v18;
  const __CFAllocator *v19;
  CFMutableArrayRef v20;
  __CFArray *v21;
  CFIndex v22;
  CFStringRef v23;
  const __CFAllocator *v24;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v26;
  CFTypeID v27;
  const __CFArray *Value;
  const __CFArray *v29;
  CFStringRef v30;
  CFTypeID v31;
  const void *v32;
  const void *v33;
  CFTypeID v34;
  const __CFArray *v35;
  CFIndex v36;
  const __CFArray *v37;
  CFIndex v38;
  CFIndex Count;
  uint64_t v40;
  const __CFString *format;
  const __CFString *v43;
  char v44;
  uint64_t *v45;
  __CFArray *v48;
  const __CFArray *theArray;
  CFTypeRef v53;
  CFTypeRef v54;
  CFTypeRef v55;
  CFRange v56;
  CFRange v57;

  v53 = 0;
  v54 = 0;
  v55 = 0;
  if (!a1)
  {
    v43 = CFSTR("amfdr is NULL");
LABEL_80:
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMinimalManifestClassesAndInstances", v43, v44);
    v23 = 0;
    v18 = 0;
    v21 = 0;
    v16 = 0;
    Mutable = 0;
LABEL_82:
    v40 = 0;
    goto LABEL_53;
  }
  EntriesForDeviceInternal = AMFDRSealingMapGetEntriesForDeviceInternal(0);
  if (!EntriesForDeviceInternal)
  {
    v43 = CFSTR("Could not get sealing map");
    goto LABEL_80;
  }
  v10 = (const __CFArray *)EntriesForDeviceInternal;
  v45 = a3;
  v11 = CFGetAllocator(a1);
  v12 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  Mutable = CFArrayCreateMutable(v11, 0, MEMORY[0x24BDBD690]);
  v14 = CFGetAllocator(a1);
  v15 = CFArrayCreateMutable(v14, 0, v12);
  v16 = v15;
  if (!Mutable || !v15)
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMinimalManifestClassesAndInstances", CFSTR("failed to allocate data class/instance arrays"), v44);
    v23 = 0;
    v18 = 0;
    v21 = 0;
    goto LABEL_82;
  }
  theArray = v15;
  v17 = CFGetAllocator(a1);
  v18 = CFArrayCreateMutable(v17, 0, &kCFArrayCallBacksAllowNULL);
  v19 = CFGetAllocator(a1);
  v20 = CFArrayCreateMutable(v19, 0, &kCFArrayCallBacksAllowNULL);
  v21 = v20;
  if (!v18 || !v20)
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMinimalManifestClassesAndInstances", CFSTR("failed to allocate minimalSealingData arrays"), v44);
    v23 = 0;
    v40 = 0;
    v16 = theArray;
    goto LABEL_53;
  }
  v48 = Mutable;
  if (CFArrayGetCount(v10) < 1)
  {
    v23 = 0;
LABEL_43:
    v16 = theArray;
    if (CFArrayGetCount(theArray) >= 1)
    {
      Count = CFArrayGetCount(theArray);
      AMFDRSetStat((CFMutableDictionaryRef *)a1, CFSTR("FDRMissingDataInstance"), Count);
      if (a6)
        *a6 = 1;
    }
    Mutable = v48;
    if (a4)
      *a4 = AMSupportSafeRetain();
    if (a5)
      *a5 = AMSupportSafeRetain();
    if (v45)
      *v45 = AMSupportSafeRetain();
    v40 = 1;
    goto LABEL_53;
  }
  v22 = 0;
  v23 = 0;
  v24 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, v22);
    v26 = ValueAtIndex;
    if (!ValueAtIndex || (v27 = CFGetTypeID(ValueAtIndex), v27 != CFDictionaryGetTypeID()))
    {
      AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMinimalManifestClassesAndInstances", CFSTR("Object of unexpected type '%@' in sealing map"), (char)v26);
      goto LABEL_72;
    }
    Value = (const __CFArray *)CFDictionaryGetValue(v26, CFSTR("MinimalSealingManifest"));
    if (!Value)
      goto LABEL_40;
    v29 = Value;
    if (v23)
      CFRelease(v23);
    v30 = _copyIdentifierListForSealingMapEntry(v24, v26, 0, 0, 0, a7);
    if (!v30)
      break;
    v23 = v30;
    v31 = CFGetTypeID(v30);
    if (v31 != CFStringGetTypeID())
    {
      AMFDRErrorPushInternal(a7, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMinimalManifestClassesAndInstances", CFSTR("minimal manifest with multi data class is not supported"), v44);
      goto LABEL_72;
    }
    if (v55)
    {
      CFRelease(v55);
      v55 = 0;
    }
    if (v54)
    {
      CFRelease(v54);
      v54 = 0;
    }
    if (v53)
    {
      CFRelease(v53);
      v53 = 0;
    }
    v32 = CFDictionaryGetValue(v26, CFSTR("Tag"));
    if (!v32 || (v33 = v32, v34 = CFGetTypeID(v32), v34 != CFStringGetTypeID()))
    {
      AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMinimalManifestClassesAndInstances", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
      goto LABEL_72;
    }
    if (!_AMFDRSealingMapCopyDataClassesAndInstancesInternal(a1, v29, 1, 0, a2, 0, 0, 0, 0, &v55, &v54, &v53, 0, 0, a7))
    {
      format = CFSTR("_AMFDRSealingMapCopyDataClassesAndInstancesInternal failed");
LABEL_75:
      AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMinimalManifestClassesAndInstances", format, v44);
      goto LABEL_72;
    }
    if (v53 && CFArrayGetCount((CFArrayRef)v53) >= 1)
    {
      v35 = (const __CFArray *)v53;
      v56.length = CFArrayGetCount((CFArrayRef)v53);
      v56.location = 0;
      CFArrayAppendArray(theArray, v35, v56);
    }
    if (v55 && CFArrayGetCount((CFArrayRef)v55) && v54 && CFArrayGetCount((CFArrayRef)v54))
    {
      v36 = CFArrayGetCount((CFArrayRef)v55);
      if (v36 != CFArrayGetCount((CFArrayRef)v54))
      {
        format = CFSTR("Must have a data instance for each data class to add to miniaml sealing array");
        goto LABEL_75;
      }
      v37 = (const __CFArray *)v54;
      v57.length = CFArrayGetCount((CFArrayRef)v54);
      v57.location = 0;
      CFArrayAppendArray(v48, v37, v57);
      if (CFArrayGetCount((CFArrayRef)v55) >= 1)
      {
        v38 = 0;
        do
        {
          CFArrayAppendValue(v18, v33);
          CFArrayAppendValue(v21, v23);
          ++v38;
        }
        while (v38 < CFArrayGetCount((CFArrayRef)v55));
      }
    }
LABEL_40:
    if (++v22 >= CFArrayGetCount(v10))
      goto LABEL_43;
  }
  if ((AMFDRAllowIncompleteData((uint64_t)a1) & 1) != 0)
  {
    AMSupportLogInternal();
    v23 = 0;
    if (a6)
      *a6 = 1;
    goto LABEL_40;
  }
  AMFDRErrorPushInternal(a7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyMinimalManifestClassesAndInstances", CFSTR("failed to query sealed data instance for minimal manifest and incomplete data is not allowed"), v44);
  v23 = 0;
LABEL_72:
  v40 = 0;
  Mutable = v48;
  v16 = theArray;
LABEL_53:
  if (v55)
  {
    CFRelease(v55);
    v55 = 0;
  }
  if (v54)
  {
    CFRelease(v54);
    v54 = 0;
  }
  if (v53)
  {
    CFRelease(v53);
    v53 = 0;
  }
  if (v18)
    CFRelease(v18);
  if (v21)
    CFRelease(v21);
  if (Mutable)
    CFRelease(Mutable);
  if (v16)
    CFRelease(v16);
  if (v23)
    CFRelease(v23);
  return v40;
}

CFMutableArrayRef AMFDRSealingManifestCopyMinimalManifestClassesAndInstances(void *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5)
{
  const __CFString *v11;
  char v12;

  if ((AMFDRSealingMapPopulateSealingManifest((uint64_t)a1, 0, (uint64_t)a5) & 1) != 0)
  {
    if ((AMFDRSealingMapPopulateMinimalSealingManifest((CFDictionaryRef *)a1, 0, (uint64_t)a5) & 1) != 0)
      return _AMFDRSealingManifestCopyMinimalManifestClassesAndInstances(a1, a2, a3, a4, a5);
    v11 = CFSTR("AMFDRSealingMapPopulateMinimalSealingManifest failed on amfdr");
  }
  else
  {
    v11 = CFSTR("AMFDRSealingMapPopulateSealingManifest failed on amfdr");
  }
  AMFDRErrorPushInternal((uint64_t)a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCopyMinimalManifestClassesAndInstances", v11, v12);
  return 0;
}

CFMutableArrayRef _AMFDRSealingManifestCopyMinimalManifestClassesAndInstances(CFTypeRef cf, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5)
{
  const __CFAllocator *v10;
  CFMutableArrayRef Mutable;
  const __CFAllocator *v12;
  CFMutableArrayRef v13;
  const __CFAllocator *v14;
  CFMutableArrayRef v15;
  CFMutableArrayRef v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  CFTypeID v19;
  uint64_t v20;
  _QWORD context[6];

  context[5] = *MEMORY[0x24BDAC8D0];
  if (!cf || !*((_QWORD *)cf + 2))
  {
    AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyMinimalManifestClassesAndInstances", CFSTR("amfdr/amfdr->optionsDict is NULL"), context[0]);
    return 0;
  }
  v10 = CFGetAllocator(cf);
  Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyMinimalManifestClassesAndInstances", CFSTR("failed to allocate data class/instance arrays"), context[0]);
    return Mutable;
  }
  v12 = CFGetAllocator(cf);
  v13 = CFArrayCreateMutable(v12, 0, &kCFArrayCallBacksAllowNULL);
  v14 = CFGetAllocator(cf);
  v15 = CFArrayCreateMutable(v14, 0, &kCFArrayCallBacksAllowNULL);
  v16 = v15;
  if (v13 && v15)
  {
    v17 = (const __CFDictionary *)_CFDictionaryCopyValue(*((const __CFDictionary **)cf + 2), CFSTR("MinimalSealingManifests"));
    v18 = v17;
    if (v17
      && (v19 = CFGetTypeID(v17), v19 == CFDictionaryGetTypeID())
      && CFDictionaryGetCount(v18) >= 1
      && (context[0] = cf,
          context[1] = Mutable,
          context[2] = v13,
          context[3] = v16,
          context[4] = a5,
          CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)_getMinimalSealingManifestDataInstances, context),
          *a5))
    {
      AMSupportLogInternal();
      v20 = 0;
    }
    else
    {
      if (a3)
        *a3 = AMSupportSafeRetain();
      if (a4)
        *a4 = AMSupportSafeRetain();
      if (a2)
        *a2 = AMSupportSafeRetain();
      v20 = 1;
      if (!v18)
        goto LABEL_18;
    }
    CFRelease(v18);
LABEL_18:
    CFRelease(Mutable);
LABEL_19:
    CFRelease(v13);
    Mutable = (CFMutableArrayRef)v20;
    goto LABEL_20;
  }
  AMFDRErrorPushInternal((uint64_t)a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingManifestCopyMinimalManifestClassesAndInstances", CFSTR("failed to allocate minimalSealingData arrays"), context[0]);
  CFRelease(Mutable);
  v20 = 0;
  Mutable = 0;
  if (v13)
    goto LABEL_19;
LABEL_20:
  if (v16)
    CFRelease(v16);
  return Mutable;
}

_QWORD *AMFDRSealingManifestCreateSealedData(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  _QWORD *v7;
  CFTypeRef v8;
  const void *v9;
  CFTypeRef v10;
  const void *v11;
  CFTypeRef v12;
  const __CFString *v14;
  char v15;
  CFTypeRef cf;
  CFTypeRef v17;
  CFTypeRef v18;
  CFTypeRef v19;
  CFTypeRef v20;
  CFTypeRef v21;
  CFTypeRef v22;
  uint64_t v23;
  uint64_t v24;

  v23 = 0;
  v24 = 0;
  v21 = 0;
  v22 = 0;
  v19 = 0;
  v20 = 0;
  v17 = 0;
  v18 = 0;
  cf = 0;
  if (!a1
    || !AMFDRSealingMapPopulateSealingManifest(a1, 0, (uint64_t)&v24)
    || !_AMFDRSealingManifestTrustEvaluation(a1, (uint64_t)&v24)
    || !AMFDRSealingMapPopulateMinimalSealingManifest((CFDictionaryRef *)a1, 0, (uint64_t)&v24)
    || !AMFDRSealingManifestVerifyMinimalManifest((const __CFDictionary **)a1, &v24)
    || !_AMFDRSealingManifestCopyDataClassesAndInstances(a1, 0, 0, 0, &v23, &v22, &v21, &v20, (uint64_t *)&v19, (uint64_t *)&v18, (uint64_t *)&v17, &cf, &v24))
  {
    AMSupportLogInternal();
    if (!AMFDRSealingMapPopulateSealingManifest(a2, 0, (uint64_t)a3))
    {
      v7 = 0;
      v14 = CFSTR("AMFDRSealingMapPopulateSealingManifest failed on amfdrRemote");
      goto LABEL_36;
    }
    if (!_AMFDRSealingManifestCopyDataClassesAndInstances(a2, 0, 0, 0, &v23, &v22, &v21, &v20, (uint64_t *)&v19, (uint64_t *)&v18, (uint64_t *)&v17, &cf, a3))
    {
      v7 = 0;
      v14 = CFSTR("_AMFDRSealingManifestCopyDataClassesAndInstances failed");
      goto LABEL_36;
    }
  }
  AMFDRSealedDataCreate();
  v7 = (_QWORD *)v6;
  if (!v6)
  {
    v14 = CFSTR("Failed to create sealedData.");
    goto LABEL_36;
  }
  if (AMFDRSealedDataPopulatedFromManifest(v6, 1, (uint64_t)a3))
  {
    v8 = cf;
    if (!cf)
    {
LABEL_28:
      if ((AMFDRSealedDataSetMinimalManifestClassInstance(v7, v19, v18, v17, (uint64_t)a3) & 1) != 0)
        goto LABEL_29;
      v14 = CFSTR("AMFDRSealedDataSetMinimalManifestClassInstance failed");
LABEL_36:
      AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingManifestCreateSealedData", v14, v15);
      goto LABEL_29;
    }
    if (a1)
    {
      if (*(_QWORD *)(a1 + 120))
      {
        CFRelease(*(CFTypeRef *)(a1 + 120));
        v8 = cf;
        *(_QWORD *)(a1 + 120) = cf;
        if (!v8)
          goto LABEL_19;
      }
      else
      {
        *(_QWORD *)(a1 + 120) = cf;
      }
      CFRetain(v8);
    }
LABEL_19:
    if (a2)
    {
      v9 = *(const void **)(a2 + 120);
      if (v9)
        CFRelease(v9);
      v10 = cf;
      *(_QWORD *)(a2 + 120) = cf;
      if (v10)
        CFRetain(v10);
    }
    v11 = (const void *)v7[16];
    if (v11)
      CFRelease(v11);
    v12 = cf;
    v7[16] = cf;
    if (v12)
      CFRetain(v12);
    goto LABEL_28;
  }
LABEL_29:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v7;
}

uint64_t AMFDRSealingMapGetLocalStoreMaxSizeInternal(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  const __CFDictionary *FDRSealingMapFromCache;
  const __CFDictionary *v6;
  CFTypeID v7;
  const __CFDictionary *Value;
  const __CFDictionary *v9;
  CFTypeID v10;
  const void *v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  CFTypeID v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  CFTypeID v17;
  CFTypeID v18;
  uint64_t v19;
  const __CFString *v21;
  char v22;
  uint64_t valuePtr;

  valuePtr = 0;
  if (a1 && (*(_BYTE *)(*(_QWORD *)(a1 + 136) + 8) & 8) != 0)
  {
    v19 = 0;
    goto LABEL_20;
  }
  v3 = copyProductType(a1);
  v4 = (const void *)v3;
  if (!v3)
  {
    v21 = CFSTR("Failed to query product type");
    goto LABEL_26;
  }
  FDRSealingMapFromCache = (const __CFDictionary *)_getFDRSealingMapFromCache(v3);
  if (!FDRSealingMapFromCache)
    goto LABEL_21;
  v6 = FDRSealingMapFromCache;
  v7 = CFGetTypeID(FDRSealingMapFromCache);
  if (v7 != CFDictionaryGetTypeID())
    goto LABEL_21;
  Value = (const __CFDictionary *)CFDictionaryGetValue(v6, CFSTR("StoreMaxSize"));
  if (Value && (v9 = Value, v10 = CFGetTypeID(Value), v10 == CFDictionaryGetTypeID()))
  {
    v11 = CFDictionaryGetValue(v9, v4);
    if (v11)
      goto LABEL_16;
  }
  else
  {
    AMSupportLogInternal();
  }
  v12 = (const __CFDictionary *)_getFDRSealingMapFromCache((uint64_t)CFSTR("iRefDefault"));
  if (!v12 || (v13 = v12, v14 = CFGetTypeID(v12), v14 != CFDictionaryGetTypeID()))
  {
LABEL_21:
    v21 = CFSTR("Failed to load sealing map");
LABEL_26:
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapGetLocalStoreMaxSizeInternal", v21, v22);
    goto LABEL_27;
  }
  v15 = (const __CFDictionary *)CFDictionaryGetValue(v13, CFSTR("StoreMaxSize"));
  if (!v15 || (v16 = v15, v17 = CFGetTypeID(v15), v17 != CFDictionaryGetTypeID()))
  {
    v21 = CFSTR("Failed to find store max size map");
    goto LABEL_26;
  }
  v11 = CFDictionaryGetValue(v16, CFSTR("iRefDefault"));
  if (!v11)
  {
LABEL_22:
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapGetLocalStoreMaxSizeInternal", CFSTR("Failed to find store max size for '%@'"), (char)v4);
LABEL_27:
    v19 = 0;
    goto LABEL_20;
  }
LABEL_16:
  v18 = CFGetTypeID(v11);
  if (v18 != CFNumberGetTypeID())
    goto LABEL_22;
  if (!CFNumberGetValue((CFNumberRef)v11, kCFNumberLongType, &valuePtr))
  {
    v21 = CFSTR("Failed to decode maxSizeNumber");
    goto LABEL_26;
  }
  v19 = valuePtr;
LABEL_20:
  AMSupportSafeRelease();
  return v19;
}

uint64_t _getFDRSealingMapFromCache(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v1 = gSealingMap;
  if (!gSealingMap)
  {
    v1 = fileSystemSealingMap;
    if (!fileSystemSealingMap)
    {
      if (a1)
      {
        if (sealingMapCacheQueue_onceToken != -1)
        {
          v3 = a1;
          dispatch_once(&sealingMapCacheQueue_onceToken, &__block_literal_global_860);
          a1 = v3;
        }
        v4[0] = MEMORY[0x24BDAC760];
        v4[1] = 0x40000000;
        v4[2] = ___getFDRSealingMapFromCache_block_invoke;
        v4[3] = &unk_24C69F2A0;
        v4[4] = &v5;
        v4[5] = a1;
        dispatch_sync((dispatch_queue_t)sealingMapCacheQueue_sealingMapCacheQueue, v4);
        v1 = v6[3];
      }
      else
      {
        v1 = AMFDRGetSealingMap();
      }
    }
  }
  _Block_object_dispose(&v5, 8);
  return v1;
}

uint64_t AMFDRSealingMapGetLocalStoreMaxSize(uint64_t a1)
{
  return AMFDRSealingMapGetLocalStoreMaxSizeInternal(0, a1);
}

uint64_t AMFDRSealingMapCheckSubCCIntegrity(__CFString *a1, const __CFString *a2, const __CFString *cf, uint64_t a4)
{
  const __CFString *v5;
  uint64_t v8;
  const __CFString *format;
  char v11;
  const __CFDictionary *v12;

  v12 = 0;
  if (!a2)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCheckSubCCIntegrity", CFSTR("dataClass is NULL"), v11);
    return 0;
  }
  v5 = cf;
  if (cf)
  {
    CFRetain(cf);
    goto LABEL_5;
  }
  v5 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(a2, a4, 0, 0);
  if (v5)
  {
LABEL_5:
    if ((AMFDRSealingMapCopySubCCDataClasses(a1, CFSTR("RequiredToSeal"), (CFTypeRef *)&v12, a4) & 1) != 0)
    {
      if ((_AMFDRSealingMapCheckSubCCIntegrityInternal(a1, a2, v5, v12, a4) & 1) != 0)
      {
        v8 = 1;
LABEL_8:
        CFRelease(v5);
        goto LABEL_9;
      }
      v11 = (char)a2;
      format = CFSTR("Cannot verify subCC integrity for %@-%@");
    }
    else
    {
      format = CFSTR("Failed to copy subcc list");
    }
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCheckSubCCIntegrity", format, v11);
    v8 = 0;
    goto LABEL_8;
  }
  AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCheckSubCCIntegrity", CFSTR("cannot copy data instance for %@"), (char)a2);
  v8 = 0;
LABEL_9:
  if (v12)
    CFRelease(v12);
  return v8;
}

uint64_t _AMFDRSealingMapCheckSubCCIntegrityInternal(__CFString *a1, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4, uint64_t a5)
{
  CFStringRef FullKey;
  __CFString *v11;
  const __CFString *PermissionsString;
  const __CFData *v13;
  const __CFData *v14;
  CFArrayRef *v15;
  const __CFArray *Value;
  const __CFArray *v17;
  CFTypeID v18;
  const __CFAllocator *v19;
  __CFArray *Mutable;
  char v21;
  CFIndex v22;
  const __CFArray *v23;
  CFIndex Count;
  const void *v25;
  const void *ValueAtIndex;
  uint64_t v27;
  const __CFString *v29;
  char v30;
  uint64_t v31;
  CFRange v32;

  if (!a2)
  {
    v29 = CFSTR("dataClass is NULL");
LABEL_30:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCheckSubCCIntegrityInternal", v29, v30);
    return 0;
  }
  if (!a3)
  {
    v29 = CFSTR("dataInstance is NULL");
    goto LABEL_30;
  }
  FullKey = AMFDRDataLocalCreateFullKey((const __CFAllocator *)*MEMORY[0x24BDBD240], (uint64_t)a2, (uint64_t)a3);
  if (!FullKey)
  {
    v29 = CFSTR("dataClassInstance is NULL");
    goto LABEL_30;
  }
  v11 = (__CFString *)FullKey;
  PermissionsString = AMFDRDataCreatePermissionsString(a1, 0, a2, a3);
  if (PermissionsString)
  {
    AMFDRSetOption((uint64_t)a1, CFSTR("Permissions"), PermissionsString);
    v13 = AMFDRDataCopy((uint64_t)a1, a2, a3, a5);
    if (v13)
    {
      v14 = v13;
      v15 = (CFArrayRef *)AMFDRDataDictCreateFromData((uint64_t)a1, v13, 0, 0);
      if (v15)
      {
        Value = (const __CFArray *)CFDictionaryGetValue(a4, v11);
        if (!Value)
        {
          AMSupportLogInternal();
          Mutable = 0;
          goto LABEL_19;
        }
        v17 = Value;
        v18 = CFGetTypeID(Value);
        if (v18 == CFArrayGetTypeID())
        {
          v19 = CFGetAllocator(a1);
          Mutable = CFArrayCreateMutable(v19, 0, MEMORY[0x24BDBD690]);
          if (Mutable)
          {
            v31 = a5;
            if (CFArrayGetCount(v17) < 1)
              goto LABEL_17;
            v21 = 0;
            v22 = 0;
            do
            {
              v23 = v15[4];
              if (!v23
                || (Count = CFArrayGetCount(v15[4]),
                    v25 = CFArrayGetValueAtIndex(v17, v22),
                    v32.location = 0,
                    v32.length = Count,
                    !CFArrayContainsValue(v23, v32, v25)))
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v17, v22);
                CFArrayAppendValue(Mutable, ValueAtIndex);
                v21 = 1;
              }
              ++v22;
            }
            while (v22 < CFArrayGetCount(v17));
            if ((v21 & 1) == 0)
            {
LABEL_17:
              AMSupportLogInternal();
LABEL_19:
              v27 = 1;
              goto LABEL_20;
            }
            AMFDRErrorPushInternal(v31, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCheckSubCCIntegrityInternal", CFSTR("Missing SubCC for %@: required subCC: %@, existing subCC: %@, missing subCC: %@"), (char)v11);
          }
          else
          {
            AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCheckSubCCIntegrityInternal", CFSTR("Could not create missingSubCCArray"), v30);
          }
          v27 = 0;
LABEL_20:
          CFRelease(v14);
          CFRelease(v11);
          if (Mutable)
            CFRelease(Mutable);
          if (!v15)
            goto LABEL_24;
          goto LABEL_23;
        }
        AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCheckSubCCIntegrityInternal", CFSTR("unexpected subcclist array type"), v30);
      }
      else
      {
        AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCheckSubCCIntegrityInternal", CFSTR("decoded of %@ is NULL"), (char)a2);
      }
      v27 = 0;
      Mutable = 0;
      goto LABEL_20;
    }
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCheckSubCCIntegrityInternal", CFSTR("valueData is NULL"), v30);
  }
  else
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCheckSubCCIntegrityInternal", CFSTR("permStr is NULL"), v30);
  }
  v27 = 0;
  v15 = (CFArrayRef *)v11;
LABEL_23:
  CFRelease(v15);
LABEL_24:
  if (PermissionsString)
    CFRelease(PermissionsString);
  return v27;
}

uint64_t AMFDRSealingMapCheckSubCCIntegrityForClass(__CFString *a1, const __CFString *a2, uint64_t a3)
{
  return AMFDRSealingMapCheckSubCCIntegrity(a1, a2, 0, a3);
}

uint64_t AMFDRSealingMapCheckMultiSubCCIntegrityForClass(__CFString *a1, const __CFString *a2, uint64_t a3)
{
  const __CFArray *v6;
  const __CFArray *v7;
  CFTypeID v8;
  CFIndex v9;
  const __CFString *ValueAtIndex;
  uint64_t v11;
  char v13;
  CFTypeRef cf;

  cf = 0;
  v6 = (const __CFArray *)AMFDRSealingMapCopyMultiInstanceForClass(a2, a3);
  if (!v6)
  {
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCheckMultiSubCCIntegrityForClass", CFSTR("Could not copy data instance for %@"), (char)a2);
    return 0;
  }
  v7 = v6;
  v8 = CFGetTypeID(v6);
  if (v8 == CFArrayGetTypeID() && CFArrayGetCount(v7) > 0)
  {
    if (AMFDRSealingMapCopySubCCDataClasses(a1, CFSTR("RequiredToSeal"), &cf, a3))
    {
      if (CFArrayGetCount(v7) >= 1)
      {
        v9 = 0;
        do
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v9);
          AMSupportLogInternal();
          v11 = _AMFDRSealingMapCheckSubCCIntegrityInternal(a1, a2, ValueAtIndex, (const __CFDictionary *)cf, a3);
          if ((v11 & 1) == 0)
            AMSupportLogInternal();
          ++v9;
        }
        while (v9 < CFArrayGetCount(v7));
        goto LABEL_15;
      }
    }
    else
    {
      AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCheckMultiSubCCIntegrityForClass", CFSTR("Failed to copy subcc list"), v13);
    }
  }
  else
  {
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCheckMultiSubCCIntegrityForClass", CFSTR("Could not copy data instance array for %@, array count is zero"), (char)a2);
  }
  v11 = 0;
LABEL_15:
  CFRelease(v7);
  if (cf)
    CFRelease(cf);
  return v11;
}

uint64_t AMFDRSealingMapUpdateAsidMetadataWithPrimaryModule(const __CFDictionary *cf, const __CFString *a2, const __CFString *a3, CFTypeRef *a4)
{
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  const __CFAllocator *v11;
  _QWORD *v12;
  const void *v13;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v15;
  CFTypeID v16;
  CFMutableStringRef v17;
  __CFString *v18;
  uint64_t v19;
  const __CFString *v21;
  const __CFString *v22;
  char v23;
  CFTypeRef cfa;
  CFTypeRef v25;
  CFTypeRef v26;
  CFTypeRef v27;

  v26 = 0;
  v27 = 0;
  cfa = 0;
  v25 = 0;
  if (cf && (v8 = CFGetTypeID(cf), v8 == CFDictionaryGetTypeID()))
  {
    if (a2 && (v9 = CFGetTypeID(a2), v9 == CFStringGetTypeID()))
    {
      if (a3 && (v10 = CFGetTypeID(a3), v10 != CFStringGetTypeID()))
      {
        AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapUpdateAsidMetadataWithPrimaryModule", CFSTR("primaryDataInstance has wrong type %@"), (char)a3);
      }
      else
      {
        AMSupportLogInternal();
        v11 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
        v12 = AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Remote"), cf);
        if (v12)
        {
          v13 = v12;
          if ((AMFDRDataApTicketPopulate((uint64_t)v12) & 1) != 0)
          {
            Mutable = CFDictionaryCreateMutable(v11, 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
            v15 = Mutable;
            if (!Mutable || (v16 = CFGetTypeID(Mutable), v16 != CFDictionaryGetTypeID()))
            {
              v21 = CFSTR("queryCache allocation failed");
LABEL_35:
              AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapUpdateAsidMetadataWithPrimaryModule", v21, v23);
              goto LABEL_36;
            }
            if ((_AMFDRSealingMapCopyAsidMetadataParameters(a2, a3, v15, &v27, &v26, &v25, &cfa, a4) & 1) != 0)
            {
              v17 = CFStringCreateMutable(v11, 0);
              if (v17)
              {
                v18 = v17;
                AMFDRSetOption((uint64_t)v13, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD268]);
                if (AMFDRDataAppendPermissionUpdateAsidMetadata((const __CFArray *)v27, (const __CFArray *)v26, (uint64_t)v13, v18, (uint64_t)a4))
                {
                  if ((AMFDRDataUpdateAsidMetadata(v27, v26, v25, cfa, (uint64_t)v13, v18, (uint64_t)a4) & 1) != 0)
                  {
                    v19 = 1;
LABEL_16:
                    CFRelease(v13);
                    CFRelease(v18);
                    goto LABEL_17;
                  }
                  v22 = CFSTR("AMFDRDataUpdateAsidMetadata failed");
                }
                else
                {
                  v22 = CFSTR("AMFDRDataAppendPermissionUpdateAsidMetadata failed");
                }
                AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapUpdateAsidMetadataWithPrimaryModule", v22, v23);
                v19 = 0;
                goto LABEL_16;
              }
              v21 = CFSTR("updateAsidMetadataPermissions allocation failed");
              goto LABEL_35;
            }
            AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapUpdateAsidMetadataWithPrimaryModule", CFSTR("_AMFDRSealingMapCopyAsidMetadataParameters failed"), v23);
          }
          else
          {
            AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapUpdateAsidMetadataWithPrimaryModule", CFSTR("Unable to populate apTicket for amfdrRemote"), v23);
            v15 = 0;
          }
LABEL_36:
          CFRelease(v13);
          v19 = 0;
          goto LABEL_17;
        }
        AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapUpdateAsidMetadataWithPrimaryModule", CFSTR("Unable to create amfdrRemote"), v23);
      }
    }
    else
    {
      AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapUpdateAsidMetadataWithPrimaryModule", CFSTR("primaryDataClass has wrong type %@"), (char)a2);
    }
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapUpdateAsidMetadataWithPrimaryModule", CFSTR("optionsDict has wrong type %@"), (char)cf);
  }
  v19 = 0;
  v15 = 0;
LABEL_17:
  if (v27)
  {
    CFRelease(v27);
    v27 = 0;
  }
  if (v26)
  {
    CFRelease(v26);
    v26 = 0;
  }
  if (cfa)
  {
    CFRelease(cfa);
    cfa = 0;
  }
  if (v25)
  {
    CFRelease(v25);
    v25 = 0;
  }
  if (v15)
    CFRelease(v15);
  return v19;
}

uint64_t _AMFDRSealingMapCopyAsidMetadataParameters(const __CFString *a1, const __CFString *a2, const void *a3, CFTypeRef *a4, CFTypeRef *a5, CFTypeRef *a6, CFTypeRef *a7, CFTypeRef *a8)
{
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t (*v19)(_QWORD *, _QWORD);
  const void *v20;
  const void *v21;
  CFTypeID v22;
  const void *RepairConfigurationEntries;
  const void *v24;
  CFTypeID v25;
  __CFDictionary *RepairConfigurationAsidMetadataInternalBlob;
  CFTypeRef RepairConfigurationAsidMetadata;
  const void *v28;
  CFTypeID v29;
  uint64_t v30;
  const void *v31;
  const __CFString *format;
  char v34;
  CFTypeRef *v35;
  CFTypeRef *v36;

  v16 = AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Local"), 0);
  if (!v16)
  {
    AMFDRErrorPushInternal((uint64_t)a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataParameters", CFSTR("Unable to create amfdrLocal"), v34);
    return 0;
  }
  v17 = v16;
  if ((AMFDRDataApTicketPopulate((uint64_t)v16) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataParameters", CFSTR("Unable to populate apTicket for amfdrLocal"), v34);
    v31 = v17;
    goto LABEL_20;
  }
  v18 = (_QWORD *)v17[17];
  if (*v18 < 0x21uLL || (v19 = (uint64_t (*)(_QWORD *, _QWORD))v18[4]) == 0)
  {
    v21 = 0;
    goto LABEL_18;
  }
  v35 = a6;
  v36 = a7;
  v20 = (const void *)v19(v17, v17[18]);
  v21 = v20;
  if (!v20 || (v22 = CFGetTypeID(v20), v22 != CFStringGetTypeID()))
  {
LABEL_18:
    AMFDRErrorPushInternal((uint64_t)a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataParameters", CFSTR("currentDevice has wrong type '%@'"), (char)v21);
    CFRelease(v17);
    if (!v21)
      return 0;
    goto LABEL_19;
  }
  RepairConfigurationEntries = _AMFDRSealingMapGetRepairConfigurationEntries(v21);
  if (!RepairConfigurationEntries
    || (v24 = RepairConfigurationEntries, v25 = CFGetTypeID(RepairConfigurationEntries), v25 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataParameters", CFSTR("_AMFDRSealingMapGetRepairConfigurationEntries failed"), v34);
    CFRelease(v17);
LABEL_19:
    v31 = v21;
LABEL_20:
    CFRelease(v31);
    return 0;
  }
  RepairConfigurationAsidMetadataInternalBlob = AMFDRSealingMapCreateRepairConfigurationAsidMetadataInternalBlob(a1, a2, v24, 0, a3, a8);
  RepairConfigurationAsidMetadata = AMFDRDataCreateRepairConfigurationAsidMetadata(RepairConfigurationAsidMetadataInternalBlob, 0, 0, (uint64_t)a8);
  if (RepairConfigurationAsidMetadata)
  {
    v28 = RepairConfigurationAsidMetadata;
    v29 = CFGetTypeID(RepairConfigurationAsidMetadata);
    if (v29 == CFDictionaryGetTypeID())
    {
      AMSupportLogInternal();
      if (CFDictionaryGetCount((CFDictionaryRef)v28) < 1)
      {
        format = CFSTR("incomplete asidMetadata");
      }
      else
      {
        if (AMFDRDataCopyAsidMetadataParameters(v28, a4, a5, v35, v36, (uint64_t)a8))
        {
          v30 = 1;
LABEL_14:
          CFRelease(v28);
          goto LABEL_15;
        }
        format = CFSTR("AMFDRDataCopyAsidMetadataParameters failed");
      }
    }
    else
    {
      format = CFSTR("AMFDRDataCreateRepairConfigurationAsidMetadata failed");
    }
    AMFDRErrorPushInternal((uint64_t)a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataParameters", format, v34);
    v30 = 0;
    goto LABEL_14;
  }
  AMFDRErrorPushInternal((uint64_t)a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataParameters", CFSTR("AMFDRDataCreateRepairConfigurationAsidMetadata failed"), v34);
  v30 = 0;
LABEL_15:
  CFRelease(v17);
  CFRelease(v21);
  if (RepairConfigurationAsidMetadataInternalBlob)
    CFRelease(RepairConfigurationAsidMetadataInternalBlob);
  return v30;
}

uint64_t AMFDRSealingMapCopyAsidMetadataDataClassesAndInstancesWithPrimaryModule(const __CFString *cf, const __CFString *a2, CFTypeRef *a3, CFTypeRef *a4, CFTypeRef *a5)
{
  CFTypeID v10;
  CFTypeID v11;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v13;
  CFTypeID v14;
  uint64_t v15;
  const __CFString *v17;
  char v18;

  if (!cf || (v10 = CFGetTypeID(cf), v10 != CFStringGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyAsidMetadataDataClassesAndInstancesWithPrimaryModule", CFSTR("primaryDataClass has wrong type %@"), (char)cf);
    return 0;
  }
  if (a2)
  {
    v11 = CFGetTypeID(a2);
    if (v11 != CFStringGetTypeID())
    {
      v18 = (char)a2;
      v17 = CFSTR("primaryDataInstance has wrong type %@");
      goto LABEL_21;
    }
  }
  AMSupportLogInternal();
  if (!a3)
  {
    v17 = CFSTR("outDataClasses is NULL");
LABEL_21:
    AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyAsidMetadataDataClassesAndInstancesWithPrimaryModule", v17, v18);
    return 0;
  }
  if (!a4)
  {
    v17 = CFSTR("outDataInstances is NULL");
    goto LABEL_21;
  }
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyAsidMetadataDataClassesAndInstancesWithPrimaryModule", CFSTR("queryCache allocation failed"), v18);
    return 0;
  }
  v13 = Mutable;
  v14 = CFGetTypeID(Mutable);
  if (v14 != CFDictionaryGetTypeID())
  {
    AMFDRErrorPushInternal((uint64_t)a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyAsidMetadataDataClassesAndInstancesWithPrimaryModule", CFSTR("queryCache allocation failed"), v18);
LABEL_19:
    v15 = 0;
    goto LABEL_11;
  }
  if ((_AMFDRSealingMapCopyAsidMetadataParameters(cf, a2, v13, a3, a4, 0, 0, a5) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyAsidMetadataDataClassesAndInstancesWithPrimaryModule", CFSTR("AMFDRSealingMapCopyAsidMetadataData failed"), v18);
    goto LABEL_19;
  }
  v15 = 1;
LABEL_11:
  CFRelease(v13);
  return v15;
}

uint64_t AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule(CFTypeRef cf, const __CFString *a2, const __CFString *a3, CFTypeRef *a4)
{
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  const __CFAllocator *v11;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v13;
  CFTypeID v14;
  CFTypeID v15;
  CFTypeID v16;
  __CFString *v17;
  __CFString *v18;
  CFMutableStringRef v19;
  CFIndex Count;
  CFIndex v21;
  CFIndex v22;
  const __CFString *ValueAtIndex;
  const __CFString *v24;
  const __CFString *v25;
  CFTypeRef v26;
  uint64_t v27;
  uint64_t v29;
  CFIndex v30;
  char v31;
  const __CFString *v32;
  char v33;
  const __CFString *v34;
  void *value[2];
  void *v36[2];
  __int128 v37;
  const __CFString *v38;
  char v39;
  char v40;
  CFTypeRef v41;
  CFTypeRef cfa;
  char v43;

  v43 = 1;
  v41 = 0;
  cfa = 0;
  if (!cf || (v8 = CFGetTypeID(cf), v8 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", CFSTR("optionsDict has wrong type %@"), (char)cf);
LABEL_64:
    v27 = 0;
    v26 = 0;
    v13 = 0;
    goto LABEL_65;
  }
  if (!a2 || (v9 = CFGetTypeID(a2), v9 != CFStringGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", CFSTR("primaryDataClass has wrong type %@"), (char)a2);
    goto LABEL_64;
  }
  if (a3)
  {
    v10 = CFGetTypeID(a3);
    if (v10 != CFStringGetTypeID())
    {
      AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", CFSTR("primaryDataInstance has wrong type %@"), (char)a3);
      goto LABEL_64;
    }
  }
  v11 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  v13 = Mutable;
  if (!Mutable || (v14 = CFGetTypeID(Mutable), v14 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", CFSTR("queryCache allocation failed"), v39);
LABEL_58:
    v27 = 0;
    v26 = 0;
LABEL_65:
    v18 = 0;
    goto LABEL_66;
  }
  if ((_AMFDRSealingMapCopyAsidMetadataParameters(a2, a3, v13, &cfa, &v41, 0, 0, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", CFSTR("_AMFDRSealingMapCopyAsidMetadataParameters failed"), v39);
    goto LABEL_58;
  }
  if (!cfa)
  {
    v31 = 0;
LABEL_53:
    v40 = v31;
    v32 = CFSTR("onDeviceDataClasses has wrong type %@");
LABEL_57:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", v32, v40);
    goto LABEL_58;
  }
  v15 = CFGetTypeID(cfa);
  if (v15 != CFArrayGetTypeID())
  {
    v31 = (char)cfa;
    goto LABEL_53;
  }
  if (!v41)
  {
    v33 = 0;
LABEL_56:
    v40 = v33;
    v32 = CFSTR("onDeviceDataInstances has wrong type %@");
    goto LABEL_57;
  }
  v16 = CFGetTypeID(v41);
  if (v16 != CFArrayGetTypeID())
  {
    v33 = (char)v41;
    goto LABEL_56;
  }
  v17 = (__CFString *)AMFDRCreateTypeWithOptions(v11, CFSTR("Remote"), (const __CFDictionary *)cf);
  v18 = v17;
  if (!v17)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", CFSTR("Unable to create amfdrRemote"), v39);
    v27 = 0;
    v26 = 0;
LABEL_66:
    v19 = 0;
    goto LABEL_29;
  }
  AMFDRSetOption((uint64_t)v17, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD268]);
  v19 = CFStringCreateMutable(v11, 0);
  if (v19)
  {
    Count = CFArrayGetCount((CFArrayRef)cfa);
    if (Count >= 1)
    {
      v21 = Count;
      v22 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cfa, v22);
        if (!ValueAtIndex)
        {
          v38 = CFSTR("dataClassStr is NULL");
          *(_OWORD *)v36 = 0u;
          v37 = 0u;
          *(_OWORD *)value = 0u;
          v29 = (uint64_t)a4;
          v30 = 1;
          goto LABEL_45;
        }
        v24 = ValueAtIndex;
        v25 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v41, v22);
        if (!v25)
        {
          AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", CFSTR("dataInstanceStr is NULL"), v39);
          goto LABEL_46;
        }
        if ((AMFDRDataAppendPermissionsString(v18, 7u, v24, v25, v19) & 1) == 0)
          break;
        if (v21 == ++v22)
          goto LABEL_22;
      }
      v38 = CFSTR("AMFDRDataAppendPermissionsString failed");
      *(_OWORD *)v36 = 0u;
      v37 = 0u;
      *(_OWORD *)value = 0u;
      v29 = (uint64_t)a4;
      v30 = 10;
      goto LABEL_45;
    }
LABEL_22:
    AMFDRSetOption((uint64_t)v18, CFSTR("Permissions"), v19);
    v26 = AMFDRDataMultiCopyAsidMetadata(v18, (uint64_t)cfa, (uint64_t)v41, a4);
    if (v26)
    {
      if ((_AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule(a2, a3, v26, v13, &v43, a4) & 1) != 0)
      {
        if (a3)
        {
          if (!v43)
          {
            AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", CFSTR("Primary module '%@:%@' verification failed"), (char)a2);
LABEL_69:
            v27 = 0;
            goto LABEL_29;
          }
LABEL_28:
          v27 = 1;
          goto LABEL_29;
        }
        if (v43)
          goto LABEL_28;
        v39 = (char)a2;
        v34 = CFSTR("Primary module '%@' verification failed");
      }
      else
      {
        v34 = CFSTR("_AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule failed");
      }
    }
    else
    {
      v34 = CFSTR("AMFDRDataMultiCopyAsidMetadata failed");
    }
    AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", v34, v39);
    goto LABEL_69;
  }
  v38 = CFSTR("permissions is NULL");
  *(_OWORD *)v36 = 0u;
  v37 = 0u;
  *(_OWORD *)value = 0u;
  v29 = (uint64_t)a4;
  v30 = 2;
LABEL_45:
  AMFDRErrorPushInternal(v29, v30, 0, 0, 0, 0, 0, 0, value[0], value[1], v36[0], v36[1], (void *)v37, *((void **)&v37 + 1), (uint64_t)"AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", v38, v39);
LABEL_46:
  v27 = 0;
  v26 = 0;
LABEL_29:
  if (cfa)
  {
    CFRelease(cfa);
    cfa = 0;
  }
  if (v41)
  {
    CFRelease(v41);
    v41 = 0;
  }
  if (v26)
    CFRelease(v26);
  if (v13)
    CFRelease(v13);
  if (v18)
    CFRelease(v18);
  if (v19)
    CFRelease(v19);
  return v27;
}

uint64_t _AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule(const __CFString *cf, const __CFString *a2, const void *a3, const void *a4, _BYTE *a5, CFTypeRef *a6)
{
  CFTypeID v11;
  CFTypeID v12;
  const __CFArray *v13;
  CFTypeRef v14;
  CFTypeRef v15;
  CFTypeID v16;
  CFTypeID v17;
  CFTypeID v18;
  CFTypeID v19;
  CFIndex Count;
  CFIndex v21;
  CFIndex v22;
  CFStringRef v23;
  const __CFAllocator *v24;
  const void *ValueAtIndex;
  const void *v26;
  const __CFDictionary *v27;
  const __CFString *Value;
  CFStringRef v29;
  const __CFString *v30;
  const __CFString *v31;
  CFTypeID v32;
  uint64_t v33;
  const __CFString *v35;
  const __CFString *format;
  char v37;
  char v38;
  uint64_t v39;
  const __CFArray *theArray;
  CFTypeRef v42;
  CFTypeRef v43;
  const __CFArray *v44;

  v43 = 0;
  v44 = 0;
  v42 = 0;
  if (!cf || (v11 = CFGetTypeID(cf), v11 != CFStringGetTypeID()))
  {
    v38 = (char)cf;
    v35 = CFSTR("primaryDataClass has wrong type %@");
LABEL_48:
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", v35, v38);
    goto LABEL_45;
  }
  if (a2)
  {
    v12 = CFGetTypeID(a2);
    if (v12 != CFStringGetTypeID())
    {
      v38 = (char)a2;
      v35 = CFSTR("primaryDataInstance has wrong type %@");
      goto LABEL_48;
    }
  }
  if ((_AMFDRSealingMapCopyAsidMetadataParameters(cf, a2, a4, (CFTypeRef *)&v44, &v43, &v42, 0, a6) & 1) == 0)
  {
    format = CFSTR("_AMFDRSealingMapCopyAsidMetadataParameters failed");
    goto LABEL_44;
  }
  v13 = v44;
  if (!v44 || (v14 = v42, v15 = v43, v16 = CFGetTypeID(v44), v16 != CFArrayGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapVerifyAsidMetadata", CFSTR("onDeviceDataClasses has wrong type %@"), (char)v13);
LABEL_43:
    format = CFSTR("_AMFDRSealingMapVerifyAsidMetadata failed");
LABEL_44:
    AMFDRErrorPushInternal((uint64_t)a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule", format, v37);
LABEL_45:
    v33 = 0;
    goto LABEL_30;
  }
  if (!v15 || (v17 = CFGetTypeID(v15), v17 != CFArrayGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapVerifyAsidMetadata", CFSTR("onDeviceDataInstances has wrong type %@"), (char)v15);
    goto LABEL_43;
  }
  if (!v14 || (v18 = CFGetTypeID(v14), v18 != CFArrayGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapVerifyAsidMetadata", CFSTR("onDeviceMetadataArray has wrong type %@"), (char)v14);
    goto LABEL_43;
  }
  if (!a3 || (v19 = CFGetTypeID(a3), v19 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapVerifyAsidMetadata", CFSTR("onServerAsidMetaDataDict has wrong type %@"), (char)a3);
    goto LABEL_43;
  }
  Count = CFArrayGetCount(v13);
  if (Count >= 1)
  {
    v21 = Count;
    theArray = (const __CFArray *)v14;
    v39 = (uint64_t)a6;
    v22 = 0;
    v23 = 0;
    v24 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v13, v22);
      v26 = CFArrayGetValueAtIndex((CFArrayRef)v15, v22);
      v27 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v22);
      Value = (const __CFString *)CFDictionaryGetValue(v27, CFSTR("asid"));
      if (v23)
        CFRelease(v23);
      v29 = CFStringCreateWithFormat(v24, 0, CFSTR("%@-%@"), ValueAtIndex, v26);
      if (!v29)
        break;
      v23 = v29;
      v30 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a3, v29);
      if (v30 && (v31 = v30, v32 = CFGetTypeID(v30), v32 == CFStringGetTypeID()))
      {
        if (CFStringCompare(Value, v31, 0))
        {
          *a5 = 0;
          AMFDRErrorPushInternal(v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapVerifyAsidMetadata", CFSTR("Verification failed: '%@' has asid metadata '%@' on device but the one on server is '%@' "), (char)v23);
        }
        else
        {
          AMSupportLogInternal();
        }
      }
      else
      {
        *a5 = 0;
        AMFDRErrorPushInternal(v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapVerifyAsidMetadata", CFSTR("Verification failed: '%@' has asid metadata '%@' on device but corresponding fdr data on server is not found"), (char)v23);
      }
      if (v21 == ++v22)
      {
        CFRelease(v23);
        goto LABEL_27;
      }
    }
    a6 = (CFTypeRef *)v39;
    AMFDRErrorPushInternal(v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapVerifyAsidMetadata", CFSTR("onDeviceDataClassInstance allocation failed"), v37);
    goto LABEL_43;
  }
LABEL_27:
  if (*a5)
    AMSupportLogInternal();
  v33 = 1;
LABEL_30:
  if (v44)
  {
    CFRelease(v44);
    v44 = 0;
  }
  if (v43)
  {
    CFRelease(v43);
    v43 = 0;
  }
  if (v42)
    CFRelease(v42);
  return v33;
}

uint64_t AMFDRSealingMapVerifyAsidMetadataForDevice(const __CFDictionary *cf, CFTypeRef *a2)
{
  const __CFDictionary *v3;
  CFTypeID v4;
  const __CFAllocator *v5;
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v7;
  CFTypeID v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t (*v12)(_QWORD *, _QWORD);
  const void *v13;
  const void *v14;
  CFTypeID v15;
  const __CFDictionary *RepairConfigurationEntries;
  const __CFDictionary *v17;
  CFTypeID v18;
  const __CFArray *Value;
  const __CFArray *v20;
  CFTypeID v21;
  CFIndex Count;
  CFMutableArrayRef v23;
  CFMutableArrayRef v24;
  const void *v25;
  BOOL v26;
  CFIndex v27;
  CFStringRef v28;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v30;
  CFTypeID v31;
  const __CFDictionary *v32;
  const void *v33;
  const void *v34;
  CFTypeRef *v35;
  CFTypeID v36;
  BOOL v37;
  CFStringRef v38;
  CFTypeID v39;
  const void *v40;
  const __CFArray *v41;
  const void *v42;
  CFTypeID v43;
  CFTypeID v44;
  __CFString *v45;
  const __CFString *v46;
  const __CFAllocator *v47;
  const __CFDictionary *EntryInternal;
  CFMutableStringRef v49;
  CFIndex v50;
  CFIndex v51;
  CFIndex v52;
  const __CFString *v53;
  const __CFString *v54;
  const __CFString *v55;
  CFTypeRef v56;
  CFIndex v57;
  CFIndex v58;
  CFIndex v59;
  char v60;
  const __CFString *v61;
  const __CFString *v62;
  const __CFArray *v63;
  const __CFString *format;
  char v66;
  char v67;
  const __CFString *v68;
  char v69;
  const __CFDictionary *v70;
  const void *v71;
  _QWORD *v72;
  const __CFArray *v73;
  const __CFAllocator *v74;
  __CFString *v75;
  CFMutableArrayRef v76;
  CFMutableArrayRef theArray;
  CFMutableArrayRef theArraya;
  char v79;
  CFDataRef theData;
  CFTypeRef cfa;
  CFTypeRef v82;
  UInt8 bytes[16];
  __int128 v84;
  __int128 v85;
  uint64_t v86;

  v3 = cf;
  v86 = *MEMORY[0x24BDAC8D0];
  v82 = 0;
  theData = 0;
  cfa = 0;
  v84 = 0u;
  v85 = 0u;
  *(_OWORD *)bytes = 0u;
  if (!cf || (v4 = CFGetTypeID(cf), v4 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("optionsDict has wrong type %@"), (char)v3);
    v60 = 0;
    v56 = 0;
    v7 = 0;
LABEL_110:
    v45 = 0;
    v49 = 0;
    v46 = 0;
    goto LABEL_80;
  }
  CFDictionaryGetValue(v3, CFSTR("TrustObjectURL"));
  v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  v7 = Mutable;
  if (!Mutable || (v8 = CFGetTypeID(Mutable), v8 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("queryCache allocation failed"), v69);
    v60 = 0;
    v56 = 0;
    goto LABEL_110;
  }
  v9 = AMFDRCreateTypeWithOptions(v5, CFSTR("Local"), 0);
  if (!v9)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataPrimaryModules", CFSTR("Unable to create amfdrLocal"), v69);
LABEL_113:
    v73 = 0;
    v41 = 0;
LABEL_114:
    format = CFSTR("_AMFDRSealingMapCopyAsidMetadataPrimaryModules failed");
LABEL_116:
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", format, v69);
LABEL_123:
    v60 = 0;
    v56 = 0;
    v45 = 0;
LABEL_133:
    v49 = 0;
    v46 = 0;
    goto LABEL_102;
  }
  v10 = v9;
  if ((AMFDRDataApTicketPopulate((uint64_t)v9) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataPrimaryModules", CFSTR("Unable to populate apTicket for amfdrLocal"), v69);
    CFRelease(v10);
    goto LABEL_113;
  }
  v11 = (_QWORD *)v10[17];
  if (*v11 < 0x21uLL || (v12 = (uint64_t (*)(_QWORD *, _QWORD))v11[4]) == 0)
  {
    v40 = 0;
LABEL_31:
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataPrimaryModules", CFSTR("currentDevice has wrong type '%@'"), (char)v40);
    v41 = 0;
    v73 = 0;
    v28 = 0;
    v76 = 0;
    theArray = 0;
    v26 = 0;
    goto LABEL_35;
  }
  v72 = v10;
  v13 = (const void *)v12(v10, v10[18]);
  if (!v13)
  {
    v40 = 0;
    goto LABEL_31;
  }
  v14 = v13;
  v15 = CFGetTypeID(v13);
  if (v15 != CFStringGetTypeID())
  {
    v10 = v72;
    v40 = v14;
    goto LABEL_31;
  }
  v71 = v14;
  RepairConfigurationEntries = (const __CFDictionary *)_AMFDRSealingMapGetRepairConfigurationEntries(v14);
  if (!RepairConfigurationEntries
    || (v17 = RepairConfigurationEntries, v18 = CFGetTypeID(RepairConfigurationEntries), v18 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataPrimaryModules", CFSTR("repairConfiguration has wrong type '%@'"), (char)v71);
LABEL_137:
    theArray = 0;
    v25 = v72;
    goto LABEL_138;
  }
  Value = (const __CFArray *)CFDictionaryGetValue(v17, CFSTR("RepairConfigurationAsidMetadata"));
  v20 = Value;
  if (!Value || (v21 = CFGetTypeID(Value), v21 != CFArrayGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataPrimaryModules", CFSTR("asidMetadataEntry has wrong type %@"), (char)v20);
    goto LABEL_137;
  }
  Count = CFArrayGetCount(v20);
  v23 = CFArrayCreateMutable(v5, 0, MEMORY[0x24BDBD690]);
  if (!v23)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataPrimaryModules", CFSTR("primaryDataClasses create failed"), v69);
    goto LABEL_137;
  }
  theArray = v23;
  v24 = CFArrayCreateMutable(v5, 0, MEMORY[0x24BDBD690]);
  v25 = v72;
  if (v24)
  {
    v74 = v5;
    v76 = v24;
    v70 = v3;
    if (Count < 1)
    {
      v28 = 0;
      v26 = 1;
LABEL_33:
      v41 = (const __CFArray *)CFRetain(theArray);
      v73 = (const __CFArray *)CFRetain(v76);
    }
    else
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v20, v27);
        v30 = ValueAtIndex;
        if (!ValueAtIndex || (v31 = CFGetTypeID(ValueAtIndex), v31 != CFDictionaryGetTypeID()))
        {
          AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataPrimaryModules", CFSTR("primaryDataDict has wrong type %@"), (char)v30);
          goto LABEL_107;
        }
        v32 = v7;
        v33 = CFDictionaryGetValue(v30, CFSTR("Tag"));
        v34 = v33;
        if (!v33 || (v35 = a2, v36 = CFGetTypeID(v33), v37 = v36 == CFStringGetTypeID(), a2 = v35, !v37))
        {
          AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataPrimaryModules", CFSTR("primaryDataClass has wrong type %@"), (char)v34);
          v41 = 0;
          v73 = 0;
          v7 = v32;
          goto LABEL_34;
        }
        if (v28)
          CFRelease(v28);
        v7 = v32;
        v38 = _copyIdentifierListForSealingMapEntry(v74, v30, v32, 0, 0, (uint64_t)a2);
        v28 = v38;
        if (!v38)
          break;
        v39 = CFGetTypeID(v38);
        if (v39 != CFStringGetTypeID())
          break;
        CFArrayAppendValue(theArray, v34);
        CFArrayAppendValue(v76, v28);
        v26 = ++v27 >= Count;
        if (Count == v27)
          goto LABEL_33;
      }
      AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataPrimaryModules", CFSTR("failed to get instance of primary dataClass %@"), (char)v34);
LABEL_107:
      v41 = 0;
      v73 = 0;
    }
LABEL_34:
    v5 = v74;
    v3 = v70;
    v40 = v71;
    v10 = v72;
LABEL_35:
    CFRelease(v10);
    v42 = v40;
    if (!v40)
      goto LABEL_37;
    goto LABEL_36;
  }
  AMFDRErrorPushInternal((uint64_t)a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyAsidMetadataPrimaryModules", CFSTR("primaryDataInstances create failed"), v69);
LABEL_138:
  CFRelease(v25);
  v41 = 0;
  v73 = 0;
  v26 = 0;
  v76 = 0;
  v28 = 0;
  v42 = v71;
LABEL_36:
  CFRelease(v42);
LABEL_37:
  if (v76)
    CFRelease(v76);
  if (theArray)
    CFRelease(theArray);
  if (v28)
    CFRelease(v28);
  if (!v26)
    goto LABEL_114;
  if ((_AMFDRSealingMapCopyAsidMetadataParameters(0, 0, v7, &v82, &cfa, 0, 0, a2) & 1) == 0)
  {
    format = CFSTR("_AMFDRSealingMapCopyAsidMetadataParameters failed");
    goto LABEL_116;
  }
  if (!v82)
  {
    v66 = 0;
LABEL_119:
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("onDeviceDataClasses has wrong type %@"), v66);
    goto LABEL_123;
  }
  v43 = CFGetTypeID(v82);
  if (v43 != CFArrayGetTypeID())
  {
    v66 = (char)v82;
    goto LABEL_119;
  }
  if (!cfa)
  {
    v67 = 0;
LABEL_122:
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("onDeviceDataInstances has wrong type %@"), v67);
    goto LABEL_123;
  }
  v44 = CFGetTypeID(cfa);
  if (v44 != CFArrayGetTypeID())
  {
    v67 = (char)cfa;
    goto LABEL_122;
  }
  v45 = (__CFString *)AMFDRCreateTypeWithOptions(v5, CFSTR("Remote"), v3);
  if (!v45)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("Unable to create amfdrRemote"), v69);
LABEL_132:
    v60 = 0;
    v56 = 0;
    goto LABEL_133;
  }
  if (!CFDictionaryContainsKey(v3, CFSTR("TrustObject")))
  {
    if ((AMFDRDataCopyTrustObject((uint64_t)v45) & 1) != 0)
      v68 = CFSTR("trust object empty");
    else
      v68 = CFSTR("failed to fetch trust object");
    goto LABEL_131;
  }
  if (CFDictionaryContainsKey(v3, CFSTR("TrustObjectDigest")))
  {
    v46 = 0;
  }
  else
  {
    theData = (CFDataRef)CFDictionaryGetValue((CFDictionaryRef)v45->data, CFSTR("TrustObject"));
    CFRetain(theData);
    CFDataGetBytePtr(theData);
    CFDataGetLength(theData);
    if (AMSupportDigestSha256())
    {
      v68 = CFSTR("Failed to get digest from trust object");
LABEL_131:
      AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", v68, v69);
      goto LABEL_132;
    }
    v47 = CFGetAllocator(v45);
    v46 = (const __CFString *)CFDataCreate(v47, bytes, 32);
    if (!v46)
    {
      AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("Failed to allocate trust object digest data"), v69);
      v60 = 0;
      v56 = 0;
      v49 = 0;
      goto LABEL_102;
    }
    AMFDRSetOption((uint64_t)v45, CFSTR("TrustObjectDigest"), v46);
  }
  EntryInternal = AMFDRSealingMapGetEntryInternal((uint64_t)v45, CFSTR("seal"), 0, 0);
  if (!AMFDRSealingMapEntryHasAttributeInternal((int)EntryInternal, EntryInternal, CFSTR("DeprecateVersion1"), 0))
  {
    AMFDRSetOption((uint64_t)v45, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD268]);
    AMSupportLogInternal();
  }
  v49 = CFStringCreateMutable(v5, 0);
  if (!v49)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("permissions is NULL"), v69);
LABEL_101:
    v60 = 0;
    v56 = 0;
    goto LABEL_102;
  }
  v50 = CFArrayGetCount((CFArrayRef)v82);
  if (v50 >= 1)
  {
    v51 = v50;
    v52 = 0;
    while (1)
    {
      v53 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v82, v52);
      if (!v53)
      {
        AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("dataClassStr is NULL"), v69);
        goto LABEL_101;
      }
      v54 = v53;
      v55 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cfa, v52);
      if (!v55)
      {
        AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("dataInstanceStr is NULL"), v69);
        goto LABEL_101;
      }
      if ((AMFDRDataAppendPermissionsString(v45, 7u, v54, v55, v49) & 1) == 0)
        break;
      if (v51 == ++v52)
        goto LABEL_67;
    }
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("AMFDRDataAppendPermissionsString failed"), v69);
    goto LABEL_101;
  }
LABEL_67:
  AMFDRSetOption((uint64_t)v45, CFSTR("Permissions"), v49);
  v56 = AMFDRDataMultiCopyAsidMetadata(v45, (uint64_t)v82, (uint64_t)cfa, a2);
  if (v56)
  {
    theArraya = (CFMutableArrayRef)v46;
    v57 = CFArrayGetCount(v41);
    if (v57 < 1)
    {
      v60 = 1;
      v63 = v73;
    }
    else
    {
      v58 = v57;
      v75 = v45;
      v59 = 0;
      v60 = 1;
      while (1)
      {
        v79 = 1;
        v61 = (const __CFString *)CFArrayGetValueAtIndex(v41, v59);
        v62 = (const __CFString *)CFArrayGetValueAtIndex(v73, v59);
        if (!_AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule(v61, v62, v56, v7, &v79, a2))
          break;
        if (!v79)
        {
          AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("Primary module '%@:%@' verification failed"), (char)v61);
          v60 = 0;
        }
        if (v58 == ++v59)
          goto LABEL_74;
      }
      AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("_AMFDRSealingMapVerifyAsidMetadataWithPrimaryModule failed"), v69);
      v60 = 0;
LABEL_74:
      v63 = v73;
      v45 = v75;
    }
    v46 = (const __CFString *)theArraya;
    if (!v41)
      goto LABEL_78;
    goto LABEL_77;
  }
  AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapVerifyAsidMetadataForDevice", CFSTR("AMFDRDataMultiCopyAsidMetadata failed"), v69);
  v60 = 0;
LABEL_102:
  v63 = v73;
  if (v41)
LABEL_77:
    CFRelease(v41);
LABEL_78:
  if (v63)
    CFRelease(v63);
LABEL_80:
  if (v82)
  {
    CFRelease(v82);
    v82 = 0;
  }
  if (cfa)
  {
    CFRelease(cfa);
    cfa = 0;
  }
  if (v56)
    CFRelease(v56);
  if (v7)
    CFRelease(v7);
  if (v45)
    CFRelease(v45);
  if (v49)
    CFRelease(v49);
  if (v46)
    CFRelease(v46);
  if (theData)
    CFRelease(theData);
  return v60 & 1;
}

CFDataRef AMFDRSealingMapCreateLocalMultiDataBlobForClass(__CFString *a1, CFDictionaryRef theDict, int a3, _QWORD *a4)
{
  const __CFAllocator *v8;
  __CFDictionary *MutableCopy;
  __CFDictionary *v10;
  const void *v11;
  const __CFString *v12;
  CFStringRef v13;
  __CFArray *Mutable;
  __CFArray *v15;
  CFIndex v16;
  CFStringRef FullKey;
  const void *v18;
  const __CFString *ValueAtIndex;
  CFDataRef MultiDataAsMultiResponse;
  char v22;
  uint64_t v23;
  const __CFDictionary *v24;
  CFTypeRef v25;

  v25 = 0;
  v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if (theDict)
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, theDict);
  else
    MutableCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v10 = MutableCopy;
  if (!MutableCopy)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateLocalMultiDataBlobForClass", CFSTR("optionsFDR is NULL"), v22);
    MultiDataAsMultiResponse = 0;
    goto LABEL_47;
  }
  v11 = (const void *)*MEMORY[0x24BDBD268];
  CFDictionaryAddValue(MutableCopy, CFSTR("VerifyData"), (const void *)*MEMORY[0x24BDBD268]);
  CFDictionaryAddValue(v10, CFSTR("StripImg4"), v11);
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateLocalMultiDataBlobForClass", CFSTR("dataClass is NULL"), v22);
    goto LABEL_31;
  }
  if (a3)
    v12 = (const __CFString *)AMFDRSealingMapCopyMultiInstanceForClass(a1, (uint64_t)a4);
  else
    v12 = (const __CFString *)AMFDRSealingManifestCopyMultiInstanceForClass(a1, theDict, a4);
  v13 = v12;
  if (!v12)
  {
    AMSupportLogInternal();
LABEL_31:
    MultiDataAsMultiResponse = 0;
LABEL_46:
    CFRelease(v10);
    goto LABEL_47;
  }
  Mutable = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  v24 = v10;
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateLocalMultiDataBlobForClass", CFSTR("dataClassInstanceArray is NULL"), v22);
    v15 = 0;
LABEL_51:
    MultiDataAsMultiResponse = 0;
LABEL_40:
    CFRelease(v13);
    goto LABEL_41;
  }
  v15 = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  if (!v15)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateLocalMultiDataBlobForClass", CFSTR("dataArray is NULL"), v22);
    goto LABEL_51;
  }
  v23 = (uint64_t)a4;
  if (CFArrayGetCount((CFArrayRef)v13) >= 1)
  {
    v16 = 0;
    FullKey = 0;
    v18 = 0;
    while (1)
    {
      if (FullKey)
        CFRelease(FullKey);
      if (v18)
        CFRelease(v18);
      if (v25)
      {
        CFRelease(v25);
        v25 = 0;
      }
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v13, v16);
      v18 = (const void *)AMFDRSealingMapCopyLocalData(a1, ValueAtIndex, v24, (uint64_t)&v25);
      if (v25)
        AMSupportLogInternal();
      if ((a3 & 1) == 0 && !v18)
      {
        AMFDRErrorPushInternal(v23, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateLocalMultiDataBlobForClass", CFSTR("failed to create data for %@-%@"), (char)a1);
        goto LABEL_51;
      }
      if (v18)
      {
        FullKey = AMFDRDataLocalCreateFullKey(v8, (uint64_t)a1, (uint64_t)ValueAtIndex);
        if (!FullKey)
        {
          AMFDRErrorPushInternal(v23, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateLocalMultiDataBlobForClass", CFSTR("failed to create currDataClassInstance string"), v22);
          CFRelease(v13);
          MultiDataAsMultiResponse = 0;
          goto LABEL_38;
        }
        CFArrayAppendValue(Mutable, FullKey);
        CFArrayAppendValue(v15, v18);
      }
      else
      {
        AMSupportLogInternal();
        FullKey = 0;
      }
      if (++v16 >= CFArrayGetCount((CFArrayRef)v13))
        goto LABEL_33;
    }
  }
  v18 = 0;
  FullKey = 0;
LABEL_33:
  if (CFArrayGetCount(v15) < 1)
  {
    AMSupportLogInternal();
    MultiDataAsMultiResponse = 0;
  }
  else
  {
    MultiDataAsMultiResponse = AMFDRDataCreateMultiDataAsMultiResponse(Mutable, v15, v23);
    if (!MultiDataAsMultiResponse)
      AMFDRErrorPushInternal(v23, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCreateLocalMultiDataBlobForClass", CFSTR("failed to create an encoded data blob for %@"), (char)a1);
  }
  CFRelease(v13);
  if (v18)
LABEL_38:
    CFRelease(v18);
  v13 = FullKey;
  if (FullKey)
    goto LABEL_40;
LABEL_41:
  if (Mutable)
    CFRelease(Mutable);
  v10 = v24;
  if (v15)
    CFRelease(v15);
  if (v24)
    goto LABEL_46;
LABEL_47:
  if (v25)
    CFRelease(v25);
  return MultiDataAsMultiResponse;
}

uint64_t AMFDRSealingMapCopyLocalMultiCombinedDataBegin(uint64_t a1, uint64_t a2)
{
  return AMFDRSealingMapCopyLocalMultiCombinedDataBeginWithOptions(a1, 0, a2);
}

uint64_t AMFDRSealingMapCopyLocalMultiCombinedDataBeginWithOptions(uint64_t a1, CFDictionaryRef theDict, uint64_t a3)
{
  const __CFAllocator *v6;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v8;
  void *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  const __CFString *v14;
  char v15;

  v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if (theDict)
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, theDict);
  else
    MutableCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v8 = MutableCopy;
  if (!a1)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataBeginWithOptions", CFSTR("copyLocalMultiCombinedDataContext is NULL"), v15);
LABEL_21:
    v12 = 0;
    if (!v8)
      return v12;
    goto LABEL_17;
  }
  v9 = malloc_type_calloc(1uLL, 0x40uLL, 0x1060040D88E8A37uLL);
  *(_QWORD *)a1 = v9;
  if (!v9)
  {
    v14 = CFSTR("failed to allocate memory for AMFDRSealingMapCopyLocalMultiCombinedDataContext");
    goto LABEL_20;
  }
  **(_QWORD **)a1 = CFArrayCreateMutable(v6, 0, MEMORY[0x24BDBD690]);
  if (!**(_QWORD **)a1)
    goto LABEL_19;
  *(_QWORD *)(*(_QWORD *)a1 + 8) = CFArrayCreateMutable(v6, 0, MEMORY[0x24BDBD690]);
  if (!*(_QWORD *)(*(_QWORD *)a1 + 8))
    goto LABEL_19;
  *(_QWORD *)(*(_QWORD *)a1 + 16) = CFArrayCreateMutable(v6, 0, MEMORY[0x24BDBD690]);
  if (!*(_QWORD *)(*(_QWORD *)a1 + 16))
    goto LABEL_19;
  *(_QWORD *)(*(_QWORD *)a1 + 24) = CFArrayCreateMutable(v6, 0, MEMORY[0x24BDBD690]);
  if (!*(_QWORD *)(*(_QWORD *)a1 + 24))
    goto LABEL_19;
  *(_QWORD *)(*(_QWORD *)a1 + 32) = AMSupportSafeRetain();
  if (!*(_QWORD *)(*(_QWORD *)a1 + 32))
    goto LABEL_19;
  *(_QWORD *)(*(_QWORD *)a1 + 56) = AMFDRCreateTypeWithOptions(v6, CFSTR("Local"), theDict);
  v10 = *(_QWORD *)(*(_QWORD *)a1 + 56);
  if (!v10)
  {
    v14 = CFSTR("amfdrLocal is NULL");
    goto LABEL_20;
  }
  if (AMFDRDataApTicketPopulate(v10))
    AMSupportLogInternal();
  v11 = AMFDRAPTicketAllowsUnsealedData(*(_QWORD *)(*(_QWORD *)a1 + 56));
  *(_BYTE *)(*(_QWORD *)a1 + 40) = v11;
  if (v11)
  {
    *(_QWORD *)(*(_QWORD *)a1 + 48) = CFArrayCreateMutable(v6, 0, MEMORY[0x24BDBD690]);
    if (!*(_QWORD *)(*(_QWORD *)a1 + 48))
    {
LABEL_19:
      v14 = CFSTR("failed to allocate memory");
LABEL_20:
      AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataBeginWithOptions", v14, v15);
      goto LABEL_21;
    }
  }
  v12 = 1;
  if (v8)
LABEL_17:
    CFRelease(v8);
  return v12;
}

uint64_t AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClass(uint64_t a1, __CFString *a2, uint64_t a3)
{
  const __CFString *v6;
  const __CFString *v7;
  void *v8;
  const void *v9;
  uint64_t v10;
  const __CFString *v12;
  const __CFString *v13;
  char v14;
  CFTypeRef v15;

  v15 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClass", CFSTR("copyLocalMultiCombinedDataContext is NULL"), v14);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 24) || !*(_QWORD *)a1 || !*(_QWORD *)(a1 + 8) || !*(_QWORD *)(a1 + 16) || !*(_QWORD *)(a1 + 32))
  {
    v12 = CFSTR("copyLocalMultiCombinedDataContext is not properly initialized, AMFDRSealingMapCopyLocalMultiCombinedDataBegin should be used");
LABEL_19:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClass", v12, v14);
    goto LABEL_20;
  }
  if (!a2)
  {
    v12 = CFSTR("dataClass is NULL");
    goto LABEL_19;
  }
  v6 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(a2, a3, 0, 0);
  if (v6)
  {
    v7 = v6;
    if (*(_BYTE *)(a1 + 40))
    {
      if ((_AMFDRSealingMapCopyLocalMultiCombinedDataCopyPayloadAndSaveManifest(a1, (uint64_t)a2, (uint64_t)v6, 0, &v15, a3) & 1) == 0)
      {
        v14 = (char)a2;
        v13 = CFSTR("failed to copy data and save manifest for %@");
LABEL_26:
        AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClass", v13, v14);
        CFRelease(v7);
        goto LABEL_20;
      }
      v8 = (void *)CFRetain(v15);
    }
    else
    {
      v8 = (void *)AMFDRSealingMapCopyLocalData(a2, v6, *(const __CFDictionary **)(a1 + 32), a3);
    }
    v9 = v8;
    if (v8)
    {
      _AMFDRSealingMapCopyLocalMultiCombinedDataContextAddEntry((CFMutableArrayRef *)a1, a2, v7, &stru_24C6A3418, v8);
      CFRelease(v7);
      CFRelease(v9);
      v10 = 1;
      goto LABEL_15;
    }
    v13 = CFSTR("copied localData is NULL");
    goto LABEL_26;
  }
  AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClass", CFSTR("copied dataInstance is NULL"), v14);
LABEL_20:
  v10 = 0;
LABEL_15:
  if (v15)
    CFRelease(v15);
  return v10;
}

uint64_t _AMFDRSealingMapCopyLocalMultiCombinedDataCopyPayloadAndSaveManifest(uint64_t a1, uint64_t a2, uint64_t a3, int a4, CFTypeRef *a5, uint64_t a6)
{
  char v9;
  uint64_t v10;
  const __CFString *v12;
  char v13;
  CFTypeRef v14;
  CFTypeRef v15;

  v14 = 0;
  v15 = 0;
  if (!a5)
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalMultiCombinedDataCopyPayloadAndSaveManifest", CFSTR("outType is NULL"), v13);
    v10 = 0;
    goto LABEL_10;
  }
  if (a1 && *(_BYTE *)(a1 + 40) && *(_QWORD *)(a1 + 48))
  {
    v9 = a2;
    if ((AMFDRDataCopyRawDataAndManifests(*(_QWORD **)(a1 + 56), a2, a3, a4, &v15, &v14, 0, a6) & 1) != 0)
    {
      if (v14)
      {
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v14);
        *a5 = CFRetain(v15);
        v10 = 1;
        goto LABEL_8;
      }
      v13 = v9;
      v12 = CFSTR("failed to copy device manifest for %@-%@");
    }
    else
    {
      v12 = CFSTR("failed to copy data and manifest");
    }
    AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalMultiCombinedDataCopyPayloadAndSaveManifest", v12, v13);
  }
  else
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalMultiCombinedDataCopyPayloadAndSaveManifest", CFSTR("not allow unseal, shouldn't call this function"), v13);
  }
  v10 = 0;
LABEL_8:
  if (v14)
  {
    CFRelease(v14);
    v14 = 0;
  }
LABEL_10:
  if (v15)
    CFRelease(v15);
  return v10;
}

void _AMFDRSealingMapCopyLocalMultiCombinedDataContextAddEntry(CFMutableArrayRef *a1, const void *a2, const void *a3, const void *a4, void *value)
{
  CFArrayAppendValue(a1[3], value);
  CFArrayAppendValue(*a1, a2);
  CFArrayAppendValue(a1[1], a3);
  CFArrayAppendValue(a1[2], a4);
}

uint64_t AMFDRSealingMapCopyLocalMultiCombinedDataAddSubCCForClass(uint64_t a1, __CFString *a2, const __CFArray *a3, uint64_t a4)
{
  const __CFString *v8;
  const __CFString *v9;
  uint64_t v10;
  const __CFDictionary *v11;
  CFIndex v12;
  const void *v13;
  const __CFAllocator *v14;
  const void *ValueAtIndex;
  const void *v16;
  CFTypeID v17;
  const __CFString *Value;
  CFTypeID v19;
  void *ExternalRepresentation;
  CFTypeID v21;
  uint64_t v22;
  uint64_t v23;
  const __CFString *v25;
  const __CFString *v26;
  char v27;
  uint64_t v28;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddSubCCForClass", CFSTR("copyLocalMultiCombinedDataContext is NULL"), v27);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 24) || !*(_QWORD *)a1 || !*(_QWORD *)(a1 + 8) || !*(_QWORD *)(a1 + 16) || !*(_QWORD *)(a1 + 32))
  {
    v25 = CFSTR("copyLocalMultiCombinedDataContext is not properly initialized, AMFDRSealingMapCopyLocalMultiCombinedDataBegin should be used");
LABEL_41:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddSubCCForClass", v25, v27);
LABEL_42:
    v23 = 0;
    goto LABEL_34;
  }
  if (!a2)
  {
    v25 = CFSTR("dataClass is NULL");
    goto LABEL_41;
  }
  if (!a3)
  {
    v25 = CFSTR("subCCArray is NULL, please use AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClass when adding the entire data");
    goto LABEL_41;
  }
  v8 = (const __CFString *)_AMFDRSealingMapCopyIdentifierListForClass(a2, a4, 0, 0);
  if (!v8)
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddSubCCForClass", CFSTR("failed to copy dataInstance for %@"), (char)a2);
    goto LABEL_42;
  }
  v9 = v8;
  if (*(_BYTE *)(a1 + 40))
  {
    if ((_AMFDRSealingMapCopyLocalMultiCombinedDataCopyPayloadAndSaveManifest(a1, (uint64_t)a2, (uint64_t)v8, 1, &cf, a4) & 1) == 0)
    {
      v27 = (char)a2;
      v26 = CFSTR("failed to copy data and save manifest for %@");
      goto LABEL_49;
    }
    v10 = (uint64_t)CFRetain(cf);
  }
  else
  {
    v10 = AMFDRSealingMapCopyLocalDict(a2, v8, *(const __CFDictionary **)(a1 + 32), a4);
  }
  v11 = (const __CFDictionary *)v10;
  if (!v10)
  {
    v26 = CFSTR("copied localData is NULL");
LABEL_49:
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddSubCCForClass", v26, v27);
    CFRelease(v9);
    goto LABEL_42;
  }
  if (CFArrayGetCount(a3) < 1)
  {
    v23 = 1;
    goto LABEL_33;
  }
  v28 = a4;
  v12 = 0;
  v13 = 0;
  v14 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(a3, v12);
    if (!ValueAtIndex || (v16 = ValueAtIndex, v17 = CFGetTypeID(ValueAtIndex), v17 != CFStringGetTypeID()))
    {
      AMFDRErrorPushInternal(v28, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddSubCCForClass", CFSTR("subCC Name should be CFString"), v27);
      v22 = 0;
      v23 = 0;
      if (!v13)
        goto LABEL_33;
LABEL_29:
      CFRelease(v13);
      v23 = v22;
      goto LABEL_33;
    }
    Value = (const __CFString *)CFDictionaryGetValue(v11, v16);
    if (v13)
      CFRelease(v13);
    if (!Value)
    {
LABEL_31:
      AMFDRErrorPushInternal(v28, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddSubCCForClass", CFSTR("unknown data type for the subCC value"), v27);
      goto LABEL_32;
    }
    v19 = CFGetTypeID(Value);
    if (v19 == CFStringGetTypeID())
    {
      ExternalRepresentation = CFStringCreateExternalRepresentation(v14, Value, 0x8000100u, 0x5Fu);
    }
    else
    {
      v21 = CFGetTypeID(Value);
      if (v21 != CFDataGetTypeID())
        goto LABEL_31;
      ExternalRepresentation = (void *)CFRetain(Value);
    }
    v13 = ExternalRepresentation;
    if (!ExternalRepresentation)
      break;
    _AMFDRSealingMapCopyLocalMultiCombinedDataContextAddEntry((CFMutableArrayRef *)a1, a2, v9, v16, ExternalRepresentation);
    if (++v12 >= CFArrayGetCount(a3))
    {
      v22 = 1;
      goto LABEL_29;
    }
  }
  AMFDRErrorPushInternal(v28, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddSubCCForClass", CFSTR("subCC %@ is missing"), (char)v16);
LABEL_32:
  v23 = 0;
LABEL_33:
  CFRelease(v9);
  CFRelease(v11);
LABEL_34:
  if (cf)
    CFRelease(cf);
  return v23;
}

uint64_t AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClassWithMultiData(uint64_t a1, __CFString *a2, uint64_t a3)
{
  const __CFArray *v6;
  const __CFArray *v7;
  CFTypeID v8;
  CFIndex v9;
  const void *v10;
  const __CFString *ValueAtIndex;
  void *v12;
  uint64_t v13;
  const __CFString *v15;
  char v16;
  CFTypeRef v17;

  v17 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClassWithMultiData", CFSTR("copyLocalMultiCombinedDataContext is NULL"), v16);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 24) || !*(_QWORD *)a1 || !*(_QWORD *)(a1 + 8) || !*(_QWORD *)(a1 + 16) || !*(_QWORD *)(a1 + 32))
  {
    v15 = CFSTR("copyLocalMultiCombinedDataContext is not properly initialized, AMFDRSealingMapCopyLocalMultiCombinedDataBegin should be used");
LABEL_35:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClassWithMultiData", v15, v16);
    v13 = 0;
    goto LABEL_28;
  }
  if (!a2)
  {
    v15 = CFSTR("dataClass is NULL");
    goto LABEL_35;
  }
  v6 = (const __CFArray *)AMFDRSealingMapCopyMultiInstanceForClass(a2, a3);
  v7 = v6;
  if (!v6 || (v8 = CFGetTypeID(v6), v8 != CFArrayGetTypeID()) || CFArrayGetCount(v7) < 1)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClassWithMultiData", CFSTR("cannot find valid dataInstances"), v16);
    goto LABEL_33;
  }
  if (CFArrayGetCount(v7) < 1)
  {
    v10 = 0;
    v13 = 1;
    goto LABEL_26;
  }
  v9 = 0;
  v10 = 0;
  while (1)
  {
    if (v10)
      CFRelease(v10);
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v9);
    if (*(_BYTE *)(a1 + 40))
      break;
    v12 = (void *)AMFDRSealingMapCopyLocalData(a2, ValueAtIndex, *(const __CFDictionary **)(a1 + 32), a3);
LABEL_19:
    v10 = v12;
    if (!v12)
    {
      AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClassWithMultiData", CFSTR("copied localData is NULL"), v16);
      v13 = 0;
      goto LABEL_22;
    }
    _AMFDRSealingMapCopyLocalMultiCombinedDataContextAddEntry((CFMutableArrayRef *)a1, a2, ValueAtIndex, &stru_24C6A3418, v12);
    if (++v9 >= CFArrayGetCount(v7))
    {
      v13 = 1;
      goto LABEL_22;
    }
  }
  if ((_AMFDRSealingMapCopyLocalMultiCombinedDataCopyPayloadAndSaveManifest(a1, (uint64_t)a2, (uint64_t)ValueAtIndex, 0, &v17, a3) & 1) != 0)
  {
    v12 = (void *)CFRetain(v17);
    goto LABEL_19;
  }
  AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataAddDataClassWithMultiData", CFSTR("failed to copy data and save manifest for %@-%@"), (char)a2);
LABEL_33:
  v13 = 0;
  v10 = 0;
LABEL_22:
  if (v7)
  {
LABEL_26:
    CFRelease(v7);
    if (v10)
      goto LABEL_27;
    goto LABEL_28;
  }
  if (!v10)
    goto LABEL_28;
LABEL_27:
  CFRelease(v10);
LABEL_28:
  if (v17)
    CFRelease(v17);
  return v13;
}

CFDataRef AMFDRSealingMapCopyLocalMultiCombinedDataEnd(const __CFArray ***a1, CFTypeRef *a2)
{
  const __CFArray **v4;
  const __CFAllocator *v5;
  __CFDictionary *Mutable;
  const __CFDictionary *v7;
  const __CFData *v8;
  _QWORD *v9;
  CFDataRef MultiCombinedData;
  const __CFArray **v11;
  const __CFArray *v12;
  const void *ValueAtIndex;
  const __CFString *v15;
  const __CFString *v16;
  char v17;

  if (!a1 || (v4 = *a1) == 0)
  {
    v15 = CFSTR("copyLocalMultiCombinedDataContext is NULL");
    goto LABEL_28;
  }
  if (!v4[3] || !*v4 || !v4[1] || !v4[2])
  {
    v15 = CFSTR("copyLocalMultiCombinedDataContext is not properly initialized, AMFDRSealingMapCopyLocalMultiCombinedDataBegin should be used");
LABEL_28:
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataEnd", v15, v17);
    goto LABEL_24;
  }
  v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataEnd", CFSTR("failed to initialize options"), v17);
    goto LABEL_24;
  }
  v7 = Mutable;
  CFDictionaryAddValue(Mutable, CFSTR("VerifyData"), (const void *)*MEMORY[0x24BDBD268]);
  v8 = (const __CFData *)AMFDRSealingMapCopyLocalDataForClass(CFSTR("seal"), v7, (uint64_t)a2);
  if (!v8)
  {
    v11 = *a1;
    if (*((_BYTE *)*a1 + 40))
    {
      if (a2 && *a2 && (CFRelease(*a2), *a2 = 0, (v11 = *a1) == 0))
      {
        v16 = CFSTR("copyLocalMultiCombinedDataContext is NULL");
      }
      else
      {
        v12 = v11[6];
        if (v12 && CFArrayGetCount(v12) > 0)
        {
          if (CFArrayGetCount(v11[6]) == 1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v11[6], 0);
            v8 = (const __CFData *)CFRetain(ValueAtIndex);
            if (v8)
              goto LABEL_9;
          }
          else
          {
            AMSupportLogInternal();
          }
          goto LABEL_23;
        }
        v16 = CFSTR("manifestArray is empty");
      }
      AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealingMapCopyLocalMultiCombinedDataCreateUnsealedManifest", v16, v17);
    }
LABEL_23:
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataEnd", CFSTR("failed to copy manifestOverride"), v17);
    CFRelease(v7);
LABEL_24:
    MultiCombinedData = 0;
    goto LABEL_25;
  }
LABEL_9:
  v9 = AMFDRCreateTypeWithOptions(v5, CFSTR("Local"), v7);
  if ((AMFDRDataCopyTrustObject((uint64_t)v9) & 1) != 0)
  {
    MultiCombinedData = AMFDRDataLocalCreateMultiCombinedData(**a1, (*a1)[1], (*a1)[2], (*a1)[3], v8, 0, (uint64_t)a2);
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealingMapCopyLocalMultiCombinedDataEnd", CFSTR("failed to copy trust object"), v17);
    MultiCombinedData = 0;
  }
  CFRelease(v8);
  CFRelease(v7);
  if (v9)
    CFRelease(v9);
LABEL_25:
  AMFDRSealingMapCopyLocalMultiCombinedDataContextDestroy((CFTypeRef **)a1);
  return MultiCombinedData;
}

void AMFDRSealingMapCopyLocalMultiCombinedDataContextDestroy(CFTypeRef **a1)
{
  CFTypeRef *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      if (v2[3])
      {
        CFRelease(v2[3]);
        (*a1)[3] = 0;
        v2 = *a1;
      }
      if (*v2)
      {
        CFRelease(*v2);
        **a1 = 0;
        v2 = *a1;
      }
      if (v2[1])
      {
        CFRelease(v2[1]);
        (*a1)[1] = 0;
        v2 = *a1;
      }
      if (v2[2])
      {
        CFRelease(v2[2]);
        (*a1)[2] = 0;
        v2 = *a1;
      }
      if (v2[4])
      {
        CFRelease(v2[4]);
        (*a1)[4] = 0;
        v2 = *a1;
      }
      if (v2[6])
      {
        CFRelease(v2[6]);
        (*a1)[6] = 0;
        v2 = *a1;
      }
      if (!v2[7] || (CFRelease(v2[7]), (*a1)[7] = 0, (v2 = *a1) != 0))
      {
        free(v2);
        *a1 = 0;
      }
    }
  }
}

uint64_t ___isAppleDeviceQueryFrameworkAvailable_block_invoke()
{
  uint64_t result;

  _isAppleDeviceQueryFrameworkAvailable_isAvailable = 1;
  if (!MEMORY[0x24BE06038])
    return AMSupportLogInternal();
  return result;
}

uint64_t ___isZhuGeLegacyAvailable_block_invoke()
{
  uint64_t result;

  if (!ZhuGeSupportLibraryCore_frameworkLibrary)
    ZhuGeSupportLibraryCore_frameworkLibrary = _sl_dlopen();
  if (!ZhuGeSupportLibraryCore_frameworkLibrary)
  {
    _isZhuGeLegacyAvailable_isAvailable = 0;
    return AMSupportLogInternal();
  }
  result = getZhuGeCopyValueWithErrorSymbolLoc();
  _isZhuGeLegacyAvailable_isAvailable = result != 0;
  if (!result)
    return AMSupportLogInternal();
  return result;
}

uint64_t getZhuGeCopyValueWithErrorSymbolLoc()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v0 = getZhuGeCopyValueWithErrorSymbolLoc_ptr;
  v6 = getZhuGeCopyValueWithErrorSymbolLoc_ptr;
  if (!getZhuGeCopyValueWithErrorSymbolLoc_ptr)
  {
    v2[0] = MEMORY[0x24BDAC760];
    v2[1] = 0x40000000;
    v2[2] = __getZhuGeCopyValueWithErrorSymbolLoc_block_invoke;
    v2[3] = &unk_24C69F188;
    v2[4] = &v3;
    __getZhuGeCopyValueWithErrorSymbolLoc_block_invoke((uint64_t)v2);
    v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void *__getZhuGeCopyValueWithErrorSymbolLoc_block_invoke(uint64_t a1)
{
  void *v2;
  void *result;
  void *v4;

  if (ZhuGeSupportLibraryCore_frameworkLibrary)
  {
    v2 = (void *)ZhuGeSupportLibraryCore_frameworkLibrary;
  }
  else
  {
    ZhuGeSupportLibraryCore_frameworkLibrary = _sl_dlopen();
    v2 = (void *)ZhuGeSupportLibraryCore_frameworkLibrary;
    if (!ZhuGeSupportLibraryCore_frameworkLibrary)
    {
      v4 = (void *)abort_report_np();
      free(v4);
    }
  }
  result = dlsym(v2, "ZhuGeCopyValueWithError");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  getZhuGeCopyValueWithErrorSymbolLoc_ptr = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

dispatch_queue_t __sealingMapCacheQueue_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("com.apple.libfdr.sealingMapCache", 0);
  sealingMapCacheQueue_sealingMapCacheQueue = (uint64_t)result;
  return result;
}

const __CFDictionary *_AMFDRSealingMapGetManifestPropertiesEntries(const void *a1)
{
  const __CFDictionary *FDRSealingMapFromCache;
  const __CFDictionary *v3;
  CFTypeID v4;
  const __CFDictionary *Value;
  CFTypeID v6;
  CFTypeID v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  CFTypeID v10;
  const __CFDictionary *v11;
  CFTypeID v12;

  if (!a1)
    goto LABEL_11;
  FDRSealingMapFromCache = (const __CFDictionary *)_getFDRSealingMapFromCache((uint64_t)a1);
  v3 = FDRSealingMapFromCache;
  if (!FDRSealingMapFromCache)
  {
    AMSupportLogInternal();
    return v3;
  }
  v4 = CFGetTypeID(FDRSealingMapFromCache);
  if (v4 != CFDictionaryGetTypeID())
    goto LABEL_11;
  Value = (const __CFDictionary *)CFDictionaryGetValue(v3, CFSTR("ManifestProperties"));
  if (!Value)
    goto LABEL_11;
  v3 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFArrayGetTypeID())
  {
    v7 = CFGetTypeID(v3);
    if (v7 != CFDictionaryGetTypeID()
      || (v8 = (const __CFDictionary *)CFDictionaryGetValue(v3, a1)) == 0
      || (v9 = v8, v10 = CFGetTypeID(v8), v10 != CFDictionaryGetTypeID())
      || (v11 = (const __CFDictionary *)CFDictionaryGetValue(v9, CFSTR("Properties"))) == 0
      || (v3 = v11, v12 = CFGetTypeID(v11), v12 != CFArrayGetTypeID()))
    {
LABEL_11:
      AMSupportLogInternal();
      return 0;
    }
  }
  return v3;
}

dispatch_queue_t __sealingMapRepairConfigurationCacheQueue_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("com.apple.libfdr.sealingMapRepairConfigurationCache", 0);
  sealingMapRepairConfigurationCacheQueue_sealingMapRepairConfigurationCacheQueue = (uint64_t)result;
  return result;
}

uint64_t _getMinimalSealingManifestDataInstances(void *value, const __CFData *a2, uint64_t a3)
{
  const void *v4;
  __CFArray *v5;
  __CFArray *v6;
  uint64_t v7;
  const void *v8;
  CFStringRef v9;
  CFStringRef v10;
  char v11;
  const __CFString *v12;
  const __CFAllocator *v13;
  CFStringRef v14;
  const __CFAllocator *v15;
  CFTypeRef v16;
  const __CFString *v18;
  char v19;
  unint64_t *v20;
  unsigned int numBytes;
  const UInt8 *numBytes_4;
  unsigned int v23;
  const UInt8 *v24;

  v24 = 0;
  v23 = 0;
  numBytes_4 = 0;
  numBytes = 0;
  v20 = 0;
  v4 = *(const void **)a3;
  v6 = *(__CFArray **)(a3 + 16);
  v5 = *(__CFArray **)(a3 + 24);
  v7 = *(_QWORD *)(a3 + 32);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 8), value);
  CFDataGetBytePtr(a2);
  CFDataGetLength(a2);
  if (AMFDRDecodeManifestBody(&v20))
  {
    v18 = CFSTR("AMFDRDecodeManifestBody failed");
LABEL_31:
    AMFDRErrorPushInternal(v7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_getMinimalSealingManifestDataInstances", v18, v19);
  }
  else
  {
    if (AMFDRDecodeManifestBodyNext(&v20, &v24, &v23, &numBytes_4, &numBytes))
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
    }
    else
    {
      v11 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v12 = CFSTR("failed to create dataInstanceStr");
      do
      {
        if (v10)
          CFRelease(v10);
        if (v9)
          CFRelease(v9);
        if (v8)
          CFRelease(v8);
        v10 = 0;
        if (v24 && v23 && numBytes_4)
        {
          v9 = 0;
          v8 = 0;
          if (numBytes)
          {
            v13 = CFGetAllocator(v4);
            v14 = CFStringCreateWithBytes(v13, v24, v23, 0x8000100u, 0);
            if (!v14)
            {
              v18 = CFSTR("failed to create dataClassStr");
              goto LABEL_31;
            }
            v10 = v14;
            v15 = CFGetAllocator(v4);
            v9 = CFStringCreateWithBytes(v15, numBytes_4, numBytes, 0x8000100u, 0);
            if (!v9)
              goto LABEL_33;
            v16 = AMFDRDataInstanceCopyNonSik(v4, v9);
            if (!v16)
            {
              v12 = CFSTR("failed to create dataInstanceNonSik");
LABEL_33:
              AMFDRErrorPushInternal(v7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_getMinimalSealingManifestDataInstances", v12, v19);
              v8 = 0;
              goto LABEL_24;
            }
            v8 = v16;
            CFArrayAppendValue(v6, v10);
            CFArrayAppendValue(v5, v8);
            v11 = 1;
          }
        }
        else
        {
          v9 = 0;
          v8 = 0;
        }
      }
      while (!AMFDRDecodeManifestBodyNext(&v20, &v24, &v23, &numBytes_4, &numBytes));
      if ((v11 & 1) != 0)
        goto LABEL_23;
    }
    CFArrayAppendValue(v6, 0);
    CFArrayAppendValue(v5, 0);
LABEL_23:
    if (v10)
LABEL_24:
      CFRelease(v10);
    if (v9)
      CFRelease(v9);
    if (v8)
      CFRelease(v8);
  }
  return AMFDRDecodeManifestBodyDestroy(v20);
}

void ___getFDRSealingMapFromCache_block_invoke(uint64_t a1)
{
  const __CFDictionary *v2;
  uint64_t v3;
  const __CFDictionary *v4;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v6;
  const void *v7;
  const void *Value;
  const void *v9;
  CFTypeID v10;
  const void *v11;
  const void *v12;
  const void *v13;
  CFTypeID v14;
  CFTypeID v15;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  CFTypeID v18;
  const __CFDictionary *v19;

  v2 = (const __CFDictionary *)prunedSealingMapCache;
  if (prunedSealingMapCache
    || (v2 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]), (prunedSealingMapCache = (uint64_t)v2) != 0))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue(v2, *(const void **)(a1 + 40));
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      return;
    v3 = copyFDRSealingMapFromFilesystem();
    if (v3)
    {
      v4 = (const __CFDictionary *)v3;
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      if (!Mutable)
      {
        AMSupportLogInternal();
        v19 = v4;
        goto LABEL_20;
      }
      v6 = Mutable;
      v7 = *(const void **)(a1 + 40);
      Value = CFDictionaryGetValue(v4, v7);
      if (Value)
      {
        v9 = Value;
        CFDictionarySetValue(v6, v7, Value);
        v10 = CFGetTypeID(v9);
        if (v10 == CFStringGetTypeID())
        {
          v11 = CFDictionaryGetValue(v4, v9);
          if (v11)
            CFDictionarySetValue(v6, v9, v11);
        }
      }
      v12 = CFDictionaryGetValue(v4, CFSTR("ManifestProperties"));
      if (v12)
      {
        v13 = v12;
        v14 = CFGetTypeID(v12);
        if (v14 == CFArrayGetTypeID())
        {
          CFDictionarySetValue(v6, CFSTR("ManifestProperties"), v13);
        }
        else
        {
          v15 = CFGetTypeID(v13);
          if (v15 == CFDictionaryGetTypeID()
            && !_addSealingMapEntryKeyValueToCache(v6, v7, CFSTR("ManifestProperties"), (CFDictionaryRef)v13))
          {
            goto LABEL_23;
          }
        }
      }
      v16 = (const __CFDictionary *)CFDictionaryGetValue(v4, CFSTR("StoreMaxSize"));
      if (!v16
        || (v17 = v16, v18 = CFGetTypeID(v16), v18 != CFDictionaryGetTypeID())
        || (_addSealingMapEntryKeyValueToCache(v6, v7, CFSTR("StoreMaxSize"), v17) & 1) != 0)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)prunedSealingMapCache, *(const void **)(a1 + 40), v6);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v6;
LABEL_19:
        CFRelease(v4);
        v19 = v6;
LABEL_20:
        CFRelease(v19);
        return;
      }
LABEL_23:
      AMSupportLogInternal();
      goto LABEL_19;
    }
  }
  AMSupportLogInternal();
}

uint64_t _addSealingMapEntryKeyValueToCache(const __CFDictionary *a1, const void *a2, const void *a3, CFDictionaryRef theDict)
{
  const void *Value;
  const __CFDictionary *v8;
  __CFDictionary *v9;
  CFMutableDictionaryRef Mutable;

  Value = CFDictionaryGetValue(theDict, a2);
  v8 = (const __CFDictionary *)CFDictionaryGetValue(a1, a3);
  if (!Value)
    return 1;
  v9 = v8;
  if (v8)
  {
    if (!CFDictionaryContainsKey(v8, a2))
      CFDictionaryAddValue(v9, a2, Value);
    return 1;
  }
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  CFDictionarySetValue(a1, a3, Mutable);
  if (Mutable)
  {
    CFDictionaryAddValue(Mutable, a2, Value);
    CFRelease(Mutable);
    return 1;
  }
  AMSupportLogInternal();
  return 0;
}

uint64_t _AMFDRServiceSendSocketDict(int a1, const void *a2)
{
  const __CFData *Data;
  const __CFData *v4;
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v7;
  unsigned int v9;

  v9 = -1431655766;
  if (a1 == -1 || !a2)
  {
    AMSupportLogInternal();
    v7 = 0;
  }
  else
  {
    Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x24BDBD240], a2, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    v4 = Data;
    if (Data
      && (Length = CFDataGetLength(Data),
          BytePtr = CFDataGetBytePtr(v4),
          AMSupportLogInternal(),
          v9 = bswap32(Length),
          send(a1, &v9, 4uLL, 0) == 4)
      && send(a1, BytePtr, Length, 0) == Length)
    {
      v7 = 1;
    }
    else
    {
      AMSupportLogInternal();
      v7 = 0;
    }
  }
  AMSupportSafeRelease();
  return v7;
}

CFPropertyListRef _AMFDRServiceCopySocketDict(int a1)
{
  unint64_t i;
  unsigned int v3;
  size_t v4;
  const UInt8 *v5;
  size_t v6;
  const __CFAllocator *v7;
  const __CFData *v8;
  CFPropertyListRef v9;
  unsigned int v11;

  v11 = -1431655766;
  if (a1 == -1)
  {
    AMSupportLogInternal();
    v9 = 0;
  }
  else
  {
    for (i = 0; i < 4; i += read(a1, (char *)&v11 + i, 4 - i))
      ;
    v3 = v11;
    v4 = bswap32(v11);
    v5 = (const UInt8 *)malloc_type_malloc(v4, 0xDC64F391uLL);
    if (!v5)
      goto LABEL_13;
    if (v3)
    {
      v6 = 0;
      do
        v6 += read(a1, (void *)&v5[v6], v4 - v6);
      while (v6 < v4);
    }
    v7 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], v5, v4);
    if (v8)
    {
      v9 = CFPropertyListCreateWithData(v7, v8, 0, 0, 0);
      if (!v9)
        AMSupportLogInternal();
    }
    else
    {
LABEL_13:
      AMSupportLogInternal();
      v9 = 0;
    }
  }
  AMSupportSafeFree();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v9;
}

BOOL AMFDRServicePreflightRecoveryCopyData(const void *a1, const void *a2, _BOOL8 a3, const __CFDictionary *a4, CFTypeRef *a5)
{
  _BOOL8 v6;
  __CFDictionary *Mutable;
  __CFDictionary *v11;
  const void *Value;
  const __CFString *v13;
  const void *v14;
  const void *v15;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  const void *v18;
  const void *v19;
  const void *v20;

  if (!a1 || !a5)
    goto LABEL_24;
  v6 = a3;
  if (a3)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    v11 = Mutable;
    if (Mutable)
    {
      CFDictionaryAddValue(Mutable, CFSTR("command"), CFSTR("preflight"));
      CFDictionaryAddValue(v11, CFSTR("apTicket"), a1);
      if (a2)
        CFDictionaryAddValue(v11, CFSTR("fdrData"), a2);
      if (a4)
      {
        if (CFDictionaryGetValue(a4, CFSTR("EnableProxy")))
        {
          Value = CFDictionaryGetValue(a4, CFSTR("EnableProxy"));
          CFDictionaryAddValue(v11, CFSTR("EnableProxy"), Value);
          v13 = CFSTR("EnableProxySsl");
        }
        else
        {
          if (CFDictionaryGetValue(a4, CFSTR("UseSOCKSHost")))
          {
            v14 = CFDictionaryGetValue(a4, CFSTR("UseSOCKSHost"));
            CFDictionaryAddValue(v11, CFSTR("UseSOCKSHost"), v14);
          }
          v13 = CFSTR("UseSOCKSPort");
        }
        if (CFDictionaryGetValue(a4, v13))
        {
          v15 = CFDictionaryGetValue(a4, v13);
          CFDictionaryAddValue(v11, v13, v15);
        }
      }
      AMSupportLogInternal();
      if ((_AMFDRServiceSendSocketDict(v6, v11) & 1) != 0)
      {
        AMSupportSafeRelease();
        AMSupportLogInternal();
        v16 = (const __CFDictionary *)_AMFDRServiceCopySocketDict(v6);
        v17 = v16;
        if (v16)
        {
          v18 = CFDictionaryGetValue(v16, CFSTR("fdrData"));
          v19 = CFDictionaryGetValue(v17, CFSTR("result"));
          if (v19)
          {
            v20 = v19;
            if (CFDictionaryGetValue(v17, CFSTR("errorString")))
              AMSupportLogInternal();
            v6 = v20 == (const void *)*MEMORY[0x24BDBD270];
            if (v18)
              *a5 = CFRetain(v18);
            goto LABEL_22;
          }
        }
      }
    }
LABEL_24:
    AMSupportLogInternal();
    v6 = 0;
    goto LABEL_23;
  }
LABEL_22:
  AMSupportLogInternal();
LABEL_23:
  AMSupportSafeRelease();
  return v6;
}

void AMFDRHttpRequestPrintGlobalStatistics(const __CFAllocator *a1, CFArrayRef theArray, char a3)
{
  __CFArray *v4;
  uint64_t Count;
  CFIndex v7;
  CFStringRef v8;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v10;
  CFStringRef v11;
  const void *Value;
  CFStringRef v13;
  const void *v14;
  CFStringRef v15;
  const void *v16;
  CFStringRef v17;
  const void *v18;
  CFStringRef v19;
  const void *v20;
  const void *v21;
  const __CFString *v22;
  uint64_t v23;
  __CFArray *v24;
  CFRange v25;

  if (theArray)
  {
    v4 = theArray;
    Count = CFArrayGetCount(theArray);
    if ((a3 & 1) != 0)
    {
      v25.location = 0;
      v25.length = Count;
      CFArraySortValues(v4, v25, (CFComparatorFunction)_HttpRequestStatisticCompareFunction, 0);
    }
    AMSupportLogInternal();
    if (Count >= 1)
    {
      v7 = 0;
      v23 = Count;
      v24 = v4;
      v8 = &stru_24C6A3418;
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, v7);
        v10 = ValueAtIndex;
        v11 = &stru_24C6A3418;
        if ((a3 & 2) == 0)
        {
          Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("EpochTime"));
          v11 = CFStringCreateWithFormat(a1, 0, CFSTR(" epochtime=%@"), Value);
          if (!v11)
            break;
        }
        v13 = &stru_24C6A3418;
        if ((a3 & 4) != 0
          || (v14 = CFDictionaryGetValue(v10, CFSTR("Pid")),
              (v13 = CFStringCreateWithFormat(a1, 0, CFSTR(" pid=%@"), v14)) != 0))
        {
          v15 = &stru_24C6A3418;
          if ((a3 & 0x40) != 0
            && (v16 = CFDictionaryGetValue(v10, CFSTR("UUID")),
                (v15 = CFStringCreateWithFormat(a1, 0, CFSTR(" UUID=%@"), v16)) == 0))
          {
            AMSupportLogInternal();
            v22 = 0;
            v17 = &stru_24C6A3418;
          }
          else
          {
            v17 = &stru_24C6A3418;
            if ((a3 & 8) != 0
              || (v18 = CFDictionaryGetValue(v10, CFSTR("Process")),
                  (v17 = CFStringCreateWithFormat(a1, 0, CFSTR(" process=%@"), v18)) != 0))
            {
              v19 = &stru_24C6A3418;
              if (((a3 & 0x10) != 0
                 || (v20 = CFDictionaryGetValue(v10, CFSTR("Url")),
                     (v19 = CFStringCreateWithFormat(a1, 0, CFSTR(" url=%@"), v20)) != 0))
                && ((a3 & 0x20) != 0
                 || (v21 = CFDictionaryGetValue(v10, CFSTR("Tag")),
                     (v8 = CFStringCreateWithFormat(a1, 0, CFSTR(" tag=%@"), v21)) != 0)))
              {
                v22 = CFStringCreateWithFormat(a1, 0, CFSTR("%@%@%@%@%@%@"), v11, v15, v13, v17, v19, v8);
              }
              else
              {
                AMSupportLogInternal();
                v22 = 0;
              }
LABEL_19:
              CFRelease(v11);
              if (v13)
LABEL_20:
                CFRelease(v13);
              if (!v15)
                goto LABEL_23;
              goto LABEL_22;
            }
            AMSupportLogInternal();
            v22 = 0;
          }
          v19 = &stru_24C6A3418;
          goto LABEL_19;
        }
        AMSupportLogInternal();
        CFRelease(v11);
        v22 = 0;
        v15 = &stru_24C6A3418;
        v19 = &stru_24C6A3418;
        v17 = &stru_24C6A3418;
LABEL_22:
        CFRelease(v15);
LABEL_23:
        if (v17)
          CFRelease(v17);
        if (v19)
          CFRelease(v19);
        if (v8)
          CFRelease(v8);
        if (!v22)
          goto LABEL_41;
        if (CFStringGetLength(v22) >= 1)
          AMSupportLogInternal();
        CFRelease(v22);
        ++v7;
        v4 = v24;
        v8 = &stru_24C6A3418;
        if (v23 == v7)
          return;
      }
      AMSupportLogInternal();
      v22 = 0;
      v13 = &stru_24C6A3418;
      v15 = &stru_24C6A3418;
      v17 = &stru_24C6A3418;
      v19 = &stru_24C6A3418;
      goto LABEL_20;
    }
  }
  else
  {
LABEL_41:
    AMSupportLogInternal();
  }
}

CFComparisonResult _HttpRequestStatisticCompareFunction(const __CFDictionary *a1, const __CFDictionary *a2)
{
  const __CFNumber *Value;
  const __CFNumber *v4;

  Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("EpochTime"));
  v4 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("EpochTime"));
  if (!Value)
    return 1;
  if (v4)
    return CFNumberCompare(Value, v4, 0);
  return -1;
}

uint64_t AMFDRHttpRequestCopyGlobalStatistics(uint64_t a1)
{
  uint64_t v2;
  _QWORD context[3];

  context[2] = *MEMORY[0x24BDAC8D0];
  v2 = 0;
  context[0] = a1;
  context[1] = &v2;
  if (_AMFDRGetHttpRequestStatisticsQueue_onceToken != -1)
    dispatch_once(&_AMFDRGetHttpRequestStatisticsQueue_onceToken, &__block_literal_global_2);
  dispatch_sync_f((dispatch_queue_t)_AMFDRGetHttpRequestStatisticsQueue_queue, context, (dispatch_function_t)___thr_AMFDRHttpRequestCopyGlobalStatistics);
  return v2;
}

CFMutableArrayRef ___thr_AMFDRHttpRequestCopyGlobalStatistics(CFMutableArrayRef result)
{
  CFMutableArrayRef *v1;

  if (gHttpRequestStatisticsArray)
  {
    v1 = (CFMutableArrayRef *)*((_QWORD *)result + 1);
    result = CFArrayCreateMutableCopy(*(CFAllocatorRef *)result, 0, (CFArrayRef)gHttpRequestStatisticsArray);
    *v1 = result;
  }
  return result;
}

void AMFDRHttpRequestResetGlobalStatistics()
{
  if (_AMFDRGetHttpRequestStatisticsQueue_onceToken != -1)
    dispatch_once(&_AMFDRGetHttpRequestStatisticsQueue_onceToken, &__block_literal_global_2);
  dispatch_sync_f((dispatch_queue_t)_AMFDRGetHttpRequestStatisticsQueue_queue, 0, (dispatch_function_t)___thr_AMFDRHttpResetReleaseGlobalStatistics);
}

void ___thr_AMFDRHttpResetReleaseGlobalStatistics()
{
  if (gHttpRequestStatisticsArray)
  {
    CFRelease((CFTypeRef)gHttpRequestStatisticsArray);
    gHttpRequestStatisticsArray = 0;
  }
}

BOOL AMFDRLoadPersistent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v5;
  _QWORD context[6];

  context[5] = *MEMORY[0x24BDAC8D0];
  v5 = 0;
  if (a1 && a4 && a2 && a3)
  {
    context[0] = a1;
    context[1] = a2;
    context[2] = a3;
    context[3] = a4;
    context[4] = &v5;
    if (_AMFDRGetPersistentQueue_onceToken != -1)
      dispatch_once(&_AMFDRGetPersistentQueue_onceToken, &__block_literal_global_625);
    dispatch_sync_f((dispatch_queue_t)_AMFDRGetPersistentQueue_queue, context, (dispatch_function_t)___thr_AMFDRLoadPersistent);
    return v5 != 0;
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
}

void ___thr_AMFDRLoadPersistent(uint64_t a1)
{
  CFDictionaryRef *v1;
  CFTypeRef *v2;
  _BYTE *v3;
  CFTypeRef v4;
  const void *v5;

  v1 = *(CFDictionaryRef **)a1;
  v2 = *(CFTypeRef **)(a1 + 24);
  v3 = *(_BYTE **)(a1 + 32);
  v4 = _CopyPersistentDataPath(*(CFDictionaryRef **)a1, *(const void **)(a1 + 8));
  if (v4)
  {
    v5 = v4;
    CFGetAllocator(v1);
    if (AMSupportCreateDataFromFileURL() || !CFDataGetLength(0))
    {
      AMSupportLogInternal();
    }
    else
    {
      *v2 = CFRetain(0);
      *v3 = 1;
    }
    CFRelease(v5);
  }
  else
  {
    AMSupportLogInternal();
  }
}

uint64_t AMFDRDataHTTPLoadPersistent(CFDataRef *a1, CFTypeRef *a2)
{
  const __CFDictionary *v4;
  const __CFData *Value;
  _QWORD *v6;
  unsigned int (*v7)(CFDataRef *, CFTypeRef *, CFTypeRef *, CFDataRef);
  uint64_t v8;
  const __CFData *v9;
  CFDataRef *v10;
  CFDataRef v11;
  const __CFData *v12;
  CFDataRef v13;
  const __CFAllocator *v14;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFStringRef v17;
  CFDataRef v19;
  int v20;
  CFTypeRef v21;
  CFTypeRef v22;

  v21 = 0;
  v22 = 0;
  v20 = 0;
  v19 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPLoadPersistent", CFSTR("amfdr is NULL"), 0);
    goto LABEL_14;
  }
  if ((AMFDRDataGetSigningVersion((uint64_t)a1, &v20) & 1) == 0
    || v20 == 1
    && !AMFDRCryptoGetPrivateKey((uint64_t)a1)
    && ((v6 = a1[17], *v6 < 0x51uLL)
     || (v7 = (unsigned int (*)(CFDataRef *, CFTypeRef *, CFTypeRef *, CFDataRef))v6[10]) == 0
     || v7(a1, &v21, &v22, a1[18])))
  {
    AMSupportLogInternal();
LABEL_14:
    v8 = 0;
    goto LABEL_33;
  }
  if (!AMFDRCryptoGetCert((uint64_t)a1) && AMFDRShouldPersistData((uint64_t)a1, CFSTR("PersistCertificate")))
  {
    v4 = a1[10];
    if (v4)
    {
      Value = (const __CFData *)CFDictionaryGetValue(v4, CFSTR("certificate"));
      a1[4] = Value;
      AMSupportSafeRetain();
      if (!Value)
        goto LABEL_20;
    }
    else if (!AMFDRLoadPersistent((uint64_t)a1, (uint64_t)CFSTR("CertificateFile"), (uint64_t)CFSTR("certificate"), (uint64_t)(a1 + 4)))
    {
      goto LABEL_20;
    }
    v10 = a1 + 4;
    v9 = a1[4];
    if (!v9 || !CFDataGetLength(v9))
    {
LABEL_20:
      AMSupportLogInternal();
      v10 = a1 + 4;
      v11 = a1[4];
      if (!v11)
        goto LABEL_22;
      goto LABEL_21;
    }
    CFDataGetBytePtr(*v10);
    CFDataGetLength(*v10);
    AMSupportRsaCreateDataFromPem();
    AMSupportLogInternal();
    v11 = *v10;
    if (*v10)
    {
LABEL_21:
      CFRelease(v11);
      *v10 = 0;
    }
  }
LABEL_22:
  v12 = a1[4];
  if ((!v12 || !CFDataGetLength(v12)) && (AMFDRPermissionsRequest((uint64_t)a1, a2) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a2, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPLoadPersistent", CFSTR("Permissions request failed."), 0);
    goto LABEL_14;
  }
  if (AMFDROptionsGetBooleanValue((uint64_t)a1, CFSTR("EnableCookie"), 0)
    && !a1[3]
    && AMFDRShouldPersistData((uint64_t)a1, CFSTR("PersistCookie"))
    && AMFDRLoadPersistent((uint64_t)a1, (uint64_t)CFSTR("CookieFile"), (uint64_t)CFSTR("cookie"), (uint64_t)&v19))
  {
    v13 = a1[3];
    if (v13)
    {
      CFRelease(v13);
      a1[3] = 0;
    }
    v14 = CFGetAllocator(a1);
    BytePtr = CFDataGetBytePtr(v19);
    Length = CFDataGetLength(v19);
    v17 = CFStringCreateWithBytes(v14, BytePtr, Length, 0x8000100u, 0);
    a1[3] = (CFDataRef)v17;
    if (!v17)
    {
      AMFDRErrorPushInternal((uint64_t)a2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPLoadPersistent", CFSTR("failed to convert amfdr->cookieStr"), 0);
      goto LABEL_14;
    }
  }
  v8 = 1;
LABEL_33:
  if (v19)
  {
    CFRelease(v19);
    v19 = 0;
  }
  if (v21)
  {
    CFRelease(v21);
    v21 = 0;
  }
  if (v22)
  {
    CFRelease(v22);
    v22 = 0;
  }
  return v8;
}

BOOL AMFDRShouldPersistData(uint64_t a1, const void *a2)
{
  uint64_t v2;
  const __CFBoolean *Value;
  const __CFBoolean *v4;
  CFTypeID v5;

  if (a1)
    v2 = (*(unsigned __int8 *)(*(_QWORD *)(a1 + 136) + 8) >> 2) & 1;
  else
    v2 = 0;
  Value = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  if (Value)
  {
    v4 = Value;
    v5 = CFGetTypeID(Value);
    if (v5 == CFBooleanGetTypeID())
      return CFBooleanGetValue(v4) == 1;
  }
  return v2;
}

uint64_t AMFDRPermissionsRequest(uint64_t a1, CFTypeRef *a2)
{
  const __CFDictionary *v4;
  const __CFString *Value;
  const __CFString *v6;
  __CFString *v7;
  const __CFData *Csr;
  const __CFData *v9;
  const __CFString *v11;
  const __CFString *v12;
  char v13;
  char v14;

  if (!a1)
  {
    v11 = CFSTR("amfdr is NULL");
LABEL_22:
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRPermissionsRequest", v11, v13);
    return 0;
  }
  v4 = *(const __CFDictionary **)(a1 + 16);
  if (!v4)
  {
    v11 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_22;
  }
  *(_BYTE *)(a1 + 41) = 0;
  Value = (const __CFString *)CFDictionaryGetValue(v4, CFSTR("Permissions"));
  if (!Value)
  {
    v11 = CFSTR("permsStr is NULL. kAMFDROptionPermissions required in options.");
    goto LABEL_22;
  }
  v6 = Value;
  if (a2 && *a2)
  {
    CFRelease(*a2);
    *a2 = 0;
  }
  if (*(_QWORD *)(a1 + 16))
  {
    v7 = _AMFDRCreateUrlWithKey(a1, CFSTR("CAURL"), (uint64_t)CFSTR("ca/authorize"), 0, 0);
    if (v7)
    {
      Csr = AMFDRCryptoCreateCsr(a1, v6);
      v9 = Csr;
      if (!Csr)
      {
        v12 = CFSTR("Unable to create CSR");
        goto LABEL_27;
      }
      CFDataGetBytePtr(Csr);
      CFDataGetLength(v9);
      if (!AMSupportRsaCreateDataFromPem())
      {
        v12 = CFSTR("Unable to create DER CSR (csrDER is NULL)");
LABEL_27:
        AMFDRErrorPushInternal((uint64_t)a2, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRPermissionsRequestWithString", v12, v13);
        goto LABEL_28;
      }
      AMFDRErrorPushInternal((uint64_t)a2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRPermissionsRequestWithString", CFSTR("Unable to create CSR"), v13);
    }
    else
    {
      AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRPermissionsRequestWithString", CFSTR("serverURL is NULL"), v13);
      v9 = 0;
    }
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRPermissionsRequestWithString", CFSTR("amfdr->optionsDict is NULL"), v13);
    v9 = 0;
    v7 = 0;
  }
LABEL_28:
  AMFDRSetStat((CFMutableDictionaryRef *)a1, CFSTR("FDRCAFail"), 1);
  if (v7)
    CFRelease(v7);
  if (v9)
    CFRelease(v9);
  if (AMFDRGetUnderlyingErrorCode(a1, (CFErrorRef *)a2) == 403)
    *(_BYTE *)(a1 + 41) = 1;
  AMFDRErrorPushInternal((uint64_t)a2, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRPermissionsRequest", CFSTR("_AMFDRSavePersistentData failed"), v14);
  return 0;
}

BOOL _AMFDRSavePersistent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v5;
  _QWORD context[6];

  context[5] = *MEMORY[0x24BDAC8D0];
  v5 = 0;
  if (!a4)
    return 0;
  context[0] = a1;
  context[1] = a2;
  context[2] = a3;
  context[3] = a4;
  context[4] = &v5;
  if (_AMFDRGetPersistentQueue_onceToken != -1)
    dispatch_once(&_AMFDRGetPersistentQueue_onceToken, &__block_literal_global_625);
  dispatch_sync_f((dispatch_queue_t)_AMFDRGetPersistentQueue_queue, context, (dispatch_function_t)___thr_AMFDRSavePersistent);
  return v5 != 0;
}

uint64_t _AMFDRSupportBase64Encode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (!a2)
    goto LABEL_7;
  v3 = a3;
  if (a3)
  {
    AMSupportBase64Encode();
LABEL_7:
    AMSupportLogInternal();
    return 0;
  }
  AMSupportLogInternal();
  return v3;
}

uint64_t AMFDRSupportBase64Decode(const __CFAllocator *a1, CFStringRef theString, uint64_t a3)
{
  uint64_t v3;
  const __CFString *MutableCopy;
  __CFString *v5;
  CFRange v7;
  CFRange v8;

  if (!theString)
    goto LABEL_8;
  v3 = a3;
  if (!a3)
  {
    AMSupportLogInternal();
    return v3;
  }
  MutableCopy = CFStringCreateMutableCopy(a1, 0, theString);
  if (!MutableCopy)
  {
LABEL_8:
    AMSupportLogInternal();
    return 0;
  }
  v5 = (__CFString *)MutableCopy;
  v7.length = CFStringGetLength(MutableCopy);
  v7.location = 0;
  CFStringFindAndReplace(v5, CFSTR("-"), CFSTR("+"), v7, 0);
  v8.length = CFStringGetLength(v5);
  v8.location = 0;
  CFStringFindAndReplace(v5, CFSTR("_"), CFSTR("/"), v8, 0);
  AMSupportBase64Decode();
  AMSupportLogInternal();
  v3 = 0;
  CFRelease(v5);
  return v3;
}

uint64_t AMFDROfflineBlobCreate(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t SikPub;
  uint64_t v9;
  const __CFAllocator *v10;
  const __CFString *v11;
  const __CFData *Csr;
  const __CFData *v13;
  const __CFString *v15;
  const __CFString *v16;
  char v17;
  _BYTE v18[12];
  CFIndex length;
  uint64_t v20;

  v20 = 0;
  length = 0;
  memset(v18, 0, sizeof(v18));
  if (!a1)
  {
    v15 = CFSTR("amfdr is NULL");
LABEL_14:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobCreate", v15, v17);
    return 0;
  }
  if (!a1[2])
  {
    v15 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_14;
  }
  if (!a2)
  {
    v15 = CFSTR("dataClass is NULL");
    goto LABEL_14;
  }
  if (!a3)
  {
    v15 = CFSTR("dataInstance is NULL");
    goto LABEL_14;
  }
  SikPub = AMFDRCryptoGetSikPub((uint64_t)a1);
  if (!SikPub)
  {
    v16 = CFSTR("Unable to get sik");
LABEL_18:
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobCreate", v16, v17);
    return 0;
  }
  v9 = SikPub;
  v10 = CFGetAllocator(a1);
  v11 = CFStringCreateWithFormat(v10, 0, CFSTR("PUT/%@:sik-%@-%@"), a2, a3, v9);
  if (!v11)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobCreate", CFSTR("permsStr is NULL"), v17);
    return 0;
  }
  Csr = AMFDRCryptoCreateCsr((uint64_t)a1, v11);
  if (!Csr)
  {
    v16 = CFSTR("Unable to create CSR");
    goto LABEL_18;
  }
  v13 = Csr;
  CFDataGetBytePtr(Csr);
  CFDataGetLength(v13);
  if (AMSupportRsaCreateDataFromPem())
    AMFDRErrorPushInternal(a4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobCreate", CFSTR("Unable to create CSR"), v17);
  else
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobCreate", CFSTR("Unable to create DER CSR (csrDER is NULL)"), v17);
  CFRelease(v13);
  return 0;
}

CFDataRef _CopyDevRefKeySignature(const void *a1, CFDataRef theData, uint64_t a3)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  CFDataRef v8;
  const __CFString *v10;
  const __CFString *v11;
  CFIndex v12;
  UInt8 *v13;

  v12 = 0;
  v13 = 0;
  if (!a1)
  {
    v10 = CFSTR("amfdr is NULL");
LABEL_13:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_CopyDevRefKeySignature", v10, v12);
    goto LABEL_18;
  }
  if (!theData)
  {
    v10 = CFSTR("csrData is NULL");
    goto LABEL_13;
  }
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (!Length)
  {
    v11 = CFSTR("csrData byte length is 0");
LABEL_17:
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_CopyDevRefKeySignature", v11, v12);
    goto LABEL_18;
  }
  if (AMFDRCryptoCreateDataSignature(66050, (uint64_t)BytePtr, Length, (void **)&v13, &v12, a1) == 100)
  {
    if (v13)
    {
      if (v12)
      {
        v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], v13, v12);
        goto LABEL_8;
      }
      v11 = CFSTR("sig_len is 0");
      goto LABEL_17;
    }
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_CopyDevRefKeySignature", CFSTR("sig byte pointer is NULL"), v12);
  }
LABEL_18:
  v8 = 0;
LABEL_8:
  if (v13)
    free(v13);
  return v8;
}

CFDataRef AMFDROfflineBlobVerify(uint64_t a1, const __CFData *a2, uint64_t a3)
{
  __CFString *v6;
  const __CFURL *v7;
  const UInt8 *BytePtr;
  unsigned int v9;
  const __CFAllocator *v10;
  const __CFData *v11;
  const __CFAllocator *v12;
  CFDataRef v13;
  const __CFAllocator *v14;
  CFDataRef v15;
  CFAllocatorRef v16;
  CFAllocatorRef v17;
  _QWORD *v18;
  uint64_t (*v19)(uint64_t, _QWORD);
  uint64_t v20;
  void *v21;
  const __CFString *SikInstanceStringInternal;
  const __CFString *v23;
  CFDictionaryRef v24;
  const __CFAllocator *v25;
  CFDataRef v26;
  const __CFString *v27;
  CFDataRef v28;
  const __CFString *v30;
  const __CFString *v31;
  const __CFString *v32;
  char v33;
  _DWORD v34[4];
  _DWORD v35[4];
  _DWORD length[3];
  uint64_t v37;
  CFTypeRef v38;
  CFTypeRef cf;
  CFDataRef theData;
  void *values[5];
  _OWORD keys[2];
  const __CFString *v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  cf = 0;
  theData = 0;
  v37 = -1;
  v38 = 0;
  memset(length, 0, sizeof(length));
  *(_QWORD *)&v35[1] = 0;
  v35[0] = 0;
  *(_QWORD *)&v34[1] = 0;
  v34[0] = 0;
  if (!a1)
  {
    v31 = CFSTR("amfdr is NULL");
LABEL_51:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobVerify", v31, v33);
    AMFDRSetStat((CFMutableDictionaryRef *)a1, CFSTR("FDRCAFail"), 1);
    v24 = 0;
    v23 = 0;
    v21 = 0;
    v28 = 0;
    goto LABEL_33;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v31 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_51;
  }
  if (!a2)
  {
    v31 = CFSTR("offlineBlob is NULL");
    goto LABEL_51;
  }
  v6 = _AMFDRCreateUrlWithKey(a1, CFSTR("CAURL"), (uint64_t)CFSTR("ca/authorize"), 0, 0);
  if (!v6)
  {
    v31 = CFSTR("serverURL is NULL");
    goto LABEL_51;
  }
  v7 = (const __CFURL *)v6;
  BytePtr = CFDataGetBytePtr(a2);
  v9 = CFDataGetLength(a2);
  if (AMFDRDecodeOfflineBlob((uint64_t)BytePtr, v9, &length[1], length, &v35[1], v35, &v34[1], v34))
  {
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobVerify", CFSTR("AMFDRDecodeOfflineBlob failed"), v33);
    v11 = 0;
LABEL_54:
    v13 = 0;
LABEL_56:
    v15 = 0;
LABEL_59:
    v21 = 0;
    v23 = 0;
    v24 = 0;
    goto LABEL_60;
  }
  v10 = CFGetAllocator((CFTypeRef)a1);
  v11 = CFDataCreate(v10, *(const UInt8 **)&length[1], length[0]);
  if (!v11)
  {
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobVerify", CFSTR("Unable to create csrDERData"), v33);
    goto LABEL_54;
  }
  v12 = CFGetAllocator((CFTypeRef)a1);
  v13 = CFDataCreate(v12, *(const UInt8 **)&v35[1], v35[0]);
  if (!v13)
  {
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobVerify", CFSTR("Unable to create csrSigData"), v33);
    goto LABEL_56;
  }
  v14 = CFGetAllocator((CFTypeRef)a1);
  v15 = CFDataCreate(v14, *(const UInt8 **)&v34[1], v34[0]);
  if (!v15)
  {
    v30 = CFSTR("Unable to create attestationData");
    goto LABEL_58;
  }
  v16 = CFGetAllocator((CFTypeRef)a1);
  if ((_AMFDRSupportBase64Encode((uint64_t)v16, (uint64_t)v13, (uint64_t)&cf) & 1) == 0)
    goto LABEL_46;
  if (!cf)
  {
    v27 = CFSTR("base64CsrGidSignature is NULL");
    goto LABEL_25;
  }
  v17 = CFGetAllocator((CFTypeRef)a1);
  if ((_AMFDRSupportBase64Encode((uint64_t)v17, (uint64_t)v15, (uint64_t)&v38) & 1) == 0)
  {
LABEL_46:
    v30 = CFSTR("_AMFDRSupportBase64Encode failed");
LABEL_58:
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobVerify", v30, v33);
    goto LABEL_59;
  }
  if (!v38)
  {
    v27 = CFSTR("base64Attestation is NULL");
    goto LABEL_25;
  }
  v18 = *(_QWORD **)(a1 + 136);
  if (*v18 < 0x59uLL
    || (v19 = (uint64_t (*)(uint64_t, _QWORD))v18[11]) == 0
    || (v20 = v19(a1, *(_QWORD *)(a1 + 144))) == 0)
  {
    v27 = CFSTR("clientId is NULL");
LABEL_25:
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobVerify", v27, v33);
    v24 = 0;
    v23 = 0;
    v21 = 0;
    goto LABEL_26;
  }
  v21 = (void *)v20;
  SikInstanceStringInternal = AMFDRDataCreateSikInstanceStringInternal((__CFString *)a1, 0, v20);
  v23 = SikInstanceStringInternal;
  if (SikInstanceStringInternal)
  {
    keys[0] = xmmword_24C69F468;
    keys[1] = *(_OWORD *)off_24C69F478;
    v43 = CFSTR("x-fdr-device-certificate-version");
    values[0] = (void *)cf;
    values[1] = (void *)v38;
    values[2] = v21;
    values[3] = (void *)SikInstanceStringInternal;
    values[4] = CFSTR("2");
    v24 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], (const void **)keys, (const void **)values, 5, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (!v24)
    {
      v32 = CFSTR("Unable to create HTTP header extension dictionary");
LABEL_70:
      AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobVerify", v32, v33);
      goto LABEL_26;
    }
    if ((_AMFDRHttpRequestSendSyncNoRetry(a1, v7, (uint64_t)CFSTR("OfflineBlobVerify"), CFSTR("POST"), CFSTR("application/x-pem-file"), v24, v11, (CFTypeRef *)&theData, 0, 1, 0, 0, &v37, a3) & 1) != 0)
    {
      if (theData)
      {
        if (v37 <= 0)
        {
          v32 = CFSTR("httpStatus is negative");
        }
        else
        {
          CFDataGetBytePtr(theData);
          CFDataGetLength(theData);
          if (!AMSupportRsaCreateDataFromPem())
          {
            v25 = CFGetAllocator((CFTypeRef)a1);
            v26 = CFDataCreate(v25, 0, 0);
            if (!v26)
              AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobVerify", CFSTR("Unable to create outCert"), v33);
            goto LABEL_27;
          }
          v32 = CFSTR("failed to convert certificate");
        }
      }
      else
      {
        v32 = CFSTR("signedCert is NULL");
      }
      goto LABEL_70;
    }
    AMFDRErrorPushInternal(a3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobVerify", CFSTR("AMFDRPermissionsRequest failed"), v33);
LABEL_60:
    AMFDRSetStat((CFMutableDictionaryRef *)a1, CFSTR("FDRCAFail"), 1);
    CFRelease(v7);
    v26 = 0;
    v28 = 0;
    if (!v11)
      goto LABEL_29;
    goto LABEL_28;
  }
  AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDROfflineBlobVerify", CFSTR("clientIdSik is NULL"), v33);
  v24 = 0;
LABEL_26:
  v26 = 0;
LABEL_27:
  CFRelease(v7);
LABEL_28:
  CFRelease(v11);
  v28 = v26;
LABEL_29:
  if (v13)
    CFRelease(v13);
  if (v15)
    CFRelease(v15);
LABEL_33:
  if (theData)
  {
    CFRelease(theData);
    theData = 0;
  }
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v38)
  {
    CFRelease(v38);
    v38 = 0;
  }
  if (v21)
    CFRelease(v21);
  if (v23)
    CFRelease(v23);
  if (v24)
    CFRelease(v24);
  return v28;
}

__CFString *_AMFDRCreateUrlWithKey(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
  __CFString *v5;
  const void *Value;
  const void *v10;
  const __CFString *InstanceString;
  const __CFString *v12;
  const __CFAllocator *v13;
  const __CFAllocator *v15;
  const __CFString *v16;

  v5 = (__CFString *)a1;
  if (!a1)
  {
    AMSupportLogInternal();
    return v5;
  }
  if (!a2)
    goto LABEL_14;
  if (!a3)
    goto LABEL_14;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  if (!Value)
    goto LABEL_14;
  v10 = Value;
  if (a4)
  {
    if (a5)
    {
      InstanceString = AMFDRDataCreateInstanceString(v5, a4, a5);
      if (InstanceString)
      {
        v12 = InstanceString;
        CFGetAllocator(v5);
        AMSupportHttpUriEscapeString();
        AMSupportLogInternal();
        v5 = 0;
        CFRelease(v12);
        return v5;
      }
    }
LABEL_14:
    AMSupportLogInternal();
    return 0;
  }
  v15 = CFGetAllocator(v5);
  v16 = CFStringCreateWithFormat(v15, 0, CFSTR("%@/%@"), v10, a3);
  if (!v16)
    goto LABEL_14;
  v13 = CFGetAllocator(v5);
  v5 = (__CFString *)CFURLCreateWithString(v13, v16, 0);
  if (!v5)
    AMSupportLogInternal();
  CFRelease(v16);
  return v5;
}

uint64_t _AMFDRHttpRequestSendSyncNoRetry(uint64_t cf, const __CFURL *a2, uint64_t a3, __CFString *a4, const __CFString *a5, const void *a6, const __CFData *a7, CFTypeRef *a8, CFTypeRef *a9, char a10, uint64_t a11, char a12, uint64_t *a13, uint64_t a14)
{
  const __CFURL *v15;
  __CFString *v16;
  const __CFString *v17;
  const __CFAllocator *v21;
  __CFHTTPMessage *Request;
  const __CFAllocator *v23;
  CFIndex Length;
  const __CFString *v25;
  const __CFAllocator *v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *Value;
  const __CFString *v30;
  const __CFDictionary *v31;
  const __CFDictionary *v32;
  CFTypeID v33;
  const __CFDictionary *v34;
  const __CFDictionary *v35;
  CFTypeID v36;
  CFTypeID v37;
  SInt32 v38;
  unsigned int v39;
  const __CFDictionary *v40;
  const __CFNumber *v41;
  const __CFNumber *v42;
  CFTypeID v43;
  uint64_t (*v44)(uint64_t, __CFHTTPMessage *, CFDictionaryRef *, CFTypeRef *, uint64_t *, void (*)(CFDataRef, CFTypeRef *, CFTypeRef *, int *), uint64_t);
  const void *v45;
  const void *v46;
  const void *v47;
  CFIndex v48;
  uint64_t v49;
  const __CFString *v51;
  const __CFString *v52;
  char v53;
  _QWORD v55[2];
  uint64_t v56;
  unint64_t v57;
  const __CFString *v58;
  CFDictionaryRef theDict;
  CFTypeRef cfa;
  uint64_t v61;
  _QWORD context[6];

  context[4] = *MEMORY[0x24BDAC8D0];
  theDict = 0;
  cfa = 0;
  v57 = 0xAAAAAAAAAAAAAAAALL;
  v58 = (const __CFString *)0xAAAAAAAAAAAAAAAALL;
  v55[1] = a11;
  v56 = -1;
  v55[0] = 0xAAAAAAAAAAAAAAAALL;
  LOBYTE(v55[0]) = a10;
  if (!cf)
  {
    v52 = CFSTR("amfdr is NULL");
LABEL_77:
    AMFDRErrorPushInternal(a14, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", v52, v53);
    v49 = 0;
    v16 = 0;
LABEL_83:
    v17 = 0;
    goto LABEL_84;
  }
  if (!*(_QWORD *)(cf + 16))
  {
    v52 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_77;
  }
  v15 = a2;
  if (!a2)
  {
    AMFDRErrorPushInternal(a14, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", CFSTR("serverURL is NULL"), v53);
    v49 = 0;
    v16 = 0;
    v17 = 0;
LABEL_85:
    v27 = 0;
LABEL_86:
    v28 = 0;
    goto LABEL_59;
  }
  v16 = a4;
  if (!a4)
  {
    AMFDRErrorPushInternal(a14, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", CFSTR("action is NULL"), v53);
LABEL_82:
    v49 = 0;
    goto LABEL_83;
  }
  v17 = a5;
  if (!a5)
  {
    AMFDRErrorPushInternal(a14, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", CFSTR("contentType is NULL"), v53);
    v49 = 0;
    v16 = 0;
LABEL_84:
    v15 = 0;
    goto LABEL_85;
  }
  if (a3)
  {
    v61 = -1;
    context[0] = CFGetAllocator((CFTypeRef)cf);
    context[1] = v15;
    context[2] = a3;
    context[3] = &v61;
    if (_AMFDRGetHttpRequestStatisticsQueue_onceToken != -1)
      dispatch_once(&_AMFDRGetHttpRequestStatisticsQueue_onceToken, &__block_literal_global_2);
    dispatch_sync_f((dispatch_queue_t)_AMFDRGetHttpRequestStatisticsQueue_queue, context, (dispatch_function_t)___thr_AMFDRHttpRequestStatisticsRecord);
  }
  v21 = CFGetAllocator((CFTypeRef)cf);
  Request = CFHTTPMessageCreateRequest(v21, v16, v15, (CFStringRef)*MEMORY[0x24BDB7698]);
  v16 = (__CFString *)Request;
  if (!Request)
  {
    AMFDRErrorPushInternal(a14, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", CFSTR("httpRequest allocation failed"), v53);
    goto LABEL_82;
  }
  CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("Content-Type"), v17);
  v23 = CFGetAllocator((CFTypeRef)cf);
  if (a7)
    Length = CFDataGetLength(a7);
  else
    Length = 0;
  v17 = CFStringCreateWithFormat(v23, 0, CFSTR("%lu"), Length);
  if (!v17)
  {
    AMFDRErrorPushInternal(a14, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", CFSTR("contentLengthStr allocation failed"), v53);
    v49 = 0;
    goto LABEL_84;
  }
  CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v16, CFSTR("Content-Length"), v17);
  if (AMFDROptionsGetBooleanValue(cf, CFSTR("EnableCookie"), 0))
  {
    v25 = *(const __CFString **)(cf + 24);
    if (v25)
      CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v16, CFSTR("Cookie"), v25);
    else
      AMSupportLogInternal();
  }
  v15 = (const __CFURL *)AMFDRCopyClientId(cf);
  if (!v15)
  {
    AMFDRErrorPushInternal(a14, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", CFSTR("clientId not found in optionsDict"), v53);
    v49 = 0;
    goto LABEL_85;
  }
  CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v16, CFSTR("x-fdr-client-id"), (CFStringRef)v15);
  v26 = CFGetAllocator((CFTypeRef)cf);
  v27 = CFStringCreateWithFormat(v26, 0, CFSTR("%d"), 2);
  if (!v27)
  {
    AMFDRErrorPushInternal(a14, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", CFSTR("clientVersion is NULL"), v53);
    v49 = 0;
    goto LABEL_86;
  }
  CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v16, CFSTR("x-fdr-client-version"), v27);
  v28 = AMFDRCopyLibraryVersionString();
  CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v16, CFSTR("x-fdr-libFDR-tag"), v28);
  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("HardwareModel"));
  if (_AMFDRHttpRequestSendSyncNoRetry_onceToken != -1)
    dispatch_once(&_AMFDRHttpRequestSendSyncNoRetry_onceToken, &__block_literal_global_676);
  if (Value)
    v30 = Value;
  else
    v30 = (const __CFString *)_AMFDRHttpRequestSendSyncNoRetry_hardwareModel;
  CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v16, CFSTR("x-fdr-hardware-model"), v30);
  v57 = (unint64_t)v16;
  v58 = CFSTR("x-fdr-metadata-");
  v31 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("Metadata"));
  if (v31)
  {
    v32 = v31;
    v33 = CFGetTypeID(v31);
    if (v33 != CFDictionaryGetTypeID())
      goto LABEL_74;
    CFDictionaryApplyFunction(v32, (CFDictionaryApplierFunction)_InsertHeader, &v57);
  }
  v57 = (unint64_t)v16;
  v58 = CFSTR("x-fdr-user-metadata-");
  v34 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("UserMetadata"));
  if (!v34)
    goto LABEL_32;
  v35 = v34;
  v36 = CFGetTypeID(v34);
  if (v36 != CFDictionaryGetTypeID())
  {
LABEL_74:
    v51 = CFSTR("metadataDict is of incorrect type");
LABEL_93:
    AMFDRErrorPushInternal(a14, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", v51, v53);
    v49 = 0;
    goto LABEL_59;
  }
  CFDictionaryApplyFunction(v35, (CFDictionaryApplierFunction)_InsertHeader, &v57);
LABEL_32:
  v58 = &stru_24C6A3418;
  if (!a6)
    goto LABEL_35;
  v37 = CFGetTypeID(a6);
  if (v37 != CFDictionaryGetTypeID())
  {
    v51 = CFSTR("httpExtHeaders is of incorrect type");
    goto LABEL_93;
  }
  CFDictionaryApplyFunction((CFDictionaryRef)a6, (CFDictionaryApplierFunction)_InsertHeader, &v57);
LABEL_35:
  CFHTTPMessageSetBody((CFHTTPMessageRef)v16, a7);
  v38 = _AMFDRGetHttpTimeout(cf);
  v39 = 3;
  LODWORD(context[0]) = 3;
  v40 = *(const __CFDictionary **)(cf + 16);
  if (v40)
  {
    v41 = (const __CFNumber *)CFDictionaryGetValue(v40, CFSTR("HTTPMaxAttempts"));
    if (!v41
      || (v42 = v41, v43 = CFGetTypeID(v41), v43 != CFNumberGetTypeID())
      || (v39 = 3, CFNumberGetValue(v42, kCFNumberSInt32Type, context)) && (v39 = context[0]) == 0)
    {
      v39 = 3;
    }
  }
  v44 = _AMFDRHttpAuthenticationCallback;
  if (!a12)
    v44 = 0;
  if ((_AMFDRHttpMessageSendSync((CFDictionaryRef *)cf, (CFHTTPMessageRef)v16, &cfa, (CFTypeRef *)&theDict, &v56, v38, v39, (uint64_t (*)(CFDictionaryRef *, __CFHTTPMessage *, __CFDictionary *, uint64_t, uint64_t))_AMFDRHttpMessagePreAction, (uint64_t (*)(CFDictionaryRef *, CFHTTPMessageRef, CFDictionaryRef *, CFTypeRef *, uint64_t *, _QWORD, CFErrorRef *))v44, (uint64_t)v55, a14) & 1) != 0)
  {
    if (theDict)
    {
      if (AMFDROptionsGetBooleanValue(cf, CFSTR("EnableCookie"), 0))
      {
        v45 = CFDictionaryGetValue(theDict, CFSTR("Set-Cookie"));
        if (v45)
        {
          v46 = v45;
          v47 = *(const void **)(cf + 24);
          if (v47)
          {
            CFRelease(v47);
            *(_QWORD *)(cf + 24) = 0;
          }
          *(_QWORD *)(cf + 24) = CFRetain(v46);
        }
      }
      if (a8 && cfa)
        *a8 = CFRetain(cfa);
      if (a9)
        *a9 = CFRetain(theDict);
      v48 = v56;
      *a13 = v56;
      if ((v48 & 0xFFFFFFFFFFFFFFFDLL) == 0xC8)
      {
        v49 = 1;
        goto LABEL_59;
      }
      _AMFDRHttpHandleHeaderMessage((CFMutableDictionaryRef *)cf, theDict, v48, (const __CFData *)cfa, a14);
    }
    else
    {
      AMFDRErrorPushInternal(a14, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", CFSTR("httpResponseHeader is NULL"), v53);
    }
  }
  else
  {
    AMFDRErrorPushInternal(a14, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSyncNoRetry", CFSTR("_AMFDRHttpMessageSendSync failed"), v53);
  }
  v49 = 0;
LABEL_59:
  if (cfa)
  {
    CFRelease(cfa);
    cfa = 0;
  }
  if (theDict)
  {
    CFRelease(theDict);
    theDict = 0;
  }
  if (v16)
    CFRelease(v16);
  if (v17)
    CFRelease(v17);
  if (v15)
    CFRelease(v15);
  if (v27)
    CFRelease(v27);
  if (v28)
    CFRelease(v28);
  return v49;
}

BOOL AMFDRDecomposePermissionString(const __CFAllocator *a1, const __CFString *a2, CFTypeRef *a3, CFTypeRef *a4, CFTypeRef *a5)
{
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v14;
  CFMutableArrayRef v15;
  BOOL v16;
  CFIndex v17;
  const __CFString *ValueAtIndex;
  const __CFArray *v19;
  const __CFArray *v20;
  const __CFArray *v21;
  const void *v22;
  const __CFString *v23;
  const __CFArray *v24;
  const __CFArray *v25;
  CFIndex v26;
  CFIndex v27;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  __CFArray *v31;
  CFTypeRef *v33;
  CFTypeRef *v34;
  CFTypeRef *v35;
  __CFArray *v36;
  __CFArray *v37;
  __CFArray *theArray;

  if (!a2 || (ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, a2, CFSTR(";"))) == 0)
  {
    AMSupportLogInternal();
    return 0;
  }
  v10 = ArrayBySeparatingStrings;
  Count = CFArrayGetCount(ArrayBySeparatingStrings);
  if (Count <= 0)
  {
    AMSupportLogInternal();
    v31 = 0;
    v14 = 0;
    Mutable = 0;
  }
  else
  {
    v12 = Count;
    Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x24BDBD690]);
    if (Mutable)
    {
      v14 = CFArrayCreateMutable(a1, 0, MEMORY[0x24BDBD690]);
      if (v14)
      {
        v15 = CFArrayCreateMutable(a1, 0, MEMORY[0x24BDBD690]);
        if (v15)
        {
          v33 = a3;
          v34 = a4;
          v35 = a5;
          v36 = v15;
          v37 = v14;
          theArray = Mutable;
          v16 = 0;
          v17 = 0;
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v17);
            v19 = CFStringCreateArrayBySeparatingStrings(a1, ValueAtIndex, CFSTR("/"));
            if (!v19)
            {
              AMSupportLogInternal();
              v14 = v37;
              Mutable = theArray;
              v31 = v36;
              goto LABEL_23;
            }
            v20 = v19;
            if (CFArrayGetCount(v19) <= 1)
            {
              AMSupportLogInternal();
              v25 = 0;
              goto LABEL_34;
            }
            v21 = v10;
            v22 = CFArrayGetValueAtIndex(v20, 0);
            v23 = (const __CFString *)CFArrayGetValueAtIndex(v20, 1);
            v24 = CFStringCreateArrayBySeparatingStrings(a1, v23, CFSTR(":"));
            v25 = v24;
            if (!v24)
              break;
            v26 = CFArrayGetCount(v24);
            if ((unint64_t)(v26 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
              break;
            v27 = v26;
            v28 = (const __CFString *)CFArrayGetValueAtIndex(v25, 0);
            v29 = v28;
            if (v27 == 1)
            {
              v30 = CFSTR("*");
              if (CFStringCompare(v28, CFSTR("*"), 0))
                break;
            }
            else
            {
              v30 = (const __CFString *)CFArrayGetValueAtIndex(v25, 1);
            }
            CFArrayAppendValue(theArray, v22);
            CFArrayAppendValue(v37, v29);
            CFArrayAppendValue(v36, v30);
            CFRelease(v20);
            CFRelease(v25);
            v16 = ++v17 >= v12;
            v10 = v21;
            if (v12 == v17)
            {
              Mutable = theArray;
              if (v33)
                *v33 = CFRetain(theArray);
              v31 = v36;
              v14 = v37;
              if (v34)
                *v34 = CFRetain(v37);
              if (v35)
                *v35 = CFRetain(v36);
              goto LABEL_23;
            }
          }
          AMSupportLogInternal();
          v10 = v21;
LABEL_34:
          v14 = v37;
          Mutable = theArray;
          v31 = v36;
          CFRelease(v10);
          CFRelease(v20);
          v10 = v25;
          if (v25)
            goto LABEL_23;
          goto LABEL_24;
        }
      }
      AMSupportLogInternal();
      v31 = 0;
    }
    else
    {
      AMSupportLogInternal();
      v31 = 0;
      v14 = 0;
    }
  }
  v16 = 0;
LABEL_23:
  CFRelease(v10);
LABEL_24:
  if (Mutable)
    CFRelease(Mutable);
  if (v14)
    CFRelease(v14);
  if (v31)
    CFRelease(v31);
  return v16;
}

uint64_t _AMFDRHttpMultiSealingCallback(const UInt8 *a1, unsigned int a2, const UInt8 *a3, unsigned int a4, unint64_t a5, unsigned int a6, int a7, char *a8, int a9, const UInt8 *a10, unsigned int a11, uint64_t a12)
{
  const __CFDictionary *v13;
  const __CFDictionary *v19;
  const void *v20;
  CFTypeRef *v21;
  const __CFAllocator *v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFData *v29;
  CFStringRef v30;
  const __CFAllocator *v31;
  const __CFData *v32;
  const __CFAllocator *v33;
  CFStringRef v34;
  CFIndex v35;
  CFIndex v36;
  const __CFString *cf;
  const void *v41;

  v41 = 0;
  if (!a1
    || !a2
    || (v13 = *(const __CFDictionary **)(a12 + 16)) == 0
    || (v20 = *(const void **)a12,
        v19 = *(const __CFDictionary **)(a12 + 8),
        v21 = *(CFTypeRef **)(a12 + 24),
        CFDictionaryGetCount(*(CFDictionaryRef *)(a12 + 16)) >= 16)
    || !v20
    || !v19
    || CFDictionaryGetCount(v19) >= 16)
  {
    AMSupportLogInternal();
    v27 = 1;
    goto LABEL_49;
  }
  v22 = CFGetAllocator(v20);
  v23 = CFStringCreateWithBytes(v22, a1, a2, 0x8000100u, 0);
  if (!v23)
  {
    AMSupportLogInternal();
LABEL_55:
    v27 = 2;
    goto LABEL_49;
  }
  cf = v23;
  v24 = (const __CFString *)_AMFDRDataHTTPConvertMultiResponseKey(v20, v23);
  if (!v24)
  {
    AMSupportLogInternal();
    CFRelease(cf);
    goto LABEL_55;
  }
  v25 = v24;
  if (v21 && !*v21 && CFStringHasPrefix(v24, CFSTR("sreq")))
    *v21 = CFRetain(v25);
  AMSupportLogInternal();
  if (!a5)
  {
    v27 = 2;
    goto LABEL_18;
  }
  v26 = AMFDRDecodeMetadata(a5, a6, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t))_AMFDRHttpMetadataLog, 0);
  v27 = 0;
  if (!v26)
  {
LABEL_18:
    if (CFDictionaryGetValue(v19, v25) || CFDictionaryGetValue(v13, v25))
      goto LABEL_63;
    if (a7)
    {
      if (!a8)
      {
        if (a3 && a4)
        {
          v31 = CFGetAllocator(v20);
          v32 = CFDataCreate(v31, a3, a4);
          v29 = v32;
          if (v32)
          {
            CFDataGetLength(v32);
            AMSupportLogInternal();
            CFDictionarySetValue(v19, v25, v29);
            v27 = 0;
          }
          else
          {
            AMSupportLogInternal();
          }
          goto LABEL_26;
        }
LABEL_63:
        AMSupportLogInternal();
        v29 = 0;
        v30 = 0;
        v27 = 1;
        goto LABEL_45;
      }
    }
    else if (!a3)
    {
      if (a4)
        goto LABEL_63;
      if (a8 && a9 == 1)
      {
        if (a10
          && a11
          && (v33 = CFGetAllocator(v20), (v34 = CFStringCreateWithBytes(v33, a10, a11, 0x8000100u, 0)) != 0))
        {
          v30 = v34;
          AMSupportLogInternal();
          if ((*a8 - 1) >= 5u)
            v35 = 799;
          else
            v35 = (*a8 - 1) + 701;
          AMFDRErrorPushInternal((uint64_t)&v41, v35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMultiSealingCallback", CFSTR("multi-response error %d : %@"), *a8);
        }
        else
        {
          AMSupportLogInternal();
          if ((*a8 - 1) >= 5u)
            v36 = 799;
          else
            v36 = (*a8 - 1) + 701;
          AMFDRErrorPushInternal((uint64_t)&v41, v36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMultiSealingCallback", CFSTR("multi-response error %d without an error message"), *a8);
          v30 = 0;
        }
        if (v41)
        {
          CFDictionarySetValue(v13, v25, v41);
          v27 = 0;
        }
        else
        {
          AMSupportLogInternal();
        }
        v29 = 0;
        goto LABEL_45;
      }
    }
    AMSupportLogInternal();
    v29 = 0;
LABEL_26:
    v30 = 0;
    goto LABEL_45;
  }
  v28 = v26;
  AMSupportLogInternal();
  v29 = 0;
  v30 = 0;
  v27 = v28;
LABEL_45:
  CFRelease(cf);
  CFRelease(v25);
  if (v29)
    CFRelease(v29);
  if (v30)
    CFRelease(v30);
LABEL_49:
  if (v41)
    CFRelease(v41);
  return v27;
}

CFTypeRef _AMFDRDataHTTPConvertMultiResponseKey(CFTypeRef cf, const __CFString *a2)
{
  const __CFAllocator *v4;
  CFMutableStringRef MutableCopy;
  const __CFArray *v6;
  const __CFArray *v7;
  CFIndex Count;
  const __CFString *v9;
  CFIndex v10;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFString *ValueAtIndex;
  const __CFString *v13;
  CFIndex Length;
  CFIndex v15;
  CFTypeRef v16;
  CFRange result;
  CFRange v19;
  CFRange v20;
  CFRange v21;
  CFRange v22;
  CFRange v23;
  CFRange v24;

  if (!cf)
  {
    AMSupportLogInternal();
    v16 = 0;
    goto LABEL_22;
  }
  if (!a2)
    goto LABEL_23;
  v4 = CFGetAllocator(cf);
  MutableCopy = CFStringCreateMutableCopy(v4, 0, a2);
  if (!MutableCopy)
    goto LABEL_23;
  if (!AMFDRDataInstanceUseSikFormat((uint64_t)cf))
  {
    if ((*(_BYTE *)(*((_QWORD *)cf + 17) + 8) & 0x10) != 0)
    {
      ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x24BDBD240], MutableCopy, CFSTR(":"));
      if (ArrayBySeparatingStrings)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
        if (ValueAtIndex)
        {
          v13 = ValueAtIndex;
          Length = CFStringGetLength(ValueAtIndex);
          if ((unint64_t)(Length - 5) > 0xFFFFFFFFFFFFFFFDLL)
          {
            v15 = Length;
            if (Length != 3 || CFStringCompare(CFSTR("TS2"), v13, 0) == kCFCompareEqualTo)
            {
              v24.location = v15;
              v24.length = 1;
              if (CFStringFindAndReplace(MutableCopy, CFSTR(":"), CFSTR("-"), v24, 0) == 1)
                goto LABEL_21;
            }
          }
        }
      }
    }
    else
    {
      v23.location = 4;
      v23.length = 1;
      if (CFStringFindAndReplace(MutableCopy, CFSTR(":"), CFSTR("-"), v23, 0) == 1)
        goto LABEL_21;
    }
LABEL_23:
    AMSupportLogInternal();
    v16 = 0;
    goto LABEL_22;
  }
  result.location = 0xAAAAAAAAAAAAAAAALL;
  result.length = 0xAAAAAAAAAAAAAAAALL;
  v21.location = 4;
  v21.length = 5;
  if (CFStringFindAndReplace(MutableCopy, CFSTR(":sik-"), CFSTR("-"), v21, 0) != 1)
  {
    v20.location = 0;
    v20.length = 16;
    if (!CFStringFindWithOptions(MutableCopy, CFSTR("minimal-manifest"), v20, 8uLL, &result))
      goto LABEL_23;
    v22.location = 16;
    v22.length = 5;
    if (CFStringFindAndReplace(MutableCopy, CFSTR(":sik-"), CFSTR("-"), v22, 0) != 1)
      goto LABEL_23;
  }
  v6 = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x24BDBD240], MutableCopy, CFSTR("-"));
  v7 = v6;
  if (!v6)
    goto LABEL_23;
  Count = CFArrayGetCount(v6);
  if (Count <= 2)
    goto LABEL_23;
  v9 = (const __CFString *)CFArrayGetValueAtIndex(v7, Count - 1);
  if (!v9)
    goto LABEL_23;
  v10 = CFStringGetLength(v9);
  v19.location = CFStringGetLength(MutableCopy) + ~v10;
  v19.length = v10 + 1;
  CFStringDelete(MutableCopy, v19);
LABEL_21:
  v16 = CFRetain(MutableCopy);
LABEL_22:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v16;
}

uint64_t _AMFDRHttpMetadataLog(UInt8 *bytes, CFIndex numBytes, const UInt8 *a3, unsigned int a4, _QWORD *a5)
{
  const __CFAllocator *v8;
  CFStringRef v9;
  const __CFString *v10;
  CFStringRef Copy;
  uint64_t v12;
  CFTypeRef *v13;
  const void *v14;

  if (!bytes)
  {
    AMSupportLogInternal();
    return 1;
  }
  v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v9 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], bytes, numBytes, 0x8000100u, 0);
  if (!v9)
  {
    AMSupportLogInternal();
    return 2;
  }
  v10 = v9;
  if (a3)
  {
    a3 = (const UInt8 *)CFStringCreateWithBytes(v8, a3, a4, 0x8000100u, 0);
    if (!a3)
    {
      AMSupportLogInternal();
      CFRelease(v10);
      return 2;
    }
  }
  AMSupportLogInternal();
  if (!a5)
    goto LABEL_13;
  if (!a3 || !*a5 || CFStringCompare(v10, CFSTR("x-fdr-jmet-data-hash"), 0))
  {
    if (a3 && a5[1])
    {
      if (CFStringCompare(v10, CFSTR("x-fdr-metadata-asid"), 0))
      {
        Copy = 0;
      }
      else
      {
        Copy = CFStringCreateCopy(v8, (CFStringRef)a3);
        v13 = (CFTypeRef *)a5[1];
        if (*v13)
        {
          CFRelease(*v13);
          v13 = (CFTypeRef *)a5[1];
        }
        *v13 = Copy;
        v14 = *(const void **)a5[1];
        if (v14)
          CFRetain(v14);
      }
      v12 = 0;
      goto LABEL_21;
    }
LABEL_13:
    CFRelease(v10);
    v12 = 0;
    Copy = 0;
    if (!a3)
      return v12;
    goto LABEL_22;
  }
  AMSupportCopyDataFromHexString();
  AMSupportLogInternal();
  Copy = 0;
  v12 = 2;
LABEL_21:
  CFRelease(v10);
LABEL_22:
  CFRelease(a3);
  if (Copy)
    CFRelease(Copy);
  return v12;
}

const __CFData *AMFDRDataHTTPCreateMultiRequest(__CFString *a1, unsigned int a2, CFArrayRef theArray, const __CFArray *a4, const __CFArray *a5, const __CFArray *a6, const __CFArray *a7, int a8, uint64_t a9)
{
  const __CFArray *v9;
  int v13;
  CFIndex v14;
  const void *InstanceString;
  CFStringRef v16;
  const __CFString *ValueAtIndex;
  const void *v18;
  const void *v19;
  __CFString *v20;
  const __CFAllocator *v21;
  const __CFData *v22;
  const __CFAllocator *v23;
  const __CFDictionary *v24;
  const __CFDictionary *v25;
  CFTypeID v26;
  const void *Value;
  const void *v28;
  int v29;
  const __CFString *v30;
  int v31;
  const UInt8 *BytePtr;
  int Length;
  const UInt8 *v34;
  int v35;
  int v36;
  const __CFAllocator *v37;
  const __CFString *v39;
  char v40;
  const __CFArray *v42;
  const __CFArray *v43;
  CFIndex Count;
  _QWORD context[2];
  const __CFString *v49;
  _QWORD *v50;
  uint64_t v51;
  int v52;
  void *v53;
  unsigned int v54;
  UInt8 *v55;

  v55 = 0;
  v54 = 0;
  v53 = 0;
  v52 = 0;
  v50 = 0;
  v51 = 0;
  if (!a1)
  {
    v39 = CFSTR("amfdr is NULL");
    goto LABEL_83;
  }
  v9 = theArray;
  if (!theArray)
  {
    v39 = CFSTR("dataClassArray is NULL");
    goto LABEL_83;
  }
  if (!a4)
  {
    v39 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_83;
  }
  if (a2 > 0x10 || ((1 << a2) & 0x10804) == 0)
  {
    if (a5 || !a8)
      goto LABEL_7;
    v39 = CFSTR("dataInstanceArray is NULL and signData is specified");
LABEL_83:
    AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", v39, v40);
    goto LABEL_84;
  }
  if (!a5)
  {
    v39 = CFSTR("MultiRequestActionPut but valueDataArray is NULL, or other action code but valueDataArray has value");
    goto LABEL_83;
  }
LABEL_7:
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v39 = CFSTR("Nothing to compose multirequest");
    goto LABEL_83;
  }
  v13 = AMFDREncodeMultiRequestBegin((uint64_t)&v51, a2);
  if (!v13)
  {
    v14 = 0;
    InstanceString = 0;
    v16 = 0;
    ValueAtIndex = 0;
    v42 = v9;
    v43 = a6;
    while (1)
    {
      if (v16)
        CFRelease(v16);
      if (InstanceString)
        CFRelease(InstanceString);
      if (ValueAtIndex)
        CFRelease(ValueAtIndex);
      if (v53)
      {
        free(v53);
        v53 = 0;
      }
      v52 = 0;
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, v14);
      v18 = CFArrayGetValueAtIndex(a4, v14);
      if (!ValueAtIndex)
      {
        AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", CFSTR("dataClassStr is NULL"), v40);
        v22 = 0;
        goto LABEL_85;
      }
      v19 = v18;
      if (!CFStringGetLength(ValueAtIndex))
      {
        v39 = CFSTR("dataClassStr length is 0");
        goto LABEL_83;
      }
      if (!v19)
      {
        v39 = CFSTR("dataInstanceStr is NULL");
        goto LABEL_83;
      }
      if (a6)
      {
        v20 = (__CFString *)CFArrayGetValueAtIndex(a6, v14);
        if (!v20)
        {
          v39 = CFSTR("options is NULL");
          goto LABEL_83;
        }
      }
      else
      {
        v20 = 0;
      }
      InstanceString = AMFDRDataCreateInstanceString(a1, (uint64_t)ValueAtIndex, v19);
      if (!InstanceString)
      {
        AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", CFSTR("dataInstanceToReq is NULL"), v40);
        v22 = 0;
        ValueAtIndex = 0;
        v16 = 0;
        goto LABEL_60;
      }
      v21 = CFGetAllocator(a1);
      v16 = CFStringCreateWithFormat(v21, 0, CFSTR("%@:%@"), ValueAtIndex, InstanceString);
      CFRelease(InstanceString);
      if (!v16)
        break;
      v22 = 0;
      if (a2 <= 0x10 && ((1 << a2) & 0x10804) != 0)
      {
        v22 = (const __CFData *)CFArrayGetValueAtIndex(a5, v14);
        if (!v22)
        {
          AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", CFSTR("valueData is NULL"), v40);
          goto LABEL_82;
        }
      }
      v23 = CFGetAllocator(a1);
      InstanceString = CFStringCreateExternalRepresentation(v23, v16, 0x8000100u, 0x5Fu);
      if (!InstanceString)
      {
        AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", CFSTR("currDataInstanceData is NULL"), v40);
        v22 = 0;
        ValueAtIndex = 0;
        goto LABEL_60;
      }
      if (a8)
      {
        ValueAtIndex = (const __CFString *)AMFDRDataCopyForPut((uint64_t)a1, ValueAtIndex, v19, v22, v20, a9);
        v22 = (const __CFData *)ValueAtIndex;
        if (!ValueAtIndex)
        {
          AMFDRErrorPushInternal(a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", CFSTR("AMFDRDataCopyForPut failed"), v40);
          goto LABEL_60;
        }
      }
      else
      {
        ValueAtIndex = 0;
      }
      if (a7)
      {
        v24 = (const __CFDictionary *)CFArrayGetValueAtIndex(a7, v14);
        if (!v24)
        {
          AMFDRErrorPushInternal(a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", CFSTR("metadata is NULL"), v40);
          goto LABEL_88;
        }
        if (a2 <= 0x10 && ((1 << a2) & 0x10880) != 0)
        {
          v25 = v24;
          v26 = CFGetTypeID(v24);
          if (v26 == CFDictionaryGetTypeID() && CFDictionaryGetCount(v25) >= 1)
          {
            if (AMFDREncodeMetadataBegin(&v50))
              goto LABEL_80;
            context[0] = v50;
            context[1] = a9;
            v49 = &stru_24C6A3418;
            if (v20)
            {
              Value = CFDictionaryGetValue((CFDictionaryRef)v20, CFSTR("MetadataType"));
              if (Value)
              {
                v28 = Value;
                v29 = CFEqual(Value, CFSTR("System"));
                v30 = CFSTR("x-fdr-metadata-");
                if (!v29)
                {
                  v31 = CFEqual(v28, CFSTR("User"));
                  v30 = &stru_24C6A3418;
                  if (v31)
                    v30 = CFSTR("x-fdr-user-metadata-");
                }
                v49 = v30;
              }
            }
            CFDictionaryApplyFunction(v25, (CFDictionaryApplierFunction)_addMetaDataRecord, context);
            if (AMFDREncodeMetadataEnd(&v50, &v53, &v52))
            {
LABEL_80:
              AMSupportLogInternal();
              goto LABEL_88;
            }
          }
        }
      }
      BytePtr = CFDataGetBytePtr((CFDataRef)InstanceString);
      Length = CFDataGetLength((CFDataRef)InstanceString);
      v34 = 0;
      if (a2 <= 0x10 && ((1 << a2) & 0x10804) != 0)
        v34 = CFDataGetBytePtr(v22);
      v35 = 0;
      if (a2 <= 0x10 && ((1 << a2) & 0x10804) != 0)
        v35 = CFDataGetLength(v22);
      if (AMFDREncodeMultiRequestAddRecord((uint64_t)&v51, (uint64_t)BytePtr, Length, (uint64_t)v34, v35, (uint64_t)v53, v52))goto LABEL_80;
      ++v14;
      a6 = v43;
      v9 = v42;
      if (Count == v14)
      {
        v36 = AMFDREncodeMultiRequestEnd(&v51, &v55, &v54);
        if (!v36)
        {
          v37 = CFGetAllocator(a1);
          v22 = CFDataCreate(v37, v55, v54);
          if (!v22)
            AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", CFSTR("httpRequestData is NULL"), v40);
          goto LABEL_60;
        }
        AMFDRErrorPushInternal(a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", CFSTR("AMFDREncodeMultiRequestEnd failed 0x%X"), v36);
LABEL_88:
        v22 = 0;
        goto LABEL_60;
      }
    }
    AMFDRErrorPushInternal(a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", CFSTR("currDataInstance is NULL"), v40);
    v22 = 0;
LABEL_82:
    ValueAtIndex = 0;
    goto LABEL_86;
  }
  AMFDRErrorPushInternal(a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCreateMultiRequest", CFSTR("AMFDREncodeMultiRequestBegin failed 0x%X"), v13);
LABEL_84:
  v22 = 0;
  ValueAtIndex = 0;
LABEL_85:
  v16 = 0;
LABEL_86:
  InstanceString = 0;
LABEL_60:
  if (v55)
  {
    free(v55);
    v55 = 0;
  }
  if (v53)
  {
    free(v53);
    v53 = 0;
  }
  if (ValueAtIndex)
    CFRelease(ValueAtIndex);
  if (v16)
    CFRelease(v16);
  if (InstanceString)
    CFRelease(InstanceString);
  AMFDREncodeMetadataDestroy(&v50);
  AMFDREncodeMultiRequestDestroy((uint64_t)&v51);
  return v22;
}

void _addMetaDataRecord(const __CFString *cf, const __CFString *a2, uint64_t a3)
{
  const __CFString *v4;
  const __CFString *v5;
  CFTypeID v6;
  const __CFAllocator *v7;
  const __CFData *ExternalRepresentation;
  CFTypeID v9;
  CFTypeID v10;
  const UInt8 *BytePtr;
  int Length;
  const UInt8 *v13;
  int v14;
  int v15;
  char v16;
  CFTypeRef cfa;

  v4 = cf;
  cfa = 0;
  if (!cf)
  {
    AMSupportLogInternal();
    ExternalRepresentation = 0;
    goto LABEL_15;
  }
  if (!a3)
  {
    AMSupportLogInternal();
    goto LABEL_26;
  }
  v5 = a2;
  if (!a2)
  {
    AMFDRErrorPushInternal((uint64_t)&cfa, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_addMetaDataRecord", CFSTR("value is NULL"), v16);
    ExternalRepresentation = 0;
LABEL_33:
    v4 = 0;
    goto LABEL_16;
  }
  v6 = CFGetTypeID(cf);
  if (v6 != CFStringGetTypeID())
  {
    AMSupportLogInternal();
    ExternalRepresentation = 0;
    v5 = 0;
    goto LABEL_33;
  }
  v7 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@%@"), *(_QWORD *)(a3 + 16), v4);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v7, v4, 0x8000100u, 0x20u);
  if (!ExternalRepresentation)
  {
    AMFDRErrorPushInternal((uint64_t)&cfa, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_addMetaDataRecord", CFSTR("failed to create innerHeaderKey"), v16);
    goto LABEL_15;
  }
  v9 = CFGetTypeID(v5);
  if (v9 == CFDataGetTypeID())
  {
    v5 = (const __CFString *)CFRetain(v5);
    goto LABEL_10;
  }
  v10 = CFGetTypeID(v5);
  if (v10 != CFStringGetTypeID())
  {
    AMFDRErrorPushInternal((uint64_t)&cfa, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_addMetaDataRecord", CFSTR("unexpected type of innerHeaderValue"), v16);
LABEL_15:
    v5 = 0;
    goto LABEL_16;
  }
  v5 = (const __CFString *)CFStringCreateExternalRepresentation(v7, v5, 0x8000100u, 0x20u);
  if (v5)
  {
LABEL_10:
    if (CFDataGetLength((CFDataRef)v5))
    {
      BytePtr = CFDataGetBytePtr(ExternalRepresentation);
      Length = CFDataGetLength(ExternalRepresentation);
      v13 = CFDataGetBytePtr((CFDataRef)v5);
      v14 = CFDataGetLength((CFDataRef)v5);
      v15 = AMFDREncodeMetadataAddRecord((_QWORD *)a3, (uint64_t)BytePtr, Length, (uint64_t)v13, v14);
      if (v15)
        AMFDRErrorPushInternal((uint64_t)&cfa, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_addMetaDataRecord", CFSTR("AMFDREncodeMetadataAddRecord failed 0x%X"), v15);
    }
    else
    {
      AMSupportLogInternal();
    }
    goto LABEL_16;
  }
  AMFDRErrorPushInternal((uint64_t)&cfa, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_addMetaDataRecord", CFSTR("failed to create innerHeaderValue"), v16);
LABEL_16:
  if (a3 && cfa && *(_QWORD *)(a3 + 8))
    **(_QWORD **)(a3 + 8) = CFRetain(cfa);
  if (ExternalRepresentation)
    CFRelease(ExternalRepresentation);
  if (v5)
    CFRelease(v5);
  if (v4)
    CFRelease(v4);
LABEL_26:
  if (cfa)
    CFRelease(cfa);
}

CFTypeRef *AMFDRDataHTTPMultiSign(uint64_t a1, const __CFArray *a2, const __CFArray *a3, const __CFData *a4, CFTypeRef *a5, CFTypeRef *a6)
{
  CFTypeRef *v6;
  CFDictionaryRef *v7;
  CFTypeRef *v8;
  CFIndex Count;
  CFIndex v13;
  const __CFAllocator *v14;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v16;
  const void *ValueAtIndex;
  const __CFAllocator *v18;
  const CFDictionaryKeyCallBacks *v19;
  const CFDictionaryValueCallBacks *v20;
  const __CFAllocator *v21;
  CFIndex v22;
  const __CFDictionary *v23;
  const __CFDictionary *v24;
  const __CFDictionary *v25;
  const __CFAllocator *v26;
  CFIndex v27;
  const __CFArray *v28;
  const __CFArray *v29;
  const __CFData *v30;
  CFTypeRef *v31;
  const __CFDictionary *v32;
  __CFDictionary *v33;
  CFTypeID v34;
  BOOL v35;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v37;
  const __CFAllocator *v38;
  CFMutableDictionaryRef v39;
  CFMutableDictionaryRef value;
  const UInt8 *BytePtr;
  unsigned int Length;
  const void *v43;
  const void *v44;
  const __CFAllocator *v45;
  CFStringRef v46;
  __CFError *v47;
  uint64_t v48;
  const __CFString *v50;
  const __CFString *v51;
  const __CFString *v52;
  const __CFString *v53;
  const __CFString *v54;
  const __CFString *v55;
  const __CFString *v56;
  const __CFString *format;
  char v58;
  CFDictionaryRef *v59;
  CFTypeRef *v60;
  __CFString *cf;
  char v62;
  CFDataRef theData;
  int v64;
  uint64_t v65;
  void *values[2];
  const __CFString *v67;
  void *keys[2];
  const __CFString *v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;

  v6 = a6;
  v72 = *MEMORY[0x24BDAC8D0];
  v65 = 0;
  v64 = 0;
  theData = 0;
  v62 = 0;
  v70 = 0u;
  v71 = 0u;
  if (!a1)
  {
    v51 = CFSTR("amfdr is NULL");
LABEL_51:
    format = v51;
LABEL_58:
    AMFDRErrorPushInternal((uint64_t)v6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", format, v58);
    goto LABEL_59;
  }
  v7 = (CFDictionaryRef *)a1;
  if (!*(_QWORD *)(a1 + 16))
  {
    v51 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_51;
  }
  v8 = a5;
  if (!a5)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", CFSTR("outSignedValueDataDict is NULL"), v58);
    goto LABEL_45;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a6) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)v6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v58);
LABEL_59:
    v8 = 0;
    goto LABEL_45;
  }
  if (!a2)
  {
    v52 = CFSTR("dataClassesArray is NULL");
LABEL_57:
    format = v52;
    goto LABEL_58;
  }
  Count = CFArrayGetCount(a2);
  if (Count <= 0)
  {
    v52 = CFSTR("dataClassesArray count is 0");
    goto LABEL_57;
  }
  v13 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v52 = CFSTR("Invalid dataInstancesArray count");
    goto LABEL_57;
  }
  v14 = CFGetAllocator(v7);
  Mutable = CFDictionaryCreateMutable(v14, v13, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)v6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", CFSTR("valueDataDict is NULL"), v58);
    goto LABEL_59;
  }
  v16 = Mutable;
  ValueAtIndex = CFArrayGetValueAtIndex(a3, 0);
  cf = _AMFDRCreateUrlWithKey((uint64_t)v7, CFSTR("SealingURL"), (uint64_t)CFSTR("sealing/sign"), (uint64_t)CFSTR("seal"), ValueAtIndex);
  if (!cf)
  {
    AMFDRErrorPushInternal((uint64_t)v6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", CFSTR("serverURL is NULL"), v58);
    CFRelease(v16);
    goto LABEL_59;
  }
  if ((AMFDRDataGetSigningVersion((uint64_t)v7, (int *)&v65 + 1) & 1) == 0)
  {
    v53 = CFSTR("AMFDRDataGetSigningVersion failed");
LABEL_65:
    AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", v53, v58);
    v23 = 0;
LABEL_67:
    v37 = 0;
    goto LABEL_75;
  }
  if (HIDWORD(v65) == 1)
  {
    v53 = CFSTR("Multi sealing require FDR 2.0");
    goto LABEL_65;
  }
  if ((AMFDRDataGetManifestVersion((uint64_t)v7, (unsigned int *)&v65) & 1) == 0)
  {
    v53 = CFSTR("AMFDRDataGetManifestVersion failed");
    goto LABEL_65;
  }
  v60 = v8;
  if ((_DWORD)v65 == 1)
  {
    *(_OWORD *)keys = xmmword_24C69F2D0;
    v69 = CFSTR("x-fdr-jmet-multi-seal");
    *(_OWORD *)values = xmmword_24C69F2E8;
    v67 = CFSTR("true");
    v18 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v19 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
    v20 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
    v21 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v22 = 3;
  }
  else
  {
    *(_OWORD *)keys = xmmword_24C69F300;
    *(_OWORD *)values = xmmword_24C69F310;
    v18 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v19 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
    v20 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
    v21 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v22 = 2;
  }
  v23 = CFDictionaryCreate(v21, (const void **)keys, (const void **)values, v22, v19, v20);
  if (!v23)
  {
    AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", CFSTR("Unable to create HTTP header extensiondictionary"), v58);
    goto LABEL_67;
  }
  v24 = (const __CFDictionary *)CFDictionaryGetValue(v7[2], CFSTR("SealingHeaders"));
  if (!v24)
    goto LABEL_21;
  v25 = v24;
  v59 = v7;
  v26 = v18;
  v27 = v13;
  v28 = a2;
  v29 = a3;
  v30 = a4;
  v31 = v6;
  v32 = v23;
  v33 = v16;
  v34 = CFGetTypeID(v24);
  v35 = v34 == CFDictionaryGetTypeID();
  v16 = v33;
  v23 = v32;
  v6 = v31;
  a4 = v30;
  a3 = v29;
  a2 = v28;
  v13 = v27;
  v18 = v26;
  v7 = v59;
  if (v35)
    MutableCopy = CFDictionaryCreateMutableCopy(v18, 0, v25);
  else
LABEL_21:
    MutableCopy = CFDictionaryCreateMutable(v18, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v37 = MutableCopy;
  if (!MutableCopy)
  {
    v54 = CFSTR("Unable to create httpXAllHeaders");
    goto LABEL_74;
  }
  if (AMFDROptionsGetBooleanValue((uint64_t)v7, CFSTR("DeprecateV1"), 0))
    CFDictionarySetValue(v37, CFSTR("x-fdr-deprecate-v1"), CFSTR("true"));
  if ((AMFDRDataGetMinimalManifestVersion((uint64_t)v7, &v64) & 1) == 0)
  {
    v55 = CFSTR("AMFDRDataGetMinimalManifestVersion failed");
LABEL_71:
    AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", v55, v58);
    goto LABEL_75;
  }
  if (v64 == 2)
    CFDictionarySetValue(v37, CFSTR("x-fdr-minimal-seal-version"), CFSTR("2"));
  if ((_CFDictionaryAddDictionary(v37, v23) & 1) == 0)
  {
    v55 = CFSTR("Unable to add sealing headers");
    goto LABEL_71;
  }
  if ((_AMFDRHttpRequestSendSync(v7, (const __CFURL *)cf, (uint64_t)CFSTR("MultiSign"), CFSTR("POST"), v37, a4, (CFTypeRef *)&theData, 1, 0, 0, 0, 0, v6) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)v6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", CFSTR("AMFDRDataHTTPMultiSign failed"), v58);
    goto LABEL_75;
  }
  v38 = CFGetAllocator(v7);
  v39 = CFDictionaryCreateMutable(v38, v13, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v39)
  {
    value = v39;
    if (theData)
    {
      *(_QWORD *)&v70 = v7;
      *((_QWORD *)&v70 + 1) = v16;
      *(_QWORD *)&v71 = v39;
      BytePtr = CFDataGetBytePtr(theData);
      Length = CFDataGetLength(theData);
      if (AMFDRDecodeMultiSealingResponse((uint64_t)BytePtr, Length, &v62, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t))_AMFDRHttpMultiSealingCallback, (uint64_t)&v70))
      {
        v56 = CFSTR("AMFDRDecodeMultiSealingResponse failed");
      }
      else
      {
        if (v62 == 11)
        {
          if ((_AMFDRSavePersistentCookie((uint64_t)v7, (uint64_t)v6) & 1) != 0)
          {
            if (CFDictionaryGetCount(value) >= 1)
            {
              AMFDRErrorPushInternal((uint64_t)v6, 21, 0, 0, 0, 0, 0, 0, value, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", CFSTR("got multiRequestErrors"), v58);
              if (CFArrayGetCount(a2) >= 1)
              {
                v43 = CFArrayGetValueAtIndex(a2, 0);
                v44 = CFArrayGetValueAtIndex(a3, 0);
                v45 = CFGetAllocator(v7);
                v46 = CFStringCreateWithFormat(v45, 0, CFSTR("%@-%@"), v43, v44);
                v47 = (__CFError *)CFDictionaryGetValue(value, v46);
                if (v47)
                {
                  CFErrorGetCode(v47);
                  AMSupportLogInternal();
                }
                else
                {
                  AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", CFSTR("%@ manifest is missing but multiRequestError is NULL"), (char)v46);
                }
                v48 = 0;
LABEL_42:
                CFRelease(v16);
                CFRelease(value);
                CFRelease(cf);
                CFRelease(v23);
                if (v46)
                  CFRelease(v46);
LABEL_44:
                CFRelease(v37);
                v8 = (CFTypeRef *)v48;
                goto LABEL_45;
              }
            }
            *v60 = CFRetain(v16);
            if ((_AMFDRSavePersistentCookie((uint64_t)v7, (uint64_t)v6) & 1) != 0)
            {
              v46 = 0;
              v48 = 1;
              goto LABEL_42;
            }
          }
          v50 = CFSTR("_AMFDRSavePersistentCookie failed");
          goto LABEL_80;
        }
        v58 = v62;
        v56 = CFSTR("actionCode returned is %d");
      }
      AMFDRErrorPushInternal((uint64_t)v6, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", v56, v58);
      goto LABEL_84;
    }
    v50 = CFSTR("_AMFDRHttpRequestSendSync failed: httpReturnData is NULL");
LABEL_80:
    AMFDRErrorPushInternal((uint64_t)v6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", v50, v58);
LABEL_84:
    v48 = 0;
    v46 = 0;
    goto LABEL_42;
  }
  v54 = CFSTR("multiRequestErrors is NULL");
LABEL_74:
  AMFDRErrorPushInternal((uint64_t)v6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiSign", v54, v58);
LABEL_75:
  CFRelease(v16);
  CFRelease(cf);
  if (v23)
    CFRelease(v23);
  v48 = 0;
  v8 = 0;
  if (v37)
    goto LABEL_44;
LABEL_45:
  if (theData)
    CFRelease(theData);
  return v8;
}

uint64_t _AMFDRHttpRequestSendSync(CFDictionaryRef *cf, const __CFURL *a2, uint64_t a3, __CFString *a4, const void *a5, const __CFData *a6, CFTypeRef *a7, char a8, uint64_t a9, const __CFString *a10, uint64_t (*a11)(CFDictionaryRef *, uint64_t, CFTypeRef *), uint64_t a12, CFTypeRef *a13)
{
  CFTypeRef *v17;
  char v21;
  const __CFData *v22;
  CFDictionaryRef v23;
  const __CFString *v24;
  uint64_t v25;
  CFTypeRef *v26;
  CFIndex v27;
  int v28;
  const __CFDictionary *v29;
  const __CFNumber *Value;
  const __CFNumber *v31;
  CFTypeID v32;
  const __CFData *v33;
  const __CFString *format;
  char v36;
  char v37;
  const __CFData *v38;
  CFIndex v40;
  CFTypeRef cfa;
  int valuePtr;

  v40 = 0xAAAAAAAAAAAAAAAALL;
  cfa = 0;
  if (!cf)
  {
    format = CFSTR("amfdr is NULL");
LABEL_58:
    AMFDRErrorPushInternal((uint64_t)a13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSync", format, v36);
    goto LABEL_24;
  }
  if (!cf[2])
  {
    format = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_58;
  }
  if (!a2)
  {
    format = CFSTR("serverURL is NULL");
    goto LABEL_58;
  }
  if (!a4)
  {
    format = CFSTR("action is NULL");
    goto LABEL_58;
  }
  v17 = a7;
  if (a10)
  {
    v21 = _AMFDRDataPermAllowed(cf, a10);
    v17 = a7;
    if ((v21 & 1) == 0)
    {
      v37 = (char)a10;
LABEL_23:
      AMFDRErrorPushInternal((uint64_t)a13, 404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSync", CFSTR("%@ is not allowed. returning kAMFDRServerErrorNotFound"), v37);
LABEL_24:
      v25 = 0;
      v22 = 0;
      goto LABEL_49;
    }
  }
  _AMFDRHttpRequestSendSyncNoRetry((uint64_t)cf, a2, a3, a4, CFSTR("application/octet-stream"), a5, a6, v17, &cfa, a8, a9, 1, &v40, (uint64_t)a13);
  if (!cfa)
  {
    AMFDRErrorPushInternal((uint64_t)a13, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSync", CFSTR("httpResponseHeader is NULL"), v36);
    goto LABEL_24;
  }
  v38 = a6;
  v22 = 0;
  if ((unint64_t)(v40 - 401) > 0x12 || ((1 << (v40 + 111)) & 0x40005) == 0)
    goto LABEL_34;
  AMSupportLogInternal();
  if ((AMFDRPermissionsRequest((uint64_t)cf, a13) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a13, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSync", CFSTR("Permissions request failed."), v36);
    goto LABEL_24;
  }
  v23 = cf[3];
  if (v23)
  {
    CFRelease(v23);
    cf[3] = 0;
  }
  if (a13 && *a13)
  {
    CFRelease(*a13);
    *a13 = 0;
  }
  AMSupportSafeRelease();
  cfa = 0;
  if (a10 && (_AMFDRDataPermAllowed(cf, a10) & 1) == 0)
  {
    v37 = (char)a10;
    goto LABEL_23;
  }
  if (a11)
  {
    v22 = (const __CFData *)a11(cf, a12, a13);
    v38 = v22;
    if (!v22)
    {
      v24 = CFSTR("createSignedData failed");
LABEL_63:
      AMFDRErrorPushInternal((uint64_t)a13, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSync", v24, v36);
      goto LABEL_48;
    }
  }
  else
  {
    v22 = 0;
  }
  v26 = a7;
  if (a7 && *a7)
  {
    CFRelease(*a7);
    v26 = a7;
    *a7 = 0;
  }
  if ((_AMFDRHttpRequestSendSyncNoRetry((uint64_t)cf, a2, a3, a4, CFSTR("application/octet-stream"), a5, v38, v26, &cfa, a8, a9, 1, &v40, (uint64_t)a13) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a13, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpRequestSendSync", CFSTR("_AMFDRHttpRequestSendSyncNoRetry failed"), v36);
    goto LABEL_48;
  }
  if (!cfa)
  {
    v24 = CFSTR("httpResponseHeader is NULL");
    goto LABEL_63;
  }
  if (a13 && *a13)
  {
    CFRelease(*a13);
    *a13 = 0;
  }
LABEL_34:
  v27 = v40;
  if ((v40 & 0xFFFFFFFFFFFFFFFDLL) == 0xC8)
  {
    v25 = 1;
    goto LABEL_49;
  }
  if (AMFDROptionsGetBooleanValue((uint64_t)cf, CFSTR("DumpHttpBodyOnFailure"), 0))
  {
    v28 = 0x80000;
    valuePtr = 0x80000;
    v29 = cf[2];
    if (v29)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(v29, CFSTR("DumpHttpBodyLength"));
      if (!Value
        || (v31 = Value, v32 = CFGetTypeID(Value), v32 != CFNumberGetTypeID())
        || !CFNumberGetValue(v31, kCFNumberSInt32Type, &valuePtr)
        || (v28 = valuePtr, valuePtr < 0))
      {
        v28 = 0x80000;
      }
    }
    _AMFDRHttpLogRequest(0, v38, v28);
    v27 = v40;
  }
  if (a7)
    v33 = (const __CFData *)*a7;
  else
    v33 = 0;
  _AMFDRHttpHandleHeaderMessage(cf, (CFDictionaryRef)cfa, v27, v33, (uint64_t)a13);
LABEL_48:
  v25 = 0;
LABEL_49:
  if (cfa)
  {
    CFRelease(cfa);
    cfa = 0;
  }
  if (v22)
    CFRelease(v22);
  return v25;
}

uint64_t _AMFDRSavePersistentCookie(uint64_t a1, uint64_t a2)
{
  const __CFString *v4;
  CFIndex Length;
  UInt8 *v6;
  UInt8 *v7;
  const __CFString *v8;
  CFIndex v9;
  const __CFAllocator *v10;
  CFIndex v11;
  CFDataRef v12;
  CFDataRef v13;
  __CFDictionary *v14;
  uint64_t v15;
  char v17;

  if (!a1)
  {
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSavePersistentCookie", CFSTR("amfdr is NULL"), v17);
    return 0;
  }
  if (AMFDRShouldPersistData(a1, CFSTR("PersistCookie")))
  {
    v4 = *(const __CFString **)(a1 + 24);
    if (v4)
    {
      if (CFStringGetLength(v4))
      {
        Length = CFStringGetLength(*(CFStringRef *)(a1 + 24));
        v6 = (UInt8 *)malloc_type_calloc(1uLL, Length + 1, 0x8DACE079uLL);
        if (v6)
        {
          v7 = v6;
          v8 = *(const __CFString **)(a1 + 24);
          v9 = CFStringGetLength(v8);
          if (CFStringGetCString(v8, (char *)v7, v9 + 1, 0x8000100u))
          {
            v10 = CFGetAllocator((CFTypeRef)a1);
            v11 = CFStringGetLength(*(CFStringRef *)(a1 + 24));
            v12 = CFDataCreate(v10, v7, v11);
            if (v12)
            {
              v13 = v12;
              v14 = *(__CFDictionary **)(a1 + 80);
              if (v14)
              {
                CFDictionarySetValue(v14, CFSTR("cookie"), v13);
              }
              else if (!_AMFDRSavePersistent(a1, (uint64_t)CFSTR("CookieFile"), (uint64_t)CFSTR("cookie"), (uint64_t)v13))
              {
                v15 = 0;
                goto LABEL_14;
              }
              v15 = 1;
LABEL_14:
              CFRelease(v13);
LABEL_15:
              free(v7);
              return v15;
            }
            AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSavePersistentCookie", CFSTR("tempData is NULL, failed to convert tempCString to CFData"), v17);
          }
          else
          {
            AMFDRErrorPushInternal(a2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSavePersistentCookie", CFSTR("failed to convert amfdr->cookieStr to c-string"), v17);
          }
          v15 = 0;
          goto LABEL_15;
        }
        AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSavePersistentCookie", CFSTR("tempCString is NULL"), v17);
        return 0;
      }
    }
  }
  return 1;
}

uint64_t AMFDRDataHTTPSign(CFDictionaryRef *a1, const void *a2, const __CFData *a3, CFTypeRef *a4, CFTypeRef *a5)
{
  __CFString *v10;
  __CFString *v11;
  const __CFAllocator *v12;
  const CFDictionaryKeyCallBacks *v13;
  const CFDictionaryValueCallBacks *v14;
  CFIndex v15;
  const __CFString *v16;
  CFDictionaryRef v17;
  CFDictionaryRef v18;
  const __CFDictionary *Value;
  const __CFDictionary *v20;
  CFTypeID v21;
  CFTypeID TypeID;
  const __CFAllocator *v23;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v25;
  uint64_t v26;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  char v31;
  unsigned int v32;
  CFTypeRef cf;
  uint64_t v34;
  void *values[2];
  void *keys[2];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  cf = 0;
  v34 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPSign", CFSTR("amfdr is NULL"), v31);
    return 0;
  }
  if (!a1[2])
  {
    v28 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_48;
  }
  if (!a4)
  {
    v28 = CFSTR("outSealingManifest is NULL");
    goto LABEL_48;
  }
  if ((AMFDRDataHTTPLoadPersistent(a1, a5) & 1) != 0)
  {
    v10 = _AMFDRCreateUrlWithKey((uint64_t)a1, CFSTR("SealingURL"), (uint64_t)CFSTR("sealing/sign"), (uint64_t)CFSTR("seal"), a2);
    if (v10)
    {
      v11 = v10;
      if ((AMFDRDataGetSigningVersion((uint64_t)a1, (int *)&v34 + 1) & 1) == 0)
      {
        v29 = CFSTR("AMFDRDataGetSigningVersion failed");
LABEL_60:
        AMFDRErrorPushInternal((uint64_t)a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPSign", v29, v31);
        CFRelease(v11);
        goto LABEL_61;
      }
      if (HIDWORD(v34) == 1)
      {
        v32 = 0;
        if ((AMFDRDataGetManifestVersion((uint64_t)a1, &v32) & 1) == 0)
        {
LABEL_57:
          v29 = CFSTR("AMFDRDataGetManifestVersion failed");
          goto LABEL_60;
        }
        if (v32 == 1)
        {
          v16 = CFSTR("x-fdr-seal-manifest-version");
          goto LABEL_17;
        }
      }
      else if (HIDWORD(v34) == 2)
      {
        v32 = 0;
        if ((AMFDRDataGetManifestVersion((uint64_t)a1, &v32) & 1) != 0)
        {
          if (v32 == 1)
          {
            *(_OWORD *)keys = xmmword_24C69F320;
            *(_OWORD *)values = xmmword_24C69F330;
            v12 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
            v13 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
            v14 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
            v15 = 2;
LABEL_18:
            v18 = CFDictionaryCreate(v12, (const void **)keys, (const void **)values, v15, v13, v14);
            if (v18)
            {
              v17 = v18;
LABEL_20:
              if ((AMFDRDataGetMinimalManifestVersion((uint64_t)a1, (int *)&v34) & 1) == 0)
              {
                AMFDRErrorPushInternal((uint64_t)a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPSign", CFSTR("AMFDRDataGetMinimalManifestVersion failed"), v31);
                v26 = 0;
                v25 = 0;
                goto LABEL_36;
              }
              if ((_DWORD)v34 == 2)
                CFDictionarySetValue(0, CFSTR("x-fdr-minimal-seal-version"), CFSTR("2"));
              Value = (const __CFDictionary *)CFDictionaryGetValue(a1[2], CFSTR("SealingHeaders"));
              if (Value)
              {
                v20 = Value;
                v21 = CFGetTypeID(Value);
                TypeID = CFDictionaryGetTypeID();
                v23 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
                if (v21 == TypeID)
                {
                  MutableCopy = CFDictionaryCreateMutableCopy(v23, 0, v20);
LABEL_28:
                  v25 = MutableCopy;
                  if (MutableCopy)
                  {
                    if (AMFDROptionsGetBooleanValue((uint64_t)a1, CFSTR("DeprecateV1"), 0))
                      CFDictionarySetValue(v25, CFSTR("x-fdr-deprecate-v1"), CFSTR("true"));
                    if (v17 && (_CFDictionaryAddDictionary(v25, v17) & 1) == 0)
                    {
                      AMFDRErrorPushInternal((uint64_t)a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPSign", CFSTR("Unable to add sealing headers"), v31);
                      CFRelease(v11);
                      v26 = 0;
LABEL_37:
                      CFRelease(v17);
LABEL_38:
                      if (v25)
                        CFRelease(v25);
                      goto LABEL_40;
                    }
                    if ((_AMFDRHttpRequestSendSync(a1, (const __CFURL *)v11, (uint64_t)CFSTR("Sign"), CFSTR("POST"), v25, a3, &cf, 1, 0, 0, 0, 0, a5) & 1) != 0)
                    {
                      if ((_AMFDRSavePersistentCookie((uint64_t)a1, (uint64_t)a5) & 1) != 0)
                      {
                        *a4 = CFRetain(cf);
                        v26 = 1;
                        goto LABEL_36;
                      }
                      v30 = CFSTR("_AMFDRSavePersistentCookie failed");
                    }
                    else
                    {
                      v30 = CFSTR("AMFDRDataHTTPSign failed");
                    }
                    AMFDRErrorPushInternal((uint64_t)a5, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPSign", v30, v31);
                  }
                  else
                  {
                    AMFDRErrorPushInternal((uint64_t)a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPSign", CFSTR("Unable to create httpXAllHeaders"), v31);
                  }
                  v26 = 0;
LABEL_36:
                  CFRelease(v11);
                  if (!v17)
                    goto LABEL_38;
                  goto LABEL_37;
                }
              }
              else
              {
                v23 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
              }
              MutableCopy = CFDictionaryCreateMutable(v23, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
              goto LABEL_28;
            }
            v29 = CFSTR("Unable to create HTTP header extensiondictionary");
            goto LABEL_60;
          }
          v16 = CFSTR("x-fdr-seal-version");
LABEL_17:
          keys[0] = (void *)v16;
          values[0] = CFSTR("2");
          v12 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
          v13 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
          v14 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
          v15 = 1;
          goto LABEL_18;
        }
        goto LABEL_57;
      }
      v17 = 0;
      goto LABEL_20;
    }
    v28 = CFSTR("serverURL is NULL");
LABEL_48:
    AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPSign", v28, v31);
    goto LABEL_61;
  }
  AMFDRErrorPushInternal((uint64_t)a5, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPSign", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v31);
LABEL_61:
  v26 = 0;
LABEL_40:
  if (cf)
    CFRelease(cf);
  return v26;
}

CFTypeRef AMFDRDataHTTPChallengeClaim(uint64_t a1, const __CFString *a2, const void *a3, CFTypeRef *a4)
{
  const __CFDictionary *v8;
  const __CFString *Value;
  __CFString *v10;
  const __CFURL *v11;
  uint64_t v12;
  const __CFString *v13;
  CFTypeRef v14;
  const __CFString *v16;
  const __CFString *v17;
  CFTypeRef cf;
  const __CFString *v19;

  v19 = a2;
  cf = 0;
  if (a4 && *a4)
  {
    CFRelease(*a4);
    *a4 = 0;
  }
  if (!a1)
  {
    v16 = CFSTR("amfdr is NULL");
LABEL_36:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPChallengeClaim", v16, (char)cf);
    Value = 0;
LABEL_39:
    AMFDRSetOption(a1, CFSTR("UseSikDataInstance"), Value);
    return 0;
  }
  v8 = *(const __CFDictionary **)(a1 + 16);
  if (!v8)
  {
    v16 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_36;
  }
  if (!a2)
  {
    v16 = CFSTR("dataClassStr is NULL");
    goto LABEL_36;
  }
  if (!a3)
  {
    v16 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_36;
  }
  if (!*(_QWORD *)(a1 + 96))
  {
    v16 = CFSTR("amfdr->challengeCallbacks is NULL");
    goto LABEL_36;
  }
  Value = (const __CFString *)CFDictionaryGetValue(v8, CFSTR("UseSikDataInstance"));
  AMFDRSetOption(a1, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD268]);
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPChallengeClaim", CFSTR("AMFDRDataHTTPLoadPersistent failed"), (char)cf);
    goto LABEL_39;
  }
  v10 = _AMFDRCreateUrlWithKey(a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/claim"), (uint64_t)a2, a3);
  if (!v10)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPChallengeClaim", CFSTR("serverURL is NULL"), (char)cf);
    goto LABEL_39;
  }
  v11 = (const __CFURL *)v10;
  if (a4 && *a4)
  {
    CFRelease(*a4);
    *a4 = 0;
  }
  v12 = *(_QWORD *)(a1 + 96);
  if (v12)
  {
    while (1)
    {
      if (!*(_QWORD *)v12)
      {
        v13 = CFSTR("exeNode->dataClass is NULL");
        goto LABEL_20;
      }
      if (!*(_QWORD *)(v12 + 8))
      {
        v13 = CFSTR("exeNode->callback is NULL");
        goto LABEL_20;
      }
      if (CFStringCompare(*(CFStringRef *)v12, a2, 0) == kCFCompareEqualTo)
        break;
      v12 = *(_QWORD *)(v12 + 16);
      if (!v12)
        goto LABEL_19;
    }
    AMSupportLogInternal();
    if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, v11, (uint64_t)CFSTR("ChallengeClaim"), CFSTR("GET"), 0, 0, &cf, 0, *(_QWORD *)(v12 + 8), 0, 0, (uint64_t)&v19, a4) & 1) != 0)
    {
      if (cf)
      {
        if ((_AMFDRSavePersistentCookie(a1, (uint64_t)a4) & 1) != 0)
        {
          v14 = CFRetain(cf);
          goto LABEL_26;
        }
        v17 = CFSTR("_AMFDRSavePersistentCookie failed");
      }
      else
      {
        v17 = CFSTR("AMFDRDataHTTPChallengeClaim failed: httpReturnData is NULL");
      }
    }
    else
    {
      v17 = CFSTR("AMFDRDataHTTPChallengeClaim failed");
    }
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPChallengeClaim", v17, (char)cf);
  }
  else
  {
LABEL_19:
    v13 = CFSTR("AMFDRDataHTTPChallengeClaim cannot find the callback funtion.");
LABEL_20:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPChallengeClaim", v13, (char)cf);
  }
  v14 = 0;
LABEL_26:
  AMFDRSetOption(a1, CFSTR("UseSikDataInstance"), Value);
  CFRelease(v11);
  if (cf)
    CFRelease(cf);
  return v14;
}

uint64_t AMFDRDataHTTPCopyDigest(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCopyDigest", CFSTR("AMFDRDataHTTPCopyDigest is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataHTTPPresent(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  __CFString *v8;
  const __CFURL *v9;
  const __CFString *v11;
  char v12;

  if (a4 && *a4)
  {
    CFRelease(*a4);
    *a4 = 0;
  }
  if (!a1)
  {
    v11 = CFSTR("amfdr is NULL");
LABEL_30:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPresent", v11, v12);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v11 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_30;
  }
  if (!a2)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPresent", CFSTR("dataClassStr is NULL"), v12);
    return a2;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPresent", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v12);
    return 0;
  }
  v8 = _AMFDRCreateUrlWithKey(a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/data"), a2, a3);
  if (!v8)
  {
    v11 = CFSTR("serverURL is NULL");
    goto LABEL_30;
  }
  v9 = (const __CFURL *)v8;
  if (a4)
  {
    if (*a4)
    {
      CFRelease(*a4);
      *a4 = 0;
    }
    if (_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, v9, (uint64_t)CFSTR("Present"), CFSTR("HEAD"), 0, 0, 0, 0, 0, 0, 0, 0, a4))
    {
      if (*a4)
      {
        AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPresent", CFSTR("_AMFDRHttpRequestSendSync returned success but outError is not NULL"), v12);
LABEL_33:
        a2 = 0;
        goto LABEL_23;
      }
      goto LABEL_16;
    }
  }
  else if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v8, (uint64_t)CFSTR("Present"), CFSTR("HEAD"), 0, 0, 0, 0, 0, 0, 0, 0, 0) & 1) != 0)
  {
LABEL_16:
    a2 = 1;
    goto LABEL_22;
  }
  if (AMFDRGetUnderlyingErrorCode(a1, (CFErrorRef *)a4) == 404 && (AMSupportLogInternal(), a4) && *a4)
  {
    CFRelease(*a4);
    a2 = 0;
    *a4 = 0;
  }
  else
  {
    a2 = 0;
  }
LABEL_22:
  if ((_AMFDRSavePersistentCookie(a1, (uint64_t)a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPresent", CFSTR("_AMFDRSavePersistentCookie failed"), v12);
    goto LABEL_33;
  }
LABEL_23:
  CFRelease(v9);
  return a2;
}

CFTypeRef AMFDRDataHTTPCopy(__CFString *cf, const __CFString *a2, const __CFString *a3, CFTypeRef *a4)
{
  const __CFString *PermissionsString;
  const __CFString *v9;
  __CFString *v10;
  const __CFURL *v11;
  CFTypeRef v12;
  const __CFString *v14;
  const __CFString *v15;
  char v16;
  CFTypeRef v17;

  v17 = 0;
  if (a4 && *a4)
  {
    CFRelease(*a4);
    *a4 = 0;
  }
  if (!cf)
  {
    v14 = CFSTR("amfdr is NULL");
LABEL_29:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCopy", v14, v16);
    return 0;
  }
  if (!cf->data)
  {
    v14 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_29;
  }
  if (!a2)
  {
    v14 = CFSTR("dataClassStr is NULL");
    goto LABEL_29;
  }
  if (!a3)
  {
    v14 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_29;
  }
  PermissionsString = AMFDRDataCreatePermissionsString(cf, 0, a2, a3);
  if (!PermissionsString)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCopy", CFSTR("AMFDRDataCreatePermissionsString failed"), v16);
    return 0;
  }
  v9 = PermissionsString;
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)cf, a4) & 1) != 0)
  {
    v10 = _AMFDRCreateUrlWithKey((uint64_t)cf, CFSTR("DSURL"), (uint64_t)CFSTR("dm/data"), (uint64_t)a2, a3);
    if (v10)
    {
      v11 = (const __CFURL *)v10;
      if (a4 && *a4)
      {
        CFRelease(*a4);
        *a4 = 0;
      }
      if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)cf, v11, (uint64_t)CFSTR("Copy"), CFSTR("GET"), 0, 0, &v17, 0, 0, v9, 0, 0, a4) & 1) != 0)
      {
        if (v17)
        {
          if (a4 && *a4)
          {
            CFRelease(*a4);
            *a4 = 0;
          }
          if ((_AMFDRSavePersistentCookie((uint64_t)cf, (uint64_t)a4) & 1) != 0)
          {
            v12 = CFRetain(v17);
            goto LABEL_21;
          }
          v15 = CFSTR("_AMFDRSavePersistentCookie failed");
        }
        else
        {
          v15 = CFSTR("AMFDRDataHTTPCopy failed: outValueData is NULL");
        }
      }
      else
      {
        v15 = CFSTR("AMFDRDataHTTPCopy failed");
      }
      AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCopy", v15, v16);
      v12 = 0;
LABEL_21:
      CFRelease(v11);
      if (v17)
      {
        CFRelease(v17);
        v17 = 0;
      }
      goto LABEL_23;
    }
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCopy", CFSTR("serverURL is NULL"), v16);
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCopy", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v16);
  }
  v12 = 0;
LABEL_23:
  CFRelease(v9);
  return v12;
}

uint64_t AMFDRDataHTTPPutWithOptions(uint64_t a1, uint64_t a2, CFStringRef theString, const __CFData *a4, uint64_t a5, CFTypeRef *a6)
{
  __CFString *v12;
  __CFString *v13;
  uint64_t v14;
  const __CFString *v16;
  const __CFString *v17;
  char v18;
  CFRange result;
  _QWORD v20[5];
  CFRange v21;

  v20[4] = *MEMORY[0x24BDAC8D0];
  result.location = 0xAAAAAAAAAAAAAAAALL;
  result.length = 0xAAAAAAAAAAAAAAAALL;
  v20[0] = a2;
  v20[1] = theString;
  v20[2] = a4;
  v20[3] = a5;
  if (!a1)
  {
    v16 = CFSTR("amfdr is NULL");
LABEL_20:
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPutWithOptions", v16, v18);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v16 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_20;
  }
  if (!a2)
  {
    v16 = CFSTR("dataClassStr is NULL");
    goto LABEL_20;
  }
  if (!a4)
  {
    v16 = CFSTR("valueData is NULL");
    goto LABEL_20;
  }
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 136) + 8) & 2) != 0)
  {
    v21.location = 0;
    v21.length = 4;
    if (CFStringFindWithOptions(theString, CFSTR("sik-"), v21, 8uLL, &result))
    {
      AMFDRErrorPushInternal((uint64_t)a6, 403, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPutWithOptions", CFSTR("Station AMFDRDataHTTPPut with sik format is forbidden. %@-%@"), a2);
      return 0;
    }
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a6) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPutWithOptions", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v18);
    return 0;
  }
  v12 = _AMFDRCreateUrlWithKey(a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/data"), a2, theString);
  if (!v12)
  {
    v16 = CFSTR("serverURL is NULL");
    goto LABEL_20;
  }
  v13 = v12;
  if (!_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v12, (uint64_t)CFSTR("Put"), CFSTR("PUT"), 0, a4, 0, 0, 0, 0, (uint64_t (*)(CFDictionaryRef *, uint64_t, CFTypeRef *))_AMFDRDataHTTPCopyForPut, (uint64_t)v20, a6))
  {
    v17 = CFSTR("AMFDRDataHTTPPut failed");
LABEL_24:
    AMFDRErrorPushInternal((uint64_t)a6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPutWithOptions", v17, v18);
    v14 = 0;
    goto LABEL_12;
  }
  if ((_AMFDRSavePersistentCookie(a1, (uint64_t)a6) & 1) == 0)
  {
    v17 = CFSTR("_AMFDRSavePersistentCookie failed");
    goto LABEL_24;
  }
  v14 = 1;
LABEL_12:
  CFRelease(v13);
  return v14;
}

uint64_t AMFDRDataHTTPDelete(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  __CFString *v8;
  __CFString *v9;
  uint64_t v10;
  const __CFString *v12;
  const __CFString *v13;
  char v14;

  if (!a1)
  {
    v12 = CFSTR("amfdr is NULL");
LABEL_16:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPDelete", v12, v14);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v12 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_16;
  }
  if (!a2)
  {
    v12 = CFSTR("dataClassStr is NULL");
    goto LABEL_16;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPDelete", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v14);
    return 0;
  }
  v8 = _AMFDRCreateUrlWithKey(a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/data"), a2, a3);
  if (!v8)
  {
    v12 = CFSTR("serverURL is NULL");
    goto LABEL_16;
  }
  v9 = v8;
  if (!_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v8, (uint64_t)CFSTR("Delete"), CFSTR("DELETE"), 0, 0, 0, 0, 0, 0, 0, 0, a4))
  {
    v13 = CFSTR("AMFDRDataHTTPDelete failed");
LABEL_20:
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPDelete", v13, v14);
    v10 = 0;
    goto LABEL_9;
  }
  if ((_AMFDRSavePersistentCookie(a1, (uint64_t)a4) & 1) == 0)
  {
    v13 = CFSTR("_AMFDRSavePersistentCookie failed");
    goto LABEL_20;
  }
  v10 = 1;
LABEL_9:
  CFRelease(v9);
  return v10;
}

uint64_t AMFDRDataHTTPPrefetch(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  __CFString *v8;
  __CFString *v9;
  uint64_t v10;
  const __CFString *v12;
  const __CFString *v13;
  char v14;

  if (!a1)
  {
    v12 = CFSTR("amfdr is NULL");
LABEL_16:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPrefetch", v12, v14);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v12 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_16;
  }
  if (!a2)
  {
    v12 = CFSTR("dataClassStr is NULL");
    goto LABEL_16;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPrefetch", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v14);
    return 0;
  }
  v8 = _AMFDRCreateUrlWithKey(a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/export"), a2, a3);
  if (!v8)
  {
    v12 = CFSTR("serverURL is NULL");
    goto LABEL_16;
  }
  v9 = v8;
  if (!_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v8, (uint64_t)CFSTR("Present"), CFSTR("POST"), 0, 0, 0, 0, 0, 0, 0, 0, a4))
  {
    v13 = CFSTR("AMFDRDataHTTPPrefetch failed");
LABEL_20:
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPrefetch", v13, v14);
    v10 = 0;
    goto LABEL_9;
  }
  if ((_AMFDRSavePersistentCookie(a1, (uint64_t)a4) & 1) == 0)
  {
    v13 = CFSTR("_AMFDRSavePersistentCookie failed");
    goto LABEL_20;
  }
  v10 = 1;
LABEL_9:
  CFRelease(v9);
  return v10;
}

uint64_t AMFDRDataHTTPExport(CFDataRef *a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  __CFString *v8;
  const __CFURL *v9;
  __CFString *Value;
  __CFString *v11;
  CFTypeID v12;
  __CFString *v13;
  const __CFAllocator *v14;
  const __CFURL *v15;
  CFTypeID v16;
  CFIndex Count;
  CFIndex v18;
  CFIndex v19;
  const void *ValueAtIndex;
  CFTypeID v21;
  CFDictionaryRef v22;
  uint64_t v23;
  const __CFString *v24;
  const __CFString *v26;
  const __CFString *v27;
  char v28;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v26 = CFSTR("amfdr is NULL");
LABEL_38:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPExport", v26, v28);
    return 0;
  }
  if (!a1[2])
  {
    v26 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_38;
  }
  if (!a2)
  {
    v26 = CFSTR("dataClassStr is NULL");
    goto LABEL_38;
  }
  if ((AMFDRDataHTTPLoadPersistent(a1, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPExport", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v28);
    return 0;
  }
  v8 = _AMFDRCreateUrlWithKey((uint64_t)a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/export"), a2, a3);
  if (!v8)
  {
    v26 = CFSTR("serverURL is NULL");
    goto LABEL_38;
  }
  v9 = (const __CFURL *)v8;
  Value = (__CFString *)CFDictionaryGetValue(a1[2], CFSTR("ExportDestination"));
  v11 = Value;
  if (!Value)
  {
    v15 = 0;
    goto LABEL_20;
  }
  v12 = CFGetTypeID(Value);
  if (v12 == CFStringGetTypeID())
  {
    v13 = (__CFString *)CFRetain(v11);
    if (v13)
    {
      v11 = v13;
      v14 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      goto LABEL_18;
    }
    goto LABEL_26;
  }
  v16 = CFGetTypeID(v11);
  if (v16 != CFArrayGetTypeID())
  {
LABEL_26:
    v24 = CFSTR("export destination has wrong type");
LABEL_27:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPExport", v24, v28);
    v23 = 0;
    v11 = 0;
LABEL_28:
    v15 = v9;
    goto LABEL_29;
  }
  Count = CFArrayGetCount((CFArrayRef)v11);
  if (Count >= 1)
  {
    v18 = Count;
    v19 = 0;
    while (CFArrayGetValueAtIndex((CFArrayRef)v11, v19))
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v11, v19);
      v21 = CFGetTypeID(ValueAtIndex);
      if (v21 != CFStringGetTypeID())
        break;
      if (v18 == ++v19)
        goto LABEL_17;
    }
    v24 = CFSTR("malformed export destination");
    goto LABEL_27;
  }
LABEL_17:
  v14 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v11 = (__CFString *)CFStringCreateByCombiningStrings((CFAllocatorRef)*MEMORY[0x24BDBD240], (CFArrayRef)v11, CFSTR(","));
  if (!v11)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPExport", CFSTR("exportDestination is NULL"), v28);
    goto LABEL_45;
  }
LABEL_18:
  values = v11;
  keys[0] = CFSTR("x-fdr-internal-export-destination");
  v22 = CFDictionaryCreate(v14, (const void **)keys, (const void **)&values, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v22)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPExport", CFSTR("Unable to create HTTP header extension dictionary"), v28);
LABEL_45:
    v23 = 0;
    goto LABEL_28;
  }
  v15 = v22;
LABEL_20:
  if (_AMFDRHttpRequestSendSync(a1, v9, (uint64_t)CFSTR("Export"), CFSTR("PUT"), v15, 0, 0, 0, 0, 0, 0, 0, a4))
  {
    if ((_AMFDRSavePersistentCookie((uint64_t)a1, (uint64_t)a4) & 1) != 0)
    {
      v23 = 1;
      goto LABEL_23;
    }
    v27 = CFSTR("_AMFDRSavePersistentCookie failed");
  }
  else
  {
    v27 = CFSTR("AMFDRDataHTTPExport failed");
  }
  AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPExport", v27, v28);
  v23 = 0;
LABEL_23:
  CFRelease(v9);
  if (!v15)
  {
    if (!v11)
      return v23;
    goto LABEL_30;
  }
LABEL_29:
  CFRelease(v15);
  if (v11)
LABEL_30:
    CFRelease(v11);
  return v23;
}

uint64_t AMFDRDataHTTPCopyTrustObject(CFDictionaryRef *a1, const __CFString *a2, CFTypeRef *a3, CFTypeRef *a4)
{
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *Value;
  const __CFDictionary *v10;
  const __CFAllocator *v11;
  uint64_t v12;
  const void *v13;
  const __CFString *v14;
  const __CFAllocator *v15;
  const __CFURL *v16;
  const __CFURL *v17;
  uint64_t v18;
  const __CFString *v20;
  char v21;

  if (a2)
  {
    v7 = a2;
    if (!a1)
    {
      v8 = CFSTR("amfdr is NULL");
LABEL_28:
      AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCopyTrustObject", v8, v21);
      return 0;
    }
  }
  else
  {
    Value = (const __CFString *)CFDictionaryGetValue(a1[2], CFSTR("TrustObjectURL"));
    if (Value)
      v7 = Value;
    else
      v7 = CFSTR("http://gg.apple.com/fdrtrustobject");
  }
  v10 = a1[2];
  if (!v10)
  {
    v8 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_28;
  }
  if (CFDictionaryGetValue(v10, CFSTR("TrustObjectDigest")))
  {
    v11 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v12 = AMSupportCopyHexStringFromData();
    if (!v12)
    {
      v8 = CFSTR("Failed to convert trust object digest to hex");
      goto LABEL_28;
    }
    v13 = (const void *)v12;
    v14 = CFStringCreateWithFormat(v11, 0, CFSTR("%@/%@"), v7, v12);
  }
  else
  {
    v14 = (const __CFString *)CFRetain(v7);
    v13 = 0;
  }
  v15 = CFGetAllocator(a1);
  v16 = CFURLCreateWithString(v15, v14, 0);
  if (v16)
  {
    v17 = v16;
    if (_AMFDRHttpRequestSendSync(a1, v16, (uint64_t)CFSTR("CopyTrustObject"), CFSTR("GET"), 0, 0, a3, 0, 0, 0, 0, 0, a4))
    {
      if (*a3)
      {
        v18 = 1;
        goto LABEL_16;
      }
      v20 = CFSTR("AMFDRDataHTTPCopyTrustObject failed: outValueData is NULL");
    }
    else
    {
      v20 = CFSTR("AMFDRDataHTTPCopyTrustObject failed");
    }
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCopyTrustObject", v20, v21);
    v18 = 0;
LABEL_16:
    CFRelease(v17);
    if (!v14)
      goto LABEL_18;
    goto LABEL_17;
  }
  AMFDRErrorPushInternal((uint64_t)a4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCopyTrustObject", CFSTR("AMFDRDataHTTPCopyTrustObject failed: serverURL is NULL"), v21);
  v18 = 0;
  if (v14)
LABEL_17:
    CFRelease(v14);
LABEL_18:
  if (v13)
    CFRelease(v13);
  return v18;
}

uint64_t AMFDRDataHTTPPutTrustObject(int a1, int a2, uint64_t a3)
{
  char vars0;

  AMFDRErrorPushInternal(a3, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPutTrustObject", CFSTR("No implementation in AMFDRDataHTTP module"), vars0);
  return 0;
}

uint64_t AMFDRDataHTTPIterate(int a1, int a2, uint64_t a3)
{
  char vars0;

  AMFDRErrorPushInternal(a3, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPIterate", CFSTR("No implementation in AMFDRDataHTTP module"), vars0);
  return 0;
}

CFTypeRef AMFDRDataHTTPMake(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  __CFString *v8;
  const __CFURL *v9;
  CFTypeRef v10;
  const __CFString *v12;
  const __CFString *v13;
  char v14;
  CFTypeRef v15;

  v15 = 0;
  if (a4 && *a4)
  {
    CFRelease(*a4);
    *a4 = 0;
  }
  if (!a1)
  {
    v12 = CFSTR("amfdr is NULL");
LABEL_29:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMake", v12, v14);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v12 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_29;
  }
  if (!a2)
  {
    v12 = CFSTR("dataClassStr is NULL");
    goto LABEL_29;
  }
  if (!a3)
  {
    v12 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_29;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMake", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v14);
    return 0;
  }
  v8 = _AMFDRCreateUrlWithKey(a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/make"), a2, a3);
  if (!v8)
  {
    v12 = CFSTR("serverURL is NULL");
    goto LABEL_29;
  }
  v9 = (const __CFURL *)v8;
  if (a4 && *a4)
  {
    CFRelease(*a4);
    *a4 = 0;
  }
  if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, v9, (uint64_t)CFSTR("Make"), CFSTR("GET"), 0, 0, &v15, 0, 0, 0, 0, 0, a4) & 1) != 0)
  {
    if (v15)
    {
      if (a4 && *a4)
      {
        CFRelease(*a4);
        *a4 = 0;
      }
      if ((_AMFDRSavePersistentCookie(a1, (uint64_t)a4) & 1) != 0)
      {
        v10 = CFRetain(v15);
        goto LABEL_20;
      }
      v13 = CFSTR("_AMFDRSavePersistentCookie failed");
    }
    else
    {
      v13 = CFSTR("AMFDRDataHTTPMake failed: outValueData is NULL");
    }
  }
  else
  {
    v13 = CFSTR("AMFDRDataHTTPMake failed");
  }
  AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMake", v13, v14);
  v10 = 0;
LABEL_20:
  CFRelease(v9);
  if (v15)
    CFRelease(v15);
  return v10;
}

__CFString *AMFDRDataHTTPMultiCopy(__CFString *a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4)
{
  return _AMFDRDataHTTPMultiCopyInternal(a1, a2, a3, 0, a4);
}

uint64_t AMFDRDataHTTPMultiPutWithOptions(__CFString *a1, CFArrayRef theArray, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, CFTypeRef *a6)
{
  __int128 v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v11;
  const __CFAllocator *v12;
  CFStringRef v13;
  CFMutableArrayRef v14;
  CFMutableArrayRef v15;
  CFMutableArrayRef Mutable;
  const __CFArray *v17;
  const __CFData *v18;
  const CFArrayCallBacks *v19;
  const __CFAllocator *v20;
  const __CFAllocator *v21;
  const __CFAllocator *v22;
  const __CFAllocator *v23;
  CFMutableArrayRef v24;
  unsigned int v25;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const __CFString *v28;
  const __CFString *v29;
  uint64_t v30;
  const __CFArray *v31;
  const void *v32;
  const __CFAllocator *v33;
  CFStringRef FullKey;
  CFTypeRef *v35;
  const __CFAllocator *v36;
  CFMutableArrayRef v37;
  const UInt8 *BytePtr;
  unsigned int Length;
  const __CFString *v40;
  uint64_t v42;
  CFIndex v43;
  const __CFString *v44;
  const __CFString *v45;
  uint64_t v46;
  const __CFString *v47;
  void *value[2];
  void *valuea[2];
  void *v50[2];
  void *v51[2];
  void *v52[2];
  void *v53[2];
  const __CFString *format;
  const __CFString *formata;
  char v56;
  __CFString *v57;
  CFMutableDictionaryRef theDict;
  unsigned int v60;
  CFMutableArrayRef cf;
  __CFArray *v62;
  __CFArray *v63;
  __CFArray *v64;
  CFIndex v65;
  CFRange result;
  int v69;
  char v70;
  CFTypeRef v71;
  __int128 v72;
  __int128 v73;
  int *v74;
  uint64_t v75;
  CFRange v76;
  CFRange v77;

  v75 = *MEMORY[0x24BDAC8D0];
  v71 = 0;
  v70 = 0;
  v74 = (int *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v72 = v6;
  v73 = v6;
  v69 = 5;
  if (!a1)
  {
    v45 = CFSTR("amfdr is NULL");
LABEL_125:
    formata = v45;
    *(_OWORD *)v51 = 0u;
    *(_OWORD *)v53 = 0u;
    *(_OWORD *)valuea = 0u;
    v46 = (uint64_t)a6;
LABEL_130:
    AMFDRErrorPushInternal(v46, 1, 0, 0, 0, 0, 0, 0, valuea[0], valuea[1], v51[0], v51[1], v53[0], v53[1], (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", formata, v56);
LABEL_131:
    v17 = 0;
    Mutable = 0;
    v15 = 0;
    v14 = 0;
    cf = 0;
    v30 = 0;
    goto LABEL_86;
  }
  v7 = theArray;
  if (!theArray)
  {
    v45 = CFSTR("dataClassArray is NULL");
    goto LABEL_125;
  }
  if (!a3)
  {
    v45 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_125;
  }
  if (!a4)
  {
    v45 = CFSTR("valueDataArray is NULL");
    goto LABEL_125;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v47 = CFSTR("Invalid dataClassArray count");
LABEL_129:
    formata = v47;
    *(_OWORD *)v51 = 0u;
    *(_OWORD *)v53 = 0u;
    *(_OWORD *)valuea = 0u;
    v46 = (uint64_t)a6;
    goto LABEL_130;
  }
  v11 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v47 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_129;
  }
  if (CFArrayGetCount(a4) != v11)
  {
    v47 = CFSTR("Invalid dataValueArray count");
    goto LABEL_129;
  }
  v12 = CFGetAllocator(a1);
  theDict = CFDictionaryCreateMutable(v12, v11, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", CFSTR("multiRequestErrors is NULL"), v56);
    goto LABEL_131;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a6) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v56);
LABEL_135:
    CFRelease(theDict);
    goto LABEL_131;
  }
  v57 = _AMFDRCreateUrlWithKey((uint64_t)a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/bulk/data"), 0, 0);
  if (!v57)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", CFSTR("serverURL is NULL"), v56);
    goto LABEL_135;
  }
  if (!_AMFDRGetMultiRequestMaxAttempts((uint64_t)a1))
  {
    v18 = 0;
    v17 = 0;
    Mutable = 0;
    v15 = 0;
    v14 = 0;
    cf = 0;
    v13 = 0;
    goto LABEL_72;
  }
  v65 = v11;
  v13 = 0;
  v60 = 0;
  cf = 0;
  v14 = 0;
  v15 = 0;
  Mutable = 0;
  v17 = 0;
  v18 = 0;
  do
  {
    if (Mutable)
      CFRelease(Mutable);
    if (v15)
      CFRelease(v15);
    if (v14)
      CFRelease(v14);
    if (v18)
      CFRelease(v18);
    v19 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
    if (v71)
    {
      CFRelease(v71);
      v71 = 0;
    }
    if (cf)
      CFRelease(cf);
    v20 = CFGetAllocator(a1);
    Mutable = CFArrayCreateMutable(v20, 0, v19);
    if (!Mutable)
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", CFSTR("dataClassToRequest is NULL"), v56);
      v18 = 0;
      v15 = 0;
LABEL_102:
      v14 = 0;
LABEL_116:
      cf = 0;
      goto LABEL_117;
    }
    v21 = CFGetAllocator(a1);
    v15 = CFArrayCreateMutable(v21, 0, v19);
    if (!v15)
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", CFSTR("dataInstanceToRequest is NULL"), v56);
      v18 = 0;
      goto LABEL_102;
    }
    v22 = CFGetAllocator(a1);
    v14 = CFArrayCreateMutable(v22, 0, v19);
    if (!v14)
    {
      v44 = CFSTR("valueToRequest is NULL");
      goto LABEL_115;
    }
    if (a5)
    {
      v23 = CFGetAllocator(a1);
      v24 = CFArrayCreateMutable(v23, 0, MEMORY[0x24BDBD690]);
      if (!v24)
      {
        v44 = CFSTR("optionsToRequest is NULL");
LABEL_115:
        AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", v44, v56);
        v18 = 0;
        goto LABEL_116;
      }
    }
    else
    {
      v24 = 0;
    }
    cf = v24;
    v62 = Mutable;
    v63 = v14;
    v64 = v15;
    if (v60)
    {
      v25 = _AMFDRGetMultiRequestBackoff((uint64_t)a1) * v60;
      AMSupportLogInternal();
      sleep(v25);
    }
    for (i = 0; i != v65; ++i)
    {
      if (v13)
        CFRelease(v13);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, i);
      if (!ValueAtIndex)
      {
        v40 = CFSTR("dataClassStr is NULL");
        goto LABEL_80;
      }
      v28 = ValueAtIndex;
      if (!CFStringGetLength(ValueAtIndex))
      {
        v40 = CFSTR("dataClassStr length is 0");
        goto LABEL_80;
      }
      v29 = (const __CFString *)CFArrayGetValueAtIndex(a3, i);
      v18 = (const __CFData *)v29;
      if (!v29)
      {
        AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", CFSTR("dataInstanceStr is NULL"), v56);
        goto LABEL_82;
      }
      if ((*(_BYTE *)(a1[4].info + 8) & 2) != 0)
      {
        result.location = 0xAAAAAAAAAAAAAAAALL;
        result.length = 0xAAAAAAAAAAAAAAAALL;
        v77.location = 0;
        v77.length = 4;
        if (CFStringFindWithOptions(v29, CFSTR("sik-"), v77, 8uLL, &result))
        {
          AMFDRErrorPushInternal((uint64_t)a6, 403, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", CFSTR("Station AMFDRDataHTTPMultiPut with sik format is forbidden. %@-%@"), (char)v28);
LABEL_81:
          v18 = 0;
LABEL_82:
          v30 = 0;
LABEL_83:
          Mutable = v62;
          v14 = v63;
          v15 = v64;
          goto LABEL_84;
        }
      }
      v30 = (uint64_t)CFArrayGetValueAtIndex(a4, i);
      if (!v30)
      {
        AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", CFSTR("valueData is NULL"), v56);
        v18 = 0;
        goto LABEL_83;
      }
      v31 = v7;
      if (a5)
      {
        v32 = CFArrayGetValueAtIndex(a5, i);
        if (!v32)
        {
          v40 = CFSTR("options is NULL");
LABEL_80:
          AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", v40, v56);
          goto LABEL_81;
        }
      }
      else
      {
        v32 = 0;
      }
      v33 = CFGetAllocator(a1);
      FullKey = AMFDRDataLocalCreateFullKey(v33, (uint64_t)v28, (uint64_t)v18);
      if (!FullKey)
      {
        AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", CFSTR("currDataInstance is NULL"), v56);
        goto LABEL_81;
      }
      v13 = FullKey;
      if (v17)
      {
        v76.length = CFArrayGetCount(v17);
        v76.location = 0;
        if (!CFArrayContainsValue(v17, v76, v13))
          goto LABEL_53;
        CFDictionaryRemoveValue(theDict, v13);
        AMSupportLogInternal();
      }
      CFArrayAppendValue(v62, v28);
      CFArrayAppendValue(v64, v18);
      CFArrayAppendValue(v63, (const void *)v30);
      if (a5)
        CFArrayAppendValue(cf, v32);
LABEL_53:
      v7 = v31;
    }
    v35 = a6;
    Mutable = v62;
    v14 = v63;
    v15 = v64;
    v18 = AMFDRDataHTTPCreateMultiRequest(a1, 2u, v62, v64, v63, cf, 0, 0, (uint64_t)a6);
    if (!v18)
    {
      format = CFSTR("httpRequestData is NULL");
      *(_OWORD *)v50 = 0u;
      *(_OWORD *)v52 = 0u;
      *(_OWORD *)value = 0u;
      v42 = (uint64_t)a6;
      goto LABEL_108;
    }
    if (a6 && *a6)
    {
      CFRelease(*a6);
      v35 = a6;
      *a6 = 0;
    }
    *(_QWORD *)&v72 = v62;
    *((_QWORD *)&v72 + 1) = v64;
    *(_QWORD *)&v73 = v63;
    *((_QWORD *)&v73 + 1) = cf;
    if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v57, (uint64_t)CFSTR("MultiPut"), CFSTR("POST"), 0, v18, &v71, 0, 0, 0, (uint64_t (*)(CFDictionaryRef *, uint64_t, CFTypeRef *))AMFDRDataHTTPMultiCopyForPut, (uint64_t)&v72, v35) & 1) == 0|| v35 && *v35)
    {
      AMSupportLogInternal();
LABEL_120:
      v30 = 0;
LABEL_74:
      CFRelease(v13);
      goto LABEL_84;
    }
    if (!v71)
    {
      format = CFSTR("_AMFDRHttpRequestSendSync failed: httpReturnData is NULL");
      *(_OWORD *)v50 = 0u;
      *(_OWORD *)v52 = 0u;
      *(_OWORD *)value = 0u;
      v42 = (uint64_t)v35;
      goto LABEL_113;
    }
    if (v17)
      CFRelease(v17);
    v36 = CFGetAllocator(a1);
    v37 = CFArrayCreateMutable(v36, 0, MEMORY[0x24BDBD690]);
    v17 = v37;
    if (!v37)
    {
      format = CFSTR("dataClassInstanceToRetry is NULL");
      *(_OWORD *)v50 = 0u;
      *(_OWORD *)v52 = 0u;
      *(_OWORD *)value = 0u;
      v42 = (uint64_t)a6;
LABEL_108:
      v43 = 2;
LABEL_114:
      AMFDRErrorPushInternal(v42, v43, 0, 0, 0, 0, 0, 0, value[0], value[1], v50[0], v50[1], v52[0], v52[1], (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", format, v56);
      goto LABEL_120;
    }
    v72 = (unint64_t)a1;
    *(_QWORD *)&v73 = theDict;
    *((_QWORD *)&v73 + 1) = v37;
    v74 = &v69;
    BytePtr = CFDataGetBytePtr((CFDataRef)v71);
    Length = CFDataGetLength((CFDataRef)v71);
    if (AMFDRDecodeMultiResponse((uint64_t)BytePtr, Length, &v70, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t))_AMFDRHttpMultiResponseCallback, (uint64_t)&v72))
    {
      format = CFSTR("AMFDRDecodeMultiResponse failed");
      *(_OWORD *)v50 = 0u;
      *(_OWORD *)v52 = 0u;
      *(_OWORD *)value = 0u;
      v42 = (uint64_t)a6;
LABEL_111:
      v43 = 12;
      goto LABEL_114;
    }
    if (v70 != 2)
    {
      v56 = v70;
      format = CFSTR("actionCode returned is %d");
      *(_OWORD *)v50 = 0u;
      *(_OWORD *)v52 = 0u;
      *(_OWORD *)value = 0u;
      v42 = (uint64_t)a6;
      goto LABEL_111;
    }
    if ((_AMFDRSavePersistentCookie((uint64_t)a1, (uint64_t)a6) & 1) == 0)
    {
      format = CFSTR("_AMFDRSavePersistentCookie failed");
      *(_OWORD *)v50 = 0u;
      *(_OWORD *)v52 = 0u;
      *(_OWORD *)value = 0u;
      v42 = (uint64_t)a6;
LABEL_113:
      v43 = 8;
      goto LABEL_114;
    }
    if (!CFArrayGetCount(v17))
      break;
    ++v60;
  }
  while (v60 < _AMFDRGetMultiRequestMaxAttempts((uint64_t)a1));
LABEL_72:
  if (CFDictionaryGetCount(theDict))
  {
    AMFDRErrorPushInternal((uint64_t)a6, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiPutWithOptions", CFSTR("got multiRequestErrors"), v56);
LABEL_117:
    v30 = 0;
    if (!v13)
      goto LABEL_84;
    goto LABEL_74;
  }
  v30 = 1;
  if (v13)
    goto LABEL_74;
LABEL_84:
  CFRelease(theDict);
  CFRelease(v57);
  if (v18)
    CFRelease(v18);
LABEL_86:
  if (v71)
  {
    CFRelease(v71);
    v71 = 0;
  }
  if (v17)
    CFRelease(v17);
  if (Mutable)
    CFRelease(Mutable);
  if (v15)
    CFRelease(v15);
  if (v14)
    CFRelease(v14);
  if (cf)
    CFRelease(cf);
  return v30;
}

uint64_t AMFDRDataHTTPMultiDelete(__CFString *a1, CFArrayRef theArray, const __CFArray *a3, CFTypeRef *a4)
{
  __int128 v5;
  CFIndex Count;
  CFIndex v9;
  const __CFAllocator *v10;
  int v11;
  __CFArray *v12;
  CFMutableArrayRef Mutable;
  const __CFArray *v14;
  const __CFData *v15;
  CFStringRef v16;
  const CFArrayCallBacks *v17;
  const __CFAllocator *v18;
  const __CFAllocator *v19;
  CFMutableArrayRef v20;
  __CFArray *v21;
  __CFArray *v22;
  int v23;
  unsigned int v24;
  CFIndex i;
  const __CFString *ValueAtIndex;
  uint64_t v27;
  const void *v28;
  const void *v29;
  const __CFAllocator *v30;
  CFStringRef FullKey;
  const __CFArray *v32;
  const __CFAllocator *v33;
  CFMutableArrayRef v34;
  const UInt8 *BytePtr;
  unsigned int Length;
  const __CFString *format;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  const __CFString *v42;
  const __CFString *v43;
  char v44;
  CFTypeRef *v45;
  __CFString *v46;
  CFMutableDictionaryRef theDict;
  int v48;
  int v50;
  char v51;
  CFTypeRef cf;
  __int128 v53;
  __int128 v54;
  int *v55;
  uint64_t v56;
  CFRange v57;

  v56 = *MEMORY[0x24BDAC8D0];
  cf = 0;
  v51 = 0;
  v55 = (int *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v53 = v5;
  v54 = v5;
  v50 = 6;
  if (!a1)
  {
    v43 = CFSTR("amfdr is NULL");
LABEL_97:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", v43, v44);
LABEL_102:
    v14 = 0;
    Mutable = 0;
    v12 = 0;
    v27 = 0;
    goto LABEL_66;
  }
  if (!theArray)
  {
    v43 = CFSTR("dataClassArray is NULL");
    goto LABEL_97;
  }
  if (!a3)
  {
    v43 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_97;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v43 = CFSTR("Invalid dataClassArray count");
    goto LABEL_97;
  }
  v9 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v43 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_97;
  }
  v10 = CFGetAllocator(a1);
  theDict = CFDictionaryCreateMutable(v10, v9, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", CFSTR("multiRequestErrors is NULL"), v44);
    goto LABEL_102;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v44);
LABEL_101:
    CFRelease(theDict);
    goto LABEL_102;
  }
  v46 = _AMFDRCreateUrlWithKey((uint64_t)a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/bulk/data"), 0, 0);
  if (!v46)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", CFSTR("serverURL is NULL"), v44);
    goto LABEL_101;
  }
  if (!_AMFDRGetMultiRequestMaxAttempts((uint64_t)a1))
  {
    v16 = 0;
    v15 = 0;
    v14 = 0;
    Mutable = 0;
    v12 = 0;
LABEL_54:
    if (!CFDictionaryGetCount(theDict))
    {
      v27 = 1;
      if (v16)
        goto LABEL_56;
      goto LABEL_64;
    }
    AMFDRErrorPushInternal((uint64_t)a4, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", CFSTR("got multiRequestErrors"), v44);
LABEL_78:
    v27 = 0;
    if (v16)
      goto LABEL_56;
    goto LABEL_64;
  }
  v11 = 0;
  v12 = 0;
  Mutable = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v45 = a4;
  while (1)
  {
    if (Mutable)
      CFRelease(Mutable);
    if (v12)
      CFRelease(v12);
    if (v15)
      CFRelease(v15);
    v17 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    v18 = CFGetAllocator(a1);
    Mutable = CFArrayCreateMutable(v18, 0, v17);
    if (!Mutable)
    {
      v39 = CFSTR("dataClassToRequest is NULL");
LABEL_77:
      AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", v39, v44);
      v15 = 0;
      v12 = 0;
      goto LABEL_78;
    }
    v19 = CFGetAllocator(a1);
    v20 = CFArrayCreateMutable(v19, 0, v17);
    if (!v20)
    {
      v39 = CFSTR("dataInstanceToRequest is NULL");
      goto LABEL_77;
    }
    v21 = v20;
    v22 = Mutable;
    v23 = v11;
    if (v11)
    {
      v24 = _AMFDRGetMultiRequestBackoff((uint64_t)a1) * v11;
      AMSupportLogInternal();
      sleep(v24);
    }
    v48 = v23;
    for (i = 0; i != v9; ++i)
    {
      if (v16)
        CFRelease(v16);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, i);
      v27 = (uint64_t)ValueAtIndex;
      if (!ValueAtIndex)
      {
        AMFDRErrorPushInternal((uint64_t)v45, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", CFSTR("dataClassStr is NULL"), v44);
LABEL_63:
        Mutable = v22;
        v12 = v21;
        v15 = 0;
        goto LABEL_64;
      }
      if (!CFStringGetLength(ValueAtIndex))
      {
        format = CFSTR("dataClassStr length is 0");
        goto LABEL_60;
      }
      v28 = CFArrayGetValueAtIndex(a3, i);
      if (!v28)
      {
        format = CFSTR("dataInstanceStr is NULL");
LABEL_60:
        AMFDRErrorPushInternal((uint64_t)v45, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", format, v44);
LABEL_62:
        v27 = 0;
        goto LABEL_63;
      }
      v29 = v28;
      v30 = CFGetAllocator(a1);
      FullKey = AMFDRDataLocalCreateFullKey(v30, v27, (uint64_t)v29);
      if (!FullKey)
      {
        AMFDRErrorPushInternal((uint64_t)v45, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", CFSTR("currDataInstance is NULL"), v44);
        goto LABEL_62;
      }
      v16 = FullKey;
      if (v14)
      {
        v57.length = CFArrayGetCount(v14);
        v57.location = 0;
        if (!CFArrayContainsValue(v14, v57, v16))
          continue;
        CFDictionaryRemoveValue(theDict, v16);
        AMSupportLogInternal();
      }
      CFArrayAppendValue(v22, (const void *)v27);
      CFArrayAppendValue(v21, v29);
    }
    a4 = v45;
    Mutable = v22;
    v32 = v22;
    v12 = v21;
    v15 = AMFDRDataHTTPCreateMultiRequest(a1, 4u, v32, v21, 0, 0, 0, 0, (uint64_t)v45);
    if (!v15)
    {
      v40 = CFSTR("httpRequestData is NULL");
LABEL_84:
      AMFDRErrorPushInternal((uint64_t)v45, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", v40, v44);
      goto LABEL_91;
    }
    if (v45)
      break;
    if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v46, (uint64_t)CFSTR("MultiDelete"), CFSTR("POST"), 0, v15, &cf, 0, 0, 0, 0, 0, 0) & 1) == 0)goto LABEL_90;
LABEL_43:
    if (!cf)
    {
      v41 = CFSTR("_AMFDRHttpRequestSendSync failed: httpReturnData is NULL");
LABEL_89:
      AMFDRErrorPushInternal((uint64_t)v45, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", v41, v44);
      goto LABEL_91;
    }
    if (v14)
      CFRelease(v14);
    v33 = CFGetAllocator(a1);
    v34 = CFArrayCreateMutable(v33, 0, MEMORY[0x24BDBD690]);
    v14 = v34;
    if (!v34)
    {
      v40 = CFSTR("dataClassInstanceToRetry is NULL");
      goto LABEL_84;
    }
    v53 = (unint64_t)a1;
    *(_QWORD *)&v54 = theDict;
    *((_QWORD *)&v54 + 1) = v34;
    v55 = &v50;
    BytePtr = CFDataGetBytePtr((CFDataRef)cf);
    Length = CFDataGetLength((CFDataRef)cf);
    if (AMFDRDecodeMultiResponse((uint64_t)BytePtr, Length, &v51, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t))_AMFDRHttpMultiResponseCallback, (uint64_t)&v53))
    {
      v42 = CFSTR("AMFDRDecodeMultiResponse failed");
LABEL_87:
      AMFDRErrorPushInternal((uint64_t)v45, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiDelete", v42, v44);
      goto LABEL_91;
    }
    if (v51 != 4)
    {
      v44 = v51;
      v42 = CFSTR("actionCode returned is %d");
      goto LABEL_87;
    }
    if ((_AMFDRSavePersistentCookie((uint64_t)a1, (uint64_t)v45) & 1) == 0)
    {
      v41 = CFSTR("_AMFDRSavePersistentCookie failed");
      goto LABEL_89;
    }
    if (CFArrayGetCount(v14))
    {
      v11 = v48 + 1;
      if (v48 + 1 < _AMFDRGetMultiRequestMaxAttempts((uint64_t)a1))
        continue;
    }
    goto LABEL_54;
  }
  if (*v45)
  {
    CFRelease(*v45);
    *v45 = 0;
  }
  if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v46, (uint64_t)CFSTR("MultiDelete"), CFSTR("POST"), 0, v15, &cf, 0, 0, 0, 0, 0, v45) & 1) != 0&& !*v45)
  {
    goto LABEL_43;
  }
LABEL_90:
  AMSupportLogInternal();
LABEL_91:
  v27 = 0;
LABEL_56:
  CFRelease(v16);
LABEL_64:
  CFRelease(theDict);
  CFRelease(v46);
  if (v15)
    CFRelease(v15);
LABEL_66:
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v14)
    CFRelease(v14);
  if (Mutable)
    CFRelease(Mutable);
  if (v12)
    CFRelease(v12);
  return v27;
}

uint64_t AMFDRDataHTTPMultiExport(uint64_t a1, CFArrayRef theArray, const __CFArray *a3, CFTypeRef *a4)
{
  __int128 v5;
  CFIndex Count;
  CFIndex v9;
  const __CFAllocator *v10;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef value;
  int v13;
  __CFArray *v14;
  CFMutableArrayRef v15;
  const __CFArray *v16;
  const __CFData *v17;
  CFStringRef v18;
  const CFArrayCallBacks *v19;
  const __CFAllocator *v20;
  const __CFAllocator *v21;
  CFMutableArrayRef v22;
  __CFArray *v23;
  __CFArray *v24;
  int v25;
  unsigned int v26;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const __CFString *v29;
  const void *v30;
  const void *v31;
  const __CFAllocator *v32;
  CFStringRef FullKey;
  const void *v34;
  const void *v35;
  CFTypeID v36;
  void *v37;
  uint64_t v38;
  CFTypeID v39;
  CFIndex v40;
  CFIndex v41;
  CFIndex v42;
  const void *v43;
  CFTypeID v44;
  const __CFAllocator *v45;
  CFMutableArrayRef v46;
  const UInt8 *BytePtr;
  unsigned int Length;
  const __CFString *format;
  const __CFString *v51;
  const __CFString *v52;
  const __CFString *v53;
  const __CFString *v54;
  char v55;
  __CFDictionary *v56;
  const __CFAllocator *alloc;
  CFTypeRef v58;
  __CFString *v59;
  int v60[2];
  const __CFData *v61;
  uint64_t v62;
  int v63;
  CFIndex v64;
  int v66;
  char v67;
  CFTypeRef cf;
  void *values;
  void *keys;
  __int128 v71;
  __int128 v72;
  int *v73;
  uint64_t v74;
  CFRange v75;

  v74 = *MEMORY[0x24BDAC8D0];
  cf = 0;
  v67 = 0;
  v73 = (int *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v71 = v5;
  v72 = v5;
  v66 = 7;
  if (!a1)
  {
    v54 = CFSTR("amfdr is NULL");
LABEL_115:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", v54, v55);
    goto LABEL_121;
  }
  if (!theArray)
  {
    v54 = CFSTR("dataClassArray is NULL");
    goto LABEL_115;
  }
  if (!a3)
  {
    v54 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_115;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v54 = CFSTR("Invalid dataClassArray count");
    goto LABEL_115;
  }
  v9 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v54 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_115;
  }
  v10 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFDictionaryCreateMutable(v10, v9, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("multiRequestErrors is NULL"), v55);
LABEL_121:
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v58 = 0;
    v38 = 0;
    goto LABEL_81;
  }
  value = Mutable;
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v55);
LABEL_120:
    CFRelease(value);
    goto LABEL_121;
  }
  v59 = _AMFDRCreateUrlWithKey(a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/bulk/export"), 0, 0);
  if (!v59)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("serverURL is NULL"), v55);
    goto LABEL_120;
  }
  if (!_AMFDRGetMultiRequestMaxAttempts(a1))
  {
    v18 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v58 = 0;
LABEL_69:
    if (!CFDictionaryGetCount(value))
    {
      v38 = 1;
      goto LABEL_71;
    }
    AMFDRErrorPushInternal((uint64_t)a4, 21, 0, 0, 0, 0, 0, 0, value, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("got multiRequestErrors"), v55);
LABEL_107:
    v38 = 0;
    goto LABEL_71;
  }
  v64 = v9;
  v13 = 0;
  v58 = 0;
  *(_QWORD *)v60 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v56 = value;
  alloc = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v62 = (uint64_t)a4;
  while (1)
  {
    if (v15)
      CFRelease(v15);
    if (v14)
      CFRelease(v14);
    if (v17)
      CFRelease(v17);
    v19 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    v20 = CFGetAllocator((CFTypeRef)a1);
    v15 = CFArrayCreateMutable(v20, 0, v19);
    if (!v15)
    {
      v51 = CFSTR("dataClassToRequest is NULL");
LABEL_95:
      AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", v51, v55);
      v17 = 0;
      v14 = 0;
      goto LABEL_107;
    }
    v21 = CFGetAllocator((CFTypeRef)a1);
    v22 = CFArrayCreateMutable(v21, 0, v19);
    if (!v22)
    {
      v51 = CFSTR("dataInstanceToRequest is NULL");
      goto LABEL_95;
    }
    v23 = v22;
    v24 = v15;
    v25 = v13;
    if (v13)
    {
      v26 = _AMFDRGetMultiRequestBackoff(a1) * v13;
      AMSupportLogInternal();
      sleep(v26);
    }
    v63 = v25;
    for (i = 0; i != v64; ++i)
    {
      if (v18)
        CFRelease(v18);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, i);
      if (!ValueAtIndex)
      {
        format = CFSTR("dataClassStr is NULL");
        goto LABEL_76;
      }
      v29 = ValueAtIndex;
      if (!CFStringGetLength(ValueAtIndex))
      {
        format = CFSTR("dataClassStr length is 0");
        goto LABEL_76;
      }
      v30 = CFArrayGetValueAtIndex(a3, i);
      if (!v30)
      {
        format = CFSTR("dataInstanceStr is NULL");
LABEL_76:
        AMFDRErrorPushInternal(v62, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", format, v55);
LABEL_78:
        v38 = 0;
        v15 = v24;
        v17 = 0;
        v14 = v23;
        goto LABEL_79;
      }
      v31 = v30;
      v32 = CFGetAllocator((CFTypeRef)a1);
      FullKey = AMFDRDataLocalCreateFullKey(v32, (uint64_t)v29, (uint64_t)v31);
      if (!FullKey)
      {
        AMFDRErrorPushInternal(v62, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("currDataInstance is NULL"), v55);
        goto LABEL_78;
      }
      v18 = FullKey;
      if (v16)
      {
        v75.length = CFArrayGetCount(v16);
        v75.location = 0;
        if (!CFArrayContainsValue(v16, v75, v18))
          continue;
        CFDictionaryRemoveValue(value, v18);
        AMSupportLogInternal();
      }
      CFArrayAppendValue(v24, v29);
      CFArrayAppendValue(v23, v31);
    }
    v15 = v24;
    v61 = AMFDRDataHTTPCreateMultiRequest((__CFString *)a1, 3u, v24, v23, 0, 0, 0, 0, v62);
    if (!v61)
    {
      AMFDRErrorPushInternal(v62, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("httpRequestData is NULL"), v55);
      v38 = 0;
      v17 = 0;
      v14 = v23;
      goto LABEL_72;
    }
    v34 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("ExportDestination"));
    if (!v34)
    {
      v14 = v23;
      v17 = v61;
      a4 = (CFTypeRef *)v62;
      v38 = *(_QWORD *)v60;
      goto LABEL_51;
    }
    v35 = v34;
    v36 = CFGetTypeID(v34);
    if (v36 == CFStringGetTypeID())
    {
      v37 = (void *)CFRetain(v35);
      goto LABEL_49;
    }
    v39 = CFGetTypeID(v35);
    if (v39 != CFArrayGetTypeID())
    {
      v37 = (void *)v58;
LABEL_49:
      v14 = v23;
      v17 = v61;
      if (!v37)
      {
        AMFDRErrorPushInternal(v62, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("export destination has wrong type"), v55);
        v38 = 0;
        v58 = 0;
        goto LABEL_72;
      }
      goto LABEL_50;
    }
    v40 = CFArrayGetCount((CFArrayRef)v35);
    if (v40 >= 1)
      break;
LABEL_46:
    v37 = (void *)CFStringCreateByCombiningStrings(alloc, (CFArrayRef)v35, CFSTR(","));
    value = v56;
    v15 = v24;
    v14 = v23;
    v17 = v61;
    if (!v37)
    {
      AMFDRErrorPushInternal(v62, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("exportDestination is NULL"), v55);
      v58 = 0;
      goto LABEL_107;
    }
LABEL_50:
    values = v37;
    keys = CFSTR("x-fdr-internal-export-destination");
    v58 = v37;
    v38 = (uint64_t)CFDictionaryCreate(alloc, (const void **)&keys, (const void **)&values, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    a4 = (CFTypeRef *)v62;
    if (!v38)
    {
      AMFDRErrorPushInternal(v62, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("Unable to create HTTP header extension dictionary"), v55);
      goto LABEL_71;
    }
LABEL_51:
    if (a4)
    {
      if (*a4)
      {
        CFRelease(*a4);
        *a4 = 0;
      }
      if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v59, (uint64_t)CFSTR("MultiExport"), CFSTR("POST"), (const void *)v38, v17, &cf, 0, 0, 0, 0, 0, a4) & 1) == 0|| *a4)
      {
LABEL_106:
        AMSupportLogInternal();
        goto LABEL_107;
      }
    }
    else if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v59, (uint64_t)CFSTR("MultiExport"), CFSTR("POST"), (const void *)v38, v17, &cf, 0, 0, 0, 0, 0, 0) & 1) == 0)
    {
      goto LABEL_106;
    }
    if (!cf)
    {
      v52 = CFSTR("_AMFDRHttpRequestSendSync failed: httpReturnData is NULL");
LABEL_104:
      AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", v52, v55);
      goto LABEL_107;
    }
    if (v16)
      CFRelease(v16);
    v45 = CFGetAllocator((CFTypeRef)a1);
    v46 = CFArrayCreateMutable(v45, 0, MEMORY[0x24BDBD690]);
    v16 = v46;
    if (!v46)
    {
      AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("dataClassInstanceToRetry is NULL"), v55);
      goto LABEL_107;
    }
    *(_QWORD *)v60 = v38;
    v71 = (unint64_t)a1;
    *(_QWORD *)&v72 = value;
    *((_QWORD *)&v72 + 1) = v46;
    v73 = &v66;
    BytePtr = CFDataGetBytePtr((CFDataRef)cf);
    Length = CFDataGetLength((CFDataRef)cf);
    if (AMFDRDecodeMultiResponse((uint64_t)BytePtr, Length, &v67, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t))_AMFDRHttpMultiResponseCallback, (uint64_t)&v71))
    {
      v53 = CFSTR("AMFDRDecodeMultiResponse failed");
LABEL_102:
      AMFDRErrorPushInternal((uint64_t)a4, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", v53, v55);
      goto LABEL_107;
    }
    if (v67 != 3)
    {
      v55 = v67;
      v53 = CFSTR("actionCode returned is %d");
      goto LABEL_102;
    }
    if ((_AMFDRSavePersistentCookie(a1, (uint64_t)a4) & 1) == 0)
    {
      v52 = CFSTR("_AMFDRSavePersistentCookie failed");
      goto LABEL_104;
    }
    if (CFArrayGetCount(v16))
    {
      v13 = v63 + 1;
      if (v63 + 1 < _AMFDRGetMultiRequestMaxAttempts(a1))
        continue;
    }
    goto LABEL_69;
  }
  v41 = v40;
  v42 = 0;
  while (CFArrayGetValueAtIndex((CFArrayRef)v35, v42))
  {
    v43 = CFArrayGetValueAtIndex((CFArrayRef)v35, v42);
    v44 = CFGetTypeID(v43);
    if (v44 != CFStringGetTypeID())
      break;
    if (v41 == ++v42)
      goto LABEL_46;
  }
  AMFDRErrorPushInternal(v62, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiExport", CFSTR("malformed export destination"), v55);
  v38 = 0;
  value = v56;
  v15 = v24;
  v14 = v23;
  v17 = v61;
LABEL_71:
  if (v18)
LABEL_72:
    CFRelease(v18);
LABEL_79:
  CFRelease(value);
  CFRelease(v59);
  if (v17)
    CFRelease(v17);
LABEL_81:
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v58)
    CFRelease(v58);
  if (v16)
    CFRelease(v16);
  if (v15)
    CFRelease(v15);
  if (v14)
    CFRelease(v14);
  return v38;
}

CFTypeRef AMFDRDataHTTPMultiMake(__CFString *a1, CFArrayRef theArray, const __CFArray *a3, CFTypeRef *a4)
{
  __int128 v5;
  CFIndex Count;
  CFIndex v10;
  const __CFAllocator *v11;
  CFMutableDictionaryRef Mutable;
  const void *v13;
  const __CFAllocator *v14;
  __CFString *v15;
  int v16;
  __CFArray *v17;
  const __CFArray *v18;
  const __CFAllocator *v19;
  const CFArrayCallBacks *v20;
  CFMutableArrayRef v21;
  const __CFAllocator *v22;
  CFMutableArrayRef v23;
  unsigned int v24;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFTypeRef v27;
  const void *v28;
  const void *v29;
  const __CFAllocator *v30;
  CFStringRef FullKey;
  uint64_t v32;
  const __CFData *v33;
  const __CFAllocator *v34;
  CFMutableArrayRef v35;
  const UInt8 *BytePtr;
  unsigned int Length;
  BOOL v38;
  const void *v39;
  const __CFString *v40;
  uint64_t v42;
  CFIndex v43;
  const __CFString *v44;
  void *value[2];
  void *v46[2];
  void *v47[2];
  const __CFString *format;
  char v49;
  const __CFURL *v50;
  CFTypeRef v51;
  CFTypeRef *v52;
  const __CFData *v53;
  __CFDictionary *theDict;
  __CFArray *theArraya;
  CFMutableArrayRef cf;
  int v57;
  char v58;
  CFTypeRef v59;
  __int128 v60;
  __int128 v61;
  int *v62;
  uint64_t v63;
  CFRange v64;

  v63 = *MEMORY[0x24BDAC8D0];
  v59 = 0;
  v58 = 0;
  v62 = (int *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v60 = v5;
  v61 = v5;
  v57 = 0;
  if (!a1)
  {
    v44 = CFSTR("amfdr is NULL");
LABEL_108:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", v44, v49);
LABEL_109:
    v27 = 0;
    theArraya = 0;
    cf = 0;
    v18 = 0;
    goto LABEL_80;
  }
  if (!theArray)
  {
    v44 = CFSTR("dataClassArray is NULL");
    goto LABEL_108;
  }
  if (!a3)
  {
    v44 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_108;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v44 = CFSTR("Invalid dataClassArray count");
    goto LABEL_108;
  }
  v10 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v44 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_108;
  }
  v11 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v11, v10, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("valueDataDict is NULL"), v49);
    goto LABEL_109;
  }
  v13 = Mutable;
  v14 = CFGetAllocator(a1);
  theDict = CFDictionaryCreateMutable(v14, v10, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("multiRequestErrors is NULL"), v49);
LABEL_113:
    v15 = 0;
    goto LABEL_115;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v49);
    goto LABEL_113;
  }
  v15 = _AMFDRCreateUrlWithKey((uint64_t)a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/bulk/make"), 0, 0);
  if (!v15)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("serverURL is NULL"), v49);
LABEL_115:
    v53 = 0;
    v18 = 0;
    theArraya = 0;
    cf = 0;
LABEL_59:
    v27 = 0;
    goto LABEL_73;
  }
  v51 = v13;
  if (!_AMFDRGetMultiRequestMaxAttempts((uint64_t)a1))
  {
    v13 = 0;
    v53 = 0;
    v18 = 0;
    v17 = 0;
    cf = 0;
    goto LABEL_61;
  }
  v16 = 0;
  cf = 0;
  v17 = 0;
  v18 = 0;
  v52 = a4;
  v53 = 0;
  v13 = 0;
  v50 = (const __CFURL *)v15;
  while (2)
  {
    if (v17)
      CFRelease(v17);
    if (cf)
      CFRelease(cf);
    if (v53)
      CFRelease(v53);
    if (v59)
    {
      CFRelease(v59);
      v59 = 0;
    }
    v19 = CFGetAllocator(a1);
    v20 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
    v21 = CFArrayCreateMutable(v19, 0, MEMORY[0x24BDBD690]);
    if (!v21)
    {
      AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("dataClassToRequest is NULL"), v49);
      v27 = 0;
      theArraya = 0;
      cf = 0;
LABEL_91:
      v53 = 0;
      v39 = v51;
      goto LABEL_64;
    }
    theArraya = v21;
    v22 = CFGetAllocator(a1);
    v23 = CFArrayCreateMutable(v22, 0, v20);
    if (!v23)
    {
      AMFDRErrorPushInternal((uint64_t)a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("dataInstanceToRequest is NULL"), v49);
      v27 = 0;
      cf = 0;
      goto LABEL_91;
    }
    cf = v23;
    if (v16)
    {
      v24 = _AMFDRGetMultiRequestBackoff((uint64_t)a1) * v16;
      AMSupportLogInternal();
      sleep(v24);
    }
    for (i = 0; i != v10; ++i)
    {
      if (v13)
        CFRelease(v13);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, i);
      v27 = ValueAtIndex;
      if (!ValueAtIndex)
      {
        AMFDRErrorPushInternal((uint64_t)v52, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("dataClassStr is NULL"), v49);
        v53 = 0;
LABEL_72:
        v15 = (__CFString *)v50;
        v13 = v51;
LABEL_73:
        CFRelease(v13);
        goto LABEL_74;
      }
      if (!CFStringGetLength(ValueAtIndex))
      {
        v40 = CFSTR("dataClassStr length is 0");
LABEL_69:
        AMFDRErrorPushInternal((uint64_t)v52, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", v40, v49);
LABEL_71:
        v53 = 0;
        v27 = 0;
        goto LABEL_72;
      }
      v28 = CFArrayGetValueAtIndex(a3, i);
      if (!v28)
      {
        v40 = CFSTR("dataInstanceStr is NULL");
        goto LABEL_69;
      }
      v29 = v28;
      v30 = CFGetAllocator(a1);
      FullKey = AMFDRDataLocalCreateFullKey(v30, (uint64_t)v27, (uint64_t)v29);
      if (!FullKey)
      {
        AMFDRErrorPushInternal((uint64_t)v52, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("currDataInstance is NULL"), v49);
        goto LABEL_71;
      }
      v13 = FullKey;
      if (v18)
      {
        v64.length = CFArrayGetCount(v18);
        v64.location = 0;
        if (!CFArrayContainsValue(v18, v64, v13))
          continue;
        CFDictionaryRemoveValue(theDict, v13);
        AMSupportLogInternal();
      }
      CFArrayAppendValue(theArraya, v27);
      CFArrayAppendValue(cf, v29);
    }
    if (!CFArrayGetCount(theArraya))
    {
      AMFDRErrorPushInternal((uint64_t)v52, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("got multiRequestErrors"), v49);
      v53 = 0;
      v15 = (__CFString *)v50;
LABEL_58:
      CFRelease(v51);
      goto LABEL_59;
    }
    v32 = (uint64_t)v52;
    v33 = AMFDRDataHTTPCreateMultiRequest(a1, 0xCu, theArraya, cf, 0, 0, 0, 0, (uint64_t)v52);
    if (!v33)
    {
      AMFDRErrorPushInternal((uint64_t)v52, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("httpRequestData is NULL"), v49);
      v53 = 0;
      v15 = (__CFString *)v50;
      goto LABEL_58;
    }
    v53 = v33;
    if (v52)
    {
      if (*v52)
      {
        CFRelease(*v52);
        *v52 = 0;
      }
      v15 = (__CFString *)v50;
      if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, v50, (uint64_t)CFSTR("MultiMake"), CFSTR("POST"), 0, v53, &v59, 0, 0, 0, 0, 0, v52) & 1) == 0|| *v52)
      {
LABEL_102:
        AMSupportLogInternal();
        goto LABEL_58;
      }
    }
    else
    {
      v15 = (__CFString *)v50;
      v32 = 0;
      if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, v50, (uint64_t)CFSTR("MultiMake"), CFSTR("POST"), 0, v33, &v59, 0, 0, 0, 0, 0, 0) & 1) == 0)goto LABEL_102;
    }
    if (!v59)
    {
      format = CFSTR("_AMFDRHttpRequestSendSync failed: httpReturnData is NULL");
      *(_OWORD *)v46 = 0u;
      *(_OWORD *)v47 = 0u;
      *(_OWORD *)value = 0u;
      v42 = v32;
      goto LABEL_100;
    }
    if (v18)
      CFRelease(v18);
    v34 = CFGetAllocator(a1);
    v35 = CFArrayCreateMutable(v34, 0, MEMORY[0x24BDBD690]);
    v18 = v35;
    if (!v35)
    {
      AMFDRErrorPushInternal(v32, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("dataClassInstanceToRetry is NULL"), v49);
      goto LABEL_58;
    }
    *(_QWORD *)&v60 = a1;
    *((_QWORD *)&v60 + 1) = v51;
    *(_QWORD *)&v61 = theDict;
    *((_QWORD *)&v61 + 1) = v35;
    v62 = &v57;
    BytePtr = CFDataGetBytePtr((CFDataRef)v59);
    Length = CFDataGetLength((CFDataRef)v59);
    if (AMFDRDecodeMultiResponse((uint64_t)BytePtr, Length, &v58, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t))_AMFDRHttpMultiResponseCallback, (uint64_t)&v60))
    {
      format = CFSTR("AMFDRDecodeMultiResponse failed");
      *(_OWORD *)v46 = 0u;
      *(_OWORD *)v47 = 0u;
      *(_OWORD *)value = 0u;
      v42 = (uint64_t)v52;
      goto LABEL_98;
    }
    a4 = v52;
    if (v58 != 12)
    {
      v49 = v58;
      format = CFSTR("actionCode returned is %d");
      *(_OWORD *)v46 = 0u;
      *(_OWORD *)v47 = 0u;
      *(_OWORD *)value = 0u;
      v42 = (uint64_t)v52;
LABEL_98:
      v43 = 12;
LABEL_101:
      AMFDRErrorPushInternal(v42, v43, 0, 0, 0, 0, 0, 0, value[0], value[1], v46[0], v46[1], v47[0], v47[1], (uint64_t)"AMFDRDataHTTPMultiMake", format, v49);
      goto LABEL_58;
    }
    if ((_AMFDRSavePersistentCookie((uint64_t)a1, (uint64_t)v52) & 1) == 0)
    {
      format = CFSTR("_AMFDRSavePersistentCookie failed");
      *(_OWORD *)v46 = 0u;
      *(_OWORD *)v47 = 0u;
      *(_OWORD *)value = 0u;
      v42 = (uint64_t)v52;
LABEL_100:
      v43 = 8;
      goto LABEL_101;
    }
    if (CFArrayGetCount(v18))
    {
      v38 = ++v16 >= _AMFDRGetMultiRequestMaxAttempts((uint64_t)a1);
      v17 = theArraya;
      if (v38)
        goto LABEL_61;
      continue;
    }
    break;
  }
  v17 = theArraya;
LABEL_61:
  theArraya = v17;
  if (CFDictionaryGetCount(theDict) >= 1)
    AMFDRErrorPushInternal((uint64_t)a4, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiMake", CFSTR("got multiRequestErrors"), v49);
  v39 = v51;
  v27 = CFRetain(v51);
LABEL_64:
  CFRelease(v39);
  if (v13)
    goto LABEL_73;
LABEL_74:
  if (theDict)
    CFRelease(theDict);
  if (v15)
    CFRelease(v15);
  if (v53)
    CFRelease(v53);
LABEL_80:
  if (v59)
  {
    CFRelease(v59);
    v59 = 0;
  }
  if (v18)
    CFRelease(v18);
  if (theArraya)
    CFRelease(theArraya);
  if (cf)
    CFRelease(cf);
  return v27;
}

CFTypeRef AMFDRDataHTTPPopulate(__CFString *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, CFTypeRef *a5)
{
  return AMFDRDataHTTPCopy(a1, a2, a3, a5);
}

__CFString *AMFDRDataHTTPMultiPopulate(__CFString *a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4, uint64_t a5)
{
  return _AMFDRDataHTTPMultiCopyInternal(a1, a2, a3, 0, a5);
}

uint64_t AMFDRDataHTTPCommit(int a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  char vars0;

  AMFDRErrorPushInternal(a6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCommit", CFSTR("AMFDRDataHTTPCommit is not implemented"), vars0);
  return 0;
}

__CFString *AMFDRDataHTTPMultiCopyDigest(__CFString *a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4)
{
  return _AMFDRDataHTTPMultiCopyInternal(a1, a2, a3, 2u, a4);
}

uint64_t AMFDRDataHTTPCopyManifest(int a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  char vars0;

  AMFDRErrorPushInternal(a6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPCopyManifest", CFSTR("AMFDRDataHTTPCopyManifest is not implemented"), vars0);
  return 0;
}

__CFString *AMFDRDataHTTPMultiCopyManifest(__CFString *a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4)
{
  return _AMFDRDataHTTPMultiCopyInternal(a1, a2, a3, 3u, a4);
}

const __CFArray *AMFDRDataHTTPPatch(__CFString *a1, void *a2, void *a3, const __CFArray *a4, void *a5, const __CFArray *a6, CFTypeRef *a7)
{
  return _AMFDRDataHTTPPatchInternal(a1, a2, a3, a4, 0, a5, a6, a7);
}

__CFString *AMFDRDataHTTPMultiPatch(__CFString *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, const __CFArray *a6, uint64_t a7)
{
  return _AMFDRDataHTTPMultiPatchInternal(a1, a2, a3, a4, 0, a5, a6, a7);
}

const __CFArray *AMFDRDataHTTPCommitPatch(__CFString *a1, void *a2, void *a3, const __CFArray *a4, void *a5, const __CFArray *a6, CFTypeRef *a7)
{
  return _AMFDRDataHTTPPatchInternal(a1, a2, a3, 0, a4, a5, a6, a7);
}

__CFString *AMFDRDataHTTPMultiCommitPatch(__CFString *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, const __CFArray *a6, uint64_t a7)
{
  return _AMFDRDataHTTPMultiPatchInternal(a1, a2, a3, 0, a4, a5, a6, a7);
}

uint64_t AMFDRDataHTTPUpdateMetadataWithOptions(uint64_t a1, uint64_t a2, const __CFString *a3, CFTypeRef cf, CFDictionaryRef a5, CFTypeRef *a6)
{
  CFTypeID v12;
  __CFString *v13;
  __CFString *v14;
  CFTypeID v15;
  const void *Value;
  const void *v17;
  const __CFString *v18;
  CFStringRef v19;
  void *v20;
  void *v21;
  const __CFAllocator *v22;
  CFStringRef v23;
  uint64_t v24;
  const __CFString *v26;
  const __CFString *v27;
  char v28;
  CFRange result;
  void *values;
  void *keys[2];
  CFRange v32;

  keys[1] = *(void **)MEMORY[0x24BDAC8D0];
  result.location = 0xAAAAAAAAAAAAAAAALL;
  result.length = 0xAAAAAAAAAAAAAAAALL;
  if (!a1)
  {
    v26 = CFSTR("amfdr is NULL");
    goto LABEL_37;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v26 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_37;
  }
  if (!a2)
  {
    v26 = CFSTR("dataClassStr is NULL");
    goto LABEL_37;
  }
  if (!cf || (v12 = CFGetTypeID(cf), v12 != CFDictionaryGetTypeID()))
  {
    v26 = CFSTR("metaDataDict is of incorrect type");
LABEL_37:
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPUpdateMetadataWithOptions", v26, v28);
    return 0;
  }
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 136) + 8) & 2) != 0)
  {
    v32.location = 0;
    v32.length = 4;
    if (CFStringFindWithOptions(a3, CFSTR("sik-"), v32, 8uLL, &result))
    {
      AMFDRErrorPushInternal((uint64_t)a6, 403, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPUpdateMetadataWithOptions", CFSTR("Station AMFDRDataHTTPUpdateMeta with sik format is forbidden. %@-%@"), a2);
      return 0;
    }
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a6) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPUpdateMetadataWithOptions", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v28);
    return 0;
  }
  v13 = _AMFDRCreateUrlWithKey(a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/updateMetadata"), a2, a3);
  if (!v13)
  {
    v26 = CFSTR("serverURL is NULL");
    goto LABEL_37;
  }
  v14 = v13;
  if (!a5)
  {
LABEL_16:
    v19 = 0;
    goto LABEL_23;
  }
  v15 = CFGetTypeID(a5);
  if (v15 != CFDictionaryGetTypeID())
  {
    a5 = 0;
    goto LABEL_16;
  }
  Value = CFDictionaryGetValue(a5, CFSTR("MetadataType"));
  if (!Value)
    goto LABEL_19;
  v17 = Value;
  if (CFEqual(Value, CFSTR("System")))
  {
    v18 = CFSTR("x-fdr-metadata-");
    goto LABEL_20;
  }
  if (CFEqual(v17, CFSTR("User")))
    v18 = CFSTR("x-fdr-user-metadata-");
  else
LABEL_19:
    v18 = 0;
LABEL_20:
  v20 = (void *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("asid"));
  if (!v20)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPUpdateMetadataWithOptions", CFSTR("metadataValue is NULL"), v28);
LABEL_45:
    CFRelease(v14);
    return 0;
  }
  v21 = v20;
  v22 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@%@"), v18, CFSTR("asid"));
  if (!v23)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPUpdateMetadataWithOptions", CFSTR("httpHeader is NULL"), v28);
    goto LABEL_45;
  }
  v19 = v23;
  values = v21;
  keys[0] = (void *)v23;
  a5 = CFDictionaryCreate(v22, (const void **)keys, (const void **)&values, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (a5)
  {
LABEL_23:
    if (_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v14, (uint64_t)CFSTR("UpdateMetaData"), CFSTR("PUT"), a5, 0, 0, 0, 0, 0, 0, 0, a6))
    {
      if ((_AMFDRSavePersistentCookie(a1, (uint64_t)a6) & 1) != 0)
      {
        v24 = 1;
        goto LABEL_26;
      }
      v27 = CFSTR("_AMFDRSavePersistentCookie failed");
    }
    else
    {
      v27 = CFSTR("AMFDRDataHTTPUpdateMetaData failed");
    }
    AMFDRErrorPushInternal((uint64_t)a6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPUpdateMetadataWithOptions", v27, v28);
    v24 = 0;
LABEL_26:
    CFRelease(v14);
    if (!v19)
      goto LABEL_28;
    goto LABEL_27;
  }
  AMFDRErrorPushInternal((uint64_t)a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPUpdateMetadataWithOptions", CFSTR("Unable to create HTTP metadata Headers dictionary"), v28);
  CFRelease(v14);
  v24 = 0;
LABEL_27:
  CFRelease(v19);
LABEL_28:
  if (a5)
    CFRelease(a5);
  return v24;
}

uint64_t AMFDRDataHTTPMultiUpdateMetadataWithOptions(__CFString *a1, CFArrayRef theArray, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, CFTypeRef *a6)
{
  __int128 v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v11;
  const __CFAllocator *v12;
  CFStringRef v13;
  __CFArray *v14;
  CFMutableArrayRef v15;
  CFMutableArrayRef Mutable;
  const __CFArray *v17;
  const __CFData *v18;
  const CFArrayCallBacks *v19;
  const __CFAllocator *v20;
  const __CFAllocator *v21;
  const __CFAllocator *v22;
  const __CFAllocator *v23;
  CFMutableArrayRef v24;
  unsigned int v25;
  CFIndex v26;
  __CFArray *v27;
  const __CFString *ValueAtIndex;
  const __CFString *v29;
  const __CFString *v30;
  uint64_t v31;
  const __CFArray *v32;
  const void *v33;
  const __CFAllocator *v34;
  CFStringRef FullKey;
  CFTypeRef *v36;
  const __CFAllocator *v37;
  CFMutableArrayRef v38;
  const UInt8 *BytePtr;
  unsigned int Length;
  const __CFString *format;
  const __CFString *v43;
  const __CFString *v44;
  const __CFString *v45;
  const __CFString *v46;
  char v47;
  __CFString *v48;
  CFMutableDictionaryRef theDict;
  int v51;
  __CFArray *v52;
  CFMutableArrayRef cf;
  __CFArray *v54;
  __CFArray *v55;
  CFIndex v56;
  const __CFArray *v59;
  CFRange result;
  int v61;
  char v62;
  CFTypeRef v63;
  __int128 v64;
  __int128 v65;
  int *v66;
  uint64_t v67;
  CFRange v68;
  CFRange v69;

  v67 = *MEMORY[0x24BDAC8D0];
  v63 = 0;
  v62 = 0;
  v66 = (int *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v64 = v6;
  v65 = v6;
  v61 = 8;
  if (!a1)
  {
    v46 = CFSTR("amfdr is NULL");
LABEL_134:
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", v46, v47);
    goto LABEL_135;
  }
  v7 = theArray;
  if (!theArray)
  {
    v46 = CFSTR("dataClassArray is NULL");
    goto LABEL_134;
  }
  if (!a3)
  {
    v46 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_134;
  }
  if (!a4)
  {
    v46 = CFSTR("metaDataArray is NULL");
    goto LABEL_134;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v46 = CFSTR("Invalid dataClassArray count");
    goto LABEL_134;
  }
  v11 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v46 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_134;
  }
  if (CFArrayGetCount(a4) != v11)
  {
    v46 = CFSTR("Invalid metaDataArray count");
    goto LABEL_134;
  }
  if (a5 && CFArrayGetCount(a5) != v11)
  {
    v46 = CFSTR("Invalid optionsArray or count");
    goto LABEL_134;
  }
  v12 = CFGetAllocator(a1);
  theDict = CFDictionaryCreateMutable(v12, v11, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("multiRequestErrors is NULL"), v47);
LABEL_135:
    v17 = 0;
    Mutable = 0;
    v15 = 0;
    cf = 0;
    v14 = 0;
    v31 = 0;
    goto LABEL_89;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a6) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v47);
LABEL_132:
    CFRelease(theDict);
    goto LABEL_135;
  }
  v48 = _AMFDRCreateUrlWithKey((uint64_t)a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/bulk/metadata"), 0, 0);
  if (!v48)
  {
    AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("serverURL is NULL"), v47);
    goto LABEL_132;
  }
  if (!_AMFDRGetMultiRequestMaxAttempts((uint64_t)a1))
  {
    v18 = 0;
    v17 = 0;
    Mutable = 0;
    v15 = 0;
    cf = 0;
    v14 = 0;
    v13 = 0;
LABEL_75:
    if (!CFDictionaryGetCount(theDict))
    {
      v31 = 1;
      if (v13)
        goto LABEL_77;
      goto LABEL_87;
    }
    AMFDRErrorPushInternal((uint64_t)a6, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("got multiRequestErrors"), v47);
LABEL_109:
    v31 = 0;
    if (v13)
      goto LABEL_77;
    goto LABEL_87;
  }
  v56 = v11;
  v13 = 0;
  v51 = 0;
  v14 = 0;
  cf = 0;
  v15 = 0;
  Mutable = 0;
  v17 = 0;
  v18 = 0;
  while (1)
  {
    if (Mutable)
      CFRelease(Mutable);
    if (v15)
      CFRelease(v15);
    if (cf)
      CFRelease(cf);
    v19 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
    if (v18)
      CFRelease(v18);
    if (v63)
    {
      CFRelease(v63);
      v63 = 0;
    }
    if (v14)
      CFRelease(v14);
    v20 = CFGetAllocator(a1);
    Mutable = CFArrayCreateMutable(v20, 0, v19);
    if (!Mutable)
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("dataClassToRequest is NULL"), v47);
      v18 = 0;
      v15 = 0;
LABEL_107:
      cf = 0;
      goto LABEL_108;
    }
    v21 = CFGetAllocator(a1);
    v15 = CFArrayCreateMutable(v21, 0, v19);
    if (!v15)
    {
      v43 = CFSTR("dataInstanceToRequest is NULL");
LABEL_106:
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", v43, v47);
      v18 = 0;
      goto LABEL_107;
    }
    v22 = CFGetAllocator(a1);
    cf = CFArrayCreateMutable(v22, 0, v19);
    if (!cf)
    {
      v43 = CFSTR("metaDataToRequest is NULL");
      goto LABEL_106;
    }
    if (a5)
    {
      v23 = CFGetAllocator(a1);
      v24 = CFArrayCreateMutable(v23, 0, MEMORY[0x24BDBD690]);
      if (!v24)
      {
        AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("optionsToRequest is NULL"), v47);
        v18 = 0;
LABEL_108:
        v14 = 0;
        goto LABEL_109;
      }
    }
    else
    {
      v24 = 0;
    }
    v52 = v24;
    v59 = v17;
    v54 = Mutable;
    v55 = v15;
    if (v51)
    {
      v25 = _AMFDRGetMultiRequestBackoff((uint64_t)a1) * v51;
      AMSupportLogInternal();
      sleep(v25);
    }
    v26 = 0;
    v27 = cf;
    do
    {
      if (v13)
        CFRelease(v13);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v26);
      if (!ValueAtIndex)
      {
        format = CFSTR("dataClassStr is NULL");
        goto LABEL_83;
      }
      v29 = ValueAtIndex;
      if (!CFStringGetLength(ValueAtIndex))
      {
        format = CFSTR("dataClassStr length is 0");
        goto LABEL_83;
      }
      v30 = (const __CFString *)CFArrayGetValueAtIndex(a3, v26);
      v18 = (const __CFData *)v30;
      if (!v30)
      {
        AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("dataInstanceStr is NULL"), v47);
        goto LABEL_85;
      }
      if ((*(_BYTE *)(a1[4].info + 8) & 2) != 0)
      {
        result.location = 0xAAAAAAAAAAAAAAAALL;
        result.length = 0xAAAAAAAAAAAAAAAALL;
        v69.location = 0;
        v69.length = 4;
        if (CFStringFindWithOptions(v30, CFSTR("sik-"), v69, 8uLL, &result))
        {
          AMFDRErrorPushInternal((uint64_t)a6, 403, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("Station AMFDRDataHTTPMultiPut with sik format is forbidden. %@-%@"), (char)v29);
LABEL_84:
          v18 = 0;
LABEL_85:
          v31 = 0;
LABEL_86:
          Mutable = v54;
          v15 = v55;
          v17 = v59;
          v14 = v52;
          goto LABEL_87;
        }
      }
      v31 = (uint64_t)CFArrayGetValueAtIndex(a4, v26);
      if (!v31)
      {
        AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("metaDict is NULL"), v47);
        v18 = 0;
        goto LABEL_86;
      }
      v32 = v7;
      if (a5)
      {
        v33 = CFArrayGetValueAtIndex(a5, v26);
        if (!v33)
        {
          format = CFSTR("options is NULL");
LABEL_83:
          AMFDRErrorPushInternal((uint64_t)a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", format, v47);
          goto LABEL_84;
        }
      }
      else
      {
        v33 = 0;
      }
      v34 = CFGetAllocator(a1);
      FullKey = AMFDRDataLocalCreateFullKey(v34, (uint64_t)v29, (uint64_t)v18);
      if (!FullKey)
      {
        AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("currDataInstance is NULL"), v47);
        goto LABEL_84;
      }
      v13 = FullKey;
      if (v59)
      {
        v68.length = CFArrayGetCount(v59);
        v27 = cf;
        v68.location = 0;
        if (!CFArrayContainsValue(v59, v68, v13))
          goto LABEL_55;
        CFDictionaryRemoveValue(theDict, v13);
        AMSupportLogInternal();
      }
      CFArrayAppendValue(v54, v29);
      CFArrayAppendValue(v55, v18);
      CFArrayAppendValue(v27, (const void *)v31);
      if (a5)
        CFArrayAppendValue(v52, v33);
LABEL_55:
      ++v26;
      v7 = v32;
    }
    while (v56 != v26);
    v36 = a6;
    Mutable = v54;
    v15 = v55;
    v18 = AMFDRDataHTTPCreateMultiRequest(a1, 7u, v54, v55, 0, v52, v27, 0, (uint64_t)a6);
    if (!v18)
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("httpRequestData is NULL"), v47);
      v31 = 0;
      v17 = v59;
      v14 = v52;
      goto LABEL_77;
    }
    v17 = v59;
    if (a6)
      break;
    v14 = v52;
    if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v48, (uint64_t)CFSTR("MultiUpdateMetaData"), CFSTR("POST"), 0, v18, &v63, 0, 0, 0, 0, 0, 0) & 1) == 0)goto LABEL_120;
LABEL_64:
    if (!v63)
    {
      v44 = CFSTR("_AMFDRHttpRequestSendSync failed: httpReturnData is NULL");
LABEL_119:
      AMFDRErrorPushInternal((uint64_t)a6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", v44, v47);
      goto LABEL_121;
    }
    if (v59)
      CFRelease(v59);
    v37 = CFGetAllocator(a1);
    v38 = CFArrayCreateMutable(v37, 0, MEMORY[0x24BDBD690]);
    v17 = v38;
    if (!v38)
    {
      AMFDRErrorPushInternal((uint64_t)a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", CFSTR("dataClassInstanceToRetry is NULL"), v47);
      goto LABEL_121;
    }
    v64 = (unint64_t)a1;
    *(_QWORD *)&v65 = theDict;
    *((_QWORD *)&v65 + 1) = v38;
    v66 = &v61;
    BytePtr = CFDataGetBytePtr((CFDataRef)v63);
    Length = CFDataGetLength((CFDataRef)v63);
    if (AMFDRDecodeMultiResponse((uint64_t)BytePtr, Length, &v62, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t))_AMFDRHttpMultiResponseCallback, (uint64_t)&v64))
    {
      v45 = CFSTR("AMFDRDecodeMultiResponse failed");
LABEL_117:
      AMFDRErrorPushInternal((uint64_t)a6, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPMultiUpdateMetadataWithOptions", v45, v47);
      goto LABEL_121;
    }
    if (v62 != 7)
    {
      v47 = v62;
      v45 = CFSTR("actionCode returned is %d");
      goto LABEL_117;
    }
    if ((_AMFDRSavePersistentCookie((uint64_t)a1, (uint64_t)a6) & 1) == 0)
    {
      v44 = CFSTR("_AMFDRSavePersistentCookie failed");
      goto LABEL_119;
    }
    if (CFArrayGetCount(v17))
    {
      if (++v51 < _AMFDRGetMultiRequestMaxAttempts((uint64_t)a1))
        continue;
    }
    goto LABEL_75;
  }
  v14 = v52;
  if (*a6)
  {
    CFRelease(*a6);
    v36 = a6;
    *a6 = 0;
  }
  if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v48, (uint64_t)CFSTR("MultiUpdateMetaData"), CFSTR("POST"), 0, v18, &v63, 0, 0, 0, 0, 0, v36) & 1) != 0&& !*a6)
  {
    goto LABEL_64;
  }
LABEL_120:
  AMSupportLogInternal();
LABEL_121:
  v31 = 0;
LABEL_77:
  CFRelease(v13);
LABEL_87:
  CFRelease(theDict);
  CFRelease(v48);
  if (v18)
    CFRelease(v18);
LABEL_89:
  if (v63)
  {
    CFRelease(v63);
    v63 = 0;
  }
  if (v17)
    CFRelease(v17);
  if (Mutable)
    CFRelease(Mutable);
  if (v15)
    CFRelease(v15);
  if (cf)
    CFRelease(cf);
  if (v14)
    CFRelease(v14);
  return v31;
}

__CFString *AMFDRDataHTTPMultiCopyAsidMetadata(__CFString *a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4)
{
  return _AMFDRDataHTTPMultiCopyInternal(a1, a2, a3, 4u, a4);
}

uint64_t AMFDRDataHTTPRevert(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  __CFString *v8;
  __CFString *v9;
  uint64_t v10;
  const __CFString *v12;
  const __CFString *v13;
  char v14;

  if (!a1)
  {
    v12 = CFSTR("amfdr is NULL");
LABEL_18:
    AMFDRErrorPushInternal((uint64_t)a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPRevert", v12, v14);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v12 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_18;
  }
  if (!a2)
  {
    v12 = CFSTR("sealedDataClass is NULL");
    goto LABEL_18;
  }
  if (!a3)
  {
    v12 = CFSTR("sealedDataInstance is NULL");
    goto LABEL_18;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)a1, a4) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPRevert", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v14);
    return 0;
  }
  v8 = _AMFDRCreateUrlWithKey(a1, CFSTR("DSURL"), (uint64_t)CFSTR("dm/revert"), a2, a3);
  if (!v8)
  {
    v12 = CFSTR("serverURL is NULL");
    goto LABEL_18;
  }
  v9 = v8;
  if (!_AMFDRHttpRequestSendSync((CFDictionaryRef *)a1, (const __CFURL *)v8, (uint64_t)CFSTR("Revert"), CFSTR("POST"), 0, 0, 0, 0, 0, 0, 0, 0, a4))
  {
    v13 = CFSTR("AMFDRDataHTTPRevert failed");
LABEL_22:
    AMFDRErrorPushInternal((uint64_t)a4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPRevert", v13, v14);
    v10 = 0;
    goto LABEL_10;
  }
  if ((_AMFDRSavePersistentCookie(a1, (uint64_t)a4) & 1) == 0)
  {
    v13 = CFSTR("_AMFDRSavePersistentCookie failed");
    goto LABEL_22;
  }
  v10 = 1;
LABEL_10:
  CFRelease(v9);
  return v10;
}

uint64_t AMFDRCertificateSigningRequest(CFDictionaryRef *a1, const __CFData *a2, uint64_t a3, CFTypeRef *a4, uint64_t *a5)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v11;
  const __CFDictionary *v12;
  const __CFDictionary *Value;
  const __CFDictionary *v14;
  const void *v15;
  CFStringRef v16;
  uint64_t v17;
  char v19;
  int v20;

  v20 = 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCertificateSigningRequest", CFSTR("internalHttpXHeaders is NULL"), v19);
    return 0;
  }
  v11 = Mutable;
  v12 = a1[2];
  if (v12 && (Value = (const __CFDictionary *)CFDictionaryGetValue(v12, CFSTR("CertifyHeaders"))) != 0)
  {
    v14 = Value;
    if (CFDictionaryContainsKey(Value, CFSTR("x-fdr-client-id")))
    {
      v15 = 0;
    }
    else
    {
      v15 = (const void *)AMFDRCopyCertifyClientId(a1);
      if (v15)
        CFDictionarySetValue(v11, CFSTR("x-fdr-client-id"), v15);
    }
    if (CFDictionaryContainsKey(v14, CFSTR("x-fdr-client-id-sik")))
      goto LABEL_16;
  }
  else
  {
    v15 = (const void *)AMFDRCopyCertifyClientId(a1);
    if (v15)
      CFDictionarySetValue(v11, CFSTR("x-fdr-client-id"), v15);
  }
  if ((*((_BYTE *)a1[17] + 8) & 2) == 0)
  {
    v16 = 0;
    if (AMFDRDataGetSigningVersion((uint64_t)a1, &v20))
    {
      if (v20 == 2)
      {
        v16 = AMFDRCopyCertifyClientIdSik(a1);
        if (v16)
          CFDictionarySetValue(v11, CFSTR("x-fdr-client-id-sik"), v16);
      }
    }
    goto LABEL_17;
  }
LABEL_16:
  v16 = 0;
LABEL_17:
  v17 = _AMFDRCertificateSigningRequestInternal(a1, a2, a3, v11, a4, a5);
  CFRelease(v11);
  if (v15)
    CFRelease(v15);
  if (v16)
    CFRelease(v16);
  return v17;
}

uint64_t _AMFDRCertificateSigningRequestInternal(CFDictionaryRef *a1, const __CFData *a2, uint64_t a3, const void *a4, CFTypeRef *a5, uint64_t *a6)
{
  const __CFData *PemFromData;
  const __CFDictionary *v9;
  uint64_t URLFromString;
  const __CFURL *v14;
  const void *v15;
  const void *v16;
  CFTypeID TypeID;
  _BOOL4 v18;
  const __CFDictionary *v19;
  const __CFAllocator *v20;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v22;
  CFTypeID v23;
  CFTypeID v24;
  CFAllocatorRef v25;
  uint64_t v26;
  CFTypeRef v27;
  const __CFString *v29;
  const __CFString *v30;
  CFIndex v31;
  void *v32[2];
  void *v33[2];
  uint64_t v34[2];
  const __CFString *v35;
  char v36;
  uint64_t v37;
  CFTypeRef cf;
  void *value;

  cf = 0;
  value = 0;
  v37 = -1;
  if (!a1)
  {
    v29 = CFSTR("amfdr is NULL");
LABEL_42:
    AMFDRErrorPushInternal((uint64_t)&cf, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRCertificateSigningRequestInternal", v29, v36);
    v14 = 0;
LABEL_44:
    PemFromData = 0;
    goto LABEL_46;
  }
  PemFromData = a2;
  if (!a2)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRCertificateSigningRequestInternal", CFSTR("csrDERData is NULL"), v36);
    v14 = 0;
    goto LABEL_46;
  }
  v9 = a1[2];
  if (!v9)
  {
    v29 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_42;
  }
  if (CFDictionaryGetValue(v9, CFSTR("CertifyURL")))
  {
    CFGetAllocator(a1);
    URLFromString = AMSupportCreateURLFromString();
  }
  else
  {
    URLFromString = (uint64_t)_AMFDRCreateUrlWithKey((uint64_t)a1, CFSTR("CAURL"), (uint64_t)CFSTR("ca/authorize"), 0, 0);
  }
  v14 = (const __CFURL *)URLFromString;
  if (!URLFromString)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRCertificateSigningRequestInternal", CFSTR("serverURL is NULL"), v36);
    goto LABEL_44;
  }
  v15 = CFDictionaryGetValue(a1[2], CFSTR("CertifyBase64"));
  v18 = v15
     && (v16 = v15, TypeID = CFBooleanGetTypeID(), TypeID == CFGetTypeID(v16))
     && CFBooleanGetValue((CFBooleanRef)v16) == 1;
  PemFromData = AMFDRCryptoCreatePemFromData((uint64_t)PemFromData, !v18);
  if (PemFromData)
  {
    v19 = (const __CFDictionary *)CFDictionaryGetValue(a1[2], CFSTR("CertifyHeaders"));
    v20 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    if (v19)
      MutableCopy = CFDictionaryCreateMutableCopy(v20, 0, v19);
    else
      MutableCopy = CFDictionaryCreateMutable(v20, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    v22 = MutableCopy;
    if (MutableCopy)
    {
      v23 = CFGetTypeID(MutableCopy);
      if (v23 == CFDictionaryGetTypeID())
      {
        if (a4)
        {
          v24 = CFGetTypeID(a4);
          if (v24 != CFDictionaryGetTypeID())
          {
            v30 = CFSTR("internalHeaders is not dictionary");
            goto LABEL_53;
          }
          if ((_CFDictionaryAddDictionary(v22, (CFDictionaryRef)a4) & 1) == 0)
          {
            v30 = CFSTR("_CFDictionaryAddDictionary fail to add dictionary");
            goto LABEL_53;
          }
        }
        if (!a3)
        {
LABEL_25:
          v26 = 1;
          if ((_AMFDRHttpRequestSendSyncNoRetry((uint64_t)a1, v14, (uint64_t)CFSTR("CertificateSigning"), CFSTR("POST"), CFSTR("application/x-pem-file"), v22, PemFromData, a5, 0, 1, 0, 0, &v37, (uint64_t)&cf) & 1) != 0)goto LABEL_26;
          v35 = CFSTR("AMFDRCertificateSigningRequest failed");
          *(_OWORD *)v33 = 0u;
          *(_OWORD *)v34 = 0u;
          *(_OWORD *)v32 = 0u;
          v31 = 8;
          goto LABEL_54;
        }
        v25 = CFGetAllocator(a1);
        if ((_AMFDRSupportBase64Encode((uint64_t)v25, a3, (uint64_t)&value) & 1) != 0)
        {
          if (!value)
          {
            AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRCertificateSigningRequestInternal", CFSTR("base64CsrSignature is NULL"), v36);
            goto LABEL_55;
          }
          CFDictionarySetValue(v22, CFSTR("x-fdr-csr-signature"), value);
          goto LABEL_25;
        }
        v30 = CFSTR("_AMFDRSupportBase64Encode failed");
      }
      else
      {
        v30 = CFSTR("httpXHeaders is not dictionary");
      }
    }
    else
    {
      v30 = CFSTR("Unable to create HTTP header extension dictionary");
    }
LABEL_53:
    v35 = v30;
    *(_OWORD *)v33 = 0u;
    *(_OWORD *)v34 = 0u;
    *(_OWORD *)v32 = 0u;
    v31 = 10;
LABEL_54:
    AMFDRErrorPushInternal((uint64_t)&cf, v31, 0, 0, 0, 0, 0, 0, v32[0], v32[1], v33[0], v33[1], (void *)v34[0], (void *)v34[1], (uint64_t)"_AMFDRCertificateSigningRequestInternal", v35, v36);
    goto LABEL_55;
  }
  AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRCertificateSigningRequestInternal", CFSTR("csrData is NULL"), v36);
LABEL_46:
  v22 = 0;
LABEL_55:
  if (cf)
    AMSupportLogInternal();
  v26 = 0;
LABEL_26:
  v27 = cf;
  if (a6)
  {
    *a6 = AMSupportSafeRetain();
    v27 = cf;
  }
  if (v27)
  {
    CFRelease(v27);
    cf = 0;
  }
  if (v14)
    CFRelease(v14);
  if (PemFromData)
    CFRelease(PemFromData);
  if (value)
  {
    CFRelease(value);
    value = 0;
  }
  if (v22)
    CFRelease(v22);
  return v26;
}

uint64_t AMFDRCertificationRequest(uint64_t a1, const __CFData *a2, uint64_t a3, uint64_t *a4)
{
  __CFDictionary *Mutable;
  const void *SikPub;
  const __CFDictionary *v10;
  const void *v11;
  const void *v12;
  CFTypeID v13;
  CFAllocatorRef v14;
  uint64_t v15;
  const __CFString *v17;
  void *value;
  CFTypeRef cf;

  value = 0;
  cf = 0;
  if ((!a1 || (*(_BYTE *)(*(_QWORD *)(a1 + 136) + 8) & 2) == 0)
    && AMFDRSealingMapGetFDRDataVersionForDeviceInternal(a1) == 2)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (Mutable)
    {
      SikPub = (const void *)AMFDRCryptoGetSikPub(a1);
      if (SikPub)
      {
        CFDictionarySetValue(Mutable, CFSTR("x-fdr-client-id-sik"), SikPub);
        goto LABEL_8;
      }
      AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCertificationRequest", CFSTR("sik is NULL"), (char)value);
    }
    else
    {
      AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCertificationRequest", CFSTR("internalHttpXHeaders is NULL"), (char)value);
    }
    v15 = 0;
    goto LABEL_15;
  }
  Mutable = 0;
LABEL_8:
  v10 = (const __CFDictionary *)AMFDRGetOptions(a1);
  v11 = _CFDictionaryCopyValue(v10, CFSTR("CertifyManifestSigCert"));
  if (!v11)
  {
    v15 = _AMFDRCertificateSigningRequestInternal((CFDictionaryRef *)a1, a2, a3, Mutable, &cf, a4);
    goto LABEL_15;
  }
  v12 = v11;
  v13 = CFGetTypeID(v11);
  if (v13 == CFDataGetTypeID())
  {
    v14 = CFGetAllocator((CFTypeRef)a1);
    if ((_AMFDRSupportBase64Encode((uint64_t)v14, (uint64_t)v12, (uint64_t)&value) & 1) != 0)
    {
      CFDictionarySetValue(Mutable, CFSTR("x-fdr-partial-im4m"), value);
      v15 = _AMFDRCertificateSigningRequestInternal((CFDictionaryRef *)a1, a2, a3, Mutable, &cf, a4);
      goto LABEL_12;
    }
    v17 = CFSTR("cannot convert partialIm4mData to base64 string");
  }
  else
  {
    v17 = CFSTR("partialIm4mData is in malformed format");
  }
  AMFDRErrorPushInternal((uint64_t)a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRCertificationRequest", v17, (char)value);
  v15 = 0;
LABEL_12:
  CFRelease(v12);
  if (value)
  {
    CFRelease(value);
    value = 0;
  }
LABEL_15:
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
  return v15;
}

uint64_t AMFDRModuleCreateSignedCSR(const void **a1, const void *a2, CFTypeRef *a3, uint64_t a4)
{
  uint64_t v5;
  const void *v6;
  CFTypeID v9;
  const void *v10;
  CFTypeID v11;
  const void *v12;
  CFTypeID v13;
  CFTypeID v14;
  const __CFString *v15;
  CFTypeID v16;
  CFTypeID v17;
  const __CFAllocator *v18;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v20;
  uint64_t v21;
  const __CFString *v22;
  const __CFString *v23;
  CFTypeRef v24;
  __CFString *v25;
  __CFString *v26;
  uint64_t v28;
  const __CFString *v29;
  uint64_t v30;
  char v31;
  CFTypeRef cf;

  v5 = (uint64_t)a1;
  cf = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRModuleCreateSignedCSR", CFSTR("certificationCtx is NULL"), v31);
    return v5;
  }
  v6 = *a1;
  if (!*(_QWORD *)v5)
    goto LABEL_33;
  v9 = CFGetTypeID(v6);
  if (v9 != CFStringGetTypeID())
  {
    v28 = *(_QWORD *)v5;
    goto LABEL_39;
  }
  v10 = *(const void **)(v5 + 24);
  if (!v10)
  {
LABEL_33:
    LOBYTE(v28) = 0;
LABEL_39:
    v31 = v28;
    v29 = CFSTR("moduleDataInstanceStr has wrong type: %@");
    goto LABEL_49;
  }
  v11 = CFGetTypeID(v10);
  if (v11 != CFStringGetTypeID())
  {
    v28 = *(_QWORD *)(v5 + 24);
    goto LABEL_39;
  }
  v12 = *(const void **)(v5 + 32);
  if (!v12)
  {
    LOBYTE(v30) = 0;
LABEL_42:
    v31 = v30;
    v29 = CFSTR("moduleRawPublicKey has wrong type: %@");
    goto LABEL_49;
  }
  v13 = CFGetTypeID(v12);
  if (v13 != CFDataGetTypeID())
  {
    v30 = *(_QWORD *)(v5 + 32);
    goto LABEL_42;
  }
  if (!*(_QWORD *)(v5 + 40))
  {
    v29 = CFSTR("csrSign is NULL");
    goto LABEL_49;
  }
  if (!a2 || (v14 = CFGetTypeID(a2), v14 != CFDictionaryGetTypeID()))
  {
    v31 = (char)a2;
    v29 = CFSTR("certificationOptions has wrong type: %@");
LABEL_49:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRModuleCreateSignedCSR", v29, v31);
    return 0;
  }
  if (!a3)
  {
    v29 = CFSTR("outSignedCsr is NULL");
    goto LABEL_49;
  }
  if (!a4)
  {
    AMFDRErrorPushInternal(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRModuleCreateSignedCSR", CFSTR("outError is NULL"), v31);
    return 0;
  }
  v15 = *(const __CFString **)(v5 + 24);
  if (!v15 || (v16 = CFGetTypeID(*(CFTypeRef *)(v5 + 24)), v16 != CFStringGetTypeID()))
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRModuleCreateInternalCertificationOptions", CFSTR("moduleChipName has wrong type: %@"), (char)v15);
LABEL_48:
    v29 = CFSTR("internalCertificationOptions is NULL");
    goto LABEL_49;
  }
  v17 = CFGetTypeID(a2);
  if (v17 != CFDictionaryGetTypeID())
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRModuleCreateInternalCertificationOptions", CFSTR("certificationOptions has wrong type: %@"), (char)a2);
    goto LABEL_48;
  }
  v18 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, (CFDictionaryRef)a2);
  if (!MutableCopy)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRModuleCreateInternalCertificationOptions", CFSTR("failed to create internalCertificationOptions"), v31);
    goto LABEL_48;
  }
  v20 = MutableCopy;
  if (CFStringCompare(v15, CFSTR("brunor"), 0))
  {
    v21 = 0;
    v22 = 0;
    goto LABEL_23;
  }
  v23 = AMFDRSealingMapCallMGCopyAnswer(CFSTR("ProductType"), 0);
  if (!v23)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRModuleCreateInternalCertificationOptions", CFSTR("can't get productType\n"), v31);
    CFRelease(v20);
    goto LABEL_48;
  }
  v22 = v23;
  CFDictionarySetValue(v20, CFSTR("CertifyPartNumber"), v23);
  CFDictionarySetValue(v20, CFSTR("CertifyNoClientID"), (const void *)*MEMORY[0x24BDBD270]);
  if (CFStringCompare(v15, CFSTR("brunor"), 0))
  {
    v21 = 0;
  }
  else
  {
    CFDictionarySetValue(v20, CFSTR("CertifyComponentType"), CFSTR("iPhone FCAM IR"));
    v21 = 67586;
  }
LABEL_23:
  v24 = CFRetain(v20);
  CFRelease(v20);
  if (v22)
    CFRelease(v22);
  if (!v24)
    goto LABEL_48;
  v25 = (__CFString *)AMFDRCreateTypeWithOptions(v18, CFSTR("Local"), 0);
  if (v25)
  {
    v26 = v25;
    v5 = _AMFDRModuleCreateSignedCSR(v25, v5, v24, &cf, v21, a4);
    if ((v5 & 1) != 0)
      *a3 = CFRetain(cf);
    else
      AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRModuleCreateSignedCSR", CFSTR("Failed to create csr, _AMFDRModuleCreateSignedCSR failed."), v31);
    CFRelease(v26);
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
  }
  else
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRModuleCreateSignedCSR", CFSTR("amfdr is NULL"), v31);
    v5 = 0;
  }
  CFRelease(v24);
  return v5;
}

uint64_t _AMFDRModuleCreateSignedCSR(__CFString *a1, uint64_t a2, const void *a3, CFTypeRef *a4, uint64_t a5, uint64_t a6)
{
  CFTypeID v12;
  const void *v13;
  CFTypeID v14;
  const void *v15;
  CFTypeID v16;
  CFTypeID v17;
  const __CFBoolean *Value;
  const __CFBoolean *v19;
  CFTypeID v20;
  const __CFAllocator *v21;
  CFIndex Length;
  __CFData *Mutable;
  __CFData *v24;
  const UInt8 *BytePtr;
  CFIndex v26;
  __CFData *v27;
  uint64_t v28;
  const __CFDictionary *data;
  const __CFString *v30;
  CFDataRef ModuleSignedCsr;
  CFDataRef v32;
  uint64_t v33;
  const __CFString *v35;
  CFTypeRef v36;
  uint64_t v37;
  uint64_t v38;
  const __CFString *v39;
  char v40;
  CFTypeRef v41;
  const __CFString *v42;
  __CFData *v43;
  uint64_t v44;
  uint64_t v45;
  UInt8 bytes;

  bytes = 4;
  if (!a1)
  {
    v35 = CFSTR("amfdr is NULL");
LABEL_42:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRModuleCreateSignedCSR", v35, v40);
    return 0;
  }
  if (!a2)
  {
    v35 = CFSTR("CertificationCtx is NULL");
    goto LABEL_42;
  }
  if (!*(_QWORD *)a2)
  {
    LOBYTE(v36) = 0;
LABEL_32:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRModuleCreateSignedCSR", CFSTR("moduleDataInstanceStr has wrong type: %@"), (char)v36);
    return 0;
  }
  v12 = CFGetTypeID(*(CFTypeRef *)a2);
  if (v12 != CFStringGetTypeID())
  {
    v36 = *(CFTypeRef *)a2;
    goto LABEL_32;
  }
  v13 = *(const void **)(a2 + 24);
  if (!v13)
  {
    LOBYTE(v37) = 0;
LABEL_35:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRModuleCreateSignedCSR", CFSTR("moduleChipNameStr has wrong type: %@"), v37);
    return 0;
  }
  v14 = CFGetTypeID(v13);
  if (v14 != CFStringGetTypeID())
  {
    v37 = *(_QWORD *)(a2 + 24);
    goto LABEL_35;
  }
  v15 = *(const void **)(a2 + 32);
  if (!v15)
  {
    LOBYTE(v38) = 0;
LABEL_38:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRModuleCreateSignedCSR", CFSTR("moduleRawPublicKey has wrong type: %@"), v38);
    return 0;
  }
  v16 = CFGetTypeID(v15);
  if (v16 != CFDataGetTypeID())
  {
    v38 = *(_QWORD *)(a2 + 32);
    goto LABEL_38;
  }
  if (!*(_QWORD *)(a2 + 40))
  {
    v35 = CFSTR("csrSign is NULL");
    goto LABEL_42;
  }
  if (!(_DWORD)a5)
  {
    v35 = CFSTR("cryptoVersion is undefined");
    goto LABEL_42;
  }
  if (!a4)
  {
    v35 = CFSTR("outSignedCsr is NULL");
    goto LABEL_42;
  }
  if (a3)
  {
    v17 = CFGetTypeID(a3);
    if (v17 == CFDictionaryGetTypeID())
    {
      Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a3, CFSTR("CertifyRawPublicKey"));
      if (Value)
      {
        v19 = Value;
        v20 = CFGetTypeID(Value);
        if (v20 == CFBooleanGetTypeID())
        {
          if (CFBooleanGetValue(v19))
          {
            if ((CFDataGetLength(*(CFDataRef *)(a2 + 32)) & 1) == 0)
            {
              v21 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
              Length = CFDataGetLength(*(CFDataRef *)(a2 + 32));
              Mutable = CFDataCreateMutable(v21, Length + 1);
              if (Mutable)
              {
                v24 = Mutable;
                CFDataAppendBytes(Mutable, &bytes, 1);
                BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a2 + 32));
                v26 = CFDataGetLength(*(CFDataRef *)(a2 + 32));
                CFDataAppendBytes(v24, BytePtr, v26);
                AMSupportLogInternal();
                v27 = v24;
                goto LABEL_21;
              }
            }
          }
        }
        AMSupportLogInternal();
        return 0;
      }
    }
  }
  v24 = 0;
  v27 = *(__CFData **)(a2 + 32);
LABEL_21:
  v41 = *(CFTypeRef *)a2;
  v42 = CFSTR("Components");
  v28 = *(_QWORD *)(a2 + 40);
  v43 = v27;
  v44 = v28;
  v45 = 0;
  data = (const __CFDictionary *)a1->data;
  if (!data)
  {
    v39 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_46;
  }
  v30 = (const __CFString *)CFDictionaryGetValue(data, CFSTR("OrganizationalUnit"));
  if (v30)
    v42 = v30;
  ModuleSignedCsr = AMFDRCryptoCreateModuleSignedCsr(a1, a5, (uint64_t)&v41, (const __CFDictionary *)a3, *(_QWORD *)(a2 + 56));
  if (!ModuleSignedCsr)
  {
    v39 = CFSTR("Failed to create csr, AMFDRCryptoCreateModuleSignedCsr failed.");
LABEL_46:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRModuleCreateSignedCSR", v39, v40);
    v33 = 0;
    if (!v24)
      return v33;
    goto LABEL_26;
  }
  v32 = ModuleSignedCsr;
  *a4 = CFRetain(ModuleSignedCsr);
  CFRelease(v32);
  v33 = 1;
  if (v24)
LABEL_26:
    CFRelease(v24);
  return v33;
}

uint64_t AMFDRModuleCertification(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t *a4)
{
  return AMFDRModuleCertificationWithOptions(a1, a2, 0, a3, a4);
}

uint64_t AMFDRModuleCertificationWithOptions(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4, uint64_t *a5)
{
  __CFDictionary *Mutable;
  const void *v10;
  const void *v11;
  const __CFDictionary *Value;
  const __CFDictionary *v13;
  CFTypeID v14;
  uint64_t v15;
  char v17;
  uint64_t v18;
  const __CFData *v19;
  uint64_t v20;

  v19 = 0;
  v20 = 0;
  v18 = 0;
  if (!a1
    || !a2
    || !*(_QWORD *)a2
    || !*(_QWORD *)(a2 + 24)
    || !*(_QWORD *)(a2 + 32)
    || !*(_QWORD *)(a2 + 40)
    || !*(_QWORD *)(a2 + 48))
  {
    goto LABEL_32;
  }
  if ((_AMFDRModuleCreateSignedCSR((__CFString *)a1, a2, a3, (CFTypeRef *)&v19, 514, (uint64_t)a5) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRModuleCertificationWithOptions", CFSTR("Failed to create csr, _AMFDRModuleCreateSignedCSR failed."), v17);
LABEL_33:
    v15 = 0;
    goto LABEL_21;
  }
  if (((*(uint64_t (**)(uint64_t, const __CFData *, uint64_t *, _QWORD))(a2 + 48))(4, v19, &v18, *(_QWORD *)(a2 + 56)) & 1) == 0)
  {
LABEL_32:
    AMSupportLogInternal();
    goto LABEL_33;
  }
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  CFDictionarySetValue(Mutable, CFSTR("x-fdr-chip-name"), *(const void **)(a2 + 24));
  v10 = *(const void **)(a2 + 16);
  if (v10)
    CFDictionarySetValue(Mutable, CFSTR("x-fdr-metadata-ChipID"), v10);
  v11 = *(const void **)(a2 + 8);
  if (v11)
    CFDictionarySetValue(Mutable, CFSTR("x-fdr-client-auth-kcv"), v11);
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("CertifyHeaders"));
  if (!Value
    || (v13 = Value, v14 = CFGetTypeID(Value), v14 == CFDictionaryGetTypeID())
    && !CFDictionaryContainsKey(v13, CFSTR("x-fdr-certification-type")))
  {
    CFDictionarySetValue(Mutable, CFSTR("x-fdr-certification-type"), CFSTR("component"));
  }
  if (Mutable && (_AMFDRCertificateSigningRequestInternal((CFDictionaryRef *)a1, v19, v18, Mutable, a4, &v20) & 1) != 0)
  {
    v15 = 1;
  }
  else
  {
    AMSupportLogInternal();
    v15 = 0;
  }
LABEL_21:
  if (a5)
    *a5 = AMSupportSafeRetain();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v15;
}

uint64_t AMFDRSensorAuthCertification(CFDictionaryRef *a1, CFTypeRef cf, CFTypeRef *a3, uint64_t *a4)
{
  CFTypeID v8;
  const void *Value;
  uint64_t v10;
  CFTypeID v11;
  const __CFData *v12;
  const __CFData *v13;
  CFTypeID v14;
  uint64_t v15;
  const __CFString *v17;
  char v18;
  uint64_t v19;

  v19 = 0;
  if (!a1)
  {
    v17 = CFSTR("amfdr is NULL");
LABEL_17:
    AMFDRErrorPushInternal((uint64_t)&v19, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSensorAuthCertification", v17, v18);
LABEL_18:
    v15 = 0;
    if (!a4)
      goto LABEL_11;
    goto LABEL_10;
  }
  if (!cf || (v8 = CFGetTypeID(cf), v8 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)&v19, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSensorAuthCertification", CFSTR("certificationOptions has wrong type: %@"), (char)cf);
    goto LABEL_18;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("CertifySaltAttestationSignature"));
  v10 = (uint64_t)Value;
  if (!Value || (v11 = CFGetTypeID(Value), v11 != CFDataGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)&v19, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSensorAuthCertification", CFSTR("saltWtihAttestationSignature has wrong type: %@"), v10);
    goto LABEL_18;
  }
  v12 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("CertifySignedCSR"));
  v13 = v12;
  if (!v12 || (v14 = CFGetTypeID(v12), v14 != CFDataGetTypeID()))
  {
    AMFDRErrorPushInternal((uint64_t)&v19, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSensorAuthCertification", CFSTR("csrDerData has wrong type: %@"), (char)v13);
    goto LABEL_18;
  }
  if ((_AMFDRCertificateSigningRequestInternal(a1, v13, v10, 0, a3, &v19) & 1) == 0)
  {
    v18 = v19;
    v17 = CFSTR("_AMFDRCertificateSigningRequestInternal() failed: %@");
    goto LABEL_17;
  }
  v15 = 1;
  if (a4)
LABEL_10:
    *a4 = AMSupportSafeRetain();
LABEL_11:
  AMSupportSafeRelease();
  return v15;
}

const void *AMFDRChipCertifyForRestore(int a1, const void *a2, const __CFData *a3, uint64_t a4, const void *a5, const void *a6, const __CFString *SikPubDigestIfNecessary, CFTypeRef *a8, uint64_t *a9)
{
  const void *v9;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  CFTypeID v17;
  const __CFAllocator *v18;
  CFDictionaryRef *v19;
  CFDictionaryRef *v20;
  const __CFDictionary *MutableCopy;
  const __CFDictionary *v22;
  const __CFDictionary *Value;
  const __CFDictionary *v24;
  CFTypeID v25;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v27;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  CFTypeID v30;
  CFMutableDictionaryRef v31;
  CFMutableDictionaryRef v32;
  CFNumberRef v33;
  __CFDictionary *v34;
  const __CFDictionary *v35;
  const __CFDictionary *v36;
  CFTypeID v37;
  const __CFDictionary *v38;
  const __CFDictionary *v39;
  CFTypeID v40;
  const void *v41;
  const void *v42;
  CFTypeID v43;
  CFAllocatorRef v44;
  CFTypeID v45;
  UInt8 *BytePtr;
  CFIndex Length;
  CFStringRef v48;
  const void *SikPub;
  CFStringRef v50;
  uint64_t v51;
  const __CFString *v52;
  CFStringRef v53;
  const __CFString *format;
  const __CFString *v56;
  char v57;
  uint64_t v58;
  CFTypeRef *v59;
  CFStringRef v61;
  __CFDictionary *v62;
  const __CFString *v63;
  const void *v64;
  const void *v65;
  int valuePtr[3];

  valuePtr[0] = a1;
  v65 = 0;
  if ((a1 - 3) <= 0xFFFFFFFD)
  {
    AMFDRErrorPushInternal((uint64_t)a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("invalid fdrVersion: %d"), a1);
    return 0;
  }
  v9 = a2;
  if (!a2)
  {
    AMFDRErrorPushInternal((uint64_t)a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("certifyUrl is NULL"), v57);
    goto LABEL_81;
  }
  if (a3)
  {
    v15 = (const __CFDictionary *)AMFDRGetRestorePeriodOptions();
    v16 = v15;
    if (!v15)
      goto LABEL_7;
    v17 = CFGetTypeID(v15);
    if (v17 == CFDictionaryGetTypeID())
    {
      CFDictionaryGetCount(v16);
      AMSupportLogInternal();
LABEL_7:
      v58 = a4;
      v59 = a8;
      v18 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      v19 = (CFDictionaryRef *)AMFDRCreateTypeWithOptions((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("Remote"), v16);
      if (v19)
      {
        v20 = v19;
        if (v19[2])
        {
          if (AMFDREnableRestorePeriodSsoCallback((uint64_t)v19))
            AMSupportLogInternal();
          MutableCopy = CFDictionaryCreateMutableCopy(v18, 0, v20[2]);
          if (MutableCopy)
          {
            v22 = MutableCopy;
            Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, CFSTR("CertifyHeaders"));
            if (Value && (v24 = Value, v25 = CFGetTypeID(Value), v25 == CFDictionaryGetTypeID()))
              Mutable = CFDictionaryCreateMutableCopy(v18, 0, v24);
            else
              Mutable = CFDictionaryCreateMutable(v18, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
            v27 = Mutable;
            if (Mutable)
            {
              v28 = (const __CFDictionary *)CFDictionaryGetValue(v22, CFSTR("Metadata"));
              if (v28 && (v29 = v28, v30 = CFGetTypeID(v28), v30 == CFDictionaryGetTypeID()))
                v31 = CFDictionaryCreateMutableCopy(v18, 0, v29);
              else
                v31 = CFDictionaryCreateMutable(v18, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
              v32 = v31;
              if (v31)
              {
                v33 = CFNumberCreate(v18, kCFNumberIntType, valuePtr);
                if (v33)
                {
                  CFDictionarySetValue(v22, CFSTR("DataVersion"), v33);
                  CFDictionarySetValue(v22, CFSTR("CertifyURL"), v9);
                  CFDictionarySetValue(v22, CFSTR("CertifyBase64"), (const void *)*MEMORY[0x24BDBD270]);
                  CFDictionarySetValue(v27, CFSTR("x-fdr-attestation"), CFSTR("true"));
                  if (valuePtr[0] == 1)
                  {
                    if (a5)
                      CFDictionarySetValue(v27, CFSTR("x-fdr-chip-name"), a5);
                    if (a6)
                      CFDictionarySetValue(v27, CFSTR("x-fdr-csr-DataClassRequest"), a6);
                    CFDictionarySetValue(v27, CFSTR("x-fdr-certification-type"), CFSTR("component"));
                  }
                  if (!SikPubDigestIfNecessary)
                  {
                    v34 = 0;
                    v42 = 0;
                    v64 = 0;
                    v50 = 0;
                    if (valuePtr[0] != 2)
                    {
LABEL_54:
                      v61 = v50;
                      v63 = SikPubDigestIfNecessary;
                      v62 = v34;
                      if (CFDictionaryGetCount(v32))
                      {
                        SikPubDigestIfNecessary = 0;
LABEL_61:
                        CFDictionaryRemoveValue(v22, CFSTR("CertifyHeaders"));
                        CFDictionarySetValue(v22, CFSTR("Metadata"), v32);
                        AMFDRSetOptions((uint64_t)v20, v22);
                        v9 = (const void *)_AMFDRCertificateSigningRequestInternal(v20, a3, v58, v27, v59, a9);
                      }
                      else
                      {
                        v51 = 0;
                        SikPubDigestIfNecessary = 0;
                        while (1)
                        {
                          if (SikPubDigestIfNecessary)
                            CFRelease(SikPubDigestIfNecessary);
                          v52 = off_24C69F358[v51];
                          SikPubDigestIfNecessary = AMFDRSealingMapCallMGCopyAnswer(v52, 0);
                          if (!SikPubDigestIfNecessary)
                            break;
                          CFDictionarySetValue(v32, off_24C69F340[v51++], SikPubDigestIfNecessary);
                          if (v51 == 3)
                            goto LABEL_61;
                        }
                        AMFDRErrorPushInternal((uint64_t)a9, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("failed to query %@"), (char)v52);
                        v9 = 0;
                      }
                      v34 = v62;
                      v53 = v61;
                      goto LABEL_63;
                    }
                    goto LABEL_50;
                  }
                  v34 = CFDictionaryCreateMutableCopy(v18, 0, (CFDictionaryRef)SikPubDigestIfNecessary);
                  if (v34)
                  {
                    v35 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)SikPubDigestIfNecessary, CFSTR("CertifyHeaders"));
                    if (v35)
                    {
                      v36 = v35;
                      v37 = CFGetTypeID(v35);
                      if (v37 == CFDictionaryGetTypeID())
                      {
                        _CFDictionaryAddDictionary(v27, v36);
                        CFDictionaryRemoveValue(v34, CFSTR("CertifyHeaders"));
                      }
                    }
                    v38 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)SikPubDigestIfNecessary, CFSTR("Metadata"));
                    if (v38)
                    {
                      v39 = v38;
                      v40 = CFGetTypeID(v38);
                      if (v40 == CFDictionaryGetTypeID())
                      {
                        _CFDictionaryAddDictionary(v32, v39);
                        CFDictionaryRemoveValue(v34, CFSTR("Metadata"));
                      }
                    }
                    v64 = _CFDictionaryCopyValue((const __CFDictionary *)SikPubDigestIfNecessary, CFSTR("CertifySikPub"));
                    if (v64)
                      CFDictionaryRemoveValue(v34, CFSTR("CertifySikPub"));
                    v41 = _CFDictionaryCopyValue((const __CFDictionary *)SikPubDigestIfNecessary, CFSTR("CertifyManifestSigCert"));
                    v42 = v41;
                    if (v41)
                    {
                      v43 = CFGetTypeID(v41);
                      if (v43 != CFDataGetTypeID())
                      {
                        v56 = CFSTR("partialIm4mData is in malformed format");
LABEL_104:
                        AMFDRErrorPushInternal((uint64_t)a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", v56, v57);
                        goto LABEL_105;
                      }
                      CFDictionaryRemoveValue(v34, CFSTR("CertifyManifestSigCert"));
                      v44 = CFGetAllocator(v20);
                      if ((_AMFDRSupportBase64Encode((uint64_t)v44, (uint64_t)v42, (uint64_t)&v65) & 1) == 0)
                      {
                        AMSupportLogInternal();
LABEL_105:
                        v9 = 0;
                        SikPubDigestIfNecessary = 0;
                        goto LABEL_106;
                      }
                      CFDictionarySetValue(v27, CFSTR("x-fdr-partial-im4m"), v65);
                    }
                    _CFDictionaryAddDictionary(v22, v34);
                    if (valuePtr[0] != 2)
                    {
                      SikPubDigestIfNecessary = 0;
                      v50 = 0;
                      goto LABEL_54;
                    }
                    if (v64)
                    {
                      v45 = CFGetTypeID(v64);
                      if (v45 == CFDataGetTypeID())
                      {
                        BytePtr = (UInt8 *)CFDataGetBytePtr((CFDataRef)v64);
                        Length = CFDataGetLength((CFDataRef)v64);
                        SikPubDigestIfNecessary = (const __CFString *)AMFDRDataCreateSikPubDigestIfNecessary(v18, BytePtr, Length);
                        if (SikPubDigestIfNecessary)
                        {
                          v48 = AMFDRCreateInstanceString(v18, SikPubDigestIfNecessary);
                          SikPub = v48;
                          if (v48)
                          {
                            v50 = v48;
LABEL_52:
                            CFDictionarySetValue(v27, CFSTR("x-fdr-client-id-sik"), SikPub);
                            goto LABEL_54;
                          }
                          v63 = SikPubDigestIfNecessary;
                          AMFDRErrorPushInternal((uint64_t)a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("sikDigestString is NULL"), v57);
                          v9 = 0;
                          SikPubDigestIfNecessary = 0;
                          goto LABEL_107;
                        }
                        AMFDRErrorPushInternal((uint64_t)a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("sikDigest is NULL"), v57);
                        v9 = 0;
LABEL_106:
                        v63 = 0;
LABEL_107:
                        v53 = 0;
                        goto LABEL_63;
                      }
                      v56 = CFSTR("sikData is in malformed format");
                      goto LABEL_104;
                    }
LABEL_50:
                    SikPub = (const void *)AMFDRCryptoGetSikPub((uint64_t)v20);
                    if (SikPub)
                    {
                      v64 = 0;
                      SikPubDigestIfNecessary = 0;
                      v50 = 0;
                      goto LABEL_52;
                    }
                    AMFDRErrorPushInternal((uint64_t)a9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("sikPubString is NULL"), v57);
                    v9 = 0;
                    SikPubDigestIfNecessary = 0;
                    v64 = 0;
                    goto LABEL_106;
                  }
                  AMFDRErrorPushInternal((uint64_t)a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("extraOptionsCopy is NULL"), v57);
                  v9 = 0;
                }
                else
                {
                  AMFDRErrorPushInternal((uint64_t)a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("fdrVersionNumber is NULL"), v57);
                  v9 = 0;
                  v34 = 0;
                }
LABEL_99:
                SikPubDigestIfNecessary = 0;
                v63 = 0;
                v64 = 0;
                v53 = 0;
                v42 = 0;
LABEL_63:
                CFRelease(v20);
                CFRelease(v22);
                if (v27)
                  CFRelease(v27);
                if (v32)
                  CFRelease(v32);
                if (v34)
                  CFRelease(v34);
                if (v33)
                  CFRelease(v33);
                if (SikPubDigestIfNecessary)
                  CFRelease(SikPubDigestIfNecessary);
                if (v64)
                  CFRelease(v64);
                if (v63)
                  CFRelease(v63);
                if (v53)
                  CFRelease(v53);
                if (v42)
                  CFRelease(v42);
                goto LABEL_81;
              }
              AMFDRErrorPushInternal((uint64_t)a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("metadataDict is NULL"), v57);
              v9 = 0;
              v34 = 0;
            }
            else
            {
              AMFDRErrorPushInternal((uint64_t)a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("certifyHeaders is NULL"), v57);
              v9 = 0;
              v34 = 0;
              v32 = 0;
            }
            v33 = 0;
            goto LABEL_99;
          }
          format = CFSTR("fdrOptions is NULL");
        }
        else
        {
          format = CFSTR("amfdr->optionsDict is NULL");
        }
        AMFDRErrorPushInternal((uint64_t)a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", format, v57);
        CFRelease(v20);
      }
      else
      {
        AMFDRErrorPushInternal((uint64_t)a9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("amfdr is NULL"), v57);
      }
      goto LABEL_97;
    }
    AMFDRErrorPushInternal((uint64_t)a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("fdrRestoreOptions is malformed"), v57);
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)a9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRChipCertifyForRestore", CFSTR("csrData is NULL"), v57);
  }
LABEL_97:
  v9 = 0;
LABEL_81:
  if (v65)
    CFRelease(v65);
  return v9;
}

CFDataRef AMFDRDataCreateMultiDataAsMultiResponse(const __CFArray *a1, const __CFArray *a2, uint64_t a3)
{
  int v6;
  CFIndex Count;
  CFAllocatorRef *v8;
  CFIndex v9;
  const __CFData *v10;
  const __CFAllocator *v11;
  const __CFString *ValueAtIndex;
  const __CFData *v13;
  const __CFData *ExternalRepresentation;
  const UInt8 *BytePtr;
  int v16;
  const UInt8 *v17;
  int v18;
  int v19;
  int v20;
  CFDataRef v21;
  char v23;
  uint64_t v24;
  _DWORD length[3];
  uint64_t v26;

  v26 = 0;
  memset(length, 0, sizeof(length));
  v6 = AMFDREncodeMultiResponseBegin((uint64_t)&v26);
  if (v6)
  {
    AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateMultiDataAsMultiResponse", CFSTR("AMFDREncodeMultiRequestBegin failed 0x%X"), v6);
LABEL_18:
    v21 = 0;
  }
  else
  {
    v24 = a3;
    Count = CFArrayGetCount(a1);
    v8 = (CFAllocatorRef *)MEMORY[0x24BDBD240];
    if (Count >= 1)
    {
      v9 = 0;
      v10 = 0;
      v11 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      while (1)
      {
        if (v10)
          CFRelease(v10);
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, v9);
        v13 = (const __CFData *)CFArrayGetValueAtIndex(a2, v9);
        ExternalRepresentation = CFStringCreateExternalRepresentation(v11, ValueAtIndex, 0x8000100u, 0x5Fu);
        if (!ExternalRepresentation)
        {
          AMFDRErrorPushInternal(v24, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateMultiDataAsMultiResponse", CFSTR("failed to create data class instance data"), v23);
          goto LABEL_18;
        }
        v10 = ExternalRepresentation;
        BytePtr = CFDataGetBytePtr(ExternalRepresentation);
        v16 = CFDataGetLength(v10);
        v17 = CFDataGetBytePtr(v13);
        v18 = CFDataGetLength(v13);
        v19 = AMFDREncodeMultiResponseAddRecord((uint64_t)&v26, (uint64_t)BytePtr, v16, (uint64_t)v17, v18, 0, 0, 0, 0);
        if (v19)
          break;
        if (++v9 >= CFArrayGetCount(a1))
          goto LABEL_11;
      }
      AMFDRErrorPushInternal(v24, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateMultiDataAsMultiResponse", CFSTR("AMFDREncodeMultiRequestAddRecord failed 0x%X"), v19);
      v21 = 0;
      goto LABEL_15;
    }
    v10 = 0;
LABEL_11:
    v20 = AMFDREncodeMultiResponseEnd(&v26, &length[1], length);
    if (v20)
    {
      AMFDRErrorPushInternal(v24, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateMultiDataAsMultiResponse", CFSTR("AMFDREncodeMultiRequestEnd failed 0x%X"), v20);
      v21 = 0;
    }
    else
    {
      v21 = CFDataCreate(*v8, *(const UInt8 **)&length[1], length[0]);
      if (!v21)
        AMFDRErrorPushInternal(v24, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataCreateMultiDataAsMultiResponse", CFSTR("outData is NULL"), v23);
    }
    if (v10)
LABEL_15:
      CFRelease(v10);
  }
  AMFDREncodeMultiRequestDestroy((uint64_t)&v26);
  return v21;
}

CFTypeRef _CopyPersistentDataPath(CFDictionaryRef *a1, const void *a2)
{
  const void *Value;
  const void *v4;

  Value = CFDictionaryGetValue(a1[2], a2);
  if (!Value)
    return (CFTypeRef)AMFDRPlatformCopyDefaultDataDirectoryAppendingPathComponent(a1);
  v4 = Value;
  MEMORY[0x212BA04D4]();
  return CFRetain(v4);
}

void ___thr_AMFDRSavePersistent(uint64_t a1)
{
  CFDictionaryRef *v1;
  _BYTE *v2;
  CFTypeRef v3;
  const void *v4;

  v1 = *(CFDictionaryRef **)a1;
  v2 = *(_BYTE **)(a1 + 32);
  v3 = _CopyPersistentDataPath(*(CFDictionaryRef **)a1, *(const void **)(a1 + 8));
  if (v3)
  {
    v4 = v3;
    CFGetAllocator(v1);
    if (AMSupportWriteDataToFileURL())
      AMSupportLogInternal();
    else
      *v2 = 1;
    CFRelease(v4);
  }
  else
  {
    AMSupportLogInternal();
  }
}

void _InsertHeader(const void *a1, const void *a2, uint64_t a3)
{
  __CFHTTPMessage *v5;
  CFTypeID v7;
  CFTypeID v8;
  const __CFAllocator *v9;
  const __CFString *v10;
  CFTypeID v11;
  const __CFString *v12;
  CFTypeID v13;
  CFStringRef value;

  value = 0;
  if (!a1)
  {
    AMSupportLogInternal();
    return;
  }
  if (!a2
    || (v5 = *(__CFHTTPMessage **)a3) == 0
    || (v7 = CFGetTypeID(*(CFTypeRef *)a3), v7 != CFHTTPMessageGetTypeID())
    || (v8 = CFGetTypeID(a1), v8 != CFStringGetTypeID()))
  {
    AMSupportLogInternal();
    goto LABEL_19;
  }
  v9 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@%@"), *(_QWORD *)(a3 + 8), a1);
  v11 = CFGetTypeID(a2);
  if (v11 == CFStringGetTypeID())
  {
    v12 = (const __CFString *)CFRetain(a2);
LABEL_13:
    value = v12;
    goto LABEL_14;
  }
  v13 = CFGetTypeID(a2);
  if (v13 != CFDataGetTypeID())
  {
    v12 = CFStringCreateWithFormat(v9, 0, CFSTR("%@"), a2);
    goto LABEL_13;
  }
  if ((_AMFDRSupportBase64Encode((uint64_t)v9, (uint64_t)a2, (uint64_t)&value) & 1) == 0 || (v12 = value) == 0)
  {
LABEL_17:
    AMSupportLogInternal();
    if (!v10)
      goto LABEL_19;
    goto LABEL_18;
  }
LABEL_14:
  if (!CFStringGetLength(v12))
    goto LABEL_17;
  CFHTTPMessageSetHeaderFieldValue(v5, v10, value);
  if (v10)
LABEL_18:
    CFRelease(v10);
LABEL_19:
  if (value)
    CFRelease(value);
}

uint64_t _AMFDRHttpMessageSendSync(CFDictionaryRef *a1, CFHTTPMessageRef request, CFTypeRef *a3, CFTypeRef *a4, _QWORD *a5, SInt32 a6, unsigned int a7, uint64_t (*a8)(CFDictionaryRef *, __CFHTTPMessage *, __CFDictionary *, uint64_t, uint64_t), uint64_t (*a9)(CFDictionaryRef *, CFHTTPMessageRef, CFDictionaryRef *, CFTypeRef *, uint64_t *, _QWORD, CFErrorRef *), uint64_t a10, uint64_t a11)
{
  CFURLRef v16;
  const __CFBoolean *Value;
  const __CFBoolean *v18;
  CFTypeID v19;
  BOOL v20;
  NSObject *v21;
  __CFDictionary *Mutable;
  const void *v23;
  dispatch_time_t v24;
  __CFDictionary *v25;
  const void *v26;
  CFTypeID v27;
  const __CFDictionary *v28;
  const void *v29;
  const void *v30;
  CFTypeID v31;
  const __CFNumber *v32;
  CFNumberRef v33;
  const __CFAllocator *v34;
  CFTypeID v35;
  const __CFAllocator *v36;
  __CFDictionary *v37;
  char v38;
  const __CFAllocator *v39;
  const __CFBoolean *v40;
  const __CFBoolean *v41;
  CFTypeID v42;
  const __CFAllocator *v43;
  __CFArray *v44;
  const void *v45;
  const void *v46;
  CFTypeID v47;
  uint64_t v48;
  CFTypeID v49;
  const __CFData *v50;
  const __CFData *v51;
  const __CFAllocator *v52;
  const __CFArray *v53;
  int v54;
  const __CFDictionary *v55;
  const __CFNumber *v56;
  const __CFNumber *v57;
  CFTypeID v58;
  __CFDictionary *v59;
  unsigned int v60;
  uint64_t (*v61)(CFDictionaryRef *, __CFHTTPMessage *, __CFDictionary *, uint64_t, uint64_t);
  __CFHTTPMessage *v62;
  const __CFAllocator *v63;
  CFNumberRef v64;
  int v65;
  const __CFData *v66;
  const __CFDictionary *v67;
  CFIndex Count;
  const void **v69;
  const void **v70;
  const void **v71;
  const void **v72;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFStringRef v75;
  const void *v76;
  __int128 v77;
  CFDataRef v78;
  const __CFDictionary *v79;
  const __CFString *v80;
  SInt32 IntValue;
  const __CFString *v82;
  SInt32 v83;
  const __CFString *v84;
  SInt32 v85;
  const __CFString *format;
  _QWORD *v88;
  __CFDictionary *v89;
  const __CFURL *v90;
  CFTypeRef *v91;
  CFTypeRef *v92;
  const __CFAllocator *v93;
  int v94;
  void *key;
  const __CFNumber *v98;
  __CFDictionary *theDict;
  CFDictionaryRef *cf;
  CFDictionaryRef v101;
  CFTypeRef v102;
  uint64_t v103;
  CFErrorRef v104;
  SInt32 v105;
  uint64_t v106;
  uint64_t *v107;
  uint64_t v108;
  char v109;
  __int128 valuePtr;
  __int128 v111;
  uint64_t *v112;
  NSObject *v113;
  uint64_t v114;
  CFRange v115;
  CFRange v116;

  v114 = *MEMORY[0x24BDAC8D0];
  v105 = a6;
  v103 = -1;
  v104 = 0;
  v101 = 0;
  v102 = 0;
  if (!request)
  {
    AMFDRErrorPushInternal(a11, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessageSendSync", CFSTR("httpRequest is NULL"), (char)v88);
    v48 = 0;
    v44 = 0;
    v16 = 0;
    v25 = 0;
    goto LABEL_149;
  }
  v16 = CFHTTPMessageCopyRequestURL(request);
  if (!v16)
  {
    AMFDRErrorPushInternal(a11, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessageSendSync", CFSTR("No URL in request"), (char)v88);
    goto LABEL_36;
  }
  cf = a1;
  if (!_AMFDRHttpProxyIsEnabled((uint64_t)a1))
    goto LABEL_34;
  Value = (const __CFBoolean *)CFDictionaryGetValue(a1[2], CFSTR("EnableProxy"));
  if (Value)
  {
    v18 = Value;
    v19 = CFGetTypeID(Value);
    v20 = v19 == CFBooleanGetTypeID();
    a1 = cf;
    if (v20)
    {
      if (CFBooleanGetValue(v18))
      {
        v21 = dispatch_semaphore_create(0);
        v106 = 0;
        v107 = &v106;
        v108 = 0x2000000000;
        v109 = 0;
        if (cf[2])
        {
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
          CFDictionaryAddValue(Mutable, CFSTR("TestReachability"), (const void *)*MEMORY[0x24BDBD268]);
          *(_QWORD *)&valuePtr = MEMORY[0x24BDAC760];
          *((_QWORD *)&valuePtr + 1) = 0x40000000;
          *(_QWORD *)&v111 = ___AMFDRHttpCopyPurpleReverseProxyInformation_block_invoke;
          *((_QWORD *)&v111 + 1) = &unk_24C69F448;
          v112 = &v106;
          v113 = v21;
          v23 = (const void *)RPRegisterForAvailability();
          if (v23
            && (RPRegistrationResume(),
                v24 = dispatch_time(0, 5000000000),
                dispatch_semaphore_wait(v21, v24),
                MEMORY[0x212BA0D74](v23),
                *((_BYTE *)v107 + 24)))
          {
            v25 = (__CFDictionary *)RPCopyProxyDictionaryWithOptions();
            if (!v21)
              goto LABEL_29;
          }
          else
          {
            AMSupportLogInternal();
            v25 = 0;
            if (!v21)
              goto LABEL_29;
          }
        }
        else
        {
          AMSupportLogInternal();
          v25 = 0;
          Mutable = 0;
          v23 = 0;
          if (!v21)
          {
LABEL_29:
            if (v23)
              CFRelease(v23);
            if (Mutable)
              CFRelease(Mutable);
            _Block_object_dispose(&v106, 8);
            a1 = cf;
            if (!v25)
              goto LABEL_34;
LABEL_26:
            v38 = 0;
            goto LABEL_38;
          }
        }
        dispatch_release(v21);
        goto LABEL_29;
      }
    }
  }
  v26 = CFDictionaryGetValue(a1[2], CFSTR("UseSOCKSHost"));
  if (v26)
  {
    v27 = CFGetTypeID(v26);
    if (v27 == CFStringGetTypeID())
    {
      LODWORD(valuePtr) = 1080;
      v28 = a1[2];
      if (!v28)
      {
        AMSupportLogInternal();
        v25 = 0;
LABEL_25:
        AMSupportSafeRelease();
        if (v25)
          goto LABEL_26;
        goto LABEL_34;
      }
      v29 = CFDictionaryGetValue(v28, CFSTR("UseSOCKSHost"));
      if (!v29 || (v30 = v29, v31 = CFGetTypeID(v29), v31 != CFStringGetTypeID()))
      {
        AMSupportLogInternal();
        v25 = 0;
LABEL_24:
        a1 = cf;
        goto LABEL_25;
      }
      v32 = (const __CFNumber *)CFDictionaryGetValue(cf[2], CFSTR("UseSOCKSPort"));
      if (v32)
      {
        v33 = v32;
        CFRetain(v32);
      }
      else
      {
        v34 = CFGetAllocator(cf);
        v33 = CFNumberCreate(v34, kCFNumberSInt32Type, &valuePtr);
        if (!v33)
        {
LABEL_170:
          AMSupportLogInternal();
          v25 = 0;
          goto LABEL_24;
        }
      }
      v35 = CFGetTypeID(v33);
      if (v35 == CFNumberGetTypeID())
      {
        v36 = CFGetAllocator(cf);
        v37 = CFDictionaryCreateMutable(v36, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        v25 = v37;
        if (v37)
        {
          CFDictionaryAddValue(v37, CFSTR("SOCKSProxy"), v30);
          CFDictionaryAddValue(v25, CFSTR("SOCKSPort"), v33);
        }
        else
        {
          AMSupportLogInternal();
        }
        goto LABEL_24;
      }
      goto LABEL_170;
    }
  }
LABEL_34:
  if (_AMFDRHttpProxyIsEnabled((uint64_t)a1))
  {
    AMFDRErrorPushInternal(a11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessageSendSync", CFSTR("Failed to copy proxy information and proxy is enabled."), (char)v88);
LABEL_36:
    v25 = 0;
LABEL_51:
    v44 = 0;
    v48 = 0;
    goto LABEL_147;
  }
  v25 = 0;
  v38 = 1;
LABEL_38:
  v39 = CFGetAllocator(a1);
  theDict = CFDictionaryCreateMutable(v39, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal(a11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessageSendSync", CFSTR("Failed to create connection options dictionary."), (char)v88);
    goto LABEL_51;
  }
  if ((v38 & 1) == 0)
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x24BEDA290], v25);
  v40 = (const __CFBoolean *)CFDictionaryGetValue(a1[2], CFSTR("EnableSslValidation"));
  if (v40)
  {
    v41 = v40;
    v42 = CFGetTypeID(v40);
    v20 = v42 == CFBooleanGetTypeID();
    a1 = cf;
    if (v20 && !CFBooleanGetValue(v41))
      CFDictionarySetValue(theDict, (const void *)*MEMORY[0x24BEDA288], (const void *)*MEMORY[0x24BDBD270]);
  }
  v43 = CFGetAllocator(a1);
  v44 = CFArrayCreateMutable(v43, 0, MEMORY[0x24BDBD690]);
  if (!v44)
  {
    AMFDRErrorPushInternal(a11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessageSendSync", CFSTR("sslRoots is NULL"), (char)v88);
    v48 = 0;
LABEL_166:
    v59 = theDict;
    goto LABEL_146;
  }
  v45 = CFDictionaryGetValue(a1[2], CFSTR("ExtraSslRoots"));
  if (v45)
  {
    v46 = v45;
    v47 = CFGetTypeID(v45);
    if (v47 == CFDataGetTypeID())
    {
      CFArrayAppendValue(v44, v46);
      a1 = cf;
    }
    else
    {
      v49 = CFGetTypeID(v46);
      v20 = v49 == CFArrayGetTypeID();
      a1 = cf;
      if (v20)
      {
        v115.length = CFArrayGetCount((CFArrayRef)v46);
        v115.location = 0;
        CFArrayAppendArray(v44, (CFArrayRef)v46, v115);
      }
    }
  }
  v50 = (const __CFData *)CFDictionaryGetValue(a1[2], CFSTR("TrustObject"));
  if (!v50)
  {
    AMSupportLogInternal();
    goto LABEL_59;
  }
  v51 = v50;
  v52 = CFGetAllocator(a1);
  v53 = AMFDRDataCopySslRoots(v52, v51, a11);
  v48 = (uint64_t)v53;
  if (!v53)
  {
    AMFDRErrorPushInternal(a11, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessageSendSync", CFSTR("No SSL Root found in trust object"), (char)v88);
    goto LABEL_166;
  }
  v116.length = CFArrayGetCount(v53);
  v116.location = 0;
  CFArrayAppendArray(v44, (CFArrayRef)v48, v116);
  CFRelease((CFTypeRef)v48);
LABEL_59:
  if (CFArrayGetCount(v44) >= 1)
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x24BEDA2A0], v44);
  v54 = 1;
  LODWORD(valuePtr) = 1;
  v55 = a1[2];
  v91 = a3;
  v92 = a4;
  if (v55)
  {
    v56 = (const __CFNumber *)CFDictionaryGetValue(v55, CFSTR("HTTPBackoff"));
    if (v56)
    {
      v57 = v56;
      v58 = CFGetTypeID(v56);
      if (v58 == CFNumberGetTypeID())
      {
        if (CFNumberGetValue(v57, kCFNumberSInt32Type, &valuePtr))
          v54 = valuePtr;
        else
          v54 = 1;
      }
      else
      {
        v54 = 1;
      }
      a1 = cf;
    }
  }
  v59 = theDict;
  if (!a7)
  {
    v98 = 0;
LABEL_132:
    if (v101)
    {
      if (v91 && v102)
        *v91 = CFRetain(v102);
      if (v92)
        *v92 = CFRetain(v101);
      *a5 = v103;
      v48 = 1;
    }
    else
    {
      AMFDRErrorPushInternal(a11, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessageSendSync", CFSTR("HTTP request failed, httpResponseDict is NULL"), (char)v88);
      v48 = 0;
    }
    v64 = v98;
    if (v98)
      goto LABEL_145;
    goto LABEL_146;
  }
  v89 = v25;
  v88 = a5;
  v90 = v16;
  key = (void *)*MEMORY[0x24BEDA298];
  v60 = 1;
  v93 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v62 = request;
  v61 = a8;
  do
  {
    v63 = CFGetAllocator(a1);
    v64 = CFNumberCreate(v63, kCFNumberSInt32Type, &v105);
    if (v64)
    {
      CFDictionarySetValue(v59, key, v64);
      if (!v61)
        goto LABEL_75;
    }
    else
    {
      AMSupportLogInternal();
      if (!v61)
        goto LABEL_75;
    }
    if ((v61(a1, v62, v59, a10, a11) & 1) == 0)
    {
      format = CFSTR("AMFDRHttpMessagePreAction failed");
      goto LABEL_143;
    }
LABEL_75:
    AMSupportLogInternal();
    _AMFDRHttpLogRequest(v62, 0, 0);
    AMSupportLogInternal();
    if (v104)
    {
      CFRelease(v104);
      v104 = 0;
    }
    v65 = AMSupportHttpSendSync();
    if (v65)
    {
      if (v65 == 23)
      {
        AMFDRErrorPushInternal(a11, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessageSendSync", CFSTR("SSL trust evaluation failed"), (char)v88);
        goto LABEL_144;
      }
      AMSupportLogInternal();
      v65 = 1;
    }
    if (v104)
    {
      AMSupportLogInternal();
      v65 = 1;
    }
    if (!v101)
    {
      AMSupportLogInternal();
      v65 = 1;
    }
    if (((unint64_t)(v103 - 401) > 0x12 || ((1 << (v103 + 111)) & 0x4000D) == 0)
      && v103 != 200
      && v103 != 202)
    {
      AMSupportLogInternal();
      AMFDRSetStat(a1, CFSTR("FDRLastUnexpectedResponse"), v103);
      goto LABEL_108;
    }
    if (v65)
      goto LABEL_108;
    v94 = v54;
    v98 = v64;
    AMSupportLogInternal();
    v67 = v101;
    v66 = (const __CFData *)v102;
    Count = CFDictionaryGetCount(v101);
    v69 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    v70 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    CFDictionaryGetKeysAndValues(v67, v69, v70);
    AMSupportLogInternal();
    v71 = v69;
    v72 = v70;
    if (Count >= 1)
    {
      do
      {
        ++v71;
        ++v72;
        AMSupportLogInternal();
        --Count;
      }
      while (Count);
    }
    v64 = v98;
    v59 = theDict;
    if (v66)
    {
      BytePtr = CFDataGetBytePtr(v66);
      Length = CFDataGetLength(v66);
      v75 = CFStringCreateWithBytes(v93, BytePtr, Length, 0x8000100u, 0);
      if (v75)
      {
        v76 = v75;
        AMSupportLogInternal();
LABEL_98:
        CFRelease(v76);
        goto LABEL_99;
      }
      *(_QWORD *)&v77 = -1;
      *((_QWORD *)&v77 + 1) = -1;
      valuePtr = v77;
      v111 = v77;
      CFDataGetBytePtr(v66);
      CFDataGetLength(v66);
      AMSupportDigestSha256();
      v78 = CFDataCreate(v93, (const UInt8 *)&valuePtr, 32);
      v76 = (const void *)AMSupportCopyHexStringFromData();
      CFDataGetLength(v66);
      AMSupportLogInternal();
      if (v78)
        CFRelease(v78);
      v59 = theDict;
      if (v76)
        goto LABEL_98;
    }
LABEL_99:
    if (v69)
      free(v69);
    v62 = request;
    v61 = a8;
    if (v70)
      free(v70);
    AMSupportLogInternal();
    a1 = cf;
    if (!a9)
      goto LABEL_131;
    if (v104)
    {
      CFRelease(v104);
      v104 = 0;
    }
    v54 = v94;
    if ((a9(cf, request, &v101, &v102, &v103, *(_QWORD *)(a10 + 8), &v104) & 1) != 0)
    {
LABEL_131:
      v25 = v89;
      v16 = v90;
      a5 = v88;
      goto LABEL_132;
    }
    AMSupportLogInternal();
    if (AMFDRGetUnderlyingErrorCode((uint64_t)cf, &v104) != 11)
    {
      format = CFSTR("AMFDRHttpMessagePostAction failed");
LABEL_143:
      AMFDRErrorPushInternal(a11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessageSendSync", format, (char)v88);
      goto LABEL_144;
    }
LABEL_108:
    AMFDRIncrementStat(a1, CFSTR("FDRTotalHTTPFailures"));
    if (v60 < a7)
    {
      v79 = v101;
      if (v101)
      {
        v80 = (const __CFString *)CFDictionaryGetValue(v101, CFSTR("x-fdr-retry-backoff"));
        if (v80)
        {
          IntValue = CFStringGetIntValue(v80);
          if ((IntValue - 1) < 0x12C)
            v54 = IntValue;
        }
        v82 = (const __CFString *)CFDictionaryGetValue(v79, CFSTR("x-fdr-retry-attempts"));
        if (v82)
        {
          v83 = CFStringGetIntValue(v82);
          if ((v83 - 1) < 0x64)
            a7 = v83;
        }
        v84 = (const __CFString *)CFDictionaryGetValue(v79, CFSTR("x-fdr-retry-timeout"));
        if (v84)
        {
          v85 = CFStringGetIntValue(v84);
          if ((v85 - 1) <= 0x257)
            v105 = v85;
        }
      }
      AMSupportLogInternal();
      sleep(v54 * v60);
      v103 = -1;
      if (v101)
      {
        CFRelease(v101);
        v101 = 0;
      }
      a1 = cf;
      if (v102)
      {
        CFRelease(v102);
        v102 = 0;
      }
      if (v64)
        CFRelease(v64);
      v64 = 0;
      v101 = 0;
      v102 = 0;
    }
    ++v60;
  }
  while (v60 <= a7);
  if (a7 >= 2)
    AMSupportLogInternal();
  AMFDRErrorPushInternal(a11, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessageSendSync", CFSTR("got http failures"), (char)v88);
LABEL_144:
  v48 = 0;
  v25 = v89;
  v16 = v90;
  if (v64)
LABEL_145:
    CFRelease(v64);
LABEL_146:
  CFRelease(v59);
LABEL_147:
  if (v101)
  {
    CFRelease(v101);
    v101 = 0;
  }
LABEL_149:
  if (v102)
  {
    CFRelease(v102);
    v102 = 0;
  }
  if (v25)
    CFRelease(v25);
  if (v16)
    CFRelease(v16);
  if (v104)
  {
    CFRelease(v104);
    v104 = 0;
  }
  if (v44)
    CFRelease(v44);
  return v48;
}

uint64_t _AMFDRGetHttpTimeout(uint64_t a1)
{
  uint64_t v1;
  const __CFDictionary *v2;
  const __CFNumber *Value;
  const __CFNumber *v4;
  CFTypeID v5;
  unsigned int valuePtr;

  v1 = 120;
  valuePtr = 120;
  if (a1)
  {
    v2 = *(const __CFDictionary **)(a1 + 16);
    if (v2)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(v2, CFSTR("HTTPTimeout"));
      if (Value)
      {
        v4 = Value;
        v5 = CFGetTypeID(Value);
        if (v5 == CFNumberGetTypeID())
        {
          if (CFNumberGetValue(v4, kCFNumberSInt32Type, &valuePtr))
            return valuePtr;
          else
            return 120;
        }
      }
    }
  }
  return v1;
}

uint64_t _AMFDRHttpMessagePreAction(const __CFString *cf, __CFHTTPMessage *a2, int a3, _BYTE *a4, uint64_t a5)
{
  CFStringRef v6;
  unsigned int (*length)(CFAllocatorRef, CFTypeRef *, void *);
  CFAllocatorRef v9;
  CFAllocatorRef v10;
  const __CFAllocator *v11;
  const __CFUUID *v12;
  const __CFAllocator *v13;
  uint64_t v14;
  uint64_t v16;
  CFIndex v17;
  const __CFString *v18;
  void *v19[2];
  void *v20[2];
  __int128 v21;
  const __CFString *v22;
  CFStringRef value;
  CFTypeRef v24;

  v6 = cf;
  v24 = 0;
  value = 0;
  if (!cf)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessagePreAction", CFSTR("amfdr is NULL"), (char)value);
    v14 = 0;
    v12 = 0;
    goto LABEL_14;
  }
  if (!a2)
  {
    v22 = CFSTR("httpRequest is NULL");
    *(_OWORD *)v20 = 0u;
    v21 = 0u;
    *(_OWORD *)v19 = 0u;
    v16 = a5;
    v17 = 1;
    goto LABEL_32;
  }
  if (!a4)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessagePreAction", CFSTR("ctx is NULL"), (char)value);
LABEL_33:
    v14 = 0;
    v12 = 0;
    goto LABEL_34;
  }
  if (!*a4)
    goto LABEL_11;
  if (cf[1].length)
  {
    AMSupportLogInternal();
    length = (unsigned int (*)(CFAllocatorRef, CFTypeRef *, void *))v6[1].length;
    v9 = CFGetAllocator(v6);
    if (length(v9, &v24, v6[2].isa))
    {
      v18 = CFSTR("FDR failed to create SSO data.");
    }
    else
    {
      if (v24)
      {
        v10 = CFGetAllocator(v6);
        if ((_AMFDRSupportBase64Encode((uint64_t)v10, (uint64_t)v24, (uint64_t)&value) & 1) != 0)
        {
          AMSupportLogInternal();
          CFHTTPMessageSetHeaderFieldValue(a2, CFSTR("x-fdr-metadata-authuserid"), value);
          goto LABEL_11;
        }
        v22 = CFSTR("ssoData base64 conversion failed");
        *(_OWORD *)v20 = 0u;
        v21 = 0u;
        *(_OWORD *)v19 = 0u;
        v16 = a5;
        v17 = 3;
        goto LABEL_32;
      }
      v18 = CFSTR("FDR failed to create SSO data. (ssoData is NULL).");
    }
    v22 = v18;
    *(_OWORD *)v20 = 0u;
    v21 = 0u;
    *(_OWORD *)v19 = 0u;
    v16 = a5;
    v17 = 15;
LABEL_32:
    AMFDRErrorPushInternal(v16, v17, 0, 0, 0, 0, 0, 0, v19[0], v19[1], v20[0], v20[1], (void *)v21, *((void **)&v21 + 1), (uint64_t)"_AMFDRHttpMessagePreAction", v22, (char)value);
    goto LABEL_33;
  }
  AMSupportLogInternal();
LABEL_11:
  v11 = CFGetAllocator(v6);
  v12 = CFUUIDCreate(v11);
  if (!v12)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessagePreAction", CFSTR("failed to create uuid"), (char)value);
    v14 = 0;
LABEL_34:
    v6 = 0;
    goto LABEL_14;
  }
  v13 = CFGetAllocator(v6);
  v6 = CFUUIDCreateString(v13, v12);
  if (v6)
  {
    CFHTTPMessageSetHeaderFieldValue(a2, CFSTR("x-fdr-request-uuid"), v6);
    v14 = 1;
  }
  else
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMessagePreAction", CFSTR("failed to create uuid"), (char)value);
    v14 = 0;
  }
LABEL_14:
  if (v24)
  {
    CFRelease(v24);
    v24 = 0;
  }
  if (value)
  {
    CFRelease(value);
    value = 0;
  }
  if (v12)
    CFRelease(v12);
  if (v6)
    CFRelease(v6);
  return v14;
}

uint64_t _AMFDRHttpAuthenticationCallback(uint64_t a1, __CFHTTPMessage *a2, CFDictionaryRef *a3, CFTypeRef *a4, uint64_t *a5, void (*a6)(CFDataRef, CFTypeRef *, CFTypeRef *, int *), uint64_t a7)
{
  uint64_t v8;
  const __CFString *Value;
  const __CFAllocator *v14;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v16;
  uint64_t Count;
  const __CFAllocator *v18;
  CFMutableDictionaryRef Mutable;
  CFIndex v20;
  const __CFString *ValueAtIndex;
  CFIndex location;
  CFIndex v23;
  const __CFArray *v24;
  CFIndex v25;
  const __CFAllocator *v26;
  CFStringRef v27;
  const __CFString *v28;
  const __CFAllocator *v29;
  const __CFString *v30;
  const __CFAllocator *v31;
  CFMutableStringRef v32;
  const __CFAllocator *v33;
  CFMutableStringRef v34;
  __CFString *v35;
  const __CFDictionary *v36;
  const __CFString *v37;
  const __CFString *v38;
  const void *v39;
  const __CFURL *v40;
  const __CFURL *v41;
  CFStringRef v42;
  const __CFAllocator *v43;
  const __CFData *RandomNumber;
  const __CFAllocator *v45;
  CFIndex Length;
  CFIndex v47;
  __CFData *MutableCopy;
  const UInt8 *BytePtr;
  CFIndex v50;
  CFAllocatorRef v51;
  int v52;
  const UInt8 *v53;
  CFIndex v54;
  const __CFAllocator *v55;
  CFAllocatorRef v56;
  CFAllocatorRef v57;
  __int128 v58;
  const __CFAllocator *v59;
  CFIndex v60;
  CFIndex v61;
  const UInt8 *v62;
  CFIndex v63;
  const __CFAllocator *v64;
  CFDataRef v65;
  CFDataRef v66;
  CFAllocatorRef v67;
  CFAllocatorRef v68;
  const __CFAllocator *v69;
  CFStringRef v70;
  const __CFDictionary *v71;
  const __CFString *v72;
  const __CFAllocator *v73;
  SInt32 v74;
  char v75;
  const __CFString *format;
  const __CFString *v78;
  const __CFString *v79;
  uint64_t v80;
  const __CFString *v81;
  const __CFString *v82;
  const __CFString *v83;
  char v84;
  char v85;
  char v86;
  const void *v87;
  uint64_t *v88;
  CFTypeRef *v89;
  CFTypeRef *v90;
  uint64_t v91;
  const __CFString *v92;
  const __CFData *cf;
  CFDataRef v95;
  __CFHTTPMessage *request;
  const __CFDictionary *theDict;
  uint64_t v98;
  CFTypeRef v99;
  CFTypeRef v100;
  CFTypeRef v101;
  CFTypeRef v102;
  CFTypeRef v103;
  CFTypeRef v104;
  CFTypeRef v105;
  CFDataRef v106;
  int v107;
  int v108;
  CFIndex v109;
  UInt8 bytes[16];
  __int128 v111;
  uint64_t v112;
  CFRange v113;
  CFRange v114;
  CFRange v115;
  CFRange v116;
  CFRange v117;

  v8 = a1;
  v112 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticationCallback", CFSTR("amfdr is NULL"), v84);
    return v8;
  }
  if (!a2)
  {
    v78 = CFSTR("httpRequest is NULL");
LABEL_116:
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticationCallback", v78, v84);
    return 0;
  }
  if (!a3)
  {
    v78 = CFSTR("inOutHttpResponseHeader is NULL");
    goto LABEL_116;
  }
  if (!*a3)
  {
    v78 = CFSTR("*inOutHttpResponseHeader is NULL");
    goto LABEL_116;
  }
  if (!a4)
  {
    v78 = CFSTR("inOutHttpResponseData is NULL");
    goto LABEL_116;
  }
  if (!a5)
  {
    v78 = CFSTR("inOutHttpStatus is NULL");
    goto LABEL_116;
  }
  if (*a5 != 419 && *a5 != 401)
    return 1;
  AMSupportLogInternal();
  if (*a4)
  {
    CFRelease(*a4);
    *a4 = 0;
  }
  v107 = -1;
  v105 = 0;
  v106 = 0;
  v103 = 0;
  v104 = 0;
  v102 = 0;
  v100 = 0;
  v101 = 0;
  v98 = -1;
  v99 = 0;
  if (!*a3)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("*inOutHttpResponseHeader is NULL"), v84);
LABEL_121:
    v95 = 0;
    MutableCopy = 0;
    cf = 0;
    Value = 0;
    goto LABEL_122;
  }
  v90 = (CFTypeRef *)a3;
  Value = (const __CFString *)CFDictionaryGetValue(*a3, CFSTR("www-authenticate"));
  if (!Value)
  {
    AMFDRErrorPushInternal(a7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("authenticationStr is NULL"), v84);
    v95 = 0;
    MutableCopy = 0;
    cf = 0;
LABEL_122:
    v41 = 0;
    v42 = 0;
    RandomNumber = 0;
    Count = 0;
    v8 = 0;
    goto LABEL_68;
  }
  v14 = CFGetAllocator((CFTypeRef)v8);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v14, Value, CFSTR(","));
  if (!ArrayBySeparatingStrings)
  {
    AMFDRErrorPushInternal(a7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("responseParts is NULL"), v84);
    goto LABEL_121;
  }
  v16 = ArrayBySeparatingStrings;
  Count = CFArrayGetCount(ArrayBySeparatingStrings);
  if (!Count)
  {
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("arrayCount is 0"), v84);
    v95 = 0;
    v36 = 0;
    MutableCopy = 0;
    v92 = 0;
    cf = 0;
    v41 = 0;
    v42 = 0;
    goto LABEL_167;
  }
  v18 = CFGetAllocator((CFTypeRef)v8);
  Mutable = CFDictionaryCreateMutable(v18, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("responseParts is NULL"), v84);
    v95 = 0;
    v36 = 0;
    goto LABEL_126;
  }
  v88 = a5;
  v89 = a4;
  request = a2;
  theDict = Mutable;
  v91 = a7;
  if (Count < 1)
  {
LABEL_25:
    v36 = theDict;
    v37 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("nonce"));
    v38 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("qop"));
    v39 = CFDictionaryGetValue(theDict, CFSTR("realm"));
    if (CFStringCompare(v38, CFSTR("auth"), 1uLL) == kCFCompareEqualTo)
    {
      v40 = CFHTTPMessageCopyRequestURL(request);
      v41 = v40;
      if (v40)
      {
        v42 = CFURLCopyPath(v40);
        if (v42)
        {
          v43 = CFGetAllocator((CFTypeRef)v8);
          if ((AMFDRSupportBase64Decode(v43, v37, (uint64_t)&v106) & 1) != 0)
          {
            if (v106)
            {
              RandomNumber = (const __CFData *)AMSupportCreateRandomNumber();
              if (!RandomNumber)
              {
                AMFDRErrorPushInternal(v91, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("salt is NULL"), v84);
                v95 = 0;
                MutableCopy = 0;
                v92 = 0;
                cf = 0;
                goto LABEL_151;
              }
              v87 = v39;
              v45 = CFGetAllocator((CFTypeRef)v8);
              Length = CFDataGetLength(v106);
              v47 = CFDataGetLength(RandomNumber);
              MutableCopy = CFDataCreateMutableCopy(v45, v47 + Length, v106);
              cf = RandomNumber;
              if (MutableCopy)
              {
                BytePtr = CFDataGetBytePtr(RandomNumber);
                v50 = CFDataGetLength(RandomNumber);
                CFDataAppendBytes(MutableCopy, BytePtr, v50);
                v51 = CFGetAllocator((CFTypeRef)v8);
                if ((_AMFDRSupportBase64Encode((uint64_t)v51, (uint64_t)RandomNumber, (uint64_t)&v99) & 1) == 0)
                {
                  AMFDRErrorPushInternal(v91, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("_AMFDRSupportBase64Encode failed"), v84);
                  goto LABEL_145;
                }
                if (!v99)
                {
                  AMFDRErrorPushInternal(v91, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("base64EncodedSalt is NULL"), v84);
                  goto LABEL_145;
                }
                v109 = 0;
                *(_QWORD *)bytes = 0;
                v108 = 0;
                if (AMFDRCryptoGetCryptoVersion(v8, 1u, &v108))
                {
                  v80 = v91;
                  AMFDRErrorPushInternal(v91, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpNonceSign", CFSTR("AMFDRCryptoGetCryptoVersion failed"), v84);
                }
                else
                {
                  v52 = v108;
                  v53 = CFDataGetBytePtr(MutableCopy);
                  v54 = CFDataGetLength(MutableCopy);
                  if (AMFDRCryptoCreateDataSignature(v52, (uint64_t)v53, v54, (void **)bytes, &v109, (CFTypeRef)v8) == 100)
                  {
                    if (*(_QWORD *)bytes)
                    {
                      if (v109)
                      {
                        v55 = CFGetAllocator((CFTypeRef)v8);
                        v95 = CFDataCreateWithBytesNoCopy(v55, *(const UInt8 **)bytes, v109, (CFAllocatorRef)*MEMORY[0x24BDBD248]);
                        if (v95)
                        {
                          *(_QWORD *)bytes = 0;
                          AMSupportSafeFree();
                          v56 = CFGetAllocator((CFTypeRef)v8);
                          if ((_AMFDRSupportBase64Encode((uint64_t)v56, (uint64_t)v95, (uint64_t)&v105) & 1) != 0)
                          {
                            if (!v105)
                            {
                              v82 = CFSTR("base64EncodedNonceSignature is NULL");
LABEL_148:
                              AMFDRErrorPushInternal(v91, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", v82, v84);
                              goto LABEL_149;
                            }
                            v57 = CFGetAllocator((CFTypeRef)v8);
                            if ((_AMFDRSupportBase64Encode((uint64_t)v57, *(_QWORD *)(v8 + 32), (uint64_t)&v100) & 1) != 0)
                            {
                              if (v100)
                              {
                                if (a6)
                                {
                                  *(_QWORD *)&v58 = -1;
                                  *((_QWORD *)&v58 + 1) = -1;
                                  *(_OWORD *)bytes = v58;
                                  v111 = v58;
                                  v59 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
                                  v60 = CFDataGetLength(MutableCopy);
                                  v61 = CFDataGetLength(*(CFDataRef *)(v8 + 32));
                                  RandomNumber = CFDataCreateMutableCopy(v59, v61 + v60, MutableCopy);
                                  if (RandomNumber)
                                  {
                                    v62 = CFDataGetBytePtr(*(CFDataRef *)(v8 + 32));
                                    v63 = CFDataGetLength(*(CFDataRef *)(v8 + 32));
                                    CFDataAppendBytes(RandomNumber, v62, v63);
                                    CFDataGetBytePtr(RandomNumber);
                                    CFDataGetLength(RandomNumber);
                                    AMSupportDigestSha256();
                                    v64 = CFGetAllocator((CFTypeRef)v8);
                                    v65 = CFDataCreate(v64, bytes, 32);
                                    if (v65)
                                    {
                                      v66 = v65;
                                      a6(v65, &v104, &v103, &v107);
                                      v92 = (const __CFString *)v66;
                                      if (v107)
                                      {
                                        AMFDRErrorPushInternal(v91, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("ChallengeClaim callback fail with authError: %d"), v107);
                                      }
                                      else
                                      {
                                        if (v104)
                                        {
                                          v36 = theDict;
                                          if (v103)
                                          {
                                            v67 = CFGetAllocator((CFTypeRef)v8);
                                            if ((_AMFDRSupportBase64Encode((uint64_t)v67, (uint64_t)v104, (uint64_t)&v102) & 1) != 0)
                                            {
                                              if (!v102)
                                              {
                                                v83 = CFSTR("base64EncodedComponentSignature is NULL");
LABEL_164:
                                                AMFDRErrorPushInternal(v91, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", v83, v84);
                                                goto LABEL_151;
                                              }
                                              v68 = CFGetAllocator((CFTypeRef)v8);
                                              if ((_AMFDRSupportBase64Encode((uint64_t)v68, (uint64_t)v103, (uint64_t)&v101) & 1) != 0)
                                              {
                                                if (v101)
                                                {
                                                  v69 = CFGetAllocator((CFTypeRef)v8);
                                                  v70 = CFStringCreateWithFormat(v69, 0, CFSTR("Digest realm=\"%@\", nonce=\"%@\", salt=\"%@\", uri=\"%@\", response=\"%@\", qop=auth, cert=%@, componentSig=%@, componentNonce=%@"), v87, v37, v99, v42, v105, v100, v102, v101);
                                                  if (v70)
                                                  {
                                                    Count = (uint64_t)v70;
                                                    v71 = theDict;
                                                    v72 = v42;
LABEL_58:
                                                    CFHTTPMessageSetHeaderFieldValue(request, CFSTR("Authorization"), (CFStringRef)Count);
                                                    if (*v90)
                                                    {
                                                      CFRelease(*v90);
                                                      *v90 = 0;
                                                    }
                                                    v74 = _AMFDRGetHttpTimeout(v8);
                                                    v75 = _AMFDRHttpMessageSendSync((CFDictionaryRef *)v8, request, v89, v90, &v98, v74, 1u, 0, 0, 0, v91);
                                                    CFHTTPMessageSetHeaderFieldValue(request, CFSTR("Authorization"), 0);
                                                    if ((v75 & 1) != 0)
                                                    {
                                                      if (*v90)
                                                      {
                                                        *v88 = v98;
                                                        v8 = 1;
                                                      }
                                                      else
                                                      {
                                                        AMFDRErrorPushInternal(v91, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("*inOutHttpResponseHeader is NULL"), v84);
                                                        v8 = 0;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      AMFDRErrorPushInternal(v91, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("_AMFDRHttpMessageSendSync failed"), v84);
                                                      v8 = 0;
                                                    }
                                                    v42 = v72;
                                                    v36 = v71;
                                                    goto LABEL_64;
                                                  }
                                                  AMFDRErrorPushInternal(v91, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("authorizationResponseStr is NULL"), v84);
                                                  goto LABEL_151;
                                                }
                                                v83 = CFSTR("base64EncodedComponentNonce is NULL");
                                                goto LABEL_164;
                                              }
                                            }
                                            AMFDRErrorPushInternal(v91, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("_AMFDRSupportBase64Encode failed"), v84);
                                          }
                                          else
                                          {
                                            AMFDRErrorPushInternal(v91, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("ChallengeClaim callback return NULL componentNonce"), v84);
                                          }
LABEL_151:
                                          Count = 0;
LABEL_152:
                                          v8 = 0;
                                          goto LABEL_64;
                                        }
                                        AMFDRErrorPushInternal(v91, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("ChallengeClaim callback return NULL componentSignature"), v84);
                                      }
LABEL_160:
                                      v36 = theDict;
                                      goto LABEL_151;
                                    }
                                    AMFDRErrorPushInternal(v91, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("Unable to create challengeDigest"), v84);
                                  }
                                  else
                                  {
                                    AMFDRErrorPushInternal(v91, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("dataToBeSigned is NULL"), v84);
                                  }
                                  v92 = 0;
                                  goto LABEL_160;
                                }
                                v73 = CFGetAllocator((CFTypeRef)v8);
                                Count = (uint64_t)CFStringCreateWithFormat(v73, 0, CFSTR("Digest realm=\"%@\", nonce=\"%@\", salt=\"%@\", uri=\"%@\", response=\"%@\", qop=auth, cert=%@"), v87, v37, v99, v42, v105, v100);
                                if (Count)
                                {
                                  v71 = theDict;
                                  v72 = v42;
                                  v92 = 0;
                                  RandomNumber = 0;
                                  goto LABEL_58;
                                }
                                AMFDRErrorPushInternal(v91, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("authorizationResponseStr is NULL"), v84);
                                v92 = 0;
LABEL_167:
                                RandomNumber = 0;
                                goto LABEL_152;
                              }
                              v82 = CFSTR("base64EncodedCert is NULL");
                              goto LABEL_148;
                            }
                          }
                          AMFDRErrorPushInternal(v91, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("_AMFDRSupportBase64Encode failed"), v84);
LABEL_149:
                          v92 = 0;
                          goto LABEL_150;
                        }
                        v81 = CFSTR("*outNonceSignature is NULL");
                      }
                      else
                      {
                        v81 = CFSTR("nonceSignatureBufferLength is 0");
                      }
                    }
                    else
                    {
                      v81 = CFSTR("nonceSignatureBuffer is NULL");
                    }
                    AMFDRErrorPushInternal(v91, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpNonceSign", v81, v84);
                    AMSupportSafeFree();
                    AMFDRErrorPushInternal(v91, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("nonceSignature is NULL"), v86);
LABEL_145:
                    v95 = 0;
                    goto LABEL_149;
                  }
                  v80 = v91;
                  AMFDRErrorPushInternal(v91, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpNonceSign", CFSTR("AMFDRCryptoCreateDataSignature failed"), v84);
                }
                AMSupportSafeFree();
                AMFDRErrorPushInternal(v80, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("_AMFDRHttpAuthenticateSign failed"), v85);
                goto LABEL_145;
              }
              AMFDRErrorPushInternal(v91, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("saltedNonce is NULL"), v84);
              goto LABEL_145;
            }
            AMFDRErrorPushInternal(v91, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("nonce is NULL"), v84);
LABEL_133:
            v95 = 0;
            MutableCopy = 0;
            cf = 0;
            goto LABEL_149;
          }
          v79 = CFSTR("_AMFDRSupportBase64Decode failed");
        }
        else
        {
          v79 = CFSTR("uri is NULL");
        }
        AMFDRErrorPushInternal(v91, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", v79, v84);
        goto LABEL_133;
      }
      AMFDRErrorPushInternal(v91, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("requestURL is NULL"), v84);
      v95 = 0;
      MutableCopy = 0;
      v92 = 0;
      cf = 0;
LABEL_128:
      v42 = 0;
LABEL_150:
      RandomNumber = 0;
      goto LABEL_151;
    }
    AMFDRErrorPushInternal(v91, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("unexpected qop: %@"), (char)v38);
    v95 = 0;
LABEL_126:
    MutableCopy = 0;
    v92 = 0;
    cf = 0;
    v41 = 0;
    goto LABEL_128;
  }
  v20 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v16, v20);
    location = CFStringFind(ValueAtIndex, CFSTR("="), 0).location;
    if (location != -1)
      break;
LABEL_24:
    if (Count == ++v20)
      goto LABEL_25;
  }
  v23 = location;
  v24 = v16;
  v25 = CFStringGetLength(ValueAtIndex);
  v26 = CFGetAllocator((CFTypeRef)v8);
  v113.location = 0;
  v113.length = v23;
  v27 = CFStringCreateWithSubstring(v26, ValueAtIndex, v113);
  if (!v27)
  {
    AMFDRErrorPushInternal(v91, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", CFSTR("key is NULL"), v84);
    v95 = 0;
    MutableCopy = 0;
    v92 = 0;
    cf = 0;
    v41 = 0;
    v42 = 0;
    RandomNumber = 0;
    Count = 0;
    v8 = 0;
    v36 = theDict;
    goto LABEL_64;
  }
  v28 = v27;
  v29 = CFGetAllocator((CFTypeRef)v8);
  v114.location = v23 + 1;
  v114.length = v25 + ~v23;
  v30 = CFStringCreateWithSubstring(v29, ValueAtIndex, v114);
  if (!v30)
  {
    v32 = 0;
    format = CFSTR("value is NULL");
    goto LABEL_105;
  }
  v31 = CFGetAllocator((CFTypeRef)v8);
  v32 = CFStringCreateMutableCopy(v31, 0, v28);
  if (!v32)
  {
    format = CFSTR("mutableKey is NULL");
    goto LABEL_105;
  }
  v33 = CFGetAllocator((CFTypeRef)v8);
  v34 = CFStringCreateMutableCopy(v33, 0, v30);
  if (v34)
  {
    v35 = v34;
    CFStringTrimWhitespace(v32);
    CFStringTrimWhitespace(v35);
    v115.length = CFStringGetLength(v32);
    v115.location = 0;
    CFStringFindAndReplace(v32, CFSTR("Digest "), &stru_24C6A3418, v115, 0);
    v116.length = CFStringGetLength(v32);
    v116.location = 0;
    CFStringFindAndReplace(v32, CFSTR("\""), &stru_24C6A3418, v116, 0);
    v117.length = CFStringGetLength(v35);
    v117.location = 0;
    CFStringFindAndReplace(v35, CFSTR("\""), &stru_24C6A3418, v117, 0);
    CFDictionarySetValue(theDict, v32, v35);
    CFRelease(v28);
    CFRelease(v30);
    CFRelease(v32);
    CFRelease(v35);
    v16 = v24;
    goto LABEL_24;
  }
  format = CFSTR("mutableValue is NULL");
LABEL_105:
  AMFDRErrorPushInternal(v91, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpAuthenticateSendSync", format, v84);
  CFRelease(v24);
  CFRelease(v28);
  if (v30)
    CFRelease(v30);
  v95 = 0;
  MutableCopy = 0;
  v92 = 0;
  cf = 0;
  v41 = 0;
  v42 = 0;
  RandomNumber = 0;
  Count = 0;
  v8 = 0;
  v16 = (const __CFArray *)v32;
  v36 = theDict;
  if (v32)
LABEL_64:
    CFRelease(v16);
  if (v36)
    CFRelease(v36);
  Value = v92;
LABEL_68:
  if (v106)
  {
    CFRelease(v106);
    v106 = 0;
  }
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (cf)
    CFRelease(cf);
  if (v95)
    CFRelease(v95);
  if (v105)
  {
    CFRelease(v105);
    v105 = 0;
  }
  if (v100)
  {
    CFRelease(v100);
    v100 = 0;
  }
  if (v99)
  {
    CFRelease(v99);
    v99 = 0;
  }
  if (v41)
    CFRelease(v41);
  if (v42)
    CFRelease(v42);
  if (Count)
    CFRelease((CFTypeRef)Count);
  if (RandomNumber)
    CFRelease(RandomNumber);
  if (Value)
    CFRelease(Value);
  if (v104)
  {
    CFRelease(v104);
    v104 = 0;
  }
  if (v103)
  {
    CFRelease(v103);
    v103 = 0;
  }
  if (v102)
  {
    CFRelease(v102);
    v102 = 0;
  }
  if (v101)
    CFRelease(v101);
  return v8;
}

void _AMFDRHttpHandleHeaderMessage(CFMutableDictionaryRef *a1, CFDictionaryRef theDict, CFIndex a3, const __CFData *a4, uint64_t a5)
{
  const __CFString *Value;
  const __CFString *v10;
  CFIndex Length;
  CFIndex v12;
  const __CFAllocator *v13;
  const UInt8 *BytePtr;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *format;
  char v18;

  if (!a1)
  {
    format = CFSTR("amfdr is NULL");
LABEL_15:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpHandleHeaderMessage", format, v18);
    return;
  }
  if (!theDict)
  {
    format = CFSTR("httpResponseHeader is NULL");
    goto LABEL_15;
  }
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("x-fdr-message"));
  if (Value)
  {
    v10 = Value;
    AMFDRErrorPushInternal(a5, a3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpHandleHeaderMessage", CFSTR("%s returned status %d. x-fdr-message: '%@'"), (char)"_AMFDRHttpHandleHeaderMessage");
    AMFDRCopyStatString(a1, CFSTR("FDRXFDRMessage"), v10);
  }
  else if (a4)
  {
    Length = CFDataGetLength(a4);
    if (Length >= 80)
      v12 = 80;
    else
      v12 = Length;
    v13 = CFGetAllocator(a1);
    BytePtr = CFDataGetBytePtr(a4);
    v15 = CFStringCreateWithBytes(v13, BytePtr, v12, 0x8000100u, 0);
    if (v15)
    {
      v16 = v15;
      AMFDRCopyStatString(a1, CFSTR("FDRXFDRMessage"), v15);
      AMFDRErrorPushInternal(a5, a3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpHandleHeaderMessage", CFSTR("%s returned status %d. ResponseBody: '%@'"), (char)"_AMFDRHttpHandleHeaderMessage");
      CFRelease(v16);
    }
  }
  else
  {
    AMFDRErrorPushInternal(a5, a3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpHandleHeaderMessage", CFSTR("%s returned status %d. ResponseBody: '%@'"), (char)"_AMFDRHttpHandleHeaderMessage");
  }
}

void ___thr_AMFDRHttpRequestStatisticsRecord(uint64_t a1)
{
  const __CFAllocator *v1;
  const __CFURL *v2;
  CFIndex *v3;
  void *v4;
  CFStringRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  const __CFUUID *v8;
  const __CFUUID *v9;
  CFStringRef v10;
  CFNumberRef v11;
  CFStringRef v12;
  const char **v13;
  CFStringRef v14;
  CFDictionaryRef v15;
  __CFArray *Mutable;
  pid_t v17;
  double valuePtr;
  void *values[6];
  void *keys[2];
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v1 = *(const __CFAllocator **)a1;
  v2 = *(const __CFURL **)(a1 + 8);
  v4 = *(void **)(a1 + 16);
  v3 = *(CFIndex **)(a1 + 24);
  valuePtr = CFAbsoluteTimeGetCurrent() + *MEMORY[0x24BDBD238];
  v17 = 0;
  if (!v2 || !v4 || (v5 = CFURLGetString(v2), (v6 = CFNumberCreate(v1, kCFNumberDoubleType, &valuePtr)) == 0))
  {
    AMSupportLogInternal();
LABEL_23:
    AMSupportLogInternal();
    return;
  }
  v7 = v6;
  v8 = CFUUIDCreate(v1);
  if (!v8)
  {
    AMSupportLogInternal();
    CFRelease(v7);
    goto LABEL_23;
  }
  v9 = v8;
  v10 = CFUUIDCreateString(v1, v8);
  if (v10)
  {
    v11 = (CFNumberRef)_HttpRequestStatisticCreate_pidNumber;
    if (_HttpRequestStatisticCreate_pidNumber
      || (v17 = getpid(),
          v11 = CFNumberCreate(v1, kCFNumberIntType, &v17),
          (_HttpRequestStatisticCreate_pidNumber = (uint64_t)v11) != 0))
    {
      v12 = (CFStringRef)_HttpRequestStatisticCreate_procNameStr;
      if (_HttpRequestStatisticCreate_procNameStr)
      {
LABEL_13:
        *(_OWORD *)keys = xmmword_24C69F410;
        v21 = *(_OWORD *)&off_24C69F420;
        v22 = xmmword_24C69F430;
        values[0] = v7;
        values[1] = (void *)v10;
        values[2] = v11;
        values[3] = (void *)v12;
        values[4] = (void *)v5;
        values[5] = v4;
        v15 = CFDictionaryCreate(v1, (const void **)keys, (const void **)values, 6, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        goto LABEL_14;
      }
      v13 = (const char **)_CFGetProgname();
      if (v13)
      {
        if (*v13)
        {
          v14 = CFStringCreateWithCString(v1, *v13, 0x8000100u);
          _HttpRequestStatisticCreate_procNameStr = (uint64_t)v14;
          if (v14)
          {
            v12 = v14;
            v11 = (CFNumberRef)_HttpRequestStatisticCreate_pidNumber;
            goto LABEL_13;
          }
        }
      }
    }
  }
  AMSupportLogInternal();
  v15 = 0;
LABEL_14:
  CFRelease(v7);
  CFRelease(v9);
  if (v10)
    CFRelease(v10);
  if (!v15)
    goto LABEL_23;
  Mutable = (__CFArray *)gHttpRequestStatisticsArray;
  if (gHttpRequestStatisticsArray
    || (Mutable = CFArrayCreateMutable(v1, 0, MEMORY[0x24BDBD690]),
        (gHttpRequestStatisticsArray = (uint64_t)Mutable) != 0))
  {
    CFArrayAppendValue(Mutable, v15);
    *v3 = CFArrayGetCount((CFArrayRef)gHttpRequestStatisticsArray);
  }
  else
  {
    AMSupportLogInternal();
  }
  CFRelease(v15);
}

uint64_t _AMFDRHttpProxyIsEnabled(uint64_t a1)
{
  const __CFDictionary *v2;
  const __CFBoolean *Value;
  const __CFBoolean *v4;
  CFTypeID v5;
  const void *v6;
  CFTypeID v7;

  if (a1 && (v2 = *(const __CFDictionary **)(a1 + 16)) != 0)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v2, CFSTR("EnableProxy"));
    if (Value)
    {
      v4 = Value;
      v5 = CFGetTypeID(Value);
      if (v5 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue(v4))
          return 1;
      }
    }
    v6 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("UseSOCKSHost"));
    if (v6)
    {
      v7 = CFGetTypeID(v6);
      if (v7 == CFStringGetTypeID())
        return 1;
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  return 0;
}

void _AMFDRHttpLogRequest(__CFHTTPMessage *a1, const void *a2, int a3)
{
  int v3;
  CFURLRef v6;
  const __CFDictionary *v7;
  CFIndex Count;
  const void **v9;
  const void **v10;
  const __CFDictionary *v11;
  const void **v12;
  const void **v13;
  const void **v14;
  const void **v15;
  const void **v16;
  const __CFDictionary *v17;
  const __CFData *v18;
  const __CFAllocator *v19;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFStringRef v22;
  CFDataRef v23;
  __int128 v24;
  const __CFDictionary *v26;
  const __CFString *cf;
  UInt8 bytes[16];
  __int128 v29;
  uint64_t v30;

  v3 = a3;
  v30 = *MEMORY[0x24BDAC8D0];
  cf = 0;
  if (a1)
  {
    v6 = CFHTTPMessageCopyRequestURL(a1);
    v7 = CFHTTPMessageCopyAllHeaderFields(a1);
    Count = CFDictionaryGetCount(v7);
    v9 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    v10 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    v26 = v7;
    v11 = v7;
    v12 = v9;
    v13 = v10;
    CFDictionaryGetKeysAndValues(v11, v9, v10);
    if (v6)
      AMSupportLogInternal();
    if (Count >= 1)
    {
      v14 = v13;
      do
      {
        ++v9;
        ++v14;
        AMSupportLogInternal();
        --Count;
      }
      while (Count);
    }
    if (!a2)
    {
      v18 = CFHTTPMessageCopyBody(a1);
      v15 = v13;
      v16 = v12;
      v17 = v26;
      v3 = a3;
      if (v18)
        goto LABEL_11;
      goto LABEL_32;
    }
    v15 = v13;
    v16 = v12;
    v17 = v26;
    v3 = a3;
  }
  else
  {
    v6 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    if (!a2)
      goto LABEL_22;
  }
  v18 = (const __CFData *)CFRetain(a2);
  if (v18)
  {
LABEL_11:
    v19 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    BytePtr = CFDataGetBytePtr(v18);
    Length = CFDataGetLength(v18);
    v22 = CFStringCreateWithBytes(v19, BytePtr, Length, 0x8000100u, 0);
    cf = v22;
    if (v3 >= 1 && !v22)
    {
      if (CFDataGetLength(v18) >= v3)
        goto LABEL_18;
      AMSupportLogInternal();
      AMSupportBase64Encode();
      v22 = cf;
    }
    if (v22)
    {
      AMSupportLogInternal();
      v23 = 0;
      if (!v6)
      {
LABEL_20:
        CFRelease(v18);
        if (!v23)
          goto LABEL_22;
        goto LABEL_21;
      }
LABEL_19:
      CFRelease(v6);
      goto LABEL_20;
    }
LABEL_18:
    *(_QWORD *)&v24 = -1;
    *((_QWORD *)&v24 + 1) = -1;
    *(_OWORD *)bytes = v24;
    v29 = v24;
    CFDataGetBytePtr(v18);
    CFDataGetLength(v18);
    AMSupportDigestSha256();
    v23 = CFDataCreate(v19, bytes, 32);
    cf = (const __CFString *)AMSupportCopyHexStringFromData();
    CFDataGetLength(v18);
    AMSupportLogInternal();
    if (!v6)
      goto LABEL_20;
    goto LABEL_19;
  }
LABEL_32:
  v23 = v6;
  if (v6)
LABEL_21:
    CFRelease(v23);
LABEL_22:
  if (cf)
    CFRelease(cf);
  if (v17)
    CFRelease(v17);
  if (v16)
    free(v16);
  if (v15)
    free(v15);
}

uint64_t _AMFDRDataPermAllowed(CFDictionaryRef *a1, const __CFString *a2)
{
  const __CFString *Value;
  const __CFString *v5;
  const __CFAllocator *v6;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v8;
  const __CFString *ValueAtIndex;
  const __CFString *v10;
  const __CFAllocator *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  const __CFString *v14;
  const __CFString *v15;
  const __CFAllocator *v16;
  CFIndex Count;
  CFIndex v18;
  CFIndex v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  uint64_t v23;
  const __CFArray *cf;
  CFArrayRef v26;
  CFArrayRef v27;
  CFArrayRef theArray;

  v27 = 0;
  theArray = 0;
  v26 = 0;
  Value = (const __CFString *)CFDictionaryGetValue(a1[2], CFSTR("Permissions"));
  if (!Value)
  {
    AMSupportLogInternal();
    v8 = 0;
LABEL_20:
    v13 = 0;
    goto LABEL_22;
  }
  v5 = Value;
  v6 = CFGetAllocator(a1);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v6, a2, CFSTR("/"));
  v8 = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings || CFArrayGetCount(ArrayBySeparatingStrings) != 2)
  {
    AMSupportLogInternal();
    goto LABEL_20;
  }
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, 0);
  v10 = (const __CFString *)CFArrayGetValueAtIndex(v8, 1);
  v11 = CFGetAllocator(a1);
  v12 = CFStringCreateArrayBySeparatingStrings(v11, v10, CFSTR(":"));
  v13 = v12;
  if (!v12
    || CFArrayGetCount(v12) != 2
    || (v14 = (const __CFString *)CFArrayGetValueAtIndex(v13, 0),
        v15 = (const __CFString *)CFArrayGetValueAtIndex(v13, 1),
        v16 = CFGetAllocator(a1),
        !AMFDRDecomposePermissionString(v16, v5, (CFTypeRef *)&theArray, (CFTypeRef *)&v27, (CFTypeRef *)&v26)))
  {
    AMSupportLogInternal();
    goto LABEL_22;
  }
  Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
LABEL_22:
    v23 = 0;
    goto LABEL_23;
  }
  v18 = Count;
  cf = v8;
  v19 = 0;
  while (1)
  {
    v20 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v19);
    v21 = (const __CFString *)CFArrayGetValueAtIndex(v27, v19);
    v22 = (const __CFString *)CFArrayGetValueAtIndex(v26, v19);
    if (CFStringCompare(v20, ValueAtIndex, 0) == kCFCompareEqualTo
      && (CFStringCompare(v21, CFSTR("*"), 0) == kCFCompareEqualTo
       || CFStringCompare(v21, v14, 0) == kCFCompareEqualTo)
      && (CFStringCompare(v22, v15, 0) == kCFCompareEqualTo || CFStringFind(v22, CFSTR("*"), 0).location != -1))
    {
      break;
    }
    if (v18 == ++v19)
    {
      v23 = 0;
      goto LABEL_17;
    }
  }
  v23 = 1;
LABEL_17:
  v8 = cf;
LABEL_23:
  if (theArray)
  {
    CFRelease(theArray);
    theArray = 0;
  }
  if (v27)
  {
    CFRelease(v27);
    v27 = 0;
  }
  if (v26)
  {
    CFRelease(v26);
    v26 = 0;
  }
  if (v8)
    CFRelease(v8);
  if (v13)
    CFRelease(v13);
  return v23;
}

CFTypeRef _AMFDRDataHTTPCopyForPut(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AMFDRDataCopyForPut(a1, *(const __CFString **)a2, *(const void **)(a2 + 8), *(const __CFData **)(a2 + 16), *(__CFString **)(a2 + 24), a3);
}

__CFString *_AMFDRDataHTTPMultiCopyInternal(__CFString *a1, CFArrayRef theArray, const __CFArray *a3, unsigned int a4, uint64_t a5)
{
  CFTypeRef *v5;
  __CFString *v6;
  __int128 v7;
  CFIndex Count;
  CFIndex v11;
  const __CFAllocator *v12;
  const __CFAllocator *v13;
  __CFString *v14;
  const void *v15;
  const __CFString *v16;
  const __CFData *v17;
  const __CFArray *v18;
  CFMutableArrayRef Mutable;
  __CFArray *v20;
  const void *v21;
  __CFDictionary *v22;
  int v24;
  char v25;
  const CFArrayCallBacks *v26;
  const __CFAllocator *v27;
  const __CFAllocator *v28;
  CFMutableArrayRef v29;
  __CFArray *v30;
  __CFArray *v31;
  int v32;
  unsigned int v33;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const __CFString *v36;
  const void *v37;
  const void *v38;
  const __CFAllocator *v39;
  CFStringRef FullKey;
  const __CFArray *v41;
  const __CFAllocator *v42;
  CFMutableArrayRef v43;
  const UInt8 *BytePtr;
  unsigned int Length;
  char MultiActionDescription;
  CFMutableDictionaryRef v47;
  const __CFString *v48;
  const __CFString *v49;
  const __CFString *v50;
  uint64_t v51;
  const __CFString *v52;
  CFIndex v53;
  const __CFString *v54;
  void *value[2];
  void *v56[2];
  void *v57[2];
  const __CFString *format;
  char v59;
  CFTypeRef *v60;
  const __CFURL *v61;
  unint64_t v62;
  CFMutableDictionaryRef cf;
  int v64;
  __CFDictionary *theDict;
  unsigned __int8 v67;
  CFTypeRef v68;
  unsigned int v69;
  __int128 v70;
  __int128 v71;
  unsigned int *v72;
  uint64_t v73;
  CFRange v74;

  v5 = (CFTypeRef *)a5;
  v6 = a1;
  v73 = *MEMORY[0x24BDAC8D0];
  v69 = a4;
  v68 = 0;
  v67 = 0;
  v72 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v70 = v7;
  v71 = v7;
  if (!a1)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", CFSTR("amfdr is NULL"), v59);
LABEL_100:
    v20 = 0;
    Mutable = 0;
    v18 = 0;
    goto LABEL_22;
  }
  if (!theArray)
  {
    v50 = CFSTR("dataClassArray is NULL");
LABEL_98:
    AMFDRErrorPushInternal((uint64_t)v5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", v50, v59);
LABEL_99:
    v6 = 0;
    goto LABEL_100;
  }
  if (!a3)
  {
    v50 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_98;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v50 = CFSTR("Invalid dataClassArray count");
    goto LABEL_98;
  }
  v11 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v50 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_98;
  }
  v12 = CFGetAllocator(v6);
  cf = CFDictionaryCreateMutable(v12, v11, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!cf)
  {
    AMFDRErrorPushInternal((uint64_t)v5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", CFSTR("valueDataDict is NULL"), v59);
    goto LABEL_99;
  }
  v13 = CFGetAllocator(v6);
  theDict = CFDictionaryCreateMutable(v13, v11, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal((uint64_t)v5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", CFSTR("multiRequestErrors is NULL"), v59);
LABEL_104:
    v15 = 0;
    goto LABEL_14;
  }
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)v6, v5) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)v5, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v59);
    goto LABEL_104;
  }
  v14 = _AMFDRCreateUrlWithKey((uint64_t)v6, CFSTR("DSURL"), (uint64_t)CFSTR("dm/bulk/data"), 0, 0);
  v15 = v14;
  if (!v14)
  {
    v16 = CFSTR("serverURL is NULL");
    goto LABEL_13;
  }
  if (a4 >= 5 || ((0x1Du >> a4) & 1) == 0)
  {
    v59 = a4;
    v16 = CFSTR("unsupported multi action: %d");
LABEL_13:
    AMFDRErrorPushInternal((uint64_t)v5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", v16, v59);
LABEL_14:
    v17 = 0;
    v18 = 0;
    Mutable = 0;
    v20 = 0;
    v6 = 0;
    v21 = cf;
    v22 = theDict;
LABEL_15:
    CFRelease(v21);
    goto LABEL_16;
  }
  v61 = (const __CFURL *)v14;
  if (!_AMFDRGetMultiRequestMaxAttempts((uint64_t)v6))
  {
    v21 = 0;
    v17 = 0;
    v18 = 0;
    Mutable = 0;
    v20 = 0;
    goto LABEL_77;
  }
  v24 = 0;
  v20 = 0;
  Mutable = 0;
  v18 = 0;
  v21 = 0;
  v25 = 8 * a4;
  v17 = 0;
  v62 = 0xD0E0D0101uLL >> v25;
  v60 = v5;
  do
  {
    if (Mutable)
      CFRelease(Mutable);
    if (v20)
      CFRelease(v20);
    if (v17)
      CFRelease(v17);
    v26 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
    if (v68)
    {
      CFRelease(v68);
      v68 = 0;
    }
    v27 = CFGetAllocator(v6);
    Mutable = CFArrayCreateMutable(v27, 0, v26);
    if (!Mutable)
    {
      v49 = CFSTR("dataClassToRequest is NULL");
LABEL_92:
      AMFDRErrorPushInternal((uint64_t)v5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", v49, v59);
      v6 = 0;
      v20 = 0;
      v17 = 0;
      v22 = theDict;
      v15 = v61;
      v47 = cf;
      goto LABEL_80;
    }
    v28 = CFGetAllocator(v6);
    v29 = CFArrayCreateMutable(v28, 0, v26);
    if (!v29)
    {
      v49 = CFSTR("dataInstanceToRequest is NULL");
      goto LABEL_92;
    }
    v30 = v29;
    v31 = Mutable;
    v32 = v24;
    if (v24)
    {
      v33 = _AMFDRGetMultiRequestBackoff((uint64_t)v6) * v24;
      AMSupportLogInternal();
      sleep(v33);
    }
    v64 = v32;
    for (i = 0; i != v11; ++i)
    {
      if (v21)
        CFRelease(v21);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, i);
      if (!ValueAtIndex)
      {
        v48 = CFSTR("dataClassStr is NULL");
LABEL_87:
        AMFDRErrorPushInternal((uint64_t)v60, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", v48, v59);
LABEL_89:
        v17 = 0;
        v6 = 0;
        v21 = cf;
        v22 = theDict;
        v15 = v61;
        Mutable = v31;
        v20 = v30;
        goto LABEL_15;
      }
      v36 = ValueAtIndex;
      if (!CFStringGetLength(ValueAtIndex))
      {
        v48 = CFSTR("dataClassStr length is 0");
        goto LABEL_87;
      }
      v37 = CFArrayGetValueAtIndex(a3, i);
      if (!v37)
      {
        v48 = CFSTR("dataInstanceStr is NULL");
        goto LABEL_87;
      }
      v38 = v37;
      v39 = CFGetAllocator(v6);
      FullKey = AMFDRDataLocalCreateFullKey(v39, (uint64_t)v36, (uint64_t)v38);
      if (!FullKey)
      {
        AMFDRErrorPushInternal((uint64_t)v60, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", CFSTR("currDataInstance is NULL"), v59);
        goto LABEL_89;
      }
      v21 = FullKey;
      if (v18)
      {
        v74.length = CFArrayGetCount(v18);
        v74.location = 0;
        if (!CFArrayContainsValue(v18, v74, v21))
          continue;
        CFDictionaryRemoveValue(theDict, v21);
        AMSupportLogInternal();
      }
      CFArrayAppendValue(v31, v36);
      CFArrayAppendValue(v30, v38);
    }
    Mutable = v31;
    if (!CFArrayGetCount(v31))
    {
      v22 = theDict;
      AMFDRErrorPushInternal((uint64_t)v60, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", CFSTR("got multiRequestErrors"), v59);
      v17 = 0;
      v20 = v30;
      goto LABEL_83;
    }
    v41 = v31;
    v20 = v30;
    v17 = AMFDRDataHTTPCreateMultiRequest(v6, v62, v41, v30, 0, 0, 0, 0, (uint64_t)v60);
    if (!v17)
    {
      format = CFSTR("httpRequestData is NULL");
      *(_OWORD *)v56 = 0u;
      *(_OWORD *)v57 = 0u;
      *(_OWORD *)value = 0u;
      v51 = (uint64_t)v60;
      goto LABEL_110;
    }
    v5 = v60;
    if (v60)
    {
      if (*v60)
      {
        CFRelease(*v60);
        *v60 = 0;
      }
      if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)v6, v61, (uint64_t)CFSTR("MultiCopy"), CFSTR("POST"), 0, v17, &v68, 0, 0, 0, 0, 0, v60) & 1) == 0|| *v60)
      {
LABEL_117:
        AMSupportLogInternal();
LABEL_118:
        v22 = theDict;
LABEL_83:
        CFRelease(cf);
        v6 = 0;
        v15 = v61;
        goto LABEL_15;
      }
    }
    else if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)v6, v61, (uint64_t)CFSTR("MultiCopy"), CFSTR("POST"), 0, v17, &v68, 0, 0, 0, 0, 0, 0) & 1) == 0)
    {
      goto LABEL_117;
    }
    if (!v68)
    {
      v52 = CFSTR("_AMFDRHttpRequestSendSync failed: httpReturnData is NULL");
      goto LABEL_115;
    }
    if (v18)
      CFRelease(v18);
    v42 = CFGetAllocator(v6);
    v43 = CFArrayCreateMutable(v42, 0, MEMORY[0x24BDBD690]);
    v18 = v43;
    if (!v43)
    {
      format = CFSTR("dataClassInstanceToRetry is NULL");
      *(_OWORD *)v56 = 0u;
      *(_OWORD *)v57 = 0u;
      *(_OWORD *)value = 0u;
      v51 = (uint64_t)v60;
LABEL_110:
      v53 = 2;
      goto LABEL_116;
    }
    *(_QWORD *)&v70 = v6;
    *((_QWORD *)&v70 + 1) = cf;
    *(_QWORD *)&v71 = theDict;
    *((_QWORD *)&v71 + 1) = v43;
    v72 = &v69;
    BytePtr = CFDataGetBytePtr((CFDataRef)v68);
    Length = CFDataGetLength((CFDataRef)v68);
    if (AMFDRDecodeMultiResponse((uint64_t)BytePtr, Length, &v67, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t))_AMFDRHttpMultiResponseCallback, (uint64_t)&v70))
    {
      v54 = CFSTR("AMFDRDecodeMultiResponse failed");
LABEL_113:
      AMFDRErrorPushInternal((uint64_t)v60, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", v54, v59);
      goto LABEL_118;
    }
    if (v67 != v62)
    {
      v59 = v67;
      v54 = CFSTR("actionCode returned is %d");
      goto LABEL_113;
    }
    if ((_AMFDRSavePersistentCookie((uint64_t)v6, (uint64_t)v60) & 1) == 0)
    {
      v52 = CFSTR("_AMFDRSavePersistentCookie failed");
LABEL_115:
      format = v52;
      *(_OWORD *)v56 = 0u;
      *(_OWORD *)v57 = 0u;
      *(_OWORD *)value = 0u;
      v51 = (uint64_t)v60;
      v53 = 8;
LABEL_116:
      AMFDRErrorPushInternal(v51, v53, 0, 0, 0, 0, 0, 0, value[0], value[1], v56[0], v56[1], v57[0], v57[1], (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", format, v59);
      goto LABEL_118;
    }
    if (!CFArrayGetCount(v18))
      break;
    v24 = v64 + 1;
  }
  while (v64 + 1 < _AMFDRGetMultiRequestMaxAttempts((uint64_t)v6));
LABEL_77:
  v22 = theDict;
  v15 = v61;
  if (CFDictionaryGetCount(theDict) >= 1)
  {
    MultiActionDescription = AMFDRDataGetMultiActionDescription(v69);
    AMFDRErrorPushInternal((uint64_t)v5, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiCopyInternal", CFSTR("got multiRequestErrors for %@"), MultiActionDescription);
  }
  v47 = cf;
  v6 = (__CFString *)CFRetain(cf);
LABEL_80:
  CFRelease(v47);
  if (v21)
    goto LABEL_15;
LABEL_16:
  if (v22)
    CFRelease(v22);
  if (v15)
    CFRelease(v15);
  if (v17)
    CFRelease(v17);
LABEL_22:
  if (v68)
  {
    CFRelease(v68);
    v68 = 0;
  }
  if (v18)
    CFRelease(v18);
  if (Mutable)
    CFRelease(Mutable);
  if (v20)
    CFRelease(v20);
  return v6;
}

uint64_t _AMFDRHttpMultiResponseCallback(const UInt8 *a1, unsigned int a2, const UInt8 *a3, unsigned int a4, unint64_t a5, unsigned int a6, int a7, __CFDictionary *Mutable, int a9, const char *a10, unsigned int a11, uint64_t a12)
{
  __int128 v12;
  unsigned int v14;
  uint64_t v20;
  const void *v21;
  unsigned int v22;
  const __CFAllocator *v24;
  const __CFString *v25;
  const __CFString *v26;
  CFTypeRef v27;
  const void *v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int v31;
  CFTypeRef **v32;
  unsigned int v33;
  const char *v34;
  const __CFAllocator *v35;
  CFStringRef v36;
  CFStringRef v37;
  CFIndex v38;
  CFIndex v39;
  const __CFData *v40;
  const __CFAllocator *v41;
  const __CFData *v42;
  const __CFAllocator *v43;
  __CFDictionary *v44;
  CFTypeRef v45;
  __CFArray *theArray;
  __CFDictionary *theDict;
  __CFDictionary *v50;
  const __CFString *cf;
  char v52;
  CFTypeRef *v53;
  void **p_value;
  CFTypeRef v55;
  CFTypeRef v56;
  void *value;
  CFTypeRef v58;
  CFTypeRef v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  unint64_t v88;
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  v58 = 0;
  v59 = 0;
  v56 = 0;
  value = 0;
  p_value = 0;
  v55 = 0;
  v53 = 0;
  v52 = 0;
  v88 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v86 = v12;
  v87 = v12;
  v84 = v12;
  v85 = v12;
  v82 = v12;
  v83 = v12;
  v80 = v12;
  v81 = v12;
  v78 = v12;
  v79 = v12;
  v76 = v12;
  v77 = v12;
  v74 = v12;
  v75 = v12;
  v72 = v12;
  v73 = v12;
  v70 = v12;
  v71 = v12;
  v68 = v12;
  v69 = v12;
  v66 = v12;
  v67 = v12;
  v65 = v12;
  v63 = v12;
  v64 = v12;
  v61 = v12;
  v62 = v12;
  v60 = v12;
  if (!a1)
    goto LABEL_118;
  if (!a2)
    goto LABEL_118;
  v14 = **(_DWORD **)(a12 + 32);
  if (v14 >= 9)
    goto LABEL_118;
  v21 = *(const void **)a12;
  v20 = *(_QWORD *)(a12 + 8);
  v22 = v14 - 5;
  if (v14 - 5 <= 3 && (a3 || a4))
    goto LABEL_118;
  if (!*(_QWORD *)(a12 + 16) || !v21)
    goto LABEL_118;
  if (v22 > 3)
  {
    if (v14 <= 4 && v14 != 1 && !v20)
      goto LABEL_118;
  }
  else if (v20)
  {
LABEL_118:
    AMSupportLogInternal();
    Mutable = 0;
    v29 = 1;
    goto LABEL_87;
  }
  if (!*(_QWORD *)(a12 + 24))
    goto LABEL_118;
  theDict = *(__CFDictionary **)(a12 + 8);
  v50 = *(__CFDictionary **)(a12 + 16);
  theArray = *(__CFArray **)(a12 + 24);
  v24 = CFGetAllocator(v21);
  v25 = CFStringCreateWithBytes(v24, a1, a2, 0x8000100u, 0);
  if (!v25)
  {
    AMSupportLogInternal();
LABEL_117:
    Mutable = 0;
    v29 = 2;
    goto LABEL_87;
  }
  v26 = v25;
  v27 = _AMFDRDataHTTPConvertMultiResponseKey(v21, v25);
  if (!v27)
  {
    AMSupportLogInternal();
    CFRelease(v26);
    goto LABEL_117;
  }
  v28 = v27;
  AMSupportLogInternal();
  cf = v26;
  if (!a5)
  {
    v29 = 2;
    goto LABEL_30;
  }
  if (v14 == 4)
  {
    p_value = &value;
  }
  else if (v14 == 2)
  {
    v53 = &v58;
  }
  else
  {
    if (v22 <= 3)
    {
      v30 = a5;
      v31 = a6;
      v32 = 0;
      goto LABEL_29;
    }
    v29 = 2;
    if (v14 > 4 || v14 == 1)
      goto LABEL_101;
  }
  v32 = &v53;
  v30 = a5;
  v31 = a6;
LABEL_29:
  v29 = AMFDRDecodeMetadata(v30, v31, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t))_AMFDRHttpMetadataLog, (uint64_t)v32);
  if (v29)
    goto LABEL_101;
LABEL_30:
  if (v14 == 4)
  {
    if (a7 && !value)
    {
      v52 = 1;
      v33 = 31;
      v34 = "missing data asid from metadata";
LABEL_38:
      Mutable = (__CFDictionary *)&v52;
      if (!v34)
        goto LABEL_54;
      goto LABEL_39;
    }
  }
  else if (v14 == 2)
  {
    if (a7 && !v58)
    {
      v52 = 1;
      v33 = 31;
      v34 = "missing data hash from metadata";
      goto LABEL_38;
    }
    if ((a7 & 1) != 0)
    {
      if (!Mutable)
      {
        CFDictionarySetValue(theDict, v28, v58);
        v29 = 0;
LABEL_66:
        v40 = 0;
LABEL_108:
        v37 = 0;
        goto LABEL_83;
      }
      goto LABEL_101;
    }
    goto LABEL_67;
  }
  if ((a7 & 1) != 0)
  {
    if (!Mutable)
    {
      if (v14 == 4)
      {
        CFDictionarySetValue(theDict, v28, value);
LABEL_79:
        v29 = 0;
LABEL_80:
        v40 = 0;
LABEL_81:
        v37 = 0;
LABEL_82:
        Mutable = 0;
        goto LABEL_83;
      }
      if (v14 != 3 && v14)
        goto LABEL_79;
      if (!a3 || !a4)
        goto LABEL_68;
      v41 = CFGetAllocator(v21);
      v42 = CFDataCreate(v41, a3, a4);
      v40 = v42;
      if (!v42)
      {
        AMSupportLogInternal();
        goto LABEL_81;
      }
      CFDataGetLength(v42);
      AMSupportLogInternal();
      if (v14 != 3)
      {
        CFDictionarySetValue(theDict, v28, v40);
        v29 = 0;
        goto LABEL_81;
      }
      v43 = CFGetAllocator(v21);
      Mutable = CFDictionaryCreateMutable(v43, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      if (Mutable)
      {
        if (!Img4DecodeInitManifest())
        {
          v45 = CFRetain(v40);
          v56 = v45;
          v44 = theDict;
          goto LABEL_103;
        }
        v44 = theDict;
        if ((AMFDRDataCopyExtraManifests(v21, v40, &v56, &v55, (uint64_t)&v59) & 1) != 0)
        {
          v45 = v56;
LABEL_103:
          if (v45)
            CFDictionarySetValue(Mutable, CFSTR("mandev"), v45);
          if (v55)
            CFDictionarySetValue(Mutable, CFSTR("mansta"), v55);
          CFDictionarySetValue(v44, v28, Mutable);
          v29 = 0;
          goto LABEL_108;
        }
      }
      AMSupportLogInternal();
      goto LABEL_108;
    }
LABEL_101:
    AMSupportLogInternal();
    goto LABEL_80;
  }
  if (v14 > 4 || v14 == 1)
    goto LABEL_51;
LABEL_67:
  if (!a3 && !a4)
  {
LABEL_51:
    if (!Mutable)
    {
      AMSupportLogInternal();
      goto LABEL_66;
    }
    if (a9 == 1)
    {
      v33 = a11;
      v34 = a10;
      if (!a10)
        goto LABEL_54;
LABEL_39:
      if (v33)
      {
        v35 = CFGetAllocator(v21);
        v36 = CFStringCreateWithBytes(v35, (const UInt8 *)v34, v33, 0x8000100u, 0);
        if (v36)
        {
          v37 = v36;
          AMSupportLogInternal();
          if ((*(_BYTE *)Mutable - 1) >= 5u)
            v38 = 799;
          else
            v38 = (*(_BYTE *)Mutable - 1) + 701;
          AMFDRErrorPushInternal((uint64_t)&v59, v38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMultiResponseCallback", CFSTR("multi-response error %d : %@"), *(_BYTE *)Mutable);
LABEL_58:
          if (v59)
          {
            CFDictionarySetValue(v50, v28, v59);
            if (*(_BYTE *)Mutable == 3)
              CFArrayAppendValue(theArray, v28);
            v29 = 0;
          }
          else
          {
            AMSupportLogInternal();
          }
          v40 = 0;
          goto LABEL_82;
        }
      }
LABEL_54:
      AMSupportLogInternal();
      if ((*(_BYTE *)Mutable - 1) >= 5u)
        v39 = 799;
      else
        v39 = (*(_BYTE *)Mutable - 1) + 701;
      AMFDRErrorPushInternal((uint64_t)&v59, v39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRHttpMultiResponseCallback", CFSTR("multi-response error %d without an error message"), *(_BYTE *)Mutable);
      v37 = 0;
      goto LABEL_58;
    }
    goto LABEL_101;
  }
LABEL_68:
  AMSupportLogInternal();
  v40 = 0;
  v37 = 0;
  Mutable = 0;
  v29 = 1;
LABEL_83:
  CFRelease(cf);
  CFRelease(v28);
  if (v40)
    CFRelease(v40);
  if (v37)
    CFRelease(v37);
LABEL_87:
  if (v59)
  {
    CFRelease(v59);
    v59 = 0;
  }
  if (v58)
  {
    CFRelease(v58);
    v58 = 0;
  }
  if (value)
  {
    CFRelease(value);
    value = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v56)
  {
    CFRelease(v56);
    v56 = 0;
  }
  if (v55)
    CFRelease(v55);
  return v29;
}

uint64_t _AMFDRGetMultiRequestMaxAttempts(uint64_t a1)
{
  uint64_t result;
  const __CFDictionary *v3;
  const __CFNumber *v4;
  const __CFNumber *v5;
  CFTypeID v6;
  int Value;
  unsigned int v8;
  unsigned int valuePtr;

  result = 3;
  valuePtr = 3;
  if (a1)
  {
    v3 = *(const __CFDictionary **)(a1 + 16);
    if (v3
      && (v4 = (const __CFNumber *)CFDictionaryGetValue(v3, CFSTR("MultiRequestMaxAttempts"))) != 0
      && (v5 = v4, v6 = CFGetTypeID(v4), v6 == CFNumberGetTypeID()))
    {
      Value = CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr)
        v8 = valuePtr;
      else
        v8 = 3;
      if (Value)
        return v8;
      else
        return valuePtr;
    }
    else
    {
      return 3;
    }
  }
  return result;
}

uint64_t _AMFDRGetMultiRequestBackoff(uint64_t a1)
{
  uint64_t result;
  const __CFDictionary *v3;
  const __CFNumber *Value;
  const __CFNumber *v5;
  CFTypeID v6;
  unsigned int valuePtr;

  result = 1;
  valuePtr = 1;
  if (a1)
  {
    v3 = *(const __CFDictionary **)(a1 + 16);
    if (v3
      && (Value = (const __CFNumber *)CFDictionaryGetValue(v3, CFSTR("MultiRequestBackoff"))) != 0
      && (v5 = Value, v6 = CFGetTypeID(Value), v6 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
      return valuePtr;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

const __CFData *AMFDRDataHTTPMultiCopyForPut(__CFString *a1, CFArrayRef *a2, uint64_t a3)
{
  return AMFDRDataHTTPCreateMultiRequest(a1, 2u, *a2, a2[1], a2[2], a2[3], 0, 1, a3);
}

const __CFArray *_AMFDRDataHTTPPatchInternal(__CFString *a1, void *a2, void *a3, const __CFArray *a4, const __CFArray *a5, void *a6, const __CFArray *a7, CFTypeRef *a8)
{
  CFArrayRef v11;
  CFArrayRef v12;
  CFArrayRef v13;
  const __CFAllocator *v15;
  const CFArrayCallBacks *v16;
  const __CFArray *v17;
  const __CFAllocator *v18;
  CFArrayRef v19;
  const __CFAllocator *v20;
  CFArrayRef v21;
  CFArrayRef v22;
  const __CFAllocator *v23;
  const __CFAllocator *v24;
  const __CFAllocator *v25;
  const __CFAllocator *v26;
  CFStringRef FullKey;
  __CFString *v28;
  __CFError *v29;
  CFTypeRef v30;
  CFTypeRef *v31;
  const __CFDictionary *v32;
  const void *v33;
  CFTypeRef *v34;
  const __CFDictionary *v35;
  const __CFDictionary *Value;
  const void *v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v42;
  char v43;
  const __CFArray *cf;
  CFErrorRef err;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *values[2];

  values[1] = *(void **)MEMORY[0x24BDAC8D0];
  err = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", CFSTR("amfdr is NULL"), v43);
    return 0;
  }
  if (!a2)
  {
    v38 = CFSTR("dataClassArray is NULL");
LABEL_35:
    AMFDRErrorPushInternal((uint64_t)a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", v38, v43);
    goto LABEL_37;
  }
  if (!a3)
  {
    v38 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_35;
  }
  v11 = a5;
  v12 = a4;
  if (!((unint64_t)a4 | (unint64_t)a5))
  {
    v38 = CFSTR("originalData and expectedData are NULL");
    goto LABEL_35;
  }
  if (a6)
  {
    v13 = a7;
    v50 = a3;
    values[0] = a2;
    v48 = a5;
    v49 = a4;
    v46 = a7;
    v47 = a6;
    v15 = CFGetAllocator(a1);
    v16 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
    v17 = CFArrayCreate(v15, (const void **)values, 1, MEMORY[0x24BDBD690]);
    v18 = CFGetAllocator(a1);
    v19 = CFArrayCreate(v18, (const void **)&v50, 1, v16);
    v20 = CFGetAllocator(a1);
    v21 = CFArrayCreate(v20, (const void **)&v47, 1, v16);
    v22 = v21;
    if (!v17)
    {
      AMFDRErrorPushInternal((uint64_t)a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", CFSTR("dataClassArray is NULL"), v43);
      v32 = 0;
      FullKey = 0;
      v28 = 0;
      v13 = 0;
      v11 = 0;
      v12 = 0;
LABEL_55:
      if (v19)
        CFRelease(v19);
      if (v12)
        CFRelease(v12);
      if (v11)
        CFRelease(v11);
      if (v22)
        CFRelease(v22);
      if (v13)
        CFRelease(v13);
      if (v28)
        CFRelease(v28);
      if (FullKey)
        CFRelease(FullKey);
      goto LABEL_69;
    }
    cf = v17;
    if (v19)
    {
      if (v21)
      {
        if (!v12
          || (v23 = CFGetAllocator(a1), (v12 = CFArrayCreate(v23, (const void **)&v49, 1, MEMORY[0x24BDBD690])) != 0))
        {
          if (!v11
            || (v24 = CFGetAllocator(a1),
                (v11 = CFArrayCreate(v24, (const void **)&v48, 1, MEMORY[0x24BDBD690])) != 0))
          {
            if (!v13
              || (v25 = CFGetAllocator(a1),
                  (v13 = CFArrayCreate(v25, (const void **)&v46, 1, MEMORY[0x24BDBD690])) != 0))
            {
              v26 = CFGetAllocator(a1);
              FullKey = AMFDRDataLocalCreateFullKey(v26, (uint64_t)a2, (uint64_t)a3);
              if (FullKey)
              {
                v28 = _AMFDRDataHTTPMultiPatchInternal(a1, v17, v19, v12, v11, v22, v13, (uint64_t)&err);
                v29 = err;
                if (err)
                {
                  if (a8)
                  {
                    if (*a8)
                    {
                      CFRelease(*a8);
                      *a8 = 0;
                      v29 = err;
                    }
                    if (CFErrorGetCode(v29) != 21)
                    {
                      v30 = CFRetain(err);
                      v17 = 0;
                      v31 = a8;
                      v32 = 0;
                      *v31 = v30;
LABEL_54:
                      CFRelease(cf);
                      goto LABEL_55;
                    }
LABEL_26:
                    v34 = a8;
                    v35 = CFErrorCopyUserInfo(err);
                    v32 = v35;
                    if (v35)
                    {
                      Value = (const __CFDictionary *)CFDictionaryGetValue(v35, CFSTR("MultiRequestErrors"));
                      if (Value)
                      {
                        v37 = CFDictionaryGetValue(Value, FullKey);
                        if (v37)
                        {
                          if (v34)
                          {
                            v17 = 0;
                            *v34 = CFRetain(v37);
                            goto LABEL_54;
                          }
LABEL_78:
                          v17 = 0;
                          goto LABEL_54;
                        }
                        v42 = CFSTR("missing multi request error");
                      }
                      else
                      {
                        v42 = CFSTR("MultiRequestErrors not in userInfo");
                      }
                    }
                    else
                    {
                      v42 = CFSTR("userInfo is NULL");
                    }
                    AMFDRErrorPushInternal((uint64_t)v34, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", v42, v43);
                    goto LABEL_78;
                  }
                  if (CFErrorGetCode(err) == 21)
                    goto LABEL_26;
                  goto LABEL_52;
                }
                if (v28)
                {
                  v33 = CFDictionaryGetValue((CFDictionaryRef)v28, FullKey);
                  if (v33)
                  {
                    v17 = (const __CFArray *)CFRetain(v33);
LABEL_53:
                    v32 = 0;
                    goto LABEL_54;
                  }
                  v40 = CFSTR("valueData is NULL");
                }
                else
                {
                  v40 = CFSTR("multiResponse is NULL");
                }
                AMFDRErrorPushInternal((uint64_t)a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", v40, v43);
LABEL_52:
                v17 = 0;
                goto LABEL_53;
              }
              AMFDRErrorPushInternal((uint64_t)a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", CFSTR("dataClassInstance is NULL"), v43);
              v17 = 0;
              v28 = 0;
              goto LABEL_53;
            }
            AMFDRErrorPushInternal((uint64_t)a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", CFSTR("metadataDictArray is NULL"), v43);
            v17 = 0;
LABEL_46:
            v28 = 0;
            FullKey = 0;
            goto LABEL_53;
          }
          AMFDRErrorPushInternal((uint64_t)a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", CFSTR("expectedDataArray is NULL"), v43);
          v17 = 0;
LABEL_45:
          v13 = 0;
          goto LABEL_46;
        }
        AMFDRErrorPushInternal((uint64_t)a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", CFSTR("originalDataArray is NULL"), v43);
        v17 = 0;
LABEL_44:
        v11 = 0;
        goto LABEL_45;
      }
      v39 = CFSTR("patchDictArray is NULL");
    }
    else
    {
      v39 = CFSTR("dataInstanceArray is NULL");
    }
    AMFDRErrorPushInternal((uint64_t)a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", v39, v43);
    v17 = 0;
    v12 = 0;
    goto LABEL_44;
  }
  AMFDRErrorPushInternal((uint64_t)a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchInternal", CFSTR("patchDict is NULL"), v43);
LABEL_37:
  v17 = 0;
  v32 = 0;
LABEL_69:
  if (err)
  {
    CFRelease(err);
    err = 0;
  }
  if (v32)
    CFRelease(v32);
  return v17;
}

__CFString *_AMFDRDataHTTPMultiPatchInternal(__CFString *a1, CFArrayRef theArray, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, const __CFArray *a6, const __CFArray *a7, uint64_t a8)
{
  __CFString *v9;
  __int128 v10;
  const __CFArray *v11;
  const __CFArray *v12;
  CFIndex Count;
  CFIndex v14;
  const __CFAllocator *v15;
  const __CFArray *Mutable;
  const __CFAllocator *v17;
  const __CFAllocator *v18;
  CFMutableDictionaryRef v19;
  CFIndex v20;
  CFStringRef FullKey;
  __CFDictionary *v22;
  CFTypeRef v23;
  CFTypeRef v24;
  CFTypeRef v25;
  CFTypeRef v26;
  const __CFData *ValueAtIndex;
  const __CFDictionary *v28;
  const __CFString *v29;
  const void *v30;
  const __CFDictionary *v31;
  const void *v32;
  const __CFAllocator *v33;
  const __CFAllocator *v34;
  uint64_t v35;
  const __CFString *v36;
  uint64_t v37;
  const __CFData *v38;
  CFTypeRef *v39;
  const __CFAllocator *v40;
  uint64_t v41;
  CFIndex v42;
  CFIndex v43;
  const void **v44;
  const void **v45;
  const __CFAllocator *v46;
  __CFString *MutableCopy;
  const __CFString *v48;
  uint64_t v49;
  const __CFString *v50;
  CFTypeID v51;
  CFDataRef EncodedData;
  const __CFAllocator *v53;
  CFArrayRef *v54;
  CFArrayRef *v55;
  const __CFData *v56;
  unsigned int v57;
  int v58;
  char v59;
  const __CFAllocator *v60;
  __CFDictionary *v61;
  CFAllocatorRef v62;
  const __CFString *format;
  const __CFAllocator *v64;
  CFMutableDictionaryRef v65;
  const __CFAllocator *v66;
  CFMutableDictionaryRef v67;
  const __CFAllocator *v68;
  __CFString *v69;
  int v70;
  __CFArray *v71;
  const __CFArray *v72;
  const __CFData *v73;
  const __CFAllocator *v74;
  const CFArrayCallBacks *v75;
  CFMutableArrayRef v76;
  const __CFAllocator *v77;
  CFMutableArrayRef v78;
  const __CFAllocator *v79;
  CFMutableArrayRef v80;
  const __CFAllocator *v81;
  CFMutableArrayRef v82;
  unsigned int v83;
  CFIndex v84;
  const __CFString *v85;
  const __CFString *v86;
  const __CFString *v87;
  const __CFString *v88;
  const void *v89;
  const void *v90;
  const __CFAllocator *v91;
  const __CFData *v92;
  const __CFAllocator *v93;
  CFMutableArrayRef v94;
  const UInt8 *BytePtr;
  unsigned int Length;
  BOOL v97;
  __CFArray *v98;
  const void *v99;
  const void *v100;
  const __CFString *v101;
  const __CFString *v102;
  const void *v103;
  const void *v104;
  const void *v105;
  const void **v106;
  CFMutableDictionaryRef v107;
  const void **v108;
  const __CFString *v110;
  const __CFString *v111;
  const __CFString *v112;
  const __CFString *v113;
  char v114;
  CFTypeRef v115;
  const __CFArray *v116;
  CFArrayRef v117;
  const __CFURL *v119;
  __CFDictionary *theDict;
  const __CFDictionary *v122;
  int v123;
  CFMutableDictionaryRef value;
  CFTypeRef cf;
  CFTypeRef v126;
  const void **v127;
  __CFDictionary *v128;
  CFTypeRef v129;
  CFTypeRef v130;
  CFTypeRef v131;
  CFDataRef v132;
  void *v133;
  const __CFDictionary *v134;
  __CFArray *v135;
  const __CFData *v136;
  CFMutableArrayRef v137;
  CFMutableArrayRef v139;
  const __CFData *v140;
  CFMutableArrayRef v141;
  uint64_t v142;
  const __CFArray *v143;
  CFIndex capacity;
  __CFArray *v146;
  __CFArray *v147;
  __CFString *v148;
  __CFString *v149;
  CFRange result;
  char v151;
  CFTypeRef v152;
  const void *v153;
  int v154;
  char v155;
  CFTypeRef v156;
  CFTypeRef v157;
  __int128 context;
  __int128 v159;
  int *v160;
  uint64_t v161;
  CFRange v162;
  CFRange v163;

  v9 = a1;
  v161 = *MEMORY[0x24BDAC8D0];
  v155 = 0;
  v160 = (int *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  context = v10;
  v159 = v10;
  v154 = 0;
  v152 = 0;
  v153 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("amfdr is NULL"), v114);
LABEL_328:
    v149 = 0;
    v106 = 0;
    v122 = 0;
    v117 = 0;
    v137 = 0;
    v139 = 0;
    v141 = 0;
    v135 = 0;
    v72 = 0;
    v98 = 0;
    Mutable = 0;
    goto LABEL_329;
  }
  v11 = theArray;
  if (!theArray)
  {
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("dataClassArray is NULL"), v114);
    v9 = 0;
    v149 = 0;
    v106 = 0;
    v122 = 0;
    v117 = 0;
    v137 = 0;
    v139 = 0;
    v141 = 0;
    v135 = 0;
    v72 = 0;
    v98 = 0;
    Mutable = 0;
LABEL_330:
    v119 = 0;
    theDict = 0;
    FullKey = 0;
    v107 = 0;
    v128 = 0;
    v103 = 0;
    v105 = 0;
    goto LABEL_243;
  }
  if (!a3)
  {
    v112 = CFSTR("dataInstanceArray is NULL");
LABEL_327:
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", v112, v114);
    v9 = 0;
    goto LABEL_328;
  }
  if (!a6)
  {
    v112 = CFSTR("patchDictArray is NULL");
    goto LABEL_327;
  }
  v12 = a4;
  if (!a4)
    v12 = a5;
  v116 = v12;
  if (!v12)
  {
    v112 = CFSTR("input data array is NULL");
    goto LABEL_327;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v112 = CFSTR("Invalid dataClassArray count");
    goto LABEL_327;
  }
  v14 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v112 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_327;
  }
  if (CFArrayGetCount(v116) != v14)
  {
    v112 = CFSTR("Invalid inputDataArray count");
    goto LABEL_327;
  }
  if (CFArrayGetCount(a6) != v14)
  {
    v112 = CFSTR("Invalid patchDictArray count");
    goto LABEL_327;
  }
  if (a7 && CFArrayGetCount(a7) != v14)
  {
    v112 = CFSTR("Invalid metadataDictArray count");
    goto LABEL_327;
  }
  v15 = CFGetAllocator(v9);
  Mutable = CFArrayCreateMutable(v15, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    v113 = CFSTR("valueDataArray is NULL");
LABEL_316:
    AMFDRErrorPushInternal(a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", v113, v114);
    v9 = 0;
    v149 = 0;
    v106 = 0;
    v122 = 0;
    v117 = 0;
    v137 = 0;
    v139 = 0;
    v141 = 0;
    v135 = 0;
    v72 = 0;
    v98 = 0;
LABEL_329:
    v11 = 0;
    goto LABEL_330;
  }
  v17 = CFGetAllocator(v9);
  v146 = CFArrayCreateMutable(v17, 0, MEMORY[0x24BDBD690]);
  if (!v146)
  {
    v113 = CFSTR("originalDigestArray is NULL");
    goto LABEL_316;
  }
  v18 = CFGetAllocator(v9);
  v19 = CFDictionaryCreateMutable(v18, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v19)
  {
    AMFDRErrorPushInternal(a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("patchedPayloadDict is NULL"), v114);
    v9 = 0;
    v149 = 0;
    v106 = 0;
    theDict = 0;
    v122 = 0;
    v117 = 0;
    v119 = 0;
    v137 = 0;
    v139 = 0;
    v141 = 0;
    v135 = 0;
    v72 = 0;
    v11 = 0;
    FullKey = 0;
    v107 = 0;
    v128 = 0;
    v103 = 0;
    v105 = 0;
    v98 = v146;
    goto LABEL_243;
  }
  capacity = v14;
  v148 = v9;
  theDict = v19;
  v20 = 0;
  v149 = 0;
  v127 = 0;
  FullKey = 0;
  v22 = 0;
  v23 = 0;
  v132 = 0;
  v133 = 0;
  cf = 0;
  v24 = 0;
  v25 = 0;
  v147 = Mutable;
  v26 = 0;
  v142 = a8;
  v143 = v11;
  do
  {
    v128 = v22;
    v129 = v24;
    ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v116, v20);
    v28 = (const __CFDictionary *)CFArrayGetValueAtIndex(a6, v20);
    v29 = (const __CFString *)CFArrayGetValueAtIndex(v11, v20);
    v30 = CFArrayGetValueAtIndex(a3, v20);
    v31 = a7;
    if (a7)
      v31 = (const __CFDictionary *)CFArrayGetValueAtIndex(a7, v20);
    v151 = 0;
    v126 = v26;
    if (!ValueAtIndex)
    {
      AMFDRErrorPushInternal(v142, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("inputData %ld is NULL"), v20);
LABEL_207:
      v99 = cf;
      v100 = v133;
      v24 = v129;
      goto LABEL_230;
    }
    if (!v28)
    {
      AMFDRErrorPushInternal(v142, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("patchDict %ld is NULL"), v20);
      goto LABEL_207;
    }
    if (!v29)
    {
      AMFDRErrorPushInternal(v142, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("dataClassStr %ld is NULL"), v20);
      goto LABEL_207;
    }
    if (!v30)
    {
      AMFDRErrorPushInternal(v142, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("dataInstanceStr %ld is NULL"), v20);
      goto LABEL_207;
    }
    v134 = v31;
    if (v23)
      CFRelease(v23);
    if (cf)
      CFRelease(cf);
    v140 = ValueAtIndex;
    v32 = v25;
    if (v153)
    {
      CFRelease(v153);
      v153 = 0;
    }
    v33 = CFGetAllocator(v148);
    v23 = _AMFDRDataCreateUnsignedValueNoCopy(v33, v140, &v151, v142);
    if (!v23)
    {
      AMFDRErrorPushInternal(v142, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("failed to strip data for %@-%@"), (char)v29);
      goto LABEL_210;
    }
    v34 = CFGetAllocator(v148);
    v35 = AMFDRSysconfigCreateFromData(v34, (CFDataRef)v23, v142);
    if (!v35)
    {
      AMFDRErrorPushInternal(v142, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("failed to decode as internal Sysconfig format"), v114);
LABEL_210:
      v99 = 0;
      v100 = v133;
      v24 = v129;
LABEL_230:
      v98 = v146;
      Mutable = v147;
      goto LABEL_231;
    }
    Mutable = v147;
    cf = (CFTypeRef)v35;
    if (v151)
    {
      v36 = FullKey;
      v37 = v35;
      if (CFArrayGetCount(*(CFArrayRef *)(v35 + 32)) || CFArrayGetCount(*(CFArrayRef *)(v37 + 40)))
      {
        v123 = 0;
      }
      else
      {
        AMSupportLogInternal();
        v123 = 1;
      }
      FullKey = v36;
    }
    else
    {
      v123 = 0;
    }
    if (a4)
      v38 = (const __CFData *)v23;
    else
      v38 = 0;
    if (FullKey)
      CFRelease(FullKey);
    v136 = v38;
    if (v133)
      CFRelease(v133);
    if (v132)
      CFRelease(v132);
    if (v32)
      CFRelease(v32);
    if (v129)
      CFRelease(v129);
    v39 = (CFTypeRef *)v142;
    if (v126)
      CFRelease(v126);
    if (v128)
      CFRelease(v128);
    if (v149)
      CFRelease(v149);
    if (v127)
      free(v127);
    v40 = CFGetAllocator(v148);
    FullKey = AMFDRDataLocalCreateFullKey(v40, (uint64_t)v29, (uint64_t)v30);
    if (!FullKey)
    {
      v102 = CFSTR("currDataInstance is NULL");
LABEL_213:
      AMFDRErrorPushInternal(v142, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", v102, v114);
      v126 = 0;
      v127 = 0;
      v25 = 0;
      v24 = 0;
      v100 = 0;
      v132 = 0;
      v128 = 0;
      v149 = 0;
      v99 = cf;
      goto LABEL_226;
    }
    CFGetAllocator(v148);
    AMFDRSysconfigCreate();
    if (!v41)
    {
      v102 = CFSTR("sysconfig is NULL");
      goto LABEL_213;
    }
    v133 = (void *)v41;
    AMFDRSysconfigSetDataClass(v41, v29);
    v42 = CFDictionaryGetCount(v28);
    v131 = v23;
    if (v42 >= 1)
    {
      v43 = v42;
      v44 = (const void **)malloc_type_calloc(1uLL, 8 * v42, 0x6004044C4A2DFuLL);
      if (v44)
      {
        v45 = v44;
        CFDictionaryGetKeysAndValues(v28, v44, 0);
        v46 = CFGetAllocator(v148);
        MutableCopy = CFStringCreateMutableCopy(v46, 0, v29);
        v127 = v45;
        if (MutableCopy)
        {
          v48 = FullKey;
          v149 = MutableCopy;
          CFStringAppend(MutableCopy, CFSTR(":"));
          v49 = 0;
          while (1)
          {
            v50 = (const __CFString *)v45[v49];
            if (!v50)
              break;
            v51 = CFGetTypeID(v45[v49]);
            if (v51 != CFStringGetTypeID())
              break;
            CFStringAppend(v149, CFSTR("/"));
            CFStringAppend(v149, v50);
            if (v43 == ++v49)
            {
              AMSupportLogInternal();
              Mutable = v147;
              v23 = v131;
              v39 = (CFTypeRef *)v142;
              goto LABEL_70;
            }
          }
          AMFDRErrorPushInternal(v142, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("patchDict key is not a string"), v114);
          v126 = 0;
          v24 = 0;
          v132 = 0;
          v128 = 0;
          Mutable = v147;
          v98 = v146;
          v23 = v131;
          v99 = cf;
          v100 = v133;
          v25 = 0;
          goto LABEL_231;
        }
        AMFDRErrorPushInternal(v142, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("Could not create patchItemKeysString"), v114);
        v126 = 0;
      }
      else
      {
        AMFDRErrorPushInternal(v142, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("keysInPatchDict is NULL"), v114);
        v126 = 0;
        v127 = 0;
      }
      v25 = 0;
      v24 = 0;
      v132 = 0;
      v128 = 0;
      v149 = 0;
      goto LABEL_225;
    }
    v48 = FullKey;
    v127 = 0;
    v149 = 0;
LABEL_70:
    if (!AMFDRSysconfigSetValues((CFArrayRef *)v133, v28, (uint64_t)v39))
    {
      AMFDRErrorPushInternal((uint64_t)v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("failed to set patch data %@"), (char)v48);
      v126 = 0;
      v24 = 0;
      v132 = 0;
      v128 = 0;
      v99 = cf;
      v100 = v133;
      FullKey = v48;
      v25 = 0;
      goto LABEL_226;
    }
    EncodedData = AMFDRSysconfigCreateEncodedData(v133, (uint64_t)v39);
    if (!EncodedData)
    {
      FullKey = v48;
      AMFDRErrorPushInternal((uint64_t)v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("failed to encode patch data %@"), (char)v48);
      v126 = 0;
      v25 = 0;
      v24 = 0;
      v132 = 0;
      v128 = 0;
LABEL_225:
      v99 = cf;
      v100 = v133;
LABEL_226:
      v98 = v146;
LABEL_231:
      v122 = 0;
      value = 0;
      v117 = 0;
      v119 = 0;
      v11 = 0;
      v72 = 0;
      v135 = 0;
      v137 = 0;
      v139 = 0;
      v141 = 0;
      v9 = 0;
      goto LABEL_232;
    }
    result.location = 0;
    v156 = 0;
    v157 = 0;
    FullKey = v48;
    v132 = EncodedData;
    if (!v136)
    {
      if (!a4)
      {
        v56 = (const __CFData *)CFRetain(v23);
        v25 = 0;
        v55 = 0;
LABEL_81:
        v57 = AMFDRDataLocalPatchCreatePayloadAndDigest(v148, v29, v56, (CFTypeRef *)&result, &v156, (uint64_t)v39) ^ 1;
        if (!result.location)
          v57 = 1;
        if (v156)
          v58 = v57;
        else
          v58 = 1;
        if (v58 == 1)
        {
          AMFDRErrorPushInternal((uint64_t)v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPatchCopyDigestAndPayload", CFSTR("failed to copy patched digest and payload"), v114);
          v26 = 0;
          v24 = 0;
        }
        else
        {
          v24 = CFRetain(v156);
          v26 = CFRetain((CFTypeRef)result.location);
        }
        v59 = v58 ^ 1;
        if (!v55)
          goto LABEL_90;
        goto LABEL_89;
      }
      AMFDRErrorPushInternal((uint64_t)v39, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPatchCopyDigestAndPayload", CFSTR("expectedData is NULL"), v114);
LABEL_124:
      v26 = 0;
      v25 = 0;
      v24 = 0;
      v59 = 0;
      goto LABEL_92;
    }
    v53 = CFGetAllocator(v148);
    v54 = (CFArrayRef *)AMFDRSysconfigCreateFromData(v53, v136, (uint64_t)v39);
    if (!v54)
    {
      AMFDRErrorPushInternal((uint64_t)v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPatchCopyDigestAndPayload", CFSTR("failed to decode original data"), v114);
      goto LABEL_124;
    }
    v55 = v54;
    if (AMFDRSysconfigSetValues(v54, v28, (uint64_t)v39))
    {
      v56 = AMFDRSysconfigCreateEncodedData(v55, (uint64_t)v39);
      if (v56)
      {
        if (AMFDRDataLocalPatchCreatePayloadAndDigest(v148, v29, v136, 0, &v157, (uint64_t)v39) && v157)
        {
          v25 = CFRetain(v157);
          goto LABEL_81;
        }
        format = CFSTR("failed to copy original digest");
      }
      else
      {
        format = CFSTR("failed to encode patched data");
      }
    }
    else
    {
      v56 = 0;
      format = CFSTR("failed to patch data");
    }
    AMFDRErrorPushInternal((uint64_t)v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataHTTPPatchCopyDigestAndPayload", format, v114);
    v26 = 0;
    v25 = 0;
    v24 = 0;
    v59 = 0;
LABEL_89:
    CFRelease(v55);
LABEL_90:
    if (v56)
      CFRelease(v56);
LABEL_92:
    v11 = v143;
    if (result.location)
    {
      CFRelease((CFTypeRef)result.location);
      result.location = 0;
    }
    if (v157)
    {
      CFRelease(v157);
      v157 = 0;
    }
    if (v156)
      CFRelease(v156);
    if ((v59 & 1) == 0)
    {
      v126 = v26;
      AMFDRErrorPushInternal((uint64_t)v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("failed to obtain digests for patched data %@"), (char)FullKey);
      goto LABEL_218;
    }
    if (a4 && !v25)
    {
      v126 = v26;
      AMFDRErrorPushInternal((uint64_t)v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("failed to obtain original digest"), v114);
LABEL_218:
      v128 = 0;
      v23 = v131;
LABEL_229:
      v99 = cf;
      v100 = v133;
      goto LABEL_230;
    }
    v23 = v131;
    if (!v24 || !v26)
    {
      v126 = v26;
      AMFDRErrorPushInternal((uint64_t)v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("failed to obtain valid patched digest and data"), v114);
LABEL_221:
      v128 = 0;
      goto LABEL_229;
    }
    CFDictionarySetValue(theDict, FullKey, v26);
    v60 = CFGetAllocator(v148);
    if (v134)
      v61 = CFDictionaryCreateMutableCopy(v60, 0, v134);
    else
      v61 = CFDictionaryCreateMutable(v60, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    v22 = v61;
    if (!v61)
    {
      v126 = v26;
      AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("metadataDict is NULL"), v114);
      goto LABEL_221;
    }
    if ((*(_BYTE *)(v148[4].info + 8) & 0x40) == 0 && v25)
      CFDictionarySetValue(v61, CFSTR("x-fdr-jmet-payload-dgst"), v25);
    CFDictionarySetValue(v22, CFSTR("x-fdr-jmet-payload-dgst-expected"), v24);
    if (v123)
    {
      v62 = CFGetAllocator(v148);
      if ((_AMFDRSupportBase64Encode((uint64_t)v62, (uint64_t)v140, (uint64_t)&v153) & 1) == 0)
      {
        v128 = v22;
        v126 = v26;
        AMFDRErrorPushInternal((uint64_t)v39, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("_AMFDRSupportBase64Encode failed"), v114);
        goto LABEL_229;
      }
      if (!v153)
      {
        v128 = v22;
        v126 = v26;
        AMFDRErrorPushInternal((uint64_t)v39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("basePayload is NULL"), v114);
        goto LABEL_229;
      }
      CFDictionarySetValue(v22, CFSTR("x-fdr-patch-base-payload"), v153);
    }
    CFArrayAppendValue(v147, v132);
    CFArrayAppendValue(v146, v22);
    ++v20;
  }
  while (v20 != capacity);
  v64 = CFGetAllocator(v148);
  v65 = CFDictionaryCreateMutable(v64, capacity, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v126 = v26;
  v128 = v22;
  if (!v65)
  {
    AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("valueDataDict is NULL"), v114);
    value = 0;
    v117 = 0;
    v119 = 0;
LABEL_320:
    v11 = 0;
    v72 = 0;
    v135 = 0;
    v137 = 0;
    v139 = 0;
    v141 = 0;
    v122 = 0;
LABEL_322:
    v9 = 0;
    v99 = cf;
    v100 = v133;
    v98 = v146;
    Mutable = v147;
    goto LABEL_232;
  }
  v117 = v65;
  v66 = CFGetAllocator(v148);
  v67 = CFDictionaryCreateMutable(v66, capacity, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v67)
  {
    AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("manifestDataDict is NULL"), v114);
    value = 0;
    v119 = 0;
    goto LABEL_320;
  }
  v122 = v67;
  v68 = CFGetAllocator(v148);
  value = CFDictionaryCreateMutable(v68, capacity, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!value)
  {
    AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("multiRequestErrors is NULL"), v114);
    value = 0;
    v119 = 0;
    v11 = 0;
    v72 = 0;
    v135 = 0;
    v137 = 0;
    v139 = 0;
    v141 = 0;
    goto LABEL_322;
  }
  Mutable = v147;
  if ((AMFDRDataHTTPLoadPersistent((CFDataRef *)v148, v39) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)v39, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("AMFDRDataHTTPLoadPersistent failed"), v114);
LABEL_325:
    v119 = 0;
    v11 = 0;
    v72 = 0;
    v135 = 0;
    v137 = 0;
    v139 = 0;
    v141 = 0;
    v9 = 0;
    v99 = cf;
    v100 = v133;
    v98 = v146;
    goto LABEL_232;
  }
  v69 = _AMFDRCreateUrlWithKey((uint64_t)v148, CFSTR("DSURL"), (uint64_t)CFSTR("dm/bulk/data"), 0, 0);
  if (!v69)
  {
    AMFDRErrorPushInternal((uint64_t)v39, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("serverURL is NULL"), v114);
    goto LABEL_325;
  }
  v119 = (const __CFURL *)v69;
  if (!_AMFDRGetMultiRequestMaxAttempts((uint64_t)v148))
  {
    v73 = 0;
    v72 = 0;
    v71 = 0;
    v139 = 0;
    v141 = 0;
    v137 = 0;
LABEL_185:
    v135 = v71;
    *(_QWORD *)&context = v148;
    *((_QWORD *)&context + 1) = v117;
    *(_QWORD *)&v159 = value;
    *((_QWORD *)&v159 + 1) = theDict;
    CFDictionaryApplyFunction(v122, (CFDictionaryApplierFunction)_AMFDRDataHTTPPatchCreateImg4Callback, &context);
    if (CFDictionaryGetCount(value) >= 1)
      AMFDRErrorPushInternal((uint64_t)v39, 21, 0, 0, 0, 0, 0, 0, value, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("got multiRequestErrors"), v114);
    v11 = v73;
    v9 = (__CFString *)CFRetain(v117);
    goto LABEL_188;
  }
  v70 = 0;
  v137 = 0;
  v139 = 0;
  v141 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v130 = v24;
  v115 = v25;
  while (2)
  {
    if (v71)
      CFRelease(v71);
    if (v141)
      CFRelease(v141);
    if (v139)
      CFRelease(v139);
    if (v137)
      CFRelease(v137);
    if (v73)
      CFRelease(v73);
    if (v152)
    {
      CFRelease(v152);
      v152 = 0;
    }
    v74 = CFGetAllocator(v148);
    v75 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
    v76 = CFArrayCreateMutable(v74, 0, MEMORY[0x24BDBD690]);
    if (!v76)
    {
      AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("dataClassToRequest is NULL"), v114);
      v11 = 0;
      v135 = 0;
LABEL_288:
      v141 = 0;
LABEL_290:
      v139 = 0;
LABEL_292:
      v137 = 0;
      v9 = 0;
      v98 = v146;
      v23 = v131;
      v99 = cf;
      v100 = v133;
      v25 = v115;
      goto LABEL_232;
    }
    v135 = v76;
    v77 = CFGetAllocator(v148);
    v78 = CFArrayCreateMutable(v77, 0, v75);
    if (!v78)
    {
      AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("dataInstanceToRequest is NULL"), v114);
      v11 = 0;
      goto LABEL_288;
    }
    v141 = v78;
    v79 = CFGetAllocator(v148);
    v80 = CFArrayCreateMutable(v79, 0, v75);
    if (!v80)
    {
      AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("valueToRequest is NULL"), v114);
      v11 = 0;
      goto LABEL_290;
    }
    v139 = v80;
    v81 = CFGetAllocator(v148);
    v82 = CFArrayCreateMutable(v81, 0, v75);
    if (!v82)
    {
      AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("metadataToRequest is NULL"), v114);
      v11 = 0;
      goto LABEL_292;
    }
    v137 = v82;
    v25 = v115;
    if (v70)
    {
      v83 = _AMFDRGetMultiRequestBackoff((uint64_t)v148) * v70;
      AMSupportLogInternal();
      sleep(v83);
    }
    v84 = 0;
    while (2)
    {
      CFRelease(FullKey);
      v85 = (const __CFString *)CFArrayGetValueAtIndex(v11, v84);
      if (!v85)
      {
        v101 = CFSTR("dataClassStr is NULL");
LABEL_192:
        AMFDRErrorPushInternal((uint64_t)v39, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", v101, v114);
        goto LABEL_193;
      }
      v86 = v85;
      if (!CFStringGetLength(v85))
      {
        v101 = CFSTR("dataClassStr length is 0");
        goto LABEL_192;
      }
      v87 = (const __CFString *)CFArrayGetValueAtIndex(a3, v84);
      if (!v87)
      {
        v101 = CFSTR("dataInstanceStr is NULL");
        goto LABEL_192;
      }
      v88 = v87;
      if ((*(_BYTE *)(v148[4].info + 8) & 2) != 0)
      {
        result.location = 0xAAAAAAAAAAAAAAAALL;
        result.length = 0xAAAAAAAAAAAAAAAALL;
        v163.location = 0;
        v163.length = 4;
        if (CFStringFindWithOptions(v87, CFSTR("sik-"), v163, 8uLL, &result))
        {
          AMFDRErrorPushInternal((uint64_t)v39, 403, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("Station AMFDRDataHTTPMultiPatch with sik format is forbidden. %@-%@"), (char)v86);
LABEL_193:
          FullKey = 0;
LABEL_194:
          v11 = 0;
LABEL_196:
          v9 = 0;
          goto LABEL_200;
        }
      }
      v11 = (const __CFArray *)CFArrayGetValueAtIndex(Mutable, v84);
      if (!v11)
      {
        AMFDRErrorPushInternal((uint64_t)v39, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("valueData is NULL"), v114);
        FullKey = 0;
        goto LABEL_196;
      }
      v89 = CFArrayGetValueAtIndex(v146, v84);
      if (!v89)
      {
        AMFDRErrorPushInternal((uint64_t)v39, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("currMetadata is NULL"), v114);
        FullKey = 0;
        goto LABEL_199;
      }
      v90 = v89;
      v91 = CFGetAllocator(v148);
      FullKey = AMFDRDataLocalCreateFullKey(v91, (uint64_t)v86, (uint64_t)v88);
      if (!FullKey)
      {
        AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("currDataInstance is NULL"), v114);
LABEL_199:
        v11 = 0;
        v9 = 0;
        Mutable = v147;
LABEL_200:
        v98 = v146;
        v24 = v130;
        v23 = v131;
        goto LABEL_201;
      }
      if (v72)
      {
        v162.length = CFArrayGetCount(v72);
        v162.location = 0;
        if (CFArrayContainsValue(v72, v162, FullKey))
        {
          CFDictionaryRemoveValue(value, FullKey);
          v39 = (CFTypeRef *)v142;
          AMSupportLogInternal();
          goto LABEL_162;
        }
      }
      else
      {
LABEL_162:
        CFArrayAppendValue(v135, v86);
        CFArrayAppendValue(v141, v88);
        CFArrayAppendValue(v139, v11);
        CFArrayAppendValue(v137, v90);
      }
      ++v84;
      v11 = v143;
      Mutable = v147;
      if (capacity != v84)
        continue;
      break;
    }
    v92 = AMFDRDataHTTPCreateMultiRequest(v148, 0x10u, v135, v141, v139, 0, v137, 1, (uint64_t)v39);
    if (!v92)
    {
      AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("httpRequestData is NULL"), v114);
      goto LABEL_194;
    }
    v73 = v92;
    v24 = v130;
    if (v39 && *v39)
    {
      CFRelease(*v39);
      *v39 = 0;
    }
    *(_QWORD *)&context = v135;
    *((_QWORD *)&context + 1) = v141;
    *(_QWORD *)&v159 = v139;
    *((_QWORD *)&v159 + 1) = v137;
    if ((_AMFDRHttpRequestSendSync((CFDictionaryRef *)v148, v119, (uint64_t)CFSTR("MultiPatch"), CFSTR("POST"), 0, v73, &v152, 0, 0, 0, (uint64_t (*)(CFDictionaryRef *, uint64_t, CFTypeRef *))AMFDRDataHTTPMultiCopyForPatch, (uint64_t)&context, v39) & 1) == 0)
    {
      v11 = v73;
      goto LABEL_303;
    }
    if (v39 && *v39)
    {
      v11 = v73;
LABEL_303:
      AMSupportLogInternal();
      goto LABEL_304;
    }
    if (!v152)
    {
      v11 = v73;
      v110 = CFSTR("_AMFDRHttpRequestSendSync failed: httpReturnData is NULL");
LABEL_301:
      AMFDRErrorPushInternal((uint64_t)v39, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", v110, v114);
      goto LABEL_304;
    }
    if (v72)
      CFRelease(v72);
    v93 = CFGetAllocator(v148);
    v94 = CFArrayCreateMutable(v93, 0, MEMORY[0x24BDBD690]);
    v72 = v94;
    if (!v94)
    {
      v11 = v73;
      AMFDRErrorPushInternal((uint64_t)v39, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", CFSTR("dataClassInstanceToRetry is NULL"), v114);
      goto LABEL_304;
    }
    *(_QWORD *)&context = v148;
    *((_QWORD *)&context + 1) = v122;
    *(_QWORD *)&v159 = value;
    *((_QWORD *)&v159 + 1) = v94;
    v160 = &v154;
    BytePtr = CFDataGetBytePtr((CFDataRef)v152);
    Length = CFDataGetLength((CFDataRef)v152);
    if (AMFDRDecodeMultiResponse((uint64_t)BytePtr, Length, &v155, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD, _QWORD, _DWORD, uint64_t))_AMFDRHttpMultiResponseCallback, (uint64_t)&context))
    {
      v11 = v73;
      v111 = CFSTR("AMFDRDecodeMultiResponse failed");
      goto LABEL_299;
    }
    if (v155 == 16)
    {
      if ((_AMFDRSavePersistentCookie((uint64_t)v148, (uint64_t)v39) & 1) == 0)
      {
        v11 = v73;
        v110 = CFSTR("_AMFDRSavePersistentCookie failed");
        goto LABEL_301;
      }
      if (!CFArrayGetCount(v72))
      {
        v71 = v135;
        goto LABEL_185;
      }
      v97 = ++v70 >= _AMFDRGetMultiRequestMaxAttempts((uint64_t)v148);
      v71 = v135;
      if (v97)
        goto LABEL_185;
      continue;
    }
    break;
  }
  v11 = v73;
  v114 = v155;
  v111 = CFSTR("actionCode returned is %d");
LABEL_299:
  AMFDRErrorPushInternal((uint64_t)v39, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPMultiPatchInternal", v111, v114);
LABEL_304:
  v9 = 0;
LABEL_188:
  v98 = v146;
  v23 = v131;
LABEL_201:
  v99 = cf;
  v100 = v133;
LABEL_232:
  v103 = v24;
  if (v100)
  {
    v104 = v99;
    CFRelease(v100);
    v99 = v104;
  }
  if (v99)
    CFRelease(v99);
  if (v132)
    CFRelease(v132);
  if (v126)
    CFRelease(v126);
  v105 = v25;
  if (v23)
    CFRelease(v23);
  v106 = v127;
  v107 = value;
LABEL_243:
  v108 = v106;
  if (v153)
  {
    CFRelease(v153);
    v106 = v108;
    v153 = 0;
  }
  if (v105)
  {
    CFRelease(v105);
    v106 = v108;
  }
  if (v103)
  {
    CFRelease(v103);
    v106 = v108;
  }
  if (theDict)
  {
    CFRelease(theDict);
    v106 = v108;
  }
  if (v128)
  {
    CFRelease(v128);
    v106 = v108;
  }
  if (FullKey)
  {
    CFRelease(FullKey);
    v106 = v108;
  }
  if (v107)
  {
    CFRelease(v107);
    v106 = v108;
  }
  if (v119)
  {
    CFRelease(v119);
    v106 = v108;
  }
  if (v11)
  {
    CFRelease(v11);
    v106 = v108;
  }
  if (v152)
  {
    CFRelease(v152);
    v106 = v108;
    v152 = 0;
  }
  if (Mutable)
  {
    CFRelease(Mutable);
    v106 = v108;
  }
  if (v98)
  {
    CFRelease(v98);
    v106 = v108;
  }
  if (v72)
  {
    CFRelease(v72);
    v106 = v108;
  }
  if (v135)
  {
    CFRelease(v135);
    v106 = v108;
  }
  if (v141)
  {
    CFRelease(v141);
    v106 = v108;
  }
  if (v139)
  {
    CFRelease(v139);
    v106 = v108;
  }
  if (v137)
  {
    CFRelease(v137);
    v106 = v108;
  }
  if (v117)
  {
    CFRelease(v117);
    v106 = v108;
  }
  if (v122)
  {
    CFRelease(v122);
    v106 = v108;
  }
  if (v149)
  {
    CFRelease(v149);
    v106 = v108;
  }
  if (v106)
    free(v106);
  return v9;
}

const __CFData *AMFDRDataHTTPMultiCopyForPatch(__CFString *a1, CFArrayRef *a2, uint64_t a3)
{
  return AMFDRDataHTTPCreateMultiRequest(a1, 0x10u, *a2, a2[1], a2[2], 0, a2[3], 1, a3);
}

void _AMFDRDataHTTPPatchCreateImg4Callback(const void *a1, const __CFData *a2, uint64_t a3)
{
  const void *v4;
  __CFDictionary *v5;
  __CFDictionary *v6;
  const __CFDictionary *v7;
  const __CFData *SignedData;
  int v9;
  const __CFData *Value;
  const __CFString *format;
  char v12;
  const void *v13;

  v4 = *(const void **)a3;
  v5 = *(__CFDictionary **)(a3 + 8);
  v6 = *(__CFDictionary **)(a3 + 16);
  v7 = *(const __CFDictionary **)(a3 + 24);
  v13 = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)&v13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchCreateImg4Callback", CFSTR("dataClassInstance is NULL"), v12);
    goto LABEL_13;
  }
  SignedData = a2;
  if (a2)
  {
    if (v4)
    {
      if (v5)
      {
        if (v7)
        {
          v9 = CFGetAllocator(v4);
          Value = (const __CFData *)CFDictionaryGetValue(v7, a1);
          SignedData = (const __CFData *)AMFDRDataLocalPatchCreateSignedData(v9, Value, SignedData, (uint64_t)&v13);
          if (SignedData)
            CFDictionarySetValue(v5, a1, SignedData);
          else
            AMFDRErrorPushInternal((uint64_t)&v13, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchCreateImg4Callback", CFSTR("failed to created img4 for %@"), (char)a1);
          goto LABEL_8;
        }
        format = CFSTR("payloadDict is NULL");
      }
      else
      {
        format = CFSTR("outDict is NULL");
      }
    }
    else
    {
      format = CFSTR("amfdr is NULL");
    }
    AMFDRErrorPushInternal((uint64_t)&v13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchCreateImg4Callback", format, v12);
    SignedData = 0;
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)&v13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataHTTPPatchCreateImg4Callback", CFSTR("manifestData is NULL"), v12);
  }
LABEL_8:
  if (v13 && v6)
    CFDictionarySetValue(v6, a1, v13);
  if (SignedData)
    CFRelease(SignedData);
LABEL_13:
  if (v13)
    CFRelease(v13);
}

CFDictionaryRef AMFDRCreateLocalPending(const __CFAllocator *a1)
{
  return CFDictionaryCreate(a1, 0, 0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
}

uint64_t AMFDRDataPutForSysCfgKey()
{
  return 1;
}

uint64_t AMFDRCryptoGetPrivateKey(uint64_t a1)
{
  _QWORD *v1;
  uint64_t (*v2)(uint64_t, _QWORD);

  if (a1
    && (v1 = *(_QWORD **)(a1 + 136), *v1 >= 0x61uLL)
    && (v2 = (uint64_t (*)(uint64_t, _QWORD))v1[12]) != 0)
  {
    return v2(a1, *(_QWORD *)(a1 + 144));
  }
  else
  {
    return 0;
  }
}

CFTypeRef AMFDRCryptoGetCert(uint64_t a1)
{
  CFTypeRef result;
  const void *Value;

  result = *(CFTypeRef *)(a1 + 32);
  if (!result)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("Certificate"));
    if (Value)
    {
      result = CFRetain(Value);
      *(_QWORD *)(a1 + 32) = result;
    }
    else
    {
      return *(CFTypeRef *)(a1 + 32);
    }
  }
  return result;
}

uint64_t AMFDRCryptoGetCryptoVersion(uint64_t a1, unsigned int a2, int *a3)
{
  uint64_t result;
  int v7;
  BOOL v8;
  int v9;

  v9 = 0;
  if (!a1 || !a3 || (AMFDRDataGetSigningVersion(a1, &v9) & 1) == 0)
  {
    AMSupportLogInternal();
    return 199;
  }
  if (!a2)
  {
    if (v9 != 2)
    {
      if (v9 == 1)
      {
        result = 0;
        v7 = 257;
        goto LABEL_18;
      }
      return 9;
    }
    result = 0;
    v8 = (*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) & 2) == 0;
    v7 = 1025;
LABEL_16:
    if (v8)
      v7 = 66050;
    goto LABEL_18;
  }
  if (a2 > 2)
    return 0;
  if (v9 == 2)
  {
    result = 0;
    v8 = (*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) & 2) == 0;
    v7 = 513;
    goto LABEL_16;
  }
  if (v9 != 1)
    return 9;
  result = 0;
  v7 = 513;
LABEL_18:
  *a3 = v7;
  return result;
}

uint64_t AMFDRCryptoCreateFDRSignature(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6)
{
  return AMFDRCryptoCreateFDRSignatureInternal(a2, a3, a4, a5, (uint64_t (*)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, CFTypeRef))AMFDRCryptoCreateDataSignature, a6);
}

uint64_t AMFDRCryptoCreateFDRSignatureInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, CFTypeRef), CFTypeRef cf)
{
  CFTypeID v12;
  uint64_t CryptoVersion;
  uint64_t v14;
  unsigned int v16;

  v16 = 0;
  if (cf && (v12 = CFGetTypeID(cf), v12 == AMFDRGetTypeID()) && a5)
  {
    CryptoVersion = AMFDRCryptoGetCryptoVersion((uint64_t)cf, 0, (int *)&v16);
    if ((_DWORD)CryptoVersion)
    {
      v14 = CryptoVersion;
      AMSupportLogInternal();
    }
    else
    {
      return a5(v16, a1, a2, a3, a4, cf);
    }
  }
  else
  {
    AMSupportLogInternal();
    return 103;
  }
  return v14;
}

uint64_t AMFDRCryptoCreateLocalSignedFDRSignature(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6)
{
  return AMFDRCryptoCreateFDRSignatureInternal(a2, a3, a4, a5, (uint64_t (*)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, CFTypeRef))AMFDRCryptoCreateLocalSignedDataSignature, a6);
}

uint64_t AMFDRCryptoCreateFDRCertificateData(_QWORD *a1, _DWORD *a2, CFDataRef *cf)
{
  CFTypeID v6;
  const __CFData *v7;
  CFIndex Length;
  void *v9;
  void *v10;
  const UInt8 *BytePtr;
  uint64_t v12;
  CFTypeRef v14;

  v14 = 0;
  if (cf
    && (v6 = CFGetTypeID(cf), v6 == AMFDRGetTypeID())
    && a1
    && a2
    && (AMFDRDataHTTPLoadPersistent(cf, &v14) & 1) != 0
    && (v7 = cf[4]) != 0
    && (Length = CFDataGetLength(v7), v9 = malloc_type_calloc(1uLL, Length, 0x73A55033uLL), (*a1 = v9) != 0))
  {
    v10 = v9;
    BytePtr = CFDataGetBytePtr(cf[4]);
    memcpy(v10, BytePtr, Length);
    v12 = 0;
    *a2 = Length;
  }
  else
  {
    AMSupportLogInternal();
    v12 = 199;
  }
  AMSupportSafeRelease();
  return v12;
}

uint64_t AMFDRCryptoCreateLocalSignedFDRCertificateData(_QWORD *a1, _DWORD *a2, CFTypeRef cf)
{
  CFTypeID v6;
  uint64_t CryptoVersion;
  uint64_t v8;
  int v10;

  v10 = 0;
  if (cf && (v6 = CFGetTypeID(cf), v6 == AMFDRGetTypeID()))
  {
    CryptoVersion = AMFDRCryptoGetCryptoVersion((uint64_t)cf, 0, &v10);
    if ((_DWORD)CryptoVersion)
    {
      v8 = CryptoVersion;
      AMSupportLogInternal();
    }
    else
    {
      return AMFDRCryptoCreateLocalSignedCertificateData(v10, a1, a2);
    }
  }
  else
  {
    AMSupportLogInternal();
    return 199;
  }
  return v8;
}

CFDataRef AMFDRCryptoCreatePemFromData(uint64_t a1, int a2)
{
  const __CFAllocator *v3;
  __CFString *Mutable;
  __CFString *v5;
  CFIndex v6;
  __int128 v7;
  CFIndex Length;
  CFIndex v9;
  CFDataRef ExternalRepresentation;
  UniChar buffer[8];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  CFRange v21;

  v20 = *MEMORY[0x24BDAC8D0];
  v3 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if (AMSupportBase64Encode())
  {
    v5 = 0;
    goto LABEL_20;
  }
  Mutable = CFStringCreateMutable(v3, 0);
  v5 = Mutable;
  if (!Mutable)
  {
LABEL_20:
    ExternalRepresentation = 0;
    goto LABEL_16;
  }
  if (a2)
    CFStringAppend(Mutable, CFSTR("-----BEGIN CERTIFICATE REQUEST-----\n"));
  if (CFStringGetLength(0) >= 1)
  {
    v6 = 0;
    do
    {
      *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v18 = v7;
      v19 = v7;
      v16 = v7;
      v17 = v7;
      v14 = v7;
      v15 = v7;
      *(_OWORD *)buffer = v7;
      v13 = v7;
      Length = CFStringGetLength(0);
      if (Length - v6 >= 64)
        v9 = 64;
      else
        v9 = Length - v6;
      v21.location = v6;
      v21.length = v9;
      CFStringGetCharacters(0, v21, buffer);
      CFStringAppendCharacters(v5, buffer, v9);
      if (a2)
        CFStringAppend(v5, CFSTR("\n"));
      v6 += v9;
    }
    while (v6 < CFStringGetLength(0));
  }
  if ((a2 & 1) != 0)
    CFStringAppend(v5, CFSTR("-----END CERTIFICATE REQUEST-----"));
  ExternalRepresentation = CFStringCreateExternalRepresentation(v3, v5, 0x8000100u, 0x20u);
LABEL_16:
  if (v5)
    CFRelease(v5);
  return ExternalRepresentation;
}

CFDataRef AMFDRCryptoCreateSignedCsr(const __CFDictionary **a1, uint64_t a2, const __CFString *a3, const __CFData *a4, uint64_t (*a5)(_QWORD, _QWORD, _QWORD, _QWORD), uint64_t a6)
{
  uint64_t (*v7)(_QWORD, _QWORD, _QWORD, _QWORD);
  const __CFData *v8;
  uint64_t v10;
  CFDataRef v11;
  const char *v12;
  char v13;
  const char *v14;
  const char *v15;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  CFTypeID v19;
  uint64_t v20;
  const void *v21;
  char v22;
  char v23;
  __CFString *v24;
  const __CFArray *v25;
  const __CFArray *v26;
  CFTypeID v27;
  CFIndex v28;
  const void *ValueAtIndex;
  CFTypeID v30;
  CFTypeID v31;
  int v32;
  char *v33;
  CFTypeID v34;
  CFTypeID TypeID;
  CFTypeID v36;
  const __CFAllocator *v37;
  _BOOL4 v38;
  _BOOL4 v39;
  const UInt8 *v40;
  int v41;
  const UInt8 *v42;
  int v43;
  const __CFData *v44;
  const __CFString *v45;
  CFTypeID v46;
  const __CFAllocator *v47;
  const __CFData *ExternalRepresentation;
  const UInt8 *BytePtr;
  int v50;
  const __CFAllocator *v51;
  const __CFData *v52;
  const __CFData *v53;
  const UInt8 *v54;
  int v55;
  _QWORD *v56;
  uint64_t (*v57)(CFDataRef, _QWORD);
  _QWORD *v58;
  uint64_t (*v59)(CFDataRef, _QWORD);
  uint64_t v60;
  uint64_t SikInstanceStringInternal;
  const __CFString *v62;
  const __CFAllocator *v63;
  const __CFData *v64;
  const __CFData *v65;
  const UInt8 *v66;
  int v67;
  const __CFString *v68;
  const __CFString *v69;
  CFTypeID v70;
  const __CFAllocator *v71;
  const __CFData *v72;
  const __CFData *v73;
  const UInt8 *v74;
  int v75;
  const UInt8 *v76;
  int v77;
  const __CFString *v78;
  const __CFString *v79;
  CFTypeID v80;
  const __CFAllocator *v81;
  const __CFData *v82;
  const __CFData *v83;
  const UInt8 *v84;
  int v85;
  __int128 v86;
  const __CFDictionary *v87;
  const __CFData *Value;
  const __CFData *v89;
  void *v90;
  unint64_t v91;
  int v92;
  int v93;
  const __CFData *v94;
  _QWORD *v95;
  const UInt8 *v96;
  unsigned int v97;
  const __CFAllocator *v98;
  CFDataRef v99;
  const UInt8 *v100;
  unsigned int v101;
  const __CFAllocator *v102;
  int v104;
  int v105;
  int EncodedBuffer;
  const UInt8 *v107;
  int v108;
  int v109;
  int v110;
  const __CFData *v111;
  const __CFDictionary *v112;
  CFTypeRef v113;
  char cf;
  const __CFData *cfa;
  uint64_t v116;
  unsigned int v117;
  unsigned int v118;
  uint64_t (*v119)(_QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t (*v120)(_QWORD, _QWORD, _QWORD, _QWORD);
  char *v121;
  char v122;
  char *v123;
  char *v124;
  const __CFData *v126;
  _DWORD length[4];
  _DWORD v128[3];
  CFDataRef theData;
  int v130;
  _QWORD v131[3];
  void *keys[4];
  void *v133[3];
  void *values;
  int v135;
  int v136;
  _OWORD v137[16];
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  unint64_t v150;
  uint64_t v151;

  v7 = a5;
  v8 = a4;
  v10 = a2;
  v11 = (CFDataRef)a1;
  v151 = *MEMORY[0x24BDAC8D0];
  theData = 0;
  memset(v128, 0, sizeof(v128));
  *(_QWORD *)&length[1] = 0;
  length[0] = 0;
  v126 = 0;
  if ((int)a2 <= 1025)
  {
    if ((int)a2 <= 513)
    {
      if ((_DWORD)a2 != 257)
      {
        if ((_DWORD)a2 == 513)
        {
          v12 = 0;
          v13 = 0;
          v14 = "1.2.840.113549.1.1.11";
          goto LABEL_149;
        }
LABEL_151:
        AMSupportLogInternal();
        goto LABEL_152;
      }
      v12 = 0;
      v13 = 0;
      v14 = "1.2.840.113549.1.1.5";
LABEL_149:
      v15 = "1.2.840.113549.1.1.1";
      if (!a1)
        goto LABEL_150;
      goto LABEL_19;
    }
    if ((_DWORD)a2 != 514)
    {
      if ((_DWORD)a2 != 1025)
        goto LABEL_151;
      v12 = 0;
      v13 = 0;
      v14 = "1.2.840.113549.1.1.12";
      goto LABEL_149;
    }
    goto LABEL_16;
  }
  if ((int)a2 <= 66561)
  {
    if ((_DWORD)a2 != 1026)
    {
      if ((_DWORD)a2 != 66050)
        goto LABEL_151;
LABEL_16:
      v13 = 1;
      v14 = "1.2.840.10045.4.3.2";
      v12 = "1.2.840.10045.3.1.7";
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if ((_DWORD)a2 == 66562)
  {
LABEL_17:
    v13 = 1;
    v14 = "1.2.840.10045.4.3.3";
    v12 = "1.3.132.0.34";
    goto LABEL_18;
  }
  if ((_DWORD)a2 != 67586)
    goto LABEL_151;
  v13 = 1;
  v14 = "1.2.840.10045.4.3.2";
  v12 = "1.3.132.0.33";
LABEL_18:
  v15 = "1.2.840.10045.2.1";
  if (!a1)
  {
LABEL_150:
    AMSupportLogInternal();
    v99 = 0;
    goto LABEL_139;
  }
LABEL_19:
  if (!a4 || !a5)
    goto LABEL_151;
  v123 = (char *)v15;
  v124 = (char *)v12;
  v121 = (char *)v14;
  v122 = v13;
  v16 = a1[2];
  if (!v16
    || (v17 = (const __CFDictionary *)CFDictionaryGetValue(v16, CFSTR("CSRFormatOverride"))) == 0
    || (v18 = v17, v19 = CFGetTypeID(v17), v19 != CFDictionaryGetTypeID())
    || CFDictionaryGetCount(v18) < 1)
  {
    v131[0] = 0;
    v130 = 2;
    if ((AMFDRDataGetSigningVersion((uint64_t)v11, &v130) & 1) == 0)
      goto LABEL_73;
    if (AMFDREncodeCertificateRequestBegin((uint64_t)v131)
      || AMFDREncodeCertificateRequestAddSubject((uint64_t)v131, "2.5.4.6", 19, (uint64_t)"US", 2)
      || AMFDREncodeCertificateRequestAddSubject((uint64_t)v131, "2.5.4.10", 12, (uint64_t)"Apple Inc.", 10))
    {
      goto LABEL_74;
    }
    v45 = (const __CFString *)_CFDictionaryCopyValue(*((const __CFDictionary **)v11 + 2), CFSTR("OrganizationalUnit"));
    if (!v45)
    {
      v56 = (_QWORD *)*((_QWORD *)v11 + 17);
      if (*v56 < 0x71uLL
        || (v57 = (uint64_t (*)(CFDataRef, _QWORD))v56[14]) == 0
        || (v45 = (const __CFString *)v57(v11, *((_QWORD *)v11 + 18))) == 0)
      {
LABEL_73:
        AMSupportLogInternal();
LABEL_74:
        v44 = 0;
LABEL_131:
        v95 = v131;
        goto LABEL_132;
      }
    }
    v46 = CFGetTypeID(v45);
    if (v46 != CFStringGetTypeID())
    {
      AMSupportLogInternal();
      CFRelease(v45);
      goto LABEL_74;
    }
    v47 = CFGetAllocator(v11);
    ExternalRepresentation = CFStringCreateExternalRepresentation(v47, v45, 0x8000100u, 0x20u);
    v44 = ExternalRepresentation;
    if (!ExternalRepresentation)
    {
      AMSupportLogInternal();
      CFRelease(v45);
      goto LABEL_131;
    }
    BytePtr = CFDataGetBytePtr(ExternalRepresentation);
    v50 = CFDataGetLength(v44);
    v120 = v7;
    cfa = v44;
    v116 = a6;
    v118 = v10;
    if (!AMFDREncodeCertificateRequestAddSubject((uint64_t)v131, "2.5.4.11", 12, (uint64_t)BytePtr, v50))
    {
      if (!a3)
      {
        v111 = 0;
        goto LABEL_76;
      }
      v51 = CFGetAllocator(v11);
      v52 = CFStringCreateExternalRepresentation(v51, a3, 0x8000100u, 0x20u);
      if (v52)
      {
        v53 = v52;
        v54 = CFDataGetBytePtr(v52);
        v111 = v53;
        v55 = CFDataGetLength(v53);
        if (AMFDREncodeCertificateRequestAddAttribute((uint64_t)v131, "1.2.840.113635.100.6.16", 0, (uint64_t)v54, v55, 0))
        {
          v44 = 0;
          v113 = 0;
LABEL_209:
          v62 = 0;
          goto LABEL_210;
        }
LABEL_76:
        v58 = (_QWORD *)*((_QWORD *)v11 + 17);
        if (*v58 >= 0x59uLL && (v59 = (uint64_t (*)(CFDataRef, _QWORD))v58[11]) != 0)
          v60 = v59(v11, *((_QWORD *)v11 + 18));
        else
          v60 = 0;
        v113 = (CFTypeRef)v60;
        if (v130 != 2 || (*(_BYTE *)(*((_QWORD *)v11 + 17) + 8) & 2) != 0)
          SikInstanceStringInternal = AMSupportSafeRetain();
        else
          SikInstanceStringInternal = (uint64_t)AMFDRDataCreateSikInstanceStringInternal((__CFString *)v11, 0, v60);
        v62 = (const __CFString *)SikInstanceStringInternal;
        if (!SikInstanceStringInternal)
        {
          AMSupportLogInternal();
          v44 = 0;
LABEL_210:
          v65 = 0;
          goto LABEL_211;
        }
        v63 = CFGetAllocator(v11);
        v64 = CFStringCreateExternalRepresentation(v63, v62, 0x8000100u, 0x20u);
        v65 = v64;
        if (v64)
        {
          v66 = CFDataGetBytePtr(v64);
          v67 = CFDataGetLength(v65);
          if (!AMFDREncodeCertificateRequestAddAttribute((uint64_t)v131, "1.2.840.113635.100.6.17", 0, (uint64_t)v66, v67, 0))
          {
            v68 = (const __CFString *)_CFDictionaryCopyValue(*((const __CFDictionary **)v11 + 2), CFSTR("CertifyCustomCommonName"));
            v69 = v68;
            if (v68)
            {
              v70 = CFGetTypeID(v68);
              if (v70 != CFStringGetTypeID())
              {
                AMSupportLogInternal();
                v44 = 0;
                v94 = 0;
                goto LABEL_212;
              }
              v71 = CFGetAllocator(v11);
              v72 = CFStringCreateExternalRepresentation(v71, v69, 0x8000100u, 0x20u);
              v73 = v72;
              if (!v72)
              {
                AMSupportLogInternal();
LABEL_216:
                v44 = 0;
                v94 = 0;
                goto LABEL_213;
              }
              v74 = CFDataGetBytePtr(v72);
              v75 = CFDataGetLength(v73);
              if (AMFDREncodeCertificateRequestAddSubject((uint64_t)v131, "2.5.4.3", 12, (uint64_t)v74, v75))goto LABEL_216;
            }
            else
            {
              v76 = CFDataGetBytePtr(v65);
              v77 = CFDataGetLength(v65);
              v73 = 0;
              if (AMFDREncodeCertificateRequestAddSubject((uint64_t)v131, "2.5.4.3", 12, (uint64_t)v76, v77))
              {
                v44 = 0;
                v94 = 0;
                v69 = 0;
                v83 = 0;
                v79 = 0;
                goto LABEL_112;
              }
            }
            v78 = (const __CFString *)_CFDictionaryCopyValue(*((const __CFDictionary **)v11 + 2), CFSTR("CertifyClassFKey"));
            v79 = v78;
            if (v78)
            {
              v80 = CFGetTypeID(v78);
              if (v80 != CFStringGetTypeID())
              {
                AMSupportLogInternal();
                v44 = 0;
                v94 = 0;
                v83 = 0;
                goto LABEL_112;
              }
              v81 = CFGetAllocator(v11);
              v82 = CFStringCreateExternalRepresentation(v81, v79, 0x8000100u, 0x20u);
              v83 = v82;
              if (!v82)
              {
                AMSupportLogInternal();
LABEL_219:
                v44 = 0;
                v94 = 0;
                goto LABEL_112;
              }
              v84 = CFDataGetBytePtr(v82);
              v85 = CFDataGetLength(v83);
              if (AMFDREncodeCertificateRequestAddAttribute((uint64_t)v131, "1.2.840.113635.100.6.74.4", 0, (uint64_t)v84, v85, 0))goto LABEL_219;
            }
            else
            {
              v83 = 0;
            }
            if (v130 != 1 || (*(_BYTE *)(*((_QWORD *)v11 + 17) + 8) & 1) != 0)
            {
              v94 = 0;
              goto LABEL_111;
            }
            v150 = 0xAAAAAAAAAAAAAAAALL;
            *(_QWORD *)&v86 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v86 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v148 = v86;
            v149 = v86;
            v146 = v86;
            v147 = v86;
            v144 = v86;
            v145 = v86;
            v142 = v86;
            v143 = v86;
            v140 = v86;
            v141 = v86;
            v138 = v86;
            v139 = v86;
            v137[14] = v86;
            v137[15] = v86;
            v137[12] = v86;
            v137[13] = v86;
            v137[10] = v86;
            v137[11] = v86;
            v137[8] = v86;
            v137[9] = v86;
            v137[6] = v86;
            v137[7] = v86;
            v137[4] = v86;
            v137[5] = v86;
            v137[2] = v86;
            v137[3] = v86;
            v137[0] = v86;
            v137[1] = v86;
            memset((char *)&v131[1] + 4, 0, 12);
            v87 = (const __CFDictionary *)*((_QWORD *)v11 + 2);
            if (!v87)
              goto LABEL_224;
            Value = (const __CFData *)CFDictionaryGetValue(v87, CFSTR("APTicket"));
            if (!Value)
              goto LABEL_224;
            v89 = Value;
            CFDataGetBytePtr(Value);
            CFDataGetLength(v89);
            if (Img4DecodeInitManifest())
              goto LABEL_224;
            v90 = (void *)*((_QWORD *)&v138 + 1);
            if (!*((_QWORD *)&v138 + 1) || !(_QWORD)v139)
              goto LABEL_224;
            v136 = 0;
            v135 = 1295273289;
            values = 0;
            memset(v133, 170, sizeof(v133));
            memset(keys, 170, sizeof(keys));
            v91 = v139;
            if (!(_DWORD)v139)
            {
              v93 = 101;
              goto LABEL_187;
            }
            if (DEREncoderCreate())
            {
              v92 = DEREncoderAddDataNoCopy();
              if (v92)
              {
                v93 = v92;
                goto LABEL_186;
              }
              v104 = DEREncoderAddUInt32();
              if (v104)
              {
                v93 = v104;
                goto LABEL_186;
              }
              keys[2] = v90;
              keys[3] = (void *)v91;
              memset(v133, 0, sizeof(v133));
              if (DERDecodeSeqContentInit((unint64_t *)&keys[2], (unint64_t *)keys))
              {
                v93 = 103;
                goto LABEL_186;
              }
              if (DERDecodeSeqNext((unint64_t *)keys, (unint64_t *)v133))
              {
                v93 = 103;
                goto LABEL_186;
              }
              v105 = DEREncoderAddDataNoCopy();
              if (v105)
              {
                v93 = v105;
                goto LABEL_186;
              }
              EncodedBuffer = DEREncoderCreateEncodedBuffer();
              if (EncodedBuffer)
              {
                v93 = EncodedBuffer;
                goto LABEL_186;
              }
              if (DEREncoderCreate())
              {
                v109 = DEREncoderAddDataNoCopy();
                if (v109)
                {
                  v93 = v109;
                }
                else
                {
                  v110 = DEREncoderCreateEncodedBuffer();
                  if (!v110)
                  {
                    v93 = 100;
LABEL_187:
                    DEREncoderDestroy();
                    DEREncoderDestroy();
                    if (values)
                      free(values);
                    if (v93 == 100 && v131[2] && HIDWORD(v131[1]))
                    {
                      v94 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], (const UInt8 *)v131[2], HIDWORD(v131[1]));
                      if (!v94)
                        AMSupportLogInternal();
LABEL_194:
                      if (v131[2])
                        free((void *)v131[2]);
                      if (v94)
                      {
                        AMSupportLogInternal();
                        v107 = CFDataGetBytePtr(v94);
                        v108 = CFDataGetLength(v94);
                        if (AMFDREncodeCertificateRequestAddAttribute((uint64_t)v131, "1.2.840.113635.100.6.8", 1, (uint64_t)v107, v108, 0))
                        {
                          v44 = 0;
                          goto LABEL_112;
                        }
                      }
                      else
                      {
                        AMSupportLogInternal();
                      }
LABEL_111:
                      v44 = (const __CFData *)v131[0];
                      v131[0] = 0;
LABEL_112:
                      CFRelease(v45);
                      CFRelease(cfa);
                      if (v111)
                        CFRelease(v111);
                      if (v65)
                        CFRelease(v65);
                      if (v94)
                        CFRelease(v94);
                      if (v62)
                        CFRelease(v62);
                      v7 = v120;
                      if (v113)
                        CFRelease(v113);
                      v10 = v118;
                      if (v73)
                        CFRelease(v73);
                      if (v69)
                        CFRelease(v69);
                      if (v79)
                        CFRelease(v79);
                      a6 = v116;
                      if (v83)
                        CFRelease(v83);
                      v8 = a4;
                      goto LABEL_131;
                    }
LABEL_224:
                    AMSupportLogInternal();
                    v94 = 0;
                    goto LABEL_194;
                  }
                  v93 = v110;
                }
LABEL_186:
                AMSupportLogInternal();
                goto LABEL_187;
              }
            }
            v93 = 2;
            goto LABEL_186;
          }
        }
        else
        {
          AMSupportLogInternal();
        }
        v44 = 0;
LABEL_211:
        v94 = 0;
        v69 = 0;
LABEL_212:
        v73 = 0;
LABEL_213:
        v83 = 0;
        v79 = 0;
        goto LABEL_112;
      }
      AMSupportLogInternal();
    }
    v44 = 0;
    v111 = 0;
    v113 = 0;
    goto LABEL_209;
  }
  v117 = v10;
  v119 = v7;
  AMSupportLogInternal();
  *(_QWORD *)&v137[0] = 0;
  v133[0] = 0;
  keys[2] = 0;
  if (AMFDREncodeCertificateRequestBegin((uint64_t)v137))
  {
    v44 = 0;
    goto LABEL_158;
  }
  v20 = 0;
  v21 = 0;
  v22 = 1;
  v112 = v18;
  while (1)
  {
    v23 = v22;
    v24 = off_24C69F490[v20];
    v25 = (const __CFArray *)CFDictionaryGetValue(v18, v24);
    cf = v23;
    if (v25)
    {
      v26 = v25;
      v27 = CFGetTypeID(v25);
      if (v27 != CFArrayGetTypeID())
      {
        AMSupportLogInternal();
        v44 = 0;
        goto LABEL_156;
      }
      if (CFArrayGetCount(v26) >= 1)
        break;
    }
LABEL_56:
    v22 = 0;
    v20 = 1;
    v8 = a4;
    v18 = v112;
    if ((cf & 1) == 0)
    {
      v44 = *(const __CFData **)&v137[0];
      *(_QWORD *)&v137[0] = 0;
      goto LABEL_156;
    }
  }
  v28 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v26, v28);
    keys[0] = 0;
    values = 0;
    if (v133[0])
    {
      free(v133[0]);
      v133[0] = 0;
    }
    if (v21)
      CFRelease(v21);
    if (!ValueAtIndex
      || (v30 = CFGetTypeID(ValueAtIndex), v30 != CFDictionaryGetTypeID())
      || CFDictionaryGetCount((CFDictionaryRef)ValueAtIndex) != 1
      || (CFDictionaryGetKeysAndValues((CFDictionaryRef)ValueAtIndex, (const void **)keys, (const void **)&values),
          !keys[0])
      || (v31 = CFGetTypeID(keys[0]), v31 != CFStringGetTypeID())
      || AMSupportCreateCStringFromCFString()
      || !keys[2]
      || ((v32 = *(unsigned __int8 *)v133[0], v32 == 33) ? (v33 = (char *)v133[0] + 1) : (v33 = (char *)v133[0]), !values))
    {
LABEL_154:
      AMSupportLogInternal();
      v21 = 0;
      goto LABEL_155;
    }
    v34 = CFGetTypeID(values);
    TypeID = CFDataGetTypeID();
    if (v34 == TypeID)
    {
      v21 = CFRetain(values);
      goto LABEL_50;
    }
    v36 = CFGetTypeID(values);
    if (v36 != CFStringGetTypeID())
      goto LABEL_154;
    v37 = CFGetAllocator(v11);
    v21 = CFStringCreateExternalRepresentation(v37, (CFStringRef)values, 0x8000100u, 0x20u);
    if (!v21)
      break;
LABEL_50:
    if (CFStringCompare(v24, CFSTR("Subjects"), 0))
    {
      if (CFStringCompare(v24, CFSTR("Attributes"), 0) == kCFCompareEqualTo)
      {
        v38 = v34 == TypeID;
        v39 = v32 == 33;
        v40 = CFDataGetBytePtr((CFDataRef)v21);
        v41 = CFDataGetLength((CFDataRef)v21);
        if (AMFDREncodeCertificateRequestAddAttribute((uint64_t)v137, v33, v38, (uint64_t)v40, v41, v39))
          break;
      }
    }
    else
    {
      v42 = CFDataGetBytePtr((CFDataRef)v21);
      v43 = CFDataGetLength((CFDataRef)v21);
      if (AMFDREncodeCertificateRequestAddSubject((uint64_t)v137, v33, 12, (uint64_t)v42, v43))
        goto LABEL_155;
    }
    if (CFArrayGetCount(v26) <= ++v28)
      goto LABEL_56;
  }
  AMSupportLogInternal();
LABEL_155:
  v44 = 0;
  v8 = a4;
LABEL_156:
  if (v21)
    CFRelease(v21);
LABEL_158:
  v7 = v119;
  v10 = v117;
  if (v133[0])
  {
    free(v133[0]);
    v133[0] = 0;
  }
  v95 = v137;
LABEL_132:
  AMFDREncodeMultiRequestDestroy((uint64_t)v95);
  v126 = v44;
  if (!v44)
    goto LABEL_151;
  v96 = CFDataGetBytePtr(v8);
  v97 = CFDataGetLength(v8);
  if (AMFDREncodeCertificateRequestCreateUnsginedData((uint64_t)&v126, v96, v97, v123, v124, &length[1], length))
  {
LABEL_152:
    v99 = 0;
    goto LABEL_153;
  }
  v98 = CFGetAllocator(v11);
  v99 = CFDataCreateWithBytesNoCopy(v98, *(const UInt8 **)&length[1], length[0], (CFAllocatorRef)*MEMORY[0x24BDBD258]);
  if (!v99 || (v7(v10, v99, &theData, a6) & 1) == 0)
  {
    AMSupportLogInternal();
    goto LABEL_153;
  }
  v100 = CFDataGetBytePtr(theData);
  v101 = CFDataGetLength(theData);
  if (AMFDREncodeCertificateRequestEnd((uint64_t)&v126, v100, v101, v121, 0, v122, &v128[1], v128))
  {
LABEL_153:
    v11 = 0;
    goto LABEL_139;
  }
  v102 = CFGetAllocator(v11);
  v11 = CFDataCreateWithBytesNoCopy(v102, *(const UInt8 **)&v128[1], v128[0], (CFAllocatorRef)*MEMORY[0x24BDBD248]);
  if (v11)
    *(_QWORD *)&v128[1] = 0;
  else
    AMSupportLogInternal();
LABEL_139:
  if (*(_QWORD *)&length[1])
  {
    free(*(void **)&length[1]);
    *(_QWORD *)&length[1] = 0;
  }
  if (*(_QWORD *)&v128[1])
  {
    free(*(void **)&v128[1]);
    *(_QWORD *)&v128[1] = 0;
  }
  if (theData)
  {
    CFRelease(theData);
    theData = 0;
  }
  if (v99)
    CFRelease(v99);
  AMFDREncodeMultiRequestDestroy((uint64_t)&v126);
  return v11;
}

CFDataRef AMFDRCryptoCreateModuleSignedCsr(__CFString *a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4, uint64_t a5)
{
  __int128 v10;
  char v11;
  const char *v12;
  const char *v13;
  const char *v14;
  const __CFAllocator *v15;
  const __CFData *ExternalRepresentation;
  const __CFData *v17;
  const UInt8 *BytePtr;
  int Length;
  const __CFDictionary *data;
  const __CFBoolean *Value;
  const __CFBoolean *v22;
  CFTypeID v23;
  const void *v24;
  const __CFString *v25;
  _QWORD *info;
  uint64_t (*v27)(__CFString *, char *);
  uint64_t SikInstanceStringInternal;
  const __CFAllocator *v29;
  const __CFData *v30;
  const __CFData *v31;
  const UInt8 *v32;
  int v33;
  const __CFAllocator *v34;
  const __CFData *v35;
  const UInt8 *v36;
  int v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFAllocator *v40;
  const __CFData *v41;
  const __CFData *v42;
  const UInt8 *v43;
  int v44;
  const __CFString *v45;
  const __CFString *v46;
  const __CFAllocator *v47;
  const __CFData *v48;
  const __CFData *v49;
  const UInt8 *v50;
  int v51;
  const void *v52;
  unint64_t v53;
  unint64_t v54;
  const void *v55;
  CFTypeID v56;
  CFIndex Count;
  _BOOL4 v58;
  const void *v59;
  __CFString *v60;
  CFTypeID v61;
  __CFDictionary *Mutable;
  __CFDictionary *v63;
  CFTypeID v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const __CFBoolean *v68;
  const __CFBoolean *v69;
  CFTypeID v70;
  const __CFString *v71;
  const __CFString *v72;
  CFTypeID v73;
  const __CFData *v74;
  CFDataRef v75;
  CFDataRef v76;
  CFTypeID v77;
  const __CFData *v78;
  const __CFString *v79;
  const __CFString *v80;
  CFTypeID v81;
  const __CFData *v82;
  const __CFData *v83;
  const void *v84;
  int v85;
  const __CFString *v86;
  const __CFString *v87;
  CFTypeID v88;
  const __CFData *v89;
  const __CFData *v90;
  const __CFData *v91;
  const __CFData *v92;
  CFTypeID v93;
  const __CFData *v94;
  const __CFData *v95;
  const __CFData *v96;
  uint64_t v97;
  const UInt8 *v98;
  unsigned int v99;
  const __CFAllocator *v100;
  const __CFBoolean *v101;
  const __CFBoolean *v102;
  __CFDictionary *v103;
  const __CFData *v104;
  const void *v105;
  const __CFData *v106;
  CFTypeID v107;
  CFDataRef v108;
  const __CFBoolean *v109;
  CFAllocatorRef *v110;
  const __CFBoolean *v111;
  CFTypeID v112;
  const UInt8 *v113;
  unsigned int v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  char *v118;
  char *v119;
  void *v120;
  const __CFData *v121;
  uint64_t v122;
  const UInt8 *v123;
  _BYTE *v124;
  char v125;
  const __CFData *v126;
  uint64_t v127;
  _BYTE *v128;
  const UInt8 *v129;
  char v130;
  uint64_t v131;
  const UInt8 *v132;
  _BYTE *v133;
  char v134;
  uint64_t v135;
  _BYTE *v136;
  const UInt8 *v137;
  char v138;
  const UInt8 *v139;
  unsigned int v140;
  const __CFAllocator *v141;
  const __CFData *v143;
  const __CFData *v144;
  const __CFData *cf;
  const __CFData *v146;
  uint64_t v147;
  uint64_t v148;
  int v149;
  __CFDictionary *v150;
  __CFDictionary *v151;
  char *v152;
  char v153;
  uint64_t v154;
  const void *v155;
  char *v156;
  const __CFData *v157;
  char *v158;
  CFDataRef v159;
  const __CFData *v160;
  const __CFData *v161;
  const __CFData *v162;
  const __CFData *v163;
  __CFString *v164;
  const __CFString *v165;
  int v166;
  uint64_t v167;
  int v168;
  void *v169;
  unsigned int v170;
  UInt8 *v171;
  unsigned int v172;
  UInt8 *v173;
  CFDataRef v174;
  UInt8 bytes[16];
  __int128 v176;
  uint64_t v177;

  v177 = *MEMORY[0x24BDAC8D0];
  v173 = 0;
  v174 = 0;
  v172 = 0;
  v171 = 0;
  v170 = 0;
  v169 = 0;
  v168 = 0;
  v167 = 0;
  v166 = 2;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)bytes = v10;
  v176 = v10;
  if ((int)a2 > 1025)
  {
    if ((_DWORD)a2 == 1026)
    {
      v11 = 1;
      v12 = "1.2.840.10045.4.3.3";
      v13 = "1.3.132.0.34";
LABEL_16:
      v14 = "1.2.840.10045.2.1";
      if (!a1)
        goto LABEL_89;
      goto LABEL_17;
    }
    if ((_DWORD)a2 != 66050)
    {
      if ((_DWORD)a2 != 67586)
      {
LABEL_89:
        AMSupportLogInternal();
LABEL_90:
        v24 = 0;
        v75 = 0;
        v17 = 0;
LABEL_91:
        v162 = 0;
        v163 = 0;
        v160 = 0;
        v161 = 0;
        v159 = 0;
        v76 = 0;
        v63 = 0;
        v25 = 0;
        goto LABEL_205;
      }
      v11 = 1;
      v12 = "1.2.840.10045.4.3.2";
      v13 = "1.3.132.0.33";
      goto LABEL_16;
    }
LABEL_10:
    v11 = 1;
    v12 = "1.2.840.10045.4.3.2";
    v13 = "1.2.840.10045.3.1.7";
    goto LABEL_16;
  }
  switch((_DWORD)a2)
  {
    case 0x101:
      v13 = 0;
      v11 = 0;
      v12 = "1.2.840.113549.1.1.5";
      break;
    case 0x201:
      v13 = 0;
      v11 = 0;
      v12 = "1.2.840.113549.1.1.11";
      break;
    case 0x202:
      goto LABEL_10;
    default:
      goto LABEL_89;
  }
  v14 = "1.2.840.113549.1.1.1";
  if (!a1)
    goto LABEL_89;
LABEL_17:
  if (!*(_QWORD *)a3
    || !*(_QWORD *)(a3 + 16)
    || !*(_QWORD *)(a3 + 24)
    || !*(_QWORD *)(a3 + 8)
    || (AMFDRDataGetSigningVersion((uint64_t)a1, &v166) & 1) == 0)
  {
    goto LABEL_89;
  }
  if (AMFDREncodeCertificateRequestBegin((uint64_t)&v167)
    || AMFDREncodeCertificateRequestAddSubject((uint64_t)&v167, "2.5.4.6", 19, (uint64_t)"US", 2)
    || AMFDREncodeCertificateRequestAddSubject((uint64_t)&v167, "2.5.4.10", 12, (uint64_t)"Apple Inc.", 10))
  {
    goto LABEL_90;
  }
  v158 = (char *)v14;
  v15 = CFGetAllocator(a1);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v15, *(CFStringRef *)(a3 + 8), 0x8000100u, 0x20u);
  v17 = ExternalRepresentation;
  if (!ExternalRepresentation)
  {
    AMSupportLogInternal();
    goto LABEL_242;
  }
  v156 = (char *)v13;
  BytePtr = CFDataGetBytePtr(ExternalRepresentation);
  Length = CFDataGetLength(v17);
  if (AMFDREncodeCertificateRequestAddSubject((uint64_t)&v167, "2.5.4.11", 12, (uint64_t)BytePtr, Length))
  {
LABEL_242:
    v24 = 0;
    v75 = 0;
    goto LABEL_91;
  }
  v153 = v11;
  if (!a4 || (data = a4, CFDictionaryGetCount(a4) <= 0))
    data = (const __CFDictionary *)a1->data;
  Value = (const __CFBoolean *)CFDictionaryGetValue(data, CFSTR("CertifyNoClientID"));
  v152 = (char *)v12;
  v154 = a5;
  if (Value)
  {
    v22 = Value;
    v23 = CFGetTypeID(Value);
    if (v23 != CFBooleanGetTypeID() || CFBooleanGetValue(v22))
    {
      v24 = 0;
      v163 = 0;
      v25 = 0;
      goto LABEL_44;
    }
  }
  info = (_QWORD *)a1[4].info;
  if (*info >= 0x59uLL && (v27 = (uint64_t (*)(__CFString *, char *))info[11]) != 0)
    v24 = (const void *)v27(a1, a1[4].data);
  else
    v24 = 0;
  if (v166 == 2)
    SikInstanceStringInternal = (uint64_t)AMFDRDataCreateSikInstanceStringInternal(a1, 0, (uint64_t)v24);
  else
    SikInstanceStringInternal = AMSupportSafeRetain();
  v25 = (const __CFString *)SikInstanceStringInternal;
  if (!SikInstanceStringInternal
    || (v29 = CFGetAllocator(a1), (v30 = CFStringCreateExternalRepresentation(v29, v25, 0x8000100u, 0x20u)) == 0))
  {
    AMSupportLogInternal();
    v75 = 0;
    v163 = 0;
LABEL_269:
    v162 = 0;
    goto LABEL_270;
  }
  v31 = v30;
  v32 = CFDataGetBytePtr(v30);
  v163 = v31;
  v33 = CFDataGetLength(v31);
  if (AMFDREncodeCertificateRequestAddAttribute((uint64_t)&v167, "1.2.840.113635.100.6.17", 0, (uint64_t)v32, v33, 0))
  {
    v75 = 0;
    goto LABEL_269;
  }
LABEL_44:
  v34 = CFGetAllocator(a1);
  v35 = CFStringCreateExternalRepresentation(v34, *(CFStringRef *)a3, 0x8000100u, 0x20u);
  v36 = CFDataGetBytePtr(v35);
  v162 = v35;
  v37 = CFDataGetLength(v35);
  if (AMFDREncodeCertificateRequestAddSubject((uint64_t)&v167, "2.5.4.3", 12, (uint64_t)v36, v37))
  {
LABEL_250:
    v75 = 0;
LABEL_270:
    v161 = 0;
    goto LABEL_271;
  }
  v38 = (const __CFString *)CFDictionaryGetValue(data, CFSTR("CertifyComponentType"));
  if (!v38)
  {
    v161 = 0;
    goto LABEL_50;
  }
  v39 = v38;
  v40 = CFGetAllocator(a1);
  v41 = CFStringCreateExternalRepresentation(v40, v39, 0x8000100u, 0x20u);
  if (!v41)
  {
    AMSupportLogInternal();
    goto LABEL_250;
  }
  v42 = v41;
  v43 = CFDataGetBytePtr(v41);
  v161 = v42;
  v44 = CFDataGetLength(v42);
  if (AMFDREncodeCertificateRequestAddAttribute((uint64_t)&v167, "1.2.840.113635.100.11.1", 0, (uint64_t)v43, v44, 1))goto LABEL_252;
LABEL_50:
  v45 = (const __CFString *)CFDictionaryGetValue(data, CFSTR("CertifyPartNumber"));
  v164 = a1;
  if (v45)
  {
    v46 = v45;
    v47 = CFGetAllocator(a1);
    v48 = CFStringCreateExternalRepresentation(v47, v46, 0x8000100u, 0x20u);
    if (!v48)
    {
      AMSupportLogInternal();
LABEL_252:
      v75 = 0;
LABEL_271:
      v160 = 0;
      goto LABEL_272;
    }
    v49 = v48;
    v50 = CFDataGetBytePtr(v48);
    v160 = v49;
    v51 = CFDataGetLength(v49);
    if (AMFDREncodeCertificateRequestAddAttribute((uint64_t)&v167, "1.2.840.113635.100.11.2", 0, (uint64_t)v50, v51, 1))
    {
LABEL_244:
      v75 = 0;
LABEL_272:
      v159 = 0;
      v76 = 0;
      v63 = 0;
      goto LABEL_205;
    }
  }
  else
  {
    v160 = 0;
  }
  v52 = CFDictionaryGetValue(data, CFSTR("CertifyComponentAttributes"));
  v53 = (unint64_t)CFDictionaryGetValue(data, CFSTR("CertifyComponentAttributesCritical"));
  v54 = (unint64_t)CFDictionaryGetValue(a4, CFSTR("CertifyComponentAttributesCriticalProductionMode"));
  v55 = (const void *)v54;
  if (v53 && v54 || v52 && v53 | v54)
  {
    AMSupportLogInternal();
    goto LABEL_244;
  }
  v165 = v25;
  if (!v52 || (v56 = CFGetTypeID(v52), v56 != CFDictionaryGetTypeID()))
  {
    v60 = v164;
    if (!v55)
    {
LABEL_71:
      v58 = 1;
      v59 = (const void *)v53;
      goto LABEL_72;
    }
LABEL_68:
    v61 = CFGetTypeID(v55);
    if (v61 == CFBooleanGetTypeID())
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      v63 = Mutable;
      if (!Mutable)
      {
        AMSupportLogInternal();
        goto LABEL_274;
      }
      CFDictionarySetValue(Mutable, CFSTR("ComponentAttributeProductionMode"), v55);
      v58 = 1;
      v59 = v63;
      goto LABEL_73;
    }
    goto LABEL_71;
  }
  Count = CFDictionaryGetCount((CFDictionaryRef)v52);
  v58 = Count == 0;
  if (Count)
    v59 = v52;
  else
    v59 = (const void *)v53;
  if (Count)
  {
    v60 = v164;
    goto LABEL_72;
  }
  v60 = v164;
  if (v55)
    goto LABEL_68;
LABEL_72:
  v63 = 0;
  if (!v59)
    goto LABEL_145;
LABEL_73:
  v149 = v58;
  v64 = CFGetTypeID(v59);
  if (v64 == CFDictionaryGetTypeID() && CFDictionaryGetCount((CFDictionaryRef)v59) >= 1)
  {
    v65 = DEREncoderCreate();
    v66 = DEREncoderCreate();
    v150 = v63;
    v147 = v65;
    v148 = v66;
    v146 = v17;
    if (!v65 || !v66)
    {
      v84 = v24;
      AMSupportLogInternal();
      v143 = 0;
      v144 = 0;
      cf = 0;
      v67 = 0;
      v94 = 0;
      v95 = 0;
      v96 = 0;
      v97 = 0;
      v85 = 199;
      if (!v148)
      {
LABEL_132:
        if (v147)
          DEREncoderDestroy();
        v63 = v150;
        if (v97)
          DEREncoderDestroy();
        if (v96)
          CFRelease(v96);
        v24 = v84;
        if (v95)
          CFRelease(v95);
        v60 = v164;
        if (v94)
          CFRelease(v94);
        if (v85)
        {
          AMSupportLogInternal();
        }
        else if (!AMFDREncodeCertificateRequestAddAttribute((uint64_t)&v167, "1.2.840.113635.100.11.3", 1, (uint64_t)v169, v168, v149))
        {
          v17 = v146;
          goto LABEL_145;
        }
        v75 = 0;
        v159 = 0;
        v76 = 0;
        v17 = v146;
        goto LABEL_281;
      }
LABEL_131:
      DEREncoderDestroy();
      v94 = v143;
      v95 = v144;
      v96 = cf;
      v97 = v67;
      goto LABEL_132;
    }
    if (CFDictionaryContainsKey((CFDictionaryRef)v59, CFSTR("ComponentAttributeProductionMode")))
    {
      v67 = DEREncoderCreate();
      if (!v67)
        goto LABEL_276;
      v68 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v59, CFSTR("ComponentAttributeProductionMode"));
      if (!v68 || (v69 = v68, v70 = CFGetTypeID(v68), v70 != CFBooleanGetTypeID()))
      {
        v84 = v24;
        v143 = 0;
        v144 = 0;
        cf = 0;
        goto LABEL_109;
      }
      CFBooleanGetValue(v69);
      if (DEREncoderAddBoolean())
      {
        v84 = v24;
        v143 = 0;
        v144 = 0;
        cf = 0;
        goto LABEL_109;
      }
      if (DEREncoderAddDataFromEncoder())
      {
        v84 = v24;
        v143 = 0;
        v144 = 0;
        cf = 0;
        goto LABEL_109;
      }
      DEREncoderDestroy();
    }
    if (!CFDictionaryContainsKey((CFDictionaryRef)v59, CFSTR("ComponentAttributeBatteryPackIdentifier")))
    {
      cf = 0;
      goto LABEL_100;
    }
    v67 = DEREncoderCreate();
    if (v67)
    {
      v71 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v59, CFSTR("ComponentAttributeBatteryPackIdentifier"));
      if (v71)
      {
        v72 = v71;
        v73 = CFGetTypeID(v71);
        if (v73 == CFStringGetTypeID())
        {
          v74 = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x24BDBD240], v72, 0x8000100u, 0x20u);
LABEL_96:
          if (!v74)
          {
            v84 = v24;
            v143 = 0;
            v144 = 0;
            cf = 0;
            goto LABEL_109;
          }
          v78 = v74;
          CFDataGetBytePtr(v74);
          cf = v78;
          CFDataGetLength(v78);
          if (DEREncoderAddDataNoCopy())
          {
            v84 = v24;
            v143 = 0;
            v144 = 0;
            goto LABEL_109;
          }
          if (DEREncoderAddDataFromEncoder())
          {
            v84 = v24;
            v143 = 0;
            v144 = 0;
            goto LABEL_109;
          }
          DEREncoderDestroy();
LABEL_100:
          if (CFDictionaryContainsKey((CFDictionaryRef)v59, CFSTR("ComponentAttributeBoardType")))
          {
            v67 = DEREncoderCreate();
            if (!v67)
            {
              v84 = v24;
              v143 = 0;
              v144 = 0;
              goto LABEL_109;
            }
            v79 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v59, CFSTR("ComponentAttributeBoardType"));
            if (!v79 || (v80 = v79, v81 = CFGetTypeID(v79), v81 != CFStringGetTypeID()))
            {
              v84 = v24;
              v143 = 0;
              v144 = 0;
              goto LABEL_109;
            }
            v82 = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x24BDBD240], v80, 0x8000100u, 0x20u);
            if (!v82)
            {
              v84 = v24;
              v143 = 0;
              v144 = 0;
              goto LABEL_109;
            }
            v83 = v82;
            CFDataGetBytePtr(v82);
            v144 = v83;
            CFDataGetLength(v83);
            if (DEREncoderAddData())
            {
              v84 = v24;
              v143 = 0;
              goto LABEL_109;
            }
            if (DEREncoderAddDataFromEncoder())
            {
              v84 = v24;
              v143 = 0;
              goto LABEL_109;
            }
            DEREncoderDestroy();
          }
          else
          {
            v144 = 0;
          }
          if (CFDictionaryContainsKey((CFDictionaryRef)v59, CFSTR("ComponentAttributeSoCECID")))
          {
            v67 = DEREncoderCreate();
            if (!v67)
            {
              v84 = v24;
              v143 = 0;
              goto LABEL_109;
            }
            v86 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v59, CFSTR("ComponentAttributeSoCECID"));
            if (!v86 || (v87 = v86, v88 = CFGetTypeID(v86), v88 != CFStringGetTypeID()))
            {
              v84 = v24;
              v143 = 0;
              goto LABEL_109;
            }
            v89 = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x24BDBD240], v87, 0x8000100u, 0x20u);
            if (!v89)
            {
              v84 = v24;
              v143 = 0;
              goto LABEL_109;
            }
            v90 = v89;
            CFDataGetBytePtr(v89);
            v143 = v90;
            CFDataGetLength(v90);
            if (DEREncoderAddData())
            {
              v84 = v24;
              goto LABEL_109;
            }
            if (DEREncoderAddDataFromEncoder())
            {
              v84 = v24;
              goto LABEL_109;
            }
            DEREncoderDestroy();
          }
          else
          {
            v143 = 0;
          }
          if (CFDictionaryContainsKey((CFDictionaryRef)v59, CFSTR("ComponentAttributeSoCChipIDECID")))
          {
            v67 = DEREncoderCreate();
            if (!v67)
            {
              v84 = v24;
              goto LABEL_109;
            }
            v91 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v59, CFSTR("ComponentAttributeSoCChipIDECID"));
            if (!v91 || (v92 = v91, v93 = CFGetTypeID(v91), v93 != CFDataGetTypeID()))
            {
              v84 = v24;
              goto LABEL_109;
            }
            CFDataGetBytePtr(v92);
            CFDataGetLength(v92);
            if (DEREncoderAddDataNoCopy())
            {
              v84 = v24;
              goto LABEL_109;
            }
            if (DEREncoderAddDataFromEncoder())
            {
              v84 = v24;
              goto LABEL_109;
            }
          }
          else
          {
            v67 = 0;
          }
          v84 = v24;
          if (!DEREncoderAddSequenceFromEncoder() && !DEREncoderCreateEncodedBuffer())
          {
            v85 = 0;
            goto LABEL_131;
          }
          goto LABEL_109;
        }
        v77 = CFGetTypeID(v72);
        if (v77 == CFDataGetTypeID())
        {
          v74 = (const __CFData *)AMSupportSafeRetain();
          goto LABEL_96;
        }
      }
      v84 = v24;
      v143 = 0;
      v144 = 0;
      cf = 0;
LABEL_109:
      AMSupportLogInternal();
      v85 = 199;
      goto LABEL_131;
    }
LABEL_276:
    v84 = v24;
    v143 = 0;
    v144 = 0;
    cf = 0;
    goto LABEL_109;
  }
LABEL_145:
  v98 = CFDataGetBytePtr(*(CFDataRef *)(a3 + 16));
  v99 = CFDataGetLength(*(CFDataRef *)(a3 + 16));
  if (AMFDREncodeCertificateRequestCreateUnsginedData((uint64_t)&v167, v98, v99, v158, v156, &v171, &v170))
  {
LABEL_274:
    v75 = 0;
    v159 = 0;
    v76 = 0;
    goto LABEL_281;
  }
  v100 = CFGetAllocator(v60);
  v76 = CFDataCreateWithBytesNoCopy(v100, v171, v170, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
  v25 = v165;
  if (!v76)
  {
    AMSupportLogInternal();
    v75 = 0;
    v159 = 0;
    goto LABEL_205;
  }
  v101 = (const __CFBoolean *)CFDictionaryGetValue(data, CFSTR("CertifyChallengeSupport128b"));
  if (v101)
  {
    v102 = v101;
    v103 = v63;
    v104 = v17;
    v105 = v24;
    v106 = v76;
    v107 = CFGetTypeID(v101);
    if (v107 == CFBooleanGetTypeID() && CFBooleanGetValue(v102))
    {
      v76 = v106;
      CFDataGetBytePtr(v106);
      CFDataGetLength(v106);
      if (!AMSupportDigestSha256())
      {
        v108 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], bytes, 16);
        v159 = v108;
        v24 = v105;
        v17 = v104;
        v63 = v103;
        v25 = v165;
        goto LABEL_153;
      }
      AMSupportLogInternal();
      v75 = 0;
      v159 = 0;
    }
    else
    {
      AMSupportLogInternal();
      v75 = 0;
      v159 = 0;
      v76 = v106;
    }
    v24 = v105;
    v17 = v104;
    v63 = v103;
LABEL_281:
    v25 = v165;
    goto LABEL_205;
  }
  v159 = 0;
  v108 = v76;
LABEL_153:
  if (((*(uint64_t (**)(uint64_t, CFDataRef, CFDataRef *, uint64_t))(a3 + 24))(a2, v108, &v174, v154) & 1) == 0
    || !v174)
  {
LABEL_258:
    AMSupportLogInternal();
LABEL_259:
    v75 = 0;
    goto LABEL_205;
  }
  v109 = (const __CFBoolean *)CFDictionaryGetValue(data, CFSTR("CertifyRawECDSASignature"));
  v110 = (CFAllocatorRef *)MEMORY[0x24BDBD248];
  if (v109)
  {
    v111 = v109;
    v112 = CFGetTypeID(v109);
    if (v112 == CFBooleanGetTypeID() && CFBooleanGetValue(v111))
    {
      v155 = v24;
      v113 = CFDataGetBytePtr(v174);
      v114 = CFDataGetLength(v174);
      v115 = DEREncoderCreate();
      v157 = v76;
      if (v115)
      {
        v116 = DEREncoderCreate();
        if (v116)
        {
          v151 = v63;
          v117 = (unint64_t)v114 >> 1;
          v118 = (char *)malloc_type_calloc(1uLL, (v117 + 1), 0x100004077774924uLL);
          v119 = (char *)malloc_type_calloc(1uLL, (v117 + 1), 0x100004077774924uLL);
          v120 = v119;
          if (*(char *)v113 < 0)
          {
            v121 = v17;
            if (v114 >= 2)
            {
              if (v117 <= 1)
                v127 = 1;
              else
                v127 = v117;
              v128 = v118 + 1;
              v129 = v113;
              do
              {
                v130 = *v129++;
                *v128++ = v130;
                --v127;
              }
              while (v127);
            }
          }
          else
          {
            v121 = v17;
            if (v114 >= 2)
            {
              if (v117 <= 1)
                v122 = 1;
              else
                v122 = v117;
              v123 = v113;
              v124 = v118;
              do
              {
                v125 = *v123++;
                *v124++ = v125;
                --v122;
              }
              while (v122);
            }
          }
          if ((char)v113[v117] < 0)
          {
            if (v114 >= 2)
            {
              if (v117 <= 1)
                v135 = 1;
              else
                v135 = v117;
              v136 = v119 + 1;
              v137 = &v113[v117];
              do
              {
                v138 = *v137++;
                *v136++ = v138;
                --v135;
              }
              while (v135);
            }
          }
          else if (v114 >= 2)
          {
            if (v117 <= 1)
              v131 = 1;
            else
              v131 = v117;
            v132 = &v113[v117];
            v133 = v119;
            do
            {
              v134 = *v132++;
              *v133++ = v134;
              --v131;
            }
            while (v131);
          }
          if (DEREncoderAddData())
          {
            v17 = v121;
            v24 = v155;
          }
          else
          {
            v24 = v155;
            if (!DEREncoderAddData())
            {
              v17 = v121;
              v25 = v165;
              if (!DEREncoderAddSequenceFromEncoder())
              {
                v63 = v151;
                if (!DEREncoderCreateEncodedBuffer())
                  goto LABEL_265;
                goto LABEL_264;
              }
              goto LABEL_263;
            }
            v17 = v121;
          }
          v25 = v165;
LABEL_263:
          v63 = v151;
          goto LABEL_264;
        }
        v118 = 0;
        v120 = 0;
      }
      else
      {
        v118 = 0;
        v120 = 0;
        v116 = 0;
      }
      v24 = v155;
LABEL_264:
      AMSupportLogInternal();
LABEL_265:
      AMSupportLogInternal();
      if (v115)
        DEREncoderDestroy();
      if (v116)
        DEREncoderDestroy();
      if (v118)
        free(v118);
      if (v120)
        free(v120);
      AMSupportLogInternal();
      v76 = v157;
      goto LABEL_259;
    }
    goto LABEL_258;
  }
  v126 = v174;
  v139 = CFDataGetBytePtr(v174);
  v140 = CFDataGetLength(v126);
  if (AMFDREncodeCertificateRequestEnd((uint64_t)&v167, v139, v140, v152, 0, v153, &v173, &v172))
    goto LABEL_259;
  v141 = CFGetAllocator(v60);
  v75 = CFDataCreateWithBytesNoCopy(v141, v173, v172, *v110);
  if (v75)
    v173 = 0;
  else
    AMSupportLogInternal();
LABEL_205:
  if (v171)
  {
    free(v171);
    v171 = 0;
  }
  if (v173)
  {
    free(v173);
    v173 = 0;
  }
  if (v169)
  {
    free(v169);
    v169 = 0;
  }
  if (v174)
  {
    CFRelease(v174);
    v174 = 0;
  }
  if (v76)
    CFRelease(v76);
  if (v17)
    CFRelease(v17);
  if (v163)
    CFRelease(v163);
  if (v25)
    CFRelease(v25);
  if (v24)
    CFRelease(v24);
  if (v162)
    CFRelease(v162);
  if (v161)
    CFRelease(v161);
  if (v160)
    CFRelease(v160);
  if (v159)
    CFRelease(v159);
  if (v63)
    CFRelease(v63);
  AMFDREncodeMultiRequestDestroy((uint64_t)&v167);
  return v75;
}

uint64_t AMFDRCryptoCreateCsrSignature(int a1, CFDataRef theData, uint64_t a3, const void *a4)
{
  uint64_t v4;
  const UInt8 *BytePtr;
  CFIndex v9;
  CFDataRef v10;
  CFIndex length;
  UInt8 *bytes;

  length = 0;
  bytes = 0;
  if (!theData)
  {
    AMSupportLogInternal();
LABEL_8:
    v4 = 0;
    goto LABEL_6;
  }
  v4 = a3;
  if (!a3)
  {
    AMSupportLogInternal();
    goto LABEL_6;
  }
  BytePtr = CFDataGetBytePtr(theData);
  v9 = CFDataGetLength(theData);
  if (AMFDRCryptoCreateDataSignature(a1, (uint64_t)BytePtr, v9, (void **)&bytes, &length, a4) != 100)
    goto LABEL_8;
  v10 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], bytes, length, (CFAllocatorRef)*MEMORY[0x24BDBD248]);
  *(_QWORD *)v4 = v10;
  if (v10)
  {
    bytes = 0;
    v4 = 1;
  }
  else
  {
    AMSupportLogInternal();
    v4 = 0;
  }
LABEL_6:
  AMSupportSafeFree();
  return v4;
}

uint64_t AMFDRCryptoGetSikPub(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(uint64_t, _QWORD);

  if (a1
    && (v1 = *(_QWORD *)(a1 + 136), (*(_BYTE *)(v1 + 8) & 2) == 0)
    && *(_QWORD *)v1 >= 0x49uLL
    && (v2 = *(uint64_t (**)(uint64_t, _QWORD))(v1 + 72)) != 0)
  {
    return v2(a1, *(_QWORD *)(a1 + 144));
  }
  else
  {
    return 0;
  }
}

uint64_t AMFDRPlatformSetImplementation(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  void (*v7)(void);
  _QWORD *v8;
  uint64_t (*v9)(uint64_t);

  if (a1 && (!a2 || *a2))
  {
    v6 = *(_QWORD *)(a1 + 136);
    if (v6)
    {
      v7 = *(void (**)(void))(v6 + 24);
      if (v7)
      {
        if (*(_QWORD *)(a1 + 144))
        {
          v7();
          *(_QWORD *)(a1 + 144) = 0;
        }
      }
    }
    v8 = &kAMFDRPlatformImplementationNative;
    if (a2)
      v8 = a2;
    *(_QWORD *)(a1 + 136) = v8;
    v9 = (uint64_t (*)(uint64_t))v8[2];
    if (v9)
      a3 = v9(a3);
    *(_QWORD *)(a1 + 144) = a3;
    return 1;
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
}

_QWORD *_AMFDRPlatformDefaultRetain(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = malloc_type_calloc(1uLL, 0x10uLL, 0xE0040CF218873uLL);
  v3 = v2;
  if (a1 && v2)
  {
    *v2 = AMSupportSafeRetain();
    v3[1] = AMSupportSafeRetain();
  }
  return v3;
}

void _AMFDRPlatformDefaultRelease(void *a1)
{
  if (a1)
  {
    AMSupportSafeRelease();
    AMSupportSafeRelease();
    free(a1);
  }
  else
  {
    AMSupportLogInternal();
  }
}

uint64_t _AMFDRPlatformDefaultCopyProductTypeNative()
{
  if (_AMFDRPlatformDefaultCopyProductTypeNative_onceToken != -1)
    dispatch_once(&_AMFDRPlatformDefaultCopyProductTypeNative_onceToken, &__block_literal_global_3);
  return AMSupportSafeRetain();
}

CFTypeRef _AMFDRPlatformDefaultCopyRefKeyPub(const __CFDictionary **a1, uint64_t a2)
{
  uint64_t v2;
  const void *PublicKey;

  v2 = _AMFDRPlatformDefaultCopyRefKey(a1, a2);
  if (v2)
  {
    PublicKey = (const void *)AMFDRDeviceRefKeyGetPublicKey(v2);
    if (PublicKey)
      return CFRetain(PublicKey);
  }
  AMSupportLogInternal();
  return 0;
}

CFTypeRef _AMFDRPlatformDefaultCopyRefKeyAttest(const __CFDictionary **a1, uint64_t a2)
{
  uint64_t v2;

  v2 = _AMFDRPlatformDefaultCopyRefKey(a1, a2);
  if (v2)
    return AMFDRDeviceRefKeyCopyAttestation(v2);
  AMSupportLogInternal();
  return 0;
}

uint64_t _AMFDRPlatformDefaultRefKeySign(const __CFDictionary **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;

  v10 = _AMFDRPlatformDefaultCopyRefKey(a1, a6);
  if (v10)
    return AMFDRDeviceRefKeySign(v10, a2, a3, a4, a5);
  AMSupportLogInternal();
  return 199;
}

uint64_t _AMFDRPlatformDefaultHMACSign(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  if (a2 && a4 && a5)
  {
    result = aks_fdr_hmac_data();
    if ((_DWORD)result)
    {
      AMSupportLogInternal();
      return 6;
    }
  }
  else
  {
    AMSupportLogInternal();
    return 1;
  }
  return result;
}

uint64_t _AMFDRPlatformDefaultGetSikPub(uint64_t a1)
{
  _QWORD block[5];

  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___AMFDRPlatformDefaultGetSikPub_block_invoke;
  block[3] = &__block_descriptor_tmp_17;
  block[4] = a1;
  if (_AMFDRPlatformDefaultGetSikPub_onceToken != -1)
    dispatch_once(&_AMFDRPlatformDefaultGetSikPub_onceToken, block);
  return _AMFDRPlatformDefaultGetSikPub_key;
}

uint64_t _AMFDRPlatformDefaultCopyDeviceKeys(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t v6;

  if (a4)
  {
    result = AMFDRCopyDeviceKeys(*MEMORY[0x24BDE9080], a2, a3);
    if (!(_DWORD)result)
    {
      AMSupportSafeRelease();
      v6 = AMSupportSafeRetain();
      result = 0;
      *a4 = v6;
    }
  }
  else
  {
    AMSupportLogInternal();
    return 199;
  }
  return result;
}

uint64_t _AMFDRPlatformGetPrivateKeyNative(const __CFDictionary **cf, uint64_t a2)
{
  CFTypeID v4;
  uint64_t result;
  const void *v6;
  const void *v7;

  if (a2 && cf && (v4 = CFGetTypeID(cf), v4 == AMFDRGetTypeID()))
  {
    result = *(_QWORD *)a2;
    if (*(_QWORD *)a2)
      return result;
    v6 = _CFDictionaryCopyValue(cf[2], CFSTR("PrivateKey"));
    if (v6)
    {
      v7 = v6;
      *(_QWORD *)a2 = CFRetain(v6);
      CFRelease(v7);
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  return *(_QWORD *)a2;
}

CFURLRef _AMFDRPlatformDefaultCopyDefaultDataPathNative(uint64_t a1)
{
  _QWORD block[5];

  if (AMFDRDataIsDiagnosticMode())
    return AMFDRPlatformCopyDefaultDataStoragePath();
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___AMFDRPlatformDefaultCopyDefaultDataPathNative_block_invoke;
  block[3] = &__block_descriptor_tmp_20;
  block[4] = a1;
  if (_AMFDRPlatformDefaultCopyDefaultDataPathNative_onceToken != -1)
    dispatch_once(&_AMFDRPlatformDefaultCopyDefaultDataPathNative_onceToken, block);
  return (CFURLRef)AMSupportSafeRetain();
}

const __CFString *_AMFDRPlatformCopyOrganizationalUnitNative()
{
  return CFSTR("Devices");
}

const __CFString *_AMFDRPlatformDefaultCopyProductTypeStation()
{
  return AMFDRSealingMapCallMGCopyAnswer(CFSTR("ProductType"), 0);
}

uint64_t _AMFDRPlatformDefaultCopyDisposableKeys(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t v6;

  if (a4)
  {
    result = AMFDRCopyDisposableKeys(*MEMORY[0x24BDE9080], a2, a3);
    if (!(_DWORD)result)
    {
      AMSupportSafeRelease();
      v6 = AMSupportSafeRetain();
      result = 0;
      *a4 = v6;
    }
  }
  else
  {
    AMSupportLogInternal();
    return 199;
  }
  return result;
}

CFTypeRef _AMFDRPlatformCopyClientIdStation(_QWORD *a1)
{
  const __CFDictionary *v2;
  const void *Value;
  CFTypeRef v4;

  if (!a1)
    return 0;
  v2 = (const __CFDictionary *)a1[2];
  if (!v2)
    return 0;
  Value = CFDictionaryGetValue(v2, CFSTR("ClientId"));
  if (Value)
  {
    v4 = Value;
    CFRetain(Value);
  }
  else
  {
    v4 = AMFDRPlatformCopyDefaultClientIdByInterface(a1);
    if (v4)
      AMSupportLogInternal();
  }
  return v4;
}

uint64_t _AMFDRPlatformGetPrivateKeyStation(const __CFDictionary **cf, uint64_t a2)
{
  CFTypeID v4;
  uint64_t result;
  const __CFData *v6;
  CFDataRef theData;

  theData = 0;
  if (!a2)
    goto LABEL_14;
  if (!cf)
    goto LABEL_14;
  v4 = CFGetTypeID(cf);
  if (v4 != AMFDRGetTypeID())
    goto LABEL_14;
  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
    return result;
  v6 = (const __CFData *)_CFDictionaryCopyValue(cf[2], CFSTR("PrivateKey"));
  theData = v6;
  if (v6)
    goto LABEL_9;
  if (!AMFDRLoadPersistent((uint64_t)cf, (uint64_t)CFSTR("PrivateKeyFile"), (uint64_t)CFSTR("privatekey"), (uint64_t)&theData)|| (CFDataGetBytePtr(theData), CFDataGetLength(theData), AMSupportRsaCreatePrivateKeyFromPEMBuffer()))
  {
LABEL_14:
    AMSupportLogInternal();
    goto LABEL_10;
  }
  v6 = theData;
LABEL_9:
  *(_QWORD *)a2 = CFRetain(v6);
LABEL_10:
  if (theData)
    CFRelease(theData);
  return *(_QWORD *)a2;
}

uint64_t _AMFDRPlatformDefaultCopyDefaultDataPathStation(const void *a1)
{
  return AMFDRPlatformCopyDefaultDataDirectoryAppendingPathComponent(a1);
}

const __CFString *_AMFDRPlatformCopyOrganizationalUnitStation()
{
  return CFSTR("Stations");
}

uint64_t _AMFDRPlatformDefaultCopyRefKey(const __CFDictionary **cf, uint64_t a2)
{
  CFTypeID v4;
  const __CFDictionary *v5;
  const __CFData *Value;
  const __CFAllocator *v7;
  _QWORD *v8;
  _QWORD *v9;

  if (!a2)
    goto LABEL_11;
  if (!cf)
    goto LABEL_11;
  v4 = CFGetTypeID(cf);
  if (v4 != AMFDRGetTypeID())
    goto LABEL_11;
  v5 = cf[2];
  if (!v5)
    goto LABEL_11;
  if (!*(_QWORD *)(a2 + 8))
  {
    Value = (const __CFData *)CFDictionaryGetValue(v5, CFSTR("RefKeyBlob"));
    v7 = CFGetAllocator(cf);
    if (Value)
    {
      v8 = AMFDRDeviceRefKeyCreateWithData(v7, Value);
      *(_QWORD *)(a2 + 8) = v8;
      if (!v8)
LABEL_11:
        AMSupportLogInternal();
    }
    else
    {
      v9 = AMFDRDeviceRefKeyCreate(v7);
      *(_QWORD *)(a2 + 8) = v9;
      if (!v9)
        goto LABEL_11;
    }
  }
  return *(_QWORD *)(a2 + 8);
}

uint64_t AMFDRDiagnosticGenerateReport(const __CFDictionary *a1, CFTypeRef *a2, uint64_t a3)
{
  uint64_t EntriesForDevice;
  const __CFArray *v7;
  const __CFAllocator *v8;
  CFDictionaryRef *v9;
  __CFArray *v10;
  const __CFDictionary *v11;
  const __CFData *v12;
  CFStringRef v13;
  int IsAppleSigned;
  const __CFString *v15;
  const __CFString *v16;
  __int128 v17;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v19;
  const __CFString *v20;
  uint64_t v21;
  BOOL v22;
  const __CFArray *v23;
  const __CFArray *v24;
  CFMutableArrayRef v25;
  __CFArray *v26;
  const void *v27;
  uint64_t v28;
  CFStringRef PathComponent;
  const __CFString *v30;
  char v31;
  int v32;
  __CFError *v33;
  __CFArray *v34;
  int v35;
  __CFError *v36;
  const __CFDictionary *v37;
  const __CFData *v38;
  CFStringRef v39;
  CFLocaleRef v40;
  const __CFLocale *v41;
  CFTimeZoneRef v42;
  __CFDateFormatter *v43;
  __CFDateFormatter *v44;
  CFDateRef DateFromString;
  const __CFDate *v46;
  CFStringRef StringWithDate;
  const __CFString *v48;
  const __CFString *v49;
  const __CFString *v50;
  CFMutableArrayRef v51;
  __CFArray *v52;
  const __CFArray *v53;
  const __CFDictionary *v54;
  const __CFArray *v55;
  const __CFArray *v56;
  __CFError *v57;
  char v58;
  CFMutableArrayRef MutableCopy;
  CFMutableArrayRef v60;
  const CFArrayCallBacks *v61;
  CFMutableArrayRef v62;
  CFMutableArrayRef v63;
  __CFDictionary *v64;
  __CFDictionary *v65;
  CFDictionaryRef v66;
  const __CFArray *v67;
  __CFString *v68;
  CFTypeRef v69;
  CFIndex v70;
  _BOOL4 v71;
  const __CFDictionary *v72;
  const __CFDictionary *v73;
  CFTypeID v74;
  const __CFString *v75;
  const __CFString *v76;
  CFStringRef v77;
  CFTypeID v78;
  void *v79;
  CFTypeID v80;
  CFMutableArrayRef v81;
  const __CFArray *v82;
  CFTypeID v83;
  const __CFArray *v84;
  const __CFArray *v85;
  int v86;
  __CFError *v87;
  CFIndex Count;
  const __CFArray *v89;
  __CFError *v90;
  CFIndex v91;
  _BOOL4 v92;
  const __CFString *v93;
  const __CFArray *v94;
  const void *v95;
  CFIndex v96;
  char v97;
  __CFError *v98;
  CFTypeRef v99;
  const __CFDictionary *v100;
  CFTypeRef v101;
  CFTypeRef v102;
  int v103;
  const __CFString *v104;
  CFDictionaryRef v105;
  CFTypeID v106;
  CFTypeID v107;
  CFMutableArrayRef v108;
  uint64_t v109;
  const __CFArray *v110;
  CFIndex v111;
  const __CFDictionary *v112;
  const __CFDictionary *v113;
  CFTypeID v114;
  const void *v115;
  const void *v116;
  CFTypeID v117;
  const __CFArray *v118;
  const __CFArray *v119;
  const __CFDictionary *v120;
  int v121;
  __CFDictionary *v122;
  __CFDictionary *v123;
  __CFError *v124;
  const __CFDictionary *v125;
  CFIndex v126;
  CFIndex v127;
  const __CFString *v128;
  const __CFArray *v129;
  CFIndex v130;
  const CFDictionaryValueCallBacks *v131;
  const __CFString *ValueAtIndex;
  CFIndex FirstIndexOfValue;
  CFIndex v134;
  const CFDictionaryValueCallBacks *v135;
  __CFArray *v136;
  const __CFDictionary *v137;
  CFDictionaryRef *v138;
  const __CFDictionary *v139;
  CFDictionaryRef v140;
  __CFArray *v141;
  const __CFDictionary *v142;
  const __CFDictionary *v143;
  CFMutableArrayRef v144;
  const __CFDictionary *v145;
  const __CFDictionary *v146;
  CFDictionaryRef *v147;
  CFTypeID v148;
  const __CFArray *v149;
  const CFArrayCallBacks *v150;
  CFMutableArrayRef v151;
  CFMutableArrayRef v152;
  _QWORD *v153;
  const __CFString *v154;
  CFTypeRef v155;
  CFDictionaryRef v156;
  const __CFDictionary *v157;
  CFIndex v158;
  const void **v159;
  const void **v160;
  CFDictionaryRef v161;
  const CFDictionaryKeyCallBacks *v162;
  const CFDictionaryValueCallBacks *v163;
  void **v164;
  const __CFArray *v165;
  CFIndex v166;
  const __CFString *v167;
  BOOL HasAttribute;
  const __CFString *v169;
  __CFString *v170;
  __CFError *v171;
  BOOL v172;
  CFStringRef v173;
  __CFString *v174;
  const __CFString *v175;
  CFDictionaryRef v176;
  const __CFDictionary *v177;
  CFTypeID v178;
  const __CFAllocator *v179;
  CFMutableArrayRef v180;
  __CFArray *v181;
  const __CFArray *v182;
  const __CFData *v183;
  const __CFData *v184;
  const __CFArray *v185;
  CFDictionaryRef ManifestPropertyValueDict;
  const __CFDictionary *v187;
  const __CFDictionary *v188;
  CFTypeID v189;
  CFDictionaryRef v190;
  const void *v191;
  CFTypeID v192;
  uint64_t v193;
  const __CFString *v195;
  const __CFString *v196;
  const __CFString *v197;
  const __CFString *value;
  const __CFString *format;
  char v200;
  const __CFArray *v201;
  CFTypeRef *v202;
  const __CFString *v203;
  const __CFArray *v204;
  CFStringRef v205;
  CFTypeRef v206;
  const __CFDictionary *v207;
  const __CFArray *v208;
  _BOOL4 v209;
  CFDictionaryRef *v210;
  CFTypeRef v211;
  CFTypeRef v212;
  CFMutableDictionaryRef theDict;
  const __CFArray *v214;
  CFDictionaryRef v215;
  const __CFDictionary *v216;
  CFIndex v217;
  _BOOL4 v218;
  _BOOL4 v219;
  CFTypeRef v220;
  const __CFDictionary *v221;
  CFDictionaryRef *v222;
  const __CFAllocator *allocator;
  const void *v224;
  __CFArray *v225;
  const __CFDictionary *v226;
  CFArrayRef v227;
  CFArrayRef v228;
  __CFArray *v229;
  void *v230;
  const void **v231;
  __CFArray *theArray;
  const __CFArray *v233;
  CFArrayRef v234;
  __CFArray *key;
  const __CFArray *v236;
  const void **v237;
  CFTypeRef v238;
  const __CFDictionary *v239;
  __CFArray *v240;
  CFTypeRef cf;
  CFTypeRef v242;
  CFTypeRef v243;
  CFTypeRef v244;
  CFTypeRef v245;
  CFTypeRef v246;
  CFTypeRef v247;
  CFTypeRef v248;
  CFTypeRef v249;
  CFURLRef url;
  void *values[2];
  __int128 v252;
  __int128 v253;
  __int128 v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  __int128 v258;
  __int128 v259;
  __int128 v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  __int128 v268;
  __int128 v269;
  __int128 v270;
  __int128 v271;
  __int128 v272;
  __int128 v273;
  __int128 v274;
  __int128 v275;
  __int128 v276;
  __int128 v277;
  __int128 v278;
  unint64_t v279;
  void *BytePtr;
  const __CFString *Length;
  CFStringRef v282;
  uint64_t v283;
  CFRange v284;
  CFRange v285;
  CFRange v286;
  CFRange v287;
  CFRange v288;
  CFRange v289;
  CFRange v290;
  CFRange v291;
  CFRange v292;
  CFRange v293;
  CFRange v294;
  CFRange v295;
  CFRange v296;

  v283 = *MEMORY[0x24BDAC8D0];
  cf = 0;
  v242 = 0;
  AMFDRSealingMapSetKeyQueryRetry(0);
  EntriesForDevice = AMFDRSealingMapGetEntriesForDevice();
  if (!EntriesForDevice)
  {
    v195 = CFSTR("This device is not FDR supported");
LABEL_589:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDiagnosticGenerateReport", v195, v200);
LABEL_591:
    AMFDRSealingMapSetKeyQueryRetry(1);
LABEL_593:
    v203 = 0;
    v204 = 0;
    v205 = 0;
    v206 = 0;
    v177 = 0;
    v190 = 0;
    v191 = 0;
    v147 = 0;
    v212 = 0;
    v137 = 0;
    v193 = 0;
    goto LABEL_553;
  }
  if (!a2)
  {
    v195 = CFSTR("outReport is NULL");
    goto LABEL_589;
  }
  v7 = (const __CFArray *)EntriesForDevice;
  v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDiagnosticGenerateReport", CFSTR("Failed to allocate report."), v200);
    goto LABEL_591;
  }
  theArray = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  if (!theArray)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDiagnosticGenerateReport", CFSTR("Failed to allocate dataFailedToReport."), v200);
    AMFDRSealingMapSetKeyQueryRetry(1);
    CFRelease(theDict);
    goto LABEL_593;
  }
  AMSupportLogInternal();
  v207 = a1;
  v9 = (CFDictionaryRef *)AMFDRCreateTypeWithOptions(v8, CFSTR("Local"), a1);
  if ((AMFDRDataApTicketPopulate((uint64_t)v9) & 1) == 0)
    AMSupportLogInternal();
  v10 = theArray;
  if (v9 && (v11 = v9[2]) != 0)
    v12 = (const __CFData *)CFDictionaryGetValue(v11, CFSTR("APTicket"));
  else
    v12 = 0;
  v202 = a2;
  if ((AMFDRDataApTicketIsTrusted((uint64_t)v9, (uint64_t)v12) & 1) != 0)
  {
    v13 = CFSTR("Trusted");
  }
  else
  {
    IsAppleSigned = _AMFDRApTicketIsAppleSigned(v12);
    v15 = CFSTR("WarningMessage");
    if (IsAppleSigned)
      v15 = CFSTR("FailureReason");
    v16 = CFSTR("and is NOT Apple signed.");
    if (!IsAppleSigned)
      v16 = CFSTR("but is Apple signed.");
    v13 = CFStringCreateWithFormat(v8, 0, CFSTR("%@: ApTicket is NOT trusted, %@"), v15, v16);
  }
  CFDictionaryAddValue(theDict, CFSTR("ApTicket"), v13);
  allocator = v8;
  v214 = v7;
  if (!v12)
    goto LABEL_32;
  v279 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v277 = v17;
  v278 = v17;
  v275 = v17;
  v276 = v17;
  v273 = v17;
  v274 = v17;
  v271 = v17;
  v272 = v17;
  v269 = v17;
  v270 = v17;
  v267 = v17;
  v268 = v17;
  v265 = v17;
  v266 = v17;
  v263 = v17;
  v264 = v17;
  v261 = v17;
  v262 = v17;
  v259 = v17;
  v260 = v17;
  v257 = v17;
  v258 = v17;
  v255 = v17;
  v256 = v17;
  v253 = v17;
  v254 = v17;
  *(_OWORD *)values = v17;
  v252 = v17;
  CFDataGetBytePtr(v12);
  CFDataGetLength(v12);
  if (Img4DecodeInitManifest())
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyEntitlementsFromAPTicket", CFSTR("failed to parse AP ticket"), v200);
LABEL_32:
    values[0] = CFSTR("EntitlementReadFailed");
    if (cf)
      values[0] = (void *)CFStringCreateWithFormat(v8, 0, CFSTR("%@: %@"), CFSTR("EntitlementReadFailed"), cf);
    CFArrayAppendValue(v10, CFSTR("Entitlements"));
    v23 = CFArrayCreate(v8, (const void **)values, 1, MEMORY[0x24BDBD690]);
    if (values[0])
      CFRelease(values[0]);
    v218 = 0;
    goto LABEL_39;
  }
  Mutable = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyEntitlementsFromAPTicket", CFSTR("Failed to allocate entitlements"), v200);
    goto LABEL_32;
  }
  v19 = Mutable;
  LOBYTE(url) = 0;
  BytePtr = (void *)0xAAAAAAAAAAAAAAAALL;
  if (!_stringTagToDERTag(CFSTR("esca"), &BytePtr))
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyEntitlementsFromAPTicket", CFSTR("_stringTagToDERTag failed for '%@'"), (char)CFSTR("esca"));
    CFRelease(v19);
    goto LABEL_32;
  }
  v20 = CFSTR("esca");
  v21 = 1;
  do
  {
    if (Img4DecodeGetBooleanFromSection())
      v22 = 1;
    else
      v22 = url == 0;
    if (v22)
      AMSupportLogInternal();
    else
      CFArrayAppendValue(v19, v20);
    if (v21 == 6)
    {
      v24 = (const __CFArray *)CFRetain(v19);
      v25 = v19;
      v23 = v24;
      CFRelease(v25);
      goto LABEL_38;
    }
    LOBYTE(url) = 0;
    BytePtr = (void *)0xAAAAAAAAAAAAAAAALL;
    v20 = *(&kFDREntitlements + v21++);
  }
  while (_stringTagToDERTag(v20, &BytePtr));
  AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyEntitlementsFromAPTicket", CFSTR("_stringTagToDERTag failed for '%@'"), (char)v20);
  CFRelease(v19);
  v23 = 0;
  v10 = theArray;
  if ((unint64_t)(v21 - 2) < 5)
    goto LABEL_32;
LABEL_38:
  v284.length = CFArrayGetCount(v23);
  v284.location = 0;
  v218 = CFArrayContainsValue(v23, v284, CFSTR("faus")) != 0;
LABEL_39:
  CFDictionaryAddValue(theDict, CFSTR("Entitlements"), v23);
  AMSupportLogInternal();
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  v211 = AMFDRDataLocalCopyDataDirectoryPath(v9, (uint64_t)&cf);
  if (cf)
  {
    v212 = _copyUnderlyingErrors((__CFError *)cf);
    AMSupportLogInternal();
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
  }
  else
  {
    v212 = 0;
  }
  v204 = v23;
  v205 = v13;
  url = 0;
  values[0] = 0;
  BytePtr = 0;
  v249 = 0;
  v210 = v9;
  if (!v211)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyLocalFullKeys", CFSTR("localDataDirURL is NULL"), v200);
    v206 = 0;
    v31 = 0;
    v26 = 0;
LABEL_599:
    v27 = 0;
    goto LABEL_65;
  }
  v26 = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  if (!v26)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyLocalFullKeys", CFSTR("Failed to allocate localFullKeys"), v200);
    v206 = 0;
    v31 = 0;
    goto LABEL_599;
  }
  v27 = (const void *)MEMORY[0x212BA0AA4](v8, v211, 0, 0);
  if (v27)
  {
    v206 = 0;
    while (1)
    {
      v28 = MEMORY[0x212BA0AB0](v27, &url, &v249);
      if (v28 == 2)
      {
        v31 = 1;
        goto LABEL_65;
      }
      if (v28 == 3)
        break;
      PathComponent = CFURLCopyLastPathComponent(url);
      if (PathComponent)
      {
        v30 = PathComponent;
        AMSupportLogInternal();
        if (values[0])
        {
          CFRelease(values[0]);
          values[0] = 0;
        }
        if (BytePtr)
        {
          CFRelease(BytePtr);
          BytePtr = 0;
        }
        if (AMFDRDataLocalDecomposeFullKey(v8, v30, (CFTypeRef *)values, (CFTypeRef *)&BytePtr)
          && (CFStringGetLength((CFStringRef)values[0]) == 4
           || CFStringCompare((CFStringRef)values[0], CFSTR("minimal-manifest"), 0) == kCFCompareEqualTo))
        {
          CFArrayAppendValue(v26, v30);
          if (CFStringCompare((CFStringRef)values[0], CFSTR("seal"), 0) == kCFCompareEqualTo)
          {
            v206 = (CFTypeRef)AMSupportSafeRetain();
            AMSupportLogInternal();
          }
        }
        CFRelease(v30);
      }
      v9 = v210;
      if (v249)
      {
        CFRelease(v249);
        v249 = 0;
      }
    }
    AMFDRErrorPushInternal((uint64_t)&cf, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyLocalFullKeys", CFSTR("Error enumerating %@, error: %@"), (char)url);
    v31 = 0;
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyLocalFullKeys", CFSTR("local data dir enumerator is NULL"), v200);
    v206 = 0;
    v31 = 0;
  }
LABEL_65:
  v208 = (const __CFArray *)AMSupportSafeRetain();
  if (v249)
  {
    CFRelease(v249);
    v249 = 0;
  }
  if (values[0])
  {
    CFRelease(values[0]);
    values[0] = 0;
  }
  if (BytePtr)
  {
    CFRelease(BytePtr);
    BytePtr = 0;
  }
  if (v26)
    CFRelease(v26);
  if (v27)
    CFRelease(v27);
  if ((v31 & 1) == 0)
    AMSupportLogInternal();
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  v32 = AMFDRSealingMapPopulateSealingManifest((uint64_t)v9, 0, (uint64_t)&cf);
  v33 = (__CFError *)cf;
  v34 = theArray;
  if (!v32 || cf)
  {
    if (v212)
    {
      CFRelease(v212);
      v33 = (__CFError *)cf;
    }
    v212 = _copyUnderlyingErrors(v33);
    AMSupportLogInternal();
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
  }
  v35 = AMFDRSealingMapPopulateMinimalSealingManifest(v9, 0, (uint64_t)&cf);
  v36 = (__CFError *)cf;
  if (!v35 || cf)
  {
    if (v212)
    {
      CFRelease(v212);
      v36 = (__CFError *)cf;
    }
    v212 = _copyUnderlyingErrors(v36);
    AMSupportLogInternal();
  }
  AMSupportLogInternal();
  if (v9 && (v37 = v9[2]) != 0)
    v38 = (const __CFData *)CFDictionaryGetValue(v37, CFSTR("SealingManifest"));
  else
    v38 = 0;
  url = 0;
  values[0] = 0;
  BytePtr = (void *)0xAAAAAAAAAAAAAAAALL;
  Length = (const __CFString *)0xAAAAAAAAAAAAAAAALL;
  values[1] = 0;
  *(_QWORD *)&v252 = 0;
  if (_copySealingManifestProperty(v38, CFSTR("time"), &url)
    && url
    && (BytePtr = (void *)CFDataGetBytePtr(url),
        Length = (const __CFString *)CFDataGetLength(url),
        !DERDecodeItem((uint64_t)&BytePtr, (unint64_t *)values)))
  {
    v39 = CFStringCreateWithBytes(v8, (const UInt8 *)values[1], v252, 0x8000100u, 0);
    if (v39)
    {
      v40 = CFLocaleCreate(v8, CFSTR("en_US"));
      if (!v40)
      {
        v48 = (const __CFString *)CFRetain(v39);
LABEL_110:
        v34 = theArray;
        goto LABEL_111;
      }
      v41 = v40;
      v42 = CFTimeZoneCreateWithTimeIntervalFromGMT(v8, 0.0);
      v43 = CFDateFormatterCreate(v8, v41, kCFDateFormatterShortStyle, kCFDateFormatterMediumStyle);
      v44 = v43;
      if (v42 && v43)
      {
        CFDateFormatterSetFormat(v43, CFSTR("yyMMddHHmmss'Z'"));
        CFDateFormatterSetProperty(v44, (CFStringRef)*MEMORY[0x24BDBD340], v42);
        DateFromString = CFDateFormatterCreateDateFromString(v8, v44, v39, 0);
        if (DateFromString)
        {
          v46 = DateFromString;
          CFDateFormatterSetFormat(v44, CFSTR("dd/MM/yyyy HH:mm:ss zzz"));
          StringWithDate = CFDateFormatterCreateStringWithDate(v8, v44, v46);
          CFRelease(v46);
        }
        else
        {
          StringWithDate = 0;
        }
        v7 = v214;
      }
      else
      {
        StringWithDate = 0;
        v49 = 0;
        if (!v42)
        {
          if (!v44)
          {
LABEL_107:
            if (!v49)
              v49 = (const __CFString *)CFRetain(v39);
            v48 = v49;
            CFRelease(v41);
            goto LABEL_110;
          }
LABEL_106:
          v50 = v49;
          CFRelease(v44);
          v49 = v50;
          goto LABEL_107;
        }
      }
      CFRelease(v42);
      v49 = StringWithDate;
      if (!v44)
        goto LABEL_107;
      goto LABEL_106;
    }
    AMSupportLogInternal();
    v48 = 0;
  }
  else
  {
    AMSupportLogInternal();
    v48 = 0;
    v39 = 0;
  }
LABEL_111:
  if (url)
  {
    CFRelease(url);
    url = 0;
  }
  if (v39)
    CFRelease(v39);
  if (!v48)
  {
    CFArrayAppendValue(v34, CFSTR("SealDate"));
    v48 = CFSTR("SealDateParseFail");
  }
  v203 = v48;
  CFDictionaryAddValue(theDict, CFSTR("SealDate"), v48);
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  url = 0;
  values[0] = 0;
  BytePtr = 0;
  if (!v38)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopySealedFullKeysAndProperties", CFSTR("sealingManifest is NULL"), v200);
    v56 = 0;
LABEL_602:
    v54 = v207;
    goto LABEL_140;
  }
  v51 = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  if (!v51)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopySealedFullKeysAndProperties", CFSTR("Failed to allocate sealedFullKeys"), v200);
    v56 = 0;
    LOBYTE(v38) = 0;
    goto LABEL_602;
  }
  v52 = v51;
  if ((AMFDRSealingManifestCopyDataClassesInstancesAndProperties(v38, &v242, (CFTypeRef *)&BytePtr, (CFTypeRef *)&url, &cf) & 1) == 0)
  {
    v196 = CFSTR("AMFDRSealingManifestCopyDataClassesInstancesAndProperties failed");
LABEL_614:
    AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopySealedFullKeysAndProperties", v196, v200);
    v56 = 0;
    LOBYTE(v38) = 0;
    v54 = v207;
    goto LABEL_138;
  }
  if ((_createFullKeysForDataInstances(url, BytePtr, (CFTypeRef *)values) & 1) == 0)
  {
    v196 = CFSTR("_createFullKeysForDataInstances failed");
    goto LABEL_614;
  }
  if (values[0] && CFArrayGetCount((CFArrayRef)values[0]) >= 1)
  {
    v53 = (const __CFArray *)values[0];
    v293.length = CFArrayGetCount((CFArrayRef)values[0]);
    v293.location = 0;
    CFArrayAppendArray(v52, v53, v293);
  }
  if (url)
  {
    CFRelease(url);
    url = 0;
  }
  if (values[0])
  {
    CFRelease(values[0]);
    values[0] = 0;
  }
  v54 = v207;
  if (!AMFDRSealingManifestCopyMinimalManifestClassesAndInstances(v9, (uint64_t *)&url, 0, 0, &cf)
    || !url
    || CFArrayGetCount(url) < 1)
  {
    goto LABEL_137;
  }
  if ((_createFullKeysForDataInstances(url, CFSTR("minimal-manifest"), (CFTypeRef *)values) & 1) != 0)
  {
    if (values[0] && CFArrayGetCount((CFArrayRef)values[0]) >= 1)
    {
      v55 = (const __CFArray *)values[0];
      v294.length = CFArrayGetCount((CFArrayRef)values[0]);
      v294.location = 0;
      CFArrayAppendArray(v52, v55, v294);
    }
LABEL_137:
    v56 = (const __CFArray *)CFRetain(v52);
    LOBYTE(v38) = 1;
    goto LABEL_138;
  }
  AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopySealedFullKeysAndProperties", CFSTR("_createFullKeysForDataInstances failed"), v200);
  v56 = 0;
  LOBYTE(v38) = 0;
LABEL_138:
  CFRelease(v52);
  if (values[0])
  {
    CFRelease(values[0]);
    values[0] = 0;
  }
LABEL_140:
  if (BytePtr)
  {
    CFRelease(BytePtr);
    BytePtr = 0;
  }
  if (url)
    CFRelease(url);
  v57 = (__CFError *)cf;
  if (cf)
    v58 = 0;
  else
    v58 = (char)v38;
  if ((v58 & 1) == 0)
  {
    if (v212)
    {
      CFRelease(v212);
      v57 = (__CFError *)cf;
    }
    v212 = _copyUnderlyingErrors(v57);
    AMSupportLogInternal();
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
  }
  v248 = 0;
  v249 = 0;
  v246 = 0;
  v247 = 0;
  v244 = 0;
  v245 = 0;
  v201 = v56;
  if (!v208)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("localFullKeys is NULL"), v200);
    v137 = 0;
    v56 = 0;
LABEL_604:
    v68 = 0;
    v69 = 0;
    v138 = 0;
    v220 = 0;
    goto LABEL_419;
  }
  if (!v56)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("sealedFullKeys is NULL"), v200);
    v137 = 0;
    goto LABEL_604;
  }
  MutableCopy = CFArrayCreateMutableCopy(v8, 0, v208);
  v60 = CFArrayCreateMutableCopy(v8, 0, v56);
  v233 = MutableCopy;
  v236 = v60;
  if (!MutableCopy || !v60)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("Failed to allocate localFullKeysToVerify/sealedFullKeysToVerify"), v200);
    v220 = 0;
    v138 = 0;
    v69 = 0;
    v68 = 0;
    v56 = 0;
    v140 = 0;
    v137 = 0;
    if (MutableCopy)
      goto LABEL_414;
    goto LABEL_415;
  }
  v61 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  v62 = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  v63 = CFArrayCreateMutable(v8, 0, v61);
  v229 = v62;
  v225 = v63;
  if (!v62 || !v63)
  {
    AMFDRErrorPushInternal((uint64_t)&cf, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("Failed to allocate failureData/verifiedData"), v200);
    v220 = 0;
    v221 = 0;
    v138 = 0;
    v69 = 0;
    v68 = 0;
    v228 = 0;
    v139 = 0;
    v140 = 0;
    v137 = 0;
    MutableCopy = v233;
    v136 = v229;
    if (v229)
      goto LABEL_406;
    goto LABEL_407;
  }
  v64 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v221 = v64;
  if (!v64)
  {
    v197 = CFSTR("CFDictionaryCreateMutable failed for copyLocalDataOptions");
LABEL_620:
    AMFDRErrorPushInternal((uint64_t)&cf, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", v197, v200);
    v137 = 0;
    v140 = 0;
    v139 = 0;
    v228 = 0;
    v68 = 0;
    v69 = 0;
    v138 = 0;
    v220 = 0;
    MutableCopy = v233;
    v136 = v229;
    goto LABEL_406;
  }
  v65 = v64;
  _CFDictionaryAddDictionary(v64, v54);
  CFDictionarySetValue(v65, CFSTR("VerifyData"), (const void *)*MEMORY[0x24BDBD270]);
  CFDictionarySetValue(v65, CFSTR("StripImg4"), (const void *)*MEMORY[0x24BDBD268]);
  v216 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x24BDBD6A0], &kCFDictionaryValueCallBacksAllowNULL);
  if (!v216)
  {
    v197 = CFSTR("CFDictionaryCreateMutable failed for queryCache");
    goto LABEL_620;
  }
  v222 = (CFDictionaryRef *)AMFDRCreateTypeWithOptions(v8, CFSTR("Local"), v54);
  if (CFArrayGetCount(v7) < 1)
  {
    v220 = 0;
    v69 = 0;
    v68 = 0;
    v67 = 0;
    v66 = 0;
LABEL_376:
    v228 = v67;
    v129 = v236;
    if (CFArrayGetCount(v236) >= 1)
    {
      v130 = 0;
      v131 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
      do
      {
        if (v66)
          CFRelease(v66);
        if (v249)
        {
          CFRelease(v249);
          v249 = 0;
        }
        if (v248)
        {
          CFRelease(v248);
          v248 = 0;
        }
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v129, v130);
        AMSupportLogInternal();
        if (AMFDRDataLocalDecomposeFullKey(allocator, ValueAtIndex, &v249, &v248))
        {
          *(_OWORD *)values = xmmword_24C69F550;
          BytePtr = (void *)v248;
          Length = CFSTR("Sealed key not found with live queries based on sealing map");
          v66 = CFDictionaryCreate(allocator, (const void **)values, (const void **)&BytePtr, 2, MEMORY[0x24BDBD6A0], v131);
          _buildReportWithKeyAndMessage(v249, (uint64_t)CFSTR("Sealed key not found with live queries based on sealing map"), v66, v229, 0, theArray);
        }
        else
        {
          v66 = 0;
        }
        v290.length = CFArrayGetCount(v233);
        v290.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v233, v290, ValueAtIndex);
        if (FirstIndexOfValue != -1)
          CFArrayRemoveValueAtIndex(v233, FirstIndexOfValue);
        ++v130;
        v129 = v236;
      }
      while (v130 < CFArrayGetCount(v236));
    }
    if (CFArrayGetCount(v233) >= 1)
    {
      v134 = 0;
      v135 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
      do
      {
        if (v66)
          CFRelease(v66);
        if (v249)
        {
          CFRelease(v249);
          v249 = 0;
        }
        if (v248)
        {
          CFRelease(v248);
          v248 = 0;
        }
        value = (const __CFString *)CFArrayGetValueAtIndex(v233, v134);
        AMSupportLogInternal();
        if (AMFDRDataLocalDecomposeFullKey(allocator, value, &v249, &v248))
        {
          *(_OWORD *)values = xmmword_24C69F560;
          BytePtr = (void *)v248;
          Length = CFSTR("Local data not sealed");
          v66 = CFDictionaryCreate(allocator, (const void **)values, (const void **)&BytePtr, 2, MEMORY[0x24BDBD6A0], v135);
          _buildReportWithKeyAndMessage(v249, (uint64_t)CFSTR("Local data not sealed"), v66, v229, 0, theArray);
        }
        else
        {
          v66 = 0;
        }
        ++v134;
      }
      while (v134 < CFArrayGetCount(v233));
    }
    *(_OWORD *)values = xmmword_24C69F570;
    v136 = v229;
    BytePtr = v229;
    Length = (const __CFString *)v225;
    v8 = allocator;
    v137 = CFDictionaryCreate(allocator, (const void **)values, (const void **)&BytePtr, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (!v137)
      AMFDRErrorPushInternal((uint64_t)&cf, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("Failed to create outDataReport"), v200);
    MutableCopy = v233;
    v138 = v222;
    goto LABEL_405;
  }
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v220 = 0;
  v70 = 0;
  v71 = v218;
  if (v206)
    v71 = 0;
  v209 = v71;
  while (1)
  {
    v217 = v70;
    v72 = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v70);
    v73 = v72;
    if (!v72 || (v74 = CFGetTypeID(v72), v74 != CFDictionaryGetTypeID()))
    {
      v228 = v67;
      AMFDRErrorPushInternal((uint64_t)&cf, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("unexpected type sealingMapEntry: '%@'"), (char)v73);
      goto LABEL_584;
    }
    v75 = (const __CFString *)CFDictionaryGetValue(v73, CFSTR("Tag"));
    if (!v75)
    {
      v228 = v67;
      AMFDRErrorPushInternal((uint64_t)&cf, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("Missing key '%@' in sealing map entry"), (char)CFSTR("Tag"));
      goto LABEL_584;
    }
    v76 = v75;
    v224 = CFDictionaryGetValue(v73, CFSTR("MinimalSealingManifest"));
    v230 = (void *)CFStringCompare(v76, CFSTR("seal"), 0);
    v238 = CFDictionaryGetValue(v73, CFSTR("SubCCList"));
    if (v244)
    {
      CFRelease(v244);
      v244 = 0;
    }
    if (v220)
      CFRelease(v220);
    v77 = AMFDRSealingMapCopyDataInstanceForSealingMapEntry(v8, v73, v216, (uint64_t)&v247);
    v244 = v77;
    if (!v77)
      goto LABEL_217;
    v78 = CFGetTypeID(v77);
    if (v78 != CFStringGetTypeID())
      break;
    v79 = CFArrayCreate(v8, &v244, 1, MEMORY[0x24BDBD690]);
    if (v79)
      goto LABEL_178;
LABEL_217:
    AMSupportLogInternal();
    if (v66)
      CFRelease(v66);
    if (v68)
      CFRelease(v68);
    v87 = (__CFError *)v247;
    if (v247)
    {
      if (v69)
      {
        CFRelease(v69);
        v87 = (__CFError *)v247;
      }
      v69 = _copyUnderlyingErrors(v87);
      v68 = (__CFString *)CFStringCreateWithFormat(v8, 0, CFSTR("%@: %@"), CFSTR("MissingLiveData"), v69);
      if (v247)
      {
        CFRelease(v247);
        v247 = 0;
      }
    }
    else
    {
      v68 = CFSTR("MissingLiveData");
    }
    values[0] = CFSTR("FailureReason");
    BytePtr = v68;
    v66 = CFDictionaryCreate(v8, (const void **)values, (const void **)&BytePtr, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    _buildReportWithKeyAndMessage(v76, (uint64_t)v68, v66, v229, 0, theArray);
    v220 = 0;
LABEL_228:
    Count = CFArrayGetCount(v7);
    v70 = v217 + 1;
    if (v217 + 1 >= Count)
      goto LABEL_376;
  }
  if (!v244)
    goto LABEL_217;
  v80 = CFGetTypeID(v244);
  if (v80 != CFArrayGetTypeID())
    goto LABEL_217;
  v79 = (void *)CFRetain(v244);
  if (!v79)
    goto LABEL_217;
LABEL_178:
  v220 = v79;
  if (v67)
    CFRelease(v67);
  v81 = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  if (v81)
  {
    v67 = v81;
    if (v246)
    {
      CFRelease(v246);
      v246 = 0;
    }
    if ((_createFullKeysForDataInstances((CFArrayRef)v220, v76, &v246) & 1) == 0)
      AMSupportLogInternal();
    if (v246)
    {
      if (CFArrayGetCount((CFArrayRef)v246) >= 1)
      {
        v82 = (const __CFArray *)v246;
        v295.length = CFArrayGetCount((CFArrayRef)v246);
        v295.location = 0;
        CFArrayAppendArray(v67, v82, v295);
      }
      if (v246)
      {
        CFRelease(v246);
        v246 = 0;
      }
    }
    if (v245)
    {
      CFRelease(v245);
      v245 = 0;
    }
    url = 0;
    values[0] = 0;
    BytePtr = 0;
    v83 = CFGetTypeID(v73);
    if (v83 == CFDictionaryGetTypeID())
    {
      if (v222)
      {
        v84 = (const __CFArray *)CFDictionaryGetValue(v73, CFSTR("MinimalSealingManifest"));
        if (!v84)
        {
          v86 = 1;
          goto LABEL_215;
        }
        v85 = v84;
        if (_AMFDRSealingMapCopyDataClassesAndInstancesInternal(v222, v84, 1, 0, 0, 0, 0, 0, 0, (CFTypeRef *)values, (CFTypeRef *)&BytePtr, (CFTypeRef *)&url, 0, 0, (uint64_t)&v247))
        {
          if (values[0]
            && CFArrayGetCount((CFArrayRef)values[0]) >= 1
            && BytePtr
            && CFArrayGetCount((CFArrayRef)BytePtr) >= 1
            && (_createFullKeysForDataInstances((CFArrayRef)BytePtr, values[0], &v246) & 1) == 0)
          {
            v128 = CFSTR("_createFullKeysForDataInstances failed");
          }
          else
          {
            if (url && CFArrayGetCount(url) >= 1)
              AMSupportLogInternal();
            if (values[0])
            {
              CFRelease(values[0]);
              values[0] = 0;
            }
            if (BytePtr)
            {
              CFRelease(BytePtr);
              BytePtr = 0;
            }
            if (_AMFDRSealingMapCopyDataClassesAndInstancesInternal(v222, v85, 1, CFSTR("RequiredToSeal"), 0, 0, 0, 0, 0, (CFTypeRef *)values, (CFTypeRef *)&BytePtr, 0, 0, 0, (uint64_t)&v247))
            {
              if (values[0])
              {
                v86 = 1;
                if (CFArrayGetCount((CFArrayRef)values[0]) >= 1
                  && BytePtr
                  && CFArrayGetCount((CFArrayRef)BytePtr) >= 1
                  && (_createFullKeysForDataInstances((CFArrayRef)BytePtr, values[0], &v245) & 1) == 0)
                {
                  AMSupportLogInternal();
                }
LABEL_215:
                if (values[0])
                {
                  CFRelease(values[0]);
                  values[0] = 0;
                }
              }
              else
              {
                v86 = 1;
              }
              if (BytePtr)
              {
                CFRelease(BytePtr);
                BytePtr = 0;
              }
              if (url)
                CFRelease(url);
              if (v86)
              {
                if (v246 && CFArrayGetCount((CFArrayRef)v246) >= 1)
                {
                  v89 = (const __CFArray *)v246;
                  v296.length = CFArrayGetCount((CFArrayRef)v246);
                  v296.location = 0;
                  CFArrayAppendArray(v67, v89, v296);
                }
              }
              else
              {
                AMSupportLogInternal();
                if (v66)
                  CFRelease(v66);
                if (v68)
                  CFRelease(v68);
                v90 = (__CFError *)v247;
                if (v247)
                {
                  if (v69)
                  {
                    CFRelease(v69);
                    v90 = (__CFError *)v247;
                  }
                  v69 = _copyUnderlyingErrors(v90);
                  v68 = (__CFString *)CFStringCreateWithFormat(v8, 0, CFSTR("%@: %@"), CFSTR("MissingLiveData"), v69);
                  if (v247)
                  {
                    CFRelease(v247);
                    v247 = 0;
                  }
                }
                else
                {
                  v68 = CFSTR("MissingLiveData");
                }
                values[0] = CFSTR("FailureReason");
                BytePtr = v68;
                v66 = CFDictionaryCreate(v8, (const void **)values, (const void **)&BytePtr, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
                _buildReportWithKeyAndMessage(CFSTR("minimal-manifest"), (uint64_t)v68, v66, v229, 0, theArray);
              }
              if (CFArrayGetCount(v67) < 1)
                goto LABEL_228;
              v91 = 0;
              v92 = v209;
              if (v230)
                v92 = 0;
              v219 = v92;
              v226 = v73;
              v227 = v67;
              while (2)
              {
                if (v66)
                  CFRelease(v66);
                if (v68)
                  CFRelease(v68);
                url = 0;
                v243 = 0;
                v93 = (const __CFString *)CFArrayGetValueAtIndex(v67, v91);
                if ((AMFDRDataLocalDecomposeFullKey(v8, v93, (CFTypeRef *)&url, &v243) & 1) != 0)
                {
                  AMSupportLogInternal();
                  LODWORD(v94) = AMFDRSealingMapEntryHasAttributeInternal(0, v73, CFSTR("RequiredToSeal"), 0);
                  if (v230)
                  {
                    if (v224 && CFStringCompare((CFStringRef)url, CFSTR("minimal-manifest"), 0) == kCFCompareEqualTo)
                    {
                      v95 = AMFDRSealingMapCopyLocalMinimalManifestForInstance((const __CFString *)v243, (uint64_t)&v247);
                      v94 = (const __CFArray *)v245;
                      if (v245)
                      {
                        v287.length = CFArrayGetCount((CFArrayRef)v245);
                        v287.location = 0;
                        LODWORD(v94) = CFArrayContainsValue(v94, v287, v93) != 0;
                      }
                    }
                    else
                    {
                      v95 = (const void *)AMFDRSealingMapCopyLocalData((__CFString *)url, (const __CFString *)v243, v221, (uint64_t)&v247);
                    }
                  }
                  else
                  {
                    AMFDRSealingMapVerifySealing(v222, (CFErrorRef *)&v247);
                    v96 = CFArrayGetCount(v236);
                    v97 = v218;
                    if (v96)
                      v97 = 1;
                    if ((v97 & 1) == 0)
                      AMFDRErrorPushInternal((uint64_t)&v247, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("No sealed key found and allowUnSeal is false"), v200);
                    v95 = 0;
                  }
                  v98 = (__CFError *)v247;
                  if (v247)
                  {
                    if (v69)
                    {
                      CFRelease(v69);
                      v98 = (__CFError *)v247;
                    }
                    v99 = _copyUnderlyingErrors(v98);
                    v285.length = CFArrayGetCount(v236);
                    v285.location = 0;
                    if (CFArrayContainsValue(v236, v285, v93))
                    {
                      v68 = (__CFString *)CFStringCreateWithFormat(v8, 0, CFSTR("%@: %@"), CFSTR("DataFailedVerification"), v99);
                      *(_OWORD *)values = xmmword_24C69F530;
                      BytePtr = (void *)v243;
                      Length = v68;
                    }
                    else
                    {
                      if (v230)
                        v103 = (int)v94;
                      else
                        v103 = 1;
                      if (v103 == 1)
                      {
                        v68 = (__CFString *)CFStringCreateWithFormat(v8, 0, CFSTR("%@: %@"), CFSTR("SealedDataMissing"), v99);
                        v104 = CFSTR("FailureReason");
                      }
                      else
                      {
                        v104 = CFSTR("WarningMessage");
                        v68 = CFSTR("Key is not required to seal");
                      }
                      values[0] = CFSTR("LiveInstance");
                      values[1] = (void *)v104;
                      BytePtr = (void *)v243;
                      Length = v68;
                    }
                    v100 = CFDictionaryCreate(v8, (const void **)values, (const void **)&BytePtr, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
                    v69 = v99;
                    if (v247)
                    {
                      v120 = v100;
                      CFRelease(v247);
                      v100 = v120;
                      v101 = 0;
                      v102 = 0;
                      v247 = 0;
                    }
                    else
                    {
                      v101 = 0;
                      v102 = 0;
                    }
                    goto LABEL_338;
                  }
                  if (v219)
                  {
                    *(_OWORD *)values = xmmword_24C69F540;
                    BytePtr = (void *)v243;
                    Length = CFSTR("Unit is not sealed");
                    v100 = CFDictionaryCreate(v8, (const void **)values, (const void **)&BytePtr, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
                    v101 = 0;
                    v102 = 0;
                    v68 = 0;
                    goto LABEL_338;
                  }
                  values[0] = CFSTR("LiveInstance");
                  BytePtr = (void *)v243;
                  v105 = CFDictionaryCreate(v8, (const void **)values, (const void **)&BytePtr, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
                  v100 = v105;
                  v101 = 0;
                  if (!v238 || !v95)
                  {
                    v102 = 0;
                    v68 = 0;
                    goto LABEL_332;
                  }
                  v215 = v105;
                  v106 = CFGetTypeID(v238);
                  if (v106 == CFArrayGetTypeID())
                  {
                    v107 = CFGetTypeID(v95);
                    if (v107 == CFDataGetTypeID())
                    {
                      if (v222)
                      {
                        v108 = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
                        if (!v108)
                        {
                          AMFDRErrorPushInternal((uint64_t)&v247, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyAndVerifySubCC", CFSTR("failed to allocate missingSubCCList"), v200);
                          v101 = 0;
                          v102 = 0;
                          goto LABEL_358;
                        }
                        v109 = AMFDRDataDictCreateFromData((uint64_t)v222, (const __CFData *)v95, 0, 0);
                        v110 = (const __CFArray *)v238;
                        if (!v109)
                        {
                          AMFDRErrorPushInternal((uint64_t)&v247, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyAndVerifySubCC", CFSTR("AMFDRDataDictCreateFromData failed"), v200);
                          goto LABEL_357;
                        }
                        if (CFArrayGetCount((CFArrayRef)v238) < 1)
                        {
LABEL_298:
                          v119 = *(const __CFArray **)(v109 + 32);
                          if (v119 && CFArrayGetCount(v119) >= 1)
                            v101 = CFRetain(*(CFTypeRef *)(v109 + 32));
                          else
                            v101 = 0;
                          if (CFArrayGetCount(v108) < 1)
                            v102 = 0;
                          else
                            v102 = CFRetain(v108);
                          v121 = 1;
                        }
                        else
                        {
                          v111 = 0;
                          while (1)
                          {
                            v112 = (const __CFDictionary *)CFArrayGetValueAtIndex(v110, v111);
                            v113 = v112;
                            if (!v112 || (v114 = CFGetTypeID(v112), v114 != CFDictionaryGetTypeID()))
                            {
                              AMFDRErrorPushInternal((uint64_t)&v247, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyAndVerifySubCC", CFSTR("Unexpected type for subCCListEntry: '%@'"), (char)v113);
                              goto LABEL_357;
                            }
                            v115 = CFDictionaryGetValue(v113, CFSTR("Tag"));
                            v116 = v115;
                            if (!v115)
                              break;
                            v117 = CFGetTypeID(v115);
                            if (v117 != CFStringGetTypeID())
                              break;
                            if (AMFDRSealingMapEntryHasAttributeInternal(0, v113, CFSTR("RequiredToSeal"), 0))
                            {
                              v118 = *(const __CFArray **)(v109 + 32);
                              if (!v118
                                || (v286.length = CFArrayGetCount(*(CFArrayRef *)(v109 + 32)),
                                    v286.location = 0,
                                    !CFArrayContainsValue(v118, v286, v116)))
                              {
                                CFArrayAppendValue(v108, v116);
                              }
                            }
                            ++v111;
                            v110 = (const __CFArray *)v238;
                            if (v111 >= CFArrayGetCount((CFArrayRef)v238))
                              goto LABEL_298;
                          }
                          AMFDRErrorPushInternal((uint64_t)&v247, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyAndVerifySubCC", CFSTR("Unexpected type for subCCDataClass: %@"), (char)v116);
LABEL_357:
                          v101 = 0;
                          v102 = 0;
LABEL_358:
                          v121 = 0;
                        }
                        AMSupportSafeRelease();
                        AMSupportSafeRelease();
                        if (v121)
                        {
                          v122 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
                          if (v122)
                          {
                            v123 = v122;
                            if (v101)
                              CFDictionaryAddValue(v122, CFSTR("SubCCList"), v101);
                            if (v102)
                            {
                              v68 = (__CFString *)CFStringCreateWithFormat(allocator, 0, CFSTR("%@: %@"), CFSTR("SealedSubCCMissing"), v102);
                              if (v68)
                                CFDictionaryAddValue(v123, CFSTR("FailureReason"), v68);
                              else
                                AMFDRErrorPushInternal((uint64_t)&v247, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("failed to report missingSubCCList: %@"), (char)v102);
                            }
                            else
                            {
                              v68 = 0;
                            }
                            if (CFDictionaryGetCount(v123) >= 1 && _CFDictionaryAddDictionary(v123, v215))
                            {
                              if (v215)
                                CFRelease(v215);
                              CFRetain(v123);
                              v215 = v123;
                            }
                            CFRelease(v123);
LABEL_331:
                            v8 = allocator;
                            v100 = v215;
LABEL_332:
                            v124 = (__CFError *)v247;
                            if (v247)
                            {
                              v125 = v100;
                              if (v69)
                              {
                                CFRelease(v69);
                                v124 = (__CFError *)v247;
                              }
                              v69 = _copyUnderlyingErrors(v124);
                              AMSupportLogInternal();
                              if (v247)
                              {
                                CFRelease(v247);
                                v247 = 0;
                              }
                              v100 = v125;
                            }
LABEL_338:
                            v66 = v100;
                            _buildReportWithKeyAndMessage(url, (uint64_t)v68, v100, v229, v225, theArray);
                            v288.length = CFArrayGetCount(v233);
                            v288.location = 0;
                            v126 = CFArrayGetFirstIndexOfValue(v233, v288, v93);
                            if (v126 != -1)
                              CFArrayRemoveValueAtIndex(v233, v126);
                            v289.length = CFArrayGetCount(v236);
                            v289.location = 0;
                            v127 = CFArrayGetFirstIndexOfValue(v236, v289, v93);
                            if (v127 != -1)
                              CFArrayRemoveValueAtIndex(v236, v127);
                            if (v95)
                              CFRelease(v95);
                            if (url)
                            {
                              CFRelease(url);
                              url = 0;
                            }
                            v73 = v226;
                            if (v243)
                            {
                              CFRelease(v243);
                              v243 = 0;
                            }
                            if (v101)
                              CFRelease(v101);
                            if (v102)
                              CFRelease(v102);
                            v67 = v227;
LABEL_353:
                            if (++v91 >= CFArrayGetCount(v67))
                            {
                              v7 = v214;
                              goto LABEL_228;
                            }
                            continue;
                          }
                          AMFDRErrorPushInternal((uint64_t)&v247, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("failed to create subCCReportDetails"), v200);
                        }
                        v68 = 0;
                        goto LABEL_331;
                      }
                      AMFDRErrorPushInternal((uint64_t)&v247, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyAndVerifySubCC", CFSTR("amfdr is NULL"), v200);
                    }
                    else
                    {
                      AMFDRErrorPushInternal((uint64_t)&v247, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyAndVerifySubCC", CFSTR("unexpected type for localManifestData: %@"), (char)v95);
                    }
                  }
                  else
                  {
                    AMFDRErrorPushInternal((uint64_t)&v247, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyAndVerifySubCC", CFSTR("unexpected type for sealingMapSubCCList: %@"), (char)v238);
                  }
                  v101 = 0;
                  v102 = 0;
                  goto LABEL_358;
                }
                break;
              }
              AMSupportLogInternal();
              v68 = 0;
              v66 = 0;
              goto LABEL_353;
            }
            v128 = CFSTR("_AMFDRSealingMapCopyDataClassesAndInstancesInternal for required to seal attribute failed");
          }
        }
        else
        {
          v128 = CFSTR("_AMFDRSealingMapCopyDataClassesAndInstancesInternal failed");
        }
        AMFDRErrorPushInternal((uint64_t)&v247, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyMinimalSealingManifestFullKeysForSealingMapEntry", v128, v200);
LABEL_373:
        v86 = 0;
        goto LABEL_215;
      }
      format = CFSTR("amfdr is NULL");
    }
    else
    {
      format = CFSTR("unexpected type sealingMapEntry: '%@'");
      v200 = (char)v73;
    }
    AMFDRErrorPushInternal((uint64_t)&v247, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCopyMinimalSealingManifestFullKeysForSealingMapEntry", format, v200);
    goto LABEL_373;
  }
  AMFDRErrorPushInternal((uint64_t)&cf, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreateDataReport", CFSTR("Failed to allocate currLiveFullKeys"), v200);
  v228 = 0;
LABEL_584:
  v137 = 0;
  MutableCopy = v233;
  v138 = v222;
  v136 = v229;
LABEL_405:
  v139 = v216;
  v140 = v66;
  if (v136)
  {
LABEL_406:
    v141 = v136;
    v142 = v140;
    CFRelease(v141);
    v140 = v142;
  }
LABEL_407:
  v143 = v140;
  if (v225)
  {
    CFRelease(v225);
    v140 = v143;
  }
  v56 = v228;
  if (v221)
  {
    CFRelease(v221);
    v140 = v143;
  }
  if (v139)
  {
    CFRelease(v139);
    v140 = v143;
  }
  if (MutableCopy)
  {
LABEL_414:
    v144 = MutableCopy;
    v145 = v140;
    CFRelease(v144);
    v140 = v145;
  }
LABEL_415:
  if (v236)
  {
    v146 = v140;
    CFRelease(v236);
    v140 = v146;
  }
  if (v140)
    CFRelease(v140);
LABEL_419:
  if (v249)
  {
    CFRelease(v249);
    v249 = 0;
  }
  if (v248)
  {
    CFRelease(v248);
    v248 = 0;
  }
  if (v138)
    CFRelease(v138);
  if (v247)
  {
    CFRelease(v247);
    v247 = 0;
  }
  if (v56)
    CFRelease(v56);
  if (v246)
  {
    CFRelease(v246);
    v246 = 0;
  }
  if (v220)
    CFRelease(v220);
  if (v245)
  {
    CFRelease(v245);
    v245 = 0;
  }
  if (v244)
  {
    CFRelease(v244);
    v244 = 0;
  }
  if (v68)
    CFRelease(v68);
  if (v69)
    CFRelease(v69);
  v147 = v210;
  if (v137 && (v148 = CFGetTypeID(v137), v148 == CFDictionaryGetTypeID()))
    _CFDictionaryAddDictionary(theDict, v137);
  else
    AMSupportLogInternal();
  v149 = theArray;
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  v239 = (const __CFDictionary *)v242;
  v249 = 0;
  url = 0;
  v150 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  v151 = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  v152 = CFArrayCreateMutable(v8, 0, v150);
  v153 = 0;
  v154 = CFSTR("Failed to allocate verifiedProperties/failureProperties");
  v240 = v152;
  v155 = 0;
  v156 = 0;
  if (!v151 || !v152)
    goto LABEL_606;
  key = v151;
  v153 = AMFDRCreateTypeWithOptions(allocator, CFSTR("Local"), v207);
  v234 = v137;
  if ((AMFDRSealingMapVerifySealingManifestPropertiesInternal(v153, 0, (CFTypeRef *)&url, (uint64_t)&v249) & 1) == 0
    && !url)
  {
    AMSupportLogInternal();
    CFArrayAppendValue(theArray, CFSTR("Properties"));
    v155 = 0;
    v156 = 0;
    goto LABEL_501;
  }
  if (!v249)
  {
    v155 = 0;
    v157 = v239;
    if (v239)
      goto LABEL_456;
    goto LABEL_466;
  }
  v155 = _copyUnderlyingErrors((__CFError *)v249);
  AMSupportLogInternal();
  v157 = v239;
  if (v249)
  {
    CFRelease(v249);
    v249 = 0;
  }
  if (!v239)
  {
LABEL_466:
    v156 = 0;
    goto LABEL_472;
  }
LABEL_456:
  v158 = CFDictionaryGetCount(v157);
  v159 = (const void **)malloc_type_malloc(8 * v158, 0x80040B8603338uLL);
  v160 = (const void **)malloc_type_malloc(8 * v158, 0x80040B8603338uLL);
  CFDictionaryGetKeysAndValues(v157, v159, v160);
  v237 = v160;
  v231 = v159;
  v161 = 0;
  if (v158 < 1)
  {
    v156 = 0;
    if (v159)
      goto LABEL_468;
  }
  else
  {
    v162 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
    v163 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
    v164 = (void **)v160;
    do
    {
      v165 = url;
      if (!url || (v291.length = CFArrayGetCount(url), v291.location = 0, !CFArrayContainsValue(v165, v291, *v159)))
      {
        if (v161)
          CFRelease(v161);
        values[0] = CFSTR("LiveProperty");
        BytePtr = *v164;
        v161 = CFDictionaryCreate(allocator, (const void **)values, (const void **)&BytePtr, 1, v162, v163);
        _buildReportWithKeyAndMessage(*v159, (uint64_t)CFSTR("VerifiedProperties"), v161, 0, key, theArray);
      }
      ++v159;
      ++v164;
      --v158;
    }
    while (v158);
LABEL_468:
    free(v231);
    v156 = v161;
  }
  if (v237)
    free(v237);
  v149 = theArray;
  v157 = v239;
LABEL_472:
  if (url && CFArrayGetCount(url) >= 1)
  {
    v166 = 0;
    do
    {
      if (v156)
        CFRelease(v156);
      v167 = (const __CFString *)CFArrayGetValueAtIndex(url, v166);
      HasAttribute = AMFDRSealingMapPropertyHasAttribute((uint64_t)v153, v167, CFSTR("Required"), 0);
      if (v157)
        v169 = (const __CFString *)CFDictionaryGetValue(v157, v167);
      else
        v169 = 0;
      v170 = (__CFString *)AMFDRSealingMapCopyPropertyWithTag(v153, v167, (uint64_t)&v249);
      v171 = (__CFError *)v249;
      if (v249)
      {
        if (v155)
        {
          CFRelease(v155);
          v171 = (__CFError *)v249;
        }
        v155 = _copyUnderlyingErrors(v171);
        AMSupportLogInternal();
        if (v249)
        {
          CFRelease(v249);
          v249 = 0;
        }
      }
      if (v170 || v169)
      {
        v173 = CFSTR("PropertyMismatched");
      }
      else
      {
        v172 = !HasAttribute;
        v173 = CFSTR("PropertyMismatched");
        if (!v172)
          v173 = CFStringCreateWithFormat(allocator, 0, CFSTR("%@: Property is required"), CFSTR("PropertyMismatched"));
      }
      *(_OWORD *)values = xmmword_24C69F580;
      *(_QWORD *)&v252 = CFSTR("FailureReason");
      if (v170)
        v174 = v170;
      else
        v174 = CFSTR("(NULL)");
      if (v169)
        v175 = v169;
      else
        v175 = CFSTR("(NULL)");
      BytePtr = v174;
      Length = v175;
      v282 = v173;
      v156 = CFDictionaryCreate(allocator, (const void **)values, (const void **)&BytePtr, 3, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      _buildReportWithKeyAndMessage(v167, (uint64_t)v173, v156, v240, 0, theArray);
      if (v173)
        CFRelease(v173);
      if (v170)
        CFRelease(v170);
      ++v166;
      v149 = theArray;
      v157 = v239;
    }
    while (v166 < CFArrayGetCount(url));
  }
LABEL_501:
  *(_OWORD *)values = xmmword_24C69F598;
  v151 = key;
  BytePtr = v240;
  Length = (const __CFString *)key;
  v176 = CFDictionaryCreate(allocator, (const void **)values, (const void **)&BytePtr, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v176)
  {
    v177 = v176;
    v147 = v210;
    v137 = v234;
    goto LABEL_503;
  }
  v154 = CFSTR("Failed to create outPropertyReport");
  v147 = v210;
  v137 = v234;
LABEL_606:
  AMFDRErrorPushInternal((uint64_t)&cf, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDiagnosticCreatePropertiesReport", v154, v200);
  v177 = 0;
LABEL_503:
  if (v240)
    CFRelease(v240);
  if (v151)
    CFRelease(v151);
  if (url)
  {
    CFRelease(url);
    url = 0;
  }
  if (v156)
    CFRelease(v156);
  if (v153)
    CFRelease(v153);
  if (v249)
  {
    CFRelease(v249);
    v249 = 0;
  }
  if (v155)
    CFRelease(v155);
  if (v177 && (v178 = CFGetTypeID(v177), v178 == CFDictionaryGetTypeID()))
  {
    _CFDictionaryAddDictionary(theDict, v177);
    v179 = allocator;
  }
  else
  {
    v292.length = CFArrayGetCount(v149);
    v292.location = 0;
    v179 = allocator;
    if (CFArrayContainsValue(v149, v292, CFSTR("Properties")))
      CFArrayAppendValue(v149, CFSTR("Properties"));
    AMSupportLogInternal();
  }
  if (v147 && v147[2] && (v180 = CFArrayCreateMutable(v179, 0, MEMORY[0x24BDBD690])) != 0)
  {
    v181 = v180;
    v182 = v149;
    v183 = (const __CFData *)CFDictionaryGetValue(v147[2], CFSTR("SealingManifest"));
    if (v183)
    {
      v184 = v183;
      v185 = CFArrayCreate(v179, (const void **)&sealingManifestPropertyTagsToQuery, 3, MEMORY[0x24BDBD690]);
      ManifestPropertyValueDict = _createManifestPropertyValueDict(v184, v185, CFSTR("seal"));
      if (ManifestPropertyValueDict)
        CFArrayAppendValue(v181, ManifestPropertyValueDict);
    }
    else
    {
      ManifestPropertyValueDict = 0;
      v185 = 0;
    }
    v187 = (const __CFDictionary *)CFDictionaryGetValue(v147[2], CFSTR("MinimalSealingManifests"));
    if (v187)
    {
      v188 = v187;
      v189 = CFGetTypeID(v187);
      if (v189 == CFDictionaryGetTypeID())
      {
        v179 = allocator;
        if (CFDictionaryGetCount(v188) >= 1)
        {
          if (v185)
            CFRelease(v185);
          v185 = CFArrayCreate(allocator, (const void **)&minimalManifestPropertyTagsToQuery, 3, MEMORY[0x24BDBD690]);
          values[0] = CFSTR("minimal-manifest");
          values[1] = v185;
          *(_QWORD *)&v252 = v181;
          CFDictionaryApplyFunction(v188, (CFDictionaryApplierFunction)_findAndAppendManifestPropertyValueDicts, values);
        }
      }
      else
      {
        v179 = allocator;
      }
    }
    if (CFArrayGetCount(v181) < 1)
    {
      v190 = 0;
    }
    else
    {
      values[0] = CFSTR("OtherData");
      BytePtr = v181;
      v190 = CFDictionaryCreate(v179, (const void **)values, (const void **)&BytePtr, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    }
    v191 = v211;
    CFRelease(v181);
    if (v185)
      CFRelease(v185);
    if (ManifestPropertyValueDict)
      CFRelease(ManifestPropertyValueDict);
    if (v190)
    {
      v192 = CFGetTypeID(v190);
      v149 = v182;
      if (v192 == CFDictionaryGetTypeID())
        _CFDictionaryAddDictionary(theDict, v190);
    }
    else
    {
      v149 = v182;
    }
  }
  else
  {
    AMSupportLogInternal();
    v190 = 0;
    v191 = v211;
  }
  CFDictionaryAddValue(theDict, CFSTR("DataFailedToReport"), v149);
  *v202 = CFRetain(theDict);
  AMFDRSealingMapSetKeyQueryRetry(1);
  CFRelease(theDict);
  if (v208)
    CFRelease(v208);
  if (v201)
    CFRelease(v201);
  CFRelease(v149);
  v193 = 1;
LABEL_553:
  if (v242)
  {
    CFRelease(v242);
    v242 = 0;
  }
  if (v204)
    CFRelease(v204);
  if (v206)
    CFRelease(v206);
  if (v191)
    CFRelease(v191);
  if (v203)
    CFRelease(v203);
  if (v147)
    CFRelease(v147);
  if (v177)
    CFRelease(v177);
  if (v137)
    CFRelease(v137);
  if (v190)
    CFRelease(v190);
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v212)
    CFRelease(v212);
  if (v205)
    CFRelease(v205);
  return v193;
}

CFTypeRef _copyUnderlyingErrors(__CFError *a1)
{
  CFMutableStringRef Mutable;
  __CFString *v3;
  const void *v4;
  const void *v5;
  CFIndex Code;
  CFErrorDomain Domain;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const void *Value;
  CFTypeRef v11;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  if (Mutable)
  {
    v3 = Mutable;
    if (a1)
    {
      v4 = (const void *)*MEMORY[0x24BDBD378];
      v5 = (const void *)*MEMORY[0x24BDBD3B0];
      do
      {
        Code = CFErrorGetCode(a1);
        Domain = CFErrorGetDomain(a1);
        v8 = CFErrorCopyUserInfo(a1);
        v9 = v8;
        if (v8)
        {
          Value = CFDictionaryGetValue(v8, v4);
          a1 = (__CFError *)CFDictionaryGetValue(v9, v5);
        }
        else
        {
          a1 = 0;
          Value = 0;
        }
        if (CFStringGetLength(v3))
          CFStringAppendFormat(v3, 0, CFSTR("; Domain=%@ Description=%@ code=%ld"), Domain, Value, Code);
        else
          CFStringAppendFormat(v3, 0, CFSTR("Domain=%@ Description=%@ code=%ld"), Domain, Value, Code);
        if (v9)
          CFRelease(v9);
      }
      while (a1);
    }
    if (CFStringGetLength(v3) < 1)
      v11 = 0;
    else
      v11 = CFRetain(v3);
    CFRelease(v3);
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
  return v11;
}

BOOL _stringTagToDERTag(CFStringRef theString, _QWORD *a2)
{
  const __CFData *ExternalRepresentation;
  const __CFData *v4;
  CFIndex Length;
  _BOOL8 v6;
  unsigned int *BytePtr;

  if (theString
    && (ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x24BDBD240], theString, 0x8000100u, 0x5Fu)) != 0)
  {
    v4 = ExternalRepresentation;
    Length = CFDataGetLength(ExternalRepresentation);
    v6 = Length == 4;
    if (Length == 4)
    {
      BytePtr = (unsigned int *)CFDataGetBytePtr(v4);
      *a2 = AMFDRTagsStringToTag(BytePtr);
    }
    else
    {
      AMSupportLogInternal();
    }
    CFRelease(v4);
  }
  else
  {
    AMSupportLogInternal();
    return 0;
  }
  return v6;
}

uint64_t _copySealingManifestProperty(const __CFData *a1, const __CFString *a2, CFDataRef *a3)
{
  __int128 v6;
  int ObjectPropertyData;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  unint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a3)
    {
      v38 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v36 = v6;
      v37 = v6;
      v34 = v6;
      v35 = v6;
      v32 = v6;
      v33 = v6;
      v30 = v6;
      v31 = v6;
      v28 = v6;
      v29 = v6;
      v26 = v6;
      v27 = v6;
      v24 = v6;
      v25 = v6;
      v22 = v6;
      v23 = v6;
      v20 = v6;
      v21 = v6;
      v18 = v6;
      v19 = v6;
      v17 = v6;
      v15 = v6;
      v16 = v6;
      v13 = v6;
      v14 = v6;
      v11 = v6;
      v12 = v6;
      v10 = v6;
      CFDataGetBytePtr(a1);
      CFDataGetLength(a1);
      if (!Img4DecodeInitManifest())
      {
        v9 = 0xAAAAAAAAAAAAAAAALL;
        if (_stringTagToDERTag(a2, &v9))
        {
          ObjectPropertyData = Img4DecodeGetObjectPropertyData();
          if (!ObjectPropertyData)
          {
            *a3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], (const UInt8 *)0xAAAAAAAAAAAAAAAALL, 0xAAAAAAAAAAAAAAAALL);
            return 1;
          }
          if (ObjectPropertyData == 1)
          {
            AMSupportLogInternal();
            return 1;
          }
        }
      }
    }
  }
  AMSupportLogInternal();
  return 0;
}

uint64_t _createFullKeysForDataInstances(CFArrayRef theArray, const void *a2, CFTypeRef *a3)
{
  CFTypeID v6;
  CFTypeID v7;
  const __CFAllocator *v8;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v10;
  CFTypeID v11;
  CFIndex Count;
  CFIndex v13;
  const void *v14;
  CFStringRef FullKey;
  CFTypeID v16;
  const void *ValueAtIndex;
  CFTypeID v18;
  const void *v19;

  if (!a3
    || !theArray
    || CFArrayGetCount(theArray) <= 0
    || !a2
    || (v6 = CFGetTypeID(a2), v6 != CFStringGetTypeID()) && (v7 = CFGetTypeID(a2), v7 != CFArrayGetTypeID())
    || (v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240],
        (Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690])) == 0))
  {
    AMSupportLogInternal();
    return 0;
  }
  v10 = Mutable;
  v11 = CFGetTypeID(a2);
  if (v11 == CFArrayGetTypeID())
  {
    Count = CFArrayGetCount((CFArrayRef)a2);
    if (Count != CFArrayGetCount(theArray))
    {
      AMSupportLogInternal();
      CFRelease(v10);
      return 0;
    }
  }
  if (CFArrayGetCount(theArray) < 1)
  {
    FullKey = 0;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    FullKey = 0;
    do
    {
      if (FullKey)
        CFRelease(FullKey);
      v16 = CFGetTypeID(a2);
      ValueAtIndex = a2;
      if (v16 != CFStringGetTypeID())
      {
        v18 = CFGetTypeID(a2);
        ValueAtIndex = v14;
        if (v18 == CFArrayGetTypeID())
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v13);
      }
      v19 = CFArrayGetValueAtIndex(theArray, v13);
      FullKey = AMFDRDataLocalCreateFullKey(v8, (uint64_t)ValueAtIndex, (uint64_t)v19);
      if (FullKey)
        CFArrayAppendValue(v10, FullKey);
      else
        AMSupportLogInternal();
      ++v13;
      v14 = ValueAtIndex;
    }
    while (v13 < CFArrayGetCount(theArray));
  }
  *a3 = CFRetain(v10);
  CFRelease(v10);
  if (FullKey)
    CFRelease(FullKey);
  return 1;
}

void _buildReportWithKeyAndMessage(const void *a1, uint64_t a2, const __CFDictionary *a3, __CFArray *a4, __CFArray *a5, __CFArray *a6)
{
  const __CFAllocator *v12;
  CFMutableDictionaryRef Mutable;
  void *v14;
  __CFArray *v15;
  CFStringRef v16;

  if (a3)
  {
    v12 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (Mutable)
    {
      v14 = Mutable;
      if (CFDictionaryGetCount(a3) < 1)
      {
LABEL_9:
        CFRelease(v14);
        return;
      }
      CFDictionarySetValue((CFMutableDictionaryRef)v14, a1, a3);
      if (CFDictionaryContainsKey(a3, CFSTR("WarningMessage")) || CFDictionaryContainsKey(a3, CFSTR("FailureReason")))
      {
        if (a4)
        {
LABEL_7:
          v15 = a4;
LABEL_8:
          CFArrayAppendValue(v15, v14);
          goto LABEL_9;
        }
      }
      else
      {
        a4 = a5;
        if (a5)
          goto LABEL_7;
      }
      AMSupportLogInternal();
      CFRelease(v14);
    }
    else
    {
      AMSupportLogInternal();
    }
  }
  else
  {
    AMSupportLogInternal();
    v12 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  }
  v16 = CFStringCreateWithFormat(v12, 0, CFSTR("_buildReportWithKey failed for %@: %@"), a1, a2);
  if (v16)
  {
    v14 = (void *)v16;
    v15 = a6;
    goto LABEL_8;
  }
}

CFDictionaryRef _createManifestPropertyValueDict(const __CFData *a1, const __CFArray *a2, void *a3)
{
  const __CFAllocator *v6;
  __CFArray *Mutable;
  CFIndex v8;
  CFDictionaryRef v9;
  const CFDictionaryValueCallBacks *v10;
  const __CFString *ValueAtIndex;
  CFDictionaryRef v12;
  CFTypeRef cf;
  void *values[2];
  void *keys[2];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  cf = 0;
  v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  if (Mutable)
  {
    if (CFArrayGetCount(a2) >= 1)
    {
      v8 = 0;
      v9 = 0;
      v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
      while (1)
      {
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        if (v9)
          CFRelease(v9);
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v8);
        if ((_copySealingManifestProperty(a1, ValueAtIndex, (CFDataRef *)&cf) & 1) != 0)
        {
          if (cf)
          {
            keys[0] = (void *)ValueAtIndex;
            values[0] = (void *)cf;
            v9 = CFDictionaryCreate(v6, (const void **)keys, (const void **)values, 1, MEMORY[0x24BDBD6A0], v10);
            if (v9)
              CFArrayAppendValue(Mutable, v9);
            else
              AMSupportLogInternal();
            goto LABEL_14;
          }
        }
        else
        {
          AMSupportLogInternal();
        }
        v9 = 0;
LABEL_14:
        if (CFArrayGetCount(a2) <= ++v8)
          goto LABEL_18;
      }
    }
    v9 = 0;
LABEL_18:
    if (CFArrayGetCount(Mutable) < 1)
    {
      v12 = 0;
    }
    else
    {
      *(_OWORD *)keys = xmmword_24C69F5D8;
      values[0] = a3;
      values[1] = Mutable;
      v12 = CFDictionaryCreate(v6, (const void **)keys, (const void **)values, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    }
  }
  else
  {
    AMSupportLogInternal();
    v12 = 0;
    v9 = 0;
  }
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v9)
    CFRelease(v9);
  if (Mutable)
    CFRelease(Mutable);
  return v12;
}

void _findAndAppendManifestPropertyValueDicts(uint64_t a1, const __CFData *a2, uint64_t *a3)
{
  void *v4;
  const __CFArray *v5;
  __CFArray *v6;
  CFStringRef FullKey;
  CFDictionaryRef ManifestPropertyValueDict;

  v4 = (void *)a1;
  v5 = (const __CFArray *)a3[1];
  v6 = (__CFArray *)a3[2];
  FullKey = AMFDRDataLocalCreateFullKey((const __CFAllocator *)*MEMORY[0x24BDBD240], *a3, a1);
  if (FullKey)
    v4 = (void *)FullKey;
  ManifestPropertyValueDict = _createManifestPropertyValueDict(a2, v5, v4);
  if (ManifestPropertyValueDict)
    CFArrayAppendValue(v6, ManifestPropertyValueDict);
  if (v4)
    CFRelease(v4);
  if (ManifestPropertyValueDict)
    CFRelease(ManifestPropertyValueDict);
}

uint64_t AMFDRSealedDataGetTypeID()
{
  pthread_once(&_AMFDRSealedDataClassInitializeOnce, (void (*)(void))_AMFDRSealedDataClassInitialize);
  return _AMFDRSealedDataTypeID;
}

uint64_t _AMFDRSealedDataClassInitialize()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  _AMFDRSealedDataTypeID = result;
  return result;
}

double AMFDRSealedDataCreate()
{
  _OWORD *Instance;
  double result;

  pthread_once(&_AMFDRSealedDataClassInitializeOnce, (void (*)(void))_AMFDRSealedDataClassInitialize);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    result = 0.0;
    Instance[17] = 0u;
    Instance[18] = 0u;
    Instance[15] = 0u;
    Instance[16] = 0u;
    Instance[13] = 0u;
    Instance[14] = 0u;
    Instance[11] = 0u;
    Instance[12] = 0u;
    Instance[9] = 0u;
    Instance[10] = 0u;
    Instance[7] = 0u;
    Instance[8] = 0u;
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[1] = 0u;
    Instance[2] = 0u;
  }
  return result;
}

uint64_t AMFDRGetUnderlyingErrorCode(uint64_t a1, CFErrorRef *a2)
{
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  const void *v6;
  __CFError *Value;
  __CFError *v8;
  CFIndex Code;
  const __CFDictionary *v10;

  if (a2 && *a2)
  {
    if (!a1 || !*(_QWORD *)(a1 + 16))
    {
      AMSupportLogInternal();
      return 1;
    }
    v4 = CFErrorCopyUserInfo(*a2);
    if (!v4)
      return 10;
    v5 = v4;
    v6 = (const void *)*MEMORY[0x24BDBD3B0];
    Value = (__CFError *)CFDictionaryGetValue(v4, (const void *)*MEMORY[0x24BDBD3B0]);
    if (Value)
    {
      v8 = Value;
      while (1)
      {
        CFRelease(v5);
        Code = CFErrorGetCode(v8);
        v10 = CFErrorCopyUserInfo(v8);
        if (!v10)
          return 10;
        v5 = v10;
        v8 = (__CFError *)CFDictionaryGetValue(v10, v6);
        if (!v8)
          goto LABEL_14;
      }
    }
    Code = 199;
LABEL_14:
    if (Code != 4)
    {
      if (Code != 7)
      {
LABEL_19:
        if (Code == 199)
          Code = CFErrorGetCode(*a2);
        goto LABEL_22;
      }
      if (!*(_QWORD *)(a1 + 80))
      {
        Code = 7;
LABEL_22:
        CFRelease(v5);
        return Code;
      }
    }
    if (*(uint64_t (***)(int, int, int, int))(a1 + 48) != AMFDRHTTPStore)
      Code = 404;
    goto LABEL_19;
  }
  return 199;
}

uint64_t AMFDRSealedDataMultiManifestPopulate(uint64_t a1, uint64_t a2, CFDataRef theData, __CFArray *a4, uint64_t a5)
{
  CFStringRef FullKey;
  CFStringRef v10;
  const void *v11;
  const __CFAllocator *v12;
  const __CFAllocator *v13;
  const __CFArray *v14;
  CFIndex Count;
  CFIndex v16;
  CFIndex v17;
  const void *ValueAtIndex;
  const void *v19;
  const __CFAllocator *v20;
  uint64_t v21;
  const __CFAllocator *v22;
  const __CFAllocator *v23;
  const __CFArray *v24;
  CFIndex v25;
  CFIndex v26;
  CFIndex v27;
  const void *v28;
  uint64_t v29;
  const __CFAllocator *v30;
  const __CFAllocator *v31;
  const void *v32;
  const void *v33;
  uint64_t v34;
  const __CFString *format;
  const __CFString *v37;
  char v38;
  CFTypeRef cf;
  CFMutableDictionaryRef theDict;
  CFTypeRef v41;

  theDict = 0;
  v41 = 0;
  cf = 0;
  if (!a2)
  {
    v37 = CFSTR("amfdr is NULL");
LABEL_85:
    AMFDRErrorPushInternal(a5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataMultiManifestPopulate", v37, v38);
LABEL_86:
    v34 = 0;
    FullKey = 0;
LABEL_87:
    v10 = 0;
    goto LABEL_88;
  }
  if (!*(_QWORD *)(a2 + 16))
  {
    v37 = CFSTR("amfdr option is NULL");
    goto LABEL_85;
  }
  if (!theData)
  {
LABEL_9:
    FullKey = 0;
    v10 = 0;
    v11 = 0;
LABEL_60:
    v33 = *(const void **)(a1 + 16);
    if (v33)
    {
      CFRelease(v33);
      *(_QWORD *)(a1 + 16) = 0;
    }
    *(_QWORD *)(a1 + 16) = AMSupportSafeRetain();
    AMFDRSetOption(a2, CFSTR("SealingManifest"), (const __CFString *)v41);
    v34 = 1;
    goto LABEL_63;
  }
  if ((AMFDRDataDecodeAndSetSealingManifest((_QWORD *)a2, theData, *(_QWORD *)(a1 + 80), &v41, (CFTypeRef *)&theDict, a5) & 1) == 0)
  {
    v37 = CFSTR("AMFDRDataDecodeAndSetSealingManifest failed");
    goto LABEL_85;
  }
  if (!*(_QWORD *)(a1 + 136) && !*(_QWORD *)(a1 + 176))
    goto LABEL_9;
  if (theDict)
  {
    FullKey = 0;
    goto LABEL_13;
  }
  v12 = CFGetAllocator((CFTypeRef)a2);
  theDict = CFDictionaryCreateMutable(v12, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataMultiManifestPopulate", CFSTR("valueDataDict is NULL"), v38);
    goto LABEL_86;
  }
  v13 = CFGetAllocator((CFTypeRef)a2);
  FullKey = AMFDRDataLocalCreateFullKey(v13, (uint64_t)CFSTR("sreq"), *(_QWORD *)(a1 + 80));
  if (!FullKey)
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataMultiManifestPopulate", CFSTR("failed to create data instance string"), v38);
    v34 = 0;
    goto LABEL_87;
  }
  CFDictionarySetValue(theDict, FullKey, v41);
LABEL_13:
  if (*(uint64_t (***)(int, int, int, int))(a2 + 48) == AMFDRHTTPStore)
  {
    v10 = 0;
    v11 = 0;
LABEL_57:
    v32 = *(const void **)(a1 + 152);
    if (v32)
    {
      CFRelease(v32);
      *(_QWORD *)(a1 + 152) = 0;
    }
    *(_QWORD *)(a1 + 152) = CFRetain(theDict);
    goto LABEL_60;
  }
  v14 = *(const __CFArray **)(a1 + 136);
  if (v14)
  {
    Count = CFArrayGetCount(v14);
    if (Count >= 1)
    {
      v16 = Count;
      v17 = 0;
      v11 = 0;
      v10 = 0;
      while (1)
      {
        if (v10)
          CFRelease(v10);
        if (v11)
          CFRelease(v11);
        if (FullKey)
          CFRelease(FullKey);
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 136), v17);
        v19 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), v17);
        v20 = CFGetAllocator((CFTypeRef)a2);
        v10 = CFStringCreateWithFormat(v20, 0, CFSTR("%@-%@"), CFSTR("manifest"), ValueAtIndex);
        if (!v10)
          break;
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        v21 = (*(uint64_t (**)(uint64_t, CFStringRef, const void *, CFTypeRef *))(*(_QWORD *)(a2 + 48) + 16))(a2, v10, v19, &cf);
        v11 = (const void *)v21;
        if (cf || !v21)
        {
          AMSupportLogInternal();
          if (a4)
          {
            v23 = CFGetAllocator((CFTypeRef)a2);
            FullKey = AMFDRDataLocalCreateFullKey(v23, (uint64_t)v10, (uint64_t)v19);
            if (!FullKey)
            {
              format = CFSTR("failed to create currDataInstance");
              goto LABEL_81;
            }
            CFArrayAppendValue(a4, FullKey);
          }
          else
          {
            FullKey = 0;
          }
        }
        else
        {
          v22 = CFGetAllocator((CFTypeRef)a2);
          FullKey = AMFDRDataLocalCreateFullKey(v22, (uint64_t)ValueAtIndex, (uint64_t)v19);
          if (!FullKey)
          {
            format = CFSTR("failed to  create data instance string");
            goto LABEL_81;
          }
          CFDictionarySetValue(theDict, FullKey, v11);
          AMSupportLogInternal();
        }
        if (v16 == ++v17)
          goto LABEL_37;
      }
      AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataMultiManifestPopulate", CFSTR("failed to create multiManifestDataClass"), a5);
      v34 = 0;
      FullKey = 0;
LABEL_88:
      v11 = 0;
      goto LABEL_63;
    }
  }
  v10 = 0;
  v11 = 0;
LABEL_37:
  v24 = *(const __CFArray **)(a1 + 176);
  if (!v24)
    goto LABEL_57;
  v25 = CFArrayGetCount(v24);
  if (v25 < 1)
    goto LABEL_57;
  v26 = v25;
  v27 = 0;
  while (1)
  {
    if (v11)
      CFRelease(v11);
    if (FullKey)
      CFRelease(FullKey);
    v28 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), v27);
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    v29 = (*(uint64_t (**)(uint64_t, const __CFString *, const void *, CFTypeRef *))(*(_QWORD *)(a2 + 48) + 16))(a2, CFSTR("minimal-manifest"), v28, &cf);
    v11 = (const void *)v29;
    if (cf || !v29)
      break;
    v30 = CFGetAllocator((CFTypeRef)a2);
    FullKey = AMFDRDataLocalCreateFullKey(v30, (uint64_t)CFSTR("minimal-manifest"), (uint64_t)v28);
    if (!FullKey)
    {
      format = CFSTR("failed to create data instance string");
      goto LABEL_81;
    }
    CFDictionarySetValue(theDict, FullKey, v11);
    AMSupportLogInternal();
LABEL_54:
    if (v26 == ++v27)
      goto LABEL_57;
  }
  if (!a4)
  {
    FullKey = 0;
    goto LABEL_54;
  }
  v31 = CFGetAllocator((CFTypeRef)a2);
  FullKey = AMFDRDataLocalCreateFullKey(v31, (uint64_t)CFSTR("minimal-manifest"), (uint64_t)v28);
  if (FullKey)
  {
    AMSupportLogInternal();
    CFArrayAppendValue(a4, FullKey);
    goto LABEL_54;
  }
  format = CFSTR("failed to create currDataInstance");
LABEL_81:
  AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataMultiManifestPopulate", format, a5);
  v34 = 0;
LABEL_63:
  if (v41)
  {
    CFRelease(v41);
    v41 = 0;
  }
  if (FullKey)
    CFRelease(FullKey);
  if (theDict)
  {
    CFRelease(theDict);
    theDict = 0;
  }
  if (v11)
    CFRelease(v11);
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v10)
    CFRelease(v10);
  return v34;
}

uint64_t AMFDRSealedDataPopulate(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t cf, unint64_t a6, uint64_t a7)
{
  return __AMFDRSealedDataPopulatePrivate(0, a1, a2, a3, a4, cf, a6, a7);
}

uint64_t __AMFDRSealedDataPopulatePrivate(const __CFDictionary *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, unint64_t cf, unint64_t a7, uint64_t a8)
{
  CFTypeRef *v8;
  uint64_t v9;
  uint64_t v11;
  CFTypeID v16;
  CFTypeID v17;
  CFIndex v18;
  uint64_t v19;
  const __CFArray *v20;
  CFIndex v21;
  CFIndex v22;
  const __CFArray *v23;
  const __CFString *v24;
  __CFArray *v25;
  __CFArray *v26;
  const __CFArray *v27;
  CFIndex v28;
  CFIndex v29;
  const __CFArray *v30;
  uint64_t v31;
  const __CFArray *v32;
  const __CFAllocator *v33;
  const __CFArray *v34;
  CFIndex v35;
  const __CFAllocator *v36;
  const __CFAllocator *v37;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFArray *v40;
  CFIndex FirstIndexOfValue;
  const void *v42;
  CFTypeID v43;
  const void *v44;
  CFTypeID v45;
  const void *v46;
  const __CFAllocator *v47;
  const CFArrayCallBacks *v48;
  CFMutableArrayRef v49;
  const __CFAllocator *v50;
  CFMutableArrayRef v51;
  __CFArray *v52;
  const __CFBoolean *v53;
  const __CFBoolean *v54;
  CFTypeID v55;
  uint64_t v56;
  const __CFBoolean *v57;
  const __CFBoolean *v58;
  const __CFBoolean *v59;
  CFTypeID v60;
  BOOL v61;
  const __CFBoolean *v62;
  const __CFBoolean *v63;
  CFTypeID v64;
  _BOOL4 v65;
  const __CFBoolean *v66;
  const __CFBoolean *v67;
  CFTypeID v68;
  const __CFBoolean *v69;
  const __CFBoolean *v70;
  CFTypeID v71;
  _BOOL4 v72;
  const __CFArray *v73;
  const __CFString *v74;
  void *v75;
  const void *v76;
  CFIndex v77;
  CFIndex v78;
  const __CFAllocator *v79;
  const __CFAllocator *v80;
  CFMutableArrayRef v81;
  const __CFAllocator *v82;
  const __CFAllocator *v83;
  CFMutableArrayRef v84;
  int *v85;
  const __CFString *v86;
  const __CFDictionary *v87;
  CFIndex v88;
  CFIndex v89;
  const __CFAllocator *v90;
  CFMutableDictionaryRef v91;
  const void **v92;
  const void **v93;
  void **v94;
  uint64_t v95;
  const __CFDictionary *v96;
  CFTypeID v97;
  const __CFAllocator *v98;
  __CFDictionary *MutableCopy;
  __CFDictionary *v100;
  CFIndex j;
  const void *v102;
  const void *v103;
  const void *v104;
  const __CFDictionary *v105;
  __CFDictionary *v106;
  const __CFDictionary *v107;
  CFIndex v108;
  CFStringRef FullKey;
  const __CFData *v110;
  const void *v111;
  const void *v112;
  const void *v113;
  const UInt8 *v114;
  const __CFAllocator *v115;
  const __CFData *v116;
  const __CFData *v117;
  CFTypeID v118;
  const UInt8 *v119;
  BOOL v120;
  const __CFDictionary *v121;
  uint64_t v122;
  CFIndex v123;
  const __CFData *v124;
  const void *v125;
  const void *v126;
  uint64_t v127;
  const __CFAllocator *v128;
  BOOL v129;
  const __CFAllocator *v130;
  const void *v131;
  __CFDictionary *v132;
  const __CFDictionary *v133;
  const __CFDictionary *v134;
  CFTypeID v135;
  const __CFData *v136;
  const __CFData *v137;
  const __CFArray *v138;
  char v139;
  const __CFData *DataWithManifests;
  const __CFData *v141;
  const __CFData *v142;
  const __CFData *v143;
  CFTypeID v144;
  const UInt8 *BytePtr;
  const __CFDictionary *v147;
  const __CFDictionary *v148;
  const void *v149;
  const void *v150;
  const __CFAllocator *v151;
  __CFArray *v152;
  const __CFAllocator *v153;
  CFMutableArrayRef v154;
  __CFArray *v155;
  CFIndex v156;
  const void *v157;
  const void *v158;
  const void *v159;
  const void *v160;
  CFTypeID v161;
  const __CFArray *v162;
  const __CFArray *v163;
  const __CFArray *v164;
  const __CFDictionary *v165;
  const __CFDictionary *v166;
  int v167;
  const void **v168;
  const __CFDictionary *v169;
  const void *v170;
  uint64_t v171;
  const void **v172;
  const __CFAllocator *v173;
  const void *v174;
  const __CFData *v175;
  char v176;
  int v177;
  __CFError *v178;
  CFIndex Code;
  uint64_t v180;
  CFIndex v181;
  const __CFAllocator *v182;
  const __CFArray *v183;
  uint64_t v184;
  uint64_t v185;
  const __CFDictionary *v186;
  const void *v187;
  int DataFromFileURL;
  uint64_t v189;
  void **v190;
  CFIndex v191;
  uint64_t v192;
  const __CFString *v193;
  const __CFString *v194;
  const __CFString *v195;
  const __CFAllocator *v196;
  const void *v197;
  const void *v198;
  CFTypeID v199;
  const void *v200;
  void *v201;
  char v202;
  __CFDictionary *v203;
  const __CFAllocator *v204;
  const __CFArray *v205;
  _BOOL4 v206;
  const __CFArray *v207;
  BOOL v208;
  CFIndex v209;
  CFIndex v210;
  __CFArray *v211;
  __CFError *v212;
  CFIndex v213;
  uint64_t v214;
  const __CFBoolean *v215;
  CFMutableArrayRef v216;
  CFTypeRef *v217;
  const __CFBoolean *v218;
  CFTypeID v219;
  uint64_t (*v220)(CFAllocatorRef, uint64_t, uint64_t, uint64_t, uint64_t, const __CFDictionary **);
  CFAllocatorRef v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  char v226;
  const __CFDictionary *v227;
  CFDataRef v229;
  const __CFString *v230;
  const __CFString *v231;
  const __CFString *v232;
  const __CFString *v233;
  const __CFString *v234;
  const __CFString *v235;
  const __CFString *v236;
  uint64_t v237;
  CFIndex v238;
  const __CFString *v239;
  void *value[2];
  void *v241[2];
  __int128 v242;
  const __CFString *format;
  char Count;
  char v245;
  char v246;
  __CFArray *v247;
  const __CFArray *v248;
  BOOL v249;
  const void **v250;
  BOOL v251;
  CFTypeRef v252;
  CFTypeRef v253;
  __CFArray *v254;
  void **values;
  void **valuesa;
  char v257;
  const __CFBoolean *v258;
  char v259;
  const __CFDictionary *v260;
  BOOL v261;
  const __CFData *cfa;
  const __CFDictionary *cfb;
  const __CFData *v264;
  int *v265;
  __CFArray *v266;
  _BOOL4 v267;
  __CFArray *Mutable;
  __CFArray *theArray;
  __CFDictionary *theDict;
  BOOL theDicta;
  CFMutableArrayRef v272;
  char v273;
  CFDictionaryRef v274;
  const __CFDictionary *v275;
  __CFArray *v276;
  __CFArray *v277;
  _BOOL4 v278;
  const __CFDictionary *v279;
  int v280;
  int v281;
  __CFArray *v282;
  uint64_t v283;
  __CFDictionary *v284;
  const __CFArray *v285;
  CFTypeRef *v286;
  BOOL v288;
  CFTypeRef v289;
  const void *v290;
  const __CFDictionary *v291;
  const __CFDictionary *v292;
  CFTypeRef v293;
  const __CFString *v294;
  CFTypeRef v295;
  CFTypeRef v296;
  CFErrorRef v297;
  unint64_t v298;
  uint64_t v299;
  CFRange v300;
  CFRange v301;
  CFRange v302;
  CFRange v303;
  CFRange v304;
  CFRange v305;
  CFRange v306;

  v8 = (CFTypeRef *)a8;
  v299 = *MEMORY[0x24BDAC8D0];
  v293 = 0;
  v294 = 0;
  v291 = 0;
  v292 = 0;
  v289 = 0;
  v290 = 0;
  v288 = 0;
  if (!a2)
  {
    v24 = CFSTR("amfdr is NULL");
    goto LABEL_21;
  }
  v9 = a3;
  if (!a3)
  {
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("amfdr is NULL"), Count);
    v25 = 0;
    v26 = 0;
    v264 = 0;
    goto LABEL_443;
  }
  if (!*(_QWORD *)(a3 + 16))
  {
    v24 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_21;
  }
  v11 = *(_QWORD *)(a2 + 32);
  if (!(cf | v11))
    goto LABEL_102;
  if (!(a7 | *(_QWORD *)(a2 + 40)))
    goto LABEL_487;
  if (!(a4 | *(_QWORD *)(a2 + 72)))
  {
    v24 = CFSTR("sealedDataClass is NULL");
    goto LABEL_21;
  }
  if (!(a5 | *(_QWORD *)(a2 + 80)))
  {
    v24 = CFSTR("sealedDataInstance is NULL");
    goto LABEL_21;
  }
  if (cf)
  {
    v16 = CFGetTypeID((CFTypeRef)cf);
    if (v16 != CFArrayGetTypeID())
    {
      v24 = CFSTR("dataClassArray must be a CFArray");
      goto LABEL_21;
    }
    if (!a7)
      goto LABEL_20;
    goto LABEL_13;
  }
  if (!a7)
  {
    v19 = a2;
    if (v11)
      goto LABEL_25;
LABEL_102:
    v24 = CFSTR("dataClassArray is NULL");
    goto LABEL_21;
  }
LABEL_13:
  v17 = CFGetTypeID((CFTypeRef)a7);
  if (v17 != CFArrayGetTypeID())
  {
    v24 = CFSTR("dataInstanceArray must be a CFArray");
    goto LABEL_21;
  }
  if (!cf || (v18 = CFArrayGetCount((CFArrayRef)cf), v18 != CFArrayGetCount((CFArrayRef)a7)))
  {
LABEL_20:
    Count = CFArrayGetCount((CFArrayRef)cf);
    CFArrayGetCount((CFArrayRef)a7);
    v24 = CFSTR("dataClassArray length (%ld) does not match dataInstanceArray (%ld)");
    goto LABEL_21;
  }
  v19 = a2;
  v20 = *(const __CFArray **)(a2 + 32);
  if (v20)
  {
    v21 = CFArrayGetCount(v20);
    v22 = CFArrayGetCount((CFArrayRef)cf);
    v23 = *(const __CFArray **)(a2 + 32);
    if (v21 != v22)
    {
      Count = CFArrayGetCount(v23);
      CFArrayGetCount((CFArrayRef)cf);
      v24 = CFSTR("sealedData->dataClassArray length (%ld) does not match dataClassArray (%ld)");
      goto LABEL_21;
    }
    v19 = a2;
    if (!CFEqual(v23, (CFTypeRef)cf))
    {
      v24 = CFSTR("sealedData->dataClassArray does not match dataClassArray contents.");
LABEL_21:
      AMFDRErrorPushInternal((uint64_t)v8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", v24, Count);
LABEL_22:
      v25 = 0;
      v26 = 0;
      v264 = 0;
      LOBYTE(v9) = 0;
      goto LABEL_443;
    }
  }
  else
  {
    *(_QWORD *)(a2 + 32) = CFRetain((CFTypeRef)cf);
  }
LABEL_25:
  v27 = *(const __CFArray **)(v19 + 40);
  if (!v27)
  {
    if (a7)
    {
      *(_QWORD *)(v19 + 40) = CFRetain((CFTypeRef)a7);
      goto LABEL_32;
    }
LABEL_487:
    v24 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_21;
  }
  if (a7)
  {
    v28 = CFArrayGetCount(v27);
    v29 = CFArrayGetCount((CFArrayRef)a7);
    v30 = *(const __CFArray **)(v19 + 40);
    if (v28 != v29)
    {
      Count = CFArrayGetCount(v30);
      CFArrayGetCount((CFArrayRef)a7);
      v24 = CFSTR("sealedData->dataInstanceArray length (%ld) does not match dataInstanceArray (%ld)");
      goto LABEL_21;
    }
    v19 = a2;
    if (!CFEqual(v30, (CFTypeRef)a7))
    {
      v24 = CFSTR("sealedData->dataInstanceArray does not match dataInstanceArray contents.");
      goto LABEL_21;
    }
  }
LABEL_32:
  v31 = CFArrayGetCount(*(CFArrayRef *)(v19 + 32));
  v32 = *(const __CFArray **)(v19 + 64);
  if (v32)
  {
    if (CFArrayGetCount(v32) != v31)
    {
      Count = CFArrayGetCount(*(CFArrayRef *)(v19 + 64));
      v24 = CFSTR("sealedData->dataArray length (%ld) does not match countToSeal (%ld)");
      goto LABEL_21;
    }
  }
  else
  {
    v33 = CFGetAllocator((CFTypeRef)v9);
    *(_QWORD *)(v19 + 64) = CFArrayCreateMutable(v33, v31, &kCFArrayCallBacksAllowNULL);
  }
  v286 = v8;
  if (!*(_QWORD *)(v19 + 136) || !*(_QWORD *)(v19 + 144))
  {
    v34 = *(const __CFArray **)(v19 + 288);
    if (v34)
    {
      if (CFArrayGetCount(v34) >= 1)
      {
        v35 = CFArrayGetCount(*(CFArrayRef *)(v19 + 288));
        v36 = CFGetAllocator((CFTypeRef)v9);
        theArray = CFArrayCreateMutable(v36, 0, MEMORY[0x24BDBD690]);
        if (!theArray)
        {
          AMFDRErrorPushInternal((uint64_t)v8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("mutableMultiSealingDataClasses is NULL"), Count);
          goto LABEL_22;
        }
        v252 = (CFTypeRef)v31;
        v37 = CFGetAllocator((CFTypeRef)v9);
        Mutable = CFArrayCreateMutable(v37, 0, MEMORY[0x24BDBD690]);
        if (!Mutable)
        {
          AMFDRErrorPushInternal((uint64_t)v8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("mutableMultiSealingDataInstances is NULL"), Count);
          v26 = 0;
          v264 = 0;
          LOBYTE(v9) = 0;
          v25 = theArray;
          goto LABEL_443;
        }
        if (v35 >= 1)
        {
          for (i = 0; i != v35; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v19 + 288), i);
            v40 = *(const __CFArray **)(v19 + 32);
            v300.length = CFArrayGetCount(v40);
            v300.location = 0;
            FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v40, v300, ValueAtIndex);
            if (FirstIndexOfValue == -1)
            {
              AMSupportLogInternal();
            }
            else
            {
              v42 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v19 + 40), FirstIndexOfValue);
              CFArrayAppendValue(theArray, ValueAtIndex);
              CFArrayAppendValue(Mutable, v42);
            }
            v19 = a2;
          }
        }
        AMSupportSafeRelease();
        *(_QWORD *)(v19 + 136) = CFRetain(theArray);
        AMSupportSafeRelease();
        *(_QWORD *)(v19 + 144) = CFRetain(Mutable);
        v8 = v286;
        v31 = (uint64_t)v252;
        if (!a4)
          goto LABEL_55;
        goto LABEL_51;
      }
    }
  }
  Mutable = 0;
  theArray = 0;
  if (a4)
  {
LABEL_51:
    v43 = CFGetTypeID((CFTypeRef)a4);
    v19 = a2;
    if (v43 == CFStringGetTypeID())
    {
      v44 = *(const void **)(a2 + 72);
      if (v44)
      {
        CFRelease(v44);
        *(_QWORD *)(a2 + 72) = 0;
      }
      *(_QWORD *)(a2 + 72) = CFRetain((CFTypeRef)a4);
    }
  }
LABEL_55:
  if (a5)
  {
    v45 = CFGetTypeID((CFTypeRef)a5);
    v19 = a2;
    if (v45 == CFStringGetTypeID())
    {
      v46 = *(const void **)(a2 + 80);
      if (v46)
      {
        CFRelease(v46);
        *(_QWORD *)(a2 + 80) = 0;
      }
      *(_QWORD *)(a2 + 80) = CFRetain((CFTypeRef)a5);
    }
  }
  v47 = CFGetAllocator((CFTypeRef)v19);
  v48 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  v49 = CFArrayCreateMutable(v47, 0, MEMORY[0x24BDBD690]);
  v50 = CFGetAllocator((CFTypeRef)v19);
  v51 = CFArrayCreateMutable(v50, 0, v48);
  v52 = v51;
  v272 = v49;
  if (!v49 || !v51)
  {
    AMFDRErrorPushInternal((uint64_t)v8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("Failed to allocate array"), Count);
    goto LABEL_521;
  }
  v53 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(v9 + 16), CFSTR("AllowCSRForbidden"));
  if (!v53)
    goto LABEL_67;
  v54 = v53;
  v55 = CFGetTypeID(v53);
  if (v55 != CFBooleanGetTypeID())
  {
    v257 = 0;
    v8 = v286;
    v56 = a2;
    goto LABEL_69;
  }
  v8 = v286;
  if (!CFBooleanGetValue(v54))
  {
LABEL_67:
    v257 = 0;
    v56 = a2;
    goto LABEL_69;
  }
  v56 = a2;
  if ((AMFDRAPTicketAllowsIncompleteData(v9) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)v286, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("Missing entitlement to allow server forbidden error"), Count);
    LOBYTE(v9) = 0;
    cfb = 0;
    v264 = 0;
    valuesa = 0;
    v152 = 0;
    v183 = 0;
    v26 = Mutable;
    v25 = theArray;
    v216 = v272;
    goto LABEL_432;
  }
  v257 = 1;
LABEL_69:
  v57 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(v9 + 16), CFSTR("EnableMultiRequest"));
  v266 = v52;
  v283 = v9;
  if (!a1)
  {
    v61 = 0;
    v251 = 0;
    v267 = 0;
    goto LABEL_98;
  }
  v58 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("SkipManifest"));
  v61 = v58 && (v59 = v58, v60 = CFGetTypeID(v58), v60 == CFBooleanGetTypeID()) && CFBooleanGetValue(v59) != 0;
  v62 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("KeepExistingData"));
  v65 = v62 && (v63 = v62, v64 = CFGetTypeID(v62), v64 == CFBooleanGetTypeID()) && CFBooleanGetValue(v63) != 0;
  v66 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("SkipProperties"));
  v251 = v66 && (v67 = v66, v68 = CFGetTypeID(v66), v68 == CFBooleanGetTypeID()) && CFBooleanGetValue(v67) != 0;
  v8 = v286;
  v69 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("SkipExtraManifests"));
  if (v69 && (v70 = v69, v71 = CFGetTypeID(v69), v120 = v71 == CFBooleanGetTypeID(), v8 = v286, v120))
  {
    v267 = CFBooleanGetValue(v70) != 0;
    v56 = a2;
    if (!v65)
      goto LABEL_98;
  }
  else
  {
    v267 = 0;
    v56 = a2;
    if (!v65)
      goto LABEL_98;
  }
  if (!AMFDRDigestEnabled(v9, &v288))
  {
    v281 = 1;
    goto LABEL_234;
  }
  v72 = v288;
  v297 = (CFErrorRef)0xAAAAAAAAAAAAAAAALL;
  v298 = 0xAAAAAAAAAAAAAAAALL;
  v295 = 0;
  v296 = 0;
  v73 = *(const __CFArray **)(v56 + 64);
  v249 = v61;
  if (!v73)
  {
    v74 = CFSTR("sealedData->dataArray is NULL");
    goto LABEL_95;
  }
  if (!*(_QWORD *)(v56 + 32))
  {
    v74 = CFSTR("sealedData->dataClassArray is NULL");
    goto LABEL_95;
  }
  if (!*(_QWORD *)(v56 + 40))
  {
    v74 = CFSTR("sealedData->dataInstanceArray is NULL");
    goto LABEL_95;
  }
  if (!*(_QWORD *)(v9 + 16))
  {
    v74 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_95;
  }
  if (*(uint64_t (***)(int, int, int, int))(v9 + 48) != AMFDRHTTPStore)
  {
    v74 = CFSTR("amfdr is not a remote store, skipped verifying digests");
LABEL_95:
    AMFDRErrorPushInternal((uint64_t)&v289, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", v74, Count);
LABEL_96:
    v75 = 0;
    v250 = 0;
    values = 0;
    v273 = 0;
    goto LABEL_226;
  }
  v77 = CFArrayGetCount(v73);
  if (v77 <= 0)
  {
    v74 = CFSTR("sealedData->dataArray is empty");
    goto LABEL_95;
  }
  v78 = v77;
  v79 = CFGetAllocator((CFTypeRef)v56);
  v276 = CFArrayCreateMutable(v79, v78, MEMORY[0x24BDBD690]);
  if (!v276)
  {
    AMFDRErrorPushInternal((uint64_t)&v289, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("dataClassesToVerify is NULL"), Count);
    goto LABEL_96;
  }
  v80 = CFGetAllocator((CFTypeRef)v56);
  v81 = CFArrayCreateMutable(v80, v78, MEMORY[0x24BDBD690]);
  if (!v81)
  {
    AMFDRErrorPushInternal((uint64_t)&v289, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("dataInstancesToVerify is NULL"), Count);
    goto LABEL_578;
  }
  v282 = v81;
  if (v72)
  {
    v82 = CFGetAllocator((CFTypeRef)v56);
    v248 = CFArrayCreateMutable(v82, v78, MEMORY[0x24BDBD690]);
    if (v248)
    {
      v83 = CFGetAllocator((CFTypeRef)v56);
      v84 = CFArrayCreateMutable(v83, v78, MEMORY[0x24BDBD690]);
      if (!v84)
      {
        v86 = CFSTR("dataInstancesToRetry is NULL");
        goto LABEL_580;
      }
      v85 = (int *)malloc_type_calloc(1uLL, 4 * v78, 0x100004052888210uLL);
      if (!v85)
      {
        v86 = CFSTR("dataIndicesToRetry is NULL");
LABEL_580:
        AMFDRErrorPushInternal((uint64_t)&v289, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", v86, Count);
        v75 = 0;
        v250 = 0;
        values = 0;
        v273 = 0;
        goto LABEL_226;
      }
      goto LABEL_112;
    }
    AMFDRErrorPushInternal((uint64_t)&v289, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("dataClassesToRetry is NULL"), Count);
LABEL_578:
    v75 = 0;
    v250 = 0;
    values = 0;
    v273 = 0;
    goto LABEL_226;
  }
  v248 = 0;
  v84 = 0;
  v85 = 0;
LABEL_112:
  v278 = v72;
  v265 = v85;
  v247 = v84;
  v87 = *(const __CFDictionary **)(v56 + 160);
  v258 = v57;
  if (v87)
  {
    v88 = CFDictionaryGetCount(v87);
    if (v88 >= 1)
    {
      v89 = v88;
      v90 = CFGetAllocator((CFTypeRef)v9);
      v91 = CFDictionaryCreateMutable(v90, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      if (!v91)
      {
        AMFDRErrorPushInternal((uint64_t)&v289, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("populateAdditions is NULL"), Count);
        v250 = 0;
        values = 0;
        v273 = 0;
        v75 = v265;
        goto LABEL_226;
      }
      theDict = v91;
      v92 = (const void **)malloc_type_calloc(1uLL, 8 * v89, 0x80040B8603338uLL);
      v93 = (const void **)malloc_type_calloc(1uLL, 8 * v89, 0x80040B8603338uLL);
      values = (void **)v93;
      v250 = v92;
      if (v92 && v93)
      {
        v56 = a2;
        CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a2 + 160), v92, v93);
        v94 = values;
        v95 = 0;
        v284 = 0;
        while (1)
        {
          v96 = (const __CFDictionary *)v94[v95];
          if (v96)
          {
            v97 = CFGetTypeID(v94[v95]);
            if (v97 == CFDictionaryGetTypeID())
            {
              v56 = a2;
              if (v284)
                CFRelease(v284);
              v98 = CFGetAllocator((CFTypeRef)a2);
              MutableCopy = CFDictionaryCreateMutableCopy(v98, 0, v96);
              if (!MutableCopy)
              {
                AMFDRErrorPushInternal((uint64_t)&v289, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("populateInfo is NULL"), Count);
                v273 = 0;
                v57 = v258;
LABEL_546:
                v75 = v265;
                goto LABEL_226;
              }
              v100 = MutableCopy;
              CFDictionaryRemoveValue(MutableCopy, CFSTR("CombinedManifest"));
              v57 = v258;
              v284 = v100;
              if (CFDictionaryGetCount(v100) >= 1)
                CFDictionarySetValue(theDict, v92[v95], v100);
            }
            else
            {
              v56 = a2;
              v57 = v258;
            }
            v94 = values;
          }
          else
          {
            v57 = v258;
          }
          if (v89 == ++v95)
            goto LABEL_131;
        }
      }
      AMFDRErrorPushInternal((uint64_t)&v289, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("additionKeys or additionValues is NULL"), Count);
      v273 = 0;
      goto LABEL_546;
    }
  }
  theDict = 0;
  v284 = 0;
  v250 = 0;
  v94 = 0;
LABEL_131:
  values = v94;
  for (j = 0; j != v78; ++j)
  {
    v102 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 32), j);
    v103 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 40), j);
    if (!v102)
    {
      AMFDRErrorPushInternal((uint64_t)&v289, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("dataClass %d is NULL"), j);
LABEL_499:
      v273 = 0;
      goto LABEL_500;
    }
    v104 = v103;
    if (!v103)
    {
      AMFDRErrorPushInternal((uint64_t)&v289, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("dataInstance %d is NULL"), j);
      goto LABEL_499;
    }
    if (CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 64), j))
    {
      CFArrayAppendValue(v276, v102);
      CFArrayAppendValue(v282, v104);
    }
  }
  if (CFArrayGetCount(v276) <= 0)
  {
    AMFDRErrorPushInternal((uint64_t)&v289, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("no data to verify digests"), Count);
    v273 = 0;
LABEL_500:
    v75 = v265;
    goto LABEL_226;
  }
  v253 = (CFTypeRef)v31;
  v105 = (const __CFDictionary *)AMFDRDataMultiCopyDigest((_QWORD *)v9, (uint64_t)v276, (uint64_t)v282, &v289);
  v106 = theDict;
  if (!v105)
  {
    AMFDRErrorPushInternal((uint64_t)&v289, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("failed to get digests from server"), Count);
    v273 = 0;
    goto LABEL_519;
  }
  v107 = v105;
  v108 = 0;
  v274 = 0;
  FullKey = 0;
  v260 = v105;
  while (2)
  {
    v110 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 64), v108);
    v111 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 32), v108);
    v112 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 40), v108);
    if (!v110)
    {
LABEL_156:
      v52 = v266;
      if (v78 != ++v108)
        continue;
      if (v248 && CFArrayGetCount(v248) >= 1)
        v121 = (const __CFDictionary *)AMFDRDataMultiCopyManifest((_QWORD *)v9, (uint64_t)v248, (uint64_t)v247, &v296);
      else
        v121 = 0;
      v279 = v121;
      if (!v274)
      {
LABEL_218:
        v149 = *(const void **)(v56 + 160);
        if (v149)
        {
          CFRelease(v149);
          *(_QWORD *)(v56 + 160) = 0;
        }
        v9 = v283;
        v31 = (uint64_t)v253;
        v57 = v258;
        if (v106)
        {
          if (CFDictionaryGetCount(v106) >= 1)
          {
            AMSupportLogInternal();
            *(_QWORD *)(v56 + 160) = CFRetain(v106);
          }
          v273 = 1;
        }
        else
        {
          v273 = 1;
        }
        goto LABEL_225;
      }
      v122 = 0;
      cfa = 0;
      while (1)
      {
        v123 = v265[v122];
        v124 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 64), v123);
        v125 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 32), v123);
        v126 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 40), v123);
        if (!v124)
        {
          v235 = CFSTR("unexpected NULL dataValue");
          goto LABEL_515;
        }
        v127 = (uint64_t)v126;
        if (v295)
        {
          CFRelease(v295);
          v295 = 0;
        }
        v128 = CFGetAllocator((CFTypeRef)v56);
        if (AMFDRDataStripExtraManifest(v128, v124, &v295, 0, (uint64_t)&v296))
          v129 = v295 == 0;
        else
          v129 = 1;
        if (v129)
        {
          v235 = CFSTR("failed to strip fdr2 data");
LABEL_515:
          AMFDRErrorPushInternal((uint64_t)&v289, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", v235, Count);
LABEL_517:
          v273 = 0;
LABEL_518:
          v9 = v283;
          goto LABEL_519;
        }
        CFArraySetValueAtIndex(*(CFMutableArrayRef *)(v56 + 64), v123, 0);
        if (FullKey)
          CFRelease(FullKey);
        v130 = CFGetAllocator((CFTypeRef)v56);
        FullKey = AMFDRDataLocalCreateFullKey(v130, (uint64_t)v125, v127);
        if (!FullKey)
        {
          AMFDRErrorPushInternal((uint64_t)&v289, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("dataClassInstance is NULL"), Count);
          goto LABEL_517;
        }
        if (v284)
          CFRelease(v284);
        if (v106 && (v131 = CFDictionaryGetValue(v106, FullKey)) != 0)
        {
          v132 = (__CFDictionary *)CFRetain(v131);
          CFDictionaryRemoveValue(v106, FullKey);
        }
        else
        {
          v132 = 0;
        }
        v284 = v132;
        if (v279)
        {
          v133 = (const __CFDictionary *)CFDictionaryGetValue(v279, FullKey);
          if (v133)
          {
            v134 = v133;
            v135 = CFGetTypeID(v133);
            if (v135 == CFDictionaryGetTypeID())
            {
              v136 = (const __CFData *)CFDictionaryGetValue(v134, CFSTR("mandev"));
              v137 = (const __CFData *)CFDictionaryGetValue(v134, CFSTR("mansta"));
            }
            else
            {
              v136 = 0;
              v137 = 0;
            }
            v56 = a2;
          }
          else
          {
            v136 = 0;
            v137 = 0;
          }
          v106 = theDict;
          if ((unint64_t)v136 | (unint64_t)v137)
          {
            if (v136)
            {
              v138 = *(const __CFArray **)(v56 + 272);
              if (v138)
              {
                v301.length = CFArrayGetCount(v138);
                v301.location = 0;
                v139 = CFArrayContainsValue(v138, v301, v125) != 0;
              }
              else
              {
                v139 = 0;
              }
              v56 = a2;
            }
            else
            {
              v139 = 0;
            }
            if (cfa)
              CFRelease(cfa);
            DataWithManifests = (const __CFData *)AMFDRDataLocalCreateDataWithManifests((const void *)v283, (const __CFData *)v295, v136, v137, v139, (uint64_t)&v296);
            if (!DataWithManifests)
            {
              cfa = 0;
              v52 = v266;
              v106 = theDict;
              goto LABEL_210;
            }
            v297 = 0;
            v298 = 0;
            v141 = DataWithManifests;
            CFDataGetBytePtr(DataWithManifests);
            cfa = v141;
            CFDataGetLength(v141);
            if (!AMSupportDigestMd5())
            {
              AMFDRErrorPushInternal((uint64_t)&v289, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("failed to compute restitched digest for %@:%@"), (char)v125);
              v273 = 0;
              v52 = v266;
              v9 = v283;
              v31 = (uint64_t)v253;
              v57 = v258;
              goto LABEL_500;
            }
            v142 = (const __CFData *)CFDictionaryGetValue(v260, FullKey);
            v106 = theDict;
            if (!v142
              || (v143 = v142, v144 = CFGetTypeID(v142), v144 != CFDataGetTypeID())
              || CFDataGetLength(v143) != 16)
            {
              AMFDRErrorPushInternal((uint64_t)&v289, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("unexpected invalid hash"), Count);
              v273 = 0;
              v52 = v266;
              goto LABEL_518;
            }
            BytePtr = CFDataGetBytePtr(v143);
            if (*(CFErrorRef *)BytePtr != v297 || *((_QWORD *)BytePtr + 1) != v298)
            {
              AMSupportLogInternal();
              v52 = v266;
              v56 = a2;
              goto LABEL_210;
            }
            v56 = a2;
            CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a2 + 64), v123, cfa);
            if (theDict)
            {
              v147 = v132;
              if (v132)
              {
                if (v136)
                {
                  CFDictionaryRemoveValue(v132, CFSTR("DeviceManifestMissing"));
                  v147 = v132;
                }
                v148 = v147;
                v52 = v266;
                if (CFDictionaryGetCount(v147) >= 1)
                  CFDictionarySetValue(theDict, FullKey, v148);
                goto LABEL_210;
              }
            }
          }
          v52 = v266;
        }
LABEL_210:
        if (v274 == (CFDictionaryRef)++v122)
          goto LABEL_218;
      }
    }
    break;
  }
  v113 = v112;
  v297 = 0;
  v298 = 0;
  v114 = CFDataGetBytePtr(v110);
  CFDataGetLength(v110);
  if (!AMFDRDigestMd5((uint64_t)v114))
  {
    AMFDRErrorPushInternal((uint64_t)&v289, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("failed to compute digest for %@:%@"), (char)v111);
    goto LABEL_512;
  }
  if (FullKey)
    CFRelease(FullKey);
  v56 = a2;
  v115 = CFGetAllocator((CFTypeRef)a2);
  FullKey = AMFDRDataLocalCreateFullKey(v115, (uint64_t)v111, (uint64_t)v113);
  if (FullKey)
  {
    v116 = (const __CFData *)CFDictionaryGetValue(v107, FullKey);
    if (v116
      && (v117 = v116, v118 = CFGetTypeID(v116), v120 = v118 == CFDataGetTypeID(), v56 = a2, v120)
      && CFDataGetLength(v117) == 16)
    {
      v119 = CFDataGetBytePtr(v117);
      v120 = *(CFErrorRef *)v119 == v297 && *((_QWORD *)v119 + 1) == v298;
      if (!v120)
      {
        if (v278)
        {
          AMSupportLogInternal();
          CFArrayAppendValue(v248, v111);
          CFArrayAppendValue(v247, v113);
          v265[(_QWORD)v274] = v108;
          v274 = (CFDictionaryRef)((char *)v274 + 1);
        }
        else
        {
          AMSupportLogInternal();
          CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a2 + 64), v108, 0);
          if (theDict)
            CFDictionaryRemoveValue(theDict, FullKey);
        }
      }
    }
    else
    {
      CFArraySetValueAtIndex(*(CFMutableArrayRef *)(v56 + 64), v108, 0);
    }
    goto LABEL_156;
  }
  AMFDRErrorPushInternal((uint64_t)&v289, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerifyDigest", CFSTR("dataClassInstance is NULL"), Count);
LABEL_512:
  v273 = 0;
  v52 = v266;
LABEL_519:
  v31 = (uint64_t)v253;
  v57 = v258;
LABEL_225:
  v75 = v265;
LABEL_226:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (v75)
    free(v75);
  v8 = v286;
  v61 = v249;
  if (v250)
    free(v250);
  if (values)
    free(values);
  if ((v273 & 1) != 0)
  {
    v281 = 1;
    v56 = a2;
    goto LABEL_234;
  }
  AMSupportLogInternal();
  v56 = a2;
LABEL_98:
  v76 = *(const void **)(v56 + 160);
  if (v76)
  {
    CFRelease(v76);
    v281 = 0;
    *(_QWORD *)(v56 + 160) = 0;
  }
  else
  {
    v281 = 0;
  }
LABEL_234:
  v150 = *(const void **)(v56 + 16);
  if (v150)
  {
    CFRelease(v150);
    *(_QWORD *)(v56 + 16) = 0;
  }
  if (v57 && !CFBooleanGetValue(v57))
  {
    if (v61)
    {
      AMSupportLogInternal();
      goto LABEL_290;
    }
    *(_BYTE *)(v9 + 41) = 0;
    v229 = AMFDRDataCopy(v9, *(const __CFString **)(v56 + 72), *(const __CFString **)(v56 + 80), (uint64_t)v8);
    v175 = v229;
    if (*(_BYTE *)(v9 + 41))
    {
      if (AMFDRGetUnderlyingErrorCode(v9, (CFErrorRef *)v8) == 403)
      {
        if (!v175)
        {
          if ((v257 & 1) != 0)
          {
            AMSupportLogInternal();
            if (v8 && *v8)
            {
              CFRelease(*v8);
              *v8 = 0;
            }
            AMSupportLogInternal();
            cfb = 0;
            v280 = 0;
            v152 = 0;
            v277 = 0;
            v254 = 0;
            v275 = 0;
            v175 = 0;
            goto LABEL_287;
          }
          AMFDRErrorPushInternal((uint64_t)v8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("permissions request failed"), Count);
          goto LABEL_521;
        }
        v264 = v175;
        v239 = CFSTR("sealedData->sealingIM4M is not NULL");
      }
      else
      {
        v264 = v175;
        v239 = CFSTR("unexpected error code");
      }
      AMFDRErrorPushInternal((uint64_t)v8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", v239, Count);
      cfb = 0;
      v183 = 0;
      v152 = 0;
      valuesa = 0;
LABEL_530:
      LOBYTE(v9) = 0;
      v26 = Mutable;
      v25 = theArray;
      v216 = v272;
      if (v272)
        goto LABEL_432;
      goto LABEL_433;
    }
    if (v229)
    {
      cfb = 0;
      v280 = 0;
      v152 = 0;
      LOBYTE(v177) = 0;
      v277 = 0;
      v254 = 0;
      v275 = 0;
      goto LABEL_296;
    }
    if (AMFDRGetUnderlyingErrorCode(v9, (CFErrorRef *)v8) == 404)
    {
      AMSupportLogInternal();
      if (v8 && *v8)
      {
        CFRelease(*v8);
        cfb = 0;
        v280 = 0;
        v152 = 0;
        LOBYTE(v177) = 0;
        v277 = 0;
        v254 = 0;
        v275 = 0;
        v175 = 0;
        *v8 = 0;
        goto LABEL_296;
      }
LABEL_290:
      cfb = 0;
      v280 = 0;
      v152 = 0;
      LOBYTE(v177) = 0;
      v277 = 0;
      v254 = 0;
      v275 = 0;
      v175 = 0;
      goto LABEL_296;
    }
    AMFDRErrorPushInternal((uint64_t)v8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("Unexpected error for %@:%@: %ld"), *(_QWORD *)(v56 + 72));
LABEL_521:
    cfb = 0;
    v183 = 0;
    v152 = 0;
LABEL_529:
    valuesa = 0;
    v264 = 0;
    goto LABEL_530;
  }
  v151 = CFGetAllocator((CFTypeRef)v9);
  v152 = CFArrayCreateMutable(v151, 0, MEMORY[0x24BDBD690]);
  if (!v152)
  {
    AMFDRErrorPushInternal((uint64_t)v8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("dataClassArrayToCopy is NULL"), Count);
    cfb = 0;
    v183 = 0;
    goto LABEL_529;
  }
  v153 = CFGetAllocator((CFTypeRef)v9);
  v154 = CFArrayCreateMutable(v153, 0, MEMORY[0x24BDBD690]);
  v277 = v154;
  if (v61)
  {
    AMSupportLogInternal();
  }
  else
  {
    v155 = v154;
    CFArrayAppendValue(v152, *(const void **)(v56 + 72));
    CFArrayAppendValue(v155, *(const void **)(v56 + 80));
  }
  v254 = v152;
  if (v281)
  {
    if (v31 >= 1)
    {
      v156 = 0;
      while (1)
      {
        v157 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 32), v156);
        v158 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 40), v156);
        if (!v157)
        {
          v231 = CFSTR("dataClass is NULL. Sealing failed.");
          goto LABEL_484;
        }
        v159 = v158;
        if (!v158)
          break;
        v160 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 64), v156);
        if (!v160 || (v161 = CFGetTypeID(v160), v120 = v161 == CFDataGetTypeID(), v56 = a2, !v120))
        {
          CFArrayAppendValue(v152, v157);
          CFArrayAppendValue(v277, v159);
        }
        if (v31 == ++v156)
          goto LABEL_253;
      }
      v231 = CFSTR("dataInstance is NULL. Sealing failed.");
LABEL_484:
      v8 = v286;
      AMFDRErrorPushInternal((uint64_t)v286, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", v231, Count);
LABEL_485:
      cfb = 0;
      v264 = 0;
      v183 = 0;
      v152 = 0;
      valuesa = 0;
      LOBYTE(v9) = 0;
      v26 = Mutable;
      v25 = theArray;
      v216 = v272;
      goto LABEL_427;
    }
  }
  else
  {
    v162 = *(const __CFArray **)(a2 + 32);
    v305.length = CFArrayGetCount(v162);
    v305.location = 0;
    CFArrayAppendArray(v152, v162, v305);
    v163 = *(const __CFArray **)(a2 + 40);
    v306.length = CFArrayGetCount(v163);
    v164 = v163;
    v56 = a2;
    v306.location = 0;
    CFArrayAppendArray(v277, v164, v306);
  }
LABEL_253:
  *(_BYTE *)(v9 + 41) = 0;
  if (CFArrayGetCount(v152))
  {
    v8 = v286;
    if (v267)
      v165 = (const __CFDictionary *)AMFDRDataMultiCopy((_QWORD *)v9, (uint64_t)v152, (uint64_t)v277, v286);
    else
      v165 = (const __CFDictionary *)AMFDRDataMultiPopulate((_QWORD *)v9, (uint64_t)v152, (uint64_t)v277, (uint64_t)&v291, v286);
    v166 = v165;
    if ((v281 & 1) != 0)
    {
      if (v291 && CFDictionaryGetCount(v291))
      {
        AMFDRErrorPushInternal((uint64_t)v286, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("Unexpected multiAdditions value"), Count);
        LOBYTE(v9) = 0;
        cfb = 0;
        v264 = 0;
        valuesa = 0;
        v152 = 0;
        v183 = 0;
        v26 = Mutable;
        v25 = theArray;
        v216 = v272;
        v227 = v166;
        goto LABEL_425;
      }
      AMSupportLogInternal();
    }
    else
    {
      *(_QWORD *)(v56 + 160) = AMSupportSafeRetain();
    }
  }
  else
  {
    CFArrayGetCount(*(CFArrayRef *)(v56 + 32));
    AMSupportLogInternal();
    v166 = 0;
    v8 = v286;
  }
  v275 = v166;
  v167 = *(unsigned __int8 *)(v9 + 41);
  if (!*(_BYTE *)(v9 + 41))
  {
    if (!v8 || !*v8)
    {
LABEL_275:
      cfb = 0;
      goto LABEL_276;
    }
    if (CFErrorGetCode((CFErrorRef)*v8) == 21)
    {
      v171 = AMFDRCopyUnderlyingDictionary((__CFError *)*v8, CFSTR("MultiRequestErrors"));
      v172 = v8;
      v169 = (const __CFDictionary *)v171;
      v170 = *v172;
      cfb = v169;
      if (!*v172)
        goto LABEL_276;
      goto LABEL_274;
    }
    v236 = CFSTR("AMFDRDataMultiCopy got unexpected error");
LABEL_536:
    AMFDRErrorPushInternal((uint64_t)v8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", v236, Count);
    LOBYTE(v9) = 0;
    cfb = 0;
    v264 = 0;
    valuesa = 0;
    v152 = 0;
LABEL_561:
    v183 = 0;
    goto LABEL_562;
  }
  if (AMFDRGetUnderlyingErrorCode(v9, (CFErrorRef *)v8) != 403)
  {
    v236 = CFSTR("unexpected error code");
    goto LABEL_536;
  }
  if (v166)
  {
    AMFDRErrorPushInternal((uint64_t)v8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("valueDataDict is not NULL"), Count);
    v216 = v272;
    v227 = v166;
    cfb = 0;
    v264 = 0;
    v183 = 0;
    v152 = 0;
    valuesa = 0;
    LOBYTE(v9) = 0;
    v26 = Mutable;
    v25 = theArray;
    goto LABEL_426;
  }
  if ((v257 & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)v8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("permissions request failed"), Count);
    goto LABEL_485;
  }
  AMSupportLogInternal();
  if (!v8)
    goto LABEL_275;
  v168 = v8;
  v169 = 0;
  cfb = 0;
  v170 = *v168;
  if (*v168)
  {
LABEL_274:
    CFRelease(v170);
    *v286 = 0;
    cfb = v169;
  }
LABEL_276:
  v173 = CFGetAllocator((CFTypeRef)a2);
  v152 = (__CFArray *)AMFDRDataLocalCreateFullKey(v173, *(_QWORD *)(a2 + 72), *(_QWORD *)(a2 + 80));
  if (!v152)
  {
    v8 = v286;
    AMFDRErrorPushInternal((uint64_t)v286, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("failed to create data instance string"), Count);
LABEL_559:
    LOBYTE(v9) = 0;
    v264 = 0;
    goto LABEL_560;
  }
  v8 = v286;
  if (!v166 || (v174 = CFDictionaryGetValue(v166, v152)) == 0)
  {
    v175 = 0;
    if (v167)
      goto LABEL_286;
LABEL_280:
    if (v175)
      v176 = 1;
    else
      v176 = v61;
    if ((v176 & 1) != 0)
    {
      LOBYTE(v177) = 0;
      v280 = 1;
      v56 = a2;
      goto LABEL_296;
    }
    v297 = 0;
    if (cfb)
    {
      v178 = (__CFError *)CFDictionaryGetValue(cfb, v152);
      v297 = v178;
      v56 = a2;
      if (v178)
      {
        Code = CFErrorGetCode(v178);
        v180 = AMFDRGetUnderlyingErrorCode(v9, &v297);
        if (Code == 701 || v180 == 404)
        {
          AMSupportLogInternal();
          LOBYTE(v177) = 0;
          v175 = 0;
          v280 = 1;
          v8 = v286;
          goto LABEL_296;
        }
        format = CFSTR("Unexpected error and underlying error for %@: %ld, %ld");
        v246 = (char)v152;
        *(_OWORD *)v241 = 0u;
        v242 = 0u;
        *(_OWORD *)value = 0u;
        v8 = v286;
        v237 = (uint64_t)v286;
        v238 = 8;
        goto LABEL_558;
      }
      format = CFSTR("%@ is missing but multiRequestError is NULL");
      v246 = 0;
      *(_OWORD *)v241 = 0u;
      v242 = 0u;
      *(_OWORD *)value = 0u;
      v8 = v286;
    }
    else
    {
      format = CFSTR("%@ is missing but multiRequestErrors is NULL");
      v246 = (char)v152;
      *(_OWORD *)v241 = 0u;
      v242 = 0u;
      *(_OWORD *)value = 0u;
    }
    v237 = (uint64_t)v8;
    v238 = 10;
LABEL_558:
    AMFDRErrorPushInternal(v237, v238, 0, 0, 0, 0, 0, 0, value[0], value[1], v241[0], v241[1], (void *)v242, *((void **)&v242 + 1), (uint64_t)"__AMFDRSealedDataPopulatePrivate", format, v246);
    goto LABEL_559;
  }
  v175 = (const __CFData *)CFRetain(v174);
  if (!v167)
    goto LABEL_280;
LABEL_286:
  v56 = a2;
  AMSupportLogInternal();
  v280 = 1;
LABEL_287:
  LOBYTE(v177) = 1;
LABEL_296:
  v264 = v175;
  if ((AMFDRSealedDataMultiManifestPopulate(v56, v283, v175, v52, (uint64_t)v8) & 1) == 0)
  {
    AMFDRErrorPushInternal((uint64_t)v8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("AMFDRSealedDataMultiManifestPopulate failed"), Count);
    LOBYTE(v9) = 0;
LABEL_560:
    valuesa = 0;
    goto LABEL_561;
  }
  v181 = CFArrayGetCount(v52);
  v261 = v181 > 0;
  theDicta = v181 < 1;
  AMSupportLogInternal();
  if (*(_QWORD *)(v56 + 280))
  {
    v182 = CFGetAllocator((CFTypeRef)v56);
    v183 = CFArrayCreateMutableCopy(v182, 0, *(CFArrayRef *)(v56 + 280));
    v184 = v283;
    if (!v183)
    {
      AMFDRErrorPushInternal((uint64_t)v8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("Failed to copy array"), Count);
      goto LABEL_300;
    }
  }
  else
  {
    v183 = 0;
    v184 = v283;
    *(_BYTE *)(v283 + 40) = 0;
  }
  v294 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v184 + 16), CFSTR("TrustObject"));
  if (!v294)
  {
    if (v8 && *v8)
    {
      CFRelease(*v8);
      *v8 = 0;
    }
    v184 = v283;
    AMFDRDataCopyTrustObject(v283);
    if (v294)
    {
      AMFDRSetOption(v283, CFSTR("TrustObject"), v294);
      CFRelease(v294);
    }
  }
  if (*(_QWORD *)(v184 + 32))
  {
    valuesa = 0;
    v185 = a2;
    goto LABEL_315;
  }
  v186 = *(const __CFDictionary **)(v184 + 80);
  if (v186)
  {
    v187 = CFDictionaryGetValue(v186, CFSTR("certificate"));
    *(_QWORD *)(v184 + 32) = v187;
    DataFromFileURL = 4 * (v187 == 0);
    AMSupportSafeRetain();
    valuesa = 0;
    goto LABEL_314;
  }
  v189 = AMFDRDataLocalCopyDataStoragePath((_QWORD *)v184, (uint64_t)CFSTR("certificate"), 0, (uint64_t)v8);
  if (!v189)
  {
    AMFDRErrorPushInternal((uint64_t)v8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("missing cert data storage path"), Count);
LABEL_300:
    LOBYTE(v9) = 0;
    valuesa = 0;
LABEL_562:
    v26 = Mutable;
    v25 = theArray;
    v216 = v272;
    goto LABEL_563;
  }
  v190 = (void **)v189;
  CFGetAllocator((CFTypeRef)v184);
  valuesa = v190;
  DataFromFileURL = AMSupportCreateDataFromFileURL();
LABEL_314:
  v185 = a2;
  if ((DataFromFileURL & 0xFFFFFFFB) != 0)
  {
    AMFDRErrorPushInternal((uint64_t)v8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("failed to read cert data from %@. error %d"), (char)valuesa);
LABEL_542:
    LOBYTE(v9) = 0;
    goto LABEL_562;
  }
LABEL_315:
  v285 = v183;
  if (v31 < 1)
  {
    v259 = 0;
LABEL_403:
    v215 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(v283 + 16), CFSTR("SealIdentifiers"));
    v52 = v266;
    if (v251)
      goto LABEL_404;
    v217 = (CFTypeRef *)(v185 + 88);
    if (*(_QWORD *)(v185 + 88))
      goto LABEL_404;
    v218 = v215;
    if (!v215)
      goto LABEL_404;
    v219 = CFGetTypeID(v215);
    if (v219 != CFBooleanGetTypeID() || !CFBooleanGetValue(v218))
      goto LABEL_404;
    if (!*(_QWORD *)(v283 + 88))
      goto LABEL_586;
    if ((AMFDREntitlementIsEntitled(CFSTR("com.apple.libFDR.AllowIdentifierOverride")) & 1) == 0)
    {
      v8 = v286;
      AMFDRErrorPushInternal((uint64_t)v286, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("Missing AllowIdentifierOverride entitlement"), Count);
      LOBYTE(v9) = 0;
      v26 = Mutable;
      v25 = theArray;
LABEL_507:
      v216 = v272;
      v227 = v275;
      v183 = v285;
      goto LABEL_425;
    }
    v220 = *(uint64_t (**)(CFAllocatorRef, uint64_t, uint64_t, uint64_t, uint64_t, const __CFDictionary **))(v283 + 88);
    v221 = CFGetAllocator((CFTypeRef)v283);
    v222 = *(_QWORD *)(a2 + 32);
    v223 = *(_QWORD *)(a2 + 40);
    v224 = *(_QWORD *)(a2 + 64);
    v225 = AMFDRAllowIncompleteData(v283);
    v226 = v220(v221, v222, v223, v224, v225, &v292);
    v183 = v285;
    v8 = v286;
    if ((v226 & 1) == 0)
    {
      AMFDRErrorPushInternal((uint64_t)v286, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("copyMGOverride failed"), Count);
    }
    else
    {
LABEL_586:
      if (AMFDRSealingMapCopyManifestPropertiesForDevice((CFDictionaryRef *)v283, v292, v217, &v293, (uint64_t)v8))
      {
        if (*v217)
          AMSupportLogInternal();
        if (v293)
          AMSupportLogInternal();
LABEL_404:
        v216 = v272;
        v26 = Mutable;
        v25 = theArray;
        if (CFArrayGetCount(v272) || CFArrayGetCount(v266))
        {
          if (v259 & 1 | !v261)
            AMFDRErrorPushInternal((uint64_t)v8, 28, 0, v272, v266, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("kAMFDRErrorMissingNonGeneratedData:Failed to fetch data for instances %@\nFailed to fetch multi-manifest for instances %@"), (char)v272);
          else
            AMFDRErrorPushInternal((uint64_t)v8, 20, 0, v272, v266, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("kAMFDRErrorMissingGeneratedData: Failed to fetch data for instances %@\nFailed to fetch multi-manifest for instances %@"), (char)v272);
        }
        if (v183 && CFArrayGetCount(v183) >= 1)
        {
          AMSupportLogInternal();
          *(_BYTE *)(v283 + 40) = 0;
        }
        v227 = v275;
        LOBYTE(v9) = theDicta;
        goto LABEL_425;
      }
    }
    goto LABEL_542;
  }
  v191 = 0;
  v259 = 0;
  while (1)
  {
    v192 = v31;
    if (v152)
      CFRelease(v152);
    v193 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v185 + 32), v191);
    v194 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v185 + 40), v191);
    if (!v193)
    {
      v230 = CFSTR("dataClass is NULL. Sealing failed.");
LABEL_480:
      AMFDRErrorPushInternal((uint64_t)v8, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", v230, Count);
      LOBYTE(v9) = 0;
      v152 = 0;
      goto LABEL_506;
    }
    v195 = v194;
    if (!v194)
    {
      v230 = CFSTR("dataInstance is NULL. Sealing failed.");
      goto LABEL_480;
    }
    v196 = CFGetAllocator((CFTypeRef)v185);
    v152 = (__CFArray *)AMFDRDataLocalCreateFullKey(v196, (uint64_t)v193, (uint64_t)v195);
    if (!v152)
    {
      AMFDRErrorPushInternal((uint64_t)v8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("failed to create data instance string"), Count);
      goto LABEL_505;
    }
    if ((v177 & 1) != 0)
    {
      AMSupportLogInternal();
      goto LABEL_324;
    }
    if (v281)
    {
      CFArrayGetValueAtIndex(*(CFArrayRef *)(v185 + 64), v191);
      v198 = (const void *)AMSupportSafeRetain();
      if (v198)
      {
        v197 = v198;
        v199 = CFGetTypeID(v198);
        if (v199 == CFDataGetTypeID())
        {
          AMSupportLogInternal();
          goto LABEL_358;
        }
        v232 = CFSTR("Expected data type in sealedData->dataArray");
LABEL_495:
        AMFDRErrorPushInternal((uint64_t)v8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", v232, Count);
        v26 = Mutable;
        v25 = theArray;
        v52 = v266;
        v216 = v272;
        v183 = v285;
        goto LABEL_525;
      }
    }
    if (!v280)
      break;
    if (!v275)
    {
      v177 = 0;
      v197 = 0;
      goto LABEL_361;
    }
    v200 = CFDictionaryGetValue(v275, v152);
    v197 = v200;
    v185 = a2;
    if (v200)
      CFRetain(v200);
    v177 = 0;
LABEL_362:
    v205 = *(const __CFArray **)(v185 + 264);
    if (v205)
    {
      v302.length = CFArrayGetCount(v205);
      v302.location = 0;
      v206 = CFArrayContainsValue(v205, v302, v193) != 0;
    }
    else
    {
      v206 = 0;
    }
    v207 = *(const __CFArray **)(a2 + 296);
    if (v207)
    {
      v303.length = CFArrayGetCount(*(CFArrayRef *)(a2 + 296));
      v303.location = 0;
      v208 = CFArrayContainsValue(v207, v303, v193) != 0;
    }
    else
    {
      v208 = 0;
    }
    v185 = a2;
    if (v197)
      goto LABEL_369;
    if (!v177)
    {
      if (v280)
      {
        v297 = 0;
        if (cfb)
        {
          v212 = (__CFError *)CFDictionaryGetValue(cfb, v152);
          v297 = v212;
          if (v212)
          {
            v213 = CFErrorGetCode(v212);
            v214 = AMFDRGetUnderlyingErrorCode(v283, &v297);
            if (v213 == 701 || v214 == 404)
              goto LABEL_387;
            v8 = v286;
            AMFDRErrorPushInternal((uint64_t)v286, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("Unexpected error and underlying error for %@:%@: %ld, %ld"), (char)v193);
LABEL_505:
            LOBYTE(v9) = 0;
LABEL_506:
            v26 = Mutable;
            v25 = theArray;
            v52 = v266;
            goto LABEL_507;
          }
          v245 = (char)v193;
          v234 = CFSTR("%@:%@ is missing but multiRequestError is NULL");
        }
        else
        {
          v245 = (char)v193;
          v234 = CFSTR("%@:%@ is missing but multiRequestErrors is NULL");
        }
        v8 = v286;
        AMFDRErrorPushInternal((uint64_t)v286, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", v234, v245);
        goto LABEL_505;
      }
      if (AMFDRGetUnderlyingErrorCode(v283, (CFErrorRef *)v286) == 404)
      {
        if (v286 && *v286)
        {
          CFRelease(*v286);
          *v286 = 0;
        }
        goto LABEL_387;
      }
      AMFDRErrorPushInternal((uint64_t)v286, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("Unexpected error for %@:%@: %ld"), (char)v193);
      LOBYTE(v9) = 0;
      v8 = v286;
      goto LABEL_506;
    }
    AMSupportLogInternal();
LABEL_387:
    if (!v208)
    {
      AMSupportLogInternal();
      v8 = v286;
      v185 = a2;
      goto LABEL_370;
    }
    v185 = a2;
    AMSupportLogInternal();
    CFArrayAppendValue(v272, v152);
    theDicta = 0;
    if (v206)
      v261 = 1;
    else
      v259 = 1;
LABEL_369:
    v8 = v286;
LABEL_370:
    v31 = v192;
    v183 = v285;
    if (v285)
    {
      if (CFArrayGetCount(v285) >= 1)
      {
        v304.length = CFArrayGetCount(v285);
        v304.location = 0;
        v209 = CFArrayGetFirstIndexOfValue(v285, v304, v193);
        if (v209 != -1)
        {
          *(_BYTE *)(v283 + 40) = 1;
          if (v197)
            CFArrayRemoveValueAtIndex(v285, v209);
        }
      }
    }
    v210 = CFArrayGetCount(*(CFArrayRef *)(v185 + 64));
    v211 = *(__CFArray **)(v185 + 64);
    if (v210 != v31)
    {
      CFArrayAppendValue(v211, v197);
      if (!v197)
        goto LABEL_380;
LABEL_379:
      CFRelease(v197);
      goto LABEL_380;
    }
    CFArraySetValueAtIndex(v211, v191, v197);
    if (v197)
      goto LABEL_379;
LABEL_380:
    if (v8 && *v8)
    {
      CFRelease(*v8);
      *v8 = 0;
    }
    if (v31 == ++v191)
      goto LABEL_403;
  }
  if (v290)
  {
    CFRelease(v290);
    v290 = 0;
  }
  *(_BYTE *)(v283 + 41) = 0;
  if (v267)
    v201 = AMFDRDataCopy(v283, v193, v195, (uint64_t)v8);
  else
    v201 = (void *)AMFDRDataPopulate(v283, (uint64_t)v193, (uint64_t)v195, (uint64_t)&v290, (uint64_t)v8);
  v197 = v201;
  v202 = v281;
  if (!v290)
    v202 = 1;
  if ((v202 & 1) != 0 || CFDictionaryGetCount((CFDictionaryRef)v290) < 1)
  {
LABEL_347:
    if (v281)
    {
      if (v290 && CFDictionaryGetCount((CFDictionaryRef)v290))
      {
        v233 = CFSTR("Unexpected populateInfo value");
        goto LABEL_523;
      }
      AMSupportLogInternal();
    }
    if (!*(_BYTE *)(v283 + 41))
    {
LABEL_358:
      v177 = 0;
      goto LABEL_361;
    }
    if (AMFDRGetUnderlyingErrorCode(v283, (CFErrorRef *)v8) == 403)
    {
      if (v197)
      {
        v232 = CFSTR("valueData is not NULL");
        goto LABEL_495;
      }
      if ((v257 & 1) == 0)
      {
        AMFDRErrorPushInternal((uint64_t)v8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("permissions request failed"), Count);
        goto LABEL_505;
      }
      AMSupportLogInternal();
      if (v8)
      {
        v185 = a2;
        if (*v8)
        {
          CFRelease(*v8);
          v197 = 0;
          *v8 = 0;
          goto LABEL_325;
        }
LABEL_324:
        v197 = 0;
LABEL_325:
        v177 = 1;
        goto LABEL_362;
      }
      v197 = 0;
      v177 = 1;
LABEL_361:
      v185 = a2;
      goto LABEL_362;
    }
    v233 = CFSTR("unexpected error code");
LABEL_523:
    AMFDRErrorPushInternal((uint64_t)v8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", v233, Count);
    goto LABEL_524;
  }
  v203 = *(__CFDictionary **)(a2 + 160);
  if (v203
    || (v204 = CFGetAllocator((CFTypeRef)v283),
        v203 = CFDictionaryCreateMutable(v204, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]),
        (*(_QWORD *)(a2 + 160) = v203) != 0))
  {
    CFDictionarySetValue(v203, v152, v290);
    goto LABEL_347;
  }
  AMFDRErrorPushInternal((uint64_t)v8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"__AMFDRSealedDataPopulatePrivate", CFSTR("Failed to allocate populateAdditions"), Count);
LABEL_524:
  v26 = Mutable;
  v25 = theArray;
  v52 = v266;
  v216 = v272;
  v183 = v285;
  if (v197)
LABEL_525:
    CFRelease(v197);
  LOBYTE(v9) = 0;
LABEL_563:
  v227 = v275;
LABEL_425:
  if (v227)
LABEL_426:
    CFRelease(v227);
LABEL_427:
  if (v254)
    CFRelease(v254);
  if (v277)
    CFRelease(v277);
  if (v216)
LABEL_432:
    CFRelease(v216);
LABEL_433:
  if (v52)
    CFRelease(v52);
  if (v183)
    CFRelease(v183);
  if (v152)
    CFRelease(v152);
  if (valuesa)
    CFRelease(valuesa);
  if (cfb)
    CFRelease(cfb);
LABEL_443:
  if (v292)
  {
    CFRelease(v292);
    v292 = 0;
  }
  if (v293)
  {
    CFRelease(v293);
    v293 = 0;
  }
  if (v25)
    CFRelease(v25);
  if (v26)
    CFRelease(v26);
  if (v291)
  {
    CFRelease(v291);
    v291 = 0;
  }
  if (v290)
  {
    CFRelease(v290);
    v290 = 0;
  }
  if (v264)
    CFRelease(v264);
  if (v289)
  {
    CFRelease(v289);
    v289 = 0;
  }
  if (v8 != 0 && (v9 & 1) != 0 && *v8)
  {
    CFRelease(*v8);
    *v8 = 0;
  }
  return v9 & 1;
}

uint64_t AMFDRSealedDataPopulateWithExistingData(uint64_t a1, CFTypeRef cf, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  const __CFAllocator *v14;
  __CFDictionary *Mutable;
  const __CFDictionary *v16;
  uint64_t v17;
  char v19;

  v14 = CFGetAllocator(cf);
  Mutable = CFDictionaryCreateMutable(v14, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v16 = Mutable;
  if (Mutable)
  {
    CFDictionaryAddValue(Mutable, CFSTR("KeepExistingData"), (const void *)*MEMORY[0x24BDBD270]);
    v17 = __AMFDRSealedDataPopulatePrivate(v16, a1, (uint64_t)cf, a3, a4, a5, a6, a7);
  }
  else
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataPopulateWithExistingData", CFSTR("failed to allocate privateOptions"), v19);
    v17 = 0;
  }
  AMSupportSafeRelease();
  return v17;
}

uint64_t AMFDRSealedDataSetDataClassInstance(_QWORD *a1, CFTypeRef cf, const void *a3, const void *a4, const void *a5, uint64_t a6)
{
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  CFIndex Count;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const __CFString *v23;
  char v24;

  if (!a1)
  {
    v23 = CFSTR("sealedData is NULL");
    goto LABEL_28;
  }
  if (!cf || (v12 = CFGetTypeID(cf), v12 != CFStringGetTypeID()))
  {
    v23 = CFSTR("sealedDataClass must be a CFString");
LABEL_28:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataSetDataClassInstance", v23, v24);
    return 0;
  }
  if (!a3 || (v13 = CFGetTypeID(a3), v13 != CFStringGetTypeID()))
  {
    v23 = CFSTR("sealedDataInstance must be a CFString");
    goto LABEL_28;
  }
  if (!a4 || (v14 = CFGetTypeID(a4), v14 != CFArrayGetTypeID()))
  {
    v23 = CFSTR("dataClassArray must be a CFArray");
    goto LABEL_28;
  }
  if (!a5 || (v15 = CFGetTypeID(a5), v15 != CFArrayGetTypeID()))
  {
    v23 = CFSTR("dataInstanceArray must be a CFArray");
    goto LABEL_28;
  }
  Count = CFArrayGetCount((CFArrayRef)a4);
  if (Count != CFArrayGetCount((CFArrayRef)a5))
  {
    v24 = CFArrayGetCount((CFArrayRef)a4);
    CFArrayGetCount((CFArrayRef)a5);
    v23 = CFSTR("dataClassArray length (%ld) does not match dataInstanceArray (%ld)");
    goto LABEL_28;
  }
  v17 = (const void *)a1[4];
  if (v17)
    CFRelease(v17);
  a1[4] = a4;
  CFRetain(a4);
  v18 = (const void *)a1[5];
  if (v18)
    CFRelease(v18);
  a1[5] = a5;
  CFRetain(a5);
  v19 = (const void *)a1[8];
  if (v19)
  {
    CFRelease(v19);
    a1[8] = 0;
  }
  v20 = (const void *)a1[9];
  if (v20)
    CFRelease(v20);
  a1[9] = cf;
  CFRetain(cf);
  v21 = (const void *)a1[10];
  if (v21)
    CFRelease(v21);
  a1[10] = a3;
  CFRetain(a3);
  return 1;
}

uint64_t AMFDRSealedDataSetIntraFactoryDataClassInstance(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4)
{
  CFTypeID v8;
  CFTypeID v9;
  CFIndex Count;
  const void *v11;
  const void *v12;
  const __CFString *v14;
  char v15;

  if (!a1)
  {
    v14 = CFSTR("sealedData is NULL");
    goto LABEL_16;
  }
  if (!cf || (v8 = CFGetTypeID(cf), v8 != CFArrayGetTypeID()))
  {
    v14 = CFSTR("intraDataClasses must be a CFArray");
LABEL_16:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataSetIntraFactoryDataClassInstance", v14, v15);
    return 0;
  }
  if (!a3 || (v9 = CFGetTypeID(a3), v9 != CFArrayGetTypeID()))
  {
    v14 = CFSTR("intraDataInstances must be a CFArray");
    goto LABEL_16;
  }
  Count = CFArrayGetCount((CFArrayRef)cf);
  if (Count != CFArrayGetCount((CFArrayRef)a3))
  {
    v15 = CFArrayGetCount((CFArrayRef)cf);
    CFArrayGetCount((CFArrayRef)a3);
    v14 = CFSTR("intraDataClasses length (%ld) does not match intraDataInstances (%ld)");
    goto LABEL_16;
  }
  v11 = *(const void **)(a1 + 48);
  if (v11)
    CFRelease(v11);
  *(_QWORD *)(a1 + 48) = cf;
  CFRetain(cf);
  v12 = *(const void **)(a1 + 56);
  if (v12)
    CFRelease(v12);
  *(_QWORD *)(a1 + 56) = a3;
  CFRetain(a3);
  return 1;
}

uint64_t AMFDRSealedDataSetMinimalManifestClassInstance(_QWORD *a1, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4, uint64_t a5)
{
  CFTypeID v10;
  CFTypeID v11;
  CFTypeID v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const __CFString *v17;
  char v18;

  if (!a1)
  {
    v17 = CFSTR("sealedData is NULL");
LABEL_25:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataSetMinimalManifestClassInstance", v17, v18);
    return 0;
  }
  if (cf)
  {
    v10 = CFGetTypeID(cf);
    if (v10 != CFArrayGetTypeID())
    {
      v17 = CFSTR("minimalSealingDataInstances must be a CFArray");
      goto LABEL_25;
    }
  }
  if (a3)
  {
    v11 = CFGetTypeID(a3);
    if (v11 != CFArrayGetTypeID())
    {
      v17 = CFSTR("minimalSealedDataClasses must be a CFArray");
      goto LABEL_25;
    }
  }
  if (a4)
  {
    v12 = CFGetTypeID(a4);
    if (v12 != CFArrayGetTypeID())
    {
      v17 = CFSTR("minimalSealedDataInstances must be a CFArray");
      goto LABEL_25;
    }
  }
  v13 = (const void *)a1[22];
  if (v13)
    CFRelease(v13);
  a1[22] = cf;
  if (cf)
    CFRetain(cf);
  v14 = (const void *)a1[23];
  if (v14)
    CFRelease(v14);
  a1[23] = a3;
  if (a3)
    CFRetain(a3);
  v15 = (const void *)a1[24];
  if (v15)
    CFRelease(v15);
  a1[24] = a4;
  if (a4)
    CFRetain(a4);
  return 1;
}

uint64_t AMFDRSealedDataSetRepairConfiguration(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  CFTypeID v6;
  const void *v7;
  char v9;

  if (!a1)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataSetRepairConfiguration", CFSTR("sealedData is NULL"), v9);
    return 0;
  }
  if (!cf || (v6 = CFGetTypeID(cf), v6 != CFDictionaryGetTypeID()))
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataSetRepairConfiguration", CFSTR("repairConfigurationMap has wrong type %@"), (char)cf);
    return 0;
  }
  v7 = *(const void **)(a1 + 224);
  if (v7)
    CFRelease(v7);
  *(_QWORD *)(a1 + 224) = cf;
  CFRetain(cf);
  return 1;
}

BOOL AMFDRSealedDataClear(_QWORD *a1, uint64_t a2)
{
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  char v14;

  if (a1)
  {
    v3 = (const void *)a1[2];
    if (v3)
    {
      CFRelease(v3);
      a1[2] = 0;
    }
    v4 = (const void *)a1[3];
    if (v4)
    {
      CFRelease(v4);
      a1[3] = 0;
    }
    v5 = (const void *)a1[8];
    if (v5)
    {
      CFRelease(v5);
      a1[8] = 0;
    }
    v6 = (const void *)a1[11];
    if (v6)
    {
      CFRelease(v6);
      a1[11] = 0;
    }
    v7 = (const void *)a1[12];
    if (v7)
    {
      CFRelease(v7);
      a1[12] = 0;
    }
    v8 = (const void *)a1[13];
    if (v8)
    {
      CFRelease(v8);
      a1[13] = 0;
    }
    v9 = (const void *)a1[14];
    if (v9)
    {
      CFRelease(v9);
      a1[14] = 0;
    }
    v10 = (const void *)a1[15];
    if (v10)
    {
      CFRelease(v10);
      a1[15] = 0;
    }
    v11 = (const void *)a1[19];
    if (v11)
    {
      CFRelease(v11);
      a1[19] = 0;
    }
    v12 = (const void *)a1[20];
    if (v12)
    {
      CFRelease(v12);
      a1[20] = 0;
    }
  }
  else
  {
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataClear", CFSTR("sealedData is NULL"), v14);
  }
  return a1 != 0;
}

BOOL AMFDRSealedDataPopulatedFromManifest(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v4;
  char v6;

  if (a1)
  {
    v4 = (_QWORD *)MEMORY[0x24BDBD270];
    if (!a2)
      v4 = (_QWORD *)MEMORY[0x24BDBD268];
    *(_QWORD *)(a1 + 208) = *v4;
  }
  else
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataPopulatedFromManifest", CFSTR("sealedData is NULL"), v6);
  }
  return a1 != 0;
}

uint64_t AMFDRSealedDataRecover(uint64_t a1, uint64_t cf, uint64_t a3, int a4, CFTypeRef *a5, uint64_t a6)
{
  __CFError **v6;
  const __CFAllocator *v11;
  const __CFAllocator *v12;
  const void *v13;
  CFTypeID v14;
  const void *v15;
  CFTypeID v16;
  const __CFBoolean *v17;
  int v18;
  const __CFArray *v19;
  const __CFArray *v20;
  CFTypeID v21;
  CFIndex Count;
  CFIndex v23;
  CFIndex v24;
  const void *ValueAtIndex;
  CFTypeID v26;
  const __CFBoolean *v27;
  const __CFBoolean *v28;
  CFTypeID v29;
  const __CFArray *v30;
  const __CFArray *v31;
  CFTypeID v32;
  CFIndex v33;
  CFIndex v34;
  CFIndex v35;
  const void *v36;
  CFTypeID v37;
  const __CFArray *v38;
  const __CFArray *v39;
  CFTypeID v40;
  CFIndex v41;
  CFIndex v42;
  CFIndex v43;
  const void *v44;
  CFTypeID v45;
  unint64_t v46;
  const __CFString *v47;
  CFTypeID v48;
  CFIndex v49;
  CFIndex v50;
  CFIndex v51;
  const void *v52;
  CFTypeID v53;
  const __CFString *v54;
  uint64_t v55;
  CFIndex v56;
  uint64_t v57;
  const void *v58;
  const __CFString *v59;
  const __CFDictionary *v60;
  CFMutableStringRef v61;
  const __CFString *v62;
  char v63;
  const __CFBoolean *v65;
  const __CFBoolean *v66;
  CFTypeID v67;
  _BOOL4 v68;
  CFTypeRef *v69;
  int v70;
  int v71;
  int v72;
  int v73;
  char v74;
  const void *v75;
  const void *v76;
  _BOOL4 v77;
  const void *v78;
  const __CFString *v79;
  char v80;
  const void *v81;
  char v82;
  const __CFArray *v83;
  char v84;
  const void *v85;
  const __CFDictionary *v86;
  const __CFDictionary *v87;
  const __CFDictionary *v88;
  const __CFAllocator *v89;
  CFMutableDictionaryRef v90;
  const __CFDictionary *v91;
  const __CFArray *v92;
  const __CFDictionary *v93;
  const __CFDictionary *v94;
  const __CFDictionary *v95;
  const __CFAllocator *v96;
  const __CFDictionary *v97;
  const __CFString *v98;
  int v99;
  int v100;
  int v101;
  const __CFString *v102;
  const void *v103;
  const __CFBoolean *v104;
  const __CFBoolean *v105;
  CFTypeID v106;
  const __CFDictionary *v107;
  const void *v108;
  const __CFDictionary *v109;
  const __CFBoolean *v110;
  const __CFString *v111;
  void (*v112)(uint64_t);
  uint64_t v113;
  uint64_t v114;
  uint64_t (*v115)(uint64_t);
  const __CFString *v116;
  const __CFString *v117;
  const __CFString *v118;
  const __CFString *v119;
  BOOL v120;
  _BOOL4 v121;
  CFTypeID v122;
  CFTypeID v123;
  const __CFArray *v124;
  const __CFArray *v125;
  CFTypeID v126;
  const __CFString *v127;
  const void *v128;
  CFTypeID v129;
  __CFError **v130;
  char v131;
  int v132;
  const __CFString *v133;
  const __CFArray *v134;
  char v135;
  const __CFDictionary *RepairConfigurationAsidMetadata;
  CFTypeID v137;
  const __CFString *v138;
  const __CFString *v139;
  const __CFString *v140;
  const __CFString *v141;
  const __CFString *v142;
  const __CFString *v143;
  const __CFString *v144;
  const __CFString *v145;
  const __CFString *v146;
  void *value[2];
  void *v148[2];
  __int128 v149;
  const __CFString *format;
  const __CFString *formata;
  const __CFString *formatb;
  const __CFString *formatc;
  char v154;
  const __CFArray *v155;
  const void *v156;
  const __CFString *v157;
  _BOOL4 v158;
  int v159;
  const __CFString *v160;
  __CFError **v161;
  const __CFDictionary *v162;
  const __CFString *cfa;
  const __CFDictionary *cfb;
  CFTypeRef v166;
  CFTypeRef v167;
  __CFDictionary *Mutable;
  __CFDictionary *theDict;
  int v170;
  int valuePtr;
  CFTypeRef v172;
  CFTypeRef v173;
  const __CFArray *v174;
  const __CFArray *v175;
  CFTypeRef v176;
  char v177;
  uint64_t context;
  CFTypeRef *v179;
  const __CFDictionary *v180;
  CFTypeRef *v181;
  char *v182;
  uint64_t v183;

  v6 = (__CFError **)a6;
  v183 = *MEMORY[0x24BDAC8D0];
  v177 = a4;
  v175 = 0;
  v176 = 0;
  v173 = 0;
  v174 = 0;
  v172 = 0;
  v170 = 0;
  valuePtr = 1;
  if (!cf)
  {
    v139 = CFSTR("amfdrLocal is NULL");
LABEL_343:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", v139, v154);
LABEL_344:
    v57 = 0;
    cfb = 0;
    Mutable = 0;
LABEL_345:
    v162 = 0;
    theDict = 0;
    goto LABEL_69;
  }
  if (!a3)
  {
    v139 = CFSTR("amfdrRemote is NULL");
    goto LABEL_343;
  }
  if (!a1)
  {
    v139 = CFSTR("sealedData is NULL");
    goto LABEL_343;
  }
  if (!*(_QWORD *)(a1 + 80))
  {
    v139 = CFSTR("sealedData->sealedDataInstance is NULL");
    goto LABEL_343;
  }
  if (!*(_QWORD *)(a1 + 32))
  {
    v139 = CFSTR("sealedData->dataClassArray is NULL");
    goto LABEL_343;
  }
  if (!*(_QWORD *)(a1 + 40))
  {
    v139 = CFSTR("sealedData->dataInstanceArray is NULL");
    goto LABEL_343;
  }
  v11 = CFGetAllocator((CFTypeRef)cf);
  Mutable = CFDictionaryCreateMutable(v11, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)v6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("Failed to allocate fdrInfo."), v154);
    goto LABEL_344;
  }
  v12 = CFGetAllocator((CFTypeRef)cf);
  theDict = CFDictionaryCreateMutable(v12, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal((uint64_t)v6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("Failed to allocate privateOptions."), v154);
    v57 = 0;
    cfb = 0;
    goto LABEL_345;
  }
  if ((AMFDRSealedDataConfigureOptionsForRecover(a1, (CFTypeRef *)cf, a3, *(const void **)(a1 + 80), (uint64_t)v6) & 1) == 0)
  {
    v140 = CFSTR("AMFDRSealedDataConfigureOptionsForRecover failed.");
    goto LABEL_349;
  }
  v13 = *(const void **)(a3 + 16);
  if (!v13)
  {
    v54 = CFSTR("amfdrRemote->optionsDict is NULL");
    goto LABEL_64;
  }
  v14 = CFGetTypeID(v13);
  if (v14 != CFDictionaryGetTypeID())
  {
    v54 = CFSTR("amfdrRemote->optionsDict must be a CFDictionaryRef");
    goto LABEL_64;
  }
  if (CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("ForceSealing"))
    && (v15 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("ForceSealing")),
        v16 = CFGetTypeID(v15),
        v16 == CFBooleanGetTypeID()))
  {
    v17 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("ForceSealing"));
    if (CFBooleanGetValue(v17))
      v18 = a4;
    else
      v18 = 0;
    v159 = v18;
  }
  else
  {
    v159 = 0;
  }
  v19 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("SealingUpdateProperties"));
  v20 = v19;
  if (v19)
  {
    v21 = CFGetTypeID(v19);
    if (v21 != CFArrayGetTypeID())
    {
      v54 = CFSTR("kAMFDROptionSealingUpdateProperties is not array");
      goto LABEL_64;
    }
    Count = CFArrayGetCount(v20);
    if (Count >= 1)
    {
      v23 = Count;
      v24 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v20, v24);
        if (!ValueAtIndex)
          break;
        v26 = CFGetTypeID(ValueAtIndex);
        if (v26 != CFStringGetTypeID())
          break;
        if (v23 == ++v24)
          goto LABEL_26;
      }
      v54 = CFSTR("malformed property");
      goto LABEL_64;
    }
  }
LABEL_26:
  v27 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("SealingUpdateRepairConfigurationAsidMetadata"));
  v158 = v27 && (v28 = v27, v29 = CFGetTypeID(v27), v29 == CFBooleanGetTypeID()) && CFBooleanGetValue(v28) != 0;
  v30 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("ExportDataClasses"));
  v31 = v30;
  if (v30)
  {
    v32 = CFGetTypeID(v30);
    if (v32 != CFArrayGetTypeID())
      goto LABEL_352;
    v33 = CFArrayGetCount(v31);
    if (v33 >= 1)
    {
      v34 = v33;
      v35 = 0;
      do
      {
        v36 = CFArrayGetValueAtIndex(v31, v35);
        if (!v36)
          goto LABEL_62;
        v37 = CFGetTypeID(v36);
        if (v37 != CFStringGetTypeID())
          goto LABEL_62;
      }
      while (v34 != ++v35);
    }
  }
  v38 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("ClaimDataClasses"));
  v161 = v6;
  if (!v38)
  {
LABEL_46:
    v156 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("ExportAfterSealing"));
    v166 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("SealingUpdateDataClasses"));
    if ((a4 & 1) == 0)
      CFDictionaryAddValue(theDict, CFSTR("SkipProperties"), (const void *)*MEMORY[0x24BDBD270]);
    if ((__AMFDRSealedDataPopulatePrivate(theDict, a1, cf, 0, 0, 0, 0, (uint64_t)v6) & 1) == 0)
    {
      AMSupportLogInternal();
      _AMFDRSealedDataSetFDRInfo(v6, CFSTR("MissingDataInstances"), Mutable, CFSTR("MissingLocalDataInstances"));
      AMFDRSetStat((CFMutableDictionaryRef *)cf, CFSTR("FDRLocalDataMissing"), 1);
      v6 = v161;
      AMFDRSetStat((CFMutableDictionaryRef *)a3, CFSTR("FDRLocalDataMissing"), 1);
    }
    if (v6 && *v6)
    {
      CFRelease(*v6);
      *v6 = 0;
    }
    v46 = (unint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("ExportLegacyDataClasses"));
    if (v46)
    {
      v157 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("DataVersion"));
      v47 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("UseSikDataInstance"));
      v48 = CFGetTypeID((CFTypeRef)v46);
      if (v48 != CFArrayGetTypeID())
      {
        format = CFSTR("exportLegacyData: kAMFDROptionExportLegacyDataClasses is not array");
        *(_OWORD *)v148 = 0u;
        v149 = 0u;
        *(_OWORD *)value = 0u;
        v6 = v161;
        goto LABEL_65;
      }
      v49 = CFArrayGetCount((CFArrayRef)v46);
      v6 = v161;
      if (v49 >= 1)
      {
        v50 = v49;
        cfa = v47;
        v51 = 0;
        while (1)
        {
          v52 = CFArrayGetValueAtIndex((CFArrayRef)v46, v51);
          if (!v52)
            break;
          v53 = CFGetTypeID(v52);
          v120 = v53 == CFStringGetTypeID();
          v6 = v161;
          if (!v120)
            break;
          if (v50 == ++v51)
          {
            v47 = cfa;
            goto LABEL_115;
          }
        }
        v54 = CFSTR("exportLegacyData: malformed dataClass");
        goto LABEL_64;
      }
    }
    else
    {
      v47 = 0;
      v157 = 0;
    }
LABEL_115:
    v65 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("ForceUpdate"));
    v68 = v65 && (v66 = v65, v67 = CFGetTypeID(v65), v67 == CFBooleanGetTypeID()) && CFBooleanGetValue(v66) != 0;
    v69 = (CFTypeRef *)v161;
    if (AMFDRSealedDataVerify((_QWORD *)a1, cf, (uint64_t)v161))
    {
      v70 = a4 ^ 1;
      if (v20)
        v71 = 0;
      else
        v71 = v159 ^ 1;
      v72 = v71 & !v158;
      if (v166)
        v72 = 0;
      if ((v72 | v70) == 1)
      {
        v73 = (unint64_t)v31 | v46 ? a4 ^ 1 : 0;
        if (((v68 | v73) & 1) == 0)
        {
          v75 = CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("TrustObject"));
          v76 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("TrustObject"));
          v6 = v161;
          if (v76 && v75 && !CFEqual(v75, v76) && (AMFDRDataPutTrustObject(cf) & 1) == 0)
          {
            AMFDRErrorPushInternal((uint64_t)v161, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("Failed to store trust object in local data store"), v154);
            goto LABEL_67;
          }
          AMSupportLogInternal();
          v162 = 0;
          cfb = 0;
          v167 = 0;
          v58 = 0;
          v59 = 0;
          goto LABEL_251;
        }
      }
      if (v166)
        v74 = a4 ^ 1;
      else
        v74 = 1;
      if ((v74 & 1) == 0 || !((v20 == 0) | v70 & 1) || ((!v158 | v70) & 1) == 0 || ((v159 ^ 1 | v70) & 1) == 0)
        goto LABEL_148;
      if (!((unint64_t)v31 | v46))
        v70 = 0;
      if (v70 != 1)
      {
        v69 = (CFTypeRef *)v161;
        if (v68)
          AMSupportLogInternal();
      }
      else
      {
LABEL_148:
        AMSupportLogInternal();
        v69 = (CFTypeRef *)v161;
      }
    }
    else
    {
      AMSupportLogInternal();
      _AMFDRSealedDataSetFDRInfo(v161, CFSTR("UnverifiedDataInstances"), Mutable, CFSTR("UnverifiedLocalDataInstances"));
      AMFDRSetStat((CFMutableDictionaryRef *)cf, CFSTR("FDRLocalVerifyFail"), 1);
      AMFDRSetStat((CFMutableDictionaryRef *)a3, CFSTR("FDRLocalVerifyFail"), 1);
    }
    v155 = (const __CFArray *)v46;
    if (v69 && *v69)
    {
      CFRelease(*v69);
      *v69 = 0;
    }
    v77 = AMFDRDigestEnabled(a3, 0);
    if ((a4 & 1) != 0)
    {
      v78 = *(const void **)(a1 + 88);
      if (v78)
      {
        CFRelease(v78);
        *(_QWORD *)(a1 + 88) = 0;
      }
      v79 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("SealIdentifiers"));
      AMFDRSetOption(a3, CFSTR("SealIdentifiers"), v79);
      *(_QWORD *)(a3 + 88) = *(_QWORD *)(cf + 88);
      if (v77)
        v80 = AMFDRSealedDataPopulateWithExistingData(a1, (CFTypeRef)a3, 0, 0, 0, 0, (uint64_t)v161);
      else
        v80 = __AMFDRSealedDataPopulatePrivate(0, a1, a3, 0, 0, 0, 0, (uint64_t)v161);
      v84 = v80;
      _AMFDRSealedDataSetFDRInfo(v161, CFSTR("MissingDataInstances"), Mutable, CFSTR("MissingDataInstances"));
      if ((v84 & 1) == 0
        && (!AMFDRAllowIncompleteData(a3)
         || (AMFDRDataErrorIsBenign(a3, (char)CFSTR("AMFDRSealedDataPopulate"), v161) & 1) == 0))
      {
        AMFDRSetStat((CFMutableDictionaryRef *)cf, CFSTR("FDRRecoveryFail"), 1);
        AMFDRSetStat((CFMutableDictionaryRef *)a3, CFSTR("FDRRecoveryFail"), 1);
        format = CFSTR("AMFDRSealedDataPopulate with amfdrRemote failed. Data Recovery failed.");
        *(_OWORD *)v148 = 0u;
        v149 = 0u;
        *(_OWORD *)value = 0u;
        v6 = v161;
LABEL_174:
        v55 = (uint64_t)v6;
        v56 = 7;
        goto LABEL_66;
      }
      if (AMFDRSealedDataIsEmpty(a1))
        goto LABEL_169;
      v85 = *(const void **)(a1 + 16);
      v6 = v161;
      if (v85)
        v167 = CFRetain(v85);
      else
        v167 = 0;
      AMFDRSetOption(a3, CFSTR("SealingManifest"), 0);
      if (AMFDRSealedDataVerify((_QWORD *)a1, a3, (uint64_t)v161))
      {
        AMSupportLogInternal();
        cfb = 0;
LABEL_210:
        v162 = 0;
        goto LABEL_211;
      }
      if (v161 && *v161)
      {
        v93 = CFErrorCopyUserInfo(*v161);
        if (v93)
        {
          cfb = v93;
          v94 = (const __CFDictionary *)CFDictionaryGetValue(v93, CFSTR("UnverifiedDataInstances"));
          if (!v94)
            goto LABEL_210;
          v95 = v94;
          v96 = CFGetAllocator((CFTypeRef)a1);
          v97 = CFDictionaryCreateMutable(v96, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
          context = a3;
          v179 = (CFTypeRef *)a1;
          v180 = v97;
          v181 = &v176;
          v182 = &v177;
          CFDictionaryApplyFunction(v95, (CFDictionaryApplierFunction)_checkVerificationError, &context);
          v162 = v97;
          if (v176)
          {
            AMFDRErrorPushInternal((uint64_t)v161, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("failed to verify test station signature, _checkVerificationError %@"), (char)v176);
          }
          else
          {
            context = a1;
            v179 = &v176;
            v180 = 0;
            v181 = 0;
            CFDictionaryApplyFunction(v97, (CFDictionaryApplierFunction)_deleteFromSealedData, &context);
            if (!v176)
            {
              AMSupportLogInternal();
              v6 = v161;
LABEL_211:
              if (v167)
              {
                v98 = *(const __CFString **)(a1 + 16);
                if (!v98)
                {
                  v98 = (const __CFString *)CFRetain(v167);
                  *(_QWORD *)(a1 + 16) = v98;
                }
                AMFDRSetOption(a3, CFSTR("SealingManifest"), v98);
              }
              v99 = AMFDRSealedDataVerify((_QWORD *)a1, a3, (uint64_t)v6);
              if ((v99 & 1) != 0)
              {
                v100 = v159;
                if (v20)
                  v100 = 1;
                if (((v100 | v158) & 1) == 0)
                {
                  v60 = 0;
                  v61 = 0;
                  v62 = 0;
                  v103 = v156;
                  goto LABEL_288;
                }
LABEL_230:
                AMSupportLogInternal();
                v104 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("DisallowSealing"));
                if (v104
                  && (v105 = v104, v106 = CFGetTypeID(v104), v120 = v106 == CFBooleanGetTypeID(), v6 = v161, v120)
                  && CFBooleanGetValue(v105))
                {
                  v143 = CFSTR("Sealing (force sealing or re-sealing) not allowed due to PR Doc setting, restore stopped as requested.");
                }
                else
                {
                  if (!AMFDRAPTicketAllowsUnsealedData(a3))
                  {
                    if (v6 && *v6)
                    {
                      CFRelease(*v6);
                      *v6 = 0;
                    }
                    if ((AMFDRDataGetSigningVersion(cf, &v170) & 1) != 0)
                    {
                      if (!v79 || v170 != 2 || !CFBooleanGetValue((CFBooleanRef)v79))
                        goto LABEL_260;
                      v107 = *(const __CFDictionary **)(a1 + 88);
                      if (v107)
                      {
                        v108 = CFDictionaryGetValue(v107, CFSTR("SrNm"));
                        v109 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), CFSTR("mlb#"));
                        if (v108)
                          goto LABEL_260;
                        v60 = v109;
                      }
                      else
                      {
                        v60 = 0;
                      }
                      v110 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("AllowSealingWithMLBSerialNumber"));
                      if (v110 && CFBooleanGetValue(v110))
                      {
                        if (!v60)
                        {
                          formatc = CFSTR("MLBSerialNumber is required for sealing when allowSealingWithMLBSerialNumber is set");
                          goto LABEL_409;
                        }
LABEL_260:
                        v111 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("Permissions"));
                        if (!v111)
                        {
                          v6 = v161;
                          AMFDRErrorPushInternal((uint64_t)v161, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("permStr in amfdrRemote is NULL."), v154);
                          goto LABEL_403;
                        }
                        AMFDRSetOption(cf, CFSTR("Permissions"), v111);
                        v112 = *(void (**)(uint64_t))(*(_QWORD *)(cf + 136) + 24);
                        if (v112)
                        {
                          v113 = *(_QWORD *)(cf + 144);
                          if (v113)
                          {
                            v112(v113);
                            *(_QWORD *)(cf + 144) = 0;
                          }
                        }
                        v114 = *(_QWORD *)(a3 + 144);
                        v115 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a3 + 136) + 16);
                        v116 = v47;
                        if (v115)
                          v114 = v115(v114);
                        *(_QWORD *)(cf + 144) = v114;
                        v117 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 16), CFSTR("TrustObject"));
                        v118 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("TrustObject"));
                        AMFDRSetOption(cf, CFSTR("TrustObject"), v118);
                        v119 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("PairedSoCs"));
                        AMFDRSetOption(cf, CFSTR("PairedSoCs"), v119);
                        if (v79)
                          v120 = *(_QWORD *)(a1 + 232) == 0;
                        else
                          v120 = 1;
                        v121 = v158;
                        if (v120)
                          v121 = 0;
                        if (!v121
                          || (v122 = CFGetTypeID(v79), v122 != CFBooleanGetTypeID())
                          || !CFBooleanGetValue((CFBooleanRef)v79))
                        {
                          v60 = 0;
                          v61 = 0;
                          v62 = 0;
                          v6 = v161;
                          v103 = v156;
                          goto LABEL_280;
                        }
                        AMSupportLogInternal();
                        v123 = CFGetTypeID(Mutable);
                        v103 = v156;
                        if (v123 == CFDictionaryGetTypeID()
                          && CFDictionaryContainsKey(Mutable, CFSTR("MissingDataInstances")))
                        {
                          v124 = (const __CFArray *)CFDictionaryGetValue(Mutable, CFSTR("MissingDataInstances"));
                          v125 = v124;
                          if (!v124 || (v126 = CFGetTypeID(v124), v126 != CFArrayGetTypeID()))
                          {
                            v6 = v161;
                            AMFDRErrorPushInternal((uint64_t)v161, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("missingDataInstances has wrong type %@"), (char)v125);
LABEL_403:
                            v57 = 0;
                            goto LABEL_70;
                          }
                        }
                        else
                        {
                          v125 = 0;
                        }
                        v134 = *(const __CFArray **)(a1 + 232);
                        v135 = AMFDRAllowIncompleteData(cf);
                        RepairConfigurationAsidMetadata = (const __CFDictionary *)AMFDRDataCreateRepairConfigurationAsidMetadata(v134, v135, v125, (uint64_t)v161);
                        v60 = RepairConfigurationAsidMetadata;
                        if (RepairConfigurationAsidMetadata)
                        {
                          v137 = CFGetTypeID(RepairConfigurationAsidMetadata);
                          if (v137 == CFDictionaryGetTypeID())
                          {
                            v6 = v161;
                            if (!CFDictionaryGetCount(v60))
                            {
                              AMSupportLogInternal();
                              v61 = 0;
                              v62 = 0;
                              goto LABEL_280;
                            }
                            if (AMFDRDataCopyAsidMetadataParameters(v60, (CFTypeRef *)&v175, (CFTypeRef *)&v174, &v173, &v172, (uint64_t)v161))
                            {
                              v62 = (const __CFString *)_CFDictionaryCopyValue(*(const __CFDictionary **)(a3 + 16), CFSTR("UseSikDataInstance"));
                              v61 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
                              if (!v61)
                              {
                                AMFDRErrorPushInternal((uint64_t)v161, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("updateAsidMetadataPermissions allocation failed"), v154);
                                goto LABEL_320;
                              }
                              v138 = (const __CFString *)*MEMORY[0x24BDBD270];
                              AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD270]);
                              if (!AMFDRDataAppendPermissionUpdateAsidMetadata(v175, v174, a3, v61, (uint64_t)v161))
                              {
                                v146 = CFSTR("sik AMFDRDataAppendPermissionUpdateAsidMetadata failed");
                                goto LABEL_382;
                              }
                              v160 = (const __CFString *)*MEMORY[0x24BDBD268];
                              AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD268]);
                              if (!AMFDRDataAppendPermissionUpdateAsidMetadata(v175, v174, a3, v61, (uint64_t)v161))
                              {
                                v146 = CFSTR("non-sik AMFDRDataAppendPermissionUpdateAsidMetadata failed");
                                goto LABEL_382;
                              }
                              AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), v138);
                              if ((AMFDRDataUpdateAsidMetadata(v175, v174, v173, v172, a3, v61, (uint64_t)v161) & 1) == 0)
                              {
                                v146 = CFSTR("sik AMFDRDataMultiUpdateMetaDataWithOptions failed");
                                goto LABEL_382;
                              }
                              AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), v160);
                              v103 = v156;
                              if ((AMFDRDataUpdateAsidMetadata(v175, v174, v173, v172, a3, v61, (uint64_t)v161) & 1) == 0)
                              {
                                v146 = CFSTR("non-sik AMFDRDataMultiUpdateMetaDataWithOptions failed");
                                goto LABEL_382;
                              }
                              AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), v62);
                              AMSupportLogInternal();
LABEL_280:
                              if ((AMFDRPermissionsRequest(cf, (CFTypeRef *)v6) & 1) == 0)
                              {
                                AMFDRErrorPushInternal((uint64_t)v6, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("Permissions request failed."), v154);
                                goto LABEL_320;
                              }
                              v127 = (const __CFString *)AMFDRGetCert(cf);
                              if (!v127)
                              {
                                AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("clientCert is NULL"), v154);
                                goto LABEL_320;
                              }
                              AMFDRSetOption(a3, CFSTR("Certificate"), v127);
                              AMFDRSetOption(cf, CFSTR("TrustObject"), v117);
                              if ((AMFDRSealedDataCreateSealingRequest(a1, cf, (uint64_t)v6) & 1) == 0)
                              {
                                formatb = CFSTR("AMFDRSealedDataCreateSealingRequest failed. Sealing failed.");
LABEL_380:
                                AMFDRErrorPushInternal((uint64_t)v6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", formatb, v154);
                                goto LABEL_320;
                              }
                              if (*(_QWORD *)(a1 + 24))
                              {
                                v47 = v116;
                                v128 = *(const void **)(a1 + 16);
                                if (v128)
                                {
                                  CFRelease(v128);
                                  *(_QWORD *)(a1 + 16) = 0;
                                }
                                if ((AMFDRSealedDataHTTPSign(a1, (CFDictionaryRef *)a3, (CFTypeRef *)v6) & 1) != 0)
                                {
                                  AMFDRSetStat((CFMutableDictionaryRef *)cf, CFSTR("FDRSealingSuccess"), 1);
                                  v6 = v161;
                                  AMFDRSetStat((CFMutableDictionaryRef *)a3, CFSTR("FDRSealingSuccess"), 1);
LABEL_288:
                                  AMSupportLogInternal();
                                  if (!v6)
                                  {
LABEL_291:
                                    if (*(_QWORD *)(a1 + 16))
                                    {
                                      if (!v103)
                                        goto LABEL_298;
                                      v129 = CFGetTypeID(v103);
                                      v120 = v129 == CFBooleanGetTypeID();
                                      v6 = v161;
                                      if (!v120 || !CFBooleanGetValue((CFBooleanRef)v103))
                                        goto LABEL_298;
                                      if ((_AMFDRSealedDataExportExistingData((CFDictionaryRef *)a3, (CFArrayRef *)a1, (CFTypeRef *)v161) & 1) != 0)
                                      {
                                        AMSupportLogInternal();
LABEL_298:
                                        AMFDRSetOption(cf, CFSTR("SealingManifest"), *(const __CFString **)(a1 + 16));
                                        if ((AMFDRSealedDataCommit(a1, cf, 1, (uint64_t)v6) & 1) != 0)
                                        {
                                          if (v155)
                                          {
                                            v59 = (const __CFString *)CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberIntType, &valuePtr);
                                            AMFDRSetOption(a3, CFSTR("DataVersion"), v59);
                                            AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD268]);
                                            if ((_AMFDRSealedDataExport((CFArrayRef *)a1, (CFDictionaryRef *)a3, v155, (uint64_t)v6) & 1) == 0)
                                            {
                                              AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("exportLegacyData: Failed to export legacy data %@."), (char)v155);
                                              goto LABEL_391;
                                            }
                                            AMSupportLogInternal();
                                            AMFDRSetOption(a3, CFSTR("DataVersion"), v157);
                                            AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), v47);
                                          }
                                          else
                                          {
                                            v59 = 0;
                                          }
                                          if (AMFDRSealedDataRestoreOptions(a1, cf, a3))
                                          {
                                            v58 = (const void *)AMSupportSafeRetain();
                                            if (AMFDRSealedDataClear((_QWORD *)a1, (uint64_t)v6))
                                            {
                                              if ((AMFDRSealedDataConfigureOptionsForRecover(a1, (CFTypeRef *)cf, a3, *(const void **)(a1 + 80), (uint64_t)v6) & 1) != 0)
                                              {
                                                *(_QWORD *)(a1 + 88) = AMSupportSafeRetain();
                                                if ((__AMFDRSealedDataPopulatePrivate(0, a1, cf, 0, 0, 0, 0, (uint64_t)v6) & 1) != 0|| (AMFDRDataErrorIsBenign(cf, (char)CFSTR("AMFDRSealedDataPopulate"), v6) & 1) != 0)
                                                {
                                                  if (*(_QWORD *)(a1 + 16))
                                                  {
                                                    v130 = v6;
                                                    v131 = AMFDRSealedDataVerify((_QWORD *)a1, cf, (uint64_t)v6);
                                                    _AMFDRSealedDataSetFDRInfo(v130, CFSTR("UnverifiedDataInstances"), Mutable, CFSTR("UnverifiedDataInstances"));
                                                    if ((v131 & 1) != 0)
                                                    {
LABEL_312:
                                                      AMSupportLogInternal();
                                                      v6 = v130;
                                                      goto LABEL_252;
                                                    }
                                                    v6 = v130;
                                                    if (v130
                                                      && AMFDRSealedDataVerificationErrorIsBenign(v132, (CFDictionaryRef *)cf, 0, 1, 0, *v130))
                                                    {
                                                      if (*v130)
                                                      {
                                                        CFRelease(*v130);
                                                        *v130 = 0;
                                                      }
                                                      goto LABEL_312;
                                                    }
                                                    v133 = CFSTR("AMFDRSealedDataVerify with amfdrLocal failed after recovery. Data Recovery failed.");
                                                  }
                                                  else
                                                  {
                                                    if (AMFDRAPTicketAllowsUnsealedData(cf))
                                                    {
                                                      AMSupportLogInternal();
                                                      goto LABEL_252;
                                                    }
                                                    v133 = CFSTR("Failed to populate sealedData->sealingIM4M from local data store. Data Recovery failed.");
                                                  }
                                                }
                                                else
                                                {
                                                  v133 = CFSTR("Failed to populate sealedData from local data store. Data recovery failed.");
                                                }
                                                AMFDRErrorPushInternal((uint64_t)v6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", v133, v154);
LABEL_324:
                                                v57 = 0;
                                                goto LABEL_73;
                                              }
                                              v142 = CFSTR("AMFDRSealedDataConfigureOptionsForRecover failed.");
                                            }
                                            else
                                            {
                                              v142 = CFSTR("Failed to clear populated data from sealedData. Data Recovery failed.");
                                            }
                                            AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", v142, v154);
                                            goto LABEL_324;
                                          }
                                          AMFDRErrorPushInternal((uint64_t)v6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("AMFDRSealedDataRestoreOptions failed."), v154);
LABEL_391:
                                          v57 = 0;
                                          v58 = 0;
                                          goto LABEL_73;
                                        }
                                        formatb = CFSTR("AMFDRSealedDataCommit with amfdrLocal failed. Data Recovery failed.");
                                        goto LABEL_380;
                                      }
                                      v141 = CFSTR("Failed to export sealedData");
                                    }
                                    else
                                    {
                                      v141 = CFSTR("sealedData->sealingManifest is NULL. Sealing failed.");
                                    }
                                    formata = v141;
LABEL_383:
                                    AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", formata, v154);
                                    goto LABEL_320;
                                  }
LABEL_289:
                                  if (*v6)
                                  {
                                    CFRelease(*v6);
                                    *v6 = 0;
                                  }
                                  goto LABEL_291;
                                }
                                if (AMFDRAPTicketAllowsUnsealedData(a3))
                                {
                                  AMSupportLogInternal();
                                  v58 = 0;
                                  v59 = 0;
                                  goto LABEL_252;
                                }
                                AMFDRSetStat((CFMutableDictionaryRef *)cf, CFSTR("FDRSealingFail"), 1);
                                v6 = v161;
                                AMFDRSetStat((CFMutableDictionaryRef *)a3, CFSTR("FDRSealingFail"), 1);
                                AMFDRErrorPushInternal((uint64_t)v161, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("AMFDRSealedDataSign failed. Sealing failed."), v154);
LABEL_320:
                                v57 = 0;
                                v58 = 0;
                                v59 = 0;
                                goto LABEL_73;
                              }
                              v146 = CFSTR("sealedData->sealingRequest is NULL. Sealing failed.");
LABEL_382:
                              formata = v146;
                              goto LABEL_383;
                            }
                            AMFDRErrorPushInternal((uint64_t)v161, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("AMFDRDataCopyAsidMetadataParameters failed"), v154);
LABEL_410:
                            v57 = 0;
                            v58 = 0;
                            v59 = 0;
                            goto LABEL_72;
                          }
                        }
                        formatc = CFSTR("AMFDRDataCreateRepairConfigurationAsidMetadata failed");
LABEL_409:
                        v6 = v161;
                        AMFDRErrorPushInternal((uint64_t)v161, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", formatc, v154);
                        goto LABEL_410;
                      }
                      v144 = CFSTR("SerialNumber is required for sealing");
                    }
                    else
                    {
                      v144 = CFSTR("failed to get FDR data version");
                    }
                    v6 = v161;
                    AMFDRErrorPushInternal((uint64_t)v161, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", v144, v154);
                    goto LABEL_403;
                  }
                  v143 = CFSTR("Sealing is not allowed if FDRAllowUnsealedData is enabled");
                }
                AMFDRErrorPushInternal((uint64_t)v6, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", v143, v154);
                goto LABEL_403;
              }
              if (!v6 || (AMFDRSealedDataVerificationErrorIsBenign(v99, (CFDictionaryRef *)cf, 0, 0, 1, *v6) & 1) == 0)
              {
                AMSupportLogInternal();
                goto LABEL_403;
              }
              v101 = v159;
              if (v20)
                v101 = 1;
              if (((v101 | v158) & 1) != 0 || !_AMFDRVerificationErrorRemoteDataIsSealed(a3, v6))
                goto LABEL_230;
              AMSupportLogInternal();
              if (v167)
              {
                v102 = *(const __CFString **)(a1 + 16);
                v103 = v156;
                if (!v102)
                {
                  v102 = (const __CFString *)CFRetain(v167);
                  *(_QWORD *)(a1 + 16) = v102;
                }
                AMFDRSetOption(a3, CFSTR("SealingManifest"), v102);
                v62 = 0;
                v61 = 0;
                v60 = 0;
                goto LABEL_289;
              }
              AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("sealingIM4M is NULL"), v154);
LABEL_361:
              v57 = 0;
              goto LABEL_69;
            }
            AMFDRErrorPushInternal((uint64_t)v161, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("_deleteFromSealedData failed with error %@"), (char)v176);
          }
          v57 = 0;
LABEL_395:
          v58 = 0;
          v59 = 0;
          v60 = 0;
          v61 = 0;
          v62 = 0;
          goto LABEL_170;
        }
        AMFDRErrorPushInternal((uint64_t)v161, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("userInfo is NULL"), v154);
      }
      else
      {
        AMFDRErrorPushInternal((uint64_t)v161, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("AMFDRSealedDataVerify failed but outError is NULL."), v154);
      }
      v57 = 0;
      v162 = 0;
      cfb = 0;
      goto LABEL_70;
    }
    v81 = (const void *)*MEMORY[0x24BDBD270];
    CFDictionaryAddValue(theDict, CFSTR("SkipManifest"), (const void *)*MEMORY[0x24BDBD270]);
    if (v77)
      CFDictionarySetValue(theDict, CFSTR("KeepExistingData"), v81);
    v82 = __AMFDRSealedDataPopulatePrivate(theDict, a1, a3, 0, 0, 0, 0, (uint64_t)v69);
    CFDictionaryRemoveValue(theDict, CFSTR("SkipManifest"));
    CFDictionaryRemoveValue(theDict, CFSTR("KeepExistingData"));
    _AMFDRSealedDataSetFDRInfo((__CFError **)v69, CFSTR("MissingDataInstances"), Mutable, CFSTR("MissingDataInstances"));
    v83 = v155;
    if ((v82 & 1) == 0)
    {
      v6 = (__CFError **)v69;
      if ((AMFDRDataErrorIsBenign(a3, (char)CFSTR("AMFDRSealedDataPopulate"), (CFErrorRef *)v69) & 1) == 0)
      {
        v140 = CFSTR("AMFDRSealedDataPopulate with amfdrRemote failed with a fatal error");
        goto LABEL_349;
      }
      AMSupportLogInternal();
      if (v69 && *v69)
      {
        CFRelease(*v69);
        *v69 = 0;
      }
    }
    if (AMFDRSealedDataIsEmpty(a1))
    {
LABEL_169:
      AMSupportLogInternal();
      v162 = 0;
      cfb = 0;
      v167 = 0;
      v58 = 0;
      v59 = 0;
      v60 = 0;
      v61 = 0;
      v62 = 0;
      v57 = 1;
LABEL_170:
      v6 = v161;
      goto LABEL_73;
    }
    AMFDRSetOption(a3, CFSTR("SealingManifest"), 0);
    v6 = v161;
    if (AMFDRSealedDataVerify((_QWORD *)a1, a3, (uint64_t)v161))
    {
      AMSupportLogInternal();
      cfb = 0;
      goto LABEL_187;
    }
    if (v161 && *v161)
    {
      _AMFDRSealedDataSetFDRInfo(v161, CFSTR("UnverifiedDataInstances"), Mutable, CFSTR("UnverifiedDataInstances"));
      v86 = CFErrorCopyUserInfo(*v161);
      if (!v86)
      {
        format = CFSTR("userInfo is NULL");
        *(_OWORD *)v148 = 0u;
        v149 = 0u;
        *(_OWORD *)value = 0u;
        goto LABEL_174;
      }
      cfb = v86;
      v87 = (const __CFDictionary *)CFDictionaryGetValue(v86, CFSTR("UnverifiedDataInstances"));
      if (v87)
      {
        v88 = v87;
        v89 = CFGetAllocator((CFTypeRef)a1);
        v90 = CFDictionaryCreateMutable(v89, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        if (!v90)
        {
          v6 = v161;
          AMFDRErrorPushInternal((uint64_t)v161, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("Failed to allocate dataIntanceToDelete."), v154);
          v57 = 0;
          goto LABEL_68;
        }
        context = a3;
        v179 = (CFTypeRef *)a1;
        v180 = v90;
        v181 = &v176;
        v182 = &v177;
        v91 = v90;
        CFDictionaryApplyFunction(v88, (CFDictionaryApplierFunction)_checkVerificationError, &context);
        v162 = v91;
        if (v176)
        {
          AMFDRErrorPushInternal((uint64_t)v161, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("_checkVerificationError %@"), (char)v176);
        }
        else
        {
          context = a1;
          v179 = &v176;
          v180 = 0;
          v181 = 0;
          CFDictionaryApplyFunction(v91, (CFDictionaryApplierFunction)_deleteFromSealedData, &context);
          if (!v176)
          {
            v6 = v161;
            v83 = v155;
            goto LABEL_188;
          }
          AMFDRErrorPushInternal((uint64_t)v161, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("_deleteFromSealedData failed with error %@"), (char)v176);
        }
        v57 = 0;
        v167 = 0;
        goto LABEL_395;
      }
LABEL_187:
      v162 = 0;
LABEL_188:
      if ((AMFDRSealedDataCommit(a1, cf, 0, (uint64_t)v6) & 1) == 0)
      {
        AMFDRErrorPushInternal((uint64_t)v6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("AMFDRSealedDataCommit with amfdrLocal failed. Data Recovery failed."), v154);
        goto LABEL_361;
      }
      if (v31)
      {
        if ((_AMFDRSealedDataExport((CFArrayRef *)a1, (CFDictionaryRef *)a3, v31, (uint64_t)v6) & 1) == 0)
        {
          AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("Failed to export data %@."), (char)v31);
          goto LABEL_361;
        }
        AMSupportLogInternal();
      }
      if (v83)
      {
        v59 = (const __CFString *)CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberIntType, &valuePtr);
        AMFDRSetOption(a3, CFSTR("DataVersion"), v59);
        AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD268]);
        if ((_AMFDRSealedDataExport((CFArrayRef *)a1, (CFDictionaryRef *)a3, v83, (uint64_t)v6) & 1) == 0)
        {
          AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("exportLegacyData: Failed to export legacy data %@."), (char)v83);
          goto LABEL_398;
        }
        AMSupportLogInternal();
        AMFDRSetOption(a3, CFSTR("DataVersion"), v157);
        AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), v47);
      }
      else
      {
        v59 = 0;
      }
      v92 = *(const __CFArray **)(a1 + 48);
      if (!v92 || !CFArrayGetCount(v92))
        goto LABEL_250;
      AMSupportLogInternal();
      if (_AMFDRSealedDataCopyAndCommitIntraFactoryData(a1, (const __CFString *)cf, a3, (uint64_t)v6))
      {
        AMSupportLogInternal();
LABEL_250:
        AMSupportLogInternal();
        v167 = 0;
        v58 = 0;
LABEL_251:
        v60 = 0;
        v61 = 0;
        v62 = 0;
LABEL_252:
        v57 = 1;
        goto LABEL_73;
      }
      if (v6 && *v6)
      {
        if (CFErrorGetCode(*v6) == 33)
        {
          _AMFDRSealedDataSetFDRInfo(v6, CFSTR("MissingDataInstances"), Mutable, CFSTR("MissingIntraFactoryDataInstances"));
          if (*v6)
          {
            CFRelease(*v6);
            *v6 = 0;
          }
          goto LABEL_250;
        }
        v145 = CFSTR("_AMFDRSealedDataCopyAndCommitIntraFactoryData got unexpected error");
      }
      else
      {
        v145 = CFSTR("_AMFDRIntraDataCopyAndCommitInternal failed but outError is NULL.");
      }
      AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", v145, v154);
LABEL_398:
      v57 = 0;
      v167 = 0;
      v58 = 0;
      goto LABEL_71;
    }
    v140 = CFSTR("AMFDRSealedDataVerify failed but outError is NULL.");
LABEL_349:
    AMFDRErrorPushInternal((uint64_t)v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", v140, v154);
    goto LABEL_67;
  }
  v39 = v38;
  v40 = CFGetTypeID(v38);
  if (v40 != CFArrayGetTypeID())
  {
LABEL_352:
    v54 = CFSTR("kAMFDROptionExportDataClasses is not array");
    goto LABEL_64;
  }
  v41 = CFArrayGetCount(v39);
  if (v41 < 1)
  {
LABEL_45:
    AMSupportLogInternal();
    if ((_AMFDRDataClaimInternal((const void *)a3, *(const __CFArray **)(a1 + 32), *(const __CFArray **)(a1 + 40), *(const void **)(a1 + 248), *(const void **)(a1 + 256), *(const __CFArray **)(a1 + 240), v39, (CFTypeRef *)v6) & 1) == 0)
    {
      AMFDRErrorPushInternal((uint64_t)v6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataRecover", CFSTR("_AMFDRDataClaim failed"), v154);
      goto LABEL_67;
    }
    goto LABEL_46;
  }
  v42 = v41;
  v43 = 0;
  while (1)
  {
    v44 = CFArrayGetValueAtIndex(v39, v43);
    if (!v44)
      break;
    v45 = CFGetTypeID(v44);
    v120 = v45 == CFStringGetTypeID();
    v6 = v161;
    if (!v120)
      break;
    if (v42 == ++v43)
      goto LABEL_45;
  }
LABEL_62:
  v54 = CFSTR("malformed dataClass");
LABEL_64:
  format = v54;
  *(_OWORD *)v148 = 0u;
  v149 = 0u;
  *(_OWORD *)value = 0u;
LABEL_65:
  v55 = (uint64_t)v6;
  v56 = 1;
LABEL_66:
  AMFDRErrorPushInternal(v55, v56, 0, 0, 0, 0, 0, 0, value[0], value[1], v148[0], v148[1], (void *)v149, *((void **)&v149 + 1), (uint64_t)"AMFDRSealedDataRecover", format, v154);
LABEL_67:
  v57 = 0;
  cfb = 0;
LABEL_68:
  v162 = 0;
LABEL_69:
  v167 = 0;
LABEL_70:
  v58 = 0;
  v59 = 0;
LABEL_71:
  v60 = 0;
LABEL_72:
  v61 = 0;
  v62 = 0;
LABEL_73:
  AMFDRSealedDataRestoreOptions(a1, cf, a3);
  if (a5 && Mutable && CFDictionaryGetCount(Mutable) >= 1)
    *a5 = CFRetain(Mutable);
  if (cfb)
    CFRelease(cfb);
  if (theDict)
    CFRelease(theDict);
  if (v176)
  {
    CFRelease(v176);
    v176 = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v162)
    CFRelease(v162);
  if (v167)
    CFRelease(v167);
  if (v58)
    CFRelease(v58);
  if (v59)
    CFRelease(v59);
  if (v60)
    CFRelease(v60);
  if (v61)
    CFRelease(v61);
  if (v175)
  {
    CFRelease(v175);
    v175 = 0;
  }
  if (v174)
  {
    CFRelease(v174);
    v174 = 0;
  }
  if (v173)
  {
    CFRelease(v173);
    v173 = 0;
  }
  if (v172)
  {
    CFRelease(v172);
    v172 = 0;
  }
  if (v62)
    CFRelease(v62);
  v63 = v57 ^ 1;
  if (!v6)
    v63 = 1;
  if ((v63 & 1) == 0 && *v6)
  {
    CFRelease(*v6);
    *v6 = 0;
  }
  return v57;
}

uint64_t AMFDRSealedDataConfigureOptionsForRecover(uint64_t a1, CFTypeRef *a2, uint64_t a3, const void *a4, uint64_t a5)
{
  const void **v10;
  const void *v11;
  const void *v12;
  const __CFAllocator *v13;
  __CFDictionary *MutableCopy;
  const void *v15;
  const void *v16;
  const void *v17;
  const __CFBoolean *v18;
  const void *v19;
  const __CFAllocator *v20;
  __CFDictionary *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const __CFString *v26;
  const __CFString *v27;
  char v28;

  if (a1)
  {
    if (a2)
    {
      if (a4)
      {
        v10 = (const void **)MEMORY[0x24BDBD268];
        if (!a3)
          goto LABEL_16;
        v11 = (const void *)AMFDRGetOptions(a3);
        *(_QWORD *)(a1 + 120) = CFRetain(v11);
        v12 = *(const void **)(a1 + 104);
        if (v12)
        {
          CFRelease(v12);
          *(_QWORD *)(a1 + 104) = 0;
        }
        v13 = CFGetAllocator(a2);
        MutableCopy = CFDictionaryCreateMutableCopy(v13, 0, *(CFDictionaryRef *)(a1 + 120));
        *(_QWORD *)(a1 + 104) = MutableCopy;
        if (MutableCopy)
        {
          v15 = *v10;
          CFDictionarySetValue(MutableCopy, CFSTR("VerifyData"), *v10);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), CFSTR("SignData"), v15);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), CFSTR("GetCombined"), v15);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), CFSTR("INST"), a4);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), CFSTR("PutCombined"), v15);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), CFSTR("CopyAllowUnsealed"), v15);
          v16 = *(const void **)(a1 + 16);
          if (v16)
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), CFSTR("SealingManifest"), v16);
          v17 = *(const void **)(a1 + 200);
          if (v17)
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), CFSTR("PairedSoCs"), v17);
          v18 = *(const __CFBoolean **)(a1 + 216);
          if (v18 && CFBooleanGetValue(v18))
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), CFSTR("DeprecateV1"), *(const void **)(a1 + 216));
          if ((AMFDRSetOptions(a3, *(CFTypeRef *)(a1 + 104)) & 1) != 0)
          {
LABEL_16:
            *(_QWORD *)(a1 + 112) = CFRetain(a2[2]);
            v19 = *(const void **)(a1 + 96);
            if (v19)
            {
              CFRelease(v19);
              *(_QWORD *)(a1 + 96) = 0;
            }
            v20 = CFGetAllocator(a2);
            v21 = CFDictionaryCreateMutableCopy(v20, 0, *(CFDictionaryRef *)(a1 + 112));
            *(_QWORD *)(a1 + 96) = v21;
            if (v21)
            {
              v22 = *v10;
              CFDictionarySetValue(v21, CFSTR("VerifyData"), *v10);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 96), CFSTR("SignData"), v22);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 96), CFSTR("GetCombined"), v22);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 96), CFSTR("CopyAllowUnsealed"), v22);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 96), CFSTR("INST"), a4);
              v23 = *(const void **)(a1 + 16);
              if (v23)
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 96), CFSTR("SealingManifest"), v23);
              v24 = *(const void **)(a1 + 200);
              if (v24)
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 96), CFSTR("PairedSoCs"), v24);
              if ((AMFDRSetOptions((uint64_t)a2, *(CFTypeRef *)(a1 + 96)) & 1) != 0)
                return 1;
              v27 = CFSTR("AMFDRSetOptions(amfdrLocal) failed.");
            }
            else
            {
              v27 = CFSTR("localOptions allocation. Sealing failed.");
            }
            goto LABEL_33;
          }
          v27 = CFSTR("AMFDRSetOptions(amfdrRemote) failed.");
        }
        else
        {
          v27 = CFSTR("remoteOptions allocation. Sealing failed.");
        }
LABEL_33:
        AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataConfigureOptionsForRecover", v27, v28);
        return 0;
      }
      v26 = CFSTR("sealedDataInstance is NULL");
    }
    else
    {
      v26 = CFSTR("amfdrLocal is NULL");
    }
  }
  else
  {
    v26 = CFSTR("sealedData is NULL");
  }
  AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataConfigureOptionsForRecover", v26, v28);
  return 0;
}

void _AMFDRSealedDataSetFDRInfo(__CFError **a1, const void *a2, __CFDictionary *a3, const void *a4)
{
  __CFError *v6;
  BOOL v7;
  const void *v9;
  const void *v10;

  if (a1 && a3)
  {
    v6 = *a1;
    if (v6)
      v7 = a2 == 0;
    else
      v7 = 1;
    if (!v7 && a4 != 0)
    {
      v9 = (const void *)AMFDRCopyUnderlyingDictionary(v6, a2);
      if (v9)
      {
        v10 = v9;
        CFDictionarySetValue(a3, a4, v9);
        CFRelease(v10);
      }
    }
  }
}

uint64_t AMFDRSealedDataVerify(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  CFTypeRef v5;
  const void *v6;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  CFIndex Count;
  const __CFAllocator *v11;
  const CFArrayCallBacks *v12;
  CFMutableArrayRef Mutable;
  const __CFAllocator *v14;
  const __CFAllocator *v15;
  const __CFAllocator *v16;
  const __CFAllocator *v17;
  const __CFAllocator *v18;
  const __CFAllocator *v19;
  const CFDictionaryKeyCallBacks *v20;
  const CFDictionaryValueCallBacks *v21;
  const __CFAllocator *v22;
  const __CFAllocator *v23;
  const __CFAllocator *v24;
  const __CFString *v25;
  const __CFString *v26;
  CFIndex v27;
  CFArrayRef *v28;
  CFStringRef v29;
  const __CFString *ValueAtIndex;
  const __CFString *v31;
  const __CFString *v32;
  CFTypeID v33;
  CFTypeID v34;
  const __CFAllocator *v35;
  CFStringRef FullKey;
  CFStringRef v37;
  const __CFDictionary *v38;
  const __CFAllocator *v39;
  const __CFArray *v40;
  const __CFArray *v41;
  const __CFBoolean *v42;
  int v43;
  char v44;
  char v45;
  const __CFDictionary *v46;
  const __CFData *v47;
  CFDataRef *v48;
  int v49;
  int v50;
  const __CFString *v51;
  const UInt8 *BytePtr;
  CFIndex Length;
  __CFArray *v54;
  const __CFDictionary *v55;
  const __CFArray *v56;
  const __CFArray *v57;
  const __CFString *v58;
  CFTypeID v59;
  const __CFAllocator *v60;
  __CFString *MutableCopy;
  __CFString *v62;
  CFIndex v63;
  char v64;
  const __CFArray *v65;
  CFArrayRef *v66;
  CFIndex v67;
  const void *v68;
  const __CFString *v69;
  const __CFDictionary *v70;
  const __CFDictionary *v71;
  const __CFDictionary *v72;
  CFTypeID v73;
  const __CFArray *v74;
  int v75;
  char v76;
  const __CFDictionary *v77;
  const __CFString *v78;
  char v79;
  const __CFArray *v80;
  CFIndex v81;
  CFIndex v82;
  CFIndex v83;
  const __CFString *v84;
  const __CFString *v85;
  CFComparisonResult v86;
  BOOL v87;
  const __CFArray *v88;
  const __CFString *v89;
  const __CFString *v90;
  const __CFString *v91;
  const __CFString *v92;
  CFIndex v93;
  BOOL v94;
  CFIndex v95;
  CFStringRef v96;
  const __CFString *v97;
  CFTypeID v98;
  const __CFAllocator *v99;
  const __CFDictionary *v100;
  const __CFData *v101;
  const __CFData *v102;
  char v103;
  const __CFDictionary *v104;
  const __CFDictionary *v105;
  CFTypeID v106;
  const __CFArray *v107;
  const __CFArray *v108;
  CFTypeID v109;
  CFTypeID v110;
  CFTypeID v111;
  __int128 v112;
  CFIndex v113;
  const __CFString *v114;
  const __CFString *v116;
  const __CFBoolean *v117;
  const __CFBoolean *v118;
  CFTypeID v119;
  int v120;
  CFIndex v121;
  CFTypeID v122;
  CFIndex v123;
  const __CFString *v124;
  const void *v125;
  const void *v126;
  CFTypeID v127;
  const __CFArray *v128;
  const __CFBoolean *v129;
  const __CFBoolean *v130;
  CFTypeID v131;
  BOOL v132;
  uint64_t v133;
  __CFString *v134;
  const void *v135;
  CFIndex v137;
  const void *v138;
  const void *v139;
  CFTypeID v140;
  char v141;
  const __CFString *v142;
  const __CFString *v143;
  const __CFString *v144;
  const __CFString *v145;
  const __CFString *v146;
  uint64_t v147;
  CFIndex v148;
  const __CFString *v149;
  void *value[2];
  void *v151[2];
  void *v152[2];
  const __CFString *format;
  char v154;
  uint64_t v155;
  __CFArray *v156;
  CFArrayRef v157;
  CFDictionaryRef theDict;
  __CFArray *v159;
  CFDictionaryRef v160;
  __CFArray *v161;
  __CFArray *v162;
  const __CFString *v163;
  __CFArray *v164;
  int v165;
  CFTypeRef v166;
  CFDictionaryRef v167;
  CFDictionaryRef *v168;
  __CFArray *theArray;
  int v170;
  __CFString *v171;
  CFIndex v172;
  _BOOL4 v173;
  const __CFString *v174;
  const __CFString *v175;
  const __CFString *v176;
  BOOL v177;
  CFIndex v178;
  const __CFData *v179;
  CFTypeRef v180[2];
  uint64_t v181;
  uint64_t v182;
  CFTypeRef cf;
  CFTypeRef v184;
  CFTypeRef v185;
  char buffer[4];
  char v187;
  uint64_t v188;
  CFArrayRef v189;
  _OWORD __s2[3];
  __int128 context;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  __int128 v218;
  unint64_t v219;
  uint64_t v220;
  CFRange v221;
  CFRange v222;
  CFRange v223;
  CFRange v224;
  CFRange v225;

  v4 = a2;
  v5 = a1;
  v220 = *MEMORY[0x24BDAC8D0];
  v182 = 0;
  cf = 0;
  v180[1] = 0;
  v181 = 0;
  v180[0] = 0;
  memset(__s2, 0, sizeof(__s2));
  if (!a2)
  {
    v149 = CFSTR("amfdr is NULL");
LABEL_309:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", v149, v154);
LABEL_314:
    v132 = 0;
    goto LABEL_261;
  }
  if (!*(_QWORD *)(a2 + 16))
  {
    v149 = CFSTR("amfdr->optionsDict is NULL");
    goto LABEL_309;
  }
  if (!a1)
  {
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", CFSTR("sealedData is NULL"), v154);
    v133 = 0;
    v134 = CFSTR("FDRSealedVerifyFail");
    goto LABEL_266;
  }
  if (!a1[4])
  {
    v149 = CFSTR("sealedData->dataClassArray is NULL");
    goto LABEL_309;
  }
  v6 = (const void *)a1[5];
  if (!v6)
  {
    v149 = CFSTR("sealedData->dataInstanceArray is NULL");
    goto LABEL_309;
  }
  if (!*((_QWORD *)v5 + 8))
  {
    v149 = CFSTR("sealedData->dataArray is NULL");
    goto LABEL_309;
  }
  v7 = CFGetTypeID(v6);
  if (v7 != CFArrayGetTypeID())
  {
    v146 = CFSTR("dataInstanceArray is not a CFArray");
    goto LABEL_313;
  }
  v8 = (const void *)*((_QWORD *)v5 + 8);
  if (!v8 || (v9 = CFGetTypeID(v8), v9 != CFArrayGetTypeID()))
  {
    v146 = CFSTR("dataArray is not a CFArray");
LABEL_313:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", v146, v154);
    goto LABEL_314;
  }
  Count = CFArrayGetCount(*((CFArrayRef *)v5 + 4));
  if (Count != CFArrayGetCount(*((CFArrayRef *)v5 + 5)))
  {
    CFArrayGetCount(*((CFArrayRef *)v5 + 5));
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", CFSTR("dataClassArray length (%ld) does not match dataInstanceArray (%ld)"), Count);
    goto LABEL_314;
  }
  if (Count != CFArrayGetCount(*((CFArrayRef *)v5 + 8)))
  {
    v154 = Count;
    CFArrayGetCount(*((CFArrayRef *)v5 + 8));
    v146 = CFSTR("dataClassArray length (%ld) does not match dataArray (%ld)");
    goto LABEL_313;
  }
  v11 = CFGetAllocator(v5);
  v12 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  Mutable = CFArrayCreateMutable(v11, 0, MEMORY[0x24BDBD690]);
  v14 = CFGetAllocator(v5);
  v157 = CFArrayCreateMutable(v14, 0, v12);
  v15 = CFGetAllocator(v5);
  v164 = CFArrayCreateMutable(v15, 0, v12);
  v16 = CFGetAllocator(v5);
  theArray = CFArrayCreateMutable(v16, 0, v12);
  v17 = CFGetAllocator(v5);
  v161 = CFArrayCreateMutable(v17, 0, v12);
  v18 = CFGetAllocator(v5);
  v156 = CFArrayCreateMutable(v18, 0, v12);
  v19 = CFGetAllocator(v5);
  v20 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
  v21 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
  v167 = CFDictionaryCreateMutable(v19, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v22 = CFGetAllocator(v5);
  theDict = CFDictionaryCreateMutable(v22, 0, v20, v21);
  v23 = CFGetAllocator(v5);
  v160 = CFDictionaryCreateMutable(v23, 0, v20, v21);
  v24 = CFGetAllocator(v5);
  v159 = CFArrayCreateMutable(v24, 0, v12);
  v162 = Mutable;
  if (!Mutable || !v157 || !theArray || !v167 || !theDict || !v164 || !v160 || !v159 || !v161 || !v156)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", CFSTR("Failed to allocate arrays or dictionaries"), v154);
    v132 = 0;
    goto LABEL_261;
  }
  v25 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 16), CFSTR("SealingManifest"));
  v26 = v25;
  if (v25)
    CFRetain(v25);
  v155 = a3;
  v163 = v26;
  v168 = (CFDictionaryRef *)v4;
  if (Count >= 1)
  {
    v171 = 0;
    v172 = Count;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v166 = v5;
    while (1)
    {
      if (v29)
        CFRelease(v29);
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)v5 + 4), v27);
      v31 = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)v5 + 5), v27);
      if (!ValueAtIndex)
      {
        v142 = CFSTR("dataClass is NULL. Verification failed.");
LABEL_282:
        AMFDRErrorPushInternal(v155, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", v142, v154);
        goto LABEL_301;
      }
      v32 = v31;
      if (!v31)
      {
        v142 = CFSTR("dataInstance is NULL. Verification failed.");
        goto LABEL_282;
      }
      v33 = CFGetTypeID(ValueAtIndex);
      if (v33 != CFStringGetTypeID())
      {
        v143 = CFSTR("dataClass is not a CFString. Verification failed.");
LABEL_285:
        AMFDRErrorPushInternal(v155, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", v143, v154);
        goto LABEL_301;
      }
      v34 = CFGetTypeID(v32);
      if (v34 != CFStringGetTypeID())
      {
        v143 = CFSTR("dataInstance is not a CFString. Verification failed.");
        goto LABEL_285;
      }
      v35 = CFGetAllocator(v5);
      FullKey = AMFDRDataLocalCreateFullKey(v35, (uint64_t)ValueAtIndex, (uint64_t)v32);
      if (FullKey)
      {
        v37 = FullKey;
        v38 = (const __CFDictionary *)*((_QWORD *)v5 + 16);
        if (v38)
          v175 = (const __CFString *)CFDictionaryGetValue(v38, v37);
        else
          v175 = 0;
        CFRelease(v37);
      }
      else
      {
        AMSupportLogInternal();
        v175 = 0;
      }
      v39 = CFGetAllocator(v5);
      v29 = AMFDRDataLocalCreateFullKey(v39, (uint64_t)ValueAtIndex, (uint64_t)v32);
      if (!v29)
      {
        AMFDRErrorPushInternal(v155, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", CFSTR("failed to create data instance string"), v154);
        goto LABEL_301;
      }
      v179 = (const __CFData *)CFArrayGetValueAtIndex(*((CFArrayRef *)v5 + 8), v27);
      v40 = (const __CFArray *)*((_QWORD *)v5 + 37);
      if (v40)
      {
        v221.length = CFArrayGetCount(*((CFArrayRef *)v5 + 37));
        v221.location = 0;
        v177 = CFArrayContainsValue(v40, v221, ValueAtIndex) != 0;
      }
      else
      {
        v177 = 0;
      }
      v41 = (const __CFArray *)*((_QWORD *)v5 + 35);
      if (v41)
      {
        v222.length = CFArrayGetCount(*((CFArrayRef *)v5 + 35));
        v222.location = 0;
        v173 = CFArrayContainsValue(v41, v222, ValueAtIndex) != 0;
      }
      else
      {
        v173 = 0;
      }
      if (*(uint64_t (***)(int, int, int, int))(v4 + 48) != AMFDRHTTPStore)
      {
        v42 = (const __CFBoolean *)*((_QWORD *)v5 + 26);
        if (v42)
        {
          v43 = CFBooleanGetValue(v42);
          v44 = v177;
          if (v43)
            v45 = v177;
          else
            v45 = 1;
          if (v43)
            v44 = 1;
          v177 = v44;
          if ((v45 & 1) == 0)
          {
            AMSupportLogInternal();
            v177 = 1;
          }
        }
      }
      v46 = *(const __CFDictionary **)(v4 + 112);
      if (v46)
        v47 = (const __CFData *)CFDictionaryGetValue(v46, v29);
      else
        v47 = 0;
      if (!v179)
      {
        if (v177)
          CFArrayAppendValue(v162, v29);
        else
          AMSupportLogInternal();
        if (v173)
          *(_BYTE *)(v4 + 40) = 0;
        if (!v47)
          goto LABEL_148;
        v54 = theArray;
        goto LABEL_80;
      }
      if (v180[0])
      {
        CFRelease(v180[0]);
        v180[0] = 0;
      }
      v48 = v47 ? (CFDataRef *)&cf : 0;
      v170 = AMFDRSealingMapEntryHasSubCCListForClassInternal(v4, ValueAtIndex);
      v49 = AMFDRDataVerifyInternal(v4, ValueAtIndex, v32, v175, v179, 0, v170, v48, (uint64_t)v180);
      if (v47 && cf)
      {
        v50 = v49;
        v51 = v29;
        CFDataGetBytePtr((CFDataRef)cf);
        CFDataGetLength((CFDataRef)cf);
        if (AMSupportDigestSha384())
        {
          v145 = CFSTR("Failed to compute digest of raw data.");
LABEL_292:
          AMFDRErrorPushInternal(v155, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", v145, v154);
          v132 = 0;
          goto LABEL_261;
        }
        if (CFDataGetLength(v47) != 48)
        {
          v145 = CFSTR("The digestValue length is not as expected.");
          goto LABEL_292;
        }
        BytePtr = CFDataGetBytePtr(v47);
        Length = CFDataGetLength(v47);
        if (!memcmp(BytePtr, __s2, Length))
        {
          v29 = v51;
        }
        else
        {
          v29 = v51;
          CFArrayAppendValue(theArray, v51);
        }
        AMSupportLogInternal();
        v49 = v50;
      }
      else if (v47 && !cf)
      {
        CFArrayAppendValue(theArray, v29);
      }
      v55 = (const __CFDictionary *)*((_QWORD *)v5 + 21);
      if (v55 && CFDictionaryContainsKey(v55, v29))
      {
        if (v28)
          CFRelease(v28);
        if (v171)
          CFRelease(v171);
        v28 = (CFArrayRef *)AMFDRDataDictCreateFromData(v4, v179, 0, 0);
        if (!v28)
        {
          AMFDRErrorPushInternal(v155, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", CFSTR("decoded of %@ is NULL"), (char)ValueAtIndex);
          goto LABEL_301;
        }
        AMSupportLogInternal();
        v56 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)v5 + 21), v29);
        if (!v56 || (v57 = v56, v58 = v29, v59 = CFGetTypeID(v56), v59 != CFArrayGetTypeID()))
        {
          v144 = CFSTR("unexpected subcclist array type");
          goto LABEL_296;
        }
        v165 = v49;
        v60 = CFGetAllocator(v166);
        MutableCopy = CFStringCreateMutableCopy(v60, 0, ValueAtIndex);
        if (!MutableCopy)
        {
          v144 = CFSTR("Could not create enforceDataInstanceString");
LABEL_296:
          AMFDRErrorPushInternal(v155, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", v144, v154);
          v132 = 0;
          v5 = v166;
LABEL_261:
          v133 = 0;
          v134 = CFSTR("FDRSealedVerifyFail");
          if (v5 && !v132)
          {
            v135 = (const void *)*((_QWORD *)v5 + 2);
            if (v135)
              CFRelease(v135);
            v133 = 0;
            *((_QWORD *)v5 + 2) = 0;
            v134 = CFSTR("FDRSealedVerifyFail");
          }
          goto LABEL_266;
        }
        v62 = MutableCopy;
        CFStringAppend(MutableCopy, CFSTR(":"));
        v171 = v62;
        CFStringAppend(v62, v32);
        if (CFArrayGetCount(v57) < 1)
        {
LABEL_103:
          AMSupportLogInternal();
        }
        else
        {
          v63 = 0;
          v64 = 0;
          do
          {
            while (1)
            {
              v65 = v28[4];
              if (v65)
              {
                v66 = v28;
                v67 = CFArrayGetCount(v28[4]);
                v68 = CFArrayGetValueAtIndex(v57, v63);
                v223.location = 0;
                v223.length = v67;
                v28 = v66;
                if (CFArrayContainsValue(v65, v223, v68))
                  break;
              }
              CFStringAppend(v171, CFSTR("/"));
              v69 = (const __CFString *)CFArrayGetValueAtIndex(v57, v63);
              CFStringAppend(v171, v69);
              ++v63;
              v64 = 1;
              if (v63 >= CFArrayGetCount(v57))
                goto LABEL_102;
            }
            ++v63;
          }
          while (v63 < CFArrayGetCount(v57));
          if ((v64 & 1) == 0)
            goto LABEL_103;
LABEL_102:
          CFArrayAppendValue(v161, v171);
        }
        v4 = (uint64_t)v168;
        v29 = v58;
        v5 = v166;
        v49 = v165;
      }
      if (v49)
        break;
      if (v177 || *(uint64_t (***)(int, int, int, int))(v4 + 48) == AMFDRHTTPStore)
        goto LABEL_114;
      AMSupportLogInternal();
      if ((AMFDRDataDelete(v4) & 1) == 0)
      {
        AMSupportLogInternal();
LABEL_114:
        if (v173)
          *(_BYTE *)(v4 + 40) = 0;
        if (!v180[0])
        {
          format = CFSTR("verifyError is NULL");
          goto LABEL_299;
        }
LABEL_117:
        AMFDRGetTrustError((__CFError *)v180[0]);
LABEL_118:
        AMSupportCFDictionarySetInteger64();
      }
LABEL_126:
      v77 = (const __CFDictionary *)*((_QWORD *)v5 + 19);
      if (!v77 || !CFDictionaryContainsKey(v77, v29))
      {
        v80 = (const __CFArray *)*((_QWORD *)v5 + 17);
        if (!v80)
          goto LABEL_148;
        v81 = CFArrayGetCount(v80);
        if (v81 < 1)
          goto LABEL_148;
        v82 = v81;
        v83 = 0;
        do
        {
          while (1)
          {
            v84 = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)v5 + 17), v83);
            if (CFStringCompare(ValueAtIndex, v84, 0) == kCFCompareEqualTo)
              break;
            if (++v83 >= v82)
              goto LABEL_148;
          }
          v85 = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)v5 + 18), v83);
          v86 = CFStringCompare(v32, v85, 0);
          ++v83;
          if (v86)
            v87 = v83 < v82;
          else
            v87 = 0;
        }
        while (v87);
        if (v86)
          goto LABEL_148;
        v54 = v157;
LABEL_80:
        CFArrayAppendValue(v54, v29);
        goto LABEL_148;
      }
      v78 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)v5 + 19), v29);
      AMFDRSetOption(v4, CFSTR("SealingManifest"), v78);
      v79 = AMFDRDataVerifyInternal(v4, ValueAtIndex, v32, v175, v179, 0, v170, 0, (uint64_t)v180);
      AMFDRSetOption(v4, CFSTR("SealingManifest"), v163);
      if ((v79 & 1) == 0)
      {
        if (!v177 && *(uint64_t (***)(int, int, int, int))(v4 + 48) != AMFDRHTTPStore)
        {
          AMSupportLogInternal();
          if ((AMFDRDataDelete(v4) & 1) != 0)
            goto LABEL_148;
          AMSupportLogInternal();
        }
        if (v173)
          *(_BYTE *)(v4 + 40) = 0;
        if (!v180[0])
        {
          format = CFSTR("verifyError is NULL");
LABEL_299:
          *(_OWORD *)v151 = 0u;
          *(_OWORD *)v152 = 0u;
          *(_OWORD *)value = 0u;
          v147 = v155;
          v148 = 10;
LABEL_300:
          AMFDRErrorPushInternal(v147, v148, 0, 0, 0, 0, 0, 0, value[0], value[1], v151[0], v151[1], v152[0], v152[1], (uint64_t)"AMFDRSealedDataVerify", format, v154);
LABEL_301:
          v132 = 0;
          goto LABEL_261;
        }
        AMFDRGetTrustError((__CFError *)v180[0]);
        AMSupportCFDictionarySetInteger64();
      }
LABEL_148:
      if (++v27 == v172)
        goto LABEL_155;
    }
    v70 = (const __CFDictionary *)*((_QWORD *)v5 + 20);
    if (!v70)
      goto LABEL_119;
    v71 = (const __CFDictionary *)CFDictionaryGetValue(v70, v29);
    v72 = v71;
    if (!v71)
      goto LABEL_120;
    v73 = CFGetTypeID(v71);
    if (v73 == CFDictionaryGetTypeID())
      v72 = (const __CFDictionary *)CFDictionaryGetValue(v72, CFSTR("CombinedManifest"));
    else
LABEL_119:
      v72 = 0;
LABEL_120:
    v74 = (const __CFArray *)*((_QWORD *)v5 + 34);
    if (v74)
    {
      v224.length = CFArrayGetCount(*((CFArrayRef *)v5 + 34));
      v224.location = 0;
      v75 = CFArrayContainsValue(v74, v224, ValueAtIndex);
      if (*(uint64_t (***)(int, int, int, int))(v4 + 48) != AMFDRHTTPStore)
      {
        if (v75)
        {
          if (v180[0])
          {
            CFRelease(v180[0]);
            v180[0] = 0;
          }
          AMFDRSetOption(v4, CFSTR("SealingManifest"), (const __CFString *)v72);
          v76 = AMFDRDataVerifyInternal(v4, ValueAtIndex, v32, v175, v179, 0, v170, 0, (uint64_t)v180);
          AMFDRSetOption(v4, CFSTR("SealingManifest"), v163);
          if ((v76 & 1) == 0)
          {
            if (v180[0])
              goto LABEL_117;
            goto LABEL_118;
          }
        }
      }
    }
    goto LABEL_126;
  }
LABEL_155:
  if (!*((_QWORD *)v5 + 11) || !CFDictionaryContainsKey(*(CFDictionaryRef *)(v4 + 16), CFSTR("SealingManifest")))
    goto LABEL_160;
  AMSupportLogInternal();
  if ((AMFDRSealingMapCopyPropertyTagsWithAttributeInternal((const void *)v4, CFSTR("Required"), &v182, v155) & 1) == 0)
  {
    format = CFSTR("failed to copy required sealing properties");
    *(_OWORD *)v151 = 0u;
    *(_OWORD *)v152 = 0u;
    *(_OWORD *)value = 0u;
    v147 = v155;
LABEL_319:
    v148 = 7;
    goto LABEL_300;
  }
  if ((AMFDRSealingMapCopyPropertyTagsWithAttributeInternal((const void *)v4, CFSTR("Matching"), &v181, v155) & 1) == 0)
  {
    format = CFSTR("failed to copy matching sealing properties");
    *(_OWORD *)v151 = 0u;
    *(_OWORD *)v152 = 0u;
    *(_OWORD *)value = 0u;
    v147 = v155;
    goto LABEL_319;
  }
  *(_QWORD *)&context = v4;
  *((_QWORD *)&context + 1) = v182;
  *(_QWORD *)&v192 = v181;
  *((_QWORD *)&v192 + 1) = v156;
  CFDictionaryApplyFunction(*((CFDictionaryRef *)v5 + 11), (CFDictionaryApplierFunction)_AMFDRSealedDataSealingPropertyCheck, &context);
LABEL_160:
  v88 = (const __CFArray *)*((_QWORD *)v5 + 22);
  if (!v88 || CFArrayGetCount(v88) < 1)
    goto LABEL_245;
  AMSupportLogInternal();
  v184 = 0;
  v185 = 0;
  v89 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 16), CFSTR("SealingManifestIsMinimal"));
  v90 = v89;
  if (v89)
    CFRetain(v89);
  v91 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 16), CFSTR("MinimalSealingDataInstance"));
  v92 = v91;
  if (v91)
    CFRetain(v91);
  v174 = v92;
  v176 = v90;
  v93 = CFArrayGetCount(*((CFArrayRef *)v5 + 22));
  AMFDRSetOption((uint64_t)v168, CFSTR("SealingManifestIsMinimal"), (const __CFString *)*MEMORY[0x24BDBD270]);
  if (v93 < 1)
  {
    v96 = 0;
    v94 = 1;
    goto LABEL_214;
  }
  v94 = 0;
  v95 = 0;
  v96 = 0;
  v178 = v93;
  while (1)
  {
    v97 = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)v5 + 22), v95);
    if (v96)
      CFRelease(v96);
    if (v185)
    {
      CFRelease(v185);
      v185 = 0;
    }
    if (v184)
    {
      CFRelease(v184);
      v184 = 0;
    }
    if (!v97 || (v98 = CFGetTypeID(v97), v98 != CFStringGetTypeID()))
    {
      AMFDRErrorPushInternal(v155, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataVerifyMinimalManifest", CFSTR("sealingDataInstance is not a string"), v154);
      v96 = 0;
      goto LABEL_214;
    }
    v99 = CFGetAllocator(v5);
    v96 = AMFDRDataLocalCreateFullKey(v99, (uint64_t)CFSTR("minimal-manifest"), (uint64_t)v97);
    if (!v96)
    {
      AMFDRErrorPushInternal(v155, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataVerifyMinimalManifest", CFSTR("failed to create minimal sealing data instance string"), v154);
      goto LABEL_214;
    }
    v100 = (const __CFDictionary *)*((_QWORD *)v5 + 19);
    if (!v100 || (v101 = (const __CFData *)CFDictionaryGetValue(v100, v96)) == 0)
    {
      CFArrayAppendValue(v164, v96);
      goto LABEL_202;
    }
    v102 = v101;
    AMFDRSetOption((uint64_t)v168, CFSTR("MinimalSealingDataInstance"), v97);
    v103 = AMFDRDataVerifySealingManifestInternal((uint64_t)v168, v102, v97, (uint64_t)&v185);
    if ((v103 & 1) != 0)
    {
      AMSupportLogInternal();
      goto LABEL_183;
    }
    if (!v185)
      break;
LABEL_183:
    v104 = (const __CFDictionary *)CFDictionaryGetValue(v168[2], CFSTR("MinimalManifestPropertyCheck"));
    if (v104)
    {
      v105 = v104;
      v106 = CFGetTypeID(v104);
      if (v106 == CFDictionaryGetTypeID())
      {
        v107 = (const __CFArray *)CFDictionaryGetValue(v105, v97);
        if (v107)
        {
          v108 = v107;
          v109 = CFGetTypeID(v107);
          if (v109 == CFArrayGetTypeID())
          {
            v188 = 0;
            v189 = 0;
            v187 = 0;
            *(_DWORD *)buffer = 0;
            v110 = CFGetTypeID(v102);
            if (v110 != CFDataGetTypeID())
            {
              v116 = CFSTR("invalid manifestData");
LABEL_211:
              AMFDRErrorPushInternal((uint64_t)&v184, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataVerifyMinimalManifestProperty", v116, v154);
              goto LABEL_206;
            }
            if (CFArrayGetCount(v108) <= 0)
            {
              v116 = CFSTR("no available property tags found");
              goto LABEL_211;
            }
            v111 = CFGetTypeID(v97);
            if (v111 != CFStringGetTypeID())
            {
              v116 = CFSTR("invalid dataInstance");
              goto LABEL_211;
            }
            v219 = 0xAAAAAAAAAAAAAAAALL;
            *(_QWORD *)&v112 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v112 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v217 = v112;
            v218 = v112;
            v215 = v112;
            v216 = v112;
            v213 = v112;
            v214 = v112;
            v211 = v112;
            v212 = v112;
            v209 = v112;
            v210 = v112;
            v207 = v112;
            v208 = v112;
            v205 = v112;
            v206 = v112;
            v203 = v112;
            v204 = v112;
            v201 = v112;
            v202 = v112;
            v199 = v112;
            v200 = v112;
            v197 = v112;
            v198 = v112;
            v195 = v112;
            v196 = v112;
            v193 = v112;
            v194 = v112;
            context = v112;
            v192 = v112;
            CFDataGetBytePtr(v102);
            CFDataGetLength(v102);
            if (Img4DecodeInitManifest())
            {
              AMFDRErrorPushInternal((uint64_t)&v184, 18, (const __CFNumber *)0x2000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataVerifyMinimalManifestProperty", CFSTR("trust verification error code=0x%016llX for %@:%@"), 0);
              goto LABEL_206;
            }
            if (CFArrayGetCount(v108) >= 1)
            {
              v113 = 0;
              while (1)
              {
                v114 = (const __CFString *)CFArrayGetValueAtIndex(v108, v113);
                if (!CFStringGetCString(v114, buffer, 5, 0x8000100u))
                {
                  AMFDRErrorPushInternal((uint64_t)&v184, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataVerifyMinimalManifestProperty", CFSTR("convert property tag string failed"), v154);
                  goto LABEL_206;
                }
                AMFDRTagsStringToTag((unsigned int *)buffer);
                if (Img4DecodeGetObjectPropertyData() || v188 == 0)
                  break;
                CFArrayGetValueAtIndex(v108, v113);
                AMSupportLogInternal();
                if (++v113 >= CFArrayGetCount(v108))
                  goto LABEL_199;
              }
              AMFDRErrorPushInternal((uint64_t)&v184, 18, (const __CFNumber *)0x10000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataVerifyMinimalManifestProperty", CFSTR("trust verification error code=0x%016llX for %@:%@"), 0);
LABEL_206:
              v93 = v178;
              if (!v184)
              {
                AMFDRErrorPushInternal(v155, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataVerifyMinimalManifest", CFSTR("verifyPropError is NULL"), v154);
                goto LABEL_214;
              }
LABEL_201:
              AMFDRGetTrustError((__CFError *)v185);
              AMFDRGetTrustError((__CFError *)v184);
              AMSupportCFDictionarySetInteger64();
              goto LABEL_202;
            }
LABEL_199:
            AMSupportLogInternal();
          }
        }
      }
    }
    v93 = v178;
    if ((v103 & 1) == 0)
      goto LABEL_201;
LABEL_202:
    v94 = ++v95 >= v93;
    if (v95 == v93)
      goto LABEL_214;
  }
  AMFDRErrorPushInternal(v155, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataVerifyMinimalManifest", CFSTR("verifyError is NULL"), v154);
LABEL_214:
  v4 = (uint64_t)v168;
  AMFDRSetOption((uint64_t)v168, CFSTR("SealingManifestIsMinimal"), v176);
  AMFDRSetOption((uint64_t)v168, CFSTR("MinimalSealingDataInstance"), v174);
  if (v96)
    CFRelease(v96);
  if (v185)
  {
    CFRelease(v185);
    v185 = 0;
  }
  if (v184)
  {
    CFRelease(v184);
    v184 = 0;
  }
  if (v176)
    CFRelease(v176);
  if (v174)
    CFRelease(v174);
  if (!v94)
  {
    AMFDRErrorPushInternal(v155, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerify", CFSTR("failed to verify minimal manifests"), v154);
    v132 = 0;
    goto LABEL_261;
  }
  v117 = (const __CFBoolean *)CFDictionaryGetValue(v168[2], CFSTR("SealIdentifiers"));
  if (v117 && (v118 = v117, v119 = CFGetTypeID(v117), v119 == CFBooleanGetTypeID()))
  {
    v120 = CFBooleanGetValue(v118);
    if ((AMFDRAPTicketAllowsUnsealedData((uint64_t)v168) & 1) == 0 && v120)
    {
      AMSupportLogInternal();
      *(_QWORD *)&context = 0;
      v189 = 0;
      if (!v168[2])
      {
        v124 = CFSTR("amfdr option is NULL");
        goto LABEL_324;
      }
      v121 = CFArrayGetCount(*((CFArrayRef *)v5 + 22));
      if (AMFDRDataCopySealingManifestProperty(v168, CFSTR("meta"), (uint64_t)&context)
        && (_QWORD)context
        && (v122 = CFGetTypeID((CFTypeRef)context), v122 == CFDataGetTypeID()))
      {
        if (!AMFDRDataDecodeMetaProperty((const __CFData *)context, (CFTypeRef *)&v189))
        {
          v124 = CFSTR("AMFDRDataDecodeMetaProperty failed");
          goto LABEL_324;
        }
        if (v121 != CFArrayGetCount(v189))
        {
          v124 = CFSTR("minimalManifestInstances array count is not equal to sealedData->minimalSealingDataInstances");
          goto LABEL_324;
        }
        if (v121 >= 1)
        {
          v123 = 0;
          v124 = CFSTR("minimalSealingDataInstance is not a string");
          while (1)
          {
            v125 = CFArrayGetValueAtIndex(*((CFArrayRef *)v5 + 22), v123);
            if (!v125)
              goto LABEL_324;
            v126 = v125;
            v127 = CFGetTypeID(v125);
            if (v127 != CFStringGetTypeID())
              goto LABEL_324;
            v128 = v189;
            v225.length = CFArrayGetCount(v189);
            v225.location = 0;
            if (CFArrayContainsValue(v128, v225, v126))
              AMSupportLogInternal();
            else
              CFArrayAppendValue(v159, v126);
            if (v121 == ++v123)
              goto LABEL_272;
          }
        }
LABEL_273:
        v141 = 1;
      }
      else
      {
        if (v121 < 1)
          goto LABEL_273;
        v137 = 0;
        v124 = CFSTR("minimalSealingDataInstance is not a string");
        while (1)
        {
          v138 = CFArrayGetValueAtIndex(*((CFArrayRef *)v5 + 22), v137);
          if (!v138)
            break;
          v139 = v138;
          v140 = CFGetTypeID(v138);
          if (v140 != CFStringGetTypeID())
            break;
          CFArrayAppendValue(v159, v139);
          if (v121 == ++v137)
          {
LABEL_272:
            v141 = 1;
            goto LABEL_274;
          }
        }
LABEL_324:
        AMFDRErrorPushInternal(v155, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataMinimalSealingMetaPropertyCheck", v124, v154);
        v141 = 0;
      }
LABEL_274:
      if ((_QWORD)context)
      {
        CFRelease((CFTypeRef)context);
        *(_QWORD *)&context = 0;
      }
      if (v189)
        CFRelease(v189);
      if ((v141 & 1) == 0)
      {
        AMSupportLogInternal();
        CFArrayAppendValue(v156, CFSTR("meta"));
      }
    }
  }
  else
  {
    AMFDRAPTicketAllowsUnsealedData((uint64_t)v168);
  }
LABEL_245:
  if (CFArrayGetCount(v162) > 0
    || CFArrayGetCount(v157) > 0
    || CFArrayGetCount(theArray) > 0
    || CFDictionaryGetCount(theDict) > 0
    || CFDictionaryGetCount(v167) > 0
    || CFArrayGetCount(v164) > 0
    || CFDictionaryGetCount(v160) > 0
    || CFArrayGetCount(v159) > 0
    || CFArrayGetCount(v161) > 0
    || CFArrayGetCount(v156) >= 1)
  {
    AMFDRErrorPushInternal(v155, 100, 0, v162, v157, theArray, theDict, v167, 0, v164, v160, v159, v161, v156, (uint64_t)"AMFDRSealedDataVerify", CFSTR("Data instances %@ missing.\nMulti-manifest %@ missing.\nDigest for %@ mismatched.\nCombined manifests %@ did not verify.\nData instances %@ did not verify.\nMinimal manifests %@ missing.\nMinimal manifests %@ did not verify. \nMinimalSealingInstances %@ missing. \nSubCCDataInstances %@ missing. \nmismatchedProperties %@ mismatched. Verification failed."), (char)v162);
    v129 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 16), CFSTR("PersistIncompleteManifest"));
    if (v129)
    {
      v130 = v129;
      v131 = CFGetTypeID(v129);
      v132 = v131 == CFBooleanGetTypeID() && CFBooleanGetValue(v130) != 0;
    }
    else
    {
      v132 = 0;
    }
    AMSupportLogInternal();
    goto LABEL_261;
  }
  v134 = CFSTR("FDRSealedVerifySuccess");
  v133 = 1;
LABEL_266:
  AMFDRIncrementStat((CFMutableDictionaryRef *)v4, v134);
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v133;
}

uint64_t AMFDRSealedDataIsEmpty(uint64_t a1)
{
  const __CFArray *v2;
  CFIndex v3;
  const void *ValueAtIndex;
  _BOOL8 v5;

  if (!a1)
    return 1;
  v2 = *(const __CFArray **)(a1 + 64);
  if (!v2 || !CFArrayGetCount(v2) || CFArrayGetCount(*(CFArrayRef *)(a1 + 64)) < 1)
    return 1;
  v3 = 0;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), v3);
    v5 = ValueAtIndex == 0;
    if (ValueAtIndex)
      break;
    ++v3;
  }
  while (v3 < CFArrayGetCount(*(CFArrayRef *)(a1 + 64)));
  return v5;
}

void _checkVerificationError(const __CFString *a1, CFNumberRef number, uint64_t a3)
{
  char v3;
  const void *v5;
  uint64_t v6;
  uint64_t v7;
  __CFDictionary *v8;
  int v9;
  const __CFAllocator *v10;
  int v11;
  int v12;
  BOOL v13;
  const __CFArray *v14;
  uint64_t valuePtr;
  CFTypeRef v16;
  CFTypeRef v17;
  CFRange v18;

  v3 = (char)number;
  v16 = 0;
  v17 = 0;
  valuePtr = 0;
  v5 = *(const void **)a3;
  v6 = *(_QWORD *)(a3 + 8);
  v8 = *(__CFDictionary **)(a3 + 16);
  v7 = *(_QWORD *)(a3 + 24);
  v9 = **(unsigned __int8 **)(a3 + 32);
  if (CFNumberGetValue(number, kCFNumberSInt64Type, &valuePtr))
  {
    if ((valuePtr & 0xFFFD9FFFFFFFFEFFLL) != 0)
    {
      v10 = CFGetAllocator(v5);
      v11 = AMFDRDataLocalDecomposeFullKey(v10, a1, &v17, &v16);
      v12 = v11;
      if (v9)
        v13 = 1;
      else
        v13 = v11 == 0;
      if (!v13
        && (v14 = *(const __CFArray **)(v6 + 264)) != 0
        && (v18.length = CFArrayGetCount(v14), v18.location = 0, CFArrayContainsValue(v14, v18, v17))
        || v12 && AMFDRAllowIncompleteData((uint64_t)v5))
      {
        AMSupportLogInternal();
        CFDictionaryAddValue(v8, v17, v16);
      }
      else
      {
        AMSupportLogInternal();
        AMFDRErrorPushInternal(v7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_checkVerificationError", CFSTR("AMFDRSealedDataVerify failed for %@ with trustError 0x%016llX. (Unsealed errors are ignored.)"), (char)a1);
      }
    }
    else
    {
      AMSupportLogInternal();
    }
  }
  else
  {
    AMFDRErrorPushInternal(v7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_checkVerificationError", CFSTR("Failed to convert %@ to a uint64."), v3);
  }
  if (v17)
  {
    CFRelease(v17);
    v17 = 0;
  }
  if (v16)
    CFRelease(v16);
}

uint64_t _deleteFromSealedData(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  return AMFDRSealedDataDelete(*(CFArrayRef **)a3, a1, a2, *(_QWORD *)(a3 + 8));
}

uint64_t AMFDRSealedDataCommit(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  CFTypeRef *v4;
  uint64_t v5;
  uint64_t v7;
  const void *v8;
  const __CFData *v9;
  const __CFData *v10;
  CFIndex Length;
  unint64_t v12;
  const __CFDictionary *v13;
  const __CFData *v14;
  const __CFData *v15;
  const void *v16;
  __CFDictionary *v17;
  CFStringRef FullKey;
  CFIndex v19;
  const __CFString *ValueAtIndex;
  const void *v21;
  const __CFData *v22;
  const __CFData *v23;
  const __CFData *v24;
  const __CFAllocator *v25;
  const __CFDictionary *v26;
  const void *v27;
  const __CFDictionary *v28;
  const __CFData *v29;
  const __CFArray *v30;
  int v31;
  _BOOL4 v32;
  const __CFData *v33;
  const void *v34;
  const __CFArray *v35;
  CFIndex v36;
  CFIndex v37;
  CFIndex v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const __CFAllocator *v42;
  const __CFData *v43;
  const __CFData *v44;
  unint64_t v45;
  const __CFAllocator *v46;
  const __CFString *v47;
  char v48;
  CFIndex v49;
  const __CFArray *v50;
  CFIndex v51;
  CFIndex v52;
  CFIndex v53;
  const void *v54;
  const void *v55;
  const __CFAllocator *v56;
  const __CFData *v57;
  const __CFData *v58;
  char v59;
  CFIndex v60;
  uint64_t LocalStoreMaxSizeInternal;
  const void *v62;
  uint64_t v64;
  uint64_t v65;
  CFIndex v66;
  const __CFString *v67;
  const __CFString *v68;
  const __CFString *v69;
  void *value[2];
  void *v71[2];
  __int128 v72;
  const __CFString *format;
  const __CFString *v74;
  CFTypeRef v75;
  CFTypeRef cf;
  CFIndex Count;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  CFIndex v81;
  CFTypeRef v82;
  CFRange v83;

  v4 = (CFTypeRef *)a4;
  v5 = a2;
  v82 = 0;
  if (!a2)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCommit", CFSTR("amfdr is NULL"), (char)v74);
    return v5;
  }
  if (!a1)
  {
    v68 = CFSTR("sealedData is NULL");
LABEL_131:
    AMFDRErrorPushInternal((uint64_t)v4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCommit", v68, (char)v74);
LABEL_136:
    v5 = 0;
    goto LABEL_101;
  }
  if (!*(_QWORD *)(a1 + 32))
  {
    v68 = CFSTR("sealedData->dataClassArray is NULL");
    goto LABEL_131;
  }
  if (!*(_QWORD *)(a1 + 40))
  {
    v68 = CFSTR("sealedData->dataInstanceArray is NULL");
    goto LABEL_131;
  }
  if (!*(_QWORD *)(a1 + 64))
  {
    v68 = CFSTR("sealedData->dataArray is NULL");
    goto LABEL_131;
  }
  if (a3 && !*(_QWORD *)(a1 + 16))
  {
    v68 = CFSTR("sealedData->sealingIM4M is NULL");
    goto LABEL_131;
  }
  AMFDRGetOptions(a2);
  v7 = AMSupportSafeRetain();
  if (!v7)
  {
    v68 = CFSTR("failed to preserve amfdr options");
    goto LABEL_131;
  }
  v8 = (const void *)v7;
  v80 = v5;
  v9 = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 16), CFSTR("TrustObject"));
  if (v9)
  {
    v10 = v9;
    if (v4 && *v4)
    {
      CFRelease(*v4);
      *v4 = 0;
    }
    if (!AMFDRDataPutTrustObject(v80))
    {
      v69 = CFSTR("Failed to store trust object in local data store");
      goto LABEL_135;
    }
    Length = CFDataGetLength(v10);
    if (!AMFDRDataPut(v80, CFSTR("trustobject"), CFSTR("current"), v10, (uint64_t)v4))
    {
      v69 = CFSTR("Failed to store trustobject-current in local data store");
      goto LABEL_135;
    }
    v12 = CFDataGetLength(v10) + Length;
  }
  else
  {
    v12 = 0;
  }
  v13 = *(const __CFDictionary **)(a1 + 104);
  if (v13)
  {
    v14 = (const __CFData *)CFDictionaryGetValue(v13, CFSTR("TrustObject"));
    if (v14)
    {
      v15 = v14;
      if (v4 && *v4)
      {
        CFRelease(*v4);
        *v4 = 0;
      }
      if (AMFDRDataPutTrustObject(v80))
      {
        v12 += CFDataGetLength(v15);
        goto LABEL_24;
      }
      v69 = CFSTR("Failed to store remote trust object in local data store");
LABEL_135:
      AMFDRErrorPushInternal((uint64_t)v4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCommit", v69, (char)v74);
      CFRelease(v8);
      goto LABEL_136;
    }
  }
LABEL_24:
  if (!AMFDRShouldPersistData(v80, CFSTR("PersistCertificate")))
    goto LABEL_28;
  v16 = *(const void **)(v80 + 32);
  if (!v16)
    goto LABEL_28;
  v17 = *(__CFDictionary **)(v80 + 80);
  if (v17)
  {
    CFDictionarySetValue(v17, CFSTR("certificate"), v16);
LABEL_28:
    cf = 0;
    goto LABEL_29;
  }
  v64 = AMFDRDataLocalCopyDataStoragePath((_QWORD *)v80, (uint64_t)CFSTR("certificate"), 0, (uint64_t)v4);
  if (!v64)
  {
    v69 = CFSTR("missing cert data storage path");
    goto LABEL_135;
  }
  cf = (CFTypeRef)v64;
  if (AMFDRWriteDataToFileURL((CFTypeRef)v80, *(_QWORD *)(v80 + 32), v64, 1))
  {
    AMFDRErrorPushInternal((uint64_t)v4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCommit", CFSTR("failed to write cert data to %@"), (char)cf);
    v62 = cf;
    v5 = 0;
    FullKey = 0;
    goto LABEL_98;
  }
LABEL_29:
  v75 = v8;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  v78 = (uint64_t)v4;
  FullKey = 0;
  if (Count >= 1)
  {
    v19 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), v19);
      v21 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), v19);
      v22 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), v19);
      v23 = *(const __CFData **)(a1 + 16);
      v81 = 0;
      if (v22)
        break;
      AMSupportLogInternal();
LABEL_52:
      if (Count == ++v19)
        goto LABEL_53;
    }
    v24 = v22;
    if (FullKey)
      CFRelease(FullKey);
    v25 = CFGetAllocator((CFTypeRef)v80);
    FullKey = AMFDRDataLocalCreateFullKey(v25, (uint64_t)ValueAtIndex, (uint64_t)v21);
    if (!FullKey)
    {
      format = CFSTR("failed to create data instance string");
      *(_OWORD *)v71 = 0u;
      v72 = 0u;
      *(_OWORD *)value = 0u;
      v65 = (uint64_t)v4;
      goto LABEL_109;
    }
    v79 = v12;
    v26 = *(const __CFDictionary **)(a1 + 160);
    if (v26)
      v27 = CFDictionaryGetValue(v26, FullKey);
    else
      v27 = 0;
    v28 = *(const __CFDictionary **)(a1 + 152);
    if (v28)
      v29 = (const __CFData *)CFDictionaryGetValue(v28, FullKey);
    else
      v29 = 0;
    v30 = *(const __CFArray **)(a1 + 272);
    if (v30)
    {
      v83.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 272));
      v83.location = 0;
      v31 = CFArrayContainsValue(v30, v83, ValueAtIndex);
      v32 = v31 != 0;
      if (v31 && v29)
      {
        AMSupportLogInternal();
        v32 = 1;
        v4 = (CFTypeRef *)v78;
        goto LABEL_48;
      }
    }
    else
    {
      v32 = 0;
    }
    v4 = (CFTypeRef *)v78;
    if (!v29)
    {
LABEL_49:
      if ((AMFDRDataCommitWithPopulateAddition((_QWORD *)v80, ValueAtIndex, v21, v24, v32, v23, v27, &v81, (uint64_t)v4) & 1) == 0)
        AMSupportLogInternal();
      v12 = v81 + v79;
      goto LABEL_52;
    }
LABEL_48:
    v23 = v29;
    goto LABEL_49;
  }
LABEL_53:
  v33 = *(const __CFData **)(a1 + 16);
  if (v33)
  {
    v34 = (const void *)v80;
    if ((AMFDRDataPut(v80, *(const __CFString **)(a1 + 72), *(const void **)(a1 + 80), v33, (uint64_t)v4) & 1) == 0)
    {
      v74 = *(const __CFString **)(a1 + 72);
      format = CFSTR("AMFDRDataPut(%@:%@) failed.");
      *(_OWORD *)v71 = 0u;
      v72 = 0u;
      *(_OWORD *)value = 0u;
      v65 = (uint64_t)v4;
      goto LABEL_117;
    }
    v12 += CFDataGetLength(*(CFDataRef *)(a1 + 16));
  }
  else
  {
    v34 = (const void *)v80;
  }
  if (!*(_QWORD *)(a1 + 152))
    goto LABEL_86;
  v35 = *(const __CFArray **)(a1 + 136);
  if (v35)
  {
    v36 = CFArrayGetCount(v35);
    if (v36 >= 1)
    {
      v37 = v36;
      if (CFArrayGetCount(*(CFArrayRef *)(a1 + 144)) != v36)
      {
        AMFDRErrorPushInternal((uint64_t)v4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCommit", CFSTR("Invalid sealedData->multiSealingDataInstancesArray count"), (char)v74);
        goto LABEL_119;
      }
      v38 = 0;
      while (1)
      {
        v39 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 136), v38);
        v40 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), v38);
        if (!v39)
          break;
        v41 = v40;
        if (!v40)
        {
          v67 = CFSTR("dataInstance is NULL. MultiSealing failed.");
          goto LABEL_113;
        }
        if (FullKey)
          CFRelease(FullKey);
        v42 = CFGetAllocator(v34);
        FullKey = AMFDRDataLocalCreateFullKey(v42, (uint64_t)v39, (uint64_t)v41);
        if (!FullKey)
        {
LABEL_107:
          format = CFSTR("failed to create data instance string");
          *(_OWORD *)v71 = 0u;
          v72 = 0u;
          *(_OWORD *)value = 0u;
          v65 = v78;
LABEL_109:
          v66 = 2;
          goto LABEL_118;
        }
        v43 = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 152), FullKey);
        if (v43)
        {
          v44 = v43;
          v45 = v12;
          CFRetain(v43);
          v46 = CFGetAllocator(v34);
          v47 = CFStringCreateWithFormat(v46, 0, CFSTR("%@-%@"), CFSTR("manifest"), v39);
          v48 = AMFDRDataPut((uint64_t)v34, v47, v41, v44, v78);
          v49 = CFDataGetLength(v44);
          if (v47)
            CFRelease(v47);
          CFRelease(v44);
          if ((v48 & 1) == 0)
          {
            LOBYTE(v74) = 0;
            goto LABEL_116;
          }
          v12 = v49 + v45;
          v34 = (const void *)v80;
        }
        else
        {
          AMSupportLogInternal();
        }
        if (v37 == ++v38)
          goto LABEL_74;
      }
      v67 = CFSTR("dataClass is NULL. MultiSealing failed.");
LABEL_113:
      AMFDRErrorPushInternal(v78, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCommit", v67, (char)v74);
      goto LABEL_119;
    }
  }
LABEL_74:
  v50 = *(const __CFArray **)(a1 + 176);
  if (!v50 || (v51 = CFArrayGetCount(v50), v51 < 1))
  {
LABEL_86:
    v8 = v75;
    if ((AMFDRSetOptions((uint64_t)v34, v75) & 1) != 0)
    {
      LocalStoreMaxSizeInternal = AMFDRSealingMapGetLocalStoreMaxSizeInternal((uint64_t)v34, (uint64_t)&v82);
      AMSupportLogInternal();
      if (v12 > LocalStoreMaxSizeInternal << 20)
      {
        if (!LocalStoreMaxSizeInternal && v82)
          AMSupportLogInternal();
        if (*(uint64_t (***)(int, int, int, int))(v80 + 48) != AMFDRHTTPStore
          && AMFDROptionsGetBooleanValue(v80, CFSTR("CheckStoreSize"), 0))
        {
          AMFDRErrorPushInternal(v78, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCommit", CFSTR("committed FDR data (%ld bytes) has larger size than estimated (%ld MB)"), v12);
LABEL_94:
          v5 = 0;
          goto LABEL_97;
        }
        AMSupportLogInternal();
      }
      v5 = 1;
      goto LABEL_97;
    }
    AMFDRErrorPushInternal(v78, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCommit", CFSTR("failed to restore amfdr options"), (char)v74);
    goto LABEL_94;
  }
  v52 = v51;
  v53 = 0;
  while (1)
  {
    v54 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), v53);
    if (!v54)
    {
      v67 = CFSTR("dataInstance is NULL. minimalSealing failed.");
      goto LABEL_113;
    }
    v55 = v54;
    if (FullKey)
      CFRelease(FullKey);
    v56 = CFGetAllocator(v34);
    FullKey = AMFDRDataLocalCreateFullKey(v56, (uint64_t)CFSTR("minimal-manifest"), (uint64_t)v55);
    if (!FullKey)
      goto LABEL_107;
    v57 = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 152), FullKey);
    if (!v57)
    {
      AMSupportLogInternal();
      goto LABEL_85;
    }
    v58 = v57;
    CFRetain(v57);
    v59 = AMFDRDataPut((uint64_t)v34, CFSTR("minimal-manifest"), v55, v58, v78);
    v60 = CFDataGetLength(v58);
    CFRelease(v58);
    if ((v59 & 1) == 0)
      break;
    v12 += v60;
    v34 = (const void *)v80;
LABEL_85:
    if (v52 == ++v53)
      goto LABEL_86;
  }
  v74 = CFSTR("minimal-manifest");
LABEL_116:
  format = CFSTR("AMFDRDataPut(%@:%@) failed.");
  *(_OWORD *)v71 = 0u;
  v72 = 0u;
  *(_OWORD *)value = 0u;
  v65 = v78;
LABEL_117:
  v66 = 10;
LABEL_118:
  AMFDRErrorPushInternal(v65, v66, 0, 0, 0, 0, 0, 0, value[0], value[1], v71[0], v71[1], (void *)v72, *((void **)&v72 + 1), (uint64_t)"AMFDRSealedDataCommit", format, (char)v74);
LABEL_119:
  v5 = 0;
  v8 = v75;
LABEL_97:
  v62 = cf;
  if (cf)
LABEL_98:
    CFRelease(v62);
  CFRelease(v8);
  if (FullKey)
    CFRelease(FullKey);
LABEL_101:
  if (v82)
    CFRelease(v82);
  return v5;
}

uint64_t _AMFDRSealedDataExport(CFArrayRef *a1, CFDictionaryRef *a2, const __CFArray *a3, uint64_t a4)
{
  const __CFArray *v7;
  CFIndex Count;
  const __CFBoolean *Value;
  const __CFAllocator *v11;
  CFMutableArrayRef v12;
  __CFArray *v13;
  __CFDictionary *v14;
  int v15;
  const __CFAllocator *v16;
  CFMutableDictionaryRef Mutable;
  __CFString *v18;
  const __CFAllocator *v19;
  CFMutableStringRef v20;
  CFIndex v21;
  const __CFString *ValueAtIndex;
  const __CFString *v23;
  CFIndex FirstIndexOfValue;
  CFIndex v25;
  uint64_t v26;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  char v31;
  char v32;
  CFTypeRef *v33;
  __CFDictionary *theDict;
  __CFArray *theArray;
  CFTypeRef cf;
  _QWORD context[3];
  CFRange v38;

  context[2] = *MEMORY[0x24BDAC8D0];
  cf = 0;
  if (!a2)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", CFSTR("amfdr is NULL"), v31);
    return 0;
  }
  if (!a2[2])
  {
    v29 = CFSTR("amfdr->optionsDict is NULL");
LABEL_59:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", v29, v31);
    goto LABEL_60;
  }
  if (!a1)
  {
    v29 = CFSTR("sealedData is NULL");
    goto LABEL_59;
  }
  v7 = a1[4];
  if (!v7)
  {
    v29 = CFSTR("sealedData->dataClassArray is NULL");
    goto LABEL_59;
  }
  if (!a1[5])
  {
    v29 = CFSTR("sealedData->dataInstanceArray is NULL");
    goto LABEL_59;
  }
  if (!a1[8])
  {
    v29 = CFSTR("sealedData->dataArray is NULL");
    goto LABEL_59;
  }
  if (!a3)
  {
    v29 = CFSTR("dataClassesToExport is NULL");
    goto LABEL_59;
  }
  Count = CFArrayGetCount(v7);
  Value = (const __CFBoolean *)CFDictionaryGetValue(a2[2], CFSTR("EnableMultiRequest"));
  if (Value && !CFBooleanGetValue(Value))
  {
    v16 = CFGetAllocator(a1);
    Mutable = CFDictionaryCreateMutable(v16, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (Mutable)
    {
      v14 = Mutable;
      v13 = 0;
      v15 = 0;
LABEL_14:
      v18 = (__CFString *)AMFDRCreateCopy((uint64_t)a2);
      if (v18)
      {
        v19 = CFGetAllocator(a1);
        v20 = CFStringCreateMutable(v19, 0);
        if (!v20)
        {
          AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", CFSTR("permStr is NULL"), v31);
          goto LABEL_66;
        }
        theDict = v14;
        theArray = v13;
        v33 = (CFTypeRef *)a4;
        if (CFArrayGetCount(a3) >= 1)
        {
          v21 = 0;
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a3, v21);
            if (!ValueAtIndex)
            {
              AMFDRErrorPushInternal((uint64_t)v33, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", CFSTR("dataClass is NULL"), v31);
              goto LABEL_50;
            }
            v23 = ValueAtIndex;
            v38.location = 0;
            v38.length = Count;
            FirstIndexOfValue = CFArrayGetFirstIndexOfValue(a1[4], v38, ValueAtIndex);
            if (FirstIndexOfValue == -1)
            {
              v32 = (char)v23;
              v28 = CFSTR("%@ is not in sealedData");
LABEL_48:
              AMFDRErrorPushInternal((uint64_t)v33, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", v28, v32);
              goto LABEL_50;
            }
            v25 = FirstIndexOfValue;
            v26 = (uint64_t)CFArrayGetValueAtIndex(a1[5], FirstIndexOfValue);
            if (!v26)
            {
              AMFDRErrorPushInternal((uint64_t)v33, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", CFSTR("dataInstance is NULL"), v31);
              goto LABEL_51;
            }
            if (!CFArrayGetValueAtIndex(a1[8], v25))
            {
              v32 = (char)v23;
              v28 = CFSTR("data %@-%@ is missing");
              goto LABEL_48;
            }
            if ((AMFDRDataAppendPermissionsString(v18, 3u, v23, (const __CFString *)v26, v20) & 1) == 0)
              break;
            if (v15)
              CFArrayAppendValue(theArray, (const void *)v26);
            else
              CFDictionaryAddValue(theDict, v23, (const void *)v26);
            if (++v21 >= CFArrayGetCount(a3))
              goto LABEL_27;
          }
          AMFDRErrorPushInternal((uint64_t)v33, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", CFSTR("AMFDRDataAppendPermissionsString failed"), v31);
LABEL_50:
          v26 = 0;
LABEL_51:
          v14 = theDict;
          v13 = theArray;
          goto LABEL_33;
        }
LABEL_27:
        AMFDRSetOption((uint64_t)v18, CFSTR("Permissions"), v20);
        AMFDRSetOption((uint64_t)v18, CFSTR("OrganizationalUnit"), CFSTR("Devices - Stations"));
        AMFDRSetOption((uint64_t)v18, CFSTR("PersistCertificate"), (const __CFString *)*MEMORY[0x24BDBD268]);
        v13 = theArray;
        if ((AMFDRPermissionsRequest((uint64_t)v18, v33) & 1) != 0)
        {
          v14 = theDict;
          if (v15)
          {
            if ((AMFDRDataMultiExport((uint64_t)v18) & 1) == 0)
            {
              AMSupportLogInternal();
LABEL_66:
              v26 = 0;
              goto LABEL_33;
            }
          }
          else
          {
            context[0] = v18;
            context[1] = &cf;
            CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)_exportDataInstances, context);
            if (cf)
            {
              AMFDRErrorPushInternal((uint64_t)v33, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", CFSTR("_exportDataInstances failed with error %@"), (char)cf);
              goto LABEL_66;
            }
          }
          v26 = 1;
        }
        else
        {
          AMFDRErrorPushInternal((uint64_t)v33, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", CFSTR("Permissions request failed."), v31);
          v26 = 0;
          v14 = theDict;
        }
LABEL_33:
        if (v13)
          CFRelease(v13);
        if (v14)
          CFRelease(v14);
        if (v20)
          CFRelease(v20);
        goto LABEL_39;
      }
      AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", CFSTR("cannot create a separate amfdr object for data export"), v31);
      v20 = 0;
      goto LABEL_66;
    }
    v30 = CFSTR("exportDict is NULL");
  }
  else
  {
    v11 = CFGetAllocator(a2);
    v12 = CFArrayCreateMutable(v11, 0, MEMORY[0x24BDBD690]);
    if (v12)
    {
      v13 = v12;
      v14 = 0;
      v15 = 1;
      goto LABEL_14;
    }
    v30 = CFSTR("dataInstancesToExport is NULL");
  }
  AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExport", v30, v31);
LABEL_60:
  v26 = 0;
  v18 = 0;
LABEL_39:
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v18)
    CFRelease(v18);
  return v26;
}

uint64_t _AMFDRSealedDataCopyAndCommitIntraFactoryData(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4)
{
  const __CFString *v6;
  uint64_t v7;
  const __CFArray *v8;
  CFIndex Count;
  const __CFAllocator *v10;
  CFMutableArrayRef Mutable;
  const __CFAllocator *v12;
  CFMutableArrayRef v13;
  const __CFAllocator *v14;
  const __CFAllocator *v15;
  const void *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFAllocator *v19;
  CFMutableStringRef v20;
  __CFString *FullKey;
  CFIndex v22;
  const __CFString *ValueAtIndex;
  const __CFString *v24;
  const __CFString *v25;
  const __CFDictionary *v26;
  __CFError *v27;
  CFIndex v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const __CFAllocator *v33;
  const void *v34;
  const void *v35;
  __CFError *v36;
  CFIndex Code;
  uint64_t v38;
  __CFArray *v39;
  __CFArray *v40;
  const void *v41;
  const __CFString *v42;
  const void *v43;
  const __CFString *format;
  const __CFString *v46;
  const __CFString *v47;
  char v48;
  __CFString *v49;
  const __CFString *Value;
  const void *v51;
  const __CFString *v52;
  CFMutableStringRef cf;
  CFTypeRef *v54;
  __CFArray *theArray;
  __CFArray *v56;
  __CFArray *v57;
  __CFArray *v58;
  const __CFDictionary *v59;
  CFErrorRef v60;

  v6 = a2;
  if (!a2)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("amfdrLocal is NULL"), v48);
    v7 = 0;
    v26 = 0;
LABEL_96:
    cf = 0;
    v59 = 0;
    Mutable = 0;
LABEL_97:
    v13 = 0;
LABEL_102:
    v39 = 0;
    v40 = 0;
    FullKey = 0;
    v42 = 0;
    v41 = 0;
    goto LABEL_54;
  }
  if (!a3)
  {
    v46 = CFSTR("amfdrRemote is NULL");
LABEL_94:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", v46, v48);
    v7 = 0;
    goto LABEL_95;
  }
  if (!*(_QWORD *)(a3 + 16))
  {
    v46 = CFSTR("amfdrRemote->optionsDict is NULL");
    goto LABEL_94;
  }
  v7 = a1;
  if (!a1)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("sealedData is NULL"), v48);
LABEL_95:
    v26 = 0;
    v6 = 0;
    goto LABEL_96;
  }
  v8 = *(const __CFArray **)(a1 + 48);
  if (!v8)
  {
    v46 = CFSTR("sealedData->intraFactoryDataClasses is NULL");
    goto LABEL_94;
  }
  if (!*(_QWORD *)(v7 + 56))
  {
    v46 = CFSTR("sealedData->intraFactoryDataInstances is NULL");
    goto LABEL_94;
  }
  Count = CFArrayGetCount(v8);
  if (Count != CFArrayGetCount(*(CFArrayRef *)(v7 + 56)))
  {
    v46 = CFSTR("count of intraFactoryDataClasses and intraFactoryDataInstances mismatch");
    goto LABEL_94;
  }
  v10 = CFGetAllocator((CFTypeRef)a3);
  Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("Failed to allocate missingDataInstances"), v48);
    v7 = 0;
    v26 = 0;
    v6 = 0;
    cf = 0;
    v59 = 0;
    goto LABEL_97;
  }
  v12 = CFGetAllocator((CFTypeRef)a3);
  v13 = CFArrayCreateMutable(v12, 0, MEMORY[0x24BDBD690]);
  if (!v13)
  {
    v47 = CFSTR("Failed to allocate dataClassesToCommit");
LABEL_101:
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", v47, v48);
    v7 = 0;
    v26 = 0;
    v6 = 0;
    cf = 0;
    v59 = 0;
    goto LABEL_102;
  }
  v14 = CFGetAllocator((CFTypeRef)a3);
  v57 = CFArrayCreateMutable(v14, 0, MEMORY[0x24BDBD690]);
  if (!v57)
  {
    v47 = CFSTR("Failed to allocate dataInstancesToCommit");
    goto LABEL_101;
  }
  v15 = CFGetAllocator((CFTypeRef)a3);
  v56 = CFArrayCreateMutable(v15, 0, MEMORY[0x24BDBD690]);
  if (v56)
  {
    v54 = (CFTypeRef *)a4;
    Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("UseSikDataInstance"));
    AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD268]);
    v16 = *(const void **)(a3 + 32);
    if (v16)
      CFRetain(*(CFTypeRef *)(a3 + 32));
    v51 = v16;
    v17 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), CFSTR("Permissions"));
    v18 = v17;
    if (v17)
      CFRetain(v17);
    v52 = v18;
    v19 = CFGetAllocator((CFTypeRef)a3);
    v20 = CFStringCreateMutable(v19, 0);
    FullKey = v20;
    if (!v20)
    {
      AMFDRErrorPushInternal((uint64_t)v54, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("permStr is NULL"), v48);
      v7 = 0;
      v26 = 0;
      cf = 0;
      v59 = 0;
      goto LABEL_51;
    }
    cf = v20;
    if (Count >= 1)
    {
      v22 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 48), v22);
        if (!ValueAtIndex)
          break;
        v24 = ValueAtIndex;
        v25 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 56), v22);
        if (!v25)
        {
          AMFDRErrorPushInternal((uint64_t)v54, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("dataInstance is NULL"), v48);
          goto LABEL_80;
        }
        if ((AMFDRDataAppendPermissionsString((__CFString *)a3, 0, v24, v25, FullKey) & 1) == 0)
        {
          AMFDRErrorPushInternal((uint64_t)v54, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("AMFDRDataAppendPermissionsString failed"), v48);
          goto LABEL_80;
        }
        if (Count == ++v22)
          goto LABEL_23;
      }
      AMFDRErrorPushInternal((uint64_t)v54, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("dataClass is NULL"), v48);
LABEL_80:
      v7 = 0;
      v26 = 0;
      v59 = 0;
      FullKey = 0;
      goto LABEL_51;
    }
LABEL_23:
    v49 = (__CFString *)v6;
    AMFDRSetOption(a3, CFSTR("Permissions"), FullKey);
    v26 = (const __CFDictionary *)AMFDRDataMultiCopy((_QWORD *)a3, *(_QWORD *)(v7 + 48), *(_QWORD *)(v7 + 56), v54);
    theArray = v13;
    if (v54)
    {
      v27 = (__CFError *)*v54;
      if (*v54)
      {
        if (CFErrorGetCode(v27) != 21)
        {
          AMFDRErrorPushInternal((uint64_t)v54, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("AMFDRDataMultiCopy got unexpected error"), v48);
          goto LABEL_107;
        }
        v27 = (__CFError *)AMFDRCopyUnderlyingDictionary((__CFError *)*v54, CFSTR("MultiRequestErrors"));
        if (!v27)
        {
          AMFDRErrorPushInternal((uint64_t)v54, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("AMFDRDataMultiCopy failed but multiRequestErrors is NULL"), v48);
LABEL_107:
          v7 = 0;
          v59 = 0;
          FullKey = 0;
          goto LABEL_50;
        }
      }
    }
    else
    {
      v27 = 0;
    }
    v58 = Mutable;
    v59 = v27;
    if (Count >= 1)
    {
      v28 = 0;
      while (1)
      {
        v60 = 0;
        v29 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 48), v28);
        if (!v29)
          break;
        v30 = v29;
        v31 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 56), v28);
        if (!v31)
        {
          format = CFSTR("dataInstance is NULL");
          goto LABEL_83;
        }
        v32 = v31;
        v33 = CFGetAllocator((CFTypeRef)a3);
        FullKey = (__CFString *)AMFDRDataLocalCreateFullKey(v33, (uint64_t)v30, (uint64_t)v32);
        if (!FullKey)
        {
          AMFDRErrorPushInternal((uint64_t)v54, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("failed to create data instance string"), v48);
          goto LABEL_49;
        }
        if (v26 && CFDictionaryContainsKey(v26, FullKey))
        {
          v34 = CFDictionaryGetValue(v26, FullKey);
          if (!v34)
          {
            AMFDRErrorPushInternal((uint64_t)v54, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("valueData is NULL"), v48);
            goto LABEL_49;
          }
          v35 = v34;
          CFRetain(v34);
          CFArrayAppendValue(theArray, v30);
          CFArrayAppendValue(v57, v32);
          CFArrayAppendValue(v56, v35);
          CFRelease(v35);
        }
        else
        {
          v36 = (__CFError *)CFDictionaryGetValue(v59, FullKey);
          v60 = v36;
          if (!v36)
          {
            AMFDRErrorPushInternal((uint64_t)v54, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("AMFDRDataMultiCopy failed(%@), but multiRequestError is NULL"), (char)FullKey);
            goto LABEL_49;
          }
          Code = CFErrorGetCode(v36);
          v38 = AMFDRGetUnderlyingErrorCode(a3, &v60);
          if (Code != 701 && v38 != 404)
          {
            AMFDRErrorPushInternal((uint64_t)v54, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("Unexpected error and underlying error for %@: %ld, %ld"), (char)FullKey);
LABEL_49:
            v7 = 0;
            Mutable = v58;
LABEL_50:
            v13 = theArray;
LABEL_51:
            v40 = v56;
            v39 = v57;
LABEL_52:
            v41 = v51;
            v6 = v52;
            goto LABEL_53;
          }
          AMSupportLogInternal();
          CFArrayAppendValue(v58, FullKey);
        }
        CFRelease(FullKey);
        if (Count == ++v28)
          goto LABEL_43;
      }
      format = CFSTR("dataClass is NULL");
LABEL_83:
      AMFDRErrorPushInternal((uint64_t)v54, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", format, v48);
      FullKey = 0;
      goto LABEL_49;
    }
LABEL_43:
    v13 = theArray;
    v40 = v56;
    v39 = v57;
    if (CFArrayGetCount(theArray) >= 1 && (AMFDRDataMultiPut(v49, theArray, v57, v56, (uint64_t)v54) & 1) == 0)
    {
      AMFDRErrorPushInternal((uint64_t)v54, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("AMFDRDataMultiCopy failed."), v48);
      v7 = 0;
      FullKey = 0;
      Mutable = v58;
      goto LABEL_52;
    }
    Mutable = v58;
    v41 = v51;
    v6 = v52;
    if (CFArrayGetCount(v58) < 1)
    {
      FullKey = 0;
      v7 = 1;
    }
    else
    {
      AMFDRErrorPushInternal((uint64_t)v54, 33, 0, v58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("Failed to fetch intra factory data for instances %@\n"), (char)v58);
      v7 = 0;
      FullKey = 0;
    }
LABEL_53:
    v42 = Value;
  }
  else
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCopyAndCommitIntraFactoryData", CFSTR("Failed to allocate dataToCommit"), v48);
    v7 = 0;
    v26 = 0;
    v6 = 0;
    cf = 0;
    v59 = 0;
    v40 = 0;
    FullKey = 0;
    v42 = 0;
    v41 = 0;
    v39 = v57;
  }
LABEL_54:
  AMFDRSetOption(a3, CFSTR("UseSikDataInstance"), v42);
  AMFDRSetOption(a3, CFSTR("Permissions"), v6);
  v43 = *(const void **)(a3 + 32);
  if (v43)
    CFRelease(v43);
  *(_QWORD *)(a3 + 32) = v41;
  if (v41)
    CFRetain(v41);
  if (v26)
    CFRelease(v26);
  if (v6)
    CFRelease(v6);
  if (cf)
    CFRelease(cf);
  if (v59)
    CFRelease(v59);
  if (Mutable)
    CFRelease(Mutable);
  if (FullKey)
    CFRelease(FullKey);
  if (v13)
    CFRelease(v13);
  if (v39)
    CFRelease(v39);
  if (v40)
    CFRelease(v40);
  return v7;
}

uint64_t AMFDRSealedDataVerificationErrorIsBenign(int a1, CFDictionaryRef *a2, char a3, int a4, char a5, CFErrorRef err)
{
  const __CFDictionary *v10;
  int v11;
  int v12;
  const __CFBoolean *Value;
  const __CFBoolean *v14;
  CFTypeID v15;
  int v16;
  const __CFArray *v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  const __CFDictionary *v21;
  int v22;
  int v23;
  CFIndex Count;
  _BOOL4 v25;
  const __CFAllocator *v26;
  CFMutableDictionaryRef Mutable;
  uint64_t v28;
  _BOOL4 v29;
  const __CFAllocator *v30;
  CFMutableDictionaryRef v31;
  _BOOL4 v32;
  const __CFAllocator *v33;
  CFMutableDictionaryRef v34;
  _BOOL4 v35;
  const __CFArray *v36;
  int v37;
  int v38;
  int v39;
  CFIndex v40;
  char v41;
  char v43;
  _BOOL4 v44;
  char v45;
  const __CFArray *v47;
  CFArrayRef v48;
  const __CFArray *v49;
  const __CFArray *v50;
  const __CFArray *theArray;
  CFTypeRef cf;
  CFErrorRef v53;
  CFDictionaryRef *context;
  CFTypeRef *v55;
  CFTypeRef *p_cf;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  cf = 0;
  v53 = err;
  if (!a2)
  {
    v28 = 1;
    AMFDRErrorPushInternal((uint64_t)&v53, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerificationErrorIsBenign", CFSTR("amfdr is NULL"), v43);
    goto LABEL_99;
  }
  if (!err)
  {
    v28 = 1;
    AMFDRErrorPushInternal((uint64_t)&v53, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataVerificationErrorIsBenign", CFSTR("error is NULL"), v43);
    goto LABEL_99;
  }
  v10 = CFErrorCopyUserInfo(err);
  v11 = AMFDRAPTicketAllowsUnsealedData((uint64_t)a2);
  v12 = AMFDRAllowIncompleteData((uint64_t)a2);
  Value = (const __CFBoolean *)CFDictionaryGetValue(a2[2], CFSTR("AllowPropertyMismatch"));
  v45 = a3;
  if (Value && (v14 = Value, v15 = CFGetTypeID(Value), v15 == CFBooleanGetTypeID()))
  {
    v16 = v12;
    v44 = CFBooleanGetValue(v14) != 0;
    if (!v10)
    {
LABEL_6:
      v50 = 0;
      theArray = 0;
      v48 = 0;
      v49 = 0;
      v17 = 0;
      v47 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    v16 = v12;
    v44 = 0;
    if (!v10)
      goto LABEL_6;
  }
  theArray = (const __CFArray *)CFDictionaryGetValue(v10, CFSTR("MissingDataInstances"));
  v49 = (const __CFArray *)CFDictionaryGetValue(v10, CFSTR("MissingMultiManifests"));
  v48 = (CFArrayRef)CFDictionaryGetValue(v10, CFSTR("MissingMinimalManifests"));
  v50 = (const __CFArray *)CFDictionaryGetValue(v10, CFSTR("MissingMinimalSealingInstances"));
  v18 = (const __CFDictionary *)CFDictionaryGetValue(v10, CFSTR("UnverifiedDataInstances"));
  v19 = (const __CFDictionary *)CFDictionaryGetValue(v10, CFSTR("UnverifiedCombinedManifests"));
  v20 = (const __CFDictionary *)CFDictionaryGetValue(v10, CFSTR("UnverifiedMinimalManifests"));
  v17 = (const __CFArray *)CFDictionaryGetValue(v10, CFSTR("MissingSubCCDataInstances"));
  v47 = (const __CFArray *)CFDictionaryGetValue(v10, CFSTR("MismatchedProperties"));
LABEL_9:
  if (CFErrorGetCode(err) == 100)
  {
    if ((a5 & 1) != 0)
    {
      if (!v17)
        goto LABEL_15;
      AMSupportLogInternal();
      if (CFArrayGetCount(v17) < 1)
        goto LABEL_15;
      if (((v16 | v11) & 1) != 0)
      {
        AMSupportLogInternal();
LABEL_15:
        v21 = 0;
LABEL_94:
        v28 = 1;
        goto LABEL_95;
      }
      AMSupportLogInternal();
      goto LABEL_36;
    }
    if (theArray)
      AMSupportLogInternal();
    v22 = v11;
    if (v49)
      AMSupportLogInternal();
    v23 = v16;
    if (v48)
      AMSupportLogInternal();
    if (v18)
      AMSupportLogInternal();
    if (v50)
      AMSupportLogInternal();
    if (v18)
    {
      Count = CFDictionaryGetCount(v18);
      v21 = 0;
      v25 = Count > 0;
      if (Count >= 1 && a4)
      {
        if ((v16 | v22) == 1)
        {
          AMSupportLogInternal();
          v26 = CFGetAllocator(a2);
          Mutable = CFDictionaryCreateMutable(v26, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
          v21 = Mutable;
          if (!Mutable)
            goto LABEL_93;
          context = a2;
          v55 = (CFTypeRef *)Mutable;
          p_cf = &cf;
          CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)_getDataClassesAndInstances, &context);
          if (cf)
            goto LABEL_93;
          v55 = &cf;
          p_cf = 0;
          CFDictionaryApplyFunction(v21, (CFDictionaryApplierFunction)_deleteUnverifiedDataInstance, &context);
          v25 = cf != 0;
          if (cf)
            AMSupportLogInternal();
        }
        else
        {
          v21 = 0;
          v25 = 1;
        }
      }
    }
    else
    {
      v21 = 0;
      v25 = 0;
    }
    v29 = 0;
    if ((v45 & 1) == 0 && v19)
    {
      if (CFDictionaryGetCount(v19) < 1)
      {
        v29 = 0;
      }
      else
      {
        AMSupportLogInternal();
        v29 = 1;
        if (a4 && v16 | v22)
        {
          AMSupportLogInternal();
          if (v21)
            CFRelease(v21);
          if (cf)
          {
            CFRelease(cf);
            cf = 0;
          }
          v30 = CFGetAllocator(a2);
          v31 = CFDictionaryCreateMutable(v30, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
          v21 = v31;
          if (!v31)
            goto LABEL_93;
          context = a2;
          v55 = (CFTypeRef *)v31;
          p_cf = &cf;
          CFDictionaryApplyFunction(v19, (CFDictionaryApplierFunction)_getDataClassesAndInstances, &context);
          if (cf)
            goto LABEL_93;
          v55 = &cf;
          p_cf = 0;
          CFDictionaryApplyFunction(v21, (CFDictionaryApplierFunction)_deleteUnverifiedDataInstance, &context);
          v29 = cf != 0;
          if (cf)
            AMSupportLogInternal();
        }
      }
    }
    if (v20 && CFDictionaryGetCount(v20) >= 1)
    {
      AMSupportLogInternal();
      v32 = 1;
      if (a4 && v23 | v22)
      {
        AMSupportLogInternal();
        if (v21)
          CFRelease(v21);
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        v33 = CFGetAllocator(a2);
        v34 = CFDictionaryCreateMutable(v33, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        v21 = v34;
        if (!v34)
          goto LABEL_93;
        context = a2;
        v55 = (CFTypeRef *)v34;
        p_cf = &cf;
        CFDictionaryApplyFunction(v20, (CFDictionaryApplierFunction)_getDataClassesAndInstances, &context);
        if (cf)
          goto LABEL_93;
        v55 = &cf;
        p_cf = 0;
        CFDictionaryApplyFunction(v21, (CFDictionaryApplierFunction)_deleteUnverifiedDataInstance, &context);
        v32 = cf != 0;
        v35 = v44;
        v36 = v48;
        if (cf)
          AMSupportLogInternal();
        goto LABEL_66;
      }
    }
    else
    {
      v32 = 0;
    }
    v35 = v44;
    v36 = v48;
LABEL_66:
    if (v47)
      AMSupportLogInternal();
    v28 = !v25 && !v29 && !v32;
    if (theArray)
    {
      if (CFArrayGetCount(theArray) < 1)
        v37 = 1;
      else
        v37 = v23;
      v28 = (v37 | v22) & v28;
    }
    if (v49)
    {
      if (CFArrayGetCount(v49) < 1)
        v38 = 1;
      else
        v38 = v23;
      v28 = (v38 | v22) & v28;
    }
    if (v36)
    {
      if (CFArrayGetCount(v36) < 1)
        v39 = 1;
      else
        v39 = v23;
      v28 = (v39 | v22) & v28;
    }
    if (v50)
    {
      if (CFArrayGetCount(v50) <= 0)
        v28 = v28;
      else
        v28 = v35 & v28;
    }
    if (v47)
    {
      v40 = CFArrayGetCount(v47);
      v41 = v35 & v28;
      if (v40 <= 0)
        v41 = v28;
      if ((v41 & 1) == 0)
      {
        v28 = 0;
        goto LABEL_95;
      }
    }
    else if (!(_DWORD)v28)
    {
      goto LABEL_95;
    }
LABEL_93:
    AMSupportLogInternal();
    goto LABEL_94;
  }
LABEL_36:
  v28 = 0;
  v21 = 0;
LABEL_95:
  if (v10)
    CFRelease(v10);
  if (v21)
    CFRelease(v21);
LABEL_99:
  if (cf)
    CFRelease(cf);
  return v28;
}

uint64_t _AMFDRVerificationErrorRemoteDataIsSealed(uint64_t a1, CFErrorRef *a2)
{
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  const __CFDictionary *Value;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  _BOOL4 v8;
  _BOOL4 v9;
  uint64_t v10;

  if (!a1
    || !a2
    || !*a2
    || !*(_QWORD *)(a1 + 16)
    || *(uint64_t (***)(int, int, int, int))(a1 + 48) != AMFDRHTTPStore)
  {
    goto LABEL_14;
  }
  if (CFErrorGetCode(*a2) != 100)
    return 0;
  v3 = CFErrorCopyUserInfo(*a2);
  if (!v3)
  {
LABEL_14:
    AMSupportLogInternal();
    return 0;
  }
  v4 = v3;
  Value = (const __CFDictionary *)CFDictionaryGetValue(v3, CFSTR("UnverifiedDataInstances"));
  v6 = (const __CFDictionary *)CFDictionaryGetValue(v4, CFSTR("UnverifiedMinimalManifests"));
  v7 = v6;
  if (!Value)
  {
    v8 = 1;
    if (v6)
      goto LABEL_10;
LABEL_12:
    v9 = 1;
    goto LABEL_13;
  }
  v8 = CFDictionaryGetCount(Value) == 0;
  if (!v7)
    goto LABEL_12;
LABEL_10:
  v9 = CFDictionaryGetCount(v7) == 0;
LABEL_13:
  v10 = v8 & v9;
  CFRelease(v4);
  return v10;
}

const void *_CFDictionaryCopyValue(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  const void *v3;

  Value = CFDictionaryGetValue(a1, a2);
  v3 = Value;
  if (Value)
    CFRetain(Value);
  return v3;
}

uint64_t AMFDRSealedDataCreateSealingRequest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v6;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  const void *v10;
  CFTypeID v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex v14;
  const void *v15;
  CFTypeID v16;
  const __CFString *Value;
  const __CFArray *v18;
  const __CFArray *v19;
  const __CFAllocator *v20;
  __CFArray *Mutable;
  const __CFAllocator *v22;
  __CFArray *v23;
  const __CFAllocator *v24;
  __CFArray *v25;
  const __CFAllocator *v26;
  __CFArray *v27;
  const void *v28;
  const __CFArray *v29;
  CFIndex v30;
  CFIndex v31;
  CFIndex v32;
  const void *v33;
  const __CFString *ValueAtIndex;
  const __CFString *v35;
  const __CFArray *v36;
  CFIndex v37;
  CFIndex v38;
  const __CFString *v39;
  CFIndex v40;
  __CFArray *v41;
  __CFArray *v42;
  const __CFArray *v43;
  const __CFString *v44;
  const __CFArray *v45;
  const __CFString *v46;
  char SealingRequestInternal;
  const __CFData *v48;
  const void *v49;
  CFTypeRef v50;
  const void *v51;
  uint64_t v52;
  const __CFString *v54;
  const __CFString *v55;
  const __CFString *v56;
  const __CFString *v57;
  char v58;
  const __CFString *v59;
  __CFArray *v60;
  __CFArray *v61;
  __CFArray *theArray;
  const void *v63;
  int v64;
  const void *v65;

  v65 = 0;
  v64 = 1;
  v63 = 0;
  if (!a1)
  {
    v56 = CFSTR("sealedData is NULL");
    goto LABEL_119;
  }
  if (!a2)
  {
    v56 = CFSTR("amfdr is NULL");
    goto LABEL_119;
  }
  v6 = *(const void **)(a1 + 32);
  if (!v6)
  {
    v56 = CFSTR("sealedData->dataClassArray is NULL");
    goto LABEL_119;
  }
  if (!*(_QWORD *)(a1 + 40))
  {
    v56 = CFSTR("sealedData->dataInstanceArray is NULL");
    goto LABEL_119;
  }
  if (!*(_QWORD *)(a1 + 64))
  {
    v56 = CFSTR("sealedData->dataArray is NULL");
    goto LABEL_119;
  }
  if (!*(_QWORD *)(a1 + 80))
  {
    v56 = CFSTR("sealedData->sealedDataInstance is NULL");
    goto LABEL_119;
  }
  v7 = CFGetTypeID(v6);
  if (v7 != CFArrayGetTypeID())
  {
    v56 = CFSTR("sealedData->dataClassArray is not a CFArray");
    goto LABEL_119;
  }
  v8 = *(const void **)(a1 + 40);
  if (!v8 || (v9 = CFGetTypeID(v8), v9 != CFArrayGetTypeID()))
  {
    v56 = CFSTR("sealedData->dataInstanceArray is not a CFArray");
LABEL_119:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingRequest", v56, v58);
LABEL_120:
    v52 = 0;
    Mutable = 0;
LABEL_121:
    v23 = 0;
LABEL_122:
    v25 = 0;
LABEL_123:
    v48 = 0;
    v27 = 0;
    goto LABEL_79;
  }
  v10 = *(const void **)(a1 + 64);
  if (!v10 || (v11 = CFGetTypeID(v10), v11 != CFArrayGetTypeID()))
  {
    v56 = CFSTR("sealedData->dataArray is not a CFArray");
    goto LABEL_119;
  }
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  v13 = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
  v14 = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  if (Count != v13)
  {
    v58 = v14;
    CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    v56 = CFSTR("dataClassArray length (%ld) does not match dataInstanceArray (%ld)");
    goto LABEL_119;
  }
  if (v14 != CFArrayGetCount(*(CFArrayRef *)(a1 + 64)))
  {
    v58 = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
    CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
    v56 = CFSTR("dataClassArray length (%ld) does not match dataArray (%ld)");
    goto LABEL_119;
  }
  v15 = *(const void **)(a1 + 80);
  if (!v15 || (v16 = CFGetTypeID(v15), v16 != CFStringGetTypeID()))
  {
    v56 = CFSTR("sealedData->sealedDataInstance is not a CFStringRef");
    goto LABEL_119;
  }
  if ((AMFDRDataGetSigningVersion(a2, &v64) & 1) == 0)
  {
    v56 = CFSTR("AMFDRDataGetSigningVersion failed");
    goto LABEL_119;
  }
  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 16), CFSTR("UseSikDataInstance"));
  if ((_AMFDRSealedDataCreateSealingRequestInternal(a1, a2, *(__CFArray **)(a1 + 80), 0, 0, 0, (uint64_t)&v65, a3) & 1) == 0)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingRequest", CFSTR("_AMFDRSealedDataCreateSealingRequestInternal (Main) failed"), v58);
    goto LABEL_120;
  }
  v18 = *(const __CFArray **)(a1 + 136);
  if (!v18 || CFArrayGetCount(v18) <= 0)
  {
    v19 = *(const __CFArray **)(a1 + 176);
    if (!v19 || CFArrayGetCount(v19) < 1)
    {
      v51 = *(const void **)(a1 + 24);
      if (v51)
      {
        CFRelease(v51);
        *(_QWORD *)(a1 + 24) = 0;
      }
      v50 = CFRetain(v65);
      Mutable = 0;
      v23 = 0;
      v25 = 0;
      v48 = 0;
      v27 = 0;
LABEL_78:
      *(_QWORD *)(a1 + 24) = v50;
      v52 = 1;
      goto LABEL_79;
    }
  }
  v20 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFArrayCreateMutable(v20, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingRequest", CFSTR("mutableMultiSealingDataClasses is NULL"), v58);
    v52 = 0;
    goto LABEL_121;
  }
  v22 = CFGetAllocator((CFTypeRef)a1);
  v23 = CFArrayCreateMutable(v22, 0, MEMORY[0x24BDBD690]);
  if (!v23)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingRequest", CFSTR("mutableMultiSealingDataInstances is NULL"), v58);
    v52 = 0;
    goto LABEL_122;
  }
  v24 = CFGetAllocator((CFTypeRef)a1);
  v25 = CFArrayCreateMutable(v24, 0, MEMORY[0x24BDBD690]);
  if (!v25)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingRequest", CFSTR("sealingRequestArray is NULL"), v58);
    v52 = 0;
    goto LABEL_123;
  }
  v26 = CFGetAllocator((CFTypeRef)a2);
  v27 = CFArrayCreateMutable(v26, 0, MEMORY[0x24BDBD690]);
  if (!v27)
  {
    v57 = CFSTR("metaDataOptionsArray is NULL");
LABEL_130:
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingRequest", v57, v58);
    v52 = 0;
    v48 = 0;
    goto LABEL_79;
  }
  CFArrayInsertValueAtIndex(Mutable, 0, CFSTR("sreq"));
  CFArrayInsertValueAtIndex(v23, 0, *(const void **)(a1 + 80));
  if (!AMFDRSealedDataCreateSealingMetadata((const void *)a1, (CFDictionaryRef *)a2, CFSTR("seal"), *(_QWORD *)(a1 + 80), 0, (uint64_t *)&v63, a3)|| (v28 = v63) == 0)
  {
    v57 = CFSTR("AMFDRSealedDataCreateSealingMetadata failed");
    goto LABEL_130;
  }
  CFArrayAppendValue(v27, v63);
  if (!v65)
  {
    v52 = 0;
    v48 = 0;
    goto LABEL_82;
  }
  v59 = Value;
  CFArrayInsertValueAtIndex(v25, 0, v65);
  v29 = *(const __CFArray **)(a1 + 136);
  v61 = v25;
  theArray = v23;
  if (v29)
  {
    v30 = CFArrayGetCount(v29);
    if (v30 >= 1)
    {
      v31 = v30;
      v32 = 0;
      v33 = v28;
      while (1)
      {
        if (v65)
        {
          CFRelease(v65);
          v65 = 0;
        }
        if (v33)
        {
          CFRelease(v33);
          v28 = 0;
          v63 = 0;
        }
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 136), v32);
        v35 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), v32);
        if ((_AMFDRSealedDataCreateSealingRequestInternal(a1, a2, *(__CFArray **)(a1 + 80), 1, ValueAtIndex, v35, (uint64_t)&v65, a3) & 1) == 0)break;
        if (v65)
        {
          CFArrayAppendValue(Mutable, ValueAtIndex);
          CFArrayAppendValue(theArray, v35);
          CFArrayAppendValue(v61, v65);
          if (!AMFDRSealedDataCreateSealingMetadata((const void *)a1, (CFDictionaryRef *)a2, ValueAtIndex, (uint64_t)v35, 0, (uint64_t *)&v63, a3)|| (v28 = v63) == 0)
          {
            v54 = CFSTR("AMFDRSealedDataCreateSealingMetadata failed");
            goto LABEL_97;
          }
          CFArrayAppendValue(v27, v63);
          v33 = v28;
        }
        else
        {
          v33 = 0;
        }
        if (v31 == ++v32)
          goto LABEL_43;
      }
      v54 = CFSTR("_AMFDRSealedDataCreateSealingRequestInternal (MultiSealing) failed");
LABEL_97:
      AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingRequest", v54, v58);
      v52 = 0;
      v48 = 0;
      v25 = v61;
      v23 = theArray;
      goto LABEL_79;
    }
  }
LABEL_43:
  v60 = v27;
  v36 = *(const __CFArray **)(a1 + 176);
  if (!v36)
    goto LABEL_71;
  v37 = CFArrayGetCount(v36);
  if (v37 < 1)
    goto LABEL_71;
  v38 = v37;
  AMFDRSetOption(a2, CFSTR("UseSikDataInstance"), (const __CFString *)*MEMORY[0x24BDBD268]);
  v39 = AMFDRSealingMapCallMGCopyAnswer(CFSTR("UniqueDeviceID"), 0);
  v40 = 0;
  v41 = Mutable;
  do
  {
    if (v65)
    {
      CFRelease(v65);
      v65 = 0;
    }
    if (v28)
    {
      CFRelease(v28);
      v63 = 0;
    }
    v42 = (__CFArray *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), v40);
    v43 = *(const __CFArray **)(a1 + 184);
    if (v43 && CFArrayGetCount(v43) >= 1)
      v44 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 184), v40);
    else
      v44 = 0;
    v45 = *(const __CFArray **)(a1 + 192);
    if (v45
      && CFArrayGetCount(v45) >= 1
      && (v46 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 192), v40), v44)
      && v46)
    {
      SealingRequestInternal = _AMFDRSealedDataCreateSealingRequestInternal(a1, a2, v42, 2, v44, v46, (uint64_t)&v65, a3);
      Mutable = v41;
      if ((SealingRequestInternal & 1) == 0)
      {
        if (v39)
LABEL_105:
          CFRelease(v39);
        v55 = CFSTR("_AMFDRSealedDataCreateSealingRequestInternal (MinimalSealing) failed");
LABEL_107:
        AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingRequest", v55, v58);
LABEL_108:
        v52 = 0;
        v48 = 0;
        v25 = v61;
        v23 = theArray;
        v27 = v60;
        goto LABEL_79;
      }
    }
    else
    {
      Mutable = v41;
      if (!v39)
      {
        AMFDRErrorPushInternal(a3, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingRequest", CFSTR("UniqueDeviceID is NULL"), v58);
        goto LABEL_108;
      }
      if ((_AMFDRSealedDataCreateSealingRequestInternal(a1, a2, v42, 2, CFSTR("scrt"), v39, (uint64_t)&v65, a3) & 1) == 0)
        goto LABEL_105;
    }
    if (v65)
    {
      CFArrayAppendValue(Mutable, CFSTR("minimal-manifest"));
      CFArrayAppendValue(theArray, v42);
      CFArrayAppendValue(v61, v65);
      if (!AMFDRSealedDataCreateSealingMetadata((const void *)a1, (CFDictionaryRef *)a2, CFSTR("minimal-manifest"), (uint64_t)v42, 1, (uint64_t *)&v63, a3)|| (v28 = v63) == 0)
      {
        if (v39)
          CFRelease(v39);
        v55 = CFSTR("AMFDRSealedDataCreateSealingMetadata failed");
        goto LABEL_107;
      }
      CFArrayAppendValue(v60, v63);
    }
    else
    {
      v28 = 0;
    }
    ++v40;
  }
  while (v38 != v40);
  if (v39)
    CFRelease(v39);
  AMFDRSetOption(a2, CFSTR("UseSikDataInstance"), v59);
LABEL_71:
  v25 = v61;
  v23 = theArray;
  v27 = v60;
  v48 = AMFDRDataHTTPCreateMultiRequest((__CFString *)a2, kAMFDRHTTPMultiRequestActionSealing, Mutable, theArray, v61, 0, v60, 0, a3);
  if (v48)
  {
    v49 = *(const void **)(a1 + 24);
    if (v49)
    {
      CFRelease(v49);
      *(_QWORD *)(a1 + 24) = 0;
    }
    v50 = CFRetain(v48);
    goto LABEL_78;
  }
  AMFDRErrorPushInternal(a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingRequest", CFSTR("AMFDRDataHTTPCreateMultiRequest failed"), v58);
  v52 = 0;
LABEL_79:
  if (v65)
  {
    CFRelease(v65);
    v65 = 0;
  }
  if (v25)
LABEL_82:
    CFRelease(v25);
  if (v48)
    CFRelease(v48);
  if (Mutable)
    CFRelease(Mutable);
  if (v23)
    CFRelease(v23);
  if (v63)
  {
    CFRelease(v63);
    v63 = 0;
  }
  if (v27)
    CFRelease(v27);
  return v52;
}

uint64_t AMFDRSealedDataHTTPSign(uint64_t a1, CFDictionaryRef *a2, CFTypeRef *a3)
{
  const __CFArray *v6;
  const __CFArray *v7;
  const __CFAllocator *v8;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v10;
  const __CFAllocator *v11;
  CFMutableArrayRef v12;
  __CFArray *v13;
  const __CFArray *v14;
  const __CFArray *v15;
  const __CFArray *v16;
  CFIndex v17;
  const void *ValueAtIndex;
  const void *v19;
  const __CFAllocator *v20;
  CFStringRef FullKey;
  CFStringRef v22;
  const void *v23;
  const void *Value;
  uint64_t v25;
  const void *v26;
  const __CFString *v28;
  char v29;
  CFRange v30;
  CFRange v31;

  if (!a1)
  {
    v28 = CFSTR("sealedData is NULL");
LABEL_30:
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataHTTPSign", v28, v29);
    return 0;
  }
  if (!a2)
  {
    v28 = CFSTR("amfdrRemote is NULL");
    goto LABEL_30;
  }
  v6 = *(const __CFArray **)(a1 + 136);
  if (!v6 || !CFArrayGetCount(v6))
  {
    v7 = *(const __CFArray **)(a1 + 176);
    if (!v7 || !CFArrayGetCount(v7))
    {
      v26 = *(const void **)(a1 + 16);
      if (v26)
      {
        CFRelease(v26);
        *(_QWORD *)(a1 + 16) = 0;
      }
      if ((AMFDRDataHTTPSign(a2, *(const void **)(a1 + 80), *(const __CFData **)(a1 + 24), (CFTypeRef *)(a1 + 16), a3) & 1) != 0)
        return 1;
      AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataHTTPSign", CFSTR("AMFDRDataHTTPSign(amfdrRemote) failed."), v29);
      return 0;
    }
  }
  v8 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFArrayCreateMutable(v8, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataHTTPSign", CFSTR("mutableMultiSealingDataClasses is NULL"), v29);
    return 0;
  }
  v10 = Mutable;
  v11 = CFGetAllocator((CFTypeRef)a1);
  v12 = CFArrayCreateMutable(v11, 0, MEMORY[0x24BDBD690]);
  if (!v12)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataHTTPSign", CFSTR("mutableMultiSealingDataInstances is NULL"), v29);
    CFRelease(v10);
    return 0;
  }
  v13 = v12;
  CFArrayInsertValueAtIndex(v10, 0, CFSTR("sreq"));
  CFArrayInsertValueAtIndex(v13, 0, *(const void **)(a1 + 80));
  v14 = *(const __CFArray **)(a1 + 136);
  if (v14)
  {
    v30.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 136));
    v30.location = 0;
    CFArrayAppendArray(v10, v14, v30);
    v15 = *(const __CFArray **)(a1 + 144);
    v31.length = CFArrayGetCount(v15);
    v31.location = 0;
    CFArrayAppendArray(v13, v15, v31);
  }
  v16 = *(const __CFArray **)(a1 + 176);
  if (v16 && CFArrayGetCount(v16) >= 1)
  {
    v17 = 0;
    do
    {
      CFArrayAppendValue(v10, CFSTR("minimal-manifest"));
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), v17);
      CFArrayAppendValue(v13, ValueAtIndex);
      ++v17;
    }
    while (v17 < CFArrayGetCount(*(CFArrayRef *)(a1 + 176)));
  }
  v19 = *(const void **)(a1 + 152);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(a1 + 152) = 0;
  }
  if ((AMFDRDataHTTPMultiSign((uint64_t)a2, v10, v13, *(const __CFData **)(a1 + 24), (CFTypeRef *)(a1 + 152), a3) & 1) != 0)
  {
    v20 = CFGetAllocator(a2);
    FullKey = AMFDRDataLocalCreateFullKey(v20, (uint64_t)CFSTR("sreq"), *(_QWORD *)(a1 + 80));
    if (FullKey)
    {
      v22 = FullKey;
      v23 = *(const void **)(a1 + 16);
      if (v23)
      {
        CFRelease(v23);
        *(_QWORD *)(a1 + 16) = 0;
      }
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 152), v22);
      *(_QWORD *)(a1 + 16) = CFRetain(Value);
      CFRelease(v22);
      v25 = 1;
      goto LABEL_22;
    }
    AMFDRErrorPushInternal((uint64_t)a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataHTTPSign", CFSTR("failed to create data instance string"), v29);
  }
  else
  {
    AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataHTTPSign", CFSTR("AMFDRDataHTTPMultiSign(amfdrRemote) failed."), v29);
  }
  v25 = 0;
LABEL_22:
  CFRelease(v10);
  CFRelease(v13);
  return v25;
}

uint64_t _AMFDRSealedDataExportExistingData(CFDictionaryRef *a1, CFArrayRef *a2, CFTypeRef *a3)
{
  const __CFArray *v6;
  CFIndex Count;
  const __CFBoolean *Value;
  const __CFAllocator *v9;
  CFMutableArrayRef v10;
  __CFArray *v11;
  const __CFAllocator *v12;
  CFMutableArrayRef v13;
  __CFDictionary *v14;
  int v15;
  const __CFAllocator *v16;
  CFMutableDictionaryRef Mutable;
  __CFString *v18;
  const __CFAllocator *v19;
  CFMutableStringRef v20;
  __CFArray *v21;
  CFIndex v22;
  const __CFString *ValueAtIndex;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *v26;
  uint64_t v27;
  const __CFString *v29;
  const __CFString *v30;
  const __CFString *v31;
  char v32;
  __CFArray *theArray;
  __CFDictionary *theDict;
  CFTypeRef cf;
  _QWORD context[3];

  context[2] = *MEMORY[0x24BDAC8D0];
  cf = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExportExistingData", CFSTR("amfdr is NULL"), v32);
    return 0;
  }
  if (!a1[2])
  {
    v30 = CFSTR("amfdr->optionsDict is NULL");
LABEL_57:
    AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExportExistingData", v30, v32);
    goto LABEL_58;
  }
  if (!a2)
  {
    v30 = CFSTR("sealedData is NULL");
    goto LABEL_57;
  }
  v6 = a2[4];
  if (!v6)
  {
    v30 = CFSTR("sealedData->dataClassArray is NULL");
    goto LABEL_57;
  }
  if (!a2[5])
  {
    v30 = CFSTR("sealedData->dataInstanceArray is NULL");
    goto LABEL_57;
  }
  if (!a2[8])
  {
    v30 = CFSTR("sealedData->dataArray is NULL");
    goto LABEL_57;
  }
  Count = CFArrayGetCount(v6);
  Value = (const __CFBoolean *)CFDictionaryGetValue(a1[2], CFSTR("EnableMultiRequest"));
  if (Value && !CFBooleanGetValue(Value))
  {
    v16 = CFGetAllocator(a2);
    Mutable = CFDictionaryCreateMutable(v16, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (Mutable)
    {
      v14 = Mutable;
      v11 = 0;
      v13 = 0;
      v15 = 0;
      goto LABEL_14;
    }
    v31 = CFSTR("exportDict is NULL");
  }
  else
  {
    v9 = CFGetAllocator(a1);
    v10 = CFArrayCreateMutable(v9, 0, MEMORY[0x24BDBD690]);
    if (v10)
    {
      v11 = v10;
      v12 = CFGetAllocator(a1);
      v13 = CFArrayCreateMutable(v12, 0, MEMORY[0x24BDBD690]);
      if (!v13)
      {
        AMFDRErrorPushInternal((uint64_t)a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExportExistingData", CFSTR("dataInstancesToExport is NULL"), v32);
        v18 = 0;
        v20 = 0;
        v14 = 0;
        v27 = 0;
        goto LABEL_34;
      }
      v14 = 0;
      v15 = 1;
LABEL_14:
      v18 = (__CFString *)AMFDRCreateCopy((uint64_t)a1);
      if (!v18)
      {
        AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExportExistingData", CFSTR("cannot create a separate amfdr object for data export"), v32);
        v27 = 0;
        v20 = 0;
        goto LABEL_33;
      }
      v19 = CFGetAllocator(a2);
      v20 = CFStringCreateMutable(v19, 0);
      if (v20)
      {
        theArray = v13;
        theDict = v14;
        v21 = v11;
        if (Count >= 1)
        {
          v22 = 0;
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2[4], v22);
            if (!ValueAtIndex)
              break;
            v24 = ValueAtIndex;
            v25 = (const __CFString *)CFArrayGetValueAtIndex(a2[5], v22);
            if (!v25)
            {
              v29 = CFSTR("dataInstance is NULL");
              goto LABEL_48;
            }
            v26 = v25;
            if (CFArrayGetValueAtIndex(a2[8], v22))
            {
              if ((AMFDRDataAppendPermissionsString(v18, 3u, v24, v26, v20) & 1) == 0)
              {
                AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExportExistingData", CFSTR("AMFDRDataAppendPermissionsString failed"), v32);
                goto LABEL_50;
              }
              if (v15)
              {
                CFArrayAppendValue(v21, v24);
                CFArrayAppendValue(theArray, v26);
              }
              else
              {
                CFDictionaryAddValue(theDict, v24, v26);
              }
            }
            else
            {
              AMSupportLogInternal();
            }
            if (Count == ++v22)
              goto LABEL_27;
          }
          v29 = CFSTR("dataClass is NULL");
LABEL_48:
          AMFDRErrorPushInternal((uint64_t)a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExportExistingData", v29, v32);
          goto LABEL_50;
        }
LABEL_27:
        AMFDRSetOption((uint64_t)v18, CFSTR("Permissions"), v20);
        AMFDRSetOption((uint64_t)v18, CFSTR("OrganizationalUnit"), CFSTR("Devices - Stations"));
        AMFDRSetOption((uint64_t)v18, CFSTR("PersistCertificate"), (const __CFString *)*MEMORY[0x24BDBD268]);
        if ((AMFDRPermissionsRequest((uint64_t)v18, a3) & 1) == 0)
        {
          AMFDRErrorPushInternal((uint64_t)a3, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExportExistingData", CFSTR("Permissions request failed."), v32);
LABEL_50:
          v27 = 0;
          v11 = v21;
          v13 = theArray;
          v14 = theDict;
LABEL_33:
          if (!v11)
          {
LABEL_35:
            if (v13)
              CFRelease(v13);
            if (v14)
              CFRelease(v14);
            if (v20)
              CFRelease(v20);
            goto LABEL_41;
          }
LABEL_34:
          CFRelease(v11);
          goto LABEL_35;
        }
        v11 = v21;
        if (v15)
        {
          v13 = theArray;
          v14 = theDict;
          if ((AMFDRDataMultiExport((uint64_t)v18) & 1) == 0)
          {
            AMSupportLogInternal();
LABEL_65:
            v27 = 0;
            goto LABEL_33;
          }
        }
        else
        {
          context[0] = v18;
          context[1] = &cf;
          v14 = theDict;
          CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)_exportDataInstances, context);
          v13 = theArray;
          if (cf)
          {
            AMFDRErrorPushInternal((uint64_t)a3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExportExistingData", CFSTR("_exportDataInstances failed with error %@"), (char)cf);
            goto LABEL_65;
          }
        }
        v27 = 1;
        goto LABEL_33;
      }
      AMFDRErrorPushInternal((uint64_t)a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExportExistingData", CFSTR("permStr is NULL"), v32);
      goto LABEL_65;
    }
    v31 = CFSTR("dataClassesToExport is NULL");
  }
  AMFDRErrorPushInternal((uint64_t)a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataExportExistingData", v31, v32);
LABEL_58:
  v27 = 0;
  v18 = 0;
LABEL_41:
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v18)
    CFRelease(v18);
  return v27;
}

BOOL AMFDRSealedDataRestoreOptions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v5;
  const void *v6;

  if (a1)
  {
    if (a2)
      AMFDRSetOptions(a2, *(CFTypeRef *)(a1 + 112));
    if (a3)
      AMFDRSetOptions(a3, *(CFTypeRef *)(a1 + 120));
    v5 = *(const void **)(a1 + 112);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 112) = 0;
    }
    v6 = *(const void **)(a1 + 120);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a1 + 120) = 0;
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  return a1 != 0;
}

uint64_t _AMFDRSealedDataSealingPropertyCheck(const __CFString *a1, const __CFString *cf, uint64_t a3)
{
  const void *v5;
  const __CFArray *v6;
  __CFArray *v7;
  const __CFArray *v8;
  CFTypeID v9;
  char v10;
  char v11;
  _BOOL4 v12;
  CFDataRef v13;
  char v14;
  CFTypeID v15;
  const __CFAllocator *v16;
  const __CFString *v17;
  CFDataRef data;
  CFRange v20;
  CFRange v21;

  data = 0;
  v5 = *(const void **)a3;
  v6 = *(const __CFArray **)(a3 + 8);
  v8 = *(const __CFArray **)(a3 + 16);
  v7 = *(__CFArray **)(a3 + 24);
  if (cf && (v9 = CFGetTypeID(cf), v9 == CFNumberGetTypeID()))
    v10 = AMFDRDataCopySealingManifestIntegerProperty(v5, a1, (uint64_t)&data);
  else
    v10 = AMFDRDataCopySealingManifestProperty(v5, a1, (uint64_t)&data);
  v11 = v10;
  if (v6)
  {
    v20.length = CFArrayGetCount(v6);
    v20.location = 0;
    LODWORD(v6) = CFArrayContainsValue(v6, v20, a1) != 0;
  }
  if (v8)
  {
    v21.length = CFArrayGetCount(v8);
    v21.location = 0;
    v12 = CFArrayContainsValue(v8, v21, a1) != 0;
  }
  else
  {
    v12 = 0;
  }
  v13 = data;
  if (data)
    v14 = v11;
  else
    v14 = 0;
  if ((v14 & 1) != 0)
  {
    if (cf)
    {
      v15 = CFGetTypeID(cf);
      if (v15 == CFStringGetTypeID())
      {
        v16 = CFGetAllocator(v5);
        v17 = CFStringCreateFromExternalRepresentation(v16, data, 0x8000100u);
        if ((!v17 || CFStringCompare(v17, cf, 0)) && (v6 | v12) == 1)
          goto LABEL_19;
LABEL_27:
        AMSupportLogInternal();
        goto LABEL_28;
      }
      v13 = data;
    }
    if (CFEqual(v13, cf) || (v6 | v12) != 1)
      goto LABEL_27;
  }
  else if ((v6 | v12) != 1)
  {
    goto LABEL_27;
  }
LABEL_19:
  AMSupportLogInternal();
  CFArrayAppendValue(v7, a1);
LABEL_28:
  AMSupportSafeRelease();
  return AMSupportSafeRelease();
}

uint64_t _AMFDRSealedDataCreateSealingRequestInternal(uint64_t a1, uint64_t a2, __CFArray *a3, int a4, const __CFString *a5, const __CFString *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const void *v10;
  CFTypeID v14;
  const void *v15;
  CFTypeID v16;
  const void *v17;
  CFTypeID v18;
  CFIndex Count;
  CFIndex v20;
  CFIndex v21;
  const void *v22;
  CFTypeID v23;
  const __CFAllocator *v24;
  CFMutableDictionaryRef Mutable;
  const __CFString *InstanceString;
  const __CFAllocator *v27;
  const __CFData *ExternalRepresentation;
  const __CFData *v29;
  const __CFAllocator *v30;
  CFIndex v31;
  CFIndex v32;
  CFIndex v33;
  CFStringRef FullKey;
  const __CFString *v35;
  const __CFString *ValueAtIndex;
  const __CFString *v37;
  const void *v38;
  __int128 v39;
  const void *v40;
  const __CFAllocator *v41;
  const __CFArray *v42;
  int v43;
  CFTypeID v44;
  CFTypeID v45;
  CFTypeID v46;
  const __CFAllocator *v47;
  const __CFString *format;
  const __CFString *v50;
  const __CFString *v51;
  const __CFString *v52;
  const __CFString *v53;
  char v54;
  char v55;
  const __CFString *v57;
  const __CFData *v58;
  __CFArray *theArray;
  CFTypeRef v61;
  const __CFString *v62;
  _QWORD *v63;
  int v64;
  CFTypeRef v65;
  CFTypeRef cf;
  CFTypeRef v67[2];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  unint64_t v95;
  uint64_t v96;
  CFRange v97;

  v96 = *MEMORY[0x24BDAC8D0];
  v65 = 0;
  cf = 0;
  v64 = 1;
  v63 = 0;
  if (!a1)
  {
    v53 = CFSTR("sealedData is NULL");
    goto LABEL_100;
  }
  v8 = a2;
  if (!a2)
  {
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", CFSTR("amfdr is NULL"), v55);
LABEL_102:
    Mutable = 0;
LABEL_103:
    a3 = 0;
    goto LABEL_104;
  }
  v10 = *(const void **)(a1 + 32);
  if (!v10)
  {
    v53 = CFSTR("sealedData->dataClassArray is NULL");
    goto LABEL_100;
  }
  if (!*(_QWORD *)(a1 + 40))
  {
    v53 = CFSTR("sealedData->dataInstanceArray is NULL");
    goto LABEL_100;
  }
  if (!*(_QWORD *)(a1 + 64))
  {
    v53 = CFSTR("sealedData->dataArray is NULL");
    goto LABEL_100;
  }
  if (!*(_QWORD *)(a1 + 80))
  {
    v53 = CFSTR("sealedData->sealedDataInstance is NULL");
    goto LABEL_100;
  }
  v14 = CFGetTypeID(v10);
  if (v14 != CFArrayGetTypeID())
  {
    v53 = CFSTR("sealedData->dataClassArray is not a CFArray");
    goto LABEL_100;
  }
  v15 = *(const void **)(a1 + 40);
  if (!v15 || (v16 = CFGetTypeID(v15), v16 != CFArrayGetTypeID()))
  {
    v53 = CFSTR("sealedData->dataInstanceArray is not a CFArray");
LABEL_100:
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", v53, v55);
    goto LABEL_101;
  }
  v17 = *(const void **)(a1 + 64);
  if (!v17 || (v18 = CFGetTypeID(v17), v18 != CFArrayGetTypeID()))
  {
    v53 = CFSTR("sealedData->dataArray is not a CFArray");
    goto LABEL_100;
  }
  v62 = a5;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  v20 = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
  v21 = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  if (Count != v20)
  {
    CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", CFSTR("dataClassArray length (%ld) does not match dataInstanceArray (%ld)"), v21);
LABEL_101:
    v8 = 0;
    goto LABEL_102;
  }
  if (v21 != CFArrayGetCount(*(CFArrayRef *)(a1 + 64)))
  {
    v54 = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
    CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", CFSTR("dataClassArray length (%ld) does not match dataArray (%ld)"), v54);
    goto LABEL_101;
  }
  v22 = *(const void **)(a1 + 80);
  if (!v22 || (v23 = CFGetTypeID(v22), v23 != CFStringGetTypeID()))
  {
    v53 = CFSTR("sealedData->sealedDataInstance is not a CFStringRef");
    goto LABEL_100;
  }
  if (!a3)
  {
    AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", CFSTR("sreqDataInstance is NULL"), v55);
    v8 = 0;
    Mutable = 0;
LABEL_104:
    FullKey = 0;
    v58 = 0;
    InstanceString = 0;
    goto LABEL_59;
  }
  if ((AMFDRDataGetSigningVersion(v8, &v64) & 1) == 0)
  {
    v53 = CFSTR("AMFDRDataGetSigningVersion failed");
    goto LABEL_100;
  }
  v24 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFDictionaryCreateMutable(v24, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", CFSTR("extraProperties is NULL"), v55);
    v8 = 0;
    goto LABEL_103;
  }
  v61 = (CFTypeRef)v8;
  InstanceString = AMFDRDataCreateInstanceString((__CFString *)v8, 0, a3);
  if (!InstanceString)
  {
    AMFDRErrorPushInternal(a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", CFSTR("sreqDataInstanceStr is NULL"), v55);
LABEL_108:
    v8 = 0;
    a3 = 0;
    FullKey = 0;
    v58 = 0;
    goto LABEL_59;
  }
  v27 = CFGetAllocator((CFTypeRef)a1);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v27, InstanceString, 0x8000100u, 0x5Fu);
  if (!ExternalRepresentation)
  {
    AMFDRErrorPushInternal(a8, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", CFSTR("sreqDataInstanceData is NULL"), v55);
    goto LABEL_108;
  }
  v57 = InstanceString;
  v29 = ExternalRepresentation;
  CFDataGetBytePtr(ExternalRepresentation);
  v58 = v29;
  CFDataGetLength(v29);
  v30 = CFGetAllocator((CFTypeRef)a1);
  theArray = CFArrayCreateMutable(v30, 0, MEMORY[0x24BDBD690]);
  v31 = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  if (v31 >= 1)
  {
    v32 = v31;
    v33 = 0;
    FullKey = 0;
    v35 = v62;
    while (1)
    {
      if (FullKey)
        CFRelease(FullKey);
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
      if (v65)
      {
        CFRelease(v65);
        v65 = 0;
      }
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), v33);
      v37 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), v33);
      if (v35 && CFStringCompare(v35, ValueAtIndex, 0) || a6 && CFStringCompare(a6, v37, 0))
      {
        FullKey = 0;
      }
      else
      {
        v38 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), v33);
        v95 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v39 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v93 = v39;
        v94 = v39;
        v91 = v39;
        v92 = v39;
        v89 = v39;
        v90 = v39;
        v87 = v39;
        v88 = v39;
        v85 = v39;
        v86 = v39;
        v83 = v39;
        v84 = v39;
        v81 = v39;
        v82 = v39;
        v79 = v39;
        v80 = v39;
        v77 = v39;
        v78 = v39;
        v75 = v39;
        v76 = v39;
        v73 = v39;
        v74 = v39;
        v71 = v39;
        v72 = v39;
        v70 = v39;
        v68 = v39;
        v69 = v39;
        *(_OWORD *)v67 = v39;
        if (!ValueAtIndex)
        {
          v50 = CFSTR("dataClassStr is NULL");
LABEL_76:
          AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", v50, v55);
          FullKey = 0;
          goto LABEL_85;
        }
        if (!v37)
        {
          v50 = CFSTR("dataInstanceStr is NULL");
          goto LABEL_76;
        }
        v40 = v38;
        v41 = CFGetAllocator((CFTypeRef)a1);
        FullKey = AMFDRDataLocalCreateFullKey(v41, (uint64_t)ValueAtIndex, (uint64_t)v37);
        if (!FullKey)
        {
          AMFDRErrorPushInternal(a8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", CFSTR("failed to create data instance string"), v55);
          goto LABEL_85;
        }
        v42 = *(const __CFArray **)(a1 + 296);
        if (!v42)
        {
          v35 = v62;
          if (v40)
          {
LABEL_42:
            v44 = CFGetTypeID(ValueAtIndex);
            if (v44 == CFStringGetTypeID())
            {
              v45 = CFGetTypeID(v37);
              if (v45 == CFStringGetTypeID())
              {
                v46 = CFGetTypeID(v40);
                if (v46 == CFDataGetTypeID())
                {
                  v47 = CFGetAllocator(v61);
                  if ((AMFDRDataStripExtraManifest(v47, (CFDataRef)v40, &cf, &v65, a8) & 1) != 0)
                  {
                    CFDataGetBytePtr((CFDataRef)cf);
                    CFDataGetLength((CFDataRef)cf);
                    if (Img4DecodeInit())
                    {
                      v52 = CFSTR("FDR failed to decode Data img4");
                    }
                    else
                    {
                      Img4DecodeGetManifest();
                      v52 = CFSTR("FDR failed to get manifest from Data img4");
                    }
                    AMFDRErrorPushInternal(a8, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", v52, v55);
                  }
                  else
                  {
                    AMFDRErrorPushInternal(a8, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", CFSTR("AMFDRDataStripExtraManifest failed"), v55);
                  }
                  goto LABEL_85;
                }
                v51 = CFSTR("payload is not CFDataRef");
              }
              else
              {
                v51 = CFSTR("dataInstance is not CFStringRef");
              }
            }
            else
            {
              v51 = CFSTR("dataClass is not CFStringRef");
            }
            AMFDRErrorPushInternal(a8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", v51, v55);
LABEL_85:
            v8 = 0;
            a3 = theArray;
            InstanceString = v57;
            goto LABEL_59;
          }
LABEL_48:
          AMSupportLogInternal();
          goto LABEL_49;
        }
        v97.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 296));
        v97.location = 0;
        v43 = CFArrayContainsValue(v42, v97, ValueAtIndex);
        v35 = v62;
        if (v40)
          goto LABEL_42;
        if (!v43)
          goto LABEL_48;
        CFArrayAppendValue(theArray, FullKey);
      }
LABEL_49:
      if (v32 == ++v33)
      {
        if (a4)
        {
          a3 = theArray;
          InstanceString = v57;
          goto LABEL_53;
        }
        a3 = theArray;
        InstanceString = v57;
LABEL_57:
        format = CFSTR("Found no data to seal over");
LABEL_58:
        AMFDRErrorPushInternal(a8, 7, 0, a3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRSealedDataCreateSealingRequestInternal", format, v55);
        v8 = 0;
        goto LABEL_59;
      }
    }
  }
  FullKey = 0;
  a3 = theArray;
  if (!a4)
    goto LABEL_57;
LABEL_53:
  if (!AMFDRAllowIncompleteData((uint64_t)v61))
  {
    format = CFSTR("Missing data to create multi sealing request and incomplete data is not allowed");
    goto LABEL_58;
  }
  AMSupportLogInternal();
  v8 = 1;
LABEL_59:
  if (InstanceString)
    CFRelease(InstanceString);
  if (v58)
    CFRelease(v58);
  if (FullKey)
    CFRelease(FullKey);
  if (v65)
  {
    CFRelease(v65);
    v65 = 0;
  }
  if (a3)
    CFRelease(a3);
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
  AMFDREncodeMetadataDestroy(&v63);
  return v8;
}

uint64_t AMFDRSealedDataCreateSealingMetadata(const void *a1, CFDictionaryRef *cf, const __CFString *a3, uint64_t a4, int a5, uint64_t *a6, uint64_t a7)
{
  const __CFAllocator *v14;
  CFStringRef v15;
  CFStringRef v16;
  const __CFAllocator *v17;
  __CFDictionary *Mutable;
  __CFDictionary *v19;
  const __CFDictionary *Value;
  const __CFDictionary *v21;
  const __CFString *v23;
  char v24;

  if (!cf)
  {
    v23 = CFSTR("amfdr is NULL");
LABEL_16:
    AMFDRErrorPushInternal(a7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingMetadata", v23, v24);
    return 0;
  }
  if (!a3 || !a4)
  {
    v23 = CFSTR("dataClass/dataInstance is NULL");
    goto LABEL_16;
  }
  v14 = CFGetAllocator(cf);
  v15 = CFStringCreateWithFormat(v14, 0, CFSTR("%@-%@"), a3, a4);
  if (!v15)
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingMetadata", CFSTR("innerHeaderKey is NULL"), v24);
    return 0;
  }
  v16 = v15;
  v17 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v17, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a7, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataCreateSealingMetadata", CFSTR("mutableMetaDataDict is NULL"), v24);
    CFRelease(v16);
    return 0;
  }
  v19 = Mutable;
  if (a5)
    CFDictionarySetValue(Mutable, CFSTR("x-fdr-minimal-seal"), CFSTR("true"));
  if (CFStringCompare(a3, CFSTR("seal"), 0))
    CFDictionarySetValue(v19, CFSTR("x-fdr-seal-manifest-version"), CFSTR("1"));
  Value = (const __CFDictionary *)CFDictionaryGetValue(cf[2], CFSTR("MultiSealingMetadata"));
  if (Value)
  {
    v21 = (const __CFDictionary *)CFDictionaryGetValue(Value, v16);
    if (v21)
      _CFDictionaryAddDictionary(v19, v21);
  }
  *a6 = AMSupportSafeRetain();
  CFRelease(v16);
  CFRelease(v19);
  return 1;
}

uint64_t AMFDRSealedDataDelete(CFArrayRef *a1, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  CFIndex v8;
  const __CFString *ValueAtIndex;
  const __CFString *v10;
  const __CFString *v12;
  char v13;

  if (!a1)
  {
    v12 = CFSTR("sealedData is NULL");
LABEL_15:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataDelete", v12, v13);
    return 0;
  }
  if (!a2)
  {
    v12 = CFSTR("dataClass is NULL");
    goto LABEL_15;
  }
  if (!a3)
  {
    v12 = CFSTR("dataInstance is NULL");
    goto LABEL_15;
  }
  AMSupportLogInternal();
  if (CFArrayGetCount(a1[8]) < 1)
  {
LABEL_9:
    AMFDRErrorPushInternal(a4, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataDelete", CFSTR("failed to find %@-%@ from sealedData to delete"), (char)a2);
    return 0;
  }
  v8 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1[4], v8);
    v10 = (const __CFString *)CFArrayGetValueAtIndex(a1[5], v8);
    if (CFStringCompare(a2, ValueAtIndex, 0) == kCFCompareEqualTo
      && CFStringCompare(a3, v10, 0) == kCFCompareEqualTo)
    {
      break;
    }
    if (++v8 >= CFArrayGetCount(a1[8]))
      goto LABEL_9;
  }
  CFArraySetValueAtIndex(a1[8], v8, 0);
  return 1;
}

uint64_t AMFDRSealedDataGetSealingManifest(uint64_t a1, uint64_t a2)
{
  char vars0;

  if (a1)
    return *(_QWORD *)(a1 + 16);
  AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataGetSealingManifest", CFSTR("sealedData is NULL"), vars0);
  return 0;
}

BOOL AMFDRSealedDataClearSealingManifest(uint64_t a1, uint64_t a2)
{
  const void *v3;
  char v5;

  if (a1)
  {
    v3 = *(const void **)(a1 + 16);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
  else
  {
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataClearSealingManifest", CFSTR("sealedData is NULL"), v5);
  }
  return a1 != 0;
}

uint64_t AMFDRSealedDataGetSealingRequest(uint64_t a1, uint64_t a2)
{
  char vars0;

  if (a1)
    return *(_QWORD *)(a1 + 24);
  AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSealedDataGetSealingRequest", CFSTR("sealedData is NULL"), vars0);
  return 0;
}

void _getDataClassesAndInstances(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  const __CFDictionary *v4;
  CFTypeRef v5;
  uint64_t v6;
  const __CFAllocator *v7;
  const void *Value;
  const void *v9;
  CFTypeID v10;
  __CFArray *Mutable;
  const __CFAllocator *v12;
  char v13;
  CFTypeRef v14;
  CFTypeRef v15;

  v14 = 0;
  v15 = 0;
  v5 = *(CFTypeRef *)a3;
  v4 = *(const __CFDictionary **)(a3 + 8);
  v6 = *(_QWORD *)(a3 + 16);
  v7 = CFGetAllocator(*(CFTypeRef *)a3);
  if ((AMFDRDataLocalDecomposeFullKey(v7, a1, &v15, &v14) & 1) != 0)
  {
    Value = CFDictionaryGetValue(v4, v15);
    if (Value)
    {
      v9 = Value;
      v10 = CFGetTypeID(Value);
      if (v10 == CFArrayGetTypeID())
      {
        Mutable = (__CFArray *)CFRetain(v9);
LABEL_7:
        CFArrayAppendValue(Mutable, v14);
        goto LABEL_8;
      }
    }
    v12 = CFGetAllocator(v5);
    Mutable = CFArrayCreateMutable(v12, 0, MEMORY[0x24BDBD690]);
    if (Mutable)
    {
      CFDictionarySetValue(v4, v15, Mutable);
      goto LABEL_7;
    }
    AMFDRErrorPushInternal(v6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_getDataClassesAndInstances", CFSTR("multiDataInstances is NULL"), v13);
  }
  else
  {
    AMFDRErrorPushInternal(v6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_getDataClassesAndInstances", CFSTR("Cannot add data class and instance from %@ to dictionary"), (char)a1);
    Mutable = 0;
  }
LABEL_8:
  if (v15)
  {
    CFRelease(v15);
    v15 = 0;
  }
  if (v14)
  {
    CFRelease(v14);
    v14 = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
}

CFIndex _deleteUnverifiedDataInstance(char a1, CFArrayRef theArray, uint64_t *a3)
{
  __CFError **v5;
  uint64_t v6;
  CFIndex result;
  CFIndex v8;

  v6 = *a3;
  v5 = (__CFError **)a3[1];
  result = CFArrayGetCount(theArray);
  if (result >= 1)
  {
    v8 = 0;
    while (1)
    {
      CFArrayGetValueAtIndex(theArray, v8);
      AMSupportLogInternal();
      if ((AMFDRDataDelete(v6) & 1) == 0)
        break;
      ++v8;
      result = CFArrayGetCount(theArray);
      if (v8 >= result)
        return result;
    }
    AMFDRGetTrustError(*v5);
    return AMFDRErrorPushInternal((uint64_t)v5, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_deleteUnverifiedDataInstance", CFSTR("_deleteUnverifiedDataInstance failed when deleting data %@-%@ with error 0x%016llX."), a1);
  }
  return result;
}

double _AMFDRSealedDataFinalize(_QWORD *a1)
{
  const void *v2;
  _QWORD *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  double result;

  if (!a1)
    _AMFDRSealedDataFinalize_cold_1();
  v3 = a1 + 2;
  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    *v3 = 0;
  }
  v4 = (const void *)a1[3];
  if (v4)
  {
    CFRelease(v4);
    a1[3] = 0;
  }
  v5 = (const void *)a1[4];
  if (v5)
  {
    CFRelease(v5);
    a1[4] = 0;
  }
  v6 = (const void *)a1[5];
  if (v6)
  {
    CFRelease(v6);
    a1[5] = 0;
  }
  v7 = (const void *)a1[8];
  if (v7)
  {
    CFRelease(v7);
    a1[8] = 0;
  }
  v8 = (const void *)a1[9];
  if (v8)
  {
    CFRelease(v8);
    a1[9] = 0;
  }
  v9 = (const void *)a1[10];
  if (v9)
  {
    CFRelease(v9);
    a1[10] = 0;
  }
  v10 = (const void *)a1[17];
  if (v10)
  {
    CFRelease(v10);
    a1[17] = 0;
  }
  v11 = (const void *)a1[18];
  if (v11)
  {
    CFRelease(v11);
    a1[18] = 0;
  }
  v12 = (const void *)a1[19];
  if (v12)
  {
    CFRelease(v12);
    a1[19] = 0;
  }
  v13 = (const void *)a1[11];
  if (v13)
  {
    CFRelease(v13);
    a1[11] = 0;
  }
  v14 = (const void *)a1[12];
  if (v14)
  {
    CFRelease(v14);
    a1[12] = 0;
  }
  v15 = (const void *)a1[13];
  if (v15)
  {
    CFRelease(v15);
    a1[13] = 0;
  }
  v16 = (const void *)a1[20];
  if (v16)
  {
    CFRelease(v16);
    a1[20] = 0;
  }
  v17 = (const void *)a1[22];
  if (v17)
  {
    CFRelease(v17);
    a1[22] = 0;
  }
  v18 = (const void *)a1[23];
  if (v18)
  {
    CFRelease(v18);
    a1[23] = 0;
  }
  v19 = (const void *)a1[24];
  if (v19)
  {
    CFRelease(v19);
    a1[24] = 0;
  }
  v20 = (const void *)a1[25];
  if (v20)
  {
    CFRelease(v20);
    a1[25] = 0;
  }
  v21 = (const void *)a1[30];
  if (v21)
  {
    CFRelease(v21);
    a1[30] = 0;
  }
  v22 = (const void *)a1[31];
  if (v22)
  {
    CFRelease(v22);
    a1[31] = 0;
  }
  v23 = (const void *)a1[32];
  if (v23)
  {
    CFRelease(v23);
    a1[32] = 0;
  }
  v24 = (const void *)a1[33];
  if (v24)
  {
    CFRelease(v24);
    a1[33] = 0;
  }
  v25 = (const void *)a1[34];
  if (v25)
  {
    CFRelease(v25);
    a1[34] = 0;
  }
  v26 = (const void *)a1[35];
  if (v26)
  {
    CFRelease(v26);
    a1[35] = 0;
  }
  v27 = (const void *)a1[36];
  if (v27)
  {
    CFRelease(v27);
    a1[36] = 0;
  }
  v28 = (const void *)a1[37];
  if (v28)
  {
    CFRelease(v28);
    a1[37] = 0;
  }
  v29 = (const void *)a1[6];
  if (v29)
  {
    CFRelease(v29);
    a1[6] = 0;
  }
  v30 = (const void *)a1[7];
  if (v30)
  {
    CFRelease(v30);
    a1[7] = 0;
  }
  v31 = (const void *)a1[16];
  if (v31)
  {
    CFRelease(v31);
    a1[16] = 0;
  }
  v32 = (const void *)a1[21];
  if (v32)
  {
    CFRelease(v32);
    a1[21] = 0;
  }
  v33 = (const void *)a1[28];
  if (v33)
  {
    CFRelease(v33);
    a1[28] = 0;
  }
  v34 = (const void *)a1[29];
  if (v34)
  {
    CFRelease(v34);
    a1[29] = 0;
  }
  v35 = (const void *)a1[14];
  if (v35)
  {
    CFRelease(v35);
    a1[14] = 0;
  }
  v36 = (const void *)a1[15];
  if (v36)
    CFRelease(v36);
  result = 0.0;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  return result;
}

CFTypeRef *_AMFDRSealedDataEqual(CFTypeRef *result, CFTypeRef *a2)
{
  CFTypeRef *v3;
  CFTypeID v4;
  CFTypeID v5;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID(result);
    pthread_once(&_AMFDRSealedDataClassInitializeOnce, (void (*)(void))_AMFDRSealedDataClassInitialize);
    result = 0;
    if (a2)
    {
      if (v4 == _AMFDRSealedDataTypeID)
      {
        v5 = CFGetTypeID(a2);
        pthread_once(&_AMFDRSealedDataClassInitializeOnce, (void (*)(void))_AMFDRSealedDataClassInitialize);
        if (v5 == _AMFDRSealedDataTypeID)
        {
          result = (CFTypeRef *)CFEqual(v3[4], a2[4]);
          if ((_DWORD)result)
          {
            result = (CFTypeRef *)CFEqual(v3[5], a2[5]);
            if ((_DWORD)result)
              return (CFTypeRef *)(CFEqual(v3[8], a2[8]) != 0);
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFStringRef _AMFDRSealedDataCopyFormattingDescription(_QWORD *a1)
{
  if (!a1)
    _AMFDRSealedDataCopyFormattingDescription_cold_1();
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("sealedDataClass=%@ sealedDataInstance=%@ dataClassArray=%@ dataInstanceArray=%@ dataArray=%@"), a1[9], a1[10], a1[4], a1[5], a1[8]);
}

uint64_t _exportDataInstances(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  char v3;
  uint64_t v4;
  uint64_t result;
  const __CFString *v6;
  char v7;

  v3 = a1;
  v4 = a3[1];
  if (!*a3)
  {
    v6 = CFSTR("amfdr is NULL");
    return AMFDRErrorPushInternal(v4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_exportDataInstances", v6, v7);
  }
  if (!a1)
  {
    v6 = CFSTR("dataClass is NULL");
    return AMFDRErrorPushInternal(v4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_exportDataInstances", v6, v7);
  }
  if (!a2)
  {
    v6 = CFSTR("dataInstance is NULL");
    return AMFDRErrorPushInternal(v4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_exportDataInstances", v6, v7);
  }
  result = AMFDRDataExport(*a3);
  if ((result & 1) == 0)
    return AMFDRErrorPushInternal(v4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_exportDataInstances", CFSTR("Fail to export data %@-%@"), v3);
  return result;
}

CFDataRef AMFDRDataMemoryCopyDigest(const __CFData *cf, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFDataRef v5;
  const __CFAllocator *v8;
  CFStringRef FullKey;
  CFStringRef v10;
  const __CFDictionary *Store;
  const __CFData *Value;
  const __CFData *v13;
  const UInt8 *BytePtr;
  const __CFAllocator *v15;
  const __CFString *v17;
  const __CFString *v18;
  char v19;
  UInt8 bytes[16];
  uint64_t v21;

  v5 = cf;
  v21 = *MEMORY[0x24BDAC8D0];
  memset(bytes, 170, sizeof(bytes));
  if (!cf)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryCopyDigest", CFSTR("amfdr is NULL"), v19);
    return v5;
  }
  if (!a2)
  {
    v17 = CFSTR("dataClassStr is NULL");
LABEL_16:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryCopyDigest", v17, v19);
    return 0;
  }
  if (!a3)
  {
    v17 = CFSTR("dataInstanceStr is NULL.");
    goto LABEL_16;
  }
  v8 = CFGetAllocator(cf);
  FullKey = AMFDRDataLocalCreateFullKey(v8, a2, a3);
  if (!FullKey)
  {
    v17 = CFSTR("fullKey is NULL");
    goto LABEL_16;
  }
  v10 = FullKey;
  Store = AMFDRDataMemoryGetStore(v5);
  if (!Store)
  {
    v18 = CFSTR("memoryStore is NULL");
LABEL_20:
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryCopyDigest", v18, v19);
    goto LABEL_21;
  }
  Value = (const __CFData *)CFDictionaryGetValue(Store, v10);
  if (Value)
  {
    v13 = Value;
    BytePtr = CFDataGetBytePtr(Value);
    CFDataGetLength(v13);
    if (AMFDRDigestMd5((uint64_t)BytePtr))
    {
      v15 = CFGetAllocator(v5);
      v5 = CFDataCreate(v15, bytes, 16);
      if (!v5)
        AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryCopyDigest", CFSTR("CFDataCreate failed to create md5 data"), v19);
      goto LABEL_10;
    }
    v18 = CFSTR("Failed to compute md5");
    goto LABEL_20;
  }
  AMFDRErrorPushInternal(a4, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryCopyDigest", CFSTR("Failed to read memory data for key %@"), (char)v10);
LABEL_21:
  v5 = 0;
LABEL_10:
  CFRelease(v10);
  return v5;
}

BOOL AMFDRDataMemoryPresent(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const __CFAllocator *v8;
  CFStringRef FullKey;
  CFStringRef v10;
  const __CFDictionary *Store;
  int v12;
  const __CFString *v14;
  char v15;

  if (!a1)
  {
    v14 = CFSTR("amfdr is NULL");
LABEL_13:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryPresent", v14, v15);
    v12 = 0;
    return v12 != 0;
  }
  if (!a2)
  {
    v14 = CFSTR("dataClassStr is NULL");
    goto LABEL_13;
  }
  if (!a3)
  {
    v14 = CFSTR("dataInstanceStr is NULL.");
    goto LABEL_13;
  }
  v8 = CFGetAllocator(a1);
  FullKey = AMFDRDataLocalCreateFullKey(v8, a2, a3);
  if (!FullKey)
  {
    v14 = CFSTR("fullKey is NULL");
    goto LABEL_13;
  }
  v10 = FullKey;
  Store = AMFDRDataMemoryGetStore(a1);
  if (Store)
  {
    v12 = CFDictionaryContainsKey(Store, v10);
  }
  else
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryPresent", CFSTR("memoryStore is NULL"), v15);
    v12 = 0;
  }
  CFRelease(v10);
  return v12 != 0;
}

CFTypeRef AMFDRDataMemoryCopy(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const __CFAllocator *v8;
  CFStringRef FullKey;
  CFStringRef v10;
  const __CFDictionary *Store;
  const void *Value;
  CFTypeRef v13;
  const __CFString *format;
  char v16;

  if (!a1)
  {
    format = CFSTR("amfdr is NULL");
LABEL_14:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryCopy", format, v16);
    return 0;
  }
  if (!a2)
  {
    format = CFSTR("dataClassStr is NULL");
    goto LABEL_14;
  }
  if (!a3)
  {
    format = CFSTR("dataInstanceStr is NULL.");
    goto LABEL_14;
  }
  v8 = CFGetAllocator(a1);
  FullKey = AMFDRDataLocalCreateFullKey(v8, a2, a3);
  if (!FullKey)
  {
    format = CFSTR("fullKey is NULL");
    goto LABEL_14;
  }
  v10 = FullKey;
  Store = AMFDRDataMemoryGetStore(a1);
  if (!Store)
  {
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryCopy", CFSTR("memoryStore is NULL"), v16);
LABEL_17:
    v13 = 0;
    goto LABEL_8;
  }
  Value = CFDictionaryGetValue(Store, v10);
  if (!Value)
  {
    AMFDRErrorPushInternal(a4, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryCopy", CFSTR("Failed to read memory data for key %@"), (char)v10);
    goto LABEL_17;
  }
  v13 = CFRetain(Value);
LABEL_8:
  CFRelease(v10);
  return v13;
}

unint64_t AMFDRDataMemoryPutWithOptions(_QWORD *cf, uint64_t a2, uint64_t a3, const void *a4, int a5, uint64_t a6)
{
  unint64_t v7;
  const __CFAllocator *v11;
  CFStringRef FullKey;
  CFStringRef v13;
  __CFDictionary *Store;
  const __CFString *v16;
  char v17;

  v7 = (unint64_t)cf;
  if (!cf)
  {
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryPutWithOptions", CFSTR("amfdr is NULL"), v17);
    return v7;
  }
  if (!a2)
  {
    v16 = CFSTR("dataClassStr is NULL");
LABEL_15:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryPutWithOptions", v16, v17);
    return 0;
  }
  if (!a3)
  {
    v16 = CFSTR("dataInstanceStr is NULL.");
    goto LABEL_15;
  }
  if (!a4)
  {
    v16 = CFSTR("valueData is NULL");
    goto LABEL_15;
  }
  v11 = CFGetAllocator(cf);
  FullKey = AMFDRDataLocalCreateFullKey(v11, a2, a3);
  if (!FullKey)
  {
    v16 = CFSTR("fullKey is NULL");
    goto LABEL_15;
  }
  v13 = FullKey;
  Store = AMFDRDataMemoryGetStore((_QWORD *)v7);
  v7 = Store != 0;
  if (Store)
    CFDictionarySetValue(Store, v13, a4);
  else
    AMFDRErrorPushInternal(a6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryPutWithOptions", CFSTR("memoryStore is NULL"), v17);
  CFRelease(v13);
  return v7;
}

unint64_t AMFDRDataMemoryDelete(_QWORD *cf, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5;
  const __CFAllocator *v8;
  CFStringRef FullKey;
  CFStringRef v10;
  __CFDictionary *Store;
  const __CFString *v13;
  char v14;

  v5 = (unint64_t)cf;
  if (!cf)
  {
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryDelete", CFSTR("amfdr is NULL"), v14);
    return v5;
  }
  if (!a2)
  {
    v13 = CFSTR("dataClassStr is NULL");
LABEL_13:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryDelete", v13, v14);
    return 0;
  }
  if (!a3)
  {
    v13 = CFSTR("dataInstanceStr is NULL.");
    goto LABEL_13;
  }
  v8 = CFGetAllocator(cf);
  FullKey = AMFDRDataLocalCreateFullKey(v8, a2, a3);
  if (!FullKey)
  {
    v13 = CFSTR("fullKey is NULL");
    goto LABEL_13;
  }
  v10 = FullKey;
  Store = AMFDRDataMemoryGetStore((_QWORD *)v5);
  v5 = Store != 0;
  if (Store)
    CFDictionaryRemoveValue(Store, v10);
  else
    AMFDRErrorPushInternal(a4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryDelete", CFSTR("memoryStore is NULL"), v14);
  CFRelease(v10);
  return v5;
}

uint64_t AMFDRDataMemoryPrefetch(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryPrefetch", CFSTR("AMFDRDataMemoryPrefetch is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryExport(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryExport", CFSTR("AMFDRDataMemoryExport is not implemented"), vars0);
  return 0;
}

BOOL AMFDRDataMemoryCopyTrustObject(_QWORD *a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  CFTypeRef v5;

  v5 = AMFDRDataMemoryCopy(a1, (uint64_t)CFSTR("trustobject"), (uint64_t)CFSTR("current"), a4);
  if (v5)
    *a3 = v5;
  return v5 != 0;
}

unint64_t AMFDRDataMemoryPutTrustObject(_QWORD *a1, const void *a2, uint64_t a3, uint64_t a4, int a5)
{
  return AMFDRDataMemoryPutWithOptions(a1, (uint64_t)CFSTR("trustobject"), (uint64_t)CFSTR("current"), a2, a5, a3);
}

uint64_t AMFDRDataMemoryIterate(int a1, int a2, uint64_t a3)
{
  char vars0;

  AMFDRErrorPushInternal(a3, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryIterate", CFSTR("No implementation in AMFDRDataMemory module"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryMake(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMake", CFSTR("AMFDRDataMemoryMake is not implemented"), vars0);
  return 0;
}

CFTypeRef AMFDRDataMemoryMultiCopy(_QWORD *a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4)
{
  return _AMFDRDataMemoryMultiCopyInternal(a1, a2, a3, 0, a4);
}

uint64_t AMFDRDataMemoryMultiPutWithOptions(_QWORD *a1, CFArrayRef theArray, const __CFArray *a3, const __CFArray *a4, uint64_t a5, uint64_t a6)
{
  CFIndex Count;
  CFIndex v11;
  const __CFAllocator *v12;
  CFIndex v13;
  CFStringRef v14;
  const void *ValueAtIndex;
  uint64_t v16;
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  const __CFAllocator *v20;
  CFStringRef FullKey;
  int v22;
  const __CFString *format;
  const __CFString *v25;
  char v26;
  __CFDictionary *theDict;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
  {
    v25 = CFSTR("amfdr is NULL");
LABEL_43:
    AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiPutWithOptions", v25, v26);
    return 0;
  }
  if (!theArray)
  {
    v25 = CFSTR("dataClassArray is NULL");
    goto LABEL_43;
  }
  if (!a3)
  {
    v25 = CFSTR("dataInstanceArray is NULL");
    goto LABEL_43;
  }
  if (!a4)
  {
    v25 = CFSTR("valueDataArray is NULL");
    goto LABEL_43;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v25 = CFSTR("Invalid dataClassArray count");
    goto LABEL_43;
  }
  v11 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v25 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_43;
  }
  if (CFArrayGetCount(a4) != v11)
  {
    v25 = CFSTR("Invalid dataValueArray count");
    goto LABEL_43;
  }
  v12 = CFGetAllocator(a1);
  theDict = CFDictionaryCreateMutable(v12, v11, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!theDict)
  {
    AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiPutWithOptions", CFSTR("multiRequestErrors is NULL"), v26);
    return 0;
  }
  v13 = 0;
  v14 = 0;
  while (1)
  {
    if (v14)
      CFRelease(v14);
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v13);
    if (!ValueAtIndex)
    {
      format = CFSTR("dataClassStr is NULL");
LABEL_30:
      AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiPutWithOptions", format, v26);
      goto LABEL_33;
    }
    v16 = (uint64_t)ValueAtIndex;
    v17 = CFArrayGetValueAtIndex(a3, v13);
    if (!v17)
    {
      format = CFSTR("dataInstanceStr is NULL");
      goto LABEL_30;
    }
    v18 = (uint64_t)v17;
    v19 = (uint64_t)CFArrayGetValueAtIndex(a4, v13);
    if (!v19)
    {
      AMFDRErrorPushInternal(a6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiPutWithOptions", CFSTR("valueData is NULL"), v26);
      goto LABEL_25;
    }
    v20 = CFGetAllocator(a1);
    FullKey = AMFDRDataLocalCreateFullKey(v20, v16, v18);
    if (!FullKey)
      break;
    v14 = FullKey;
    if ((AMFDRDataMemoryPutWithOptions(a1, v16, v18, (const void *)v19, v22, a6) & 1) == 0)
    {
      AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiPutWithOptions", CFSTR("AMFDRDataMemoryPut failed"), v26);
      if (!cf)
      {
        AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiPutWithOptions", CFSTR("internalError is NULL"), v26);
        goto LABEL_35;
      }
      CFDictionaryAddValue(theDict, v14, cf);
    }
    if (v11 == ++v13)
    {
      if (!CFDictionaryGetCount(theDict))
      {
        v19 = 1;
LABEL_24:
        CFRelease(v14);
        goto LABEL_25;
      }
      AMFDRErrorPushInternal(a6, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiPutWithOptions", CFSTR("got multiRequestErrors"), v26);
LABEL_35:
      v19 = 0;
      goto LABEL_24;
    }
  }
  AMFDRErrorPushInternal(a6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiPutWithOptions", CFSTR("currDataInstance is NULL"), v26);
LABEL_33:
  v19 = 0;
LABEL_25:
  CFRelease(theDict);
  if (cf)
    CFRelease(cf);
  return v19;
}

uint64_t AMFDRDataMemoryMultiDelete(_QWORD *a1, CFArrayRef theArray, const __CFArray *a3, uint64_t a4)
{
  CFIndex Count;
  CFIndex v9;
  const __CFAllocator *v10;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *value;
  CFIndex v13;
  CFStringRef v14;
  const void *ValueAtIndex;
  uint64_t v16;
  const void *v17;
  uint64_t v18;
  const __CFAllocator *v19;
  CFStringRef FullKey;
  uint64_t v21;
  const __CFString *format;
  const __CFString *v24;
  char v25;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
  {
    v24 = CFSTR("amfdr is NULL");
LABEL_37:
    AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiDelete", v24, v25);
    return 0;
  }
  if (!theArray)
  {
    v24 = CFSTR("dataClassStr is NULL");
    goto LABEL_37;
  }
  if (!a3)
  {
    v24 = CFSTR("dataInstanceStr is NULL");
    goto LABEL_37;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    v24 = CFSTR("Invalid dataClassArray count");
    goto LABEL_37;
  }
  v9 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    v24 = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_37;
  }
  v10 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v10, v9, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiDelete", CFSTR("multiRequestErrors is NULL"), v25);
    return 0;
  }
  value = Mutable;
  v13 = 0;
  v14 = 0;
  while (1)
  {
    if (v14)
      CFRelease(v14);
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v13);
    if (!ValueAtIndex)
    {
      format = CFSTR("dataClassStr is NULL");
LABEL_27:
      AMFDRErrorPushInternal(a4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiDelete", format, v25);
      goto LABEL_29;
    }
    v16 = (uint64_t)ValueAtIndex;
    v17 = CFArrayGetValueAtIndex(a3, v13);
    if (!v17)
    {
      format = CFSTR("dataInstanceStr is NULL");
      goto LABEL_27;
    }
    v18 = (uint64_t)v17;
    v19 = CFGetAllocator(a1);
    FullKey = AMFDRDataLocalCreateFullKey(v19, v16, v18);
    if (!FullKey)
      break;
    v14 = FullKey;
    if ((AMFDRDataMemoryDelete(a1, v16, v18, a4) & 1) == 0)
    {
      AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiDelete", CFSTR("AMFDRDataMemoryDelete failed"), v25);
      if (!cf)
      {
        AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiDelete", CFSTR("internalError is NULL"), v25);
        goto LABEL_31;
      }
      CFDictionaryAddValue(value, v14, cf);
    }
    if (v9 == ++v13)
    {
      if (!CFDictionaryGetCount(value))
      {
        v21 = 1;
LABEL_21:
        CFRelease(v14);
        goto LABEL_22;
      }
      AMFDRErrorPushInternal(a4, 21, 0, 0, 0, 0, 0, 0, value, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiDelete", CFSTR("got multiRequestErrors"), v25);
LABEL_31:
      v21 = 0;
      goto LABEL_21;
    }
  }
  AMFDRErrorPushInternal(a4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiDelete", CFSTR("currDataInstance is NULL"), v25);
LABEL_29:
  v21 = 0;
LABEL_22:
  CFRelease(value);
  if (cf)
    CFRelease(cf);
  return v21;
}

uint64_t AMFDRDataMemoryMultiExport(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiExport", CFSTR("AMFDRDataLocalMultiExport is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryMultiMake(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiMake", CFSTR("AMFDRDataMemoryMultiMake is not implemented"), vars0);
  return 0;
}

void *AMFDRDataMemoryPopulate(_QWORD *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  const __CFData *v7;
  const __CFData *v8;
  const UInt8 *BytePtr;
  unsigned int Length;
  const __CFAllocator *v11;
  void *v12;
  char v14;
  unsigned int v15;
  const UInt8 *v16;
  int v17;
  uint64_t v18;

  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v7 = (const __CFData *)AMFDRDataMemoryCopy(a1, a2, a3, a5);
  if (v7)
  {
    v8 = v7;
    BytePtr = CFDataGetBytePtr(v7);
    Length = CFDataGetLength(v8);
    if (!AMFDRDecodeCombined((uint64_t)BytePtr, Length, &v18, &v17, &v16, &v15) && v16 && v15)
    {
      v11 = CFGetAllocator(a1);
      v12 = CFDataCreate(v11, v16, v15);
      if (!v12)
        AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryPopulate", CFSTR("Failed to create uncombined data"), v14);
    }
    else
    {
      v12 = (void *)CFRetain(v8);
    }
    CFRelease(v8);
  }
  else
  {
    AMFDRErrorPushInternal(a5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryPopulate", CFSTR("Failed to populate raw data"), v14);
    return 0;
  }
  return v12;
}

CFTypeRef AMFDRDataMemoryMultiPopulate(_QWORD *a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4, uint64_t a5)
{
  return _AMFDRDataMemoryMultiCopyInternal(a1, a2, a3, 1, a5);
}

uint64_t AMFDRDataMemoryMultiCopyDigest(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiCopyDigest", CFSTR("AMFDRDataMemoryMultiCopyDigest is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryCopyManifest(int a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  char vars0;

  AMFDRErrorPushInternal(a6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryCopyManifest", CFSTR("AMFDRDataMemoryCopyManifest is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryMultiCopyManifest(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiCopyManifest", CFSTR("AMFDRDataMemoryMultiCopyManifest is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryPatch(int a1, int a2, int a3, int a4, int a5, int a6, uint64_t a7)
{
  char vars0;

  AMFDRErrorPushInternal(a7, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryPatch", CFSTR("AMFDRDataMemoryPatch is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryMultiPatch(int a1, int a2, int a3, int a4, int a5, int a6, uint64_t a7)
{
  char vars0;

  AMFDRErrorPushInternal(a7, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiPatch", CFSTR("AMFDRDataMemoryMultiPatch is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryCommitPatch(int a1, int a2, int a3, int a4, int a5, int a6, uint64_t a7)
{
  char vars0;

  AMFDRErrorPushInternal(a7, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryCommitPatch", CFSTR("AMFDRDataMemoryCommitPatch is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryMultiCommitPatch(int a1, int a2, int a3, int a4, int a5, int a6, uint64_t a7)
{
  char vars0;

  AMFDRErrorPushInternal(a7, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiCommitPatch", CFSTR("AMFDRDataMemoryMultiCommitPatch is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryUpdateMetadataWithOptions(int a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  char vars0;

  AMFDRErrorPushInternal(a6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryUpdateMetadataWithOptions", CFSTR("AMFDRDataMemoryUpdateMetadataWithOptions is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryMultiUpdateMetadataWithOptions(int a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  char vars0;

  AMFDRErrorPushInternal(a6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiUpdateMetadataWithOptions", CFSTR("AMFDRDataMemoryMultiUpdateMetadataWithOptions is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryMultiCopyAsidMetadata(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryMultiCopyAsidMetadata", CFSTR("AMFDRDataMemoryMultiCopyAsidMetadata is not implemented"), vars0);
  return 0;
}

uint64_t AMFDRDataMemoryRevert(int a1, int a2, int a3, uint64_t a4)
{
  char vars0;

  AMFDRErrorPushInternal(a4, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRDataMemoryRevert", CFSTR("AMFDRDataMemoryRevert is not implemented"), vars0);
  return 0;
}

CFMutableDictionaryRef AMFDRDataMemoryGetStore(_QWORD *cf)
{
  CFMutableDictionaryRef result;
  const __CFAllocator *v3;

  if (!cf)
    goto LABEL_6;
  result = (CFMutableDictionaryRef)cf[10];
  if (result)
    return result;
  v3 = CFGetAllocator(cf);
  result = CFDictionaryCreateMutable(v3, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!result)
  {
LABEL_6:
    AMSupportLogInternal();
    return 0;
  }
  cf[10] = result;
  return result;
}

CFTypeRef _AMFDRDataMemoryMultiCopyInternal(_QWORD *a1, CFArrayRef theArray, const __CFArray *a3, int a4, uint64_t a5)
{
  CFIndex Count;
  CFIndex v11;
  const __CFAllocator *v12;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v14;
  const __CFAllocator *v15;
  CFIndex v16;
  CFStringRef v17;
  const void *ValueAtIndex;
  const void *v19;
  uint64_t v20;
  const __CFAllocator *v21;
  CFStringRef FullKey;
  int v23;
  void *v24;
  __CFDictionary *v25;
  CFStringRef v26;
  CFTypeRef v27;
  CFMutableDictionaryRef v28;
  CFTypeRef v29;
  const __CFString *format;
  char v32;
  uint64_t v33;
  CFMutableDictionaryRef theDict;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
  {
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("amfdr is NULL"), v32);
    return 0;
  }
  if (!theArray)
  {
    format = CFSTR("dataClassArray is NULL");
LABEL_52:
    AMFDRErrorPushInternal(a5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", format, v32);
    goto LABEL_54;
  }
  if (!a3)
  {
    format = CFSTR("dataInstanceArray is NULL");
    goto LABEL_52;
  }
  Count = CFArrayGetCount(theArray);
  if (Count <= 0)
  {
    format = CFSTR("Invalid dataClassArray count");
    goto LABEL_52;
  }
  v11 = Count;
  if (CFArrayGetCount(a3) != Count)
  {
    format = CFSTR("Invalid dataInstanceArray count");
    goto LABEL_52;
  }
  v12 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v12, v11, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (Mutable)
  {
    v14 = Mutable;
    v15 = CFGetAllocator(a1);
    theDict = CFDictionaryCreateMutable(v15, v11, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (theDict)
    {
      v33 = a5;
      v16 = 0;
      v17 = 0;
      ValueAtIndex = 0;
      while (1)
      {
        if (v17)
          CFRelease(v17);
        if (ValueAtIndex)
          CFRelease(ValueAtIndex);
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v16);
        if (!ValueAtIndex)
        {
          AMFDRErrorPushInternal(v33, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("dataClassStr is NULL"), v32);
          goto LABEL_44;
        }
        v19 = CFArrayGetValueAtIndex(a3, v16);
        if (!v19)
        {
          AMFDRErrorPushInternal(v33, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("dataInstanceStr is NULL"), v32);
          goto LABEL_43;
        }
        v20 = (uint64_t)v19;
        v21 = CFGetAllocator(a1);
        FullKey = AMFDRDataLocalCreateFullKey(v21, (uint64_t)ValueAtIndex, v20);
        if (!FullKey)
          break;
        v17 = FullKey;
        if (a4 == 1)
        {
          v24 = AMFDRDataMemoryPopulate(a1, (uint64_t)ValueAtIndex, v20, v23, (uint64_t)&cf);
        }
        else
        {
          if (a4)
          {
            AMFDRErrorPushInternal(v33, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("Unsupported multi local action: %d"), a4);
            goto LABEL_32;
          }
          v24 = (void *)AMFDRDataMemoryCopy(a1, (uint64_t)ValueAtIndex, v20, (uint64_t)&cf);
        }
        ValueAtIndex = v24;
        if (v24)
        {
          if (cf)
          {
            AMFDRErrorPushInternal(v33, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("internalError is not NULL"), v32);
            goto LABEL_33;
          }
          v25 = v14;
          v26 = v17;
          v27 = ValueAtIndex;
        }
        else
        {
          AMFDRErrorPushInternal((uint64_t)&cf, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("AMFDRDataMemoryCopy failed"), v32);
          v27 = cf;
          if (!cf)
          {
            AMFDRErrorPushInternal(v33, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("internalError is NULL"), v32);
LABEL_32:
            ValueAtIndex = 0;
LABEL_33:
            v29 = 0;
            v28 = theDict;
LABEL_34:
            CFRelease(v17);
            goto LABEL_35;
          }
          v25 = theDict;
          v26 = v17;
        }
        CFDictionaryAddValue(v25, v26, v27);
        if (v11 == ++v16)
        {
          v28 = theDict;
          if (CFDictionaryGetCount(theDict) >= 1)
            AMFDRErrorPushInternal(v33, 21, 0, 0, 0, 0, 0, 0, theDict, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("Previous AMFDRDataMemoryCopy got errors"), v32);
          v29 = CFRetain(v14);
          goto LABEL_34;
        }
      }
      AMFDRErrorPushInternal(v33, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("currDataInstance is NULL"), v32);
LABEL_43:
      ValueAtIndex = 0;
LABEL_44:
      v29 = 0;
      v28 = theDict;
LABEL_35:
      CFRelease(v28);
      CFRelease(v14);
      if (ValueAtIndex)
        CFRelease(ValueAtIndex);
      goto LABEL_37;
    }
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("errorDict is NULL"), v32);
    CFRelease(v14);
  }
  else
  {
    AMFDRErrorPushInternal(a5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"_AMFDRDataMemoryMultiCopyInternal", CFSTR("valueDataDict is NULL"), v32);
  }
LABEL_54:
  v29 = 0;
LABEL_37:
  if (cf)
    CFRelease(cf);
  return v29;
}

uint64_t AMFDRSysconfigGetTypeID()
{
  if (AMFDRSysconfigGetTypeID_onceToken != -1)
    dispatch_once(&AMFDRSysconfigGetTypeID_onceToken, &__block_literal_global_4);
  return AMFDRSysconfigGetTypeID__AMFDRSysconfigTypeID;
}

double _AMFDRSysconfigClassFinalize(_QWORD *a1)
{
  const void *v2;
  _QWORD *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  double result;

  if (a1)
  {
    v3 = a1 + 2;
    v2 = (const void *)a1[2];
    if (v2)
    {
      CFRelease(v2);
      *v3 = 0;
    }
    v4 = (const void *)a1[4];
    if (v4)
    {
      CFRelease(v4);
      a1[4] = 0;
    }
    v5 = (const void *)a1[5];
    if (v5)
    {
      CFRelease(v5);
      a1[5] = 0;
    }
    v6 = (const void *)a1[6];
    if (v6)
    {
      CFRelease(v6);
      a1[6] = 0;
    }
    v7 = (const void *)a1[7];
    if (v7)
      CFRelease(v7);
    result = 0.0;
    *((_OWORD *)v3 + 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *(_OWORD *)v3 = 0u;
  }
  return result;
}

uint64_t _AMFDRSysconfigEqual(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  CFTypeID v4;
  CFTypeID v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID((CFTypeRef)result);
    if (AMFDRSysconfigGetTypeID_onceToken != -1)
      dispatch_once(&AMFDRSysconfigGetTypeID_onceToken, &__block_literal_global_4);
    result = 0;
    if (a2)
    {
      if (v4 == AMFDRSysconfigGetTypeID__AMFDRSysconfigTypeID)
      {
        v5 = CFGetTypeID((CFTypeRef)a2);
        if (AMFDRSysconfigGetTypeID_onceToken != -1)
          dispatch_once(&AMFDRSysconfigGetTypeID_onceToken, &__block_literal_global_4);
        if (v5 != AMFDRSysconfigGetTypeID__AMFDRSysconfigTypeID || *(_DWORD *)(v3 + 24) != *(_DWORD *)(a2 + 24))
          return 0;
        v6 = *(const void **)(v3 + 16);
        v7 = *(const void **)(a2 + 16);
        if (v6)
        {
          if (!v7)
            return 0;
          result = CFEqual(v6, v7);
          if (!(_DWORD)result)
            return result;
        }
        else if (v7)
        {
          return 0;
        }
        v8 = *(const void **)(v3 + 32);
        v9 = *(const void **)(a2 + 32);
        if (v8)
        {
          if (!v9)
            return 0;
          result = CFEqual(v8, v9);
          if (!(_DWORD)result)
            return result;
        }
        else if (v9)
        {
          return 0;
        }
        v10 = *(const void **)(v3 + 40);
        v11 = *(const void **)(a2 + 40);
        if (v10)
        {
          if (!v11)
            return 0;
          result = CFEqual(v10, v11);
          if (!(_DWORD)result)
            return result;
        }
        else if (v11)
        {
          return 0;
        }
        v12 = *(const void **)(v3 + 48);
        v13 = *(const void **)(a2 + 48);
        if (v12)
        {
          if (!v13)
            return 0;
          result = CFEqual(v12, v13);
          if (!(_DWORD)result)
            return result;
        }
        else if (v13)
        {
          return 0;
        }
        v14 = *(const void **)(v3 + 56);
        v15 = *(const void **)(a2 + 56);
        if (v14)
        {
          if (v15 && CFEqual(v14, v15))
            return 1;
        }
        else if (!v15)
        {
          return 1;
        }
        return 0;
      }
    }
  }
  return result;
}

CFStringRef _AMFDRSysconfigCopyFormattingDescription(CFStringRef result)
{
  const __CFString *data;

  if (result)
  {
    data = CFSTR("NULL");
    if (result->data)
      data = (const __CFString *)result->data;
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("<Sysconfig '%@'>{version=0x%08x}"), data, LODWORD(result->length));
  }
  return result;
}

double AMFDRSysconfigCreate()
{
  uint64_t Instance;
  double result;

  if (AMFDRSysconfigGetTypeID_onceToken != -1)
    dispatch_once(&AMFDRSysconfigGetTypeID_onceToken, &__block_literal_global_4);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    result = 0.0;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_DWORD *)(Instance + 24) = 196611;
  }
  return result;
}

uint64_t AMFDRSysconfigCreateWithDataClass(uint64_t a1, const void *a2)
{
  uint64_t v3;
  uint64_t v4;

  AMFDRSysconfigCreate();
  v4 = v3;
  if (v3)
    AMFDRSysconfigSetDataClass(v3, a2);
  return v4;
}

void AMFDRSysconfigSetDataClass(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  CFTypeRef v5;
  const void *v6;

  if (a1)
  {
    if (cf)
    {
      v4 = CFGetTypeID(cf);
      if (v4 == CFStringGetTypeID())
      {
        v5 = CFRetain(cf);
        v6 = *(const void **)(a1 + 16);
        if (v6)
          CFRelease(v6);
        *(_QWORD *)(a1 + 16) = v5;
      }
    }
  }
}

CFTypeRef AMFDRSysconfigCreateCopy(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  const __CFString *v6;
  CFStringRef Copy;
  const __CFArray *v8;
  CFArrayRef v9;
  const __CFArray *v10;
  CFArrayRef v11;
  const __CFArray *v12;
  CFArrayRef v13;
  const __CFArray *v14;
  CFArrayRef v15;
  CFTypeRef v16;

  if (!a2)
    return 0;
  AMFDRSysconfigCreate();
  if (!v4)
    return 0;
  v5 = (_QWORD *)v4;
  *(_DWORD *)(v4 + 24) = *(_DWORD *)(a2 + 24);
  v6 = *(const __CFString **)(a2 + 16);
  if (v6)
  {
    Copy = CFStringCreateCopy(a1, v6);
    v5[2] = Copy;
    if (!Copy)
      goto LABEL_16;
  }
  v8 = *(const __CFArray **)(a2 + 32);
  if (v8)
  {
    v9 = CFArrayCreateCopy(a1, v8);
    v5[4] = v9;
    if (!v9)
      goto LABEL_16;
  }
  v10 = *(const __CFArray **)(a2 + 40);
  if (v10)
  {
    v11 = CFArrayCreateCopy(a1, v10);
    v5[5] = v11;
    if (!v11)
      goto LABEL_16;
  }
  if ((v12 = *(const __CFArray **)(a2 + 48)) != 0 && (v13 = CFArrayCreateCopy(a1, v12), (v5[6] = v13) == 0)
    || (v14 = *(const __CFArray **)(a2 + 56)) != 0 && (v15 = CFArrayCreateCopy(a1, v14), (v5[7] = v15) == 0))
  {
LABEL_16:
    v16 = 0;
  }
  else
  {
    v16 = CFRetain(v5);
  }
  CFRelease(v5);
  return v16;
}

uint64_t AMFDRSysconfigCreateFromData(const __CFAllocator *a1, CFDataRef theData, uint64_t a3)
{
  __CFArray *Mutable;
  __CFArray *v7;
  __CFArray *v8;
  __CFArray *v9;
  const UInt8 *BytePtr;
  unsigned int Length;
  uint64_t v12;
  CFStringRef v13;
  CFStringRef v14;
  CFStringRef v15;
  const void *v16;
  char v17;
  const void *v18;
  uint64_t v19;
  const void *v20;
  const void *v21;
  char i;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  const __CFString *v28;
  const __CFString *v29;
  char v30;
  uint64_t v31;
  int v32;
  unsigned int numBytes;
  const UInt8 *numBytes_4;
  char v35;
  unsigned int v36;
  const UInt8 *v37;
  _DWORD **v38;
  UInt8 bytes[12];

  *(_DWORD *)bytes = 0;
  v38 = 0;
  if (!theData)
  {
    v28 = CFSTR("data is NULL");
LABEL_54:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", v28, v30);
    Mutable = 0;
LABEL_56:
    v7 = 0;
LABEL_58:
    v8 = 0;
LABEL_59:
    v9 = 0;
    goto LABEL_65;
  }
  if (CFDataGetLength(theData) <= 0)
  {
    v28 = CFSTR("data is empty");
    goto LABEL_54;
  }
  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x24BDBD690]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("keys is NULL"), v30);
    goto LABEL_56;
  }
  v7 = CFArrayCreateMutable(a1, 0, MEMORY[0x24BDBD690]);
  if (!v7)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("values is NULL"), v30);
    goto LABEL_58;
  }
  v8 = CFArrayCreateMutable(a1, 0, MEMORY[0x24BDBD690]);
  if (!v8)
  {
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("metaKeys is NULL"), v30);
    goto LABEL_59;
  }
  v9 = CFArrayCreateMutable(a1, 0, MEMORY[0x24BDBD690]);
  if (v9)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    v12 = AMFDRDecodeIterateSysconfigBegin((uint64_t)BytePtr, Length, &v38, bytes);
    if (v12 || !v38)
    {
      AMFDRErrorPushInternal(a3, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("failed to decode sysconfig data: 0x%llx"), v12);
      goto LABEL_65;
    }
    v13 = CFStringCreateWithBytes(a1, bytes, 4, 0x8000100u, 0);
    if (v13)
    {
      v14 = v13;
      v31 = a3;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v32 = *v38[3];
      v18 = (const void *)*MEMORY[0x24BDBD268];
      while (1)
      {
        LODWORD(numBytes_4) = 0;
        LOBYTE(numBytes) = 0;
        v37 = 0;
        v36 = 0;
        v35 = 0;
        if (v15)
          CFRelease(v15);
        if (v16)
          CFRelease(v16);
        v19 = AMFDRDecodeIterateSysconfigPayloadNext((uint64_t)v38, &numBytes_4, &numBytes, &v37, &v36, &v35);
        if (v19 == 0x40000000000000)
          break;
        if (v19)
        {
          AMFDRErrorPushInternal(v31, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("failed to decode payload #%u: 0x%llx"), v17);
LABEL_70:
          v15 = 0;
          goto LABEL_75;
        }
        v15 = CFStringCreateWithBytes(a1, (const UInt8 *)&numBytes_4, 4, 0x8000100u, 0);
        if (!v15)
        {
          AMFDRErrorPushInternal(v31, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("payload key #%u is NULL"), v17);
LABEL_75:
          v26 = 0;
          goto LABEL_41;
        }
        CFArrayAppendValue(Mutable, v15);
        if ((_BYTE)numBytes)
        {
          CFArrayAppendValue(v7, v18);
          v16 = 0;
        }
        else
        {
          if (v35)
            v20 = CFStringCreateWithBytes(a1, v37, v36, 0x8000100u, 0);
          else
            v20 = CFDataCreate(a1, v37, v36);
          v16 = v20;
          if (!v20)
          {
            AMFDRErrorPushInternal(v31, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("payload value #%u is NULL"), v17);
            goto LABEL_75;
          }
          CFArrayAppendValue(v7, v20);
        }
        ++v17;
      }
      v15 = 0;
      v21 = 0;
      for (i = 0; ; ++i)
      {
        v37 = 0;
        v36 = 0;
        numBytes_4 = 0;
        numBytes = 0;
        v35 = 0;
        if (v15)
          CFRelease(v15);
        if (v21)
          CFRelease(v21);
        v23 = AMFDRDecodeIterateSysconfigMetadataNext((uint64_t)v38, &v37, &v36, &numBytes_4, &numBytes, &v35);
        if (v23 == 0x40000000000000)
          break;
        if (v23)
        {
          AMFDRErrorPushInternal(v31, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("failed to decode metadata #%u: 0x%llx"), i);
          goto LABEL_70;
        }
        v15 = CFStringCreateWithBytes(a1, v37, v36, 0x8000100u, 0);
        if (!v15)
        {
          AMFDRErrorPushInternal(v31, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("metadata key #%u is NULL"), i);
          goto LABEL_75;
        }
        CFArrayAppendValue(v8, v15);
        if (v35)
          v24 = CFStringCreateWithBytes(a1, numBytes_4, numBytes, 0x8000100u, 0);
        else
          v24 = CFDataCreate(a1, numBytes_4, numBytes);
        v21 = v24;
        if (!v24)
        {
          AMFDRErrorPushInternal(v31, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("metadata value #%u is NULL"), i);
          goto LABEL_75;
        }
        CFArrayAppendValue(v9, v24);
      }
      AMFDRSysconfigCreate();
      v26 = v25;
      if (v25)
      {
        *(_QWORD *)(v25 + 16) = CFRetain(v14);
        *(_DWORD *)(v26 + 24) = v32;
        *(_QWORD *)(v26 + 32) = CFRetain(Mutable);
        *(_QWORD *)(v26 + 40) = CFRetain(v7);
        *(_QWORD *)(v26 + 48) = CFRetain(v8);
        v15 = 0;
        *(_QWORD *)(v26 + 56) = CFRetain(v9);
      }
      else
      {
        AMFDRErrorPushInternal(v31, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", CFSTR("sysconfigRef is NULL"), v30);
        v15 = 0;
      }
LABEL_41:
      AMFDRDecodeIterateSysconfigDestroy((void **)&v38);
      CFRelease(v14);
      goto LABEL_42;
    }
    v29 = CFSTR("dataClass is NULL");
  }
  else
  {
    v29 = CFSTR("metaValues is NULL");
  }
  AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateFromData", v29, v30);
LABEL_65:
  AMFDRDecodeIterateSysconfigDestroy((void **)&v38);
  v15 = 0;
  v26 = 0;
  if (Mutable)
LABEL_42:
    CFRelease(Mutable);
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  if (v9)
    CFRelease(v9);
  if (v15)
    CFRelease(v15);
  return v26;
}

uint64_t AMFDRSysconfigGetDeletedMarker()
{
  return *MEMORY[0x24BDBD268];
}

CFDataRef AMFDRSysconfigCreateEncodedData(CFTypeRef cf, uint64_t a2)
{
  const __CFData *EncodedKey;
  const __CFData *v4;
  CFIndex Length;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  CFIndex v14;
  const void *ExternalRepresentation;
  const __CFData *v16;
  char *v17;
  const __CFString *ValueAtIndex;
  const __CFString *v19;
  const __CFString *v20;
  const __CFData *v21;
  __int128 *v22;
  CFTypeID v23;
  CFTypeID v24;
  size_t v25;
  void *v26;
  int v27;
  void **v28;
  void *v29;
  void *v30;
  int v31;
  void **v32;
  const __CFArray *v33;
  CFIndex v34;
  CFIndex v35;
  char *v36;
  char *v37;
  uint64_t v38;
  CFIndex v39;
  char *v40;
  const __CFString *v41;
  const __CFString *v42;
  const __CFString *v43;
  const __CFData *v44;
  CFTypeID v45;
  __int128 *v46;
  CFTypeID v47;
  size_t v48;
  void *v49;
  unint64_t v50;
  uint64_t v51;
  void *v52;
  void *v53;
  int v54;
  void *v55;
  void *v56;
  int v57;
  UInt8 *v58;
  int v59;
  CFDataRef v60;
  void **v61;
  const __CFString *format;
  const __CFString *v64;
  char v65;
  void *v66;
  const __CFData *cfa;
  void *v68;
  uint64_t v70;
  uint64_t v71;
  void **v72;
  const __CFAllocator *allocator;
  UInt8 bytes;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  char v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;
  _QWORD v85[4];
  __int128 v86;
  __int128 v87;
  __int128 v88;
  int v89;

  v88 = 0u;
  v87 = 0u;
  v86 = 0u;
  v84 = 0;
  v83 = 0u;
  v81 = 0u;
  v82 = 0u;
  v80 = 0;
  if (!cf)
  {
    format = CFSTR("sysconfig is NULL");
LABEL_123:
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", format, v65);
    return 0;
  }
  if (!*((_QWORD *)cf + 2))
  {
    format = CFSTR("dataClass is NULL");
    goto LABEL_123;
  }
  allocator = CFGetAllocator(cf);
  EncodedKey = AMFDRSysconfigCreateEncodedKey(allocator, *((CFStringRef *)cf + 2), a2);
  if (!EncodedKey)
  {
    AMFDRErrorPushInternal(a2, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to encode data class"), v65);
    return 0;
  }
  v4 = EncodedKey;
  v85[0] = CFDataGetBytePtr(EncodedKey);
  Length = CFDataGetLength(v4);
  v89 = *((_DWORD *)cf + 6);
  v85[1] = Length;
  v85[2] = &v89;
  v85[3] = 4;
  v6 = (const __CFArray *)*((_QWORD *)cf + 4);
  cfa = v4;
  if (v6 && *((_QWORD *)cf + 5))
  {
    Count = CFArrayGetCount(v6);
    if (Count != CFArrayGetCount(*((CFArrayRef *)cf + 5)))
    {
      AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("payload keys and values have different numbers"), v65);
LABEL_143:
      CFRelease(v4);
      return 0;
    }
    v8 = CFArrayGetCount(*((CFArrayRef *)cf + 4));
    v9 = v8;
    if (v8 >= 1)
    {
      v10 = (char *)malloc_type_calloc(1uLL, 16 * v8, 0x1010040FDD9F14CuLL);
      if (v10)
      {
        v11 = v10;
        v12 = (char *)malloc_type_calloc(1uLL, 24 * v9, 0x1000040D248FAB4uLL);
        v72 = (void **)v11;
        if (v12)
        {
          v13 = 0;
          v14 = 0;
          ExternalRepresentation = 0;
          v16 = 0;
          v68 = v12;
          v17 = v12 + 8;
          v70 = v9;
          while (1)
          {
            v78 = 0u;
            v79 = 0u;
            v76 = 0u;
            v77 = 0u;
            v75 = 0u;
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 4), v14);
            v19 = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 5), v14);
            if (!ValueAtIndex)
            {
              AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("payload key #%ld is NULL"), v14);
              goto LABEL_84;
            }
            v20 = v19;
            if (!v19)
            {
              AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("payload value #%ld is NULL"), v14);
              goto LABEL_84;
            }
            if (v16)
              CFRelease(v16);
            if (ExternalRepresentation)
              CFRelease(ExternalRepresentation);
            v21 = AMFDRSysconfigCreateEncodedKey(allocator, ValueAtIndex, a2);
            v16 = v21;
            if (!v21)
            {
              AMFDRErrorPushInternal(a2, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to encode payload key #%ld"), v14);
              goto LABEL_83;
            }
            *(_QWORD *)&v75 = CFDataGetBytePtr(v21);
            *((_QWORD *)&v75 + 1) = CFDataGetLength(v16);
            if (AMFDRSysconfigEntryIsDeleted((const __CFBoolean *)v20))
            {
              bytes = -1;
              ExternalRepresentation = CFDataCreate(allocator, &bytes, 1);
              v22 = &v79;
              if (!ExternalRepresentation)
                goto LABEL_110;
            }
            else
            {
              v23 = CFGetTypeID(v20);
              if (v23 == CFStringGetTypeID())
              {
                ExternalRepresentation = CFStringCreateExternalRepresentation(allocator, v20, 0x8000100u, 0x20u);
                v22 = &v78;
                if (!ExternalRepresentation)
                  goto LABEL_110;
              }
              else
              {
                v24 = CFGetTypeID(v20);
                if (v24 != CFDataGetTypeID())
                {
                  CFGetTypeID(v20);
                  AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("unknown payload value type at #%ld: %lu"), v14);
LABEL_83:
                  ExternalRepresentation = 0;
                  goto LABEL_84;
                }
                ExternalRepresentation = CFRetain(v20);
                v22 = &v77;
                if (!ExternalRepresentation)
                {
LABEL_110:
                  AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("payload valueData is NULL"), v65);
                  goto LABEL_113;
                }
              }
            }
            *(_QWORD *)v22 = CFDataGetBytePtr((CFDataRef)ExternalRepresentation);
            *((_QWORD *)v22 + 1) = CFDataGetLength((CFDataRef)ExternalRepresentation);
            *(_QWORD *)&v76 = ".";
            *((_QWORD *)&v76 + 1) = 1;
            v25 = DERLengthOfEncodedSequence(0x2000000000000010, (unint64_t)&v75, (unsigned __int16)DERNumSysconfigPayloadItemSpecs, (uint64_t)&DERSysconfigPayloadItemSpecs);
            v72[v13 + 1] = (void *)v25;
            v26 = malloc_type_calloc(1uLL, v25, 0x69DB007EuLL);
            v72[v13] = v26;
            if (!v26)
            {
              AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to allocate encoded payload data #%ld"), v14);
              goto LABEL_113;
            }
            if (DEREncodeSequence(0x2000000000000010, (unint64_t)&v75, (unsigned __int16)DERNumSysconfigPayloadItemSpecs, (uint64_t)&DERSysconfigPayloadItemSpecs, (unint64_t)v26, (unint64_t *)&v72[v13 + 1]))break;
            *((_QWORD *)v17 - 1) = v13 * 8;
            *(_QWORD *)v17 = 0x2000000000000010;
            *((_WORD *)v17 + 4) = 512;
            ++v14;
            v13 += 2;
            v17 += 24;
            v9 = v70;
            if (v70 == v14)
            {
              v27 = 1;
              v28 = v72;
              v29 = v68;
              goto LABEL_32;
            }
          }
          AMFDRErrorPushInternal(a2, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to encode payload #%ld: %d"), v14);
LABEL_113:
          v9 = v70;
LABEL_84:
          v58 = 0;
          v56 = 0;
          v53 = 0;
          v66 = 0;
          goto LABEL_85;
        }
        v66 = 0;
        v16 = 0;
        ExternalRepresentation = 0;
        v64 = CFSTR("topLevelSpec for payload is NULL");
        goto LABEL_148;
      }
      AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("encodedItems for payload is NULL"), v65);
      goto LABEL_143;
    }
    v27 = 0;
    v29 = 0;
    v28 = 0;
  }
  else
  {
    v27 = 0;
    v29 = 0;
    v28 = 0;
    v9 = 0;
  }
  v16 = 0;
  ExternalRepresentation = 0;
LABEL_32:
  *((_QWORD *)&v86 + 1) = DERLengthOfEncodedSequence(0x2000000000000011, (unint64_t)v28, (unsigned __int16)v9, (uint64_t)v29);
  v30 = malloc_type_calloc(1uLL, *((size_t *)&v86 + 1), 0xE0F61002uLL);
  v66 = v30;
  if (!v30)
  {
    v68 = v29;
    v72 = v28;
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("encodedPayload is NULL"), v65);
LABEL_128:
    v60 = 0;
    v53 = 0;
    goto LABEL_132;
  }
  *(_QWORD *)&v86 = v30;
  v31 = DEREncodeSequence(0x2000000000000011, (unint64_t)v28, (unsigned __int16)v9, (uint64_t)v29, (unint64_t)v30, (unint64_t *)&v86 + 1);
  if (v31)
  {
    v68 = v29;
    v72 = v28;
    AMFDRErrorPushInternal(a2, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to encode top-level payload set: %d"), v31);
    goto LABEL_128;
  }
  if (v28)
  {
    if (v27)
    {
      v32 = v28;
      do
      {
        if (*v32)
        {
          free(*v32);
          *v32 = 0;
        }
        v32 += 2;
        --v9;
      }
      while (v9);
    }
    free(v28);
  }
  if (v29)
    free(v29);
  v33 = (const __CFArray *)*((_QWORD *)cf + 6);
  if (!v33 || !*((_QWORD *)cf + 7))
  {
    v51 = 0;
    v50 = 0;
    v9 = 0;
LABEL_67:
    *((_QWORD *)&v87 + 1) = DERLengthOfEncodedSequence(0x2000000000000011, v50, (unsigned __int16)v9, v51);
    v52 = malloc_type_calloc(1uLL, *((size_t *)&v87 + 1), 0x30437997uLL);
    v53 = v52;
    v72 = (void **)v50;
    v68 = (void *)v51;
    if (v52)
    {
      *(_QWORD *)&v87 = v52;
      v54 = DEREncodeSequence(0x2000000000000011, v50, (unsigned __int16)v9, v51, (unint64_t)v52, (unint64_t *)&v87 + 1);
      if (!v54)
      {
        *(_QWORD *)&v81 = &v80;
        *((_QWORD *)&v81 + 1) = 1;
        *(_QWORD *)&v82 = &v80;
        *((_QWORD *)&v82 + 1) = 1;
        *(_QWORD *)&v83 = &v80;
        *((_QWORD *)&v83 + 1) = 1;
        *((_QWORD *)&v88 + 1) = DERLengthOfEncodedSequence(0x2000000000000010, (unint64_t)&v81, (unsigned __int16)DERNumSysconfigManifestItemSpecs, (uint64_t)&DERSysconfigManifestItemSpecs);
        v55 = malloc_type_calloc(1uLL, *((size_t *)&v88 + 1), 0x294F6391uLL);
        v56 = v55;
        if (v55)
        {
          *(_QWORD *)&v88 = v55;
          v57 = DEREncodeSequence(0x2000000000000010, (unint64_t)&v81, (unsigned __int16)DERNumSysconfigManifestItemSpecs, (uint64_t)&DERSysconfigManifestItemSpecs, (unint64_t)v55, (unint64_t *)&v88 + 1);
          if (!v57)
          {
            v84 = DERLengthOfEncodedSequence(0x2000000000000010, (unint64_t)v85, (unsigned __int16)DERNumSysconfigItemSpecs, (uint64_t)&DERSysconfigItemSpecs);
            v58 = (UInt8 *)malloc_type_calloc(1uLL, v84, 0xFD5E22A8uLL);
            if (v58)
            {
              v59 = DEREncodeSequence(0x2000000000000010, (unint64_t)v85, (unsigned __int16)DERNumSysconfigItemSpecs, (uint64_t)&DERSysconfigItemSpecs, (unint64_t)v58, (unint64_t *)&v84);
              if (!v59)
              {
                v60 = CFDataCreateWithBytesNoCopy(allocator, v58, v84, (CFAllocatorRef)*MEMORY[0x24BDBD248]);
                if (v60)
                {
LABEL_74:
                  v58 = 0;
                  goto LABEL_75;
                }
                AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("outData is NULL"), v65);
LABEL_75:
                if (!v72)
                {
LABEL_92:
                  if (v68)
                    free(v68);
                  goto LABEL_94;
                }
LABEL_86:
                if (v9 <= 0)
                {
LABEL_91:
                  free(v72);
                  goto LABEL_92;
                }
LABEL_87:
                v61 = v72;
                do
                {
                  if (*v61)
                  {
                    free(*v61);
                    *v61 = 0;
                  }
                  v61 += 2;
                  --v9;
                }
                while (v9);
                goto LABEL_91;
              }
              AMFDRErrorPushInternal(a2, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to encode sysconfig sequence: %d"), v59);
            }
            else
            {
              AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("encodedSysconfig is NULL"), v65);
            }
            v60 = 0;
            goto LABEL_75;
          }
          AMFDRErrorPushInternal(a2, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to encode sysconfig manifest: %d"), v57);
        }
        else
        {
          AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("encodedManifest is NULL"), v65);
        }
        v60 = 0;
        goto LABEL_74;
      }
      AMFDRErrorPushInternal(a2, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to encode top-level metadata set: %d"), v54);
    }
    else
    {
      AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("encodedMetadata is NULL"), v65);
    }
    v60 = 0;
LABEL_132:
    v56 = 0;
    goto LABEL_74;
  }
  v34 = CFArrayGetCount(v33);
  if (v34 != CFArrayGetCount(*((CFArrayRef *)cf + 7)))
  {
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("metadata keys and values have different numbers"), v65);
    goto LABEL_146;
  }
  v35 = CFArrayGetCount(*((CFArrayRef *)cf + 6));
  v9 = v35;
  if (v35 < 1)
  {
    v51 = 0;
    v50 = 0;
    goto LABEL_67;
  }
  v36 = (char *)malloc_type_calloc(1uLL, 16 * v35, 0x1010040FDD9F14CuLL);
  if (v36)
  {
    v72 = (void **)v36;
    v37 = (char *)malloc_type_calloc(1uLL, 24 * v9, 0x1000040D248FAB4uLL);
    if (v37)
    {
      v38 = 0;
      v39 = 0;
      v68 = v37;
      v40 = v37 + 8;
      v71 = v9;
      while (1)
      {
        v76 = 0u;
        v77 = 0u;
        v75 = 0u;
        v41 = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 6), v39);
        v42 = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 7), v39);
        if (!v41)
        {
          AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("metadata key #%ld is NULL"), v39);
          goto LABEL_81;
        }
        v43 = v42;
        if (!v42)
        {
          AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("metadata  value #%ld is NULL"), v39);
          goto LABEL_81;
        }
        if (v16)
          CFRelease(v16);
        if (ExternalRepresentation)
          CFRelease(ExternalRepresentation);
        v44 = CFStringCreateExternalRepresentation(allocator, v41, 0x8000100u, 0x20u);
        v16 = v44;
        if (!v44)
        {
          AMFDRErrorPushInternal(a2, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to encode metadata key #%ld"), v39);
          goto LABEL_80;
        }
        *(_QWORD *)&v75 = CFDataGetBytePtr(v44);
        *((_QWORD *)&v75 + 1) = CFDataGetLength(v16);
        v45 = CFGetTypeID(v43);
        if (v45 == CFStringGetTypeID())
        {
          ExternalRepresentation = CFStringCreateExternalRepresentation(allocator, v43, 0x8000100u, 0x20u);
          v46 = &v77;
          if (!ExternalRepresentation)
            goto LABEL_117;
        }
        else
        {
          v47 = CFGetTypeID(v43);
          if (v47 != CFDataGetTypeID())
          {
            CFGetTypeID(v43);
            AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("unknown metadata value type at #%ld: %lu"), v39);
LABEL_80:
            ExternalRepresentation = 0;
            goto LABEL_81;
          }
          ExternalRepresentation = CFRetain(v43);
          v46 = &v76;
          if (!ExternalRepresentation)
          {
LABEL_117:
            AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("metadata valueData is NULL"), v65);
            goto LABEL_120;
          }
        }
        *(_QWORD *)v46 = CFDataGetBytePtr((CFDataRef)ExternalRepresentation);
        *((_QWORD *)v46 + 1) = CFDataGetLength((CFDataRef)ExternalRepresentation);
        v48 = DERLengthOfEncodedSequence(0x2000000000000010, (unint64_t)&v75, (unsigned __int16)DERNumSysconfigMetadataItemSpecs, (uint64_t)&DERSysconfigMetadataItemSpecs);
        v72[v38 + 1] = (void *)v48;
        v49 = malloc_type_calloc(1uLL, v48, 0x38B6AB18uLL);
        v72[v38] = v49;
        if (!v49)
        {
          AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to allocate encoded metadata #%ld"), v39);
          goto LABEL_120;
        }
        if (DEREncodeSequence(0x2000000000000010, (unint64_t)&v75, (unsigned __int16)DERNumSysconfigMetadataItemSpecs, (uint64_t)&DERSysconfigMetadataItemSpecs, (unint64_t)v49, (unint64_t *)&v72[v38 + 1]))break;
        *((_QWORD *)v40 - 1) = v38 * 8;
        *(_QWORD *)v40 = 0x2000000000000010;
        *((_WORD *)v40 + 4) = 512;
        ++v39;
        v38 += 2;
        v40 += 24;
        v9 = v71;
        if (v71 == v39)
        {
          v50 = (unint64_t)v72;
          v51 = (uint64_t)v68;
          goto LABEL_67;
        }
      }
      AMFDRErrorPushInternal(a2, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("failed to encode metadata #%ld: %d"), v39);
LABEL_120:
      v9 = v71;
LABEL_81:
      v58 = 0;
      v56 = 0;
      v53 = 0;
LABEL_85:
      v60 = 0;
      goto LABEL_86;
    }
    v64 = CFSTR("topLevelSpec for metadata is NULL");
LABEL_148:
    AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", v64, v65);
    v60 = 0;
    v68 = 0;
    v53 = 0;
    v56 = 0;
    v58 = 0;
    goto LABEL_87;
  }
  AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedData", CFSTR("encodedItems for metadata is NULL"), v65);
LABEL_146:
  v60 = 0;
  v53 = 0;
  v56 = 0;
  v58 = 0;
LABEL_94:
  if (v66)
    free(v66);
  if (v53)
    free(v53);
  if (v56)
    free(v56);
  if (v58)
    free(v58);
  CFRelease(cfa);
  if (v16)
    CFRelease(v16);
  if (ExternalRepresentation)
    CFRelease(ExternalRepresentation);
  return v60;
}

CFDataRef AMFDRSysconfigCreateEncodedKey(const __CFAllocator *a1, CFStringRef theString, uint64_t a3)
{
  const __CFString *v7;
  char v8;
  UInt8 bytes[4];
  char buffer[4];
  char v11;

  v11 = 0;
  *(_DWORD *)buffer = 0;
  if (!theString)
  {
    v7 = CFSTR("key to encode is NULL");
LABEL_8:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedKey", v7, v8);
    return 0;
  }
  if (CFStringGetLength(theString) != 4)
  {
    v7 = CFSTR("invalid key length");
    goto LABEL_8;
  }
  if (!CFStringGetCString(theString, buffer, 5, 0x8000100u))
  {
    AMFDRErrorPushInternal(a3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCreateEncodedKey", CFSTR("failed to get cstring from key"), v8);
    return 0;
  }
  *(_DWORD *)bytes = bswap32(*(unsigned int *)buffer);
  return CFDataCreate(a1, bytes, 4);
}

const __CFBoolean *AMFDRSysconfigEntryIsDeleted(const __CFBoolean *result)
{
  const __CFBoolean *v1;
  CFTypeID v2;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFBooleanGetTypeID())
      return (const __CFBoolean *)(CFBooleanGetValue(v1) == 0);
    else
      return 0;
  }
  return result;
}

uint64_t AMFDRSysconfigGetDataClass(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

CFTypeRef AMFDRSysconfigCopyValues(CFArrayRef *a1, uint64_t a2)
{
  const __CFAllocator *v4;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v11;
  CFTypeRef v12;
  char v14;

  if (!a1)
  {
    AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCopyValues", CFSTR("sysconfig is NULL"), v14);
    return 0;
  }
  v4 = CFGetAllocator(a1);
  Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    AMFDRErrorPushInternal(a2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCopyValues", CFSTR("values is NULL"), v14);
    return 0;
  }
  v6 = Mutable;
  v7 = a1[4];
  if (v7 && a1[5])
  {
    Count = CFArrayGetCount(v7);
    if (Count != CFArrayGetCount(a1[5]))
    {
      AMFDRErrorPushInternal(a2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigCopyValues", CFSTR("invalid number of payload values"), v14);
      v12 = 0;
      goto LABEL_10;
    }
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1[4], i);
        v11 = CFArrayGetValueAtIndex(a1[5], i);
        CFDictionarySetValue(v6, ValueAtIndex, v11);
      }
    }
  }
  v12 = CFRetain(v6);
LABEL_10:
  CFRelease(v6);
  return v12;
}

BOOL AMFDRSysconfigSetValues(CFArrayRef *a1, const __CFDictionary *a2, uint64_t a3)
{
  const __CFAllocator *v6;
  CFIndex Count;
  void *v8;
  const void **v9;
  const void **v10;
  const CFArrayCallBacks *v11;
  __CFArray *Mutable;
  CFMutableArrayRef v13;
  CFMutableDictionaryRef v14;
  const __CFDictionary *v15;
  void *v16;
  const __CFArray *v17;
  CFIndex v18;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v21;
  BOOL v22;
  uint64_t v23;
  const void *v24;
  const void *v25;
  CFTypeID v26;
  uint64_t v27;
  uint64_t v28;
  CFIndex j;
  const void *v30;
  const void *Value;
  CFArrayRef v32;
  CFArrayRef v33;
  const __CFString *v35;
  const __CFString *v36;
  const __CFString *v37;
  char v38;
  uint64_t v39;
  __CFArray *v40;
  const void **v41;
  CFRange v42;

  if (!a1)
  {
    v36 = CFSTR("sysconfig is NULL");
LABEL_52:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetValues", v36, v38);
    return 0;
  }
  if (!a2)
  {
    v36 = CFSTR("valueDict is NULL");
    goto LABEL_52;
  }
  v6 = CFGetAllocator(a1);
  Count = CFDictionaryGetCount(a2);
  if (Count < 1)
  {
    v8 = 0;
    v10 = 0;
  }
  else
  {
    v8 = malloc_type_calloc(1uLL, 8 * Count, 0x6004044C4A2DFuLL);
    v9 = (const void **)malloc_type_calloc(1uLL, 8 * Count, 0xC0040B8AA526DuLL);
    v10 = v9;
    if (!v8)
    {
      AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetValues", CFSTR("keysToUpdate is NULL"), v38);
      v22 = 0;
      if (!v10)
        return v22;
      goto LABEL_44;
    }
    if (!v9)
    {
      AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetValues", CFSTR("valuesToUpdate is NULL"), v38);
      v22 = 0;
LABEL_42:
      free(v8);
      goto LABEL_43;
    }
    CFDictionaryGetKeysAndValues(a2, (const void **)v8, v9);
  }
  v11 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  Mutable = CFArrayCreateMutable(v6, 0, MEMORY[0x24BDBD690]);
  v13 = CFArrayCreateMutable(v6, 0, v11);
  v14 = CFDictionaryCreateMutable(v6, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v15 = v14;
  if (Mutable)
  {
    if (v13)
    {
      if (v14)
      {
        v40 = v13;
        v41 = v10;
        v16 = v8;
        v17 = a1[4];
        if (v17 && a1[5])
        {
          v18 = CFArrayGetCount(v17);
          if (v18 != CFArrayGetCount(a1[5]))
          {
            AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetValues", CFSTR("invalid number of payload values"), v38);
            v22 = 0;
LABEL_49:
            v13 = v40;
            v10 = v41;
            v8 = v16;
            goto LABEL_37;
          }
          if (v18 >= 1)
          {
            for (i = 0; i != v18; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(a1[4], i);
              v21 = CFArrayGetValueAtIndex(a1[5], i);
              if (!CFDictionaryContainsKey(v15, ValueAtIndex))
                CFArrayAppendValue(Mutable, ValueAtIndex);
              CFDictionarySetValue(v15, ValueAtIndex, v21);
            }
          }
        }
        if (Count >= 1)
        {
          v39 = a3;
          v22 = 0;
          v23 = 0;
          v8 = v16;
          while (1)
          {
            v24 = (const void *)*((_QWORD *)v8 + v23);
            if (!v24 || (v25 = v41[v23], v26 = CFGetTypeID(v24), v26 != CFStringGetTypeID()))
            {
              v35 = CFSTR("valueDict key is not a string");
              goto LABEL_48;
            }
            if (!v25)
              break;
            if (!CFDictionaryContainsKey(v15, v24))
              CFArrayAppendValue(Mutable, v24);
            CFDictionarySetValue(v15, v24, v25);
            v22 = ++v23 >= Count;
            v8 = v16;
            if (Count == v23)
              goto LABEL_29;
          }
          v35 = CFSTR("valueDict contains NULL value");
LABEL_48:
          AMFDRErrorPushInternal(v39, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetValues", v35, v38);
          goto LABEL_49;
        }
        v22 = 1;
        v8 = v16;
LABEL_29:
        v27 = CFArrayGetCount(Mutable);
        v13 = v40;
        if (v27 >= 1)
        {
          v28 = v27;
          v42.location = 0;
          v42.length = v27;
          CFArraySortValues(Mutable, v42, (CFComparatorFunction)MEMORY[0x24BDBC4D0], 0);
          for (j = 0; j != v28; ++j)
          {
            v30 = CFArrayGetValueAtIndex(Mutable, j);
            Value = CFDictionaryGetValue(v15, v30);
            CFArrayAppendValue(v40, Value);
          }
        }
        v32 = a1[4];
        if (v32)
        {
          CFRelease(v32);
          a1[4] = 0;
        }
        v33 = a1[5];
        v10 = v41;
        if (v33)
        {
          CFRelease(v33);
          a1[5] = 0;
        }
        a1[4] = (CFArrayRef)CFRetain(Mutable);
        a1[5] = (CFArrayRef)CFRetain(v40);
LABEL_37:
        CFRelease(Mutable);
        if (!v13)
          goto LABEL_39;
        goto LABEL_38;
      }
      v37 = CFSTR("allDict is NULL");
    }
    else
    {
      v37 = CFSTR("payloadValues is NULL");
    }
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetValues", v37, v38);
    v22 = 0;
    goto LABEL_37;
  }
  AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetValues", CFSTR("payloadKeys is NULL"), v38);
  v22 = 0;
  if (v13)
LABEL_38:
    CFRelease(v13);
LABEL_39:
  if (v15)
    CFRelease(v15);
  if (v8)
    goto LABEL_42;
LABEL_43:
  if (v10)
LABEL_44:
    free(v10);
  return v22;
}

BOOL AMFDRSysconfigSetMetaValues(CFArrayRef *a1, const __CFDictionary *a2, uint64_t a3)
{
  const __CFAllocator *v6;
  CFIndex Count;
  void *v8;
  const void **v9;
  const void **v10;
  const CFArrayCallBacks *v11;
  __CFArray *Mutable;
  CFMutableArrayRef v13;
  CFMutableDictionaryRef v14;
  const __CFDictionary *v15;
  void *v16;
  const __CFArray *v17;
  CFIndex v18;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v21;
  BOOL v22;
  uint64_t v23;
  const void *v24;
  const void *v25;
  CFTypeID v26;
  uint64_t v27;
  uint64_t v28;
  CFIndex j;
  const void *v30;
  const void *Value;
  CFArrayRef v32;
  CFArrayRef v33;
  const __CFString *v35;
  const __CFString *v36;
  const __CFString *v37;
  char v38;
  uint64_t v39;
  __CFArray *v40;
  const void **v41;
  CFRange v42;

  if (!a1)
  {
    v36 = CFSTR("sysconfig is NULL");
LABEL_52:
    AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetMetaValues", v36, v38);
    return 0;
  }
  if (!a2)
  {
    v36 = CFSTR("metaValueDict is NULL");
    goto LABEL_52;
  }
  v6 = CFGetAllocator(a1);
  Count = CFDictionaryGetCount(a2);
  if (Count < 1)
  {
    v8 = 0;
    v10 = 0;
  }
  else
  {
    v8 = malloc_type_calloc(1uLL, 8 * Count, 0x6004044C4A2DFuLL);
    v9 = (const void **)malloc_type_calloc(1uLL, 8 * Count, 0xC0040B8AA526DuLL);
    v10 = v9;
    if (!v8)
    {
      AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetMetaValues", CFSTR("metaKeysToUpdate is NULL"), v38);
      v22 = 0;
      if (!v10)
        return v22;
      goto LABEL_44;
    }
    if (!v9)
    {
      AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetMetaValues", CFSTR("metaValuesToUpdate is NULL"), v38);
      v22 = 0;
LABEL_42:
      free(v8);
      goto LABEL_43;
    }
    CFDictionaryGetKeysAndValues(a2, (const void **)v8, v9);
  }
  v11 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
  Mutable = CFArrayCreateMutable(v6, 0, MEMORY[0x24BDBD690]);
  v13 = CFArrayCreateMutable(v6, 0, v11);
  v14 = CFDictionaryCreateMutable(v6, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v15 = v14;
  if (Mutable)
  {
    if (v13)
    {
      if (v14)
      {
        v40 = v13;
        v41 = v10;
        v16 = v8;
        v17 = a1[6];
        if (v17 && a1[7])
        {
          v18 = CFArrayGetCount(v17);
          if (v18 != CFArrayGetCount(a1[7]))
          {
            AMFDRErrorPushInternal(a3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetMetaValues", CFSTR("invalid number of metadata values"), v38);
            v22 = 0;
LABEL_49:
            v13 = v40;
            v10 = v41;
            v8 = v16;
            goto LABEL_37;
          }
          if (v18 >= 1)
          {
            for (i = 0; i != v18; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(a1[6], i);
              v21 = CFArrayGetValueAtIndex(a1[7], i);
              if (!CFDictionaryContainsKey(v15, ValueAtIndex))
                CFArrayAppendValue(Mutable, ValueAtIndex);
              CFDictionarySetValue(v15, ValueAtIndex, v21);
            }
          }
        }
        if (Count >= 1)
        {
          v39 = a3;
          v22 = 0;
          v23 = 0;
          v8 = v16;
          while (1)
          {
            v24 = (const void *)*((_QWORD *)v8 + v23);
            if (!v24 || (v25 = v41[v23], v26 = CFGetTypeID(v24), v26 != CFStringGetTypeID()))
            {
              v35 = CFSTR("metaValueDict key is not a string");
              goto LABEL_48;
            }
            if (!v25)
              break;
            if (!CFDictionaryContainsKey(v15, v24))
              CFArrayAppendValue(Mutable, v24);
            CFDictionarySetValue(v15, v24, v25);
            v22 = ++v23 >= Count;
            v8 = v16;
            if (Count == v23)
              goto LABEL_29;
          }
          v35 = CFSTR("metaValueDict contains NULL value");
LABEL_48:
          AMFDRErrorPushInternal(v39, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetMetaValues", v35, v38);
          goto LABEL_49;
        }
        v22 = 1;
        v8 = v16;
LABEL_29:
        v27 = CFArrayGetCount(Mutable);
        v13 = v40;
        if (v27 >= 1)
        {
          v28 = v27;
          v42.location = 0;
          v42.length = v27;
          CFArraySortValues(Mutable, v42, (CFComparatorFunction)MEMORY[0x24BDBC4D0], 0);
          for (j = 0; j != v28; ++j)
          {
            v30 = CFArrayGetValueAtIndex(Mutable, j);
            Value = CFDictionaryGetValue(v15, v30);
            CFArrayAppendValue(v40, Value);
          }
        }
        v32 = a1[6];
        if (v32)
        {
          CFRelease(v32);
          a1[6] = 0;
        }
        v33 = a1[7];
        v10 = v41;
        if (v33)
        {
          CFRelease(v33);
          a1[7] = 0;
        }
        a1[6] = (CFArrayRef)CFRetain(Mutable);
        a1[7] = (CFArrayRef)CFRetain(v40);
LABEL_37:
        CFRelease(Mutable);
        if (!v13)
          goto LABEL_39;
        goto LABEL_38;
      }
      v37 = CFSTR("allDict is NULL");
    }
    else
    {
      v37 = CFSTR("metadataValues is NULL");
    }
    AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetMetaValues", v37, v38);
    v22 = 0;
    goto LABEL_37;
  }
  AMFDRErrorPushInternal(a3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)"AMFDRSysconfigSetMetaValues", CFSTR("metadataKeys is NULL"), v38);
  v22 = 0;
  if (v13)
LABEL_38:
    CFRelease(v13);
LABEL_39:
  if (v15)
    CFRelease(v15);
  if (v8)
    goto LABEL_42;
LABEL_43:
  if (v10)
LABEL_44:
    free(v10);
  return v22;
}

void AMFDRSysconfigRemoveAllValues(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  v2 = (const void *)a1[4];
  if (v2)
  {
    CFRelease(v2);
    a1[4] = 0;
  }
  v3 = (const void *)a1[5];
  if (v3)
  {
    CFRelease(v3);
    a1[5] = 0;
  }
  v4 = (const void *)a1[6];
  if (v4)
  {
    CFRelease(v4);
    a1[6] = 0;
  }
  v5 = (const void *)a1[7];
  if (v5)
  {
    CFRelease(v5);
    a1[7] = 0;
  }
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

uint64_t DERParseBitString(uint64_t result, unint64_t *a2, _BYTE *a3)
{
  unsigned int v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  unint64_t v10;

  *a3 = 0;
  *a2 = 0;
  a2[1] = 0;
  if (!*(_QWORD *)(result + 8))
    return 3;
  v3 = **(unsigned __int8 **)result;
  *a3 = v3;
  v4 = *(_QWORD *)(result + 8);
  if (v4 != 1)
  {
    if (v3 <= 7)
    {
      v5 = v4 - 1;
      if (!v4)
      {
LABEL_20:
        __break(0x5515u);
        goto LABEL_21;
      }
      v6 = *(_QWORD *)result;
      v7 = *(_QWORD *)result + v4;
      v8 = (unsigned __int8 *)(*(_QWORD *)result + v5);
      if ((unint64_t)v8 >= v7 || (unint64_t)v8 < v6)
      {
LABEL_19:
        __break(0x5519u);
        goto LABEL_20;
      }
      if (((0xFFu >> (8 - v3)) & *v8) == 0)
      {
        if (v6 == -1)
        {
LABEL_21:
          __break(0x5513u);
          return result;
        }
        v10 = v6 + 1;
        if (v6 + 1 <= v7 && v6 <= v10)
        {
          result = 0;
          *a2 = v10;
          a2[1] = v5;
          return result;
        }
        goto LABEL_19;
      }
    }
    return 3;
  }
  if (v3)
    return 3;
  else
    return 0;
}

uint64_t DERParseBooleanWithDefault(unsigned __int8 **a1, BOOL a2, BOOL *a3)
{
  unsigned __int8 *v3;
  int v4;
  uint64_t result;

  v3 = a1[1];
  if (!v3)
    goto LABEL_9;
  if (v3 == (unsigned __int8 *)1)
  {
    v4 = **a1;
    if (v4 == 255 || v4 == 0)
    {
      a2 = v4 != 0;
LABEL_9:
      result = 0;
      *a3 = a2;
      return result;
    }
  }
  return 3;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *result;
  v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t DEREncodeSequence(uint64_t result, unint64_t a2, unsigned int a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  if ((a2 | 0x7FFFFFFFFFFFFFFFLL) >= a2)
    return DEREncodeSequenceFromObject(result, a2, ~a2 & 0x7FFFFFFFFFFFFFFFLL, a3, a4, a5, *a6, a6);
  __break(0x5519u);
  return result;
}

BOOL DEROidCompare(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  size_t v4;

  result = 0;
  if (a1 && a2)
  {
    v4 = *(_QWORD *)(a1 + 8);
    return v4 == *(_QWORD *)(a2 + 8) && memcmp(*(const void **)a1, *(const void **)a2, v4) == 0;
  }
  return result;
}

void *aks_params_create(uint64_t a1)
{
  _QWORD *v2;
  void *v3;

  v2 = calloc(8uLL, 1uLL);
  v3 = v2;
  if (v2)
  {
    *v2 = 0;
    if (a1)
    {
      if (encode_list_merge_dict((uint64_t)v2))
      {
        memset_s(v3, 8uLL, 0, 8uLL);
        free(v3);
        return 0;
      }
    }
  }
  return v3;
}

void *_params_get_der_key(int a1, int a2)
{
  void **v2;
  void *result;
  void **v4;
  void *v5;
  BOOL v6;

  switch(a1)
  {
    case 1:
      v2 = (void **)&der_key_access_groups;
      goto LABEL_28;
    case 2:
      v2 = (void **)&der_key_external_data;
      goto LABEL_28;
    case 3:
      v2 = (void **)&der_key_acm_handle;
      goto LABEL_28;
    case 4:
      v2 = (void **)&der_key_salt;
      goto LABEL_28;
    case 5:
      v2 = (void **)&der_key_data;
      goto LABEL_28;
    case 6:
      v2 = (void **)&der_key_ecdh_seed;
      goto LABEL_28;
    case 7:
      v2 = (void **)&der_key_ecdh_iv;
      goto LABEL_28;
    case 8:
      v4 = (void **)&der_key_raw_output;
      goto LABEL_30;
    case 9:
      v4 = (void **)&der_key_options;
      goto LABEL_30;
    case 10:
      v2 = (void **)&der_key_shared_info;
      goto LABEL_28;
    case 11:
      v2 = (void **)&der_key_shared_info2;
      goto LABEL_28;
    case 12:
      v2 = (void **)&der_key_transcode_shared_info;
      goto LABEL_28;
    case 13:
      v2 = (void **)&der_key_transcode_shared_info2;
      goto LABEL_28;
    case 14:
      v2 = (void **)&der_key_transcode_ecdh_seed;
      goto LABEL_28;
    case 15:
      v2 = (void **)&der_key_persona_uuid;
      goto LABEL_28;
    case 16:
      v4 = (void **)&der_key_sub_key_type;
      goto LABEL_30;
    case 17:
      v2 = (void **)&der_key_system_key_client_seed;
      goto LABEL_28;
    case 18:
      v4 = (void **)&der_key_system_key_options;
      goto LABEL_30;
    case 19:
      v5 = der_key_system_key_no_img4;
      v6 = a2 == 3;
      goto LABEL_31;
    case 20:
      v4 = (void **)&der_key_remote_session_signing_key_type;
      goto LABEL_30;
    case 21:
      v2 = (void **)&der_key_remote_session_signing_key_certificate;
      goto LABEL_28;
    case 22:
      v4 = (void **)&der_key_gid_ref_key_options;
      goto LABEL_30;
    case 23:
      v4 = (void **)&der_key_pka_flags;
      goto LABEL_30;
    case 24:
      v2 = (void **)&der_key_volume_uuid;
      goto LABEL_28;
    case 25:
      v2 = (void **)&der_key_seed;
LABEL_28:
      v5 = *v2;
      v6 = a2 == 2;
      goto LABEL_31;
    case 26:
      v4 = (void **)&der_key_test_flags;
LABEL_30:
      v5 = *v4;
      v6 = a2 == 1;
LABEL_31:
      if (v6)
        result = v5;
      else
        result = 0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t aks_params_set_number(_QWORD *a1, int a2, uint64_t *a3)
{
  uint64_t v5;
  unsigned __int8 *der_key;
  uint64_t v7;

  v5 = 3758097090;
  der_key = (unsigned __int8 *)_params_get_der_key(a2, 1);
  if (der_key)
  {
    v7 = (uint64_t)der_key;
    if (!encode_list_remove_key(a1, der_key)
      && (!a3 || !encode_list_add_number(a1, v7, *a3)))
    {
      return 0;
    }
  }
  return v5;
}

uint64_t aks_ref_key_create(int a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5, void ***a6)
{
  uint64_t v11;
  void *v12;
  void **v13;
  void *v14;
  void **v15;
  uint64_t v16;
  char *v17;
  rsize_t v18;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  rsize_t v24;
  void *v25;
  size_t v26;

  v11 = 3758097090;
  v12 = der_key_op_create;
  v13 = (void **)calloc(8uLL, 1uLL);
  *v13 = 0;
  encode_list_add_key(v13, (uint64_t)der_key_op, (uint64_t)v12);
  v25 = 0;
  v26 = 0;
  v23 = 0;
  v24 = 0;
  if (!a6)
    goto LABEL_14;
  v14 = calloc(0x50uLL, 1uLL);
  v22 = v14;
  if (!v14)
  {
    v11 = 3758604298;
    goto LABEL_14;
  }
  v15 = (void **)v14;
  memset_s(v14, 0x50uLL, 0, 0x50uLL);
  if (a4 && encode_list_merge_dict((uint64_t)v13)
    || encode_list_add_number(v13, (uint64_t)der_key_keybag_class, a2)
    || encode_list_add_number(v13, (uint64_t)der_key_type, a3)
    || encode_list_dict(v13, &v25, &v26))
  {
LABEL_17:
    aks_ref_key_free((uint64_t *)&v22);
    goto LABEL_14;
  }
  v16 = _aks_operation();
  if ((_DWORD)v16)
  {
    v11 = v16;
    goto LABEL_17;
  }
  v17 = (char *)v23;
  v18 = v24;
  *v15 = v23;
  v15[1] = (void *)v18;
  *((_DWORD *)v15 + 10) = a1;
  v15[2] = &v17[v18];
  v20 = 0;
  v21 = 0;
  if (der_dict_find_value((uint64_t)der_key_ref_key, &v20, &v21))
    v15[4] = v20;
  if (der_dict_find_value((uint64_t)der_key_external_data, &v20, &v21))
    v15[3] = v20;
  v11 = 0;
  *a6 = v15;
  v23 = 0;
  v24 = 0;
LABEL_14:
  encode_list_free(v13);
  memset_s(v13, 8uLL, 0, 8uLL);
  free(v13);
  memset_s(v25, v26, 0, v26);
  free(v25);
  memset_s(v23, v24, 0, v24);
  free(v23);
  return v11;
}

uint64_t aks_ref_key_free(uint64_t *a1)
{
  uint64_t v1;
  void *v2;
  void *v3;

  v1 = *a1;
  if (!*a1)
    return 3758097090;
  *a1 = 0;
  if (*(_QWORD *)v1)
  {
    memset_s(*(void **)v1, *(_QWORD *)(v1 + 8), 0, *(_QWORD *)(v1 + 8));
    free(*(void **)v1);
  }
  v2 = *(void **)(v1 + 48);
  if (v2)
  {
    memset_s(v2, *(_QWORD *)(v1 + 56), 0, *(_QWORD *)(v1 + 56));
    free(*(void **)(v1 + 48));
  }
  v3 = *(void **)(v1 + 64);
  if (v3)
  {
    memset_s(v3, *(_QWORD *)(v1 + 72), 0, *(_QWORD *)(v1 + 72));
    free(*(void **)(v1 + 64));
  }
  memset_s((void *)v1, 0x50uLL, 0, 0x50uLL);
  free((void *)v1);
  return 0;
}

uint64_t aks_ref_key_get_public_key(_QWORD *a1, _QWORD *a2)
{
  int type;
  uint64_t v5;
  uint64_t v7;
  size_t v8;
  size_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v17 = 0;
  v16 = 0;
  if (!a1[4])
    return 0;
  v14 = 0;
  v15 = 0;
  if (der_dict_find_value((uint64_t)der_key_public_key, &v14, &v15))
  {
    *(_QWORD *)&v13 = v14;
    *((_QWORD *)&v13 + 1) = v14 + v15;
    der_utils_decode_implicit_raw_octet_string(&v13, 4, &v17, &v16);
  }
  type = aks_ref_key_get_type((uint64_t)a1);
  if ((type - 7) < 2)
  {
    v5 = MEMORY[0x212BA0EDC]();
    goto LABEL_9;
  }
  if ((type - 4) <= 1)
  {
    v5 = MEMORY[0x212BA0ED0]();
LABEL_9:
    if (v5)
    {
      v7 = firebloom_cp_prime_bitlen(v5);
      if (v17 == (unint64_t)(v7 + 7) >> 3)
      {
        if (v16 && !a1[8])
        {
          MEMORY[0x24BDAC7A8]();
          bzero((char *)&v12 - v8, v8);
          ccec_compact_import_pub();
          v9 = (2 * firebloom_cp_prime_size()) | 1;
          v10 = calloc(v9, 1uLL);
          a1[8] = v10;
          a1[9] = v9;
          if (v10)
            ccec_export_pub();
          cc_clear();
        }
        v11 = a1[9];
        v16 = a1[8];
        v17 = v11;
      }
    }
  }
  *a2 = v17;
  return v16;
}

uint64_t aks_ref_key_get_blob(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;

  result = *a1;
  *a2 = a1[1];
  return result;
}

uint64_t aks_sik_attest(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _op_attest(a1, (uint64_t)der_key_op_sik_attest, a2, a3, a4, a5);
}

uint64_t _op_attest(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  void **v12;
  void *__s;
  rsize_t __n;

  v11 = 3758097090;
  v12 = (void **)calloc(8uLL, 1uLL);
  *v12 = 0;
  encode_list_add_key(v12, (uint64_t)der_key_op, a2);
  __s = 0;
  __n = 0;
  if (a1)
  {
    if (a5)
    {
      if (a6)
      {
        if (!_get_merged_params((uint64_t)a1, v12, a3))
        {
          encode_list_remove_key(v12, (unsigned __int8 *)der_key_ref_key);
          if (!encode_list_add_der(v12, (uint64_t)der_key_ref_key, *a1, a1[2])
            && !encode_list_dict(v12, &__s, &__n))
          {
            v11 = _aks_operation();
          }
        }
      }
    }
  }
  encode_list_free(v12);
  memset_s(v12, 8uLL, 0, 8uLL);
  free(v12);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v11;
}

uint64_t aks_system_key_get_public(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v11;
  void *v12;
  void **v13;
  void *__s;
  rsize_t __n;

  v11 = 3758097090;
  v12 = der_key_op_system_key_get_public;
  v13 = (void **)calloc(8uLL, 1uLL);
  *v13 = 0;
  encode_list_add_key(v13, (uint64_t)der_key_op, (uint64_t)v12);
  __s = 0;
  __n = 0;
  if ((!a3 || !encode_list_merge_dict((uint64_t)v13))
    && !encode_list_add_number(v13, (uint64_t)der_key_system_key_type, a1)
    && !encode_list_add_number(v13, (uint64_t)der_key_system_key_generation, a2)
    && !encode_list_dict(v13, &__s, &__n))
  {
    v11 = _aks_operation();
    if (!(_DWORD)v11)
    {
      *a5 = 0;
      *a6 = 0;
    }
  }
  encode_list_free(v13);
  memset_s(v13, 8uLL, 0, 8uLL);
  free(v13);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v11;
}

dispatch_queue_t __get_aks_client_dispatch_queue_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("aks-client-queue", 0);
  get_aks_client_dispatch_queue_connection_queue = (uint64_t)result;
  return result;
}

uint64_t aks_fdr_hmac_data()
{
  uint64_t v0;
  _DWORD *v1;
  _DWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  int v5;
  int v6;
  const void *v7;
  uint64_t v8;
  mach_port_t aks_client_connection;
  uint64_t v10;
  void *v11;
  size_t __count;
  _BYTE __src[32768];
  uint64_t v15;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v7 = (const void *)v0;
  v15 = *MEMORY[0x24BDAC8D0];
  v8 = 3758097090;
  bzero(__src, 0x8000uLL);
  __count = 0x8000;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v7 && v4 && v2)
    {
      v10 = IOConnectCallMethod(aks_client_connection, 0x29u, 0, 0, v7, v6, 0, 0, __src, &__count);
      if ((_DWORD)v10)
      {
        v8 = v10;
      }
      else
      {
        v11 = calloc(__count, 1uLL);
        *v4 = v11;
        if (v11)
        {
          memcpy(v11, __src, __count);
          v8 = 0;
          *v2 = __count;
        }
        else
        {
          v8 = 3758097085;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fdr_hmac_data", ":", 1758, "", 0, "", "");
    v8 = 3758097084;
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  return v8;
}

unint64_t firebloom_cp_prime_size()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

double der_utils_decode_implicit_raw_octet_string(__int128 *a1, uint64_t a2, _DWORD *a3, _QWORD *a4)
{
  double result;
  __int128 v8;

  v8 = *a1;
  if (ccder_blob_decode_range())
  {
    *a4 = 0;
    *a3 = 0;
    result = *(double *)&v8;
    *a1 = v8;
  }
  return result;
}

uint64_t encode_list_add_number(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  size_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  int v16;
  char *v17;
  int v18;
  char *v19;
  BOOL v20;
  _QWORD *v21;
  _QWORD *v22;
  char *v23;
  char *v24;
  _QWORD v25[2];

  v3 = a3;
  v25[1] = *MEMORY[0x24BDAC8D0];
  v5 = HIBYTE(a3);
  if ((HIBYTE(a3) + 1) > 1u)
  {
    v10 = 8;
  }
  else
  {
    v6 = 9;
    v7 = 48;
    v8 = 1;
    while ((unint64_t)(v6 - 2) >= 2)
    {
      v9 = a3 >> v7;
      --v6;
      v7 -= 8;
      if ((_DWORD)v5 != v9)
      {
        v8 = v6 - 1;
        goto LABEL_8;
      }
    }
    v6 = 2;
LABEL_8:
    if ((((a3 >> (8 * v8 - 8)) ^ v5) & 0x80) != 0)
      v10 = v6;
    else
      v10 = v8;
  }
  v25[0] = 0;
  result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    ccder_sizeof();
    v12 = ccder_sizeof();
    v13 = (char *)calloc(v12, 1uLL);
    if (v13)
    {
      v14 = v13;
      v15 = v10;
      do
      {
        *((_BYTE *)v25 + v15 - 1) = v3;
        v3 >>= 8;
        --v15;
      }
      while (v15);
      v23 = &v13[v12];
      if ((ccder_blob_encode_body() & 1) == 0 || !ccder_blob_encode_tl())
        goto LABEL_30;
      v16 = ccder_blob_encode_body();
      v17 = v23;
      if (!v16)
        v17 = 0;
      v24 = v17;
      v18 = ccder_blob_encode_tl();
      v19 = v24;
      if (!v18)
        v19 = 0;
      v20 = v19 && v19 == v14;
      if (v20 && (v21 = calloc(0x18uLL, 1uLL)) != 0)
      {
        v22 = v21;
        result = 0;
        v22[1] = v14;
        v22[2] = v12;
        *v22 = *a1;
        *a1 = v22;
      }
      else
      {
LABEL_30:
        memset_s(v14, v12, 0, v12);
        free(v14);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t _qsort_compare(const void **a1, void **a2)
{
  int v2;
  void *__s2;
  const void *v5;

  v5 = *a1;
  __s2 = *a2;
  if (!ccder_blob_decode_sequence_tl()
    || !ccder_blob_decode_sequence_tl()
    || !ccder_blob_decode_tag()
    || !ccder_blob_decode_len()
    || !v5
    || !ccder_blob_decode_tag()
    || !ccder_blob_decode_len()
    || !__s2)
  {
    return 4294967293;
  }
  v2 = memcmp(v5, __s2, 0);
  if (v2 > 0)
    return 1;
  else
    return ((v2 < 0) << 31 >> 31);
}

void _AMFDRDeviceRefKeyClassFinalize_cold_1()
{
  __assert_rtn("_AMFDRDeviceRefKeyClassFinalize", "AMFDRDeviceKey.c", 392, "type != NULL");
}

void _AMFDRDeviceRefKeyCopyFormattingDescription_cold_1()
{
  __assert_rtn("_AMFDRDeviceRefKeyCopyFormattingDescription", "AMFDRDeviceKey.c", 422, "type != NULL");
}

void _AMFDRFinalize_cold_1()
{
  __assert_rtn("_AMFDRFinalize", "AMFDRCreate.c", 232, "type != NULL");
}

void _AMFDRCopyFormattingDescription_cold_1()
{
  __assert_rtn("_AMFDRCopyFormattingDescription", "AMFDRCreate.c", 267, "type != NULL");
}

void AMFDRSealingMapCallMGCopyAnswerInternal_cold_1()
{
  uint64_t v0;

  dlerror();
  v0 = abort_report_np();
  _AMFDRSealedDataFinalize_cold_1(v0);
}

void _AMFDRSealedDataFinalize_cold_1()
{
  __assert_rtn("_AMFDRSealedDataFinalize", "AMFDRSealedData.c", 46, "type != NULL");
}

void _AMFDRSealedDataCopyFormattingDescription_cold_1()
{
  __assert_rtn("_AMFDRSealedDataCopyFormattingDescription", "AMFDRSealedData.c", 96, "type != NULL");
}

uint64_t AMSupportBase64Decode()
{
  return MEMORY[0x24BED9F38]();
}

uint64_t AMSupportBase64Encode()
{
  return MEMORY[0x24BED9F40]();
}

uint64_t AMSupportCFDictionarySetInteger64()
{
  return MEMORY[0x24BED9F60]();
}

uint64_t AMSupportCopyDataFromHexString()
{
  return MEMORY[0x24BED9F70]();
}

uint64_t AMSupportCopyHexStringFromData()
{
  return MEMORY[0x24BED9F78]();
}

uint64_t AMSupportCopyHexStringFromUInt32()
{
  return MEMORY[0x24BED9F80]();
}

uint64_t AMSupportCopyHexStringFromUInt64()
{
  return MEMORY[0x24BED9F88]();
}

uint64_t AMSupportCopyPreserveFileURL()
{
  return MEMORY[0x24BED9F90]();
}

uint64_t AMSupportCopyURLWithAppendedComponent()
{
  return MEMORY[0x24BED9F98]();
}

uint64_t AMSupportCreateCStringFromCFString()
{
  return MEMORY[0x24BED9FA0]();
}

uint64_t AMSupportCreateDataFromFileURL()
{
  return MEMORY[0x24BED9FA8]();
}

uint64_t AMSupportCreateDictionaryFromFileURL()
{
  return MEMORY[0x24BED9FB0]();
}

uint64_t AMSupportCreateRandomNumber()
{
  return MEMORY[0x24BED9FD0]();
}

uint64_t AMSupportCreateURLFromString()
{
  return MEMORY[0x24BED9FD8]();
}

uint64_t AMSupportDigestMd5()
{
  return MEMORY[0x24BED9FE0]();
}

uint64_t AMSupportDigestSha1()
{
  return MEMORY[0x24BED9FE8]();
}

uint64_t AMSupportDigestSha256()
{
  return MEMORY[0x24BED9FF0]();
}

uint64_t AMSupportDigestSha384()
{
  return MEMORY[0x24BED9FF8]();
}

uint64_t AMSupportEcDsaCreateSignatureSha256()
{
  return MEMORY[0x24BEDA000]();
}

uint64_t AMSupportEcDsaCreateSignatureSha384()
{
  return MEMORY[0x24BEDA008]();
}

uint64_t AMSupportEcDsaVerifySignature()
{
  return MEMORY[0x24BEDA018]();
}

uint64_t AMSupportFileURLExists()
{
  return MEMORY[0x24BEDA020]();
}

uint64_t AMSupportHttpSendSync()
{
  return MEMORY[0x24BEDA040]();
}

uint64_t AMSupportHttpUriEscapeString()
{
  return MEMORY[0x24BEDA048]();
}

uint64_t AMSupportLogDumpMemory()
{
  return MEMORY[0x24BEDA050]();
}

uint64_t AMSupportLogInternal()
{
  return MEMORY[0x24BEDA060]();
}

uint64_t AMSupportLogSetHandler()
{
  return MEMORY[0x24BEDA068]();
}

uint64_t AMSupportMakeDirectory()
{
  return MEMORY[0x24BEDA070]();
}

uint64_t AMSupportPlatformWriteDataToFileURL()
{
  return MEMORY[0x24BEDA088]();
}

uint64_t AMSupportPlatformWriteDataToFileURLUncached()
{
  return MEMORY[0x24BEDA090]();
}

uint64_t AMSupportRemoveFile()
{
  return MEMORY[0x24BEDA098]();
}

uint64_t AMSupportRsaCreateDataFromPem()
{
  return MEMORY[0x24BEDA0A0]();
}

uint64_t AMSupportRsaCreatePemFromData()
{
  return MEMORY[0x24BEDA0A8]();
}

uint64_t AMSupportRsaCreatePrivateKeyFromPEMBuffer()
{
  return MEMORY[0x24BEDA0B0]();
}

uint64_t AMSupportRsaCreatePublicKeyFromPrivateKeyPEMBuffer()
{
  return MEMORY[0x24BEDA0B8]();
}

uint64_t AMSupportRsaVerifySignatureSha1()
{
  return MEMORY[0x24BEDA0C0]();
}

uint64_t AMSupportRsaVerifySignatureSha256()
{
  return MEMORY[0x24BEDA0C8]();
}

uint64_t AMSupportRsaVerifySignatureSha384()
{
  return MEMORY[0x24BEDA0D0]();
}

uint64_t AMSupportSafeFree()
{
  return MEMORY[0x24BEDA0D8]();
}

uint64_t AMSupportSafeRelease()
{
  return MEMORY[0x24BEDA0E0]();
}

uint64_t AMSupportSafeRetain()
{
  return MEMORY[0x24BEDA0E8]();
}

uint64_t AMSupportWriteDataToFileURL()
{
  return MEMORY[0x24BEDA0F0]();
}

uint64_t AMSupportWriteDictionarytoFileURL()
{
  return MEMORY[0x24BEDA0F8]();
}

uint64_t AMSupportX509CreateDerCertFromPEM()
{
  return MEMORY[0x24BEDA100]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x24BDBB780]();
  return result;
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  MEMORY[0x24BDBB7C0](theArray, otherArray, otherRange.location, otherRange.length);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x24BDBB7C8](theArray, value);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x24BDBB7E8](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x24BDBB7F0](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x24BDBB7F8](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x24BDBB808](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x24BDBB810](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x24BDBB820](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x24BDBB838](theArray, range.location, range.length, value);
}

CFIndex CFArrayGetLastIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x24BDBB840](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x24BDBB850]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x24BDBB860](theArray, idx);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x24BDBB870](theArray, idx, value);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x24BDBB880](theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x24BDBB898](theArray, idx, value);
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  MEMORY[0x24BDBB8A0](theArray, range.location, range.length, comparator, context);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x24BDBBA18]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  MEMORY[0x24BDBBC88](theData, bytes, length);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x24BDBBC98](allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x24BDBBCB0](allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return (CFMutableDataRef)MEMORY[0x24BDBBCB8](allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x24BDBBCC0](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x24BDBBCE0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x24BDBBCF8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x24BDBBD08]();
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x24BDBBD40](allocator, locale, dateStyle, timeStyle);
}

CFDateRef CFDateFormatterCreateDateFromString(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep)
{
  return (CFDateRef)MEMORY[0x24BDBBD50](allocator, formatter, string, rangep);
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  return (CFStringRef)MEMORY[0x24BDBBD68](allocator, formatter, date);
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
  MEMORY[0x24BDBBD88](formatter, formatString);
}

void CFDateFormatterSetProperty(CFDateFormatterRef formatter, CFStringRef key, CFTypeRef value)
{
  MEMORY[0x24BDBBD90](formatter, key, value);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBDB0](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x24BDBBDB8](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x24BDBBDC0](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBDD8](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBDE0](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x24BDBBE00](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x24BDBBE10](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x24BDBBE18]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x24BDBBE48](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x24BDBBE68](cf1, cf2);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBE80](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x24BDBBE88](allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x24BDBBE98](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x24BDBBEA0](err);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x24BDBBEE0](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFDictionaryRef CFHTTPMessageCopyAllHeaderFields(CFHTTPMessageRef message)
{
  return (CFDictionaryRef)MEMORY[0x24BDB72A0](message);
}

CFDataRef CFHTTPMessageCopyBody(CFHTTPMessageRef message)
{
  return (CFDataRef)MEMORY[0x24BDB72A8](message);
}

CFURLRef CFHTTPMessageCopyRequestURL(CFHTTPMessageRef request)
{
  return (CFURLRef)MEMORY[0x24BDB72C0](request);
}

CFHTTPMessageRef CFHTTPMessageCreateRequest(CFAllocatorRef alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion)
{
  return (CFHTTPMessageRef)MEMORY[0x24BDB72D8](alloc, requestMethod, url, httpVersion);
}

CFTypeID CFHTTPMessageGetTypeID(void)
{
  return MEMORY[0x24BDB72F0]();
}

void CFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData)
{
  MEMORY[0x24BDB7308](message, bodyData);
}

void CFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef value)
{
  MEMORY[0x24BDB7310](message, headerField, value);
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x24BDBBF48](allocator, localeIdentifier);
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x24BDBC090]();
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x24BDBC098](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x24BDBC0A0](allocator, theType, valuePtr);
}

CFIndex CFNumberGetByteSize(CFNumberRef number)
{
  return MEMORY[0x24BDBC108](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x24BDBC118]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x24BDBC130](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x24BDBC138](number);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x24BDBC1C0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x24BDBC1E8](allocator, data, options, format, error);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x24BDBC4A8](theString, appendedString);
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
  MEMORY[0x24BDBC4B8](theString, chars, numChars);
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  MEMORY[0x24BDBC4C0](theString, formatOptions, format);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x24BDBC4D0](theString1, theString2, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x24BDBC510](alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x24BDBC518](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x24BDBC520](alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return (CFDataRef)MEMORY[0x24BDBC528](alloc, theString, *(_QWORD *)&encoding, lossByte);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x24BDBC530](alloc, data, *(_QWORD *)&encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x24BDBC538](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x24BDBC540](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x24BDBC558](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x24BDBC568](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x24BDBC598](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x24BDBC5A0](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x24BDBC5B0](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
  MEMORY[0x24BDBC5B8](theString, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x24BDBC5D0](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x24BDBC5D8](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x24BDBC5E8](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC600](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x24BDBC618](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  MEMORY[0x24BDBC620](theString, range.location, range.length, buffer);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x24BDBC650](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x24BDBC658](theString);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x24BDBC698]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x24BDBC6A8](theString, prefix);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x24BDBC6C8](theString, locale);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
  MEMORY[0x24BDBC740](theString);
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  return (CFTimeZoneRef)MEMORY[0x24BDBC770](allocator, ti);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x24BDBC7A8](url);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x24BDBC7B8](anURL);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x24BDBC7F8](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x24BDBC828](allocator, buffer, bufLen, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x24BDBC858](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x24BDBC868](allocator, URLString, baseURL);
}

CFURLEnumeratorRef CFURLEnumeratorCreateForDirectoryURL(CFAllocatorRef alloc, CFURLRef directoryURL, CFURLEnumeratorOptions option, CFArrayRef propertyKeys)
{
  return (CFURLEnumeratorRef)MEMORY[0x24BDBC870](alloc, directoryURL, option, propertyKeys);
}

CFURLEnumeratorResult CFURLEnumeratorGetNextURL(CFURLEnumeratorRef enumerator, CFURLRef *url, CFErrorRef *error)
{
  return MEMORY[0x24BDBC878](enumerator, url, error);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x24BDBC8A8](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x24BDBC8B0]();
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x24BDBC8D0](alloc);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x24BDBC8E8](alloc, uuid);
}

uint64_t DEREncoderAddBoolean()
{
  return MEMORY[0x24BEDA108]();
}

uint64_t DEREncoderAddData()
{
  return MEMORY[0x24BEDA110]();
}

uint64_t DEREncoderAddDataFromEncoder()
{
  return MEMORY[0x24BEDA118]();
}

uint64_t DEREncoderAddDataNoCopy()
{
  return MEMORY[0x24BEDA128]();
}

uint64_t DEREncoderAddSequenceFromEncoder()
{
  return MEMORY[0x24BEDA138]();
}

uint64_t DEREncoderAddSetFromEncoder()
{
  return MEMORY[0x24BEDA140]();
}

uint64_t DEREncoderAddUInt32()
{
  return MEMORY[0x24BEDA148]();
}

uint64_t DEREncoderCreate()
{
  return MEMORY[0x24BEDA158]();
}

uint64_t DEREncoderCreateEncodedBuffer()
{
  return MEMORY[0x24BEDA160]();
}

uint64_t DEREncoderDestroy()
{
  return MEMORY[0x24BEDA168]();
}

uint64_t DERImg4DecodeContentFindItemWithTag()
{
  return MEMORY[0x24BEDA170]();
}

uint64_t DERImg4DecodeFindProperty()
{
  return MEMORY[0x24BEDA178]();
}

uint64_t DERImg4DecodeFindPropertyInSequence()
{
  return MEMORY[0x24BEDA180]();
}

uint64_t DERImg4DecodeManifest()
{
  return MEMORY[0x24BEDA188]();
}

uint64_t DERImg4DecodeProperty()
{
  return MEMORY[0x24BEDA190]();
}

uint64_t DERImg4DecodePropertyWithItem()
{
  return MEMORY[0x24BEDA198]();
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return MEMORY[0x24BDD7EF8](*(_QWORD *)&connection, *(_QWORD *)&selector, input, *(_QWORD *)&inputCnt, inputStruct, inputStructCnt, output, outputCnt);
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return MEMORY[0x24BDD7F08](*(_QWORD *)&connection, *(_QWORD *)&selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x24BDD86F8](*(_QWORD *)&object);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x24BDD88B0](*(_QWORD *)&entry, key, allocator, *(_QWORD *)&options);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return MEMORY[0x24BDD88C0](*(_QWORD *)&mainPort, path);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x24BDD8970](*(_QWORD *)&connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x24BDD8988](*(_QWORD *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDD89A8](name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return MEMORY[0x24BDD89B8](*(_QWORD *)&service, *(_QWORD *)&owningTask, *(_QWORD *)&type, connect);
}

uint64_t Img4DecodeEvaluateDictionaryProperties()
{
  return MEMORY[0x24BEDA1A0]();
}

uint64_t Img4DecodeGetBooleanFromSection()
{
  return MEMORY[0x24BEDA1B8]();
}

uint64_t Img4DecodeGetManifest()
{
  return MEMORY[0x24BEDA1C0]();
}

uint64_t Img4DecodeGetObjectPropertyData()
{
  return MEMORY[0x24BEDA1C8]();
}

uint64_t Img4DecodeGetObjectPropertyInteger64()
{
  return MEMORY[0x24BEDA1D0]();
}

uint64_t Img4DecodeGetPayload()
{
  return MEMORY[0x24BEDA1D8]();
}

uint64_t Img4DecodeGetPayloadType()
{
  return MEMORY[0x24BEDA1E0]();
}

uint64_t Img4DecodeGetPropertyBoolean()
{
  return MEMORY[0x24BEDA1E8]();
}

uint64_t Img4DecodeGetPropertyData()
{
  return MEMORY[0x24BEDA1F0]();
}

uint64_t Img4DecodeGetPropertyInteger64()
{
  return MEMORY[0x24BEDA1F8]();
}

uint64_t Img4DecodeInit()
{
  return MEMORY[0x24BEDA200]();
}

uint64_t Img4DecodeInitManifest()
{
  return MEMORY[0x24BEDA208]();
}

uint64_t Img4DecodePerformManifestTrustEvaluationWithCallbacks()
{
  return MEMORY[0x24BEDA210]();
}

uint64_t Img4DecodePerformTrustEvaluation()
{
  return MEMORY[0x24BEDA220]();
}

uint64_t Img4DecodePerformTrustEvaluationWithCallbacks()
{
  return MEMORY[0x24BEDA228]();
}

uint64_t Img4EncodeCreateManifest()
{
  return MEMORY[0x24BEDA230]();
}

uint64_t Img4EncodeCreatePayload()
{
  return MEMORY[0x24BEDA238]();
}

uint64_t Img4EncodeItemBegin()
{
  return MEMORY[0x24BEDA240]();
}

uint64_t Img4EncodeItemCopyBuffer()
{
  return MEMORY[0x24BEDA248]();
}

uint64_t Img4EncodeItemDestroy()
{
  return MEMORY[0x24BEDA250]();
}

uint64_t Img4EncodeItemEnd()
{
  return MEMORY[0x24BEDA258]();
}

uint64_t Img4EncodeItemPropertyBool()
{
  return MEMORY[0x24BEDA260]();
}

uint64_t Img4EncodeItemPropertyData()
{
  return MEMORY[0x24BEDA268]();
}

uint64_t Img4EncodeItemPropertyInt64()
{
  return MEMORY[0x24BEDA278]();
}

uint64_t Img4EncodeStitchManifest()
{
  return MEMORY[0x24BEDA280]();
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x24BED8448]();
}

uint64_t MGCopyAnswerWithError()
{
  return MEMORY[0x24BED8450]();
}

uint64_t RPCopyProxyDictionaryWithOptions()
{
  return MEMORY[0x24BED8C78]();
}

uint64_t RPRegisterForAvailability()
{
  return MEMORY[0x24BED8C88]();
}

uint64_t RPRegistrationInvalidate()
{
  return MEMORY[0x24BED8C98]();
}

uint64_t RPRegistrationResume()
{
  return MEMORY[0x24BED8CA8]();
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x24BDE8D48](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x24BDE8D70](allocator);
}

uint64_t ZhuGeCopyValue()
{
  return MEMORY[0x24BE06038]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

uint64_t _CFGetProgname()
{
  return MEMORY[0x24BDBCFF0]();
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x24BDBD0A8]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x24BDBD0B0]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x24BEAE670]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x24BDAD010]();
}

uint32_t arc4random(void)
{
  return MEMORY[0x24BDAD158]();
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x24BDAD328](__count, __size);
}

uint64_t cc_clear()
{
  return MEMORY[0x24BDAD348]();
}

uint64_t ccder_blob_decode_len()
{
  return MEMORY[0x24BDAD408]();
}

uint64_t ccder_blob_decode_range()
{
  return MEMORY[0x24BDAD418]();
}

uint64_t ccder_blob_decode_sequence_tl()
{
  return MEMORY[0x24BDAD420]();
}

uint64_t ccder_blob_decode_tag()
{
  return MEMORY[0x24BDAD428]();
}

uint64_t ccder_blob_decode_tl()
{
  return MEMORY[0x24BDAD430]();
}

uint64_t ccder_blob_encode_body()
{
  return MEMORY[0x24BDAD440]();
}

uint64_t ccder_blob_encode_tl()
{
  return MEMORY[0x24BDAD460]();
}

uint64_t ccder_decode_tl()
{
  return MEMORY[0x24BDAD490]();
}

uint64_t ccder_sizeof()
{
  return MEMORY[0x24BDAD4E0]();
}

uint64_t ccdigest()
{
  return MEMORY[0x24BDAD538]();
}

uint64_t ccec_compact_import_pub()
{
  return MEMORY[0x24BDAD560]();
}

uint64_t ccec_cp_256()
{
  return MEMORY[0x24BDAD590]();
}

uint64_t ccec_cp_384()
{
  return MEMORY[0x24BDAD598]();
}

uint64_t ccec_export_pub()
{
  return MEMORY[0x24BDAD5B0]();
}

uint64_t ccmd5_di()
{
  return MEMORY[0x24BDAD710]();
}

uint64_t ccrng()
{
  return MEMORY[0x24BDAD758]();
}

uint64_t ccrsa_ctx_public()
{
  return MEMORY[0x24BDAD770]();
}

uint64_t ccrsa_export_priv()
{
  return MEMORY[0x24BDAD788]();
}

uint64_t ccrsa_export_priv_size()
{
  return MEMORY[0x24BDAD790]();
}

uint64_t ccrsa_export_pub()
{
  return MEMORY[0x24BDAD798]();
}

uint64_t ccrsa_export_pub_size()
{
  return MEMORY[0x24BDAD7A0]();
}

uint64_t ccrsa_generate_key()
{
  return MEMORY[0x24BDAD7B0]();
}

uint64_t ccrsa_generate_key_deterministic()
{
  return MEMORY[0x24BDAD7B8]();
}

uint64_t ccrsa_import_priv()
{
  return MEMORY[0x24BDAD7C0]();
}

uint64_t ccrsa_import_priv_n()
{
  return MEMORY[0x24BDAD7C8]();
}

uint64_t ccrsa_sign_pkcs1v15()
{
  return MEMORY[0x24BDAD7E8]();
}

uint64_t ccsha1_di()
{
  return MEMORY[0x24BDAD818]();
}

uint64_t ccsha256_di()
{
  return MEMORY[0x24BDAD828]();
}

uint64_t ccsha384_di()
{
  return MEMORY[0x24BDAD838]();
}

uint64_t cczp_bitlen()
{
  return MEMORY[0x24BDAD928]();
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x24BDADF10](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x24BDADF28](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x24BDADF30](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADF38](dsema, timeout);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x24BDADFF0](queue, context, work);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x24BDADFF8](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x24BDAE068]();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x24BDAE088](__handle, __symbol);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE428](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

void freeifaddrs(ifaddrs *a1)
{
  MEMORY[0x24BDAE468](a1);
}

int getifaddrs(ifaddrs **a1)
{
  return MEMORY[0x24BDAE660](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x24BDAE6D0]();
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return (passwd *)MEMORY[0x24BDAE720](*(_QWORD *)&a1);
}

uid_t getuid(void)
{
  return MEMORY[0x24BDAE788]();
}

void if_freenameindex(if_nameindex *a1)
{
  MEMORY[0x24BDAE848](a1);
}

if_nameindex *if_nameindex(void)
{
  return (if_nameindex *)MEMORY[0x24BDAE858]();
}

unsigned int if_nametoindex(const char *a1)
{
  return MEMORY[0x24BDAE860](a1);
}

uint64_t lookupPathForPersistentData()
{
  return MEMORY[0x24BE63548]();
}

uint64_t lookupPathForPersonalizedData()
{
  return MEMORY[0x24BE63558]();
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x24BDAED80](memptr, alignment, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return MEMORY[0x24BDAEEC8](__s, __smax, *(_QWORD *)&__c, __n);
}

uint64_t os_variant_is_recovery()
{
  return MEMORY[0x24BDAF4F0]();
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x24BDAF910](a1, a2);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x24BDAFA18](__base, __nel, __width, __compar);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x24BDAFA80](*(_QWORD *)&a1, a2, a3);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return MEMORY[0x24BDAFCE8](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x24BDAFE38](*(_QWORD *)&a1);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x24BDAFF68](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x24BDAFF70](__dst, __src, __n);
}

char *__cdecl strtok_r(char *__str, const char *__sep, char **__lasts)
{
  return (char *)MEMORY[0x24BDAFFF8](__str, __sep, __lasts);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0030](__str, __endptr, *(_QWORD *)&__base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x24BDB00F8](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

void syslog(int a1, const char *a2, ...)
{
  MEMORY[0x24BDB0128](*(_QWORD *)&a1, a2);
}

