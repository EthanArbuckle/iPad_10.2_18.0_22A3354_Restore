uint64_t sub_18BC0EFCC(uint64_t a1)
{
  unsigned int *v1;

  v1 = *(unsigned int **)(a1 + 16);
  if (v1)
    return *v1;
  else
    return 0;
}

uint64_t sub_18BC0EFE4(uint64_t a1, unsigned __int8 *a2, _DWORD *a3)
{
  _DWORD *v3;
  unsigned __int8 **v4;
  int v5;
  unsigned __int8 *v6;
  int v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v13;
  int v14;
  int v16;
  unsigned __int8 *v17;
  int v18;
  unsigned __int8 *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  BOOL v24;
  int v25;
  int v26;
  int v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  BOOL v35;

  v3 = *(_DWORD **)(a1 + 16);
  if (!v3)
    return *(_QWORD *)(a1 + 8);
  v4 = (unsigned __int8 **)(v3 + 2);
  v5 = *v3;
  if (*v3)
  {
    v6 = *v4;
    v7 = -1;
    v8 = a2;
    do
    {
      v10 = *v8++;
      v9 = v10;
      v12 = *v6++;
      v11 = v12;
      ++v7;
      if (v9)
        v13 = v9 == v11;
      else
        v13 = 0;
    }
    while (v13);
    if (v9 == v11)
    {
      v14 = 0;
LABEL_19:
      *a3 = -1;
      return sub_18BC35558(*(_QWORD *)&v3[4 * v14 + 4]);
    }
    v16 = v5 - 1;
    v17 = v4[2 * v5 - 2];
    v18 = -1;
    v19 = a2;
    do
    {
      v21 = *v19++;
      v20 = v21;
      v23 = *v17++;
      v22 = v23;
      ++v18;
      if (v20)
        v24 = v20 == v22;
      else
        v24 = 0;
    }
    while (v24);
    if (v20 == v22)
    {
      v14 = v5 - 1;
LABEL_18:
      if ((v14 & 0x80000000) == 0)
        goto LABEL_19;
    }
    else if (v5 >= 3)
    {
      v25 = 1;
      do
      {
        v26 = v25 + v16;
        if (v25 + v16 < 0 != __OFADD__(v25, v16))
          ++v26;
        v14 = v26 >> 1;
        if (v7 >= v18)
          v27 = v18;
        else
          v27 = v7;
        v28 = &a2[v27];
        v29 = &v4[2 * v14][v27];
        v30 = v27 - 1;
        do
        {
          v32 = *v28++;
          v31 = v32;
          v34 = *v29++;
          v33 = v34;
          ++v30;
          if (v31)
            v35 = v31 == v33;
          else
            v35 = 0;
        }
        while (v35);
        if (v31 >= v33)
        {
          if (v31 == v33)
            goto LABEL_18;
          v25 = v14 + 1;
          v7 = v30;
        }
        else
        {
          v18 = v30;
          v16 = v14;
        }
      }
      while (v25 < v16);
    }
  }
  return 0;
}

uint64_t sub_18BC0F100(uint64_t a1)
{
  unsigned int *v1;

  v1 = *(unsigned int **)(a1 + 16);
  if (v1)
    return *v1;
  else
    return 0;
}

_OWORD *ucnv_open(unsigned __int8 *a1, UErrorCode *a2)
{
  if (a2 && *(int *)a2 <= 0)
    return ucnv_createConverter(0, a1, a2);
  else
    return 0;
}

_OWORD *ucnv_openU(UChar *s, UErrorCode *a2)
{
  _OWORD *result;
  unsigned __int8 *v5;
  _OWORD v6[4];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (!a2 || *(int *)a2 > 0)
    return 0;
  if (!s)
    return ucnv_createConverter(0, 0, a2);
  if (u_strlen(s) >= 60)
  {
    result = 0;
    *a2 = U_ILLEGAL_ARGUMENT_ERROR;
    return result;
  }
  memset(v6, 0, 60);
  v5 = (unsigned __int8 *)u_austrcpy((char *)v6, s);
  if (*(int *)a2 <= 0)
    return ucnv_createConverter(0, v5, a2);
  else
    return 0;
}

_OWORD *ucnv_openCCSID(unsigned int a1, int a2, UErrorCode *a3)
{
  uint64_t v5;
  _OWORD v6[4];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (!a3 || *(int *)a3 > 0)
    return 0;
  memset(v6, 0, 60);
  if (a2)
  {
    v5 = 0;
  }
  else
  {
    strcpy((char *)v6, "ibm-");
    v5 = 4;
  }
  T_CString_integerToString((_BYTE *)((unint64_t)v6 | v5), a1, 0xAu);
  return ucnv_createConverter(0, (unsigned __int8 *)v6, a3);
}

uint64_t ucnv_safeClone(void (**a1)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD), uint64_t a2, int *a3, int *a4)
{
  uint64_t v5;
  int *v8;
  void (*v10)(_QWORD, _QWORD, _QWORD, _QWORD);
  int v11;
  int v12;
  unint64_t v13;
  size_t v14;
  uint64_t v15;
  BOOL v16;
  int v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _OWORD *v21;
  __int128 *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t (*v26)(_QWORD, _QWORD, _QWORD, _QWORD);
  _QWORD *v27;
  uint64_t v28;
  _OWORD v29[3];
  uint64_t v30;
  _OWORD v31[3];
  uint64_t v32;
  int v33;
  int v34;
  int v35;

  v32 = 0;
  memset(v31, 0, sizeof(v31));
  LOWORD(v31[0]) = 56;
  BYTE2(v31[0]) = 1;
  v30 = 0;
  memset(v29, 0, sizeof(v29));
  LOWORD(v29[0]) = 56;
  BYTE2(v29[0]) = 1;
  if (!a4 || *a4 > 0)
    return 0;
  if (!a1)
  {
    v5 = 0;
    v12 = 1;
LABEL_12:
    *a4 = v12;
    return v5;
  }
  v8 = a3;
  v10 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*((_QWORD *)a1[6] + 4) + 112);
  if (v10)
  {
    v34 = 0;
    v10(a1, 0, &v34, a4);
    v5 = 0;
    if (*a4 >= 1)
      return v5;
    if (v8)
      goto LABEL_9;
LABEL_14:
    v11 = 1;
    v35 = 1;
    v8 = &v35;
    goto LABEL_15;
  }
  v34 = 288;
  if (!a3)
    goto LABEL_14;
LABEL_9:
  v11 = *v8;
  v35 = v11;
  if (v11 <= 0)
  {
    v5 = 0;
    *v8 = v34;
    return v5;
  }
LABEL_15:
  if (a2)
  {
    v13 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
    v14 = v34;
    v15 = v13 - a2 + v34;
    v16 = v15 <= v11;
    if (v15 > v11)
      v17 = 1;
    else
      v17 = v11 - (v13 - a2);
    if (v16)
      v18 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
    else
      v18 = a2;
    v35 = v17;
    if (v17 >= v34 && v18)
    {
      v19 = 0;
      v5 = v18;
      goto LABEL_30;
    }
  }
  else
  {
    v18 = 0;
    v14 = v34;
  }
  v20 = uprv_malloc(v14);
  v5 = (uint64_t)v20;
  if (!v20)
  {
    v12 = 7;
    goto LABEL_12;
  }
  if (v8 != &v35)
    *a4 = -126;
  v14 = v34;
  *v8 = v34;
  v19 = v20;
LABEL_30:
  bzero((void *)v5, v14);
  memcpy((void *)v5, a1, 0x120uLL);
  *(_WORD *)(v5 + 61) = 0;
  if ((char *)a1[5] == (char *)(a1 + 17))
  {
    *(_QWORD *)(v5 + 40) = v5 + 136;
  }
  else
  {
    v21 = uprv_malloc(0x40uLL);
    *(_QWORD *)(v5 + 40) = v21;
    if (!v21)
    {
LABEL_40:
      uprv_free(v19);
      return 0;
    }
    v22 = (__int128 *)a1[5];
    v23 = v22[3];
    v25 = *v22;
    v24 = v22[1];
    v21[2] = v22[2];
    v21[3] = v23;
    *v21 = v25;
    v21[1] = v24;
  }
  v26 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*((_QWORD *)a1[6] + 4) + 112);
  if (v26 && (v5 = v26(a1, v5, v8, a4)) == 0 || *a4 >= 1)
  {
    if (v19)
    {
      v27 = (_QWORD *)v19[5];
      if (v27 != v19 + 17)
        uprv_free(v27);
    }
    goto LABEL_40;
  }
  v28 = (uint64_t)a1[6];
  if (*(_BYTE *)(v28 + 25))
    sub_18BC15C24(v28);
  if (v5 == v18)
    *(_BYTE *)(v18 + 61) = 1;
  *((_QWORD *)&v29[0] + 1) = v5;
  *((_QWORD *)&v31[0] + 1) = v5;
  v33 = 0;
  ((void (*)(_QWORD, _OWORD *, _QWORD, _QWORD, uint64_t, _DWORD *))a1[1])(a1[4], v31, 0, 0, 5, &v33);
  v33 = 0;
  (*a1)(a1[3], v29, 0, 0, 0, 5, &v33);
  return v5;
}

uint64_t ucnv_clone(void (**a1)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD), int *a2)
{
  return ucnv_safeClone(a1, 0, 0, a2);
}

void ucnv_close(_QWORD *a1)
{
  _BYTE *(*v2)(_BYTE *, uint64_t, uint64_t, uint64_t, int, int *);
  void (*v3)(_QWORD, uint64_t *, _QWORD, _QWORD, _QWORD, uint64_t, int *);
  void (*v4)(_QWORD *);
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  int v12;

  v12 = 0;
  if (a1)
  {
    v2 = (_BYTE *(*)(_BYTE *, uint64_t, uint64_t, uint64_t, int, int *))a1[1];
    if (v2 != UCNV_TO_U_CALLBACK_SUBSTITUTE)
    {
      v11 = 0;
      v9 = 0u;
      v10 = 0u;
      v7 = 65592;
      v8 = a1;
      v12 = 0;
      v2((_BYTE *)a1[4], (uint64_t)&v7, 0, 0, 4, &v12);
    }
    v3 = (void (*)(_QWORD, uint64_t *, _QWORD, _QWORD, _QWORD, uint64_t, int *))*a1;
    if ((_BYTE *(*)(_BYTE *, uint64_t, uint64_t, uint64_t, int, int, int *))*a1 != UCNV_FROM_U_CALLBACK_SUBSTITUTE)
    {
      v11 = 0;
      v9 = 0u;
      v10 = 0u;
      v7 = 65592;
      v8 = a1;
      v12 = 0;
      v3(a1[3], &v7, 0, 0, 0, 4, &v12);
    }
    v4 = *(void (**)(_QWORD *))(*(_QWORD *)(a1[6] + 32) + 32);
    if (v4)
      v4(a1);
    v5 = (_QWORD *)a1[5];
    if (v5 != a1 + 17)
      uprv_free(v5);
    v6 = a1[6];
    if (*(_BYTE *)(v6 + 25))
      sub_18BC15BD4(v6);
    if (!*((_BYTE *)a1 + 61))
      uprv_free(a1);
  }
}

uint64_t ucnv_getAvailableName(unsigned int a1)
{
  uint64_t result;
  int v2;

  if (HIWORD(a1))
    return 0;
  v2 = 0;
  result = sub_18BC168E4((unsigned __int16)a1, (UErrorCode *)&v2);
  if (v2 >= 1)
    return 0;
  return result;
}

uint64_t ucnv_countAvailable()
{
  int v1;

  v1 = 0;
  return sub_18BC166FC((UErrorCode *)&v1);
}

const void **ucnv_getSubstChars(const void **result, void *__dst, _BYTE *a3, int *a4)
{
  const void **v5;
  int v6;

  if (*a4 <= 0)
  {
    v5 = result;
    v6 = *((char *)result + 89);
    if (v6 <= 0)
    {
      *a3 = 0;
    }
    else if ((char)*a3 >= (char)v6)
    {
      result = (const void **)memcpy(__dst, result[5], *((unsigned __int8 *)result + 89));
      *a3 = *((_BYTE *)v5 + 89);
    }
    else
    {
      *a4 = 8;
    }
  }
  return result;
}

void **ucnv_setSubstChars(void **result, const void *a2, int a3, int *a4)
{
  char v4;
  void **v5;
  uint64_t v6;

  if (*a4 <= 0)
  {
    v4 = a3;
    v5 = result;
    v6 = *((_QWORD *)result[6] + 2);
    if (*(char *)(v6 + 71) >= a3 && *(char *)(v6 + 70) <= a3)
    {
      result = (void **)memcpy(result[5], a2, a3);
      *((_BYTE *)v5 + 89) = v4;
      *((_BYTE *)v5 + 94) = 0;
    }
    else
    {
      *a4 = 1;
    }
  }
  return result;
}

void ucnv_setSubstString(uint64_t a1, const UChar *a2, int32_t a3, int *a4)
{
  _QWORD *v8;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  int v12;
  void *v13;
  _OWORD *v14;
  int v15;
  _OWORD __src[2];
  _BYTE v17[1024];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  bzero(v17, 0x400uLL);
  memset(__src, 0, sizeof(__src));
  v15 = 1024;
  v8 = (_QWORD *)ucnv_safeClone((void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a1, (uint64_t)v17, &v15, a4);
  v9 = v8;
  if (*a4 <= 0)
  {
    *v8 = UCNV_FROM_U_CALLBACK_STOP;
    v8[3] = 0;
  }
  v10 = ucnv_fromUChars((uint64_t)v8, (unint64_t)__src, 32, a2, a3, a4);
  ucnv_close(v9);
  if (*a4 <= 0)
  {
    v11 = *(_QWORD *)(a1 + 48);
    if (*(_QWORD *)(*(_QWORD *)(v11 + 32) + 104)
      && (*(_BYTE *)(*(_QWORD *)(v11 + 16) + 69) != 2 || sub_18BC28C98(a1) == 9))
    {
      if (a3 >= 33)
      {
        v12 = 15;
LABEL_9:
        *a4 = v12;
        return;
      }
      if (a3 < 0)
        a3 = u_strlen(a2);
      v10 = 2 * a3;
    }
    else
    {
      a2 = (const UChar *)__src;
    }
    if (v10 < 5)
    {
      if (!v10)
      {
LABEL_22:
        *(_BYTE *)(a1 + 89) = v10;
        *(_BYTE *)(a1 + 94) = 0;
        return;
      }
      v13 = *(void **)(a1 + 40);
    }
    else
    {
      v13 = *(void **)(a1 + 40);
      if (v13 == (void *)(a1 + 136))
      {
        v14 = uprv_malloc(0x40uLL);
        *(_QWORD *)(a1 + 40) = v14;
        if (!v14)
        {
          *(_QWORD *)(a1 + 40) = v13;
          v12 = 7;
          goto LABEL_9;
        }
        v14[2] = 0u;
        v14[3] = 0u;
        *v14 = 0u;
        v14[1] = 0u;
        v13 = v14;
      }
    }
    memcpy(v13, a2, v10);
    if (a2 != (const UChar *)__src)
      v10 = -a3;
    goto LABEL_22;
  }
}

_QWORD *ucnv_setFromUCallBack(_QWORD *result, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5, int *a6)
{
  if (*a6 <= 0)
  {
    if (a4)
      *a4 = *result;
    *result = a2;
    if (a5)
      *a5 = result[3];
    result[3] = a3;
  }
  return result;
}

uint64_t ucnv_fromUChars(uint64_t a1, unint64_t a2, int a3, const UChar *a4, int a5, int *a6)
{
  uint64_t result;
  int v9;
  BOOL v11;
  int32_t v12;
  unint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  const UChar *v18;
  _BYTE *v19;
  _BYTE v20[1024];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v18 = a4;
  v19 = (_BYTE *)a2;
  if (!a6 || *a6 > 0)
    return 0;
  if (!a1 || (v9 = a3, a3 < 0) || (a3 ? (v11 = a2 == 0) : (v11 = 0), v11 || (v12 = a5, a5 < -1) || !a4 && a5))
  {
    result = 0;
    *a6 = 1;
  }
  else
  {
    sub_18BC0FC34(a1, 2, 1);
    if (v12 == -1)
      v12 = u_strlen(a4);
    if (v12 < 1)
    {
      v17 = 0;
    }
    else
    {
      v14 = (unint64_t)&a4[v12];
      v15 = a2 + 0x7FFFFFFF;
      if (a2 > 0xFFFFFFFF80000000)
        v15 = -1;
      v16 = v15 - a2;
      if (v16 >= v9)
        v16 = v9;
      if (v9)
        v9 = v16;
      else
        v9 = 0;
      ucnv_fromUnicode(a1, (uint64_t *)&v19, a2 + v9, (unint64_t *)&v18, v14, 0, 1, a6);
      v17 = ((_DWORD)v19 - a2);
      if (*a6 == 15)
      {
        bzero(v20, 0x400uLL);
        do
        {
          v19 = v20;
          *a6 = 0;
          ucnv_fromUnicode(a1, (uint64_t *)&v19, (unint64_t)&v21, (unint64_t *)&v18, v14, 0, 1, a6);
          v17 = v17 + (_DWORD)v19 - v20;
        }
        while (*a6 == 15);
      }
    }
    return u_terminateChars(a2, v9, v17, a6);
  }
  return result;
}

uint64_t ucnv_reset(uint64_t a1)
{
  return sub_18BC0FC34(a1, 0, 1);
}

uint64_t sub_18BC0FC34(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4;
  _BYTE *(*v5)(_BYTE *, uint64_t, uint64_t, uint64_t, int, int *);
  _BYTE *(*v6)(_BYTE *, uint64_t, uint64_t, uint64_t, int, int, int *);
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  int v14;

  if (result)
  {
    v4 = result;
    if (a3)
    {
      if ((int)a2 > 1)
        goto LABEL_7;
      v5 = *(_BYTE *(**)(_BYTE *, uint64_t, uint64_t, uint64_t, int, int *))(result + 8);
      if (v5 != UCNV_TO_U_CALLBACK_SUBSTITUTE)
      {
        v13 = 0;
        v11 = 0u;
        v12 = 0u;
        v9 = 65592;
        v10 = result;
        v14 = 0;
        result = (uint64_t)v5(*(_BYTE **)(result + 32), (uint64_t)&v9, 0, 0, 3, &v14);
      }
      if ((_DWORD)a2 != 1)
      {
LABEL_7:
        v6 = *(_BYTE *(**)(_BYTE *, uint64_t, uint64_t, uint64_t, int, int, int *))v4;
        if (*(_BYTE *(**)(_BYTE *, uint64_t, uint64_t, uint64_t, int, int, int *))v4 != UCNV_FROM_U_CALLBACK_SUBSTITUTE)
        {
          v13 = 0;
          v11 = 0u;
          v12 = 0u;
          v9 = 65592;
          v10 = v4;
          v14 = 0;
          result = (uint64_t)v6(*(_BYTE **)(v4 + 24), (uint64_t)&v9, 0, 0, 0, 3, &v14);
        }
      }
    }
    v7 = *(_QWORD *)(v4 + 48);
    if ((int)a2 > 1
      || (*(_QWORD *)(v4 + 72) = *(unsigned int *)(v7 + 40),
          *(_BYTE *)(v4 + 64) = 0,
          *(_BYTE *)(v4 + 93) = 0,
          *(_BYTE *)(v4 + 90) = 0,
          *(_BYTE *)(v4 + 282) = 0,
          (_DWORD)a2 != 1))
    {
      *(_QWORD *)(v4 + 80) = 0;
      *(_WORD *)(v4 + 91) = 0;
      *(_DWORD *)(v4 + 208) = -1;
      *(_BYTE *)(v4 + 281) = 0;
    }
    v8 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v7 + 32) + 40);
    if (v8)
      return v8(v4, a2);
  }
  return result;
}

uint64_t ucnv_resetToUnicode(uint64_t a1)
{
  return sub_18BC0FC34(a1, 1, 1);
}

uint64_t ucnv_resetFromUnicode(uint64_t a1)
{
  return sub_18BC0FC34(a1, 2, 1);
}

uint64_t ucnv_getMaxCharSize(uint64_t a1)
{
  return *(char *)(a1 + 88);
}

uint64_t ucnv_getMinCharSize(uint64_t a1)
{
  return *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) + 70);
}

uint64_t ucnv_getName(uint64_t a1, int *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);

  if (*a2 > 0)
    return 0;
  v4 = *(_QWORD *)(a1 + 48);
  v5 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v4 + 32) + 96);
  if (v5)
  {
    result = v5(a1);
    if (result)
      return result;
    v4 = *(_QWORD *)(a1 + 48);
  }
  return *(_QWORD *)(v4 + 16) + 4;
}

uint64_t ucnv_getCCSID(uint64_t a1, UErrorCode *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v7)(uint64_t);
  char *v8;
  char *StandardName;

  if (*(int *)a2 > 0)
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 48);
  v5 = *(_QWORD *)(v4 + 16);
  result = *(unsigned int *)(v5 + 64);
  if (!(_DWORD)result)
  {
    v7 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v4 + 32) + 96);
    if (v7)
    {
      v8 = (char *)v7(a1);
      if (v8)
      {
LABEL_9:
        StandardName = (char *)ucnv_getStandardName(v8, "IBM", a2);
        result = 0;
        if (*(int *)a2 <= 0 && StandardName)
        {
          result = (uint64_t)strchr(StandardName, 45);
          if (result)
            return atol((const char *)(result + 1));
        }
        return result;
      }
      v5 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16);
    }
    v8 = (char *)(v5 + 4);
    goto LABEL_9;
  }
  return result;
}

uint64_t ucnv_getPlatform(uint64_t a1, int *a2)
{
  if (*a2 <= 0)
    return *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) + 68);
  else
    return 0xFFFFFFFFLL;
}

uint64_t ucnv_getToUCallBack(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  *a2 = *(_QWORD *)(result + 8);
  *a3 = *(_QWORD *)(result + 32);
  return result;
}

_QWORD *ucnv_getFromUCallBack(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *a2 = *result;
  *a3 = result[3];
  return result;
}

uint64_t ucnv_setToUCallBack(uint64_t result, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5, int *a6)
{
  if (*a6 <= 0)
  {
    if (a4)
      *a4 = *(_QWORD *)(result + 8);
    *(_QWORD *)(result + 8) = a2;
    if (a5)
      *a5 = *(_QWORD *)(result + 32);
    *(_QWORD *)(result + 32) = a3;
  }
  return result;
}

uint64_t ucnv_fromUnicode(uint64_t result, uint64_t *a2, unint64_t a3, unint64_t *a4, unint64_t a5, _DWORD *a6, int a7, int *a8)
{
  uint64_t v9;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  BOOL v17;
  unint64_t v18;
  BOOL v19;
  BOOL v20;
  char v21;
  uint64_t v23;
  uint64_t v24;
  _QWORD v25[2];
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _DWORD *v30;
  _DWORD *v31;

  v31 = a6;
  if (a8 && *a8 <= 0)
  {
    v9 = result;
    if (!result || !a2 || !a4)
      goto LABEL_30;
    v13 = *a4;
    v14 = *a2;
    v15 = a5 + 0x7FFFFFFF;
    if (a5 >= 0xFFFFFFFF80000001)
      v15 = -1;
    v16 = a5 - (v15 == a5);
    v17 = v16 < v13 || v14 > a3;
    if (!v17
      && ((v18 = v16 - v13, v16 > v13) ? (v19 = v18 > 0x7FFFFFFE) : (v19 = 0),
          !v19
       && ((a3 - v14) >> 31 ? (v20 = a3 > v14) : (v20 = 0), v20 ? (v21 = 0) : (v21 = 1), (v18 & 1) == 0
                                                                                      && (v21 & 1) != 0)))
    {
      v25[0] = 0;
      if (*(char *)(result + 91) < 1 || (result = sub_18BC1008C(result, a2, a3, &v31, a8), !(_DWORD)result))
      {
        if (a7 || v13 != v16 || *(char *)(v9 + 281) < 0)
        {
          BYTE2(v25[0]) = a7;
          v25[1] = v9;
          v26 = v13;
          v23 = *a2;
          v27 = v16;
          v28 = v23;
          v29 = a3;
          v30 = v31;
          LOWORD(v25[0]) = 56;
          result = sub_18BC10144((uint64_t)v25, a8);
          v24 = v28;
          *a4 = v26;
          *a2 = v24;
        }
      }
    }
    else
    {
LABEL_30:
      *a8 = 1;
    }
  }
  return result;
}

uint64_t sub_18BC1008C(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD **a4, _DWORD *a5)
{
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  _BYTE *v12;
  char v13;

  if (a4)
    v5 = *a4;
  else
    v5 = 0;
  v6 = *a2;
  if (*(char *)(a1 + 91) < 1)
  {
LABEL_11:
    *(_BYTE *)(a1 + 91) = 0;
    *a2 = v6;
    result = 0;
    if (v5)
      *a4 = v5;
  }
  else
  {
    v7 = 0;
    v8 = a1 + 104;
    v9 = *(unsigned __int8 *)(a1 + 91);
    while (v6 + v7 != a3)
    {
      *(_BYTE *)(v6 + v7) = *(_BYTE *)(v8 + v7);
      if (v5)
        *v5++ = -1;
      if (v9 == ++v7)
      {
        v6 += v7;
        goto LABEL_11;
      }
    }
    v11 = 0;
    do
    {
      v12 = (_BYTE *)(v8 + v11);
      v13 = *(_BYTE *)(v8 + v11++ + v7);
      *v12 = v13;
    }
    while (v11 + v7 < (char)v9);
    *(_BYTE *)(a1 + 91) = v11;
    *a2 = a3;
    if (v5)
      *a4 = v5;
    *a5 = 15;
    return 1;
  }
  return result;
}

uint64_t sub_18BC10144(uint64_t result, int *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t (*v19)(uint64_t, int *);
  _BOOL4 v20;
  void *__src;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  _BYTE __dst[38];
  uint64_t v26;

  v3 = result;
  v26 = *MEMORY[0x1E0C80C00];
  memset(__dst, 0, sizeof(__dst));
  v4 = *(_QWORD *)(result + 8);
  v5 = *(_QWORD *)(result + 16);
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(*(_QWORD *)(v4 + 48) + 32);
  if (v6)
  {
    v19 = *(uint64_t (**)(uint64_t, int *))(v7 + 72);
    if (v19)
    {
      v8 = 0;
      goto LABEL_7;
    }
    v8 = 0xFFFFFFFFLL;
  }
  else
  {
    v8 = 0;
  }
  v19 = *(uint64_t (**)(uint64_t, int *))(v7 + 64);
LABEL_7:
  v9 = *(_QWORD *)(result + 32);
  v10 = *(char *)(v4 + 281);
  if (v10 < 0)
  {
    v23 = *(_QWORD *)(result + 24);
    LODWORD(v22) = v8;
    BYTE4(v22) = *(_BYTE *)(result + 2);
    result = (uint64_t)memcpy(__dst, (const void *)(v4 + 212), (-2 * v10));
    *(_QWORD *)(v3 + 16) = __dst;
    *(_QWORD *)(v3 + 24) = &__dst[-2 * v10];
    *(_BYTE *)(v3 + 2) = 0;
    *(_BYTE *)(v4 + 281) = 0;
    v8 = 0xFFFFFFFFLL;
    v24 = v5;
  }
  else
  {
    v23 = 0;
    v24 = 0;
    v22 = 0;
  }
  __src = (void *)(v4 + 212);
  v11 = *a2;
  while (2)
  {
    while (2)
    {
      while (2)
      {
        v20 = v11 <= 0
           && (result = v19(v3, a2), *a2 <= 0)
           && *(_BYTE *)(v3 + 2)
           && *(_QWORD *)(v3 + 16) == *(_QWORD *)(v3 + 24)
           && *(_DWORD *)(v4 + 84) == 0;
        LODWORD(v12) = 0;
        v13 = 0;
        if (!v6)
          goto LABEL_19;
LABEL_15:
        v14 = *(_QWORD *)(v3 + 32) - v9;
        if ((int)v14 >= 1)
        {
          result = sub_18BC12150(v6, v14, v8, v12);
          v6 += 4 * v14;
          *(_QWORD *)(v3 + 48) = v6;
        }
        if ((v8 & 0x80000000) == 0)
        {
          v15 = v8 + ((*(_QWORD *)(v3 + 16) - v5) >> 1);
          goto LABEL_20;
        }
        while (1)
        {
LABEL_19:
          v15 = v8;
LABEL_20:
          v16 = *(char *)(v4 + 281);
          if ((v16 & 0x8000000000000000) == 0)
            goto LABEL_23;
          if (v24)
          {
            *a2 = 5;
LABEL_23:
            v8 = v15;
            goto LABEL_24;
          }
          v23 = *(_QWORD *)(v3 + 24);
          v24 = *(_QWORD *)(v3 + 16);
          BYTE4(v22) = *(_BYTE *)(v3 + 2);
          result = (uint64_t)memcpy(__dst, __src, (-2 * v16));
          *(_QWORD *)(v3 + 16) = __dst;
          *(_QWORD *)(v3 + 24) = &__dst[-2 * v16];
          *(_BYTE *)(v3 + 2) = 0;
          v8 = (int)v15 + (int)v16 < 0 != __OFADD__((_DWORD)v15, (_DWORD)v16) ? 0xFFFFFFFFLL : (v15 + v16);
          *(_BYTE *)(v4 + 281) = 0;
          LODWORD(v22) = v15;
LABEL_24:
          v5 = *(_QWORD *)(v3 + 16);
          v9 = *(_QWORD *)(v3 + 32);
          v11 = *a2;
          if (*a2 <= 0)
            break;
          if (v13 & 1 | ((v11 - 13) < 0xFFFFFFFD))
          {
            if (v24)
            {
              v18 = *(_QWORD *)(v3 + 24) - v5;
              if ((int)(v18 >> 1) >= 1)
              {
                result = (uint64_t)u_memcpy((UChar *)__src, *(const UChar **)(v3 + 16), v18 >> 1);
                *(_BYTE *)(v4 + 281) = -(v18 >> 1);
              }
              *(_QWORD *)(v3 + 16) = v24;
              *(_QWORD *)(v3 + 24) = v23;
              *(_BYTE *)(v3 + 2) = BYTE4(v22);
            }
            return result;
          }
          v17 = *(_DWORD *)(v4 + 84);
LABEL_32:
          if (HIWORD(v17))
          {
            *(_WORD *)(v4 + 140) = (v17 >> 10) - 10304;
            *(_WORD *)(v4 + 142) = v17 & 0x3FF | 0xDC00;
            v12 = 2;
          }
          else
          {
            *(_WORD *)(v4 + 140) = v17;
            v12 = 1;
          }
          *(_BYTE *)(v4 + 92) = v12;
          *(_DWORD *)(v4 + 84) = 0;
          result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))v4)(*(_QWORD *)(v4 + 24), v3, v4 + 140, v12);
          v13 = 1;
          if (v6)
            goto LABEL_15;
        }
        if (v5 < *(_QWORD *)(v3 + 24))
          continue;
        break;
      }
      if (v24)
      {
        *(_QWORD *)(v3 + 16) = v24;
        *(_QWORD *)(v3 + 24) = v23;
        v8 = v22;
        *(_BYTE *)(v3 + 2) = BYTE4(v22);
        v24 = 0;
        continue;
      }
      break;
    }
    if (!*(_BYTE *)(v3 + 2))
      return result;
    v17 = *(_DWORD *)(v4 + 84);
    if (v17)
    {
      *a2 = 11;
      goto LABEL_32;
    }
    v24 = 0;
    if (!v20)
      continue;
    return sub_18BC0FC34(v4, 2, 0);
  }
}

uint64_t ucnv_toUnicode(uint64_t result, char **a2, unint64_t a3, unint64_t *a4, unint64_t a5, _DWORD *a6, int a7, int *a8)
{
  uint64_t v9;
  unint64_t v13;
  uint64_t v14;
  _BOOL8 v15;
  char *v16;
  char *v17;
  unint64_t v19;
  BOOL v20;
  unint64_t v21;
  char *v23;
  char *v24;
  _QWORD v25[2];
  unint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  _DWORD *v30;
  _DWORD *v31;

  v31 = a6;
  if (a8 && *a8 <= 0)
  {
    v9 = result;
    if (!result || !a2 || !a4)
      goto LABEL_19;
    v13 = *a4;
    v14 = a3 + 0x7FFFFFFF;
    if (a3 >= 0xFFFFFFFF80000001)
      v14 = -1;
    v15 = v14 == a3;
    if (v13 > a5)
      goto LABEL_19;
    v16 = *a2;
    v17 = (char *)(a3 - v15);
    if (a3 - v15 < (unint64_t)*a2 || a5 > v13 && (a5 - v13) >> 31)
      goto LABEL_19;
    v20 = v17 >= v16;
    v19 = v17 - v16;
    v20 = v19 != 0 && v20 && v19 >= 0x7FFFFFFF;
    v21 = v19 & 1;
    if (!v20 && v21 == 0)
    {
      v25[0] = 0;
      if (*(char *)(result + 93) < 1 || (result = sub_18BC1060C(result, (_WORD **)a2, v17, &v31, a8), !(_DWORD)result))
      {
        if (a7 || v13 != a5 || *(char *)(v9 + 282) < 0)
        {
          BYTE2(v25[0]) = a7;
          v25[1] = v9;
          v26 = v13;
          v23 = *a2;
          v27 = a5;
          v28 = v23;
          v29 = v17;
          v30 = v31;
          LOWORD(v25[0]) = 56;
          result = sub_18BC106BC((uint64_t)v25, a8);
          v24 = v28;
          *a4 = v26;
          *a2 = v24;
        }
      }
    }
    else
    {
LABEL_19:
      *a8 = 1;
    }
  }
  return result;
}

uint64_t sub_18BC1060C(uint64_t a1, _WORD **a2, _WORD *a3, _DWORD **a4, _DWORD *a5)
{
  _WORD *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;

  v5 = *a2;
  if (a4)
    v6 = *a4;
  else
    v6 = 0;
  if (*(char *)(a1 + 93) < 1)
  {
LABEL_10:
    *(_BYTE *)(a1 + 93) = 0;
    *a2 = v5;
    result = 0;
    if (v6)
      *a4 = v6;
  }
  else
  {
    v7 = 0;
    v8 = a1 + 144;
    v9 = *(unsigned __int8 *)(a1 + 93);
    while (v5 != a3)
    {
      *v5++ = *(_WORD *)(v8 + 2 * v7);
      if (v6)
        *v6++ = -1;
      if (v9 == ++v7)
        goto LABEL_10;
    }
    v11 = 0;
    do
      *(_WORD *)(v8 + 2 * v11++) = *(_WORD *)(v8 + 2 * v7++);
    while (v7 < (char)v9);
    *(_BYTE *)(a1 + 93) = v11;
    *a2 = a3;
    if (v6)
      *a4 = v6;
    *a5 = 15;
    return 1;
  }
  return result;
}

uint64_t sub_18BC106BC(uint64_t result, int *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  char v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;
  BOOL v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t (*v24)(uint64_t, int *);
  _BOOL4 v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD __dst[5];

  v3 = result;
  __dst[4] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(result + 8);
  v5 = *(_QWORD *)(result + 16);
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(*(_QWORD *)(v4 + 48) + 32);
  if (v6)
  {
    v24 = *(uint64_t (**)(uint64_t, int *))(v7 + 56);
    if (v24)
    {
      v8 = 0;
      goto LABEL_7;
    }
    v8 = 0xFFFFFFFFLL;
  }
  else
  {
    v8 = 0;
  }
  v24 = *(uint64_t (**)(uint64_t, int *))(v7 + 48);
LABEL_7:
  v9 = *(_QWORD *)(result + 32);
  memset(__dst, 0, 31);
  v10 = *(char *)(v4 + 282);
  if (v10 < 0)
  {
    v28 = *(_QWORD *)(result + 24);
    LODWORD(v27) = v8;
    BYTE4(v27) = *(_BYTE *)(result + 2);
    result = (uint64_t)memcpy(__dst, (const void *)(v4 + 250), -v10);
    *(_QWORD *)(v3 + 16) = __dst;
    *(_QWORD *)(v3 + 24) = (char *)__dst - v10;
    *(_BYTE *)(v3 + 2) = 0;
    *(_BYTE *)(v4 + 282) = 0;
    v8 = 0xFFFFFFFFLL;
    v29 = v5;
  }
  else
  {
    v29 = 0;
    v27 = 0;
    v28 = 0;
  }
  v26 = (void *)(v4 + 250);
  v11 = *a2;
  while (2)
  {
    while (2)
    {
      while (2)
      {
        v25 = v11 <= 0
           && (result = v24(v3, a2), *a2 <= 0)
           && *(_BYTE *)(v3 + 2)
           && *(_QWORD *)(v3 + 16) == *(_QWORD *)(v3 + 24)
           && *(_BYTE *)(v4 + 64) == 0;
        LODWORD(v12) = 0;
        v13 = 1;
        if (!v6)
          goto LABEL_19;
LABEL_15:
        v14 = *(_QWORD *)(v3 + 32) - v9;
        v15 = v14 >> 1;
        if ((int)(v14 >> 1) >= 1)
        {
          result = sub_18BC12150(v6, v14 >> 1, v8, v12);
          v6 += 4 * v15;
          *(_QWORD *)(v3 + 48) = v6;
        }
        if ((v8 & 0x80000000) == 0)
        {
          v16 = (v8 + *(_DWORD *)(v3 + 16) - v5);
          goto LABEL_20;
        }
        while (1)
        {
LABEL_19:
          v16 = v8;
LABEL_20:
          v17 = *(char *)(v4 + 282);
          if ((v17 & 0x8000000000000000) == 0)
            goto LABEL_23;
          if (v29)
          {
            *a2 = 5;
LABEL_23:
            v8 = v16;
            goto LABEL_24;
          }
          v29 = *(_QWORD *)(v3 + 16);
          v28 = *(_QWORD *)(v3 + 24);
          BYTE4(v27) = *(_BYTE *)(v3 + 2);
          result = (uint64_t)memcpy(__dst, v26, -(int)v17);
          *(_QWORD *)(v3 + 16) = __dst;
          *(_QWORD *)(v3 + 24) = (char *)__dst - v17;
          *(_BYTE *)(v3 + 2) = 0;
          v8 = (int)v16 + (int)v17 < 0 != __OFADD__((_DWORD)v16, (_DWORD)v17) ? 0xFFFFFFFFLL : (v16 + v17);
          *(_BYTE *)(v4 + 282) = 0;
          LODWORD(v27) = v16;
LABEL_24:
          v5 = *(_QWORD *)(v3 + 16);
          v9 = *(_QWORD *)(v3 + 32);
          v11 = *a2;
          if (*a2 <= 0)
            break;
          if ((v13 & 1) == 0
            || ((v18 = v11 > 0x13, v19 = (1 << v11) & 0xC1C00, !v18) ? (v20 = v19 == 0) : (v20 = 1), v20))
          {
            if (v29)
            {
              v23 = *(_QWORD *)(v3 + 24) - v5;
              if (v23 >= 1)
              {
                result = (uint64_t)memcpy(v26, *(const void **)(v3 + 16), *(_QWORD *)(v3 + 24) - v5);
                *(_BYTE *)(v4 + 282) = -(char)v23;
              }
              *(_QWORD *)(v3 + 16) = v29;
              *(_QWORD *)(v3 + 24) = v28;
              *(_BYTE *)(v3 + 2) = BYTE4(v27);
            }
            return result;
          }
          v12 = *(char *)(v4 + 64);
          *(_BYTE *)(v4 + 90) = *(_BYTE *)(v4 + 64);
          if ((int)v12 >= 1)
            goto LABEL_37;
LABEL_38:
          *(_BYTE *)(v4 + 64) = 0;
          v22 = *(unsigned int *)(v4 + 284);
          if ((_DWORD)v22 == 1)
          {
            if (*a2 == 10)
            {
              v22 = 0;
              *(_DWORD *)(v4 + 284) = 0;
            }
            else
            {
              v22 = 1;
            }
          }
          result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, int *))(v4 + 8))(*(_QWORD *)(v4 + 32), v3, v4 + 96, v12, v22, a2);
          v13 = 0;
          *(_DWORD *)(v4 + 284) = 1;
          if (v6)
            goto LABEL_15;
        }
        if (v5 < *(_QWORD *)(v3 + 24))
          continue;
        break;
      }
      if (v29)
      {
        *(_QWORD *)(v3 + 16) = v29;
        *(_QWORD *)(v3 + 24) = v28;
        v8 = v27;
        *(_BYTE *)(v3 + 2) = BYTE4(v27);
        v29 = 0;
        continue;
      }
      break;
    }
    if (!*(_BYTE *)(v3 + 2))
      return result;
    v21 = *(char *)(v4 + 64);
    if (v21 >= 1)
    {
      v12 = *(unsigned __int8 *)(v4 + 64);
      *a2 = 11;
      *(_BYTE *)(v4 + 90) = v21;
LABEL_37:
      memcpy((void *)(v4 + 96), (const void *)(v4 + 65), v12);
      goto LABEL_38;
    }
    v29 = 0;
    if (!v25)
      continue;
    return sub_18BC0FC34(v4, 1, 0);
  }
}

uint64_t ucnv_toUChars(uint64_t a1, unint64_t a2, int a3, const char *a4, int a5, int *a6)
{
  uint64_t result;
  int v9;
  BOOL v11;
  int v12;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char *v18;
  char *v19;
  _BYTE v20[2048];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v18 = a4;
  v19 = (char *)a2;
  if (!a6 || *a6 > 0)
    return 0;
  if (!a1 || (v9 = a3, a3 < 0) || (a3 ? (v11 = a2 == 0) : (v11 = 0), v11 || (v12 = a5, a5 < -1) || !a4 && a5))
  {
    result = 0;
    *a6 = 1;
  }
  else
  {
    sub_18BC0FC34(a1, 1, 1);
    if (v12 == -1)
      v12 = strlen(a4);
    if (v12 < 1)
    {
      v17 = 0;
    }
    else
    {
      v14 = (unint64_t)&a4[v12];
      v15 = a2 + 0x7FFFFFFF;
      if (a2 > 0xFFFFFFFF80000000)
        v15 = 0x1FFFFFFFFLL;
      v16 = (v15 - a2) >> 1;
      if ((int)v16 >= v9)
        LODWORD(v16) = v9;
      if (v9)
        v9 = v16;
      else
        v9 = 0;
      ucnv_toUnicode(a1, &v19, a2 + 2 * v9, (unint64_t *)&v18, v14, 0, 1, a6);
      v17 = (unint64_t)&v19[-a2] >> 1;
      if (*a6 == 15)
      {
        bzero(v20, 0x800uLL);
        do
        {
          v19 = v20;
          *a6 = 0;
          ucnv_toUnicode(a1, &v19, (unint64_t)&v21, (unint64_t *)&v18, v14, 0, 1, a6);
          v17 = v17 + ((unint64_t)(v19 - v20) >> 1);
        }
        while (*a6 == 15);
      }
    }
    return u_terminateUChars(a2, v9, v17, a6);
  }
  return result;
}

uint64_t ucnv_getNextUChar(uint64_t a1, unint64_t *a2, unint64_t a3, int *a4)
{
  unint64_t v8;
  uint64_t v9;
  int v11;
  char *v12;
  int v13;
  int v14;
  BOOL v15;
  unsigned int v16;
  unint64_t v17;
  int v18;
  unsigned __int16 v19;
  int v20;
  BOOL v21;
  int v22;
  int v23;
  uint64_t (*v24)(_QWORD *, int *);
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  _QWORD v30[2];
  unint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;

  if (!a4 || *a4 > 0)
    return 0xFFFFLL;
  if (!a1 || !a2 || (v8 = *a2, *a2 > a3) || a3 > v8 && (a3 - v8) >> 31)
  {
    *a4 = 1;
    return 0xFFFFLL;
  }
  v11 = *(char *)(a1 + 93);
  if (v11 < 1)
  {
    LODWORD(v9) = -1;
  }
  else
  {
    v12 = (char *)(a1 + 144);
    v9 = *(unsigned __int16 *)(a1 + 144);
    v13 = 1;
    if (v11 != 1 && (v9 & 0xFC00) == 0xD800)
    {
      v14 = *(unsigned __int16 *)(a1 + 146);
      v15 = (v14 & 0xFC00) == 56320;
      v16 = v14 + ((_DWORD)v9 << 10) - 56613888;
      if (v15)
        v9 = v16;
      else
        v9 = *(unsigned __int16 *)(a1 + 144);
      if (v15)
        v13 = 2;
      else
        v13 = 1;
    }
    *(_BYTE *)(a1 + 93) = v11 - v13;
    if ((char)(v11 - v13) >= 1)
      memmove(v12, &v12[2 * v13], 2 * (v11 - v13));
    if (v9 >> 10 != 54 || v13 < v11)
      return v9;
  }
  v29 = 0;
  v30[0] = 65592;
  v30[1] = a1;
  v31 = v8;
  v32 = a3;
  v33 = (char *)&v29;
  v34 = (char *)&v29 + 2;
  v35 = 0;
  if ((v9 & 0x80000000) == 0)
  {
    LOWORD(v29) = v9;
    v33 = (char *)&v29 + 2;
    LODWORD(v17) = 1;
    if (*a4 >= 1)
    {
      v18 = 0;
      v9 = 0xFFFFLL;
LABEL_55:
      v27 = v17 - v18;
      v28 = *(unsigned __int8 *)(a1 + 93);
      if (*(char *)(a1 + 93) >= 1)
        memmove((void *)(a1 + 144 + 2 * v27), (const void *)(a1 + 144), 2 * v28);
      *(_BYTE *)(a1 + 93) = v28 + v27;
      *(_WORD *)(a1 + 144) = *(_WORD *)((unint64_t)&v29 | (2 * v18));
      if (v27 > 1)
        *(_WORD *)(a1 + 146) = *((_WORD *)&v29 + (v18 + 1));
      goto LABEL_59;
    }
    v19 = v9;
    goto LABEL_37;
  }
  if (*(_BYTE *)(a1 + 64))
    goto LABEL_30;
  v24 = *(uint64_t (**)(_QWORD *, int *))(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32) + 80);
  if (!v24)
    goto LABEL_30;
  v25 = v24(v30, a4);
  *a2 = v31;
  if (*a4 == 8)
  {
    sub_18BC0FC34(a1, 1, 0);
    return 0xFFFFLL;
  }
  if (*a4 > 0 || (v9 = v25, (v25 & 0x80000000) != 0))
  {
LABEL_30:
    sub_18BC106BC((uint64_t)v30, a4);
    if (*a4 == 15)
    {
      *a4 = 0;
      v17 = (unint64_t)(v33 - (char *)&v29) >> 1;
    }
    else
    {
      v17 = (unint64_t)(v33 - (char *)&v29) >> 1;
      if (*a4 >= 1)
      {
        v18 = 0;
        v9 = 0xFFFFLL;
        goto LABEL_54;
      }
    }
    if (!(_DWORD)v17)
    {
      *a4 = 8;
      v9 = 0xFFFFLL;
      goto LABEL_59;
    }
    v19 = v29;
LABEL_37:
    v9 = v19;
    if ((v19 & 0xFC00) == 0xD800)
    {
      v20 = *(char *)(a1 + 93);
      v21 = __OFSUB__(v20, 1);
      v22 = v20 - 1;
      if (v22 < 0 != v21)
      {
        if (v31 < a3)
        {
          v34 = (char *)v30;
          sub_18BC106BC((uint64_t)v30, a4);
          v26 = *a4;
          if (*a4 == 15)
          {
            v26 = 0;
            *a4 = 0;
          }
          v17 = (unint64_t)(v33 - (char *)&v29) >> 1;
          v18 = 1;
          if (v26 <= 0 && (_DWORD)v17 == 2)
          {
            if ((HIWORD(v29) & 0xFC00) != 0xDC00)
            {
              LODWORD(v17) = 2;
              goto LABEL_55;
            }
            v9 = HIWORD(v29) + ((_DWORD)v9 << 10) - 56613888;
            goto LABEL_59;
          }
LABEL_54:
          if (v18 < (int)v17)
            goto LABEL_55;
LABEL_59:
          *a2 = v31;
          return v9;
        }
      }
      else
      {
        v23 = *(unsigned __int16 *)(a1 + 144);
        if ((v23 & 0xFC00) == 0xDC00)
        {
          v9 = (v23 + ((_DWORD)v9 << 10) - 56613888);
          *(_BYTE *)(a1 + 93) = v22;
          if ((_BYTE)v22)
            memmove((void *)(a1 + 144), (const void *)(a1 + 146), 2 * v22);
        }
      }
    }
    v18 = 1;
    goto LABEL_54;
  }
  return v9;
}

void ucnv_convertEx(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4, const char **a5, const char *a6, uint64_t *a7, uint64_t **a8, uint64_t *a9, uint64_t *a10, char a11, char a12, int *a13)
{
  const char *v17;
  unint64_t v19;
  const char *v20;
  uint64_t **v22;
  uint64_t *v23;
  BOOL v24;
  unint64_t v25;
  int v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(__int128 *, __int128 *, int *);
  uint64_t *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t *v40;
  int v41;
  int v42;
  _BYTE *v43;
  int v44;
  uint64_t *v45;
  uint64_t *v46;
  void (*v47)(__int128 *, __int128 *, int *);
  uint64_t *v48;
  __int128 v49;
  __int128 v50;
  _BYTE *v51;
  unint64_t v52;
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  uint64_t *v56;
  uint64_t *v57;
  uint64_t v58;
  _BYTE *v59;
  _BYTE *v60;
  _BYTE v61[2048];
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v60 = 0;
  if (!a13 || *a13 > 0)
    return;
  if (!a1)
    goto LABEL_21;
  if (!a2)
    goto LABEL_21;
  if (!a5)
    goto LABEL_21;
  if (!a3)
    goto LABEL_21;
  v17 = *a5;
  if (!*a5)
    goto LABEL_21;
  if (!a4)
    goto LABEL_21;
  v19 = *a3;
  if (!*a3)
    goto LABEL_21;
  v20 = a6;
  if (v17 > a6 && a6 != 0)
    goto LABEL_21;
  if (v19 > a4)
    goto LABEL_21;
  v22 = a8;
  v23 = a7;
  if (a6 > v17)
  {
    if ((unint64_t)(a6 - v17) >> 31)
      goto LABEL_21;
  }
  v24 = a4 >= v19;
  v25 = a4 - v19;
  if (v25 != 0 && v24)
  {
    if (v25 >> 31)
      goto LABEL_21;
  }
  v59 = 0;
  if (a7)
  {
    if (!a8 || (v27 = a10, a7 >= a10) || (v28 = a9) == 0 || !*a8 || !*a9)
    {
LABEL_21:
      v26 = 1;
LABEL_22:
      *a13 = v26;
      return;
    }
  }
  else
  {
    if (!a12)
      goto LABEL_21;
    v23 = (uint64_t *)v61;
    v59 = v61;
    v60 = v61;
    v27 = &v62;
    v22 = (uint64_t **)&v60;
    v28 = (uint64_t *)&v59;
  }
  v45 = v27;
  v48 = v28;
  bzero(v61, 0x800uLL);
  v56 = 0;
  v54 = 0u;
  v55 = 0u;
  v49 = 0u;
  v50 = 0u;
  if (!v20)
    v20 = &v17[strlen(v17)];
  if (a11)
  {
    sub_18BC0FC34(a2, 1, 1);
    sub_18BC0FC34(a1, 2, 1);
    v29 = v48;
    *v48 = (uint64_t)v23;
    *v22 = v23;
  }
  else
  {
    v29 = v48;
    if (*(char *)(a1 + 91) >= 1)
    {
      v44 = sub_18BC1008C(a1, a3, a4, 0, a13);
      v29 = v48;
      if (v44
        || !a12
        && (*(char *)(a1 + 281) & 0x80000000) == 0
        && *v22 == (uint64_t *)*v48
        && !*(_BYTE *)(a2 + 93)
        && (*(char *)(a2 + 282) & 0x80000000) == 0
        && v17 == v20)
      {
        return;
      }
    }
  }
  v30 = *(_QWORD *)(a2 + 48);
  v31 = *(_QWORD *)(a1 + 48);
  if ((*(_BYTE *)(*(_QWORD *)(v30 + 16) + 69) != 4
     || (v32 = *(void (**)(__int128 *, __int128 *, int *))(*(_QWORD *)(v31 + 32) + 136)) == 0)
    && (*(_BYTE *)(*(_QWORD *)(v31 + 16) + 69) != 4
     || (v32 = *(void (**)(__int128 *, __int128 *, int *))(*(_QWORD *)(v30 + 32) + 128)) == 0))
  {
    v32 = 0;
  }
  BYTE2(v49) = 0;
  v47 = v32;
  if ((char *)v45 - (char *)v23 <= 64 || v32 == 0)
    v34 = v45;
  else
    v34 = v23 + 8;
  v35 = *a3;
  *((_QWORD *)&v49 + 1) = a1;
  v51 = (_BYTE *)v35;
  v52 = a4;
  v53 = 0;
  LOWORD(v49) = 56;
  BYTE2(v54) = a12;
  v57 = v34;
  v58 = 0;
  *((_QWORD *)&v54 + 1) = a2;
  *(_QWORD *)&v55 = v17;
  LOWORD(v54) = 56;
  v46 = (uint64_t *)((char *)v23 + 2);
  *((_QWORD *)&v55 + 1) = v20;
  v36 = v34;
  while (1)
  {
    v37 = *v29;
    if ((unint64_t)*v22 >= *v29)
    {
      v38 = *a13;
      if (*a13 <= 0 && (*(char *)(a1 + 281) & 0x80000000) == 0 && !BYTE2(v49))
        goto LABEL_53;
    }
    *(_QWORD *)&v50 = *v22;
    *((_QWORD *)&v50 + 1) = v37;
    sub_18BC10144((uint64_t)&v49, a13);
    v38 = *a13;
    if (*a13 >= 1)
      break;
    v29 = v48;
LABEL_53:
    *v29 = (uint64_t)v23;
    *v22 = v23;
    if (*(char *)(a2 + 93) < 1)
    {
      if ((const char *)v55 == v20
        && (*(char *)(a2 + 282) & 0x80000000) == 0
        && !*(_BYTE *)(a2 + 64)
        && (!a12 || BYTE2(v49)))
      {
        goto LABEL_92;
      }
      if (!v47 || (*(_DWORD *)(a1 + 208) & 0x80000000) == 0 || *(_BYTE *)(a2 + 282))
        goto LABEL_60;
      if (v38 == -127)
        *a13 = 0;
      v47(&v49, &v54, a13);
      v38 = *a13;
      if (*a13 == 15)
        goto LABEL_92;
      v29 = v48;
      if (v38 < 1)
      {
        if (v38 == -127)
        {
          v42 = 0;
        }
        else
        {
          if (!a12)
          {
LABEL_108:
            *a5 = (const char *)v55;
            *a3 = (uint64_t)v51;
            return;
          }
          if (*(char *)(a2 + 64) <= 0)
          {
            sub_18BC0FC34(a2, 1, 0);
            sub_18BC0FC34(a1, 2, 0);
            *a5 = (const char *)v55;
            v43 = v51;
            *a3 = (uint64_t)v51;
            v38 = *a13;
            goto LABEL_94;
          }
          v42 = 11;
        }
        *a13 = v42;
        goto LABEL_60;
      }
      if (*(char *)(a2 + 64) > 0)
      {
LABEL_60:
        v56 = v23;
        sub_18BC106BC((uint64_t)&v54, a13);
        v29 = v48;
        v40 = v56;
        *v48 = (uint64_t)v56;
        v38 = *a13;
        if (*a13 == 15)
        {
          *a13 = 0;
          if (a12)
            goto LABEL_68;
        }
        else
        {
          v41 = a12;
          if (v38 > 0)
            goto LABEL_93;
          if (a12)
          {
LABEL_68:
            if ((const char *)v55 == v20 && (*(char *)(a2 + 282) & 0x80000000) == 0 && !*(_BYTE *)(a2 + 93))
              BYTE2(v49) = 1;
          }
          else if (v40 == v23)
          {
            goto LABEL_108;
          }
        }
      }
      else
      {
        *v48 = (uint64_t)v46;
        *v22 = v46;
      }
    }
    else
    {
      v39 = sub_18BC1060C(a2, (_WORD **)v48, v36, 0, a13);
      v29 = v48;
      if (v39)
        *a13 = 0;
    }
  }
  *v22 = (uint64_t *)v50;
LABEL_92:
  v41 = a12;
LABEL_93:
  *a5 = (const char *)v55;
  v43 = v51;
  *a3 = (uint64_t)v51;
  if (!v41)
    return;
LABEL_94:
  if (v38 > 0)
    return;
  if (v43 == (_BYTE *)a4)
  {
    v26 = -124;
    goto LABEL_22;
  }
  *v43 = 0;
  if (*a13 == -124)
    *a13 = 0;
}

uint64_t ucnv_convert(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3, int a4, char *a5, signed int a6, UErrorCode *a7)
{
  uint64_t v8;
  _OWORD *Converter;
  _QWORD *v16;
  _OWORD *v17;
  _QWORD *v18;
  _OWORD v19[18];
  _OWORD v20[18];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a7 || *(int *)a7 > 0)
    return 0;
  if (a4 < 0 || !a5 || a6 < -1 || !a3 && a4)
  {
    v8 = 0;
    *a7 = U_ILLEGAL_ARGUMENT_ERROR;
    return v8;
  }
  if (a6 && ((a6 & 0x80000000) == 0 || *a5))
  {
    memset(v20, 0, sizeof(v20));
    memset(v19, 0, sizeof(v19));
    Converter = ucnv_createConverter(v20, a2, a7);
    if (*(int *)a7 <= 0)
    {
      v16 = Converter;
      v17 = ucnv_createConverter(v19, a1, a7);
      if (*(int *)a7 < 1)
      {
        v18 = v17;
        v8 = sub_18BC11714((uint64_t)v17, (uint64_t)v16, a3, a4, a5, a6, (int *)a7);
        ucnv_close(v16);
        ucnv_close(v18);
        return v8;
      }
      ucnv_close(v16);
    }
    return 0;
  }
  return u_terminateChars(a3, a4, 0, (int *)a7);
}

uint64_t sub_18BC11714(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char *__s, unsigned int a6, int *a7)
{
  size_t v13;
  const char *v14;
  uint64_t v15;
  _BYTE *v17;
  uint64_t *v18;
  uint64_t *v19;
  const char *v20;
  _BYTE v21[1024];
  uint64_t v22[256];
  uint64_t v23[2];

  v23[0] = *MEMORY[0x1E0C80C00];
  v20 = __s;
  if ((a6 & 0x80000000) == 0)
  {
    v13 = a6;
    if (a6)
      goto LABEL_3;
    return u_terminateChars(a3, a4, 0, a7);
  }
  v13 = strlen(__s);
  if (!v13)
    return u_terminateChars(a3, a4, 0, a7);
LABEL_3:
  v14 = &__s[v13];
  bzero(v22, 0x800uLL);
  v18 = v22;
  v19 = v22;
  v17 = (_BYTE *)a3;
  if (a4 < 1)
  {
    v15 = 0;
    if (!a4)
      goto LABEL_9;
  }
  else
  {
    ucnv_convertEx(a1, a2, (uint64_t *)&v17, a3 + a4, &v20, v14, v22, &v19, (uint64_t *)&v18, v23, 0, 1, a7);
    v15 = ((_DWORD)v17 - a3);
  }
  if (*a7 == 15)
  {
LABEL_9:
    bzero(v21, 0x400uLL);
    do
    {
      *a7 = 0;
      v17 = v21;
      ucnv_convertEx(a1, a2, (uint64_t *)&v17, (unint64_t)v22, &v20, v14, v22, &v19, (uint64_t *)&v18, v23, 0, 1, a7);
      v15 = v15 + (_DWORD)v17 - v21;
    }
    while (*a7 == 15);
    return u_terminateChars(a3, a4, v15, a7);
  }
  return v15;
}

uint64_t ucnv_toAlgorithmic(unsigned int a1, uint64_t a2, uint64_t a3, int a4, char *a5, signed int a6, int *a7)
{
  return sub_18BC1193C(1, a1, a2, a3, a4, a5, a6, a7);
}

uint64_t sub_18BC1193C(int a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5, char *a6, signed int a7, int *a8)
{
  uint64_t v9;
  _OWORD *v17;
  _QWORD *v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _OWORD v23[18];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a8 || *a8 > 0)
    return 0;
  if (a5 < 0 || !a3 || !a6 || a7 < -1 || !a4 && a5)
  {
    v9 = 0;
    *a8 = 1;
    return v9;
  }
  if (a7 && ((a7 & 0x80000000) == 0 || *a6))
  {
    memset(v23, 0, sizeof(v23));
    v17 = sub_18BC16488(v23, a2, (uint64_t)"", 0, a8);
    v9 = 0;
    if (*a8 <= 0)
    {
      v18 = v17;
      v19 = a1 == 0;
      if (a1)
        v20 = 1;
      else
        v20 = 2;
      if (a1)
        v21 = (uint64_t)v17;
      else
        v21 = a3;
      if (v19)
        v22 = (uint64_t)v17;
      else
        v22 = a3;
      sub_18BC0FC34(a3, v20, 1);
      v9 = sub_18BC11714(v21, v22, a4, a5, a6, a7, a8);
      ucnv_close(v18);
    }
    return v9;
  }
  return u_terminateChars(a4, a5, 0, a8);
}

uint64_t ucnv_fromAlgorithmic(uint64_t a1, unsigned int a2, uint64_t a3, int a4, char *a5, signed int a6, int *a7)
{
  if (a2 < 0x22)
    return sub_18BC1193C(0, a2, a1, a3, a4, a5, a6, a7);
  *a7 = 1;
  return 0;
}

uint64_t ucnv_getType(uint64_t a1)
{
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) + 69) == 2)
    return sub_18BC28C98(a1);
  else
    return *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) + 69);
}

uint64_t ucnv_getStarters(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t (*v3)(void);

  if (a3 && *a3 <= 0)
  {
    v3 = *(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(result + 48) + 32) + 88);
    if (v3)
      return v3();
    else
      *a3 = 1;
  }
  return result;
}

char **ucnv_fixFileSeparator(char **result, _WORD *a2, int a3)
{
  _WORD *v3;
  int v5;
  uint64_t v6;

  if (result)
  {
    v3 = a2;
    if (a2)
    {
      if (a3 >= 1)
      {
        result = sub_18BC11BF0(result);
        if (result)
        {
          v5 = *((unsigned __int16 *)result + 4);
          v6 = a3;
          do
          {
            if ((unsigned __int16)*v3 == v5)
              *v3 = 92;
            ++v3;
            --v6;
          }
          while (v6);
        }
      }
    }
  }
  return result;
}

char **sub_18BC11BF0(char **result)
{
  char **v1;
  char *v2;
  uint64_t (*v3)(char **);
  const char *v4;
  uint64_t v5;

  if (!result)
    return result;
  v1 = result;
  v2 = result[6];
  v3 = *(uint64_t (**)(char **))(*((_QWORD *)v2 + 4) + 96);
  if (v3)
  {
    v4 = (const char *)v3(result);
    if (v4)
      goto LABEL_6;
    v2 = v1[6];
  }
  v4 = (const char *)(*((_QWORD *)v2 + 2) + 4);
LABEL_6:
  v5 = 0;
  while (strcmp(v4, (&off_1E224CDC0)[v5]))
  {
    v5 += 2;
    if (v5 == 22)
      return 0;
  }
  return &(&off_1E224CDC0)[v5];
}

BOOL ucnv_isAmbiguous(char **a1)
{
  return sub_18BC11BF0(a1) != 0;
}

uint64_t ucnv_setFallback(uint64_t result, char a2)
{
  *(_BYTE *)(result + 63) = a2;
  return result;
}

uint64_t ucnv_usesFallback(uint64_t a1)
{
  return *(char *)(a1 + 63);
}

char *ucnv_getInvalidChars(char *result, void *__dst, _BYTE *a3, int *a4)
{
  int v4;
  int v5;

  if (a4 && *a4 <= 0)
  {
    if (result && __dst && a3)
    {
      v4 = result[90];
      if ((char)*a3 >= v4)
      {
        *a3 = v4;
        if (v4 >= 1)
          return (char *)memcpy(__dst, result + 96, v4);
        return result;
      }
      v5 = 8;
    }
    else
    {
      v5 = 1;
    }
    *a4 = v5;
  }
  return result;
}

UChar *ucnv_getInvalidUChars(UChar *result, UChar *dest, _BYTE *a3, int *a4)
{
  int32_t v4;
  int v5;

  if (a4 && *a4 <= 0)
  {
    if (result && dest && a3)
    {
      v4 = *((char *)result + 92);
      if ((char)*a3 >= v4)
      {
        *a3 = v4;
        if (v4 >= 1)
          return u_memcpy(dest, result + 70, v4);
        return result;
      }
      v5 = 8;
    }
    else
    {
      v5 = 1;
    }
    *a4 = v5;
  }
  return result;
}

const char *ucnv_detectUnicodeSignature(char *__s, int a2, int *a3, int *a4)
{
  const char *result;
  int v7;
  int v8;
  int v9;
  _BOOL4 v10;
  int v11;
  int v12;
  int __dst;
  char v14;

  v14 = -91;
  __dst = -1515870811;
  if (!a4 || *a4 > 0)
    return 0;
  if (!__s || a2 <= -2)
  {
    result = 0;
    *a4 = 1;
    return result;
  }
  if (a2 == -1)
    a2 = strlen(__s);
  if (a2 <= 0)
  {
    v10 = 0;
    v11 = BYTE2(__dst);
    v8 = 165;
    v9 = 165;
  }
  else
  {
    v7 = a2 - 1;
    if ((a2 - 1) >= 4)
      v7 = 4;
    memcpy(&__dst, __s, (v7 + 1));
    v8 = __dst;
    v9 = BYTE1(__dst);
    if (__dst == 254 && BYTE1(__dst) == 255)
    {
      if (a3)
        *a3 = 2;
      return "UTF-16BE";
    }
    v10 = BYTE1(__dst) == 254;
    if (__dst == 255 && BYTE1(__dst) == 254)
    {
      if (BYTE2(__dst) | HIBYTE(__dst))
      {
        if (a3)
          *a3 = 2;
        return "UTF-16LE";
      }
      else
      {
        if (a3)
          *a3 = 4;
        return "UTF-32LE";
      }
    }
    v11 = BYTE2(__dst);
    if (__dst == 239 && BYTE1(__dst) == 187 && BYTE2(__dst) == 191)
    {
      if (a3)
        *a3 = 3;
      return "UTF-8";
    }
  }
  if (!v8 && !v9 && v11 == 254 && HIBYTE(__dst) == 255)
  {
    if (a3)
      *a3 = 4;
    return "UTF-32BE";
  }
  if (v8 != 14)
    v10 = 0;
  if (v10 && v11 == 255)
  {
    if (a3)
      *a3 = 3;
    return "SCSU";
  }
  if (v8 == 251 && v9 == 238 && v11 == 40)
  {
    if (a3)
      *a3 = 3;
    return "BOCU-1";
  }
  if (v8 == 43 && v9 == 47 && v11 == 118)
  {
    if (HIBYTE(__dst) == 56 && v14 == 45)
    {
      if (a3)
      {
        v12 = 5;
LABEL_71:
        *a3 = v12;
        return "UTF-7";
      }
      return "UTF-7";
    }
    if (HIBYTE(__dst) <= 0x39u && ((1 << SHIBYTE(__dst)) & 0x300880000000000) != 0)
    {
      if (a3)
      {
        v12 = 4;
        goto LABEL_71;
      }
      return "UTF-7";
    }
  }
  else if (v8 == 221 && v9 == 115 && v11 == 102 && HIBYTE(__dst) == 115)
  {
    if (a3)
      *a3 = 4;
    return "UTF-EBCDIC";
  }
  if (!a3)
    return 0;
  result = 0;
  *a3 = 0;
  return result;
}

uint64_t ucnv_fromUCountPending(uint64_t a1, int *a2)
{
  unsigned int v3;
  int v4;
  int v5;

  if (!a2 || *a2 > 0)
    return 0xFFFFFFFFLL;
  if (!a1)
  {
    *a2 = 1;
    return 0xFFFFFFFFLL;
  }
  v3 = *(_DWORD *)(a1 + 208);
  if ((v3 & 0x80000000) != 0)
  {
    v5 = *(char *)(a1 + 281);
    if (v5 < 0)
      return -v5;
    else
      return *(_DWORD *)(a1 + 84) > 0;
  }
  else
  {
    if (v3 < 0x10000)
      v4 = 1;
    else
      v4 = 2;
    return (v4 + *(char *)(a1 + 281));
  }
}

uint64_t ucnv_toUCountPending(uint64_t a1, int *a2)
{
  uint64_t result;

  if (!a2 || *a2 > 0)
    return 0xFFFFFFFFLL;
  if (!a1)
  {
    *a2 = 1;
    return 0xFFFFFFFFLL;
  }
  result = *(char *)(a1 + 282);
  if ((int)result <= 0)
  {
    if ((result & 0x80000000) != 0)
      return -(int)result;
    else
      return *(char *)(a1 + 64) & ~(*(char *)(a1 + 64) >> 31);
  }
  return result;
}

uint64_t ucnv_isFixedWidth(uint64_t result, int *a2)
{
  unsigned int v2;
  BOOL v3;
  int v4;

  if (*a2 > 0)
    return 0;
  if (result)
  {
    v2 = *(char *)(*(_QWORD *)(*(_QWORD *)(result + 48) + 16) + 69);
    if (v2 == 2)
      v2 = sub_18BC28C98(result);
    result = 1;
    v3 = v2 > 0x1E;
    v4 = (1 << v2) & 0x44000183;
    if (v3 || v4 == 0)
      return 0;
  }
  else
  {
    *a2 = 1;
  }
  return result;
}

unint64_t sub_18BC12150(unint64_t result, unsigned int a2, int a3, int a4)
{
  int v4;
  _DWORD *v5;
  unint64_t v6;

  v4 = a3 - a4;
  if (a3 < 0)
    v4 = -1;
  if (v4)
  {
    if (v4 <= 0)
    {
      if (a2)
      {
        v6 = result + 4 * a2;
        if (v6 <= result + 4)
          v6 = result + 4;
        return (unint64_t)memset((void *)result, 255, ((v6 + ~result) & 0xFFFFFFFFFFFFFFFCLL) + 4);
      }
    }
    else if (a2)
    {
      v5 = (_DWORD *)(result + 4 * a2);
      do
      {
        if ((*(_DWORD *)result & 0x80000000) == 0)
          *(_DWORD *)result += v4;
        result += 4;
      }
      while (result < (unint64_t)v5);
    }
  }
  return result;
}

void sub_18BC121C4(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  _OWORD *v6;
  _OWORD *v7;
  int v8;
  const char *v9;
  int v10;
  unsigned int v11;
  char *v12;
  uint64_t v13;
  int v14;
  char *v15;
  const char *v16;
  _QWORD *v17;
  _BYTE *v18;
  _OWORD *v19;
  int v20;
  __int128 v21[2];
  uint64_t v22;
  char __dst[8];
  _OWORD v24[14];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  memset(__dst, 32, 6);
  v6 = uprv_malloc(0x98uLL);
  *(_QWORD *)(a1 + 16) = v6;
  if (!v6)
  {
    v14 = 7;
LABEL_16:
    *a3 = v14;
    return;
  }
  v7 = v6;
  memset(v24, 0, sizeof(v24));
  v22 = 0;
  memset(v21, 0, sizeof(v21));
  LODWORD(v21[0]) = 40;
  v8 = *(unsigned __int8 *)(a2 + 8);
  BYTE8(v21[0]) = *(_BYTE *)(a2 + 8);
  *v6 = 0u;
  v6[1] = 0u;
  v6[2] = 0u;
  v6[3] = 0u;
  v6[4] = 0u;
  v6[5] = 0u;
  v6[6] = 0u;
  v6[7] = 0u;
  v6[8] = 0u;
  *((_QWORD *)v6 + 18) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  v9 = *(const char **)(a2 + 32);
  if (!v9)
  {
    *((_DWORD *)v6 + 27) = *(_DWORD *)(a2 + 12) & 0xF;
    goto LABEL_15;
  }
  strncpy(__dst, v9, 6uLL);
  v10 = __dst[0];
  v11 = *(_DWORD *)(a2 + 12) & 0xF;
  *((_DWORD *)v7 + 27) = v11;
  if (v10 != 107)
  {
    if (v10 == 106)
    {
      if ((__dst[1] == 112 || __dst[1] == 97) && (__dst[2] == 95 || !__dst[2]) && v11 < 5)
      {
        if (v11 > 1)
        {
          *((_QWORD *)v7 + 2) = sub_18BC15C78("ISO8859_7", v24, v21, a3);
          *((_QWORD *)v7 + 4) = sub_18BC15C78("Shift-JIS", v24, v21, a3);
          *((_QWORD *)v7 + 5) = sub_18BC15C78("jisx-212", v24, v21, a3);
          *((_QWORD *)v7 + 6) = sub_18BC15C78("ibm-5478", v24, v21, a3);
          v12 = "ksc_5601";
          v13 = 7;
        }
        else
        {
          *((_QWORD *)v7 + 4) = sub_18BC15C78("Shift-JIS", v24, v21, a3);
          if (!v11)
          {
LABEL_39:
            v17 = &unk_1E224D028;
            *(_QWORD *)(a1 + 48) = &unk_1E224D028;
            strcpy((char *)v7 + 143, "ja");
            strcpy((char *)v7 + 113, "ISO_2022,locale=ja,version=");
            v18 = (char *)v7 + strlen((const char *)v7 + 113) + 113;
            *v18 = *((_BYTE *)v7 + 108) + 48;
            v18[1] = 0;
            goto LABEL_50;
          }
          v12 = "jisx-212";
          v13 = 5;
        }
        *((_QWORD *)v7 + v13) = sub_18BC15C78((unsigned __int8 *)v12, v24, v21, a3);
        goto LABEL_39;
      }
      goto LABEL_15;
    }
    if ((v10 == 122 && __dst[1] == 104 || v10 == 99 && __dst[1] == 110) && (__dst[2] == 95 || !__dst[2]) && v11 < 3)
    {
      *((_QWORD *)v7 + 1) = sub_18BC15C78("ibm-5478", v24, v21, a3);
      if (v11 == 1)
        *((_QWORD *)v7 + 2) = sub_18BC15C78("iso-ir-165", v24, v21, a3);
      *((_QWORD *)v7 + 3) = sub_18BC15C78("cns-11643-1992", v24, v21, a3);
      *(_QWORD *)(a1 + 48) = &unk_1E224D278;
      strcpy((char *)v7 + 143, "cn");
      if (v11)
      {
        if (v11 == 1)
        {
          *((_DWORD *)v7 + 27) = 1;
          v16 = "ISO_2022,locale=zh,version=1";
        }
        else
        {
          *((_DWORD *)v7 + 27) = 2;
          v16 = "ISO_2022,locale=zh,version=2";
        }
        *(_OWORD *)((char *)v7 + 113) = *(_OWORD *)v16;
        *(_OWORD *)((char *)v7 + 126) = *(_OWORD *)(v16 + 13);
      }
      else
      {
        *((_DWORD *)v7 + 27) = 0;
        strcpy((char *)v7 + 113, "ISO_2022,locale=zh,version=0");
      }
      v17 = &unk_1E224D278;
      goto LABEL_50;
    }
LABEL_15:
    v14 = 2;
    goto LABEL_16;
  }
  if (__dst[1] != 114 && __dst[1] != 111 || __dst[2] != 95 && __dst[2] || v11 >= 2)
    goto LABEL_15;
  if (v11 == 1)
  {
    v15 = "icu-internal-25546";
  }
  else
  {
    *((_DWORD *)v7 + 27) = 0;
    v15 = "ibm-949";
  }
  if (v8)
  {
    sub_18BC1638C((unsigned __int8 *)v15, a3);
    uprv_free(*(void **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    return;
  }
  v19 = ucnv_open((unsigned __int8 *)v15, a3);
  *((_QWORD *)v7 + 10) = v19;
  if (*(int *)a3 >= 1)
    goto LABEL_52;
  if (v11 == 1)
  {
    strcpy((char *)v7 + 113, "ISO_2022,locale=ko,version=1");
    **(_DWORD **)(a1 + 40) = **((_DWORD **)v19 + 5);
    v19 = (_OWORD *)*((_QWORD *)v7 + 10);
    *(_BYTE *)(a1 + 89) = *((_BYTE *)v19 + 89);
  }
  else
  {
    strcpy((char *)v7 + 113, "ISO_2022,locale=ko,version=0");
  }
  v20 = *((_DWORD *)v7 + 27);
  if (v20 == 1)
  {
    *((_QWORD *)v19 + 9) = 0;
    *((_BYTE *)v19 + 64) = 0;
  }
  if (!*(_BYTE *)(a1 + 91))
  {
    *(_BYTE *)(a1 + 91) = 4;
    *(_DWORD *)(a1 + 104) = 1126769691;
  }
  if (v20 == 1)
    *((_QWORD *)v19 + 10) = 1;
  v17 = &unk_1E224D150;
  *(_QWORD *)(a1 + 48) = &unk_1E224D150;
  strcpy((char *)v7 + 143, "ko");
LABEL_50:
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(v17[2] + 71);
  if (*(int *)a3 > 0 || *(_BYTE *)(a2 + 8))
LABEL_52:
    sub_18BC126CC(a1);
}

void sub_18BC126CC(uint64_t a1)
{
  uint64_t v1;
  uint64_t i;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
  {
    for (i = 0; i != 80; i += 8)
    {
      v4 = *(_QWORD *)(v1 + i);
      if (v4)
        sub_18BC15BD4(v4);
    }
    ucnv_close(*(_QWORD **)(v1 + 80));
    if (!*(_BYTE *)(a1 + 62))
    {
      uprv_free(*(void **)(a1 + 16));
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
}

double sub_18BC12730(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  double result;

  v2 = *(_QWORD *)(a1 + 16);
  if (a2 > 1)
  {
    *(_WORD *)(v2 + 102) = 0;
    *(_DWORD *)(v2 + 98) = 0;
    if (*(_BYTE *)(v2 + 143) != 107)
      return result;
  }
  else
  {
    *(_WORD *)(v2 + 96) = 0;
    *(_DWORD *)(v2 + 92) = 0;
    *(_DWORD *)(v2 + 104) = 0;
    *(_BYTE *)(v2 + 112) = 0;
    if (a2 == 1)
    {
      if (*(_BYTE *)(v2 + 143) == 107 && *(_DWORD *)(v2 + 108) == 1)
      {
        v3 = *(_QWORD *)(v2 + 80);
        *(_QWORD *)(v3 + 72) = 0;
        *(_BYTE *)(v3 + 64) = 0;
      }
      return result;
    }
    *(_WORD *)(v2 + 102) = 0;
    *(_DWORD *)(v2 + 98) = 0;
    if (*(_BYTE *)(v2 + 143) != 107)
      return result;
    if (*(_DWORD *)(v2 + 108) == 1)
    {
      v4 = *(_QWORD *)(v2 + 80);
      *(_QWORD *)(v4 + 72) = 0;
      *(_BYTE *)(v4 + 64) = 0;
    }
  }
  if (!*(_BYTE *)(a1 + 91))
  {
    *(_BYTE *)(a1 + 91) = 4;
    *(_QWORD *)&result = 1126769691;
    *(_DWORD *)(a1 + 104) = 1126769691;
  }
  if (*(_DWORD *)(v2 + 108) == 1)
  {
    *(_QWORD *)&result = 1;
    *(_QWORD *)(*(_QWORD *)(v2 + 80) + 80) = 1;
  }
  return result;
}

uint64_t sub_18BC127FC(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
    return v1 + 113;
  else
    return 0;
}

_QWORD *sub_18BC12810(_QWORD *a1, int a2, int *a3)
{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  int v8;
  char *v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  _QWORD *result;
  uint64_t v16;
  int v17;
  int v18;
  char *v19;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  v5 = a1[1];
  v6 = *(_QWORD *)(v5 + 16);
  v20[0] = 0;
  v7 = *(char **)(v5 + 40);
  v8 = *(char *)(v6 + 143);
  if (v8 == 99)
  {
    v9 = (char *)v20;
    if (!*(_BYTE *)(v6 + 102))
      goto LABEL_14;
    *(_BYTE *)(v6 + 102) = 0;
LABEL_13:
    v9 = (char *)v20 + 1;
    LOBYTE(v20[0]) = 15;
    goto LABEL_14;
  }
  if (v8 != 107)
  {
    if (v8 != 106)
    {
      v9 = (char *)v20;
      return ucnv_cbFromUWriteBytes(a1, (char *)v20, v9 - v20, a2, a3);
    }
    v9 = (char *)v20;
    if (*(_BYTE *)(v6 + 102) == 1)
    {
      *(_BYTE *)(v6 + 102) = 0;
      v9 = (char *)v20 + 1;
      LOBYTE(v20[0]) = 15;
    }
    if (*(_BYTE *)(v6 + 98))
      v10 = *(_BYTE *)(v6 + 98) == 3;
    else
      v10 = 1;
    if (!v10)
    {
      *(_BYTE *)(v6 + 98) = 0;
      *v9 = 27;
      *(_WORD *)(v9 + 1) = 16936;
      v9 += 3;
    }
LABEL_14:
    *v9 = *v7;
    LODWORD(v9) = (_DWORD)v9 + 1;
    return ucnv_cbFromUWriteBytes(a1, (char *)v20, v9 - v20, a2, a3);
  }
  v11 = *(unsigned __int8 *)(v5 + 89);
  if (!*(_DWORD *)(v6 + 108))
  {
    v18 = *(_DWORD *)(v5 + 80);
    if (v11 != 1)
    {
      v19 = (char *)v20;
      if (!v18)
      {
        *(_DWORD *)(v5 + 80) = 1;
        v19 = (char *)v20 + 1;
        LOBYTE(v20[0]) = 14;
      }
      *v19 = *v7;
      LODWORD(v9) = (_DWORD)v19 + 2;
      v19[1] = v7[1];
      return ucnv_cbFromUWriteBytes(a1, (char *)v20, v9 - v20, a2, a3);
    }
    v9 = (char *)v20;
    if (!v18)
      goto LABEL_14;
    *(_DWORD *)(v5 + 80) = 0;
    goto LABEL_13;
  }
  v12 = *(_QWORD *)(v6 + 80);
  v13 = *(_QWORD *)(v12 + 40);
  v14 = *(_BYTE *)(v12 + 89);
  *(_QWORD *)(v12 + 40) = v7;
  *(_BYTE *)(v12 + 89) = v11;
  a1[1] = v12;
  *(_DWORD *)(v12 + 84) = *(_DWORD *)(v5 + 84);
  result = (_QWORD *)ucnv_cbFromUWriteSub((uint64_t)a1, 0, a3);
  v16 = *(_QWORD *)(v6 + 80);
  *(_DWORD *)(v5 + 84) = *(_DWORD *)(v16 + 84);
  a1[1] = v5;
  *(_QWORD *)(v16 + 40) = v13;
  *(_BYTE *)(v16 + 89) = v14;
  if (*a3 == 15)
  {
    v17 = *(char *)(v16 + 91);
    if (v17 >= 1)
    {
      result = memcpy((void *)(v5 + 104), (const void *)(v16 + 104), *(unsigned __int8 *)(v16 + 91));
      v16 = *(_QWORD *)(v6 + 80);
      LOBYTE(v17) = *(_BYTE *)(v16 + 91);
    }
    *(_BYTE *)(v5 + 91) = v17;
    *(_BYTE *)(v16 + 91) = 0;
  }
  return result;
}

uint64_t sub_18BC12A14(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  void (**v14)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t i;
  uint64_t v17;
  int v18;

  if (*a4 > 0)
    return 0;
  if (!*a3)
  {
    v4 = 0;
    *a3 = 728;
    return v4;
  }
  v4 = a2;
  v18 = 0;
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(v6 + 144);
  v8 = *(_OWORD *)(v6 + 96);
  v9 = *(_OWORD *)(v6 + 128);
  *(_OWORD *)(a2 + 688) = *(_OWORD *)(v6 + 112);
  *(_OWORD *)(a2 + 704) = v9;
  *(_OWORD *)(a2 + 672) = v8;
  *(_QWORD *)(a2 + 720) = v7;
  v10 = *(_OWORD *)(v6 + 16);
  *(_OWORD *)(a2 + 576) = *(_OWORD *)v6;
  *(_OWORD *)(a2 + 592) = v10;
  v11 = *(_OWORD *)(v6 + 32);
  v12 = *(_OWORD *)(v6 + 48);
  v13 = *(_OWORD *)(v6 + 80);
  *(_OWORD *)(a2 + 640) = *(_OWORD *)(v6 + 64);
  *(_OWORD *)(a2 + 656) = v13;
  *(_OWORD *)(a2 + 608) = v11;
  *(_OWORD *)(a2 + 624) = v12;
  *(_QWORD *)(a2 + 16) = a2 + 576;
  *(_BYTE *)(a2 + 62) = 1;
  v14 = *(void (***)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v6 + 80);
  if (v14)
  {
    v18 = 288;
    *(_QWORD *)(a2 + 656) = ucnv_safeClone(v14, a2 + 288, &v18, a4);
    if (*a4 > 0)
      return 0;
  }
  for (i = 0; i != 80; i += 8)
  {
    v17 = *(_QWORD *)(v6 + i);
    if (v17)
      sub_18BC15C24(v17);
  }
  return v4;
}

uint64_t sub_18BC12B04(uint64_t result, uint64_t *a2, uint64_t a3, int *a4)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  uint64_t i;
  uint64_t v14;
  int v15;
  int v16;

  if (*a4 > 0)
    return result;
  v7 = *(_QWORD *)(result + 16);
  v8 = *(char *)(v7 + 143);
  if (v8 <= 106)
  {
    if (v8 != 99)
    {
      if (v8 == 106)
      {
        ((void (*)(uint64_t, uint64_t))a2[1])(*a2, 165);
        ((void (*)(uint64_t, uint64_t))a2[1])(*a2, 8254);
        v9 = *(_DWORD *)(v7 + 108) >= 2u ? 255 : 127;
        ((void (*)(uint64_t, _QWORD, uint64_t))a2[2])(*a2, 0, v9);
        v10 = *(_DWORD *)(v7 + 108);
        v11 = v10 == 3 || (_DWORD)a3 == 1;
        if (v11 || v10 == 4)
          ((void (*)(uint64_t, uint64_t, uint64_t))a2[2])(*a2, 65377, 65439);
      }
      goto LABEL_21;
    }
LABEL_19:
    ((void (*)(uint64_t, _QWORD, uint64_t))a2[2])(*a2, 0, 127);
    goto LABEL_21;
  }
  if (v8 != 107)
  {
    if (v8 != 122)
      goto LABEL_21;
    goto LABEL_19;
  }
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 80) + 48) + 32) + 120))();
LABEL_21:
  for (i = 0; i != 80; i += 8)
  {
    v14 = *(_QWORD *)(v7 + i);
    if (v14)
    {
      v15 = *(unsigned __int8 *)(v7 + 143);
      if (i == 32 && v15 == 106)
      {
        v16 = 3;
      }
      else if ((v15 == 122 || v15 == 99) && i == 24 && !*(_DWORD *)(v7 + 108))
      {
        v16 = 2;
      }
      else
      {
        v16 = 4 * (i == 56);
      }
      sub_18BC25E90(v14, a2, a3, v16, a4);
    }
  }
  ((void (*)(uint64_t, uint64_t))a2[4])(*a2, 14);
  ((void (*)(uint64_t, uint64_t))a2[4])(*a2, 15);
  ((void (*)(uint64_t, uint64_t))a2[4])(*a2, 27);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))a2[5])(*a2, 128, 159);
}

uint64_t sub_18BC12CDC(_QWORD *a1, int *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  _QWORD *v6;
  unint64_t v7;
  _WORD *v8;
  uint64_t v9;
  _BYTE *v10;
  char v11;
  int v12;
  BOOL v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned __int8 v21;
  char v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  char v27;
  unsigned __int8 v28;
  unsigned int v29;
  int v30;
  char v31;
  char v32;
  char v33;
  BOOL v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  _WORD *v42;
  _BYTE *v43;
  char v44;
  unsigned __int8 *v45;
  __int16 v46;

  v46 = 0;
  v6 = a1 + 1;
  result = a1[1];
  v5 = (unsigned __int8 *)v6[1];
  v45 = v5;
  v7 = a1[3];
  v8 = (_WORD *)a1[4];
  v9 = *(_QWORD *)(result + 16);
  v10 = (_BYTE *)(v9 + 92);
  if (!*(_DWORD *)(v9 + 104))
  {
    v13 = *(_BYTE *)(result + 64) != 1 || (unint64_t)v5 >= v7;
    if (v13 || (unint64_t)v8 >= a1[5])
      goto LABEL_20;
    v14 = *(unsigned __int8 *)(result + 65);
    *(_BYTE *)(result + 64) = 0;
    v15 = (char)v10[*(char *)(v9 + 96)];
    goto LABEL_66;
  }
LABEL_2:
  v11 = *(_BYTE *)(result + 64);
  result = (uint64_t)sub_18BC13E04((_QWORD *)result, (unint64_t *)&v45, v7, 1, a2);
  if (*(_DWORD *)(v9 + 108))
  {
    v12 = *a2;
    goto LABEL_5;
  }
  v12 = *a2;
  if (*(_DWORD *)(v9 + 104))
  {
LABEL_5:
    if (v12 >= 1)
      goto LABEL_18;
    goto LABEL_6;
  }
  if (v12 > 0)
    goto LABEL_18;
  if (*(_BYTE *)(v9 + 112))
  {
    *a2 = 18;
    v16 = a1[1];
    *(_DWORD *)(v16 + 284) = 2;
    *(_BYTE *)(v16 + 64) = v11 + (_BYTE)v45 - (_BYTE)v5;
LABEL_18:
    a1[4] = v8;
    a1[2] = v45;
    *(_BYTE *)(v9 + 112) = 0;
    return result;
  }
LABEL_6:
  if (!*(_DWORD *)(v9 + 104))
    *(_BYTE *)(v9 + 112) = 1;
  v5 = v45;
LABEL_20:
  if ((unint64_t)v5 >= v7)
    goto LABEL_32;
  v19 = v7 - (_QWORD)v5;
  while (2)
  {
    if ((unint64_t)v8 >= a1[5])
    {
      v23 = 15;
      goto LABEL_31;
    }
    v20 = *v5;
    v21 = *v5;
    switch(*v5)
    {
      case 0xAu:
      case 0xDu:
        v45 = v5 + 1;
        v15 = *v10;
        if (*v10 && v15 != 3)
        {
          LOBYTE(v15) = 0;
          *v10 = 0;
        }
        *(_BYTE *)(v9 + 94) = 0;
        *(_BYTE *)(v9 + 96) = 0;
        *(_BYTE *)(v9 + 112) = 0;
        goto LABEL_46;
      case 0xBu:
      case 0xCu:
        goto LABEL_40;
      case 0xEu:
        if (*(_DWORD *)(v9 + 108) != 3)
        {
          v45 = ++v5;
          *(_BYTE *)(v9 + 112) = 0;
          LODWORD(v20) = 14;
          goto LABEL_52;
        }
        *(_BYTE *)(v9 + 93) = 8;
        v22 = 1;
        goto LABEL_28;
      case 0xFu:
        if (*(_DWORD *)(v9 + 108) == 3)
        {
          v22 = 0;
LABEL_28:
          *(_BYTE *)(v9 + 96) = v22;
          ++v5;
          if (!--v19)
          {
            v5 = (unsigned __int8 *)v7;
            goto LABEL_32;
          }
          continue;
        }
        v45 = ++v5;
        *(_BYTE *)(v9 + 112) = 0;
        LODWORD(v20) = 15;
LABEL_52:
        result = 0xFFFFLL;
LABEL_91:
        if (result <= 0xFFFD)
        {
          v35 = a1[6];
          if (v35)
          {
            if (v20 >= 0x100)
              v36 = -2;
            else
              v36 = -1;
            *(_DWORD *)(v35 + 2 * ((_QWORD)v8 - a1[4])) = v36 + (_DWORD)v5 - *((_DWORD *)a1 + 4);
          }
          *v8++ = result;
          goto LABEL_20;
        }
        if (result >= 0x10000)
        {
          *v8 = ((result + 67043328) >> 10) - 10240;
          v37 = a1[6];
          if (v37)
          {
            if (v20 >= 0x100)
              v38 = -2;
            else
              v38 = -1;
            v39 = v38 + (_DWORD)v5 - *((_DWORD *)a1 + 4);
            v40 = a1[4];
            v41 = a1[5];
            *(_DWORD *)(v37 + 2 * ((_QWORD)v8 - v40)) = v39;
            v42 = v8 + 1;
            if ((unint64_t)(v8 + 1) < v41)
            {
              *v42 = result & 0x3FF | 0xDC00;
              *(_DWORD *)(v37 + 2 * ((_QWORD)v42 - v40)) = v39;
LABEL_107:
              v8 += 2;
              goto LABEL_20;
            }
          }
          else
          {
            v42 = v8 + 1;
            if ((unint64_t)(v8 + 1) < a1[5])
            {
              *v42 = result & 0x3FF | 0xDC00;
              goto LABEL_107;
            }
          }
          v17 = a1[1];
          v18 = *(char *)(v17 + 93);
          *(_BYTE *)(v17 + 93) = v18 + 1;
          *(_WORD *)(v17 + 2 * v18 + 144) = result & 0x3FF | 0xDC00;
          v8 = v42;
          goto LABEL_20;
        }
        v43 = (_BYTE *)a1[1];
        if (v20 < 0x100)
        {
          v44 = 1;
        }
        else
        {
          v43[66] = v20;
          LODWORD(v20) = v20 >> 8;
          v44 = 2;
        }
        v43[65] = v20;
        v43[64] = v44;
        if ((_DWORD)result == 65534)
          v23 = 10;
        else
          v23 = 12;
LABEL_31:
        *a2 = v23;
LABEL_32:
        a1[4] = v8;
        a1[2] = v5;
        return result;
      default:
        if ((_DWORD)v20 != 27)
        {
LABEL_40:
          v45 = v5 + 1;
          *(_BYTE *)(v9 + 112) = 0;
          v24 = *(char *)(v9 + 96);
          LOBYTE(v15) = v10[v24];
          if (((char)v20 + 95) <= 0x3E && *(_DWORD *)(v9 + 108) == 4 && (v15 & 0xFC) != 4)
          {
            result = (v20 + 65216);
            if ((int)v24 >= 2)
              *(_BYTE *)(v9 + 96) = *(_BYTE *)(v9 + 97);
            ++v5;
            goto LABEL_91;
          }
LABEL_46:
          v15 = (char)v15;
          ++v5;
          switch((char)v15)
          {
            case 0:
              if ((v20 & 0x80u) != 0)
                result = 0xFFFFLL;
              else
                result = v20;
              goto LABEL_91;
            case 1:
              *(_BYTE *)(v9 + 96) = *(_BYTE *)(v9 + 97);
              if ((v20 & 0x80u) != 0)
                result = 0xFFFFLL;
              else
                result = (v20 + 128);
              goto LABEL_91;
            case 2:
              result = 0xFFFFLL;
              if (((char)v20 & 0x80000000) == 0)
                result = *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v9 + 16) + 56) + 4 * (v21 ^ 0x80u));
              *(_BYTE *)(v9 + 96) = *(_BYTE *)(v9 + 97);
              goto LABEL_91;
            case 3:
              result = 0xFFFFLL;
              if ((char)v20 < 0)
                goto LABEL_91;
              if ((char)v20 < 0x5C)
                goto LABEL_113;
              if ((_DWORD)v20 == 126)
              {
                result = 8254;
              }
              else if ((_DWORD)v20 == 92)
              {
                result = 165;
              }
              else
              {
LABEL_113:
                result = v20;
              }
              goto LABEL_91;
            case 8:
              if (((char)v20 - 33) >= 0x3F)
                result = 0xFFFFLL;
              else
                result = (v20 + 65344);
              goto LABEL_91;
            default:
              if ((unint64_t)v5 >= v7)
              {
                *(_BYTE *)(a1[1] + 65) = v21;
                *(_BYTE *)(a1[1] + 64) = 1;
                goto LABEL_32;
              }
              v14 = v20;
              break;
          }
LABEL_66:
          v25 = *v5;
          LODWORD(v20) = v25 | (v14 << 8);
          if ((((_BYTE)v14 - 33) & 0xFEu) > 0x5D || (v25 - 33) > 0x5Du)
          {
            result = 0xFFFFLL;
            if ((v25 - 33) >= 0x5Eu
              && (v25 <= 0x1F ? (v34 = ((1 << v25) & 0x800C000) == 0) : (v34 = 1), v34))
            {
              v45 = ++v5;
              LODWORD(v20) = v20 + 0x10000;
            }
            else
            {
              LODWORD(v20) = v14;
            }
            goto LABEL_91;
          }
          v45 = ++v5;
          if (v15 == 7)
          {
            v26 = v20 + 32896;
          }
          else
          {
            v26 = v25 | (v14 << 8);
            if (v15 == 4)
            {
              if (v25 < 0x60)
                v27 = 31;
              else
                v27 = 32;
              if ((v14 & 1) == 0)
                v27 = 126;
              v28 = (v14 & 1) + v14;
              v29 = v28;
              v30 = (char)v28;
              v31 = v25 + v27;
              v28 >>= 1;
              v32 = v28 + 112;
              v33 = v28 - 80;
              if (v30 < 0)
                v33 = 0;
              if (v29 < 0x60)
                v33 = v32;
              LOBYTE(v46) = v33;
              HIBYTE(v46) = v31;
              goto LABEL_90;
            }
          }
          v46 = bswap32(v26) >> 16;
LABEL_90:
          result = sub_18BC2735C(*(_QWORD *)(v9 + 8 * v15), (uint64_t)&v46, 2);
          goto LABEL_91;
        }
        v45 = v5;
        result = a1[1];
        goto LABEL_2;
    }
  }
}

unint64_t sub_18BC132A4(unint64_t result, int *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 *v5;
  unint64_t v6;
  _WORD *v7;
  unint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  BOOL v11;
  unsigned int v12;
  int v13;
  unsigned int v15;
  uint64_t v16;
  int v17;
  char v18;
  unsigned int v19;
  char v20;
  uint64_t i;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  _BOOL4 v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  int v60;
  uint64_t v63;
  BOOL v64;
  int v65;
  int v66;
  int v67;
  int v68;
  unsigned int v69;
  int v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  char v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  _DWORD *v82;
  unint64_t v83;
  int v84;
  uint64_t v85;
  _DWORD *v86;
  int v87;
  int v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unsigned int v92;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  uint64_t v97;
  unint64_t v98;
  _BYTE *v99;
  unint64_t v100;
  unint64_t v101;
  unsigned int v102;
  unsigned __int16 *v103;
  _WORD *v104;
  unsigned int v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  uint64_t v109;
  unsigned int v110;
  unsigned int v111;
  int v112;
  int v113;
  uint64_t v114;
  _DWORD *v115;
  _WORD *v116;
  uint64_t v117;
  __int16 v118;
  _QWORD v119[3];

  v2 = 0;
  v3 = 0;
  v119[1] = *MEMORY[0x1E0C80C00];
  v5 = *(unsigned __int16 **)(result + 16);
  v6 = *(_QWORD *)(result + 24);
  v7 = *(_WORD **)(result + 32);
  v8 = *(_QWORD *)(result + 40);
  v97 = *(_QWORD *)(result + 8);
  v4 = v97;
  v98 = result;
  v115 = *(_DWORD **)(result + 48);
  v119[0] = 0;
  v118 = 0;
  v117 = 0;
  v114 = *(_QWORD *)(v97 + 16);
  v9 = (_BYTE *)(v114 + 98);
  LODWORD(v10) = *(_DWORD *)(v97 + 84);
  v100 = v6;
  v101 = v8;
  if ((_DWORD)v10)
    v11 = (unint64_t)v7 >= v8;
  else
    v11 = 1;
  v99 = (_BYTE *)(v114 + 98);
  if (v11)
    goto LABEL_6;
LABEL_10:
  if ((unint64_t)v5 >= v100)
  {
    *(_DWORD *)(v4 + 84) = v10;
LABEL_143:
    if (*a2 <= 0
      && (*(_BYTE *)(v114 + 102) || *v9)
      && *(_BYTE *)(v98 + 2)
      && (unint64_t)v5 >= v100
      && !*(_DWORD *)(v4 + 84))
    {
      if (*(_BYTE *)(v114 + 102))
      {
        LOBYTE(v119[0]) = 15;
        *(_BYTE *)(v114 + 102) = 0;
        v69 = 1;
      }
      else
      {
        v69 = 0;
      }
      if (*v9)
      {
        v89 = (unint64_t)v119 | v69;
        *(_BYTE *)(v89 + 2) = 66;
        *(_WORD *)v89 = 10267;
        v69 += 3;
        *v9 = 0;
      }
      v90 = *(_QWORD *)(v98 + 16);
      v91 = ((unint64_t)v5 - v90) >> 1;
      v92 = v91 - 1;
      if ((int)v91 < 1)
      {
        v92 = -1;
      }
      else if ((*(_WORD *)(v90 + 2 * v92) & 0xFC00) == 0xDC00
             && ((_DWORD)v91 == 1 || (*(_WORD *)(v90 + 2 * (v91 - 2)) & 0xFC00) == 0xD800))
      {
        v92 = v91 - 2;
      }
      v116 = v7;
      result = sub_18BC17544(v4, (char *)v119, v69, &v116, v101, &v115, v92, a2);
      v7 = v116;
    }
    goto LABEL_187;
  }
  v13 = *v5;
  if ((v13 & 0xFC00) != 0xDC00)
  {
LABEL_135:
    *a2 = 12;
    *(_DWORD *)(v4 + 84) = v10;
    goto LABEL_187;
  }
  ++v5;
  v10 = (v13 + ((_DWORD)v10 << 10) - 56613888);
  *(_DWORD *)(v4 + 84) = 0;
LABEL_13:
  if ((int)v10 <= 31 && ((1 << v10) & 0x800C000) != 0)
    goto LABEL_135;
  v104 = v7;
  if (!(_DWORD)v2)
  {
    v15 = 0;
    v16 = *(unsigned int *)(v114 + 108);
    v17 = word_18BE12A24[v16];
    if ((v16 - 3) <= 1)
    {
      LOBYTE(v117) = 8;
      v15 = 1;
    }
    v18 = *(_BYTE *)(v114 + 98);
    v2 = v15 + 1;
    *(_BYTE *)((unint64_t)&v117 | v15) = v18;
    v19 = v17 & ~(1 << v18) & 0xFFFFFEFF;
    v20 = *(_BYTE *)(v114 + 100);
    if (v20)
    {
      *(_BYTE *)((unint64_t)&v117 | v2) = v20;
      v19 &= (unsigned __int16)~(unsigned __int16)(1 << v20);
      v2 = v15 | 2;
    }
    for (i = 0; i != 9; ++i)
    {
      v22 = dword_18BE12D9C[i];
      if (((1 << v22) & v19) != 0)
      {
        *((_BYTE *)&v117 + (int)v2) = v22;
        v19 &= (unsigned __int16)~(unsigned __int16)(1 << v22);
        v2 = (v2 + 1);
      }
    }
  }
  if ((int)v2 < 1)
    goto LABEL_134;
  v103 = v5;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = *(unsigned __int8 *)(v4 + 63);
  v28 = (uint64_t)(int)v10 >> 10;
  v29 = (v10 >> 4) & 0x3F;
  v30 = v10 & 0xF;
  v31 = 1 << (v10 & 0xF | 0x10);
  v105 = v10 - 57344;
  v102 = v10 - 983040;
  v32 = (v10 - 65377);
  v95 = v10 - 65216;
  v94 = v10 - 65344;
  v33 = (v10 - 160);
  v96 = v10 - 128;
  v34 = v2;
  v109 = v2;
  v108 = v31;
  v106 = v10;
  v107 = v32;
  while (2)
  {
    LODWORD(v116) = 0;
    v35 = *((unsigned __int8 *)&v117 + v23);
    v36 = *((char *)&v117 + v23);
    switch(*((_BYTE *)&v117 + v23))
    {
      case 0:
        if ((int)v10 >= 128)
          goto LABEL_128;
        LODWORD(v24) = 0;
        v3 = v10;
        goto LABEL_141;
      case 1:
        if (v33 >= 0x60)
          goto LABEL_128;
        LODWORD(v24) = 2;
        v5 = v103;
        v4 = v97;
        v9 = (_BYTE *)(v114 + 98);
        v3 = v96;
        goto LABEL_153;
      case 2:
        v37 = *(_QWORD *)(v114 + 8 * v36);
        if ((int)v10 >= 0x10000 && (*(_BYTE *)(v37 + 253) & 1) == 0)
          goto LABEL_128;
        v38 = *(unsigned __int16 *)(*(_QWORD *)(v37 + 232)
                                  + 2
                                  * (v30
                                   + *(unsigned __int16 *)(*(_QWORD *)(v37 + 88)
                                                         + 2
                                                         * (v29 + *(unsigned __int16 *)(*(_QWORD *)(v37 + 88) + 2 * v28)))));
        if (v38 <= 0xEFF)
        {
          if ((_BYTE)v27)
          {
            if (v38 <= 0x7FF)
              goto LABEL_128;
          }
          else if (v38 < 0xC00)
          {
            v27 = 0;
            goto LABEL_128;
          }
          v39 = -1;
        }
        else
        {
          v39 = 1;
        }
        if (v26)
          v64 = v38 > 0xEFF;
        else
          v64 = 1;
        if (v64 && v38 >= 0xA0u)
        {
          v27 = 0;
          v3 = v38 - 128;
          v24 = 2;
          goto LABEL_126;
        }
        goto LABEL_128;
      case 3:
        if (v10 > 0x7F)
        {
          if ((_DWORD)v10 == 165)
          {
            v3 = 92;
            goto LABEL_151;
          }
          if ((_DWORD)v10 == 8254)
          {
            LODWORD(v24) = 0;
            v3 = 126;
            goto LABEL_141;
          }
        }
        else if ((_DWORD)v10 != 92 && (_DWORD)v10 != 126)
        {
          v3 = v10;
LABEL_151:
          v5 = v103;
          LODWORD(v24) = 0;
          goto LABEL_152;
        }
        goto LABEL_128;
      case 4:
        v41 = *(_QWORD *)(v114 + 8 * v36);
        if ((int)v10 >= 0x10000 && (*(_BYTE *)(v41 + 253) & 1) == 0)
          goto LABEL_73;
        v42 = *(unsigned __int16 *)(*(_QWORD *)(v41 + 232)
                                  + 2
                                  * (v30 & 0xFFF0000F | (16
                                                       * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v41 + 88) + 4 * (v29 + *(unsigned __int16 *)(*(_QWORD *)(v41 + 88) + 2 * v28))))));
        if (v42 >= 0x100)
          result = 4294967294;
        else
          result = 0xFFFFFFFFLL;
        if ((*(_DWORD *)(*(_QWORD *)(v41 + 88) + 4 * (v29 + *(unsigned __int16 *)(*(_QWORD *)(v41 + 88) + 2 * v28))) & v31) != 0)
        {
          if (v42 < 0x100)
            goto LABEL_76;
          v39 = 2;
LABEL_115:
          if (v42 > 0xEFFC)
            goto LABEL_128;
          v27 = 0;
          v24 = 0;
          if ((v42 & 0xFF00) >= 0x9F01)
            v65 = -45056;
          else
            v65 = -28672;
          v66 = 2 * (v65 + (v42 & 0xFF00));
          if (v42 >= 0x7Fu)
            v67 = -32;
          else
            v67 = -31;
          if (v42 >= 0x9Fu)
          {
            v68 = -126;
          }
          else
          {
            v66 -= 256;
            v68 = v67;
          }
          v3 = v66 | (v68 + v42);
LABEL_126:
          v26 = v39;
LABEL_127:
          v25 = v35;
          goto LABEL_128;
        }
        if (((_BYTE)v27 || v105 >> 8 < 0x19 || !(v102 >> 17))
          && *(_WORD *)(*(_QWORD *)(v41 + 232)
                      + 2
                      * (v30 & 0xFFF0000F | (16
                                           * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v41 + 88)
                                                                                       + 4
                                                                                       * (v29
                                                                                        + *(unsigned __int16 *)(*(_QWORD *)(v41 + 88) + 2 * v28)))))))
        {
          LODWORD(v116) = *(unsigned __int16 *)(*(_QWORD *)(v41 + 232)
                                              + 2
                                              * (v30 & 0xFFF0000F | (16
                                                                   * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v41 + 88) + 4 * (v29 + *(unsigned __int16 *)(*(_QWORD *)(v41 + 88) + 2 * v28))))));
        }
        else
        {
LABEL_73:
          result = *(_QWORD *)(v41 + 288);
          if (!result)
          {
LABEL_76:
            v52 = v26 == 0;
LABEL_89:
            if (v52 && (_BYTE)v27)
            {
              if (v32 <= 0x3E)
              {
                v27 = 0;
                v24 = 0;
                v3 = word_18BE12DC0[v32];
                v26 = -2;
                goto LABEL_127;
              }
              v26 = 0;
            }
            goto LABEL_128;
          }
          v110 = *((unsigned __int8 *)&v117 + v23);
          v112 = v27;
          v45 = v10;
          v46 = v3;
          v47 = v24;
          v48 = v25;
          v49 = v30;
          v50 = v33;
          v51 = v34;
          result = sub_18BC19D3C(result, v45, (int *)&v116, (char)v27);
          v34 = v51;
          v35 = v110;
          v27 = v112;
          v33 = v50;
          v31 = v108;
          v30 = v49;
          v10 = v106;
          v32 = v107;
          v25 = v48;
          v24 = v47;
          v2 = v109;
          v3 = v46;
          if ((_DWORD)result == 2)
          {
            v39 = 2;
LABEL_114:
            v42 = v116;
            goto LABEL_115;
          }
        }
        v52 = v26 == 0;
        if ((_DWORD)result != -2 || v26 != 0)
          goto LABEL_89;
        v39 = -2;
        goto LABEL_114;
      case 8:
        if (v32 > 0x3E)
          goto LABEL_128;
        v40 = *(_DWORD *)(v114 + 108);
        if (v40 != 4)
        {
          if (v40 == 3)
          {
            *(_BYTE *)(v114 + 99) = v35;
            LODWORD(v24) = 1;
            v3 = v94;
LABEL_141:
            v5 = v103;
LABEL_152:
            v4 = v97;
            v9 = (_BYTE *)(v114 + 98);
            goto LABEL_153;
          }
LABEL_128:
          if (++v23 >= v34 || v26 >= 1)
          {
            v5 = v103;
            v4 = v97;
            v9 = (_BYTE *)(v114 + 98);
            if (v26)
              goto LABEL_154;
LABEL_134:
            *a2 = 10;
            *(_DWORD *)(v4 + 84) = v10;
            v7 = v104;
            goto LABEL_187;
          }
          continue;
        }
        LODWORD(v24) = 0;
        v9 = (_BYTE *)(v114 + 98);
        if ((*v99 & 0xFC) == 4)
          LOBYTE(v35) = 3;
        else
          LOBYTE(v35) = *v99;
        v3 = v95;
        v5 = v103;
        v4 = v97;
LABEL_153:
        v26 = 1;
        LOBYTE(v25) = v35;
LABEL_154:
        v70 = 0;
        if (v26 < 0)
          v26 = -v26;
        v71 = *(unsigned __int8 *)(v114 + 102);
        if (v71 == 1 && !(_DWORD)v24)
        {
          LOBYTE(v71) = 0;
          LOBYTE(v119[0]) = 15;
          *(_BYTE *)(v114 + 102) = 0;
          v70 = 1;
        }
        if (v9[v24] != v25)
        {
          v72 = byte_18BE12E3E[(char)v25];
          v73 = v24;
          v74 = v3;
          v75 = v24;
          v76 = v4;
          v77 = v25;
          result = (unint64_t)memcpy((void *)((unint64_t)v119 | v70), (char *)&unk_18BE12E47 + 6 * (char)v25, byte_18BE12E3E[(char)v25]);
          LODWORD(v24) = v75;
          v3 = v74;
          v2 = 0;
          v70 += v72;
          v9 = (_BYTE *)(v114 + 98);
          v99[v73] = v77;
          v4 = v76;
          LOBYTE(v71) = *(_BYTE *)(v114 + 102);
        }
        if ((_DWORD)v24 != (char)v71)
        {
          v78 = v70 + 1;
          if ((_DWORD)v24 == 1)
          {
            *((_BYTE *)v119 + v70) = 14;
            *(_BYTE *)(v114 + 102) = 1;
            ++v70;
          }
          else
          {
            *((_BYTE *)v119 + v70) = 27;
            v70 += 2;
            *((_BYTE *)v119 + v78) = 78;
          }
        }
        v79 = 1;
        v80 = v70;
        if (v26 != 1)
        {
          v80 = v70 + 1;
          *((_BYTE *)v119 + v70) = BYTE1(v3);
          v79 = 2;
        }
        v81 = v70 + v79;
        *((_BYTE *)v119 + v80) = v3;
        if ((_DWORD)v10 == 13 || (_DWORD)v10 == 10)
        {
          v2 = 0;
          *(_BYTE *)(v114 + 100) = 0;
        }
        if (v81 == 2)
        {
          if ((unint64_t)(v104 + 1) > v101)
            goto LABEL_175;
          *v104 = v119[0];
          v86 = v115;
          if (v115)
          {
            if (v10 >= 0x10000)
              v87 = -2;
            else
              v87 = -1;
            v88 = (((unint64_t)v5 - *(_QWORD *)(v98 + 16)) >> 1) + v87;
            *v115 = v88;
            v115 = v86 + 2;
            v86[1] = v88;
          }
          v7 = v104 + 1;
LABEL_6:
          if ((unint64_t)v5 >= v100)
            goto LABEL_143;
          if ((unint64_t)v7 >= v101)
          {
            *a2 = 15;
            goto LABEL_187;
          }
          v12 = *v5++;
          v10 = v12;
          if ((v12 & 0xF800) == 0xD800)
          {
            if ((v10 & 0x400) == 0)
              goto LABEL_10;
            goto LABEL_135;
          }
          goto LABEL_13;
        }
        if (v81 == 1)
        {
          *(_BYTE *)v104 = v119[0];
          v7 = (_WORD *)((char *)v104 + 1);
          v82 = v115;
          if (v115)
          {
            *v115 = (((unint64_t)v5 - *(_QWORD *)(v98 + 16)) >> 1) - 1;
            v115 = v82 + 1;
          }
          goto LABEL_6;
        }
LABEL_175:
        v83 = ((unint64_t)v5 - *(_QWORD *)(v98 + 16)) >> 1;
        if (v10 >= 0x10000)
          v84 = -2;
        else
          v84 = -1;
        v116 = v104;
        v85 = v3;
        result = sub_18BC17544(v4, (char *)v119, v81, &v116, v101, &v115, (int)v83 + v84, a2);
        v3 = v85;
        v7 = v116;
        if (*a2 < 1)
          goto LABEL_6;
LABEL_187:
        *(_QWORD *)(v98 + 16) = v5;
        *(_QWORD *)(v98 + 32) = v7;
        return result;
      default:
        v43 = *(_QWORD *)(v114 + 8 * v36);
        if ((int)v10 >= 0x10000 && (*(_BYTE *)(v43 + 253) & 1) == 0)
          goto LABEL_82;
        v44 = *(unsigned __int16 *)(*(_QWORD *)(v43 + 232)
                                  + 2
                                  * (v30 & 0xFFF0000F | (16
                                                       * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v43 + 88) + 4 * (v29 + *(unsigned __int16 *)(*(_QWORD *)(v43 + 88) + 2 * v28))))));
        if (v44 >= 0x100)
          result = 4294967294;
        else
          result = 0xFFFFFFFFLL;
        if ((*(_DWORD *)(*(_QWORD *)(v43 + 88) + 4 * (v29 + *(unsigned __int16 *)(*(_QWORD *)(v43 + 88) + 2 * v28))) & v31) != 0)
        {
          LODWORD(v116) = *(unsigned __int16 *)(*(_QWORD *)(v43 + 232)
                                              + 2
                                              * (v30 & 0xFFF0000F | (16
                                                                   * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v43 + 88) + 4 * (v29 + *(unsigned __int16 *)(*(_QWORD *)(v43 + 88) + 2 * v28))))));
          if (v44 < 0x100)
            goto LABEL_128;
LABEL_84:
          v60 = 2;
          goto LABEL_99;
        }
        if (((_BYTE)v27 || v105 >> 8 < 0x19 || !(v102 >> 17))
          && *(_WORD *)(*(_QWORD *)(v43 + 232)
                      + 2
                      * (v30 & 0xFFF0000F | (16
                                           * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v43 + 88)
                                                                                       + 4
                                                                                       * (v29
                                                                                        + *(unsigned __int16 *)(*(_QWORD *)(v43 + 88) + 2 * v28)))))))
        {
          LODWORD(v116) = *(unsigned __int16 *)(*(_QWORD *)(v43 + 232)
                                              + 2
                                              * (v30 & 0xFFF0000F | (16
                                                                   * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v43 + 88) + 4 * (v29 + *(unsigned __int16 *)(*(_QWORD *)(v43 + 88) + 2 * v28))))));
        }
        else
        {
LABEL_82:
          result = *(_QWORD *)(v43 + 288);
          if (!result)
            goto LABEL_128;
          v111 = *((unsigned __int8 *)&v117 + v23);
          v113 = v27;
          v53 = v10;
          v54 = v3;
          v55 = v24;
          v56 = v25;
          v57 = v30;
          v58 = v33;
          v59 = v34;
          result = sub_18BC19D3C(result, v53, (int *)&v116, (char)v27);
          v34 = v59;
          v35 = v111;
          v27 = v113;
          v33 = v58;
          v31 = v108;
          v30 = v57;
          v10 = v106;
          v32 = v107;
          v25 = v56;
          v24 = v55;
          v2 = v109;
          v3 = v54;
          if ((_DWORD)result == 2)
            goto LABEL_84;
        }
        if ((_DWORD)result != -2 || v26 != 0)
          goto LABEL_128;
        v60 = -2;
LABEL_99:
        v63 = v116;
        if ((_DWORD)v35 != 7
          || (((_WORD)v116 + 24159) & 0xFFFEu) <= 0x5D5D
          && (((_BYTE)v116 + 95) & 0xFEu) <= 0x5D
          && (v63 = ((_DWORD)v116 - 32896), (_DWORD)v116 != 32896))
        {
          v27 = 0;
          v24 = 0;
          v26 = v60;
          v3 = v63;
          goto LABEL_127;
        }
        goto LABEL_128;
    }
  }
}

_QWORD *sub_18BC13E04(_QWORD *result, unint64_t *a2, unint64_t a3, int a4, int *a5)
{
  unsigned __int8 *v5;
  _QWORD *v7;
  uint64_t v8;
  char v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  char v21;
  uint64_t v22;
  int v23;
  char v24;
  int v25;
  int v26;
  char v27;
  int v28;
  int v29;

  v5 = (unsigned __int8 *)*a2;
  if (*a2 >= a3)
    return result;
  v7 = result;
  v8 = result[2];
  v9 = *((_BYTE *)result + 64);
  v10 = *(_DWORD *)(v8 + 104);
  do
  {
    *a2 = (unint64_t)(v5 + 1);
    v11 = *v5;
    v12 = *((char *)v7 + 64);
    *((_BYTE *)v7 + 64) = v12 + 1;
    *((_BYTE *)v7 + v12 + 65) = v11;
    v13 = byte_18BE12C9A[v11];
    if (!byte_18BE12C9A[v11])
    {
LABEL_15:
      v10 = 0;
LABEL_16:
      *(_DWORD *)(v8 + 104) = v10;
LABEL_17:
      *a5 = 18;
LABEL_18:
      v20 = *((char *)v7 + 64);
      if (v20 >= 2)
      {
        v21 = v20 - v9;
        if ((v20 - 1) <= (char)(v20 - v9))
        {
          v22 = (v20 - 1);
        }
        else
        {
          *((_BYTE *)v7 + 282) = 1 - v9;
          result = memcpy((char *)v7 + 250, (char *)v7 + 66, -(uint64_t)(char)(1 - v9));
          v22 = v21;
        }
        *a2 -= v22;
        *((_BYTE *)v7 + 64) = 1;
      }
      return result;
    }
    v14 = 0;
    v15 = 0;
    v16 = 74;
    v10 = v13 + 32 * v10;
    while (1)
    {
      v17 = v14;
      v14 = (v15 + (int)v16) >> 1;
      if (v14 == v17)
        goto LABEL_15;
      result = (_QWORD *)dword_18BE12B28[v14];
      v18 = ((v15 + (int)v16) >> 1);
      if ((int)result <= v10)
      {
        v15 = (v15 + (int)v16) >> 1;
        v18 = v16;
        if ((int)result >= v10)
          break;
      }
      v16 = v18;
      if ((_DWORD)v18 == v15)
        goto LABEL_15;
    }
    v19 = byte_18BE12C50[v14];
    if ((v19 - 1) < 2)
    {
      *(_DWORD *)(v8 + 104) = 0;
      goto LABEL_25;
    }
    if (v19 == -1)
      goto LABEL_16;
    v5 = (unsigned __int8 *)*a2;
  }
  while (*a2 < a3);
  *(_DWORD *)(v8 + 104) = v10;
  if (!v19)
    return result;
LABEL_25:
  if (a4 == 3)
  {
    v25 = byte_18BE12ADE[v14];
    v24 = byte_18BE12ADE[v14];
    if (v25 <= 15)
    {
      if (v25 == -1)
        goto LABEL_66;
      if (v25 != 1)
      {
        if (v25 != 2)
        {
LABEL_64:
          if (!*(_DWORD *)(v8 + 108))
            goto LABEL_66;
          *(_BYTE *)(v8 + 95) = v24;
          goto LABEL_59;
        }
        if (!*(_DWORD *)(v8 + 108))
          goto LABEL_66;
      }
    }
    else
    {
      if (v25 <= 32)
      {
        if (v25 == 16)
        {
LABEL_50:
          if (!*(_BYTE *)(v8 + 94))
            goto LABEL_17;
          v28 = *(char *)(v8 + 96);
          if (v28 <= 1)
            *(_BYTE *)(v8 + 97) = v28;
          v27 = 2;
          goto LABEL_54;
        }
        if (v25 == 17)
        {
          if (!*(_BYTE *)(v8 + 95))
            goto LABEL_17;
          v26 = *(char *)(v8 + 96);
          if (v26 <= 1)
            *(_BYTE *)(v8 + 97) = v26;
          v27 = 3;
LABEL_54:
          *(_BYTE *)(v8 + 96) = v27;
          goto LABEL_59;
        }
        goto LABEL_64;
      }
      if (v25 != 33)
      {
        if (v25 == 34)
        {
LABEL_57:
          *(_BYTE *)(v8 + 94) = v24;
          goto LABEL_59;
        }
        goto LABEL_64;
      }
    }
    *(_BYTE *)(v8 + 93) = v24;
    goto LABEL_59;
  }
  if (a4 != 2)
  {
    if (a4 != 1)
      goto LABEL_17;
    v23 = byte_18BE12A94[v14];
    v24 = byte_18BE12A94[v14];
    if ((v23 - 1) >= 2)
    {
      if (v23 == -1)
        goto LABEL_66;
      if (v23 != 16)
      {
        if (((word_18BE12A24[*(unsigned int *)(v8 + 108)] >> v23) & 1) != 0)
        {
          *(_BYTE *)(v8 + 92) = v24;
          goto LABEL_59;
        }
LABEL_66:
        *a5 = 19;
LABEL_67:
        *((_DWORD *)v7 + 71) = 0;
        return result;
      }
      goto LABEL_50;
    }
    if (((word_18BE12A24[*(unsigned int *)(v8 + 108)] >> v23) & 1) == 0)
      goto LABEL_66;
    goto LABEL_57;
  }
  if (v14 != 48)
    goto LABEL_66;
LABEL_59:
  v29 = *a5;
  if (*a5 <= 0)
  {
    *((_BYTE *)v7 + 64) = 0;
    return result;
  }
  if (v29 == 18)
    goto LABEL_18;
  if (v29 == 19)
    goto LABEL_67;
  return result;
}

uint64_t sub_18BC14108(uint64_t result, int *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  size_t v10;
  _WORD *v11;
  uint64_t v12;
  BOOL v13;
  int v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  char *v21;
  _DWORD *v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  char *v26;
  uint64_t v27;
  int v28;
  _BYTE *v29;
  int v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  __int16 v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  _BYTE *v40;
  char v41;
  int v42;
  unsigned __int8 *v43;
  __int16 v44;
  _WORD __dst[4];
  char *v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;

  v3 = result;
  v44 = 0;
  v6 = *(unsigned __int8 **)(result + 16);
  v4 = *(_QWORD *)(result + 24);
  v5 = (unint64_t *)(result + 16);
  v43 = v6;
  v7 = *(_QWORD *)(result + 8);
  v8 = *(_QWORD *)(v7 + 16);
  if (*(_DWORD *)(v8 + 108) != 1)
  {
    v11 = *(_WORD **)(result + 32);
    v12 = *(_QWORD *)(*(_QWORD *)(v8 + 80) + 48);
    if (*(_DWORD *)(v8 + 104))
      goto LABEL_59;
    v13 = *(_BYTE *)(v7 + 64) != 1 || (unint64_t)v6 >= v4;
    if (v13 || (unint64_t)v11 >= *(_QWORD *)(result + 40))
      goto LABEL_44;
    LOWORD(v14) = *(unsigned __int8 *)(v7 + 65);
    *(_BYTE *)(v7 + 64) = 0;
LABEL_63:
    v34 = *v6;
    v35 = v34 - 33;
    v36 = v34 | ((_WORD)v14 << 8);
    if ((((_BYTE)v14 - 33) & 0xFEu) > 0x5D || v35 > 0x5D)
    {
      result = 0xFFFFLL;
      if (v35 < 0x5E || v34 <= 0x1F && ((1 << v34) & 0x800C000) != 0)
        goto LABEL_71;
      v43 = ++v6;
    }
    else
    {
      v43 = ++v6;
      LOBYTE(v44) = v14 ^ 0x80;
      HIBYTE(v44) = v34 ^ 0x80;
      result = sub_18BC2735C(v12, (uint64_t)&v44, 2);
    }
    LOWORD(v14) = v36;
LABEL_71:
    if ((int)result > 65533)
    {
      v40 = *(_BYTE **)(v3 + 8);
      if ((unsigned __int16)v14 < 0x100u)
      {
        v41 = 1;
      }
      else
      {
        v40[66] = v14;
        LOBYTE(v14) = BYTE1(v14);
        v41 = 2;
      }
      v40[65] = v14;
      v40[64] = v41;
      if ((_DWORD)result == 65534)
        v42 = 10;
      else
        v42 = 12;
      *a2 = v42;
      v6 = v43;
      goto LABEL_55;
    }
    v37 = *(_QWORD *)(v3 + 48);
    if (v37)
    {
      if ((unsigned __int16)v14 >= 0x100u)
        v38 = -2;
      else
        v38 = -1;
      *(_DWORD *)(v37 + 2 * ((_QWORD)v11 - *(_QWORD *)(v3 + 32))) = v38 + (_DWORD)v6 - *(_DWORD *)(v3 + 16);
    }
    *v11++ = result;
    while (1)
    {
LABEL_44:
      if ((unint64_t)v6 >= v4)
        goto LABEL_55;
      v31 = 0;
      v32 = *(_QWORD *)(v3 + 40);
      while (1)
      {
        if ((unint64_t)v11 >= v32)
        {
          *a2 = 15;
          goto LABEL_55;
        }
        v14 = v6[v31];
        if (v14 != 14)
          break;
        *(_BYTE *)(v8 + 96) = 1;
        *(_BYTE *)(v8 + 112) = 1;
LABEL_52:
        if (v4 - (_QWORD)v6 == ++v31)
        {
          v6 = (unsigned __int8 *)v4;
          goto LABEL_55;
        }
      }
      if (v14 == 15)
        break;
      if (v14 != 27)
      {
        v33 = (uint64_t)&v6[v31];
        v6 += v31 + 1;
        v43 = v6;
        *(_BYTE *)(v8 + 112) = 0;
        if (*(_BYTE *)(v8 + 96) != 1)
        {
          result = 0xFFFFLL;
          if (((char)v14 & 0x80000000) == 0)
            result = sub_18BC2735C(v12, v33, 1);
          goto LABEL_71;
        }
        if ((unint64_t)v6 >= v4)
        {
          *(_BYTE *)(*(_QWORD *)(v3 + 8) + 65) = v14;
          *(_BYTE *)(*(_QWORD *)(v3 + 8) + 64) = 1;
          goto LABEL_55;
        }
        goto LABEL_63;
      }
      v43 = &v6[v31];
      v7 = *(_QWORD *)(v3 + 8);
LABEL_59:
      *(_BYTE *)(v8 + 112) = 0;
      result = (uint64_t)sub_18BC13E04((_QWORD *)v7, (unint64_t *)&v43, v4, 2, a2);
      v6 = v43;
      if (*a2 >= 1)
      {
LABEL_55:
        *(_QWORD *)(v3 + 32) = v11;
        *(_QWORD *)(v3 + 16) = v6;
        return result;
      }
    }
    *(_BYTE *)(v8 + 96) = 0;
    if (*(_BYTE *)(v8 + 112))
    {
      *(_BYTE *)(v8 + 112) = 0;
      *a2 = 18;
      v39 = *(_QWORD *)(v3 + 8);
      *(_DWORD *)(v39 + 284) = 2;
      *(_BYTE *)(v39 + 65) = 15;
      *(_BYTE *)(*(_QWORD *)(v3 + 8) + 64) = 1;
      *(_QWORD *)(v3 + 32) = v11;
      *(_QWORD *)(v3 + 16) = &v6[v31 + 1];
      return result;
    }
    goto LABEL_52;
  }
  if (*(unsigned __int16 *)result >= 0x38u)
    v9 = 56;
  else
    v9 = *(unsigned __int16 *)result;
  if (v9 <= 0x37)
    v10 = 56 - v9;
  else
    v10 = 0;
  bzero((char *)__dst + v9, v10);
  result = (uint64_t)memcpy(__dst, (const void *)v3, v9);
  __dst[0] = v9;
  v46 = *(char **)(v8 + 80);
  if (*(_DWORD *)(v8 + 104))
    goto LABEL_43;
  while (1)
  {
    v15 = *a2;
    if (*a2 > 0)
      return result;
    v16 = *(_QWORD *)(v3 + 16);
    v17 = *(_QWORD *)(v3 + 24);
    if (v16 >= v17)
      return result;
    v18 = 0;
    v47 = *(_QWORD *)(v3 + 16);
    while (*(_BYTE *)(v16 + v18) != 27)
    {
      if (v17 - v16 == ++v18)
        goto LABEL_24;
    }
    v17 = v16 + v18;
LABEL_24:
    v48 = v17;
    if (v16 != v17)
    {
      v19 = *(_QWORD *)(v3 + 8);
      v20 = *(char *)(v19 + 64);
      v21 = v46;
      if (v20 >= 1)
      {
        memcpy(v46 + 65, (const void *)(v19 + 65), *(unsigned __int8 *)(v19 + 64));
        LOBYTE(v20) = *(_BYTE *)(*(_QWORD *)(v3 + 8) + 64);
      }
      v21[64] = v20;
      result = sub_18BC262B0((uint64_t)__dst, a2);
      v22 = *(_DWORD **)(v3 + 48);
      if (v22)
      {
        if (v6 != (unsigned __int8 *)*v5)
        {
          v23 = *(_QWORD *)(v3 + 32);
          v24 = v49;
          if (v23 < v49)
          {
            v25 = *v5 - (_DWORD)v6;
            do
            {
              if ((*v22 & 0x80000000) == 0)
                *v22 += v25;
              ++v22;
              v23 += 2;
            }
            while (v23 < v24);
          }
        }
      }
      v26 = v46;
      *(_QWORD *)(v3 + 16) = v47;
      v27 = v50;
      *(_QWORD *)(v3 + 32) = v49;
      *(_QWORD *)(v3 + 48) = v27;
      v28 = v26[64];
      if (v28 >= 1)
      {
        result = (uint64_t)memcpy((void *)(*(_QWORD *)(v3 + 8) + 65), v26 + 65, v26[64]);
        LOBYTE(v28) = v26[64];
      }
      v29 = *(_BYTE **)(v3 + 8);
      v29[64] = v28;
      v15 = *a2;
      if (*a2 == 15)
      {
        v30 = v26[93];
        if (v30 >= 1)
        {
          result = (uint64_t)memcpy(v29 + 144, v26 + 144, v26[93]);
          LOBYTE(v30) = v26[93];
          v29 = *(_BYTE **)(v3 + 8);
          v15 = *a2;
        }
        v29[93] = v30;
        v26[93] = 0;
      }
    }
    if (v15 > 0)
      return result;
    v4 = *(_QWORD *)(v3 + 24);
    if (*(_QWORD *)(v3 + 16) == v4)
      return result;
    v7 = *(_QWORD *)(v3 + 8);
LABEL_43:
    result = (uint64_t)sub_18BC13E04((_QWORD *)v7, v5, v4, 2, a2);
  }
}

unint64_t sub_18BC14600(unint64_t result, int *a2)
{
  int *v2;
  unint64_t v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  int v14;
  BOOL v15;
  _QWORD *v16;
  unsigned __int16 *v17;
  int v18;
  int v19;
  int v20;
  unsigned __int16 *v21;
  BOOL v23;
  BOOL v24;
  char v25;
  _DWORD *v26;
  char v27;
  _DWORD *v28;
  unsigned int v29;
  char *v30;
  _DWORD *v31;
  char v32;
  _DWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  BOOL v45;
  int v46;
  int v47;
  uint64_t v49;
  unint64_t v50;
  unsigned int v51;
  int v52;
  int v53;
  int *v54;
  unsigned int v55;
  _DWORD *v56;
  char *v57;

  v2 = a2;
  v3 = result;
  v5 = *(_QWORD *)(result + 24);
  v4 = *(char **)(result + 32);
  v6 = *(_QWORD *)(result + 40);
  v56 = *(_DWORD **)(result + 48);
  v55 = 0;
  v7 = *(_QWORD *)(result + 8);
  v8 = *(unsigned __int16 **)(result + 16);
  v9 = *(_QWORD *)(v7 + 16);
  v10 = *(_QWORD *)(v9 + 80);
  if (*(_DWORD *)(v9 + 108) == 1)
  {
    *(_QWORD *)(result + 8) = v10;
    *(_DWORD *)(v10 + 84) = *(_DWORD *)(v7 + 84);
    result = sub_18BC274E8(result, a2);
    v11 = *(_QWORD *)(v9 + 80);
    *(_DWORD *)(v7 + 84) = *(_DWORD *)(v11 + 84);
    if (*v2 == 15)
    {
      v12 = *(char *)(v11 + 91);
      if (v12 >= 1)
      {
        result = (unint64_t)memcpy((void *)(v7 + 104), (const void *)(v11 + 104), *(unsigned __int8 *)(v11 + 91));
        v11 = *(_QWORD *)(v9 + 80);
        LOBYTE(v12) = *(_BYTE *)(v11 + 91);
      }
      *(_BYTE *)(v7 + 91) = v12;
      *(_BYTE *)(v11 + 91) = 0;
    }
    *(_QWORD *)(v3 + 8) = v7;
    return result;
  }
  v14 = *(_DWORD *)(v7 + 80);
  LODWORD(v13) = *(_DWORD *)(v7 + 84);
  if ((_DWORD)v13)
    v15 = (unint64_t)v4 >= v6;
  else
    v15 = 1;
  if (!v15)
  {
LABEL_68:
    if ((unint64_t)v8 >= v5)
    {
      v47 = 0;
    }
    else
    {
      v44 = *v8;
      v45 = (v44 & 0xFC00) == 56320;
      v46 = v44 + ((_DWORD)v13 << 10) - 56613888;
      if ((v44 & 0xFC00) == 0xDC00)
        v47 = 10;
      else
        v47 = 12;
      v8 += v45;
      if (v45)
        LODWORD(v13) = v46;
    }
    goto LABEL_79;
  }
  if ((unint64_t)v8 < v5)
  {
    v16 = *(_QWORD **)(v10 + 48);
    v17 = v8 + 1;
    v18 = *(unsigned __int8 *)(v7 + 63);
    v19 = (char)v18;
    v20 = *(_DWORD *)(v7 + 80);
    while (1)
    {
      v21 = v8;
      LOBYTE(v14) = v20;
      v55 = 0xFFFF;
      if ((unint64_t)v4 >= *(_QWORD *)(v3 + 40))
      {
        *v2 = 15;
        goto LABEL_81;
      }
      ++v8;
      v13 = *v21;
      if (v13 <= 0x1F && ((1 << v13) & 0x800C000) != 0)
      {
        *v2 = 12;
        *(_DWORD *)(*(_QWORD *)(v3 + 8) + 84) = v13;
        ++v21;
        goto LABEL_81;
      }
      if (*(unsigned __int16 *)(v16[29]
                               + 2
                               * (v13 & 0xF | (16
                                             * (unsigned __int16)*(_DWORD *)(v16[11]
                                                                                         + 4
                                                                                         * (((v13 >> 4) & 0x3F)
                                                                                          + *(unsigned __int16 *)(v16[11] + ((v13 >> 9) & 0x7E))))))) < 0x100u)
        result = 1;
      else
        result = 2;
      if (((*(_DWORD *)(v16[11]
                       + 4
                       * (((v13 >> 4) & 0x3F) + *(unsigned __int16 *)(v16[11] + ((v13 >> 9) & 0x7E)))) >> (v13 & 0xF | 0x10)) & 1) != 0
        || ((v13 - 63744) < 0xFFFFE700 ? (v23 = v18 == 0) : (v23 = 0),
            !v23
         && *(_WORD *)(v16[29]
                     + 2
                     * (v13 & 0xF | (16
                                   * (unsigned __int16)*(_DWORD *)(v16[11]
                                                                               + 4
                                                                               * (((v13 >> 4) & 0x3F)
                                                                                + *(unsigned __int16 *)(v16[11] + ((v13 >> 9) & 0x7E)))))))))
      {
        v55 = *(unsigned __int16 *)(v16[29]
                                  + 2
                                  * (v13 & 0xF | (16
                                                * (unsigned __int16)*(_DWORD *)(v16[11]
                                                                                            + 4
                                                                                            * (((v13 >> 4) & 0x3F)
                                                                                             + *(unsigned __int16 *)(v16[11] + ((v13 >> 9) & 0x7E)))))));
      }
      else
      {
        result = v16[36];
        if (!result)
          goto LABEL_65;
        v52 = v19;
        v53 = v18;
        v38 = v6;
        v39 = v16;
        v54 = v2;
        v40 = v5;
        v41 = v4;
        result = sub_18BC19D3C(result, v13, (int *)&v55, v19);
        v19 = v52;
        v18 = v53;
        v4 = v41;
        v5 = v40;
        v2 = v54;
        v16 = v39;
        v6 = v38;
        if ((result & 0x80000000) != 0)
          result = -(int)result;
      }
      v24 = (int)result > 2 || (_DWORD)result == 0;
      if (v24
        || (_DWORD)result == 1 && v55 > 0x7F
        || (_DWORD)result == 2 && ((((_WORD)v55 + 24159) & 0xFFFEu) > 0x5D5D || (((_BYTE)v55 + 95) & 0xFEu) >= 0x5E))
      {
LABEL_65:
        v55 = 0xFFFF;
LABEL_66:
        v8 = v21 + 1;
        if ((v13 & 0xF800) == 0xD800)
        {
          if ((v13 & 0x400) == 0)
            goto LABEL_68;
          v47 = 12;
        }
        else
        {
          v47 = 10;
        }
LABEL_79:
        *v2 = v47;
        *(_DWORD *)(*(_QWORD *)(v3 + 8) + 84) = v13;
        break;
      }
      if (v55 == 0xFFFF)
        goto LABEL_66;
      v20 = v55 > 0xFF;
      if (v20 != (char)v14)
      {
        v25 = v55 > 0xFF ? 14 : 15;
        *v4++ = v25;
        v26 = v56;
        if (v56)
        {
          *v56 = (((unint64_t)v17 - *(_QWORD *)(v3 + 16)) >> 1) - 1;
          v56 = v26 + 1;
        }
      }
      v27 = v55;
      if (v55 > 0xFF)
      {
        v29 = (v55 >> 8) ^ 0xFFFFFF80;
        if ((unint64_t)v4 < v6)
        {
          *v4 = v29;
          v30 = v4 + 1;
          v31 = v56;
          if (v56)
          {
            *v56 = (((unint64_t)v17 - *(_QWORD *)(v3 + 16)) >> 1) - 1;
            v56 = v31 + 1;
          }
          v32 = v55 ^ 0x80;
          if ((unint64_t)v30 >= v6)
          {
            v42 = *(_QWORD *)(v3 + 8);
            v43 = *(char *)(v42 + 91);
            *(_BYTE *)(v42 + 91) = v43 + 1;
            *(_BYTE *)(v42 + v43 + 104) = v32;
            *v2 = 15;
          }
          else
          {
            v30 = v4 + 2;
            v4[1] = v32;
            v33 = v56;
            if (v56)
            {
              *v56 = (((unint64_t)v17 - *(_QWORD *)(v3 + 16)) >> 1) - 1;
              v56 = v33 + 1;
            }
          }
          v4 = v30;
          goto LABEL_63;
        }
        v34 = *(_QWORD *)(v3 + 8);
        v35 = *(char *)(v34 + 91);
        *(_BYTE *)(v34 + 91) = v35 + 1;
        *(_BYTE *)(v34 + v35 + 104) = v29;
        v27 = v55 ^ 0x80;
      }
      else if ((unint64_t)v4 < v6)
      {
        *v4++ = v55;
        v28 = v56;
        if (v56)
        {
          *v56 = (((unint64_t)v17 - *(_QWORD *)(v3 + 16)) >> 1) - 1;
          v56 = v28 + 1;
        }
        goto LABEL_63;
      }
      v36 = *(_QWORD *)(v3 + 8);
      v37 = *(char *)(v36 + 91);
      *(_BYTE *)(v36 + 91) = v37 + 1;
      *(_BYTE *)(v36 + v37 + 104) = v27;
      *v2 = 15;
LABEL_63:
      ++v17;
      if ((unint64_t)v8 >= v5)
      {
        ++v21;
        LOBYTE(v14) = v20;
        goto LABEL_81;
      }
    }
  }
  v21 = v8;
LABEL_81:
  if (*v2 <= 0 && v14 != 0)
  {
    if (*(_BYTE *)(v3 + 2))
    {
      if ((unint64_t)v21 >= v5)
      {
        result = *(_QWORD *)(v3 + 8);
        if (!*(_DWORD *)(result + 84))
        {
          v49 = *(_QWORD *)(v3 + 16);
          v50 = ((unint64_t)v21 - v49) >> 1;
          v51 = v50 - 1;
          if ((int)v50 < 1)
          {
            v51 = -1;
          }
          else if ((*(_WORD *)(v49 + 2 * v51) & 0xFC00) == 0xDC00
                 && ((_DWORD)v50 == 1 || (*(_WORD *)(v49 + 2 * (v50 - 2)) & 0xFC00) == 0xD800))
          {
            v51 = v50 - 2;
          }
          v57 = v4;
          result = sub_18BC17544(result, byte_18BE12EE4, 1, &v57, v6, &v56, v51, v2);
          LOBYTE(v14) = 0;
          v4 = v57;
        }
      }
    }
  }
  *(_QWORD *)(v3 + 16) = v21;
  *(_QWORD *)(v3 + 32) = v4;
  *(_DWORD *)(*(_QWORD *)(v3 + 8) + 80) = (char)v14;
  return result;
}

uint64_t sub_18BC14B4C(_QWORD *a1, int *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  _QWORD *v6;
  unint64_t v7;
  _WORD *v8;
  uint64_t v9;
  _DWORD *v10;
  char v11;
  int v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unsigned __int8 v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  unint64_t v35;
  _WORD *v36;
  uint64_t v37;
  _BYTE *v38;
  char v39;
  unsigned __int8 *v40;
  __int16 v41;
  char v42;

  v42 = 0;
  v41 = 0;
  v6 = a1 + 1;
  result = a1[1];
  v5 = (unsigned __int8 *)v6[1];
  v40 = v5;
  v7 = a1[3];
  v8 = (_WORD *)a1[4];
  v9 = *(_QWORD *)(result + 16);
  v10 = (_DWORD *)(v9 + 92);
  if (*(_DWORD *)(v9 + 104))
  {
LABEL_2:
    v11 = *(_BYTE *)(result + 64);
    result = (uint64_t)sub_18BC13E04((_QWORD *)result, (unint64_t *)&v40, v7, 3, a2);
    v12 = *a2;
    if (*(_DWORD *)(v9 + 104))
      goto LABEL_5;
    if (v12 <= 0)
    {
      if (!*(_BYTE *)(v9 + 112))
      {
LABEL_5:
        v5 = v40;
        if (v12 < 1)
          goto LABEL_17;
        goto LABEL_15;
      }
      *a2 = 18;
      v15 = a1[1];
      *(_DWORD *)(v15 + 284) = 2;
      *(_BYTE *)(v15 + 64) = v11 + (_BYTE)v40 - (_BYTE)v5;
    }
    v5 = v40;
LABEL_15:
    a1[4] = v8;
    a1[2] = v5;
    *(_BYTE *)(v9 + 112) = 0;
    return result;
  }
  v13 = *(_BYTE *)(result + 64) != 1 || (unint64_t)v5 >= v7;
  if (!v13 && (unint64_t)v8 < a1[5])
  {
    LODWORD(v14) = *(unsigned __int8 *)(result + 65);
    *(_BYTE *)(result + 64) = 0;
    goto LABEL_37;
  }
LABEL_17:
  if ((unint64_t)v5 >= v7)
    goto LABEL_28;
  v18 = 0;
  v19 = a1[5];
  while (2)
  {
    if ((unint64_t)v8 >= v19)
    {
      v21 = 15;
      goto LABEL_27;
    }
    v14 = v5[v18];
    v20 = v5[v18];
    switch(v20)
    {
      case 0xAu:
      case 0xDu:
        v40 = &v5[v18 + 1];
        *v10 = 0;
        *(_WORD *)(v9 + 96) = 0;
        *(_BYTE *)(v9 + 112) = 0;
        goto LABEL_31;
      case 0xBu:
      case 0xCu:
        goto LABEL_34;
      case 0xEu:
        if (!*(_BYTE *)(v9 + 93))
        {
          v5 += v18 + 1;
          v40 = v5;
          *(_BYTE *)(v9 + 112) = 0;
          LODWORD(v14) = 14;
          result = 0xFFFFLL;
          goto LABEL_49;
        }
        *(_BYTE *)(v9 + 96) = 1;
        *(_BYTE *)(v9 + 112) = 1;
LABEL_24:
        if (v7 - (_QWORD)v5 == ++v18)
        {
          v5 = (unsigned __int8 *)v7;
          goto LABEL_28;
        }
        continue;
      case 0xFu:
        *(_BYTE *)(v9 + 96) = 0;
        if (!*(_BYTE *)(v9 + 112))
          goto LABEL_24;
        *(_BYTE *)(v9 + 112) = 0;
        *a2 = 18;
        v37 = a1[1];
        *(_DWORD *)(v37 + 284) = 2;
        *(_BYTE *)(v37 + 65) = 15;
        *(_BYTE *)(a1[1] + 64) = 1;
        a1[4] = v8;
        a1[2] = &v5[v18 + 1];
        return result;
      default:
        if ((_DWORD)v14 == 27)
        {
          v5 += v18;
          v40 = v5;
          result = a1[1];
          goto LABEL_2;
        }
LABEL_34:
        v40 = &v5[v18 + 1];
        v22 = *(unsigned __int8 *)(v9 + 96);
        *(_BYTE *)(v9 + 112) = 0;
        if (v22)
        {
          if ((unint64_t)&v5[v18 + 1] >= v7)
          {
            *(_BYTE *)(a1[1] + 65) = v20;
            *(_BYTE *)(a1[1] + 64) = 1;
            v5 += v18 + 1;
            goto LABEL_28;
          }
          v5 += v18 + 1;
LABEL_37:
          v23 = *v5;
          v24 = v23 | ((_DWORD)v14 << 8);
          if ((((_BYTE)v14 - 33) & 0xFEu) > 0x5D || (v23 - 33) > 0x5Du)
          {
            result = 0xFFFFLL;
            if ((v23 - 33) >= 0x5Eu && (v23 > 0x1F || ((1 << v23) & 0x800C000) == 0))
            {
              v40 = ++v5;
              LODWORD(v14) = v24 | 0x10000;
            }
          }
          else
          {
            v40 = ++v5;
            v25 = *((char *)v10 + *(char *)(v9 + 96));
            if (v25 < 32)
            {
              v26 = *(_QWORD *)(v9 + 8 * v25);
              v28 = 2;
              v27 = v14;
            }
            else
            {
              v26 = *(_QWORD *)(v9 + 24);
              v27 = v25 + 96;
              v42 = v23;
              v28 = 3;
              LOBYTE(v23) = v14;
            }
            LOBYTE(v41) = v27;
            HIBYTE(v41) = v23;
            result = sub_18BC2735C(v26, (uint64_t)&v41, v28);
            LODWORD(v14) = v24;
          }
          if (*(char *)(v9 + 96) >= 2)
            *(_BYTE *)(v9 + 96) = *(_BYTE *)(v9 + 97);
        }
        else
        {
          result = 0xFFFFLL;
          if ((char)v14 < 0)
          {
            v5 += v18 + 1;
          }
          else
          {
LABEL_31:
            v5 += v18 + 1;
            result = v14;
          }
        }
LABEL_49:
        if (result <= 0xFFFD)
        {
          v29 = a1[6];
          if (v29)
          {
            if (v14 >= 0x100)
              v30 = -2;
            else
              v30 = -1;
            *(_DWORD *)(v29 + 2 * ((_QWORD)v8 - a1[4])) = v30 + (_DWORD)v5 - *((_DWORD *)a1 + 4);
          }
          *v8++ = result;
          goto LABEL_17;
        }
        if (result >= 0x10000)
        {
          *v8 = ((result + 67043328) >> 10) - 10240;
          v31 = a1[6];
          if (v31)
          {
            if (v14 >= 0x100)
              v32 = -2;
            else
              v32 = -1;
            v33 = v32 + (_DWORD)v5 - *((_DWORD *)a1 + 4);
            v34 = a1[4];
            v35 = a1[5];
            *(_DWORD *)(v31 + 2 * ((_QWORD)v8 - v34)) = v33;
            v36 = v8 + 1;
            if ((unint64_t)(v8 + 1) < v35)
            {
              *v36 = result & 0x3FF | 0xDC00;
              *(_DWORD *)(v31 + 2 * ((_QWORD)v36 - v34)) = v33;
              goto LABEL_65;
            }
LABEL_16:
            v16 = a1[1];
            v17 = *(char *)(v16 + 93);
            *(_BYTE *)(v16 + 93) = v17 + 1;
            *(_WORD *)(v16 + 2 * v17 + 144) = result & 0x3FF | 0xDC00;
            v8 = v36;
          }
          else
          {
            v36 = v8 + 1;
            if ((unint64_t)(v8 + 1) >= a1[5])
              goto LABEL_16;
            *v36 = result & 0x3FF | 0xDC00;
LABEL_65:
            v8 += 2;
          }
          goto LABEL_17;
        }
        v38 = (_BYTE *)a1[1];
        if (v14 < 0x100)
        {
          v39 = 1;
        }
        else
        {
          v38[66] = v14;
          LODWORD(v14) = v14 >> 8;
          v39 = 2;
        }
        v38[65] = v14;
        v38[64] = v39;
        if ((_DWORD)result == 65534)
          v21 = 10;
        else
          v21 = 12;
LABEL_27:
        *a2 = v21;
LABEL_28:
        a1[4] = v8;
        a1[2] = v5;
        return result;
    }
  }
}

unint64_t sub_18BC14FE0(unint64_t result, int *a2)
{
  int *v2;
  unint64_t v3;
  unsigned int v4;
  uint64_t v5;
  unsigned __int16 *v6;
  uint64_t v7;
  _WORD *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  int v18;
  char v19;
  unsigned int v20;
  int v21;
  int v22;
  char v23;
  __int16 v24;
  int v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  unint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int8 *v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  _BYTE *v56;
  char v57;
  unint64_t v58;
  _DWORD *v59;
  unint64_t v60;
  int v61;
  uint64_t v62;
  _DWORD *v63;
  int v64;
  int v65;
  uint64_t v66;
  unint64_t v67;
  unsigned int v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v74;
  _WORD *v75;
  unsigned __int16 *v76;
  unsigned int v77;
  unsigned int v78;
  uint64_t v79;
  int v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  _WORD v84[2];
  _DWORD *v85;
  _WORD *v86;
  _QWORD v87[3];

  v2 = a2;
  v3 = result;
  v4 = 0;
  v5 = 0;
  v87[1] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(result + 8);
  v6 = *(unsigned __int16 **)(result + 16);
  v9 = *(_QWORD *)(result + 24);
  v8 = *(_WORD **)(result + 32);
  v10 = *(_QWORD *)(result + 40);
  v85 = *(_DWORD **)(result + 48);
  v87[0] = 0;
  memset(v84, 0, 3);
  v11 = *(_QWORD *)(v7 + 16);
  v12 = v11 + 98;
  v13 = *(_DWORD *)(v7 + 84);
  if (v13)
    v14 = (unint64_t)v8 >= v10;
  else
    v14 = 1;
  v74 = result;
  v71 = v11 + 98;
  v72 = v7;
  v69 = v9;
  v70 = v10;
  v82 = *(_QWORD *)(v7 + 16);
  if (v14)
    goto LABEL_6;
  while (2)
  {
    if ((unint64_t)v6 >= v9)
    {
      *(_DWORD *)(v7 + 84) = v13;
LABEL_138:
      if (*v2 <= 0
        && *(_BYTE *)(v11 + 102)
        && *(_BYTE *)(v3 + 2)
        && (unint64_t)v6 >= v9
        && !*(_DWORD *)(v7 + 84))
      {
        *(_BYTE *)(v11 + 102) = 0;
        v66 = *(_QWORD *)(v3 + 16);
        v67 = ((unint64_t)v6 - v66) >> 1;
        v68 = v67 - 1;
        if ((int)v67 < 1)
        {
          v68 = -1;
        }
        else if ((*(_WORD *)(v66 + 2 * v68) & 0xFC00) == 0xDC00
               && ((_DWORD)v67 == 1 || (*(_WORD *)(v66 + 2 * (v67 - 2)) & 0xFC00) == 0xD800))
        {
          v68 = v67 - 2;
        }
        v86 = v8;
        result = sub_18BC17544(v7, byte_18BE12EE4, 1, &v86, v10, &v85, v68, v2);
        v8 = v86;
      }
      goto LABEL_149;
    }
    v16 = *v6;
    if ((v16 & 0xFC00) != 0xDC00)
    {
LABEL_38:
      *v2 = 12;
      *(_DWORD *)(v7 + 84) = v13;
      goto LABEL_149;
    }
    ++v6;
    v13 = v16 + (v13 << 10) - 56613888;
    *(_DWORD *)(v7 + 84) = 0;
LABEL_13:
    if ((int)v13 <= 127)
    {
      if ((int)v13 > 31 || ((1 << v13) & 0x800C000) == 0)
      {
        v18 = 1;
        v19 = v13;
        if (*(_BYTE *)(v11 + 102))
        {
          v4 = 0;
          BYTE1(v87[0]) = v13;
          *(_BYTE *)(v11 + 102) = 0;
          v18 = 2;
          v19 = 15;
        }
        LOBYTE(v87[0]) = v19;
        if (v13 == 13 || v13 == 10)
        {
          v4 = 0;
          *(_WORD *)(v12 + 4) = 0;
          *(_DWORD *)v12 = 0;
        }
        goto LABEL_120;
      }
      goto LABEL_38;
    }
    v76 = v6;
    if (v4)
    {
      v77 = v4;
    }
    else
    {
      v20 = *(unsigned __int8 *)(v11 + 99);
      if (v20 <= 1)
        v21 = 1;
      else
        v21 = *(unsigned __int8 *)(v11 + 99);
      LOBYTE(v84[0]) = v21;
      v22 = *(_DWORD *)(v11 + 108);
      if (v22 == 1)
      {
        if (v21 == 2)
        {
          v24 = 8449;
        }
        else if ((char)v21 == 1)
        {
          v24 = 545;
        }
        else
        {
          v24 = 513;
        }
        *(_WORD *)((char *)v84 + 1) = v24;
        v25 = 3;
      }
      else
      {
        if (v22)
          goto LABEL_136;
        if (v20 > 1)
          v23 = 1;
        else
          v23 = 33;
        HIBYTE(v84[0]) = v23;
        v25 = 2;
      }
      v77 = v25;
    }
    v75 = v8;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = *(unsigned __int8 *)(v7 + 63);
    v83 = v13 >> 10;
    v31 = (v13 >> 4) & 0x3F;
    v32 = 1 << (v13 & 0xF | 0x10);
    v81 = v13 - 57344;
    v78 = v13 - 983040;
    v33 = v77;
    do
    {
      v34 = *((char *)v84 + v26);
      if (v34 < 1)
        goto LABEL_101;
      v35 = *((unsigned __int8 *)v84 + v26);
      LODWORD(v86) = 0;
      if (v35 < 0x20)
      {
        v41 = *(_QWORD *)(v11 + 8 * v34);
        if (v13 >= 0x10000 && (*(_BYTE *)(v41 + 253) & 1) == 0)
          goto LABEL_87;
        v42 = *(unsigned __int16 *)(*(_QWORD *)(v41 + 232)
                                  + 2
                                  * (v13 & 0xF | (16
                                                * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v41 + 88)
                                                                              + 4
                                                                              * (v31
                                                                               + *(unsigned __int16 *)(*(_QWORD *)(v41 + 88) + 2 * v83))))));
        if (v42 >= 0x100)
          result = 4294967294;
        else
          result = 0xFFFFFFFFLL;
        if ((*(_DWORD *)(*(_QWORD *)(v41 + 88)
                        + 4 * (v31 + *(unsigned __int16 *)(*(_QWORD *)(v41 + 88) + 2 * v83))) & v32) != 0)
        {
          LODWORD(v86) = *(unsigned __int16 *)(*(_QWORD *)(v41 + 232)
                                             + 2
                                             * (v13 & 0xF | (16
                                                           * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v41 + 88)
                                                                                         + 4
                                                                                         * (v31
                                                                                          + *(unsigned __int16 *)(*(_QWORD *)(v41 + 88) + 2 * v83))))));
          if (v42 < 0x100)
            goto LABEL_101;
LABEL_89:
          v29 = 2;
LABEL_96:
          v30 = 0;
          v27 = 1;
          v5 = v86;
          v28 = v35;
          goto LABEL_101;
        }
        if (((_BYTE)v30 || v81 >> 8 < 0x19 || !(v78 >> 17))
          && *(_WORD *)(*(_QWORD *)(v41 + 232)
                      + 2
                      * (v13 & 0xF | (16
                                    * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v41 + 88)
                                                                  + 4
                                                                  * (v31
                                                                   + *(unsigned __int16 *)(*(_QWORD *)(v41 + 88) + 2 * v83)))))))
        {
          LODWORD(v86) = *(unsigned __int16 *)(*(_QWORD *)(v41 + 232)
                                             + 2
                                             * (v13 & 0xF | (16
                                                           * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v41 + 88)
                                                                                         + 4
                                                                                         * (v31
                                                                                          + *(unsigned __int16 *)(*(_QWORD *)(v41 + 88) + 2 * v83))))));
        }
        else
        {
LABEL_87:
          result = *(_QWORD *)(v41 + 288);
          if (!result)
            goto LABEL_101;
          v79 = v28;
          v48 = v5;
          v80 = v29;
          v49 = v27;
          v50 = v30;
          result = sub_18BC19D3C(result, v13, (int *)&v86, (char)v30);
          v28 = v79;
          v33 = v77;
          v11 = v82;
          v30 = v50;
          v27 = v49;
          v29 = v80;
          v5 = v48;
          if ((_DWORD)result == 2)
            goto LABEL_89;
        }
        if ((_DWORD)result == -2 && v29 == 0)
        {
          v29 = -2;
          goto LABEL_96;
        }
        goto LABEL_101;
      }
      v36 = *(_QWORD *)(v11 + 24);
      if (v13 >= 0x10000 && (*(_BYTE *)(v36 + 253) & 1) == 0)
      {
LABEL_69:
        result = *(_QWORD *)(v36 + 288);
        if (!result)
          goto LABEL_101;
        v43 = v28;
        v44 = v5;
        v45 = v27;
        v46 = v30;
        result = sub_18BC19D3C(result, v13, (int *)&v86, (char)v30);
        v28 = v43;
        v33 = v77;
        v11 = v82;
        v30 = v46;
        v27 = v45;
        v5 = v44;
LABEL_71:
        if ((_DWORD)result == 3)
        {
          v29 = 2;
          goto LABEL_79;
        }
        goto LABEL_73;
      }
      v37 = v13 & 0xF | (16
                       * (unsigned __int16)*(_DWORD *)(*(_QWORD *)(v36 + 88)
                                                     + 4
                                                     * (v31
                                                      + *(unsigned __int16 *)(*(_QWORD *)(v36 + 88)
                                                                                          + 2 * v83))));
      v38 = (unsigned __int8 *)(*(_QWORD *)(v36 + 232) + v37 + 2 * v37);
      v39 = (*v38 << 16) | (v38[1] << 8) | v38[2];
      if (v39 < 0x10000)
        v40 = 2;
      else
        v40 = 3;
      if (v39 < 0x100)
        result = 1;
      else
        result = v40;
      if ((*(_DWORD *)(*(_QWORD *)(v36 + 88)
                      + 4 * (v31 + *(unsigned __int16 *)(*(_QWORD *)(v36 + 88) + 2 * v83))) & v32) != 0)
      {
        LODWORD(v86) = v39;
        goto LABEL_71;
      }
      if (!(_BYTE)v30 && v81 >> 8 >= 0x19 && v78 >> 17 || !v39)
        goto LABEL_69;
      LODWORD(v86) = v39;
      result = -(int)result;
LABEL_73:
      if ((_DWORD)result == -3 && v29 == 0)
      {
        v30 = 0;
        v29 = -2;
LABEL_79:
        v5 = v86;
        if (BYTE2(v86) == 129)
        {
          v27 = 1;
          v28 = 33;
        }
        else if (BYTE2(v86) == 130)
        {
          v27 = 2;
          v28 = 34;
        }
        else
        {
          v28 = (v86 >> 16) - 96;
          if (*(_DWORD *)(v11 + 108) == 1)
          {
            v27 = 3;
          }
          else
          {
            v29 = 0;
            v27 = v27;
          }
        }
      }
LABEL_101:
      ++v26;
    }
    while (v26 < v33 && v29 < 1);
    v2 = a2;
    v3 = v74;
    v12 = v71;
    v7 = v72;
    v8 = v75;
    if (!v29)
    {
LABEL_136:
      *v2 = 10;
      *(_DWORD *)(v7 + 84) = v13;
      v6 = v76;
      goto LABEL_149;
    }
    if (*(unsigned __int8 *)(v71 + v27) == v28)
    {
      v52 = 0;
      v10 = v70;
      v4 = v77;
    }
    else
    {
      v53 = (char)v28;
      if ((char)v28 >= 3)
        v53 = (char)v28 - 30;
      LODWORD(v87[0]) = *(_DWORD *)(&off_1E224D550)[v53];
      *(_BYTE *)(v71 + v27) = v28;
      v4 = v77;
      if (v27 == 1)
        v4 = 0;
      v52 = 4;
      v10 = v70;
    }
    v9 = v69;
    if (*(char *)(v11 + 102) == v27)
    {
      v6 = v76;
      goto LABEL_119;
    }
    v6 = v76;
    if (v27 == 2)
    {
      v55 = v52 | (unint64_t)v87;
      *(_BYTE *)v55 = 27;
      v52 |= 2u;
      v56 = (_BYTE *)(v55 | 1);
      v57 = 78;
    }
    else
    {
      if (v27 == 1)
      {
        v54 = v52;
        v52 |= 1u;
        *(_BYTE *)((unint64_t)v87 | v54) = 14;
        *(_BYTE *)(v11 + 102) = 1;
        goto LABEL_119;
      }
      v58 = v52 | (unint64_t)v87;
      *(_BYTE *)v58 = 27;
      v52 |= 2u;
      v56 = (_BYTE *)(v58 | 1);
      v57 = 79;
    }
    *v56 = v57;
LABEL_119:
    v18 = v52 + 2;
    *(_WORD *)((unint64_t)v87 | v52) = bswap32(v5) >> 16;
LABEL_120:
    if (v18 == 2)
    {
      if ((unint64_t)(v8 + 1) > v10)
        goto LABEL_125;
      *v8 = v87[0];
      v63 = v85;
      if (v85)
      {
        if (v13 >= 0x10000)
          v64 = -2;
        else
          v64 = -1;
        v65 = (((unint64_t)v6 - *(_QWORD *)(v3 + 16)) >> 1) + v64;
        *v85 = v65;
        v85 = v63 + 2;
        v63[1] = v65;
      }
      ++v8;
LABEL_6:
      if ((unint64_t)v6 >= v9)
        goto LABEL_138;
      if ((unint64_t)v8 >= v10)
      {
        *v2 = 15;
        goto LABEL_149;
      }
      v15 = *v6++;
      v13 = v15;
      if ((v15 & 0xF800) == 0xD800)
      {
        if ((v13 & 0x400) == 0)
          continue;
        goto LABEL_38;
      }
      goto LABEL_13;
    }
    break;
  }
  if (v18 == 1)
  {
    *(_BYTE *)v8 = v87[0];
    v8 = (_WORD *)((char *)v8 + 1);
    v59 = v85;
    if (v85)
    {
      *v85 = (((unint64_t)v6 - *(_QWORD *)(v3 + 16)) >> 1) - 1;
      v85 = v59 + 1;
    }
    goto LABEL_6;
  }
LABEL_125:
  v60 = ((unint64_t)v6 - *(_QWORD *)(v3 + 16)) >> 1;
  if (v13 >= 0x10000)
    v61 = -2;
  else
    v61 = -1;
  v86 = v8;
  v62 = v5;
  result = sub_18BC17544(v7, (char *)v87, v18, &v86, v10, &v85, (int)v60 + v61, v2);
  v5 = v62;
  v11 = v82;
  v8 = v86;
  if (*v2 < 1)
    goto LABEL_6;
LABEL_149:
  *(_QWORD *)(v3 + 16) = v6;
  *(_QWORD *)(v3 + 32) = v8;
  return result;
}

void ucnv_enableCleanup()
{
  sub_18BC0ECC4(0x16u, (uint64_t)sub_18BC15814);
}

BOOL sub_18BC15814()
{
  ucnv_flushCache();
  if (qword_1EE0093F8 && !uhash_count(qword_1EE0093F8))
  {
    uhash_close((void **)qword_1EE0093F8);
    qword_1EE0093F8 = 0;
  }
  word_1EE009400 = 0;
  if (qword_1EE009408)
  {
    uprv_free((void *)qword_1EE009408);
    qword_1EE009408 = 0;
  }
  atomic_store(0, &dword_1EE009410);
  return qword_1EE0093F8 == 0;
}

_BYTE *ucnv_load(uint64_t a1, UErrorCode *a2)
{
  _BYTE *result;
  _BYTE *v5;
  _BYTE *v6;

  if (!a2 || *(int *)a2 > 0)
    return 0;
  v5 = *(_BYTE **)(a1 + 16);
  if (v5 && *v5)
    return sub_18BC1594C(a1, a2);
  if (qword_1EE0093F8 && (result = (_BYTE *)uhash_get(qword_1EE0093F8, *(_QWORD *)(a1 + 24))) != 0)
  {
    ++*((_DWORD *)result + 1);
  }
  else
  {
    v6 = sub_18BC1594C(a1, a2);
    result = 0;
    if (*(int *)a2 <= 0 && v6)
    {
      if (!*(_BYTE *)(a1 + 8))
        sub_18BC15AB4((uint64_t)v6);
      return v6;
    }
  }
  return result;
}

_BYTE *sub_18BC1594C(uint64_t a1, UErrorCode *a2)
{
  _BYTE *v2;
  _QWORD *v5;
  _OWORD *v7;
  uint64_t Memory;
  char *v9;
  __int16 v10;
  uint64_t v11;
  _BYTE *v12;
  void (*v13)(_BYTE *, uint64_t, char *, UErrorCode *);
  int v14;

  if (*(int *)a2 > 0)
    return 0;
  v5 = udata_openChoice(*(char **)(a1 + 16), "cnv", *(const char **)(a1 + 24), (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18BC171B8, 0, a2);
  v2 = 0;
  if (*(int *)a2 > 0)
    return v2;
  v7 = v5;
  Memory = udata_getMemory((uint64_t)v5);
  if (*(int *)a2 <= 0)
  {
    v9 = (char *)Memory;
    v10 = *(char *)(Memory + 69);
    if ((v10 & 0xFFFEu) <= 0x21
      && ((0x203uLL >> v10) & 1) == 0
      && (v11 = qword_1E224D5A0[*(char *)(Memory + 69)], *(_BYTE *)(v11 + 25))
      && *(_DWORD *)(v11 + 4) == 1
      && *(_DWORD *)Memory == 100)
    {
      v12 = uprv_malloc(0x128uLL);
      if (v12)
      {
        v2 = v12;
        memcpy(v12, (const void *)v11, 0x128uLL);
        v2[24] = 0;
        *((_QWORD *)v2 + 1) = v7;
        *((_QWORD *)v2 + 2) = v9;
        v13 = *(void (**)(_BYTE *, uint64_t, char *, UErrorCode *))(*((_QWORD *)v2 + 4) + 8);
        if (v13)
        {
          v13(v2, a1, &v9[*(unsigned int *)v9], a2);
          if (*(int *)a2 < 1)
            return v2;
          uprv_free(v2);
          v2 = 0;
        }
        if (*(int *)a2 < 1)
          return v2;
        goto LABEL_19;
      }
      v14 = 7;
    }
    else
    {
      v14 = 13;
    }
    *a2 = v14;
  }
LABEL_19:
  udata_close(v7);
  return 0;
}

void sub_18BC15AB4(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;

  v4 = 0;
  v2 = qword_1EE0093F8;
  if (qword_1EE0093F8)
    goto LABEL_2;
  v3 = ucnv_io_countKnownConverters((UErrorCode *)&v4);
  qword_1EE0093F8 = (uint64_t)uhash_openSize((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0, 2 * v3, &v4);
  sub_18BC0ECC4(0x16u, (uint64_t)sub_18BC15814);
  if (v4 <= 0)
  {
    v2 = qword_1EE0093F8;
LABEL_2:
    *(_BYTE *)(a1 + 24) = 1;
    uhash_put(v2, *(_QWORD *)(a1 + 16) + 4, a1, &v4);
  }
}

void ucnv_unload(_QWORD *a1)
{
  int v1;
  int v2;

  if (a1)
  {
    v1 = *((_DWORD *)a1 + 1);
    if (!v1 || (v2 = v1 - 1, (*((_DWORD *)a1 + 1) = v2) == 0))
    {
      if (!*((_BYTE *)a1 + 24))
        sub_18BC15B80(a1);
    }
  }
}

void sub_18BC15B80(_QWORD *a1)
{
  void (*v2)(_QWORD *);
  _OWORD *v3;

  if (!*((_DWORD *)a1 + 1))
  {
    v2 = *(void (**)(_QWORD *))(a1[4] + 16);
    if (v2)
      v2(a1);
    v3 = (_OWORD *)a1[1];
    if (v3)
      udata_close(v3);
    uprv_free(a1);
  }
}

void sub_18BC15BD4(uint64_t a1)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 25))
    {
      umtx_lock((icu::UMutex *)&unk_1EE009418);
      ucnv_unload((_QWORD *)a1);
      umtx_unlock((std::mutex **)&unk_1EE009418);
    }
  }
}

void sub_18BC15C24(uint64_t a1)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 25))
    {
      umtx_lock((icu::UMutex *)&unk_1EE009418);
      ++*(_DWORD *)(a1 + 4);
      umtx_unlock((std::mutex **)&unk_1EE009418);
    }
  }
}

_BYTE *sub_18BC15C78(unsigned __int8 *a1, _OWORD *a2, __int128 *a3, UErrorCode *a4)
{
  _BYTE *result;
  __int128 *v6;
  _OWORD *v7;
  int v8;
  int v9;
  uint64_t ConverterName;
  _BYTE *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  _BYTE *v19;
  char v20;
  int v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  _OWORD v25[14];
  _OWORD __s1[4];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v21 = 0;
  v20 = 1;
  if (*(int *)a4 > 0)
    return 0;
  v6 = a3;
  v7 = a2;
  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  if (a2)
  {
    if (a3)
      goto LABEL_11;
  }
  else
  {
    if (a3)
    {
      result = 0;
      *a4 = U_INTERNAL_PROGRAM_ERROR;
      return result;
    }
    v7 = v25;
  }
  v24 = 0;
  v22 = 0uLL;
  v23 = 0uLL;
  LODWORD(v22) = 40;
  v6 = &v22;
LABEL_11:
  memset(v25, 0, sizeof(v25));
  *(_BYTE *)v7 = 0;
  *((_BYTE *)v7 + 60) = 0;
  *((_DWORD *)v7 + 55) = 0;
  *((_QWORD *)v6 + 3) = a1;
  *((_QWORD *)v6 + 4) = (char *)v7 + 60;
  *((_DWORD *)v6 + 3) = 0;
  if (!a1)
    goto LABEL_23;
  v8 = *a1;
  if (v8 != 117)
  {
    if (v8 != 85 || a1[1] != 84 || a1[2] != 70)
      goto LABEL_25;
    goto LABEL_19;
  }
  if (a1[1] == 116 && a1[2] == 102)
  {
LABEL_19:
    v9 = a1[3];
    if (v9 == 56)
    {
      if (a1[4])
        goto LABEL_25;
    }
    else if (v9 != 45 || a1[4] != 56 || a1[5])
    {
      goto LABEL_25;
    }
LABEL_23:
    *((_QWORD *)v6 + 3) = "UTF-8";
    return &unk_1E2250200;
  }
LABEL_25:
  sub_18BC15F8C((uint64_t)a1, (uint64_t)v7, (uint64_t)v6, a4);
  if (*(int *)a4 > 0)
    return 0;
  ConverterName = ucnv_io_getConverterName(*((char **)v6 + 3), &v20, (UErrorCode *)&v21);
  *((_QWORD *)v6 + 3) = ConverterName;
  if (v21 <= 0 && (v11 = (_BYTE *)ConverterName) != 0)
  {
    if (v21 == -122)
      *a4 = U_AMBIGUOUS_ALIAS_WARNING;
  }
  else
  {
    *((_QWORD *)v6 + 3) = v7;
    v11 = v7;
  }
  if (v20)
  {
    if (v11 == (_BYTE *)v7)
    {
      v11 = v7;
    }
    else
    {
      sub_18BC15F8C((uint64_t)v11, (uint64_t)v7, (uint64_t)v6, a4);
      v11 = (_BYTE *)*((_QWORD *)v6 + 3);
    }
  }
  memset(__s1, 0, 60);
  ucnv_io_stripASCIIForCompare(__s1, v11);
  v12 = 0;
  v13 = 34;
  v14 = 17;
  while (1)
  {
    v15 = strcmp((const char *)__s1, (&off_1E224D6B0)[2 * v14]);
    v16 = v14;
    if ((v15 & 0x80000000) == 0)
    {
      v12 = v14;
      v16 = v13;
      if (!v15)
        break;
    }
    v17 = (_DWORD)v14 == (v16 + v12) >> 1;
    v14 = (v16 + v12) >> 1;
    v13 = v16;
    if (v17)
      goto LABEL_43;
  }
  v18 = SLODWORD((&off_1E224D6B0)[2 * v14 + 1]);
  if (((0x203uLL >> v18) & 1) == 0)
    return (_BYTE *)qword_1E224D5A0[v18];
LABEL_43:
  *((_DWORD *)v6 + 1) = 1;
  *((_QWORD *)v6 + 2) = 0;
  umtx_lock((icu::UMutex *)&unk_1EE009418);
  v19 = ucnv_load((uint64_t)v6, a4);
  umtx_unlock((std::mutex **)&unk_1EE009418);
  result = 0;
  if (*(int *)a4 <= 0 && v19)
    return v19;
  return result;
}

uint64_t sub_18BC15F8C(uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v7;
  _BYTE *v8;
  int v9;
  _BYTE *v10;
  _BYTE *v11;
  int v12;
  int v13;
  uint64_t i;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;

  v7 = 0;
  v8 = (_BYTE *)(a2 + 60);
  *(_QWORD *)(a3 + 24) = result;
  *(_QWORD *)(a3 + 32) = a2 + 60;
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 220);
  while (1)
  {
    v9 = *(unsigned __int8 *)(result + v7);
    if (!*(_BYTE *)(result + v7) || v9 == 44)
      break;
    if ((_DWORD)v7 == 59)
    {
      *a4 = 1;
      *(_BYTE *)a2 = 0;
      return result;
    }
    *(_BYTE *)(a2 + v7++) = v9;
  }
  *(_BYTE *)(a2 + v7) = 0;
  *(_QWORD *)(a3 + 24) = a2;
  v10 = (_BYTE *)(result + v7);
  while (1)
  {
    while (1)
    {
      while (1)
      {
LABEL_7:
        if (*v10 == 44)
        {
          v11 = v10 + 1;
        }
        else
        {
          v11 = v10;
          if (!*v10)
            return result;
        }
        result = strncmp(v11, "locale=", 7uLL);
        if ((_DWORD)result)
          break;
        for (i = 0; ; ++i)
        {
          v15 = v11[i + 7];
          if (!v11[i + 7] || v15 == 44)
          {
            v8[i] = 0;
            v10 = &v11[i + 7];
            if (!v15)
              goto LABEL_7;
            goto LABEL_30;
          }
          if ((_DWORD)i == 156)
            break;
          v8[i] = v15;
        }
        *a4 = 1;
        *v8 = 0;
        v10 = &v11[i + 8];
        if (!v15)
          continue;
LABEL_30:
        if (v15 != 44)
          return result;
      }
      result = strncmp(v11, "version=", 8uLL);
      if (!(_DWORD)result)
        break;
      result = strncmp(v11, "swaplfnl", 8uLL);
      if ((_DWORD)result)
      {
        v10 = v11;
        while (1)
        {
          v13 = *v10++;
          v12 = v13;
          if (v13 == 44)
            break;
          if (!v12)
            return result;
        }
      }
      else
      {
        v10 = v11 + 8;
        v18 = *(_DWORD *)(a2 + 220) | 0x10;
        *(_DWORD *)(a2 + 220) = v18;
        *(_DWORD *)(a3 + 12) = v18;
      }
    }
    v10 = v11 + 8;
    if (!v11[8])
      break;
    v16 = (char)v11[8] - 48;
    if ((v16 & 0xFEu) <= 9)
    {
      v17 = *(_DWORD *)(a2 + 220) & 0xFFFFFFF0 | v16;
      *(_DWORD *)(a2 + 220) = v17;
      *(_DWORD *)(a3 + 12) = v17;
      v10 = v11 + 9;
    }
  }
  v19 = *(_DWORD *)(a2 + 220) & 0xFFFFFFF0;
  *(_DWORD *)(a2 + 220) = v19;
  *(_DWORD *)(a3 + 12) = v19;
  return result;
}

_OWORD *ucnv_createConverter(_OWORD *a1, unsigned __int8 *a2, UErrorCode *a3)
{
  _BYTE *v5;
  _OWORD *result;
  __int128 v7[2];
  uint64_t v8;
  _OWORD v9[14];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LODWORD(v7[0]) = 40;
  if (*(int *)a3 > 0)
    return 0;
  memset(v9, 0, sizeof(v9));
  v5 = sub_18BC15C78(a2, v9, v7, a3);
  result = sub_18BC16240(a1, (uint64_t)v5, (uint64_t)v7, (int *)a3);
  if (*(int *)a3 >= 1)
    return 0;
  return result;
}

_OWORD *sub_18BC16240(_OWORD *a1, uint64_t a2, uint64_t a3, int *a4)
{
  _OWORD *v5;
  char v9;
  _BYTE *v10;
  size_t v11;
  void (*v12)(_OWORD *, uint64_t, int *);

  v5 = a1;
  if (*a4 >= 1)
    goto LABEL_2;
  if (a1)
  {
    v9 = 1;
  }
  else
  {
    v5 = uprv_malloc(0x120uLL);
    if (!v5)
    {
      *a4 = 7;
LABEL_2:
      sub_18BC15BD4(a2);
      return v5;
    }
    v9 = 0;
  }
  v5[16] = 0u;
  v5[17] = 0u;
  v5[14] = 0u;
  v5[15] = 0u;
  v5[12] = 0u;
  v5[13] = 0u;
  v5[10] = 0u;
  v5[11] = 0u;
  v5[8] = 0u;
  v5[9] = 0u;
  v5[6] = 0u;
  v5[7] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  *v5 = 0u;
  v5[1] = 0u;
  *((_BYTE *)v5 + 61) = v9;
  *((_QWORD *)v5 + 6) = a2;
  *((_DWORD *)v5 + 14) = *(_DWORD *)(a3 + 12);
  if (!*(_BYTE *)(a3 + 8))
  {
    *((_DWORD *)v5 + 52) = -1;
    *(_QWORD *)v5 = UCNV_FROM_U_CALLBACK_SUBSTITUTE;
    *((_QWORD *)v5 + 1) = UCNV_TO_U_CALLBACK_SUBSTITUTE;
    *((_DWORD *)v5 + 18) = *(_DWORD *)(a2 + 40);
    v10 = *(_BYTE **)(a2 + 16);
    *((_BYTE *)v5 + 88) = v10[71];
    *((_BYTE *)v5 + 94) = v10[80];
    v11 = (char)v10[76];
    *((_BYTE *)v5 + 89) = v11;
    *((_QWORD *)v5 + 5) = (char *)v5 + 136;
    memcpy((char *)v5 + 136, v10 + 72, v11);
    *((_DWORD *)v5 + 71) = 1;
  }
  v12 = *(void (**)(_OWORD *, uint64_t, int *))(*(_QWORD *)(a2 + 32) + 24);
  if (v12)
  {
    v12(v5, a3, a4);
    if (*a4 >= 1 && !*(_BYTE *)(a3 + 8))
    {
      ucnv_close(v5);
      return 0;
    }
  }
  return v5;
}

BOOL sub_18BC1638C(unsigned __int8 *a1, UErrorCode *a2)
{
  UErrorCode v2;
  _BYTE *v4;
  __int128 v6[2];
  uint64_t v7;
  _OWORD v8[14];
  _OWORD v9[18];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v7 = 0;
  memset(v6, 0, sizeof(v6));
  LODWORD(v6[0]) = 40;
  v2 = *a2;
  if (*(int *)a2 <= 0)
  {
    memset(v9, 0, sizeof(v9));
    memset(v8, 0, sizeof(v8));
    BYTE8(v6[0]) = 1;
    v4 = sub_18BC15C78(a1, v8, v6, a2);
    sub_18BC16240(v9, (uint64_t)v4, (uint64_t)v6, (int *)a2);
    sub_18BC15BD4((uint64_t)v4);
    v2 = *a2;
  }
  return v2 < U_ILLEGAL_ARGUMENT_ERROR;
}

_OWORD *sub_18BC16488(_OWORD *a1, unsigned int a2, uint64_t a3, int a4, int *a5)
{
  uint64_t v5;
  _OWORD *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;

  v8 = 0;
  v9 = 0;
  v7 = 40;
  if (a2 >= 0x22 || ((0x203uLL >> a2) & 1) != 0 || (v5 = qword_1E224D5A0[a2], *(_BYTE *)(v5 + 25)))
  {
    result = 0;
    *a5 = 1;
  }
  else
  {
    HIDWORD(v8) = a4;
    v10 = "";
    v11 = a3;
    return sub_18BC16240(a1, v5, (uint64_t)&v7, a5);
  }
  return result;
}

_QWORD *ucnv_openPackage_0(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  _BYTE *v5;
  _QWORD *result;
  _DWORD v7[2];
  __int128 v8;
  __int128 v9;
  _OWORD v10[3];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[28];
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v8 = 0u;
  v9 = 0u;
  v7[0] = 40;
  if (*(int *)a3 <= 0)
  {
    v19 = 0uLL;
    memset(v20, 0, sizeof(v20));
    v17 = 0uLL;
    v18 = 0uLL;
    v15 = 0uLL;
    v16 = 0uLL;
    v14 = 0uLL;
    v12 = 0uLL;
    v13 = 0uLL;
    v11 = 0uLL;
    memset(v10, 0, sizeof(v10));
    LOBYTE(v10[0]) = 0;
    BYTE12(v11) = 0;
    v21 = 0;
    sub_18BC15F8C(a2, (uint64_t)v10, (uint64_t)v7, a3);
    if (*(int *)a3 <= 0)
    {
      v7[1] = 1;
      *((_QWORD *)&v8 + 1) = a1;
      v5 = sub_18BC1594C((uint64_t)v7, a3);
      if (*(int *)a3 <= 0)
      {
        result = sub_18BC16240(0, (uint64_t)v5, (uint64_t)v7, (int *)a3);
        if (*(int *)a3 < 1)
          return result;
        ucnv_close(result);
      }
    }
  }
  return 0;
}

uint64_t ucnv_flushCache()
{
  uint64_t v0;
  char v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  char v6;
  int v8;

  u_flushDefaultConverter();
  if (!qword_1EE0093F8)
    return 0;
  umtx_lock((icu::UMutex *)&unk_1EE009418);
  v0 = 0;
  v1 = 1;
  do
  {
    v8 = -1;
    v2 = uhash_nextElement((uint64_t *)qword_1EE0093F8, &v8);
    if (!v2)
      break;
    v3 = v2;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(v3 + 8);
      if (*(_DWORD *)(v5 + 4))
      {
        ++v4;
      }
      else
      {
        v0 = (v0 + 1);
        uhash_removeElement(qword_1EE0093F8, (_DWORD *)v3);
        *(_BYTE *)(v5 + 24) = 0;
        sub_18BC15B80((_QWORD *)v5);
      }
      v3 = uhash_nextElement((uint64_t *)qword_1EE0093F8, &v8);
    }
    while (v3);
    v6 = v1 & (v4 > 0);
    v1 = 0;
  }
  while ((v6 & 1) != 0);
  umtx_unlock((std::mutex **)&unk_1EE009418);
  return v0;
}

uint64_t sub_18BC166FC(UErrorCode *a1)
{
  _BOOL4 v1;
  unsigned __int16 v2;

  v1 = sub_18BC16724(a1);
  v2 = word_1EE009400;
  if (!v1)
    return 0;
  return v2;
}

BOOL sub_18BC16724(UErrorCode *a1)
{
  unsigned int v2;
  void **v3;
  int v4;
  UErrorCode v5;
  int v6;
  _QWORD *Converter;
  unsigned __int8 *v8;
  uint64_t v9;
  int v11;
  _OWORD v12[18];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (*(int *)a1 <= 0)
  {
    v2 = atomic_load(&dword_1EE009410);
    if (v2 == 2 || !icu::umtx_initImplPreInit(&dword_1EE009410))
    {
      if (dword_1EE009414 >= 1)
        *a1 = dword_1EE009414;
    }
    else
    {
      sub_18BC0ECC4(0x16u, (uint64_t)sub_18BC15814);
      v3 = (void **)ucnv_openAllNames(a1);
      v4 = uenum_count((uint64_t)v3, (int *)a1);
      v5 = *a1;
      if (*(int *)a1 <= 0)
      {
        v6 = v4;
        qword_1EE009408 = (uint64_t)uprv_malloc(8 * v4);
        if (qword_1EE009408)
        {
          v11 = 0;
          memset(v12, 0, sizeof(v12));
          Converter = ucnv_createConverter(v12, 0, (UErrorCode *)&v11);
          ucnv_close(Converter);
          word_1EE009400 = 0;
          if (v6 >= 1)
          {
            do
            {
              v11 = 0;
              v8 = (unsigned __int8 *)uenum_next((uint64_t)v3, 0, &v11);
              if (sub_18BC1638C(v8, (UErrorCode *)&v11))
              {
                v9 = (unsigned __int16)word_1EE009400++;
                *(_QWORD *)(qword_1EE009408 + 8 * v9) = v8;
              }
              --v6;
            }
            while (v6);
          }
          uenum_close(v3);
          v5 = *a1;
        }
        else
        {
          v5 = U_MEMORY_ALLOCATION_ERROR;
          *a1 = U_MEMORY_ALLOCATION_ERROR;
        }
      }
      dword_1EE009414 = v5;
      icu::umtx_initImplPostInit(&dword_1EE009410);
    }
  }
  return *a1 < U_ILLEGAL_ARGUMENT_ERROR;
}

uint64_t sub_18BC168E4(unsigned int a1, UErrorCode *a2)
{
  uint64_t result;

  if (!sub_18BC16724(a2))
    return 0;
  if ((unsigned __int16)word_1EE009400 > a1)
    return *(_QWORD *)(qword_1EE009408 + 8 * a1);
  result = 0;
  *a2 = U_INDEX_OUTOFBOUNDS_ERROR;
  return result;
}

const char *ucnv_getDefaultName()
{
  return "UTF-8";
}

uint64_t ucnv_swap(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  int v21;
  char *v22;
  char *v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  const char *v27;
  unsigned int v28;
  uint64_t v29;
  char *v30;
  char *v31;
  size_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  size_t v42;
  void (**v43)(uint64_t, unsigned __int8 *, uint64_t, char *, int *);
  uint64_t v44;
  uint64_t v45;
  unsigned __int8 *v46;
  char *v47;
  int Int32;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  uint64_t v62;
  unsigned int *v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  int v76;
  unsigned int v77;
  int v78;

  v10 = a3;
  v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0)
    return 0;
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), *(unsigned __int8 *)(a2 + 12)) != 0x6E00000063
    || *(_BYTE *)(a2 + 14) != 118
    || *(_BYTE *)(a2 + 15) != 116
    || *(_BYTE *)(a2 + 16) != 6
    || *(unsigned __int8 *)(a2 + 17) <= 1u)
  {
    v62 = *(unsigned __int8 *)(a2 + 12);
    v27 = "ucnv_swap(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not recognized as an ICU .cnv conversion table\n";
LABEL_18:
    udata_printError(a1, (uint64_t)v27, v14, v15, v16, v17, v18, v19, v62);
LABEL_19:
    result = 0;
    v26 = 16;
    goto LABEL_20;
  }
  v21 = v13;
  v22 = (char *)(a2 + v13);
  if (a4)
    v23 = (char *)a4 + v13;
  else
    v23 = 0;
  if ((v10 & 0x80000000) != 0)
  {
    v28 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*(unsigned int *)v22);
    v29 = v28;
    v30 = &v23[v28];
  }
  else
  {
    v24 = (v10 - v13);
    if ((int)v24 < 100
      || (v25 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*(unsigned int *)v22),
          v10 = v24 - v25,
          v24 < v25))
    {
      udata_printError(a1, (uint64_t)"ucnv_swap(): too few bytes (%d after header) for an ICU .cnv conversion table\n", v14, v15, v16, v17, v18, v19, v24);
LABEL_16:
      result = 0;
      v26 = 8;
LABEL_20:
      *a5 = v26;
      return result;
    }
    v28 = v25;
    if (v22 != v23)
      memcpy(v23, v22, v25);
    (*(void (**)(uint64_t, char *, uint64_t, char *, int *))(a1 + 56))(a1, v22, 4, v23, a5);
    (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(a1 + 56))(a1, (unsigned int *)v22 + 16, 4, v23 + 64, a5);
    v32 = strlen(v22 + 4);
    (*(void (**)(uint64_t, unsigned int *, size_t, char *, int *))(a1 + 72))(a1, (unsigned int *)v22 + 1, v32, v23 + 4, a5);
    if (*a5 >= 1)
    {
      udata_printError(a1, (uint64_t)"ucnv_swap(): error swapping converter name\n", v14, v15, v16, v17, v18, v19, v62);
      return 0;
    }
    v29 = v28;
    v30 = &v23[v28];
  }
  if (v23)
    v31 = v30;
  else
    v31 = 0;
  if (v22[69] != 2)
  {
    udata_printError(a1, (uint64_t)"ucnv_swap(): unknown conversionType=%d!=UCNV_MBCS\n", v14, v15, v16, v17, v18, v19, v22[69]);
    goto LABEL_19;
  }
  if (v10 <= 0x27)
  {
LABEL_27:
    udata_printError(a1, (uint64_t)"ucnv_swap(): too few bytes (%d after headers) for an ICU MBCS .cnv conversion table\n", v14, v15, v16, v17, v18, v19, v10);
    goto LABEL_16;
  }
  v33 = &v22[v29];
  v34 = v22[v29];
  if (v34 == 5)
  {
    if (v33[1] < 3u)
    {
      v34 = 5;
    }
    else
    {
      v35 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*((unsigned int *)v33 + 8));
      if ((v35 & 0xFF80) == 0)
      {
        v78 = (v35 >> 6) & 1;
        v73 = 4 * (v35 & 0x3F);
        v75 = v33[1];
        goto LABEL_45;
      }
      v34 = *v33;
    }
LABEL_43:
    udata_printError(a1, (uint64_t)"ucnv_swap(): unsupported _MBCSHeader.version %d.%d\n", v14, v15, v16, v17, v18, v19, v34);
    goto LABEL_19;
  }
  if (v34 != 4)
    goto LABEL_43;
  if (!v33[1])
  {
    v34 = 4;
    goto LABEL_43;
  }
  v75 = v33[1];
  v78 = 0;
  v73 = 32;
LABEL_45:
  v71 = v33[2];
  v68 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*((unsigned int *)v33 + 1));
  v67 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*((unsigned int *)v33 + 2));
  v69 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*((unsigned int *)v33 + 3));
  v70 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*((unsigned int *)v33 + 4));
  v74 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*((unsigned int *)v33 + 5));
  v36 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*((unsigned int *)v33 + 6));
  v37 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*((unsigned int *)v33 + 7));
  v77 = v36;
  if (v78 && !(_BYTE)v36)
  {
    v27 = "ucnv_swap(): unsupported combination of makeconv --small with SBCS\n";
    goto LABEL_18;
  }
  v66 = v37;
  if (v36 > 0xEu || ((1 << v36) & 0x530F) == 0)
  {
    udata_printError(a1, (uint64_t)"ucnv_swap(): unsupported MBCS output type 0x%x\n", v14, v15, v16, v17, v18, v19, v36);
    goto LABEL_19;
  }
  v64 = v36;
  if (v75 >= 3 && (_BYTE)v36)
  {
    v38 = ((v71 << 8) + 256) >> 5;
    if (!v71)
      v38 = 0;
    if (v36 == 14)
      v39 = 0;
    else
      v39 = v38;
    v65 = v39;
  }
  else
  {
    v65 = 0;
  }
  v72 = v36 >> 8;
  if (v36 > 0xFF)
  {
    if ((v10 & 0x80000000) == 0 && (int)v10 < (int)(v72 + 128))
    {
      udata_printError(a1, (uint64_t)"ucnv_swap(): too few bytes (%d after headers) for an ICU MBCS .cnv conversion table with extension data\n", v14, v15, v16, v17, v18, v19, v10);
      goto LABEL_16;
    }
    v63 = (unsigned int *)&v33[v72];
    v41 = udata_readInt32(a1, v63[31]) + v72;
  }
  else
  {
    v63 = 0;
    v40 = v37;
    if (v78)
      v40 = 0;
    v41 = v40 + v74 + v65;
  }
  v76 = v41;
  if ((v10 & 0x80000000) == 0)
  {
    if ((int)v10 < v41)
      goto LABEL_27;
    if (v33 != v31)
      memcpy(v31, v33, v41);
    (*(void (**)(uint64_t, unsigned __int8 *, _QWORD, char *, int *))(a1 + 56))(a1, (unsigned __int8 *)v33 + 4, v73 - 4, v31 + 4, a5);
    if (v36 == 14)
    {
      v42 = strlen(&v33[v73]);
      (*(void (**)(uint64_t, char *, size_t, char *, int *))(a1 + 72))(a1, &v33[v73], v42, &v31[v73], a5);
      goto LABEL_91;
    }
    (*(void (**)(uint64_t, char *, _QWORD, char *, int *))(a1 + 56))(a1, &v33[v73], (v68 << 10), &v31[v73], a5);
    (*(void (**)(uint64_t, char *, _QWORD, char *, int *))(a1 + 56))(a1, &v33[v73 & 0x3FF | (v68 << 10)], (8 * v67), &v31[v73 & 0x3FF | (v68 << 10)], a5);
    v43 = (void (**)(uint64_t, unsigned __int8 *, uint64_t, char *, int *))(a1 + 48);
    (*(void (**)(uint64_t, char *, _QWORD, char *, int *))(a1 + 48))(a1, &v33[v69], (v70 - v69), &v31[v69], a5);
    if (!v64)
    {
      (*(void (**)(uint64_t, char *, _QWORD, char *, int *))(a1 + 48))(a1, &v33[v70], v74 - v70 + v66, &v31[v70], a5);
LABEL_91:
      if (v77 >= 0x100)
      {
        v46 = (unsigned __int8 *)&v33[v72];
        v47 = &v31[v72];
        Int32 = udata_readInt32(a1, v63[1]);
        v49 = udata_readInt32(a1, v63[2]);
        (*(void (**)(uint64_t, unsigned __int8 *, _QWORD, char *, int *))(a1 + 56))(a1, &v46[Int32], (4 * v49), &v47[Int32], a5);
        v50 = udata_readInt32(a1, v63[3]);
        v51 = udata_readInt32(a1, v63[4]);
        (*(void (**)(uint64_t, unsigned __int8 *, _QWORD, char *, int *))(a1 + 48))(a1, &v46[v50], (2 * v51), &v47[v50], a5);
        v52 = udata_readInt32(a1, v63[5]);
        v53 = udata_readInt32(a1, v63[7]);
        (*(void (**)(uint64_t, unsigned __int8 *, _QWORD, char *, int *))(a1 + 48))(a1, &v46[v52], (2 * v53), &v47[v52], a5);
        v54 = udata_readInt32(a1, v63[6]);
        (*(void (**)(uint64_t, unsigned __int8 *, _QWORD, char *, int *))(a1 + 56))(a1, &v46[v54], (4 * v53), &v47[v54], a5);
        v55 = udata_readInt32(a1, v63[10]);
        v56 = udata_readInt32(a1, v63[12]);
        (*(void (**)(uint64_t, unsigned __int8 *, _QWORD, char *, int *))(a1 + 48))(a1, &v46[v55], (2 * v56), &v47[v55], a5);
        v57 = udata_readInt32(a1, v63[13]);
        v58 = udata_readInt32(a1, v63[14]);
        (*(void (**)(uint64_t, unsigned __int8 *, _QWORD, char *, int *))(a1 + 48))(a1, &v46[v57], (2 * v58), &v47[v57], a5);
        v59 = udata_readInt32(a1, v63[15]);
        v60 = udata_readInt32(a1, v63[16]);
        (*(void (**)(uint64_t, unsigned __int8 *, _QWORD, char *, int *))(a1 + 56))(a1, &v46[v59], (4 * v60), &v47[v59], a5);
        v61 = udata_readInt32(a1, *v63);
        (*(void (**)(uint64_t, unsigned __int8 *, _QWORD, char *, int *))(a1 + 56))(a1, v46, (4 * v61), v47, a5);
      }
      return v28 + v21 + v76;
    }
    if ((v22[79] & 1) != 0)
      v44 = 2176;
    else
      v44 = 128;
    (*(void (**)(uint64_t, char *, uint64_t, char *, int *))(a1 + 48))(a1, &v33[v70], v44, &v31[v70], a5);
    (*(void (**)(uint64_t, char *, _QWORD, char *, int *))(a1 + 56))(a1, &v33[(v44 + v70)], (v74 - (v44 + v70)), &v31[(v44 + v70)], a5);
    if (v78)
      v45 = 0;
    else
      v45 = v66;
    if (v77 > 7u)
    {
      if (v77 != 8 && v77 != 12)
      {
LABEL_89:
        if (v65)
          (*(void (**)(uint64_t, char *, _QWORD, char *, int *))(a1 + 48))(a1, &v33[(v45 + v74)], v65, &v31[(v45 + v74)], a5);
        goto LABEL_91;
      }
    }
    else if (v77 != 1)
    {
      if (v77 != 3)
        goto LABEL_89;
      v43 = (void (**)(uint64_t, unsigned __int8 *, uint64_t, char *, int *))(a1 + 56);
    }
    (*v43)(a1, (unsigned __int8 *)&v33[v74], v45, &v31[v74], a5);
    goto LABEL_89;
  }
  return v28 + v21 + v76;
}

BOOL sub_18BC171B8(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  return *(unsigned __int16 *)a4 >= 0x14u
      && !a4[4]
      && !a4[5]
      && a4[6] == 2
      && a4[8] == 99
      && a4[9] == 110
      && a4[10] == 118
      && a4[11] == 116
      && a4[12] == 6;
}

_QWORD *ucnv_cbFromUWriteBytes(_QWORD *result, char *a2, int a3, int a4, int *a5)
{
  if (*a5 <= 0)
    return (_QWORD *)sub_18BC17544(result[1], a2, a3, result + 4, result[5], result + 6, a4, a5);
  return result;
}

uint64_t ucnv_cbFromUWriteUChars(uint64_t result, unint64_t *a2, unint64_t a3, int a4, int *a5)
{
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;

  if (*a5 <= 0)
  {
    v9 = result;
    v10 = (uint64_t *)(result + 32);
    v11 = *(_QWORD *)(result + 32);
    result = ucnv_fromUnicode(*(_QWORD *)(result + 8), (uint64_t *)(result + 32), *(_QWORD *)(result + 40), a2, a3, 0, 0, a5);
    v12 = (_DWORD *)v10[2];
    if (v12)
    {
      v13 = *v10;
      if (*v10 != v11)
      {
        do
        {
          *v12++ = a4;
          ++v11;
        }
        while (v11 != v13);
        *(_QWORD *)(v9 + 48) = v12;
      }
    }
    if (*a5 == 15)
    {
      v16 = 0;
      result = *(_QWORD *)(v9 + 8);
      v17 = result + *(char *)(result + 91) + 104;
      v14 = result + 136;
      if (v17 >= result + 136
        || (*(_BYTE *)(result + 91) = 0,
            result = ucnv_fromUnicode(result, (uint64_t *)&v17, result + 136, a2, a3, 0, 0, &v16),
            v15 = v17,
            *(_BYTE *)(*(_QWORD *)(v9 + 8) + 91) = v17 - *(_QWORD *)(v9 + 8) - 104,
            v15 >= v14)
        || v16 == 15)
      {
        *a5 = 5;
      }
    }
  }
  return result;
}

uint64_t ucnv_cbFromUWriteSub(uint64_t result, int a2, int *a3)
{
  uint64_t v4;
  int v5;
  uint64_t (*v7)(void);
  char *v8;
  _QWORD *v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;

  if (*a3 <= 0)
  {
    v4 = *(_QWORD *)(result + 8);
    v5 = *(char *)(v4 + 89);
    if (*(_BYTE *)(v4 + 89))
    {
      if (v5 < 0)
      {
        return ucnv_cbFromUWriteUChars(result, &v13, *(_QWORD *)(v4 + 40) - 2 * *(char *)(v4 + 89), a2, a3);
      }
      else
      {
        v7 = *(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 32) + 104);
        if (v7)
        {
          return v7();
        }
        else
        {
          v8 = (char *)(v4 + 94);
          if (*(_BYTE *)(v4 + 94) && *(unsigned __int16 *)(v4 + 140) <= 0xFFu)
          {
            v9 = (_QWORD *)(result + 32);
            v10 = *(_QWORD *)(result + 40);
            v11 = (_QWORD *)(result + 48);
            v12 = *(_QWORD *)(result + 8);
            v5 = 1;
          }
          else
          {
            v8 = *(char **)(v4 + 40);
            v9 = (_QWORD *)(result + 32);
            v10 = *(_QWORD *)(result + 40);
            v11 = (_QWORD *)(result + 48);
            v12 = *(_QWORD *)(result + 8);
          }
          return sub_18BC17544(v12, v8, v5, v9, v10, v11, a2, a3);
        }
      }
    }
  }
  return result;
}

uint64_t ucnv_cbToUWriteUChars(uint64_t result, __int16 *a2, int a3, int a4, int *a5)
{
  if (*a5 <= 0)
    return sub_18BC175EC(*(_QWORD *)(result + 8), a2, a3, (_WORD **)(result + 32), *(_QWORD *)(result + 40), (_QWORD *)(result + 48), a4, a5);
  return result;
}

uint64_t ucnv_cbToUWriteSub(uint64_t a1, int a2, int *a3)
{
  uint64_t result;
  __int16 *v6;

  result = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(result + 90) == 1 && *(_BYTE *)(result + 94))
  {
    if (*a3 < 1)
    {
      v6 = (__int16 *)&unk_18BE12F7E;
      return sub_18BC175EC(result, v6, 1, (_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (_QWORD *)(a1 + 48), a2, a3);
    }
  }
  else if (*a3 <= 0)
  {
    v6 = (__int16 *)&unk_18BE12F80;
    return sub_18BC175EC(result, v6, 1, (_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (_QWORD *)(a1 + 48), a2, a3);
  }
  return result;
}

uint64_t sub_18BC174F0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a2 + 16))(*(_QWORD *)a2, 0, 1114111);
}

uint64_t sub_18BC17504(uint64_t a1, _QWORD *a2)
{
  ((void (*)(_QWORD, _QWORD, uint64_t))a2[2])(*a2, 0, 55295);
  return ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[2])(*a2, 57344, 1114111);
}

uint64_t sub_18BC17544(uint64_t result, char *a2, int a3, _QWORD *a4, unint64_t a5, _QWORD *a6, int a7, _DWORD *a8)
{
  _BYTE *v8;
  _DWORD *v9;
  unsigned int v10;
  char v11;
  unsigned int v12;
  char v13;
  _BYTE *v14;
  unsigned int v15;
  char v16;

  v8 = (_BYTE *)*a4;
  if (a6 && (v9 = (_DWORD *)*a6) != 0)
  {
    if (a3 >= 1)
    {
      do
      {
        if ((unint64_t)v8 >= a5)
          break;
        v10 = a3;
        v11 = *a2++;
        *v8++ = v11;
        *v9++ = a7;
        --a3;
      }
      while (v10 >= 2);
    }
    *a6 = v9;
  }
  else if (a3 >= 1)
  {
    do
    {
      if ((unint64_t)v8 >= a5)
        break;
      v12 = a3;
      v13 = *a2++;
      *v8++ = v13;
      --a3;
    }
    while (v12 >= 2);
  }
  *a4 = v8;
  if (a3 >= 1)
  {
    if (result)
    {
      v14 = (_BYTE *)(result + 104);
      *(_BYTE *)(result + 91) = a3;
      v15 = a3 + 1;
      do
      {
        v16 = *a2++;
        *v14++ = v16;
        --v15;
      }
      while (v15 > 1);
    }
    *a8 = 15;
  }
  return result;
}

uint64_t sub_18BC175EC(uint64_t result, __int16 *a2, int a3, _WORD **a4, unint64_t a5, _QWORD *a6, int a7, _DWORD *a8)
{
  _WORD *v8;
  _DWORD *v9;
  unsigned int v10;
  __int16 v11;
  unsigned int v12;
  __int16 v13;
  _WORD *v14;
  unsigned int v15;
  __int16 v16;

  v8 = *a4;
  if (a6 && (v9 = (_DWORD *)*a6) != 0)
  {
    if (a3 >= 1)
    {
      do
      {
        if ((unint64_t)v8 >= a5)
          break;
        v10 = a3;
        v11 = *a2++;
        *v8++ = v11;
        *v9++ = a7;
        --a3;
      }
      while (v10 >= 2);
    }
    *a6 = v9;
  }
  else if (a3 >= 1)
  {
    do
    {
      if ((unint64_t)v8 >= a5)
        break;
      v12 = a3;
      v13 = *a2++;
      *v8++ = v13;
      --a3;
    }
    while (v12 >= 2);
  }
  *a4 = v8;
  if (a3 >= 1)
  {
    if (result)
    {
      v14 = (_WORD *)(result + 144);
      *(_BYTE *)(result + 93) = a3;
      v15 = a3 + 1;
      do
      {
        v16 = *a2++;
        *v14++ = v16;
        --v15;
      }
      while (v15 > 1);
    }
    *a8 = 15;
  }
  return result;
}

uint64_t sub_18BC17694(uint64_t result, unsigned int a2, unint64_t *a3, unint64_t a4, _DWORD **a5, int a6, _DWORD *a7)
{
  _WORD *v7;
  _WORD *v8;
  int v9;
  _WORD *v10;
  uint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  char v14;
  __int16 v15;

  v7 = (_WORD *)*a3;
  v8 = (_WORD *)*a3;
  if (*a3 >= a4)
    goto LABEL_13;
  if ((int)a2 < 0x10000)
  {
    v9 = 0;
    *v8 = a2;
    a2 = -1;
LABEL_7:
    v11 = 1;
    goto LABEL_8;
  }
  *v8 = (a2 >> 10) - 10304;
  v10 = v8 + 1;
  if ((unint64_t)v10 >= a4)
  {
    v9 = 0;
    a2 = a2 & 0x3FF | 0xDC00;
    goto LABEL_7;
  }
  *v10 = a2 & 0x3FF | 0xDC00;
  v9 = 1;
  a2 = -1;
  v11 = 2;
LABEL_8:
  v8 = &v7[v11];
  if (a5)
  {
    v12 = *a5;
    if (*a5)
    {
      *v12 = a6;
      v13 = v12 + 1;
      if (v9)
      {
        v13 = v12 + 2;
        v12[1] = a6;
      }
      *a5 = v13;
    }
  }
LABEL_13:
  *a3 = (unint64_t)v8;
  if ((a2 & 0x80000000) == 0)
  {
    if (result)
    {
      if (HIWORD(a2))
      {
        v15 = a2 & 0x3FF | 0xDC00;
        a2 = (a2 >> 10) - 10304;
        *(_WORD *)(result + 146) = v15;
        v14 = 2;
      }
      else
      {
        v14 = 1;
      }
      *(_WORD *)(result + 144) = a2;
      *(_BYTE *)(result + 93) = v14;
    }
    *a7 = 15;
  }
  return result;
}

void sub_18BC17768(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  __int128 v8[2];
  uint64_t v9;
  _OWORD v10[14];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v6 = uprv_malloc(0xA8uLL);
  *(_QWORD *)(a1 + 16) = v6;
  if (v6)
  {
    v7 = v6;
    memset(v10, 0, sizeof(v10));
    v9 = 0;
    memset(v8, 0, sizeof(v8));
    LODWORD(v8[0]) = 40;
    *v6 = 0;
    v6[1] = sub_18BC15C78("icu-internal-compound-s1", v10, v8, a3);
    v7[2] = sub_18BC15C78("icu-internal-compound-s2", v10, v8, a3);
    v7[3] = sub_18BC15C78("icu-internal-compound-s3", v10, v8, a3);
    v7[4] = sub_18BC15C78("icu-internal-compound-d1", v10, v8, a3);
    v7[5] = sub_18BC15C78("icu-internal-compound-d2", v10, v8, a3);
    v7[6] = sub_18BC15C78("icu-internal-compound-d3", v10, v8, a3);
    v7[7] = sub_18BC15C78("icu-internal-compound-d4", v10, v8, a3);
    v7[8] = sub_18BC15C78("icu-internal-compound-d5", v10, v8, a3);
    v7[9] = sub_18BC15C78("icu-internal-compound-d6", v10, v8, a3);
    v7[10] = sub_18BC15C78("icu-internal-compound-d7", v10, v8, a3);
    v7[11] = sub_18BC15C78("icu-internal-compound-t", v10, v8, a3);
    v7[12] = sub_18BC15C78("ibm-915_P100-1995", v10, v8, a3);
    v7[13] = sub_18BC15C78("ibm-916_P100-1995", v10, v8, a3);
    v7[14] = sub_18BC15C78("ibm-914_P100-1995", v10, v8, a3);
    v7[15] = sub_18BC15C78("ibm-874_P100-1995", v10, v8, a3);
    v7[16] = sub_18BC15C78("ibm-912_P100-1995", v10, v8, a3);
    v7[17] = sub_18BC15C78("ibm-913_P100-2000", v10, v8, a3);
    v7[18] = sub_18BC15C78("iso-8859_14-1998", v10, v8, a3);
    v7[19] = sub_18BC15C78("ibm-923_P100-1998", v10, v8, a3);
    if (*(int *)a3 > 0 || *(_BYTE *)(a2 + 8))
      sub_18BC17A5C(a1);
    else
      *((_DWORD *)v7 + 40) = 0;
  }
  else
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }
}

void sub_18BC17A5C(uint64_t a1)
{
  uint64_t v1;
  uint64_t i;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
  {
    for (i = 0; i != 160; i += 8)
    {
      v4 = *(_QWORD *)(v1 + i);
      if (v4)
        sub_18BC15BD4(v4);
    }
    uprv_free(*(void **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
  }
}

size_t sub_18BC17AB4(_QWORD *a1, int *a2)
{
  _WORD *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  size_t result;
  int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  _WORD __dst[4];
  uint64_t v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  _WORD *v39;

  v5 = (unsigned __int8 *)a1[3];
  v4 = (_WORD *)a1[4];
  v6 = (unsigned __int8 *)a1[2];
  v7 = *(_QWORD *)(a1[1] + 16);
  if (*(unsigned __int16 *)a1 >= 0x38u)
    v8 = 56;
  else
    v8 = *(unsigned __int16 *)a1;
  if (v8 <= 0x37)
    v9 = 56 - v8;
  else
    v9 = 0;
  bzero((char *)__dst + v8, v9);
  result = (size_t)memcpy(__dst, a1, v8);
  __dst[0] = v8;
  v34 = v7;
  v11 = *(_DWORD *)(v7 + 160);
  while (1)
  {
LABEL_8:
    if (v6 >= v5)
      goto LABEL_57;
    v12 = a1[5];
    if ((unint64_t)v4 >= v12)
    {
      v28 = 15;
LABEL_56:
      *a2 = v28;
      goto LABEL_57;
    }
    v13 = a1[1];
    v14 = *(char *)(v13 + 64);
    v15 = (int)v14 <= 0 ? v6 : (unsigned __int8 *)(v13 + 65);
    if (*v15 == 27)
      break;
LABEL_29:
    if (v11)
    {
      if (v6 < v5)
      {
        v22 = (_DWORD)v5 - (_DWORD)v6;
        if ((int)v5 - (int)v6 > 1)
        {
          v23 = 1;
          while (v6[v23] != 27)
          {
            if ((_DWORD)v5 - (_DWORD)v6 == ++v23)
              goto LABEL_43;
          }
          v22 = v23;
        }
LABEL_43:
        v37 = v6;
        v38 = &v6[v22];
        v39 = v4;
        v26 = *(_QWORD *)(v36 + 48);
        *(_QWORD *)(v36 + 48) = *(_QWORD *)(v34 + 8 * v11);
        result = sub_18BC262B0((uint64_t)__dst, a2);
        v27 = v36;
        v6 = v37;
        *(_QWORD *)(v36 + 48) = v26;
        v4 = v39;
        if (*a2 >= 1)
        {
          if (*a2 == 15)
          {
            v33 = *(char *)(v27 + 93);
            if (v33 >= 1)
            {
              result = (size_t)memcpy((void *)(a1[1] + 144), (const void *)(v27 + 144), *(unsigned __int8 *)(v27 + 93));
              LOBYTE(v33) = *(_BYTE *)(v27 + 93);
            }
            *(_BYTE *)(a1[1] + 93) = v33;
            *(_BYTE *)(v27 + 93) = 0;
          }
          goto LABEL_57;
        }
      }
    }
    else if (v6 < v5)
    {
      v24 = v5 - v6;
      while (1)
      {
        v25 = *v6;
        if (v25 == 27)
          break;
        if ((unint64_t)v4 >= v12)
        {
          *a2 = 15;
          goto LABEL_8;
        }
        ++v6;
        *v4++ = v25;
        if (!--v24)
        {
          v6 = v5;
          goto LABEL_8;
        }
      }
    }
  }
  v16 = 0;
  v17 = &v6[-v14];
  v18 = (unsigned __int8 *)&unk_18BE12FE9;
  while (2)
  {
    v19 = 0;
    v20 = 27;
    while (v19 < v14)
    {
      v21 = *(unsigned __int8 *)(v13 + 65 + v19);
LABEL_20:
      if (v21 != v20)
        goto LABEL_24;
      v20 = v18[v19++];
      if (!v20)
      {
        if (*a2 != 11)
        {
          if ((_DWORD)v16 != -2)
          {
            result = strlen((const char *)&unk_18BE12FE8 + 5 * (int)v16);
            v6 += (int)result - (int)v14;
            *(_BYTE *)(v13 + 64) = 0;
            v11 = v16;
            goto LABEL_29;
          }
          goto LABEL_53;
        }
        goto LABEL_48;
      }
    }
    if (&v17[v19] < v5)
    {
      v21 = (char)v17[v19];
      goto LABEL_20;
    }
    *a2 = 11;
LABEL_24:
    ++v16;
    v18 += 5;
    if (v16 != 20)
      continue;
    break;
  }
  if (*a2 != 11)
  {
LABEL_53:
    if (!(_DWORD)v14)
      ++v6;
    v28 = 12;
    goto LABEL_56;
  }
LABEL_48:
  if (v6 < v5)
  {
    v29 = v5 - v6;
    do
    {
      v30 = *v6++;
      v31 = a1[1];
      v32 = *(char *)(v31 + 64);
      *(_BYTE *)(v31 + 64) = v32 + 1;
      *(_BYTE *)(v31 + v32 + 65) = v30;
      --v29;
    }
    while (v29);
    v6 = v5;
  }
  *a2 = 0;
LABEL_57:
  *(_DWORD *)(v34 + 160) = v11;
  a1[4] = v4;
  a1[2] = v6;
  return result;
}

uint64_t sub_18BC17DA0(uint64_t result, int *a2)
{
  _QWORD *v2;
  _BYTE *v3;
  unint64_t v4;
  uint64_t v5;
  unsigned __int16 *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v16;
  char *v17;
  _BYTE *v18;
  int v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  unint64_t v25;
  int *v26;
  uint64_t v27;
  unsigned int v28;
  _BYTE *v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  char v34;
  _BYTE *v35;
  int v36;
  unsigned int v37;
  _BYTE *v38;
  int v39;
  int v40;
  unint64_t v41;
  uint64_t v42;
  char *v43;
  unint64_t v44;
  char v45;
  int v46;
  char *v47;
  unint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int *v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int *v57;
  char v58;
  unsigned __int16 *v59;
  unsigned int v60;
  _BYTE v61[8];

  v2 = (_QWORD *)result;
  v3 = *(_BYTE **)(result + 32);
  v4 = *(_QWORD *)(result + 40);
  v5 = *(_QWORD *)(result + 8);
  v6 = *(unsigned __int16 **)(result + 16);
  v7 = *(_QWORD *)(result + 24);
  v58 = *(_BYTE *)(v5 + 63);
  v60 = 0;
  memset(v61, 0, 7);
  v8 = *(_QWORD *)(v5 + 16);
  v9 = *(unsigned int *)(v8 + 160);
  v10 = *(_DWORD *)(v5 + 84);
  if (v10)
    v11 = (unint64_t)v3 >= v4;
  else
    v11 = 1;
  v56 = v5;
  v57 = a2;
  v54 = v7;
  v55 = v4;
  if (v11)
    goto LABEL_6;
  while ((unint64_t)v6 < v7)
  {
    v13 = *v6;
    if ((v13 & 0xFC00) != 0xDC00)
    {
LABEL_72:
      *a2 = 12;
      break;
    }
    ++v6;
    v10 = v13 + (v10 << 10) - 56613888;
    *(_DWORD *)(v5 + 84) = 0;
    do
    {
      v14 = 0;
      if (v10 > 0xA || ((1 << v10) & 0x601) == 0)
      {
        v14 = 0;
        if ((v10 & 0xFFFFFF60) - 32 >= 0x60)
        {
          if ((v10 - 258) >= 0x10 || (v14 = 16, ((0xFC3Fu >> (v10 - 2)) & 1) == 0))
          {
            v32 = v10 & 0xFFFFFFFC;
            v14 = 16;
            if ((v10 & 0xFFFFFFFC) != 0x118 && (v10 & 0xFFFFFFFB) - 313 >= 2)
            {
              if ((v10 - 321) >= 0x15 || (v14 = 16, ((0x19804Fu >> (v10 - 65)) & 1) == 0))
              {
                v14 = 16;
                if (v32 != 344)
                {
                  v33 = v10 & 0xFFFFFFFE;
                  if ((v10 & 0xFFFFFFFE) != 0x15E)
                  {
                    v14 = 16;
                    if (((v10 - 352) > 0x1E || ((1 << (v10 - 96)) & 0x7E03C03F) == 0)
                      && ((v10 - 711) > 0x16 || ((1 << (v10 + 57)) & 0x560001) == 0))
                    {
                      v14 = 17;
                      if (v32 != 264)
                      {
                        if ((v10 - 284) >= 6)
                        {
                          v14 = 17;
                        }
                        else
                        {
                          v14 = 17;
                          if (((0x33u >> (v10 - 28)) & 1) != 0)
                            goto LABEL_17;
                        }
                        if (v32 != 292)
                        {
                          if ((v10 - 308) > 0x39
                            || (v14 = 17, ((1 << (v10 - 52)) & 0x300030000000003) == 0))
                          {
                            v14 = 18;
                            if (v32 != 372)
                            {
                              v14 = 18;
                              if (v10 <= 7765)
                              {
                                if ((v10 - 7690) <= 0x37
                                  && ((1 << (v10 - 10)) & 0xC0000000300003) != 0)
                                {
                                  goto LABEL_17;
                                }
                                v52 = v5;
                                v53 = a2;
                                if ((v10 - 338) <= 0x26
                                  && ((1 << (v10 - 82)) & 0x4000000003) != 0)
                                {
LABEL_91:
                                  v14 = 19;
LABEL_92:
                                  a2 = v53;
                                  v5 = v52;
                                  goto LABEL_17;
                                }
                              }
                              else
                              {
                                if ((v10 - 7766) <= 0x2F
                                  && ((1 << (v10 - 86)) & 0xFC0000300C03) != 0
                                  || (v10 - 7922) < 2)
                                {
                                  goto LABEL_17;
                                }
                                v52 = v5;
                                v53 = a2;
                                if (v10 == 8364)
                                  goto LABEL_91;
                              }
                              v14 = 15;
                              if ((v10 - 3585) < 0x3A)
                                goto LABEL_92;
                              a2 = v53;
                              v5 = v52;
                              if ((v10 - 3647) >= 0x1D)
                              {
                                if ((v10 - 256) > 0x23
                                  || (v14 = 14, ((1 << v10) & 0xC00CC0003) == 0))
                                {
                                  v59 = v6;
                                  v14 = 14;
                                  if (v32 == 296)
                                    goto LABEL_124;
                                  v5 = v56;
                                  a2 = v57;
                                  v7 = v54;
                                  v4 = v55;
                                  if (v33 != 302)
                                  {
                                    if ((v10 - 310) > 0x3D
                                      || (v14 = 14, ((1 << (v10 - 54)) & 0x303F000300F18067) == 0))
                                    {
                                      v14 = 2;
                                      if (v33 != 700)
                                      {
                                        v14 = 2;
                                        if (v10 == 8213)
                                          goto LABEL_124;
                                        v5 = v56;
                                        a2 = v57;
                                        v7 = v54;
                                        v4 = v55;
                                        if ((v10 - 900) >= 0x4B)
                                        {
                                          if ((v10 - 1548) > 0x13
                                            || (v14 = 3, ((1 << (v10 - 12)) & 0x88001) == 0))
                                          {
                                            v14 = 3;
                                            if ((v10 - 1569) < 0x1A)
                                              goto LABEL_124;
                                            v5 = v56;
                                            a2 = v57;
                                            v7 = v54;
                                            v4 = v55;
                                            if ((v10 - 1600) < 0x13)
                                              goto LABEL_17;
                                            v14 = 3;
                                            if (v10 == 8203)
                                              goto LABEL_124;
                                            v5 = v56;
                                            a2 = v57;
                                            v7 = v54;
                                            v4 = v55;
                                            if ((v10 - 1632) < 0xE)
                                              goto LABEL_17;
                                            if ((v10 - 65136) >= 5)
                                            {
                                              v14 = 3;
                                              v5 = v56;
                                              a2 = v57;
                                              v7 = v54;
                                              v4 = v55;
                                              if ((v10 - 65142) < 0x49)
                                                goto LABEL_17;
                                            }
                                            else
                                            {
                                              v14 = 3;
                                              if (((0x17u >> (v10 - 112)) & 1) != 0)
                                                goto LABEL_124;
                                              v5 = v56;
                                              a2 = v57;
                                              v7 = v54;
                                              v4 = v55;
                                              if ((v10 - 65142) <= 0x48)
                                                goto LABEL_17;
                                            }
                                            v14 = 13;
                                            if ((v10 - 1488) < 0x1B)
                                              goto LABEL_17;
                                            v14 = 13;
                                            if (v10 == 8215)
                                              goto LABEL_124;
                                            v5 = v56;
                                            a2 = v57;
                                            v7 = v54;
                                            v4 = v55;
                                            if (v10 == 8254)
                                              goto LABEL_17;
                                            v14 = 12;
                                            if (v10 == 8470)
                                            {
LABEL_124:
                                              v5 = v56;
                                              a2 = v57;
                                              v7 = v54;
                                              v4 = v55;
                                              goto LABEL_17;
                                            }
                                            v5 = v56;
                                            a2 = v57;
                                            v7 = v54;
                                            v4 = v55;
                                            if ((v10 - 1025) >= 0x5F)
                                            {
                                              if ((v10 - 286) > 0x13
                                                || (v14 = 1, ((1 << (v10 - 30)) & 0xC0003) == 0))
                                              {
                                                v14 = 1;
                                                if (v32 != 536)
                                                {
                                                  LODWORD(v16) = 0;
LABEL_23:
                                                  v21 = 1;
                                                  v22 = v9;
                                                  v23 = v9;
                                                  v24 = &byte_18BE12FEE;
                                                  while (1)
                                                  {
                                                    result = sub_18BC28B6C(*(_QWORD *)(v8 + 8 * v21), v10, (int *)&v60, v58);
                                                    if ((int)result >= 1)
                                                      break;
                                                    ++v21;
                                                    v24 += 5;
                                                    if (v21 == 12)
                                                    {
                                                      v9 = v23;
                                                      v5 = v56;
                                                      a2 = v57;
                                                      v7 = v54;
                                                      v4 = v55;
                                                      goto LABEL_32;
                                                    }
                                                  }
                                                  if ((_DWORD)v22 == (_DWORD)v21)
                                                  {
                                                    v9 = v22;
                                                    v5 = v56;
                                                    a2 = v57;
                                                    v6 = v59;
                                                  }
                                                  else
                                                  {
                                                    v34 = *(v24 - 1);
                                                    v35 = &v61[v16];
                                                    v5 = v56;
                                                    a2 = v57;
                                                    v6 = v59;
                                                    do
                                                    {
                                                      *v35++ = v34;
                                                      v36 = *v24++;
                                                      v34 = v36;
                                                      LODWORD(v16) = v16 + 1;
                                                    }
                                                    while (v36);
                                                    v9 = v21;
                                                  }
                                                  v37 = v60;
                                                  v38 = &v61[(int)v16];
                                                  v39 = result + 1;
                                                  v40 = 8 * result - 8;
                                                  v7 = v54;
                                                  v4 = v55;
                                                  do
                                                  {
                                                    *v38++ = v37 >> v40;
                                                    LODWORD(v16) = v16 + 1;
                                                    --v39;
                                                    v40 -= 8;
                                                  }
                                                  while (v39 > 1);
                                                  goto LABEL_57;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
LABEL_17:
      LODWORD(v16) = 0;
      if ((_DWORD)v9 != (_DWORD)v14)
      {
        v16 = 0;
        v17 = (char *)&unk_18BE12FE8 + 5 * v14;
        v20 = *v17;
        v18 = v17 + 1;
        LOBYTE(v19) = v20;
        do
        {
          v61[v16] = v19;
          v19 = v18[v16++];
        }
        while (v19);
        v9 = v14;
      }
      if ((_DWORD)v9)
      {
        v59 = v6;
        if ((_DWORD)v9 != -1)
        {
          v25 = v4;
          v26 = a2;
          v27 = v9;
          result = sub_18BC28B6C(*(_QWORD *)(v8 + 8 * (int)v9), v10, (int *)&v60, v58);
          if ((int)result >= 1)
          {
            v28 = v60;
            v29 = &v61[v16];
            v30 = result + 1;
            v31 = 8 * result - 8;
            LODWORD(v16) = result + v16;
            do
            {
              *v29++ = v28 >> v31;
              --v30;
              v31 -= 8;
            }
            while (v30 > 1);
          }
          v9 = v27;
          a2 = v26;
          v4 = v25;
LABEL_32:
          v6 = v59;
          goto LABEL_57;
        }
        goto LABEL_23;
      }
      v61[v16] = v10;
      LODWORD(v16) = v16 + 1;
LABEL_57:
      if ((int)v16 < 1)
      {
        LODWORD(v41) = 0;
LABEL_65:
        v46 = *a2;
      }
      else
      {
        v41 = v4 - (_QWORD)v3;
        if (v4 < (unint64_t)v3)
          v41 = 0;
        v42 = v16;
        v43 = v61;
        v44 = v41;
        while (v44)
        {
          v45 = *v43++;
          *v3++ = v45;
          --v44;
          if (!--v42)
          {
            LODWORD(v41) = v16;
            goto LABEL_65;
          }
        }
        v46 = 15;
        *a2 = 15;
      }
      if (v46 == 15 && (int)v41 < (int)v16)
      {
        v47 = &v61[v41];
        v48 = v16 - (unint64_t)v41;
        do
        {
          v49 = *v47++;
          v50 = v2[1];
          v51 = *(char *)(v50 + 91);
          *(_BYTE *)(v50 + 91) = v51 + 1;
          *(_BYTE *)(v50 + v51 + 104) = v49;
          --v48;
        }
        while (v48);
      }
LABEL_6:
      if ((unint64_t)v6 >= v7)
        goto LABEL_75;
      if ((unint64_t)v3 >= v4)
      {
        *a2 = 15;
        goto LABEL_75;
      }
      v12 = *v6++;
      v10 = v12;
    }
    while ((v12 & 0xF800) != 0xD800);
    if ((v10 & 0x400) != 0)
      goto LABEL_72;
  }
  *(_DWORD *)(v5 + 84) = v10;
LABEL_75:
  *(_DWORD *)(v8 + 160) = v9;
  v2[2] = v6;
  v2[4] = v3;
  return result;
}

const char *sub_18BC185BC()
{
  return "x11-compound-text";
}

uint64_t sub_18BC185C8(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v7;
  uint64_t i;

  v7 = *(_QWORD *)(a1 + 16);
  for (i = 8; i != 160; i += 8)
    sub_18BC2629C(*(_QWORD *)(v7 + i), a2, a3, a4);
  ((void (*)(uint64_t, _QWORD))a2[1])(*a2, 0);
  ((void (*)(uint64_t, uint64_t))a2[1])(*a2, 9);
  ((void (*)(uint64_t, uint64_t))a2[1])(*a2, 10);
  ((void (*)(uint64_t, uint64_t, uint64_t))a2[2])(*a2, 32, 127);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))a2[2])(*a2, 160, 255);
}

void UCNV_FROM_U_CALLBACK_STOP(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, _DWORD *a7)
{
  int v7;

  if (!a6)
  {
    if (a5 <= 8202)
    {
      if (a5 > 6067)
      {
        if ((a5 - 6155) < 5)
          goto LABEL_17;
        v7 = -6068;
      }
      else
      {
        if (a5 <= 4446)
        {
          if (a5 == 173 || a5 == 847 || a5 == 1564)
            goto LABEL_17;
          goto LABEL_18;
        }
        v7 = -4447;
      }
      if ((a5 + v7) < 2)
        goto LABEL_17;
      goto LABEL_18;
    }
    if ((a5 - 8203) <= 0x23 && ((1 << (a5 - 11)) & 0xF8000001FLL) != 0)
      goto LABEL_17;
LABEL_18:
    if (a5 != 12644
      && (a5 & 0xFFFFFFF0) != 0x2060
      && (a5 & 0xFFFFF000) != 0xE0000
      && (a5 - 119155) >= 8
      && (a5 & 0xFFFFFFFC) != 0x1BCA0
      && (a5 - 65520) >= 9
      && a5 != 65440
      && a5 != 65279
      && (a5 & 0xFFFFFFF0) != 0xFE00)
    {
      return;
    }
LABEL_17:
    *a7 = 0;
  }
}

_BYTE *UCNV_FROM_U_CALLBACK_SKIP(_BYTE *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, _DWORD *a7)
{
  int v7;

  if (a6 <= 2)
  {
    if (a6)
    {
LABEL_3:
      if (result && (a6 || *result != 105))
        return result;
LABEL_21:
      *a7 = 0;
      return result;
    }
    if (a5 <= 8202)
    {
      if (a5 > 6067)
      {
        if ((a5 - 6155) < 5)
          goto LABEL_21;
        v7 = -6068;
      }
      else
      {
        if (a5 <= 4446)
        {
          if (a5 == 173 || a5 == 847 || a5 == 1564)
            goto LABEL_21;
LABEL_22:
          if (a5 == 12644
            || (a5 & 0xFFFFFFF0) == 0x2060
            || (a5 & 0xFFFFF000) == 0xE0000
            || (a5 - 119155) < 8
            || (a5 & 0xFFFFFFFC) == 0x1BCA0
            || (a5 - 65520) < 9
            || a5 == 65440
            || a5 == 65279
            || (a5 & 0xFFFFFFF0) == 0xFE00)
          {
            goto LABEL_21;
          }
          goto LABEL_3;
        }
        v7 = -4447;
      }
      if ((a5 + v7) < 2)
        goto LABEL_21;
      goto LABEL_22;
    }
    if ((a5 - 8203) <= 0x23 && ((1 << (a5 - 11)) & 0xF8000001FLL) != 0)
      goto LABEL_21;
    goto LABEL_22;
  }
  return result;
}

_BYTE *UCNV_FROM_U_CALLBACK_SUBSTITUTE(_BYTE *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int *a7)
{
  int v7;

  if (a6 > 2)
    return result;
  if (!a6)
  {
    if (a5 <= 8202)
    {
      if (a5 > 6067)
      {
        if ((a5 - 6155) < 5)
          goto LABEL_22;
        v7 = -6068;
      }
      else
      {
        if (a5 <= 4446)
        {
          if (a5 == 173 || a5 == 847 || a5 == 1564)
            goto LABEL_22;
          goto LABEL_23;
        }
        v7 = -4447;
      }
      if ((a5 + v7) < 2)
        goto LABEL_22;
      goto LABEL_23;
    }
    if ((a5 - 8203) <= 0x23 && ((1 << (a5 - 11)) & 0xF8000001FLL) != 0)
      goto LABEL_22;
LABEL_23:
    if (a5 != 12644
      && (a5 & 0xFFFFFFF0) != 0x2060
      && (a5 & 0xFFFFF000) != 0xE0000
      && (a5 - 119155) >= 8
      && (a5 & 0xFFFFFFFC) != 0x1BCA0
      && (a5 - 65520) >= 9
      && a5 != 65440
      && a5 != 65279
      && (a5 & 0xFFFFFFF0) != 0xFE00)
    {
      goto LABEL_3;
    }
LABEL_22:
    *a7 = 0;
    return result;
  }
LABEL_3:
  if (!result || !a6 && *result == 105)
  {
    *a7 = 0;
    return (_BYTE *)ucnv_cbFromUWriteSub(a2, 0, a7);
  }
  return result;
}

char *UCNV_FROM_U_CALLBACK_ESCAPE(char *result, uint64_t a2, unsigned __int16 *a3, int a4, int a5, int a6, int *a7)
{
  unsigned int v8;
  uint64_t v9;
  char *v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  char *v21;
  __int16 v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  _OWORD *v35;
  _OWORD v36[6];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  v33 = 0;
  v31 = 0;
  if (a6 <= 2)
  {
    v8 = a5;
    LODWORD(v9) = a4;
    v12 = result;
    if (a6)
    {
LABEL_3:
      memset(v36, 0, sizeof(v36));
      v32 = 0;
      v30 = 0;
      result = (char *)ucnv_setFromUCallBack(*(_QWORD **)(a2 + 8), (uint64_t)UCNV_FROM_U_CALLBACK_SUBSTITUTE, 0, &v33, &v32, &v34);
      v13 = v34;
      if (v34 <= 0)
      {
        if (!v12)
        {
          if ((int)v9 < 1)
            goto LABEL_61;
          v17 = 0;
          v9 = v9;
          do
          {
            *(_DWORD *)((char *)v36 + 2 * v17) = 5570597;
            v18 = *a3++;
            v17 += uprv_itou((__int16 *)v36 + v17 + 2, 46 - v17, v18, 0x10u, 4) + 2;
            --v9;
          }
          while (v9);
LABEL_64:
          v35 = v36;
          *a7 = 0;
          ucnv_cbFromUWriteUChars(a2, (unint64_t *)&v35, (unint64_t)v36 + 2 * v17, 0, a7);
          result = (char *)ucnv_setFromUCallBack(*(_QWORD **)(a2 + 8), v33, v32, &v31, &v30, &v34);
          v13 = v34;
          if (v34 < 1)
            return result;
          goto LABEL_65;
        }
        v14 = *v12;
        if (v14 <= 82)
        {
          switch(v14)
          {
            case 'C':
              LOWORD(v36[0]) = 92;
              if ((_DWORD)v9 == 2)
              {
                WORD1(v36[0]) = 85;
                v23 = v8;
                v24 = 8;
              }
              else
              {
                WORD1(v36[0]) = 117;
                v23 = *a3;
                v24 = 4;
              }
              v17 = uprv_itou((__int16 *)v36 + 2, 46, v23, 0x10u, v24) + 2;
              goto LABEL_64;
            case 'D':
              LODWORD(v36[0]) = 2293798;
              if ((_DWORD)v9 != 2)
                v8 = *a3;
              v25 = uprv_itou((__int16 *)v36 + 2, 46, v8, 0xAu, 0);
              v17 = v25 + 3;
              *((_WORD *)v36 + v25 + 2) = 59;
              goto LABEL_64;
            case 'J':
              if ((int)v9 >= 1)
              {
                v15 = 0;
                v9 = v9;
                do
                {
                  *(_DWORD *)((char *)v36 + 2 * v15) = 7667804;
                  v16 = *a3++;
                  v15 += uprv_itou((__int16 *)v36 + v15 + 2, 46 - v15, v16, 0x10u, 4) + 2;
                  v17 = v15;
                  --v9;
                }
                while (v9);
                goto LABEL_64;
              }
LABEL_61:
              v17 = 0;
              goto LABEL_64;
          }
          goto LABEL_57;
        }
        switch(v14)
        {
          case 'S':
            LOWORD(v36[0]) = 92;
            v26 = uprv_itou((__int16 *)v36 + 1, 47, v8, 0x10u, 0);
            v17 = v26 + 2;
            *((_WORD *)v36 + v26 + 1) = 32;
            goto LABEL_64;
          case 'U':
            LODWORD(v36[0]) = 5570683;
            WORD2(v36[0]) = 43;
            if ((_DWORD)v9 != 2)
              v8 = *a3;
            v27 = uprv_itou((__int16 *)v36 + 3, 45, v8, 0x10u, 4);
            v17 = v27 + 4;
            v21 = (char *)v36 + 2 * v27;
            v22 = 125;
            break;
          case 'X':
            LODWORD(v36[0]) = 2293798;
            WORD2(v36[0]) = 120;
            if ((_DWORD)v9 != 2)
              v8 = *a3;
            v20 = uprv_itou((__int16 *)v36 + 3, 45, v8, 0x10u, 0);
            v17 = v20 + 4;
            v21 = (char *)v36 + 2 * v20;
            v22 = 59;
            break;
          default:
LABEL_57:
            if ((int)v9 < 1)
              goto LABEL_61;
            v28 = 0;
            v9 = v9;
            do
            {
              *(_DWORD *)((char *)v36 + 2 * v28) = 5570597;
              v29 = *a3++;
              v28 += uprv_itou((__int16 *)v36 + v28 + 2, 46 - v28, v29, 0x10u, 4) + 2;
              v17 = v28;
              --v9;
            }
            while (v9);
            goto LABEL_64;
        }
        *((_WORD *)v21 + 3) = v22;
        goto LABEL_64;
      }
LABEL_65:
      *a7 = v13;
      return result;
    }
    v13 = 0;
    if (a5 <= 8202)
    {
      if (a5 > 6067)
      {
        if ((a5 - 6155) < 5)
          goto LABEL_65;
        v19 = -6068;
      }
      else
      {
        if (a5 <= 4446)
        {
          if (a5 == 173 || a5 == 847 || a5 == 1564)
            goto LABEL_65;
LABEL_37:
          v13 = 0;
          if (a5 == 12644)
            goto LABEL_65;
          if ((a5 & 0xFFFFFFF0) == 0x2060)
            goto LABEL_65;
          v13 = 0;
          if ((a5 & 0xFFFFF000) == 0xE0000
            || (a5 - 119155) < 8
            || (a5 & 0xFFFFFFFC) == 0x1BCA0
            || (a5 - 65520) < 9
            || a5 == 65440
            || a5 == 65279
            || (a5 & 0xFFFFFFF0) == 0xFE00)
          {
            goto LABEL_65;
          }
          goto LABEL_3;
        }
        v19 = -4447;
      }
      if ((a5 + v19) < 2)
        goto LABEL_65;
      goto LABEL_37;
    }
    if ((a5 - 8203) <= 0x23 && ((1 << (a5 - 11)) & 0xF8000001FLL) != 0)
      goto LABEL_65;
    goto LABEL_37;
  }
  return result;
}

_BYTE *UCNV_TO_U_CALLBACK_SKIP(_BYTE *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, _DWORD *a6)
{
  if (a5 <= 2 && (!result || !a5 && *result == 105))
    *a6 = 0;
  return result;
}

_BYTE *UCNV_TO_U_CALLBACK_SUBSTITUTE(_BYTE *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  if (a5 <= 2 && (!result || !a5 && *result == 105))
  {
    *a6 = 0;
    return (_BYTE *)ucnv_cbToUWriteSub(a2, 0, a6);
  }
  return result;
}

char *UCNV_TO_U_CALLBACK_ESCAPE(char *result, uint64_t a2, unsigned __int8 *a3, int a4, int a5, int *a6)
{
  int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  __int16 *v28;
  uint64_t v29;
  unsigned int v30;
  _OWORD v31[6];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a5 <= 2)
  {
    memset(v31, 0, sizeof(v31));
    if (result)
    {
      v9 = *result;
      switch(v9)
      {
        case 'X':
          if (a4 >= 1)
          {
            v16 = 0;
            v17 = a4;
            do
            {
              v18 = (char *)v31 + 2 * v16;
              *(_DWORD *)v18 = 2293798;
              v19 = v16 + 3;
              *((_WORD *)v18 + 2) = 120;
              v20 = *a3++;
              v21 = uprv_itou((__int16 *)v31 + v19, 45 - v16, v20, 0x10u, 0);
              v16 = v21 + v19 + 1;
              *((_WORD *)v31 + v21 + (int)v19) = 59;
              v13 = v16;
              --v17;
            }
            while (v17);
            goto LABEL_27;
          }
          break;
        case 'D':
          if (a4 >= 1)
          {
            v22 = 0;
            v23 = a4;
            do
            {
              *(_DWORD *)((char *)v31 + 2 * v22) = 2293798;
              v24 = v22 + 2;
              v25 = *a3++;
              v26 = uprv_itou((__int16 *)v31 + v24, 46 - v22, v25, 0xAu, 0);
              v22 = v26 + v24 + 1;
              *((_WORD *)v31 + v26 + (int)v24) = 59;
              v13 = v22;
              --v23;
            }
            while (v23);
            goto LABEL_27;
          }
          break;
        case 'C':
          if (a4 >= 1)
          {
            v10 = 0;
            v11 = a4;
            do
            {
              *(_DWORD *)((char *)v31 + 2 * v10) = 7864412;
              v12 = *a3++;
              v10 += uprv_itou((__int16 *)v31 + v10 + 2, 46 - v10, v12, 0x10u, 2) + 2;
              v13 = v10;
              --v11;
            }
            while (v11);
            goto LABEL_27;
          }
          break;
        default:
          if (a4 >= 1)
          {
            v27 = 0;
            v28 = (__int16 *)v31 + 2;
            v29 = 4 * a4;
            do
            {
              *((_DWORD *)v28 - 1) = 5767205;
              v30 = *a3++;
              uprv_itou(v28, v27 + 46, v30, 0x10u, 2);
              v27 -= 4;
              v28 += 4;
            }
            while (v29 + v27);
            v13 = -(int)v27;
            goto LABEL_27;
          }
          break;
      }
    }
    else if (a4 >= 1)
    {
      v13 = 0;
      v14 = a4;
      do
      {
        *(_DWORD *)((char *)v31 + 2 * v13) = 5767205;
        v15 = *a3++;
        v13 += uprv_itou((__int16 *)v31 + v13 + 2, 46 - v13, v15, 0x10u, 2) + 2;
        --v14;
      }
      while (v14);
      goto LABEL_27;
    }
    v13 = 0;
LABEL_27:
    *a6 = 0;
    return (char *)ucnv_cbToUWriteUChars(a2, (__int16 *)v31, v13, 0, a6);
  }
  return result;
}

uint64_t sub_18BC19238(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, int a5, unint64_t *a6, unint64_t a7, _QWORD *a8, int a9, unsigned __int8 a10, _DWORD *a11)
{
  int v15;
  int v18;
  int v19;
  _BYTE *v20;
  char *v21;
  int v22;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  char v28;
  unsigned int v29;

  v15 = a3;
  v29 = 0;
  v18 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 252);
  if (v18 == 12)
  {
    v19 = *(_DWORD *)(a1 + 76);
  }
  else if (v18 == 219)
  {
    LOBYTE(v19) = 1;
  }
  else
  {
    LOBYTE(v19) = -1;
  }
  v20 = (_BYTE *)(a1 + 65);
  v21 = (char *)*a4;
  v22 = sub_18BC193D8(a2, (char)v19, a1 + 65, a3, *a4, a5 - *a4, &v29, a10);
  if (v22 < 1)
  {
    if ((v22 & 0x80000000) == 0)
      return 0;
    *(_BYTE *)(a1 + 283) = v15;
    if (v15 < 1)
    {
      v15 = 0;
    }
    else
    {
      v24 = v15;
      do
      {
        v20[185] = *v20;
        ++v20;
        --v24;
      }
      while (v24);
      v21 = (char *)*a4;
    }
    v25 = -v22;
    if (v15 < (int)v25)
    {
      v26 = (_BYTE *)(a1 + v15 + 250);
      v27 = v25 - v15;
      do
      {
        v28 = *v21++;
        *v26++ = v28;
        --v27;
      }
      while (v27);
    }
    *a4 = (uint64_t)v21;
    *(_BYTE *)(a1 + 282) = -(char)v22;
  }
  else
  {
    *a4 = (uint64_t)&v21[v22 - v15];
    if (v29 >> 20 > 2)
      sub_18BC175EC(a1, (__int16 *)(a2 + *(int *)(a2 + 12) + 2 * (v29 & 0x3FFFF)), (v29 >> 18) - 12, (_WORD **)a6, a7, a8, a9, a11);
    else
      sub_18BC17694(a1, v29 - 2031616, a6, a7, (_DWORD **)a8, a9, a11);
  }
  return 1;
}

uint64_t sub_18BC193D8(uint64_t result, int a2, uint64_t a3, int a4, uint64_t a5, int a6, unsigned int *a7, unsigned __int8 a8)
{
  uint64_t v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  _DWORD *v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  int v36;

  if (!result)
    return result;
  v8 = result;
  if (*(int *)(result + 8) < 1)
    return 0;
  if (!a2)
  {
    if (a4 <= 1)
    {
      if (a6 >= 1)
        v10 = 1;
      else
        v10 = a6;
      if (a4 == 1)
        a6 = 0;
      else
        a6 = v10;
      v9 = 1;
      goto LABEL_14;
    }
    return 0;
  }
  v9 = a8;
LABEL_14:
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  result = 0;
  v15 = v8 + *(int *)(v8 + 4);
  while (1)
  {
    v16 = (unsigned int *)(v15 + 4 * v14);
    v19 = *v16;
    v17 = v16 + 1;
    v18 = v19;
    v20 = v19 & 0xFFFFFF;
    if ((v19 & 0xFFFFFF) != 0)
    {
      v21 = (a2 == 0) ^ (v13 + v12 != 1);
      if (a2 < 0)
        v21 = 1;
      if (v21)
      {
        v11 = v20;
        result = (v13 + v12);
      }
      else
      {
        result = result;
      }
    }
    if (v12 >= a4)
      break;
    v22 = v12++;
    v23 = a3;
LABEL_25:
    v24 = HIBYTE(v18);
    v25 = *(unsigned __int8 *)(v23 + v22);
    v26 = HIBYTE(v17[HIBYTE(v18) - 1]);
    if (v25 < HIBYTE(*v17) || v26 < v25)
      goto LABEL_60;
    v28 = HIBYTE(*v17);
    if (v26 - v28 + 1 == v24)
    {
      v29 = v17[v25 - v28];
    }
    else
    {
      v30 = v18 >> 25;
      if (v30)
      {
        v30 = 0;
        v31 = v25 << 24;
        v32 = v24;
        while (v32 > 4)
        {
          v33 = v30 + v24;
          if (v30 + v24 < 0 != __OFADD__(v30, v24))
            ++v33;
          v34 = v33 >> 1;
          if (((v25 << 24) | 0xFFFFFFu) < v17[v34])
            v24 = v34;
          else
            v30 = v34;
          v32 = v24 - v30;
          if (v24 - v30 <= 1)
            goto LABEL_49;
        }
        if (v31 > v17[v30])
        {
          v35 = v30 + 1;
          if ((int)v35 < v24 && v31 <= v17[v35] || (v35 = v30 + 2, v30 + 2 < v24) && v31 <= v17[v35])
            v30 = v35;
          else
            v30 += 3;
        }
      }
LABEL_49:
      if (v30 >= v24)
        goto LABEL_60;
      v29 = v17[v30];
      if (v25 != HIBYTE(v29))
        goto LABEL_60;
    }
    v14 = v29 & 0xFFFFFF;
    if (!v14)
      goto LABEL_60;
    if (v14 >= 0x1F0000)
    {
      v36 = (a2 == 0) ^ (v13 + v12 != 1);
      if (a2 < 0)
        v36 = 1;
      if (v36)
      {
        v11 = v14;
        result = (v13 + v12);
      }
      else
      {
        result = result;
      }
      goto LABEL_60;
    }
  }
  if (v13 < a6)
  {
    v22 = v13++;
    v23 = a5;
    goto LABEL_25;
  }
  if (!v9 && v13 + v12 <= 31)
    return -(v13 + v12);
LABEL_60:
  if ((_DWORD)result)
    *a7 = v11 & 0xFF7FFFFF;
  return result;
}

uint64_t sub_18BC195FC(uint64_t a1, uint64_t a2, int a3)
{
  int v4;
  unsigned int v7;

  v7 = 0;
  if (a3 < 1)
    return 0xFFFFLL;
  v4 = sub_18BC193D8(a1, -1, a2, a3, 0, 0, &v7, 1u);
  if (v7 < 0x300000 && v4 == a3)
    return v7 - 2031616;
  else
    return 65534;
}

uint64_t sub_18BC1966C(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  char *v13;
  uint64_t result;
  int v15;
  int v16;
  int v17;
  int v18;
  char v19;
  uint64_t v20;
  _BYTE *v21;
  uint64_t v22;
  char v23;
  unsigned int v24;

  v24 = 0;
  v8 = *(_QWORD *)(a1 + 48);
  v9 = *(unsigned __int8 *)(v8 + 252);
  if (v9 == 12)
  {
    v10 = *(_DWORD *)(a1 + 76);
  }
  else if (v9 == 219)
  {
    LOBYTE(v10) = 1;
  }
  else
  {
    LOBYTE(v10) = -1;
  }
  v11 = a1 + 250;
  v12 = *(char *)(a1 + 282);
  v13 = *(char **)(a2 + 16);
  result = sub_18BC193D8(*(_QWORD *)(v8 + 288), (char)v10, a1 + 250, v12, (uint64_t)v13, *(_DWORD *)(a2 + 24) - (int)v13, &v24, *(_BYTE *)(a2 + 2));
  if ((int)result < 1)
  {
    if ((result & 0x80000000) != 0)
    {
      v20 = -(int)result;
      if (v12 < (int)v20)
      {
        v21 = (_BYTE *)(a1 + v12 + 250);
        v22 = v20 - v12;
        do
        {
          v23 = *v13++;
          *v21++ = v23;
          --v22;
        }
        while (v22);
      }
      *(_QWORD *)(a2 + 16) = v13;
      *(_BYTE *)(a1 + 282) = -(char)result;
    }
    else
    {
      result = (uint64_t)memcpy((void *)(a1 + 65), (const void *)(a1 + 250), *(char *)(a1 + 283));
      v17 = *(char *)(a1 + 283);
      *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 283);
      v18 = *(char *)(a1 + 282);
      v19 = v18 - v17;
      if (v18 - v17 >= 1)
        result = (uint64_t)memmove((void *)(a1 + 250), (const void *)(v11 + v17), (v18 - v17));
      *(_BYTE *)(a1 + 282) = -v19;
      *a4 = 10;
    }
  }
  else
  {
    if ((int)result >= v12)
    {
      LOBYTE(v16) = 0;
      *(_QWORD *)(a2 + 16) = &v13[(int)result - v12];
    }
    else
    {
      v15 = v12 - result;
      memmove((void *)(a1 + 250), (const void *)(v11 + result), v12 - (int)result);
      v16 = -v15;
    }
    *(_BYTE *)(a1 + 282) = v16;
    if (v24 >> 20 > 2)
      return sub_18BC175EC(a1, (__int16 *)(*(_QWORD *)(v8 + 288) + *(int *)(*(_QWORD *)(v8 + 288) + 12) + 2 * (v24 & 0x3FFFF)), (v24 >> 18) - 12, (_WORD **)(a2 + 32), *(_QWORD *)(a2 + 40), (_QWORD *)(a2 + 48), a3, a4);
    else
      return sub_18BC17694(a1, v24 - 2031616, (unint64_t *)(a2 + 32), *(_QWORD *)(a2 + 40), (_DWORD **)(a2 + 48), a3, a4);
  }
  return result;
}

uint64_t sub_18BC19868(uint64_t a1, unint64_t a2, int a3, uint64_t *a4, uint64_t a5, _QWORD *a6, unint64_t a7, _QWORD *a8, int a9, char a10, _DWORD *a11)
{
  __int16 *v18;
  int v19;
  unsigned int v20;
  size_t v21;
  char *v22;
  _BYTE *v23;
  _BYTE *v24;
  uint64_t result;
  int v26;
  char v27;
  int v28;
  _WORD *v29;
  uint64_t v30;
  __int16 v31;
  unsigned int v32;
  _OWORD v33[2];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v32 = 0;
  v18 = (__int16 *)*a4;
  v19 = sub_18BC19AB4(a2, a3, 0, 0, *a4, (unint64_t)(a5 - *a4) >> 1, &v32, *(char *)(a1 + 63), a10);
  if (v19 < 2)
  {
    if (v19 < 0)
    {
      *(_DWORD *)(a1 + 208) = a3;
      if (v19 <= 0xFFFFFFFD)
      {
        v29 = (_WORD *)(a1 + 212);
        v30 = (-2 - v19);
        do
        {
          v31 = *v18++;
          *v29++ = v31;
          --v30;
        }
        while (v30);
      }
      *a4 = (uint64_t)v18;
      *(_BYTE *)(a1 + 281) = -2 - v19;
      return 1;
    }
    if (v19 == 1)
    {
      result = 0;
      *(_BYTE *)(a1 + 95) = 1;
      return result;
    }
    return 0;
  }
  v20 = v32;
  if ((v32 & 0x1F000000) == 0x1000000 && *(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 252) == 219)
    return 0;
  *a4 = (uint64_t)&v18[v19 - 2];
  memset(v33, 0, sizeof(v33));
  v21 = HIBYTE(v20) & 0x1F;
  if (v21 > 3)
  {
    v22 = (char *)(a2 + *(int *)(a2 + 32) + (*(_QWORD *)&v20 & 0xFFFFFFLL));
  }
  else
  {
    v22 = (char *)v33 + 1;
    v23 = (char *)v33 + 1;
    if ((_DWORD)v21 != 1)
    {
      v24 = (char *)v33 + 1;
      if ((_DWORD)v21 != 2)
      {
        if ((_DWORD)v21 != 3)
          goto LABEL_16;
        v24 = (char *)v33 + 2;
        BYTE1(v33[0]) = BYTE2(v20);
      }
      *v24 = BYTE1(v20);
      v23 = v24 + 1;
    }
    *v23 = v20;
  }
LABEL_16:
  v26 = *(_DWORD *)(a1 + 80);
  if (v26)
  {
    if ((_DWORD)v21 == 1 && v26 > 1)
    {
      v27 = 15;
      v28 = 1;
LABEL_27:
      *(_DWORD *)(a1 + 80) = v28;
      LOBYTE(v33[0]) = v27;
      if (v22 != (char *)v33 + 1)
        memcpy((char *)v33 + 1, v22, v21);
      LODWORD(v21) = v21 + 1;
      v22 = (char *)v33;
      goto LABEL_30;
    }
    if (v21 >= 2 && v26 == 1)
    {
      v27 = 14;
      v28 = 2;
      goto LABEL_27;
    }
  }
LABEL_30:
  sub_18BC17544(a1, v22, v21, a6, a7, a8, a9, a11);
  return 1;
}

unint64_t sub_18BC19AB4(unint64_t result, int a2, uint64_t a3, int a4, uint64_t a5, int a6, _DWORD *a7, int a8, char a9)
{
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int *v18;
  unint64_t v19;
  _DWORD *v20;
  unsigned int v21;
  BOOL v22;
  BOOL v23;
  BOOL v24;
  _BOOL4 v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  _BOOL4 v41;
  _BOOL4 v45;

  if (!result)
    return result;
  v9 = result;
  if (a2 >> 10 >= *(_DWORD *)(result + 44))
    return 0;
  v10 = *(unsigned int *)(result
                        + *(int *)(result + 60)
                        + 4
                        * *(unsigned __int16 *)(result
                                              + *(int *)(result + 52)
                                              + 2
                                              * ((a2 & 0xF)
                                               + 4
                                               * *(unsigned __int16 *)(result
                                                                                   + *(int *)(result + 40)
                                                                                   + 2
                                                                                   * (((a2 >> 4) & 0x3F)
                                                                                    + *(unsigned __int16 *)(result + *(int *)(result + 40) + 2 * (a2 >> 10)))))));
  if (!(_DWORD)v10)
    return 0;
  if (v10 >> 16 <= 0x1E)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    result = 0;
    v14 = v9 + *(int *)(v9 + 20);
    v15 = v9 + *(int *)(v9 + 24);
    v16 = a2 - 57344;
    v17 = a2 - 983040;
    while (1)
    {
      v18 = (unsigned int *)(v15 + 4 * v10);
      v21 = *v18;
      v20 = v18 + 1;
      v19 = v21;
      if (v21)
      {
        v22 = (v19 & 0xC0000000) == 0 && a8 == 0;
        v23 = v22 && v16 >> 8 >= 0x19;
        v24 = v23 && v17 >= 0x20000;
        v25 = !v24;
        if ((v19 & 0x20000000) == 0)
        {
          if (v25)
          {
            v11 = v19;
            result = (v13 + v12 + 2);
          }
          else
          {
            result = result;
          }
        }
      }
      v26 = (unsigned __int16 *)(v14 + 2 * v10);
      v29 = *v26;
      v27 = v26 + 1;
      v28 = v29;
      if (v12 >= a4)
      {
        if (v13 >= a6)
        {
          if (!a9 && v13 + v12 <= 19)
            return (-2 - (v13 + v12));
LABEL_83:
          v10 = v11;
          if (!(_DWORD)result)
            return result;
LABEL_84:
          if (v10 == 2147483649)
            return 1;
          *a7 = v10;
          return result;
        }
        v30 = v13++;
        v31 = a5;
      }
      else
      {
        v30 = v12++;
        v31 = a3;
      }
      v32 = *(unsigned __int16 *)(v31 + 2 * v30);
      if (v28 >= 2)
      {
        v33 = 0;
        v34 = v28;
        while (v34 > 4)
        {
          v35 = v33 + v28;
          if (v33 + v28 < 0 != __OFADD__(v33, v28))
            ++v35;
          v36 = v35 >> 1;
          if (v27[v36] > v32)
            v28 = v36;
          else
            v33 = v36;
          v34 = v28 - v33;
          if (v28 - v33 <= 1)
            goto LABEL_45;
        }
        if (v27[v33] < v32)
        {
          v37 = v33 + 1;
          if ((int)v37 < v28 && v27[v37] >= v32 || (v37 = v33 + 2, v33 + 2 < v28) && v27[v37] >= v32)
            v33 = v37;
          else
            v33 += 3;
        }
      }
      else
      {
        v33 = 0;
      }
LABEL_45:
      if (v33 >= v28 || v33 < 0 || v27[v33] != v32)
        goto LABEL_83;
      v10 = v20[v33];
      if (HIBYTE(v20[v33]))
      {
        v41 = (v10 & 0xC0000000) != 0 || a8 != 0 || v16 >> 8 < 0x19 || v17 < 0x20000;
        if ((v10 & 0x20000000) == 0 && v41)
        {
          result = (v12 + v13 + 2);
          v11 = v20[v33];
        }
        goto LABEL_83;
      }
    }
  }
  result = 0;
  v45 = (v10 & 0xC0000000) != 0
     || a8 != 0
     || (a2 - 57344) >> 8 < 0x19
     || (a2 - 983040) < 0x20000;
  if ((v10 & 0x20000000) == 0 && v45)
  {
    result = 2;
    goto LABEL_84;
  }
  return result;
}

uint64_t sub_18BC19D3C(unint64_t a1, int a2, int *a3, int a4)
{
  int v5;
  uint64_t result;
  int v7;
  unsigned int v8;
  unsigned int v9;

  v9 = 0;
  v5 = sub_18BC19AB4(a1, a2, 0, 0, 0, 0, &v9, a4, 1);
  result = 0;
  if (v5 >= 2)
  {
    v7 = v9;
    v8 = HIBYTE(v9) & 0x1F;
    if (v8 <= 3)
    {
      *a3 = v9 & 0xFFFFFF;
      if (v7 < 0)
        return v8;
      else
        return -v8;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t sub_18BC19DC0(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  unint64_t v8;
  int v9;
  UChar *v10;
  int v11;
  __int16 *v12;
  unint64_t result;
  int v14;
  int v15;
  int v16;
  int v17;
  char v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  char *v23;
  _BYTE *v24;
  _BYTE *v25;
  int v26;
  char v27;
  int v28;
  _WORD *v29;
  uint64_t v30;
  __int16 v31;
  unsigned int v32;
  _OWORD v33[2];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v32 = 0;
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 288);
  v9 = *(_DWORD *)(a1 + 208);
  v10 = (UChar *)(a1 + 212);
  v11 = *(char *)(a1 + 281);
  v12 = *(__int16 **)(a2 + 16);
  result = sub_18BC19AB4(v8, v9, a1 + 212, v11, (uint64_t)v12, (*(_QWORD *)(a2 + 24) - (_QWORD)v12) >> 1, &v32, *(char *)(a1 + 63), *(_BYTE *)(a2 + 2));
  v14 = result - 2;
  if ((int)result >= 2)
  {
    v15 = v14 - v11;
    if (v14 >= v11)
    {
      LOBYTE(v17) = 0;
      *(_QWORD *)(a2 + 16) = &v12[v15];
    }
    else
    {
      v16 = v11 - v14;
      u_memmove(v10, &v10[v14], v11 - v14);
      v17 = -v16;
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 288);
    }
    *(_BYTE *)(a1 + 281) = v17;
    *(_DWORD *)(a1 + 208) = -1;
    v18 = v32;
    v19 = (_QWORD *)(a2 + 32);
    v20 = *(_QWORD *)(a2 + 40);
    v21 = (_QWORD *)(a2 + 48);
    memset(v33, 0, sizeof(v33));
    v22 = ((unint64_t)v32 >> 24) & 0x1F;
    if (v22 > 3)
    {
      v23 = (char *)(v8 + (v32 & 0xFFFFFF) + *(int *)(v8 + 32));
    }
    else
    {
      v23 = (char *)v33 + 1;
      v24 = (char *)v33 + 1;
      if ((_DWORD)v22 != 1)
      {
        v25 = (char *)v33 + 1;
        if ((_DWORD)v22 != 2)
        {
          if ((_DWORD)v22 != 3)
            goto LABEL_17;
          v25 = (char *)v33 + 2;
          BYTE1(v33[0]) = BYTE2(v32);
        }
        *v25 = BYTE1(v32);
        v24 = v25 + 1;
      }
      *v24 = v18;
    }
LABEL_17:
    v26 = *(_DWORD *)(a1 + 80);
    if (v26)
    {
      if ((_DWORD)v22 == 1 && v26 > 1)
      {
        v27 = 15;
        v28 = 1;
LABEL_28:
        *(_DWORD *)(a1 + 80) = v28;
        LOBYTE(v33[0]) = v27;
        if (v23 != (char *)v33 + 1)
          memcpy((char *)v33 + 1, v23, v22);
        LODWORD(v22) = v22 + 1;
        v23 = (char *)v33;
        return sub_18BC17544(a1, v23, v22, v19, v20, v21, a3, a4);
      }
      if (v22 >= 2 && v26 == 1)
      {
        v27 = 14;
        v28 = 2;
        goto LABEL_28;
      }
    }
    return sub_18BC17544(a1, v23, v22, v19, v20, v21, a3, a4);
  }
  if ((result & 0x80000000) != 0)
  {
    if (-2 - (int)result > v11)
    {
      v29 = (_WORD *)(a1 + 2 * v11 + 212);
      v30 = -2 - (v11 + (uint64_t)(int)result);
      do
      {
        v31 = *v12++;
        *v29++ = v31;
        --v30;
      }
      while (v30);
    }
    *(_QWORD *)(a2 + 16) = v12;
    *(_BYTE *)(a1 + 281) = -2 - result;
  }
  else
  {
    if ((_DWORD)result == 1)
      *(_BYTE *)(a1 + 95) = 1;
    *(_DWORD *)(a1 + 84) = v9;
    *(_DWORD *)(a1 + 208) = -1;
    *(_BYTE *)(a1 + 281) = -(char)v11;
    *a4 = 10;
  }
  return result;
}

uint64_t sub_18BC1A04C(uint64_t result, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v7;
  int v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  BOOL v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE v29[38];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(result + 288);
  if (v4)
  {
    v7 = *(unsigned int *)(v4 + 44);
    v8 = a4 - 2;
    if (a4 == 2)
    {
      v9 = 3;
    }
    else
    {
      v10 = *(unsigned __int8 *)(result + 252) != 219 && a4 == 0;
      v9 = v10 ? 1 : 2;
    }
    if ((int)v7 >= 1)
    {
      v11 = 0;
      v12 = 0;
      v13 = v4 + *(int *)(v4 + 40);
      v14 = v4 + *(int *)(v4 + 60);
      v27 = *(int *)(v4 + 52);
      memset(v29, 0, sizeof(v29));
      v24 = v13;
      v25 = v7;
      while (1)
      {
        v26 = v11;
        v15 = *(unsigned __int16 *)(v13 + 2 * v11);
        if ((int)v7 < (int)v15)
          break;
        v12 = (v12 + 1024);
LABEL_54:
        LODWORD(v7) = v25;
        v11 = v26 + 1;
        v13 = v24;
        if (v26 + 1 == v25)
          return result;
      }
      v16 = 0;
      v28 = v13 + 2 * v15;
      while (!*(_WORD *)(v28 + 2 * v16))
      {
        v12 = (v12 + 16);
LABEL_51:
        if (++v16 == 64)
          goto LABEL_54;
      }
      v17 = v27 + 8 * *(unsigned __int16 *)(v28 + 2 * v16);
      while (1)
      {
        v18 = *(_DWORD *)(v14 + 4 * *(unsigned __int16 *)(v4 + v17));
        if (v18)
        {
          if (HIBYTE(v18))
          {
            if ((_DWORD)a3)
            {
              if ((v18 & 0x20000000) == 0)
                goto LABEL_28;
            }
            else if ((v18 & 0xA0000000) == 0x80000000)
            {
LABEL_28:
              if ((HIBYTE(v18) & 0x1F) >= v9)
              {
                switch(v8)
                {
                  case 0:
                    if ((v18 & 0x1F000000) == 0x3000000 && (v18 & 0xFF0000) < 0x830000)
                      goto LABEL_49;
                    break;
                  case 1:
                    if ((v18 & 0x1F000000) == 0x2000000 && (v18 & 0xFFFFFF) - 33088 < 0x6EBD)
                      goto LABEL_49;
                    break;
                  case 2:
                    v22 = (v18 & 0x1F000000) != 0x2000000 || (((_WORD)v18 + 24159) & 0xFFFEu) > 0x5D5D;
                    if (!v22 && (((_BYTE)v18 + 95) & 0xFEu) < 0x5E)
                      goto LABEL_49;
                    break;
                  case 3:
                    v23 = (v18 & 0x1F000000) != 0x2000000 || (((_WORD)v18 + 24159) & 0xFFFEu) > 0x5C5D;
                    if (!v23 && (((_BYTE)v18 + 95) & 0xFEu) <= 0x5D)
                      goto LABEL_49;
                    break;
                  default:
LABEL_49:
                    result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v12);
                    break;
                }
              }
            }
          }
          else
          {
            if (WORD1(v12))
            {
              v20 = (v12 >> 10) - 10304;
              *(_WORD *)&v29[2] = v12 & 0x3FF | 0xDC00;
              v19 = 2;
            }
            else
            {
              v19 = 1;
              LOWORD(v20) = v12;
            }
            *(_WORD *)v29 = v20;
            result = sub_18BC1A308(v4, a2, a3, v9, v12, (uint64_t)v29, v19, v18);
          }
        }
        v12 = (v12 + 1);
        v17 += 2;
        if ((v12 & 0xF) == 0)
          goto LABEL_51;
      }
    }
  }
  return result;
}

uint64_t sub_18BC1A308(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, int a8)
{
  int v9;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;

  v9 = a7;
  v14 = result;
  v15 = *(int *)(result + 20);
  v16 = *(int *)(result + 24);
  v17 = *(unsigned __int16 *)(result + v15 + 2 * a8);
  v18 = *(_DWORD *)(result + v16 + 4 * a8);
  if ((_DWORD)a3)
  {
    if ((v18 & 0x20000000) != 0)
      goto LABEL_11;
  }
  else if ((v18 & 0xA0000000) != 0x80000000)
  {
    goto LABEL_11;
  }
  if ((int)(HIBYTE(v18) & 0x1F) >= (int)a4)
  {
    if (a5 < 0x10000)
      v19 = 1;
    else
      v19 = 2;
    v20 = *a2;
    if (v19 != (_DWORD)a7)
    {
      result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))a2[3])(v20, a6, a7);
      if ((_DWORD)v17)
        goto LABEL_12;
      return result;
    }
    result = ((uint64_t (*)(uint64_t))a2[1])(v20);
  }
LABEL_11:
  if ((_DWORD)v17)
  {
LABEL_12:
    v21 = a8;
    v22 = v9;
    v23 = (v9 + 1);
    v24 = v16 + 4 * v21 + 4;
    v25 = v15 + 2 * v21 + 2;
    do
    {
      *(_WORD *)(a6 + 2 * v22) = *(_WORD *)(v14 + v25);
      v26 = *(_DWORD *)(v14 + v24);
      if (v26)
      {
        if (HIBYTE(v26))
        {
          if ((_DWORD)a3)
          {
            if ((v26 & 0x20000000) == 0)
              goto LABEL_20;
          }
          else if ((v26 & 0xA0000000) == 0x80000000)
          {
LABEL_20:
            if ((int)(HIBYTE(v26) & 0x1F) >= (int)a4)
              result = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, a6, v23);
          }
        }
        else
        {
          result = sub_18BC1A308(v14, a2, a3, a4, a5, a6, v23);
        }
      }
      v25 += 2;
      v24 += 4;
      --v17;
    }
    while (v17);
  }
  return result;
}

_BYTE *ucnv_io_stripASCIIForCompare(_BYTE *result, _BYTE *a2)
{
  int v2;
  _BYTE *v3;
  int v4;
  int v5;

  v2 = *a2;
  v3 = result;
  if (!*a2)
    goto LABEL_20;
  v4 = 0;
  v3 = result;
  do
  {
    ++a2;
    while (1)
    {
      if ((v2 & 0x80) != 0 || (v5 = byte_18BE13050[v2]) == 0)
      {
        v2 = *a2;
        goto LABEL_12;
      }
      if (v5 != 1)
        break;
      if (v4)
      {
        v4 = 1;
        goto LABEL_19;
      }
      if ((char)*a2 < 0 || byte_18BE13050[*a2] - 1 > 1)
      {
        v4 = 0;
        goto LABEL_19;
      }
      v2 = *a2;
LABEL_12:
      v4 = 0;
      ++a2;
      if (!v2)
        goto LABEL_20;
    }
    if (v5 == 2)
    {
      v4 = 1;
    }
    else
    {
      LOBYTE(v2) = byte_18BE13050[v2];
      v4 = 0;
    }
LABEL_19:
    *v3++ = v2;
    v2 = *a2;
  }
  while (*a2);
LABEL_20:
  *v3 = 0;
  return result;
}

_BYTE *ucnv_io_stripEBCDICForCompare(_BYTE *result, _BYTE *a2)
{
  int v2;
  _BYTE *v3;
  int v4;
  int v5;
  int v6;

  LOBYTE(v2) = *a2;
  v3 = result;
  if (!*a2)
    goto LABEL_20;
  v4 = 0;
  v3 = result;
  do
  {
    ++a2;
    while (1)
    {
      if ((v2 & 0x80) == 0 || (v5 = byte_18BE130D0[v2 & 0x7F]) == 0)
      {
        v2 = *a2;
        goto LABEL_12;
      }
      if (v5 != 1)
        break;
      if (v4)
      {
        v4 = 1;
        goto LABEL_19;
      }
      v6 = (char)*a2;
      if ((v6 & 0x80000000) == 0 || byte_18BE130D0[v6 & 0x7F] - 1 > 1)
      {
        v4 = 0;
        goto LABEL_19;
      }
      v2 = *a2;
LABEL_12:
      v4 = 0;
      ++a2;
      if (!v2)
        goto LABEL_20;
    }
    if (v5 == 2)
    {
      v4 = 1;
    }
    else
    {
      LOBYTE(v2) = byte_18BE130D0[v2 & 0x7F];
      v4 = 0;
    }
LABEL_19:
    *v3++ = v2;
    LOBYTE(v2) = *a2;
  }
  while (*a2);
LABEL_20:
  *v3 = 0;
  return result;
}

uint64_t ucnv_compareNames(char *a1, char *a2)
{
  int v2;
  _BOOL4 v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  _BOOL4 v10;
  int v11;
  int v12;
  uint64_t v13;

  v2 = 0;
  v3 = 0;
  while (2)
  {
    v5 = *a1++;
    v4 = v5;
    if (!v5)
    {
      v7 = 0;
      goto LABEL_21;
    }
    v6 = v2;
    while (1)
    {
      if ((v4 & 0x80) != 0 || (v7 = byte_18BE13050[v4]) == 0)
      {
        v4 = *a1;
        goto LABEL_12;
      }
      if (v7 != 1)
        break;
      if (v6)
      {
        v2 = 1;
        goto LABEL_20;
      }
      if (*a1 < 0 || byte_18BE13050[*a1] - 1 > 1)
      {
        v2 = 0;
LABEL_20:
        v7 = v4;
        goto LABEL_21;
      }
      v4 = *a1;
LABEL_12:
      v6 = 0;
      v7 = 0;
      v2 = 0;
      ++a1;
      if (!v4)
        goto LABEL_21;
    }
    if (v7 == 2)
    {
      v7 = v4;
      v2 = 1;
    }
    else
    {
      v2 = 0;
    }
LABEL_21:
    v9 = *a2++;
    v8 = v9;
    if (!v9)
    {
      v12 = 0;
      goto LABEL_41;
    }
    v10 = v3;
    while (2)
    {
      if ((v8 & 0x80) != 0 || (v11 = byte_18BE13050[v8]) == 0)
      {
        v8 = *a2;
LABEL_31:
        v10 = 0;
        v12 = 0;
        v3 = 0;
        ++a2;
        if (!v8)
          goto LABEL_41;
        continue;
      }
      break;
    }
    if (v11 == 1)
    {
      if (v10)
      {
        v3 = 1;
        goto LABEL_40;
      }
      if (*a2 < 0 || byte_18BE13050[*a2] - 1 > 1)
      {
        v3 = 0;
LABEL_40:
        v12 = v8;
        goto LABEL_41;
      }
      v8 = *a2;
      goto LABEL_31;
    }
    if (v11 == 2)
      v12 = v8;
    else
      v12 = byte_18BE13050[v8];
    v3 = v11 == 2;
LABEL_41:
    if (v12 | v7)
    {
      v13 = (v7 - v12);
      if ((_DWORD)v13)
        return v13;
      continue;
    }
    return 0;
  }
}

uint64_t ucnv_io_getConverterName(char *a1, _BYTE *a2, UErrorCode *a3)
{
  char v4;
  char i;
  char v6;
  uint64_t v7;
  int v8;
  char *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  uint64_t result;
  char v25;
  _OWORD v26[4];
  uint64_t v27;

  v4 = 0;
  v27 = *MEMORY[0x1E0C80C00];
  for (i = 1; ; i = 0)
  {
    v6 = i;
    if ((v4 & 1) != 0)
    {
      if (*a1 != 120 || a1[1] != 45)
        return 0;
      a1 += 2;
    }
    if (!sub_18BC1A93C(a3))
      return 0;
    if (!a1)
    {
      result = 0;
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
      return result;
    }
    if (!*a1)
      return 0;
    v7 = xmmword_1EE009498;
    v8 = *(unsigned __int16 *)xmmword_1EE009498;
    memset(v26, 0, 60);
    v9 = a1;
    v25 = v6;
    if (!v8)
      break;
    if (strlen(a1) < 0x3C)
    {
      v9 = (char *)v26;
      ucnv_io_stripASCIIForCompare(v26, a1);
      break;
    }
    *a3 = U_BUFFER_OVERFLOW_ERROR;
LABEL_29:
    v4 = 1;
    if ((v25 & 1) == 0)
      return 0;
  }
  v10 = 0;
  v11 = DWORD1(xmmword_1EE0094B8);
  v12 = DWORD1(xmmword_1EE0094B8) >> 1;
  v13 = xmmword_1EE009478;
  v15 = *((_QWORD *)&xmmword_1EE009498 + 1);
  v14 = qword_1EE0094A8;
  while (1)
  {
    v16 = *(unsigned __int16 *)(v13 + 2 * v12);
    v17 = v8 ? strcmp(v9, (const char *)(v14 + 2 * v16)) : ucnv_compareNames(v9, (char *)(v15 + 2 * v16));
    v18 = v12;
    if ((v17 & 0x80000000) == 0)
    {
      v10 = v12;
      v18 = v11;
      if (!v17)
        break;
    }
    v19 = (_DWORD)v12 == (v18 + v10) >> 1;
    v12 = (v18 + v10) >> 1;
    v11 = v18;
    if (v19)
      goto LABEL_29;
  }
  v20 = *((_QWORD *)&xmmword_1EE009478 + 1);
  v21 = *(__int16 *)(*((_QWORD *)&xmmword_1EE009478 + 1) + 2 * v12);
  if (v21 < 0)
    *a3 = U_AMBIGUOUS_ALIAS_WARNING;
  if (a2)
  {
    v21 = ((unsigned __int16)v21 >> 14) & 1;
    if (!*(_BYTE *)(v7 + 2))
      LOBYTE(v21) = 1;
    *a2 = v21;
    LOWORD(v21) = *(_WORD *)(v20 + 2 * v12);
  }
  if (dword_1EE0094B0 <= (v21 & 0xFFFu))
    goto LABEL_29;
  return v15 + 2 * *(unsigned __int16 *)(xmmword_1EE009468 + 2 * (v21 & 0xFFF));
}

BOOL sub_18BC1A93C(UErrorCode *a1)
{
  unsigned int v2;
  _QWORD *v3;
  _OWORD *v4;
  int *Memory;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  char *v16;
  unsigned int v17;
  unsigned int v18;
  char *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned __int16 *v25;
  __int16 v26;
  unsigned int v27;
  uint64_t v28;

  if (*(int *)a1 <= 0)
  {
    v2 = atomic_load(&dword_1EE0094D8);
    if (v2 == 2 || !icu::umtx_initImplPreInit(&dword_1EE0094D8))
    {
      if (dword_1EE0094DC >= 1)
        *a1 = dword_1EE0094DC;
    }
    else
    {
      sub_18BC0ECC4(0x17u, (uint64_t)sub_18BC1C004);
      v3 = udata_openChoice(0, "icu", "cnvalias", (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18BC1C05C, 0, a1);
      if (*(int *)a1 <= 0)
      {
        v4 = v3;
        Memory = (int *)udata_getMemory((uint64_t)v3);
        v6 = *Memory;
        if (*Memory > 7)
        {
          qword_1EE0094E0 = (uint64_t)v4;
          v7 = Memory[1];
          dword_1EE0094B0 = v7;
          v8 = Memory[2];
          dword_1EE0094B4 = v8;
          v9 = Memory[3];
          LODWORD(xmmword_1EE0094B8) = v9;
          v10 = Memory[4];
          DWORD1(xmmword_1EE0094B8) = v10;
          v11 = Memory[5];
          DWORD2(xmmword_1EE0094B8) = v11;
          v12 = Memory[6];
          HIDWORD(xmmword_1EE0094B8) = v12;
          v13 = Memory[7];
          dword_1EE0094C8 = v13;
          v14 = Memory[8];
          dword_1EE0094CC = v14;
          if (v6 != 8)
            dword_1EE0094D0 = Memory[9];
          v15 = 2 * v6 + 2;
          v16 = (char *)Memory + 2 * v15;
          v17 = v7 + v15;
          *(_QWORD *)&xmmword_1EE009468 = v16;
          *((_QWORD *)&xmmword_1EE009468 + 1) = (char *)Memory + 2 * v17;
          v18 = v8 + v17;
          v19 = (char *)Memory + 2 * v18;
          v20 = v9 + v18;
          *(_QWORD *)&xmmword_1EE009478 = v19;
          *((_QWORD *)&xmmword_1EE009478 + 1) = (char *)Memory + 2 * v20;
          v21 = v10 + v20;
          v22 = (uint64_t)Memory + 2 * v21;
          v23 = v11 + v21;
          qword_1EE009488 = v22;
          qword_1EE009490 = (uint64_t)Memory + 2 * v23;
          v24 = v12 + v23;
          if (v13 && (v25 = (unsigned __int16 *)Memory + v24, v26 = *v25, *v25 < 2u))
          {
            v27 = v13 + v24;
            v28 = (uint64_t)Memory + 2 * v27;
            *(_QWORD *)&xmmword_1EE009498 = v25;
            *((_QWORD *)&xmmword_1EE009498 + 1) = v28;
            if (v26)
              v28 = (uint64_t)Memory + 2 * v14 + 2 * v27;
          }
          else
          {
            v28 = (uint64_t)Memory + 2 * v13 + 2 * v24;
            *(_QWORD *)&xmmword_1EE009498 = &unk_18BE1315E;
            *((_QWORD *)&xmmword_1EE009498 + 1) = v28;
          }
          qword_1EE0094A8 = v28;
        }
        else
        {
          *a1 = U_INVALID_FORMAT_ERROR;
          udata_close(v4);
        }
      }
      dword_1EE0094DC = *a1;
      icu::umtx_initImplPostInit(&dword_1EE0094D8);
    }
  }
  return *a1 < U_ILLEGAL_ARGUMENT_ERROR;
}

_QWORD *ucnv_openStandardNames(char *a1, unsigned __int8 *a2, UErrorCode *a3)
{
  unsigned int v6;
  unsigned int v7;
  _QWORD *v8;
  _QWORD *v9;
  _DWORD *v10;
  int v11;

  if (!sub_18BC1A93C(a3))
    return 0;
  if (!a1)
  {
    v9 = 0;
    v11 = 1;
LABEL_9:
    *a3 = v11;
    return v9;
  }
  if (!*a1)
    return 0;
  v6 = sub_18BC1AC28(a1, a2, (int *)a3);
  if (v6 >= HIDWORD(xmmword_1EE0094B8))
    return 0;
  v7 = v6;
  v8 = uprv_malloc(0x38uLL);
  v9 = v8;
  if (!v8)
  {
    v11 = 7;
    goto LABEL_9;
  }
  *(_OWORD *)v8 = xmmword_1E224DA88;
  *((_OWORD *)v8 + 1) = *(_OWORD *)&off_1E224DA98;
  *((_OWORD *)v8 + 2) = xmmword_1E224DAA8;
  v8[6] = sub_18BC1C20C;
  v10 = uprv_malloc(8uLL);
  if (!v10)
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
    uprv_free(v9);
    return 0;
  }
  *v10 = v7;
  v10[1] = 0;
  v9[1] = v10;
  return v9;
}

uint64_t sub_18BC1AC28(char *a1, unsigned __int8 *a2, int *a3)
{
  unsigned int v5;
  int v6;
  char *v7;
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t result;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int16 *v27;
  unsigned __int16 *v28;
  unint64_t v29;
  unsigned int v30;
  uint64_t v31;
  BOOL v32;
  unsigned int v33;
  unsigned int v34;
  int *v35;
  int v36;
  _OWORD v37[4];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v5 = sub_18BC1C0C0(a2);
  v6 = *(unsigned __int16 *)xmmword_1EE009498;
  memset(v37, 0, 60);
  v7 = a1;
  if (v6)
  {
    if (strlen(a1) >= 0x3C)
    {
      v8 = 15;
      v9 = -1;
LABEL_17:
      *a3 = v8;
      goto LABEL_18;
    }
    v7 = (char *)v37;
    ucnv_io_stripASCIIForCompare(v37, a1);
  }
  v35 = a3;
  v10 = 0;
  v11 = DWORD1(xmmword_1EE0094B8);
  v12 = DWORD1(xmmword_1EE0094B8) >> 1;
  v13 = xmmword_1EE009478;
  v15 = *((_QWORD *)&xmmword_1EE009498 + 1);
  v14 = qword_1EE0094A8;
  while (1)
  {
    v16 = *(unsigned __int16 *)(v13 + 2 * v12);
    v17 = v6 ? strcmp(v7, (const char *)(v14 + 2 * v16)) : ucnv_compareNames(v7, (char *)(v15 + 2 * v16));
    v18 = v12;
    if ((v17 & 0x80000000) == 0)
    {
      v10 = v12;
      v18 = v11;
      if (!v17)
        break;
    }
    v19 = (_DWORD)v12 == (v18 + v10) >> 1;
    v12 = (v18 + v10) >> 1;
    v11 = v18;
    if (v19)
    {
      v8 = 0;
      v9 = -1;
      goto LABEL_18;
    }
  }
  v9 = *(_WORD *)(*((_QWORD *)&xmmword_1EE009478 + 1) + 2 * v12) & 0xFFF;
  if ((*(_WORD *)(*((_QWORD *)&xmmword_1EE009478 + 1) + 2 * v12) & 0x8000) != 0)
  {
    v8 = -122;
    a3 = v35;
    goto LABEL_17;
  }
  v8 = 0;
LABEL_18:
  if (v5 >= dword_1EE0094B4 - 1 || v9 >= dword_1EE0094B0)
    return 0xFFFFFFFFLL;
  v20 = qword_1EE009488;
  v36 = dword_1EE0094B0 * v5;
  v21 = dword_1EE0094B0 * v5 + v9;
  result = *(unsigned __int16 *)(qword_1EE009488 + 2 * v21);
  if (!*(_WORD *)(qword_1EE009488 + 2 * v21) || !*(_WORD *)(qword_1EE009490 + 2 * result + 2))
  {
    if (v8 == -122 && (v23 = DWORD2(xmmword_1EE0094B8), DWORD2(xmmword_1EE0094B8)))
    {
      v34 = dword_1EE0094B0;
      v24 = 0;
      v25 = qword_1EE009490;
      v26 = *((_QWORD *)&xmmword_1EE009498 + 1);
      while (1)
      {
        if (*(_WORD *)(v20 + 2 * v24))
        {
          v27 = (unsigned __int16 *)(v25 + 2 * *(unsigned __int16 *)(v20 + 2 * v24));
          v30 = *v27;
          v28 = v27 + 1;
          v29 = v30;
          if (v30)
          {
            v31 = 0;
            v32 = 1;
            do
            {
              if (v28[v31] && !ucnv_compareNames(a1, (char *)(v26 + 2 * v28[v31])))
                break;
              v32 = ++v31 < v29;
            }
            while (v29 != v31);
            if (v32)
            {
              v33 = v24 % v34 + v36;
              result = *(unsigned __int16 *)(v20 + 2 * v33);
              if (*(_WORD *)(v20 + 2 * v33))
              {
                if (*(_WORD *)(v25 + 2 * result + 2))
                  break;
              }
            }
          }
        }
        if (++v24 == v23)
          return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ucnv_getStandard(unsigned int a1, UErrorCode *a2)
{
  uint64_t result;

  if (!sub_18BC1A93C(a2))
    return 0;
  if (dword_1EE0094B4 - 1 > a1)
    return *((_QWORD *)&xmmword_1EE009498 + 1)
         + 2 * *(unsigned __int16 *)(*((_QWORD *)&xmmword_1EE009468 + 1) + 2 * a1);
  result = 0;
  *a2 = U_INDEX_OUTOFBOUNDS_ERROR;
  return result;
}

uint64_t ucnv_getStandardName(char *a1, unsigned __int8 *a2, UErrorCode *a3)
{
  unsigned int v6;
  uint64_t result;

  if (!sub_18BC1A93C(a3))
    return 0;
  if (a1)
  {
    if (*a1)
    {
      v6 = sub_18BC1AC28(a1, a2, (int *)a3);
      if (v6)
      {
        if (v6 < HIDWORD(xmmword_1EE0094B8) && *(_WORD *)(qword_1EE009490 + 2 * v6 + 2))
          return *((_QWORD *)&xmmword_1EE009498 + 1) + 2 * *(unsigned __int16 *)(qword_1EE009490 + 2 * v6 + 2);
      }
    }
    return 0;
  }
  result = 0;
  *a3 = U_ILLEGAL_ARGUMENT_ERROR;
  return result;
}

uint64_t ucnv_countAliases(char *a1, UErrorCode *a2)
{
  uint64_t result;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  BOOL v15;
  __int16 v16;
  unsigned int v17;
  uint64_t v18;
  _OWORD v19[4];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  result = sub_18BC1A93C(a2);
  if ((_DWORD)result)
  {
    if (!a1)
    {
      result = 0;
      *a2 = U_ILLEGAL_ARGUMENT_ERROR;
      return result;
    }
    if (!*a1)
      return 0;
    v5 = *(unsigned __int16 *)xmmword_1EE009498;
    memset(v19, 0, 60);
    if (v5)
    {
      if (strlen(a1) >= 0x3C)
      {
        *a2 = U_BUFFER_OVERFLOW_ERROR;
        return 0;
      }
      ucnv_io_stripASCIIForCompare(v19, a1);
      a1 = (char *)v19;
    }
    v6 = 0;
    v7 = DWORD1(xmmword_1EE0094B8);
    v8 = DWORD1(xmmword_1EE0094B8) >> 1;
    v9 = xmmword_1EE009478;
    v11 = *((_QWORD *)&xmmword_1EE009498 + 1);
    v10 = qword_1EE0094A8;
    while (1)
    {
      v12 = *(unsigned __int16 *)(v9 + 2 * v8);
      v13 = v5 ? strcmp(a1, (const char *)(v10 + 2 * v12)) : ucnv_compareNames(a1, (char *)(v11 + 2 * v12));
      v14 = v8;
      if ((v13 & 0x80000000) == 0)
      {
        v6 = v8;
        v14 = v7;
        if (!v13)
          break;
      }
      v15 = (_DWORD)v8 == (v14 + v6) >> 1;
      v8 = (v14 + v6) >> 1;
      v7 = v14;
      if (v15)
        return 0;
    }
    v16 = *(_WORD *)(*((_QWORD *)&xmmword_1EE009478 + 1) + 2 * v8);
    if (v16 < 0)
      *a2 = U_AMBIGUOUS_ALIAS_WARNING;
    v17 = v16 & 0xFFF;
    if (dword_1EE0094B0 > v17)
    {
      v18 = *(unsigned __int16 *)(qword_1EE009488 + 2 * (v17 + (dword_1EE0094B4 - 1) * dword_1EE0094B0));
      if (v18)
        return *(unsigned __int16 *)(qword_1EE009490 + 2 * v18);
    }
    return 0;
  }
  return result;
}

uint64_t ucnv_getAlias(char *a1, unsigned int a2, UErrorCode *a3)
{
  int v6;
  uint64_t result;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;
  unsigned int v20;
  uint64_t v21;
  unsigned __int16 *v22;
  _OWORD v23[4];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!sub_18BC1A93C(a3))
    return 0;
  if (!a1)
  {
    result = 0;
    v8 = 1;
    goto LABEL_8;
  }
  if (*a1)
  {
    v6 = *(unsigned __int16 *)xmmword_1EE009498;
    memset(v23, 0, 60);
    if (v6)
    {
      if (strlen(a1) >= 0x3C)
      {
        *a3 = U_BUFFER_OVERFLOW_ERROR;
        return 0;
      }
      ucnv_io_stripASCIIForCompare(v23, a1);
      a1 = (char *)v23;
    }
    v9 = 0;
    v10 = DWORD1(xmmword_1EE0094B8);
    v11 = DWORD1(xmmword_1EE0094B8) >> 1;
    v12 = xmmword_1EE009478;
    v13 = *((_QWORD *)&xmmword_1EE009498 + 1);
    v14 = qword_1EE0094A8;
    while (1)
    {
      v15 = *(unsigned __int16 *)(v12 + 2 * v11);
      v16 = v6 ? strcmp(a1, (const char *)(v14 + 2 * v15)) : ucnv_compareNames(a1, (char *)(v13 + 2 * v15));
      v17 = v11;
      if ((v16 & 0x80000000) == 0)
      {
        v9 = v11;
        v17 = v10;
        if (!v16)
          break;
      }
      v18 = (_DWORD)v11 == (v17 + v9) >> 1;
      v11 = (v17 + v9) >> 1;
      v10 = v17;
      if (v18)
        return 0;
    }
    v19 = *(_WORD *)(*((_QWORD *)&xmmword_1EE009478 + 1) + 2 * v11);
    if (v19 < 0)
      *a3 = U_AMBIGUOUS_ALIAS_WARNING;
    v20 = v19 & 0xFFF;
    if (dword_1EE0094B0 <= v20)
      return 0;
    v21 = *(unsigned __int16 *)(qword_1EE009488 + 2 * (v20 + (dword_1EE0094B4 - 1) * dword_1EE0094B0));
    if (!v21)
      return 0;
    v22 = (unsigned __int16 *)(qword_1EE009490 + 2 * v21);
    if (*v22 > a2)
      return v13 + 2 * v22[a2 + 1];
    result = 0;
    v8 = 8;
LABEL_8:
    *a3 = v8;
    return result;
  }
  return 0;
}

unint64_t ucnv_getAliases(char *a1, _QWORD *a2, UErrorCode *a3)
{
  unint64_t result;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  __int16 v18;
  unsigned int v19;
  uint64_t v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  _OWORD v26[4];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  result = sub_18BC1A93C(a3);
  if ((_DWORD)result)
  {
    if (!a1)
    {
      v8 = 1;
      goto LABEL_8;
    }
    if (!*a1)
      return result;
    v7 = *(unsigned __int16 *)xmmword_1EE009498;
    memset(v26, 0, 60);
    if (v7)
    {
      result = strlen(a1);
      if (result >= 0x3C)
      {
        v8 = 15;
LABEL_8:
        *a3 = v8;
        return result;
      }
      ucnv_io_stripASCIIForCompare(v26, a1);
      a1 = (char *)v26;
    }
    v9 = 0;
    v10 = DWORD1(xmmword_1EE0094B8);
    v11 = DWORD1(xmmword_1EE0094B8) >> 1;
    v12 = xmmword_1EE009478;
    v13 = *((_QWORD *)&xmmword_1EE009498 + 1);
    v14 = qword_1EE0094A8;
    while (1)
    {
      v15 = *(unsigned __int16 *)(v12 + 2 * v11);
      result = v7 ? strcmp(a1, (const char *)(v14 + 2 * v15)) : ucnv_compareNames(a1, (char *)(v13 + 2 * v15));
      v16 = v11;
      if ((result & 0x80000000) == 0)
      {
        v9 = v11;
        v16 = v10;
        if (!(_DWORD)result)
          break;
      }
      v17 = (_DWORD)v11 == (v16 + v9) >> 1;
      v11 = (v16 + v9) >> 1;
      v10 = v16;
      if (v17)
        return result;
    }
    v18 = *(_WORD *)(*((_QWORD *)&xmmword_1EE009478 + 1) + 2 * v11);
    if (v18 < 0)
      *a3 = U_AMBIGUOUS_ALIAS_WARNING;
    v19 = v18 & 0xFFF;
    if (dword_1EE0094B0 > v19)
    {
      v20 = *(unsigned __int16 *)(qword_1EE009488 + 2 * (v19 + (dword_1EE0094B4 - 1) * dword_1EE0094B0));
      if (v20)
      {
        v21 = (unsigned __int16 *)(qword_1EE009490 + 2 * v20);
        v24 = *v21;
        v22 = v21 + 1;
        v23 = v24;
        if (v24)
        {
          do
          {
            v25 = *v22++;
            *a2++ = v13 + 2 * v25;
            --v23;
          }
          while (v23);
        }
      }
    }
  }
  return result;
}

uint64_t ucnv_countStandards()
{
  _BOOL4 v0;
  unsigned __int16 v1;
  int v3;

  v3 = 0;
  v0 = sub_18BC1A93C((UErrorCode *)&v3);
  v1 = dword_1EE0094B4 - 1;
  if (!v0)
    return 0;
  return v1;
}

uint64_t ucnv_getCanonicalName(char *a1, unsigned __int8 *a2, UErrorCode *a3)
{
  unsigned int v6;
  int v7;
  char *v8;
  int v9;
  unsigned int v10;
  uint64_t result;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  BOOL v21;
  __int16 v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  unint64_t v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  unint64_t v39;
  unsigned int v40;
  uint64_t v41;
  BOOL v42;
  uint64_t v43;
  int v44;
  unsigned int v45;
  int v46;
  unsigned int v47;
  _OWORD v48[4];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (!sub_18BC1A93C(a3))
    return 0;
  if (!a1)
  {
    result = 0;
    *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    return result;
  }
  if (!*a1)
    return 0;
  v6 = sub_18BC1C0C0(a2);
  v7 = *(unsigned __int16 *)xmmword_1EE009498;
  memset(v48, 0, 60);
  v8 = a1;
  if (v7)
  {
    if (strlen(a1) >= 0x3C)
    {
      v9 = 15;
      v10 = -1;
      goto LABEL_22;
    }
    v8 = (char *)v48;
    ucnv_io_stripASCIIForCompare(v48, a1);
  }
  v45 = v6;
  v12 = 0;
  v13 = DWORD1(xmmword_1EE0094B8);
  v14 = DWORD1(xmmword_1EE0094B8) >> 1;
  v15 = xmmword_1EE009478;
  v17 = *((_QWORD *)&xmmword_1EE009498 + 1);
  v16 = qword_1EE0094A8;
  while (1)
  {
    v18 = *(unsigned __int16 *)(v15 + 2 * v14);
    v19 = v7 ? strcmp(v8, (const char *)(v16 + 2 * v18)) : ucnv_compareNames(v8, (char *)(v17 + 2 * v18));
    v20 = v14;
    if ((v19 & 0x80000000) == 0)
    {
      v12 = v14;
      v20 = v13;
      if (!v19)
        break;
    }
    v21 = (_DWORD)v14 == (v20 + v12) >> 1;
    v14 = (v20 + v12) >> 1;
    v13 = v20;
    if (v21)
    {
      v9 = 0;
      v10 = -1;
LABEL_20:
      v6 = v45;
      goto LABEL_23;
    }
  }
  v22 = *(_WORD *)(*((_QWORD *)&xmmword_1EE009478 + 1) + 2 * v14);
  v10 = v22 & 0xFFF;
  if ((v22 & 0x8000) == 0)
  {
    v9 = 0;
    goto LABEL_20;
  }
  v9 = -122;
  v6 = v45;
LABEL_22:
  *a3 = v9;
LABEL_23:
  if (v6 >= dword_1EE0094B4 - 1)
    return 0;
  v23 = dword_1EE0094B0;
  if (v10 >= dword_1EE0094B0)
    return 0;
  v24 = qword_1EE009488;
  v25 = dword_1EE0094B0 * v6;
  if (!*(_WORD *)(qword_1EE009488 + 2 * (v25 + v10)))
    goto LABEL_50;
  v26 = (unsigned __int16 *)(qword_1EE009490
                           + 2 * *(unsigned __int16 *)(qword_1EE009488 + 2 * (v25 + v10)));
  v29 = *v26;
  v27 = v26 + 1;
  v28 = v29;
  if (!v29)
    goto LABEL_50;
  v43 = dword_1EE0094B0 * v6;
  v46 = dword_1EE0094B0;
  v30 = v6;
  v31 = 0;
  v32 = *((_QWORD *)&xmmword_1EE009498 + 1);
  v33 = 1;
  do
  {
    if (v27[v31] && !ucnv_compareNames(a1, (char *)(v32 + 2 * v27[v31])))
      break;
    v33 = ++v31 < v28;
  }
  while (v28 != v31);
  v6 = v30;
  v23 = v46;
  v25 = v43;
  if (!v33)
  {
LABEL_50:
    if (v9 != -122)
      return 0;
    v34 = v23 + v23 * v6;
    if (v25 >= v34)
      return 0;
    v47 = v23;
    v35 = qword_1EE009490;
    v32 = *((_QWORD *)&xmmword_1EE009498 + 1);
    v44 = v25;
    v36 = v25;
    while (1)
    {
      if (*(_WORD *)(v24 + 2 * v36))
      {
        v37 = (unsigned __int16 *)(v35 + 2 * *(unsigned __int16 *)(v24 + 2 * v36));
        v40 = *v37;
        v38 = v37 + 1;
        v39 = v40;
        if (v40)
        {
          v41 = 0;
          v42 = 1;
          do
          {
            if (v38[v41] && !ucnv_compareNames(a1, (char *)(v32 + 2 * v38[v41])))
              break;
            v42 = ++v41 < v39;
          }
          while (v39 != v41);
          if (v42)
            break;
        }
      }
      result = 0;
      if (++v36 == v34)
        return result;
    }
    v10 = v36 - v44;
    v23 = v47;
  }
  if (v10 < v23)
    return v32 + 2 * *(unsigned __int16 *)(xmmword_1EE009468 + 2 * v10);
  return 0;
}

_QWORD *ucnv_openAllNames(UErrorCode *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _WORD *v4;

  if (!sub_18BC1A93C(a1))
    return 0;
  v2 = uprv_malloc(0x38uLL);
  v3 = v2;
  if (!v2)
  {
    *a1 = U_MEMORY_ALLOCATION_ERROR;
    return v3;
  }
  *(_OWORD *)v2 = xmmword_1E224DAC0;
  *((_OWORD *)v2 + 1) = *(_OWORD *)&off_1E224DAD0;
  *((_OWORD *)v2 + 2) = xmmword_1E224DAE0;
  v2[6] = sub_18BC1C29C;
  v4 = uprv_malloc(2uLL);
  if (!v4)
  {
    *a1 = U_MEMORY_ALLOCATION_ERROR;
    uprv_free(v3);
    return 0;
  }
  *v4 = 0;
  v3[1] = v4;
  return v3;
}

uint64_t ucnv_io_countKnownConverters(UErrorCode *a1)
{
  _BOOL4 v1;
  unsigned __int16 v2;

  v1 = sub_18BC1A93C(a1);
  v2 = dword_1EE0094B0;
  if (!v1)
    return 0;
  return v2;
}

uint64_t ucnv_swapAliases(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  __int128 *v34;
  char *v35;
  int v36;
  int v37;
  _BYTE *v38;
  int v39;
  int v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  _BYTE *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _BYTE *(*v59)(_BYTE *, _BYTE *);
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _WORD *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  size_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t __dst;
  char *__dsta;
  char *v86;
  void *v87;
  void *__src;
  _BYTE *(*v89)(_BYTE *, _BYTE *);
  _BYTE v90[1000];
  _BYTE v91[2000];
  __int128 v92;
  __int128 v93;
  uint64_t v94;
  _DWORD v95[3];
  __int128 v96;
  __int128 v97;
  int v98;
  uint64_t v99;

  v10 = a3;
  v99 = *MEMORY[0x1E0C80C00];
  v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0)
    return 0;
  v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x7600000043
    || *(_BYTE *)(a2 + 14) != 65
    || *(_BYTE *)(a2 + 15) != 108
    || *(_BYTE *)(a2 + 16) != 3)
  {
    udata_printError(a1, (uint64_t)"ucnv_swapAliases(): data format %02x.%02x.%02x.%02x (format version %02x) is not an alias table\n", v14, v15, v16, v17, v18, v19, v21);
    result = 0;
    v32 = 16;
    goto LABEL_13;
  }
  v22 = v13;
  if ((v10 & 0x80000000) == 0)
  {
    v23 = (v10 - v13);
    if ((int)v23 <= 35)
    {
LABEL_23:
      udata_printError(a1, (uint64_t)"ucnv_swapAliases(): too few bytes (%d after header) for an alias table\n", v14, v15, v16, v17, v18, v19, v23);
      result = 0;
      v32 = 8;
      goto LABEL_13;
    }
  }
  v98 = 0;
  v97 = 0u;
  v96 = 0u;
  v24 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*(unsigned int *)(a2 + v13));
  v31 = v24;
  v95[0] = v24;
  if ((v24 - 10) < 0xFFFFFFFE)
  {
    udata_printError(a1, (uint64_t)"ucnv_swapAliases(): table of contents contains unsupported number of sections (%u sections)\n", v25, v26, v27, v28, v29, v30, v24);
    result = 0;
    v32 = 3;
LABEL_13:
    *a5 = v32;
    return result;
  }
  v83 = a2 + v22;
  v33 = v22 + 4;
  v34 = &v96;
  __dst = (v24 + 1);
  v35 = (char *)(__dst - 1);
  do
  {
    *(_DWORD *)v34 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*(unsigned int *)(a2 + v33));
    v34 = (__int128 *)((char *)v34 + 4);
    v33 += 4;
    --v35;
  }
  while (v35);
  v94 = 0;
  v92 = 0u;
  v93 = 0u;
  v36 = 2 * __dst;
  DWORD1(v92) = 2 * __dst;
  if (v31 >= 2)
  {
    v38 = 0;
    do
    {
      v36 += *((_DWORD *)&v96 + (_QWORD)v38);
      *((_DWORD *)&v92 + (_QWORD)v38++ + 2) = v36;
    }
    while ((_BYTE *)(__dst - 2) != v38);
    v36 = *((_DWORD *)&v92 + (_QWORD)v38 + 1);
    v37 = (_DWORD)v38 + 1;
  }
  else
  {
    v37 = 1;
  }
  v39 = v95[v37] + v36;
  if (v10 < 0)
  {
    v40 = 2 * v39;
  }
  else
  {
    v23 = (v10 - v22);
    if ((int)v23 < 2 * v39)
      goto LABEL_23;
    v41 = (char *)a4 + v22;
    (*(void (**)(uint64_t, uint64_t, _QWORD, char *, int *))(a1 + 56))(a1, v83, (4 * __dst), v41, a5);
    v42 = v94;
    (*(void (**)(uint64_t, uint64_t, _QWORD, char *, int *))(a1 + 72))(a1, v83 + 2 * v94, (2 * (v98 + HIDWORD(v97))), &v41[2 * v94], a5);
    if (*a5 >= 1)
    {
      udata_printError(a1, (uint64_t)"ucnv_swapAliases().swapInvChars(charset names) failed\n", v43, v44, v45, v46, v47, v48, v77);
      return 0;
    }
    v40 = 2 * v39;
    v49 = *(unsigned __int8 *)(a1 + 3);
    if (*(unsigned __int8 *)(a1 + 1) == v49)
    {
      (*(void (**)(uint64_t, uint64_t, _QWORD, char *, int *))(a1 + 48))(a1, v83 + 2 * DWORD1(v92), (2 * (v42 - DWORD1(v92))), &v41[2 * DWORD1(v92)], a5);
    }
    else
    {
      v87 = 0;
      __src = 0;
      v89 = 0;
      v50 = DWORD2(v96);
      v86 = &v41[2 * v42];
      if (DWORD2(v96) > 0x1F4)
      {
        v52 = (char *)uprv_malloc((2 * DWORD2(v96)) + 4 * DWORD2(v96));
        v87 = v52;
        if (!v52)
        {
          udata_printError(a1, (uint64_t)"ucnv_swapAliases(): unable to allocate memory for sorting tables (max length: %u)\n", v53, v54, v55, v56, v57, v58, v50);
          result = 0;
          v32 = 7;
          goto LABEL_13;
        }
        v79 = v42;
        v80 = v40;
        v51 = v52;
        __src = &v52[4 * v50];
        v49 = *(unsigned __int8 *)(a1 + 3);
      }
      else
      {
        v79 = v42;
        v80 = v40;
        v51 = v91;
        v87 = v91;
        __src = v90;
      }
      v81 = (char *)a4 + v22;
      if (v49)
        v59 = ucnv_io_stripEBCDICForCompare;
      else
        v59 = ucnv_io_stripASCIIForCompare;
      bzero(v91, 0x7D0uLL);
      bzero(v90, 0x3E8uLL);
      v89 = v59;
      v78 = v93;
      v82 = HIDWORD(v92);
      v60 = v83 + 2 * HIDWORD(v92);
      v61 = (uint64_t)v51;
      if ((_DWORD)v50)
      {
        v62 = 0;
        v63 = v51 + 2;
        do
        {
          *(v63 - 1) = (*(uint64_t (**)(_QWORD))(a1 + 8))(*(unsigned __int16 *)(v60 + 2 * v62));
          *v63 = v62;
          v63 += 2;
          ++v62;
        }
        while (v50 != v62);
      }
      uprv_sortArray(v61, v50, 4, (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_18BC1BF50, (uint64_t)&v86, 0, a5);
      if (*a5 <= 0)
      {
        __dsta = &v81[2 * v78];
        v70 = v83 + 2 * v78;
        if ((unsigned __int16 *)a2 == a4)
        {
          v73 = (char *)__src;
          if ((_DWORD)v50)
          {
            v74 = 0;
            v75 = 2 * v50;
            do
            {
              (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v60 + 2 * *((unsigned __int16 *)v87 + v74 + 1), 2, &v73[v74], a5);
              v74 += 2;
            }
            while (v75 != v74);
            memcpy(&v81[2 * v82], v73, 2 * v50);
            v76 = 0;
            do
            {
              (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v70 + 2 * *((unsigned __int16 *)v87 + v76 + 1), 2, &v73[v76], a5);
              v76 += 2;
            }
            while (v75 != v76);
          }
          else
          {
            memcpy(&v81[2 * v82], __src, 2 * v50);
            v75 = 0;
          }
          memcpy(__dsta, v73, v75);
        }
        else if ((_DWORD)v50)
        {
          v71 = 0;
          do
          {
            v72 = *((unsigned __int16 *)v87 + v71 + 1);
            (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v60 + 2 * v72, 2, &v81[2 * v82 + v71], a5);
            (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v70 + 2 * v72, 2, &__dsta[v71], a5);
            v71 += 2;
          }
          while (2 * v50 != v71);
        }
      }
      if (v87 != v91)
        uprv_free(v87);
      if (*a5 >= 1)
      {
        udata_printError(a1, (uint64_t)"ucnv_swapAliases().uprv_sortArray(%u items) failed\n", v64, v65, v66, v67, v68, v69, v50);
        return 0;
      }
      (*(void (**)(uint64_t, uint64_t, _QWORD, char *, int *))(a1 + 48))(a1, v83 + 2 * DWORD1(v92), (2 * (v82 - DWORD1(v92))), &v81[2 * DWORD1(v92)], a5);
      (*(void (**)(uint64_t, uint64_t, _QWORD, char *, int *))(a1 + 48))(a1, v83 + 2 * DWORD1(v93), (2 * (v79 - DWORD1(v93))), &v81[2 * DWORD1(v93)], a5);
      v40 = v80;
    }
  }
  return (v40 + v22);
}

uint64_t sub_18BC1BF50(uint64_t *a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  uint64_t v5;
  const char *v6;
  const char *v7;
  _OWORD v9[4];
  _OWORD v10[4];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  memset(v10, 0, 60);
  memset(v9, 0, 60);
  v5 = *a1;
  v6 = (const char *)((uint64_t (*)(_OWORD *, uint64_t))a1[3])(v10, *a1 + 2 * *a2);
  v7 = (const char *)((uint64_t (*)(_OWORD *, uint64_t))a1[3])(v9, v5 + 2 * *a3);
  return strcmp(v6, v7);
}

uint64_t sub_18BC1C004()
{
  if (qword_1EE0094E0)
  {
    udata_close((_OWORD *)qword_1EE0094E0);
    qword_1EE0094E0 = 0;
  }
  atomic_store(0, &dword_1EE0094D8);
  xmmword_1EE0094B8 = 0u;
  *(_OWORD *)&dword_1EE0094C8 = 0u;
  xmmword_1EE009498 = 0u;
  *(_OWORD *)&qword_1EE0094A8 = 0u;
  xmmword_1EE009478 = 0u;
  *(_OWORD *)&qword_1EE009488 = 0u;
  xmmword_1EE009468 = 0u;
  return 1;
}

BOOL sub_18BC1C05C(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  return *(unsigned __int16 *)a4 >= 0x14u
      && !a4[4]
      && !a4[5]
      && a4[8] == 67
      && a4[9] == 118
      && a4[10] == 65
      && a4[11] == 108
      && a4[12] == 3;
}

uint64_t sub_18BC1C0C0(unsigned __int8 *a1)
{
  BOOL v1;
  uint64_t v3;

  if (*((_QWORD *)&xmmword_1EE009468 + 1))
    v1 = dword_1EE0094B4 == 0;
  else
    v1 = 1;
  if (v1)
    return 0xFFFFFFFFLL;
  v3 = 0;
  while (uprv_stricmp((_BYTE *)(*((_QWORD *)&xmmword_1EE009498 + 1)+ 2 * *(unsigned __int16 *)(*((_QWORD *)&xmmword_1EE009468 + 1) + 2 * v3)), a1))
  {
    if (++v3 >= (unint64_t)dword_1EE0094B4)
      return 0xFFFFFFFFLL;
  }
  return v3;
}

void sub_18BC1C13C(void **a1)
{
  uprv_free(a1[1]);
  uprv_free(a1);
}

uint64_t sub_18BC1C164(uint64_t a1)
{
  uint64_t v1;

  v1 = **(unsigned int **)(a1 + 8);
  if ((_DWORD)v1)
    return *(unsigned __int16 *)(qword_1EE009490 + 2 * v1);
  else
    return 0;
}

uint64_t sub_18BC1C188(uint64_t a1, _DWORD *a2)
{
  unsigned int *v3;
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v3 = *(unsigned int **)(a1 + 8);
  v4 = *v3;
  if ((_DWORD)v4 && (v5 = (unsigned __int16 *)(qword_1EE009490 + 2 * v4), v6 = v3[1], v6 < *v5))
  {
    v7 = *((_QWORD *)&xmmword_1EE009498 + 1);
    v3[1] = v6 + 1;
    v8 = v5[v6 + 1];
    v9 = v7 + 2 * v8;
    if (a2)
    {
      v10 = strlen((const char *)(v7 + 2 * v8));
LABEL_7:
      *a2 = v10;
    }
  }
  else
  {
    v9 = 0;
    if (a2)
    {
      v10 = 0;
      goto LABEL_7;
    }
  }
  return v9;
}

uint64_t sub_18BC1C20C(uint64_t result)
{
  *(_DWORD *)(*(_QWORD *)(result + 8) + 4) = 0;
  return result;
}

uint64_t sub_18BC1C218()
{
  return dword_1EE0094B0;
}

uint64_t sub_18BC1C224(uint64_t a1, _DWORD *a2)
{
  _WORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v3 = *(_WORD **)(a1 + 8);
  v4 = (unsigned __int16)*v3;
  if (dword_1EE0094B0 <= v4)
  {
    v8 = 0;
    if (a2)
    {
      v9 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    v5 = *((_QWORD *)&xmmword_1EE009498 + 1);
    v6 = xmmword_1EE009468;
    *v3 = v4 + 1;
    v7 = *(unsigned __int16 *)(v6 + 2 * v4);
    v8 = v5 + 2 * v7;
    if (a2)
    {
      v9 = strlen((const char *)(v5 + 2 * v7));
LABEL_6:
      *a2 = v9;
    }
  }
  return v8;
}

uint64_t sub_18BC1C29C(uint64_t result)
{
  **(_WORD **)(result + 8) = 0;
  return result;
}

void sub_18BC1C2A8(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 1);
}

void sub_18BC1C2B0(uint64_t a1)
{
  uint64_t v1;
  uint64_t i;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
  {
    for (i = 0; i != 160; i += 8)
    {
      v4 = *(_QWORD *)(v1 + i);
      if (v4)
        sub_18BC15BD4(v4);
    }
    if (!*(_BYTE *)(a1 + 62))
    {
      uprv_free(*(void **)(a1 + 16));
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
}

_QWORD *sub_18BC1C30C(_QWORD *result, int *a2)
{
  _QWORD *v3;
  int v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  char *v12;
  unsigned __int8 v13;
  uint64_t v14;
  char *v15;
  __int16 *p_dst;
  _WORD *v17;
  _DWORD *v18;
  uint64_t v19;
  __int16 __dst;
  char v21;

  v3 = result;
  v4 = *a2;
  if (*a2 < 1)
  {
    v21 = 0;
    __dst = 0;
    v6 = result[2];
    v7 = result[3];
    if (v7 <= v6)
      return result;
    v8 = (char *)result[2];
    while (1)
    {
      if (v3[5] <= v3[4])
      {
        v5 = 15;
        goto LABEL_5;
      }
      v9 = v3[1];
      v10 = *(char *)(v9 + 64);
      if (*(_BYTE *)(v9 + 64))
      {
        if (3 - v10 >= v7 - (unint64_t)v8)
          v11 = v7 - (_QWORD)v8;
        else
          v11 = 3 - v10;
        memcpy(&__dst, (const void *)(v9 + 65), *(char *)(v9 + 64));
        v12 = (char *)&__dst + v10;
        memcpy((char *)&__dst + v10, v8, v11);
        v3[2] = &__dst;
        v3[3] = (char *)&__dst + v10 + v11;
        v13 = v10 + v11;
        result = (_QWORD *)sub_18BC1CD6C(v3, a2);
        v14 = v3[1];
        v15 = &v8[v3[2] - (_QWORD)v12];
        v3[2] = v15;
        v3[3] = v7;
        v4 = *a2;
        if (*a2 == 11)
        {
          *(_BYTE *)(v14 + 64) = v13;
          result = memcpy((void *)(v14 + 65), &__dst, (char)v13);
          v5 = 0;
          v3[2] = v3[3];
          goto LABEL_5;
        }
        *(_BYTE *)(v14 + 64) = 0;
        p_dst = &__dst;
      }
      else
      {
        result = (_QWORD *)sub_18BC1CD6C(v3, a2);
        v15 = (char *)v3[2];
        v13 = (_BYTE)v15 - (_BYTE)v8;
        v4 = *a2;
        p_dst = (__int16 *)v8;
      }
      if (v4 > 0)
        break;
      if ((unsigned __int16)result > 0xFFFDu)
      {
        if ((unsigned __int16)result == 65534)
          v4 = 10;
        else
          v4 = 12;
        *a2 = v4;
        break;
      }
      v17 = (_WORD *)v3[4];
      *v17 = (_WORD)result;
      v3[4] = v17 + 1;
      v18 = (_DWORD *)v3[6];
      if (v18)
      {
        *v18 = (_DWORD)v8 - v6;
        v3[6] = v18 + 1;
      }
      v7 = v3[3];
      v8 = v15;
      if (v7 <= (unint64_t)v15)
        return result;
    }
    v19 = v3[1];
    *(_BYTE *)(v19 + 64) = v13;
    if ((char)v13 >= 1)
    {
      result = memcpy((void *)(v19 + 65), p_dst, v13);
      v4 = *a2;
    }
  }
  else
  {
    *(_BYTE *)(result[1] + 64) = 0;
  }
  if (v4 == 11)
  {
    v5 = 0;
LABEL_5:
    *a2 = v5;
  }
  return result;
}

uint64_t sub_18BC1C4F8(uint64_t result, int *a2)
{
  unsigned __int16 *v2;
  _QWORD *v4;
  int v5;
  uint64_t v6;
  char *v7;
  char v8;
  unsigned __int16 v9;
  __int16 *v10;
  BOOL v11;
  _BYTE *v12;
  char *v13;
  char v14;
  _DWORD *v15;
  uint64_t v16;
  _BYTE *v17;
  char v18;
  unsigned __int8 *v19;
  unsigned int v20;
  unsigned int v21;
  char v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  BOOL v26;
  _BOOL4 v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  _BOOL4 v31;
  char v32;
  int v33;
  char v34;
  char *v35;
  __int16 v36;
  char v37;
  unsigned __int16 v38;
  unsigned __int8 v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  v2 = *(unsigned __int16 **)(result + 16);
  if ((unint64_t)v2 < *(_QWORD *)(result + 24))
  {
    v4 = (_QWORD *)result;
    v5 = 0;
    v6 = *(_QWORD *)(*(_QWORD *)(result + 8) + 16);
    v7 = (char *)&v36 + 1;
    v37 = 0;
    v36 = 0;
    v40 = 0;
    v41 = 0;
    v42 = 0;
    while (1)
    {
      if (*a2 > 0)
        return result;
      if (v4[4] >= v4[5])
      {
        *a2 = 15;
        return result;
      }
      v8 = *(_BYTE *)(v6 + 161);
      v9 = *v2;
      v38 = v9;
      if ((v9 & 0xFF80) != 0x80)
        break;
      v10 = &v36;
      v11 = v9 - 167 > 0x30 || ((1 << (v9 + 89)) & 0x100000000A603) == 0;
      if (v11 && v9 != 247)
      {
        *(_BYTE *)(v6 + 161) = 1;
LABEL_15:
        v10 = &v36;
        if (v9 <= 0x19u && ((1 << v9) & 0x2002601) != 0)
        {
          LOBYTE(v36) = v9;
          v10 = (__int16 *)v7;
        }
      }
      if (v9 <= 0x19u && ((1 << v9) & 0x2002601) != 0)
        goto LABEL_20;
      v19 = (unsigned __int8 *)&unk_18BE13622;
      do
      {
        v20 = *((unsigned __int16 *)v19 + 2);
        v19 += 6;
      }
      while (v20 < v9);
      if (*((unsigned __int16 *)v19 - 2) > v9)
        goto LABEL_39;
      v21 = *v19;
      if (v21 == 15)
      {
        if (v9 <= 0x1Fu)
        {
          *(_BYTE *)v10 = 15;
          LOBYTE(v9) = v9 + 32;
          goto LABEL_51;
        }
        if ((unsigned __int16)(v9 - 128) <= 0x20u)
        {
          *(_BYTE *)v10 = 15;
LABEL_51:
          *((_BYTE *)v10++ + 1) = v9;
        }
        result = (char *)v10 - (char *)&v36;
        v21 = 15;
        goto LABEL_53;
      }
      if (v21 == 20)
      {
LABEL_39:
        v21 = 20;
        *(_BYTE *)v10 = 20;
        if ((_BYTE)v9)
          v22 = HIBYTE(v9);
        else
          v22 = -10;
        if (!(_BYTE)v9)
          LOBYTE(v9) = HIBYTE(v9);
        *((_BYTE *)v10 + 1) = v22;
        *((_BYTE *)v10 + 2) = v9;
        v10 = (__int16 *)((char *)v10 + 3);
        result = (char *)v10 - (char *)&v36;
      }
      else
      {
        if (v21 > 0x13)
          goto LABEL_54;
        result = sub_18BC1CFE0(v6, *v19, v10, &v38, &v39, (uint64_t)&v40);
      }
LABEL_53:
      if ((_DWORD)result)
        goto LABEL_21;
LABEL_54:
      v40 = 0;
      v41 = 0;
      v42 = 0;
      v23 = *(unsigned __int8 *)(v6 + 160);
      if (v23 == 1 || (v21 != 128 || v23 >= 0x10) && v21 != 130 && (v21 != 129 || v23 < 0x10))
        goto LABEL_55;
      v25 = *(unsigned __int8 *)(v6 + 161);
      if (v25 <= 0xF)
      {
        result = sub_18BC1CFE0(v6, 1u, v10, &v38, &v39, (uint64_t)&v40);
        if ((_DWORD)result)
          goto LABEL_21;
        result = sub_18BC1CFE0(v6, 0, v10, &v38, &v39, (uint64_t)&v40);
        if ((_DWORD)result)
          goto LABEL_21;
        v25 = *(unsigned __int8 *)(v6 + 161);
      }
      result = sub_18BC1CFE0(v6, v25, v10, &v38, &v39, (uint64_t)&v40);
      if (!(_DWORD)result)
      {
LABEL_55:
        v24 = *(unsigned __int8 *)(v6 + 161);
        if (*(_BYTE *)(v6 + 161) && (v21 == 128 && v24 < 0x10 || v21 == 130 || v21 == 129 && v24 >= 0x10))
        {
          result = sub_18BC1CFE0(v6, v24, v10, &v38, &v39, (uint64_t)&v40);
          if ((_DWORD)result)
          {
LABEL_79:
            if (!(_DWORD)result)
              goto LABEL_89;
            goto LABEL_21;
          }
        }
        else
        {
          result = 0;
        }
        if (v39)
        {
          if (v21 != 128 || v39 >= 0x10u)
          {
            v26 = v21 == 129 && v39 > 0xFu;
            v27 = v26;
            if (v21 != 130 && !v27)
            {
LABEL_89:
              v35 = v7;
              if (v21 == 129)
                v28 = 16;
              else
                v28 = 1;
              if ((((_BYTE)v21 + 127) & 0xFE) != 0)
                v29 = 11;
              else
                v29 = 19;
              if (v29 >= v28)
              {
                do
                {
                  v30 = *(_QWORD *)(v6 + 8 * v28);
                  if (v30)
                  {
                    if (*((_BYTE *)&v40 + v28))
                      v30 = 0;
                    else
                      v30 = sub_18BC1CFE0(v6, v28, v10, &v38, &v39, (uint64_t)&v40);
                  }
                  v31 = v30 == 0;
                  if (v28 >= v29)
                    break;
                  ++v28;
                }
                while (!(_DWORD)v30);
              }
              else
              {
                v30 = 0;
                v31 = 1;
              }
              if (v21 == 129)
              {
                v7 = v35;
              }
              else
              {
                v7 = v35;
                if (v31)
                  v30 = sub_18BC1CFE0(v6, 0, v10, &v38, &v39, (uint64_t)&v40);
              }
              result = v30;
              if (!(_DWORD)v30)
              {
                v32 = v38;
                v33 = HIBYTE(v38);
                *(_BYTE *)v10 = 20;
                if (v32)
                  v34 = v33;
                else
                  v34 = -10;
                if (!v32)
                  v32 = v33;
                *((_BYTE *)v10 + 1) = v34;
                *((_BYTE *)v10 + 2) = v32;
                result = v10 - &v36 + 3;
              }
              goto LABEL_21;
            }
          }
          result = sub_18BC1CFE0(v6, v39, v10, &v38, &v39, (uint64_t)&v40);
        }
        goto LABEL_79;
      }
LABEL_21:
      v4[2] += 2;
      v12 = (_BYTE *)v4[4];
      if ((unint64_t)v12 >= v4[5])
      {
        v13 = (char *)&v36;
LABEL_29:
        if ((int)result >= 1)
        {
          v16 = v4[1];
          v17 = (_BYTE *)(v16 + 104);
          *a2 = 15;
          *(_BYTE *)(v16 + 91) = result;
          do
          {
            v18 = *v13++;
            *v17++ = v18;
            result = (result - 1);
          }
          while ((_DWORD)result);
        }
      }
      else
      {
        v13 = (char *)&v36;
        while ((_DWORD)result)
        {
          v14 = *v13++;
          v4[4] = v12 + 1;
          *v12 = v14;
          v15 = (_DWORD *)v4[6];
          if (v15)
          {
            *v15 = v5;
            v4[6] = v15 + 1;
          }
          v12 = (_BYTE *)v4[4];
          result = (result - 1);
          if ((unint64_t)v12 >= v4[5])
            goto LABEL_29;
        }
      }
      ++v5;
      *(_BYTE *)(v6 + 161) = v8;
      v2 = (unsigned __int16 *)v4[2];
      if ((unint64_t)v2 >= v4[3])
        return result;
    }
    if ((unsigned __int16)(v9 - 32) <= 0x5Fu)
    {
      LOBYTE(v36) = v9;
LABEL_20:
      result = 1;
      goto LABEL_21;
    }
    goto LABEL_15;
  }
  return result;
}

uint64_t sub_18BC1CAF0(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v3;
  uint64_t v4;
  __int128 *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;

  if (*a3 <= 0)
  {
    v3 = 0;
    *a3 = 456;
  }
  else
  {
    v3 = a2;
    v4 = 0;
    v5 = *(__int128 **)(a1 + 16);
    v6 = *v5;
    v7 = v5[2];
    *(_OWORD *)(a2 + 304) = v5[1];
    *(_OWORD *)(a2 + 320) = v7;
    *(_OWORD *)(a2 + 288) = v6;
    v8 = v5[3];
    v9 = v5[4];
    v10 = v5[6];
    *(_OWORD *)(a2 + 368) = v5[5];
    *(_OWORD *)(a2 + 384) = v10;
    *(_OWORD *)(a2 + 336) = v8;
    *(_OWORD *)(a2 + 352) = v9;
    v11 = v5[7];
    v12 = v5[8];
    v13 = v5[9];
    *(_QWORD *)(a2 + 448) = *((_QWORD *)v5 + 20);
    v14 = a2 + 288;
    *(_OWORD *)(a2 + 416) = v12;
    *(_OWORD *)(a2 + 432) = v13;
    *(_OWORD *)(a2 + 400) = v11;
    do
    {
      v15 = *(_QWORD *)((char *)v5 + v4);
      if (v15)
        sub_18BC15C24(v15);
      v4 += 8;
    }
    while (v4 != 160);
    *(_QWORD *)(v3 + 16) = v14;
    *(_BYTE *)(v3 + 62) = 1;
  }
  return v3;
}

void sub_18BC1CB9C(uint64_t a1, uint64_t a2, UErrorCode *a3, char a4)
{
  _OWORD *v8;
  _OWORD *v9;
  uint64_t v10;
  const char *v11;
  int v12;
  const char *v13;
  char **v14;
  int v15;
  size_t v16;
  char *v17;
  char v18;
  __int128 v19[2];
  uint64_t v20;
  _OWORD v21[14];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v8 = uprv_malloc(0xA8uLL);
  *(_QWORD *)(a1 + 16) = v8;
  if (v8)
  {
    v9 = v8;
    v10 = 0;
    memset(v21, 0, sizeof(v21));
    v20 = 0;
    memset(v19, 0, sizeof(v19));
    LODWORD(v19[0]) = 40;
    *v8 = 0u;
    v8[1] = 0u;
    v8[2] = 0u;
    v8[3] = 0u;
    v8[4] = 0u;
    v8[5] = 0u;
    v8[6] = 0u;
    v8[7] = 0u;
    v8[8] = 0u;
    v8[9] = 0u;
    BYTE8(v19[0]) = *(_BYTE *)(a2 + 8);
    *((_QWORD *)v8 + 20) = 0;
    do
    {
      if (*(int *)a3 > 0)
        goto LABEL_9;
      if (((0xF680uLL >> v10) & 1) == 0)
        *((_QWORD *)v9 + v10) = sub_18BC15C78((unsigned __int8 *)off_1E224EF98[v10], v21, v19, a3);
      ++v10;
    }
    while (v10 != 20);
    if (*(int *)a3 > 0 || *(_BYTE *)(a2 + 8))
    {
LABEL_9:
      sub_18BC1C2B0(a1);
      return;
    }
    *((_BYTE *)v9 + 160) = a4;
    v11 = *(const char **)(a2 + 32);
    if (v11 && (v12 = *(unsigned __int8 *)v11, *v11))
    {
      v13 = "ar";
      v14 = &off_1E224F048;
      do
      {
        v15 = *(unsigned __int8 *)v13;
        if (v15 == v12)
        {
          v16 = strlen(v13);
          if (!strncmp(v13, v11, v16))
          {
            v18 = *((_BYTE *)v14 - 8);
            goto LABEL_22;
          }
        }
        else if ((char)v15 > (char)v12)
        {
          break;
        }
        v17 = *v14;
        v14 += 2;
        v13 = v17;
      }
      while (v17);
      v18 = 1;
    }
    else
    {
      v18 = 0;
    }
LABEL_22:
    *((_BYTE *)v9 + 161) = v18;
  }
  else
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }
}

uint64_t sub_18BC1CD6C(_QWORD *a1, _DWORD *a2)
{
  unint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v6;
  unsigned __int8 v7;
  uint64_t result;
  int v9;
  BOOL v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _BOOL4 v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  int v27;
  uint64_t v28;
  _BYTE v29[2];

  v4 = (unsigned __int8 *)a1[2];
  v3 = a1[3];
  if ((unint64_t)v4 >= v3)
  {
    *a2 = 1;
    return 0xFFFFLL;
  }
  else
  {
    v6 = v4 + 1;
    a1[2] = v4 + 1;
    v7 = *v4;
    result = *v4;
    if ((char)*v4 <= 31)
    {
      switch(*v4)
      {
        case 9u:
        case 0xAu:
        case 0xDu:
          return result;
        case 0xBu:
        case 0xCu:
        case 0xEu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
          goto LABEL_15;
        case 0xFu:
          if ((unint64_t)(v4 + 2) > v3)
            goto LABEL_23;
          a1[2] = v4 + 2;
          v9 = *v6;
          if ((v9 & 0x80u) == 0)
            return (v9 - 32);
          else
            return *v6;
        case 0x14u:
          if ((unint64_t)(v4 + 3) > v3)
            goto LABEL_23;
          a1[2] = v4 + 2;
          v22 = v4[1];
          a1[2] = v4 + 3;
          v23 = v4[2];
          if (v22 == 246)
          {
            v22 = v4[2];
            v23 = 0;
          }
          return v23 | (v22 << 8);
        default:
          if (*v4)
            v10 = (_DWORD)result == 25;
          else
            v10 = 1;
          if (v10)
            return result;
LABEL_15:
          if (*v4 <= 0x20u)
          {
            if (*v4 > 0x13u || (v11 = *(uint64_t **)(a1[1] + 16), (v12 = v11[*v4]) == 0))
            {
              result = 0;
              *a2 = 10;
              return result;
            }
            if (*v4 >= 0x10u)
            {
              if ((unint64_t)(v4 + 3) <= v3)
              {
                if ((char)*v6 != (_DWORD)result)
                {
                  result = sub_18BC2735C(v12, (uint64_t)v6, 2);
                  v21 = a1[2] + 2;
                  goto LABEL_29;
                }
                v13 = (uint64_t)(v4 + 2);
                a1[2] = v4 + 2;
                v14 = v12;
                v15 = 1;
LABEL_28:
                result = sub_18BC2735C(v14, v13, v15);
                v21 = a1[2] + 1;
LABEL_29:
                a1[2] = v21;
                return result;
              }
              goto LABEL_23;
            }
            v26 = v4 + 2;
            if ((unint64_t)v26 > v3)
              goto LABEL_23;
            a1[2] = v26;
            v27 = (char)*v6;
            if ((v27 & 0x80000000) == 0)
            {
              v28 = *v11;
              v29[0] = v7;
              v29[1] = v27;
              return sub_18BC2735C(v28, (uint64_t)v29, 2);
            }
            v25 = *v6;
            v24 = *(_QWORD *)(v12 + 56);
            return *(unsigned __int16 *)(v24 + 4 * v25);
          }
          v16 = *(_QWORD *)(a1[1] + 16);
          v17 = *(unsigned __int8 *)(v16 + 160);
          v18 = *(_QWORD *)(v16 + 8 * v17);
          if (v17 < 0x10)
          {
            v24 = *(_QWORD *)(v18 + 56);
            v25 = v7;
            return *(unsigned __int16 *)(v24 + 4 * v25);
          }
          v19 = sub_18BC28C80(*(_QWORD *)(v16 + 8 * v17), v7);
          v20 = a1[2];
          if (v19)
          {
            v3 = a1[3];
            if (v20 + 1 <= v3)
            {
              v13 = v20 - 1;
              v14 = v18;
              v15 = 2;
              goto LABEL_28;
            }
LABEL_23:
            *a2 = 11;
            a1[2] = v3;
            return 0xFFFFLL;
          }
          v3 = a1[3];
          if (v20 > v3)
            goto LABEL_23;
          result = sub_18BC2735C(v18, v20 - 1, 1);
          break;
      }
    }
  }
  return result;
}

uint64_t sub_18BC1CFE0(uint64_t a1, unsigned int a2, _BYTE *a3, unsigned __int16 *a4, _BYTE *a5, uint64_t a6)
{
  uint64_t v11;
  char v12;
  int v13;
  int v14;
  _BYTE *v15;
  uint64_t result;
  int v18;

  v11 = *(_QWORD *)(a1 + 8 * a2);
  v18 = 0;
  v12 = a2;
  v13 = sub_18BC28B6C(v11, *a4, &v18, 0);
  if (v13 < 1)
  {
    result = 0;
    *(_BYTE *)(a6 + a2) = 1;
  }
  else
  {
    v14 = v18;
    *a5 = v12;
    v15 = a3;
    if (a2)
    {
      v15 = a3;
      if (*(unsigned __int8 *)(a1 + 160) != a2)
      {
        *a3 = a2;
        v15 = a3 + 1;
        if (a2 >= 0x10 && v13 == 1)
        {
          v15 = a3 + 2;
          a3[1] = a2;
        }
      }
    }
    if (v13 == 1 && (v14 & 0xE0) == 0)
    {
      return 0;
    }
    else
    {
      switch(v13)
      {
        case 1:
          goto LABEL_15;
        case 2:
          goto LABEL_14;
        case 3:
          goto LABEL_13;
        case 4:
          *v15++ = HIBYTE(v14);
LABEL_13:
          *v15++ = BYTE2(v14);
          BYTE1(v14) = BYTE1(v18);
LABEL_14:
          *v15++ = BYTE1(v14);
          LOBYTE(v14) = v18;
LABEL_15:
          *v15++ = v14;
          break;
        default:
          return v15 - a3;
      }
      return v15 - a3;
    }
  }
  return result;
}

void sub_18BC1D108(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 2);
}

void sub_18BC1D110(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 3);
}

void sub_18BC1D118(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 4);
}

void sub_18BC1D120(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 5);
}

void sub_18BC1D128(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 6);
}

void sub_18BC1D130(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 8);
}

void sub_18BC1D138(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 11);
}

void sub_18BC1D140(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 16);
}

void sub_18BC1D148(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 17);
}

void sub_18BC1D150(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 18);
}

void sub_18BC1D158(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC1CB9C(a1, a2, a3, 19);
}

uint64_t ucnv_getUnicodeSet(uint64_t result, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v5;
  int v7;
  _QWORD v8[2];
  __int128 v9;
  __int128 v10;

  if (a4 && *a4 <= 0)
  {
    v5 = result;
    if (result && a2 && a3 < 2)
    {
      if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 48) + 32) + 120))
      {
        v8[1] = 0x18BC6491CLL;
        v9 = *(_OWORD *)&off_1E224F1D8;
        v10 = xmmword_1E224F1E8;
        v8[0] = a2;
        uset_clear(a2);
        return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, int *))(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32)
                                                                            + 120))(v5, v8, a3, a4);
      }
      v7 = 16;
    }
    else
    {
      v7 = 1;
    }
    *a4 = v7;
  }
  return result;
}

_DWORD *sub_18BC1D21C(_DWORD *result, uint64_t a2, _DWORD *a3)
{
  int v3;

  if ((result[14] & 0xE) != 0)
  {
    *a3 = 1;
  }
  else
  {
    v3 = result[14] & 0xF;
    result[19] = 8 * (v3 == 0);
    if (v3 == 1)
      result[20] = 1;
  }
  return result;
}

_DWORD *sub_18BC1D254(_DWORD *result, int a2)
{
  int v2;

  v2 = result[14] & 0xF;
  if (a2 > 1 || (result[19] = 8 * (v2 == 0), a2 != 1))
  {
    if (v2 == 1)
      result[20] = 1;
  }
  return result;
}

_QWORD *sub_18BC1D290(_QWORD *result, int *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;
  _WORD *v6;
  unint64_t v7;
  unint64_t v8;
  int *v9;
  int v10;
  unsigned int v11;
  char *v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  char v19;
  unsigned __int16 v20;
  _WORD *v21;
  BOOL v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  unsigned __int8 *v26;
  __int16 v27;
  __int16 v28;
  int *v29;
  int v30;
  uint64_t v31;
  __int16 v32;
  __int16 v33;
  unsigned int v34;
  unsigned __int16 v35;
  int v36;
  char v37;

  v2 = result[1];
  if (*(int *)(v2 + 76) <= 7)
    return sub_18BC1DBA0(result, a2);
  v3 = result[2];
  v4 = result[3];
  v5 = v4 - v3;
  if ((_DWORD)v4 != (_DWORD)v3 || *(_DWORD *)(v2 + 72))
  {
    v6 = (_WORD *)result[4];
    v7 = result[5];
    if ((unint64_t)v6 >= v7)
    {
      *a2 = 15;
      return result;
    }
    v8 = (v7 - (unint64_t)v6) >> 1;
    v9 = (int *)result[6];
    v10 = *(_DWORD *)(v2 + 72);
    if (v10)
    {
      LOBYTE(v11) = 1;
      *(_BYTE *)(v2 + 64) = 1;
      v12 = (char *)(v2 + 64);
      *(_BYTE *)(v2 + 65) = v10;
      *(_DWORD *)(v2 + 72) = 0;
    }
    else
    {
      v12 = (char *)(v2 + 64);
      v11 = *(unsigned __int8 *)(v2 + 64);
      if (!*(_BYTE *)(v2 + 64))
      {
        v19 = 0;
        v15 = 0;
        goto LABEL_33;
      }
    }
    v13 = 0;
    v14 = (char)v11;
    v15 = 4 - (char)v11;
    v16 = v4 + (char)v11 - v3 - 4;
    v17 = ~(_DWORD)v3 + v4;
    while (1)
    {
      v18 = v13;
      *(_BYTE *)(v2 + 65 + (v14 + v13)) = *(_BYTE *)(v3 + v13);
      if (v14 + (_DWORD)v13 == 1)
      {
        v11 = __rev16(*(unsigned __int16 *)(v2 + 65));
        if ((v11 & 0xF800) != 0xD800)
        {
          *v6++ = v11;
          v15 = v13 + 1;
          if (v9)
            *v9++ = -1;
          v19 = 0;
          v11 = 0;
          LODWORD(v8) = v8 - 1;
          goto LABEL_32;
        }
        if ((v11 & 0x400) != 0)
        {
          v15 = v13 + 1;
          v19 = 2;
          goto LABEL_32;
        }
      }
      else if (v14 + (_DWORD)v13 == 3)
      {
        if ((*(_BYTE *)(v2 + 67) & 0xFC) != 0xDC)
        {
          *a2 = 12;
          if ((uint64_t)(~v3 + result[2] - v13) < 2)
          {
            v23 = v3 + v13;
            *(_DWORD *)(v2 + 72) = *(unsigned __int8 *)(v2 + 67) | 0x100;
          }
          else
          {
            v23 = v3 + v13 - 1;
          }
          *v12 = 2;
          result[2] = v23;
          goto LABEL_78;
        }
        v20 = _byteswap_ushort(*(_WORD *)(v2 + 67));
        *v6 = bswap32(*(unsigned __int16 *)(v2 + 65)) >> 16;
        v21 = v6 + 1;
        v22 = v8 >= 2;
        LODWORD(v8) = v8 - 2;
        if (v22)
        {
          v21 = v6 + 2;
          v6[1] = v20;
          if (v9)
          {
            *(_QWORD *)v9 = -1;
            v9 += 2;
          }
          v19 = 0;
          v11 = 0;
        }
        else
        {
          LODWORD(v8) = 0;
          v19 = 0;
          v11 = 0;
          *(_WORD *)(v2 + 144) = v20;
          *(_BYTE *)(v2 + 93) = 1;
          *a2 = 15;
        }
        v17 = v16;
        v6 = v21;
LABEL_32:
        *v12 = v19;
        v3 += v18 + 1;
        v5 = v17;
LABEL_33:
        v24 = v5 & 0xFFFFFFFE;
        if (2 * (int)v8 <= v5)
          v24 = 2 * v8;
        if (v11 || !v24)
          goto LABEL_61;
        v5 -= v24;
        v25 = v24 >> 1;
        LODWORD(v8) = v8 - (v24 >> 1);
        if (v9)
        {
          while (1)
          {
            v26 = (unsigned __int8 *)(v3 + 2);
            v11 = __rev16(*(unsigned __int16 *)v3);
            if ((v11 & 0xF800) == 0xD800)
            {
              if ((v11 & 0x400) != 0 || v25 < 2)
                goto LABEL_57;
              v27 = *v26;
              if ((v27 & 0xFC) != 0xDC)
                goto LABEL_60;
              v28 = *(unsigned __int8 *)(v3 + 3) | (unsigned __int16)(v27 << 8);
              v3 += 4;
              --v25;
              *v6 = v11;
              v6[1] = v28;
              v6 += 2;
              *v9 = v15;
              v29 = v9 + 1;
              v30 = 4;
              v31 = 2;
            }
            else
            {
              *v6++ = v11;
              v30 = 2;
              v31 = 1;
              v29 = v9;
              v3 += 2;
            }
            v9 += v31;
            *v29 = v15;
            v15 += v30;
            if (!--v25)
              goto LABEL_72;
          }
        }
        while (1)
        {
          v26 = (unsigned __int8 *)(v3 + 2);
          v11 = __rev16(*(unsigned __int16 *)v3);
          if ((v11 & 0xF800) == 0xD800)
          {
            if ((v11 & 0x400) != 0 || v25 < 2)
            {
              v9 = 0;
LABEL_57:
              if (!v25)
              {
                v3 = (unint64_t)v26;
                goto LABEL_72;
              }
LABEL_60:
              v5 = v5 + 2 * v25 - 2;
              LODWORD(v8) = v25 + v8;
              v3 = (unint64_t)v26;
LABEL_61:
              if (!v11)
                goto LABEL_72;
              *(_BYTE *)(v2 + 65) = BYTE1(v11);
              *(_BYTE *)(v2 + 66) = v11;
              v19 = 2;
              *(_BYTE *)(v2 + 64) = 2;
              if ((v11 & 0x400) == 0)
              {
                v34 = v5 - 2;
                if (v5 < 2)
                {
                  v19 = 2;
                  goto LABEL_72;
                }
                if ((*(_BYTE *)v3 & 0xFC) == 0xDC)
                {
                  v35 = _byteswap_ushort(*(_WORD *)v3);
                  v3 += 2;
                  *v6++ = v11;
                  if (v9)
                    *v9++ = v15;
                  v19 = 0;
                  *(_WORD *)(v2 + 144) = v35;
                  *(_BYTE *)(v2 + 93) = 1;
                  *(_BYTE *)(v2 + 64) = 0;
                  v36 = 15;
                  v5 = v34;
LABEL_71:
                  *a2 = v36;
LABEL_72:
                  if (v5 && *a2 <= 0)
                  {
                    if ((_DWORD)v8)
                    {
                      v37 = *(_BYTE *)v3++;
                      *(_BYTE *)(v2 + 64) = v19 + 1;
                      *(_BYTE *)(v2 + v19 + 65) = v37;
                    }
                    else
                    {
                      *a2 = 15;
                    }
                  }
                  result[2] = v3;
LABEL_78:
                  result[4] = v6;
                  result[6] = v9;
                  return result;
                }
                v5 = 1;
                v19 = 2;
              }
              v36 = 12;
              goto LABEL_71;
            }
            v32 = *v26;
            if ((v32 & 0xFC) != 0xDC)
            {
              v9 = 0;
              goto LABEL_60;
            }
            v33 = *(unsigned __int8 *)(v3 + 3) | (unsigned __int16)(v32 << 8);
            v3 += 4;
            --v25;
            *v6 = v11;
            v6[1] = v33;
            v6 += 2;
          }
          else
          {
            *v6++ = v11;
            v3 += 2;
          }
          if (!--v25)
          {
            v9 = 0;
            goto LABEL_72;
          }
        }
      }
      ++v13;
      --v17;
      if (v5 == (_DWORD)v18 + 1)
      {
        v17 = 0;
        v11 = 0;
        v19 = v14 + v13;
        v15 = v5;
        goto LABEL_32;
      }
    }
  }
  return result;
}

_QWORD *sub_18BC1D6C0(_QWORD *result, int *a2)
{
  unsigned __int16 *v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _BYTE *v7;
  unint64_t v8;
  unsigned int v9;
  int32x4_t *v10;
  int v11;
  int v12;
  unsigned __int16 v13;
  BOOL v14;
  unsigned int v15;
  unsigned __int16 v16;
  int v17;
  int32x4_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned __int16 *v21;
  int v22;
  unsigned __int16 v23;
  _BYTE *v24;
  int32x4_t *v25;
  _BYTE *v26;
  int32x4_t *v27;
  unsigned __int16 v28;
  _BYTE *v29;
  _BYTE *v30;
  int v31;
  int32x4_t *v32;
  _BYTE *v33;

  v2 = (unsigned __int16 *)result[2];
  v3 = (result[3] - (_QWORD)v2) >> 1;
  if (!(_DWORD)v3)
    return result;
  v5 = result;
  v6 = result[1];
  if (*(_DWORD *)(v6 + 80) == 1)
  {
    result = (_QWORD *)sub_18BC17544(result[1], byte_18BE13AF0, 2, result + 4, result[5], result + 6, -1, a2);
    *(_DWORD *)(v6 + 80) = 0;
  }
  v7 = (_BYTE *)v5[4];
  v8 = v5[5];
  v33 = v7;
  if ((unint64_t)v7 >= v8)
  {
    *a2 = 15;
    return result;
  }
  v31 = 0;
  v9 = v8 - (_DWORD)v7;
  v10 = (int32x4_t *)v5[6];
  v32 = v10;
  v11 = *(_DWORD *)(v6 + 84);
  v12 = (unsigned __int16)v11;
  if ((_WORD)v11 && ((v13 = *v2, v9 >= 4) ? (v14 = (*v2 & 0xFC00) == 56320) : (v14 = 0), v14))
  {
    ++v2;
    LODWORD(v3) = v3 - 1;
    *v7 = BYTE1(v11);
    v7[1] = v11;
    v7[2] = HIBYTE(v13);
    v7[3] = v13;
    v7 += 4;
    v33 = v7;
    if (v10)
    {
      v18.i64[0] = -1;
      v18.i64[1] = -1;
      *v10++ = v18;
      v32 = v10;
    }
    *(_DWORD *)(v6 + 84) = 0;
    v15 = 1;
    v9 -= 4;
  }
  else
  {
    v15 = 0;
    if ((unsigned __int16)*(_DWORD *)(v6 + 84))
    {
LABEL_11:
      if ((v12 & 0x400) != 0)
        goto LABEL_16;
      if ((unint64_t)v2 >= v5[3])
      {
        v17 = 0;
        goto LABEL_49;
      }
      v16 = *v2;
      if ((*v2 & 0xFC00) != 0xDC00)
      {
LABEL_16:
        v17 = 0;
        *a2 = 12;
      }
      else
      {
        ++v2;
        LOBYTE(v31) = BYTE1(v12);
        BYTE1(v31) = v12;
        BYTE2(v31) = HIBYTE(v16);
        HIBYTE(v31) = v16;
        v17 = 4;
        v12 = 0;
      }
LABEL_49:
      *(_DWORD *)(v6 + 84) = v12;
      v21 = v2;
      goto LABEL_50;
    }
  }
  v19 = 2 * v3;
  if (2 * (int)v3 > v9)
    v19 = v9 & 0xFFFFFFFE;
  v9 -= v19;
  v20 = v19 >> 1;
  v17 = v3 - (v19 >> 1);
  if (v10)
  {
    if (v19)
    {
      v21 = v2;
      while (1)
      {
        v22 = *v21++;
        v12 = v22;
        if ((v22 & 0xF800) == 0xD800)
        {
          if (v20 < 2)
            goto LABEL_46;
          if ((v12 & 0x400) != 0)
            goto LABEL_46;
          v23 = *v21;
          if ((*v21 & 0xFC00) != 0xDC00)
            goto LABEL_46;
          v21 = v2 + 2;
          --v20;
          *v7 = BYTE1(v12);
          v24 = v33;
          v33[1] = v12;
          v24[2] = HIBYTE(v23);
          v24[3] = v23;
          v7 = v24 + 4;
          v25 = v32;
          *v32 = vdupq_n_s32(v15);
          v32 = v25 + 1;
          v33 = v7;
          v15 += 2;
        }
        else
        {
          *v7 = BYTE1(v12);
          v26 = v33;
          v33[1] = v12;
          v7 = v26 + 2;
          v33 = v7;
          v27 = v32;
          v32->i32[0] = v15;
          v32 = (int32x4_t *)&v27->u64[1];
          v27->i32[1] = v15++;
        }
        v2 = v21;
        if (!--v20)
          goto LABEL_42;
      }
    }
    goto LABEL_41;
  }
  if (!v19)
  {
LABEL_41:
    v21 = v2;
LABEL_42:
    if (!v17 || !v9)
      goto LABEL_52;
    v12 = *v21;
    v2 = v21 + 1;
    if ((v12 & 0xF800) != 0xD800)
    {
      LOBYTE(v31) = BYTE1(v12);
      BYTE1(v31) = v12;
      v17 = 2;
      ++v21;
      goto LABEL_51;
    }
    goto LABEL_11;
  }
  while (1)
  {
    v21 = v2 + 1;
    v12 = *v2;
    if ((v12 & 0xF800) != 0xD800)
    {
      *v7 = BYTE1(v12);
      v30 = v33;
      v33[1] = v12;
      v7 = v30 + 2;
      ++v2;
      goto LABEL_40;
    }
    if (v20 < 2)
      break;
    if ((v12 & 0x400) != 0)
      break;
    v28 = *v21;
    if ((*v21 & 0xFC00) != 0xDC00)
      break;
    v2 += 2;
    --v20;
    *v7 = BYTE1(v12);
    v29 = v33;
    v33[1] = v12;
    v29[2] = HIBYTE(v28);
    v29[3] = v28;
    v7 = v29 + 4;
LABEL_40:
    v33 = v7;
    if (!--v20)
      goto LABEL_41;
  }
LABEL_46:
  v9 += 2 * v20;
  v2 = v21;
  if (v12)
    goto LABEL_11;
LABEL_50:
  if (v17)
  {
LABEL_51:
    result = (_QWORD *)sub_18BC17544(v6, (char *)&v31, v17, &v33, v5[5], &v32, v15, a2);
    v7 = v33;
    v9 = *((_DWORD *)v5 + 10) - (_DWORD)v33;
  }
LABEL_52:
  if (*a2 <= 0 && (unint64_t)v21 < v5[3] && !v9)
    *a2 = 15;
  v5[2] = v21;
  v5[4] = v7;
  v5[6] = v32;
  return result;
}

uint64_t sub_18BC1DA5C(_QWORD *a1, int *a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  unint64_t v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  unsigned __int8 *v9;
  _BYTE *v10;
  unint64_t v11;
  char v12;
  int v13;
  int v14;
  unsigned int v15;

  v2 = a1[1];
  if (*(int *)(v2 + 76) >= 8)
  {
    v4 = (char *)a1[2];
    v5 = a1[3];
    if ((unint64_t)v4 >= v5)
    {
      v7 = 8;
      goto LABEL_7;
    }
    v6 = (unsigned __int8 *)(v4 + 2);
    if ((unint64_t)(v4 + 2) > v5)
    {
      *(_BYTE *)(v2 + 65) = *v4;
      *(_BYTE *)(a1[1] + 64) = 1;
      a1[2] = v4 + 1;
      v7 = 11;
LABEL_7:
      *a2 = v7;
      return 0xFFFFLL;
    }
    v8 = *v4;
    v3 = v4[1] | (v8 << 8);
    if ((v8 & 0xF8) != 0xD8)
      goto LABEL_19;
    if ((v8 & 4) == 0)
    {
      v9 = (unsigned __int8 *)(v4 + 4);
      if ((unint64_t)(v4 + 4) > v5)
      {
        v10 = (_BYTE *)(v2 + 65);
        v11 = v5 - (_QWORD)v4;
        *(_BYTE *)(v2 + 64) = v5 - (_BYTE)v4;
        v6 = (unsigned __int8 *)v5;
        do
        {
          v12 = *v4++;
          *v10++ = v12;
          --v11;
        }
        while (v11);
        v13 = 11;
        goto LABEL_18;
      }
      v14 = *v6;
      if ((v14 & 0xFC) == 0xDC)
      {
        v15 = (v4[3] | (v14 << 8)) + ((_DWORD)v3 << 10);
        if (v15 > 0x35FDBFF)
        {
          v3 = v15 - 56613888;
          goto LABEL_20;
        }
        v6 = (unsigned __int8 *)(v4 + 4);
      }
    }
    *(_BYTE *)(v2 + 64) = 2;
    *(_BYTE *)(v2 + 65) = *(v6 - 2);
    *(_BYTE *)(v2 + 66) = *(v6 - 1);
    v13 = 12;
LABEL_18:
    *a2 = v13;
    v3 = 0xFFFFLL;
LABEL_19:
    v9 = v6;
LABEL_20:
    a1[2] = v9;
    return v3;
  }
  return 4294967287;
}

const char *sub_18BC1DB80(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 56) & 0xF) != 0)
    return "UTF-16BE,version=1";
  else
    return "UTF-16BE";
}

_QWORD *sub_18BC1DBA0(_QWORD *result, int *a2)
{
  _QWORD *v3;
  unsigned __int8 *v4;
  uint64_t v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  _DWORD *v9;
  char v10;
  int v11;
  int v12;
  void *v13;
  unsigned __int8 *v14;
  unint64_t v15;
  int v16;

  v3 = result;
  v5 = result[1];
  v4 = (unsigned __int8 *)result[2];
  v6 = (unsigned __int8 *)result[3];
  v7 = *(_DWORD *)(v5 + 76);
  if (v4 >= v6)
  {
LABEL_33:
    v3[2] = v4;
    if (v4 == v6 && *((_BYTE *)v3 + 2))
    {
      if (v7 == 9)
      {
        result = sub_18BC1DDF4(v3, a2);
      }
      else if (v7 == 8)
      {
        result = (_QWORD *)sub_18BC1D290(v3, a2);
      }
    }
    *(_DWORD *)(v5 + 76) = v7;
    return result;
  }
  v8 = 0;
  v9 = (_DWORD *)result[6];
  while (2)
  {
    if (*a2 > 0)
    {
LABEL_28:
      if (v9 && v8)
      {
        v15 = v3[6];
        while ((unint64_t)v9 < v15)
          *v9++ += v8;
      }
      goto LABEL_33;
    }
    switch(v7)
    {
      case 0:
        v10 = *v4++;
        *(_BYTE *)(v5 + 65) = v10;
        v7 = 1;
        *(_BYTE *)(v5 + 64) = 1;
        goto LABEL_8;
      case 1:
        v11 = *v4;
        v12 = *(unsigned __int8 *)(v5 + 65);
        if (v12 == 254 && v11 == 255)
        {
          if (*(_UNKNOWN **)(v5 + 48) == &unk_1E224F440)
          {
            v16 = 9;
            LOBYTE(v11) = -1;
            goto LABEL_43;
          }
          v7 = 8;
LABEL_18:
          ++v4;
          *(_BYTE *)(v5 + 64) = 0;
          v8 = (_DWORD)v4 - *((_DWORD *)v3 + 4);
          goto LABEL_27;
        }
        v13 = *(void **)(v5 + 48);
        if (v12 == 255 && v11 == 254)
        {
          if (v13 == &unk_1E224F288)
          {
            v16 = 8;
            LOBYTE(v11) = -2;
            goto LABEL_43;
          }
          v7 = 9;
          goto LABEL_18;
        }
        if (v13 != &unk_1E224F5F8 && v13 != &unk_1E224F7B0 || (*(_DWORD *)(v5 + 56) & 0xF) != 1)
        {
          v14 = (unsigned __int8 *)v3[2];
          if (v4 != v14)
          {
            *(_BYTE *)(v5 + 64) = 0;
            v4 = v14;
          }
          if (v13 == &unk_1E224F440)
            v7 = 9;
          else
            v7 = 8;
LABEL_27:
          *(_DWORD *)(v5 + 76) = v7;
LABEL_8:
          if (v4 >= v6)
            goto LABEL_28;
          continue;
        }
        v16 = 8;
LABEL_43:
        *(_BYTE *)(v5 + 66) = v11;
        *(_BYTE *)(v5 + 64) = 2;
        v3[2] = v4 + 1;
        *(_DWORD *)(v5 + 76) = v16;
        *a2 = 18;
        return result;
      case 8:
        v3[2] = v4;
        result = (_QWORD *)sub_18BC1D290(v3, a2);
        v4 = (unsigned __int8 *)v3[2];
        v7 = 8;
        goto LABEL_8;
      case 9:
        v3[2] = v4;
        result = sub_18BC1DDF4(v3, a2);
        v4 = (unsigned __int8 *)v3[2];
        v7 = 9;
        goto LABEL_8;
      default:
        goto LABEL_8;
    }
  }
}

_QWORD *sub_18BC1DDF4(_QWORD *result, int *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;
  _WORD *v6;
  unint64_t v7;
  unint64_t v8;
  int *v9;
  int v10;
  int v11;
  char *v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  char v19;
  __int16 v20;
  __int16 v21;
  _WORD *v22;
  BOOL v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unsigned __int8 *v27;
  __int16 v28;
  __int16 v29;
  int *v30;
  int v31;
  uint64_t v32;
  __int16 v33;
  __int16 v34;
  unsigned int v35;
  __int16 v36;
  __int16 v37;
  __int16 v38;
  int v39;
  char v40;

  v2 = result[1];
  if (*(int *)(v2 + 76) <= 7)
    return (_QWORD *)sub_18BC1DBA0();
  v3 = result[2];
  v4 = result[3];
  v5 = v4 - v3;
  if ((_DWORD)v4 != (_DWORD)v3 || *(_DWORD *)(v2 + 72))
  {
    v6 = (_WORD *)result[4];
    v7 = result[5];
    if ((unint64_t)v6 >= v7)
    {
      *a2 = 15;
      return result;
    }
    v8 = (v7 - (unint64_t)v6) >> 1;
    v9 = (int *)result[6];
    v10 = *(_DWORD *)(v2 + 72);
    if (v10)
    {
      LOBYTE(v11) = 1;
      *(_BYTE *)(v2 + 64) = 1;
      v12 = (char *)(v2 + 64);
      *(_BYTE *)(v2 + 65) = v10;
      *(_DWORD *)(v2 + 72) = 0;
    }
    else
    {
      v12 = (char *)(v2 + 64);
      v11 = *(unsigned __int8 *)(v2 + 64);
      if (!*(_BYTE *)(v2 + 64))
      {
        v19 = 0;
        v15 = 0;
        goto LABEL_33;
      }
    }
    v13 = 0;
    v14 = (char)v11;
    v15 = 4 - (char)v11;
    v16 = v4 + (char)v11 - v3 - 4;
    v17 = ~(_DWORD)v3 + v4;
    while (1)
    {
      v18 = v13;
      *(_BYTE *)(v2 + 65 + (v14 + v13)) = *(_BYTE *)(v3 + v13);
      if (v14 + (_DWORD)v13 == 1)
      {
        v11 = *(unsigned __int16 *)(v2 + 65);
        if ((v11 & 0xF800) != 0xD800)
        {
          *v6++ = v11;
          v15 = v13 + 1;
          if (v9)
            *v9++ = -1;
          v19 = 0;
          v11 = 0;
          LODWORD(v8) = v8 - 1;
          goto LABEL_32;
        }
        if ((v11 & 0x400) != 0)
        {
          v15 = v13 + 1;
          v19 = 2;
          goto LABEL_32;
        }
      }
      else if (v14 + (_DWORD)v13 == 3)
      {
        v20 = *(unsigned __int8 *)(v2 + 68);
        if ((v20 & 0xFC) != 0xDC)
        {
          *a2 = 12;
          if ((uint64_t)(~v3 + result[2] - v13) < 2)
          {
            v24 = v3 + v13;
            *(_DWORD *)(v2 + 72) = *(unsigned __int8 *)(v2 + 67) | 0x100;
          }
          else
          {
            v24 = v3 + v13 - 1;
          }
          *v12 = 2;
          result[2] = v24;
          goto LABEL_78;
        }
        v21 = *(unsigned __int8 *)(v2 + 67) | (unsigned __int16)(v20 << 8);
        *v6 = *(_WORD *)(v2 + 65);
        v22 = v6 + 1;
        v23 = v8 >= 2;
        LODWORD(v8) = v8 - 2;
        if (v23)
        {
          v22 = v6 + 2;
          v6[1] = v21;
          if (v9)
          {
            *(_QWORD *)v9 = -1;
            v9 += 2;
          }
          v19 = 0;
          v11 = 0;
        }
        else
        {
          LODWORD(v8) = 0;
          v19 = 0;
          v11 = 0;
          *(_WORD *)(v2 + 144) = v21;
          *(_BYTE *)(v2 + 93) = 1;
          *a2 = 15;
        }
        v17 = v16;
        v6 = v22;
LABEL_32:
        *v12 = v19;
        v3 += v18 + 1;
        v5 = v17;
LABEL_33:
        v25 = v5 & 0xFFFFFFFE;
        if (2 * (int)v8 <= v5)
          v25 = 2 * v8;
        if (v11 || !v25)
          goto LABEL_61;
        v5 -= v25;
        v26 = v25 >> 1;
        LODWORD(v8) = v8 - (v25 >> 1);
        if (v9)
        {
          while (1)
          {
            v27 = (unsigned __int8 *)(v3 + 2);
            v11 = *(unsigned __int16 *)v3;
            if ((v11 & 0xF800) == 0xD800)
            {
              if ((v11 & 0x400) != 0 || v26 < 2)
                goto LABEL_57;
              v28 = *(unsigned __int8 *)(v3 + 3);
              if ((v28 & 0xFC) != 0xDC)
                goto LABEL_60;
              v29 = *(unsigned __int8 *)(v3 + 2) | (unsigned __int16)(v28 << 8);
              v3 += 4;
              --v26;
              *v6 = v11;
              v6[1] = v29;
              v6 += 2;
              *v9 = v15;
              v30 = v9 + 1;
              v31 = 4;
              v32 = 2;
            }
            else
            {
              *v6++ = v11;
              v31 = 2;
              v32 = 1;
              v30 = v9;
              v3 += 2;
            }
            v9 += v32;
            *v30 = v15;
            v15 += v31;
            if (!--v26)
              goto LABEL_72;
          }
        }
        while (1)
        {
          v27 = (unsigned __int8 *)(v3 + 2);
          v11 = *(unsigned __int16 *)v3;
          if ((v11 & 0xF800) == 0xD800)
          {
            if ((v11 & 0x400) != 0 || v26 < 2)
            {
              v9 = 0;
LABEL_57:
              if (!v26)
              {
                v3 = (unint64_t)v27;
                goto LABEL_72;
              }
LABEL_60:
              v5 = v5 + 2 * v26 - 2;
              LODWORD(v8) = v26 + v8;
              v3 = (unint64_t)v27;
LABEL_61:
              if (!v11)
                goto LABEL_72;
              *(_WORD *)(v2 + 65) = v11;
              v19 = 2;
              *(_BYTE *)(v2 + 64) = 2;
              if ((v11 & 0x400) == 0)
              {
                v35 = v5 - 2;
                if (v5 < 2)
                {
                  v19 = 2;
                  goto LABEL_72;
                }
                v36 = *(unsigned __int8 *)(v3 + 1);
                if ((v36 & 0xFC) == 0xDC)
                {
                  v37 = *(unsigned __int8 *)v3;
                  v3 += 2;
                  v38 = v37 | (v36 << 8);
                  *v6++ = v11;
                  if (v9)
                    *v9++ = v15;
                  v19 = 0;
                  *(_WORD *)(v2 + 144) = v38;
                  *(_BYTE *)(v2 + 93) = 1;
                  *(_BYTE *)(v2 + 64) = 0;
                  v39 = 15;
                  v5 = v35;
LABEL_71:
                  *a2 = v39;
LABEL_72:
                  if (v5 && *a2 <= 0)
                  {
                    if ((_DWORD)v8)
                    {
                      v40 = *(_BYTE *)v3++;
                      *(_BYTE *)(v2 + 64) = v19 + 1;
                      *(_BYTE *)(v2 + v19 + 65) = v40;
                    }
                    else
                    {
                      *a2 = 15;
                    }
                  }
                  result[2] = v3;
LABEL_78:
                  result[4] = v6;
                  result[6] = v9;
                  return result;
                }
                v5 = 1;
                v19 = 2;
              }
              v39 = 12;
              goto LABEL_71;
            }
            v33 = *(unsigned __int8 *)(v3 + 3);
            if ((v33 & 0xFC) != 0xDC)
            {
              v9 = 0;
              goto LABEL_60;
            }
            v34 = *(unsigned __int8 *)(v3 + 2) | (unsigned __int16)(v33 << 8);
            v3 += 4;
            --v26;
            *v6 = v11;
            v6[1] = v34;
            v6 += 2;
          }
          else
          {
            *v6++ = v11;
            v3 += 2;
          }
          if (!--v26)
          {
            v9 = 0;
            goto LABEL_72;
          }
        }
      }
      ++v13;
      --v17;
      if (v5 == (_DWORD)v18 + 1)
      {
        v17 = 0;
        v11 = 0;
        v19 = v14 + v13;
        v15 = v5;
        goto LABEL_32;
      }
    }
  }
  return result;
}

_DWORD *sub_18BC1E20C(_DWORD *result, uint64_t a2, _DWORD *a3)
{
  int v3;

  if ((result[14] & 0xE) != 0)
  {
    *a3 = 1;
  }
  else
  {
    v3 = result[14] & 0xF;
    result[19] = 8 * (v3 == 0);
    if (v3 == 1)
      result[20] = 1;
  }
  return result;
}

_DWORD *sub_18BC1E244(_DWORD *result, int a2)
{
  int v2;

  v2 = result[14] & 0xF;
  if (a2 > 1 || (result[19] = 8 * (v2 == 0), a2 != 1))
  {
    if (v2 == 1)
      result[20] = 1;
  }
  return result;
}

_QWORD *sub_18BC1E280(_QWORD *result, int *a2)
{
  unsigned __int16 *v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _WORD *v7;
  unint64_t v8;
  unsigned int v9;
  int32x4_t *v10;
  int v11;
  unsigned int v12;
  unsigned __int16 v13;
  BOOL v14;
  unsigned int v15;
  unsigned __int16 v16;
  int v17;
  int32x4_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned __int16 *v21;
  unsigned int v22;
  unsigned __int16 v23;
  unsigned int v24;
  _WORD *v25;
  int32x4_t *v26;
  unsigned int v27;
  _WORD *v28;
  int32x4_t *v29;
  unsigned __int16 v30;
  unsigned int v31;
  _WORD *v32;
  unsigned int v33;
  _WORD *v34;
  int v35;
  int32x4_t *v36;
  _WORD *v37;

  v2 = (unsigned __int16 *)result[2];
  v3 = (result[3] - (_QWORD)v2) >> 1;
  if (!(_DWORD)v3)
    return result;
  v5 = result;
  v6 = result[1];
  if (*(_DWORD *)(v6 + 80) == 1)
  {
    result = (_QWORD *)sub_18BC17544(result[1], byte_18BE13AF2, 2, result + 4, result[5], result + 6, -1, a2);
    *(_DWORD *)(v6 + 80) = 0;
  }
  v7 = (_WORD *)v5[4];
  v8 = v5[5];
  v37 = v7;
  if ((unint64_t)v7 >= v8)
  {
    *a2 = 15;
    return result;
  }
  v35 = 0;
  v9 = v8 - (_DWORD)v7;
  v10 = (int32x4_t *)v5[6];
  v36 = v10;
  v11 = *(_DWORD *)(v6 + 84);
  v12 = (unsigned __int16)v11;
  if ((_WORD)v11 && ((v13 = *v2, v9 >= 4) ? (v14 = (*v2 & 0xFC00) == 56320) : (v14 = 0), v14))
  {
    ++v2;
    LODWORD(v3) = v3 - 1;
    *v7 = v11;
    v7[1] = v13;
    v7 += 2;
    v37 = v7;
    if (v10)
    {
      v18.i64[0] = -1;
      v18.i64[1] = -1;
      *v10++ = v18;
      v36 = v10;
    }
    *(_DWORD *)(v6 + 84) = 0;
    v15 = 1;
    v9 -= 4;
  }
  else
  {
    v15 = 0;
    if ((unsigned __int16)*(_DWORD *)(v6 + 84))
    {
LABEL_11:
      if ((v12 & 0x400) != 0)
        goto LABEL_16;
      if ((unint64_t)v2 >= v5[3])
      {
        v17 = 0;
        goto LABEL_49;
      }
      v16 = *v2;
      if ((*v2 & 0xFC00) != 0xDC00)
      {
LABEL_16:
        v17 = 0;
        *a2 = 12;
      }
      else
      {
        ++v2;
        LOWORD(v35) = v12;
        HIWORD(v35) = v16;
        v17 = 4;
        v12 = 0;
      }
LABEL_49:
      *(_DWORD *)(v6 + 84) = v12;
      v21 = v2;
      goto LABEL_50;
    }
  }
  v19 = v9 & 0xFFFFFFFE;
  if (2 * (int)v3 <= v9)
    v19 = 2 * v3;
  v9 -= v19;
  v20 = v19 >> 1;
  v17 = v3 - (v19 >> 1);
  if (v10)
  {
    if (v19)
    {
      v21 = v2;
      while (1)
      {
        v22 = *v21++;
        v12 = v22;
        if ((v22 & 0xF800) == 0xD800)
        {
          if (v20 < 2)
            goto LABEL_46;
          if ((v12 & 0x400) != 0)
            goto LABEL_46;
          v23 = *v21;
          if ((*v21 & 0xFC00) != 0xDC00)
            goto LABEL_46;
          v21 = v2 + 2;
          --v20;
          *(_BYTE *)v7 = v12;
          v24 = v12 >> 8;
          v25 = v37;
          *((_BYTE *)v37 + 1) = v24;
          v25[1] = v23;
          v7 = v25 + 2;
          v26 = v36;
          *v36 = vdupq_n_s32(v15);
          v36 = v26 + 1;
          v37 = v7;
          v15 += 2;
        }
        else
        {
          *(_BYTE *)v7 = v12;
          v27 = v12 >> 8;
          v28 = v37;
          *((_BYTE *)v37 + 1) = v27;
          v7 = v28 + 1;
          v37 = v28 + 1;
          v29 = v36;
          v36->i32[0] = v15;
          v36 = (int32x4_t *)&v29->u64[1];
          v29->i32[1] = v15++;
        }
        v2 = v21;
        if (!--v20)
          goto LABEL_42;
      }
    }
    goto LABEL_41;
  }
  if (!v19)
  {
LABEL_41:
    v21 = v2;
LABEL_42:
    if (!v17 || !v9)
      goto LABEL_52;
    v12 = *v21;
    v2 = v21 + 1;
    if ((v12 & 0xF800) != 0xD800)
    {
      LOWORD(v35) = v12;
      v17 = 2;
      ++v21;
      goto LABEL_51;
    }
    goto LABEL_11;
  }
  while (1)
  {
    v21 = v2 + 1;
    v12 = *v2;
    if ((v12 & 0xF800) != 0xD800)
    {
      *(_BYTE *)v7 = v12;
      v33 = v12 >> 8;
      v34 = v37;
      *((_BYTE *)v37 + 1) = v33;
      v7 = v34 + 1;
      ++v2;
      goto LABEL_40;
    }
    if (v20 < 2)
      break;
    if ((v12 & 0x400) != 0)
      break;
    v30 = *v21;
    if ((*v21 & 0xFC00) != 0xDC00)
      break;
    v2 += 2;
    --v20;
    *(_BYTE *)v7 = v12;
    v31 = v12 >> 8;
    v32 = v37;
    *((_BYTE *)v37 + 1) = v31;
    v32[1] = v30;
    v7 = v32 + 2;
LABEL_40:
    v37 = v7;
    if (!--v20)
      goto LABEL_41;
  }
LABEL_46:
  v9 += 2 * v20;
  v2 = v21;
  if (v12)
    goto LABEL_11;
LABEL_50:
  if (v17)
  {
LABEL_51:
    result = (_QWORD *)sub_18BC17544(v6, (char *)&v35, v17, &v37, v5[5], &v36, v15, a2);
    v7 = v37;
    v9 = *((_DWORD *)v5 + 10) - (_DWORD)v37;
  }
LABEL_52:
  if (*a2 <= 0 && (unint64_t)v21 < v5[3] && !v9)
    *a2 = 15;
  v5[2] = v21;
  v5[4] = v7;
  v5[6] = v36;
  return result;
}

uint64_t sub_18BC1E61C(_QWORD *a1, int *a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  unint64_t v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  unsigned __int8 *v9;
  _BYTE *v10;
  unint64_t v11;
  char v12;
  int v13;
  int v14;
  unsigned int v15;

  v2 = a1[1];
  if (*(int *)(v2 + 76) >= 8)
  {
    v4 = (char *)a1[2];
    v5 = a1[3];
    if ((unint64_t)v4 >= v5)
    {
      v7 = 8;
      goto LABEL_7;
    }
    v6 = (unsigned __int8 *)(v4 + 2);
    if ((unint64_t)(v4 + 2) > v5)
    {
      *(_BYTE *)(v2 + 65) = *v4;
      *(_BYTE *)(a1[1] + 64) = 1;
      a1[2] = v4 + 1;
      v7 = 11;
LABEL_7:
      *a2 = v7;
      return 0xFFFFLL;
    }
    v8 = v4[1];
    v3 = *v4 | (v8 << 8);
    if ((v8 & 0xF8) != 0xD8)
      goto LABEL_19;
    if ((v8 & 4) == 0)
    {
      v9 = (unsigned __int8 *)(v4 + 4);
      if ((unint64_t)(v4 + 4) > v5)
      {
        v10 = (_BYTE *)(v2 + 65);
        v11 = v5 - (_QWORD)v4;
        *(_BYTE *)(v2 + 64) = v5 - (_BYTE)v4;
        v6 = (unsigned __int8 *)v5;
        do
        {
          v12 = *v4++;
          *v10++ = v12;
          --v11;
        }
        while (v11);
        v13 = 11;
        goto LABEL_18;
      }
      v14 = v4[3];
      if ((v14 & 0xFC) == 0xDC)
      {
        v15 = (*v6 | (v14 << 8)) + ((_DWORD)v3 << 10);
        if (v15 > 0x35FDBFF)
        {
          v3 = v15 - 56613888;
          goto LABEL_20;
        }
        v6 = v9;
      }
    }
    *(_BYTE *)(v2 + 64) = 2;
    *(_BYTE *)(v2 + 65) = *(v6 - 2);
    *(_BYTE *)(v2 + 66) = *(v6 - 1);
    v13 = 12;
LABEL_18:
    *a2 = v13;
    v3 = 0xFFFFLL;
LABEL_19:
    v9 = v6;
LABEL_20:
    a1[2] = v9;
    return v3;
  }
  return 4294967287;
}

const char *sub_18BC1E744(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 56) & 0xF) != 0)
    return "UTF-16LE,version=1";
  else
    return "UTF-16LE";
}

uint64_t sub_18BC1E764(uint64_t result, uint64_t a2, _DWORD *a3)
{
  if ((*(_DWORD *)(result + 56) & 0xFu) > 2)
  {
    *a3 = 1;
  }
  else
  {
    if ((*(_DWORD *)(result + 56) & 0xF) == 2 && !*(_BYTE *)(a2 + 8))
    {
      *(_QWORD *)(result + 48) = &unk_1E224F7B0;
      **(_DWORD **)(result + 40) = 65023;
    }
    *(_QWORD *)(result + 76) = 0x100000000;
  }
  return result;
}

uint64_t sub_18BC1E7B4(uint64_t result, int a2)
{
  if (a2 > 1 || (*(_DWORD *)(result + 76) = 0, a2 != 1))
    *(_DWORD *)(result + 80) = 1;
  return result;
}

uint64_t sub_18BC1E7D0(_QWORD *a1, int *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1[1] + 76);
  if (v2 == 9)
    return sub_18BC1E61C(a1, a2);
  if (v2 == 8)
    return sub_18BC1DA5C(a1, a2);
  return 4294967287;
}

const char *sub_18BC1E7F8(uint64_t a1)
{
  int v1;
  const char *v2;

  v1 = *(_DWORD *)(a1 + 56);
  v2 = "UTF-16,version=2";
  if ((v1 & 0xF) == 1)
    v2 = "UTF-16,version=1";
  if ((v1 & 0xF) != 0)
    return v2;
  else
    return "UTF-16";
}

_QWORD *sub_18BC1E82C(_QWORD *result, int *a2)
{
  _WORD *v2;
  unint64_t v3;
  unint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unsigned int v10;
  int v12;
  _WORD *v14;
  __int16 v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;

  v3 = result[3];
  v2 = (_WORD *)result[4];
  v4 = result[5];
  v6 = result[1];
  v5 = (unsigned __int8 *)result[2];
  v7 = v6 + 65;
  if (*(char *)(v6 + 64) < 1 || (unint64_t)v2 >= v4)
    goto LABEL_6;
  LODWORD(v9) = *(unsigned __int8 *)(v6 + 64);
  *(_BYTE *)(v6 + 64) = 0;
  v10 = *(_DWORD *)(v6 + 72) - 1;
  *(_DWORD *)(v6 + 72) = 0;
  while (v9 > 3)
  {
LABEL_14:
    if (HIWORD(v10) > 0x10u || (v10 & 0xFFFFF800) == 55296)
    {
      *(_BYTE *)(result[1] + 64) = v9;
      *a2 = 12;
      goto LABEL_23;
    }
    if (HIWORD(v10))
    {
      *v2 = (v10 >> 10) - 10304;
      v14 = v2 + 1;
      v15 = v10 & 0x3FF | 0xDC00;
      if ((unint64_t)(v2 + 1) >= v4)
      {
        v18 = result[1];
        *(_WORD *)(v18 + 144) = v15;
        *(_BYTE *)(v18 + 93) = 1;
        *a2 = 15;
        v2 = v14;
        goto LABEL_23;
      }
      v2[1] = v15;
      v2 += 2;
    }
    else
    {
      *v2++ = v10;
    }
LABEL_6:
    v10 = 0;
    LODWORD(v9) = 0;
    if ((unint64_t)v5 >= v3 || (unint64_t)v2 >= v4)
      goto LABEL_23;
  }
  v9 = v9;
  while ((unint64_t)v5 < v3)
  {
    v12 = *v5++;
    v10 = v12 | (v10 << 8);
    *(_BYTE *)(v7 + v9++) = v12;
    if (v9 == 4)
      goto LABEL_14;
  }
  v16 = v10 + 1;
  v17 = result[1];
  *(_DWORD *)(v17 + 72) = v16;
  *(_BYTE *)(v17 + 64) = v9;
LABEL_23:
  if ((unint64_t)v5 < v3 && (unint64_t)v2 >= v4 && *a2 <= 0)
    *a2 = 15;
  result[4] = v2;
  result[2] = v5;
  return result;
}

_QWORD *sub_18BC1E96C(_QWORD *result, int *a2)
{
  _WORD *v2;
  unint64_t v3;
  _DWORD *v4;
  unint64_t v5;
  unsigned __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v11;
  unsigned int v12;
  int v14;
  uint64_t v16;
  _DWORD *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v3 = result[3];
  v2 = (_WORD *)result[4];
  v5 = result[5];
  v4 = (_DWORD *)result[6];
  v7 = result[1];
  v6 = (unsigned __int8 *)result[2];
  v8 = v7 + 65;
  v9 = 0;
  if (*(char *)(v7 + 64) < 1 || (unint64_t)v2 >= v5)
    goto LABEL_6;
  LODWORD(v11) = *(unsigned __int8 *)(v7 + 64);
  *(_BYTE *)(v7 + 64) = 0;
  v12 = *(_DWORD *)(v7 + 72) - 1;
  *(_DWORD *)(v7 + 72) = 0;
  while (v11 > 3)
  {
LABEL_14:
    if (HIWORD(v12) > 0x10u || (v12 & 0xFFFFF800) == 55296)
    {
      *(_BYTE *)(result[1] + 64) = v11;
      *a2 = 12;
      goto LABEL_24;
    }
    if (HIWORD(v12))
    {
      *v2 = (v12 >> 10) - 10304;
      *v4 = v9;
      v17 = v4 + 1;
      v18 = v12 & 0x3FF | 0xDC00;
      if ((unint64_t)(v2 + 1) >= v5)
      {
        v20 = result[1];
        *(_WORD *)(v20 + 144) = v18;
        *(_BYTE *)(v20 + 93) = 1;
        *a2 = 15;
        ++v2;
        v4 = v17;
        goto LABEL_24;
      }
      v2[1] = v18;
      v2 += 2;
      v16 = 2;
    }
    else
    {
      *v2++ = v12;
      v16 = 1;
      v17 = v4;
    }
    v4 += v16;
    *v17 = v9;
    v9 += v11;
LABEL_6:
    v12 = 0;
    LODWORD(v11) = 0;
    if ((unint64_t)v6 >= v3 || (unint64_t)v2 >= v5)
      goto LABEL_24;
  }
  v11 = v11;
  while ((unint64_t)v6 < v3)
  {
    v14 = *v6++;
    v12 = v14 | (v12 << 8);
    *(_BYTE *)(v8 + v11++) = v14;
    if (v11 == 4)
      goto LABEL_14;
  }
  v19 = result[1];
  *(_DWORD *)(v19 + 72) = v12 + 1;
  *(_BYTE *)(v19 + 64) = v11;
LABEL_24:
  if ((unint64_t)v6 < v3 && (unint64_t)v2 >= v5 && *a2 <= 0)
    *a2 = 15;
  result[4] = v2;
  result[2] = v6;
  result[6] = v4;
  return result;
}

uint64_t sub_18BC1EAD8(uint64_t result, int *a2)
{
  unsigned __int16 *v2;
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  int v8;
  int v10;
  int v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  int v16;

  v2 = *(unsigned __int16 **)(result + 16);
  v3 = *(_QWORD *)(result + 24);
  if ((unint64_t)v2 >= v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 40);
  result = *(_QWORD *)(result + 8);
  if (*(_DWORD *)(result + 80) == 1)
  {
    sub_18BC17544(result, byte_18BE13C2C, 4, (_QWORD *)(v5 + 32), v6, (_QWORD *)(v5 + 48), -1, a2);
    result = *(_QWORD *)(v5 + 8);
    *(_DWORD *)(result + 80) = 0;
  }
  v16 = 0;
  v7 = *(_BYTE **)(v5 + 32);
  v8 = *(_DWORD *)(result + 84);
  if (!v8)
    goto LABEL_6;
  *(_DWORD *)(result + 84) = 0;
LABEL_12:
  if ((unint64_t)v2 >= v3)
  {
    *(_DWORD *)(*(_QWORD *)(v5 + 8) + 84) = v8;
    if (!*(_BYTE *)(v5 + 2))
      goto LABEL_24;
  }
  else
  {
    v11 = *v2;
    if ((v11 & 0xFC00) == 0xDC00)
    {
      v8 = v11 + (v8 << 10) - 56613888;
      ++v2;
      while (1)
      {
        v12 = 0;
        BYTE1(v16) = BYTE2(v8) & 0x1F;
        BYTE2(v16) = BYTE1(v8);
        HIBYTE(v16) = v8;
        do
        {
          v13 = *((_BYTE *)&v16 + v12);
          if ((unint64_t)v7 >= v6)
          {
            v14 = *(_QWORD *)(v5 + 8);
            v15 = *(char *)(v14 + 91);
            *(_BYTE *)(v14 + 91) = v15 + 1;
            *(_BYTE *)(v14 + v15 + 104) = v13;
            *a2 = 15;
          }
          else
          {
            *v7++ = v13;
          }
          ++v12;
        }
        while (v12 != 4);
LABEL_6:
        if ((unint64_t)v2 >= v3 || (unint64_t)v7 >= v6)
          goto LABEL_24;
        v10 = *v2++;
        v8 = v10;
        if ((v10 & 0xF800) == 0xD800)
        {
          if ((v8 & 0xFC00) != 0xD800)
            break;
          goto LABEL_12;
        }
      }
    }
    *(_DWORD *)(*(_QWORD *)(v5 + 8) + 84) = v8;
  }
  *a2 = 12;
LABEL_24:
  if ((unint64_t)v2 < v3 && (unint64_t)v7 >= v6 && *a2 <= 0)
    *a2 = 15;
  *(_QWORD *)(v5 + 32) = v7;
  *(_QWORD *)(v5 + 16) = v2;
  return result;
}

uint64_t sub_18BC1EC80(uint64_t result, int *a2)
{
  unsigned __int16 *v2;
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  _DWORD *v8;
  int v9;
  int v10;
  int v12;
  int v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  int v18;

  v2 = *(unsigned __int16 **)(result + 16);
  v3 = *(_QWORD *)(result + 24);
  if ((unint64_t)v2 >= v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 40);
  result = *(_QWORD *)(result + 8);
  if (*(_DWORD *)(result + 80) == 1)
  {
    sub_18BC17544(result, byte_18BE13C30, 4, (_QWORD *)(v5 + 32), v6, (_QWORD *)(v5 + 48), -1, a2);
    result = *(_QWORD *)(v5 + 8);
    *(_DWORD *)(result + 80) = 0;
  }
  v18 = 0;
  v7 = *(_BYTE **)(v5 + 32);
  v8 = *(_DWORD **)(v5 + 48);
  v9 = *(_DWORD *)(result + 84);
  if (!v9)
  {
    v10 = 0;
    goto LABEL_7;
  }
  v10 = 0;
  *(_DWORD *)(result + 84) = 0;
LABEL_13:
  if ((unint64_t)v2 >= v3)
  {
    *(_DWORD *)(*(_QWORD *)(v5 + 8) + 84) = v9;
    if (!*(_BYTE *)(v5 + 2))
      goto LABEL_27;
  }
  else
  {
    v13 = *v2;
    if ((v13 & 0xFC00) == 0xDC00)
    {
      v9 = v13 + (v9 << 10) - 56613888;
      ++v2;
      while (1)
      {
        v14 = 0;
        BYTE1(v18) = BYTE2(v9) & 0x1F;
        BYTE2(v18) = BYTE1(v9);
        HIBYTE(v18) = v9;
        do
        {
          v15 = *((_BYTE *)&v18 + v14);
          if ((unint64_t)v7 >= v6)
          {
            v16 = *(_QWORD *)(v5 + 8);
            v17 = *(char *)(v16 + 91);
            *(_BYTE *)(v16 + 91) = v17 + 1;
            *(_BYTE *)(v16 + v17 + 104) = v15;
            *a2 = 15;
          }
          else
          {
            *v7++ = v15;
            *v8++ = v10;
          }
          ++v14;
        }
        while (v14 != 4);
        if (BYTE1(v18))
          ++v10;
        ++v10;
LABEL_7:
        if ((unint64_t)v2 >= v3 || (unint64_t)v7 >= v6)
          goto LABEL_27;
        v12 = *v2++;
        v9 = v12;
        if ((v12 & 0xF800) == 0xD800)
        {
          if ((v9 & 0xFC00) != 0xD800)
            break;
          goto LABEL_13;
        }
      }
    }
    *(_DWORD *)(*(_QWORD *)(v5 + 8) + 84) = v9;
  }
  *a2 = 12;
LABEL_27:
  if ((unint64_t)v2 < v3 && (unint64_t)v7 >= v6 && *a2 <= 0)
    *a2 = 15;
  *(_QWORD *)(v5 + 32) = v7;
  *(_QWORD *)(v5 + 16) = v2;
  *(_QWORD *)(v5 + 48) = v8;
  return result;
}

uint64_t sub_18BC1EE4C(_QWORD *a1, int *a2)
{
  unint64_t v3;
  unsigned __int8 *v4;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;

  v4 = (unsigned __int8 *)a1[2];
  v3 = a1[3];
  if ((unint64_t)v4 >= v3)
  {
    v7 = 8;
  }
  else
  {
    v6 = v3 - (_DWORD)v4;
    if ((int)v3 - (int)v4 > 3)
    {
      v8 = (*v4 << 24) | (v4[1] << 16);
      v9 = v8 | (v4[2] << 8);
      v10 = v4[3];
      a1[2] = v4 + 4;
      if (HIWORD(v8) <= 0x10u && (v9 & 0xFFFFF800) != 55296)
        return v9 | v10;
      *(_DWORD *)(a1[1] + 65) = *(_DWORD *)v4;
      *(_BYTE *)(a1[1] + 64) = 4;
      v7 = 12;
    }
    else
    {
      memcpy((void *)(a1[1] + 65), v4, v6);
      *(_BYTE *)(a1[1] + 64) = v6;
      a1[2] = &v4[v6];
      v7 = 11;
    }
  }
  *a2 = v7;
  return 0xFFFFLL;
}

_QWORD *sub_18BC1EF28(_QWORD *result, int *a2)
{
  _WORD *v2;
  unint64_t v3;
  unint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unsigned int v10;
  int v12;
  int v13;
  _WORD *v15;
  __int16 v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;

  v3 = result[3];
  v2 = (_WORD *)result[4];
  v4 = result[5];
  v6 = result[1];
  v5 = (unsigned __int8 *)result[2];
  v7 = v6 + 65;
  if (*(char *)(v6 + 64) < 1 || (unint64_t)v2 >= v4)
    goto LABEL_6;
  LODWORD(v9) = *(unsigned __int8 *)(v6 + 64);
  *(_BYTE *)(v6 + 64) = 0;
  v10 = *(_DWORD *)(v6 + 72) - 1;
  *(_DWORD *)(v6 + 72) = 0;
  while (v9 > 3)
  {
LABEL_14:
    if (HIWORD(v10) > 0x10u || (v10 & 0xFFFFF800) == 55296)
    {
      *(_BYTE *)(result[1] + 64) = v9;
      *a2 = 12;
      goto LABEL_23;
    }
    if (HIWORD(v10))
    {
      *v2 = (v10 >> 10) - 10304;
      v15 = v2 + 1;
      v16 = v10 & 0x3FF | 0xDC00;
      if ((unint64_t)(v2 + 1) >= v4)
      {
        v19 = result[1];
        *(_WORD *)(v19 + 144) = v16;
        *(_BYTE *)(v19 + 93) = 1;
        *a2 = 15;
        v2 = v15;
        goto LABEL_23;
      }
      v2[1] = v16;
      v2 += 2;
    }
    else
    {
      *v2++ = v10;
    }
LABEL_6:
    v10 = 0;
    LODWORD(v9) = 0;
    if ((unint64_t)v5 >= v3 || (unint64_t)v2 >= v4)
      goto LABEL_23;
  }
  v12 = 8 * v9;
  v9 = v9;
  while ((unint64_t)v5 < v3)
  {
    v13 = *v5++;
    v10 |= v13 << v12;
    *(_BYTE *)(v7 + v9) = v13;
    v12 += 8;
    if (++v9 == 4)
      goto LABEL_14;
  }
  v17 = v10 + 1;
  v18 = result[1];
  *(_DWORD *)(v18 + 72) = v17;
  *(_BYTE *)(v18 + 64) = v9;
LABEL_23:
  if ((unint64_t)v5 < v3 && (unint64_t)v2 >= v4 && *a2 <= 0)
    *a2 = 15;
  result[4] = v2;
  result[2] = v5;
  return result;
}

_QWORD *sub_18BC1F074(_QWORD *result, int *a2)
{
  _WORD *v2;
  unint64_t v3;
  _DWORD *v4;
  unint64_t v5;
  unsigned __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v11;
  unsigned int v12;
  int v14;
  int v15;
  uint64_t v17;
  _DWORD *v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v3 = result[3];
  v2 = (_WORD *)result[4];
  v5 = result[5];
  v4 = (_DWORD *)result[6];
  v7 = result[1];
  v6 = (unsigned __int8 *)result[2];
  v8 = v7 + 65;
  v9 = 0;
  if (*(char *)(v7 + 64) < 1 || (unint64_t)v2 >= v5)
    goto LABEL_6;
  LODWORD(v11) = *(unsigned __int8 *)(v7 + 64);
  *(_BYTE *)(v7 + 64) = 0;
  v12 = *(_DWORD *)(v7 + 72) - 1;
  *(_DWORD *)(v7 + 72) = 0;
  while (v11 > 3)
  {
LABEL_14:
    if (HIWORD(v12) > 0x10u || (v12 & 0xFFFFF800) == 55296)
    {
      *(_BYTE *)(result[1] + 64) = v11;
      *a2 = 12;
      goto LABEL_24;
    }
    if (HIWORD(v12))
    {
      *v2 = (v12 >> 10) - 10304;
      *v4 = v9;
      v18 = v4 + 1;
      v19 = v12 & 0x3FF | 0xDC00;
      if ((unint64_t)(v2 + 1) >= v5)
      {
        v21 = result[1];
        *(_WORD *)(v21 + 144) = v19;
        *(_BYTE *)(v21 + 93) = 1;
        *a2 = 15;
        ++v2;
        v4 = v18;
        goto LABEL_24;
      }
      v2[1] = v19;
      v2 += 2;
      v17 = 2;
    }
    else
    {
      *v2++ = v12;
      v17 = 1;
      v18 = v4;
    }
    v4 += v17;
    *v18 = v9;
    v9 += v11;
LABEL_6:
    v12 = 0;
    LODWORD(v11) = 0;
    if ((unint64_t)v6 >= v3 || (unint64_t)v2 >= v5)
      goto LABEL_24;
  }
  v14 = 8 * v11;
  v11 = v11;
  while ((unint64_t)v6 < v3)
  {
    v15 = *v6++;
    v12 |= v15 << v14;
    *(_BYTE *)(v8 + v11) = v15;
    v14 += 8;
    if (++v11 == 4)
      goto LABEL_14;
  }
  v20 = result[1];
  *(_DWORD *)(v20 + 72) = v12 + 1;
  *(_BYTE *)(v20 + 64) = v11;
LABEL_24:
  if ((unint64_t)v6 < v3 && (unint64_t)v2 >= v5 && *a2 <= 0)
    *a2 = 15;
  result[4] = v2;
  result[2] = v6;
  result[6] = v4;
  return result;
}

uint64_t sub_18BC1F1EC(uint64_t result, int *a2)
{
  unsigned __int16 *v2;
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  int v8;
  int v10;
  int v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  int v16;

  v2 = *(unsigned __int16 **)(result + 16);
  v3 = *(_QWORD *)(result + 24);
  if ((unint64_t)v2 >= v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 40);
  result = *(_QWORD *)(result + 8);
  if (*(_DWORD *)(result + 80) == 1)
  {
    sub_18BC17544(result, byte_18BE13C34, 4, (_QWORD *)(v5 + 32), v6, (_QWORD *)(v5 + 48), -1, a2);
    result = *(_QWORD *)(v5 + 8);
    *(_DWORD *)(result + 80) = 0;
  }
  v16 = 0;
  v7 = *(_BYTE **)(v5 + 32);
  v8 = *(_DWORD *)(result + 84);
  if (!v8)
    goto LABEL_6;
  *(_DWORD *)(result + 84) = 0;
LABEL_12:
  if ((unint64_t)v2 >= v3)
  {
    *(_DWORD *)(*(_QWORD *)(v5 + 8) + 84) = v8;
    if (!*(_BYTE *)(v5 + 2))
      goto LABEL_24;
  }
  else
  {
    v11 = *v2;
    if ((v11 & 0xFC00) == 0xDC00)
    {
      v8 = v11 + (v8 << 10) - 56613888;
      ++v2;
      while (1)
      {
        v12 = 0;
        BYTE2(v16) = BYTE2(v8) & 0x1F;
        LOWORD(v16) = v8;
        do
        {
          v13 = *((_BYTE *)&v16 + v12);
          if ((unint64_t)v7 >= v6)
          {
            v14 = *(_QWORD *)(v5 + 8);
            v15 = *(char *)(v14 + 91);
            *(_BYTE *)(v14 + 91) = v15 + 1;
            *(_BYTE *)(v14 + v15 + 104) = v13;
            *a2 = 15;
          }
          else
          {
            *v7++ = v13;
          }
          ++v12;
        }
        while (v12 != 4);
LABEL_6:
        if ((unint64_t)v2 >= v3 || (unint64_t)v7 >= v6)
          goto LABEL_24;
        v10 = *v2++;
        v8 = v10;
        if ((v10 & 0xF800) == 0xD800)
        {
          if ((v8 & 0xFC00) != 0xD800)
            break;
          goto LABEL_12;
        }
      }
    }
    *(_DWORD *)(*(_QWORD *)(v5 + 8) + 84) = v8;
  }
  *a2 = 12;
LABEL_24:
  if ((unint64_t)v2 < v3 && (unint64_t)v7 >= v6 && *a2 <= 0)
    *a2 = 15;
  *(_QWORD *)(v5 + 32) = v7;
  *(_QWORD *)(v5 + 16) = v2;
  return result;
}

uint64_t sub_18BC1F394(uint64_t result, int *a2)
{
  unsigned __int16 *v2;
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  _DWORD *v8;
  int v9;
  int v10;
  int v12;
  int v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  int v18;

  v2 = *(unsigned __int16 **)(result + 16);
  v3 = *(_QWORD *)(result + 24);
  if ((unint64_t)v2 >= v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 40);
  result = *(_QWORD *)(result + 8);
  if (*(_DWORD *)(result + 80) == 1)
  {
    sub_18BC17544(result, byte_18BE13C38, 4, (_QWORD *)(v5 + 32), v6, (_QWORD *)(v5 + 48), -1, a2);
    result = *(_QWORD *)(v5 + 8);
    *(_DWORD *)(result + 80) = 0;
  }
  v18 = 0;
  v7 = *(_BYTE **)(v5 + 32);
  v8 = *(_DWORD **)(v5 + 48);
  v9 = *(_DWORD *)(result + 84);
  if (!v9)
  {
    v10 = 0;
    goto LABEL_7;
  }
  v10 = 0;
  *(_DWORD *)(result + 84) = 0;
LABEL_13:
  if ((unint64_t)v2 >= v3)
  {
    *(_DWORD *)(*(_QWORD *)(v5 + 8) + 84) = v9;
    if (!*(_BYTE *)(v5 + 2))
      goto LABEL_27;
  }
  else
  {
    v13 = *v2;
    if ((v13 & 0xFC00) == 0xDC00)
    {
      v9 = v13 + (v9 << 10) - 56613888;
      ++v2;
      while (1)
      {
        v14 = 0;
        BYTE2(v18) = BYTE2(v9) & 0x1F;
        LOWORD(v18) = v9;
        do
        {
          v15 = *((_BYTE *)&v18 + v14);
          if ((unint64_t)v7 >= v6)
          {
            v16 = *(_QWORD *)(v5 + 8);
            v17 = *(char *)(v16 + 91);
            *(_BYTE *)(v16 + 91) = v17 + 1;
            *(_BYTE *)(v16 + v17 + 104) = v15;
            *a2 = 15;
          }
          else
          {
            *v7++ = v15;
            *v8++ = v10;
          }
          ++v14;
        }
        while (v14 != 4);
        if (BYTE2(v18))
          ++v10;
        ++v10;
LABEL_7:
        if ((unint64_t)v2 >= v3 || (unint64_t)v7 >= v6)
          goto LABEL_27;
        v12 = *v2++;
        v9 = v12;
        if ((v12 & 0xF800) == 0xD800)
        {
          if ((v9 & 0xFC00) != 0xD800)
            break;
          goto LABEL_13;
        }
      }
    }
    *(_DWORD *)(*(_QWORD *)(v5 + 8) + 84) = v9;
  }
  *a2 = 12;
LABEL_27:
  if ((unint64_t)v2 < v3 && (unint64_t)v7 >= v6 && *a2 <= 0)
    *a2 = 15;
  *(_QWORD *)(v5 + 32) = v7;
  *(_QWORD *)(v5 + 16) = v2;
  *(_QWORD *)(v5 + 48) = v8;
  return result;
}

uint64_t sub_18BC1F560(_QWORD *a1, int *a2)
{
  unint64_t v3;
  unsigned __int8 *v4;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;

  v4 = (unsigned __int8 *)a1[2];
  v3 = a1[3];
  if ((unint64_t)v4 >= v3)
  {
    v7 = 8;
  }
  else
  {
    v6 = v3 - (_DWORD)v4;
    if ((int)v3 - (int)v4 > 3)
    {
      v8 = (v4[3] << 24) | (v4[2] << 16);
      v9 = v8 | (v4[1] << 8);
      v10 = *v4;
      a1[2] = v4 + 4;
      if (HIWORD(v8) <= 0x10u && (v9 & 0xFFFFF800) != 55296)
        return v9 | v10;
      *(_DWORD *)(a1[1] + 65) = *(_DWORD *)v4;
      *(_BYTE *)(a1[1] + 64) = 4;
      v7 = 12;
    }
    else
    {
      memcpy((void *)(a1[1] + 65), v4, v6);
      *(_BYTE *)(a1[1] + 64) = v6;
      a1[2] = &v4[v6];
      v7 = 11;
    }
  }
  *a2 = v7;
  return 0xFFFFLL;
}

double sub_18BC1F63C(uint64_t a1)
{
  double result;

  *(_QWORD *)&result = 0x100000000;
  *(_QWORD *)(a1 + 76) = 0x100000000;
  return result;
}

uint64_t sub_18BC1F64C(uint64_t result, int a2)
{
  if (a2 > 1 || (*(_DWORD *)(result + 76) = 0, a2 != 1))
    *(_DWORD *)(result + 80) = 1;
  return result;
}

_QWORD *sub_18BC1F668(_QWORD *result, int *a2)
{
  _QWORD *v3;
  int v4;
  _BYTE *v5;
  uint64_t v6;
  _BYTE *v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  int v12;
  int v13;
  uint64_t v14;
  char v15;
  char *v16;
  unint64_t v17;
  char *v19;

  v3 = result;
  v4 = 0;
  v6 = result[1];
  v5 = (_BYTE *)result[2];
  v7 = (_BYTE *)result[3];
  v8 = (_DWORD *)result[6];
  v9 = *(unsigned int *)(v6 + 76);
LABEL_2:
  v10 = v9;
  while (1)
  {
    if (v5 >= v7)
      goto LABEL_32;
    if (*a2 > 0)
      break;
    if ((_DWORD)v10)
    {
      v9 = v10;
      if (v10 > 9)
        goto LABEL_2;
      if (((1 << v10) & 0xEE) != 0)
      {
        if (*v5 == *((_BYTE *)&unk_18BE13C3C + v10))
        {
          ++v5;
          if ((_DWORD)v10 == 3)
          {
            v9 = 8;
          }
          else
          {
            v9 = (v10 + 1);
            if ((_DWORD)v10 != 7)
              goto LABEL_2;
            v9 = 9;
          }
          v4 = (_DWORD)v5 - *((_DWORD *)v3 + 4);
        }
        else
        {
          v11 = (_BYTE *)v3[2];
          v12 = (_DWORD)v5 - (_DWORD)v11;
          v9 = 8u;
          v5 = v11;
          v13 = (v10 & 3) - v12;
          if (v13)
          {
            v14 = v6;
            v15 = *((_BYTE *)v3 + 2);
            v16 = (char *)&unk_18BE13C3C + (v10 & 4);
            v3[2] = v16;
            v3[3] = &v16[v13];
            *((_BYTE *)v3 + 2) = 0;
            result = sub_18BC1E82C(v3, a2);
            v3[3] = v7;
            *((_BYTE *)v3 + 2) = v15;
            v6 = v14;
            v9 = 8;
            v5 = v11;
          }
        }
      }
      else if ((_DWORD)v10 == 8)
      {
        v3[2] = v5;
        if (v8)
          result = sub_18BC1E96C(v3, a2);
        else
          result = sub_18BC1E82C(v3, a2);
        v5 = (_BYTE *)v3[2];
        v9 = 8;
      }
      else
      {
        v9 = v10;
        if ((_DWORD)v10 == 9)
        {
          v3[2] = v5;
          if (v8)
            result = sub_18BC1F074(v3, a2);
          else
            result = sub_18BC1EF28(v3, a2);
          v5 = (_BYTE *)v3[2];
          v9 = 9u;
        }
      }
      goto LABEL_2;
    }
    if (*v5 == 255)
    {
      v9 = 5u;
      goto LABEL_24;
    }
    v10 = 8;
    if (!*v5)
    {
      v9 = 1u;
LABEL_24:
      ++v5;
      goto LABEL_2;
    }
  }
  LODWORD(v9) = v10;
LABEL_32:
  if (v8 && v4)
  {
    v17 = v3[6];
    while ((unint64_t)v8 < v17)
      *v8++ += v4;
  }
  v3[2] = v5;
  if (v5 == v7 && *((_BYTE *)v3 + 2) && (_DWORD)v9 != 0)
  {
    if ((_DWORD)v9 == 9)
    {
      result = sub_18BC1EF28(v3, a2);
      LODWORD(v9) = 9;
    }
    else
    {
      if ((_DWORD)v9 == 8)
      {
        result = sub_18BC1E82C(v3, a2);
      }
      else
      {
        v19 = (char *)&unk_18BE13C3C + (v9 & 4);
        v3[2] = v19;
        v3[3] = &v19[v9 & 3];
        result = sub_18BC1E82C(v3, a2);
        v3[2] = v7;
        v3[3] = v7;
      }
      LODWORD(v9) = 8;
    }
  }
  *(_DWORD *)(v6 + 76) = v9;
  return result;
}

uint64_t sub_18BC1F8D0(_QWORD *a1, int *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1[1] + 76);
  if (v2 == 9)
    return sub_18BC1F560(a1, a2);
  if (v2 == 8)
    return sub_18BC1EE4C(a1, a2);
  return 4294967287;
}

uint64_t sub_18BC1F8F8(uint64_t result, uint64_t a2, _DWORD *a3)
{
  unsigned int v3;

  v3 = *(_DWORD *)(result + 56) & 0xF;
  if (v3 > 1)
  {
    *a3 = 1;
  }
  else
  {
    *(_DWORD *)(result + 72) = 0x1000000;
    *(_BYTE *)(result + 64) = 0;
    *(_DWORD *)(result + 80) = (v3 << 28) | 0x1000000;
  }
  return result;
}

uint64_t sub_18BC1F92C(uint64_t result, int a2)
{
  if (a2 > 1 || (*(_DWORD *)(result + 72) = 0x1000000, *(_BYTE *)(result + 64) = 0, a2 != 1))
    *(_DWORD *)(result + 80) = *(_DWORD *)(result + 80) & 0xF0000000 | 0x1000000;
  return result;
}

uint64_t sub_18BC1F95C(uint64_t result, int *a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  _WORD *v4;
  unsigned __int8 *v5;
  _DWORD *v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  _BYTE *v10;
  unsigned __int8 v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unsigned __int8 *v16;
  unsigned int v17;
  int v20;
  int64_t v21;
  unint64_t v22;
  int v23;
  unsigned __int8 v24;
  int v25;
  BOOL v26;
  unsigned __int8 v27;

  v2 = *(_QWORD *)(result + 8);
  v3 = *(unsigned __int8 **)(result + 16);
  v5 = *(unsigned __int8 **)(result + 24);
  v4 = *(_WORD **)(result + 32);
  v7 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD **)(result + 48);
  v8 = *(_DWORD *)(v2 + 72);
  v9 = HIWORD(v8);
  v10 = (_BYTE *)(v2 + 65);
  v11 = *(_BYTE *)(v2 + 64);
  if (v11)
    v12 = -1;
  else
    v12 = 0;
  if ((v8 & 0x1000000) != 0)
  {
    v13 = v12;
LABEL_7:
    v14 = (_DWORD)v5 - (_DWORD)v3;
    if ((int)v5 - (int)v3 >= (int)((v7 - (unint64_t)v4) >> 1))
      v14 = (v7 - (unint64_t)v4) >> 1;
    if (v14 >= 1)
    {
      v15 = v14 + 1;
      v16 = v3 + 1;
      do
      {
        v3 = v16;
        v17 = *(v16 - 1);
        if (v17 - 32 >= 0x5E || v17 == 92)
        {
          if (v17 > 0xD || ((1 << v17) & 0x2600) == 0)
          {
            *v10 = v17;
            *a2 = 12;
            v11 = 1;
            goto LABEL_25;
          }
        }
        else if (v17 == 43)
        {
          v11 = 0;
          LOWORD(v8) = 0;
          v12 = v13 + 1;
          LOBYTE(v9) = -1;
          ++v13;
          goto LABEL_28;
        }
        *v4++ = v17;
        if (v6)
          *v6++ = v13++;
        --v15;
        v16 = v3 + 1;
      }
      while (v15 > 1);
    }
    v11 = 0;
LABEL_25:
    v20 = 0x1000000;
    if (v3 < v5 && (unint64_t)v4 >= v7)
    {
LABEL_38:
      v25 = 15;
LABEL_39:
      *a2 = v25;
    }
  }
  else
  {
    v13 = 0;
LABEL_28:
    if (v3 < v5)
    {
      v21 = v5 - v3;
      while (1)
      {
        if ((unint64_t)v4 >= v7)
        {
          v20 = 0;
          goto LABEL_38;
        }
        v22 = *v3;
        v10[v11] = v22;
        if (v22 > 0x7D)
          break;
        v23 = byte_18BE13D20[v22];
        v24 = byte_18BE13D20[v22];
        if ((~v23 & 0xFD) == 0)
          goto LABEL_51;
        if ((char)v23 < 0)
        {
          ++v13;
          ++v3;
          if ((_BYTE)v9 != 0xFF)
          {
            if (!(_WORD)v8)
            {
              LOWORD(v8) = 0;
              goto LABEL_7;
            }
            goto LABEL_62;
          }
          *v4++ = 43;
          LOBYTE(v9) = -1;
          if (v6)
          {
            *v6++ = v12 - 1;
            LOBYTE(v9) = -1;
          }
          goto LABEL_7;
        }
        if ((char)v9 != -1)
          JUMPOUT(0x18BC1FACCLL);
        LOBYTE(v9) = 1;
        ++v11;
        LOWORD(v8) = byte_18BE13D20[v22];
        ++v13;
        ++v3;
        if (!--v21)
        {
          v20 = 0;
          v3 = v5;
          goto LABEL_40;
        }
      }
      v24 = -3;
LABEL_51:
      if ((_BYTE)v9 == 0xFF)
      {
        *v10 = 43;
        v20 = 0x1000000;
        LOBYTE(v9) = -1;
        v11 = 1;
      }
      else
      {
        if (!(_WORD)v8)
        {
          LOWORD(v8) = 0;
          if (v24 != 253)
            goto LABEL_7;
          ++v3;
LABEL_62:
          v20 = 0x1000000;
          v25 = 12;
          ++v11;
          goto LABEL_39;
        }
        v20 = 0x1000000;
      }
      v25 = 12;
      goto LABEL_39;
    }
    v20 = 0;
  }
LABEL_40:
  if (*a2 <= 0)
  {
    if ((_WORD)v8)
      v26 = 0;
    else
      v26 = v3 == v5;
    if (v26)
      v27 = 0;
    else
      v27 = v11;
    if (*(_BYTE *)(result + 2))
      v11 = v27;
  }
  *(_DWORD *)(v2 + 72) = v20 | (v9 << 16) | (unsigned __int16)v8;
  *(_BYTE *)(v2 + 64) = v11;
  *(_QWORD *)(result + 16) = v3;
  *(_QWORD *)(result + 32) = v4;
  *(_QWORD *)(result + 48) = v6;
  return result;
}

uint64_t sub_18BC1FCA8(uint64_t result, _DWORD *a2)
{
  int v2;
  uint64_t v3;
  unsigned __int16 *v4;
  unint64_t v5;
  char *v6;
  _DWORD *v7;
  unint64_t v8;
  unsigned int v9;
  _BYTE *v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  unsigned __int16 *i;
  uint64_t v15;
  unsigned int v16;
  int v17;
  unsigned __int16 *v18;
  unint64_t v19;
  char *v20;
  int v21;
  BOOL v22;
  unsigned int v23;
  char v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;

  v2 = 0;
  v3 = *(_QWORD *)(result + 8);
  v4 = *(unsigned __int16 **)(result + 16);
  v5 = *(_QWORD *)(result + 24);
  v6 = *(char **)(result + 32);
  v8 = *(_QWORD *)(result + 40);
  v7 = *(_DWORD **)(result + 48);
  v9 = *(_DWORD *)(v3 + 80);
  v10 = &unk_18BE13E20;
  if (!(v9 >> 28))
    v10 = &unk_18BE13DA0;
  v11 = HIWORD(v9);
  if ((v9 & 0x1000000) != 0)
    goto LABEL_4;
  while (2)
  {
    v17 = 1;
    if ((unint64_t)v4 >= v5)
    {
      v21 = 0;
      goto LABEL_83;
    }
    while (1)
    {
      v18 = v4;
      if ((unint64_t)v6 >= v8)
      {
        v21 = 0;
        v17 = 1;
        goto LABEL_67;
      }
      ++v4;
      v19 = *v18;
      if (v19 <= 0x7F)
      {
        if (v10[v19])
          break;
      }
      if (v11 == 2)
      {
        *v6 = aAbcdefghijklmn[v9 | (v19 >> 12)];
        v20 = v6 + 1;
        if ((unint64_t)(v6 + 1) >= v8)
        {
          if (v7)
            *v7++ = v2++;
          LOBYTE(v9) = 0;
          LOBYTE(v11) = 0;
          *(_BYTE *)(v3 + 104) = aAbcdefghijklmn[(v19 >> 6) & 0x3F];
          *(_BYTE *)(v3 + 105) = aAbcdefghijklmn[v19 & 0x3F];
          *(_BYTE *)(v3 + 91) = 2;
        }
        else
        {
          v20 = v6 + 2;
          v6[1] = aAbcdefghijklmn[(v19 >> 6) & 0x3F];
          if ((unint64_t)(v6 + 2) < v8)
          {
            v6[2] = aAbcdefghijklmn[v19 & 0x3F];
            LOBYTE(v9) = 0;
            LOBYTE(v11) = 0;
            if (v7)
            {
              *v7 = v2;
              v7[1] = v2;
              v7[2] = v2++;
              v7 += 3;
            }
            v6 += 3;
            goto LABEL_64;
          }
          if (v7)
          {
            *v7 = v2;
            v7[1] = v2;
            v7 += 2;
            ++v2;
          }
          LOBYTE(v9) = 0;
          LOBYTE(v11) = 0;
          *(_BYTE *)(v3 + 104) = aAbcdefghijklmn[v19 & 0x3F];
          *(_BYTE *)(v3 + 91) = 1;
        }
        *a2 = 15;
        goto LABEL_63;
      }
      if ((char)v11 == 1)
      {
        *v6 = aAbcdefghijklmn[v9 | (v19 >> 14)];
        v20 = v6 + 1;
        if ((unint64_t)(v6 + 1) >= v8)
        {
          if (v7)
            *v7++ = v2++;
          *(_BYTE *)(v3 + 104) = aAbcdefghijklmn[(v19 >> 8) & 0x3F];
          *(_BYTE *)(v3 + 105) = aAbcdefghijklmn[v19 >> 2];
          *(_BYTE *)(v3 + 91) = 2;
        }
        else
        {
          v20 = v6 + 2;
          v6[1] = aAbcdefghijklmn[(v19 >> 8) & 0x3F];
          if ((unint64_t)(v6 + 2) < v8)
          {
            v20 = v6 + 3;
            v6[2] = aAbcdefghijklmn[v19 >> 2];
            if (v7)
            {
              *v7 = v2;
              v7[1] = v2;
              v7[2] = v2++;
              v7 += 3;
            }
LABEL_62:
            LOBYTE(v9) = 16 * (v19 & 3);
            LOBYTE(v11) = 2;
LABEL_63:
            v6 = v20;
            goto LABEL_64;
          }
          if (v7)
          {
            *v7 = v2;
            v7[1] = v2;
            v7 += 2;
            ++v2;
          }
          *(_BYTE *)(v3 + 104) = aAbcdefghijklmn[v19 >> 2];
          *(_BYTE *)(v3 + 91) = 1;
        }
        *a2 = 15;
        goto LABEL_62;
      }
      if (!(_BYTE)v11)
      {
        *v6 = aAbcdefghijklmn[v19 >> 10];
        v20 = v6 + 1;
        if ((unint64_t)(v6 + 1) >= v8)
        {
          if (v7)
            *v7++ = v2++;
          *(_BYTE *)(v3 + 104) = aAbcdefghijklmn[(v19 >> 4) & 0x3F];
          *(_BYTE *)(v3 + 91) = 1;
          *a2 = 15;
        }
        else
        {
          v20 = v6 + 2;
          v6[1] = aAbcdefghijklmn[(v19 >> 4) & 0x3F];
          if (v7)
          {
            *v7 = v2;
            v7[1] = v2;
            v7 += 2;
            ++v2;
          }
        }
        LOBYTE(v9) = 4 * (v19 & 0xF);
        LOBYTE(v11) = 1;
        goto LABEL_63;
      }
LABEL_64:
      if ((unint64_t)v4 >= v5)
      {
        v21 = 0;
        v17 = 1;
        goto LABEL_83;
      }
    }
    if ((_BYTE)v11)
    {
      *v6++ = aAbcdefghijklmn[v9];
      if (v7)
        *v7++ = v2 - 1;
    }
    if (byte_18BE13D20[v19] != 255)
    {
      if ((unint64_t)v6 < v8)
      {
        *v6++ = 45;
        if (v7)
          *v7++ = v2 - 1;
        goto LABEL_76;
      }
      v17 = 0;
      *(_BYTE *)(v3 + 104) = 45;
      *(_BYTE *)(v3 + 91) = 1;
      v21 = 0x1000000;
LABEL_67:
      v4 = v18;
      goto LABEL_82;
    }
LABEL_76:
    v4 = v18;
LABEL_4:
    if ((int)((v5 - (unint64_t)v4) >> 1) >= (int)v8 - (int)v6)
      LODWORD(v12) = v8 - (_DWORD)v6;
    else
      LODWORD(v12) = (v5 - (unint64_t)v4) >> 1;
    if ((int)v12 >= 1)
    {
      v13 = v5 - (_QWORD)v4 - 2;
      for (i = v4; ; v4 = i)
      {
        v16 = *i++;
        v15 = v16;
        if (v16 > 0x7F)
          break;
        if (v10[v15])
        {
          *v6++ = v15;
          if (v7)
            *v7++ = v2++;
          if ((int)v12 < 2)
            goto LABEL_68;
          LODWORD(v12) = v12 - 1;
        }
        else
        {
          if ((_DWORD)v15 != 43)
            break;
          *v6 = 43;
          if ((unint64_t)(v6 + 1) >= v8)
          {
            ++v4;
            if (v7)
              *v7++ = v2++;
            *(_BYTE *)(v3 + 104) = 45;
            *(_BYTE *)(v3 + 91) = 1;
            *a2 = 15;
            ++v6;
            goto LABEL_80;
          }
          v6[1] = 45;
          if (v7)
          {
            *v7 = v2;
            v7[1] = v2;
            v7 += 2;
            ++v2;
          }
          v6 += 2;
          v12 = v13 >> 1;
          if ((int)(v13 >> 1) >= (int)v8 - (int)v6)
            LODWORD(v12) = v8 - (_DWORD)v6;
          if ((int)v12 <= 0)
          {
LABEL_68:
            ++v4;
            goto LABEL_80;
          }
        }
        v13 -= 2;
      }
      *v6++ = 43;
      LOBYTE(v11) = 0;
      if (v7)
        *v7++ = v2;
      continue;
    }
    break;
  }
LABEL_80:
  v17 = 0;
  v21 = 0x1000000;
  if ((unint64_t)v4 < v5 && (unint64_t)v6 >= v8)
LABEL_82:
    *a2 = 15;
LABEL_83:
  if (*(_BYTE *)(result + 2))
    v22 = (unint64_t)v4 >= v5;
  else
    v22 = 0;
  if (v22)
  {
    if (!v17)
      goto LABEL_103;
    if ((_BYTE)v11)
    {
      v24 = aAbcdefghijklmn[v9];
      if ((unint64_t)v6 < v8)
      {
        *v6 = v24;
        v25 = v6 + 1;
        if (v7)
        {
          *v7++ = v2 - 1;
          goto LABEL_95;
        }
        if ((unint64_t)v25 >= v8)
        {
          v7 = 0;
LABEL_102:
          v27 = *(char *)(v3 + 91);
          *(_BYTE *)(v3 + 91) = v27 + 1;
          *(_BYTE *)(v3 + v27 + 104) = 45;
          *a2 = 15;
          v6 = v25;
          goto LABEL_103;
        }
        v7 = 0;
        v6[1] = 45;
        v6 += 2;
LABEL_103:
        v23 = *(_DWORD *)(v3 + 80) & 0xF0000000 | 0x1000000;
        goto LABEL_104;
      }
      v26 = *(char *)(v3 + 91);
      *(_BYTE *)(v3 + 91) = v26 + 1;
      *(_BYTE *)(v3 + v26 + 104) = v24;
      *a2 = 15;
    }
    v25 = v6;
LABEL_95:
    if ((unint64_t)v25 < v8)
    {
      *v25 = 45;
      v6 = v25 + 1;
      if (v7)
        *v7++ = v2 - 1;
      goto LABEL_103;
    }
    goto LABEL_102;
  }
  v23 = v21 | v9 | ((char)v11 << 16) | *(_DWORD *)(v3 + 80) & 0xF0000000;
LABEL_104:
  *(_DWORD *)(v3 + 80) = v23;
  *(_QWORD *)(result + 16) = v4;
  *(_QWORD *)(result + 32) = v6;
  *(_QWORD *)(result + 48) = v7;
  return result;
}

const char *sub_18BC201F4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 80) >> 28 == 1)
    return "UTF-7,version=1";
  else
    return "UTF-7";
}

uint64_t sub_18BC20218(uint64_t result, int *a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  _WORD *v4;
  unsigned __int8 *v5;
  int *v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  _BYTE *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned __int8 *v17;
  int v18;
  char v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;

  v2 = *(_QWORD *)(result + 8);
  v3 = *(unsigned __int8 **)(result + 16);
  v5 = *(unsigned __int8 **)(result + 24);
  v4 = *(_WORD **)(result + 32);
  v7 = *(_QWORD *)(result + 40);
  v6 = *(int **)(result + 48);
  v8 = *(_DWORD *)(v2 + 72);
  v9 = HIWORD(v8);
  v10 = (_BYTE *)(v2 + 65);
  v11 = *(unsigned __int8 *)(v2 + 64);
  if (*(_BYTE *)(v2 + 64))
    v12 = -1;
  else
    v12 = 0;
  if ((v8 & 0x1000000) != 0)
  {
    v14 = v12;
    goto LABEL_7;
  }
  v13 = 0;
LABEL_22:
  if (v3 < v5)
  {
    v22 = v5 - v3;
    while (1)
    {
      if ((unint64_t)v4 >= v7)
      {
        *a2 = 15;
        goto LABEL_51;
      }
      v23 = *v3;
      v19 = v11 + 1;
      v10[v11] = v23;
      if (v23 > 0x7E)
        break;
      if ((_DWORD)v23 == 44)
      {
        v24 = 63;
      }
      else
      {
        if ((_DWORD)v23 == 47)
          goto LABEL_67;
        if ((char)byte_18BE13D20[v23] < 0)
        {
          if ((_DWORD)v23 == 45)
          {
            v14 = v13 + 1;
            ++v3;
            if ((_BYTE)v9 != 0xFF)
            {
              if (!(_WORD)v8 && v9 <= 6u && ((1 << v9) & 0x49) != 0)
              {
                LOWORD(v8) = 0;
                goto LABEL_7;
              }
              goto LABEL_69;
            }
            *v4++ = 38;
            LOBYTE(v9) = -1;
            if (v6)
            {
              *v6++ = v12 - 1;
              LOBYTE(v9) = -1;
            }
LABEL_7:
            v15 = (_DWORD)v5 - (_DWORD)v3;
            if ((int)v5 - (int)v3 >= (int)((v7 - (unint64_t)v4) >> 1))
              v15 = (v7 - (unint64_t)v4) >> 1;
            if (v15 >= 1)
            {
              v16 = v15 + 1;
              v17 = v3 + 1;
              while (1)
              {
                v3 = v17;
                v18 = *(v17 - 1);
                if ((v18 - 32) >= 0x5F)
                {
                  *v10 = v18;
                  *a2 = 12;
                  v19 = 1;
                  goto LABEL_18;
                }
                if (v18 == 38)
                  break;
                *v4++ = v18;
                if (v6)
                  *v6++ = v14++;
                --v16;
                v17 = v3 + 1;
                if (v16 <= 1)
                  goto LABEL_16;
              }
              v11 = 0;
              LOWORD(v8) = 0;
              v12 = v14 + 1;
              LOBYTE(v9) = -1;
              v13 = v14 + 1;
              goto LABEL_22;
            }
LABEL_16:
            v19 = 0;
LABEL_18:
            v20 = 0x1000000;
            if (v3 < v5 && (unint64_t)v4 >= v7)
            {
              v21 = 15;
              goto LABEL_72;
            }
            goto LABEL_73;
          }
LABEL_67:
          ++v3;
          if ((_BYTE)v9 == 0xFF)
          {
            *(_BYTE *)(v2 + 65) = 38;
            *(_BYTE *)(v2 + 66) = v23;
            v19 = 2;
          }
LABEL_69:
          v21 = 12;
          goto LABEL_72;
        }
        v24 = byte_18BE13D20[v23];
      }
      switch((char)v9)
      {
        case -1:
        case 0:
          LOBYTE(v9) = 1;
          ++v11;
          LOWORD(v8) = v24;
          break;
        case 1:
        case 3:
        case 4:
        case 6:
          LOWORD(v8) = v24 | ((_WORD)v8 << 6);
          LOBYTE(v9) = v9 + 1;
          goto LABEL_33;
        case 2:
          if ((unsigned __int16)((v24 >> 2) | (16 * v8)) - 32 < 0x5F)
            goto LABEL_49;
          *v4++ = (v24 >> 2) | (16 * v8);
          if (v6)
          {
            *v6++ = v12;
            v12 = v13;
          }
          *v10 = v23;
          LOWORD(v8) = v24 & 3;
          LOBYTE(v9) = 3;
          goto LABEL_43;
        case 5:
          if ((unsigned __int16)((v24 >> 4) | (4 * v8)) - 32 < 0x5F)
            goto LABEL_49;
          *v4++ = (v24 >> 4) | (4 * v8);
          if (v6)
          {
            *v6++ = v12;
            v12 = v13;
          }
          *v10 = v23;
          LOWORD(v8) = v24 & 0xF;
          LOBYTE(v9) = 6;
LABEL_43:
          v11 = 1;
          break;
        case 7:
          if ((unsigned __int16)(v24 | ((_WORD)v8 << 6)) - 32 < 0x5F)
            goto LABEL_49;
          *v4++ = v24 | ((_WORD)v8 << 6);
          v11 = 0;
          LOWORD(v8) = 0;
          LOBYTE(v9) = 0;
          if (v6)
          {
            *v6++ = v12;
            v12 = v13 + 1;
          }
          break;
        default:
LABEL_33:
          ++v11;
          break;
      }
      ++v13;
      ++v3;
      if (!--v22)
      {
        v3 = v5;
        goto LABEL_51;
      }
    }
LABEL_49:
    ++v3;
    goto LABEL_69;
  }
LABEL_51:
  if (*a2 <= 0 && v11 == 0)
  {
    LOBYTE(v11) = 0;
    if (*(_BYTE *)(result + 2) && v3 >= v5)
    {
      if ((_BYTE)v9 == 0xFF)
      {
        *v10 = 38;
        v19 = 1;
      }
      else
      {
        v19 = 0;
      }
      v21 = 11;
LABEL_72:
      *a2 = v21;
      v20 = 0x1000000;
LABEL_73:
      LOBYTE(v11) = v19;
    }
    else
    {
      v20 = 0;
    }
  }
  else
  {
    v20 = 0;
  }
  *(_DWORD *)(v2 + 72) = v20 | (v9 << 16) | (unsigned __int16)v8;
  *(_BYTE *)(v2 + 64) = v11;
  *(_QWORD *)(result + 16) = v3;
  *(_QWORD *)(result + 32) = v4;
  *(_QWORD *)(result + 48) = v6;
  return result;
}

uint64_t sub_18BC205B0(uint64_t result, _DWORD *a2)
{
  int v2;
  uint64_t v3;
  unsigned __int16 *v4;
  char *v5;
  unint64_t v6;
  unint64_t v7;
  _DWORD *v8;
  unsigned int v9;
  unsigned int v10;
  char *v11;
  _DWORD *v12;
  int v13;
  unsigned __int16 *v14;
  unint64_t v15;
  char v16;
  char v17;
  char v18;
  char *v19;
  uint64_t v20;
  char v21;
  char *v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  char v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  char v32;
  char v33;
  uint64_t v34;
  char v35;
  char v36;
  uint64_t v37;
  char v38;
  char v39;
  uint64_t v40;
  char v41;
  int v42;
  int v43;
  char v44;
  int v45;
  unint64_t v46;
  unsigned __int16 *v47;
  int v48;
  int v49;
  BOOL v50;
  BOOL v51;
  unsigned int v52;
  char v53;
  char v54;
  uint64_t v55;
  uint64_t v56;

  v2 = 0;
  v3 = *(_QWORD *)(result + 8);
  v4 = *(unsigned __int16 **)(result + 16);
  v6 = *(_QWORD *)(result + 24);
  v5 = *(char **)(result + 32);
  v7 = *(_QWORD *)(result + 40);
  v8 = *(_DWORD **)(result + 48);
  v9 = *(_DWORD *)(v3 + 80);
  v10 = HIWORD(v9);
  v11 = v5;
  v12 = v8;
  if ((v9 & 0x1000000) != 0)
    goto LABEL_100;
  while (2)
  {
    v13 = 1;
    if ((unint64_t)v4 >= v6)
    {
      v42 = 0;
      goto LABEL_131;
    }
    v14 = v4;
    while (1)
    {
      v4 = v14;
      if ((unint64_t)v11 >= v7)
      {
        v42 = 0;
        v43 = 1;
        goto LABEL_130;
      }
      ++v14;
      v15 = *v4;
      if ((unsigned __int16)(v15 - 32) <= 0x5Eu)
        break;
      if (v10 == 2)
      {
        if ((v9 | (v15 >> 12)) > 0x3Eu)
          v17 = 44;
        else
          v17 = aAbcdefghijklmn[(v9 | (v15 >> 12))];
        *v11 = v17;
        v22 = v11 + 1;
        if ((unint64_t)(v11 + 1) >= v7)
        {
          if (v12)
            *v12++ = v2++;
          v29 = (v15 >> 6) & 0x3F;
          if ((_DWORD)v29 == 63)
            v30 = 44;
          else
            v30 = aAbcdefghijklmn[v29];
          *(_BYTE *)(v3 + 104) = v30;
          if ((v15 & 0x3F) == 0x3F)
            v36 = 44;
          else
            v36 = aAbcdefghijklmn[v15 & 0x3F];
          LOBYTE(v9) = 0;
          LOBYTE(v10) = 0;
          *(_BYTE *)(v3 + 105) = v36;
          *(_BYTE *)(v3 + 91) = 2;
        }
        else
        {
          v23 = (v15 >> 6) & 0x3F;
          if ((_DWORD)v23 == 63)
            v24 = 44;
          else
            v24 = aAbcdefghijklmn[v23];
          v22 = v11 + 2;
          v11[1] = v24;
          if ((unint64_t)(v11 + 2) < v7)
          {
            if ((v15 & 0x3F) == 0x3F)
              v33 = 44;
            else
              v33 = aAbcdefghijklmn[v15 & 0x3F];
            v19 = v11 + 3;
            v11[2] = v33;
            LOBYTE(v9) = 0;
            LOBYTE(v10) = 0;
            if (v12)
            {
              *v12 = v2;
              v12[1] = v2;
              v12[2] = v2++;
              v12 += 3;
            }
            goto LABEL_84;
          }
          if (v12)
          {
            *v12 = v2;
            v12[1] = v2;
            v12 += 2;
            ++v2;
          }
          if ((v15 & 0x3F) == 0x3F)
            v39 = 44;
          else
            v39 = aAbcdefghijklmn[v15 & 0x3F];
          LOBYTE(v9) = 0;
          LOBYTE(v10) = 0;
          *(_BYTE *)(v3 + 104) = v39;
          *(_BYTE *)(v3 + 91) = 1;
        }
        v11 = v22;
        *a2 = 15;
      }
      else
      {
        if ((char)v10 == 1)
        {
          if ((v9 | (v15 >> 14)) > 0x3Eu)
            v18 = 44;
          else
            v18 = aAbcdefghijklmn[(v9 | (v15 >> 14))];
          *v11 = v18;
          v19 = v11 + 1;
          if ((unint64_t)(v11 + 1) >= v7)
          {
            if (v12)
              *v12++ = v2++;
            v31 = (v15 >> 8) & 0x3F;
            if ((_DWORD)v31 == 63)
              v32 = 44;
            else
              v32 = aAbcdefghijklmn[v31];
            *(_BYTE *)(v3 + 104) = v32;
            v37 = v15 >> 2;
            if ((_DWORD)v37 == 63)
              v38 = 44;
            else
              v38 = aAbcdefghijklmn[v37];
            *(_BYTE *)(v3 + 105) = v38;
            *(_BYTE *)(v3 + 91) = 2;
          }
          else
          {
            v25 = (v15 >> 8) & 0x3F;
            if ((_DWORD)v25 == 63)
              v26 = 44;
            else
              v26 = aAbcdefghijklmn[v25];
            v19 = v11 + 2;
            v11[1] = v26;
            if ((unint64_t)(v11 + 2) < v7)
            {
              v34 = v15 >> 2;
              if ((_DWORD)v34 == 63)
                v35 = 44;
              else
                v35 = aAbcdefghijklmn[v34];
              v19 = v11 + 3;
              v11[2] = v35;
              if (v12)
              {
                *v12 = v2;
                v12[1] = v2;
                v12[2] = v2++;
                v12 += 3;
              }
              goto LABEL_83;
            }
            if (v12)
            {
              *v12 = v2;
              v12[1] = v2;
              v12 += 2;
              ++v2;
            }
            v40 = v15 >> 2;
            if ((_DWORD)v40 == 63)
              v41 = 44;
            else
              v41 = aAbcdefghijklmn[v40];
            *(_BYTE *)(v3 + 104) = v41;
            *(_BYTE *)(v3 + 91) = 1;
          }
          *a2 = 15;
LABEL_83:
          LOBYTE(v9) = 16 * (v15 & 3);
          LOBYTE(v10) = 2;
LABEL_84:
          v11 = v19;
          goto LABEL_85;
        }
        if (!(_BYTE)v10)
        {
          if ((v15 >> 10) == 63)
            v16 = 44;
          else
            v16 = aAbcdefghijklmn[v15 >> 10];
          *v11 = v16;
          v19 = v11 + 1;
          if ((unint64_t)(v11 + 1) >= v7)
          {
            if (v12)
              *v12++ = v2++;
            v27 = (v15 >> 4) & 0x3F;
            if ((_DWORD)v27 == 63)
              v28 = 44;
            else
              v28 = aAbcdefghijklmn[v27];
            *(_BYTE *)(v3 + 104) = v28;
            *(_BYTE *)(v3 + 91) = 1;
            *a2 = 15;
          }
          else
          {
            v20 = (v15 >> 4) & 0x3F;
            if ((_DWORD)v20 == 63)
              v21 = 44;
            else
              v21 = aAbcdefghijklmn[v20];
            v19 = v11 + 2;
            v11[1] = v21;
            if (v12)
            {
              *v12 = v2;
              v12[1] = v2;
              v12 += 2;
              ++v2;
            }
          }
          LOBYTE(v9) = 4 * (v15 & 0xF);
          LOBYTE(v10) = 1;
          goto LABEL_84;
        }
      }
LABEL_85:
      if ((unint64_t)v14 >= v6)
      {
        v42 = 0;
        v13 = 1;
        v4 = v14;
        goto LABEL_131;
      }
    }
    if (!(_BYTE)v10)
      goto LABEL_93;
    v44 = 44;
    if (v9 <= 0x3Eu)
      v44 = aAbcdefghijklmn[v9];
    *v11++ = v44;
    if (!v12)
    {
      if ((unint64_t)v11 < v7)
      {
        v8 = 0;
        *v11 = 45;
        goto LABEL_99;
      }
      v12 = 0;
      goto LABEL_161;
    }
    *v12++ = v2 - 1;
LABEL_93:
    if ((unint64_t)v11 >= v7)
    {
LABEL_161:
      v43 = 0;
      *(_BYTE *)(v3 + 104) = 45;
      *(_BYTE *)(v3 + 91) = 1;
      v42 = 0x1000000;
      goto LABEL_130;
    }
    *v11 = 45;
    if (v12)
    {
      *v12 = v2 - 1;
      v8 = v12 + 1;
    }
    else
    {
      v8 = 0;
    }
LABEL_99:
    v5 = v11 + 1;
LABEL_100:
    if ((int)((v6 - (unint64_t)v4) >> 1) >= (int)v7 - (int)v5)
      v45 = v7 - (_DWORD)v5;
    else
      v45 = (v6 - (unint64_t)v4) >> 1;
    if (v45 < 1)
    {
      v11 = v5;
      goto LABEL_125;
    }
    v46 = v6 - (_QWORD)v4 - 2;
    v47 = v4;
    while (2)
    {
      v49 = *v47++;
      v48 = v49;
      v11 = v5 + 1;
      if (v49 != 38 && (v48 - 32) <= 0x5E)
      {
        *v5 = v48;
        if (v8)
          *v8++ = v2++;
        if (v45 < 2)
          goto LABEL_119;
        --v45;
LABEL_118:
        v46 -= 2;
        v5 = v11;
        v4 = v47;
        continue;
      }
      break;
    }
    *v5 = 38;
    if (v48 != 38)
    {
      LOBYTE(v10) = 0;
      if (v8)
      {
        *v8 = v2;
        v12 = v8 + 1;
      }
      else
      {
        v12 = 0;
      }
      continue;
    }
    break;
  }
  if ((unint64_t)v11 < v7)
  {
    v5[1] = 45;
    if (v8)
    {
      *v8 = v2;
      v8[1] = v2;
      v8 += 2;
      ++v2;
    }
    v11 = v5 + 2;
    v45 = v7 - ((_DWORD)v5 + 2);
    if ((int)(v46 >> 1) < v45)
      v45 = v46 >> 1;
    if (v45 <= 0)
    {
LABEL_119:
      ++v4;
      goto LABEL_125;
    }
    goto LABEL_118;
  }
  ++v4;
  if (v8)
    *v8++ = v2++;
  *(_BYTE *)(v3 + 104) = 45;
  *(_BYTE *)(v3 + 91) = 1;
  *a2 = 15;
LABEL_125:
  v43 = 0;
  v13 = 0;
  v42 = 0x1000000;
  v50 = (unint64_t)v4 < v6 && (unint64_t)v11 >= v7;
  v12 = v8;
  if (v50)
  {
LABEL_130:
    *a2 = 15;
    v13 = v43;
  }
LABEL_131:
  if (*(_BYTE *)(result + 2))
    v51 = (unint64_t)v4 >= v6;
  else
    v51 = 0;
  if (v51)
  {
    if (v13)
    {
      if (!(_BYTE)v10)
        goto LABEL_149;
      if ((unint64_t)v11 >= v7)
      {
        if (v9 > 0x3Eu)
          v54 = 44;
        else
          v54 = aAbcdefghijklmn[v9];
        v55 = *(char *)(v3 + 91);
        *(_BYTE *)(v3 + 91) = v55 + 1;
        *(_BYTE *)(v3 + v55 + 104) = v54;
        *a2 = 15;
LABEL_149:
        if ((unint64_t)v11 < v7)
        {
          *v11++ = 45;
          if (v12)
            *v12++ = v2 - 1;
          goto LABEL_158;
        }
        goto LABEL_157;
      }
      if (v9 > 0x3Eu)
        v53 = 44;
      else
        v53 = aAbcdefghijklmn[v9];
      *v11 = v53;
      if (v12)
      {
        *v12++ = v2 - 1;
        ++v11;
        goto LABEL_149;
      }
      if ((unint64_t)(v11 + 1) >= v7)
      {
        v12 = 0;
        ++v11;
LABEL_157:
        v56 = *(char *)(v3 + 91);
        *(_BYTE *)(v3 + 91) = v56 + 1;
        *(_BYTE *)(v3 + v56 + 104) = 45;
        *a2 = 15;
        goto LABEL_158;
      }
      v12 = 0;
      v11[1] = 45;
      v11 += 2;
    }
LABEL_158:
    v52 = *(_DWORD *)(v3 + 80) & 0xF0000000 | 0x1000000;
    goto LABEL_159;
  }
  v52 = v42 | v9 | ((char)v10 << 16) | *(_DWORD *)(v3 + 80) & 0xF0000000;
LABEL_159:
  *(_DWORD *)(v3 + 80) = v52;
  *(_QWORD *)(result + 16) = v4;
  *(_QWORD *)(result + 32) = v11;
  *(_QWORD *)(result + 48) = v12;
  return result;
}

_QWORD *sub_18BC20C64(_QWORD *result, int *a2)
{
  unsigned __int16 *v2;
  uint64_t v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  void *v7;
  unsigned int v8;
  BOOL v9;
  unsigned int v10;
  char v11;
  int v13;
  char *v14;
  unsigned int v15;
  unsigned int v16;
  int *v17;
  unint64_t i;
  char v19;
  uint64_t v20;
  int v21;

  v3 = result[1];
  v2 = (unsigned __int16 *)result[2];
  v5 = result[3];
  v4 = (char *)result[4];
  v6 = result[5];
  v21 = 0;
  v7 = *(void **)(v3 + 48);
  v8 = *(_DWORD *)(v3 + 84);
  if (v8)
    v9 = (unint64_t)v4 >= v6;
  else
    v9 = 1;
  if (v9)
    goto LABEL_13;
  *(_DWORD *)(v3 + 84) = 0;
LABEL_23:
  if ((unint64_t)v2 >= v5)
  {
    *(_DWORD *)(v3 + 84) = v8;
  }
  else if ((v8 & 0x400) != 0 || (v13 = *v2, (v13 & 0xFC00) != 0xDC00))
  {
    *(_DWORD *)(v3 + 84) = v8;
    *a2 = 12;
  }
  else
  {
    v8 = v13 + (v8 << 10) - 56613888;
    ++v2;
LABEL_27:
    if ((uint64_t)(v6 - (_QWORD)v4) <= 3)
      v14 = (char *)&v21;
    else
      v14 = v4;
    if ((int)v8 >= 0x10000)
    {
      v15 = (v8 >> 18) | 0xFFFFFFF0;
      if ((uint64_t)(v6 - (_QWORD)v4) <= 3)
        v17 = &v21;
      else
        v17 = (int *)v4;
      *((_BYTE *)v17 + 1) = (v8 >> 12) & 0x3F | 0x80;
      v16 = 3;
    }
    else
    {
      v15 = (v8 >> 12) | 0xFFFFFFE0;
      v16 = 2;
    }
    *v14 = v15;
    v14[v16 - 1] = (v8 >> 6) & 0x3F | 0x80;
    v14[v16] = v8 & 0x3F | 0x80;
    if (v14 == v4)
    {
      v4 += v16 + 1;
    }
    else
    {
      for (i = (unint64_t)&v21 | v16; (unint64_t)v14 <= i; ++v14)
      {
        v19 = *v14;
        if ((unint64_t)v4 >= v6)
        {
          v20 = *(char *)(v3 + 91);
          *(_BYTE *)(v3 + 91) = v20 + 1;
          *(_BYTE *)(v3 + v20 + 104) = v19;
          *a2 = 15;
        }
        else
        {
          *v4++ = v19;
        }
      }
    }
LABEL_13:
    while ((unint64_t)v2 < v5 && (unint64_t)v4 < v6)
    {
      v10 = *v2++;
      v8 = v10;
      if (v10 > 0x7F)
      {
        if (v8 > 0x7FF)
        {
          if ((v8 & 0xF800) != 0xD800 || v7 == &unk_1E22503B8)
            goto LABEL_27;
          goto LABEL_23;
        }
        *v4 = (v8 >> 6) | 0xC0;
        v11 = v8 & 0x3F | 0x80;
        if ((unint64_t)(v4 + 1) >= v6)
        {
          *(_BYTE *)(v3 + 104) = v11;
          *(_BYTE *)(v3 + 91) = 1;
          *a2 = 15;
          ++v4;
        }
        else
        {
          v4[1] = v11;
          v4 += 2;
        }
      }
      else
      {
        *v4++ = v8;
      }
    }
  }
  if ((unint64_t)v2 < v5 && (unint64_t)v4 >= v6 && *a2 <= 0)
    *a2 = 15;
  result[4] = v4;
  result[2] = v2;
  return result;
}

_QWORD *sub_18BC20E70(_QWORD *result, int *a2)
{
  unsigned __int16 *v2;
  uint64_t v3;
  unint64_t v4;
  char *v5;
  unint64_t v6;
  int *v7;
  void *v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  int v12;
  unsigned int v13;
  int v15;
  char *v16;
  unsigned int v17;
  int *v18;
  unsigned int v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  int v23;

  v3 = result[1];
  v2 = (unsigned __int16 *)result[2];
  v4 = result[3];
  v5 = (char *)result[4];
  v6 = result[5];
  v7 = (int *)result[6];
  v23 = 0;
  v8 = *(void **)(v3 + 48);
  v9 = *(_DWORD *)(v3 + 84);
  if (v9)
    v10 = (unint64_t)v5 >= v6;
  else
    v10 = 1;
  if (v10)
  {
    v12 = 0;
    goto LABEL_7;
  }
  v11 = 0;
  *(_DWORD *)(v3 + 84) = 0;
  v12 = -1;
LABEL_19:
  if ((unint64_t)v2 >= v4)
  {
    *(_DWORD *)(v3 + 84) = v9;
  }
  else if ((v9 & 0x400) != 0 || (v15 = *v2, (v15 & 0xFC00) != 0xDC00))
  {
    *(_DWORD *)(v3 + 84) = v9;
    *a2 = 12;
  }
  else
  {
    v9 = v15 + (v9 << 10) - 56613888;
    ++v2;
    ++v11;
LABEL_23:
    if ((uint64_t)(v6 - (_QWORD)v5) <= 3)
      v16 = (char *)&v23;
    else
      v16 = v5;
    if ((int)v9 < 0x10000)
    {
      v17 = (v9 >> 12) | 0xFFFFFFE0;
      v19 = 2;
    }
    else
    {
      v17 = (v9 >> 18) | 0xFFFFFFF0;
      if ((uint64_t)(v6 - (_QWORD)v5) <= 3)
        v18 = &v23;
      else
        v18 = (int *)v5;
      *((_BYTE *)v18 + 1) = (v9 >> 12) & 0x3F | 0x80;
      v19 = 3;
    }
    *v16 = v17;
    v16[v19 - 1] = (v9 >> 6) & 0x3F | 0x80;
    v16[v19] = v9 & 0x3F | 0x80;
    if (v16 == v5)
    {
      v22 = v19 + 1;
      v5 += v22;
      *v7 = v12;
      v7[1] = v12;
      v7[2] = v12;
      if ((int)v9 >= 0x10000)
        v7[3] = v12;
      v7 += v22;
    }
    else
    {
      for (; (unint64_t)v16 <= ((unint64_t)&v23 | v19); ++v16)
      {
        if ((unint64_t)v5 >= v6)
        {
          v20 = *v16;
          v21 = *(char *)(v3 + 91);
          *(_BYTE *)(v3 + 91) = v21 + 1;
          *(_BYTE *)(v3 + v21 + 104) = v20;
          *a2 = 15;
        }
        else
        {
          *v7++ = v12;
          *v5++ = *v16;
        }
      }
    }
    v12 = v11;
LABEL_7:
    while ((unint64_t)v2 < v4 && (unint64_t)v5 < v6)
    {
      v13 = *v2++;
      v9 = v13;
      if (v13 > 0x7F)
      {
        if (v9 > 0x7FF)
        {
          v11 = v12 + 1;
          if ((v9 & 0xF800) != 0xD800 || v8 == &unk_1E22503B8)
            goto LABEL_23;
          goto LABEL_19;
        }
        *v7 = v12;
        *v5 = (v9 >> 6) | 0xC0;
        if ((unint64_t)(v5 + 1) >= v6)
        {
          *(_BYTE *)(v3 + 104) = v9 & 0x3F | 0x80;
          *(_BYTE *)(v3 + 91) = 1;
          *a2 = 15;
          ++v7;
          ++v5;
        }
        else
        {
          v7[1] = v12++;
          v7 += 2;
          v5[1] = v9 & 0x3F | 0x80;
          v5 += 2;
        }
      }
      else
      {
        *v7++ = v12++;
        *v5++ = v9;
      }
    }
  }
  if ((unint64_t)v2 < v4 && (unint64_t)v5 >= v6 && *a2 <= 0)
    *a2 = 15;
  result[4] = v5;
  result[2] = v2;
  result[6] = v7;
  return result;
}

_QWORD *sub_18BC210E4(_QWORD *result, int *a2)
{
  char *v2;
  uint64_t v3;
  _WORD *v4;
  unint64_t v5;
  unint64_t v6;
  void *v7;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  BOOL v22;
  unsigned int v23;
  __int16 v24;

  v3 = result[1];
  v2 = (char *)result[2];
  v5 = result[3];
  v4 = (_WORD *)result[4];
  v6 = result[5];
  v7 = *(void **)(v3 + 48);
  if (*(char *)(v3 + 64) < 1 || (unint64_t)v4 >= v6)
  {
    while (1)
    {
LABEL_7:
      if ((unint64_t)v2 >= v5 || (unint64_t)v4 >= v6)
        goto LABEL_36;
      v10 = *v2;
      if (*v2 < 0)
        break;
      *v4++ = v10;
      ++v2;
    }
    *(_BYTE *)(v3 + 65) = v10;
    ++v2;
    if (v10 <= 0xEF)
      v12 = 2;
    else
      v12 = 3;
    if (v10 > 0xDF)
      ++v12;
    v9 = 1;
    if ((v10 + 62) <= 0x32u)
      v11 = v12;
    else
      v11 = 0;
  }
  else
  {
    v9 = *(unsigned __int8 *)(v3 + 64);
    *(_BYTE *)(v3 + 64) = 0;
    v10 = *(_DWORD *)(v3 + 72);
    v11 = *(_DWORD *)(v3 + 76);
    *(_DWORD *)(v3 + 72) = 0;
  }
  if (v9 < v11)
  {
    v13 = 0;
    v14 = v9;
    v15 = v3 + v9 + 65;
    v16 = v9 - v11;
    while (1)
    {
      if ((unint64_t)&v2[v13] >= v5)
      {
        *(_DWORD *)(v3 + 72) = v10;
        *(_DWORD *)(v3 + 76) = v11;
        *(_BYTE *)(v3 + 64) = v14 + v13;
        v2 += v13;
        goto LABEL_36;
      }
      v17 = v14 + v13;
      v18 = v2[v13];
      *(_BYTE *)(v15 + v13) = v18;
      if (v11 < 3 || v17 >= 2)
      {
        if ((char)v18 < -64)
          goto LABEL_33;
      }
      else
      {
        if (v11 == 3)
        {
          v19 = a00000000000000[v10 & 0xF];
          v20 = 1 << (v18 >> 5);
        }
        else
        {
          v19 = byte_18BE13FBC[v18 >> 4];
          v20 = 1 << (v10 & 7);
        }
        if ((v19 & v20) != 0)
          goto LABEL_33;
      }
      if (v7 != &unk_1E22503B8 || v17 != 1 || v10 != 237 || (char)v18 > -65)
      {
        v9 = v14 + v13;
        v2 += v13;
        break;
      }
LABEL_33:
      v10 = v18 + (v10 << 6);
      if (!(v16 + (_DWORD)++v13))
      {
        v2 += v13;
        v9 = v11;
        break;
      }
    }
  }
  v22 = v7 == &unk_1E22503B8 && v9 > 3;
  if (v9 != v11 || v22)
  {
    *(_BYTE *)(v3 + 64) = v9;
    *a2 = 12;
  }
  else
  {
    v23 = v10 - dword_18BE13FA8[v11];
    if (!HIWORD(v23))
    {
      *v4++ = v23;
      goto LABEL_7;
    }
    *v4 = (v23 >> 10) - 10304;
    v24 = v23 & 0x3FF | 0xDC00;
    if ((unint64_t)(v4 + 1) < v6)
    {
      v4[1] = v24;
      v4 += 2;
      goto LABEL_7;
    }
    *(_WORD *)(v3 + 144) = v24;
    *(_BYTE *)(v3 + 93) = 1;
    *a2 = 15;
    ++v4;
  }
LABEL_36:
  if ((unint64_t)v2 < v5 && (unint64_t)v4 >= v6 && *a2 <= 0)
    *a2 = 15;
  result[4] = v4;
  result[2] = v2;
  return result;
}

_QWORD *sub_18BC21354(_QWORD *result, int *a2)
{
  char *v2;
  uint64_t v3;
  _WORD *v4;
  unint64_t v5;
  _DWORD *v6;
  unint64_t v7;
  void *v8;
  int v9;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  int v22;
  BOOL v24;
  unsigned int v25;
  __int16 v26;

  v3 = result[1];
  v2 = (char *)result[2];
  v5 = result[3];
  v4 = (_WORD *)result[4];
  v7 = result[5];
  v6 = (_DWORD *)result[6];
  v8 = *(void **)(v3 + 48);
  v9 = 0;
  if (*(char *)(v3 + 64) < 1 || (unint64_t)v4 >= v7)
    goto LABEL_6;
  v11 = *(unsigned __int8 *)(v3 + 64);
  *(_BYTE *)(v3 + 64) = 0;
  v13 = *(_DWORD *)(v3 + 72);
  v12 = *(_DWORD *)(v3 + 76);
  *(_DWORD *)(v3 + 72) = 0;
LABEL_18:
  if (v11 < v12)
  {
    v15 = 0;
    v16 = v11;
    v17 = v3 + v11 + 65;
    v18 = v11 - v12;
    while (1)
    {
      if ((unint64_t)&v2[v15] >= v5)
      {
        *(_DWORD *)(v3 + 72) = v13;
        *(_DWORD *)(v3 + 76) = v12;
        *(_BYTE *)(v3 + 64) = v16 + v15;
        v2 += v15;
        goto LABEL_36;
      }
      v19 = v16 + v15;
      v20 = v2[v15];
      *(_BYTE *)(v17 + v15) = v20;
      if (v12 < 3 || v19 >= 2)
      {
        if ((char)v20 < -64)
          goto LABEL_33;
      }
      else
      {
        if (v12 == 3)
        {
          v21 = a00000000000000[v13 & 0xF];
          v22 = 1 << (v20 >> 5);
        }
        else
        {
          v21 = byte_18BE13FBC[v20 >> 4];
          v22 = 1 << (v13 & 7);
        }
        if ((v21 & v22) != 0)
          goto LABEL_33;
      }
      if (v8 != &unk_1E22503B8 || v19 != 1 || v13 != 237 || (char)v20 > -65)
      {
        v11 = v16 + v15;
        v2 += v15;
        break;
      }
LABEL_33:
      v13 = v20 + (v13 << 6);
      if (!(v18 + (_DWORD)++v15))
      {
        v2 += v15;
        v11 = v12;
        break;
      }
    }
  }
  v24 = v8 == &unk_1E22503B8 && v11 > 3;
  if (v11 != v12 || v24)
  {
    *(_BYTE *)(v3 + 64) = v11;
    *a2 = 12;
  }
  else
  {
    v25 = v13 - dword_18BE13FA8[v12];
    if (HIWORD(v25))
    {
      *v4 = (v25 >> 10) - 10304;
      *v6 = v9;
      v26 = v25 & 0x3FF | 0xDC00;
      if ((unint64_t)(v4 + 1) >= v7)
      {
        *(_WORD *)(v3 + 144) = v26;
        *(_BYTE *)(v3 + 93) = 1;
        *a2 = 15;
        ++v4;
        ++v6;
      }
      else
      {
        v4[1] = v26;
        v4 += 2;
        v6[1] = v9;
        v6 += 2;
      }
    }
    else
    {
      *v4++ = v25;
      *v6++ = v9;
    }
    v9 += v12;
LABEL_6:
    while ((unint64_t)v2 < v5 && (unint64_t)v4 < v7)
    {
      v13 = *v2;
      if (*v2 < 0)
      {
        *(_BYTE *)(v3 + 65) = v13;
        ++v2;
        if (v13 <= 0xEF)
          v14 = 2;
        else
          v14 = 3;
        if (v13 > 0xDF)
          ++v14;
        v11 = 1;
        if ((v13 + 62) <= 0x32u)
          v12 = v14;
        else
          v12 = 0;
        goto LABEL_18;
      }
      *v4++ = v13;
      *v6++ = v9++;
      ++v2;
    }
  }
LABEL_36:
  if ((unint64_t)v2 < v5 && (unint64_t)v4 >= v7 && *a2 <= 0)
    *a2 = 15;
  result[4] = v4;
  result[2] = v2;
  result[6] = v6;
  return result;
}

uint64_t sub_18BC215FC(_QWORD *a1, int *a2)
{
  char *v2;
  unint64_t v3;
  char *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  char v8;
  int v9;
  int v10;
  char v11;
  unint64_t v12;
  unsigned __int8 v13;
  char v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unint64_t v21;
  int v22;
  int v23;
  char v24;
  char v25;

  v2 = (char *)a1[2];
  v3 = a1[3];
  if ((unint64_t)v2 >= v3)
  {
    v6 = 8;
LABEL_5:
    *a2 = v6;
    return 0xFFFFLL;
  }
  v4 = v2 + 1;
  v5 = *v2;
  if ((*v2 & 0x80000000) == 0)
  {
    a1[2] = v4;
    return v5;
  }
  v7 = a1[1];
  if ((v5 + 62) > 0x32u)
  {
    *(_BYTE *)(v7 + 65) = v5;
    *(_BYTE *)(v7 + 64) = 1;
    *a2 = 12;
    goto LABEL_41;
  }
  v8 = *v2;
  v9 = v5 > 0xEF;
  if (v5 > 0xDF)
    ++v9;
  if ((unint64_t)&v4[v9 + 1] <= v3)
  {
    v15 = (_DWORD)v5 << 6;
    if (v9)
    {
      if (v9 == 1)
      {
        v16 = *v4;
        if (((a00000000000000[v8 & 0xF] >> (*v4 >> 5)) & 1) != 0)
        {
          v4 = v2 + 2;
          v17 = v2[2];
          if (v17 <= -65)
          {
            a1[2] = v2 + 3;
            return v17 + ((v15 + v16) << 6) - 925824;
          }
        }
        goto LABEL_36;
      }
      v21 = *v4;
      if (((byte_18BE13FBC[v21 >> 4] >> (v5 & 7)) & 1) != 0)
      {
        v4 = v2 + 2;
        v22 = v2[2];
        if (v22 <= -65)
        {
          v4 = v2 + 3;
          v23 = v2[3];
          if (v23 <= -65)
          {
            a1[2] = v2 + 4;
            v19 = ((v15 + (_DWORD)v21) << 12) + (v22 << 6);
            v20 = v23 - 63447168;
            return (v19 + v20);
          }
        }
      }
    }
    else
    {
      v18 = *v4;
      if (v18 <= -65)
      {
        a1[2] = v2 + 2;
        v19 = v15 + v18;
        v20 = -12416;
        return (v19 + v20);
      }
    }
LABEL_36:
    v24 = 0;
    a1[2] = v4;
    do
    {
      v25 = *v2++;
      *(_BYTE *)(v7 + v24++ + 65) = v25;
    }
    while (v2 < v4);
    *(_BYTE *)(v7 + 64) = v24;
    v6 = 12;
    goto LABEL_5;
  }
  *(_BYTE *)(v7 + 65) = v5;
  *a2 = 11;
  if ((unint64_t)v4 >= a1[3])
  {
    v14 = 1;
    goto LABEL_40;
  }
  v10 = 1 << (v5 & 7);
  v11 = 1;
  while (1)
  {
    v12 = *v4;
    v13 = *v4;
    if (v9)
    {
      if (v11 < 2)
        break;
    }
    if ((char)v12 >= -64)
      goto LABEL_39;
LABEL_20:
    v14 = v11 + 1;
    *(_BYTE *)(v7 + v11 + 65) = v13;
    ++v4;
    ++v11;
    if ((unint64_t)v4 >= a1[3])
      goto LABEL_40;
  }
  if (v9 == 1)
  {
    if ((a00000000000000[v8 & 0xF] & (1 << (v13 >> 5))) == 0)
      goto LABEL_39;
    goto LABEL_20;
  }
  if ((byte_18BE13FBC[v12 >> 4] & v10) != 0)
    goto LABEL_20;
LABEL_39:
  *a2 = 12;
  v14 = v11;
LABEL_40:
  *(_BYTE *)(v7 + 64) = v14;
LABEL_41:
  a1[2] = v4;
  return 0xFFFFLL;
}

uint64_t sub_18BC2187C(uint64_t result, _QWORD *a2, int *a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  unsigned int v7;
  int v8;
  _BYTE *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned __int8 *v17;
  unint64_t v18;
  unsigned int v19;
  unint64_t v20;
  BOOL v21;
  unsigned __int8 *v22;
  char v23;
  char *v24;
  unsigned int v25;
  unsigned __int8 v26;
  char v27;
  int v28;
  int v29;
  unsigned int v30;
  unsigned __int8 v31;
  int v32;
  int v33;
  BOOL v34;
  unsigned int v36;
  unsigned __int8 v37;
  int v38;
  int v39;
  int v40;
  unsigned __int8 *v41;
  unint64_t v42;
  int v43;
  unsigned int v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  char *v48;
  char v49;
  int v50;
  char v51;
  _BYTE *v52;
  unint64_t v53;
  char v54;
  char v55;
  char v56;
  unint64_t v57;
  unsigned __int8 v58;
  int v59;
  char v60;
  int v61;
  char v62;

  v3 = a2[1];
  v4 = (unsigned __int8 *)a2[2];
  v5 = (unsigned __int8 *)a2[3];
  v6 = *(char *)(v3 + 64);
  if (v6 < 1)
  {
    v6 = 0;
    LOBYTE(v8) = 0;
    v7 = 0;
  }
  else
  {
    v7 = *(_DWORD *)(v3 + 72);
    v8 = *(_DWORD *)(v3 + 76);
  }
  v9 = *(_BYTE **)(result + 32);
  v10 = (_DWORD)v5 - (_DWORD)v4 + v6;
  if (v10 >= (char)v8)
  {
    v11 = *(_DWORD *)(result + 40) - (_DWORD)v9;
    if (v11 < (char)v8)
    {
      v12 = -127;
LABEL_33:
      *a3 = v12;
      return result;
    }
    if (v10 >= v11)
      v10 = *(_DWORD *)(result + 40) - (_DWORD)v9;
    v13 = v10 - v6;
    v14 = v13 - 1;
    if (v13 >= 1)
    {
      v15 = (char)v4[v14];
      if (v15 < 0)
      {
        v18 = v4[v14];
        if ((v15 + 62) < 0x33u)
          goto LABEL_12;
        v19 = v4[v14];
        if (v19 <= 0xBF)
        {
          v14 = v13 - 2;
          if (v13 < 2)
          {
            v14 = 1;
            goto LABEL_12;
          }
          v20 = v4[v14];
          if ((v20 + 32) <= 0x14u)
          {
            v21 = v20 > 0xEF;
            v22 = &byte_18BE13FBC[v18 >> 4];
            v23 = v20 & 7;
            v24 = &a00000000000000[v20 & 0xF];
            v25 = v19 >> 5;
            if (v21)
            {
              LOBYTE(v25) = v23;
              v24 = (char *)v22;
            }
            if (((*v24 >> v25) & 1) == 0)
              v14 = v13;
            goto LABEL_12;
          }
          if ((char)v20 <= -65)
          {
            if (v13 < 3)
            {
              v14 = 2;
            }
            else
            {
              v26 = v4[v13 - 3];
              v14 = v13;
              if ((v26 + 16) <= 4u)
              {
                if (((byte_18BE13FBC[v20 >> 4] >> (v26 & 7)) & 1) != 0)
                  v14 = v13 - 3;
                else
                  v14 = v13;
              }
            }
            goto LABEL_12;
          }
        }
      }
    }
    v14 = v13;
LABEL_12:
    v10 = v14 + v6;
  }
  if (v7)
  {
    *(_DWORD *)(v3 + 72) = 0;
    *(_BYTE *)(v3 + 64) = 0;
    v16 = v6;
    goto LABEL_63;
  }
  v17 = (unsigned __int8 *)a2[2];
  while (2)
  {
    if (v10 < 1)
    {
      v4 = v17;
LABEL_48:
      if (*a3 <= 0 && v4 < v5)
      {
        if (v9 == *(_BYTE **)(result + 40))
        {
          v38 = 15;
        }
        else
        {
          v36 = *v4;
          if ((char)*v4 < 0)
          {
            if (v36 <= 0xEF)
              v55 = 2;
            else
              v55 = 3;
            if (v36 > 0xDF)
              ++v55;
            if ((v36 + 62) <= 0x32u)
              v37 = v55;
            else
              v37 = 0;
          }
          else
          {
            v37 = 1;
          }
          if (v5 - v4 >= v37)
          {
            v38 = -127;
          }
          else
          {
            *(_BYTE *)(v3 + 65) = v36;
            if (++v4 == v5)
            {
              v62 = 1;
LABEL_121:
              *(_BYTE *)(v3 + 64) = v62;
              *(_DWORD *)(v3 + 72) = v36;
              *(_DWORD *)(v3 + 76) = v37;
              goto LABEL_125;
            }
            v56 = 1;
            while (1)
            {
              v57 = *v4;
              v58 = *v4;
              if (v37 < 3u || v56 >= 2)
              {
                v61 = (char)v57 < -64;
              }
              else
              {
                if (v37 == 3)
                {
                  v59 = a00000000000000[v36 & 0xF];
                  v60 = v58 >> 5;
                }
                else
                {
                  v59 = byte_18BE13FBC[v57 >> 4];
                  v60 = v36 & 7;
                }
                v61 = v59 & (1 << v60);
              }
              if (!v61)
                break;
              v36 = v57 + (v36 << 6);
              v62 = v56 + 1;
              *(_BYTE *)(v3 + v56 + 65) = v58;
              ++v4;
              ++v56;
              if (v4 == v5)
                goto LABEL_121;
            }
            *(_BYTE *)(v3 + 64) = v56;
            v38 = 12;
          }
        }
        *a3 = v38;
      }
      v5 = v4;
      goto LABEL_125;
    }
    v4 = v17;
    while (1)
    {
      v28 = (char)*v4++;
      v27 = v28;
      v7 = v28;
      if ((v28 & 0x80000000) == 0)
      {
        *v9++ = v7;
        v29 = -1;
        goto LABEL_46;
      }
      if (v7 >= 0xE0)
        break;
      if (v7 < 0xC2)
        goto LABEL_91;
      v33 = (char)*v4;
      if (v33 > -65)
        goto LABEL_57;
      v4 = v17 + 2;
      *v9 = v7;
      v9[1] = v33;
      v9 += 2;
      v29 = -2;
LABEL_46:
      v17 = v4;
      v34 = __OFADD__(v10, v29);
      v10 += v29;
      if ((v10 < 0) ^ v34 | (v10 == 0))
        goto LABEL_48;
    }
    if (v7 <= 0xEF)
    {
      v30 = a00000000000000[v27 & 0xF];
      v31 = *v4;
      if (((v30 >> (*v4 >> 5)) & 1) == 0)
        goto LABEL_57;
      v32 = (char)v17[2];
      if (v32 > -65)
        goto LABEL_57;
      v4 = v17 + 3;
      *v9 = v7;
      v9[1] = v31;
      v9[2] = v32;
      v9 += 3;
      v29 = -3;
      goto LABEL_46;
    }
    if ((v7 + 62) > 0x32u)
    {
LABEL_91:
      LOBYTE(v6) = 0;
      LOBYTE(v16) = 1;
      goto LABEL_92;
    }
LABEL_57:
    v6 = 0;
    if (v7 <= 0xEF)
      LOBYTE(v8) = 2;
    else
      LOBYTE(v8) = 3;
    if (v7 > 0xDF)
      LOBYTE(v8) = v8 + 1;
    v16 = 1;
LABEL_63:
    if (v16 >= (char)v8)
    {
LABEL_80:
      v39 = (char)v16;
      if (v16 == v8)
      {
        v41 = v4;
LABEL_82:
        if (v6 < 1)
        {
          v50 = 0;
        }
        else
        {
          v47 = v6;
          v48 = (char *)(v3 + 65);
          do
          {
            v49 = *v48++;
            *v9++ = v49;
            --v47;
          }
          while (v47);
          v50 = v6;
        }
        v17 = &v41[v6 - v39];
        while (v50 < (char)v8)
        {
          v51 = *v17++;
          *v9++ = v51;
          v50 = (char)(v50 + 1);
        }
        v10 -= v39;
        continue;
      }
      v17 = &v4[v6 - (char)v16];
      if (v6 < (char)v16)
      {
LABEL_92:
        v52 = (_BYTE *)(v3 + v6 + 65);
        v53 = v16 - (unint64_t)v6;
        do
        {
          v54 = *v17++;
          *v52++ = v54;
          --v53;
        }
        while (v53);
      }
      *(_BYTE *)(v3 + 64) = v16;
      a2[2] = v17;
      *(_QWORD *)(result + 32) = v9;
      v12 = 12;
      goto LABEL_33;
    }
    break;
  }
  v39 = (char)v8;
  LOBYTE(v40) = v16;
  v41 = v4;
  while (v41 < v5)
  {
    v42 = *v41;
    if ((char)v8 < 3 || v40 >= 2u)
    {
      if ((char)v42 >= -64)
        goto LABEL_79;
    }
    else
    {
      if (v8 == 3)
      {
        v43 = a00000000000000[v7 & 0xF];
        v44 = v42 >> 5;
      }
      else
      {
        v43 = byte_18BE13FBC[v42 >> 4];
        LOBYTE(v44) = v7 & 7;
      }
      if ((v43 & (1 << v44)) == 0)
      {
LABEL_79:
        LOBYTE(v16) = v40;
        v4 = v41;
        goto LABEL_80;
      }
    }
    v40 = (char)(v40 + 1);
    ++v41;
    v7 = v42 + (v7 << 6);
    if (v40 >= (char)v8)
      goto LABEL_82;
  }
  v45 = v6;
  if (v6 >= (char)v40)
  {
    v5 = &v41[v6 - (uint64_t)(char)v40];
  }
  else
  {
    do
    {
      v46 = v45 + 1;
      *(_BYTE *)(v3 + 65 + v45) = v4[v45 - v16];
      v45 = v46;
    }
    while (v46 < (char)v40);
    v5 = &v4[v46 - v16];
  }
  *(_BYTE *)(v3 + 64) = v40;
  *(_DWORD *)(v3 + 72) = v7;
  *(_DWORD *)(v3 + 76) = (char)v8;
LABEL_125:
  a2[2] = v5;
  *(_QWORD *)(result + 32) = v9;
  return result;
}

_QWORD *sub_18BC21E0C(_QWORD *result, _DWORD *a2)
{
  uint64_t v2;
  _BYTE *v3;
  _WORD *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  unint64_t v9;
  int v10;
  _BYTE *v11;
  uint64_t v14;
  int v15;
  unsigned int v16;
  int v17;
  BOOL v18;
  _BYTE *v19;
  int v20;
  int v21;
  unsigned int v22;
  int v24;
  unsigned int v25;
  int v26;
  _BYTE *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  int v38;
  __int16 v39;
  unsigned int v40;
  int v41;

  v2 = result[1];
  v3 = (_BYTE *)result[2];
  v5 = result[3];
  v4 = (_WORD *)result[4];
  v6 = result[5];
  v7 = *(_DWORD *)(v2 + 76);
  if (*(_DWORD *)(v2 + 72))
    v8 = *(_DWORD *)(v2 + 72);
  else
    v8 = 64;
  LODWORD(v9) = *(_DWORD *)(v2 + 76) & 3;
  v10 = *(char *)(v2 + 64);
  v11 = (_BYTE *)(v2 + 65);
  if ((v7 & 3) == 0 || v10 < 1 || (unint64_t)v4 >= v6)
  {
    v14 = result[5];
LABEL_13:
    v15 = v5 - (_DWORD)v3;
    v9 = (unint64_t)(v14 - (_QWORD)v4) >> 1;
    if ((int)v9 >= (int)v5 - (int)v3)
      LODWORD(v9) = v5 - (_DWORD)v3;
    if ((int)v9 >= 1)
    {
      do
      {
        v16 = *v3;
        if (((v16 - 80) & 0x80) != 0)
        {
          if (v16 > 0x20)
            goto LABEL_26;
          if (v16 != 32)
            v8 = 64;
          *v4 = v16;
        }
        else
        {
          v17 = v8 + v16 - 144;
          if (v17 >= 12288)
            goto LABEL_26;
          *v4 = v17;
          v8 = v17 & 0xFFFFFF80 | 0x40;
        }
        ++v4;
        ++v3;
        v18 = __OFSUB__((_DWORD)v9, 1);
        LODWORD(v9) = v9 - 1;
      }
      while (!(((v9 & 0x80000000) != 0) ^ v18 | ((_DWORD)v9 == 0)));
      LODWORD(v9) = 0;
    }
    goto LABEL_26;
  }
LABEL_75:
  v15 = v7 >> 2;
  while ((unint64_t)v3 < v5)
  {
    v36 = *v3++;
    v35 = v36;
    v11[(char)v10] = v36;
    if (v36 > 0x20uLL)
      v37 = v35 - 13;
    else
      v37 = byte_18BE14034[v35];
    LOBYTE(v10) = v10 + 1;
    v38 = 59049 * v37;
    if ((_DWORD)v9 == 2)
      v38 = 243 * v37;
    if ((_DWORD)v9 != 1)
      v37 = v38;
    if (v37 < 0)
      goto LABEL_106;
    v15 += v37;
    LODWORD(v9) = v9 - 1;
    if (!(_DWORD)v9)
    {
      v25 = v15 + v8;
      if (v15 + v8 > 0x10FFFF)
      {
        LOBYTE(v10) = 0;
LABEL_106:
        v27 = v3;
LABEL_107:
        *a2 = 12;
        v3 = v27;
        goto LABEL_108;
      }
      LODWORD(v9) = 0;
      LOBYTE(v10) = 0;
LABEL_91:
      if (v25 - 55204 >= 0xFFFF589C)
      {
        if (v25 >> 10 <= 0x2A)
          v40 = v25 & 0xFFFFFF80 | 0x40;
        else
          v40 = 49617;
        if (v25 - 19968 >= 0x51A6)
          v41 = v40;
        else
          v41 = 30481;
        if (v25 >> 5 >= 0x185)
          v8 = v41;
        else
          v8 = 12400;
      }
      else
      {
        v8 = v25 & 0xFFFFFF80 | 0x40;
        if (HIWORD(v25))
        {
          *v4 = (v25 >> 10) - 10304;
          v39 = v25 & 0x3FF | 0xDC00;
          if ((unint64_t)(v4 + 1) < v6)
          {
            v4[1] = v39;
            v4 += 2;
            goto LABEL_26;
          }
          *(_WORD *)(v2 + 144) = v39;
          *(_BYTE *)(v2 + 93) = 1;
          ++v4;
LABEL_47:
          *a2 = 15;
LABEL_48:
          *(_DWORD *)(v2 + 72) = v8;
          v24 = v9 | (4 * v15);
          goto LABEL_109;
        }
      }
      *v4++ = v25;
LABEL_26:
      v19 = v3;
      v20 = v8;
LABEL_27:
      v3 = v19 + 1;
      v21 = v20;
      do
      {
        v8 = v21;
        if ((unint64_t)(v3 - 1) >= v5)
        {
          --v3;
          goto LABEL_44;
        }
        if ((unint64_t)v4 >= v6)
        {
          v8 = v20;
          v3 = v19;
          goto LABEL_47;
        }
        v22 = *(v3 - 1);
        if (((v22 - 80) & 0x80) == 0)
        {
          v25 = v21 + v22 - 144;
          if ((int)v25 >= 12288)
            goto LABEL_91;
          *v4++ = v25;
          v8 = v25 & 0xFFFFFF80 | 0x40;
          v14 = result[5];
          goto LABEL_13;
        }
        if (v22 <= 0x20)
        {
          if (v22 == 32)
            v20 = v21;
          else
            v20 = 64;
          *v4++ = v22;
          v19 = v3;
          goto LABEL_27;
        }
        if ((v22 - 37) <= 0xD5u && (unint64_t)v3 < v5)
        {
          if (v22 <= 0x8F)
            v26 = -19504;
          else
            v26 = -50480;
          v15 = v26 + 243 * v22;
          v27 = v3 + 1;
          v28 = *v3;
          if (v28 >= 0x21)
          {
            v29 = v28 - 13;
          }
          else
          {
            v29 = byte_18BE14034[*v3];
            if (((0x10C00FF81uLL >> v28) & 1) != 0)
            {
LABEL_110:
              *(_BYTE *)(v2 + 65) = v22;
              *(_BYTE *)(v2 + 66) = *v3;
              LOBYTE(v10) = 2;
              goto LABEL_107;
            }
          }
          v25 = v15 + v21 + v29;
          if (v25 < 0x110000)
          {
            ++v3;
            goto LABEL_91;
          }
          goto LABEL_110;
        }
        ++v3;
        v21 = 64;
      }
      while (v22 == 255);
      *v11 = v22;
      --v3;
      if (v22 >= 0x22)
        v30 = 59049 * v22 - 2195326;
      else
        v30 = -14536567;
      if (v22 >= 0x22)
        v31 = 2;
      else
        v31 = 3;
      if (v22 >= 0x25)
      {
        v30 = 243 * v22 - 19504;
        v31 = 1;
      }
      v32 = 59049 * v22 - 14810786;
      if (v22 <= 0xFD)
      {
        v33 = 2;
      }
      else
      {
        v32 = 187660;
        v33 = 3;
      }
      if (v22 > 0xFA)
      {
        v34 = v33;
      }
      else
      {
        v32 = 243 * v22 - 50480;
        v34 = 1;
      }
      if (v22 >= 0x50)
      {
        LODWORD(v9) = v34;
      }
      else
      {
        v32 = v30;
        LODWORD(v9) = v31;
      }
      v7 = v9 | (4 * v32);
      LOBYTE(v10) = 1;
      goto LABEL_75;
    }
  }
LABEL_44:
  if (*a2 != 12)
    goto LABEL_48;
LABEL_108:
  v24 = 0;
  *(_DWORD *)(v2 + 72) = 64;
LABEL_109:
  *(_DWORD *)(v2 + 76) = v24;
  *(_BYTE *)(v2 + 64) = v10;
  result[2] = v3;
  result[4] = v4;
  return result;
}

_QWORD *sub_18BC2220C(_QWORD *result, int *a2)
{
  int v2;
  uint64_t v3;
  unsigned __int8 *v4;
  _WORD *v5;
  unint64_t v6;
  int *v7;
  unint64_t v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  int v12;
  _BYTE *v13;
  uint64_t v16;
  int v17;
  unsigned int v18;
  int v19;
  BOOL v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  int v27;
  unsigned int v28;
  int v29;
  unsigned __int8 *v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  int v37;
  int *v38;
  uint64_t v39;
  int v40;
  int v41;

  v2 = 0;
  v3 = result[1];
  v4 = (unsigned __int8 *)result[2];
  v6 = result[3];
  v5 = (_WORD *)result[4];
  v8 = result[5];
  v7 = (int *)result[6];
  v9 = *(_DWORD *)(v3 + 76);
  if (*(_DWORD *)(v3 + 72))
    v10 = *(_DWORD *)(v3 + 72);
  else
    v10 = 64;
  LODWORD(v11) = *(_DWORD *)(v3 + 76) & 3;
  v12 = *(char *)(v3 + 64);
  v13 = (_BYTE *)(v3 + 65);
  if ((v9 & 3) == 0 || v12 < 1 || (unint64_t)v5 >= v8)
  {
    v16 = result[5];
    goto LABEL_13;
  }
  v21 = -1;
LABEL_72:
  v17 = v9 >> 2;
  v2 += v11;
  do
  {
    if ((unint64_t)v4 >= v6)
      goto LABEL_99;
    v35 = *v4++;
    v34 = v35;
    v13[(char)v12] = v35;
    if (v35 > 0x20uLL)
      v36 = v34 - 13;
    else
      v36 = byte_18BE14034[v34];
    LOBYTE(v12) = v12 + 1;
    v37 = 59049 * v36;
    if ((_DWORD)v11 == 2)
      v37 = 243 * v36;
    if ((_DWORD)v11 != 1)
      v36 = v37;
    if (v36 < 0)
      goto LABEL_97;
    v17 += v36;
    LODWORD(v11) = v11 - 1;
  }
  while ((_DWORD)v11);
  v28 = v17 + v10;
  if (v17 + v10 > 0x10FFFF)
  {
    v27 = 12;
    LOBYTE(v12) = 0;
    goto LABEL_98;
  }
  LOBYTE(v12) = 0;
LABEL_85:
  while (2)
  {
    if (v28 - 55204 >= 0xFFFF589C)
    {
      v10 = 12400;
      if (v28 >> 5 >= 0x185)
      {
        v10 = 30481;
        if (v28 - 19968 >= 0x51A6)
        {
          v10 = 49617;
          if (v28 >> 10 <= 0x2A)
            v10 = v28 & 0xFFFFFF80 | 0x40;
        }
      }
      goto LABEL_93;
    }
    v10 = v28 & 0xFFFFFF80 | 0x40;
    if (!HIWORD(v28))
    {
LABEL_93:
      *v5++ = v28;
      v39 = 1;
      v38 = v7;
      goto LABEL_94;
    }
    *v5 = (v28 >> 10) - 10304;
    if ((unint64_t)(v5 + 1) >= v8)
    {
      *v7++ = v21;
      *(_WORD *)(v3 + 144) = v28 & 0x3FF | 0xDC00;
      *(_BYTE *)(v3 + 93) = 1;
      v27 = 15;
      ++v5;
      goto LABEL_98;
    }
    v5[1] = v28 & 0x3FF | 0xDC00;
    v5 += 2;
    *v7 = v21;
    v38 = v7 + 1;
    v39 = 2;
LABEL_94:
    v7 += v39;
    *v38 = v21;
LABEL_26:
    v22 = v10;
LABEL_27:
    v23 = 0;
    v24 = v22;
    while (1)
    {
      v10 = v24;
      if ((unint64_t)&v4[v23] >= v6)
      {
        v4 += v23;
        goto LABEL_99;
      }
      if ((unint64_t)v5 >= v8)
      {
        v27 = 15;
        v10 = v22;
        goto LABEL_98;
      }
      v25 = v4[v23];
      if (((v25 - 80) & 0x80) == 0)
      {
        v28 = v24 + v25 - 144;
        v4 += v23 + 1;
        v21 = v23 + v2;
        v2 += v23 + 1;
        if ((int)v28 >= 12288)
          goto LABEL_85;
        *v5++ = v28;
        *v7++ = v21;
        v10 = v28 & 0xFFFFFF80 | 0x40;
        v16 = result[5];
LABEL_13:
        v17 = v6 - (_DWORD)v4;
        v11 = (unint64_t)(v16 - (_QWORD)v5) >> 1;
        if ((int)v11 >= (int)v6 - (int)v4)
          LODWORD(v11) = v6 - (_DWORD)v4;
        if ((int)v11 >= 1)
        {
          do
          {
            v18 = *v4;
            if (((v18 - 80) & 0x80) != 0)
            {
              if (v18 > 0x20)
                goto LABEL_26;
              if (v18 != 32)
                v10 = 64;
              *v5 = v18;
              *v7 = v2;
            }
            else
            {
              v19 = v10 + v18 - 144;
              if (v19 >= 12288)
                goto LABEL_26;
              *v5 = v19;
              *v7 = v2;
              v10 = v19 & 0xFFFFFF80 | 0x40;
            }
            ++v7;
            ++v5;
            ++v2;
            ++v4;
            v20 = __OFSUB__((_DWORD)v11, 1);
            LODWORD(v11) = v11 - 1;
          }
          while (!(((v11 & 0x80000000) != 0) ^ v20 | ((_DWORD)v11 == 0)));
          LODWORD(v11) = 0;
        }
        goto LABEL_26;
      }
      if (v25 <= 0x20)
      {
        if (v25 == 32)
          v22 = v24;
        else
          v22 = 64;
        *v5++ = v25;
        *v7++ = v2 + v23;
        v4 += v23 + 1;
        v2 += v23 + 1;
        goto LABEL_27;
      }
      if ((v25 - 37) <= 0xD5u && (unint64_t)&v4[v23 + 1] < v6)
        break;
      ++v23;
      v24 = 64;
      if (v25 != 255)
      {
        *v13 = v25;
        v4 += v23;
        v21 = v2 - 1 + v23;
        v2 += v23;
        if (v25 < 0x50)
        {
          if (v25 < 0x25)
          {
            LODWORD(v11) = 3;
            v12 = -14536567;
            if (v25 >= 0x22)
            {
              v12 = 59049 * v25 - 2195326;
              LODWORD(v11) = 2;
            }
            goto LABEL_71;
          }
          v33 = -19504;
        }
        else
        {
          if (v25 > 0xFA)
          {
            if (v25 <= 0xFD)
              v12 = 59049 * v25 - 14810786;
            else
              v12 = 187660;
            if (v25 <= 0xFD)
              LODWORD(v11) = 2;
            else
              LODWORD(v11) = 3;
            goto LABEL_71;
          }
          v33 = -50480;
        }
        v12 = v33 + 243 * v25;
        LODWORD(v11) = 1;
LABEL_71:
        v9 = v11 | (4 * v12);
        LOBYTE(v12) = 1;
        goto LABEL_72;
      }
    }
    if (v25 <= 0x8F)
      v29 = -19504;
    else
      v29 = -50480;
    v17 = v29 + 243 * v25;
    v30 = &v4[v23];
    v4 += v23 + 2;
    v31 = v30[1];
    v21 = v23 + v2;
    if (v31 >= 0x21)
    {
      v32 = v31 - 13;
    }
    else
    {
      v32 = byte_18BE14034[v30[1]];
      if (((0x10C00FF81uLL >> v31) & 1) != 0)
        break;
    }
    v28 = v17 + v10 + v32;
    if (HIWORD(v28) <= 0x10u)
    {
      v2 = v21 + 2;
      continue;
    }
    break;
  }
  *(_BYTE *)(v3 + 65) = v25;
  *(_BYTE *)(v3 + 66) = v30[1];
  LOBYTE(v12) = 2;
LABEL_97:
  v27 = 12;
LABEL_98:
  *a2 = v27;
LABEL_99:
  v40 = v11 | (4 * v17);
  if (*a2 == 12)
    v41 = 64;
  else
    v41 = v10;
  if (*a2 == 12)
    v40 = 0;
  *(_DWORD *)(v3 + 72) = v41;
  *(_DWORD *)(v3 + 76) = v40;
  *(_BYTE *)(v3 + 64) = v12;
  result[2] = v4;
  result[4] = v5;
  result[6] = v7;
  return result;
}

uint64_t sub_18BC22688(uint64_t result, _DWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 *v5;
  _BYTE *v6;
  unint64_t v7;
  int v8;
  unsigned int v9;
  int v10;
  BOOL v11;
  unsigned __int16 *v12;
  unsigned int v13;
  int v14;
  unsigned __int16 v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int16 *v19;
  int v20;
  BOOL v21;
  int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  char v31;
  _BYTE *v32;
  int v33;

  v3 = result;
  v4 = *(_QWORD *)(result + 8);
  v5 = *(unsigned __int16 **)(result + 16);
  v7 = *(_QWORD *)(result + 24);
  v6 = *(_BYTE **)(result + 32);
  v8 = *(_DWORD *)(result + 40) - (_DWORD)v6;
  v9 = *(_DWORD *)(v4 + 84);
  if (*(_DWORD *)(v4 + 80))
    v10 = *(_DWORD *)(v4 + 80);
  else
    v10 = 64;
  if (v9)
    v11 = v8 <= 0;
  else
    v11 = 1;
  v12 = *(unsigned __int16 **)(result + 16);
  v13 = *(_DWORD *)(result + 40) - (_DWORD)v6;
  if (v11)
    goto LABEL_9;
LABEL_33:
  if ((unint64_t)v12 >= v7)
  {
    v9 = -v9;
    v5 = v12;
    goto LABEL_56;
  }
  v20 = *v12;
  v21 = (v20 & 0xFC00) == 56320;
  v22 = v20 + (v9 << 10) - 56613888;
  v5 = &v12[v21];
  if (v21)
    v9 = v22;
  while (1)
  {
    result = v9 - v10;
    v23 = v9 >> 10 <= 0x2A ? v9 & 0xFFFFFF80 | 0x40 : 49617;
    v24 = v9 - 19968 >= 0x51A6 ? v23 : 30481;
    v25 = v9 >> 5 >= 0x185 ? v24 : 12400;
    v10 = v9 - 55204 <= 0xFFFF589B ? v9 & 0xFFFFFF80 | 0x40 : v25;
    if ((result + 64) > 0x7F)
      break;
    *v6++ = result - 112;
    v8 = v13 - 1;
    if ((int)v9 < 12288)
    {
LABEL_9:
      if (v8 >= (int)((v7 - (unint64_t)v5) >> 1))
        v8 = (v7 - (unint64_t)v5) >> 1;
      if (v8 >= 1)
      {
        v14 = v8 + 1;
        do
        {
          v9 = *v5;
          if (v9 >> 12 > 2)
            break;
          if (v9 > 0x20)
          {
            v16 = v9 - v10;
            if (v9 - v10 + 64 > 0x7F)
              break;
            v10 = v9 & 0xFF80 | 0x40;
            LOBYTE(v15) = v16 - 112;
          }
          else
          {
            if (v9 != 32)
              v10 = 64;
            v15 = *v5;
          }
          *v6++ = v15;
          ++v5;
          --v14;
        }
        while (v14 > 1);
      }
      v8 = *(_DWORD *)(v3 + 40) - (_DWORD)v6;
    }
LABEL_22:
    if ((unint64_t)v5 >= v7)
      goto LABEL_56;
    if (v8 < 1)
      goto LABEL_31;
    v17 = 0;
    v18 = 1;
    v19 = v5;
    while (1)
    {
      v12 = v19 + 1;
      v9 = v5[v17];
      if (v9 > 0x20)
        break;
      if (v9 != 32)
        v10 = 64;
      v6[v17] = v9;
      if ((unint64_t)v12 >= v7)
      {
        v5 = v19 + 1;
        v6 += v17 + 1;
        goto LABEL_56;
      }
      ++v17;
      --v18;
      ++v19;
      if (v8 + (int)v18 < 2)
      {
        v6 += v17;
        v5 = v12;
        goto LABEL_31;
      }
    }
    v6 += v17;
    v13 = v8 - v17;
    if ((v9 & 0xFC00) == 0xD800)
      goto LABEL_33;
    v5 = v19 + 1;
  }
  if ((result + 10513) <= 0x5221)
  {
    v8 = v13 - 2;
    if (v13 >= 2)
    {
      if ((result & 0x80000000) != 0)
      {
        v27 = (-64 - (int)result) / 0xF3u;
        v30 = (-64 - (int)result) % 0xF3u;
        v26 = 243 - v30;
        if (v30)
          LOBYTE(v27) = ~(_BYTE)v27;
        else
          v27 = -v27;
        LOBYTE(v27) = v27 + 80;
        if (!v30)
        {
          v26 = 0u;
          *v6 = v27;
          goto LABEL_74;
        }
      }
      else
      {
        v26 = (__int16)(result - 64) % 243;
        LOWORD(v27) = (__int16)(result - 64) / 243 + 208;
      }
      *v6 = v27;
      if (v26 >= 20)
      {
        v31 = v26 + 13;
LABEL_75:
        v6[1] = v31;
        v6 += 2;
        goto LABEL_22;
      }
LABEL_74:
      v31 = byte_18BE14055[v26];
      goto LABEL_75;
    }
  }
  result = sub_18BC22EF8(result);
  if (result >> 26)
    v28 = 4;
  else
    v28 = (int)result >> 24;
  v29 = v28 - v13;
  if (v28 <= (int)v13)
  {
    if (v28 == 3)
      goto LABEL_64;
    if (v28 == 4)
    {
      *v6++ = BYTE3(result);
LABEL_64:
      *v6 = BYTE2(result);
      v6[1] = BYTE1(result);
      v6[2] = result;
      v6 += 3;
    }
    v8 = v13 - v28;
    goto LABEL_22;
  }
  v32 = (_BYTE *)(v4 + 104);
  switch(v29)
  {
    case 1u:
      goto LABEL_82;
    case 2u:
      goto LABEL_81;
    case 3u:
      v32 = (_BYTE *)(v4 + 105);
      *(_BYTE *)(v4 + 104) = BYTE2(result);
LABEL_81:
      *v32++ = BYTE1(result);
LABEL_82:
      *v32 = result;
      break;
  }
  *(_BYTE *)(v4 + 91) = v29;
  v33 = (int)result >> (8 * v29);
  switch(v13)
  {
    case 1u:
      goto LABEL_88;
    case 2u:
      goto LABEL_87;
    case 3u:
      *v6++ = BYTE2(v33);
LABEL_87:
      *v6++ = BYTE1(v33);
LABEL_88:
      *v6++ = v33;
      break;
  }
LABEL_31:
  *a2 = 15;
LABEL_56:
  *(_DWORD *)(v4 + 80) = v10;
  *(_DWORD *)(v4 + 84) = -v9 & ((int)v9 >> 31);
  *(_QWORD *)(v3 + 16) = v5;
  *(_QWORD *)(v3 + 32) = v6;
  return result;
}

uint64_t sub_18BC22A68(uint64_t result, _DWORD *a2)
{
  uint64_t v2;
  int v3;
  unsigned __int16 *v4;
  uint64_t v5;
  _BYTE *v6;
  unint64_t v7;
  int v8;
  int *v9;
  unsigned int v10;
  int v11;
  int v12;
  BOOL v13;
  unsigned __int16 *v14;
  unint64_t v15;
  int v16;
  unsigned __int16 v17;
  char v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int16 *v22;
  int v23;
  BOOL v24;
  int v25;
  int v26;
  __int16 v27;
  int v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  char v32;
  char v33;
  _BYTE *v34;
  _DWORD *v35;
  int v36;
  uint64_t v37;
  _DWORD *v38;

  v2 = result;
  v3 = 0;
  v5 = *(_QWORD *)(result + 8);
  v4 = *(unsigned __int16 **)(result + 16);
  v7 = *(_QWORD *)(result + 24);
  v6 = *(_BYTE **)(result + 32);
  v8 = *(_DWORD *)(result + 40) - (_DWORD)v6;
  v9 = *(int **)(result + 48);
  v10 = *(_DWORD *)(v5 + 84);
  if (*(_DWORD *)(v5 + 80))
    v11 = *(_DWORD *)(v5 + 80);
  else
    v11 = 64;
  if (v10)
    v12 = -1;
  else
    v12 = 0;
  if (v10)
    v13 = v8 <= 0;
  else
    v13 = 1;
  if (v13)
  {
    v14 = *(unsigned __int16 **)(result + 16);
    goto LABEL_13;
  }
LABEL_38:
  if ((unint64_t)v4 >= v7)
  {
    v10 = -v10;
    v14 = v4;
    goto LABEL_54;
  }
  v23 = *v4;
  v24 = (v23 & 0xFC00) == 56320;
  v25 = v23 + (v10 << 10) - 56613888;
  v14 = &v4[v24];
  if (v24)
  {
    v10 = v25;
    ++v3;
  }
  while (1)
  {
    result = v10 - v11;
    if (v10 - 55204 <= 0xFFFF589B
      || (v11 = 12400, v10 >> 5 >= 0x185) && (v11 = 30481, v10 - 19968 >= 0x51A6) && (v11 = 49617, v10 >> 10 <= 0x2A))
    {
      v11 = v10 & 0xFFFFFF80 | 0x40;
    }
    if ((result + 64) > 0x7F)
    {
      if ((result + 10513) <= 0x5221 && v8 >= 2)
      {
        if ((result & 0x80000000) != 0)
        {
          v30 = (-64 - (int)result) / 0xF3u;
          v31 = (-64 - (int)result) % 0xF3u;
          v26 = 243 - v31;
          if (v31)
            v32 = ~(_BYTE)v30;
          else
            v32 = -(char)v30;
          LOBYTE(v27) = v32 + 80;
          if (!v31)
          {
            v26 = 0u;
            *v6 = v27;
            goto LABEL_74;
          }
        }
        else
        {
          v26 = (__int16)(result - 64) % 243;
          v27 = (__int16)(result - 64) / 243 + 208;
        }
        *v6 = v27;
        if (v26 >= 20)
        {
          v33 = v26 + 13;
LABEL_75:
          v6[1] = v33;
          v6 += 2;
          v19 = v9 + 2;
          *v9 = v12;
          v9[1] = v12;
          v8 -= 2;
          goto LABEL_27;
        }
LABEL_74:
        v33 = byte_18BE14055[v26];
        goto LABEL_75;
      }
      v37 = v2;
      v38 = a2;
      result = sub_18BC22EF8(result);
      v28 = (int)result >> 24;
      if (result >> 26)
        v28 = 4;
      v29 = v28 - v8;
      if (v28 <= v8)
      {
        if (v28 == 2)
        {
          v2 = v37;
          a2 = v38;
        }
        else
        {
          v2 = v37;
          a2 = v38;
          if (v28 != 3)
          {
            if (v28 != 4)
            {
LABEL_72:
              v8 -= v28;
LABEL_26:
              v19 = v9;
              goto LABEL_27;
            }
            *v6++ = BYTE3(result);
            *v9++ = v12;
          }
          *v6++ = BYTE2(result);
          *v9++ = v12;
        }
        *v6 = BYTE1(result);
        *v9 = v12;
        v6[1] = result;
        v6 += 2;
        v9[1] = v12;
        v9 += 2;
        goto LABEL_72;
      }
      v34 = (_BYTE *)(v5 + 104);
      if (v29 == 1)
      {
        v2 = v37;
        v35 = v38;
      }
      else
      {
        v2 = v37;
        v35 = v38;
        if (v29 != 2)
        {
          if (v29 != 3)
            goto LABEL_86;
          v34 = (_BYTE *)(v5 + 105);
          *(_BYTE *)(v5 + 104) = BYTE2(result);
        }
        *v34++ = BYTE1(result);
      }
      *v34 = result;
LABEL_86:
      *(_BYTE *)(v5 + 91) = v29;
      v36 = (int)result >> (8 * v29);
      if (v8 != 1)
      {
        if (v8 != 2)
        {
          if (v8 != 3)
          {
LABEL_92:
            *v35 = 15;
            goto LABEL_54;
          }
          *v6++ = BYTE2(v36);
          *v9++ = v12;
        }
        *v6++ = BYTE1(v36);
        *v9++ = v12;
      }
      *v6++ = v36;
      *v9++ = v12;
      goto LABEL_92;
    }
    *v6++ = result - 112;
    *v9++ = v12;
    --v8;
    v19 = v9;
    if ((int)v10 < 12288)
    {
LABEL_13:
      v15 = (v7 - (unint64_t)v14) >> 1;
      if (v8 < (int)v15)
        LODWORD(v15) = v8;
      if ((int)v15 >= 1)
      {
        v16 = v15 + 1;
        do
        {
          v10 = *v14;
          if (v10 >> 12 > 2)
            break;
          if (v10 > 0x20)
          {
            v18 = v10 - v11;
            if (v10 - v11 + 64 > 0x7F)
              break;
            v11 = v10 & 0xFF80 | 0x40;
            LOBYTE(v17) = v18 - 112;
          }
          else
          {
            if (v10 != 32)
              v11 = 64;
            v17 = *v14;
          }
          *v6++ = v17;
          *v9++ = v3;
          ++v14;
          ++v3;
          --v16;
        }
        while (v16 > 1);
      }
      v8 = *(_DWORD *)(v2 + 40) - (_DWORD)v6;
      goto LABEL_26;
    }
LABEL_27:
    if ((unint64_t)v14 >= v7)
    {
      v9 = v19;
      goto LABEL_54;
    }
    if (v8 < 1)
      break;
    v20 = 0;
    v21 = 1;
    v22 = v14;
    v9 = v19;
    while (1)
    {
      v4 = v22 + 1;
      v10 = v14[v20];
      if (v10 > 0x20)
        break;
      if (v10 != 32)
        v11 = 64;
      v6[v20] = v10;
      ++v9;
      v19[v20] = v3 + v20;
      if ((unint64_t)v4 >= v7)
      {
        v14 = v22 + 1;
        v6 += v20 + 1;
        goto LABEL_54;
      }
      ++v20;
      --v21;
      ++v22;
      if (v8 + (int)v21 < 2)
      {
        v6 += v20;
        v14 = v4;
        goto LABEL_36;
      }
    }
    v6 += v20;
    v8 -= v20;
    v12 = v20 + v3;
    v3 += v20 + 1;
    if ((v10 & 0xFC00) == 0xD800)
      goto LABEL_38;
    v14 = v22 + 1;
  }
  v9 = v19;
LABEL_36:
  *a2 = 15;
LABEL_54:
  *(_DWORD *)(v5 + 80) = v11;
  *(_DWORD *)(v5 + 84) = -v10 & ((int)v10 >> 31);
  *(_QWORD *)(v2 + 16) = v14;
  *(_QWORD *)(v2 + 32) = v6;
  *(_QWORD *)(v2 + 48) = v9;
  return result;
}

uint64_t sub_18BC22EF8(int a1)
{
  int v1;
  int v2;
  unsigned int v3;
  int v4;
  unsigned __int16 v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  __int16 v23;
  unsigned __int16 v24;
  BOOL v25;
  int v26;
  unsigned __int16 v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  BOOL v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;

  if (a1 < -64)
  {
    if (a1 >= 0xFFFFD6EF)
    {
      v3 = (((unsigned __int16)(-64 - a1 - ((3507 * (unsigned __int16)(-64 - a1)) >> 16)) >> 1)
          + ((3507 * (unsigned __int16)(-64 - a1)) >> 16)) >> 7;
      if (-64 - (_WORD)a1 == 243 * (_WORD)v3)
        v4 = -v3;
      else
        v4 = ~v3;
      if (-64 - (_WORD)a1 == 243 * (_WORD)v3)
        v5 = 0;
      else
        v5 = 243 - (-64 - a1 - 243 * v3);
      if (v5 < 0x14u)
        v2 = byte_18BE14055[v5];
      else
        v2 = v5 + 13;
      v11 = (v4 << 8) + 20480;
      return v11 | v2 | 0x2000000u;
    }
    if (a1 > 0xFFFD22F3)
    {
      v8 = (-10513 - a1) / 0xF3u;
      v9 = (-10513 - a1) % 0xF3u;
      if (v9)
      {
        LOWORD(v8) = v8 + 1;
        v10 = 243 - v9;
      }
      else
      {
        v10 = 0;
      }
      if (v10 < 0x14)
        v7 = byte_18BE14055[v10];
      else
        v7 = v10 + 13;
      v22 = (((unsigned __int16)(v8 - ((3507 * (unsigned __int16)v8) >> 16)) >> 1)
           + ((3507 * (unsigned __int16)v8) >> 16)) >> 7;
      v23 = v8 - 243 * v22;
      v24 = 243 - v23;
      v25 = v23 == 0;
      if (v23)
        v26 = ~v22;
      else
        v26 = -v22;
      if (v25)
        v27 = 0;
      else
        v27 = v24;
      if (v27 < 0x14u)
        v21 = byte_18BE14055[v27];
      else
        v21 = v27 + 13;
      v37 = (v26 << 16) + 2424832;
      return v37 | v7 | (v21 << 8) | 0x3000000;
    }
    v16 = (-187660 - a1) % 0xF3u;
    if (v16)
      v17 = (-187660 - a1) / 0xF3u + 1;
    else
      v17 = (-187660 - a1) / 0xF3u;
    if (v16)
      v18 = 243 - v16;
    else
      v18 = 0;
    if (v18 < 0x14)
      v19 = byte_18BE14055[v18];
    else
      v19 = v18 + 13;
    v30 = v17 / 0xF3;
    v31 = v17 % 0xF3;
    v32 = 243 - v31;
    v33 = v31 == 0;
    if (v31)
      v34 = ~v30;
    else
      v34 = -v30;
    if (v33)
      v35 = 0;
    else
      v35 = v32;
    if (v35 < 0x14)
      v36 = byte_18BE14055[v35];
    else
      v36 = v35 + 13;
    v40 = v36 << 8;
    if (v34 < -223)
      v41 = byte_18BE14055[v34 + 243];
    else
      v41 = v34 + 256;
    return v19 | v40 | (v41 << 16) | 0x21000000;
  }
  else
  {
    if (a1 <= 10512)
    {
      v1 = (__int16)(a1 - 64) % 243;
      if (v1 < 20)
        v2 = byte_18BE14055[(__int16)(a1 - 64) % 243];
      else
        v2 = (unsigned __int16)(v1 + 13);
      v11 = ((unsigned __int16)((__int16)(a1 - 64) / 243) << 8) + 53248;
      return v11 | v2 | 0x2000000u;
    }
    if (a1 <= 0x2DD0B)
    {
      v6 = (a1 - 10513) % 0xF3u;
      if (v6 < 0x14)
        v7 = byte_18BE14055[v6];
      else
        v7 = v6 + 13;
      v20 = (unsigned __int16)((a1 - 10513) / 0xF3u)
          - 243 * ((17674763 * (unint64_t)(unsigned __int16)((a1 - 10513) / 0xF3u)) >> 32);
      if (v20 < 0x14)
        v21 = byte_18BE14055[v20];
      else
        v21 = v20 + 13;
      v37 = (((a1 - 10513) / 0xE6A9u) << 16) + 16449536;
      return v37 | v7 | (v21 << 8) | 0x3000000;
    }
    v13 = a1 - 187660;
    v14 = (a1 - 187660) % 0xF3u;
    if (v14 < 0x14)
      v15 = byte_18BE14055[v14];
    else
      v15 = v14 + 13;
    v28 = (a1 - 187660) / 0xF3u - 243 * ((17674763 * (unint64_t)((a1 - 187660) / 0xF3u)) >> 32);
    if (v28 < 0x14)
      v29 = byte_18BE14055[v28];
    else
      v29 = v28 + 13;
    v38 = v13 / 0xE6A9;
    if (v13 < 0x120534)
      v39 = byte_18BE14055[v38];
    else
      v39 = v38 + 13;
    return v15 | (v29 << 8) | (v39 << 16) | 0xFE000000;
  }
}

uint64_t ucnv_getDisplayName(uint64_t a1, char *a2, UChar *a3, int a4, int *a5)
{
  uint64_t result;
  _QWORD *v10;
  _QWORD *v11;
  const UChar *StringByKey;
  const char *v13;
  size_t v14;
  int32_t v15;
  int v16;
  int v17;
  unsigned int v18;

  v17 = 0;
  if (!a5 || *a5 > 0)
    return 0;
  if (!a1 || a4 < 0 || !a3 && a4)
  {
    result = 0;
    *a5 = 1;
    return result;
  }
  v10 = ures_open(0, a2, a5);
  if (*a5 > 0)
    return 0;
  v11 = v10;
  v18 = 0;
  StringByKey = ures_getStringByKey((uint64_t)v10, (const char *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) + 4), (int *)&v18, &v17);
  ures_close(v11);
  if (v17 <= 0)
  {
    if (!*a5)
      *a5 = v17;
    v16 = uprv_min(v18, a4);
    u_memcpy(a3, StringByKey, 2 * v16);
  }
  else
  {
    v13 = (const char *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) + 4);
    v14 = strlen(v13);
    v18 = v14;
    v15 = uprv_min(v14, a4);
    u_charsToUChars(v13, a3, v15);
  }
  return u_terminateUChars((uint64_t)a3, a4, v18, a5);
}

void sub_18BC23420(_QWORD *a1, uint64_t a2, UErrorCode *a3)
{
  _OWORD *v5;
  _QWORD *v6;
  _QWORD *v7;

  if (*(_BYTE *)(a2 + 8))
  {
    sub_18BC1638C("GBK", a3);
  }
  else
  {
    v5 = ucnv_open("GBK", a3);
    if (*(int *)a3 <= 0)
    {
      v6 = v5;
      a1[9] = 0;
      a1[10] = 0;
      v7 = uprv_calloc(1, 24);
      a1[2] = v7;
      if (v7)
      {
        *v7 = v6;
      }
      else
      {
        ucnv_close(v6);
        *a3 = U_MEMORY_ALLOCATION_ERROR;
      }
    }
  }
}

void sub_18BC234BC(uint64_t a1)
{
  _QWORD **v1;

  v1 = *(_QWORD ***)(a1 + 16);
  if (v1)
  {
    ucnv_close(*v1);
    if (!*(_BYTE *)(a1 + 62))
      uprv_free(*(void **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
  }
}

_QWORD *sub_18BC234FC(_QWORD *result, int a2)
{
  uint64_t v2;

  if (a2 >= 2)
  {
    v2 = result[2];
LABEL_7:
    result[10] = 0;
    if (v2)
    {
      *(_BYTE *)(v2 + 18) = 0;
      *(_QWORD *)(v2 + 8) = 0;
      *(_BYTE *)(v2 + 16) = 0;
    }
    return result;
  }
  result[9] = 0;
  v2 = result[2];
  if (v2)
  {
    *(_BYTE *)(v2 + 17) = 0;
    *(_BYTE *)(v2 + 19) = 0;
  }
  if (a2 != 1)
    goto LABEL_7;
  return result;
}

_QWORD *sub_18BC23540(_QWORD *result, int *a2)
{
  _QWORD *v2;
  _WORD *v3;
  unint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  _BYTE *v7;
  unint64_t v8;
  int v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unint64_t v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  int v20;
  int *v21;
  __int16 v22;

  v2 = result;
  v22 = 0;
  v4 = result[3];
  v3 = (_WORD *)result[4];
  v5 = (unsigned __int8 *)result[2];
  if ((unint64_t)v5 >= v4)
    goto LABEL_40;
  v6 = result[1];
  v7 = *(_BYTE **)(v6 + 16);
  while (2)
  {
    v8 = v2[5];
    v9 = (int)v5;
    v10 = v5;
    while (1)
    {
      if ((unint64_t)v3 >= v8)
      {
        *a2 = 15;
        goto LABEL_40;
      }
      v11 = v10;
      v13 = *v10++;
      v12 = v13;
      if (*(_DWORD *)(v6 + 76) == 126)
        break;
      if (!v7[17])
      {
        if ((_DWORD)v12 == 126)
        {
LABEL_15:
          *(_DWORD *)(v6 + 76) = 126;
          goto LABEL_19;
        }
        v7[19] = 0;
        if ((v12 & 0x80) == 0)
        {
          result = (_QWORD *)v12;
          goto LABEL_31;
        }
        *a2 = 12;
        goto LABEL_56;
      }
      v14 = *(_DWORD *)(v6 + 72);
      if (v14)
      {
        v15 = v12 - 33;
        if ((v14 - 33) > 0x5Cu || v15 >= 0x5E)
        {
          *(_DWORD *)(v6 + 72) = 0;
          *a2 = 12;
          if (v15 >= 0x5E)
          {
            LOWORD(v12) = v12 | (v14 << 8);
            goto LABEL_59;
          }
          LOBYTE(v12) = v14;
        }
        else
        {
          v21 = a2;
          LOBYTE(v22) = v14 ^ 0x80;
          HIBYTE(v22) = v12 ^ 0x80;
          result = (_QWORD *)sub_18BC2735C(*(_QWORD *)(*(_QWORD *)v7 + 48), (uint64_t)&v22, 2);
          v6 = v2[1];
          *(_DWORD *)(v6 + 72) = 0;
          if ((int)result <= 65533)
          {
            a2 = v21;
LABEL_31:
            v17 = v2[6];
            if (v17)
              *(_DWORD *)(v17 + 2 * ((_QWORD)v3 - v2[4])) = v9 - ((char)v7[17] + *((_DWORD *)v2 + 4));
            *v3 = (_WORD)result;
            goto LABEL_34;
          }
          LODWORD(v12) = v12 & 0xFFFF00FF | (v14 << 8);
          if ((_DWORD)result == 65534)
            v20 = 10;
          else
            v20 = 12;
          *v21 = v20;
          if (v12 >= 0x100)
          {
LABEL_59:
            *(_BYTE *)(v6 + 65) = BYTE1(v12);
            *(_BYTE *)(v2[1] + 66) = v12;
            v18 = v2[1];
            goto LABEL_38;
          }
LABEL_56:
          ++v11;
        }
        *(_BYTE *)(v6 + 65) = v12;
        *(_BYTE *)(v2[1] + 64) = 1;
LABEL_47:
        v5 = v11;
        goto LABEL_40;
      }
      if ((_DWORD)v12 == 126)
        goto LABEL_15;
      *(_DWORD *)(v6 + 72) = v12 | 0x100;
      v7[19] = 0;
LABEL_19:
      ++v9;
      if ((unint64_t)v10 >= v4)
        goto LABEL_39;
    }
    *(_DWORD *)(v6 + 76) = 0;
    if ((int)v12 <= 124)
    {
      if ((_DWORD)v12 == 10)
        goto LABEL_19;
      if ((_DWORD)v12 != 123)
        goto LABEL_41;
      goto LABEL_17;
    }
    if ((_DWORD)v12 == 125)
    {
LABEL_17:
      v7[17] = (_DWORD)v12 == 123;
      if (v7[19])
      {
        v7[19] = 0;
        *a2 = 18;
        *(_DWORD *)(v6 + 284) = 2;
        *(_BYTE *)(v6 + 65) = 126;
        *(_BYTE *)(v2[1] + 66) = v12;
        v18 = v2[1];
LABEL_38:
        *(_BYTE *)(v18 + 64) = 2;
LABEL_39:
        v5 = v11 + 1;
        break;
      }
      v7[19] = 1;
      goto LABEL_19;
    }
    if ((_DWORD)v12 != 126)
    {
LABEL_41:
      v7[19] = 0;
      *a2 = 18;
      *(_BYTE *)(v6 + 65) = 126;
      if (v7[17])
      {
        if ((v12 - 33) >= 0x5E)
        {
LABEL_43:
          ++v11;
          *(_BYTE *)(v2[1] + 66) = v12;
          v19 = 2;
LABEL_46:
          *(_BYTE *)(v2[1] + 64) = v19;
          goto LABEL_47;
        }
      }
      else if ((v12 & 0x80) != 0)
      {
        goto LABEL_43;
      }
      v19 = 1;
      goto LABEL_46;
    }
    v16 = v2[6];
    if (v16)
      *(_DWORD *)(v16 + 2 * ((_QWORD)v3 - v2[4])) = ~*((_DWORD *)v2 + 4) + v9;
    *v3 = 126;
    v7[19] = 0;
LABEL_34:
    ++v3;
    v5 = v11 + 1;
    if ((unint64_t)(v11 + 1) < v4)
      continue;
    break;
  }
LABEL_40:
  v2[4] = v3;
  v2[2] = v5;
  return result;
}

uint64_t sub_18BC23864(uint64_t a1, int *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _BYTE *v11;
  int v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  BOOL v26;
  uint64_t v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _BYTE *v53;
  unint64_t v54;
  unsigned int v55;

  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_DWORD *)(a1 + 40) - v5;
  result = *(_QWORD *)(a1 + 16);
  v8 = *(_QWORD *)(a1 + 8);
  v9 = v4 - result;
  v10 = (unint64_t)v9 >> 1;
  v11 = *(_BYTE **)(v8 + 16);
  LOBYTE(v12) = v11[18];
  LODWORD(v13) = *(_DWORD *)(v8 + 84);
  if ((_DWORD)v13)
    v14 = v6 <= 0;
  else
    v14 = 1;
  if (!v14)
  {
    LODWORD(v45) = 0;
    LODWORD(v46) = 0;
    result = 0;
    goto LABEL_65;
  }
  if ((int)v10 < 1)
  {
    LODWORD(v45) = 0;
    LODWORD(v15) = 0;
    goto LABEL_76;
  }
  v15 = 0;
  LODWORD(v45) = 0;
  v16 = *(_DWORD **)(a1 + 48);
  v17 = (int)(v9 >> 1);
  v18 = v11[18];
  while (2)
  {
    v19 = (int)v45;
    v46 = v15;
    while (1)
    {
      v55 = 0xFFFF;
      if ((int)v46 >= v6)
      {
        *a2 = 15;
        LODWORD(v45) = v19;
        goto LABEL_75;
      }
      v45 = v19 + 1;
      v13 = *(unsigned __int16 *)(result + 2 * v19);
      if ((_DWORD)v13 != 126)
        break;
      v20 = 0;
      do
      {
        v21 = asc_18BE2F134[v20];
        if ((int)v46 >= v6)
        {
          v22 = *(_QWORD *)(a1 + 8);
          v23 = *(char *)(v22 + 91);
          *(_BYTE *)(v22 + 91) = v23 + 1;
          *(_BYTE *)(v22 + v23 + 104) = v21;
          *a2 = 15;
        }
        else
        {
          *(_BYTE *)(*(_QWORD *)(a1 + 32) + (int)v46) = v21;
          if (*(_QWORD *)(a1 + 48))
            *v16++ = v19;
          v46 = (v46 + 1);
        }
        ++v20;
      }
      while ((_DWORD)v20 != 2);
      ++v19;
      if (v45 >= v17)
        goto LABEL_75;
    }
    v54 = v10;
    v24 = *(unsigned __int16 *)(result + 2 * v19);
    if (v13 >= 0x80)
    {
      v50 = v17;
      v51 = result;
      v52 = v5;
      v53 = v11;
      v49 = v18;
      v25 = sub_18BC28B6C(*(_QWORD *)(*(_QWORD *)v11 + 48), v13, (int *)&v55, *(char *)(*(_QWORD *)(a1 + 8) + 63));
      v18 = v49;
      v5 = v52;
      v11 = v53;
      v26 = v25 == 2;
      v17 = v50;
      result = v51;
      if (!v26 || (((_WORD)v55 + 24159) & 0xFFFEu) > 0x5C5D || (((_BYTE)v55 + 95) & 0xFEu) > 0x5D)
        break;
      v24 = v55 - 32896;
    }
    v55 = v24;
    if (v24 != 0xFFFF)
    {
      v12 = v24 > 0xFF;
      v11[18] = v12;
      if (v12 == v18 && v11[16])
      {
        v10 = v54;
      }
      else
      {
        if (v24 <= 0xFF)
        {
          v31 = 0;
          v10 = v54;
          do
          {
            v32 = asc_18BE2F137[v31];
            if ((int)v46 >= v6)
            {
              v33 = *(_QWORD *)(a1 + 8);
              v34 = *(char *)(v33 + 91);
              *(_BYTE *)(v33 + 91) = v34 + 1;
              *(_BYTE *)(v33 + v34 + 104) = v32;
              *a2 = 15;
            }
            else
            {
              *(_BYTE *)(*(_QWORD *)(a1 + 32) + (int)v46) = v32;
              if (*(_QWORD *)(a1 + 48))
                *v16++ = v19;
              v46 = (v46 + 1);
            }
            ++v31;
          }
          while ((_DWORD)v31 != 2);
        }
        else
        {
          v27 = 0;
          v10 = v54;
          do
          {
            v28 = asc_18BE2F13A[v27];
            if ((int)v46 >= v6)
            {
              v29 = *(_QWORD *)(a1 + 8);
              v30 = *(char *)(v29 + 91);
              *(_BYTE *)(v29 + 91) = v30 + 1;
              *(_BYTE *)(v29 + v30 + 104) = v28;
              *a2 = 15;
            }
            else
            {
              *(_BYTE *)(*(_QWORD *)(a1 + 32) + (int)v46) = v28;
              if (*(_QWORD *)(a1 + 48))
                *v16++ = v19;
              v46 = (v46 + 1);
            }
            ++v27;
          }
          while ((_DWORD)v27 != 2);
        }
        v11[16] = 1;
      }
      v35 = v55;
      if (v24 < 0x100)
      {
        if ((int)v46 < v6)
        {
          v15 = (v46 + 1);
          *(_BYTE *)(v5 + (int)v46) = v55;
          if (v16)
            *v16++ = v19;
          goto LABEL_63;
        }
        v41 = *(_QWORD *)(a1 + 8);
        v42 = *(char *)(v41 + 91);
        *(_BYTE *)(v41 + 91) = v42 + 1;
        *(_BYTE *)(v41 + v42 + 104) = v35;
      }
      else
      {
        v36 = v55 >> 8;
        if ((int)v46 < v6)
        {
          v15 = (int)v46 + 1;
          *(_BYTE *)(v5 + (int)v46) = BYTE1(v55);
          if (v16)
          {
            *v16 = v19;
            v35 = v55;
            if ((int)v15 < v6)
            {
              *(_BYTE *)(v5 + v15) = v55;
              v15 = (v46 + 2);
              v16[1] = v19;
              v16 += 2;
              goto LABEL_63;
            }
            ++v16;
          }
          else
          {
            if ((int)v15 < v6)
            {
              v16 = 0;
              *(_BYTE *)(v5 + v15) = v35;
              v15 = (v46 + 2);
              goto LABEL_63;
            }
            v16 = 0;
          }
          v43 = *(_QWORD *)(a1 + 8);
          v44 = *(char *)(v43 + 91);
          *(_BYTE *)(v43 + 91) = v44 + 1;
          *(_BYTE *)(v43 + v44 + 104) = v35;
          *a2 = 15;
LABEL_63:
          v55 = 0xFFFF;
          v18 = v12;
          if ((int)v45 < (int)v10)
            continue;
          goto LABEL_76;
        }
        v37 = *(_QWORD *)(a1 + 8);
        v38 = *(char *)(v37 + 91);
        *(_BYTE *)(v37 + 91) = v38 + 1;
        *(_BYTE *)(v37 + v38 + 104) = v36;
        LOBYTE(v37) = v55;
        v39 = *(_QWORD *)(a1 + 8);
        v40 = *(char *)(v39 + 91);
        *(_BYTE *)(v39 + 91) = v40 + 1;
        *(_BYTE *)(v39 + v40 + 104) = v37;
      }
      *a2 = 15;
      v15 = v46;
      goto LABEL_63;
    }
    break;
  }
  if ((v13 & 0xF800) == 0xD800)
  {
    if ((v13 & 0x400) == 0)
    {
      v8 = *(_QWORD *)(a1 + 8);
      *(_DWORD *)(v8 + 84) = v13;
      result = v13;
      LOBYTE(v12) = v18;
      LODWORD(v10) = v54;
LABEL_65:
      if ((int)v45 >= (int)v10)
      {
        v48 = 0;
      }
      else
      {
        v47 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 2 * (int)v45);
        if ((v47 & 0xFC00) == 0xDC00)
        {
          LODWORD(v45) = v45 + 1;
          LODWORD(v13) = v47 + ((_DWORD)v13 << 10) - 56613888;
          *(_DWORD *)(v8 + 84) = 0;
          v48 = 10;
LABEL_73:
          v18 = v12;
          goto LABEL_74;
        }
        v48 = 12;
      }
      LODWORD(v13) = result;
      goto LABEL_73;
    }
    v48 = 12;
  }
  else
  {
    v48 = 10;
  }
LABEL_74:
  *a2 = v48;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 84) = v13;
LABEL_75:
  LODWORD(v15) = v46;
  LOBYTE(v12) = v18;
LABEL_76:
  *(_QWORD *)(a1 + 32) += (int)v15;
  *(_QWORD *)(a1 + 16) += 2 * (int)v45;
  v11[18] = v12;
  return result;
}

_QWORD *sub_18BC23D34(_QWORD *a1, int a2, int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v7;
  uint64_t vars0;

  v3 = a1[1];
  v4 = *(_QWORD *)(v3 + 16);
  v7 = 0;
  v5 = &v7;
  if (*(_BYTE *)(v4 + 18))
  {
    LOWORD(v7) = 32126;
    v5 = (int *)((char *)&v7 + 2);
    *(_BYTE *)(v4 + 18) = 0;
  }
  *(_BYTE *)v5 = **(_BYTE **)(v3 + 40);
  return ucnv_cbFromUWriteBytes(a1, (char *)&v7, v5 - (&vars0 - 4) + 1, a2, a3);
}

uint64_t sub_18BC23D9C(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  uint64_t v4;
  __int128 *v5;
  __int128 v6;
  int v8;

  if (*a4 > 0)
    return 0;
  if (*a3)
  {
    v4 = a2;
    v5 = *(__int128 **)(a1 + 16);
    v6 = *v5;
    *(_QWORD *)(a2 + 592) = *((_QWORD *)v5 + 2);
    *(_OWORD *)(a2 + 576) = v6;
    *(_QWORD *)(a2 + 16) = a2 + 576;
    *(_BYTE *)(a2 + 62) = 1;
    v8 = 288;
    **(_QWORD **)(a2 + 16) = ucnv_safeClone(**(void (****)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 16), a2 + 288, &v8, a4);
  }
  else
  {
    v4 = 0;
    *a3 = 600;
  }
  return v4;
}

uint64_t sub_18BC23E38(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  ((void (*)(uint64_t, _QWORD, uint64_t))a2[2])(*a2, 0, 127);
  return sub_18BC25E90(*(_QWORD *)(**(_QWORD **)(a1 + 16) + 48), a2, a3, 5, a4);
}

void sub_18BC23E98(uint64_t a1, uint64_t a2, int *a3)
{
  char *v6;
  int v7;
  _DWORD *v8;
  __int16 v9;
  char *v10;
  int v11;
  int v12;

  if (!*(_BYTE *)(a2 + 8))
  {
    v6 = (char *)uprv_malloc(0x30uLL);
    *(_QWORD *)(a1 + 16) = v6;
    if (v6)
    {
      *(_DWORD *)v6 = 65534;
      *(_DWORD *)(a1 + 72) = 0xFFFF;
      v6[25] = 0;
      v7 = *(_DWORD *)(a2 + 12);
      if ((v7 & 0xFu) <= 8)
      {
        v8 = &dword_18BE14140[3 * (v7 & 0xF)];
        v9 = *(_WORD *)v8;
        *(_QWORD *)(v6 + 26) = *(_QWORD *)"ISCII,version=";
        v10 = v6 + 26;
        v9 <<= 7;
        *((_WORD *)v6 + 2) = v9;
        *((_WORD *)v6 + 4) = v9;
        *((_WORD *)v6 + 3) = v9;
        LODWORD(v8) = v8[1];
        *((_DWORD *)v6 + 5) = (_DWORD)v8;
        *((_DWORD *)v6 + 4) = (_DWORD)v8;
        *((_DWORD *)v6 + 3) = (_DWORD)v8;
        v6[24] = 1;
        strcpy(v6 + 33, "ersion=");
        v11 = strlen(v6 + 26);
        v10[v11] = v7 & 0xF | 0x30;
        v10[v11 + 1] = 0;
        *(_DWORD *)(v10 + 18) = 0;
        return;
      }
      uprv_free(v6);
      *(_QWORD *)(a1 + 16) = 0;
      v12 = 1;
    }
    else
    {
      v12 = 7;
    }
    *a3 = v12;
  }
}

void sub_18BC23F98(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 16);
  if (v2)
  {
    if (!*(_BYTE *)(a1 + 62))
      uprv_free(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

uint64_t sub_18BC23FCC(uint64_t result, int a2)
{
  uint64_t v2;
  __int16 v3;
  int v4;

  v2 = *(_QWORD *)(result + 16);
  if (a2 >= 2)
  {
    v4 = *(_DWORD *)(v2 + 20);
    v3 = *(_WORD *)(v2 + 4);
    goto LABEL_5;
  }
  *(_QWORD *)(result + 72) = 0xFFFFLL;
  v3 = *(_WORD *)(v2 + 4);
  *(_WORD *)(v2 + 8) = v3;
  v4 = *(_DWORD *)(v2 + 20);
  *(_DWORD *)(v2 + 16) = v4;
  *(_WORD *)v2 = -2;
  *(_DWORD *)(v2 + 44) = 0;
  if (a2 != 1)
  {
LABEL_5:
    *(_DWORD *)(result + 84) = 0;
    *(_WORD *)(v2 + 2) = 0;
    *(_DWORD *)(v2 + 12) = v4;
    *(_WORD *)(v2 + 6) = v3;
    *(_WORD *)(v2 + 24) = 1;
  }
  return result;
}

uint64_t sub_18BC2402C(uint64_t result, int *a2)
{
  uint64_t v2;
  unint64_t v3;
  __int16 *v4;
  unint64_t v5;
  __int16 *v6;
  int v7;
  uint64_t v9;
  int v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  _WORD *v18;
  int v19;
  __int16 v20;
  char v21;
  int v22;
  _DWORD *v23;
  __int16 v24;
  _DWORD *v25;
  int v26;
  int v27;
  _DWORD *v28;
  __int16 v29;
  _DWORD *v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  _DWORD *v35;
  __int16 v36;
  int v37;
  int v38;
  uint64_t v39;
  _DWORD *v40;
  uint64_t v41;
  int v42;
  int v43;
  _DWORD *v44;
  uint64_t v45;
  char *v46;
  int v47;
  _DWORD *v48;
  int v50;
  int v51;
  int v52;
  BOOL v53;
  int v54;
  _DWORD *v55;
  _DWORD *v56;
  uint64_t v57;
  int v58;
  __int16 v59;
  _DWORD *v60;
  _DWORD *v61;
  uint64_t v62;
  uint64_t v63;
  _DWORD *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  __int16 *v68;
  _DWORD *v69;
  _DWORD *v70;
  _DWORD *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  BOOL v76;
  uint64_t v77;
  int v78;
  int v79;
  int v81;
  _DWORD *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;

  v2 = *(_QWORD *)(result + 8);
  if (!v2)
  {
    *a2 = 1;
    return result;
  }
  v3 = *(_QWORD *)(result + 24);
  v4 = *(__int16 **)(result + 32);
  v5 = *(_QWORD *)(result + 16);
  v6 = *(__int16 **)(v2 + 16);
  v7 = *a2;
  if (*a2 > 0 || v5 >= v3)
  {
    v9 = *(_QWORD *)(result + 8);
    v13 = *(_QWORD *)(result + 16);
    goto LABEL_209;
  }
  v10 = ~*(_DWORD *)(result + 16);
  v11 = -*(_DWORD *)(result + 16);
  v12 = *(_QWORD *)(result + 40);
  v13 = *(_QWORD *)(result + 16);
  while (2)
  {
    v14 = 0;
    while (1)
    {
      if ((unint64_t)v4 >= v12)
      {
        *a2 = 15;
        goto LABEL_210;
      }
      v15 = v14;
      v16 = *(unsigned __int8 *)(v13 + v14);
      v17 = (unsigned __int16)*v6;
      if (v17 != 239)
        break;
      if ((v16 - 66) <= 9)
      {
        v18 = (_WORD *)((char *)&unk_18BE141AC + 4 * (v16 & 0xF));
        v6[4] = *v18 << 7;
        v19 = (unsigned __int16)v18[1];
LABEL_16:
        *((_DWORD *)v6 + 4) = v19;
        goto LABEL_18;
      }
      if ((_DWORD)v16 == 64)
      {
        v6[4] = v6[2];
        v19 = *((_DWORD *)v6 + 5);
        goto LABEL_16;
      }
      if ((v16 - 33) >= 0x1F)
      {
        *a2 = 12;
        *v6 = -2;
        goto LABEL_208;
      }
LABEL_18:
      *v6 = -2;
      v14 = v15 + 1;
      if (v13 + v15 + 1 >= v3)
      {
        v13 += v15 + 1;
        goto LABEL_203;
      }
    }
    if (v17 == 217)
    {
      v27 = *((_DWORD *)v6 + 11);
      if (v27)
      {
        *v4++ = v27;
        v28 = *(_DWORD **)(result + 48);
        if (v28)
        {
          *v28 = v13 - v5 + v15;
          *(_QWORD *)(result + 48) = v28 + 1;
        }
        *((_DWORD *)v6 + 11) = 0;
      }
      if ((_DWORD)v16 == 232)
        v29 = 32;
      else
        v29 = 8205;
      if ((unint64_t)v4 >= v12)
      {
        v31 = *(char *)(v2 + 93);
        *(_BYTE *)(v2 + 93) = v31 + 1;
        *(_WORD *)(v2 + 2 * v31 + 144) = v29;
        v7 = 15;
        *a2 = 15;
      }
      else
      {
        *v4++ = v29;
        v30 = *(_DWORD **)(result + 48);
        if (v30)
        {
          *v30 = ~(_DWORD)v5 + v13 + v15;
          *(_QWORD *)(result + 48) = v30 + 1;
        }
      }
      v17 = 65534;
      *v6 = -2;
LABEL_52:
      if ((int)v16 <= 223)
      {
        if ((_DWORD)v16 == 10 || (_DWORD)v16 == 13)
        {
          *((_BYTE *)v6 + 25) = 1;
          v32 = word_18BE141DC[v16];
          v36 = v16;
        }
        else
        {
          if ((_DWORD)v16 == 217)
          {
LABEL_59:
            *v6 = v16;
            v33 = *(_DWORD *)(v2 + 72);
            if (v33 == 0xFFFF)
              goto LABEL_172;
            v34 = *((_DWORD *)v6 + 11);
            if (v34)
            {
              if ((unint64_t)v4 >= v12)
              {
                v39 = *(char *)(v2 + 93);
                *(_BYTE *)(v2 + 93) = v39 + 1;
                *(_WORD *)(v2 + 2 * v39 + 144) = v34;
                v7 = 15;
                *a2 = 15;
              }
              else
              {
                *v4++ = v34;
                v35 = *(_DWORD **)(result + 48);
                if (v35)
                {
                  *v35 = v11 + v13 + v15;
                  *(_QWORD *)(result + 48) = v35 + 1;
                }
              }
              *((_DWORD *)v6 + 11) = 0;
              v33 = *(_DWORD *)(v2 + 72);
            }
            if (v33 >= 161 && (v33 - 2404) >= 2 && (v33 - 8204) >= 2)
              LOWORD(v33) = v33 + v6[4];
            if ((unint64_t)v4 >= v12)
            {
              v41 = *(char *)(v2 + 93);
              *(_BYTE *)(v2 + 93) = v41 + 1;
              *(_WORD *)(v2 + 2 * v41 + 144) = v33;
              v7 = 15;
              *a2 = 15;
            }
            else
            {
              *v4++ = v33;
              v40 = *(_DWORD **)(result + 48);
              if (v40)
              {
                *v40 = v10 + v13 + v15;
                *(_QWORD *)(result + 48) = v40 + 1;
              }
            }
            goto LABEL_164;
          }
LABEL_113:
          v32 = word_18BE141DC[v16];
          if (v16 >= 0xA1
            && (*((_DWORD *)v6 + 4) & byte_18BE1441C[v32 & 0x7F]) == 0
            && ((_DWORD)v16 != 208 || v6[4] != 768))
          {
            v32 = 0xFFFF;
          }
          v36 = v16;
        }
      }
      else
      {
        switch((int)v16)
        {
          case 232:
            if (v17 == 232)
            {
              v32 = 8204;
              goto LABEL_71;
            }
            if (*((_BYTE *)v6 + 16))
              v32 = 2381;
            else
              v32 = 0xFFFF;
            v36 = 232;
            break;
          case 233:
            if (v17 == 232)
            {
              v32 = 8205;
LABEL_71:
              v36 = -2;
              break;
            }
            v42 = (unsigned __int16)v6[4];
            if (v17 != 192 || v42 != 256)
            {
              v45 = 0;
              while (1)
              {
                v46 = (char *)&unk_18BE143DC + v45;
                if (*(_WORD *)((char *)&unk_18BE143DC + v45 + 4) == v17)
                  break;
                v45 += 4;
                if (v45 == 60)
                  goto LABEL_113;
              }
              v32 = *((unsigned __int16 *)v46 + 3);
              if ((*((_DWORD *)v6 + 4) & byte_18BE1441C[*((_WORD *)v46 + 3)]) == 0)
                goto LABEL_113;
              *v6 = -2;
              *(_DWORD *)(v2 + 72) = 0xFFFF;
              if (v42 != 256)
                goto LABEL_169;
              v47 = *((_DWORD *)v6 + 11);
              if (v47)
              {
                if ((unint64_t)v4 >= v12)
                {
                  v75 = *(char *)(v2 + 93);
                  *(_BYTE *)(v2 + 93) = v75 + 1;
                  *(_WORD *)(v2 + 2 * v75 + 144) = v47;
                  v7 = 15;
                  *a2 = 15;
                }
                else
                {
                  *v4++ = v47;
                  v48 = *(_DWORD **)(result + 48);
                  if (v48)
                  {
                    *v48 = v11 + v13 + v15;
                    *(_QWORD *)(result + 48) = v48 + 1;
                  }
                }
                *((_DWORD *)v6 + 11) = 0;
              }
              v76 = (v32 - 2404) >= 2 && (v32 - 8204) >= 2;
              v24 = v32 + 256;
              if (!v76)
                v24 = v32;
              if ((unint64_t)v4 >= v12)
                goto LABEL_229;
              *v4++ = v24;
              v25 = *(_DWORD **)(result + 48);
              if (v25)
              {
                v26 = v10 + v13 + v15;
LABEL_39:
                *v25 = v26;
                *(_QWORD *)(result + 48) = v25 + 1;
              }
LABEL_172:
              v13 += v15 + 1;
              if (v7 > 0 || v13 >= v3)
              {
LABEL_203:
                v9 = v2;
LABEL_209:
                if (v7 <= 0 && *(_BYTE *)(result + 2) && v13 == v3)
                {
                  v79 = (unsigned __int16)*v6;
                  if ((v79 - 217) > 0x17 || ((1 << (v79 + 39)) & 0xC00001) == 0)
                  {
                    *(_BYTE *)(v9 + 64) = 0;
                  }
                  else
                  {
                    *(_BYTE *)(v9 + 65) = v79;
                    *(_BYTE *)(v9 + 64) = 1;
                    *v6 = -2;
                  }
                  v81 = *(_DWORD *)(v2 + 72);
                  if (v81 != 0xFFFF)
                  {
                    if (v81 >= 161 && (v81 - 2404) >= 2 && (v81 - 8204) >= 2)
                      LOWORD(v81) = v81 + v6[4];
                    if ((unint64_t)v4 >= *(_QWORD *)(result + 40))
                    {
                      v83 = *(_QWORD *)(result + 8);
                      v84 = *(char *)(v83 + 93);
                      *(_BYTE *)(v83 + 93) = v84 + 1;
                      *(_WORD *)(v83 + 2 * v84 + 144) = v81;
                      *a2 = 15;
                    }
                    else
                    {
                      *v4++ = v81;
                      v82 = *(_DWORD **)(result + 48);
                      if (v82)
                      {
                        *v82 = ~*(_DWORD *)(result + 16) + v3;
                        *(_QWORD *)(result + 48) = v82 + 1;
                      }
                    }
                    *(_DWORD *)(v2 + 72) = 0xFFFF;
                  }
                }
                goto LABEL_210;
              }
              continue;
            }
            v43 = *((_DWORD *)v6 + 11);
            if (v43)
            {
              if ((unint64_t)v4 >= v12)
              {
                v67 = *(char *)(v2 + 93);
                *(_BYTE *)(v2 + 93) = v67 + 1;
                *(_WORD *)(v2 + 2 * v67 + 144) = v43;
                v7 = 15;
                *a2 = 15;
              }
              else
              {
                *v4++ = v43;
                v44 = *(_DWORD **)(result + 48);
                if (v44)
                {
                  *v44 = v11 + v13 + v15;
                  *(_QWORD *)(result + 48) = v44 + 1;
                }
              }
              *((_DWORD *)v6 + 11) = 0;
            }
            if ((unint64_t)v4 >= v12)
            {
              v72 = *(char *)(v2 + 93);
              *(_BYTE *)(v2 + 93) = v72 + 1;
              *(_WORD *)(v2 + 2 * v72 + 144) = 2652;
              v7 = 15;
              *a2 = 15;
              v68 = v4;
            }
            else
            {
              *v4 = 2652;
              v68 = v4 + 1;
              v69 = *(_DWORD **)(result + 48);
              if (v69)
              {
                *v69 = v10 + v13 + v15;
                *(_QWORD *)(result + 48) = v69 + 1;
              }
              if (v7 <= 0)
              {
                if ((unint64_t)v68 >= v12)
                {
                  v74 = *(char *)(v2 + 93);
                  *(_WORD *)(v2 + 144 + 2 * v74) = 2637;
                  v7 = 15;
                  *a2 = 15;
                  *(_BYTE *)(v2 + 93) = v74 + 2;
                  *(_WORD *)(v2 + 144 + 2 * (char)(v74 + 1)) = 2617;
                }
                else
                {
                  v4[1] = 2637;
                  v70 = *(_DWORD **)(result + 48);
                  if (v70)
                  {
                    *v70 = v10 + v13 + v15;
                    *(_QWORD *)(result + 48) = v70 + 1;
                  }
                  v68 = v4 + 2;
                  if ((unint64_t)(v4 + 2) >= v12)
                  {
                    v77 = *(char *)(v2 + 93);
                    *(_BYTE *)(v2 + 93) = v77 + 1;
                    *(_WORD *)(v2 + 2 * v77 + 144) = 2617;
                    v7 = 15;
                    *a2 = 15;
                  }
                  else
                  {
                    v68 = v4 + 3;
                    v4[2] = 2617;
                    v71 = *(_DWORD **)(result + 48);
                    if (v71)
                    {
                      *v71 = v10 + v13 + v15;
                      *(_QWORD *)(result + 48) = v71 + 1;
                    }
                  }
                }
                goto LABEL_189;
              }
            }
            v73 = *(char *)(v2 + 93);
            *(_WORD *)(v2 + 144 + 2 * v73) = 2637;
            *(_BYTE *)(v2 + 93) = v73 + 2;
            *(_WORD *)(v2 + 144 + 2 * (char)(v73 + 1)) = 2617;
LABEL_189:
            *(_DWORD *)(v2 + 72) = 0xFFFF;
            *v6 = -2;
            v4 = v68;
            goto LABEL_172;
          case 234:
            if (v17 == 234)
            {
              v32 = 2405;
              goto LABEL_74;
            }
            if ((v6[8] & 0x80) != 0)
              v32 = 2404;
            else
              v32 = 0xFFFF;
            v36 = 234;
            break;
          case 235:
          case 236:
          case 237:
          case 238:
            goto LABEL_113;
          case 239:
          case 240:
            goto LABEL_59;
          default:
            if ((_DWORD)v16 != 224)
              goto LABEL_113;
            v37 = v17;
            v38 = *((_DWORD *)v6 + 4);
            if (v37 == 164 && (v38 & 0x80) != 0)
            {
              v32 = 2308;
LABEL_74:
              *v6 = -2;
              goto LABEL_170;
            }
            if ((v38 & 0x87) != 0)
              v32 = 2374;
            else
              v32 = 0xFFFF;
            v36 = 224;
            break;
        }
      }
      *v6 = v36;
      v50 = *(_DWORD *)(v2 + 72);
      if (v50 == 0xFFFF)
        goto LABEL_169;
      v51 = (unsigned __int16)v6[4];
      v52 = *((_DWORD *)v6 + 11);
      if (v51 != 256 || (v52 - 2560) > 0x4F)
      {
        if (!v52)
          goto LABEL_139;
        goto LABEL_134;
      }
      if (v50 != 2381 || ((byte_18BE1449C[v52 - 2560] & 1) != 0 ? (v53 = v32 + 256 == v52) : (v53 = 0), !v53))
      {
LABEL_134:
        if ((unint64_t)v4 >= v12)
        {
          v57 = *(char *)(v2 + 93);
          *(_BYTE *)(v2 + 93) = v57 + 1;
          *(_WORD *)(v2 + 2 * v57 + 144) = v52;
          v7 = 15;
          *a2 = 15;
        }
        else
        {
          *v4++ = v52;
          v56 = *(_DWORD **)(result + 48);
          if (v56)
          {
            *v56 = v11 + v13 + v15;
            *(_QWORD *)(result + 48) = v56 + 1;
          }
        }
        *((_DWORD *)v6 + 11) = 0;
LABEL_139:
        if (v51 == 256 && v32 == 2306)
        {
          v58 = *(_DWORD *)(v2 + 72);
          if ((v58 - 2384) >= 0xFFFFFFB0 && byte_18BE1449C[v58 - 2304] >= 2u)
          {
            v59 = v58 + 256;
            if ((unint64_t)v4 >= v12)
            {
              v66 = *(char *)(v2 + 93);
              *(_BYTE *)(v2 + 93) = v66 + 1;
              *(_WORD *)(v2 + 2 * v66 + 144) = v59;
              v7 = 15;
              *a2 = 15;
            }
            else
            {
              *v4++ = v59;
              v60 = *(_DWORD **)(result + 48);
              if (v60)
              {
                *v60 = v10 + v13 + v15;
                *(_QWORD *)(result + 48) = v60 + 1;
              }
            }
            v32 = 2416;
            goto LABEL_168;
          }
        }
        else
        {
          v58 = *(_DWORD *)(v2 + 72);
          if (v51 == 256
            && v32 == 2381
            && (v58 - 2384) >= 0xFFFFFFB0
            && (byte_18BE1449C[v58 - 2304] & 1) != 0)
          {
            *((_DWORD *)v6 + 11) = v58 + 256;
            v32 = 2381;
LABEL_168:
            *(_DWORD *)(v2 + 72) = 0xFFFF;
LABEL_169:
            if (v32 == 0xFFFF)
              goto LABEL_205;
LABEL_170:
            *(_DWORD *)(v2 + 72) = v32;
            if (*((_BYTE *)v6 + 25))
            {
              v6[4] = v6[2];
              *((_DWORD *)v6 + 4) = *((_DWORD *)v6 + 5);
              *((_BYTE *)v6 + 25) = 0;
            }
            goto LABEL_172;
          }
        }
        if (v58 >= 161 && (v58 - 2404) >= 2 && (v58 - 8204) >= 2)
        {
          v58 += v51;
          *(_DWORD *)(v2 + 72) = v58;
        }
        if ((unint64_t)v4 >= v12)
        {
          v62 = *(char *)(v2 + 93);
          *(_BYTE *)(v2 + 93) = v62 + 1;
          *(_WORD *)(v2 + 2 * v62 + 144) = v58;
          v7 = 15;
          *a2 = 15;
        }
        else
        {
          *v4++ = v58;
          v61 = *(_DWORD **)(result + 48);
          if (v61)
          {
            *v61 = v10 + v13 + v15;
            *(_QWORD *)(result + 48) = v61 + 1;
          }
        }
        goto LABEL_168;
      }
      v54 = -2 - v5 + v13 + v15;
      if ((unint64_t)v4 >= v12)
      {
        v63 = *(char *)(v2 + 93);
        *(_BYTE *)(v2 + 93) = v63 + 1;
        *(_WORD *)(v2 + 2 * v63 + 144) = 2673;
        v7 = 15;
        *a2 = 15;
      }
      else
      {
        *v4++ = 2673;
        v55 = *(_DWORD **)(result + 48);
        if (v55)
        {
          *v55 = v54;
          *(_QWORD *)(result + 48) = v55 + 1;
          v52 = *((_DWORD *)v6 + 11);
        }
      }
      if ((unint64_t)v4 >= v12)
      {
        v65 = *(char *)(v2 + 93);
        *(_BYTE *)(v2 + 93) = v65 + 1;
        *(_WORD *)(v2 + 2 * v65 + 144) = v52;
        v7 = 15;
        *a2 = 15;
      }
      else
      {
        *v4++ = v52;
        v64 = *(_DWORD **)(result + 48);
        if (v64)
        {
          *v64 = v54;
          *(_QWORD *)(result + 48) = v64 + 1;
        }
      }
      *((_DWORD *)v6 + 11) = 0;
LABEL_164:
      *(_DWORD *)(v2 + 72) = 0xFFFF;
      goto LABEL_172;
    }
    break;
  }
  if (v17 != 240)
    goto LABEL_52;
  if ((v16 + 95) > 0x4Du)
  {
    *v6 = -2;
    v78 = 12;
LABEL_207:
    *a2 = v78;
LABEL_208:
    *(_BYTE *)(v2 + 65) = v16;
    v9 = *(_QWORD *)(result + 8);
    *(_BYTE *)(v9 + 64) = 1;
    v7 = *a2;
    v13 += v15 + 1;
    goto LABEL_209;
  }
  if ((_DWORD)v16 != 191 && (_DWORD)v16 != 184
    || ((_DWORD)v16 != 191 ? (v20 = 2386) : (v20 = 2416),
        (_DWORD)v16 != 191 ? (v21 = 82) : (v21 = 112),
        (*((_DWORD *)v6 + 4) & byte_18BE1441C[v21 & 0xFE]) == 0))
  {
LABEL_205:
    v78 = 10;
    goto LABEL_207;
  }
  *v6 = -2;
  v22 = *((_DWORD *)v6 + 11);
  if (v22)
  {
    *v4++ = v22;
    v23 = *(_DWORD **)(result + 48);
    if (v23)
    {
      *v23 = v13 - v5 + v15;
      *(_QWORD *)(result + 48) = v23 + 1;
    }
    *((_DWORD *)v6 + 11) = 0;
  }
  v24 = v6[4] + v20;
  if ((unint64_t)v4 < v12)
  {
    *v4++ = v24;
    v25 = *(_DWORD **)(result + 48);
    if (v25)
    {
      v26 = ~(_DWORD)v5 + v13 + v15;
      goto LABEL_39;
    }
    goto LABEL_172;
  }
LABEL_229:
  v85 = *(char *)(v2 + 93);
  *(_BYTE *)(v2 + 93) = v85 + 1;
  *(_WORD *)(v2 + 2 * v85 + 144) = v24;
  *a2 = 15;
  v13 += v15 + 1;
LABEL_210:
  *(_QWORD *)(result + 32) = v4;
  *(_QWORD *)(result + 16) = v13;
  return result;
}

_QWORD *sub_18BC24B78(_QWORD *result, int *a2)
{
  unint64_t v2;
  _BYTE *v3;
  unint64_t v4;
  uint64_t v5;
  unsigned __int16 *v6;
  BOOL v7;
  unsigned int v9;
  _BYTE *v10;
  int v11;
  BOOL v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  _DWORD *v17;
  uint64_t v18;
  unsigned __int16 *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  int v30;
  unsigned __int16 v31;
  int v32;
  unsigned __int16 v33;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unsigned int v44;
  unint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;

  v2 = result[3];
  v3 = (_BYTE *)result[4];
  v4 = result[5];
  v5 = result[1];
  v6 = (unsigned __int16 *)result[2];
  if (v5)
    v7 = v4 >= (unint64_t)v3;
  else
    v7 = 0;
  if (!v7 || v2 < (unint64_t)v6)
  {
    *a2 = 1;
    return result;
  }
  v9 = *(_DWORD *)(v5 + 84);
  if (v9)
  {
    v10 = (_BYTE *)result[4];
LABEL_11:
    if ((unint64_t)v6 >= v2)
    {
      v14 = 0;
    }
    else
    {
      v11 = *v6;
      v12 = (v11 & 0xFC00) == 56320;
      v13 = v11 + (v9 << 10) - 56613888;
      if ((v11 & 0xFC00) == 0xDC00)
        v14 = 10;
      else
        v14 = 12;
      v6 += v12;
      if (v12)
        v9 = v13;
    }
LABEL_119:
    *a2 = v14;
    *(_DWORD *)(result[1] + 84) = v9;
    goto LABEL_139;
  }
  if ((unint64_t)v6 >= v2)
    goto LABEL_138;
  v15 = *(_QWORD *)(v5 + 16);
  v16 = *(unsigned __int16 *)(v15 + 6) >> 7;
  v17 = (_DWORD *)result[6];
  while (2)
  {
    v18 = 0;
    v19 = v6;
    while (1)
    {
      v20 = v18;
      v21 = result[1];
      if (*(_DWORD *)(v21 + 80) == 10)
      {
        v22 = dword_18BE14140[3 * (unsigned __int16)v16 + 2];
        *(_DWORD *)(v21 + 80) = 0;
        v6 = (unsigned __int16 *)((char *)v19 + v20);
        if ((unint64_t)v3 >= v4)
        {
          v49 = *(char *)(v21 + 91);
          *(_BYTE *)(v21 + 91) = v49 + 1;
          *(_BYTE *)(v21 + v49 + 104) = -17;
          v50 = result[1];
          v51 = *(char *)(v50 + 91);
          *(_BYTE *)(v50 + 91) = v51 + 1;
          *(_BYTE *)(v50 + v51 + 104) = v22;
          *a2 = 15;
          goto LABEL_138;
        }
        v23 = result[2];
        *v3 = -17;
        v10 = v3 + 1;
        if (v17)
        {
          v24 = (((unint64_t)v6 - v23) >> 1) - 1;
          *v17 = v24;
          if ((unint64_t)v10 >= v4)
            goto LABEL_121;
          *v10 = v22;
          v17[1] = v24;
          v17 += 2;
        }
        else
        {
          if ((unint64_t)v10 >= v4)
          {
LABEL_121:
            v52 = result[1];
            v53 = *(char *)(v52 + 91);
            *(_BYTE *)(v52 + 91) = v53 + 1;
            *(_BYTE *)(v52 + v53 + 104) = v22;
            *a2 = 15;
            v6 = (unsigned __int16 *)((char *)v19 + v20);
            goto LABEL_139;
          }
          v17 = 0;
          *v10 = v22;
        }
        v3 += 2;
        if (*a2 > 0)
        {
          v6 = (unsigned __int16 *)((char *)v19 + v20);
          goto LABEL_138;
        }
      }
      v9 = *(unsigned __int16 *)((char *)v19 + v20);
      if (v9 <= 0xA0)
      {
        v25 = result[1];
        *(_DWORD *)(v25 + 80) = v9;
        v26 = (char *)v19 + v20;
        if ((unint64_t)v3 >= v4)
        {
          v54 = *(char *)(v25 + 91);
          *(_BYTE *)(v25 + 91) = v54 + 1;
          *(_BYTE *)(v25 + v54 + 104) = v9;
          *a2 = 15;
          v6 = (unsigned __int16 *)(v26 + 2);
          goto LABEL_138;
        }
        v27 = result[2];
        *v3++ = v9;
        if (v17)
          *v17++ = ((unint64_t)&v26[-v27 + 2] >> 1) - 1;
        if (*a2 >= 1)
          goto LABEL_137;
        goto LABEL_37;
      }
      v28 = *(unsigned __int16 *)(v15 + 2);
      if (v9 != 8204)
        break;
      *(_WORD *)(v15 + 2) = 0;
      if (v28)
      {
        v9 = 8204;
        v29 = 232;
        goto LABEL_78;
      }
LABEL_37:
      v18 = v20 + 2;
      if ((unint64_t)v19 + v20 + 2 >= v2)
        goto LABEL_137;
    }
    if (v9 != 8205)
    {
      if (v9 - 2304 > 0x47F)
      {
        v29 = 0xFFFF;
        goto LABEL_58;
      }
      if (v9 - 2406 > 0xFFFFFFFD)
      {
        v32 = 0;
      }
      else
      {
        if ((int)(v9 - 2304) >= 0)
          v30 = v9 - 2304;
        else
          v30 = v9 - 2177;
        v16 = v30 >> 7;
        v31 = v30 & 0xFF80;
        if ((v30 & 0xFF80) == *(unsigned __int16 *)(v15 + 6) && !*(_BYTE *)(v15 + 24))
        {
          v32 = 0;
        }
        else
        {
          *(_WORD *)(v15 + 6) = v31;
          *(_DWORD *)(v15 + 12) = dword_18BE14140[3 * (unsigned __int16)(v30 >> 7) + 1];
          *(_BYTE *)(v15 + 24) = 0;
          v32 = 1;
        }
        if ((v30 & 0xFF80) == 0x100)
        {
          if (v9 == 2672)
          {
            v9 = 2562;
          }
          else if (v9 == 2673)
          {
            v9 = 2673;
            *(_WORD *)(v15 + 2) = 2673;
          }
        }
        v9 -= v31;
      }
      v33 = word_18BE144EC[v9];
      if ((*(_DWORD *)(v15 + 12) & byte_18BE1441C[v9]) == 0
        && (*(_WORD *)(v15 + 6) != 768 || v9 != 2353))
      {
        v33 = -1;
      }
      v29 = v33;
      if (!v32)
      {
LABEL_101:
        if (v9 == 2417 && *(_WORD *)(v15 + 6) == 256)
        {
LABEL_113:
          v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
          if ((unint64_t)v6 < v2)
            continue;
          goto LABEL_137;
        }
LABEL_58:
        *(_WORD *)(v15 + 2) = 0;
        goto LABEL_78;
      }
      v35 = dword_18BE14140[3 * (unsigned __int16)v16 + 2];
      if ((unint64_t)v3 >= v4)
      {
        v38 = result[1];
        v39 = *(char *)(v38 + 91);
        *(_BYTE *)(v38 + 91) = v39 + 1;
        *(_BYTE *)(v38 + v39 + 104) = -17;
        v40 = result[1];
        v41 = *(char *)(v40 + 91);
        *(_BYTE *)(v40 + 91) = v41 + 1;
        *(_BYTE *)(v40 + v41 + 104) = v35;
        *a2 = 15;
        goto LABEL_78;
      }
      v36 = result[2];
      *v3 = -17;
      v10 = v3 + 1;
      if (v17)
      {
        v37 = (((unint64_t)v19 + v20 - v36 + 2) >> 1) - 1;
        *v17 = v37;
        if ((unint64_t)v10 < v4)
        {
          *v10 = v35;
          v17[1] = v37;
          v17 += 2;
          goto LABEL_77;
        }
        ++v17;
      }
      else
      {
        if ((unint64_t)v10 < v4)
        {
          v17 = 0;
          *v10 = v35;
LABEL_77:
          v3 += 2;
          if (*a2 > 0)
            goto LABEL_78;
          goto LABEL_101;
        }
        v17 = 0;
      }
      v47 = result[1];
      v48 = *(char *)(v47 + 91);
      *(_BYTE *)(v47 + 91) = v48 + 1;
      *(_BYTE *)(v47 + v48 + 104) = v35;
      *a2 = 15;
      goto LABEL_79;
    }
    break;
  }
  if (*(_WORD *)(v15 + 2))
    v29 = 233;
  else
    v29 = 217;
  *(_WORD *)(v15 + 2) = 0;
  v9 = 8205;
LABEL_78:
  v10 = v3;
LABEL_79:
  if (*(_WORD *)(v15 + 6) == 256 && v28 == 2673 && v9 - 2384 >= 0xFFFFFFB0 && (byte_18BE1449C[v9 - 2304] & 1) != 0)
  {
    *(_WORD *)(v15 + 2) = 0;
    v43 = v29 | (v29 << 16);
    v44 = v43 | 0xE800;
    if ((unint64_t)v10 >= v4)
    {
      v56 = result[1];
      v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
      if ((v43 & 0xFF0000) != 0)
      {
        v57 = *(char *)(v56 + 91);
        *(_BYTE *)(v56 + 91) = v57 + 1;
        *(_BYTE *)(v56 + v57 + 104) = BYTE2(v43);
        v56 = result[1];
      }
      v58 = *(char *)(v56 + 91);
      *(_BYTE *)(v56 + 91) = v58 + 1;
      *(_BYTE *)(v56 + v58 + 104) = BYTE1(v44);
      v59 = result[1];
      v60 = *(char *)(v59 + 91);
      *(_BYTE *)(v59 + 91) = v60 + 1;
      *(_BYTE *)(v59 + v60 + 104) = v29;
      *a2 = 15;
      goto LABEL_139;
    }
    v45 = ((unint64_t)v19 + v20 - result[2] + 2) >> 1;
    v46 = v45 - 1;
    if (v44 >= 0x10000)
    {
      *v10++ = BYTE2(v43);
      if (!v17)
      {
        if ((unint64_t)v10 < v4)
        {
          v17 = 0;
          *v10 = BYTE1(v44);
LABEL_108:
          if ((unint64_t)(v10 + 1) >= v4)
          {
            v65 = result[1];
            v66 = *(char *)(v65 + 91);
            *(_BYTE *)(v65 + 91) = v66 + 1;
            *(_BYTE *)(v65 + v66 + 104) = v29;
            *a2 = 15;
            v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
            ++v10;
            goto LABEL_139;
          }
          v10[1] = v29;
          if (v17)
            *v17++ = v46;
          v3 = v10 + 2;
          goto LABEL_112;
        }
LABEL_132:
        v55 = v44 >> 8;
        goto LABEL_133;
      }
      v46 = v45 - 2;
      *v17++ = v45 - 2;
    }
    if ((unint64_t)v10 < v4)
    {
      *v10 = BYTE1(v44);
      if (v17)
        *v17++ = v46;
      goto LABEL_108;
    }
    goto LABEL_132;
  }
  if (v29 == 232)
  {
    *(_WORD *)(v15 + 2) = 232;
    if ((unint64_t)v10 < v4)
    {
      v42 = (((unint64_t)v19 + v20 - result[2] + 2) >> 1) - 1;
LABEL_92:
      *v10 = v29;
      v3 = v10 + 1;
      if (v17)
        *v17++ = v42;
      goto LABEL_112;
    }
    goto LABEL_134;
  }
  if (v29 == 0xFFFF)
  {
    v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
    if (v9 >> 11 == 27)
    {
      if ((v9 & 0x400) == 0)
        goto LABEL_11;
      v14 = 12;
    }
    else
    {
      v14 = 10;
    }
    goto LABEL_119;
  }
  if ((unint64_t)v10 >= v4)
  {
    if ((v29 & 0xFF00) != 0)
    {
      v55 = v29 >> 8;
LABEL_133:
      v61 = result[1];
      v62 = *(char *)(v61 + 91);
      *(_BYTE *)(v61 + 91) = v62 + 1;
      *(_BYTE *)(v61 + v62 + 104) = v55;
    }
LABEL_134:
    v63 = result[1];
    v64 = *(char *)(v63 + 91);
    *(_BYTE *)(v63 + 91) = v64 + 1;
    *(_BYTE *)(v63 + v64 + 104) = v29;
    *a2 = 15;
    v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
    goto LABEL_139;
  }
  v42 = (((unint64_t)v19 + v20 - result[2] + 2) >> 1) - 1;
  if (v29 <= 0xFF)
    goto LABEL_92;
  *v10 = BYTE1(v29);
  v3 = v10 + 1;
  if (!v17)
  {
    if ((unint64_t)v3 >= v4)
      goto LABEL_136;
    v17 = 0;
    v3 = v10 + 2;
    v10[1] = v29;
LABEL_112:
    if (*a2 >= 1)
      goto LABEL_137;
    goto LABEL_113;
  }
  *v17 = v42;
  if ((unint64_t)v3 < v4)
  {
    v3 = v10 + 2;
    v10[1] = v29;
    v17[1] = v42;
    v17 += 2;
    goto LABEL_112;
  }
LABEL_136:
  v67 = result[1];
  v68 = *(char *)(v67 + 91);
  *(_BYTE *)(v67 + 91) = v68 + 1;
  *(_BYTE *)(v67 + v68 + 104) = v29;
  *a2 = 15;
LABEL_137:
  v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
LABEL_138:
  v10 = v3;
LABEL_139:
  result[2] = v6;
  result[4] = v10;
  return result;
}

uint64_t sub_18BC25328(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
    return v1 + 26;
  else
    return 0;
}

uint64_t sub_18BC2533C(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  __int128 *v4;
  __int128 v5;
  __int128 v6;

  if (*a4 > 0)
    return 0;
  if (*a3)
  {
    v4 = *(__int128 **)(a1 + 16);
    v5 = *v4;
    v6 = v4[2];
    *(_OWORD *)(a2 + 304) = v4[1];
    *(_OWORD *)(a2 + 320) = v6;
    *(_OWORD *)(a2 + 288) = v5;
    *(_QWORD *)(a2 + 16) = a2 + 288;
    *(_BYTE *)(a2 + 62) = 1;
  }
  else
  {
    a2 = 0;
    *a3 = 336;
  }
  return a2;
}

uint64_t sub_18BC25394(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  _BOOL4 v8;

  ((void (*)(_QWORD, _QWORD, uint64_t))a2[2])(*a2, 0, 160);
  v3 = 0;
  v4 = 2304;
  do
  {
    v5 = 0;
    v6 = dword_18BE14140[3 * v3 + 1];
    do
    {
      v8 = v3 == 6 && v5 == 49;
      if ((v6 & byte_18BE1441C[v5]) != 0 || v8)
        ((void (*)(_QWORD, _QWORD))a2[1])(*a2, (v4 + v5));
      ++v5;
    }
    while (v5 != 128);
    ++v3;
    v4 += 128;
  }
  while (v3 != 9);
  ((void (*)(_QWORD, uint64_t))a2[1])(*a2, 2404);
  ((void (*)(_QWORD, uint64_t))a2[1])(*a2, 2405);
  ((void (*)(_QWORD, uint64_t))a2[1])(*a2, 8204);
  return ((uint64_t (*)(_QWORD, uint64_t))a2[1])(*a2, 8205);
}

uint64_t sub_18BC25484(uint64_t result, _DWORD *a2)
{
  unsigned __int8 *v2;
  _WORD *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int8x16_t v11;
  unsigned int v12;
  unsigned int v13;
  __int16 v14;

  v2 = *(unsigned __int8 **)(result + 16);
  v3 = *(_WORD **)(result + 32);
  v4 = (*(_QWORD *)(result + 40) - (_QWORD)v3) >> 1;
  v5 = *(_QWORD *)(result + 48);
  v6 = *(_DWORD *)(result + 24) - (_DWORD)v2;
  if (v6 > (int)v4)
  {
    *a2 = 15;
    v6 = v4;
  }
  if (v6 < 8)
  {
    v12 = 0;
  }
  else
  {
    v7 = v6 >> 3;
    v8 = (v6 >> 3) + 1;
    do
    {
      *v3 = *v2;
      v3[1] = v2[1];
      v3[2] = v2[2];
      v3[3] = v2[3];
      v3[4] = v2[4];
      v3[5] = v2[5];
      v3[6] = v2[6];
      v3[7] = v2[7];
      v3 += 8;
      v2 += 8;
      --v8;
    }
    while (v8 > 1);
    v6 &= 7u;
    if (!v5)
    {
      if (!v6)
      {
        *(_QWORD *)(result + 16) = v2;
        *(_QWORD *)(result + 32) = v3;
        return result;
      }
      v12 = 0;
      v5 = 0;
      goto LABEL_12;
    }
    v9 = 0;
    v10 = v7 + 1;
    do
    {
      v11 = (int8x16_t)vdupq_n_s32(v9);
      *(_DWORD *)v5 = v9;
      *(int8x16_t *)(v5 + 4) = vorrq_s8(v11, (int8x16_t)xmmword_18BE145F0);
      *(int8x8_t *)(v5 + 20) = vorr_s8(*(int8x8_t *)v11.i8, (int8x8_t)0x600000005);
      v12 = v9 + 8;
      *(_DWORD *)(v5 + 28) = v9 + 7;
      v5 += 32;
      --v10;
      v9 += 8;
    }
    while (v10 > 1);
  }
  if (v6 <= 0)
  {
    *(_QWORD *)(result + 16) = v2;
    *(_QWORD *)(result + 32) = v3;
    if (!v5)
      return result;
    goto LABEL_18;
  }
LABEL_12:
  v13 = v6 + 1;
  do
  {
    v14 = *v2++;
    *v3++ = v14;
    --v13;
  }
  while (v13 > 1);
  *(_QWORD *)(result + 16) = v2;
  *(_QWORD *)(result + 32) = v3;
  if (v5)
  {
    do
    {
      *(_DWORD *)v5 = v12;
      v5 += 4;
      ++v12;
      --v6;
    }
    while (v6);
LABEL_18:
    *(_QWORD *)(result + 48) = v5;
  }
  return result;
}

uint64_t sub_18BC255E8(uint64_t result, int *a2)
{
  __int16 *v2;
  uint64_t v3;
  unint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unint64_t v10;
  BOOL v11;
  unsigned int v12;
  __int16 v13;
  __int16 v14;
  __int16 v15;
  __int16 v16;
  __int16 v17;
  __int16 v18;
  __int16 v19;
  __int16 v20;
  __int16 v21;
  __int16 v22;
  __int16 v23;
  __int16 v24;
  __int16 v25;
  __int16 v26;
  __int16 v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  unsigned int v31;
  _BYTE *v32;
  int v33;
  BOOL v34;
  int v35;
  int v36;
  unsigned int v37;
  int32x4_t v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  unsigned __int16 *v42;
  int v43;
  uint64_t v44;
  BOOL v45;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(__int16 **)(result + 16);
  v4 = *(_QWORD *)(result + 24);
  v5 = *(_BYTE **)(result + 32);
  v6 = *(_QWORD *)(result + 48);
  if (*(_UNKNOWN **)(v3 + 48) == &unk_1E2250A98)
    v7 = 255;
  else
    v7 = 127;
  v8 = *(_DWORD *)(v3 + 84);
  if (v8)
    v9 = -1;
  else
    v9 = 0;
  v10 = (v4 - (unint64_t)v2) >> 1;
  if ((int)v10 >= *(_DWORD *)(result + 40) - (int)v5)
    LODWORD(v10) = *(_DWORD *)(result + 40) - (_DWORD)v5;
  if (v8)
    v11 = (int)v10 <= 0;
  else
    v11 = 1;
  if (!v11)
  {
    v32 = *(_BYTE **)(result + 32);
LABEL_19:
    if ((unint64_t)v2 >= v4)
    {
LABEL_40:
      *(_DWORD *)(v3 + 84) = v8;
      goto LABEL_41;
    }
    v33 = (unsigned __int16)*v2;
    v34 = (v33 & 0xFC00) == 56320;
    v35 = v33 + (v8 << 10) - 56613888;
    v2 += v34;
    if (v34)
      v8 = v35;
LABEL_36:
    if (v8 >> 11 == 27)
      v43 = 12;
    else
      v43 = 10;
    *a2 = v43;
    goto LABEL_40;
  }
  if ((int)v10 < 16)
  {
    v32 = *(_BYTE **)(result + 32);
  }
  else
  {
    v12 = (v10 >> 4) + 1;
    v32 = *(_BYTE **)(result + 32);
    while (1)
    {
      v13 = *v2;
      *v32 = *v2;
      v14 = v2[1];
      v32[1] = v14;
      v15 = v2[2];
      v32[2] = v15;
      v16 = v2[3];
      v32[3] = v16;
      v17 = v2[4];
      v32[4] = v17;
      v18 = v2[5];
      v32[5] = v18;
      v19 = v2[6];
      v32[6] = v19;
      v20 = v2[7];
      v32[7] = v20;
      v21 = v2[8];
      v32[8] = v21;
      v22 = v2[9];
      v32[9] = v22;
      v23 = v2[10];
      v32[10] = v23;
      v24 = v2[11];
      v32[11] = v24;
      v25 = v2[12];
      v32[12] = v25;
      v26 = v2[13];
      v32[13] = v26;
      v27 = v2[14];
      v28.i16[0] = v13;
      v28.i16[1] = v14;
      v28.i16[2] = v15;
      v28.i16[3] = v16;
      v28.i16[4] = v17;
      v28.i16[5] = v18;
      v32[14] = v27;
      v28.i16[6] = v19;
      v28.i16[7] = v20;
      v29.i16[0] = v21;
      v29.i16[1] = v22;
      v29.i16[2] = v23;
      v29.i16[3] = v24;
      v29.i16[4] = v25;
      v29.i16[5] = v26;
      v29.i16[6] = v27;
      v29.i16[7] = v2[15];
      v30 = vorrq_s8(v28, v29);
      *(int8x8_t *)v30.i8 = vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
      v32[15] = v29.i8[14];
      if (v7 < (v30.i16[0] | v30.i16[2] | ((v30.i32[0] | v30.i32[1]) >> 16)))
        break;
      v32 += 16;
      v2 += 16;
      if ((int)--v12 <= 1)
      {
        v31 = 0;
        goto LABEL_25;
      }
    }
    v31 = v12 - 1;
LABEL_25:
    v36 = (v10 >> 4) - v31;
    LODWORD(v10) = v10 - 16 * v36;
    if (v6)
    {
      v5 += 16 * v36;
      if (v36 >= 1)
      {
        v37 = v36 + 1;
        do
        {
          v38 = vdupq_n_s32(v9);
          *(_DWORD *)v6 = v9;
          *(int32x4_t *)(v6 + 4) = vaddq_s32(v38, (int32x4_t)xmmword_18BE145F0);
          *(int32x4_t *)(v6 + 20) = vaddq_s32(v38, (int32x4_t)xmmword_18BE14600);
          *(int32x4_t *)(v6 + 36) = vaddq_s32(v38, (int32x4_t)xmmword_18BE14610);
          v39 = v9 + 15;
          *(int32x2_t *)(v6 + 52) = vadd_s32(*(int32x2_t *)v38.i8, (int32x2_t)0xE0000000DLL);
          v9 += 16;
          v40 = v6 + 64;
          *(_DWORD *)(v6 + 60) = v39;
          --v37;
          v6 += 64;
        }
        while (v37 > 1);
        v6 = v40;
      }
    }
  }
  if ((int)v10 >= 1)
  {
    v41 = v10 + 1;
    v42 = (unsigned __int16 *)(v2 + 1);
    do
    {
      v2 = (__int16 *)v42;
      v8 = *(v42 - 1);
      if (v8 > v7)
        break;
      *v32++ = v8;
      --v41;
      ++v42;
    }
    while (v41 > 1);
    if (v7 < v8)
    {
      if ((v8 & 0xFC00) != 0xD800)
        goto LABEL_36;
      goto LABEL_19;
    }
  }
LABEL_41:
  if (v6 && v32 != v5)
  {
    v44 = v5 - v32;
    do
    {
      *(_DWORD *)v6 = v9;
      v6 += 4;
      ++v9;
      v45 = __CFADD__(v44++, 1);
    }
    while (!v45);
  }
  v45 = *a2 > 0 || (unint64_t)v2 >= v4;
  if (!v45 && (unint64_t)v32 >= *(_QWORD *)(result + 40))
    *a2 = 15;
  *(_QWORD *)(result + 16) = v2;
  *(_QWORD *)(result + 32) = v32;
  *(_QWORD *)(result + 48) = v6;
  return result;
}

uint64_t sub_18BC2590C(uint64_t a1, _DWORD *a2)
{
  unsigned __int8 *v2;

  v2 = *(unsigned __int8 **)(a1 + 16);
  if ((unint64_t)v2 >= *(_QWORD *)(a1 + 24))
  {
    *a2 = 8;
    return 0xFFFFLL;
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v2 + 1;
    return *v2;
  }
}

uint64_t sub_18BC25938(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a2 + 16))(*(_QWORD *)a2, 0, 255);
}

uint64_t sub_18BC2594C(uint64_t result, _QWORD *a2, int *a3)
{
  uint64_t v3;
  _BYTE *v4;
  unint64_t v5;
  _BYTE *v6;
  int v7;
  int v8;
  BOOL v10;
  _BYTE *v11;
  int v12;
  unsigned __int8 v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  int v21;

  v3 = a2[1];
  v4 = (_BYTE *)a2[2];
  v5 = a2[3];
  v6 = *(_BYTE **)(result + 32);
  v7 = *(_DWORD *)(result + 40) - (_DWORD)v6;
  if (*(char *)(v3 + 64) < 1)
    goto LABEL_7;
  v8 = *(_DWORD *)(v3 + 72);
  if (!v8 || (unint64_t)v4 >= v5)
    goto LABEL_7;
  if (!v7)
  {
    v21 = 15;
LABEL_43:
    *a3 = v21;
    return result;
  }
  if ((v8 & 0xFFFFFFFE) != 0xC2 || (*v4 ^ 0x80u) > 0x3F)
  {
LABEL_42:
    v21 = -127;
    goto LABEL_43;
  }
  *v6++ = *v4++ ^ 0x80 | ((_BYTE)v8 << 6);
  --v7;
  *(_DWORD *)(v3 + 72) = 0;
  *(_BYTE *)(v3 + 64) = 0;
LABEL_7:
  if ((unint64_t)v4 < v5 && (*(_BYTE *)(v5 - 1) + 62) < 0x33u)
    --v5;
  if ((unint64_t)v4 < v5)
  {
    while (1)
    {
      v10 = __OFSUB__(v7--, 1);
      if (v7 < 0 != v10)
      {
        *a3 = 15;
        goto LABEL_39;
      }
      v11 = v4 + 1;
      v12 = (char)*v4;
      if (v12 < 0)
      {
        if ((v12 & 0xFFFFFFFE) != 0xFFFFFFC2 || (v13 = *v11 ^ 0x80, v13 > 0x3Fu))
        {
          a2[2] = v4;
          *(_QWORD *)(result + 32) = v6;
          goto LABEL_42;
        }
        v11 = v4 + 2;
        LOBYTE(v12) = v13 | ((_BYTE)v12 << 6);
      }
      *v6++ = v12;
      v4 = v11;
      if ((unint64_t)v11 >= v5)
        goto LABEL_19;
    }
  }
  v11 = v4;
LABEL_19:
  if (*a3 <= 0 && (unint64_t)v11 < a2[3])
  {
    v15 = (char)*v11++;
    v14 = v15;
    v16 = v15;
    *(_BYTE *)(v3 + 65) = v15;
    *(_BYTE *)(v3 + 64) = 1;
    v17 = (v15 + 62);
    if (v15 <= 0xEFu)
      v18 = 2;
    else
      v18 = 3;
    if (v16 > 0xDF)
      ++v18;
    if (v17 <= 0x32)
      v19 = v18;
    else
      v19 = 0;
    if (v14 < 0)
      v20 = v19;
    else
      v20 = 1;
    *(_DWORD *)(v3 + 72) = v16;
    *(_DWORD *)(v3 + 76) = v20;
  }
  v4 = v11;
LABEL_39:
  a2[2] = v4;
  *(_QWORD *)(result + 32) = v6;
  return result;
}

_QWORD *sub_18BC25ACC(_QWORD *result, int *a2)
{
  unsigned __int8 *v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  _WORD *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  int8x16_t v26;
  unsigned int v27;
  int v28;
  unsigned __int8 v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v2 = (unsigned __int8 *)result[2];
  v3 = result[3];
  v4 = result[4];
  v5 = result[5];
  v6 = result[6];
  v7 = v3 - (_DWORD)v2;
  if ((int)v3 - (int)v2 >= (int)((v5 - v4) >> 1))
    v7 = (v5 - v4) >> 1;
  if (v7 < 8)
  {
    v27 = 0;
    v8 = (_WORD *)result[4];
  }
  else
  {
    v8 = (_WORD *)result[4];
    v9 = v7 >> 3;
    while (1)
    {
      v10 = *v2;
      *v8 = v10;
      v11 = v2[1];
      v8[1] = v11;
      v12 = v11 | v10;
      v13 = v2[2];
      v8[2] = v13;
      v14 = v2[3];
      v8[3] = v14;
      v15 = v12 | v13 | v14;
      v16 = v2[4];
      v8[4] = v16;
      v17 = v2[5];
      v8[5] = v17;
      v18 = v16 | v17;
      v19 = v2[6];
      v8[6] = v19;
      v20 = v15 | v18 | v19;
      v21 = v2[7];
      v8[7] = v21;
      if (((v20 | v21) & 0x80) != 0)
        break;
      v2 += 8;
      v8 += 8;
      v22 = __OFSUB__(v9--, 1);
      if ((v9 < 0) ^ v22 | (v9 == 0))
      {
        v9 = 0;
        break;
      }
    }
    v23 = (v7 >> 3) - v9;
    v7 -= 8 * v23;
    if (v6 && (v4 += 16 * v23, v23 >= 1))
    {
      v24 = 0;
      v25 = v23 + 1;
      do
      {
        v26 = (int8x16_t)vdupq_n_s32(v24);
        *(_DWORD *)v6 = v24;
        *(int8x16_t *)(v6 + 4) = vorrq_s8(v26, (int8x16_t)xmmword_18BE145F0);
        *(int8x8_t *)(v6 + 20) = vorr_s8(*(int8x8_t *)v26.i8, (int8x8_t)0x600000005);
        v27 = v24 + 8;
        *(_DWORD *)(v6 + 28) = v24 + 7;
        v6 += 32;
        --v25;
        v24 += 8;
      }
      while (v25 > 1);
    }
    else
    {
      v27 = 0;
    }
  }
  if (v7 >= 1)
  {
    v28 = v7 + 1;
    while (1)
    {
      v30 = (char)*v2++;
      v29 = v30;
      if (v30 < 0)
        break;
      *v8++ = v29;
      if (--v28 <= 1)
        goto LABEL_20;
    }
    v32 = result[1];
    *(_BYTE *)(v32 + 65) = v29;
    *(_BYTE *)(v32 + 64) = 1;
    v31 = 12;
    goto LABEL_24;
  }
LABEL_20:
  if ((unint64_t)v2 < v3 && (unint64_t)v8 >= v5)
  {
    v31 = 15;
LABEL_24:
    *a2 = v31;
  }
  if (v6)
  {
    v33 = (uint64_t)v8 - v4;
    if (v33)
    {
      v34 = v33 >> 1;
      do
      {
        *(_DWORD *)v6 = v27;
        v6 += 4;
        ++v27;
        --v34;
      }
      while (v34);
    }
  }
  result[2] = v2;
  result[4] = v8;
  result[6] = v6;
  return result;
}

uint64_t sub_18BC25C7C(_QWORD *a1, int *a2)
{
  char *v2;
  unsigned __int8 v3;
  int v4;
  int v6;
  uint64_t v7;

  v2 = (char *)a1[2];
  if ((unint64_t)v2 >= a1[3])
  {
    v6 = 8;
  }
  else
  {
    v4 = *v2;
    v3 = *v2;
    a1[2] = v2 + 1;
    if ((v4 & 0x80000000) == 0)
      return v3;
    v7 = a1[1];
    *(_BYTE *)(v7 + 65) = v3;
    *(_BYTE *)(v7 + 64) = 1;
    v6 = 12;
  }
  *a2 = v6;
  return 0xFFFFLL;
}

uint64_t sub_18BC25CC4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a2 + 16))(*(_QWORD *)a2, 0, 127);
}

uint64_t sub_18BC25CD8(uint64_t result, _QWORD *a2, int *a3)
{
  __int8 *v3;
  unint64_t v4;
  __int8 *v5;
  int v6;
  int v7;
  __int8 v8;
  __int8 v9;
  __int8 v10;
  __int8 v11;
  __int8 v12;
  __int8 v13;
  __int8 v14;
  __int8 v15;
  __int8 v16;
  __int8 v17;
  __int8 v18;
  __int8 v19;
  __int8 v20;
  __int8 v21;
  __int8 v22;
  __int8 v23;
  int8x8_t v24;
  int8x8_t v25;
  int8x8_t v26;
  BOOL v27;
  int v28;
  int v29;
  int v30;

  if (*(char *)(a2[1] + 64) >= 1)
  {
    *a3 = -127;
    return result;
  }
  v3 = (__int8 *)a2[2];
  v4 = a2[3];
  v5 = *(__int8 **)(result + 32);
  v6 = *(_DWORD *)(result + 40) - (_DWORD)v5;
  if ((int)v4 - (int)v3 < v6)
    v6 = v4 - (_DWORD)v3;
  if (v6 >= 16)
  {
    v7 = v6 >> 4;
    while (1)
    {
      v8 = *v3;
      *v5 = *v3;
      v9 = v3[1];
      v5[1] = v9;
      v10 = v3[2];
      v5[2] = v10;
      v11 = v3[3];
      v5[3] = v11;
      v12 = v3[4];
      v5[4] = v12;
      v13 = v3[5];
      v5[5] = v13;
      v14 = v3[6];
      v5[6] = v14;
      v15 = v3[7];
      v5[7] = v15;
      v16 = v3[8];
      v5[8] = v16;
      v17 = v3[9];
      v5[9] = v17;
      v18 = v3[10];
      v5[10] = v18;
      v19 = v3[11];
      v5[11] = v19;
      v20 = v3[12];
      v5[12] = v20;
      v21 = v3[13];
      v5[13] = v21;
      v22 = v3[14];
      v5[14] = v22;
      v23 = v3[15];
      v24.i8[0] = v8;
      v24.i8[1] = v9;
      v24.i8[2] = v10;
      v24.i8[3] = v11;
      v24.i8[4] = v12;
      v24.i8[5] = v13;
      v24.i8[6] = v14;
      v5[15] = v23;
      v24.i8[7] = v15;
      v25.i8[0] = v16;
      v25.i8[1] = v17;
      v25.i8[2] = v18;
      v25.i8[3] = v19;
      v25.i8[4] = v20;
      v25.i8[5] = v21;
      v25.i8[6] = v22;
      v25.i8[7] = v23;
      v26 = vorr_s8(v24, v25);
      if (((v26.i32[0] | v26.i32[1] | ((*(_QWORD *)&v26 | HIDWORD(*(_QWORD *)&v26)) >> 16) | ((v26.i32[0] | v26.i32[1] | ((*(_QWORD *)&v26 | HIDWORD(*(_QWORD *)&v26)) >> 16)) >> 8)) & 0x80) != 0)
        break;
      v5 += 16;
      v3 += 16;
      v27 = __OFSUB__(v7--, 1);
      if ((v7 < 0) ^ v27 | (v7 == 0))
      {
        v7 = 0;
        break;
      }
    }
    v6 += 16 * (v7 - (v6 >> 4));
  }
  if (v6 < 1)
  {
LABEL_16:
    if ((unint64_t)v3 >= v4 || (unint64_t)v5 < *(_QWORD *)(result + 40))
      goto LABEL_21;
    v30 = 15;
  }
  else
  {
    v28 = v6 + 1;
    while (1)
    {
      v29 = *v3;
      if (v29 < 0)
        break;
      ++v3;
      *v5++ = v29;
      if (--v28 <= 1)
        goto LABEL_16;
    }
    v30 = -127;
  }
  *a3 = v30;
LABEL_21:
  a2[2] = v3;
  *(_QWORD *)(result + 32) = v5;
  return result;
}

uint64_t sub_18BC25E90(uint64_t result, uint64_t *a2, uint64_t a3, int a4, _DWORD *a5)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned __int8 *v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int16 *v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;

  v35 = result;
  v40 = *(_QWORD *)(result + 88);
  if ((*(_BYTE *)(result + 253) & 1) != 0)
    v7 = 1088;
  else
    v7 = 64;
  v8 = *(unsigned __int8 *)(result + 252);
  v9 = *(_QWORD *)(result + 232);
  if (*(_BYTE *)(result + 252))
  {
    v10 = 0;
    v11 = 0;
    if (v8 == 3)
      v12 = 4;
    else
      v12 = 2;
    if (v8 == 2 || v8 == 9)
      v14 = 3;
    else
      v14 = v12;
    v38 = v7 >> 1;
    v37 = v7;
    while (1)
    {
      v39 = v10;
      v15 = *(unsigned __int16 *)(v40 + 2 * v10);
      if (v38 < v15)
        break;
      v11 = (v11 + 1024);
LABEL_66:
      v10 = v39 + 1;
      if (v39 + 1 == v37)
        return sub_18BC1A04C(v35, a2, a3, a4);
    }
    v16 = 0;
    v17 = v40 + 4 * v15;
    while (1)
    {
      v18 = *(_DWORD *)(v17 + 4 * v16);
      if (v18)
        break;
      v11 = (v11 + 16);
LABEL_63:
      if (++v16 == 64)
        goto LABEL_66;
    }
    v19 = (unsigned __int8 *)(v9 + 16 * (_DWORD)v14 * (unsigned __int16)*(_DWORD *)(v17 + 4 * v16));
    v20 = HIWORD(v18);
    switch(a4)
    {
      case 0:
        do
        {
          if ((v20 & 1) != 0)
          {
            result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v11);
            v19 += v14;
          }
          else if ((_DWORD)a3 == 1)
          {
            v21 = 0;
            if ((_DWORD)v14 != 2)
            {
              if ((_DWORD)v14 != 3)
              {
                v22 = *v19++;
                v21 = v22;
              }
              v23 = *v19++;
              v21 |= v23;
            }
            v24 = *v19;
            v25 = v19[1];
            v19 += 2;
            if (v24 | v21 | v25)
              result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v11);
          }
          v20 >>= 1;
          v11 = (v11 + 1);
        }
        while ((v11 & 0xF) != 0);
        goto LABEL_63;
      case 1:
        do
        {
          if (((_DWORD)a3 == 1 || (v20 & 1) != 0) && *(unsigned __int16 *)v19 >= 0x100u)
            result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v11);
          v20 >>= 1;
          v19 += 2;
          v11 = (v11 + 1);
        }
        while ((v11 & 0xF) != 0);
        goto LABEL_63;
      case 2:
        do
        {
          if (((_DWORD)a3 == 1 || (v20 & 1) != 0) && (*v19 + 127) <= 1u)
            result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v11);
          v20 >>= 1;
          v19 += 3;
          v11 = (v11 + 1);
        }
        while ((v11 & 0xF) != 0);
        goto LABEL_63;
      case 3:
        do
        {
          if (((_DWORD)a3 == 1 || (v20 & 1) != 0) && (unsigned __int16)(*(_WORD *)v19 + 32448) <= 0x6EBCu)
            result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v11);
          v20 >>= 1;
          v19 += 2;
          v11 = (v11 + 1);
        }
        while ((v11 & 0xF) != 0);
        goto LABEL_63;
      case 4:
        do
        {
          if (((_DWORD)a3 == 1 || (v20 & 1) != 0)
            && (unsigned __int16)(*(_WORD *)v19 + 24159) <= 0x5D5Du
            && ((*(_WORD *)v19 + 95) & 0xFEu) <= 0x5D)
          {
            result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v11);
          }
          v20 >>= 1;
          v19 += 2;
          v11 = (v11 + 1);
        }
        while ((v11 & 0xF) != 0);
        goto LABEL_63;
      case 5:
        do
        {
          if (((_DWORD)a3 == 1 || (v20 & 1) != 0)
            && (unsigned __int16)(*(_WORD *)v19 + 24159) <= 0x5C5Du
            && ((*(_WORD *)v19 + 95) & 0xFEu) <= 0x5D)
          {
            result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v11);
          }
          v20 >>= 1;
          v19 += 2;
          v11 = (v11 + 1);
        }
        while ((v11 & 0xF) != 0);
        goto LABEL_63;
      default:
        *a5 = 5;
        break;
    }
  }
  else
  {
    v26 = 0;
    v27 = 0;
    if ((_DWORD)a3)
      v28 = 2048;
    else
      v28 = 3840;
    v29 = v7;
    do
    {
      v30 = *(unsigned __int16 *)(v40 + 2 * v26);
      if (v29 >= v30)
      {
        v27 = (v27 + 1024);
      }
      else
      {
        v31 = 0;
        v32 = v40 + 2 * v30;
        do
        {
          if (*(_WORD *)(v32 + 2 * v31))
          {
            v33 = (unsigned __int16 *)(v9 + 2 * *(unsigned __int16 *)(v32 + 2 * v31));
            do
            {
              v34 = *v33++;
              if (v28 <= v34)
                ((void (*)(uint64_t, uint64_t))a2[1])(*a2, v27);
              v27 = (v27 + 1);
            }
            while ((v27 & 0xF) != 0);
          }
          else
          {
            v27 = (v27 + 16);
          }
          ++v31;
        }
        while (v31 != 64);
      }
      ++v26;
    }
    while (v26 != v29);
    return sub_18BC1A04C(v35, a2, a3, a4);
  }
  return result;
}

uint64_t sub_18BC2629C(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  return sub_18BC25E90(a1, a2, a3, *(unsigned __int8 *)(a1 + 252) == 219, a4);
}

uint64_t sub_18BC262B0(uint64_t result, int *a2)
{
  int *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned __int8 *v9;
  uint64_t v10;
  _WORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int32x4_t v19;
  unsigned __int8 *v20;
  signed int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  unsigned __int8 *v49;
  int v50;
  _WORD *v51;
  BOOL v52;
  int v53;
  int *v54;
  unsigned int v55;
  int32x4_t v56;
  unsigned int v57;
  int *v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  int v63;
  int v64;
  int *v66;
  uint64_t v67;
  int *v68;
  int v69;
  unint64_t v70;
  _BYTE *v71;
  unint64_t v72;
  uint64_t v73;
  int v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _BYTE *v79;
  uint64_t v80;
  uint64_t v81;
  _WORD *v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  _DWORD *v86;
  unint64_t v87;
  unsigned __int8 *v88;
  unsigned int v89;
  unint64_t v90;
  unsigned int v91;
  int v92;
  uint64_t v93;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  unint64_t v98;
  _WORD *v99;
  _DWORD *v100;
  __int16 v101;
  unsigned int v102;
  _WORD *v103;
  _DWORD *v104;
  __int16 v105;
  unsigned int v106;
  _DWORD *v107;
  _DWORD *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  _BYTE *v112;
  uint64_t v113;
  uint64_t v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v117;
  __int16 v118;
  int v119;
  int *v120;
  uint64_t v121;
  _BYTE *v122;
  uint64_t v123;
  _BYTE *v124;
  uint64_t v125;
  _WORD *v126;
  unint64_t v127;
  unint64_t v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  unint64_t v132;
  int v133;
  int *v134;
  _WORD *v135;
  int *v136;
  __int16 v137;
  int v138;
  uint64_t v139;
  int *v140;
  char v141;
  int v142;
  BOOL v143;
  int *v144;
  int64_t v145;
  uint64_t v146;
  _BOOL4 v147;
  uint64_t v148;
  uint64_t v149;
  char v150;
  _BYTE *v151;
  char v152;
  uint64_t v153;
  _BYTE *v154;
  uint64_t v155;
  int *v156;
  int *v157;
  uint64_t v158;
  _DWORD *v159;
  _WORD *v160;
  _BYTE *v161;
  int *v162;
  _WORD *v163;
  uint64_t v164[2];

  v2 = a2;
  v3 = result;
  v160 = 0;
  v161 = 0;
  v159 = 0;
  v4 = *(_QWORD *)(result + 8);
  if (*(char *)(v4 + 282) >= 1)
  {
    v6 = *(_QWORD *)(result + 8);
    result = sub_18BC1966C(v6, result, -1, a2);
    if (*a2 > 0)
      return result;
    v4 = v6;
    v2 = a2;
    if (*(char *)(v6 + 282) < 0)
      return result;
  }
  v7 = *(_QWORD *)(v4 + 48);
  if (*(_BYTE *)(v7 + 48) != 1)
  {
    v71 = *(_BYTE **)(v3 + 16);
    v70 = *(_QWORD *)(v3 + 24);
    v72 = *(_QWORD *)(v3 + 40);
    v160 = *(_WORD **)(v3 + 32);
    v161 = v71;
    v158 = v3;
    v159 = *(_DWORD **)(v3 + 48);
    v73 = 56;
    if ((*(_BYTE *)(v4 + 56) & 0x10) != 0)
      v73 = 64;
    v74 = *(_DWORD *)(v4 + 72);
    LOBYTE(v75) = *(_BYTE *)(v4 + 64);
    v76 = *(unsigned __int8 *)(v4 + 76);
    if (!*(_BYTE *)(v4 + 76))
      v76 = *(unsigned __int8 *)(v7 + 49);
    if ((unint64_t)v71 >= v70)
      goto LABEL_211;
    LODWORD(v77) = 0;
    v78 = *(_QWORD *)(v7 + v73);
    v79 = (_BYTE *)(v4 + 65);
    v80 = *(_QWORD *)(v7 + 72);
    if (*(_BYTE *)(v4 + 64))
      v81 = 0xFFFFFFFFLL;
    else
      v81 = 0;
    while (1)
    {
      v82 = v160;
      if ((unint64_t)v160 >= v72)
        goto LABEL_210;
      if ((_BYTE)v75)
      {
        v161 = v71 + 1;
        v83 = *v71;
        v79[(char)v75] = v83;
        LODWORD(v84) = *(_DWORD *)(v78 + ((unint64_t)v76 << 10) + 4 * v83);
        ++v71;
        v85 = v76;
        goto LABEL_89;
      }
      v86 = v159;
      if (!v159)
      {
        while (1)
        {
          v84 = *(unsigned int *)(v78 + ((unint64_t)v76 << 10) + 4 * *v71);
          if ((v84 & 0x80000000) != 0)
          {
            if (v84 >= 0x80100000)
              goto LABEL_83;
            v76 = 0;
            v161 = ++v71;
            *v82 = v84;
            v160 = v82 + 1;
          }
          else
          {
            v90 = v84 >> 24;
            v74 = v84 & 0xFFFFFF;
            v88 = v71 + 1;
            v161 = v71 + 1;
            if ((unint64_t)(v71 + 1) >= v70
              || (LODWORD(v84) = *(_DWORD *)(v78 + (v90 << 10) + 4 * *v88), (v84 & 0x80F00000) != 0x80400000)
              || (v91 = *(unsigned __int16 *)(v80 + 2 * (v74 + (unsigned __int16)v84)), v91 > 0xFFFD))
            {
LABEL_85:
              *v79 = *v71;
              v75 = 1;
              v71 = v88;
              v85 = v90;
              goto LABEL_86;
            }
            v74 = 0;
            v71 += 2;
            v161 = v71;
            *v82 = v91;
            v160 = v82 + 1;
            v76 = BYTE3(v84) & 0x7F;
          }
          v82 = v160;
          if ((unint64_t)v71 >= v70 || (unint64_t)v160 >= v72)
          {
LABEL_83:
            v75 = 0;
            v85 = v76;
            goto LABEL_86;
          }
        }
      }
      v85 = v76;
      while (1)
      {
        v84 = *(unsigned int *)(v78 + ((unint64_t)v85 << 10) + 4 * *v71);
        if ((v84 & 0x80000000) != 0)
          break;
        v87 = v84 >> 24;
        v74 = v84 & 0xFFFFFF;
        v88 = v71 + 1;
        v161 = v71 + 1;
        if ((unint64_t)(v71 + 1) >= v70
          || (LODWORD(v84) = *(_DWORD *)(v78 + (v87 << 10) + 4 * *v88), (v84 & 0x80F00000) != 0x80400000)
          || (v89 = *(unsigned __int16 *)(v80 + 2 * (v74 + (unsigned __int16)v84)), v89 > 0xFFFD))
        {
          LODWORD(v77) = v77 + 1;
          v90 = v87;
          goto LABEL_85;
        }
        v71 += 2;
        v161 = v71;
        *v82 = v89;
        v160 = v82 + 1;
        if (v86)
        {
          *v86++ = v81;
          v159 = v86;
          v81 = (v77 + 2);
          LODWORD(v77) = v77 + 2;
        }
        v74 = 0;
        v85 = BYTE3(v84) & 0x7F;
LABEL_71:
        v75 = 0;
        v82 = v160;
        if ((unint64_t)v71 >= v70 || (unint64_t)v160 >= v72)
          goto LABEL_86;
      }
      if (v84 < 0x80100000)
        break;
      v75 = 0;
LABEL_86:
      if ((unint64_t)v71 >= v70)
        goto LABEL_182;
      if ((unint64_t)v82 >= v72)
      {
        *v2 = 15;
LABEL_182:
        LOBYTE(v76) = v85;
        goto LABEL_211;
      }
      v161 = v71 + 1;
      v79[v75] = *v71++;
LABEL_89:
      v77 = (v77 + 1);
      v92 = (char)(v75 + 1);
      if ((v84 & 0x80000000) == 0)
      {
        v76 = BYTE3(v84);
        v74 += v84 & 0xFFFFFF;
        LOBYTE(v75) = v75 + 1;
        v93 = v81;
        goto LABEL_133;
      }
      *(_DWORD *)(v4 + 76) = v85;
      v76 = BYTE3(v84) & 0x7F;
      v94 = (v84 >> 20) & 0xF;
      if (!v94)
      {
LABEL_109:
        *v82 = v84;
        v98 = (unint64_t)(v82 + 1);
LABEL_110:
        v160 = (_WORD *)v98;
        v107 = v159;
        if (v159)
        {
          v74 = 0;
          LOBYTE(v75) = 0;
          *v159 = v81;
          v159 = v107 + 1;
          goto LABEL_132;
        }
LABEL_130:
        v74 = 0;
LABEL_131:
        LOBYTE(v75) = 0;
        goto LABEL_132;
      }
      if (v94 == 5)
      {
        v97 = v74 + (unsigned __int16)v84;
        v96 = *(unsigned __int16 *)(v80 + 2 * v97);
        if (v96 >> 11 <= 0x1A)
        {
LABEL_99:
          *v82 = v96;
          v98 = (unint64_t)(v82 + 1);
          goto LABEL_110;
        }
        v102 = v97 + 1;
        if (v96 >> 13 <= 6)
        {
          *v82 = v96 & 0xDBFF;
          v103 = v82 + 1;
          v160 = v82 + 1;
          v104 = v159;
          if (v159)
          {
            *v159 = v81;
            v159 = v104 + 1;
            if ((unint64_t)v103 < v72)
            {
              v74 = 0;
              LOBYTE(v75) = 0;
              v105 = *(_WORD *)(v80 + 2 * v102);
              v160 = v82 + 2;
              v82[1] = v105;
              v159 = v104 + 2;
              v104[1] = v81;
              goto LABEL_132;
            }
          }
          else if ((unint64_t)v103 < v72)
          {
            v74 = 0;
            LOBYTE(v75) = 0;
            v118 = *(_WORD *)(v80 + 2 * v102);
            v160 = v82 + 2;
            v82[1] = v118;
            goto LABEL_132;
          }
          v74 = 0;
          LOBYTE(v75) = 0;
          *(_WORD *)(v4 + 144) = *(_WORD *)(v80 + 2 * v102);
LABEL_209:
          *(_BYTE *)(v4 + 93) = 1;
LABEL_210:
          *v2 = 15;
          goto LABEL_211;
        }
        if ((v96 & 0xFFFE) == 0xE000)
        {
          LOWORD(v96) = *(_WORD *)(v80 + 2 * v102);
          goto LABEL_99;
        }
        result = v76;
        if (v96 == 0xFFFF)
        {
LABEL_124:
          *v2 = 12;
          v76 = result;
        }
LABEL_125:
        if (!v92)
          goto LABEL_130;
        if (*v2 >= 1)
        {
          if (v92 >= 2)
          {
            v146 = 0;
            v147 = *(_BYTE *)(*(_QWORD *)(v4 + 48) + 49) != 0;
            v148 = v4;
            v149 = v4 + 66;
            do
            {
              result = sub_18BC2732C(v78, v76, v147, *(unsigned __int8 *)(v149 + v146));
              if ((_DWORD)result)
              {
                LOBYTE(v75) = v146 + 1;
                v150 = v92 - (v146 + 1);
                v151 = &v71[-*(_QWORD *)(v158 + 16)];
                v4 = v148;
                if ((int)v151 >= v150)
                {
                  v74 = 0;
                  v71 -= v150;
                }
                else
                {
                  v152 = (_BYTE)v151 - v150;
                  *(_BYTE *)(v148 + 282) = v152;
                  result = (uint64_t)memcpy((void *)(v148 + 250), (const void *)(v148 + v146 + 66), -(uint64_t)v152);
                  v4 = v148;
                  v74 = 0;
                  v71 = *(_BYTE **)(v158 + 16);
                }
                goto LABEL_211;
              }
              ++v146;
            }
            while (v92 - 1 != v146);
            v74 = 0;
            LOBYTE(v75) = v92;
            v4 = v148;
            goto LABEL_211;
          }
          v74 = 0;
        }
        else
        {
          v109 = v158;
          *(_QWORD *)(v158 + 16) = v71;
          v110 = *(_QWORD *)(*(_QWORD *)(v4 + 48) + 288);
          if (v110)
          {
            v157 = v2;
            v111 = v4;
            v112 = v79;
            v113 = v80;
            result = sub_18BC19238(v4, v110, v92, (uint64_t *)&v161, v70, (unint64_t *)&v160, v72, &v159, v81, *(_BYTE *)(v158 + 2), v2);
            v109 = v158;
            v80 = v113;
            v79 = v112;
            v4 = v111;
            v2 = v157;
            if ((_DWORD)result)
              goto LABEL_129;
          }
          if (v92 == 4 && (*(_BYTE *)(v4 + 57) & 0x80) != 0)
          {
            v114 = 0;
            v115 = *(unsigned __int8 *)(v4 + 68)
                 + 10
                 * (*(unsigned __int8 *)(v4 + 67)
                  + 126 * (*(unsigned __int8 *)(v4 + 66) + 10 * *(unsigned __int8 *)(v4 + 65)));
            while (1)
            {
              v116 = dword_18BE14774[v114 + 2];
              v143 = v115 >= v116;
              v117 = v115 - v116;
              if (v143 && v115 <= dword_18BE14774[v114 + 3])
                break;
              v114 += 4;
              if ((_DWORD)(v114 * 4) == 224)
                goto LABEL_142;
            }
            *v2 = 0;
            v119 = v81;
            v120 = v2;
            v121 = v4;
            v122 = v79;
            v123 = v80;
            result = sub_18BC17694(v4, v117 + dword_18BE14774[v114], (unint64_t *)&v160, v72, &v159, v119, v2);
            v109 = v158;
            v80 = v123;
            v79 = v122;
            v4 = v121;
            v2 = v120;
LABEL_129:
            LOBYTE(v92) = 0;
          }
          else
          {
LABEL_142:
            *v2 = 10;
          }
          v74 = 0;
          v71 = v161;
          if (*v2 < 1)
          {
            v93 = (v77 + (_DWORD)v161 - *(_DWORD *)(v109 + 16));
            LOBYTE(v75) = v92;
            LODWORD(v77) = v77 + (_DWORD)v161 - *(_DWORD *)(v109 + 16);
            goto LABEL_133;
          }
        }
        LOBYTE(v75) = v92;
        goto LABEL_211;
      }
      if (v94 != 4)
      {
        if ((v84 & 0xD00000) != 0x100000)
        {
          v74 = 0;
          v106 = v94 - 2;
          LOBYTE(v75) = 0;
          v93 = v77;
          result = BYTE3(v84) & 0x7F;
          switch(v106)
          {
            case 0u:
              goto LABEL_109;
            case 1u:
            case 2u:
            case 3u:
              goto LABEL_133;
            case 4u:
              goto LABEL_125;
            case 5u:
              goto LABEL_124;
            case 6u:
              v74 = *(unsigned __int8 *)(*(_QWORD *)(v4 + 48) + 49);
              result = v85;
              if (*(_BYTE *)(*(_QWORD *)(v4 + 48) + 49))
                goto LABEL_124;
              goto LABEL_131;
            default:
              LOBYTE(v75) = 0;
              goto LABEL_132;
          }
        }
        *v82 = (v84 >> 10) & 0x3FF | 0xD800;
        v99 = v82 + 1;
        v160 = v82 + 1;
        v100 = v159;
        if (v159)
        {
          *v159 = v81;
          v159 = v100 + 1;
          v101 = v84 & 0x3FF | 0xDC00;
          if ((unint64_t)v99 < v72)
          {
            v74 = 0;
            LOBYTE(v75) = 0;
            v160 = v82 + 2;
            v82[1] = v101;
            v159 = v100 + 2;
            v100[1] = v81;
LABEL_132:
            v93 = v77;
            goto LABEL_133;
          }
        }
        else
        {
          v101 = v84 & 0x3FF | 0xDC00;
          if ((unint64_t)v99 < v72)
          {
            v74 = 0;
            LOBYTE(v75) = 0;
            v160 = v82 + 2;
            v82[1] = v101;
            goto LABEL_132;
          }
        }
        v74 = 0;
        LOBYTE(v75) = 0;
        *(_WORD *)(v4 + 144) = v101;
        goto LABEL_209;
      }
      v95 = v74 + (unsigned __int16)v84;
      v96 = *(unsigned __int16 *)(v80 + 2 * v95);
      if (v96 <= 0xFFFD)
        goto LABEL_99;
      if (v96 != 65534)
      {
        result = BYTE3(v84) & 0x7F;
        goto LABEL_124;
      }
      v153 = v80;
      v154 = v79;
      v156 = v2;
      v155 = v4;
      result = sub_18BC272C0(*(_QWORD *)(v4 + 48) + 48, v95);
      if ((_DWORD)result == 65534)
      {
        v2 = v156;
        v4 = v155;
        v80 = v153;
        v79 = v154;
        goto LABEL_125;
      }
      *v82 = result;
      v160 = v82 + 1;
      v108 = v159;
      v2 = v156;
      v80 = v153;
      v79 = v154;
      v74 = 0;
      LOBYTE(v75) = 0;
      if (v159)
      {
        *v159 = v81;
        v159 = v108 + 1;
      }
      v93 = v77;
      v4 = v155;
LABEL_133:
      v81 = v93;
      if ((unint64_t)v71 >= v70)
      {
LABEL_211:
        *(_DWORD *)(v4 + 72) = v74;
        *(_DWORD *)(v4 + 76) = v76;
        *(_BYTE *)(v4 + 64) = v75;
        *(_QWORD *)(v158 + 16) = v71;
        *(_QWORD *)(v158 + 32) = v160;
        *(_QWORD *)(v158 + 48) = v159;
        return result;
      }
    }
    v161 = ++v71;
    *v82 = v84;
    v160 = v82 + 1;
    v85 = 0;
    if (v86)
    {
      *v86++ = v81;
      v159 = v86;
      v81 = (v77 + 1);
      LODWORD(v77) = v77 + 1;
    }
    goto LABEL_71;
  }
  if ((*(_BYTE *)(v7 + 253) & 1) == 0)
  {
    v8 = 0;
    v10 = *(_QWORD *)(v3 + 8);
    v9 = *(unsigned __int8 **)(v3 + 16);
    v12 = *(_QWORD *)(v3 + 24);
    v11 = *(_WORD **)(v3 + 32);
    v13 = v3;
    v14 = (*(_QWORD *)(v3 + 40) - (_QWORD)v11) >> 1;
    v162 = *(int **)(v3 + 48);
    v163 = v11;
    v15 = 64;
    if ((*(_BYTE *)(v10 + 56) & 0x10) == 0)
      v15 = 56;
    v16 = *(_QWORD *)(*(_QWORD *)(v10 + 48) + v15);
    if ((int)v12 - (int)v9 < (int)v14)
      LODWORD(v14) = v12 - (_DWORD)v9;
    v17 = (int32x4_t)xmmword_18BE145F0;
    v18 = (int32x4_t)xmmword_18BE14600;
    v19 = (int32x4_t)xmmword_18BE14610;
    result = 2;
    v20 = v9;
    while (1)
    {
      if ((int)v14 < 16)
        goto LABEL_23;
      v21 = v14 >> 4;
      while (1)
      {
        v164[0] = (uint64_t)(v9 + 1);
        v22 = *(_DWORD *)(v16 + 4 * *v9);
        v163 = v11 + 1;
        *v11 = v22;
        v164[0] = (uint64_t)(v9 + 2);
        v23 = *(_DWORD *)(v16 + 4 * v9[1]);
        v24 = v23 | v22;
        v163 = v11 + 2;
        v11[1] = v23;
        v164[0] = (uint64_t)(v9 + 3);
        v25 = *(_DWORD *)(v16 + 4 * v9[2]);
        v163 = v11 + 3;
        v11[2] = v25;
        v164[0] = (uint64_t)(v9 + 4);
        v26 = *(_DWORD *)(v16 + 4 * v9[3]);
        v27 = v24 | v25 | v26;
        v163 = v11 + 4;
        v11[3] = v26;
        v164[0] = (uint64_t)(v9 + 5);
        v28 = *(_DWORD *)(v16 + 4 * v9[4]);
        v163 = v11 + 5;
        v11[4] = v28;
        v164[0] = (uint64_t)(v9 + 6);
        v29 = *(_DWORD *)(v16 + 4 * v9[5]);
        v30 = v28 | v29;
        v163 = v11 + 6;
        v11[5] = v29;
        v164[0] = (uint64_t)(v9 + 7);
        v31 = *(_DWORD *)(v16 + 4 * v9[6]);
        v32 = v30 | v31;
        v163 = v11 + 7;
        v11[6] = v31;
        v164[0] = (uint64_t)(v9 + 8);
        v33 = *(_DWORD *)(v16 + 4 * v9[7]);
        v34 = v27 | v32;
        v11[7] = v33;
        v35 = *(_DWORD *)(v16 + 4 * v9[8]);
        v36 = v33 | v35;
        v11[8] = v35;
        v37 = *(_DWORD *)(v16 + 4 * v9[9]);
        v38 = v36 | v37;
        v11[9] = v37;
        v39 = *(_DWORD *)(v16 + 4 * v9[10]);
        v40 = v38 | v39;
        v11[10] = v39;
        v41 = *(_DWORD *)(v16 + 4 * v9[11]);
        v11[11] = v41;
        v42 = *(_DWORD *)(v16 + 4 * v9[12]);
        v43 = v34 | v40;
        v44 = v41 | v42;
        v11[12] = v42;
        v45 = *(_DWORD *)(v16 + 4 * v9[13]);
        v46 = v44 | v45;
        v11[13] = v45;
        v47 = *(_DWORD *)(v16 + 4 * v9[14]);
        v48 = v46 | v47;
        v11[14] = v47;
        v49 = v9 + 16;
        v164[0] = (uint64_t)(v9 + 16);
        v50 = *(_DWORD *)(v16 + 4 * v9[15]);
        v51 = v11 + 16;
        v163 = v11 + 16;
        v11[15] = v50;
        if ((v43 | v48 | v50) >= -2146435072)
          break;
        v11 += 16;
        v9 += 16;
        v52 = __OFSUB__(v21--, 1);
        if ((v21 < 0) ^ v52 | (v21 == 0))
        {
          v21 = 0;
          v9 = v49;
          v11 = v51;
          goto LABEL_18;
        }
      }
      v164[0] = (uint64_t)v9;
      v163 = v11;
LABEL_18:
      v53 = (v14 >> 4) - v21;
      LODWORD(v14) = v14 - 16 * v53;
      v54 = v162;
      if (v162 && (v20 += 16 * v53, v53 >= 1))
      {
        v55 = v53 + 1;
        do
        {
          v56 = vdupq_n_s32(v8);
          *v54 = v8;
          *(int32x4_t *)(v54 + 1) = vaddq_s32(v56, v17);
          *(int32x4_t *)(v54 + 5) = vaddq_s32(v56, v18);
          *(int32x4_t *)(v54 + 9) = vaddq_s32(v56, v19);
          *(int32x2_t *)(v54 + 13) = vadd_s32(*(int32x2_t *)v56.i8, (int32x2_t)0xE0000000DLL);
          v57 = v8 + 16;
          v58 = v54 + 16;
          v54[15] = v8 + 15;
          --v55;
          v8 += 16;
          v54 += 16;
        }
        while (v55 > 1);
        v162 = v58;
        v59 = v164[0];
        v8 = v57;
      }
      else
      {
LABEL_23:
        v59 = (uint64_t)v9;
      }
      if ((int)v14 < 1)
      {
LABEL_183:
        v9 = (unsigned __int8 *)v59;
        goto LABEL_190;
      }
LABEL_25:
      v60 = 0;
      v61 = 2 - (_DWORD)v20 + v59;
      do
      {
        v62 = v61;
        v9 = (unsigned __int8 *)(v59 + v60);
        if (v59 + v60 >= v12)
          goto LABEL_190;
        v164[0] = (uint64_t)(v9 + 1);
        v63 = *(_DWORD *)(v16 + 4 * *v9);
        v64 = (v63 >> 20) & 0xF;
        if (v63 < -2146435072 || v64 == 2)
        {
          *v11++ = v63;
          v163 = v11;
          v59 = v164[0];
          v52 = __OFSUB__((_DWORD)v14, 1);
          LODWORD(v14) = v14 - 1;
          if (((int)v14 < 0) ^ v52 | ((_DWORD)v14 == 0))
            goto LABEL_183;
          goto LABEL_25;
        }
        ++v60;
        if (v64 == 6)
          goto LABEL_37;
        v61 = v62 + 1;
      }
      while (v64 != 7);
      *v2 = 12;
LABEL_37:
      v66 = v162;
      if (v162 && (int)v59 - (int)v20 + (int)v60 > 1)
      {
        do
        {
          *v66++ = v8++;
          --v62;
        }
        while (v62 > 2);
        v162 = v66;
      }
      if (*v2 >= 1)
      {
        v9 = (unsigned __int8 *)v164[0];
        goto LABEL_190;
      }
      v20 = (unsigned __int8 *)(v59 + v60);
      *(_BYTE *)(v10 + 65) = *(_BYTE *)(v59 + v60 - 1);
      v67 = *(_QWORD *)(*(_QWORD *)(v10 + 48) + 288);
      if (!v67)
      {
        v9 = (unsigned __int8 *)v164[0];
LABEL_188:
        *v2 = 10;
        *(_BYTE *)(v10 + 64) = 1;
        v8 = (_DWORD)v9 + v8 - v59 - v60 + 1;
        v20 = (unsigned __int8 *)(v59 + v60);
        goto LABEL_190;
      }
      v68 = v2;
      result = sub_18BC19238(v10, v67, 1, v164, v12, (unint64_t *)&v163, *(_QWORD *)(v13 + 40), &v162, v8, *(_BYTE *)(v13 + 2), v2);
      v9 = (unsigned __int8 *)v164[0];
      if (!(_DWORD)result)
      {
        v2 = v68;
        goto LABEL_188;
      }
      v69 = *v68;
      *(_BYTE *)(v10 + 64) = 0;
      v2 = v68;
      if (v69 >= 1)
        break;
      v8 = 1 - v59 + v8 + (_DWORD)v9 - v60;
      v11 = v163;
      v14 = (*(_QWORD *)(v13 + 40) - (_QWORD)v163) >> 1;
      if ((int)v12 - (int)v9 < (int)v14)
        LODWORD(v14) = v12 - (_DWORD)v9;
      v18 = (int32x4_t)xmmword_18BE14600;
      v17 = (int32x4_t)xmmword_18BE145F0;
      v19 = (int32x4_t)xmmword_18BE14610;
      result = 2;
    }
    v20 = (unsigned __int8 *)(v59 + v60);
    v8 = v8 + (_DWORD)v9 - v59 - v60 + 1;
LABEL_190:
    v143 = *v2 > 0 || (unint64_t)v9 >= v12;
    if (!v143 && (unint64_t)v163 >= *(_QWORD *)(v13 + 40))
      *v2 = 15;
    v144 = v162;
    if (v162 && v9 != v20)
    {
      v145 = v20 - v9;
      do
      {
        *v144++ = v8++;
        v143 = __CFADD__(v145++, 1);
      }
      while (!v143);
    }
    *(_QWORD *)(v13 + 16) = v9;
    *(_QWORD *)(v13 + 32) = v163;
    *(_QWORD *)(v13 + 48) = v144;
    return result;
  }
  v125 = *(_QWORD *)(v3 + 8);
  v124 = *(_BYTE **)(v3 + 16);
  v127 = *(_QWORD *)(v3 + 24);
  v126 = *(_WORD **)(v3 + 32);
  v128 = *(_QWORD *)(v3 + 40);
  v162 = *(int **)(v3 + 48);
  v163 = v126;
  v129 = 64;
  if ((*(_BYTE *)(v125 + 56) & 0x10) == 0)
    v129 = 56;
  if ((unint64_t)v124 >= v127)
  {
LABEL_179:
    v132 = (unint64_t)v124;
    goto LABEL_180;
  }
  v130 = 0;
  v131 = *(_QWORD *)(*(_QWORD *)(v125 + 48) + v129);
  while (1)
  {
    v126 = v163;
    if ((unint64_t)v163 >= v128)
    {
      *v2 = 15;
      goto LABEL_179;
    }
    v132 = (unint64_t)(v124 + 1);
    v164[0] = (uint64_t)(v124 + 1);
    v133 = *(_DWORD *)(v131 + 4 * *v124);
    if (v133 < -2146435072)
    {
LABEL_155:
      *v163 = v133;
      v163 = v126 + 1;
      v134 = v162;
      if (v162)
      {
        *v162 = v130;
        v162 = v134 + 1;
      }
      goto LABEL_167;
    }
    if ((v133 & 0xD00000) == 0x100000)
      break;
    v138 = (v133 >> 20) & 0xF;
    if (v138 == 2)
      goto LABEL_155;
    if (v138 != 6)
    {
      if (v138 == 7)
      {
        *v2 = 12;
        goto LABEL_180;
      }
      goto LABEL_167;
    }
    if (*v2 > 0)
      goto LABEL_177;
    *(_QWORD *)(v3 + 16) = v132;
    *(_BYTE *)(v125 + 65) = *v124;
    v139 = *(_QWORD *)(*(_QWORD *)(v125 + 48) + 288);
    if (v139
      && (v140 = v2,
          result = sub_18BC19238(v125, v139, 1, v164, v127, (unint64_t *)&v163, v128, &v162, v130, *(_BYTE *)(v3 + 2), v2), v2 = v140, (_DWORD)result))
    {
      v141 = 0;
      v142 = *v140;
    }
    else
    {
      v142 = 10;
      *v2 = 10;
      v141 = 1;
    }
    *(_BYTE *)(v125 + 64) = v141;
    v132 = v164[0];
    if (v142 >= 1)
    {
LABEL_177:
      v126 = v163;
      goto LABEL_180;
    }
    v130 += LODWORD(v164[0]) - *(_DWORD *)(v3 + 16) + 1;
LABEL_168:
    v124 = (_BYTE *)v132;
    if (v132 >= v127)
      goto LABEL_177;
  }
  *v163 = (v133 >> 10) & 0x3FF | 0xD800;
  v135 = v126 + 1;
  v136 = v162;
  v137 = v133 & 0x3FF | 0xDC00;
  if (v162)
  {
    *v162 = v130;
    v162 = v136 + 1;
    if ((unint64_t)v135 >= v128)
      goto LABEL_184;
    v163 = v126 + 2;
    v126[1] = v137;
    v162 = v136 + 2;
    v136[1] = v130;
    goto LABEL_167;
  }
  if ((unint64_t)v135 < v128)
  {
    v163 = v126 + 2;
    v126[1] = v137;
LABEL_167:
    ++v130;
    goto LABEL_168;
  }
LABEL_184:
  *(_WORD *)(v125 + 144) = v137;
  *(_BYTE *)(v125 + 93) = 1;
  *v2 = 15;
  ++v126;
LABEL_180:
  *(_QWORD *)(v3 + 16) = v132;
  *(_QWORD *)(v3 + 32) = v126;
  *(_QWORD *)(v3 + 48) = v162;
  return result;
}

uint64_t sub_18BC272C0(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  v2 = *(_DWORD *)(a1 + 4);
  if (!v2)
    return 65534;
  v3 = *(_QWORD *)(a1 + 32);
  if (v2 == 1)
  {
    v4 = 0;
  }
  else
  {
    LODWORD(v4) = 0;
    do
    {
      v5 = (v2 + v4) >> 1;
      v6 = *(_DWORD *)(v3 + 8 * v5);
      if (v6 <= a2)
        v4 = v5;
      else
        v4 = v4;
      if (v6 > a2)
        v2 = v5;
    }
    while (v4 < v2 - 1);
  }
  if (*(_DWORD *)(v3 + 8 * v4) == a2)
    return *(unsigned int *)(v3 + 8 * v4 + 4);
  else
    return 65534;
}

uint64_t sub_18BC2732C(uint64_t a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  int v6;
  BOOL v7;

  v4 = *(_DWORD *)(a1 + ((unint64_t)a2 << 10) + 4 * a4);
  if ((v4 & 0x80000000) == 0)
    return sub_18BC2B050(a1, HIBYTE(v4));
  v6 = (v4 >> 20) & 0xF;
  if (a3)
    v7 = v6 == 8;
  else
    v7 = 0;
  return !v7 && v6 != 7;
}

uint64_t sub_18BC2735C(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  unsigned int v12;
  uint64_t result;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  BOOL v17;
  uint64_t v18;

  v3 = a3 - 1;
  if (a3 < 1)
    return 0xFFFFLL;
  v6 = 0;
  v7 = 0;
  v8 = a1 + 48;
  v9 = *(_QWORD *)(a1 + 72);
  v11 = *(unsigned __int8 *)(a1 + 49);
  while (1)
  {
    v12 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + (v11 << 10) + 4 * *(unsigned __int8 *)(a2 + v6));
    if ((v12 & 0x80000000) != 0)
      break;
    ++v6;
    v11 = HIBYTE(v12);
    v7 += v12 & 0xFFFFFF;
    if (a3 == v6)
      return 0xFFFFLL;
  }
  result = 65534;
  switch((v12 >> 20) & 0xF)
  {
    case 0u:
    case 2u:
      result = (unsigned __int16)v12;
      goto LABEL_18;
    case 1u:
    case 3u:
      result = (v12 & 0xFFFFF) + 0x10000;
      goto LABEL_18;
    case 4u:
      v14 = v7 + (unsigned __int16)v12;
      result = *(unsigned __int16 *)(v9 + 2 * v14);
      if ((_DWORD)result == 65534)
        result = sub_18BC272C0(v8, v14);
      goto LABEL_18;
    case 5u:
      v15 = v7 + (unsigned __int16)v12;
      result = *(unsigned __int16 *)(v9 + 2 * v15);
      if (result >> 11 < 0x1B)
        goto LABEL_18;
      v16 = v15 + 1;
      if (result >> 13 > 6)
      {
        if ((result & 0xFFFE) == 0xE000)
        {
          result = *(unsigned __int16 *)(v9 + 2 * v16);
        }
        else
        {
          v17 = (_DWORD)result == 0xFFFF;
          result = 0xFFFFLL;
          if (v17)
            return result;
          result = 65534;
        }
      }
      else
      {
        result = ((result & 0x3FF) << 10) + *(unsigned __int16 *)(v9 + 2 * v16) + 9216;
      }
LABEL_18:
      if (v3 != (_DWORD)v6)
        return 0xFFFFLL;
      if ((_DWORD)result == 65534)
      {
        v18 = *(_QWORD *)(a1 + 288);
        if (v18)
          result = sub_18BC195FC(v18, a2, a3);
        else
          result = 65534;
      }
      break;
    case 6u:
      goto LABEL_18;
    default:
      return 0xFFFFLL;
  }
  return result;
}

uint64_t sub_18BC274E8(uint64_t result, int *a2)
{
  int *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  int v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  char *v21;
  int v22;
  unsigned __int16 *v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  unint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unint64_t v34;
  int v35;
  int v36;
  unsigned int v37;
  unint64_t v38;
  unsigned __int16 *v39;
  _BYTE *v40;
  int v41;
  int *v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  int v62;
  unsigned __int16 *v63;
  uint64_t v64;
  unint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  char v72;
  uint64_t v73;
  int v74;
  unsigned int v75;
  int v76;
  unsigned __int16 *v77;
  unsigned int v78;
  _BYTE *v79;
  unsigned int v80;
  _BYTE *v81;
  int v82;
  int *v83;
  uint64_t v84;
  uint64_t i;
  int v86;
  int v87;
  int *v88;
  int v89;
  unsigned int v90;
  int v91;
  int v92;
  _BYTE *v93;
  int v94;
  char v95;
  int v98;
  int v99;
  unsigned int v100;
  char v101;
  unsigned int v102;
  uint64_t v103;
  int v104;
  _BYTE *v105;
  unsigned int v106;
  unint64_t v107;
  int v108;
  unsigned int v109;
  unsigned int v110;
  unint64_t v111;
  unsigned __int8 *v112;
  int v113;
  int v114;
  unsigned int v115;
  unsigned int v116;
  int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  int v121;
  int v122;
  unsigned int v123;
  int v124;
  unsigned __int8 *v125;
  int v126;
  BOOL v127;
  unsigned __int8 *v128;
  int v129;
  int v130;
  int v131;
  int v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  int v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  _BYTE *v143;
  int *v144;
  int *v145;
  int v146;
  int v147;
  int v148;
  _BYTE *v149;
  int *v150;
  _BYTE *v151;
  int *v152;
  _BYTE *v153;
  int *v154;
  _BYTE *v155;
  int *v156;
  _BYTE *v157;
  _BYTE *v158;
  _BYTE *v159;
  _BYTE *v160;
  _BYTE *v161;
  unsigned int v162;
  _BYTE *v163;
  int *v164;
  _BYTE *v165;
  int *v166;
  _BYTE *v167;
  int *v168;
  unsigned int v169;
  int v170;
  _BYTE *v171;
  unsigned int v172;
  int *v173;
  int v174;
  _BYTE *v175;
  int *v176;
  int v178;
  _BYTE *v180;
  int *v181;
  int v182;
  int *v183;
  _BYTE *v184;
  _BYTE *v185;
  int *v186;
  int *v187;
  int v188;
  char v189;
  int v190;
  int v191;
  uint64_t v192;
  int v193;
  int v194;
  uint64_t v195;
  char v196;
  uint64_t v197;
  char v198;
  int v199;
  int v200;
  unsigned int v201;
  int v202;
  int *v203;
  int *v204;
  _BYTE *v205;
  unint64_t v206;
  int *v207;
  _BYTE *v208;
  unsigned __int16 *v209;

  v2 = a2;
  v3 = result;
  v205 = 0;
  v206 = 0;
  v204 = 0;
  v4 = *(_QWORD *)(result + 8);
  if ((*(_DWORD *)(v4 + 208) & 0x80000000) == 0)
  {
    result = sub_18BC19DC0(*(_QWORD *)(result + 8), result, -1, a2);
    if (*v2 > 0 || *(char *)(v4 + 281) < 0)
      return result;
  }
  v5 = *(_QWORD *)(v4 + 48);
  v6 = *(unsigned __int8 *)(v5 + 252);
  v7 = *(_BYTE *)(v5 + 253);
  v8 = v6 - 1;
  if ((_DWORD)v6 == 1)
  {
    if (*(_BYTE *)(v5 + 254))
    {
      v22 = 0;
      v24 = *(_QWORD *)(v3 + 8);
      v23 = *(unsigned __int16 **)(v3 + 16);
      v25 = *(_QWORD *)(v24 + 48);
      v26 = *(_BYTE *)(v25 + 253);
      v27 = *(_QWORD *)(v3 + 24);
      v208 = *(_BYTE **)(v3 + 32);
      v209 = 0;
      v28 = *(_DWORD *)(v3 + 40) - (_DWORD)v208;
      v207 = *(int **)(v3 + 48);
      v29 = *(_QWORD *)(v25 + 88);
      v30 = *(_QWORD *)(v25 + 96);
      v31 = 240;
      if ((*(_BYTE *)(v24 + 56) & 0x10) == 0)
        v31 = 232;
      v32 = *(_QWORD *)(v25 + v31);
      v33 = *(_DWORD *)(v25 + 260);
      LODWORD(v34) = *(_DWORD *)(v24 + 84);
      if ((_DWORD)v34)
        v35 = -1;
      else
        v35 = 0;
      if (!(_DWORD)v34 || v28 <= 0)
        goto LABEL_386;
      do
      {
        if ((unint64_t)v23 >= v27)
          goto LABEL_419;
        v36 = *v23;
        if ((v36 & 0xFC00) != 0xDC00)
          break;
        v209 = ++v23;
        ++v22;
        v34 = (((_DWORD)v34 << 10) - 56613888 + v36);
        if ((v26 & 1) != 0)
          goto LABEL_29;
LABEL_123:
        while (2)
        {
          *(_QWORD *)(v3 + 16) = v23;
          result = sub_18BC289CC(v24, *(_QWORD *)(v24 + 48), v34, (uint64_t *)&v209, v27, &v208, (unint64_t)&v208[v28], &v207, v35, *(_BYTE *)(v3 + 2), v2);
          LODWORD(v34) = result;
          v23 = v209;
          if (*v2 > 0)
            goto LABEL_419;
          v35 = v22 + (((unint64_t)v209 - *(_QWORD *)(v3 + 16)) >> 1);
          v28 = *(_DWORD *)(v3 + 40) - (_DWORD)v208;
          v22 = v35;
LABEL_386:
          if ((unint64_t)v23 >= v27)
            goto LABEL_419;
          if (v28 < 1)
          {
LABEL_397:
            v178 = 15;
LABEL_398:
            *v2 = v178;
            goto LABEL_419;
          }
          ++v22;
          while (1)
          {
            v34 = *v23;
            v209 = v23 + 1;
            if (v34 > 0x7F)
              break;
            if (((v33 >> (v34 >> 2)) & 1) == 0)
            {
              ++v23;
LABEL_408:
              v37 = *(unsigned __int16 *)(v32 + 2 * ((v34 & 0x3F) + *(unsigned __int16 *)(v30 + ((v34 >> 5) & 0x7FE))));
LABEL_409:
              if (!v37)
                goto LABEL_123;
LABEL_410:
              if (v37 > 0xFF)
              {
                v184 = v208++;
                *v184 = BYTE1(v37);
                if (v28 < 2)
                {
                  v187 = v207;
                  if (v207)
                  {
                    *v207 = v35;
                    v207 = v187 + 1;
                  }
                  LODWORD(v34) = 0;
                  *(_BYTE *)(v24 + 104) = v37;
                  *(_BYTE *)(v24 + 91) = 1;
                  *v2 = 15;
                  v23 = v209;
LABEL_419:
                  *(_DWORD *)(v24 + 84) = v34;
                  *(_QWORD *)(v3 + 16) = v23;
LABEL_383:
                  *(_QWORD *)(v3 + 32) = v208;
                  v145 = v207;
                  goto LABEL_384;
                }
                v185 = v208++;
                *v185 = v37;
                v186 = v207;
                v182 = -2;
                if (v207)
                {
                  v181 = v207 + 1;
                  *v207 = v35;
                  v183 = v186 + 2;
LABEL_416:
                  v207 = v183;
                  *v181 = v35;
                }
              }
              else
              {
                v180 = v208++;
                *v180 = v37;
                v181 = v207;
                v182 = -1;
                if (v207)
                {
                  v183 = v207 + 1;
                  goto LABEL_416;
                }
              }
              LODWORD(v34) = 0;
              v28 += v182;
              v23 = v209;
              v35 = v22;
              goto LABEL_386;
            }
            v175 = v208++;
            *v175 = v34;
            v176 = v207;
            if (v207)
            {
              *v207 = v35;
              v207 = v176 + 1;
              v35 = v22;
            }
            v23 = v209;
            if ((unint64_t)v209 >= v27)
            {
              LODWORD(v34) = 0;
              goto LABEL_419;
            }
            ++v22;
            if (v28-- < 2)
            {
              LODWORD(v34) = 0;
              goto LABEL_397;
            }
          }
          ++v23;
          if (v34 >> 11 < 0x1B)
            goto LABEL_408;
          if ((v34 & 0xF800) != 0xD800 || (v26 & 2) != 0)
          {
LABEL_29:
            v37 = *(unsigned __int16 *)(v32
                                      + 2
                                      * (v34 & 0xF | (16
                                                    * (unsigned __int16)*(_DWORD *)(v29
                                                                                                + 4
                                                                                                * (((v34 >> 4) & 0x3F)
                                                                                                 + *(unsigned __int16 *)(v29 + 2 * ((int)v34 >> 10)))))));
            if (((*(_DWORD *)(v29
                             + 4
                             * (((v34 >> 4) & 0x3F) + *(unsigned __int16 *)(v29 + 2 * ((int)v34 >> 10)))) >> (v34 & 0xF | 0x10)) & 1) != 0)
              goto LABEL_410;
            if (*(_BYTE *)(v24 + 63)
              || (v34 - 57344) >> 8 < 0x19
              || !((v34 - 983040) >> 17))
            {
              goto LABEL_409;
            }
            continue;
          }
          break;
        }
      }
      while ((v34 & 0x400) == 0);
      v178 = 12;
      goto LABEL_398;
    }
  }
  else if (!*(_BYTE *)(v5 + 252) && (*(_BYTE *)(v5 + 253) & 2) == 0)
  {
    if ((*(_BYTE *)(v5 + 253) & 1) == 0)
    {
      v10 = *(_QWORD *)(v3 + 8);
      v9 = *(char **)(v3 + 16);
      v11 = *(_QWORD *)(v3 + 24);
      v208 = *(_BYTE **)(v3 + 32);
      v209 = (unsigned __int16 *)v9;
      v12 = *(_DWORD *)(v3 + 40) - (_DWORD)v208;
      v207 = *(int **)(v3 + 48);
      v13 = *(_QWORD *)(v10 + 48);
      v14 = *(_QWORD *)(v13 + 88);
      v15 = 240;
      if ((*(_BYTE *)(v10 + 56) & 0x10) == 0)
        v15 = 232;
      v16 = *(_QWORD *)(v13 + v15);
      v17 = *(_DWORD *)(v13 + 260);
      v202 = *(unsigned __int8 *)(v10 + 63);
      LODWORD(v18) = *(_DWORD *)(v10 + 84);
      if ((_DWORD)v18)
        v19 = -1;
      else
        v19 = 0;
      v20 = (v11 - (unint64_t)v9) >> 1;
      if ((int)v20 >= v12)
        LODWORD(v20) = v12;
      if (!(_DWORD)v18 || (v21 = v9, (int)v20 <= 0))
      {
LABEL_81:
        if ((int)v20 < 1)
          goto LABEL_118;
        if (v202)
          v75 = 2048;
        else
          v75 = 3072;
        v76 = v20 + 1;
        while (1)
        {
          v77 = v209;
          v78 = *v209;
          v18 = *v209++;
          if (v78 <= 0x7F && ((v17 >> (v18 >> 2)) & 1) != 0)
          {
            v79 = v208++;
            *v79 = v18;
          }
          else
          {
            v80 = *(unsigned __int16 *)(v16
                                      + 2
                                      * ((v18 & 0xF)
                                       + *(unsigned __int16 *)(v14
                                                             + 2
                                                             * (((v18 >> 4) & 0x3F)
                                                              + *(unsigned __int16 *)(v14 + ((v18 >> 9) & 0x7E))))));
            if (v75 > v80)
            {
              v21 = (char *)(v77 + 1);
              if ((v18 & 0xF800) == 0xD800)
              {
                if ((v18 & 0x400) == 0)
                  break;
LABEL_119:
                v91 = 12;
LABEL_122:
                *v2 = v91;
                goto LABEL_93;
              }
LABEL_107:
              if (v18 < 0x10000)
                v87 = 1;
              else
                v87 = 2;
              v88 = v207;
              if (v207)
              {
                v89 = ((unint64_t)(v21 - v9) >> 1) - v87;
                if (v89 >= 1)
                {
                  v90 = v89 + 1;
                  do
                  {
                    *v88++ = v19++;
                    --v90;
                  }
                  while (v90 > 1);
                  v207 = v88;
                }
              }
              result = sub_18BC289CC(v10, *(_QWORD *)(v10 + 48), v18, (uint64_t *)&v209, v11, &v208, *(_QWORD *)(v3 + 40), &v207, v19, *(_BYTE *)(v3 + 2), v2);
              LODWORD(v18) = result;
              v9 = (char *)v209;
              v19 += v87 + ((unint64_t)((char *)v209 - v21) >> 1);
              if (*v2 <= 0)
              {
                v20 = (v11 - (unint64_t)v209) >> 1;
                if ((int)v20 >= *(_DWORD *)(v3 + 40) - (int)v208)
                  LODWORD(v20) = *(_DWORD *)(v3 + 40) - (_DWORD)v208;
                goto LABEL_81;
              }
LABEL_118:
              v21 = v9;
              goto LABEL_93;
            }
            v81 = v208++;
            *v81 = v80;
          }
          if (--v76 <= 1)
          {
            LODWORD(v18) = 0;
            v21 = (char *)v209;
            goto LABEL_93;
          }
        }
      }
      if ((unint64_t)v21 < v11)
      {
        v86 = *(unsigned __int16 *)v21;
        if ((v86 & 0xFC00) != 0xDC00)
          goto LABEL_119;
        v21 += 2;
        v209 = (unsigned __int16 *)v21;
        v18 = (((_DWORD)v18 << 10) - 56613888 + v86);
        goto LABEL_107;
      }
      if (*(_BYTE *)(v3 + 2))
      {
        v91 = 11;
        goto LABEL_122;
      }
LABEL_93:
      v82 = *v2;
      if (*v2 <= 0 && (unint64_t)v21 < v11 && (unint64_t)v208 >= *(_QWORD *)(v3 + 40))
      {
        v82 = 15;
        *v2 = 15;
      }
      v83 = v207;
      if (v207)
      {
        v84 = v21 - v9;
        if (v84)
        {
          for (i = (v84 >> 1) - (v82 == 11); i; --i)
            *v83++ = v19++;
        }
      }
      *(_DWORD *)(v10 + 84) = v18;
      *(_QWORD *)(v3 + 16) = v21;
      *(_QWORD *)(v3 + 32) = v208;
      *(_QWORD *)(v3 + 48) = v83;
      return result;
    }
    v62 = 0;
    v64 = *(_QWORD *)(v3 + 8);
    v63 = *(unsigned __int16 **)(v3 + 16);
    v65 = *(_QWORD *)(v3 + 24);
    v208 = *(_BYTE **)(v3 + 32);
    v209 = 0;
    v66 = *(_DWORD *)(v3 + 40) - (_DWORD)v208;
    v207 = *(int **)(v3 + 48);
    v67 = *(_QWORD *)(v64 + 48);
    v68 = *(_QWORD *)(v67 + 88);
    v69 = 240;
    if ((*(_BYTE *)(v64 + 56) & 0x10) == 0)
      v69 = 232;
    v70 = *(_QWORD *)(v67 + v69);
    if (*(_BYTE *)(v64 + 63))
      v71 = 2048;
    else
      v71 = 3072;
    v72 = *(_BYTE *)(v67 + 253);
    LODWORD(v73) = *(_DWORD *)(v64 + 84);
    if ((_DWORD)v73)
      v74 = -1;
    else
      v74 = 0;
    if ((_DWORD)v73 && v66 > 0)
      goto LABEL_368;
    while (1)
    {
      if ((unint64_t)v63 >= v65)
      {
LABEL_382:
        *(_DWORD *)(v64 + 84) = v73;
        *(_QWORD *)(v3 + 16) = v63;
        goto LABEL_383;
      }
      if (v66 < 1)
      {
        v174 = 15;
        goto LABEL_381;
      }
      v169 = *v63++;
      v73 = v169;
      v209 = v63;
      ++v62;
      if ((v169 & 0xF800) != 0xD800)
        break;
      if ((v73 & 0x400) != 0)
        goto LABEL_379;
LABEL_368:
      if ((unint64_t)v63 >= v65)
        goto LABEL_382;
      v170 = *v63;
      if ((v170 & 0xFC00) != 0xDC00)
      {
LABEL_379:
        v174 = 12;
LABEL_381:
        *v2 = v174;
        goto LABEL_382;
      }
      v209 = ++v63;
      ++v62;
      v73 = (((_DWORD)v73 << 10) - 56613888 + v170);
      v171 = v208;
      if ((v72 & 1) != 0)
      {
LABEL_373:
        v172 = *(unsigned __int16 *)(v70
                                   + 2
                                   * ((v73 & 0xF)
                                    + *(unsigned __int16 *)(v68
                                                          + 2
                                                          * (((v73 >> 4) & 0x3F)
                                                           + *(unsigned __int16 *)(v68 + 2 * ((int)v73 >> 10))))));
        if (v71 > v172)
          goto LABEL_374;
        v208 = v171 + 1;
        *v171 = v172;
        v173 = v207;
        if (v207)
        {
          *v207 = v74;
          v207 = v173 + 1;
        }
        LODWORD(v73) = 0;
        --v66;
        v63 = v209;
        v74 = v62;
      }
      else
      {
LABEL_374:
        *(_QWORD *)(v3 + 16) = v63;
        result = sub_18BC289CC(v64, *(_QWORD *)(v64 + 48), v73, (uint64_t *)&v209, v65, &v208, (unint64_t)&v171[v66], &v207, v74, *(_BYTE *)(v3 + 2), v2);
        LODWORD(v73) = result;
        v63 = v209;
        if (*v2 > 0)
          goto LABEL_382;
        v74 = v62 + (((unint64_t)v209 - *(_QWORD *)(v3 + 16)) >> 1);
        v66 = *(_DWORD *)(v3 + 40) - (_DWORD)v208;
        v62 = v74;
      }
    }
    v171 = v208;
    goto LABEL_373;
  }
  v39 = *(unsigned __int16 **)(v3 + 16);
  v38 = *(_QWORD *)(v3 + 24);
  v40 = *(_BYTE **)(v3 + 32);
  v205 = v40;
  v206 = (unint64_t)v39;
  v41 = *(_DWORD *)(v3 + 40);
  v42 = *(int **)(v3 + 48);
  v204 = v42;
  if (*(_BYTE *)(v5 + 254))
    v43 = *(_QWORD *)(v5 + 96);
  else
    v43 = 0;
  v44 = *(_DWORD *)(v4 + 56);
  v45 = 232;
  if ((v44 & 0x10) != 0)
    v45 = 240;
  LODWORD(v46) = *(_DWORD *)(v4 + 84);
  if ((_DWORD)v6 == 12)
  {
    v47 = *(_DWORD *)(v4 + 80);
    if (v47 <= 1)
      v47 = 1;
  }
  else
  {
    v47 = 0;
  }
  v48 = v41 - (_DWORD)v40;
  v195 = *(_QWORD *)(v5 + 88);
  v197 = *(_QWORD *)(v5 + v45);
  if ((_DWORD)v46)
    v49 = -1;
  else
    v49 = 0;
  if ((v44 & 0x1000) != 0)
  {
    v192 = 0x4100420000;
    v196 = 2;
    v193 = 2;
    v194 = 10;
    v56 = 10;
    v57 = 2;
LABEL_66:
    v190 = v57;
    v191 = v56;
    goto LABEL_67;
  }
  if ((v44 & 0x2000) != 0)
  {
    v196 = 1;
    v192 = 0;
    v56 = 40;
    v57 = 1;
    v193 = 1;
    v194 = 41;
    goto LABEL_66;
  }
  v50 = v44 << 17;
  if ((v44 & 0x4000) != 0)
    v51 = 26;
  else
    v51 = 15;
  if ((v44 & 0x4000) != 0)
    v52 = 2;
  else
    v52 = 1;
  result = 1;
  if ((v44 & 0x4000) != 0)
    v53 = 26;
  else
    v53 = 14;
  v191 = v53;
  v193 = v52;
  v194 = v51;
  v196 = v52;
  if ((*(_DWORD *)(v4 + 56) & 0x4000) != 0)
    v54 = 7340032;
  else
    v54 = 0;
  if ((*(_DWORD *)(v4 + 56) & 0x4000) != 0)
    v55 = 2;
  else
    v55 = 1;
  v190 = v55;
  LODWORD(v192) = v54;
  HIDWORD(v192) = (v50 >> 31) & 0x71;
LABEL_67:
  v58 = 0;
  v59 = *(_DWORD *)(v5 + 260);
  v60 = -1;
  v203 = v2;
  v201 = v59;
  v199 = v6 - 1;
  v198 = v7;
  v61 = 0;
  if ((_DWORD)v46 && v48 > 0)
    goto LABEL_149;
  while (1)
  {
    while (1)
    {
      if ((unint64_t)v39 >= v38)
        goto LABEL_162;
      v92 = v48 & (v48 >> 31);
      if (v48 < 1)
      {
LABEL_135:
        v94 = 15;
        goto LABEL_136;
      }
      ++v58;
      while (1)
      {
        v46 = *v39;
        v206 = (unint64_t)(v39 + 1);
        if (v46 > 0x7F || ((v59 >> (v46 >> 2)) & 1) == 0)
          break;
        v93 = v205++;
        *v93 = v46;
        v42 = v204;
        if (v204)
        {
          *v204 = v49;
          v204 = ++v42;
          v60 = v49;
          v49 = v58;
        }
        --v48;
        v39 = (unsigned __int16 *)v206;
        if (v206 >= v38)
        {
          LODWORD(v46) = 0;
          goto LABEL_162;
        }
        ++v58;
        if (v48 + 1 < 2)
        {
          LODWORD(v46) = 0;
          goto LABEL_135;
        }
      }
      ++v39;
      if (v46 >> 11 > 0x1A || v43 == 0)
        break;
      v104 = *(unsigned __int16 *)(v43 + ((v46 >> 5) & 0x7FE));
      switch(v8)
      {
        case 0:
          v102 = *(unsigned __int16 *)(v197 + 2 * ((v46 & 0x3F) + v104));
          if (v102 > 0xFF)
            goto LABEL_241;
          goto LABEL_289;
        case 1:
          v125 = (unsigned __int8 *)(v197 + 3 * ((v46 & 0x3F) + v104));
          v102 = (*v125 << 16) | (v125[1] << 8) | v125[2];
          if (v102 <= 0xFF)
            goto LABEL_289;
          if (v102 < 0x10000)
            v61 = 2;
          else
            v61 = 3;
          break;
        case 2:
          v102 = *(_DWORD *)(v197 + 4 * ((v46 & 0x3F) + v104));
          if (v102 <= 0xFF)
            goto LABEL_289;
          if (HIBYTE(v102))
            LODWORD(v61) = 4;
          else
            LODWORD(v61) = 3;
          if (v102 >= 0x10000)
            v61 = v61;
          else
            v61 = 2;
          break;
        case 3:
        case 4:
        case 5:
        case 6:
        case 9:
        case 10:
          goto LABEL_265;
        case 7:
          v102 = *(unsigned __int16 *)(v197 + 2 * ((v46 & 0x3F) + v104));
          if (v102 <= 0xFF)
            goto LABEL_289;
          v126 = v102 | 0x8F0080;
          if ((v102 & 0x80) != 0)
          {
            v126 = v102;
            LODWORD(v61) = 2;
          }
          else
          {
            LODWORD(v61) = 3;
          }
          v127 = (v102 & 0x8000) == 0;
          if ((v102 & 0x8000) != 0)
            v102 = v126;
          else
            v102 |= 0x8E8000u;
          if (v127)
            v61 = 3;
          else
            v61 = v61;
          break;
        case 8:
          v128 = (unsigned __int8 *)(v197 + 3 * ((v46 & 0x3F) + v104));
          v129 = *v128;
          v130 = v128[1];
          v102 = v128[2] | (v129 << 16) | (v130 << 8);
          if (v102 > 0xFF)
          {
            v61 = 2;
            if (v102 >= 0x10000)
            {
              if ((char)v129 < 0)
              {
                if ((v130 & 0x80u) != 0)
                {
                  v61 = 3;
                }
                else
                {
                  v102 |= 0x8F008000;
                  v61 = 4;
                }
              }
              else
              {
                v102 |= 0x8E800000;
                v61 = 4;
              }
            }
          }
          else
          {
LABEL_289:
            v103 = v61;
            v61 = 1;
            if (!v102)
              goto LABEL_305;
          }
          break;
        case 11:
          *(_DWORD *)(v4 + 80) = v47;
          v102 = *(unsigned __int16 *)(v197 + 2 * ((v46 & 0x3F) + v104));
          if (v102 > 0xFF)
          {
            v146 = v102 | (v191 << 16);
            v147 = v192 | (v191 << 24) | v102;
            result = 4;
            if (v190 == 2)
              LODWORD(v61) = 4;
            else
              v147 = v102;
            if (v190 == 1)
              LODWORD(v61) = 3;
            else
              v146 = v147;
            if (v47 == 2)
            {
              v61 = 2;
            }
            else
            {
              v102 = v146;
              v61 = v61;
            }
            v47 = 2;
          }
          else
          {
            if (!v102)
              goto LABEL_304;
            v131 = v102 | (v194 << 8);
            v132 = (v194 << 16) | (HIDWORD(v192) << 8) | v102;
            result = 3;
            if (v193 == 2)
              LODWORD(v61) = 3;
            else
              v132 = v102;
            if (v193 == 1)
              LODWORD(v61) = 2;
            else
              v131 = v132;
            if (v47 < 2)
            {
              v61 = 1;
            }
            else
            {
              v102 = v131;
              v61 = v61;
            }
            if (v47 >= 2)
              v47 = 1;
          }
          break;
        default:
          if ((_DWORD)v6 == 219)
          {
            v102 = *(unsigned __int16 *)(v197 + 2 * ((v46 & 0x3F) + v104));
            if (v102 < 0x100)
              goto LABEL_304;
LABEL_241:
            v61 = 2;
          }
          else
          {
LABEL_265:
            v102 = 0;
            v61 = 0;
          }
          break;
      }
LABEL_327:
      v148 = v61 - v48;
      if ((int)v61 > v48)
      {
        v161 = (_BYTE *)(v4 + 104);
        if (v148 == 1)
        {
          v2 = v203;
          v95 = v196;
        }
        else
        {
          v2 = v203;
          v95 = v196;
          if (v148 != 2)
          {
            if (v148 != 3)
              goto LABEL_350;
            v161 = (_BYTE *)(v4 + 105);
            *(_BYTE *)(v4 + 104) = BYTE2(v102);
          }
          *v161++ = BYTE1(v102);
        }
        *v161 = v102;
LABEL_350:
        *(_BYTE *)(v4 + 91) = v148;
        v162 = v102 >> (8 * v148);
        if (v48 != 1)
        {
          if (v48 != 2)
          {
            if (v48 != 3)
              goto LABEL_359;
            v163 = v205++;
            *v163 = BYTE2(v162);
            v164 = v204;
            if (v204)
            {
              *v204 = v49;
              v204 = v164 + 1;
            }
          }
          v165 = v205++;
          *v165 = BYTE1(v162);
          v166 = v204;
          if (v204)
          {
            *v204 = v49;
            v204 = v166 + 1;
          }
        }
        v167 = v205++;
        *v167 = v162;
        v168 = v204;
        if (v204)
        {
          v92 = 0;
          LODWORD(v46) = 0;
          *v204 = v49;
          v204 = v168 + 1;
LABEL_360:
          v94 = 15;
          goto LABEL_137;
        }
LABEL_359:
        v92 = 0;
        LODWORD(v46) = 0;
        goto LABEL_360;
      }
      if (v42)
      {
        v2 = v203;
        v59 = v201;
        switch((int)v61)
        {
          case 1:
            goto LABEL_333;
          case 2:
            goto LABEL_332;
          case 3:
            goto LABEL_331;
          case 4:
            v149 = v205++;
            *v149 = HIBYTE(v102);
            v150 = v204;
            *v204 = v49;
            v204 = v150 + 1;
LABEL_331:
            v151 = v205++;
            *v151 = BYTE2(v102);
            v152 = v204;
            *v204 = v49;
            v204 = v152 + 1;
LABEL_332:
            v153 = v205++;
            *v153 = BYTE1(v102);
            v154 = v204;
            *v204 = v49;
            v204 = v154 + 1;
LABEL_333:
            v155 = v205++;
            *v155 = v102;
            v156 = v204;
            *v204 = v49;
            v42 = v156 + 1;
            v204 = v42;
            break;
          default:
            break;
        }
      }
      else
      {
        v2 = v203;
        v59 = v201;
        switch((int)v61)
        {
          case 1:
            goto LABEL_338;
          case 2:
            goto LABEL_337;
          case 3:
            goto LABEL_336;
          case 4:
            v157 = v205++;
            *v157 = HIBYTE(v102);
LABEL_336:
            v158 = v205++;
            *v158 = BYTE2(v102);
LABEL_337:
            v159 = v205++;
            *v159 = BYTE1(v102);
LABEL_338:
            v160 = v205++;
            *v160 = v102;
            v42 = v204;
            break;
          default:
            break;
        }
      }
      LODWORD(v46) = 0;
      v48 -= v61;
      if (v42)
      {
        v60 = v49;
        v49 = v58;
      }
      v39 = (unsigned __int16 *)v206;
    }
    if ((v46 & 0xF800) == 0xD800 && (v7 & 2) == 0)
      break;
LABEL_154:
    v100 = *(_DWORD *)(v195
                     + 4 * (((v46 >> 4) & 0x3F) + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10))));
    switch(v8)
    {
      case 0:
        v101 = v46 & 0xF;
        v102 = *(unsigned __int16 *)(v197
                                   + 2
                                   * (v46 & 0xF | (16
                                                 * (unsigned __int16)*(_DWORD *)(v195
                                                                                             + 4
                                                                                             * (((v46 >> 4) & 0x3F)
                                                                                              + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
        if (v102 < 0x100)
          v103 = 1;
        else
          v103 = 2;
        goto LABEL_258;
      case 1:
        v101 = v46 & 0xF;
        v107 = v46 & 0xF | (16
                          * (unsigned __int16)*(_DWORD *)(v195
                                                                      + 4
                                                                      * (((v46 >> 4) & 0x3F)
                                                                       + *(unsigned __int16 *)(v195
                                                                                             + 2 * ((int)v46 >> 10)))));
        v102 = (*(unsigned __int8 *)(v197 + v107 + 2 * v107) << 16) | (*(unsigned __int8 *)(v197 + v107 + 2 * v107 + 1) << 8) | *(unsigned __int8 *)(v197 + v107 + 2 * v107 + 2);
        if (v102 < 0x10000)
          LODWORD(v103) = 2;
        else
          LODWORD(v103) = 3;
        goto LABEL_191;
      case 2:
        v101 = v46 & 0xF;
        v102 = *(_DWORD *)(v197
                         + 4
                         * (v46 & 0xF | (16
                                       * (unsigned __int16)*(_DWORD *)(v195
                                                                                   + 4
                                                                                   * (((v46 >> 4) & 0x3F)
                                                                                    + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
        if (HIBYTE(v102))
          v108 = 4;
        else
          v108 = 3;
        if (v102 >= 0x10000)
          LODWORD(v103) = v108;
        else
          LODWORD(v103) = 2;
LABEL_191:
        if (v102 >= 0x100)
          v103 = v103;
        else
          v103 = 1;
        goto LABEL_258;
      case 3:
      case 4:
      case 5:
      case 6:
      case 9:
      case 10:
        goto LABEL_181;
      case 7:
        v101 = v46 & 0xF;
        v109 = *(unsigned __int16 *)(v197
                                   + 2
                                   * (v46 & 0xF | (16
                                                 * (unsigned __int16)*(_DWORD *)(v195
                                                                                             + 4
                                                                                             * (((v46 >> 4) & 0x3F)
                                                                                              + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
        v102 = v109 | 0x8F0080;
        if ((v109 & 0x80) != 0)
        {
          v102 = *(unsigned __int16 *)(v197
                                     + 2
                                     * (v46 & 0xF | (16
                                                   * (unsigned __int16)*(_DWORD *)(v195
                                                                                               + 4
                                                                                               * (((v46 >> 4) & 0x3F)
                                                                                                + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
          v110 = 2;
        }
        else
        {
          v110 = 3;
        }
        result = 3;
        if ((v109 & 0x8000) == 0)
        {
          v102 = v109 | 0x8E8000;
          v110 = 3;
        }
        if (v109 >= 0x100)
        {
          v103 = v110;
        }
        else
        {
          v102 = *(unsigned __int16 *)(v197
                                     + 2
                                     * (v46 & 0xF | (16
                                                   * (unsigned __int16)*(_DWORD *)(v195
                                                                                               + 4
                                                                                               * (((v46 >> 4) & 0x3F)
                                                                                                + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
          v103 = 1;
        }
        goto LABEL_258;
      case 8:
        v101 = v46 & 0xF;
        v111 = v46 & 0xF | (16
                          * (unsigned __int16)*(_DWORD *)(v195
                                                                      + 4
                                                                      * (((v46 >> 4) & 0x3F)
                                                                       + *(unsigned __int16 *)(v195
                                                                                             + 2 * ((int)v46 >> 10)))));
        v112 = (unsigned __int8 *)(v197 + v111 + 2 * v111);
        v113 = *v112;
        v114 = v112[1];
        v115 = v112[2] | (v113 << 16) | (v114 << 8);
        if ((v114 & 0x80u) != 0)
          v116 = v115;
        else
          v116 = v115 | 0x8F008000;
        if ((v114 & 0x80u) != 0)
          v117 = 3;
        else
          v117 = 4;
        result = v115 | 0x8E800000;
        if ((v113 & 0x80u) == 0)
          v118 = v115 | 0x8E800000;
        else
          v118 = v116;
        if ((v113 & 0x80u) == 0)
          v119 = 4;
        else
          v119 = v117;
        if (v115 < 0x10000)
        {
          v118 = v115;
          v119 = 2;
        }
        if (v115 >= 0x100)
          v102 = v118;
        else
          v102 = v115;
        if (v115 >= 0x100)
          v103 = v119;
        else
          v103 = 1;
        goto LABEL_258;
      case 11:
        *(_DWORD *)(v4 + 80) = v47;
        v101 = v46 & 0xF;
        v120 = *(unsigned __int16 *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)));
        if (v120 > 0xFF)
        {
          v123 = v192 | (v191 << 24) | v120;
          v124 = v120 | (v191 << 16);
          if (v190 == 1)
            LODWORD(v61) = 3;
          else
            v124 = *(unsigned __int16 *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)));
          if (v190 == 2)
            LODWORD(v61) = 4;
          else
            v123 = v124;
          result = 2;
          if (v47 == 2)
            v102 = *(unsigned __int16 *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)));
          else
            v102 = v123;
          if (v47 == 2)
            v103 = 2;
          else
            v103 = v61;
          v47 = 2;
        }
        else if (*(_WORD *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)))
               || ((v100 >> (v101 | 0x10)) & 1) != 0)
        {
          v121 = (v194 << 16) | (HIDWORD(v192) << 8) | v120;
          v122 = v120 | (v194 << 8);
          if (v193 == 1)
            LODWORD(v61) = 2;
          else
            v122 = *(unsigned __int16 *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)));
          if (v193 == 2)
            LODWORD(v61) = 3;
          else
            v121 = v122;
          result = 1;
          if (v47 >= 2)
            v102 = v121;
          else
            v102 = *(unsigned __int16 *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)));
          if (v47 >= 2)
            v103 = v61;
          else
            v103 = 1;
          if (v47 >= 2)
            v47 = 1;
        }
        else
        {
          v102 = 0;
          v103 = 0;
        }
        goto LABEL_258;
      default:
        if ((_DWORD)v6 == 219)
        {
          v101 = v46 & 0xF;
          v106 = *(unsigned __int16 *)(v197
                                     + 2
                                     * (v46 & 0xF | (16
                                                   * (unsigned __int16)*(_DWORD *)(v195
                                                                                               + 4
                                                                                               * (((v46 >> 4) & 0x3F)
                                                                                                + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
          if (v106 >= 0x100)
          {
            v102 = *(unsigned __int16 *)(v197
                                       + 2
                                       * (v46 & 0xF | (16
                                                     * (unsigned __int16)*(_DWORD *)(v195
                                                                                                 + 4
                                                                                                 * (((v46 >> 4) & 0x3F)
                                                                                                  + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
          }
          else
          {
            v100 = 0;
            v102 = 0;
          }
          if (v106 >= 0x100)
            v103 = 2;
          else
            v103 = 0;
        }
        else
        {
LABEL_181:
          v100 = 0;
          v102 = 0;
          v103 = 0;
          v101 = v46 & 0xF;
        }
LABEL_258:
        if (((v100 >> (v101 | 0x10)) & 1) != 0)
        {
          v61 = v103;
          goto LABEL_327;
        }
        if (*(_BYTE *)(v4 + 63) || (v46 - 57344) >> 8 < 0x19 || !((v46 - 983040) >> 17))
        {
          v61 = v103;
          if (v102)
            goto LABEL_327;
        }
LABEL_305:
        v200 = v60;
        *(_QWORD *)(v3 + 16) = v39;
        v133 = *(_QWORD *)(v4 + 48);
        v134 = v6;
        v2 = v203;
        v189 = *(_BYTE *)(v3 + 2);
        v188 = v49;
        v135 = v4;
        v136 = v43;
        v137 = v49;
        v138 = v4;
        v139 = v3;
        v140 = v38;
        v141 = v103;
        result = sub_18BC289CC(v135, v133, v46, (uint64_t *)&v206, v38, &v205, (unint64_t)&v205[v48], &v204, v188, v189, v203);
        v142 = v141;
        v38 = v140;
        v3 = v139;
        v4 = v138;
        v49 = v137;
        v43 = v136;
        v6 = v134;
        v60 = v200;
        v59 = v201;
        v7 = v198;
        v8 = v199;
        LODWORD(v46) = result;
        v47 = *(_DWORD *)(v4 + 80);
        if (*v203 > 0)
        {
LABEL_162:
          v95 = v196;
          goto LABEL_163;
        }
        v39 = (unsigned __int16 *)v206;
        v58 += (v206 - *(_QWORD *)(v3 + 16)) >> 1;
        v48 = *(_DWORD *)(v3 + 40) - (_DWORD)v205;
        v42 = v204;
        if (v204)
        {
          v60 = v49;
          v49 = v58;
        }
        v61 = v142;
        break;
    }
  }
  if ((v46 & 0x400) != 0)
    goto LABEL_266;
LABEL_149:
  if ((unint64_t)v39 >= v38)
    goto LABEL_162;
  v98 = *v39;
  if ((v98 & 0xFC00) == 0xDC00)
  {
    v99 = 0;
    v206 = (unint64_t)++v39;
    ++v58;
    v46 = (((_DWORD)v46 << 10) - 56613888 + v98);
    if ((v7 & 1) == 0)
    {
      *(_DWORD *)(v4 + 80) = v47;
      v99 = 6;
    }
    if (v99 == 6)
    {
LABEL_304:
      v103 = v61;
      goto LABEL_305;
    }
    goto LABEL_154;
  }
LABEL_266:
  v94 = 12;
  v92 = v48;
LABEL_136:
  v95 = v196;
LABEL_137:
  *v2 = v94;
  v48 = v92;
LABEL_163:
  if ((_DWORD)v6 == 12 && *v2 <= 0 && v47 == 2)
  {
    if (*(_BYTE *)(v3 + 2))
    {
      v47 = 2;
      if (v206 >= v38 && !(_DWORD)v46)
      {
        if (v48 < 1)
        {
          *(_BYTE *)(v4 + 104) = v194;
          if (v193 == 2)
            *(_BYTE *)(v4 + 105) = BYTE4(v192);
          *(_BYTE *)(v4 + 91) = v95;
          *v2 = 15;
        }
        else
        {
          v105 = v205++;
          *v105 = v194;
          if (v193 == 2)
          {
            if (v48 > 1)
            {
              v143 = v205++;
              *v143 = BYTE4(v192);
            }
            else
            {
              *(_BYTE *)(v4 + 104) = BYTE4(v192);
              *(_BYTE *)(v4 + 91) = 1;
              *v2 = 15;
            }
          }
          v144 = v204;
          if (v204)
          {
            *v204 = v60;
            v204 = v144 + 1;
          }
        }
        v47 = 1;
      }
    }
    else
    {
      v47 = 2;
    }
  }
  *(_DWORD *)(v4 + 80) = v47;
  *(_DWORD *)(v4 + 84) = v46;
  *(_QWORD *)(v3 + 16) = v206;
  *(_QWORD *)(v3 + 32) = v205;
  v145 = v204;
LABEL_384:
  *(_QWORD *)(v3 + 48) = v145;
  return result;
}

uint64_t sub_18BC289CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, _QWORD *a6, unint64_t a7, _QWORD *a8, int a9, char a10, _DWORD *a11)
{
  uint64_t v14;
  unint64_t v16;
  uint64_t v17;
  unsigned int v18;
  BOOL v19;
  int v20;
  unsigned int v22;
  char v23[4];

  v14 = a3;
  *(_BYTE *)(a1 + 95) = 0;
  v16 = *(_QWORD *)(a2 + 288);
  if (!v16 || !sub_18BC19868(a1, v16, a3, a4, a5, a6, a7, a8, a9, a10, a11))
  {
    if ((*(_BYTE *)(a1 + 57) & 0x80) == 0)
    {
LABEL_10:
      *a11 = 10;
      return v14;
    }
    v17 = 0;
    while (1)
    {
      v18 = dword_18BE14774[v17];
      v19 = v14 >= v18;
      v20 = v14 - v18;
      if (v19 && dword_18BE14774[v17 + 1] >= v14)
        break;
      v17 += 4;
      if ((_DWORD)(v17 * 4) == 224)
        goto LABEL_10;
    }
    v22 = v20 + dword_18BE14774[v17 + 2] - 1687218;
    v23[3] = (v22 % 0xA) | 0x30;
    v23[2] = v22 / 0xA - 126 * ((545392673 * (unint64_t)(v22 / 0xA)) >> 36) - 127;
    v23[1] = (v22 / 0x4EC - 10 * ((429496730 * (unint64_t)(v22 / 0x4EC)) >> 32)) | 0x30;
    v23[0] = v22 / 0x3138 - 127;
    sub_18BC17544(a1, v23, 4, a6, a7, a8, a9, a11);
  }
  return 0;
}

uint64_t sub_18BC28B6C(uint64_t a1, int a2, int *a3, int a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t result;

  if (a2 < 0x10000 || (*(_BYTE *)(a1 + 253) & 1) != 0)
  {
    v4 = *(_QWORD *)(a1 + 88);
    if (*(_BYTE *)(a1 + 252) != 1)
    {
      if (*(_BYTE *)(a1 + 252))
        return 0xFFFFFFFFLL;
      v5 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 232)
                               + 2
                               * ((a2 & 0xF)
                                + *(unsigned __int16 *)(v4
                                                                    + 2
                                                                    * (((a2 >> 4) & 0x3F)
                                                                     + *(unsigned __int16 *)(v4 + 2 * (a2 >> 10))))));
      if (a4)
      {
        if (v5 <= 0x7FF)
          goto LABEL_20;
      }
      else if (v5 < 0xC00)
      {
        goto LABEL_20;
      }
      *a3 = v5;
      return 1;
    }
    v6 = *(_DWORD *)(v4 + 4 * (((a2 >> 4) & 0x3F) + *(unsigned __int16 *)(v4 + 2 * (a2 >> 10))));
    v7 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 232) + 2 * (a2 & 0xF | (16 * (unsigned __int16)v6)));
    if (v7 < 0x100)
      v8 = 1;
    else
      v8 = 2;
    if (((v6 >> (a2 & 0xF | 0x10)) & 1) != 0
      || (a4 || (a2 - 57344) >> 8 < 0x19 || !((a2 - 983040) >> 17))
      && *(_WORD *)(*(_QWORD *)(a1 + 232) + 2 * (a2 & 0xF | (16 * (unsigned __int16)v6))))
    {
      *a3 = v7;
      return v8;
    }
  }
LABEL_20:
  v9 = *(_QWORD *)(a1 + 288);
  if (!v9)
    return 0;
  LODWORD(result) = sub_18BC19D3C(v9, a2, a3, a4);
  if ((int)result >= 0)
    return result;
  else
    return -(int)result;
}

BOOL sub_18BC28C80(uint64_t a1, unsigned __int8 a2)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * a2) >= 0;
}

uint64_t sub_18BC28C98(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *(_QWORD *)(a1 + 48);
  if (*(_BYTE *)(v1 + 48) == 1)
    return 0;
  if (*(_BYTE *)(v1 + 252) == 12)
    return 9;
  v3 = *(_QWORD *)(v1 + 16);
  if (*(_BYTE *)(v3 + 70) == 2 && *(_BYTE *)(v3 + 71) == 2)
    return 1;
  else
    return 2;
}

void sub_18BC28CF0(uint64_t a1, uint64_t a2, unsigned __int8 *a3, UErrorCode *a4)
{
  int v8;
  int v9;
  unsigned int v10;
  unsigned __int8 *v11;
  int v12;
  _BYTE *v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int16 v21;
  unsigned int v22;
  uint64_t v23;
  const char *v24;
  _BYTE *v25;
  _QWORD *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int32x4_t v30;
  int8x16_t v31;
  uint32x4_t v32;
  int32x4_t v33;
  int8x8_t v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  size_t v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  unsigned int v44;
  uint64_t v45;
  signed int v46;
  signed int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  unsigned int v52;
  __int128 v53;
  unsigned int v54;
  unint64_t v55;
  int v56;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  int v69;
  unsigned int v70;
  int v71;
  unsigned __int8 *v72;
  _BYTE *v73;
  int v74;
  char *v75;
  char *v76;
  uint64_t v77;
  int v78;
  int32x2_t v79;
  unsigned __int8 *v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  _BYTE v84[48];
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  v8 = *a3;
  if (v8 == 5)
  {
    if (a3[1] < 3u)
      goto LABEL_32;
    v22 = *((_DWORD *)a3 + 8);
    if ((v22 & 0xFF80) != 0)
      goto LABEL_32;
    v12 = *((_DWORD *)a3 + 8) & 0x3F;
    v10 = *((_DWORD *)a3 + 6);
    *(_BYTE *)(a1 + 252) = v10;
    v11 = (unsigned __int8 *)(a1 + 252);
    v9 = (v22 >> 6) & 1;
    if ((v22 & 0x40) != 0 && !(_BYTE)v10)
      goto LABEL_32;
  }
  else
  {
    if (v8 != 4)
      goto LABEL_32;
    v9 = 0;
    v10 = *((_DWORD *)a3 + 6);
    *(_BYTE *)(a1 + 252) = v10;
    v11 = (unsigned __int8 *)(a1 + 252);
    v12 = 8;
  }
  if (v10 >= 0x100)
    *(_QWORD *)(a1 + 288) = &a3[v10 >> 8];
  v81 = 0;
  v82 = 0;
  v83 = 0;
  if (v10 > 0xEu)
    goto LABEL_32;
  v13 = (_BYTE *)(a1 + 48);
  if (((1 << v10) & 0x130F) != 0)
  {
    if (*(_BYTE *)(a2 + 8))
      return;
    v14 = *((unsigned int *)a3 + 1);
    *(_BYTE *)(a1 + 48) = v14;
    *(_DWORD *)(a1 + 52) = *((_DWORD *)a3 + 2);
    v15 = &a3[4 * v12];
    *(_QWORD *)(a1 + 56) = v15;
    *(_QWORD *)(a1 + 80) = &v15[1024 * v14];
    *(_QWORD *)(a1 + 72) = &a3[*((unsigned int *)a3 + 3)];
    *(_QWORD *)(a1 + 88) = &a3[*((unsigned int *)a3 + 4)];
    *(_QWORD *)(a1 + 232) = &a3[*((unsigned int *)a3 + 5)];
    *(_DWORD *)(a1 + 248) = *((_DWORD *)a3 + 7);
    LOWORD(v81) = 20;
    udata_getInfo(*(_QWORD **)(a1 + 8), &v81);
    if (BYTE4(v82) > 6u || BYTE4(v82) == 6 && BYTE5(v82))
    {
      v16 = *(_BYTE *)(*(_QWORD *)(a1 + 16) + 79) & 3;
      *(_BYTE *)(a1 + 253) = v16;
      if (a3[1] >= 3u && v16 < 2)
      {
        v17 = a3[2];
        if (*v13 == 1)
        {
          if (v17 > 0xE)
          {
            v18 = 0;
            v19 = 0;
            *(_BYTE *)(a1 + 254) = 1;
            v20 = *(_QWORD *)(a1 + 88);
            do
            {
              *(_WORD *)(a1 + 104 + 2 * v19) = *(_WORD *)(v20
                                                        + 2
                                                        * ((v18 & 0x3C)
                                                         + *(unsigned __int16 *)(v20 + 2 * (v19 >> 4))));
              ++v19;
              v18 += 4;
            }
            while (v19 != 64);
            v21 = 4095;
LABEL_42:
            *(_WORD *)(a1 + 256) = v21;
          }
        }
        else if (v17 > 0xD6)
        {
          *(_BYTE *)(a1 + 254) = 1;
          if ((v9 & 1) != 0)
            v28 = 0;
          else
            v28 = *(unsigned int *)(a1 + 248);
          *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 232) + v28;
          v21 = (a3[2] << 8) | 0xFF;
          goto LABEL_42;
        }
      }
    }
    else
    {
      LOBYTE(v16) = 3;
      *(_BYTE *)(a1 + 253) = 3;
    }
    v29 = 0;
    v30 = (int32x4_t)xmmword_18BE14860;
    v31.i64[0] = -1;
    v31.i64[1] = -1;
    v32.i64[0] = 0x100000001;
    v32.i64[1] = 0x100000001;
    v33.i64[0] = 0x400000004;
    v33.i64[1] = 0x400000004;
    do
    {
      v31 = vandq_s8(vornq_s8((int8x16_t)vceqq_s32(*(int32x4_t *)(*(_QWORD *)(a1 + 56) + v29), (int32x4_t)(*(_OWORD *)&v30 | __PAIR128__(0x8000000080000000, 0x8000000080000000))), (int8x16_t)vshlq_u32(v32, vshrq_n_u32((uint32x4_t)v30, 2uLL))), v31);
      v30 = vaddq_s32(v30, v33);
      v29 += 16;
    }
    while (v29 != 512);
    v34 = vand_s8(*(int8x8_t *)v31.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
    *(_DWORD *)(a1 + 260) = v34.i32[0] & v34.i32[1];
    if (v9)
    {
      v80 = v11;
      if ((v16 & 1) != 0)
        v35 = 1088;
      else
        v35 = 64;
      v36 = *((_DWORD *)a3 + 4);
      v37 = *((_DWORD *)a3 + 5);
      v38 = *((unsigned int *)a3 + 9);
      v39 = 4 * (_DWORD)v38 + 2 * v35 + *(_DWORD *)(a1 + 248);
      v40 = (char *)uprv_malloc(v39);
      *(_QWORD *)(a1 + 264) = v40;
      if (v40)
      {
        v41 = v40;
        bzero(v40, v39);
        v42 = *(char **)(a1 + 88);
        memcpy(v41, v42, 2 * v35);
        v43 = &v41[2 * v35];
        memcpy(&v43[4 * (v38 - (((v37 - v36) >> 2) - (v35 >> 1)))], &v42[2 * v35], 4 * (((v37 - v36) >> 2) - (v35 >> 1)));
        *(_QWORD *)(a1 + 88) = v41;
        *(_QWORD *)(a1 + 232) = &v43[4 * v38];
        v44 = *(unsigned __int16 *)(a1 + 256);
        v11 = v80;
        if (v44 >= 0x3F)
        {
          v45 = 0;
          v46 = 0;
          v47 = (v44 + 1) >> 6;
          do
          {
            v48 = *(unsigned __int16 *)&v41[2 * v45];
            if (v35 >> 1 == (_DWORD)v48)
            {
              v46 += 16;
            }
            else
            {
              v49 = 0;
              v50 = *(_QWORD *)(a1 + 96) + 2 * v46;
              v51 = &v41[4 * v48];
              do
              {
                if (*(_WORD *)(v50 + 2 * v49))
                {
                  v52 = *(unsigned __int16 *)(v50 + 2 * v49) >> 4;
                  *(_DWORD *)v51 = v52;
                  *(int32x2_t *)(v51 + 4) = vadd_s32(vdup_n_s32(v52), (int32x2_t)0x200000001);
                  *((_DWORD *)v51 + 3) = v52 + 3;
                }
                ++v49;
                v51 += 16;
              }
              while ((_DWORD)v49 != 16);
              v46 += 16;
            }
            ++v45;
          }
          while (v46 < v47);
        }
        *(_QWORD *)&v53 = -1;
        *((_QWORD *)&v53 + 1) = -1;
        v88 = v53;
        v89 = v53;
        v86 = v53;
        v87 = v53;
        *(_OWORD *)&v84[32] = v53;
        v85 = v53;
        *(_OWORD *)v84 = v53;
        *(_OWORD *)&v84[16] = v53;
        sub_18BC29F88(*(_QWORD *)(a1 + 56), (uint64_t)v84, 0);
        v54 = *(unsigned __int8 *)(a1 + 48);
        if (*(_BYTE *)(a1 + 48))
        {
          v55 = 0;
          do
          {
            if ((char)v84[v55] >= 64)
            {
              sub_18BC2A170(a1 + 48, (uint64_t)v84, v55, 0, 0, a1 + 48);
              v54 = *v13;
            }
            ++v55;
          }
          while (v55 < v54);
        }
      }
      else
      {
        *a4 = U_MEMORY_ALLOCATION_ERROR;
        v11 = v80;
      }
    }
    goto LABEL_67;
  }
  if (v10 != 14)
    goto LABEL_32;
  memset(&v84[8], 0, 32);
  v23 = *(_QWORD *)(a1 + 288);
  if (!v23)
    goto LABEL_32;
  if (*(_DWORD *)(a2 + 4) != 1)
  {
    v27 = 14;
    goto LABEL_33;
  }
  v24 = (const char *)&a3[4 * v12];
  if (!strcmp(v24, (const char *)(*(_QWORD *)(a1 + 16) + 4)))
  {
LABEL_32:
    v27 = 13;
LABEL_33:
    *a4 = v27;
    return;
  }
  *(_QWORD *)v84 = 0x200000028;
  v84[8] = *(_BYTE *)(a2 + 8);
  *(_WORD *)&v84[10] = *(_WORD *)(a2 + 10);
  *(_DWORD *)&v84[12] = *(_DWORD *)(a2 + 12);
  *(_QWORD *)&v84[16] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)&v84[24] = v24;
  v25 = ucnv_load((uint64_t)v84, a4);
  if (*(int *)a4 > 0)
    return;
  v26 = v25;
  if (*(_BYTE *)(*((_QWORD *)v25 + 2) + 69) != 2 || *((_QWORD *)v25 + 35))
  {
    ucnv_unload(v25);
    goto LABEL_32;
  }
  if (*(_BYTE *)(a2 + 8))
  {
    ucnv_unload(v25);
    return;
  }
  v58 = *((_OWORD *)v25 + 3);
  *(_OWORD *)(a1 + 64) = *((_OWORD *)v25 + 4);
  v59 = *((_OWORD *)v25 + 5);
  v60 = *((_OWORD *)v25 + 6);
  v61 = *((_OWORD *)v25 + 8);
  *(_OWORD *)(a1 + 112) = *((_OWORD *)v25 + 7);
  *(_OWORD *)(a1 + 128) = v61;
  *(_OWORD *)(a1 + 80) = v59;
  *(_OWORD *)(a1 + 96) = v60;
  v62 = *((_OWORD *)v25 + 9);
  v63 = *((_OWORD *)v25 + 10);
  v64 = *((_OWORD *)v25 + 12);
  *(_OWORD *)(a1 + 176) = *((_OWORD *)v25 + 11);
  *(_OWORD *)(a1 + 192) = v64;
  *(_OWORD *)(a1 + 144) = v62;
  *(_OWORD *)(a1 + 160) = v63;
  v65 = *((_OWORD *)v25 + 13);
  v66 = *((_OWORD *)v25 + 14);
  v67 = *((_OWORD *)v25 + 15);
  *(_QWORD *)(a1 + 256) = *((_QWORD *)v25 + 32);
  *(_OWORD *)(a1 + 224) = v66;
  *(_OWORD *)(a1 + 240) = v67;
  *(_OWORD *)(a1 + 208) = v65;
  *(_OWORD *)v13 = v58;
  *(_QWORD *)(a1 + 280) = v25;
  *(_QWORD *)(a1 + 288) = v23;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  v68 = *(_QWORD *)(a1 + 16);
  v69 = *(unsigned __int8 *)(v68 + 69);
  if (v69 == 1 || v69 == 2 && *(char *)(v68 + 70) >= 2)
  {
    if (v25[252] == 12)
    {
      v70 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 56);
      if ((v70 & 0x80F00000) != 0x80800000)
        goto LABEL_67;
      v71 = HIBYTE(v70) & 0x7F;
      if (!v71)
        goto LABEL_67;
      v72 = v11;
      *(_BYTE *)(a1 + 49) = v71;
    }
    else
    {
      v73 = (_BYTE *)*((_QWORD *)v25 + 2);
      if (v73[69] != 2)
        goto LABEL_67;
      if (v73[70] != 1)
        goto LABEL_67;
      if (v73[71] != 2)
        goto LABEL_67;
      v74 = (char)*v13;
      if (v74 < 0)
        goto LABEL_67;
      v72 = v11;
      v75 = (char *)uprv_malloc((*v13 + 1) << 10);
      if (!v75)
      {
        ucnv_unload(v26);
        v27 = 7;
        goto LABEL_33;
      }
      v76 = v75;
      memcpy(v75, *(const void **)(a1 + 56), (unint64_t)v74 << 10);
      v77 = 0;
      v78 = v74 << 24;
      do
      {
        v79 = vcltz_s32(*(int32x2_t *)&v76[v77]);
        if ((v79.i8[0] & 1) != 0)
          *(_DWORD *)&v76[v77] = v78;
        if ((v79.i8[4] & 1) != 0)
          *(_DWORD *)&v76[v77 + 4] = v78;
        v77 += 8;
      }
      while (v77 != 1024);
      memset_pattern16(&v76[1024 * (unint64_t)v74], &unk_18BE14870, 0x400uLL);
      *(_QWORD *)(a1 + 56) = v76;
      *(_BYTE *)(a1 + 48) = v74 + 1;
      *(_BYTE *)(a1 + 50) = 1;
    }
    v11 = v72;
    *v72 = -37;
  }
LABEL_67:
  if (*(_BYTE *)(a1 + 254))
  {
    if (*v13 != 1)
    {
      v56 = *v11;
      if (v56 == 1)
      {
        *(_QWORD *)(a1 + 32) = &unk_1E2250FC0;
        return;
      }
      goto LABEL_71;
    }
    *(_QWORD *)(a1 + 32) = &unk_1E2250F30;
  }
  v56 = *v11;
LABEL_71:
  if (v56 == 219 || v56 == 12)
    *(_DWORD *)(a1 + 260) = 0;
}

void sub_18BC2941C(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(void **)(a1 + 64);
  if (v2)
    uprv_free(v2);
  if (*(_BYTE *)(a1 + 50))
    uprv_free(*(void **)(a1 + 56));
  v3 = *(_QWORD **)(a1 + 280);
  if (v3)
    ucnv_unload(v3);
  v4 = *(void **)(a1 + 264);
  if (v4)
    uprv_free(v4);
}

void sub_18BC29474(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  int v15;
  uint64_t v17;
  unsigned __int16 *v18;
  _WORD *v19;
  uint64_t v20;
  int v21;
  size_t v22;
  _DWORD *v23;
  uint64_t v24;
  _DWORD *v25;
  char *v26;
  uint64_t v27;
  unsigned __int16 *v28;
  uint64_t v29;
  __int16 v30;
  unsigned int v31;
  int v32;
  unsigned __int16 *v33;
  char *v34;
  size_t __n;

  if (*(_BYTE *)(a2 + 8))
    return;
  v6 = *(_QWORD *)(a1 + 48);
  v7 = *(unsigned __int8 *)(v6 + 252);
  v8 = *(_DWORD *)(a2 + 12);
  if (v7 == 219)
  {
    v8 &= ~0x10u;
    *(_DWORD *)(a2 + 12) = v8;
    *(_DWORD *)(a1 + 56) = v8;
  }
  if ((v8 & 0x10) != 0)
  {
    umtx_lock(0);
    v9 = *(_QWORD *)(v6 + 64);
    umtx_unlock(0);
    if (!v9)
    {
      v14 = *(_QWORD *)(a1 + 48);
      v15 = *(unsigned __int8 *)(v14 + 252);
      if (v15 != 12 && v15 != 0)
        goto LABEL_44;
      v17 = *(_QWORD *)(v14 + 56);
      if (*(_DWORD *)(v17 + 148) != -2147483638 || *(_DWORD *)(v17 + 84) != -2147483515)
        goto LABEL_44;
      v18 = *(unsigned __int16 **)(v14 + 88);
      v19 = *(_WORD **)(v14 + 232);
      v20 = *v18;
      if (*(_BYTE *)(v14 + 252))
      {
        if ((*(_DWORD *)&v18[2 * v20] & 0x4000000) == 0
          || v19[16 * (unsigned __int16)*(_DWORD *)&v18[2 * v20] + 10] != 37
          || (v21 = *(_DWORD *)&v18[2 * v20 + 16], (v21 & 0x200000) == 0)
          || v19[16 * (unsigned __int16)v21 + 5] != 21)
        {
LABEL_44:
          if (*a3 > 0)
            return;
          v31 = *(_DWORD *)(a2 + 12) & 0xFFFFFFEF;
          *(_DWORD *)(a2 + 12) = v31;
          *(_DWORD *)(a1 + 56) = v31;
          goto LABEL_7;
        }
      }
      else if (v19[v18[v20] + 10] != 3877 || v19[v18[v20 + 8] + 5] != 3861)
      {
        goto LABEL_44;
      }
      v22 = *(unsigned int *)(v14 + 248);
      if ((_DWORD)v22)
      {
        v23 = uprv_malloc(v22 + (*(unsigned __int8 *)(v14 + 48) << 10) + 80);
        if (v23)
        {
          v24 = *(unsigned __int8 *)(v14 + 48);
          __n = v22;
          v25 = v23;
          memcpy(v23, *(const void **)(v14 + 56), v24 << 10);
          v25[37] = -2147483515;
          v25[21] = -2147483638;
          v26 = (char *)&v25[256 * v24];
          memcpy(v26, v19, __n);
          v27 = *v18;
          if (*(_BYTE *)(v14 + 252))
          {
            v28 = &v18[2 * v27];
            *(_WORD *)&v26[32 * (unsigned __int16)*(_DWORD *)v28 + 20] = 21;
            v29 = (16 * (unsigned __int16)*((_DWORD *)v28 + 8)) | 5;
            v30 = 37;
          }
          else
          {
            v33 = &v18[v27];
            *(_WORD *)&v26[2 * *v33 + 20] = 3861;
            v29 = v33[8] + 5;
            v30 = 3877;
          }
          *(_WORD *)&v26[2 * v29] = v30;
          v34 = strcpy(&v26[__n], (const char *)(*(_QWORD *)(v14 + 16) + 4));
          strcpy(&v26[__n + strlen(v34)], ",swaplfnl");
          umtx_lock(0);
          if (*(_QWORD *)(v14 + 64))
          {
            umtx_unlock(0);
            uprv_free(v25);
          }
          else
          {
            *(_QWORD *)(v14 + 64) = v25;
            *(_QWORD *)(v14 + 240) = v26;
            *(_QWORD *)(v14 + 272) = &v26[__n];
            umtx_unlock(0);
          }
          goto LABEL_7;
        }
        v32 = 7;
      }
      else
      {
        v32 = 3;
      }
      *a3 = v32;
      return;
    }
  }
LABEL_7:
  v10 = *(char **)(a2 + 24);
  if (strstr(v10, "18030"))
  {
    if (!strstr(v10, "gb18030") && !strstr(v10, "GB18030"))
      goto LABEL_15;
    v11 = 0x8000;
  }
  else if (strstr(v10, "KEIS") || strstr(v10, "keis"))
  {
    v11 = 4096;
  }
  else if (strstr(v10, "JEF") || strstr(v10, "jef"))
  {
    v11 = 0x2000;
  }
  else
  {
    if (!strstr(v10, "JIPS") && !strstr(v10, "jips"))
      goto LABEL_15;
    v11 = 0x4000;
  }
  *(_DWORD *)(a1 + 56) |= v11;
LABEL_15:
  if (v7 == 12)
    *(_BYTE *)(a1 + 88) = 3;
  v12 = *(_QWORD *)(v6 + 288);
  if (v12)
  {
    v13 = *(_BYTE *)(v12 + 68);
    if (v7 == 12)
      ++v13;
    if (v13 > *(char *)(a1 + 88))
      *(_BYTE *)(a1 + 88) = v13;
  }
}

uint64_t sub_18BC29834(_QWORD *a1, int *a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  int v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  unint64_t v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  _BOOL4 v33;
  _BYTE *v34;
  char v35;
  char *v36;
  _BYTE *v37;
  char v38;
  unint64_t v39;
  char v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v2 = a1[1];
  if (*(char *)(v2 + 282) > 0)
    return 4294967287;
  v3 = *(_QWORD *)(v2 + 48);
  if ((*(_BYTE *)(v3 + 253) & 2) != 0)
    return 4294967287;
  v6 = (char *)a1[2];
  v7 = a1[3];
  if (*(_BYTE *)(v3 + 48) == 1)
  {
    v8 = 64;
    if ((*(_BYTE *)(v2 + 56) & 0x10) == 0)
      v8 = 56;
    v9 = *(_QWORD *)(v3 + v8);
    while (1)
    {
      if ((unint64_t)v6 >= v7)
        goto LABEL_36;
      v10 = *v6++;
      v11 = *(_DWORD *)(v9 + 4 * v10);
      a1[2] = v6;
      if (v11 < -2146435072)
        return (unsigned __int16)v11;
      if ((v11 & 0xD00000) == 0x100000)
        return (v11 & 0xFFFFFu) + 0x10000;
      v12 = (v11 >> 20) & 0xF;
      if (v12 == 7)
        goto LABEL_36;
      if (v12 == 6)
        break;
      if (v12 == 2)
        return (unsigned __int16)v11;
    }
    if (*a2 > 0)
    {
LABEL_36:
      *a2 = 8;
      return 0xFFFFLL;
    }
    a1[2] = v6 - 1;
    return 4294967287;
  }
  v14 = 64;
  if ((*(_BYTE *)(v2 + 56) & 0x10) == 0)
    v14 = 56;
  v15 = *(_QWORD *)(v3 + v14);
  v16 = *(_QWORD *)(v3 + 72);
  v17 = *(_DWORD *)(v2 + 72);
  v18 = *(unsigned __int8 *)(v2 + 76);
  if (!*(_BYTE *)(v2 + 76))
    v18 = *(unsigned __int8 *)(v3 + 49);
  result = 0xFFFFFFFFLL;
  while (2)
  {
    v19 = v6;
    if ((unint64_t)v6 >= v7)
    {
      v21 = 0;
      goto LABEL_51;
    }
    v20 = 0;
    v21 = v7 - (_QWORD)v6;
    v22 = v18;
    while (1)
    {
      v23 = &v19[v20 + 1];
      v24 = *(unsigned int *)(v15 + ((unint64_t)v22 << 10) + 4 * v19[v20]);
      if ((v24 & 0x80000000) != 0)
        break;
      v22 = v24 >> 24;
      v17 += v24 & 0xFFFFFF;
      if ((unint64_t)v23 < v7)
      {
        v25 = *(_DWORD *)(v15 + (v22 << 10) + 4 * *v23);
        if ((v25 & 0x80F00000) == 0x80400000)
        {
          result = *(unsigned __int16 *)(v16 + 2 * (v17 + (unsigned __int16)v25));
          if (result <= 0xFFFD)
          {
            v27 = (uint64_t)&v19[v20 + 2];
            LODWORD(v18) = HIBYTE(v25) & 0x7F;
            goto LABEL_75;
          }
        }
      }
      if (v21 == ++v20)
        goto LABEL_50;
    }
    *(_DWORD *)(v2 + 76) = v22;
    v18 = BYTE3(v24) & 0x7F;
    v26 = (v24 >> 20) & 0xF;
    switch(v26)
    {
      case 5u:
        v28 = v17 + (unsigned __int16)v24;
        result = *(unsigned __int16 *)(v16 + 2 * v28);
        v27 = (uint64_t)&v19[v20 + 1];
        if (result >> 11 < 0x1B)
          goto LABEL_75;
        v29 = v28 + 1;
        if (result >> 13 <= 6)
        {
          result = ((result & 0x3FF) << 10) + *(unsigned __int16 *)(v16 + 2 * v29) + 9216;
          goto LABEL_75;
        }
        if ((result & 0xFFFE) == 0xE000)
        {
          result = *(unsigned __int16 *)(v16 + 2 * v29);
          goto LABEL_75;
        }
        if ((_DWORD)result != 0xFFFF)
        {
LABEL_83:
          if (*a2 > 0)
          {
            v21 = v20 + 1;
            goto LABEL_51;
          }
          *(_DWORD *)(v2 + 72) = 0;
          *(_DWORD *)(v2 + 76) = BYTE3(v24) & 0x7F;
          a1[2] = v19;
          return 4294967287;
        }
LABEL_82:
        *a2 = 12;
        v27 = (uint64_t)&v19[v20 + 1];
LABEL_66:
        result = 0xFFFFLL;
        goto LABEL_75;
      case 4u:
        v30 = v17 + (unsigned __int16)v24;
        result = *(unsigned __int16 *)(v16 + 2 * v30);
        v21 = v20 + 1;
        if (result < 0xFFFE)
        {
          v27 = (uint64_t)&v19[v21];
          goto LABEL_75;
        }
        if ((_DWORD)result == 65534)
        {
          v42 = sub_18BC272C0(v3 + 48, v30);
          v18 = BYTE3(v24) & 0x7F;
          v43 = v42;
          result = 65534;
          if ((_DWORD)v43 != 65534)
          {
            result = v43;
            goto LABEL_51;
          }
          goto LABEL_83;
        }
        goto LABEL_82;
      case 0u:
LABEL_32:
        result = (unsigned __int16)v24;
LABEL_46:
        v27 = (uint64_t)&v19[v20 + 1];
        goto LABEL_75;
    }
    if ((v24 & 0xD00000) == 0x100000)
    {
      result = (v24 & 0xFFFFF) + 0x10000;
      goto LABEL_46;
    }
    v17 = 0;
    v6 = &v19[v20 + 1];
    switch(v26)
    {
      case 2u:
        goto LABEL_32;
      case 6u:
        goto LABEL_83;
      case 7u:
        v22 = BYTE3(v24) & 0x7F;
        break;
      case 8u:
        if (!*(_BYTE *)(v3 + 49))
          goto LABEL_83;
        break;
      default:
        continue;
    }
    break;
  }
  *a2 = 12;
  v21 = v20 + 1;
LABEL_50:
  v18 = v22;
LABEL_51:
  v27 = (uint64_t)&v19[v21];
  if ((result & 0x80000000) != 0)
  {
    if (*a2 <= 0 && v27 == v7 && v21 >= 1)
    {
      v34 = (_BYTE *)(v2 + 65);
      *(_BYTE *)(v2 + 64) = v21;
      do
      {
        v35 = *v19++;
        *v34++ = v35;
      }
      while ((unint64_t)v19 < v7);
      *a2 = 11;
      result = 0xFFFFLL;
      v27 = v7;
      goto LABEL_75;
    }
    if (*a2 < 1)
    {
      *a2 = 8;
    }
    else
    {
      v33 = *(_BYTE *)(v3 + 49) != 0;
      *(_BYTE *)(v2 + 65) = *v19;
      if (v21 != 1)
      {
        v36 = v19 + 1;
        if (v21 < 2)
        {
          v38 = 1;
        }
        else
        {
          v37 = (_BYTE *)(v2 + 66);
          v38 = 1;
          while (1)
          {
            v39 = v27;
            v40 = *v36;
            v41 = v18;
            if (sub_18BC2732C(v15, v18, v33, *v36))
              break;
            ++v36;
            *v37++ = v40;
            ++v38;
            v27 = v39;
            v18 = v41;
            if ((unint64_t)v36 >= v39)
              goto LABEL_74;
          }
          LOBYTE(v18) = v41;
        }
LABEL_74:
        *(_BYTE *)(v2 + 64) = v38;
        result = 0xFFFFLL;
        v27 = (uint64_t)v36;
        goto LABEL_75;
      }
      *(_BYTE *)(v2 + 64) = 1;
    }
    goto LABEL_66;
  }
LABEL_75:
  *(_DWORD *)(v2 + 72) = 0;
  *(_DWORD *)(v2 + 76) = v18;
  a1[2] = v27;
  return result;
}

uint64_t sub_18BC29CB4(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  v2 = 0;
  v3 = *(_QWORD *)(*(_QWORD *)(result + 48) + 56)
     + ((unint64_t)*(unsigned __int8 *)(*(_QWORD *)(result + 48) + 49) << 10);
  do
  {
    *(_BYTE *)(a2 + v2) = *(_DWORD *)(v3 + 4 * v2) >= 0;
    ++v2;
  }
  while (v2 != 256);
  return result;
}

uint64_t sub_18BC29CE8(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 48);
  if ((*(_BYTE *)(a1 + 56) & 0x10) == 0)
    return *(_QWORD *)(v1 + 16) + 4;
  result = *(_QWORD *)(v1 + 272);
  if (!result)
    return *(_QWORD *)(v1 + 16) + 4;
  return result;
}

_QWORD *sub_18BC29D0C(_QWORD *result, int a2, int *a3)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  int v8;
  char *v9;
  int v10;
  char *v11;
  int v12;
  uint64_t vars0;

  v5 = result[1];
  v6 = (char *)(v5 + 94);
  v7 = *(_QWORD *)(v5 + 48);
  if (*(_BYTE *)(v5 + 94))
  {
    if (*(_QWORD *)(v7 + 288))
    {
      if (*(_BYTE *)(v5 + 95))
      {
LABEL_4:
        v8 = 1;
        goto LABEL_7;
      }
    }
    else if (*(unsigned __int16 *)(v5 + 140) < 0x100u)
    {
      goto LABEL_4;
    }
  }
  v6 = *(char **)(v5 + 40);
  v8 = *(char *)(v5 + 89);
LABEL_7:
  v12 = 0;
  *(_BYTE *)(v5 + 95) = 0;
  if (*(_BYTE *)(v7 + 252) == 12)
  {
    if (v8 == 2)
    {
      v11 = (char *)&v12;
      if (*(_DWORD *)(v5 + 80) <= 1u)
      {
        *(_DWORD *)(v5 + 80) = 2;
        v11 = (char *)&v12 + 1;
        LOBYTE(v12) = 14;
      }
      *v11 = *v6;
      v10 = (_DWORD)v11 + 2;
      v11[1] = v6[1];
    }
    else
    {
      if (v8 != 1)
      {
        *a3 = 1;
        return result;
      }
      v9 = (char *)&v12;
      if (*(_DWORD *)(v5 + 80) == 2)
      {
        *(_DWORD *)(v5 + 80) = 1;
        v9 = (char *)&v12 + 1;
        LOBYTE(v12) = 15;
      }
      *v9 = *v6;
      v10 = (_DWORD)v9 + 1;
    }
    v6 = (char *)&v12;
    v8 = v10 - (&vars0 - 4);
  }
  return ucnv_cbFromUWriteBytes(result, v6, v8, a2, a3);
}

uint64_t sub_18BC29E14(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  if ((*(_BYTE *)(a1 + 57) & 0x80) == 0)
    return sub_18BC25E90(*(_QWORD *)(a1 + 48), a2, a3, *(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 252) == 219, a4);
  ((void (*)(uint64_t, _QWORD, uint64_t))a2[2])(*a2, 0, 55295);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))a2[2])(*a2, 57344, 1114111);
}

uint64_t sub_18BC29E80(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  _BYTE *v17;

  v3 = 0;
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_QWORD *)(a1 + 184);
  v6 = a2 & 0xFF7FFF;
  if (HIBYTE(a2) <= 0x8Eu)
    v6 = a2 & 0x7FFFFF;
  if (HIBYTE(a2))
    v7 = v6;
  else
    v7 = a2;
  v8 = a2 & 0xFF7F;
  if (HIWORD(a2) <= 0x8Eu)
    v8 = a2 & 0x7FFF;
  v9 = *(unsigned __int8 *)(a1 + 204);
  if (a2 < 0x10000)
    v8 = a2;
  if (v9 != 8)
    v8 = a2;
  if (v9 != 9)
    v7 = v8;
  do
  {
    v10 = *(unsigned int *)(a3 + 4 * v3);
    if ((v10 & 0x80000000) != 0)
      goto LABEL_22;
    v11 = v4 + 4 * *(unsigned __int16 *)(v4 + ((v10 >> 9) & 0x7FFFFE));
    v12 = (v10 >> 4) & 0x3F;
    v13 = v7 + v3;
    v14 = *(_DWORD *)(a3 + 4 * v3) & 0xF;
    v15 = v14 | (16 * (unsigned __int16)*(_DWORD *)(v11 + 4 * v12));
    v16 = *(unsigned __int8 *)(a1 + 204);
    if (v16 != 9)
    {
      if (v16 == 3)
      {
        *(_DWORD *)(v5 + 4 * v15) = v13;
        goto LABEL_21;
      }
      if (v16 != 2)
      {
        *(_WORD *)(v5 + 2 * v15) = v13;
        goto LABEL_21;
      }
    }
    v17 = (_BYTE *)(v5 + 3 * v15);
    *v17 = BYTE2(v13);
    v17[1] = BYTE1(v13);
    v17[2] = v13;
LABEL_21:
    *(_DWORD *)(v11 + 4 * v12) |= 1 << (v14 | 0x10);
LABEL_22:
    ++v3;
  }
  while (v3 != 32);
  return 1;
}

uint64_t sub_18BC29F88(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v4 = result;
  v5 = 0;
  v6 = 0;
  v21 = a3;
  v7 = result + ((unint64_t)a3 << 10);
  v8 = (unint64_t)a3 << 10;
  *(_BYTE *)(a2 + a3) = 0;
  while (1)
  {
    v9 = *(unsigned int *)(v4 + v8);
    v10 = (v9 >> 24) & 0x7F;
    if (*(unsigned __int8 *)(a2 + v10) == 255)
      break;
    if ((v9 & 0x80000000) != 0)
      goto LABEL_7;
LABEL_4:
    if ((*(char *)(a2 + v10) & 0x80000000) == 0)
      goto LABEL_10;
LABEL_8:
    if (v5 == -255)
    {
      *(_BYTE *)(a2 + v21) = -64;
      return result;
    }
    ++v6;
    v8 += 4;
    --v5;
  }
  result = sub_18BC29F88(v4, a2, (v9 >> 24) & 0x7F);
  if ((v9 & 0x80000000) == 0)
    goto LABEL_4;
LABEL_7:
  if ((v9 & 0xE00000) >= 0x600000)
    goto LABEL_8;
LABEL_10:
  v11 = -v5;
  v12 = v21;
  v13 = *(_BYTE *)(a2 + v21) | ((unint64_t)-v5 >> 2) & 0xF8;
  *(_BYTE *)(a2 + v21) = v13;
  if (-(int)v5 > 0xFE)
  {
    LODWORD(v14) = 255;
    goto LABEL_24;
  }
  v14 = 255;
  while (2)
  {
    v15 = *(unsigned int *)(v7 + 4 * v14);
    v16 = (v15 >> 24) & 0x7F;
    if (*(unsigned __int8 *)(a2 + v16) == 255)
    {
      result = sub_18BC29F88(v4, a2, (v15 >> 24) & 0x7F);
      if ((v15 & 0x80000000) == 0)
        goto LABEL_14;
    }
    else if ((v15 & 0x80000000) == 0)
    {
LABEL_14:
      if ((*(char *)(a2 + v16) & 0x80000000) == 0)
        break;
      goto LABEL_18;
    }
    if ((v15 & 0xE00000) >= 0x600000)
    {
LABEL_18:
      if (-v5 >= (unint64_t)--v14)
      {
        v11 = -v5;
        v12 = v21;
        v14 = -v5;
        goto LABEL_23;
      }
      continue;
    }
    break;
  }
  v11 = -v5;
  v12 = v21;
LABEL_23:
  v13 = *(_BYTE *)(a2 + v12);
LABEL_24:
  *(_BYTE *)(a2 + v12) = v13 | (v14 >> 5);
  if ((int)v14 >= (int)v11)
  {
    if ((int)v14 <= v6)
      v17 = v6;
    else
      v17 = v14;
    for (i = v17 + v5 + 1; i; --i)
    {
      v19 = *(unsigned int *)(v4 + v8);
      v20 = (v19 >> 24) & 0x7F;
      if (*(unsigned __int8 *)(a2 + v20) == 255)
      {
        result = sub_18BC29F88(v4, a2, (v19 >> 24) & 0x7F);
        if ((v19 & 0x80000000) != 0)
        {
LABEL_33:
          *(_BYTE *)(a2 + v20) |= 0x40u;
          if ((v19 & 0xC00000) == 0)
            *(_BYTE *)(a2 + v12) |= 0x40u;
        }
      }
      else if ((v19 & 0x80000000) != 0)
      {
        goto LABEL_33;
      }
      v8 += 4;
    }
  }
  return result;
}

uint64_t sub_18BC2A170(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t result;
  unsigned int v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _OWORD v26[8];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  memset(v26, 0, sizeof(v26));
  v9 = *(_QWORD *)(a1 + 8);
  v24 = *(_QWORD *)(a1 + 24);
  v10 = *(char *)(a2 + a3);
  v11 = (4 * v10) & 0xE0;
  if (v11)
  {
LABEL_4:
    v12 = 32 * (v10 & 7) + 32;
    if (v11 >= v12)
      return 1;
    goto LABEL_7;
  }
  if (v10 > 63)
  {
    LODWORD(v26[0]) = -1;
    v11 = 1;
    goto LABEL_4;
  }
  v11 = 0;
  v12 = 32 * (v10 & 7) + 32;
LABEL_7:
  v13 = v9 + ((uint64_t)a3 << 10);
  v14 = a5 << 8;
  v15 = v11;
  v16 = -1;
  v17 = v12;
  do
  {
    v18 = *(unsigned int *)(v13 + 4 * v15);
    if ((v18 & 0x80000000) != 0)
    {
      v20 = -1;
      switch((v18 >> 20) & 0xF)
      {
        case 0u:
          v20 = (unsigned __int16)*(_DWORD *)(v13 + 4 * v15);
          break;
        case 1u:
          v20 = (v18 & 0xFFFFF) + 0x10000;
          break;
        case 4u:
          v20 = *(unsigned __int16 *)(v24 + 2 * (a4 + (unsigned __int16)v18));
          if (v20 >= 0xFFFE)
            v20 = -1;
          break;
        case 5u:
          v21 = a4 + (unsigned __int16)v18;
          v20 = *(unsigned __int16 *)(v24 + 2 * v21);
          if (v20 >> 11 >= 0x1B)
          {
            v22 = v21 + 1;
            if (v20 >> 10 > 0x36)
            {
              if (v20 == 57344)
                v20 = *(unsigned __int16 *)(v24 + 2 * (int)v22);
              else
                v20 = -1;
            }
            else
            {
              v20 = ((v20 & 0x3FF) << 10) + 9216 + *(unsigned __int16 *)(v24 + 2 * v22);
            }
          }
          break;
        default:
          break;
      }
      *((_DWORD *)v26 + (v15 & 0x1F)) = v20;
      v16 &= v20;
    }
    else
    {
      if ((*(char *)(a2 + (v18 >> 24)) & 0x80000000) == 0)
      {
        result = sub_18BC2A170(a1, a2);
        if (!(_DWORD)result)
          return result;
      }
      *((_DWORD *)v26 + (v15 & 0x1F)) = -1;
    }
    v23 = v15 + 1;
    if (((v15 + 1) & 0x1F) == 0 && (v16 & 0x80000000) == 0)
    {
      result = sub_18BC29E80(a6, (v15 - 31) | v14, (uint64_t)v26);
      if (!(_DWORD)result)
        return result;
      v16 = -1;
    }
    ++v15;
  }
  while (v23 < v17);
  return 1;
}

uint64_t sub_18BC2A3C4(uint64_t result, _QWORD *a2, int *a3)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  char v20;
  unsigned __int16 *v21;
  uint64_t v22;
  int v23;
  char v24;
  unsigned __int8 *v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  _BYTE *v32;
  unint64_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unint64_t v39;
  char v40;
  int v41;
  char v42;
  BOOL v43;
  char v44;
  int v45;
  unint64_t v46;
  int v47;
  unsigned int v48;
  unint64_t v49;
  unint64_t v50;
  unsigned __int8 *v51;
  uint64_t v52;
  uint64_t v53;
  unsigned __int16 *v54;
  uint64_t v55;
  _QWORD *v56;
  int *v57;
  _BYTE *v58;
  uint64_t v59;
  _BYTE *v60;
  int v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  _BYTE *v66;

  v4 = *(_QWORD *)(result + 8);
  v6 = a2[1];
  v5 = a2[2];
  v7 = a2[3];
  v8 = *(_BYTE **)(result + 32);
  v66 = v8;
  v64 = result;
  v9 = *(_QWORD *)(v4 + 48);
  if ((*(_BYTE *)(v4 + 56) & 0x10) != 0)
    v10 = 240;
  else
    v10 = 232;
  if (*(_BYTE *)(v4 + 63))
    v11 = 2048;
  else
    v11 = 3072;
  v12 = *(char *)(v6 + 64);
  if (v12 < 1)
  {
    LOBYTE(v12) = 0;
    LOBYTE(v14) = 0;
    LODWORD(v13) = 0;
  }
  else
  {
    LODWORD(v13) = *(_DWORD *)(v6 + 72);
    v14 = *(_DWORD *)(v6 + 76);
  }
  v15 = *(_DWORD *)(result + 40) - (_DWORD)v8;
  v16 = *(_QWORD *)(v9 + 88);
  v17 = *(_QWORD *)(v9 + v10);
  v18 = v7 - v5 - (char)v14 + v12;
  if (v18 >= 1 && *(char *)(v7 - 1) < 0)
  {
    v19 = *(unsigned __int8 *)(v7 - 1);
    if (v18 < 2 || v19 > 0xBF)
    {
      if ((v19 + 62) < 0x2Eu)
        --v7;
    }
    else
    {
      v20 = *(_BYTE *)(v7 - 2);
      if ((v20 & 0xF0) == 0xE0 && ((a00000000000000[v20 & 0xF] >> (*(_BYTE *)(v7 - 1) >> 5)) & 1) != 0)
        v7 -= 2;
    }
  }
  v21 = (unsigned __int16 *)(v9 + 104);
  v22 = *(unsigned int *)(v9 + 260);
  v23 = *(unsigned __int8 *)(v9 + 253);
  if ((_DWORD)v13 && v15 > 0)
  {
    *(_DWORD *)(v6 + 72) = 0;
    *(_BYTE *)(v6 + 64) = 0;
    v24 = v12;
    goto LABEL_66;
  }
  v25 = (unsigned __int8 *)v5;
  while (1)
  {
    if ((unint64_t)v25 >= v7)
    {
      v5 = (unint64_t)v25;
      goto LABEL_39;
    }
    while (1)
    {
      v26 = v15 - 1;
      if (v15 < 1)
      {
        *a3 = 15;
        goto LABEL_59;
      }
      v5 = (unint64_t)(v25 + 1);
      LOBYTE(v27) = *v25;
      v13 = *v25;
      if ((*v25 & 0x80) == 0)
      {
        if (((v22 >> (*v25 >> 2)) & 1) == 0)
        {
          v27 = *(unsigned __int16 *)(v17 + 2 * (*v21 + v13));
LABEL_63:
          v25 = (unsigned __int8 *)v5;
          goto LABEL_89;
        }
        goto LABEL_38;
      }
      v28 = *v25;
      if (v13 <= 0xDF)
      {
        if (v28 < 0xC2)
        {
          LOBYTE(v12) = 0;
          LOBYTE(v14) = 0;
LABEL_65:
          v24 = 1;
          goto LABEL_66;
        }
        v29 = *(unsigned __int8 *)v5 ^ 0x80;
        if (v29 > 0x3F)
          goto LABEL_60;
        LODWORD(v30) = v13 & 0x1F;
        v5 = (unint64_t)(v25 + 2);
        v31 = v21[v13 & 0x1F];
        goto LABEL_37;
      }
      if (v28 != 224)
        break;
      v30 = *(unsigned __int8 *)v5 ^ 0x80;
      if ((v30 & 0xE0) != 0x20 || (v29 = v25[2] ^ 0x80, v29 > 0x3F))
      {
LABEL_60:
        v43 = *v25 > 0xDFu;
        v44 = 2;
        goto LABEL_61;
      }
      v5 = (unint64_t)(v25 + 3);
      v31 = v21[v30];
LABEL_37:
      v27 = *(unsigned __int16 *)(v17 + 2 * (v31 + v29));
      if (v27 < v11)
      {
        v13 = v29 | ((_DWORD)v30 << 6);
        goto LABEL_63;
      }
LABEL_38:
      v32 = v66++;
      *v32 = v27;
      v15 = v26;
      v25 = (unsigned __int8 *)v5;
      if (v5 >= v7)
        goto LABEL_39;
    }
    v24 = 1;
    if ((v27 + 62) < 0x33u)
    {
      if (*v25 <= 0xEFu)
        v44 = 2;
      else
        v44 = 3;
      v43 = 1;
LABEL_61:
      LOBYTE(v12) = 0;
      LOBYTE(v14) = v44 + v43;
      goto LABEL_65;
    }
    LOBYTE(v12) = 0;
    LOBYTE(v14) = 0;
LABEL_66:
    if (v24 < (char)v14)
      break;
LABEL_83:
    if (v24 != v14)
    {
      v59 = (char)v12 - (uint64_t)v24;
      if ((char)v12 < v24)
      {
        v60 = (_BYTE *)((char)v12 + v6 + 65);
        do
          *v60++ = *(_BYTE *)(v5 + v59);
        while (!__CFADD__(v59++, 1));
      }
      *(_BYTE *)(v6 + 64) = v24;
      a2[2] = v5 + v59;
      *(_QWORD *)(v64 + 32) = v66;
      *a3 = 12;
      return result;
    }
    v25 = (unsigned __int8 *)v5;
LABEL_85:
    v13 = (v13 - dword_18BE14748[(char)v14]);
    if ((char)v14 < 4 || (v23 & 1) != 0)
      v27 = *(unsigned __int16 *)(v17
                                + 2
                                * ((v13 & 0xF)
                                 + *(unsigned __int16 *)(v16
                                                       + 2
                                                       * (((v13 >> 4) & 0x3F)
                                                        + *(unsigned __int16 *)(v16 + 2 * ((int)v13 >> 10))))));
    else
      v27 = 0;
LABEL_89:
    if (v11 <= v27)
    {
      v58 = v66++;
      *v58 = v27;
      --v15;
    }
    else
    {
      v62 = v23;
      v52 = v22;
      v53 = v11;
      v54 = v21;
      v55 = v17;
      v63 = v6;
      v56 = a2;
      v65 = &unk_18BE1475C;
      v57 = a3;
      result = sub_18BC289CC(v4, *(_QWORD *)(v4 + 48), v13, (uint64_t *)&v65, (uint64_t)&unk_18BE1475C, &v66, (unint64_t)&v66[v15], 0, -1, *(_BYTE *)(v64 + 2), a3);
      a3 = v57;
      if (*v57 >= 1)
      {
        *(_DWORD *)(v4 + 84) = result;
        v5 = (unint64_t)v25;
        a2 = v56;
LABEL_111:
        v6 = v63;
LABEL_39:
        if (*a3 <= 0 && (*(_DWORD *)(v4 + 208) & 0x80000000) != 0 && (v33 = a2[3], v5 < v33))
        {
          v34 = *(char *)v5;
          *(_BYTE *)(v6 + 65) = *(_BYTE *)v5;
          v35 = v34;
          if (v34 <= 0xEFu)
            v36 = 2;
          else
            v36 = 3;
          if (v34 > 0xDFu)
            ++v36;
          if ((v34 + 62) <= 0x32u)
            v37 = v36;
          else
            v37 = 0;
          if (v34 < 0)
            v38 = v37;
          else
            v38 = 1;
          v25 = (unsigned __int8 *)(v5 + 1);
          if (v5 + 1 >= v33)
          {
            v40 = 1;
          }
          else
          {
            v39 = ~v5 + v33;
            v40 = 1;
            do
            {
              v41 = *v25++;
              v42 = v40++;
              *(_BYTE *)(v6 + v42 + 65) = v41;
              v35 = v41 + (v35 << 6);
              --v39;
            }
            while (v39);
            v25 = (unsigned __int8 *)v33;
          }
          *(_BYTE *)(v6 + 64) = v40;
          *(_DWORD *)(v6 + 72) = v35;
          *(_DWORD *)(v6 + 76) = v38;
        }
        else
        {
          v25 = (unsigned __int8 *)v5;
        }
LABEL_59:
        a2[2] = v25;
        goto LABEL_96;
      }
      a2 = v56;
      if ((*(_DWORD *)(v4 + 208) & 0x80000000) == 0)
      {
        *v57 = -127;
        v5 = (unint64_t)v25;
        goto LABEL_111;
      }
      v6 = v63;
      v15 = *(_DWORD *)(v64 + 40) - (_DWORD)v66;
      v17 = v55;
      v21 = v54;
      v11 = v53;
      v22 = v52;
      v23 = v62;
    }
  }
  result = 1;
  LOBYTE(v45) = v24;
  v25 = (unsigned __int8 *)v5;
  while ((unint64_t)v25 < a2[3])
  {
    v46 = *v25;
    if ((char)v14 < 3 || v45 >= 2u)
    {
      if ((char)v46 >= -64)
        goto LABEL_82;
    }
    else
    {
      if (v14 == 3)
      {
        v47 = a00000000000000[v13 & 0xF];
        v48 = v46 >> 5;
      }
      else
      {
        v47 = byte_18BE1475E[v46 >> 4];
        LOBYTE(v48) = v13 & 7;
      }
      if ((v47 & (1 << v48)) == 0)
      {
LABEL_82:
        v24 = v45;
        v5 = (unint64_t)v25;
        goto LABEL_83;
      }
    }
    v45 = (char)(v45 + 1);
    ++v25;
    LODWORD(v13) = v46 + ((_DWORD)v13 << 6);
    if (v45 >= (char)v14)
      goto LABEL_85;
  }
  v49 = (char)v12;
  if ((char)v12 >= (char)v45)
  {
    v51 = &v25[(char)v12 - (uint64_t)(char)v45];
  }
  else
  {
    do
    {
      v50 = v49 + 1;
      *(_BYTE *)(v6 + 65 + v49) = *(_BYTE *)(v5 - v24 + v49);
      v49 = v50;
    }
    while (v50 < (char)v45);
    v51 = (unsigned __int8 *)(v5 - v24 + v50);
  }
  *(_BYTE *)(v6 + 64) = v45;
  *(_DWORD *)(v6 + 72) = v13;
  *(_DWORD *)(v6 + 76) = (char)v14;
  a2[2] = v51;
LABEL_96:
  *(_QWORD *)(v64 + 32) = v66;
  return result;
}

uint64_t sub_18BC2A9E8(uint64_t result, _QWORD *a2, int *a3)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  char v20;
  unsigned int v21;
  char v22;
  char v23;
  unint64_t v24;
  int v25;
  int v26;
  _BYTE *v27;
  _BYTE *v28;
  char v29;
  _BYTE *v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  unint64_t v36;
  int v37;
  unsigned int v38;
  unint64_t v39;
  unint64_t v40;
  _BYTE *v41;
  unsigned int v42;
  _BYTE *v43;
  int v44;
  _BYTE *v45;
  _BYTE *v46;
  unint64_t v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  unsigned __int8 *v53;
  unint64_t v54;
  char v55;
  int v56;
  char v57;
  uint64_t v58;
  _BYTE *v59;
  unsigned __int16 *v61;
  uint64_t v62;
  void *v63;
  _BYTE *v64;

  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  v8 = a2[1];
  v7 = (_BYTE *)a2[2];
  v9 = (_BYTE *)a2[3];
  v10 = *(_BYTE **)(result + 32);
  v64 = v10;
  v11 = *(_QWORD *)(v6 + 48);
  if ((*(_BYTE *)(v6 + 56) & 0x10) != 0)
    v12 = 240;
  else
    v12 = 232;
  v13 = *(char *)(v8 + 64);
  if (v13 < 1)
  {
    LOBYTE(v13) = 0;
    LOBYTE(v15) = 0;
    LODWORD(v14) = 0;
  }
  else
  {
    LODWORD(v14) = *(_DWORD *)(v8 + 72);
    v15 = *(_DWORD *)(v8 + 76);
  }
  v16 = *(_DWORD *)(result + 40) - (_DWORD)v10;
  v61 = *(unsigned __int16 **)(v11 + 96);
  v62 = *(_QWORD *)(v11 + 88);
  v17 = *(_QWORD *)(v11 + v12);
  v18 = (_DWORD)v9 - (_DWORD)v7 - (char)v15 + v13;
  if (v18 >= 1 && (char)*(v9 - 1) < 0)
  {
    v19 = *(v9 - 1);
    if (v18 < 2 || v19 > 0xBF)
    {
      if ((v19 + 62) < 0x2Eu)
        --v9;
    }
    else
    {
      v20 = *(v9 - 2);
      if ((v20 & 0xF0) == 0xE0 && ((a00000000000000[v20 & 0xF] >> (*(v9 - 1) >> 5)) & 1) != 0)
        v9 -= 2;
    }
  }
  v21 = *(_DWORD *)(v11 + 260);
  v22 = *(_BYTE *)(v11 + 253);
  if ((_DWORD)v14 && v16 >= 1)
  {
    *(_DWORD *)(v8 + 72) = 0;
    *(_BYTE *)(v8 + 64) = 0;
    v23 = v13;
    goto LABEL_46;
  }
  v24 = (unint64_t)v7;
  while (1)
  {
    while (1)
    {
      if (v24 >= (unint64_t)v9)
        goto LABEL_87;
      v28 = 0;
      while (1)
      {
        v25 = v16 - 1;
        if (v16 < 1)
        {
          *a3 = 15;
          v24 += (unint64_t)v28;
          goto LABEL_113;
        }
        v26 = (char)v28[v24];
        v14 = v28[v24];
        if (v26 < 0)
          break;
        if (((v21 >> (v28[v24] >> 2)) & 1) == 0)
        {
          v33 = *(unsigned __int16 *)(v17 + 2 * (*v61 + v14));
          v24 += (unint64_t)(v28 + 1);
          goto LABEL_72;
        }
        v27 = v64++;
        *v27 = v14;
        ++v28;
        v16 = v25;
        if (&v9[-v24] == v28)
        {
          v24 = (unint64_t)v9;
          goto LABEL_87;
        }
      }
      v29 = v28[v24];
      v7 = &v28[v24 + 1];
      if (v14 < 0xE0)
        break;
      if (v14 > 0xED)
      {
        v23 = 1;
        if ((v14 + 62) > 0x32u)
        {
LABEL_45:
          LOBYTE(v13) = 0;
          LOBYTE(v15) = 0;
          goto LABEL_46;
        }
        goto LABEL_39;
      }
      if (((a00000000000000[v26 & 0xF] >> (*v7 >> 5)) & 1) == 0)
        goto LABEL_39;
      v30 = &v28[v24];
      v31 = v28[v24 + 2] ^ 0x80;
      if (v31 > 0x3F)
        goto LABEL_39;
      v32 = *v7 & 0x3F | ((v26 & 0xF) << 6);
      v24 = (unint64_t)(v30 + 3);
      v33 = *(unsigned __int16 *)(v17 + 2 * (v61[v32] + v31));
      if (*(_WORD *)(v17 + 2 * (v61[v32] + v31)))
        goto LABEL_73;
      v14 = v31 | (v32 << 6);
LABEL_78:
      v63 = &unk_18BE14770;
      result = sub_18BC289CC(v6, *(_QWORD *)(v6 + 48), v14, (uint64_t *)&v63, (uint64_t)&unk_18BE14770, &v64, (unint64_t)&v64[v16], 0, -1, *(_BYTE *)(v5 + 2), a3);
      if (*a3 >= 1)
      {
        *(_DWORD *)(v6 + 84) = result;
        goto LABEL_87;
      }
      if ((*(_DWORD *)(v6 + 208) & 0x80000000) == 0)
      {
        *a3 = -127;
LABEL_87:
        if (*a3 <= 0 && (*(_DWORD *)(v6 + 208) & 0x80000000) != 0)
        {
          v47 = a2[3];
          if (v24 < v47)
          {
            v48 = *(char *)v24;
            *(_BYTE *)(v8 + 65) = *(_BYTE *)v24;
            v49 = v48;
            if (v48 <= 0xEFu)
              v50 = 2;
            else
              v50 = 3;
            if (v48 > 0xDFu)
              ++v50;
            if ((v48 + 62) <= 0x32u)
              v51 = v50;
            else
              v51 = 0;
            if (v48 < 0)
              v52 = v51;
            else
              v52 = 1;
            v53 = (unsigned __int8 *)(v24 + 1);
            if (v24 + 1 >= v47)
            {
              v55 = 1;
            }
            else
            {
              v54 = ~v24 + v47;
              v55 = 1;
              do
              {
                v56 = *v53++;
                v57 = v55++;
                *(_BYTE *)(v8 + v57 + 65) = v56;
                v49 = v56 + (v49 << 6);
                --v54;
              }
              while (v54);
              v53 = (unsigned __int8 *)v47;
            }
            *(_BYTE *)(v8 + 64) = v55;
            v24 = (unint64_t)v53;
            *(_DWORD *)(v8 + 72) = v49;
            *(_DWORD *)(v8 + 76) = v52;
          }
        }
LABEL_113:
        a2[2] = v24;
LABEL_114:
        *(_QWORD *)(v5 + 32) = v64;
        return result;
      }
      v16 = *(_DWORD *)(v5 + 40) - (_DWORD)v64;
    }
    v23 = 1;
    if (v14 < 0xC2)
      goto LABEL_45;
    v34 = *v7 ^ 0x80;
    if (v34 <= 0x3F)
    {
      v24 += (unint64_t)(v28 + 2);
      v33 = *(unsigned __int16 *)(v17 + 2 * (v61[v29 & 0x1F] + v34));
      if (!*(_WORD *)(v17 + 2 * (v61[v29 & 0x1F] + v34)))
      {
        v14 = v34 | ((v29 & 0x1F) << 6);
        goto LABEL_78;
      }
      goto LABEL_73;
    }
LABEL_39:
    LOBYTE(v13) = 0;
    if (v14 <= 0xEF)
      LOBYTE(v15) = 2;
    else
      LOBYTE(v15) = 3;
    if (v14 > 0xDF)
      LOBYTE(v15) = v15 + 1;
    v23 = 1;
LABEL_46:
    if (v23 < (char)v15)
    {
      result = 1;
      LOBYTE(v35) = v23;
      v24 = (unint64_t)v7;
      while (v24 < a2[3])
      {
        v36 = *(unsigned __int8 *)v24;
        if ((char)v15 < 3 || v35 >= 2u)
        {
          if ((char)v36 >= -64)
            goto LABEL_62;
        }
        else
        {
          if (v15 == 3)
          {
            v37 = a00000000000000[v14 & 0xF];
            v38 = v36 >> 5;
          }
          else
          {
            v37 = byte_18BE1475E[v36 >> 4];
            LOBYTE(v38) = v14 & 7;
          }
          if ((v37 & (1 << v38)) == 0)
          {
LABEL_62:
            v23 = v35;
            v7 = (_BYTE *)v24;
            goto LABEL_63;
          }
        }
        v35 = (char)(v35 + 1);
        ++v24;
        LODWORD(v14) = v36 + ((_DWORD)v14 << 6);
        if (v35 >= (char)v15)
          goto LABEL_65;
      }
      v39 = (char)v13;
      if ((char)v13 >= (char)v35)
      {
        v41 = (_BYTE *)(v24 + (char)v13 - (uint64_t)(char)v35);
      }
      else
      {
        do
        {
          v40 = v39 + 1;
          *(_BYTE *)(v8 + 65 + v39) = v7[v39 - v23];
          v39 = v40;
        }
        while (v40 < (char)v35);
        v41 = &v7[v40 - v23];
      }
      *(_BYTE *)(v8 + 64) = v35;
      *(_DWORD *)(v8 + 72) = v14;
      *(_DWORD *)(v8 + 76) = (char)v15;
      a2[2] = v41;
      goto LABEL_114;
    }
LABEL_63:
    if (v23 != v15)
      break;
    v24 = (unint64_t)v7;
LABEL_65:
    v14 = (v14 - dword_18BE14748[(char)v15]);
    if ((char)v15 < 4 || (v42 = 0, (v22 & 1) != 0))
      v42 = *(_DWORD *)(v62
                      + 4 * (((v14 >> 4) & 0x3F) + *(unsigned __int16 *)(v62 + 2 * ((int)v14 >> 10))));
    v33 = *(unsigned __int16 *)(v17 + 2 * (v14 & 0xF | (16 * (unsigned __int16)v42)));
    if (((v42 >> (v14 & 0xF | 0x10)) & 1) == 0)
    {
      if (!*(_BYTE *)(v6 + 63) && (v14 - 57344) >> 8 >= 0x19 && (v14 - 983040) >> 17)
        goto LABEL_78;
LABEL_72:
      if (!v33)
        goto LABEL_78;
    }
LABEL_73:
    if (v33 > 0xFF)
    {
      v45 = v64++;
      *v45 = BYTE1(v33);
      if (v16 < 2)
      {
        *(_BYTE *)(v6 + 104) = v33;
        *(_BYTE *)(v6 + 91) = 1;
        *a3 = 15;
        goto LABEL_113;
      }
      v46 = v64++;
      *v46 = v33;
      v44 = -2;
    }
    else
    {
      v43 = v64++;
      *v43 = v33;
      v44 = -1;
    }
    v16 += v44;
  }
  v58 = (char)v13 - (uint64_t)v23;
  if ((char)v13 < v23)
  {
    v59 = (_BYTE *)((char)v13 + v8 + 65);
    do
      *v59++ = v7[v58];
    while (!__CFADD__(v58++, 1));
  }
  *(_BYTE *)(v8 + 64) = v23;
  a2[2] = &v7[v58];
  *(_QWORD *)(v5 + 32) = v64;
  *a3 = 12;
  return result;
}

uint64_t sub_18BC2B050(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int v10;

  v3 = a1 + ((unint64_t)a2 << 10);
  v4 = *(_DWORD *)(v3 + 644);
  if ((v4 & 0x80000000) == 0 || (v4 & 0xF00000) == 0x700000)
  {
    v5 = *(_DWORD *)(v3 + 260);
    if ((v5 & 0x80000000) == 0 || (v5 & 0xF00000) == 0x700000)
    {
      v7 = 0;
      while (1)
      {
        v8 = *(_DWORD *)(v3 + v7);
        if (v8 < 0 && (v8 & 0xF00000) != 0x700000)
          break;
        v7 += 4;
        if (v7 == 1024)
        {
          v9 = 0;
          while (1)
          {
            v10 = *(_DWORD *)(v3 + v9);
            if ((v10 & 0x80000000) == 0)
            {
              if (sub_18BC2B050(a1, HIBYTE(v10)))
                break;
            }
            v9 += 4;
            if (v9 == 1024)
              return 0;
          }
          return 1;
        }
      }
    }
  }
  return 1;
}

char *sub_18BC2B0FC(char *result, uint64_t a2, _DWORD *a3)
{
  char *v4;
  _BYTE *v5;
  uint64_t v6;
  char v7;

  if (!*(_BYTE *)(a2 + 8))
  {
    v4 = result;
    v5 = *(_BYTE **)(a2 + 32);
    result = (char *)uprv_malloc(0x54uLL);
    *((_QWORD *)v4 + 2) = result;
    if (result)
    {
      if (!v5 || *v5 != 106 || v5[1] != 97 || (v6 = 0x605070001040203, v7 = 1, v5[2]) && v5[2] != 95)
      {
        v7 = 0;
        v6 = 0x106050402030007;
      }
      result[74] = v7;
      *(_OWORD *)result = xmmword_18BE1490C;
      *((_OWORD *)result + 1) = unk_18BE1491C;
      result[64] = 1;
      *(_DWORD *)(result + 65) = 0;
      v4[64] = 0;
      *((_OWORD *)result + 2) = xmmword_18BE1490C;
      *((_OWORD *)result + 3) = unk_18BE1491C;
      *((_WORD *)result + 36) = 1;
      result[75] = 0;
      *(_QWORD *)(result + 76) = v6;
      *((_DWORD *)v4 + 21) = 0;
    }
    else
    {
      *a3 = 7;
    }
    *((_WORD *)v4 + 68) = -3;
    v4[89] = -1;
  }
  return result;
}

void sub_18BC2B1E8(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 16);
  if (v2)
  {
    if (!*(_BYTE *)(a1 + 62))
      uprv_free(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

uint64_t sub_18BC2B21C(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 16);
  if (a2 > 1
    || (*(_OWORD *)v2 = xmmword_18BE1490C,
        *(_OWORD *)(v2 + 16) = unk_18BE1491C,
        *(_BYTE *)(v2 + 64) = 1,
        *(_DWORD *)(v2 + 65) = 0,
        *(_BYTE *)(result + 64) = 0,
        a2 != 1))
  {
    *(_OWORD *)(v2 + 32) = xmmword_18BE1490C;
    *(_OWORD *)(v2 + 48) = unk_18BE1491C;
    *(_WORD *)(v2 + 72) = 1;
    *(_BYTE *)(v2 + 75) = 0;
    v3 = 0x106050402030007;
    if (*(_BYTE *)(v2 + 74) == 1)
      v3 = 0x605070001040203;
    *(_QWORD *)(v2 + 76) = v3;
    *(_DWORD *)(result + 84) = 0;
  }
  return result;
}

_QWORD *sub_18BC2B29C(_QWORD *result, int *a2)
{
  uint64_t v2;
  unsigned __int16 *v3;
  _BYTE *v4;
  _WORD *v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  __int16 v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  int v22;
  char v23;
  _BYTE *v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  __int16 v28;
  unsigned __int16 *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  char v33;

  v2 = result[1];
  v3 = (unsigned __int16 *)result[2];
  v4 = *(_BYTE **)(v2 + 16);
  v6 = result[3];
  v5 = (_WORD *)result[4];
  v7 = result[5];
  v8 = v4[64];
  v9 = v4[65];
  v10 = v4[66];
  v11 = v4[67];
  v12 = v4[68];
  if (!v8)
  {
    v14 = v4[66];
    if (v4[65])
      goto LABEL_80;
    goto LABEL_72;
  }
  v13 = v4[68];
  v14 = v4[66];
  v15 = v4[67];
  if (v4[65])
    goto LABEL_21;
  while (2)
  {
    v9 = 0;
    if ((unint64_t)v3 < v6 && (unint64_t)v5 < v7)
    {
      do
      {
        v16 = *(unsigned __int8 *)v3;
        if (v16 < 0x20)
          break;
        v3 = (unsigned __int16 *)((char *)v3 + 1);
        if ((v16 & 0x80) != 0)
        {
          v17 = *(_DWORD *)&v4[4 * (char)v11] + (v16 & 0x7F);
          if (HIWORD(v17))
          {
            *v5 = (v17 >> 10) - 10304;
            v18 = v17 & 0x3FF | 0xDC00;
            if ((unint64_t)(v5 + 1) >= v7)
            {
              v9 = 0;
              *(_WORD *)(v2 + 144) = v18;
              *(_BYTE *)(v2 + 93) = 1;
              *a2 = 15;
              ++v5;
              goto LABEL_100;
            }
            v5[1] = v18;
            v5 += 2;
          }
          else
          {
            *v5++ = v17;
          }
        }
        else
        {
          *v5++ = v16;
        }
      }
      while ((unint64_t)v3 < v6 && (unint64_t)v5 < v7);
      v9 = 0;
    }
    v13 = v12;
    v14 = v10;
LABEL_20:
    v15 = v11;
LABEL_21:
    if ((unint64_t)v3 >= v6)
      goto LABEL_42;
    v19 = 0;
    v11 = v15;
    v10 = v14;
    v12 = v13;
    v20 = v9;
LABEL_23:
    if ((unint64_t)v5 >= v7)
    {
      *a2 = 15;
LABEL_42:
      LOBYTE(v12) = v13;
      LOBYTE(v10) = v14;
      LOBYTE(v11) = v15;
      goto LABEL_100;
    }
    v22 = v20;
    v21 = *((unsigned __int8 *)v3 + v19);
    v23 = 2;
    v24 = (_BYTE *)(v2 + 66);
    v20 = 2;
    v25 = *((unsigned __int8 *)v3 + v19);
    switch(v22)
    {
      case 0:
        if (((1 << v21) & 0x2601) != 0)
        {
          *v5++ = v21;
LABEL_51:
          v3 = (unsigned __int16 *)((char *)v3 + v19 + 1);
          continue;
        }
        if (v21 >= 0x10)
        {
          if (v21 > 0x17)
          {
            v11 = v21 - 24;
            v20 = 6;
LABEL_36:
            v23 = 1;
            v24 = (_BYTE *)(v2 + 65);
            goto LABEL_37;
          }
          v3 = (unsigned __int16 *)((char *)v3 + v19 + 1);
          v11 = v21 - 16;
          continue;
        }
        if (v21 <= 8)
        {
          v10 = v21 - 1;
          v20 = 3;
          goto LABEL_36;
        }
        if (v21 == 11)
        {
          v20 = 4;
          goto LABEL_36;
        }
        if (v21 == 14)
        {
          v23 = 1;
          v24 = (_BYTE *)(v2 + 65);
          v20 = 1;
LABEL_37:
          v25 = v12;
          goto LABEL_38;
        }
        if (v21 != 15)
        {
          v9 = 0;
          *a2 = 12;
          *(_BYTE *)(v2 + 65) = v21;
          *(_BYTE *)(v2 + 64) = 1;
          v3 = (unsigned __int16 *)((char *)v3 + v19 + 1);
          goto LABEL_100;
        }
        v3 = (unsigned __int16 *)((char *)v3 + v19 + 1);
LABEL_72:
        v9 = 0;
        if ((unint64_t)v3 + 1 < v6 && (unint64_t)v5 < v7)
        {
          while ((*(_BYTE *)v3 + 13) <= 0xECu)
          {
            *v5++ = _byteswap_ushort(*v3);
            v29 = v3 + 1;
            if ((unint64_t)v3 + 3 < v6)
            {
              ++v3;
              if ((unint64_t)v5 < v7)
                continue;
            }
            v9 = 0;
            v3 = v29;
            goto LABEL_79;
          }
          v9 = 0;
        }
LABEL_79:
        v14 = v10;
LABEL_80:
        if ((unint64_t)v3 >= v6)
        {
          v8 = 0;
          goto LABEL_99;
        }
        v30 = 0;
        v13 = v12;
        v31 = v9;
        while (1)
        {
          if ((unint64_t)v5 >= v7)
          {
            v8 = 0;
            *a2 = 15;
            goto LABEL_99;
          }
          v32 = *((unsigned __int8 *)v3 + v30);
          if (!v31)
            break;
          if (v31 == 1)
          {
            *(_BYTE *)(v2 + 66) = v32;
            v33 = 2;
            v31 = 2;
            goto LABEL_94;
          }
          if (v31 == 2)
          {
            *v5++ = v32 | ((_WORD)v13 << 8);
            v3 = (unsigned __int16 *)((char *)v3 + v30 + 1);
            v12 = v13;
            v10 = v14;
            goto LABEL_72;
          }
LABEL_95:
          if (v6 - (_QWORD)v3 == ++v30)
          {
            v8 = 0;
            v3 = (unsigned __int16 *)v6;
            v9 = v31;
            goto LABEL_97;
          }
        }
        if ((v32 + 32) >= 0x13u)
        {
          *(_BYTE *)(v2 + 65) = v32;
          v31 = 2;
          v33 = 1;
LABEL_94:
          *(_BYTE *)(v2 + 64) = v33;
          v13 = v32;
          goto LABEL_95;
        }
        if (v32 < 0xE8)
        {
          v3 = (unsigned __int16 *)((char *)v3 + v30 + 1);
          v8 = 1;
          v12 = v13;
          v10 = v14;
          v11 = (v32 + 32);
          continue;
        }
        if (v32 <= 0xEF)
        {
          v11 = (v32 + 24);
          v9 = 6;
LABEL_71:
          *(_BYTE *)(v2 + 65) = v32;
          v8 = 1;
          *(_BYTE *)(v2 + 64) = 1;
          v3 = (unsigned __int16 *)((char *)v3 + v30 + 1);
          goto LABEL_20;
        }
        if ((_DWORD)v32 == 240)
        {
          *(_BYTE *)(v2 + 65) = -16;
          v33 = 1;
          v31 = 1;
          v32 = v13;
          goto LABEL_94;
        }
        if ((_DWORD)v32 == 241)
        {
          v9 = 4;
          goto LABEL_71;
        }
        v8 = 0;
        v9 = 0;
        *a2 = 12;
        *(_BYTE *)(v2 + 65) = v32;
        *(_BYTE *)(v2 + 64) = 1;
        v3 = (unsigned __int16 *)((char *)v3 + v30 + 1);
LABEL_97:
        LOBYTE(v12) = v13;
LABEL_99:
        LOBYTE(v10) = v14;
LABEL_100:
        if (*a2 < 1 || *a2 == 15)
        {
          if (!v9)
            *(_BYTE *)(v2 + 64) = 0;
        }
        else
        {
          LOBYTE(v9) = 0;
        }
        v4[64] = v8;
        v4[65] = v9;
        v4[66] = v10;
        v4[67] = v11;
        v4[68] = v12;
        result[2] = v3;
        result[4] = v5;
        return result;
      case 1:
        goto LABEL_38;
      case 2:
        *v5++ = v21 | ((_WORD)v12 << 8);
        goto LABEL_51;
      case 3:
        v3 = (unsigned __int16 *)((char *)v3 + v19 + 1);
        if ((v21 & 0x80) == 0)
        {
          v26 = dword_18BE1492C[(char)v10] + v21;
LABEL_57:
          *v5++ = v26;
          continue;
        }
        v26 = *(_DWORD *)&v4[4 * (char)v10] + (v21 & 0x7F);
        if (!HIWORD(v26))
          goto LABEL_57;
        *v5 = (v26 >> 10) - 10304;
        v28 = v26 & 0x3FF | 0xDC00;
        if ((unint64_t)(v5 + 1) >= v7)
        {
          *(_WORD *)(v2 + 144) = v28;
          *(_BYTE *)(v2 + 93) = 1;
          *a2 = 15;
          v9 = 3;
          ++v5;
          goto LABEL_100;
        }
        v5[1] = v28;
        v5 += 2;
        continue;
      case 4:
        v11 = v21 >> 5;
        v25 = v21 & 0x1F;
        v20 = 5;
        v24 = (_BYTE *)(v2 + 66);
LABEL_38:
        *v24 = v21;
        *(_BYTE *)(v2 + 64) = v23;
        v12 = v25;
        goto LABEL_39;
      case 5:
        *(_DWORD *)&v4[4 * (char)v11] = ((v21 << 7) & 0xFF807FFF | (v12 << 15)) + 0x10000;
        goto LABEL_51;
      case 6:
        v3 = (unsigned __int16 *)((char *)v3 + v19 + 1);
        if (v21)
        {
          if (v21 <= 0x67)
          {
            v27 = v21 << 7;
LABEL_60:
            *(_DWORD *)&v4[4 * (char)v11] = v27;
            continue;
          }
          if ((v21 - 104) <= 0x3Fu)
          {
            v27 = (v21 << 7) + 44032;
            goto LABEL_60;
          }
          if (v21 >= 0xF9)
          {
            v27 = dword_18BE1494C[v21 - 249];
            goto LABEL_60;
          }
          *(_BYTE *)(v2 + 66) = v21;
        }
        else
        {
          *(_BYTE *)(v2 + 66) = 0;
        }
        *(_BYTE *)(v2 + 64) = 2;
        v9 = 6;
        goto LABEL_100;
      default:
LABEL_39:
        if (v6 - (_QWORD)v3 != ++v19)
          goto LABEL_23;
        v3 = (unsigned __int16 *)v6;
        v9 = v20;
        goto LABEL_100;
    }
  }
}

_QWORD *sub_18BC2B888(_QWORD *result, int *a2)
{
  int *v2;
  uint64_t v3;
  unsigned __int8 *v4;
  _BYTE *v5;
  _WORD *v6;
  unint64_t v7;
  int *v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  int v21;
  unsigned int v22;
  int v23;
  char v24;
  _BYTE *v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  int *v31;
  _WORD *v32;
  __int16 v33;
  unsigned int v34;
  uint64_t v35;
  int *v36;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  char v44;
  char v46;
  uint64_t v47;

  v2 = a2;
  v3 = result[1];
  v4 = (unsigned __int8 *)result[2];
  v5 = *(_BYTE **)(v3 + 16);
  v7 = result[3];
  v6 = (_WORD *)result[4];
  v9 = result[5];
  v8 = (int *)result[6];
  v10 = v5[65];
  v11 = v5[66];
  v12 = v5[67];
  v13 = v5[68];
  if (v5[64])
  {
    v46 = v5[64];
    v14 = 0;
    if (v5[65])
    {
      v15 = -1;
      goto LABEL_7;
    }
    v17 = v5[68];
    v18 = v5[67];
    v15 = 0;
    goto LABEL_68;
  }
  v16 = 0;
  if (v5[65])
  {
    v15 = -1;
    v17 = v5[68];
  }
  else
  {
LABEL_131:
    v17 = v13;
LABEL_88:
    if ((unint64_t)(v4 + 1) >= v7 || (unint64_t)v6 >= v9)
    {
      v10 = 0;
      v15 = v16;
    }
    else
    {
      v38 = 0;
      v15 = v16;
      while ((v4[v38] + 13) <= 0xECu)
      {
        v6[v38 / 2] = _byteswap_ushort(*(_WORD *)&v4[v38]);
        v39 = (unint64_t)&v6[v38 / 2 + 1];
        if (v8)
          *v8++ = v15;
        v40 = v38 + 2;
        if ((unint64_t)&v4[v38 + 3] < v7)
        {
          v15 = v16 + v38;
          v38 += 2;
          if (v39 < v9)
            continue;
        }
        v10 = 0;
        v16 += v40;
        v15 = v16 - 2;
        v6 = (_WORD *)((char *)v6 + v40);
        v4 += v40;
        goto LABEL_101;
      }
      v10 = 0;
      v16 += v38;
      v6 = (_WORD *)((char *)v6 + v38);
      v4 += v38;
    }
  }
LABEL_101:
  if ((unint64_t)v4 >= v7)
  {
    v27 = 0;
    goto LABEL_120;
  }
  v41 = 0;
  v13 = v17;
  v42 = v10;
  while (1)
  {
    if ((unint64_t)v6 >= v9)
    {
      v27 = 0;
      *v2 = 15;
      goto LABEL_120;
    }
    v43 = v4[v41];
    if (!v42)
      break;
    if (v42 == 1)
    {
      *(_BYTE *)(v3 + 66) = v43;
      v44 = 2;
      v42 = 2;
      goto LABEL_115;
    }
    if (v42 == 2)
    {
      *v6++ = v43 | ((_WORD)v13 << 8);
      v16 += 1 + v41;
      v4 += v41 + 1;
      if (v8)
        *v8++ = v15;
      goto LABEL_131;
    }
LABEL_116:
    if (v7 - (_QWORD)v4 == ++v41)
    {
      v27 = 0;
      v4 = (unsigned __int8 *)v7;
      v10 = v42;
      goto LABEL_118;
    }
  }
  v18 = (v43 + 32);
  if ((v43 + 32) >= 0x13u)
  {
    *(_BYTE *)(v3 + 65) = v43;
    v42 = 2;
    v44 = 1;
LABEL_115:
    *(_BYTE *)(v3 + 64) = v44;
    v13 = v43;
    goto LABEL_116;
  }
  if (v43 < 0xE8)
  {
    v15 = v16 + v41 + 1;
    v4 += v41 + 1;
    v46 = 1;
    v17 = v13;
    goto LABEL_68;
  }
  if (v43 > 0xEF)
  {
    if ((_DWORD)v43 != 240)
    {
      if ((_DWORD)v43 == 241)
      {
        v10 = 4;
        goto LABEL_135;
      }
      v27 = 0;
      v10 = 0;
      *v2 = 12;
      *(_BYTE *)(v3 + 65) = v43;
      *(_BYTE *)(v3 + 64) = 1;
      v4 += v41 + 1;
LABEL_118:
      LOBYTE(v17) = v13;
LABEL_120:
      LOBYTE(v18) = v12;
      goto LABEL_121;
    }
    *(_BYTE *)(v3 + 65) = -16;
    v44 = 1;
    v42 = 1;
    v43 = v13;
    goto LABEL_115;
  }
  v12 = (v43 + 24);
  v10 = 6;
LABEL_135:
  *(_BYTE *)(v3 + 65) = v43;
  v46 = 1;
  *(_BYTE *)(v3 + 64) = 1;
  v14 = v16 + v41 + 1;
  v4 += v41 + 1;
LABEL_7:
  while (2)
  {
    if ((unint64_t)v4 >= v7)
    {
      LOBYTE(v17) = v13;
      LOBYTE(v18) = v12;
      v2 = a2;
    }
    else
    {
      v19 = 0;
      v18 = v12;
      v20 = v11;
      v47 = v11;
      v17 = v13;
      v21 = v10;
LABEL_9:
      if ((unint64_t)v6 >= v9)
      {
        v2 = a2;
        *a2 = 15;
        LOBYTE(v17) = v13;
        LOBYTE(v11) = v20;
        LOBYTE(v18) = v12;
      }
      else
      {
        v23 = v21;
        v22 = v4[v19];
        v24 = 2;
        v25 = (_BYTE *)(v3 + 66);
        v21 = 2;
        v26 = v4[v19];
        switch(v23)
        {
          case 0:
            if (((1 << v22) & 0x2601) != 0)
            {
              *v6++ = v22;
LABEL_39:
              v4 += v19 + 1;
              if (v8)
                *v8++ = v15;
              v15 = v14 + 1 + v19;
              goto LABEL_42;
            }
            if (v22 < 0x10)
            {
              if (v22 <= 8)
              {
                v47 = v22 - 1;
                v21 = 3;
LABEL_22:
                v24 = 1;
                v25 = (_BYTE *)(v3 + 65);
                goto LABEL_23;
              }
              switch(v22)
              {
                case 0xBu:
                  v21 = 4;
                  goto LABEL_22;
                case 0xEu:
                  v24 = 1;
                  v25 = (_BYTE *)(v3 + 65);
                  v21 = 1;
LABEL_23:
                  v26 = v17;
                  goto LABEL_24;
                case 0xFu:
                  v16 = v14 + v19 + 1;
                  v4 += v19 + 1;
                  v2 = a2;
                  v11 = v47;
                  v12 = v18;
                  goto LABEL_88;
              }
              v10 = 0;
              v2 = a2;
              *a2 = 12;
              *(_BYTE *)(v3 + 65) = v22;
              *(_BYTE *)(v3 + 64) = 1;
              v4 += v19 + 1;
LABEL_27:
              v27 = v46;
              LOBYTE(v11) = v47;
              goto LABEL_121;
            }
            if (v22 > 0x17)
            {
              v18 = v22 - 24;
              v21 = 6;
              goto LABEL_22;
            }
            v15 = v14 + v19 + 1;
            v4 += v19 + 1;
            v18 = v22 - 16;
LABEL_42:
            v11 = v47;
            v2 = a2;
LABEL_68:
            v10 = 0;
            if ((unint64_t)v4 >= v7 || (unint64_t)v6 >= v9)
            {
LABEL_84:
              v13 = v17;
              v12 = v18;
              v14 = v15;
              continue;
            }
            while (2)
            {
              v34 = *v4;
              if (v34 < 0x20)
              {
LABEL_83:
                v10 = 0;
                goto LABEL_84;
              }
              ++v4;
              if ((v34 & 0x80) == 0 || (v34 = *(_DWORD *)&v5[4 * (char)v18] + (v34 & 0x7F), !HIWORD(v34)))
              {
                *v6++ = v34;
                if (v8)
                {
                  v35 = 1;
                  v36 = v8;
                  goto LABEL_75;
                }
                goto LABEL_76;
              }
              *v6 = (v34 >> 10) - 10304;
              if ((unint64_t)(v6 + 1) < v9)
              {
                v6[1] = v34 & 0x3FF | 0xDC00;
                if (v8)
                {
                  *v8 = v15;
                  v36 = v8 + 1;
                  v35 = 2;
                  v6 += 2;
LABEL_75:
                  v8 += v35;
                  *v36 = v15;
                }
                else
                {
                  v6 += 2;
                }
LABEL_76:
                ++v15;
                if ((unint64_t)v4 >= v7 || (unint64_t)v6 >= v9)
                  goto LABEL_83;
                continue;
              }
              break;
            }
            if (v8)
              *v8++ = v15;
            v27 = v46;
            v10 = 0;
            *(_WORD *)(v3 + 144) = v34 & 0x3FF | 0xDC00;
            *(_BYTE *)(v3 + 93) = 1;
            *v2 = 15;
            ++v6;
LABEL_121:
            if (*v2 < 1 || *v2 == 15)
            {
              if (!v10)
                *(_BYTE *)(v3 + 64) = 0;
            }
            else
            {
              LOBYTE(v10) = 0;
            }
            v5[64] = v27;
            v5[65] = v10;
            v5[66] = v11;
            v5[67] = v18;
            v5[68] = v17;
            result[2] = v4;
            result[4] = v6;
            result[6] = v8;
            return result;
          case 1:
            goto LABEL_24;
          case 2:
            *v6++ = v22 | ((_WORD)v17 << 8);
            goto LABEL_39;
          case 3:
            v11 = v47;
            v4 += v19 + 1;
            if ((v22 & 0x80) == 0)
            {
              *v6++ = LOWORD(dword_18BE1492C[(char)v47]) + v22;
              v28 = 1;
              v2 = a2;
              if (!v8)
                goto LABEL_52;
LABEL_49:
              v31 = v8;
              v32 = v6;
              goto LABEL_50;
            }
            v30 = *(_DWORD *)&v5[4 * (char)v47] + (v22 & 0x7F);
            v2 = a2;
            if (!HIWORD(v30))
            {
              *v6++ = v30;
              v28 = 1;
              if (!v8)
              {
LABEL_52:
                v15 = v14 + 1 + v19;
                goto LABEL_68;
              }
              goto LABEL_49;
            }
            *v6 = (v30 >> 10) - 10304;
            if ((unint64_t)(v6 + 1) < v9)
            {
              v33 = v30 & 0x3FF | 0xDC00;
              v32 = v6 + 2;
              v6[1] = v33;
              if (!v8)
                goto LABEL_51;
              *v8 = v15;
              v31 = v8 + 1;
              v28 = 2;
LABEL_50:
              v8 += v28;
              *v31 = v15;
LABEL_51:
              v6 = v32;
              goto LABEL_52;
            }
            if (v8)
              *v8++ = v15;
            *(_WORD *)(v3 + 144) = v30 & 0x3FF | 0xDC00;
            *(_BYTE *)(v3 + 93) = 1;
            *a2 = 15;
            v10 = 3;
            ++v6;
            goto LABEL_29;
          case 4:
            v18 = v22 >> 5;
            v26 = v22 & 0x1F;
            v21 = 5;
            v25 = (_BYTE *)(v3 + 66);
LABEL_24:
            *v25 = v22;
            *(_BYTE *)(v3 + 64) = v24;
            v17 = v26;
            goto LABEL_25;
          case 5:
            *(_DWORD *)&v5[4 * (char)v18] = ((v22 << 7) & 0xFF807FFF | (v17 << 15)) + 0x10000;
            v15 = v14 + v19 + 1;
            v4 += v19 + 1;
            goto LABEL_42;
          case 6:
            v4 += v19 + 1;
            v2 = a2;
            if (!v22)
            {
              *(_BYTE *)(v3 + 66) = 0;
              *(_BYTE *)(v3 + 64) = 2;
              v10 = 6;
              goto LABEL_27;
            }
            v15 = v14 + 1 + v19;
            v11 = v47;
            if (v22 <= 0x67)
            {
              v29 = v22 << 7;
LABEL_55:
              *(_DWORD *)&v5[4 * (char)v18] = v29;
              goto LABEL_68;
            }
            if ((v22 - 104) <= 0x3Fu)
            {
              v29 = (v22 << 7) + 44032;
              goto LABEL_55;
            }
            if (v22 >= 0xF9)
            {
              v29 = dword_18BE1494C[v22 - 249];
              goto LABEL_55;
            }
            *(_BYTE *)(v3 + 66) = v22;
            *(_BYTE *)(v3 + 64) = 2;
            v10 = 6;
            break;
          default:
LABEL_25:
            if (v7 - (_QWORD)v4 != ++v19)
              goto LABEL_9;
            v4 = (unsigned __int8 *)v7;
            v10 = v21;
            v2 = a2;
            goto LABEL_27;
        }
      }
    }
    break;
  }
LABEL_29:
  v27 = v46;
  goto LABEL_121;
}

uint64_t sub_18BC2C038(uint64_t result, int *a2)
{
  uint64_t v2;
  unsigned __int16 *v3;
  uint64_t v4;
  unint64_t v5;
  _BYTE *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int i;
  BOOL v11;
  BOOL v12;
  int v13;
  int v14;
  char v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unsigned __int8 v28;
  int v29;
  char v30;
  uint64_t v31;
  int v32;
  unint64_t v33;
  _BYTE *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  char v39;
  uint64_t v40;
  unsigned __int16 *v41;
  _BYTE *v42;
  uint64_t v43;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  unsigned __int8 v52;
  int v53;
  char v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  int v58;
  char v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  unsigned __int8 v69;
  int v70;
  char v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _BYTE *v75;
  int v76;
  _BYTE *v77;
  unsigned int v78;
  uint64_t v79;
  int *v80;
  int v81;
  unint64_t v82;
  uint64_t v84;
  _BYTE *v85;
  uint64_t v86;
  unsigned int v87;

  v84 = result;
  v87 = 0;
  v2 = *(_QWORD *)(result + 8);
  v3 = *(unsigned __int16 **)(result + 16);
  v4 = *(_QWORD *)(v2 + 16);
  v5 = *(_QWORD *)(result + 24);
  v6 = *(_BYTE **)(result + 32);
  v7 = *(_DWORD *)(result + 40) - (_DWORD)v6;
  v8 = *(unsigned __int8 *)(v4 + 72);
  v85 = (_BYTE *)v2;
  v86 = *(unsigned __int8 *)(v4 + 73);
  v9 = *(unsigned int *)(v4 + 4 * v86 + 32);
  for (i = *(_DWORD *)(v2 + 84); ; i = 0)
  {
    v11 = !i || v7 <= 0;
    v12 = !v11;
    if (!(_DWORD)v8)
      break;
    if (v12)
      goto LABEL_10;
    while (1)
    {
      if ((unint64_t)v3 >= v5)
        goto LABEL_162;
      if (v7 < 1)
        goto LABEL_157;
      v56 = *v3++;
      i = v56;
      if (v56 - 32 <= 0x5F)
        goto LABEL_91;
      if (i > 0x1F)
        break;
      if (((1 << i) & 0x2601) == 0)
      {
        i |= 0x100u;
        goto LABEL_98;
      }
LABEL_91:
      *v6 = i;
LABEL_92:
      i = 0;
      ++v6;
      --v7;
    }
    v15 = i - v9;
    if (i - v9 < 0x80)
      goto LABEL_13;
    if ((i & 0xF800) != 0xD800)
    {
      if (i > 0x9F)
      {
        if (i == 65279 || i >> 4 > 0xFFE)
        {
          i |= 0xE0000u;
LABEL_114:
          v32 = 3;
        }
        else
        {
          v57 = 0;
          v58 = 4224;
          while (i - *(_DWORD *)(v4 + 4 * v57 + 32) >= 0x80)
          {
            ++v57;
            v58 += 256;
            if (v57 == 8)
              goto LABEL_119;
          }
          if ((v57 & 0x80) != 0)
          {
LABEL_119:
            v64 = 0;
            v62 = 256;
            while (i - dword_18BE1492C[v64] >= 0x80)
            {
              ++v64;
              v62 += 256;
              if (v64 == 8)
                goto LABEL_126;
            }
            if ((v64 & 0x80) == 0)
            {
              v63 = i - dword_18BE1492C[v64];
              goto LABEL_125;
            }
LABEL_126:
            v65 = v9;
            v66 = v8;
            result = sub_18BC2D6AC(i, &v87);
            if ((result & 0x80000000) != 0)
            {
              v9 = v65;
              if ((i - 13312) >> 10 <= 0x28
                && ((unint64_t)v3 >= v5 || (*v3 - 13312) >> 10 <= 0x28))
              {
                v8 = 0;
                i |= 0xF0000u;
                goto LABEL_114;
              }
              i |= 0xE0000u;
              v32 = 3;
            }
            else
            {
              v67 = result;
              v68 = *(char *)(v4 + 75);
              v69 = *(_BYTE *)(v4 + v68 + 76);
              v70 = v69;
              if ((v68 + 1) == 8)
                v71 = 0;
              else
                v71 = v68 + 1;
              *(_BYTE *)(v4 + 75) = v71;
              v72 = v87;
              *(_DWORD *)(v4 + 4 * v69 + 32) = v87;
              result = sub_18BC2D634(v4, v69);
              v9 = v72;
              LOBYTE(v86) = v70;
              i = ((v70 << 16) + 1572864) | (v67 << 8) | (i - v72) | 0x80;
              v32 = 3;
            }
            v8 = v66;
            goto LABEL_99;
          }
          v59 = v57;
          if ((unint64_t)v3 >= v5
            || (v60 = *(_DWORD *)(v4 + 4 * v57 + 32), v61 = *v3, v60 + 127 >= v61)
            && (v60 <= v61 || v61 <= 0x7F && (v61 > 0x1F || ((1 << v61) & 0x2601) != 0)))
          {
            v73 = *(unsigned int *)(v4 + 4 * v57 + 32);
            v74 = v8;
            result = sub_18BC2D634(v4, v57);
            v9 = v73;
            v8 = v74;
            i = v58 | (i - v73);
            v32 = 2;
            LOBYTE(v86) = v59;
            goto LABEL_99;
          }
          v62 = i - v60;
          v63 = ((char)v57 << 8) + 384;
LABEL_125:
          i = v63 | v62;
LABEL_98:
          v32 = 2;
        }
      }
      else
      {
        v32 = 2;
        i = i & 0x7F | 0x200;
      }
      goto LABEL_99;
    }
    if ((i & 0x400) != 0)
    {
LABEL_164:
      v81 = 12;
LABEL_165:
      v79 = v84;
      v75 = v85;
LABEL_166:
      v80 = a2;
      goto LABEL_167;
    }
LABEL_10:
    v82 = v5;
    if ((unint64_t)v3 >= v5)
      goto LABEL_162;
    v13 = *v3;
    if ((v13 & 0xFC00) != 0xDC00)
      goto LABEL_164;
    ++v3;
    v14 = (i << 10) - 56613888 + v13;
    v15 = v13 - v9;
    if ((v14 - v9) < 0x80)
    {
LABEL_13:
      *v6 = v15 | 0x80;
      goto LABEL_92;
    }
    v16 = 0;
    v17 = 4224;
    while ((v14 - *(_DWORD *)(v4 + 4 * v16 + 32)) >= 0x80)
    {
      ++v16;
      v17 += 256;
      if (v16 == 8)
        goto LABEL_27;
    }
    if ((v16 & 0x80) == 0)
    {
      v22 = *(unsigned int *)(v4 + 4 * v16 + 32);
      LOBYTE(v86) = v16;
      v23 = v8;
      result = sub_18BC2D634(v4, v16);
      v9 = v22;
      v8 = v23;
      i = v17 | (v14 - v22);
      goto LABEL_98;
    }
LABEL_27:
    v24 = v9;
    v25 = v8;
    result = sub_18BC2D6AC((i << 10) - 56613888 + v13, &v87);
    if ((result & 0x80000000) != 0)
    {
      v8 = 0;
      *v6++ = 15;
      --v7;
      v32 = 4;
      i = v13 | (i << 16);
      v9 = v24;
    }
    else
    {
      v26 = result;
      v27 = *(char *)(v4 + 75);
      v28 = *(_BYTE *)(v4 + v27 + 76);
      v29 = v28;
      if ((v27 + 1) == 8)
        v30 = 0;
      else
        v30 = v27 + 1;
      *(_BYTE *)(v4 + 75) = v30;
      v31 = v87;
      *(_DWORD *)(v4 + 4 * v28 + 32) = v87;
      result = sub_18BC2D634(v4, v28);
      v9 = v31;
      LOBYTE(v86) = v29;
      i = ((v26 << 8) - 0x20000) | (v29 << 21) | (v14 - v31) | 0xB000080;
      v32 = 4;
      v8 = v25;
    }
    v5 = v82;
LABEL_99:
    if (v7 < v32)
    {
LABEL_143:
      v75 = v85;
      v76 = v32 - v7;
      v77 = v85 + 104;
      switch(v76)
      {
        case 1:
          goto LABEL_147;
        case 2:
          goto LABEL_146;
        case 3:
          goto LABEL_145;
        case 4:
          v77 = v85 + 105;
          v85[104] = HIBYTE(i);
LABEL_145:
          *v77++ = BYTE2(i);
LABEL_146:
          *v77++ = BYTE1(i);
LABEL_147:
          *v77 = i;
          break;
        default:
          break;
      }
      v85[91] = v76;
      if (v76 == 4)
        v78 = 0;
      else
        v78 = i >> (8 * v76);
      if (v7 == 1)
      {
        v80 = a2;
        v79 = v84;
      }
      else
      {
        if (v7 != 2)
        {
          if (v7 != 3)
          {
            i = 0;
            v81 = 15;
            v79 = v84;
            goto LABEL_166;
          }
          *v6++ = BYTE2(v78);
        }
        v80 = a2;
        v79 = v84;
        *v6++ = BYTE1(v78);
      }
      i = 0;
      *v6++ = v78;
      v81 = 15;
LABEL_167:
      *v80 = v81;
      goto LABEL_168;
    }
    if (v32 != 2)
    {
      if (v32 != 3)
        *v6++ = HIBYTE(i);
      *v6++ = BYTE2(i);
    }
    *(_WORD *)v6 = bswap32(i) >> 16;
    v6 += 2;
    v7 -= v32;
  }
  if (v12)
  {
LABEL_19:
    if ((unint64_t)v3 < v5)
    {
      v18 = *v3;
      if ((v18 & 0xFC00) != 0xDC00)
      {
        LOBYTE(v8) = 0;
        goto LABEL_164;
      }
      v19 = 0;
      ++v3;
      v20 = v18 + (i << 10) - 56613888;
      v21 = 57472;
      while (v20 - *(_DWORD *)(v4 + 4 * v19 + 32) >= 0x80)
      {
        ++v19;
        v21 += 256;
        if (v19 == 8)
          goto LABEL_46;
      }
      if ((v19 & 0x80) != 0 || (unint64_t)v3 < v5 && (*v3 - 13312) >> 10 < 0x29)
      {
LABEL_46:
        if ((unint64_t)v3 >= v5
          || *v3 != (unsigned __int16)i
          || (v35 = v9, result = sub_18BC2D6AC(v20, &v87), v9 = v35, (result & 0x80000000) != 0))
        {
          v8 = 0;
          i = v18 | (i << 16);
          v32 = 4;
          goto LABEL_99;
        }
        v36 = result;
        v37 = *(char *)(v4 + 75);
        v38 = *(char *)(v4 + v37 + 76);
        LOBYTE(v86) = *(_BYTE *)(v4 + v37 + 76);
        if ((v37 + 1) == 8)
          v39 = 0;
        else
          v39 = v37 + 1;
        *(_BYTE *)(v4 + 75) = v39;
        v40 = v87;
        *(_DWORD *)(v4 + 4 * v38 + 32) = v87;
        result = sub_18BC2D634(v4, v38);
        v9 = v40;
        i = ((v36 << 8) + 268304384) | (v38 << 21) | (v20 - v40) | 0xF1000080;
        v32 = 4;
      }
      else
      {
        v43 = *(unsigned int *)(v4 + 4 * v19 + 32);
        LOBYTE(v86) = v19;
        result = sub_18BC2D634(v4, v19);
        v9 = v43;
        i = v21 | (v20 - v43);
        v32 = 2;
      }
      v8 = 1;
      goto LABEL_99;
    }
  }
  else if ((unint64_t)v3 < v5)
  {
    if (v7 < 1)
    {
      LOBYTE(v8) = 0;
      goto LABEL_157;
    }
    v33 = 0;
    while (1)
    {
      i = v3[v33 / 2];
      if ((i - 13312) >> 10 > 0x28)
        break;
      if (v7 < 2)
      {
        LOBYTE(v8) = 0;
        v3 = (unsigned __int16 *)((char *)v3 + v33 + 2);
        v6 += v33;
        v7 = 1;
        v32 = 2;
        goto LABEL_143;
      }
      v34 = &v6[v33];
      *v34 = BYTE1(i);
      v34[1] = i;
      if ((unint64_t)&v3[v33 / 2 + 1] >= v5)
      {
        LOBYTE(v8) = 0;
        i = 0;
        v3 = (unsigned __int16 *)((char *)v3 + v33 + 2);
        v6 = v34 + 2;
        goto LABEL_162;
      }
      v33 += 2;
      v11 = v7 < 3;
      v7 -= 2;
      if (v11)
      {
        LOBYTE(v8) = 0;
        i = 0;
        v3 = (unsigned __int16 *)((char *)v3 + v33);
        v6 += v33;
LABEL_157:
        v81 = 15;
        goto LABEL_165;
      }
    }
    v41 = &v3[v33 / 2 + 1];
    v42 = &v6[v33];
    if ((i - 13312) >> 8 < 0xBF)
    {
      if (i >> 13 <= 6)
      {
        if ((i & 0x400) != 0)
        {
          LOBYTE(v8) = 0;
          v3 = (unsigned __int16 *)((char *)v3 + v33 + 2);
          v6 += v33;
          goto LABEL_164;
        }
        v3 = (unsigned __int16 *)((char *)v3 + v33 + 2);
        v6 += v33;
        goto LABEL_19;
      }
      v8 = 0;
      i |= 0xF00000u;
      v32 = 3;
    }
    else if ((unint64_t)v41 >= v5 || (*v41 - 13312) >> 10 >= 0x29)
    {
      if (i - 48 >= 0xA && i - 97 >= 0x1A && i - 65 >= 0x1A)
      {
        v46 = 0;
        v47 = 57472;
        while (i - *(_DWORD *)(v4 + 4 * v46 + 32) >= 0x80)
        {
          ++v46;
          v47 += 256;
          if (v46 == 8)
            goto LABEL_80;
        }
        if ((v46 & 0x80) != 0)
        {
LABEL_80:
          v49 = v9;
          result = sub_18BC2D6AC(i, &v87);
          if ((result & 0x80000000) != 0)
          {
            v8 = 0;
            v32 = 2;
            v3 = v41;
            v6 = v42;
            v9 = v49;
          }
          else
          {
            v50 = result;
            v51 = *(char *)(v4 + 75);
            v52 = *(_BYTE *)(v4 + v51 + 76);
            v53 = v52;
            if ((v51 + 1) == 8)
              v54 = 0;
            else
              v54 = v51 + 1;
            *(_BYTE *)(v4 + 75) = v54;
            v55 = v87;
            *(_DWORD *)(v4 + 4 * v52 + 32) = v87;
            result = sub_18BC2D634(v4, v52);
            v9 = v55;
            LOBYTE(v86) = v53;
            i = ((v53 << 16) + 15204352) | (v50 << 8) | (i - v55) | 0x80;
            v32 = 3;
            v8 = 1;
            v3 = v41;
            v6 = v42;
          }
          goto LABEL_99;
        }
        v48 = *(unsigned int *)(v4 + 4 * v46 + 32);
        LOBYTE(v86) = v46;
        result = sub_18BC2D634(v4, v46);
        v9 = v48;
        i = v47 | (i - v48);
      }
      else
      {
        i |= (v86 << 8) + 57344;
      }
      v32 = 2;
      v8 = 1;
    }
    else
    {
      v8 = 0;
      v32 = 2;
    }
    v3 = v41;
    v6 = v42;
    goto LABEL_99;
  }
  LOBYTE(v8) = 0;
LABEL_162:
  v79 = v84;
  v75 = v85;
LABEL_168:
  *(_BYTE *)(v4 + 72) = v8;
  *(_BYTE *)(v4 + 73) = v86;
  *((_DWORD *)v75 + 21) = i;
  *(_QWORD *)(v79 + 16) = v3;
  *(_QWORD *)(v79 + 32) = v6;
  return result;
}

uint64_t sub_18BC2C9FC(uint64_t result, int *a2)
{
  int v2;
  uint64_t v3;
  unsigned __int16 *v4;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  int v8;
  int *v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  BOOL v14;
  char v15;
  int v16;
  int v17;
  int v18;
  char v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int16 *v29;
  int *v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  unsigned __int8 v37;
  int v38;
  char v39;
  uint64_t v40;
  unint64_t v41;
  int v42;
  _BYTE *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  char v48;
  uint64_t v49;
  unsigned __int16 *v50;
  _BYTE *v51;
  uint64_t v52;
  unsigned __int16 *v53;
  int v54;
  uint64_t v57;
  int v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  unsigned __int8 v62;
  char v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  int v67;
  char v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  int v72;
  uint64_t v73;
  unsigned __int16 *v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  unsigned __int8 v78;
  int v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int16 *v83;
  int v84;
  _BYTE *v85;
  unsigned int v86;
  _BYTE *v87;
  _QWORD *v88;
  int *v89;
  int v90;
  _BYTE *v91;
  unsigned int v92;
  unsigned int v93;
  int v94;
  int v95;
  int v96;
  _QWORD *v98;
  unsigned __int16 *v99;
  unsigned __int16 *v100;
  unsigned int v101;
  unsigned int v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  unsigned int v106;

  v98 = (_QWORD *)result;
  v2 = 0;
  v106 = 0;
  v3 = *(_QWORD *)(result + 8);
  v4 = *(unsigned __int16 **)(result + 16);
  v5 = *(_QWORD *)(v3 + 16);
  v6 = *(_QWORD *)(result + 24);
  v7 = *(_BYTE **)(result + 32);
  v8 = *(_DWORD *)(result + 40) - (_DWORD)v7;
  v9 = *(int **)(result + 48);
  v10 = *(unsigned __int8 *)(v5 + 72);
  v104 = v6;
  v105 = *(unsigned __int8 *)(v5 + 73);
  v103 = v3;
  v11 = *(_DWORD *)(v3 + 84);
  if (v11)
    v12 = -1;
  else
    v12 = 0;
  v13 = *(unsigned int *)(v5 + 4 * v105 + 32);
  while (1)
  {
    if (v11)
      v14 = v8 <= 0;
    else
      v14 = 1;
    v15 = !v14;
    if (!(_DWORD)v10)
    {
      if ((v15 & 1) != 0)
      {
        v16 = v12;
LABEL_24:
        if ((unint64_t)v4 < v6)
        {
          v22 = *v4;
          if ((v22 & 0xFC00) == 0xDC00)
          {
            v23 = 0;
            ++v4;
            v12 = v2 + 1;
            v24 = v22 + (v11 << 10) - 56613888;
            v25 = 57472;
            while (v24 - *(_DWORD *)(v5 + 4 * v23 + 32) >= 0x80)
            {
              ++v23;
              v25 += 256;
              if (v23 == 8)
                goto LABEL_54;
            }
            if ((v23 & 0x80) != 0 || (unint64_t)v4 < v6 && (*v4 - 13312) >> 10 < 0x29)
            {
LABEL_54:
              if ((unint64_t)v4 >= v6)
                goto LABEL_61;
              if (*v4 != (unsigned __int16)v11)
                goto LABEL_61;
              v44 = v13;
              v100 = v4;
              v95 = v16;
              result = sub_18BC2D6AC(v24, &v106);
              v16 = v95;
              v4 = v100;
              v13 = v44;
              v6 = v104;
              if ((result & 0x80000000) != 0)
              {
LABEL_61:
                v10 = 0;
                v11 = v22 | (v11 << 16);
                v33 = 4;
                goto LABEL_96;
              }
              v45 = result;
              v46 = *(char *)(v5 + 75);
              v47 = *(char *)(v5 + v46 + 76);
              LOBYTE(v105) = *(_BYTE *)(v5 + v46 + 76);
              if ((v46 + 1) == 8)
                v48 = 0;
              else
                v48 = v46 + 1;
              *(_BYTE *)(v5 + 75) = v48;
              v49 = v106;
              *(_DWORD *)(v5 + 4 * v47 + 32) = v106;
              result = sub_18BC2D634(v5, v47);
              v16 = v95;
              v4 = v100;
              v13 = v49;
              v6 = v104;
              v11 = ((v45 << 8) + 268304384) | (v47 << 21) | (v24 - v49) | 0xF1000080;
              v33 = 4;
            }
            else
            {
              v52 = *(unsigned int *)(v5 + 4 * v23 + 32);
              LOBYTE(v105) = v23;
              v53 = v4;
              v54 = v16;
              result = sub_18BC2D634(v5, v23);
              v16 = v54;
              v4 = v53;
              v13 = v52;
              v6 = v104;
              v11 = v25 | (v24 - v52);
              v33 = 2;
            }
            v10 = 1;
            goto LABEL_96;
          }
          LOBYTE(v10) = 0;
          goto LABEL_185;
        }
LABEL_179:
        LOBYTE(v10) = 0;
LABEL_180:
        v88 = v98;
        goto LABEL_188;
      }
      if ((unint64_t)v4 >= v6)
        goto LABEL_179;
      if (v8 < 1)
      {
        LOBYTE(v10) = 0;
        goto LABEL_175;
      }
      v41 = 0;
      v42 = v2 + 1;
      while (1)
      {
        v11 = v4[v41 / 2];
        if ((v11 - 13312) >> 10 > 0x28)
          break;
        if (v8 < 2)
        {
          LOBYTE(v10) = 0;
          v4 = (unsigned __int16 *)((char *)v4 + v41 + 2);
          v7 += v41;
          v8 = 1;
          v33 = 2;
          goto LABEL_162;
        }
        v43 = &v7[v41];
        *v43 = BYTE1(v11);
        v43[1] = v11;
        if (v9)
        {
          *v9 = v12;
          v9[1] = v12;
          v9 += 2;
        }
        if ((unint64_t)&v4[v41 / 2 + 1] >= v6)
        {
          LOBYTE(v10) = 0;
          v11 = 0;
          v4 = (unsigned __int16 *)((char *)v4 + v41 + 2);
          v7 += v41 + 2;
          goto LABEL_180;
        }
        v41 += 2;
        ++v42;
        v12 = ++v2;
        v14 = v8 < 3;
        v8 -= 2;
        if (v14)
        {
          LOBYTE(v10) = 0;
          v11 = 0;
          v4 = (unsigned __int16 *)((char *)v4 + v41);
          v7 += v41;
          goto LABEL_175;
        }
      }
      v50 = &v4[v41 / 2 + 1];
      v51 = &v7[v41];
      if ((v11 - 13312) >> 8 < 0xBF)
      {
        if (v11 >> 13 <= 6)
        {
          if ((v11 & 0x400) != 0)
          {
            LOBYTE(v10) = 0;
            v4 = (unsigned __int16 *)((char *)v4 + v41 + 2);
            v7 += v41;
            goto LABEL_185;
          }
          v4 = (unsigned __int16 *)((char *)v4 + v41 + 2);
          v7 += v41;
          v16 = v12;
          v2 = v42;
          goto LABEL_24;
        }
        v10 = 0;
        v11 |= 0xF00000u;
        v33 = 3;
LABEL_95:
        v4 = v50;
        v7 = v51;
        v16 = v12;
        v12 = v42;
        goto LABEL_96;
      }
      if ((unint64_t)v50 < v6 && (*v50 - 13312) >> 10 < 0x29)
      {
        v10 = 0;
        v33 = 2;
        goto LABEL_95;
      }
      if (v11 - 48 >= 0xA && v11 - 97 >= 0x1A && v11 - 65 >= 0x1A)
      {
        v57 = 0;
        v58 = 57472;
        while (v11 - *(_DWORD *)(v5 + 4 * v57 + 32) >= 0x80)
        {
          ++v57;
          v58 += 256;
          if (v57 == 8)
            goto LABEL_89;
        }
        if ((v57 & 0x80) != 0)
        {
LABEL_89:
          v101 = v13;
          result = sub_18BC2D6AC(v11, &v106);
          if ((result & 0x80000000) != 0)
          {
            v10 = 0;
            v33 = 2;
            v4 = v50;
            v7 = v51;
            v16 = v12;
            v12 = v42;
            v6 = v104;
            v13 = v101;
            goto LABEL_96;
          }
          v60 = result;
          v61 = *(char *)(v5 + 75);
          v62 = *(_BYTE *)(v5 + v61 + 76);
          LODWORD(v105) = v62;
          if ((v61 + 1) == 8)
            v63 = 0;
          else
            v63 = v61 + 1;
          *(_BYTE *)(v5 + 75) = v63;
          v64 = v106;
          *(_DWORD *)(v5 + 4 * v62 + 32) = v106;
          result = sub_18BC2D634(v5, v62);
          v13 = v64;
          v6 = v104;
          v11 = (((_DWORD)v105 << 16) + 15204352) | (v60 << 8) | (v11 - v64) | 0x80;
          v33 = 3;
          goto LABEL_94;
        }
        v59 = *(unsigned int *)(v5 + 4 * v57 + 32);
        LOBYTE(v105) = v57;
        result = sub_18BC2D634(v5, v57);
        v13 = v59;
        v6 = v104;
        v11 = v58 | (v11 - v59);
      }
      else
      {
        v11 |= (v105 << 8) + 57344;
      }
      v33 = 2;
LABEL_94:
      v10 = 1;
      goto LABEL_95;
    }
    v16 = v12;
    if ((v15 & 1) != 0)
      goto LABEL_13;
    while (1)
    {
      if ((unint64_t)v4 >= v6)
        goto LABEL_180;
      if (v8 < 1)
        goto LABEL_175;
      v65 = *v4++;
      v11 = v65;
      v12 = v2 + 1;
      if (v65 - 32 > 0x5F)
        break;
LABEL_115:
      *v7 = v11;
      if (v9)
        goto LABEL_17;
LABEL_116:
      result = 0;
LABEL_117:
      v11 = 0;
      ++v7;
      --v8;
      v9 = (int *)result;
      v16 = v12;
      v2 = v12;
    }
    if (v11 > 0x1F)
    {
      v19 = v11 - v13;
      if (v11 - v13 <= 0x7F)
      {
LABEL_16:
        *v7 = v19 | 0x80;
        if (!v9)
          goto LABEL_116;
LABEL_17:
        *v9 = v16;
        result = (uint64_t)(v9 + 1);
        goto LABEL_117;
      }
      if ((v11 & 0xF800) != 0xD800)
      {
        if (v11 <= 0x9F)
        {
          v33 = 2;
          v11 = v11 & 0x7F | 0x200;
          goto LABEL_96;
        }
        if (v11 == 65279 || v11 >> 4 > 0xFFE)
        {
          v11 |= 0xE0000u;
          v33 = 3;
          goto LABEL_96;
        }
        v66 = 0;
        v67 = 4224;
        while (v11 - *(_DWORD *)(v5 + 4 * v66 + 32) >= 0x80)
        {
          ++v66;
          v67 += 256;
          if (v66 == 8)
            goto LABEL_137;
        }
        if ((v66 & 0x80) == 0)
        {
          v68 = v66;
          if ((unint64_t)v4 >= v6
            || (v69 = *(_DWORD *)(v5 + 4 * v66 + 32), v70 = *v4, v69 + 127 >= v70)
            && (v69 <= v70 || v70 <= 0x7F && (v70 > 0x1F || ((1 << v70) & 0x2601) != 0)))
          {
            v102 = *(_DWORD *)(v5 + 4 * v66 + 32);
            v82 = v10;
            v83 = v4;
            v96 = v16;
            result = sub_18BC2D634(v5, v66);
            v16 = v96;
            v4 = v83;
            v13 = v102;
            v10 = v82;
            v6 = v104;
            v11 = v67 | (v11 - v102);
            v33 = 2;
            LOBYTE(v105) = v68;
            goto LABEL_96;
          }
          v71 = v11 - v69;
          v72 = ((char)v66 << 8) + 384;
LABEL_143:
          v11 = v72 | v71;
          goto LABEL_123;
        }
LABEL_137:
        v73 = 0;
        v71 = 256;
        while (v11 - dword_18BE1492C[v73] >= 0x80)
        {
          ++v73;
          v71 += 256;
          if (v73 == 8)
            goto LABEL_144;
        }
        if ((v73 & 0x80) == 0)
        {
          v72 = v11 - dword_18BE1492C[v73];
          goto LABEL_143;
        }
LABEL_144:
        v93 = v10;
        v94 = v16;
        v74 = v4;
        v75 = v13;
        result = sub_18BC2D6AC(v11, &v106);
        if ((result & 0x80000000) == 0)
        {
          v76 = result;
          v77 = *(char *)(v5 + 75);
          v78 = *(_BYTE *)(v5 + v77 + 76);
          v79 = v78;
          if ((v77 + 1) == 8)
            v80 = 0;
          else
            v80 = v77 + 1;
          *(_BYTE *)(v5 + 75) = v80;
          v81 = v106;
          *(_DWORD *)(v5 + 4 * v78 + 32) = v106;
          result = sub_18BC2D634(v5, v78);
          v13 = v81;
          LOBYTE(v105) = v79;
          v11 = ((v79 << 16) + 1572864) | (v76 << 8) | (v11 - v81) | 0x80;
          v33 = 3;
          v6 = v104;
          v10 = v93;
          v16 = v94;
          v4 = v74;
          goto LABEL_96;
        }
        v6 = v104;
        v13 = v75;
        v4 = v74;
        if ((v11 - 13312) >> 10 > 0x28 || (unint64_t)v74 < v104 && (*v74 - 13312) >> 10 > 0x28)
        {
          v11 |= 0xE0000u;
          v33 = 3;
          v10 = v93;
        }
        else
        {
          v10 = 0;
          v11 |= 0xF0000u;
          v33 = 3;
        }
        goto LABEL_37;
      }
      if ((v11 & 0x400) == 0)
      {
        v2 = v12;
LABEL_13:
        v92 = v10;
        v94 = v16;
        v91 = v7;
        if ((unint64_t)v4 >= v6)
          goto LABEL_180;
        v17 = *v4;
        if ((v17 & 0xFC00) == 0xDC00)
        {
          ++v4;
          v12 = v2 + 1;
          v18 = (v11 << 10) - 56613888 + v17;
          v19 = v17 - v13;
          if ((v18 - v13) < 0x80)
            goto LABEL_16;
          v20 = 0;
          v21 = 4224;
          while ((v18 - *(_DWORD *)(v5 + 4 * v20 + 32)) >= 0x80)
          {
            ++v20;
            v21 += 256;
            if (v20 == 8)
              goto LABEL_32;
          }
          if ((v20 & 0x80) == 0)
          {
            v26 = *(unsigned int *)(v5 + 4 * v20 + 32);
            v27 = v5;
            LOBYTE(v105) = v20;
            v28 = v10;
            v29 = v4;
            v30 = v9;
            v31 = v5;
            v32 = v16;
            result = sub_18BC2D634(v27, v20);
            v16 = v32;
            v5 = v31;
            v9 = v30;
            v4 = v29;
            v13 = v26;
            v7 = v91;
            v10 = v28;
            v6 = v104;
            v11 = v21 | (v18 - v13);
            v33 = 2;
            goto LABEL_96;
          }
LABEL_32:
          v34 = v13;
          v99 = v4;
          result = sub_18BC2D6AC((v11 << 10) - 56613888 + v17, &v106);
          if ((result & 0x80000000) != 0)
          {
            *v7++ = 15;
            if (v9)
            {
              v16 = v94;
              *v9++ = v94;
              v6 = v104;
              v4 = v99;
              v13 = v34;
            }
            else
            {
              v6 = v104;
              v4 = v99;
              v13 = v34;
              v16 = v94;
            }
            v10 = 0;
            --v8;
            v33 = 4;
            v11 = v17 | (v11 << 16);
            goto LABEL_96;
          }
          v35 = result;
          v36 = *(char *)(v5 + 75);
          v37 = *(_BYTE *)(v5 + v36 + 76);
          v38 = v37;
          if ((v36 + 1) == 8)
            v39 = 0;
          else
            v39 = v36 + 1;
          *(_BYTE *)(v5 + 75) = v39;
          v40 = v106;
          *(_DWORD *)(v5 + 4 * v37 + 32) = v106;
          result = sub_18BC2D634(v5, v37);
          v13 = v40;
          LOBYTE(v105) = v38;
          v11 = ((v35 << 8) - 0x20000) | (v38 << 21) | (v18 - v40) | 0xB000080;
          v33 = 4;
          v6 = v104;
          v10 = v92;
          v4 = v99;
LABEL_37:
          v16 = v94;
          goto LABEL_96;
        }
      }
LABEL_185:
      v90 = 12;
      goto LABEL_186;
    }
    if (((1 << v11) & 0x2601) != 0)
      goto LABEL_115;
    v11 |= 0x100u;
LABEL_123:
    v33 = 2;
LABEL_96:
    if (v8 < v33)
      break;
    if (v9)
    {
      if (v33 != 2)
      {
        if (v33 != 3)
        {
          *v7++ = HIBYTE(v11);
          *v9++ = v16;
        }
        *v7++ = BYTE2(v11);
        *v9++ = v16;
      }
      *v7 = BYTE1(v11);
      *v9 = v16;
      v7[1] = v11;
      v7 += 2;
      v9[1] = v16;
      v9 += 2;
    }
    else
    {
      if (v33 != 2)
      {
        if (v33 != 3)
          *v7++ = HIBYTE(v11);
        *v7++ = BYTE2(v11);
      }
      v9 = 0;
      *(_WORD *)v7 = bswap32(v11) >> 16;
      v7 += 2;
    }
    v11 = 0;
    v8 -= v33;
    v2 = v12;
  }
  v12 = v16;
LABEL_162:
  v84 = v33 - v8;
  v85 = (_BYTE *)(v103 + 104);
  switch(v84)
  {
    case 1:
      goto LABEL_166;
    case 2:
      goto LABEL_165;
    case 3:
      goto LABEL_164;
    case 4:
      v85 = (_BYTE *)(v103 + 105);
      *(_BYTE *)(v103 + 104) = HIBYTE(v11);
LABEL_164:
      *v85++ = BYTE2(v11);
LABEL_165:
      *v85++ = BYTE1(v11);
LABEL_166:
      *v85 = v11;
      break;
    default:
      break;
  }
  *(_BYTE *)(v103 + 91) = v84;
  v86 = v11 >> (8 * v84);
  if (v8 == 1)
  {
    *v7++ = v86;
    if (!v9)
      goto LABEL_174;
    v89 = a2;
    v88 = v98;
LABEL_178:
    v11 = 0;
    *v9++ = v12;
    goto LABEL_183;
  }
  if (v8 == 2)
  {
    *v7 = BYTE1(v86);
    v87 = v7 + 1;
    v89 = a2;
    v88 = v98;
    if (!v9)
      goto LABEL_182;
LABEL_177:
    *v9++ = v12;
    *v87 = v86;
    v7 = v87 + 1;
    goto LABEL_178;
  }
  if (v8 != 3)
  {
LABEL_174:
    v11 = 0;
LABEL_175:
    v90 = 15;
LABEL_186:
    v89 = a2;
    v88 = v98;
    goto LABEL_187;
  }
  *v7 = BYTE2(v86);
  if (v9)
  {
    *v9++ = v12;
    v7[1] = BYTE1(v86);
    v87 = v7 + 2;
    v89 = a2;
    v88 = v98;
    goto LABEL_177;
  }
  v7[1] = BYTE1(v86);
  v87 = v7 + 2;
  v89 = a2;
  v88 = v98;
LABEL_182:
  v9 = 0;
  v11 = 0;
  *v87 = v86;
  v7 = v87 + 1;
LABEL_183:
  v90 = 15;
LABEL_187:
  *v89 = v90;
LABEL_188:
  *(_BYTE *)(v5 + 72) = v10;
  *(_BYTE *)(v5 + 73) = v105;
  *(_DWORD *)(v103 + 84) = v11;
  v88[2] = v4;
  v88[4] = v7;
  v88[6] = v9;
  return result;
}

const char *sub_18BC2D5A8(uint64_t a1)
{
  if (*(_BYTE *)(*(_QWORD *)(a1 + 16) + 74) == 1)
    return "SCSU,locale=ja";
  else
    return "SCSU";
}

uint64_t sub_18BC2D5CC(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  if (*a4 > 0)
    return 0;
  if (*a3)
  {
    v4 = *(_QWORD *)(a1 + 16);
    v5 = *(_OWORD *)(v4 + 16);
    *(_OWORD *)(a2 + 288) = *(_OWORD *)v4;
    *(_OWORD *)(a2 + 304) = v5;
    v6 = *(_OWORD *)(v4 + 32);
    v7 = *(_OWORD *)(v4 + 48);
    v8 = *(_OWORD *)(v4 + 64);
    *(_DWORD *)(a2 + 368) = *(_DWORD *)(v4 + 80);
    *(_OWORD *)(a2 + 336) = v7;
    *(_OWORD *)(a2 + 352) = v8;
    *(_OWORD *)(a2 + 320) = v6;
    *(_QWORD *)(a2 + 16) = a2 + 288;
    *(_BYTE *)(a2 + 62) = 1;
  }
  else
  {
    a2 = 0;
    *a3 = 376;
  }
  return a2;
}

uint64_t sub_18BC2D634(uint64_t result, unsigned __int8 a2)
{
  int v2;
  BOOL v3;
  int v4;
  int v5;

  v2 = *(char *)(result + 75);
  do
  {
    v3 = __OFSUB__(v2--, 1);
    if (v2 < 0 != v3)
      v2 = 7;
  }
  while (*(unsigned __int8 *)(result + v2 + 76) != a2);
  if (v2 == 7)
    v4 = 0;
  else
    v4 = v2 + 1;
  while (v4 != *(char *)(result + 75))
  {
    v5 = v2;
    v2 = v4;
    *(_BYTE *)(result + 76 + v5) = *(_BYTE *)(result + 76 + v4);
    if (v4 == 7)
      v4 = 0;
    else
      ++v4;
  }
  *(_BYTE *)(result + v2 + 76) = a2;
  return result;
}

uint64_t sub_18BC2D6AC(unsigned int a1, unsigned int *a2)
{
  uint64_t i;
  unsigned int v3;
  uint64_t v4;

  for (i = 0; i != 7; ++i)
  {
    v3 = dword_18BE1494C[i];
    if (a1 - v3 <= 0x7F)
    {
      *a2 = v3;
      return (i + 249);
    }
  }
  if (a1 < 0x80)
    return 0xFFFFFFFFLL;
  if (a1 - 118784 < 0x3000 || a1 >> 10 < 0xD || (a1 & 0xFFFFC000) == 0x10000)
  {
    *a2 = a1 & 0x7FFFFF80;
    return a1 >> 7;
  }
  else
  {
    v4 = 0xFFFFFFFFLL;
    if (a1 != 65279 && (a1 - 57344) >> 4 <= 0x1FE)
    {
      *a2 = a1 & 0x7FFFFF80;
      return (a1 - 44032) >> 7;
    }
  }
  return v4;
}

uint64_t ucnvsel_open(uint64_t a1, int a2, icu::UnicodeSet *a3, unsigned int a4, int *a5)
{
  uint64_t v5;
  int v7;
  uint64_t v10;
  int v11;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  int v16;
  const char *AvailableName;
  int v18;
  int v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  const char *v25;
  int v26;
  int v27;
  void **v28;
  int v29;
  int v30;

  if (*a5 > 0)
    return 0;
  v7 = a2;
  if (a2 < 0 || (v10 = a1) == 0 && a2)
  {
    v5 = 0;
    v11 = 1;
LABEL_7:
    *a5 = v11;
    return v5;
  }
  v13 = uprv_malloc(0x38uLL);
  v5 = (uint64_t)v13;
  if (!v13)
  {
    v11 = 7;
    goto LABEL_7;
  }
  v13[6] = 0;
  *((_OWORD *)v13 + 1) = 0u;
  *((_OWORD *)v13 + 2) = 0u;
  *(_OWORD *)v13 = 0u;
  if (!v7)
  {
    v7 = ucnv_countAvailable();
    v10 = 0;
  }
  v14 = uprv_malloc(8 * v7);
  *(_QWORD *)(v5 + 24) = v14;
  if (!v14)
    goto LABEL_41;
  *v14 = 0;
  if (v7 < 1)
  {
    v16 = 0;
  }
  else
  {
    v15 = 0;
    v16 = 0;
    do
    {
      if (v10)
        AvailableName = *(const char **)(v10 + 8 * v15);
      else
        AvailableName = (const char *)ucnv_getAvailableName(v15);
      v16 += strlen(AvailableName) + 1;
      ++v15;
    }
    while (v7 != v15);
  }
  v30 = v16 & 3;
  v18 = (v16 & 3) != 0 ? 4 - (v16 & 3) : 0;
  v19 = v18 + v16;
  *(_DWORD *)(v5 + 36) = v19;
  v20 = (char *)uprv_malloc(v19);
  if (!v20)
  {
LABEL_41:
    *a5 = 7;
LABEL_42:
    ucnvsel_close(v5);
    return 0;
  }
  v21 = v20;
  v29 = 4 - (v16 & 3);
  if (v7 >= 1)
  {
    v22 = 0;
    v23 = *(_QWORD *)(v5 + 24);
    do
    {
      *(_QWORD *)(v23 + 8 * v22) = v21;
      v24 = *(char **)(*(_QWORD *)(v5 + 24) + 8 * v22);
      if (v10)
        v25 = *(const char **)(v10 + 8 * v22);
      else
        v25 = (const char *)ucnv_getAvailableName(v22);
      strcpy(v24, v25);
      v23 = *(_QWORD *)(v5 + 24);
      v21 += strlen(*(const char **)(v23 + 8 * v22++)) + 1;
    }
    while (v7 != v22);
  }
  if (v30)
  {
    if (v29 >= 1)
      v26 = 1;
    else
      v26 = v29;
    bzero(v21, (v29 - v26) + 1);
  }
  *(_BYTE *)(v5 + 49) = 1;
  *(_DWORD *)(v5 + 32) = v7;
  v27 = v7 + 31;
  if (v7 < -31)
    v27 = v7 + 62;
  v28 = (void **)upvec_open(v27 >> 5, a5);
  sub_18BC2D998(v5, (uint64_t)v28, a3, a4, a5);
  upvec_close(v28);
  if (*a5 >= 1)
    goto LABEL_42;
  return v5;
}

void sub_18BC2D998(uint64_t a1, uint64_t a2, icu::UnicodeSet *a3, unsigned int a4, int *a5)
{
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  _OWORD *v14;
  uint64_t *v15;
  _QWORD *v16;
  icu::UnicodeSet *v17;
  icu::UnicodeSet *v18;
  int v19;
  int v20;
  int j;
  int ItemCount;
  int v23;
  int v24;
  int v25;
  int i;
  int v27;
  int v28;
  uint64_t v29;
  int v31;
  uint64_t v32;

  if (*a5 <= 0)
  {
    v8 = a1;
    v9 = *(_DWORD *)(a1 + 32);
    v10 = v9 + 31;
    if (v9 < -31)
      v10 = v9 + 62;
    v27 = v10 >> 5;
    if (v9 < 1)
      goto LABEL_20;
    v11 = 0;
    v12 = v27 <= 1 ? 1 : v10 >> 5;
    do
      upvec_setValue(a2, 1114113, 1114113, v11++, -1, -1, a5);
    while (v12 != v11);
    if (*(int *)(v8 + 32) < 1)
    {
LABEL_20:
      if (a3)
      {
        ItemCount = uset_getItemCount(a3);
        if (ItemCount >= 1)
        {
          v23 = ItemCount;
          v24 = 0;
          if (v27 <= 1)
            v25 = 1;
          else
            v25 = v27;
          do
          {
            v32 = 0;
            uset_getItem(a3, v24, (_DWORD *)&v32 + 1, &v32, 0, 0, a5);
            if (v9 >= 1)
            {
              for (i = 0; i != v25; ++i)
                upvec_setValue(a2, SHIDWORD(v32), v32, i, -1, -1, a5);
            }
            ++v24;
          }
          while (v24 != v23);
        }
      }
      *(_QWORD *)v8 = upvec_compactToUTrie2WithRowIndexes(a2, a5);
      *(_QWORD *)(v8 + 8) = upvec_cloneArray(a2, (_DWORD *)(v8 + 16), 0, a5);
      *(_DWORD *)(v8 + 16) *= v27;
      *(_BYTE *)(v8 + 48) = 1;
    }
    else
    {
      v13 = 0;
      v29 = v8;
      v28 = v9;
      while (1)
      {
        v14 = ucnv_open(*(unsigned __int8 **)(*(_QWORD *)(v8 + 24) + 8 * v13), (UErrorCode *)a5);
        v15 = (uint64_t *)*a5;
        if ((int)v15 > 0)
          break;
        v16 = v14;
        v17 = uset_open(1u, 0, v15);
        ucnv_getUnicodeSet((uint64_t)v16, (uint64_t)v17, a4, a5);
        if (*a5 >= 1)
        {
          ucnv_close(v16);
          return;
        }
        v18 = a3;
        v19 = uset_getItemCount(v17);
        if (v19 >= 1)
        {
          v20 = v19;
          for (j = 0; j != v20; ++j)
          {
            v32 = 0;
            v31 = 0;
            uset_getItem(v17, j, (_DWORD *)&v32 + 1, &v32, 0, 0, &v31);
            if (v31 <= 0)
              upvec_setValue(a2, SHIDWORD(v32), v32, v13 >> 5, -1, 1 << v13, a5);
          }
        }
        ucnv_close(v16);
        uset_close(v17);
        a3 = v18;
        v8 = v29;
        v9 = v28;
        if (*a5 >= 1)
          return;
        if (++v13 >= *(int *)(v29 + 32))
          goto LABEL_20;
      }
    }
  }
}

void ucnvsel_close(uint64_t a1)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 49))
      uprv_free(**(void ***)(a1 + 24));
    uprv_free(*(void **)(a1 + 24));
    if (*(_BYTE *)(a1 + 48))
      uprv_free(*(void **)(a1 + 8));
    utrie2_close(*(void ***)a1);
    uprv_free(*(void **)(a1 + 40));
    uprv_free((void *)a1);
  }
}

uint64_t ucnvsel_serialize(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  uint64_t v4;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v15;
  char *v16;
  char *v17;
  uint64_t v18;

  if (*a4 > 0)
    return 0;
  if (a3 < 0 || a3 && (!a2 || (a2 & 3) != 0))
  {
    v4 = 0;
    v13 = 1;
LABEL_12:
    *a4 = v13;
    return v4;
  }
  v9 = utrie2_serialize(*(_QWORD *)a1, 0, 0, a4);
  v10 = v9;
  if (*a4 == 15 || (v4 = 0, *a4 <= 0))
  {
    *a4 = 0;
    v11 = *(_DWORD *)(a1 + 16);
    v12 = *(_DWORD *)(a1 + 36);
    v4 = (v9 + 4 * v11 + v12 + 96);
    if ((int)v4 <= a3)
    {
      v15 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)a2 = 668598304;
      *(_DWORD *)(a2 + 20) = 0;
      *(_OWORD *)(a2 + 4) = xmmword_18BE14968;
      *(_QWORD *)(a2 + 24) = 0;
      *(_DWORD *)(a2 + 32) = v9;
      *(_DWORD *)(a2 + 36) = v11;
      *(_DWORD *)(a2 + 40) = v15;
      *(_DWORD *)(a2 + 44) = v12;
      *(_OWORD *)(a2 + 48) = 0u;
      *(_OWORD *)(a2 + 64) = 0u;
      *(_OWORD *)(a2 + 76) = 0u;
      *(_DWORD *)(a2 + 92) = v9 + 4 * v11 + v12 + 64;
      v16 = (char *)(a2 + 96);
      utrie2_serialize(*(_QWORD *)a1, v16, v9, a4);
      v17 = &v16[v10];
      v18 = *(int *)(a1 + 16);
      memcpy(v17, *(const void **)(a1 + 8), 4 * v18);
      memcpy(&v17[4 * v18], **(const void ***)(a1 + 24), *(int *)(a1 + 36));
      return v4;
    }
    v13 = 15;
    goto LABEL_12;
  }
  return v4;
}

_OWORD *ucnvsel_openFromSerialized(unsigned __int16 *a1, uint64_t a2, int *a3)
{
  _OWORD *v3;
  unsigned __int16 *v5;
  int v7;
  _OWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned __int16 *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int16 *v19;
  int v20;
  int *v21;
  void *v22;
  void *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  unsigned __int16 *v30;

  if (*a3 > 0)
    return 0;
  v5 = a1;
  if (!a1 || (int)a2 < 1 || (a1 & 3) != 0)
  {
    v3 = 0;
    v7 = 1;
    goto LABEL_21;
  }
  if (a2 <= 0x1F)
  {
LABEL_7:
    v3 = 0;
    v7 = 8;
LABEL_21:
    *a3 = v7;
    return v3;
  }
  if (*((unsigned __int8 *)a1 + 2) != 218
    || *((_BYTE *)a1 + 3) != 39
    || *((_BYTE *)a1 + 12) != 67
    || *((_BYTE *)a1 + 13) != 83
    || *((_BYTE *)a1 + 14) != 101
    || *((_BYTE *)a1 + 15) != 108)
  {
    v3 = 0;
    v7 = 3;
    goto LABEL_21;
  }
  if (*((_BYTE *)a1 + 16) != 1)
  {
    v3 = 0;
    v7 = 16;
    goto LABEL_21;
  }
  if (*((_BYTE *)a1 + 8) || *((_BYTE *)a1 + 9))
  {
    v8 = udata_openSwapperForInputData(a1, a2, 0, 0, a3);
    v12 = sub_18BC2E0FC((uint64_t)v8, (uint64_t)v5, 0xFFFFFFFFLL, 0, a3, v9, v10, v11);
    if (*a3 >= 1)
    {
      udata_closeSwapper(v8);
      return 0;
    }
    if (v12 > (int)a2)
    {
      udata_closeSwapper(v8);
      goto LABEL_7;
    }
    v14 = (unsigned __int16 *)uprv_malloc(v12);
    if (!v14)
    {
      udata_closeSwapper(v8);
LABEL_40:
      v3 = 0;
      v7 = 7;
      goto LABEL_21;
    }
    v18 = (uint64_t)v5;
    v5 = v14;
    sub_18BC2E0FC((uint64_t)v8, v18, a2, v14, a3, v15, v16, v17);
    udata_closeSwapper(v8);
    if (*a3 >= 1)
    {
      uprv_free(v5);
      return 0;
    }
    v19 = v5;
  }
  else
  {
    v19 = 0;
  }
  v20 = *v5;
  if (v20 + 64 > a2 || (v30 = v19, v21 = (int *)((char *)v5 + *v5), (int)a2 - v20 < v21[15]))
  {
    uprv_free(v19);
    goto LABEL_7;
  }
  v3 = uprv_malloc(0x38uLL);
  v22 = uprv_malloc(8 * v21[2]);
  v23 = v22;
  if (!v3 || !v22)
  {
    uprv_free(v30);
    uprv_free(v3);
    uprv_free(v23);
    goto LABEL_40;
  }
  v3[1] = 0u;
  v3[2] = 0u;
  *v3 = 0u;
  v24 = *v21;
  *((_DWORD *)v3 + 4) = v21[1];
  *((_QWORD *)v3 + 3) = v22;
  *((_QWORD *)v3 + 4) = *((_QWORD *)v21 + 1);
  *((_QWORD *)v3 + 5) = v30;
  *((_QWORD *)v3 + 6) = 0;
  *(_QWORD *)v3 = utrie2_openFromSerialized(0, (uint64_t)(v21 + 16), v24, 0, a3);
  if (*a3 >= 1)
  {
    ucnvsel_close((uint64_t)v3);
    return 0;
  }
  v25 = (uint64_t)v21 + *v21 + 64;
  *((_QWORD *)v3 + 1) = v25;
  v26 = *((unsigned int *)v3 + 8);
  if ((int)v26 >= 1)
  {
    v27 = 0;
    v28 = (const char *)(v25 + 4 * *((int *)v3 + 4));
    v29 = 8 * v26;
    do
    {
      *(_QWORD *)(*((_QWORD *)v3 + 3) + v27) = v28;
      v28 += strlen(v28) + 1;
      v27 += 8;
    }
    while (v29 != v27);
  }
  return v3;
}

uint64_t sub_18BC2E0FC(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _OWORD v39[3];
  size_t __n[2];
  uint64_t v41;

  v10 = a3;
  v41 = *MEMORY[0x1E0C80C00];
  v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (*a5 > 0)
    return 0;
  v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x5300000043
    || *(_BYTE *)(a2 + 14) != 101
    || *(_BYTE *)(a2 + 15) != 108)
  {
    udata_printError(a1, (uint64_t)"ucnvsel_swap(): data format %02x.%02x.%02x.%02x is not recognized as UConverterSelector data\n", v14, v15, v16, v17, v18, v19, v21);
    result = 0;
    v24 = 3;
LABEL_11:
    *a5 = v24;
    return result;
  }
  if (*(_BYTE *)(a2 + 16) != 1)
  {
    udata_printError(a1, (uint64_t)"ucnvsel_swap(): format version %02x is not supported\n", v14, v15, v16, v17, v18, v19, *(unsigned __int8 *)(a2 + 16));
    result = 0;
    v24 = 16;
    goto LABEL_11;
  }
  v22 = v13;
  if (v10 < 0)
  {
    v23 = 0xFFFFFFFFLL;
  }
  else
  {
    v23 = (v10 - v13);
    if ((int)v23 <= 63)
    {
      udata_printError(a1, (uint64_t)"ucnvsel_swap(): too few bytes (%d after header) for UConverterSelector data\n", v14, v15, v16, v17, v18, v19, (v10 - v13));
LABEL_19:
      result = 0;
      v24 = 8;
      goto LABEL_11;
    }
  }
  v25 = 0;
  v26 = v13;
  *(_OWORD *)__n = 0u;
  v27 = a2 + v13;
  memset(v39, 0, sizeof(v39));
  do
  {
    *(_DWORD *)((char *)v39 + v25) = udata_readInt32(a1, *(unsigned int *)(v27 + v25));
    v25 += 4;
  }
  while (v25 != 64);
  v34 = HIDWORD(__n[1]);
  if ((v23 & 0x80000000) == 0)
  {
    if ((int)v23 < SHIDWORD(__n[1]))
    {
      udata_printError(a1, (uint64_t)"ucnvsel_swap(): too few bytes (%d after header) for all of UConverterSelector data\n", v28, v29, v30, v31, v32, v33, v23);
      goto LABEL_19;
    }
    v35 = (char *)a4 + v22;
    if ((unsigned __int16 *)a2 != a4)
      memcpy((char *)a4 + v26, (const void *)(a2 + v22), SHIDWORD(__n[1]));
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 56))(a1, a2 + v22, 64, (char *)a4 + v26, a5);
    v36 = SLODWORD(v39[0]);
    utrie2_swap(a1, (unsigned __int16 *)(v27 + 64), v39[0], (uint64_t)(v35 + 64), a5);
    v37 = v36 + 64;
    v38 = 4 * SDWORD1(v39[0]);
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 56))(a1, v27 + v37, v38, &v35[v37], a5);
    (*(void (**)(uint64_t, uint64_t, _QWORD, char *, int *))(a1 + 72))(a1, v27 + v38 + (int)v37, HIDWORD(v39[0]), &v35[v38 + (int)v37], a5);
  }
  return (v34 + v22);
}

_QWORD *ucnvsel_selectForString(uint64_t a1, unsigned __int16 *a2, int a3, int *a4)
{
  unsigned __int16 *v7;
  int v8;
  int v10;
  int v11;
  uint64_t v12;
  __int32 *v13;
  __int32 *v14;
  unsigned __int16 *v15;
  unsigned int v16;
  unsigned __int16 *v17;
  uint64_t *v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  unsigned __int16 *v25;
  int v26;
  int *v27;
  __int32 *v28;
  uint64_t v29;
  int v30;
  int v31;

  if (*a4 > 0)
    return 0;
  if (!a1 || (v7 = a2) == 0 && a3)
  {
    v8 = 1;
LABEL_6:
    *a4 = v8;
    return 0;
  }
  v10 = *(_DWORD *)(a1 + 32);
  v11 = v10 + 31;
  if (v10 < -31)
    v11 = v10 + 62;
  v12 = (v11 >> 5);
  v13 = (__int32 *)uprv_malloc(4 * (int)v12);
  if (!v13)
  {
    v8 = 7;
    goto LABEL_6;
  }
  v14 = v13;
  memset(v13, 255, 4 * (int)v12);
  if (v7)
  {
    v15 = &v7[a3];
    while (1)
    {
      if (a3 < 0)
      {
        v16 = *v7;
        if (!*v7)
          return sub_18BC2E54C(a1, v14, a4);
      }
      else
      {
        if (v7 == v15)
          return sub_18BC2E54C(a1, v14, a4);
        v16 = *v7;
      }
      v17 = v7 + 1;
      if ((v16 & 0xFC00) == 0xD800)
      {
        if (a3 < 0 || v15 != v17)
        {
          v21 = *v17;
          v18 = *(uint64_t **)a1;
          if ((v21 & 0xFC00) == 0xDC00)
          {
            v22 = v21 + (v16 << 10) - 56613888;
            v23 = *v18;
            if ((signed int)v22 >= *((_DWORD *)v18 + 11))
              v24 = *((_DWORD *)v18 + 12);
            else
              v24 = (v21 & 0x1F)
                  + 4
                  * *(unsigned __int16 *)(v23
                                        + 2
                                        * (((v22 >> 5) & 0x3F) + *(unsigned __int16 *)(v23 + 2 * ((v22 >> 11) + 2080))));
            v17 = v7 + 2;
            v25 = (unsigned __int16 *)(v23 + 2 * v24);
            goto LABEL_27;
          }
        }
        else
        {
          v18 = *(uint64_t **)a1;
        }
        v19 = *v18;
        v20 = (v16 >> 5) + 320;
      }
      else
      {
        v19 = **(_QWORD **)a1;
        v20 = v16 >> 5;
      }
      v25 = (unsigned __int16 *)(v19 + 2 * ((v16 & 0x1F) + 4 * *(unsigned __int16 *)(v19 + 2 * v20)));
LABEL_27:
      if (v10 >= 1)
      {
        v26 = 0;
        v27 = (int *)(*(_QWORD *)(a1 + 8) + 4 * *v25);
        v28 = v14;
        v29 = v12;
        do
        {
          v30 = *v27++;
          v31 = *v28 & v30;
          *v28++ = v31;
          v26 |= v31;
          --v29;
        }
        while (v29);
        v7 = v17;
        if (v26)
          continue;
      }
      return sub_18BC2E54C(a1, v14, a4);
    }
  }
  return sub_18BC2E54C(a1, v14, a4);
}

_QWORD *sub_18BC2E54C(uint64_t a1, __int32 *a2, _DWORD *a3)
{
  __int16 *v6;
  __int16 *v7;
  _OWORD *v8;
  _QWORD *v9;
  int8x8_t v10;
  int v11;
  int v12;
  unsigned __int16 v13;
  uint64_t v14;
  __int32 *v15;
  uint64_t v16;
  __int32 v17;
  __int32 v18;
  _WORD *v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;

  v6 = (__int16 *)uprv_malloc(0x18uLL);
  v7 = v6;
  if (v6)
  {
    *(_QWORD *)v6 = 0;
    *((_DWORD *)v6 + 2) = 0;
    *((_QWORD *)v6 + 2) = a1;
    v8 = uprv_malloc(0x38uLL);
    v9 = v8;
    if (v8)
    {
      *v8 = xmmword_1E2251208;
      v8[1] = *(_OWORD *)&off_1E2251218;
      v10.i32[1] = 1;
      v8[2] = xmmword_1E2251228;
      *((_QWORD *)v8 + 6) = sub_18BC2E9E8;
      v11 = *(_DWORD *)(a1 + 32);
      v12 = v11 + 31;
      if (v11 < -31)
        v12 = v11 + 62;
      if (v11 >= 1)
      {
        v13 = 0;
        v14 = (v12 >> 5);
        v15 = a2;
        v16 = v14;
        do
        {
          v18 = *v15++;
          v17 = v18;
          if (v18)
          {
            v10.i32[0] = v17;
            v10 = vcnt_s8(v10);
            v13 += vaddlv_u8((uint8x8_t)v10);
          }
          --v16;
        }
        while (v16);
        if ((__int16)v13 >= 1)
        {
          v19 = uprv_malloc(2 * v13);
          *(_QWORD *)v7 = v19;
          if (!v19)
          {
            *a3 = 7;
            v8 = v9;
            v9 = 0;
            goto LABEL_25;
          }
          v20 = 0;
          v21 = 0;
          v22 = *(_DWORD *)(a1 + 32);
          if ((int)v14 <= 1)
            v23 = 1;
          else
            v23 = v14;
          do
          {
            v24 = a2[v20];
            v25 = 32;
            do
            {
              if (v22 <= v21)
                break;
              if ((v24 & 1) != 0)
              {
                v26 = v7[4];
                v7[4] = v26 + 1;
                v19[v26] = v21;
              }
              v24 >>= 1;
              ++v21;
              --v25;
            }
            while (v25);
            ++v20;
          }
          while (v20 != v23);
        }
      }
      v8 = 0;
      v9[1] = v7;
      v7 = 0;
    }
    else
    {
      *a3 = 7;
    }
LABEL_25:
    uprv_free(v8);
    goto LABEL_26;
  }
  v9 = 0;
  *a3 = 7;
LABEL_26:
  uprv_free(v7);
  uprv_free(a2);
  return v9;
}

_QWORD *ucnvsel_selectForUTF8(_DWORD *a1, char *a2, int a3, int *a4)
{
  int v6;
  char *v7;
  int v8;
  int v10;
  int v11;
  uint64_t v12;
  __int32 *v13;
  __int32 *v14;
  unint64_t v15;
  int v16;
  _BYTE *v17;
  uint64_t v18;
  unsigned __int16 *v19;
  UChar32 v20;
  unsigned int v21;
  uint64_t v23;
  int Index;
  int v25;
  int *v26;
  __int32 *v27;
  uint64_t v28;
  int v29;
  int v30;

  if (*a4 > 0)
    return 0;
  if (!a1 || (v6 = a3, (v7 = a2) == 0) && a3)
  {
    v8 = 1;
LABEL_6:
    *a4 = v8;
    return 0;
  }
  v10 = a1[8];
  v11 = v10 + 31;
  if (v10 < -31)
    v11 = v10 + 62;
  v12 = (v11 >> 5);
  v13 = (__int32 *)uprv_malloc(4 * (int)v12);
  if (!v13)
  {
    v8 = 7;
    goto LABEL_6;
  }
  v14 = v13;
  memset(v13, 255, 4 * (int)v12);
  if (v6 < 0)
    v6 = strlen(v7);
  if (v7)
  {
    v15 = (unint64_t)&v7[v6];
    while (1)
    {
      if (v7 == (char *)v15)
        return sub_18BC2E54C((uint64_t)a1, v14, a4);
      v17 = v7 + 1;
      v16 = *v7;
      v18 = *v7;
      if ((v16 & 0x80000000) == 0)
      {
        v19 = (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)a1 + 8) + 2 * v18);
        ++v7;
        goto LABEL_30;
      }
      v20 = *v7;
      if ((v18 & 0xF0) == 0xE0)
      {
        if ((unint64_t)(v7 + 2) < v15 && ((a00000000000000[v18 & 0xF] >> (*v17 >> 5)) & 1) != 0)
        {
          v21 = v7[2] ^ 0x80;
          if (v21 <= 0x3F)
          {
            v7 += 3;
            v19 = (unsigned __int16 *)(**(_QWORD **)a1
                                     + 2
                                     * ((v21 & 0x1F)
                                      + 4
                                      * *(unsigned __int16 *)(**(_QWORD **)a1
                                                            + 2
                                                            * (((2 * (*v17 & 0x3F)) | (v20 << 7)) + (v21 >> 5) - 28672))));
            goto LABEL_30;
          }
        }
      }
      else if ((v16 + 62) <= 0x1Du && (unint64_t)v17 < v15)
      {
        v23 = *v17 ^ 0x80;
        if (v23 <= 0x3F)
        {
          v7 += 2;
          v19 = (unsigned __int16 *)(**(_QWORD **)a1
                                   + 2 * (*(unsigned __int16 *)(**(_QWORD **)a1 + 2 * v18 + 3776) + v23));
          goto LABEL_30;
        }
      }
      Index = utrie2_internalU8NextIndex(*(uint64_t **)a1, v20, (uint8_t *)v7 + 1, v15);
      v7 = &v17[Index & 7];
      v19 = (unsigned __int16 *)(**(_QWORD **)a1 + 2 * (Index >> 3));
LABEL_30:
      if (v10 >= 1)
      {
        v25 = 0;
        v26 = (int *)(*((_QWORD *)a1 + 1) + 4 * *v19);
        v27 = v14;
        v28 = v12;
        do
        {
          v29 = *v26++;
          v30 = *v27 & v29;
          *v27++ = v30;
          v25 |= v30;
          --v28;
        }
        while (v28);
        if (v25)
          continue;
      }
      return sub_18BC2E54C((uint64_t)a1, v14, a4);
    }
  }
  return sub_18BC2E54C((uint64_t)a1, v14, a4);
}

void sub_18BC2E91C(void ***a1)
{
  uprv_free(*a1[1]);
  uprv_free(a1[1]);
  uprv_free(a1);
}

uint64_t sub_18BC2E950(uint64_t a1, int *a2)
{
  if (*a2 <= 0)
    return *(__int16 *)(*(_QWORD *)(a1 + 8) + 8);
  else
    return 0;
}

const char *sub_18BC2E970(uint64_t a1, _DWORD *a2, int *a3)
{
  uint64_t v3;
  int v4;
  const char *v5;

  if (*a3 > 0)
    return 0;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(__int16 *)(v3 + 10);
  if (v4 >= *(__int16 *)(v3 + 8))
    return 0;
  v5 = *(const char **)(*(_QWORD *)(*(_QWORD *)(v3 + 16) + 24)
                      + 8 * *(__int16 *)(*(_QWORD *)v3 + 2 * *(__int16 *)(v3 + 10)));
  *(_WORD *)(v3 + 10) = v4 + 1;
  if (a2)
    *a2 = strlen(v5);
  return v5;
}

uint64_t sub_18BC2E9E8(uint64_t result, int *a2)
{
  if (*a2 <= 0)
    *(_WORD *)(*(_QWORD *)(result + 8) + 10) = 0;
  return result;
}

BOOL ucol_looksLikeCollationBinary(unsigned __int8 *a1, unsigned __int16 *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BOOL8 result;
  int v12;

  result = 0;
  if (a1 && a2 && a3 >= -1)
  {
    v12 = 0;
    udata_swapDataHeader((uint64_t)a1, a2, 0xFFFFFFFFLL, 0, &v12, a6, a7, a8);
    if (v12 <= 0
      && *((_BYTE *)a2 + 12) == 85
      && *((_BYTE *)a2 + 13) == 67
      && *((_BYTE *)a2 + 14) == 111
      && *((_BYTE *)a2 + 15) == 108)
    {
      return 1;
    }
    if (a3 < 0)
    {
      udata_readInt32((uint64_t)a1, *(unsigned int *)a2);
    }
    else if (a3 < 0xA8 || (int)udata_readInt32((uint64_t)a1, *(unsigned int *)a2) > a3)
    {
      return 0;
    }
    if ((*((unsigned int (**)(_QWORD))a1 + 2))(*((unsigned int *)a2 + 4)) == 537069080
      && *((_BYTE *)a2 + 80) == 3
      && *((unsigned __int8 *)a2 + 65) == *a1)
    {
      return *((unsigned __int8 *)a2 + 66) == a1[1];
    }
    return 0;
  }
  return result;
}

uint64_t ucol_swap(unsigned __int8 *a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  unsigned int *v24;
  int v25;
  uint64_t v26;
  unsigned int *v27;
  int v28;

  if (*a5 > 0)
    return 0;
  v14 = udata_swapDataHeader((uint64_t)a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (*a5 < 1)
  {
    v21 = *(unsigned __int8 *)(a2 + 12);
    if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) == 0x4300000055
      && *(_BYTE *)(a2 + 14) == 111
      && *(_BYTE *)(a2 + 15) == 108
      && (v22 = *(unsigned __int8 *)(a2 + 16), v22 - 3 < 3))
    {
      v23 = v14;
      v24 = (unsigned int *)(a2 + v14);
      if ((int)a3 >= 0)
        v25 = v14;
      else
        v25 = 0;
      v26 = (a3 - v25);
      if (a4)
        v27 = (unsigned int *)((char *)a4 + v14);
      else
        v27 = 0;
      if (v22 < 4)
        v28 = sub_18BC2EC94(a1, v24, v26, (uint64_t)v27, a5, v18, v19, v20);
      else
        v28 = sub_18BC2F114((uint64_t)a1, v24, v26, v27, a5, v18, v19, v20);
      if (*a5 <= 0)
        return (v28 + v23);
      else
        return 0;
    }
    else
    {
      udata_printError((uint64_t)a1, (uint64_t)"ucol_swap(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not recognized as collation data\n", v15, v16, v17, v18, v19, v20, v21);
      result = 0;
      *a5 = 16;
    }
  }
  else
  {
    *a5 = 0;
    return sub_18BC2EC94(a1, (unsigned int *)a2, a3, (uint64_t)a4, a5, v18, v19, v20);
  }
  return result;
}

uint64_t sub_18BC2EC94(unsigned __int8 *a1, unsigned int *a2, uint64_t a3, uint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Int32;
  int v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  unsigned __int16 *v29;
  int v30;
  int v31;
  unsigned __int16 *v32;
  int v33;
  int v34;
  unsigned int v35;
  int v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;

  if (*a5 > 0)
    return 0;
  if (!a1 || !a2 || (int)a3 < -1 || (int)a3 >= 1 && !a4)
  {
    Int32 = 0;
    v14 = 1;
LABEL_9:
    *a5 = v14;
    return Int32;
  }
  if ((a3 & 0x80000000) != 0)
  {
    Int32 = udata_readInt32((uint64_t)a1, *a2);
  }
  else if (a3 < 0xA8 || (Int32 = udata_readInt32((uint64_t)a1, *a2), (int)Int32 > (int)a3))
  {
    udata_printError((uint64_t)a1, (uint64_t)"ucol_swap(formatVersion=3): too few bytes (%d after header) for collation data\n", a3, a4, (uint64_t)a5, a6, a7, a8, a3);
    Int32 = 0;
    v14 = 8;
    goto LABEL_9;
  }
  v16 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[4]);
  if ((_DWORD)v16 != 537069080 || *((_BYTE *)a2 + 80) != 3)
  {
    udata_printError((uint64_t)a1, (uint64_t)"ucol_swap(formatVersion=3): magic 0x%08x or format version %02x.%02x is not a collation binary\n", v17, v18, v19, v20, v21, v22, v16);
    Int32 = 0;
    v14 = 16;
    goto LABEL_9;
  }
  v23 = *((unsigned __int8 *)a2 + 65);
  if (v23 != *a1 || *((unsigned __int8 *)a2 + 66) != a1[1])
  {
    udata_printError((uint64_t)a1, (uint64_t)"ucol_swap(formatVersion=3): endianness %d or charset %d does not match the swapper\n", v17, v18, v19, v20, v21, v22, (char)v23);
    Int32 = 0;
    v14 = 3;
    goto LABEL_9;
  }
  if ((a3 & 0x80000000) == 0)
  {
    if (a2 != (unsigned int *)a4)
      memcpy((void *)a4, a2, (int)Int32);
    v24 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[1]);
    v41 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[2]);
    v42 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[3]);
    v25 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[5]);
    v26 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[6]);
    v43 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[7]);
    v35 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[8]);
    v27 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[9]);
    v37 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[10]);
    (*((void (**)(_QWORD))a1 + 2))(a2[11]);
    v36 = udata_readInt32((uint64_t)a1, a2[12]);
    v38 = udata_readInt32((uint64_t)a1, a2[15]);
    v39 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[21]);
    v40 = (*((uint64_t (**)(_QWORD))a1 + 2))(a2[22]);
    (*((void (**)(unsigned __int8 *, unsigned int *, uint64_t, uint64_t, int *))a1 + 7))(a1, a2, 64, a4, a5);
    (*((void (**)(unsigned __int8 *, unsigned int *, uint64_t, uint64_t, int *))a1 + 7))(a1, a2 + 21, 8, a4 + 84, a5);
    *(_WORD *)(a4 + 65) = *((_WORD *)a1 + 1);
    if (v24)
      (*((void (**)(unsigned __int8 *, char *, _QWORD, uint64_t, int *))a1 + 7))(a1, (char *)a2 + v24, v26 - v24, a4 + v24, a5);
    if (v25 && v26)
    {
      v28 = v43;
      if (!v43)
        v28 = v25;
      (*((void (**)(unsigned __int8 *, char *, _QWORD, uint64_t, int *))a1 + 7))(a1, (char *)a2 + v26, v28 - v26, a4 + v26, a5);
    }
    if (v27)
    {
      (*((void (**)(unsigned __int8 *, char *, _QWORD, uint64_t, int *))a1 + 6))(a1, (char *)a2 + v43, (2 * v27), a4 + v43, a5);
      (*((void (**)(unsigned __int8 *, char *, _QWORD, uint64_t, int *))a1 + 7))(a1, (char *)a2 + v35, (4 * v27), a4 + v35, a5);
    }
    if (v25)
      utrie_swap((uint64_t)a1, (unsigned int *)((char *)a2 + v25), v37 - v25, a4 + v25, a5);
    if (v36)
      (*((void (**)(unsigned __int8 *, char *, _QWORD, uint64_t, int *))a1 + 7))(a1, (char *)a2 + v37, (4 * v36), a4 + v37, a5);
    if (v41)
      (*((void (**)(unsigned __int8 *, char *, _QWORD, uint64_t, int *))a1 + 7))(a1, (char *)a2 + v41, v42 - v41, a4 + v41, a5);
    if (v38)
      (*((void (**)(unsigned __int8 *, char *, _QWORD, uint64_t, int *))a1 + 6))(a1, (char *)a2 + v42, 2 * v38 * *((unsigned __int8 *)a2 + 67), a4 + v42, a5);
    if (v39)
    {
      v29 = (unsigned __int16 *)((char *)a2 + v39);
      v30 = (*((uint64_t (**)(_QWORD))a1 + 1))(*v29);
      v31 = (*((uint64_t (**)(_QWORD))a1 + 1))(v29[1]);
      (*((void (**)(unsigned __int8 *, unsigned __int16 *, _QWORD, uint64_t, int *))a1 + 6))(a1, v29, (4 * v30 + 2 * v31 + 4), a4 + v39, a5);
    }
    if (v40)
    {
      v32 = (unsigned __int16 *)((char *)a2 + v40);
      v33 = (*((uint64_t (**)(_QWORD))a1 + 1))(*v32);
      v34 = (*((uint64_t (**)(_QWORD))a1 + 1))(v32[1]);
      (*((void (**)(unsigned __int8 *, unsigned __int16 *, _QWORD, uint64_t, int *))a1 + 6))(a1, v32, (2 * (v34 + v33) + 4), a4 + v40, a5);
    }
  }
  return Int32;
}

uint64_t sub_18BC2F114(uint64_t a1, unsigned int *a2, uint64_t a3, unsigned int *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int Int32;
  int v15;
  uint64_t v16;
  unint64_t v17;
  __int128 *v18;
  unsigned int *v19;
  unint64_t v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _DWORD v44[7];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (*a5 > 0)
    return 0;
  memset(v44, 0, sizeof(v44));
  v43 = 0u;
  v42 = 0u;
  v41 = 0u;
  if (a3 <= 7)
    goto LABEL_18;
  Int32 = udata_readInt32(a1, *a2);
  v15 = Int32;
  v40 = Int32;
  v16 = (4 * Int32);
  if ((a3 & 0x80000000) == 0 && (int)v16 > (int)a3)
    goto LABEL_18;
  v17 = (Int32 - 2);
  if (Int32 < 2)
    goto LABEL_12;
  v18 = &v41;
  v19 = a2 + 1;
  if (v17 >= 0x12)
    v17 = 18;
  v20 = v17 + 1;
  do
  {
    v21 = *v19++;
    *(_DWORD *)v18 = udata_readInt32(a1, v21);
    v18 = (__int128 *)((char *)v18 + 4);
    --v20;
  }
  while (v20);
  if (v15 >= 20)
  {
    v22 = 19;
  }
  else
  {
LABEL_12:
    memset(&v40 + v15, 255, 4 * (19 - v15) + 4);
    v8 = v16;
    if (v15 < 6)
      goto LABEL_16;
    v22 = (v15 - 1);
  }
  v8 = *(&v40 + v22);
LABEL_16:
  if ((a3 & 0x80000000) != 0)
    return v8;
  if ((int)v8 > (int)a3)
  {
LABEL_18:
    udata_printError(a1, (uint64_t)"ucol_swap(formatVersion=4): too few bytes (%d after header) for collation data\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, a3);
    v23 = 8;
LABEL_19:
    v8 = 0;
    *a5 = v23;
    return v8;
  }
  if (a2 != a4)
    memcpy(a4, a2, (int)v8);
  (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(a1 + 56))(a1, a2, v16, a4, a5);
  if (DWORD1(v42) - (int)v42 >= 1)
    (*(void (**)(uint64_t, char *))(a1 + 56))(a1, (char *)a2 + (int)v42);
  v30 = HIDWORD(v42);
  v31 = (HIDWORD(v42) - DWORD2(v42));
  if ((int)v31 >= 1)
    utrie2_swap(a1, (unsigned __int16 *)((char *)a2 + SDWORD2(v42)), v31, (uint64_t)a4 + SDWORD2(v42), a5);
  if ((int)v43 - v30 >= 1)
  {
    udata_printError(a1, (uint64_t)"ucol_swap(formatVersion=4): unknown data at IX_RESERVED8_OFFSET\n", v31, v25, v26, v27, v28, v29, (v43 - v30));
LABEL_47:
    v23 = 16;
    goto LABEL_19;
  }
  v32 = DWORD1(v43);
  v33 = (DWORD1(v43) - v43);
  if ((int)v33 >= 1)
    (*(void (**)(uint64_t, char *))(a1 + 64))(a1, (char *)a2 + (int)v43);
  if (DWORD2(v43) - v32 >= 1)
  {
    udata_printError(a1, (uint64_t)"ucol_swap(formatVersion=4): unknown data at IX_RESERVED10_OFFSET\n", v33, v25, v26, v27, v28, v29, (DWORD2(v43) - v32));
    goto LABEL_47;
  }
  v34 = SHIDWORD(v43);
  if (HIDWORD(v43) - DWORD2(v43) >= 1)
    (*(void (**)(uint64_t, char *))(a1 + 56))(a1, (char *)a2 + SDWORD2(v43));
  v35 = v44[0];
  if (v44[0] - (int)v34 >= 1)
    (*(void (**)(uint64_t, char *))(a1 + 56))(a1, (char *)a2 + v34);
  v36 = v44[1];
  if (v44[1] - (int)v35 >= 1)
    (*(void (**)(uint64_t, char *))(a1 + 48))(a1, (char *)a2 + v35);
  v37 = v44[2];
  if (v44[2] - (int)v36 >= 1)
    (*(void (**)(uint64_t, char *))(a1 + 48))(a1, (char *)a2 + v36);
  v38 = v44[3];
  if (v44[3] - (int)v37 >= 1)
    (*(void (**)(uint64_t, char *))(a1 + 48))(a1, (char *)a2 + v37);
  v39 = (v44[4] - v38);
  if ((int)v39 >= 1)
    (*(void (**)(uint64_t, char *))(a1 + 48))(a1, (char *)a2 + v38);
  if (v44[6] - v44[5] >= 1)
  {
    udata_printError(a1, (uint64_t)"ucol_swap(formatVersion=4): unknown data at IX_RESERVED18_OFFSET\n", v39, v25, v26, v27, v28, v29, (v44[6] - v44[5]));
    goto LABEL_47;
  }
  return v8;
}

uint64_t ucol_swapInverseUCA(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  int v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int Int32;
  char *v28;
  int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;

  v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0)
    return 0;
  v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x6E00000049
    || *(_BYTE *)(a2 + 14) != 118
    || *(_BYTE *)(a2 + 15) != 67
    || *(_BYTE *)(a2 + 16) != 2
    || !*(_BYTE *)(a2 + 17))
  {
    udata_printError(a1, (uint64_t)"ucol_swapInverseUCA(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not an inverse UCA collation file\n", v14, v15, v16, v17, v18, v19, v21);
    result = 0;
    v26 = 16;
    goto LABEL_14;
  }
  v22 = v13;
  v23 = (unsigned int *)(a2 + v13);
  if ((a3 & 0x80000000) != 0)
  {
    Int32 = udata_readInt32(a1, *v23);
  }
  else
  {
    v24 = a3 - v13;
    if ((int)a3 - v13 < 32 || (v25 = udata_readInt32(a1, *v23), v24 < v25))
    {
      udata_printError(a1, (uint64_t)"ucol_swapInverseUCA(): too few bytes (%d after header) for inverse UCA collation data\n", v14, v15, v16, v17, v18, v19, a3);
      result = 0;
      v26 = 8;
LABEL_14:
      *a5 = v26;
      return result;
    }
    Int32 = v25;
    v28 = (char *)a4 + v22;
    if ((unsigned __int16 *)a2 != a4)
      memcpy((char *)a4 + v22, v23, v25);
    v29 = (*(uint64_t (**)(_QWORD))(a1 + 16))(v23[1]);
    v30 = (*(uint64_t (**)(_QWORD))(a1 + 16))(v23[2]);
    v31 = (*(uint64_t (**)(_QWORD))(a1 + 16))(v23[3]);
    v32 = (*(uint64_t (**)(_QWORD))(a1 + 16))(v23[4]);
    (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(a1 + 56))(a1, v23, 20, v28, a5);
    (*(void (**)(uint64_t, char *, _QWORD, char *, int *))(a1 + 56))(a1, (char *)v23 + v31, (12 * v29), &v28[v31], a5);
    (*(void (**)(uint64_t, char *, _QWORD, char *, int *))(a1 + 48))(a1, (char *)v23 + v32, (2 * v30), &v28[v32], a5);
  }
  return (Int32 + v22);
}

_DWORD *ucptrie_openFromBinary(int a1, int a2, uint64_t a3, int a4, int *a5, int *a6)
{
  _DWORD *result;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  BOOL v12;
  BOOL v13;
  BOOL v14;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  signed int v24;
  int v25;
  int v26;
  __int16 v27;

  if (*a6 > 0)
    return 0;
  if (a4 < 1 || (a2 - 3) < 0xFFFFFFFC || (a1 - 2) < 0xFFFFFFFD || (a3 & 3) != 0)
  {
    result = 0;
    v19 = 1;
LABEL_31:
    *a6 = v19;
    return result;
  }
  if (a4 <= 0xF)
    goto LABEL_30;
  if (*(_DWORD *)a3 != 1416784179)
    goto LABEL_30;
  v9 = *(unsigned __int16 *)(a3 + 4);
  if ((v9 & 0x38) != 0)
    goto LABEL_30;
  v10 = v9 & 7;
  if (v10 > 2)
    goto LABEL_30;
  v11 = v9 >> 6;
  if (v11 >= 2)
    goto LABEL_30;
  v12 = a1 < 0 || v11 == a1;
  v13 = v12;
  v14 = v10 == a2 || a2 <= -1;
  if (!v14 || !v13)
    goto LABEL_30;
  v16 = *(unsigned __int16 *)(a3 + 6);
  v17 = *(unsigned __int16 *)(a3 + 8) | ((unsigned __int16)v9 >> 12 << 16);
  if (v10 == 1)
  {
    v18 = 4 * v17;
  }
  else
  {
    v18 = *(unsigned __int16 *)(a3 + 8) | ((unsigned __int16)v9 >> 12 << 16);
    if ((v9 & 7) == 0)
      v18 = 2 * v17;
  }
  if (2 * v16 + 16 + v18 > a4)
  {
LABEL_30:
    result = 0;
    v19 = 3;
    goto LABEL_31;
  }
  v26 = 2 * v16 + 16 + v18;
  v20 = *(unsigned __int16 *)(a3 + 12);
  v21 = *(unsigned __int16 *)(a3 + 14);
  v27 = *(_WORD *)(a3 + 10);
  result = uprv_malloc(0x30uLL);
  if (!result)
  {
    v19 = 7;
    goto LABEL_31;
  }
  result[5] = v17;
  result[6] = v21 << 9;
  result[4] = v16;
  *((_WORD *)result + 14) = ((v21 << 9) + 4095) >> 12;
  v22 = v20 & 0xFFF0FFFF | (((v9 >> 8) & 0xF) << 16);
  *((_BYTE *)result + 30) = v11;
  *((_BYTE *)result + 31) = v10;
  result[8] = 0;
  *((_WORD *)result + 18) = 0;
  *((_WORD *)result + 19) = v27;
  *((_QWORD *)result + 5) = v22;
  v23 = a3 + 16 + 2 * v16;
  v24 = v17 - 2;
  if (v22 < v17)
    v24 = v22;
  *(_QWORD *)result = a3 + 16;
  *((_QWORD *)result + 1) = 0;
  if (v10 == 2)
  {
    *((_QWORD *)result + 1) = v23;
    v25 = *(unsigned __int8 *)(v23 + v24);
  }
  else if (v10 == 1)
  {
    *((_QWORD *)result + 1) = v23;
    v25 = *(_DWORD *)(v23 + 4 * v24);
  }
  else
  {
    if ((v9 & 7) != 0)
      goto LABEL_30;
    *((_QWORD *)result + 1) = v23;
    v25 = *(unsigned __int16 *)(v23 + 2 * v24);
  }
  result[11] = v25;
  if (a5)
    *a5 = v26;
  return result;
}

uint64_t ucptrie_getType(uint64_t a1)
{
  return *(char *)(a1 + 30);
}

uint64_t ucptrie_getValueWidth(uint64_t a1)
{
  return *(char *)(a1 + 31);
}

uint64_t ucptrie_internalSmallIndex(uint64_t *a1, unsigned int a2)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;

  if (*((_BYTE *)a1 + 30))
    v2 = 64;
  else
    v2 = 1020;
  v3 = v2 + ((int)a2 >> 14);
  v4 = *a1;
  v5 = *(__int16 *)(*a1 + 2 * (((a2 >> 9) & 0x1F) + *(unsigned __int16 *)(*a1 + 2 * v3)));
  v6 = *(unsigned __int16 *)(*a1 + 2 * (((a2 >> 9) & 0x1F) + *(unsigned __int16 *)(*a1 + 2 * v3)));
  v7 = (a2 >> 4) & 0x1F;
  if (v5 < 0)
  {
    v9 = ((a2 >> 4) & 0x18 | (v7 >> 3)) + (v6 & 0x7FFF);
    v8 = (*(unsigned __int16 *)(v4 + 2 * v9) << (2 * ((a2 >> 4) & 7) + 2)) & 0x30000 | *(unsigned __int16 *)(v4 + 2 * (((a2 >> 4) & 7) + v9 + 1));
  }
  else
  {
    v8 = *(unsigned __int16 *)(v4 + 2 * (v7 + v6));
  }
  return v8 + (a2 & 0xF);
}

uint64_t ucptrie_internalSmallU8Index(uint64_t a1, int a2, int a3, int a4)
{
  signed int v4;

  v4 = (a3 << 6) | (a2 << 12) | a4;
  if (v4 >= *(_DWORD *)(a1 + 24))
    return (*(_DWORD *)(a1 + 20) - 2);
  else
    return ucptrie_internalSmallIndex((uint64_t *)a1, v4);
}

uint64_t ucptrie_internalU8PrevIndex(uint64_t a1, UChar32 c, const uint8_t *a3, uint64_t a4)
{
  int32_t v5;
  const uint8_t *v6;
  unsigned int v7;
  int32_t v8;
  int v9;
  int32_t pi;

  if (a4 - (uint64_t)a3 >= 8)
    v5 = 7;
  else
    v5 = a4 - (_DWORD)a3;
  if (a4 - (uint64_t)a3 >= 8)
    v6 = (const uint8_t *)(a4 - 7);
  else
    v6 = a3;
  pi = v5;
  v7 = utf8_prevCharSafeBody(v6, 0, &pi, c, -1);
  v8 = v5 - pi;
  pi = v8;
  if (HIWORD(v7))
  {
    if (HIWORD(v7) > 0x10u)
    {
      v9 = *(_DWORD *)(a1 + 20) - 1;
    }
    else if ((signed int)v7 >= *(_DWORD *)(a1 + 24))
    {
      v9 = *(_DWORD *)(a1 + 20) - 2;
    }
    else
    {
      v9 = ucptrie_internalSmallIndex((uint64_t *)a1, v7);
    }
  }
  else
  {
    v9 = (v7 & 0x3F) + *(unsigned __int16 *)(*(_QWORD *)a1 + 2 * (v7 >> 6));
  }
  return v8 | (8 * v9);
}

uint64_t ucptrie_get(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  uint64_t v4;
  int v5;

  if (a2 >= 0x80)
  {
    if (*(_BYTE *)(a1 + 30))
      v3 = 4095;
    else
      v3 = 0xFFFF;
    if (v3 >= a2)
    {
      a2 = (a2 & 0x3F) + *(unsigned __int16 *)(*(_QWORD *)a1 + 2 * (a2 >> 6));
    }
    else if (HIWORD(a2) > 0x10u)
    {
      a2 = *(_DWORD *)(a1 + 20) - 1;
    }
    else if (*(_DWORD *)(a1 + 24) <= (signed int)a2)
    {
      a2 = *(_DWORD *)(a1 + 20) - 2;
    }
    else
    {
      a2 = ucptrie_internalSmallIndex((uint64_t *)a1, a2);
    }
  }
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(char *)(a1 + 31);
  if (v5 == 2)
    return *(unsigned __int8 *)(v4 + (int)a2);
  if (v5 == 1)
    return *(unsigned int *)(v4 + 4 * (int)a2);
  if (*(_BYTE *)(a1 + 31))
    return 0xFFFFFFFFLL;
  return *(unsigned __int16 *)(v4 + 2 * (int)a2);
}

uint64_t sub_18BC2FB18(uint64_t (*a1)(uint64_t, uint64_t, uint64_t, uint64_t, int *), uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, int *a8)
{
  int v10;
  int *v13;
  uint64_t v14;
  uint64_t result;
  uint64_t (*v16)(uint64_t, uint64_t, uint64_t, uint64_t, int *);
  BOOL v17;
  int v19;
  int v20;

  v10 = a3;
  if (!a4)
    return a1(a2, a3, a6, a7, a8);
  v20 = 0;
  if (a8)
    v13 = a8;
  else
    v13 = &v20;
  if (a4 == 2)
    v14 = 57343;
  else
    v14 = 56319;
  result = a1(a2, a3, a6, a7, v13);
  if ((int)v14 >= v10 && (int)result >= 55295)
  {
    if (*v13 == a5)
    {
      v16 = a1;
      if (result >= v14)
        return result;
      goto LABEL_17;
    }
    v16 = a1;
    if (v10 < 55296)
      return 55295;
    *v13 = a5;
    v17 = result > v14;
    result = v14;
    if (!v17)
    {
LABEL_17:
      v19 = 0;
      LODWORD(result) = v16(a2, (v14 + 1), a6, a7, &v19);
      if (v19 == a5)
        return result;
      else
        return v14;
    }
  }
  return result;
}

uint64_t ucptrie_getRange(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, int *a7)
{
  return sub_18BC2FB18((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, int *))sub_18BC2FC80, a1, a2, a3, a4, a5, a6, a7);
}

uint64_t sub_18BC2FC80(uint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, _DWORD *a5)
{
  uint64_t v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  signed int v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  unsigned int v56;
  _DWORD *v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  int v63;
  int v64;
  unsigned int v65;
  uint64_t (*v66)(uint64_t, uint64_t);

  if (WORD1(a2) > 0x10u)
    return 0xFFFFFFFFLL;
  v6 = a5;
  v7 = a4;
  v8 = a2;
  v5 = 1114111;
  v10 = *((char *)a1 + 31);
  if (*((_DWORD *)a1 + 6) <= (int)a2)
  {
    if (a5)
    {
      v48 = *((int *)a1 + 5) - 2;
      v49 = a1[1];
      if (v10 == 2)
      {
        v50 = *(unsigned __int8 *)(v49 + v48);
      }
      else if (v10 == 1)
      {
        v50 = *(unsigned int *)(v49 + 4 * (int)v48);
      }
      else if (*((_BYTE *)a1 + 31))
      {
        v50 = 0xFFFFFFFFLL;
      }
      else
      {
        v50 = *(unsigned __int16 *)(v49 + 2 * v48);
      }
      if (a3)
        LODWORD(v50) = a3(a4, v50);
      *v6 = v50;
    }
    return v5;
  }
  v11 = *((unsigned int *)a1 + 11);
  v66 = a3;
  if (a3)
  {
    v12 = a3(a4, v11);
    a3 = v66;
    v11 = v12;
  }
  v13 = 0;
  v14 = 0;
  v15 = *a1;
  v16 = 0xFFFFFFFFLL;
  v17 = -1;
  v5 = v8;
  v18 = v11;
  v65 = v11;
  v59 = v8;
  v57 = v6;
  v58 = *a1;
  while ((int)v5 >= 0x10000 || (int)v5 >= 4096 && *((_BYTE *)a1 + 30))
  {
    if (*((_BYTE *)a1 + 30))
      v19 = 64;
    else
      v19 = 1020;
    v20 = *(unsigned __int16 *)(*a1
                              + 2
                              * (((v5 >> 9) & 0x1F)
                               + *(unsigned __int16 *)(*a1 + 2 * (v19 + (v5 >> 14)))));
    if ((_DWORD)v16 == (_DWORD)v20 && (int)v5 - (int)v8 >= 512)
    {
      v5 = (v5 + 512);
      v20 = v16;
    }
    else
    {
      if ((_DWORD)v20 != *((unsigned __int16 *)a1 + 19))
      {
        v21 = (v5 >> 4) & 0x1F;
        v22 = 16;
        v56 = v20;
        v23 = 32;
        goto LABEL_24;
      }
      if ((v14 & 1) != 0)
      {
        if ((_DWORD)v11 != (_DWORD)v18)
          return (v5 - 1);
      }
      else
      {
        v13 = *((unsigned int *)a1 + 11);
        if (v6)
          *v6 = v11;
      }
      v17 = *((_DWORD *)a1 + 10);
      v5 = (v5 & 0xFFFFFE00) + 512;
      v14 = 1;
      v18 = v11;
    }
LABEL_86:
    v16 = v20;
    if ((int)v5 >= *((_DWORD *)a1 + 6))
    {
      v45 = *((int *)a1 + 5) - 2;
      v46 = a1[1];
      if (v10 == 2)
      {
        v47 = *(unsigned __int8 *)(v46 + v45);
      }
      else if (v10 == 1)
      {
        v47 = *(_DWORD *)(v46 + 4 * (int)v45);
      }
      else if (v10)
      {
        v47 = -1;
      }
      else
      {
        v47 = *(unsigned __int16 *)(v46 + 2 * v45);
      }
      v52 = *((_DWORD *)a1 + 11);
      if (v47 == v52)
        v53 = v11;
      else
        v53 = v47;
      if (a3 && v47 != v52)
      {
        v54 = v18;
        v53 = ((uint64_t (*)(uint64_t))a3)(v7);
        LODWORD(v18) = v54;
      }
      if (v53 == (_DWORD)v18)
        return 1114111;
      else
        return (v5 - 1);
    }
  }
  v56 = v16;
  LODWORD(v20) = 0;
  v21 = (int)v5 >> 6;
  v22 = 64;
  if (*((_BYTE *)a1 + 30))
    v23 = 64;
  else
    v23 = 1024;
LABEL_24:
  v24 = v20 & 0x7FFF;
  v25 = v22 - 1;
  v64 = -v22;
  v26 = v21;
  v27 = v20;
  v62 = v23;
  v63 = v22;
  v61 = v24;
  v60 = v20;
  while (1)
  {
    v28 = v27 >> 15
        ? (*(unsigned __int16 *)(v15 + 2 * (int)((v26 & 0xFFFFFFF8) + v24 + ((int)v26 >> 3))) << (2 * (v26 & 7) + 2)) & 0x30000 | *(unsigned __int16 *)(v15 + 2 * (int)((v26 & 7) + (v26 & 0xFFFFFFF8) + v24 + ((int)v26 >> 3) + 1))
        : *(unsigned __int16 *)(v15 + 2 * (v26 + v27));
    if (v28 != v17 || (int)v5 - (int)v8 < v22)
      break;
    v5 = (v5 + v22);
LABEL_81:
    if (++v26 >= v23)
    {
      v20 = v56;
      goto LABEL_86;
    }
  }
  if (v28 == *((_DWORD *)a1 + 10))
  {
    if ((v14 & 1) != 0)
    {
      if ((_DWORD)v11 != (_DWORD)v18)
        return (v5 - 1);
    }
    else
    {
      v13 = *((unsigned int *)a1 + 11);
      if (v6)
        *v6 = v11;
    }
    v5 = ((_DWORD)v5 + v22) & v64;
    v14 = 1;
    v17 = v28;
    v18 = v11;
    goto LABEL_81;
  }
  v30 = (v5 & v25) + (unint64_t)v28;
  v31 = a1[1];
  if (v10 != 2)
  {
    if (v10 == 1)
    {
      v32 = *(unsigned int *)(v31 + 4 * v30);
      if ((v14 & 1) != 0)
        goto LABEL_57;
    }
    else if (v10)
    {
      v32 = 0xFFFFFFFFLL;
      if ((v14 & 1) != 0)
        goto LABEL_57;
    }
    else
    {
      v32 = *(unsigned __int16 *)(v31 + 2 * v30);
      if ((v14 & 1) != 0)
        goto LABEL_57;
    }
LABEL_48:
    v33 = *((_DWORD *)a1 + 11);
    if ((_DWORD)v32 == v33)
      v18 = v11;
    else
      v18 = v32;
    if (a3 && (_DWORD)v32 != v33)
    {
      v34 = v66(v7, v32);
      v11 = v65;
      a3 = v66;
      v18 = v34;
    }
    if (v6)
      *v6 = v18;
    goto LABEL_63;
  }
  v32 = *(unsigned __int8 *)(v31 + v30);
  if ((v14 & 1) == 0)
    goto LABEL_48;
LABEL_57:
  if ((_DWORD)v32 == (_DWORD)v13)
  {
    v32 = v13;
  }
  else
  {
    if (!a3)
      return (v5 - 1);
    v35 = v11;
    if ((_DWORD)v32 != *((_DWORD *)a1 + 11))
    {
      v36 = v7;
      v55 = v7;
      v37 = v18;
      v35 = v66(v36, v32);
      v18 = v37;
      v7 = v55;
      v11 = v65;
      a3 = v66;
    }
    if (v35 != (_DWORD)v18)
      return (v5 - 1);
  }
LABEL_63:
  if ((((_DWORD)v5 + 1) & v25) == 0)
  {
    v14 = 1;
    v17 = v28;
    v5 = (v5 + 1);
    v13 = v32;
LABEL_80:
    LODWORD(v8) = v59;
    v15 = v58;
    v23 = v62;
    v22 = v63;
    v24 = v61;
    v27 = v60;
    goto LABEL_81;
  }
  v38 = v7;
  v39 = v30 + 1;
  while (1)
  {
    v40 = a1[1];
    if (v10 == 2)
    {
      v41 = *(unsigned __int8 *)(v40 + v39);
    }
    else if (v10 == 1)
    {
      v41 = *(unsigned int *)(v40 + 4 * v39);
    }
    else
    {
      v41 = v10 ? 0xFFFFFFFFLL : *(unsigned __int16 *)(v40 + 2 * v39);
    }
    if ((_DWORD)v41 != (_DWORD)v32)
    {
      if (!a3)
        return v5;
      v42 = v11;
      if ((_DWORD)v41 != *((_DWORD *)a1 + 11))
      {
        v43 = v18;
        v42 = v66(v38, v41);
        v18 = v43;
        v11 = v65;
        a3 = v66;
      }
      v32 = v41;
      if (v42 != (_DWORD)v18)
        return v5;
    }
    v44 = v5 + 2;
    ++v39;
    v5 = (v5 + 1);
    if ((v44 & v25) == 0)
    {
      v5 = (v5 + 1);
      v14 = 1;
      v17 = v28;
      v13 = v32;
      v7 = v38;
      v6 = v57;
      goto LABEL_80;
    }
  }
}

uint64_t ucptrie_toBinary(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  uint64_t v4;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  const void *v15;
  size_t v16;

  if (*a4 > 0)
    return 0;
  if (a3 < 0
    || (v6 = *(unsigned __int8 *)(a1 + 30), v6 > 1)
    || (v7 = *(char *)(a1 + 31), v7 < 0)
    || v7 > 2
    || a3 && (!a2 || (a2 & 3) != 0))
  {
    v4 = 0;
    v9 = 1;
  }
  else
  {
    v8 = *(int *)(a1 + 16);
    v4 = (2 * v8 + 16);
    if (v7 == 2)
    {
      v4 = (*(_DWORD *)(a1 + 20) + v4);
    }
    else if (v7 == 1)
    {
      v4 = (v4 + 4 * *(_DWORD *)(a1 + 20));
    }
    else if (!*(_BYTE *)(a1 + 31))
    {
      v4 = (2 * (*(_DWORD *)(a1 + 20) + v8) + 16);
    }
    if ((int)v4 <= a3)
    {
      *(_DWORD *)a2 = 1416784179;
      v11 = *(_DWORD *)(a1 + 20);
      v12 = *(_DWORD *)(a1 + 24);
      v13 = *(_DWORD *)(a1 + 40);
      *(_WORD *)(a2 + 4) = (v11 >> 4) & 0xF000 | ((_WORD)v6 << 6) | (v13 >> 8) & 0xF00 | v7;
      *(_WORD *)(a2 + 6) = v8;
      *(_WORD *)(a2 + 8) = v11;
      *(_WORD *)(a2 + 10) = *(_WORD *)(a1 + 38);
      *(_WORD *)(a2 + 12) = v13;
      *(_WORD *)(a2 + 14) = v12 >> 9;
      v14 = a2 + 16;
      memcpy((void *)(a2 + 16), *(const void **)a1, 2 * v8);
      if (v7 == 2)
      {
        v15 = *(const void **)(a1 + 8);
        v16 = *(int *)(a1 + 20);
      }
      else if (v7 == 1)
      {
        v15 = *(const void **)(a1 + 8);
        v16 = 4 * *(int *)(a1 + 20);
      }
      else
      {
        if (v7)
          return v4;
        v15 = *(const void **)(a1 + 8);
        v16 = 2 * *(int *)(a1 + 20);
      }
      memcpy((void *)(v14 + 2 * *(int *)(a1 + 16)), v15, v16);
      return v4;
    }
    v9 = 15;
  }
  *a4 = v9;
  return v4;
}

UChar32 ucpmap_getRange(const UCPMap *map, UChar32 start, UCPMapRangeOption option, uint32_t surrogateValue, UCPMapValueFilter *filter, const void *context, uint32_t *pValue)
{
  return sub_18BC2FB18((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, int *))sub_18BC2FC80, (uint64_t)map, *(uint64_t *)&start, option, surrogateValue, (uint64_t)filter, (uint64_t)context, (int *)pValue);
}

uint64_t sub_18BC30348(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;

  v2 = uhash_get(**(_QWORD **)a1, *(_QWORD *)(a1 + 16));
  v3 = v2;
  if (v2)
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(unsigned __int16 *)(v2 + 8);
    if ((v5 & 1) != 0)
    {
      if ((*(_WORD *)(v4 + 8) & 1) != 0)
        return 0;
    }
    else
    {
      if ((v5 & 0x8000) != 0)
        v6 = *(_DWORD *)(v2 + 12);
      else
        v6 = v5 >> 5;
      v7 = *(unsigned __int16 *)(v4 + 8);
      if ((v7 & 0x8000u) == 0)
        v8 = v7 >> 5;
      else
        v8 = *(_DWORD *)(v4 + 12);
      if ((v7 & 1) == 0
        && v6 == v8
        && icu::UnicodeString::doEquals((icu::UnicodeString *)v2, (const icu::UnicodeString *)v4, v6))
      {
        return 0;
      }
    }
    *(_QWORD *)(a1 + 16) = v3;
  }
  return v3;
}

uint64_t ucurr_forLocale(char *a1, UChar *a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  uint64_t v9;
  int v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  const UChar *v17;
  int v18;
  int Size;
  int v20;
  signed int v21;
  char *v22;
  const UChar *StringByKey;
  int32_t v24;
  int v25;
  _QWORD v27[2];
  unsigned int v28;
  int v29;
  void *v30[8];
  char __s[16];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _BYTE v39[29];
  void *v40[7];
  uint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (*a4 > 0)
    return 0;
  if ((a3 & 0x80000000) != 0 || !a2 && (_DWORD)a3)
  {
    v4 = 0;
    *a4 = 1;
    return v4;
  }
  v29 = 0;
  v41 = 0;
  memset(&v40[1], 0, 48);
  v40[0] = (char *)&v40[1] + 5;
  LODWORD(v40[1]) = 40;
  memset(__s, 0, sizeof(__s));
  icu::CharStringByteSink::CharStringByteSink(__s, (uint64_t)v40);
  ulocimp_getKeywordValue(a1, "currency", (uint64_t)__s, &v29);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)__s);
  v28 = v41;
  if (v29 > 0 || (_DWORD)v41 != 3 || !uprv_isInvariantString((unsigned __int8 *)v40[0], 3))
  {
    v38 = 0u;
    memset(v39, 0, sizeof(v39));
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    *(_OWORD *)__s = 0u;
    ulocimp_getRegionForSupplementalData(a1, 0, __s, 157, a4);
    v4 = 0;
    if (*a4 > 0)
      goto LABEL_50;
    v12 = strchr(__s, 95);
    if (v12)
      *v12 = 0;
    if (!__s[0])
    {
      v17 = 0;
      v18 = 2;
      v29 = 2;
      goto LABEL_39;
    }
    v29 = 0;
    v13 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)&v29);
    v14 = ures_getByKey(v13, "CurrencyMap", v13, &v29);
    v15 = ures_getByKey(v13, __s, v14, &v29);
    v16 = (_QWORD *)v15;
    if (v29 > 0)
    {
      v17 = 0;
      goto LABEL_38;
    }
    Size = ures_getSize(v15);
    if (Size < 1)
    {
      v17 = 0;
LABEL_35:
      if (v29 <= 0 && !v17)
        v29 = 2;
LABEL_38:
      ures_close(v16);
      v18 = v29;
      if (v29 < 1)
      {
        if (!v29)
        {
          v25 = *a4;
          if (*a4)
            goto LABEL_45;
        }
        goto LABEL_44;
      }
LABEL_39:
      if (strchr(__s, 95))
      {
        memset(&v30[1], 0, 56);
        v30[0] = (char *)&v30[1] + 5;
        LODWORD(v30[1]) = 40;
        v27[0] = 0;
        v27[1] = 0;
        icu::CharStringByteSink::CharStringByteSink(v27, (uint64_t)v30);
        ulocimp_getParent(a1, (uint64_t)v27, a4);
        icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v27);
        *a4 = -128;
        v4 = ucurr_forLocale(v30[0], a2, a3, a4);
        if (BYTE4(v30[1]))
          uprv_free(v30[0]);
        goto LABEL_50;
      }
LABEL_44:
      *a4 = v18;
      v25 = v18;
LABEL_45:
      v11 = v28;
      if (v25 <= 0 && (int)v28 < (int)a3)
      {
        u_strcpy(a2, v17);
        v11 = v28;
      }
      v9 = (uint64_t)a2;
      v10 = a3;
      goto LABEL_49;
    }
    v20 = Size;
    v21 = 0;
    v17 = 0;
    while (1)
    {
      v22 = ures_getByIndex((uint64_t)v16, v21, 0, &v29);
      LODWORD(v30[0]) = v29;
      StringByKey = ures_getStringByKey((uint64_t)v22, "tender", 0, (int *)v30);
      if (SLODWORD(v30[0]) < 1)
      {
        v24 = u_strcmp(StringByKey, word_18BE35BC2);
        if (!v24 && v17)
        {
          v24 = 4;
          goto LABEL_29;
        }
        v17 = ures_getStringByKey((uint64_t)v22, "id", (int *)&v28, &v29);
        if (!v24)
          goto LABEL_29;
      }
      else
      {
        v17 = ures_getStringByKey((uint64_t)v22, "id", (int *)&v28, &v29);
      }
      v24 = 2;
LABEL_29:
      if (v22)
        ures_close(v22);
      if ((v24 | 4) == 4 && v20 != ++v21)
        continue;
      goto LABEL_35;
    }
  }
  if (a3 >= 4)
  {
    T_CString_toUpperCase((unsigned __int8 *)v40[0]);
    u_charsToUChars((const char *)v40[0], a2, 3);
  }
  v9 = (uint64_t)a2;
  v10 = a3;
  v11 = 3;
LABEL_49:
  v4 = u_terminateUChars(v9, v10, v11, a4);
LABEL_50:
  if (BYTE4(v40[1]))
    uprv_free(v40[0]);
  return v4;
}

const UChar *ucurr_getName(const UChar *a1, char *a2, unsigned int a3, _BYTE *a4, int *a5, int *a6)
{
  const UChar *v6;
  signed int v8;
  _QWORD *v13;
  _QWORD *v14;
  const char *v15;
  _BYTE *v16;
  icu::StringPiece *v17;
  const UChar *StringByKeyWithFallback;
  UErrorCode v19;
  int v20;
  int v21;
  int v22;
  int Script;
  const UChar *StringByIndex;
  int v25;
  int v26;
  int v27;
  int v28;
  UErrorCode v29;
  int v31;
  int v32;
  char *v33;
  int v34;
  char *v35;
  int v36;
  _BYTE v37[16];
  _BYTE v38[16];
  _BYTE v39[23];
  BOOL v40;
  char __s[4];
  UErrorCode v42;
  void *v43[8];
  _QWORD v44[2];
  int v45;
  void *v46[10];

  v46[8] = *(void **)MEMORY[0x1E0C80C00];
  if (*a6 > 0)
    return 0;
  v8 = a3;
  if (a3 >= 5)
  {
    v6 = 0;
    *a6 = 1;
    return v6;
  }
  v42 = U_ZERO_ERROR;
  memset(&v46[1], 0, 56);
  v46[0] = (char *)&v46[1] + 5;
  LODWORD(v46[1]) = 40;
  v43[0] = 0;
  v43[1] = 0;
  icu::CharStringByteSink::CharStringByteSink(v43, (uint64_t)v46);
  ulocimp_getName(a2);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v43);
  *(_DWORD *)__s = 0;
  u_UCharsToChars(a1, __s, 3);
  __s[3] = 0;
  T_CString_toUpperCase((unsigned __int8 *)__s);
  v42 = U_ZERO_ERROR;
  v40 = 0;
  v13 = ures_open("icudt74l-curr", (char *)v46[0], (int *)&v42);
  v14 = ures_openWithCountryFallback("icudt74l-curr", (char *)v46[0], &v40, (int *)&v42);
  v44[0] = 0;
  v44[1] = 0;
  v45 = 0;
  if (v40)
  {
    uscript_getCode((char *)v46[0], (int32_t *)v44, 5, (int *)&v42);
    if (v42 >= U_ILLEGAL_ARGUMENT_ERROR)
      LODWORD(v44[0]) = 0;
  }
  if ((v8 - 2) > 2)
    goto LABEL_37;
  memset(&v43[1], 0, 56);
  v43[0] = (char *)&v43[1] + 5;
  LODWORD(v43[1]) = 40;
  switch(v8)
  {
    case 4:
      v15 = "Currencies%variant";
      v16 = v37;
      v17 = (icu::StringPiece *)v37;
      break;
    case 3:
      v15 = "Currencies%formal";
      v16 = v38;
      v17 = (icu::StringPiece *)v38;
      break;
    case 2:
      v15 = "Currencies%narrow";
      v16 = v39;
      v17 = (icu::StringPiece *)v39;
      break;
    default:
      v20 = 0;
      v6 = 0;
      *a6 = 16;
      goto LABEL_33;
  }
  icu::StringPiece::StringPiece(v17, v15);
  icu::CharString::append((icu::CharString *)v43, *(const char **)v16, *((_DWORD *)v16 + 2), &v42);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v35, "/");
  icu::CharString::append((icu::CharString *)v43, v35, v36, &v42);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v33, __s);
  icu::CharString::append((icu::CharString *)v43, v33, v34, &v42);
  if (!v40)
  {
    v19 = v42;
    goto LABEL_21;
  }
  StringByKeyWithFallback = ures_getStringByKeyWithFallback((uint64_t)v14, (char *)v43[0], a5, &v42);
  v6 = StringByKeyWithFallback;
  v19 = v42;
  if (v42 <= U_ZERO_ERROR)
  {
    v21 = *StringByKeyWithFallback;
    if ((v21 & 0xFC00) == 0xD800 && u_strlen(StringByKeyWithFallback) != 1)
    {
      v22 = v6[1];
      if ((v22 & 0xFC00) == 0xDC00)
        v21 = v22 + (v21 << 10) - 56613888;
    }
    Script = uscript_getScript(v21, (int *)&v42);
    if (v42 > U_ZERO_ERROR)
      goto LABEL_29;
    v31 = Script;
    v32 = u_isalpha(v21);
    v19 = v42;
    if (v32)
    {
      if (v31 != 25 && v31 != LODWORD(v44[0]))
        goto LABEL_21;
    }
  }
  if (v19 == U_MISSING_RESOURCE_ERROR || !v6)
  {
LABEL_21:
    if (v19 < U_ILLEGAL_ARGUMENT_ERROR)
    {
LABEL_30:
      v6 = ures_getStringByKeyWithFallback((uint64_t)v13, (char *)v43[0], a5, &v42);
      if (v42 == U_MISSING_RESOURCE_ERROR)
      {
        v8 = 0;
        *a6 = -128;
        v42 = U_ZERO_ERROR;
      }
      goto LABEL_32;
    }
LABEL_29:
    v42 = U_ZERO_ERROR;
    goto LABEL_30;
  }
LABEL_32:
  v20 = 1;
LABEL_33:
  if (BYTE4(v43[1]))
    uprv_free(v43[0]);
  if (v20)
  {
    if (v6)
      goto LABEL_55;
LABEL_37:
    if (v8 != 1 && v40)
    {
      ures_getByKey((uint64_t)v14, "Currencies", (uint64_t)v14, (int *)&v42);
      ures_getByKeyWithFallback((uint64_t)v14, __s, (uint64_t)v14, &v42);
      StringByIndex = ures_getStringByIndex((uint64_t)v14, v8, a5, (int *)&v42);
      v6 = StringByIndex;
      if (v42 <= U_ZERO_ERROR)
      {
        v25 = *StringByIndex;
        if ((v25 & 0xFC00) == 0xD800 && u_strlen(StringByIndex) != 1)
        {
          v26 = v6[1];
          if ((v26 & 0xFC00) == 0xDC00)
            v25 = v26 + (v25 << 10) - 56613888;
        }
        v27 = uscript_getScript(v25, (int *)&v42);
        if (v42 > U_ZERO_ERROR)
          goto LABEL_53;
        v28 = v27;
        if (u_isalpha(v25) && v28 != 25 && v28 != LODWORD(v44[0]))
          goto LABEL_52;
      }
      else if (!StringByIndex)
      {
        goto LABEL_53;
      }
      if (u_strcmp(v6, a1))
        goto LABEL_55;
    }
LABEL_52:
    if (v42 < U_ILLEGAL_ARGUMENT_ERROR)
    {
LABEL_54:
      ures_getByKey((uint64_t)v13, "Currencies", (uint64_t)v13, (int *)&v42);
      ures_getByKeyWithFallback((uint64_t)v13, __s, (uint64_t)v13, &v42);
      v6 = ures_getStringByIndex((uint64_t)v13, v8, a5, (int *)&v42);
LABEL_55:
      v29 = v42;
      if (v42 <= U_ZERO_ERROR && (v42 == U_USING_DEFAULT_WARNING || v42 == U_USING_FALLBACK_WARNING && *a6 != -127))
        *a6 = v42;
      if (a4)
        *a4 = 0;
      if (v29 >= U_ILLEGAL_ARGUMENT_ERROR)
      {
        *a5 = u_strlen(a1);
        *a6 = -127;
        v6 = a1;
      }
      goto LABEL_64;
    }
LABEL_53:
    v42 = U_ZERO_ERROR;
    goto LABEL_54;
  }
  v6 = 0;
LABEL_64:
  if (v14)
    ures_close(v14);
  if (v13)
    ures_close(v13);
  if (BYTE4(v46[1]))
    uprv_free(v46[0]);
  return v6;
}

const UChar *ucurr_getPluralName(const UChar *a1, char *a2, _BYTE *a3, char *a4, int *a5, int *a6)
{
  const UChar *Name;
  int v13;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  const UChar *StringByKeyWithFallback;
  _QWORD v19[2];
  int v20;
  void *v21[9];

  v21[8] = *(void **)MEMORY[0x1E0C80C00];
  if (*a6 > 0)
    return 0;
  v20 = 0;
  memset(&v21[1], 0, 56);
  v21[0] = (char *)&v21[1] + 5;
  LODWORD(v21[1]) = 40;
  v19[0] = 0;
  v19[1] = 0;
  icu::CharStringByteSink::CharStringByteSink(v19, (uint64_t)v21);
  ulocimp_getName(a2);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v19);
  if (v20 >= 1)
  {
    Name = 0;
    v13 = 1;
LABEL_5:
    *a6 = v13;
    goto LABEL_6;
  }
  LODWORD(v19[0]) = 0;
  u_UCharsToChars(a1, (char *)v19, 3);
  BYTE3(v19[0]) = 0;
  v20 = 0;
  v15 = ures_open("icudt74l-curr", (char *)v21[0], &v20);
  v16 = ures_getByKey((uint64_t)v15, "CurrencyPlurals", (uint64_t)v15, &v20);
  v17 = (_QWORD *)ures_getByKeyWithFallback(v16, (char *)v19, v16, (UErrorCode *)&v20);
  StringByKeyWithFallback = ures_getStringByKeyWithFallback((uint64_t)v17, a4, a5, (UErrorCode *)&v20);
  if (v20 < 1
    || (v20 = 0,
        StringByKeyWithFallback = ures_getStringByKeyWithFallback((uint64_t)v17, "other", a5, (UErrorCode *)&v20),
        v20 < 1))
  {
    Name = StringByKeyWithFallback;
    ures_close(v17);
    v13 = v20;
    if (v20 <= 0)
    {
      if (v20 == -127 || v20 == -128 && *a6 != -127)
        goto LABEL_5;
    }
    else
    {
      *a5 = u_strlen(a1);
      *a6 = -127;
      Name = a1;
    }
  }
  else
  {
    ures_close(v17);
    Name = ucurr_getName(a1, a2, 1u, a3, a5, a6);
  }
LABEL_6:
  if (BYTE4(v21[1]))
    uprv_free(v21[0]);
  return Name;
}

void uprv_parseCurrency(char *a1, uint64_t a2, uint64_t a3, int a4, int *a5, UChar *a6, int *a7)
{
  char *v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int32_t v20;
  int v21;
  BOOL v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  UErrorCode pErrorCode;
  UChar dest[8];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  UChar src[8];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  if (*a7 <= 0)
  {
    v14 = sub_18BC3123C(a1, a7);
    if (*a7 <= 0)
    {
      v15 = (uint64_t)v14;
      v25 = *((_DWORD *)v14 + 46);
      v26 = *((_DWORD *)v14 + 42);
      v27 = *((_QWORD *)v14 + 20);
      v28 = *((_QWORD *)v14 + 22);
      v16 = *(_DWORD *)(a3 + 8);
      v59 = 0;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      v49 = 0u;
      v50 = 0u;
      *(_OWORD *)src = 0u;
      v48 = 0u;
      v46 = 0;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      v36 = 0u;
      v37 = 0u;
      *(_OWORD *)dest = 0u;
      v35 = 0u;
      v17 = *(unsigned __int16 *)(a2 + 8);
      if ((v17 & 0x8000) != 0)
        v18 = *(_DWORD *)(a2 + 12);
      else
        v18 = v17 >> 5;
      v19 = v18 - v16;
      if ((int)(v18 - v16) > 100)
        v19 = 100;
      icu::UnicodeString::doExtract((char *)a2, v16, v19, (uint64_t)src, 0);
      pErrorCode = U_ZERO_ERROR;
      v20 = u_strToUpper(dest, 100, src, v19, a1, &pErrorCode);
      *a5 = 0;
      v31 = -1;
      v32 = 0;
      sub_18BC31B28(v27, v26, dest, v20, a5, &v32, &v31);
      v21 = 0;
      v29 = -1;
      v30 = 0;
      v22 = a4 == 1;
      v23 = v28;
      if (!v22)
      {
        sub_18BC31B28(v28, v25, src, v20, a5, &v30, &v29);
        v21 = v30;
      }
      if (v32 < v21 || (v24 = v31, v31 == -1))
      {
        if (v21 < v32)
          goto LABEL_16;
        v24 = v29;
        if (v29 == -1)
          goto LABEL_16;
      }
      else
      {
        v23 = v27;
        v21 = v32;
      }
      u_charsToUChars(*(const char **)(v23 + 24 * v24), a6, 4);
      *(_DWORD *)(a3 + 8) = v21 + v16;
LABEL_16:
      sub_18BC31DCC(v15);
    }
  }
}

char *sub_18BC3123C(char *a1, int *a2)
{
  uint64_t i;
  const char *v5;
  int v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  int Size;
  int v11;
  signed int j;
  char *v13;
  const UChar *StringByIndex;
  void *v15;
  _QWORD *v16;
  int v17;
  int v18;
  signed int k;
  char *v20;
  int *v21;
  uint64_t v22;
  int v23;
  int v24;
  signed int m;
  char *v26;
  const UChar *v27;
  const char *Key;
  const char **v29;
  int v30;
  uint64_t v31;
  void *v32;
  int *v33;
  __int16 v34;
  uint64_t v35;
  int v36;
  UChar *v37;
  char *v38;
  const char **v39;
  UChar *v40;
  signed int v41;
  void **v42;
  char *v43;
  uint64_t v44;
  int v45;
  int v46;
  signed int v47;
  char *v48;
  UChar *v49;
  int v50;
  char *v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  int v55;
  int v56;
  char *v57;
  int *v59;
  _QWORD *v60;
  int32x2_t *v61;
  char *__base;
  uint64_t v63;
  int v64;
  _QWORD *v65;
  _QWORD *v66;
  int32x2_t *v67;
  char *v68;
  _QWORD *v69;
  int v70;
  int v71;
  const UChar *v72;
  int v73;
  int32_t srcLength;
  char *v75;
  int v76;
  _QWORD v77[3];
  char *__s[8];
  int32_t v79[2];
  _OWORD *v80;
  _OWORD *v81;
  _OWORD v82[4];
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  umtx_lock((icu::UMutex *)&unk_1EE009548);
  for (i = 0; i != 10; ++i)
  {
    v5 = (const char *)qword_1EE0094F0[i];
    if (v5 && !strcmp(a1, v5))
    {
      v51 = (char *)qword_1EE0094F0[i];
LABEL_62:
      ++*((_DWORD *)v51 + 47);
      goto LABEL_79;
    }
  }
  umtx_unlock((std::mutex **)&unk_1EE009548);
  v63 = sub_18BC33204();
  v71 = 0;
  memset(&__s[1], 0, 56);
  __s[0] = (char *)&__s[1] + 5;
  LODWORD(__s[1]) = 40;
  v82[0] = 0uLL;
  icu::CharStringByteSink::CharStringByteSink(v82, (uint64_t)__s);
  ulocimp_getName(a1);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v82);
  v59 = a2;
  memset((char *)v82 + 8, 0, 56);
  *(_QWORD *)&v82[0] = (char *)v82 + 13;
  DWORD2(v82[0]) = 40;
  v79[0] = 0;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v75, __s[0]);
  icu::CharString::append((icu::CharString *)v82, v75, v76, (UErrorCode *)v79);
  v6 = 0;
  v7 = 0;
  if (v79[0] <= 0)
  {
    v8 = sub_18BC33204();
    v6 = 0;
    v7 = 0;
    do
    {
      srcLength = 0;
      v69 = ures_open("icudt74l-curr", *(char **)&v82[0], &srcLength);
      v9 = (_QWORD *)ures_getByKey((uint64_t)v69, "Currencies", 0, &srcLength);
      Size = ures_getSize((uint64_t)v9);
      if (Size >= 1)
      {
        v11 = Size;
        for (j = 0; j != v11; ++j)
        {
          v13 = ures_getByIndex((uint64_t)v9, j, 0, &srcLength);
          v73 = 0;
          StringByIndex = ures_getStringByIndex((uint64_t)v13, 0, &v73, &srcLength);
          if (v8)
          {
            v72 = StringByIndex;
            icu::UnicodeString::UnicodeString(v79, 1, &v72);
            v77[1] = v79;
            v77[2] = v79;
            v77[0] = v8;
            do
              ++v7;
            while (sub_18BC30348((uint64_t)v77));
            icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)v79);
          }
          else
          {
            ++v7;
          }
          ++v7;
          ures_close(v13);
        }
        v6 += v11;
      }
      v79[0] = 0;
      v16 = (_QWORD *)ures_getByKey((uint64_t)v69, "CurrencyPlurals", 0, v79);
      v17 = ures_getSize((uint64_t)v16);
      if (v17 >= 1)
      {
        v18 = v17;
        for (k = 0; k != v18; ++k)
        {
          v20 = ures_getByIndex((uint64_t)v16, k, 0, v79);
          v6 += ures_getSize((uint64_t)v20);
          ures_close(v20);
        }
      }
      ures_close(v16);
      ures_close(v9);
      ures_close(v69);
    }
    while (sub_18BC337D8((icu::CharString *)v82));
  }
  if (BYTE12(v82[0]))
    uprv_free(*(void **)&v82[0]);
  v21 = v59;
  v22 = v63;
  __base = (char *)uprv_malloc(24 * v6);
  if (__base)
  {
    v68 = (char *)uprv_malloc(24 * v7);
    if (v68)
    {
      if (*v59 <= 0)
      {
        LODWORD(v75) = 0;
        LODWORD(v72) = 0;
        v67 = uhash_open((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0, (int *)&v75);
        v6 = 0;
        v7 = 0;
        v70 = 0;
        v61 = uhash_open((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0, (int *)&v72);
        do
        {
          v71 = 0;
          v60 = ures_open("icudt74l-curr", __s[0], &v71);
          v66 = (_QWORD *)ures_getByKey((uint64_t)v60, "Currencies", 0, &v71);
          v23 = ures_getSize((uint64_t)v66);
          if (v23 >= 1)
          {
            v24 = v23;
            for (m = 0; m != v24; ++m)
            {
              v26 = ures_getByIndex((uint64_t)v66, m, 0, &v71);
              srcLength = 0;
              v27 = ures_getStringByIndex((uint64_t)v26, 0, &srcLength, &v71);
              Key = (const char *)ures_getKey((uint64_t)v26);
              if (!v70 || !uhash_get((uint64_t)v67, (uint64_t)Key))
              {
                uhash_put((uint64_t)v67, (uint64_t)Key, (uint64_t)Key, (int *)&v75);
                v29 = (const char **)&v68[24 * v7];
                *v29 = Key;
                v29[1] = (const char *)v27;
                v30 = v7 + 1;
                v29[2] = (const char *)srcLength;
                if (v22)
                {
                  memset(v82, 0, sizeof(v82));
                  v77[0] = v27;
                  icu::UnicodeString::UnicodeString(v82, 1, v77);
                  v80 = v82;
                  v81 = v82;
                  *(_QWORD *)v79 = v22;
                  v31 = sub_18BC30348((uint64_t)v79);
                  if (v31)
                  {
                    v33 = (int *)&v68[24 * v30 + 16];
                    do
                    {
                      *((_QWORD *)v33 - 2) = Key;
                      v34 = *(_WORD *)(v31 + 8);
                      if ((v34 & 0x11) != 0)
                      {
                        v35 = 0;
                      }
                      else if ((v34 & 2) != 0)
                      {
                        v35 = v31 + 10;
                      }
                      else
                      {
                        v35 = *(_QWORD *)(v31 + 24);
                      }
                      *((_QWORD *)v33 - 1) = v35;
                      v33[1] = 0;
                      if (*(__int16 *)(v31 + 8) < 0)
                        v36 = *(_DWORD *)(v31 + 12);
                      else
                        v36 = *(unsigned __int16 *)(v31 + 8) >> 5;
                      *v33 = v36;
                      v33 += 6;
                      v31 = sub_18BC30348((uint64_t)v79);
                      ++v30;
                    }
                    while (v31);
                  }
                  icu::UnicodeString::~UnicodeString(v32, (icu::UnicodeString *)v82);
                }
                v37 = (UChar *)ures_getStringByIndex((uint64_t)v26, 1, &srcLength, &v71);
                v38 = &__base[24 * v6];
                *(_QWORD *)v38 = Key;
                *((_QWORD *)v38 + 1) = sub_18BC33728(v37, srcLength, a1);
                ++v6;
                *((_DWORD *)v38 + 4) = srcLength;
                *((_DWORD *)v38 + 5) = 1;
                v39 = (const char **)&v68[24 * v30];
                *v39 = Key;
                v40 = (UChar *)uprv_malloc(6uLL);
                v39[1] = (const char *)v40;
                u_charsToUChars(Key, v40, 3);
                v7 = v30 + 1;
                v39[2] = (const char *)0x100000003;
                v22 = v63;
              }
              ures_close(v26);
            }
          }
          LODWORD(v82[0]) = 0;
          v65 = (_QWORD *)ures_getByKey((uint64_t)v60, "CurrencyPlurals", 0, (int *)v82);
          v64 = ures_getSize((uint64_t)v65);
          if (v64 < 1)
          {
            v42 = (void **)v61;
          }
          else
          {
            v41 = 0;
            v42 = (void **)v61;
            do
            {
              v43 = ures_getByIndex((uint64_t)v65, v41, 0, (int *)v82);
              v44 = ures_getKey((uint64_t)v43);
              if (!v70 || !uhash_get((uint64_t)v42, v44))
              {
                uhash_put((uint64_t)v42, v44, v44, (int *)&v72);
                v45 = ures_getSize((uint64_t)v43);
                v79[0] = 0;
                if (v45 >= 1)
                {
                  v46 = v45;
                  v47 = 0;
                  v48 = &__base[24 * v6 + 16];
                  do
                  {
                    v49 = (UChar *)ures_getStringByIndex((uint64_t)v43, v47, v79, (int *)v82);
                    *((_QWORD *)v48 - 2) = v44;
                    *((_QWORD *)v48 - 1) = sub_18BC33728(v49, v79[0], a1);
                    *(_DWORD *)v48 = v79[0];
                    *((_DWORD *)v48 + 1) = 1;
                    v48 += 24;
                    ++v47;
                  }
                  while (v46 != v47);
                  v6 += v47;
                  v22 = v63;
                  v42 = (void **)v61;
                }
              }
              ures_close(v43);
              ++v41;
            }
            while (v41 != v64);
          }
          ures_close(v65);
          ures_close(v66);
          ures_close(v60);
          ++v70;
        }
        while (sub_18BC337D8((icu::CharString *)__s));
        uhash_close((void **)v67);
        uhash_close(v42);
        qsort(__base, v6, 0x18uLL, (int (__cdecl *)(const void *, const void *))sub_18BC33900);
        qsort(v68, v7, 0x18uLL, (int (__cdecl *)(const void *, const void *))sub_18BC33900);
        v50 = (int)v75;
        v21 = v59;
        if ((int)v75 > 0 || (v50 = (int)v72, (int)v72 >= 1))
          *v59 = v50;
      }
      goto LABEL_65;
    }
    uprv_free(__base);
  }
  v6 = 0;
  __base = 0;
  v7 = 0;
  v68 = 0;
  *v59 = 7;
LABEL_65:
  if (BYTE4(__s[1]))
    uprv_free(__s[0]);
  if (*v21 > 0)
    return 0;
  umtx_lock((icu::UMutex *)&unk_1EE009548);
  v52 = 0;
  while (1)
  {
    v53 = (const char *)qword_1EE0094F0[v52];
    if (v53)
    {
      if (!strcmp(a1, v53))
        break;
    }
    if (++v52 == 10)
      goto LABEL_75;
  }
  if (v52 != 255)
  {
    sub_18BC331AC(__base, v6);
    sub_18BC331AC(v68, v7);
    v51 = (char *)qword_1EE0094F0[v52];
    goto LABEL_62;
  }
LABEL_75:
  v54 = qword_1EE0094F0[byte_1EE009540];
  if (v54)
  {
    v55 = *(_DWORD *)(v54 + 188) - 1;
    *(_DWORD *)(v54 + 188) = v55;
    if (!v55)
      sub_18BC330E0(v54);
  }
  v51 = (char *)uprv_malloc(0xC0uLL);
  v56 = byte_1EE009540;
  qword_1EE0094F0[byte_1EE009540] = (uint64_t)v51;
  v57 = strcpy(v51, a1);
  *((_QWORD *)v57 + 20) = __base;
  *((_DWORD *)v57 + 42) = v6;
  *((_QWORD *)v57 + 22) = v68;
  *((_DWORD *)v57 + 46) = v7;
  *((_DWORD *)v57 + 47) = 2;
  byte_1EE009540 = v56 + 1 - 10 * ((6554 * (v56 + 1)) >> 16);
  sub_18BC0ECC4(0xEu, (uint64_t)sub_18BC33118);
LABEL_79:
  umtx_unlock((std::mutex **)&unk_1EE009548);
  return v51;
}

uint64_t sub_18BC31B28(uint64_t result, int a2, unsigned __int16 *__s2, int a4, int *a5, int *a6, int *a7)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  BOOL v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;

  v12 = result;
  v13 = 0;
  v14 = 0;
  *a7 = -1;
  *a6 = 0;
  v15 = a2 - 1;
  while (2)
  {
    if (v13 == (a4 & ~(a4 >> 31)) || v14 > v15)
      return result;
    v16 = __s2[v13];
    v17 = v15;
    v18 = v14;
    while (1)
    {
      v19 = v18 + v17 < 0 != __OFADD__(v18, v17) ? v18 + v17 + 1 : v18 + v17;
      v20 = v19 >> 1;
      result = *(int *)(v12 + 24 * (v19 >> 1) + 16);
      if (v13 < result)
      {
        v21 = *(unsigned __int16 *)(*(_QWORD *)(v12 + 24 * (v19 >> 1) + 8) + 2 * v13);
        if (v21 >= v16)
          break;
      }
      v18 = v20 + 1;
LABEL_13:
      if (v18 > v17)
        return result;
    }
    if (v21 > v16)
    {
      v17 = v20 - 1;
      goto LABEL_13;
    }
    if (v14 < v20)
    {
      v22 = v20;
      do
      {
        v23 = v14 + v22;
        if (v14 + v22 < 0 != __OFADD__(v14, v22))
          ++v23;
        v24 = v23 >> 1;
        v25 = (uint64_t)v23 >> 1;
        if (v13 >= *(int *)(v12 + 24 * v24 + 16))
        {
          v14 = v25 + 1;
        }
        else if (*(unsigned __int16 *)(*(_QWORD *)(v12 + 24 * (int)v25 + 8) + 2 * v13) >= v16)
        {
          v22 = v25;
        }
        else
        {
          v14 = v25 + 1;
        }
      }
      while (v14 < v22);
    }
    while (v20 < v15)
    {
      v26 = v20 + v15;
      if (v20 + v15 < 0 != __OFADD__(v20, v15))
        ++v26;
      v27 = v26 >> 1;
      v28 = (uint64_t)v26 >> 1;
      if (v13 <= *(int *)(v12 + 24 * v27 + 16))
      {
        if (*(unsigned __int16 *)(*(_QWORD *)(v12 + 24 * (int)v28 + 8) + 2 * v13) > v16)
          v15 = v28;
        else
          v20 = v28 + 1;
      }
      else
      {
        v20 = v28 + 1;
      }
    }
    v29 = *(unsigned __int16 *)(*(_QWORD *)(v12 + 24 * v15 + 8) + 2 * v13) > v16;
    v30 = v13 + 1;
    if (v13 + 1 == *(_DWORD *)(v12 + 24 * v14 + 16))
      v31 = v14;
    else
      v31 = -1;
    if (v14 != -1)
    {
      if (v13 >= *a5)
        v32 = v13 + 1;
      else
        v32 = *a5;
      *a5 = v32;
      if (v31 != -1)
      {
        *a6 = v30;
        *a7 = v31;
      }
      v15 -= v29;
      v13 = v30;
      if (v15 - v14 <= 9)
      {
        if (v15 >= v14)
        {
          v33 = v14;
          v34 = *a5;
          v35 = v15 + 1;
          do
          {
            v36 = *(_DWORD *)(v12 + 24 * v33 + 16);
            v37 = v36 > a4 || v36 <= *a6;
            if (v37 || (result = memcmp(*(const void **)(v12 + 24 * v33 + 8), __s2, 2 * v36), (_DWORD)result))
            {
              if (v36 >= a4)
                v38 = a4;
              else
                v38 = v36;
              if ((int)v34 < v38)
              {
                v39 = *(_QWORD *)(v12 + 24 * v33 + 8);
                v40 = v34;
                do
                {
                  if (*(unsigned __int16 *)(v39 + 2 * v40) != __s2[v40])
                    break;
                  v41 = *a5;
                  if (v40 >= v41)
                    LODWORD(v41) = v40 + 1;
                  *a5 = v41;
                  ++v40;
                }
                while (v38 != (_DWORD)v40);
              }
            }
            else
            {
              v42 = *a5;
              if (*a5 <= v36)
                v42 = v36;
              *a5 = v42;
              *a7 = v33;
              *a6 = v36;
            }
            ++v33;
          }
          while (v35 != (_DWORD)v33);
        }
        return result;
      }
      continue;
    }
    return result;
  }
}

void sub_18BC31DCC(uint64_t a1)
{
  int v2;

  umtx_lock((icu::UMutex *)&unk_1EE009548);
  v2 = *(_DWORD *)(a1 + 188) - 1;
  *(_DWORD *)(a1 + 188) = v2;
  if (!v2)
    sub_18BC330E0(a1);
  umtx_unlock((std::mutex **)&unk_1EE009548);
}

const UChar *uprv_getStaticCurrencyName(const UChar *a1, char *a2, uint64_t a3, int *a4)
{
  const UChar *result;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;

  v13 = 0;
  result = ucurr_getName(a1, a2, 0, 0, (int *)&v13, a4);
  if (*a4 <= 0)
  {
    v7 = (uint64_t)result;
    v8 = v13;
    icu::UnicodeString::unBogus(a3);
    v9 = *(unsigned __int16 *)(a3 + 8);
    v10 = (__int16)v9;
    v11 = v9 >> 5;
    if (v10 >= 0)
      v12 = v11;
    else
      v12 = *(unsigned int *)(a3 + 12);
    return (const UChar *)icu::UnicodeString::doReplace(a3, 0, v12, v7, 0, v8);
  }
  return result;
}

uint64_t ucurr_getDefaultFractionDigits(const UChar *a1, int *a2)
{
  if (*a2 <= 0)
    return *sub_18BC31F30(a1, a2);
  else
    return 0;
}

uint64_t ucurr_getDefaultFractionDigitsForUsage(const UChar *a1, int a2, int *a3)
{
  uint64_t result;

  if (*a3 > 0)
    return 0;
  if (a2 == 1)
    return sub_18BC31F30(a1, a3)[2];
  if (!a2)
    return *sub_18BC31F30(a1, a3);
  result = 0;
  *a3 = 16;
  return result;
}

int *sub_18BC31F30(const UChar *a1, int *a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  int *v7;
  _QWORD *v9;
  _QWORD *v10;
  int *IntVector;
  int v12;
  char v13[8];

  if (!a1 || !*a1)
  {
    if (*a2 <= 0)
      *a2 = 1;
    return (int *)&unk_18BE14A4C;
  }
  v4 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)a2);
  v5 = (_QWORD *)ures_getByKey(v4, "CurrencyMeta", v4, a2);
  v6 = v5;
  if (*a2 >= 1)
  {
LABEL_4:
    ures_close(v5);
    return (int *)&unk_18BE14A4C;
  }
  *(_QWORD *)v13 = 0;
  u_UCharsToChars(a1, &v13[4], 3);
  v13[7] = 0;
  v9 = (_QWORD *)ures_getByKey((uint64_t)v6, &v13[4], 0, (int *)v13);
  v10 = v9;
  if (*(int *)v13 >= 1)
  {
    ures_close(v9);
    v10 = (_QWORD *)ures_getByKey((uint64_t)v6, "DEFAULT", 0, a2);
    if (*a2 >= 1)
    {
      ures_close(v6);
      v5 = v10;
      goto LABEL_4;
    }
  }
  v12 = 0;
  IntVector = ures_getIntVector((uint64_t)v10, &v12, a2);
  if (*a2 < 1 && v12 == 4)
    v7 = IntVector;
  else
    v7 = (int *)&unk_18BE14A4C;
  if ((*a2 >= 1 || v12 != 4) && *a2 <= 0)
  {
    *a2 = 3;
    v7 = (int *)&unk_18BE14A4C;
  }
  ures_close(v6);
  ures_close(v10);
  return v7;
}

int *ucurr_getRoundingIncrement(const UChar *a1, int *a2)
{
  return ucurr_getRoundingIncrementForUsage(a1, 0, a2);
}

int *ucurr_getRoundingIncrementForUsage(const UChar *a1, int a2, int *a3)
{
  int *result;
  int *v6;
  int v7;

  result = sub_18BC31F30(a1, a3);
  if (*a3 <= 0)
  {
    if (a2)
    {
      if (a2 != 1)
      {
        v7 = 16;
        goto LABEL_10;
      }
      v6 = result + 2;
    }
    else
    {
      v6 = result;
    }
    if (*v6 >= 0xA)
    {
      v7 = 3;
LABEL_10:
      *a3 = v7;
    }
  }
  return result;
}

uint64_t ucurr_isAvailable(uint64_t a1, int *a2, double a3, double a4)
{
  uint64_t result;
  unsigned int v9;
  int32x2_t *v10;
  int v11;
  void **v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  int v16;
  signed int v17;
  char *v18;
  char *v19;
  signed int v20;
  char *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  const UChar *String;
  uint64_t v27;
  _QWORD *v28;
  double v29;
  int *IntVector;
  uint64_t v31;
  _QWORD *v32;
  double v33;
  int *v34;
  uint64_t v35;
  signed int v36;
  int v37;
  int v38;
  int v39;

  if (*a2 > 0)
    return 0;
  v9 = atomic_load(&dword_1EE0095A8);
  if (v9 == 2 || !icu::umtx_initImplPreInit(&dword_1EE0095A8))
  {
    v16 = dword_1EE0095AC;
    if (dword_1EE0095AC < 1)
      goto LABEL_36;
    result = 0;
LABEL_13:
    *a2 = v16;
    return result;
  }
  sub_18BC0ECC4(0xEu, (uint64_t)sub_18BC33118);
  v10 = uhash_open((uint64_t)uhash_hashUChars, (uint64_t)uhash_compareUChars, 0, a2);
  v11 = *a2;
  if (*a2 > 0)
    goto LABEL_35;
  v12 = (void **)v10;
  uhash_setValueDeleter((uint64_t)v10, (uint64_t)j__uprv_free);
  v39 = 0;
  v13 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)&v39);
  v14 = ures_getByKey(v13, "CurrencyMap", v13, &v39);
  v15 = (_QWORD *)v14;
  if (v39 > 0)
  {
    *a2 = v39;
LABEL_9:
    ures_close(v15);
    v11 = *a2;
    if (*a2 >= 1)
      goto LABEL_34;
    qword_1EE0094E8 = (uint64_t)v12;
    goto LABEL_35;
  }
  if ((int)ures_getSize(v14) < 1)
    goto LABEL_9;
  v17 = 0;
  v35 = (uint64_t)v15;
  while (1)
  {
    v36 = v17;
    v18 = ures_getByIndex((uint64_t)v15, v17, 0, &v39);
    v19 = v18;
    if (v39 <= 0)
      break;
    *a2 = v39;
LABEL_18:
    ures_close(v19);
    v17 = v36 + 1;
    v15 = (_QWORD *)v35;
    if (v36 + 1 >= (int)ures_getSize(v35))
      goto LABEL_9;
  }
  if ((int)ures_getSize((uint64_t)v18) < 1)
    goto LABEL_18;
  v20 = 0;
  while (1)
  {
    v21 = ures_getByIndex((uint64_t)v19, v20, 0, &v39);
    v22 = uprv_malloc(0x18uLL);
    if (!v22)
      break;
    v23 = (uint64_t)v22;
    v38 = 0;
    v24 = ures_getByKey((uint64_t)v21, "id", 0, &v39);
    if (v24)
    {
      v25 = (_QWORD *)v24;
      String = ures_getString(v24, &v38, &v39);
      v27 = ures_getByKey((uint64_t)v21, "from", 0, &v39);
      v28 = (_QWORD *)v27;
      if (v39 <= 0)
      {
        v37 = 0;
        IntVector = ures_getIntVector(v27, &v37, &v39);
        v29 = (double)(uint64_t)(IntVector[1] | ((unint64_t)*IntVector << 32));
      }
      else
      {
        v29 = -1.79769313e308;
      }
      ures_close(v28);
      v39 = 0;
      v31 = ures_getByKey((uint64_t)v21, "to", 0, &v39);
      v32 = (_QWORD *)v31;
      if (v39 <= 0)
      {
        v37 = 0;
        v34 = ures_getIntVector(v31, &v37, &v39);
        v33 = (double)(uint64_t)(v34[1] | ((unint64_t)*v34 << 32));
      }
      else
      {
        v33 = 1.79769313e308;
      }
      ures_close(v32);
      ures_close(v25);
      ures_close(v21);
      *(_QWORD *)v23 = String;
      *(double *)(v23 + 8) = v29;
      *(double *)(v23 + 16) = v33;
      v39 = 0;
      uhash_put((uint64_t)v12, (uint64_t)String, v23, &v39);
    }
    if (++v20 >= (int)ures_getSize((uint64_t)v19))
      goto LABEL_18;
  }
  *a2 = 7;
LABEL_34:
  uhash_close(v12);
  v11 = *a2;
LABEL_35:
  dword_1EE0095AC = v11;
  icu::umtx_initImplPostInit(&dword_1EE0095A8);
LABEL_36:
  if (*a2 > 0)
    return 0;
  result = uhash_get(qword_1EE0094E8, a1);
  if (result)
  {
    if (a3 > a4)
    {
      result = 0;
      v16 = 1;
      goto LABEL_13;
    }
    return *(double *)(result + 16) >= a3 && *(double *)(result + 8) <= a4;
  }
  return result;
}

_QWORD *ucurr_openISOCurrencies(int a1, _DWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _DWORD *v6;

  v4 = uprv_malloc(0x38uLL);
  v5 = v4;
  if (v4)
  {
    *(_OWORD *)v4 = xmmword_1E2251240;
    *((_OWORD *)v4 + 1) = *(_OWORD *)&off_1E2251250;
    *((_OWORD *)v4 + 2) = xmmword_1E2251260;
    v4[6] = sub_18BC33AA4;
    v6 = uprv_malloc(8uLL);
    if (v6)
    {
      *v6 = a1;
      v6[1] = 0;
      v5[1] = v6;
    }
    else
    {
      *a2 = 7;
      uprv_free(v5);
      return 0;
    }
  }
  else
  {
    *a2 = 7;
  }
  return v5;
}

uint64_t ucurr_countCurrencies(char *a1, int *a2, double a3)
{
  uint64_t v4;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  signed int v12;
  char *v13;
  _QWORD *v14;
  int *IntVector;
  double v16;
  _QWORD *v17;
  int *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  char __s[16];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _BYTE v32[29];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!a2 || *a2 > 0)
    return 0;
  v23 = 0;
  memset(v32, 0, sizeof(v32));
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  *(_OWORD *)__s = 0u;
  v25 = 0u;
  ulocimp_getRegionForSupplementalData(a1, 0, __s, 157, a2);
  v4 = 0;
  if (*a2 <= 0)
  {
    v7 = strchr(__s, 95);
    if (v7)
      *v7 = 0;
    v8 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)&v23);
    v9 = ures_getByKey(v8, "CurrencyMap", v8, &v23);
    v10 = ures_getByKey(v8, __s, v9, &v23);
    v11 = (_QWORD *)v10;
    if (v23 > 0 || (int)ures_getSize(v10) < 1)
    {
      v4 = 0;
    }
    else
    {
      v4 = 0;
      v12 = 0;
      do
      {
        v13 = ures_getByIndex((uint64_t)v11, v12, 0, &v23);
        v22 = 0;
        v14 = (_QWORD *)ures_getByKey((uint64_t)v13, "from", 0, &v23);
        IntVector = ures_getIntVector((uint64_t)v14, &v22, &v23);
        v16 = (double)(uint64_t)(IntVector[1] | ((unint64_t)*IntVector << 32));
        if ((int)ures_getSize((uint64_t)v13) < 3)
        {
          if (v16 <= a3)
            v4 = (v4 + 1);
        }
        else
        {
          v21 = 0;
          v17 = (_QWORD *)ures_getByKey((uint64_t)v13, "to", 0, &v23);
          v18 = ures_getIntVector((uint64_t)v17, &v21, &v23);
          if (v16 <= a3 && (double)(uint64_t)(v18[1] | ((unint64_t)*v18 << 32)) > a3)
            v4 = (v4 + 1);
          ures_close(v17);
        }
        ures_close(v13);
        ures_close(v14);
        ++v12;
      }
      while (v12 < (int)ures_getSize((uint64_t)v11));
    }
    ures_close(v11);
    v19 = *a2;
    v20 = v23;
    if (!*a2 || v23)
    {
      *a2 = v23;
      v19 = v20;
    }
    if (v19 > 0)
      return 0;
  }
  return v4;
}

uint64_t ucurr_forLocaleAndDate(char *a1, int a2, UChar *a3, int a4, int *a5, double a6)
{
  uint64_t result;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  const UChar *StringByKey;
  BOOL v18;
  int v19;
  int v20;
  char v21;
  signed int v22;
  char v23;
  char *v24;
  _QWORD *v25;
  int *IntVector;
  double v27;
  _QWORD *v28;
  int *v29;
  int v30;
  const UChar *v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  char __s[16];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _BYTE v44[29];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v35 = 0;
  if (!a5 || *a5 > 0)
    return 0;
  if (!a3 && a4)
  {
    result = 0;
    *a5 = 1;
    return result;
  }
  v34 = 0;
  v43 = 0u;
  memset(v44, 0, sizeof(v44));
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  *(_OWORD *)__s = 0u;
  ulocimp_getRegionForSupplementalData(a1, 0, __s, 157, a5);
  result = 0;
  if (*a5 <= 0)
  {
    v12 = strchr(__s, 95);
    if (v12)
      *v12 = 0;
    v13 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)&v34);
    v14 = ures_getByKey(v13, "CurrencyMap", v13, &v34);
    v15 = ures_getByKey(v13, __s, v14, &v34);
    v16 = (_QWORD *)v15;
    if (v34 <= 0)
    {
      if (a2 < 1 || (int)ures_getSize(v15) < a2)
      {
        ures_close(v16);
        return 0;
      }
      if ((int)ures_getSize((uint64_t)v16) < 1)
      {
        StringByKey = 0;
        v23 = 0;
      }
      else
      {
        v30 = 0;
        v22 = 0;
        v23 = 0;
        do
        {
          v24 = ures_getByIndex((uint64_t)v16, v22, 0, &v34);
          StringByKey = ures_getStringByKey((uint64_t)v24, "id", (int *)&v35, &v34);
          v33 = 0;
          v25 = (_QWORD *)ures_getByKey((uint64_t)v24, "from", 0, &v34);
          IntVector = ures_getIntVector((uint64_t)v25, &v33, &v34);
          v27 = (double)(uint64_t)(IntVector[1] | ((unint64_t)*IntVector << 32));
          if ((int)ures_getSize((uint64_t)v24) < 3)
          {
            if (v27 <= a6 && ++v30 == a2)
              v23 = 1;
          }
          else
          {
            v31 = StringByKey;
            v32 = 0;
            v28 = (_QWORD *)ures_getByKey((uint64_t)v24, "to", 0, &v34);
            v29 = ures_getIntVector((uint64_t)v28, &v32, &v34);
            if (v27 <= a6
              && (double)(uint64_t)(v29[1] | ((unint64_t)*v29 << 32)) > a6
              && ++v30 == a2)
            {
              v23 = 1;
            }
            ures_close(v28);
            StringByKey = v31;
          }
          ures_close(v24);
          ures_close(v25);
          if ((v23 & 1) != 0)
            break;
          ++v22;
        }
        while (v22 < (int)ures_getSize((uint64_t)v16));
      }
      v18 = (v23 & 1) == 0;
    }
    else
    {
      StringByKey = 0;
      v18 = 1;
    }
    ures_close(v16);
    v19 = *a5;
    v20 = v34;
    if (!*a5 || v34)
    {
      *a5 = v34;
      v19 = v20;
    }
    if (v19 <= 0)
    {
      v21 = (int)v35 >= a4 || v18;
      if ((v21 & 1) != 0)
        return 0;
      u_strcpy(a3, StringByKey);
    }
    return u_terminateUChars((uint64_t)a3, a4, v35, a5);
  }
  return result;
}

uint64_t ucurr_getKeywordValuesForLocale(uint64_t a1, char *a2, int a3, int *a4)
{
  _QWORD *EmptyList;
  _QWORD *v8;
  _OWORD *v9;
  uint64_t KeywordValuesForLocale;
  _QWORD *v12;
  const char *Key;
  int v15;
  int v16;
  char *v17;
  char *v18;
  int v19;
  int v20;
  uint64_t v21;
  const char *Next;
  const char *v23;
  int v24;
  void *v25;
  size_t v26;
  uint64_t v27;
  int32_t v28;
  char __s2[4];
  _OWORD v30[8];
  uint64_t v31;
  _QWORD v32[18];
  _QWORD v33[18];
  _QWORD v34[20];

  v34[17] = *MEMORY[0x1E0C80C00];
  *(_DWORD *)__s2 = 0;
  ulocimp_getRegionForSupplementalData(a2, 1, __s2, 4, a4);
  EmptyList = ulist_createEmptyList(a4);
  v8 = ulist_createEmptyList(a4);
  v9 = uprv_malloc(0x38uLL);
  KeywordValuesForLocale = (uint64_t)v9;
  if (*a4 <= 0 && v9 != 0)
  {
    v27 = a1;
    *v9 = xmmword_1E2251278;
    v9[1] = *(_OWORD *)&off_1E2251288;
    v9[2] = xmmword_1E2251298;
    *((_QWORD *)v9 + 6) = ulist_reset_keyword_values_iterator;
    *((_QWORD *)v9 + 1) = EmptyList;
    v12 = (_QWORD *)ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)a4);
    ures_getByKey((uint64_t)v12, "CurrencyMap", (uint64_t)v12, a4);
    memset(v34, 0, 136);
    memset(v33, 0, 136);
    memset(v32, 0, 136);
    v31 = 0;
    memset(v30, 0, sizeof(v30));
    ures_initStackObject((uint64_t)v34);
    ures_initStackObject((uint64_t)v33);
    ures_initStackObject((uint64_t)v32);
    ures_initStackObject((uint64_t)v30);
    if (*a4 > 0)
      goto LABEL_9;
    while (1)
    {
      if (!ures_hasNext((_BOOL8)v12))
      {
        if (*a4 <= 0)
        {
          if (a3)
          {
            if (!ulist_getListSize((uint64_t)EmptyList))
            {
              uenum_close((void **)KeywordValuesForLocale);
              KeywordValuesForLocale = ucurr_getKeywordValuesForLocale(v27, "und", 1, a4);
            }
          }
          else
          {
            ulist_resetList(v8);
            Next = (const char *)ulist_getNext((uint64_t)v8);
            if (Next)
            {
              v23 = Next;
              do
              {
                v24 = strlen(v23);
                if (!ulist_containsString((uint64_t)EmptyList, v23, v24))
                {
                  v25 = uprv_malloc(0x60uLL);
                  v26 = strlen(v23);
                  memcpy(v25, v23, v26 + 1);
                  ulist_addItemEndList((uint64_t)EmptyList, v25, 1, a4);
                  if (*a4 > 0)
                    break;
                }
                v23 = (const char *)ulist_getNext((uint64_t)v8);
              }
              while (v23);
            }
          }
          ulist_resetList(*(_QWORD **)(KeywordValuesForLocale + 8));
          goto LABEL_10;
        }
LABEL_9:
        ulist_deleteList(EmptyList);
        uprv_free((void *)KeywordValuesForLocale);
        KeywordValuesForLocale = 0;
LABEL_10:
        ures_close(v30);
        ures_close(v32);
        ures_close(v33);
        ures_close(v34);
        ures_close(v12);
        ulist_deleteList(v8);
        return KeywordValuesForLocale;
      }
      ures_getNextResource((uint64_t)v12, (char *)v34, a4);
      if (*a4 > 0)
        goto LABEL_9;
      Key = (const char *)ures_getKey((uint64_t)v34);
      v15 = strcmp(Key, __s2);
      v16 = v15;
      if (!a3 || !v15)
        break;
LABEL_18:
      if (*a4 > 0)
        goto LABEL_9;
    }
    ures_getByKey((uint64_t)v12, Key, (uint64_t)v33, a4);
    while (1)
    {
      while (1)
      {
        do
        {
          if (*a4 > 0)
            goto LABEL_9;
          if (!ures_hasNext((_BOOL8)v33))
            goto LABEL_18;
          ures_getNextResource((uint64_t)v33, (char *)v32, a4);
        }
        while (ures_getType((uint64_t)v32) != 2);
        v17 = (char *)uprv_malloc(0x60uLL);
        v28 = 96;
        if (!v17)
        {
          *a4 = 7;
          goto LABEL_18;
        }
        v18 = v17;
        ures_getUTF8StringByKey((uint64_t)v32, "id", v17, &v28, 1, a4);
        if (*a4 > 0)
          goto LABEL_18;
        ures_getByKey((uint64_t)v32, "to", (uint64_t)v30, a4);
        if (*a4 < 1)
          break;
        *a4 = 0;
        if (v16)
          break;
        v19 = strlen(v18);
        if (ulist_containsString((uint64_t)EmptyList, v18, v19))
          break;
        v21 = (uint64_t)EmptyList;
LABEL_33:
        ulist_addItemEndList(v21, v18, 1, a4);
      }
      v20 = strlen(v18);
      if (!(ulist_containsString((uint64_t)v8, v18, v20) | a3))
      {
        v21 = (uint64_t)v8;
        goto LABEL_33;
      }
      uprv_free(v18);
    }
  }
  if (v9)
    uprv_free(v9);
  else
    *a4 = 7;
  ulist_deleteList(EmptyList);
  ulist_deleteList(v8);
  return 0;
}

uint64_t ucurr_getNumericCode(const UChar *a1)
{
  _QWORD *v2;
  uint64_t v3;
  unsigned int Int;
  char v6[4];
  int v7;

  if (!a1 || u_strlen(a1) != 3)
    return 0;
  v7 = 0;
  v2 = (_QWORD *)ures_openDirect(0, (uint64_t)"currencyNumericCodes", (uint64_t)&v7);
  ures_getByKey((uint64_t)v2, "codeMap", (uint64_t)v2, &v7);
  v3 = 0;
  if (v7 <= 0)
  {
    *(_DWORD *)v6 = 0;
    u_UCharsToChars(a1, v6, 3);
    v6[3] = 0;
    T_CString_toUpperCase((unsigned __int8 *)v6);
    ures_getByKey((uint64_t)v2, v6, (uint64_t)v2, &v7);
    Int = ures_getInt((uint64_t)v2, &v7);
    if (v7 <= 0)
      v3 = Int;
    else
      v3 = 0;
  }
  ures_close(v2);
  return v3;
}

void sub_18BC330E0(uint64_t a1)
{
  sub_18BC331AC(*(char **)(a1 + 160), *(_DWORD *)(a1 + 168));
  sub_18BC331AC(*(char **)(a1 + 176), *(_DWORD *)(a1 + 184));
  uprv_free((void *)a1);
}

uint64_t sub_18BC33118()
{
  uint64_t i;
  uint64_t v1;
  void *v2;

  for (i = 0; i != 10; ++i)
  {
    v1 = qword_1EE0094F0[i];
    if (v1)
    {
      sub_18BC330E0(v1);
      qword_1EE0094F0[i] = 0;
    }
  }
  if (qword_1EE0094E8)
  {
    uhash_close((void **)qword_1EE0094E8);
    qword_1EE0094E8 = 0;
  }
  atomic_store(0, &dword_1EE0095A8);
  v2 = (void *)qword_1EE009598;
  if (qword_1EE009598)
  {
    if (*(_QWORD *)qword_1EE009598)
      uhash_close(*(void ***)qword_1EE009598);
    icu::UMemory::operator delete(v2);
  }
  qword_1EE009598 = 0;
  atomic_store(0, (unsigned int *)&unk_1EE0095A0);
  return 1;
}

void sub_18BC331AC(char *a1, int a2)
{
  uint64_t v3;
  char *v4;
  char *v5;
  char v6;

  if (a2 >= 1)
  {
    v3 = a2;
    v4 = a1 + 20;
    v5 = a1 + 20;
    do
    {
      v6 = *v5;
      v5 += 24;
      if ((v6 & 1) != 0)
        uprv_free(*(void **)(v4 - 12));
      v4 = v5;
      --v3;
    }
    while (v3);
  }
  uprv_free(a1);
}

uint64_t sub_18BC33204()
{
  unsigned int v0;
  unint64_t v1;
  uint64_t *v2;
  int32x2_t *v3;
  uint64_t *v4;
  uint64_t v5;
  int *v6;
  __int128 v7;
  const icu::UnicodeSet *v8;
  void *v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t *String;
  int v13;
  int v14;
  unint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  icu::UnicodeString *v32;
  unint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  UChar **v36;
  icu::UnicodeString *v37;
  uint64_t v38;
  UChar **v39;
  UChar **v40;
  unint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  icu::UnicodeString *v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t *v48;
  icu::UnicodeString *v49;
  uint64_t v50;
  void *v51;
  int v53;
  _OWORD v54[4];
  _QWORD v55[3];
  _QWORD v56[3];
  _OWORD v57[4];
  _OWORD v58[4];
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v0 = atomic_load((unsigned int *)&unk_1EE0095A0);
  if (v0 == 2 || !icu::umtx_initImplPreInit((unsigned int *)&unk_1EE0095A0))
    return qword_1EE009598;
  v53 = 0;
  sub_18BC0ECC4(0xEu, (uint64_t)sub_18BC33118);
  v3 = (int32x2_t *)icu::UMemory::operator new(v2, (icu::UMemory *)0x58, v1);
  if (!v3)
    goto LABEL_103;
  v4 = (uint64_t *)v3;
  *v3 = 0;
  v5 = (uint64_t)&v3[1];
  uhash_init(v3 + 1, (uint64_t)uhash_hashUnicodeString, (uint64_t)uhash_compareUnicodeString, 0, &v53);
  if (v53 > 0)
    goto LABEL_100;
  *v4 = v5;
  uhash_setKeyDeleter(v5, (uint64_t)uprv_deleteUObject);
  if (v53 >= 1)
    goto LABEL_100;
  uhash_setValueDeleter(*v4, (uint64_t)sub_18BC33960);
  if (v53 > 0)
    goto LABEL_100;
  v6 = &dword_18BE14A24;
  v7 = 0uLL;
  while (2)
  {
    v58[2] = v7;
    v58[3] = v7;
    v58[0] = v7;
    v58[1] = v7;
    icu::UnicodeString::UnicodeString((uint64_t)v58, v6[1]);
    v8 = (const icu::UnicodeSet *)icu::unisets::get(*v6);
    if (!v8)
    {
LABEL_98:
      icu::UnicodeString::~UnicodeString(v9, (icu::UnicodeString *)v58);
      break;
    }
    memset(v54, 0, sizeof(v54));
    icu::UnicodeSetIterator::UnicodeSetIterator((icu::UnicodeSetIterator *)v54, v8);
    while (icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)v54))
    {
      memset(v57, 0, sizeof(v57));
      String = icu::UnicodeSetIterator::getString((icu::UnicodeSetIterator *)v54, v10, v11);
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)v57, (UChar **)String);
      if ((BYTE8(v57[0]) & 1) != 0)
      {
        v15 = WORD4(v58[0]);
        if ((BYTE8(v58[0]) & 1) != 0)
          goto LABEL_92;
      }
      else
      {
        if ((SWORD4(v57[0]) & 0x8000u) == 0)
          v13 = WORD4(v57[0]) >> 5;
        else
          v13 = HIDWORD(v57[0]);
        if ((SWORD4(v58[0]) & 0x8000u) == 0)
          v14 = WORD4(v58[0]) >> 5;
        else
          v14 = HIDWORD(v58[0]);
        if ((BYTE8(v58[0]) & 1) == 0
          && v13 == v14
          && icu::UnicodeString::doEquals((icu::UnicodeString *)v57, (const icu::UnicodeString *)v58, v13))
        {
          goto LABEL_92;
        }
      }
      v15 = v53;
      if (v53 > 0)
        goto LABEL_97;
      if ((BYTE8(v58[0]) & 1) != 0)
      {
        if ((BYTE8(v57[0]) & 1) != 0)
          goto LABEL_91;
      }
      else
      {
        if ((SWORD4(v58[0]) & 0x8000u) == 0)
          v16 = WORD4(v58[0]) >> 5;
        else
          v16 = HIDWORD(v58[0]);
        if ((SWORD4(v57[0]) & 0x8000u) == 0)
          v17 = WORD4(v57[0]) >> 5;
        else
          v17 = HIDWORD(v57[0]);
        if ((BYTE8(v57[0]) & 1) == 0
          && v16 == v17
          && icu::UnicodeString::doEquals((icu::UnicodeString *)v58, (const icu::UnicodeString *)v57, v16))
        {
          goto LABEL_91;
        }
      }
      v56[1] = v58;
      v56[2] = v58;
      v55[2] = v57;
      v56[0] = v4;
      v55[0] = v4;
      v55[1] = v57;
      v18 = sub_18BC30348((uint64_t)v56);
      v19 = sub_18BC30348((uint64_t)v55);
      v22 = v19;
      if (v18 && v19)
      {
        v23 = v19;
        v24 = v18;
        while (1)
        {
          v25 = *(unsigned __int16 *)(v24 + 8);
          if ((v25 & 1) != 0)
          {
            if ((BYTE8(v57[0]) & 1) != 0)
              goto LABEL_91;
          }
          else
          {
            if ((v25 & 0x8000) != 0)
              v26 = *(_DWORD *)(v24 + 12);
            else
              v26 = v25 >> 5;
            if ((SWORD4(v57[0]) & 0x8000u) == 0)
              v27 = WORD4(v57[0]) >> 5;
            else
              v27 = HIDWORD(v57[0]);
            if ((BYTE8(v57[0]) & 1) == 0
              && v26 == v27
              && icu::UnicodeString::doEquals((icu::UnicodeString *)v24, (const icu::UnicodeString *)v57, v26))
            {
              goto LABEL_91;
            }
          }
          v28 = *(unsigned __int16 *)(v23 + 8);
          if ((v28 & 1) != 0)
          {
            if ((BYTE8(v58[0]) & 1) != 0)
              goto LABEL_91;
          }
          else
          {
            if ((v28 & 0x8000) != 0)
              v29 = *(_DWORD *)(v23 + 12);
            else
              v29 = v28 >> 5;
            if ((SWORD4(v58[0]) & 0x8000u) == 0)
              v30 = WORD4(v58[0]) >> 5;
            else
              v30 = HIDWORD(v58[0]);
            if ((BYTE8(v58[0]) & 1) == 0
              && v29 == v30
              && icu::UnicodeString::doEquals((icu::UnicodeString *)v23, (const icu::UnicodeString *)v58, v29))
            {
              goto LABEL_91;
            }
          }
          v24 = sub_18BC30348((uint64_t)v56);
          v31 = sub_18BC30348((uint64_t)v55);
          if (v24)
          {
            v23 = v31;
            if (v31)
              continue;
          }
          break;
        }
      }
      v32 = (icu::UnicodeString *)icu::UMemory::operator new(v21, (icu::UMemory *)0x40, v20);
      v35 = (uint64_t)v32;
      if (v22 | v18)
      {
        if (!v22)
        {
          if (v32)
          {
            v40 = (UChar **)v57;
LABEL_77:
            icu::UnicodeString::UnicodeString(v32, v40);
          }
LABEL_78:
          v37 = (icu::UnicodeString *)icu::UMemory::operator new(v34, (icu::UMemory *)0x40, v33);
          if (!v37)
          {
LABEL_86:
            if (v35)
              goto LABEL_89;
            goto LABEL_90;
          }
          v38 = (uint64_t)v37;
          v39 = (UChar **)v18;
          goto LABEL_80;
        }
        if (v18)
        {
          if (v32)
          {
            v40 = (UChar **)v22;
            goto LABEL_77;
          }
          goto LABEL_78;
        }
        if (v32)
        {
          v36 = (UChar **)v22;
          goto LABEL_68;
        }
      }
      else if (v32)
      {
        v36 = (UChar **)v57;
LABEL_68:
        icu::UnicodeString::UnicodeString(v32, v36);
      }
      v37 = (icu::UnicodeString *)icu::UMemory::operator new(v34, (icu::UMemory *)0x40, v33);
      if (!v37)
        goto LABEL_86;
      v38 = (uint64_t)v37;
      v39 = (UChar **)v58;
LABEL_80:
      icu::UnicodeString::UnicodeString(v37, v39);
      if (!v35)
      {
        v35 = v38;
LABEL_89:
        (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
LABEL_90:
        v53 = 7;
        goto LABEL_91;
      }
      v43 = *v4;
      v44 = (icu::UnicodeString *)icu::UMemory::operator new(v42, (icu::UMemory *)0x40, v41);
      v45 = (uint64_t)v44;
      if (v44)
        icu::UnicodeString::UnicodeString(v44, (UChar **)v58);
      uhash_put(v43, v45, v35, &v53);
      v46 = *v4;
      v49 = (icu::UnicodeString *)icu::UMemory::operator new(v48, (icu::UMemory *)0x40, v47);
      v50 = (uint64_t)v49;
      if (v49)
        icu::UnicodeString::UnicodeString(v49, (UChar **)v57);
      uhash_put(v46, v50, v38, &v53);
LABEL_91:
      v15 = v53;
      if (v53 >= 1)
      {
LABEL_97:
        icu::UnicodeString::~UnicodeString((void *)v15, (icu::UnicodeString *)v57);
        icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v54);
        goto LABEL_98;
      }
LABEL_92:
      icu::UnicodeString::~UnicodeString((void *)v15, (icu::UnicodeString *)v57);
    }
    icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v54);
    icu::UnicodeString::~UnicodeString(v51, (icu::UnicodeString *)v58);
    v6 += 2;
    v7 = 0uLL;
    if (v6 != (int *)&unk_18BE14A4C)
      continue;
    break;
  }
  if (v53 < 1)
  {
    qword_1EE009598 = (uint64_t)v4;
  }
  else
  {
LABEL_100:
    if (*v4)
      uhash_close((void **)*v4);
    icu::UMemory::operator delete(v4);
  }
LABEL_103:
  icu::umtx_initImplPostInit((unsigned int *)&unk_1EE0095A0);
  return qword_1EE009598;
}

UChar *sub_18BC33728(UChar *src, int32_t srcLength, char *locale)
{
  int32_t v6;
  int32_t v7;
  int32_t v8;
  UChar *v9;
  UErrorCode pErrorCode;

  pErrorCode = U_ZERO_ERROR;
  v6 = u_strToUpper(0, 0, src, srcLength, locale, &pErrorCode);
  v7 = v6;
  pErrorCode = U_ZERO_ERROR;
  if (v6 <= srcLength)
    v8 = srcLength;
  else
    v8 = v6;
  v9 = (UChar *)uprv_malloc(2 * v8);
  u_strToUpper(v9, v7, src, srcLength, locale, &pErrorCode);
  if (pErrorCode >= U_ILLEGAL_ARGUMENT_ERROR)
    u_memcpy(v9, src, srcLength);
  return v9;
}

uint64_t sub_18BC337D8(icu::CharString *a1)
{
  _QWORD v3[2];
  char *v4;
  int v5;
  const void *v6;
  uint64_t v7;
  UErrorCode v8;
  void *v9[9];

  v9[8] = *(void **)MEMORY[0x1E0C80C00];
  if (!*((_DWORD *)a1 + 14))
    return 0;
  v8 = U_ZERO_ERROR;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v6, "en_GB");
  if (sub_18BC33974((uint64_t)a1, v6, v7))
  {
    icu::CharString::truncate((uint64_t)a1, 3);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v4, "001");
    icu::CharString::append(a1, v4, v5, &v8);
  }
  else
  {
    memset(&v9[1], 0, 56);
    v9[0] = (char *)&v9[1] + 5;
    LODWORD(v9[1]) = 40;
    v3[0] = 0;
    v3[1] = 0;
    icu::CharStringByteSink::CharStringByteSink(v3, (uint64_t)v9);
    ulocimp_getParent(*(char **)a1, (uint64_t)v3, (int *)&v8);
    icu::CharString::operator=((uint64_t)a1, (uint64_t)v9);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v3);
    if (BYTE4(v9[1]))
      uprv_free(v9[0]);
  }
  return 1;
}

uint64_t sub_18BC33900(uint64_t a1, uint64_t a2)
{
  signed int v2;
  signed int v3;
  uint64_t v4;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  _BOOL4 v11;

  v2 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a2 + 16);
  if (v2 >= v3)
    v4 = v3;
  else
    v4 = v2;
  if ((int)v4 < 1)
  {
LABEL_9:
    v10 = v2 < v3;
    v11 = v2 > v3;
    if (v10)
      return 0xFFFFFFFFLL;
    else
      return v11;
  }
  else
  {
    v5 = *(unsigned __int16 **)(a1 + 8);
    v6 = *(unsigned __int16 **)(a2 + 8);
    while (1)
    {
      v8 = *v5++;
      v7 = v8;
      v9 = *v6++;
      v10 = v7 > v9;
      if (v7 < v9)
        return 0xFFFFFFFFLL;
      if (v10)
        return 1;
      if (!--v4)
        goto LABEL_9;
    }
  }
}

uint64_t sub_18BC33960(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

BOOL sub_18BC33974(uint64_t a1, const void *a2, int a3)
{
  if (*(_DWORD *)(a1 + 56) != a3)
    return 0;
  if (a3)
    return memcmp(*(const void **)a1, a2, a3) == 0;
  return 1;
}

void sub_18BC339BC(void **a1)
{
  uprv_free(a1[1]);
  uprv_free(a1);
}

uint64_t sub_18BC339E4(uint64_t a1)
{
  uint64_t result;
  int v3;
  char **v4;
  char *v5;

  result = 0;
  v3 = **(_DWORD **)(a1 + 8);
  v4 = &off_1E22512C0;
  do
  {
    if (v3 == 0x7FFFFFFF || (v3 & ~*((_DWORD *)v4 - 2)) == 0)
      result = (result + 1);
    v5 = *v4;
    v4 += 2;
  }
  while (v5);
  return result;
}

uint64_t sub_18BC33A24(uint64_t a1, _DWORD *a2)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  char **v5;
  _DWORD *v6;
  uint64_t result;

  v2 = *(_DWORD **)(a1 + 8);
  v3 = v2[1];
  if (v3 <= 0x132)
    v4 = 306;
  else
    v4 = v3;
  v5 = &(&off_1E22512B0)[2 * v3 + 1];
  while (v4 != v3)
  {
    v6 = v5;
    v2[1] = v3 + 1;
    if (*v2 != 0x7FFFFFFF)
    {
      v5 += 2;
      ++v3;
      if ((*v2 & ~*v6) != 0)
        continue;
    }
    if (a2)
      *a2 = 3;
    return *((_QWORD *)v6 - 1);
  }
  result = 0;
  if (a2)
    *a2 = 0;
  return result;
}

uint64_t sub_18BC33AA4(uint64_t result)
{
  *(_DWORD *)(*(_QWORD *)(result + 8) + 4) = 0;
  return result;
}

uint64_t sub_18BC33AB0(uint64_t a1, const char *DataDirectory, const char *a3, char *__s, const char *a5, char a6, UErrorCode *a7)
{
  uint64_t v13;
  icu::CharString *v14;
  icu::CharString *v15;
  icu::CharString *v16;
  char *v17;
  const char *v18;
  icu::CharString *v19;
  const char *v20;
  uint64_t v22;
  int v23;
  char *v24;
  int v25;

  *(_QWORD *)(a1 + 24) = 0;
  v13 = a1 + 24;
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 48) = a1 + 61;
  v14 = (icu::CharString *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = 40;
  *(_WORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = a1 + 125;
  *(_DWORD *)(a1 + 120) = 40;
  *(_WORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = a1 + 189;
  v15 = (icu::CharString *)(a1 + 176);
  *(_DWORD *)(a1 + 184) = 40;
  *(_WORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  if (!DataDirectory)
    DataDirectory = u_getDataDirectory();
  *(_QWORD *)a1 = DataDirectory;
  if (a3)
  {
    v16 = icu::CharString::append(v15, 47, a7);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v24, a3);
    icu::CharString::append(v16, v24, v25, a7);
  }
  v17 = strrchr(__s, 47);
  if (v17)
    v18 = v17 + 1;
  else
    v18 = __s;
  *(_QWORD *)(a1 + 16) = v18;
  *(_DWORD *)(a1 + 40) = strlen(v18);
  v19 = (icu::CharString *)a1;
  if (v18 != __s)
  {
    icu::CharString::append(v14, __s, (_DWORD)v18 - (_DWORD)__s, a7);
    v19 = v14;
  }
  *(_QWORD *)(a1 + 8) = *(_QWORD *)v19;
  if (a5)
    v20 = a5;
  else
    v20 = "";
  icu::StringPiece::StringPiece((icu::StringPiece *)&v22, v20);
  *(_QWORD *)v13 = v22;
  *(_DWORD *)(v13 + 8) = v23;
  *(_BYTE *)(a1 + 240) = a6;
  return a1;
}

uint64_t sub_18BC33C2C(uint64_t a1, UErrorCode *a2)
{
  icu::CharString *v5;
  const char *v6;
  char *v7;
  size_t v8;
  char *v9;
  char *v10;
  const char *v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;

  if (*(int *)a2 <= 0)
  {
    v5 = (icu::CharString *)(a1 + 112);
    while (1)
    {
      v6 = *(const char **)(a1 + 8);
      if (!v6)
        return 0;
      if (v6 == *(const char **)(a1 + 48))
        break;
      v7 = strchr(*(char **)(a1 + 8), 58);
      *(_QWORD *)(a1 + 8) = v7;
      if (!v7)
        goto LABEL_10;
      v8 = v7 - v6;
      *(_QWORD *)(a1 + 8) = v7 + 1;
      if ((_DWORD)v7 == (_DWORD)v6)
        goto LABEL_22;
LABEL_11:
      *(_DWORD *)(a1 + 168) = 0;
      **(_BYTE **)(a1 + 112) = 0;
      icu::CharString::append(v5, v6, v8, a2);
      v9 = *(char **)(a1 + 112);
      v10 = strrchr(v9, 47);
      if (v10)
        v11 = v10 + 1;
      else
        v11 = v9;
      if ((int)v8 >= 4)
      {
        if (*(_BYTE *)(a1 + 240))
        {
          if (!strncmp(&v9[(v8 - 4)], *(const char **)(a1 + 24), 4uLL))
          {
            v12 = *(_DWORD *)(a1 + 40);
            if (!strncmp(v11, *(const char **)(a1 + 16), v12) && strlen(v11) == v12 + 4)
              return *(_QWORD *)v5;
          }
        }
      }
      if (v9[(uint64_t)((v8 << 32) - 0x100000000) >> 32] == 47)
        goto LABEL_29;
      if ((int)v8 < 4 || strncmp(&v9[(v8 - 4)], ".dat", 4uLL))
      {
        v13 = *(_DWORD *)(a1 + 232);
        if (v13)
        {
          if ((int)v8 > v13)
          {
            v14 = *(_DWORD *)(a1 + 232);
            if (!strcmp(&v9[(int)v8 - v13], *(const char **)(a1 + 176)))
              icu::CharString::truncate((uint64_t)v5, v8 - v14);
          }
        }
        icu::CharString::append(v5, 47, a2);
LABEL_29:
        icu::CharString::append(v5, (const char *)(*(_QWORD *)(a1 + 176) + 1), *(_DWORD *)(a1 + 232) - 1, a2);
        v15 = *(_DWORD *)(a1 + 32);
        if (v15)
        {
          if (v15 >= 5)
            icu::CharString::ensureEndsWithFileSeparator(v5, a2);
          icu::CharString::append(v5, *(const char **)(a1 + 24), *(_DWORD *)(a1 + 32), a2);
        }
        return *(_QWORD *)v5;
      }
LABEL_22:
      if (!*(_QWORD *)a1)
        return 0;
    }
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
LABEL_10:
    v8 = strlen(v6);
    if (!(_DWORD)v8)
      goto LABEL_22;
    goto LABEL_11;
  }
  return 0;
}

void udata_setCommonData(uint64_t a1, int *a2)
{
  _OWORD v4[3];
  uint64_t v5;

  if (a2 && *a2 <= 0)
  {
    if (a1)
    {
      v5 = 0;
      memset(v4, 0, sizeof(v4));
      sub_18BC354B0((uint64_t)v4);
      sub_18BC3557C((uint64_t)v4, a1);
      sub_18BC0ED90(v4, a2);
      if (*a2 <= 0)
        sub_18BC33EE0((uint64_t)v4, 1, a2);
    }
    else
    {
      *a2 = 1;
    }
  }
}

void sub_18BC33EE0(uint64_t a1, int a2, int *a3)
{
  _QWORD *NewInstance;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  NewInstance = UDataMemory_createNewInstance(a3);
  if (*a3 <= 0)
  {
    v7 = NewInstance;
    sub_18BC354CC((uint64_t)NewInstance, a1);
    umtx_lock(0);
    v8 = 0;
    while (1)
    {
      v9 = qword_1ECD27A90[v8];
      if (!v9)
        break;
      if (*(_QWORD *)(v9 + 8) != *(_QWORD *)(a1 + 8) && ++v8 != 10)
        continue;
      goto LABEL_8;
    }
    qword_1ECD27A90[v8] = (uint64_t)v7;
LABEL_8:
    umtx_unlock(0);
    if (a2 && (_DWORD)v8 == 10)
      *a3 = -127;
    if (v9)
      uprv_free(v7);
    else
      sub_18BC0ECC4(0x18u, (uint64_t)sub_18BC34BA4);
  }
}

void **udata_setAppData(void **result, uint64_t a2, int *a3)
{
  char *v5;
  _OWORD v6[3];
  uint64_t v7;

  if (a3 && *a3 <= 0)
  {
    if (a2)
    {
      v5 = (char *)result;
      v7 = 0;
      memset(v6, 0, sizeof(v6));
      sub_18BC354B0((uint64_t)v6);
      sub_18BC3557C((uint64_t)v6, a2);
      sub_18BC0ED90(v6, a3);
      return sub_18BC34060(v5, (uint64_t)v6, a3);
    }
    else
    {
      *a3 = 1;
    }
  }
  return result;
}

void **sub_18BC34060(char *a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  void **result;
  void **v9;
  _QWORD *NewInstance;
  char *v11;
  const char *v12;
  int v13;
  char *v14;
  uint64_t v15;
  int v16;

  v16 = 0;
  v6 = sub_18BC34C14(a3);
  if (*a3 > 0)
    return 0;
  v7 = v6;
  result = (void **)uprv_malloc(0x10uLL);
  if (!result)
  {
    *a3 = 7;
    return result;
  }
  v9 = result;
  NewInstance = UDataMemory_createNewInstance(a3);
  v9[1] = NewInstance;
  if (*a3 >= 1)
    goto LABEL_4;
  sub_18BC354CC((uint64_t)NewInstance, a2);
  v11 = strrchr(a1, 47);
  if (v11)
    v12 = v11 + 1;
  else
    v12 = a1;
  v13 = strlen(v12);
  v14 = (char *)uprv_malloc(v13 + 1);
  *v9 = v14;
  if (!v14)
  {
    *a3 = 7;
    uprv_free(v9[1]);
LABEL_4:
    uprv_free(v9);
    return 0;
  }
  strcpy(v14, v12);
  umtx_lock(0);
  v15 = uhash_get(v7, (uint64_t)a1);
  if (v15)
    v16 = -127;
  else
    uhash_put(v7, (uint64_t)*v9, (uint64_t)v9, &v16);
  umtx_unlock(0);
  if (v16 != -127 && v16 < 1)
    return (void **)v9[1];
  *a3 = v16;
  uprv_free(*v9);
  uprv_free(v9[1]);
  uprv_free(v9);
  if (v15)
    return *(void ***)(v15 + 8);
  return 0;
}

_QWORD *udata_open(char *a1, const char *a2, const char *a3, UErrorCode *a4)
{
  if (a4 && *(int *)a4 <= 0)
  {
    if (a3 && *a3)
      return sub_18BC34210(a1, a2, a3, 0, 0, a4);
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return 0;
}

_QWORD *sub_18BC34210(char *__s1, const char *a2, const char *a3, unsigned int (*a4)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a5, UErrorCode *a6)
{
  char *v9;
  int v10;
  char v11;
  char *v12;
  char *v13;
  char *v14;
  int v15;
  char *v16;
  int v17;
  uint64_t v18;
  icu::CharString *v19;
  icu::CharString *v20;
  icu::CharString *v21;
  icu::CharString *v22;
  icu::CharString *v23;
  icu::CharString *v24;
  const char *v25;
  const char *DataDirectory;
  _QWORD *v27;
  unsigned int v28;
  char v29;
  const char *TimeZoneFilesDirectory;
  icu::CharString *v31;
  icu::CharString *v32;
  icu::CharString *v33;
  icu::CharString *v34;
  _QWORD *v35;
  _BOOL4 v36;
  int v37;
  const char *v39;
  char *v42;
  int v43;
  char *v44;
  int v45;
  char *v46;
  int v47;
  char *v48;
  int v49;
  char *v50;
  int v51;
  char *v52;
  int v53;
  UErrorCode v54;
  char *v55;
  int v56;
  char *v57;
  int v58;
  char *v59;
  int v60;
  char *v61;
  int v62;
  char *v63;
  int v64;
  char *v65;
  int v66;
  char *v67;
  int v68;
  char *v69;
  int v70;
  char *v71;
  int v72;
  char *v73;
  int v74;
  char *v75;
  int v76;
  char *v77;
  int v78;
  char *v79;
  int v80;
  int v81;
  void *v82[8];
  void *v83[8];
  char *v84[7];
  int v85[2];
  char *v86[7];
  int v87[2];
  void *v88[8];
  void *v89[7];
  uint64_t v90;
  uint64_t v91;

  v9 = __s1;
  v91 = *MEMORY[0x1E0C80C00];
  v81 = 0;
  if (!__s1 || !strcmp(__s1, "ICUDATA") || !strncmp(v9, "icudt74l-", 9uLL) || !strncmp(v9, "ICUDATA-", 8uLL))
  {
    v11 = 0;
    v10 = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
  }
  memset(&v89[1], 0, 48);
  v90 = 0;
  v89[0] = (char *)&v89[1] + 5;
  LODWORD(v89[1]) = 40;
  memset(&v88[1], 0, 56);
  v88[0] = (char *)&v88[1] + 5;
  LODWORD(v88[1]) = 40;
  memset(&v86[1], 0, 48);
  v87[1] = 0;
  v86[0] = (char *)&v86[1] + 5;
  LODWORD(v86[1]) = 40;
  v87[0] = 0;
  memset(&v84[1], 0, 48);
  v85[1] = 0;
  v84[0] = (char *)&v84[1] + 5;
  LODWORD(v84[1]) = 40;
  v85[0] = 0;
  if (!v9)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v79, "icudt74l");
    v16 = v79;
    v17 = v80;
LABEL_23:
    icu::CharString::append((icu::CharString *)v86, v16, v17, a6);
    goto LABEL_24;
  }
  v12 = strrchr(v9, 47);
  v13 = strchr(v9, 47);
  if (uprv_pathIsAbsolute((unsigned __int8 *)v9) || v12 != v13)
  {
    if (v12)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v77, v12 + 1);
      v16 = v77;
      v17 = v78;
    }
    else
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v75, v9);
      v16 = v75;
      v17 = v76;
    }
    goto LABEL_23;
  }
  v14 = strchr(v9, 45);
  if (!v14)
  {
    if ((v11 & 1) != 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v67, v9);
      v16 = v67;
      v17 = v68;
    }
    else
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v69, "icudt74l");
      v16 = v69;
      v17 = v70;
    }
    goto LABEL_23;
  }
  v15 = (int)v14;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v73, v14 + 1);
  icu::CharString::append((icu::CharString *)v84, v73, v74, a6);
  if ((v11 & 1) == 0)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v71, "icudt74l");
    v16 = v71;
    v17 = v72;
    goto LABEL_23;
  }
  icu::CharString::append((icu::CharString *)v86, v9, v15 - (_DWORD)v9, a6);
  if (!v12)
    v9 = v86[0];
LABEL_24:
  icu::CharString::append((icu::CharString *)v89, v86[0], v87[0], a6);
  icu::CharString::append((icu::CharString *)v88, v86[0], v87[0], a6);
  v18 = (int)v90;
  if (v85[0])
  {
    v19 = icu::CharString::append((icu::CharString *)v89, 47, a6);
    icu::CharString::append(v19, v84[0], v85[0], a6);
    v20 = icu::CharString::append((icu::CharString *)v88, 47, a6);
    icu::CharString::append(v20, v84[0], v85[0], a6);
  }
  v21 = icu::CharString::append((icu::CharString *)v89, 47, a6);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v65, a3);
  icu::CharString::append(v21, v65, v66, a6);
  v22 = icu::CharString::append((icu::CharString *)v88, 47, a6);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v63, a3);
  icu::CharString::append(v22, v63, v64, a6);
  if (a2 && *a2)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v61, ".");
    v23 = icu::CharString::append((icu::CharString *)v89, v61, v62, a6);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v59, a2);
    icu::CharString::append(v23, v59, v60, a6);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v57, ".");
    v24 = icu::CharString::append((icu::CharString *)v88, v57, v58, a6);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v55, a2);
    icu::CharString::append(v24, v55, v56, a6);
  }
  v25 = (char *)v88[0] + v18 + 1;
  if (!v9)
    v9 = "icudt74l";
  DataDirectory = u_getDataDirectory();
  if (v10
    && !strcmp(a2, "res")
    && (!strcmp(a3, "zoneinfo64")
     || !strcmp(a3, "timezoneTypes")
     || !strcmp(a3, "windowsZones")
     || !strcmp(a3, "metaZones"))
    && (TimeZoneFilesDirectory = u_getTimeZoneFilesDirectory(a6), *TimeZoneFilesDirectory))
  {
    v54 = U_ZERO_ERROR;
    memset(&v83[1], 0, 56);
    v83[0] = (char *)&v83[1] + 5;
    LODWORD(v83[1]) = 40;
    v39 = TimeZoneFilesDirectory;
    icu::StringPiece::StringPiece((icu::StringPiece *)&v52, TimeZoneFilesDirectory);
    icu::CharString::append((icu::CharString *)v83, v52, v53, &v54);
    v31 = icu::CharString::append((icu::CharString *)v83, 47, &v54);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v50, "icutz44l");
    icu::CharString::append(v31, v50, v51, &v54);
    memset(&v82[1], 0, 56);
    v82[0] = (char *)&v82[1] + 5;
    LODWORD(v82[1]) = 40;
    icu::StringPiece::StringPiece((icu::StringPiece *)&v48, "icutz44l");
    icu::CharString::append((icu::CharString *)v82, v48, v49, &v54);
    if (v85[0])
    {
      v32 = icu::CharString::append((icu::CharString *)v82, 47, &v54);
      icu::CharString::append(v32, v84[0], v85[0], &v54);
    }
    v33 = icu::CharString::append((icu::CharString *)v82, 47, &v54);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v46, a3);
    icu::CharString::append(v33, v46, v47, &v54);
    if (a2 && *a2)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v44, ".");
      v34 = icu::CharString::append((icu::CharString *)v82, v44, v45, &v54);
      icu::StringPiece::StringPiece((icu::StringPiece *)&v42, a2);
      icu::CharString::append(v34, v42, v43, &v54);
    }
    v35 = sub_18BC34D14(0, (uint64_t)v82[0], (char *)v83[0], (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, (int *)&v54);
    if (v54 > U_ZERO_ERROR || (v27 = v35, v36 = 0, !v35))
    {
      v27 = sub_18BC34F18("", v39, v25, "", (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, a6);
      if (v27)
        v36 = 0;
      else
        v36 = *a6 < U_ILLEGAL_ARGUMENT_ERROR;
    }
    if (BYTE4(v82[1]))
      uprv_free(v82[0]);
    if (BYTE4(v83[1]))
      uprv_free(v83[0]);
    if (!v36)
      goto LABEL_81;
  }
  else
  {
    v27 = 0;
  }
  v28 = dword_1EE008E70;
  if (dword_1EE008E70 == 2)
  {
    v27 = sub_18BC34D14(v10, (uint64_t)v89[0], v9, (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, (int *)a6);
    if (v27)
      goto LABEL_81;
    if (*(int *)a6 > 0)
      goto LABEL_74;
    v27 = 0;
    v28 = dword_1EE008E70;
  }
  if ((v28 & 0xFFFFFFFD) == 0)
  {
    if (DataDirectory)
    {
      if (*DataDirectory)
        v29 = 0;
      else
        v29 = v10;
      if ((v29 & 1) != 0)
        goto LABEL_39;
    }
    else if ((v10 & 1) != 0)
    {
      goto LABEL_39;
    }
    v27 = sub_18BC34F18(v86[0], DataDirectory, v25, v9, (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, a6);
    if (v27)
      goto LABEL_81;
    if (*(int *)a6 > 0)
      goto LABEL_74;
    v27 = 0;
    v28 = dword_1EE008E70;
  }
LABEL_39:
  if (v28 <= 1)
  {
    v27 = sub_18BC34D14(v10, (uint64_t)v89[0], v9, (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, (int *)a6);
    if (v27)
      goto LABEL_81;
    if (*(int *)a6 <= 0)
    {
      v27 = 0;
      v28 = dword_1EE008E70;
      goto LABEL_43;
    }
LABEL_74:
    v27 = 0;
    goto LABEL_81;
  }
LABEL_43:
  if (v28 == 3)
  {
    v27 = sub_18BC34D14(v10, (uint64_t)v89[0], v9, (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, (int *)a6);
    if (v27 || *(int *)a6 >= 1)
      goto LABEL_81;
  }
  else if (*(int *)a6 > 0)
  {
    goto LABEL_81;
  }
  v37 = v81;
  if (v81 <= 0)
    v37 = 4;
  *a6 = v37;
LABEL_81:
  if (BYTE4(v84[1]))
    uprv_free(v84[0]);
  if (BYTE4(v86[1]))
    uprv_free(v86[0]);
  if (BYTE4(v88[1]))
    uprv_free(v88[0]);
  if (BYTE4(v89[1]))
    uprv_free(v89[0]);
  return v27;
}

_QWORD *udata_openChoice(char *a1, const char *a2, const char *a3, unsigned int (*a4)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a5, UErrorCode *a6)
{
  if (a6 && *(int *)a6 <= 0)
  {
    if (a3 && a4 && *a3)
      return sub_18BC34210(a1, a2, a3, a4, a5, a6);
    *a6 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return 0;
}

_QWORD *udata_getInfo(_QWORD *result, _WORD *a2)
{
  _BYTE *v3;
  unsigned int v4;
  unsigned int v5;
  _WORD *v6;

  if (a2)
  {
    if (result && (v3 = (_BYTE *)result[1]) != 0)
    {
      v4 = sub_18BC0ED64(v3 + 4);
      v5 = (unsigned __int16)*a2;
      if (v5 > v4)
      {
        *a2 = v4;
        v5 = v4;
      }
      v6 = a2 + 1;
      result = memcpy(v6, v3 + 6, v5 - 2);
      if (v3[8])
        *v6 = bswap32(*((unsigned __int16 *)v3 + 3)) >> 16;
    }
    else
    {
      *a2 = 0;
    }
  }
  return result;
}

uint64_t udata_setFileAccess(uint64_t result)
{
  dword_1EE008E70 = result;
  return result;
}

uint64_t sub_18BC34BA4()
{
  uint64_t v0;
  _OWORD *v1;

  if (qword_1ECD27AE0)
  {
    uhash_close((void **)qword_1ECD27AE0);
    qword_1ECD27AE0 = 0;
  }
  v0 = 0;
  atomic_store(0, &dword_1ECD27AE8);
  do
  {
    v1 = (_OWORD *)qword_1ECD27A90[v0];
    if (!v1)
      break;
    udata_close(v1);
    qword_1ECD27A90[v0++] = 0;
  }
  while (v0 != 10);
  atomic_store(0, (unsigned int *)&unk_1ECD27AF0);
  return 1;
}

uint64_t sub_18BC34C14(int *a1)
{
  unsigned int v2;
  int32x2_t *v3;
  int v4;

  if (*a1 <= 0)
  {
    v2 = atomic_load(&dword_1ECD27AE8);
    if (v2 == 2 || !icu::umtx_initImplPreInit(&dword_1ECD27AE8))
    {
      if (dword_1ECD27AEC >= 1)
        *a1 = dword_1ECD27AEC;
    }
    else
    {
      v3 = uhash_open((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0, a1);
      qword_1ECD27AE0 = (uint64_t)v3;
      v4 = *a1;
      if (*a1 <= 0)
      {
        uhash_setValueDeleter((uint64_t)v3, (uint64_t)sub_18BC34CE4);
        sub_18BC0ECC4(0x18u, (uint64_t)sub_18BC34BA4);
        v4 = *a1;
      }
      dword_1ECD27AEC = v4;
      icu::umtx_initImplPostInit(&dword_1ECD27AE8);
    }
  }
  return qword_1ECD27AE0;
}

void sub_18BC34CE4(uint64_t a1)
{
  udata_close(*(_OWORD **)(a1 + 8));
  uprv_free(*(void **)a1);
  uprv_free((void *)a1);
}

_QWORD *sub_18BC34D14(int a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, unsigned int (*a6)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a7, int *a8, int *a9)
{
  int v13;
  unsigned int v14;
  uint64_t (***v15)(_QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t (***v16)(_QWORD, _QWORD, _QWORD, _QWORD);
  int v17;
  uint64_t v19;
  _QWORD *result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD v31[2];
  __int128 v32;
  uint64_t v33;

  v13 = 0;
  if (a1)
    v14 = 0;
  else
    v14 = -1;
  while (1)
  {
    v15 = (uint64_t (***)(_QWORD, _QWORD, _QWORD, _QWORD))sub_18BC350A8(a3, v14, a8);
    v16 = v15;
    v17 = *a8;
    if (*a8 <= 0 && v15 != 0)
      break;
LABEL_12:
    if (v17 == 7)
    {
      result = 0;
      *a9 = 7;
      return result;
    }
    if (!a1)
      return 0;
    if (v16)
    {
      ++v14;
    }
    else
    {
      if (v13)
        return 0;
      v33 = 0;
      v32 = 0u;
      memset(v31, 0, sizeof(v31));
      if (!atomic_load((unsigned int *)&unk_1ECD27AF0))
      {
        v22 = sub_18BC350A8("icudt74l", 0xFFFFFFFF, a8);
        sub_18BC354B0((uint64_t)v31);
        if (v22)
        {
          sub_18BC354CC((uint64_t)v31, v22);
          v32 = 0uLL;
          sub_18BC33EE0((uint64_t)v31, 0, a8);
        }
        atomic_store(1u, (unsigned int *)&unk_1ECD27AF0);
      }
      v23 = sub_18BC353DC("icudt74l", a8);
      if (*a8 > 0)
        return 0;
      v24 = v23;
      if (!v23)
        return 0;
      umtx_lock(0);
      v25 = 0;
      while (1)
      {
        v26 = qword_1ECD27A90[v25];
        if (v26)
        {
          if (*(_QWORD *)(v26 + 8) == *(_QWORD *)(v24 + 8))
            break;
        }
        if (++v25 == 10)
        {
          umtx_unlock(0);
          return 0;
        }
      }
      umtx_unlock(0);
      v13 = 1;
    }
  }
  LODWORD(v31[0]) = 0;
  v19 = (**v15)(v15, a2, v31, a8);
  if (!v19)
    goto LABEL_11;
  result = sub_18BC35338(v19, a6, a7, a4, a5, a8, a9);
  if (*a9 > 0)
    return 0;
  if (!result)
  {
LABEL_11:
    v17 = *a8;
    goto LABEL_12;
  }
  *((_DWORD *)result + 12) = v31[0];
  return result;
}

_QWORD *sub_18BC34F18(const char *a1, const char *a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, unsigned int (*a7)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a8, _DWORD *a9, UErrorCode *a10)
{
  uint64_t v14;
  const char *v15;
  _QWORD *v16;
  _QWORD *v17;
  _OWORD v19[2];
  __int128 v20;
  uint64_t v21;
  _OWORD v22[3];
  void *v23[2];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  void *v27[2];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  void *v31[2];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v21 = 0;
  v20 = 0u;
  memset(v19, 0, sizeof(v19));
  v35 = 0;
  v33 = 0u;
  v34 = 0u;
  *(_OWORD *)v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  *(_OWORD *)v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  *(_OWORD *)v23 = 0u;
  v24 = 0u;
  memset(v22, 0, sizeof(v22));
  sub_18BC33AB0((uint64_t)v22, a2, a1, a4, a3, 0, a10);
  v14 = sub_18BC33C2C((uint64_t)v22, a10);
  if (!v14)
  {
LABEL_8:
    v17 = 0;
    goto LABEL_9;
  }
  v15 = (const char *)v14;
  while (!uprv_mapFile(v19, v15, (int *)a10))
  {
LABEL_7:
    v15 = (const char *)sub_18BC33C2C((uint64_t)v22, a10);
    if (!v15)
      goto LABEL_8;
  }
  v16 = sub_18BC35338(*((uint64_t *)&v19[0] + 1), a7, a8, a5, a6, a9, (int *)a10);
  if (!v16)
  {
    udata_close(v19);
    if (*(int *)a10 > 0)
      goto LABEL_8;
    *a9 = 3;
    goto LABEL_7;
  }
  v17 = v16;
  *((_OWORD *)v16 + 2) = v20;
LABEL_9:
  if (BYTE4(v31[1]))
    uprv_free(v31[0]);
  if (BYTE4(v27[1]))
    uprv_free(v27[0]);
  if (BYTE4(v23[1]))
    uprv_free(v23[0]);
  return v17;
}

uint64_t sub_18BC350A8(char *a1, unsigned int a2, int *a3)
{
  uint64_t v3;
  uint64_t *v8;
  uint64_t v9;
  char *v10;
  char *v11;
  const char *DataDirectory;
  const char *v13;
  _OWORD v14[3];
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (*a3 > 0)
    return 0;
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  sub_18BC354B0((uint64_t)v14);
  if ((a2 & 0x80000000) != 0)
  {
    v10 = strrchr(a1, 47);
    if (v10)
      v11 = v10 + 1;
    else
      v11 = a1;
    if (!*v11)
    {
      if (*a3 <= 0)
      {
        v3 = 0;
        *a3 = 4;
        return v3;
      }
      return 0;
    }
    v3 = sub_18BC353DC(v11, a3);
    if (v3)
      return v3;
    if (*a3 > 0)
      return 0;
    v31 = 0;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v16 = 0u;
    DataDirectory = u_getDataDirectory();
    sub_18BC33AB0((uint64_t)&v16, DataDirectory, v11, a1, ".dat", 1, (UErrorCode *)a3);
    while (!sub_18BC35690((uint64_t)v14))
    {
      v13 = (const char *)sub_18BC33C2C((uint64_t)&v16, (UErrorCode *)a3);
      if (!v13)
        break;
      uprv_mapFile(v14, v13, a3);
    }
    if (*a3 <= 0)
    {
      if (sub_18BC35690((uint64_t)v14))
      {
        sub_18BC0ED90(v14, a3);
        v3 = (uint64_t)sub_18BC34060(v11, (uint64_t)v14, a3);
      }
      else
      {
        v3 = 0;
        *a3 = 4;
      }
    }
    else
    {
      v3 = 0;
    }
    sub_18BC35460((uint64_t)&v16);
  }
  else
  {
    if (a2 > 9)
      return 0;
    umtx_lock(0);
    v3 = qword_1ECD27A90[a2];
    if (!v3)
    {
      if (a2)
      {
        v8 = qword_1ECD27A90;
        v9 = a2;
        while (*(char **)(*v8 + 8) != " ")
        {
          ++v8;
          if (!--v9)
            goto LABEL_11;
        }
        v3 = 0;
      }
      else
      {
LABEL_11:
        umtx_unlock(0);
        *(_QWORD *)&v19 = 0;
        v17 = 0u;
        v18 = 0u;
        v16 = 0u;
        sub_18BC354B0((uint64_t)&v16);
        sub_18BC3557C((uint64_t)&v16, (uint64_t)" ");
        sub_18BC0ED90(&v16, a3);
        sub_18BC33EE0((uint64_t)&v16, 0, a3);
        umtx_lock(0);
        v3 = qword_1ECD27A90[a2];
      }
    }
    umtx_unlock(0);
  }
  return v3;
}

_QWORD *sub_18BC35338(uint64_t a1, unsigned int (*a2)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, int *a7)
{
  _QWORD *result;

  if (*a7 > 0)
    return 0;
  if (*(unsigned __int8 *)(a1 + 2) == 218 && *(_BYTE *)(a1 + 3) == 39 && (!a2 || a2(a3, a4, a5, a1 + 4)))
  {
    result = UDataMemory_createNewInstance(a7);
    if (*a7 > 0)
      return 0;
    result[1] = a1;
  }
  else
  {
    result = 0;
    *a6 = 3;
  }
  return result;
}

uint64_t sub_18BC353DC(char *a1, int *a2)
{
  uint64_t v4;
  uint64_t v6;
  char *v7;
  uint64_t v8;

  v4 = sub_18BC34C14(a2);
  if (*a2 > 0)
    return 0;
  v6 = v4;
  v7 = strrchr(a1, 47);
  if (v7)
    a1 = v7 + 1;
  umtx_lock(0);
  v8 = uhash_get(v6, (uint64_t)a1);
  umtx_unlock(0);
  if (v8)
    return *(_QWORD *)(v8 + 8);
  else
    return 0;
}

uint64_t sub_18BC35460(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 188))
    uprv_free(*(void **)(a1 + 176));
  if (*(_BYTE *)(a1 + 124))
    uprv_free(*(void **)(a1 + 112));
  if (*(_BYTE *)(a1 + 60))
    uprv_free(*(void **)(a1 + 48));
  return a1;
}

double sub_18BC354B0(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 48) = -1;
  return result;
}

__n128 sub_18BC354CC(uint64_t a1, uint64_t a2)
{
  char v2;
  __n128 result;
  __int128 v4;
  uint64_t v5;

  v2 = *(_BYTE *)(a1 + 24);
  v4 = *(_OWORD *)(a2 + 16);
  result = *(__n128 *)(a2 + 32);
  v5 = *(_QWORD *)(a2 + 48);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 48) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_BYTE *)(a1 + 24) = v2;
  return result;
}

_QWORD *UDataMemory_createNewInstance(int *a1)
{
  _QWORD *result;

  if (*a1 > 0)
    return 0;
  result = uprv_malloc(0x38uLL);
  if (result)
  {
    result[6] = 0;
    *((_OWORD *)result + 1) = 0u;
    *((_OWORD *)result + 2) = 0u;
    *(_OWORD *)result = 0u;
    *((_DWORD *)result + 12) = -1;
    *((_BYTE *)result + 24) = 1;
  }
  else
  {
    *a1 = 7;
  }
  return result;
}

uint64_t sub_18BC35558(uint64_t result)
{
  if (result && (*(unsigned __int8 *)(result + 2) != 218 || *(_BYTE *)(result + 3) != 39))
    result += 8;
  return result;
}

uint64_t sub_18BC3557C(uint64_t result, uint64_t a2)
{
  if (a2 && (*(unsigned __int8 *)(a2 + 2) != 218 || *(_BYTE *)(a2 + 3) != 39))
    a2 += 8;
  *(_QWORD *)(result + 8) = a2;
  return result;
}

double udata_close(_OWORD *a1)
{
  double result;

  if (a1)
  {
    sub_18BC43968((uint64_t)a1);
    if (*((_BYTE *)a1 + 24))
    {
      uprv_free(a1);
    }
    else
    {
      *((_QWORD *)a1 + 6) = 0;
      result = 0.0;
      a1[1] = 0u;
      a1[2] = 0u;
      *a1 = 0u;
      *((_DWORD *)a1 + 12) = -1;
    }
  }
  return result;
}

uint64_t udata_getMemory(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 8);
    if (v1)
      return v1 + sub_18BC0ED38(*(_BYTE **)(result + 8));
    else
      return 0;
  }
  return result;
}

uint64_t udata_getLength(uint64_t a1)
{
  _BYTE *v2;
  int v3;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = *(_BYTE **)(a1 + 8);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = *(_DWORD *)(a1 + 48);
  if (v3 < 0)
    return 0xFFFFFFFFLL;
  else
    return v3 - sub_18BC0ED38(v2);
}

uint64_t udata_getRawMemory(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    return 0;
  result = *(_QWORD *)(a1 + 8);
  if (!result)
    return 0;
  return result;
}

BOOL sub_18BC35690(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) != 0;
}

uint64_t udata_readInt16(uint64_t a1, unsigned __int16 a2)
{
  return (*(__int16 (**)(_QWORD))(a1 + 8))(a2);
}

uint64_t udata_readInt32(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 16))(a2);
}

uint64_t udata_swapInvStringBlock(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int *a5)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  int v12;

  if (!a5)
    return 0;
  if (*a5 > 0)
    return 0;
  if (a1 && a2 && (a3 & 0x80000000) == 0 && (!a3 || a4))
  {
    v10 = a3;
    LODWORD(v11) = a3 + 1;
    while (v10 >= 1)
    {
      v12 = *(unsigned __int8 *)(a2 + v10 - 1);
      v11 = (v11 - 1);
      --v10;
      if (!v12)
        goto LABEL_16;
    }
    v11 = 0;
LABEL_16:
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(a1 + 72))(a1, a2, v11, a4, a5);
    if (a2 != a4 && (int)a3 > (int)v11)
      memcpy((void *)(a4 + v11), (const void *)(a2 + v11), (int)(a3 - v11));
    if (*a5 <= 0)
      return a3;
    else
      return 0;
  }
  else
  {
    result = 0;
    *a5 = 1;
  }
  return result;
}

uint64_t udata_printError(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(_QWORD *)(result + 80))
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t *))(result + 80))(*(_QWORD *)(result + 88), a2, &a9);
  return result;
}

uint64_t udata_swapDataHeader(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v12;
  int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v25;
  uint64_t i;
  uint64_t v27;

  if (!a5 || *a5 > 0)
    return 0;
  if (!a1 || !a2 || (v12 = a3, (int)a3 < -1) || (int)a3 >= 1 && !a4)
  {
    v9 = 0;
    v14 = 1;
LABEL_21:
    *a5 = v14;
    return v9;
  }
  if (a3 < 0x18
    || *((unsigned __int8 *)a2 + 2) != 218
    || *((_BYTE *)a2 + 3) != 39
    || *((_BYTE *)a2 + 10) != 2)
  {
    udata_printError(a1, (uint64_t)"udata_swapDataHeader(): initial bytes do not look like ICU data\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v27);
    v9 = 0;
    v14 = 16;
    goto LABEL_21;
  }
  v15 = (*(uint64_t (**)(_QWORD))(a1 + 8))(*a2);
  v16 = (*(uint64_t (**)(_QWORD))(a1 + 8))(a2[2]);
  v9 = v15;
  if (v15 < 0x18 || v16 < 0x14 || (v23 = v16 + 4, v23 > v15) || (v12 & 0x80000000) == 0 && (int)v15 > v12)
  {
    udata_printError(a1, (uint64_t)"udata_swapDataHeader(): header size mismatch - headerSize %d infoSize %d length %d\n", v17, v18, v19, v20, v21, v22, v15);
    v9 = 0;
    v14 = 8;
    goto LABEL_21;
  }
  if (v12 >= 1)
  {
    if (a2 != a4)
      memcpy(a4, a2, v15);
    a4[4] = *(_WORD *)(a1 + 2);
    (*(void (**)(uint64_t, unsigned __int16 *, uint64_t, unsigned __int16 *, int *))(a1 + 48))(a1, a2, 2, a4, a5);
    (*(void (**)(uint64_t, unsigned __int16 *, uint64_t, unsigned __int16 *, int *))(a1 + 48))(a1, a2 + 2, 4, a4 + 2, a5);
    v25 = v15 - (unsigned __int16)v23;
    if ((int)v25 >= 1)
    {
      for (i = 0; i != v25; ++i)
      {
        if (!*((_BYTE *)a2 + (unsigned __int16)v23 + i))
          break;
      }
    }
    (*(void (**)(uint64_t))(a1 + 72))(a1);
  }
  return v9;
}

_OWORD *udata_openSwapper(int a1, unsigned int a2, int a3, int a4, int *a5)
{
  _OWORD *result;
  uint64_t (*v11);
  uint64_t (*v12)(int, char *, int, UChar *, int);
  uint64_t (*v13);
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t (*v20)(uint64_t, _BYTE *, uint64_t, _BYTE *, int *, uint64_t, uint64_t, uint64_t);
  BOOL v21;
  int v22;

  if (!a5)
    return 0;
  if (*a5 > 0)
    return 0;
  if ((a4 | a2) >= 2)
  {
    result = 0;
    v22 = 1;
LABEL_27:
    *a5 = v22;
    return result;
  }
  result = uprv_malloc(0x60uLL);
  if (!result)
  {
    v22 = 7;
    goto LABEL_27;
  }
  v11 = sub_18BC35BA0;
  v12 = sub_18BC38C08;
  if (!a1)
    v11 = (uint64_t (*))nullsub_19;
  v13 = (uint64_t (*))nullsub_20;
  if (a1)
    v13 = sub_18BC35BAC;
  v14 = sub_18BC35BBC;
  if (!a3)
    v14 = sub_18BC35BB4;
  v15 = sub_18BC35BD0;
  if (!a3)
    v15 = sub_18BC35BC8;
  if (!a4)
    v12 = sub_18BC38B10;
  *result = 0u;
  result[1] = 0u;
  *(_BYTE *)result = a1;
  *((_BYTE *)result + 2) = a3;
  result[2] = 0u;
  result[3] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  *((_BYTE *)result + 1) = a2;
  *((_BYTE *)result + 3) = a4;
  *((_QWORD *)result + 1) = v11;
  *((_QWORD *)result + 2) = v13;
  v16 = sub_18BC35D40;
  *((_QWORD *)result + 4) = v14;
  *((_QWORD *)result + 5) = v15;
  *((_QWORD *)result + 3) = v12;
  if (a1 == a3)
    v16 = sub_18BC35BDC;
  v17 = sub_18BC35C50;
  if (a1 != a3)
    v17 = sub_18BC35DB0;
  *((_QWORD *)result + 6) = v16;
  *((_QWORD *)result + 7) = v17;
  v18 = sub_18BC35CC8;
  if (a1 != a3)
    v18 = sub_18BC35E20;
  *((_QWORD *)result + 8) = v18;
  if (a2)
  {
    v19 = sub_18BC3894C;
    v20 = sub_18BC38A24;
    v21 = a4 == 1;
  }
  else
  {
    v19 = uprv_ebcdicFromAscii;
    v20 = sub_18BC38868;
    v21 = a4 == 0;
  }
  if (v21)
    v19 = v20;
  *((_QWORD *)result + 9) = v19;
  return result;
}

uint64_t sub_18BC35BA0(unsigned int a1)
{
  return __rev16(a1);
}

uint64_t sub_18BC35BAC(unsigned int a1)
{
  return bswap32(a1);
}

_WORD *sub_18BC35BB4(_WORD *result, __int16 a2)
{
  *result = a2;
  return result;
}

_WORD *sub_18BC35BBC(_WORD *result, unsigned int a2)
{
  *result = __rev16(a2);
  return result;
}

_DWORD *sub_18BC35BC8(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}

_DWORD *sub_18BC35BD0(_DWORD *result, unsigned int a2)
{
  *result = bswap32(a2);
  return result;
}

size_t sub_18BC35BDC(uint64_t a1, const void *a2, size_t __n, void *__dst, int *a5)
{
  size_t v5;

  if (!a5 || *a5 > 0)
    return 0;
  if (a1 && a2 && (v5 = __n, (__n & 0x80000000) == 0) && (__n & 1) == 0 && __dst)
  {
    if ((_DWORD)__n && a2 != __dst)
      memcpy(__dst, a2, __n);
  }
  else
  {
    v5 = 0;
    *a5 = 1;
  }
  return v5;
}

size_t sub_18BC35C50(uint64_t a1, const void *a2, size_t __n, void *__dst, int *a5)
{
  size_t v5;

  if (!a5 || *a5 > 0)
    return 0;
  if (a1 && a2 && (v5 = __n, (__n & 0x80000000) == 0) && (__n & 3) == 0 && __dst)
  {
    if ((_DWORD)__n && a2 != __dst)
      memcpy(__dst, a2, __n);
  }
  else
  {
    v5 = 0;
    *a5 = 1;
  }
  return v5;
}

size_t sub_18BC35CC8(uint64_t a1, const void *a2, size_t __n, void *__dst, int *a5)
{
  size_t v5;

  if (!a5 || *a5 > 0)
    return 0;
  if (a1 && a2 && (v5 = __n, (__n & 0x80000000) == 0) && (__n & 7) == 0 && __dst)
  {
    if ((_DWORD)__n && a2 != __dst)
      memcpy(__dst, a2, __n);
  }
  else
  {
    v5 = 0;
    *a5 = 1;
  }
  return v5;
}

uint64_t sub_18BC35D40(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _WORD *a4, int *a5)
{
  unsigned int v6;
  unsigned int v7;

  if (!a5 || *a5 > 0)
    return 0;
  if (a1 && a2 && (a3 & 0x80000000) == 0 && (a3 & 1) == 0 && a4)
  {
    if (a3 >= 2)
    {
      v6 = (a3 >> 1) + 1;
      do
      {
        v7 = *a2++;
        *a4++ = bswap32(v7) >> 16;
        --v6;
      }
      while (v6 > 1);
    }
  }
  else
  {
    a3 = 0;
    *a5 = 1;
  }
  return a3;
}

uint64_t sub_18BC35DB0(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD *a4, int *a5)
{
  unsigned int v6;
  unsigned int v7;

  if (!a5 || *a5 > 0)
    return 0;
  if (a1 && a2 && (a3 & 0x80000000) == 0 && (a3 & 3) == 0 && a4)
  {
    if (a3 >= 4)
    {
      v6 = (a3 >> 2) + 1;
      do
      {
        v7 = *a2++;
        *a4++ = bswap32(v7);
        --v6;
      }
      while (v6 > 1);
    }
  }
  else
  {
    a3 = 0;
    *a5 = 1;
  }
  return a3;
}

uint64_t sub_18BC35E20(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD *a4, int *a5)
{
  unsigned int v6;
  unint64_t v7;

  if (!a5 || *a5 > 0)
    return 0;
  if (a1 && a2 && (a3 & 0x80000000) == 0 && (a3 & 7) == 0 && a4)
  {
    if (a3 >= 8)
    {
      v6 = (a3 >> 3) + 1;
      do
      {
        v7 = *a2++;
        *a4++ = bswap64(v7);
        --v6;
      }
      while (v6 > 1);
    }
  }
  else
  {
    a3 = 0;
    *a5 = 1;
  }
  return a3;
}

_OWORD *udata_openSwapperForInputData(unsigned __int16 *a1, unsigned int a2, int a3, unsigned int a4, int *a5)
{
  unsigned int v5;
  unsigned int v6;
  int v7;

  if (a5 && *a5 <= 0)
  {
    if (a1 && a2 >= 0x18 && a4 < 2)
    {
      if (*((unsigned __int8 *)a1 + 2) == 218 && *((_BYTE *)a1 + 3) == 39 && *((_BYTE *)a1 + 10) == 2)
      {
        v5 = *a1;
        if (*((_BYTE *)a1 + 8))
        {
          v5 = __rev16(v5);
          v6 = bswap32(a1[2]) >> 16;
        }
        else
        {
          v6 = a1[2];
        }
        if (v5 <= a2 && v5 >= 0x18 && v6 >= 0x14 && (unint64_t)v6 + 4 <= v5)
          return udata_openSwapper(*((char *)a1 + 8), *((unsigned __int8 *)a1 + 9), a3, a4, a5);
      }
      v7 = 16;
    }
    else
    {
      v7 = 1;
    }
    *a5 = v7;
  }
  return 0;
}

void uenum_close(void **a1)
{
  void (*v2)(void **);
  void *v3;

  if (a1)
  {
    v2 = (void (*)(void **))a1[2];
    if (v2)
    {
      v3 = *a1;
      if (*a1)
      {
        uprv_free(v3);
        v2 = (void (*)(void **))a1[2];
      }
      v2(a1);
    }
    else
    {
      uprv_free(a1);
    }
  }
}

uint64_t uenum_count(uint64_t a1, int *a2)
{
  uint64_t (*v3)(void);

  if (!a1 || *a2 > 0)
    return 0xFFFFFFFFLL;
  v3 = *(uint64_t (**)(void))(a1 + 24);
  if (!v3)
  {
    *a2 = 16;
    return 0xFFFFFFFFLL;
  }
  return v3();
}

UChar *uenum_unextDefault(uint64_t a1, _DWORD *a2, int *a3)
{
  uint64_t (*v5)(void);
  uint64_t v7;
  const char *v8;
  UChar *v9;
  int v10;
  int v12;

  v12 = 0;
  v5 = *(uint64_t (**)(void))(a1 + 40);
  if (v5)
  {
    v7 = v5();
    if (!v7)
    {
      v9 = 0;
      goto LABEL_9;
    }
    v8 = (const char *)v7;
    v9 = (UChar *)sub_18BC3608C((_DWORD **)a1, 2 * v12 + 2);
    if (v9)
    {
      u_charsToUChars(v8, v9, v12 + 1);
      goto LABEL_9;
    }
    v10 = 7;
  }
  else
  {
    v9 = 0;
    v10 = 16;
  }
  *a3 = v10;
LABEL_9:
  if (a2)
    *a2 = v12;
  return v9;
}

_DWORD *sub_18BC3608C(_DWORD **a1, int a2)
{
  _DWORD *result;

  result = *a1;
  if (result)
  {
    if (*result >= a2)
      return ++result;
    result = uprv_realloc(result, a2 + 12);
  }
  else
  {
    result = uprv_malloc(a2 + 12);
  }
  *a1 = result;
  if (!result)
    return result;
  *result = a2 + 8;
  return ++result;
}

char *uenum_nextDefault(uint64_t a1, _DWORD *a2, int *a3)
{
  uint64_t (*v4)(void);
  uint64_t v7;
  const UChar *v8;
  char *v9;
  int v10;

  v4 = *(uint64_t (**)(void))(a1 + 32);
  if (!v4)
  {
    v9 = 0;
    v10 = 16;
LABEL_8:
    *a3 = v10;
    return v9;
  }
  v7 = v4();
  if (!v7)
    return 0;
  v8 = (const UChar *)v7;
  v9 = (char *)sub_18BC3608C((_DWORD **)a1, *a2 + 1);
  if (!v9)
  {
    v10 = 7;
    goto LABEL_8;
  }
  u_UCharsToChars(v8, v9, *a2 + 1);
  return v9;
}

uint64_t uenum_unext(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t (*v4)(void);

  if (!a1 || *a3 > 0)
    return 0;
  v4 = *(uint64_t (**)(void))(a1 + 32);
  if (!v4)
  {
    *a3 = 16;
    return 0;
  }
  return v4();
}

uint64_t uenum_next(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t (*v3)(void);
  int v4;

  if (result)
  {
    if (*a3 <= 0)
    {
      v3 = *(uint64_t (**)(void))(result + 40);
      if (v3)
      {
        if (a2)
        {
          return v3();
        }
        else
        {
          v4 = 0;
          return v3();
        }
      }
      else
      {
        result = 0;
        *a3 = 16;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t uenum_reset(uint64_t result, int *a2)
{
  uint64_t (*v2)(void);

  if (result && *a2 <= 0)
  {
    v2 = *(uint64_t (**)(void))(result + 48);
    if (v2)
      return v2();
    else
      *a2 = 16;
  }
  return result;
}

int32x2_t *uhash_open(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  return sub_18BC36254(a1, a2, a3, 4, a4);
}

int32x2_t *sub_18BC36254(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int *a5)
{
  int32x2_t *v5;
  int32x2_t *v12;

  if (*a5 > 0)
    return 0;
  v12 = (int32x2_t *)uprv_malloc(0x50uLL);
  v5 = v12;
  if (!v12)
  {
    *a5 = 7;
    return v5;
  }
  sub_18BC36334(v12, a1, a2, a3, a4, a5);
  v5[9].i8[1] = 1;
  if (*a5 >= 1)
  {
    uprv_free(v5);
    return 0;
  }
  return v5;
}

int32x2_t *uhash_openSize(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int *a5)
{
  uint64_t i;

  for (i = 0; i != 28; ++i)
  {
    if (dword_18BE14A80[i] >= a4)
      break;
  }
  return sub_18BC36254(a1, a2, a3, i, a5);
}

int32x2_t *uhash_init(int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  return sub_18BC36334(a1, a2, a3, a4, 4, a5);
}

int32x2_t *sub_18BC36334(int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  if (*a6 > 0)
    return 0;
  a1[1] = (int32x2_t)a2;
  a1[2] = (int32x2_t)a3;
  a1[9].i8[1] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[3] = (int32x2_t)a4;
  a1[8] = (int32x2_t)1056964608;
  sub_18BC37074(a1, a5, a6);
  if (*a6 >= 1)
    return 0;
  else
    return a1;
}

int32x2_t *uhash_initSize(int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  uint64_t i;

  for (i = 0; i != 28; ++i)
  {
    if (dword_18BE14A80[i] >= a5)
      break;
  }
  return sub_18BC36334(a1, a2, a3, a4, i, a6);
}

void uhash_close(void **a1)
{
  void *v2;
  uint64_t v3;
  int *v4;
  _DWORD *v5;
  int v6;
  void (*v7)(void);
  void (*v8)(void);

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      if (a1[4] || a1[5])
      {
        LODWORD(v3) = -1;
LABEL_6:
        v3 = (int)v3;
        v2 = *a1;
        v4 = (int *)((char *)*a1 + 24 * (int)v3 + 24);
        while (++v3 < *((int *)a1 + 13))
        {
          v5 = v4 + 6;
          v6 = *v4;
          v4 += 6;
          if ((v6 & 0x80000000) == 0)
          {
            v7 = (void (*)(void))a1[4];
            if (v7 && *((_QWORD *)v5 - 1))
              v7();
            v8 = (void (*)(void))a1[5];
            if (v8)
            {
              if (*((_QWORD *)v5 - 2))
                v8();
            }
            goto LABEL_6;
          }
        }
      }
      uprv_free(v2);
      *a1 = 0;
    }
    if (*((_BYTE *)a1 + 73))
      uprv_free(a1);
  }
}

uint64_t uhash_nextElement(uint64_t *a1, int *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;

  v2 = *a2;
  v3 = v2 + 1;
  v4 = 24 * v2;
  while (v3 < *((int *)a1 + 13))
  {
    v5 = *a1;
    v6 = *(_DWORD *)(*a1 + v4 + 24);
    LODWORD(v2) = v2 + 1;
    ++v3;
    v4 += 24;
    if ((v6 & 0x80000000) == 0)
    {
      *a2 = v2;
      return v5 + v4;
    }
  }
  return 0;
}

uint64_t uhash_setKeyHasher(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2;
  return v2;
}

uint64_t uhash_setKeyComparator(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = a2;
  return v2;
}

uint64_t uhash_setValueComparator(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = a2;
  return v2;
}

uint64_t uhash_setKeyDeleter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = a2;
  return v2;
}

uint64_t uhash_setValueDeleter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = a2;
  return v2;
}

void uhash_setResizePolicy(int32x2_t *a1, int a2)
{
  float32x2_t v2;
  int v3;

  v3 = 0;
  v2 = qword_18BE14AF4[a2];
  a1[7] = vrev64_s32(vcvt_s32_f32(vmul_n_f32(v2, (float)a1[6].i32[1])));
  a1[8] = vrev64_s32((int32x2_t)v2);
  sub_18BC36578(a1, &v3);
}

void sub_18BC36578(int32x2_t *a1, int *a2)
{
  char *v4;
  int v5;
  __int32 v6;
  uint64_t v7;
  int v8;
  unint64_t v10;
  int *v11;
  char *v12;
  int *v13;

  v4 = (char *)*a1;
  v5 = a1[9].i8[0];
  v6 = a1[6].i32[0];
  v7 = a1[6].u32[1];
  if (v6 <= a1[7].i32[0])
  {
    if (v6 >= a1[7].i32[1] || v5 < 1)
      return;
    v8 = v5 - 1;
  }
  else
  {
    if (v5 > 27)
      return;
    v8 = v5 + 1;
  }
  sub_18BC37074(a1, v8, a2);
  if (*a2 <= 0)
  {
    if ((int)v7 >= 1)
    {
      v10 = v7 + 1;
      do
      {
        v11 = (int *)&v4[24 * (v10 - 2)];
        if ((*v11 & 0x80000000) == 0)
        {
          v12 = &v4[24 * (v10 - 2)];
          v13 = sub_18BC366C4((uint64_t *)a1, *((_QWORD *)v12 + 2), *v11);
          *((_QWORD *)v13 + 2) = *((_QWORD *)v12 + 2);
          *((_QWORD *)v13 + 1) = *((_QWORD *)v12 + 1);
          *v13 = *v11;
          ++a1[6].i32[0];
        }
        --v10;
      }
      while (v10 > 1);
    }
    uprv_free(v4);
  }
  else
  {
    *a1 = (int32x2_t)v4;
    a1[6].i32[1] = v7;
  }
}

uint64_t uhash_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t uhash_get(uint64_t a1, uint64_t a2)
{
  int v4;

  v4 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  return *((_QWORD *)sub_18BC366C4((uint64_t *)a1, a2, v4) + 1);
}

int *sub_18BC366C4(uint64_t *a1, uint64_t a2, int a3)
{
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int *v12;
  int v13;

  v4 = 0;
  v5 = a3 & 0x7FFFFFFF;
  v6 = *((_DWORD *)a1 + 13);
  v7 = (a3 & 0x7FFFFFFF ^ 0x4000000) % v6;
  v8 = *a1;
  v9 = -1;
  v10 = v7;
  do
  {
    v11 = v10;
    v12 = (int *)(v8 + 24 * v10);
    v13 = *v12;
    if (*v12 == v5)
    {
      if (((unsigned int (*)(uint64_t, _QWORD))a1[2])(a2, *(_QWORD *)(v8 + 24 * v10 + 16)))
        return v12;
      v6 = *((_DWORD *)a1 + 13);
    }
    else if (v13 < 0)
    {
      if (v9 < 0)
        v9 = v10;
      if (v13 == -2147483647)
        return (int *)(v8 + 24 * v9);
    }
    if (!v4)
      v4 = v5 % (v6 - 1) + 1;
    v10 = (v4 + v11) % v6;
  }
  while (v10 != v7);
  if (v9 < 0)
  {
    v9 = v7;
    if (v13 != -2147483647)
      abort();
  }
  return (int *)(v8 + 24 * v9);
}

uint64_t uhash_iget(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  int v4;

  v3 = a2;
  v4 = (*(uint64_t (**)(_QWORD))(a1 + 8))(a2);
  return *((_QWORD *)sub_18BC366C4((uint64_t *)a1, v3, v4) + 1);
}

uint64_t uhash_geti(uint64_t a1, uint64_t a2)
{
  int v4;

  v4 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  return sub_18BC366C4((uint64_t *)a1, a2, v4)[2];
}

uint64_t uhash_igeti(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  int v4;

  v3 = a2;
  v4 = (*(uint64_t (**)(_QWORD))(a1 + 8))(a2);
  return sub_18BC366C4((uint64_t *)a1, v3, v4)[2];
}

uint64_t uhash_getiAndFound(uint64_t a1, uint64_t a2, BOOL *a3)
{
  int v6;
  int *v7;

  v6 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  v7 = sub_18BC366C4((uint64_t *)a1, a2, v6);
  *a3 = *v7 >= 0;
  return v7[2];
}

uint64_t uhash_igetiAndFound(uint64_t a1, unsigned int a2, BOOL *a3)
{
  uint64_t v5;
  int v6;
  int *v7;

  v5 = a2;
  v6 = (*(uint64_t (**)(_QWORD))(a1 + 8))(a2);
  v7 = sub_18BC366C4((uint64_t *)a1, v5, v6);
  *a3 = *v7 >= 0;
  return v7[2];
}

uint64_t uhash_put(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  return sub_18BC36950(a1, a2, a3, 3, a4);
}

uint64_t sub_18BC36950(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int *a5)
{
  void (*v8)(uint64_t);
  BOOL v9;
  void (*v10)(uint64_t);
  BOOL v11;
  int v14;
  int *v15;
  int v16;
  int v17;

  if (*a5 > 0)
    goto LABEL_2;
  if ((a4 & 2) != 0)
  {
    if (!a3)
      return sub_18BC36B30(a1, a2);
  }
  else if (!(_DWORD)a3 && (a4 & 4) == 0)
  {
    return sub_18BC36B30(a1, a2);
  }
  if (*(_DWORD *)(a1 + 48) <= *(_DWORD *)(a1 + 56) || (sub_18BC36578((int32x2_t *)a1, a5), *a5 <= 0))
  {
    v14 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
    v15 = sub_18BC366C4((uint64_t *)a1, a2, v14);
    if ((*v15 & 0x80000000) == 0)
      return sub_18BC37114(a1, (uint64_t)v15, v14 & 0x7FFFFFFF, a2, a3);
    v16 = *(_DWORD *)(a1 + 48);
    v17 = *(_DWORD *)(a1 + 52);
    *(_DWORD *)(a1 + 48) = v16 + 1;
    if (v16 + 1 != v17)
      return sub_18BC37114(a1, (uint64_t)v15, v14 & 0x7FFFFFFF, a2, a3);
    *(_DWORD *)(a1 + 48) = v16;
    *a5 = 7;
  }
LABEL_2:
  v8 = *(void (**)(uint64_t))(a1 + 32);
  if (v8)
    v9 = a2 == 0;
  else
    v9 = 1;
  if (!v9)
    v8(a2);
  v10 = *(void (**)(uint64_t))(a1 + 40);
  if (v10)
    v11 = a3 == 0;
  else
    v11 = 1;
  if (!v11)
    v10(a3);
  return 0;
}

uint64_t uhash_iput(uint64_t a1, unsigned int a2, uint64_t a3, int *a4)
{
  return sub_18BC36950(a1, a2, a3, 2, a4);
}

uint64_t uhash_puti(uint64_t a1, uint64_t a2, unsigned int a3, int *a4)
{
  return sub_18BC36950(a1, a2, a3, 1, a4);
}

uint64_t uhash_iputi(uint64_t a1, unsigned int a2, unsigned int a3, int *a4)
{
  return sub_18BC36950(a1, a2, a3, 0, a4);
}

uint64_t uhash_putiAllowZero(uint64_t a1, uint64_t a2, unsigned int a3, int *a4)
{
  return sub_18BC36950(a1, a2, a3, 5, a4);
}

uint64_t uhash_iputiAllowZero(uint64_t a1, unsigned int a2, unsigned int a3, int *a4)
{
  return sub_18BC36950(a1, a2, a3, 4, a4);
}

uint64_t sub_18BC36B30(uint64_t a1, uint64_t a2)
{
  int v4;
  int *v5;
  uint64_t v6;
  int v8;

  v4 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  v5 = sub_18BC366C4((uint64_t *)a1, a2, v4);
  if (*v5 < 0)
    return 0;
  --*(_DWORD *)(a1 + 48);
  v6 = sub_18BC37114(a1, (uint64_t)v5, 0x80000000, 0, 0);
  if (*(_DWORD *)(a1 + 48) < *(_DWORD *)(a1 + 60))
  {
    v8 = 0;
    sub_18BC36578((int32x2_t *)a1, &v8);
  }
  return v6;
}

uint64_t uhash_iremove(uint64_t a1, unsigned int a2)
{
  return sub_18BC36B30(a1, a2);
}

uint64_t uhash_removei(uint64_t a1, uint64_t a2)
{
  return sub_18BC36B30(a1, a2);
}

uint64_t uhash_iremovei(uint64_t a1, unsigned int a2)
{
  return sub_18BC36B30(a1, a2);
}

uint64_t uhash_removeAll(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  if (*(_DWORD *)(result + 48))
  {
    v1 = result;
    LODWORD(v2) = -1;
LABEL_3:
    v3 = 24 * (int)v2;
    v2 = (int)v2;
    while (++v2 < *(int *)(v1 + 52))
    {
      v4 = v3 + 24;
      v5 = *(_DWORD *)(*(_QWORD *)v1 + v3 + 24);
      v3 += 24;
      if ((v5 & 0x80000000) == 0)
      {
        result = uhash_removeElement(v1, (_DWORD *)(*(_QWORD *)v1 + v4));
        goto LABEL_3;
      }
    }
  }
  return result;
}

uint64_t uhash_removeElement(uint64_t a1, _DWORD *a2)
{
  if ((*a2 & 0x80000000) != 0)
    return 0;
  --*(_DWORD *)(a1 + 48);
  return sub_18BC37114(a1, (uint64_t)a2, 0x80000000, 0, 0);
}

BOOL uhash_containsKey(uint64_t a1, uint64_t a2)
{
  int v4;

  v4 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  return *sub_18BC366C4((uint64_t *)a1, a2, v4) >= 0;
}

BOOL uhash_icontainsKey(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  int v4;

  v3 = a2;
  v4 = (*(uint64_t (**)(_QWORD))(a1 + 8))(a2);
  return *sub_18BC366C4((uint64_t *)a1, v3, v4) >= 0;
}

int *uhash_find(uint64_t a1, uint64_t a2)
{
  int v4;
  int *result;

  v4 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  result = sub_18BC366C4((uint64_t *)a1, a2, v4);
  if (*result < 0)
    return 0;
  return result;
}

unsigned __int16 *uhash_hashUChars(unsigned __int16 *result)
{
  unsigned __int16 *v1;
  int32_t v2;

  if (result)
  {
    v1 = result;
    v2 = u_strlen(result);
    return ustr_hashUCharsN(v1, v2);
  }
  return result;
}

unsigned __int8 *uhash_hashChars(unsigned __int8 *result)
{
  unsigned __int8 *v1;
  int v2;

  if (result)
  {
    v1 = result;
    v2 = strlen((const char *)result);
    return ustr_hashCharsN(v1, v2);
  }
  return result;
}

char *uhash_hashIChars(char *result)
{
  char *v1;
  int v2;

  if (result)
  {
    v1 = result;
    v2 = strlen(result);
    return ustr_hashICharsN(v1, v2);
  }
  return result;
}

uint64_t uhash_equals(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  _DWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int *v14;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    if (*(_QWORD *)(a1 + 16) != *(_QWORD *)(a2 + 16))
      return 0;
    result = 0;
    v5 = *(_QWORD *)(a1 + 24);
    if (v5 && v5 == *(_QWORD *)(a2 + 24))
    {
      v6 = *(_DWORD *)(a1 + 48);
      if (v6 != *(_DWORD *)(a2 + 48))
        return 0;
      if (v6 < 1)
      {
        return 1;
      }
      else
      {
        v7 = 0;
        v8 = -1;
        do
        {
          v9 = (_DWORD *)(*(_QWORD *)a1 + 24 * v8 + 24);
          do
          {
            ++v8;
            v10 = *v9;
            v9 += 6;
          }
          while (v10 < 0);
          v12 = *((_QWORD *)v9 - 2);
          v11 = *((_QWORD *)v9 - 1);
          v13 = (*(uint64_t (**)(uint64_t))(a2 + 8))(v11);
          v14 = sub_18BC366C4((uint64_t *)a2, v11, v13);
          result = (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 24))(v12, *((_QWORD *)v14 + 1));
          if (!(_DWORD)result)
            break;
          ++v7;
          result = 1;
        }
        while (v7 != v6);
      }
    }
  }
  return result;
}

BOOL uhash_compareUChars(unsigned __int16 *a1, unsigned __int16 *a2)
{
  _BOOL8 result;
  int v4;
  unsigned __int16 *v5;
  int v6;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    v4 = *a1;
    if (*a1)
    {
      v5 = a1 + 1;
      do
      {
        if (v4 != *a2)
          break;
        ++a2;
        v6 = *v5++;
        v4 = v6;
      }
      while (v6);
    }
    return v4 == *a2;
  }
  return result;
}

BOOL uhash_compareChars(unsigned __int8 *a1, unsigned __int8 *a2)
{
  _BOOL8 result;
  int v4;
  unsigned __int8 *v5;
  int v6;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    v4 = *a1;
    if (*a1)
    {
      v5 = a1 + 1;
      do
      {
        if (v4 != *a2)
          break;
        ++a2;
        v6 = *v5++;
        v4 = v6;
      }
      while (v6);
    }
    return v4 == *a2;
  }
  return result;
}

BOOL uhash_compareIChars(unsigned __int8 *a1, unsigned __int8 *a2)
{
  _BOOL8 result;
  unsigned __int8 *v4;
  unsigned __int8 v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1)
  {
    v4 = a2;
    if (a2)
    {
      v5 = *a1;
      if (*a1)
      {
        v6 = a1 + 1;
        while (1)
        {
          v7 = uprv_asciitolower((char)v5);
          if (v7 != uprv_asciitolower((char)*v4))
            break;
          ++v4;
          v8 = *v6++;
          v5 = v8;
          if (!v8)
            goto LABEL_8;
        }
        v9 = *(v6 - 1);
      }
      else
      {
LABEL_8:
        v9 = 0;
      }
      return v9 == *v4;
    }
  }
  return result;
}

BOOL uhash_compareLong(int a1, int a2)
{
  return a1 == a2;
}

int32x2_t *sub_18BC37074(int32x2_t *result, int a2, int *a3)
{
  int32x2_t *v4;
  uint64_t v5;
  int v6;
  char *v7;

  if (*a3 <= 0)
  {
    v4 = result;
    result[9].i8[0] = a2;
    v5 = dword_18BE14A80[a2];
    result[6].i32[1] = v5;
    result = (int32x2_t *)uprv_malloc(24 * v5);
    *v4 = (int32x2_t)result;
    if (result)
    {
      v6 = v4[6].i32[1];
      if (v6 >= 1)
      {
        v7 = (char *)&result[3 * v6];
        do
        {
          result[1] = 0;
          result[2] = 0;
          result->i32[0] = -2147483647;
          result += 3;
        }
        while (result < (int32x2_t *)v7);
      }
      v4[6].i32[0] = 0;
      v4[7] = vcvt_s32_f32(vmul_n_f32((float32x2_t)v4[8], (float)v6));
    }
    else
    {
      *a3 = 7;
    }
  }
  return result;
}

uint64_t sub_18BC37114(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  void (*v11)(void);
  uint64_t v12;
  void (*v14)(uint64_t);
  BOOL v15;

  v10 = *(_QWORD *)(a2 + 8);
  v11 = *(void (**)(void))(a1 + 32);
  if (v11)
  {
    v12 = *(_QWORD *)(a2 + 16);
    if (v12 && v12 != a4)
      v11();
  }
  v14 = *(void (**)(uint64_t))(a1 + 40);
  if (v14)
  {
    if (v10)
      v15 = v10 == a5;
    else
      v15 = 1;
    if (!v15)
      v14(v10);
    v10 = 0;
  }
  *(_QWORD *)(a2 + 8) = a5;
  *(_QWORD *)(a2 + 16) = a4;
  *(_DWORD *)a2 = a3;
  return v10;
}

void uhash_deleteHashtable(void ***a1)
{
  void **v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      uhash_close(v2);
    icu::UMemory::operator delete(a1);
  }
}

int32_t uidna_toASCII(const UChar *src, int32_t srcLength, UChar *dest, int32_t destCapacity, int32_t options, UParseError *parseError, UErrorCode *status)
{
  int32_t result;
  uint64_t v10;
  char v13;
  uint64_t v15;
  uint64_t v16;
  int32_t v17;

  if (!status || *(int *)status > 0)
    return 0;
  if (src
    && (v10 = *(_QWORD *)&srcLength, srcLength >= -1)
    && (destCapacity & 0x80000000) == 0
    && ((v13 = options, dest) || !destCapacity))
  {
    v15 = usprep_openByType(0, (int *)status);
    if (*(int *)status <= 0)
    {
      v16 = v15;
      v17 = sub_18BC372B4((UChar *)src, v10, dest, destCapacity, v13, v15, (uint64_t)parseError, (int *)status);
      usprep_close(v16);
      return v17;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    result = 0;
    *status = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return result;
}

uint64_t sub_18BC372B4(UChar *s, uint64_t a2, UChar *a3, int a4, char a5, uint64_t a6, uint64_t a7, int *a8)
{
  uint64_t v12;
  _WORD *v14;
  int v15;
  uint64_t v16;
  UChar *v17;
  char v18;
  uint64_t v19;
  char v20;
  int v21;
  UChar *v22;
  uint64_t v24;
  char v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  UChar *v34;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  UChar *v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int32_t v45;
  _OWORD v48[12];
  uint64_t v49;
  _OWORD v50[12];
  uint64_t v51;
  uint64_t v52;

  v12 = a2;
  v52 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a2 == -1)
    v12 = u_strlen(s);
  v51 = 0;
  memset(v50, 0, sizeof(v50));
  memset(v48, 0, sizeof(v48));
  v49 = 0;
  if ((int)v12 < 101)
  {
    v14 = v50;
    if ((int)v12 < 1)
    {
      v12 = 0;
      goto LABEL_19;
    }
    v15 = 100;
LABEL_8:
    v18 = a5 & 1;
    memcpy(v14, s, 2 * v12);
    v19 = 0;
    v20 = 1;
    do
    {
      if (s[v19] > 0x7Fu)
        v20 = 0;
      ++v19;
    }
    while (v12 != v19);
    if (!v20)
    {
      v16 = usprep_prepare(a6, s, v12, v14, v15, v18, a7, a8);
      v21 = *a8;
      if (*a8 != 15)
        goto LABEL_20;
      if (v14 != (_WORD *)v50)
        uprv_free(v14);
      v22 = (UChar *)uprv_malloc(2 * (int)v16);
      if (!v22)
        goto LABEL_5;
      v14 = v22;
      *a8 = 0;
      v12 = usprep_prepare(a6, s, v12, v22, v16, v18, a7, a8);
    }
LABEL_19:
    v21 = *a8;
    v16 = v12;
LABEL_20:
    if (v21 > 0)
    {
LABEL_21:
      v16 = 0;
LABEL_22:
      v17 = (UChar *)v48;
      goto LABEL_23;
    }
    if (!(_DWORD)v16)
    {
      *a8 = 66567;
      goto LABEL_22;
    }
    if ((int)v16 < 1)
    {
      if ((a5 & 2) == 0)
      {
LABEL_64:
        if ((int)v16 > a4)
          goto LABEL_22;
        u_memmove(a3, v14, v16);
        v17 = (UChar *)v48;
        goto LABEL_66;
      }
      v27 = 1;
    }
    else
    {
      v24 = 0;
      v25 = 1;
      v26 = -1;
      v27 = 1;
      v28 = v16;
      do
      {
        v29 = (unsigned __int16)v14[v24];
        if (v29 <= 0x7F)
        {
          if (v29 > 0x7A || v29 != 45 && v29 - 48 >= 0xA && v29 - 65 >= 0x1A && v29 <= 0x60)
          {
            v25 = 0;
            v26 = v24;
          }
        }
        else
        {
          v27 = 0;
        }
        ++v24;
      }
      while (v16 != v24);
      if ((a5 & 2) == 0)
        goto LABEL_63;
      if (!v25)
      {
        *a8 = 66563;
        v34 = v14;
LABEL_62:
        uprv_syntaxError(v34, v26, v28, a7);
        goto LABEL_21;
      }
    }
    if (*v14 == 45)
    {
      v35 = 66563;
LABEL_58:
      *a8 = v35;
      v34 = v14;
      v26 = 0;
LABEL_61:
      v28 = v16;
      goto LABEL_62;
    }
    if (v14[(int)v16 - 1] == 45)
    {
      *a8 = 66563;
      v26 = v16 - ((int)v16 > 0);
      v34 = v14;
      goto LABEL_61;
    }
LABEL_63:
    if (v27)
      goto LABEL_64;
    if ((int)v16 >= 4)
    {
      v36 = (unsigned __int16)*v14;
      if ((v36 - 65) < 0x1A)
        LOWORD(v36) = v36 + 32;
      if ((unsigned __int16)v36 == 120)
      {
        v37 = 1;
        while (v37 != 4)
        {
          v38 = (unsigned __int16)v14[v37];
          if ((v38 - 65) < 0x1A)
            LOWORD(v38) = v38 + 32;
          v39 = (unsigned __int16)aXn[v37++];
          if (v39 != (unsigned __int16)v38)
          {
            if ((unint64_t)(v37 - 2) <= 2)
              goto LABEL_79;
            break;
          }
        }
        v35 = 66564;
        goto LABEL_58;
      }
    }
LABEL_79:
    v40 = a3;
    v17 = (UChar *)v48;
    v41 = u_strToPunycode(v14, v16, (uint64_t)v48, 100, 0, a8);
    v42 = v41;
    v43 = *a8;
    if (*a8 == 15)
    {
      v17 = (UChar *)uprv_malloc(2 * v41);
      if (!v17)
      {
        v16 = 0;
        v44 = 7;
        goto LABEL_87;
      }
      *a8 = 0;
      v42 = u_strToPunycode(v14, v16, (uint64_t)v17, v42, 0, a8);
      v43 = *a8;
    }
    if (v43 > 0)
    {
      v16 = 0;
LABEL_88:
      a3 = v40;
      goto LABEL_23;
    }
    v16 = (v42 + 4);
    if ((int)v16 <= a4)
    {
      u_memcpy(v40, (const UChar *)aXn, 4);
      v45 = v42;
      a3 = v40;
      u_memcpy(v40 + 4, v17, v45);
LABEL_66:
      if ((int)v16 >= 64)
        *a8 = 66566;
LABEL_23:
      if (v14 == (_WORD *)v50)
        goto LABEL_25;
      goto LABEL_24;
    }
    v44 = 15;
LABEL_87:
    *a8 = v44;
    goto LABEL_88;
  }
  v14 = uprv_malloc((2 * v12));
  v15 = v12;
  if (v14)
    goto LABEL_8;
LABEL_5:
  v16 = 0;
  v14 = 0;
  *a8 = 7;
  v17 = (UChar *)v48;
LABEL_24:
  uprv_free(v14);
LABEL_25:
  if (v17 != (UChar *)v48)
    uprv_free(v17);
  uprv_free(0);
  return u_terminateUChars((uint64_t)a3, a4, v16, a8);
}

int32_t uidna_toUnicode(const UChar *src, int32_t srcLength, UChar *dest, int32_t destCapacity, int32_t options, UParseError *parseError, UErrorCode *status)
{
  int32_t result;
  uint64_t v10;
  uint64_t v15;
  uint64_t v16;
  int32_t v17;

  if (!status || *(int *)status > 0)
    return 0;
  if (src
    && (v10 = *(_QWORD *)&srcLength, srcLength >= -1)
    && (destCapacity & 0x80000000) == 0
    && (dest || !destCapacity))
  {
    v15 = usprep_openByType(0, (int *)status);
    if (*(int *)status <= 0)
    {
      v16 = v15;
      v17 = sub_18BC378A4((UChar *)src, v10, dest, destCapacity, options, v15, (uint64_t)parseError, (int *)status);
      usprep_close(v16);
      return v17;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    result = 0;
    *status = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return result;
}

uint64_t sub_18BC378A4(UChar *src, uint64_t a2, UChar *dest, int a4, int32_t a5, uint64_t a6, uint64_t a7, int *a8)
{
  int v11;
  UChar *v12;
  uint64_t v14;
  uint64_t v15;
  UChar *v16;
  uint64_t v17;
  unsigned int v18;
  char v19;
  UChar *v20;
  int v22;
  int32_t v23;
  char v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  UChar *v32;
  uint64_t v33;
  UChar *v34;
  int32_t v35;
  int v36;
  UChar *v37;
  int v38;
  uint64_t v39;
  int v40;
  UChar *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int32_t destCapacity;
  int32_t options;
  UParseError *parseError;
  UParseError *parseErrora;
  UChar desta[8];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  _OWORD v64[12];
  uint64_t v65;
  _OWORD v66[12];
  uint64_t v67;
  uint64_t v68;

  v11 = a4;
  v12 = dest;
  v68 = *MEMORY[0x1E0C80C00];
  v67 = 0;
  memset(v66, 0, sizeof(v66));
  v65 = 0;
  memset(v64, 0, sizeof(v64));
  v63 = 0;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  *(_OWORD *)desta = 0u;
  v52 = 0u;
  if ((_DWORD)a2 == -1)
  {
    v18 = *src;
    if (!*src)
    {
      v14 = 0;
      v16 = src;
LABEL_42:
      if ((int)v14 <= v11)
        u_memmove(v12, src, v14);
      v32 = (UChar *)v64;
      v27 = v14;
      goto LABEL_47;
    }
    v17 = 0;
    v19 = 1;
    do
    {
      if (v18 > 0x7F)
        v19 = 0;
      v20 = &src[v17++];
      v18 = v20[1];
    }
    while (v18);
    if (v19)
    {
      v14 = v17;
      v16 = src;
      goto LABEL_24;
    }
    parseError = (UParseError *)dest;
    v22 = a4;
    v14 = v17;
  }
  else
  {
    v14 = a2;
    if ((int)a2 < 1)
      return 0;
    v15 = 0;
    while (src[v15] <= 0x7Fu)
    {
      if (a2 == ++v15)
      {
        v16 = src;
        LODWORD(v17) = a2;
        goto LABEL_24;
      }
    }
    parseError = (UParseError *)dest;
    v22 = a4;
  }
  v23 = a5;
  v24 = a5 & 1;
  v16 = (UChar *)v66;
  v25 = usprep_prepare(a6, src, v14, (UChar *)v66, 100, a5 & 1, a7, a8);
  LODWORD(v17) = v25;
  v26 = *a8;
  if (*a8 == 15)
  {
    v16 = (UChar *)uprv_malloc(2 * v25);
    if (!v16)
    {
      v27 = 0;
      *a8 = 7;
      goto LABEL_46;
    }
    *a8 = 0;
    LODWORD(v17) = usprep_prepare(a6, src, v14, v16, v17, v24, a7, a8);
    v26 = *a8;
  }
  if (v26 > 0)
  {
    v27 = 0;
LABEL_46:
    v32 = (UChar *)v64;
    v11 = v22;
    v12 = (UChar *)parseError;
    goto LABEL_47;
  }
  a5 = v23;
  v11 = v22;
  v12 = (UChar *)parseError;
LABEL_24:
  if ((int)v17 < 4)
    goto LABEL_42;
  v28 = *v16;
  if ((v28 - 65) < 0x1A)
    LOWORD(v28) = v28 + 32;
  if ((unsigned __int16)v28 != 120)
    goto LABEL_42;
  v29 = 1;
  while (v29 != 4)
  {
    v30 = v16[v29];
    if ((v30 - 65) < 0x1A)
      LOWORD(v30) = v30 + 32;
    v31 = (unsigned __int16)aXn[v29++];
    if (v31 != (unsigned __int16)v30)
    {
      if ((unint64_t)(v29 - 2) < 3)
        goto LABEL_42;
      break;
    }
  }
  options = a5;
  parseErrora = (UParseError *)a7;
  v32 = (UChar *)v64;
  v33 = u_strFromPunycode(v16 + 4, (v17 - 4), (uint64_t)v64, 100, 0, a8);
  v27 = v33;
  if (*a8 == 15)
  {
    v32 = (UChar *)uprv_malloc(2 * (int)v33);
    if (!v32)
      goto LABEL_58;
    *a8 = 0;
    v27 = u_strFromPunycode(v16 + 4, (v17 - 4), (uint64_t)v32, v27, 0, a8);
  }
  v34 = desta;
  v35 = uidna_toASCII(v32, v27, desta, 100, options, parseErrora, (UErrorCode *)a8);
  v36 = *a8;
  if (*a8 != 15)
  {
LABEL_40:
    if (v36 > 0)
    {
      v27 = 0;
      goto LABEL_47;
    }
    if ((int)v17 >= v35)
      v39 = v35;
    else
      v39 = v17;
    if ((int)v17 < v35)
      v40 = -1;
    else
      v40 = 1;
    if ((_DWORD)v17 == v35)
      v40 = 0;
    if ((_DWORD)v39)
    {
      v41 = v16;
      while (1)
      {
        v43 = *v41++;
        v42 = v43;
        v45 = *v34++;
        v44 = v45;
        if (v42 != v45)
        {
          if ((v42 - 65) < 0x1A)
            LOWORD(v42) = v42 + 32;
          if ((v44 - 65) < 0x1A)
            LOWORD(v44) = v44 + 32;
          v46 = (unsigned __int16)v42 - (unsigned __int16)v44;
          if (v46)
            break;
        }
        if (!--v39)
          goto LABEL_78;
      }
      v40 = v46;
    }
LABEL_78:
    if (!v40)
    {
      if ((int)v27 <= v11)
        u_memmove(v12, v32, v27);
      goto LABEL_47;
    }
    v27 = 0;
    v38 = 66565;
    goto LABEL_80;
  }
  destCapacity = v35;
  v37 = (UChar *)uprv_malloc(2 * v35);
  if (v37)
  {
    v34 = v37;
    *a8 = 0;
    v35 = uidna_toASCII(v32, v27, v37, destCapacity, options, parseErrora, (UErrorCode *)a8);
    v36 = *a8;
    goto LABEL_40;
  }
LABEL_58:
  v27 = 0;
  v38 = 7;
LABEL_80:
  *a8 = v38;
LABEL_47:
  if (v16 != (UChar *)v66 && v16 != src)
    uprv_free(v16);
  if (v32 != (UChar *)v64)
    uprv_free(v32);
  uprv_free(0);
  if (*a8 >= 1)
  {
    if (v12)
    {
      if ((int)v14 <= v11)
        u_memmove(v12, src, v14);
    }
    *a8 = 0;
    v27 = v14;
  }
  return u_terminateUChars((uint64_t)v12, v11, v27, a8);
}

int32_t uidna_IDNToASCII(const UChar *src, int32_t srcLength, UChar *dest, int32_t destCapacity, int32_t options, UParseError *parseError, UErrorCode *status)
{
  uint64_t v9;
  int32_t v10;
  uint64_t v12;
  UChar *v13;
  uint64_t v15;
  UErrorCode v16;
  uint64_t v17;
  uint64_t v18;
  UChar *v19;
  uint64_t v20;
  uint64_t v21;
  UChar *v22;
  unsigned int v23;
  uint64_t i;
  unsigned int v27;
  int v30;
  char v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  UChar *v37;
  int32_t v38;
  int v39;
  UParseError *v40;

  if (!status || *(int *)status > 0)
    return 0;
  if (!src
    || (v9 = *(_QWORD *)&srcLength, srcLength < -1)
    || (v10 = destCapacity, destCapacity < 0)
    || (v12 = *(_QWORD *)&options, (v13 = dest) == 0) && destCapacity)
  {
    *status = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  v15 = usprep_openByType(0, (int *)status);
  v16 = *status;
  if (*(int *)status > 0)
    return 0;
  v17 = v15;
  v40 = parseError;
  v18 = 0;
  v19 = (UChar *)src;
  v37 = v13;
  v20 = v9;
  v38 = v10;
  v39 = v9;
  while (1)
  {
    if ((_DWORD)v20 == -1)
    {
      for (i = 0; ; ++i)
      {
        v27 = v19[i];
        if (v27 <= 0x3001)
        {
          if (!v19[i])
          {
            v21 = i;
            goto LABEL_46;
          }
          if (v27 == 46)
            goto LABEL_43;
        }
        else if (v27 == 12290 || v27 == 65294 || v27 == 65377)
        {
LABEL_43:
          v22 = &v19[(i + 1)];
          v30 = 1;
          v21 = i;
          goto LABEL_47;
        }
      }
    }
    if ((int)v20 >= 1)
    {
      v21 = 0;
      v22 = v19 + 1;
      while (1)
      {
        v23 = *(v22 - 1);
        if (v23 > 0xFF0D)
        {
          if (v23 == 65377 || v23 == 65294)
          {
LABEL_42:
            v30 = 1;
            goto LABEL_47;
          }
        }
        else if (v23 == 46 || v23 == 12290)
        {
          goto LABEL_42;
        }
        ++v21;
        ++v22;
        if (v20 == v21)
        {
          v21 = v20;
          goto LABEL_45;
        }
      }
    }
    v21 = 0;
LABEL_45:
    i = (int)v20;
LABEL_46:
    v22 = &v19[i];
    v30 = 0;
    if ((_DWORD)v21)
      break;
    v33 = 0;
LABEL_52:
    if (v16 > U_ZERO_ERROR
      || ((v18 = (v33 + v18), v10 <= v33) ? (v34 = 0) : (v34 = v33),
          v10 <= v33 ? (v10 = 0) : (v10 -= v33),
          !v30))
    {
      v35 = v38;
      v36 = (uint64_t)v37;
      goto LABEL_69;
    }
    v19 = v22;
LABEL_61:
    v13 += v34;
    if (v10 >= 1)
    {
      *v13++ = 46;
      --v10;
    }
    v18 = (v18 + 1);
    if ((int)v20 <= 0)
      v20 = v20;
    else
      v20 = v9 - ((unint64_t)((char *)v19 - (char *)src) >> 1);
  }
LABEL_47:
  v9 = v12;
  v31 = v12;
  v32 = v17;
  v33 = sub_18BC372B4(v19, v21, v13, v10, v31, v17, (uint64_t)v40, (int *)status);
  v16 = *status;
  if (*status != U_BUFFER_OVERFLOW_ERROR)
  {
    v17 = v32;
    v12 = v9;
    LODWORD(v9) = v39;
    goto LABEL_52;
  }
  *status = U_ZERO_ERROR;
  v18 = (v33 + v18);
  if ((v30 & 1) != 0)
  {
    v16 = U_ZERO_ERROR;
    v34 = v33 & (v33 >> 31);
    v10 = -v33 & (v33 >> 31);
    v19 = v22;
    v17 = v32;
    v12 = v9;
    LODWORD(v9) = v39;
    goto LABEL_61;
  }
  v35 = v38;
  v36 = (uint64_t)v37;
  v17 = v32;
LABEL_69:
  if ((int)v18 >= 256)
    *status = U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR;
  usprep_close(v17);
  return u_terminateUChars(v36, v35, v18, (int *)status);
}

int32_t uidna_IDNToUnicode(const UChar *src, int32_t srcLength, UChar *dest, int32_t destCapacity, int32_t options, UParseError *parseError, UErrorCode *status)
{
  uint64_t v9;
  int32_t v10;
  UChar *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  UChar *v18;
  uint64_t v19;
  uint64_t v20;
  UChar *v21;
  unsigned int v22;
  unsigned int i;
  unsigned int v26;
  int v29;
  uint64_t v30;
  int32_t v31;
  int32_t v32;
  uint64_t v33;
  int v34;
  const UChar *v35;
  int v36;
  int32_t v37;
  UParseError *v38;

  if (!status || *(int *)status > 0)
    return 0;
  if (!src
    || (v9 = *(_QWORD *)&srcLength, srcLength < -1)
    || (v10 = destCapacity, destCapacity < 0)
    || (v13 = dest) == 0 && destCapacity)
  {
    *status = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  v15 = usprep_openByType(0, (int *)status);
  if (*(int *)status > 0)
    return 0;
  v16 = v15;
  v36 = v9;
  v37 = options;
  v38 = parseError;
  v17 = 0;
  v18 = (UChar *)src;
  v33 = (uint64_t)v13;
  v19 = v9;
  v34 = v10;
  v35 = src;
  while (1)
  {
    if ((_DWORD)v19 == -1)
    {
      v21 = v18;
      for (i = 1; ; ++i)
      {
        v26 = *v21;
        if (v26 <= 0x3001)
        {
          if (!*v21)
          {
            v29 = 0;
            v20 = i - 1;
            goto LABEL_46;
          }
          if (v26 == 46)
          {
LABEL_42:
            v20 = i - 1;
            v21 = &v18[i];
LABEL_43:
            v29 = 1;
            goto LABEL_46;
          }
        }
        else if (v26 == 12290 || v26 == 65294 || v26 == 65377)
        {
          goto LABEL_42;
        }
        ++v21;
      }
    }
    if ((int)v19 < 1)
    {
      v20 = 0;
    }
    else
    {
      v20 = 0;
      v21 = v18 + 1;
      do
      {
        v22 = *(v21 - 1);
        if (v22 > 0xFF0D)
        {
          if (v22 == 65377 || v22 == 65294)
            goto LABEL_43;
        }
        else if (v22 == 46 || v22 == 12290)
        {
          goto LABEL_43;
        }
        ++v20;
        ++v21;
      }
      while (v19 != v20);
      v20 = v19;
    }
    v29 = 0;
    v21 = &v18[(int)v19];
LABEL_46:
    v30 = v16;
    v31 = sub_18BC378A4(v18, v20, v13, v10, v37, v16, (uint64_t)v38, (int *)status);
    if (*status == U_BUFFER_OVERFLOW_ERROR)
    {
      v10 = 0;
      *status = U_ZERO_ERROR;
      goto LABEL_49;
    }
    if (*(int *)status > 0)
      break;
LABEL_49:
    v17 = (v31 + v17);
    if (v10 <= v31)
      v32 = 0;
    else
      v32 = v31;
    if (v10 <= v31)
      v10 = 0;
    else
      v10 -= v31;
    v16 = v30;
    if (!v29)
      goto LABEL_64;
    v13 += v32;
    if (v10 >= 1)
    {
      *v13++ = v18[(int)v20];
      --v10;
    }
    v17 = (v17 + 1);
    if ((int)v19 <= 0)
      v19 = v19;
    else
      v19 = v36 - ((unint64_t)((char *)v21 - (char *)v35) >> 1);
    v18 = v21;
  }
  v16 = v30;
LABEL_64:
  if ((int)v17 >= 256)
    *status = U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR;
  usprep_close(v16);
  return u_terminateUChars(v33, v34, v17, (int *)status);
}

int32_t uidna_compare(const UChar *s1, int32_t length1, const UChar *s2, int32_t length2, int32_t options, UErrorCode *status)
{
  int32_t v7;
  UChar *v14;
  int32_t v15;
  int32_t v16;
  UChar *v17;
  int32_t v18;
  int32_t v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  UParseError v27;
  UChar v28[8];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  UChar dest[8];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  if (!status || *(int *)status > 0)
    return -1;
  v91 = 0u;
  v90 = 0u;
  v89 = 0u;
  v88 = 0u;
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  v80 = 0u;
  v81 = 0u;
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  *(_OWORD *)dest = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  *(_OWORD *)v28 = 0u;
  v29 = 0u;
  memset(&v27, 0, sizeof(v27));
  v14 = dest;
  v15 = uidna_IDNToASCII(s1, length1, dest, 256, options, &v27, status);
  v16 = v15;
  if (*status != U_BUFFER_OVERFLOW_ERROR)
  {
LABEL_8:
    v17 = v28;
    v18 = uidna_IDNToASCII(s2, length2, v28, 256, options, &v27, status);
    v19 = v18;
    if (*status == U_BUFFER_OVERFLOW_ERROR)
    {
      v17 = (UChar *)uprv_malloc(2 * v18);
      if (!v17)
      {
        *status = U_MEMORY_ALLOCATION_ERROR;
        v7 = -1;
        goto LABEL_33;
      }
      *status = U_ZERO_ERROR;
      v19 = uidna_IDNToASCII(s2, length2, v17, v19, options, &v27, status);
    }
    if (v16 >= v19)
      v20 = v19;
    else
      v20 = v16;
    if (v16 < v19)
      v21 = -1;
    else
      v21 = 1;
    if (v16 == v19)
      v7 = 0;
    else
      v7 = v21;
    if (v20)
    {
      v22 = 0;
      v23 = 2 * v20;
      while (1)
      {
        v24 = v14[v22 / 2];
        v25 = v17[v22 / 2];
        if (v24 != v25)
        {
          if ((v24 - 65) < 0x1A)
            LOWORD(v24) = v24 + 32;
          if ((v25 - 65) < 0x1A)
            LOWORD(v25) = v25 + 32;
          v26 = (unsigned __int16)v24 - (unsigned __int16)v25;
          if (v26)
            break;
        }
        v22 += 2;
        if (v23 == v22)
          goto LABEL_33;
      }
      v7 = v26;
    }
LABEL_33:
    if (v14 == dest)
      goto LABEL_35;
    goto LABEL_34;
  }
  v14 = (UChar *)uprv_malloc(2 * v15);
  if (v14)
  {
    *status = U_ZERO_ERROR;
    v16 = uidna_IDNToASCII(s1, length1, v14, v16, options, &v27, status);
    goto LABEL_8;
  }
  *status = U_MEMORY_ALLOCATION_ERROR;
  v17 = v28;
  v7 = -1;
LABEL_34:
  uprv_free(v14);
LABEL_35:
  if (v17 != v28)
    uprv_free(v17);
  return v7;
}

void u_init(UErrorCode *a1)
{
  unsigned int v2;

  if (*(int *)a1 <= 0)
  {
    v2 = atomic_load(&dword_1EE0095B0);
    if (v2 == 2 || !icu::umtx_initImplPreInit(&dword_1EE0095B0))
    {
      if (dword_1EE0095B4 >= 1)
        *a1 = dword_1EE0095B4;
    }
    else
    {
      ucnv_io_countKnownConverters(a1);
      sub_18BC0ECC4(0x1Au, (uint64_t)sub_18BC38668);
      dword_1EE0095B4 = *a1;
      icu::umtx_initImplPostInit(&dword_1EE0095B0);
    }
  }
}

uint64_t sub_18BC38668()
{
  atomic_store(0, &dword_1EE0095B0);
  return 1;
}

void u_charsToUChars(const char *cs, UChar *us, int32_t length)
{
  unsigned int v3;
  UChar v4;

  if (length >= 1)
  {
    v3 = length + 1;
    do
    {
      v4 = *(unsigned __int8 *)cs++;
      *us++ = v4;
      --v3;
    }
    while (v3 > 1);
  }
}

void u_UCharsToChars(const UChar *us, char *cs, int32_t length)
{
  int v3;
  unsigned int v4;
  unsigned int v5;

  if (length >= 1)
  {
    v3 = length + 1;
    do
    {
      v5 = *us++;
      v4 = v5;
      if (v5 > 0x7F || ((dword_18BE14B14[v4 >> 5] >> v4) & 1) == 0)
        LOBYTE(v4) = 0;
      *cs++ = v4;
      --v3;
    }
    while (v3 > 1);
  }
}

uint64_t uprv_isInvariantString(unsigned __int8 *a1, int a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;

  while ((a2 & 0x80000000) == 0)
  {
    if (!a2)
      return 1;
    --a2;
    v3 = *a1++;
    v2 = v3;
    if (v3)
    {
LABEL_6:
      if ((v2 & 0x80) != 0 || ((dword_18BE14B14[v2 >> 5] >> v2) & 1) == 0)
        return 0;
    }
  }
  v4 = *a1++;
  v2 = v4;
  if (v4)
    goto LABEL_6;
  return 1;
}

uint64_t uprv_isInvariantUString(_WORD *a1, int a2)
{
  unsigned int v2;

  while ((a2 & 0x80000000) == 0)
  {
    if (!a2)
      return 1;
    --a2;
    v2 = (unsigned __int16)*a1;
LABEL_5:
    if (v2 <= 0x7F)
    {
      ++a1;
      if (((dword_18BE14B14[v2 >> 5] >> v2) & 1) != 0)
        continue;
    }
    return 0;
  }
  v2 = (unsigned __int16)*a1;
  if (*a1)
    goto LABEL_5;
  return 1;
}

uint64_t uprv_ebcdicFromAscii(uint64_t a1, char *a2, uint64_t a3, _BYTE *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  unsigned __int8 v11;
  int v12;

  if (!a5)
    return 0;
  if (*a5 <= 0)
  {
    v9 = 1;
    if (a1 && a2 && (a3 & 0x80000000) == 0 && (!(_DWORD)a3 || a4))
    {
      if (!(_DWORD)a3)
        return a3;
      v10 = 0;
      while (1)
      {
        v12 = *a2++;
        v11 = v12;
        if (v12 < 0 || ((*(_DWORD *)((char *)dword_18BE14B14 + (((unint64_t)v11 >> 3) & 0x1C)) >> v11) & 1) == 0)
          break;
        *a4++ = byte_18BE14D27[v11];
        --v10;
        if ((int)a3 + v10 + 1 <= 1)
          return a3;
      }
      udata_printError(a1, (uint64_t)"uprv_ebcdicFromAscii() string[%d] contains a variant character in position %d\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, a3);
      v9 = 10;
    }
    a3 = 0;
    *a5 = v9;
    return a3;
  }
  return 0;
}

uint64_t sub_18BC38868(uint64_t a1, _BYTE *a2, uint64_t __n, _BYTE *__dst, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  uint64_t v12;
  int v13;

  if (!a5 || *a5 > 0)
    return 0;
  if (a1 && a2 && (v9 = __n, (__n & 0x80000000) == 0) && (!(_DWORD)__n || __dst))
  {
    if ((_DWORD)__n)
    {
      v12 = 0;
      v13 = __n + 1;
      do
      {
        if ((char)a2[v12] < 0
          || ((*(_DWORD *)((char *)dword_18BE14B14 + (((unint64_t)a2[v12] >> 3) & 0x1C)) >> a2[v12]) & 1) == 0)
        {
          udata_printError(a1, (uint64_t)"uprv_copyFromAscii() string[%d] contains a variant character in position %d\n", __n, (uint64_t)__dst, (uint64_t)a5, a6, a7, a8, __n);
          v9 = 0;
          v10 = 10;
          goto LABEL_10;
        }
        ++v12;
        --v13;
      }
      while (v13 > 1);
      if (a2 != __dst)
        memcpy(__dst, a2, __n);
    }
  }
  else
  {
    v9 = 0;
    v10 = 1;
LABEL_10:
    *a5 = v10;
  }
  return v9;
}

uint64_t sub_18BC3894C(uint64_t a1, unsigned __int8 *a2, uint64_t a3, _BYTE *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  unint64_t v11;
  unsigned int v12;

  if (!a5)
    return 0;
  if (*a5 <= 0)
  {
    v9 = 1;
    if (a1 && a2 && (a3 & 0x80000000) == 0 && (!(_DWORD)a3 || a4))
    {
      if (!(_DWORD)a3)
        return a3;
      v10 = 0;
      while (1)
      {
        v12 = *a2++;
        v11 = v12;
        if (v12)
        {
          v11 = byte_18BE14B24[v11];
          if (!v11 || ((*(_DWORD *)((char *)dword_18BE14B14 + ((v11 >> 3) & 0x1C)) >> v11) & 1) == 0)
            break;
        }
        *a4++ = v11;
        --v10;
        if ((int)a3 + v10 + 1 <= 1)
          return a3;
      }
      udata_printError(a1, (uint64_t)"uprv_asciiFromEbcdic() string[%d] contains a variant character in position %d\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, a3);
      v9 = 10;
    }
    a3 = 0;
    *a5 = v9;
    return a3;
  }
  return 0;
}

uint64_t sub_18BC38A24(uint64_t a1, _BYTE *a2, uint64_t __n, _BYTE *__dst, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  uint64_t v12;
  int v13;
  unint64_t v14;

  if (!a5 || *a5 > 0)
    return 0;
  if (a1 && a2 && (v9 = __n, (__n & 0x80000000) == 0) && (!(_DWORD)__n || __dst))
  {
    if ((_DWORD)__n)
    {
      v12 = 0;
      v13 = __n + 1;
      do
      {
        if (a2[v12])
        {
          if (!byte_18BE14B24[a2[v12]]
            || (v14 = byte_18BE14B24[a2[v12]],
                ((*(_DWORD *)((char *)dword_18BE14B14 + ((v14 >> 3) & 0x1C)) >> v14) & 1) == 0))
          {
            udata_printError(a1, (uint64_t)"uprv_copyEbcdic() string[%] contains a variant character in position %d\n", __n, (uint64_t)__dst, (uint64_t)a5, a6, a7, a8, __n);
            v9 = 0;
            v10 = 10;
            goto LABEL_10;
          }
        }
        ++v12;
        --v13;
      }
      while (v13 > 1);
      if (a2 != __dst)
        memcpy(__dst, a2, __n);
    }
  }
  else
  {
    v9 = 0;
    v10 = 1;
LABEL_10:
    *a5 = v10;
  }
  return v9;
}

uint64_t sub_18BC38B10(int a1, char *__s, int a3, UChar *s, int a5)
{
  uint64_t result;
  int v6;
  const UChar *v7;
  int32_t v8;
  char *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;

  result = 0;
  if (!__s)
    return result;
  v6 = a3;
  if (a3 < -1)
    return result;
  v7 = s;
  if (!s)
    return result;
  v8 = a5;
  if (a5 < -1)
    return result;
  v9 = __s;
  if ((a3 & 0x80000000) == 0)
  {
    if ((a5 & 0x80000000) == 0)
      goto LABEL_8;
    goto LABEL_7;
  }
  v6 = strlen(__s);
  if (v8 < 0)
LABEL_7:
    v8 = u_strlen(v7);
LABEL_8:
  result = (v6 - v8);
  if (v6 >= v8)
    v10 = v8;
  else
    v10 = v6;
  if (v10 >= 1)
  {
    v11 = v10 + 1;
    while (1)
    {
      v13 = *v9++;
      LOBYTE(v12) = v13;
      if (v13 < 0
        || (v12 = v12,
            ((*(_DWORD *)((char *)dword_18BE14B14 + (((unint64_t)v12 >> 3) & 0x1C)) >> v12) & 1) == 0))
      {
        v12 = -1;
      }
      v15 = *v7++;
      v14 = v15;
      if (v15 > 0x7F || ((*(_DWORD *)((char *)dword_18BE14B14 + ((v14 >> 3) & 0x1FFC)) >> v14) & 1) == 0)
        LODWORD(v14) = -2;
      v16 = (v12 - v14);
      if ((_DWORD)v16)
        break;
      if (--v11 < 2)
        return result;
    }
    return v16;
  }
  return result;
}

uint64_t sub_18BC38C08(int a1, char *__s, int a3, UChar *s, int a5)
{
  uint64_t result;
  int v6;
  const UChar *v7;
  int32_t v8;
  char *v9;
  int v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;

  result = 0;
  if (!__s)
    return result;
  v6 = a3;
  if (a3 < -1)
    return result;
  v7 = s;
  if (!s)
    return result;
  v8 = a5;
  if (a5 < -1)
    return result;
  v9 = __s;
  if ((a3 & 0x80000000) == 0)
  {
    if ((a5 & 0x80000000) == 0)
      goto LABEL_8;
    goto LABEL_7;
  }
  v6 = strlen(__s);
  if (v8 < 0)
LABEL_7:
    v8 = u_strlen(v7);
LABEL_8:
  result = (v6 - v8);
  if (v6 >= v8)
    v10 = v8;
  else
    v10 = v6;
  if (v10 >= 1)
  {
    v11 = v10 + 1;
    while (1)
    {
      v13 = *v9++;
      v12 = v13;
      if (v13)
      {
        v12 = byte_18BE14B24[v12];
        if (!(_DWORD)v12 || ((*(_DWORD *)((char *)dword_18BE14B14 + ((v12 >> 3) & 0x1C)) >> v12) & 1) == 0)
          LODWORD(v12) = -1;
      }
      v15 = *v7++;
      v14 = v15;
      if (v15 > 0x7F || ((*(_DWORD *)((char *)dword_18BE14B14 + ((v14 >> 3) & 0x1FFC)) >> v14) & 1) == 0)
        LODWORD(v14) = -2;
      v16 = (v12 - v14);
      if ((_DWORD)v16)
        break;
      if (--v11 < 2)
        return result;
    }
    return v16;
  }
  return result;
}

uint64_t uprv_compareInvEbcdicAsAscii(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2;
  int v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;

  v2 = *a1;
  v3 = *a2;
  if (v2 != v3)
  {
LABEL_5:
    if (v2)
    {
      v8 = byte_18BE14B24[v2];
      if (!byte_18BE14B24[v2] || ((*(_DWORD *)((char *)dword_18BE14B14 + ((v8 >> 3) & 0x1C)) >> v8) & 1) == 0)
        LODWORD(v8) = -v2;
      if (v3)
        goto LABEL_10;
    }
    else
    {
      LODWORD(v8) = 0;
      if (v3)
      {
LABEL_10:
        v9 = byte_18BE14B24[v3];
        if (!byte_18BE14B24[v3] || ((*(_DWORD *)((char *)dword_18BE14B14 + ((v9 >> 3) & 0x1C)) >> v9) & 1) == 0)
          LODWORD(v9) = -v3;
        return (v8 - v9);
      }
    }
    LODWORD(v9) = 0;
    return (v8 - v9);
  }
  v4 = a2 + 1;
  v5 = a1 + 1;
  while (v2)
  {
    v6 = *v5++;
    v2 = v6;
    v7 = *v4++;
    v3 = v7;
    if (v2 != v7)
      goto LABEL_5;
  }
  return 0;
}

uint64_t uprv_ebcdicToAscii(unsigned __int8 a1)
{
  return (char)byte_18BE14B24[a1];
}

uint64_t uprv_ebcdicToLowercaseAscii(unsigned __int8 a1)
{
  return byte_18BE14C27[a1];
}

_BYTE *uprv_aestrncpy(_BYTE *a1, char *__s, int a3)
{
  int v5;
  BOOL v6;
  int v7;
  char *v8;
  _BYTE *v9;
  int v10;
  BOOL v11;

  if (a3 == -1)
    a3 = strlen(__s) + 1;
  v5 = *__s;
  if (*__s)
    v6 = a3 < 1;
  else
    v6 = 1;
  if (v6)
  {
    v9 = a1;
    v7 = a3;
  }
  else
  {
    v8 = __s + 1;
    v9 = a1;
    do
    {
      *v9++ = byte_18BE14B24[v5];
      v7 = a3 - 1;
      v10 = *v8++;
      v5 = v10;
      if (v10)
        v11 = a3 > 1;
      else
        v11 = 0;
      --a3;
    }
    while (v11);
  }
  if (v7 >= 1)
    bzero(v9, v7);
  return a1;
}

_BYTE *uprv_eastrncpy(_BYTE *a1, char *__s, int a3)
{
  int v5;
  BOOL v6;
  int v7;
  char *v8;
  _BYTE *v9;
  int v10;
  int v11;
  BOOL v12;

  if (a3 == -1)
    a3 = strlen(__s) + 1;
  v5 = *__s;
  if (*__s)
    v6 = a3 < 1;
  else
    v6 = 1;
  if (v6)
  {
    v9 = a1;
    v7 = a3;
  }
  else
  {
    v8 = __s + 1;
    v9 = a1;
    do
    {
      v10 = byte_18BE14D27[v5];
      if (!v10)
        LOBYTE(v10) = 111;
      *v9++ = v10;
      v7 = a3 - 1;
      v11 = *v8++;
      v5 = v11;
      if (v11)
        v12 = a3 > 1;
      else
        v12 = 0;
      --a3;
    }
    while (v12);
  }
  if (v7 >= 1)
    bzero(v9, v7);
  return a1;
}

void uiter_setString(UCharIterator *iter, const UChar *s, int32_t length)
{
  if (iter)
  {
    if (s && length >= -1)
    {
      *iter = *(UCharIterator *)byte_1E22525E0;
      iter->context = s;
      if (length < 0)
        length = u_strlen(s);
      iter->length = length;
      iter->limit = length;
    }
    else
    {
      *iter = *(UCharIterator *)byte_1E2252650;
    }
  }
}

void uiter_setUTF16BE(UCharIterator *iter, const char *s, int32_t length)
{
  UCharIterator *v3;
  uint64_t i;

  if (iter)
  {
    v3 = iter;
    if (!s)
    {
LABEL_5:
      *iter = *(UCharIterator *)byte_1E2252650;
      return;
    }
    if (length == -1)
    {
      *iter = *(UCharIterator *)byte_1E22526C0;
      iter->context = s;
      if ((s & 1) != 0)
      {
        for (i = 0; s[i] || s[i + 1]; i += 2)
          ;
        iter = (UCharIterator *)((i + (unint64_t)(i < 0)) >> 1);
      }
      else
      {
        LODWORD(iter) = u_strlen((const UChar *)s);
      }
    }
    else
    {
      if ((length & 0x80000001) != 0)
        goto LABEL_5;
      *iter = *(UCharIterator *)byte_1E22526C0;
      LODWORD(iter) = length >> 1;
      v3->context = s;
    }
    v3->length = (int)iter;
    v3->limit = (int)iter;
  }
}

double uiter_setCharacterIterator(_OWORD *a1, uint64_t a2)
{
  double result;

  if (a1)
  {
    if (a2)
    {
      a1[4] = xmmword_1E2252770;
      a1[5] = *(_OWORD *)&off_1E2252780;
      a1[6] = xmmword_1E2252790;
      *a1 = xmmword_1E2252730;
      a1[1] = unk_1E2252740;
      result = COERCE_DOUBLE(sub_18BC397C0);
      a1[2] = xmmword_1E2252750;
      a1[3] = *(_OWORD *)&off_1E2252760;
      *(_QWORD *)a1 = a2;
    }
    else
    {
      a1[4] = xmmword_1E2252690;
      a1[5] = *(_OWORD *)&off_1E22526A0;
      a1[6] = xmmword_1E22526B0;
      *a1 = xmmword_1E2252650;
      a1[1] = unk_1E2252660;
      result = COERCE_DOUBLE(sub_18BC39614);
      a1[2] = xmmword_1E2252670;
      a1[3] = *(_OWORD *)&off_1E2252680;
    }
  }
  return result;
}

double uiter_setReplaceable(uint64_t a1, uint64_t a2)
{
  int v3;
  double result;

  if (a1)
  {
    if (a2)
    {
      *(_OWORD *)a1 = xmmword_1E22527A0;
      *(_OWORD *)(a1 + 16) = *(_OWORD *)algn_1E22527B0;
      *(_OWORD *)(a1 + 96) = xmmword_1E2252800;
      *(_OWORD *)(a1 + 64) = xmmword_1E22527E0;
      *(_OWORD *)(a1 + 80) = *(_OWORD *)&off_1E22527F0;
      *(_OWORD *)(a1 + 32) = xmmword_1E22527C0;
      *(_OWORD *)(a1 + 48) = *(_OWORD *)&off_1E22527D0;
      *(_QWORD *)a1 = a2;
      v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2);
      *(_DWORD *)(a1 + 8) = v3;
      *(_DWORD *)(a1 + 20) = v3;
    }
    else
    {
      *(_OWORD *)(a1 + 64) = xmmword_1E2252690;
      *(_OWORD *)(a1 + 80) = *(_OWORD *)&off_1E22526A0;
      *(_OWORD *)(a1 + 96) = xmmword_1E22526B0;
      *(_OWORD *)a1 = xmmword_1E2252650;
      *(_OWORD *)(a1 + 16) = unk_1E2252660;
      result = COERCE_DOUBLE(sub_18BC39614);
      *(_OWORD *)(a1 + 32) = xmmword_1E2252670;
      *(_OWORD *)(a1 + 48) = *(_OWORD *)&off_1E2252680;
    }
  }
  return result;
}

void uiter_setUTF8(UCharIterator *iter, const char *s, int32_t length)
{
  int32_t v4;

  if (iter)
  {
    if (s && length >= -1)
    {
      *iter = *(UCharIterator *)byte_1E2252810;
      iter->context = s;
      if (length < 0)
        length = strlen(s);
      iter->limit = length;
      if (length >= 2)
        v4 = -1;
      else
        v4 = length;
      iter->length = v4;
    }
    else
    {
      *iter = *(UCharIterator *)byte_1E2252650;
    }
  }
}

UChar32 uiter_current32(UCharIterator *iter)
{
  unsigned int v2;
  UChar32 v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;

  v2 = ((uint64_t (*)(void))iter->current)();
  v3 = v2;
  if (v2 >> 11 == 27)
  {
    if ((v2 & 0x400) == 0)
    {
      ((void (*)(UCharIterator *, uint64_t, uint64_t))iter->move)(iter, 1, 1);
      v4 = ((uint64_t (*)(UCharIterator *))iter->current)(iter);
      if (v4 >> 10 == 55)
        v3 = v4 + (v3 << 10) - 56613888;
      v5 = 0xFFFFFFFFLL;
      goto LABEL_10;
    }
    v6 = ((uint64_t (*)(UCharIterator *))iter->previous)(iter);
    if (v6 >> 10 == 54)
      v3 = v3 + (v6 << 10) - 56613888;
    if ((v6 & 0x80000000) == 0)
    {
      v5 = 1;
LABEL_10:
      ((void (*)(UCharIterator *, uint64_t, uint64_t))iter->move)(iter, v5, 1);
    }
  }
  return v3;
}

UChar32 uiter_next32(UCharIterator *iter)
{
  unsigned int v2;
  unsigned int v3;

  v2 = ((uint64_t (*)(void))iter->next)();
  if (v2 >> 10 == 54)
  {
    v3 = ((uint64_t (*)(UCharIterator *))iter->next)(iter);
    if (v3 >> 10 == 55)
    {
      return v3 + (v2 << 10) - 56613888;
    }
    else if ((v3 & 0x80000000) == 0)
    {
      ((void (*)(UCharIterator *, uint64_t, uint64_t))iter->move)(iter, 0xFFFFFFFFLL, 1);
    }
  }
  return v2;
}

UChar32 uiter_previous32(UCharIterator *iter)
{
  unsigned int v2;
  unsigned int v3;

  v2 = ((uint64_t (*)(void))iter->previous)();
  if (v2 >> 10 == 55)
  {
    v3 = ((uint64_t (*)(UCharIterator *))iter->previous)(iter);
    if (v3 >> 10 == 54)
    {
      return v2 + (v3 << 10) - 56613888;
    }
    else if ((v3 & 0x80000000) == 0)
    {
      ((void (*)(UCharIterator *, uint64_t, uint64_t))iter->move)(iter, 1, 1);
    }
  }
  return v2;
}

uint32_t uiter_getState(const UCharIterator *iter)
{
  uint64_t (*getState)(void);

  if (iter && (getState = (uint64_t (*)(void))iter->getState) != 0)
    return getState();
  else
    return -1;
}

void uiter_setState(UCharIterator *iter, uint32_t state, UErrorCode *pErrorCode)
{
  void (*setState)(void);
  UErrorCode v4;

  if (pErrorCode && *(int *)pErrorCode <= 0)
  {
    if (iter)
    {
      setState = (void (*)(void))iter->setState;
      if (setState)
      {
        setState();
        return;
      }
      v4 = U_UNSUPPORTED_ERROR;
    }
    else
    {
      v4 = U_ILLEGAL_ARGUMENT_ERROR;
    }
    *pErrorCode = v4;
  }
}

uint64_t sub_18BC39454(unsigned int *a1, int a2)
{
  uint64_t result;

  result = 0;
  switch(a2)
  {
    case 0:
      result = a1[3];
      break;
    case 1:
      result = a1[4];
      break;
    case 2:
      result = a1[5];
      break;
    case 3:
      return result;
    case 4:
      result = a1[2];
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_18BC394A8(_DWORD *a1, int a2, int a3)
{
  int v3;
  uint64_t v4;

  switch(a3)
  {
    case 0:
      v3 = a1[3];
      goto LABEL_7;
    case 1:
      v3 = a1[4];
      goto LABEL_7;
    case 2:
      v3 = a1[5];
      goto LABEL_7;
    case 3:
      goto LABEL_8;
    case 4:
      v3 = a1[2];
LABEL_7:
      a2 += v3;
LABEL_8:
      v4 = a1[3];
      if (a2 >= (int)v4)
      {
        LODWORD(v4) = a1[5];
        if (a2 >= (int)v4)
          v4 = v4;
        else
          v4 = a2;
      }
      a1[4] = v4;
      break;
    default:
      v4 = 0xFFFFFFFFLL;
      break;
  }
  return v4;
}

BOOL sub_18BC39518(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) < *(_DWORD *)(a1 + 20);
}

BOOL sub_18BC39528(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) > *(_DWORD *)(a1 + 12);
}

uint64_t sub_18BC39538(uint64_t a1)
{
  uint64_t v1;

  v1 = *(int *)(a1 + 16);
  if ((int)v1 >= *(_DWORD *)(a1 + 20))
    return 0xFFFFFFFFLL;
  else
    return *(unsigned __int16 *)(*(_QWORD *)a1 + 2 * v1);
}

uint64_t sub_18BC3955C(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((int *)a1 + 4);
  if ((int)v1 >= *((_DWORD *)a1 + 5))
    return 0xFFFFFFFFLL;
  v2 = *a1;
  *((_DWORD *)a1 + 4) = v1 + 1;
  return *(unsigned __int16 *)(v2 + 2 * v1);
}

uint64_t sub_18BC39588(uint64_t *a1)
{
  int v1;
  uint64_t v2;
  int v3;

  v1 = *((_DWORD *)a1 + 4);
  if (v1 <= *((_DWORD *)a1 + 3))
    return 0xFFFFFFFFLL;
  v2 = *a1;
  v3 = v1 - 1;
  *((_DWORD *)a1 + 4) = v3;
  return *(unsigned __int16 *)(v2 + 2 * v3);
}

uint64_t sub_18BC395B0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

_DWORD *sub_18BC395B8(_DWORD *result, int a2, int *a3)
{
  int v3;

  if (a3 && *a3 <= 0)
  {
    if (result)
    {
      if (result[3] <= a2 && result[5] >= a2)
      {
        result[4] = a2;
        return result;
      }
      v3 = 8;
    }
    else
    {
      v3 = 1;
    }
    *a3 = v3;
  }
  return result;
}

uint64_t sub_18BC39604()
{
  return 0;
}

uint64_t sub_18BC3960C()
{
  return 0;
}

uint64_t sub_18BC39614()
{
  return 0;
}

uint64_t sub_18BC3961C()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_18BC39624()
{
  return 0xFFFFFFFFLL;
}

void sub_18BC3962C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = 16;
}

uint64_t sub_18BC39638(uint64_t a1)
{
  uint64_t v1;

  v1 = *(int *)(a1 + 16);
  if ((int)v1 >= *(_DWORD *)(a1 + 20))
    return 0xFFFFFFFFLL;
  else
    return *(unsigned __int8 *)(*(_QWORD *)a1 + 2 * (int)v1 + 1) | (*(unsigned __int8 *)(*(_QWORD *)a1 + 2 * v1) << 8);
}

uint64_t sub_18BC3966C(uint64_t a1)
{
  uint64_t v1;

  v1 = *(int *)(a1 + 16);
  if ((int)v1 >= *(_DWORD *)(a1 + 20))
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 16) = v1 + 1;
  return *(unsigned __int8 *)(*(_QWORD *)a1 + 2 * (int)v1 + 1) | (*(unsigned __int8 *)(*(_QWORD *)a1 + 2 * v1) << 8);
}

uint64_t sub_18BC396A8(uint64_t a1)
{
  int v1;
  int v2;

  v1 = *(_DWORD *)(a1 + 16);
  if (v1 <= *(_DWORD *)(a1 + 12))
    return 0xFFFFFFFFLL;
  v2 = v1 - 1;
  *(_DWORD *)(a1 + 16) = v2;
  return *(unsigned __int8 *)(*(_QWORD *)a1 + 2 * v2 + 1) | (*(unsigned __int8 *)(*(_QWORD *)a1 + 2 * v2) << 8);
}

uint64_t sub_18BC396E0(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  switch(a2)
  {
    case 0:
      result = *(unsigned int *)(*(_QWORD *)a1 + 16);
      break;
    case 1:
      result = *(unsigned int *)(*(_QWORD *)a1 + 12);
      break;
    case 2:
      result = *(unsigned int *)(*(_QWORD *)a1 + 20);
      break;
    case 3:
      return result;
    case 4:
      result = *(unsigned int *)(*(_QWORD *)a1 + 8);
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_18BC39744(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;

  if (a3 < 3)
    return (*(uint64_t (**)(void))(*(_QWORD *)*a1 + 192))();
  if (a3 == 4)
  {
    v5 = *a1;
    goto LABEL_7;
  }
  if (a3 == 3)
  {
    v5 = *a1;
LABEL_7:
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 120))(v5);
    return *(unsigned int *)(*a1 + 12);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_18BC397C0(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 56))(*a1);
}

uint64_t sub_18BC397D0(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 184))(*a1);
}

uint64_t sub_18BC397E0(_QWORD *a1)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 136))(*a1);
  if ((_DWORD)v2 == 0xFFFF)
  {
    if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)*a1 + 56))(*a1))
      return 0xFFFFLL;
    else
      return 0xFFFFFFFFLL;
  }
  return v2;
}

uint64_t sub_18BC39838(_QWORD *a1)
{
  if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)*a1 + 56))(*a1))
    return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 40))(*a1);
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_18BC39880(_QWORD *a1)
{
  if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)*a1 + 184))(*a1))
    return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 168))(*a1);
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_18BC398C8(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 12);
}

_DWORD *sub_18BC398D4(_DWORD *result, int a2, int *a3)
{
  int v3;

  if (a3 && *a3 <= 0)
  {
    if (result && (result = *(_DWORD **)result) != 0)
    {
      if (result[4] <= a2 && result[5] >= a2)
        return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 120))(result);
      v3 = 8;
    }
    else
    {
      v3 = 1;
    }
    *a3 = v3;
  }
  return result;
}

uint64_t sub_18BC3992C(_DWORD *a1)
{
  if (a1[4] >= a1[5])
    return 0xFFFFFFFFLL;
  else
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)a1 + 72))(*(_QWORD *)a1);
}

uint64_t sub_18BC39960(uint64_t *a1)
{
  int v1;
  uint64_t v2;

  v1 = *((_DWORD *)a1 + 4);
  if (v1 >= *((_DWORD *)a1 + 5))
    return 0xFFFFFFFFLL;
  v2 = *a1;
  *((_DWORD *)a1 + 4) = v1 + 1;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 72))(v2);
}

uint64_t sub_18BC399A0(uint64_t *a1)
{
  int v1;
  uint64_t v2;

  v1 = *((_DWORD *)a1 + 4);
  if (v1 <= *((_DWORD *)a1 + 3))
    return 0xFFFFFFFFLL;
  v2 = *a1;
  *((_DWORD *)a1 + 4) = v1 - 1;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 72))(v2);
}

uint64_t sub_18BC399E0(uint64_t *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  unint64_t v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  _BOOL4 v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  unint64_t v38;
  unsigned int v39;
  int v40;
  unsigned int v41;
  int v42;
  unsigned int v43;
  uint64_t v44;

  v2 = 0;
  switch(a2)
  {
    case 0:
    case 3:
      return v2;
    case 1:
      v2 = *((unsigned int *)a1 + 4);
      if ((v2 & 0x80000000) == 0)
        return v2;
      v5 = *((_DWORD *)a1 + 3);
      if (v5 >= 1)
      {
        v6 = 0;
        v7 = 0;
        v8 = *a1;
        while (1)
        {
          v9 = v7;
          v10 = v7 + 1;
          v11 = *(char *)(v8 + v7);
          if ((v11 & 0x80000000) == 0 || (_DWORD)v10 == v5)
            goto LABEL_30;
          v12 = *(unsigned __int8 *)(v8 + v7);
          if (v11 < 0xE0u)
          {
            if (v12 < 0xC2)
              goto LABEL_30;
            v16 = v11 & 0x1F;
          }
          else
          {
            if (v12 > 0xEF)
            {
              if (v12 > 0xF4)
                goto LABEL_30;
              v18 = v12 - 240;
              v13 = *(unsigned __int8 *)(v8 + v10);
              if (((byte_18BE14E40[v13 >> 4] >> v18) & 1) == 0)
                goto LABEL_30;
              v19 = v9 + 2;
              LODWORD(v10) = *((_DWORD *)a1 + 3);
              if ((_DWORD)v9 + 2 == v5)
                goto LABEL_30;
              v14 = *(unsigned __int8 *)(v8 + v19) ^ 0x80;
              if (v14 > 0x3F)
              {
                LODWORD(v10) = v19;
LABEL_30:
                v17 = 1;
                goto LABEL_31;
              }
              LODWORD(v13) = v13 & 0x3F | (v18 << 6);
              LODWORD(v10) = v19;
            }
            else
            {
              v13 = v11 & 0xF;
              if (((a00000000000000[v13] >> (*(_BYTE *)(v8 + v10) >> 5)) & 1) == 0)
                goto LABEL_30;
              v14 = *(_BYTE *)(v8 + v10) & 0x3F;
            }
            v15 = v10 + 1;
            LODWORD(v10) = *((_DWORD *)a1 + 3);
            if (v15 == v5)
              goto LABEL_30;
            v16 = v14 | ((_DWORD)v13 << 6);
            LODWORD(v10) = v15;
          }
          if (*(char *)(v8 + (int)v10) > -65)
            goto LABEL_30;
          LODWORD(v10) = v10 + 1;
          if (v16 <= 0x3FF)
            goto LABEL_30;
          v17 = 2;
LABEL_31:
          v6 += v17;
          v7 = v10;
          if ((int)v10 >= v5)
            goto LABEL_58;
        }
      }
      LODWORD(v10) = 0;
      v6 = 0;
LABEL_58:
      *((_DWORD *)a1 + 3) = v10;
      if ((_DWORD)v10 == *((_DWORD *)a1 + 5))
        *((_DWORD *)a1 + 2) = v6;
      v2 = v6 - (*((_DWORD *)a1 + 6) != 0);
      *((_DWORD *)a1 + 4) = v2;
      return v2;
    case 2:
    case 4:
      v2 = *((unsigned int *)a1 + 2);
      if ((v2 & 0x80000000) == 0)
        return v2;
      v3 = *a1;
      v4 = *((_DWORD *)a1 + 3);
      LODWORD(v2) = *((_DWORD *)a1 + 4);
      if ((v2 & 0x80000000) != 0)
      {
        if (v4 < 1)
        {
          LODWORD(v22) = 0;
          v2 = 0;
LABEL_62:
          v32 = *((_DWORD *)a1 + 6) != 0;
          *((_DWORD *)a1 + 3) = v22;
          *((_DWORD *)a1 + 4) = v2 - v32;
          v4 = v22;
          goto LABEL_63;
        }
        LODWORD(v2) = 0;
        v20 = 0;
        while (1)
        {
          v21 = v20;
          v22 = v20 + 1;
          v23 = *(char *)(v3 + v20);
          if ((v23 & 0x80000000) == 0 || (_DWORD)v22 == v4)
            goto LABEL_54;
          v24 = *(unsigned __int8 *)(v3 + v20);
          if (v23 < 0xE0u)
          {
            if (v24 < 0xC2)
              goto LABEL_54;
            v28 = v23 & 0x1F;
          }
          else
          {
            if (v24 > 0xEF)
            {
              if (v24 > 0xF4)
                goto LABEL_54;
              v30 = v24 - 240;
              v25 = *(unsigned __int8 *)(v3 + v22);
              if (((byte_18BE14E40[v25 >> 4] >> v30) & 1) == 0)
                goto LABEL_54;
              v31 = v21 + 2;
              LODWORD(v22) = *((_DWORD *)a1 + 3);
              if ((_DWORD)v21 + 2 == v4)
                goto LABEL_54;
              v26 = *(unsigned __int8 *)(v3 + v31) ^ 0x80;
              if (v26 > 0x3F)
              {
                LODWORD(v22) = v31;
LABEL_54:
                v29 = 1;
                goto LABEL_55;
              }
              LODWORD(v25) = v25 & 0x3F | (v30 << 6);
              LODWORD(v22) = v31;
            }
            else
            {
              v25 = v23 & 0xF;
              if (((a00000000000000[v25] >> (*(_BYTE *)(v3 + v22) >> 5)) & 1) == 0)
                goto LABEL_54;
              v26 = *(_BYTE *)(v3 + v22) & 0x3F;
            }
            v27 = v22 + 1;
            LODWORD(v22) = *((_DWORD *)a1 + 3);
            if (v27 == v4)
              goto LABEL_54;
            v28 = v26 | ((_DWORD)v25 << 6);
            LODWORD(v22) = v27;
          }
          if (*(char *)(v3 + (int)v22) > -65)
            goto LABEL_54;
          LODWORD(v22) = v22 + 1;
          if (v28 <= 0x3FF)
            goto LABEL_54;
          v29 = 2;
LABEL_55:
          v2 = (v29 + v2);
          v20 = v22;
          if ((int)v22 >= v4)
            goto LABEL_62;
        }
      }
      if (*((_DWORD *)a1 + 6))
        v2 = (v2 + 1);
      else
        v2 = v2;
LABEL_63:
      v33 = *((_DWORD *)a1 + 5);
      if (v4 < v33)
      {
        do
        {
          v34 = v4;
          v35 = v4 + 1;
          v36 = *(char *)(v3 + v4);
          if ((v36 & 0x80000000) == 0 || (_DWORD)v35 == v33)
            goto LABEL_83;
          v37 = *(unsigned __int8 *)(v3 + v4);
          if (v36 < 0xE0u)
          {
            if (v37 < 0xC2)
              goto LABEL_83;
            v41 = v36 & 0x1F;
          }
          else
          {
            if (v37 > 0xEF)
            {
              if (v37 > 0xF4)
                goto LABEL_83;
              v43 = v37 - 240;
              v38 = *(unsigned __int8 *)(v3 + v35);
              if (((byte_18BE14E40[v38 >> 4] >> v43) & 1) == 0)
                goto LABEL_83;
              v44 = v34 + 2;
              LODWORD(v35) = *((_DWORD *)a1 + 5);
              if ((_DWORD)v34 + 2 == v33)
                goto LABEL_83;
              v39 = *(unsigned __int8 *)(v3 + v44) ^ 0x80;
              if (v39 > 0x3F)
              {
                LODWORD(v35) = v44;
LABEL_83:
                v42 = 1;
                goto LABEL_84;
              }
              LODWORD(v38) = v38 & 0x3F | (v43 << 6);
              LODWORD(v35) = v44;
            }
            else
            {
              v38 = v36 & 0xF;
              if (((a00000000000000[v38] >> (*(_BYTE *)(v3 + v35) >> 5)) & 1) == 0)
                goto LABEL_83;
              v39 = *(_BYTE *)(v3 + v35) & 0x3F;
            }
            v40 = v35 + 1;
            LODWORD(v35) = *((_DWORD *)a1 + 5);
            if (v40 == v33)
              goto LABEL_83;
            v41 = v39 | ((_DWORD)v38 << 6);
            LODWORD(v35) = v40;
          }
          if (*(char *)(v3 + (int)v35) > -65)
            goto LABEL_83;
          LODWORD(v35) = v35 + 1;
          if (v41 <= 0x3FF)
            goto LABEL_83;
          v42 = 2;
LABEL_84:
          v2 = (v42 + v2);
          v4 = v35;
        }
        while ((int)v35 < v33);
      }
      *((_DWORD *)a1 + 2) = v2;
      return v2;
    default:
      return 0xFFFFFFFFLL;
  }
}

uint64_t sub_18BC39DF0(uint64_t a1, signed int a2, int a3)
{
  signed int v3;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  const uint8_t *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  char v17;
  unint64_t v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  UChar32 v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v32;
  int32_t pi;

  v3 = a2;
  switch(a3)
  {
    case 0:
    case 3:
      goto LABEL_7;
    case 1:
      v7 = *(unsigned int *)(a1 + 16);
      if ((v7 & 0x80000000) == 0)
      {
        v3 = v7 + a2;
        goto LABEL_7;
      }
      if (!a2)
        return 4294967294;
      v9 = *(unsigned int *)(a1 + 12);
      goto LABEL_56;
    case 2:
    case 4:
      v5 = *(_DWORD *)(a1 + 8);
      if ((v5 & 0x80000000) == 0)
      {
        v3 = v5 + a2;
LABEL_7:
        if (v3 > 0)
        {
          v6 = *(unsigned int *)(a1 + 8);
          if ((v6 & 0x80000000) == 0 && (int)v6 <= v3)
          {
            *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 20);
            *(_DWORD *)(a1 + 16) = v6;
            *(_DWORD *)(a1 + 24) = 0;
            return v6;
          }
          v8 = (_DWORD *)(a1 + 16);
          v7 = *(unsigned int *)(a1 + 16);
          if ((v7 & 0x80000000) != 0 || v3 < v7 >> 1)
          {
            v6 = 0;
            *(_DWORD *)(a1 + 24) = 0;
            *(_DWORD *)(a1 + 12) = 0;
          }
          else
          {
            if ((v6 & 0x80000000) != 0 || (int)v6 - v3 >= v3 - (int)v7)
              goto LABEL_20;
            *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 20);
            *(_DWORD *)(a1 + 16) = v6;
            v8 = (_DWORD *)(a1 + 24);
          }
          *v8 = 0;
          v7 = v6;
LABEL_20:
          v3 -= v7;
          if (!v3)
            return v7;
          v9 = *(unsigned int *)(a1 + 12);
LABEL_22:
          v10 = *(const uint8_t **)a1;
          if (v3 < 1)
          {
            if (*(_DWORD *)(a1 + 24))
            {
              *(_DWORD *)(a1 + 24) = 0;
              v11 = (v9 - 4);
              v6 = (v7 - 1);
              ++v3;
            }
            else
            {
              v11 = v9;
              v6 = v7;
            }
            if (v3 < 0 && (int)v11 >= 1)
            {
              do
              {
                pi = v11 - 1;
                v25 = (char)v10[(v11 - 1)];
                if (v25 < 0 && (v26 = utf8_prevCharSafeBody(v10, 0, &pi, v25, -3), v26 >= 0x10000))
                {
                  if (v3 >= -1)
                  {
                    v11 = (pi + 4);
                    *(_DWORD *)(a1 + 24) = v26;
                    v6 = (v6 - 1);
                    break;
                  }
                  v27 = 2;
                  v28 = -2;
                }
                else
                {
                  v27 = 1;
                  v28 = -1;
                }
                v6 = (v6 + v28);
                v11 = pi;
                v3 += v27;
              }
              while (v3 < 0 && pi > 0);
            }
          }
          else
          {
            v11 = *(unsigned int *)(a1 + 20);
            v6 = v7;
            if (*(_DWORD *)(a1 + 24))
            {
              *(_DWORD *)(a1 + 24) = 0;
              v6 = (v7 + 1);
              --v3;
            }
            v12 = 0;
            if (v3 && (int)v9 < (int)v11)
            {
              do
              {
                v13 = (int)v9;
                v14 = (char)v10[(int)v9];
                v9 = (int)v9 + 1;
                v15 = -1;
                v16 = 1;
                if ((v14 & 0x80000000) == 0 || (_DWORD)v9 == (_DWORD)v11)
                  goto LABEL_47;
                v17 = v14;
                if (v14 < 0xE0u)
                {
                  if (v14 < 0xC2u)
                    goto LABEL_46;
                  v20 = v14 & 0x1F;
                }
                else
                {
                  if (v14 > 0xEFu)
                  {
                    if (v14 > 0xF4u)
                    {
LABEL_46:
                      v15 = -1;
                      goto LABEL_47;
                    }
                    v22 = v14 - 240;
                    v18 = v10[v9];
                    if (((byte_18BE14E40[v18 >> 4] >> (v17 + 16)) & 1) == 0)
                      goto LABEL_45;
                    v9 = v13 + 2;
                    if ((_DWORD)v13 + 2 == (_DWORD)v11)
                    {
LABEL_44:
                      v15 = -1;
                      v16 = 1;
                      v9 = v11;
                      goto LABEL_47;
                    }
                    v19 = v10[v9] ^ 0x80;
                    if (v19 > 0x3F)
                    {
                      v15 = -1;
                      v16 = 1;
                      goto LABEL_47;
                    }
                    LODWORD(v18) = v18 & 0x3F | (v22 << 6);
                  }
                  else
                  {
                    v18 = v14 & 0xF;
                    if (((a00000000000000[v18] >> (v10[v9] >> 5)) & 1) == 0)
                      goto LABEL_45;
                    v19 = v10[v9] & 0x3F;
                  }
                  v9 = (v9 + 1);
                  if ((_DWORD)v9 == (_DWORD)v11)
                    goto LABEL_44;
                  v20 = v19 | ((_DWORD)v18 << 6);
                }
                v21 = v10[(int)v9] ^ 0x80;
                if (v21 > 0x3F || (v12 = v21 | (v20 << 6), v9 = (v9 + 1), v12 < 0x10000))
                {
LABEL_45:
                  v15 = -1;
                  v16 = 1;
                  goto LABEL_47;
                }
                if (v3 <= 1)
                {
                  *(_DWORD *)(a1 + 24) = v12;
                  v6 = (v6 + 1);
                  break;
                }
                v15 = -2;
                v16 = 2;
LABEL_47:
                v12 = 0;
                v6 = (v6 + v16);
                v3 += v15;
              }
              while (v3 >= 1 && (int)v9 < (int)v11);
            }
            if ((_DWORD)v9 == (_DWORD)v11)
            {
              v29 = *(_DWORD *)(a1 + 8);
              if (v29 < 0)
              {
                if ((v7 & 0x80000000) == 0)
                {
                  if (v12)
                    v32 = v6 + 1;
                  else
                    v32 = v6;
                  *(_DWORD *)(a1 + 8) = v32;
                }
              }
              else if ((v7 & 0x80000000) != 0)
              {
                v30 = v29 - (v12 != 0);
                *(_DWORD *)(a1 + 16) = v30;
LABEL_83:
                *(_DWORD *)(a1 + 12) = v11;
                if ((v30 & 0x80000000) == 0)
                {
                  *(_DWORD *)(a1 + 16) = v6;
                  return v6;
                }
                if ((int)v11 <= 1)
                {
                  *(_DWORD *)(a1 + 16) = v11;
                  return v11;
                }
                return 4294967294;
              }
            }
            else
            {
              v11 = v9;
            }
          }
          v30 = *(_DWORD *)(a1 + 16);
          goto LABEL_83;
        }
LABEL_61:
        v6 = 0;
        *(_DWORD *)(a1 + 24) = 0;
        *(_DWORD *)(a1 + 12) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        return v6;
      }
      v7 = 0xFFFFFFFFLL;
      v9 = *(unsigned int *)(a1 + 20);
      *(_DWORD *)(a1 + 12) = v9;
      *(_DWORD *)(a1 + 16) = -1;
      *(_DWORD *)(a1 + 24) = 0;
      if ((a2 & 0x80000000) == 0)
        return 4294967294;
LABEL_56:
      if ((int)v9 <= -a2)
        goto LABEL_61;
      v23 = *(_DWORD *)(a1 + 20);
      if (v23 - (int)v9 > a2)
        goto LABEL_22;
      v24 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 12) = v23;
      *(_DWORD *)(a1 + 16) = v24;
      *(_DWORD *)(a1 + 24) = 0;
      if (v24 < 0)
        return 4294967294;
      else
        return v24;
    default:
      return 0xFFFFFFFFLL;
  }
}

BOOL sub_18BC3A1FC(_DWORD *a1)
{
  return a1[3] < a1[5] || a1[6] != 0;
}

BOOL sub_18BC3A224(uint64_t a1)
{
  return *(_DWORD *)(a1 + 12) > 0;
}

uint64_t sub_18BC3A234(uint64_t *a1)
{
  uint64_t result;
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;

  if (*((_DWORD *)a1 + 6))
    return a1[3] & 0x3FF | 0xDC00;
  v2 = *((int *)a1 + 3);
  v3 = *((_DWORD *)a1 + 5);
  if ((int)v2 >= v3)
    return 0xFFFFFFFFLL;
  v4 = *a1;
  v5 = *(char *)(*a1 + v2);
  result = *(unsigned __int8 *)(*a1 + v2);
  if (v5 < 0)
  {
    v6 = v2 + 1;
    if ((_DWORD)v2 + 1 != v3)
    {
      if (result < 0xE0)
      {
        if (result < 0xC2)
          return 65533;
        v9 = result & 0x1F;
      }
      else
      {
        if (result > 0xEF)
        {
          if (result > 0xF4)
            return 65533;
          v6 = *(unsigned __int8 *)(v4 + v6);
          if (((byte_18BE14E40[v6 >> 4] >> (result + 16)) & 1) == 0)
            return 65533;
          v11 = v2 + 2;
          if ((_DWORD)v2 + 2 == v3)
            return 65533;
          v8 = *(unsigned __int8 *)(v4 + v11) ^ 0x80;
          if (v8 > 0x3F)
            return 65533;
          LODWORD(v7) = v6 & 0x3F | (((_DWORD)result - 240) << 6);
          LODWORD(v6) = v11;
        }
        else
        {
          v7 = v5 & 0xF;
          if (((a00000000000000[v7] >> (*(_BYTE *)(v4 + v6) >> 5)) & 1) == 0)
            return 65533;
          v8 = *(_BYTE *)(v4 + v6) & 0x3F;
        }
        LODWORD(v6) = v6 + 1;
        if ((_DWORD)v6 == v3)
          return 65533;
        v9 = v8 | ((_DWORD)v7 << 6);
      }
      v10 = *(unsigned __int8 *)(v4 + (int)v6) ^ 0x80;
      if (v10 <= 0x3F)
      {
        result = v10 | (v9 << 6);
        if (WORD1(result))
          return (unsigned __int16)((v9 >> 4) - 10304);
        return result;
      }
    }
    return 65533;
  }
  return result;
}

uint64_t sub_18BC3A360(uint64_t *a1)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  int v15;

  if (*((_DWORD *)a1 + 6))
  {
    v1 = a1[3] & 0x3FF | 0xDC00;
    *((_DWORD *)a1 + 6) = 0;
    v2 = *((_DWORD *)a1 + 4);
    if ((v2 & 0x80000000) == 0)
      *((_DWORD *)a1 + 4) = v2 + 1;
    return v1;
  }
  v3 = *((int *)a1 + 3);
  v4 = *((_DWORD *)a1 + 5);
  if ((int)v3 >= v4)
    return 0xFFFFFFFFLL;
  v5 = *a1;
  v6 = v3 + 1;
  *((_DWORD *)a1 + 3) = v3 + 1;
  v7 = *(char *)(v5 + v3);
  v1 = *(unsigned __int8 *)(v5 + v3);
  if (v7 < 0)
  {
    if ((_DWORD)v6 == v4)
    {
LABEL_7:
      v1 = 65533;
      LODWORD(v6) = v4;
      goto LABEL_25;
    }
    if (v1 < 0xE0)
    {
      if (v1 < 0xC2)
        goto LABEL_24;
      v10 = v1 & 0x1F;
    }
    else
    {
      if (v1 > 0xEF)
      {
        if (v1 > 0xF4)
          goto LABEL_24;
        v12 = v1 - 240;
        v8 = *(unsigned __int8 *)(v5 + v6);
        if (((byte_18BE14E40[v8 >> 4] >> v12) & 1) == 0)
          goto LABEL_24;
        v6 = v3 + 2;
        *((_DWORD *)a1 + 3) = v3 + 2;
        if ((_DWORD)v3 + 2 == v4)
          goto LABEL_7;
        v9 = *(unsigned __int8 *)(v5 + v6) ^ 0x80;
        if (v9 > 0x3F)
        {
          v1 = 65533;
          goto LABEL_25;
        }
        LODWORD(v8) = v8 & 0x3F | (v12 << 6);
      }
      else
      {
        v8 = v7 & 0xF;
        if (((a00000000000000[v8] >> (*(_BYTE *)(v5 + v6) >> 5)) & 1) == 0)
          goto LABEL_24;
        v9 = *(_BYTE *)(v5 + v6) & 0x3F;
      }
      LODWORD(v6) = v6 + 1;
      *((_DWORD *)a1 + 3) = v6;
      if ((_DWORD)v6 == v4)
        goto LABEL_7;
      v10 = v9 | ((_DWORD)v8 << 6);
    }
    v11 = *(unsigned __int8 *)(v5 + (int)v6) ^ 0x80;
    if (v11 <= 0x3F)
    {
      v1 = v11 | (v10 << 6);
      LODWORD(v6) = v6 + 1;
      *((_DWORD *)a1 + 3) = v6;
      goto LABEL_25;
    }
LABEL_24:
    v1 = 65533;
  }
LABEL_25:
  v13 = *((_DWORD *)a1 + 4);
  if (v13 < 0)
  {
    if ((_DWORD)v6 == v4)
    {
      v15 = *((_DWORD *)a1 + 2);
      if ((v15 & 0x80000000) == 0)
        *((_DWORD *)a1 + 4) = v15 - ((int)v1 >= 0x10000);
    }
  }
  else
  {
    *((_DWORD *)a1 + 4) = v13 + 1;
    if ((a1[1] & 0x80000000) != 0 && (_DWORD)v6 == v4)
    {
      v14 = v13 + 2;
      if ((int)v1 < 0x10000)
        v14 = v13 + 1;
      *((_DWORD *)a1 + 2) = v14;
    }
  }
  if ((int)v1 >= 0x10000)
  {
    *((_DWORD *)a1 + 6) = v1;
    return (unsigned __int16)((v1 >> 10) - 10304);
  }
  return v1;
}

uint64_t sub_18BC3A518(int32_t *pi)
{
  unsigned int v2;
  int v3;
  int v4;
  uint64_t CharSafeBody;
  int32_t v7;
  int32_t *v8;
  BOOL v9;
  int v10;
  const uint8_t *v11;
  int v12;
  int32_t v13;
  int v14;

  v2 = pi[6];
  if (v2)
  {
    v3 = (v2 >> 10) + 55232;
    pi[6] = 0;
    v4 = pi[4];
    pi[3] -= 4;
    if (v4 >= 1)
      pi[4] = v4 - 1;
    return (unsigned __int16)v3;
  }
  v8 = pi + 3;
  v7 = pi[3];
  v9 = __OFSUB__(v7, 1);
  v10 = v7 - 1;
  if (v10 < 0 != v9)
    return 0xFFFFFFFFLL;
  v11 = *(const uint8_t **)pi;
  pi[3] = v10;
  v12 = (char)v11[v10];
  CharSafeBody = v12;
  if (v12 < 0)
    CharSafeBody = utf8_prevCharSafeBody(v11, 0, pi + 3, v12, -3);
  v13 = pi[4];
  v9 = __OFSUB__(v13, 1);
  v14 = v13 - 1;
  if (v14 < 0 != v9)
  {
    v14 = *v8;
    if (*v8 > 1)
      goto LABEL_15;
    if ((int)CharSafeBody >= 0x10000)
      ++v14;
  }
  pi[4] = v14;
LABEL_15:
  if ((int)CharSafeBody >= 0x10000)
  {
    pi[3] += 4;
    pi[6] = CharSafeBody;
    return CharSafeBody & 0x3FF | 0xDC00;
  }
  return CharSafeBody;
}

uint64_t sub_18BC3A5F4(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 24) != 0) | (2 * *(_DWORD *)(a1 + 12));
}

uint64_t sub_18BC3A60C(uint64_t result, unsigned int a2, int *a3)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int32_t pi;

  if (a3 && *a3 <= 0)
  {
    v4 = result;
    if (result)
    {
      if (((*(_DWORD *)(result + 24) != 0) | (2 * *(_DWORD *)(result + 12))) == a2)
        return result;
      if ((a2 & 0xFFFFFFF9) != 1)
      {
        v5 = a2 >> 1;
        if (*(_DWORD *)(result + 20) >= (int)v5)
        {
          if (a2 >= 4)
            v6 = -1;
          else
            v6 = a2 >> 1;
          *(_DWORD *)(result + 12) = v5;
          *(_DWORD *)(result + 16) = v6;
          if ((a2 & 1) == 0)
          {
            *(_DWORD *)(result + 24) = 0;
            return result;
          }
          result = *(_QWORD *)result;
          v8 = v5 - 1;
          pi = v8;
          v9 = *(char *)(result + v8);
          if (v9 < 0)
          {
            result = utf8_prevCharSafeBody((const uint8_t *)result, 0, &pi, v9, -3);
            if ((int)result >= 0x10000)
            {
              *(_DWORD *)(v4 + 24) = result;
              return result;
            }
          }
        }
      }
      v7 = 8;
    }
    else
    {
      v7 = 1;
    }
    *a3 = v7;
  }
  return result;
}

_QWORD *ulist_createEmptyList(int *a1)
{
  _QWORD *result;

  if (*a1 > 0)
    return 0;
  result = uprv_malloc(0x20uLL);
  if (result)
  {
    *result = 0;
    result[1] = 0;
    *((_DWORD *)result + 6) = 0;
    result[2] = 0;
  }
  else
  {
    *a1 = 7;
  }
  return result;
}

void ulist_addItemEndList(uint64_t a1, void *a2, int a3, int *a4)
{
  _BYTE *v8;
  int v9;
  uint64_t v10;

  if (a2 && a1 && *a4 < 1)
  {
    v8 = uprv_malloc(0x20uLL);
    if (v8)
    {
      *(_QWORD *)v8 = a2;
      v8[24] = a3;
      v9 = *(_DWORD *)(a1 + 24);
      if (v9)
      {
        v10 = *(_QWORD *)(a1 + 16);
        *((_QWORD *)v8 + 1) = 0;
        *((_QWORD *)v8 + 2) = v10;
        *(_QWORD *)(v10 + 8) = v8;
      }
      else
      {
        *((_QWORD *)v8 + 1) = 0;
        *((_QWORD *)v8 + 2) = 0;
        *(_QWORD *)(a1 + 8) = v8;
      }
      *(_QWORD *)(a1 + 16) = v8;
      *(_DWORD *)(a1 + 24) = v9 + 1;
    }
    else
    {
      if (a3)
        uprv_free(a2);
      *a4 = 7;
    }
  }
  else if (a3)
  {
    uprv_free(a2);
  }
}

void ulist_addItemBeginList(uint64_t a1, void *a2, int a3, int *a4)
{
  _BYTE *v8;
  int v9;
  _QWORD *v10;
  uint64_t v11;

  if (a2 && a1 && *a4 < 1)
  {
    v8 = uprv_malloc(0x20uLL);
    if (v8)
    {
      *(_QWORD *)v8 = a2;
      v8[24] = a3;
      v9 = *(_DWORD *)(a1 + 24);
      if (v9)
      {
        v10 = (_QWORD *)(a1 + 8);
        v11 = *(_QWORD *)(a1 + 8);
        *((_QWORD *)v8 + 1) = v11;
        *((_QWORD *)v8 + 2) = 0;
        *(_QWORD *)(v11 + 16) = v8;
      }
      else
      {
        *((_QWORD *)v8 + 1) = 0;
        *((_QWORD *)v8 + 2) = 0;
        v10 = (_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 8) = v8;
      }
      *v10 = v8;
      *(_DWORD *)(a1 + 24) = v9 + 1;
    }
    else
    {
      if (a3)
        uprv_free(a2);
      *a4 = 7;
    }
  }
  else if (a3)
  {
    uprv_free(a2);
  }
}

uint64_t ulist_containsString(uint64_t result, const void *a2, int a3)
{
  uint64_t v3;
  size_t v6;

  if (result)
  {
    v3 = *(_QWORD *)(result + 8);
    if (v3)
    {
      v6 = a3;
      while (strlen(*(const char **)v3) != a3 || memcmp(a2, *(const void **)v3, v6))
      {
        v3 = *(_QWORD *)(v3 + 8);
        if (!v3)
          return 0;
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ulist_removeString(uint64_t result, char *__s1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (result)
  {
    v2 = result;
    v3 = *(_QWORD *)(result + 8);
    if (v3)
    {
      while (strcmp(__s1, *(const char **)v3))
      {
        v3 = *(_QWORD *)(v3 + 8);
        if (!v3)
          return 0;
      }
      v5 = *(_QWORD *)(v3 + 8);
      v6 = *(_QWORD *)(v3 + 16);
      if (v6)
      {
        *(_QWORD *)(v6 + 8) = v5;
        v5 = *(_QWORD *)(v3 + 8);
      }
      else
      {
        *(_QWORD *)(v2 + 8) = v5;
      }
      if (v5)
        v7 = v5;
      else
        v7 = v2;
      *(_QWORD *)(v7 + 16) = v6;
      if (*(_QWORD *)v2 == v3)
        *(_QWORD *)v2 = v5;
      --*(_DWORD *)(v2 + 24);
      if (*(_BYTE *)(v3 + 24))
        uprv_free(*(void **)v3);
      uprv_free((void *)v3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *ulist_getNext(uint64_t a1)
{
  _QWORD *v1;

  if (!a1)
    return 0;
  v1 = *(_QWORD **)a1;
  if (*(_QWORD *)a1)
  {
    v1 = (_QWORD *)*v1;
    *(_QWORD *)a1 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  }
  return v1;
}

uint64_t ulist_getListSize(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 24);
  else
    return 0xFFFFFFFFLL;
}

_QWORD *ulist_resetList(_QWORD *result)
{
  if (result)
    *result = result[1];
  return result;
}

void ulist_deleteList(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  if (a1)
  {
    v2 = a1[1];
    if (v2)
    {
      do
      {
        v3 = *(_QWORD *)(v2 + 8);
        if (*(_BYTE *)(v2 + 24))
          uprv_free(*(void **)v2);
        uprv_free((void *)v2);
        v2 = v3;
      }
      while (v3);
    }
    uprv_free(a1);
  }
}

void ulist_close_keyword_values_iterator(_QWORD **a1)
{
  if (a1)
  {
    ulist_deleteList(a1[1]);
    uprv_free(a1);
  }
}

uint64_t ulist_count_keyword_values(uint64_t a1, int *a2)
{
  uint64_t v3;

  if (*a2 <= 0 && (v3 = *(_QWORD *)(a1 + 8)) != 0)
    return *(unsigned int *)(v3 + 24);
  else
    return 0xFFFFFFFFLL;
}

const char *ulist_next_keyword_value(uint64_t a1, _DWORD *a2, int *a3)
{
  const char *v3;
  uint64_t *v5;
  uint64_t v6;

  if (*a3 > 0)
    return 0;
  v5 = *(uint64_t **)(a1 + 8);
  if (!v5)
    return 0;
  v6 = *v5;
  if (!*v5)
    return 0;
  v3 = *(const char **)v6;
  *v5 = *(_QWORD *)(v6 + 8);
  if (a2 && v3)
    *a2 = strlen(v3);
  return v3;
}

uint64_t ulist_reset_keyword_values_iterator(uint64_t result, int *a2)
{
  _QWORD *v2;

  if (*a2 <= 0)
  {
    v2 = *(_QWORD **)(result + 8);
    if (v2)
      *v2 = v2[1];
  }
  return result;
}

uint64_t ulist_getListFromEnum(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

char *locale_getKeywordsStart(char *a1)
{
  return strchr(a1, 64);
}

void sub_18BC3AB60(char *a1, int a2, uint64_t a3, int a4, int *a5)
{
  uint64_t v10;
  const char *v11;
  char *i;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  char *v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  char *v26;
  int v27;
  const char *v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  _BOOL4 v32;
  int v33;
  uint64_t v34;
  int v35;
  char *v36;
  unint64_t v37;
  char *v38;
  void (*v39)(uint64_t, const char *, uint64_t);
  int v40;
  const char *v41;
  int *v42;
  char __s1[48];
  _QWORD v44[146];

  v44[144] = *MEMORY[0x1E0C80C00];
  bzero(__s1, 0x4B0uLL);
  if (a2 != 64)
    return;
  v10 = 0;
  v11 = (const char *)v44;
  do
  {
    for (i = a1; *i == 32; ++i)
      ++a1;
    if (!*i)
      break;
    if ((_DWORD)v10 == 25)
      goto LABEL_52;
    v41 = v11;
    v13 = strchr(i, 61);
    v14 = strchr(i, 59);
    if (!v13 || (v15 = v14) != 0 && v14 < v13)
    {
LABEL_51:
      v40 = 3;
      goto LABEL_49;
    }
    v16 = v13 - a1;
    if (v13 - a1 > 24)
    {
LABEL_52:
      v40 = 5;
      goto LABEL_49;
    }
    if (v16 < 1)
      goto LABEL_51;
    v42 = a5;
    v17 = 0;
    v18 = 0;
    v19 = &__s1[48 * v10];
    do
    {
      v20 = i[v17];
      if (v20 != 32)
        v19[v18++] = uprv_asciitolower((char)v20);
      ++v17;
    }
    while (v16 > v17);
    if (!v18)
      goto LABEL_48;
    v21 = 0;
    v19[v18] = 0;
    *(_DWORD *)&__s1[48 * v10 + 28] = v18;
    v22 = (_DWORD)v15 - (_DWORD)v13;
    do
    {
      v23 = v22;
      v25 = *++v13;
      v24 = v25;
      --v21;
      --v22;
    }
    while (v25 == 32);
    if (!v24 || v13 == v15)
    {
LABEL_48:
      v40 = 3;
      a5 = v42;
LABEL_49:
      *a5 = v40;
      return;
    }
    *(_QWORD *)&__s1[48 * v10 + 32] = v13;
    if (v15)
    {
      v26 = v15 - 1;
      do
      {
        v27 = *v26--;
        --v23;
      }
      while (v27 == 32);
      *(_DWORD *)&__s1[48 * v10 + 40] = v23;
      a1 = v15 + 1;
      v11 = v41;
      if ((_DWORD)v10)
        goto LABEL_26;
    }
    else
    {
      v33 = strlen(v13);
      v34 = v33;
      v35 = v33 + 1;
      v11 = v41;
      while (v34)
      {
        v36 = &v13[v34--];
        --v35;
        if (*(v36 - 1) != 32)
          goto LABEL_37;
      }
      v35 = 0;
LABEL_37:
      a1 = 0;
      *(_DWORD *)&__s1[48 * v10 + 40] = v35;
      if ((_DWORD)v10)
      {
LABEL_26:
        if (!strcmp(__s1, &__s1[48 * v10]))
        {
          v32 = 0;
        }
        else
        {
          v28 = v11;
          v29 = 1;
          do
          {
            v30 = v29;
            if (v10 == v29)
              break;
            v31 = strcmp(v28, &__s1[48 * v10]);
            v29 = v30 + 1;
            v28 += 48;
          }
          while (v31);
          v32 = v30 >= v10;
        }
        goto LABEL_39;
      }
    }
    v32 = 1;
LABEL_39:
    v10 = (v10 + v32);
    a5 = v42;
  }
  while (a1);
  uprv_sortArray((uint64_t)__s1, v10, 48, (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_18BC3AED0, 0, 0, a5);
  if ((int)v10 >= 1)
  {
    v37 = 0;
    v38 = __s1;
    do
    {
      (*(void (**)(uint64_t, char *, _QWORD))(*(_QWORD *)a3 + 16))(a3, v38, *((unsigned int *)v38 + 7));
      v39 = *(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16);
      if (a4)
      {
        v39(a3, "=", 1);
        (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a3 + 16))(a3, *((_QWORD *)v38 + 4), *((unsigned int *)v38 + 10));
        if (v37 < (v10 - 1))
          (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, ";", 1);
      }
      else
      {
        v39(a3, byte_18BE14E51, 1);
      }
      ++v37;
      v38 += 48;
    }
    while (v10 != v37);
  }
}

uint64_t sub_18BC3AED0(int a1, char *__s1, char *__s2)
{
  return strcmp(__s1, __s2);
}

uint64_t uloc_getKeywordValue(char *a1, char *a2, char *a3, int a4, int *a5)
{
  uint64_t v5;
  __int128 v12;
  __int128 v13;

  if (*a5 > 0)
    return 0;
  v12 = 0u;
  v13 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v12, a3, a4);
  ulocimp_getKeywordValue(a1, a2, (uint64_t)&v12, a5);
  v5 = DWORD2(v13);
  if (*a5 <= 0)
  {
    if (BYTE12(v13))
      *a5 = 15;
    else
      u_terminateChars((uint64_t)a3, a4, DWORD2(v13), a5);
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v12);
  return v5;
}

void ulocimp_getKeywordValue(char *a1, char *a2, uint64_t a3, int *a4)
{
  char *v4;
  BOOL v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  int v12;
  char *v13;
  int v14;
  uint64_t v15;
  char *v16;
  char v17;
  int v18;
  char *v19;
  int v20;
  int v21;
  char *v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  int v27;
  void *v28[7];
  uint64_t v29;
  char __s2[8];
  uint64_t v31;
  uint64_t v32;
  char v33;
  char __s1[8];
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v4 = a1;
    if (a1)
    {
      if (*a4 <= 0)
      {
        memset(&v28[1], 0, 48);
        v29 = 0;
        v28[0] = (char *)&v28[1] + 5;
        LODWORD(v28[1]) = 40;
        if (a2 && *a2)
        {
          *(_QWORD *)__s1 = 0;
          v35 = 0;
          v37 = 0;
          v36 = 0;
          sub_18BC3B290((uint64_t)__s1, a2, a4);
          if (*a4 <= 0)
          {
            if (!strchr(v4, 64) && sub_18BC3B33C(v4) == 1)
            {
              *(_QWORD *)__s2 = 0;
              v31 = 0;
              icu::CharStringByteSink::CharStringByteSink(__s2, (uint64_t)v28);
              ulocimp_forLanguageTag(v4, -1, (uint64_t)__s2, 0, a4);
              if ((_DWORD)v29)
                v7 = *a4 <= 0;
              else
                v7 = 0;
              if (v7)
                v4 = (char *)v28[0];
              icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)__s2);
            }
            v8 = strchr(v4, 64);
            if (v8)
            {
              v9 = v8;
              *(_QWORD *)__s2 = 0;
              v31 = 0;
              v33 = 0;
              v32 = 0;
              while (v9)
              {
                v10 = strchr(v9 + 1, 61);
                if (!v10)
                  goto LABEL_50;
                v11 = v10;
                do
                  v12 = *++v9;
                while (v12 == 32);
                v13 = v10;
                while (v13 > v9)
                {
                  v14 = *--v13;
                  if (v14 != 32)
                  {
                    v15 = 0;
                    v16 = v13 + 1;
                    while (uprv_isASCIILetter(v9[v15]) || v9[v15] - 48 <= 9)
                    {
                      if (v15 == 24)
                      {
                        v27 = 5;
                        goto LABEL_51;
                      }
                      v17 = uprv_asciitolower(v9[v15]);
                      v18 = v15 + 1;
                      __s2[v15] = v17;
                      v19 = &v9[++v15];
                      if (v19 >= v16)
                        goto LABEL_33;
                    }
                    goto LABEL_50;
                  }
                }
                if (v13 == v9)
                  goto LABEL_50;
                v18 = 0;
LABEL_33:
                __s2[v18] = 0;
                v9 = strchr(v11, 59);
                if (!strcmp(__s1, __s2))
                {
                  do
                    v20 = *++v11;
                  while (v20 == 32);
                  if (!v9)
                    v9 = &v11[strlen(v11)];
                  while (v9 > v11)
                  {
                    v21 = *--v9;
                    if (v21 != 32)
                    {
                      v22 = v9 + 1;
                      while (1)
                      {
                        if (!uprv_isASCIILetter(*v11))
                        {
                          v23 = *v11;
                          if ((v23 - 48) >= 0xA)
                          {
                            v24 = v23 - 43;
                            v7 = v24 > 0x34;
                            v25 = (1 << v24) & 0x10000000000015;
                            if (v7 || v25 == 0)
                              goto LABEL_50;
                          }
                        }
                        (*(void (**)(uint64_t, char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, v11++, 1);
                        if (v11 >= v22)
                          goto LABEL_52;
                      }
                    }
                  }
                  if (v11 != v9)
                    break;
                  goto LABEL_50;
                }
              }
            }
          }
        }
        else
        {
LABEL_50:
          v27 = 1;
LABEL_51:
          *a4 = v27;
        }
LABEL_52:
        if (BYTE4(v28[1]))
          uprv_free(v28[0]);
      }
    }
  }
}

uint64_t sub_18BC3B290(uint64_t a1, char *a2, int *a3)
{
  char v4;
  uint64_t v7;
  char v8;
  uint64_t result;
  int v10;

  v4 = *a2;
  if (*a2)
  {
    v7 = 0;
    while (uprv_isASCIILetter(v4) || a2[v7] - 48 < 0xA)
    {
      if (v7 == 24)
      {
        result = 0;
        v10 = 5;
        goto LABEL_11;
      }
      v8 = uprv_asciitolower(a2[v7]);
      result = v7 + 1;
      *(_BYTE *)(a1 + v7) = v8;
      v4 = a2[++v7];
      if (!v4)
      {
        if (!(_DWORD)result)
          break;
        *(_BYTE *)(a1 + result) = 0;
        return result;
      }
    }
  }
  result = 0;
  v10 = 1;
LABEL_11:
  *a3 = v10;
  return result;
}

size_t sub_18BC3B33C(const char *a1)
{
  const char *v1;
  size_t result;
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  BOOL v8;

  v1 = a1;
  result = strlen(a1);
  if ((int)result >= 1)
  {
    v3 = 0;
    v4 = result;
    v5 = 1;
    do
    {
      v7 = *(unsigned __int8 *)v1++;
      v6 = v7;
      if (v7 == 45 || v6 == 95)
      {
        v8 = v3 >= (int)result || v3 == 0;
        if (v8)
          result = result;
        else
          result = v3;
        v5 = 1;
      }
      else
      {
        v8 = v5 == 0;
        v5 = 0;
        if (v8)
          ++v3;
        else
          v3 = 1;
      }
      --v4;
    }
    while (v4);
  }
  return result;
}

size_t uloc_setKeywordValue(char *a1, _BYTE *a2, char *__s, int a4, int *a5)
{
  size_t v5;
  int v11;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  BOOL v19;
  uint64_t v20;
  int v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  int v27;
  char *v28;
  int v29;
  uint64_t v30;
  char *v31;
  int v32;
  char *v33;
  char *v34;
  int v35;
  int v36;
  int v37;
  char *v38;
  int v39;
  char *v40;
  int v41;
  int v42;
  char v43;
  int v44;
  size_t v45;
  char *v46;
  int v47;
  int v48;
  char *__dst;
  int v50;
  int v51;
  int v52;
  char v53;
  void *v54[7];
  uint64_t v55;
  char __s2[8];
  uint64_t v57;
  uint64_t v58;
  char v59;
  char __src[16];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  char v66;
  char __s1[8];
  uint64_t v68;
  uint64_t v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)__s1 = 0;
  v68 = 0;
  v70 = 0;
  v69 = 0;
  v66 = 0;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  *(_OWORD *)__src = 0u;
  v61 = 0u;
  *(_QWORD *)__s2 = 0;
  v57 = 0;
  v59 = 0;
  v58 = 0;
  memset(&v54[1], 0, 48);
  v55 = 0;
  v54[0] = (char *)&v54[1] + 5;
  LODWORD(v54[1]) = 40;
  if (*a5 > 0)
  {
    v5 = 0xFFFFFFFFLL;
    goto LABEL_11;
  }
  if (*a5 == -124)
    *a5 = 0;
  if (!a1)
    goto LABEL_9;
  if (a4 < 2)
    goto LABEL_9;
  if (!*a1)
    goto LABEL_9;
  v5 = strlen(__s);
  if ((int)v5 > a4)
    goto LABEL_9;
  v13 = sub_18BC3B290((uint64_t)__s1, a1, a5);
  if (*a5 > 0)
  {
    v5 = 0;
    goto LABEL_11;
  }
  v14 = v13;
  if (!a2 || (LOBYTE(v15) = *a2) == 0)
  {
    v22 = 0;
    goto LABEL_29;
  }
  v50 = v13;
  v16 = 0;
  do
  {
    if (!uprv_isASCIILetter(v15))
    {
      v17 = a2[v16];
      if ((v17 - 48) >= 0xA)
      {
        v18 = v17 - 43;
        v19 = v18 > 0x34;
        v20 = (1 << v18) & 0x10000000000015;
        if (v19 || v20 == 0)
          goto LABEL_9;
      }
    }
    if (v16 == 96)
    {
LABEL_77:
      v5 = 0;
      v11 = 5;
      goto LABEL_10;
    }
    v22 = v16 + 1;
    __src[v16] = a2[v16];
    v15 = a2[++v16];
  }
  while (v15);
  v14 = v50;
LABEL_29:
  __src[v22] = 0;
  v23 = strchr(__s, 64);
  if (!v23 || !v23[1])
  {
    if (v22)
    {
      v44 = v5 + v14 + v22;
      if (!v23)
        ++v44;
      v45 = (v44 + 1);
      if ((int)v45 >= a4)
      {
        *a5 = 15;
      }
      else
      {
        if (!v23)
          v23 = &__s[(int)v5];
        *v23 = 64;
        v46 = &strcpy(v23 + 1, __s1)[v14];
        *v46 = 61;
        strcpy(v46 + 1, __src);
      }
      v5 = v45;
    }
    goto LABEL_11;
  }
  v52 = 0;
  v53 = 64;
  __dst = v23;
  v24 = v23;
  v51 = v14;
  while (2)
  {
    v25 = strchr(v24 + 1, 61);
    v26 = v25;
    if (!v25)
      goto LABEL_9;
    do
      v27 = *++v24;
    while (v27 == 32);
    v28 = v25;
    while (v28 > v24)
    {
      v29 = *--v28;
      if (v29 != 32)
      {
        v30 = 0;
        v31 = v28 + 1;
        while (uprv_isASCIILetter(v24[v30]) || v24[v30] - 48 < 0xA)
        {
          if (v30 == 24)
            goto LABEL_77;
          v32 = v30 + 1;
          __s2[v30] = uprv_asciitolower(v24[v30]);
          v33 = &v24[++v30];
          if (v33 >= v31)
          {
            v14 = v51;
            goto LABEL_45;
          }
        }
        goto LABEL_9;
      }
    }
    if (v28 == v24)
      goto LABEL_9;
    v32 = 0;
LABEL_45:
    __s2[v32] = 0;
    v34 = strchr(v26, 59);
    v24 = v34;
    v35 = ~(_DWORD)v26;
    do
    {
      v36 = v35;
      v37 = *++v26;
      --v35;
    }
    while (v37 == 32);
    v38 = v34;
    if (!v34)
      v38 = &v26[strlen(v26)];
    v39 = (_DWORD)v38 + v36;
    do
    {
      v40 = v38;
      v41 = v39;
      if (v38 <= v26)
        break;
      --v38;
      --v39;
    }
    while (*(v40 - 1) == 32);
    if (v40 == v26)
    {
LABEL_9:
      v5 = 0;
      v11 = 1;
LABEL_10:
      *a5 = v11;
      goto LABEL_11;
    }
    v42 = strcmp(__s1, __s2);
    if (v42)
    {
      if (v22 && v42 < 0 && !v52)
      {
        icu::CharString::append((icu::CharString *)v54, v53, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, __s1, v14, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, 61, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, __src, v22, (UErrorCode *)a5);
        v43 = 59;
        v52 = 1;
      }
      else
      {
        v43 = v53;
      }
      icu::CharString::append((icu::CharString *)v54, v43, (UErrorCode *)a5);
      icu::CharString::append((icu::CharString *)v54, __s2, v32, (UErrorCode *)a5);
      icu::CharString::append((icu::CharString *)v54, 61, (UErrorCode *)a5);
      icu::CharString::append((icu::CharString *)v54, v26, v41, (UErrorCode *)a5);
      if (v22)
      {
        v53 = 59;
        if (!v24 && !v52)
        {
          icu::CharString::append((icu::CharString *)v54, 59, (UErrorCode *)a5);
          icu::CharString::append((icu::CharString *)v54, __s1, v14, (UErrorCode *)a5);
          icu::CharString::append((icu::CharString *)v54, 61, (UErrorCode *)a5);
          icu::CharString::append((icu::CharString *)v54, __src, v22, (UErrorCode *)a5);
LABEL_80:
          if (*a5 <= 0)
          {
            v47 = v55;
            v48 = a4 - ((_DWORD)__dst - (_DWORD)__s);
            if ((int)v55 >= v48)
              *a5 = 15;
            else
              v47 = icu::CharString::extract((char **)v54, __dst, v48, (UErrorCode *)a5);
            v5 = (v47 + (_DWORD)__dst - (_DWORD)__s);
          }
          goto LABEL_11;
        }
      }
      else
      {
        v53 = 59;
      }
    }
    else
    {
      if (v22)
      {
        icu::CharString::append((icu::CharString *)v54, v53, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, __s1, v14, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, 61, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, __src, v22, (UErrorCode *)a5);
        v53 = 59;
      }
      v52 = 1;
    }
    if (v24)
      continue;
    break;
  }
  if (v52)
    goto LABEL_80;
LABEL_11:
  if (BYTE4(v54[1]))
    uprv_free(v54[0]);
  return v5;
}

char *sub_18BC3B934(char *__s1)
{
  char *v1;
  int v2;

  v1 = __s1;
  v2 = sub_18BC3B978((const char **)off_1E2252880, __s1);
  if ((v2 & 0x80000000) == 0)
    return off_1E2252910[(unsigned __int16)v2];
  return v1;
}

uint64_t sub_18BC3B978(const char **a1, char *__s1)
{
  const char **v3;
  uint64_t v4;
  int v5;
  const char *v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;

  v3 = a1;
  v4 = -(uint64_t)a1;
  v5 = 1;
  while (1)
  {
    v6 = *v3;
    if (*v3)
      break;
LABEL_6:
    ++v3;
    if (++v5 == 3)
    {
      LOWORD(v9) = -1;
      return (__int16)v9;
    }
  }
  v7 = (unint64_t)v3 + v4;
  while (strcmp(__s1, v6))
  {
    v8 = v3[1];
    ++v3;
    v6 = v8;
    v7 += 8;
    if (!v8)
      goto LABEL_6;
  }
  v9 = v7 >> 3;
  return (__int16)v9;
}

char *sub_18BC3B9F4(char *__s1)
{
  char *v1;
  int v2;

  v1 = __s1;
  v2 = sub_18BC3B978((const char **)off_1E22529A0, __s1);
  if ((v2 & 0x80000000) == 0)
    return off_1E22529D8[(unsigned __int16)v2];
  return v1;
}

uint64_t sub_18BC3BA38@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned __int8 *v6;
  int v8;
  int v10;
  char v11;
  int v12;
  BOOL v13;
  char v15;
  _BYTE *v16;
  char *v17;
  int v18;

  v6 = (unsigned __int8 *)result;
  *(_OWORD *)(a4 + 8) = 0u;
  *(_QWORD *)(a4 + 56) = 0;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(_QWORD *)a4 = a4 + 13;
  *(_DWORD *)(a4 + 8) = 40;
  *(_DWORD *)(a4 + 56) = 0;
  v8 = *(unsigned __int8 *)result;
  if ((v8 - 73) <= 0x2F && ((1 << (v8 - 73)) & 0x800100008001) != 0)
  {
    v10 = *(unsigned __int8 *)(result + 1);
    if (v10 == 95 || v10 == 45)
    {
      v11 = uprv_asciitolower((char)v8);
      icu::CharString::append((icu::CharString *)a4, v11, a3);
      result = (uint64_t)icu::CharString::append((icu::CharString *)a4, 45, a3);
      v6 += 2;
    }
  }
  while (1)
  {
    v12 = *v6;
    v13 = (v12 - 45) > 0x32 || ((1 << (v12 - 45)) & 0x4000000080003) == 0;
    if (!v13 || v12 == 0)
      break;
    v15 = uprv_asciitolower((char)v12);
    result = (uint64_t)icu::CharString::append((icu::CharString *)a4, v15, a3);
    ++v6;
  }
  if (*(_DWORD *)(a4 + 56) == 3)
  {
    v16 = *(_BYTE **)a4;
    result = sub_18BC3B978((const char **)off_1E2252A10, *(char **)a4);
    if ((result & 0x80000000) == 0)
    {
      *(_DWORD *)(a4 + 56) = 0;
      *v16 = 0;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v17, off_1E2253D98[(unsigned __int16)result]);
      result = (uint64_t)icu::CharString::append((icu::CharString *)a4, v17, v18, a3);
    }
  }
  if (a2)
    *a2 = v6;
  return result;
}

icu::CharString *sub_18BC3BBB8@<X0>(icu::CharString *result@<X0>, _QWORD *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  char *v6;
  uint64_t i;
  int v9;
  BOOL v10;
  char v12;
  uint64_t v13;
  char v14;

  v6 = (char *)result;
  *(_OWORD *)(a4 + 8) = 0u;
  *(_QWORD *)(a4 + 56) = 0;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(_QWORD *)a4 = a4 + 13;
  *(_DWORD *)(a4 + 8) = 40;
  *(_DWORD *)(a4 + 56) = 0;
  if (a2)
    *a2 = result;
  for (i = 0; ; ++i)
  {
    v9 = v6[i];
    v10 = (v9 - 45) > 0x32 || ((1 << (v9 - 45)) & 0x4000000080003) == 0;
    if (!v10 || v9 == 0)
      break;
    result = (icu::CharString *)uprv_isASCIILetter(v9);
    if (!(_DWORD)result)
      break;
  }
  if ((_DWORD)i == 4)
  {
    if (a2)
      *a2 = &v6[i];
    v12 = uprv_toupper(*v6);
    icu::CharString::append((icu::CharString *)a4, v12, a3);
    v13 = 1;
    do
    {
      v14 = uprv_asciitolower(v6[v13]);
      result = icu::CharString::append((icu::CharString *)a4, v14, a3);
      ++v13;
    }
    while ((_DWORD)v13 != 4);
  }
  return result;
}

uint64_t sub_18BC3BCC4@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  uint64_t v8;
  int v9;
  BOOL v10;
  char v12;
  _BYTE *v13;
  char *v14;
  int v15;

  v6 = result;
  v8 = 0;
  *(_OWORD *)(a4 + 8) = 0u;
  *(_QWORD *)(a4 + 56) = 0;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(_QWORD *)a4 = a4 + 13;
  *(_DWORD *)(a4 + 8) = 40;
  *(_DWORD *)(a4 + 56) = 0;
  while (1)
  {
    v9 = *(unsigned __int8 *)(v6 + v8);
    v10 = (v9 - 45) > 0x32 || ((1 << (v9 - 45)) & 0x4000000080003) == 0;
    if (!v10 || v9 == 0)
      break;
    v12 = uprv_toupper((char)v9);
    result = (uint64_t)icu::CharString::append((icu::CharString *)a4, v12, a3);
    ++v8;
  }
  if ((v8 & 0x7FFFFFFE) == 2)
  {
    v6 += v8;
    if ((_DWORD)v8 == 3)
    {
      v13 = *(_BYTE **)a4;
      result = sub_18BC3B978((const char **)off_1E2255120, *(char **)a4);
      if ((result & 0x80000000) == 0)
      {
        *(_DWORD *)(a4 + 56) = 0;
        *v13 = 0;
        icu::StringPiece::StringPiece((icu::StringPiece *)&v14, off_1E2255988[(unsigned __int16)result]);
        result = (uint64_t)icu::CharString::append((icu::CharString *)a4, v14, v15, a3);
      }
    }
  }
  else
  {
    *(_DWORD *)(a4 + 56) = 0;
    **(_BYTE **)a4 = 0;
  }
  if (a2)
    *a2 = v6;
  return result;
}

_OWORD *uloc_openKeywordList(const void *a1, int a2, int *a3)
{
  _QWORD *v3;
  void *v4;
  _OWORD *v8;
  _BYTE *v9;
  _BYTE *v10;

  if (*a3 > 0)
  {
    v3 = 0;
    v4 = 0;
LABEL_8:
    v8 = 0;
    goto LABEL_9;
  }
  v3 = uprv_malloc(0x10uLL);
  uprv_free(0);
  v8 = uprv_malloc(0x38uLL);
  uprv_free(0);
  if (!v3
    || !v8
    || (*v8 = xmmword_1E22561F0,
        v8[1] = *(_OWORD *)&off_1E2256200,
        v8[2] = xmmword_1E2256210,
        *((_QWORD *)v8 + 6) = sub_18BC3DAA0,
        v9 = uprv_malloc(a2 + 1),
        (*v3 = v9) == 0))
  {
    *a3 = 7;
    v4 = v8;
    goto LABEL_8;
  }
  v10 = v9;
  memcpy(v9, a1, a2);
  v4 = 0;
  v10[a2] = 0;
  v3[1] = v10;
  *((_QWORD *)v8 + 1) = v3;
  v3 = 0;
LABEL_9:
  uprv_free(v4);
  uprv_free(v3);
  return v8;
}

_OWORD *uloc_openKeywords(char *__s, int *a2)
{
  char *Default_0;
  BOOL v4;
  _OWORD *v5;
  char *v7;
  int v8;
  int v9;
  _QWORD v10[2];
  char *__sa;
  void *v12[7];
  uint64_t v13;
  void *v14;
  char v15;
  void *v16;
  char v17;
  void *v18;
  char v19;
  void *v20[7];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  memset(&v20[1], 0, 48);
  v21 = 0;
  v20[0] = (char *)&v20[1] + 5;
  LODWORD(v20[1]) = 40;
  if (!a2 || *a2 > 0)
    goto LABEL_18;
  Default_0 = __s;
  if (__s)
  {
    if (!strchr(__s, 64) && sub_18BC3B33C(Default_0) == 1)
    {
      v12[0] = 0;
      v12[1] = 0;
      icu::CharStringByteSink::CharStringByteSink(v12, (uint64_t)v20);
      ulocimp_forLanguageTag(Default_0, -1, (uint64_t)v12, 0, a2);
      if ((_DWORD)v21)
        v4 = *a2 <= 0;
      else
        v4 = 0;
      if (v4)
        Default_0 = (char *)v20[0];
      __sa = Default_0;
      icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v12);
      goto LABEL_15;
    }
  }
  else
  {
    Default_0 = (char *)uloc_getDefault_0();
  }
  __sa = Default_0;
LABEL_15:
  sub_18BC3BA38((uint64_t)Default_0, &__sa, (UErrorCode *)a2, (uint64_t)&v18);
  if (v19)
    uprv_free(v18);
  if (*a2 > 0)
    goto LABEL_18;
  v7 = __sa;
  v8 = *__sa;
  if (v8 == 95 || v8 == 45)
  {
    v12[0] = 0;
    sub_18BC3BBB8((icu::CharString *)(__sa + 1), v12, (UErrorCode *)a2, (uint64_t)&v16);
    if (v17)
      uprv_free(v16);
    if (*a2 > 0)
      goto LABEL_18;
    v7 = __sa;
    if (v12[0] != __sa + 1)
    {
      __sa = (char *)v12[0];
      v7 = (char *)v12[0];
    }
    v9 = *v7;
    if (v9 == 95 || v9 == 45)
    {
      sub_18BC3BCC4((uint64_t)(v7 + 1), (uint64_t *)&__sa, (UErrorCode *)a2, (uint64_t)&v14);
      if (v15)
        uprv_free(v14);
      if (*a2 > 0)
        goto LABEL_18;
      v7 = __sa;
    }
  }
  __sa = strchr(v7, 64);
  if (!__sa)
  {
LABEL_18:
    v5 = 0;
    goto LABEL_19;
  }
  memset(&v12[1], 0, 48);
  v13 = 0;
  v12[0] = (char *)&v12[1] + 5;
  LODWORD(v12[1]) = 40;
  v10[0] = 0;
  v10[1] = 0;
  icu::CharStringByteSink::CharStringByteSink(v10, (uint64_t)v12);
  sub_18BC3AB60(__sa + 1, 64, (uint64_t)v10, 0, a2);
  v5 = 0;
  if (*a2 <= 0)
    v5 = uloc_openKeywordList(v12[0], v13, a2);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v10);
  if (BYTE4(v12[1]))
    uprv_free(v12[0]);
LABEL_19:
  if (BYTE4(v20[1]))
    uprv_free(v20[0]);
  return v5;
}

uint64_t uloc_getParent(char *a1, char *a2, int a3, int *a4)
{
  uint64_t v4;
  __int128 v10;
  __int128 v11;

  if (*a4 > 0)
    return 0;
  v10 = 0u;
  v11 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v10, a2, a3);
  ulocimp_getParent(a1, (uint64_t)&v10, a4);
  v4 = DWORD2(v11);
  if (*a4 <= 0)
  {
    if (BYTE12(v11))
      *a4 = 15;
    else
      u_terminateChars((uint64_t)a2, a3, DWORD2(v11), a4);
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v10);
  return v4;
}

char *ulocimp_getParent(char *__s, uint64_t a2, int *a3)
{
  char *Default_0;
  int v5;

  if (*a3 <= 0)
  {
    Default_0 = __s;
    if (!__s)
      Default_0 = (char *)uloc_getDefault_0(0);
    __s = strrchr(Default_0, 95);
    if (__s)
      v5 = (_DWORD)__s - (_DWORD)Default_0;
    else
      v5 = 0;
    if (v5 >= 1)
      return (char *)(*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)a2 + 16))(a2, Default_0);
  }
  return __s;
}

UErrorCode *uloc_getLanguage(uint64_t Default_0, char *a2, int a3, int *a4)
{
  UErrorCode *v4;
  char *v8;
  char v9;
  uint64_t v10;

  v4 = (UErrorCode *)a4;
  v10 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    if (*a4 <= 0)
    {
      if (!Default_0)
        Default_0 = uloc_getDefault_0();
      sub_18BC3BA38(Default_0, 0, v4, (uint64_t)&v8);
      v4 = (UErrorCode *)icu::CharString::extract(&v8, a2, a3, v4);
      if (v9)
        uprv_free(v8);
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t uloc_getScript(uint64_t Default_0, char *a2, int a3, int *a4)
{
  UErrorCode *v4;
  int v8;
  unsigned __int8 *v9;
  char *v10;
  char v11;
  void *v12;
  char v13;
  uint64_t v14;

  v4 = (UErrorCode *)a4;
  v14 = *MEMORY[0x1E0C80C00];
  v9 = (unsigned __int8 *)Default_0;
  if (a4)
  {
    if (*a4 > 0)
      return 0;
    if (!Default_0)
    {
      Default_0 = uloc_getDefault_0();
      v9 = (unsigned __int8 *)Default_0;
    }
    sub_18BC3BA38(Default_0, &v9, v4, (uint64_t)&v12);
    if (v13)
      uprv_free(v12);
    if (*(int *)v4 <= 0)
    {
      v8 = *v9;
      if (v8 == 95 || v8 == 45)
      {
        sub_18BC3BBB8((icu::CharString *)(v9 + 1), 0, v4, (uint64_t)&v10);
        v4 = (UErrorCode *)icu::CharString::extract(&v10, a2, a3, v4);
        if (v11)
          uprv_free(v10);
      }
      else
      {
        return u_terminateChars((uint64_t)a2, a3, 0, (int *)v4);
      }
    }
    else
    {
      return 0;
    }
  }
  return (uint64_t)v4;
}

uint64_t uloc_getCountry(uint64_t Default_0, char *a2, int a3, int *a4)
{
  UErrorCode *v4;
  int v8;
  unsigned __int8 *v9;
  int v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  char *v13;
  char v14;
  void *v15;
  char v16;
  void *v17;
  char v18;
  uint64_t v19;

  v4 = (UErrorCode *)a4;
  v19 = *MEMORY[0x1E0C80C00];
  v12 = (unsigned __int8 *)Default_0;
  if (a4)
  {
    if (*a4 > 0)
      return 0;
    if (!Default_0)
    {
      Default_0 = uloc_getDefault_0();
      v12 = (unsigned __int8 *)Default_0;
    }
    sub_18BC3BA38(Default_0, &v12, v4, (uint64_t)&v17);
    if (v18)
      uprv_free(v17);
    if (*(int *)v4 > 0)
      return 0;
    v8 = *v12;
    if (v8 != 95 && v8 != 45)
      return u_terminateChars((uint64_t)a2, a3, 0, (int *)v4);
    v11 = 0;
    sub_18BC3BBB8((icu::CharString *)(v12 + 1), &v11, v4, (uint64_t)&v15);
    if (v16)
      uprv_free(v15);
    if (*(int *)v4 > 0)
      return 0;
    v9 = v12;
    if (v11 != v12 + 1)
    {
      v12 = v11;
      v9 = v11;
    }
    v10 = *v9;
    if (v10 != 95 && v10 != 45)
      return u_terminateChars((uint64_t)a2, a3, 0, (int *)v4);
    sub_18BC3BCC4((uint64_t)(v9 + 1), 0, v4, (uint64_t)&v13);
    v4 = (UErrorCode *)icu::CharString::extract(&v13, a2, a3, v4);
    if (v14)
      uprv_free(v13);
  }
  return (uint64_t)v4;
}

uint64_t uloc_getVariant(char *__s, char *a2, int a3, int *a4)
{
  char *Default_0;
  BOOL v8;
  char *v9;
  uint64_t v10;
  int v12;
  unsigned __int8 *v13;
  int v14;
  unsigned __int8 *v15;
  int v16;
  unsigned __int8 *v17;
  int v18;
  int v19;
  __int128 v20;
  __int128 v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  char *v24;
  void *v25;
  char v26;
  void *v27;
  char v28;
  void *v29;
  char v30;
  void *v31[7];
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  memset(&v31[1], 0, 48);
  v32 = 0;
  v31[0] = (char *)&v31[1] + 5;
  LODWORD(v31[1]) = 40;
  v24 = 0;
  if (!a4 || *a4 > 0)
    goto LABEL_17;
  Default_0 = __s;
  if (__s)
  {
    if (!strchr(__s, 64) && sub_18BC3B33C(Default_0) == 1)
    {
      v20 = 0uLL;
      icu::CharStringByteSink::CharStringByteSink(&v20, (uint64_t)v31);
      ulocimp_forLanguageTag(Default_0, -1, (uint64_t)&v20, 0, a4);
      if ((_DWORD)v32)
        v8 = *a4 <= 0;
      else
        v8 = 0;
      v9 = (char *)v31[0];
      if (!v8)
        v9 = Default_0;
      v24 = v9;
      icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&v20);
      Default_0 = v24;
      goto LABEL_14;
    }
  }
  else
  {
    Default_0 = (char *)uloc_getDefault_0();
  }
  v24 = Default_0;
LABEL_14:
  sub_18BC3BA38((uint64_t)Default_0, &v24, (UErrorCode *)a4, (uint64_t)&v29);
  if (v30)
    uprv_free(v29);
  if (*a4 > 0)
    goto LABEL_17;
  v12 = *v24;
  if (v12 != 95 && v12 != 45)
    goto LABEL_45;
  v23 = 0;
  sub_18BC3BBB8((icu::CharString *)(v24 + 1), &v23, (UErrorCode *)a4, (uint64_t)&v27);
  if (v28)
    uprv_free(v27);
  if (*a4 > 0)
    goto LABEL_17;
  v13 = (unsigned __int8 *)v24;
  if (v23 != (unsigned __int8 *)(v24 + 1))
  {
    v24 = (char *)v23;
    v13 = v23;
  }
  v14 = *v13;
  if (v14 != 95 && v14 != 45)
    goto LABEL_45;
  v22 = 0;
  sub_18BC3BCC4((uint64_t)(v13 + 1), (uint64_t *)&v22, (UErrorCode *)a4, (uint64_t)&v25);
  if (v26)
    uprv_free(v25);
  if (*a4 > 0)
  {
LABEL_17:
    v10 = 0;
    goto LABEL_18;
  }
  v15 = (unsigned __int8 *)v24;
  if (v22 != (unsigned __int8 *)(v24 + 1))
  {
    v24 = (char *)v22;
    v15 = v22;
  }
  v16 = *v15;
  if (v16 != 95 && v16 != 45)
  {
LABEL_45:
    v10 = 0;
    goto LABEL_46;
  }
  if (v15 != v22)
  {
    v19 = v15[1];
    v17 = v15 + 1;
    v18 = v19;
    if (v19 == 95 || v18 == 45)
      v24 = (char *)v17;
  }
  v20 = 0u;
  v21 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v20, a2, a3);
  sub_18BC3C938(v24 + 1, *v24, (uint64_t)&v20, 0);
  v10 = DWORD2(v21);
  if (*a4 > 0)
    goto LABEL_44;
  if (BYTE12(v21))
  {
    *a4 = 15;
LABEL_44:
    icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v20);
    goto LABEL_18;
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v20);
LABEL_46:
  v10 = u_terminateChars((uint64_t)a2, a3, v10, a4);
LABEL_18:
  if (BYTE4(v31[1]))
    uprv_free(v31[0]);
  return v10;
}

char *sub_18BC3C938(char *__s, int a2, uint64_t a3, unsigned __int8 a4)
{
  char *v6;
  int v7;
  char i;
  int v9;
  int v10;
  char v11;
  int v12;
  int v13;
  int v14;
  char v15;
  char v16;
  char v17;

  v6 = __s;
  v7 = a4;
  if (a2 != 95 && a2 != 45)
    goto LABEL_14;
  for (i = 1; ; i = 0)
  {
    v9 = *v6;
    if (!*v6 || v9 == 46 || v9 == 64)
      break;
    if (v7)
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, "_", 1);
      LOBYTE(v9) = *v6;
    }
    v17 = 0;
    v10 = uprv_toupper((char)v9);
    if (v10 == 45)
      v11 = 95;
    else
      v11 = v10;
    v17 = v11;
    __s = (char *)(*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, &v17, 1);
    v7 = 0;
    ++v6;
  }
  if ((i & 1) != 0)
  {
LABEL_14:
    if (a2 != 64)
    {
      __s = strchr(v6, 64);
      if (!__s)
        return __s;
      v6 = __s + 1;
    }
    while (1)
    {
      v12 = *v6;
      if (!*v6 || v12 == 46 || v12 == 64)
        break;
      if (v7)
        (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, "_", 1);
      v16 = 0;
      v13 = *v6++;
      v14 = uprv_toupper(v13);
      if ((v14 & 0xFFFFFFFE) == 0x2C)
        v15 = 95;
      else
        v15 = v14;
      v16 = v15;
      __s = (char *)(*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, &v16, 1);
      v7 = 0;
    }
  }
  return __s;
}

uint64_t uloc_getName(char *a1, char *a2, int a3, int *a4)
{
  uint64_t v4;
  __int128 v10;
  __int128 v11;

  if (*a4 > 0)
    return 0;
  v10 = 0u;
  v11 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v10, a2, a3);
  sub_18BC3CB6C(a1);
  v4 = DWORD2(v11);
  if (*a4 <= 0)
  {
    if (BYTE12(v11))
      *a4 = 15;
    else
      u_terminateChars((uint64_t)a2, a3, DWORD2(v11), a4);
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v10);
  return v4;
}

uint64_t ulocimp_getName(char *a1)
{
  return sub_18BC3CB6C(a1);
}

void sub_18BC3CB6C(char *__s, uint64_t a2, char a3, UErrorCode *a4)
{
  char *Default_0;
  int v8;
  _BYTE *i;
  icu::Locale *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  char *v16;
  const char *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  char *v22;
  int v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  _BOOL4 v28;
  char v29;
  int v30;
  int v31;
  uint64_t v32;
  BOOL v33;
  char *v34;
  char *v35;
  int v36;
  _QWORD v37[2];
  char *v38;
  char *v39;
  char *v40;
  int v41;
  char *__sa;
  char *v43[2];
  __int128 v44;
  __int128 v45;
  int v46[4];
  __int128 __s2;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 __s1;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  void *v55[8];
  void *v56[7];
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (*(int *)a4 > 0)
    return;
  Default_0 = __s;
  v57 = 0;
  memset(&v56[1], 0, 48);
  v56[0] = (char *)&v56[1] + 5;
  LODWORD(v56[1]) = 40;
  memset(&v55[1], 0, 56);
  v55[0] = (char *)&v55[1] + 5;
  LODWORD(v55[1]) = 40;
  __sa = 0;
  if (!__s)
  {
    Default_0 = (char *)uloc_getDefault_0(0);
LABEL_16:
    __sa = Default_0;
    goto LABEL_17;
  }
  if (strchr(__s, 64) || sub_18BC3B33C(Default_0) != 1)
    goto LABEL_16;
  if (!strchr(Default_0, 95))
    goto LABEL_94;
  v8 = Default_0[1];
  if (v8 == 45)
    goto LABEL_94;
  if (v8 == 95)
    goto LABEL_94;
  icu::CharString::append((icu::CharString *)v55, Default_0, -1, a4);
  if (*(int *)a4 > 0)
    goto LABEL_94;
  for (i = v55[0]; *i == 95; ++i)
  {
    *i = 45;
LABEL_14:
    ;
  }
  if (*i)
    goto LABEL_14;
  Default_0 = (char *)v55[0];
LABEL_94:
  __s1 = 0uLL;
  icu::CharStringByteSink::CharStringByteSink(&__s1, (uint64_t)v56);
  ulocimp_forLanguageTag(Default_0, -1, (uint64_t)&__s1, 0, (int *)a4);
  if ((_DWORD)v57)
    v33 = *a4 <= U_ZERO_ERROR;
  else
    v33 = 0;
  v34 = (char *)v56[0];
  if (!v33)
    v34 = Default_0;
  __sa = v34;
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&__s1);
  Default_0 = __sa;
LABEL_17:
  v53 = 0u;
  v54 = 0u;
  __s1 = 0u;
  v52 = 0u;
  sub_18BC3BA38((uint64_t)Default_0, &__sa, a4, (uint64_t)&__s1);
  if (DWORD2(v54) == 9)
  {
    v10 = (icu::Locale *)strncmp(Default_0, aIDefault_0, 9uLL);
    if (!(_DWORD)v10)
    {
      DWORD2(v54) = 0;
      *(_BYTE *)__s1 = 0;
      v17 = (const char *)uloc_getDefault_0(v10);
      icu::StringPiece::StringPiece((icu::StringPiece *)&v40, v17);
      icu::CharString::append((icu::CharString *)&__s1, v40, v41, a4);
LABEL_32:
      v14 = 0;
      v12 = 0;
      v18 = 0;
      goto LABEL_47;
    }
  }
  v11 = *__sa;
  if (v11 != 95 && v11 != 45)
    goto LABEL_32;
  v39 = 0;
  icu::CharString::append((icu::CharString *)&__s1, 95, a4);
  v49 = 0u;
  v50 = 0u;
  __s2 = 0u;
  v48 = 0u;
  sub_18BC3BBB8((icu::CharString *)(__sa + 1), &v39, a4, (uint64_t)&__s2);
  icu::CharString::append((icu::CharString *)&__s1, (const char *)__s2, SDWORD2(v50), a4);
  v12 = DWORD2(v50);
  if (SDWORD2(v50) < 1)
  {
    v14 = 1;
  }
  else
  {
    __sa = v39;
    v13 = *v39;
    if (v13 == 95 || v13 == 45)
      icu::CharString::append((icu::CharString *)&__s1, 95, a4);
    v14 = 2;
  }
  v15 = *__sa;
  if (v15 == 95 || v15 == 45)
  {
    v38 = 0;
    v45 = 0u;
    *(_OWORD *)v46 = 0u;
    *(_OWORD *)v43 = 0u;
    v44 = 0u;
    sub_18BC3BCC4((uint64_t)(__sa + 1), (uint64_t *)&v38, a4, (uint64_t)v43);
    icu::CharString::append((icu::CharString *)&__s1, v43[0], v46[2], a4);
    if (v46[2])
    {
      v16 = v38;
      __sa = v38;
    }
    else
    {
      v16 = __sa;
    }
    v19 = *v16;
    if (v19 == 95 || v19 == 45)
    {
      v20 = v16[1];
      if (v20 != 45 && v20 != 95)
      {
        ++v14;
        icu::CharString::append((icu::CharString *)&__s1, 95, a4);
      }
      v21 = DWORD2(v54);
      v37[0] = 0;
      v37[1] = 0;
      icu::CharStringByteSink::CharStringByteSink(v37, (uint64_t)&__s1);
      sub_18BC3C938(__sa + 1, *__sa, (uint64_t)v37, 0);
      icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v37);
      v18 = DWORD2(v54) - v21;
      if (DWORD2(v54) - v21 >= 1)
        __sa += (v18 + 1);
    }
    else
    {
      v18 = 0;
    }
    if (BYTE4(v43[1]))
      uprv_free(v43[0]);
  }
  else
  {
    v18 = 0;
  }
  if (BYTE12(__s2))
    uprv_free((void *)__s2);
LABEL_47:
  v22 = __sa;
  if ((a3 & 1) == 0)
  {
    v23 = *__sa;
    if (v23 == 46)
    {
      while (((char)v23 | 0x40) != 0x40)
      {
        icu::CharString::append((icu::CharString *)&__s1, v23, a4);
        v22 = __sa + 1;
        __sa = v22;
        LOBYTE(v23) = *v22;
      }
    }
  }
  v24 = strchr(v22, 64);
  v25 = v24;
  __sa = v24;
  if (!v24)
  {
    v27 = 0;
    goto LABEL_58;
  }
  v26 = strchr(v24, 61);
  v27 = strchr(v25, 59);
  v28 = v26 == 0;
  if ((a3 & 1) == 0 && !v26)
  {
    v29 = *v25;
    if (!*v25)
    {
      v26 = 0;
      goto LABEL_81;
    }
    do
    {
      icu::CharString::append((icu::CharString *)&__s1, v29, a4);
      v25 = __sa + 1;
      __sa = v25;
      v29 = *v25;
    }
    while (*v25);
LABEL_58:
    v26 = 0;
    v28 = 1;
  }
  if ((a3 & 1) == 0)
    goto LABEL_81;
  if (!v25)
    v28 = 0;
  if (v28)
  {
    if (v14 < 2 || v14 == 2 && v12 >= 1)
    {
      if (v14 <= 1)
        v30 = 1;
      else
        v30 = v14;
      v31 = v30 - v14 + 1;
      do
      {
        icu::CharString::append((icu::CharString *)&__s1, 95, a4);
        --v31;
      }
      while (v31);
    }
    __s2 = 0uLL;
    icu::CharStringByteSink::CharStringByteSink(&__s2, (uint64_t)&__s1);
    sub_18BC3C938(__sa + 1, 64, (uint64_t)&__s2, v18 > 0);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&__s2);
  }
  v32 = 0;
  while (2)
  {
    __s2 = 0uLL;
    icu::StringPiece::StringPiece((icu::StringPiece *)&__s2, off_1E2256228[v32]);
    if (DWORD2(v54) != DWORD2(__s2))
    {
LABEL_76:
      v32 += 2;
      if (v32 == 20)
        goto LABEL_81;
      continue;
    }
    break;
  }
  if (DWORD2(__s2))
  {
    if (!memcmp((const void *)__s1, (const void *)__s2, SDWORD2(__s2)))
      goto LABEL_80;
    goto LABEL_76;
  }
  if (__sa)
    goto LABEL_81;
LABEL_80:
  DWORD2(v54) = 0;
  *(_BYTE *)__s1 = 0;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v35, off_1E2256228[v32 + 1]);
  icu::CharString::append((icu::CharString *)&__s1, v35, v36, a4);
LABEL_81:
  (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 16))(a2, __s1, DWORD2(v54));
  if ((a3 & 2) == 0 && __sa && v26 && (!v27 || v27 > v26))
  {
    (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "@", 1);
    sub_18BC3AB60(__sa + 1, 64, a2, 1, (int *)a4);
  }
  if (BYTE12(__s1))
    uprv_free((void *)__s1);
  if (BYTE4(v55[1]))
    uprv_free(v55[0]);
  if (BYTE4(v56[1]))
    uprv_free(v56[0]);
}

uint64_t uloc_getBaseName(char *a1, char *a2, int a3, UErrorCode *a4)
{
  uint64_t v4;
  __int128 v10;
  __int128 v11;

  if (*(int *)a4 > 0)
    return 0;
  v10 = 0u;
  v11 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v10, a2, a3);
  sub_18BC3CB6C(a1, (uint64_t)&v10, 2, a4);
  v4 = DWORD2(v11);
  if (*(int *)a4 <= 0)
  {
    if (BYTE12(v11))
      *a4 = U_BUFFER_OVERFLOW_ERROR;
    else
      u_terminateChars((uint64_t)a2, a3, DWORD2(v11), (int *)a4);
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v10);
  return v4;
}

void ulocimp_getBaseName(char *a1, uint64_t a2, UErrorCode *a3)
{
  sub_18BC3CB6C(a1, a2, 2, a3);
}

uint64_t uloc_canonicalize(char *a1, char *a2, int a3, int *a4)
{
  uint64_t v4;
  __int128 v10;
  __int128 v11;

  if (*a4 > 0)
    return 0;
  v10 = 0u;
  v11 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v10, a2, a3);
  sub_18BC3CB6C(a1);
  v4 = DWORD2(v11);
  if (*a4 <= 0)
  {
    if (BYTE12(v11))
      *a4 = 15;
    else
      u_terminateChars((uint64_t)a2, a3, DWORD2(v11), a4);
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v10);
  return v4;
}

uint64_t ulocimp_canonicalize(char *a1)
{
  return sub_18BC3CB6C(a1);
}

uint64_t ualoc_canonicalForm(icu::Locale *a1, void *a2, int a3, int *a4)
{
  uint64_t v4;
  char *v8;
  size_t v9;
  int v10;
  _OWORD v12[2];
  char *__s[2];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (*a4 > 0)
    return 0;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  *(_OWORD *)__s = 0u;
  v14 = 0u;
  memset(v12, 0, sizeof(v12));
  icu::Locale::createCanonical(a1, (icu::Locale *)v12);
  v8 = __s[1];
  v9 = strlen(__s[1]);
  v10 = uprv_min(v9, a3);
  memcpy(a2, v8, v10);
  v4 = u_terminateChars((uint64_t)a2, a3, v9, a4);
  icu::Locale::~Locale((icu::Locale *)v12);
  return v4;
}

char *uloc_getISO3Language(uint64_t Default_0)
{
  int v2;
  int v3;
  char __s1[8];
  int v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  if (!Default_0)
    Default_0 = uloc_getDefault_0(0);
  v5 = 0;
  *(_QWORD *)__s1 = 0;
  uloc_getLanguage(Default_0, __s1, 12, &v3);
  if (v3 > 0)
    return "";
  v2 = sub_18BC3B978((const char **)off_1E2253D98, __s1);
  if (v2 < 0)
    return "";
  else
    return off_1E2252A10[(unsigned __int16)v2];
}

char *uloc_getISO3Country(uint64_t Default_0)
{
  int v2;
  int v3;
  char __s1[8];
  int v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  if (!Default_0)
    Default_0 = uloc_getDefault_0(0);
  v5 = 0;
  *(_QWORD *)__s1 = 0;
  uloc_getCountry(Default_0, __s1, 12, &v3);
  if (v3 > 0)
    return "";
  v2 = sub_18BC3B978((const char **)off_1E2255988, __s1);
  if (v2 < 0)
    return "";
  else
    return off_1E2255120[(unsigned __int16)v2];
}

uint64_t uloc_getLCID(char *a1)
{
  uint64_t v2;
  uint64_t v3;
  int BaseName;
  int v6;
  int v7;
  _QWORD v8[2];
  int v9;
  void *v10[7];
  uint64_t v11;
  char __s[16];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[29];
  char v21[168];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  if (!a1 || strlen(a1) < 2)
    return 0;
  memset(v21, 0, 157);
  v2 = uprv_convertToLCIDPlatform();
  v3 = v2;
  if (!(_DWORD)v2)
  {
    uloc_getLanguage((uint64_t)a1, v21, 157, &v9);
    if (v9 <= 0 && v9 != -124)
    {
      if (!strchr(a1, 64))
        return uprv_convertToLCID(v21, a1, &v9);
      v19 = 0u;
      memset(v20, 0, sizeof(v20));
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      v13 = 0u;
      v14 = 0u;
      *(_OWORD *)__s = 0u;
      memset(&v10[1], 0, 48);
      v11 = 0;
      v10[0] = (char *)&v10[1] + 5;
      LODWORD(v10[1]) = 40;
      v8[0] = 0;
      v8[1] = 0;
      icu::CharStringByteSink::CharStringByteSink(v8, (uint64_t)v10);
      ulocimp_getKeywordValue(a1, "collation", (uint64_t)v8, &v9);
      icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v8);
      if (v9 > 0)
        goto LABEL_17;
      if ((_DWORD)v11
        && (BaseName = uloc_getBaseName(a1, __s, 156, (UErrorCode *)&v9), v9 <= 0)
        && BaseName >= 1
        && (__s[BaseName] = 0, v6 = uloc_setKeywordValue("collation", (_BYTE *)v10[0], __s, 156 - BaseName, &v9),
                               v9 <= 0)
        && v6 >= 1)
      {
        __s[v6] = 0;
        v3 = uprv_convertToLCID(v21, __s, &v9);
        v7 = 0;
      }
      else
      {
LABEL_17:
        v9 = 0;
        v7 = 1;
      }
      if (BYTE4(v10[1]))
        uprv_free(v10[0]);
      if (v7)
        return uprv_convertToLCID(v21, a1, &v9);
    }
  }
  return v3;
}

char *uloc_setDefault(char *a1, int *a2)
{
  if (*a2 <= 0)
    return (char *)sub_18BBC751C(a1);
  return a1;
}

char **uloc_getISOLanguages()
{
  return off_1E2253D98;
}

char **uloc_getISOCountries()
{
  return off_1E2255988;
}

char *uloc_toUnicodeLocaleKey(uint64_t a1)
{
  char *v1;
  uint64_t v2;

  v1 = (char *)a1;
  v2 = sub_18BC3DAB0(a1);
  if (v2 || !sub_18BC3F39C(v1, -1))
    return (char *)v2;
  return v1;
}

char *uloc_toUnicodeLocaleType(uint64_t a1, char *a2)
{
  char *v2;
  uint64_t v3;

  v2 = a2;
  v3 = sub_18BC3E5B8(a1, a2, 0, 0);
  if (v3 || !sub_18BC3F2E8(v2, -1))
    return (char *)v3;
  return v2;
}

uint64_t uloc_toLegacyKey(char *a1)
{
  uint64_t result;
  char v3;
  unsigned __int8 *v4;
  int v5;

  result = sub_18BC3E574((uint64_t)a1);
  if (!result)
  {
    v3 = *a1;
    if (*a1)
    {
      v4 = (unsigned __int8 *)(a1 + 1);
      while (uprv_isASCIILetter(v3) || *(v4 - 1) - 48 <= 9)
      {
        v5 = *v4++;
        v3 = v5;
        if (!v5)
          return (uint64_t)a1;
      }
      return 0;
    }
    else
    {
      return (uint64_t)a1;
    }
  }
  return result;
}

uint64_t uloc_toLegacyType(uint64_t a1, _BYTE *a2)
{
  _BYTE *v2;
  uint64_t v3;
  int v5;
  _BYTE *i;
  int v7;

  v2 = a2;
  v3 = sub_18BC3E7F4(a1, a2, 0, 0);
  if (v3)
    return v3;
  v5 = 0;
  for (i = v2; ; ++i)
  {
    v7 = *i;
    if ((v7 - 45) <= 0x32 && ((1 << (v7 - 45)) & 0x4000000000005) != 0)
    {
      if (!v5)
        return v3;
      v5 = 0;
      continue;
    }
    if (!*i)
      break;
    if (!uprv_isASCIILetter(v7) && *i - 48 > 9)
      return v3;
    ++v5;
  }
  if (!v5)
    return v3;
  return (uint64_t)v2;
}

void sub_18BC3D9B8(void ***a1)
{
  uprv_free(*a1[1]);
  uprv_free(a1[1]);
  uprv_free(a1);
}

uint64_t sub_18BC3D9EC(uint64_t a1)
{
  const char *v1;
  uint64_t v2;
  const char *v3;
  int v4;

  v1 = **(const char ***)(a1 + 8);
  if (!*v1)
    return 0;
  LODWORD(v2) = 0;
  do
  {
    v2 = (v2 + 1);
    v3 = &v1[strlen(v1)];
    v4 = *((unsigned __int8 *)v3 + 1);
    v1 = v3 + 1;
  }
  while (v4);
  return v2;
}

_BYTE *sub_18BC3DA3C(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  _BYTE *v4;
  int v5;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_BYTE **)(v3 + 8);
  if (!*v4)
  {
    v4 = 0;
    v5 = 0;
    if (!a2)
      return v4;
    goto LABEL_3;
  }
  v5 = strlen(*(const char **)(v3 + 8));
  *(_QWORD *)(v3 + 8) = &v4[v5 + 1];
  if (a2)
LABEL_3:
    *a2 = v5;
  return v4;
}

uint64_t sub_18BC3DAA0(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = **(_QWORD **)(result + 8);
  return result;
}

uint64_t sub_18BC3DAB0(uint64_t a1)
{
  uint64_t result;

  if (!sub_18BC3DAF4())
    return 0;
  result = uhash_get(qword_1ECD27AF8, a1);
  if (result)
    return *(_QWORD *)(result + 8);
  return result;
}

BOOL sub_18BC3DAF4()
{
  unsigned int v0;
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  char *NextResource;
  const char *Key;
  const UChar *String;
  unint64_t v16;
  const char *v17;
  icu::CharString *v18;
  const char **v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  int v25;
  char *v26;
  int v27;
  unint64_t v28;
  char *v29;
  char *v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  const char *v34;
  unint64_t v35;
  int v36;
  icu::CharString *v37;
  char **p_s;
  char *v39;
  _QWORD *v40;
  uint64_t v41;
  char *v42;
  UChar *v43;
  UErrorCode v44;
  char *v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  _BOOL4 hasNext;
  char *v50;
  UChar *v51;
  UErrorCode v52;
  uint64_t v53;
  _BOOL4 v54;
  _OWORD *v55;
  uint64_t v56;
  void **v57;
  uint64_t v59;
  char *v60;
  _QWORD *v61;
  _QWORD *v62;
  _QWORD *v63;
  const char *v64;
  uint64_t v65;
  int32x2_t *v66;
  int v67;
  _QWORD *v68;
  _QWORD *v69;
  UErrorCode v70;
  char *__s;
  int v72;
  const UChar *v73;
  int v74;
  const UChar *v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  uint64_t v79;
  void (**v80)(icu::UnicodeString *__hidden);
  __int128 v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v70 = U_ZERO_ERROR;
  v0 = atomic_load(&dword_1ECD27B00);
  if (v0 == 2 || !icu::umtx_initImplPreInit(&dword_1ECD27B00))
  {
    if (dword_1ECD27B04 >= 1)
      v70 = dword_1ECD27B04;
    return v70 < U_ILLEGAL_ARGUMENT_ERROR;
  }
  sub_18BC0ECC4(6u, (uint64_t)sub_18BC3E8E0);
  qword_1ECD27AF8 = (uint64_t)uhash_open((uint64_t)uhash_hashIChars, (uint64_t)uhash_compareIChars, 0, (int *)&v70);
  v1 = (_QWORD *)ures_openDirect(0, (uint64_t)"keyTypeData", (uint64_t)&v70);
  v2 = (_QWORD *)ures_getByKey((uint64_t)v1, "keyMap", 0, (int *)&v70);
  v3 = (_QWORD *)ures_getByKey((uint64_t)v1, "typeMap", 0, (int *)&v70);
  if (v70 > U_ZERO_ERROR)
    goto LABEL_147;
  v72 = 0;
  v4 = (_QWORD *)ures_getByKey((uint64_t)v1, "typeAlias", 0, &v72);
  v72 = 0;
  v5 = (_QWORD *)ures_getByKey((uint64_t)v1, "bcpTypeAlias", 0, &v72);
  v7 = icu::UMemory::operator new((icu::UMemory *)0x58, v6);
  if (!v7)
  {
    qword_1ECD27B08 = 0;
LABEL_142:
    v70 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_143;
  }
  *(_DWORD *)v7 = 0;
  *(_QWORD *)(v7 + 8) = v7 + 24;
  *(_DWORD *)(v7 + 16) = 8;
  *(_BYTE *)(v7 + 20) = 0;
  qword_1ECD27B08 = v7;
  v9 = icu::UMemory::operator new((icu::UMemory *)0x58, v8);
  if (!v9)
  {
    qword_1ECD27B10 = 0;
    goto LABEL_142;
  }
  *(_DWORD *)v9 = 0;
  *(_QWORD *)(v9 + 8) = v9 + 24;
  *(_DWORD *)(v9 + 16) = 8;
  *(_BYTE *)(v9 + 20) = 0;
  qword_1ECD27B10 = v9;
  v11 = icu::UMemory::operator new((icu::UMemory *)0x58, v10);
  if (!v11)
  {
    qword_1ECD27B18 = 0;
    goto LABEL_142;
  }
  v12 = 0;
  *(_DWORD *)v11 = 0;
  *(_QWORD *)(v11 + 8) = v11 + 24;
  *(_DWORD *)(v11 + 16) = 8;
  *(_BYTE *)(v11 + 20) = 0;
  qword_1ECD27B18 = v11;
  v62 = v4;
  v63 = v5;
  v61 = v3;
  do
  {
    if (!ures_hasNext((_BOOL8)v2))
      break;
    NextResource = ures_getNextResource((uint64_t)v2, v12, (int *)&v70);
    v12 = NextResource;
    if (v70 > U_ZERO_ERROR)
      break;
    Key = (const char *)ures_getKey((uint64_t)NextResource);
    v84 = 0;
    v82 = 0u;
    v83 = 0u;
    v81 = 0u;
    v80 = off_1E2256B38;
    LOWORD(v81) = 2;
    LODWORD(v73) = 0;
    String = ures_getString((uint64_t)v12, (int *)&v73, (int *)&v70);
    if (v70 <= U_ZERO_ERROR)
    {
      v75 = String;
      icu::UnicodeString::setTo((icu::UnicodeString *)&v80, 1, &v75, (int)v73);
    }
    else
    {
      icu::UnicodeString::setToBogus((icu::UnicodeString *)&v80);
    }
    if (v70 > U_ZERO_ERROR)
      goto LABEL_156;
    v17 = Key;
    if ((unsigned __int16)v81 >= 0x20u)
    {
      v18 = (icu::CharString *)sub_18BC3E964((const void **)qword_1ECD27B08, v16);
      if (!v18)
      {
        v70 = U_MEMORY_ALLOCATION_ERROR;
LABEL_156:
        icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v80);
        break;
      }
      v19 = (const char **)v18;
      icu::CharString::appendInvariantChars(v18, (const icu::UnicodeString *)&v80, &v70);
      if (v70 > U_ZERO_ERROR)
        goto LABEL_156;
      v17 = *v19;
    }
    v67 = strcmp(Key, "timezone");
    v66 = uhash_open((uint64_t)uhash_hashIChars, (uint64_t)uhash_compareIChars, 0, (int *)&v70);
    if (v70 > U_ZERO_ERROR)
      goto LABEL_156;
    if (v4)
    {
      v72 = 0;
      v20 = ures_getByKey((uint64_t)v4, Key, 0, &v72);
      if (v72 >= 1)
        v21 = 0;
      else
        v21 = (_QWORD *)v20;
      v69 = v21;
    }
    else
    {
      v69 = 0;
    }
    v65 = (uint64_t)v17;
    if (v5)
    {
      v72 = 0;
      v22 = ures_getByKey((uint64_t)v5, v17, 0, &v72);
      if (v72 >= 1)
        v23 = 0;
      else
        v23 = (_QWORD *)v22;
      v68 = v23;
    }
    else
    {
      v68 = 0;
    }
    v24 = (_QWORD *)ures_getByKey((uint64_t)v3, Key, 0, (int *)&v70);
    if (v70 > U_ZERO_ERROR)
    {
      v25 = 3;
      goto LABEL_128;
    }
    v26 = 0;
    v27 = 0;
    do
    {
      if (!ures_hasNext((_BOOL8)v24))
        break;
      v29 = ures_getNextResource((uint64_t)v24, v26, (int *)&v70);
      v26 = v29;
      if (v70 > U_ZERO_ERROR)
        break;
      __s = 0;
      v30 = (char *)ures_getKey((uint64_t)v29);
      __s = v30;
      if (!strcmp(v30, "CODEPOINTS"))
      {
        v27 |= 1u;
      }
      else if (!strcmp(v30, "REORDER_CODE"))
      {
        v27 |= 2u;
      }
      else
      {
        if (strcmp(v30, "RG_KEY_VALUE"))
        {
          if (!v67 && strchr(v30, 58))
          {
            v31 = sub_18BC3EA4C((int *)qword_1ECD27B08, (const char **)&__s, &v70);
            if (!v31)
            {
              v70 = U_MEMORY_ALLOCATION_ERROR;
              break;
            }
            if (v70 > U_ZERO_ERROR)
              break;
            v32 = *(char **)v31;
            v33 = *(int *)(v31 + 56);
            if ((_DWORD)v33)
            {
              do
              {
                if (*v32 == 58)
                  *v32 = 47;
                ++v32;
                --v33;
              }
              while (v33);
              v32 = *(char **)v31;
            }
            __s = v32;
          }
          v79 = 0;
          v77 = 0u;
          v78 = 0u;
          v76 = 0u;
          v75 = (const UChar *)off_1E2256B38;
          LOWORD(v76) = 2;
          v74 = 0;
          v34 = (const char *)ures_getString((uint64_t)v26, &v74, (int *)&v70);
          if (v70 <= U_ZERO_ERROR)
          {
            v73 = (const UChar *)v34;
            icu::UnicodeString::setTo((icu::UnicodeString *)&v75, 1, &v73, v74);
          }
          else
          {
            icu::UnicodeString::setToBogus((icu::UnicodeString *)&v75);
          }
          if (v70 > U_ZERO_ERROR)
          {
LABEL_57:
            v36 = 5;
            goto LABEL_91;
          }
          v64 = Key;
          if ((unsigned __int16)v76 < 0x20u)
          {
            p_s = &__s;
            goto LABEL_63;
          }
          v37 = (icu::CharString *)sub_18BC3E964((const void **)qword_1ECD27B08, v35);
          if (v37)
          {
            p_s = (char **)v37;
            icu::CharString::appendInvariantChars(v37, (const icu::UnicodeString *)&v75, &v70);
            if (v70 > U_ZERO_ERROR)
              goto LABEL_90;
LABEL_63:
            v39 = *p_s;
            v40 = sub_18BC3EB74((const void **)qword_1ECD27B18, v35);
            if (v40)
            {
              v41 = (uint64_t)v40;
              *v40 = __s;
              v40[1] = v39;
              uhash_put((uint64_t)v66, (uint64_t)__s, (uint64_t)v40, (int *)&v70);
              if (v39 != __s)
                uhash_put((uint64_t)v66, (uint64_t)v39, v41, (int *)&v70);
              v59 = v41;
              v60 = v39;
              if (v70 <= U_ZERO_ERROR)
              {
                Key = v64;
                v3 = v61;
                if (v69)
                {
                  ures_resetIterator((uint64_t)v69);
                  if (ures_hasNext((_BOOL8)v69) && v70 <= U_ZERO_ERROR)
                  {
                    v42 = 0;
                    do
                    {
                      v74 = 0;
                      v42 = ures_getNextResource((uint64_t)v69, v42, (int *)&v70);
                      v43 = (UChar *)ures_getString((uint64_t)v42, &v74, (int *)&v70);
                      v44 = v70;
                      if (v70 > U_ZERO_ERROR)
                        break;
                      if (!sub_18BC38B10(0, __s, -1, v43, v74))
                      {
                        v73 = 0;
                        v45 = (char *)ures_getKey((uint64_t)v42);
                        v46 = v45;
                        v73 = (const UChar *)v45;
                        if (!v67 && strchr(v45, 58))
                        {
                          v47 = sub_18BC3EA4C((int *)qword_1ECD27B08, (const char **)&v73, &v70);
                          if (!v47)
                          {
                            v44 = U_MEMORY_ALLOCATION_ERROR;
                            v70 = U_MEMORY_ALLOCATION_ERROR;
                            if (!v42)
                              goto LABEL_97;
LABEL_87:
                            ures_close(v42);
                            if (v44 >= U_ILLEGAL_ARGUMENT_ERROR)
                              goto LABEL_57;
                            goto LABEL_98;
                          }
                          v44 = v70;
                          if (v70 > U_ZERO_ERROR)
                            break;
                          v46 = *(char **)v47;
                          v48 = *(int *)(v47 + 56);
                          if ((_DWORD)v48)
                          {
                            do
                            {
                              if (*v46 == 58)
                                *v46 = 47;
                              ++v46;
                              --v48;
                            }
                            while (v48);
                            v46 = *(char **)v47;
                          }
                          v73 = (const UChar *)v46;
                        }
                        uhash_put((uint64_t)v66, (uint64_t)v46, v59, (int *)&v70);
                      }
                      hasNext = ures_hasNext((_BOOL8)v69);
                      v44 = v70;
                    }
                    while (hasNext && v70 < U_ILLEGAL_ARGUMENT_ERROR);
                    if (v42)
                      goto LABEL_87;
LABEL_97:
                    if (v44 > U_ZERO_ERROR)
                      goto LABEL_57;
                  }
                  else if (v70 >= U_ILLEGAL_ARGUMENT_ERROR)
                  {
                    goto LABEL_57;
                  }
                }
LABEL_98:
                if (v68)
                {
                  ures_resetIterator((uint64_t)v68);
                  if (ures_hasNext((_BOOL8)v68) && v70 <= U_ZERO_ERROR)
                  {
                    v50 = 0;
                    do
                    {
                      LODWORD(v73) = 0;
                      v50 = ures_getNextResource((uint64_t)v68, v50, (int *)&v70);
                      v51 = (UChar *)ures_getString((uint64_t)v50, (int *)&v73, (int *)&v70);
                      v52 = v70;
                      if (v70 >= U_ILLEGAL_ARGUMENT_ERROR)
                        break;
                      if (!sub_18BC38B10(0, v60, -1, v51, (int)v73))
                      {
                        v53 = ures_getKey((uint64_t)v50);
                        uhash_put((uint64_t)v66, v53, v59, (int *)&v70);
                      }
                      v54 = ures_hasNext((_BOOL8)v68);
                      v52 = v70;
                      if (!v54)
                        break;
                    }
                    while (v70 < U_ILLEGAL_ARGUMENT_ERROR);
                    if (v50)
                    {
                      ures_close(v50);
                      if (v52 >= U_ILLEGAL_ARGUMENT_ERROR)
                        goto LABEL_57;
                    }
                    else if (v52 > U_ZERO_ERROR)
                    {
                      goto LABEL_57;
                    }
                  }
                  else if (v70 >= U_ILLEGAL_ARGUMENT_ERROR)
                  {
                    goto LABEL_57;
                  }
                }
                v36 = 0;
LABEL_91:
                icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v75);
                continue;
              }
LABEL_90:
              v36 = 5;
              Key = v64;
              v3 = v61;
              goto LABEL_91;
            }
          }
          v70 = U_MEMORY_ALLOCATION_ERROR;
          goto LABEL_90;
        }
        v27 |= 4u;
      }
      v36 = 4;
    }
    while (v36 != 5);
    if (v26)
      ures_close(v26);
    if (v70 > U_ZERO_ERROR)
    {
      v25 = 3;
      v4 = v62;
      goto LABEL_127;
    }
    v55 = sub_18BC3EC48((const void **)qword_1ECD27B10, v28);
    v5 = v63;
    if (v55)
    {
      v56 = (uint64_t)v55;
      *(_QWORD *)v55 = Key;
      *((_QWORD *)v55 + 1) = v65;
      *((_DWORD *)v55 + 6) = v27;
      v57 = (void **)*((_QWORD *)v55 + 2);
      if (v57)
        uhash_close(v57);
      *(_QWORD *)(v56 + 16) = v66;
      uhash_put(qword_1ECD27AF8, (uint64_t)Key, v56, (int *)&v70);
      v4 = v62;
      if (Key != (const char *)v65)
        uhash_put(qword_1ECD27AF8, v65, v56, (int *)&v70);
      if (v70 <= U_ZERO_ERROR)
        v25 = 0;
      else
        v25 = 3;
LABEL_127:
      v5 = v63;
    }
    else
    {
      v70 = U_MEMORY_ALLOCATION_ERROR;
      v25 = 3;
      v4 = v62;
    }
LABEL_128:
    if (v24)
      ures_close(v24);
    if (v68)
      ures_close(v68);
    if (v69)
      ures_close(v69);
    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v80);
  }
  while (!v25);
  if (v12)
    ures_close(v12);
LABEL_143:
  if (v5)
    ures_close(v5);
  if (v4)
    ures_close(v4);
LABEL_147:
  if (v3)
    ures_close(v3);
  if (v2)
    ures_close(v2);
  if (v1)
    ures_close(v1);
  dword_1ECD27B04 = v70;
  icu::umtx_initImplPostInit(&dword_1ECD27B00);
  return v70 < U_ILLEGAL_ARGUMENT_ERROR;
}

uint64_t sub_18BC3E574(uint64_t a1)
{
  uint64_t result;

  if (!sub_18BC3DAF4())
    return 0;
  result = uhash_get(qword_1ECD27AF8, a1);
  if (result)
    return *(_QWORD *)result;
  return result;
}

uint64_t sub_18BC3E5B8(uint64_t a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _BOOL4 v12;

  if (a3)
    *a3 = 0;
  if (a4)
    *a4 = 0;
  if (!sub_18BC3DAF4())
    return 0;
  result = uhash_get(qword_1ECD27AF8, a1);
  if (!result)
    return result;
  v9 = result;
  if (a3)
    *a3 = 1;
  v10 = uhash_get(*(_QWORD *)(result + 16), (uint64_t)a2);
  if (v10)
    return *(_QWORD *)(v10 + 8);
  v11 = *(_DWORD *)(v9 + 24);
  if (!v11)
    return 0;
  if ((v11 & 1) != 0 && sub_18BC3E6A4(a2))
  {
LABEL_16:
    if (!a4)
      return (uint64_t)a2;
    goto LABEL_27;
  }
  if ((v11 & 2) != 0)
  {
    if (sub_18BC3E718(a2))
      goto LABEL_16;
    v11 = *(_DWORD *)(v9 + 24);
  }
  if ((v11 & 4) == 0)
    return 0;
  v12 = sub_18BC3E788(a2);
  if (v12)
    result = (uint64_t)a2;
  else
    result = 0;
  if (a4 && v12)
  {
LABEL_27:
    *a4 = 1;
    return (uint64_t)a2;
  }
  return result;
}

BOOL sub_18BC3E6A4(_BYTE *a1)
{
  int v1;
  int v2;
  unsigned int v3;
  BOOL v4;
  uint64_t v5;
  BOOL v6;
  unsigned int v7;

  v1 = 0;
  while (1)
  {
    v2 = *a1;
    if (v2 != 45)
      break;
    v7 = v1 - 7;
    v1 = 0;
    if (v7 < 0xFFFFFFFD)
      return 0;
LABEL_11:
    ++a1;
  }
  if (!*a1)
    return (v1 - 4) < 3;
  if ((v2 - 48) < 0xA
    || ((v3 = v2 - 65, v4 = v3 > 0x25, v5 = (1 << v3) & 0x3F0000003FLL, !v4) ? (v6 = v5 == 0) : (v6 = 1), !v6))
  {
    ++v1;
    goto LABEL_11;
  }
  return 0;
}

BOOL sub_18BC3E718(_BYTE *a1)
{
  int v2;
  int v3;
  _BOOL8 result;
  unsigned int v5;

  v2 = 0;
  while (1)
  {
    v3 = *a1;
    if (v3 == 45)
      break;
    if (!*a1)
      return (v2 - 3) < 6;
    result = uprv_isASCIILetter(v3);
    if (!result)
      return result;
    ++v2;
LABEL_7:
    ++a1;
  }
  v5 = v2 - 9;
  v2 = 0;
  if (v5 >= 0xFFFFFFFA)
    goto LABEL_7;
  return 0;
}

BOOL sub_18BC3E788(_BYTE *a1)
{
  int v1;
  uint64_t v2;
  _BYTE *v3;
  _BOOL8 result;

  LOBYTE(v1) = *a1;
  if (!*a1)
    return 0;
  v2 = 0;
  v3 = a1 + 1;
  do
  {
    if (v2 > 1)
    {
      if ((v1 | 0x20) != 0x7A)
        return 0;
    }
    else
    {
      result = uprv_isASCIILetter(v1);
      if (!result)
        return result;
    }
    v1 = v3[v2++];
  }
  while (v1);
  return (_DWORD)v2 == 6;
}

uint64_t sub_18BC3E7F4(uint64_t a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _BOOL4 v12;

  if (a3)
    *a3 = 0;
  if (a4)
    *a4 = 0;
  if (!sub_18BC3DAF4())
    return 0;
  result = uhash_get(qword_1ECD27AF8, a1);
  if (!result)
    return result;
  v9 = result;
  if (a3)
    *a3 = 1;
  v10 = uhash_get(*(_QWORD *)(result + 16), (uint64_t)a2);
  if (v10)
    return *(_QWORD *)v10;
  v11 = *(_DWORD *)(v9 + 24);
  if (!v11)
    return 0;
  if ((v11 & 1) != 0 && sub_18BC3E6A4(a2))
  {
LABEL_16:
    if (!a4)
      return (uint64_t)a2;
    goto LABEL_27;
  }
  if ((v11 & 2) != 0)
  {
    if (sub_18BC3E718(a2))
      goto LABEL_16;
    v11 = *(_DWORD *)(v9 + 24);
  }
  if ((v11 & 4) == 0)
    return 0;
  v12 = sub_18BC3E788(a2);
  if (v12)
    result = (uint64_t)a2;
  else
    result = 0;
  if (a4 && v12)
  {
LABEL_27:
    *a4 = 1;
    return (uint64_t)a2;
  }
  return result;
}

uint64_t sub_18BC3E8E0()
{
  void *v0;
  void *v1;
  void *v2;

  if (qword_1ECD27AF8)
  {
    uhash_close((void **)qword_1ECD27AF8);
    qword_1ECD27AF8 = 0;
  }
  if (qword_1ECD27B10)
  {
    v0 = (void *)sub_18BC3ED20(qword_1ECD27B10);
    icu::UMemory::operator delete(v0);
  }
  qword_1ECD27B10 = 0;
  if (qword_1ECD27B18)
  {
    v1 = (void *)sub_18BC3ED98(qword_1ECD27B18);
    icu::UMemory::operator delete(v1);
  }
  qword_1ECD27B18 = 0;
  if (qword_1ECD27B08)
  {
    v2 = (void *)sub_18BC3EDF8(qword_1ECD27B08);
    icu::UMemory::operator delete(v2);
  }
  qword_1ECD27B08 = 0;
  atomic_store(0, &dword_1ECD27B00);
  return 1;
}

_QWORD *sub_18BC3E964(const void **a1, unint64_t a2)
{
  int v3;
  int v4;
  _QWORD *result;
  _QWORD *v6;
  int v7;
  uint64_t v8;

  v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8)
      v4 = 32;
    else
      v4 = 2 * v3;
    if (v4 < 1)
      return 0;
    result = uprv_malloc(8 * v4);
    if (!result)
      return result;
    v6 = result;
    if (v3 >= 1)
    {
      v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3)
        v7 = v3;
      if (v7 >= v4)
        v7 = v4;
      memcpy(result, a1[1], 8 * v7);
    }
    if (*((_BYTE *)a1 + 20))
      uprv_free((void *)a1[1]);
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((_BYTE *)a1 + 20) = 1;
  }
  result = (_QWORD *)icu::UMemory::operator new((icu::UMemory *)0x40, a2);
  if (result)
  {
    *result = (char *)result + 13;
    *((_DWORD *)result + 2) = 40;
    *((_WORD *)result + 6) = 0;
    *((_DWORD *)result + 14) = 0;
  }
  v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((_QWORD *)a1[1] + v8) = result;
  return result;
}

uint64_t sub_18BC3EA4C(int *a1, const char **a2, UErrorCode *a3)
{
  int v6;
  int v7;
  void *v8;
  uint64_t v9;
  int v10;
  char *v11;
  int v12;
  uint64_t v13;
  char *v15;
  int v16;

  v6 = a1[4];
  if (*a1 != v6)
  {
LABEL_16:
    v9 = icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
    if (v9)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v15, *a2);
      v11 = v15;
      v12 = v16;
      *(_QWORD *)v9 = v9 + 13;
      *(_DWORD *)(v9 + 8) = 40;
      *(_WORD *)(v9 + 12) = 0;
      *(_DWORD *)(v9 + 56) = 0;
      icu::CharString::append((icu::CharString *)v9, v11, v12, a3);
    }
    v13 = *a1;
    *a1 = v13 + 1;
    *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v13) = v9;
    return v9;
  }
  if (v6 == 8)
    v7 = 32;
  else
    v7 = 2 * v6;
  if (v7 < 1)
    return 0;
  v8 = uprv_malloc(8 * v7);
  v9 = (uint64_t)v8;
  if (v8)
  {
    if (v6 >= 1)
    {
      v10 = a1[4];
      if (v10 >= v6)
        v10 = v6;
      if (v10 >= v7)
        v10 = v7;
      memcpy(v8, *((const void **)a1 + 1), 8 * v10);
    }
    if (*((_BYTE *)a1 + 20))
      uprv_free(*((void **)a1 + 1));
    *((_QWORD *)a1 + 1) = v9;
    a1[4] = v7;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }
  return v9;
}

_QWORD *sub_18BC3EB74(const void **a1, unint64_t a2)
{
  int v3;
  int v4;
  _QWORD *result;
  _QWORD *v6;
  int v7;
  uint64_t v8;

  v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8)
      v4 = 32;
    else
      v4 = 2 * v3;
    if (v4 < 1)
      return 0;
    result = uprv_malloc(8 * v4);
    if (!result)
      return result;
    v6 = result;
    if (v3 >= 1)
    {
      v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3)
        v7 = v3;
      if (v7 >= v4)
        v7 = v4;
      memcpy(result, a1[1], 8 * v7);
    }
    if (*((_BYTE *)a1 + 20))
      uprv_free((void *)a1[1]);
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((_BYTE *)a1 + 20) = 1;
  }
  result = (_QWORD *)icu::UMemory::operator new((icu::UMemory *)0x10, a2);
  if (result)
  {
    *result = 0;
    result[1] = 0;
  }
  v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((_QWORD *)a1[1] + v8) = result;
  return result;
}

_OWORD *sub_18BC3EC48(const void **a1, unint64_t a2)
{
  int v3;
  int v4;
  _OWORD *result;
  _OWORD *v6;
  int v7;
  uint64_t v8;

  v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8)
      v4 = 32;
    else
      v4 = 2 * v3;
    if (v4 < 1)
      return 0;
    result = uprv_malloc(8 * v4);
    if (!result)
      return result;
    v6 = result;
    if (v3 >= 1)
    {
      v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3)
        v7 = v3;
      if (v7 >= v4)
        v7 = v4;
      memcpy(result, a1[1], 8 * v7);
    }
    if (*((_BYTE *)a1 + 20))
      uprv_free((void *)a1[1]);
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((_BYTE *)a1 + 20) = 1;
  }
  result = (_OWORD *)icu::UMemory::operator new((icu::UMemory *)0x20, a2);
  if (result)
  {
    *result = 0u;
    result[1] = 0u;
  }
  v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((_QWORD *)a1[1] + v8) = result;
  return result;
}

uint64_t sub_18BC3ED20(uint64_t a1)
{
  int v2;
  uint64_t v3;
  _QWORD *v4;
  void **v5;

  v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    v3 = 0;
    do
    {
      v4 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        v5 = (void **)v4[2];
        if (v5)
          uhash_close(v5);
        icu::UMemory::operator delete(v4);
        v2 = *(_DWORD *)a1;
      }
      ++v3;
    }
    while (v3 < v2);
  }
  if (*(_BYTE *)(a1 + 20))
    uprv_free(*(void **)(a1 + 8));
  return a1;
}

uint64_t sub_18BC3ED98(uint64_t a1)
{
  int v2;
  uint64_t v3;
  void *v4;

  v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    v3 = 0;
    do
    {
      v4 = *(void **)(*(_QWORD *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        icu::UMemory::operator delete(v4);
        v2 = *(_DWORD *)a1;
      }
      ++v3;
    }
    while (v3 < v2);
  }
  if (*(_BYTE *)(a1 + 20))
    uprv_free(*(void **)(a1 + 8));
  return a1;
}

uint64_t sub_18BC3EDF8(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        if (*(_BYTE *)(v4 + 12))
          uprv_free(*(void **)v4);
        icu::UMemory::operator delete((void *)v4);
        v2 = *(_DWORD *)a1;
      }
      ++v3;
    }
    while (v3 < v2);
  }
  if (*(_BYTE *)(a1 + 20))
    uprv_free(*(void **)(a1 + 8));
  return a1;
}

BOOL sub_18BC3EE74(char *__s, unsigned int a2)
{
  char *v2;
  uint64_t v3;
  char v4;
  _BOOL8 result;

  v2 = __s;
  if ((a2 & 0x80000000) != 0)
    a2 = strlen(__s);
  if (a2 - 2 > 6)
    return 0;
  v3 = a2;
  while (1)
  {
    v4 = *v2++;
    result = uprv_isASCIILetter(v4);
    if (!result)
      break;
    if (!--v3)
      return 1;
  }
  return result;
}

BOOL sub_18BC3EED0(char *__s, int a2)
{
  uint64_t v3;
  _BOOL8 result;

  if (a2 < 0)
    a2 = strlen(__s);
  if (a2 != 4)
    return 0;
  v3 = 0;
  while (1)
  {
    result = uprv_isASCIILetter(__s[v3]);
    if (!result)
      break;
    if (++v3 == 4)
      return 1;
  }
  return result;
}

BOOL sub_18BC3EF2C(char *__s, int a2)
{
  uint64_t v3;
  _BOOL8 result;
  uint64_t v5;

  if (a2 < 0)
    a2 = strlen(__s);
  if (a2 == 2)
  {
    v5 = 0;
    while (1)
    {
      result = uprv_isASCIILetter(__s[v5]);
      if (!result)
        break;
      if (++v5 == 2)
        return 1;
    }
  }
  else
  {
    if (a2 == 3)
    {
      v3 = 0;
      while (__s[v3] - 48 < 0xA)
      {
        if (++v3 == 3)
          return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_18BC3EFB4(char *__s, int a2)
{
  return sub_18BC3EFC8((uint64_t (*)(void))sub_18BC3F088, __s, a2);
}

uint64_t sub_18BC3EFC8(uint64_t (*a1)(void), char *__s, int a3)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;

  if (a3 < 0)
    a3 = strlen(__s);
  if (a3 < 1)
    return 0;
  v4 = 0;
  v5 = 0;
  v6 = a3;
  do
  {
    if (__s[v4] == 45)
    {
      if (!v5 || !((unsigned int (*)(char *, _QWORD))a1)(v5, ((_DWORD)__s + v4 - (_DWORD)v5)))
        return 0;
      v5 = 0;
    }
    else if (!v5)
    {
      v5 = &__s[v4];
    }
    ++v4;
  }
  while (v4 < v6);
  if (v5)
    return a1();
  else
    return 0;
}

uint64_t sub_18BC3F088(char *__s, int a2)
{
  int v2;
  uint64_t v5;

  v2 = a2;
  if (a2 < 0)
    v2 = strlen(__s);
  if (sub_18BC3F290(__s, v2, 5))
    return 1;
  if (v2 == 4 && *__s - 48 <= 9)
  {
    v5 = 1;
    while (uprv_isASCIILetter(__s[v5]) || __s[v5] - 48 <= 9)
    {
      if (++v5 == 4)
        return 1;
    }
  }
  return 0;
}

BOOL sub_18BC3F120(char *__s, int a2)
{
  char *v3;
  uint64_t v4;
  char *v5;

  if (a2 < 0)
    a2 = strlen(__s);
  if (a2 < 1)
    return 0;
  v3 = 0;
  v4 = a2;
  v5 = __s;
  do
  {
    while (*v5 == 45)
    {
      if (v3)
      {
        if (sub_18BC3F290(v3, (_DWORD)v5 - (_DWORD)v3, 2))
        {
          v3 = 0;
          if (++v5 - __s < v4)
            continue;
        }
      }
      return 0;
    }
    if (!v3)
      v3 = v5;
    ++v5;
  }
  while (v5 - __s < v4);
  return sub_18BC3F290(v3, (_DWORD)v5 - (_DWORD)v3, 2);
}

BOOL sub_18BC3F1D4(char *__s, int a2)
{
  char *v3;
  uint64_t v4;
  char *v5;

  if (a2 < 0)
    a2 = strlen(__s);
  if (a2 < 1)
    return 0;
  v3 = 0;
  v4 = a2;
  v5 = __s;
  do
  {
    while (*v5 == 45)
    {
      if (v3)
      {
        if (sub_18BC3F290(v3, (_DWORD)v5 - (_DWORD)v3, 1))
        {
          v3 = 0;
          if (++v5 - __s < v4)
            continue;
        }
      }
      return 0;
    }
    if (!v3)
      v3 = v5;
    ++v5;
  }
  while (v5 - __s < v4);
  return sub_18BC3F290(v3, (_DWORD)v5 - (_DWORD)v3, 1);
}

BOOL sub_18BC3F288(char *a1, int a2)
{
  return sub_18BC3F290(a1, a2, 3);
}

BOOL sub_18BC3F290(char *__s, int a2, int a3)
{
  if (a2 < 0)
    a2 = strlen(__s);
  return a2 >= a3 && a2 <= 8 && sub_18BC41AE4(__s, a2);
}

BOOL sub_18BC3F2E8(char *__s, int a2)
{
  char *v3;
  uint64_t v4;
  char *v5;

  if (a2 < 0)
    a2 = strlen(__s);
  if (a2 < 1)
    return 0;
  v3 = 0;
  v4 = a2;
  v5 = __s;
  do
  {
    while (*v5 == 45)
    {
      if (v3)
      {
        if (sub_18BC3F290(v3, (_DWORD)v5 - (_DWORD)v3, 3))
        {
          v3 = 0;
          if (++v5 - __s < v4)
            continue;
        }
      }
      return 0;
    }
    if (!v3)
      v3 = v5;
    ++v5;
  }
  while (v5 - __s < v4);
  return sub_18BC3F290(v3, (_DWORD)v5 - (_DWORD)v3, 3);
}

BOOL sub_18BC3F39C(char *__s, int a2)
{
  if (a2 < 0)
    a2 = strlen(__s);
  return a2 == 2
      && (uprv_isASCIILetter(*__s) || *__s - 48 <= 9)
      && uprv_isASCIILetter(__s[1]);
}

char *ultag_getTKeyStart(char *a1)
{
  char *v1;
  char *v2;
  char *v3;

  v1 = a1;
  v2 = strchr(a1, 45);
  if (v2)
  {
    v3 = v2;
    while (!sub_18BC3F470(v1, (_DWORD)v3 - (_DWORD)v1))
    {
      v1 = v3 + 1;
      v3 = strchr(v3 + 1, 45);
      if (!v3)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    if (!sub_18BC3F470(v1, -1))
      return 0;
  }
  return v1;
}

BOOL sub_18BC3F470(char *__s, int a2)
{
  if (a2 < 0)
    a2 = strlen(__s);
  return a2 == 2 && uprv_isASCIILetter(*__s) && __s[1] - 48 < 0xA;
}

uint64_t sub_18BC3F4CC(char *__s, int a2)
{
  return sub_18BC3F4E0((uint64_t (*)(int *, char *, uint64_t))sub_18BC3F59C, __s, a2);
}

uint64_t sub_18BC3F4E0(uint64_t (*a1)(int *, char *, uint64_t), char *__s, int a3)
{
  int v3;
  char *v4;
  uint64_t v6;
  char *v7;
  int v8;
  uint64_t result;
  BOOL v10;
  int v11;

  v3 = a3;
  v4 = __s;
  v11 = 0;
  if (a3 < 0)
    v3 = strlen(__s);
  if (v3 < 1)
  {
    v6 = 0;
  }
  else
  {
    v6 = 0;
    v7 = v4 + 1;
    v8 = v3 + 1;
    do
    {
      if (*(v7 - 1) == 45)
      {
        result = a1(&v11, v4, v6);
        v6 = 0;
        v4 = v7;
        if (!(_DWORD)result)
          return result;
      }
      else
      {
        v6 = (v6 + 1);
      }
      ++v7;
      --v8;
    }
    while (v8 > 1);
  }
  if (a1(&v11, v4, v6))
    v10 = v11 < 0;
  else
    v10 = 1;
  return !v10;
}

BOOL sub_18BC3F59C(int *a1, char *__s, unsigned int a3)
{
  unsigned int v3;
  _BOOL8 result;
  int v7;

  v3 = a3;
  if ((a3 & 0x80000000) != 0)
    v3 = strlen(__s);
  result = 0;
  switch(*a1)
  {
    case -1:
      result = sub_18BC3F290(__s, v3, 3);
      if ((_DWORD)result)
      {
        v7 = 6;
        goto LABEL_19;
      }
      return result;
    case 0:
      if (!sub_18BC3EE74(__s, v3) || v3 == 4)
        goto LABEL_11;
      result = 1;
      *a1 = 1;
      return result;
    case 1:
      if (!sub_18BC3EED0(__s, v3))
        goto LABEL_15;
      v7 = 2;
      goto LABEL_19;
    case 2:
LABEL_15:
      if (!sub_18BC3EF2C(__s, v3))
        goto LABEL_4;
      v7 = 3;
      goto LABEL_19;
    case 3:
    case 4:
LABEL_4:
      if (sub_18BC3F088(__s, v3))
      {
        v7 = 4;
      }
      else
      {
LABEL_11:
        result = sub_18BC3F470(__s, v3);
        if (!(_DWORD)result)
          return result;
LABEL_18:
        v7 = -1;
      }
LABEL_19:
      *a1 = v7;
      return 1;
    case 6:
      if (sub_18BC3F470(__s, v3))
        goto LABEL_18;
      return sub_18BC3F290(__s, v3, 3);
    default:
      return result;
  }
}

uint64_t sub_18BC3F6D8(char *__s, int a2)
{
  return sub_18BC3F4E0((uint64_t (*)(int *, char *, uint64_t))sub_18BC3F6EC, __s, a2);
}

BOOL sub_18BC3F6EC(int *a1, char *__s, int a3)
{
  int v6;
  _BOOL8 result;

  v6 = *a1;
  if (*a1 == 2)
    goto LABEL_15;
  if (v6 == 1)
  {
    if (!sub_18BC3F39C(__s, a3))
    {
      result = sub_18BC3F290(__s, a3, 3);
      if (!(_DWORD)result)
        return result;
      *a1 = 2;
    }
    return 1;
  }
  if (v6)
    return 0;
LABEL_15:
  if (!sub_18BC3F39C(__s, a3))
    return sub_18BC3F290(__s, a3, 3);
  result = 1;
  *a1 = 1;
  return result;
}

uint64_t uloc_toLanguageTag(char *a1, char *a2, int a3, int a4, int *a5)
{
  uint64_t v5;
  __int128 v12;
  __int128 v13;

  if (*a5 > 0)
    return 0;
  v12 = 0u;
  v13 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v12, a2, a3);
  ulocimp_toLanguageTag(a1, (uint64_t)&v12, a4, a5);
  v5 = DWORD2(v13);
  if (*a5 <= 0)
  {
    if (BYTE12(v13))
      *a5 = 15;
    else
      u_terminateChars((uint64_t)a2, a3, DWORD2(v13), a5);
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v12);
  return v5;
}

void ulocimp_toLanguageTag(char *a1, uint64_t a2, int a3, int *a4)
{
  char *KeywordsStart;
  void **v9;
  void **v10;
  char *v11;
  char *v12;
  int v13;
  int v14;
  char v15;
  int v16;
  int Variant;
  int v18;
  char *v19;
  char *v20;
  int v21;
  char v22;
  unsigned __int8 *v23;
  int v24;
  _QWORD *v25;
  void *v26;
  const char **v27;
  const char **v28;
  size_t v29;
  UErrorCode *Language;
  size_t v31;
  size_t v32;
  const char *v33;
  unint64_t v34;
  uint64_t Country;
  size_t v36;
  const char *v37;
  unint64_t v38;
  int v39;
  int v40;
  uint64_t Script;
  uint64_t v42;
  const char **v43;
  char *v44;
  void **v45;
  void **v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  int v50;
  int v51;
  int v52;
  int v53;
  char *v54;
  unsigned __int8 **v55;
  unsigned __int8 **v56;
  int v57;
  int v58;
  int v59;
  int v60;
  unint64_t v61;
  char *v62;
  _QWORD *v63;
  _QWORD *v64;
  _QWORD *v65;
  int v66;
  char **v67;
  int v68;
  int v69;
  _QWORD *v70;
  int v71;
  _QWORD *v72;
  const char **v73;
  int v74;
  const char **v75;
  const char *v76;
  size_t v77;
  const char *v78;
  size_t v79;
  const char **v80;
  size_t v81;
  int v82;
  char *v83;
  char *v84;
  int v85;
  int v86;
  char v87;
  unsigned __int8 *v88;
  int v89;
  size_t v90;
  char *v91;
  char v92;
  char *v93;
  int v94;
  int v95;
  const char *v96[2];
  int v97;
  _QWORD v98[11];
  const char **v99;
  const char **v100;
  int v101;
  _QWORD v102[12];
  const void *v103[12];
  const char **v104;
  _DWORD *v105;
  _DWORD v106[16];
  uint64_t v107;
  int v108;
  void *v109[7];
  int v110;
  int v111;
  void *v112[7];
  uint64_t v113;
  char __s[64];
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  _BYTE v119[29];
  uint64_t v120;

  v120 = *MEMORY[0x1E0C80C00];
  memset(&v109[1], 0, 48);
  v111 = 0;
  v109[0] = (char *)&v109[1] + 5;
  LODWORD(v109[1]) = 40;
  v110 = 0;
  v95 = 0;
  *(_QWORD *)__s = 0;
  *(_QWORD *)&__s[8] = 0;
  icu::CharStringByteSink::CharStringByteSink(__s, (uint64_t)v109);
  ulocimp_canonicalize(a1);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)__s);
  KeywordsStart = locale_getKeywordsStart((char *)v109[0]);
  if (KeywordsStart == v109[0])
  {
    v9 = (void **)uloc_openKeywords(KeywordsStart, &v95);
    v10 = v9;
    if (v95 > 0
      || uenum_count((uint64_t)v9, &v95) != 1
      || (LODWORD(v103[0]) = 0, v11 = (char *)uenum_next((uint64_t)v10, (uint64_t)v103, &v95), LODWORD(v103[0]) != 1)
      || (v12 = v11, *v11 != 120))
    {
LABEL_16:
      if (v10)
        uenum_close(v10);
      goto LABEL_18;
    }
    memset(&__s[8], 0, 56);
    *(_QWORD *)__s = &__s[13];
    *(_DWORD *)&__s[8] = 40;
    v104 = 0;
    v105 = 0;
    icu::CharStringByteSink::CharStringByteSink(&v104, (uint64_t)__s);
    ulocimp_getKeywordValue(a1, v12, (uint64_t)&v104, &v95);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&v104);
    if (v95 > 0)
    {
      v13 = 0;
      *a4 = 1;
      goto LABEL_13;
    }
    if (sub_18BC3F1D4(*(char **)__s, *(int *)&__s[56]))
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "und-x-", 6);
      (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)__s, *(unsigned int *)&__s[56]);
    }
    else
    {
      v13 = 1;
      if (!a3)
        goto LABEL_13;
      *a4 = 1;
    }
    v13 = 0;
LABEL_13:
    if (__s[12])
      uprv_free(*(void **)__s);
    if (!v13)
    {
      if (v10)
        uenum_close(v10);
      goto LABEL_204;
    }
    goto LABEL_16;
  }
LABEL_18:
  LODWORD(v104) = 0;
  v94 = a3;
  if (*a4 > 0)
    goto LABEL_19;
  *(_DWORD *)&__s[8] = 0;
  *(_QWORD *)__s = 0;
  Language = uloc_getLanguage((uint64_t)v109[0], __s, 12, (int *)&v104);
  if ((int)v104 > 0 || (_DWORD)v104 == -124)
    goto LABEL_73;
  v31 = (size_t)Language;
  if (!(_DWORD)Language)
  {
LABEL_79:
    (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "und", 3);
    goto LABEL_86;
  }
  if (!sub_18BC3EE74(__s, Language))
  {
LABEL_73:
    if (a3)
    {
      *a4 = 1;
      goto LABEL_19;
    }
    goto LABEL_79;
  }
  v32 = strlen(__s);
  v33 = (const char *)&unk_18BE14E68;
  v34 = -2;
  while (v32 >= strlen(v33))
  {
    if (!strcmp(__s, v33))
    {
      strcpy(__s, v33 + 4);
      v31 = strlen(__s);
      break;
    }
    v33 += 8;
    v34 += 2;
    if (v34 >= 0x9A)
      break;
  }
  (*(void (**)(uint64_t, char *, size_t))(*(_QWORD *)a2 + 16))(a2, __s, v31);
LABEL_86:
  v40 = *a4;
  LODWORD(v104) = 0;
  if (v40 <= 0)
  {
    *(_WORD *)&__s[4] = 0;
    *(_DWORD *)__s = 0;
    Script = uloc_getScript((uint64_t)v109[0], __s, 6, (int *)&v104);
    if ((int)v104 <= 0 && (_DWORD)v104 != -124)
    {
      v42 = Script;
      if ((int)Script < 1)
        goto LABEL_19;
      if (sub_18BC3EED0(__s, Script))
      {
        (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "-", 1);
        (*(void (**)(uint64_t, char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, __s, v42);
        goto LABEL_19;
      }
    }
    if (a3)
    {
      *a4 = 1;
      goto LABEL_20;
    }
  }
LABEL_19:
  v14 = *a4;
  LODWORD(v104) = 0;
  if (v14 > 0)
    goto LABEL_20;
  *(_DWORD *)__s = 0;
  Country = uloc_getCountry((uint64_t)v109[0], __s, 4, (int *)&v104);
  if ((int)v104 > 0 || (_DWORD)v104 == -124)
    goto LABEL_75;
  v36 = Country;
  if ((int)Country < 1)
    goto LABEL_20;
  if (!sub_18BC3EF2C(__s, Country))
  {
LABEL_75:
    if (a3)
      goto LABEL_78;
  }
  else
  {
    (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "-", 1);
    v37 = (const char *)&unk_18BE150D8;
    v38 = -2;
    while (strcmp(__s, v37))
    {
      v37 += 6;
      v38 += 2;
      if (v38 >= 0xA)
        goto LABEL_82;
    }
    strcpy(__s, v37 + 3);
    v36 = strlen(__s);
LABEL_82:
    (*(void (**)(uint64_t, char *, size_t))(*(_QWORD *)a2 + 16))(a2, __s, v36);
  }
LABEL_20:
  v15 = 0;
  v16 = *a4;
  LODWORD(v103[0]) = 0;
  if (v16 > 0)
    goto LABEL_101;
  v118 = 0u;
  memset(v119, 0, sizeof(v119));
  v116 = 0u;
  v117 = 0u;
  v115 = 0u;
  memset(__s, 0, sizeof(__s));
  Variant = uloc_getVariant((char *)v109[0], __s, 157, (int *)v103);
  if (SLODWORD(v103[0]) > 0 || LODWORD(v103[0]) == -124)
  {
    if (!a3)
      goto LABEL_80;
LABEL_78:
    v15 = 0;
    *a4 = 1;
    goto LABEL_101;
  }
  v18 = Variant;
  if (Variant < 1)
  {
LABEL_80:
    v15 = 0;
    goto LABEL_101;
  }
  v92 = 0;
  v19 = 0;
  v104 = 0;
  v20 = __s;
  while (1)
  {
    v21 = *v20;
    if (*v20)
    {
      if (v21 != 95 && v21 != 45)
      {
        if (!v19)
          v19 = v20;
        v21 = 1;
        goto LABEL_50;
      }
      *v20 = 0;
      v21 = 1;
    }
    if (!v19)
      goto LABEL_48;
    v22 = *v19;
    if (*v19)
    {
      v23 = (unsigned __int8 *)(v19 + 1);
      do
      {
        *(v23 - 1) = uprv_asciitolower(v22);
        v24 = *v23++;
        v22 = v24;
      }
      while (v24);
    }
    if (!sub_18BC3F088(v19, -1))
      break;
    if (!strcmp(v19, "posix") && v18 == 5)
    {
      v19 = 0;
      v92 = 1;
    }
    else
    {
      v25 = uprv_malloc(0x10uLL);
      if (!v25)
      {
        v39 = 7;
        goto LABEL_97;
      }
      v26 = v25;
      *v25 = v19;
      if (!sub_18BC41B48(&v104, (uint64_t)v25))
      {
        uprv_free(v26);
        a3 = v94;
LABEL_48:
        if (!a3)
        {
LABEL_49:
          v19 = 0;
          goto LABEL_50;
        }
LABEL_83:
        v39 = 1;
LABEL_97:
        *a4 = v39;
        v27 = v104;
        goto LABEL_98;
      }
      v19 = 0;
    }
    a3 = v94;
LABEL_50:
    ++v20;
    if (!v21)
      goto LABEL_51;
  }
  a3 = v94;
  if (v94)
    goto LABEL_83;
  if (!sub_18BC3F290(v19, -1, 1))
    goto LABEL_49;
LABEL_51:
  v27 = v104;
  if (*a4 <= 0 && v104)
  {
    sub_18BC41A74((uint64_t)v104);
    v28 = v27;
    do
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "-", 1);
      v29 = strlen(*v28);
      (*(void (**)(uint64_t, const char *, size_t))(*(_QWORD *)a2 + 16))(a2, *v28, v29);
      v28 = (const char **)v28[1];
    }
    while (v28);
  }
LABEL_98:
  if (v27)
  {
    do
    {
      v43 = (const char **)v27[1];
      uprv_free(v27);
      v27 = v43;
    }
    while (v43);
  }
  v15 = v92;
LABEL_101:
  v44 = (char *)v109[0];
  LODWORD(v117) = 0;
  v115 = 0u;
  v116 = 0u;
  memset(__s, 0, sizeof(__s));
  v108 = 0;
  v104 = 0;
  memset(v106, 0, sizeof(v106));
  v107 = 0;
  v105 = &v106[2];
  v106[0] = 8;
  v103[0] = 0;
  memset(&v103[2], 0, 72);
  v103[1] = &v103[3];
  LODWORD(v103[2]) = 8;
  v102[0] = 0;
  memset(&v102[2], 0, 72);
  v102[1] = &v102[3];
  LODWORD(v102[2]) = 8;
  v45 = (void **)uloc_openKeywords((char *)v109[0], a4);
  v46 = v45;
  if (!v15 && *a4 > 0 || !(v15 | (v45 != 0)))
    goto LABEL_201;
  v101 = 0;
  v99 = 0;
  v100 = 0;
  v98[0] = 0;
  memset(&v98[2], 0, 72);
  v98[1] = &v98[3];
  LODWORD(v98[2]) = 8;
  v97 = 0;
  v47 = uenum_next((uint64_t)v45, 0, a4);
  if (!v47)
    goto LABEL_179;
  v49 = (char *)v47;
  v91 = 0;
  v93 = 0;
  while (2)
  {
    v113 = 0;
    memset(&v112[1], 0, 48);
    v112[0] = (char *)&v112[1] + 5;
    LODWORD(v112[1]) = 40;
    v96[0] = 0;
    v96[1] = 0;
    icu::CharStringByteSink::CharStringByteSink(v96, (uint64_t)v112);
    ulocimp_getKeywordValue(v44, v49, (uint64_t)v96, &v97);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v96);
    v50 = v113;
    v101 = v113;
    v51 = v97;
    if (v97 >= 1)
    {
      if (v97 != 7)
      {
        if (v94)
          goto LABEL_109;
        v97 = 0;
LABEL_149:
        v52 = 2;
        goto LABEL_111;
      }
LABEL_110:
      *a4 = v51;
      v52 = 3;
      goto LABEL_111;
    }
    v53 = strlen(v49);
    if (strcmp(v49, "attribute"))
    {
      if (v53 >= 2)
      {
        v93 = uloc_toUnicodeLocaleKey((uint64_t)v49);
        if (v93)
        {
          v54 = uloc_toUnicodeLocaleType((uint64_t)v49, (char *)v112[0]);
          if (v54)
          {
            v91 = v54;
            if (v54 != v112[0])
              goto LABEL_172;
            v55 = (unsigned __int8 **)sub_18BC41D78((int *)v98, (unint64_t)v112, (UErrorCode *)&v97);
            if (!v55)
              goto LABEL_176;
            v51 = v97;
            if (v97 >= 1)
              goto LABEL_110;
            v56 = v55;
            T_CString_toLowerCase(*v55);
            v91 = (char *)*v56;
LABEL_172:
            v70 = sub_18BC42020(v103, v48);
            if (!v70)
            {
LABEL_176:
              v51 = 7;
              goto LABEL_110;
            }
            *v70 = v93;
            v70[1] = v91;
            v71 = sub_18BC420F8(&v100, (uint64_t)v70, 1);
            v52 = 0;
            if (!v94 || v71)
              goto LABEL_111;
          }
          else
          {
            if (!v94)
            {
              v91 = 0;
              goto LABEL_149;
            }
            v91 = 0;
          }
        }
        else
        {
          if (!v94)
          {
            v93 = 0;
            goto LABEL_149;
          }
          v93 = 0;
        }
LABEL_109:
        v51 = 1;
        goto LABEL_110;
      }
      if (*v49 == 120)
      {
        if (!sub_18BC3F1D4((char *)v112[0], v50))
          goto LABEL_158;
      }
      else if (!sub_18BC41E8C(v49, v53) || !sub_18BC3F120((char *)v112[0], v101))
      {
LABEL_158:
        if (!v94)
          goto LABEL_149;
        goto LABEL_109;
      }
      v96[0] = (const char *)v112[0];
      v67 = (char **)sub_18BC41EFC((int *)v98, v96, &v101, (UErrorCode *)&v97);
      if (v67)
      {
        v68 = v97;
        if (v97 < 1)
        {
          v91 = *v67;
          v93 = v49;
          goto LABEL_172;
        }
      }
      else
      {
        v68 = 7;
      }
      *a4 = v68;
      v52 = 3;
      v93 = v49;
      goto LABEL_111;
    }
    if (v50 < 1)
      goto LABEL_172;
    v57 = 0;
    while (2)
    {
      v108 = 0;
      v58 = v101;
      if (v57 >= v101)
        goto LABEL_140;
      v59 = v57;
      v60 = *((unsigned __int8 *)v112[0] + v57);
      if (v60 == 45)
      {
        v61 = 0;
LABEL_135:
        v57 = v59 + 1;
LABEL_137:
        if ((int)v61 >= 1)
        {
          if (v61 > 0x63)
            *a4 = -124;
          else
            __s[v61] = 0;
LABEL_141:
          v63 = sub_18BC3EB74((const void **)&v104, v48);
          if (!v63 || (v64 = v63, (v65 = (_QWORD *)sub_18BC41BAC((int *)v102, __s, &v108, (UErrorCode *)a4)) == 0))
          {
            v91 = 0;
            v69 = 7;
LABEL_170:
            *a4 = v69;
LABEL_171:
            v93 = "attribute";
            goto LABEL_172;
          }
          if (*a4 > 0)
          {
LABEL_168:
            v91 = 0;
            goto LABEL_171;
          }
          *v64 = *v65;
          v66 = sub_18BC41CCC(&v99, (uint64_t)v64);
          if (v94 && !v66)
          {
            v91 = 0;
            v69 = 1;
            goto LABEL_170;
          }
          continue;
        }
LABEL_140:
        if (v57 >= v58)
          goto LABEL_168;
        goto LABEL_141;
      }
      break;
    }
    v61 = 0;
    v62 = (char *)v112[0] + v57 + 1;
    while (v61 != 100)
    {
      v108 = v61 + 1;
      __s[v61] = v60;
      if (!(v57 - (uint64_t)v58 + 1 + v61))
      {
        v61 = (v61 + 1);
        v57 = v58;
        goto LABEL_137;
      }
      v60 = v62[v61++];
      if (v60 == 45)
      {
        v59 = v57 + v61;
        v61 = v61;
        goto LABEL_135;
      }
    }
    v52 = 1;
    *a4 = 1;
LABEL_111:
    if (BYTE4(v112[1]))
      uprv_free(v112[0]);
    if (v52 && v52 != 2)
    {
      if (v52 == 3)
        break;
      goto LABEL_200;
    }
    v49 = (char *)uenum_next((uint64_t)v46, 0, a4);
    if (v49)
      continue;
    break;
  }
LABEL_179:
  if (!v15)
  {
LABEL_182:
    if (*a4 > 0)
      goto LABEL_200;
    v73 = v100;
    if (!v100)
      goto LABEL_200;
    v74 = 0;
    v75 = v99;
    while (1)
    {
      v76 = *v73;
      if (!v74)
      {
        if (strlen(*v73) < 2)
        {
          v74 = 0;
          goto LABEL_189;
        }
        (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "-u", 2);
        v76 = *v73;
      }
      v74 = 1;
LABEL_189:
      if (!strcmp(v76, "attribute"))
      {
        if (v75)
        {
          v80 = v75;
          do
          {
            (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "-", 1);
            v81 = strlen(*v80);
            (*(void (**)(uint64_t, const char *, size_t))(*(_QWORD *)a2 + 16))(a2, *v80, v81);
            v80 = (const char **)v80[1];
          }
          while (v80);
        }
      }
      else
      {
        (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "-", 1);
        v77 = strlen(*v73);
        (*(void (**)(uint64_t, const char *, size_t))(*(_QWORD *)a2 + 16))(a2, *v73, v77);
        v78 = v73[1];
        if (strcmp(v78, "true") && strcmp(v78, "yes"))
        {
          (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "-", 1);
          v79 = strlen(v73[1]);
          (*(void (**)(uint64_t, const char *, size_t))(*(_QWORD *)a2 + 16))(a2, v73[1], v79);
        }
      }
      v73 = (const char **)v73[2];
      if (!v73)
        goto LABEL_200;
    }
  }
  v72 = sub_18BC42020(v103, v48);
  if (v72)
  {
    *v72 = "va";
    v72[1] = "posix";
    sub_18BC420F8(&v100, (uint64_t)v72, 1);
    goto LABEL_182;
  }
  *a4 = 7;
LABEL_200:
  sub_18BC3EDF8((uint64_t)v98);
LABEL_201:
  if (v46)
    uenum_close(v46);
  sub_18BC3EDF8((uint64_t)v102);
  sub_18BC3ED98((uint64_t)v103);
  sub_18BC3ED98((uint64_t)&v104);
  LODWORD(v104) = 0;
  if (*a4 <= 0)
  {
    v118 = 0u;
    memset(v119, 0, sizeof(v119));
    v116 = 0u;
    v117 = 0u;
    v115 = 0u;
    memset(__s, 0, sizeof(__s));
    v82 = uloc_getVariant((char *)v109[0], __s, 157, (int *)&v104);
    if ((int)v104 > 0 || (_DWORD)v104 == -124)
    {
LABEL_230:
      if (v94)
        *a4 = 1;
      goto LABEL_204;
    }
    if (v82 < 1)
      goto LABEL_204;
    v83 = 0;
    v84 = __s;
    v85 = 1;
    do
    {
      v86 = *v84;
      if (*v84)
      {
        if (v86 != 95 && v86 != 45)
        {
          if (!v83)
            v83 = v84;
          v86 = 1;
          goto LABEL_228;
        }
        *v84 = 0;
        v86 = 1;
      }
      if (v83)
      {
        v87 = *v83;
        if (*v83)
        {
          v88 = (unsigned __int8 *)(v83 + 1);
          do
          {
            *(v88 - 1) = uprv_asciitolower(v87);
            v89 = *v88++;
            v87 = v89;
          }
          while (v89);
        }
        if (!sub_18BC3F290(v83, -1, 1))
          goto LABEL_230;
        if (!v85)
          goto LABEL_227;
        if (!sub_18BC3F088(v83, -1))
        {
          (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "-", 1);
          (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "x", 1);
          (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "-", 1);
          (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "lvariant", 8);
LABEL_227:
          (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(a2, "-", 1);
          v90 = strlen(v83);
          (*(void (**)(uint64_t, char *, size_t))(*(_QWORD *)a2 + 16))(a2, v83, v90);
          v83 = 0;
          v85 = 0;
          goto LABEL_228;
        }
        v83 = 0;
      }
LABEL_228:
      ++v84;
    }
    while (v86);
  }
LABEL_204:
  if (BYTE4(v109[1]))
    uprv_free(v109[0]);
}

uint64_t uloc_forLanguageTag(char *a1, char *a2, int a3, _DWORD *a4, int *a5)
{
  uint64_t v5;
  __int128 v12;
  __int128 v13;

  if (*a5 > 0)
    return 0;
  v12 = 0u;
  v13 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v12, a2, a3);
  ulocimp_forLanguageTag(a1, -1, (uint64_t)&v12, a4, a5);
  v5 = DWORD2(v13);
  if (*a5 <= 0)
  {
    if (BYTE12(v13))
      *a5 = 15;
    else
      u_terminateChars((uint64_t)a2, a3, DWORD2(v13), a5);
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v12);
  return v5;
}

uint64_t *ulocimp_forLanguageTag(char *__s, int a2, uint64_t a3, _DWORD *a4, int *a5)
{
  int v8;
  char *v11;
  char *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  BOOL v19;
  unint64_t v20;
  size_t v21;
  int v22;
  BOOL v23;
  int *v24;
  size_t v25;
  char *v26;
  const char *v27;
  int v28;
  int v29;
  char *v30;
  int v31;
  __int16 v32;
  unsigned __int8 *v33;
  size_t i;
  int v35;
  unsigned __int8 *v36;
  unsigned __int8 *v37;
  int v38;
  uint64_t v39;
  signed __int8 v40;
  unsigned __int8 *v41;
  int v42;
  unsigned __int8 *v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  unsigned __int8 *v47;
  int v48;
  char *v49;
  char *v50;
  uint64_t j;
  char *v52;
  _BOOL4 v53;
  _QWORD *v54;
  void *v55;
  _DWORD *v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  const char *v61;
  int v62;
  const char *v63;
  int v64;
  uint64_t v65;
  const char *v66;
  int v67;
  unsigned __int8 *v68;
  const char **v70;
  uint64_t v71;
  int v72;
  int v73;
  int v74;
  uint64_t v75;
  int v76;
  _BYTE *v77;
  unsigned __int8 *v78;
  UErrorCode v80;
  uint64_t v81;
  int v82;
  int v83;
  int v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  _BYTE *v88;
  int v89;
  char *v90;
  uint64_t v91;
  int v92;
  int v93;
  size_t k;
  char *v95;
  unint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  const char **v99;
  uint64_t v100;
  _QWORD *v101;
  unint64_t v102;
  _QWORD *v103;
  icu::CharString *v104;
  icu::CharString *v105;
  const char **v106;
  const char **v107;
  const char *v108;
  const char *v109;
  BOOL v110;
  int v111;
  int v112;
  uint64_t v113;
  char *v114;
  int v115;
  char *v116;
  uint64_t v117;
  char *v118;
  const char *v119;
  const char **v120;
  uint64_t v121;
  char *v122;
  const char *v123;
  const char **v124;
  _QWORD *v125;
  int v126;
  _QWORD *v127;
  const char **v128;
  int v129;
  int v130;
  int v131;
  const char *v132;
  unint64_t v133;
  _QWORD *v134;
  const char **v135;
  const char *v136;
  size_t v137;
  size_t v138;
  int v139;
  int v140;
  int v141;
  int v142;
  _DWORD *v143;
  uint64_t v144;
  const char *v145;
  int v146;
  uint64_t v147;
  int v148;
  unsigned __int8 *v149;
  unsigned __int8 *v150;
  int v151;
  _QWORD *v152;
  int v153;
  UErrorCode *v154;
  uint64_t v155;
  const void *v156[12];
  const void *v157[12];
  const char **v158;
  char __dst[2];
  char v160;
  char *v161;
  int v162;
  size_t __n[12];
  const char **v164;
  const char **v165;
  char v166[16];
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  uint64_t v174;

  v8 = a2;
  v174 = *MEMORY[0x1E0C80C00];
  if (a4)
    *a4 = 0;
  v155 = 0;
  if (*a5 > 0)
    goto LABEL_4;
  if (a2 < 0)
    v8 = strlen(__s);
  v11 = (char *)uprv_malloc(v8 + 1);
  if (!v11)
  {
    *a5 = 7;
LABEL_4:
    v155 = 0;
    return sub_18BC4227C(&v155);
  }
  v12 = v11;
  v154 = (UErrorCode *)a5;
  if (v8 >= 1)
    memcpy(v11, __s, v8);
  v12[v8] = 0;
  v13 = uprv_malloc(0x58uLL);
  v14 = (uint64_t)v13;
  *(_QWORD *)v166 = v13;
  if (!v13)
  {
    uprv_free(v12);
LABEL_32:
    v24 = (int *)v154;
    *v154 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_149;
  }
  v13[2] = 0;
  v13[3] = 0;
  v13[4] = 0;
  v13[5] = &unk_18BE1511E;
  v13[6] = &unk_18BE1511E;
  v13[7] = 0;
  v13[9] = &unk_18BE1511E;
  v13[10] = &unk_18BE1511E;
  v13[8] = 0;
  *v13 = v12;
  v13[1] = &unk_18BE1511E;
  if (v8 < 2)
    goto LABEL_148;
  v143 = a4;
  v15 = 0;
  while (1)
  {
    v16 = strlen(off_1E22562C8[v15]);
    v17 = v16;
    v18 = v8 - v16;
    if (v8 >= v16 && (v8 <= v16 || v12[v16] == 45) && !uprv_strnicmp(off_1E22562C8[v15], v12, v16))
      break;
    v19 = v15 >= 0x30;
    v15 += 2;
    if (v19)
    {
      v141 = 0;
LABEL_21:
      v20 = 0;
      while (1)
      {
        v21 = strlen(off_1E2256458[v20]);
        if (!uprv_strnicmp(off_1E2256458[v20], v12, v21))
        {
          v22 = v12[v21];
          v23 = v22 == 45 || v22 == 0;
          if (v23)
            break;
        }
        v19 = v20 >= 0x32;
        v20 += 2;
        if (v19)
          goto LABEL_44;
      }
      v25 = strlen(off_1E2256458[v20 + 1]);
      memcpy(*(void **)v14, off_1E2256458[v20 + 1], v25);
      v26 = &v12[v25];
      if (v12[v21] == 45)
        memmove(v26, &v12[v21], v8 - v21 + 1);
      else
        *v26 = 0;
      v141 = v21 - v25;
      goto LABEL_45;
    }
  }
  v27 = off_1E22562C8[v15 + 1];
  v28 = strlen(v27);
  v29 = v18 + v28;
  if (v8 >= v18 + v28)
  {
    v30 = *(char **)v14;
  }
  else
  {
    uprv_free(v12);
    v30 = (char *)uprv_malloc(v29 + 1);
    *(_QWORD *)v14 = v30;
    v12 = v30;
    v8 = v18 + v28;
    if (!v30)
    {
LABEL_37:
      v14 = 0;
      goto LABEL_32;
    }
  }
  v141 = v17 - v28;
  strcpy(v30, v27);
  v31 = v17;
  if (v8 != v17)
  {
    memcpy((void *)(*(_QWORD *)v14 + v28), &__s[v17], v18);
    *(_BYTE *)(*(_QWORD *)v14 + v29) = 0;
    v31 = v8;
  }
  v8 = v31;
  if (!v17)
    goto LABEL_21;
LABEL_44:
  if (!v12)
    goto LABEL_145;
LABEL_45:
  v140 = 0;
  v149 = 0;
  v150 = 0;
  v152 = 0;
  v146 = 0;
  v32 = 129;
  v33 = (unsigned __int8 *)v12;
  while (1)
  {
    for (i = 0; ; ++i)
    {
      v35 = v33[i];
      if (!v33[i] || v35 == 45)
        break;
    }
    v36 = &v33[i];
    if (v33[i])
      v37 = v36 + 1;
    else
      v37 = 0;
    if ((v32 & 1) != 0 && sub_18BC3EE74((char *)v33, i))
    {
      v33[i] = 0;
      *(_QWORD *)(*(_QWORD *)v166 + 8) = T_CString_toLowerCase(v33);
      if ((int)i >= 4)
        v32 = 188;
      else
        v32 = 190;
      goto LABEL_91;
    }
    if ((v32 & 2) != 0)
    {
      v38 = (i & 0x80000000) != 0 ? strlen((const char *)v33) : i;
      if (v38 == 3)
      {
        v39 = 0;
        while (uprv_isASCIILetter(v33[v39]))
        {
          if (++v39 == 3)
          {
            *v36 = 0;
            *(_QWORD *)(*(_QWORD *)v166 + 8 * v146 + 16) = T_CString_toLowerCase(v33);
            if (v146 >= 2)
              v32 = 188;
            else
              v32 = 190;
            v12 = (char *)&v33[i];
            ++v146;
            goto LABEL_92;
          }
        }
      }
    }
    if ((v32 & 4) != 0 && sub_18BC3EED0((char *)v33, i))
    {
      *v36 = 0;
      *v33 = uprv_toupper((char)*v33);
      v40 = v33[1];
      if (v40)
      {
        v41 = v33 + 2;
        do
        {
          *(v41 - 1) = uprv_asciitolower(v40);
          v42 = *v41++;
          v40 = v42;
        }
        while (v42);
      }
      *(_QWORD *)(*(_QWORD *)v166 + 40) = v33;
      v32 = 184;
      goto LABEL_91;
    }
    if ((v32 & 8) != 0 && sub_18BC3EF2C((char *)v33, i))
    {
      *v36 = 0;
      *(_QWORD *)(*(_QWORD *)v166 + 48) = T_CString_toUpperCase(v33);
      goto LABEL_90;
    }
    if ((v32 & 0x10) != 0 && (sub_18BC3F088((char *)v33, i) || v140 && sub_18BC3F290((char *)v33, i, 1)))
    {
      v45 = uprv_malloc(0x10uLL);
      if (!v45)
        goto LABEL_37;
      v46 = v45;
      *v36 = 0;
      *v45 = T_CString_toUpperCase(v33);
      if (!sub_18BC41B48((const char ***)(*(_QWORD *)v166 + 56), (uint64_t)v46))
      {
        uprv_free(v46);
        goto LABEL_134;
      }
LABEL_90:
      v32 = 176;
LABEL_91:
      v12 = (char *)v36;
      goto LABEL_92;
    }
    if ((v32 & 0x20) == 0 || !sub_18BC41E8C((char *)v33, i))
      break;
    if (v152)
    {
      v43 = v149;
      if (!v150 || !v149)
      {
        v55 = v152;
        goto LABEL_144;
      }
      *v149 = 0;
      v44 = v152;
      v152[1] = T_CString_toLowerCase(v150);
      if (!sub_18BC420F8((const char ***)(*(_QWORD *)v166 + 64), (uint64_t)v152, 0))
        goto LABEL_132;
    }
    else
    {
      v43 = (unsigned __int8 *)v12;
    }
    v54 = uprv_malloc(0x18uLL);
    if (!v54)
      goto LABEL_37;
    *v36 = 0;
    v150 = 0;
    v152 = v54;
    *v54 = T_CString_toLowerCase(v33);
    v152[1] = 0;
    v12 = (char *)v43;
    v32 = 64;
    v149 = 0;
LABEL_92:
    v33 = v37;
    if (!v37)
      goto LABEL_134;
  }
  if ((v32 & 0x40) != 0 && sub_18BC3F290((char *)v33, i, 2))
  {
    v47 = v150;
    if (!v150)
      v47 = v33;
    v149 = &v33[i];
    v150 = v47;
    v32 = 224;
    goto LABEL_92;
  }
  if ((v32 & 0x80) != 0 && (v48 = uprv_asciitolower((char)*v33), (_DWORD)i == 1) && v48 == 120)
  {
    v44 = v152;
    if (v152)
    {
      v49 = (char *)v149;
      if (!v150
        || !v149
        || (*v149 = 0,
            v152[1] = T_CString_toLowerCase(v150),
            !sub_18BC420F8((const char ***)(*(_QWORD *)v166 + 64), (uint64_t)v152, 0)))
      {
LABEL_132:
        v55 = v44;
LABEL_144:
        uprv_free(v55);
        goto LABEL_145;
      }
    }
    else
    {
      v49 = v12;
    }
    if (v35)
    {
      v50 = (char *)(v36 + 1);
      while (1)
      {
        v12 = v49;
        if (!v50)
          break;
        for (j = 0; v50[j] && v50[j] != 45; ++j)
          ;
        v49 = &v50[j];
        if (v50[j])
          v52 = v49 + 1;
        else
          v52 = 0;
        if (!strncmp(v50, "lvariant", 8uLL))
        {
          v152 = 0;
          v50[j] = 0;
          v140 = 1;
          goto LABEL_128;
        }
        v53 = sub_18BC3F290(v50, j, 1);
        v50 = v52;
        if (!v53)
          goto LABEL_125;
      }
      v52 = 0;
LABEL_125:
      if (v32 == 16)
      {
        v152 = 0;
LABEL_128:
        v32 = 16;
        v37 = (unsigned __int8 *)v52;
        goto LABEL_92;
      }
      if (v12 - (char *)v37 >= 1)
      {
        *v12 = 0;
        *(_QWORD *)(*(_QWORD *)v166 + 72) = T_CString_toLowerCase(v37);
      }
    }
    else
    {
      LODWORD(v12) = (_DWORD)v49;
    }
LABEL_145:
    v56 = v143;
  }
  else
  {
LABEL_134:
    if (!v152)
      goto LABEL_145;
    v56 = v143;
    if (v150
      && v149
      && (*v149 = 0,
          v152[1] = T_CString_toLowerCase(v150),
          sub_18BC420F8((const char ***)(*(_QWORD *)v166 + 64), (uint64_t)v152, 0)))
    {
      LODWORD(v12) = (_DWORD)v149;
    }
    else
    {
      uprv_free(v152);
    }
  }
  v14 = *(_QWORD *)v166;
  if (v56)
    *v56 = v141 + (_DWORD)v12 - **(_DWORD **)v166;
LABEL_148:
  *(_QWORD *)v166 = 0;
  v24 = (int *)v154;
LABEL_149:
  sub_18BC4227C((uint64_t *)v166);
  v57 = *v24;
  v155 = v14;
  if (v57 > 0)
    return sub_18BC4227C(&v155);
  v58 = 0;
  v59 = 0;
  do
  {
    if (*(_QWORD *)(v14 + 16 + v58))
      ++v59;
    v58 += 8;
  }
  while (v58 != 24);
  v23 = v59 == 0;
  v60 = 16;
  if (v23)
    v60 = 8;
  v61 = *(const char **)(v14 + v60);
  if (!strcmp(v61, "und") || (int)strlen(v61) < 1)
  {
    v62 = 1;
  }
  else
  {
    (*(void (**)(uint64_t, const char *))(*(_QWORD *)a3 + 16))(a3, v61);
    v62 = 0;
  }
  v63 = *(const char **)(v14 + 40);
  v64 = strlen(v63);
  v65 = (v64 - 1);
  if (v64 >= 1)
  {
    (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, "_", 1);
    v166[0] = 0;
    v166[0] = uprv_toupper(*v63);
    (*(void (**)(uint64_t, char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, v166, 1);
    (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, v63 + 1, v65);
    v62 = 0;
  }
  v66 = *(const char **)(v14 + 48);
  v67 = strlen(v66);
  if (v67 >= 1)
  {
    (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, "_", 1);
    if (*v66)
    {
      v68 = (unsigned __int8 *)(v66 + 1);
      do
      {
        v166[0] = 0;
        v166[0] = uprv_toupper((char)*(v68 - 1));
        (*(void (**)(uint64_t, char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, v166, 1);
      }
      while (*v68++);
    }
    v62 = 0;
  }
  sub_18BC41A74(*(_QWORD *)(v14 + 56));
  v71 = *(_QWORD *)(v14 + 56);
  if (v71)
  {
    v72 = 0;
    do
    {
      v71 = *(_QWORD *)(v71 + 8);
      ++v72;
    }
    while (v71);
    if (v67 <= 0)
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, "_", 1);
      v62 = 0;
    }
    v73 = 0;
    v74 = 1;
    do
    {
      v75 = *(_QWORD *)(v14 + 56);
      if (v75)
      {
        v76 = v74;
        while (--v76)
        {
          v75 = *(_QWORD *)(v75 + 8);
          if (!v75)
            goto LABEL_177;
        }
        v77 = *(_BYTE **)v75;
      }
      else
      {
LABEL_177:
        v77 = 0;
      }
      (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, "_", 1);
      if (*v77)
      {
        v78 = v77 + 1;
        do
        {
          v166[0] = 0;
          v166[0] = uprv_toupper((char)*(v78 - 1));
          (*(void (**)(uint64_t, char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, v166, 1);
        }
        while (*v78++);
      }
      ++v73;
      ++v74;
    }
    while (v72 != v73);
  }
  if (*(_QWORD *)(v14 + 64))
  {
    if (v62)
      (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, "und", 3);
  }
  else if (!**(_BYTE **)(v14 + 72))
  {
    return sub_18BC4227C(&v155);
  }
  v158 = 0;
  v157[0] = 0;
  memset(&v157[2], 0, 72);
  v157[1] = &v157[3];
  LODWORD(v157[2]) = 8;
  v156[0] = 0;
  memset(&v156[2], 0, 72);
  v156[1] = &v156[3];
  LODWORD(v156[2]) = 8;
  v80 = *v154;
  if (*(int *)v154 > 0)
    goto LABEL_318;
  v81 = *(_QWORD *)(v14 + 64);
  if (!v81)
  {
    v131 = 0;
    goto LABEL_301;
  }
  v82 = -1;
  do
  {
    v81 = *(_QWORD *)(v81 + 16);
    ++v82;
  }
  while (v81);
  v83 = 0;
  v151 = 0;
  v84 = 1;
  while (2)
  {
    v85 = *(_QWORD *)(v14 + 64);
    v86 = v84;
    v87 = v85;
    while (--v86)
    {
      v87 = *(_QWORD *)(v87 + 16);
      if (!v87)
      {
        v88 = 0;
        goto LABEL_197;
      }
    }
    v88 = *(_BYTE **)v87;
LABEL_197:
    v89 = v84;
    while (--v89)
    {
      v85 = *(_QWORD *)(v85 + 16);
      if (!v85)
      {
        v90 = 0;
        goto LABEL_202;
      }
    }
    v90 = *(char **)(v85 + 8);
LABEL_202:
    if (*v88 != 117)
    {
      v127 = sub_18BC42020(v157, (unint64_t)v70);
      if (v127)
      {
        *v127 = v88;
        v127[1] = v90;
        if (sub_18BC420F8(&v158, (uint64_t)v127, 0))
          goto LABEL_290;
        goto LABEL_316;
      }
      goto LABEL_315;
    }
    v91 = *(_QWORD *)(v14 + 56);
    v164 = 0;
    v165 = 0;
    LODWORD(v172) = 0;
    v170 = 0u;
    v171 = 0u;
    v168 = 0u;
    v169 = 0u;
    *(_OWORD *)v166 = 0u;
    v167 = 0u;
    __n[0] = 0;
    memset(&__n[2], 0, 72);
    __n[1] = (size_t)&__n[3];
    LODWORD(__n[2]) = 8;
    v92 = *v90;
    if (!*v90)
    {
      sub_18BC3ED98((uint64_t)__n);
      goto LABEL_279;
    }
    v147 = v91;
    v153 = v83;
    v93 = 0;
    while (2)
    {
      for (k = 0; v92; v92 = v95[1])
      {
        if (v92 == 45)
          break;
        v95 = &v90[k++];
      }
      if (sub_18BC3F39C(v90, k))
        goto LABEL_216;
      v97 = sub_18BC3EB74((const void **)__n, v96);
      if (!v97)
      {
        v129 = 7;
LABEL_285:
        v83 = v153;
        goto LABEL_287;
      }
      if (100 - v93 <= (int)k)
      {
        v129 = 1;
        goto LABEL_285;
      }
      v98 = v97;
      memcpy(&v166[v93], v90, k);
      v166[(v93 + k)] = 0;
      *v98 = &v166[v93];
      v93 += k + 1;
      sub_18BC41CCC(&v164, (uint64_t)v98);
      if (v90[k])
        v90 += k + 1;
      else
        v90 += k;
      v92 = *v90;
      if (*v90)
        continue;
      break;
    }
    v90 = 0;
LABEL_216:
    v99 = v164;
    v83 = v153;
    v100 = v147;
    if (v164)
    {
      v101 = sub_18BC42020(v157, v96);
      if (v101)
      {
        v103 = v101;
        v104 = (icu::CharString *)sub_18BC3E964(v156, v102);
        if (v104)
        {
          v105 = v104;
          v144 = (uint64_t)v103;
          v106 = v99;
          do
          {
            v107 = (const char **)v106[1];
            if (v106 != v99)
              icu::CharString::append(v105, 45, v154);
            icu::StringPiece::StringPiece((icu::StringPiece *)&v161, *v106);
            icu::CharString::append(v105, v161, v162, v154);
            v106 = v107;
          }
          while (v107);
          v83 = v153;
          if (*(int *)v154 <= 0)
          {
            *v103 = "attribute";
            v103[1] = *(_QWORD *)v105;
            v100 = v147;
            if (sub_18BC420F8(&v165, v144, 0))
              goto LABEL_225;
            v129 = 1;
LABEL_287:
            *v154 = v129;
          }
          sub_18BC3ED98((uint64_t)__n);
          v151 = 0;
          goto LABEL_289;
        }
      }
      v129 = 7;
      goto LABEL_287;
    }
LABEL_225:
    sub_18BC3ED98((uint64_t)__n);
    if (v90)
    {
      v108 = 0;
      v109 = 0;
      LODWORD(__n[0]) = 0;
      LODWORD(v164) = 0;
      if (v100)
        v110 = 0;
      else
        v110 = v151 == 0;
      v111 = v110;
      v142 = v111;
      v151 = 0;
      while (1)
      {
        v112 = *v90;
        if (*v90)
        {
          v113 = 0;
          do
          {
            if (v112 == 45)
              break;
            v114 = &v90[v113++];
            v112 = v114[1];
          }
          while (v112);
          if (!sub_18BC3F39C(v90, v113))
          {
            if (v108)
            {
              LODWORD(v164) = (_DWORD)v164 + v113 + 1;
            }
            else
            {
              LODWORD(v164) = v113;
              v108 = v90;
            }
            goto LABEL_271;
          }
          if (!v109)
          {
            LODWORD(__n[0]) = v113;
            v109 = v90;
LABEL_271:
            if (v90[v113])
              v90 += v113 + 1;
            else
              v90 += v113;
            continue;
          }
          v115 = 0;
          v116 = v90;
          if (v90[v113])
            v90 += v113 + 1;
          else
            v90 += v113;
        }
        else
        {
          LODWORD(v113) = 0;
          v116 = 0;
          v115 = 1;
        }
        v160 = 0;
        *(_WORD *)__dst = 0;
        v117 = SLODWORD(__n[0]);
        if (SLODWORD(__n[0]) >= 3
          || (v145 = v116,
              v148 = v115,
              strncpy(__dst, v109, SLODWORD(__n[0])),
              __dst[v117] = 0,
              (v118 = (char *)uloc_toLegacyKey(__dst)) == 0))
        {
          *v154 = U_ILLEGAL_ARGUMENT_ERROR;
          v83 = v153;
          goto LABEL_289;
        }
        v119 = v118;
        v83 = v153;
        if (v118 == __dst)
        {
          T_CString_toLowerCase((unsigned __int8 *)__dst);
          v120 = (const char **)sub_18BC41BAC((int *)v156, __dst, (int *)__n, v154);
          if (!v120)
          {
            *v154 = U_MEMORY_ALLOCATION_ERROR;
            goto LABEL_289;
          }
          if (*(int *)v154 > 0)
            goto LABEL_289;
          v119 = *v120;
        }
        if (v108)
        {
          v172 = 0u;
          v173 = 0u;
          v170 = 0u;
          v171 = 0u;
          v168 = 0u;
          v169 = 0u;
          *(_OWORD *)v166 = 0u;
          v167 = 0u;
          v121 = (int)v164;
          if ((int)v164 > 127
            || (strncpy(v166, v108, (int)v164),
                v166[v121] = 0,
                (v122 = (char *)uloc_toLegacyType((uint64_t)v119, v166)) == 0))
          {
            v130 = 1;
            v83 = v153;
LABEL_295:
            *v154 = v130;
            goto LABEL_289;
          }
          v123 = v122;
          v83 = v153;
          if (v122 == v166)
          {
            T_CString_toLowerCase((unsigned __int8 *)v166);
            v124 = (const char **)sub_18BC41BAC((int *)v156, v166, (int *)&v164, v154);
            if (!v124)
            {
              v130 = 7;
              goto LABEL_295;
            }
            if (*(int *)v154 > 0)
              goto LABEL_289;
            v123 = *v124;
          }
        }
        else
        {
          v123 = "yes";
        }
        if (v142 && !strcmp(v119, "va") && !strcmp(v123, "posix"))
        {
          v151 = 1;
        }
        else
        {
          v125 = sub_18BC42020(v157, (unint64_t)v70);
          if (!v125)
          {
            *v154 = U_MEMORY_ALLOCATION_ERROR;
            goto LABEL_289;
          }
          *v125 = v119;
          v125[1] = v123;
          sub_18BC420F8(&v165, (uint64_t)v125, 0);
        }
        v108 = 0;
        v109 = v145;
        if (v145)
          v126 = v113;
        else
          v126 = 0;
        LODWORD(__n[0]) = v126;
        LODWORD(v164) = 0;
        if (v148)
          goto LABEL_280;
      }
    }
LABEL_279:
    v151 = 0;
LABEL_280:
    v70 = v165;
    if (v165)
    {
      do
      {
        v128 = (const char **)v70[2];
        sub_18BC420F8(&v158, (uint64_t)v70, 0);
        v70 = v128;
      }
      while (v128);
    }
LABEL_289:
    if (*(int *)v154 >= 1)
      goto LABEL_318;
LABEL_290:
    ++v84;
    v23 = v82 == v83++;
    if (!v23)
      continue;
    break;
  }
  v80 = *v154;
  if (*(int *)v154 <= 0)
  {
    v131 = v151;
LABEL_301:
    v132 = *(const char **)(v14 + 72);
    if ((int)strlen(v132) < 1)
    {
LABEL_305:
      if (v80 <= U_ZERO_ERROR && v131)
      {
        (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, "_POSIX", 6);
        v80 = *v154;
      }
      if (v80 <= U_ZERO_ERROR)
      {
        v135 = v158;
        if (v158)
        {
          v136 = "@";
          do
          {
            (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, v136, 1);
            v137 = strlen(*v135);
            (*(void (**)(uint64_t, const char *, size_t))(*(_QWORD *)a3 + 16))(a3, *v135, v137);
            (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(a3, "=", 1);
            v138 = strlen(v135[1]);
            (*(void (**)(uint64_t, const char *, size_t))(*(_QWORD *)a3 + 16))(a3, v135[1], v138);
            v135 = (const char **)v135[2];
            v136 = ";";
          }
          while (v135);
        }
      }
      goto LABEL_318;
    }
    v134 = sub_18BC42020(v157, v133);
    if (v134)
    {
      *v134 = "x";
      v134[1] = v132;
      if (sub_18BC420F8(&v158, (uint64_t)v134, 0))
      {
        v80 = *v154;
        goto LABEL_305;
      }
LABEL_316:
      v139 = 1;
LABEL_317:
      *v154 = v139;
      goto LABEL_318;
    }
LABEL_315:
    v139 = 7;
    goto LABEL_317;
  }
LABEL_318:
  sub_18BC3EDF8((uint64_t)v156);
  sub_18BC3ED98((uint64_t)v157);
  return sub_18BC4227C(&v155);
}

uint64_t sub_18BC41A74(uint64_t result)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  const char *v5;

  if (result)
  {
    for (i = result; ; i = v2)
    {
      v2 = *(_QWORD *)(i + 8);
      v3 = v2;
      if (!v2)
        break;
      do
      {
        v4 = *(const char **)i;
        v5 = *(const char **)v3;
        result = strcmp(*(const char **)i, *(const char **)v3);
        if ((int)result >= 1)
        {
          *(_QWORD *)i = v5;
          *(_QWORD *)v3 = v4;
        }
        v3 = *(_QWORD *)(v3 + 8);
      }
      while (v3);
    }
  }
  return result;
}

uint64_t sub_18BC41AE4(char *a1, int a2)
{
  uint64_t v3;

  if (a2 < 1)
    return 1;
  v3 = a2;
  while (uprv_isASCIILetter(*a1) || *a1 - 48 <= 9)
  {
    ++a1;
    if (!--v3)
      return 1;
  }
  return 0;
}

uint64_t sub_18BC41B48(const char ***a1, uint64_t a2)
{
  const char **v3;
  const char *v4;
  const char **v5;
  uint64_t result;

  v3 = *a1;
  if (*a1)
  {
    v4 = *(const char **)a2;
    while (1)
    {
      v5 = v3;
      result = strcmp(v4, *v3);
      if (!(_DWORD)result)
        break;
      v3 = (const char **)v5[1];
      if (!v3)
      {
        v5[1] = (const char *)a2;
        *(_QWORD *)(a2 + 8) = 0;
        return 1;
      }
    }
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *a1 = (const char **)a2;
    return 1;
  }
  return result;
}

uint64_t sub_18BC41BAC(int *a1, const char *a2, int *a3, UErrorCode *a4)
{
  int v8;
  int v9;
  void *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;

  v8 = a1[4];
  if (*a1 != v8)
  {
LABEL_16:
    v13 = icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
    v11 = v13;
    if (v13)
    {
      v14 = *a3;
      *(_QWORD *)v13 = v13 + 13;
      *(_DWORD *)(v13 + 8) = 40;
      *(_WORD *)(v13 + 12) = 0;
      *(_DWORD *)(v13 + 56) = 0;
      icu::CharString::append((icu::CharString *)v13, a2, v14, a4);
    }
    v15 = *a1;
    *a1 = v15 + 1;
    *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v15) = v11;
    return v11;
  }
  if (v8 == 8)
    v9 = 32;
  else
    v9 = 2 * v8;
  if (v9 < 1)
    return 0;
  v10 = uprv_malloc(8 * v9);
  v11 = (uint64_t)v10;
  if (v10)
  {
    if (v8 >= 1)
    {
      v12 = a1[4];
      if (v12 >= v8)
        v12 = v8;
      if (v12 >= v9)
        v12 = v9;
      memcpy(v10, *((const void **)a1 + 1), 8 * v12);
    }
    if (*((_BYTE *)a1 + 20))
      uprv_free(*((void **)a1 + 1));
    *((_QWORD *)a1 + 1) = v11;
    a1[4] = v9;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }
  return v11;
}

uint64_t sub_18BC41CCC(const char ***a1, uint64_t a2)
{
  const char **v4;
  const char *v5;
  uint64_t result;
  const char **v7;
  const char **v8;
  const char ***v9;

  v4 = *a1;
  if (!*a1)
  {
    *(_QWORD *)(a2 + 8) = 0;
    *a1 = (const char **)a2;
    return 1;
  }
  v5 = *(const char **)a2;
  result = strcmp(*(const char **)a2, *v4);
  if ((result & 0x80000000) != 0)
  {
    v7 = 0;
LABEL_9:
    if (v7)
      v9 = (const char ***)(v7 + 1);
    else
      v9 = a1;
    *v9 = (const char **)a2;
    *(_QWORD *)(a2 + 8) = v4;
    return 1;
  }
  v8 = v4;
  while ((_DWORD)result)
  {
    v4 = (const char **)v8[1];
    if (!v4)
    {
      v8[1] = (const char *)a2;
      *(_QWORD *)(a2 + 8) = 0;
      return 1;
    }
    result = strcmp(v5, *v4);
    v7 = v8;
    v8 = v4;
    if ((result & 0x80000000) != 0)
      goto LABEL_9;
  }
  return result;
}

uint64_t sub_18BC41D78(int *a1, unint64_t a2, UErrorCode *a3)
{
  int v6;
  int v7;
  void *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v6 = a1[4];
  if (*a1 != v6)
  {
LABEL_16:
    v11 = icu::UMemory::operator new((icu::UMemory *)0x40, a2);
    v9 = v11;
    if (v11)
    {
      *(_QWORD *)v11 = v11 + 13;
      *(_DWORD *)(v11 + 8) = 40;
      *(_WORD *)(v11 + 12) = 0;
      *(_DWORD *)(v11 + 56) = 0;
      icu::CharString::append((icu::CharString *)v11, *(const char **)a2, *(_DWORD *)(a2 + 56), a3);
    }
    v12 = *a1;
    *a1 = v12 + 1;
    *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v12) = v9;
    return v9;
  }
  if (v6 == 8)
    v7 = 32;
  else
    v7 = 2 * v6;
  if (v7 < 1)
    return 0;
  v8 = uprv_malloc(8 * v7);
  v9 = (uint64_t)v8;
  if (v8)
  {
    if (v6 >= 1)
    {
      v10 = a1[4];
      if (v10 >= v6)
        v10 = v6;
      if (v10 >= v7)
        v10 = v7;
      memcpy(v8, *((const void **)a1 + 1), 8 * v10);
    }
    if (*((_BYTE *)a1 + 20))
      uprv_free(*((void **)a1 + 1));
    *((_QWORD *)a1 + 1) = v9;
    a1[4] = v7;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }
  return v9;
}

BOOL sub_18BC41E8C(char *__s, int a2)
{
  BOOL v3;
  _BOOL8 result;

  if (a2 < 0)
    a2 = strlen(__s);
  result = 0;
  if (a2 == 1)
  {
    v3 = !uprv_isASCIILetter(*__s) && (*__s - 48) > 9u;
    if (!v3 && uprv_asciitolower(*__s) != 120)
      return 1;
  }
  return result;
}

uint64_t sub_18BC41EFC(int *a1, const char **a2, int *a3, UErrorCode *a4)
{
  int v8;
  int v9;
  void *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  const char *v14;
  int v15;
  uint64_t v16;

  v8 = a1[4];
  if (*a1 != v8)
  {
LABEL_16:
    v13 = icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
    v11 = v13;
    if (v13)
    {
      v14 = *a2;
      v15 = *a3;
      *(_BYTE *)(v13 + 13) = 0;
      *(_QWORD *)v13 = v13 + 13;
      *(_DWORD *)(v13 + 8) = 40;
      *(_BYTE *)(v13 + 12) = 0;
      *(_DWORD *)(v13 + 56) = 0;
      icu::CharString::append((icu::CharString *)v13, v14, v15, a4);
    }
    v16 = *a1;
    *a1 = v16 + 1;
    *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v16) = v11;
    return v11;
  }
  if (v8 == 8)
    v9 = 32;
  else
    v9 = 2 * v8;
  if (v9 < 1)
    return 0;
  v10 = uprv_malloc(8 * v9);
  v11 = (uint64_t)v10;
  if (v10)
  {
    if (v8 >= 1)
    {
      v12 = a1[4];
      if (v12 >= v8)
        v12 = v8;
      if (v12 >= v9)
        v12 = v9;
      memcpy(v10, *((const void **)a1 + 1), 8 * v12);
    }
    if (*((_BYTE *)a1 + 20))
      uprv_free(*((void **)a1 + 1));
    *((_QWORD *)a1 + 1) = v11;
    a1[4] = v9;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }
  return v11;
}

_QWORD *sub_18BC42020(const void **a1, unint64_t a2)
{
  int v3;
  int v4;
  _QWORD *result;
  _QWORD *v6;
  int v7;
  uint64_t v8;

  v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8)
      v4 = 32;
    else
      v4 = 2 * v3;
    if (v4 < 1)
      return 0;
    result = uprv_malloc(8 * v4);
    if (!result)
      return result;
    v6 = result;
    if (v3 >= 1)
    {
      v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3)
        v7 = v3;
      if (v7 >= v4)
        v7 = v4;
      memcpy(result, a1[1], 8 * v7);
    }
    if (*((_BYTE *)a1 + 20))
      uprv_free((void *)a1[1]);
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((_BYTE *)a1 + 20) = 1;
  }
  result = (_QWORD *)icu::UMemory::operator new((icu::UMemory *)0x18, a2);
  if (result)
  {
    *result = 0;
    result[1] = 0;
    result[2] = 0;
  }
  v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((_QWORD *)a1[1] + v8) = result;
  return result;
}

uint64_t sub_18BC420F8(const char ***a1, uint64_t a2, int a3)
{
  const char **v5;
  const char **v7;
  const char *v8;
  const char **v9;
  int v10;
  const char *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t result;
  const char ***v17;

  v5 = *a1;
  if (*a1)
  {
    v7 = 0;
    v8 = *(const char **)a2;
    while (1)
    {
      v9 = v7;
      v7 = v5;
      if (a3)
      {
        v10 = strlen(v8);
        v11 = *v7;
        v12 = strlen(*v7);
        if (v10 == 1 && v12 == 1)
        {
          v13 = *(unsigned __int8 *)v8;
          v14 = *(unsigned __int8 *)v11;
          if (v13 == v14)
            return 0;
          if ((char)v13 == 120)
            goto LABEL_20;
          if ((char)v14 == 120)
            goto LABEL_24;
          v15 = (char)v13 - (char)v14;
        }
        else if (v10 == 1)
        {
          v15 = *v8 - 117;
        }
        else if (v12 == 1)
        {
          v15 = 117 - *v11;
        }
        else
        {
          result = strcmp(v8, v11);
          if (!(_DWORD)result)
            return result;
          v15 = result;
          if (!strcmp(v11, "attribute"))
            goto LABEL_20;
          if (!strcmp(v8, "attribute"))
            goto LABEL_24;
        }
      }
      else
      {
        v15 = strcmp(v8, *v5);
      }
      if (v15 < 0)
      {
LABEL_24:
        v17 = (const char ***)(v9 + 2);
        if (!v9)
          v17 = a1;
        *v17 = (const char **)a2;
        *(_QWORD *)(a2 + 16) = v7;
        return 1;
      }
      if (!v15)
        return 0;
LABEL_20:
      v5 = (const char **)v7[2];
      if (!v5)
      {
        v7[2] = (const char *)a2;
        *(_QWORD *)(a2 + 16) = 0;
        return 1;
      }
    }
  }
  *(_QWORD *)(a2 + 16) = 0;
  *a1 = (const char **)a2;
  return 1;
}

uint64_t *sub_18BC4227C(uint64_t *a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  v2 = *a1;
  if (*a1)
  {
    uprv_free(*(void **)v2);
    v3 = *(_QWORD **)(v2 + 56);
    if (v3)
    {
      do
      {
        v4 = (_QWORD *)v3[1];
        uprv_free(v3);
        v3 = v4;
      }
      while (v4);
    }
    v5 = *(_QWORD **)(v2 + 64);
    if (v5)
    {
      do
      {
        v6 = (_QWORD *)v5[2];
        uprv_free(v5);
        v5 = v6;
      }
      while (v6);
    }
    uprv_free((void *)v2);
  }
  return a1;
}

icu::Locale *ulocale_openForLocaleID(char *__s, int a2, UErrorCode *a3)
{
  char *v5;
  icu::Locale *v6;
  unint64_t v7;
  char *v9;
  int v10;
  _BYTE v11[224];
  void *v12[7];
  uint64_t v13;
  uint64_t v14;

  v5 = __s;
  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  memset(&v12[1], 0, 48);
  if (a2 < 0)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v9, __s);
    v5 = v9;
  }
  else
  {
    v9 = __s;
    v10 = a2;
  }
  v12[0] = (char *)&v12[1] + 5;
  LODWORD(v12[1]) = 40;
  WORD2(v12[1]) = 0;
  LODWORD(v13) = 0;
  icu::CharString::append((icu::CharString *)v12, v5, v10, a3);
  if (*(int *)a3 <= 0)
  {
    icu::Locale::createFromName((icu::Locale *)v12[0], (uint64_t)v11);
    v6 = icu::Locale::clone((icu::Locale *)v11, v7);
    icu::Locale::~Locale((icu::Locale *)v11);
  }
  else
  {
    v6 = 0;
  }
  if (BYTE4(v12[1]))
    uprv_free(v12[0]);
  return v6;
}

icu::Locale *ulocale_openForLanguageTag(char *__s, int a2, int *a3)
{
  char *v4;
  unint64_t v5;
  icu::Locale *v6;
  char *v8;
  uint64_t v9;
  _OWORD v10[14];
  uint64_t v11;

  v4 = __s;
  v11 = *MEMORY[0x1E0C80C00];
  memset(v10, 0, sizeof(v10));
  if (a2 < 0)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v8, __s);
    v4 = v8;
  }
  else
  {
    v8 = __s;
    LODWORD(v9) = a2;
  }
  icu::Locale::forLanguageTag(v4, v9, a3, (uint64_t)v10);
  if (*a3 <= 0)
    v6 = icu::Locale::clone((icu::Locale *)v10, v5);
  else
    v6 = 0;
  icu::Locale::~Locale((icu::Locale *)v10);
  return v6;
}

uint64_t ulocale_close(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t ulocale_getLanguage(uint64_t a1)
{
  if (a1)
    return a1 + 8;
  else
    return 0;
}

uint64_t ulocale_getScript(uint64_t a1)
{
  if (a1)
    return a1 + 20;
  else
    return 0;
}

uint64_t ulocale_getRegion(uint64_t a1)
{
  if (a1)
    return a1 + 26;
  else
    return 0;
}

uint64_t ulocale_getVariant(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 208) + *(int *)(result + 32);
  return result;
}

uint64_t ulocale_getLocaleID(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 40);
  return result;
}

icu::Locale *ulocale_getBaseName(icu::Locale *result)
{
  if (result)
    return (icu::Locale *)icu::Locale::getBaseName(result);
  return result;
}

uint64_t ulocale_getKeywordValue(uint64_t a1, const char *a2, int a3, char *a4, int a5, UErrorCode *a6)
{
  uint64_t v6;
  const char *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;

  if (*(int *)a6 > 0)
    return 0;
  v6 = a1;
  if (a1)
  {
    v15 = 0u;
    v16 = 0u;
    icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v15, a4, a5);
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v13, a2);
      a2 = v13;
    }
    else
    {
      v13 = a2;
      LODWORD(v14) = a3;
    }
    icu::Locale::getKeywordValue(v6, a2, v14, (uint64_t)&v15, a6);
    v6 = DWORD2(v16);
    if (*(int *)a6 <= 0)
    {
      if (BYTE12(v16))
        *a6 = U_BUFFER_OVERFLOW_ERROR;
      else
        u_terminateChars((uint64_t)a4, a5, DWORD2(v16), (int *)a6);
    }
    icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v15);
  }
  else
  {
    *a6 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v6;
}

uint64_t ulocale_getUnicodeKeywordValue(uint64_t a1, const char *a2, int a3, char *a4, int a5, UErrorCode *a6)
{
  uint64_t v6;
  const char *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;

  if (*(int *)a6 > 0)
    return 0;
  v6 = a1;
  if (a1)
  {
    v15 = 0u;
    v16 = 0u;
    icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v15, a4, a5);
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v13, a2);
      a2 = v13;
    }
    else
    {
      v13 = a2;
      LODWORD(v14) = a3;
    }
    icu::Locale::getUnicodeKeywordValue(v6, a2, v14, (uint64_t)&v15, a6);
    v6 = DWORD2(v16);
    if (*(int *)a6 <= 0)
    {
      if (BYTE12(v16))
        *a6 = U_BUFFER_OVERFLOW_ERROR;
      else
        u_terminateChars((uint64_t)a4, a5, DWORD2(v16), (int *)a6);
    }
    icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v15);
  }
  else
  {
    *a6 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v6;
}

_OWORD *ulocale_getKeywords(icu::Locale *a1, UErrorCode *a2)
{
  char *Keywords;

  if (*(int *)a2 > 0)
    return 0;
  if (!a1)
  {
    *a2 = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  Keywords = icu::Locale::createKeywords(a1, a2);
  return uenum_openFromStringEnumeration((uint64_t)Keywords, (int *)a2);
}

_OWORD *ulocale_getUnicodeKeywords(icu::Locale *a1, UErrorCode *a2)
{
  char *UnicodeKeywords;

  if (*(int *)a2 > 0)
    return 0;
  if (!a1)
  {
    *a2 = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  UnicodeKeywords = icu::Locale::createUnicodeKeywords(a1, a2);
  return uenum_openFromStringEnumeration((uint64_t)UnicodeKeywords, (int *)a2);
}

BOOL ulocale_isBogus(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 216) != 0;
  return result;
}

uint64_t *ulocbld_open@<X0>(unint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t *result;

  result = icu::UMemory::operator new(a2, (icu::UMemory *)0x30, a1);
  if (result)
    return icu::LocaleBuilder::LocaleBuilder(result);
  return result;
}

uint64_t ulocbld_close(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void ulocbld_setLocale(icu::LocaleBuilder *a1, const char *a2, unsigned int a3)
{
  const char *v6;
  _BYTE __dst[157];
  _BYTE v8[224];
  _BYTE v9[232];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    memset(v9, 0, 224);
    icu::Locale::Locale((icu::Locale *)v9);
    if ((a3 & 0x80000000) != 0 || !a2[a3])
    {
      v6 = a2;
    }
    else
    {
      if (a3 >= 0x9D)
      {
        icu::Locale::setToBogus((icu::Locale *)v9);
LABEL_9:
        icu::LocaleBuilder::setLocale(a1, (const icu::Locale *)v9);
        icu::Locale::~Locale((icu::Locale *)v9);
        return;
      }
      bzero(&__dst[a3], 157 - a3);
      memcpy(__dst, a2, a3);
      __dst[a3] = 0;
      v6 = __dst;
    }
    icu::Locale::Locale((icu::Locale *)v8, v6, 0, 0, 0);
    icu::Locale::operator=((uint64_t)v9, (uint64_t)v8);
    icu::Locale::~Locale((icu::Locale *)v8);
    goto LABEL_9;
  }
}

icu::LocaleBuilder *ulocbld_adoptULocale(icu::LocaleBuilder *result, const icu::Locale *a2)
{
  if (result)
  {
    icu::LocaleBuilder::setLocale(result, a2);
    return (icu::LocaleBuilder *)ulocale_close((uint64_t)a2);
  }
  return result;
}

int *ulocbld_setLanguageTag(int *result, char *a2, int a3)
{
  int *v3;
  char *v4;
  uint64_t v5;

  if (result)
  {
    v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::setLanguageTag(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_setLanguage(uint64_t result, char *a2, int a3)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;

  if (result)
  {
    v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::setLanguage(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_setScript(uint64_t result, char *a2, int a3)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;

  if (result)
  {
    v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::setScript(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_setRegion(uint64_t result, char *a2, int a3)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;

  if (result)
  {
    v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::setRegion(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_setVariant(uint64_t result, const char *a2, int a3)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;

  if (result)
  {
    v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::setVariant(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_addUnicodeLocaleAttribute(uint64_t result, const char *a2, int a3)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;

  if (result)
  {
    v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::addUnicodeLocaleAttribute(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_removeUnicodeLocaleAttribute(uint64_t result, const char *a2, int a3)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;

  if (result)
  {
    v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::removeUnicodeLocaleAttribute(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_setExtension(uint64_t result, int a2, char *__s, int a4)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;

  if (result)
  {
    v5 = result;
    if (a4 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v6, __s);
      __s = v6;
    }
    else
    {
      v6 = __s;
      LODWORD(v7) = a4;
    }
    return icu::LocaleBuilder::setExtension(v5, a2, __s, v7);
  }
  return result;
}

uint64_t ulocbld_setUnicodeLocaleKeyword(uint64_t result, const char *a2, int a3, char *__s, int a5)
{
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;

  if (result)
  {
    v7 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v10, a2);
      if ((a5 & 0x80000000) == 0)
        goto LABEL_4;
    }
    else
    {
      v10 = (char *)a2;
      LODWORD(v11) = a3;
      if ((a5 & 0x80000000) == 0)
      {
LABEL_4:
        v8 = __s;
        LODWORD(v9) = a5;
        return icu::LocaleBuilder::setUnicodeLocaleKeyword(v7, v10, v11, __s, v9);
      }
    }
    icu::StringPiece::StringPiece((icu::StringPiece *)&v8, __s);
    __s = v8;
    return icu::LocaleBuilder::setUnicodeLocaleKeyword(v7, v10, v11, __s, v9);
  }
  return result;
}

icu::LocaleBuilder *ulocbld_clear(icu::LocaleBuilder *this)
{
  if (this)
    return icu::LocaleBuilder::clear(this);
  return this;
}

icu::LocaleBuilder *ulocbld_clearExtensions(icu::LocaleBuilder *this)
{
  if (this)
    return icu::LocaleBuilder::clearExtensions(this);
  return this;
}

icu::Locale *ulocbld_buildULocale(icu::LocaleBuilder *a1, UErrorCode *a2)
{
  unint64_t v3;
  icu::Locale *v4;
  _OWORD v6[14];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    memset(v6, 0, sizeof(v6));
    icu::LocaleBuilder::build(a1, a2, (icu::Locale *)v6);
    if (*(int *)a2 <= 0)
    {
      v4 = icu::Locale::clone((icu::Locale *)v6, v3);
      if (!v4)
        *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
    else
    {
      v4 = 0;
    }
    icu::Locale::~Locale((icu::Locale *)v6);
  }
  else
  {
    v4 = 0;
    *a2 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v4;
}

uint64_t ulocbld_buildLocaleID(icu::LocaleBuilder *a1, void *a2, int a3, UErrorCode *a4)
{
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  _OWORD v11[2];
  char *__s[2];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    *(_OWORD *)__s = 0u;
    v13 = 0u;
    memset(v11, 0, sizeof(v11));
    icu::LocaleBuilder::build(a1, a4, (icu::Locale *)v11);
    if (*(int *)a4 <= 0)
    {
      v8 = strlen(__s[1]);
      v9 = v8;
      if ((int)v8 >= 1 && (int)v8 <= a3)
        memcpy(a2, __s[1], v8);
      v7 = u_terminateChars((uint64_t)a2, a3, v9, (int *)a4);
    }
    else
    {
      v7 = 0;
    }
    icu::Locale::~Locale((icu::Locale *)v11);
  }
  else
  {
    v7 = 0;
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v7;
}

uint64_t ulocbld_buildLanguageTag(icu::LocaleBuilder *a1, char *a2, int a3, UErrorCode *a4)
{
  uint64_t v7;
  __int128 v9;
  __int128 v10;
  _OWORD v11[14];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    memset(v11, 0, sizeof(v11));
    icu::LocaleBuilder::build(a1, a4, (icu::Locale *)v11);
    if (*(int *)a4 <= 0)
    {
      v9 = 0u;
      v10 = 0u;
      icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v9, a2, a3);
      icu::Locale::toLanguageTag((char **)v11, (icu::ByteSink *)&v9, a4);
      v7 = DWORD2(v10);
      if (*(int *)a4 <= 0)
      {
        if (BYTE12(v10))
          *a4 = U_BUFFER_OVERFLOW_ERROR;
        else
          u_terminateChars((uint64_t)a2, a3, DWORD2(v10), (int *)a4);
      }
      icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v9);
    }
    else
    {
      v7 = 0;
    }
    icu::Locale::~Locale((icu::Locale *)v11);
  }
  else
  {
    v7 = 0;
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v7;
}

BOOL ulocbld_copyErrorTo(icu::LocaleBuilder *a1, UErrorCode *a2)
{
  if (a1)
    return icu::LocaleBuilder::copyErrorTo(a1, a2);
  *a2 = U_ILLEGAL_ARGUMENT_ERROR;
  return 1;
}

_QWORD *ulocdata_open(char *a1, int *a2)
{
  _QWORD *v2;
  _QWORD *v6;
  int v7;

  if (*a2 > 0)
    return 0;
  v6 = uprv_malloc(0x18uLL);
  v2 = v6;
  if (!v6)
  {
    *a2 = 7;
    return v2;
  }
  v6[2] = 0;
  *(_BYTE *)v6 = 0;
  v6[1] = ures_open(0, a1, a2);
  v7 = *a2;
  if (*a2 >= 1)
  {
    uprv_free(v2);
    return 0;
  }
  v2[2] = ures_open("icudt74l-lang", a1, a2);
  if (*a2 == 2)
    *a2 = v7;
  return v2;
}

void ulocdata_close(_QWORD **a1)
{
  if (a1)
  {
    ures_close(a1[2]);
    ures_close(a1[1]);
    uprv_free(a1);
  }
}

_BYTE *ulocdata_setNoSubstitute(_BYTE *result, char a2)
{
  *result = a2;
  return result;
}

uint64_t ulocdata_getNoSubstitute(char *a1)
{
  return *a1;
}

icu::UnicodeSet *ulocdata_getExemplarSet(uint64_t a1, icu::UnicodeSet *a2, int a3, int a4, UErrorCode *a5)
{
  const UChar *StringByKey;
  int v10;
  uint64_t v12;

  v12 = 0;
  if (*(int *)a5 > 0)
    return 0;
  StringByKey = ures_getStringByKey(*(_QWORD *)(a1 + 8), off_1E22565F8[a4], (int *)&v12 + 1, (int *)&v12);
  v10 = v12;
  if ((_DWORD)v12 == -127)
  {
    if (*(_BYTE *)a1)
    {
      v10 = 2;
      LODWORD(v12) = 2;
    }
    else
    {
      v10 = -127;
    }
  }
  else if (!(_DWORD)v12)
  {
    v10 = *a5;
    goto LABEL_9;
  }
  *a5 = v10;
LABEL_9:
  if (v10 > 0)
    return 0;
  if (!a2)
    return uset_openPatternOptions((uint64_t)StringByKey, SHIDWORD(v12), a3 | 1u, a5);
  uset_applyPattern(a2, (uint64_t)StringByKey, HIDWORD(v12), a3 | 1, a5);
  return a2;
}

uint64_t ulocdata_getDelimiter(uint64_t a1, int a2, UChar *a3, int32_t a4, int *a5)
{
  uint64_t result;
  _QWORD *v11;
  _QWORD *v12;
  int v13;
  const UChar *StringByKeyWithFallback;
  int v15;
  uint64_t v16;

  result = 0;
  v16 = 0;
  if (*a5 <= 0)
  {
    v11 = (_QWORD *)ures_getByKey(*(_QWORD *)(a1 + 8), "delimiters", 0, (int *)&v16);
    v12 = v11;
    v13 = v16;
    if ((_DWORD)v16 == -127)
    {
      if (*(_BYTE *)a1)
      {
        v13 = 2;
        LODWORD(v16) = 2;
      }
      else
      {
        v13 = -127;
      }
    }
    else if (!(_DWORD)v16)
    {
      v13 = *a5;
      goto LABEL_9;
    }
    *a5 = v13;
LABEL_9:
    if (v13 >= 1)
    {
      ures_close(v11);
      return 0;
    }
    StringByKeyWithFallback = ures_getStringByKeyWithFallback((uint64_t)v11, off_1E2256618[a2], (int *)&v16 + 1, (UErrorCode *)&v16);
    ures_close(v12);
    v15 = v16;
    if ((_DWORD)v16 == -127)
    {
      if (*(_BYTE *)a1)
      {
        v15 = 2;
        LODWORD(v16) = 2;
      }
      else
      {
        v15 = -127;
      }
    }
    else if (!(_DWORD)v16)
    {
      v15 = *a5;
      goto LABEL_18;
    }
    *a5 = v15;
LABEL_18:
    if (v15 <= 0)
    {
      u_strncpy(a3, StringByKeyWithFallback, a4);
      return HIDWORD(v16);
    }
    return 0;
  }
  return result;
}

uint64_t ulocdata_getMeasurementSystem(char *a1, int *a2)
{
  uint64_t v3;
  _QWORD *v4;
  unsigned int Int;

  if (!a2)
    return 3;
  v3 = 3;
  if (*a2 <= 0)
  {
    v4 = (_QWORD *)sub_18BC43364(a1, "MeasurementSystem", a2);
    Int = ures_getInt((uint64_t)v4, a2);
    if (*a2 <= 0)
      v3 = Int;
    else
      v3 = 3;
    ures_close(v4);
  }
  return v3;
}

uint64_t sub_18BC43364(char *a1, const char *a2, int *a3)
{
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  int v8;
  uint64_t v9;
  int v11;

  v11 = 0;
  ulocimp_getRegionForSupplementalData(a1, 1, (char *)&v11, 4, a3);
  v5 = (_QWORD *)ures_openDirect(0, (uint64_t)"supplementalData", (uint64_t)a3);
  ures_getByKey((uint64_t)v5, "measurementData", (uint64_t)v5, a3);
  if (v5)
  {
    v6 = ures_getByKey((uint64_t)v5, (const char *)&v11, 0, a3);
    v7 = (_QWORD *)v6;
    v8 = *a3;
    if (*a3 <= 0)
    {
      v9 = ures_getByKey(v6, a2, 0, a3);
      v8 = *a3;
    }
    else
    {
      v9 = 0;
    }
    if (v8 == 2)
    {
      *a3 = 0;
      if (v7)
        ures_close(v7);
      v7 = (_QWORD *)ures_getByKey((uint64_t)v5, "001", 0, a3);
      v9 = ures_getByKey((uint64_t)v7, a2, 0, a3);
    }
    ures_close(v7);
  }
  else
  {
    v9 = 0;
  }
  ures_close(v5);
  return v9;
}

void ulocdata_getPaperSize(char *a1, int *a2, _DWORD *a3, int *a4)
{
  _QWORD *v7;
  int *IntVector;
  int v9;

  v9 = 0;
  if (a4 && *a4 <= 0)
  {
    v7 = (_QWORD *)sub_18BC43364(a1, "PaperSize", a4);
    IntVector = ures_getIntVector((uint64_t)v7, &v9, a4);
    if (*a4 <= 0)
    {
      if (v9 > 1)
      {
        *a2 = *IntVector;
        *a3 = IntVector[1];
      }
      else
      {
        *a4 = 5;
      }
    }
    ures_close(v7);
  }
}

void ulocdata_getCLDRVersion(uint8_t *a1, int *a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)ures_openDirect(0, (uint64_t)"supplementalData", (uint64_t)a2);
  ures_getVersionByKey((uint64_t)v4, "cldrVersion", a1, a2);
  ures_close(v4);
}

uint64_t ulocdata_getLocaleDisplayPattern(uint64_t a1, UChar *a2, int32_t a3, int *a4)
{
  uint64_t result;
  _QWORD *v9;
  _QWORD *v10;
  int v11;
  const UChar *StringByKey;
  int v13;
  uint64_t v14;

  result = 0;
  v14 = 0;
  if (*a4 <= 0)
  {
    result = *(_QWORD *)(a1 + 16);
    if (!result)
    {
      *a4 = 2;
      return result;
    }
    v9 = (_QWORD *)ures_getByKey(result, "localeDisplayPattern", 0, (int *)&v14);
    v10 = v9;
    v11 = v14;
    if ((_DWORD)v14 == -127)
    {
      if (*(_BYTE *)a1)
      {
        v11 = 2;
        LODWORD(v14) = 2;
      }
      else
      {
        v11 = -127;
      }
    }
    else if (!(_DWORD)v14)
    {
      v11 = *a4;
      goto LABEL_11;
    }
    *a4 = v11;
LABEL_11:
    if (v11 >= 1)
    {
      ures_close(v9);
      return 0;
    }
    StringByKey = ures_getStringByKey((uint64_t)v9, "pattern", (int *)&v14 + 1, (int *)&v14);
    ures_close(v10);
    v13 = v14;
    if ((_DWORD)v14 == -127)
    {
      if (*(_BYTE *)a1)
      {
        v13 = 2;
        LODWORD(v14) = 2;
      }
      else
      {
        v13 = -127;
      }
    }
    else if (!(_DWORD)v14)
    {
      v13 = *a4;
      goto LABEL_20;
    }
    *a4 = v13;
LABEL_20:
    if (v13 <= 0)
    {
      u_strncpy(a2, StringByKey, a3);
      return HIDWORD(v14);
    }
    return 0;
  }
  return result;
}

uint64_t ulocdata_getLocaleSeparator(uint64_t a1, UChar *a2, int32_t a3, int *a4)
{
  uint64_t result;
  _QWORD *v9;
  _QWORD *v10;
  int v11;
  const UChar *StringByKey;
  int v13;
  UChar *v14;
  UChar *v15;
  unint64_t v16;
  uint64_t v17;

  result = 0;
  v17 = 0;
  if (*a4 > 0)
    return result;
  result = *(_QWORD *)(a1 + 16);
  if (!result)
  {
    *a4 = 2;
    return result;
  }
  v9 = (_QWORD *)ures_getByKey(result, "localeDisplayPattern", 0, (int *)&v17);
  v10 = v9;
  v11 = v17;
  if ((_DWORD)v17 == -127)
  {
    if (*(_BYTE *)a1)
    {
      v11 = 2;
      LODWORD(v17) = 2;
    }
    else
    {
      v11 = -127;
    }
  }
  else if (!(_DWORD)v17)
  {
    v11 = *a4;
    goto LABEL_11;
  }
  *a4 = v11;
LABEL_11:
  if (v11 >= 1)
  {
    ures_close(v9);
    return 0;
  }
  StringByKey = ures_getStringByKey((uint64_t)v9, "separator", (int *)&v17 + 1, (int *)&v17);
  ures_close(v10);
  v13 = v17;
  if ((_DWORD)v17 == -127)
  {
    if (*(_BYTE *)a1)
    {
      v13 = 2;
      LODWORD(v17) = 2;
    }
    else
    {
      v13 = -127;
    }
    goto LABEL_19;
  }
  if ((_DWORD)v17)
  {
LABEL_19:
    *a4 = v13;
    goto LABEL_20;
  }
  v13 = *a4;
LABEL_20:
  if (v13 > 0)
    return 0;
  v14 = u_strstr(StringByKey, (const UChar *)"{");
  v15 = u_strstr(StringByKey, (const UChar *)"{");
  if (v14
    && v15
    && v14 <= v15
    && (StringByKey = v14 + 3,
        v16 = (unint64_t)((char *)v15 - (char *)(v14 + 3)) >> 1,
        HIDWORD(v17) = v16,
        (int)v16 < a3))
  {
    u_strncpy(a2, v14 + 3, v16);
    result = SHIDWORD(v17);
    a2[SHIDWORD(v17)] = 0;
  }
  else
  {
    u_strncpy(a2, StringByKey, a3);
    return HIDWORD(v17);
  }
  return result;
}

uint64_t uprv_mapFile(_QWORD *a1, const char *a2, int *a3)
{
  uint64_t v3;
  int st_size;
  int v8;
  int v9;
  size_t v10;
  char *v11;
  stat v12;

  if (*a3 > 0)
    return 0;
  memset(&v12, 0, sizeof(v12));
  sub_18BC354B0((uint64_t)a1);
  v3 = 0;
  if (!stat(a2, &v12))
  {
    st_size = v12.st_size;
    if (v12.st_size >= 1)
    {
      v8 = open(a2, 0, *(_OWORD *)&v12.st_dev, *(_OWORD *)&v12.st_uid, *(_OWORD *)&v12.st_atimespec, *(_OWORD *)&v12.st_mtimespec, *(_OWORD *)&v12.st_ctimespec, *(_OWORD *)&v12.st_birthtimespec);
      if (v8 != -1)
      {
        v9 = v8;
        v10 = st_size;
        v11 = (char *)mmap(0, st_size, 1, 1, v8, 0);
        close(v9);
        if (v11 != (char *)-1)
        {
          a1[1] = v11;
          a1[4] = v11;
          a1[5] = &v11[v10];
          v3 = 1;
          posix_madvise(v11, v10, 1);
          return v3;
        }
      }
      return 0;
    }
  }
  return v3;
}

uint64_t sub_18BC43968(uint64_t result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = (_QWORD *)result;
    v2 = *(_QWORD *)(result + 40);
    if (v2)
    {
      result = munmap(*(void **)(result + 32), v2 - *(_QWORD *)(result + 32));
      v1[1] = 0;
      v1[4] = 0;
      v1[5] = 0;
    }
  }
  return result;
}

uint64_t uprv_max(uint64_t result, int a2)
{
  if ((int)result <= a2)
    return a2;
  else
    return result;
}

uint64_t uprv_min(uint64_t result, int a2)
{
  if ((int)result >= a2)
    return a2;
  else
    return result;
}

void **umutablecptrie_open(int a1, unint64_t a2, int *a3)
{
  void **result;
  int v5;
  uint64_t v7;
  void **v8;

  if (*a3 > 0)
    return 0;
  v5 = a2;
  v7 = icu::UMemory::operator new((icu::UMemory *)0x11040, a2);
  if (!v7)
  {
    if (*a3 <= 0)
    {
      result = 0;
      *a3 = 7;
      return result;
    }
    return 0;
  }
  result = (void **)sub_18BC43A4C(v7, a1, v5, a3);
  if (*a3 >= 1)
  {
    v8 = sub_18BC43C60(result);
    icu::UMemory::operator delete(v8);
    return 0;
  }
  return result;
}

uint64_t sub_18BC43A4C(uint64_t a1, int a2, int a3, int *a4)
{
  void *v6;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0xFFFFFFFF00000000;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = -1;
  *(_DWORD *)(a1 + 36) = a2;
  *(_DWORD *)(a1 + 40) = a2;
  *(_DWORD *)(a1 + 44) = a3;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = a2;
  *(_QWORD *)(a1 + 56) = 0;
  if (*a4 <= 0)
  {
    *(_QWORD *)a1 = uprv_malloc(0x4000uLL);
    v6 = uprv_malloc(0x10000uLL);
    *(_QWORD *)(a1 + 16) = v6;
    if (*(_QWORD *)a1 && v6)
    {
      *(_DWORD *)(a1 + 8) = 4096;
      *(_DWORD *)(a1 + 24) = 0x4000;
    }
    else
    {
      *a4 = 7;
    }
  }
  return a1;
}

uint64_t *umutablecptrie_clone(uint64_t a1, int *a2)
{
  uint64_t *v2;
  uint64_t *v4;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  int v9;
  void *v10;
  void *v11;
  int v12;
  int v13;
  void **v14;

  v2 = 0;
  if (a1)
  {
    v4 = (uint64_t *)*a2;
    if ((int)v4 <= 0)
    {
      v6 = icu::UMemory::operator new(v4, (icu::UMemory *)0x11040, (unint64_t)a2);
      if (v6)
      {
        v2 = v6;
        *v6 = 0;
        v7 = *(_DWORD *)(a1 + 12);
        *((_DWORD *)v6 + 2) = 0;
        *((_DWORD *)v6 + 3) = v7;
        v6[2] = 0;
        v6[3] = 0;
        *((_OWORD *)v6 + 2) = *(_OWORD *)(a1 + 32);
        v8 = *(_QWORD *)(a1 + 48);
        v6[6] = v8;
        v6[7] = 0;
        if (*a2 <= 0)
        {
          if ((int)v8 > 0x10000)
            v9 = 69632;
          else
            v9 = 4096;
          *v6 = (uint64_t)uprv_malloc((4 * v9));
          v10 = uprv_malloc(4 * *(int *)(a1 + 24));
          v2[2] = (uint64_t)v10;
          v11 = (void *)*v2;
          if (*v2 && v10)
          {
            *((_DWORD *)v2 + 2) = v9;
            *((_DWORD *)v2 + 6) = *(_DWORD *)(a1 + 24);
            v12 = *((_DWORD *)v2 + 12);
            v13 = v12 >> 4;
            memcpy(v2 + 8, (const void *)(a1 + 64), (uint64_t)v12 >> 4);
            memcpy(v11, *(const void **)a1, 4 * v13);
            memcpy((void *)v2[2], *(const void **)(a1 + 16), 4 * *(int *)(a1 + 28));
            *((_DWORD *)v2 + 7) = *(_DWORD *)(a1 + 28);
            if (*a2 < 1)
              return v2;
          }
          else
          {
            *a2 = 7;
          }
        }
        v14 = sub_18BC43C60((void **)v2);
        icu::UMemory::operator delete(v14);
        return 0;
      }
      if (*a2 > 0)
        return 0;
      v2 = 0;
      *a2 = 7;
    }
  }
  return v2;
}

void umutablecptrie_close(void **a1)
{
  void **v1;

  if (a1)
  {
    v1 = sub_18BC43C60(a1);
    icu::UMemory::operator delete(v1);
  }
}

void **sub_18BC43C60(void **a1)
{
  uprv_free(*a1);
  uprv_free(a1[2]);
  uprv_free(a1[7]);
  return a1;
}

void **umutablecptrie_fromUCPMap(UCPMap *map, int *a2)
{
  void **v2;
  uint32_t v6;
  uint32_t v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  UChar32 Range;
  UChar32 v12;
  unsigned int v13;
  void **v14;
  int v15;
  uint32_t pValue;

  if (*a2 > 0)
    return 0;
  if (!map)
  {
    v2 = 0;
    v15 = 1;
    goto LABEL_19;
  }
  v6 = ucpmap_get(map, -1);
  v7 = ucpmap_get(map, 1114111);
  v10 = icu::UMemory::operator new(v9, (icu::UMemory *)0x11040, v8);
  if (!v10)
  {
    if (*a2 > 0)
      return 0;
    v2 = 0;
    v15 = 7;
LABEL_19:
    *a2 = v15;
    return v2;
  }
  v2 = (void **)v10;
  sub_18BC43A4C((uint64_t)v10, v7, v6, a2);
  if (*a2 > 0)
    goto LABEL_15;
  pValue = 0;
  Range = ucpmap_getRange(map, 0, UCPMAP_RANGE_NORMAL, 0, 0, 0, &pValue);
  if ((Range & 0x80000000) == 0)
  {
    v12 = Range;
    v13 = 0;
    do
    {
      if (pValue != v7)
      {
        if (v13 == v12)
          sub_18BC44300((uint64_t)v2, v12, pValue, a2);
        else
          sub_18BC44398((uint64_t)v2, v13, v12, pValue, a2);
      }
      v13 = v12 + 1;
      v12 = ucpmap_getRange(map, v12 + 1, UCPMAP_RANGE_NORMAL, 0, 0, 0, &pValue);
    }
    while ((v12 & 0x80000000) == 0);
  }
  if (*a2 >= 1)
  {
LABEL_15:
    v14 = sub_18BC43C60(v2);
    icu::UMemory::operator delete(v14);
    return 0;
  }
  return v2;
}

void **umutablecptrie_fromUCPTrie(uint64_t a1, int *a2)
{
  void **v2;
  int v5;
  uint64_t *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v12;
  uint64_t *v13;
  unsigned int Range;
  unsigned int v15;
  unsigned int v16;
  void **v17;
  unsigned int v18;

  if (*a2 > 0)
    return 0;
  if (!a1)
    goto LABEL_8;
  v5 = *(char *)(a1 + 31);
  if (v5 == 2)
  {
    v6 = (uint64_t *)(*(int *)(a1 + 20) + *(_QWORD *)(a1 + 8));
    v8 = *((unsigned __int8 *)v6 - 1);
    v9 = *((unsigned __int8 *)v6 - 2);
  }
  else
  {
    if (v5 != 1)
    {
      if (!*(_BYTE *)(a1 + 31))
      {
        v6 = *(uint64_t **)(a1 + 8);
        v7 = *(_DWORD *)(a1 + 20);
        v8 = *((unsigned __int16 *)v6 + v7 - 1);
        v9 = *((unsigned __int16 *)v6 + v7 - 2);
        goto LABEL_13;
      }
LABEL_8:
      v2 = 0;
      v10 = 1;
      goto LABEL_9;
    }
    v6 = *(uint64_t **)(a1 + 8);
    v12 = *(_DWORD *)(a1 + 20);
    v8 = *((_DWORD *)v6 + v12 - 1);
    v9 = *((_DWORD *)v6 + v12 - 2);
  }
LABEL_13:
  v13 = icu::UMemory::operator new(v6, (icu::UMemory *)0x11040, (unint64_t)a2);
  if (!v13)
  {
    if (*a2 > 0)
      return 0;
    v2 = 0;
    v10 = 7;
LABEL_9:
    *a2 = v10;
    return v2;
  }
  v2 = (void **)v13;
  sub_18BC43A4C((uint64_t)v13, v9, v8, a2);
  if (*a2 > 0)
    goto LABEL_23;
  v18 = 0;
  Range = ucptrie_getRange(a1, 0, 0, 0, 0, 0, (int *)&v18);
  if ((Range & 0x80000000) == 0)
  {
    v15 = Range;
    v16 = 0;
    do
    {
      if (v18 != v9)
      {
        if (v16 == v15)
          sub_18BC44300((uint64_t)v2, v15, v18, a2);
        else
          sub_18BC44398((uint64_t)v2, v16, v15, v18, a2);
      }
      v16 = v15 + 1;
      v15 = ucptrie_getRange(a1, v15 + 1, 0, 0, 0, 0, (int *)&v18);
    }
    while ((v15 & 0x80000000) == 0);
  }
  if (*a2 >= 1)
  {
LABEL_23:
    v17 = sub_18BC43C60(v2);
    icu::UMemory::operator delete(v17);
    return 0;
  }
  return v2;
}

uint64_t umutablecptrie_get(uint64_t a1, unsigned int a2)
{
  unsigned int *v2;
  uint64_t v3;

  if (a2 < 0x110000)
  {
    if (*(_DWORD *)(a1 + 48) <= (signed int)a2)
    {
      v2 = (unsigned int *)(a1 + 52);
    }
    else
    {
      v3 = a2 >> 4;
      if (*(_BYTE *)(a1 + v3 + 64))
        v2 = (unsigned int *)(*(_QWORD *)(a1 + 16) + 4 * (*(_DWORD *)(*(_QWORD *)a1 + 4 * v3) + (a2 & 0xF)));
      else
        v2 = (unsigned int *)(*(_QWORD *)a1 + 4 * v3);
    }
  }
  else
  {
    v2 = (unsigned int *)(a1 + 44);
  }
  return *v2;
}

uint64_t umutablecptrie_getRange(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, int *a7)
{
  return sub_18BC2FB18((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, int *))sub_18BC4405C, a1, a2, a3, a4, a5, a6, a7);
}

uint64_t sub_18BC4405C(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, _DWORD *a5)
{
  uint64_t v5;
  uint64_t v9;
  int v11;
  uint64_t v12;
  int v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  char v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;

  if (WORD1(a2) > 0x10u)
    return 0xFFFFFFFFLL;
  v9 = a2;
  v5 = 1114111;
  if (*(_DWORD *)(a1 + 48) <= (int)a2)
  {
    if (a5)
    {
      v30 = *(unsigned int *)(a1 + 52);
      if (a3)
        LODWORD(v30) = a3(a4, v30);
      *a5 = v30;
    }
    return v5;
  }
  v11 = *(_DWORD *)(a1 + 40);
  if (a3)
    v11 = a3(a4, *(unsigned int *)(a1 + 40));
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = v9 >> 4;
  while (1)
  {
    v16 = *(unsigned int *)(*(_QWORD *)a1 + 4 * v15);
    if (!*(_BYTE *)(a1 + v15 + 64))
    {
      if ((v14 & 1) != 0)
      {
        if ((_DWORD)v16 == (_DWORD)v12)
        {
          v16 = v12;
        }
        else
        {
          if (!a3)
            return (v9 - 1);
          v26 = v11;
          if ((_DWORD)v16 != *(_DWORD *)(a1 + 40))
            v26 = a3(a4, *(unsigned int *)(*(_QWORD *)a1 + 4 * v15));
          if (v26 != v13)
            return (v9 - 1);
        }
      }
      else
      {
        v20 = *(_DWORD *)(a1 + 40);
        if ((_DWORD)v16 == v20)
          v13 = v11;
        else
          v13 = *(_DWORD *)(*(_QWORD *)a1 + 4 * v15);
        if (a3 && (_DWORD)v16 != v20)
          v13 = a3(a4, *(unsigned int *)(*(_QWORD *)a1 + 4 * v15));
        if (a5)
          *a5 = v13;
      }
      v9 = (v9 & 0xFFFFFFF0) + 16;
      goto LABEL_49;
    }
    v17 = v16 + (v9 & 0xF);
    v18 = *(_QWORD *)(a1 + 16);
    v16 = *(unsigned int *)(v18 + 4 * v17);
    if ((v14 & 1) != 0)
    {
      if ((_DWORD)v16 == (_DWORD)v12)
      {
        v16 = v12;
      }
      else
      {
        if (!a3)
          return (v9 - 1);
        v21 = v11;
        if ((_DWORD)v16 != *(_DWORD *)(a1 + 40))
          v21 = a3(a4, *(unsigned int *)(v18 + 4 * v17));
        if (v21 != v13)
          return (v9 - 1);
      }
    }
    else
    {
      v19 = *(_DWORD *)(a1 + 40);
      if ((_DWORD)v16 == v19)
        v13 = v11;
      else
        v13 = *(_DWORD *)(v18 + 4 * v17);
      if (a3 && (_DWORD)v16 != v19)
        v13 = a3(a4, *(unsigned int *)(v18 + 4 * v17));
      if (a5)
        *a5 = v13;
    }
    if ((((_BYTE)v9 + 1) & 0xF) != 0)
      break;
    v9 = (v9 + 1);
LABEL_49:
    ++v15;
    v14 = 1;
    v12 = v16;
    if ((int)v9 >= *(_DWORD *)(a1 + 48))
    {
      v27 = *(_DWORD *)(a1 + 52);
      v28 = *(_DWORD *)(a1 + 40);
      if (v27 == v28)
        v29 = v11;
      else
        v29 = *(_DWORD *)(a1 + 52);
      if (a3 && v27 != v28)
        v29 = ((uint64_t (*)(uint64_t))a3)(a4);
      if (v29 == v13)
        return 1114111;
      else
        return (v9 - 1);
    }
  }
  v22 = 4 * v17 + 4;
  while (1)
  {
    v23 = v16;
    v16 = *(unsigned int *)(*(_QWORD *)(a1 + 16) + v22);
    if ((_DWORD)v16 != v23)
    {
      if (!a3)
        return v9;
      v24 = v11;
      if ((_DWORD)v16 != *(_DWORD *)(a1 + 40))
        v24 = a3(a4, *(unsigned int *)(*(_QWORD *)(a1 + 16) + v22));
      if (v24 != v13)
        return v9;
    }
    v25 = v9 + 2;
    v9 = (v9 + 1);
    v22 += 4;
    if ((v25 & 0xF) == 0)
    {
      v9 = (v9 + 1);
      goto LABEL_49;
    }
  }
}

uint64_t umutablecptrie_set(uint64_t result, unsigned int a2, int a3, int *a4)
{
  if (*a4 <= 0)
    return sub_18BC44300(result, a2, a3, a4);
  return result;
}

uint64_t sub_18BC44300(uint64_t result, unsigned int a2, int a3, int *a4)
{
  int v6;
  _QWORD *v8;

  if (*a4 <= 0)
  {
    if (a2 < 0x110000)
    {
      v8 = (_QWORD *)result;
      result = sub_18BC45E38(result, a2);
      if ((_DWORD)result)
      {
        result = sub_18BC45EF8(v8, a2 >> 4);
        if ((result & 0x80000000) == 0)
        {
          *(_DWORD *)(v8[2] + 4 * (result + (a2 & 0xF))) = a3;
          return result;
        }
      }
      v6 = 7;
    }
    else
    {
      v6 = 1;
    }
    *a4 = v6;
  }
  return result;
}

uint64_t umutablecptrie_setRange(uint64_t result, unsigned int a2, int a3, unsigned int a4, int *a5)
{
  if (*a5 <= 0)
    return sub_18BC44398(result, a2, a3, a4, a5);
  return result;
}

uint64_t sub_18BC44398(uint64_t result, unsigned int a2, int a3, unsigned int a4, int *a5)
{
  unint64_t v7;
  int v8;
  _QWORD *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int *v15;
  uint64_t v16;
  int32x4_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int *v22;

  if (*a5 > 0)
    return result;
  LODWORD(v7) = a2;
  v8 = 1;
  if ((int)a2 > a3 || a2 > 0x10FFFF || a3 > 0x10FFFF)
  {
LABEL_29:
    *a5 = v8;
    return result;
  }
  v10 = (_QWORD *)result;
  result = sub_18BC45E38(result, a3);
  if (!(_DWORD)result)
    goto LABEL_28;
  v11 = a3 + 1;
  v12 = v7 & 0xF;
  if ((v7 & 0xF) == 0)
    goto LABEL_15;
  result = sub_18BC45EF8(v10, v7 >> 4);
  if ((result & 0x80000000) != 0)
  {
LABEL_28:
    v8 = 7;
    goto LABEL_29;
  }
  LODWORD(v7) = (v7 + 15) & 0xFFFFFFF0;
  v13 = v10[2] + 4 * result;
  if (v7 > v11)
  {
    if (v12 < (v11 & 0xF))
    {
      v14 = v13 + 4 * (v11 & 0xF);
      v15 = (unsigned int *)(v13 + 4 * v12);
      do
        *v15++ = a4;
      while ((unint64_t)v15 < v14);
    }
    return result;
  }
  v16 = 4 * v12;
  do
  {
    *(_DWORD *)(v13 + v16) = a4;
    v16 += 4;
  }
  while (v16 != 64);
LABEL_15:
  if ((int)v7 < (int)(v11 & 0xFFFFFFF0))
  {
    v7 = v7;
    v17 = vdupq_n_s32(a4);
    do
    {
      v18 = v7 >> 4;
      if (*((_BYTE *)v10 + (v7 >> 4) + 64))
      {
        v19 = 0;
        v20 = v10[2] + 4 * *(unsigned int *)(*v10 + 4 * v18);
        do
        {
          *(int32x4_t *)(v20 + v19) = v17;
          v19 += 16;
        }
        while (v19 != 64);
      }
      else
      {
        *(_DWORD *)(*v10 + 4 * v18) = a4;
      }
      v7 += 16;
    }
    while ((int)(v11 & 0xFFFFFFF0) > (int)v7);
  }
  if ((v11 & 0xF) != 0)
  {
    result = sub_18BC45EF8(v10, v7 >> 4);
    if ((result & 0x80000000) == 0)
    {
      v21 = (unsigned int *)(v10[2] + 4 * result);
      v22 = &v21[v11 & 0xF];
      do
        *v21++ = a4;
      while (v21 < v22);
      return result;
    }
    goto LABEL_28;
  }
  return result;
}

char *umutablecptrie_buildImmutable()
{
  int8x8_t *v0;
  unsigned int v1;
  unsigned int v2;
  int *v3;
  char *v4;
  int8x8_t *v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int8x8_t v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  __int32 *v15;
  _DWORD *v16;
  __int32 v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unint64_t v25;
  _DWORD *v26;
  _BYTE *v27;
  unint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  int v31;
  signed int v32;
  int v33;
  int v34;
  int v35;
  int8x8_t v36;
  uint64_t v37;
  char *v38;
  _BYTE *v39;
  int v40;
  int *v41;
  _DWORD *v42;
  int v43;
  _DWORD *v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  int v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  char *v56;
  uint64_t v57;
  int v58;
  int v59;
  _DWORD *v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  uint64_t v66;
  unsigned int v67;
  _DWORD *v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  int v74;
  int v75;
  int8x8_t v76;
  unsigned int v77;
  unsigned int v78;
  int v79;
  signed int v80;
  int v81;
  int v82;
  int v83;
  _DWORD *v84;
  _DWORD *v85;
  int8x8_t v86;
  unsigned int v87;
  int *v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  unsigned int v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  _DWORD *v100;
  uint64_t v101;
  _DWORD *v102;
  int *v103;
  uint64_t v104;
  int v105;
  int v106;
  int v107;
  int v108;
  unint64_t v109;
  uint64_t v110;
  BOOL v111;
  int v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unsigned int *v119;
  int v120;
  int v121;
  uint64_t v122;
  int *v123;
  uint64_t v124;
  int v125;
  unsigned int v126;
  __int32 v127;
  int v129;
  int v130;
  int v131;
  int8x8_t v132;
  int8x8_t v133;
  __int32 v134;
  int v135;
  __int32 v136;
  __int32 v137;
  uint64_t v138;
  __int32 v139;
  int8x8_t v140;
  __int32 v141;
  __int32 v142;
  __int32 v143;
  __int32 v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  int8x8_t v148;
  int v149;
  uint64_t v150;
  int v151;
  int8x8_t v152;
  int v153;
  int v154;
  uint64_t i;
  int v156;
  unint64_t v157;
  int v158;
  char v159;
  int v160;
  __int32 v161;
  int64_t v162;
  uint64_t v163;
  uint64_t v164;
  int64_t v165;
  uint64_t v166;
  const float *v167;
  int32x4_t v168;
  int8x16_t v169;
  int8x16_t v170;
  int8x16_t v171;
  int8x16_t v172;
  int8x16_t v173;
  int32x4_t v174;
  int32x4_t v175;
  int32x4_t v176;
  int32x4_t v177;
  int8x16_t v178;
  unsigned __int32 v179;
  int v180;
  _BYTE *v181;
  unsigned __int32 v182;
  BOOL v183;
  BOOL v184;
  int v185;
  __int32 v186;
  uint64_t v187;
  __int32 v188;
  __int32 v189;
  char *v190;
  char **v191;
  signed int v192;
  __int32 v193;
  uint64_t v194;
  __int32 v195;
  char *v196;
  char *v197;
  int *v198;
  int v199;
  char *v200;
  int *v201;
  unsigned int v202;
  int v203;
  unsigned int v204;
  int v205;
  __int32 v206;
  uint64_t v207;
  int v208;
  void *v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  int v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  int8x8_t v220;
  uint64_t v221;
  uint64_t v222;
  int16x8_t *v223;
  int16x8_t *v224;
  unint64_t v225;
  int16x8_t v226;
  int16x8_t v227;
  int v228;
  int v229;
  uint64_t v230;
  unint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  unint64_t v238;
  int v239;
  unsigned __int16 *v240;
  int v241;
  unsigned __int16 *v242;
  int8x8_t v243;
  int v244;
  uint64_t v245;
  uint64_t v246;
  _WORD *v247;
  uint64_t v248;
  int v249;
  uint64_t v250;
  int v251;
  uint64_t v252;
  int v253;
  int v254;
  int v255;
  int v256;
  uint64_t v257;
  unsigned __int16 *v258;
  int v259;
  unsigned __int16 *v260;
  int v261;
  uint64_t v262;
  uint64_t v263;
  unsigned __int16 *v264;
  int v265;
  unsigned __int16 *v266;
  uint64_t v267;
  int v268;
  unsigned int v269;
  uint64_t v270;
  int8x8_t v271;
  unsigned int v272;
  unsigned int v273;
  int v274;
  uint64_t v275;
  unsigned int v276;
  unsigned int v277;
  unsigned int v278;
  char v279;
  int v280;
  int *v281;
  unsigned int v282;
  uint64_t v283;
  int v284;
  int v285;
  int v286;
  uint64_t v287;
  uint64_t v288;
  void *v289[2];
  __int128 v290;
  _OWORD v291[24];
  uint64_t v292;
  void *v293[2];
  __int128 v294;
  _OWORD __src[32];
  _WORD v296[2176];
  _WORD v297[1024];
  uint64_t v298;

  v0 = (int8x8_t *)MEMORY[0x1E0C80A78]();
  v298 = *MEMORY[0x1E0C80C00];
  if (*v3 <= 0)
  {
    if (v1 > 1 || v2 >= 3)
    {
      v4 = 0;
      *v3 = 1;
      return v4;
    }
    v5 = v0;
    if (v2)
    {
      if (v2 != 2)
        goto LABEL_18;
      v6 = 255;
    }
    else
    {
      v6 = 0xFFFF;
    }
    v0[5] = vand_s8(v0[5], (int8x8_t)vdup_n_s32(v6));
    v7 = v0[6].u32[0];
    v0[6].i32[1] &= v6;
    if ((int)v7 >= 16)
    {
      v8 = 0;
      v9 = v7 >> 4;
      do
      {
        if (!v0[8].i8[v8])
          *(_DWORD *)(*(_QWORD *)v0 + 4 * v8) &= v6;
        ++v8;
      }
      while (v9 != v8);
    }
    if (v0[3].i32[1] >= 1)
    {
      v10 = 0;
      v11 = v0[2];
      do
        *(_DWORD *)(*(_QWORD *)&v11 + 4 * v10++) &= v6;
      while (v10 < v0[3].i32[1]);
    }
LABEL_18:
    v277 = v2;
    if (v1)
      v12 = 4096;
    else
      v12 = 0x10000;
    v13 = v12 >> 4;
    v14 = v0[6].u32[0];
    if ((int)v14 < 1114112)
    {
      v16 = (_DWORD *)&v0[6] + 1;
      v17 = v0[6].i32[1];
      if ((int)v14 < 16)
      {
LABEL_25:
        v18 = 0;
        goto LABEL_41;
      }
    }
    else
    {
      if (v0[8711].i8[7])
        v15 = (__int32 *)(*(_QWORD *)&v0[2] + 4 * (*(_DWORD *)(*(_QWORD *)v0 + 278524) + 15));
      else
        v15 = (__int32 *)(*(_QWORD *)v0 + 278524);
      v17 = *v15;
      v0[6].i32[1] = *v15;
      v16 = (_DWORD *)&v0[6] + 1;
    }
    v19 = v14 >> 4;
    while (1)
    {
      v20 = (v19 - 1);
      if (v0[8].i8[v20])
        break;
      if (*(_DWORD *)(*(_QWORD *)v0 + 4 * v20) != v17)
        goto LABEL_38;
LABEL_35:
      v111 = v19-- <= 1;
      if (v111)
        goto LABEL_25;
    }
    v21 = 0;
    v22 = *(_QWORD *)&v0[2] + 4 * *(unsigned int *)(*(_QWORD *)v0 + 4 * v20);
    while (*(_DWORD *)(v22 + v21) == v17)
    {
      v21 += 4;
      if (v21 == 64)
        goto LABEL_35;
    }
LABEL_38:
    v18 = (16 * v19 + 511) & 0x7FFFFE00;
    if (v18 == 1114112)
    {
      v0[6].i32[1] = v0[5].i32[0];
      v23 = 1114112;
      goto LABEL_45;
    }
    v23 = (16 * v19 + 511) & 0x7FFFFE00;
    if (v18 >= v12)
    {
LABEL_45:
      v281 = v3;
      v28 = 0;
      v0[6].i32[0] = v23;
      memset(__src, 0, sizeof(__src));
      do
      {
        v29 = v16;
        if (v28 < v23)
        {
          v30 = v28 >> 4;
          if (v0[8].i8[v30])
            v29 = (_DWORD *)(*(_QWORD *)&v0[2] + 4
                                               * (*(_DWORD *)(*(_QWORD *)v0 + 4 * v30) + (v28 & 0xF)));
          else
            v29 = (_DWORD *)(*(_QWORD *)v0 + 4 * v30);
        }
        *((_DWORD *)__src + v28++) = *v29;
      }
      while (v28 != 128);
      v269 = v18;
      v272 = v1;
      v273 = v12;
      v292 = 0;
      memset(v291, 0, sizeof(v291));
      DWORD1(v291[0]) = -1;
      if (!v23)
      {
        v33 = 148;
        goto LABEL_109;
      }
      v31 = 0;
      v32 = v23 >> 4;
      v33 = 148;
      v34 = 64;
      v35 = 4;
      while (1)
      {
        if (v31 == (_DWORD)v13)
        {
          v34 = 16;
          v35 = 1;
        }
        v36 = *v5;
        v37 = *(unsigned int *)(*(_QWORD *)v5 + 4 * v31);
        v38 = (char *)v5 + v31;
        v40 = v38[64];
        v39 = v38 + 64;
        if (v40 == 1)
        {
          v41 = (int *)(*(_QWORD *)&v5[2] + 4 * v37);
          v43 = *v41;
          v42 = v41 + 1;
          LODWORD(v37) = v43;
          v44 = &v42[v34 - 1];
          do
          {
            if (*v42 != (_DWORD)v37)
              break;
            ++v42;
          }
          while (v42 < v44);
          if (v42 != v44)
            goto LABEL_93;
          *v39 = 0;
          v36 = *v5;
          *(_DWORD *)(*(_QWORD *)v5 + 4 * v31) = v37;
        }
        else if (v35 >= 2)
        {
          v45 = v31 + 1;
          do
          {
            if (v45 >= v35 + v31)
              goto LABEL_67;
            v46 = *(_DWORD *)(*(_QWORD *)&v36 + 4 * v45++);
          }
          while (v46 == (_DWORD)v37);
          v47 = sub_18BC45EF8(v5, v31);
          if (v47 < 0)
            goto LABEL_117;
          v33 += v34 & ~(v47 >> 31);
          goto LABEL_94;
        }
LABEL_67:
        v48 = DWORD1(v291[0]);
        if ((DWORD1(v291[0]) & 0x80000000) != 0 || *((_DWORD *)&v291[8] + DWORD1(v291[0]) + 2) != (_DWORD)v37)
          break;
LABEL_76:
        v50 = (char *)v291 + 4 * v48;
        *((_DWORD *)v50 + 66) += v35;
        v51 = *((_DWORD *)v50 + 2);
        if (v51 == -2)
        {
LABEL_77:
          if (!v31)
          {
LABEL_84:
            if (SLODWORD(v291[0]) < 1)
            {
              v54 = -1;
            }
            else
            {
              v53 = 0;
              v54 = -1;
              v55 = 69632;
              do
              {
                if (*((_DWORD *)&v291[16] + v53 + 2) < v55)
                {
                  v54 = v53;
                  v55 = *((_DWORD *)&v291[16] + v53 + 2);
                }
                ++v53;
              }
              while (LODWORD(v291[0]) != v53);
            }
            DWORD1(v291[0]) = v54;
            v49 = v54;
            v56 = (char *)v291 + 4 * v54;
            *((_DWORD *)v56 + 2) = v31;
            *((_DWORD *)v56 + 34) = v37;
LABEL_92:
            *((_DWORD *)&v291[16] + v49 + 2) = v35;
            goto LABEL_93;
          }
          v51 = 0;
          v52 = 4;
          while (1)
          {
            if (v51 == (_DWORD)v13)
              v52 = 1;
            if (!v5[8].i8[v51] && *(_DWORD *)(*(_QWORD *)&v36 + 4 * v51) == (_DWORD)v37)
              break;
            v51 += v52;
            if (v51 == v31)
              goto LABEL_84;
          }
          if (SLODWORD(v291[0]) < 1)
          {
            v58 = -1;
          }
          else
          {
            v57 = 0;
            v58 = -1;
            v59 = 69632;
            do
            {
              if (*((_DWORD *)&v291[16] + v57 + 2) < v59)
              {
                v58 = v57;
                v59 = *((_DWORD *)&v291[16] + v57 + 2);
              }
              ++v57;
            }
            while (LODWORD(v291[0]) != v57);
          }
          DWORD1(v291[0]) = v58;
          v60 = (_DWORD *)v291 + v58;
          v60[2] = v51;
          v60[34] = v37;
          v60[66] = v52 + v35;
        }
        if ((v51 & 0x80000000) == 0)
        {
          *v39 = 2;
          *(_DWORD *)(*(_QWORD *)v5 + 4 * v31) = v51;
          goto LABEL_94;
        }
LABEL_93:
        v33 += v34;
LABEL_94:
        v31 += v35;
        if (v31 >= v32)
        {
          if (v33 < 0)
          {
LABEL_117:
            *v281 = 7;
            goto LABEL_207;
          }
LABEL_109:
          v61 = uprv_malloc(4 * v33);
          if (!v61)
            goto LABEL_117;
          v62 = (uint64_t)v61;
          memcpy(v61, __src, 0x200uLL);
          if (LODWORD(v291[0]))
          {
            if (SLODWORD(v291[0]) < 1)
            {
              v66 = -1;
            }
            else
            {
              v63 = 0;
              v64 = 0;
              v65 = -1;
              do
              {
                if (*((_DWORD *)&v291[16] + v63 + 2) > v64)
                {
                  v65 = v63;
                  v64 = *((_DWORD *)&v291[16] + v63 + 2);
                }
                ++v63;
              }
              while (LODWORD(v291[0]) != v63);
              v66 = v65;
            }
            v67 = *((_DWORD *)v291 + v66 + 2);
          }
          else
          {
            v67 = -1;
          }
          *(_OWORD *)v289 = 0u;
          v290 = 0u;
          v68 = (_DWORD *)*v5;
          *v68 = 0;
          v68[4] = 64;
          if (!sub_18BC460B0((uint64_t)v289, v33, 64))
          {
LABEL_203:
            LODWORD(v124) = 0;
            v125 = 7;
            v123 = v281;
LABEL_204:
            *v123 = v125;
LABEL_205:
            v126 = v277;
            goto LABEL_206;
          }
          LODWORD(v69) = 128;
          sub_18BC46198((uint64_t)v289, v62, 0, 128);
          v70 = v5[6].i32[0];
          if (v70 >= 144)
          {
            v71 = 0;
            v72 = v70 >> 4;
            v69 = 128;
            v73 = 64;
            v74 = 4;
            v75 = 8;
            v274 = v70 >> 4;
            v276 = v67;
            do
            {
              if (v75 == (_DWORD)v13)
              {
                if (!sub_18BC460B0((uint64_t)v289, v33, 16))
                  goto LABEL_203;
                sub_18BC46198((uint64_t)v289, v62, 0, v69);
                v74 = 1;
                v73 = 16;
                v71 = v69;
              }
              if (v5[8].i8[v75] == 1)
              {
                v282 = v73;
                v284 = v74;
                v278 = v71;
                v86 = *v5;
                v270 = 4 * *(unsigned int *)(*(_QWORD *)v5 + 4 * v75);
                v271 = v5[2];
                v88 = (int *)(*(_QWORD *)&v271 + v270 + 4);
                v87 = *(_DWORD *)(*(_QWORD *)&v271 + v270);
                if (SDWORD2(v290) <= 2)
                  v89 = 2;
                else
                  v89 = DWORD2(v290);
                v90 = v89 - 1;
                do
                {
                  v91 = *v88++;
                  v87 = v91 + 37 * v87;
                  --v90;
                }
                while (v90);
                v92 = sub_18BC46258((uint64_t)v289, v62, *(_QWORD *)&v271 + v270, 0, v87);
                if ((v92 & 0x80000000) != 0 || (v93 = (DWORD1(v290) & *((_DWORD *)v289[0] + v92)) - 1, v93 < 0))
                {
                  v94 = 4 * (int)v69;
                  v95 = v94 - 4 * v282 + 4;
                  v96 = v282;
                  do
                  {
                    v97 = v96--;
                    v98 = v95;
                    v99 = v97;
                    v100 = (_DWORD *)(*(_QWORD *)&v271 + v270);
                    while (*(_DWORD *)(v62 + v98) == *v100)
                    {
                      ++v100;
                      --v99;
                      v98 += 4;
                      if (v99 <= 1)
                        goto LABEL_157;
                    }
                    v95 += 4;
                  }
                  while (v97 >= 3);
                  LODWORD(v96) = 0;
LABEL_157:
                  *(_DWORD *)(*(_QWORD *)&v86 + 4 * v75) = v69 - v96;
                  v101 = v69;
                  v67 = v276;
                  if ((int)v96 < (int)v282)
                  {
                    v102 = (_DWORD *)(v62 + v94);
                    v103 = (int *)(*(_QWORD *)&v271 + v270 + 4 * (int)v96);
                    v104 = v282 - (uint64_t)(int)v96;
                    v101 = v69 + v282 - v96;
                    do
                    {
                      v105 = *v103++;
                      *v102++ = v105;
                      --v104;
                    }
                    while (v104);
                  }
                  sub_18BC46198((uint64_t)v289, v62, v69, v101);
                  v73 = v282;
                  v69 = v101;
                  v72 = v274;
                  v71 = v278;
                  v74 = v284;
                }
                else
                {
                  *(_DWORD *)(*(_QWORD *)&v86 + 4 * v75) = v93;
                  v67 = v276;
                  v72 = v274;
                  v71 = v278;
                  v74 = v284;
                  v73 = v282;
                }
                goto LABEL_200;
              }
              if (v5[8].i8[v75])
              {
                *(_DWORD *)(*(_QWORD *)v5 + 4 * v75) = *(_DWORD *)(*(_QWORD *)v5
                                                                   + 4 * *(unsigned int *)(*(_QWORD *)v5 + 4 * v75));
              }
              else
              {
                v76 = *v5;
                v77 = *(_DWORD *)(*(_QWORD *)v5 + 4 * v75);
                v78 = v77;
                if (SDWORD2(v290) >= 2)
                {
                  v79 = DWORD2(v290) - 1;
                  v78 = *(_DWORD *)(*(_QWORD *)v5 + 4 * v75);
                  do
                  {
                    v78 = v77 + 37 * v78;
                    --v79;
                  }
                  while (v79);
                }
                v80 = v78 % (HIDWORD(v289[1]) - 1) + 1;
                v81 = *((_DWORD *)v289[0] + v80);
                if (v81)
                {
                  v82 = v78 << v290;
                  v83 = v78 % (HIDWORD(v289[1]) - 1) + 1;
                  while (1)
                  {
                    if ((v81 & ~DWORD1(v290)) == v82)
                    {
                      v84 = (_DWORD *)(v62 + 4 * ((v81 & DWORD1(v290)) - 1));
                      v85 = &v84[SDWORD2(v290)];
                      if (SDWORD2(v290) >= 1)
                      {
                        do
                        {
                          if (*v84 != v77)
                            break;
                          ++v84;
                        }
                        while (v84 < v85);
                      }
                      if (v84 == v85)
                        break;
                    }
                    v83 = (v83 + v80) % SHIDWORD(v289[1]);
                    v81 = *((_DWORD *)v289[0] + v83);
                    if (!v81)
                      goto LABEL_162;
                  }
                }
                else
                {
                  v83 = v78 % (HIDWORD(v289[1]) - 1) + 1;
LABEL_162:
                  v83 = ~v83;
                }
                if (v83 < 0)
                  v106 = -1;
                else
                  v106 = (DWORD1(v290) & *((_DWORD *)v289[0] + v83)) - 1;
                v107 = v106 >> 31;
                if (v75 == v67 && v75 >= (int)v13 && (v106 & 0x80000000) == 0 && v106 < (int)v71)
                {
                  v108 = v69 - v73;
                  while (1)
                  {
                    v109 = 0;
                    while (*(_DWORD *)(*(_QWORD *)&v76 + 4 * v109) != v106)
                    {
                      v109 += 4;
                      if (v109 >= v13)
                        goto LABEL_194;
                    }
                    if (v108 <= v106)
                      break;
                    v107 = v106;
                    while (1)
                    {
                      v106 = v107 + 1;
                      if (*(_DWORD *)(v62 + 4 * (v107 + 1)) == v77)
                        break;
LABEL_183:
                      v107 = v106;
                      if (v106 >= v108)
                        goto LABEL_188;
                    }
                    v110 = 0;
                    do
                    {
                      if (*(_DWORD *)(v62 + 8 + 4 * v107 + 4 * v110) != v77)
                      {
                        v106 = v107 + v110 + 2;
                        goto LABEL_183;
                      }
                      ++v110;
                    }
                    while (v73 - 1 != v110);
                    v111 = v107 < -1;
                    LOBYTE(v107) = v107 < -1;
                    if (v111 || v106 >= (int)v71)
                      goto LABEL_187;
                  }
LABEL_188:
                  v112 = v69 + 1;
                  v113 = v69 + 1 - v73;
                  v114 = v113;
                  if ((int)v69 < v113)
                    v113 = v69;
                  v115 = (int)v69;
                  while (v115 > v114)
                  {
                    v116 = v62 + 4 * v115--;
                    --v112;
                    if (*(_DWORD *)(v116 - 4) != v77)
                      goto LABEL_196;
                  }
                  v112 = v113;
LABEL_196:
                  v285 = v74;
                  v117 = v71;
                  *(_DWORD *)(*(_QWORD *)&v76 + 4 * v75) = v112;
                  v118 = v69;
                  if ((int)v69 - v112 < (int)v73)
                  {
                    v119 = (unsigned int *)(v62 + 4 * (int)v69);
                    v120 = v112 + v73;
                    LODWORD(v118) = v69;
                    do
                    {
                      *v119++ = v77;
                      v118 = (v118 + 1);
                    }
                    while (v120 != (_DWORD)v118);
                  }
                  v121 = v69;
                  v122 = v73;
                  sub_18BC46198((uint64_t)v289, v62, v121, v118);
                  v73 = v122;
                  v69 = v118;
                  v72 = v274;
                  v71 = v117;
                  v74 = v285;
                  v67 = v276;
                  goto LABEL_200;
                }
LABEL_187:
                if ((v107 & 1) != 0)
                  goto LABEL_188;
LABEL_194:
                *(_DWORD *)(*(_QWORD *)&v76 + 4 * v75) = v106;
              }
LABEL_200:
              v75 += v74;
            }
            while (v75 < v72);
          }
          v123 = v281;
          if (*v281 > 0)
          {
            LODWORD(v124) = 0;
            goto LABEL_205;
          }
          uprv_free(*(void **)&v5[2]);
          v5[2] = (int8x8_t)v62;
          v5[3].i32[0] = v33;
          v5[3].i32[1] = v69;
          if ((int)v69 >= 262160)
          {
            LODWORD(v124) = 0;
            v125 = 8;
            goto LABEL_204;
          }
          if ((v67 & 0x80000000) != 0)
          {
            LODWORD(v138) = 0xFFFFF;
          }
          else
          {
            v138 = *(int *)(*(_QWORD *)v5 + 4 * v67);
            v5[5].i32[0] = *(_DWORD *)(v62 + 4 * v138);
          }
          v5[4].i32[0] = v138;
          v124 = v273 >> 6;
          if ((int)v124 >= v5[6].i32[0] >> 6)
          {
            v5[1].i32[1] = 0x7FFF;
            goto LABEL_368;
          }
          bzero(v297, 0x800uLL);
          v146 = 0;
          v147 = 0;
          v148 = *v5;
          if ((int)v13 <= 4)
            v149 = 4;
          else
            v149 = v13;
          v150 = ((v149 - 1) >> 2) + 1;
          v151 = -1;
          v152 = *v5;
          do
          {
            v153 = *(_DWORD *)(*(_QWORD *)&v148 + 4 * v146);
            v297[v147] = v153;
            if (v153 == v5[4].i32[0])
            {
              if (v151 < 0)
              {
                v151 = v147;
              }
              else if (v5[1].i32[1] < 0 && (_DWORD)v147 - v151 == 31)
              {
                v5[1].i32[1] = v151;
              }
            }
            else
            {
              v151 = -1;
            }
            v146 += 4;
            v154 = v153 + 16;
            for (i = 4; i != 16; i += 4)
            {
              *(_DWORD *)(*(_QWORD *)&v152 + i) = v154;
              v154 += 16;
            }
            ++v147;
            *(_QWORD *)&v152 += 16;
          }
          while (v147 != v150);
          if ((sub_18BC460B0((uint64_t)v289, v124, 32) & 1) == 0)
            goto LABEL_365;
          v156 = v272 == 0;
          sub_18BC4630C((uint64_t)v289, (uint64_t)v297, 0, 0, v124);
          v157 = (v156 << 12);
          v158 = v5[6].i32[0] >> 4;
          v286 = v158;
          if (v158 <= v156 << 12)
          {
            v160 = 0;
            v159 = 0;
          }
          else
          {
            v159 = 0;
            v160 = 0;
            v161 = v5[1].i32[1];
            v162 = v158;
            v163 = (uint64_t)*v5;
            v164 = *(_QWORD *)v5 + 4 * v157;
            v165 = v157;
            do
            {
              v166 = 0;
              v167 = (const float *)&v5[4];
              v168 = (int32x4_t)vld1q_dup_f32(v167);
              v169 = 0uLL;
              v170.i64[0] = 0x101010101010101;
              v170.i64[1] = 0x101010101010101;
              v171 = 0uLL;
              v172 = 0uLL;
              v173 = 0uLL;
              do
              {
                v174 = *(int32x4_t *)(v164 + v166);
                v175 = *(int32x4_t *)(v164 + v166 + 16);
                v177 = *(int32x4_t *)(v164 + v166 + 32);
                v176 = *(int32x4_t *)(v164 + v166 + 48);
                v172 = vorrq_s8((int8x16_t)v177, v172);
                v171 = vorrq_s8((int8x16_t)v175, v171);
                v169 = vorrq_s8((int8x16_t)v174, v169);
                v173 = vorrq_s8((int8x16_t)v176, v173);
                v170 = vandq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqq_s32(v174, v168), (int16x8_t)vceqq_s32(v175, v168)), (int8x16_t)vuzp1q_s16((int16x8_t)vceqq_s32(v177, v168), (int16x8_t)vceqq_s32(v176, v168))), v170);
                v166 += 64;
              }
              while (v166 != 128);
              v178 = vorrq_s8(vorrq_s8(v169, v172), vorrq_s8(v171, v173));
              *(int8x8_t *)v178.i8 = vorr_s8(*(int8x8_t *)v178.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v178, v178, 8uLL));
              v179 = v178.i32[0] | v178.i32[1];
              if ((vmaxvq_u8((uint8x16_t)vcltzq_s8(vshlq_n_s8(vmvnq_s8(v170), 7uLL))) & 1) != 0)
              {
                if (HIWORD(v179))
                {
                  v5[8].i8[v165] = 3;
                  v160 += 36;
                  v159 = 1;
                }
                else
                {
                  v180 = sub_18BC463D0((uint64_t *)v289, (uint64_t)v297, v163, v165);
                  v181 = (char *)&v5[8] + v165;
                  if (v180 < 0)
                  {
                    *v181 = 2;
                    v160 += 32;
                  }
                  else
                  {
                    *v181 = 1;
                    *(_DWORD *)(v163 + 4 * v165) = v180;
                  }
                }
              }
              else
              {
                v5[8].i8[v165] = 0;
                if (v161 < 0)
                {
                  v161 = 0;
                  v182 = HIWORD(v179);
                  v183 = v182 == 0;
                  v184 = v182 != 0;
                  if (v183)
                    v185 = 32;
                  else
                    v185 = 36;
                  v160 += v185;
                  v159 |= v184;
                }
              }
              v165 += 32;
              v164 += 128;
            }
            while (v165 < v162);
          }
          v207 = (v124 + ((((v286 - (int)v157) >> 5) + 31) >> 5));
          v208 = v207 + ((v286 - (int)v157) >> 5) + v160 + 1;
          v209 = uprv_malloc(2 * v208);
          v5[7] = (int8x8_t)v209;
          if (v209)
          {
            memcpy(v209, v297, v273 >> 5);
            v123 = v281;
            if ((sub_18BC460B0((uint64_t)v289, v208, 32) & 1) != 0)
            {
              *(_OWORD *)v293 = 0u;
              v294 = 0u;
              if ((v159 & 1) != 0 && (sub_18BC460B0((uint64_t)v293, v208, 36) & 1) == 0)
              {
                LODWORD(v124) = 0;
                *v281 = 7;
              }
              else
              {
                v279 = v159;
                bzero(v296, 0x1100uLL);
                v210 = v5[1].u32[1];
                v283 = (v124 + ((((v286 - (int)v157) >> 5) + 31) >> 5));
                if (v286 > (int)v157)
                {
                  v211 = 0;
                  v287 = ((v286 + ~(_DWORD)v157) >> 5) + 1;
                  v275 = (int)v207;
                  v212 = v207;
                  v213 = 4 * v157;
                  v214 = v212;
                  v215 = v5[1].u32[1];
                  while (1)
                  {
                    v216 = v5[8].u8[v157];
                    if (!v5[8].i8[v157] && (v215 & 0x80000000) != 0)
                      break;
                    if (v5[8].i8[v157])
                    {
                      if (v216 == 2)
                        goto LABEL_320;
                      if (v216 != 1)
                      {
LABEL_322:
                        v222 = (uint64_t)v5[7];
                        v223 = (int16x8_t *)(v222 + 2 * (int)v214 + 2);
                        v224 = (int16x8_t *)(*(_QWORD *)v5 + v213);
                        v225 = v157;
                        do
                        {
                          v226 = *v224;
                          v227 = v224[1];
                          v224 += 2;
                          v225 += 8;
                          *v223 = vuzp1q_s16(v226, v227);
                          v223[-1].i16[7] = ((unsigned __int32)v226.i32[1] >> 4) & 0x3000 | ((unsigned __int32)v226.i32[0] >> 2) & 0xC000 | ((unsigned __int32)v226.i32[2] >> 6) & 0xC00 | ((unsigned __int32)v226.i32[3] >> 8) & 0x300 | ((unsigned __int32)v227.i32[0] >> 10) & 0xC0 | ((unsigned __int32)v227.i32[1] >> 12) & 0x30 | ((unsigned __int32)v227.i32[2] >> 14) & 0xC | v227.i8[14] & 3;
                          v223 = (int16x8_t *)((char *)v223 + 18);
                        }
                        while (v225 < v157 + 32);
                        v228 = sub_18BC464D0((uint64_t)v293, v222, v222, v214);
                        if (v228 < 0)
                        {
                          v229 = v283;
                          if ((_DWORD)v214 == (_DWORD)v283)
                          {
LABEL_349:
                            v230 = (v214 + 36);
                          }
                          else
                          {
                            v234 = 0;
                            v235 = 0x7FFFFFFFFFFFFFDDLL;
                            v236 = 35;
                            v237 = 36;
LABEL_330:
                            v238 = v237--;
                            v239 = v238;
                            v240 = (unsigned __int16 *)(v222 + 2 * (int)v214);
                            do
                            {
                              if (v240[v235] != *v240)
                              {
                                --v236;
                                ++v235;
                                v234 -= 2;
                                if (v238 >= 3)
                                  goto LABEL_330;
                                v229 = v214;
                                goto LABEL_349;
                              }
                              ++v240;
                              --v239;
                            }
                            while (v239 > 1);
                            v229 = v214 - v237;
                            if ((int)v237 < 1)
                              goto LABEL_349;
                            if (v237 > 0x23)
                            {
                              v230 = v214;
                            }
                            else
                            {
                              v245 = 0;
                              do
                              {
                                *(_WORD *)(v222 + 2 * (int)v214 + 2 * v245++) = *(_WORD *)(v222
                                                                                           + 2 * (int)v214
                                                                                           + v234
                                                                                           + 70);
                                v234 += 2;
                              }
                              while (v234 != 2);
                              v230 = (v214 + v245);
                            }
                          }
                          sub_18BC4630C((uint64_t)v289, v222, v283, v214, v230);
                          if ((v279 & 1) != 0)
                            sub_18BC4630C((uint64_t)v293, *(_QWORD *)&v5[7], v283, v214, v230);
                        }
                        else
                        {
                          v229 = v228;
                          v230 = v214;
                        }
                        v217 = v229 | 0x8000u;
                        v214 = v230;
                        goto LABEL_359;
                      }
                      v217 = *(unsigned int *)(*(_QWORD *)v5 + 4 * v157);
                    }
                    else
                    {
                      v217 = v210;
                    }
LABEL_359:
                    v210 = v5[1].u32[1];
                    if ((v210 & 0x80000000) != 0 && (v215 & 0x80000000) == 0)
                    {
                      v5[1].i32[1] = v217;
                      v210 = v217;
                    }
                    v296[v211] = v217;
                    v157 += 32;
                    v213 += 128;
                    ++v211;
                    v249 = v287;
                    if (v211 == v287)
                    {
                      v250 = v214;
                      v123 = v281;
                      LODWORD(v207) = v283;
                      goto LABEL_370;
                    }
                  }
                  v215 = 0;
                  if (v5[4].i32[0] >= 0x10000)
                    goto LABEL_322;
LABEL_320:
                  v218 = v215;
                  v219 = (uint64_t)v5[7];
                  v220 = *v5;
                  v221 = sub_18BC463D0((uint64_t *)v289, v219, (uint64_t)*v5, v157);
                  if ((v221 & 0x80000000) != 0)
                  {
                    if ((_DWORD)v214 == (_DWORD)v283)
                    {
                      v231 = 0;
                      v232 = v275;
                      v217 = v283;
                      v233 = v219;
                    }
                    else
                    {
                      v232 = (int)v214;
                      v241 = 32;
                      v231 = 31;
                      v233 = v219;
LABEL_338:
                      v242 = (unsigned __int16 *)(v219 + 2 * ((int)v214 - v231));
                      v243 = v220;
                      v244 = v241;
                      do
                      {
                        if (*(_DWORD *)(*(_QWORD *)&v243 + v213) != *v242)
                        {
                          --v241;
                          v111 = v231-- > 1;
                          if (v111)
                            goto LABEL_338;
                          v231 = 0;
                          v217 = v214;
                          goto LABEL_354;
                        }
                        ++v242;
                        --v244;
                        *(_QWORD *)&v243 += 4;
                      }
                      while (v244 > 1);
                      v217 = (v214 - v231);
                      v246 = v214;
                      if ((int)v231 > 31)
                        goto LABEL_356;
                    }
LABEL_354:
                    v247 = (_WORD *)(v233 + 2 * v232);
                    v248 = 4 * v231;
                    v246 = (v232 - v231 + 32);
                    do
                    {
                      *v247++ = *(_DWORD *)(*(_QWORD *)&v220 + v213 + v248);
                      v248 += 4;
                    }
                    while (v248 != 128);
LABEL_356:
                    sub_18BC4630C((uint64_t)v289, v233, v283, v214, v246);
                    if ((v279 & 1) != 0)
                      sub_18BC4630C((uint64_t)v293, *(_QWORD *)&v5[7], v283, v214, v246);
                    v214 = v246;
                    v215 = v218;
                  }
                  else
                  {
                    v217 = v221;
                    v215 = v218;
                  }
                  goto LABEL_359;
                }
                v249 = 0;
                v250 = (v124 + ((((v286 - (int)v157) >> 5) + 31) >> 5));
LABEL_370:
                if ((v210 & 0x80000000) != 0)
                  v5[1].i32[1] = 0x7FFF;
                if ((int)v250 > 32798)
                {
                  LODWORD(v250) = 0;
                  *v123 = 8;
                  goto LABEL_409;
                }
                if (v249 >= 1)
                {
                  v251 = 0;
                  v288 = (int)v207;
                  v252 = (uint64_t)v5[7];
                  v280 = v249 + 1;
                  v253 = 32;
                  v254 = v249;
                  do
                  {
                    v255 = v249 - v251;
                    if (v249 - v251 >= v253)
                    {
                      v257 = v250;
                      v256 = sub_18BC464D0((uint64_t)v289, v252, (uint64_t)v296, v251);
                      v250 = v257;
                      LOWORD(v257) = v256;
                      if (v256 < 0)
                        goto LABEL_391;
                      goto LABEL_405;
                    }
                    if ((int)v250 - v255 < (int)v207)
                    {
LABEL_378:
                      v253 = v249 - v251;
                      goto LABEL_391;
                    }
                    v257 = v288;
                    while (1)
                    {
                      if (v255 >= 1)
                      {
                        v258 = (unsigned __int16 *)(v252 + 2 * v257);
                        v259 = v280 - v251;
                        v260 = &v296[v251];
                        while (*v258 == *v260)
                        {
                          ++v258;
                          ++v260;
                          if (--v259 <= 1)
                          {
                            v253 = v249 - v251;
                            if ((v257 & 0x80000000) == 0)
                              goto LABEL_405;
                            goto LABEL_391;
                          }
                        }
                        goto LABEL_388;
                      }
                      if (!v255)
                        break;
LABEL_388:
                      if ((_DWORD)v250 - v255 + 1 == (_DWORD)++v257)
                        goto LABEL_378;
                    }
                    v253 = 0;
                    if ((v257 & 0x80000000) != 0)
                    {
LABEL_391:
                      if ((_DWORD)v250 == (_DWORD)v207)
                      {
                        v261 = 0;
                        goto LABEL_402;
                      }
                      v261 = v253 - 1;
                      if (v253 <= 1)
                      {
                        LOWORD(v257) = v250 - v261;
                        goto LABEL_403;
                      }
                      v262 = v253;
                      do
                      {
                        v263 = v262--;
                        v264 = (unsigned __int16 *)(v252 + 2 * ((int)v250 - v262));
                        v265 = v263;
                        v266 = &v296[v251];
                        while (*v264 == *v266)
                        {
                          ++v264;
                          ++v266;
                          if (--v265 <= 1)
                          {
                            v261 = v262;
                            goto LABEL_402;
                          }
                        }
                        v261 = 0;
                      }
                      while (v263 >= 3);
LABEL_402:
                      LOWORD(v257) = v250 - v261;
                      v267 = v250;
                      if (v261 < v253)
                      {
LABEL_403:
                        v268 = v250;
                        memcpy((void *)(v252 + 2 * (int)v250), &v296[v261 + v251], 2 * (v253 + ~v261) + 2);
                        LODWORD(v250) = v268;
                        v267 = (v253 + v268 - v261);
                      }
                      LODWORD(v207) = v283;
                      sub_18BC4630C((uint64_t)v289, v252, v283, v250, v267);
                      v252 = (uint64_t)v5[7];
                      v250 = v267;
                      v249 = v254;
                    }
LABEL_405:
                    *(_WORD *)(v252 + 2 * v124++) = v257;
                    v251 += v253;
                  }
                  while (v251 < v249);
                }
LABEL_409:
                LODWORD(v124) = v250;
                v123 = v281;
              }
              uprv_free(v293[0]);
LABEL_368:
              v126 = v277;
              v5[6].i32[0] = v269;
LABEL_206:
              uprv_free(v289[0]);
              if (*v123 >= 1)
              {
LABEL_207:
                v5[1].i32[1] = -1;
                *(int8x8_t *)((char *)&v5[3] + 4) = (int8x8_t)0xFFFFFFFF00000000;
                v127 = v5[4].i32[1];
                v5[5].i32[0] = v127;
                v5[6].i32[0] = 0;
                v5[6].i32[1] = v127;
                uprv_free(*(void **)&v5[7]);
                v4 = 0;
LABEL_208:
                v5[7] = 0;
                return v4;
              }
              if (v126 == 1 && (v124 & 1) != 0)
              {
                *(_WORD *)(*(_QWORD *)&v5[7] + 2 * (int)v124) = -18;
                v129 = 2 * (v124 + 1);
                LODWORD(v124) = v124 + 1;
                goto LABEL_219;
              }
              v129 = 2 * v124;
              if (v126)
              {
                if (v126 != 1)
                {
                  v130 = v5[3].i32[1];
                  v131 = ((_BYTE)v130 + (_BYTE)v129) & 3;
                  if ((((_BYTE)v130 + (_BYTE)v129) & 3) != 0)
                  {
                    if (v131 == 3)
                    {
                      v132 = v5[2];
                      if (*(_DWORD *)(*(_QWORD *)&v132 + 4 * (v130 - 1)) != v5[6].i32[1])
                        goto LABEL_280;
                    }
                    else
                    {
                      if (v131 == 2)
                      {
                        v132 = v5[2];
                        goto LABEL_282;
                      }
                      v132 = v5[2];
                      do
                      {
LABEL_280:
                        v186 = v5[6].i32[1];
                        v187 = v5[3].i32[1];
                        v5[3].i32[1] = v187 + 1;
                        *(_DWORD *)(*(_QWORD *)&v132 + 4 * v187) = v186;
                        v131 = (v131 + 1) & 3;
                      }
                      while (v131 != 2);
                      v130 = v5[3].i32[1];
LABEL_282:
                      v188 = v5[6].i32[1];
                      v5[3].i32[1] = v130 + 1;
                      *(_DWORD *)(*(_QWORD *)&v132 + 4 * v130) = v188;
                      v130 = v5[3].i32[1];
                    }
                    v189 = v5[5].i32[1];
                    v5[3].i32[1] = v130 + 1;
                    *(_DWORD *)(*(_QWORD *)&v132 + 4 * v130) = v189;
                    v130 = v5[3].i32[1];
                  }
                  else
                  {
                    v132 = v5[2];
                    if (*(_DWORD *)(*(_QWORD *)&v132 + 4 * (v130 - 1)) != v5[5].i32[1]
                      || *(_DWORD *)(*(_QWORD *)&v132 + 4 * (v130 - 2)) != v5[6].i32[1])
                    {
                      goto LABEL_280;
                    }
                  }
LABEL_284:
                  v190 = (char *)uprv_malloc(v129 + v130 + 48);
                  v4 = v190;
                  if (v190)
                  {
                    *(_OWORD *)(v190 + 8) = 0u;
                    v191 = (char **)(v190 + 8);
                    *(_OWORD *)(v190 + 24) = 0u;
                    v192 = v5[6].i32[0];
                    *((_WORD *)v190 + 14) = (v192 + 4095) >> 12;
                    v193 = v5[4].i32[0];
                    v194 = v5[3].i32[1];
                    *((_DWORD *)v190 + 4) = v124;
                    *((_DWORD *)v190 + 5) = v194;
                    *((_DWORD *)v190 + 6) = v192;
                    v190[30] = v272;
                    v190[31] = v126;
                    *((_WORD *)v190 + 19) = v5[1].i32[1];
                    v195 = v5[5].i32[0];
                    *((_DWORD *)v190 + 10) = v193;
                    *((_DWORD *)v190 + 11) = v195;
                    v196 = v190 + 48;
                    *(_QWORD *)v190 = v190 + 48;
                    if (v192 <= (int)v273)
                    {
                      if ((int)v124 < 1)
                      {
                        v197 = v190 + 48;
                      }
                      else
                      {
                        v198 = (int *)*v5;
                        v197 = v190 + 48;
                        do
                        {
                          v199 = *v198;
                          v198 += 4;
                          *(_WORD *)v197 = v199;
                          v197 += 2;
                          LODWORD(v124) = v124 - 1;
                        }
                        while ((_DWORD)v124);
                      }
                    }
                    else
                    {
                      memcpy(v190 + 48, *(const void **)&v5[7], v129);
                      v197 = &v196[2 * (int)v124];
                    }
                    v200 = &v196[v129];
                    v201 = (int *)v5[2];
                    if (v126 == 2)
                    {
                      *v191 = v200;
                      if ((int)v194 >= 1)
                      {
                        v204 = v194 + 1;
                        do
                        {
                          v205 = *v201++;
                          *v200++ = v205;
                          --v204;
                        }
                        while (v204 > 1);
                      }
                    }
                    else if (v126 == 1)
                    {
                      *v191 = v200;
                      memcpy(v200, v201, 4 * v194);
                    }
                    else
                    {
                      *v191 = v197;
                      if ((int)v194 >= 1)
                      {
                        v202 = v194 + 1;
                        do
                        {
                          v203 = *v201++;
                          *(_WORD *)v197 = v203;
                          v197 += 2;
                          --v202;
                        }
                        while (v202 > 1);
                      }
                    }
                  }
                  else
                  {
                    *v123 = 7;
                  }
                  v5[1].i32[1] = -1;
                  *(int8x8_t *)((char *)&v5[3] + 4) = (int8x8_t)0xFFFFFFFF00000000;
                  v206 = v5[4].i32[1];
                  v5[5].i32[0] = v206;
                  v5[6].i32[0] = 0;
                  v5[6].i32[1] = v206;
                  uprv_free(*(void **)&v5[7]);
                  goto LABEL_208;
                }
LABEL_219:
                v133 = v5[2];
                v134 = v5[3].i32[1];
                v135 = *(_DWORD *)(*(_QWORD *)&v133 + 4 * (v134 - 1));
                v136 = v5[5].i32[1];
                if (v135 == v136)
                {
                  v137 = v5[6].i32[1];
                  if (*(_DWORD *)(*(_QWORD *)&v133 + 4 * (v134 - 2)) == v137)
                  {
LABEL_228:
                    v130 = 4 * v134;
                    goto LABEL_284;
                  }
                }
                else
                {
                  v137 = v5[6].i32[1];
                }
                if (v135 != v137)
                {
                  v5[3].i32[1] = v134 + 1;
                  *(_DWORD *)(*(_QWORD *)&v133 + 4 * v134) = v137;
                  v136 = v5[5].i32[1];
                  v134 = v5[3].i32[1];
                }
                v5[3].i32[1] = v134 + 1;
                *(_DWORD *)(*(_QWORD *)&v133 + 4 * v134) = v136;
                v134 = v5[3].i32[1];
                goto LABEL_228;
              }
              v139 = v5[3].i32[1];
              v140 = v5[2];
              v141 = v139;
              if (((v139 ^ v124) & 1) != 0)
              {
                v142 = v5[5].i32[1];
                v5[3].i32[1] = v139 + 1;
                *(_DWORD *)(*(_QWORD *)&v140 + 4 * v139) = v142;
                v141 = v5[3].i32[1];
              }
              if (*(_DWORD *)(*(_QWORD *)&v140 + 4 * v141 - 4) == v5[5].i32[1])
              {
                v143 = v5[6].i32[1];
                if (*(_DWORD *)(*(_QWORD *)&v140 + 4 * v141 - 8) == v143)
                  goto LABEL_238;
              }
              else
              {
                v143 = v5[6].i32[1];
              }
              v5[3].i32[1] = v141 + 1;
              *(_DWORD *)(*(_QWORD *)&v140 + 4 * v141) = v143;
              v144 = v5[5].i32[1];
              v145 = v5[3].i32[1];
              v5[3].i32[1] = v145 + 1;
              *(_DWORD *)(*(_QWORD *)&v140 + 4 * v145) = v144;
              v141 = v5[3].i32[1];
LABEL_238:
              v130 = 2 * v141;
              goto LABEL_284;
            }
LABEL_365:
            LODWORD(v124) = 0;
          }
          else
          {
            LODWORD(v124) = 0;
            v123 = v281;
          }
          *v123 = 7;
          goto LABEL_368;
        }
      }
      if (SLODWORD(v291[0]) >= 1)
      {
        v48 = 0;
        do
        {
          if (*((_DWORD *)&v291[8] + v48 + 2) == (_DWORD)v37)
          {
            DWORD1(v291[0]) = v48;
            goto LABEL_76;
          }
          ++v48;
        }
        while (LODWORD(v291[0]) != v48);
        if (LODWORD(v291[0]) == 32)
          goto LABEL_77;
      }
      DWORD1(v291[0]) = v291[0];
      *((_DWORD *)v291 + SLODWORD(v291[0]) + 2) = v31;
      *((_DWORD *)&v291[8] + SLODWORD(v291[0]) + 2) = v37;
      v49 = SLODWORD(v291[0]);
      ++LODWORD(v291[0]);
      goto LABEL_92;
    }
LABEL_41:
    v24 = v18 >> 4;
    if (v18 >> 4 < v13)
    {
      v25 = v13 - v24;
      v26 = (_DWORD *)(*(_QWORD *)v0 + 4 * v24);
      v27 = (char *)&v0[8] + v24;
      do
      {
        *v27++ = 0;
        *v26++ = *v16;
        --v25;
      }
      while (v25);
    }
    v23 = v12;
    goto LABEL_45;
  }
  return 0;
}

uint64_t sub_18BC45E38(uint64_t a1, int a2)
{
  int v2;
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  void *v9;
  uint64_t v10;

  v2 = *(_DWORD *)(a1 + 48);
  if (v2 <= a2)
  {
    v4 = (a2 & 0xFFFFFE00) + 512;
    v5 = v2 >> 4;
    v6 = v4 >> 4;
    if ((int)v6 > *(_DWORD *)(a1 + 8))
    {
      result = (uint64_t)uprv_malloc(0x44000uLL);
      if (!result)
        return result;
      v8 = result;
      v9 = *(void **)a1;
      memcpy((void *)result, *(const void **)a1, 4 * v5);
      uprv_free(v9);
      *(_QWORD *)a1 = v8;
      *(_DWORD *)(a1 + 8) = 69632;
    }
    v10 = v5;
    do
    {
      *(_BYTE *)(a1 + v10 + 64) = 0;
      *(_DWORD *)(*(_QWORD *)a1 + 4 * v10++) = *(_DWORD *)(a1 + 40);
    }
    while (v10 < v6);
    *(_DWORD *)(a1 + 48) = v4;
  }
  return 1;
}

uint64_t sub_18BC45EF8(_QWORD *a1, int a2)
{
  uint64_t v4;
  char *v5;
  _BYTE *v6;
  int v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const float *v15;
  float32x4_t v16;
  uint64_t v18;
  uint64_t v19;
  const float *v20;
  float32x4_t v21;

  v4 = a2;
  v5 = (char *)a1 + a2;
  v7 = v5[64];
  v6 = v5 + 64;
  if (v7 == 1)
    return *(unsigned int *)(*a1 + 4 * a2);
  if (a2 > 4095)
  {
    result = sub_18BC46010((uint64_t)a1, 16);
    if ((result & 0x80000000) == 0)
    {
      v18 = 0;
      v19 = a1[2] + 4 * result;
      v20 = (const float *)(*a1 + 4 * v4);
      v21 = vld1q_dup_f32(v20);
      do
      {
        *(float32x4_t *)(v19 + v18) = v21;
        v18 += 16;
      }
      while (v18 != 64);
      *v6 = 1;
      *(_DWORD *)(*a1 + 4 * v4) = result;
    }
  }
  else
  {
    result = sub_18BC46010((uint64_t)a1, 64);
    if ((result & 0x80000000) == 0)
    {
      v9 = (int)(a2 & 0xFFFFFFFC);
      v10 = *a1;
      v11 = 4 * result;
      v12 = result;
      do
      {
        v13 = 0;
        v14 = a1[2];
        v15 = (const float *)(v10 + 4 * v9);
        v16 = vld1q_dup_f32(v15);
        do
        {
          *(float32x4_t *)(v14 + v11 + v13) = v16;
          v13 += 16;
        }
        while (v13 != 64);
        *((_BYTE *)a1 + v9 + 64) = 1;
        v10 = *a1;
        *(_DWORD *)(*a1 + 4 * v9) = v12;
        v12 += 16;
        v11 += 64;
      }
      while (v9++ < (a2 | 3));
      return *(unsigned int *)(v10 + 4 * v4);
    }
  }
  return result;
}

uint64_t sub_18BC46010(uint64_t a1, int a2)
{
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  void *v7;
  void *v8;
  void *v9;

  v3 = *(_DWORD *)(a1 + 24);
  v4 = *(unsigned int *)(a1 + 28);
  v5 = v4 + a2;
  if ((int)v4 + a2 <= v3)
    goto LABEL_8;
  if (v3 >= 0x20000)
  {
    if (HIWORD(v3) > 0x10u)
      return 0xFFFFFFFFLL;
    v6 = 1114112;
  }
  else
  {
    v6 = 0x20000;
  }
  v7 = uprv_malloc((4 * v6));
  if (!v7)
    return 0xFFFFFFFFLL;
  v8 = v7;
  v9 = *(void **)(a1 + 16);
  memcpy(v7, v9, 4 * *(int *)(a1 + 28));
  uprv_free(v9);
  *(_QWORD *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 24) = v6;
LABEL_8:
  *(_DWORD *)(a1 + 28) = v5;
  return v4;
}

uint64_t sub_18BC460B0(uint64_t a1, int a2, int a3)
{
  unsigned int v5;
  int v6;
  int v7;
  uint64_t result;
  size_t v9;

  v5 = a2 - a3;
  if (a2 - a3 > 4094)
  {
    if (v5 > 0x7FFE)
    {
      if (v5 > 0x1FFFE)
      {
        *(_QWORD *)(a1 + 16) = 0x1FFFFF00000015;
        v6 = 1500007;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = 0x1FFFF00000011;
        v6 = 200003;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 16) = 0x7FFF0000000FLL;
      v6 = 50021;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 16) = 0xFFF0000000CLL;
    v6 = 6007;
  }
  v7 = *(_DWORD *)(a1 + 8);
  result = *(_QWORD *)a1;
  if (v6 <= v7)
  {
    v9 = (4 * v6);
  }
  else
  {
    uprv_free((void *)result);
    v9 = (4 * v6);
    result = (uint64_t)uprv_malloc(v9);
    *(_QWORD *)a1 = result;
    if (!result)
      return result;
    *(_DWORD *)(a1 + 8) = v6;
  }
  *(_DWORD *)(a1 + 12) = v6;
  bzero((void *)result, v9);
  *(_DWORD *)(a1 + 24) = a3;
  return 1;
}

uint64_t sub_18BC46198(uint64_t result, uint64_t a2, int a3, int a4)
{
  int v4;
  int v5;
  int v6;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;

  v4 = *(_DWORD *)(result + 24);
  if (a3 >= v4)
    v5 = a3 - v4 + 1;
  else
    v5 = 0;
  v6 = a4 - v4;
  if (v5 <= a4 - v4)
  {
    v8 = result;
    do
    {
      v9 = v5;
      v10 = *(int *)(v8 + 24) + (uint64_t)v5++;
      v11 = *(_DWORD *)(a2 + 4 * v9);
      v12 = v5;
      do
        v11 = *(_DWORD *)(a2 + 4 * v12++) + 37 * v11;
      while (v12 < v10);
      result = sub_18BC46258(v8, a2, a2, v9, v11);
      if ((result & 0x80000000) != 0)
        *(_DWORD *)(*(_QWORD *)v8 + 4 * ~(_DWORD)result) = (v11 << *(_DWORD *)(v8 + 16)) | v5;
    }
    while (v5 <= v6);
  }
  return result;
}

uint64_t sub_18BC46258(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  int v5;
  signed int v6;
  int v7;
  int v8;
  _DWORD *v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  int v13;
  _DWORD *i;

  v5 = *(_DWORD *)(a1 + 12);
  v6 = a5 % (v5 - 1) + 1;
  v7 = *(_DWORD *)(*(_QWORD *)a1 + 4 * v6);
  if (v7)
  {
    v8 = *(_DWORD *)(a1 + 20);
    v9 = (_DWORD *)(a3 + 4 * a4);
    v10 = a5 % (v5 - 1) + 1;
    do
    {
      if ((v7 & ~v8) == a5 << *(_DWORD *)(a1 + 16))
      {
        v11 = *(_DWORD *)(a1 + 24);
        if (v11 < 1)
        {
          if (!v11)
            return v10;
        }
        else
        {
          v12 = (_DWORD *)(a2 + 4 * ((v8 & v7) - 1));
          v13 = v11 + 1;
          for (i = v9; *v12 == *i; ++i)
          {
            ++v12;
            if (--v13 <= 1)
              return v10;
          }
        }
      }
      v10 = (((int)v10 + v6) % v5);
      v7 = *(_DWORD *)(*(_QWORD *)a1 + 4 * (int)v10);
    }
    while (v7);
  }
  else
  {
    LODWORD(v10) = a5 % (v5 - 1) + 1;
  }
  return ~(_DWORD)v10;
}

uint64_t sub_18BC4630C(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  int v5;
  int v6;
  int v7;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;

  v5 = *(_DWORD *)(result + 24);
  if (a4 - v5 >= a3)
    v6 = a4 - v5 + 1;
  else
    v6 = a3;
  v7 = a5 - v5;
  if (v6 <= a5 - v5)
  {
    v9 = result;
    do
    {
      v10 = v6;
      v11 = *(int *)(v9 + 24) + (uint64_t)v6++;
      v12 = *(unsigned __int16 *)(a2 + 2 * v10);
      v13 = v6;
      do
        v12 = *(unsigned __int16 *)(a2 + 2 * v13++) + 37 * v12;
      while (v13 < v11);
      result = sub_18BC46544(v9, a2, a2, v10, v12);
      if ((result & 0x80000000) != 0)
        *(_DWORD *)(*(_QWORD *)v9 + 4 * ~(_DWORD)result) = (v12 << *(_DWORD *)(v9 + 16)) | v6;
    }
    while (v6 <= v7);
  }
  return result;
}

uint64_t sub_18BC463D0(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  signed int v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned __int16 *v15;
  int v16;
  unsigned int *v17;

  v4 = *((_DWORD *)a1 + 6);
  v5 = (unsigned int *)(a3 + 4 * a4);
  v6 = *v5;
  v7 = a4 + 1;
  do
    v6 = *(_DWORD *)(a3 + 4 * v7++) + 37 * v6;
  while (v7 < v4 + a4);
  v8 = *((_DWORD *)a1 + 3);
  v9 = v6 % (v8 - 1) + 1;
  v10 = *a1;
  v11 = *(_DWORD *)(*a1 + 4 * v9);
  if (v11)
  {
    v12 = *((_DWORD *)a1 + 5);
    v13 = v6 << *((_DWORD *)a1 + 4);
    v14 = v6 % (v8 - 1) + 1;
    do
    {
      if ((v11 & ~v12) == v13)
      {
        if (v4 < 1)
        {
          if (!v4)
            goto LABEL_16;
        }
        else
        {
          v15 = (unsigned __int16 *)(a2 + 2 * ((v11 & v12) - 1));
          v16 = v4 + 1;
          v17 = v5;
          while (*v17 == *v15)
          {
            ++v15;
            ++v17;
            if (--v16 <= 1)
              goto LABEL_16;
          }
        }
      }
      v14 = (v14 + v9) % v8;
      v11 = *(_DWORD *)(v10 + 4 * v14);
    }
    while (v11);
  }
  else
  {
    v14 = v6 % (v8 - 1) + 1;
  }
  v14 = ~v14;
LABEL_16:
  if (v14 < 0)
    return 0xFFFFFFFFLL;
  else
    return ((*((_DWORD *)a1 + 5) & *(_DWORD *)(v10 + 4 * v14)) - 1);
}

uint64_t sub_18BC464D0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;

  v5 = *(unsigned __int16 *)(a3 + 2 * a4);
  v6 = a4 + 1;
  do
    v5 = *(unsigned __int16 *)(a3 + 2 * v6++) + 37 * v5;
  while (v6 < *(int *)(a1 + 24) + (uint64_t)a4);
  v7 = sub_18BC46544(a1, a2, a3, a4, v5);
  if ((v7 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  else
    return ((*(_DWORD *)(a1 + 20) & *(_DWORD *)(*(_QWORD *)a1 + 4 * v7)) - 1);
}

uint64_t sub_18BC46544(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  int v5;
  signed int v6;
  int v7;
  int v8;
  unsigned __int16 *v9;
  uint64_t v10;
  int v11;
  unsigned __int16 *v12;
  int v13;
  unsigned __int16 *i;

  v5 = *(_DWORD *)(a1 + 12);
  v6 = a5 % (v5 - 1) + 1;
  v7 = *(_DWORD *)(*(_QWORD *)a1 + 4 * v6);
  if (v7)
  {
    v8 = *(_DWORD *)(a1 + 20);
    v9 = (unsigned __int16 *)(a3 + 2 * a4);
    v10 = a5 % (v5 - 1) + 1;
    do
    {
      if ((v7 & ~v8) == a5 << *(_DWORD *)(a1 + 16))
      {
        v11 = *(_DWORD *)(a1 + 24);
        if (v11 < 1)
        {
          if (!v11)
            return v10;
        }
        else
        {
          v12 = (unsigned __int16 *)(a2 + 2 * ((v8 & v7) - 1));
          v13 = v11 + 1;
          for (i = v9; *v12 == *i; ++i)
          {
            ++v12;
            if (--v13 <= 1)
              return v10;
          }
        }
      }
      v10 = (((int)v10 + v6) % v5);
      v7 = *(_DWORD *)(*(_QWORD *)a1 + 4 * (int)v10);
    }
    while (v7);
  }
  else
  {
    LODWORD(v10) = a5 % (v5 - 1) + 1;
  }
  return ~(_DWORD)v10;
}

unint64_t icu::UMutex::getMutex(icu::UMutex *this)
{
  unint64_t v1;
  unint64_t v3;
  std::mutex *v4;
  unint64_t *v5;
  uint64_t (**v7)();
  uint64_t (*v8)();

  v1 = atomic_load((unint64_t *)this + 8);
  if (!v1)
  {
    v3 = atomic_load((unint64_t *)&qword_1ECD27B30);
    if (v3 != -1)
    {
      v7 = &v8;
      v8 = sub_18BC466CC;
      std::__call_once((std::once_flag::_State_type *)&qword_1ECD27B30, &v7, (void (__cdecl *)(void *))sub_18BC46958);
    }
    v4 = (std::mutex *)qword_1ECD27B20;
    std::mutex::lock((std::mutex *)qword_1ECD27B20);
    v5 = (unint64_t *)((char *)this + 64);
    v1 = atomic_load((unint64_t *)this + 8);
    if (!v1)
    {
      *(_QWORD *)this = 850045863;
      *(_OWORD *)((char *)this + 8) = 0u;
      *(_OWORD *)((char *)this + 24) = 0u;
      *(_OWORD *)((char *)this + 40) = 0u;
      *((_QWORD *)this + 7) = 0;
      atomic_store((unint64_t)this, v5);
      v1 = atomic_load(v5);
      *((_QWORD *)this + 9) = icu::UMutex::gListHead;
      icu::UMutex::gListHead = (uint64_t)this;
    }
    std::mutex::unlock(v4);
  }
  return v1;
}

void sub_18BC466CC()
{
  qword_1ECD27B38 = 850045863;
  unk_1ECD27B40 = 0u;
  unk_1ECD27B50 = 0u;
  unk_1ECD27B60 = 0u;
  qword_1ECD27B20 = (uint64_t)&qword_1ECD27B38;
  qword_1ECD27B70 = 0;
  qword_1ECD27B78 = 1018212795;
  unk_1ECD27B80 = 0u;
  qword_1ECD27B28 = (uint64_t)&qword_1ECD27B78;
  unk_1ECD27B90 = 0u;
  qword_1ECD27BA0 = 0;
  sub_18BC0ECC4(0x1Du, (uint64_t)sub_18BC46920);
}

void icu::UMutex::cleanup(icu::UMutex *this)
{
  uint64_t v1;
  std::mutex *v2;
  uint64_t v3;

  v1 = icu::UMutex::gListHead;
  if (icu::UMutex::gListHead)
  {
    do
    {
      v2 = (std::mutex *)atomic_load((unint64_t *)(v1 + 64));
      std::mutex::~mutex(v2);
      atomic_store(0, (unint64_t *)(v1 + 64));
      v3 = *(_QWORD *)(v1 + 72);
      *(_QWORD *)(v1 + 72) = 0;
      v1 = v3;
    }
    while (v3);
  }
  icu::UMutex::gListHead = 0;
}

void umtx_lock(icu::UMutex *a1)
{
  if (!a1)
    a1 = (icu::UMutex *)&unk_1ECD27BA8;
  sub_18BC46798(a1);
}

void sub_18BC46798(icu::UMutex *this)
{
  std::mutex *Mutex;

  Mutex = (std::mutex *)atomic_load((unint64_t *)this + 8);
  if (!Mutex)
    Mutex = (std::mutex *)icu::UMutex::getMutex(this);
  std::mutex::lock(Mutex);
}

void umtx_unlock(std::mutex **a1)
{
  std::mutex **v1;

  v1 = (std::mutex **)&unk_1ECD27BA8;
  if (a1)
    v1 = a1;
  std::mutex::unlock(v1[8]);
}

uint64_t icu::umtx_initImplPreInit(unsigned int *a1)
{
  unint64_t v2;
  uint64_t v3;
  unsigned int v5;
  unsigned int v6;
  std::unique_lock<std::mutex> __lk;
  std::unique_lock<std::mutex> *p_lk;

  v2 = atomic_load((unint64_t *)&qword_1ECD27B30);
  if (v2 != -1)
  {
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_18BC466CC;
    p_lk = &__lk;
    std::__call_once((std::once_flag::_State_type *)&qword_1ECD27B30, &p_lk, (void (__cdecl *)(void *))sub_18BC46958);
  }
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)qword_1ECD27B20;
  v3 = 1;
  *(_QWORD *)&__lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)qword_1ECD27B20);
  if (atomic_load(a1))
  {
    v5 = atomic_load(a1);
    if (v5 == 1)
    {
      do
      {
        std::condition_variable::wait((std::condition_variable *)qword_1ECD27B28, &__lk);
        v6 = atomic_load(a1);
      }
      while (v6 == 1);
    }
    v3 = 0;
  }
  else
  {
    atomic_store(1u, a1);
  }
  if (__lk.__owns_)
    std::mutex::unlock(__lk.__m_);
  return v3;
}

void icu::umtx_initImplPostInit(unsigned int *a1)
{
  std::mutex *v2;

  v2 = (std::mutex *)qword_1ECD27B20;
  std::mutex::lock((std::mutex *)qword_1ECD27B20);
  atomic_store(2u, a1);
  std::mutex::unlock(v2);
  std::condition_variable::notify_all((std::condition_variable *)qword_1ECD27B28);
}

void u_setMutexFunctions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (*a6 <= 0)
    *a6 = 16;
}

void u_setAtomicIncDecFunctions(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  if (*a4 <= 0)
    *a4 = 16;
}

uint64_t sub_18BC46920()
{
  icu::UMutex *v0;

  std::mutex::~mutex((std::mutex *)qword_1ECD27B20);
  std::condition_variable::~condition_variable((std::condition_variable *)qword_1ECD27B28);
  icu::UMutex::cleanup(v0);
  qword_1ECD27B30 = 0;
  return 1;
}

uint64_t sub_18BC46958(uint64_t (***a1)(void))
{
  return (**a1)();
}

int32_t u_charName(UChar32 code, UCharNameChoice nameChoice, char *buffer, int32_t bufferLength, UErrorCode *pErrorCode)
{
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  int32_t v17;

  if (!pErrorCode || *(int *)pErrorCode > 0)
    return 0;
  if ((int)nameChoice > (int)U_CHAR_NAME_ALIAS || bufferLength < 0 || !buffer && bufferLength)
  {
    *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  if (HIWORD(code) <= 0x10u && sub_18BC46ACC(pErrorCode))
  {
    v11 = (int *)(qword_1EE0095B8 + *(unsigned int *)(qword_1EE0095B8 + 12));
    v12 = *v11;
    if (*v11)
    {
      v13 = (uint64_t)(v11 + 1);
      while (*(_DWORD *)v13 > code || *(_DWORD *)(v13 + 4) < code)
      {
        v13 += *(unsigned __int16 *)(v13 + 10);
        if (!--v12)
          goto LABEL_16;
      }
      v15 = sub_18BC46BB0(v13, code, nameChoice, buffer, (unsigned __int16)bufferLength);
    }
    else
    {
LABEL_16:
      if (nameChoice == U_EXTENDED_CHAR_NAME)
      {
        v14 = sub_18BC46D44((unsigned int *)qword_1EE0095B8, code, 2, buffer, (unsigned __int16)bufferLength);
        if ((_DWORD)v14)
        {
LABEL_23:
          v16 = buffer;
          v17 = bufferLength;
          return u_terminateChars((uint64_t)v16, v17, v14, (int *)pErrorCode);
        }
        v15 = sub_18BC46E80(code, buffer, (unsigned __int16)bufferLength);
      }
      else
      {
        v15 = sub_18BC46D44((unsigned int *)qword_1EE0095B8, code, nameChoice, buffer, (unsigned __int16)bufferLength);
      }
    }
    v14 = v15;
    goto LABEL_23;
  }
  v16 = buffer;
  v17 = bufferLength;
  v14 = 0;
  return u_terminateChars((uint64_t)v16, v17, v14, (int *)pErrorCode);
}

BOOL sub_18BC46ACC(UErrorCode *a1)
{
  unsigned int v2;
  _QWORD *v3;

  if (*(int *)a1 <= 0)
  {
    v2 = atomic_load(&dword_1EE0095E4);
    if (v2 == 2 || !icu::umtx_initImplPreInit(&dword_1EE0095E4))
    {
      if (dword_1EE0095E8 >= 1)
        *a1 = dword_1EE0095E8;
    }
    else
    {
      v3 = udata_openChoice(0, "icu", "unames", (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18BC48D54, 0, a1);
      qword_1EE0095F0 = (uint64_t)v3;
      if (*(int *)a1 < 1)
        qword_1EE0095B8 = udata_getMemory((uint64_t)v3);
      else
        qword_1EE0095F0 = 0;
      sub_18BC0ECC4(0x13u, (uint64_t)sub_18BC48DB8);
      dword_1EE0095E8 = *a1;
      icu::umtx_initImplPostInit(&dword_1EE0095E4);
    }
  }
  return *a1 < U_ILLEGAL_ARGUMENT_ERROR;
}

uint64_t sub_18BC46BB0(uint64_t a1, unsigned int a2, int a3, _BYTE *a4, int a5)
{
  _BYTE *v5;
  unsigned __int16 v6;
  char v7;
  __int16 v8;
  unsigned __int8 *v9;
  int v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  char v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;
  _BYTE *v19;
  unsigned __int16 v20;
  char v21;
  _QWORD v24[3];

  v5 = a4;
  v24[2] = *MEMORY[0x1E0C80C00];
  if ((a3 & 0xFFFFFFFD) != 0)
  {
LABEL_2:
    v6 = 0;
    if (a5)
      *a4 = 0;
    return v6;
  }
  if (*(_BYTE *)(a1 + 8) == 1)
  {
    v24[0] = 0;
    v24[1] = 0;
    v11 = *(unsigned __int8 *)(a1 + 9);
    v12 = (unsigned __int8 *)(a1 + 12 + 2 * v11);
    v15 = *v12;
    v13 = v12 + 1;
    v14 = v15;
    if (v15)
    {
      v16 = 0;
      do
      {
        if ((_WORD)a5)
        {
          *v5++ = v14;
          LOWORD(a5) = a5 - 1;
        }
        else
        {
          LOWORD(a5) = 0;
        }
        ++v16;
        v17 = *v13++;
        v14 = v17;
      }
      while (v17);
    }
    else
    {
      v16 = 0;
    }
    return (unsigned __int16)(sub_18BC48E0C(a1 + 12, v11, v13, a2 - *(_DWORD *)a1, v24, 0, 0, v5, a5) + v16);
  }
  else
  {
    if (*(_BYTE *)(a1 + 8))
      goto LABEL_2;
    v7 = *(_BYTE *)(a1 + 12);
    if (v7)
    {
      v8 = 0;
      v9 = (unsigned __int8 *)(a1 + 13);
      do
      {
        if ((_WORD)a5)
        {
          *v5++ = v7;
          LOWORD(a5) = a5 - 1;
        }
        else
        {
          LOWORD(a5) = 0;
        }
        ++v8;
        v10 = *v9++;
        v7 = v10;
      }
      while (v10);
    }
    else
    {
      v8 = 0;
    }
    v18 = *(unsigned __int8 *)(a1 + 9);
    if (v18 < (unsigned __int16)a5)
      v5[v18] = 0;
    if ((_DWORD)v18)
    {
      v19 = &v5[(unsigned __int16)(v18 - 1)];
      v20 = v18 - 1;
      do
      {
        if ((unsigned __int16)a5 > v20)
        {
          if ((a2 & 0xF) >= 0xA)
            v21 = (a2 & 0xF) + 55;
          else
            v21 = a2 & 0xF | 0x30;
          *v19 = v21;
        }
        a2 >>= 4;
        --v19;
      }
      while (v20--);
    }
    return (unsigned __int16)(v8 + v18);
  }
}

uint64_t sub_18BC46D44(unsigned int *a1, unsigned int a2, int a3, char *a4, int a5)
{
  unsigned __int16 *v10;
  unsigned __int8 *v11;
  _OWORD v13[4];
  int v14;
  _OWORD v15[4];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v10 = sub_18BC48F00((uint64_t)a1, a2);
  if (*v10 == (unsigned __int16)(a2 >> 5))
  {
    v16 = 0;
    memset(v15, 0, sizeof(v15));
    v14 = 0;
    memset(v13, 0, sizeof(v13));
    v11 = sub_18BC48CA8((unsigned __int8 *)a1 + a1[2] + ((v10[1] << 16) | (unint64_t)v10[2]), v15, v13);
    return sub_18BC48F6C(a1, &v11[*((unsigned __int16 *)v15 + (a2 & 0x1F))], *((unsigned __int16 *)v13 + (a2 & 0x1F)), a3, a4, a5);
  }
  else
  {
    if (a5)
      *a4 = 0;
    return 0;
  }
}

uint64_t sub_18BC46E80(unsigned int a1, char *a2, int a3)
{
  int v5;
  unsigned int v6;
  const char *v7;
  __int16 v8;
  char v9;
  __int16 v10;
  __int16 v11;
  __int16 v12;
  __int16 v13;
  int v14;
  int v15;
  BOOL v16;
  uint64_t v19;
  char v20;

  v5 = a1;
  v6 = sub_18BC475A4(a1);
  if (v6 <= 0x20)
  {
    v7 = off_1E2256638[v6];
    if (a3)
      goto LABEL_3;
  }
  else
  {
    v7 = "unknown";
    if (a3)
    {
LABEL_3:
      *a2++ = 60;
      v8 = a3 - 1;
      goto LABEL_6;
    }
  }
  v8 = 0;
LABEL_6:
  v9 = *v7;
  if (*v7)
  {
    v10 = 1;
    do
    {
      v11 = v10;
      if (v8)
      {
        *a2++ = v9;
        --v8;
      }
      else
      {
        v8 = 0;
      }
      ++v10;
      v9 = v7[(unsigned __int16)(v11 + 1) - 1];
    }
    while (v9);
    v12 = v11 + 3;
  }
  else
  {
    v12 = 3;
  }
  if (v8)
  {
    *a2++ = 45;
    v13 = v8 - 1;
  }
  else
  {
    v13 = 0;
  }
  v14 = 0;
  if (v5)
  {
    v15 = v5;
    do
    {
      ++v14;
      v16 = v15 > 0xF;
      v15 >>= 4;
    }
    while (v16);
  }
  if (v14 <= 4)
    v14 = 4;
  if ((v14 > 0 || v5 != 0) && v13 != 0)
  {
    v19 = v14;
    do
    {
      if ((v5 & 0xFu) >= 0xA)
        v20 = (v5 & 0xF) + 55;
      else
        v20 = v5 & 0xF | 0x30;
      a2[v19 - 1] = v20;
      --v13;
      if (v19 < 2 && v5 < 0x10)
        break;
      --v19;
      v5 >>= 4;
    }
    while (v13);
  }
  if (v13)
    a2[v14] = 62;
  return (unsigned __int16)(v12 + v14);
}

int32_t u_getISOComment(UChar32 c, char *dest, int32_t destCapacity, UErrorCode *pErrorCode)
{
  if (!pErrorCode || *(int *)pErrorCode > 0)
    return 0;
  if (destCapacity < 0 || !dest && destCapacity)
  {
    *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  return u_terminateChars((uint64_t)dest, destCapacity, 0, (int *)pErrorCode);
}

UChar32 u_charFromName(UCharNameChoice nameChoice, const char *name, UErrorCode *pErrorCode)
{
  uint64_t v4;
  UErrorCode v5;
  const char *v6;
  uint64_t v7;
  unsigned int v8;
  char v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  unsigned int v16;
  uint64_t v17;
  int *v18;
  int v19;
  int *v20;
  int v21;
  __int128 v22;
  uint64_t v23;
  int v24;
  int v25;
  _DWORD *v26;
  uint64_t v27;
  unsigned __int8 *v28;
  const char *v29;
  int v30;
  int v31;
  int v32;
  _BYTE *v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  unsigned __int16 v39;
  uint64_t v40;
  int v41;
  unsigned __int8 *v42;
  const char *v44;
  unsigned __int16 v45;
  const char *v46;
  int v47;
  int v48;
  BOOL v49;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  int v58;
  int v59;
  _OWORD *v60;
  uint64_t v61;
  _OWORD v62[7];
  uint64_t v63;
  _OWORD v64[7];
  uint64_t v65;
  _OWORD v66[4];
  _OWORD v67[4];
  _QWORD v68[2];
  char __s2[16];
  __int128 v70;
  __int128 v71;
  __int128 v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v65 = 0;
  memset(v64, 0, sizeof(v64));
  v63 = 0;
  memset(v62, 0, sizeof(v62));
  if (!pErrorCode || *(int *)pErrorCode > 0)
    return 0xFFFF;
  v4 = *(_QWORD *)&nameChoice;
  v5 = U_ILLEGAL_ARGUMENT_ERROR;
  if ((int)nameChoice > (int)U_CHAR_NAME_ALIAS)
    goto LABEL_75;
  v6 = name;
  if (!name || !*name)
    goto LABEL_75;
  if (!sub_18BC46ACC(pErrorCode))
    return 0xFFFF;
  v7 = 0;
  v8 = -1;
  while (1)
  {
    v9 = *v6;
    if (!*v6)
      break;
    ++v6;
    v10 = v9;
    *((_BYTE *)v64 + v7) = uprv_toupper(v9);
    *((_BYTE *)v62 + v7++) = uprv_asciitolower(v10);
    ++v8;
    if (v7 == 120)
      goto LABEL_74;
  }
  *((_BYTE *)v62 + v7) = 0;
  v60 = 0;
  v61 = 0;
  *((_BYTE *)v64 + v7) = 0;
  if (LOBYTE(v62[0]) == 60)
  {
    if ((_DWORD)v4 == 2)
    {
      v11 = v7 - 1;
      if (*((_BYTE *)v62 + (v7 - 1)) == 62)
      {
        if (v11 < 3)
        {
          if ((_DWORD)v7 != 3)
            goto LABEL_74;
          v16 = 2;
        }
        else
        {
          v12 = -1;
          do
          {
            v13 = v8 + v12;
            v14 = *((unsigned __int8 *)v62 + v8 + v12--);
          }
          while (v14 != 45 && v13 > 2);
          v16 = v7 + v12;
        }
        if (*((_BYTE *)v62 + v16) == 45 && v7 - v16 - 3 <= 7)
        {
          v32 = 0;
          *((_BYTE *)v62 + v16) = 0;
          v52 = v16 + 1;
          v53 = v11 <= v16 + 1 ? v16 + 1 : v7 - 1;
          while (v52 < v11)
          {
            v54 = *((char *)v62 + v52);
            if ((v54 - 48) >= 0xA)
            {
              if ((v54 - 97) > 5)
                goto LABEL_74;
              v55 = -87;
            }
            else
            {
              v55 = -48;
            }
            v32 = v55 + 16 * v32 + v54;
            ++v52;
            v5 = U_ILLEGAL_CHAR_FOUND;
            if (v32 >= 1114112)
              goto LABEL_75;
          }
          v56 = sub_18BC475A4(v32);
          v57 = 0;
          *((_BYTE *)v62 + v53) = 0;
          while (strcmp((const char *)v62 + 1, off_1E2256638[v57]))
          {
            ++v57;
            v5 = U_ILLEGAL_CHAR_FOUND;
            if (v57 == 33)
              goto LABEL_75;
          }
          if ((_DWORD)(v57 * 8) == 8 * v56)
            return v32;
        }
      }
    }
LABEL_74:
    v5 = U_ILLEGAL_CHAR_FOUND;
LABEL_75:
    *pErrorCode = v5;
    return 0xFFFF;
  }
  v17 = qword_1EE0095B8;
  v18 = (int *)(qword_1EE0095B8 + *(unsigned int *)(qword_1EE0095B8 + 12));
  v19 = *v18;
  if (!*v18)
    goto LABEL_73;
  v20 = v18 + 1;
  v21 = v4 & 0xFFFFFFFD;
  v22 = 0uLL;
  do
  {
    if (v21)
      goto LABEL_24;
    if (*((_BYTE *)v20 + 8) == 1)
    {
      v71 = v22;
      v72 = v22;
      *(_OWORD *)__s2 = v22;
      v70 = v22;
      v68[0] = 0;
      v68[1] = 0;
      v67[2] = v22;
      v67[3] = v22;
      v67[0] = v22;
      v67[1] = v22;
      v66[2] = v22;
      v66[3] = v22;
      v66[0] = v22;
      v66[1] = v22;
      v26 = v20 + 3;
      v27 = *((unsigned __int8 *)v20 + 9);
      v28 = (unsigned __int8 *)v20 + 2 * v27 + 13;
      v29 = (const char *)v64;
      while (1)
      {
        v30 = *(v28 - 1);
        if (!*(v28 - 1))
          break;
        ++v28;
        v31 = *(unsigned __int8 *)v29++;
        if (v30 != v31)
        {
          v32 = 0xFFFF;
          goto LABEL_71;
        }
      }
      v32 = *v20;
      v58 = v20[1];
      v59 = v19;
      sub_18BC48E0C((uint64_t)(v20 + 3), v27, v28, 0, v68, v67, v66, __s2, 64);
      if (!strcmp(v29, __s2))
      {
        v19 = v59;
        v21 = v4 & 0xFFFFFFFD;
        v22 = 0uLL;
      }
      else
      {
        ++v32;
        v22 = 0uLL;
        if (v32 >= v58 + 1)
        {
LABEL_68:
          v19 = v59;
          v21 = v4 & 0xFFFFFFFD;
          goto LABEL_24;
        }
        v38 = (unsigned __int16)(v27 - 1);
        while (1)
        {
          v39 = *((_WORD *)v68 + v38) + 1;
          v40 = (unsigned __int16)(v27 - 1);
          v41 = v27 - 1;
          if (*((unsigned __int16 *)v26 + v38) <= v39)
          {
            do
            {
              *((_WORD *)v68 + v40) = 0;
              *((_QWORD *)v66 + v40) = *((_QWORD *)v67 + v40);
              v40 = (unsigned __int16)--v41;
              v39 = *((_WORD *)v68 + (unsigned __int16)v41) + 1;
            }
            while (*((unsigned __int16 *)v26 + (unsigned __int16)v41) <= v39);
          }
          *((_WORD *)v68 + v40) = v39;
          v42 = (unsigned __int8 *)*((_QWORD *)v66 + v40);
          while (*v42++)
            ;
          *((_QWORD *)v66 + v40) = v42;
          v44 = v29;
          if (!(_DWORD)v27)
            goto LABEL_102;
          v45 = 0;
          v44 = v29;
          do
          {
            v46 = (const char *)*((_QWORD *)v66 + v45);
            while (1)
            {
              v47 = *(unsigned __int8 *)v46;
              if (!*v46)
                break;
              v48 = *(unsigned __int8 *)v44++;
              v49 = v47 == v48;
              if (v47 == v48)
                ++v46;
              else
                v46 = "";
              if (!v49)
                v45 = 99;
            }
            ++v45;
          }
          while (v27 > v45);
          if (v45 <= 0x62u)
          {
LABEL_102:
            if (!*v44)
              break;
          }
          v49 = v32++ == v58;
          if (v49)
            goto LABEL_68;
        }
        v19 = v59;
        v21 = v4 & 0xFFFFFFFD;
      }
    }
    else
    {
      if (*((_BYTE *)v20 + 8))
        goto LABEL_24;
      v23 = 0;
      while (1)
      {
        v24 = *((unsigned __int8 *)v20 + v23 + 12);
        if (!*((_BYTE *)v20 + v23 + 12))
          break;
        v25 = *((unsigned __int8 *)v64 + v23++);
        if (v24 != v25)
          goto LABEL_24;
      }
      v33 = (char *)v64 + v23;
      v32 = 0;
      if (*((_BYTE *)v20 + 9))
      {
        v34 = (unsigned __int16)(*((unsigned __int8 *)v20 + 9) - 1) + 1;
        do
        {
          v36 = (char)*v33++;
          v35 = v36;
          if ((v36 - 48) >= 0xA)
          {
            if ((v35 - 65) > 5)
              goto LABEL_24;
            v37 = -55;
          }
          else
          {
            v37 = -48;
          }
          v32 = (v37 + v35) | (16 * v32);
          --v34;
        }
        while (v34);
      }
      if (*v33 || *v20 > v32 || v32 > v20[1])
        goto LABEL_24;
    }
LABEL_71:
    if (v32 != 0xFFFF)
      return v32;
LABEL_24:
    v20 = (int *)((char *)v20 + *((unsigned __int16 *)v20 + 5));
    --v19;
  }
  while (v19);
  v17 = qword_1EE0095B8;
  v4 = v4;
LABEL_73:
  v60 = v64;
  LODWORD(v61) = 0xFFFF;
  sub_18BC47620(v17, 0, 1114112, 0, (uint64_t)&v60, v4);
  v32 = v61;
  if ((_DWORD)v61 == 0xFFFF)
    goto LABEL_74;
  return v32;
}

uint64_t sub_18BC475A4(unsigned int c)
{
  unsigned __int8 v2;
  int v3;

  if ((int)c >= 64976 && (c >> 4 < 0xFDF || HIWORD(c) <= 0x10u && (c & 0xFFFE) == 0xFFFE))
  {
    return 30;
  }
  else
  {
    v3 = u_charType(c);
    if (c >> 10 == 54)
      v2 = 31;
    else
      v2 = 32;
    if (v3 != 18)
      return v3;
  }
  return v2;
}

uint64_t sub_18BC47620(uint64_t a1, uint64_t a2, int a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t), uint64_t a5, uint64_t a6)
{
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t result;
  unsigned int v19;
  unsigned int v20;
  unsigned __int8 *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  int v32;
  unsigned int v33;
  int v34;
  int v35;
  __int16 v36;

  v12 = sub_18BC48F00(a1, a2);
  v13 = v12;
  v14 = (unsigned __int16)(a2 >> 5);
  v15 = a2;
  if ((_DWORD)a6 == 2)
  {
    v16 = *v12;
    v15 = a2;
    if (v14 < v16)
    {
      v17 = 32 * v16;
      v15 = v17 >= a3 ? a3 : v17;
      result = sub_18BC490E0(a2, (int)v15 - 1, a4, a5);
      if (!(_DWORD)result)
        return result;
    }
  }
  v19 = a3 - 1;
  v20 = (a3 - 1) >> 5;
  if (v14 == (unsigned __int16)v20)
  {
    if (*v13 == (unsigned __int16)(a2 >> 5))
    {
      v21 = (unsigned __int8 *)a1;
      v22 = (uint64_t)v13;
      v23 = v15;
      return sub_18BC491C0(v21, v22, v23, a3 - 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4, a5, a6);
    }
    if ((_DWORD)a6 != 2)
      return 1;
LABEL_43:
    if (a3 >= 1114112)
      v35 = 1114112;
    else
      v35 = a3;
    return sub_18BC490E0(v15, v35 - 1, a4, a5);
  }
  v24 = a1 + *(unsigned int *)(a1 + 4) + 6 * *(unsigned __int16 *)(a1 + *(unsigned int *)(a1 + 4)) + 2;
  v25 = *v13;
  if (v14 == v25)
  {
    if ((v15 & 0x1F) != 0)
    {
      result = sub_18BC491C0((unsigned __int8 *)a1, (uint64_t)v13, v15, (32 * v14) | 0x1F, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4, a5, a6);
      if (!(_DWORD)result)
        return result;
      v13 += 3;
      v20 = (a3 - 1) >> 5;
    }
  }
  else if (v14 > v25)
  {
    v13 += 3;
    if ((unint64_t)v13 < v24 && (_DWORD)a6 == 2)
    {
      v26 = *v13;
      if (v14 < v26)
      {
        v27 = 32 * v26;
        if (v27 >= a3)
          v27 = a3;
        result = sub_18BC490E0(v15, v27 - 1, a4, a5);
        v20 = v19 >> 5;
        if (!(_DWORD)result)
          return result;
      }
    }
  }
  if ((unint64_t)v13 >= v24)
  {
LABEL_38:
    result = 1;
    if ((_DWORD)a6 != 2 || v13 != (unsigned __int16 *)v24)
      return result;
    v34 = 32 * *(unsigned __int16 *)(v24 - 6) + 32;
    if (v34 <= (int)v15)
      v15 = v15;
    else
      v15 = v34;
    goto LABEL_43;
  }
  v28 = (unsigned __int16)(v19 >> 5);
  v29 = *v13;
  if (v28 <= v29)
  {
LABEL_35:
    if (v29 == (unsigned __int16)v20)
    {
      v23 = v19 & 0xFFFFFFE0;
      v21 = (unsigned __int8 *)a1;
      v22 = (uint64_t)v13;
      return sub_18BC491C0(v21, v22, v23, a3 - 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4, a5, a6);
    }
    goto LABEL_38;
  }
  v36 = v20;
  v13 += 3;
  while (1)
  {
    LODWORD(v15) = 32 * v29;
    result = sub_18BC491C0((unsigned __int8 *)a1, (uint64_t)(v13 - 3), 32 * v29, (32 * v29) | 0x1F, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4, a5, a6);
    if (!(_DWORD)result)
      return result;
    if ((unint64_t)v13 >= v24)
      goto LABEL_38;
    if ((_DWORD)a6 == 2)
    {
      v30 = *v13;
      v31 = *(v13 - 3);
      if (v31 + 1 < v30)
      {
        v32 = 32 * v30;
        if (v32 >= a3)
          v32 = a3;
        result = sub_18BC490E0((32 * v31 + 32), v32 - 1, a4, a5);
        if (!(_DWORD)result)
          return result;
      }
    }
    v33 = *v13;
    v13 += 3;
    v29 = v33;
    if (v28 <= v33)
    {
      v13 -= 3;
      LOWORD(v20) = v36;
      goto LABEL_35;
    }
  }
}

void u_enumCharNames(UChar32 start, UChar32 limit, UEnumCharNamesFn *fn, void *context, UCharNameChoice nameChoice, UErrorCode *pErrorCode)
{
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;

  if (pErrorCode && *(int *)pErrorCode <= 0)
  {
    if (fn && (v7 = *(_QWORD *)&nameChoice, (int)nameChoice < (int)U_CHAR_NAME_CHOICE_COUNT))
    {
      v8 = *(_QWORD *)&start;
      if (limit >= 0x110000)
        v9 = 1114112;
      else
        v9 = limit;
      if (v9 > start && sub_18BC46ACC(pErrorCode))
      {
        v11 = qword_1EE0095B8;
        v12 = (_DWORD *)(qword_1EE0095B8 + *(unsigned int *)(qword_1EE0095B8 + 12));
        v13 = *v12;
        if (!*v12)
        {
LABEL_22:
          sub_18BC47620(v11, v8, v9, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn, (uint64_t)context, v7);
          return;
        }
        v14 = v12 + 1;
        while (1)
        {
          v15 = *v14;
          if (v8 < *v14)
          {
            v11 = qword_1EE0095B8;
            if (v9 <= v15)
              goto LABEL_22;
            if (!sub_18BC47620(qword_1EE0095B8, v8, v15, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn, (uint64_t)context, v7))return;
            v8 = *v14;
          }
          v16 = v14[1];
          if (v8 <= v16)
          {
            if (v9 <= v16 + 1)
            {
              sub_18BC47A8C((uint64_t)v14, v8, v9, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn, (uint64_t)context, v7);
              return;
            }
            if (!sub_18BC47A8C((uint64_t)v14, v8, v16 + 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn, (uint64_t)context, v7))return;
            v8 = v14[1] + 1;
          }
          v14 = (unsigned int *)((char *)v14 + *((unsigned __int16 *)v14 + 5));
          if (!--v13)
          {
            v11 = qword_1EE0095B8;
            goto LABEL_22;
          }
        }
      }
    }
    else
    {
      *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }
}

uint64_t sub_18BC47A8C(uint64_t a1, uint64_t a2, int a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t), uint64_t a5, uint64_t a6)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  int v15;
  int v16;
  BOOL v17;
  char *v18;
  unsigned __int8 *v19;
  int v20;
  unsigned int v21;
  unsigned int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 *v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int16 v31;
  _BYTE *v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  unsigned __int16 v36;
  uint64_t v37;
  int v38;
  unsigned __int8 *v39;
  unsigned __int16 v41;
  _BYTE *v42;
  uint64_t v43;
  _BYTE *v44;
  char v45;
  unsigned __int8 *v46;
  int v47;
  _OWORD v51[4];
  _OWORD v52[4];
  uint64_t v53;
  uint64_t v54;
  _OWORD v55[12];
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if ((a6 & 0xFFFFFFFD) != 0)
    return 1;
  v11 = a2;
  v56 = 0;
  memset(v55, 0, sizeof(v55));
  if (*(_BYTE *)(a1 + 8) == 1)
  {
    v53 = 0;
    v54 = 0;
    memset(v52, 0, sizeof(v52));
    memset(v51, 0, sizeof(v51));
    v25 = a1 + 12;
    v26 = *(unsigned __int8 *)(a1 + 9);
    v27 = (unsigned __int8 *)(a1 + 12 + 2 * v26);
    v30 = *v27;
    v28 = v27 + 1;
    v29 = v30;
    if (v30)
    {
      v31 = 0;
      v32 = v55;
      do
      {
        *v32++ = v29;
        ++v31;
        v33 = *v28++;
        v29 = v33;
      }
      while (v33);
    }
    else
    {
      v31 = 0;
      v32 = v55;
    }
    v34 = sub_18BC48E0C(a1 + 12, v26, v28, (int)a2 - *(_DWORD *)a1, &v53, v52, v51, v32, 200 - v31);
    if (!a4(a5, v11, a6, v55, (unsigned __int16)(v34 + v31)))
      return 0;
    v35 = (unsigned __int16)(v26 - 1);
    while (1)
    {
      v11 = (v11 + 1);
      if ((int)v11 >= a3)
        break;
      v36 = *((_WORD *)&v53 + v35) + 1;
      v37 = (unsigned __int16)(v26 - 1);
      v38 = v26 - 1;
      if (*(unsigned __int16 *)(v25 + 2 * v35) <= v36)
      {
        do
        {
          *((_WORD *)&v53 + v37) = 0;
          *((_QWORD *)v51 + v37) = *((_QWORD *)v52 + v37);
          v37 = (unsigned __int16)--v38;
          v36 = *((_WORD *)&v53 + (unsigned __int16)v38) + 1;
        }
        while (*(unsigned __int16 *)(v25 + 2 * (unsigned __int16)v38) <= v36);
      }
      *((_WORD *)&v53 + v37) = v36;
      v39 = (unsigned __int8 *)*((_QWORD *)v51 + v37);
      while (*v39++)
        ;
      *((_QWORD *)v51 + v37) = v39;
      v41 = v31;
      v42 = v32;
      if ((_DWORD)v26)
      {
        v43 = 0;
        v42 = v32;
        v41 = v31;
        do
        {
          v44 = (_BYTE *)*((_QWORD *)v51 + v43);
          v45 = *v44;
          if (*v44)
          {
            v46 = v44 + 1;
            do
            {
              *v42++ = v45;
              ++v41;
              v47 = *v46++;
              v45 = v47;
            }
            while (v47);
          }
          ++v43;
        }
        while (v43 != v26);
      }
      *v42 = 0;
      if (!a4(a5, v11, a6, v55, v41))
        return 0;
    }
    return 1;
  }
  if (*(_BYTE *)(a1 + 8))
    return 1;
  v12 = sub_18BC46BB0(a1, a2, a6, v55, 200);
  if (!(_DWORD)v12)
    return 1;
  v13 = v12;
  result = a4(a5, v11, a6, v55, v12);
  if ((_DWORD)result)
  {
    v14 = (char *)&v54 + 5;
    do
    {
      v15 = v14[3];
      ++v14;
    }
    while (v15);
    while (1)
    {
      v11 = (v11 + 1);
      if ((int)v11 >= a3)
        return 1;
      v16 = v14[1];
      v17 = (v16 - 48) >= 9 && (v16 - 65) >= 5;
      v18 = v14 + 1;
      v19 = (unsigned __int8 *)v14;
      if (v17)
      {
        do
        {
          if (v16 == 70)
          {
            v19[1] = 48;
          }
          else if (v16 == 57)
          {
            v18 = (char *)(v19 + 1);
            v24 = 65;
            goto LABEL_26;
          }
          v20 = *v19--;
          v16 = v20;
          v21 = v20 - 65;
        }
        while ((v20 - 48) >= 9 && v21 >= 5);
        v18 = (char *)(v19 + 1);
      }
      v24 = v16 + 1;
LABEL_26:
      *v18 = v24;
      v23 = a4(a5, v11, a6, v55, v13);
      result = 0;
      if (!v23)
        return result;
    }
  }
  return result;
}

uint64_t uprv_getMaxCharNameLength()
{
  int v1;

  v1 = 0;
  if (sub_18BC47DFC((UErrorCode *)&v1))
    return dword_1EE0095C0;
  else
    return 0;
}

BOOL sub_18BC47DFC(UErrorCode *a1)
{
  _BOOL8 result;
  uint64_t i;
  unsigned int *v3;
  int *v4;
  int v5;
  int v6;
  _DWORD *v7;
  unsigned int v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  _BYTE *v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _BYTE *v17;
  int v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  BOOL v22;
  uint64_t j;
  char *v24;
  unsigned int v25;
  uint64_t v26;
  char *v27;
  int v28;
  size_t v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _WORD *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  _WORD *v37;
  unsigned __int8 *v38;
  uint64_t k;
  unsigned __int8 *v40;
  uint64_t v41;
  unsigned __int8 *v42;
  int v43;
  int v44;
  uint64_t v45;
  _WORD *v46;
  int v47;
  unsigned __int8 *v48;
  _OWORD v49[4];
  int v50;
  _OWORD v51[4];
  int v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (!dword_1EE0095C0)
  {
    result = sub_18BC46ACC(a1);
    if (!result)
      return result;
    for (i = 0; i != 19; ++i)
      *(_DWORD *)((char *)dword_1EE0095C4 + (((unint64_t)a0123456789abcd[i] >> 3) & 0x1C)) |= 1 << a0123456789abcd[i];
    v3 = (unsigned int *)qword_1EE0095B8;
    v4 = (int *)(qword_1EE0095B8 + *(unsigned int *)(qword_1EE0095B8 + 12));
    v5 = *v4;
    if (*v4)
    {
      v6 = 0;
      v7 = v4 + 1;
      while (*((_BYTE *)v7 + 8) != 1)
      {
        if (!*((_BYTE *)v7 + 8))
        {
          v8 = *((unsigned __int8 *)v7 + 12);
          if (*((_BYTE *)v7 + 12))
          {
            v9 = 0;
            do
            {
              dword_1EE0095C4[v8 >> 5] |= 1 << v8;
              v8 = *((unsigned __int8 *)v7 + v9++ + 13);
            }
            while (v8);
          }
          else
          {
            LODWORD(v9) = 0;
          }
          v15 = v9 + *((unsigned __int8 *)v7 + 9);
          if (v15 > v6)
            v6 = v15;
        }
LABEL_40:
        v7 = (_DWORD *)((char *)v7 + *((unsigned __int16 *)v7 + 5));
        if (!--v5)
          goto LABEL_43;
      }
      v10 = v7 + 3;
      v11 = *((unsigned __int8 *)v7 + 9);
      v12 = (char *)v7 + 2 * v11 + 12;
      v13 = *v12;
      if (*v12)
      {
        v14 = 0;
        do
        {
          dword_1EE0095C4[v13 >> 5] |= 1 << v13;
          v13 = *((unsigned __int8 *)v7 + 2 * v11 + v14++ + 13);
        }
        while (v13);
        if (!(_DWORD)v11)
        {
LABEL_38:
          if ((int)v14 > v6)
            v6 = v14;
          goto LABEL_40;
        }
      }
      else
      {
        LODWORD(v14) = 0;
        if (!*((_BYTE *)v7 + 9))
          goto LABEL_38;
      }
      v16 = 0;
      v17 = &v12[(int)v14 + 1];
      do
      {
        v18 = *((unsigned __int16 *)v10 + v16);
        if (*((_WORD *)v10 + v16))
        {
          v19 = 0;
          do
          {
            v20 = *v17;
            if (*v17)
            {
              v21 = 0;
              do
              {
                dword_1EE0095C4[v20 >> 5] |= 1 << v20;
                v20 = v17[++v21];
              }
              while (v20);
            }
            else
            {
              LODWORD(v21) = 0;
            }
            v17 += (int)v21 + 1;
            if ((int)v21 > v19)
              v19 = v21;
            v22 = __OFSUB__(v18--, 1);
          }
          while (!((v18 < 0) ^ v22 | (v18 == 0)));
        }
        else
        {
          v19 = 0;
        }
        LODWORD(v14) = v19 + v14;
        ++v16;
      }
      while (v16 != v11);
      goto LABEL_38;
    }
    v6 = 0;
LABEL_43:
    for (j = 0; j != 33; ++j)
    {
      v24 = off_1E2256638[j];
      v25 = *v24;
      if (*v24)
      {
        v26 = 0;
        v27 = v24 + 1;
        do
        {
          dword_1EE0095C4[v25 >> 5] |= 1 << v25;
          v25 = v27[v26++];
        }
        while (v25);
      }
      else
      {
        LODWORD(v26) = 0;
      }
      v28 = v26 + 9;
      if (v28 > v6)
        v6 = v28;
    }
    v29 = *((unsigned __int16 *)v3 + 8);
    v30 = *v3;
    v31 = uprv_malloc(v29);
    v32 = v31;
    if (v31)
      bzero(v31, v29);
    v45 = qword_1EE0095B8;
    v33 = (_WORD *)(qword_1EE0095B8 + *(unsigned int *)(qword_1EE0095B8 + 4));
    v34 = (unsigned __int16)*v33;
    if (*v33)
    {
      v35 = (uint64_t)v3 + 18;
      v52 = 0;
      v36 = (uint64_t)v3 + v30;
      memset(v51, 0, sizeof(v51));
      memset(v49, 0, sizeof(v49));
      v37 = v33 + 1;
      v50 = 0;
      do
      {
        v47 = v34;
        v46 = v37;
        v38 = sub_18BC48CA8((unsigned __int8 *)(v45+ *(unsigned int *)(v45 + 8)+ (((unsigned __int16)v37[1] << 16) | (unint64_t)(unsigned __int16)v37[2])), v51, v49);
        for (k = 0; k != 64; k += 2)
        {
          v40 = &v38[*(unsigned __int16 *)((char *)v51 + k)];
          v48 = v40;
          v41 = *(unsigned __int16 *)((char *)v49 + k);
          if (*(_WORD *)((char *)v49 + k))
          {
            v42 = &v40[v41];
            v43 = sub_18BC494C0(v35, v29, v36, (uint64_t)v32, &v48, &v40[v41]);
            if (v43 > v6)
              v6 = v43;
            if (v48 != v42)
            {
              v44 = sub_18BC494C0(v35, v29, v36, (uint64_t)v32, &v48, v42);
              if (v44 > v6)
                v6 = v44;
            }
          }
        }
        v37 = v46 + 3;
        v34 = v47 - 1;
      }
      while (v47 > 1);
    }
    if (v32)
      uprv_free(v32);
    dword_1EE0095C0 = v6;
  }
  return 1;
}

void uprv_getCharNameCharacters(uint64_t a1)
{
  uint64_t v2;
  unsigned int i;
  char *v4;
  unsigned __int16 *v5;
  int v6;
  int v7;
  char v8[16];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _OWORD us[32];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  memset(us, 0, sizeof(us));
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  *(_OWORD *)v8 = 0u;
  v9 = 0u;
  v7 = 0;
  if (sub_18BC47DFC((UErrorCode *)&v7))
  {
    LODWORD(v2) = 0;
    for (i = 0; i != 256; ++i)
    {
      if (((dword_1EE0095C4[i >> 5] >> i) & 1) != 0)
      {
        v8[(int)v2] = i;
        LODWORD(v2) = v2 + 1;
      }
    }
    u_charsToUChars(v8, (UChar *)us, v2);
    if ((int)v2 >= 1)
    {
      v2 = v2;
      v4 = v8;
      v5 = (unsigned __int16 *)us;
      do
      {
        v6 = *v5++;
        if (v6 || !*v4)
          (*(void (**)(_QWORD))(a1 + 8))(*(_QWORD *)a1);
        ++v4;
        --v2;
      }
      while (v2);
    }
  }
}

uint64_t uchar_swapNames(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  int v22;
  unsigned int *v23;
  unsigned int *v24;
  size_t v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned int *v32;
  unsigned int v33;
  uint64_t v34;
  unsigned __int16 *v35;
  uint64_t v36;
  __int16 *v37;
  uint64_t v38;
  unsigned __int16 *v39;
  unsigned __int16 v40;
  unsigned int v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  unsigned __int8 *v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  unsigned int *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unsigned int v65;
  unsigned __int8 *v66;
  unsigned __int8 *v67;
  unsigned __int8 *v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  int v73;
  unsigned __int8 v74;
  unsigned int *v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  size_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  unsigned __int8 *v99;
  int v100;
  uint64_t v101;
  unsigned int v102;
  unsigned int v103;
  uint64_t v104;
  unsigned int v105;
  int v106;
  unsigned int v107;
  int v108;
  unsigned int *v109;
  uint64_t v110;
  char *v111;
  _OWORD v112[3];
  __int128 v113;
  __int16 v114;
  _OWORD v115[3];
  __int128 v116;
  __int16 v117;
  _OWORD v118[16];
  _OWORD v119[16];
  __int16 v120[256];
  _QWORD v121[66];

  v10 = a3;
  v121[64] = *MEMORY[0x1E0C80C00];
  v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0)
    return 0;
  v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x6E00000075
    || *(_BYTE *)(a2 + 14) != 97
    || *(_BYTE *)(a2 + 15) != 109
    || *(_BYTE *)(a2 + 16) != 1)
  {
    udata_printError(a1, (uint64_t)"uchar_swapNames(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as unames.icu\n", v14, v15, v16, v17, v18, v19, v21);
    result = 0;
    v27 = 16;
    goto LABEL_16;
  }
  v22 = v13;
  v23 = (unsigned int *)(a2 + v13);
  if (a4)
    v24 = (unsigned int *)((char *)a4 + v13);
  else
    v24 = 0;
  if (v10 < 0)
  {
    v28 = (*(uint64_t (**)(_QWORD))(a1 + 16))(v23[3]);
    v29 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*(unsigned int *)((char *)v23 + v28));
    v30 = v28 + 4;
    if (v29)
    {
      v31 = v29;
      do
      {
        v30 += (*(uint64_t (**)(_QWORD))(a1 + 8))(*(unsigned __int16 *)((char *)v23 + v30 + 10));
        --v31;
      }
      while (v31);
    }
    return v30 + v22;
  }
  v25 = (v10 - v13);
  if ((int)v25 < 20 || (v26 = (*(uint64_t (**)(_QWORD))(a1 + 16))(v23[3]), v25 < v26))
  {
    udata_printError(a1, (uint64_t)"uchar_swapNames(): too few bytes (%d after header) for unames.icu\n", v14, v15, v16, v17, v18, v19, v25);
    result = 0;
    v27 = 8;
LABEL_16:
    *a5 = v27;
    return result;
  }
  v103 = v26;
  bzero(v120, 0x400uLL);
  memset(v119, 0, sizeof(v119));
  memset(v118, 0, sizeof(v118));
  if (v23 != v24)
    memcpy(v24, v23, v25);
  v110 = v25;
  v105 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*v23);
  v107 = (*(uint64_t (**)(_QWORD))(a1 + 16))(v23[1]);
  v102 = (*(uint64_t (**)(_QWORD))(a1 + 16))(v23[2]);
  (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(a1 + 56))(a1, v23, 16, v24, a5);
  v111 = (char *)v24;
  v109 = v23;
  v33 = *((unsigned __int16 *)v23 + 8);
  v32 = v23 + 4;
  v34 = (*(uint64_t (**)(_QWORD))(a1 + 8))(v33);
  (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(a1 + 48))(a1, v32, 2, (char *)v24 + 16, a5);
  v35 = (unsigned __int16 *)v32 + 1;
  if (v34 >= 0x201)
    v36 = 512;
  else
    v36 = v34;
  if (!(_DWORD)v36)
    goto LABEL_30;
  v37 = v120;
  v38 = v36;
  v39 = v35;
  do
  {
    v40 = *v39++;
    *v37++ = udata_readInt16(a1, v40);
    --v38;
  }
  while (v38);
  if (v36 <= 0x1FF)
LABEL_30:
    bzero((char *)v120 + (2 * v36), ((2 * (_DWORD)v36) ^ 0x3FEu) + 2);
  sub_18BC48AD4(a1, (uint64_t)v120, v34, v119, a5);
  if (v34 >= 0x100)
    v41 = v34 - 256;
  else
    v41 = 0;
  sub_18BC48AD4(a1, (uint64_t)v121, v41, v118, a5);
  if (*a5 > 0)
    return 0;
  v42 = uprv_malloc((2 * v34));
  if (!v42)
  {
    udata_printError(a1, (uint64_t)"out of memory swapping %u unames.icu tokens\n", v43, v44, v45, v46, v47, v48, v34);
    v63 = 7;
    goto LABEL_48;
  }
  v49 = v42;
  if (v34 >= 0x100)
    v50 = 256;
  else
    v50 = v34;
  if ((_DWORD)v50)
  {
    v51 = (unsigned __int8 *)v119;
    v52 = v50;
    do
    {
      v53 = *v51++;
      (*(void (**)(uint64_t, unsigned __int16 *, uint64_t, uint64_t, int *))(a1 + 48))(a1, v35++, 2, (uint64_t)v49 + 2 * v53, a5);
      --v52;
    }
    while (v52);
  }
  if (v34 >= 0x101)
  {
    v54 = v22 + 2 * v50 + a2 + 18;
    do
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(a1 + 48))(a1, v54, 2, (uint64_t)v49 + 2 * (v50 & 0x7FFFFF00) + 2 * *((unsigned __int8 *)v118 + v50), a5);
      ++v50;
      v54 += 2;
    }
    while (v34 != v50);
  }
  memcpy(v111 + 18, v49, (2 * v34));
  uprv_free(v49);
  v55 = v109;
  v56 = v111;
  udata_swapInvStringBlock(a1, (uint64_t)v109 + v105, v107 - v105, (uint64_t)&v111[v105], a5);
  if (*a5 >= 1)
  {
    udata_printError(a1, (uint64_t)"uchar_swapNames(token strings) failed\n", v57, v58, v59, v60, v61, v62, v101);
    return 0;
  }
  v64 = (*(uint64_t (**)(_QWORD))(a1 + 8))(*(unsigned __int16 *)((char *)v109 + v107));
  (*(void (**)(uint64_t, char *, _QWORD, char *, int *))(a1 + 48))(a1, (char *)v109 + v107, (6 * v64 + 2), &v111[v107], a5);
  if (*(unsigned __int8 *)(a1 + 1) != *(unsigned __int8 *)(a1 + 3))
  {
    v117 = 0;
    v116 = 0u;
    memset(v115, 0, sizeof(v115));
    v114 = 0;
    v113 = 0u;
    v65 = v103 - v102;
    memset(v112, 0, sizeof(v112));
    if (v103 - v102 >= 0x21)
    {
      v66 = (unsigned __int8 *)&v111[v102];
      v67 = (unsigned __int8 *)v109 + v102;
      do
      {
        v68 = v67;
        v67 = sub_18BC48CA8(v67, v115, v112);
        v69 = (_DWORD)v67 - (_DWORD)v68;
        v66 += v67 - v68;
        v70 = HIWORD(v113) + HIWORD(v116);
        if (v70)
        {
          v71 = HIWORD(v113) + HIWORD(v116);
          do
          {
            v72 = *v67;
            *v66 = *((_BYTE *)v119 + v72);
            v73 = v120[v72];
            if (v73 == -2)
            {
              v74 = *((_BYTE *)v118 + v67[1]);
              v67 += 2;
              v66[1] = v74;
              v66 += 2;
            }
            else
            {
              v73 = -1;
              ++v67;
              ++v66;
            }
            v71 += v73;
          }
          while (v71);
        }
        v65 = v65 - v69 - v70;
      }
      while (v65 >= 0x21);
    }
    v55 = v109;
    v56 = v111;
  }
  v75 = (unsigned int *)((char *)v55 + v103);
  v76 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*v75);
  (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(a1 + 56))(a1, v75, 4, &v56[v103], a5);
  v83 = v103 + 4;
  v106 = v76;
  if (!v76)
  {
    v30 = v103 + 4;
    return v30 + v22;
  }
  v84 = 0;
  v104 = v22 + a2 + 11;
  while (1)
  {
    if (v83 > v110)
    {
      udata_printError(a1, (uint64_t)"uchar_swapNames(): too few bytes (%d after header) for unames.icu algorithmic range %u\n", v77, v78, v79, v80, v81, v82, v110);
      v63 = 8;
      goto LABEL_48;
    }
    v85 = (uint64_t)v55 + v83;
    v86 = &v56[v83];
    v108 = (*(uint64_t (**)(_QWORD))(a1 + 8))(*(unsigned __int16 *)(v85 + 10));
    v30 = v83 + v108;
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 56))(a1, v85, 8, v86, a5);
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v85 + 10, 2, v86 + 10, a5);
    if (*(_BYTE *)(v85 + 8) == 1)
    {
      v94 = v83;
      v95 = *(unsigned __int8 *)(v85 + 9);
      v96 = v85 + 12;
      (*(void (**)(uint64_t, uint64_t, _QWORD, char *, int *))(a1 + 48))(a1, v96, (2 * v95), v86 + 12, a5);
      v97 = v55 + v30 - ((_DWORD)v96 + 2 * (_DWORD)v95);
      v98 = v108 - 2 * v95 - 11;
      v99 = (unsigned __int8 *)(v104 + v94 + 2 * v95 + v97);
      v56 = v111;
      do
      {
        if (!v97)
          break;
        --v97;
        v100 = *v99--;
        --v98;
      }
      while (v100);
      (*(void (**)(uint64_t))(a1 + 72))(a1);
      goto LABEL_71;
    }
    if (*(_BYTE *)(v85 + 8))
      break;
    v93 = strlen((const char *)(v85 + 12));
    (*(void (**)(uint64_t, uint64_t, size_t, char *, int *))(a1 + 72))(a1, v85 + 12, v93, v86 + 12, a5);
    v55 = v109;
    v56 = v111;
    if (*a5 >= 1)
    {
      udata_printError(a1, (uint64_t)"uchar_swapNames(prefix string of algorithmic range %u) failed\n", v77, v78, v79, v80, v81, v82, v84);
      return 0;
    }
LABEL_71:
    v84 = (v84 + 1);
    v83 = v30;
    if ((_DWORD)v84 == v106)
      return v30 + v22;
  }
  udata_printError(a1, (uint64_t)"uchar_swapNames(): unknown type %u of algorithmic range %u\n", v87, v88, v89, v90, v91, v92, *(unsigned __int8 *)(v85 + 8));
  v63 = 16;
LABEL_48:
  *a5 = v63;
  return 0;
}

uint64_t sub_18BC48AD4(uint64_t result, uint64_t a2, unsigned int a3, _OWORD *a4, int *a5)
{
  uint64_t v6;
  uint64_t v7;
  int8x16_t v8;
  int8x16_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char v23;
  unsigned __int8 v25;
  unsigned __int8 v26;
  _OWORD v27[16];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (*a5 <= 0)
  {
    v6 = result;
    if (*(unsigned __int8 *)(result + 1) == *(unsigned __int8 *)(result + 3))
    {
      v7 = 0;
      v8 = (int8x16_t)xmmword_18BE15160;
      v9.i64[0] = 0x1010101010101010;
      v9.i64[1] = 0x1010101010101010;
      do
      {
        a4[v7++] = v8;
        v8 = vaddq_s8(v8, v9);
      }
      while (v7 != 16);
    }
    else
    {
      a4[14] = 0u;
      a4[15] = 0u;
      if (a3 >= 0x100)
        v10 = 256;
      else
        v10 = a3;
      a4[12] = 0uLL;
      a4[13] = 0uLL;
      a4[10] = 0uLL;
      a4[11] = 0uLL;
      a4[8] = 0uLL;
      a4[9] = 0uLL;
      a4[6] = 0uLL;
      a4[7] = 0uLL;
      a4[4] = 0uLL;
      a4[5] = 0uLL;
      a4[2] = 0uLL;
      a4[3] = 0uLL;
      *a4 = 0uLL;
      a4[1] = 0uLL;
      memset(v27, 0, sizeof(v27));
      if (v10 >= 2)
      {
        v25 = 0;
        for (i = 1; i != v10; ++i)
        {
          if (*(__int16 *)(a2 + 2 * i) == -1)
          {
            v26 = i;
            result = (*(uint64_t (**)(uint64_t, unsigned __int8 *, uint64_t, unsigned __int8 *, int *))(v6 + 72))(v6, &v26, 1, &v25, a5);
            if (*a5 >= 1)
              return udata_printError(v6, (uint64_t)"unames/makeTokenMap() finds variant character 0x%02x used (input charset family %d)\n", v14, v15, v16, v17, v18, v19, i);
            v20 = v25;
            *((_BYTE *)a4 + v26) = v25;
            *((_BYTE *)v27 + v20) = 1;
          }
        }
        v21 = 1;
        v22 = 1;
        do
        {
          if (!*((_BYTE *)a4 + v21))
          {
            do
              v23 = v22;
            while (*((unsigned __int8 *)v27 + (unsigned __int16)v22++));
            *((_BYTE *)a4 + v21) = v23;
          }
          ++v21;
        }
        while (v21 != v10);
      }
    }
  }
  return result;
}

unsigned __int8 *sub_18BC48CA8(unsigned __int8 *result, _WORD *a2, _WORD *a3)
{
  unsigned int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;

  LOWORD(v3) = 0;
  v4 = 0;
  v5 = 0;
  do
  {
    v7 = *result++;
    v6 = v7;
    if ((unsigned __int16)v3 < 0xCu)
    {
      if (v6 > 0xBF)
      {
        LOWORD(v3) = 0;
        v9 = (v6 & 0x3F) + 12;
        *a2++ = v4;
        *a3++ = v9;
        v4 += v9;
        ++v5;
        continue;
      }
      v8 = v6 >> 4;
    }
    else
    {
      v8 = ((v6 >> 4) & 0xFFFFFFCF | (16 * (v3 & 3))) + 12;
    }
    *a2 = v4;
    v3 = v6 & 0xF;
    *a3 = v8;
    v4 += v8;
    if (v3 > 0xB)
    {
      ++v5;
      ++a2;
      ++a3;
    }
    else
    {
      a2[1] = v4;
      a2 += 2;
      a3[1] = v3;
      a3 += 2;
      v4 += v3;
      v5 += 2;
    }
  }
  while (v5 < 0x20);
  return result;
}

BOOL sub_18BC48D54(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  return *(unsigned __int16 *)a4 >= 0x14u
      && !a4[4]
      && !a4[5]
      && a4[8] == 117
      && a4[9] == 110
      && a4[10] == 97
      && a4[11] == 109
      && a4[12] == 1;
}

uint64_t sub_18BC48DB8()
{
  if (qword_1EE0095F0)
  {
    udata_close((_OWORD *)qword_1EE0095F0);
    qword_1EE0095F0 = 0;
  }
  if (qword_1EE0095B8)
    qword_1EE0095B8 = 0;
  atomic_store(0, &dword_1EE0095E4);
  dword_1EE0095C0 = 0;
  return 1;
}

uint64_t sub_18BC48E0C(uint64_t a1, __int16 a2, unsigned __int8 *a3, unsigned int a4, _WORD *a5, _QWORD *a6, _QWORD *a7, _BYTE *a8, __int16 a9)
{
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  unsigned __int16 v14;
  int v15;
  char v17;
  int v18;
  __int16 i;

  if (a2 == 1)
  {
    v10 = 0;
  }
  else
  {
    v10 = (unsigned __int16)(a2 - 1);
    v11 = v10;
    do
    {
      v12 = a4;
      a4 /= *(unsigned __int16 *)(a1 + 2 * v11);
      a5[v11] = v12 - a4 * *(_WORD *)(a1 + 2 * v11);
      --v11;
    }
    while ((_WORD)v11);
  }
  v13 = 0;
  v14 = 0;
  *a5 = a4;
  if (a6)
  {
LABEL_7:
    *a6++ = a3;
    goto LABEL_8;
  }
  while (1)
  {
LABEL_8:
    v15 = (unsigned __int16)a5[v13];
    if (a5[v13])
    {
      do
      {
        while (*a3++)
          ;
        --v15;
      }
      while ((_WORD)v15);
    }
    if (a7)
      *a7++ = a3;
    while (1)
    {
      v18 = *a3++;
      v17 = v18;
      if (!v18)
        break;
      if (a9)
      {
        *a8++ = v17;
        --a9;
      }
      else
      {
        a9 = 0;
      }
      ++v14;
    }
    if (v13 == v10)
      break;
    for (i = *(_WORD *)(a1 + 2 * v13) + ~a5[v13]; i; --i)
    {
      while (*a3++)
        ;
    }
    ++v13;
    if (a6)
      goto LABEL_7;
  }
  if (a9)
    *a8 = 0;
  return v14;
}

unsigned __int16 *sub_18BC48F00(uint64_t a1, unsigned int a2)
{
  unsigned __int16 *v2;
  unsigned __int16 *v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  unsigned __int16 v7;
  unsigned __int16 v8;
  unsigned int v9;
  uint64_t v10;

  v2 = (unsigned __int16 *)(a1 + *(unsigned int *)(a1 + 4));
  v5 = *v2;
  v3 = v2 + 1;
  v4 = v5;
  if (v5 < 2)
  {
    v10 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = v4;
    do
    {
      v9 = (v4 + v6) >> 1;
      if ((unsigned __int16)(a2 >> 5) < v3[3 * v9])
        v8 = v9;
      else
        v7 = v9;
      v6 = v7;
      v4 = v8;
    }
    while (v8 - 1 > v7);
    v10 = 3 * v7;
  }
  return &v3[v10];
}

uint64_t sub_18BC48F6C(unsigned int *a1, unsigned __int8 *a2, int a3, int a4, char *a5, int a6)
{
  unsigned int v6;
  uint64_t v7;
  char *v8;
  int v9;
  int v10;
  BOOL v12;
  int v13;
  char *v14;
  uint64_t v15;
  int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned int v19;
  char v20;
  unsigned __int8 *v21;
  int v22;

  v6 = *((unsigned __int16 *)a1 + 8);
  v7 = *a1;
  v8 = (char *)a1 + v7;
  if ((a4 & 0xFFFFFFFD) != 0)
  {
    if (v6 < 0x3C || *((__int16 *)a1 + 68) == -1)
    {
      v9 = a4;
      do
      {
        if ((_WORD)a3)
        {
          do
          {
            --a3;
            v10 = *a2++;
          }
          while (v10 != 59 && (unsigned __int16)a3 != 0);
        }
        else
        {
          a3 = 0;
        }
        v12 = __OFSUB__(v9--, 1);
      }
      while (!((v9 < 0) ^ v12 | (v9 == 0)));
    }
    else
    {
      a3 = 0;
    }
  }
  v13 = 0;
  v14 = (char *)a1 + 18;
  v15 = (uint64_t)a1 + v7 + 1;
LABEL_17:
  v16 = a3;
  v17 = a2;
  while ((_WORD)v16)
  {
    a3 = v16 - 1;
    a2 = v17 + 1;
    v18 = *v17;
    if (v6 <= v18)
    {
      if ((_DWORD)v18 == 59)
        break;
LABEL_29:
      if ((_WORD)a6)
      {
        *a5++ = v18;
        --a6;
      }
      else
      {
        a6 = 0;
      }
      ++v13;
      goto LABEL_17;
    }
    v19 = *(unsigned __int16 *)&v14[2 * v18];
    if (v19 == 65534)
    {
      a2 = v17 + 2;
      v19 = *(unsigned __int16 *)&v14[(2 * v17[1]) | (v18 << 9)];
      a3 = v16 - 2;
    }
    if (v19 != 0xFFFF)
    {
      v20 = v8[v19];
      if (v20)
      {
        v21 = (unsigned __int8 *)(v15 + v19);
        do
        {
          if ((_WORD)a6)
          {
            *a5++ = v20;
            --a6;
          }
          else
          {
            a6 = 0;
          }
          ++v13;
          v22 = *v21++;
          v20 = v22;
        }
        while (v22);
      }
      goto LABEL_17;
    }
    if ((_DWORD)v18 != 59)
      goto LABEL_29;
    if (a4 == 2 && !(_WORD)v13)
    {
      v13 = 0;
      v16 = a3;
      v17 = a2;
      if (*((__int16 *)a1 + 68) == -1)
        continue;
    }
    break;
  }
  if ((_WORD)a6)
    *a5 = 0;
  return (unsigned __int16)v13;
}

uint64_t sub_18BC490E0(uint64_t a1, int a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t), uint64_t a4)
{
  uint64_t v4;
  int v7;
  uint64_t v8;
  uint64_t result;
  _OWORD v10[12];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return 1;
  v4 = a1;
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  if ((int)a1 > a2)
    return 1;
  v7 = a2 + 1;
  while (1)
  {
    v8 = sub_18BC46E80(v4, (char *)v10, 200);
    *((_BYTE *)v10 + v8) = 0;
    if ((_DWORD)v8)
    {
      result = a3(a4, v4, 2, v10, v8);
      if (!(_DWORD)result)
        break;
    }
    v4 = (v4 + 1);
    if (v7 == (_DWORD)v4)
      return 1;
  }
  return result;
}

uint64_t sub_18BC491C0(unsigned __int8 *a1, uint64_t a2, uint64_t a3, int a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t, _OWORD *), uint64_t a6, uint64_t a7)
{
  unsigned __int8 *v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t result;
  char *v18;
  unsigned int v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  int v23;
  BOOL v24;
  BOOL v25;
  _BYTE *v26;
  _BOOL4 v28;
  unsigned __int8 *v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  unsigned __int8 *v34;
  int v35;
  int v36;
  _OWORD v37[12];
  uint64_t v38;
  _OWORD v39[4];
  int v40;
  _OWORD v41[4];
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v42 = 0;
  memset(v41, 0, sizeof(v41));
  v40 = 0;
  memset(v39, 0, sizeof(v39));
  v13 = sub_18BC48CA8(&a1[*((unsigned int *)a1 + 2)+ ((*(unsigned __int16 *)(a2 + 2) << 16) | (unint64_t)*(unsigned __int16 *)(a2 + 4))], v41, v39);
  if (a5)
  {
    v38 = 0;
    memset(v37, 0, sizeof(v37));
    if ((int)a3 <= a4)
    {
      v14 = a4 + 1;
      while (1)
      {
        v15 = sub_18BC48F6C((unsigned int *)a1, &v13[*((unsigned __int16 *)v41 + (a3 & 0x1F))], *((unsigned __int16 *)v39 + (a3 & 0x1F)), a7, (char *)v37, 200);
        v16 = v15;
        if ((_DWORD)a7 == 2 && !v15)
        {
          v16 = sub_18BC46E80(a3, (char *)v37, 200);
          *((_BYTE *)v37 + v16) = 0;
        }
        if (v16)
        {
          result = a5(a6, a3, a7, v37);
          if (!(_DWORD)result)
            break;
        }
        a3 = (a3 + 1);
        if (v14 == (_DWORD)a3)
          return 1;
      }
      return result;
    }
    return 1;
  }
  if ((int)a3 > a4)
    return 1;
  v18 = (char *)(a1 + 18);
  v19 = *((unsigned __int16 *)a1 + 8);
LABEL_13:
  v20 = &v13[*((unsigned __int16 *)v41 + (a3 & 0x1F))];
  v21 = *((unsigned __int16 *)v39 + (a3 & 0x1F));
  if ((a7 & 0xFFFFFFFD) != 0)
  {
    if (v19 < 0x3C || *((__int16 *)a1 + 68) == -1)
    {
      v22 = a7;
      do
      {
        if ((_WORD)v21)
        {
          do
          {
            --v21;
            v23 = *v20++;
            v24 = v23 == 59 || (unsigned __int16)v21 == 0;
          }
          while (!v24);
        }
        else
        {
          v21 = 0;
        }
        v25 = __OFSUB__(v22--, 1);
      }
      while (!((v22 < 0) ^ v25 | (v22 == 0)));
    }
    else
    {
      v21 = 0;
    }
  }
  v26 = *(_BYTE **)a6;
LABEL_29:
  v28 = (_DWORD)a7 == 2 && v26 == *(_BYTE **)a6;
  v29 = v20;
  v30 = v21;
  while ((_WORD)v30)
  {
    v21 = v30 - 1;
    v20 = v29 + 1;
    v31 = *v29;
    if (v19 <= v31)
    {
      if ((_DWORD)v31 == 59)
        break;
LABEL_46:
      v33 = *v26++;
      if ((_DWORD)v31 == v33)
        goto LABEL_29;
LABEL_53:
      v24 = (_DWORD)a3 == a4;
      LODWORD(a3) = a3 + 1;
      if (v24)
        return 1;
      goto LABEL_13;
    }
    v32 = *(unsigned __int16 *)&v18[2 * v31];
    if (v32 == 65534)
    {
      v20 = v29 + 2;
      v32 = *(unsigned __int16 *)&v18[(2 * v29[1]) | (v31 << 9)];
      v21 = v30 - 2;
    }
    if (v32 != 0xFFFF)
    {
      v34 = &a1[*(unsigned int *)a1 + v32];
      while (1)
      {
        v35 = *v34;
        if (!*v34)
          goto LABEL_29;
        ++v34;
        v36 = *v26++;
        if (v35 != v36)
          goto LABEL_53;
      }
    }
    if ((_DWORD)v31 != 59)
      goto LABEL_46;
    if (!v28)
      break;
    v29 = v20;
    v30 = v21;
    if (*((__int16 *)a1 + 68) != -1)
    {
      v26 = *(_BYTE **)a6;
      break;
    }
  }
  if (*v26)
    goto LABEL_53;
  result = 0;
  *(_DWORD *)(a6 + 8) = a3;
  return result;
}

uint64_t sub_18BC494C0(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned __int8 **a5, unsigned __int8 *a6)
{
  unsigned __int8 *v6;
  uint64_t result;
  uint64_t v9;
  unsigned __int8 *v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;

  v6 = *a5;
  if (*a5 != a6)
  {
    result = 0;
    v9 = a3 + 1;
    v10 = *a5;
    while (1)
    {
      v12 = *v10++;
      v11 = v12;
      if (v12 == 59)
      {
        a6 = v10;
        goto LABEL_29;
      }
      if (v11 >= a2)
      {
        *(_DWORD *)((char *)dword_1EE0095C4 + ((v11 >> 3) & 0x1C)) |= 1 << v11;
      }
      else
      {
        v13 = *(unsigned __int16 *)(a1 + 2 * v11);
        if (v13 == 65534)
        {
          v10 = v6 + 2;
          LODWORD(v11) = v6[1] | ((_DWORD)v11 << 8);
          v13 = *(unsigned __int16 *)(a1 + 2 * v11);
        }
        if (v13 != 0xFFFF)
        {
          if (a4)
          {
            LODWORD(v14) = *(char *)(a4 + v11);
            if (!*(_BYTE *)(a4 + v11))
            {
              v15 = *(unsigned __int8 *)(a3 + v13);
              if (*(_BYTE *)(a3 + v13))
              {
                v14 = 0;
                v16 = v9 + v13;
                do
                {
                  dword_1EE0095C4[v15 >> 5] |= 1 << v15;
                  v15 = *(unsigned __int8 *)(v16 + v14++);
                }
                while (v15);
              }
              else
              {
                LODWORD(v14) = 0;
              }
              *(_BYTE *)(a4 + v11) = v14;
            }
          }
          else
          {
            v17 = *(unsigned __int8 *)(a3 + v13);
            if (*(_BYTE *)(a3 + v13))
            {
              v14 = 0;
              v18 = v9 + v13;
              do
              {
                dword_1EE0095C4[v17 >> 5] |= 1 << v17;
                v17 = *(unsigned __int8 *)(v18 + v14++);
              }
              while (v17);
            }
            else
            {
              LODWORD(v14) = 0;
            }
          }
          result = (v14 + result);
          goto LABEL_25;
        }
        dword_1EE0095C4[v11 >> 5] |= 1 << v11;
      }
      result = (result + 1);
LABEL_25:
      v6 = v10;
      if (v10 == a6)
        goto LABEL_29;
    }
  }
  result = 0;
LABEL_29:
  *a5 = a6;
  return result;
}

uint64_t sub_18BC49620(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
}

uint64_t sub_18BC4962C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t sub_18BC49648(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t icu::UnifiedCache::getInstance(UErrorCode *this, UErrorCode *a2)
{
  unsigned int v3;
  unint64_t v4;
  icu::UnifiedCache *v5;
  icu::UnifiedCache *v6;
  UErrorCode v7;

  if (*(int *)this > 0)
    goto LABEL_12;
  v3 = atomic_load(&dword_1ECD27C10);
  if (v3 != 2 && icu::umtx_initImplPreInit(&dword_1ECD27C10))
  {
    sub_18BC0ECC4(0x1Bu, (uint64_t)sub_18BC4A31C);
    qword_1ECD27C18 = 850045863;
    unk_1ECD27C20 = 0u;
    unk_1ECD27C30 = 0u;
    unk_1ECD27C40 = 0u;
    qword_1ECD27C50 = 0;
    qword_1ECD27C00 = (uint64_t)&qword_1ECD27C18;
    qword_1ECD27C58 = 1018212795;
    *(_OWORD *)algn_1ECD27C60 = 0u;
    *(_OWORD *)&algn_1ECD27C60[16] = 0u;
    qword_1ECD27C80 = 0;
    qword_1ECD27C08 = (uint64_t)&qword_1ECD27C58;
    v5 = (icu::UnifiedCache *)icu::UMemory::operator new(&qword_1ECD27C58, (icu::UMemory *)0x38, v4);
    if (v5)
    {
      v6 = icu::UnifiedCache::UnifiedCache(v5, this);
      qword_1ECD27BF8 = (uint64_t)v6;
      v7 = *this;
      if (*(int *)this < 1)
      {
LABEL_11:
        dword_1ECD27C14 = v7;
        icu::umtx_initImplPostInit(&dword_1ECD27C10);
        goto LABEL_12;
      }
      (*(void (**)(icu::UnifiedCache *))(*(_QWORD *)v6 + 8))(v6);
      v7 = *this;
    }
    else
    {
      v7 = U_MEMORY_ALLOCATION_ERROR;
      *this = U_MEMORY_ALLOCATION_ERROR;
    }
    qword_1ECD27BF8 = 0;
    goto LABEL_11;
  }
  if (dword_1ECD27C14 >= 1)
    *this = dword_1ECD27C14;
LABEL_12:
  if (*(int *)this >= 1)
    return 0;
  else
    return qword_1ECD27BF8;
}

icu::UnifiedCache *icu::UnifiedCache::UnifiedCache(icu::UnifiedCache *this, UErrorCode *a2)
{
  uint64_t *v3;
  uint64_t *v6;
  int32x2_t *v7;

  *(_QWORD *)this = off_1E2256750;
  *((_QWORD *)this + 1) = 0;
  *((_OWORD *)this + 1) = xmmword_18BE15180;
  *((_DWORD *)this + 8) = 100;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  v3 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v3 <= 0)
  {
    v6 = icu::UMemory::operator new(v3, (icu::UMemory *)0x18, (unint64_t)a2);
    if (v6)
    {
      v6[1] = 0;
      v6[2] = 0;
      *v6 = (uint64_t)&unk_1E224B810;
      *((_QWORD *)this + 6) = v6;
      *((_DWORD *)v6 + 2) = 1;
      atomic_store(1u, (unsigned int *)v6 + 3);
      *(_QWORD *)(*((_QWORD *)this + 6) + 16) = this;
      v7 = uhash_open((uint64_t)sub_18BC49620, (uint64_t)sub_18BC4962C, 0, (int *)a2);
      *((_QWORD *)this + 1) = v7;
      if (*(int *)a2 <= 0)
        uhash_setKeyDeleter((uint64_t)v7, (uint64_t)sub_18BC49648);
    }
    else
    {
      *((_QWORD *)this + 6) = 0;
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }
  return this;
}

void icu::UnifiedCache::setEvictionPolicy(icu::UnifiedCache *this, int a2, int a3, UErrorCode *a4)
{
  std::mutex *v7;

  if (*(int *)a4 <= 0)
  {
    if ((a3 | a2) < 0)
    {
      *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    }
    else
    {
      v7 = (std::mutex *)qword_1ECD27C00;
      std::mutex::lock((std::mutex *)qword_1ECD27C00);
      *((_DWORD *)this + 7) = a2;
      *((_DWORD *)this + 8) = a3;
      std::mutex::unlock(v7);
    }
  }
}

uint64_t icu::UnifiedCache::unusedCount(icu::UnifiedCache *this)
{
  std::mutex *v2;
  uint64_t v3;

  v2 = (std::mutex *)qword_1ECD27C00;
  std::mutex::lock((std::mutex *)qword_1ECD27C00);
  v3 = uhash_count(*((_QWORD *)this + 1)) - *((_DWORD *)this + 6);
  std::mutex::unlock(v2);
  return v3;
}

uint64_t icu::UnifiedCache::autoEvictedCount(icu::UnifiedCache *this)
{
  std::mutex *v2;
  uint64_t v3;

  v2 = (std::mutex *)qword_1ECD27C00;
  std::mutex::lock((std::mutex *)qword_1ECD27C00);
  v3 = *((_QWORD *)this + 5);
  std::mutex::unlock(v2);
  return v3;
}

uint64_t icu::UnifiedCache::keyCount(icu::UnifiedCache *this)
{
  std::mutex *v2;
  uint64_t v3;

  v2 = (std::mutex *)qword_1ECD27C00;
  std::mutex::lock((std::mutex *)qword_1ECD27C00);
  v3 = uhash_count(*((_QWORD *)this + 1));
  std::mutex::unlock(v2);
  return v3;
}

void icu::UnifiedCache::flush(icu::UnifiedCache *this)
{
  std::mutex *v2;

  v2 = (std::mutex *)qword_1ECD27C00;
  std::mutex::lock((std::mutex *)qword_1ECD27C00);
  while (icu::UnifiedCache::_flush(this, 0))
    ;
  std::mutex::unlock(v2);
}

uint64_t icu::UnifiedCache::_flush(icu::UnifiedCache *this, int a2)
{
  int v4;
  int v5;
  char v6;
  uint64_t Element;
  uint64_t v8;
  const icu::SharedObject *v9;

  v4 = uhash_count(*((_QWORD *)this + 1));
  if (v4 < 1)
  {
    return 0;
  }
  else
  {
    v5 = v4;
    v6 = 0;
    do
    {
      Element = icu::UnifiedCache::_nextElement(this);
      if (!Element)
        break;
      v8 = Element;
      if (a2 || icu::UnifiedCache::_isEvictable((uint64_t)this, Element))
      {
        v9 = *(const icu::SharedObject **)(v8 + 8);
        uhash_removeElement(*((_QWORD *)this + 1), (_DWORD *)v8);
        icu::UnifiedCache::removeSoftRef((uint64_t)this, v9);
        v6 = 1;
      }
      --v5;
    }
    while (v5);
  }
  return v6;
}

void icu::UnifiedCache::handleUnreferencedObject(icu::UnifiedCache *this)
{
  std::mutex *v2;

  v2 = (std::mutex *)qword_1ECD27C00;
  std::mutex::lock((std::mutex *)qword_1ECD27C00);
  --*((_DWORD *)this + 6);
  icu::UnifiedCache::_runEvictionSlice(this);
  std::mutex::unlock(v2);
}

uint64_t icu::UnifiedCache::_runEvictionSlice(icu::UnifiedCache *this)
{
  uint64_t result;
  int v3;
  unint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  const icu::SharedObject *v9;

  result = uhash_count(*((_QWORD *)this + 1));
  v3 = *((_DWORD *)this + 6);
  v4 = 1374389535 * *((_DWORD *)this + 8) * v3;
  v5 = (v4 >> 63) + (SHIDWORD(v4) >> 5);
  if (v5 <= *((_DWORD *)this + 7))
    v5 = *((_DWORD *)this + 7);
  v6 = result - v3 - v5;
  if (v6 >= 1)
  {
    v7 = 10;
    do
    {
      result = icu::UnifiedCache::_nextElement(this);
      if (!result)
        break;
      v8 = result;
      result = icu::UnifiedCache::_isEvictable((uint64_t)this, result);
      if ((_DWORD)result)
      {
        v9 = *(const icu::SharedObject **)(v8 + 8);
        uhash_removeElement(*((_QWORD *)this + 1), (_DWORD *)v8);
        result = icu::UnifiedCache::removeSoftRef((uint64_t)this, v9);
        ++*((_QWORD *)this + 5);
        if (!--v6)
          break;
      }
      --v7;
    }
    while (v7);
  }
  return result;
}

void icu::UnifiedCache::~UnifiedCache(void ***this)
{
  std::mutex *v2;
  void **v3;

  *this = (void **)off_1E2256750;
  icu::UnifiedCache::flush((icu::UnifiedCache *)this);
  v2 = (std::mutex *)qword_1ECD27C00;
  std::mutex::lock((std::mutex *)qword_1ECD27C00);
  icu::UnifiedCache::_flush((icu::UnifiedCache *)this, 1);
  std::mutex::unlock(v2);
  uhash_close(this[1]);
  this[1] = 0;
  v3 = this[6];
  if (v3)
    (*((void (**)(void **))*v3 + 1))(v3);
  this[6] = 0;
  icu::UnifiedCacheBase::~UnifiedCacheBase((icu::UnifiedCacheBase *)this);
}

{
  void *v1;

  icu::UnifiedCache::~UnifiedCache(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::UnifiedCache::_nextElement(icu::UnifiedCache *this)
{
  uint64_t result;

  result = uhash_nextElement(*((uint64_t **)this + 1), (int *)this + 4);
  if (!result)
  {
    *((_DWORD *)this + 4) = -1;
    return uhash_nextElement(*((uint64_t **)this + 1), (int *)this + 4);
  }
  return result;
}

BOOL icu::UnifiedCache::_isEvictable(uint64_t a1, uint64_t a2)
{
  icu::SharedObject *v3;
  uint64_t v4;
  icu::SharedObject *v5;
  BOOL v6;

  v3 = *(icu::SharedObject **)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(icu::SharedObject **)(a1 + 48);
  if (*(_DWORD *)(v4 + 8))
    v6 = 0;
  else
    v6 = v5 == v3;
  if (v6)
    return 0;
  if (*(_BYTE *)(v4 + 12))
  {
    if (*((_DWORD *)v3 + 2) == 1)
      return icu::SharedObject::getRefCount(v3) == 0;
    return 0;
  }
  return 1;
}

uint64_t icu::UnifiedCache::removeSoftRef(uint64_t this, const icu::SharedObject *a2)
{
  int v2;

  v2 = *((_DWORD *)a2 + 2) - 1;
  *((_DWORD *)a2 + 2) = v2;
  if (!v2)
  {
    --*(_DWORD *)(this + 20);
    this = icu::SharedObject::getRefCount(a2);
    if ((_DWORD)this)
      *((_QWORD *)a2 + 2) = 0;
    else
      return (*(uint64_t (**)(const icu::SharedObject *))(*(_QWORD *)a2 + 8))(a2);
  }
  return this;
}

uint64_t icu::UnifiedCache::_computeCountOfItemsToEvict(icu::UnifiedCache *this)
{
  int v2;
  int v3;
  unint64_t v4;
  int v5;

  v2 = uhash_count(*((_QWORD *)this + 1));
  v3 = *((_DWORD *)this + 6);
  v4 = 1374389535 * *((_DWORD *)this + 8) * v3;
  v5 = (v4 >> 63) + (SHIDWORD(v4) >> 5);
  if (v5 <= *((_DWORD *)this + 7))
    v5 = *((_DWORD *)this + 7);
  return (v2 - v3 - v5) & ~((v2 - v3 - v5) >> 31);
}

uint64_t icu::UnifiedCache::_putNew(uint64_t this, const icu::CacheKeyBase *a2, const icu::SharedObject *a3, UErrorCode a4, UErrorCode *a5)
{
  uint64_t v8;

  if (*(int *)a5 <= 0)
  {
    v8 = this;
    this = (*(uint64_t (**)(const icu::CacheKeyBase *))(*(_QWORD *)a2 + 32))(a2);
    if (this)
    {
      *(_DWORD *)(this + 8) = a4;
      if (!*((_DWORD *)a3 + 2))
      {
        *(_BYTE *)(this + 12) = 1;
        *((_QWORD *)a3 + 2) = v8;
        *(int32x2_t *)(v8 + 20) = vadd_s32(*(int32x2_t *)(v8 + 20), (int32x2_t)0x100000001);
      }
      this = uhash_put(*(_QWORD *)(v8 + 8), this, (uint64_t)a3, (int *)a5);
      if (*(int *)a5 <= 0)
        ++*((_DWORD *)a3 + 2);
    }
    else
    {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
    }
  }
  return this;
}

int32x2_t icu::UnifiedCache::_registerPrimary(icu::UnifiedCache *this, const icu::CacheKeyBase *a2, const icu::SharedObject *a3)
{
  int32x2_t result;

  *((_BYTE *)a2 + 12) = 1;
  *((_QWORD *)a3 + 2) = this;
  result = vadd_s32(*(int32x2_t *)((char *)this + 20), (int32x2_t)0x100000001);
  *(int32x2_t *)((char *)this + 20) = result;
  return result;
}

void icu::UnifiedCache::_putIfAbsentAndGet(icu::UnifiedCache *this, const icu::CacheKeyBase *a2, const icu::SharedObject **a3, UErrorCode *a4)
{
  std::mutex *v8;
  int *v9;
  uint64_t v10;
  UErrorCode v11;

  v8 = (std::mutex *)qword_1ECD27C00;
  std::mutex::lock((std::mutex *)qword_1ECD27C00);
  v9 = uhash_find(*((_QWORD *)this + 1), (uint64_t)a2);
  if (v9)
  {
    v10 = (uint64_t)v9;
    if (!icu::UnifiedCache::_inProgress((uint64_t)this, (uint64_t)v9))
    {
      icu::UnifiedCache::_fetch((uint64_t)this, v10, a3, a4);
      goto LABEL_7;
    }
    icu::UnifiedCache::_put((uint64_t)this, v10, (uint64_t)*a3, *a4);
  }
  else
  {
    v11 = U_ZERO_ERROR;
    icu::UnifiedCache::_putNew((uint64_t)this, a2, *a3, *a4, &v11);
  }
  icu::UnifiedCache::_runEvictionSlice(this);
LABEL_7:
  std::mutex::unlock(v8);
}

BOOL icu::UnifiedCache::_inProgress(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int *v4;
  unsigned int v5;
  BOOL v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 8);
  if (v2)
  {
    v4 = (unsigned int *)(v2 + 12);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
    if (!v5)
      ++*(_DWORD *)(a1 + 24);
    if (v3)
      v6 = 0;
    else
      v6 = *(_QWORD *)(a1 + 48) == v2;
    v7 = v6;
    do
    {
      v8 = __ldaxr(v4);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v4));
    if (!v9)
      --*(_DWORD *)(a1 + 24);
  }
  else
  {
    return !v3 && *(_QWORD *)(a1 + 48) == 0;
  }
  return v7;
}

uint64_t icu::UnifiedCache::_fetch(uint64_t result, uint64_t a2, _QWORD *a3, _DWORD *a4)
{
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;

  *a4 = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 8);
  if (*a3)
  {
    v4 = (unsigned int *)(*a3 + 12);
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      --*(_DWORD *)(result + 24);
  }
  v7 = *(_QWORD *)(a2 + 8);
  *a3 = v7;
  if (v7)
  {
    v8 = (unsigned int *)(v7 + 12);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
    if (!v9)
      ++*(_DWORD *)(result + 24);
  }
  return result;
}

void icu::UnifiedCache::_put(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  const icu::SharedObject *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v7 = a2 + 8;
  v5 = *(const icu::SharedObject **)(a2 + 8);
  v6 = *(_QWORD *)(v7 + 8);
  *(_DWORD *)(v6 + 8) = a4;
  v8 = *(_DWORD *)(a3 + 8);
  if (!v8)
  {
    *(_BYTE *)(v6 + 12) = 1;
    *(_QWORD *)(a3 + 16) = a1;
    *(int32x2_t *)(a1 + 20) = vadd_s32(*(int32x2_t *)(a1 + 20), (int32x2_t)0x100000001);
  }
  *(_DWORD *)(a3 + 8) = v8 + 1;
  *(_QWORD *)(a2 + 8) = a3;
  icu::UnifiedCache::removeSoftRef(a1, v5);
  std::condition_variable::notify_all((std::condition_variable *)qword_1ECD27C08);
}

uint64_t icu::UnifiedCache::_poll(icu::UnifiedCache *this, const icu::CacheKeyBase *a2, const icu::SharedObject **a3, UErrorCode *a4)
{
  int *v8;
  int *v9;
  uint64_t v10;
  std::unique_lock<std::mutex> v12;

  v12.__m_ = (std::unique_lock<std::mutex>::mutex_type *)qword_1ECD27C00;
  *(_QWORD *)&v12.__owns_ = 1;
  std::mutex::lock((std::mutex *)qword_1ECD27C00);
  v8 = uhash_find(*((_QWORD *)this + 1), (uint64_t)a2);
  if (v8)
  {
    v9 = v8;
    while (icu::UnifiedCache::_inProgress((uint64_t)this, (uint64_t)v9))
    {
      std::condition_variable::wait((std::condition_variable *)qword_1ECD27C08, &v12);
      v9 = uhash_find(*((_QWORD *)this + 1), (uint64_t)a2);
      if (!v9)
        goto LABEL_5;
    }
    icu::UnifiedCache::_fetch((uint64_t)this, (uint64_t)v9, a3, a4);
    v10 = 1;
  }
  else
  {
LABEL_5:
    icu::UnifiedCache::_putNew((uint64_t)this, a2, *((const icu::SharedObject **)this + 6), U_ZERO_ERROR, a4);
    v10 = 0;
  }
  if (v12.__owns_)
    std::mutex::unlock(v12.__m_);
  return v10;
}

const icu::SharedObject *icu::UnifiedCache::_get(icu::SharedObject **this, const icu::CacheKeyBase *a2, const icu::SharedObject **a3, const void *a4, UErrorCode *a5)
{
  const icu::SharedObject *result;
  BOOL v11;
  const icu::SharedObject *v12;

  result = (const icu::SharedObject *)icu::UnifiedCache::_poll((icu::UnifiedCache *)this, a2, a3, a5);
  if ((_DWORD)result)
  {
    result = *a3;
    if (*a3)
      v11 = result == this[6];
    else
      v11 = 0;
    if (!v11)
      return result;
LABEL_7:
    result = (const icu::SharedObject *)icu::SharedObject::removeRef(result);
    *a3 = 0;
    return result;
  }
  if (*(int *)a5 <= 0)
  {
    v12 = (const icu::SharedObject *)(*(uint64_t (**)(const icu::CacheKeyBase *, const void *, UErrorCode *))(*(_QWORD *)a2 + 40))(a2, a4, a5);
    *a3 = v12;
    if (!v12)
      sub_18BC4A244(this[6], a3);
    icu::UnifiedCache::_putIfAbsentAndGet((icu::UnifiedCache *)this, a2, a3, a5);
    result = *a3;
    if (*a3)
    {
      if (result == this[6])
        goto LABEL_7;
    }
  }
  return result;
}

icu::SharedObject *sub_18BC4A244(icu::SharedObject *this, icu::SharedObject **a2)
{
  icu::SharedObject *result;

  result = *a2;
  if (*a2 != this)
  {
    if (result)
      result = (icu::SharedObject *)icu::SharedObject::removeRef(result);
    *a2 = this;
    if (this)
      return (icu::SharedObject *)icu::SharedObject::addRef((uint64_t)this);
  }
  return result;
}

uint64_t icu::UnifiedCache::removeHardRef(icu::UnifiedCache *this, const icu::SharedObject *a2)
{
  unsigned int *v2;
  unsigned int v3;
  uint64_t v4;

  if (!a2)
    return 0;
  v2 = (unsigned int *)((char *)a2 + 12);
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, v2));
  if (!(_DWORD)v4)
  {
    v4 = 0;
    --*((_DWORD *)this + 6);
  }
  return v4;
}

uint64_t icu::UnifiedCache::addHardRef(icu::UnifiedCache *this, const icu::SharedObject *a2)
{
  unsigned int *v2;
  unsigned int v3;
  uint64_t v4;

  if (!a2)
    return 0;
  v2 = (unsigned int *)((char *)a2 + 12);
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 + 1;
  }
  while (__stlxr(v4, v2));
  if (!v3)
  {
    ++*((_DWORD *)this + 6);
    return 1;
  }
  return v4;
}

BOOL icu::UnifiedCache::_inProgress(icu::UnifiedCache *this, const icu::SharedObject *a2, UErrorCode a3)
{
  return a3 == U_ZERO_ERROR && *((_QWORD *)this + 6) == (_QWORD)a2;
}

uint64_t sub_18BC4A31C()
{
  atomic_store(0, &dword_1ECD27C10);
  if (qword_1ECD27BF8)
    (*(void (**)(uint64_t))(*(_QWORD *)qword_1ECD27BF8 + 8))(qword_1ECD27BF8);
  qword_1ECD27BF8 = 0;
  std::mutex::~mutex((std::mutex *)qword_1ECD27C00);
  qword_1ECD27C00 = 0;
  std::condition_variable::~condition_variable((std::condition_variable *)qword_1ECD27C08);
  qword_1ECD27C08 = 0;
  return 1;
}

void *icu::UnicodeFilter::getStaticClassID(icu::UnicodeFilter *this)
{
  return &unk_1EE0095F8;
}

uint64_t icu::UnicodeFilter::toMatcher(icu::UnicodeFilter *this)
{
  if (this)
    return (uint64_t)this + 8;
  else
    return 0;
}

uint64_t icu::UnicodeFilter::matches(uint64_t a1, uint64_t a2, int *a3, int a4, int a5)
{
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  int v18;

  v10 = *a3;
  if (*a3 < a4)
  {
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2);
    v12 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 56))(a1, v11);
    v10 = *a3;
    if (v12)
    {
      if (v11 < 0x10000)
        v13 = 1;
      else
        v13 = 2;
      v14 = v10 + v13;
      goto LABEL_11;
    }
  }
  if (v10 > a4)
  {
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2);
    v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 56))(a1, v15);
    v10 = *a3;
    if (v16)
    {
      v17 = __OFSUB__(v10, 1);
      v18 = v10 - 1;
      *a3 = v18;
      if (v18 < 0 != v17)
        return 2;
      v14 = *a3 - (((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2) & 0xFFFF0000) != 0);
LABEL_11:
      *a3 = v14;
      return 2;
    }
  }
  return a5 && v10 == a4;
}

uint64_t `non-virtual thunk to'icu::UnicodeFilter::matches(uint64_t a1, uint64_t a2, int *a3, int a4, int a5)
{
  return icu::UnicodeFilter::matches(a1 - 8, a2, a3, a4, a5);
}

void *icu::UnicodeFunctor::getStaticClassID(icu::UnicodeFunctor *this)
{
  return &unk_1EE0095F9;
}

uint64_t icu::UnicodeFunctor::toMatcher(icu::UnicodeFunctor *this)
{
  return 0;
}

uint64_t icu::UnicodeFunctor::toReplacer(icu::UnicodeFunctor *this)
{
  return 0;
}

void *icu::UnicodeSet::getStaticClassID(icu::UnicodeSet *this)
{
  return &unk_1EE0095FA;
}

void *icu::UnicodeSet::getDynamicClassID(icu::UnicodeSet *this)
{
  return &unk_1EE0095FA;
}

BOOL icu::UnicodeSet::hasStrings(icu::UnicodeSet *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 10);
  return v1 && *(_DWORD *)(v1 + 8) != 0;
}

uint64_t icu::UnicodeSet::stringsSize(icu::UnicodeSet *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 10);
  if (v1)
    return *(unsigned int *)(v1 + 8);
  else
    return 0;
}

icu::UVector *icu::UnicodeSet::stringsContains(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  icu::UVector *result;

  result = (icu::UVector *)*((_QWORD *)this + 10);
  if (result)
    return (icu::UVector *)((int)icu::UVector::indexOf(result, (uint64_t)a2, 0) >= 0);
  return result;
}

double icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this)
{
  double result;

  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_DWORD *)this + 24) = 1114112;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *(_QWORD *)&result = 0x100000019;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_DWORD *)this + 24) = 1114112;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *(_QWORD *)&result = 0x100000019;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_DWORD *)this + 24) = 1114112;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return icu::UnicodeSet::add(this, a2, a3);
}

{
  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_DWORD *)this + 24) = 1114112;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return icu::UnicodeSet::add(this, a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::add(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  int v4;
  int v5;
  unsigned int v6;
  int v7;
  int v8;
  uint64_t v9;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  int v16[3];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    v5 = 0;
  }
  else
  {
    v5 = 1114111;
    if (a2 <= 0x10FFFF)
    {
      if ((a3 & 0x80000000) == 0)
        goto LABEL_4;
LABEL_8:
      v4 = 0;
      goto LABEL_9;
    }
  }
  a2 = v5;
  if ((a3 & 0x80000000) != 0)
    goto LABEL_8;
LABEL_4:
  if (a3 > 0x10FFFF)
LABEL_9:
    a3 = v4;
  if (a2 < a3)
  {
    v6 = a3 + 1;
    v7 = *((_DWORD *)this + 7);
    if ((v7 & 1) != 0)
    {
      if (v7 == 1)
      {
        v8 = -2;
      }
      else
      {
        v8 = *(_DWORD *)(*((_QWORD *)this + 2) + 4 * (v7 - 2));
        if (v8 > (int)a2)
          goto LABEL_23;
      }
      if (!*((_QWORD *)this + 5) && !*((_QWORD *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
      {
        v9 = *((_QWORD *)this + 2);
        if (v8 == a2)
        {
          *(_DWORD *)(v9 + 4 * (v7 - 2)) = v6;
          if (a3 == 1114111)
            --*((_DWORD *)this + 7);
          goto LABEL_31;
        }
        *(_DWORD *)(v9 + 4 * (v7 - 1)) = a2;
        v11 = *((_DWORD *)this + 7);
        if (a3 >= 0x10FFFF)
        {
          if (!icu::UnicodeSet::ensureCapacity(this, v11 + 1))
            goto LABEL_31;
          v12 = *((_QWORD *)this + 2);
        }
        else
        {
          if (!icu::UnicodeSet::ensureCapacity(this, v11 + 2))
            goto LABEL_31;
          v12 = *((_QWORD *)this + 2);
          v13 = *((int *)this + 7);
          *((_DWORD *)this + 7) = v13 + 1;
          *(_DWORD *)(v12 + 4 * v13) = v6;
        }
        v14 = *((int *)this + 7);
        *((_DWORD *)this + 7) = v14 + 1;
        *(_DWORD *)(v12 + 4 * v14) = 1114112;
LABEL_31:
        v15 = (void *)*((_QWORD *)this + 8);
        if (v15)
        {
          uprv_free(v15);
          *((_QWORD *)this + 8) = 0;
          *((_DWORD *)this + 18) = 0;
        }
        return this;
      }
    }
LABEL_23:
    v16[0] = a2;
    v16[1] = a3 + 1;
    v16[2] = 1114112;
    icu::UnicodeSet::add(this, v16, 2, 0);
    return this;
  }
  if (a2 == a3)
    icu::UnicodeSet::add(this, a2);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, const icu::UnicodeSet *a2)
{
  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return icu::UnicodeSet::copyFrom(this, a2, 0);
}

{
  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return icu::UnicodeSet::copyFrom(this, a2, 0);
}

{
  icu::UVector **v4;
  uint64_t v5;
  uint64_t v6;
  const UChar *v7;
  UErrorCode v9;

  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 10) = 0;
  v4 = (icu::UVector **)((char *)this + 80);
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  if (icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)a2 + 7)))
  {
    v5 = *((int *)a2 + 7);
    *((_DWORD *)this + 7) = v5;
    memcpy(*((void **)this + 2), *((const void **)a2 + 2), 4 * v5);
    v6 = *((_QWORD *)a2 + 10);
    if (v6
      && *(_DWORD *)(v6 + 8)
      && ((v9 = U_ZERO_ERROR, !icu::UnicodeSet::allocateStrings(this, &v9))
       || (icu::UVector::assign(*v4, *((_QWORD *)a2 + 10), (uint64_t (*)(uint64_t, uint64_t))sub_18BC4AB4C, &v9),
           v9 > U_ZERO_ERROR)))
    {
      icu::UnicodeSet::clear(this);
      *((_BYTE *)this + 32) = 1;
    }
    else
    {
      v7 = (const UChar *)*((_QWORD *)a2 + 8);
      if (v7)
        icu::UnicodeSet::setPattern((uint64_t)this, v7, *((_DWORD *)a2 + 18));
    }
  }
  return this;
}

{
  return icu::UnicodeSet::UnicodeSet(this, a2);
}

icu::UnicodeSet *icu::UnicodeSet::operator=(icu::UnicodeSet *a1, const icu::UnicodeSet *a2)
{
  return icu::UnicodeSet::copyFrom(a1, a2, 0);
}

uint64_t icu::UnicodeSet::ensureCapacity(icu::UnicodeSet *this, int a2)
{
  int v2;
  int v4;
  int v5;
  void *v6;
  void *v7;
  char *v8;
  uint64_t result;

  if (a2 > 1114112)
    v2 = 1114113;
  else
    v2 = a2;
  if (v2 <= *((_DWORD *)this + 6))
    return 1;
  if ((2 * v2) > 0x110000)
    v4 = 1114113;
  else
    v4 = 2 * v2;
  if (v2 <= 0x9C4)
    v4 = 5 * v2;
  if (v2 <= 24)
    v5 = v2 + 25;
  else
    v5 = v4;
  v6 = uprv_malloc(4 * v5);
  if (v6)
  {
    v7 = v6;
    v8 = (char *)*((_QWORD *)this + 2);
    memcpy(v6, v8, 4 * *((int *)this + 7));
    if (v8 != (char *)this + 96)
      uprv_free(v8);
    *((_QWORD *)this + 2) = v7;
    *((_DWORD *)this + 6) = v5;
    return 1;
  }
  icu::UnicodeSet::clear(this);
  result = 0;
  *((_BYTE *)this + 32) = 1;
  return result;
}

uint64_t icu::UnicodeSet::allocateStrings(icu::UnicodeSet *this, UErrorCode *a2)
{
  uint64_t v2;
  uint64_t v6;
  uint64_t v7;

  if (*(int *)a2 > 0)
    return 0;
  v6 = icu::UMemory::operator new((icu::UMemory *)0x28, (unint64_t)a2);
  if (v6)
  {
    v2 = 1;
    v7 = icu::UVector::UVector(v6, uprv_deleteUObject, uhash_compareUnicodeString, 1, a2);
    *((_QWORD *)this + 10) = v7;
    if (*(int *)a2 >= 1)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      v2 = 0;
      *((_QWORD *)this + 10) = 0;
    }
  }
  else
  {
    v2 = 0;
    *((_QWORD *)this + 10) = 0;
    *a2 = U_MEMORY_ALLOCATION_ERROR;
  }
  return v2;
}

icu::UnicodeString *sub_18BC4AB4C(icu::UnicodeString **a1, UChar ***a2)
{
  icu::UnicodeString *result;

  result = (icu::UnicodeString *)icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
  if (result)
    result = icu::UnicodeString::UnicodeString(result, *a2);
  *a1 = result;
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::setToBogus(icu::UnicodeSet *this)
{
  icu::UnicodeSet *result;

  result = icu::UnicodeSet::clear(this);
  *((_BYTE *)result + 32) = 1;
  return result;
}

UChar *icu::UnicodeSet::setPattern(uint64_t a1, const UChar *a2, int32_t a3)
{
  void *v6;
  UChar *result;

  v6 = *(void **)(a1 + 64);
  if (v6)
  {
    uprv_free(v6);
    *(_QWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 72) = 0;
  }
  result = (UChar *)uprv_malloc(2 * (a3 + 1));
  *(_QWORD *)(a1 + 64) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 72) = a3;
    result = u_memcpy(result, a2, a3);
    *(_WORD *)(*(_QWORD *)(a1 + 64) + 2 * *(int *)(a1 + 72)) = 0;
  }
  return result;
}

void icu::UnicodeSet::~UnicodeSet(icu::UnicodeSet *this)
{
  char *v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;

  v2 = (char *)*((_QWORD *)this + 2);
  if (v2 != (char *)this + 96)
    uprv_free(v2);
  v3 = *((_QWORD *)this + 5);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (char *)*((_QWORD *)this + 6);
  if (v4 != (char *)this + 96)
    uprv_free(v4);
  v5 = *((_QWORD *)this + 10);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 11);
  if (v6)
  {
    v7 = (void *)sub_18BC5194C(v6);
    icu::UMemory::operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 8);
  if (v8)
  {
    uprv_free(v8);
    *((_QWORD *)this + 8) = 0;
    *((_DWORD *)this + 18) = 0;
  }
  icu::UnicodeFilter::~UnicodeFilter(this);
}

{
  void *v1;

  icu::UnicodeSet::~UnicodeSet(this);
  icu::UMemory::operator delete(v1);
}

void icu::UnicodeSet::releasePattern(icu::UnicodeSet *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 8);
  if (v2)
  {
    uprv_free(v2);
    *((_QWORD *)this + 8) = 0;
    *((_DWORD *)this + 18) = 0;
  }
}

void `non-virtual thunk to'icu::UnicodeSet::~UnicodeSet(icu::UnicodeSet *this)
{
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)((char *)this - 8));
}

{
  void *v1;

  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)((char *)this - 8));
  icu::UMemory::operator delete(v1);
}

icu::UnicodeSet *icu::UnicodeSet::copyFrom(icu::UnicodeSet *this, const icu::UnicodeSet *a2, int a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  icu::UVector *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const UChar *v15;
  UErrorCode v17;

  if (this == a2 || *((_QWORD *)this + 5) || *((_QWORD *)this + 11))
    return this;
  if ((*((_BYTE *)a2 + 32) & 1) != 0)
    goto LABEL_30;
  if (!icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)a2 + 7)))
    return this;
  v6 = *((int *)a2 + 7);
  *((_DWORD *)this + 7) = v6;
  memcpy(*((void **)this + 2), *((const void **)a2 + 2), 4 * v6);
  if (!a3 && *((_QWORD *)a2 + 5))
  {
    v8 = icu::UMemory::operator new((icu::UMemory *)0x368, v7);
    if (!v8)
    {
      *((_QWORD *)this + 5) = 0;
      goto LABEL_30;
    }
    sub_18BBAB684(v8, *((_QWORD *)a2 + 5), *((_QWORD *)this + 2), *((_DWORD *)this + 7));
    *((_QWORD *)this + 5) = v9;
  }
  v10 = *((_QWORD *)a2 + 10);
  if (v10 && *(_DWORD *)(v10 + 8))
  {
    v17 = U_ZERO_ERROR;
    v11 = (icu::UVector *)*((_QWORD *)this + 10);
    if (!v11)
    {
      if (!icu::UnicodeSet::allocateStrings(this, &v17))
        goto LABEL_30;
      v11 = (icu::UVector *)*((_QWORD *)this + 10);
      v10 = *((_QWORD *)a2 + 10);
    }
    icu::UVector::assign(v11, v10, (uint64_t (*)(uint64_t, uint64_t))sub_18BC4AB4C, &v17);
    if (v17 <= U_ZERO_ERROR)
      goto LABEL_20;
LABEL_30:
    icu::UnicodeSet::clear(this);
    *((_BYTE *)this + 32) = 1;
    return this;
  }
  v12 = *((_QWORD *)this + 10);
  if (v12 && *(_DWORD *)(v12 + 8))
    icu::UVector::removeAllElements(v12);
LABEL_20:
  if (a3 || !*((_QWORD *)a2 + 11))
    goto LABEL_24;
  v13 = icu::UMemory::operator new((icu::UMemory *)0x188, v10);
  if (!v13)
  {
    *((_QWORD *)this + 11) = 0;
    goto LABEL_30;
  }
  *((_QWORD *)this + 11) = sub_18BC518EC(v13, *((_QWORD *)a2 + 11), *((_QWORD *)this + 10));
LABEL_24:
  v14 = (void *)*((_QWORD *)this + 8);
  if (v14)
  {
    uprv_free(v14);
    *((_QWORD *)this + 8) = 0;
    *((_DWORD *)this + 18) = 0;
  }
  v15 = (const UChar *)*((_QWORD *)a2 + 8);
  if (v15)
    icu::UnicodeSet::setPattern((uint64_t)this, v15, *((_DWORD *)a2 + 18));
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::clone@<X0>(icu::UnicodeSet *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  icu::UnicodeSet *result;

  result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, a2);
  if (result)
  {
    *(_QWORD *)result = off_1E2256980;
    *((_QWORD *)result + 1) = &unk_1E2256A98;
    *((_QWORD *)result + 2) = (char *)result + 96;
    *((_QWORD *)result + 3) = 0x100000019;
    *((_BYTE *)result + 32) = 0;
    *((_QWORD *)result + 8) = 0;
    *((_DWORD *)result + 18) = 0;
    *((_QWORD *)result + 5) = 0;
    *((_QWORD *)result + 6) = 0;
    *((_DWORD *)result + 14) = 0;
    *((_QWORD *)result + 10) = 0;
    *((_QWORD *)result + 11) = 0;
    return icu::UnicodeSet::copyFrom(result, this, 0);
  }
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::cloneAsThawed@<X0>(icu::UnicodeSet *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  icu::UnicodeSet *result;

  result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, a2);
  if (result)
    return icu::UnicodeSet::UnicodeSet(result, this);
  return result;
}

BOOL icu::UnicodeSet::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int *v3;
  int *v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL8 result;

  v2 = *(unsigned int *)(a1 + 28);
  if ((_DWORD)v2 != *(_DWORD *)(a2 + 28))
    return 0;
  if ((int)v2 >= 1)
  {
    v3 = *(int **)(a1 + 16);
    v4 = *(int **)(a2 + 16);
    do
    {
      v6 = *v3++;
      v5 = v6;
      v7 = *v4++;
      if (v5 != v7)
        return 0;
    }
    while (--v2);
  }
  v8 = *(_QWORD *)(a1 + 80);
  if (!v8)
  {
    v11 = *(_QWORD *)(a2 + 80);
    return !v11 || !*(_DWORD *)(v11 + 8);
  }
  v9 = *(_DWORD *)(v8 + 8);
  v10 = *(_QWORD *)(a2 + 80);
  if (v10)
  {
    if ((v9 != 0) == (*(_DWORD *)(v10 + 8) != 0))
      goto LABEL_17;
    return 0;
  }
  if (v9)
    return 0;
  v10 = 0;
LABEL_17:
  if (!*(_DWORD *)(v8 + 8))
    return 1;
  result = icu::UVector::operator==(v8, v10);
  if (result)
    return 1;
  return result;
}

uint64_t icu::UnicodeSet::hashCode(icu::UnicodeSet *this)
{
  uint64_t result;
  int *v3;
  uint64_t v4;
  int v5;

  result = *((unsigned int *)this + 7);
  if ((int)result >= 1)
  {
    v3 = (int *)*((_QWORD *)this + 2);
    v4 = result;
    do
    {
      v5 = *v3++;
      result = (v5 + 1000003 * result);
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t icu::UnicodeSet::size(icu::UnicodeSet *this)
{
  unint64_t v1;
  int v2;
  unint64_t v3;
  _DWORD *v4;
  uint64_t v5;

  v1 = *((unsigned int *)this + 7);
  if ((int)v1 < 2)
  {
    v2 = 0;
  }
  else
  {
    v2 = 0;
    v3 = v1 >> 1;
    v4 = (_DWORD *)(*((_QWORD *)this + 2) + 4);
    do
    {
      v2 = *v4 + v2 - *(v4 - 1);
      v4 += 2;
      --v3;
    }
    while (v3);
  }
  v5 = *((_QWORD *)this + 10);
  if (v5)
    LODWORD(v5) = *(_DWORD *)(v5 + 8);
  return (v5 + v2);
}

uint64_t icu::UnicodeSet::getRangeCount(icu::UnicodeSet *this)
{
  return (*((_DWORD *)this + 7) / 2);
}

uint64_t icu::UnicodeSet::getRangeEnd(icu::UnicodeSet *this, int a2)
{
  return (*(_DWORD *)(*((_QWORD *)this + 2) + 4 * ((2 * a2) | 1)) - 1);
}

uint64_t icu::UnicodeSet::getRangeStart(icu::UnicodeSet *this, int a2)
{
  return *(unsigned int *)(*((_QWORD *)this + 2) + 8 * a2);
}

BOOL icu::UnicodeSet::isEmpty(icu::UnicodeSet *this)
{
  uint64_t v1;

  if (*((_DWORD *)this + 7) != 1)
    return 0;
  v1 = *((_QWORD *)this + 10);
  return !v1 || *(_DWORD *)(v1 + 8) == 0;
}

uint64_t icu::UnicodeSet::contains(icu::UnicodeSet *this, int a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *((_QWORD *)this + 5);
  if (v2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  while (1)
  {
    v4 = *((_QWORD *)this + 11);
    if (!v4)
      break;
    this = (icu::UnicodeSet *)(v4 + 8);
    v2 = *(_QWORD *)(v4 + 48);
    if (v2)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  }
  if (a2 < 1114112)
    return icu::UnicodeSet::findCodePoint(this, a2) & 1;
  else
    return 0;
}

uint64_t icu::UnicodeSet::findCodePoint(icu::UnicodeSet *this, int a2)
{
  _DWORD *v2;
  uint64_t result;
  int v4;
  unsigned int v6;
  unsigned int v7;

  v2 = (_DWORD *)*((_QWORD *)this + 2);
  if (*v2 > a2)
    return 0;
  v4 = *((_DWORD *)this + 7);
  result = (v4 - 1);
  if (v4 >= 2 && v2[v4 - 2] > a2 && v4 != 2)
  {
    v6 = 0;
    v7 = result >> 1;
    do
    {
      if (v2[v7] > a2)
      {
        result = v7;
      }
      else
      {
        v6 = v7;
        result = result;
      }
      v7 = (int)(result + v6) >> 1;
    }
    while (v7 != v6);
  }
  return result;
}

BOOL icu::UnicodeSet::contains(icu::UnicodeSet *this, int a2, int a3)
{
  int CodePoint;

  CodePoint = icu::UnicodeSet::findCodePoint(this, a2);
  return (CodePoint & 1) != 0 && *(_DWORD *)(*((_QWORD *)this + 2) + 4 * CodePoint) > a3;
}

icu::UVector *icu::UnicodeSet::contains(icu::UVector **this, const icu::UnicodeString *a2)
{
  int SingleCP;
  icu::UVector *result;

  SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
  if ((SingleCP & 0x80000000) == 0)
    return (icu::UVector *)icu::UnicodeSet::contains((icu::UnicodeSet *)this, SingleCP);
  result = this[10];
  if (result)
    return (icu::UVector *)((int)icu::UVector::indexOf(result, (uint64_t)a2, 0) >= 0);
  return result;
}

uint64_t icu::UnicodeSet::getSingleCP(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned __int16 *v4;
  uint64_t result;

  v2 = *((unsigned __int16 *)this + 4);
  if ((v2 & 0x8000u) == 0)
    v3 = v2 >> 5;
  else
    v3 = *((_DWORD *)this + 3);
  if (v3 == 2)
  {
    result = icu::UnicodeString::char32At(this, 0);
    if ((int)result >= 0x10000)
      return result;
    return 0xFFFFFFFFLL;
  }
  if (v3 != 1)
    return 0xFFFFFFFFLL;
  if ((v2 & 2) != 0)
    v4 = (unsigned __int16 *)((char *)this + 10);
  else
    v4 = (unsigned __int16 *)*((_QWORD *)this + 3);
  return *v4;
}

uint64_t icu::UnicodeSet::containsAll(icu::UnicodeSet *this, const icu::UnicodeSet *a2)
{
  unint64_t v4;
  unint64_t v5;
  _DWORD *v6;
  int CodePoint;
  const icu::UVector *v8;
  uint64_t result;

  v4 = *((unsigned int *)a2 + 7);
  if ((int)v4 < 2)
  {
LABEL_6:
    v8 = (const icu::UVector *)*((_QWORD *)a2 + 10);
    if (v8 && *((_DWORD *)v8 + 2))
    {
      result = *((_QWORD *)this + 10);
      if (result)
        return icu::UVector::containsAll((icu::UVector *)result, v8);
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v5 = v4 >> 1;
    v6 = (_DWORD *)(*((_QWORD *)a2 + 2) + 4);
    while (1)
    {
      CodePoint = icu::UnicodeSet::findCodePoint(this, *(v6 - 1));
      if ((CodePoint & 1) == 0 || *(_DWORD *)(*((_QWORD *)this + 2) + 4 * CodePoint) < *v6)
        return 0;
      v6 += 2;
      if (!--v5)
        goto LABEL_6;
    }
  }
  return result;
}

BOOL icu::UnicodeSet::containsAll(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v3;
  UChar *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;

  v3 = *((unsigned __int16 *)a2 + 4);
  if ((v3 & 0x11) != 0)
  {
    v4 = 0;
  }
  else if ((v3 & 2) != 0)
  {
    v4 = (UChar *)((char *)a2 + 10);
  }
  else
  {
    v4 = (UChar *)*((_QWORD *)a2 + 3);
  }
  v5 = (__int16)v3;
  v6 = v3 >> 5;
  if (v5 >= 0)
    v7 = v6;
  else
    v7 = *((unsigned int *)a2 + 3);
  v8 = icu::UnicodeSet::span(this, v4, v7, 1);
  v9 = *((unsigned __int16 *)a2 + 4);
  v10 = (__int16)v9;
  v11 = v9 >> 5;
  if (v10 < 0)
    v11 = *((_DWORD *)a2 + 3);
  return v8 == v11;
}

unint64_t icu::UnicodeSet::span(icu::UnicodeSet *this, UChar *s, uint64_t a3, int a4)
{
  uint64_t v5;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v18;
  BOOL v19;
  int v20;
  _OWORD v21[15];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;

  v5 = a3;
  v32 = *MEMORY[0x1E0C80C00];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0)
      return 0;
    v5 = u_strlen(s);
    if (!(_DWORD)v5)
      return 0;
  }
  else
  {
    v8 = (unsigned int *)*((_QWORD *)this + 5);
    if (v8)
      return (unint64_t)((char *)sub_18BBAB998(v8, s, (unint64_t)&s[a3], a4) - (char *)s) >> 1;
  }
  v11 = *((_QWORD *)this + 11);
  if (!v11)
  {
    v12 = *((_QWORD *)this + 10);
    if (v12 && *(_DWORD *)(v12 + 8))
    {
      v31 = 0;
      if (a4)
        v13 = 42;
      else
        v13 = 41;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      v22 = 0u;
      memset(v21, 0, sizeof(v21));
      sub_18BC517FC(v21, this, v12, v13);
      if (HIDWORD(v22))
      {
        v9 = sub_18BC51950((uint64_t)v21, s, v5, a4);
        sub_18BC5194C(v21);
        return v9;
      }
      sub_18BC5194C(v21);
    }
    v9 = 0;
    v14 = a4 != 0;
    do
    {
      v15 = (int)v9 + 1;
      v16 = s[(int)v9];
      if ((v16 & 0xFC00) == 0xD800 && (_DWORD)v15 != (_DWORD)v5)
      {
        v18 = s[v15];
        v19 = (v18 & 0xFC00) == 56320;
        v20 = v18 + (v16 << 10) - 56613888;
        if (v19)
          v16 = v20;
        if (v19)
          v15 = (v9 + 2);
        else
          v15 = v15;
      }
      if (v14 != icu::UnicodeSet::contains(this, v16))
        break;
      v9 = v15;
    }
    while ((int)v15 < (int)v5);
    return v9;
  }
  return sub_18BC51950(v11, s, v5, a4);
}

BOOL icu::UnicodeSet::containsNone(icu::UnicodeSet *this, int a2, int a3)
{
  int CodePoint;

  CodePoint = icu::UnicodeSet::findCodePoint(this, a2);
  return (CodePoint & 1) == 0 && *(_DWORD *)(*((_QWORD *)this + 2) + 4 * CodePoint) > a3;
}

BOOL icu::UnicodeSet::containsNone(icu::UnicodeSet *this, const icu::UnicodeSet *a2)
{
  unint64_t v4;
  unint64_t v5;
  _DWORD *v6;
  int CodePoint;
  icu::UVector *v8;
  const icu::UVector *v9;

  v4 = *((unsigned int *)a2 + 7);
  if ((int)v4 < 2)
  {
LABEL_6:
    v8 = (icu::UVector *)*((_QWORD *)this + 10);
    return !v8
        || (v9 = (const icu::UVector *)*((_QWORD *)a2 + 10)) == 0
        || !*((_DWORD *)v9 + 2)
        || icu::UVector::containsNone(v8, v9) != 0;
  }
  else
  {
    v5 = v4 >> 1;
    v6 = (_DWORD *)(*((_QWORD *)a2 + 2) + 4);
    while (1)
    {
      CodePoint = icu::UnicodeSet::findCodePoint(this, *(v6 - 1));
      if ((CodePoint & 1) != 0 || *(_DWORD *)(*((_QWORD *)this + 2) + 4 * CodePoint) < *v6)
        return 0;
      v6 += 2;
      if (!--v5)
        goto LABEL_6;
    }
  }
}

BOOL icu::UnicodeSet::containsNone(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v3;
  UChar *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;

  v3 = *((unsigned __int16 *)a2 + 4);
  if ((v3 & 0x11) != 0)
  {
    v4 = 0;
  }
  else if ((v3 & 2) != 0)
  {
    v4 = (UChar *)((char *)a2 + 10);
  }
  else
  {
    v4 = (UChar *)*((_QWORD *)a2 + 3);
  }
  v5 = (__int16)v3;
  v6 = v3 >> 5;
  if (v5 >= 0)
    v7 = v6;
  else
    v7 = *((unsigned int *)a2 + 3);
  v8 = icu::UnicodeSet::span(this, v4, v7, 0);
  v9 = *((unsigned __int16 *)a2 + 4);
  v10 = (__int16)v9;
  v11 = v9 >> 5;
  if (v10 < 0)
    v11 = *((_DWORD *)a2 + 3);
  return v8 == v11;
}

uint64_t icu::UnicodeSet::matchesIndexValue(icu::UnicodeSet *this, unsigned int a2)
{
  unint64_t v4;
  unint64_t v5;
  _BYTE *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t result;
  signed int v12;
  unsigned __int16 *v13;
  uint64_t *v14;

  v4 = *((unsigned int *)this + 7);
  if ((int)v4 >= 2)
  {
    v5 = v4 >> 1;
    v6 = (_BYTE *)(*((_QWORD *)this + 2) + 4);
    do
    {
      v7 = *((_DWORD *)v6 - 1);
      v8 = (*v6 - 1);
      if (((*(_DWORD *)v6 - 1) ^ *((_DWORD *)v6 - 1)) > 0xFF)
      {
        if (v7 <= a2 || v8 >= a2)
          return 1;
      }
      else if (v7 <= a2 && v8 >= a2)
      {
        return 1;
      }
      v6 += 8;
      --v5;
    }
    while (v5);
  }
  result = *((_QWORD *)this + 10);
  if (result)
  {
    if (*(int *)(result + 8) < 1)
    {
      return 0;
    }
    else
    {
      v12 = 0;
      while (1)
      {
        v13 = (unsigned __int16 *)icu::UVector::elementAt((icu::UVector *)result, v12);
        v14 = (uint64_t *)v13[4];
        if (v14 >= 0x20
          && a2 == icu::UnicodeString::char32At(v14, (icu::UnicodeString *)v13, 0))
        {
          break;
        }
        ++v12;
        result = *((_QWORD *)this + 10);
        if (v12 >= *(_DWORD *)(result + 8))
          return 0;
      }
      return 1;
    }
  }
  return result;
}

uint64_t `non-virtual thunk to'icu::UnicodeSet::matchesIndexValue(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::matchesIndexValue((icu::UnicodeSet *)((char *)this - 8), a2);
}

uint64_t icu::UnicodeSet::matches(int **this, const icu::Replaceable *a2, int *a3, int a4, int a5)
{
  int v7;
  int v8;
  unsigned int v9;
  int *v14;
  unsigned int v15;
  int *v16;
  uint64_t v17;
  signed int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  unsigned int v26;
  int matched;
  int v28;
  int v29;
  uint64_t v30;

  v7 = *a3;
  if (*a3 == a4)
  {
    v8 = icu::UnicodeSet::contains((icu::UnicodeSet *)this, 0xFFFF);
    if (a5)
      v9 = 1;
    else
      v9 = 2;
    if (v8)
      return v9;
    else
      return 0;
  }
  v14 = this[10];
  if (!v14)
    return icu::UnicodeFilter::matches((uint64_t)this, (uint64_t)a2, a3, a4, a5);
  if (!v14[2])
    return icu::UnicodeFilter::matches((uint64_t)this, (uint64_t)a2, a3, a4, a5);
  v15 = (*(uint64_t (**)(const icu::Replaceable *, _QWORD))(*(_QWORD *)a2 + 72))(a2, *a3);
  v16 = this[10];
  if (v16[2] < 1)
    return icu::UnicodeFilter::matches((uint64_t)this, (uint64_t)a2, a3, a4, a5);
  v17 = 0;
  v18 = 0;
  while (1)
  {
    v19 = icu::UVector::elementAt((icu::UVector *)v16, v18);
    v20 = *(unsigned __int16 *)(v19 + 8);
    if (v20 < 0x20)
    {
LABEL_44:
      v30 = v17;
      goto LABEL_45;
    }
    v21 = v19;
    if (v7 >= a4)
    {
      if ((v20 & 0x8000) != 0)
        v24 = *(_DWORD *)(v19 + 12);
      else
        v24 = v20 >> 5;
      v22 = v24 - 1;
      if ((v20 & 0x8000) == 0)
      {
LABEL_15:
        v23 = v20 >> 5;
        goto LABEL_21;
      }
    }
    else
    {
      v22 = 0;
      if ((v20 & 0x8000) == 0)
        goto LABEL_15;
    }
    v23 = *(_DWORD *)(v19 + 12);
LABEL_21:
    if (v23 <= v22)
    {
      v26 = 0xFFFF;
    }
    else
    {
      v25 = (v20 & 2) != 0 ? v19 + 10 : *(_QWORD *)(v19 + 24);
      v26 = *(unsigned __int16 *)(v25 + 2 * (int)v22);
    }
    if (v7 < a4 && v26 > v15)
      break;
    if (v26 != v15)
      goto LABEL_44;
    matched = icu::UnicodeSet::matchRest((uint64_t)a2, *a3, a4, v19);
    if (a5)
    {
      v28 = *a3 - a4;
      if (v7 < a4)
        v28 = a4 - *a3;
      if (matched == v28)
        return 1;
    }
    v29 = *(__int16 *)(v21 + 8) < 0 ? *(_DWORD *)(v21 + 12) : *(unsigned __int16 *)(v21 + 8) >> 5;
    if (matched != v29)
      goto LABEL_44;
    if (matched <= (int)v17)
      v30 = v17;
    else
      v30 = matched;
    if (v7 < a4 && matched < (int)v17)
    {
LABEL_46:
      if (!(_DWORD)v30)
        return icu::UnicodeFilter::matches((uint64_t)this, (uint64_t)a2, a3, a4, a5);
      goto LABEL_47;
    }
LABEL_45:
    ++v18;
    v16 = this[10];
    v17 = v30;
    if (v18 >= v16[2])
      goto LABEL_46;
  }
  LODWORD(v30) = v17;
  if (!(_DWORD)v17)
    return icu::UnicodeFilter::matches((uint64_t)this, (uint64_t)a2, a3, a4, a5);
LABEL_47:
  if (v7 >= a4)
    LODWORD(v30) = -(int)v30;
  *a3 += v30;
  return 2;
}

uint64_t icu::UnicodeSet::matchRest(uint64_t a1, int a2, int a3, uint64_t a4)
{
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v12;
  int v13;
  unsigned int v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  int v25;

  v6 = *(unsigned __int16 *)(a4 + 8);
  v7 = (__int16)v6;
  v8 = v6 >> 5;
  if (v7 < 0)
    v8 = *(_DWORD *)(a4 + 12);
  v9 = a2 - a3;
  if (a2 >= a3)
  {
    if ((int)v9 >= (int)v8)
      v10 = v8;
    else
      v10 = v9;
    if ((int)v10 >= 2)
    {
      v18 = v8 - 2;
      v19 = (a2 - 1);
      v20 = v10 - 1;
      while (1)
      {
        v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, v19);
        v22 = *(unsigned __int16 *)(a4 + 8);
        v23 = (v22 & 0x8000u) == 0 ? v22 >> 5 : *(_DWORD *)(a4 + 12);
        if (v23 <= v18)
        {
          v25 = 0xFFFF;
        }
        else
        {
          v24 = (v22 & 2) != 0 ? a4 + 10 : *(_QWORD *)(a4 + 24);
          v25 = *(unsigned __int16 *)(v24 + 2 * (int)v18);
        }
        if (v21 != v25)
          break;
        --v18;
        v19 = (v19 - 1);
        if (!--v20)
          return v10;
      }
      return 0;
    }
  }
  else
  {
    if (a3 - a2 >= (int)v8)
      v10 = v8;
    else
      v10 = (a3 - a2);
    if ((int)v10 >= 2)
    {
      v12 = 1;
      while (1)
      {
        v13 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 72))(a1, (a2 + v12));
        v14 = *(unsigned __int16 *)(a4 + 8);
        v15 = (v14 & 0x8000u) == 0 ? v14 >> 5 : *(unsigned int *)(a4 + 12);
        if (v12 >= v15)
        {
          v17 = 0xFFFF;
        }
        else
        {
          v16 = (v14 & 2) != 0 ? a4 + 10 : *(_QWORD *)(a4 + 24);
          v17 = *(unsigned __int16 *)(v16 + 2 * v12);
        }
        if (v13 != v17)
          break;
        if (v10 == ++v12)
          return v10;
      }
      return 0;
    }
  }
  return v10;
}

uint64_t `non-virtual thunk to'icu::UnicodeSet::matches(int **this, const icu::Replaceable *a2, int *a3, int a4, int a5)
{
  return icu::UnicodeSet::matches(this - 1, a2, a3, a4, a5);
}

icu::UnicodeSet *icu::UnicodeSet::addMatchSetTo(icu::UnicodeSet *this, icu::UVector **a2)
{
  return icu::UnicodeSet::addAll(a2, this);
}

icu::UnicodeSet *icu::UnicodeSet::addAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  int v4;
  int *v5;
  icu::UVector *v6;
  signed int v7;
  UChar **v8;
  icu::UVector *v9;

  v4 = *((_DWORD *)a2 + 7);
  if (v4 >= 1)
  {
    v5 = (int *)*((_QWORD *)a2 + 2);
    if (v5)
      icu::UnicodeSet::add((icu::UnicodeSet *)this, v5, v4, 0);
  }
  v6 = (icu::UVector *)*((_QWORD *)a2 + 10);
  if (v6 && *((int *)v6 + 2) >= 1)
  {
    v7 = 0;
    do
    {
      v8 = (UChar **)icu::UVector::elementAt(v6, v7);
      v9 = this[10];
      if (!v9 || (icu::UVector::indexOf(v9, (uint64_t)v8, 0) & 0x80000000) != 0)
        icu::UnicodeSet::_add((icu::UnicodeSet *)this, v8);
      ++v7;
      v6 = (icu::UVector *)*((_QWORD *)a2 + 10);
    }
    while (v7 < *((_DWORD *)v6 + 2));
  }
  return (icu::UnicodeSet *)this;
}

icu::UnicodeSet *`non-virtual thunk to'icu::UnicodeSet::addMatchSetTo(icu::UnicodeSet *this, icu::UVector **a2)
{
  return icu::UnicodeSet::addAll(a2, (icu::UnicodeSet *)((char *)this - 8));
}

uint64_t icu::UnicodeSet::indexOf(icu::UnicodeSet *this, unsigned int a2)
{
  int v3;
  int *i;
  int v5;
  int v6;
  int v7;

  if (HIWORD(a2) <= 0x10u)
  {
    v3 = 0;
    for (i = (int *)(*((_QWORD *)this + 2) + 4); ; i += 2)
    {
      v5 = *(i - 1);
      if (v5 > (int)a2)
        break;
      v6 = v3;
      v7 = *i;
      v3 = v3 - v5 + v7;
      if (v7 > (int)a2)
        return v6 + a2 - v5;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t icu::UnicodeSet::charAt(icu::UnicodeSet *this, int a2)
{
  int64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  BOOL v6;

  if ((a2 & 0x80000000) == 0)
  {
    v2 = 0;
    while (v2 < (uint64_t)(*((int *)this + 7) & 0xFFFFFFFFFFFFFFFELL))
    {
      v3 = a2;
      v4 = *((_QWORD *)this + 2) + 4 * v2;
      v2 += 2;
      v5 = *(_DWORD *)v4;
      LODWORD(v4) = *(_DWORD *)(v4 + 4) - *(_DWORD *)v4;
      v6 = __OFSUB__(a2, (_DWORD)v4);
      a2 -= v4;
      if (a2 < 0 != v6)
        return (v5 + v3);
    }
  }
  return 0xFFFFFFFFLL;
}

icu::UnicodeSet *icu::UnicodeSet::set(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  icu::UnicodeSet *v5;

  v5 = icu::UnicodeSet::clear(this);
  return icu::UnicodeSet::complement(v5, a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::clear(icu::UnicodeSet *this)
{
  void *v2;
  uint64_t v3;

  if (!*((_QWORD *)this + 5) && !*((_QWORD *)this + 11))
  {
    **((_DWORD **)this + 2) = 1114112;
    *((_DWORD *)this + 7) = 1;
    v2 = (void *)*((_QWORD *)this + 8);
    if (v2)
    {
      uprv_free(v2);
      *((_QWORD *)this + 8) = 0;
      *((_DWORD *)this + 18) = 0;
    }
    v3 = *((_QWORD *)this + 10);
    if (v3)
      icu::UVector::removeAllElements(v3);
    *((_BYTE *)this + 32) = 0;
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  int v4;
  int v5;
  void *v6;
  int v8[3];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 5) || *((_QWORD *)this + 11) || (*((_BYTE *)this + 32) & 1) != 0)
    return this;
  v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    v5 = 0;
    goto LABEL_8;
  }
  v5 = 1114111;
  if (a2 > 0x10FFFF)
LABEL_8:
    a2 = v5;
  if ((a3 & 0x80000000) != 0)
  {
    v4 = 0;
  }
  else if (a3 <= 0x10FFFF)
  {
    goto LABEL_14;
  }
  a3 = v4;
LABEL_14:
  if (a2 <= a3)
  {
    v8[0] = a2;
    v8[1] = a3 + 1;
    v8[2] = 1114112;
    icu::UnicodeSet::exclusiveOr(this, v8, 2, 0);
  }
  v6 = (void *)*((_QWORD *)this + 8);
  if (v6)
  {
    uprv_free(v6);
    *((_QWORD *)this + 8) = 0;
    *((_DWORD *)this + 18) = 0;
  }
  return this;
}

void icu::UnicodeSet::add(icu::UnicodeSet *this, int *a2, int a3, char a4)
{
  int v8;
  int *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  void *v26;
  int v27;
  uint8_t buf[4];
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 5)
    || *((_QWORD *)this + 11)
    || !a2
    || (*((_BYTE *)this + 32) & 1) != 0
    || !icu::UnicodeSet::ensureBufferCapacity(this, *((_DWORD *)this + 7) + a3))
  {
    return;
  }
  v27 = a3;
  v8 = 0;
  v9 = (int *)*((_QWORD *)this + 2);
  v10 = *v9;
  v11 = *a2;
  v12 = 1;
  v13 = 1;
  while (2)
  {
    switch(a4)
    {
      case 0:
        if (v10 >= v11)
        {
          if (v11 >= v10)
          {
            if (v10 == 1114112)
              goto LABEL_55;
            v22 = *((_QWORD *)this + 6);
            v23 = v8 - 1;
            if (v8 >= 1 && (v24 = *(_DWORD *)(v22 + 4 * v23), v10 <= v24))
            {
              if (v9[v12] <= v24)
                v10 = *(_DWORD *)(v22 + 4 * v23);
              else
                v10 = v9[v12];
            }
            else
            {
              v23 = v8 + 1;
              *(_DWORD *)(v22 + 4 * v8) = v10;
              v10 = v9[v12];
            }
            ++v12;
            v11 = a2[v13++];
            a4 = 3;
            v8 = v23;
          }
          else
          {
            v19 = *((_QWORD *)this + 6);
            v20 = v8 - 1;
            if (v8 >= 1 && (v21 = *(_DWORD *)(v19 + 4 * v20), v11 <= v21))
            {
              if (a2[v13] <= v21)
                v11 = *(_DWORD *)(v19 + 4 * v20);
              else
                v11 = a2[v13];
            }
            else
            {
              v20 = v8 + 1;
              *(_DWORD *)(v19 + 4 * v8) = v11;
              v11 = a2[v13];
            }
            ++v13;
            a4 = 2;
            v8 = v20;
          }
        }
        else
        {
          v14 = *((_QWORD *)this + 6);
          v15 = v8 - 1;
          if (v8 >= 1 && (v16 = *(_DWORD *)(v14 + 4 * v15), v10 <= v16))
          {
            if (v9[v12] <= v16)
              v10 = *(_DWORD *)(v14 + 4 * v15);
            else
              v10 = v9[v12];
          }
          else
          {
            v15 = v8 + 1;
            *(_DWORD *)(v14 + 4 * v8) = v10;
            v10 = v9[v12];
          }
          ++v12;
          a4 = 1;
          v8 = v15;
        }
        continue;
      case 1:
        if (v10 >= v11)
        {
          if (v11 >= v10)
          {
            if (v10 == 1114112)
              goto LABEL_55;
            v10 = v9[v12++];
            v11 = a2[v13++];
            a4 = 2;
          }
          else
          {
            v11 = a2[v13++];
            a4 = 3;
          }
        }
        else
        {
          v17 = *((_DWORD *)this + 14);
          if ((v8 >= v17 || v12 >= *((_DWORD *)this + 6))
            && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            v18 = *((_DWORD *)this + 6);
            *(_DWORD *)buf = 67110912;
            v29 = v8;
            v30 = 1024;
            v31 = v17;
            v32 = 1024;
            v33 = v12;
            v34 = 1024;
            v35 = v18;
            v36 = 1024;
            v37 = v13;
            v38 = 1024;
            v39 = v27;
            v40 = 1024;
            v41 = v10;
            v42 = 1024;
            v43 = v11;
            _os_log_impl(&dword_18BBAA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "# UnicodeSet::add case 1, k %d bufCap %d i %d cap %d j %d otherLen %d a %04X b %04X", buf, 0x32u);
            v9 = (int *)*((_QWORD *)this + 2);
          }
          a4 = 0;
          *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v8++) = v10;
          v10 = v9[v12++];
        }
        continue;
      case 2:
        if (v11 < v10)
        {
          a4 = 0;
          *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v8++) = v11;
LABEL_34:
          v11 = a2[v13++];
          continue;
        }
        if (v10 < v11)
        {
          v10 = v9[v12++];
          a4 = 3;
          continue;
        }
        if (v10 != 1114112)
        {
          v10 = v9[v12++];
          v11 = a2[v13++];
          a4 = 1;
          continue;
        }
LABEL_55:
        v25 = *((_QWORD *)this + 6);
        *(_DWORD *)(v25 + 4 * v8) = 1114112;
        *((_QWORD *)this + 2) = v25;
        *((_QWORD *)this + 6) = v9;
        LODWORD(v25) = *((_DWORD *)this + 6);
        *((_DWORD *)this + 6) = *((_DWORD *)this + 14);
        *((_DWORD *)this + 7) = v8 + 1;
        *((_DWORD *)this + 14) = v25;
        v26 = (void *)*((_QWORD *)this + 8);
        if (v26)
        {
          uprv_free(v26);
          *((_QWORD *)this + 8) = 0;
          *((_DWORD *)this + 18) = 0;
        }
        return;
      case 3:
        if (v11 <= v10)
        {
          if (v10 == 1114112)
            goto LABEL_55;
        }
        else
        {
          v10 = v11;
          if (v11 == 1114112)
            goto LABEL_55;
        }
        a4 = 0;
        *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v8++) = v10;
        v10 = v9[v12++];
        goto LABEL_34;
      default:
        continue;
    }
  }
}

icu::UnicodeSet *icu::UnicodeSet::add(icu::UnicodeSet *this, unsigned int a2)
{
  int v3;
  int CodePoint;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  int *v14;
  void *v15;

  if ((a2 & 0x80000000) != 0)
  {
    v3 = 0;
  }
  else
  {
    v3 = a2;
    if (a2 >= 0x110000)
      v3 = 1114111;
  }
  CodePoint = icu::UnicodeSet::findCodePoint(this, v3);
  if ((CodePoint & 1) == 0 && !*((_QWORD *)this + 5) && !*((_QWORD *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    v5 = CodePoint;
    v6 = *((_QWORD *)this + 2);
    v7 = CodePoint;
    if (v3 == *(_DWORD *)(v6 + 4 * CodePoint) - 1)
    {
      *(_DWORD *)(v6 + 4 * CodePoint) = v3;
      if (v3 == 1114111)
      {
        if (!icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)this + 7) + 1))
          return this;
        v6 = *((_QWORD *)this + 2);
        v8 = *((int *)this + 7);
        *((_DWORD *)this + 7) = v8 + 1;
        *(_DWORD *)(v6 + 4 * v8) = 1114112;
      }
      if (v5 < 1 || v3 != *(_DWORD *)(v6 + 4 * (v5 - 1)))
        goto LABEL_26;
      v9 = v6 + 4 * v7;
      v10 = *((_DWORD *)this + 7);
      if (v9 + 4 < (unint64_t)(v6 + 4 * v10))
      {
        v11 = v6 + 4 * v10;
        if (v9 + 8 > v11)
          v11 = v9 + 8;
        memmove((void *)(v9 - 4), (const void *)(v9 + 4), ((v11 - v9 - 5) & 0xFFFFFFFFFFFFFFFCLL) + 4);
        v10 = *((_DWORD *)this + 7);
      }
      v12 = v10 - 2;
    }
    else
    {
      v13 = (CodePoint - 1);
      if (CodePoint >= 1 && v3 == *(_DWORD *)(v6 + 4 * v13))
      {
        *(_DWORD *)(v6 + 4 * v13) = v3 + 1;
        goto LABEL_26;
      }
      if (!icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)this + 7) + 2))
        return this;
      memmove((void *)(*((_QWORD *)this + 2) + 4 * v7 + 8), (const void *)(*((_QWORD *)this + 2) + 4 * v7), 4 * (*((_DWORD *)this + 7) - v5));
      v14 = (int *)(*((_QWORD *)this + 2) + 4 * v7);
      *v14 = v3;
      v14[1] = v3 + 1;
      v12 = *((_DWORD *)this + 7) + 2;
    }
    *((_DWORD *)this + 7) = v12;
LABEL_26:
    v15 = (void *)*((_QWORD *)this + 8);
    if (v15)
    {
      uprv_free(v15);
      *((_QWORD *)this + 8) = 0;
      *((_DWORD *)this + 18) = 0;
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::add(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int SingleCP;
  icu::UVector *v6;
  void *v7;

  if (!*((_QWORD *)this + 5) && !*((_QWORD *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      v6 = (icu::UVector *)*((_QWORD *)this + 10);
      if (!v6 || (icu::UVector::indexOf(v6, (uint64_t)a2, 0) & 0x80000000) != 0)
      {
        icu::UnicodeSet::_add(this, (UChar **)a2);
        v7 = (void *)*((_QWORD *)this + 8);
        if (v7)
        {
          uprv_free(v7);
          *((_QWORD *)this + 8) = 0;
          *((_DWORD *)this + 18) = 0;
        }
      }
    }
    else
    {
      icu::UnicodeSet::add(this, SingleCP);
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::_add(icu::UnicodeSet *this, UChar **a2)
{
  icu::UnicodeSet *v2;
  icu::UnicodeString *v4;
  icu::UnicodeString *v5;
  UErrorCode v6;

  if (!*((_QWORD *)this + 5))
  {
    v2 = this;
    if (!*((_QWORD *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
    {
      if ((v6 = U_ZERO_ERROR, !*((_QWORD *)this + 10)) && !icu::UnicodeSet::allocateStrings(this, &v6)
        || (v4 = (icu::UnicodeString *)icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2)) == 0
        || (v5 = v4,
            icu::UnicodeString::UnicodeString(v4, a2),
            this = (icu::UnicodeSet *)icu::UVector::sortedInsert(*((_QWORD *)v2 + 10), v5, sub_18BC4C548, &v6),
            v6 >= U_ILLEGAL_ARGUMENT_ERROR))
      {
        this = icu::UnicodeSet::clear(v2);
        *((_BYTE *)v2 + 32) = 1;
      }
    }
  }
  return this;
}

uint64_t sub_18BC4C548(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  int32_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;

  v2 = *(unsigned __int16 *)(a1 + 8);
  if (*(__int16 *)(a1 + 8) < 0)
    v3 = *(_DWORD *)(a1 + 12);
  else
    v3 = v2 >> 5;
  v4 = *(unsigned __int16 *)(a2 + 8);
  if ((v4 & 1) != 0)
    return (v2 & 1) == 0;
  if ((v4 & 0x8000u) == 0)
    v5 = v4 >> 5;
  else
    v5 = *(_DWORD *)(a2 + 12);
  if ((v4 & 2) != 0)
    v6 = a2 + 10;
  else
    v6 = *(_QWORD *)(a2 + 24);
  return icu::UnicodeString::doCompare(a1, 0, v3, v6, v5 & (v5 >> 31), v5 & ~(v5 >> 31));
}

icu::UnicodeSet *icu::UnicodeSet::addAll(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v3;
  int v4;
  unint64_t v5;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;

  v3 = *((unsigned __int16 *)a2 + 4);
  v4 = (__int16)v3;
  LODWORD(v5) = v3 >> 5;
  if (v4 >= 0)
    v5 = v5;
  else
    v5 = *((unsigned int *)a2 + 3);
  if ((int)v5 >= 1)
  {
    v7 = 0;
    do
    {
      v8 = icu::UnicodeString::char32At((uint64_t *)v5, a2, v7);
      icu::UnicodeSet::add(this, v8);
      if (v8 < 0x10000)
        v9 = 1;
      else
        v9 = 2;
      v7 += v9;
      v10 = *((unsigned __int16 *)a2 + 4);
      v11 = (__int16)v10;
      LODWORD(v5) = v10 >> 5;
      if (v11 >= 0)
        v5 = v5;
      else
        v5 = *((unsigned int *)a2 + 3);
    }
    while (v7 < (int)v5);
  }
  return this;
}

icu::UVector **icu::UnicodeSet::retainAll(icu::UVector **this, const icu::UnicodeString *a2)
{
  _QWORD v4[4];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  _OWORD v9[6];
  uint64_t v10;

  v5 = 0u;
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  v4[0] = off_1E2256980;
  v4[1] = &unk_1E2256A98;
  v4[2] = v9;
  v4[3] = 0x100000019;
  v6 = 0uLL;
  v8 = 0uLL;
  v7 = 0uLL;
  LODWORD(v9[0]) = 1114112;
  icu::UnicodeSet::addAll((icu::UnicodeSet *)v4, a2);
  icu::UnicodeSet::retainAll(this, (const icu::UnicodeSet *)v4);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v4);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::retainAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  icu::UVector *v4;
  const icu::UVector *v5;

  if (!this[5] && !this[11] && ((_BYTE)this[4] & 1) == 0)
  {
    icu::UnicodeSet::retain((icu::UnicodeSet *)this, *((int **)a2 + 2), *((_DWORD *)a2 + 7), 0);
    v4 = this[10];
    if (v4)
    {
      if (*((_DWORD *)v4 + 2))
      {
        v5 = (const icu::UVector *)*((_QWORD *)a2 + 10);
        if (v5 && *((_DWORD *)v5 + 2))
          icu::UVector::retainAll(v4, v5);
        else
          icu::UVector::removeAllElements((uint64_t)v4);
      }
    }
  }
  return (icu::UnicodeSet *)this;
}

icu::UVector **icu::UnicodeSet::complementAll(icu::UVector **this, const icu::UnicodeString *a2)
{
  _QWORD v4[4];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  _OWORD v9[6];
  uint64_t v10;

  v5 = 0u;
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  v4[0] = off_1E2256980;
  v4[1] = &unk_1E2256A98;
  v4[2] = v9;
  v4[3] = 0x100000019;
  v6 = 0uLL;
  v8 = 0uLL;
  v7 = 0uLL;
  LODWORD(v9[0]) = 1114112;
  icu::UnicodeSet::addAll((icu::UnicodeSet *)v4, a2);
  icu::UnicodeSet::complementAll(this, (const icu::UnicodeSet *)v4);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v4);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::complementAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  icu::UVector *v4;
  signed int v5;
  UChar **v6;
  icu::UVector *v7;

  if (!this[5] && !this[11] && ((_BYTE)this[4] & 1) == 0)
  {
    icu::UnicodeSet::exclusiveOr((icu::UnicodeSet *)this, *((int **)a2 + 2), *((_DWORD *)a2 + 7), 0);
    v4 = (icu::UVector *)*((_QWORD *)a2 + 10);
    if (v4)
    {
      if (*((int *)v4 + 2) >= 1)
      {
        v5 = 0;
        do
        {
          v6 = (UChar **)icu::UVector::elementAt(v4, v5);
          v7 = this[10];
          if (!v7 || !icu::UVector::removeElement(v7, (uint64_t)v6))
            icu::UnicodeSet::_add((icu::UnicodeSet *)this, v6);
          ++v5;
          v4 = (icu::UVector *)*((_QWORD *)a2 + 10);
        }
        while (v5 < *((_DWORD *)v4 + 2));
      }
    }
  }
  return (icu::UnicodeSet *)this;
}

icu::UVector **icu::UnicodeSet::removeAll(icu::UVector **this, const icu::UnicodeString *a2)
{
  _QWORD v4[4];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  _OWORD v9[6];
  uint64_t v10;

  v5 = 0u;
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  v4[0] = off_1E2256980;
  v4[1] = &unk_1E2256A98;
  v4[2] = v9;
  v4[3] = 0x100000019;
  v6 = 0uLL;
  v8 = 0uLL;
  v7 = 0uLL;
  LODWORD(v9[0]) = 1114112;
  icu::UnicodeSet::addAll((icu::UnicodeSet *)v4, a2);
  icu::UnicodeSet::removeAll(this, (const icu::UnicodeSet *)v4);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v4);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::removeAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  icu::UVector *v4;
  const icu::UVector *v5;

  if (!this[5] && !this[11] && ((_BYTE)this[4] & 1) == 0)
  {
    icu::UnicodeSet::retain((icu::UnicodeSet *)this, *((int **)a2 + 2), *((_DWORD *)a2 + 7), 2);
    v4 = this[10];
    if (v4)
    {
      if (*((_DWORD *)v4 + 2))
      {
        v5 = (const icu::UVector *)*((_QWORD *)a2 + 10);
        if (v5)
        {
          if (*((_DWORD *)v5 + 2))
            icu::UVector::removeAll(v4, v5);
        }
      }
    }
  }
  return (icu::UnicodeSet *)this;
}

icu::UnicodeSet *icu::UnicodeSet::removeAllStrings(icu::UnicodeSet *this)
{
  uint64_t v3;
  void *v4;

  if (!*((_QWORD *)this + 5) && !*((_QWORD *)this + 11))
  {
    v3 = *((_QWORD *)this + 10);
    if (v3)
    {
      if (*(_DWORD *)(v3 + 8))
      {
        icu::UVector::removeAllElements(v3);
        v4 = (void *)*((_QWORD *)this + 8);
        if (v4)
        {
          uprv_free(v4);
          *((_QWORD *)this + 8) = 0;
          *((_DWORD *)this + 18) = 0;
        }
      }
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::createFrom@<X0>(icu::UnicodeSet *this@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t *a3@<X8>)
{
  icu::UnicodeSet *result;

  result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, (unint64_t)a2);
  if (result)
  {
    *(_QWORD *)result = off_1E2256980;
    *((_QWORD *)result + 1) = &unk_1E2256A98;
    *((_DWORD *)result + 24) = 1114112;
    *((_QWORD *)result + 2) = (char *)result + 96;
    *((_QWORD *)result + 3) = 0x100000019;
    *((_BYTE *)result + 32) = 0;
    *((_QWORD *)result + 8) = 0;
    *((_DWORD *)result + 18) = 0;
    *((_QWORD *)result + 5) = 0;
    *((_QWORD *)result + 6) = 0;
    *((_DWORD *)result + 14) = 0;
    *((_QWORD *)result + 10) = 0;
    *((_QWORD *)result + 11) = 0;
    return icu::UnicodeSet::add(result, this);
  }
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::createFromAll@<X0>(icu::UnicodeSet *this@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t *a3@<X8>)
{
  icu::UnicodeSet *result;

  result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, (unint64_t)a2);
  if (result)
  {
    *(_QWORD *)result = off_1E2256980;
    *((_QWORD *)result + 1) = &unk_1E2256A98;
    *((_DWORD *)result + 24) = 1114112;
    *((_QWORD *)result + 2) = (char *)result + 96;
    *((_QWORD *)result + 3) = 0x100000019;
    *((_BYTE *)result + 32) = 0;
    *((_QWORD *)result + 8) = 0;
    *((_DWORD *)result + 18) = 0;
    *((_QWORD *)result + 5) = 0;
    *((_QWORD *)result + 6) = 0;
    *((_DWORD *)result + 14) = 0;
    *((_QWORD *)result + 10) = 0;
    *((_QWORD *)result + 11) = 0;
    return icu::UnicodeSet::addAll(result, this);
  }
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::retain(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  int v4;
  int v5;
  int v7[3];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    v5 = 0;
  }
  else
  {
    v5 = 1114111;
    if (a2 <= 0x10FFFF)
    {
      if ((a3 & 0x80000000) == 0)
        goto LABEL_4;
LABEL_8:
      v4 = 0;
      goto LABEL_9;
    }
  }
  a2 = v5;
  if ((a3 & 0x80000000) != 0)
    goto LABEL_8;
LABEL_4:
  if (a3 > 0x10FFFF)
LABEL_9:
    a3 = v4;
  if (a2 <= a3)
  {
    v7[0] = a2;
    v7[1] = a3 + 1;
    v7[2] = 1114112;
    icu::UnicodeSet::retain(this, v7, 2, 0);
  }
  else
  {
    icu::UnicodeSet::clear(this);
  }
  return this;
}

void icu::UnicodeSet::retain(icu::UnicodeSet *this, int *a2, int a3, char a4)
{
  int v7;
  int *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  void *v15;

  if (!*((_QWORD *)this + 5)
    && !*((_QWORD *)this + 11)
    && (*((_BYTE *)this + 32) & 1) == 0
    && icu::UnicodeSet::ensureBufferCapacity(this, *((_DWORD *)this + 7) + a3))
  {
    v7 = 0;
    v8 = (int *)*((_QWORD *)this + 2);
    v9 = *v8;
    v10 = *a2;
    v11 = 1;
    v12 = 1;
    while (1)
    {
      switch(a4)
      {
        case 0:
          if (v9 < v10)
          {
            v9 = v8[v11++];
            a4 = 1;
            continue;
          }
          if (v10 < v9)
            goto LABEL_27;
          if (v9 == 1114112)
            goto LABEL_34;
          *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v7++) = v9;
          v9 = v8[v11];
          v10 = a2[v12];
          ++v11;
          goto LABEL_20;
        case 1:
          if (v9 >= v10)
          {
            if (v10 >= v9)
            {
              if (v9 == 1114112)
                goto LABEL_34;
              v9 = v8[v11++];
LABEL_27:
              v10 = a2[v12++];
              a4 = 2;
            }
            else
            {
              *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v7++) = v10;
              v10 = a2[v12];
LABEL_20:
              ++v12;
              a4 = 3;
            }
          }
          else
          {
            a4 = 0;
            v9 = v8[v11++];
          }
          continue;
        case 2:
          if (v10 < v9)
          {
            a4 = 0;
            goto LABEL_33;
          }
          if (v9 < v10)
          {
            *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v7++) = v9;
            v9 = v8[v11++];
            a4 = 3;
            continue;
          }
          if (v9 == 1114112)
            goto LABEL_34;
          v9 = v8[v11++];
          goto LABEL_30;
        case 3:
          if (v9 >= v10)
          {
            if (v10 >= v9)
            {
              if (v9 == 1114112)
              {
LABEL_34:
                v13 = *((_QWORD *)this + 6);
                *(_DWORD *)(v13 + 4 * v7) = 1114112;
                *((_QWORD *)this + 2) = v13;
                *((_QWORD *)this + 6) = v8;
                v14 = *((_DWORD *)this + 6);
                *((_DWORD *)this + 6) = *((_DWORD *)this + 14);
                *((_DWORD *)this + 7) = v7 + 1;
                *((_DWORD *)this + 14) = v14;
                v15 = (void *)*((_QWORD *)this + 8);
                if (v15)
                {
                  uprv_free(v15);
                  *((_QWORD *)this + 8) = 0;
                  *((_DWORD *)this + 18) = 0;
                }
                return;
              }
              a4 = 0;
              *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v7++) = v9;
              v9 = v8[v11++];
LABEL_33:
              v10 = a2[v12++];
            }
            else
            {
              *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v7++) = v10;
LABEL_30:
              v10 = a2[v12++];
              a4 = 1;
            }
          }
          else
          {
            *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v7++) = v9;
            v9 = v8[v11++];
            a4 = 2;
          }
          break;
        default:
          continue;
      }
    }
  }
}

icu::UnicodeSet *icu::UnicodeSet::retain(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::retain(this, a2, a2);
}

icu::UnicodeSet *icu::UnicodeSet::retain(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int SingleCP;
  icu::UVector *v5;
  icu::UnicodeSet *v6;

  if (!*((_QWORD *)this + 5) && !*((_QWORD *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      v5 = (icu::UVector *)*((_QWORD *)this + 10);
      if (!v5 || (icu::UVector::indexOf(v5, (uint64_t)a2, 0) & 0x80000000) != 0)
      {
        icu::UnicodeSet::clear(this);
      }
      else if ((*((_DWORD *)this + 7) + 1) > 2 || icu::UnicodeSet::size(this) != 1)
      {
        v6 = icu::UnicodeSet::clear(this);
        icu::UnicodeSet::_add(v6, (UChar **)a2);
      }
    }
    else
    {
      icu::UnicodeSet::retain(this, SingleCP, SingleCP);
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::remove(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  int v4;
  int v5;
  int v7[3];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    v5 = 0;
  }
  else
  {
    v5 = 1114111;
    if (a2 <= 0x10FFFF)
    {
      if ((a3 & 0x80000000) == 0)
        goto LABEL_4;
LABEL_8:
      v4 = 0;
      goto LABEL_9;
    }
  }
  a2 = v5;
  if ((a3 & 0x80000000) != 0)
    goto LABEL_8;
LABEL_4:
  if (a3 > 0x10FFFF)
LABEL_9:
    a3 = v4;
  if (a2 <= a3)
  {
    v7[0] = a2;
    v7[1] = a3 + 1;
    v7[2] = 1114112;
    icu::UnicodeSet::retain(this, v7, 2, 2);
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::remove(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::remove(this, a2, a2);
}

icu::UnicodeSet *icu::UnicodeSet::remove(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int SingleCP;
  icu::UVector *v6;
  void *v7;

  if (!*((_QWORD *)this + 5) && !*((_QWORD *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      v6 = (icu::UVector *)*((_QWORD *)this + 10);
      if (v6)
      {
        if (icu::UVector::removeElement(v6, (uint64_t)a2))
        {
          v7 = (void *)*((_QWORD *)this + 8);
          if (v7)
          {
            uprv_free(v7);
            *((_QWORD *)this + 8) = 0;
            *((_DWORD *)this + 18) = 0;
          }
        }
      }
    }
    else
    {
      icu::UnicodeSet::remove(this, SingleCP, SingleCP);
    }
  }
  return this;
}

void icu::UnicodeSet::exclusiveOr(icu::UnicodeSet *this, int *a2, int a3, unsigned __int8 a4)
{
  int *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  const int *i;
  uint64_t v15;
  int v16;
  void *v17;

  if (*((_QWORD *)this + 5)
    || *((_QWORD *)this + 11)
    || (*((_BYTE *)this + 32) & 1) != 0
    || !icu::UnicodeSet::ensureBufferCapacity(this, *((_DWORD *)this + 7) + a3))
  {
    return;
  }
  v7 = (int *)*((_QWORD *)this + 2);
  v8 = *v7;
  v9 = *a2;
  if (a4 - 1 > 1)
    goto LABEL_9;
  if (!v9)
  {
    v9 = a2[1];
LABEL_9:
    v10 = 1;
    goto LABEL_10;
  }
  v10 = 0;
  v9 = 0;
LABEL_10:
  v11 = 0;
  v12 = 1;
LABEL_11:
  v13 = 0;
  for (i = &a2[v10]; ; v9 = i[v13++])
  {
    if (v8 < v9)
    {
      *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v11 + 4 * v13) = v8;
      v10 += v13;
      v11 += v13 + 1;
LABEL_18:
      v8 = v7[v12++];
      goto LABEL_11;
    }
    if (v9 >= v8)
      break;
    *(_DWORD *)(*((_QWORD *)this + 6) + 4 * v11 + 4 * v13) = v9;
  }
  if (v8 != 1114112)
  {
    v11 += v13;
    v10 += v13 + 1;
    v9 = i[v13];
    goto LABEL_18;
  }
  v15 = *((_QWORD *)this + 6);
  *(_DWORD *)(v15 + 4 * v11 + 4 * v13) = 1114112;
  *((_QWORD *)this + 2) = v15;
  *((_QWORD *)this + 6) = v7;
  v16 = *((_DWORD *)this + 6);
  *((_DWORD *)this + 6) = *((_DWORD *)this + 14);
  *((_DWORD *)this + 7) = v11 + v13 + 1;
  *((_DWORD *)this + 14) = v16;
  v17 = (void *)*((_QWORD *)this + 8);
  if (v17)
  {
    uprv_free(v17);
    *((_QWORD *)this + 8) = 0;
    *((_DWORD *)this + 18) = 0;
  }
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::complement(this, a2, a2);
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this)
{
  _DWORD *v2;
  int v3;
  void *v4;

  if (!*((_QWORD *)this + 5) && !*((_QWORD *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    v2 = (_DWORD *)*((_QWORD *)this + 2);
    if (*v2)
    {
      if (!icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)this + 7) + 1))
        return this;
      memmove((void *)(*((_QWORD *)this + 2) + 4), *((const void **)this + 2), 4 * *((int *)this + 7));
      **((_DWORD **)this + 2) = 0;
      v3 = 1;
    }
    else
    {
      memmove(v2, v2 + 1, 4 * *((int *)this + 7) - 4);
      v3 = -1;
    }
    *((_DWORD *)this + 7) += v3;
    v4 = (void *)*((_QWORD *)this + 8);
    if (v4)
    {
      uprv_free(v4);
      *((_QWORD *)this + 8) = 0;
      *((_DWORD *)this + 18) = 0;
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int SingleCP;
  icu::UVector *v5;
  void *v6;

  if (!*((_QWORD *)this + 5) && !*((_QWORD *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      v5 = (icu::UVector *)*((_QWORD *)this + 10);
      if (!v5 || (icu::UVector::indexOf(v5, (uint64_t)a2, 0) & 0x80000000) != 0)
        icu::UnicodeSet::_add(this, (UChar **)a2);
      else
        icu::UVector::removeElement(*((icu::UVector **)this + 10), (uint64_t)a2);
      v6 = (void *)*((_QWORD *)this + 8);
      if (v6)
      {
        uprv_free(v6);
        *((_QWORD *)this + 8) = 0;
        *((_DWORD *)this + 18) = 0;
      }
    }
    else
    {
      icu::UnicodeSet::complement(this, SingleCP, SingleCP);
    }
  }
  return this;
}

uint64_t icu::UnicodeSet::getString(icu::UVector **this, unsigned int a2)
{
  return icu::UVector::elementAt(this[10], a2);
}

icu::UnicodeSet *icu::UnicodeSet::compact(icu::UnicodeSet *this)
{
  char *v2;
  char *v3;
  char *v4;
  uint64_t v5;
  int v6;
  void *v7;
  _DWORD *v8;

  if (*((_QWORD *)this + 5) || *((_QWORD *)this + 11) || (*((_BYTE *)this + 32) & 1) != 0)
    return this;
  v2 = (char *)*((_QWORD *)this + 6);
  v3 = (char *)this + 96;
  if (v2 != (char *)this + 96)
  {
    uprv_free(v2);
    *((_QWORD *)this + 6) = 0;
    *((_DWORD *)this + 14) = 0;
  }
  v4 = (char *)*((_QWORD *)this + 2);
  if (v4 != v3)
  {
    v5 = *((int *)this + 7);
    if ((int)v5 <= 25)
    {
      memcpy((char *)this + 96, *((const void **)this + 2), 4 * v5);
      uprv_free(v4);
      *((_QWORD *)this + 2) = v3;
      v6 = 25;
LABEL_12:
      *((_DWORD *)this + 6) = v6;
      goto LABEL_13;
    }
    if ((int)v5 + 7 < *((_DWORD *)this + 6))
    {
      v7 = uprv_realloc(*((void **)this + 2), 4 * *((unsigned int *)this + 7));
      if (v7)
      {
        *((_QWORD *)this + 2) = v7;
        v6 = *((_DWORD *)this + 7);
        goto LABEL_12;
      }
    }
  }
LABEL_13:
  v8 = (_DWORD *)*((_QWORD *)this + 10);
  if (v8 && !v8[2])
  {
    (*(void (**)(_DWORD *))(*(_QWORD *)v8 + 8))(v8);
    *((_QWORD *)this + 10) = 0;
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, unsigned __int16 *a2, int a3, int a4, int *a5)
{
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  __int16 *v17;
  int v18;
  __int16 *v19;
  int v20;
  int v21;

  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  if (*a5 < 1)
  {
    if (a3 < 1 || !a2 || a4)
    {
      *a5 = 1;
      icu::UnicodeSet::clear(this);
      *((_BYTE *)this + 32) = 1;
    }
    else
    {
      v7 = (__int16)*a2;
      if (v7 >= 0)
        v8 = 1;
      else
        v8 = 2;
      LODWORD(v9) = *a2;
      if (v7 < 0)
        LODWORD(v9) = a2[1];
      v10 = *a2 & 0x7FFF;
      v11 = v10 - v9;
      if (v10 >= (int)v9)
        v12 = v10 - v9;
      else
        v12 = v11 + 1;
      v13 = v9 + (v12 >> 1);
      if (icu::UnicodeSet::ensureCapacity(this, v13 + 1))
      {
        v14 = *((_QWORD *)this + 2);
        if ((_DWORD)v9)
        {
          v15 = v9;
          v16 = (_DWORD *)*((_QWORD *)this + 2);
          v17 = (__int16 *)&a2[v8];
          do
          {
            v18 = (unsigned __int16)*v17++;
            *v16++ = v18;
            --v15;
          }
          while (v15);
        }
        if (v11 >= 2)
        {
          v9 = v9;
          v19 = (__int16 *)&a2[v8 + 1 + v9];
          do
          {
            v20 = (unsigned __int16)*(v19 - 1);
            v21 = (unsigned __int16)*v19;
            v19 += 2;
            *(_DWORD *)(v14 + 4 * v9++) = v21 | (v20 << 16);
          }
          while (v9 < v13);
        }
        if (!(_DWORD)v9 || *(_DWORD *)(v14 + 4 * ((int)v9 - 1)) != 1114112)
        {
          *(_DWORD *)(v14 + 4 * v9) = 1114112;
          LODWORD(v9) = v9 + 1;
        }
        *((_DWORD *)this + 7) = v9;
      }
    }
  }
  else
  {
    icu::UnicodeSet::clear(this);
    *((_BYTE *)this + 32) = 1;
  }
  return this;
}

uint64_t icu::UnicodeSet::serialize(icu::UnicodeSet *this, unsigned __int16 *a2, int a3, UErrorCode *a4)
{
  uint64_t result;
  UErrorCode v5;
  int v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  int v11;
  unsigned __int16 *v12;
  int v13;
  int v14;
  int v15;
  unint64_t v16;

  if (*(int *)a4 > 0)
    return 0;
  if (a3 < 0 || !a2 && a3)
  {
    result = 0;
    v5 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_7:
    *a4 = v5;
    return result;
  }
  v6 = *((_DWORD *)this + 7);
  v7 = (v6 - 1);
  if (v6 == 1)
  {
    if (a3)
      *a2 = 0;
    else
      *a4 = U_BUFFER_OVERFLOW_ERROR;
    return 1;
  }
  else
  {
    v8 = (int *)*((_QWORD *)this + 2);
    if (v8[v6 - 2] >= 0x10000)
    {
      if (*v8 < 0x10000)
      {
        if (v6 < 2)
        {
          LODWORD(v10) = 0;
        }
        else
        {
          v10 = 0;
          while (v8[v10] < 0x10000)
          {
            if (v7 == ++v10)
            {
              LODWORD(v10) = v6 - 1;
              break;
            }
          }
        }
        v9 = v10 + 2 * (v7 - v10);
        LODWORD(v7) = v10;
      }
      else
      {
        v9 = 2 * v7;
        LODWORD(v7) = 0;
      }
    }
    else
    {
      v9 = v6 - 1;
    }
    if (v9 >= 0x8000)
    {
      result = 0;
      v5 = U_INDEX_OUTOFBOUNDS_ERROR;
      goto LABEL_7;
    }
    if (v9 <= (int)v7)
      v11 = 1;
    else
      v11 = 2;
    result = (v11 + v9);
    if ((int)result > a3)
    {
      v5 = U_BUFFER_OVERFLOW_ERROR;
      goto LABEL_7;
    }
    *a2 = v9;
    if (v9 > (int)v7)
    {
      *a2 = v9 | 0x8000;
      a2[1] = v7;
      ++a2;
    }
    v12 = a2 + 1;
    if ((int)v7 < 1)
    {
      LODWORD(v7) = 0;
    }
    else
    {
      v13 = v7;
      do
      {
        v14 = *v8++;
        *v12++ = v14;
        --v13;
      }
      while (v13);
    }
    while ((int)v7 < v9)
    {
      v15 = *v8++;
      HIDWORD(v16) = v15;
      LODWORD(v16) = v15;
      *(_DWORD *)v12 = v16 >> 16;
      v12 += 2;
      LODWORD(v7) = v7 + 2;
    }
  }
  return result;
}

uint64_t icu::UnicodeSet::nextCapacity(icu::UnicodeSet *this)
{
  if ((int)this <= 24)
    return ((_DWORD)this + 25);
  if (this <= 0x9C4)
    return (5 * (_DWORD)this);
  if ((2 * (_DWORD)this) > 0x110000)
    return 1114113;
  return (2 * (_DWORD)this);
}

uint64_t icu::UnicodeSet::ensureBufferCapacity(icu::UnicodeSet *this, int a2)
{
  int v2;
  int v4;
  int v5;
  void *v6;
  void *v7;
  char *v8;
  uint64_t result;

  if (a2 > 1114112)
    v2 = 1114113;
  else
    v2 = a2;
  if (v2 <= *((_DWORD *)this + 14))
    return 1;
  if ((2 * v2) > 0x110000)
    v4 = 1114113;
  else
    v4 = 2 * v2;
  if (v2 <= 0x9C4)
    v4 = 5 * v2;
  if (v2 <= 24)
    v5 = v2 + 25;
  else
    v5 = v4;
  v6 = uprv_malloc(4 * v5);
  if (v6)
  {
    v7 = v6;
    v8 = (char *)*((_QWORD *)this + 6);
    if (v8 != (char *)this + 96)
      uprv_free(v8);
    *((_QWORD *)this + 6) = v7;
    *((_DWORD *)this + 14) = v5;
    return 1;
  }
  icu::UnicodeSet::clear(this);
  result = 0;
  *((_BYTE *)this + 32) = 1;
  return result;
}

uint64_t icu::UnicodeSet::swapBuffers(uint64_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)(this + 16);
  *(_QWORD *)(this + 16) = *(_QWORD *)(this + 48);
  *(_QWORD *)(this + 48) = v1;
  LODWORD(v1) = *(_DWORD *)(this + 24);
  *(_DWORD *)(this + 24) = *(_DWORD *)(this + 56);
  *(_DWORD *)(this + 56) = v1;
  return this;
}

icu::ICU_Utility *icu::UnicodeSet::_appendToPat(icu::ICU_Utility *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  unsigned int v3;
  int v4;
  int v5;
  int v6;
  icu::UnicodeSet *v8;
  int v9;
  icu::UnicodeString *v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;

  v3 = *((unsigned __int16 *)a2 + 4);
  v4 = (__int16)v3;
  v5 = v3 >> 5;
  if (v4 < 0)
    v5 = *((_DWORD *)a2 + 3);
  if (v5 >= 1)
  {
    v6 = (int)a3;
    v8 = this;
    v9 = 0;
    do
    {
      v10 = (icu::UnicodeString *)icu::UnicodeString::char32At(a2, v9);
      v11 = v10;
      this = icu::UnicodeSet::_appendToPat(v8, v10, v6);
      if (v11 < 0x10000)
        v12 = 1;
      else
        v12 = 2;
      v9 += v12;
      v13 = *((unsigned __int16 *)a2 + 4);
      v14 = (__int16)v13;
      v15 = v13 >> 5;
      if (v14 < 0)
        v15 = *((_DWORD *)a2 + 3);
    }
    while (v9 < v15);
  }
  return this;
}

icu::ICU_Utility *icu::UnicodeSet::_appendToPat(icu::UnicodeSet *this, icu::UnicodeString *a2, int a3)
{
  __int16 *v6;
  __int16 v7;
  __int16 v8;

  if (a3)
  {
    if (icu::ICU_Utility::isUnprintable(a2))
      return icu::ICU_Utility::escape(this, a2);
  }
  else if (icu::ICU_Utility::shouldAlwaysBeEscaped(a2))
  {
    return icu::ICU_Utility::escape(this, a2);
  }
  if (((_DWORD)a2 - 36) <= 0x3A && ((1 << (a2 - 36)) & 0x780000000400205) != 0
    || (_DWORD)a2 == 125
    || (_DWORD)a2 == 123)
  {
    v7 = 92;
    v6 = &v7;
  }
  else
  {
    if (!icu::PatternProps::isWhiteSpace(a2))
      return (icu::ICU_Utility *)icu::UnicodeString::append((uint64_t)this, a2);
    v8 = 92;
    v6 = &v8;
  }
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)v6, 0, 1);
  return (icu::ICU_Utility *)icu::UnicodeString::append((uint64_t)this, a2);
}

icu::ICU_Utility *icu::UnicodeSet::_appendToPat(icu::UnicodeSet *this, icu::UnicodeString *a2, icu::UnicodeString *a3, int a4)
{
  int v6;
  icu::ICU_Utility *result;
  __int16 v9;

  v6 = (int)a2;
  result = icu::UnicodeSet::_appendToPat(this, a2, a4);
  if (v6 != (_DWORD)a3)
  {
    if (v6 == 56319 || v6 + 1 != (_DWORD)a3)
    {
      v9 = 45;
      icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v9, 0, 1);
    }
    return icu::UnicodeSet::_appendToPat(this, a3, a4);
  }
  return result;
}

icu::UnicodeString *icu::UnicodeSet::_toPattern(icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  int v3;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v13;
  BOOL v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;

  v3 = (int)a3;
  if (!*((_QWORD *)this + 8))
    return (icu::UnicodeString *)icu::UnicodeSet::_generatePattern(this, a2, a3);
  v6 = *((_DWORD *)this + 18);
  if (v6 >= 1)
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = *((_QWORD *)this + 8);
      v10 = v8 + 1;
      v11 = *(unsigned __int16 *)(v9 + 2 * v8);
      if ((v11 & 0xFC00) != 0xD800 || (_DWORD)v10 == v6)
      {
        ++v8;
      }
      else
      {
        v13 = *(unsigned __int16 *)(v9 + 2 * v10);
        v14 = (v13 & 0xFC00) == 56320;
        v15 = v13 + ((_DWORD)v11 << 10) - 56613888;
        if (v14)
          v8 += 2;
        else
          ++v8;
        if (v14)
          v11 = v15;
        else
          v11 = v11;
      }
      if (v3)
      {
        if (icu::ICU_Utility::isUnprintable((icu::ICU_Utility *)v11))
          goto LABEL_18;
      }
      else if (icu::ICU_Utility::shouldAlwaysBeEscaped((icu::ICU_Utility *)v11))
      {
LABEL_18:
        if ((v7 & 0x80000001) == 1)
        {
          v16 = *((unsigned __int16 *)a2 + 4);
          if (*((__int16 *)a2 + 4) < 0)
            v17 = *((_DWORD *)a2 + 3);
          else
            v17 = v16 >> 5;
          v18 = v17 - 1;
          if ((v16 & 1) != 0 && v17 == 1)
          {
            icu::UnicodeString::unBogus((uint64_t)a2);
          }
          else if (v17 > v18)
          {
            if (v18 > 1023)
            {
              *((_WORD *)a2 + 4) = v16 | 0xFFE0;
              *((_DWORD *)a2 + 3) = v18;
            }
            else
            {
              *((_WORD *)a2 + 4) = *((_WORD *)a2 + 4) & 0x1F | (32 * v18);
            }
          }
        }
        icu::ICU_Utility::escape(a2, (icu::UnicodeString *)v11);
        v7 = 0;
        goto LABEL_34;
      }
      icu::UnicodeString::append((uint64_t)a2, v11);
      if ((_DWORD)v11 == 92)
        ++v7;
      else
        v7 = 0;
LABEL_34:
      v6 = *((_DWORD *)this + 18);
    }
    while (v8 < v6);
  }
  return a2;
}

uint64_t icu::UnicodeSet::_generatePattern(icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  int v6;
  signed int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  icu::UnicodeString *v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  signed int v25;
  icu::UnicodeString *v26;
  uint64_t v28;
  signed int v29;
  __int16 v30;
  __int16 v31;
  __int16 v32;
  __int16 v33;
  __int16 v34;

  v30 = 91;
  icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v30, 0, 1);
  v6 = *((_DWORD *)this + 7);
  v7 = v6 & 0xFFFFFFFE;
  if (v6 >= 4 && (v7 == v6 ? (v8 = **((_DWORD **)this + 2) == 0) : (v8 = 0), v8))
  {
    v28 = *((_QWORD *)this + 10);
    if (v28 && *(_DWORD *)(v28 + 8))
    {
      LODWORD(v9) = 0;
      v7 = *((_DWORD *)this + 7);
    }
    else
    {
      v31 = 94;
      LODWORD(v9) = 1;
      icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v31, 0, 1);
      v7 = v6 - 1;
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if ((int)v9 < v7)
  {
    v10 = v7;
    v29 = v7;
    do
    {
      v11 = *((_QWORD *)this + 2);
      v12 = (int)v9;
      v13 = *(_DWORD *)(v11 + 4 * (int)v9 + 4);
      if ((v13 - 55297) > 0x3FF)
      {
        icu::UnicodeSet::_appendToPat(a2, (icu::UnicodeString *)*(unsigned int *)(v11 + 4 * (int)v9), (icu::UnicodeString *)(v13 - 1), (int)a3);
        v7 = v29;
        LODWORD(v9) = v9 + 2;
      }
      else
      {
        v14 = (int)v9 + 2;
        v15 = (uint64_t)(int)v9 << 32;
        v16 = (int)v9 + 2;
        do
        {
          v17 = v14;
          v18 = v15;
          if (v16 >= v10)
            break;
          v19 = *(_DWORD *)(v11 + 4 * v16);
          v14 += 2;
          v15 += 0x200000000;
          v16 += 2;
        }
        while (v19 < 56320);
        LODWORD(v9) = v17;
        if (v7 > (int)v17)
        {
          v9 = v17;
          do
          {
            v20 = *((_QWORD *)this + 2);
            v21 = (icu::UnicodeString *)*(unsigned int *)(v20 + 4 * v9);
            if ((int)v21 >= 57344)
              break;
            icu::UnicodeSet::_appendToPat(a2, v21, (icu::UnicodeString *)(*(_DWORD *)(v20 + 4 * v9 + 4) - 1), (int)a3);
            v9 += 2;
          }
          while (v9 < v10);
          v7 = v29;
        }
        if ((int)v12 < (int)v17)
        {
          v22 = v18 >> 32;
          do
          {
            icu::UnicodeSet::_appendToPat(a2, (icu::UnicodeString *)*(unsigned int *)(*((_QWORD *)this + 2) + 4 * v12), (icu::UnicodeString *)(*(_DWORD *)(*((_QWORD *)this + 2) + 4 * v12 + 4) - 1), (int)a3);
            v23 = v12 < v22;
            v12 += 2;
          }
          while (v23);
          v7 = v29;
        }
      }
    }
    while ((int)v9 < v7);
  }
  v24 = *((_QWORD *)this + 10);
  if (v24 && *(int *)(v24 + 8) >= 1)
  {
    v25 = 0;
    do
    {
      v32 = 123;
      icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v32, 0, 1);
      v26 = (icu::UnicodeString *)icu::UVector::elementAt(*((icu::UVector **)this + 10), v25);
      icu::UnicodeSet::_appendToPat(a2, v26, a3);
      v33 = 125;
      icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v33, 0, 1);
      ++v25;
    }
    while (v25 < *(_DWORD *)(*((_QWORD *)this + 10) + 8));
  }
  v34 = 93;
  return icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v34, 0, 1);
}

icu::UnicodeString *icu::UnicodeSet::toPattern(icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  unsigned int v6;
  unsigned int v7;

  v6 = *((unsigned __int16 *)a2 + 4);
  if ((v6 & 1) != 0)
  {
    icu::UnicodeString::unBogus((uint64_t)a2);
  }
  else
  {
    if ((v6 & 0x8000u) == 0)
      v7 = v6 >> 5;
    else
      v7 = *((_DWORD *)a2 + 3);
    if (v7)
      *((_WORD *)a2 + 4) &= 0x1Fu;
  }
  return icu::UnicodeSet::_toPattern(this, a2, a3);
}

icu::UnicodeString *`non-virtual thunk to'icu::UnicodeSet::toPattern(icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  return icu::UnicodeSet::toPattern((icu::UnicodeSet *)((char *)this - 8), a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::freeze(icu::UnicodeSet *this)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;

  if (!*((_QWORD *)this + 5) && !*((_QWORD *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    icu::UnicodeSet::compact(this);
    v3 = *((_QWORD *)this + 10);
    if (v3 && *(_DWORD *)(v3 + 8))
    {
      v4 = icu::UMemory::operator new((icu::UMemory *)0x188, v2);
      if (!v4)
      {
        *((_QWORD *)this + 11) = 0;
        goto LABEL_14;
      }
      v5 = sub_18BC517FC(v4, this, *((_QWORD *)this + 10), 63);
      *((_QWORD *)this + 11) = v5;
      if (!*(_DWORD *)(v5 + 252))
      {
        v6 = (void *)sub_18BC5194C();
        icu::UMemory::operator delete(v6);
        *((_QWORD *)this + 11) = 0;
LABEL_10:
        v7 = icu::UMemory::operator new((icu::UMemory *)0x368, v2);
        if (v7)
        {
          *((_QWORD *)this + 5) = sub_18BBAB680(v7, *((_QWORD *)this + 2), *((_DWORD *)this + 7));
          return this;
        }
        *((_QWORD *)this + 5) = 0;
LABEL_14:
        icu::UnicodeSet::clear(this);
        *((_BYTE *)this + 32) = 1;
      }
    }
    else if (!*((_QWORD *)this + 11))
    {
      goto LABEL_10;
    }
  }
  return this;
}

unint64_t icu::UnicodeSet::spanBack(icu::UnicodeSet *this, UChar *s, uint64_t a3, int a4)
{
  uint64_t v5;
  unsigned int *v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  _OWORD v19[15];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;

  v5 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0)
      return 0;
    v5 = u_strlen(s);
    if (!(_DWORD)v5)
      return v5;
  }
  else
  {
    v8 = (unsigned int *)*((_QWORD *)this + 5);
    if (v8)
      return (unint64_t)(sub_18BBABBEC(v8, (uint64_t)s, (uint64_t)&s[a3], a4) - (_QWORD)s) >> 1;
  }
  v10 = *((_QWORD *)this + 11);
  if (!v10)
  {
    v11 = *((_QWORD *)this + 10);
    if (v11 && *(_DWORD *)(v11 + 8))
    {
      v29 = 0;
      if (a4)
        v12 = 26;
      else
        v12 = 25;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      memset(v19, 0, sizeof(v19));
      sub_18BC517FC(v19, this, v11, v12);
      if (HIDWORD(v20))
      {
        v5 = sub_18BC5221C((uint64_t)v19, s, v5, a4);
        sub_18BC5194C(v19);
        return v5;
      }
      sub_18BC5194C(v19);
    }
    v13 = a4 != 0;
    do
    {
      v14 = (v5 - 1);
      v15 = s[(int)v14];
      if ((int)v5 > 1 && (v15 & 0xFC00) == 0xDC00)
      {
        v16 = s[(v5 - 2)];
        v17 = v16 & 0xFC00;
        v18 = v15 + (v16 << 10) - 56613888;
        if (v17 == 55296)
          v14 = (v5 - 2);
        else
          v14 = v14;
        if (v17 == 55296)
          v15 = v18;
      }
      if (v13 != icu::UnicodeSet::contains(this, v15))
        break;
      v5 = v14;
    }
    while ((int)v14 >= 1);
    return v5;
  }
  return sub_18BC5221C(v10, s, v5, a4);
}

uint64_t icu::UnicodeSet::spanUTF8(icu::UnicodeSet *this, char *__s, size_t a3, int a4)
{
  size_t v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  _OWORD v24[16];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;

  v5 = a3;
  v34 = *MEMORY[0x1E0C80C00];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0)
      return 0;
    v5 = strlen(__s);
    if (!(_DWORD)v5)
      return 0;
  }
  else
  {
    v8 = *((_QWORD *)this + 5);
    if (v8)
      return sub_18BBABE3C(v8, __s, a3, a4) - __s;
  }
  v11 = *((_QWORD *)this + 11);
  if (!v11)
  {
    v12 = *((_QWORD *)this + 10);
    if (v12 && *(_DWORD *)(v12 + 8))
    {
      v33 = 0;
      if (a4)
        v13 = 38;
      else
        v13 = 37;
      v31 = 0u;
      v32 = 0u;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      memset(v24, 0, sizeof(v24));
      sub_18BC517FC(v24, this, v12, v13);
      if ((_DWORD)v25)
      {
        v9 = sub_18BC52A60((uint64_t)v24, __s, v5, a4);
        sub_18BC5194C(v24);
        return v9;
      }
      sub_18BC5194C(v24);
    }
    v9 = 0;
    v14 = a4 != 0;
    while (1)
    {
      v15 = (int)v9 + 1;
      v16 = __s[(int)v9];
      v17 = __s[(int)v9];
      if ((v16 & 0x80000000) == 0)
        goto LABEL_42;
      if ((_DWORD)v15 == (_DWORD)v5)
        goto LABEL_21;
      if (v17 < 0xE0)
        break;
      if (v17 <= 0xEF)
      {
        v18 = v16 & 0xF;
        if (((a00000000000000[v18] >> (__s[v15] >> 5)) & 1) != 0)
        {
          v19 = __s[v15] & 0x3F;
          goto LABEL_26;
        }
        goto LABEL_41;
      }
      if (v17 > 0xF4)
        goto LABEL_41;
      v23 = __s[v15];
      if (((byte_18BE15218[v23 >> 4] >> (v17 + 16)) & 1) == 0)
        goto LABEL_41;
      v15 = (int)v9 + 2;
      if ((_DWORD)v9 + 2 == (_DWORD)v5)
        goto LABEL_21;
      v19 = __s[v15] ^ 0x80;
      if (v19 <= 0x3F)
      {
        LODWORD(v18) = v23 & 0x3F | ((v17 - 240) << 6);
LABEL_26:
        LODWORD(v15) = v15 + 1;
        if ((_DWORD)v15 != (_DWORD)v5)
        {
          v20 = v19 | ((_DWORD)v18 << 6);
LABEL_30:
          v21 = __s[(int)v15] ^ 0x80;
          v22 = v21 | (v20 << 6);
          if (v21 <= 0x3F)
            v17 = v22;
          else
            v17 = 65533;
          if (v21 > 0x3F)
            v15 = v15;
          else
            v15 = (v15 + 1);
          goto LABEL_42;
        }
LABEL_21:
        v17 = 65533;
        v15 = v5;
        goto LABEL_42;
      }
      v17 = 65533;
LABEL_42:
      if (v14 == icu::UnicodeSet::contains(this, v17))
      {
        v9 = v15;
        if ((int)v15 < (int)v5)
          continue;
      }
      return v9;
    }
    if (v17 >= 0xC2)
    {
      v20 = v17 & 0x1F;
      goto LABEL_30;
    }
LABEL_41:
    v17 = 65533;
    goto LABEL_42;
  }
  return sub_18BC52A60(v11, __s, v5, a4);
}

uint64_t icu::UnicodeSet::spanBackUTF8(icu::UnicodeSet *this, uint8_t *s, uint64_t a3, int a4)
{
  size_t v5;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  UChar32 v14;
  int32_t pi;
  _OWORD v16[16];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;

  v5 = a3;
  v26 = *MEMORY[0x1E0C80C00];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0)
      return 0;
    v5 = strlen((const char *)s);
    if ((_DWORD)v5)
      goto LABEL_8;
    return v5;
  }
  v8 = *((_QWORD *)this + 5);
  if (v8)
    return sub_18BBAC14C(v8, s, a3, a4);
LABEL_8:
  v10 = *((_QWORD *)this + 11);
  if (!v10)
  {
    v11 = *((_QWORD *)this + 10);
    if (v11 && *(_DWORD *)(v11 + 8))
    {
      v25 = 0;
      if (a4)
        v12 = 22;
      else
        v12 = 21;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      memset(v16, 0, sizeof(v16));
      sub_18BC517FC(v16, this, v11, v12);
      if ((_DWORD)v17)
      {
        v5 = sub_18BC5318C((uint64_t)v16, s, v5, a4);
        sub_18BC5194C(v16);
        return v5;
      }
      sub_18BC5194C(v16);
    }
    v13 = a4 != 0;
    do
    {
      pi = v5 - 1;
      v14 = s[(int)v5 - 1];
      if ((v14 & 0x80) != 0)
        v14 = utf8_prevCharSafeBody(s, 0, &pi, v14, -3);
      if (v13 != icu::UnicodeSet::contains(this, v14))
        break;
      v5 = pi;
    }
    while (pi > 0);
    return v5;
  }
  return sub_18BC5318C(v10, s, v5, a4);
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, const icu::UnicodeString *a2, unsigned int a3, const icu::SymbolTable *a4, UErrorCode *a5)
{
  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5);
}

{
  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5);
}

icu::UnicodeSet *icu::UnicodeSet::applyPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2, unsigned int a3, const icu::SymbolTable *a4, UErrorCode *a5)
{
  char v6;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v14;
  void (**v15)(icu::ParsePosition *__hidden);
  unint64_t v16;

  v6 = a3;
  v15 = off_1E224A8B0;
  v16 = 0xFFFFFFFF00000000;
  icu::UnicodeSet::applyPattern(this, a2, (icu::ParsePosition *)&v15, a3, a4, a5);
  if (*(int *)a5 <= 0)
  {
    v9 = v16;
    v14 = v16;
    if ((v6 & 1) != 0)
    {
      icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v14, (int *)1);
      v9 = v14;
    }
    v10 = *((unsigned __int16 *)a2 + 4);
    v11 = (__int16)v10;
    v12 = v10 >> 5;
    if (v11 < 0)
      v12 = *((_DWORD *)a2 + 3);
    if (v9 != v12)
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v15);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, unsigned int a4, const icu::SymbolTable *a5, UErrorCode *a6)
{
  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5, a6);
}

{
  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5, a6);
}

icu::UnicodeSet *icu::UnicodeSet::applyPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, unsigned int a4, const icu::SymbolTable *a5, UErrorCode *a6)
{
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  void (**v15)(icu::UnicodeString *__hidden);
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (*(int *)a6 <= 0)
  {
    if (*((_QWORD *)this + 5) || *((_QWORD *)this + 11))
    {
      *a6 = U_NO_WRITE_PERMISSION;
    }
    else
    {
      v16 = 0u;
      v17 = 0u;
      v19 = 0;
      v18 = 0u;
      v14 = 0;
      v15 = off_1E2256B38;
      LOWORD(v16) = 2;
      v12 = 0u;
      v13 = 0u;
      sub_18BBF6824((uint64_t)&v12, (uint64_t)a2, (uint64_t)a5, (uint64_t)a3);
      icu::UnicodeSet::applyPattern(this, (uint64_t *)&v12, (uint64_t)a5, (icu::UnicodeString *)&v15, a4, (void (*)(_QWORD *))icu::UnicodeSet::closeOver, 0, 0, a6);
      v11 = *(unsigned int *)a6;
      if ((int)v11 <= 0)
      {
        if (*((_QWORD *)&v13 + 1))
        {
          v11 = 65538;
          *a6 = U_MALFORMED_SET;
        }
        else
        {
          sub_18BC4E9A0((uint64_t)this, (uint64_t)&v15);
        }
      }
      icu::UnicodeString::~UnicodeString((void *)v11, (icu::UnicodeString *)&v15);
    }
  }
  return this;
}

uint64_t icu::UnicodeSet::closeOver(uint64_t this, char a2)
{
  if (!*(_QWORD *)(this + 40) && !*(_QWORD *)(this + 88) && (*(_BYTE *)(this + 32) & 1) == 0)
    __asm { BR              X10 }
  return this;
}

UChar *sub_18BC4E9A0(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  const UChar *v3;
  int v4;
  int32_t v5;
  int32_t v6;

  v2 = *(unsigned __int16 *)(a2 + 8);
  if ((v2 & 0x11) != 0)
  {
    v3 = 0;
  }
  else if ((v2 & 2) != 0)
  {
    v3 = (const UChar *)(a2 + 10);
  }
  else
  {
    v3 = *(const UChar **)(a2 + 24);
  }
  v4 = (__int16)v2;
  v5 = v2 >> 5;
  if (v4 >= 0)
    v6 = v5;
  else
    v6 = *(_DWORD *)(a2 + 12);
  return icu::UnicodeSet::setPattern(a1, v3, v6);
}

void icu::UnicodeSet::closeOverCaseInsensitive(icu::UnicodeSet *this, int a2)
{
  icu::UnicodeSet *v3;
  icu::UVector **v4;
  int RangeCount;
  int v6;
  int i;
  uint64_t RangeStart;
  int RangeEnd;
  int v10;
  int v11;
  unsigned int *v12;
  void *v13;
  signed int v14;
  uint64_t v15;
  const icu::UnicodeString *v16;
  unsigned int v17;
  uint64_t v18;
  unsigned __int16 *v19;
  unsigned __int16 *v20;
  int v21;
  icu::UnicodeSet *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  int v30;
  BOOL v31;
  unsigned int v32;
  UChar32 v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  UChar32 v40;
  int v42;
  BOOL v43;
  int v44;
  UChar32 v45;
  UChar32 v46;
  unsigned int **v47;
  int v48;
  _OWORD v49[12];
  uint64_t v50;
  _QWORD v51[6];
  _OWORD v52[5];
  icu::UVector *v53[2];
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  UChar *v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  uint64_t v66;

  v3 = this;
  v66 = *MEMORY[0x1E0C80C00];
  v60 = 0;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  *(_OWORD *)v53 = 0u;
  memset(v52, 0, sizeof(v52));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v52, this);
  if ((a2 & 1) == 0 && icu::UnicodeSet::hasStrings((icu::UnicodeSet *)v52))
    icu::UVector::removeAllElements((uint64_t)v53[0]);
  v51[0] = v52;
  v51[1] = icu::UnicodeSet::add;
  v51[2] = icu::UnicodeSet::add;
  v51[3] = sub_18BC4F290;
  v51[4] = 0;
  v51[5] = 0;
  v50 = 0;
  memset(v49, 0, sizeof(v49));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v49, 0, 0x10FFFFu);
  v4 = sub_18BC4F31C(v3, (icu::UVector **)v49);
  RangeCount = icu::UnicodeSet::getRangeCount((icu::UnicodeSet *)v4);
  if (RangeCount >= 1)
  {
    v6 = RangeCount;
    for (i = 0; i != v6; ++i)
    {
      RangeStart = icu::UnicodeSet::getRangeStart((icu::UnicodeSet *)v4, i);
      RangeEnd = icu::UnicodeSet::getRangeEnd((icu::UnicodeSet *)v4, i);
      if ((a2 & 1) != 0)
      {
        if ((int)RangeStart <= RangeEnd)
        {
          v10 = RangeEnd + 1;
          do
          {
            sub_18BC063C4(RangeStart, v51);
            RangeStart = (RangeStart + 1);
          }
          while (v10 != (_DWORD)RangeStart);
        }
      }
      else if ((int)RangeStart <= RangeEnd)
      {
        v11 = RangeEnd + 1;
        do
        {
          sub_18BC060CC(RangeStart, v51);
          RangeStart = (RangeStart + 1);
        }
        while (v11 != (_DWORD)RangeStart);
      }
    }
  }
  if (icu::UnicodeSet::hasStrings(v3))
  {
    v48 = a2;
    v62 = 0u;
    v65 = 0;
    v64 = 0u;
    v63 = 0u;
    v61 = (UChar *)off_1E2256B38;
    LOWORD(v62) = 2;
    v12 = (unsigned int *)*((_QWORD *)v3 + 10);
    v13 = (void *)v12[2];
    if ((int)v13 >= 1)
    {
      v14 = 0;
      v47 = (unsigned int **)v3;
      do
      {
        v15 = icu::UVector::elementAt((icu::UVector *)v12, v14);
        v16 = (const icu::UnicodeString *)v15;
        if (v48)
        {
          v17 = *(unsigned __int16 *)(v15 + 8);
          if ((v17 & 0x11) != 0)
          {
            v18 = 0;
          }
          else if ((v17 & 2) != 0)
          {
            v18 = v15 + 10;
          }
          else
          {
            v18 = *(_QWORD *)(v15 + 24);
          }
          v23 = (__int16)v17;
          v24 = v17 >> 5;
          if (v23 >= 0)
            v25 = v24;
          else
            v25 = *(_DWORD *)(v15 + 12);
          if (v25 < 1)
            goto LABEL_75;
          v26 = 0;
          while (1)
          {
            v27 = v26 + 1;
            v28 = *(unsigned __int16 *)(v18 + 2 * v26);
            if ((v28 & 0xFC00) != 0xD800 || (_DWORD)v27 == v25)
            {
              ++v26;
            }
            else
            {
              v30 = *(unsigned __int16 *)(v18 + 2 * v27);
              v31 = (v30 & 0xFC00) == 56320;
              v32 = (v28 << 10) - 56613888 + v30;
              if (v31)
                v26 += 2;
              else
                ++v26;
              if (v31)
                v28 = v32;
            }
            v33 = u_foldCase(v28, 0);
            if (v33 != v28)
              break;
            if (v26 >= v25)
              goto LABEL_75;
          }
          v34 = v33;
          if (v28 >= 0x10000)
            v35 = -2;
          else
            v35 = -1;
          v36 = (v35 + v26);
          icu::UnicodeString::unBogus((uint64_t)&v61);
          if ((v62 & 0x8000u) == 0)
            v37 = (unsigned __int16)v62 >> 5;
          else
            v37 = DWORD1(v62);
          icu::UnicodeString::doReplace((uint64_t)&v61, 0, v37, v18, 0, v36);
          icu::UnicodeString::append((uint64_t)&v61, v34);
          if (v26 != v25)
          {
            v38 = v26;
            do
            {
              v39 = v38 + 1;
              v40 = *(unsigned __int16 *)(v18 + 2 * v38);
              if ((v40 & 0xFC00) == 0xD800 && (_DWORD)v39 != v25)
              {
                v42 = *(unsigned __int16 *)(v18 + 2 * v39);
                v43 = (v42 & 0xFC00) == 56320;
                v44 = v38 + 2;
                v45 = (v40 << 10) - 56613888 + v42;
                if (v43)
                  LODWORD(v39) = v44;
                if (v43)
                  v40 = v45;
              }
              v46 = u_foldCase(v40, 0);
              icu::UnicodeString::append((uint64_t)&v61, v46);
              v38 = v39;
            }
            while ((_DWORD)v39 != v25);
          }
          v22 = icu::UnicodeSet::remove((icu::UnicodeSet *)v52, v16);
        }
        else
        {
          icu::UnicodeString::operator=(&v61, (UChar **)v15);
          icu::UnicodeString::foldCase((const UChar **)&v61, 0);
          v19 = (unsigned __int16 *)v63;
          if ((v62 & 2) != 0)
            v19 = (unsigned __int16 *)&v62 + 1;
          if ((v62 & 0x11) != 0)
            v20 = 0;
          else
            v20 = v19;
          if ((v62 & 0x8000u) == 0)
            v21 = (unsigned __int16)v62 >> 5;
          else
            v21 = DWORD1(v62);
          if (sub_18BC06680(v20, v21, v51))
            goto LABEL_75;
          v22 = (icu::UnicodeSet *)v52;
        }
        icu::UnicodeSet::add(v22, (const icu::UnicodeString *)&v61);
LABEL_75:
        ++v14;
        v3 = (icu::UnicodeSet *)v47;
        v12 = v47[10];
        v13 = (void *)v12[2];
      }
      while (v14 < (int)v13);
    }
    icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)&v61);
  }
  icu::UnicodeSet::operator=(v3, (const icu::UnicodeSet *)v52);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v49);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v52);
}

void icu::UnicodeSet::closeOverAddCaseMappings(icu::UVector **this)
{
  icu::UVector **v2;
  int RangeCount;
  int v4;
  int i;
  signed int RangeStart;
  signed int RangeEnd;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  UErrorCode *v13;
  UErrorCode *v14;
  char *WordInstance;
  icu::UVector *v16;
  signed int v17;
  UChar **v18;
  const UChar **v19;
  const UChar **v20;
  const UChar **v21;
  const UChar **v22;
  void *v23;
  int v24;
  uint64_t v25;
  _OWORD v26[12];
  uint64_t v27;
  _OWORD v28[12];
  uint64_t v29;
  _OWORD v30[14];
  UChar *v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v29 = 0;
  memset(v28, 0, sizeof(v28));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v28, (const icu::UnicodeSet *)this);
  v27 = 0;
  memset(v26, 0, sizeof(v26));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v26, 0, 0x10FFFFu);
  v2 = sub_18BC4F31C((icu::UnicodeSet *)this, (icu::UVector **)v26);
  RangeCount = icu::UnicodeSet::getRangeCount((icu::UnicodeSet *)v2);
  v25 = 0;
  v32 = 0u;
  v35 = 0;
  v34 = 0u;
  v33 = 0u;
  v31 = (UChar *)off_1E2256B38;
  LOWORD(v32) = 2;
  if (RangeCount >= 1)
  {
    v4 = RangeCount;
    for (i = 0; i != v4; ++i)
    {
      RangeStart = icu::UnicodeSet::getRangeStart((icu::UnicodeSet *)v2, i);
      RangeEnd = icu::UnicodeSet::getRangeEnd((icu::UnicodeSet *)v2, i);
      if (RangeStart <= RangeEnd)
      {
        v8 = RangeEnd + 1;
        do
        {
          v9 = ucase_toFullLower(RangeStart, 0, 0, &v25, 1);
          if ((v9 & 0x80000000) == 0)
          {
            if (v9 < 0x20)
            {
              *(_QWORD *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v9);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }
            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v9);
            }
          }
          v10 = ucase_toFullTitle(RangeStart, 0, 0, &v25, 1);
          if ((v10 & 0x80000000) == 0)
          {
            if (v10 < 0x20)
            {
              *(_QWORD *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v10);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }
            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v10);
            }
          }
          v11 = ucase_toFullUpper(RangeStart, 0, 0, &v25, 1);
          if ((v11 & 0x80000000) == 0)
          {
            if (v11 < 0x20)
            {
              *(_QWORD *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v11);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }
            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v11);
            }
          }
          v12 = ucase_toFullFolding(RangeStart, &v25, 0);
          if ((v12 & 0x80000000) == 0)
          {
            if (v12 < 0x20)
            {
              *(_QWORD *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v12);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }
            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v12);
            }
          }
          ++RangeStart;
        }
        while (v8 != RangeStart);
      }
    }
  }
  if (icu::UnicodeSet::hasStrings((icu::UnicodeSet *)this))
  {
    memset(v30, 0, sizeof(v30));
    icu::Locale::Locale((icu::Locale *)v30, "", 0, 0, 0);
    v24 = 0;
    WordInstance = icu::BreakIterator::createWordInstance((char **)v30, (const icu::Locale *)&v24, v13, v14);
    if (v24 <= 0)
    {
      v16 = this[10];
      if (*((int *)v16 + 2) >= 1)
      {
        v17 = 0;
        do
        {
          v18 = (UChar **)icu::UVector::elementAt(v16, v17);
          v19 = (const UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::toLower(v19, (const icu::Locale *)v30);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          v20 = (const UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::toTitle(v20, (icu::BreakIterator *)WordInstance, (const icu::Locale *)v30);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          v21 = (const UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::toUpper(v21, (const icu::Locale *)v30);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          v22 = (const UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::foldCase(v22, 0);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          ++v17;
          v16 = this[10];
        }
        while (v17 < *((_DWORD *)v16 + 2));
      }
    }
    if (WordInstance)
      (*(void (**)(char *))(*(_QWORD *)WordInstance + 8))(WordInstance);
    icu::Locale::~Locale((icu::Locale *)v30);
  }
  icu::UnicodeSet::operator=((icu::UnicodeSet *)this, (const icu::UnicodeSet *)v28);
  icu::UnicodeString::~UnicodeString(v23, (icu::UnicodeString *)&v31);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v26);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v28);
}

void *sub_18BC4F290(icu::UnicodeSet *a1, uint64_t a2, unsigned int a3)
{
  void *v4;
  uint64_t v6;
  _BYTE v7[64];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 >> 31, &v6);
  icu::UnicodeSet::add(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

icu::UVector **sub_18BC4F31C(icu::UnicodeSet *a1, icu::UVector **a2)
{
  icu::UnicodeSet *v3;
  icu::UnicodeSet *v4;
  icu::UnicodeSet *v5;
  int RangeCount;
  int v7;
  const icu::UnicodeSet *v8;
  int v10;

  v3 = a1;
  if ((int)icu::UnicodeSet::size(a1) >= 30)
  {
    v10 = 0;
    v4 = sub_18BBB1DE0(34, (UErrorCode *)&v10);
    if (v10 <= 0)
    {
      v5 = v4;
      RangeCount = icu::UnicodeSet::getRangeCount(v3);
      v7 = icu::UnicodeSet::getRangeCount(v5);
      if (RangeCount <= v7)
        v8 = v3;
      else
        v8 = v5;
      if (RangeCount <= v7)
        v3 = v5;
      icu::UnicodeSet::retainAll(a2, v8);
      icu::UnicodeSet::retainAll(a2, v3);
      return a2;
    }
  }
  return (icu::UVector **)v3;
}

uint64_t sub_18BC4F3B4(UErrorCode *a1)
{
  unsigned int v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v8;
  _BYTE v9[64];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (*(int *)a1 <= 0)
  {
    v2 = atomic_load(&dword_1EE009608);
    if (v2 != 2 && icu::umtx_initImplPreInit(&dword_1EE009608))
    {
      v4 = icu::UMemory::operator new((icu::UMemory *)0xC8, v3);
      if (v4)
      {
        v5 = v4;
        v8 = "[";
        icu::UnicodeString::UnicodeString(v9, 1, &v8);
        *(_QWORD *)v5 = off_1E2256980;
        *(_QWORD *)(v5 + 8) = &unk_1E2256A98;
        *(_QWORD *)(v5 + 16) = v5 + 96;
        *(_QWORD *)(v5 + 24) = 0x100000019;
        *(_BYTE *)(v5 + 32) = 0;
        *(_QWORD *)(v5 + 64) = 0;
        *(_DWORD *)(v5 + 72) = 0;
        *(_QWORD *)(v5 + 40) = 0;
        *(_QWORD *)(v5 + 48) = 0;
        *(_DWORD *)(v5 + 56) = 0;
        *(_QWORD *)(v5 + 80) = 0;
        *(_QWORD *)(v5 + 88) = 0;
        icu::UnicodeSet::applyPattern((icu::UnicodeSet *)v5, (const icu::UnicodeString *)v9, a1);
        qword_1EE009600 = v5;
        icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)v9);
        if (qword_1EE009600)
        {
          icu::UnicodeSet::freeze((icu::UnicodeSet *)qword_1EE009600);
LABEL_11:
          sub_18BC0ECC4(0x12u, (uint64_t)sub_18BC511CC);
          dword_1EE00960C = *a1;
          icu::umtx_initImplPostInit(&dword_1EE009608);
          return qword_1EE009600;
        }
      }
      else
      {
        qword_1EE009600 = 0;
      }
      *a1 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_11;
    }
    if (dword_1EE00960C >= 1)
      *a1 = dword_1EE00960C;
  }
  return qword_1EE009600;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3);
}

{
  *(_QWORD *)this = off_1E2256980;
  *((_QWORD *)this + 1) = &unk_1E2256A98;
  *((_QWORD *)this + 2) = (char *)this + 96;
  *((_QWORD *)this + 3) = 0x100000019;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::applyPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v10;
  void (**v11)(icu::ParsePosition *__hidden);
  unint64_t v12;

  v11 = off_1E224A8B0;
  v12 = 0xFFFFFFFF00000000;
  icu::UnicodeSet::applyPatternIgnoreSpace(this, a2, (icu::ParsePosition *)&v11, 0, a3);
  if (*(int *)a3 <= 0)
  {
    v10 = v12;
    icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v10, (int *)1);
    v6 = *((unsigned __int16 *)a2 + 4);
    v7 = (__int16)v6;
    v8 = v6 >> 5;
    if (v7 < 0)
      v8 = *((_DWORD *)a2 + 3);
    if (v10 != v8)
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v11);
  return this;
}

void icu::UnicodeSet::applyPatternIgnoreSpace(icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, const icu::SymbolTable *a4, UErrorCode *a5)
{
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  void (**v11)(icu::UnicodeString *__hidden);
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (*(int *)a5 <= 0)
  {
    if (*((_QWORD *)this + 5) || *((_QWORD *)this + 11))
    {
      *a5 = U_NO_WRITE_PERMISSION;
    }
    else
    {
      v12 = 0u;
      v13 = 0u;
      v15 = 0;
      v14 = 0u;
      v10 = 0;
      v11 = off_1E2256B38;
      LOWORD(v12) = 2;
      v8 = 0u;
      v9 = 0u;
      sub_18BBF6824((uint64_t)&v8, (uint64_t)a2, (uint64_t)a4, (uint64_t)a3);
      icu::UnicodeSet::applyPattern(this, (uint64_t *)&v8, (uint64_t)a4, (icu::UnicodeString *)&v11, 1u, 0, 0, 0, a5);
      if (*(int *)a5 <= 0)
      {
        if (*((_QWORD *)&v9 + 1))
          *a5 = U_MALFORMED_SET;
        else
          sub_18BC4E9A0((uint64_t)this, (uint64_t)&v11);
      }
      icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v11);
    }
  }
}

void icu::UnicodeSet::applyPattern(icu::UnicodeSet *a1, uint64_t *a2, uint64_t a3, icu::UnicodeString *a4, unsigned int a5, void (*a6)(_QWORD *), uint64_t a7, int a8, UErrorCode *a9)
{
  char v12;
  int v13;
  int v14;
  int v15;
  char v16;
  unint64_t v17;
  icu::UnicodeSet *v18;
  int v19;
  icu::UnicodeSet *v20;
  icu::UnicodeSet *v21;
  uint64_t v22;
  uint64_t v23;
  void (***v24)(icu::UnicodeSet *__hidden);
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  _BOOL4 v30;
  _QWORD *v31;
  icu::UnicodeSet *v32;
  uint64_t v33;
  void *v34;
  int v35;
  int v37;
  unsigned int v38;
  unsigned int v43;
  icu::UnicodeSet *v44;
  char v45;
  _QWORD v46[2];
  __int16 v47;
  void (**v48)(icu::UnicodeString *__hidden);
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  void (**v53)(icu::UnicodeString *__hidden);
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (*(int *)a9 > 0)
    return;
  if (a8 >= 101)
  {
    *a9 = U_ILLEGAL_ARGUMENT_ERROR;
    return;
  }
  v54 = 0u;
  if ((a5 & 1) != 0)
    v12 = 7;
  else
    v12 = 3;
  v57 = 0;
  v56 = 0uLL;
  v55 = 0uLL;
  v53 = off_1E2256B38;
  LOWORD(v54) = 2;
  v49 = 0uLL;
  v52 = 0;
  v51 = 0uLL;
  v50 = 0uLL;
  v48 = off_1E2256B38;
  LOWORD(v49) = 2;
  v46[0] = 0;
  v46[1] = 0;
  icu::UnicodeSet::clear(a1);
  v13 = 0;
  v14 = 0;
  v43 = 0;
  v15 = 0;
  v16 = 0;
  v44 = 0;
  v37 = 0;
  v38 = a8 + 1;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        if (sub_18BBF6834(a2))
          goto LABEL_134;
        v45 = 0;
        if (!icu::UnicodeSet::resemblesPropertyPattern((uint64_t)a2, v12))
          break;
        v18 = 0;
        v19 = 2;
LABEL_11:
        if (v16 == 1)
        {
          if (v14)
            goto LABEL_123;
          icu::UnicodeSet::add(a1, v43, v43);
          icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
        }
        else if (v14 == 45 || v14 == 38)
        {
          v47 = v14;
          icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1);
        }
        if (!v18)
        {
          v18 = v44;
          if (!v44)
          {
            v20 = (icu::UnicodeSet *)icu::UMemory::operator new((icu::UMemory *)0xC8, v17);
            if (!v20)
              goto LABEL_117;
            icu::UnicodeSet::UnicodeSet(v20);
            v44 = v21;
            v18 = v21;
          }
        }
        if (v19 == 3)
        {
          icu::UnicodeSet::_toPattern(v18, (icu::UnicodeString *)&v53, 0);
        }
        else if (v19 == 2)
        {
          sub_18BBF6C10((_BOOL8)a2, v12);
          icu::UnicodeSet::applyPropertyPattern(v18, a2, (uint64_t)&v53, a9);
          if (*(int *)a9 >= 1)
            goto LABEL_135;
        }
        else
        {
          icu::UnicodeSet::applyPattern(v18, a2, a3, &v53, a5, a6, a7, v38, a9);
        }
        if (!v15)
        {
          icu::UnicodeSet::operator=(a1, v18);
          v13 = 1;
          goto LABEL_103;
        }
        if (v14)
        {
          if (v14 == 38)
            icu::UnicodeSet::retainAll((icu::UVector **)a1, v18);
          else
            icu::UnicodeSet::removeAll((icu::UVector **)a1, v18);
          v14 = 0;
        }
        else
        {
          icu::UnicodeSet::addAll((icu::UVector **)a1, v18);
        }
        v13 = 1;
LABEL_39:
        v16 = 2;
      }
      sub_18BBF6BD8((uint64_t)a2, (uint64_t)v46);
      v22 = sub_18BBF6870((uint64_t)a2, v12, &v45, (int *)a9);
      if (*(int *)a9 > 0)
        goto LABEL_135;
      v23 = v22;
      if ((_DWORD)v22 != 91 || v45)
        break;
      if (v15 == 1)
      {
        sub_18BBF6BF4((uint64_t)a2, (uint64_t)v46);
        v18 = 0;
        v19 = 1;
        goto LABEL_11;
      }
      v47 = 91;
      icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1);
      sub_18BBF6BD8((uint64_t)a2, (uint64_t)v46);
      v25 = sub_18BBF6870((uint64_t)a2, v12, &v45, (int *)a9);
      if (*(int *)a9 > 0)
        goto LABEL_135;
      if (v25 == 94 && !v45)
      {
        v47 = 94;
        v37 = 1;
        icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1);
        sub_18BBF6BD8((uint64_t)a2, (uint64_t)v46);
        v25 = sub_18BBF6870((uint64_t)a2, v12, &v45, (int *)a9);
        if (*(int *)a9 > 0)
          goto LABEL_135;
      }
      if (v25 == 45)
      {
        v15 = 1;
        v45 = 1;
        v23 = 45;
        goto LABEL_59;
      }
      sub_18BBF6BF4((uint64_t)a2, (uint64_t)v46);
      v15 = 1;
    }
    if (a3)
    {
      v24 = (void (***)(icu::UnicodeSet *__hidden))(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 24))(a3, v22);
      if (v24)
      {
        v18 = (icu::UnicodeSet *)v24;
        if (*v24 != off_1E2256980)
          goto LABEL_123;
        v19 = 3;
        goto LABEL_11;
      }
    }
    if (!v15)
      goto LABEL_123;
    if (v45)
      goto LABEL_59;
    if ((int)v23 <= 44)
      break;
    if ((int)v23 > 93)
    {
      if ((_DWORD)v23 == 123)
      {
        if (!v14)
        {
          if (v16 == 1)
          {
            icu::UnicodeSet::add(a1, v43, v43);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
          }
          sub_18BC503EC((uint64_t)&v48, 0);
          while (!sub_18BBF6834(a2))
          {
            v27 = sub_18BBF6870((uint64_t)a2, v12, &v45, (int *)a9);
            if (*(int *)a9 > 0)
              goto LABEL_135;
            if (v27 == 125 && !v45)
            {
              icu::UnicodeSet::add(a1, (const icu::UnicodeString *)&v48);
              v47 = 123;
              icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1);
              icu::UnicodeSet::_appendToPat((icu::ICU_Utility *)&v53, (icu::UnicodeString *)&v48, 0);
              v47 = 125;
              icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1);
              goto LABEL_69;
            }
            icu::UnicodeString::append((uint64_t)&v48, v27);
          }
        }
LABEL_123:
        v26 = 65538;
        goto LABEL_124;
      }
      if ((_DWORD)v23 == 94)
        goto LABEL_123;
LABEL_59:
      switch(v16)
      {
        case 2:
          if (v14)
            goto LABEL_123;
LABEL_65:
          v16 = 1;
          goto LABEL_76;
        case 1:
          if (v14 == 45)
          {
            if ((int)v43 >= (int)v23)
              goto LABEL_123;
            icu::UnicodeSet::add(a1, v43, v23);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
            v47 = 45;
            icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v23, 0);
LABEL_69:
            v16 = 0;
            v14 = 0;
          }
          else
          {
            icu::UnicodeSet::add(a1, v43, v43);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
LABEL_76:
            v43 = v23;
          }
          break;
        case 0:
          goto LABEL_65;
      }
    }
    else
    {
      if ((_DWORD)v23 != 45)
      {
        if ((_DWORD)v23 == 93)
        {
          if (v16 == 1)
          {
            icu::UnicodeSet::add(a1, v43, v43);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
          }
          if (v14 != 38)
          {
            if (v14 == 45)
            {
              icu::UnicodeSet::add(a1, 0x2Du, 0x2Du);
              v47 = 45;
              goto LABEL_132;
            }
            goto LABEL_133;
          }
          goto LABEL_123;
        }
        goto LABEL_59;
      }
      if (v14)
        goto LABEL_123;
      if (!v16)
      {
        icu::UnicodeSet::add(a1, 0x2Du, 0x2Du);
        v35 = sub_18BBF6870((uint64_t)a2, v12, &v45, (int *)a9);
        if (*(int *)a9 > 0)
          goto LABEL_135;
        v26 = 65538;
        if (v35 == 93 && !v45)
        {
          icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&unk_18BE35BCE, 0, 2);
          goto LABEL_103;
        }
LABEL_124:
        v20 = v44;
        goto LABEL_125;
      }
      v14 = 45;
    }
  }
  if ((_DWORD)v23 != 36)
  {
    if ((_DWORD)v23 == 38)
    {
      v26 = 65538;
      if (v16 != 2 || v14)
        goto LABEL_124;
      v14 = 38;
      goto LABEL_39;
    }
    goto LABEL_59;
  }
  sub_18BBF6BD8((uint64_t)a2, (uint64_t)v46);
  v28 = sub_18BBF6870((uint64_t)a2, v12, &v45, (int *)a9);
  if (*(int *)a9 > 0)
    goto LABEL_135;
  v30 = v28 == 93 && v45 == 0;
  if (!a3 && !v30)
  {
    sub_18BBF6BF4((uint64_t)a2, (uint64_t)v46);
    v23 = 36;
    goto LABEL_59;
  }
  if (v14)
    v30 = 0;
  if (v30)
  {
    if (v16 == 1)
    {
      icu::UnicodeSet::add(a1, v43, v43);
      icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
    }
    icu::UnicodeSet::add(a1, 0xFFFFu);
    v47 = 36;
    v13 = 1;
LABEL_132:
    icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1);
LABEL_133:
    v47 = 93;
    icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1);
LABEL_103:
    sub_18BBF6C10((_BOOL8)a2, v12);
    if ((a5 & 6) != 0)
    {
      v31 = (_QWORD *)((char *)a1 + (a7 >> 1));
      if ((a7 & 1) != 0)
        (*(void (**)(_QWORD *))(*v31 + a6))(v31);
      else
        a6(v31);
    }
    if (v37)
    {
      v32 = icu::UnicodeSet::complement(a1);
      icu::UnicodeSet::removeAllStrings(v32);
    }
    if (v13)
    {
      if ((v54 & 0x8000u) == 0)
        v33 = (unsigned __int16)v54 >> 5;
      else
        v33 = DWORD1(v54);
      icu::UnicodeString::doAppend((uint64_t)a4, (const icu::UnicodeString *)&v53, 0, v33);
    }
    else
    {
      icu::UnicodeSet::_generatePattern(a1, a4, 0);
    }
    if ((*((_BYTE *)a1 + 32) & 1) != 0)
    {
      v20 = v44;
      if (*(int *)a9 > 0)
        goto LABEL_136;
LABEL_117:
      v26 = 7;
LABEL_125:
      *a9 = v26;
      goto LABEL_136;
    }
  }
  else
  {
LABEL_134:
    *a9 = U_MALFORMED_SET;
  }
LABEL_135:
  v20 = v44;
LABEL_136:
  if (v20)
  {
    icu::UnicodeSet::~UnicodeSet(v20);
    icu::UMemory::operator delete(v34);
  }
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v48);
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v53);
}

BOOL icu::UnicodeSet::resemblesPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  icu::UnicodeSet *v5;

  v2 = (_DWORD)a2 + 1;
  v3 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0)
  {
    v4 = *((_DWORD *)this + 3);
    if (v2 >= (int)v4)
      return icu::UnicodeSet::resemblesPropertyPattern((uint64_t)this, (signed int)a2) != 0;
  }
  else
  {
    if (v2 >= (int)(v3 >> 5))
      return icu::UnicodeSet::resemblesPropertyPattern((uint64_t)this, (signed int)a2) != 0;
    v4 = v3 >> 5;
  }
  if (v4 > a2)
  {
    v5 = (v3 & 2) != 0 ? (icu::UnicodeSet *)((char *)this + 10) : (icu::UnicodeSet *)*((_QWORD *)this + 3);
    if (*((_WORD *)v5 + (int)a2) == 91)
      return 1;
  }
  return icu::UnicodeSet::resemblesPropertyPattern((uint64_t)this, (signed int)a2) != 0;
}

uint64_t icu::UnicodeSet::resemblesPropertyPattern(uint64_t a1, signed int a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  int v9;

  v2 = *(unsigned __int16 *)(a1 + 8);
  if ((v2 & 0x8000u) == 0)
    v3 = v2 >> 5;
  else
    v3 = *(_DWORD *)(a1 + 12);
  if (a2 + 5 > (int)v3 || v3 <= a2)
    return 0;
  if ((v2 & 2) != 0)
    v4 = a1 + 10;
  else
    v4 = *(_QWORD *)(a1 + 24);
  v5 = *(unsigned __int16 *)(v4 + 2 * a2);
  if (v5 != 92)
  {
    if (v5 == 91)
    {
      v6 = a2 + 1;
      if (v3 > v6 && *(_WORD *)(v4 + 2 * v6) == 58)
        return 1;
    }
    return 0;
  }
  v8 = a2 + 1;
  if (v3 <= v8)
    return 0;
  v9 = *(_WORD *)(v4 + 2 * v8) & 0xFFDF;
  result = v9 == 80;
  if (v9 != 80 && v3 > v8)
    return *(unsigned __int16 *)(v4 + 2 * (int)v8) == 78;
  return result;
}

BOOL icu::UnicodeSet::resemblesPropertyPattern(uint64_t a1, char a2)
{
  char v4;
  int v5;
  int v6;
  int v7;
  int v8;
  _QWORD v10[2];
  int v11;
  char v12;

  v12 = 0;
  v11 = 0;
  v4 = a2 & 0xFD;
  v10[0] = 0;
  v10[1] = 0;
  sub_18BBF6BD8(a1, (uint64_t)v10);
  v5 = sub_18BBF6870(a1, v4, &v12, &v11);
  if ((v5 - 91) <= 1)
  {
    v6 = v5;
    v7 = sub_18BBF6870(a1, a2 & 0xF9, &v12, &v11);
    v8 = v7;
    if (v6 == 91)
    {
      sub_18BBF6BF4(a1, (uint64_t)v10);
      if (v8 != 58)
        return 0;
      return v11 < 1;
    }
    if ((v7 - 78) <= 0x22 && ((1 << (v7 - 78)) & 0x400000005) != 0)
    {
      sub_18BBF6BF4(a1, (uint64_t)v10);
      return v11 < 1;
    }
  }
  sub_18BBF6BF4(a1, (uint64_t)v10);
  return 0;
}

void icu::UnicodeSet::applyPropertyPattern(icu::UnicodeSet *a1, uint64_t *a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v8;
  void (**v9)(icu::ParsePosition *__hidden);
  unint64_t v10;
  void (**v11)(icu::UnicodeString *__hidden);
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (*(int *)a4 <= 0)
  {
    v12 = 0u;
    v13 = 0u;
    v15 = 0;
    v14 = 0u;
    v11 = off_1E2256B38;
    LOWORD(v12) = 2;
    sub_18BBF6B6C((uint64_t)a2, (icu::UnicodeString *)&v11, 0xFFFFFFFF);
    v9 = off_1E224A8B0;
    v10 = 0xFFFFFFFF00000000;
    icu::UnicodeSet::applyPropertyPattern(a1, (const icu::UnicodeString *)&v11, (icu::ParsePosition *)&v9, a4);
    if (*(int *)a4 <= 0)
    {
      v8 = v10;
      if ((_DWORD)v10)
      {
        sub_18BBF6BD4(a2, v10);
        icu::UnicodeString::doAppend(a3, (const icu::UnicodeString *)&v11, 0, v8);
      }
      else
      {
        *a4 = U_MALFORMED_SET;
      }
    }
    icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v9);
    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v11);
  }
}

uint64_t sub_18BC503EC(uint64_t a1, int a2)
{
  unsigned int v2;
  unsigned int v3;

  v2 = *(unsigned __int16 *)(a1 + 8);
  if (!a2 && (v2 & 1) != 0)
  {
    icu::UnicodeString::unBogus(a1);
    return 0;
  }
  if ((v2 & 0x8000) != 0)
    v3 = *(_DWORD *)(a1 + 12);
  else
    v3 = v2 >> 5;
  if (v3 <= a2)
    return 0;
  if (a2 > 1023)
  {
    *(_WORD *)(a1 + 8) = v2 | 0xFFE0;
    *(_DWORD *)(a1 + 12) = a2;
  }
  else
  {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0x1F | (32 * a2);
  }
  return 1;
}

icu::UnicodeSet *icu::UnicodeSet::applyFilter(icu::UnicodeSet *this, signed __int8 (*a2)(int, void *), void *a3, const icu::UnicodeSet *a4, UErrorCode *a5)
{
  UErrorCode *v5;
  icu::UnicodeSet *v9;
  int v10;
  int v11;
  signed int v12;
  int RangeStart;
  int v14;
  unsigned int v15;
  UErrorCode *v16;

  if (*(int *)a5 <= 0)
  {
    v5 = a5;
    v9 = this;
    icu::UnicodeSet::clear(this);
    this = (icu::UnicodeSet *)icu::UnicodeSet::getRangeCount(a4);
    if ((int)this >= 1)
    {
      v10 = (int)this;
      v16 = v5;
      v11 = 0;
      v12 = -1;
      do
      {
        RangeStart = icu::UnicodeSet::getRangeStart(a4, v11);
        this = (icu::UnicodeSet *)icu::UnicodeSet::getRangeEnd(a4, v11);
        if (RangeStart <= (int)this)
        {
          v14 = (int)this;
          v15 = RangeStart - 1;
          do
          {
            this = (icu::UnicodeSet *)((uint64_t (*)(_QWORD, void *))a2)(v15 + 1, a3);
            if ((_DWORD)this)
            {
              if (v12 < 0)
                v12 = v15 + 1;
            }
            else if ((v12 & 0x80000000) == 0)
            {
              this = icu::UnicodeSet::add(v9, v12, v15);
              v12 = -1;
            }
            ++v15;
          }
          while (v14 != v15);
        }
        ++v11;
      }
      while (v11 != v10);
      v5 = v16;
      if ((v12 & 0x80000000) == 0)
        this = icu::UnicodeSet::add(v9, v12, 0x10FFFFu);
    }
    if ((*((_BYTE *)v9 + 32) & 1) != 0 && *(int *)v5 <= 0)
      *v5 = U_MEMORY_ALLOCATION_ERROR;
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::applyIntPropertyValue(icu::UnicodeSet *this, uint64_t property, unsigned int a3, UErrorCode *pErrorCode)
{
  int v7;
  const icu::UnicodeSet *v8;
  signed __int8 (*v9)(int, void *);
  unsigned int *v10;
  const USet *BinaryPropertySet;
  icu::UnicodeSet *v13;
  _DWORD v14[3];
  unsigned int v15;

  v15 = a3;
  if (*(int *)pErrorCode > 0 || *((_QWORD *)this + 5) || *((_QWORD *)this + 11))
    return this;
  v7 = property;
  if ((_DWORD)property == 28672)
  {
    v8 = (const icu::UnicodeSet *)sub_18BBB1AE0(28672, (int *)pErrorCode);
    v14[0] = a3;
    v9 = (signed __int8 (*)(int, void *))sub_18BC506F8;
LABEL_8:
    v10 = v14;
    goto LABEL_9;
  }
  if ((_DWORD)property == 0x2000)
  {
    v8 = (const icu::UnicodeSet *)sub_18BBB1AE0(0x2000, (int *)pErrorCode);
    v9 = (signed __int8 (*)(int, void *))sub_18BC506D0;
    v10 = &v15;
LABEL_9:
    icu::UnicodeSet::applyFilter(this, v9, v10, v8, pErrorCode);
    return this;
  }
  if (property > 0x4A)
  {
    if ((property - 4096) > 0x18)
    {
      *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
      return this;
    }
    v8 = (const icu::UnicodeSet *)sub_18BBB1AE0(property, (int *)pErrorCode);
    v14[0] = v7;
    v14[1] = a3;
    v9 = (signed __int8 (*)(int, void *))sub_18BC50700;
    goto LABEL_8;
  }
  if (a3 > 1)
  {
    icu::UnicodeSet::clear(this);
  }
  else
  {
    BinaryPropertySet = u_getBinaryPropertySet((UProperty)property, pErrorCode);
    if (*(int *)pErrorCode <= 0)
    {
      icu::UnicodeSet::copyFrom(this, BinaryPropertySet, 1);
      if (!a3)
      {
        v13 = icu::UnicodeSet::complement(this);
        icu::UnicodeSet::removeAllStrings(v13);
      }
    }
  }
  return this;
}

uint64_t sub_18BC506D0(UChar32 a1, unsigned int *a2)
{
  unsigned int v2;

  v2 = *a2;
  return (v2 >> u_charType(a1)) & 1;
}

BOOL sub_18BC506F8(unsigned int a1, unsigned int *a2)
{
  return uscript_hasScript(a1, *a2);
}

BOOL sub_18BC50700(UChar32 a1, uint64_t a2)
{
  return u_getIntPropertyValue(a1, *(UProperty *)a2) == *(_DWORD *)(a2 + 4);
}

icu::UnicodeSet *icu::UnicodeSet::applyPropertyAlias(icu::UnicodeSet *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, UErrorCode *a4)
{
  unsigned int v8;
  _WORD *v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  _WORD *v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int32_t v24;
  int32_t v25;
  int32_t PropertyValueEnum;
  UErrorCode v27;
  const icu::UnicodeSet *v28;
  signed __int8 (*v29)(int, void *);
  double v30;
  uint64_t PropertyEnum;
  UChar32 v32;
  unsigned int v33;
  icu::UnicodeSet *v35;
  unsigned int v36;
  icu::UnicodeSet *v37;
  icu::UnicodeSet *v38;
  double versionArray;
  char versionString[16];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  char *alias[8];
  void *v49[9];

  v49[8] = *(void **)MEMORY[0x1E0C80C00];
  if (*(int *)a4 > 0 || *((_QWORD *)this + 5) || *((_QWORD *)this + 11))
    return this;
  v8 = *((unsigned __int16 *)a2 + 4);
  if ((v8 & 0x11) != 0)
  {
    v9 = 0;
  }
  else if ((v8 & 2) != 0)
  {
    v9 = (_WORD *)((char *)a2 + 10);
  }
  else
  {
    v9 = (_WORD *)*((_QWORD *)a2 + 3);
  }
  v10 = (__int16)v8;
  v11 = v8 >> 5;
  if (v10 >= 0)
    v12 = v11;
  else
    v12 = *((_DWORD *)a2 + 3);
  if (!uprv_isInvariantUString(v9, v12)
    || ((v13 = *((unsigned __int16 *)a3 + 4), (v13 & 0x11) == 0)
      ? ((v13 & 2) != 0
       ? (v14 = (_WORD *)((char *)a3 + 10))
       : (v14 = (_WORD *)*((_QWORD *)a3 + 3)))
      : (v14 = 0),
        (v15 = (__int16)v13, v16 = v13 >> 5, v15 >= 0) ? (v17 = v16) : (v17 = *((_DWORD *)a3 + 3)),
        !uprv_isInvariantUString(v14, v17)))
  {
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    return this;
  }
  memset(&v49[1], 0, 56);
  v49[0] = (char *)&v49[1] + 5;
  LODWORD(v49[1]) = 40;
  memset(&alias[1], 0, 56);
  alias[0] = (char *)&alias[1] + 5;
  LODWORD(alias[1]) = 40;
  icu::CharString::appendInvariantChars((icu::CharString *)v49, a2, a4);
  icu::CharString::appendInvariantChars((icu::CharString *)alias, a3, a4);
  if (*(int *)a4 <= 0)
  {
    v18 = *((unsigned __int16 *)a3 + 4);
    v19 = (__int16)v18;
    v20 = v18 >> 5;
    if (v19 < 0)
      v20 = *((_DWORD *)a3 + 3);
    if (v20 < 1)
    {
      v23 = 0x2000;
      PropertyValueEnum = u_getPropertyValueEnum(UCHAR_GENERAL_CATEGORY_MASK, (const char *)v49[0]);
      if (PropertyValueEnum != -1
        || (v23 = 4106,
            PropertyValueEnum = u_getPropertyValueEnum(UCHAR_SCRIPT, (const char *)v49[0]),
            PropertyValueEnum != -1))
      {
        v25 = PropertyValueEnum;
        goto LABEL_43;
      }
      PropertyEnum = u_getPropertyEnum((const char *)v49[0]);
      if (PropertyEnum < 0x4B)
      {
        v23 = PropertyEnum;
        v25 = 1;
        goto LABEL_43;
      }
      if (uprv_compareASCIIPropertyNames(byte_18BE15260, (unsigned __int8 *)v49[0]))
      {
        if (uprv_compareASCIIPropertyNames("ASCII", (unsigned __int8 *)v49[0]))
        {
          if (!uprv_compareASCIIPropertyNames("Assigned", (unsigned __int8 *)v49[0]))
          {
            v37 = icu::UnicodeSet::applyIntPropertyValue(this, 0x2000, 1u, a4);
            v38 = icu::UnicodeSet::complement(v37);
            icu::UnicodeSet::removeAllStrings(v38);
LABEL_44:
            if ((*((_BYTE *)this + 32) & 1) == 0 || *(int *)a4 > 0)
              goto LABEL_71;
            v27 = U_MEMORY_ALLOCATION_ERROR;
            goto LABEL_70;
          }
          goto LABEL_69;
        }
        v35 = this;
        v36 = 127;
      }
      else
      {
        v35 = this;
        v36 = 1114111;
      }
      icu::UnicodeSet::set(v35, 0, v36);
      goto LABEL_71;
    }
    v21 = u_getPropertyEnum((const char *)v49[0]);
    if ((_DWORD)v21 == -1)
      goto LABEL_69;
    v22 = v21;
    if ((_DWORD)v21 == 4101)
      v23 = 0x2000;
    else
      v23 = v21;
    if ((_DWORD)v23 == 0x2000 || v23 < 0x4B || (v23 - 4096) <= 0x18)
    {
      v25 = u_getPropertyValueEnum((UProperty)v23, alias[0]);
      if (v25 != -1)
        goto LABEL_43;
      if ((v23 - 4098) <= 0xF && ((1 << (v23 - 2)) & 0xC001) != 0)
      {
        *(_QWORD *)versionString = 0;
        v30 = strtod(alias[0], (char **)versionString);
        if (!**(_BYTE **)versionString && v30 >= 0.0 && v30 <= 255.0)
        {
          v25 = (int)v30;
          if (v30 == (double)(int)v30)
          {
            v23 = v22;
            goto LABEL_43;
          }
        }
      }
      goto LABEL_69;
    }
    if ((int)v23 <= 16388)
    {
      if ((_DWORD)v23 == 12288)
      {
        *(_QWORD *)versionString = 0;
        versionArray = strtod(alias[0], (char **)versionString);
        if (**(_BYTE **)versionString)
          goto LABEL_69;
        v28 = (const icu::UnicodeSet *)sub_18BBB1AE0(12288, (int *)a4);
        v29 = (signed __int8 (*)(int, void *))sub_18BC50C34;
      }
      else
      {
        if ((_DWORD)v23 != 0x4000)
          goto LABEL_69;
        v46 = 0u;
        v47 = 0u;
        v44 = 0u;
        v45 = 0u;
        v42 = 0u;
        v43 = 0u;
        *(_OWORD *)versionString = 0u;
        v41 = 0u;
        if (!sub_18BC50C60((uint64_t)versionString, (uint64_t)alias[0]))
          goto LABEL_69;
        LODWORD(versionArray) = 0;
        u_versionFromString((uint8_t *)&versionArray, versionString);
        v28 = (const icu::UnicodeSet *)sub_18BBB1AE0(0x4000, (int *)a4);
        v29 = (signed __int8 (*)(int, void *))sub_18BC50CE0;
      }
      icu::UnicodeSet::applyFilter(this, v29, &versionArray, v28, a4);
    }
    else
    {
      if ((_DWORD)v23 != 16389)
      {
        if ((_DWORD)v23 == 28672)
        {
          v24 = u_getPropertyValueEnum(UCHAR_SCRIPT, alias[0]);
          if (v24 != -1)
          {
            v25 = v24;
            v23 = 28672;
LABEL_43:
            icu::UnicodeSet::applyIntPropertyValue(this, v23, v25, a4);
            goto LABEL_44;
          }
        }
LABEL_69:
        v27 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_70:
        *a4 = v27;
        goto LABEL_71;
      }
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      *(_OWORD *)versionString = 0u;
      v41 = 0u;
      if (!sub_18BC50C60((uint64_t)versionString, (uint64_t)alias[0]))
        goto LABEL_69;
      v32 = u_charFromName(U_EXTENDED_CHAR_NAME, versionString, a4);
      if (*(int *)a4 > 0)
        goto LABEL_69;
      v33 = v32;
      icu::UnicodeSet::clear(this);
      icu::UnicodeSet::add(this, v33);
    }
  }
LABEL_71:
  if (BYTE4(alias[1]))
    uprv_free(alias[0]);
  if (BYTE4(v49[1]))
    uprv_free(v49[0]);
  return this;
}

BOOL sub_18BC50C34(UChar32 a1, double *a2)
{
  return u_getNumericValue(a1) == *a2;
}

uint64_t sub_18BC50C60(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;

  v2 = 0;
  while (2)
  {
    v3 = a2 + 1;
    while (1)
    {
      a2 = v3;
      v4 = *(unsigned __int8 *)(v3 - 1);
      if (v4 != 32)
        break;
      ++v3;
      if (v2 && *(_BYTE *)(a1 + (v2 - 1)) != 32)
        goto LABEL_8;
    }
    if (!*(_BYTE *)(v3 - 1))
    {
      if ((_DWORD)v2)
      {
        if (*(_BYTE *)(a1 + (v2 - 1)) == 32)
          LODWORD(v2) = v2 - 1;
        v2 = (int)v2;
      }
      else
      {
        v2 = 0;
      }
      *(_BYTE *)(a1 + v2) = 0;
      return 1;
    }
LABEL_8:
    if (v2 != 127)
    {
      *(_BYTE *)(a1 + v2++) = v4;
      continue;
    }
    return 0;
  }
}

BOOL sub_18BC50CE0(UChar32 a1, unsigned int *a2)
{
  _BOOL8 result;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  _BOOL4 v7;
  int v8;
  UVersionInfo versionArray;

  *(_DWORD *)versionArray = 0;
  u_charAge(a1, versionArray);
  result = 0;
  if (bswap32(*(unsigned int *)versionArray))
  {
    v4 = bswap32(*(unsigned int *)versionArray);
    v5 = bswap32(*a2);
    v6 = v4 >= v5;
    v7 = v4 > v5;
    v8 = !v6;
    return v7 - v8 < 1;
  }
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::applyPropertyPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, UErrorCode *a4)
{
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  char *v11;
  int v12;
  BOOL v13;
  unsigned int v14;
  BOOL v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  _BOOL4 v20;
  unsigned int v21;
  int v22;
  _BOOL4 v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  char *v28;
  int v29;
  int v30;
  char *v31;
  int v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  icu::UnicodeSet *v40;
  unsigned int v42;
  _BYTE v43[64];
  UChar *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint64_t v48;
  UChar *v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (*(int *)a4 > 0)
    return this;
  v8 = *((int *)a3 + 2);
  v9 = *((unsigned __int16 *)a2 + 4);
  if ((v9 & 0x8000u) == 0)
    v10 = v9 >> 5;
  else
    v10 = *((_DWORD *)a2 + 3);
  if ((int)v8 + 5 > (int)v10 || v10 <= v8)
    goto LABEL_88;
  v42 = 0;
  if ((v9 & 2) != 0)
    v11 = (char *)a2 + 10;
  else
    v11 = (char *)*((_QWORD *)a2 + 3);
  v12 = *(unsigned __int16 *)&v11[2 * v8];
  if (v12 == 92)
  {
    v21 = v8 + 1;
    if (v10 > (int)v8 + 1)
    {
      v22 = *(unsigned __int16 *)&v11[2 * v21];
      if ((v22 & 0xFFFFFFDF) != 0x50)
      {
        if (v10 <= v21 || *(_WORD *)&v11[2 * v21] != 78)
          goto LABEL_88;
        v22 = 78;
      }
      v20 = v22 == 80;
      v23 = v22 == 78;
      v42 = v8 + 2;
      v24 = icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v42, 0);
      v25 = *((unsigned __int16 *)a2 + 4);
      if ((v25 & 0x8000) != 0)
      {
        v26 = *((_DWORD *)a2 + 3);
        if (v24 == v26)
          goto LABEL_88;
      }
      else
      {
        if (v24 == v25 >> 5)
          goto LABEL_88;
        v26 = v25 >> 5;
      }
      v27 = v24 + 1;
      v42 = v24 + 1;
      if (v26 > v24)
      {
        v28 = (char *)*((_QWORD *)a2 + 3);
        if ((v25 & 2) != 0)
          v28 = (char *)a2 + 10;
        if (*(_WORD *)&v28[2 * v24] == 123)
        {
          if (v24 >= -1)
          {
            if ((v25 & 0x8000) != 0)
            {
              v30 = *((_DWORD *)a2 + 3);
              v29 = v30 >= v27 ? v24 + 1 : *((_DWORD *)a2 + 3);
            }
            else
            {
              v30 = v25 >> 5;
              v29 = v30 >= v27 ? v24 + 1 : v30;
            }
          }
          else
          {
            v29 = 0;
            v30 = (v25 & 0x8000) != 0 ? *((_DWORD *)a2 + 3) : v25 >> 5;
          }
          v34 = icu::UnicodeString::doIndexOf((uint64_t)a2, 0x7Du, v29, v30 - v29);
          v33 = 1;
          if ((v34 & 0x80000000) == 0)
            goto LABEL_57;
        }
      }
    }
LABEL_88:
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    return this;
  }
  v13 = v12 == 91;
  v14 = v8 + 1;
  v15 = v13 && v10 > v14;
  if (!v15 || *(_WORD *)&v11[2 * v14] != 58)
    goto LABEL_88;
  v42 = v8 + 2;
  v16 = icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v42, 0);
  v42 = v16;
  v17 = *((unsigned __int16 *)a2 + 4);
  v18 = v17 >> 5;
  if ((v17 & 0x8000) != 0)
  {
    v19 = *((_DWORD *)a2 + 3);
    if (v16 >= v19)
    {
      v20 = 0;
      if ((v16 & 0x80000000) == 0)
        goto LABEL_50;
LABEL_55:
      v32 = 0;
      v18 = *((_DWORD *)a2 + 3);
      goto LABEL_56;
    }
  }
  else
  {
    v19 = v17 >> 5;
    if (v16 >= (int)(v17 >> 5))
    {
      v20 = 0;
      if (v16 < 0)
        goto LABEL_54;
      goto LABEL_46;
    }
  }
  if (v19 <= v16)
    goto LABEL_43;
  v31 = (char *)*((_QWORD *)a2 + 3);
  if ((v17 & 2) != 0)
    v31 = (char *)a2 + 10;
  if (*(_WORD *)&v31[2 * v16] == 94)
  {
    v42 = ++v16;
    v20 = 1;
  }
  else
  {
LABEL_43:
    v20 = 0;
  }
  if (v16 < 0)
  {
    if ((v17 & 0x8000) == 0)
    {
LABEL_54:
      v32 = 0;
      goto LABEL_56;
    }
    goto LABEL_55;
  }
  if ((v17 & 0x8000) == 0)
  {
LABEL_46:
    if (v18 >= v16)
      v32 = v16;
    else
      v32 = v17 >> 5;
    goto LABEL_56;
  }
LABEL_50:
  v18 = *((_DWORD *)a2 + 3);
  if (v18 >= v16)
    v32 = v16;
  else
    v32 = *((_DWORD *)a2 + 3);
LABEL_56:
  v33 = 2;
  v34 = icu::UnicodeString::indexOf((uint64_t)a2, (uint64_t)L":]", 0, 2, v32, v18 - v32);
  v23 = 0;
  if ((v34 & 0x80000000) != 0)
    goto LABEL_88;
LABEL_57:
  v35 = *((unsigned __int16 *)a2 + 4);
  if ((v42 & 0x80000000) != 0)
  {
    v37 = 0;
    if ((v35 & 0x8000) != 0)
      v36 = *((_DWORD *)a2 + 3);
    else
      v36 = v35 >> 5;
  }
  else if ((v35 & 0x8000) != 0)
  {
    v36 = *((_DWORD *)a2 + 3);
    if (v36 >= (int)v42)
      v37 = v42;
    else
      v37 = *((_DWORD *)a2 + 3);
  }
  else
  {
    v36 = v35 >> 5;
    if (v36 >= v42)
      v37 = v42;
    else
      v37 = v36;
  }
  v38 = icu::UnicodeString::doIndexOf((uint64_t)a2, 0x3Du, v37, v36 - v37);
  v50 = 0u;
  v53 = 0;
  v52 = 0u;
  v51 = 0u;
  v49 = (UChar *)off_1E2256B38;
  LOWORD(v50) = 2;
  v45 = 0u;
  v48 = 0;
  v47 = 0u;
  v46 = 0u;
  v44 = (UChar *)off_1E2256B38;
  LOWORD(v45) = 2;
  if ((v38 & 0x80000000) != 0 || (v39 = v38, v38 >= v34) || v23)
  {
    (*(void (**)(const icu::UnicodeString *, _QWORD, uint64_t, UChar **))(*(_QWORD *)a2 + 24))(a2, v42, v34, &v49);
    if (v23)
    {
      icu::UnicodeString::operator=(&v44, &v49);
      icu::UnicodeString::UnicodeString(v43, "na", 2, 0);
      icu::UnicodeString::operator=((icu::UnicodeString *)&v49, (icu::UnicodeString *)v43);
      icu::UnicodeString::~UnicodeString((icu::UnicodeString *)v43);
    }
  }
  else
  {
    (*(void (**)(const icu::UnicodeString *, _QWORD, uint64_t, UChar **))(*(_QWORD *)a2 + 24))(a2, v42, v38, &v49);
    (*(void (**)(const icu::UnicodeString *, _QWORD, uint64_t, UChar **))(*(_QWORD *)a2 + 24))(a2, (v39 + 1), v34, &v44);
  }
  icu::UnicodeSet::applyPropertyAlias(this, (const icu::UnicodeString *)&v49, (const icu::UnicodeString *)&v44, a4);
  if (*(int *)a4 <= 0)
  {
    if (v20)
    {
      v40 = icu::UnicodeSet::complement(this);
      icu::UnicodeSet::removeAllStrings(v40);
    }
    *((_DWORD *)a3 + 2) = v34 + v33;
  }
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v44);
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v49);
  return this;
}

uint64_t sub_18BC511CC()
{
  void *v0;

  if (qword_1EE009600)
  {
    icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)qword_1EE009600);
    icu::UMemory::operator delete(v0);
  }
  qword_1EE009600 = 0;
  atomic_store(0, &dword_1EE009608);
  return 1;
}

uint64_t sub_18BC5120C(uint64_t a1, const icu::UnicodeSet *a2, uint64_t a3, int a4)
{
  icu::UnicodeSet *v8;
  icu::UVector **v9;
  uint64_t v10;
  unsigned int v11;
  char v12;
  uint64_t v13;
  unsigned int v14;
  UChar *v15;
  uint64_t v16;
  int v17;
  BOOL v19;
  BOOL v20;
  UErrorCode v21;
  int v22;
  int v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  UChar *v31;
  uint64_t v32;
  int v33;
  int v35;
  char *v36;
  char *v37;
  int32_t v38;
  UErrorCode v39;
  char v40;
  char *v41;
  int32_t v42;
  size_t v43;
  int v44;
  char *v45;
  unsigned int v46;
  BOOL v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  int v52;
  int v53;
  char v54;
  char **v56;
  char *v57;
  uint64_t v58;
  char *v59;
  char *v60;
  int v61;
  UErrorCode pErrorCode[2];

  v8 = (icu::UnicodeSet *)(a1 + 8);
  v9 = (icu::UVector **)icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)(a1 + 8), 0, 0x10FFFFu);
  *(_OWORD *)(a1 + 224) = 0u;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = a3;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_DWORD *)(a1 + 256) = 0;
  v56 = (char **)(a1 + 224);
  *(_BYTE *)(a1 + 260) = a4 == 63;
  icu::UnicodeSet::retainAll(v9, a2);
  if ((a4 & 1) != 0)
    *(_QWORD *)(a1 + 208) = v8;
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 216) + 8);
  if ((int)v10 < 1)
    goto LABEL_127;
  v11 = 0;
  v12 = 0;
  do
  {
    v13 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v11);
    v14 = *(unsigned __int16 *)(v13 + 8);
    if ((v14 & 0x11) != 0)
    {
      v15 = 0;
      if ((v14 & 0x8000) == 0)
        goto LABEL_10;
    }
    else if ((v14 & 2) != 0)
    {
      v15 = (UChar *)(v13 + 10);
      if ((v14 & 0x8000) == 0)
      {
LABEL_10:
        v16 = v14 >> 5;
        if (!(_DWORD)v16)
          goto LABEL_34;
        goto LABEL_14;
      }
    }
    else
    {
      v15 = *(UChar **)(v13 + 24);
      if ((v14 & 0x8000) == 0)
        goto LABEL_10;
    }
    v16 = *(unsigned int *)(v13 + 12);
    if (!(_DWORD)v16)
      goto LABEL_34;
LABEL_14:
    v17 = icu::UnicodeSet::span(v8, v15, v16, 1);
    if (v17 < (int)v16)
      v12 = 1;
    if ((a4 & 8) != 0 && (int)v16 > *(_DWORD *)(a1 + 252))
      *(_DWORD *)(a1 + 252) = v16;
    v19 = (a4 & 2) == 0 && v17 >= (int)v16;
    if ((a4 & 4) != 0 && !v19)
    {
      *(_QWORD *)pErrorCode = 0;
      u_strToUTF8(0, 0, (int32_t *)pErrorCode, v15, v16, &pErrorCode[1]);
      v20 = pErrorCode[1] == U_BUFFER_OVERFLOW_ERROR || pErrorCode[1] < U_ILLEGAL_ARGUMENT_ERROR;
      v21 = pErrorCode[0];
      if (!v20)
        v21 = U_ZERO_ERROR;
      *(_DWORD *)(a1 + 248) += v21;
      if (v21 > *(_DWORD *)(a1 + 256))
        *(_DWORD *)(a1 + 256) = v21;
    }
LABEL_34:
    ++v11;
  }
  while ((_DWORD)v10 != v11);
  if (!v12)
    goto LABEL_127;
  if (*(_BYTE *)(a1 + 260) && (icu::UnicodeSet::freeze(v8), v22 = *(unsigned __int8 *)(a1 + 260), *(_BYTE *)(a1 + 260)))
  {
    v23 = *(_DWORD *)(a1 + 248) + 8 * v10;
  }
  else
  {
    v22 = 0;
    if ((a4 & 4) != 0)
      v23 = 5 * v10 + *(_DWORD *)(a1 + 248);
    else
      v23 = v10;
  }
  if (v23 <= 128)
  {
    v24 = (char *)(a1 + 264);
    *(_QWORD *)(a1 + 224) = a1 + 264;
    if (v22)
      goto LABEL_44;
LABEL_47:
    if ((a4 & 4) != 0)
    {
      v24 += 4 * (int)v10;
      *(_QWORD *)(a1 + 240) = &v24[(int)v10];
    }
    *(_QWORD *)(a1 + 232) = v24;
    v60 = v24;
    v26 = v24;
    goto LABEL_50;
  }
  v27 = (char *)uprv_malloc(v23);
  *v56 = v27;
  if (!v27)
  {
LABEL_127:
    *(_DWORD *)(a1 + 252) = 0;
    *(_DWORD *)(a1 + 256) = 0;
    return a1;
  }
  v24 = v27;
  if (!*(_BYTE *)(a1 + 260))
    goto LABEL_47;
LABEL_44:
  v25 = &v24[4 * (int)v10];
  v24 = &v25[(int)v10];
  v60 = &v24[(int)v10];
  v26 = &v60[(int)v10];
  *(_QWORD *)(a1 + 232) = v25;
  *(_QWORD *)(a1 + 240) = &v26[(int)v10];
LABEL_50:
  v28 = 0;
  v61 = 0;
  v58 = v10;
  v59 = v24;
  v57 = v26;
  while (2)
  {
    v29 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v28);
    v30 = *(unsigned __int16 *)(v29 + 8);
    if ((v30 & 0x11) == 0)
    {
      if ((v30 & 2) != 0)
      {
        v31 = (UChar *)(v29 + 10);
        if ((v30 & 0x8000) != 0)
          goto LABEL_58;
      }
      else
      {
        v31 = *(UChar **)(v29 + 24);
        if ((v30 & 0x8000) != 0)
          goto LABEL_58;
      }
      goto LABEL_56;
    }
    v31 = 0;
    if ((v30 & 0x8000) == 0)
    {
LABEL_56:
      v32 = v30 >> 5;
      goto LABEL_59;
    }
LABEL_58:
    v32 = *(unsigned int *)(v29 + 12);
LABEL_59:
    v33 = icu::UnicodeSet::span(v8, v31, v32, 1);
    if ((int)v32 < 1 || v33 >= (int)v32)
    {
      if ((a4 & 4) != 0)
      {
        if ((a4 & 2) != 0)
        {
          v37 = (char *)(*(_QWORD *)(a1 + 240) + v61);
          v38 = *(_DWORD *)(a1 + 248) - v61;
          *(_QWORD *)pErrorCode = 0;
          u_strToUTF8(v37, v38, (int32_t *)pErrorCode, v31, v32, &pErrorCode[1]);
          if (pErrorCode[1] <= U_ZERO_ERROR)
            v39 = pErrorCode[0];
          else
            v39 = U_ZERO_ERROR;
          *(_DWORD *)(*(_QWORD *)(a1 + 224) + 4 * v28) = v39;
          v61 += v39;
        }
        else
        {
          *(_DWORD *)&(*v56)[4 * v28] = 0;
        }
      }
      if (*(_BYTE *)(a1 + 260))
      {
        v26[v28] = -1;
        v60[v28] = -1;
        v24[v28] = -1;
      }
      *(_BYTE *)(*(_QWORD *)(a1 + 232) + v28) = -1;
      goto LABEL_114;
    }
    if ((a4 & 8) != 0)
    {
      if ((a4 & 2) == 0)
      {
        LOBYTE(v35) = 0;
        v24[v28] = 0;
        v36 = *(char **)(a1 + 232);
        goto LABEL_85;
      }
      if ((a4 & 0x20) != 0)
      {
        if (v33 >= 254)
          v40 = -2;
        else
          v40 = v33;
        *(_BYTE *)(*(_QWORD *)(a1 + 232) + v28) = v40;
      }
      if ((a4 & 0x10) != 0)
      {
        v35 = v32 - icu::UnicodeSet::spanBack(v8, v31, v32, 1);
        if (v35 >= 254)
          LOBYTE(v35) = -2;
        v36 = v24;
LABEL_85:
        v36[v28] = v35;
      }
    }
    if ((a4 & 4) != 0)
    {
      v41 = (char *)(*(_QWORD *)(a1 + 240) + v61);
      v42 = *(_DWORD *)(a1 + 248) - v61;
      *(_QWORD *)pErrorCode = 0;
      u_strToUTF8(v41, v42, (int32_t *)pErrorCode, v31, v32, &pErrorCode[1]);
      if (pErrorCode[1] <= U_ZERO_ERROR)
        v43 = pErrorCode[0];
      else
        v43 = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 224) + 4 * v28) = v43;
      v61 += v43;
      if ((_DWORD)v43)
      {
        if ((a4 & 2) == 0)
        {
          LOBYTE(v44) = 0;
          v26 = v57;
          v57[v28] = 0;
          goto LABEL_94;
        }
        if ((a4 & 0x20) != 0)
        {
          v53 = icu::UnicodeSet::spanUTF8(v8, v41, v43, 1);
          if (v53 >= 254)
            v54 = -2;
          else
            v54 = v53;
          v60[v28] = v54;
        }
        if ((a4 & 0x10) == 0)
        {
          v10 = v58;
          v24 = v59;
          v26 = v57;
          if ((a4 & 1) == 0)
            goto LABEL_114;
          goto LABEL_97;
        }
        v44 = v43 - icu::UnicodeSet::spanBackUTF8(v8, (uint8_t *)v41, v43, 1);
        if (v44 >= 254)
          LOBYTE(v44) = -2;
        v26 = v57;
        v45 = v57;
      }
      else
      {
        LOBYTE(v44) = -1;
        v26 = v57;
        v57[v28] = -1;
LABEL_94:
        v45 = v60;
      }
      v10 = v58;
      v24 = v59;
      v45[v28] = v44;
    }
    if ((a4 & 1) == 0)
      goto LABEL_114;
LABEL_97:
    if ((a4 & 0x20) != 0)
    {
      v46 = *v31;
      v47 = (_DWORD)v32 != 1 && (v46 & 0xFC00) == 55296;
      if (v47)
      {
        v48 = v31[1];
        v47 = (v48 & 0xFC00) == 56320;
        v49 = (v46 << 10) - 56613888 + v48;
        if (v47)
          v46 = v49;
      }
      sub_18BC5178C(a1, v46);
    }
    if ((a4 & 0x10) != 0)
    {
      v50 = v31[(v32 - 1)];
      if (v32 >= 2 && (v50 & 0xFC00) == 0xDC00)
      {
        v51 = v31[(v32 - 2)];
        v47 = (v51 & 0xFC00) == 55296;
        v52 = v50 - 56613888 + (v51 << 10);
        if (v47)
          v50 = v52;
      }
      sub_18BC5178C(a1, v50);
    }
LABEL_114:
    if (v10 != ++v28)
      continue;
    break;
  }
  if (*(_BYTE *)(a1 + 260))
    icu::UnicodeSet::freeze(*(icu::UnicodeSet **)(a1 + 208));
  return a1;
}

icu::UnicodeSet *sub_18BC5178C(uint64_t a1, unsigned int a2)
{
  icu::UnicodeSet *result;
  BOOL v5;
  unint64_t v6;
  uint64_t *v7;

  result = *(icu::UnicodeSet **)(a1 + 208);
  if (result)
    v5 = result == (icu::UnicodeSet *)(a1 + 8);
  else
    v5 = 1;
  if (!v5)
    return icu::UnicodeSet::add(result, a2);
  result = (icu::UnicodeSet *)icu::UnicodeSet::contains((icu::UnicodeSet *)(a1 + 8), a2);
  if (!(_DWORD)result)
  {
    result = icu::UnicodeSet::cloneAsThawed((icu::UnicodeSet *)(a1 + 8), v6, v7);
    if (result)
    {
      *(_QWORD *)(a1 + 208) = result;
      return icu::UnicodeSet::add(result, a2);
    }
  }
  return result;
}

uint64_t sub_18BC51800(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v6;
  icu::UnicodeSet *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  uint64_t v12;
  size_t v13;
  char *v14;
  char *v15;

  v6 = (uint64_t *)(a2 + 8);
  v7 = icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)(a1 + 8), (const icu::UnicodeSet *)(a2 + 8));
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = a3;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  v9 = *(_QWORD *)(a2 + 248);
  *(_QWORD *)(a1 + 248) = v9;
  *(_DWORD *)(a1 + 256) = *(_DWORD *)(a2 + 256);
  *(_BYTE *)(a1 + 260) = 1;
  v10 = *(uint64_t **)(a2 + 208);
  if (v10 == v6)
  {
    v11 = v9;
  }
  else
  {
    v7 = icu::UnicodeSet::clone(*(icu::UnicodeSet **)(a2 + 208), v8, v10);
    a3 = *(_QWORD *)(a1 + 216);
    v11 = *(_DWORD *)(a1 + 248);
  }
  *(_QWORD *)(a1 + 208) = v7;
  v12 = *(int *)(a3 + 8);
  v13 = 8 * v12 + v11;
  if ((int)v13 > 128)
  {
    v14 = (char *)uprv_malloc(v13);
    *(_QWORD *)(a1 + 224) = v14;
    if (!v14)
    {
      *(_DWORD *)(a1 + 252) = 0;
      *(_DWORD *)(a1 + 256) = 0;
      return a1;
    }
  }
  else
  {
    v14 = (char *)(a1 + 264);
    *(_QWORD *)(a1 + 224) = a1 + 264;
  }
  v15 = &v14[4 * v12];
  *(_QWORD *)(a1 + 232) = v15;
  *(_QWORD *)(a1 + 240) = &v15[4 * (int)v12];
  memcpy(v14, *(const void **)(a2 + 224), v13);
  return a1;
}

_QWORD *sub_18BC518F0(_QWORD *a1)
{
  icu::UnicodeSet *v2;
  BOOL v3;
  void *v4;
  _QWORD *v5;
  BOOL v6;

  v2 = (icu::UnicodeSet *)a1[26];
  if (v2)
    v3 = v2 == (icu::UnicodeSet *)(a1 + 1);
  else
    v3 = 1;
  if (!v3)
  {
    icu::UnicodeSet::~UnicodeSet(v2);
    icu::UMemory::operator delete(v4);
  }
  v5 = (_QWORD *)a1[28];
  if (v5)
    v6 = v5 == a1 + 33;
  else
    v6 = 1;
  if (!v6)
    uprv_free(v5);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)(a1 + 1));
  return a1;
}

uint64_t sub_18BC51950(uint64_t a1, UChar *s, uint64_t a3, int a4)
{
  uint64_t v4;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  char *v12;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned __int16 *v20;
  int v21;
  BOOL v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v32;
  UChar *v33;
  int v34;
  UChar *v35;
  unsigned __int16 *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  unsigned int v42;
  unsigned __int16 *v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  UChar *v53;
  unsigned int v54;
  UChar *v55;
  unsigned __int16 *v56;
  int v57;
  UChar *v58;
  int v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  icu::UnicodeSet *v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  void *v68;
  uint64_t v69;
  _QWORD v70[4];

  v4 = a3;
  v70[3] = *MEMORY[0x1E0C80C00];
  if (!a4)
    return sub_18BC51F94(a1, (uint64_t)s, a3);
  v7 = a4;
  v64 = (icu::UnicodeSet *)(a1 + 8);
  v8 = icu::UnicodeSet::span((icu::UnicodeSet *)(a1 + 8), s);
  v9 = v4 - v8;
  if ((_DWORD)v4 == (_DWORD)v8)
    return v4;
  v10 = v8;
  memset(v70, 0, 24);
  v68 = (char *)v70 + 4;
  v69 = 0;
  if (v7 == 1)
  {
    v11 = *(_DWORD *)(a1 + 252);
    if (v11 > 16)
    {
      v12 = (char *)uprv_malloc(*(unsigned int *)(a1 + 252));
      if (v12)
      {
        v68 = v12;
        LODWORD(v69) = v11;
      }
      else
      {
        v11 = v69;
        v12 = (char *)v68;
      }
    }
    else
    {
      v11 = 16;
      LODWORD(v69) = 16;
      v12 = (char *)v70 + 4;
    }
    bzero(v12, v11);
  }
  v63 = v4;
  v67 = (int)v4;
  v14 = *(unsigned int *)(*(_QWORD *)(a1 + 216) + 8);
  v15 = v10;
  v65 = v7;
  while (1)
  {
    if (v7 == 1)
    {
      if ((int)v14 >= 1)
      {
        v16 = 0;
        while (1)
        {
          LODWORD(v17) = *(unsigned __int8 *)(*(_QWORD *)(a1 + 232) + v16);
          if ((_DWORD)v17 != 255)
            break;
LABEL_35:
          if (++v16 == v14)
            goto LABEL_99;
        }
        v18 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v16);
        v19 = *(unsigned __int16 *)(v18 + 8);
        if ((v19 & 0x11) != 0)
        {
          v20 = 0;
          if ((v19 & 0x8000) != 0)
            goto LABEL_23;
LABEL_21:
          v21 = v19 >> 5;
LABEL_24:
          if ((_DWORD)v17 == 254)
          {
            v17 = v21 - 1;
            v22 = (v20[v17] & 0xFC00) != 0xDC00 || v21 < 2;
            if (!v22 && (v20[v21 - 2] & 0xFC00) == 0xD800)
              LODWORD(v17) = v21 - 2;
          }
          if ((int)v17 >= v15)
            LODWORD(v23) = v15;
          else
            LODWORD(v23) = v17;
          v24 = v21 - v23;
          if (v21 - (int)v23 <= v9)
          {
            v25 = v21;
            v26 = v21 - 1;
            v23 = (int)v23;
            v27 = v67 - v21;
            v28 = v21 + 1;
            do
            {
              v29 = v69;
              if (LODWORD(v70[0]) + v24 < (int)v69)
                v29 = 0;
              v30 = LODWORD(v70[0]) + v24 - v29;
              if (!*((_BYTE *)v68 + v30))
              {
                v32 = (int)v10 - v23;
                v33 = &s[v32];
                v34 = v28;
                v35 = v33;
                v36 = v20;
                while (*v35 == *v36)
                {
                  ++v36;
                  ++v35;
                  if (--v34 <= 1)
                  {
                    if ((v32 < 1 || (*(v33 - 1) & 0xFC00) != 0xD800 || (*v33 & 0xFC00) != 0xDC00)
                      && (v32 >= v27 || (v33[v26] & 0xFC00) != 0xD800 || (v33[v25] & 0xFC00) != 0xDC00))
                    {
                      if (v24 == v9)
                        goto LABEL_121;
                      *((_BYTE *)v68 + v30) = 1;
                      ++HIDWORD(v69);
                    }
                    break;
                  }
                }
              }
              if (!(_DWORD)v23)
                break;
              --v23;
            }
            while (v24++ != v9);
          }
          goto LABEL_35;
        }
        if ((v19 & 2) != 0)
        {
          v20 = (unsigned __int16 *)(v18 + 10);
          if ((v19 & 0x8000) == 0)
            goto LABEL_21;
        }
        else
        {
          v20 = *(unsigned __int16 **)(v18 + 24);
          if ((v19 & 0x8000) == 0)
            goto LABEL_21;
        }
LABEL_23:
        v21 = *(_DWORD *)(v18 + 12);
        goto LABEL_24;
      }
      goto LABEL_99;
    }
    v66 = v10;
    if ((int)v14 >= 1)
    {
      v37 = 0;
      v38 = 0;
      v39 = 0;
      while (1)
      {
        v40 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 232) + v37);
        v41 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v37);
        v42 = *(unsigned __int16 *)(v41 + 8);
        if ((v42 & 0x11) != 0)
        {
          v43 = 0;
          if ((v42 & 0x8000) == 0)
            goto LABEL_63;
        }
        else if ((v42 & 2) != 0)
        {
          v43 = (unsigned __int16 *)(v41 + 10);
          if ((v42 & 0x8000) == 0)
          {
LABEL_63:
            v44 = v42 >> 5;
            if (v42 >> 5)
              goto LABEL_67;
            goto LABEL_91;
          }
        }
        else
        {
          v43 = *(unsigned __int16 **)(v41 + 24);
          if ((v42 & 0x8000) == 0)
            goto LABEL_63;
        }
        v44 = *(_DWORD *)(v41 + 12);
        if (v44)
        {
LABEL_67:
          if (v40 <= 0xFD)
            LODWORD(v45) = v40;
          else
            LODWORD(v45) = v44;
          if ((int)v45 >= v15)
            LODWORD(v45) = v15;
          v46 = v44 - v45;
          if ((int)v46 <= v9 && (int)v45 >= v38)
          {
            v48 = (int)v44;
            v49 = (int)v44 - 1;
            v45 = (int)v45;
            v50 = v67 - (int)v44;
            v51 = v44 + 1;
            do
            {
              if (v45 > v38 || (int)v46 > (int)v39)
              {
                v52 = (int)v66 - v45;
                v53 = &s[v52];
                v54 = v51;
                v55 = v53;
                v56 = v43;
                while (*v55 == *v56)
                {
                  ++v56;
                  ++v55;
                  if ((int)--v54 <= 1)
                  {
                    if ((v52 < 1 || (*(v53 - 1) & 0xFC00) != 0xD800 || (*v53 & 0xFC00) != 0xDC00)
                      && (v52 >= v50 || (v53[v49] & 0xFC00) != 0xD800 || (v53[v48] & 0xFC00) != 0xDC00))
                    {
                      v38 = v45;
                      goto LABEL_92;
                    }
                    break;
                  }
                }
              }
              if ((int)v46 >= v9)
                break;
              v46 = (v46 + 1);
              v22 = v45-- <= v38;
            }
            while (!v22);
          }
        }
LABEL_91:
        v46 = v39;
LABEL_92:
        ++v37;
        v39 = v46;
        if (v37 == v14)
          goto LABEL_96;
      }
    }
    LODWORD(v46) = 0;
    v38 = 0;
LABEL_96:
    v57 = v46 | v38;
    v7 = v65;
    v10 = v66;
    if (v57)
    {
      v9 -= v46;
      if (!v9)
        goto LABEL_121;
      v15 = 0;
      goto LABEL_120;
    }
LABEL_99:
    if (v15 || !(_DWORD)v10)
    {
      if (!HIDWORD(v69))
      {
        v4 = v10;
        goto LABEL_122;
      }
LABEL_108:
      LODWORD(v46) = sub_18BC521A8((unsigned __int8 **)&v68);
      v15 = 0;
      v9 -= v46;
      goto LABEL_120;
    }
    v58 = &s[(int)v10];
    if (HIDWORD(v69))
      break;
    LODWORD(v46) = icu::UnicodeSet::span(v64, &s[(int)v10]);
    v9 -= v46;
    if (!v9 || !(_DWORD)v46)
    {
      v4 = (v46 + v10);
      goto LABEL_122;
    }
    v15 = v46;
LABEL_120:
    v10 = (v46 + v10);
  }
  v59 = *v58;
  if (v9 >= 2 && (v59 & 0xFC00) == 0xD800 && (v60 = v58[1], (v60 & 0xFC00) == 0xDC00))
  {
    if (!icu::UnicodeSet::contains(v64, v60 + (v59 << 10) - 56613888))
      goto LABEL_108;
    LODWORD(v46) = 2;
  }
  else
  {
    if (!icu::UnicodeSet::contains(v64, v59))
      goto LABEL_108;
    LODWORD(v46) = 1;
  }
  v9 -= v46;
  if (v9)
  {
    v61 = v69;
    if (LODWORD(v70[0]) + (int)v46 < (int)v69)
      v61 = 0;
    v62 = LODWORD(v70[0]) + v46 - v61;
    if (*((_BYTE *)v68 + v62))
    {
      *((_BYTE *)v68 + v62) = 0;
      --HIDWORD(v69);
    }
    v15 = 0;
    LODWORD(v70[0]) = v62;
    goto LABEL_120;
  }
LABEL_121:
  v4 = v63;
LABEL_122:
  if (v68 != (char *)v70 + 4)
    uprv_free(v68);
  return v4;
}

uint64_t sub_18BC51F94(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v3;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned __int16 *v11;
  int v12;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned __int16 *v19;
  int v20;
  int v21;
  unsigned __int16 *v22;
  icu::UnicodeSet *v25;

  v3 = a3;
  v6 = 0;
  v7 = *(unsigned int *)(*(_QWORD *)(a1 + 216) + 8);
  v25 = (icu::UnicodeSet *)(a1 + 8);
  while (1)
  {
    v8 = icu::UnicodeSet::span(*(icu::UnicodeSet **)(a1 + 208), (UChar *)(a2 + 2 * v6));
    v9 = v3 - v8;
    if (v3 == v8)
      return a3;
    v10 = (v8 + v6);
    v11 = (unsigned __int16 *)(a2 + 2 * (int)v10);
    v12 = *v11;
    if (v9 < 2 || (v12 & 0xFC00) != 55296)
      break;
    v14 = v11[1];
    if ((v14 & 0xFC00) != 0xDC00)
      break;
    if (icu::UnicodeSet::contains(v25, v14 + (v12 << 10) - 56613888))
      return v10;
    v15 = -2;
LABEL_13:
    if ((int)v7 >= 1)
    {
      v16 = 0;
      while (*(unsigned __int8 *)(*(_QWORD *)(a1 + 232) + v16) == 255)
      {
LABEL_34:
        if (++v16 == v7)
          goto LABEL_35;
      }
      v17 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v16);
      v18 = *(unsigned __int16 *)(v17 + 8);
      if ((v18 & 0x11) != 0)
      {
        v19 = 0;
        if ((v18 & 0x8000) != 0)
        {
LABEL_23:
          v20 = *(_DWORD *)(v17 + 12);
LABEL_24:
          if (v20 <= v9)
          {
            v21 = v20 + 1;
            v22 = (unsigned __int16 *)(a2 + 2 * (int)v10);
            while (*v22 == *v19)
            {
              ++v19;
              ++v22;
              if (--v21 <= 1)
              {
                if (((int)v10 < 1 || (*(v11 - 1) & 0xFC00) != 0xD800 || (*v11 & 0xFC00) != 0xDC00)
                  && ((int)(a3 - v10) <= v20 || (v11[v20 - 1] & 0xFC00) != 0xD800 || (v11[v20] & 0xFC00) != 0xDC00))
                {
                  return v10;
                }
                goto LABEL_34;
              }
            }
          }
          goto LABEL_34;
        }
      }
      else if ((v18 & 2) != 0)
      {
        v19 = (unsigned __int16 *)(v17 + 10);
        if ((v18 & 0x8000) != 0)
          goto LABEL_23;
      }
      else
      {
        v19 = *(unsigned __int16 **)(v17 + 24);
        if ((v18 & 0x8000) != 0)
          goto LABEL_23;
      }
      v20 = v18 >> 5;
      goto LABEL_24;
    }
LABEL_35:
    v6 = v10 - v15;
    v3 = v15 + v9;
    if (!(v15 + v9))
      return a3;
  }
  if (!icu::UnicodeSet::contains(v25, v12))
  {
    v15 = -1;
    goto LABEL_13;
  }
  return v10;
}

uint64_t sub_18BC521A8(unsigned __int8 **a1)
{
  int v1;
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  int v8;
  int v9;

  v1 = *((_DWORD *)a1 + 4);
  v2 = *((int *)a1 + 2);
  v3 = *a1;
  v4 = v1;
  while (1)
  {
    v5 = v4 + 1;
    if (v4 + 1 >= v2)
      break;
    if (v3[++v4])
    {
      v3[v5] = 0;
      v7 = (v5 - *((_DWORD *)a1 + 4));
      --*((_DWORD *)a1 + 3);
      *((_DWORD *)a1 + 4) = v5;
      return v7;
    }
  }
  v8 = -1;
  do
  {
    v9 = *v3++;
    ++v8;
  }
  while (!v9);
  *(v3 - 1) = 0;
  --*((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 4) = v8;
  return (v2 - v1 + v8);
}

uint64_t sub_18BC5221C(uint64_t a1, UChar *s, int a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  char *v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned __int16 *v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  int v31;
  char *v32;
  uint64_t v33;
  UChar *v34;
  unsigned int v35;
  UChar *v36;
  unsigned __int16 *v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  unsigned int v42;
  unsigned __int16 *v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  UChar *v53;
  unsigned int v54;
  UChar *v55;
  unsigned __int16 *v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  icu::UnicodeSet *v64;
  int v66;
  uint64_t v67;
  void *v68;
  uint64_t v69;
  _QWORD v70[4];

  v70[3] = *MEMORY[0x1E0C80C00];
  if (!a4)
    return sub_18BC52874(a1, s, a3);
  v64 = (icu::UnicodeSet *)(a1 + 8);
  v7 = icu::UnicodeSet::spanBack((icu::UnicodeSet *)(a1 + 8), s);
  if (!(_DWORD)v7)
    return 0;
  v8 = v7;
  v9 = a3 - v7;
  memset(v70, 0, 24);
  v68 = (char *)v70 + 4;
  v69 = 0;
  if (a4 == 1)
  {
    v10 = *(_DWORD *)(a1 + 252);
    if (v10 > 16)
    {
      v11 = (char *)uprv_malloc(*(unsigned int *)(a1 + 252));
      if (v11)
      {
        v68 = v11;
        LODWORD(v69) = v10;
      }
      else
      {
        v10 = v69;
        v11 = (char *)v68;
      }
    }
    else
    {
      v10 = 16;
      LODWORD(v69) = 16;
      v11 = (char *)v70 + 4;
    }
    bzero(v11, v10);
  }
  v14 = *(unsigned int *)(*(_QWORD *)(a1 + 216) + 8);
  if (*(_BYTE *)(a1 + 260))
    v15 = (int)v14;
  else
    v15 = 0;
  v67 = a1;
  v16 = *(_QWORD *)(a1 + 232) + v15;
  while (1)
  {
    while (a4 != 1)
    {
      if ((int)v14 >= 1)
      {
        v38 = 0;
        v39 = 0;
        v66 = 0;
        while (1)
        {
          v40 = *(unsigned __int8 *)(v16 + v38);
          v41 = icu::UVector::elementAt(*(icu::UVector **)(v67 + 216), v38);
          v42 = *(unsigned __int16 *)(v41 + 8);
          if ((v42 & 0x11) != 0)
          {
            v43 = 0;
            if ((v42 & 0x8000) == 0)
              goto LABEL_66;
          }
          else if ((v42 & 2) != 0)
          {
            v43 = (unsigned __int16 *)(v41 + 10);
            if ((v42 & 0x8000) == 0)
            {
LABEL_66:
              v44 = v42 >> 5;
              if (v42 >> 5)
                goto LABEL_70;
              goto LABEL_95;
            }
          }
          else
          {
            v43 = *(unsigned __int16 **)(v41 + 24);
            if ((v42 & 0x8000) == 0)
              goto LABEL_66;
          }
          v44 = *(_DWORD *)(v41 + 12);
          if (v44)
          {
LABEL_70:
            if (v40 <= 0xFD)
              LODWORD(v45) = v40;
            else
              LODWORD(v45) = v44;
            if ((int)v45 >= v9)
              v45 = v9;
            else
              v45 = v45;
            LODWORD(v46) = v44 - v45;
            v47 = (int)(v44 - v45) > (int)v8 || (int)v45 < (int)v39;
            if (!v47)
            {
              v48 = (int)v44;
              v49 = (int)v44 - 1;
              v46 = (int)v46;
              v50 = a3 - (uint64_t)(int)v44;
              v51 = v44 + 1;
              do
              {
                if ((int)v45 > (int)v39 || v46 > v66)
                {
                  v52 = (int)v8 - v46;
                  v53 = &s[v52];
                  v54 = v51;
                  v55 = v53;
                  v56 = v43;
                  while (*v55 == *v56)
                  {
                    ++v56;
                    ++v55;
                    if ((int)--v54 <= 1)
                    {
                      if ((v52 < 1 || (*(v53 - 1) & 0xFC00) != 0xD800 || (*v53 & 0xFC00) != 0xDC00)
                        && (v52 >= v50 || (v53[v49] & 0xFC00) != 0xD800 || (v53[v48] & 0xFC00) != 0xDC00))
                      {
                        v66 = v46;
                        goto LABEL_96;
                      }
                      break;
                    }
                  }
                }
                if ((int)v8 <= v46)
                  break;
                ++v46;
                v47 = (int)v45 <= (int)v39;
                v45 = (v45 - 1);
              }
              while (!v47);
            }
          }
LABEL_95:
          v45 = v39;
LABEL_96:
          ++v38;
          v39 = v45;
          if (v38 == v14)
            goto LABEL_100;
        }
      }
      v66 = 0;
      LODWORD(v45) = 0;
LABEL_100:
      if (!(v66 | v45))
        goto LABEL_103;
      v9 = 0;
      v13 = 0;
      v8 = (v8 - v66);
      if (!(_DWORD)v8)
        goto LABEL_131;
    }
    if ((int)v14 >= 1)
    {
      v17 = 0;
      while (1)
      {
        v18 = *(unsigned __int8 *)(v16 + v17);
        if (v18 != 255)
          break;
LABEL_39:
        if (++v17 == v14)
          goto LABEL_103;
      }
      v19 = icu::UVector::elementAt(*(icu::UVector **)(v67 + 216), v17);
      v20 = *(unsigned __int16 *)(v19 + 8);
      if ((v20 & 0x11) != 0)
      {
        v21 = 0;
        if ((v20 & 0x8000) != 0)
          goto LABEL_27;
LABEL_25:
        v22 = v20 >> 5;
        goto LABEL_28;
      }
      if ((v20 & 2) != 0)
      {
        v21 = (unsigned __int16 *)(v19 + 10);
        if ((v20 & 0x8000) == 0)
          goto LABEL_25;
      }
      else
      {
        v21 = *(unsigned __int16 **)(v19 + 24);
        if ((v20 & 0x8000) == 0)
          goto LABEL_25;
      }
LABEL_27:
      v22 = *(_DWORD *)(v19 + 12);
LABEL_28:
      if (v18 == 254)
      {
        v23 = -1;
        if ((*v21 & 0xFC00) == 0xD800 && v22 != 1)
        {
          if ((v21[1] & 0xFC00) == 0xDC00)
            v23 = -2;
          else
            v23 = -1;
        }
        v18 = v23 + v22;
      }
      if (v18 >= v9)
        v24 = v9;
      else
        v24 = v18;
      LODWORD(v25) = v22 - v24;
      if ((int)(v22 - v24) <= (int)v8)
      {
        v26 = (int)v22;
        v27 = (int)v22 - 1;
        v25 = (int)v25;
        v28 = a3 - (uint64_t)(int)v22;
        v29 = v22 + 1;
        do
        {
          v30 = v69;
          if (LODWORD(v70[0]) + (int)v25 < (int)v69)
            v30 = 0;
          v31 = LODWORD(v70[0]) + v25 - v30;
          v32 = (char *)v68;
          if (!*((_BYTE *)v68 + v31))
          {
            v33 = (int)v8 - v25;
            v34 = &s[v33];
            v35 = v29;
            v36 = v34;
            v37 = v21;
            while (*v36 == *v37)
            {
              ++v37;
              ++v36;
              if ((int)--v35 <= 1)
              {
                if (v33 >= 1 && (*(v34 - 1) & 0xFC00) == 0xD800 && (*v34 & 0xFC00) == 0xDC00
                  || v33 < v28 && (v34[v27] & 0xFC00) == 0xD800 && (v34[v26] & 0xFC00) == 0xDC00)
                {
                  break;
                }
                if ((_DWORD)v8 != (_DWORD)v25)
                {
                  *((_BYTE *)v68 + v31) = 1;
                  ++HIDWORD(v69);
                  break;
                }
                v13 = 0;
                goto LABEL_126;
              }
            }
          }
          if (!v24)
            break;
          --v24;
          ++v25;
        }
        while ((_DWORD)v8 + 1 != (_DWORD)v25);
      }
      goto LABEL_39;
    }
LABEL_103:
    if (v9 || (_DWORD)v8 == a3)
      break;
    if (HIDWORD(v69))
    {
      v57 = s[(int)v8 - 1];
      if ((int)v8 >= 2 && (v57 & 0xFC00) == 0xDC00 && (v58 = s[(v8 - 2)], (v58 & 0xFC00) == 0xD800))
      {
        if (icu::UnicodeSet::contains(v64, v57 + (v58 << 10) - 56613888))
        {
          v59 = 2;
          goto LABEL_115;
        }
LABEL_112:
        v9 = 0;
        v8 = v8 - sub_18BC521A8((unsigned __int8 **)&v68);
      }
      else
      {
        if (!icu::UnicodeSet::contains(v64, v57))
          goto LABEL_112;
        v59 = 1;
LABEL_115:
        v8 = (v8 - v59);
        if (!(_DWORD)v8)
        {
          v13 = 0;
          goto LABEL_131;
        }
        v60 = LODWORD(v70[0]) + v59;
        if (v60 >= (int)v69)
          v61 = v69;
        else
          v61 = 0;
        v62 = v60 - v61;
        if (*((_BYTE *)v68 + v62))
        {
          *((_BYTE *)v68 + v62) = 0;
          --HIDWORD(v69);
        }
        v9 = 0;
        LODWORD(v70[0]) = v62;
      }
    }
    else
    {
      v63 = icu::UnicodeSet::spanBack(v64, s);
      v13 = v63;
      if (!(_DWORD)v63)
        goto LABEL_131;
      v9 = v8 - v63;
      v8 = v63;
      if (!v9)
        goto LABEL_131;
    }
  }
  if (HIDWORD(v69))
    goto LABEL_112;
  v13 = v8;
LABEL_131:
  v32 = (char *)v68;
LABEL_126:
  if (v32 != (char *)v70 + 4)
    uprv_free(v32);
  return v13;
}

uint64_t sub_18BC52874(uint64_t a1, UChar *s, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int16 *v16;
  int v17;
  int v18;
  UChar *v19;
  int v20;
  UChar *v21;
  icu::UnicodeSet *v23;

  v23 = (icu::UnicodeSet *)(a1 + 8);
  v6 = *(unsigned int *)(*(_QWORD *)(a1 + 216) + 8);
  do
  {
    v7 = icu::UnicodeSet::spanBack(*(icu::UnicodeSet **)(a1 + 208), s);
    v8 = v7;
    if (!(_DWORD)v7)
      return v8;
    v9 = s[(int)v7 - 1];
    v10 = (int)v7 >= 2 && (v9 & 0xFC00) == 56320;
    if (v10 && (v11 = s[(v7 - 2)], (v11 & 0xFC00) == 0xD800))
    {
      if (icu::UnicodeSet::contains(v23, v9 + (v11 << 10) - 56613888))
        return v8;
      v12 = -2;
    }
    else
    {
      if (icu::UnicodeSet::contains(v23, v9))
        return v8;
      v12 = -1;
    }
    if ((int)v6 >= 1)
    {
      v13 = 0;
      while (*(unsigned __int8 *)(*(_QWORD *)(a1 + 232) + v13) == 255)
      {
LABEL_34:
        if (++v13 == v6)
          goto LABEL_35;
      }
      v14 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v13);
      v15 = *(unsigned __int16 *)(v14 + 8);
      if ((v15 & 0x11) != 0)
      {
        v16 = 0;
        if ((v15 & 0x8000) != 0)
          goto LABEL_23;
LABEL_21:
        v17 = v15 >> 5;
        goto LABEL_24;
      }
      if ((v15 & 2) != 0)
      {
        v16 = (unsigned __int16 *)(v14 + 10);
        if ((v15 & 0x8000) == 0)
          goto LABEL_21;
      }
      else
      {
        v16 = *(unsigned __int16 **)(v14 + 24);
        if ((v15 & 0x8000) == 0)
          goto LABEL_21;
      }
LABEL_23:
      v17 = *(_DWORD *)(v14 + 12);
LABEL_24:
      v18 = v8 - v17;
      if ((int)v8 >= v17)
      {
        v19 = &s[v18];
        v20 = v17 + 1;
        v21 = v19;
        while (*v21 == *v16)
        {
          ++v16;
          ++v21;
          if (--v20 <= 1)
          {
            if ((v18 < 1 || (*(v19 - 1) & 0xFC00) != 0xD800 || (*v19 & 0xFC00) != 0xDC00)
              && (a3 - v18 <= v17 || (v19[v17 - 1] & 0xFC00) != 0xD800 || (v19[v17] & 0xFC00) != 0xDC00))
            {
              return v8;
            }
            goto LABEL_34;
          }
        }
      }
      goto LABEL_34;
    }
LABEL_35:
    ;
  }
  while (v12 + (_DWORD)v8);
  return 0;
}

uint64_t sub_18BC52A60(uint64_t a1, char *__s, uint64_t a3, int a4)
{
  uint64_t i;
  uint64_t v6;
  signed int v7;
  uint64_t v8;
  int v9;
  char *v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const uint8_t *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  int32_t v20;
  int32_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  char *v26;
  int v27;
  const uint8_t *v28;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  char *v38;
  int v39;
  const uint8_t *v40;
  unsigned __int8 *v41;
  int v42;
  int v43;
  unsigned int v44;
  icu::UnicodeSet *v45;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  _QWORD v51[4];

  i = a3;
  v51[3] = *MEMORY[0x1E0C80C00];
  if (!a4)
    return sub_18BC52F18(a1, (uint64_t)__s, a3);
  v45 = (icu::UnicodeSet *)(a1 + 8);
  v6 = icu::UnicodeSet::spanUTF8((icu::UnicodeSet *)(a1 + 8), __s);
  v7 = i - v6;
  if ((_DWORD)i == (_DWORD)v6)
    return i;
  v8 = v6;
  memset(v51, 0, 24);
  v49 = (char *)v51 + 4;
  v50 = 0;
  if (a4 == 1)
  {
    v9 = *(_DWORD *)(a1 + 256);
    if (v9 > 16)
    {
      v10 = (char *)uprv_malloc(*(unsigned int *)(a1 + 256));
      if (v10)
      {
        v49 = v10;
        LODWORD(v50) = v9;
      }
      else
      {
        v9 = v50;
        v10 = (char *)v49;
      }
    }
    else
    {
      v9 = 16;
      LODWORD(v50) = 16;
      v10 = (char *)v51 + 4;
    }
    bzero(v10, v9);
  }
  v44 = i;
  v12 = a1;
  v13 = *(unsigned int *)(*(_QWORD *)(a1 + 216) + 8);
  v14 = 2 * (int)v13;
  if (!*(_BYTE *)(a1 + 260))
    v14 = 0;
  v15 = *(_QWORD *)(a1 + 232) + v14;
  for (i = v8; ; i = (v32 + i))
  {
    v16 = *(const uint8_t **)(v12 + 240);
    v48 = i;
    if (a4 == 1)
      break;
    if ((int)v13 < 1)
    {
      LODWORD(v32) = 0;
      v31 = 0;
    }
    else
    {
      v30 = 0;
      v31 = 0;
      v32 = 0;
      do
      {
        v33 = *(int *)(*(_QWORD *)(v12 + 224) + 4 * v30);
        if ((_DWORD)v33)
        {
          v34 = *(unsigned __int8 *)(v15 + v30);
          if (v34 > 0xFD)
            v34 = *(_DWORD *)(*(_QWORD *)(v12 + 224) + 4 * v30);
          if (v34 >= (int)v8)
            LODWORD(v35) = v8;
          else
            LODWORD(v35) = v34;
          v36 = (v33 - v35);
          v37 = (int)v36 > v7 || (int)v35 < v31;
          if (!v37)
          {
            v35 = (int)v35;
            do
            {
              if (__s[(int)i - v35] >= -64 && (v35 > v31 || (int)v36 > (int)v32))
              {
                v38 = &__s[(int)i - v35];
                v39 = v33 + 1;
                v40 = v16;
                while (*v38 == *v40)
                {
                  ++v40;
                  ++v38;
                  if (--v39 <= 1)
                  {
                    v31 = v35;
                    goto LABEL_67;
                  }
                }
              }
              if ((int)v36 >= v7)
                break;
              v36 = (v36 + 1);
              v37 = v35-- <= v31;
            }
            while (!v37);
          }
          v36 = v32;
LABEL_67:
          v16 += v33;
          v32 = v36;
        }
        ++v30;
      }
      while (v30 != v13);
    }
    if (!(v32 | v31))
      goto LABEL_72;
    v7 -= v32;
    if (!v7)
    {
LABEL_90:
      i = v44;
      goto LABEL_91;
    }
    LODWORD(v8) = 0;
LABEL_89:
    ;
  }
  if ((int)v13 >= 1)
  {
    v17 = 0;
    v18 = &__s[(int)i];
    do
    {
      v19 = *(int *)(*(_QWORD *)(v12 + 224) + 4 * v17);
      if ((_DWORD)v19)
      {
        v20 = *(unsigned __int8 *)(v15 + v17);
        if (v20 != 255)
        {
          if (v20 == 254)
          {
            v20 = v19 - 1;
            if ((char)v16[v19 - 1] <= -65)
            {
              v21 = utf8_back1SafeBody(v16, 0, v20);
              v12 = a1;
              v20 = v21;
            }
          }
          LODWORD(v22) = v20 >= (int)v8 ? v8 : v20;
          v23 = v19 - v22;
          if ((int)v19 - (int)v22 <= v7)
          {
            v22 = (int)v22;
            do
            {
              if (__s[(int)v48 - v22] >= -64)
              {
                v24 = v50;
                if (LODWORD(v51[0]) + v23 < (int)v50)
                  v24 = 0;
                v25 = LODWORD(v51[0]) + v23 - v24;
                if (!*((_BYTE *)v49 + v25))
                {
                  v26 = &v18[-v22];
                  v27 = v19 + 1;
                  v28 = v16;
                  while (*v26 == *v28)
                  {
                    ++v28;
                    ++v26;
                    if (--v27 <= 1)
                    {
                      if (v23 == v7)
                        goto LABEL_90;
                      *((_BYTE *)v49 + v25) = 1;
                      ++HIDWORD(v50);
                      break;
                    }
                  }
                }
              }
              if (!(_DWORD)v22)
                break;
              --v22;
            }
            while (v23++ != v7);
          }
        }
        v16 += v19;
      }
      ++v17;
    }
    while (v17 != v13);
  }
LABEL_72:
  i = v48;
  if ((_DWORD)v8 || !(_DWORD)v48)
  {
    if (!HIDWORD(v50))
      goto LABEL_91;
LABEL_83:
    LODWORD(v32) = sub_18BC521A8((unsigned __int8 **)&v49);
    LODWORD(v8) = 0;
    v7 -= v32;
LABEL_88:
    v12 = a1;
    goto LABEL_89;
  }
  v41 = (unsigned __int8 *)&__s[(int)v48];
  if (HIDWORD(v50))
  {
    LODWORD(v32) = sub_18BC53058(v45, v41, v7);
    if ((int)v32 >= 1)
    {
      v7 -= v32;
      if (!v7)
        goto LABEL_90;
      v42 = v50;
      if (LODWORD(v51[0]) + (int)v32 < (int)v50)
        v42 = 0;
      v43 = LODWORD(v51[0]) + v32 - v42;
      if (*((_BYTE *)v49 + v43))
      {
        *((_BYTE *)v49 + v43) = 0;
        --HIDWORD(v50);
      }
      LODWORD(v8) = 0;
      LODWORD(v51[0]) = v43;
      goto LABEL_88;
    }
    goto LABEL_83;
  }
  LODWORD(v32) = icu::UnicodeSet::spanUTF8(v45, (char *)v41);
  LODWORD(v8) = v32;
  v7 -= v32;
  if (v7 && (_DWORD)v32)
    goto LABEL_88;
  i = (v32 + v48);
LABEL_91:
  if (v49 != (char *)v51 + 4)
    uprv_free(v49);
  return i;
}

uint64_t sub_18BC52F18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  icu::UnicodeSet *v10;
  int v11;
  int v12;
  signed int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  int v19;
  unsigned __int8 *v20;
  unsigned __int8 *i;

  v3 = a3;
  v6 = 0;
  v7 = *(unsigned int *)(*(_QWORD *)(a1 + 216) + 8);
  v8 = 2 * (int)v7;
  if (!*(_BYTE *)(a1 + 260))
    v8 = 0;
  v9 = *(_QWORD *)(a1 + 232) + v8;
  v10 = (icu::UnicodeSet *)(a1 + 8);
  v11 = a3;
  do
  {
    v12 = icu::UnicodeSet::spanUTF8(*(icu::UnicodeSet **)(a1 + 208), (char *)(a2 + v6));
    v13 = v11 - v12;
    if (!v13)
      break;
    v14 = v6 + (uint64_t)v12;
    v15 = sub_18BC53058(v10, (unsigned __int8 *)(a2 + v14), v13);
    if (v15 > 0)
      return v14;
    if ((int)v7 >= 1)
    {
      v16 = 0;
      v17 = *(unsigned __int8 **)(a1 + 240);
      do
      {
        v18 = *(int *)(*(_QWORD *)(a1 + 224) + 4 * v16);
        if ((_DWORD)v18 && (int)v18 <= v13 && *(unsigned __int8 *)(v9 + v16) != 255)
        {
          v19 = v18 + 1;
          v20 = (unsigned __int8 *)(a2 + v14);
          for (i = v17; *v20 == *i; ++i)
          {
            ++v20;
            if (--v19 <= 1)
              return v14;
          }
        }
        v17 += v18;
        ++v16;
      }
      while (v16 != v7);
    }
    v6 = v14 - v15;
    v11 = v15 + v13;
  }
  while (v11);
  return v3;
}

uint64_t sub_18BC53058(icu::UnicodeSet *a1, unsigned __int8 *a2, unsigned int a3)
{
  int v3;
  unsigned int v4;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unint64_t v14;

  v3 = (char)*a2;
  v4 = *a2;
  if ((v3 & 0x80000000) == 0)
  {
    if (icu::UnicodeSet::contains(a1, *a2))
      return 1;
    else
      return 0xFFFFFFFFLL;
  }
  v6 = a3;
  if (a3 == 1)
    goto LABEL_22;
  if (v4 < 0xE0)
  {
    if (v4 >= 0xC2)
    {
      v10 = v4 & 0x1F;
      v9 = 1;
LABEL_14:
      v11 = a2[v9] ^ 0x80;
      if (v11 > 0x3F)
      {
        v12 = 65533;
        v6 = v9;
      }
      else
      {
        v12 = v11 | (v10 << 6);
        v6 = v9 + 1;
      }
      goto LABEL_23;
    }
    goto LABEL_21;
  }
  if (v4 <= 0xEF)
  {
    v7 = v3 & 0xF;
    if (((a00000000000000[v3 & 0xF] >> (a2[1] >> 5)) & 1) != 0)
    {
      v8 = a2[1] & 0x3F;
      v9 = 2;
      goto LABEL_10;
    }
LABEL_21:
    v6 = 1;
    goto LABEL_22;
  }
  if (v4 > 0xF4)
    goto LABEL_21;
  v13 = v4 - 240;
  v14 = a2[1];
  if (((byte_18BE15273[v14 >> 4] >> v13) & 1) == 0)
    goto LABEL_21;
  if (a3 == 2)
    goto LABEL_22;
  v8 = a2[2] ^ 0x80;
  if (v8 > 0x3F)
  {
    v6 = 2;
    goto LABEL_22;
  }
  v7 = v14 & 0x3F | (v13 << 6);
  v9 = 3;
LABEL_10:
  if (v9 != a3)
  {
    v10 = v8 | (v7 << 6);
    goto LABEL_14;
  }
LABEL_22:
  v12 = 65533;
LABEL_23:
  if (icu::UnicodeSet::contains(a1, v12))
    return v6;
  else
    return -v6;
}

uint64_t sub_18BC5318C(uint64_t a1, uint8_t *s, int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  char *v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  unsigned int v23;
  unint64_t v24;
  BOOL v25;
  uint64_t v26;
  int v27;
  int v28;
  char *v29;
  uint8_t *v30;
  int v31;
  unsigned __int8 *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint8_t *v40;
  int v41;
  unsigned __int8 *v42;
  uint64_t v43;
  UChar32 v44;
  int v45;
  uint64_t v46;
  UChar32 v47;
  int v48;
  int v49;
  int v50;
  int v51;
  icu::UnicodeSet *v52;
  int32_t pi;
  void *v54;
  uint64_t v55;
  _QWORD v56[4];

  v56[3] = *MEMORY[0x1E0C80C00];
  if (!a4)
    return sub_18BC53748(a1, s);
  v52 = (icu::UnicodeSet *)(a1 + 8);
  v8 = icu::UnicodeSet::spanBackUTF8((icu::UnicodeSet *)(a1 + 8), s);
  if (!(_DWORD)v8)
    return 0;
  v9 = v8;
  v10 = a3 - v8;
  memset(v56, 0, 24);
  v54 = (char *)v56 + 4;
  v55 = 0;
  if (a4 == 1)
  {
    v11 = *(_DWORD *)(a1 + 256);
    if (v11 > 16)
    {
      v12 = (char *)uprv_malloc(*(unsigned int *)(a1 + 256));
      if (v12)
      {
        v54 = v12;
        LODWORD(v55) = v11;
      }
      else
      {
        v11 = v55;
        v12 = (char *)v54;
      }
    }
    else
    {
      v11 = 16;
      LODWORD(v55) = 16;
      v12 = (char *)v56 + 4;
    }
    bzero(v12, v11);
  }
  v15 = *(unsigned int *)(*(_QWORD *)(a1 + 216) + 8);
  v16 = 3 * (int)v15;
  if (!*(_BYTE *)(a1 + 260))
    v16 = 0;
  v17 = *(_QWORD *)(a1 + 232) + v16;
  while (1)
  {
    while (1)
    {
      v18 = *(unsigned __int8 **)(a1 + 240);
      if (a4 == 1)
        break;
      if ((int)v15 < 1)
      {
        v35 = 0;
        LODWORD(v34) = 0;
      }
      else
      {
        v33 = 0;
        v34 = 0;
        v35 = 0;
        do
        {
          v36 = *(int *)(*(_QWORD *)(a1 + 224) + 4 * v33);
          if ((_DWORD)v36)
          {
            LODWORD(v37) = *(unsigned __int8 *)(v17 + v33);
            if (v37 > 0xFD)
              LODWORD(v37) = *(_DWORD *)(*(_QWORD *)(a1 + 224) + 4 * v33);
            if ((int)v37 >= v10)
              v37 = v10;
            else
              v37 = v37;
            LODWORD(v38) = v36 - v37;
            if ((int)v36 - (int)v37 <= (int)v9 && (int)v37 >= (int)v34)
            {
              v38 = (int)v38;
              do
              {
                if ((char)s[(int)v9 - v38] >= -64 && ((int)v37 > (int)v34 || v38 > v35))
                {
                  v40 = &s[(int)v9 - v38];
                  v41 = v36 + 1;
                  v42 = v18;
                  while (*v40 == *v42)
                  {
                    ++v42;
                    ++v40;
                    if (--v41 <= 1)
                    {
                      v35 = v38;
                      goto LABEL_86;
                    }
                  }
                }
                if ((int)v9 <= v38)
                  break;
                ++v38;
                v25 = (int)v37 <= (int)v34;
                v37 = (v37 - 1);
              }
              while (!v25);
            }
            v37 = v34;
LABEL_86:
            v18 += v36;
            v34 = v37;
          }
          ++v33;
        }
        while (v33 != v15);
      }
      if (!(v35 | v34))
        goto LABEL_91;
      v10 = 0;
      v14 = 0;
      v9 = (v9 - v35);
      if (!(_DWORD)v9)
        goto LABEL_118;
    }
    if ((int)v15 >= 1)
    {
      v19 = 0;
      while (1)
      {
        v20 = *(int *)(*(_QWORD *)(a1 + 224) + 4 * v19);
        if ((_DWORD)v20)
          break;
LABEL_58:
        if (++v19 == v15)
          goto LABEL_91;
      }
      v21 = *(unsigned __int8 *)(v17 + v19);
      if (v21 == 255)
      {
LABEL_57:
        v18 += v20;
        goto LABEL_58;
      }
      if (v21 != 254)
      {
LABEL_42:
        if (v21 >= v10)
          v21 = v10;
        LODWORD(v26) = v20 - v21;
        if ((int)v20 - v21 <= (int)v9)
        {
          v26 = (int)v26;
          do
          {
            if ((char)s[(int)v9 - v26] >= -64)
            {
              v27 = v55;
              if (LODWORD(v56[0]) + (int)v26 < (int)v55)
                v27 = 0;
              v28 = LODWORD(v56[0]) + v26 - v27;
              v29 = (char *)v54;
              if (!*((_BYTE *)v54 + v28))
              {
                v30 = &s[(int)v9 - v26];
                v31 = v20 + 1;
                v32 = v18;
                while (*v30 == *v32)
                {
                  ++v32;
                  ++v30;
                  if (--v31 <= 1)
                  {
                    if ((_DWORD)v9 != (_DWORD)v26)
                    {
                      *((_BYTE *)v54 + v28) = 1;
                      ++HIDWORD(v55);
                      break;
                    }
                    v14 = 0;
                    goto LABEL_119;
                  }
                }
              }
            }
            if (!v21)
              break;
            --v21;
            ++v26;
          }
          while ((_DWORD)v9 + 1 != (_DWORD)v26);
        }
        goto LABEL_57;
      }
      v22 = -1;
      if ((_DWORD)v20 != 1)
      {
        v23 = *v18;
        if ((v23 + 11) >= 0xCDu)
        {
          v24 = v18[1];
          if ((v23 & 0xF0) == 0xE0)
          {
            if (((a00000000000000[v23 & 0xF] >> (v18[1] >> 5)) & 1) != 0)
            {
              if ((_DWORD)v20 != 2)
              {
                v25 = (char)v18[2] < -64;
                v22 = -3;
                goto LABEL_27;
              }
              goto LABEL_40;
            }
            goto LABEL_39;
          }
          if (v23 <= 0xDF)
          {
            if ((char)v24 < -64)
              v22 = -2;
            else
              v22 = -1;
            goto LABEL_41;
          }
          if (((byte_18BE15273[v24 >> 4] >> (v23 & 7)) & 1) == 0)
          {
LABEL_39:
            v22 = -1;
            goto LABEL_41;
          }
          if ((_DWORD)v20 == 2 || (char)v18[2] > -65)
          {
LABEL_40:
            v22 = -2;
            goto LABEL_41;
          }
          if ((_DWORD)v20 != 3)
          {
            v25 = (char)v18[3] < -64;
            v22 = -4;
LABEL_27:
            if (!v25)
              ++v22;
            goto LABEL_41;
          }
          v22 = -3;
        }
      }
LABEL_41:
      v21 = v22 + v20;
      goto LABEL_42;
    }
LABEL_91:
    if (v10 || (_DWORD)v9 == a3)
      break;
    if (HIDWORD(v55))
    {
      v43 = (int)v9 - 1;
      v44 = s[v43];
      if ((char)s[v43] < 0)
      {
        pi = v9 - 1;
        v47 = utf8_prevCharSafeBody(s, 0, &pi, v44, -3);
        v48 = v9 - pi;
        if (icu::UnicodeSet::contains(v52, v47))
          v45 = v48;
        else
          v45 = -v48;
        if (v45 < 1)
          goto LABEL_98;
LABEL_108:
        v9 = (v9 - v45);
        if (!(_DWORD)v9)
        {
          v14 = 0;
          goto LABEL_118;
        }
        v49 = LODWORD(v56[0]) + v45;
        if (v49 >= (int)v55)
          v50 = v55;
        else
          v50 = 0;
        v51 = v49 - v50;
        if (*((_BYTE *)v54 + v51))
        {
          *((_BYTE *)v54 + v51) = 0;
          --HIDWORD(v55);
        }
        v10 = 0;
        LODWORD(v56[0]) = v51;
      }
      else
      {
        if (icu::UnicodeSet::contains(v52, s[v43]))
        {
          v45 = 1;
          goto LABEL_108;
        }
LABEL_98:
        v10 = 0;
        v9 = v9 - sub_18BC521A8((unsigned __int8 **)&v54);
      }
    }
    else
    {
      v46 = icu::UnicodeSet::spanBackUTF8(v52, s);
      v14 = v46;
      if (!(_DWORD)v46)
        goto LABEL_118;
      v10 = v9 - v46;
      v9 = v46;
      if (!v10)
        goto LABEL_118;
    }
  }
  if (HIDWORD(v55))
    goto LABEL_98;
  v14 = v9;
LABEL_118:
  v29 = (char *)v54;
LABEL_119:
  if (v29 != (char *)v56 + 4)
    uprv_free(v29);
  return v14;
}

uint64_t sub_18BC53748(uint64_t a1, uint8_t *s)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  icu::UnicodeSet *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  UChar32 v11;
  int v12;
  UChar32 v13;
  int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint8_t *v18;
  int v19;
  unsigned __int8 *i;
  int32_t pi;

  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 216) + 8);
  v5 = 3 * (int)v4;
  if (!*(_BYTE *)(a1 + 260))
    v5 = 0;
  v6 = *(_QWORD *)(a1 + 232) + v5;
  v7 = (icu::UnicodeSet *)(a1 + 8);
  while (1)
  {
    v8 = icu::UnicodeSet::spanBackUTF8(*(icu::UnicodeSet **)(a1 + 208), s);
    v9 = v8;
    if (!(_DWORD)v8)
      break;
    v10 = (int)v8 - 1;
    v11 = s[v10];
    if ((char)s[v10] < 0)
    {
      pi = v8 - 1;
      v13 = utf8_prevCharSafeBody(s, 0, &pi, v11, -3);
      v14 = v9 - pi;
      if (icu::UnicodeSet::contains(v7, v13))
        v12 = v14;
      else
        v12 = -v14;
      if (v12 > 0)
        return v9;
    }
    else
    {
      if (icu::UnicodeSet::contains(v7, s[v10]))
        return v9;
      v12 = -1;
    }
    if ((int)v4 >= 1)
    {
      v15 = 0;
      v16 = *(unsigned __int8 **)(a1 + 240);
      do
      {
        v17 = *(int *)(*(_QWORD *)(a1 + 224) + 4 * v15);
        if ((_DWORD)v17 && (int)v17 <= (int)v9 && *(unsigned __int8 *)(v6 + v15) != 255)
        {
          v18 = &s[(int)v9 - v17];
          v19 = v17 + 1;
          for (i = v16; *v18 == *i; ++i)
          {
            ++v18;
            if (--v19 <= 1)
              return v9;
          }
        }
        v16 += v17;
        ++v15;
      }
      while (v15 != v4);
    }
    if (!(v12 + (_DWORD)v9))
      return 0;
  }
  return v9;
}

void *icu::UnicodeString::getStaticClassID(icu::UnicodeString *this)
{
  return &unk_1EE009610;
}

void *icu::UnicodeString::getDynamicClassID(icu::UnicodeString *this)
{
  return &unk_1EE009610;
}

void icu::operator+(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  UChar **v21;
  void (**v22)(icu::UnicodeString *__hidden);
  __int16 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int16 *)(a1 + 8);
  v7 = (__int16)v6;
  v8 = v6 >> 5;
  if (v7 < 0)
    v8 = *(_DWORD *)(a1 + 12);
  v9 = *(unsigned __int16 *)(a2 + 8);
  v10 = (__int16)v9;
  v11 = v9 >> 5;
  if (v10 < 0)
    v11 = *(_DWORD *)(a2 + 12);
  v22 = off_1E2256B38;
  v23 = 0;
  icu::UnicodeString::allocate((icu::UnicodeString *)&v22, v8 + v11 + 1);
  v12 = *(unsigned __int16 *)(a1 + 8);
  v13 = (__int16)v12;
  v14 = v12 >> 5;
  if (v13 >= 0)
    v15 = v14;
  else
    v15 = *(unsigned int *)(a1 + 12);
  v16 = icu::UnicodeString::doAppend((uint64_t)&v22, (const icu::UnicodeString *)a1, 0, v15);
  v17 = *(unsigned __int16 *)(a2 + 8);
  v18 = (__int16)v17;
  v19 = v17 >> 5;
  if (v18 >= 0)
    v20 = v19;
  else
    v20 = *(unsigned int *)(a2 + 12);
  v21 = (UChar **)icu::UnicodeString::doAppend(v16, (const icu::UnicodeString *)a2, 0, v20);
  *(_QWORD *)a3 = off_1E2256B38;
  *(_WORD *)(a3 + 8) = 2;
  icu::UnicodeString::copyFrom((UChar **)a3, v21, 0);
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v22);
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, UChar **a2)
{
  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  return icu::UnicodeString::copyFrom((UChar **)this, a2, 0);
}

{
  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  return icu::UnicodeString::copyFrom((UChar **)this, a2, 0);
}

uint64_t icu::UnicodeString::addRef(uint64_t this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(*(_QWORD *)(this + 24) - 4);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return this;
}

uint64_t icu::UnicodeString::removeRef(icu::UnicodeString *this)
{
  unsigned int *v1;
  unsigned int v2;
  uint64_t result;

  v1 = (unsigned int *)(*((_QWORD *)this + 3) - 4);
  do
  {
    v2 = __ldaxr(v1);
    result = v2 - 1;
  }
  while (__stlxr(result, v1));
  return result;
}

uint64_t icu::UnicodeString::refCount(icu::UnicodeString *this)
{
  return atomic_load((unsigned int *)(*((_QWORD *)this + 3) - 4));
}

void icu::UnicodeString::releaseArray(icu::UnicodeString *this)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  if ((*((_WORD *)this + 4) & 4) != 0)
  {
    v1 = (unsigned int *)(*((_QWORD *)this + 3) - 4);
    do
    {
      v2 = __ldaxr(v1);
      v3 = v2 - 1;
    }
    while (__stlxr(v3, v1));
    if (!v3)
      uprv_free((void *)(*((_QWORD *)this + 3) - 4));
  }
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, int a2, unsigned int a3, int a4)
{
  _WORD *v7;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  __int16 v12;
  unint64_t v13;
  char *v14;

  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 0;
  if (HIWORD(a3) > 0x10u || a4 <= 0)
    goto LABEL_10;
  if (!HIWORD(a3))
  {
    if (a2 <= a4)
      a2 = a4;
    if (icu::UnicodeString::allocate(this, a2))
    {
      if ((*((_WORD *)this + 4) & 2) != 0)
        v7 = (_WORD *)((char *)this + 10);
      else
        v7 = (_WORD *)*((_QWORD *)this + 3);
      v11 = a4;
      do
      {
        *v7++ = a3;
        --v11;
      }
      while (v11);
      if (a4 <= 1023)
      {
        v12 = *((_WORD *)this + 4) & 0x1F | (32 * a4);
LABEL_28:
        *((_WORD *)this + 4) = v12;
        return this;
      }
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = a4;
    }
    return this;
  }
  if (a4 >> 30)
  {
LABEL_10:
    icu::UnicodeString::allocate(this, a2);
    return this;
  }
  v9 = (2 * a4);
  if ((int)v9 > a2)
    a2 = 2 * a4;
  if (icu::UnicodeString::allocate(this, a2))
  {
    if ((*((_WORD *)this + 4) & 2) != 0)
      v10 = (char *)this + 10;
    else
      v10 = (char *)*((_QWORD *)this + 3);
    v13 = 0;
    do
    {
      v14 = &v10[2 * v13];
      *(_WORD *)v14 = (a3 >> 10) - 10304;
      *((_WORD *)v14 + 1) = a3 & 0x3FF | 0xDC00;
      v13 += 2;
    }
    while (v13 < v9);
    if (a4 > 0x1FF)
    {
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = v9;
      return this;
    }
    v12 = *((_WORD *)this + 4) & 0x1F | (32 * v9);
    goto LABEL_28;
  }
  return this;
}

uint64_t icu::UnicodeString::allocate(icu::UnicodeString *this, int a2)
{
  uint64_t result;
  size_t v4;
  _DWORD *v5;
  _DWORD *v6;

  if (a2 > 27)
  {
    if (a2 <= 0x7FFFFFF5
      && (v4 = (2 * (a2 + 1) + 19) & 0x3FFFFFFF0, (v5 = uprv_malloc(v4)) != 0))
    {
      v6 = v5;
      result = 1;
      *v6 = 1;
      *((_QWORD *)this + 3) = v6 + 1;
      *((_DWORD *)this + 4) = (v4 + 0x1FFFFFFFCLL) >> 1;
      *((_WORD *)this + 4) = 4;
    }
    else
    {
      result = 0;
      *((_WORD *)this + 4) = 1;
      *((_QWORD *)this + 3) = 0;
      *((_DWORD *)this + 4) = 0;
    }
  }
  else
  {
    *((_WORD *)this + 4) = 2;
    return 1;
  }
  return result;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t result, __int16 a2)
{
  *(_QWORD *)result = off_1E2256B38;
  *(_WORD *)(result + 8) = 34;
  *(_WORD *)(result + 10) = a2;
  return result;
}

{
  *(_QWORD *)result = off_1E2256B38;
  *(_WORD *)(result + 8) = 34;
  *(_WORD *)(result + 10) = a2;
  return result;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t this, unsigned int a2)
{
  __int16 v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E2256B38;
  *(_WORD *)(this + 8) = 2;
  if (HIWORD(a2))
  {
    if (HIWORD(a2) > 0x10u)
      return this;
    *(_WORD *)(this + 10) = (a2 >> 10) - 10304;
    v2 = 66;
    v3 = 12;
    LOWORD(a2) = a2 & 0x3FF | 0xDC00;
  }
  else
  {
    v2 = 34;
    v3 = 10;
  }
  *(_WORD *)(this + v3) = a2;
  *(_WORD *)(this + 8) = v2;
  return this;
}

{
  __int16 v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E2256B38;
  *(_WORD *)(this + 8) = 2;
  if (HIWORD(a2))
  {
    if (HIWORD(a2) > 0x10u)
      return this;
    *(_WORD *)(this + 10) = (a2 >> 10) - 10304;
    v2 = 66;
    v3 = 12;
    LOWORD(a2) = a2 & 0x3FF | 0xDC00;
  }
  else
  {
    v2 = 34;
    v3 = 10;
  }
  *(_WORD *)(this + v3) = a2;
  *(_WORD *)(this + 8) = v2;
  return this;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = off_1E2256B38;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, 0xFFFFFFFFLL);
  return a1;
}

{
  *(_QWORD *)a1 = off_1E2256B38;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, 0xFFFFFFFFLL);
  return a1;
}

uint64_t icu::UnicodeString::doAppend(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v11;
  unint64_t v12;
  _BOOL4 v13;
  unsigned int v14;
  char *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  void *v22;
  int v23;
  unsigned int v24;
  int v25;
  void (**v26)(icu::UnicodeString *__hidden);
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;

  v4 = a1;
  v31 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return v4;
  v5 = a4;
  if (!(_DWORD)a4)
    return v4;
  v6 = *(unsigned __int16 *)(a1 + 8);
  if ((v6 & 0x11) != 0)
    return v4;
  v7 = (const void *)(a2 + 2 * a3);
  if ((a4 & 0x80000000) != 0)
  {
    v9 = u_strlen((const UChar *)(a2 + 2 * a3));
    if (!(_DWORD)v9)
      return v4;
    v5 = v9;
    v6 = *(unsigned __int16 *)(v4 + 8);
    if ((v6 & 0x8000) == 0)
      goto LABEL_6;
  }
  else if ((v6 & 0x8000) == 0)
  {
LABEL_6:
    LODWORD(v8) = v6 >> 5;
    goto LABEL_10;
  }
  LODWORD(v8) = *(_DWORD *)(v4 + 12);
LABEL_10:
  v25 = 0;
  if (uprv_add32_overflow(v8, v5, &v25))
  {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)v4);
    return v4;
  }
  v11 = *(_WORD *)(v4 + 8);
  if ((v11 & 2) != 0)
    v12 = v4 + 10;
  else
    v12 = *(_QWORD *)(v4 + 24);
  if ((v11 & 0x19) != 0)
  {
    v8 = (int)v8;
  }
  else
  {
    if ((v11 & 4) != 0)
    {
      v14 = atomic_load((unsigned int *)(*(_QWORD *)(v4 + 24) - 4));
      v13 = v14 == 1;
    }
    else
    {
      v13 = 1;
    }
    if (v13 && v12 < (unint64_t)v7 + 2 * (int)v5 && (unint64_t)v7 < v12 + 2 * (int)v8)
    {
      v27 = 0u;
      v28 = 0u;
      v30 = 0;
      v29 = 0u;
      v26 = off_1E2256B38;
      LOWORD(v27) = 2;
      icu::UnicodeString::doAppend(&v26, v7, 0, v5);
      if ((v27 & 1) != 0)
      {
        icu::UnicodeString::setToBogus((icu::UnicodeString *)v4);
      }
      else
      {
        if ((v27 & 2) != 0)
          v15 = (char *)&v27 + 2;
        else
          v15 = (char *)v28;
        v4 = icu::UnicodeString::doAppend(v4, v15, 0, v5);
      }
      icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v26);
      return v4;
    }
    v8 = (int)v8;
    v11 = *(_WORD *)(v4 + 8);
  }
  v16 = v25;
  if ((v11 & 2) != 0)
    v17 = 27;
  else
    v17 = *(_DWORD *)(v4 + 16);
  if (v25 <= v17 && (v11 & 0x19) == 0)
  {
    if ((v11 & 4) == 0 || (v24 = atomic_load((unsigned int *)(*(_QWORD *)(v4 + 24) - 4)), v24 == 1))
    {
LABEL_39:
      v20 = *(_WORD *)(v4 + 8);
      if ((v20 & 2) != 0)
        v21 = v4 + 10;
      else
        v21 = *(_QWORD *)(v4 + 24);
      if ((int)v5 >= 1)
      {
        v22 = (void *)(v21 + 2 * v8);
        if (v7 != v22)
        {
          memmove(v22, v7, 2 * v5);
          v20 = *(_WORD *)(v4 + 8);
        }
      }
      v23 = v25;
      if (v25 > 1023)
      {
        *(_WORD *)(v4 + 8) = v20 | 0xFFE0;
        *(_DWORD *)(v4 + 12) = v23;
      }
      else
      {
        *(_WORD *)(v4 + 8) = v20 & 0x1F | (32 * v25);
      }
      return v4;
    }
    v16 = v25;
  }
  v18 = (v16 >> 2) + 128;
  if (v18 <= 2147483637 - v16)
    v19 = v18 + v16;
  else
    v19 = 2147483637;
  if (icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)v4, v16, v19, 1, 0, 0))
    goto LABEL_39;
  return v4;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a1 = off_1E2256B38;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, a3);
  return a1;
}

{
  *(_QWORD *)a1 = off_1E2256B38;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, a3);
  return a1;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, int a2, const UChar **a3, int32_t a4)
{
  __int16 v5;
  const UChar *v6;
  int32_t v8;
  __int16 v9;

  *(_QWORD *)this = off_1E2256B38;
  LOBYTE(v5) = 8;
  *((_WORD *)this + 4) = 8;
  v6 = *a3;
  if (!*a3)
  {
    *((_WORD *)this + 4) = 2;
    return this;
  }
  if (a4 < -1 || !a2 && a4 == -1)
    goto LABEL_8;
  if (!a2 || a4 < 0)
  {
    if (a4 == -1)
    {
      a4 = u_strlen(*a3);
      v5 = *((_WORD *)this + 4);
    }
  }
  else
  {
    if (v6[a4])
    {
LABEL_8:
      icu::UnicodeString::setToBogus(this);
      return this;
    }
    LOBYTE(v5) = 8;
  }
  if (a2)
    v8 = a4 + 1;
  else
    v8 = a4;
  if (a4 > 1023)
  {
    v9 = v5 | 0xFFE0;
    *((_DWORD *)this + 3) = a4;
  }
  else
  {
    v9 = v5 & 0x1F | (32 * a4);
  }
  *((_WORD *)this + 4) = v9;
  *((_QWORD *)this + 3) = v6;
  *((_DWORD *)this + 4) = v8;
  return this;
}

void icu::UnicodeString::setToBogus(icu::UnicodeString *this)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  if ((*((_WORD *)this + 4) & 4) != 0)
  {
    v2 = (unsigned int *)(*((_QWORD *)this + 3) - 4);
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
      uprv_free((void *)(*((_QWORD *)this + 3) - 4));
  }
  *((_WORD *)this + 4) = 1;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, char *a2, unint64_t a3, unsigned int a4)
{
  char *v5;
  uint64_t v6;
  __int16 v7;

  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 0;
  if (a2)
  {
    if ((int)a3 > (int)a4 || (int)a3 < -1 || (a4 & 0x80000000) != 0)
    {
      icu::UnicodeString::setToBogus(this);
    }
    else
    {
      if ((_DWORD)a3 == -1)
      {
        v5 = a2;
        if (a4)
        {
          v6 = 2 * a4;
          v5 = a2;
          while (*(_WORD *)v5)
          {
            v5 += 2;
            v6 -= 2;
            if (!v6)
            {
              v5 = &a2[2 * a4];
              break;
            }
          }
        }
        a3 = (unint64_t)(v5 - a2) >> 1;
      }
      if ((int)a3 > 1023)
      {
        *((_DWORD *)this + 3) = a3;
        v7 = -32;
      }
      else
      {
        v7 = 32 * a3;
      }
      *((_WORD *)this + 4) = v7;
      *((_QWORD *)this + 3) = a2;
      *((_DWORD *)this + 4) = a4;
    }
  }
  else
  {
    *((_WORD *)this + 4) = 2;
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, char *__s, int32_t a3)
{
  int32_t v4;
  UChar *v6;

  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  if (__s)
  {
    v4 = a3;
    if (a3 < 0)
      v4 = strlen(__s);
    if (icu::UnicodeString::cloneArrayIfNeeded(this, v4, v4, 0, 0, 0))
    {
      if ((*((_WORD *)this + 4) & 2) != 0)
        v6 = (UChar *)((char *)this + 10);
      else
        v6 = (UChar *)*((_QWORD *)this + 3);
      u_charsToUChars(__s, v6, v4);
      if (v4 > 1023)
      {
        *((_WORD *)this + 4) |= 0xFFE0u;
        *((_DWORD *)this + 3) = v4;
      }
      else
      {
        *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * v4);
      }
    }
    else
    {
      icu::UnicodeString::setToBogus(this);
    }
  }
  return this;
}

uint64_t icu::UnicodeString::cloneArrayIfNeeded(icu::UnicodeString *this, int a2, int a3, int a4, unsigned int **a5, int a6)
{
  int v8;
  unsigned int v10;
  int v12;
  int v13;
  int v15;
  int v16;
  int v17;
  _QWORD *v18;
  __int16 v19;
  int v20;
  char *v21;
  __int16 v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  _QWORD v26[8];

  v8 = a2;
  v26[7] = *MEMORY[0x1E0C80C00];
  v10 = *((unsigned __int16 *)this + 4);
  if (a2 == -1)
  {
    if ((v10 & 2) != 0)
      v8 = 27;
    else
      v8 = *((_DWORD *)this + 4);
  }
  if ((v10 & 0x11) != 0)
    return 0;
  if (!a6 && (v10 & 8) == 0)
  {
    if ((v10 & 4) == 0
      || (v12 = atomic_load((unsigned int *)(*((_QWORD *)this + 3) - 4)),
          v10 = *((unsigned __int16 *)this + 4),
          v12 <= 1))
    {
      v13 = (v10 & 2) != 0 ? 27 : *((_DWORD *)this + 4);
      if (v8 <= v13)
        return 1;
    }
  }
  if (v8 >= 28 || a3 <= 27)
    v15 = a3;
  else
    v15 = 27;
  memset(&v26[2], 0, 38);
  if (a3 >= 0)
    v16 = v15;
  else
    v16 = v8;
  *(_OWORD *)v26 = 0uLL;
  if ((v10 & 0x8000) != 0)
  {
    v17 = *((_DWORD *)this + 3);
    if ((v10 & 2) == 0)
      goto LABEL_26;
  }
  else
  {
    v17 = v10 >> 5;
    if ((v10 & 2) == 0)
    {
LABEL_26:
      v18 = (_QWORD *)*((_QWORD *)this + 3);
      goto LABEL_32;
    }
  }
  v18 = 0;
  if (a4)
  {
    if (v16 >= 28)
    {
      v18 = v26;
      if (v17 >= 1)
        memcpy(v26, (char *)this + 10, 2 * v17);
    }
  }
LABEL_32:
  if (!icu::UnicodeString::allocate(this, v16)
    && (v8 >= v16 || !icu::UnicodeString::allocate(this, v8)))
  {
    if ((v10 & 2) == 0)
      *((_QWORD *)this + 3) = v18;
    *((_WORD *)this + 4) = v10;
    icu::UnicodeString::setToBogus(this);
    return 0;
  }
  v19 = *((_WORD *)this + 4);
  if (!a4)
  {
    v22 = *((_WORD *)this + 4) & 0x1F;
    goto LABEL_55;
  }
  if ((v19 & 2) != 0)
  {
    if (v17 >= 27)
      v20 = 27;
    else
      v20 = v17;
    if (!v18)
      goto LABEL_54;
    v21 = (char *)this + 10;
  }
  else
  {
    if (*((_DWORD *)this + 4) >= v17)
      v20 = v17;
    else
      v20 = *((_DWORD *)this + 4);
    if (!v18)
    {
LABEL_53:
      if (v20 > 1023)
      {
        *((_WORD *)this + 4) = v19 | 0xFFE0;
        *((_DWORD *)this + 3) = v20;
        if ((v10 & 4) != 0)
          goto LABEL_56;
        return 1;
      }
      goto LABEL_54;
    }
    v21 = (char *)*((_QWORD *)this + 3);
  }
  if (v20 >= 1)
  {
    memmove(v21, v18, 2 * v20);
    v19 = *((_WORD *)this + 4);
    goto LABEL_53;
  }
LABEL_54:
  v22 = v19 & 0x1F | (32 * v20);
LABEL_55:
  *((_WORD *)this + 4) = v22;
  if ((v10 & 4) != 0)
  {
LABEL_56:
    v23 = (unsigned int *)v18 - 1;
    do
    {
      v24 = __ldaxr(v23);
      v25 = v24 - 1;
    }
    while (__stlxr(v25, v23));
    if (!v25)
    {
      if (a5)
        *a5 = v23;
      else
        uprv_free(v23);
    }
  }
  return 1;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *a2)
{
  const char *v4;
  uint64_t v5;

  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  if (a2)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
    icu::UnicodeString::setToUTF8((uint64_t)this, v4, v5);
  }
  return this;
}

uint64_t icu::UnicodeString::setToUTF8(uint64_t a1, const char *a2, int32_t a3)
{
  int32_t v6;
  int v7;
  UChar *Buffer;
  UErrorCode pErrorCode[2];

  if ((*(_WORD *)(a1 + 8) & 1) != 0)
    *(_WORD *)(a1 + 8) = 2;
  v6 = 27;
  if (a3 > 27)
    v7 = a3 + 1;
  else
    v7 = 27;
  Buffer = (UChar *)icu::UnicodeString::getBuffer((icu::UnicodeString *)a1, v7);
  *(_QWORD *)pErrorCode = 0;
  if ((*(_WORD *)(a1 + 8) & 2) == 0)
    v6 = *(_DWORD *)(a1 + 16);
  u_strFromUTF8WithSub(Buffer, v6, (int32_t *)&pErrorCode[1], a2, a3, 65533, 0, pErrorCode);
  icu::UnicodeString::releaseBuffer(a1, pErrorCode[1]);
  if (pErrorCode[0] >= U_ILLEGAL_ARGUMENT_ERROR)
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a1);
  return a1;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *__s, int32_t a3)
{
  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  if (a3 >= -1 && __s && a3)
  {
    if (a3 == -1)
      a3 = strlen(__s);
    icu::UnicodeString::setToUTF8((uint64_t)this, __s, a3);
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::copyFrom(UChar **this, UChar **a2, int a3)
{
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  __int16 v11;
  unsigned int *v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  UChar *v17;
  const UChar *v18;

  if (this != a2)
  {
    if (((_WORD)a2[1] & 1) != 0)
    {
      icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
    }
    else
    {
      if (((_WORD)this[1] & 4) != 0)
      {
        v6 = (unsigned int *)(this[3] - 2);
        do
        {
          v7 = __ldaxr(v6);
          v8 = v7 - 1;
        }
        while (__stlxr(v8, v6));
        if (!v8)
          uprv_free(this[3] - 2);
      }
      v9 = *((unsigned __int16 *)a2 + 4);
      if (v9 <= 0x1F)
      {
        v11 = 2;
LABEL_13:
        *((_WORD *)this + 4) = v11;
      }
      else
      {
        *((_WORD *)this + 4) = v9;
        v10 = *((unsigned __int16 *)a2 + 4);
        switch(v10 & 0x1F)
        {
          case 0u:
            goto LABEL_21;
          case 2u:
            memcpy((char *)this + 10, (char *)a2 + 10, 2 * ((__int16)v9 >> 5));
            return (icu::UnicodeString *)this;
          case 4u:
            v12 = (unsigned int *)(a2[3] - 2);
            do
              v13 = __ldaxr(v12);
            while (__stlxr(v13 + 1, v12));
            this[3] = a2[3];
            *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
            if ((__int16)this[1] < 0)
              goto LABEL_20;
            return (icu::UnicodeString *)this;
          case 8u:
            if (a3)
            {
              this[3] = a2[3];
              *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
              if ((v9 & 0x8000) != 0)
LABEL_20:
                *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
            }
            else
            {
LABEL_21:
              v14 = (__int16)v10;
              v15 = v10 >> 5;
              if (v14 >= 0)
                v16 = v15;
              else
                v16 = *((_DWORD *)a2 + 3);
              if (!icu::UnicodeString::allocate((icu::UnicodeString *)this, v16))
              {
LABEL_27:
                *((_WORD *)this + 4) = 1;
                this[3] = 0;
                *((_DWORD *)this + 4) = 0;
                return (icu::UnicodeString *)this;
              }
              if (((_WORD)this[1] & 2) != 0)
                v17 = (UChar *)this + 5;
              else
                v17 = this[3];
              if (((_WORD)a2[1] & 2) != 0)
                v18 = (const UChar *)a2 + 5;
              else
                v18 = a2[3];
              u_memcpy(v17, v18, v16);
              if (v16 <= 1023)
              {
                v11 = (_WORD)this[1] & 0x1F | (32 * v16);
                goto LABEL_13;
              }
              *((_WORD *)this + 4) |= 0xFFE0u;
              *((_DWORD *)this + 3) = v16;
            }
            break;
          default:
            goto LABEL_27;
        }
      }
    }
  }
  return (icu::UnicodeString *)this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *a1, icu::UnicodeString *a2)
{
  *(_QWORD *)a1 = off_1E2256B38;
  icu::UnicodeString::copyFieldsFrom(a1, a2, 1);
  return a1;
}

{
  *(_QWORD *)a1 = off_1E2256B38;
  icu::UnicodeString::copyFieldsFrom(a1, a2, 1);
  return a1;
}

icu::UnicodeString *icu::UnicodeString::copyFieldsFrom(icu::UnicodeString *this, icu::UnicodeString *a2, int a3)
{
  int v3;

  v3 = *((__int16 *)a2 + 4);
  *((_WORD *)this + 4) = *((_WORD *)a2 + 4);
  if ((v3 & 2) != 0)
  {
    if (this != a2)
      return (icu::UnicodeString *)memcpy((char *)this + 10, (char *)a2 + 10, 2 * (v3 >> 5));
  }
  else
  {
    *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
    *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
    if ((v3 & 0x80000000) == 0)
    {
      if (!a3)
        return this;
LABEL_8:
      *((_WORD *)a2 + 4) = 1;
      *((_QWORD *)a2 + 3) = 0;
      *((_DWORD *)a2 + 4) = 0;
      return this;
    }
    *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
    if (a3)
      goto LABEL_8;
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const icu::UnicodeString *a2, int a3)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  int v7;

  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  v4 = *((unsigned __int16 *)a2 + 4);
  v5 = v4 >> 5;
  if (a3 < 0)
  {
    v7 = 0;
    goto LABEL_7;
  }
  v6 = a3;
  if ((v4 & 0x8000) != 0)
  {
    v7 = *((_DWORD *)a2 + 3);
    if (v7 >= a3)
      goto LABEL_8;
    goto LABEL_7;
  }
  v7 = v4 >> 5;
  if (v5 < a3)
LABEL_7:
    v6 = v7;
LABEL_8:
  if ((v4 & 0x8000u) != 0)
    v5 = *((_DWORD *)a2 + 3);
  icu::UnicodeString::doReplace(this, 0, 0, a2, v6, v5 - v6);
  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const icu::UnicodeString *a2, int a3, uint64_t a4)
{
  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  icu::UnicodeString::doReplace(this, 0, 0, a2, a3, a4);
  return this;
}

{
  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  icu::UnicodeString::doReplace(this, 0, 0, a2, a3, a4);
  return this;
}

uint64_t icu::Replaceable::clone(icu::Replaceable *this)
{
  return 0;
}

icu::UnicodeString *icu::UnicodeString::clone@<X0>(UChar **this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  icu::UnicodeString *result;

  result = (icu::UnicodeString *)icu::UMemory::operator new(a3, (icu::UMemory *)0x40, a2);
  if (result)
  {
    *(_QWORD *)result = off_1E2256B38;
    *((_WORD *)result + 4) = 2;
    result = icu::UnicodeString::copyFrom((UChar **)result, this, 0);
    if ((*((_WORD *)result + 4) & 1) != 0)
    {
      (*(void (**)(icu::UnicodeString *))(*(_QWORD *)result + 8))(result);
      return 0;
    }
  }
  return result;
}

void icu::UnicodeString::~UnicodeString(icu::UnicodeString *this)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = off_1E2256B38;
  if ((*((_WORD *)this + 4) & 4) != 0)
  {
    v2 = (unsigned int *)(*((_QWORD *)this + 3) - 4);
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
      uprv_free((void *)(*((_QWORD *)this + 3) - 4));
  }
  icu::UObject::~UObject(this);
}

{
  void *v1;

  icu::UnicodeString::~UnicodeString(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::UnicodeString::fromUTF8@<X0>(const char *a1@<X0>, int32_t a2@<W1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 8) = 0u;
  *(_QWORD *)(a3 + 56) = 0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_QWORD *)a3 = off_1E2256B38;
  *(_WORD *)(a3 + 8) = 2;
  return icu::UnicodeString::setToUTF8(a3, a1, a2);
}

void icu::UnicodeString::fromUTF32(const UChar32 *this@<X0>, const int *a2@<X1>, uint64_t a3@<X8>)
{
  int32_t v3;
  int v6;
  UChar *Buffer;
  int32_t v8;
  UErrorCode v9;
  UErrorCode pErrorCode[2];

  v3 = (int)a2;
  *(_OWORD *)(a3 + 8) = 0u;
  *(_QWORD *)(a3 + 56) = 0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_QWORD *)a3 = off_1E2256B38;
  *(_WORD *)(a3 + 8) = 2;
  if ((int)a2 <= 27)
    v6 = 27;
  else
    v6 = (_DWORD)a2 + (a2 >> 4) + 4;
  while (1)
  {
    Buffer = (UChar *)icu::UnicodeString::getBuffer((icu::UnicodeString *)a3, v6);
    *(_QWORD *)pErrorCode = 0;
    v8 = (*(_WORD *)(a3 + 8) & 2) != 0 ? 27 : *(_DWORD *)(a3 + 16);
    u_strFromUTF32WithSub(Buffer, v8, (int32_t *)&pErrorCode[1], this, v3, 65533, 0, pErrorCode);
    v9 = pErrorCode[1];
    icu::UnicodeString::releaseBuffer(a3, pErrorCode[1]);
    if (pErrorCode[0] != U_BUFFER_OVERFLOW_ERROR)
      break;
    v6 = v9 + 1;
  }
  if (pErrorCode[0] >= U_ILLEGAL_ARGUMENT_ERROR)
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a3);
}

uint64_t icu::UnicodeString::getBuffer(icu::UnicodeString *this, int a2)
{
  __int16 v3;

  if (a2 < -1)
    return 0;
  if (!icu::UnicodeString::cloneArrayIfNeeded(this, a2, -1, 1, 0, 0))
    return 0;
  v3 = *((_WORD *)this + 4);
  *((_WORD *)this + 4) = v3 & 0xF | 0x10;
  if ((v3 & 2) != 0)
    return (uint64_t)this + 10;
  else
    return *((_QWORD *)this + 3);
}

uint64_t icu::UnicodeString::releaseBuffer(uint64_t this, int a2)
{
  __int16 v2;
  int v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  __int16 v8;

  if (a2 < -1)
    return this;
  v2 = *(_WORD *)(this + 8);
  if ((v2 & 0x10) == 0)
    return this;
  if ((v2 & 2) != 0)
  {
    if (a2 == -1)
    {
      v4 = (char *)(this + 10);
      v5 = this + 64;
      goto LABEL_13;
    }
    v3 = 27;
  }
  else
  {
    v3 = *(_DWORD *)(this + 16);
    if (a2 == -1)
    {
      v4 = *(char **)(this + 24);
      if (v3 < 1)
      {
        v7 = *(char **)(this + 24);
LABEL_18:
        v6 = (unint64_t)(v7 - v4) >> 1;
        goto LABEL_19;
      }
      v5 = (unint64_t)&v4[2 * v3];
LABEL_13:
      v7 = v4;
      do
      {
        if (!*(_WORD *)v7)
          break;
        v7 += 2;
      }
      while ((unint64_t)v7 < v5);
      goto LABEL_18;
    }
  }
  if (v3 >= a2)
    LODWORD(v6) = a2;
  else
    LODWORD(v6) = v3;
LABEL_19:
  if ((int)v6 > 1023)
  {
    v8 = v2 | 0xFFE0;
    *(_DWORD *)(this + 12) = v6;
  }
  else
  {
    v8 = *(_WORD *)(this + 8) & 0x1F | (32 * v6);
  }
  *(_WORD *)(this + 8) = v8 & 0xFFEF;
  return this;
}

icu::UnicodeString *icu::UnicodeString::operator=(UChar **a1, UChar **a2)
{
  return icu::UnicodeString::copyFrom(a1, a2, 0);
}

icu::UnicodeString *icu::UnicodeString::fastCopyFrom(UChar **this, UChar **a2)
{
  return icu::UnicodeString::copyFrom(this, a2, 1);
}

icu::UnicodeString *icu::UnicodeString::operator=(icu::UnicodeString *this, icu::UnicodeString *a2)
{
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  if ((*((_WORD *)this + 4) & 4) != 0)
  {
    v4 = (unsigned int *)(*((_QWORD *)this + 3) - 4);
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      uprv_free((void *)(*((_QWORD *)this + 3) - 4));
  }
  icu::UnicodeString::copyFieldsFrom(this, a2, 1);
  return this;
}

void icu::UnicodeString::swap(icu::UnicodeString *this, void (***a2)(icu::UnicodeString *__hidden this))
{
  int v4;
  void (**v5)(icu::UnicodeString *__hidden);
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v6 = 0u;
  v7 = 0u;
  v9 = 0;
  v8 = 0u;
  v5 = off_1E2256B38;
  LOWORD(v6) = 2;
  icu::UnicodeString::copyFieldsFrom((icu::UnicodeString *)&v5, this, 0);
  icu::UnicodeString::copyFieldsFrom(this, (icu::UnicodeString *)a2, 0);
  v4 = (__int16)v6;
  *((_WORD *)a2 + 4) = v6;
  if ((v4 & 2) != 0)
  {
    if (&v5 != a2)
      memcpy((char *)a2 + 10, (char *)&v6 + 2, 2 * (v4 >> 5));
  }
  else
  {
    a2[3] = (void (**)(icu::UnicodeString *__hidden))v7;
    *((_DWORD *)a2 + 4) = DWORD2(v6);
    if (v4 < 0)
      *((_DWORD *)a2 + 3) = DWORD1(v6);
  }
  LOWORD(v6) = 2;
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v5);
}

uint64_t icu::UnicodeString::unescape@<X0>(icu::UnicodeString *this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4;
  int v5;
  uint64_t result;
  unsigned int v7;
  char *v8;
  unsigned int v9;
  int v10;
  int32_t v11;
  int32_t v12;
  unsigned int v13;
  int32_t v14;
  __int16 v15;
  int32_t offset;

  *(_QWORD *)(a2 + 56) = 0;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 8) = 0u;
  v4 = *((unsigned __int16 *)this + 4);
  if ((v4 & 0x8000) != 0)
    v5 = *((_DWORD *)this + 3);
  else
    v5 = v4 >> 5;
  *(_QWORD *)a2 = off_1E2256B38;
  result = icu::UnicodeString::allocate((icu::UnicodeString *)a2, v5);
  if ((*(_WORD *)(a2 + 8) & 1) != 0)
    return result;
  v7 = *((unsigned __int16 *)this + 4);
  if ((v7 & 0x11) != 0)
  {
    v8 = 0;
    if ((v7 & 0x8000) != 0)
      goto LABEL_12;
LABEL_10:
    v9 = v7 >> 5;
    goto LABEL_13;
  }
  if ((v7 & 2) != 0)
  {
    v8 = (char *)this + 10;
    if ((v7 & 0x8000) == 0)
      goto LABEL_10;
  }
  else
  {
    v8 = (char *)*((_QWORD *)this + 3);
    if ((v7 & 0x8000) == 0)
      goto LABEL_10;
  }
LABEL_12:
  v9 = *((_DWORD *)this + 3);
LABEL_13:
  offset = 0;
  if (v9)
  {
    v10 = 0;
    v11 = 0;
    while (1)
    {
      v12 = v10 + 1;
      offset = v10 + 1;
      if (*(_WORD *)&v8[2 * v10] == 92)
      {
        icu::UnicodeString::doAppend(a2, (uint64_t)v8, v11, (v10 - v11));
        v13 = *((unsigned __int16 *)this + 4);
        if ((v13 & 0x8000) != 0)
          v14 = *((_DWORD *)this + 3);
        else
          v14 = v13 >> 5;
        result = u_unescapeAt((UNESCAPE_CHAR_AT)sub_18BC551D4, &offset, v14, this);
        if ((result & 0x80000000) != 0)
        {
          if ((*(_WORD *)(a2 + 8) & 1) != 0)
            v15 = 2;
          else
            v15 = *(_WORD *)(a2 + 8) & 0x1F;
          *(_WORD *)(a2 + 8) = v15;
          return result;
        }
        icu::UnicodeString::append(a2, result);
        v12 = offset;
        v11 = offset;
      }
      v10 = v12;
      if (v12 == v9)
        return icu::UnicodeString::doAppend(a2, (uint64_t)v8, v11, v9 - v11);
    }
  }
  v11 = 0;
  return icu::UnicodeString::doAppend(a2, (uint64_t)v8, v11, v9 - v11);
}

uint64_t icu::UnicodeString::unescapeAt(icu::UnicodeString *this, int *a2)
{
  int32_t v2;

  if (*((__int16 *)this + 4) < 0)
    v2 = *((_DWORD *)this + 3);
  else
    v2 = *((unsigned __int16 *)this + 4) >> 5;
  return u_unescapeAt((UNESCAPE_CHAR_AT)sub_18BC551D4, a2, v2, this);
}

uint64_t icu::UnicodeString::append(uint64_t this, unsigned int a2)
{
  uint64_t v2;
  int v3;

  v3 = 0;
  if (HIWORD(a2))
  {
    if (HIWORD(a2) > 0x10u)
      return this;
    LOWORD(v3) = (a2 >> 10) - 10304;
    HIWORD(v3) = a2 & 0x3FF | 0xDC00;
    v2 = 2;
  }
  else
  {
    LOWORD(v3) = a2;
    v2 = 1;
  }
  return icu::UnicodeString::doAppend(this, (uint64_t)&v3, 0, v2);
}

uint64_t sub_18BC551D4(unsigned int a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;

  v2 = *(unsigned __int16 *)(a2 + 8);
  if (*(__int16 *)(a2 + 8) < 0)
    v3 = *(_DWORD *)(a2 + 12);
  else
    v3 = v2 >> 5;
  if (v3 <= a1)
    return 0xFFFFLL;
  if ((v2 & 2) != 0)
    v4 = a2 + 10;
  else
    v4 = *(_QWORD *)(a2 + 24);
  return *(unsigned __int16 *)(v4 + 2 * (int)a1);
}

BOOL icu::UnicodeString::doEquals(icu::UnicodeString *this, const icu::UnicodeString *a2, int a3)
{
  char *v3;
  char *v4;

  if ((*((_WORD *)this + 4) & 2) != 0)
    v3 = (char *)this + 10;
  else
    v3 = (char *)*((_QWORD *)this + 3);
  if ((*((_WORD *)a2 + 4) & 2) != 0)
    v4 = (char *)a2 + 10;
  else
    v4 = (char *)*((_QWORD *)a2 + 3);
  return memcmp(v3, v4, 2 * a3) == 0;
}

BOOL icu::UnicodeString::doEqualsSubstring(uint64_t a1, int a2, int32_t count, uint64_t a4, int a5, int32_t a6)
{
  unsigned int v6;
  int32_t v7;
  int v8;
  signed int v9;
  int v10;
  int32_t v11;
  uint64_t v12;
  const UChar *v14;
  _BOOL8 result;

  v6 = *(unsigned __int16 *)(a1 + 8);
  if ((v6 & 1) != 0)
    return 0;
  v7 = count;
  v8 = a2;
  if ((v6 & 0x8000) == 0)
  {
    v9 = v6 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_4;
LABEL_11:
    v10 = 0;
    goto LABEL_12;
  }
  v9 = *(_DWORD *)(a1 + 12);
  if (a2 < 0)
    goto LABEL_11;
LABEL_4:
  v10 = v9;
  if (v9 >= v8)
  {
    if ((count & 0x80000000) == 0)
      goto LABEL_6;
LABEL_13:
    v11 = 0;
    goto LABEL_14;
  }
LABEL_12:
  v8 = v10;
  if (count < 0)
    goto LABEL_13;
LABEL_6:
  v11 = v9 - v8;
  if (v11 >= count)
  {
    if (a4)
      goto LABEL_8;
    return v7 == 0;
  }
LABEL_14:
  v7 = v11;
  if (!a4)
    return v7 == 0;
LABEL_8:
  if ((v6 & 2) != 0)
    v12 = a1 + 10;
  else
    v12 = *(_QWORD *)(a1 + 24);
  v14 = (const UChar *)(a4 + 2 * a5);
  if (a6 < 0)
    a6 = u_strlen(&v14[a5]);
  if (v7 != a6)
    return 0;
  result = 1;
  if (v7 && (const UChar *)(v12 + 2 * v8) != v14)
    return u_memcmp((const UChar *)(v12 + 2 * v8), v14, v7) == 0;
  return result;
}

uint64_t icu::UnicodeString::doCompare(uint64_t a1, int a2, int32_t a3, uint64_t a4, int a5, int32_t a6)
{
  unsigned int v6;
  int32_t v7;
  int v8;
  signed int v9;
  int v10;
  int32_t v11;
  uint64_t v12;
  int v13;
  unsigned __int16 *v14;
  int v15;
  unsigned __int16 *v16;
  int v17;
  unsigned int v18;

  v6 = *(unsigned __int16 *)(a1 + 8);
  if ((v6 & 1) != 0)
  {
    LOBYTE(v13) = -1;
    return (char)v13;
  }
  v7 = a3;
  v8 = a2;
  if ((v6 & 0x8000) == 0)
  {
    v9 = v6 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_4;
LABEL_12:
    v10 = 0;
    goto LABEL_13;
  }
  v9 = *(_DWORD *)(a1 + 12);
  if (a2 < 0)
    goto LABEL_12;
LABEL_4:
  v10 = v9;
  if (v9 >= v8)
  {
    if ((a3 & 0x80000000) == 0)
      goto LABEL_6;
LABEL_14:
    v11 = 0;
    goto LABEL_15;
  }
LABEL_13:
  v8 = v10;
  if (a3 < 0)
    goto LABEL_14;
LABEL_6:
  v11 = v9 - v8;
  if (v11 >= a3)
  {
    if (a4)
      goto LABEL_8;
LABEL_16:
    LOBYTE(v13) = v7 != 0;
    return (char)v13;
  }
LABEL_15:
  v7 = v11;
  if (!a4)
    goto LABEL_16;
LABEL_8:
  if ((v6 & 2) != 0)
    v12 = a1 + 10;
  else
    v12 = *(_QWORD *)(a1 + 24);
  v14 = (unsigned __int16 *)(a4 + 2 * a5);
  if (a6 < 0)
    a6 = u_strlen(&v14[a5]);
  if (v7 >= a6)
    v15 = a6;
  else
    v15 = v7;
  if (v7 < a6)
    LOBYTE(v13) = -1;
  else
    LOBYTE(v13) = 1;
  if (v7 == a6)
    LOBYTE(v13) = 0;
  if (v15 >= 1)
  {
    v16 = (unsigned __int16 *)(v12 + 2 * v8);
    if (v16 != v14)
    {
      v17 = v15 + 1;
      while (1)
      {
        v18 = *v16 - *v14;
        if (v18)
          break;
        ++v14;
        ++v16;
        if (--v17 <= 1)
          return (char)v13;
      }
      v13 = (v18 >> 15) | 1;
    }
  }
  return (char)v13;
}

uint64_t icu::UnicodeString::doCompareCodePointOrder(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6)
{
  unsigned int v6;
  signed int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned int v16;

  v6 = *(unsigned __int16 *)(a1 + 8);
  if ((v6 & 1) != 0)
  {
    LOBYTE(v10) = -1;
    return (char)v10;
  }
  if ((v6 & 0x8000) == 0)
  {
    v7 = v6 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_4;
LABEL_10:
    v8 = 0;
    goto LABEL_11;
  }
  v7 = *(_DWORD *)(a1 + 12);
  if (a2 < 0)
    goto LABEL_10;
LABEL_4:
  v8 = v7;
  if (v7 >= a2)
  {
    if ((a3 & 0x80000000) == 0)
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_11:
  a2 = v8;
  if ((a3 & 0x80000000) == 0)
  {
LABEL_6:
    v9 = v7 - a2;
    if (v9 >= a3)
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_12:
  v9 = 0;
LABEL_13:
  a3 = v9;
LABEL_14:
  if (a4)
    v11 = a6;
  else
    v11 = 0;
  if ((v6 & 2) != 0)
    v12 = a1 + 10;
  else
    v12 = *(_QWORD *)(a1 + 24);
  v13 = (unsigned __int16 *)(v12 + 2 * a2);
  if (a4)
    v14 = a5;
  else
    v14 = 0;
  v15 = (unsigned __int16 *)(a4 + 2 * v14);
  if (!a4)
    v15 = 0;
  v16 = sub_18BC6D570(v13, a3, v15, v11, 0, 1);
  v10 = (v16 >> 15) | 1;
  if (!v16)
    LOBYTE(v10) = 0;
  return (char)v10;
}

uint64_t icu::UnicodeString::getLength(icu::UnicodeString *this)
{
  if (*((__int16 *)this + 4) < 0)
    return *((unsigned int *)this + 3);
  else
    return *((unsigned __int16 *)this + 4) >> 5;
}

uint64_t icu::UnicodeString::getCharAt(icu::UnicodeString *this, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  char *v4;

  v2 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0)
    v3 = *((_DWORD *)this + 3);
  else
    v3 = v2 >> 5;
  if (v3 <= a2)
    return 0xFFFFLL;
  if ((v2 & 2) != 0)
    v4 = (char *)this + 10;
  else
    v4 = (char *)*((_QWORD *)this + 3);
  return *(unsigned __int16 *)&v4[2 * a2];
}

uint64_t icu::UnicodeString::char32At(icu::UnicodeString *this, int a2)
{
  unsigned int v2;
  unsigned int v3;
  char *v4;
  uint64_t result;
  uint64_t v6;
  int v7;
  int v8;
  int v9;

  v2 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0)
    v3 = *((_DWORD *)this + 3);
  else
    v3 = v2 >> 5;
  if (v3 <= a2)
    return 0xFFFFLL;
  if ((v2 & 2) != 0)
    v4 = (char *)this + 10;
  else
    v4 = (char *)*((_QWORD *)this + 3);
  result = *(unsigned __int16 *)&v4[2 * a2];
  if ((result & 0xF800) == 0xD800)
  {
    if ((result & 0x400) != 0)
    {
      if (a2 >= 1)
      {
        v9 = *(unsigned __int16 *)&v4[2 * (a2 - 1)];
        if ((v9 & 0xFC00) == 0xD800)
        {
          v8 = result + (v9 << 10);
          return (v8 - 56613888);
        }
      }
    }
    else
    {
      v6 = a2 + 1;
      if ((_DWORD)v6 != v3)
      {
        v7 = *(unsigned __int16 *)&v4[2 * v6];
        if ((v7 & 0xFC00) == 0xDC00)
        {
          v8 = v7 + ((_DWORD)result << 10);
          return (v8 - 56613888);
        }
      }
    }
  }
  return result;
}

uint64_t icu::UnicodeString::getChar32Start(icu::UnicodeString *this, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  char *v4;
  unsigned int v5;

  v2 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0)
    v3 = *((_DWORD *)this + 3);
  else
    v3 = v2 >> 5;
  if (v3 <= a2)
    return 0;
  if ((v2 & 2) != 0)
    v4 = (char *)this + 10;
  else
    v4 = (char *)*((_QWORD *)this + 3);
  v5 = a2 - 1;
  if ((int)a2 >= 1 && (*(_WORD *)&v4[2 * (int)a2] & 0xFC00) == 0xDC00)
  {
    if ((*(_WORD *)&v4[2 * v5] & 0xFC00) == 0xD800)
      return v5;
    else
      return a2;
  }
  return a2;
}

uint64_t icu::UnicodeString::getChar32Limit(icu::UnicodeString *this, uint64_t a2)
{
  unsigned int v3;
  uint64_t result;
  char *v5;

  v3 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0)
    result = *((unsigned int *)this + 3);
  else
    result = v3 >> 5;
  if (result > a2)
  {
    if ((v3 & 2) != 0)
      v5 = (char *)this + 10;
    else
      v5 = (char *)*((_QWORD *)this + 3);
    if ((int)a2 >= 1
      && ((int)result > (int)a2 || (result & 0x80000000) != 0)
      && (*(_WORD *)&v5[2 * (a2 - 1)] & 0xFC00) == 0xD800)
    {
      if ((*(_WORD *)&v5[2 * a2] & 0xFC00) == 0xDC00)
        return (a2 + 1);
      else
        return a2;
    }
    else
    {
      return a2;
    }
  }
  return result;
}

uint64_t icu::UnicodeString::countChar32(icu::UnicodeString *this, int a2, int32_t length)
{
  unsigned int v3;
  signed int v4;
  int v5;
  int32_t v6;
  char *v7;

  v3 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    v4 = v3 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_3;
LABEL_9:
    v5 = 0;
    goto LABEL_10;
  }
  v4 = *((_DWORD *)this + 3);
  if (a2 < 0)
    goto LABEL_9;
LABEL_3:
  v5 = v4;
  if (v4 >= a2)
  {
    if ((length & 0x80000000) == 0)
      goto LABEL_5;
LABEL_11:
    v6 = 0;
LABEL_12:
    length = v6;
    if ((v3 & 2) == 0)
      goto LABEL_7;
LABEL_13:
    v7 = (char *)this + 10;
    return u_countChar32((const UChar *)&v7[2 * a2], length);
  }
LABEL_10:
  a2 = v5;
  if (length < 0)
    goto LABEL_11;
LABEL_5:
  v6 = v4 - a2;
  if (v6 < length)
    goto LABEL_12;
  if ((v3 & 2) != 0)
    goto LABEL_13;
LABEL_7:
  v7 = (char *)*((_QWORD *)this + 3);
  return u_countChar32((const UChar *)&v7[2 * a2], length);
}

uint64_t icu::UnicodeString::hasMoreChar32Than(icu::UnicodeString *this, int a2, int32_t length, int32_t number)
{
  unsigned int v4;
  signed int v5;
  int v6;
  int32_t v7;
  char *v8;

  v4 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    v5 = v4 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_3;
LABEL_9:
    v6 = 0;
    goto LABEL_10;
  }
  v5 = *((_DWORD *)this + 3);
  if (a2 < 0)
    goto LABEL_9;
LABEL_3:
  v6 = v5;
  if (v5 >= a2)
  {
    if ((length & 0x80000000) == 0)
      goto LABEL_5;
LABEL_11:
    v7 = 0;
LABEL_12:
    length = v7;
    if ((v4 & 2) == 0)
      goto LABEL_7;
LABEL_13:
    v8 = (char *)this + 10;
    return u_strHasMoreChar32Than((const UChar *)&v8[2 * a2], length, number);
  }
LABEL_10:
  a2 = v6;
  if (length < 0)
    goto LABEL_11;
LABEL_5:
  v7 = v5 - a2;
  if (v7 < length)
    goto LABEL_12;
  if ((v4 & 2) != 0)
    goto LABEL_13;
LABEL_7:
  v8 = (char *)*((_QWORD *)this + 3);
  return u_strHasMoreChar32Than((const UChar *)&v8[2 * a2], length, number);
}

uint64_t icu::UnicodeString::moveIndex32(icu::UnicodeString *this, int a2, int a3)
{
  unsigned int v4;
  int v5;
  unsigned int v6;
  uint64_t result;
  char *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  unsigned int v13;
  int v14;
  unsigned int v16;

  v4 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0)
    v5 = *((_DWORD *)this + 3);
  else
    v5 = v4 >> 5;
  if (v5 >= a2)
    v6 = a2;
  else
    v6 = v5;
  if (a2 >= 0)
    result = v6;
  else
    result = 0;
  if ((v4 & 2) != 0)
    v8 = (char *)this + 10;
  else
    v8 = (char *)*((_QWORD *)this + 3);
  if (a3 >= 1)
  {
    v9 = a3 + 1;
    v10 = result;
    while (1)
    {
      if ((int)v10 >= v5)
      {
        if ((v5 & 0x80000000) == 0)
          return v10;
        v11 = *(_WORD *)&v8[2 * (int)v10];
        if (!v11)
          return v10;
      }
      else
      {
        v11 = *(_WORD *)&v8[2 * (int)v10];
      }
      result = (int)v10 + 1;
      if ((v11 & 0xFC00) == 0xD800 && (_DWORD)result != v5)
      {
        v13 = v10 + 2;
        if ((*(_WORD *)&v8[2 * result] & 0xFC00) == 0xDC00)
          result = v13;
        else
          result = result;
      }
      --v9;
      v10 = result;
      if (v9 <= 1)
        return result;
    }
  }
  if (a3 && (int)result >= 1)
  {
    v14 = -a3;
    do
    {
      result = v6 - 1;
      if ((*(_WORD *)&v8[2 * result] & 0xFC00) == 0xDC00 && v6 >= 2)
      {
        v16 = v6 - 2;
        if ((*(_WORD *)&v8[2 * v16] & 0xFC00) == 0xD800)
          result = v16;
        else
          result = result;
      }
      if (v14 < 2)
        break;
      --v14;
      v6 = result;
    }
    while ((int)result > 0);
  }
  return result;
}

char *icu::UnicodeString::doExtract(char *result, int a2, int a3, uint64_t a4, int a5)
{
  unsigned int v5;
  signed int v6;
  int v7;
  int v8;
  char *v9;
  char *v10;

  v5 = *((unsigned __int16 *)result + 4);
  if ((*((__int16 *)result + 4) & 0x80000000) == 0)
  {
    v6 = v5 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_3;
LABEL_9:
    v7 = 0;
    goto LABEL_10;
  }
  v6 = *((_DWORD *)result + 3);
  if (a2 < 0)
    goto LABEL_9;
LABEL_3:
  v7 = v6;
  if (v6 >= a2)
  {
    if ((a3 & 0x80000000) == 0)
      goto LABEL_5;
LABEL_11:
    v8 = 0;
LABEL_12:
    a3 = v8;
    if ((v5 & 2) == 0)
      goto LABEL_7;
    goto LABEL_13;
  }
LABEL_10:
  a2 = v7;
  if (a3 < 0)
    goto LABEL_11;
LABEL_5:
  v8 = v6 - a2;
  if (v8 < a3)
    goto LABEL_12;
  if ((v5 & 2) == 0)
  {
LABEL_7:
    v9 = (char *)*((_QWORD *)result + 3);
    goto LABEL_14;
  }
LABEL_13:
  v9 = result + 10;
LABEL_14:
  if (a3 >= 1)
  {
    v10 = &v9[2 * a2];
    result = (char *)(a4 + 2 * a5);
    if (v10 != result)
      return (char *)memmove(result, v10, 2 * a3);
  }
  return result;
}

uint64_t icu::UnicodeString::extract(uint64_t a1, UChar **a2, int a3, int *a4)
{
  unsigned int v7;
  uint64_t v8;
  const UChar *v9;
  UChar *v11;

  v7 = *(unsigned __int16 *)(a1 + 8);
  if (*(__int16 *)(a1 + 8) < 0)
    v8 = *(unsigned int *)(a1 + 12);
  else
    v8 = v7 >> 5;
  if (*a4 > 0)
    return v8;
  if (a3 < 0 || (v7 & 1) != 0 || a3 && !*a2)
  {
    *a4 = 1;
    return v8;
  }
  if ((v7 & 2) != 0)
    v9 = (const UChar *)(a1 + 10);
  else
    v9 = *(const UChar **)(a1 + 24);
  v11 = *a2;
  if ((int)v8 >= 1 && (int)v8 <= a3)
  {
    if (v9 == v11)
    {
      v11 = (UChar *)v9;
    }
    else
    {
      u_memcpy(v11, v9, v8);
      v11 = *a2;
    }
  }
  return u_terminateUChars((uint64_t)v11, a3, v8, a4);
}

uint64_t icu::UnicodeString::extract(uint64_t a1, int a2, uint64_t length, char *cs, int a5)
{
  unsigned int v9;
  signed int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;

  if (a5 < 0)
    return 0;
  if (!cs && a5)
    return 0;
  v9 = *(unsigned __int16 *)(a1 + 8);
  if ((*(__int16 *)(a1 + 8) & 0x80000000) == 0)
  {
    v10 = v9 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_8;
LABEL_13:
    v11 = 0;
    goto LABEL_14;
  }
  v10 = *(_DWORD *)(a1 + 12);
  if (a2 < 0)
    goto LABEL_13;
LABEL_8:
  v11 = v10;
  if (v10 >= a2)
  {
    if ((length & 0x80000000) == 0)
      goto LABEL_10;
    goto LABEL_15;
  }
LABEL_14:
  a2 = v11;
  if ((length & 0x80000000) == 0)
  {
LABEL_10:
    v12 = (v10 - a2);
    if ((int)v12 >= (int)length)
      goto LABEL_17;
    goto LABEL_16;
  }
LABEL_15:
  v12 = 0;
LABEL_16:
  length = v12;
LABEL_17:
  if ((int)length <= a5)
  {
    if ((v9 & 2) != 0)
      v13 = a1 + 10;
    else
      v13 = *(_QWORD *)(a1 + 24);
    u_UCharsToChars((const UChar *)(v13 + 2 * a2), cs, length);
  }
  v14 = 0;
  return u_terminateChars((uint64_t)cs, a5, length, &v14);
}

icu::UnicodeString *icu::UnicodeString::tempSubString@<X0>(icu::UnicodeString *this@<X0>, int a2@<W1>, int32_t a3@<W2>, icu::UnicodeString *a4@<X8>)
{
  unsigned int v7;
  signed int v8;
  int v9;
  int32_t v10;
  char *v11;
  const UChar *v13;

  v7 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    v8 = v7 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_3;
LABEL_8:
    v9 = 0;
    goto LABEL_9;
  }
  v8 = *((_DWORD *)this + 3);
  if (a2 < 0)
    goto LABEL_8;
LABEL_3:
  v9 = v8;
  if (v8 >= a2)
  {
    if ((a3 & 0x80000000) == 0)
      goto LABEL_5;
    goto LABEL_10;
  }
LABEL_9:
  a2 = v9;
  if ((a3 & 0x80000000) == 0)
  {
LABEL_5:
    v10 = v8 - a2;
    if (v10 >= a3)
      goto LABEL_12;
    goto LABEL_11;
  }
LABEL_10:
  v10 = 0;
LABEL_11:
  a3 = v10;
LABEL_12:
  if ((v7 & 0x11) != 0)
    goto LABEL_13;
  if ((v7 & 2) != 0)
  {
    v11 = (char *)this + 10;
    goto LABEL_18;
  }
  v11 = (char *)*((_QWORD *)this + 3);
  if (!v11)
  {
LABEL_13:
    v11 = (char *)this + 10;
    a3 = -2;
  }
LABEL_18:
  v13 = (const UChar *)&v11[2 * a2];
  return icu::UnicodeString::UnicodeString(a4, 0, &v13, a3);
}

uint64_t icu::UnicodeString::toUTF8(icu::UnicodeString *this, int a2, int32_t srcLength, char *dest, int32_t destCapacity)
{
  unsigned int v6;
  signed int v7;
  int v8;
  int32_t v9;
  char *v10;
  UErrorCode pErrorCode;
  int32_t pDestLength;

  v6 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    v7 = v6 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_3;
LABEL_8:
    v8 = 0;
    goto LABEL_9;
  }
  v7 = *((_DWORD *)this + 3);
  if (a2 < 0)
    goto LABEL_8;
LABEL_3:
  v8 = v7;
  if (v7 >= a2)
  {
    if ((srcLength & 0x80000000) == 0)
      goto LABEL_5;
LABEL_10:
    v9 = 0;
    goto LABEL_11;
  }
LABEL_9:
  a2 = v8;
  if (srcLength < 0)
    goto LABEL_10;
LABEL_5:
  v9 = v7 - a2;
  if (v9 < srcLength)
LABEL_11:
    srcLength = v9;
  pDestLength = 0;
  pErrorCode = U_ZERO_ERROR;
  if ((v6 & 0x11) != 0)
  {
    v10 = 0;
  }
  else if ((v6 & 2) != 0)
  {
    v10 = (char *)this + 10;
  }
  else
  {
    v10 = (char *)*((_QWORD *)this + 3);
  }
  u_strToUTF8WithSub(dest, destCapacity, &pDestLength, (const UChar *)&v10[2 * a2], srcLength, 65533, 0, &pErrorCode);
  return pDestLength;
}

uint64_t icu::UnicodeString::extract(icu::UnicodeString *this, int a2, int32_t a3, char *a4, int32_t a5)
{
  if (!a4 && a5)
    return 0;
  if (a5 < 0)
    a5 = 0x7FFFFFFF;
  return icu::UnicodeString::toUTF8(this, a2, a3, a4, a5);
}

uint64_t icu::UnicodeString::extractBetween(icu::UnicodeString *this, int a2, unsigned int a3, icu::UnicodeString *a4)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;

  if (a2 < 0)
  {
    v5 = 0;
  }
  else
  {
    v4 = a2;
    if (*((__int16 *)this + 4) < 0)
    {
      v5 = *((_DWORD *)this + 3);
      if (v5 >= a2)
      {
LABEL_4:
        if ((a3 & 0x80000000) == 0)
          goto LABEL_5;
LABEL_11:
        v6 = 0;
        goto LABEL_13;
      }
    }
    else
    {
      v5 = *((unsigned __int16 *)this + 4) >> 5;
      if (v5 >= a2)
        goto LABEL_4;
    }
  }
  v4 = v5;
  if ((a3 & 0x80000000) != 0)
    goto LABEL_11;
LABEL_5:
  if (*((__int16 *)this + 4) < 0)
  {
    v6 = *((_DWORD *)this + 3);
    if (v6 >= (int)a3)
      goto LABEL_14;
    goto LABEL_13;
  }
  v6 = *((unsigned __int16 *)this + 4) >> 5;
  if (v6 < a3)
LABEL_13:
    a3 = v6;
LABEL_14:
  v7 = a3 - v4;
  v8 = *((unsigned __int16 *)a4 + 4);
  v9 = (__int16)v8;
  v10 = v8 >> 5;
  if (v9 >= 0)
    v11 = v10;
  else
    v11 = *((unsigned int *)a4 + 3);
  return icu::UnicodeString::doReplace(a4, 0, v11, this, v4, v7);
}

void icu::UnicodeString::toUTF8(icu::UnicodeString *this, icu::ByteSink *a2)
{
  int32_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  __int16 v8;
  const UChar *v9;
  UErrorCode v10;
  UErrorCode v11;
  char *v12;
  __int16 v13;
  const UChar *v14;
  UErrorCode pErrorCode;
  int32_t pDestLength;
  int32_t destCapacity;
  _BYTE v18[1024];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*((__int16 *)this + 4) < 0)
  {
    v4 = *((_DWORD *)this + 3);
    if (!v4)
      return;
  }
  else
  {
    v4 = *((unsigned __int16 *)this + 4) >> 5;
    if (!v4)
      return;
  }
  bzero(v18, 0x400uLL);
  destCapacity = 1024;
  if (v4 >= 1024)
    v5 = 1024;
  else
    v5 = v4;
  v6 = (char *)(*(uint64_t (**)(icu::ByteSink *, uint64_t, _QWORD, _BYTE *, uint64_t, int32_t *))(*(_QWORD *)a2 + 24))(a2, v5, (3 * v4), v18, 1024, &destCapacity);
  v7 = v6;
  pErrorCode = U_ZERO_ERROR;
  pDestLength = 0;
  v8 = *((_WORD *)this + 4);
  if ((v8 & 0x11) != 0)
  {
    v9 = 0;
  }
  else if ((v8 & 2) != 0)
  {
    v9 = (const UChar *)((char *)this + 10);
  }
  else
  {
    v9 = (const UChar *)*((_QWORD *)this + 3);
  }
  u_strToUTF8WithSub(v6, destCapacity, &pDestLength, v9, v4, 65533, 0, &pErrorCode);
  v10 = pErrorCode;
  v11 = pErrorCode;
  if (pErrorCode == U_BUFFER_OVERFLOW_ERROR)
  {
    v12 = (char *)uprv_malloc(pDestLength);
    if (!v12)
      return;
    v7 = v12;
    pErrorCode = U_ZERO_ERROR;
    v13 = *((_WORD *)this + 4);
    if ((v13 & 0x11) != 0)
    {
      v14 = 0;
    }
    else if ((v13 & 2) != 0)
    {
      v14 = (const UChar *)((char *)this + 10);
    }
    else
    {
      v14 = (const UChar *)*((_QWORD *)this + 3);
    }
    u_strToUTF8WithSub(v12, pDestLength, &pDestLength, v14, v4, 65533, 0, &pErrorCode);
    v11 = pErrorCode;
  }
  if (v11 <= U_ZERO_ERROR)
  {
    (*(void (**)(icu::ByteSink *, char *, _QWORD))(*(_QWORD *)a2 + 16))(a2, v7, pDestLength);
    (*(void (**)(icu::ByteSink *))(*(_QWORD *)a2 + 32))(a2);
  }
  if (v10 == U_BUFFER_OVERFLOW_ERROR)
    uprv_free(v7);
}

uint64_t icu::UnicodeString::toUTF32(icu::UnicodeString *this, UChar32 *dest, int32_t destCapacity, UErrorCode *pErrorCode)
{
  uint64_t v4;
  unsigned int v6;
  const UChar *v7;
  int32_t v8;
  int32_t pDestLength;

  v4 = 0;
  pDestLength = 0;
  if (*(int *)pErrorCode <= 0)
  {
    v6 = *((unsigned __int16 *)this + 4);
    if ((v6 & 0x11) != 0)
    {
      v7 = 0;
      if ((v6 & 0x8000) != 0)
        goto LABEL_9;
LABEL_7:
      v8 = v6 >> 5;
LABEL_10:
      u_strToUTF32WithSub(dest, destCapacity, &pDestLength, v7, v8, 65533, 0, pErrorCode);
      return pDestLength;
    }
    if ((v6 & 2) != 0)
    {
      v7 = (const UChar *)((char *)this + 10);
      if ((v6 & 0x8000) == 0)
        goto LABEL_7;
    }
    else
    {
      v7 = (const UChar *)*((_QWORD *)this + 3);
      if ((v6 & 0x8000) == 0)
        goto LABEL_7;
    }
LABEL_9:
    v8 = *((_DWORD *)this + 3);
    goto LABEL_10;
  }
  return v4;
}

uint64_t icu::UnicodeString::indexOf(uint64_t a1, uint64_t a2, unsigned int a3, int32_t a4, int a5, int32_t length)
{
  uint64_t v6;
  unsigned int v7;
  signed int v8;
  int v9;
  int32_t v10;
  uint64_t v11;
  UChar *First;

  v6 = 0xFFFFFFFFLL;
  if (a4)
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (a2)
      {
        v7 = *(unsigned __int16 *)(a1 + 8);
        if ((v7 & 1) == 0)
        {
          if (a4 < 0 && !*(_WORD *)(a2 + 2 * a3))
            return 0xFFFFFFFFLL;
          if ((v7 & 0x8000) != 0)
          {
            v8 = *(_DWORD *)(a1 + 12);
            if ((a5 & 0x80000000) == 0)
            {
LABEL_9:
              v9 = v8;
              if (v8 >= a5)
              {
                if ((length & 0x80000000) == 0)
                  goto LABEL_11;
                goto LABEL_17;
              }
LABEL_16:
              a5 = v9;
              if ((length & 0x80000000) == 0)
              {
LABEL_11:
                v10 = v8 - a5;
                if (v10 >= length)
                {
                  if ((v7 & 2) == 0)
                  {
LABEL_13:
                    v11 = *(_QWORD *)(a1 + 24);
                    goto LABEL_20;
                  }
LABEL_19:
                  v11 = a1 + 10;
LABEL_20:
                  First = u_strFindFirst((const UChar *)(v11 + 2 * a5), length, (const UChar *)(a2 + 2 * a3), a4);
                  v6 = ((unint64_t)First - v11) >> 1;
                  if (First)
                    return v6;
                  else
                    return 0xFFFFFFFFLL;
                }
LABEL_18:
                length = v10;
                if ((v7 & 2) == 0)
                  goto LABEL_13;
                goto LABEL_19;
              }
LABEL_17:
              v10 = 0;
              goto LABEL_18;
            }
          }
          else
          {
            v8 = v7 >> 5;
            if ((a5 & 0x80000000) == 0)
              goto LABEL_9;
          }
          v9 = 0;
          goto LABEL_16;
        }
      }
    }
  }
  return v6;
}

uint64_t icu::UnicodeString::doIndexOf(uint64_t a1, UChar a2, int a3, int32_t count)
{
  unsigned int v4;
  signed int v5;
  int v6;
  int32_t v7;
  uint64_t v8;
  UChar *v9;

  v4 = *(unsigned __int16 *)(a1 + 8);
  if ((*(__int16 *)(a1 + 8) & 0x80000000) == 0)
  {
    v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0)
      goto LABEL_3;
LABEL_9:
    v6 = 0;
    goto LABEL_10;
  }
  v5 = *(_DWORD *)(a1 + 12);
  if (a3 < 0)
    goto LABEL_9;
LABEL_3:
  v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0)
      goto LABEL_5;
LABEL_11:
    v7 = 0;
LABEL_12:
    count = v7;
    if ((v4 & 2) == 0)
      goto LABEL_7;
    goto LABEL_13;
  }
LABEL_10:
  a3 = v6;
  if (count < 0)
    goto LABEL_11;
LABEL_5:
  v7 = v5 - a3;
  if (v7 < count)
    goto LABEL_12;
  if ((v4 & 2) == 0)
  {
LABEL_7:
    v8 = *(_QWORD *)(a1 + 24);
    goto LABEL_14;
  }
LABEL_13:
  v8 = a1 + 10;
LABEL_14:
  v9 = u_memchr((const UChar *)(v8 + 2 * a3), a2, count);
  if (v9)
    return (((unint64_t)v9 - v8) >> 1);
  else
    return 0xFFFFFFFFLL;
}

uint64_t icu::UnicodeString::doIndexOf(icu::UnicodeString *this, UChar32 a2, int a3, int32_t count)
{
  unsigned int v4;
  signed int v5;
  int v6;
  int32_t v7;
  char *v8;
  UChar *v9;

  v4 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0)
      goto LABEL_3;
LABEL_9:
    v6 = 0;
    goto LABEL_10;
  }
  v5 = *((_DWORD *)this + 3);
  if (a3 < 0)
    goto LABEL_9;
LABEL_3:
  v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0)
      goto LABEL_5;
LABEL_11:
    v7 = 0;
LABEL_12:
    count = v7;
    if ((v4 & 2) == 0)
      goto LABEL_7;
    goto LABEL_13;
  }
LABEL_10:
  a3 = v6;
  if (count < 0)
    goto LABEL_11;
LABEL_5:
  v7 = v5 - a3;
  if (v7 < count)
    goto LABEL_12;
  if ((v4 & 2) == 0)
  {
LABEL_7:
    v8 = (char *)*((_QWORD *)this + 3);
    goto LABEL_14;
  }
LABEL_13:
  v8 = (char *)this + 10;
LABEL_14:
  v9 = u_memchr32((const UChar *)&v8[2 * a3], a2, count);
  if (v9)
    return ((unint64_t)((char *)v9 - v8) >> 1);
  else
    return 0xFFFFFFFFLL;
}

uint64_t icu::UnicodeString::lastIndexOf(uint64_t a1, uint64_t a2, unsigned int a3, int32_t a4, int a5, int32_t length)
{
  uint64_t v6;
  unsigned int v7;
  signed int v8;
  int v9;
  int32_t v10;
  uint64_t v11;
  UChar *Last;

  v6 = 0xFFFFFFFFLL;
  if (a4)
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (a2)
      {
        v7 = *(unsigned __int16 *)(a1 + 8);
        if ((v7 & 1) == 0)
        {
          if (a4 < 0 && !*(_WORD *)(a2 + 2 * a3))
            return 0xFFFFFFFFLL;
          if ((v7 & 0x8000) != 0)
          {
            v8 = *(_DWORD *)(a1 + 12);
            if ((a5 & 0x80000000) == 0)
            {
LABEL_9:
              v9 = v8;
              if (v8 >= a5)
              {
                if ((length & 0x80000000) == 0)
                  goto LABEL_11;
                goto LABEL_17;
              }
LABEL_16:
              a5 = v9;
              if ((length & 0x80000000) == 0)
              {
LABEL_11:
                v10 = v8 - a5;
                if (v10 >= length)
                {
                  if ((v7 & 2) == 0)
                  {
LABEL_13:
                    v11 = *(_QWORD *)(a1 + 24);
                    goto LABEL_20;
                  }
LABEL_19:
                  v11 = a1 + 10;
LABEL_20:
                  Last = u_strFindLast((const UChar *)(v11 + 2 * a5), length, (const UChar *)(a2 + 2 * a3), a4);
                  v6 = ((unint64_t)Last - v11) >> 1;
                  if (Last)
                    return v6;
                  else
                    return 0xFFFFFFFFLL;
                }
LABEL_18:
                length = v10;
                if ((v7 & 2) == 0)
                  goto LABEL_13;
                goto LABEL_19;
              }
LABEL_17:
              v10 = 0;
              goto LABEL_18;
            }
          }
          else
          {
            v8 = v7 >> 5;
            if ((a5 & 0x80000000) == 0)
              goto LABEL_9;
          }
          v9 = 0;
          goto LABEL_16;
        }
      }
    }
  }
  return v6;
}

uint64_t icu::UnicodeString::doLastIndexOf(uint64_t a1, UChar a2, int a3, int32_t count)
{
  unsigned int v4;
  signed int v5;
  int v6;
  int32_t v7;
  uint64_t v8;
  UChar *v10;

  v4 = *(unsigned __int16 *)(a1 + 8);
  if ((v4 & 1) != 0)
    return 0xFFFFFFFFLL;
  if ((v4 & 0x8000) == 0)
  {
    v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0)
      goto LABEL_4;
LABEL_11:
    v6 = 0;
    goto LABEL_12;
  }
  v5 = *(_DWORD *)(a1 + 12);
  if (a3 < 0)
    goto LABEL_11;
LABEL_4:
  v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0)
      goto LABEL_6;
LABEL_13:
    v7 = 0;
LABEL_14:
    count = v7;
    if ((v4 & 2) == 0)
      goto LABEL_8;
    goto LABEL_15;
  }
LABEL_12:
  a3 = v6;
  if (count < 0)
    goto LABEL_13;
LABEL_6:
  v7 = v5 - a3;
  if (v7 < count)
    goto LABEL_14;
  if ((v4 & 2) == 0)
  {
LABEL_8:
    v8 = *(_QWORD *)(a1 + 24);
    goto LABEL_16;
  }
LABEL_15:
  v8 = a1 + 10;
LABEL_16:
  v10 = u_memrchr((const UChar *)(v8 + 2 * a3), a2, count);
  if (v10)
    return (((unint64_t)v10 - v8) >> 1);
  else
    return 0xFFFFFFFFLL;
}

uint64_t icu::UnicodeString::doLastIndexOf(icu::UnicodeString *this, UChar32 a2, int a3, int32_t count)
{
  unsigned int v4;
  signed int v5;
  int v6;
  int32_t v7;
  char *v8;
  UChar *v9;

  v4 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0)
      goto LABEL_3;
LABEL_9:
    v6 = 0;
    goto LABEL_10;
  }
  v5 = *((_DWORD *)this + 3);
  if (a3 < 0)
    goto LABEL_9;
LABEL_3:
  v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0)
      goto LABEL_5;
LABEL_11:
    v7 = 0;
LABEL_12:
    count = v7;
    if ((v4 & 2) == 0)
      goto LABEL_7;
    goto LABEL_13;
  }
LABEL_10:
  a3 = v6;
  if (count < 0)
    goto LABEL_11;
LABEL_5:
  v7 = v5 - a3;
  if (v7 < count)
    goto LABEL_12;
  if ((v4 & 2) == 0)
  {
LABEL_7:
    v8 = (char *)*((_QWORD *)this + 3);
    goto LABEL_14;
  }
LABEL_13:
  v8 = (char *)this + 10;
LABEL_14:
  v9 = u_memrchr32((const UChar *)&v8[2 * a3], a2, count);
  if (v9)
    return ((unint64_t)((char *)v9 - v8) >> 1);
  else
    return 0xFFFFFFFFLL;
}

icu::UnicodeString *icu::UnicodeString::findAndReplace(icu::UnicodeString *this, int a2, int32_t length, const icu::UnicodeString *a4, signed int a5, uint64_t a6, const icu::UnicodeString *a7, int a8, int a9)
{
  unsigned int v10;
  unsigned int v12;
  unsigned int v14;
  int v15;
  uint64_t v16;
  signed int v17;
  int32_t v18;
  int v19;
  int v20;
  int v21;
  int32_t v22;
  int v23;
  signed int v24;
  signed int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  signed int v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int32_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  char *v43;

  v10 = *((unsigned __int16 *)this + 4);
  if ((v10 & 1) != 0)
    return this;
  v12 = *((unsigned __int16 *)a4 + 4);
  if ((v12 & 1) != 0)
    return this;
  v14 = *((unsigned __int16 *)a7 + 4);
  if ((v14 & 1) != 0)
    return this;
  v15 = a8;
  v16 = a6;
  v17 = a5;
  v18 = length;
  v19 = a2;
  if ((v10 & 0x8000) == 0)
  {
    v20 = v10 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_6;
LABEL_11:
    v21 = 0;
    goto LABEL_12;
  }
  v20 = *((_DWORD *)this + 3);
  if (a2 < 0)
    goto LABEL_11;
LABEL_6:
  v21 = v20;
  if (v20 >= a2)
  {
    if ((length & 0x80000000) == 0)
      goto LABEL_8;
LABEL_13:
    v22 = 0;
    goto LABEL_14;
  }
LABEL_12:
  v19 = v21;
  if (length < 0)
    goto LABEL_13;
LABEL_8:
  v22 = v20 - v19;
  if (v22 < length)
LABEL_14:
    v18 = v22;
  v23 = (__int16)v12;
  v24 = v12 >> 5;
  if (v23 < 0)
    v24 = *((_DWORD *)a4 + 3);
  if (a5 < 0)
  {
    v25 = 0;
    goto LABEL_21;
  }
  v25 = v24;
  if (v24 < a5)
LABEL_21:
    v17 = v25;
  v26 = a9;
  if ((a6 & 0x80000000) != 0)
  {
    v27 = 0;
    goto LABEL_26;
  }
  v27 = (v24 - v17);
  if ((int)v27 < (int)a6)
LABEL_26:
    v16 = v27;
  v28 = (__int16)v14;
  v29 = v14 >> 5;
  if (v28 < 0)
    v29 = *((_DWORD *)a7 + 3);
  if (a8 < 0)
  {
    v30 = 0;
  }
  else
  {
    v30 = v29;
    if (v29 >= a8)
    {
      if ((a9 & 0x80000000) == 0)
        goto LABEL_32;
      goto LABEL_36;
    }
  }
  v15 = v30;
  if ((a9 & 0x80000000) == 0)
  {
LABEL_32:
    v31 = (v29 - v15);
    if ((int)v31 >= a9)
      goto LABEL_38;
    goto LABEL_37;
  }
LABEL_36:
  v31 = 0;
LABEL_37:
  v26 = v31;
LABEL_38:
  if ((_DWORD)v16 && v18 >= 1 && v18 >= (int)v16)
  {
    v43 = (char *)a4 + 10;
    while (1)
    {
      v32 = *((unsigned __int16 *)a4 + 4);
      if ((v32 & 1) != 0)
        return this;
      if ((v32 & 0x8000u) == 0)
        v33 = v32 >> 5;
      else
        v33 = *((_DWORD *)a4 + 3);
      if (v17 < 0)
      {
        v34 = 0;
      }
      else
      {
        v34 = v33;
        v35 = v17;
        if (v33 >= v17)
        {
          if ((v16 & 0x80000000) != 0)
            goto LABEL_53;
          goto LABEL_49;
        }
      }
      v35 = v34;
      if ((v16 & 0x80000000) != 0)
      {
LABEL_53:
        v36 = 0;
LABEL_54:
        v37 = v36;
        goto LABEL_55;
      }
LABEL_49:
      v36 = v33 - v35;
      v37 = v16;
      if (v36 < (int)v16)
        goto LABEL_54;
LABEL_55:
      if (v37 >= 1)
      {
        v38 = (v32 & 2) != 0 ? (uint64_t)v43 : *((_QWORD *)a4 + 3);
        v39 = icu::UnicodeString::indexOf((uint64_t)this, v38, v35, v37, v19, v18);
        if ((v39 & 0x80000000) == 0)
        {
          v40 = v39;
          icu::UnicodeString::doReplace(this, v39, v16, a7, v15, v26);
          v18 = v19 + v18 - v16 - v40;
          v19 = v40 + v26;
          if (v18 >= 1 && v18 >= (int)v16)
            continue;
        }
      }
      return this;
    }
  }
  return this;
}

uint64_t icu::UnicodeString::unBogus(uint64_t this)
{
  if ((*(_WORD *)(this + 8) & 1) != 0)
    *(_WORD *)(this + 8) = 2;
  return this;
}

uint64_t icu::UnicodeString::getTerminatedBuffer(icu::UnicodeString *this)
{
  unsigned int v1;
  uint64_t result;
  int v4;
  int v5;
  unsigned int v6;

  v1 = *((unsigned __int16 *)this + 4);
  if ((v1 & 0x11) != 0)
    return 0;
  if ((v1 & 2) == 0)
  {
    result = *((_QWORD *)this + 3);
    if ((v1 & 0x8000) == 0)
      goto LABEL_6;
LABEL_9:
    v4 = *((_DWORD *)this + 3);
    if ((v1 & 2) == 0)
      goto LABEL_7;
    goto LABEL_10;
  }
  result = (uint64_t)this + 10;
  if ((v1 & 0x8000) != 0)
    goto LABEL_9;
LABEL_6:
  v4 = v1 >> 5;
  if ((v1 & 2) == 0)
  {
LABEL_7:
    v5 = *((_DWORD *)this + 4);
    goto LABEL_11;
  }
LABEL_10:
  v5 = 27;
LABEL_11:
  if (v4 >= v5)
  {
    if (v4 == 0x7FFFFFFF)
      return 0;
    goto LABEL_19;
  }
  if ((v1 & 8) == 0)
  {
    if ((v1 & 4) == 0)
      goto LABEL_23;
    v6 = atomic_load((unsigned int *)(*((_QWORD *)this + 3) - 4));
    if (v6 == 1)
      goto LABEL_23;
LABEL_19:
    if (icu::UnicodeString::cloneArrayIfNeeded(this, v4 + 1, -1, 1, 0, 0))
    {
      if ((*((_WORD *)this + 4) & 2) != 0)
        result = (uint64_t)this + 10;
      else
        result = *((_QWORD *)this + 3);
LABEL_23:
      *(_WORD *)(result + 2 * v4) = 0;
      return result;
    }
    return 0;
  }
  if (*(_WORD *)(result + 2 * v4))
    goto LABEL_19;
  return result;
}

icu::UnicodeString *icu::UnicodeString::setTo(icu::UnicodeString *this, int a2, const UChar **a3, int a4)
{
  __int16 v5;
  const UChar *v6;
  int32_t v7;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  int32_t v15;
  __int16 v16;

  v5 = *((_WORD *)this + 4);
  if ((v5 & 0x10) == 0)
  {
    v6 = *a3;
    if (*a3)
    {
      v7 = a4;
      if (a4 < -1 || !a2 && a4 == -1 || a2 && (a4 & 0x80000000) == 0 && v6[a4])
      {
        icu::UnicodeString::setToBogus(this);
      }
      else
      {
        if ((v5 & 4) != 0)
        {
          v12 = (unsigned int *)(*((_QWORD *)this + 3) - 4);
          do
          {
            v13 = __ldaxr(v12);
            v14 = v13 - 1;
          }
          while (__stlxr(v14, v12));
          if (!v14)
            uprv_free((void *)(*((_QWORD *)this + 3) - 4));
        }
        if (v7 == -1)
          v7 = u_strlen(v6);
        if (a2)
          v15 = v7 + 1;
        else
          v15 = v7;
        if (v7 > 1023)
        {
          *((_DWORD *)this + 3) = v7;
          v16 = -24;
        }
        else
        {
          v16 = (32 * v7) | 8;
        }
        *((_WORD *)this + 4) = v16;
        *((_QWORD *)this + 3) = v6;
        *((_DWORD *)this + 4) = v15;
      }
    }
    else
    {
      if ((v5 & 4) != 0)
      {
        v9 = (unsigned int *)(*((_QWORD *)this + 3) - 4);
        do
        {
          v10 = __ldaxr(v9);
          v11 = v10 - 1;
        }
        while (__stlxr(v11, v9));
        if (!v11)
          uprv_free((void *)(*((_QWORD *)this + 3) - 4));
      }
      *((_WORD *)this + 4) = 2;
    }
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::setTo(icu::UnicodeString *this, char *a2, int a3, unsigned int a4)
{
  __int16 v5;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  __int16 v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;

  v5 = *((_WORD *)this + 4);
  if ((v5 & 0x10) == 0)
  {
    if (a2)
    {
      LODWORD(v8) = a3;
      if (a3 > (int)a4 || a3 < -1 || (a4 & 0x80000000) != 0)
      {
        icu::UnicodeString::setToBogus(this);
      }
      else
      {
        if (a3 == -1)
        {
          v9 = a2;
          if (a4)
          {
            v10 = 2 * a4;
            v9 = a2;
            while (*(_WORD *)v9)
            {
              v9 += 2;
              v10 -= 2;
              if (!v10)
              {
                v9 = &a2[2 * a4];
                break;
              }
            }
          }
          v8 = (unint64_t)(v9 - a2) >> 1;
        }
        if ((v5 & 4) != 0)
        {
          v11 = (unsigned int *)(*((_QWORD *)this + 3) - 4);
          do
          {
            v12 = __ldaxr(v11);
            v13 = v12 - 1;
          }
          while (__stlxr(v13, v11));
          if (!v13)
            uprv_free((void *)(*((_QWORD *)this + 3) - 4));
        }
        if ((int)v8 > 1023)
        {
          *((_DWORD *)this + 3) = v8;
          v14 = -32;
        }
        else
        {
          v14 = 32 * v8;
        }
        *((_WORD *)this + 4) = v14;
        *((_QWORD *)this + 3) = a2;
        *((_DWORD *)this + 4) = a4;
      }
    }
    else
    {
      if ((v5 & 4) != 0)
      {
        v15 = (unsigned int *)(*((_QWORD *)this + 3) - 4);
        do
        {
          v16 = __ldaxr(v15);
          v17 = v16 - 1;
        }
        while (__stlxr(v17, v15));
        if (!v17)
          uprv_free((void *)(*((_QWORD *)this + 3) - 4));
      }
      *((_WORD *)this + 4) = 2;
    }
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::setCharAt(icu::UnicodeString *this, int a2, __int16 a3)
{
  int v6;
  int v7;
  char *v8;

  if (*((__int16 *)this + 4) < 0)
    v6 = *((_DWORD *)this + 3);
  else
    v6 = *((unsigned __int16 *)this + 4) >> 5;
  if (icu::UnicodeString::cloneArrayIfNeeded(this, -1, -1, 1, 0, 0))
  {
    v7 = v6 - 1;
    if (v6 >= 1)
    {
      if (v6 > a2)
        v7 = a2;
      if (a2 < 0)
        v7 = 0;
      if ((*((_WORD *)this + 4) & 2) != 0)
        v8 = (char *)this + 10;
      else
        v8 = (char *)*((_QWORD *)this + 3);
      *(_WORD *)&v8[2 * v7] = a3;
    }
  }
  return this;
}

uint64_t icu::UnicodeString::replace(icu::UnicodeString *this, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  int v6;

  v6 = 0;
  if (HIWORD(a4))
  {
    if (HIWORD(a4) > 0x10u)
    {
      v4 = 0;
    }
    else
    {
      LOWORD(v6) = (a4 >> 10) - 10304;
      HIWORD(v6) = a4 & 0x3FF | 0xDC00;
      v4 = 2;
    }
  }
  else
  {
    LOWORD(v6) = a4;
    v4 = 1;
  }
  return icu::UnicodeString::doReplace((uint64_t)this, a2, a3, (uint64_t)&v6, 0, v4);
}

uint64_t icu::UnicodeString::doReplace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 v12;
  int32_t v13;
  uint64_t v14;
  int v15;
  const UChar *v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  const UChar *v22;
  _BOOL4 v23;
  int v24;
  unsigned int v25;
  _BYTE *v26;
  int v27;
  int v28;
  int v29;
  UChar *v30;
  int v31;
  int v32;
  const UChar *v33;
  __int16 v34;
  void *v35;
  _BYTE dest[56];
  uint64_t v37;
  uint64_t v38;

  v6 = a1;
  v38 = *MEMORY[0x1E0C80C00];
  v7 = *(unsigned __int16 *)(a1 + 8);
  if ((v7 & 0x11) != 0)
    return v6;
  v9 = a6;
  v10 = a3;
  v11 = a2;
  v12 = *(_WORD *)(a1 + 8);
  if ((__int16)v7 < 0)
  {
    v13 = *(_DWORD *)(a1 + 12);
    if ((_DWORD)a6)
      goto LABEL_21;
  }
  else
  {
    v13 = v7 >> 5;
    if ((_DWORD)a6)
      goto LABEL_21;
  }
  if ((v7 & 8) == 0)
    goto LABEL_21;
  if (!(_DWORD)a2)
  {
    if ((a3 & 0x80000000) != 0)
    {
      v15 = 0;
    }
    else if ((__int16)v7 < 0)
    {
      v15 = *(_DWORD *)(a1 + 12);
      if (v15 >= (int)a3)
        goto LABEL_53;
    }
    else
    {
      v15 = v7 >> 5;
      if (v15 >= a3)
      {
LABEL_53:
        *(_QWORD *)(a1 + 24) += 2 * (int)v10;
        *(_DWORD *)(a1 + 16) -= v10;
        v24 = v13 - v10;
        if (v13 - (int)v10 > 1023)
        {
          *(_WORD *)(a1 + 8) = v12 | 0xFFE0;
          *(_DWORD *)(a1 + 12) = v24;
        }
        else
        {
          *(_WORD *)(a1 + 8) = v12 & 0x1F | (32 * v24);
        }
        return v6;
      }
    }
    LODWORD(v10) = v15;
    goto LABEL_53;
  }
  if ((a2 & 0x80000000) != 0)
  {
    v14 = 0;
    goto LABEL_19;
  }
  if ((__int16)v7 < 0)
  {
    v14 = *(unsigned int *)(a1 + 12);
    if ((int)v14 >= (int)a2)
      goto LABEL_20;
    goto LABEL_19;
  }
  v14 = v7 >> 5;
  if (v14 < a2)
LABEL_19:
    v11 = v14;
LABEL_20:
  if (v13 - (int)v11 <= (int)a3)
  {
    if ((int)v11 > 1023)
    {
      v17 = v12 | 0xFFE0;
      *(_DWORD *)(a1 + 12) = v11;
    }
    else
    {
      v17 = *(_WORD *)(a1 + 8) & 0x1F | (32 * v11);
    }
    *(_WORD *)(a1 + 8) = v17;
    *(_DWORD *)(a1 + 16) = v11;
    return v6;
  }
LABEL_21:
  if ((_DWORD)v11 != v13)
  {
    if (a4)
    {
      v16 = (const UChar *)(a4 + 2 * a5);
      if ((a6 & 0x80000000) != 0)
      {
        v9 = u_strlen((const UChar *)(a4 + 2 * a5));
        v12 = *(_WORD *)(v6 + 8);
      }
    }
    else
    {
      v16 = 0;
      v9 = 0;
    }
    if ((v12 & 0x8000) != 0)
    {
      v18 = *(unsigned int *)(v6 + 12);
      if ((v11 & 0x80000000) == 0)
      {
LABEL_31:
        v19 = v18;
        if ((int)v11 <= (int)v18)
        {
          if ((v10 & 0x80000000) == 0)
            goto LABEL_33;
          goto LABEL_38;
        }
LABEL_37:
        v11 = v19;
        if ((v10 & 0x80000000) == 0)
        {
LABEL_33:
          v20 = (v18 - v11);
          if ((int)v20 >= (int)v10)
          {
LABEL_40:
            if ((int)v9 > (int)((v13 - v10) ^ 0x7FFFFFFF))
            {
              icu::UnicodeString::setToBogus((icu::UnicodeString *)v6);
              return v6;
            }
            v21 = v12 & 2;
            if ((v12 & 2) != 0)
              v22 = (const UChar *)(v6 + 10);
            else
              v22 = *(const UChar **)(v6 + 24);
            if ((v12 & 0x19) == 0)
            {
              if ((v12 & 4) != 0)
              {
                v25 = atomic_load((unsigned int *)(*(_QWORD *)(v6 + 24) - 4));
                v23 = v25 == 1;
              }
              else
              {
                v23 = 1;
              }
              if (v23 && v22 < &v16[(int)v9] && v16 < &v22[v13])
              {
                memset(&dest[8], 0, 48);
                v37 = 0;
                *(_QWORD *)dest = off_1E2256B38;
                *(_WORD *)&dest[8] = 2;
                icu::UnicodeString::doAppend((uint64_t)dest, (uint64_t)v16, 0, v9);
                if ((dest[8] & 1) != 0)
                {
                  icu::UnicodeString::setToBogus((icu::UnicodeString *)v6);
                }
                else
                {
                  if ((dest[8] & 2) != 0)
                    v26 = &dest[10];
                  else
                    v26 = *(_BYTE **)&dest[24];
                  v6 = icu::UnicodeString::doReplace(v6, v11, v10, v26, 0, v9);
                }
                icu::UnicodeString::~UnicodeString((icu::UnicodeString *)dest);
                return v6;
              }
              v21 = *(_WORD *)(v6 + 8) & 2;
            }
            v27 = v13 - v10 + v9;
            memset(dest, 0, 54);
            if (v21 && v27 >= 28)
            {
              u_memcpy((UChar *)dest, v22, v13);
              v22 = (const UChar *)dest;
            }
            v35 = 0;
            v28 = (v27 >> 2) + 128;
            if (v28 <= 2147483637 - v27)
              v29 = v28 + v27;
            else
              v29 = 2147483637;
            if (!icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)v6, v27, v29, 0, (unsigned int **)&v35, 0))return v6;
            if ((*(_WORD *)(v6 + 8) & 2) != 0)
              v30 = (UChar *)(v6 + 10);
            else
              v30 = *(UChar **)(v6 + 24);
            if (v30 == v22)
            {
              if ((_DWORD)v10 == (_DWORD)v9)
                goto LABEL_85;
              v31 = v10 + v11;
              v32 = v13 - (v10 + v11);
              if (v32 < 1)
                goto LABEL_85;
              v33 = v22;
            }
            else
            {
              if ((int)v11 >= 1)
                memmove(v30, v22, 2 * v11);
              v31 = v10 + v11;
              v32 = v13 - (v10 + v11);
              if (v13 <= (int)v10 + (int)v11)
                goto LABEL_85;
              v33 = v30;
            }
            memmove((void *)&v33[(int)v11 + (int)v9], &v22[v31], 2 * v32);
LABEL_85:
            if ((int)v9 >= 1)
              memmove(&v30[(int)v11], v16, 2 * v9);
            if (v27 > 1023)
            {
              v34 = *(_WORD *)(v6 + 8) | 0xFFE0;
              *(_DWORD *)(v6 + 12) = v27;
            }
            else
            {
              v34 = *(_WORD *)(v6 + 8) & 0x1F | (32 * v27);
            }
            *(_WORD *)(v6 + 8) = v34;
            if (v35)
              uprv_free(v35);
            return v6;
          }
LABEL_39:
          v10 = v20;
          goto LABEL_40;
        }
LABEL_38:
        v20 = 0;
        goto LABEL_39;
      }
    }
    else
    {
      v18 = v12 >> 5;
      if ((v11 & 0x80000000) == 0)
        goto LABEL_31;
    }
    v19 = 0;
    goto LABEL_37;
  }
  return icu::UnicodeString::doAppend(a1, a4, a5, a6);
}

uint64_t icu::UnicodeString::doReplace(icu::UnicodeString *this, uint64_t a2, uint64_t a3, const icu::UnicodeString *a4, int a5, uint64_t a6)
{
  unsigned int v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;

  v6 = *((unsigned __int16 *)a4 + 4);
  if ((v6 & 0x8000u) == 0)
    v7 = v6 >> 5;
  else
    v7 = *((_DWORD *)a4 + 3);
  if (a5 < 0)
  {
    v8 = 0;
  }
  else
  {
    v8 = v7;
    if (v7 >= a5)
    {
      if ((a6 & 0x80000000) == 0)
        goto LABEL_7;
LABEL_11:
      v9 = 0;
      goto LABEL_12;
    }
  }
  a5 = v8;
  if ((a6 & 0x80000000) != 0)
    goto LABEL_11;
LABEL_7:
  v9 = (v7 - a5);
  if ((int)v9 < (int)a6)
LABEL_12:
    a6 = v9;
  if ((v6 & 2) != 0)
    v10 = (char *)a4 + 10;
  else
    v10 = (char *)*((_QWORD *)a4 + 3);
  return icu::UnicodeString::doReplace((uint64_t)this, a2, a3, (uint64_t)v10, a5, a6);
}

uint64_t icu::UnicodeString::doAppend(uint64_t this, const icu::UnicodeString *a2, int a3, uint64_t a4)
{
  unsigned int v4;
  int v5;
  int v6;
  uint64_t v7;
  char *v8;

  if (!(_DWORD)a4)
    return this;
  v4 = *((unsigned __int16 *)a2 + 4);
  if ((v4 & 0x8000u) == 0)
    v5 = v4 >> 5;
  else
    v5 = *((_DWORD *)a2 + 3);
  if (a3 < 0)
  {
    v6 = 0;
  }
  else
  {
    v6 = v5;
    if (v5 >= a3)
    {
      if ((a4 & 0x80000000) == 0)
        goto LABEL_8;
      goto LABEL_13;
    }
  }
  a3 = v6;
  if ((a4 & 0x80000000) == 0)
  {
LABEL_8:
    v7 = (v5 - a3);
    if ((int)v7 >= (int)a4)
      goto LABEL_15;
    goto LABEL_14;
  }
LABEL_13:
  v7 = 0;
LABEL_14:
  a4 = v7;
LABEL_15:
  if ((v4 & 2) != 0)
    v8 = (char *)a2 + 10;
  else
    v8 = (char *)*((_QWORD *)a2 + 3);
  return icu::UnicodeString::doAppend(this, (uint64_t)v8, a3, a4);
}

uint64_t icu::UnicodeString::handleReplaceBetween(icu::UnicodeString *this, uint64_t a2, int a3, const icu::UnicodeString *a4)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;

  v4 = (a3 - a2);
  v5 = *((unsigned __int16 *)a4 + 4);
  v6 = (__int16)v5;
  v7 = v5 >> 5;
  if (v6 >= 0)
    v8 = v7;
  else
    v8 = *((unsigned int *)a4 + 3);
  return icu::UnicodeString::doReplace(this, a2, v4, a4, 0, v8);
}

void icu::UnicodeString::copy(icu::UnicodeString *this, int a2, int a3, uint64_t a4)
{
  uint64_t v4;
  int v6;
  int v7;
  void *v9;
  void *v10;
  int v11;
  int v12;

  v4 = (a3 - a2);
  if (a3 > a2)
  {
    v6 = a3;
    v7 = a2;
    v9 = uprv_malloc(2 * (int)v4);
    if (v9)
    {
      v10 = v9;
      if (v7 < 0)
      {
        v11 = 0;
      }
      else if (*((__int16 *)this + 4) < 0)
      {
        v11 = *((_DWORD *)this + 3);
        if (v11 >= v7)
        {
LABEL_6:
          if ((v6 & 0x80000000) == 0)
            goto LABEL_7;
          goto LABEL_14;
        }
      }
      else
      {
        v11 = *((unsigned __int16 *)this + 4) >> 5;
        if (v11 >= v7)
          goto LABEL_6;
      }
      v7 = v11;
      if ((v6 & 0x80000000) == 0)
      {
LABEL_7:
        if (*((__int16 *)this + 4) < 0)
        {
          v12 = *((_DWORD *)this + 3);
          if (v12 >= v6)
          {
LABEL_17:
            icu::UnicodeString::doExtract((char *)this, v7, v6 - v7, (uint64_t)v9, 0);
            icu::UnicodeString::doReplace((uint64_t)this, a4, 0, (uint64_t)v10, 0, v4);
            uprv_free(v10);
            return;
          }
        }
        else
        {
          v12 = *((unsigned __int16 *)this + 4) >> 5;
          if (v12 >= v6)
            goto LABEL_17;
        }
LABEL_16:
        v6 = v12;
        goto LABEL_17;
      }
LABEL_14:
      v12 = 0;
      goto LABEL_16;
    }
  }
}

uint64_t icu::Replaceable::hasMetaData(icu::Replaceable *this)
{
  return 1;
}

uint64_t icu::UnicodeString::hasMetaData(icu::UnicodeString *this)
{
  return 0;
}

icu::UnicodeString *icu::UnicodeString::doReverse(icu::UnicodeString *this, int a2, int a3)
{
  int v4;
  unsigned int v6;
  signed int v7;
  int v8;
  int v9;
  icu::UnicodeString *v10;
  int v11;
  __int16 *v12;
  unint64_t v13;
  __int16 v14;
  _BOOL4 v15;
  __int16 v16;
  BOOL v17;
  icu::UnicodeString *v18;
  __int16 *v19;
  unint64_t v20;
  __int16 v21;
  __int16 v22;

  if (a3 < 2)
    return this;
  v4 = a3;
  if (!icu::UnicodeString::cloneArrayIfNeeded(this, -1, -1, 1, 0, 0))
    return this;
  v6 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    v7 = v6 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_5;
LABEL_8:
    v8 = 0;
    goto LABEL_9;
  }
  v7 = *((_DWORD *)this + 3);
  if (a2 < 0)
    goto LABEL_8;
LABEL_5:
  v8 = v7;
  if (v7 < a2)
LABEL_9:
    a2 = v8;
  v9 = v7 - a2;
  if (v9 >= v4 || (v4 = v9, v9 >= 2))
  {
    v10 = (v6 & 2) != 0 ? (icu::UnicodeString *)((char *)this + 10) : (icu::UnicodeString *)*((_QWORD *)this + 3);
    v11 = 0;
    v12 = (__int16 *)((char *)v10 + 2 * a2);
    v13 = (unint64_t)v10 + 2 * a2 + 2 * v4 - 4;
    do
    {
      v14 = *v12;
      v15 = (*v12 & 0xFC00) == 55296;
      v16 = *(_WORD *)(v13 + 2);
      *v12++ = v16;
      v11 |= v15 || (v16 & 0xFC00) == 55296;
      *(_WORD *)(v13 + 2) = v14;
      v17 = (unint64_t)v12 >= v13;
      v13 -= 2;
    }
    while (!v17);
    if (v11 | ((*v12 & 0xFC00) == 55296))
    {
      v18 = (*((_WORD *)this + 4) & 2) != 0
          ? (icu::UnicodeString *)((char *)this + 10)
          : (icu::UnicodeString *)*((_QWORD *)this + 3);
      v19 = (__int16 *)((char *)v18 + 2 * a2);
      v20 = (unint64_t)&v19[v4 - 1];
      while ((unint64_t)v19 < v20)
      {
        v21 = *v19;
        if ((*v19 & 0xFC00) == 0xDC00 && (v22 = v19[1], (v22 & 0xFC00) == 0xD800))
        {
          *v19 = v22;
          v19[1] = v21;
          v19 += 2;
        }
        else
        {
          ++v19;
        }
      }
    }
  }
  return this;
}

uint64_t icu::UnicodeString::padLeading(icu::UnicodeString *this, int a2, __int16 a3)
{
  int v6;
  int v7;
  uint64_t result;
  char *v9;
  uint64_t v10;

  if (*((__int16 *)this + 4) < 0)
    v6 = *((_DWORD *)this + 3);
  else
    v6 = *((unsigned __int16 *)this + 4) >> 5;
  v7 = a2 - v6;
  if (a2 <= v6)
    return 0;
  result = icu::UnicodeString::cloneArrayIfNeeded(this, a2, -1, 1, 0, 0);
  if ((_DWORD)result)
  {
    if ((*((_WORD *)this + 4) & 2) != 0)
      v9 = (char *)this + 10;
    else
      v9 = (char *)*((_QWORD *)this + 3);
    if (v6 >= 1)
      memmove(&v9[2 * v7], v9, 2 * v6);
    if (v7 >= 1)
    {
      v10 = -1;
      do
        *(_WORD *)&v9[2 * (v7 + v10--)] = a3;
      while (v7 + (int)v10 + 2 > 1);
    }
    if (a2 > 1023)
    {
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = a2;
    }
    else
    {
      *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * a2);
    }
    return 1;
  }
  return result;
}

uint64_t icu::UnicodeString::padTrailing(icu::UnicodeString *this, int a2, __int16 a3)
{
  int v6;
  uint64_t result;
  char *v8;
  uint64_t v9;
  char *v10;

  if (*((__int16 *)this + 4) < 0)
    v6 = *((_DWORD *)this + 3);
  else
    v6 = *((unsigned __int16 *)this + 4) >> 5;
  if (v6 >= a2)
    return 0;
  result = icu::UnicodeString::cloneArrayIfNeeded(this, a2, -1, 1, 0, 0);
  if ((_DWORD)result)
  {
    if ((*((_WORD *)this + 4) & 2) != 0)
      v8 = (char *)this + 10;
    else
      v8 = (char *)*((_QWORD *)this + 3);
    v9 = a2;
    v10 = v8 - 2;
    do
      *(_WORD *)&v10[2 * v9--] = a3;
    while (v9 > v6);
    if (a2 > 1023)
    {
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = a2;
    }
    else
    {
      *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * a2);
    }
    return 1;
  }
  return result;
}

uint64_t icu::UnicodeString::doHashCode(icu::UnicodeString *this)
{
  unsigned int v2;
  unsigned __int16 *v3;
  int v4;
  uint64_t result;

  v2 = *((unsigned __int16 *)this + 4);
  if ((v2 & 2) != 0)
  {
    v3 = (unsigned __int16 *)((char *)this + 10);
    if ((v2 & 0x8000) == 0)
      goto LABEL_3;
  }
  else
  {
    v3 = (unsigned __int16 *)*((_QWORD *)this + 3);
    if ((v2 & 0x8000) == 0)
    {
LABEL_3:
      v4 = v2 >> 5;
      goto LABEL_6;
    }
  }
  v4 = *((_DWORD *)this + 3);
LABEL_6:
  LODWORD(result) = ustr_hashUCharsN(v3, v4);
  if (result <= 1)
    return 1;
  else
    return result;
}

void icu::UnicodeStringAppendable::~UnicodeStringAppendable(icu::UnicodeStringAppendable *this)
{
  void *v1;

  icu::Appendable::~Appendable(this);
  icu::UMemory::operator delete(v1);
}

BOOL icu::UnicodeStringAppendable::appendCodeUnit(uint64_t a1, __int16 a2)
{
  __int16 v3;

  v3 = a2;
  return (*(_WORD *)(icu::UnicodeString::doAppend(*(_QWORD *)(a1 + 8), (uint64_t)&v3, 0, 1) + 8) & 0x11) == 0;
}

BOOL icu::UnicodeStringAppendable::appendCodePoint(icu::UnicodeStringAppendable *this, unsigned int a2)
{
  uint64_t v2;
  int v4;

  v4 = 0;
  if (!HIWORD(a2))
  {
    LOWORD(v4) = a2;
    v2 = 1;
    return (*(_WORD *)(icu::UnicodeString::doAppend(*((_QWORD *)this + 1), (uint64_t)&v4, 0, v2) + 8) & 0x11) == 0;
  }
  if (HIWORD(a2) <= 0x10u)
  {
    LOWORD(v4) = (a2 >> 10) - 10304;
    HIWORD(v4) = a2 & 0x3FF | 0xDC00;
    v2 = 2;
    return (*(_WORD *)(icu::UnicodeString::doAppend(*((_QWORD *)this + 1), (uint64_t)&v4, 0, v2) + 8) & 0x11) == 0;
  }
  return 0;
}

BOOL icu::UnicodeStringAppendable::appendString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_WORD *)(icu::UnicodeString::doAppend(*(_QWORD *)(a1 + 8), a2, 0, a3) + 8) & 0x11) == 0;
}

uint64_t icu::UnicodeStringAppendable::reserveAppendCapacity(icu::UnicodeStringAppendable *this, int a2)
{
  uint64_t v2;
  int v3;

  v2 = *((_QWORD *)this + 1);
  if (*(__int16 *)(v2 + 8) < 0)
    v3 = *(_DWORD *)(v2 + 12);
  else
    v3 = *(unsigned __int16 *)(v2 + 8) >> 5;
  return icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)v2, v3 + a2, -1, 1, 0, 0);
}

uint64_t icu::UnicodeStringAppendable::getAppendBuffer(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int *a6)
{
  uint64_t v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  int v14;
  uint64_t v15;

  if (a2 < 1 || a5 < a2)
  {
    a4 = 0;
    *a6 = 0;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 8);
    if (*(__int16 *)(v10 + 8) < 0)
      v11 = *(_DWORD *)(v10 + 12);
    else
      v11 = *(unsigned __int16 *)(v10 + 8) >> 5;
    v12 = 2147483637 - v11 < a2 || 2147483637 - v11 < a3;
    if (v12
      || !icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)v10, v11 + a2, v11 + a3, 1, 0, 0))
    {
      *a6 = a5;
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 8);
      if ((*(_WORD *)(v13 + 8) & 2) != 0)
        v14 = 27;
      else
        v14 = *(_DWORD *)(v13 + 16);
      *a6 = v14 - v11;
      if ((*(_WORD *)(v13 + 8) & 2) != 0)
        v15 = v13 + 10;
      else
        v15 = *(_QWORD *)(v13 + 24);
      return v15 + 2 * v11;
    }
  }
  return a4;
}

icu::UnicodeString *uhash_hashUnicodeString(icu::UnicodeString *result)
{
  if (result)
    return (icu::UnicodeString *)icu::UnicodeString::doHashCode(result);
  return result;
}

BOOL uhash_compareUnicodeString(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;

  if (a1 == a2)
    return 1;
  v2 = 0;
  if (a1 && a2)
  {
    v3 = *(unsigned __int16 *)(a1 + 8);
    if ((v3 & 1) != 0)
    {
      return *(_WORD *)(a2 + 8) & 1;
    }
    else
    {
      if ((v3 & 0x8000) != 0)
        v4 = *(_DWORD *)(a1 + 12);
      else
        v4 = v3 >> 5;
      v2 = 0;
      v5 = *(unsigned __int16 *)(a2 + 8);
      if ((v5 & 0x8000u) == 0)
        v6 = v5 >> 5;
      else
        v6 = *(_DWORD *)(a2 + 12);
      if ((v5 & 1) == 0 && v4 == v6)
        return icu::UnicodeString::doEquals((icu::UnicodeString *)a1, (const icu::UnicodeString *)a2, v4);
    }
  }
  return v2;
}

uint64_t icu::UnicodeString::doCaseCompare(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int32_t a6, __int16 a7)
{
  unsigned int v7;
  signed int v9;
  int v10;
  int v11;
  int32_t v13;
  uint64_t v14;
  UChar *v15;
  uint64_t v16;
  UChar *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v22;

  v7 = *(unsigned __int16 *)(a1 + 8);
  if ((v7 & 1) != 0)
    return -1;
  if ((v7 & 0x8000) == 0)
  {
    v9 = v7 >> 5;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_4;
LABEL_10:
    v10 = 0;
    goto LABEL_11;
  }
  v9 = *(_DWORD *)(a1 + 12);
  if (a2 < 0)
    goto LABEL_10;
LABEL_4:
  v10 = v9;
  if (v9 >= a2)
  {
    if ((a3 & 0x80000000) == 0)
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_11:
  a2 = v10;
  if ((a3 & 0x80000000) == 0)
  {
LABEL_6:
    v11 = v9 - a2;
    if (v11 >= a3)
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_12:
  v11 = 0;
LABEL_13:
  a3 = v11;
LABEL_14:
  if (a4)
    v13 = a6;
  else
    v13 = 0;
  if ((v7 & 2) != 0)
    v14 = a1 + 10;
  else
    v14 = *(_QWORD *)(a1 + 24);
  v15 = (UChar *)(v14 + 2 * a2);
  if (a4)
    v16 = a5;
  else
    v16 = 0;
  v17 = (UChar *)(a4 + 2 * v16);
  if (v15 == v17)
  {
    if (v13 < 0)
      v13 = u_strlen(&v15[v16]);
    v20 = a3 - v13;
    if (v20)
    {
      v19 = HIBYTE(v20);
      return (char)(v19 | 1);
    }
  }
  else
  {
    v22 = 0;
    v18 = sub_18BC6B65C(v15, a3, v17, v13, a7, &v22);
    if (v18)
    {
      v19 = HIBYTE(v18);
      return (char)(v19 | 1);
    }
  }
  return 0;
}

icu::UnicodeString *icu::UnicodeString::caseMap(const UChar **this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))
{
  unsigned int v6;
  __int128 v12;
  uint64_t v13;
  int v14;
  int v15;
  const UChar *v16;
  UChar *v17;
  uint64_t v18;
  int v19;
  void *v20;
  int v21;
  const UChar *v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  __int128 v28;
  signed __int8 v29[16];
  __int128 v30;
  UChar *v31;
  unsigned __int16 *v32;
  int v33;
  int v34[2];
  _BYTE v35[20];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  UChar *v48;
  UErrorCode v49;
  void *v50[2];
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  void (**v75)(icu::UnicodeString *__hidden);
  __int128 v76;
  __int128 v77;
  __int128 v78;
  uint64_t v79;
  UChar dest[8];
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  _BYTE v85[28];
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v6 = *((unsigned __int16 *)this + 4);
  if (v6 >= 0x20 && (v6 & 0x11) == 0)
  {
    v12 = 0uLL;
    v84 = 0u;
    memset(v85, 0, sizeof(v85));
    v82 = 0u;
    v83 = 0u;
    *(_OWORD *)dest = 0u;
    v81 = 0u;
    if ((v6 & 0x8000) != 0)
      v13 = *((unsigned int *)this + 3);
    else
      v13 = v6 >> 5;
    if ((v6 & 0x19) != 0)
    {
      v49 = U_ZERO_ERROR;
      v76 = 0uLL;
      v79 = 0;
      v78 = 0uLL;
      v77 = 0uLL;
      v75 = off_1E2256B38;
      LOWORD(v76) = 2;
      goto LABEL_11;
    }
    if ((v6 & 4) != 0)
    {
      v15 = icu::UnicodeString::refCount((icu::UnicodeString *)this);
      v49 = U_ZERO_ERROR;
      v12 = 0uLL;
      v76 = 0u;
      v79 = 0;
      v78 = 0u;
      v77 = 0u;
      v75 = off_1E2256B38;
      LOWORD(v76) = 2;
      if (v15 != 1)
      {
LABEL_11:
        if ((int)v13 <= 26)
        {
          v14 = 0;
          goto LABEL_18;
        }
        goto LABEL_20;
      }
    }
    else
    {
      v49 = U_ZERO_ERROR;
      v76 = 0uLL;
      v79 = 0;
      v78 = 0uLL;
      v77 = 0uLL;
      v75 = off_1E2256B38;
      LOWORD(v76) = 2;
    }
    if ((int)v13 < 55)
    {
      v14 = 1;
LABEL_18:
      if (((_WORD)this[1] & 2) != 0)
        v16 = (const UChar *)this + 5;
      else
        v16 = this[3];
      u_memcpy(dest, v16, v13);
      if (v14)
      {
        if (((_WORD)this[1] & 2) == 0)
        {
          v18 = *((unsigned int *)this + 4);
          if (!a4)
            goto LABEL_37;
          goto LABEL_36;
        }
      }
      else
      {
        if (!icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)this, 27, 27, 0, 0, 0))
          goto LABEL_63;
        v16 = (const UChar *)this + 5;
      }
      v18 = 27;
      if (!a4)
      {
LABEL_37:
        v21 = a5(a2, a3, a4, v16, v18, dest, v13, 0, &v49);
        v19 = v21;
        if (v49 <= U_ZERO_ERROR)
        {
          v24 = *((unsigned __int16 *)this + 4);
          if (v21 > 1023)
          {
            v20 = (void *)(v24 | 0xFFE0u);
            *((_WORD *)this + 4) = (_WORD)v20;
            *((_DWORD *)this + 3) = v21;
            goto LABEL_63;
          }
          v20 = (void *)(v24 & 0x1F | (32 * v21));
          goto LABEL_61;
        }
        if (v49 != U_BUFFER_OVERFLOW_ERROR)
        {
LABEL_57:
          icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
          goto LABEL_63;
        }
        v17 = dest;
        goto LABEL_40;
      }
LABEL_36:
      v48 = dest;
      icu::UnicodeString::setTo((icu::UnicodeString *)&v75, 0, (const UChar **)&v48, v13);
      (*(void (**)(uint64_t, void (***)(icu::UnicodeString *__hidden)))(*(_QWORD *)a4 + 56))(a4, &v75);
      goto LABEL_37;
    }
LABEL_20:
    if (((_WORD)this[1] & 2) != 0)
      v17 = (UChar *)this + 5;
    else
      v17 = (UChar *)this[3];
    *(_OWORD *)&v35[4] = v12;
    v36 = v12;
    v47 = v12;
    v46 = v12;
    v45 = v12;
    v44 = v12;
    v43 = v12;
    v42 = v12;
    v41 = v12;
    v40 = v12;
    v39 = v12;
    v38 = v12;
    v37 = v12;
    v32 = (unsigned __int16 *)&v35[8];
    v33 = 100;
    *(_QWORD *)v34 = 0;
    *(_QWORD *)v35 = 0;
    v73 = v12;
    v74 = v12;
    v71 = v12;
    v72 = v12;
    v69 = v12;
    v70 = v12;
    v67 = v12;
    v68 = v12;
    v65 = v12;
    v66 = v12;
    v63 = v12;
    v64 = v12;
    v61 = v12;
    v62 = v12;
    v59 = v12;
    v60 = v12;
    v57 = v12;
    v58 = v12;
    v55 = v12;
    v56 = v12;
    v53 = v12;
    v54 = v12;
    v51 = v12;
    v52 = v12;
    *(_OWORD *)v50 = v12;
    if (a4)
    {
      v31 = v17;
      icu::UnicodeString::setTo((icu::UnicodeString *)&v75, 0, (const UChar **)&v31, v13);
      (*(void (**)(uint64_t, void (***)(icu::UnicodeString *__hidden)))(*(_QWORD *)a4 + 56))(a4, &v75);
    }
    a5(a2, a3 | 0x4000, a4, (const UChar *)v50, 200, v17, v13, &v32, &v49);
    if (v49 <= U_ZERO_ERROR)
    {
      if (v34[1] >= 1
        && !icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)this, v34[1] + (int)v13, v34[1] + (int)v13, 1, 0, 0))
      {
        goto LABEL_52;
      }
      *(_OWORD *)v29 = 0u;
      v30 = 0u;
      v28 = 0u;
      icu::Edits::Iterator::Iterator((uint64_t)&v28, v32, v34[0], 1, 1);
      while (icu::Edits::Iterator::next((icu::Edits::Iterator *)&v28, v29[4], &v49))
        icu::UnicodeString::doReplace((uint64_t)this, DWORD2(v30), *(unsigned int *)&v29[8], (uint64_t)v50, SDWORD1(v30), *(unsigned int *)&v29[12]);
      if (v49 < U_ILLEGAL_ARGUMENT_ERROR)
        goto LABEL_52;
    }
    else if (v49 == U_BUFFER_OVERFLOW_ERROR)
    {
      v19 = v34[1] + v13;
      icu::Edits::~Edits((void **)&v32);
LABEL_40:
      v50[0] = 0;
      if (icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)this, v19, v19, 0, (unsigned int **)v50, 1))
      {
        v49 = U_ZERO_ERROR;
        if (((_WORD)this[1] & 2) != 0)
        {
          v22 = (const UChar *)this + 5;
          v23 = 27;
        }
        else
        {
          v22 = this[3];
          v23 = *((unsigned int *)this + 4);
        }
        v25 = a5(a2, a3, a4, v22, v23, v17, v13, 0, &v49);
        if (v50[0])
          uprv_free(v50[0]);
        if (v49 > U_ZERO_ERROR)
          goto LABEL_57;
        v26 = *((unsigned __int16 *)this + 4);
        if (v25 > 1023)
        {
          v20 = (void *)(v26 | 0xFFE0u);
          *((_WORD *)this + 4) = (_WORD)v20;
          *((_DWORD *)this + 3) = v25;
          goto LABEL_63;
        }
        v20 = (void *)(v26 & 0x1F | (32 * v25));
LABEL_61:
        *((_WORD *)this + 4) = (_WORD)v20;
      }
LABEL_63:
      icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v75);
      return (icu::UnicodeString *)this;
    }
    icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
LABEL_52:
    icu::Edits::~Edits((void **)&v32);
    goto LABEL_63;
  }
  return (icu::UnicodeString *)this;
}

icu::UnicodeString *icu::UnicodeString::foldCase(const UChar **this, uint64_t a2)
{
  return icu::UnicodeString::caseMap(this, 1, a2, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18BC6B1F4);
}

uint64_t uhash_hashCaselessUnicodeString(UChar **a1)
{
  uint64_t v1;
  void *v2;
  _OWORD v4[4];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  memset(v4, 0, sizeof(v4));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)v4, a1);
  icu::UnicodeString::caseMap((const UChar **)v4, 1, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18BC6B1F4);
  v1 = icu::UnicodeString::doHashCode((icu::UnicodeString *)v4);
  icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)v4);
  return v1;
}

BOOL uhash_compareCaselessUnicodeString(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  int v8;

  if (a1 == a2)
    return 1;
  v2 = 0;
  if (a1 && a2)
  {
    v3 = *(unsigned __int16 *)(a1 + 8);
    if (*(__int16 *)(a1 + 8) < 0)
      v4 = *(_DWORD *)(a1 + 12);
    else
      v4 = v3 >> 5;
    v5 = *(unsigned __int16 *)(a2 + 8);
    if ((v5 & 1) != 0)
    {
      v8 = (v3 & 1) == 0;
    }
    else
    {
      if ((v5 & 0x8000u) == 0)
        v6 = v5 >> 5;
      else
        v6 = *(_DWORD *)(a2 + 12);
      if ((v5 & 2) != 0)
        v7 = a2 + 10;
      else
        v7 = *(_QWORD *)(a2 + 24);
      v8 = icu::UnicodeString::doCaseCompare(a1, 0, v4, v7, v6 & (v6 >> 31), v6 & ~(v6 >> 31), 0);
    }
    return v8 == 0;
  }
  return v2;
}

icu::UnicodeString *icu::UnicodeString::toLower(const UChar **this)
{
  uint64_t v2;

  v2 = sub_18BC6BDA0(0);
  return icu::UnicodeString::caseMap(this, v2, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18BC6AD4C);
}

icu::UnicodeString *icu::UnicodeString::toLower(const UChar **this, const icu::Locale *a2)
{
  unsigned __int8 *BaseName;
  uint64_t v4;

  BaseName = (unsigned __int8 *)icu::Locale::getBaseName(a2);
  v4 = sub_18BC6BDA0(BaseName);
  return icu::UnicodeString::caseMap(this, v4, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18BC6AD4C);
}

icu::UnicodeString *icu::UnicodeString::toUpper(const UChar **this)
{
  uint64_t v2;

  v2 = sub_18BC6BDA0(0);
  return icu::UnicodeString::caseMap(this, v2, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18BC6ADE8);
}

icu::UnicodeString *icu::UnicodeString::toUpper(const UChar **this, const icu::Locale *a2)
{
  unsigned __int8 *BaseName;
  uint64_t v4;

  BaseName = (unsigned __int8 *)icu::Locale::getBaseName(a2);
  v4 = sub_18BC6BDA0(BaseName);
  return icu::UnicodeString::caseMap(this, v4, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18BC6ADE8);
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *__s, char *a3)
{
  int v6;

  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  if (__s)
  {
    v6 = strlen(__s);
    icu::UnicodeString::doCodepageCreate((UChar **)this, __s, v6, a3);
  }
  return this;
}

void icu::UnicodeString::doCodepageCreate(UChar **this, const char *__s, int a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;
  int32_t v7;
  UConverter *DefaultConverter;
  const char *DefaultName;
  int v12;
  UChar *v13;
  int v14;
  UConverter *v15;
  UErrorCode v16;
  uint64_t v17;
  uint64_t v18;

  if (a3 < -1)
    return;
  v17 = v4;
  v18 = v5;
  if (!__s)
    return;
  v7 = a3;
  if (!a3)
    return;
  if (a3 == -1)
    v7 = strlen(__s);
  v16 = U_ZERO_ERROR;
  if (!a4)
  {
    DefaultName = ucnv_getDefaultName();
    v12 = *(unsigned __int8 *)DefaultName;
    if (v12 == 117)
    {
      if (DefaultName[1] != 116 || DefaultName[2] != 102)
        goto LABEL_29;
    }
    else if (v12 != 85 || DefaultName[1] != 84 || DefaultName[2] != 70)
    {
      goto LABEL_29;
    }
    v14 = *((unsigned __int8 *)DefaultName + 3);
    if (v14 == 56)
    {
      if (!DefaultName[4])
      {
LABEL_23:
        icu::UnicodeString::setToUTF8((uint64_t)this, __s, v7);
        return;
      }
    }
    else if (v14 == 45 && DefaultName[4] == 56 && !DefaultName[5])
    {
      goto LABEL_23;
    }
LABEL_29:
    DefaultConverter = (UConverter *)u_getDefaultConverter(&v16);
    goto LABEL_30;
  }
  if (*a4)
  {
    DefaultConverter = (UConverter *)ucnv_open((unsigned __int8 *)a4, &v16);
LABEL_30:
    v15 = DefaultConverter;
    if (v16 >= U_ILLEGAL_ARGUMENT_ERROR)
      goto LABEL_31;
    icu::UnicodeString::doCodepageCreate((icu::UnicodeString *)this, __s, v7, DefaultConverter, &v16);
    if (v16 >= U_ILLEGAL_ARGUMENT_ERROR)
      icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
    if (a4)
      ucnv_close(v15);
    else
      u_releaseDefaultConverter(v15);
    return;
  }
  if (!icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)this, v7, v7, 0, 0, 0))
  {
LABEL_31:
    icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
    return;
  }
  if (((_WORD)this[1] & 2) != 0)
    v13 = (UChar *)this + 5;
  else
    v13 = this[3];
  u_charsToUChars(__s, v13, v7);
  if (v7 > 1023)
  {
    *((_WORD *)this + 4) |= 0xFFE0u;
    *((_DWORD *)this + 3) = v7;
  }
  else
  {
    *((_WORD *)this + 4) = (_WORD)this[1] & 0x1F | (32 * v7);
  }
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *a2, int a3, char *a4)
{
  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  if (a2)
    icu::UnicodeString::doCodepageCreate((UChar **)this, a2, a3, a4);
  return this;
}

{
  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  if (a2)
    icu::UnicodeString::doCodepageCreate((UChar **)this, a2, a3, a4);
  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *__s, int a3, UConverter *a4, UErrorCode *a5)
{
  int v8;
  UConverter *DefaultConverter;

  *(_QWORD *)this = off_1E2256B38;
  *((_WORD *)this + 4) = 2;
  if (*(int *)a5 <= 0 && __s != 0)
  {
    v8 = a3;
    if (a3 <= -2)
    {
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_14:
      icu::UnicodeString::setToBogus(this);
      return this;
    }
    if (a3 == -1)
      v8 = strlen(__s);
    if (v8 >= 1)
    {
      if (a4)
      {
        ucnv_resetToUnicode((uint64_t)a4);
        icu::UnicodeString::doCodepageCreate(this, __s, v8, a4, a5);
      }
      else
      {
        DefaultConverter = (UConverter *)u_getDefaultConverter(a5);
        icu::UnicodeString::doCodepageCreate(this, __s, v8, DefaultConverter, a5);
        u_releaseDefaultConverter(DefaultConverter);
      }
    }
    if (*(int *)a5 >= 1)
      goto LABEL_14;
  }
  return this;
}

void icu::UnicodeString::doCodepageCreate(icu::UnicodeString *this, const char *a2, int a3, UConverter *a4, UErrorCode *a5)
{
  int v10;
  const char *v11;
  unsigned int v12;
  char *v13;
  int v14;
  int v15;
  unint64_t v16;
  __int16 v17;
  unsigned int v18;
  int v19;
  char *v20;
  const char *v21;

  if (*(int *)a5 <= 0)
  {
    v20 = 0;
    v21 = a2;
    if (a3 <= 27)
      v10 = 27;
    else
      v10 = a3 + (a3 >> 2);
    if (icu::UnicodeString::cloneArrayIfNeeded(this, v10, v10, 0, 0, 0))
    {
      v11 = &a2[a3];
      while (1)
      {
        v12 = *((unsigned __int16 *)this + 4);
        v13 = (char *)this + 10;
        if ((v12 & 2) == 0)
          v13 = (char *)*((_QWORD *)this + 3);
        v14 = (v12 & 0x8000) != 0 ? *((_DWORD *)this + 3) : v12 >> 5;
        v20 = &v13[2 * v14];
        v15 = (v12 & 2) != 0 ? 27 : *((_DWORD *)this + 4);
        ucnv_toUnicode((uint64_t)a4, &v20, (unint64_t)&v13[2 * v15], (unint64_t *)&v21, (unint64_t)v11, 0, 1, (int *)a5);
        v16 = (unint64_t)(v20 - v13) >> 1;
        v17 = *((_WORD *)this + 4);
        if ((int)v16 > 1023)
        {
          LOWORD(v18) = v17 | 0xFFE0;
          *((_DWORD *)this + 3) = v16;
        }
        else
        {
          v18 = v17 & 0x1F | (32 * (((_DWORD)v20 - (_DWORD)v13) >> 1));
        }
        *((_WORD *)this + 4) = v18;
        if (*a5 != U_BUFFER_OVERFLOW_ERROR)
          break;
        *a5 = U_ZERO_ERROR;
        if (*((__int16 *)this + 4) < 0)
          v19 = *((_DWORD *)this + 3);
        else
          v19 = *((unsigned __int16 *)this + 4) >> 5;
        if (!icu::UnicodeString::cloneArrayIfNeeded(this, v19 + 2 * ((int)v11 - (int)v21), v19 + 2 * ((int)v11 - (int)v21), 1, 0, 0))goto LABEL_23;
      }
    }
    else
    {
LABEL_23:
      icu::UnicodeString::setToBogus(this);
    }
  }
}

uint64_t icu::UnicodeString::extract(icu::UnicodeString *this, int a2, uint64_t a3, char *cs, unsigned int a5, char *a6)
{
  uint64_t v7;
  int v8;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  UConverter *v18;
  char *v19;
  int v20;
  uint64_t v21;
  const char *DefaultName;
  int v23;
  int32_t v24;
  char *v25;
  int v26;
  UConverter *DefaultConverter;
  UErrorCode v30;

  v7 = a3;
  v8 = a2;
  if (cs || !a5)
  {
    v11 = *((unsigned __int16 *)this + 4);
    if (*((__int16 *)this + 4) < 0)
    {
      v12 = *((_DWORD *)this + 3);
      if ((a2 & 0x80000000) == 0)
      {
LABEL_6:
        v13 = v12;
        if (v12 >= a2)
        {
          if ((a3 & 0x80000000) == 0)
            goto LABEL_8;
          goto LABEL_13;
        }
LABEL_12:
        v8 = v13;
        if ((a3 & 0x80000000) == 0)
        {
LABEL_8:
          v14 = (v12 - v8);
          if ((int)v14 >= (int)a3)
          {
LABEL_15:
            v15 = (_DWORD)cs + 0x7FFFFFFF;
            if ((unint64_t)cs >= 0xFFFFFFFF80000001)
              v15 = -1;
            v16 = v15 - (_DWORD)cs;
            if (a5 >= 0x7FFFFFFF)
              v17 = v16;
            else
              v17 = a5;
            v30 = U_ZERO_ERROR;
            if (!(_DWORD)v7)
            {
              v19 = cs;
              v20 = v17;
              v21 = 0;
              return u_terminateChars((uint64_t)v19, v20, v21, (int *)&v30);
            }
            if (a6)
            {
              if (*a6)
              {
                v18 = (UConverter *)ucnv_open((unsigned __int8 *)a6, &v30);
                v10 = icu::UnicodeString::doExtract(this, v8, v7, cs, v17, v18, &v30);
                ucnv_close(v18);
                return v10;
              }
              if ((int)v7 >= v17)
                v24 = v17;
              else
                v24 = v7;
              if ((v11 & 2) != 0)
                v25 = (char *)this + 10;
              else
                v25 = (char *)*((_QWORD *)this + 3);
              u_UCharsToChars((const UChar *)&v25[2 * v8], cs, v24);
              v19 = cs;
              v20 = v17;
              v21 = v7;
              return u_terminateChars((uint64_t)v19, v20, v21, (int *)&v30);
            }
            DefaultName = ucnv_getDefaultName();
            v23 = *(unsigned __int8 *)DefaultName;
            if (v23 == 117)
            {
              if (DefaultName[1] != 116 || DefaultName[2] != 102)
                goto LABEL_47;
            }
            else if (v23 != 85 || DefaultName[1] != 84 || DefaultName[2] != 70)
            {
              goto LABEL_47;
            }
            v26 = *((unsigned __int8 *)DefaultName + 3);
            if (v26 == 56)
            {
              if (!DefaultName[4])
                return icu::UnicodeString::toUTF8(this, v8, v7, cs, v17);
            }
            else if (v26 == 45 && DefaultName[4] == 56 && !DefaultName[5])
            {
              return icu::UnicodeString::toUTF8(this, v8, v7, cs, v17);
            }
LABEL_47:
            DefaultConverter = (UConverter *)u_getDefaultConverter(&v30);
            v10 = icu::UnicodeString::doExtract(this, v8, v7, cs, v17, DefaultConverter, &v30);
            u_releaseDefaultConverter(DefaultConverter);
            return v10;
          }
LABEL_14:
          v7 = v14;
          goto LABEL_15;
        }
LABEL_13:
        v14 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      v12 = v11 >> 5;
      if ((a2 & 0x80000000) == 0)
        goto LABEL_6;
    }
    v13 = 0;
    goto LABEL_12;
  }
  return 0;
}

uint64_t icu::UnicodeString::doExtract(icu::UnicodeString *this, int a2, int a3, char *a4, int a5, UConverter *a6, UErrorCode *a7)
{
  int v7;
  uint64_t result;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  _BYTE v18[1024];
  uint64_t v19;

  v7 = a5;
  v19 = *MEMORY[0x1E0C80C00];
  v17 = a4;
  if (*(int *)a7 < 1)
  {
    if ((*((_WORD *)this + 4) & 2) != 0)
      v12 = (char *)this + 10;
    else
      v12 = (char *)*((_QWORD *)this + 3);
    v16 = &v12[2 * a2];
    v13 = (unint64_t)&v16[2 * a3];
    if (a5 == -1)
    {
      v7 = 0x7FFFFFFF;
      if ((unint64_t)a4 >= 0xFFFFFFFF80000001)
        v14 = -1;
      else
        v14 = (unint64_t)(a4 + 0x7FFFFFFF);
    }
    else if (a5)
    {
      v14 = (unint64_t)&a4[a5];
    }
    else
    {
      v14 = 0;
      v17 = 0;
    }
    ucnv_fromUnicode((uint64_t)a6, (uint64_t *)&v17, v14, (unint64_t *)&v16, v13, 0, 1, (int *)a7);
    v15 = ((_DWORD)v17 - (_DWORD)a4);
    if (*a7 == U_BUFFER_OVERFLOW_ERROR)
    {
      bzero(v18, 0x400uLL);
      do
      {
        v17 = v18;
        *a7 = U_ZERO_ERROR;
        ucnv_fromUnicode((uint64_t)a6, (uint64_t *)&v17, (unint64_t)&v19, (unint64_t *)&v16, v13, 0, 1, (int *)a7);
        v15 = v15 + (_DWORD)v17 - v18;
      }
      while (*a7 == U_BUFFER_OVERFLOW_ERROR);
    }
    return u_terminateChars((uint64_t)a4, v7, v15, (int *)a7);
  }
  else
  {
    result = 0;
    if (a5)
      *a4 = 0;
  }
  return result;
}

uint64_t icu::UnicodeString::extract(icu::UnicodeString *this, char *a2, int a3, UConverter *a4, UErrorCode *a5)
{
  uint64_t v5;
  unsigned int v9;
  UConverter *v13;
  int v14;
  uint64_t DefaultConverter;

  if (*(int *)a5 > 0)
    return 0;
  if (a3 < 0 || (v9 = *((unsigned __int16 *)this + 4), (v9 & 1) != 0) || !a2 && a3)
  {
    v5 = 0;
    *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    return v5;
  }
  if (v9 > 0x1F)
  {
    if (a4)
    {
      ucnv_resetFromUnicode((uint64_t)a4);
      v13 = a4;
    }
    else
    {
      DefaultConverter = u_getDefaultConverter(a5);
      if (*(int *)a5 >= 1)
        return 0;
      v13 = (UConverter *)DefaultConverter;
    }
    if (*((__int16 *)this + 4) < 0)
      v14 = *((_DWORD *)this + 3);
    else
      v14 = *((unsigned __int16 *)this + 4) >> 5;
    v5 = icu::UnicodeString::doExtract(this, 0, v14, a2, a3, v13, a5);
    if (!a4)
      u_releaseDefaultConverter(v13);
    return v5;
  }
  return u_terminateChars((uint64_t)a2, a3, 0, (int *)a5);
}

icu::UnicodeString *icu::UnicodeString::trim(icu::UnicodeString *this)
{
  unsigned int v2;
  char *v3;
  int v4;
  int v5;
  int v6;
  UChar32 v7;
  int v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  UChar32 v13;
  int v15;
  BOOL v16;
  UChar32 v17;

  v2 = *((unsigned __int16 *)this + 4);
  if ((v2 & 1) != 0)
    return this;
  if ((v2 & 2) != 0)
  {
    v3 = (char *)this + 10;
    if ((v2 & 0x8000) == 0)
      goto LABEL_4;
LABEL_6:
    v4 = *((_DWORD *)this + 3);
    goto LABEL_7;
  }
  v3 = (char *)*((_QWORD *)this + 3);
  if ((v2 & 0x8000) != 0)
    goto LABEL_6;
LABEL_4:
  v4 = v2 >> 5;
LABEL_7:
  if (v4 < 1)
    return this;
  v5 = v4;
  do
  {
    v6 = v5 - 1;
    v7 = *(unsigned __int16 *)&v3[2 * (v5 - 1)];
    if ((v7 & 0xFC00) == 0xDC00)
    {
      if (v5 < 2)
      {
        v6 = 0;
      }
      else
      {
        v8 = *(unsigned __int16 *)&v3[2 * (v5 - 2)];
        v9 = (v8 & 0xFC00) == 55296;
        v10 = v7 - 56613888 + (v8 << 10);
        if (v9)
          v6 = v5 - 2;
        if (v9)
          v7 = v10;
      }
    }
    else if (v7 == 32)
    {
      goto LABEL_21;
    }
    if (!u_isWhitespace(v7))
      break;
LABEL_21:
    v5 = v6;
  }
  while (v6 > 0);
  if (v5 >= v4)
  {
LABEL_25:
    if (v5 < 1)
      return this;
  }
  else
  {
    if (v5 <= 1023)
    {
      *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * v5);
      goto LABEL_25;
    }
    *((_WORD *)this + 4) |= 0xFFE0u;
    *((_DWORD *)this + 3) = v5;
  }
  v11 = 0;
  while (2)
  {
    v12 = (int)v11 + 1;
    v13 = *(unsigned __int16 *)&v3[2 * (int)v11];
    if ((v13 & 0xFC00) == 0xD800 && (_DWORD)v12 != v5)
    {
      v15 = *(unsigned __int16 *)&v3[2 * v12];
      v16 = (v15 & 0xFC00) == 56320;
      v17 = (v13 << 10) - 56613888 + v15;
      if (v16)
        v12 = (v11 + 2);
      else
        v12 = v12;
      if (v16)
        v13 = v17;
      goto LABEL_42;
    }
    if (v13 != 32)
    {
LABEL_42:
      if (!u_isWhitespace(v13))
        break;
    }
    v11 = v12;
    if ((int)v12 < v5)
      continue;
    break;
  }
  if ((int)v11 >= 1)
    icu::UnicodeString::doReplace((uint64_t)this, 0, v11, 0, 0, 0);
  return this;
}

const UChar **icu::UnicodeString::toTitle(icu::UnicodeString *this, icu::BreakIterator *a2)
{
  uint64_t *Default;

  Default = icu::Locale::getDefault(this);
  return icu::UnicodeString::toTitle((const UChar **)this, a2, (const icu::Locale *)Default, 0);
}

const UChar **icu::UnicodeString::toTitle(const UChar **this, icu::BreakIterator *a2, const icu::Locale *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *BaseName;
  uint64_t v10;
  int v12;
  uint64_t v13;

  v13 = 0;
  v12 = 0;
  v7 = sub_18BC69468(a3, "", a4, (uint64_t)a2, &v13, (const icu::Locale *)&v12);
  if (v7)
  {
    v8 = v7;
    BaseName = (unsigned __int8 *)icu::Locale::getBaseName(a3);
    v10 = sub_18BC6BDA0(BaseName);
    icu::UnicodeString::caseMap(this, v10, a4, v8, (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18BC69A60);
  }
  else
  {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
  }
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  return this;
}

const UChar **icu::UnicodeString::toTitle(const UChar **this, icu::BreakIterator *a2, const icu::Locale *a3)
{
  return icu::UnicodeString::toTitle(this, a2, a3, 0);
}

uint64_t unorm_quickCheck(uint64_t a1, int a2, int a3, icu::Normalizer2Factory *this)
{
  uint64_t Instance;

  Instance = icu::Normalizer2Factory::getInstance(a3, this);
  return unorm2_quickCheck(Instance, a1, a2, (int *)this);
}

uint64_t unorm_quickCheckWithOptions(uint64_t a1, int a2, int a3, char a4, icu::Normalizer2Factory *this)
{
  uint64_t Instance;
  uint64_t v11;
  _QWORD v12[3];

  Instance = icu::Normalizer2Factory::getInstance(a3, this);
  if ((a4 & 0x20) == 0)
    return unorm2_quickCheck(Instance, a1, a2, (int *)this);
  v12[0] = off_1E2246ED8;
  v12[1] = Instance;
  v12[2] = sub_18BC4F3B4((UErrorCode *)this);
  v11 = unorm2_quickCheck((uint64_t)v12, a1, a2, (int *)this);
  icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v12);
  return v11;
}

uint64_t unorm_isNormalized(uint64_t a1, int a2, int a3, icu::Normalizer2Factory *this)
{
  uint64_t Instance;

  Instance = icu::Normalizer2Factory::getInstance(a3, this);
  return unorm2_isNormalized(Instance, a1, a2, (int *)this);
}

uint64_t unorm_isNormalizedWithOptions(uint64_t a1, int a2, int a3, char a4, icu::Normalizer2Factory *this)
{
  uint64_t Instance;
  uint64_t isNormalized;
  _QWORD v12[3];

  Instance = icu::Normalizer2Factory::getInstance(a3, this);
  if ((a4 & 0x20) == 0)
    return unorm2_isNormalized(Instance, a1, a2, (int *)this);
  v12[0] = off_1E2246ED8;
  v12[1] = Instance;
  v12[2] = sub_18BC4F3B4((UErrorCode *)this);
  isNormalized = unorm2_isNormalized((uint64_t)v12, a1, a2, (int *)this);
  icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v12);
  return isNormalized;
}

uint64_t unorm_normalize(UChar *a1, int a2, int a3, char a4, UChar *a5, uint64_t a6, icu::Normalizer2Factory *this)
{
  const void *Instance;
  uint64_t v15;
  _QWORD v16[3];

  Instance = (const void *)icu::Normalizer2Factory::getInstance(a3, this);
  if ((a4 & 0x20) == 0)
    return unorm2_normalize(Instance, a1, a2, a5, a6, (UErrorCode *)this);
  v16[0] = off_1E2246ED8;
  v16[1] = Instance;
  v16[2] = sub_18BC4F3B4((UErrorCode *)this);
  v15 = unorm2_normalize(v16, a1, a2, a5, a6, (UErrorCode *)this);
  icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v16);
  return v15;
}

uint64_t unorm_previous(uint64_t a1, UChar *a2, uint64_t a3, int a4, char a5, int a6, _BYTE *a7, icu::Normalizer2Factory *a8)
{
  return sub_18BC58F54(a1, 0, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_18BC58F54(uint64_t a1, int a2, UChar *a3, uint64_t a4, int a5, char a6, int a7, _BYTE *a8, icu::Normalizer2Factory *a9)
{
  uint64_t Instance;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[3];

  Instance = icu::Normalizer2Factory::getInstance(a5, a9);
  if ((a6 & 0x20) == 0)
    return sub_18BC593C4(a1, a2, a3, a4, Instance, a7, a8, (int *)a9);
  v18 = sub_18BC4F3B4((UErrorCode *)a9);
  if (*(int *)a9 > 0)
    return 0;
  v20[0] = off_1E2246ED8;
  v20[1] = Instance;
  v20[2] = v18;
  v19 = sub_18BC593C4(a1, a2, a3, a4, (uint64_t)v20, a7, a8, (int *)a9);
  icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v20);
  return v19;
}

uint64_t unorm_next(uint64_t a1, UChar *a2, uint64_t a3, int a4, char a5, int a6, _BYTE *a7, icu::Normalizer2Factory *a8)
{
  return sub_18BC58F54(a1, 1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t unorm_concatenate(uint64_t a1, uint64_t a2, unint64_t a3, int a4, char *a5, unsigned int a6, int a7, char a8, icu::Normalizer2Factory *a9)
{
  uint64_t Instance;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[3];

  Instance = icu::Normalizer2Factory::getInstance(a7, a9);
  if ((a8 & 0x20) == 0)
    return sub_18BC591C4(a1, a2, a3, a4, a5, a6, Instance, (int *)a9);
  v18 = sub_18BC4F3B4((UErrorCode *)a9);
  if (*(int *)a9 > 0)
    return 0;
  v20[0] = off_1E2246ED8;
  v20[1] = Instance;
  v20[2] = v18;
  v19 = sub_18BC591C4(a1, a2, a3, a4, a5, a6, (uint64_t)v20, (int *)a9);
  icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v20);
  return v19;
}

uint64_t sub_18BC591C4(uint64_t a1, uint64_t a2, unint64_t a3, int a4, char *a5, unsigned int a6, uint64_t a7, int *a8)
{
  uint64_t v8;
  BOOL v13;
  int v14;
  uint64_t v20;
  unint64_t v21;
  _QWORD v22[2];
  UChar *v23;
  unint64_t v24;
  _BYTE v25[64];
  void (**v26)(icu::UnicodeString *__hidden);
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (*a8 > 0)
    return 0;
  if ((a6 & 0x80000000) != 0
    || (!a5 ? (v13 = a6 == 0) : (v13 = 1),
        v13 ? (v14 = 0) : (v14 = 1),
        a4 < -1
     || !a3
     || (int)a2 < -1
     || !a1
     || v14
     || a5
     && (a3 >= (unint64_t)a5 && (unint64_t)&a5[2 * a6] > a3
      || a4 >= 1 && (unint64_t)a5 >= a3 && a3 + 2 * a4 > (unint64_t)a5)))
  {
    v8 = 0;
    *a8 = 1;
  }
  else
  {
    v27 = 0u;
    v30 = 0;
    v29 = 0u;
    v28 = 0u;
    v26 = off_1E2256B38;
    LOWORD(v27) = 2;
    if ((char *)a1 == a5)
    {
      icu::UnicodeString::setTo((icu::UnicodeString *)&v26, a5, a2, a6);
    }
    else
    {
      icu::UnicodeString::setTo((icu::UnicodeString *)&v26, a5, 0, a6);
      icu::UnicodeString::doAppend((uint64_t)&v26, a1, 0, a2);
      v22[1] = a1;
    }
    v24 = a3;
    icu::UnicodeString::UnicodeString(v25, a4 >> 31, &v24);
    v20 = (*(uint64_t (**)(uint64_t, void (***)(icu::UnicodeString *__hidden), _BYTE *, int *))(*(_QWORD *)a7 + 48))(a7, &v26, v25, a8);
    v23 = (UChar *)a5;
    v8 = icu::UnicodeString::extract(v20, &v23, a6, a8);
    v22[0] = v23;
    icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v25);
    v21 = v24;
    icu::UnicodeString::~UnicodeString(&v21, (icu::UnicodeString *)&v26);
  }
  return v8;
}

uint64_t sub_18BC593C4(uint64_t a1, int a2, UChar *a3, uint64_t a4, uint64_t a5, int a6, _BYTE *a7, int *a8)
{
  uint64_t v8;
  BOOL v13;
  int v14;
  UChar32 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unint64_t v27;
  void *v28;
  UChar *v29;
  UChar *v30;
  UChar *v31;
  _OWORD v32[4];
  void (**v33)(icu::UnicodeString *__hidden);
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (*a8 <= 0)
  {
    if ((a4 & 0x80000000) != 0 || (!a3 ? (v13 = (_DWORD)a4 == 0) : (v13 = 1), v13 ? (v14 = 0) : (v14 = 1), !a1 || v14))
    {
      v8 = 0;
      *a8 = 1;
      return v8;
    }
    if (a7)
      *a7 = 0;
    if (a2)
    {
      if ((*(unsigned int (**)(uint64_t))(a1 + 48))(a1))
      {
        v34 = 0u;
        v37 = 0;
        v36 = 0u;
        v35 = 0u;
        v33 = off_1E2256B38;
        LOWORD(v34) = 2;
        v18 = uiter_next32((UCharIterator *)a1);
        icu::UnicodeString::append((uint64_t)&v33, v18);
        v19 = uiter_next32((UCharIterator *)a1);
        if ((v19 & 0x80000000) == 0)
        {
          v20 = v19;
          while (!(*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)a5 + 120))(a5, v20))
          {
            icu::UnicodeString::append((uint64_t)&v33, v20);
            v20 = uiter_next32((UCharIterator *)a1);
            if ((v20 & 0x80000000) != 0)
              goto LABEL_32;
          }
          if (v20 >= 0x10000)
            v24 = 4294967294;
          else
            v24 = 0xFFFFFFFFLL;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a1, v24, 1);
        }
        goto LABEL_32;
      }
    }
    else if ((*(unsigned int (**)(uint64_t))(a1 + 56))(a1))
    {
      v34 = 0u;
      v37 = 0;
      v36 = 0u;
      v35 = 0u;
      v33 = off_1E2256B38;
      LOWORD(v34) = 2;
      do
      {
        v21 = uiter_previous32((UCharIterator *)a1);
        if ((v21 & 0x80000000) != 0)
          break;
        v22 = v21;
        icu::UnicodeString::replace((icu::UnicodeString *)&v33, 0, 0, v21);
      }
      while (!(*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)a5 + 120))(a5, v22));
LABEL_32:
      memset(v32, 0, sizeof(v32));
      icu::UnicodeString::UnicodeString(v32, a3, 0, a4);
      v25 = (unsigned __int16)v34 >> 5;
      if ((v34 & 0x8000u) != 0)
        v25 = DWORD1(v34);
      if (a6 && v25 >= 1)
      {
        v26 = (*(uint64_t (**)(uint64_t, void (***)(icu::UnicodeString *__hidden), _OWORD *, int *))(*(_QWORD *)a5 + 24))(a5, &v33, v32, a8);
        v31 = a3;
        icu::UnicodeString::extract(v26, &v31, a4, a8);
        if (a7 && *a8 <= 0)
          *a7 = sub_18BC59708((uint64_t)v32, (uint64_t)&v33);
        v27 = SWORD4(v32[0]);
        if ((v27 & 0x80000000) != 0)
        {
          v8 = HIDWORD(v32[0]);
        }
        else
        {
          v27 = WORD4(v32[0]);
          v8 = WORD4(v32[0]) >> 5;
        }
      }
      else
      {
        v30 = a3;
        v8 = icu::UnicodeString::extract((uint64_t)&v33, &v30, a4, a8);
        v29 = v30;
        v27 = (unint64_t)&v29;
      }
      icu::UnicodeString::~UnicodeString((void *)v27, (icu::UnicodeString *)v32);
      icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)&v33);
      return v8;
    }
    return u_terminateUChars((uint64_t)a3, a4, 0, a8);
  }
  return 0;
}

uint64_t sub_18BC59708(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;

  v2 = *(unsigned __int16 *)(a1 + 8);
  if ((v2 & 1) != 0)
  {
    v4 = *(_WORD *)(a2 + 8) & 1;
  }
  else
  {
    if ((v2 & 0x8000) != 0)
      v3 = *(_DWORD *)(a1 + 12);
    else
      v3 = v2 >> 5;
    v4 = 0;
    v5 = *(unsigned __int16 *)(a2 + 8);
    if ((v5 & 0x8000u) == 0)
      v6 = v5 >> 5;
    else
      v6 = *(_DWORD *)(a2 + 12);
    if ((v5 & 1) == 0 && v3 == v6)
      v4 = icu::UnicodeString::doEquals((icu::UnicodeString *)a1, (const icu::UnicodeString *)a2, v3);
  }
  return v4 ^ 1u;
}

uint64_t unorm_compare(UChar *a1, UErrorCode *a2, UChar *a3, int a4, unsigned int a5, icu::Normalizer2Factory *this)
{
  uint64_t v6;
  UChar *v8;
  signed int v9;
  UChar *v10;
  signed int v11;
  uint64_t v12;
  uint64_t NFCImpl;
  int v14;
  int v15;
  unsigned int v16;
  UChar *v17;
  UChar *v18;
  uint64_t v19;
  UChar *v20;
  UChar *v21;
  unsigned int v22;
  uint64_t v23;
  BOOL v24;
  BOOL v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  int v33;
  UChar *Decomposition;
  UChar *v35;
  UChar **v36;
  int v37;
  uint64_t v38;
  UChar **v39;
  int v40;
  uint64_t NFDInstance;
  uint64_t v42;
  void *v43;
  uint64_t v45;
  signed int v46;
  int v47;
  int v48;
  unsigned int v49;
  unsigned int v51;
  UChar *src;
  void (**v53)(icu::UnicodeString *__hidden);
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  void (**v58)(icu::UnicodeString *__hidden);
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;
  UChar v63[8];
  __int128 v64;
  __int128 v65;
  __int128 v66;
  UChar dest[8];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  uint64_t v72;
  __int128 v73;
  _QWORD v74[4];
  __int128 v75;
  _QWORD v76[8];

  v76[5] = *MEMORY[0x1E0C80C00];
  if (*(int *)this > 0)
    return 0;
  v8 = a1;
  if (!a1 || (v9 = (int)a2, (int)a2 < -1) || (v10 = a3) == 0 || (v11 = a4, a4 <= -2))
  {
    v6 = 0;
    *(_DWORD *)this = 1;
    return v6;
  }
  v59 = 0u;
  v62 = 0;
  v61 = 0u;
  v60 = 0u;
  v57 = 0;
  v58 = off_1E2256B38;
  LOWORD(v59) = 2;
  v54 = 0u;
  v56 = 0u;
  v55 = 0u;
  v53 = off_1E2256B38;
  LOWORD(v54) = 2;
  if ((a5 & 0x20001) != 0x20000)
  {
    if ((a5 & 1) != 0)
      NFDInstance = icu::Normalizer2::getNFDInstance(this, a2);
    else
      NFDInstance = icu::Normalizer2Factory::getFCDInstance(this, a2);
    v42 = NFDInstance;
    v12 = a5;
    if (*(int *)this > 0)
      goto LABEL_123;
    if ((a5 & 0x2000000) != 0)
    {
      *(_QWORD *)dest = off_1E2246ED8;
      *(_QWORD *)&dest[4] = NFDInstance;
      *(_QWORD *)&v68 = sub_18BC4F3B4((UErrorCode *)this);
      if (sub_18BC5A098((uint64_t)dest, (uint64_t)v8, v9, (icu::UnicodeString *)&v58, (unsigned int *)this))
      {
        if ((v59 & 0x11) != 0)
        {
          v8 = 0;
        }
        else if ((v59 & 2) != 0)
        {
          v8 = (UChar *)&v59 + 1;
        }
        else
        {
          v8 = (UChar *)v60;
        }
        if ((v59 & 0x8000) != 0)
          v9 = DWORD1(v59);
        else
          v9 = (unsigned __int16)v59 >> 5;
      }
      if (sub_18BC5A098((uint64_t)dest, (uint64_t)v10, v11, (icu::UnicodeString *)&v53, (unsigned int *)this))
      {
        if ((v54 & 0x11) != 0)
        {
          v10 = 0;
        }
        else if ((v54 & 2) != 0)
        {
          v10 = (UChar *)&v54 + 1;
        }
        else
        {
          v10 = (UChar *)v55;
        }
        if ((v54 & 0x8000) != 0)
          v11 = DWORD1(v54);
        else
          v11 = (unsigned __int16)v54 >> 5;
      }
      icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)dest);
    }
    else
    {
      if (sub_18BC5A098(NFDInstance, (uint64_t)v8, v9, (icu::UnicodeString *)&v58, (unsigned int *)this))
      {
        if ((v59 & 0x11) != 0)
        {
          v8 = 0;
        }
        else if ((v59 & 2) != 0)
        {
          v8 = (UChar *)&v59 + 1;
        }
        else
        {
          v8 = (UChar *)v60;
        }
        if ((v59 & 0x8000) != 0)
          v9 = DWORD1(v59);
        else
          v9 = (unsigned __int16)v59 >> 5;
      }
      if (sub_18BC5A098(v42, (uint64_t)v10, v11, (icu::UnicodeString *)&v53, (unsigned int *)this))
      {
        if ((v54 & 0x11) != 0)
        {
          v10 = 0;
        }
        else if ((v54 & 2) != 0)
        {
          v10 = (UChar *)&v54 + 1;
        }
        else
        {
          v10 = (UChar *)v55;
        }
        if ((v54 & 0x8000) != 0)
          v11 = DWORD1(v54);
        else
          v11 = (unsigned __int16)v54 >> 5;
      }
    }
  }
  v12 = *(unsigned int *)this;
  if ((int)v12 > 0
    || (NFCImpl = icu::Normalizer2Factory::getNFCImpl(this, a2), v12 = *(unsigned int *)this, (int)v12 > 0))
  {
LABEL_123:
    v6 = 0;
    goto LABEL_124;
  }
  v45 = NFCImpl;
  v14 = 0;
  v15 = 0;
  src = 0;
  v16 = a5;
  v51 = 0;
  memset(v76, 0, 32);
  v73 = 0u;
  memset(v74, 0, sizeof(v74));
  v75 = 0u;
  v71 = 0;
  v72 = 0;
  *(_OWORD *)dest = 0u;
  v68 = 0u;
  if (v9 == -1)
    v17 = 0;
  else
    v17 = &v8[v9];
  v12 = (uint64_t)&v10[v11];
  v69 = 0uLL;
  v70 = 0uLL;
  if (v11 == -1)
    v18 = 0;
  else
    v18 = &v10[v11];
  v19 = 0xFFFFFFFFLL;
  *(_OWORD *)v63 = 0uLL;
  v64 = 0uLL;
  v20 = v8;
  v21 = v10;
  v22 = -1;
  v65 = 0uLL;
  v66 = 0uLL;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            if ((v19 & 0x80000000) != 0)
            {
              while (1)
              {
                if (v8 != v17)
                {
                  v12 = v16 & 0x1000;
                  v24 = v17 && (_DWORD)v12 == 0;
                  v23 = *v8;
                  if (v24 || *v8)
                  {
                    ++v8;
                    if ((v22 & 0x80000000) != 0)
                      goto LABEL_37;
                    goto LABEL_46;
                  }
                }
                if (!v14)
                  break;
                v12 = (uint64_t)&v76[3 * v14];
                do
                {
                  v20 = *(UChar **)(v12 - 40);
                  v12 -= 24;
                  --v14;
                }
                while (!v20);
                v8 = *(UChar **)(v12 - 8);
                v17 = *(UChar **)v12;
              }
              v23 = 0xFFFFFFFFLL;
              if ((v22 & 0x80000000) != 0)
                goto LABEL_37;
            }
            else
            {
              v23 = v19;
              if ((v22 & 0x80000000) != 0)
              {
LABEL_37:
                while (1)
                {
                  if (v10 != v18)
                  {
                    v12 = v16 & 0x1000;
                    v25 = v18 && (_DWORD)v12 == 0;
                    v22 = *v10;
                    if (v25 || *v10)
                      break;
                  }
                  if (!v15)
                  {
                    v22 = -1;
                    goto LABEL_46;
                  }
                  v12 = (uint64_t)&v74[3 * v15];
                  do
                  {
                    v21 = *(UChar **)(v12 - 40);
                    v12 -= 24;
                    --v15;
                  }
                  while (!v21);
                  v10 = *(UChar **)(v12 - 8);
                  v18 = *(UChar **)v12;
                }
                ++v10;
              }
            }
LABEL_46:
            if ((_DWORD)v23 != v22)
              break;
            v19 = 0xFFFFFFFFLL;
            v22 = -1;
            if ((v23 & 0x80000000) != 0)
              goto LABEL_123;
          }
          if ((v23 & 0x80000000) != 0)
          {
            v6 = 0xFFFFFFFFLL;
            goto LABEL_124;
          }
          if ((v22 & 0x80000000) != 0)
          {
            v6 = 1;
            goto LABEL_124;
          }
          v26 = v23;
          v47 = v23 & 0xFFFFF800;
          if ((v23 & 0xFFFFF800) == 0xD800)
          {
            if ((v23 & 0x400) != 0)
            {
              v26 = v23;
              if (v20 <= v8 - 2)
              {
                v28 = *(v8 - 2);
                v26 = v23;
                if ((v28 & 0xFC00) == 0xD800)
                  v26 = v23 - 56613888 + (v28 << 10);
              }
            }
            else
            {
              v26 = v23;
              if (v8 != v17)
              {
                v27 = *v8;
                v26 = v23;
                if ((v27 & 0xFC00) == 0xDC00)
                  v26 = ((_DWORD)v23 << 10) - 56613888 + v27;
              }
            }
          }
          v12 = v22 & 0xFFFFF800;
          v29 = v22;
          v48 = v12;
          if ((_DWORD)v12 == 55296)
          {
            if ((v22 & 0x400) != 0)
            {
              v12 = (uint64_t)(v10 - 2);
              v29 = v22;
              if (v21 <= v10 - 2)
              {
                v12 = *(unsigned __int16 *)v12;
                v29 = v22;
                if ((v12 & 0xFC00) == 0xD800)
                  v29 = v22 - 56613888 + ((_DWORD)v12 << 10);
              }
            }
            else
            {
              v29 = v22;
              if (v10 != v18)
              {
                v12 = *v10;
                v29 = v22;
                if ((v12 & 0xFC00) == 0xDC00)
                  v29 = (v22 << 10) - 56613888 + v12;
              }
            }
          }
          v49 = v29;
          v46 = v26;
          if ((v16 & 0x10000) == 0)
            break;
          if (v14)
            break;
          v30 = ucase_toFullFolding(v26, &src, a5);
          v16 = a5;
          v51 = v30;
          if ((v30 & 0x80000000) != 0)
            break;
          LOWORD(v31) = v30;
          if (v47 == 55296)
          {
            if ((v23 & 0x400) != 0)
            {
              v22 = *(v10 - 2);
              --v10;
            }
            else
            {
              ++v8;
            }
          }
          *(_QWORD *)&v75 = v20;
          *((_QWORD *)&v75 + 1) = v8;
          v76[0] = v17;
          if (v30 > 0x1F)
          {
            if (HIWORD(v30))
            {
              v31 = (v30 >> 10) - 10304;
              dest[1] = v30 & 0x3FF | 0xDC00;
              v12 = 2;
            }
            else
            {
              v12 = 1;
            }
            dest[0] = v31;
            v51 = v12;
          }
          else
          {
            u_memcpy(dest, src, v30);
            v16 = a5;
            v12 = v51;
          }
          v8 = dest;
          v17 = &dest[(int)v12];
          v19 = 0xFFFFFFFFLL;
          v14 = 1;
          v20 = dest;
        }
        if ((v16 & 0x10000) == 0)
          break;
        if (v15)
          break;
        v32 = ucase_toFullFolding(v49, &src, a5);
        v16 = a5;
        v51 = v32;
        if ((v32 & 0x80000000) != 0)
          break;
        LOWORD(v33) = v32;
        if (v48 != 55296)
          goto LABEL_79;
        if ((v22 & 0x400) == 0)
        {
          ++v10;
LABEL_79:
          v19 = v23;
          goto LABEL_106;
        }
        v19 = *(v8 - 2);
        --v8;
LABEL_106:
        *(_QWORD *)&v73 = v21;
        *((_QWORD *)&v73 + 1) = v10;
        v74[0] = v18;
        if (v32 > 0x1F)
        {
          if (HIWORD(v32))
          {
            v33 = (v32 >> 10) - 10304;
            v63[1] = v32 & 0x3FF | 0xDC00;
            v12 = 2;
          }
          else
          {
            v12 = 1;
          }
          v63[0] = v33;
          v51 = v12;
        }
        else
        {
          v38 = v19;
          u_memcpy(v63, src, v32);
          v19 = v38;
          v16 = a5;
          v12 = v51;
        }
        v10 = v63;
        v18 = &v63[(int)v12];
        v22 = -1;
        v15 = 1;
        v21 = v63;
      }
      if (v14 > 1)
        break;
      Decomposition = icu::Normalizer2Impl::getDecomposition(v45, v46, &v72, (int *)&v51);
      v16 = a5;
      src = Decomposition;
      if (!Decomposition)
        break;
      if (v47 == 55296)
      {
        if ((v23 & 0x400) != 0)
        {
          v22 = *(v10 - 2);
          --v10;
        }
        else
        {
          ++v8;
        }
      }
      v39 = (UChar **)&v76[3 * v14 - 2];
      *v39 = v20;
      v39[1] = v8;
      v39[2] = v17;
      if (v14 <= 0)
      {
        v40 = v14;
        v14 += 2;
        v76[3 * v40 + 1] = 0;
      }
      else
      {
        v14 = 2;
      }
      v12 = (int)v51;
      v17 = &Decomposition[v51];
      v19 = 0xFFFFFFFFLL;
      v8 = Decomposition;
      v20 = Decomposition;
    }
    if (v15 > 1)
      break;
    v35 = icu::Normalizer2Impl::getDecomposition(v45, v49, &v71, (int *)&v51);
    v16 = a5;
    src = v35;
    if (!v35)
      break;
    if (v48 != 55296)
      goto LABEL_90;
    if ((v22 & 0x400) == 0)
    {
      ++v10;
LABEL_90:
      v19 = v23;
      goto LABEL_100;
    }
    v19 = *(v8 - 2);
    --v8;
LABEL_100:
    v36 = (UChar **)&v74[3 * v15 - 2];
    *v36 = v21;
    v36[1] = v10;
    v36[2] = v18;
    if (v15 <= 0)
    {
      v37 = v15;
      v15 += 2;
      v74[3 * v37 + 1] = 0;
    }
    else
    {
      v15 = 2;
    }
    v12 = (int)v51;
    v18 = &v35[v51];
    v22 = -1;
    v10 = v35;
    v21 = v35;
  }
  if ((v16 & 0x8000) != 0)
  {
    v12 = v23 >> 11;
    if (v12 >= 0x1B)
    {
      v12 = v22 >> 11;
      if (v12 >= 0x1B)
      {
        if ((v23 >> 10 > 0x36 || v8 == v17 || (*v8 & 0xFC00) != 0xDC00)
          && (v23 >> 10 != 55 || v20 == v8 - 1 || (*(v8 - 2) & 0xFC00) != 0xD800))
        {
          LODWORD(v23) = v23 - 10240;
        }
        v12 = v22 >> 10;
        if (v12 > 0x36 || v10 == v18 || (*v10 & 0xFC00) != 0xDC00)
        {
          if ((_DWORD)v12 != 55 || v21 == v10 - 1 || (v12 = *(v10 - 2) & 0xFC00, (_DWORD)v12 != 55296))
          {
            v12 = 4294957056;
            v22 -= 10240;
          }
        }
      }
    }
  }
  v6 = v23 - v22;
LABEL_124:
  icu::UnicodeString::~UnicodeString((void *)v12, (icu::UnicodeString *)&v53);
  icu::UnicodeString::~UnicodeString(v43, (icu::UnicodeString *)&v58);
  return v6;
}

uint64_t sub_18BC5A098(uint64_t a1, uint64_t a2, unsigned int a3, icu::UnicodeString *a4, unsigned int *a5)
{
  int v8;
  void *v9;
  int v10;
  const UChar *v11;
  int v12;
  void *v13;
  uint64_t v14;
  const UChar *v16;
  uint64_t v17;
  _OWORD v18[4];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = a2;
  icu::UnicodeString::UnicodeString(&v19, a3 >> 31, &v17);
  v8 = (*(uint64_t (**)(uint64_t, __int128 *, unsigned int *))(*(_QWORD *)a1 + 112))(a1, &v19, a5);
  v9 = (void *)*a5;
  if ((int)v9 > 0)
    goto LABEL_12;
  v10 = v8;
  LODWORD(v9) = WORD4(v19) >> 5;
  v9 = (SWORD4(v19) & 0x8000u) == 0 ? (void *)v9 : (void *)HIDWORD(v19);
  if (v8 >= (int)v9)
    goto LABEL_12;
  memset(v18, 0, sizeof(v18));
  icu::UnicodeString::tempSubString((icu::UnicodeString *)&v19, v8, 0x7FFFFFFF, (icu::UnicodeString *)v18);
  if ((BYTE8(v19) & 0x11) != 0)
    v11 = 0;
  else
    v11 = (const UChar *)((BYTE8(v19) & 2) != 0 ? (unint64_t)&v19 | 0xA : *((_QWORD *)&v20 + 1));
  v16 = v11;
  icu::UnicodeString::setTo(a4, 0, &v16, v10);
  (*(void (**)(uint64_t, icu::UnicodeString *, _OWORD *, unsigned int *))(*(_QWORD *)a1 + 40))(a1, a4, v18, a5);
  v12 = *a5;
  icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v18);
  if (v12 < 1)
    v14 = 1;
  else
LABEL_12:
    v14 = 0;
  icu::UnicodeString::~UnicodeString(v9, (icu::UnicodeString *)&v19);
  return v14;
}

void icu::UMemory::operator delete(void *a1)
{
  if (a1)
    uprv_free(a1);
}

void icu::UMemory::operator delete[](void *a1)
{
  if (a1)
    uprv_free(a1);
}

void icu::UObject::~UObject(void *this)
{
  if (this)
    uprv_free(this);
}

uint64_t icu::UObject::getDynamicClassID(icu::UObject *this)
{
  return 0;
}

uint64_t uprv_deleteUObject(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

UBool u_hasBinaryProperty(UChar32 c, UProperty which)
{
  if (which <= (UCHAR_BINARY_LIMIT|UCHAR_BIDI_CONTROL))
    return (*((uint64_t (**)(char *, _QWORD))&unk_1E2256CD0 + 2 * which + 1))((char *)&unk_1E2256CD0 + 16 * which, *(_QWORD *)&c);
  else
    return 0;
}

BOOL u_isEmoji(unsigned int a1)
{
  return sub_18BBB94F4(a1, 57);
}

UBool u_isIDStart(UChar32 c)
{
  return (sub_18BC0A7DC(c, 1) >> 24) & 1;
}

UBool u_isIDPart(UChar32 c)
{
  return (sub_18BC0A7DC(c, 1) >> 25) & 1;
}

UBool u_stringHasBinaryProperty(const UChar *s, int32_t length, UProperty which)
{
  UChar v4;
  int v5;
  uint64_t (*v6)(void);

  if (!s && length)
    return 0;
  if (length != 1)
  {
    if (length == 2)
    {
      v4 = *s;
    }
    else
    {
      if ((length & 0x80000000) == 0)
        goto LABEL_20;
      v4 = *s;
      if (!*s)
        goto LABEL_20;
    }
    v5 = 1;
    if ((v4 & 0xFC00) == 0xD800)
    {
      if ((s[1] & 0xFC00) == 0xDC00)
        v5 = 2;
      else
        v5 = 1;
    }
    if (length < 1)
    {
      if (!s[v5])
        goto LABEL_22;
    }
    else if (v5 == length)
    {
LABEL_22:
      if (which <= (UCHAR_BINARY_LIMIT|UCHAR_BIDI_CONTROL))
      {
        v6 = *(uint64_t (**)(void))&dword_1E2256CD0[4 * which + 2];
        return v6();
      }
      return 0;
    }
LABEL_20:
    if ((which - 65) <= 6)
      return sub_18BBB9600(s, length, which);
    return 0;
  }
  if (which > (UCHAR_BINARY_LIMIT|UCHAR_BIDI_CONTROL))
    return 0;
  v6 = *(uint64_t (**)(void))&dword_1E2256CD0[4 * which + 2];
  return v6();
}

int32_t u_getIntPropertyValue(UChar32 c, UProperty which)
{
  if (which > (UCHAR_BINARY_LIMIT|UCHAR_CHANGES_WHEN_CASEMAPPED|0xF80))
  {
    if (which <= UCHAR_VERTICAL_ORIENTATION)
      return ((uint64_t (*)(uint64_t (**)(void), _QWORD))qword_1E2257180[4 * (which - 4096) + 2])(&qword_1E2257180[4 * (which - 4096)], *(_QWORD *)&c);
    if (which == UCHAR_GENERAL_CATEGORY_MASK)
      return 1 << u_charType(c);
  }
  else if (which <= (UCHAR_BINARY_LIMIT|UCHAR_BIDI_CONTROL))
  {
    return (*(uint64_t (**)(unsigned int *, _QWORD))&dword_1E2256CD0[4 * which + 2])(&dword_1E2256CD0[4 * which], *(_QWORD *)&c);
  }
  return 0;
}

int32_t u_getIntPropertyMinValue(UProperty which)
{
  return 0;
}

int32_t u_getIntPropertyMaxValue(UProperty which)
{
  if (which > (UCHAR_BINARY_LIMIT|UCHAR_CHANGES_WHEN_CASEMAPPED|0xF80))
  {
    if (which <= UCHAR_VERTICAL_ORIENTATION)
      return qword_1E2257180[4 * (which - 4096) + 3]();
  }
  else if (which < (UCHAR_BINARY_LIMIT|UCHAR_BIDI_MIRRORED))
  {
    return 1;
  }
  return -1;
}

uint64_t sub_18BC5A4BC(unsigned int a1)
{
  if ((a1 & 0x80000000) != 0)
    return 0;
  if (a1 > 0x4A)
  {
    if (a1 >= 0x1000)
    {
      if (a1 <= 0x1018)
      {
        if (((0x1E3FEE5uLL >> a1) & 1) == 0)
          return 2;
        return LODWORD(qword_1E2257180[4 * a1 - 0x4000]);
      }
      if (!(a1 >> 14))
        return (a1 & 0xFFFFEFFF) == 0x2000;
      if (a1 > 0x400D)
        return 2 * (a1 == 28672);
      if (a1 - 0x4000 < 0xD)
        return dword_18BE1536C[a1 - 0x4000];
    }
    return 0;
  }
  if (dword_1E2256CD0[4 * a1 + 1])
    return 2;
  return dword_1E2256CD0[4 * a1];
}

uint64_t sub_18BC5A584(uint64_t result, _QWORD *a2, UErrorCode *a3)
{
  int v4;
  uint64_t i;
  uint64_t j;
  unsigned int v7;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;

  if (*(int *)a3 > 0)
    return result;
  v4 = result;
  if ((_DWORD)result == 17)
  {
    for (i = 0; i != 10; ++i)
      ((void (*)(_QWORD, _QWORD))a2[1])(*a2, dword_18BE152E8[i]);
    for (j = 0; j != 13; ++j)
    {
      v7 = dword_18BE15310[j];
      ((void (*)(_QWORD, _QWORD))a2[1])(*a2, v7);
      result = ((uint64_t (*)(_QWORD, _QWORD))a2[1])(*a2, v7 + 1);
    }
    return result;
  }
  result = sub_18BC5A6C4(a3);
  if (!(_DWORD)result)
    return result;
  if ((v4 - 12) > 2)
  {
    v13 = 1;
LABEL_17:
    *a3 = v13;
    return result;
  }
  v9 = (uint64_t *)off_1E22574A0[v4 - 12];
  v10 = *v9;
  if (!*v9)
  {
    v13 = 2;
    goto LABEL_17;
  }
  result = ucptrie_getRange(*v9, 0, 0, 0, 0, 0, 0);
  if ((result & 0x80000000) == 0)
  {
    v11 = result;
    v12 = 0;
    do
    {
      ((void (*)(_QWORD, uint64_t))a2[1])(*a2, v12);
      v12 = (v11 + 1);
      result = ucptrie_getRange(v10, v12, 0, 0, 0, 0, 0);
      v11 = result;
    }
    while ((result & 0x80000000) == 0);
  }
  return result;
}

BOOL sub_18BC5A6C4(UErrorCode *a1)
{
  unsigned int v3;
  _QWORD *v4;
  UErrorCode v5;
  int *Memory;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;

  if (*(int *)a1 > 0)
    return 0;
  v3 = atomic_load(&dword_1EE00963C);
  if (v3 == 2 || !icu::umtx_initImplPreInit(&dword_1EE00963C))
  {
    if (dword_1EE009640 >= 1)
      *a1 = dword_1EE009640;
  }
  else
  {
    v4 = udata_openChoice(0, "icu", "ulayout", (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18BC5B5F0, 0, a1);
    qword_1EE009648 = (uint64_t)v4;
    v5 = *a1;
    if (*(int *)a1 <= 0)
    {
      Memory = (int *)udata_getMemory((uint64_t)v4);
      v7 = *Memory;
      if ((int)v7 > 11)
      {
        v8 = Memory;
        v9 = 4 * v7;
        v10 = Memory[1];
        if ((int)v10 - (int)v9 >= 16)
          qword_1EE009618 = (uint64_t)ucptrie_openFromBinary(-1, -1, (uint64_t)&Memory[(unint64_t)v9 / 4], (int)v10 - (int)v9, 0, (int *)a1);
        v11 = v8[2];
        if ((int)v11 - (int)v10 >= 16)
          qword_1EE009620 = (uint64_t)ucptrie_openFromBinary(-1, -1, (uint64_t)v8 + v10, (int)v11 - (int)v10, 0, (int *)a1);
        v12 = v8[3] - v11;
        if (v12 >= 16)
          qword_1EE009628 = (uint64_t)ucptrie_openFromBinary(-1, -1, (uint64_t)v8 + v11, v12, 0, (int *)a1);
        v13 = v8[9];
        dword_1EE009630 = HIBYTE(v13);
        dword_1EE009634 = BYTE2(v13);
        dword_1EE009638 = BYTE1(v13);
        sub_18BC0ECC4(0x14u, (uint64_t)sub_18BC5B654);
        v5 = *a1;
      }
      else
      {
        v5 = U_INVALID_FORMAT_ERROR;
        *a1 = U_INVALID_FORMAT_ERROR;
      }
    }
    dword_1EE009640 = v5;
    icu::umtx_initImplPostInit(&dword_1EE00963C);
  }
  return *a1 < U_ILLEGAL_ARGUMENT_ERROR;
}

int32_t u_getFC_NFKC_Closure(UChar32 c, UChar *dest, int32_t destCapacity, UErrorCode *pErrorCode)
{
  int32_t v5;
  uint64_t NFKCInstance;
  icu::Normalizer2Factory *v11;
  unsigned int v12;
  const icu::Normalizer2 *v13;
  UChar32 v14;
  uint64_t Impl;
  unsigned int v16;
  icu::UnicodeString *v17;
  _QWORD *v18;
  void *v19;
  void *v20;
  void *v21;
  _QWORD v22[2];
  UChar *v23;
  const UChar *v24;
  const UChar *v25;
  void (**v26)(icu::UnicodeString *__hidden);
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  _OWORD v31[4];
  UChar *v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  void (**v37)(icu::UnicodeString *__hidden);
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (pErrorCode && *(int *)pErrorCode <= 0)
  {
    if (destCapacity < 0 || !dest && destCapacity)
    {
      v5 = 0;
      *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
      return v5;
    }
    NFKCInstance = icu::Normalizer2::getNFKCInstance((icu::Normalizer2 *)pErrorCode, (UErrorCode *)dest);
    if (*(int *)pErrorCode <= 0)
    {
      v11 = (icu::Normalizer2Factory *)NFKCInstance;
      v41 = 0;
      v40 = 0u;
      v38 = 0u;
      v39 = 0u;
      v37 = off_1E2256B38;
      LOWORD(v38) = 2;
      v25 = 0;
      v12 = ucase_toFullFolding(c, &v25, 0);
      if ((v12 & 0x80000000) != 0)
      {
        Impl = icu::Normalizer2Factory::getImpl(v11, v13);
        v16 = sub_18BBD79D4(Impl, c);
        if (v16 > 0xFE01 || *(unsigned __int16 *)(Impl + 18) > v16 || *(unsigned __int16 *)(Impl + 30) <= v16)
        {
          v5 = u_terminateUChars((uint64_t)dest, destCapacity, 0, (int *)pErrorCode);
LABEL_24:
          icu::UnicodeString::~UnicodeString(v21, (icu::UnicodeString *)&v37);
          return v5;
        }
        v14 = c;
      }
      else
      {
        if (v12 < 0x20)
        {
          v24 = v25;
          icu::UnicodeString::setTo((icu::UnicodeString *)&v37, 0, &v24, v12);
          v22[1] = v24;
LABEL_19:
          v36 = 0;
          v34 = 0u;
          v35 = 0u;
          v33 = 0u;
          v32 = (UChar *)off_1E2256B38;
          LOWORD(v33) = 2;
          (*(void (**)(icu::Normalizer2Factory *, void (***)(icu::UnicodeString *__hidden), UChar **, UErrorCode *))(*(_QWORD *)v11 + 24))(v11, &v37, &v32, pErrorCode);
          memset(v31, 0, sizeof(v31));
          icu::UnicodeString::UnicodeString((icu::UnicodeString *)v31, &v32);
          v17 = icu::UnicodeString::foldCase((const UChar **)v31, 0);
          v27 = 0u;
          v28 = 0u;
          v29 = 0u;
          v30 = 0;
          v26 = off_1E2256B38;
          LOWORD(v27) = 2;
          (*(void (**)(icu::Normalizer2Factory *, icu::UnicodeString *, void (***)(icu::UnicodeString *__hidden), UErrorCode *))(*(_QWORD *)v11 + 24))(v11, v17, &v26, pErrorCode);
          if (*(int *)pErrorCode > 0 || sub_18BBED900((uint64_t)&v32, (uint64_t)&v26))
          {
            v5 = u_terminateUChars((uint64_t)dest, destCapacity, 0, (int *)pErrorCode);
          }
          else
          {
            v23 = dest;
            v5 = icu::UnicodeString::extract((uint64_t)&v26, &v23, destCapacity, (int *)pErrorCode);
            v22[0] = v23;
            v18 = v22;
          }
          icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v26);
          icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v31);
          icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v32);
          goto LABEL_24;
        }
        v14 = v12;
      }
      sub_18BC5AB50((uint64_t)&v37, v14);
      goto LABEL_19;
    }
  }
  return 0;
}

uint64_t sub_18BC5AB50(uint64_t a1, unsigned int a2)
{
  uint64_t v4;

  icu::UnicodeString::unBogus(a1);
  if (*(__int16 *)(a1 + 8) < 0)
    v4 = *(unsigned int *)(a1 + 12);
  else
    v4 = *(unsigned __int16 *)(a1 + 8) >> 5;
  return icu::UnicodeString::replace((icu::UnicodeString *)a1, 0, v4, a2);
}

BOOL sub_18BC5AB98(int *a1, unsigned int a2)
{
  return (a1[1] & sub_18BC0A7DC(a2, *a1)) != 0;
}

uint64_t sub_18BC5ABD0(uint64_t a1, unsigned int a2)
{
  return sub_18BC022A4(a2);
}

uint64_t sub_18BC5ABD8(int a1, UChar32 c)
{
  return u_isMirrored_0(c);
}

BOOL sub_18BC5ABE0(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2;
  uint64_t NFCImpl;
  _BOOL8 result;
  unsigned int v5;
  int v6;

  v2 = a2;
  v6 = 0;
  NFCImpl = icu::Normalizer2Factory::getNFCImpl((icu::Normalizer2Factory *)&v6, a2);
  result = 0;
  if (v6 <= 0)
  {
    v5 = sub_18BBD79D4(NFCImpl, v2);
    return *(unsigned __int16 *)(NFCImpl + 18) <= v5 && *(unsigned __int16 *)(NFCImpl + 30) > v5;
  }
  return result;
}

uint64_t sub_18BC5AC50(uint64_t a1, unsigned int a2)
{
  return sub_18BC02318(a2);
}

uint64_t sub_18BC5AC58(uint64_t a1, unsigned int a2, int a3)
{
  return (char)sub_18BC07A94(a2, a3);
}

BOOL sub_18BC5AC78(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t Instance;
  uint64_t v5;
  int v7;

  v7 = 0;
  Instance = icu::Normalizer2Factory::getInstance(a3 - 35, (icu::Normalizer2Factory *)&v7);
  v5 = 0;
  if (v7 <= 0)
    return (*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)Instance + 136))(Instance, a2) != 0;
  return v5;
}

BOOL sub_18BC5ACD8(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2;
  icu::Normalizer2Impl *NFCImpl;
  _BOOL8 result;
  UErrorCode v5;

  v2 = a2;
  v5 = U_ZERO_ERROR;
  NFCImpl = (icu::Normalizer2Impl *)icu::Normalizer2Factory::getNFCImpl((icu::Normalizer2Factory *)&v5, a2);
  result = 0;
  if (v5 <= U_ZERO_ERROR)
  {
    result = icu::Normalizer2Impl::ensureCanonIterData(NFCImpl, &v5);
    if (result)
      return icu::Normalizer2Impl::isCanonSegmentStarter(NFCImpl, v2);
  }
  return result;
}

BOOL sub_18BC5AD40(uint64_t a1, unsigned int a2)
{
  return sub_18BC0A8F0(a2);
}

uint64_t sub_18BC5AD48(int a1, UChar32 c)
{
  return u_isblank(c);
}

BOOL sub_18BC5AD50(uint64_t a1, unsigned int a2)
{
  return sub_18BC0AE90(a2);
}

BOOL sub_18BC5AD58(uint64_t a1, unsigned int a2)
{
  return sub_18BC0ADF4(a2);
}

uint64_t sub_18BC5AD60(int a1, UChar32 c)
{
  return u_isxdigit(c);
}

BOOL sub_18BC5AD68(uint64_t a1, UErrorCode *a2)
{
  UErrorCode *v2;
  uint64_t NFCInstance;
  _BOOL8 v4;
  unint64_t v5;
  unsigned int v6;
  int v7;
  unsigned __int16 *v8;
  int v9;
  unsigned int v11;
  int v12;
  const UChar *v13;
  int v14;
  int32_t v15;
  int32_t v16;
  int32_t v17;
  int32_t v18;
  const UChar *v19;
  int32_t v20;
  UErrorCode pErrorCode;
  UChar dest[8];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _DWORD v28[7];
  void (**v29)(icu::UnicodeString *__hidden);
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;

  v2 = a2;
  v34 = *MEMORY[0x1E0C80C00];
  v30 = 0u;
  v33 = 0;
  v32 = 0u;
  v31 = 0u;
  v29 = off_1E2256B38;
  LOWORD(v30) = 2;
  pErrorCode = U_ZERO_ERROR;
  NFCInstance = icu::Normalizer2::getNFCInstance((icu::Normalizer2 *)&pErrorCode, a2);
  v4 = 0;
  v5 = pErrorCode;
  if (pErrorCode > U_ZERO_ERROR)
    goto LABEL_15;
  if (!(*(unsigned int (**)(uint64_t, UErrorCode *, void (***)(icu::UnicodeString *__hidden)))(*(_QWORD *)NFCInstance + 56))(NFCInstance, v2, &v29))
  {
    if ((v2 & 0x80000000) != 0)
    {
      v4 = 0;
      goto LABEL_15;
    }
LABEL_14:
    *(_QWORD *)dest = 0;
    v9 = ucase_toFullFolding(v2, dest, 0);
    v5 = ~v9;
    v4 = v9 >= 0;
    goto LABEL_15;
  }
  v6 = (unsigned __int16)v30;
  if (((__int16)v30 & 0x80000000) == 0)
  {
    if ((v30 & 0xFFE0) != 0x20)
    {
      if ((unsigned __int16)v30 > 0x5Fu)
        goto LABEL_23;
      v7 = (unsigned __int16)v30 >> 5;
      goto LABEL_17;
    }
LABEL_10:
    if ((v30 & 2) != 0)
      v8 = (unsigned __int16 *)&v30 + 1;
    else
      v8 = (unsigned __int16 *)v31;
    LODWORD(v2) = *v8;
    goto LABEL_14;
  }
  v7 = DWORD1(v30);
  if (DWORD1(v30) == 1)
    goto LABEL_10;
  if (SDWORD1(v30) >= 3)
    goto LABEL_23;
LABEL_17:
  v11 = icu::UnicodeString::char32At((uint64_t *)(unsigned __int16)v30, (icu::UnicodeString *)&v29, 0);
  if (v11 < 0x10000)
    v12 = 1;
  else
    v12 = 2;
  if ((v11 & 0x80000000) == 0)
  {
    LODWORD(v2) = v11;
    if (v7 == v12)
      goto LABEL_14;
  }
  v6 = (unsigned __int16)v30;
LABEL_23:
  v27 = 0u;
  memset(v28, 0, sizeof(v28));
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  *(_OWORD *)dest = 0u;
  if ((v6 & 0x11) != 0)
  {
    v13 = 0;
  }
  else if ((v6 & 2) != 0)
  {
    v13 = (const UChar *)&v30 + 1;
  }
  else
  {
    v13 = (const UChar *)v31;
  }
  v14 = (__int16)v6;
  v15 = v6 >> 5;
  if (v14 >= 0)
    v16 = v15;
  else
    v16 = DWORD1(v30);
  v17 = u_strFoldCase(dest, 62, v13, v16, 0, &pErrorCode);
  v4 = 0;
  v5 = pErrorCode;
  if (pErrorCode <= U_ZERO_ERROR)
  {
    v18 = v17;
    if ((v30 & 0x11) != 0)
    {
      v19 = 0;
    }
    else if ((v30 & 2) != 0)
    {
      v19 = (const UChar *)&v30 + 1;
    }
    else
    {
      v19 = (const UChar *)v31;
    }
    if ((v30 & 0x8000u) == 0)
      v20 = (unsigned __int16)v30 >> 5;
    else
      v20 = DWORD1(v30);
    v4 = u_strCompare(v19, v20, dest, v18, 0) != 0;
  }
LABEL_15:
  icu::UnicodeString::~UnicodeString((void *)v5, (icu::UnicodeString *)&v29);
  return v4;
}

uint64_t sub_18BC5AFAC(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2;
  uint64_t NFKC_CFImpl;
  uint64_t v4;
  UChar *v5;
  UChar *v6;
  int v7;
  unint64_t v8;
  int v9;
  int v10;
  void *v11;
  UChar *v13;
  icu::UnicodeString *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  UErrorCode v18;
  void (**v19)(icu::UnicodeString *__hidden);
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v2 = a2;
  v28 = *MEMORY[0x1E0C80C00];
  v18 = U_ZERO_ERROR;
  NFKC_CFImpl = icu::Normalizer2Factory::getNFKC_CFImpl((icu::Normalizer2Factory *)&v18, a2);
  v4 = 0;
  if (v18 <= U_ZERO_ERROR)
  {
    v5 = (UChar *)NFKC_CFImpl;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    icu::UnicodeString::UnicodeString((uint64_t)&v24, v2);
    v20 = 0u;
    v23 = 0;
    v22 = 0u;
    v21 = 0u;
    v19 = off_1E2256B38;
    LOWORD(v20) = 2;
    v17 = 0u;
    v13 = v5;
    v14 = (icu::UnicodeString *)&v19;
    v16 = 0u;
    v15 = 0u;
    *(_QWORD *)((char *)&v16 + 5) = 0;
    if (icu::ReorderingBuffer::init((icu::ReorderingBuffer *)&v13, 5, &v18))
    {
      if ((BYTE8(v24) & 0x11) != 0)
      {
        v6 = 0;
      }
      else if ((BYTE8(v24) & 2) != 0)
      {
        v6 = (UChar *)((unint64_t)&v24 | 0xA);
      }
      else
      {
        v6 = (UChar *)*((_QWORD *)&v25 + 1);
      }
      v7 = WORD4(v24) >> 5;
      if (SWORD4(v24) < 0)
        v7 = HIDWORD(v24);
      icu::Normalizer2Impl::compose((uint64_t)v5, v6, &v6[v7], 0, 1, &v13, &v18);
    }
    if ((_QWORD)v15)
      icu::UnicodeString::releaseBuffer((uint64_t)v14, ((_QWORD)v16 - (_QWORD)v15) >> 1);
    v8 = v18;
    if (v18 <= U_ZERO_ERROR)
    {
      if ((v20 & 1) != 0)
      {
        v8 = BYTE8(v24) & 1;
      }
      else
      {
        v8 = 0;
        if ((v20 & 0x8000u) == 0)
          v9 = (unsigned __int16)v20 >> 5;
        else
          v9 = DWORD1(v20);
        if ((SWORD4(v24) & 0x8000u) == 0)
          v10 = WORD4(v24) >> 5;
        else
          v10 = HIDWORD(v24);
        if ((BYTE8(v24) & 1) == 0 && v9 == v10)
          v8 = icu::UnicodeString::doEquals((icu::UnicodeString *)&v19, (const icu::UnicodeString *)&v24, v9);
      }
      v4 = v8 ^ 1;
    }
    else
    {
      v4 = 0;
    }
    icu::UnicodeString::~UnicodeString((void *)v8, (icu::UnicodeString *)&v19);
    icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)&v24);
  }
  return v4;
}

BOOL sub_18BC5B1A4(uint64_t a1, unsigned int a2, int a3)
{
  return sub_18BBB94F4(a2, a3);
}

BOOL sub_18BC5B1B0(uint64_t a1, int a2)
{
  return (a2 - 127462) < 0x1A;
}

BOOL sub_18BC5B1C4(uint64_t a1, unsigned int a2)
{
  return a2 >> 1 == 6143;
}

BOOL sub_18BC5B1D4(uint64_t a1, int a2)
{
  uint64_t v3;
  int v4;

  if (a2 < 8706)
    return 0;
  v3 = 0;
  do
  {
    v4 = dword_18BE15310[v3];
    if (v4 == a2)
      break;
  }
  while (v3++ != 12);
  return v4 == a2;
}

BOOL sub_18BC5B21C(uint64_t a1, int a2)
{
  unint64_t v2;
  BOOL v3;
  uint64_t v5;
  int v6;

  v2 = 0;
  do
  {
    if (dword_18BE152E8[v2] > a2)
      return 0;
    if (dword_18BE152E8[v2 + 1] > a2)
      return 1;
    v3 = v2 > 7;
    v2 += 2;
  }
  while (!v3);
  if (a2 < 8706)
    return 0;
  v5 = 0;
  do
  {
    v6 = dword_18BE15310[v5];
    if (v6 == a2)
      break;
  }
  while (v5++ != 12);
  return v6 == a2;
}

uint64_t sub_18BC5B2A4(int a1, UChar32 c)
{
  return u_charDirection(c);
}

uint64_t sub_18BC5B2AC(uint64_t a1, int a2)
{
  return sub_18BC02094(a2);
}

uint64_t sub_18BC5B2B4(int *a1, unsigned int a2)
{
  return ((int)(a1[1] & sub_18BC0A7DC(a2, *a1)) >> a1[2]);
}

uint64_t sub_18BC5B2EC(int *a1)
{
  return (a1[1] & sub_18BC0B598(*a1)) >> a1[2];
}

uint64_t sub_18BC5B31C(int a1, UChar32 c)
{
  return u_getCombiningClass(c);
}

uint64_t sub_18BC5B334(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_18BC5B33C(int a1, UChar32 c)
{
  return u_charType(c);
}

uint64_t sub_18BC5B354(uint64_t a1, int a2)
{
  return sub_18BC02400(a2);
}

uint64_t sub_18BC5B35C(uint64_t a1, unsigned int a2)
{
  return sub_18BC0238C(a2);
}

uint64_t sub_18BC5B364(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  int v3;
  unsigned int v4;

  v2 = sub_18BC0B528(a2);
  if (v2 < 0x540)
    v3 = 2;
  else
    v3 = 3;
  if (v2 >= 0x2C0)
    v4 = v3;
  else
    v4 = 1;
  if (v2 >= 0x40)
    return v4;
  else
    return 0;
}

uint64_t sub_18BC5B39C(uint64_t a1, unsigned int a2)
{
  int v3;

  v3 = 0;
  return uscript_getScript(a2, &v3);
}

uint64_t sub_18BC5B3C4()
{
  unsigned int v0;

  v0 = sub_18BC0B598(0);
  return v0 | (((v0 >> 20) & 3) << 8);
}

uint64_t sub_18BC5B3E8(uint64_t a1, unsigned int a2)
{
  unsigned int v2;

  v2 = (sub_18BC0A7DC(a2, 2) >> 5) & 0x1F;
  if (v2 > 9)
    return 0;
  else
    return dword_18BE15344[v2];
}

uint64_t sub_18BC5B424(int a1, uint64_t a2, int a3)
{
  return sub_18BBBC9F8(a2, a3 - 4106);
}

uint64_t sub_18BC5B434(uint64_t a1, signed int a2)
{
  return sub_18BBD6A58(a2) >> 8;
}

uint64_t sub_18BC5B450(uint64_t a1, signed int a2)
{
  return sub_18BBD6A58(a2);
}

uint64_t sub_18BC5B46C(uint64_t a1, unsigned int a2)
{
  return sub_18BC02440(a2);
}

uint64_t sub_18BC5B474(uint64_t a1, unsigned int a2)
{
  _BOOL4 v3;
  uint64_t result;
  int v5;

  v5 = 0;
  v3 = sub_18BC5A6C4((UErrorCode *)&v5);
  result = 0;
  if (v3)
  {
    if (qword_1EE009618)
      return ucptrie_get(qword_1EE009618, a2);
  }
  return result;
}

uint64_t sub_18BC5B4C8(uint64_t a1, int a2)
{
  uint64_t result;
  int v4;

  v4 = 0;
  result = sub_18BC5A6C4((UErrorCode *)&v4);
  if ((_DWORD)result)
  {
    switch(a2)
    {
      case 4120:
        return dword_1EE009638;
      case 4119:
        return dword_1EE009634;
      case 4118:
        return dword_1EE009630;
      default:
        return 0;
    }
  }
  return result;
}

uint64_t sub_18BC5B548(uint64_t a1, unsigned int a2)
{
  _BOOL4 v3;
  uint64_t result;
  int v5;

  v5 = 0;
  v3 = sub_18BC5A6C4((UErrorCode *)&v5);
  result = 0;
  if (v3)
  {
    if (qword_1EE009620)
      return ucptrie_get(qword_1EE009620, a2);
  }
  return result;
}

uint64_t sub_18BC5B59C(uint64_t a1, unsigned int a2)
{
  _BOOL4 v3;
  uint64_t result;
  int v5;

  v5 = 0;
  v3 = sub_18BC5A6C4((UErrorCode *)&v5);
  result = 0;
  if (v3)
  {
    if (qword_1EE009628)
      return ucptrie_get(qword_1EE009628, a2);
  }
  return result;
}

BOOL sub_18BC5B5F0(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  return *(unsigned __int16 *)a4 >= 0x14u
      && !a4[4]
      && !a4[5]
      && a4[8] == 76
      && a4[9] == 97
      && a4[10] == 121
      && a4[11] == 111
      && a4[12] == 1;
}

uint64_t sub_18BC5B654()
{
  udata_close((_OWORD *)qword_1EE009648);
  qword_1EE009648 = 0;
  ucptrie_close(qword_1EE009618);
  qword_1EE009618 = 0;
  ucptrie_close(qword_1EE009620);
  qword_1EE009620 = 0;
  ucptrie_close(qword_1EE009628);
  qword_1EE009628 = 0;
  dword_1EE009630 = 0;
  dword_1EE009634 = 0;
  dword_1EE009638 = 0;
  atomic_store(0, &dword_1EE00963C);
  return 1;
}

char *urbtok_open(int a1, const char *a2, const icu::Locale *a3)
{
  char *v4;
  char *v5;

  v4 = ubrk_open(a1, a2, 0, 0, a3);
  v5 = v4;
  if (*(int *)a3 <= 0)
    icu::RuleBasedBreakIterator::initLatin1Cat((icu::RuleBasedBreakIterator *)v4);
  return v5;
}

icu::RuleBasedBreakIterator *urbtok_openRules(uint64_t a1, uint64_t a2, uint64_t a3, UErrorCode *a4)
{
  icu::RuleBasedBreakIterator *v5;
  icu::RuleBasedBreakIterator *v7;
  void *v8;
  _OWORD v10[4];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (!a4 || *(int *)a4 > 0)
    return 0;
  memset(v10, 0, sizeof(v10));
  icu::UnicodeString::UnicodeString((uint64_t)v10, a1, a2);
  v7 = sub_18BBEBC04((UChar **)v10, a3, a4);
  v8 = (void *)*(unsigned int *)a4;
  if ((int)v8 <= 0)
  {
    v5 = v7;
    icu::RuleBasedBreakIterator::initLatin1Cat(v7);
  }
  else
  {
    v5 = 0;
  }
  icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)v10);
  return v5;
}

icu::RuleBasedBreakIterator *urbtok_openBinaryRules(unsigned int *a1, UErrorCode *a2)
{
  icu::RuleBasedBreakIterator *v3;
  size_t v6;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  icu::RuleBasedBreakIterator *v11;

  if (!a2 || *(int *)a2 > 0)
    return 0;
  v6 = a1[2];
  v7 = uprv_malloc(v6);
  if (!v7)
  {
    v3 = 0;
    *a2 = U_MEMORY_ALLOCATION_ERROR;
    return v3;
  }
  v8 = (uint64_t)v7;
  memcpy(v7, a1, v6);
  v11 = (icu::RuleBasedBreakIterator *)icu::UMemory::operator new(v10, (icu::UMemory *)0x310, v9);
  v3 = v11;
  if (!v11)
  {
    if (*(int *)a2 >= 1)
      return 0;
LABEL_11:
    icu::RuleBasedBreakIterator::initLatin1Cat(v3);
    return v3;
  }
  icu::RuleBasedBreakIterator::RuleBasedBreakIterator(v11, v8, a2);
  if (*(int *)a2 < 1)
    goto LABEL_11;
  (*(void (**)(icu::RuleBasedBreakIterator *))(*(_QWORD *)v3 + 8))(v3);
  return 0;
}

icu::RuleBasedBreakIterator *urbtok_openBinaryRulesNoCopy(uint64_t a1, UErrorCode *a2)
{
  uint64_t *v3;
  icu::RuleBasedBreakIterator *v4;
  unsigned int v7;
  icu::RuleBasedBreakIterator *v8;

  if (!a2)
    return 0;
  v3 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v3 > 0)
    return 0;
  v7 = *(_DWORD *)(a1 + 8);
  v8 = (icu::RuleBasedBreakIterator *)icu::UMemory::operator new(v3, (icu::UMemory *)0x310, (unint64_t)a2);
  v4 = v8;
  if (!v8)
  {
    if (*(int *)a2 >= 1)
      return 0;
LABEL_9:
    icu::RuleBasedBreakIterator::initLatin1Cat(v4);
    return v4;
  }
  icu::RuleBasedBreakIterator::RuleBasedBreakIterator(v8, (const unsigned __int8 *)a1, v7, a2);
  if (*(int *)a2 < 1)
    goto LABEL_9;
  (*(void (**)(icu::RuleBasedBreakIterator *))(*(_QWORD *)v4 + 8))(v4);
  return 0;
}

uint64_t urbtok_getBinaryRules(const void *a1, void *a2, unsigned int a3, int *a4)
{
  uint64_t v5;
  void *v8;
  const void *v9;
  int v10;
  size_t __n;

  if (a4 && *a4 <= 0)
  {
    if ((a2 || !a3)
      && a1
    {
      LODWORD(__n) = 0;
      v9 = (const void *)(*(uint64_t (**)(void *, size_t *))(*(_QWORD *)v8 + 200))(v8, &__n);
      v5 = __n;
      if (!a2)
        return v5;
      if (__n <= a3)
      {
        memcpy(a2, v9, __n);
        return v5;
      }
      v10 = 15;
    }
    else
    {
      v5 = 0;
      v10 = 1;
    }
    *a4 = v10;
    return v5;
  }
  return 0;
}

unint64_t urbtok_tokenize(uint64_t a1, int a2, char *a3, _QWORD *a4)
{
  if (a1 && a3)
    return icu::RuleBasedBreakIterator::tokenize(a1, a2, a3, a4);
  else
    return 0;
}

_OWORD *urbtok_swapBinaryRules(_DWORD *a1, void *a2, int a3, int a4, int *a5)
{
  char v6;
  _OWORD *result;
  uint64_t v10;
  unsigned int v11;
  size_t v12;
  _WORD *v13;
  _WORD *v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;

  v6 = a3;
  result = udata_openSwapper(a3, 0, a4, 0, a5);
  if (a5 && *a5 <= 0)
  {
    v10 = (uint64_t)result;
    v11 = (*((uint64_t (**)(_QWORD))result + 2))(a1[2]);
    v12 = v11 + 24;
    v13 = uprv_malloc(v12);
    if (v13)
    {
      v14 = v13;
      v15 = (unsigned __int16 *)uprv_malloc(v12);
      if (v15)
      {
        v16 = v15;
        *v14 = (*(uint64_t (**)(uint64_t))(v10 + 8))(24);
        v14[1] = 10202;
        v14[2] = (*(uint64_t (**)(uint64_t))(v10 + 8))(20);
        v14[3] = 0;
        *((_BYTE *)v14 + 8) = v6;
        *(_WORD *)((char *)v14 + 9) = 512;
        *((_BYTE *)v14 + 11) = 0;
        v17 = a1[1];
        *((_DWORD *)v14 + 3) = 543912514;
        *((_DWORD *)v14 + 4) = v17;
        *((_DWORD *)v14 + 5) = 260;
        memcpy(v14 + 12, a1, v11);
        v21 = ubrk_swap(v10, (uint64_t)v14, v12, v16, a5, v18, v19, v20);
        if (*a5 > 0 || v21 == (_DWORD)v12)
        {
          if (*a5 <= 0)
            memcpy(a2, v16 + 12, v11);
        }
        else
        {
          *a5 = 3;
        }
        uprv_free(v16);
      }
      else
      {
        *a5 = 7;
      }
      uprv_free(v14);
    }
    else
    {
      *a5 = 7;
    }
    return (_OWORD *)udata_closeSwapper(v10);
  }
  return result;
}

icu::RuleBasedTokenizer *urbtok57_openRules(uint64_t a1, uint64_t a2, UParseError *a3, UErrorCode *a4)
{
  icu::RuleBasedTokenizer *v5;
  unint64_t v7;
  uint64_t *v8;
  icu::RuleBasedTokenizer *v9;
  void *v10;
  _OWORD v12[4];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!a4 || *(int *)a4 > 0)
    return 0;
  memset(v12, 0, sizeof(v12));
  icu::UnicodeString::UnicodeString((uint64_t)v12, a1, a2);
  v9 = (icu::RuleBasedTokenizer *)icu::UMemory::operator new(v8, (icu::UMemory *)0x260, v7);
  v5 = v9;
  if (v9)
  {
    icu::RuleBasedTokenizer::RuleBasedTokenizer(v9, (const icu::UnicodeString *)v12, a3, a4);
    v10 = (void *)*(unsigned int *)a4;
    if ((int)v10 >= 1)
    {
      (*(void (**)(icu::RuleBasedTokenizer *))(*(_QWORD *)v5 + 8))(v5);
      v5 = 0;
    }
  }
  icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v12);
  return v5;
}

uint64_t *urbtok57_openBinaryRules(unsigned int *a1, UErrorCode *a2)
{
  uint64_t *result;
  size_t v5;
  unsigned __int8 *v6;
  unint64_t v7;
  uint64_t *v8;

  if (!a2)
    return 0;
  if (*(int *)a2 > 0)
    return 0;
  v5 = a1[2];
  result = (uint64_t *)uprv_malloc(v5);
  if (!result)
  {
    *a2 = U_MEMORY_ALLOCATION_ERROR;
    return result;
  }
  v6 = (unsigned __int8 *)result;
  memcpy(result, a1, v5);
  result = icu::UMemory::operator new(v8, (icu::UMemory *)0x260, v7);
  if (result)
  {
    result = (uint64_t *)icu::RuleBasedTokenizer::RuleBasedTokenizer((icu::RuleBasedTokenizer *)result, v6, a2);
    if (*(int *)a2 >= 1)
    {
      (*(void (**)(uint64_t *))(*result + 8))(result);
      return 0;
    }
  }
  return result;
}

uint64_t urbtok57_openBinaryRulesNoCopy(uint64_t a1, int *a2)
{
  uint64_t result;

  if (!a2)
    return 0;
  if (*a2 > 0)
    return 0;
  result = icu::UMemory::operator new((icu::UMemory *)0x260, (unint64_t)a2);
  if (result)
  {
    result = icu::RuleBasedTokenizer::RuleBasedTokenizer(result, a1, 0, a2);
    if (*a2 >= 1)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)result + 8))(result);
      return 0;
    }
  }
  return result;
}

uint64_t urbtok57_getBinaryRules(const void *a1, void *a2, unsigned int a3, int *a4)
{
  uint64_t v5;
  void *v8;
  const void *v9;
  int v10;
  size_t __n;

  if (a4 && *a4 <= 0)
  {
    if ((a2 || !a3)
      && a1
    {
      LODWORD(__n) = 0;
      v9 = (const void *)(*(uint64_t (**)(void *, size_t *))(*(_QWORD *)v8 + 192))(v8, &__n);
      v5 = __n;
      if (!a2)
        return v5;
      if (__n <= a3)
      {
        memcpy(a2, v9, __n);
        return v5;
      }
      v10 = 15;
    }
    else
    {
      v5 = 0;
      v10 = 1;
    }
    *a4 = v10;
    return v5;
  }
  return 0;
}

_QWORD *ures_openU(UChar *a1, char *a2, int *a3)
{
  _QWORD *result;
  int32_t v7;
  char *v8;
  int v9;
  int32_t v10;
  _QWORD *DefaultConverter;
  int v12;
  char v13[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!a3 || *a3 > 0)
    return 0;
  bzero(v13, 0x400uLL);
  if (!a1)
  {
    v8 = 0;
    return ures_open(v8, a2, a3);
  }
  v7 = u_strlen(a1);
  if (v7 >= 1024)
  {
LABEL_7:
    result = 0;
    *a3 = 1;
    return result;
  }
  v9 = v7;
  if (uprv_isInvariantUString(a1, v7))
  {
    v10 = v9 + 1;
    v8 = v13;
    u_UCharsToChars(a1, v13, v10);
    return ures_open(v8, a2, a3);
  }
  DefaultConverter = (_QWORD *)u_getDefaultConverter((UErrorCode *)a3);
  v12 = ucnv_fromUChars((uint64_t)DefaultConverter, (unint64_t)v13, 1024, a1, v9, a3);
  u_releaseDefaultConverter(DefaultConverter);
  if (*a3 <= 0)
  {
    if (v12 >= 1024)
      goto LABEL_7;
    v8 = v13;
    return ures_open(v8, a2, a3);
  }
  return 0;
}

uint64_t ures_getLocParent(char *Default, void *a2, int a3, int *a4)
{
  const char *v8;
  const char *v9;
  size_t v10;
  int v11;

  if (*a4 > 0)
    return 0;
  if (!Default)
    Default = (char *)uloc_getDefault(0);
  v8 = (const char *)sub_18BC5C070(Default, (uint64_t)"ar_Latn", (uint64_t)"ar_Latn", dword_18BE15CF0, 714);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = strlen(v8);
  v11 = uprv_min(v10, a3);
  memcpy(a2, v9, v11);
  return u_terminateChars((uint64_t)a2, a3, v10, a4);
}

uint64_t sub_18BC5C070(char *__s1, uint64_t a2, uint64_t a3, int *a4, int a5)
{
  int *v5;
  int *v9;
  int *v10;
  int v11;

  if (!a5)
    return 0;
  v5 = a4;
  v9 = &a4[a5];
  while (1)
  {
    v10 = &v5[2 * ((v9 - v5 + (v9 - v5 < 0 ? 3uLL : 0)) >> 2)];
    v11 = strcmp(__s1, (const char *)(a2 + *v10));
    if (!v11)
      break;
    if (v11 < 0)
      v9 = &v5[2 * ((v9 - v5 + (v9 - v5 < 0 ? 3uLL : 0)) >> 2)];
    else
      v5 = v10 + 2;
    if (v5 >= v9)
      return 0;
  }
  return a3 + v10[1];
}

double ures_initStackObject(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 128) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

double icu::StackUResourceBundle::StackUResourceBundle(icu::StackUResourceBundle *this)
{
  double result;

  *((_QWORD *)this + 16) = 0;
  result = 0.0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  *((_QWORD *)this + 16) = 0;
  result = 0.0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

void icu::StackUResourceBundle::~StackUResourceBundle(icu::StackUResourceBundle *this)
{
  sub_18BC5C1BC(this, 1);
}

{
  sub_18BC5C1BC(this, 1);
}

void ures_close(_QWORD *a1)
{
  sub_18BC5C1BC(a1, 1);
}

void sub_18BC5C1BC(_QWORD *a1, int a2)
{
  uint64_t v4;
  void *v5;
  _QWORD *v6;

  if (a1)
  {
    v4 = a1[1];
    if (v4)
      sub_18BC5FDE4(v4);
    v5 = (void *)a1[2];
    if (v5)
      uprv_free(v5);
    v6 = (_QWORD *)a1[4];
    if (v6 && v6 != a1 + 5)
      uprv_free(v6);
    a1[4] = 0;
    *((_DWORD *)a1 + 26) = 0;
    if (*((_DWORD *)a1 + 29) == 19700503 && a2 && *((_DWORD *)a1 + 30) == 19641227)
      uprv_free(a1);
  }
}

char *sub_18BC5C254(char *a1, char *a2, int *a3)
{
  char *v3;
  _BOOL4 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  char *v14;
  uint64_t v15;

  v3 = a1;
  if (a2 && a1 != a2 && *a3 <= 0)
  {
    if (a1)
    {
      v6 = *((_DWORD *)a1 + 29) != 19700503 || *((_DWORD *)a1 + 30) != 19641227;
      sub_18BC5C1BC(a1, 0);
    }
    else
    {
      v3 = (char *)uprv_malloc(0x88uLL);
      if (!v3)
      {
        *a3 = 7;
        return v3;
      }
      v6 = 0;
    }
    v7 = *((_OWORD *)a2 + 3);
    v8 = *((_OWORD *)a2 + 4);
    v9 = *((_OWORD *)a2 + 1);
    *((_OWORD *)v3 + 2) = *((_OWORD *)a2 + 2);
    v10 = *((_OWORD *)a2 + 7);
    v11 = *((_QWORD *)a2 + 16);
    v12 = *((_OWORD *)a2 + 5);
    *((_OWORD *)v3 + 6) = *((_OWORD *)a2 + 6);
    v13 = *(_OWORD *)a2;
    *((_OWORD *)v3 + 3) = v7;
    *((_OWORD *)v3 + 4) = v8;
    *(_OWORD *)v3 = v13;
    *((_OWORD *)v3 + 1) = v9;
    *((_QWORD *)v3 + 16) = v11;
    *((_OWORD *)v3 + 7) = v10;
    *((_OWORD *)v3 + 5) = v12;
    *((_QWORD *)v3 + 4) = 0;
    *((_DWORD *)v3 + 26) = 0;
    v14 = (char *)*((_QWORD *)a2 + 4);
    if (v14)
      sub_18BC5C384((uint64_t)v3, v14, *((_DWORD *)a2 + 26), a3);
    *(int8x8_t *)(v3 + 116) = vand_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(!v6), 0x1FuLL)), (int8x8_t)0x12BB38B012C9B17);
    v15 = *((_QWORD *)v3 + 1);
    if (v15)
      sub_18BC5C44C(v15);
  }
  return v3;
}

char *sub_18BC5C384(uint64_t a1, char *__src, int a3, _DWORD *a4)
{
  int v7;
  char *result;
  int v9;
  int v10;

  v7 = *(_DWORD *)(a1 + 104);
  result = *(char **)(a1 + 32);
  if (result)
  {
    v9 = v7;
  }
  else
  {
    v9 = 0;
    *(_BYTE *)(a1 + 40) = 0;
    result = (char *)(a1 + 40);
    *(_QWORD *)(a1 + 32) = a1 + 40;
  }
  v10 = v9 + a3;
  *(_DWORD *)(a1 + 104) = v10;
  if (v10 < 63)
    return strcpy(&result[v7], __src);
  if (result == (char *)(a1 + 40))
  {
    result = (char *)uprv_malloc((v10 + 1));
    *(_QWORD *)(a1 + 32) = result;
    if (result)
    {
      result = strcpy(result, (const char *)(a1 + 40));
      return strcpy(&result[v7], __src);
    }
  }
  else
  {
    result = (char *)uprv_realloc(result, (v10 + 1));
    if (result)
    {
      *(_QWORD *)(a1 + 32) = result;
      return strcpy(&result[v7], __src);
    }
  }
  *a4 = 7;
  return result;
}

void sub_18BC5C44C(uint64_t a1)
{
  uint64_t i;

  umtx_lock((icu::UMutex *)&unk_1ECD27C88);
  ++*(_DWORD *)(a1 + 108);
  for (i = *(_QWORD *)(a1 + 16); i; i = *(_QWORD *)(i + 16))
    ++*(_DWORD *)(i + 108);
  umtx_unlock((std::mutex **)&unk_1ECD27C88);
}

const UChar *ures_getString(uint64_t a1, int *a2, int *a3)
{
  const UChar *result;
  int v5;

  if (!a3 || *a3 > 0)
    return 0;
  if (!a1)
  {
    v5 = 1;
    goto LABEL_9;
  }
  result = res_getStringNoTrace(*(_QWORD *)(a1 + 8) + 40, *(_DWORD *)(a1 + 108), a2);
  if (!result)
  {
    v5 = 17;
LABEL_9:
    result = 0;
    *a3 = v5;
  }
  return result;
}

char *ures_getUTF8String(uint64_t a1, char *a2, int32_t *a3, int a4, int *a5)
{
  UChar *String;
  int32_t srcLength;

  srcLength = 0;
  String = (UChar *)ures_getString(a1, &srcLength, a5);
  return sub_18BC5C56C(String, srcLength, a2, a3, a4, a5);
}

char *sub_18BC5C56C(UChar *src, int32_t srcLength, char *dest, int32_t *pDestLength, int a5, int *a6)
{
  char *v6;
  int v9;
  char *v10;
  int v11;
  int v12;
  char *v13;
  int v14;

  if (*a6 > 0)
    return 0;
  v6 = dest;
  if (!pDestLength)
  {
    v9 = 0;
    if (srcLength)
      goto LABEL_12;
    if (!a5)
      return "";
LABEL_10:
    u_terminateChars((uint64_t)dest, v9, 0, a6);
    return v6;
  }
  v9 = *pDestLength;
  if (*pDestLength < 0 || !dest && v9)
  {
    v6 = 0;
    *a6 = 1;
    return v6;
  }
  if (!srcLength)
  {
    *pDestLength = 0;
    if (!a5)
      return "";
    goto LABEL_10;
  }
LABEL_12:
  if (v9 >= srcLength)
  {
    if (srcLength <= 715827882)
    {
      v11 = 3 * srcLength;
      v12 = v9 - (3 * srcLength + 1);
      if (v9 <= 3 * srcLength + 1)
        v12 = 0;
      v13 = &dest[v12];
      if (v9 >= v11 + 1)
        v14 = v11 + 1;
      else
        v14 = v9;
      if (!a5)
      {
        v6 = v13;
        v9 = v14;
      }
    }
    v10 = v6;
  }
  else
  {
    v10 = 0;
    v9 = 0;
  }
  return u_strToUTF8(v10, v9, pDestLength, src, srcLength, (UErrorCode *)a6);
}

int *ures_getBinary(uint64_t a1, int *a2, int *a3)
{
  int *result;
  int v5;

  if (!a3 || *a3 > 0)
    return 0;
  if (!a1)
  {
    v5 = 1;
    goto LABEL_9;
  }
  result = res_getBinaryNoTrace(*(_QWORD *)(a1 + 8) + 40, *(_DWORD *)(a1 + 108), a2);
  if (!result)
  {
    v5 = 17;
LABEL_9:
    result = 0;
    *a3 = v5;
  }
  return result;
}

int *ures_getIntVector(uint64_t a1, int *a2, int *a3)
{
  int *result;
  int v5;

  if (!a3 || *a3 > 0)
    return 0;
  if (!a1)
  {
    v5 = 1;
    goto LABEL_9;
  }
  result = res_getIntVectorNoTrace(*(_QWORD *)(a1 + 8) + 40, *(_DWORD *)(a1 + 108), a2);
  if (!result)
  {
    v5 = 17;
LABEL_9:
    result = 0;
    *a3 = v5;
  }
  return result;
}

uint64_t ures_getInt(uint64_t a1, int *a2)
{
  unsigned int v2;
  int v4;

  if (a2 && *a2 <= 0)
  {
    if (a1)
    {
      v2 = *(_DWORD *)(a1 + 108);
      if (v2 >> 28 == 7)
        return ((int)(16 * v2) >> 4);
      v4 = 17;
    }
    else
    {
      v4 = 1;
    }
    *a2 = v4;
  }
  return 0xFFFFFFFFLL;
}

uint64_t ures_getUInt(uint64_t a1, int *a2)
{
  unsigned int v2;
  int v4;

  if (a2 && *a2 <= 0)
  {
    if (a1)
    {
      v2 = *(_DWORD *)(a1 + 108);
      if (v2 >> 28 == 7)
        return v2 & 0xFFFFFFF;
      v4 = 17;
    }
    else
    {
      v4 = 1;
    }
    *a2 = v4;
  }
  return 0xFFFFFFFFLL;
}

uint64_t ures_getType(uint64_t a1)
{
  if (a1)
    return res_getPublicType(*(_DWORD *)(a1 + 108));
  else
    return 0xFFFFFFFFLL;
}

uint64_t ures_getKey(uint64_t result)
{
  if (result)
    return *(_QWORD *)result;
  return result;
}

uint64_t ures_getSize(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 128);
  return result;
}

uint64_t ures_resetIterator(uint64_t result)
{
  if (result)
    *(_DWORD *)(result + 124) = -1;
  return result;
}

BOOL ures_hasNext(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)(result + 124) < *(_DWORD *)(result + 128) - 1;
  return result;
}

const UChar *ures_getNextString(uint64_t a1, int *a2, _QWORD *a3, int *a4)
{
  int v6;
  int v7;
  const UChar *result;
  unsigned int v11;
  unsigned int v12;
  unsigned int TableItemByIndex;

  if (!a4 || *a4 > 0)
    return 0;
  if (!a1)
  {
    v7 = 1;
    goto LABEL_7;
  }
  v6 = *(_DWORD *)(a1 + 124);
  if (v6 == *(_DWORD *)(a1 + 128) - 1)
  {
    v7 = 8;
LABEL_7:
    *a4 = v7;
    return 0;
  }
  v11 = v6 + 1;
  *(_DWORD *)(a1 + 124) = v6 + 1;
  v12 = *(_DWORD *)(a1 + 108);
  switch(v12 >> 28)
  {
    case 0u:
    case 6u:
      return res_getStringNoTrace(*(_QWORD *)(a1 + 8) + 40, v12, a2);
    case 1u:
    case 7u:
    case 0xEu:
      v7 = 17;
      goto LABEL_7;
    case 2u:
    case 4u:
    case 5u:
      TableItemByIndex = res_getTableItemByIndex(*(_QWORD *)(a1 + 8) + 40, v12, v11, a3);
      goto LABEL_14;
    case 3u:
      goto LABEL_15;
    case 8u:
    case 9u:
      TableItemByIndex = res_getArrayItem(*(_QWORD *)(a1 + 8) + 40, v12, v11);
LABEL_14:
      v12 = TableItemByIndex;
      v11 = *(_DWORD *)(a1 + 124);
LABEL_15:
      result = sub_18BC5C90C(a1, v12, v11, a2, a4);
      break;
    default:
      return 0;
  }
  return result;
}

const UChar *sub_18BC5C90C(uint64_t a1, unsigned int a2, signed int a3, int *a4, int *a5)
{
  char *v7;
  const UChar *String;

  if (a2 >> 28 != 3)
    return res_getStringNoTrace(*(_QWORD *)(a1 + 8) + 40, a2, a4);
  v7 = ures_getByIndex(a1, a3, 0, a5);
  String = ures_getString((uint64_t)v7, a4, a5);
  sub_18BC5C1BC(v7, 1);
  return String;
}

char *ures_getNextResource(uint64_t a1, char *a2, int *a3)
{
  int v6;
  int v7;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int TableItemByIndex;
  unsigned int ArrayItem;
  const char *v14;

  v14 = 0;
  if (!a3 || *a3 > 0)
    return a2;
  if (!a1)
  {
    v7 = 1;
    goto LABEL_7;
  }
  v6 = *(_DWORD *)(a1 + 124);
  if (v6 == *(_DWORD *)(a1 + 128) - 1)
  {
    v7 = 8;
LABEL_7:
    *a3 = v7;
    return a2;
  }
  v9 = v6 + 1;
  *(_DWORD *)(a1 + 124) = v6 + 1;
  v10 = *(_DWORD *)(a1 + 108);
  v11 = v10 >> 28;
  if (v10 >> 28 != 15)
  {
    if (((1 << v11) & 0x40C3) != 0)
      return sub_18BC5C254(a2, (char *)a1, a3);
    if (((1 << v11) & 0x34) != 0)
    {
      TableItemByIndex = res_getTableItemByIndex(*(_QWORD *)(a1 + 8) + 40, v10, v9, &v14);
      return (char *)sub_18BC5FE30(*(_QWORD *)(a1 + 8), TableItemByIndex, v14, *(_DWORD *)(a1 + 124), *(_QWORD *)(a1 + 24), *(char **)(a1 + 32), 0, (uint64_t)a2, (UErrorCode *)a3);
    }
    else if (((1 << v11) & 0x300) != 0)
    {
      ArrayItem = res_getArrayItem(*(_QWORD *)(a1 + 8) + 40, v10, v9);
      return (char *)sub_18BC5FE30(*(_QWORD *)(a1 + 8), ArrayItem, 0, *(_DWORD *)(a1 + 124), *(_QWORD *)(a1 + 24), *(char **)(a1 + 32), 0, (uint64_t)a2, (UErrorCode *)a3);
    }
  }
  return a2;
}

char *ures_getByIndex(uint64_t a1, signed int a2, char *a3, int *a4)
{
  char *v4;
  unsigned int v8;
  unsigned int v9;
  unsigned int TableItemByIndex;
  int v11;
  unsigned int ArrayItem;
  const char *v14;

  v4 = a3;
  v14 = 0;
  if (!a4 || *a4 > 0)
    return v4;
  if (!a1)
  {
    v11 = 1;
    goto LABEL_12;
  }
  if (a2 < 0 || *(_DWORD *)(a1 + 128) <= a2)
  {
    v11 = 2;
LABEL_12:
    *a4 = v11;
    return v4;
  }
  v8 = *(_DWORD *)(a1 + 108);
  v9 = v8 >> 28;
  if (v8 >> 28 != 15)
  {
    if (((1 << v9) & 0x40C3) != 0)
      return sub_18BC5C254(a3, (char *)a1, a4);
    if (((1 << v9) & 0x34) != 0)
    {
      TableItemByIndex = res_getTableItemByIndex(*(_QWORD *)(a1 + 8) + 40, v8, a2, &v14);
      return (char *)sub_18BC5FE30(*(_QWORD *)(a1 + 8), TableItemByIndex, v14, a2, *(_QWORD *)(a1 + 24), *(char **)(a1 + 32), 0, (uint64_t)v4, (UErrorCode *)a4);
    }
    else if (((1 << v9) & 0x300) != 0)
    {
      ArrayItem = res_getArrayItem(*(_QWORD *)(a1 + 8) + 40, v8, a2);
      return (char *)sub_18BC5FE30(*(_QWORD *)(a1 + 8), ArrayItem, 0, a2, *(_QWORD *)(a1 + 24), *(char **)(a1 + 32), 0, (uint64_t)v4, (UErrorCode *)a4);
    }
  }
  return v4;
}

const UChar *ures_getStringByIndex(uint64_t a1, signed int a2, int *a3, int *a4)
{
  const UChar *result;
  unsigned int ArrayItem;
  int v10;
  unsigned int TableItemByIndex;
  uint64_t v12;

  v12 = 0;
  if (!a4 || *a4 > 0)
    return 0;
  if (!a1)
  {
    result = 0;
    v10 = 1;
    goto LABEL_11;
  }
  if (a2 < 0 || *(_DWORD *)(a1 + 128) <= a2)
  {
    result = 0;
    v10 = 2;
LABEL_11:
    *a4 = v10;
    return result;
  }
  ArrayItem = *(_DWORD *)(a1 + 108);
  switch(ArrayItem >> 28)
  {
    case 0u:
    case 6u:
      return res_getStringNoTrace(*(_QWORD *)(a1 + 8) + 40, ArrayItem, a3);
    case 1u:
    case 7u:
    case 0xEu:
      result = 0;
      v10 = 17;
      goto LABEL_11;
    case 2u:
    case 4u:
    case 5u:
      TableItemByIndex = res_getTableItemByIndex(*(_QWORD *)(a1 + 8) + 40, ArrayItem, a2, &v12);
      return sub_18BC5C90C(a1, TableItemByIndex, a2, a3, a4);
    case 3u:
      goto LABEL_16;
    case 8u:
    case 9u:
      ArrayItem = res_getArrayItem(*(_QWORD *)(a1 + 8) + 40, ArrayItem, a2);
LABEL_16:
      result = sub_18BC5C90C(a1, ArrayItem, a2, a3, a4);
      break;
    default:
      result = 0;
      v10 = 5;
      goto LABEL_11;
  }
  return result;
}

char *ures_getUTF8StringByIndex(uint64_t a1, signed int a2, char *a3, int32_t *a4, int a5, int *a6)
{
  UChar *StringByIndex;
  int32_t srcLength;

  srcLength = 0;
  StringByIndex = (UChar *)ures_getStringByIndex(a1, a2, &srcLength, a6);
  return sub_18BC5C56C(StringByIndex, srcLength, a3, a4, a5, a6);
}

char *ures_findResource(const char *a1, char *a2, int *a3)
{
  size_t v6;
  _BYTE *v7;
  _BYTE *v8;
  const char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t SubResource;
  char *v17;

  if (a3 && *a3 <= 0)
  {
    v6 = (int)(strlen(a1) + 1);
    v7 = uprv_malloc(v6);
    if (v7)
    {
      v8 = v7;
      memcpy(v7, a1, v6);
      if (*v8 == 47)
      {
        v9 = v8 + 1;
        v10 = strchr(v8 + 1, 47);
        if (v10)
        {
          *v10 = 0;
          v11 = v10 + 1;
          goto LABEL_11;
        }
        *a3 = 1;
      }
      else
      {
        v9 = 0;
      }
      v11 = v8;
LABEL_11:
      v12 = strchr(v11, 47);
      if (v12)
      {
        v13 = v12;
        *v12 = 0;
        v14 = (char *)sub_18BC5E03C(0, v9, v11, 0, a3);
        if (*a3 <= 0)
        {
          v15 = v14;
          SubResource = ures_findSubResource((uint64_t)v14, v13 + 1, (uint64_t)a2, (UErrorCode *)a3);
LABEL_16:
          a2 = (char *)SubResource;
          sub_18BC5C1BC(v15, 1);
        }
      }
      else
      {
        v17 = (char *)sub_18BC5E03C(0, v9, v11, 0, a3);
        if (*a3 <= 0)
        {
          v15 = v17;
          SubResource = (uint64_t)sub_18BC5C254(a2, v17, a3);
          goto LABEL_16;
        }
      }
      uprv_free(v8);
      return a2;
    }
    *a3 = 7;
  }
  return a2;
}

_QWORD *ures_open(const char *a1, char *a2, int *a3)
{
  return sub_18BC5E03C(0, a1, a2, 0, a3);
}

uint64_t ures_findSubResource(uint64_t a1, char *a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  const char *v11;
  char *v12;

  v12 = a2;
  if (a4 && *(int *)a4 <= 0)
  {
    v6 = a1;
    v11 = 0;
    v7 = sub_18BC63030(*(_QWORD *)(a1 + 8) + 40, *(unsigned int *)(a1 + 108), &v12, &v11);
    if (v7 == -1)
    {
      v6 = a3;
LABEL_9:
      *a4 = U_MISSING_RESOURCE_ERROR;
    }
    else
    {
      v8 = v7;
      while (1)
      {
        v9 = sub_18BC5FE30(*(_QWORD *)(v6 + 8), v8, v11, 0xFFFFFFFF, *(_QWORD *)(v6 + 24), *(char **)(v6 + 32), 0, a3, a4);
        v6 = v9;
        if (!*v12)
          break;
        v8 = sub_18BC63030(*(_QWORD *)(v9 + 8) + 40, *(unsigned int *)(v9 + 108), &v12, &v11);
        if (v8 == -1)
          goto LABEL_9;
      }
    }
    return v6;
  }
  return a3;
}

const UChar *ures_getStringByKeyWithFallback(uint64_t a1, char *a2, int *a3, UErrorCode *a4)
{
  const UChar *StringNoTrace;
  int v7;
  int v9;
  _OWORD v10[6];
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v11 = 0u;
  v12 = 0u;
  memset(v10, 0, sizeof(v10));
  ures_getByKeyWithFallback(a1, a2, (uint64_t)v10, a4);
  v9 = 0;
  if (a4 && *(int *)a4 <= 0)
  {
    StringNoTrace = res_getStringNoTrace(*((_QWORD *)&v10[0] + 1) + 40, HIDWORD(v11), &v9);
    if (!StringNoTrace)
      *a4 = U_RESOURCE_TYPE_MISMATCH;
  }
  else
  {
    StringNoTrace = 0;
  }
  sub_18BC5C1BC(v10, 1);
  if (*(int *)a4 > 0)
    return 0;
  v7 = v9;
  if (v9 == 3)
  {
    if (*StringNoTrace == 8709 && StringNoTrace[1] == 8709 && StringNoTrace[2] == 8709)
    {
      v7 = 0;
      StringNoTrace = 0;
      *a4 = U_MISSING_RESOURCE_ERROR;
    }
    else
    {
      v7 = 3;
    }
  }
  if (a3)
    *a3 = v7;
  return StringNoTrace;
}

uint64_t ures_getByKeyWithFallback(uint64_t a1, char *a2, uint64_t a3, UErrorCode *a4)
{
  unsigned int v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  unsigned int TableItemByKey;
  BOOL v19;
  int v20;
  uint64_t v21;
  _BOOL4 v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  const char *v26;
  const char *Default;
  int v28;
  uint64_t v29;
  unsigned __int8 *v30;
  int v31;
  int v32;
  char *v33;
  const char *v34;
  char *v35;
  void *v36;
  char v37;
  unsigned __int8 *v39;
  int v40;
  int v41;
  char *v42;
  char *v43;
  unsigned int v44;
  char *v45;
  int v46;
  UErrorCode v47;
  char *__s;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (!a4 || *(int *)a4 > 0)
    return a3;
  if (!a1)
  {
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    return a3;
  }
  v7 = *(_DWORD *)(a1 + 108);
  if (v7 >> 28 != 2 && (v7 & 0xE0000000) != 0x40000000)
  {
    v13 = 0;
    *a4 = U_RESOURCE_TYPE_MISMATCH;
LABEL_68:
    sub_18BC5C1BC(v13, 1);
    return a3;
  }
  v39 = *(unsigned __int8 **)(a1 + 32);
  v40 = *(_DWORD *)(a1 + 104);
  v10 = *(_QWORD *)(a1 + 8);
  v49 = 0u;
  v50 = 0u;
  v52 = 0;
  v51 = 0u;
  __s = (char *)&v49 + 5;
  LODWORD(v49) = 40;
  v47 = U_ZERO_ERROR;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v45, a2);
  icu::CharString::append((icu::CharString *)&__s, v45, v46, &v47);
  if (v47 <= U_ZERO_ERROR)
  {
    v14 = __s;
    if (!*__s)
      goto LABEL_11;
    v15 = v10 + 40;
    while (v7 >> 28 == 2 || (v7 & 0xE0000000) == 0x40000000 || (v7 & 0xE0000000) == 0x80000000)
    {
      v16 = strchr(v14, 47);
      if (v16)
      {
        *v16 = 0;
        v17 = v16 + 1;
      }
      else
      {
        v17 = &v14[strlen(v14)];
      }
      v44 = 0;
      v43 = v14;
      TableItemByKey = res_getTableItemByKey(v15, v7, &v44, (const char **)&v43);
      v7 = TableItemByKey;
      if (*v17)
        v19 = TableItemByKey == -1;
      else
        v19 = 1;
      v14 = v17;
      if (v19)
      {
        if (*v17)
          break;
        goto LABEL_11;
      }
    }
  }
  v7 = -1;
LABEL_11:
  if (BYTE4(v49))
    uprv_free(__s);
  v45 = a2;
  v11 = *(_QWORD *)(a1 + 8);
  if (v7 != -1)
  {
    v12 = sub_18BC5FE30(v11, v7, a2, 0xFFFFFFFF, *(_QWORD *)(a1 + 24), *(char **)(a1 + 32), 0, a3, a4);
    v13 = 0;
LABEL_67:
    a3 = v12;
    goto LABEL_68;
  }
  v13 = 0;
  v20 = 0;
  v49 = 0u;
  v50 = 0u;
  v52 = 0;
  v51 = 0u;
  __s = (char *)&v49 + 5;
  LODWORD(v49) = 40;
  v42 = *(char **)(a1 + 32);
  v43 = 0;
  v41 = *(_DWORD *)(a1 + 104);
  v21 = *(_QWORD *)(v11 + 16);
  v22 = v21 == 0;
  while (1)
  {
    if (!v22)
      v11 = v21;
    if (!*(_DWORD *)(v11 + 112))
      break;
LABEL_35:
    v20 |= v22;
    v21 = *(_QWORD *)(v11 + 16);
    v22 = v21 == 0;
    if ((v22 & v20) != 0)
    {
      *a4 = U_MISSING_RESOURCE_ERROR;
      v37 = 1;
LABEL_63:
      v12 = a3;
      goto LABEL_64;
    }
  }
  v23 = *(unsigned int *)(v11 + 72);
  sub_18BC5D65C(v39, v40, v42, v41, a2, (icu::CharString *)&__s, a4);
  if (*(int *)a4 >= 1)
  {
    sub_18BC5C1BC(v13, 1);
    v37 = 0;
    goto LABEL_63;
  }
  v43 = __s;
  v45 = a2;
  do
  {
    v24 = sub_18BC63030(v11 + 40, v23, &v43, (const char **)&v45);
    v25 = v24;
    if (v24 >> 28 == 3)
    {
      if (*v43)
      {
        v24 = sub_18BC5FE30(v11, v24, 0, 0xFFFFFFFF, *(_QWORD *)(a1 + 24), *(char **)(a1 + 32), 0, (uint64_t)v13, a4);
        v13 = (_QWORD *)v24;
        if (!v24)
          break;
        v11 = *(_QWORD *)(v24 + 8);
        v42 = *(char **)(v24 + 32);
        v23 = *(unsigned int *)(v24 + 108);
        v41 = *(_DWORD *)(v24 + 104);
      }
    }
    else if ((_DWORD)v24 == -1)
    {
      goto LABEL_35;
    }
  }
  while (*v43);
  v26 = *(const char **)v11;
  Default = (const char *)uloc_getDefault(v24);
  if (!strcmp(v26, Default))
  {
    v28 = -127;
  }
  else if (!strcmp(*(const char **)v11, "root"))
  {
    v28 = -127;
  }
  else
  {
    v28 = -128;
  }
  *a4 = v28;
  v29 = sub_18BC5FE30(v11, v25, v45, 0xFFFFFFFF, *(_QWORD *)(a1 + 24), *(char **)(a1 + 32), 0, a3, a4);
  v12 = v29;
  if (v42)
  {
    v30 = v39;
    v31 = v40;
    v32 = v41;
    v33 = v42;
  }
  else
  {
    v34 = *(const char **)(v29 + 32);
    if (v34 && (v35 = strchr(*(char **)(v29 + 32), 47)) != 0 && v35[1])
    {
      v32 = strlen(v34);
      v30 = v39;
      v31 = v40;
      v33 = (char *)v34;
    }
    else
    {
      v33 = "";
      v30 = v39;
      v31 = v40;
      v32 = 0;
    }
  }
  sub_18BC5D65C(v30, v31, v33, v32, a2, (icu::CharString *)&__s, a4);
  v36 = *(void **)(v12 + 32);
  if (v36 && v36 != (void *)(v12 + 40))
    uprv_free(v36);
  *(_QWORD *)(v12 + 32) = 0;
  *(_DWORD *)(v12 + 104) = 0;
  sub_18BC5C384(v12, __s, v52, a4);
  v37 = 1;
  if (*(_BYTE *)(*(int *)(v12 + 104) + *(_QWORD *)(v12 + 32) - 1) != 47)
    sub_18BC5C384(v12, "/", 1, a4);
LABEL_64:
  if (BYTE4(v49))
    uprv_free(__s);
  if ((v37 & 1) != 0)
    goto LABEL_67;
  return a3;
}

icu::CharString *sub_18BC5D65C(unsigned __int8 *a1, int a2, char *a3, int a4, const char *a5, icu::CharString *this, UErrorCode *a7)
{
  char *v14;
  char *v15;
  unsigned __int8 *v16;
  int v17;
  char *v19;
  int v20;
  char *v21;
  const char *v22;
  int v23;
  _BYTE *v24;
  icu::StringPiece *v25;
  _BYTE v27[16];
  _BYTE v28[16];

  *((_DWORD *)this + 14) = 0;
  **(_BYTE **)this = 0;
  if (a4 < 1)
  {
    v24 = v27;
    v25 = (icu::StringPiece *)v27;
  }
  else
  {
    icu::CharString::append(this, a3, a4, a7);
    if (*(int *)a7 <= 0)
    {
      v14 = a3;
      v15 = &a3[a4];
      if (a2 >= 1)
      {
        v16 = &a1[a2];
        v14 = a3;
        do
        {
          do
            v17 = *a1++;
          while (v17 != 47 && a1 < v16);
          if (v14 < v15)
          {
            v19 = (char *)(&a3[a4] - v14++);
            while (*(v14 - 1) != 47)
            {
              ++v14;
              if (!--v19)
              {
                v14 = &a3[a4];
                break;
              }
            }
          }
        }
        while (a1 < v16 && v14 < v15);
      }
      if (v14 < v15)
      {
        while (1)
        {
          v20 = *(unsigned __int8 *)a5;
          if (!*a5)
            break;
          if (v14 < v15)
          {
            v21 = (char *)(&a3[a4] - v14++);
            while (*(v14 - 1) != 47)
            {
              ++v14;
              if (!--v21)
              {
                v14 = &a3[a4];
                break;
              }
            }
          }
          v22 = a5;
          if (*a5)
          {
            do
            {
              if (v20 == 47)
                break;
              v23 = *(unsigned __int8 *)++v22;
              v20 = v23;
            }
            while (v23);
          }
          if (v20 == 47)
            a5 = v22 + 1;
          else
            a5 = v22;
          if (v14 >= v15)
          {
            if (v20 == 47)
              a5 = v22 + 1;
            else
              a5 = v22;
            break;
          }
        }
      }
    }
    v24 = v28;
    v25 = (icu::StringPiece *)v28;
  }
  icu::StringPiece::StringPiece(v25, a5);
  return icu::CharString::append(this, *(const char **)v24, *((_DWORD *)v24 + 2), a7);
}

void ures_getAllChildrenWithFallback(uint64_t a1, char *a2, uint64_t a3, int *a4)
{
  _QWORD v4[2];

  v4[0] = &off_1E2257550;
  v4[1] = a3;
  ures_getAllItemsWithFallback(a1, a2, (uint64_t)v4, a4);
  icu::ResourceSink::~ResourceSink((icu::ResourceSink *)v4);
}

void ures_getAllItemsWithFallback(uint64_t a1, char *a2, uint64_t a3, int *a4)
{
  _QWORD v6[4];
  _OWORD v7[8];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*a4 <= 0)
  {
    if (a2)
    {
      v8 = 0;
      memset(v7, 0, sizeof(v7));
      if (!*a2 || (a1 = ures_getByKeyWithFallback(a1, a2, (uint64_t)v7, (UErrorCode *)a4), *a4 <= 0))
      {
        v6[2] = 0;
        v6[0] = &unk_1E2257598;
        v6[1] = 0;
        v6[3] = 0xFFFFFFFFLL;
        sub_18BC5D984(a1, (uint64_t)v6, a3, a4);
        icu::ResourceValue::~ResourceValue((icu::ResourceValue *)v6);
      }
      sub_18BC5C1BC(v7, 1);
    }
    else
    {
      *a4 = 1;
    }
  }
}

uint64_t ures_getValueWithFallback(uint64_t result, char *a2, uint64_t a3, uint64_t a4, UErrorCode *a5)
{
  uint64_t v7;

  if (*(int *)a5 <= 0)
  {
    if (a2)
    {
      if (!*a2 || (result = ures_getByKeyWithFallback(result, a2, a3, a5), *(int *)a5 <= 0))
      {
        v7 = *(_QWORD *)(result + 24);
        *(_QWORD *)(a4 + 8) = *(_QWORD *)(result + 8) + 40;
        *(_QWORD *)(a4 + 16) = v7;
        *(_DWORD *)(a4 + 24) = *(_DWORD *)(result + 108);
      }
    }
    else
    {
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }
  return result;
}

void sub_18BC5D984(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  _BOOL8 v11;
  char *v12;
  _QWORD *v13;
  int v14;
  _OWORD v15[8];
  uint64_t v16;
  _QWORD v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (*a4 <= 0)
  {
    v8 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 8) = v8 + 40;
    *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 24);
    v9 = *(_QWORD *)(v8 + 16);
    v10 = v9 && *(_DWORD *)(v9 + 112) < 1;
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 108);
    v11 = !v10;
    (*(void (**)(uint64_t, _QWORD, uint64_t, _BOOL8, int *))(*(_QWORD *)a3 + 24))(a3, *(_QWORD *)a1, a2, v11, a4);
    if (!v11)
    {
      v17[0] = 0;
      v18 = 0u;
      v25 = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v17[1] = v9;
      *((_QWORD *)&v18 + 1) = *(_QWORD *)(a1 + 24);
      LOBYTE(v24) = *(_BYTE *)(v9 + 96) == 0;
      BYTE1(v24) = 1;
      HIDWORD(v23) = *(_DWORD *)(v9 + 72);
      v25 = res_countArrayItems(v9 + 40, HIDWORD(v23));
      HIDWORD(v24) = -1;
      sub_18BC5C44C(v9);
      v16 = 0;
      memset(v15, 0, sizeof(v15));
      v14 = 0;
      v12 = *(char **)(a1 + 32);
      if (v12 && *v12)
      {
        v13 = (_QWORD *)ures_getByKeyWithFallback((uint64_t)v17, v12, (uint64_t)v15, (UErrorCode *)&v14);
        if (v14 > 0)
        {
LABEL_12:
          sub_18BC5C1BC(v15, 1);
          sub_18BC5C1BC(v17, 1);
          return;
        }
      }
      else
      {
        v13 = v17;
      }
      sub_18BC5D984(v13, a2, a3, a4);
      goto LABEL_12;
    }
  }
}

uint64_t ures_getByKey(uint64_t a1, const char *a2, uint64_t a3, int *a4)
{
  unsigned int v8;
  unsigned int TableItemByKey;
  unsigned int v11;
  uint64_t v12;
  int v13;
  unsigned int v15;
  const char *v16;
  unsigned int v17;

  v16 = a2;
  if (a4 && *a4 <= 0)
  {
    if (!a1)
    {
      v13 = 1;
      goto LABEL_16;
    }
    v8 = *(_DWORD *)(a1 + 108);
    if (v8 >> 28 != 2 && (v8 & 0xE0000000) != 0x40000000)
    {
      v13 = 17;
LABEL_16:
      *a4 = v13;
      return a3;
    }
    v15 = 0;
    TableItemByKey = res_getTableItemByKey(*(_QWORD *)(a1 + 8) + 40, v8, &v15, &v16);
    v17 = TableItemByKey;
    if (TableItemByKey == -1)
    {
      v16 = a2;
      if (!*(_BYTE *)(a1 + 112) || (v12 = sub_18BC5DC4C(a1, &v16, &v17, a4), *a4 > 0))
      {
        v13 = 2;
        goto LABEL_16;
      }
      v11 = v17;
    }
    else
    {
      v11 = TableItemByKey;
      v12 = *(_QWORD *)(a1 + 8);
    }
    return sub_18BC5FE30(v12, v11, v16, 0xFFFFFFFF, *(_QWORD *)(a1 + 24), *(char **)(a1 + 32), 0, a3, (UErrorCode *)a4);
  }
  return a3;
}

uint64_t sub_18BC5DC4C(uint64_t a1, const char **a2, _DWORD *a3, int *a4)
{
  uint64_t v5;
  int v9;
  uint64_t TableItemByKey;
  uint64_t v11;
  int v12;
  const char *v13;
  const char *Default;
  int v15;
  unsigned int v17;

  v5 = *(_QWORD *)(a1 + 8);
  v17 = -1;
  *a3 = -1;
  if (!v5)
    goto LABEL_23;
  if (*(_DWORD *)(v5 + 112))
  {
    if (!*(_BYTE *)(a1 + 112))
    {
LABEL_22:
      v5 = 0;
LABEL_23:
      v15 = 2;
LABEL_24:
      *a4 = v15;
      return v5;
    }
    v9 = 0;
  }
  else
  {
    TableItemByKey = res_getTableItemByKey(v5 + 40, *(_DWORD *)(v5 + 72), &v17, a2);
    *a3 = TableItemByKey;
    if (!*(_BYTE *)(a1 + 112))
    {
      v9 = 1;
      goto LABEL_16;
    }
    if ((_DWORD)TableItemByKey != -1)
      return v5;
    v9 = 1;
  }
  TableItemByKey = 0xFFFFFFFFLL;
  while (1)
  {
    v11 = *(_QWORD *)(v5 + 16);
    if (!v11)
      break;
    v5 = *(_QWORD *)(v5 + 16);
    if (*(_DWORD *)(v11 + 112))
    {
      v12 = -1;
    }
    else
    {
      ++v9;
      TableItemByKey = res_getTableItemByKey(v11 + 40, *(_DWORD *)(v11 + 72), &v17, a2);
      *a3 = TableItemByKey;
      v12 = TableItemByKey;
    }
    if (v12 != -1)
      goto LABEL_17;
  }
LABEL_16:
  if ((_DWORD)TableItemByKey == -1)
    goto LABEL_22;
LABEL_17:
  if (v9 >= 2)
  {
    v13 = *(const char **)v5;
    Default = (const char *)uloc_getDefault(TableItemByKey);
    if (!strcmp(v13, Default))
    {
      v15 = -127;
    }
    else if (!strcmp(*(const char **)v5, "root"))
    {
      v15 = -127;
    }
    else
    {
      v15 = -128;
    }
    goto LABEL_24;
  }
  return v5;
}

const UChar *ures_getStringByKey(uint64_t a1, const char *a2, int *a3, int *a4)
{
  const UChar *String;
  unsigned int v8;
  unsigned int TableItemByKey;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  _QWORD *v18;
  unsigned int v20;
  const char *v21;
  unsigned int v22;

  v21 = a2;
  if (a4 && *a4 <= 0)
  {
    if (!a1)
    {
      String = 0;
      v15 = 1;
      goto LABEL_27;
    }
    v8 = *(_DWORD *)(a1 + 108);
    if (v8 >> 28 != 2 && (v8 & 0xE0000000) != 0x40000000)
    {
      String = 0;
      v15 = 17;
LABEL_27:
      *a4 = v15;
      return String;
    }
    v20 = 0;
    TableItemByKey = res_getTableItemByKey(*(_QWORD *)(a1 + 8) + 40, v8, &v20, &v21);
    v22 = TableItemByKey;
    if (TableItemByKey != -1)
    {
      v12 = TableItemByKey;
      v13 = TableItemByKey >> 28;
      if (TableItemByKey >> 28 == 6)
      {
LABEL_14:
        v14 = *(_QWORD *)(a1 + 8) + 40;
        return res_getStringNoTrace(v14, v12, a3);
      }
      if (v13 != 3)
      {
        if (!v13)
          goto LABEL_14;
        goto LABEL_25;
      }
LABEL_24:
      v18 = (_QWORD *)ures_getByKey(a1, a2, 0, a4);
      String = ures_getString((uint64_t)v18, a3, a4);
      sub_18BC5C1BC(v18, 1);
      return String;
    }
    v21 = a2;
    if (!*(_BYTE *)(a1 + 112) || (v16 = sub_18BC5DC4C(a1, &v21, &v22, a4), *a4 > 0))
    {
      v15 = 2;
LABEL_26:
      String = 0;
      goto LABEL_27;
    }
    v12 = v22;
    v17 = v22 >> 28;
    if (v22 >> 28 != 6)
    {
      if (v17 == 3)
        goto LABEL_24;
      if (v17)
      {
LABEL_25:
        v15 = 17;
        goto LABEL_26;
      }
    }
    v14 = v16 + 40;
    return res_getStringNoTrace(v14, v12, a3);
  }
  return 0;
}

char *ures_getUTF8StringByKey(uint64_t a1, const char *a2, char *a3, int32_t *a4, int a5, int *a6)
{
  UChar *StringByKey;
  int32_t srcLength;

  srcLength = 0;
  StringByKey = (UChar *)ures_getStringByKey(a1, a2, &srcLength, a6);
  return sub_18BC5C56C(StringByKey, srcLength, a3, a4, a5, a6);
}

uint64_t ures_getLocaleInternal(uint64_t result, int *a2)
{
  if (!a2 || *a2 > 0)
    return 0;
  if (result)
    return **(_QWORD **)(result + 8);
  *a2 = 1;
  return result;
}

uint64_t ures_getLocale(uint64_t result, int *a2)
{
  if (!a2 || *a2 > 0)
    return 0;
  if (result)
    return **(_QWORD **)(result + 8);
  *a2 = 1;
  return result;
}

uint64_t ures_getLocaleByType(uint64_t result, int a2, int *a3)
{
  uint64_t v3;

  if (!a3 || *a3 > 0)
    return 0;
  if (result)
  {
    if (a2 == 1)
    {
      v3 = *(_QWORD *)(result + 24);
      return *(_QWORD *)v3;
    }
    if (!a2)
    {
      v3 = *(_QWORD *)(result + 8);
      return *(_QWORD *)v3;
    }
    result = 0;
  }
  *a3 = 1;
  return result;
}

uint64_t sub_18BC5E02C(uint64_t result)
{
  if (result)
    return **(_QWORD **)(result + 8);
  return result;
}

_QWORD *sub_18BC5E03C(_QWORD *a1, const char *a2, char *a3, int a4, int *a5)
{
  _QWORD *v5;
  uint64_t v11;
  const char *Default;
  int v13;
  uint64_t v14;
  const char *v15;
  char *v16;
  const char *v17;
  const char **v18;
  int v19;
  _DWORD *v20;
  int v21;
  int32x2_t v22;
  int v23;
  int v24;
  int v25;
  _QWORD *v26;
  BOOL v27;
  unsigned int v28;
  int v29;
  int v30;
  _QWORD *v31;
  size_t v32;
  char *v33;
  const char **v34;
  int v35;
  const char **v36;
  const char **v37;
  const char **v38;
  const char **i;
  char v40;
  __int16 v41;
  const char **v42;
  int v43;
  void *v44[8];
  char __dst[16];
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  _BYTE v53[29];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (*a5 > 0)
    return 0;
  v5 = a1;
  if (a4 == 2)
  {
    sub_18BC60AB4(a5);
    if (*a5 > 0)
      return 0;
    if (a3)
    {
      if (*a3)
        Default = a3;
      else
        Default = "root";
    }
    else
    {
      Default = (const char *)uloc_getDefault(v11);
    }
    umtx_lock((icu::UMutex *)&unk_1ECD27C88);
    v20 = sub_18BC611C4(Default, a2, (UErrorCode *)a5);
    if (*a5 > 0)
      goto LABEL_25;
    v14 = (uint64_t)v20;
    if (v20[28])
    {
      --v20[27];
LABEL_25:
      v14 = 0;
LABEL_26:
      umtx_unlock((std::mutex **)&unk_1ECD27C88);
      goto LABEL_27;
    }
    v44[0] = v20;
    v30 = strcmp(Default, "root");
    v31 = (_QWORD *)v14;
    if (!v30
      || (v31 = (_QWORD *)v14, *(_QWORD *)(v14 + 16))
      || (v31 = (_QWORD *)v14, *(_BYTE *)(v14 + 96))
      || (v32 = strlen(Default), v31 = (_QWORD *)v14, v32 > 0x9C))
    {
LABEL_65:
      while (1)
      {
        v31 = (_QWORD *)v31[2];
        if (!v31)
          break;
        ++*((_DWORD *)v31 + 27);
      }
      goto LABEL_26;
    }
    v52 = 0u;
    memset(v53, 0, sizeof(v53));
    v50 = 0u;
    v51 = 0u;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    *(_OWORD *)__dst = 0u;
    strcpy(__dst, Default);
    v33 = strrchr(__dst, 95);
    v34 = (const char **)v14;
    if (v33)
    {
      *v33 = 0;
      v34 = (const char **)v14;
      if (*(_DWORD *)__dst ^ 0x746F6F72 | __dst[4])
      {
        if (!sub_18BC614C4((uint64_t *)v44, __dst, a5))
        {
LABEL_62:
          if (*a5 > 0)
            goto LABEL_25;
          v31 = v44[0];
          goto LABEL_65;
        }
        v34 = (const char **)v44[0];
      }
    }
    if (strcmp(*v34, "root") && !v34[2])
      sub_18BC6164C((uint64_t)v44, a5);
    goto LABEL_62;
  }
  memset(&v44[1], 0, 56);
  memset(__dst, 0, sizeof(__dst));
  v44[0] = (char *)&v44[1] + 5;
  LODWORD(v44[1]) = 40;
  icu::CharStringByteSink::CharStringByteSink(__dst, (uint64_t)v44);
  ulocimp_getBaseName(a3, (uint64_t)__dst, (UErrorCode *)a5);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)__dst);
  v13 = *a5;
  if (*a5 >= 1)
  {
    v14 = 0;
    *a5 = 1;
    goto LABEL_17;
  }
  v15 = (const char *)v44[0];
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v40 = 1;
  sub_18BC60AB4(a5);
  v14 = 0;
  if (*a5 <= 0)
  {
    v16 = strncpy(__dst, v15, 0x9CuLL);
    v53[28] = 0;
    v17 = (const char *)uloc_getDefault(v16);
    umtx_lock((icu::UMutex *)&unk_1ECD27C88);
    v18 = sub_18BC60B64(a2, __dst, v17, a4, (BOOL *)&v41, &v40, (BOOL *)&v41 + 1, (UErrorCode *)&v43);
    v19 = v43;
    if (v43 == 7)
    {
LABEL_14:
      v14 = 0;
      goto LABEL_15;
    }
    v14 = (uint64_t)v18;
    if (v18)
    {
      v42 = v18;
      if (v40)
      {
        v25 = v41;
        if (!(_BYTE)v41)
        {
LABEL_72:
          if (!sub_18BC614C4((uint64_t *)&v42, __dst, a5))
            goto LABEL_86;
          v25 = 0;
        }
LABEL_74:
        v35 = 1;
        goto LABEL_75;
      }
      v25 = v41;
      if (!__dst[0])
        goto LABEL_74;
      v35 = 1;
      if (strstr("nb nn", __dst) && !v25)
        goto LABEL_72;
    }
    else
    {
      v35 = 0;
      v25 = v41;
    }
LABEL_75:
    if (a4 || v14 || HIBYTE(v41) || v25)
    {
      if (v14)
        goto LABEL_85;
    }
    else
    {
      strcpy(__dst, v17);
      v36 = sub_18BC60B64(a2, __dst, v17, 0, (BOOL *)&v41, &v40, (BOOL *)&v41 + 1, (UErrorCode *)&v43);
      v19 = v43;
      if (v43 == 7)
        goto LABEL_14;
      v14 = (uint64_t)v36;
      v43 = -127;
      if (v36)
      {
        v42 = v36;
        if (v40)
        {
          if ((_BYTE)v41)
            goto LABEL_86;
          goto LABEL_97;
        }
        v25 = v41;
        if (__dst[0])
        {
          v35 = 1;
          if (strstr("nb nn", __dst) && !v25)
          {
LABEL_97:
            if (!sub_18BC614C4((uint64_t *)&v42, __dst, a5))
              goto LABEL_86;
            v35 = 1;
LABEL_99:
            v38 = v42;
            if (!strcmp(*v42, "root") || v38[2] || *(_BYTE *)(v14 + 96))
            {
LABEL_102:
              for (i = v42; ; ++*((_DWORD *)i + 27))
              {
                i = (const char **)i[2];
                if (!i)
                  break;
              }
              goto LABEL_86;
            }
            if (sub_18BC6164C((uint64_t)&v42, a5))
            {
              if (!v35)
                *(_DWORD *)(v14 + 112) = -127;
              goto LABEL_102;
            }
LABEL_86:
            if (*a5 > 0)
            {
              v14 = 0;
              goto LABEL_16;
            }
            v19 = v43;
            if (!v43)
              goto LABEL_16;
LABEL_15:
            *a5 = v19;
LABEL_16:
            umtx_unlock((std::mutex **)&unk_1ECD27C88);
            goto LABEL_17;
          }
        }
        else
        {
          v35 = 1;
        }
LABEL_85:
        if (v25)
          goto LABEL_86;
        goto LABEL_99;
      }
    }
    strcpy(__dst, "root");
    v37 = sub_18BC60B64(a2, __dst, v17, a4, (BOOL *)&v41, &v40, (BOOL *)&v41 + 1, (UErrorCode *)&v43);
    v19 = v43;
    if (v43 == 7)
      goto LABEL_14;
    v14 = (uint64_t)v37;
    if (!v37)
    {
      v19 = 2;
      goto LABEL_15;
    }
    v42 = v37;
    v43 = -127;
    if (!(_BYTE)v41)
      goto LABEL_102;
    goto LABEL_86;
  }
LABEL_17:
  if (BYTE4(v44[1]))
    uprv_free(v44[0]);
  if (v13 >= 1)
    return 0;
LABEL_27:
  if (*a5 > 0)
    return 0;
  if (!v14)
  {
    v5 = 0;
    v24 = 2;
    goto LABEL_37;
  }
  if (!v5)
  {
    v26 = uprv_malloc(0x88uLL);
    v5 = v26;
    if (v26)
    {
      v23 = 19700503;
      v26[16] = 0;
      *((_OWORD *)v26 + 6) = 0u;
      *((_OWORD *)v26 + 7) = 0u;
      *((_OWORD *)v26 + 4) = 0u;
      *((_OWORD *)v26 + 5) = 0u;
      *((_OWORD *)v26 + 2) = 0u;
      *((_OWORD *)v26 + 3) = 0u;
      *(_OWORD *)v26 = 0u;
      *((_OWORD *)v26 + 1) = 0u;
LABEL_44:
      v22 = vdup_n_s32(0x12BB38Bu);
      goto LABEL_45;
    }
    sub_18BC5FDE4(v14);
    v24 = 7;
LABEL_37:
    *a5 = v24;
    return v5;
  }
  if (*((_DWORD *)v5 + 29) != 19700503)
  {
    sub_18BC5C1BC(v5, 0);
    v5[16] = 0;
    *((_OWORD *)v5 + 6) = 0u;
    *((_OWORD *)v5 + 7) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    v22 = 0;
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    goto LABEL_47;
  }
  v21 = *((_DWORD *)v5 + 30);
  sub_18BC5C1BC(v5, 0);
  v5[16] = 0;
  v22.i32[1] = 0;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  if (v21 == 19641227)
    v23 = 19700503;
  else
    v23 = 0;
  if (v21 == 19641227)
    goto LABEL_44;
LABEL_45:
  v22.i32[0] = v23;
LABEL_47:
  *(int32x2_t *)((char *)v5 + 116) = v22;
  v5[1] = v14;
  v5[3] = v14;
  v27 = a4 != 2 && *(_BYTE *)(v14 + 96) == 0;
  *((_BYTE *)v5 + 112) = v27;
  *((_BYTE *)v5 + 113) = 1;
  v28 = *(_DWORD *)(v14 + 72);
  *((_DWORD *)v5 + 27) = v28;
  v29 = res_countArrayItems(v14 + 40, v28);
  *((_DWORD *)v5 + 31) = -1;
  *((_DWORD *)v5 + 32) = v29;
  return v5;
}

_QWORD *ures_openNoDefault(const char *a1, char *a2, int *a3)
{
  return sub_18BC5E03C(0, a1, a2, 1, a3);
}

uint64_t ures_openDirect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_18BC5E03C(0, a1, a2, 2, a3);
}

_QWORD *ures_openFillIn(_QWORD *result, const char *a2, char *a3, int *a4)
{
  if (result || *a4 > 0)
    return sub_18BC5E03C(result, a2, a3, 0, a4);
  *a4 = 1;
  return result;
}

_QWORD *ures_openDirectFillIn(_QWORD *result, const char *a2, char *a3, int *a4)
{
  if (result || *a4 > 0)
    return sub_18BC5E03C(result, a2, a3, 2, a4);
  *a4 = 1;
  return result;
}

_QWORD *ures_openWithCountryFallback(const char *a1, char *a2, BOOL *a3, int *a4)
{
  _QWORD *v8;
  _BOOL4 v9;
  _QWORD *v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  size_t v14;
  const char *v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  size_t v21;
  BOOL v22;
  BOOL v24;
  const char *v25;
  const char *v26;
  char __s[4];
  __int16 v28;
  char __s2[4];
  char __s1[4];
  int v31;
  char v32[8];
  int v33;
  char __dst[8];
  int v35;
  char v36[16];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _BYTE v44[29];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  if ((int)ulocimp_setRegionToSupplementalRegion(a2, 0, 0) >= 1)
  {
    v43 = 0u;
    memset(v44, 0, sizeof(v44));
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    *(_OWORD *)v36 = 0u;
    ulocimp_setRegionToSupplementalRegion(a2, v36, 157);
    if (*a4 <= 0)
    {
      v8 = (_QWORD *)ures_openWithCountryFallback(a1, v36, a3, a4);
      if (a3)
        *a3 = 1;
      return v8;
    }
  }
  v8 = sub_18BC5E03C(0, a1, a2, 0, a4);
  if (a3)
    *a3 = 0;
  *(_DWORD *)__s1 = 0;
  uloc_getCountry((uint64_t)a2, __s1, 4, a4);
  v9 = *a4 == -128;
  if (!a1 || *a4 != -128)
    goto LABEL_9;
  if (strcmp(a1, "icudt74l"))
  {
    *(_DWORD *)v36 = 0;
    v10 = sub_18BC5E03C(0, 0, a2, 0, (int *)v36);
    sub_18BC5C1BC(v10, 1);
    v9 = *(_DWORD *)v36 == -128;
LABEL_9:
    if (!v9)
      return v8;
  }
  if (__s1[0])
  {
    *(_DWORD *)__s2 = 0;
    if (*a4 <= 0)
    {
      if (v8)
      {
        v11 = *(_QWORD *)v8[1];
      }
      else
      {
        v11 = 0;
        *a4 = 1;
      }
    }
    else
    {
      v11 = 0;
    }
    uloc_getCountry(v11, __s2, 4, a4);
    if (strcmp(__s1, __s2))
    {
      v35 = 0;
      *(_QWORD *)__dst = 0;
      v28 = 0;
      *(_DWORD *)__s = 0;
      v43 = 0u;
      memset(v44, 0, sizeof(v44));
      v41 = 0u;
      v42 = 0u;
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      *(_OWORD *)v36 = 0u;
      uloc_getLanguage((uint64_t)a2, __dst, 12, a4);
      uloc_getScript((uint64_t)a2, __s, 6, a4);
      v12 = strlen(__s);
      v13 = strlen(__dst);
      if (v12)
        v14 = v12 + 1;
      else
        v14 = 0;
      sprintf(v36, "und_%s", __s1);
      uloc_addLikelySubtags(v36, v36, 157, (UErrorCode *)a4);
      uloc_getLanguage((uint64_t)v36, __dst, 12, a4);
      uloc_getScript((uint64_t)v36, __s, 6, a4);
      if (*a4 > 0)
        return v8;
      v15 = &a2[v13 + 1 + v14];
      *a4 = 0;
      sprintf(v36, "%s_%s_%s", __dst, __s, v15);
      v16 = sub_18BC5E03C(0, a1, v36, 0, a4);
      v17 = v16;
      v18 = *a4;
      if ((*a4 & 0xFFFFFFFE) == 0xFFFFFF80)
      {
        v33 = 0;
        *(_QWORD *)v32 = 0;
        if (v16)
        {
          v19 = *(_QWORD *)v16[1];
        }
        else
        {
          v19 = 0;
          *a4 = 1;
        }
        uloc_getLanguage(v19, v32, 12, a4);
        v18 = *a4;
        if (*a4 == -127 || strcmp(__dst, v32))
        {
          v20 = 0;
          strcpy(__dst, "en");
          while (1)
          {
            v21 = strlen((&off_1E22574B8)[v20]);
            if (!strncmp(v36, (&off_1E22574B8)[v20], v21))
              break;
            v22 = v20 >= 8;
            v20 += 2;
            if (v22)
              goto LABEL_36;
          }
          strcpy(__dst, (&off_1E22574B8)[v20 + 1]);
LABEL_36:
          sprintf(v36, "%s_%s_%s", __dst, __s, v15);
          sub_18BC5C1BC(v17, 1);
          v17 = sub_18BC5E03C(0, a1, v36, 0, a4);
          v18 = *a4;
        }
      }
      if (v18 > 0)
        return v8;
      if (a3)
      {
        if (v8 && v17)
        {
          v24 = 0;
          v25 = *(const char **)v8[1];
          if (v25)
          {
            v26 = *(const char **)v17[1];
            if (v26)
              v24 = strcmp(v25, v26) != 0;
          }
        }
        else
        {
          v24 = 0;
        }
        *a3 = v24;
      }
      sub_18BC5C1BC(v8, 1);
      return v17;
    }
  }
  return v8;
}

uint64_t ures_countArrayItems(uint64_t a1, const char *a2, int *a3)
{
  uint64_t v4;
  _OWORD v6[6];
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v7 = 0u;
  v8 = 0u;
  memset(v6, 0, sizeof(v6));
  if (a3 && *a3 <= 0)
  {
    if (!a1)
    {
      v4 = 0;
      *a3 = 1;
      return v4;
    }
    ures_getByKey(a1, a2, (uint64_t)v6, a3);
    if (*(_QWORD *)(*((_QWORD *)&v6[0] + 1) + 40))
    {
      v4 = res_countArrayItems(*((_QWORD *)&v6[0] + 1) + 40, HIDWORD(v7));
      sub_18BC5C1BC(v6, 1);
      return v4;
    }
    *a3 = 2;
    sub_18BC5C1BC(v6, 1);
  }
  return 0;
}

char *ures_getVersionNumberInternal(uint64_t a1)
{
  char *v2;
  const UChar *StringByKey;
  unsigned int v5;
  char *v6;
  int32_t length[2];

  if (!a1)
    return 0;
  v2 = *(char **)(a1 + 16);
  if (!v2)
  {
    *(_QWORD *)length = 0;
    StringByKey = ures_getStringByKey(a1, "Version", length, &length[1]);
    if (length[0] <= 1)
      v5 = 1;
    else
      v5 = length[0];
    v6 = (char *)uprv_malloc(v5 + 1);
    v2 = v6;
    *(_QWORD *)(a1 + 16) = v6;
    if (v6)
    {
      if (length[0] < 1)
      {
        *(_WORD *)v6 = 48;
      }
      else
      {
        u_UCharsToChars(StringByKey, v6, length[0]);
        *(_BYTE *)(*(_QWORD *)(a1 + 16) + v5) = 0;
        return *(char **)(a1 + 16);
      }
    }
  }
  return v2;
}

void ures_getVersion(uint64_t a1, uint8_t *a2)
{
  char *VersionNumberInternal;

  if (a1)
  {
    VersionNumberInternal = ures_getVersionNumberInternal(a1);
    u_versionFromString(a2, VersionNumberInternal);
  }
}

_QWORD *ures_openAvailableLocales(const char *a1, int *a2)
{
  _OWORD *v4;
  _OWORD *v5;
  _QWORD *v6;
  _QWORD *v7;

  if (*a2 > 0)
    return 0;
  v4 = uprv_malloc(0x110uLL);
  v5 = uprv_malloc(0x38uLL);
  v6 = v5;
  if (!v5 || !v4)
  {
    *a2 = 7;
    uprv_free(v5);
    uprv_free(v4);
    return 0;
  }
  *v5 = xmmword_1E2257508;
  v5[1] = *(_OWORD *)&off_1E2257518;
  v5[2] = xmmword_1E2257528;
  *((_QWORD *)v5 + 6) = sub_18BC61B98;
  *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  v4[11] = 0u;
  v4[12] = 0u;
  v4[13] = 0u;
  v4[14] = 0u;
  v4[15] = 0u;
  v4[16] = 0u;
  v7 = sub_18BC5E03C(0, a1, "res_index", 2, a2);
  ures_getByKey((uint64_t)v7, "InstalledLocales", (uint64_t)v4, a2);
  if (*a2 <= 0)
  {
    v6[1] = v4;
  }
  else
  {
    sub_18BC5C1BC(v4, 1);
    uprv_free(v4);
    uprv_free(v6);
    v6 = 0;
  }
  sub_18BC5C1BC(v7, 1);
  return v6;
}

uint64_t ures_getFunctionalEquivalent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9)
{
  uint64_t v9;
  int v10;
  int v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  const char *v18;
  const char *v19;
  const char *v20;
  const char *v21;
  int v22;
  int v23;
  char *v24;
  uint64_t v25;
  const char *v26;
  _BYTE *v27;
  void **v28;
  const char *v29;
  char v30;
  _QWORD *v31;
  uint64_t v32;
  const UChar *StringByKey;
  const UChar *v34;
  int32_t v35;
  _QWORD *v36;
  uint64_t v37;
  size_t v38;
  const UChar *v39;
  const UChar *v40;
  int32_t v41;
  const char *v42;
  _BYTE *v43;
  size_t v44;
  int v45;
  _BYTE *v46;
  _QWORD *v47;
  _QWORD *v48;
  size_t v49;
  const UChar *v50;
  const UChar *v51;
  int32_t v52;
  const char *v53;
  size_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  char *v59;
  void *v60;
  uint64_t v61;
  char *v62;
  int v63;
  void *v64;
  uint64_t v65;
  void *__s2;
  uint64_t v67;
  UErrorCode v68;
  char v69[8];
  int v70;
  char v71[8];
  uint64_t v72;
  void *__s1[7];
  uint64_t v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  uint64_t v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  uint64_t v92;
  char v93[1024];
  char __src[1024];
  char __dst[4];
  unsigned __int8 v96;
  void *v97[8];
  char __s[1024];
  char v99[1024];
  uint64_t v100;

  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v19 = v18;
  v21 = v20;
  v23 = v22;
  v24 = (char *)v9;
  v100 = *MEMORY[0x1E0C80C00];
  bzero(v99, 0x400uLL);
  bzero(__s, 0x400uLL);
  memset(&v97[1], 0, 56);
  v97[0] = (char *)&v97[1] + 5;
  LODWORD(v97[1]) = 40;
  bzero(__dst, 0x400uLL);
  bzero(__src, 0x400uLL);
  bzero(v93, 0x400uLL);
  v68 = U_ZERO_ERROR;
  if (*a9 >= 1)
    return 0;
  v59 = v24;
  v92 = 0;
  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v75 = 0u;
  v76 = 0u;
  v77 = 0u;
  v78 = 0u;
  v79 = 0u;
  v80 = 0u;
  v81 = 0u;
  v82 = 0u;
  v83 = 0;
  memset(&__s1[1], 0, 48);
  v72 = 0;
  __s1[0] = (char *)&__s1[1] + 5;
  LODWORD(__s1[1]) = 40;
  v74 = 0;
  *(_QWORD *)v71 = 0;
  icu::CharStringByteSink::CharStringByteSink(v71, (uint64_t)__s1);
  ulocimp_getKeywordValue(v15, v17, (uint64_t)v71, (int *)&v68);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v71);
  icu::StringPiece::StringPiece((icu::StringPiece *)&__s2, "default");
  v26 = v17;
  if ((_DWORD)v74 == (_DWORD)v67)
  {
    v27 = __s1[0];
    if (!(_DWORD)v67 || !memcmp(__s1[0], __s2, (int)v67))
    {
      LODWORD(v74) = 0;
      *v27 = 0;
    }
  }
  *(_QWORD *)v71 = 0;
  v72 = 0;
  icu::CharStringByteSink::CharStringByteSink(v71, (uint64_t)v97);
  ulocimp_getBaseName(v15, (uint64_t)v71, &v68);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v71);
  v84 = 0u;
  v85 = 0u;
  v86 = 0u;
  v87 = 0u;
  v88 = 0u;
  v89 = 0u;
  v90 = 0u;
  v91 = 0u;
  v92 = 0;
  v75 = 0u;
  v76 = 0u;
  v77 = 0u;
  v78 = 0u;
  v79 = 0u;
  v80 = 0u;
  v81 = 0u;
  v82 = 0u;
  v83 = 0;
  icu::CharString::extract((char **)v97, __src, 1024, &v68);
  icu::CharString::extract((char **)v97, __dst, 1024, &v68);
  if (v13)
  {
    v28 = (void **)ures_openAvailableLocales(v21, (int *)&v68);
    *v13 = 1;
    if (v68 <= U_ZERO_ERROR)
    {
      do
      {
        v29 = (const char *)uenum_next((uint64_t)v28, 0, (int *)&v68);
        if (!v29)
        {
          v30 = 0;
          goto LABEL_14;
        }
      }
      while (strcmp(v29, __src));
      v30 = 1;
LABEL_14:
      *v13 = v30;
    }
    uenum_close(v28);
  }
  if (v68 > U_ZERO_ERROR)
  {
    v25 = 0;
    *a9 = v68;
    goto LABEL_107;
  }
  do
  {
    v68 = U_ZERO_ERROR;
    v31 = sub_18BC5E03C(0, v21, __src, 0, (int *)&v68);
    v32 = (uint64_t)v31;
    if (v13 && (v68 & 0xFFFFFFFE) == 0xFFFFFF80)
    {
      *v13 = 0;
    }
    else if (v68 < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (v68 == U_ZERO_ERROR)
      {
        ures_getByKey((uint64_t)v31, v19, (uint64_t)&v84, (int *)&v68);
        if (v68 == U_ZERO_ERROR)
        {
          *(_DWORD *)v71 = 0;
          StringByKey = ures_getStringByKey((uint64_t)&v84, "default", (int *)v71, (int *)&v68);
          if (v68 <= U_ZERO_ERROR)
          {
            if (*(_DWORD *)v71)
            {
              v34 = StringByKey;
              v35 = u_strlen(StringByKey);
              u_UCharsToChars(v34, v99, v35);
              strcpy(__s, __src);
              if (!(_DWORD)v74)
                icu::CharString::append((icu::CharString *)__s1, v99, *(int *)v71, &v68);
            }
          }
        }
      }
    }
    else
    {
      *a9 = v68;
    }
    v68 = U_ZERO_ERROR;
    if (v32)
      strcpy(__dst, **(const char ***)(v32 + 24));
    if (!strcmp(__dst, __src))
      sub_18BC5F990(__dst, v32, (uint64_t)&v84, __src, 1024);
    else
      strcpy(__src, __dst);
    sub_18BC5C1BC((_QWORD *)v32, 1);
    if (v99[0])
      break;
    if (!__dst[0])
      break;
    if (!(*(_DWORD *)__dst ^ 0x746F6F72 | v96))
      break;
    v13 = 0;
  }
  while (*a9 < 1);
  icu::CharString::extract((char **)v97, __src, 1024, &v68);
  icu::CharString::extract((char **)v97, __dst, 1024, &v68);
  while (1)
  {
    v36 = sub_18BC5E03C(0, v21, __src, 0, (int *)&v68);
    v37 = (uint64_t)v36;
    if (v68 < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (v68 == U_ZERO_ERROR)
      {
        ures_getByKey((uint64_t)v36, v19, (uint64_t)&v84, (int *)&v68);
        if (v68 == U_ZERO_ERROR)
        {
          ures_getByKey((uint64_t)&v84, (const char *)__s1[0], (uint64_t)&v75, (int *)&v68);
          if (v68 == U_ZERO_ERROR)
          {
            strcpy(v93, __src);
            if (!v93[0])
              strcpy(v93, "root");
            v38 = strlen(__s);
            if (v38 > strlen(v93))
            {
              *(_DWORD *)v71 = 0;
              v39 = ures_getStringByKey((uint64_t)&v84, "default", (int *)v71, (int *)&v68);
              if (v68 <= U_ZERO_ERROR)
              {
                if (*(_DWORD *)v71)
                {
                  v40 = v39;
                  v41 = u_strlen(v39);
                  u_UCharsToChars(v40, v99, v41);
                  strcpy(__s, v93);
                }
              }
            }
          }
        }
      }
    }
    else
    {
      *a9 = v68;
    }
    if (v37)
    {
      if (!strcmp(v19, "collations"))
      {
        v68 = U_ZERO_ERROR;
        v42 = **(const char ***)(v37 + 24);
        if (v42)
        {
          if (*v42 && strcmp(v42, "root"))
          {
            LODWORD(v72) = 0;
            *(_QWORD *)v71 = 0;
            v70 = 0;
            *(_QWORD *)v69 = 0;
            uloc_getLanguage((uint64_t)v42, v71, 12, (int *)&v68);
            uloc_getLanguage((uint64_t)__src, v69, 12, (int *)&v68);
            if (v68 <= U_ZERO_ERROR && strcmp(v71, v69))
            {
              strcpy(__dst, v42);
              v68 = U_ZERO_ERROR;
              goto LABEL_54;
            }
            v68 = U_ZERO_ERROR;
          }
        }
      }
    }
    strcpy(__dst, __src);
LABEL_54:
    sub_18BC5F990(__dst, v37, (uint64_t)&v84, __src, 1023);
    sub_18BC5C1BC((_QWORD *)v37, 1);
    v68 = U_ZERO_ERROR;
    if (v93[0] || !__dst[0])
      break;
    if (*a9 > 0)
      goto LABEL_66;
  }
  if (v93[0])
    goto LABEL_69;
LABEL_66:
  icu::StringPiece::StringPiece((icu::StringPiece *)&v64, v99);
  if ((_DWORD)v74 == (_DWORD)v65)
  {
    if (!(_DWORD)v65)
      goto LABEL_69;
    v43 = __s1[0];
    if (!memcmp(__s1[0], v64, (int)v65))
      goto LABEL_69;
  }
  else
  {
    v43 = __s1[0];
  }
  LODWORD(v74) = 0;
  *v43 = 0;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v62, v99);
  icu::CharString::append((icu::CharString *)__s1, v62, v63, &v68);
  icu::CharString::extract((char **)v97, __src, 1024, &v68);
  icu::CharString::extract((char **)v97, __dst, 1024, &v68);
  while (1)
  {
    v47 = sub_18BC5E03C(0, v21, __src, 0, (int *)&v68);
    v48 = v47;
    if (v68 < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (v68 == U_ZERO_ERROR)
      {
        ures_getByKey((uint64_t)v47, v19, (uint64_t)&v84, (int *)&v68);
        if (v68 == U_ZERO_ERROR)
        {
          ures_getByKey((uint64_t)&v84, (const char *)__s1[0], (uint64_t)&v75, (int *)&v68);
          if (v68 == U_ZERO_ERROR)
          {
            strcpy(v93, __src);
            if (!v93[0])
              strcpy(v93, "root");
            v49 = strlen(__s);
            if (v49 > strlen(v93))
            {
              *(_DWORD *)v71 = 0;
              v50 = ures_getStringByKey((uint64_t)&v84, "default", (int *)v71, (int *)&v68);
              if (v68 <= U_ZERO_ERROR)
              {
                if (*(_DWORD *)v71)
                {
                  v51 = v50;
                  v52 = u_strlen(v50);
                  u_UCharsToChars(v51, v99, v52);
                  strcpy(__s, v93);
                }
              }
            }
          }
        }
      }
    }
    else
    {
      *a9 = v68;
    }
    strcpy(__dst, __src);
    sub_18BC5F990(__dst, (uint64_t)v48, (uint64_t)&v84, __src, 1023);
    sub_18BC5C1BC(v48, 1);
    v68 = U_ZERO_ERROR;
    if (v93[0] || !__dst[0])
      break;
    if (*a9 > 0)
      goto LABEL_100;
  }
LABEL_69:
  if (*a9 <= 0)
  {
    if (!v93[0])
    {
      *a9 = 2;
      goto LABEL_95;
    }
    if (v11 && (v44 = strlen(__s), v44 <= strlen(v93)))
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v60, v99);
      v45 = v74;
      if ((_DWORD)v74 == (_DWORD)v61)
      {
        v46 = __s1[0];
        if (!(_DWORD)v61 || !memcmp(__s1[0], v60, (int)v61))
        {
          LODWORD(v74) = 0;
          *v46 = 0;
        }
        goto LABEL_95;
      }
    }
    else
    {
LABEL_95:
      v45 = v74;
    }
    strcpy(__dst, v93);
    if (v45)
    {
      *(_WORD *)&__dst[strlen(__dst)] = 64;
      strcat(__dst, v26);
      *(_WORD *)&__dst[strlen(__dst)] = 61;
      v53 = (const char *)__s1[0];
      goto LABEL_98;
    }
    if (!v11)
    {
      *(_WORD *)&__dst[strlen(__dst)] = 64;
      strcat(__dst, v26);
      *(_WORD *)&__dst[strlen(__dst)] = 61;
      v53 = v99;
LABEL_98:
      strcat(__dst, v53);
    }
  }
LABEL_100:
  sub_18BC5C1BC(&v84, 1);
  sub_18BC5C1BC(&v75, 1);
  v54 = strlen(__dst);
  if (*a9 <= 0)
  {
    v55 = v54;
    v57 = uprv_min(v54, v23);
    v56 = (uint64_t)v59;
    if (v57 >= 1)
      strncpy(v59, __dst, v57);
    if (!(_DWORD)v55)
      *a9 = 2;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t)v59;
    *v59 = 0;
  }
  v25 = u_terminateChars(v56, v23, v55, a9);
LABEL_107:
  if (BYTE4(__s1[1]))
    uprv_free(__s1[0]);
  if (BYTE4(v97[1]))
    uprv_free(v97[0]);
  return v25;
}

char *sub_18BC5F990(char *a1, uint64_t a2, uint64_t a3, char *a4, int32_t a5)
{
  UChar *StringNoTrace;
  int v10;
  char *result;
  int32_t pDestLength;
  int v13;
  int32_t srcLength;

  v13 = 0;
  *a4 = 0;
  if (!a2)
    goto LABEL_9;
  ures_getByKey(a2, "%%Parent", a3, &v13);
  if (v13 > 0)
    goto LABEL_9;
  pDestLength = a5;
  srcLength = 0;
  if (!a3)
  {
    v10 = 1;
    goto LABEL_7;
  }
  StringNoTrace = (UChar *)res_getStringNoTrace(*(_QWORD *)(a3 + 8) + 40, *(_DWORD *)(a3 + 108), &srcLength);
  if (!StringNoTrace)
  {
    v10 = 17;
LABEL_7:
    StringNoTrace = 0;
    v13 = v10;
  }
  result = sub_18BC5C56C(StringNoTrace, srcLength, a4, &pDestLength, 1, &v13);
  if (v13 > 0 || !*a4)
  {
LABEL_9:
    v13 = 0;
    return (char *)uloc_getParent(a1, a4, a5, &v13);
  }
  return result;
}

_OWORD *ures_getKeywordValues(uint64_t a1)
{
  uint64_t v1;
  int *v2;
  int *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  void **v7;
  void **v9;
  uint64_t v10;
  char *v11;
  int v12;
  _QWORD *v13;
  const char **NextResource;
  const char *v15;
  void **v16;
  const char *v17;
  const char *v18;
  uint64_t v19;
  const char **v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  _OWORD v27[8];
  uint64_t v28;
  _QWORD v29[17];
  _QWORD v30[512];
  __int16 v31;
  _BYTE v32[2070];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v6 = (const char *)v1;
  *(_QWORD *)&v32[2046] = *MEMORY[0x1E0C80C00];
  bzero(v32, 0x7FEuLL);
  bzero(v30, 0x1000uLL);
  v26 = 0;
  memset(v29, 0, sizeof(v29));
  memset(v27, 0, sizeof(v27));
  v28 = 0;
  v7 = (void **)ures_openAvailableLocales(v6, v3);
  if (*v3 < 1)
  {
    v9 = v7;
    v31 = 0;
    v10 = uenum_next((uint64_t)v7, (uint64_t)&v26, v3);
    if (v10)
    {
      v11 = (char *)v10;
      v12 = 0;
      v24 = 0;
      do
      {
        v25 = 0;
        v13 = sub_18BC5E03C(0, v6, v11, 0, &v25);
        ures_getByKey((uint64_t)v13, v5, (uint64_t)v29, &v25);
        if (v13)
        {
          if (v25 <= 0)
          {
            NextResource = (const char **)ures_getNextResource((uint64_t)v29, (char *)v27, &v25);
            if (NextResource)
            {
              if (v25 <= 0)
              {
                do
                {
                  v15 = *NextResource;
                  if (*NextResource && *v15 && strcmp(*NextResource, "default") && strncmp(v15, "private-", 8uLL))
                  {
                    if (v12 >= 1)
                    {
                      v16 = v9;
                      v17 = v6;
                      v18 = v5;
                      v19 = v12;
                      v20 = (const char **)v30;
                      do
                      {
                        if (!strcmp(*v20, v15))
                        {
                          v5 = v18;
                          v6 = v17;
                          v9 = v16;
                          goto LABEL_22;
                        }
                        ++v20;
                        --v19;
                      }
                      while (v19);
                      v5 = v18;
                      v6 = v17;
                      v9 = v16;
                      if (v12 > 510)
                        goto LABEL_19;
                    }
                    v21 = strlen(v15);
                    v22 = v24;
                    v23 = v24 + (uint64_t)v21;
                    if ((int)v23 < 2046)
                    {
                      v24 = v23 + 1;
                      v30[v12++] = strcpy(&v32[v22 - 2], v15);
                      v32[v23 - 2] = 0;
                    }
                    else
                    {
LABEL_19:
                      *v3 = 1;
                    }
                  }
LABEL_22:
                  NextResource = (const char **)ures_getNextResource((uint64_t)v29, (char *)v27, &v25);
                }
                while (NextResource && v25 < 1);
              }
            }
          }
        }
        sub_18BC5C1BC(v13, 1);
        v11 = (char *)uenum_next((uint64_t)v9, (uint64_t)&v26, v3);
      }
      while (v11);
    }
    else
    {
      v24 = 0;
    }
    v32[v24 - 2] = 0;
    sub_18BC5C1BC(v29, 1);
    sub_18BC5C1BC(v27, 1);
    uenum_close(v9);
    return uloc_openKeywordList(&v31, v24 + 1, v3);
  }
  else
  {
    sub_18BC5C1BC(v29, 1);
    sub_18BC5C1BC(v27, 1);
    return 0;
  }
}

void ures_getVersionByKey(uint64_t a1, const char *a2, uint8_t *a3, int *a4)
{
  const UChar *StringByKey;
  int v7;

  v7 = 0;
  StringByKey = ures_getStringByKey(a1, a2, &v7, a4);
  if (*a4 <= 0)
    u_versionFromUString(a3, StringByKey);
}

void sub_18BC5FDE4(uint64_t a1)
{
  uint64_t v2;

  umtx_lock((icu::UMutex *)&unk_1ECD27C88);
  if (a1)
  {
    do
    {
      v2 = *(_QWORD *)(a1 + 16);
      --*(_DWORD *)(a1 + 108);
      a1 = v2;
    }
    while (v2);
  }
  umtx_unlock((std::mutex **)&unk_1ECD27C88);
}

uint64_t sub_18BC5FE30(uint64_t a1, unsigned int a2, const char *a3, unsigned int a4, uint64_t a5, char *a6, int a7, uint64_t a8, UErrorCode *a9)
{
  uint64_t v9;
  int v16;
  uint64_t v17;
  void *v18;
  char *v19;
  char *v21;
  int v22;
  int v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  _OWORD v27[16];
  uint64_t v28;

  v9 = a8;
  v28 = *MEMORY[0x1E0C80C00];
  if (!a9 || *(int *)a9 > 0)
    return v9;
  if (a5)
  {
    if (a2 >> 28 == 3)
    {
      if (a7 < 256)
        return sub_18BC600EC(a1 + 40, a2, a3, a4, a5, a6, a7, a8, a9);
      v16 = 24;
      goto LABEL_8;
    }
    if (a8)
    {
      v17 = *(_QWORD *)(a8 + 8);
      if (v17)
        sub_18BC5FDE4(v17);
      v18 = *(void **)(v9 + 16);
      if (v18)
        uprv_free(v18);
      v19 = *(char **)(v9 + 32);
      if (v19 == a6)
      {
LABEL_22:
        *(_QWORD *)(v9 + 8) = a1;
        sub_18BC5C44C(a1);
        *(_WORD *)(v9 + 112) = 0;
        *(_DWORD *)(v9 + 124) = -1;
        *(_QWORD *)v9 = a3;
        *(_QWORD *)(v9 + 24) = a5;
        if (*(char **)(v9 + 32) != a6)
        {
          v22 = strlen(a6);
          sub_18BC5C384(v9, a6, v22, a9);
        }
        if (a3)
        {
          v23 = strlen(a3);
          v24 = v9;
          v25 = (char *)a3;
        }
        else
        {
          if ((a4 & 0x80000000) != 0)
          {
LABEL_30:
            if (v9 + 40 == *(_QWORD *)(v9 + 32))
              v26 = *(int *)(v9 + 104);
            else
              v26 = 0;
            bzero((void *)(v9 + 40 + v26), 64 - v26);
            *(_QWORD *)(v9 + 16) = 0;
            *(_DWORD *)(v9 + 108) = a2;
            *(_DWORD *)(v9 + 128) = res_countArrayItems(*(_QWORD *)(v9 + 8) + 40, a2);
            return v9;
          }
          memset(v27, 0, sizeof(v27));
          v23 = T_CString_integerToString(v27, a4, 0xAu);
          v25 = (char *)v27;
          v24 = v9;
        }
        sub_18BC5C384(v24, v25, v23, a9);
        if (*(_BYTE *)(*(int *)(v9 + 104) + *(_QWORD *)(v9 + 32) - 1) != 47)
          sub_18BC5C384(v9, "/", 1, a9);
        goto LABEL_30;
      }
      if (v19 && v19 != (char *)(v9 + 40))
        uprv_free(v19);
LABEL_21:
      *(_QWORD *)(v9 + 32) = 0;
      *(_DWORD *)(v9 + 104) = 0;
      goto LABEL_22;
    }
    v21 = (char *)uprv_malloc(0x88uLL);
    v9 = (uint64_t)v21;
    if (v21)
    {
      *(_QWORD *)(v21 + 116) = 0x12BB38B012C9B17;
      goto LABEL_21;
    }
    v16 = 7;
  }
  else
  {
    v9 = 0;
    v16 = 1;
  }
LABEL_8:
  *a9 = v16;
  return v9;
}

uint64_t sub_18BC600EC(uint64_t a1, unsigned int a2, const char *a3, unsigned int a4, uint64_t a5, const char *a6, int a7, uint64_t a8, UErrorCode *a9)
{
  int *Alias;
  uint64_t v16;
  char *v17;
  const char *v18;
  char *v19;
  const char *v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  UErrorCode v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  UErrorCode v33;
  uint64_t v34;
  void *v35;
  BOOL v36;
  int v37;
  uint64_t TableItemByIndex;
  uint64_t v40;
  _QWORD *v41;
  char *v42;
  char *v43;
  int v44;
  char *v45;
  int v46;
  char *v47;
  int v48;
  char *__s2;
  int32_t v50;
  char *__dst[2];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  char *__s[7];
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(int *)a9 > 0)
    return a8;
  v50 = 0;
  Alias = res_getAlias(a1, a2, &v50);
  if (v50 <= 0)
  {
    *a9 = U_ILLEGAL_ARGUMENT_ERROR;
    return a8;
  }
  memset(&__s[1], 0, 48);
  __s[0] = (char *)&__s[1] + 5;
  LODWORD(__s[1]) = 40;
  v56 = 0;
  icu::CharString::appendInvariantChars((int *)__s, (UChar *)Alias, v50, a9);
  v16 = 0;
  if (*(int *)a9 <= 0)
  {
    v17 = __s[0];
    if (*__s[0] == 47)
    {
      v18 = __s[0] + 1;
      v19 = strchr(__s[0] + 1, 47);
      v17 = v19;
      if (v19)
      {
        *v19 = 0;
        v17 = v19 + 1;
      }
      if (!strcmp(v18, "LOCALE"))
      {
        v41 = 0;
        v26 = a5;
        goto LABEL_22;
      }
      if (!strcmp(v18, "ICUDATA"))
        v20 = 0;
      else
        v20 = v18;
      if (v17)
      {
        v21 = strchr(v17, 47);
        v22 = v21;
        if (v21)
        {
          *v21 = 0;
          v22 = v21 + 1;
        }
      }
      else
      {
        v22 = 0;
        v17 = "";
      }
    }
    else
    {
      v23 = strchr(__s[0], 47);
      v22 = v23;
      if (v23)
      {
        *v23 = 0;
        v22 = v23 + 1;
      }
      v20 = *(const char **)(a5 + 8);
    }
    LODWORD(__dst[0]) = 0;
    v24 = sub_18BC5E03C(0, v20, v17, 2, __dst);
    v25 = (_QWORD *)v24;
    if (SLODWORD(__dst[0]) > 0)
    {
      *a9 = (UErrorCode)__dst[0];
LABEL_72:
      if (v25)
        sub_18BC5C1BC(v25, 1);
      v16 = a8;
      goto LABEL_75;
    }
    v41 = (_QWORD *)v24;
    v26 = *(_QWORD *)(v24 + 8);
    v17 = v22;
LABEL_22:
    __s2 = 0;
    if (v17)
    {
      v53 = 0u;
      v54 = 0u;
      *(_OWORD *)__dst = 0u;
      v52 = 0u;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v43, v17);
      __dst[0] = (char *)((unint64_t)__dst | 0xD);
      LODWORD(__dst[1]) = 40;
      WORD2(__dst[1]) = 0;
      DWORD2(v54) = 0;
      icu::CharString::append((icu::CharString *)__dst, v43, v44, a9);
      v27 = *a9;
      if (*(int *)a9 <= 0)
      {
        v30 = 0;
        v31 = __dst[0];
        v42 = __dst[0];
        v32 = (a7 + 1);
        v33 = v27;
        v28 = a8;
        while (1)
        {
          v34 = *(unsigned int *)(v26 + 72);
          while (*v31)
          {
            if (v33 > U_ZERO_ERROR)
              goto LABEL_25;
            v34 = sub_18BC63030(v26 + 40, v34, &v42, (const char **)&__s2);
            if ((_DWORD)v34 == -1)
            {
              v33 = *a9;
              break;
            }
            v28 = sub_18BC5FE30(v26, v34, __s2, 0xFFFFFFFFLL, a5, v30, v32, v28, a9);
            v33 = *a9;
            if (*(int *)a9 > 0)
              goto LABEL_25;
            if (!__s2 || strcmp(v17, __s2))
            {
              v35 = *(void **)(v28 + 32);
              if (v35)
                v36 = v35 == (void *)(v28 + 40);
              else
                v36 = 1;
              if (!v36)
                uprv_free(v35);
              *(_QWORD *)(v28 + 32) = 0;
              *(_DWORD *)(v28 + 104) = 0;
              v37 = strlen(v17);
              sub_18BC5C384(v28, v17, v37, a9);
              if (*(_BYTE *)(*(int *)(v28 + 104) + *(_QWORD *)(v28 + 32) - 1) != 47)
                sub_18BC5C384(v28, "/", 1, a9);
              v33 = *a9;
              if (*(int *)a9 > 0)
                goto LABEL_25;
            }
            v26 = *(_QWORD *)(v28 + 8);
            v30 = *(_QWORD *)(v28 + 32);
            v34 = *(unsigned int *)(v28 + 108);
            v31 = v42;
          }
          if (v33 > U_ZERO_ERROR || (_DWORD)v34 != -1)
            break;
          v26 = *(_QWORD *)(v26 + 16);
          if (!v26)
          {
            *a9 = U_MISSING_RESOURCE_ERROR;
            break;
          }
          v42 = __dst[0];
          strcpy(__dst[0], v17);
          v31 = v42;
          v33 = *a9;
        }
      }
      else
      {
        v28 = a8;
        a8 = 0;
      }
LABEL_25:
      v25 = v41;
      if (BYTE4(__dst[1]))
        uprv_free(__dst[0]);
      if (v27 > U_ZERO_ERROR)
        goto LABEL_72;
      goto LABEL_69;
    }
    v40 = v26 + 40;
    v29 = *(unsigned int *)(v26 + 72);
    if (a6)
    {
      LODWORD(v56) = 0;
      *__s[0] = 0;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v47, a6);
      icu::CharString::append((icu::CharString *)__s, v47, v48, a9);
      v25 = v41;
      if (*(int *)a9 > 0)
      {
LABEL_58:
        a8 = 0;
        goto LABEL_72;
      }
      __dst[0] = __s[0];
      v29 = sub_18BC63030(v40, v29, __dst, (const char **)&__s2);
    }
    else
    {
      v25 = v41;
    }
    if (a3)
    {
      LODWORD(v56) = 0;
      *__s[0] = 0;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v45, a3);
      icu::CharString::append((icu::CharString *)__s, v45, v46, a9);
      if (*(int *)a9 > 0)
        goto LABEL_58;
      __dst[0] = __s[0];
      TableItemByIndex = sub_18BC63030(v40, v29, __dst, (const char **)&__s2);
    }
    else
    {
      if (a4 == -1)
        goto LABEL_66;
      if (v29 >> 28 == 2 || (v29 & 0xE0000000) == 0x40000000)
      {
        __dst[0] = 0;
        TableItemByIndex = res_getTableItemByIndex(v40, v29, a4, __dst);
      }
      else
      {
        TableItemByIndex = res_getArrayItem(v40, v29, a4);
      }
    }
    v29 = TableItemByIndex;
LABEL_66:
    if ((_DWORD)v29 == -1)
    {
      *a9 = U_MISSING_RESOURCE_ERROR;
      v28 = a8;
    }
    else
    {
      v28 = sub_18BC5FE30(v26, v29, __s2, 0xFFFFFFFFLL, a5, 0, (a7 + 1), a8, a9);
    }
LABEL_69:
    if (v25 == (_QWORD *)v28)
      v25 = 0;
    a8 = v28;
    goto LABEL_72;
  }
LABEL_75:
  if (BYTE4(__s[1]))
    uprv_free(__s[0]);
  return v16;
}

void sub_18BC60674(icu::ResourceSink *a1)
{
  void *v1;

  icu::ResourceSink::~ResourceSink(a1);
  icu::UMemory::operator delete(v1);
}

void sub_18BC60688(uint64_t a1, char *a2, icu::ResourceValue *a3, uint64_t a4, UErrorCode *a5)
{
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  char v18;
  char *v19;
  char *v20;
  int v21;
  const char *v22;
  char *v23;
  char *v24;
  int v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _OWORD v30[2];
  uint64_t v31;
  char *v32;
  void *v33[7];
  int v34;
  int v35;
  void *v36[7];
  int v37;
  int v38;
  _OWORD v39[8];
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  v32 = a2;
  memset(v30, 0, sizeof(v30));
  (*(void (**)(_OWORD *__return_ptr, icu::ResourceValue *, UErrorCode *))(*(_QWORD *)a3 + 88))(v30, a3, a5);
  if (*(int *)a5 <= 0
    && icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v30, 0, (const char **)&v32, a3))
  {
    v9 = 0;
    do
    {
      if ((*(unsigned int (**)(icu::ResourceValue *))(*(_QWORD *)a3 + 24))(a3) == 3)
      {
        v40 = 0;
        memset(v39, 0, sizeof(v39));
        v10 = sub_18BC600EC(*((_QWORD *)a3 + 1), *((_DWORD *)a3 + 6), 0, 0xFFFFFFFF, *((_QWORD *)a3 + 2), 0, 0, (uint64_t)v39, a5);
        if (*(int *)a5 <= 0)
        {
          v11 = v10;
          v29 = 0;
          v27 = 0;
          v28 = 0;
          v12 = *(_QWORD *)(v10 + 8) + 40;
          v26 = &unk_1E2257598;
          v27 = v12;
          v28 = *(_QWORD *)(v10 + 24);
          LODWORD(v29) = *(_DWORD *)(v10 + 108);
          if (sub_18BC62188((uint64_t)&v26) == 2)
          {
            v38 = 0;
            memset(&v36[1], 0, 48);
            v36[0] = (char *)&v36[1] + 5;
            LODWORD(v36[1]) = 40;
            v37 = 0;
            icu::StringPiece::StringPiece((icu::StringPiece *)&v24, *(const char **)(v11 + 32));
            icu::CharString::append((icu::CharString *)v36, v24, v25, a5);
            v19 = v32;
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8));
            v13 = *(_QWORD *)(v11 + 8);
            v14 = 2;
            while (v14 == 2 && *(_QWORD *)(v13 + 16))
            {
              v35 = 0;
              memset(&v33[1], 0, 48);
              v33[0] = (char *)&v33[1] + 5;
              LODWORD(v33[1]) = 40;
              v34 = 0;
              icu::CharString::copyFrom((const void **)v33, (const void **)v36, a5);
              v22 = 0;
              v23 = (char *)v33[0];
              v13 = *(_QWORD *)(v13 + 16);
              v15 = sub_18BC63030(v13 + 40, *(unsigned int *)(v13 + 72), &v23, &v22);
              if (v15 == -1)
              {
                v18 = 1;
                v14 = 2;
              }
              else
              {
                v27 = v13 + 40;
                LODWORD(v29) = v15;
                v14 = sub_18BC62188((uint64_t)&v26);
                if (v14 == 3)
                {
                  v16 = sub_18BC600EC(v27, v29, 0, 0xFFFFFFFF, v28, 0, 0, (uint64_t)v39, a5);
                  v37 = 0;
                  *(_BYTE *)v36[0] = 0;
                  icu::StringPiece::StringPiece((icu::StringPiece *)&v20, *(const char **)(v16 + 32));
                  icu::CharString::append((icu::CharString *)v36, v20, v21, a5);
                  v13 = *(_QWORD *)(v16 + 8);
                  v17 = *(_DWORD *)(v16 + 108);
                  v27 = v13 + 40;
                  LODWORD(v29) = v17;
                  v14 = sub_18BC62188((uint64_t)&v26);
                }
                if (v14 == 2)
                {
                  (*(void (**)(_QWORD, char *, void **, uint64_t, UErrorCode *))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), v19, &v26, a4, a5);
                  v18 = 1;
                }
                else
                {
                  v18 = 0;
                  *a5 = U_INTERNAL_PROGRAM_ERROR;
                }
              }
              if (BYTE4(v33[1]))
                uprv_free(v33[0]);
              if ((v18 & 1) == 0)
              {
                if (BYTE4(v36[1]))
                  uprv_free(v36[0]);
                icu::ResourceValue::~ResourceValue((icu::ResourceValue *)&v26);
                sub_18BC5C1BC(v39, 1);
                return;
              }
            }
            if (BYTE4(v36[1]))
              uprv_free(v36[0]);
          }
          else
          {
            (*(void (**)(_QWORD, char *, void **, uint64_t, UErrorCode *))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), v32, &v26, a4, a5);
          }
          icu::ResourceValue::~ResourceValue((icu::ResourceValue *)&v26);
        }
        sub_18BC5C1BC(v39, 1);
      }
      else
      {
        (*(void (**)(_QWORD, char *, icu::ResourceValue *, uint64_t, UErrorCode *))(**(_QWORD **)(a1 + 8)
                                                                                            + 24))(*(_QWORD *)(a1 + 8), v32, a3, a4, a5);
      }
      if (*(int *)a5 >= 1)
        break;
      ++v9;
    }
    while (icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v30, v9, (const char **)&v32, a3));
  }
}

void sub_18BC60AB4(int *a1)
{
  unsigned int v2;

  if (*a1 <= 0)
  {
    v2 = atomic_load(&dword_1ECD27CD8);
    if (v2 == 2 || !icu::umtx_initImplPreInit(&dword_1ECD27CD8))
    {
      if (dword_1ECD27CDC >= 1)
        *a1 = dword_1ECD27CDC;
    }
    else
    {
      qword_1ECD27CE0 = (uint64_t)uhash_open((uint64_t)sub_18BC616CC, (uint64_t)sub_18BC61704, 0, a1);
      sub_18BC0ECC4(0x1Cu, (uint64_t)sub_18BC61748);
      dword_1ECD27CDC = *a1;
      icu::umtx_initImplPostInit(&dword_1ECD27CD8);
    }
  }
}

const char **sub_18BC60B64(const char *a1, char *a2, const char *a3, int a4, BOOL *a5, _BYTE *a6, BOOL *a7, UErrorCode *a8)
{
  const char **v15;
  const char **v16;
  size_t v17;
  int v18;
  char *v19;
  size_t v20;
  char *v21;
  int v22;
  icu::CharString *v23;
  uint64_t v24;
  char *v25;
  _BOOL4 v26;
  uint64_t v27;
  const char *v28;
  int v29;
  icu::CharString *v30;
  _BOOL4 v31;
  icu::CharString *v32;
  icu::CharString *v33;
  const char *v34;
  int v35;
  icu::CharString *v37;
  icu::CharString *v38;
  char *v40;
  int v41;
  char *v42;
  int v43;
  UErrorCode v44;
  char *v45;
  int v46;
  char *v47;
  int v48;
  char *v49;
  UErrorCode v50;
  char __dst[16];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  _BYTE v59[29];
  char *v60;
  char v61;
  int v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 __s1;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  char *__src[7];
  uint64_t v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  const void *v77[6];
  __int128 v78;
  const char *v79[6];
  __int128 v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  *a6 = 1;
  v58 = 0u;
  memset(v59, 0, sizeof(v59));
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  *(_OWORD *)__dst = 0u;
  strcpy(__dst, a2);
  while (1)
  {
    v15 = (const char **)sub_18BC611C4(a2, a1, a8);
    if (*(int *)a8 > 0)
      return 0;
    v16 = v15;
    v17 = strlen(a2);
    *a7 = strncmp(a2, a3, v17) == 0;
    v18 = *((_DWORD *)v16 + 28);
    if (v18)
    {
      --*((_DWORD *)v16 + 27);
      v16 = 0;
      *a8 = U_USING_FALLBACK_WARNING;
    }
    else
    {
      strcpy(a2, *v16);
    }
    *a5 = strcmp(a2, "root") == 0;
    v19 = a2;
    if (!v18)
      break;
    v20 = strlen(a2);
    if (!v20 || a2[v20 - 1] == 95 || (LODWORD(v79[0]) = 0, uloc_getVariant(a2, 0, 0, (int *)v79)))
    {
      v19 = a2;
      break;
    }
    v50 = U_ZERO_ERROR;
    v49 = a2;
    v80 = 0u;
    memset(v79, 0, sizeof(v79));
    sub_18BC3BA38((uint64_t)a2, &v49, &v50, (uint64_t)v79);
    v23 = (icu::CharString *)v49;
    if (*v49 == 95)
      v23 = (icu::CharString *)++v49;
    v78 = 0u;
    memset(v77, 0, sizeof(v77));
    sub_18BC3BBB8(v23, &v49, &v50, (uint64_t)v77);
    v24 = (uint64_t)v49;
    if (*v49 == 95)
      v24 = (uint64_t)++v49;
    v75 = 0u;
    v76 = 0u;
    v73 = 0u;
    v74 = 0u;
    sub_18BC3BCC4(v24, (uint64_t *)&v49, &v50, (uint64_t)&v73);
    v72 = 0;
    memset(&__src[1], 0, 48);
    __src[0] = (char *)&__src[1] + 5;
    LODWORD(__src[1]) = 40;
    if (v50 >= U_ILLEGAL_ARGUMENT_ERROR)
    {
      v25 = strrchr(a2, 95);
      if (!v25)
        goto LABEL_39;
      *v25 = 0;
      goto LABEL_69;
    }
    if (!a4)
    {
      v27 = sub_18BC5C070(a2, (uint64_t)"ar_Latn", (uint64_t)"ar_Latn", dword_18BE15CF0, 714);
      if (v27)
      {
        v28 = (const char *)v27;
LABEL_68:
        strcpy(a2, v28);
LABEL_69:
        LOBYTE(v31) = 1;
        goto LABEL_70;
      }
    }
    if (DWORD2(v78))
    {
      if (DWORD2(v76))
      {
        sub_18BC61894((uint64_t)v79, (uint64_t)&v73, (uint64_t)&__s1);
        if (DWORD2(v70) == DWORD2(v78))
        {
          if (DWORD2(v78))
            v26 = memcmp((const void *)__s1, v77[0], SDWORD2(v78)) == 0;
          else
            v26 = 1;
        }
        else
        {
          v26 = 0;
        }
        if (BYTE12(__s1))
          uprv_free((void *)__s1);
        v38 = icu::CharString::append((icu::CharString *)__src, v79[0], SDWORD2(v80), &v50);
        if (v26)
        {
          icu::StringPiece::StringPiece((icu::StringPiece *)&v47, "_");
          v33 = icu::CharString::append(v38, v47, v48, &v50);
          v34 = (const char *)v73;
          v35 = DWORD2(v76);
        }
        else
        {
          icu::StringPiece::StringPiece((icu::StringPiece *)&v45, "_");
          v33 = icu::CharString::append(v38, v45, v46, &v50);
          v34 = (const char *)v77[0];
          v35 = DWORD2(v78);
        }
      }
      else
      {
        if (!a4)
        {
          *(_QWORD *)&v63 = (char *)&v63 + 13;
          DWORD2(v63) = 40;
          WORD6(v63) = 0;
          DWORD2(v66) = 0;
          sub_18BC61894((uint64_t)v79, (uint64_t)&v63, (uint64_t)&__s1);
          v31 = 0;
          if (DWORD2(v70) == DWORD2(v78))
          {
            if (DWORD2(v78))
              v31 = memcmp((const void *)__s1, v77[0], SDWORD2(v78)) == 0;
            else
              v31 = 1;
          }
          if (BYTE12(__s1))
            uprv_free((void *)__s1);
          if (BYTE12(v63))
            uprv_free((void *)v63);
          if (!v31)
            goto LABEL_70;
        }
        v34 = v79[0];
        v35 = DWORD2(v80);
        v33 = (icu::CharString *)__src;
      }
      icu::CharString::append(v33, v34, v35, &v50);
    }
    else
    {
      if (!DWORD2(v76))
      {
LABEL_39:
        LOBYTE(v31) = 0;
        goto LABEL_70;
      }
      v44 = U_ZERO_ERROR;
      v49 = __dst;
      v69 = 0u;
      v70 = 0u;
      __s1 = 0u;
      v68 = 0u;
      sub_18BC3BA38((uint64_t)__dst, &v49, &v44, (uint64_t)&__s1);
      if (*v49 == 95)
        ++v49;
      v65 = 0u;
      v66 = 0u;
      v63 = 0u;
      v64 = 0u;
      sub_18BC3BBB8((icu::CharString *)__dst, 0, &v44, (uint64_t)&v63);
      v29 = DWORD2(v66);
      v37 = icu::CharString::append((icu::CharString *)__src, v79[0], SDWORD2(v80), &v44);
      if (v29)
      {
        icu::StringPiece::StringPiece((icu::StringPiece *)&v42, "_");
        v30 = icu::CharString::append(v37, v42, v43, &v44);
        icu::CharString::append(v30, (const char *)v63, SDWORD2(v66), &v44);
      }
      else
      {
        icu::StringPiece::StringPiece((icu::StringPiece *)&v40, "_");
        v32 = icu::CharString::append(v37, v40, v41, &v44);
        sub_18BC61894((uint64_t)v79, (uint64_t)&v73, (uint64_t)&v60);
        icu::CharString::append(v32, v60, v62, &v44);
        if (v61)
          uprv_free(v60);
      }
      if (BYTE12(v63))
        uprv_free((void *)v63);
      if (BYTE12(__s1))
        uprv_free((void *)__s1);
    }
    LOBYTE(v31) = 0;
    if (v50 <= U_ZERO_ERROR && (_DWORD)v72)
    {
      v28 = __src[0];
      goto LABEL_68;
    }
LABEL_70:
    if (BYTE4(__src[1]))
      uprv_free(__src[0]);
    if (BYTE12(v73))
      uprv_free((void *)v73);
    if (BYTE4(v77[1]))
      uprv_free((void *)v77[0]);
    if (BYTE4(v79[1]))
      uprv_free((void *)v79[0]);
    *a6 = v31;
    if (v31)
      goto LABEL_13;
    v22 = 0;
LABEL_17:
    if (!v22)
      return v16;
  }
  v21 = strrchr(v19, 95);
  if (v21)
  {
    *v21 = 0;
    *a6 = 1;
LABEL_13:
    if (*a2)
    {
      v22 = 1;
      if (!v18)
        return v16;
    }
    else
    {
      *(_DWORD *)a2 = 6581877;
      v22 = *a6;
      if (!v18)
        return v16;
    }
    goto LABEL_17;
  }
  *a6 = 0;
  return v16;
}

void *sub_18BC611C4(const char *a1, const char *a2, UErrorCode *a3)
{
  void *result;
  const char *Default;
  char *v7;
  int v8;
  int v9;
  char *v10;
  char *v11;
  uint64_t v12;
  UErrorCode v13;
  uint64_t v14;
  unsigned int Resource;
  const UChar *StringNoTrace;
  uint64_t v17;
  char *v18;
  UErrorCode v19;
  int v20;
  _QWORD v21[2];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  char v29[16];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v35 = 0;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  *(_OWORD *)v29 = 0u;
  v30 = 0u;
  v20 = 0;
  if (*(int *)a3 > 0)
    return 0;
  if (a1)
  {
    if (*a1)
      Default = a1;
    else
      Default = "root";
  }
  else
  {
    Default = (const char *)uloc_getDefault(0);
  }
  v28 = 0;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v21[0] = Default;
  v21[1] = a2;
  v7 = (char *)uhash_get(qword_1ECD27CE0, (uint64_t)v21);
  if (v7)
    goto LABEL_10;
  result = uprv_malloc(0x78uLL);
  if (!result)
  {
    v8 = 7;
LABEL_18:
    *a3 = v8;
    return result;
  }
  v7 = (char *)result;
  *((_QWORD *)result + 14) = 0;
  *((_OWORD *)result + 5) = 0u;
  *((_OWORD *)result + 6) = 0u;
  *((_OWORD *)result + 3) = 0u;
  *((_OWORD *)result + 4) = 0u;
  *((_OWORD *)result + 1) = 0u;
  *((_OWORD *)result + 2) = 0u;
  *(_OWORD *)result = 0u;
  v9 = strlen(Default);
  if (v9 > 2)
  {
    v10 = (char *)uprv_malloc(v9 + 1);
    *(_QWORD *)v7 = v10;
    if (!v10)
    {
LABEL_23:
      *a3 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_27;
    }
  }
  else
  {
    v10 = v7 + 104;
    *(_QWORD *)v7 = v7 + 104;
  }
  strcpy(v10, Default);
  if (*(int *)a3 >= 1)
  {
LABEL_27:
    uprv_free(v7);
    return 0;
  }
  if (a2)
  {
    v11 = (char *)uprv_strdup(a2);
    *((_QWORD *)v7 + 1) = v11;
    if (!v11)
      goto LABEL_23;
  }
  else
  {
    v11 = (char *)*((_QWORD *)v7 + 1);
  }
  sub_18BC61E54(v7 + 40, v11, *(const char **)v7, a3);
  if (*(int *)a3 >= 1)
  {
    if (*a3 == U_MEMORY_ALLOCATION_ERROR)
      goto LABEL_27;
    v13 = U_USING_FALLBACK_WARNING;
    goto LABEL_37;
  }
  if (v7[98])
  {
    v12 = sub_18BC61A6C(*((_QWORD *)v7 + 1), (int *)a3);
    *((_QWORD *)v7 + 4) = v12;
    v13 = *a3;
    if (*(int *)a3 > 0)
    {
LABEL_38:
      *((_DWORD *)v7 + 28) = v13;
      goto LABEL_39;
    }
    v14 = *(_QWORD *)(v12 + 48);
    if (*(_DWORD *)(*((_QWORD *)v7 + 6) + 32) != *(_DWORD *)(v14 + 32))
    {
      v13 = U_INVALID_FORMAT_ERROR;
LABEL_37:
      *a3 = v13;
      goto LABEL_38;
    }
    *((_QWORD *)v7 + 8) = v14 + 4 + 4 * *(unsigned __int8 *)(v14 + 4);
    *((_QWORD *)v7 + 10) = *(_QWORD *)(v12 + 56);
  }
  Resource = res_getResource((uint64_t)(v7 + 40), "%%ALIAS");
  if (Resource != -1)
  {
    StringNoTrace = res_getStringNoTrace((uint64_t)(v7 + 40), Resource, &v20);
    if (StringNoTrace)
    {
      if (v20 >= 1)
      {
        u_UCharsToChars(StringNoTrace, v29, v20 + 1);
        *((_QWORD *)v7 + 3) = sub_18BC611C4(v29, a2, a3);
      }
    }
  }
LABEL_39:
  v17 = uhash_get(qword_1ECD27CE0, (uint64_t)v7);
  if (v17)
  {
    v18 = (char *)v17;
    sub_18BC61814(v7);
    v7 = v18;
    goto LABEL_10;
  }
  v19 = U_ZERO_ERROR;
  uhash_put(qword_1ECD27CE0, (uint64_t)v7, (uint64_t)v7, (int *)&v19);
  if (v19 >= U_ILLEGAL_ARGUMENT_ERROR)
  {
    *a3 = v19;
    sub_18BC61814(v7);
    return 0;
  }
  do
  {
LABEL_10:
    result = v7;
    v7 = (char *)*((_QWORD *)v7 + 3);
  }
  while (v7);
  v8 = *((_DWORD *)result + 28);
  ++*((_DWORD *)result + 27);
  if (v8 && *(int *)a3 <= 0)
    goto LABEL_18;
  return result;
}

uint64_t sub_18BC614C4(uint64_t *a1, char *a2, int *a3)
{
  uint64_t result;
  uint64_t v5;
  unsigned int Resource;
  const UChar *StringNoTrace;
  void *v11;
  char *v12;
  int v13;
  int v14;

  if (*a3 > 0)
    return 0;
  v5 = *a1;
  if (!*(_QWORD *)(*a1 + 16))
  {
    while (!*(_BYTE *)(v5 + 96) && res_getResource(v5 + 40, "%%ParentIsRoot") == -1)
    {
      Resource = res_getResource(*a1 + 40, "%%Parent");
      if (Resource != -1)
      {
        v14 = 0;
        StringNoTrace = res_getStringNoTrace(*a1 + 40, Resource, &v14);
        if (StringNoTrace && v14 >= 1 && v14 <= 156)
        {
          u_UCharsToChars(StringNoTrace, a2, v14 + 1);
          if (!strcmp(a2, "root"))
            break;
        }
      }
      v13 = 0;
      v11 = sub_18BC611C4(a2, *(const char **)(*a1 + 8), (UErrorCode *)&v13);
      if (v13 >= 1)
      {
        result = 0;
        *a3 = v13;
        return result;
      }
      *(_QWORD *)(*a1 + 16) = v11;
      *a1 = (uint64_t)v11;
      v12 = strrchr(a2, 95);
      if (v12)
      {
        *v12 = 0;
      }
      else if (!*a2 || !strstr("nb nn", a2))
      {
        return 1;
      }
      v5 = *a1;
      result = 1;
      if (*(_QWORD *)(*a1 + 16))
        return result;
    }
  }
  return 1;
}

uint64_t sub_18BC6164C(uint64_t a1, int *a2)
{
  uint64_t result;
  void *v5;
  int v6;

  if (*a2 > 0)
    return 0;
  v6 = 0;
  v5 = sub_18BC611C4("root", *(const char **)(*(_QWORD *)a1 + 8), (UErrorCode *)&v6);
  if (v6 < 1)
  {
    *(_QWORD *)(*(_QWORD *)a1 + 16) = v5;
    *(_QWORD *)a1 = v5;
    return 1;
  }
  else
  {
    result = 0;
    *a2 = v6;
  }
  return result;
}

uint64_t sub_18BC616CC(unsigned __int8 **a1)
{
  unsigned __int8 *v1;
  unsigned int v2;

  v1 = a1[1];
  v2 = uhash_hashChars(*a1);
  return v2 + 37 * uhash_hashChars(v1);
}

BOOL sub_18BC61704(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  _BOOL8 result;

  v2 = a1[1];
  v3 = a2[1];
  result = uhash_compareChars(*a1, *a2);
  if (result)
    return uhash_compareChars(v2, v3);
  return result;
}

uint64_t sub_18BC61748()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v5;

  if (qword_1ECD27CE0)
  {
    v5 = 0;
    umtx_lock((icu::UMutex *)&unk_1ECD27C88);
    if (qword_1ECD27CE0)
    {
      do
      {
        v5 = -1;
        v0 = uhash_nextElement((uint64_t *)qword_1ECD27CE0, &v5);
        if (!v0)
          break;
        v1 = v0;
        v2 = 0;
        do
        {
          v3 = *(_QWORD *)(v1 + 8);
          if (!*(_DWORD *)(v3 + 108))
          {
            uhash_removeElement(qword_1ECD27CE0, (_DWORD *)v1);
            sub_18BC61814((char *)v3);
            v2 = 1;
          }
          v1 = uhash_nextElement((uint64_t *)qword_1ECD27CE0, &v5);
        }
        while (v1);
      }
      while (v2);
    }
    umtx_unlock((std::mutex **)&unk_1ECD27C88);
    uhash_close((void **)qword_1ECD27CE0);
    qword_1ECD27CE0 = 0;
  }
  atomic_store(0, &dword_1ECD27CD8);
  return 1;
}

void sub_18BC61814(char *a1)
{
  char *v2;
  BOOL v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_18BC61EDC((_OWORD **)a1 + 5);
  v2 = *(char **)a1;
  if (*(_QWORD *)a1)
    v3 = v2 == a1 + 104;
  else
    v3 = 1;
  if (!v3)
    uprv_free(v2);
  v4 = (void *)*((_QWORD *)a1 + 1);
  if (v4)
    uprv_free(v4);
  v5 = *((_QWORD *)a1 + 4);
  if (v5)
    --*(_DWORD *)(v5 + 108);
  v6 = *((_QWORD *)a1 + 3);
  if (v6)
  {
    do
    {
      v7 = v6;
      v6 = *(_QWORD *)(v6 + 24);
    }
    while (v6);
    --*(_DWORD *)(v7 + 108);
  }
  uprv_free(a1);
}

void sub_18BC61894(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char *v6;
  int v7;
  icu::CharString *v8;
  icu::CharString *v9;
  const char *v10;
  UErrorCode v11;
  char *v12;
  int v13;
  char *v14;
  int v15;
  char *v16;
  int v17;
  UErrorCode v18;
  char *__s1[9];

  __s1[8] = *(char **)MEMORY[0x1E0C80C00];
  v18 = U_ZERO_ERROR;
  *(_OWORD *)(a3 + 8) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_QWORD *)(a3 + 56) = 0;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v16, "Latn");
  v6 = v16;
  v7 = v17;
  *(_QWORD *)a3 = a3 + 13;
  *(_DWORD *)(a3 + 8) = 40;
  *(_WORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  icu::CharString::append((icu::CharString *)a3, v6, v7, &v18);
  if (!*(_DWORD *)(a2 + 56))
    goto LABEL_8;
  memset(&__s1[1], 0, 56);
  __s1[0] = (char *)&__s1[1] + 5;
  LODWORD(__s1[1]) = 40;
  v8 = icu::CharString::append((icu::CharString *)__s1, *(const char **)a1, *(_DWORD *)(a1 + 56), &v18);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v14, "_");
  v9 = icu::CharString::append(v8, v14, v15, &v18);
  icu::CharString::append(v9, *(const char **)a2, *(_DWORD *)(a2 + 56), &v18);
  v10 = 0;
  v11 = v18;
  if (v18 <= U_ZERO_ERROR)
    v10 = (const char *)sub_18BC5C070(__s1[0], (uint64_t)&unk_18BE1683D, (uint64_t)"Aghb", dword_18BE17AD0, 2052);
  if (BYTE4(__s1[1]))
    uprv_free(__s1[0]);
  if (v11 <= U_ZERO_ERROR)
  {
    if (v10)
    {
LABEL_9:
      *(_DWORD *)(a3 + 56) = 0;
      **(_BYTE **)a3 = 0;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v12, v10);
      icu::CharString::append((icu::CharString *)a3, v12, v13, &v18);
      return;
    }
LABEL_8:
    v10 = (const char *)sub_18BC5C070(*(char **)a1, (uint64_t)&unk_18BE1683D, (uint64_t)"Aghb", dword_18BE17AD0, 2052);
    if (!v10)
      return;
    goto LABEL_9;
  }
}

uint64_t sub_18BC61A6C(uint64_t a1, int *a2)
{
  uint64_t result;

  result = sub_18BC611C4("pool", a1, a2);
  if (*a2 <= 0 && (!result || *(_DWORD *)(result + 112) || !*(_BYTE *)(result + 97)))
    *a2 = 3;
  return result;
}

void sub_18BC61AC8(_QWORD *a1)
{
  _QWORD *v2;

  v2 = (_QWORD *)a1[1];
  sub_18BC5C1BC(v2 + 17, 1);
  sub_18BC5C1BC(v2, 1);
  uprv_free(v2);
  uprv_free(a1);
}

uint64_t sub_18BC61B0C(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
    return *(unsigned int *)(v1 + 128);
  else
    return 0;
}

const char *sub_18BC61B24(uint64_t a1, _DWORD *a2, int *a3)
{
  char *NextResource;
  const char *v5;

  NextResource = *(char **)(a1 + 8);
  if (NextResource)
  {
    if (*((_DWORD *)NextResource + 31) >= *((_DWORD *)NextResource + 32) - 1)
    {
      v5 = 0;
      LODWORD(NextResource) = 0;
      if (!a2)
        return v5;
      goto LABEL_7;
    }
    NextResource = ures_getNextResource((uint64_t)NextResource, NextResource + 136, a3);
    if (NextResource)
    {
      v5 = *(const char **)NextResource;
      LODWORD(NextResource) = strlen(*(const char **)NextResource);
      if (!a2)
        return v5;
      goto LABEL_7;
    }
  }
  v5 = 0;
  if (a2)
LABEL_7:
    *a2 = (_DWORD)NextResource;
  return v5;
}

uint64_t sub_18BC61B98(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 8);
  if (v1)
    *(_DWORD *)(v1 + 124) = -1;
  return result;
}

void res_read(_OWORD *a1, unsigned __int16 *a2, unsigned int *a3, unsigned int a4, int *a5)
{
  int v9;

  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  if (*a5 <= 0)
  {
    v9 = 0;
    if (sub_18BC61C34(&v9, (uint64_t)a2, (uint64_t)a3, a2))
      sub_18BC61CB0((uint64_t)a1, (unsigned __int8 *)&v9, a3, a4, a5);
    else
      *a5 = 3;
  }
}

BOOL sub_18BC61C34(_DWORD *a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4)
{
  *a1 = *((_DWORD *)a4 + 3);
  return *a4 >= 0x14u
      && !*((_BYTE *)a4 + 4)
      && !*((_BYTE *)a4 + 5)
      && *((_BYTE *)a4 + 6) == 2
      && *((_BYTE *)a4 + 8) == 82
      && *((_BYTE *)a4 + 9) == 101
      && *((_BYTE *)a4 + 10) == 115
      && *((_BYTE *)a4 + 11) == 66
      && *((unsigned __int8 *)a4 + 12) - 1 < 3;
}

void sub_18BC61CB0(uint64_t a1, unsigned __int8 *a2, unsigned int *a3, unsigned int a4, _DWORD *a5)
{
  unsigned int v6;
  unsigned int v7;
  unsigned int v9;
  unsigned int v10;
  signed int v11;
  unsigned int v12;
  _OWORD *v13;
  uint64_t v14;

  v6 = *a3;
  *(_DWORD *)(a1 + 32) = *a3;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = &unk_18BE19B3A;
  if ((a4 & 0x80000000) == 0)
  {
    v7 = 6;
    if (*a2 == 1)
    {
      if (a2[1])
        v7 = 6;
      else
        v7 = 1;
    }
    if (a4 >> 2 < v7)
      goto LABEL_34;
  }
  if (v6 >> 28 != 2 && (v6 & 0xE0000000) != 0x40000000)
    goto LABEL_34;
  v9 = *a2;
  if (v9 == 1 && !a2[1])
  {
    *(_DWORD *)(a1 + 36) = 0x10000;
    goto LABEL_29;
  }
  v10 = *((unsigned __int8 *)a3 + 4);
  if (v10 > 4 && ((a4 & 0x80000000) != 0 || 4 * v10 + 4 <= a4 && (int)a4 >= (int)(4 * a3[4])))
  {
    v11 = a3[2];
    if (v11 > (int)(v10 + 1))
    {
      *(_DWORD *)(a1 + 36) = 4 * v11;
      v9 = *a2;
    }
    if (v9 >= 3)
      *(_DWORD *)(a1 + 48) = a3[1] >> 8;
    if (v10 < 6)
    {
      if (!*(_BYTE *)(a1 + 57) && !*(_BYTE *)(a1 + 58))
        goto LABEL_29;
    }
    else
    {
      v12 = a3[6];
      *(_BYTE *)(a1 + 56) = v12 & 1;
      *(_BYTE *)(a1 + 57) = (v12 & 2) != 0;
      *(_BYTE *)(a1 + 58) = (v12 & 4) != 0;
      *(_DWORD *)(a1 + 48) |= (v12 << 12) & 0xF000000;
      *(_DWORD *)(a1 + 52) = HIWORD(v12);
      if (((v12 >> 1) & 1) != 0)
      {
        if (v10 > 7)
          goto LABEL_37;
      }
      else if (v10 > 7 || ((v12 >> 2) & 1) == 0)
      {
        if (v10 >= 7)
        {
LABEL_37:
          v14 = (int)a3[2];
          if ((int)a3[7] > (int)v14)
            *(_QWORD *)(a1 + 16) = &a3[v14];
        }
LABEL_29:
        *(_BYTE *)(a1 + 59) = 1;
        return;
      }
    }
  }
LABEL_34:
  *a5 = 3;
  v13 = *(_OWORD **)a1;
  if (*(_QWORD *)a1)
  {
    udata_close(v13);
    *(_QWORD *)a1 = 0;
  }
}

void sub_18BC61E54(_OWORD *a1, char *a2, const char *a3, UErrorCode *a4)
{
  _QWORD *v6;
  unsigned int *Memory;
  int v8;

  v8 = 0;
  *a1 = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  v6 = udata_openChoice(a2, "res", a3, (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18BC61C34, (uint64_t)&v8, a4);
  *(_QWORD *)a1 = v6;
  if (*(int *)a4 <= 0)
  {
    Memory = (unsigned int *)udata_getMemory((uint64_t)v6);
    sub_18BC61CB0((uint64_t)a1, (unsigned __int8 *)&v8, Memory, 0xFFFFFFFF, a4);
  }
}

void sub_18BC61EDC(_OWORD **a1)
{
  _OWORD *v2;

  v2 = *a1;
  if (v2)
  {
    udata_close(v2);
    *a1 = 0;
  }
}

uint64_t res_getPublicType(unsigned int a1)
{
  return byte_18BE19AFE[(unint64_t)a1 >> 28];
}

const UChar *res_getStringNoTrace(uint64_t a1, unsigned int a2, int *a3)
{
  int v4;
  BOOL v5;
  uint64_t v6;
  const UChar *v7;
  unsigned int v8;
  int v9;
  int *v10;
  int v11;

  if (a2 >> 28 == 6)
  {
    v4 = *(_DWORD *)(a1 + 48);
    v5 = (int)(a2 & 0xFFFFFFF) < v4;
    if ((int)(a2 & 0xFFFFFFF) < v4)
      v4 = 0;
    v6 = 16;
    if (v5)
      v6 = 40;
    v7 = (const UChar *)(*(_QWORD *)(a1 + v6) + 2 * ((a2 & 0xFFFFFFF) - v4));
    v8 = *v7;
    if ((v8 & 0xFC00) == 0xDC00)
    {
      if (v8 > 0xDFEE)
      {
        if (v8 > 0xDFFE)
        {
          v9 = v7[2] | (v7[1] << 16);
          v7 += 3;
          if (!a3)
            return v7;
        }
        else
        {
          v9 = (v7[1] | (v8 << 16)) + 537985024;
          v7 += 2;
          if (!a3)
            return v7;
        }
      }
      else
      {
        v9 = v8 & 0x3FF;
        ++v7;
        if (!a3)
          return v7;
      }
    }
    else
    {
      v9 = u_strlen(v7);
      if (!a3)
        return v7;
    }
    goto LABEL_22;
  }
  if (a2 >> 28)
  {
    v7 = 0;
    v9 = 0;
    if (!a3)
      return v7;
    goto LABEL_22;
  }
  if (a2)
    v10 = (int *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  else
    v10 = &dword_18BE19B10;
  v11 = *v10;
  v7 = (const UChar *)(v10 + 1);
  v9 = v11;
  if (a3)
LABEL_22:
    *a3 = v9;
  return v7;
}

int *res_getAlias(uint64_t a1, unsigned int a2, int *a3)
{
  int *v3;
  int *result;
  int v5;
  int v6;

  if (a2 >> 28 == 3)
  {
    if ((a2 & 0xFFFFFFF) != 0)
      v3 = (int *)(*(_QWORD *)(a1 + 8) + 4 * (a2 & 0xFFFFFFF));
    else
      v3 = &dword_18BE19B10;
    v6 = *v3;
    result = v3 + 1;
    v5 = v6;
    if (a3)
      goto LABEL_8;
  }
  else
  {
    result = 0;
    v5 = 0;
    if (a3)
LABEL_8:
      *a3 = v5;
  }
  return result;
}

int *res_getBinaryNoTrace(uint64_t a1, unsigned int a2, int *a3)
{
  int *v3;
  int *result;
  int v5;
  int v6;

  if (a2 >> 28 == 1)
  {
    if ((a2 & 0xFFFFFFF) != 0)
      v3 = (int *)(*(_QWORD *)(a1 + 8) + 4 * (a2 & 0xFFFFFFF));
    else
      v3 = &dword_18BE19B18;
    v6 = *v3;
    result = v3 + 1;
    v5 = v6;
    if (a3)
      goto LABEL_8;
  }
  else
  {
    result = 0;
    v5 = 0;
    if (a3)
LABEL_8:
      *a3 = v5;
  }
  return result;
}

int *res_getIntVectorNoTrace(uint64_t a1, unsigned int a2, int *a3)
{
  int *v3;
  int *result;
  int v5;
  int v6;

  if (a2 >> 28 == 14)
  {
    if ((a2 & 0xFFFFFFF) != 0)
      v3 = (int *)(*(_QWORD *)(a1 + 8) + 4 * (a2 & 0xFFFFFFF));
    else
      v3 = &dword_18BE19B18;
    v6 = *v3;
    result = v3 + 1;
    v5 = v6;
    if (a3)
      goto LABEL_8;
  }
  else
  {
    result = 0;
    v5 = 0;
    if (a3)
LABEL_8:
      *a3 = v5;
  }
  return result;
}

uint64_t res_countArrayItems(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  uint64_t result;

  v3 = a2 & 0xFFFFFFF;
  result = 1;
  switch(a2 >> 28)
  {
    case 0u:
    case 1u:
    case 3u:
    case 6u:
    case 7u:
    case 0xEu:
      return result;
    case 2u:
      if (!v3)
        goto LABEL_7;
      result = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 4 * (a2 & 0xFFFFFFF));
      break;
    case 4u:
    case 8u:
      if (!v3)
        goto LABEL_7;
      result = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v3);
      break;
    case 5u:
    case 9u:
      result = *(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 2 * v3);
      break;
    default:
LABEL_7:
      result = 0;
      break;
  }
  return result;
}

void sub_18BC62174(icu::ResourceValue *a1)
{
  void *v1;

  icu::ResourceValue::~ResourceValue(a1);
  icu::UMemory::operator delete(v1);
}

uint64_t sub_18BC62188(uint64_t a1)
{
  return byte_18BE19AFE[(unint64_t)*(unsigned int *)(a1 + 24) >> 28];
}

const UChar *sub_18BC621A0(uint64_t a1, int *a2, int *a3)
{
  const UChar *result;

  if (*a3 > 0)
    return 0;
  result = res_getStringNoTrace(*(_QWORD *)(a1 + 8), *(_DWORD *)(a1 + 24), a2);
  if (!result)
    *a3 = 17;
  return result;
}

int *sub_18BC621F0(uint64_t a1, int *a2, int *a3)
{
  int *result;
  unsigned int v4;
  uint64_t v5;
  int *v6;
  int v7;

  if (*a3 > 0)
    return 0;
  v4 = *(_DWORD *)(a1 + 24);
  if (v4 >> 28 == 3)
  {
    v5 = v4 & 0xFFFFFFF;
    if ((_DWORD)v5)
      v6 = (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + 4 * v5);
    else
      v6 = &dword_18BE19B10;
    v7 = *v6;
    result = v6 + 1;
    *a2 = v7;
  }
  else
  {
    result = 0;
    *a2 = 0;
    *a3 = 17;
  }
  return result;
}

uint64_t sub_18BC62254(uint64_t a1, int *a2)
{
  unsigned int v3;

  if (*a2 > 0)
    return 0;
  v3 = *(_DWORD *)(a1 + 24);
  if (v3 >> 28 != 7)
    *a2 = 17;
  return ((int)(16 * v3) >> 4);
}

uint64_t sub_18BC62288(uint64_t a1, int *a2)
{
  unsigned int v3;

  if (*a2 > 0)
    return 0;
  v3 = *(_DWORD *)(a1 + 24);
  if (v3 >> 28 != 7)
    *a2 = 17;
  return v3 & 0xFFFFFFF;
}

int *sub_18BC622BC(uint64_t a1, int *a2, int *a3)
{
  int *result;
  unsigned int v4;
  uint64_t v5;
  int *v6;
  int v7;

  if (*a3 > 0)
    return 0;
  v4 = *(_DWORD *)(a1 + 24);
  if (v4 >> 28 == 14)
  {
    v5 = v4 & 0xFFFFFFF;
    if ((_DWORD)v5)
      v6 = (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + 4 * v5);
    else
      v6 = &dword_18BE19B18;
    v7 = *v6;
    result = v6 + 1;
    *a2 = v7;
  }
  else
  {
    result = 0;
    *a2 = 0;
    *a3 = 17;
  }
  return result;
}

int *sub_18BC62320(uint64_t a1, int *a2, int *a3)
{
  int *result;
  unsigned int v4;
  uint64_t v5;
  int *v6;
  int v7;

  if (*a3 > 0)
    return 0;
  v4 = *(_DWORD *)(a1 + 24);
  if (v4 >> 28 == 1)
  {
    v5 = v4 & 0xFFFFFFF;
    if ((_DWORD)v5)
      v6 = (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + 4 * v5);
    else
      v6 = &dword_18BE19B18;
    v7 = *v6;
    result = v6 + 1;
    *a2 = v7;
  }
  else
  {
    result = 0;
    *a2 = 0;
    *a3 = 17;
  }
  return result;
}

uint64_t sub_18BC62384@<X0>(uint64_t result@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  unsigned __int16 *v6;
  int *v7;
  _DWORD *v8;
  int v9;
  unsigned __int16 *v10;
  int v11;

  if (*a2 >= 1)
    goto LABEL_2;
  v3 = *(_DWORD *)(result + 24);
  v4 = v3 & 0xFFFFFFF;
  v5 = v3 >> 28;
  if (v5 == 9)
  {
    v8 = 0;
    v10 = (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(result + 8) + 16) + 2 * v4);
    v11 = *v10;
    v6 = v10 + 1;
    LODWORD(v4) = v11;
  }
  else
  {
    if (v5 != 8)
    {
      *a2 = 17;
LABEL_2:
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_DWORD *)(a3 + 16) = 0;
      return result;
    }
    v6 = 0;
    if ((_DWORD)v4)
    {
      v7 = (int *)(*(_QWORD *)(*(_QWORD *)(result + 8) + 8) + 4 * v4);
      v9 = *v7;
      v8 = v7 + 1;
      LODWORD(v4) = v9;
    }
    else
    {
      v8 = 0;
    }
  }
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v8;
  *(_DWORD *)(a3 + 16) = v4;
  return result;
}

uint64_t sub_18BC62408@<X0>(uint64_t result@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  int *v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;
  int *v14;
  uint64_t v15;

  if (*a2 >= 1)
  {
    *(_DWORD *)(a3 + 32) = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    return result;
  }
  v3 = *(_DWORD *)(result + 24);
  v4 = v3 & 0xFFFFFFF;
  v5 = v3 >> 28;
  if (v5 == 5)
  {
    v6 = 0;
    v11 = 0;
    v12 = (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(result + 8) + 16) + 2 * v4);
    v13 = *v12;
    v9 = v12 + 1;
    LODWORD(v4) = v13;
    v7 = &v9[v13];
    goto LABEL_13;
  }
  if (v5 == 4)
  {
    if ((_DWORD)v4)
    {
      v9 = 0;
      v7 = 0;
      v14 = (int *)(*(_QWORD *)(*(_QWORD *)(result + 8) + 8) + 4 * v4);
      v15 = *v14;
      v6 = v14 + 1;
      LODWORD(v4) = v15;
      v11 = (uint64_t)&v6[v15];
      goto LABEL_13;
    }
LABEL_12:
    v9 = 0;
    v6 = 0;
    v7 = 0;
    v11 = 0;
    goto LABEL_13;
  }
  if (v5 != 2)
  {
    *a2 = 17;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)(a3 + 32) = 0;
    return result;
  }
  if (!(_DWORD)v4)
    goto LABEL_12;
  v6 = 0;
  v7 = 0;
  v8 = (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(result + 8) + 8) + 4 * v4);
  v10 = *v8;
  v9 = v8 + 1;
  LODWORD(v4) = v10;
  v11 = (uint64_t)&v9[v10 + ((v10 & 1) == 0)];
LABEL_13:
  *(_QWORD *)a3 = v9;
  *(_QWORD *)(a3 + 8) = v6;
  *(_QWORD *)(a3 + 16) = v7;
  *(_QWORD *)(a3 + 24) = v11;
  *(_DWORD *)(a3 + 32) = v4;
  return result;
}

BOOL sub_18BC624F4(uint64_t a1)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  unsigned __int16 *v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  _BOOL8 result;

  v1 = *(unsigned int *)(a1 + 24);
  v2 = v1 & 0xFFFFFFF;
  if ((v1 & 0xFFFFFFF) == 0)
    return 0;
  v3 = *(_QWORD *)(a1 + 8);
  if (!(v1 >> 28))
  {
    v4 = *(_QWORD *)(v3 + 8) + 4 * v1;
    if (*(_DWORD *)v4 == 3)
    {
      v5 = 8709;
      if (*(_WORD *)(v4 + 4) == 8709 && *(_WORD *)(v4 + 6) == 8709)
      {
        v6 = (unsigned __int16 *)(v4 + 8);
        return *v6 == v5;
      }
    }
    return 0;
  }
  if (v1 >> 28 != 6)
    return 0;
  v7 = *(_DWORD *)(v3 + 48);
  v8 = v2 < v7;
  if (v2 < v7)
    v7 = 0;
  v9 = 16;
  if (v8)
    v9 = 40;
  v10 = (unsigned __int16 *)(*(_QWORD *)(v3 + v9) + 2 * (v2 - v7));
  v11 = *v10;
  if (v11 == 56323)
  {
    v5 = 8709;
    if (v10[1] == 8709 && v10[2] == 8709)
      goto LABEL_19;
    return 0;
  }
  result = 0;
  if (v11 == 8709)
  {
    if (v10[1] == 8709 && v10[2] == 8709)
    {
      v5 = 0;
LABEL_19:
      v6 = v10 + 3;
      return *v6 == v5;
    }
    return 0;
  }
  return result;
}

uint64_t sub_18BC625E8(_QWORD *a1, icu::UnicodeString *a2, int a3, int *a4)
{
  uint64_t v7;
  _QWORD v9[3];

  v7 = a1[1];
  (*(void (**)(_QWORD *__return_ptr, _QWORD *, int *))(*a1 + 80))(v9, a1, a4);
  return sub_18BC62648(v7, (uint64_t)v9, a2, a3, a4);
}

uint64_t sub_18BC62648(uint64_t a1, uint64_t a2, icu::UnicodeString *a3, int a4, int *a5)
{
  uint64_t v5;
  icu::UnicodeString *v7;
  int v10;
  uint64_t v12;
  int v13;
  int v14;
  BOOL v15;
  int v16;
  unsigned int v17;
  const UChar *StringNoTrace;
  const UChar *v19;
  int v20;

  if (*a5 <= 0)
  {
    v7 = a3;
    if (a3)
    {
      if ((a4 & 0x80000000) == 0)
      {
LABEL_5:
        v5 = *(unsigned int *)(a2 + 16);
        if (!(_DWORD)v5)
          return v5;
        if ((int)v5 <= a4)
        {
          if ((int)v5 < 1)
            return v5;
          v12 = 0;
          while (1)
          {
            v20 = 0;
            if (*(_QWORD *)a2)
            {
              v13 = *(unsigned __int16 *)(*(_QWORD *)a2 + 2 * v12);
              v14 = *(_DWORD *)(a1 + 52);
              v15 = __OFSUB__(v13, v14);
              v16 = v13 - v14;
              if (v16 < 0 == v15)
                v13 = v16 + *(_DWORD *)(a1 + 48);
              v17 = v13 | 0x60000000;
            }
            else
            {
              v17 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4 * v12);
            }
            StringNoTrace = res_getStringNoTrace(a1, v17, &v20);
            if (!StringNoTrace)
              break;
            v19 = StringNoTrace;
            icu::UnicodeString::setTo(v7, 1, &v19, v20);
            ++v12;
            v7 = (icu::UnicodeString *)((char *)v7 + 64);
            if (v5 == v12)
              return v5;
          }
          v5 = 0;
          v10 = 17;
        }
        else
        {
          v10 = 15;
        }
LABEL_10:
        *a5 = v10;
        return v5;
      }
    }
    else if (!a4)
    {
      goto LABEL_5;
    }
    v5 = 0;
    v10 = 1;
    goto LABEL_10;
  }
  return 0;
}

uint64_t sub_18BC6276C(uint64_t a1, icu::UnicodeString *a2, int a3, int *a4)
{
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  const UChar *StringNoTrace;
  int v11;
  const UChar *v13;
  _QWORD v14[3];

  v7 = *(_DWORD *)(a1 + 24);
  if ((v7 & 0xFFFFFFFE) != 8)
  {
    if (*a4 > 0)
      return 0;
    if (a2)
    {
      if ((a3 & 0x80000000) == 0)
      {
        if (a3)
        {
          LODWORD(v14[0]) = 0;
          StringNoTrace = res_getStringNoTrace(*(_QWORD *)(a1 + 8), v7, (int *)v14);
          if (StringNoTrace)
          {
            v13 = StringNoTrace;
            v9 = 1;
            icu::UnicodeString::setTo(a2, 1, &v13, v14[0]);
            return v9;
          }
          v9 = 0;
          v11 = 17;
LABEL_12:
          *a4 = v11;
          return v9;
        }
LABEL_13:
        *a4 = 15;
        return 1;
      }
    }
    else if (!a3)
    {
      goto LABEL_13;
    }
    v9 = 0;
    v11 = 1;
    goto LABEL_12;
  }
  v8 = *(_QWORD *)(a1 + 8);
  (*(void (**)(_QWORD *__return_ptr, uint64_t, int *))(*(_QWORD *)a1 + 80))(v14, a1, a4);
  return sub_18BC62648(v8, (uint64_t)v14, a2, a3, a4);
}

icu::UnicodeString *sub_18BC62874@<X0>(icu::UnicodeString *result@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  icu::UnicodeString *v5;
  const UChar *StringNoTrace;
  uint64_t v7;
  int v8;
  int v9;
  BOOL v10;
  int v11;
  unsigned int v12;
  const UChar *v13;
  unsigned __int16 *v14;
  unsigned int *v15;
  uint64_t v16;
  const UChar *v17;
  int v18;

  *(_OWORD *)(a3 + 8) = 0u;
  *(_QWORD *)(a3 + 56) = 0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_QWORD *)a3 = off_1E2256B38;
  *(_WORD *)(a3 + 8) = 2;
  if (*a2 <= 0)
  {
    v5 = result;
    v18 = 0;
    StringNoTrace = res_getStringNoTrace(*((_QWORD *)result + 1), *((_DWORD *)result + 6), &v18);
    if (StringNoTrace)
    {
      v17 = StringNoTrace;
      return icu::UnicodeString::setTo((icu::UnicodeString *)a3, 1, &v17, v18);
    }
    else
    {
      v14 = 0;
      v15 = 0;
      v16 = 0;
      result = (icu::UnicodeString *)(*(_QWORD *(**)(unsigned __int16 **__return_ptr, icu::UnicodeString *, int *))(*(_QWORD *)v5 + 80))(&v14, v5, a2);
      if (*a2 <= 0)
      {
        if ((int)v16 < 1)
          goto LABEL_13;
        v7 = *((_QWORD *)v5 + 1);
        if (v14)
        {
          v8 = *v14;
          v9 = *(_DWORD *)(v7 + 52);
          v10 = __OFSUB__(v8, v9);
          v11 = v8 - v9;
          if (v11 < 0 == v10)
            v8 = v11 + *(_DWORD *)(v7 + 48);
          v12 = v8 | 0x60000000;
        }
        else
        {
          v12 = *v15;
        }
        result = (icu::UnicodeString *)res_getStringNoTrace(v7, v12, &v18);
        if (result)
        {
          v13 = (const UChar *)result;
          return icu::UnicodeString::setTo((icu::UnicodeString *)a3, 1, &v13, v18);
        }
        else
        {
LABEL_13:
          *a2 = 17;
        }
      }
    }
  }
  return result;
}

uint64_t icu::ResourceArray::internalGetResource(_QWORD *a1, uint64_t a2, int a3)
{
  int v3;
  int v4;
  BOOL v5;
  int v6;

  if (!*a1)
    return *(unsigned int *)(a1[1] + 4 * a3);
  v3 = *(unsigned __int16 *)(*a1 + 2 * a3);
  v4 = *(_DWORD *)(a2 + 52);
  v5 = __OFSUB__(v3, v4);
  v6 = v3 - v4;
  if (v6 < 0 == v5)
    v3 = v6 + *(_DWORD *)(a2 + 48);
  return v3 | 0x60000000u;
}

uint64_t res_getTableItemByKey(uint64_t a1, unsigned int a2, unsigned int *a3, const char **a4)
{
  char *v5;
  unsigned int v8;
  unsigned int v9;
  unsigned __int16 *v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unsigned __int16 *v16;
  uint64_t v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;
  BOOL v23;
  int v24;
  int *v25;
  uint64_t v26;
  int v27;
  int v28;
  unsigned int v29;

  if (!a4)
    return 0xFFFFFFFFLL;
  v5 = (char *)*a4;
  if (!v5)
    return 0xFFFFFFFFLL;
  v8 = a2 & 0xFFFFFFF;
  v9 = a2 >> 28;
  if (a2 >> 28 != 5)
  {
    if (v9 == 4)
    {
      if (v8)
      {
        v25 = (int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
        v28 = *v25;
        v26 = (uint64_t)(v25 + 1);
        v27 = v28;
        v29 = sub_18BC62BE0(a1, v26, v28, v5, a4);
        *a3 = v29;
        if ((v29 & 0x80000000) == 0)
          return *(unsigned int *)(v26 + 4 * (int)(v29 + v27));
      }
    }
    else if (v9 == 2)
    {
      if (v8)
      {
        v10 = (unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 4 * v8);
        v13 = *v10;
        v12 = (uint64_t)(v10 + 1);
        v11 = v13;
        v14 = sub_18BC62B1C(a1, v12, v13, v5, a4);
        *a3 = v14;
        if ((v14 & 0x80000000) == 0)
          return *(unsigned int *)(v12 + 2 * v11 + 2 * ((v11 & 1) == 0) + 4 * v14);
      }
    }
    return 0xFFFFFFFFLL;
  }
  v16 = (unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 2 * v8);
  v19 = *v16;
  v17 = (uint64_t)(v16 + 1);
  v18 = v19;
  v20 = sub_18BC62B1C(a1, v17, v19, v5, a4);
  *a3 = v20;
  if ((v20 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v21 = *(unsigned __int16 *)(v17 + 2 * (v20 + v18));
  v22 = *(_DWORD *)(a1 + 52);
  v23 = __OFSUB__(v21, v22);
  v24 = v21 - v22;
  if (v24 < 0 == v23)
    v21 = v24 + *(_DWORD *)(a1 + 48);
  return v21 | 0x60000000u;
}

uint64_t sub_18BC62B1C(uint64_t a1, uint64_t a2, int a3, char *__s1, _QWORD *a5)
{
  int v7;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;

  if (a3 >= 1)
  {
    v7 = a3;
    v10 = 0;
    v11 = *(int *)(a1 + 36);
    do
    {
      v12 = v7 + v10;
      if (v7 + v10 < 0 != __OFADD__(v7, v10))
        ++v12;
      v13 = (v12 >> 1);
      v14 = *(unsigned __int16 *)(a2 + 2 * (int)v13);
      if ((int)v11 <= (int)v14)
        v15 = *(_QWORD *)(a1 + 24) - v11;
      else
        v15 = *(_QWORD *)(a1 + 8);
      v16 = v15 + v14;
      v17 = strcmp(__s1, (const char *)(v15 + v14));
      if (v17 < 0)
      {
        v7 = v13;
      }
      else
      {
        if (!v17)
        {
          *a5 = v16;
          return v13;
        }
        v10 = v13 + 1;
      }
    }
    while (v10 < v7);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_18BC62BE0(uint64_t a1, uint64_t a2, int a3, char *__s1, const char **a5)
{
  int v7;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  int v17;

  if (a3 >= 1)
  {
    v7 = a3;
    v10 = 0;
    do
    {
      v11 = v7 + v10;
      if (v7 + v10 < 0 != __OFADD__(v7, v10))
        ++v11;
      v12 = (v11 >> 1);
      v13 = *(_DWORD *)(a2 + 4 * (int)v12);
      v14 = v13 & 0x7FFFFFFF;
      if (v13 >= 0)
        v15 = 8;
      else
        v15 = 24;
      v16 = (const char *)(*(_QWORD *)(a1 + v15) + v14);
      v17 = strcmp(__s1, v16);
      if (v17 < 0)
      {
        v7 = v12;
      }
      else
      {
        if (!v17)
        {
          *a5 = v16;
          return v12;
        }
        v10 = v12 + 1;
      }
    }
    while (v10 < v7);
  }
  return 0xFFFFFFFFLL;
}

uint64_t res_getTableItemByIndex(uint64_t a1, unsigned int a2, unsigned int a3, _QWORD *a4)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;
  unsigned __int16 *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  _DWORD *v24;
  int v25;
  int v26;
  unsigned int v27;
  int v29;
  int v30;
  BOOL v31;
  int v32;

  if ((a3 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v4 = a2 & 0xFFFFFFF;
  v5 = a2 >> 28;
  if (a2 >> 28 == 5)
  {
    v15 = (unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 2 * v4);
    v18 = *v15;
    v16 = v15 + 1;
    v17 = v18;
    if (v18 <= a3)
      return 0xFFFFFFFFLL;
    if (a4)
    {
      v19 = v16[a3];
      v20 = *(int *)(a1 + 36);
      if ((int)v20 <= (int)v19)
        v21 = *(_QWORD *)(a1 + 24) + v19 - v20;
      else
        v21 = *(_QWORD *)(a1 + 8) + v19;
      *a4 = v21;
    }
    v29 = v16[v17 + a3];
    v30 = *(_DWORD *)(a1 + 52);
    v31 = __OFSUB__(v29, v30);
    v32 = v29 - v30;
    if (v32 < 0 == v31)
      v29 = v32 + *(_DWORD *)(a1 + 48);
    return v29 | 0x60000000u;
  }
  else
  {
    if (v5 != 4)
    {
      if (v5 == 2)
      {
        if (v4)
        {
          v6 = *(_QWORD *)(a1 + 8);
          v7 = (unsigned __int16 *)(v6 + 4 * v4);
          v10 = *v7;
          v9 = v7 + 1;
          v8 = v10;
          if (v10 > a3)
          {
            v11 = (uint64_t)&v9[v8 + ((v8 & 1) == 0)];
            if (a4)
            {
              v12 = v9[a3];
              v13 = *(int *)(a1 + 36);
              if ((int)v13 <= (int)v12)
                v14 = *(_QWORD *)(a1 + 24) + v12 - v13;
              else
                v14 = v6 + v12;
              *a4 = v14;
            }
            return *(unsigned int *)(v11 + 4 * a3);
          }
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (!v4)
      return 0xFFFFFFFFLL;
    v22 = *(_QWORD *)(a1 + 8);
    v23 = (int *)(v22 + 4 * v4);
    v26 = *v23;
    v24 = v23 + 1;
    v25 = v26;
    if (v26 <= (int)a3)
      return 0xFFFFFFFFLL;
    if (a4)
    {
      v27 = v24[a3];
      if ((v27 & 0x80000000) != 0)
      {
        v22 = *(_QWORD *)(a1 + 24);
        v27 &= ~0x80000000;
      }
      *a4 = v22 + v27;
    }
    return v24[v25 + a3];
  }
}

uint64_t res_getResource(uint64_t a1, const char *a2)
{
  unsigned int v3;
  const char *v4;

  v4 = a2;
  return res_getTableItemByKey(a1, *(_DWORD *)(a1 + 32), &v3, &v4);
}

uint64_t icu::ResourceTable::getKeyAndValue(icu::ResourceTable *this, unsigned int a2, const char **a3, icu::ResourceValue *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  BOOL v14;
  int v15;
  int v16;

  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 8) <= (signed int)a2)
    return 0;
  if (!*(_QWORD *)this)
  {
    v4 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * a2);
    v5 = *((_QWORD *)a4 + 1);
    if ((v4 & 0x80000000) != 0)
    {
      v9 = *(_QWORD *)(v5 + 24);
      v4 &= 0x7FFFFFFFu;
      goto LABEL_10;
    }
LABEL_8:
    v9 = *(_QWORD *)(v5 + 8);
LABEL_10:
    v7 = (const char *)(v9 + v4);
    goto LABEL_11;
  }
  v4 = *(unsigned __int16 *)(*(_QWORD *)this + 2 * a2);
  v5 = *((_QWORD *)a4 + 1);
  v6 = *(int *)(v5 + 36);
  if ((int)v6 > (int)v4)
    goto LABEL_8;
  v7 = (const char *)(*(_QWORD *)(v5 + 24) + v4 - v6);
LABEL_11:
  *a3 = v7;
  v10 = *((_QWORD *)this + 2);
  if (v10)
  {
    v11 = *((_QWORD *)a4 + 1);
    v12 = *(unsigned __int16 *)(v10 + 2 * a2);
    v13 = *(_DWORD *)(v11 + 52);
    v14 = __OFSUB__(v12, v13);
    v15 = v12 - v13;
    if (v15 < 0 == v14)
      v12 = v15 + *(_DWORD *)(v11 + 48);
    v16 = v12 | 0x60000000;
  }
  else
  {
    v16 = *(_DWORD *)(*((_QWORD *)this + 3) + 4 * a2);
  }
  *((_DWORD *)a4 + 6) = v16;
  return 1;
}

uint64_t icu::ResourceTable::findValue(icu::ResourceTable *this, char *__s1, icu::ResourceValue *a3)
{
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  int v9;
  BOOL v10;
  int v11;
  int v12;
  const char *v14;

  v5 = *((_QWORD *)a3 + 1);
  if (!*(_QWORD *)this)
  {
    v6 = sub_18BC62BE0(v5, *((_QWORD *)this + 1), *((_DWORD *)this + 8), __s1, &v14);
    if ((v6 & 0x80000000) == 0)
      goto LABEL_3;
    return 0;
  }
  v6 = sub_18BC62B1C(v5, *(_QWORD *)this, *((_DWORD *)this + 8), __s1, &v14);
  if ((v6 & 0x80000000) != 0)
    return 0;
LABEL_3:
  v7 = *((_QWORD *)this + 2);
  if (v7)
  {
    v8 = *(unsigned __int16 *)(v7 + 2 * v6);
    v9 = *(_DWORD *)(v5 + 52);
    v10 = __OFSUB__(v8, v9);
    v11 = v8 - v9;
    if (v11 < 0 == v10)
      v8 = v11 + *(_DWORD *)(v5 + 48);
    v12 = v8 | 0x60000000;
  }
  else
  {
    v12 = *(_DWORD *)(*((_QWORD *)this + 3) + 4 * v6);
  }
  *((_DWORD *)a3 + 6) = v12;
  return 1;
}

uint64_t res_getArrayItem(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  _DWORD *v4;
  unsigned __int16 *v6;
  int v7;
  int v8;
  BOOL v9;
  int v10;

  if ((a3 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v3 = a2 & 0xFFFFFFF;
  if (a2 >> 28 != 9)
  {
    if (a2 >> 28 == 8)
    {
      if (v3)
      {
        v4 = (_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v3);
        if (*v4 > (signed int)a3)
          return v4[a3 + 1];
      }
    }
    return 0xFFFFFFFFLL;
  }
  v6 = (unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 2 * v3);
  if (*v6 <= a3)
    return 0xFFFFFFFFLL;
  v7 = v6[a3 + 1];
  v8 = *(_DWORD *)(a1 + 52);
  v9 = __OFSUB__(v7, v8);
  v10 = v7 - v8;
  if (v10 < 0 == v9)
    v7 = v10 + *(_DWORD *)(a1 + 48);
  return v7 | 0x60000000u;
}

uint64_t icu::ResourceArray::getValue(icu::ResourceArray *this, unsigned int a2, icu::ResourceValue *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  BOOL v6;
  int v7;
  int v8;

  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 4) <= (signed int)a2)
    return 0;
  if (*(_QWORD *)this)
  {
    v3 = *((_QWORD *)a3 + 1);
    v4 = *(unsigned __int16 *)(*(_QWORD *)this + 2 * a2);
    v5 = *(_DWORD *)(v3 + 52);
    v6 = __OFSUB__(v4, v5);
    v7 = v4 - v5;
    if (v7 < 0 == v6)
      v4 = v7 + *(_DWORD *)(v3 + 48);
    v8 = v4 | 0x60000000;
  }
  else
  {
    v8 = *(_DWORD *)(*((_QWORD *)this + 1) + 4 * a2);
  }
  *((_DWORD *)a3 + 6) = v8;
  return 1;
}

uint64_t sub_18BC63030(uint64_t a1, uint64_t a2, char **a3, const char **a4)
{
  uint64_t TableItemByKey;
  char *v5;
  unsigned int v9;
  BOOL v10;
  int v11;
  _BOOL4 v12;
  char *v13;
  char *v14;
  char *v15;
  unsigned int v16;
  unsigned int v18;
  char *__endptr;

  TableItemByKey = a2;
  v5 = *a3;
  __endptr = 0;
  if (*v5)
  {
    v9 = a2 >> 28;
    if (a2 >> 28 == 2 || (a2 & 0xE0000000) == 0x40000000 || (a2 & 0xE0000000) == 0x80000000)
    {
      do
      {
        if (*v5)
          v10 = (_DWORD)TableItemByKey == -1;
        else
          v10 = 1;
        if (v10)
          break;
        v11 = v9 & 0xE;
        v12 = v11 == 4 || v9 == 2;
        if (v9 != 2 && v11 != 8 && v11 != 4)
          break;
        v13 = strchr(v5, 47);
        v14 = v13;
        if (v13)
        {
          if (v13 == v5)
            return 0xFFFFFFFFLL;
          *v13 = 0;
          v15 = v13 + 1;
        }
        else
        {
          v15 = &v5[strlen(v5)];
        }
        *a3 = v15;
        if (v12)
        {
          *a4 = v5;
          TableItemByKey = res_getTableItemByKey(a1, TableItemByKey, &v18, a4);
        }
        else if (v11 == 8)
        {
          v16 = strtol(v5, &__endptr, 10);
          if ((v16 & 0x80000000) != 0 || *__endptr)
            TableItemByKey = 0xFFFFFFFFLL;
          else
            TableItemByKey = res_getArrayItem(a1, TableItemByKey, v16);
          *a4 = 0;
        }
        else
        {
          TableItemByKey = 0xFFFFFFFFLL;
        }
        v9 = TableItemByKey >> 28;
        v5 = *a3;
      }
      while (v14);
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return TableItemByKey;
}

uint64_t ures_swap(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  int v22;
  unsigned int v23;
  int v24;
  signed int v25;
  unsigned int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int Int32;
  const char *v34;
  signed int v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  size_t v41;
  _BYTE *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  BOOL v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _BYTE *v79;
  uint64_t v80;
  unsigned int v81;
  int v82;
  unsigned int *__src;
  signed int v84;
  uint64_t v85;
  void *v86[2];
  void *v87[2];
  uint64_t v88;
  _BYTE v89[800];
  _BYTE v90[800];
  _BYTE v91[1600];
  uint64_t v92;

  v10 = a3;
  v92 = *MEMORY[0x1E0C80C00];
  v13 = udata_swapDataHeader(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0)
    return 0;
  v21 = *((unsigned __int8 *)a2 + 12);
  if (__PAIR64__(*((unsigned __int8 *)a2 + 13), v21) != 0x6500000052
    || *((_BYTE *)a2 + 14) != 115
    || *((_BYTE *)a2 + 15) != 66)
  {
    goto LABEL_13;
  }
  v22 = v13;
  v23 = *((unsigned __int8 *)a2 + 16);
  if (v23 == 1)
  {
    if (*((_BYTE *)a2 + 17))
      goto LABEL_9;
LABEL_13:
    udata_printError(a1, (uint64_t)"ures_swap(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not a resource bundle\n", v14, v15, v16, v17, v18, v19, v21);
    result = 0;
    v24 = 16;
LABEL_14:
    *a5 = v24;
    return result;
  }
  if ((v23 & 0xFE) != 2)
    goto LABEL_13;
LABEL_9:
  v88 = 0;
  *(_OWORD *)v86 = 0u;
  *(_OWORD *)v87 = 0u;
  BYTE4(v88) = v23;
  if (v10 < 0)
  {
    v25 = -1;
  }
  else
  {
    if (v10 - v13 <= 23)
    {
      udata_printError(a1, (uint64_t)"ures_swap(): too few bytes (%d after header) for a resource bundle\n", v14, v15, v16, v17, v18, v19, (v10 - v13));
LABEL_25:
      result = 0;
      v24 = 8;
      goto LABEL_14;
    }
    v25 = (v10 - v13) >> 2;
  }
  v26 = (unsigned int *)((char *)a2 + v13);
  v85 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*v26);
  Int32 = udata_readInt32(a1, v26[1]);
  if (Int32 <= 4)
  {
    v34 = "ures_swap(): too few indexes for a 1.1+ resource bundle\n";
LABEL_24:
    udata_printError(a1, (uint64_t)v34, v27, v28, v29, v30, v31, v32, v78);
    goto LABEL_25;
  }
  v35 = udata_readInt32(a1, v26[2]);
  v84 = v35;
  if (Int32 >= 7)
    v35 = udata_readInt32(a1, v26[7]);
  v82 = v35;
  v36 = udata_readInt32(a1, v26[4]);
  __src = (unsigned int *)((char *)a2 + v22);
  v37 = udata_readInt32(a1, __src[5]);
  if ((v25 & 0x80000000) == 0 && v25 < (int)v36)
  {
    v78 = v36;
    v34 = "ures_swap(): resource top %d exceeds bundle length %d\n";
    goto LABEL_24;
  }
  v38 = Int32 + 1;
  v39 = 4 * v84;
  if (v84 <= (int)v38)
    v39 = 0;
  LODWORD(v88) = v39;
  if ((v10 & 0x80000000) == 0)
  {
    v81 = v84 - v38;
    v80 = v37;
    bzero(v89, 0x320uLL);
    v40 = ((v10 + 31) >> 5) + 3;
    v41 = v40 & 0xFFFFFFC;
    if (v41 > 0x320)
    {
      v42 = uprv_malloc(v40 & 0xFFFFFFC);
      v87[1] = v42;
      if (!v42)
      {
        udata_printError(a1, (uint64_t)"ures_swap(): unable to allocate memory for tracking resources\n", v43, v44, v45, v46, v47, v48, v78);
        *a5 = 7;
        return 0;
      }
    }
    else
    {
      v87[1] = v89;
      v42 = v89;
    }
    v79 = v42;
    bzero(v42, v41);
    v49 = a2 == a4;
    v50 = (char *)a4 + v22;
    if (!v49)
      memcpy(v50, __src, 4 * (int)v36);
    bzero(v91, 0x640uLL);
    bzero(v90, 0x320uLL);
    udata_swapInvStringBlock(a1, (uint64_t)&__src[v38], 4 * v81, (uint64_t)&v50[4 * v38], a5);
    if (*a5 >= 1)
    {
      udata_printError(a1, (uint64_t)"ures_swap().udata_swapInvStringBlock(keys[%d]) failed\n", v51, v52, v53, v54, v55, v56, 4 * v81);
      return 0;
    }
    v57 = v82 - v84;
    if (v82 > v84)
    {
      (*(void (**)(uint64_t, unsigned int *, _QWORD, char *, int *))(a1 + 48))(a1, &__src[v84], (4 * v57), &v50[4 * v84], a5);
      if (*a5 >= 1)
      {
        udata_printError(a1, (uint64_t)"ures_swap().swapArray16(16-bit units[%d]) failed\n", v58, v59, v60, v61, v62, v63, (2 * v57));
        return 0;
      }
    }
    v86[0] = v50;
    if (v23 > 1 || (int)v80 <= 200)
    {
      v86[1] = v91;
      v71 = v90;
    }
    else
    {
      v64 = (char *)uprv_malloc(8 * v80 + 4 * (int)v80);
      v86[1] = v64;
      if (!v64)
      {
        udata_printError(a1, (uint64_t)"ures_swap(): unable to allocate memory for sorting tables (max length: %d)\n", v65, v66, v67, v68, v69, v70, v80);
        *a5 = 7;
        if (v79 != v89)
          uprv_free(v79);
        return 0;
      }
      v71 = &v64[8 * v80];
    }
    v87[0] = v71;
    sub_18BC6364C(a1, (uint64_t)__src, (uint64_t)v50, v85, 0, (uint64_t)v86, a5);
    if (*a5 >= 1)
      udata_printError(a1, (uint64_t)"ures_swapResource(root res=%08x) failed\n", v72, v73, v74, v75, v76, v77, v85);
    if (v86[1] != v91)
      uprv_free(v86[1]);
    if (v87[1] != v89)
      uprv_free(v87[1]);
    (*(void (**)(uint64_t, unsigned int *, _QWORD, char *, int *))(a1 + 56))(a1, __src, 4 * v38, v50, a5);
  }
  return (v22 + 4 * v36);
}

uint64_t sub_18BC6364C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, int *a7)
{
  BOOL v7;
  unsigned int v8;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v18;
  unsigned int *v19;
  unsigned int *v20;
  int Int32;
  uint64_t (*v22)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *);
  uint64_t v23;
  unsigned int *v24;
  uint64_t v25;
  unsigned int *v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int *v41;
  uint64_t v42;
  signed int v43;
  _BOOL4 v44;
  const char *v45;
  unsigned int *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  unsigned int *v65;
  uint64_t v66;
  int v67;
  int v68;
  _DWORD *v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  _DWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  uint64_t v81;
  int v82;
  size_t v83;
  char *v84;
  const void *v85;
  uint64_t v86;
  char *v87;
  char *v88;
  uint64_t v89;
  char *v90;
  unsigned int v91;
  unsigned int *__dst;
  char *v93;
  uint64_t v94;
  unsigned int *v95;
  int v96;
  char *v97;
  char *__srcb;
  char *__srcc;
  char *__src;
  unsigned int *__srca;

  v7 = a4 >> 28 > 9 || ((1 << (a4 >> 28)) & 0x2E0) == 0;
  v8 = a4 & 0xFFFFFFF;
  if (v7 && v8 != 0)
  {
    v12 = *(_QWORD *)(a6 + 24);
    v13 = v8 >> 5;
    v14 = *(_DWORD *)(v12 + 4 * v13);
    if ((v14 & (1 << a4)) == 0)
    {
      *(_DWORD *)(v12 + 4 * v13) = v14 | (1 << a4);
      v18 = result;
      v19 = (unsigned int *)(a2 + 4 * v8);
      v20 = (unsigned int *)(a3 + 4 * v8);
      switch(a4 >> 28)
      {
        case 0u:
        case 3u:
          Int32 = udata_readInt32(result, *v19);
          (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56))(v18, v19, 4, v20, a7);
          v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 48);
          v23 = (2 * Int32);
          v24 = v20 + 1;
          v25 = v18;
          v26 = v19 + 1;
          return v22(v25, v26, v23, v24, a7);
        case 1u:
          v28 = udata_readInt32(result, *v19);
          result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56))(v18, v19, 4, v20, a7);
          if (a5)
          {
            if (a5 == "")
              result = ucol_looksLikeCollationBinary((unsigned __int8 *)v18, (unsigned __int16 *)v19 + 2, v28, v29, v30, v31, v32, v33);
            else
              result = (*(unsigned int (**)(uint64_t, char *, uint64_t, const __int16 *, uint64_t))(v18 + 24))(v18, a5, 0xFFFFFFFFLL, L"%%CollationBin", 14) == 0;
            if ((_DWORD)result)
              return ucol_swap((unsigned __int8 *)v18, (uint64_t)(v19 + 1), v28, (unsigned __int16 *)v20 + 2, a7, v34, v35, v36);
          }
          return result;
        case 2u:
          __srcb = (char *)(a3 + 4 * v8);
          v37 = (*(uint64_t (**)(_QWORD))(result + 8))(*(unsigned __int16 *)v19);
          v93 = __srcb + 2;
          result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(v18 + 48))(v18, v19, 2);
          v38 = (char *)v19 + 2;
          v39 = 0;
          __dst = 0;
          v40 = (v37 + 2) >> 1;
          goto LABEL_18;
        case 4u:
          __srcc = (char *)(a3 + 4 * v8);
          v39 = v19 + 1;
          v37 = udata_readInt32(result, *v19);
          __dst = (unsigned int *)(__srcc + 4);
          result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(v18 + 56))(v18, v19, 4);
          v38 = 0;
          v93 = 0;
          v40 = v37 + 1;
LABEL_18:
          if (!(_DWORD)v37)
            return result;
          v94 = v37;
          v95 = v39;
          v91 = v40 + v8;
          v41 = (unsigned int *)(a2 + 4 * (int)(v40 + v8));
          __src = v38;
          if ((int)v37 < 1)
            goto LABEL_29;
          v42 = 0;
          do
          {
            if (v38)
            {
              v43 = (*(uint64_t (**)(_QWORD))(v18 + 8))(*(unsigned __int16 *)&v38[2 * v42]);
              v44 = *(_DWORD *)(a6 + 32) > v43;
            }
            else
            {
              v43 = udata_readInt32(v18, v95[v42]);
              v44 = v43 >= 0;
            }
            if (v44)
              v45 = (const char *)(a3 + v43);
            else
              v45 = "";
            v46 = v41;
            v47 = (*(uint64_t (**)(_QWORD))(v18 + 16))(v41[v42]);
            sub_18BC6364C(v18, a2, a3, v47, v45, a6, a7);
            if (*a7 >= 1)
              return udata_printError(v18, (uint64_t)"ures_swapResource(table res=%08x)[%d].recurse(%08x) failed\n", v48, v49, v50, v51, v52, v53, a4);
            ++v42;
            v38 = __src;
            v41 = v46;
          }
          while (v94 != v42);
LABEL_29:
          if (*(unsigned __int8 *)(a6 + 36) > 1u || *(unsigned __int8 *)(v18 + 1) == *(unsigned __int8 *)(v18 + 3))
          {
            if (v38)
            {
              (*(void (**)(uint64_t, char *, _QWORD, char *, int *))(v18 + 48))(v18, v38, (2 * v94), v93, a7);
              v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
              v23 = (4 * v94);
              v25 = v18;
              v26 = v41;
              v24 = (unsigned int *)(a3 + 4 * (int)v91);
            }
            else
            {
              v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
              v23 = (8 * v94);
              v25 = v18;
              v26 = v95;
              v24 = __dst;
            }
            return v22(v25, v26, v23, v24, a7);
          }
          v97 = (char *)(a3 + 4 * (int)v91);
          v65 = v41;
          if (v38)
          {
            if ((int)v94 >= 1)
            {
              v66 = 0;
              v67 = 0;
              do
              {
                v68 = (*(uint64_t (**)(_QWORD))(v18 + 8))(*(unsigned __int16 *)&__src[v66]);
                v69 = (_DWORD *)(*(_QWORD *)(a6 + 8) + 4 * v66);
                *v69 = v68;
                v69[1] = v67++;
                v66 += 2;
              }
              while (2 * v94 != v66);
            }
          }
          else if ((int)v94 >= 1)
          {
            v70 = 0;
            v71 = 4;
            do
            {
              v72 = udata_readInt32(v18, v95[v70]);
              v73 = (_DWORD *)(*(_QWORD *)(a6 + 8) + v71);
              *(v73 - 1) = v72;
              *v73 = v70++;
              v71 += 8;
            }
            while (v94 != v70);
          }
          uprv_sortArray(*(_QWORD *)(a6 + 8), v94, 8, (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_18BC63DBC, *(_QWORD *)a6, 0, a7);
          if (*a7 >= 1)
            return udata_printError(v18, (uint64_t)"ures_swapResource(table res=%08x).uprv_sortArray(%d items) failed\n", v74, v75, v76, v77, v78, v79, a4);
          if (__src)
          {
            v80 = v93;
            if (__src == v93)
              v80 = *(char **)(a6 + 16);
            if ((int)v94 >= 1)
            {
              v81 = 0;
              do
              {
                (*(void (**)(uint64_t, char *, uint64_t, char *, int *))(v18 + 48))(v18, &__src[2 * *(int *)(*(_QWORD *)(a6 + 8) + 4 * v81 + 4)], 2, &v80[v81], a7);
                v81 += 2;
              }
              while (2 * v94 != v81);
            }
            v82 = v94;
            if (v93 != v80)
            {
              v83 = 2 * (int)v94;
              v84 = v93;
              v85 = v80;
LABEL_72:
              memcpy(v84, v85, v83);
            }
          }
          else
          {
            __srca = __dst;
            if (v95 == __dst)
              __srca = *(unsigned int **)(a6 + 16);
            if ((int)v94 >= 1)
            {
              v86 = 0;
              v87 = (char *)__srca;
              do
              {
                (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(v18 + 56))(v18, &v95[*(int *)(*(_QWORD *)(a6 + 8) + v86 + 4)], 4, v87, a7);
                v87 += 4;
                v86 += 8;
              }
              while (8 * v94 != v86);
            }
            v84 = (char *)__dst;
            v85 = __srca;
            v82 = v94;
            if (__dst != __srca)
            {
              v83 = 4 * (int)v94;
              goto LABEL_72;
            }
          }
          v88 = (char *)(a3 + 4 * (int)v91);
          if (a2 == a3)
            v88 = *(char **)(a6 + 16);
          if (v82 >= 1)
          {
            v89 = 0;
            v90 = v88;
            do
            {
              (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(v18 + 56))(v18, &v65[*(int *)(*(_QWORD *)(a6 + 8) + v89 + 4)], 4, v90, a7);
              v90 += 4;
              v89 += 8;
            }
            while (8 * v82 != v89);
          }
          result = (uint64_t)v97;
          if (v97 != v88)
            result = (uint64_t)memcpy(v97, v88, 4 * v82);
          break;
        case 8u:
          v54 = v19 + 1;
          v55 = udata_readInt32(result, *v19);
          (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56))(v18, v19, 4, v20, a7);
          v96 = v55;
          if (v55 < 1)
            goto LABEL_38;
          v56 = 0;
          do
          {
            v57 = (*(uint64_t (**)(_QWORD))(v18 + 16))(v54[v56]);
            sub_18BC6364C(v18, a2, a3, v57, 0, a6, a7);
            if (*a7 >= 1)
              return udata_printError(v18, (uint64_t)"ures_swapResource(array res=%08x)[%d].recurse(%08x) failed\n", v58, v59, v60, v61, v62, v63, a4);
            ++v56;
          }
          while (v96 != v56);
LABEL_38:
          v24 = v20 + 1;
          v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
          v23 = (4 * v96);
          v25 = v18;
          v26 = v54;
          return v22(v25, v26, v23, v24, a7);
        case 0xEu:
          v64 = udata_readInt32(result, *v19);
          v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
          v23 = (4 * v64 + 4);
          v25 = v18;
          v26 = v19;
          v24 = v20;
          return v22(v25, v26, v23, v24, a7);
        default:
          *a7 = 16;
          return result;
      }
    }
  }
  return result;
}

uint64_t sub_18BC63DBC(uint64_t a1, int *a2, int *a3)
{
  return strcmp((const char *)(a1 + *a2), (const char *)(a1 + *a3));
}

_QWORD *uscript_openRun(uint64_t a1, int a2, int *a3)
{
  _QWORD *result;

  if (!a3)
    return 0;
  if (*a3 <= 0)
  {
    result = uprv_malloc(0x128uLL);
    if (!result)
    {
      *a3 = 7;
      return result;
    }
    if (*a3 <= 0)
    {
      if ((a2 & 0x80000000) == 0 && (a1 != 0) != (a2 == 0))
      {
        result[1] = a1;
        *(_DWORD *)result = a2;
        result[2] = 0;
        *((_DWORD *)result + 6) = -1;
        *((_DWORD *)result + 71) = -1;
        result[36] = 0;
        return result;
      }
      *a3 = 1;
    }
    uprv_free(result);
  }
  return 0;
}

uint64_t uscript_setRunText(uint64_t result, uint64_t a2, int a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    if (result && (a3 & 0x80000000) == 0 && (a2 != 0) != (a3 == 0))
    {
      *(_QWORD *)(result + 8) = a2;
      *(_DWORD *)result = a3;
      *(_QWORD *)(result + 16) = 0;
      *(_DWORD *)(result + 24) = -1;
      *(_DWORD *)(result + 284) = -1;
      *(_QWORD *)(result + 288) = 0;
    }
    else
    {
      *a4 = 1;
    }
  }
  return result;
}

void uscript_closeRun(void *a1)
{
  if (a1)
    uprv_free(a1);
}

double uscript_resetRun(uint64_t a1)
{
  double result;

  if (a1)
  {
    result = 0.0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = -1;
    *(_DWORD *)(a1 + 284) = -1;
    *(_QWORD *)(a1 + 288) = 0;
  }
  return result;
}

uint64_t uscript_nextRun(uint64_t result, _DWORD *a2, _DWORD *a3, int *a4)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v10;
  signed int v11;
  int v12;
  BOOL v13;
  uint64_t v14;
  int v15;
  int Script;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  BOOL v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  BOOL v32;
  int v33;
  int v34;
  int v35;
  int v36;
  BOOL v37;
  int v38;
  BOOL v39;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;

  v58 = 0;
  if (result)
  {
    v4 = result;
    v5 = *(_DWORD *)(result + 20);
    v6 = *(_DWORD *)result;
    if (v5 >= *(_DWORD *)result)
    {
      return 0;
    }
    else
    {
      *(_DWORD *)(result + 292) = 0;
      *(_DWORD *)(result + 24) = 0;
      *(_DWORD *)(result + 16) = v5;
      while (1)
      {
        v10 = *(_QWORD *)(v4 + 8);
        v11 = *(unsigned __int16 *)(v10 + 2 * v5);
        v12 = v6 - 1;
        v13 = (v11 & 0xFC00) == 0xD800 && v5 < v12;
        if (v13)
        {
          v14 = v5 + 1;
          v15 = *(unsigned __int16 *)(v10 + 2 * v14);
          if ((v15 & 0xFC00) == 0xDC00)
          {
            v11 = v15 + (v11 << 10) - 56613888;
            *(_DWORD *)(v4 + 20) = v14;
          }
        }
        Script = uscript_getScript(v11, &v58);
        v17 = 2 * (v11 > 59);
        v18 = 32;
        do
        {
          if (*(_DWORD *)&asc_18BE19B5C[2 * (v17 + (v18 >> 1))] <= v11)
            v17 += v18 >> 1;
          v13 = v18 > 3;
          v18 >>= 1;
        }
        while (v13);
        if (*(_DWORD *)&asc_18BE19B5C[2 * v17] != v11)
          v17 = -1;
        if ((v17 & 0x80000000) == 0)
        {
          v19 = *(_DWORD *)(v4 + 288);
          if ((v17 & 1) != 0)
          {
            if (v19 >= 1)
            {
              v29 = *(_DWORD *)(v4 + 284);
              while (1)
              {
                v30 = v29;
                if (*(_DWORD *)(v4 + 8 * v29 + 28) == (v17 & 0xFFFFFFFE))
                  break;
                v31 = *(_DWORD *)(v4 + 292);
                v32 = __OFSUB__(v31, 1);
                v33 = v31 - 1;
                if (v33 < 0 == v32)
                  *(_DWORD *)(v4 + 292) = v33;
                *(_DWORD *)(v4 + 288) = v19 - 1;
                v34 = v30 + 31;
                v25 = -v34 < 0;
                v35 = -v34 & 0x1F;
                v36 = v34 & 0x1F;
                if (!v25)
                  v36 = -v35;
                v37 = v19 < 2;
                if (v19 < 2)
                  v29 = -1;
                else
                  v29 = v36;
                *(_DWORD *)(v4 + 284) = v29;
                --v19;
                if (v37)
                  goto LABEL_42;
              }
              Script = *(_DWORD *)(v4 + 8 * v29 + 32);
            }
          }
          else
          {
            v20 = *(_DWORD *)(v4 + 24);
            if (v19 < 32)
              v21 = v19 + 1;
            else
              v21 = 32;
            *(_DWORD *)(v4 + 288) = v21;
            v22 = *(_DWORD *)(v4 + 292);
            if (v22 < 32)
              v23 = v22 + 1;
            else
              v23 = 32;
            *(_DWORD *)(v4 + 292) = v23;
            v24 = *(_DWORD *)(v4 + 284) + 1;
            v25 = -v24 < 0;
            v26 = -v24 & 0x1F;
            v27 = v24 & 0x1F;
            if (!v25)
              v27 = -v26;
            *(_DWORD *)(v4 + 284) = v27;
            v28 = v4 + 8 * v27;
            *(_DWORD *)(v28 + 28) = v17;
            *(_DWORD *)(v28 + 32) = v20;
          }
        }
LABEL_42:
        v38 = *(_DWORD *)(v4 + 24);
        v39 = v38 <= 1 || Script < 2;
        if (!v39 && v38 != Script)
          break;
        if (Script >= 2 && v38 <= 1)
        {
          *(_DWORD *)(v4 + 24) = Script;
          v42 = *(_DWORD *)(v4 + 292);
          v43 = v42 - 1;
          if (v42 >= 1)
          {
            v44 = *(_DWORD *)(v4 + 284) - v42 + 32;
            v45 = v44 & 0x1F;
            v46 = -v44;
            v25 = v46 < 0;
            v47 = v46 & 0x1F;
            if (v25)
              v48 = v45;
            else
              v48 = -v47;
            do
            {
              v49 = v48 + 1;
              v25 = -v49 < 0;
              v50 = -v49 & 0x1F;
              v48 = v49 & 0x1F;
              if (!v25)
                v48 = -v50;
              *(_DWORD *)(v4 + 8 * v48 + 32) = Script;
              --v42;
            }
            while (v42);
            v43 = -1;
          }
          *(_DWORD *)(v4 + 292) = v43;
          v38 = Script;
        }
        if ((v17 & 0x80000001) == 1)
        {
          v51 = *(_DWORD *)(v4 + 288);
          if (v51 >= 1)
          {
            v52 = *(_DWORD *)(v4 + 292);
            v32 = __OFSUB__(v52, 1);
            v53 = v52 - 1;
            if (v53 < 0 == v32)
              *(_DWORD *)(v4 + 292) = v53;
            *(_DWORD *)(v4 + 288) = v51 - 1;
            v54 = *(_DWORD *)(v4 + 284) + 31;
            v25 = -v54 < 0;
            v55 = -v54 & 0x1F;
            v56 = v54 & 0x1F;
            if (!v25)
              v56 = -v55;
            if (v51 < 2)
              v57 = -1;
            else
              v57 = v56;
            *(_DWORD *)(v4 + 284) = v57;
          }
        }
        v5 = *(_DWORD *)(v4 + 20) + 1;
        *(_DWORD *)(v4 + 20) = v5;
        v6 = *(_DWORD *)v4;
        if (v5 >= *(_DWORD *)v4)
          goto LABEL_79;
      }
      if (v11 >= 0x10000)
        --*(_DWORD *)(v4 + 20);
LABEL_79:
      if (a2)
        *a2 = *(_DWORD *)(v4 + 16);
      if (a3)
        *a3 = *(_DWORD *)(v4 + 20);
      if (a4)
        *a4 = v38;
      return 1;
    }
  }
  return result;
}

uint64_t uscript_getCode(char *__s1, int32_t *a2, int a3, int *a4)
{
  uint64_t v4;
  char *v6;
  char *v9;
  int v10;
  int32_t v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  int32_t PropertyValueEnum;
  _QWORD v17[2];
  int v18;
  void *v19[9];

  v19[8] = *(void **)MEMORY[0x1E0C80C00];
  if (*a4 > 0)
    return 0;
  v6 = __s1;
  if (!__s1)
    goto LABEL_15;
  if (a2)
  {
    if ((a3 & 0x80000000) == 0)
      goto LABEL_6;
LABEL_15:
    v4 = 0;
    *a4 = 1;
    return v4;
  }
  if (a3)
    goto LABEL_15;
LABEL_6:
  if (!strcmp(__s1, "Aran"))
    v6 = "Arab";
  v9 = strrchr(v6, 45);
  if (v9 || (v9 = strrchr(v6, 95)) != 0)
  {
    if (v9 - v6 == 7)
    {
      if (strlen(v6) != 11)
      {
LABEL_13:
        v10 = 1;
LABEL_23:
        v18 = 0;
        v13 = sub_18BC64498((uint64_t)v6, a2, a3, a4);
        v4 = v13;
        if (*a4 > 0 || (_DWORD)v13)
          return v4;
        memset(&v19[1], 0, 56);
        v19[0] = (char *)&v19[1] + 5;
        LODWORD(v19[1]) = 40;
        v17[0] = 0;
        v17[1] = 0;
        icu::CharStringByteSink::CharStringByteSink(v17, (uint64_t)v19);
        ulocimp_addLikelySubtags(v6, v17, &v18);
        icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v17);
        if (v18 > 0 || v18 == -124)
        {
          if (!v10)
            goto LABEL_40;
        }
        else
        {
          v14 = sub_18BC64498((uint64_t)v19[0], a2, a3, a4);
          v15 = *a4 <= 0 && v14 == 0;
          if (v15)
            v4 = 0;
          else
            v4 = v14;
          if (!v15 || ((v10 ^ 1) & 1) != 0)
            goto LABEL_41;
        }
        PropertyValueEnum = u_getPropertyValueEnum(UCHAR_SCRIPT, v6);
        if (PropertyValueEnum != -1 && *a4 <= 0)
        {
          if (a3)
            *a2 = PropertyValueEnum;
          else
            *a4 = 15;
          v4 = 1;
          goto LABEL_41;
        }
LABEL_40:
        v4 = 0;
LABEL_41:
        if (BYTE4(v19[1]))
          uprv_free(v19[0]);
        return v4;
      }
    }
    else if (v9 - v6 != 3 || strlen(v6) <= 8)
    {
      goto LABEL_13;
    }
  }
  v12 = u_getPropertyValueEnum(UCHAR_SCRIPT, v6);
  if (v12 == -1)
  {
    v10 = 0;
    goto LABEL_23;
  }
  if (*a4 > 0)
    return 0;
  if (a3)
    *a2 = v12;
  else
    *a4 = 15;
  return 1;
}

uint64_t sub_18BC64498(uint64_t a1, int32_t *a2, int a3, int *a4)
{
  uint64_t result;
  int Script;
  int32_t PropertyValueEnum;
  int32_t v11;
  uint64_t v12;
  int v13;
  char alias[8];
  _QWORD v15[2];

  result = 0;
  v15[1] = *MEMORY[0x1E0C80C00];
  v13 = 0;
  *(_QWORD *)alias = 0;
  v15[0] = 0;
  if (*a4 > 0)
    return result;
  uloc_getLanguage(a1, (char *)v15, 8, &v13);
  result = 0;
  if (v13 > 0 || v13 == -124)
    return result;
  if (LOWORD(v15[0]) ^ 0x616A | BYTE2(v15[0]))
  {
    if (LOWORD(v15[0]) ^ 0x6F6B | BYTE2(v15[0]))
    {
      Script = uloc_getScript(a1, alias, 8, &v13);
      result = 0;
      if (v13 > 0 || v13 == -124)
        return result;
      if (LOWORD(v15[0]) ^ 0x687A | BYTE2(v15[0]) || *(_DWORD *)alias ^ 0x746E6148 | alias[4])
      {
        if (Script)
        {
          if (!(*(_DWORD *)alias ^ 0x6E617241 | alias[4]))
            strcpy(alias, "Arab");
          PropertyValueEnum = u_getPropertyValueEnum(UCHAR_SCRIPT, alias);
          if (PropertyValueEnum != -1)
          {
            v11 = (PropertyValueEnum - 73) >= 2 ? PropertyValueEnum : 17;
            if (*a4 <= 0)
            {
              if (a3 <= 0)
                *a4 = 15;
              else
                *a2 = v11;
              return 1;
            }
          }
        }
        return 0;
      }
      if (*a4 > 0)
        return 0;
      if (a3 >= 2)
      {
        v12 = 0x500000011;
        goto LABEL_31;
      }
    }
    else
    {
      if (*a4 > 0)
        return 0;
      if (a3 >= 2)
      {
        v12 = 0x1100000012;
LABEL_31:
        *(_QWORD *)a2 = v12;
        return 2;
      }
    }
    *a4 = 15;
    return 2;
  }
  if (*a4 > 0)
    return 0;
  if (a3 >= 3)
  {
    *(_QWORD *)a2 = 0x1400000016;
    a2[2] = 17;
  }
  else
  {
    *a4 = 15;
  }
  return 3;
}

uint64_t uscript_getSampleString(unsigned int a1, _WORD *a2, unsigned int a3, int *a4)
{
  int v5;
  unsigned int v6;
  uint64_t v7;

  if (*a4 > 0)
    return 0;
  if ((a3 & 0x80000000) != 0 || !a2 && a3)
  {
    *a4 = 1;
    return 0;
  }
  if (a1 <= 0xC7 && (v5 = dword_18BE19C00[a1], v6 = v5 & 0x1FFFFF, (v5 & 0x1FFFFF) != 0))
  {
    if (v6 < 0x10000)
      v7 = 1;
    else
      v7 = 2;
    if (v7 <= a3)
    {
      if (HIWORD(v6))
      {
        *a2 = (v6 >> 10) - 10304;
        a2[1] = v5 & 0x3FF | 0xDC00;
        v7 = 2;
      }
      else
      {
        *a2 = v5;
        v7 = 1;
      }
    }
  }
  else
  {
    v7 = 0;
  }
  return u_terminateUChars((uint64_t)a2, a3, v7, a4);
}

uint64_t uscript_getSampleUnicodeString@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2;

  *(_OWORD *)(a2 + 8) = 0u;
  *(_QWORD *)(a2 + 56) = 0;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_QWORD *)a2 = off_1E2256B38;
  *(_WORD *)(a2 + 8) = 2;
  if (result <= 0xC7)
  {
    v2 = dword_18BE19C00[result] & 0x1FFFFF;
    if (v2)
      return icu::UnicodeString::append(a2, v2);
  }
  return result;
}

uint64_t uscript_getUsage(unsigned int a1)
{
  if (a1 > 0xC7)
    return 0;
  else
    return (dword_18BE19C00[a1] >> 21) & 7;
}

uint64_t uscript_isRightToLeft(unsigned int a1)
{
  if (a1 > 0xC7)
    return 0;
  else
    return HIBYTE(dword_18BE19C00[a1]) & 1;
}

uint64_t uscript_breaksBetweenLetters(unsigned int a1)
{
  if (a1 > 0xC7)
    return 0;
  else
    return (dword_18BE19C00[a1] >> 25) & 1;
}

uint64_t uscript_isCased(unsigned int a1)
{
  if (a1 > 0xC7)
    return 0;
  else
    return (dword_18BE19C00[a1] >> 26) & 1;
}

double uset_openEmpty@<D0>(unint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  icu::UnicodeSet *v2;
  double result;

  v2 = (icu::UnicodeSet *)icu::UMemory::operator new(a2, (icu::UMemory *)0xC8, a1);
  if (v2)
    return icu::UnicodeSet::UnicodeSet(v2);
  return result;
}

icu::UnicodeSet *uset_open@<X0>(unsigned int a1@<W0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unsigned int v3;
  icu::UnicodeSet *result;

  v3 = a2;
  result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, a2);
  if (result)
    return icu::UnicodeSet::UnicodeSet(result, a1, v3);
  return result;
}

void uset_close(icu::UnicodeSet *a1)
{
  void *v1;

  if (a1)
  {
    icu::UnicodeSet::~UnicodeSet(a1);
    icu::UMemory::operator delete(v1);
  }
}

BOOL uset_isFrozen(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40) || *(_QWORD *)(a1 + 88) != 0;
}

void *uset_addString(icu::UnicodeSet *a1, uint64_t a2, unsigned int a3)
{
  void *v4;
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v7, 0, sizeof(v7));
  v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 >> 31, &v6);
  icu::UnicodeSet::add(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_addAllCodePoints(icu::UnicodeSet *a1, uint64_t a2, uint64_t a3)
{
  void *v4;
  _OWORD v6[4];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  memset(v6, 0, sizeof(v6));
  icu::UnicodeString::UnicodeString((uint64_t)v6, a2, a3);
  icu::UnicodeSet::addAll(a1, (const icu::UnicodeString *)v6);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v6);
}

void *uset_removeString(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  void *v4;
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v7, 0, sizeof(v7));
  v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::remove(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_removeAllCodePoints(icu::UVector **a1, uint64_t a2, int a3)
{
  void *v4;
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v7, 0, sizeof(v7));
  v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::removeAll(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_retainString(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  void *v4;
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v7, 0, sizeof(v7));
  v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::retain(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_retainAllCodePoints(icu::UVector **a1, uint64_t a2, int a3)
{
  void *v4;
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v7, 0, sizeof(v7));
  v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::retainAll(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_complementString(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  void *v4;
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v7, 0, sizeof(v7));
  v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::complement(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_complementAllCodePoints(icu::UVector **a1, uint64_t a2, int a3)
{
  void *v4;
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v7, 0, sizeof(v7));
  v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::complementAll(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

icu::UVector *uset_containsString(icu::UVector **a1, uint64_t a2, int a3)
{
  icu::UVector *v4;
  void *v5;
  uint64_t v7;
  _OWORD v8[4];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  memset(v8, 0, sizeof(v8));
  v7 = a2;
  icu::UnicodeString::UnicodeString(v8, a3 == -1, &v7);
  v4 = icu::UnicodeSet::contains(a1, (const icu::UnicodeString *)v8);
  icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v8);
  return v4;
}

BOOL uset_containsAllCodePoints(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  _BOOL8 v4;
  void *v5;
  uint64_t v7;
  _OWORD v8[4];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  memset(v8, 0, sizeof(v8));
  v7 = a2;
  icu::UnicodeString::UnicodeString(v8, a3 == -1, &v7);
  v4 = icu::UnicodeSet::containsAll(a1, (const icu::UnicodeString *)v8);
  icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v8);
  return v4;
}

BOOL uset_containsSome(icu::UnicodeSet *a1, const icu::UnicodeSet *a2)
{
  return !icu::UnicodeSet::containsNone(a1, a2);
}

BOOL uset_equals(uint64_t a1, uint64_t a2)
{
  return icu::UnicodeSet::operator==(a1, a2);
}

uint64_t uset_getItemCount(icu::UnicodeSet *a1)
{
  int RangeCount;

  RangeCount = icu::UnicodeSet::getRangeCount(a1);
  return icu::UnicodeSet::stringsSize(a1) + RangeCount;
}

uint64_t uset_getItem(icu::UnicodeSet *a1, int a2, _DWORD *a3, _DWORD *a4, UChar *a5, int a6, int *a7)
{
  uint64_t result;
  int RangeCount;
  signed int v16;
  int RangeEnd;
  int v18;
  uint64_t String;
  UChar *v20;

  if (*a7 > 0)
    return 0;
  if (a2 < 0)
  {
    v18 = 1;
  }
  else
  {
    RangeCount = icu::UnicodeSet::getRangeCount(a1);
    v16 = a2 - RangeCount;
    if (a2 < RangeCount)
    {
      *a3 = icu::UnicodeSet::getRangeStart(a1, a2);
      RangeEnd = icu::UnicodeSet::getRangeEnd(a1, a2);
      result = 0;
      *a4 = RangeEnd;
      return result;
    }
    if (v16 < (int)icu::UnicodeSet::stringsSize(a1))
    {
      String = icu::UnicodeSet::getString((icu::UVector **)a1, v16);
      v20 = a5;
      return icu::UnicodeString::extract(String, &v20, a6, a7);
    }
    v18 = 8;
  }
  *a7 = v18;
  return 0xFFFFFFFFLL;
}

uint64_t uset_serialize(icu::UnicodeSet *a1, unsigned __int16 *a2, int a3, UErrorCode *a4)
{
  if (a4 && *(int *)a4 <= 0)
    return icu::UnicodeSet::serialize(a1, a2, a3, a4);
  else
    return 0;
}

uint64_t uset_getSerializedSet(uint64_t a1, __int16 *a2, int a3)
{
  unsigned __int16 *v3;
  unsigned int v4;
  uint64_t v5;

  if (a1)
  {
    if (a2 && a3 > 0)
    {
      v3 = (unsigned __int16 *)(a2 + 1);
      v4 = (unsigned __int16)*a2;
      if (*a2 < 0)
      {
        v4 &= 0x7FFFu;
        if (v4 + 2 <= a3)
        {
          v3 = (unsigned __int16 *)(a2 + 2);
          *(_DWORD *)(a1 + 8) = (unsigned __int16)a2[1];
          goto LABEL_11;
        }
      }
      else if (v4 < a3)
      {
        *(_DWORD *)(a1 + 8) = v4;
LABEL_11:
        *(_QWORD *)a1 = v3;
        v5 = 1;
        goto LABEL_12;
      }
    }
    v4 = 0;
    v5 = 0;
    *(_DWORD *)(a1 + 8) = 0;
LABEL_12:
    *(_DWORD *)(a1 + 12) = v4;
    return v5;
  }
  return 0;
}

uint64_t uset_setSerializedToOne(uint64_t result, unsigned int a2)
{
  if (result && a2 <= 0x10FFFF)
  {
    *(_QWORD *)result = result + 16;
    if (a2 > 0xFFFE)
    {
      if (a2 == 0xFFFF)
      {
        *(_QWORD *)(result + 8) = 0x300000001;
        *(_DWORD *)(result + 16) = 0x1FFFF;
        *(_WORD *)(result + 20) = 0;
      }
      else
      {
        *(_DWORD *)(result + 8) = 0;
        if (a2 >= 0x10FFFF)
        {
          *(_QWORD *)(result + 12) = 0xFFFF001000000002;
        }
        else
        {
          *(_DWORD *)(result + 12) = 4;
          *(_WORD *)(result + 16) = HIWORD(a2);
          *(_WORD *)(result + 18) = a2;
          *(_WORD *)(result + 20) = (a2 + 1) >> 16;
          *(_WORD *)(result + 22) = a2 + 1;
        }
      }
    }
    else
    {
      *(_QWORD *)(result + 8) = 0x200000002;
      *(_WORD *)(result + 16) = a2;
      *(_WORD *)(result + 18) = a2 + 1;
    }
  }
  return result;
}

uint64_t uset_serializedContains(unsigned __int16 **a1, unsigned int a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned __int16 *v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int i;
  unsigned int v14;
  int v15;
  int v16;

  v2 = 0;
  if (a1)
  {
    v3 = HIWORD(a2);
    if (HIWORD(a2) <= 0x10u)
    {
      v4 = *a1;
      if (v3)
      {
        v6 = *((_DWORD *)a1 + 3);
        v7 = *((int *)a1 + 2);
        v8 = v6 - 2 - v7;
        v9 = v4[v7];
        if (v3 < v9 || v3 == v9 && v4[(int)v7 + 1] > (unsigned __int16)a2)
        {
          v8 = 0;
        }
        else
        {
          v11 = v4[v6 - 2];
          if (v3 < v11 || v3 == v11 && v4[v6 - 1] > (unsigned __int16)a2)
          {
            v12 = (v8 >> 1) & 0xFFFFFFFE;
            if (v12)
            {
              for (i = 0; i != v12; v12 = ((int)(v8 + i) >> 1) & 0xFFFFFFFE)
              {
                v14 = v4[(int)(v12 + v7)];
                if (v3 < v14 || v3 == v14 && (unsigned __int16)a2 < v4[(int)(v12 + v7) + 1])
                  v8 = v12;
                else
                  i = v12;
              }
            }
          }
          else
          {
            v8 = v6 - v7;
          }
        }
        return ((_BYTE)v7 + (v8 >> 1)) & 1;
      }
      else
      {
        if (*v4 <= a2)
        {
          v5 = *((_DWORD *)a1 + 2);
          v10 = v5 - 1;
          if (v4[v5 - 1] > a2)
          {
            if (v10 >= 2)
            {
              v15 = 0;
              v16 = v10 >> 1;
              --v5;
              do
              {
                if (v4[v16] > (int)a2)
                  v5 = v16;
                else
                  v15 = v16;
                v16 = (v5 + v15) >> 1;
              }
              while (v16 != v15);
            }
            else
            {
              LOBYTE(v5) = v5 - 1;
            }
          }
        }
        else
        {
          LOBYTE(v5) = 0;
        }
        return v5 & 1;
      }
    }
  }
  return v2;
}

uint64_t uset_getSerializedRangeCount(uint64_t result)
{
  int v1;
  int v2;
  BOOL v3;
  int v4;
  int v5;
  int v6;

  if (result)
  {
    v1 = *(_DWORD *)(result + 8);
    v2 = *(_DWORD *)(result + 12);
    v3 = __OFSUB__(v2, v1);
    v4 = v2 - v1;
    if (v4 < 0 != v3)
      ++v4;
    v5 = v1 + (v4 >> 1);
    if (v5 + 1 >= 0)
      v6 = v5 + 1;
    else
      v6 = v5 + 2;
    return (v6 >> 1);
  }
  return result;
}

uint64_t uset_getSerializedRange(uint64_t *a1, int a2, int *a3, int *a4)
{
  uint64_t result;
  uint64_t v6;
  signed int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;

  result = 0;
  if (a1 && (a2 & 0x80000000) == 0 && a3 && a4)
  {
    v6 = *a1;
    v7 = *((_DWORD *)a1 + 3);
    v8 = *((int *)a1 + 2);
    v9 = 2 * a2;
    if (2 * a2 >= (int)v8)
    {
      v12 = 2 * (int)(v9 - v8);
      v13 = v7 - v8;
      if ((int)v12 >= v13)
        return 0;
      v14 = v6 + 2 * v8;
      v15 = (int)v12;
      *a3 = *(unsigned __int16 *)(v14 + ((2 * v12) | 2)) | (*(unsigned __int16 *)(v14 + 2 * (int)v12) << 16);
      v16 = (int)v12 + 2;
      if ((int)v16 < v13)
      {
        v11 = *(unsigned __int16 *)(v14 + 2 * v15 + 6) | (*(unsigned __int16 *)(v14 + 2 * v16) << 16);
        goto LABEL_13;
      }
    }
    else
    {
      v10 = v9 | 1;
      *a3 = *(unsigned __int16 *)(v6 + 2 * v9);
      if ((int)(v9 | 1) < (int)v8)
      {
        v11 = *(unsigned __int16 *)(v6 + 2 * v10);
LABEL_13:
        v17 = v11 - 1;
LABEL_16:
        *a4 = v17;
        return 1;
      }
      if ((int)v10 < v7)
      {
        v11 = *(unsigned __int16 *)(v6 + 2 * (int)(v9 + 2)) | (*(unsigned __int16 *)(v6 + 2 * v10) << 16);
        goto LABEL_13;
      }
    }
    v17 = 1114111;
    goto LABEL_16;
  }
  return result;
}

icu::UnicodeSet *uset_openPattern(uint64_t a1, int a2, UErrorCode *a3)
{
  unint64_t v4;
  icu::UnicodeSet *v5;
  icu::UnicodeSet *v6;
  uint64_t v7;
  void *v8;
  uint64_t v10;
  uint64_t v11;
  _OWORD v12[4];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  memset(v12, 0, sizeof(v12));
  v11 = a1;
  icu::UnicodeString::UnicodeString(v12, a2 == -1, &v11);
  v10 = v11;
  v5 = (icu::UnicodeSet *)icu::UMemory::operator new(&v10, (icu::UMemory *)0xC8, v4);
  v6 = v5;
  if (v5)
  {
    icu::UnicodeSet::UnicodeSet(v5, (const icu::UnicodeString *)v12, a3);
    v7 = *(unsigned int *)a3;
    if ((int)v7 >= 1)
    {
      icu::UnicodeSet::~UnicodeSet(v6);
      icu::UMemory::operator delete(v8);
      v6 = 0;
    }
  }
  else
  {
    v7 = 7;
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }
  icu::UnicodeString::~UnicodeString((void *)v7, (icu::UnicodeString *)v12);
  return v6;
}

icu::UnicodeSet *uset_openPatternOptions(uint64_t a1, int a2, unsigned int a3, UErrorCode *a4)
{
  unint64_t v6;
  icu::UnicodeSet *v7;
  icu::UnicodeSet *v8;
  uint64_t v9;
  void *v10;
  uint64_t v12;
  uint64_t v13;
  _OWORD v14[4];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  memset(v14, 0, sizeof(v14));
  v13 = a1;
  icu::UnicodeString::UnicodeString(v14, a2 == -1, &v13);
  v12 = v13;
  v7 = (icu::UnicodeSet *)icu::UMemory::operator new(&v12, (icu::UMemory *)0xC8, v6);
  v8 = v7;
  if (v7)
  {
    icu::UnicodeSet::UnicodeSet(v7, (const icu::UnicodeString *)v14, a3, 0, a4);
    v9 = *(unsigned int *)a4;
    if ((int)v9 >= 1)
    {
      icu::UnicodeSet::~UnicodeSet(v8);
      icu::UMemory::operator delete(v10);
      v8 = 0;
    }
  }
  else
  {
    v9 = 7;
    *a4 = U_MEMORY_ALLOCATION_ERROR;
  }
  icu::UnicodeString::~UnicodeString((void *)v9, (icu::UnicodeString *)v14);
  return v8;
}

uint64_t uset_applyPattern(icu::UnicodeSet *a1, uint64_t a2, uint64_t a3, unsigned int a4, UErrorCode *a5)
{
  uint64_t v6;
  void *v10;
  void (**v11)(icu::ParsePosition *__hidden);
  unint64_t v12;
  _OWORD v13[4];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!a5 || *(int *)a5 > 0)
    return 0;
  if (a1)
  {
    memset(v13, 0, sizeof(v13));
    icu::UnicodeString::UnicodeString((uint64_t)v13, a2, a3);
    v11 = off_1E224A8B0;
    v12 = 0xFFFFFFFF00000000;
    icu::UnicodeSet::applyPattern(a1, (const icu::UnicodeString *)v13, (icu::ParsePosition *)&v11, a4, 0, a5);
    v6 = v12;
    icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v11);
    icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v13);
  }
  else
  {
    v6 = 0;
    *a5 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v6;
}

void *uset_applyPropertyAlias(icu::UnicodeSet *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, UErrorCode *a6)
{
  void *v10;
  void *v11;
  _OWORD v13[4];
  _OWORD v14[4];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  memset(v14, 0, sizeof(v14));
  icu::UnicodeString::UnicodeString((uint64_t)v14, a2, a3);
  memset(v13, 0, sizeof(v13));
  icu::UnicodeString::UnicodeString((uint64_t)v13, a4, a5);
  icu::UnicodeSet::applyPropertyAlias(a1, (const icu::UnicodeString *)v14, (const icu::UnicodeString *)v13, a6);
  icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v13);
  return icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v14);
}

BOOL uset_resemblesPattern(uint64_t a1, uint64_t a2, const icu::UnicodeString *a3)
{
  int v4;
  unsigned int v5;
  unint64_t v6;
  void *v7;
  _BOOL8 v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  icu::UnicodeString::UnicodeString((uint64_t)&v10, a1, a2);
  v4 = (_DWORD)a3 + 1;
  if (SWORD4(v10) < 0)
  {
    v5 = HIDWORD(v10);
    if (v4 < SHIDWORD(v10))
      goto LABEL_5;
LABEL_11:
    v8 = icu::UnicodeSet::resemblesPattern((icu::UnicodeSet *)&v10, a3);
    goto LABEL_12;
  }
  if (v4 >= WORD4(v10) >> 5)
    goto LABEL_11;
  v5 = WORD4(v10) >> 5;
LABEL_5:
  if (v5 <= a3)
    goto LABEL_11;
  v6 = (BYTE8(v10) & 2) != 0 ? (unint64_t)&v10 | 0xA : *((_QWORD *)&v11 + 1);
  v7 = (void *)*(unsigned __int16 *)(v6 + 2 * (int)a3);
  if ((_DWORD)v7 != 91)
    goto LABEL_11;
  v8 = 1;
LABEL_12:
  icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)&v10);
  return v8;
}

uint64_t uset_toPattern(icu::UnicodeSet *a1, UChar *a2, int a3, const icu::UnicodeString *a4, int *a5)
{
  uint64_t v8;
  UChar *v10;
  UChar *v11;
  void (**v12)(icu::UnicodeString *__hidden);
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = 0u;
  v14 = 0u;
  v16 = 0;
  v15 = 0u;
  v12 = off_1E2256B38;
  LOWORD(v13) = 2;
  icu::UnicodeSet::toPattern(a1, (icu::UnicodeString *)&v12, a4);
  v11 = a2;
  v8 = icu::UnicodeString::extract((uint64_t)&v12, &v11, a3, a5);
  v10 = v11;
  icu::UnicodeString::~UnicodeString(&v10, (icu::UnicodeString *)&v12);
  return v8;
}

void *icu::UnicodeSetIterator::getStaticClassID(icu::UnicodeSetIterator *this)
{
  return &unk_1EE009650;
}

void *icu::UnicodeSetIterator::getDynamicClassID(icu::UnicodeSetIterator *this)
{
  return &unk_1EE009650;
}

icu::UnicodeSetIterator *icu::UnicodeSetIterator::UnicodeSetIterator(icu::UnicodeSetIterator *this, const icu::UnicodeSet *a2)
{
  *(_QWORD *)this = off_1E2257640;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 3) = a2;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

{
  *(_QWORD *)this = off_1E2257640;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 3) = a2;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

icu::UnicodeSet *icu::UnicodeSetIterator::reset(icu::UnicodeSetIterator *this, const icu::UnicodeSet *a2)
{
  *((_QWORD *)this + 3) = a2;
  return icu::UnicodeSetIterator::reset(this);
}

icu::UnicodeSetIterator *icu::UnicodeSetIterator::UnicodeSetIterator(icu::UnicodeSetIterator *this)
{
  *(_QWORD *)this = off_1E2257640;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 7) = 0;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

{
  *(_QWORD *)this = off_1E2257640;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 7) = 0;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

icu::UnicodeSet *icu::UnicodeSetIterator::reset(icu::UnicodeSetIterator *this)
{
  icu::UnicodeSet *result;
  int v3;
  __int128 v4;

  result = (icu::UnicodeSet *)*((_QWORD *)this + 3);
  if (result)
  {
    *((_DWORD *)this + 8) = icu::UnicodeSet::getRangeCount(result) - 1;
    result = (icu::UnicodeSet *)icu::UnicodeSet::stringsSize(*((icu::UnicodeSet **)this + 3));
    v3 = *((_DWORD *)this + 8);
    *((_DWORD *)this + 13) = (_DWORD)result;
    *(_QWORD *)((char *)this + 36) = 0xFFFFFFFF00000000;
    *((_DWORD *)this + 11) = 0;
    if ((v3 & 0x80000000) == 0)
    {
      *((_DWORD *)this + 11) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), 0);
      result = (icu::UnicodeSet *)icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), 0);
      *((_DWORD *)this + 10) = (_DWORD)result;
    }
  }
  else
  {
    *((_DWORD *)this + 13) = 0;
    *(_QWORD *)&v4 = 0xFFFFFFFFLL;
    *((_QWORD *)&v4 + 1) = 0xFFFFFFFFLL;
    *((_OWORD *)this + 2) = v4;
  }
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 2) = 0;
  return result;
}

void icu::UnicodeSetIterator::~UnicodeSetIterator(icu::UnicodeSetIterator *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 7);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  icu::UObject::~UObject(this);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 7);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  icu::UObject::~UObject(this);
}

{
  uint64_t v2;
  void *v3;

  v2 = *((_QWORD *)this + 7);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  icu::UObject::~UObject(this);
  icu::UMemory::operator delete(v3);
}

uint64_t icu::UnicodeSetIterator::next(icu::UnicodeSetIterator *this)
{
  int v2;
  int v3;
  int v4;
  int RangeEnd;
  uint64_t v6;
  int v7;
  signed int v8;
  icu::UVector *v9;

  v2 = *((_DWORD *)this + 11);
  if (v2 <= *((_DWORD *)this + 10))
  {
    v6 = 0;
    *((_DWORD *)this + 11) = v2 + 1;
    *((_DWORD *)this + 2) = v2;
    *((_DWORD *)this + 3) = v2;
    goto LABEL_7;
  }
  v3 = *((_DWORD *)this + 9);
  if (v3 < *((_DWORD *)this + 8))
  {
    v4 = v3 + 1;
    *((_DWORD *)this + 9) = v3 + 1;
    *((_DWORD *)this + 11) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), v3 + 1);
    RangeEnd = icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), v4);
    v6 = 0;
    v7 = *((_DWORD *)this + 11);
    *((_DWORD *)this + 10) = RangeEnd;
    *((_DWORD *)this + 11) = v7 + 1;
    *((_DWORD *)this + 2) = v7;
    *((_DWORD *)this + 3) = v7;
LABEL_7:
    *((_QWORD *)this + 2) = v6;
    return 1;
  }
  v8 = *((_DWORD *)this + 12);
  if (v8 < *((_DWORD *)this + 13))
  {
    *((_DWORD *)this + 2) = -1;
    v9 = *(icu::UVector **)(*((_QWORD *)this + 3) + 80);
    *((_DWORD *)this + 12) = v8 + 1;
    v6 = icu::UVector::elementAt(v9, v8);
    goto LABEL_7;
  }
  return 0;
}

uint64_t icu::UnicodeSetIterator::loadRange(icu::UnicodeSetIterator *this, int a2)
{
  uint64_t result;

  *((_DWORD *)this + 11) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), a2);
  result = icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), a2);
  *((_DWORD *)this + 10) = result;
  return result;
}

uint64_t icu::UnicodeSetIterator::nextRange(icu::UnicodeSetIterator *this)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int RangeEnd;
  int v7;
  signed int v9;
  icu::UVector *v10;

  *((_QWORD *)this + 2) = 0;
  v3 = *((_DWORD *)this + 10);
  v2 = *((_DWORD *)this + 11);
  if (v2 <= v3)
  {
    *((_DWORD *)this + 2) = v2;
    *((_DWORD *)this + 3) = v3;
    v7 = v3 + 1;
    goto LABEL_5;
  }
  v4 = *((_DWORD *)this + 9);
  if (v4 < *((_DWORD *)this + 8))
  {
    v5 = v4 + 1;
    *((_DWORD *)this + 9) = v4 + 1;
    *((_DWORD *)this + 11) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), v4 + 1);
    RangeEnd = icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), v5);
    *((_DWORD *)this + 2) = *((_DWORD *)this + 11);
    *((_DWORD *)this + 3) = RangeEnd;
    v7 = RangeEnd + 1;
    *((_DWORD *)this + 10) = RangeEnd;
LABEL_5:
    *((_DWORD *)this + 11) = v7;
    return 1;
  }
  v9 = *((_DWORD *)this + 12);
  if (v9 < *((_DWORD *)this + 13))
  {
    *((_DWORD *)this + 2) = -1;
    v10 = *(icu::UVector **)(*((_QWORD *)this + 3) + 80);
    *((_DWORD *)this + 12) = v9 + 1;
    *((_QWORD *)this + 2) = icu::UVector::elementAt(v10, v9);
    return 1;
  }
  return 0;
}

uint64_t *icu::UnicodeSetIterator::getString@<X0>(icu::UnicodeSetIterator *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t *result;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;

  result = (uint64_t *)*((_QWORD *)this + 2);
  if (!result)
  {
    v5 = *((_DWORD *)this + 2);
    if (v5 == -1)
      return 0;
    v6 = *((_QWORD *)this + 7);
    if (!v6)
    {
      result = icu::UMemory::operator new(a3, (icu::UMemory *)0x40, a2);
      if (!result)
      {
        *((_QWORD *)this + 7) = 0;
LABEL_11:
        *((_QWORD *)this + 2) = result;
        return result;
      }
      v6 = (uint64_t)result;
      *result = (uint64_t)off_1E2256B38;
      *((_WORD *)result + 4) = 2;
      *((_QWORD *)this + 7) = result;
      v5 = *((_DWORD *)this + 2);
    }
    icu::UnicodeString::unBogus(v6);
    if (*(__int16 *)(v6 + 8) < 0)
      v7 = *(unsigned int *)(v6 + 12);
    else
      v7 = *(unsigned __int16 *)(v6 + 8) >> 5;
    icu::UnicodeString::replace((icu::UnicodeString *)v6, 0, v7, v5);
    result = (uint64_t *)*((_QWORD *)this + 7);
    goto LABEL_11;
  }
  return result;
}

uint64_t u_shapeArabic(UChar *src, uint64_t count, UChar *dest, int a4, int a5, int *a6)
{
  uint64_t v7;
  __int16 *v8;
  BOOL v11;
  BOOL v12;
  int v14;
  unsigned int v15;
  BOOL v16;
  BOOL v17;
  int v18;
  int v19;
  int v21;
  __int16 v22;
  void *v23;
  int v24;
  int v25;
  _WORD *v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  __int16 *v31;
  int v32;
  unsigned int v33;
  unsigned __int8 v34;
  __int16 v35;
  unsigned __int16 v36;
  int v37;
  void *v38;
  uint64_t v39;
  int v40;
  UChar *v41;
  UChar *v42;
  uint64_t v43;
  int v44;
  int v45;
  UChar *v47;
  int v48;
  uint64_t v49;
  UChar v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  __int128 *v58;
  UChar *v59;
  unsigned int v60;
  int v61;
  int *v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  UChar *v69;
  int v70;
  uint64_t v71;
  UChar v72;
  int32_t v73;
  int v74;
  int v75;
  unsigned __int8 v76;
  uint64_t v77;
  UChar *v78;
  int v79;
  uint64_t v80;
  UChar *v81;
  int v82;
  _BOOL4 v83;
  uint64_t v84;
  int v85;
  int v86;
  int v87;
  unsigned __int16 v88;
  unsigned __int16 v89;
  int v90;
  uint64_t v91;
  _WORD *v92;
  void *v93;
  unsigned __int8 v94;
  int v95;
  int v96;
  int v97;
  __int128 v98;
  int v99;
  int v100;
  _WORD v101[2];
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  __int128 v107;
  int v108;
  int v109;
  _WORD v110[2];
  int v111;
  int v112;
  int v113;
  int v114;
  int v115;
  UChar desta[300];
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  if (!a6 || *a6 > 0)
    return 0;
  v8 = (__int16 *)src;
  if (!src)
    goto LABEL_27;
  v7 = count;
  if ((int)count < -1)
    goto LABEL_27;
  v11 = dest || a4 == 0;
  v12 = !v11;
  if (a4 < 0)
    goto LABEL_27;
  if (v12)
    goto LABEL_27;
  v14 = a5 & 0x18;
  v15 = a5 & 0xE0000;
  if ((a5 & 0xE0000) != 0 && v14 == 24)
    goto LABEL_27;
  v16 = v15 && v14 == 16;
  v17 = v16;
  if ((a5 & 0x200) != 0)
    goto LABEL_27;
  if (v17)
    goto LABEL_27;
  v18 = a5 & 0xE0;
  if (v18 == 160 || (a5 & 0x1001B) != 0x18 && (a5 & 0x4000) != 0)
    goto LABEL_27;
  v21 = a5 & 0x10003;
  if ((a5 & 0x10003u) >= 4 && v21 != 0x10000)
    goto LABEL_27;
  if (v15 >> 17 > 6 || ((1 << (v15 >> 17)) & 0x5D) == 0)
    goto LABEL_27;
  if ((_DWORD)count == -1)
    v7 = u_strlen(src);
  if ((int)v7 > 0)
  {
    if (!dest
      || (v8 > (__int16 *)dest || &v8[v7] <= (__int16 *)dest)
      && (dest > (UChar *)v8 || &dest[a4] <= (UChar *)v8))
    {
      if ((a5 & 0x8000000) != 0)
        v22 = -397;
      else
        v22 = 8203;
      if (v14)
      {
        v88 = v22;
        bzero(desta, 0x258uLL);
        if ((a5 & 0x4000) != 0)
        {
          v85 = v21;
          if ((a5 & 4) != 0)
            v24 = -1;
          else
            v24 = 1;
          if ((a5 & 4) != 0)
            v25 = -1;
          else
            v25 = v7;
          v95 = v25;
          v26 = uprv_malloc(4 * (int)v7);
          if (!v26)
          {
            v29 = 0;
            v30 = 7;
LABEL_147:
            *a6 = v30;
            return v29;
          }
          v92 = v26;
          v86 = v18;
          if ((a5 & 4) != 0)
            v27 = v7;
          else
            v27 = -1;
          v28 = 2 * v7;
          if ((a5 & 4) == 0)
            v28 = -1;
          v97 = v28;
          if (v27 + v24 == v95)
          {
            v7 = 0;
          }
          else
          {
            v7 = 0;
            v89 = 0;
            v31 = &v8[v27 + (uint64_t)v24];
            v90 = v24;
            v91 = 2 * v24;
            v32 = v95 - (v27 + v24);
            v94 = 0;
            v96 = 1;
            do
            {
              v33 = (unsigned __int16)*v31;
              v34 = sub_18BC6668C(v33);
              if ((a5 & 0x4018) == 0x4018 && v96 && ((v34 | v94) & 0xC0) == 0xC0)
              {
                v35 = v89;
                if (v89 >= v33)
                  v35 = v33;
                v36 = v35 - 2542;
                v92[v97] = v36;
                v34 = sub_18BC6668C(v36);
                v96 = 0;
                v37 = v90;
              }
              else
              {
                v37 = v90;
                v92[v97 + v90] = v33;
                v7 = (v7 + 1);
                v96 = 1;
                v97 += v90;
                v89 = v33;
              }
              v31 = (__int16 *)((char *)v31 + v91);
              v94 = v34;
              v32 -= v37;
            }
            while (v32);
          }
          v23 = v92;
          v8 = &v92[v97 & (a5 << 29 >> 31)];
          v21 = v85;
          v18 = v86;
        }
        else
        {
          v23 = 0;
        }
        if (!v21 || (v29 = v7, v15 == 0x80000))
        {
          v38 = v23;
          v29 = sub_18BC66728(v8, v7, a5);
          v23 = v38;
        }
        if ((int)v29 > a4)
        {
          *a6 = 15;
          if (v23)
          {
            v39 = v29;
            uprv_free(v23);
            return v39;
          }
          return v29;
        }
        v93 = v23;
        v87 = v18;
        if ((int)v7 <= (int)v29)
          v40 = v29;
        else
          v40 = v7;
        if (v40 >= 301)
        {
          v42 = (UChar *)uprv_malloc((2 * v40));
          if (!v42)
          {
            *a6 = 7;
            if (v93)
              uprv_free(v93);
            return 0;
          }
          v41 = v42;
        }
        else
        {
          v40 = 300;
          v41 = desta;
        }
        u_memcpy(v41, (const UChar *)v8, v7);
        if (v93)
          uprv_free(v93);
        if (v40 > (int)v7)
          bzero(&v41[(int)v7], 2 * (v40 - (int)v7));
        if ((a5 & 4) == 0)
        {
          LODWORD(v43) = 0;
          v44 = (int)v7 > 0;
          if ((int)v7 >= 1 && *v41 == 32)
          {
            v43 = 0;
            do
            {
              v45 = v41[++v43];
              v44 = (int)v7 > (int)v43;
            }
            while (v45 == 32 && (int)v7 > (int)v43);
          }
          if (v44)
          {
            v47 = &v41[(int)v7 - 1];
            v44 = -1;
            do
            {
              v48 = *v47--;
              ++v44;
            }
            while (v48 == 32);
          }
          LODWORD(v49) = v7 + ~v44;
          if ((int)v49 > (int)v43)
          {
            v49 = (int)v49;
            v43 = (int)v43;
            do
            {
              v50 = v41[v43];
              v41[v43] = v41[v49];
              v41[v49] = v50;
              ++v43;
              --v49;
            }
            while (v43 < v49);
          }
        }
        if ((~a5 & 0x4000004) != 0)
        {
          v55 = 0;
          v51 = 3;
          v52 = 2;
          v53 = 0x40000;
          v54 = 393216;
        }
        else
        {
          v51 = 2;
          v52 = 3;
          v53 = 393216;
          v54 = 0x40000;
          v55 = 1;
        }
        if (v14 != 24)
        {
          if (v14 == 16)
          {
            LODWORD(v98) = v88;
            *(_QWORD *)((char *)&v98 + 4) = __PAIR64__(v52, v51);
            HIDWORD(v98) = v53;
            v99 = v54;
            v100 = v55;
            v57 = sub_18BC6708C(v41, v7, a5, a6, &v98);
          }
          else
          {
            if (v14 == 8)
            {
              if (!v15 || v15 == 786432)
              {
                LODWORD(v107) = v88;
                *(_QWORD *)((char *)&v107 + 4) = __PAIR64__(v52, v51);
                HIDWORD(v107) = v53;
                v108 = v54;
                v109 = v55;
                v56 = sub_18BC6687C(v41, v7, a5, a6, 1, &v107);
                if (v15 == 786432)
                  sub_18BC66FA8(v41, v56);
                v57 = v56;
                goto LABEL_128;
              }
              v110[0] = v88;
              v110[1] = 0;
              v111 = v51;
              v112 = v52;
              v113 = v53;
              v114 = v54;
              v115 = v55;
              v58 = (__int128 *)v110;
              v59 = v41;
              v60 = v7;
              v61 = a5;
              v62 = a6;
              v63 = 2;
              goto LABEL_127;
            }
            v57 = 0;
          }
LABEL_128:
          v64 = v57;
          if ((a5 & 4) == 0)
          {
            LODWORD(v65) = 0;
            v66 = (int)v57 > 0;
            if ((int)v57 >= 1 && *v41 == 32)
            {
              v65 = 0;
              do
              {
                v67 = v41[++v65];
                v66 = (int)v57 > (int)v65;
              }
              while (v67 == 32 && (int)v57 > (int)v65);
            }
            if (v66)
            {
              v69 = &v41[(int)v57 - 1];
              v66 = -1;
              do
              {
                v70 = *v69--;
                ++v66;
              }
              while (v70 == 32);
            }
            LODWORD(v71) = v57 + ~v66;
            if ((int)v71 > (int)v65)
            {
              v71 = (int)v71;
              v65 = (int)v65;
              do
              {
                v72 = v41[v65];
                v41[v65] = v41[v71];
                v41[v71] = v72;
                ++v65;
                --v71;
              }
              while (v65 < v71);
            }
          }
          v73 = uprv_min(v57, a4);
          u_memcpy(dest, v41, v73);
          if (v41 != desta)
            uprv_free(v41);
          v29 = v64;
          if ((int)v64 > a4)
          {
            v30 = 15;
            goto LABEL_147;
          }
          v18 = v87;
LABEL_150:
          if (v18)
          {
            if ((a5 & 0x300) == 0x100)
              v74 = 1776;
            else
              v74 = 0;
            if ((a5 & 0x300) != 0)
              v75 = v74;
            else
              v75 = 1632;
            v76 = 0;
            switch((v18 - 32) >> 5)
            {
              case 0u:
                if ((int)v29 >= 1)
                {
                  v77 = v29;
                  v78 = dest;
                  do
                  {
                    v79 = *v78;
                    if ((v79 - 48) <= 9)
                      *v78 = v75 - 48 + v79;
                    ++v78;
                    --v77;
                  }
                  while (v77);
                }
                break;
              case 1u:
                if ((int)v29 >= 1)
                {
                  v80 = v29;
                  v81 = dest;
                  do
                  {
                    v82 = *v81;
                    if ((v82 - v75) <= 9)
                      *v81 = v82 - v75 + 48;
                    ++v81;
                    --v80;
                  }
                  while (v80);
                }
                break;
              case 2u:
                goto LABEL_171;
              case 3u:
                v76 = 1;
LABEL_171:
                v83 = (a5 & 4) == 0;
                v84 = v29;
                sub_18BC6724C((uint64_t)dest, v29, v75, v83, v76);
                v29 = v84;
                break;
              default:
                return u_terminateUChars((uint64_t)dest, a4, v29, a6);
            }
          }
          return u_terminateUChars((uint64_t)dest, a4, v29, a6);
        }
        v101[0] = v88;
        v101[1] = 0;
        v102 = v51;
        v103 = v52;
        v104 = v53;
        v105 = v54;
        v106 = v55;
        v58 = (__int128 *)v101;
        v59 = v41;
        v60 = v7;
        v61 = a5;
        v62 = a6;
        v63 = 0;
LABEL_127:
        v57 = sub_18BC6687C(v59, v60, v61, v62, v63, v58);
        goto LABEL_128;
      }
      if (v7 <= a4)
      {
        u_memcpy(dest, (const UChar *)v8, v7);
        v29 = v7;
        goto LABEL_150;
      }
      v19 = 15;
LABEL_28:
      *a6 = v19;
      return v7;
    }
LABEL_27:
    v7 = 0;
    v19 = 1;
    goto LABEL_28;
  }
  return u_terminateUChars((uint64_t)dest, a4, 0, a6);
}

uint64_t sub_18BC6668C(int a1)
{
  int v2;
  unsigned __int8 *v3;

  if ((a1 - 1570) <= 0xB1)
    return word_18BE19F48[a1 - 1570];
  if (a1 == 8205)
    return 3;
  if ((a1 - 8301) < 3)
    return 4;
  if ((unsigned __int16)(a1 + 1200) <= 0x112u)
  {
    v2 = a1 - 64336;
    v3 = (unsigned __int8 *)&unk_18BE1A0AC;
    return v3[v2];
  }
  if ((unsigned __int16)(a1 + 400) <= 0x8Cu)
  {
    v2 = a1 - 65136;
    v3 = (unsigned __int8 *)&unk_18BE1A1BF;
    return v3[v2];
  }
  return 0;
}

uint64_t sub_18BC66728(__int16 *a1, uint64_t a2, int a3)
{
  BOOL v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v9;
  BOOL v10;
  int v11;
  uint64_t v13;
  __int16 v14;
  unint64_t v15;
  int v16;
  BOOL v17;

  v3 = (a3 & 0x1000B) == 8 || (a3 & 0xE0018) == 524296;
  v4 = a2;
  if (v3)
  {
    v5 = (a2 - 1);
    if ((a3 & 4) == 0)
    {
      if ((int)a2 >= 1)
      {
        v6 = 0;
        v4 = a2;
        while (1)
        {
          v7 = (unsigned __int16)a1[v6];
          if (v7 != 1604 || v6 >= v5)
          {
            if ((v7 & 0xFFF0) != 0xFE70)
              goto LABEL_21;
          }
          else
          {
            v9 = (unsigned __int16)a1[v6 + 1] - 1570;
            v10 = v9 > 5;
            v11 = (1 << v9) & 0x2B;
            if (v10 || v11 == 0)
              goto LABEL_21;
          }
          v4 = (v4 - 1);
LABEL_21:
          if (a2 == ++v6)
            goto LABEL_22;
        }
      }
      return a2;
    }
    if ((int)a2 < 1)
      return a2;
    v15 = 0;
    v4 = a2;
    while (1)
    {
      v16 = (unsigned __int16)a1[v15];
      v17 = (v16 - 1570) > 5 || ((1 << (v16 - 34)) & 0x2B) == 0;
      if (!v17 && v15 < v5)
        break;
      if ((v16 & 0xFFF0) == 0xFE70)
        goto LABEL_41;
LABEL_42:
      if (a2 == ++v15)
        goto LABEL_22;
    }
    if (a1[v15 + 1] != 1604)
      goto LABEL_42;
LABEL_41:
    v4 = (v4 - 1);
    goto LABEL_42;
  }
LABEL_22:
  if ((a3 & 0x1001B) == 0x10 && (int)a2 >= 1)
  {
    v13 = a2;
    do
    {
      v14 = *a1++;
      if ((unsigned __int16)(v14 + 267) >= 8u)
        v4 = v4;
      else
        v4 = (v4 + 1);
      --v13;
    }
    while (v13);
  }
  return v4;
}

uint64_t sub_18BC6687C(UChar *a1, unsigned int a2, int a3, _DWORD *a4, int a5, __int128 *a6)
{
  uint64_t v7;
  UChar *v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  char v26;
  int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  UChar *v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  size_t v40;
  char *v41;
  char *v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  UChar *v47;
  uint64_t v48;
  int v49;
  int v50;
  BOOL v51;
  int v52;
  unsigned int v55;
  uint64_t v56;
  UChar *v57;
  _BOOL4 v58;
  char v59;
  int v60;
  signed int v61;
  uint64_t v62;
  int v63;
  char v64;
  _BOOL4 v65;
  _BOOL4 v66;
  char v67;
  unsigned int v68;
  int v69;
  uint64_t v70;
  UChar *v71;
  int v72;
  int v73;
  char v74;
  _BOOL4 v75;
  uint64_t v76;
  int v81;
  int v84;
  uint64_t v85;
  int v86;
  __int128 v87;
  uint64_t v88;

  if ((a3 & 0x8000) == 0 && (int)a2 >= 1)
  {
    v7 = a2;
    v8 = a1;
    while (1)
    {
      v9 = *v8;
      if ((unsigned __int16)(v9 + 1200) <= 0xAFu)
        break;
      if ((unsigned __int16)(v9 + 400) <= 0x8Cu)
      {
        LOWORD(v9) = word_18BE1A3B0[v9 - 65136];
LABEL_9:
        *v8 = v9;
      }
LABEL_10:
      ++v8;
      if (!--v7)
        goto LABEL_11;
    }
    v9 = word_18BE1A250[v9 - 64336];
    if (!v9)
      goto LABEL_10;
    goto LABEL_9;
  }
LABEL_11:
  if (a2)
  {
    v10 = a2 - 1;
    v11 = sub_18BC6668C(a1[a2 - 1]);
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v81 = 0;
    v15 = 0;
    v85 = 0;
    v16 = -2;
    v17 = v10;
    while (1)
    {
      if (v11 <= 0xFF && (sub_18BC6668C(a1[v17]) & 4) == 0)
      {
        v18 = v17;
        goto LABEL_67;
      }
      if (v16 < 0)
      {
        v19 = v17 - 1;
        while (v19 != -1)
        {
          v20 = sub_18BC6668C(a1[v19]);
          if ((v20 & 4) == 0)
            v16 = v19;
          v19 -= (v20 & 4) >> 2;
          if ((v16 & 0x80000000) == 0)
          {
            v12 = v20;
            goto LABEL_23;
          }
        }
        v12 = 0;
        v16 = 3000;
        if ((v11 & 0x20) == 0)
        {
LABEL_29:
          v18 = v17;
          goto LABEL_32;
        }
      }
      else
      {
LABEL_23:
        if ((v11 & 0x20) == 0)
          goto LABEL_29;
      }
      if ((v13 & 0x10) == 0)
        goto LABEL_29;
      v21 = a1[v17] - 1570;
      if (v21 <= 5 && ((0x2Bu >> v21) & 1) != 0)
      {
        v22 = word_18BE1A536[(__int16)v21];
        a1[v17] = -1;
        a1[v10] = v22;
        v17 = v10;
      }
      else
      {
        v22 = 0;
      }
      v11 = sub_18BC6668C(v22);
      LODWORD(v85) = 1;
      v18 = v17;
      v13 = v14;
LABEL_32:
      if (v18 < 1)
      {
        if (!v18)
        {
          v23 = *a1;
          goto LABEL_37;
        }
      }
      else if (a1[v18 - 1] == 32)
      {
        v23 = a1[v18];
LABEL_37:
        v24 = v23 - 1591;
        if (v23 == 1574)
          v25 = 1;
        else
          v25 = v15;
        v26 = (v24 != -5) & __CFADD__(v24, 5);
        v27 = HIDWORD(v85);
        if (v26)
          v27 = 1;
        HIDWORD(v85) = v27;
        if (!v26)
          v15 = v25;
      }
      v28 = byte_18BE1A4CA[16 * (v12 & 3) + 4 * (v13 & 3) + (v11 & 3)];
      if ((v11 & 3) == 1)
      {
        v28 &= 1u;
        v29 = v18;
        v30 = a1[v18];
      }
      else
      {
        v29 = v18;
        v31 = &a1[v18];
        v30 = *v31;
        if (v30 - 1619 >= 0xFFFFFFF8)
        {
          if ((v13 & 2) != 0 && a5 == 1 && (v12 & 1) != 0)
          {
            if ((v30 & 0xFFFE) == 0x64C)
            {
              v28 = 0;
            }
            else
            {
              v28 = (v12 & 0x20) == 0;
              if ((v13 & 0x10) == 0)
                v28 = 1;
            }
          }
          else
          {
            v28 = 0;
            if (a5 == 2 && v30 == 1617)
            {
              LOWORD(v28) = 1;
LABEL_64:
              v32 = byte_18BE1A50A[v30 - 1611];
              LOWORD(v28) = v28 - 400;
LABEL_66:
              *v31 = v28 + v32;
              goto LABEL_67;
            }
          }
        }
      }
      if ((v30 ^ 0x600) <= 0xFF)
      {
        v31 = &a1[v29];
        if (v30 - 1619 < 0xFFFFFFF8)
        {
          if ((v11 & 8) != 0)
          {
            v28 += v11 >> 8;
            v32 = -1200;
          }
          else
          {
            if (v11 < 0x100 || (v11 & 4) != 0)
              goto LABEL_67;
            v28 += v11 >> 8;
            v32 = -400;
          }
          goto LABEL_66;
        }
        if (a5 != 2 || v30 == 1617)
          goto LABEL_64;
        *v31 = -2;
        v81 = 1;
      }
LABEL_67:
      if ((v11 & 4) == 0)
      {
        v10 = v18;
        v14 = v13;
        v13 = v11;
      }
      v17 = v18 - 1;
      if (v18 - 1 == v16)
      {
        v16 = -2;
        v11 = v12;
        if (!v18)
          goto LABEL_77;
      }
      else
      {
        if (!v18)
          goto LABEL_77;
        v11 = sub_18BC6668C(a1[v17]);
      }
    }
  }
  v85 = 0;
  v15 = 0;
  v81 = 0;
LABEL_77:
  v33 = a2;
  v34 = a2;
  if (v85 | v81)
  {
    v35 = *((_DWORD *)a6 + 1);
    v36 = *((_DWORD *)a6 + 2);
    v37 = *((_DWORD *)a6 + 3);
    v38 = *((_DWORD *)a6 + 4);
    v39 = *((_DWORD *)a6 + 5);
    v40 = (int)(2 * a2 + 2);
    v41 = (char *)uprv_malloc(v40);
    if (!v41)
    {
      v34 = 0;
      *a4 = 7;
      goto LABEL_156;
    }
    v42 = v41;
    v84 = v39;
    v86 = v38;
    v43 = a3 & 0xE0000;
    v44 = a3 & 0x10003;
    if ((a3 & 0x10003) != 0)
    {
      v34 = a2;
      if (v43 != 0x80000)
      {
LABEL_105:
        if (v44 == 1)
        {
          v34 = a2;
          if ((int)a2 < 1)
          {
            if (v35 == 1)
            {
LABEL_115:
              v58 = v43 == v37;
              v59 = 1;
              goto LABEL_116;
            }
LABEL_163:
            if (v43 != v37)
              goto LABEL_133;
            v59 = 0;
            v58 = 1;
LABEL_116:
            bzero(v42, v40);
            if ((a2 & 0x80000000) == 0)
            {
              v60 = 0;
              v61 = a2;
              v62 = a2;
              do
              {
                v63 = a1[v62];
                if (v63 == 0xFFFF)
                  v64 = v59;
                else
                  v64 = 0;
                v65 = v63 == 65534 && v58;
                if ((v64 & 1) != 0 || v65)
                {
                  ++v61;
                  ++v60;
                }
                else
                {
                  *(_WORD *)&v42[2 * v61] = v63;
                }
                --v61;
                v26 = v62-- <= 0;
              }
              while (!v26);
              if (v60 >= 1)
                memset_pattern16(v42, asc_18BE1A550, 2 * v60);
            }
            v34 = a2;
            u_memcpy(a1, (const UChar *)v42, a2);
LABEL_133:
            if (v44 == v36 || v44 == 0x10000 && !v84)
            {
              v66 = v43 == v86;
              v67 = 1;
              v33 = a2;
            }
            else
            {
              v51 = v43 == v86;
              v33 = a2;
              if (!v51)
                goto LABEL_155;
              v67 = 0;
              v66 = 1;
            }
            bzero(v42, v40);
            if ((int)v33 < 1)
            {
              v68 = 0;
              v76 = 0;
            }
            else
            {
              v68 = 0;
              v69 = 0;
              v70 = v33;
              v71 = a1;
              do
              {
                v73 = *v71++;
                v72 = v73;
                if (v73 == 0xFFFF)
                  v74 = v67;
                else
                  v74 = 0;
                v75 = v72 == 65534 && v66;
                if ((v74 & 1) != 0 || v75)
                {
                  --v69;
                  ++v68;
                }
                else
                {
                  *(_WORD *)&v42[2 * v69] = v72;
                }
                ++v69;
                --v70;
              }
              while (v70);
              if ((v68 & 0x80000000) != 0)
                goto LABEL_154;
              v76 = 2 * v33;
            }
            memset_pattern16(&v42[v76 - 2 * v68], asc_18BE1A550, 2 * (v68 + 1));
LABEL_154:
            u_memcpy(a1, (const UChar *)v42, v33);
            v34 = v33;
LABEL_155:
            uprv_free(v42);
            goto LABEL_156;
          }
          v56 = a2;
          v57 = a1;
          do
          {
            if ((__int16)*v57 == -1)
              *v57 = 32;
            ++v57;
            --v56;
          }
          while (v56);
          v34 = a2;
        }
        if (v44 == v35 || v44 == 0x10000 && v84 == 1)
          goto LABEL_115;
        goto LABEL_163;
      }
    }
    bzero(v41, v40);
    if ((int)a2 < 1)
    {
      v45 = 0;
      v55 = 0;
    }
    else
    {
      v45 = 0;
      v46 = 0;
      v47 = a1;
      v48 = a2;
      do
      {
        v50 = *v47++;
        v49 = v50;
        v51 = v43 == 0x80000 && v49 == 65534;
        v52 = v51;
        if ((v49 != 0xFFFF || v44 != 0) && v52 == 0)
        {
          *(_WORD *)&v42[2 * v46] = v49;
        }
        else
        {
          --v46;
          ++v45;
        }
        ++v46;
        --v48;
      }
      while (v48);
      v55 = a2;
      if ((v45 & 0x80000000) != 0)
        goto LABEL_104;
    }
    bzero(&v42[2 * (v55 - (unint64_t)v45)], 2 * (v45 + 1));
LABEL_104:
    u_memcpy(a1, (const UChar *)v42, a2);
    v34 = u_strlen(a1);
    goto LABEL_105;
  }
LABEL_156:
  if (HIDWORD(v85) | v15)
  {
    v87 = *a6;
    v88 = *((_QWORD *)a6 + 2);
    return sub_18BC67364(a1, v33, v34, a3, a4, 0, (uint64_t)&v87);
  }
  return v34;
}

uint64_t sub_18BC66FA8(_WORD *a1, uint64_t a2)
{
  uint64_t i;
  int v3;
  int v5;

  if ((int)a2 >= 1)
  {
    for (i = a2; i; --i)
    {
      v3 = (unsigned __int16)*a1;
      if ((v3 & 0xFFF0) == 0xFE70)
      {
        if (v3 != 65139 && v3 != 65141)
        {
          if (v3 == 65149)
            goto LABEL_24;
          if (((0xAA82uLL >> (v3 - 112)) & 1) != 0)
          {
            LOWORD(v3) = 1600;
            goto LABEL_24;
          }
          if (v3 != 65139 && v3 != 65141)
          {
            v5 = 1 - byte_18BE1A526[v3 - 65136];
            goto LABEL_20;
          }
        }
      }
      else if ((v3 - 64754) < 3 || v3 == 65149)
      {
        LOWORD(v3) = -387;
        goto LABEL_24;
      }
      v5 = (unsigned __int16)(v3 + 930) < 6u;
LABEL_20:
      if (v3 == 65148 || !v5)
        goto LABEL_25;
      LOWORD(v3) = 32;
LABEL_24:
      *a1 = v3;
LABEL_25:
      ++a1;
    }
  }
  return a2;
}

uint64_t sub_18BC6708C(UChar *a1, uint64_t a2, int a3, _DWORD *a4, __int128 *a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  int v10;
  unsigned __int16 v11;
  UChar *v12;
  int v13;
  BOOL v14;
  BOOL v15;
  UChar v16;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v7 = (a2 - 1);
  if ((int)a2 < 1)
    return a2;
  v20 = v5;
  v21 = v6;
  v8 = 0;
  v9 = 0;
  do
  {
    v10 = a1[v8];
    if ((unsigned __int16)(v10 + 1200) > 0xAFu)
    {
      if ((a3 & 0x3800000) == 0x1000000 && (v10 == 65152 || v10 == 1569) && v8 < v7)
      {
        v12 = &a1[v8];
        v13 = v12[1];
        if ((v13 - 65263) < 2 || v13 == 1609)
        {
          LOWORD(v10) = 32;
          a1[v8] = 32;
          v12[1] = 1574;
          goto LABEL_27;
        }
      }
      if ((a3 & 0x700000) != 0x200000
        || (v10 != 8203 ? (v14 = v10 == 65139) : (v14 = 1),
            v14 ? (v15 = v8 >= v7) : (v15 = 1),
            v15
         || (v16 = a1[v8 + 1], (unsigned __int16)(v16 + 335) > 0xDu)
         || ((0xCCCuLL >> (v16 + 79)) & 1) != 0))
      {
        if ((unsigned __int16)(v10 + 400) > 0x84u)
          goto LABEL_27;
        LOWORD(v10) = word_18BE1A3B0[v10 - 65136];
      }
      else
      {
        LOWORD(v10) = 32;
      }
      a1[v8] = v10;
    }
    else
    {
      v11 = word_18BE1A250[v10 - 64336];
      if (v11)
      {
        a1[v8] = v11;
        LOWORD(v10) = v11;
      }
    }
LABEL_27:
    if ((unsigned __int16)(v10 + 259) >= 0xFFF8u)
      v9 = 1;
    ++v8;
  }
  while (a2 != v8);
  if (v9)
  {
    v18 = *a5;
    v19 = *((_QWORD *)a5 + 2);
    return sub_18BC67364(a1, a2, a2, a3, a4, 1, (uint64_t)&v18);
  }
  return a2;
}

uint64_t sub_18BC6724C(uint64_t result, int a2, __int16 a3, int a4, unsigned __int8 a5)
{
  _WORD *v5;
  int v6;
  __int16 v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;

  v5 = (_WORD *)result;
  v6 = a5;
  v7 = a3 - 48;
  if (a4)
  {
    if (a2 >= 1)
    {
      v8 = a2;
      do
      {
        v9 = (unsigned __int16)*v5;
        result = ubidi_getClass(v9);
        if (result < 2)
        {
          v6 = 0;
        }
        else if ((_DWORD)result == 2)
        {
          if (v6)
          {
            if (v9 - 48 <= 9)
              *v5 = v9 + v7;
            v6 = 1;
          }
        }
        else if ((_DWORD)result == 13)
        {
          v6 = 1;
        }
        ++v5;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    v10 = a2 - 1;
    if (a2 >= 1)
    {
      v11 = a2 + 1;
      do
      {
        v12 = (unsigned __int16)v5[v10];
        v13 = v10;
        result = ubidi_getClass(v12);
        if (result < 2)
        {
          v6 = 0;
        }
        else if ((_DWORD)result == 2)
        {
          if (v6)
          {
            if (v12 - 48 <= 9)
              v5[v13] = v12 + v7;
            v6 = 1;
          }
        }
        else if ((_DWORD)result == 13)
        {
          v6 = 1;
        }
        --v11;
        v10 = v13 - 1;
      }
      while (v11 > 1);
    }
  }
  return result;
}

uint64_t sub_18BC67364(UChar *a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, int a6, uint64_t a7)
{
  int v14;
  _BOOL4 v16;
  _BOOL4 v17;
  _BOOL4 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _WORD *v22;
  uint64_t v23;
  BOOL v24;
  int v25;
  uint64_t v26;
  UChar v27;
  UChar v28;
  uint64_t v29;
  uint64_t v30;
  UChar *v31;
  uint64_t v32;
  uint64_t v33;
  size_t v34;
  UChar *v35;
  UChar *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;

  v14 = a4 & 0x10003;
  if ((a4 & 0x10003) == 0x10000 && a6 == 1)
  {
    if (*(_DWORD *)(a7 + 20))
    {
      v19 = sub_18BC678FC(a1, a2, a5);
      if (*a5 == 20)
      {
        *a5 = 0;
        v20 = sub_18BC67750(a1, a2, a5);
        goto LABEL_17;
      }
    }
    else
    {
      v19 = sub_18BC67750(a1, a2, a5);
      if (*a5 == 20)
      {
        *a5 = 0;
        v20 = sub_18BC678FC(a1, a2, a5);
LABEL_17:
        a3 = v20;
        if (*a5 != 20)
          goto LABEL_27;
        *a5 = 0;
        a3 = a2;
        if ((int)a2 < 1)
          goto LABEL_27;
        v21 = a2;
        v22 = a1 + 1;
        do
        {
          v23 = (unsigned __int16)*v22;
          if ((unsigned __int16)(v23 + 259) >= 0xFFF8u)
          {
            if (*(v22 - 1) == 32)
            {
              *v22 = 1604;
              *(v22 - 1) = word_18BE1A512[v23 - 65269];
            }
            else
            {
              *a5 = 20;
            }
          }
          ++v22;
          --v21;
        }
        while (v21);
        a3 = a2;
        goto LABEL_5;
      }
    }
    a3 = v19;
    goto LABEL_27;
  }
LABEL_5:
  if (a6 != 1)
  {
    v16 = (a4 & 0x3800000) == 0x1000000;
    v17 = (a4 & 0x700000) == 0x200000;
    if (a6)
    {
      v16 = 0;
      v18 = 0;
    }
    else
    {
      v18 = (a4 & 0x700000) == 0x200000;
    }
    if (a6)
      v17 = 0;
    goto LABEL_32;
  }
LABEL_27:
  if (v14 == *(_DWORD *)(a7 + 8))
    a3 = sub_18BC67750(a1, a2, a5);
  if (v14 == *(_DWORD *)(a7 + 4))
    a3 = sub_18BC678FC(a1, a2, a5);
  v16 = 0;
  v18 = 0;
  v17 = 0;
LABEL_32:
  v24 = v14 == 1 && a6 == 1;
  v25 = v24;
  if (v24 || v16 || v18)
  {
    a3 = a2;
    if ((int)a2 >= 1)
    {
      v26 = 0;
      v27 = *(_WORD *)a7;
      while (1)
      {
        if (!v17
          || (v28 = a1[v26], (unsigned __int16)(v28 + 335) > 0xDu)
          || ((0xCCCuLL >> (v28 + 79)) & 1) != 0)
        {
          if (v16 && (v30 = a1[v26], (unsigned __int16)(v30 + 373) >= 0xFFFEu))
          {
            if (!v26)
              goto LABEL_58;
            v33 = (v26 - 1);
            if (a1[v33] != 32)
              goto LABEL_58;
            a1[v26] = word_18BE1A522[v30 - 65161];
            a1[v33] = -384;
          }
          else
          {
            if (!v25)
              goto LABEL_59;
            v31 = &a1[v26];
            v32 = v31[1];
            if ((unsigned __int16)(v32 + 259) < 0xFFF8u)
              goto LABEL_59;
            if (a1[v26] != 32)
            {
LABEL_58:
              *a5 = 20;
              goto LABEL_59;
            }
            v31[1] = 1604;
            a1[v26] = word_18BE1A512[v32 - 65269];
          }
        }
        else
        {
          if (!v26)
            goto LABEL_58;
          v29 = (v26 - 1);
          if (a1[v29] != 32)
            goto LABEL_58;
          a1[v29] = v27;
        }
LABEL_59:
        if (a2 == ++v26)
        {
          a3 = a2;
          break;
        }
      }
    }
  }
  if (!v14 && a6 == 1)
  {
    a3 = sub_18BC66728((__int16 *)a1, a2, a4);
    v34 = 2 * (int)a3 + 2;
    v35 = (UChar *)uprv_malloc(v34);
    if (v35)
    {
      v36 = v35;
      bzero(v35, v34);
      if ((int)a3 >= 1)
      {
        v37 = 0;
        v38 = 0;
        do
        {
          v39 = a1[v37];
          if ((unsigned __int16)(v39 + 259) >= 0xFFF8u)
          {
            v36[v38++] = word_18BE1A512[v39 - 65269];
            LOWORD(v39) = 1604;
          }
          v36[v38] = v39;
          if (++v37 >= (unint64_t)a3)
            break;
          ++v38;
        }
        while (v38 < (int)a3);
      }
      u_memcpy(a1, v36, a3);
      uprv_free(v36);
    }
    else
    {
      a3 = 0;
      *a5 = 7;
    }
  }
  return a3;
}

uint64_t sub_18BC67750(UChar *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4;
  size_t v6;
  UChar *v7;
  UChar *v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v18;

  v4 = a2;
  v6 = 2 * (int)a2 + 2;
  v7 = (UChar *)uprv_malloc(v6);
  if (v7)
  {
    v8 = v7;
    bzero(v7, v6);
    v9 = 0;
    v10 = v4 - 1;
    v11 = 2 * (int)v4 - 2;
    do
    {
      v12 = *(UChar *)((char *)a1 + v11);
      ++v9;
      v11 -= 2;
    }
    while (v12 == 32);
    v13 = (v4 - v9);
    v14 = v9 - 1;
    if ((v13 & 0x80000000) == 0 && (int)v4 >= 1)
    {
      v15 = v4 - 1;
      while (1)
      {
        if (v14 < 1)
        {
          LOWORD(v16) = a1[v13];
          if (!v14 && (unsigned __int16)(v16 + 259) >= 0xFFF8u)
            *a3 = 20;
        }
        else
        {
          v16 = a1[v13];
          if ((unsigned __int16)(v16 + 259) >= 0xFFF8u)
          {
            v8[v15--] = 1604;
            v8[v15] = word_18BE1A512[v16 - 65269];
            --v14;
            goto LABEL_14;
          }
        }
        v8[v15] = v16;
LABEL_14:
        if ((int)v13 >= 1)
        {
          --v13;
          if (v15-- > 0)
            continue;
        }
        break;
      }
    }
    if (v14 >= 1)
    {
      u_memmove(v8, &v8[v14], v4);
      if (u_strlen(v8) < (int)v4)
      {
        v18 = v4 - v14;
        if ((int)v4 - v14 >= v10)
          v18 = v4 - 1;
        memset_pattern16(&v8[(int)v4 - (v10 - v18) - 1], asc_18BE1A550, 2 * (v10 - v18) + 2);
      }
    }
    u_memcpy(a1, v8, v4);
    uprv_free(v8);
  }
  else
  {
    v4 = 0;
    *a3 = 7;
  }
  return v4;
}

uint64_t sub_18BC678FC(UChar *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4;
  size_t v6;
  UChar *v7;
  UChar *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  BOOL v14;

  v4 = a2;
  v6 = 2 * (int)a2 + 2;
  v7 = (UChar *)uprv_malloc(v6);
  if (v7)
  {
    v8 = v7;
    bzero(v7, v6);
    if (*a1 == 32)
    {
      v9 = 0;
      do
        v10 = a1[++v9];
      while (v10 == 32);
    }
    else
    {
      LODWORD(v9) = 0;
    }
    v11 = (v4 - 1);
    if ((int)v4 >= 1)
    {
      v12 = v4 - 1;
      while (1)
      {
        if ((int)v9 < 1)
        {
          LOWORD(v13) = a1[v11];
          if (!(_DWORD)v9 && (unsigned __int16)(v13 + 259) >= 0xFFF8u)
            *a3 = 20;
        }
        else
        {
          v13 = a1[v11];
          if ((unsigned __int16)(v13 + 259) >= 0xFFF8u)
          {
            v8[v12--] = 1604;
            v8[v12] = word_18BE1A512[v13 - 65269];
            LODWORD(v9) = v9 - 1;
            goto LABEL_17;
          }
        }
        v8[v12] = v13;
LABEL_17:
        v14 = v11-- < 1;
        if (!v14)
        {
          v14 = v12-- <= 0;
          if (!v14)
            continue;
        }
        break;
      }
    }
    u_memcpy(a1, v8, v4);
    uprv_free(v8);
  }
  else
  {
    v4 = 0;
    *a3 = 7;
  }
  return v4;
}

uint64_t usprep_open(char *a1, const char *a2, int *a3)
{
  uint64_t v4;
  unsigned int v8;
  int32x2_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  _QWORD *v14;
  _OWORD *v15;
  uint64_t Memory;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  signed int v22;
  char v23;
  char **v24;
  unsigned int v25;
  char *v26;
  unsigned int v27;
  char *v28;
  uint64_t *v29;
  int v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t *v33;
  char *v34;
  char **v35;
  _QWORD v36[2];
  UVersionInfo versionArray;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  if (a3 && *a3 <= 0)
  {
    v8 = atomic_load(&dword_1EE009660);
    if (v8 == 2 || !icu::umtx_initImplPreInit(&dword_1EE009660))
    {
      if (dword_1EE009664 >= 1)
      {
        v4 = 0;
        *a3 = dword_1EE009664;
        return v4;
      }
    }
    else
    {
      v9 = uhash_open((uint64_t)sub_18BC68ACC, (uint64_t)sub_18BC68B04, 0, a3);
      v10 = *a3 >= 1 ? 0 : (uint64_t)v9;
      qword_1EE009658 = v10;
      sub_18BC0ECC4(1u, (uint64_t)sub_18BC68B4C);
      dword_1EE009664 = *a3;
      icu::umtx_initImplPostInit(&dword_1EE009660);
    }
    if (*a3 <= 0)
    {
      v36[0] = a2;
      v36[1] = a1;
      umtx_lock((icu::UMutex *)&unk_1EE009670);
      v11 = uhash_get(qword_1EE009658, (uint64_t)v36);
      if (v11)
      {
        v4 = v11;
        ++*(_DWORD *)(v11 + 120);
        umtx_unlock((std::mutex **)&unk_1EE009670);
        return v4;
      }
      umtx_unlock((std::mutex **)&unk_1EE009670);
      v12 = (uint64_t *)uprv_malloc(0x80uLL);
      v13 = v12;
      if (!v12)
      {
        *a3 = 7;
LABEL_23:
        uprv_free(v13);
        return 0;
      }
      *((_OWORD *)v12 + 6) = 0u;
      *((_OWORD *)v12 + 7) = 0u;
      *((_OWORD *)v12 + 4) = 0u;
      *((_OWORD *)v12 + 5) = 0u;
      *((_OWORD *)v12 + 2) = 0u;
      *((_OWORD *)v12 + 3) = 0u;
      *(_OWORD *)v12 = 0u;
      *((_OWORD *)v12 + 1) = 0u;
      uprv_free(0);
      v40 = 0;
      v38 = 0u;
      v39 = 0u;
      if (*a3 > 0)
        goto LABEL_23;
      v14 = udata_openChoice(a1, "spp", a2, (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18BC68C50, 0, (UErrorCode *)a3);
      if (*a3 > 0)
        goto LABEL_23;
      v15 = v14;
      *(_DWORD *)versionArray = 0;
      Memory = udata_getMemory((uint64_t)v14);
      utrie_unserialize((uint64_t)&v38, (_DWORD *)(Memory + 64), *(_DWORD *)Memory, a3);
      *(_QWORD *)&v39 = nullsub_21;
      if (*a3 > 0)
        goto LABEL_26;
      umtx_lock((icu::UMutex *)&unk_1EE009670);
      v17 = v13[14];
      if (v17)
      {
        Memory = udata_getMemory(v17);
      }
      else
      {
        v13[14] = (uint64_t)v15;
        v18 = *(_OWORD *)Memory;
        v19 = *(_OWORD *)(Memory + 16);
        v20 = *(_OWORD *)(Memory + 48);
        *((_OWORD *)v13 + 2) = *(_OWORD *)(Memory + 32);
        *((_OWORD *)v13 + 3) = v20;
        *(_OWORD *)v13 = v18;
        *((_OWORD *)v13 + 1) = v19;
        v21 = v39;
        *((_OWORD *)v13 + 4) = v38;
        *((_OWORD *)v13 + 5) = v21;
        v13[12] = v40;
        v15 = 0;
      }
      umtx_unlock((std::mutex **)&unk_1EE009670);
      v13[13] = Memory + *(int *)v13 + 64;
      u_getUnicodeVersion(versionArray);
      if (*a3 > 0)
      {
LABEL_26:
        udata_close(v15);
        goto LABEL_23;
      }
      v22 = bswap32(*(unsigned int *)versionArray);
      if (v22 < (int)bswap32(dword_1EE009668) && v22 < *((_DWORD *)v13 + 2) && (*((_BYTE *)v13 + 28) & 1) != 0)
      {
        *a3 = 3;
        goto LABEL_26;
      }
      *((_BYTE *)v13 + 124) = 1;
      if (v15)
      {
        udata_close(v15);
        if (!*((_BYTE *)v13 + 124) || *a3 > 0)
          goto LABEL_23;
      }
      v23 = *((_BYTE *)v13 + 28);
      *((_BYTE *)v13 + 125) = v23 & 1;
      *((_BYTE *)v13 + 126) = (v23 & 2) != 0;
      v24 = (char **)uprv_malloc(0x10uLL);
      v35 = v24;
      if (v24)
      {
        *v24 = 0;
        v24[1] = 0;
        uprv_free(0);
        v25 = strlen(a2);
        v26 = 0;
        if (v25 <= 0x7FFFFFFE)
        {
          v26 = (char *)uprv_malloc(v25 + 1);
          if (v26)
          {
            uprv_free(0);
            if (!a1)
            {
              v34 = 0;
              goto LABEL_46;
            }
            v27 = strlen(a1);
            if (v27 <= 0x7FFFFFFE)
            {
              v34 = (char *)uprv_malloc(v27 + 1);
              if (v34)
              {
                uprv_free(0);
LABEL_46:
                umtx_lock((icu::UMutex *)&unk_1EE009670);
                v31 = uhash_get(qword_1EE009658, (uint64_t)v36);
                if (v31)
                {
                  v32 = (uint64_t *)v31;
                  ++*(_DWORD *)(v31 + 120);
                  udata_close((_OWORD *)v13[14]);
                  v33 = v13;
                  v13 = v32;
                }
                else
                {
                  *v35 = v26;
                  strcpy(v26, a2);
                  if (a1)
                  {
                    v35[1] = v34;
                    strcpy(v34, a1);
                    v34 = 0;
                  }
                  *((_DWORD *)v13 + 30) = 1;
                  uhash_put(qword_1EE009658, (uint64_t)v35, (uint64_t)v13, a3);
                  v26 = 0;
                  v33 = 0;
                  v35 = 0;
                }
                v29 = v13;
                umtx_unlock((std::mutex **)&unk_1EE009670);
                v30 = 1;
                v13 = v33;
                v28 = v34;
LABEL_43:
                uprv_free(v28);
                uprv_free(v26);
                uprv_free(v35);
                uprv_free(v13);
                v4 = (uint64_t)v29;
                if (v30)
                  return v4;
                return 0;
              }
            }
          }
        }
      }
      else
      {
        v26 = 0;
      }
      *a3 = 7;
      udata_close((_OWORD *)v13[14]);
      v28 = 0;
      v29 = 0;
      v30 = 0;
      goto LABEL_43;
    }
  }
  return 0;
}

uint64_t usprep_openByType(unsigned int a1, int *a2)
{
  if (!a2 || *a2 > 0)
    return 0;
  if (a1 >= 0xE)
  {
    *a2 = 1;
    return 0;
  }
  return usprep_open(0, off_1E2257670[a1], a2);
}

void usprep_close(uint64_t a1)
{
  int v2;
  BOOL v3;
  int v4;

  if (a1)
  {
    umtx_lock((icu::UMutex *)&unk_1EE009670);
    v2 = *(_DWORD *)(a1 + 120);
    v3 = __OFSUB__(v2, 1);
    v4 = v2 - 1;
    if (v4 < 0 == v3)
      *(_DWORD *)(a1 + 120) = v4;
    umtx_unlock((std::mutex **)&unk_1EE009670);
  }
}

UChar *uprv_syntaxError(UChar *result, int a2, int a3, uint64_t a4)
{
  UChar *v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  const UChar *v12;
  int32_t v13;

  if (a4)
  {
    v7 = result;
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 4) = a2;
    v8 = a2 - 15;
    if (a2 < 16)
      v8 = 0;
    v9 = a4 + 8;
    v10 = a2 - v8;
    result = u_memcpy((UChar *)(a4 + 8), &result[v8], a2 - v8);
    *(_WORD *)(v9 + 2 * v10) = 0;
    v11 = a2 + 15;
    if (a2 + 15 >= a3)
      v11 = a3;
    if (a2 >= a3)
    {
      v13 = v11 - a2;
    }
    else
    {
      v12 = &v7[a2];
      v13 = v11 - a2;
      result = u_memcpy((UChar *)(a4 + 40), v12, v13);
    }
    *(_WORD *)(a4 + 2 * v13 + 40) = 0;
  }
  return result;
}

uint64_t usprep_prepare(uint64_t a1, UChar *s, int a3, UChar *a4, int a5, char a6, uint64_t a7, int *a8)
{
  uint64_t v8;
  int32_t v15;
  uint64_t Buffer;
  int v18;
  int v19;
  int v20;
  int v21;
  UErrorCode *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  UChar **v29;
  UChar *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  BOOL v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int Class;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  UChar *v50;
  int v51;
  int v52;
  UChar *v53;
  UChar *v54;
  _QWORD v55[3];
  UChar *v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  UChar *v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (*a8 <= 0)
  {
    if (a1)
    {
      v15 = a3;
      if (s)
      {
        if (a3 < -1)
          goto LABEL_31;
      }
      else if (a3)
      {
        goto LABEL_31;
      }
      if (a4)
      {
        if ((a5 & 0x80000000) == 0)
          goto LABEL_10;
      }
      else if (!a5)
      {
LABEL_10:
        if (a3 < 0)
          v15 = u_strlen(s);
        v62 = 0u;
        v65 = 0;
        v64 = 0u;
        v63 = 0u;
        v61 = (UChar *)off_1E2256B38;
        LOWORD(v62) = 2;
        Buffer = icu::UnicodeString::getBuffer((icu::UnicodeString *)&v61, v15);
        if (Buffer)
        {
          if ((v62 & 2) != 0)
            v18 = 27;
          else
            v18 = DWORD2(v62);
          v19 = sub_18BC6855C(a1, s, v15, Buffer, v18, a6, a7, a8);
          v20 = v19;
          if (*a8 <= 0)
            v21 = v19;
          else
            v21 = 0;
          icu::UnicodeString::releaseBuffer((uint64_t)&v61, v21);
          v23 = *a8;
          if ((_DWORD)v23 != 15)
          {
LABEL_28:
            if ((int)v23 > 0)
            {
              v8 = 0;
LABEL_102:
              icu::UnicodeString::~UnicodeString((void *)v23, (icu::UnicodeString *)&v61);
              return v8;
            }
            v57 = 0u;
            v60 = 0;
            v59 = 0u;
            v58 = 0u;
            v56 = (UChar *)off_1E2256B38;
            LOWORD(v57) = 2;
            if (*(_BYTE *)(a1 + 125))
            {
              v55[0] = off_1E2246ED8;
              v55[1] = icu::Normalizer2::getNFKCInstance((icu::Normalizer2 *)a8, v22);
              v55[2] = sub_18BC4F3B4((UErrorCode *)a8);
              if (*a8 > 0)
              {
                icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v55);
LABEL_100:
                v8 = 0;
                goto LABEL_101;
              }
              icu::FilteredNormalizer2::normalize((icu::FilteredNormalizer2 *)v55, (const icu::UnicodeString *)&v61, (icu::UnicodeString *)&v56, (UErrorCode *)a8);
              icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v55);
            }
            else
            {
              icu::UnicodeString::fastCopyFrom(&v56, &v61);
            }
            v29 = (UChar **)*a8;
            if ((int)v29 > 0)
              goto LABEL_100;
            if ((v57 & 0x11) != 0)
            {
              v30 = 0;
            }
            else if ((v57 & 2) != 0)
            {
              v30 = (UChar *)&v57 + 1;
            }
            else
            {
              v30 = (UChar *)v58;
            }
            if ((v57 & 0x8000u) == 0)
              v31 = (unsigned __int16)v57 >> 5;
            else
              v31 = DWORD1(v57);
            if (v31 >= 1)
            {
              v32 = 0;
              v33 = 23;
              v51 = -1;
              v52 = 0;
              v47 = -1;
              v48 = 0;
              v34 = 23;
              v50 = v30;
              v49 = v31;
              while (1)
              {
                v35 = v32 + 1;
                v36 = v30[v32];
                v37 = (v36 & 0xFC00) != 0xD800 || (_DWORD)v35 == v31;
                if (v37 || (v38 = v30[v35], (v38 & 0xFC00) != 0xDC00))
                {
                  if ((v36 & 0xFC00) == 0xD800)
                    v41 = 320;
                  else
                    v41 = 0;
                  v40 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 64)
                                            + 2
                                            * ((v36 & 0x1F)
                                             + 4
                                             * *(unsigned __int16 *)(*(_QWORD *)(a1 + 64) + 2 * (v41 + (v36 >> 5)))));
                  v42 = -1;
                  ++v32;
                }
                else
                {
                  v32 += 2;
                  v36 = v38 + (v36 << 10) - 56613888;
                  if (v36 >= 0x110000)
                  {
                    v40 = *(unsigned __int16 *)(a1 + 96);
                    v42 = -2;
                  }
                  else
                  {
                    v39 = (*(uint64_t (**)(_QWORD))(a1 + 80))(*(unsigned __int16 *)(*(_QWORD *)(a1 + 64)
                                                                                            + 2
                                                                                            * (((v36 >> 10) & 0x1F)
                                                                                             + 4
                                                                                             * *(unsigned __int16 *)(*(_QWORD *)(a1 + 64) + 2 * (((v36 >> 10) + 55232) >> 5)))));
                    if (v39 < 1)
                      v40 = *(unsigned __int16 *)(a1 + 96);
                    else
                      v40 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 64)
                                                + 2
                                                * ((v38 & 0x1F)
                                                 + 4
                                                 * *(unsigned __int16 *)(*(_QWORD *)(a1 + 64)
                                                                       + 2 * (v39 + ((v38 >> 5) & 0x1F)))));
                    v42 = -2;
                    v30 = v50;
                    v31 = v49;
                  }
                }
                if (v40)
                {
                  if (v40 >> 4 <= 0xFFE)
                  {
                    if ((v40 & 1) != 0)
                    {
LABEL_91:
                      *a8 = 66560;
                      v46 = v32 + v42;
                      goto LABEL_99;
                    }
                  }
                  else if (v40 == 65522)
                  {
                    goto LABEL_91;
                  }
                }
                if (*(_BYTE *)(a1 + 126))
                {
                  Class = ubidi_getClass(v36);
                  v34 = Class;
                  if (v33 == 23)
                    v33 = Class;
                  if (Class)
                    v44 = v52;
                  else
                    v44 = 1;
                  v45 = v51;
                  if (!Class)
                    v45 = v32 - 1;
                  v51 = v45;
                  v52 = v44;
                  if (Class == 13 || Class == 1)
                  {
                    v47 = v32 - 1;
                    v48 = 1;
                  }
                  v30 = v50;
                  v31 = v49;
                }
                if (v32 >= v31)
                  goto LABEL_85;
              }
            }
            v47 = -1;
            v48 = 0;
            v34 = 23;
            v33 = 23;
            v51 = -1;
            LOBYTE(v52) = 0;
LABEL_85:
            if (*(_BYTE *)(a1 + 126))
            {
              if ((_BYTE)v52 && v48)
              {
                *a8 = 66562;
                if (v47 <= v51)
                  v46 = v51;
                else
                  v46 = v47;
                goto LABEL_99;
              }
              if (v48 && (v33 != 13 && v33 != 1 || v34 != 1 && v34 != 13))
              {
                *a8 = 66562;
                v46 = v47;
LABEL_99:
                uprv_syntaxError(v30, v46, v31, a7);
                goto LABEL_100;
              }
            }
            v54 = a4;
            v8 = icu::UnicodeString::extract((uint64_t)&v56, &v54, a5, a8);
            v53 = v54;
            v29 = &v53;
LABEL_101:
            icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)&v56);
            goto LABEL_102;
          }
          v24 = icu::UnicodeString::getBuffer((icu::UnicodeString *)&v61, v20);
          if (v24)
          {
            *a8 = 0;
            if ((v62 & 2) != 0)
              v25 = 27;
            else
              v25 = DWORD2(v62);
            v26 = sub_18BC6855C(a1, s, v15, v24, v25, a6, a7, a8);
            if (*a8 <= 0)
              v27 = v26;
            else
              v27 = 0;
            icu::UnicodeString::releaseBuffer((uint64_t)&v61, v27);
            v23 = *a8;
            goto LABEL_28;
          }
        }
        v8 = 0;
        v23 = 7;
        *a8 = 7;
        goto LABEL_102;
      }
    }
LABEL_31:
    v8 = 0;
    *a8 = 1;
    return v8;
  }
  return 0;
}

uint64_t sub_18BC6855C(uint64_t a1, UChar *a2, int a3, uint64_t a4, int a5, char a6, uint64_t a7, int *a8)
{
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  BOOL v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v36;

  if (a3 >= 1)
  {
    v13 = 0;
    v14 = 0;
    v15 = a6 & 1;
    v36 = v15;
    while (1)
    {
      v16 = v13 + 1;
      v17 = a2[v13];
      v18 = (v17 & 0xFC00) != 0xD800 || (_DWORD)v16 == a3;
      if (v18 || (v19 = a2[v16], (v19 & 0xFC00) != 0xDC00))
      {
        v22 = (v17 & 0xFC00) == 0xD800 ? 320 : 0;
        LOWORD(v21) = *(_WORD *)(*(_QWORD *)(a1 + 64)
                               + 2
                               * ((v17 & 0x1F)
                                + 4 * *(unsigned __int16 *)(*(_QWORD *)(a1 + 64) + 2 * (v22 + (v17 >> 5)))));
        v23 = -1;
        ++v13;
      }
      else
      {
        v13 += 2;
        v17 = v19 + (v17 << 10) - 56613888;
        if (v17 >= 0x110000)
        {
          v21 = *(_DWORD *)(a1 + 96);
          v23 = -2;
        }
        else
        {
          v20 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 80))(*(unsigned __int16 *)(*(_QWORD *)(a1 + 64)+ 2* (((v17 >> 10) & 0x1F)+ 4* *(unsigned __int16 *)(*(_QWORD *)(a1 + 64) + 2 * (((v17 >> 10) + 55232) >> 5)))), 4238353408);
          if (v20 < 1)
            v21 = *(_DWORD *)(a1 + 96);
          else
            LOWORD(v21) = *(_WORD *)(*(_QWORD *)(a1 + 64)
                                   + 2
                                   * ((v19 & 0x1F)
                                    + 4
                                    * *(unsigned __int16 *)(*(_QWORD *)(a1 + 64) + 2 * (v20 + ((v19 >> 5) & 0x1F)))));
          v23 = -2;
          v15 = v36;
        }
      }
      v24 = (unsigned __int16)v21;
      if (!(_WORD)v21)
        break;
      if ((unsigned __int16)v21 >> 4 >= 0xFFFu)
      {
        v25 = (unsigned __int16)v21 - 65520;
LABEL_23:
        LOWORD(v26) = 0;
        v27 = 0;
        goto LABEL_24;
      }
      v26 = (__int16)v21 >> 2;
      if ((v24 & 2) != 0)
        LOWORD(v26) = v24 >> 2;
      if ((v24 & 0xFFFC) == 0xFEFC)
      {
        v25 = 3;
        goto LABEL_23;
      }
      v27 = (v24 & 2) >> 1;
      v25 = 1;
LABEL_24:
      if (!(v25 | v15))
      {
        uprv_syntaxError(a2, v13 + v23, a3, a7);
        *a8 = 66561;
        return 0;
      }
      if (v25 != 3)
      {
        if (v25 != 1)
          goto LABEL_34;
        v28 = (__int16)v26;
        if (!v27)
        {
          v17 -= (__int16)v26;
LABEL_34:
          if ((int)v17 >= 0x10000)
          {
            v31 = (int)v14 + 1;
            if ((int)v31 < a5)
            {
              *(_WORD *)(a4 + 2 * (int)v14) = (v17 >> 10) - 10304;
              *(_WORD *)(a4 + 2 * v31) = v17 & 0x3FF | 0xDC00;
            }
            v14 = (v14 + 2);
          }
          else
          {
            if ((int)v14 < a5)
              *(_WORD *)(a4 + 2 * (int)v14) = v17;
            v14 = (v14 + 1);
          }
          goto LABEL_55;
        }
        v29 = *(_DWORD *)(a1 + 16);
        if (*(_DWORD *)(a1 + 12) <= (__int16)v26 && v29 > (__int16)v26)
        {
          v30 = 1;
          goto LABEL_51;
        }
        v32 = *(_DWORD *)(a1 + 20);
        if (v29 <= (__int16)v26 && v32 > (__int16)v26)
        {
          v30 = 2;
          goto LABEL_51;
        }
        if (v32 <= (__int16)v26 && *(_DWORD *)(a1 + 24) > (__int16)v26)
        {
          v30 = 3;
          goto LABEL_51;
        }
        v30 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 104) + 2 * (__int16)v26);
        if (v30)
        {
          ++v28;
LABEL_51:
          v14 = (int)v14;
          v33 = 2 * v28;
          do
          {
            if (v14 < a5)
              *(_WORD *)(a4 + 2 * v14) = *(_WORD *)(*(_QWORD *)(a1 + 104) + v33);
            ++v14;
            v33 += 2;
            --v30;
          }
          while (v30);
        }
      }
LABEL_55:
      if (v13 >= a3)
        return u_terminateUChars(a4, a5, v14, a8);
    }
    v25 = 4;
    goto LABEL_23;
  }
  v14 = 0;
  return u_terminateUChars(a4, a5, v14, a8);
}

uint64_t usprep_swap(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  int v22;
  unsigned int *v23;
  int v24;
  uint64_t v25;
  unsigned int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  _OWORD v37[4];
  uint64_t v38;

  v10 = a3;
  v38 = *MEMORY[0x1E0C80C00];
  v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0)
    return 0;
  v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x5000000053
    || *(_BYTE *)(a2 + 14) != 82
    || *(_BYTE *)(a2 + 15) != 80
    || *(_BYTE *)(a2 + 16) != 3)
  {
    udata_printError(a1, (uint64_t)"usprep_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as StringPrep .spp data\n", v14, v15, v16, v17, v18, v19, v21);
    result = 0;
    v24 = 16;
LABEL_15:
    *a5 = v24;
    return result;
  }
  v22 = v13;
  if (a4)
    v23 = (unsigned int *)((char *)a4 + v13);
  else
    v23 = 0;
  if ((v10 & 0x80000000) == 0)
  {
    v10 = (v10 - v13);
    if ((int)v10 <= 63)
    {
      udata_printError(a1, (uint64_t)"usprep_swap(): too few bytes (%d after header) for StringPrep .spp data\n", v14, v15, v16, v17, v18, v19, v10);
LABEL_21:
      result = 0;
      v24 = 8;
      goto LABEL_15;
    }
  }
  v25 = 0;
  v26 = (unsigned int *)(a2 + v13);
  memset(v37, 0, sizeof(v37));
  do
  {
    *(_DWORD *)((char *)v37 + v25 * 4) = udata_readInt32(a1, v26[v25]);
    ++v25;
  }
  while (v25 != 16);
  v33 = DWORD1(v37[0]);
  v34 = v37[0];
  v35 = SLODWORD(v37[0]) + 64;
  v36 = v35 + DWORD1(v37[0]);
  if ((v10 & 0x80000000) == 0)
  {
    if ((int)v10 < v36)
    {
      udata_printError(a1, (uint64_t)"usprep_swap(): too few bytes (%d after header) for all of StringPrep .spp data\n", v27, v28, v29, v30, v31, v32, v10);
      goto LABEL_21;
    }
    if (v26 != v23)
      memcpy(v23, v26, v36);
    (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(a1 + 56))(a1, v26, 64, v23, a5);
    utrie_swap(a1, v26 + 16, v34, (uint64_t)(v23 + 16), a5);
    (*(void (**)(uint64_t, char *, uint64_t, char *, int *))(a1 + 48))(a1, (char *)v26 + v35, v33, (char *)v23 + v35, a5);
  }
  return (v36 + v22);
}

uint64_t sub_18BC68ACC(unsigned __int8 **a1)
{
  unsigned __int8 *v1;
  unsigned int v2;

  v1 = a1[1];
  v2 = uhash_hashChars(*a1);
  return v2 + 37 * uhash_hashChars(v1);
}

uint64_t sub_18BC68B04(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  _BOOL4 v4;

  v2 = a1[1];
  v3 = a2[1];
  v4 = uhash_compareChars(*a1, *a2);
  return uhash_compareChars(v2, v3) & v4;
}

BOOL sub_18BC68B4C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  _OWORD **v3;
  void *v4;
  uint64_t v5;
  int v6;
  int v8;

  if (qword_1EE009658)
  {
    v8 = -1;
    umtx_lock((icu::UMutex *)&unk_1EE009670);
    if (qword_1EE009658)
    {
      v0 = uhash_nextElement((uint64_t *)qword_1EE009658, &v8);
      if (v0)
      {
        v1 = v0;
        do
        {
          v3 = *(_OWORD ***)(v1 + 8);
          v2 = *(_QWORD *)(v1 + 16);
          uhash_removeElement(qword_1EE009658, (_DWORD *)v1);
          udata_close(v3[14]);
          if (*(_QWORD *)v2)
          {
            uprv_free(*(void **)v2);
            *(_QWORD *)v2 = 0;
          }
          v4 = *(void **)(v2 + 8);
          if (v4)
          {
            uprv_free(v4);
            *(_QWORD *)(v2 + 8) = 0;
          }
          uprv_free(v3);
          uprv_free((void *)v2);
          v1 = uhash_nextElement((uint64_t *)qword_1EE009658, &v8);
        }
        while (v1);
      }
    }
    umtx_unlock((std::mutex **)&unk_1EE009670);
    v5 = qword_1EE009658;
    if (qword_1EE009658)
    {
      v6 = uhash_count(qword_1EE009658);
      v5 = qword_1EE009658;
      if (!v6)
      {
        uhash_close((void **)qword_1EE009658);
        v5 = 0;
        qword_1EE009658 = 0;
      }
    }
  }
  else
  {
    v5 = 0;
  }
  atomic_store(0, &dword_1EE009660);
  return v5 == 0;
}

uint64_t sub_18BC68C50(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4)
{
  if (*a4 < 0x14u
    || *((_BYTE *)a4 + 4)
    || *((_BYTE *)a4 + 5)
    || *((_BYTE *)a4 + 8) != 83
    || *((_BYTE *)a4 + 9) != 80
    || *((_BYTE *)a4 + 10) != 82
    || *((_BYTE *)a4 + 11) != 80
    || *((_BYTE *)a4 + 12) != 3
    || *((_BYTE *)a4 + 14) != 5
    || *((_BYTE *)a4 + 15) != 2)
  {
    return 0;
  }
  dword_1EE009668 = *((_DWORD *)a4 + 4);
  return 1;
}

void *icu::UStack::getStaticClassID(icu::UStack *this)
{
  return &unk_1EE0096C0;
}

void *icu::UStack::getDynamicClassID(icu::UStack *this)
{
  return &unk_1EE0096C0;
}

icu::UVector *icu::UStack::UStack(icu::UStack *this, UErrorCode *a2)
{
  icu::UVector *result;

  result = icu::UVector::UVector(this, a2);
  *(_QWORD *)result = off_1E22576F0;
  return result;
}

{
  icu::UVector *result;

  result = icu::UVector::UVector(this, a2);
  *(_QWORD *)result = off_1E22576F0;
  return result;
}

_QWORD *icu::UStack::UStack(icu::UStack *this, unsigned int a2, UErrorCode *a3)
{
  _QWORD *result;

  result = (_QWORD *)icu::UVector::UVector(this, a2, a3);
  *result = off_1E22576F0;
  return result;
}

{
  _QWORD *result;

  result = (_QWORD *)icu::UVector::UVector(this, a2, a3);
  *result = off_1E22576F0;
  return result;
}

_QWORD *icu::UStack::UStack(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  _QWORD *result;

  result = (_QWORD *)icu::UVector::UVector(a1, a2, a3, a4);
  *result = off_1E22576F0;
  return result;
}

{
  _QWORD *result;

  result = (_QWORD *)icu::UVector::UVector(a1, a2, a3, a4);
  *result = off_1E22576F0;
  return result;
}

_QWORD *icu::UStack::UStack(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int *a5)
{
  _QWORD *result;

  result = (_QWORD *)icu::UVector::UVector(a1, a2, a3, a4, a5);
  *result = off_1E22576F0;
  return result;
}

{
  _QWORD *result;

  result = (_QWORD *)icu::UVector::UVector(a1, a2, a3, a4, a5);
  *result = off_1E22576F0;
  return result;
}

void icu::UStack::~UStack(void **this)
{
  void *v1;

  icu::UVector::~UVector(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::UStack::pop(icu::UStack *this)
{
  int v1;

  v1 = *((_DWORD *)this + 2);
  if (v1 < 1)
    return 0;
  else
    return icu::UVector::orphanElementAt(this, v1 - 1);
}

uint64_t icu::UStack::popi(icu::UStack *this)
{
  int v1;
  int v2;
  uint64_t v4;

  v1 = *((_DWORD *)this + 2);
  v2 = v1 - 1;
  if (v1 < 1)
    return 0;
  v4 = icu::UVector::elementAti(this, v1 - 1);
  icu::UVector::removeElementAt((uint64_t (**)(void))this, v2);
  return v4;
}

uint64_t icu::UStack::search(icu::UStack *this, uint64_t a2)
{
  uint64_t result;

  result = icu::UVector::indexOf(this, a2, 0);
  if ((result & 0x80000000) == 0)
    return (*((_DWORD *)this + 2) - result);
  return result;
}

uint64_t u_getDefaultConverter(UErrorCode *a1)
{
  uint64_t v2;
  _QWORD *v3;

  umtx_lock(0);
  v2 = qword_1EE0096C8;
  if (qword_1EE0096C8)
  {
    qword_1EE0096C8 = 0;
    umtx_unlock(0);
  }
  else
  {
    umtx_unlock(0);
    v3 = ucnv_open(0, a1);
    v2 = (uint64_t)v3;
    if (*(int *)a1 >= 1)
    {
      ucnv_close(v3);
      return 0;
    }
  }
  return v2;
}

void u_releaseDefaultConverter(_QWORD *a1)
{
  umtx_lock(0);
  if (qword_1EE0096C8)
    goto LABEL_5;
  umtx_unlock(0);
  if (a1)
    ucnv_reset((uint64_t)a1);
  ucnv_enableCleanup();
  umtx_lock(0);
  if (qword_1EE0096C8)
  {
LABEL_5:
    umtx_unlock(0);
    if (a1)
      ucnv_close(a1);
  }
  else
  {
    qword_1EE0096C8 = (uint64_t)a1;
    umtx_unlock(0);
  }
}

void u_flushDefaultConverter()
{
  _QWORD *v0;

  if (qword_1EE0096C8)
  {
    umtx_lock(0);
    v0 = (_QWORD *)qword_1EE0096C8;
    if (qword_1EE0096C8)
    {
      qword_1EE0096C8 = 0;
      umtx_unlock(0);
      ucnv_close(v0);
    }
    else
    {
      umtx_unlock(0);
    }
  }
}

UChar *__cdecl u_uastrncpy(UChar *dst, const char *src, int32_t n)
{
  uint64_t DefaultConverter;
  BOOL v7;
  UChar *v8;
  _QWORD *v9;
  int32_t v10;
  uint64_t v11;
  int v14;
  UChar *v15;
  const char *v16;

  v15 = dst;
  v16 = src;
  v14 = 0;
  DefaultConverter = u_getDefaultConverter((UErrorCode *)&v14);
  v7 = v14 > 0 || DefaultConverter == 0;
  v8 = dst;
  if (v7)
    goto LABEL_18;
  v9 = (_QWORD *)DefaultConverter;
  ucnv_reset(DefaultConverter);
  v10 = 0;
  if (n && src)
  {
    v11 = 0;
    v10 = n;
    while (src[v11])
    {
      if (n == (_DWORD)++v11)
        goto LABEL_12;
    }
    v10 = v11;
  }
LABEL_12:
  ucnv_toUnicode((uint64_t)v9, (char **)&v15, (unint64_t)&dst[n], (unint64_t *)&v16, (unint64_t)&src[v10], 0, 1, &v14);
  ucnv_reset((uint64_t)v9);
  u_releaseDefaultConverter(v9);
  if (v14 >= 1 && v14 != 15)
    *dst = 0;
  v8 = v15;
  if (v15 < &dst[n])
LABEL_18:
    *v8 = 0;
  return dst;
}

UChar *__cdecl u_uastrcpy(UChar *dst, const char *src)
{
  uint64_t DefaultConverter;
  BOOL v5;
  _QWORD *v6;
  int v7;
  int v9;

  v9 = 0;
  DefaultConverter = u_getDefaultConverter((UErrorCode *)&v9);
  v5 = v9 > 0 || DefaultConverter == 0;
  if (v5
    || (v6 = (_QWORD *)DefaultConverter,
        v7 = strlen(src),
        ucnv_toUChars((uint64_t)v6, (unint64_t)dst, 0xFFFFFFF, src, v7, &v9),
        u_releaseDefaultConverter(v6),
        v9 >= 1))
  {
    *dst = 0;
  }
  return dst;
}

char *__cdecl u_austrncpy(char *dst, const UChar *src, int32_t n)
{
  uint64_t DefaultConverter;
  BOOL v7;
  char *v8;
  _QWORD *v9;
  int32_t v10;
  uint64_t v11;
  int v14;
  char *v15;
  const UChar *v16;

  v15 = dst;
  v16 = src;
  v14 = 0;
  DefaultConverter = u_getDefaultConverter((UErrorCode *)&v14);
  v7 = v14 > 0 || DefaultConverter == 0;
  v8 = dst;
  if (v7)
    goto LABEL_18;
  v9 = (_QWORD *)DefaultConverter;
  ucnv_reset(DefaultConverter);
  v10 = 0;
  if (n && src)
  {
    v11 = 0;
    v10 = n;
    while (src[v11])
    {
      if (n == (_DWORD)++v11)
        goto LABEL_12;
    }
    v10 = v11;
  }
LABEL_12:
  ucnv_fromUnicode((uint64_t)v9, (uint64_t *)&v15, (unint64_t)&dst[n], (unint64_t *)&v16, (unint64_t)&src[v10], 0, 1, &v14);
  ucnv_reset((uint64_t)v9);
  u_releaseDefaultConverter(v9);
  if (v14 >= 1 && v14 != 15)
    *dst = 0;
  v8 = v15;
  if (v15 < &dst[n])
LABEL_18:
    *v8 = 0;
  return dst;
}

char *__cdecl u_austrcpy(char *dst, const UChar *src)
{
  uint64_t DefaultConverter;
  BOOL v5;
  char *v6;
  _QWORD *v7;
  int v8;
  int v10;

  v10 = 0;
  DefaultConverter = u_getDefaultConverter((UErrorCode *)&v10);
  v5 = v10 > 0 || DefaultConverter == 0;
  v6 = dst;
  if (!v5)
  {
    v7 = (_QWORD *)DefaultConverter;
    v8 = ucnv_fromUChars(DefaultConverter, (unint64_t)dst, 0xFFFFFFF, src, -1, &v10);
    u_releaseDefaultConverter(v7);
    v6 = &dst[v8];
  }
  *v6 = 0;
  return dst;
}

void *sub_18BC69310()
{
  return &unk_1EE0096D0;
}

void sub_18BC69320(icu::BreakIterator *a1)
{
  void *v1;

  icu::BreakIterator::~BreakIterator(a1);
  icu::UMemory::operator delete(v1);
}

uint64_t sub_18BC69334()
{
  return 0;
}

uint64_t sub_18BC6933C()
{
  return 0;
}

void sub_18BC69344()
{
  abort();
}

uint64_t sub_18BC69350(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 <= 0)
    *a3 = 16;
  return 0;
}

uint64_t sub_18BC6936C(uint64_t result, uint64_t a2)
{
  unsigned int v2;
  int v3;
  unsigned int v4;

  v2 = *(unsigned __int16 *)(a2 + 8);
  v3 = (__int16)v2;
  v4 = v2 >> 5;
  if (v3 < 0)
    v4 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 484) = v4;
  return result;
}

int64_t sub_18BC6938C(int64_t result, UText *ut, int *a3)
{
  uint64_t v4;

  if (*a3 <= 0)
  {
    v4 = result;
    result = utext_nativeLength(ut);
    if (result > 0x7FFFFFFF)
      *a3 = 8;
    else
      *(_DWORD *)(v4 + 484) = result;
  }
  return result;
}

void sub_18BC693DC()
{
  abort();
}

uint64_t sub_18BC693E8()
{
  return 0;
}

uint64_t sub_18BC693F0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18BC693F8()
{
  return 0;
}

uint64_t sub_18BC69400(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18BC69408()
{
  return 0;
}

uint64_t sub_18BC69410(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18BC69418()
{
  return 0;
}

uint64_t sub_18BC69420()
{
  return 0;
}

uint64_t sub_18BC69428(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18BC69430(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  if (*a4 <= 0)
    *a4 = 16;
  return 0;
}

void sub_18BC6944C(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 <= 0)
    *a3 = 16;
}

uint64_t sub_18BC69468(icu::Locale *a1, const char *a2, char a3, uint64_t a4, uint64_t *a5, const icu::Locale *a6)
{
  uint64_t v6;
  int v9;
  UErrorCode *v10;
  UErrorCode *v11;
  UErrorCode *v12;
  UErrorCode *v13;
  uint64_t v14;
  int v15;
  char *SentenceInstance;
  char *v18[29];

  v18[28] = *(char **)MEMORY[0x1E0C80C00];
  if (*(int *)a6 > 0)
    return 0;
  v6 = a4;
  v9 = a3 & 0xE0;
  if ((a3 & 0xE0) != 0 && a4)
  {
    v6 = 0;
    *(_DWORD *)a6 = 1;
    return v6;
  }
  if (a4)
    return v6;
  if (v9 == 64)
  {
    if (a1)
      icu::Locale::Locale((icu::Locale *)v18, (uint64_t)a1);
    else
      icu::Locale::Locale((icu::Locale *)v18, a2, 0, 0, 0);
    SentenceInstance = icu::BreakIterator::createSentenceInstance(v18, a6, v12, v13);
    goto LABEL_21;
  }
  if (v9 != 32)
  {
    if ((a3 & 0xE0) == 0)
    {
      if (a1)
        icu::Locale::Locale((icu::Locale *)v18, (uint64_t)a1);
      else
        icu::Locale::Locale((icu::Locale *)v18, a2, 0, 0, 0);
      SentenceInstance = icu::BreakIterator::createWordInstance(v18, a6, v10, v11);
LABEL_21:
      v6 = (uint64_t)SentenceInstance;
      icu::Locale::~Locale((icu::Locale *)v18);
      goto LABEL_24;
    }
    v6 = 0;
    v15 = 1;
LABEL_23:
    *(_DWORD *)a6 = v15;
    goto LABEL_24;
  }
  v14 = icu::UMemory::operator new((icu::UMemory *)0x1E8, (unint64_t)a2);
  v6 = v14;
  if (!v14)
  {
    v15 = 7;
    goto LABEL_23;
  }
  icu::BreakIterator::BreakIterator(v14);
  *(_QWORD *)v6 = &off_1E2257730;
  *(_DWORD *)(v6 + 484) = 0;
LABEL_24:
  if (*a5)
    (*(void (**)(uint64_t))(*(_QWORD *)*a5 + 8))(*a5);
  *a5 = v6;
  return v6;
}

uint64_t icu::CaseMap::toTitle(char *a1, uint64_t a2, uint64_t a3, UChar *a4, uint64_t a5, unint64_t a6, uint64_t a7, icu::Edits *a8, const icu::Locale *a9)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  UChar *v22;
  uint64_t v23;
  _OWORD v24[4];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  v16 = sub_18BC69468(0, a1, a2, a3, &v23, a9);
  if (v16)
  {
    v17 = v16;
    memset(v24, 0, sizeof(v24));
    v22 = a4;
    icu::UnicodeString::UnicodeString(v24, a5 >> 31, &v22);
    (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v17 + 56))(v17, v24);
    v18 = sub_18BC6BDA0((unsigned __int8 *)a1);
    v19 = sub_18BC6B284(v18, a2, v17, a6, a7, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, UChar *, uint64_t, icu::Edits *, int *))sub_18BC69A60, a8, (int *)a9);
    icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)v24);
  }
  else
  {
    v19 = 0;
  }
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
  return v19;
}

int32_t u_strToTitle(UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, UBreakIterator *titleIter, const char *locale, UErrorCode *pErrorCode)
{
  uint64_t v9;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int32_t v16;
  void *v17;
  const UChar *v19;
  uint64_t v20;
  _OWORD v21[4];
  uint64_t v22;

  v9 = *(_QWORD *)&srcLength;
  v11 = *(_QWORD *)&destCapacity;
  v22 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  v13 = sub_18BC69468(0, locale, 0, (uint64_t)titleIter, &v20, (const icu::Locale *)pErrorCode);
  if (v13)
  {
    v14 = v13;
    memset(v21, 0, sizeof(v21));
    v19 = src;
    icu::UnicodeString::UnicodeString(v21, v9 >> 31, &v19);
    (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v14 + 56))(v14, v21);
    v15 = sub_18BC6BDA0((unsigned __int8 *)locale);
    v16 = sub_18BC6B3D0(v15, 0, v14, dest, v11, (UChar *)src, v9, (uint64_t (*)(uint64_t, uint64_t, uint64_t, UChar *, uint64_t, UChar *, uint64_t, _QWORD, int *))sub_18BC69A60, (int *)pErrorCode);
    icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v21);
  }
  else
  {
    v16 = 0;
  }
  if (v20)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
  return v16;
}

uint64_t ucasemap_toTitle(uint64_t *a1, unint64_t a2, uint64_t a3, UChar *a4, uint64_t a5, const icu::Locale *a6)
{
  uint64_t v6;
  void *v13;
  UChar *v15;
  _OWORD v16[4];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (*(int *)a6 <= 0)
  {
    if (!*a1)
    {
      *(_QWORD *)&v16[0] = 0;
      if (!sub_18BC69468(0, (const char *)a1 + 8, *((_DWORD *)a1 + 11), 0, (uint64_t *)v16, a6))
      {
        if (*(_QWORD *)&v16[0])
          (*(void (**)(void))(**(_QWORD **)&v16[0] + 8))();
        return 0;
      }
      *a1 = *(_QWORD *)&v16[0];
    }
    memset(v16, 0, sizeof(v16));
    v15 = a4;
    icu::UnicodeString::UnicodeString(v16, a5 >> 31, &v15);
    (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)*a1 + 56))(*a1, v16);
    v6 = sub_18BC6B284(*((unsigned int *)a1 + 10), *((unsigned int *)a1 + 11), *a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, UChar *, uint64_t, icu::Edits *, int *))sub_18BC69A60, 0, (int *)a6);
    icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v16);
    return v6;
  }
  return 0;
}

__int32 *__cdecl u_strToWCS(__int32 *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  BOOL v6;
  char v7;

  if (!pErrorCode || *(int *)pErrorCode > 0)
    return 0;
  if (src)
    v6 = 1;
  else
    v6 = srcLength == 0;
  v7 = !v6;
  if (destCapacity < 0 || srcLength < -1 || (v7 & 1) != 0 || !dest && destCapacity)
  {
    *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  return u_strToUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode);
}

UChar *__cdecl u_strFromWCS(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const __int32 *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  BOOL v6;
  char v7;

  if (!pErrorCode || *(int *)pErrorCode > 0)
    return 0;
  if (src)
    v6 = 1;
  else
    v6 = srcLength == 0;
  v7 = !v6;
  if (destCapacity < 0 || srcLength < -1 || (v7 & 1) != 0 || !dest && destCapacity)
  {
    *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  return u_strFromUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode);
}

uint64_t sub_18BC69A60(int a1, int a2, _QWORD *a3, uint64_t a4, int a5, uint64_t a6, int a7, icu::Edits *a8, int *a9)
{
  int *v9;
  uint64_t v10;
  __int16 v11;
  int v12;
  int v13;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v21;
  const UChar *v22;
  unsigned int v23;
  int v25;
  uint64_t v26;
  int v27;
  BOOL v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  BOOL v32;
  int v33;
  BOOL v34;
  int32_t v35;
  uint64_t v36;
  int v37;
  signed int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  unsigned int v46;
  UChar32 v47;
  uint64_t v48;
  int v49;
  int v50;
  signed int v51;
  uint64_t v52;
  __int16 *v60;
  _QWORD v61[2];
  uint64_t v62;
  uint64_t v63;

  v9 = a9;
  if (*a9 > 0)
    return 0;
  v11 = a2;
  if ((~a2 & 0x600) == 0)
  {
    v10 = 0;
    v12 = 1;
    goto LABEL_141;
  }
  v13 = a7;
  v63 = 0;
  v61[0] = a6;
  v61[1] = 0;
  v62 = a7;
  if (a7 < 1)
  {
    v10 = 0;
    goto LABEL_135;
  }
  v15 = a3;
  LODWORD(v16) = 0;
  v10 = 0;
  v17 = 10;
  while (2)
  {
    v18 = v16;
    v19 = (*(uint64_t (**)(_QWORD *))(*v15 + 8 * v17))(v15);
    if (v19 > v13 || v19 == -1)
      v16 = v13;
    else
      v16 = v19;
    if (v18 >= (int)v16)
      goto LABEL_126;
    v21 = v18 + 1;
    v22 = (const UChar *)(a6 + 2 * v18);
    v23 = *v22;
    if ((v23 & 0xFC00) != 0xD800 || (_DWORD)v21 == (_DWORD)v16)
    {
      if ((v11 & 0x200) != 0)
        goto LABEL_20;
    }
    else
    {
      v27 = *(unsigned __int16 *)(a6 + 2 * v21);
      v28 = (v27 & 0xFC00) == 56320;
      v29 = (v23 << 10) - 56613888 + v27;
      if (v28)
        v21 = (v18 + 2);
      else
        v21 = v21;
      if (v28)
        v23 = v29;
      if ((v11 & 0x200) != 0)
      {
LABEL_20:
        v25 = v18;
        v26 = v21;
        goto LABEL_52;
      }
    }
    v25 = v18;
    while (1)
    {
      v26 = v21;
      v30 = v23;
      if ((v11 & 0x400) == 0)
      {
        v31 = u_charType(v23);
        if (((1 << v31) & 0xF020E2E) != 0)
          goto LABEL_42;
        if (v31 != 4)
          goto LABEL_34;
        v30 = v23;
      }
      if (ucase_getType(v30))
        goto LABEL_42;
LABEL_34:
      if ((_DWORD)v26 == (_DWORD)v16)
        break;
      v21 = (int)v26 + 1;
      v23 = *(unsigned __int16 *)(a6 + 2 * (int)v26);
      v32 = (v23 & 0xFC00) != 0xD800 || (_DWORD)v21 == (_DWORD)v16;
      v25 = v26;
      if (!v32)
      {
        v33 = *(unsigned __int16 *)(a6 + 2 * v21);
        v25 = v26;
        if ((v33 & 0xFC00) == 0xDC00)
        {
          v21 = (v26 + 2);
          v23 = (v23 << 10) - 56613888 + v33;
          v25 = v26;
        }
      }
    }
    v26 = v16;
    v25 = v16;
LABEL_42:
    v34 = __OFSUB__(v25, v18);
    v35 = v25 - v18;
    if (!((v35 < 0) ^ v34 | (v35 == 0)))
    {
      if (v35 < 1)
        goto LABEL_50;
      if (a8)
        icu::Edits::addUnchanged(a8, v35);
      if ((v11 & 0x4000) != 0)
      {
LABEL_50:
        v36 = v10;
        goto LABEL_51;
      }
      if ((v10 ^ 0x7FFFFFFF) < v35)
        goto LABEL_139;
      v36 = (v35 + v10);
      if ((int)v36 <= a5)
        u_memcpy((UChar *)(a4 + 2 * (int)v10), v22, v35);
LABEL_51:
      v10 = v36;
      if ((v36 & 0x80000000) != 0)
        goto LABEL_139;
    }
LABEL_52:
    if ((int)v26 <= v25)
      goto LABEL_125;
    HIDWORD(v62) = v25;
    LODWORD(v63) = v26;
    v60 = 0;
    v37 = a1;
    v38 = ucase_toFullTitle(v23, (uint64_t (*)(uint64_t, _QWORD))sub_18BC6A0B0, (uint64_t)v61, &v60, a1);
    v39 = sub_18BC6A1AC(a4, v10, a5, v38, v60, (int)v26 - v25, v11, a8);
    if ((v39 & 0x80000000) != 0)
    {
LABEL_139:
      v10 = 0;
      v12 = 8;
      goto LABEL_140;
    }
    v40 = v39;
    if (a1 != 5 || (v41 = v25 + 1, (int)v41 >= (int)v16) || (v42 = v38 ^ (v38 >> 31), v42 != 205) && v42 != 73)
    {
      v10 = v39;
      goto LABEL_109;
    }
    v26 = v25 + 2;
    v43 = *(unsigned __int16 *)(a6 + 2 * v41);
    if (v42 == 73)
    {
      if (v43 == 769)
      {
        if ((_DWORD)v26 == (_DWORD)v16)
        {
          v10 = v39;
          v26 = v25 + 1;
          goto LABEL_109;
        }
        v43 = *(unsigned __int16 *)(a6 + 2 * v26);
        v45 = 1;
        v26 = (v25 + 3);
        v44 = 1;
      }
      else
      {
        v45 = 0;
        v44 = 0;
      }
    }
    else
    {
      v44 = 0;
      v45 = 1;
    }
    if (v43 != 106)
    {
      if (v43 == 74)
      {
        ++v44;
        goto LABEL_69;
      }
      goto LABEL_82;
    }
LABEL_69:
    if (v45)
    {
      if ((_DWORD)v26 == (_DWORD)v16 || *(_WORD *)(a6 + 2 * (int)v26) != 769)
        goto LABEL_82;
      v46 = v43 == 106;
      v26 = (v26 + 1);
      if (v43 != 106)
        ++v44;
    }
    else
    {
      v46 = 0;
    }
    if ((int)v26 < (int)v16)
    {
      v47 = *(unsigned __int16 *)(a6 + 2 * (int)v26);
      if ((v47 & 0xFC00) == 0xD800)
      {
        v48 = (int)v26 + 1;
        if ((_DWORD)v48 != (_DWORD)v16)
        {
          v49 = *(unsigned __int16 *)(a6 + 2 * v48);
          if ((v49 & 0xFC00) == 0xDC00)
            v47 = (v47 << 10) - 56613888 + v49;
        }
      }
      if (((1 << u_charType(v47)) & 0x1C0) != 0)
      {
LABEL_82:
        v10 = v40;
        v26 = v41;
        v37 = a1;
        goto LABEL_109;
      }
    }
    if (v44)
    {
      if (a8)
        icu::Edits::addUnchanged(a8, v44);
      if ((v11 & 0x4000) == 0)
      {
        if ((v40 ^ 0x7FFFFFFF) >= v44)
        {
          if ((int)(v44 + v40) <= a5)
            u_memcpy((UChar *)(a4 + 2 * v40), (const UChar *)(a6 + 2 * v41), v44);
          v40 = v44 + v40;
        }
        else
        {
          v40 = 0xFFFFFFFFLL;
        }
      }
    }
    v50 = v44 + v41;
    if (v43 == 106)
    {
      v37 = a1;
      if ((int)v40 < a5)
      {
        *(_WORD *)(a4 + 2 * (int)v40) = 74;
        goto LABEL_99;
      }
      if ((_DWORD)v40 == 0x7FFFFFFF)
        v40 = 0xFFFFFFFFLL;
      else
LABEL_99:
        v40 = (v40 + 1);
      if (a8)
        icu::Edits::addReplace(a8, 1, 1);
      ++v50;
      if (v46)
        goto LABEL_103;
LABEL_108:
      v10 = v40;
      goto LABEL_109;
    }
    v37 = a1;
    if (!v46)
      goto LABEL_108;
LABEL_103:
    if (a8)
      icu::Edits::addUnchanged(a8, v46);
    if ((v11 & 0x4000) != 0)
      goto LABEL_108;
    if ((v40 ^ 0x7FFFFFFF) >= v46)
    {
      v10 = v40 + v46;
      if ((int)v10 <= a5)
        u_memcpy((UChar *)(a4 + 2 * (int)v40), (const UChar *)(a6 + 2 * v50), v46);
    }
    else
    {
      v10 = 0xFFFFFFFFLL;
    }
LABEL_109:
    v51 = v16 - v26;
    if ((int)v16 <= (int)v26)
      goto LABEL_125;
    if ((v11 & 0x100) != 0)
    {
      if (v51 < 1)
        goto LABEL_124;
      if (a8)
        icu::Edits::addUnchanged(a8, v16 - v26);
      if ((v11 & 0x4000) != 0)
      {
LABEL_124:
        if ((v10 & 0x80000000) != 0)
          goto LABEL_139;
      }
      else
      {
        if ((v10 ^ 0x7FFFFFFF) < v51)
          goto LABEL_139;
        if (v51 + (int)v10 <= a5)
          u_memcpy((UChar *)(a4 + 2 * (int)v10), (const UChar *)(a6 + 2 * (int)v26), v16 - v26);
        v10 = (v51 + v10);
      }
LABEL_125:
      v13 = a7;
      v15 = a3;
      goto LABEL_126;
    }
    if (a4)
      v52 = a4 + 2 * (int)v10;
    else
      v52 = 0;
    v10 = sub_18BC6A344(v37, v11, v52, a5 - (int)v10, a6, (uint64_t)v61, v26, v16, a8, a9)
        + v10;
    if (*a9 == 15)
    {
      *a9 = 0;
      goto LABEL_125;
    }
    v13 = a7;
    v15 = a3;
    if (*a9 <= 0)
    {
LABEL_126:
      v17 = 13;
      if ((int)v16 >= v13)
      {
        if (*a9 > 0)
          return v10;
LABEL_135:
        if ((int)v10 <= a5)
        {
          if (a8)
            icu::Edits::copyErrorTo(a8, (UErrorCode *)a9);
          return v10;
        }
        v12 = 15;
LABEL_140:
        v9 = a9;
LABEL_141:
        *v9 = v12;
        return v10;
      }
      continue;
    }
    return v10;
  }
}

uint64_t sub_18BC6A0B0(uint64_t *a1, int a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v15;

  if (a2 < 0)
  {
    v2 = *((_DWORD *)a1 + 5);
    *((_DWORD *)a1 + 3) = v2;
    *((_BYTE *)a1 + 28) = a2;
  }
  else
  {
    if (a2)
    {
      v2 = *((_DWORD *)a1 + 6);
      *((_DWORD *)a1 + 3) = v2;
      *((_BYTE *)a1 + 28) = a2;
      goto LABEL_14;
    }
    v2 = *((_DWORD *)a1 + 3);
    if ((*((char *)a1 + 28) & 0x80000000) == 0)
    {
LABEL_14:
      v11 = *((_DWORD *)a1 + 4);
      if (v2 < v11)
      {
        v12 = *a1;
        v13 = v2 + 1;
        *((_DWORD *)a1 + 3) = v13;
        v6 = *(unsigned __int16 *)(v12 + 2 * v2);
        if ((v6 & 0xFC00) == 0xD800 && (_DWORD)v13 != v11)
        {
          v15 = *(unsigned __int16 *)(v12 + 2 * v13);
          if ((v15 & 0xFC00) == 0xDC00)
          {
            *((_DWORD *)a1 + 3) = v2 + 2;
            v10 = v15 + ((_DWORD)v6 << 10);
            return (v10 - 56613888);
          }
        }
        return v6;
      }
      return 0xFFFFFFFFLL;
    }
  }
  v3 = *((_DWORD *)a1 + 2);
  if (v3 >= v2)
    return 0xFFFFFFFFLL;
  v4 = *a1;
  v5 = v2 - 1;
  *((_DWORD *)a1 + 3) = v5;
  v6 = *(unsigned __int16 *)(v4 + 2 * v5);
  if ((int)v5 > v3 && (v6 & 0xFC00) == 56320)
  {
    v8 = v2 - 2;
    v9 = *(unsigned __int16 *)(v4 + 2 * v8);
    if ((v9 & 0xFC00) == 0xD800)
    {
      *((_DWORD *)a1 + 3) = v8;
      v10 = v6 + (v9 << 10);
      return (v10 - 56613888);
    }
  }
  return v6;
}

uint64_t sub_18BC6A1AC(uint64_t a1, uint64_t a2, int a3, unsigned int a4, __int16 *a5, unsigned int a6, __int16 a7, icu::Edits *this)
{
  int v10;
  unsigned int v14;
  uint64_t v16;
  _WORD *v17;
  unsigned int v18;
  __int16 v19;
  uint64_t v20;

  v10 = a4;
  if ((a4 & 0x80000000) != 0)
  {
    if (this)
      icu::Edits::addUnchanged(this, a6);
    if ((a7 & 0x4000) != 0)
      return a2;
    v14 = ~v10;
    if ((int)a2 < a3 && v10 >= 0xFFFF0000)
      goto LABEL_25;
    v10 = a6;
    goto LABEL_20;
  }
  if (a4 < 0x20)
  {
    v14 = -1;
    if (!this)
      goto LABEL_20;
LABEL_19:
    icu::Edits::addReplace(this, a6, v10);
    goto LABEL_20;
  }
  if ((int)a2 >= a3 || HIWORD(a4))
  {
    v14 = a4;
    if (a4 < 0x10000)
      v10 = 1;
    else
      v10 = 2;
    if (this)
      goto LABEL_19;
LABEL_20:
    if (v10 > (int)(a2 ^ 0x7FFFFFFF))
      return 0xFFFFFFFFLL;
    if ((int)a2 >= a3)
      return (v10 + a2);
    if ((v14 & 0x80000000) == 0)
    {
      if (!HIWORD(v14))
      {
LABEL_25:
        v16 = (a2 + 1);
        *(_WORD *)(a1 + 2 * (int)a2) = v14;
        return v16;
      }
      if (HIWORD(v14) <= 0x10u)
      {
        v20 = (int)a2 + 1;
        if ((int)v20 < a3)
        {
          *(_WORD *)(a1 + 2 * (int)a2) = (v14 >> 10) - 10304;
          v16 = (a2 + 2);
          *(_WORD *)(a1 + 2 * v20) = v14 & 0x3FF | 0xDC00;
          return v16;
        }
      }
      return (v10 + a2);
    }
    v16 = (v10 + a2);
    if ((int)v16 > a3)
      return v16;
    if (v10 >= 1)
    {
      v17 = (_WORD *)(a1 + 2 * (int)a2);
      v18 = v10 + 1;
      do
      {
        v19 = *a5++;
        *v17++ = v19;
        --v18;
      }
      while (v18 > 1);
      return v16;
    }
    return a2;
  }
  v16 = (a2 + 1);
  *(_WORD *)(a1 + 2 * (int)a2) = a4;
  if (this)
    icu::Edits::addReplace(this, a6, 1);
  return v16;
}

uint64_t sub_18BC6A344(int a1, __int16 a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, icu::Edits *a9, _DWORD *a10)
{
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  unsigned int v20;
  int32_t v22;
  int v23;
  unsigned int v24;
  int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  _UNKNOWN **v37;
  _BYTE *v38;
  int v41[2];

  if (a1 == 1)
    goto LABEL_4;
  if (a1 < 0)
  {
    if ((a2 & 7) == 0)
      goto LABEL_4;
  }
  else if ((a1 & 0xFFFFFFFE) != 2)
  {
LABEL_4:
    v13 = &unk_18BDE7FD6;
    goto LABEL_7;
  }
  v13 = &unk_18BDE8156;
LABEL_7:
  v38 = v13;
  v37 = sub_18BC05D2C();
  v14 = 0;
  LODWORD(v15) = a7;
  while (2)
  {
    if ((int)v15 >= a8)
    {
      LOWORD(v18) = 0;
      LODWORD(v16) = v15;
      goto LABEL_43;
    }
    LODWORD(v16) = v15;
    v17 = a7;
    while (1)
    {
      v18 = *(unsigned __int16 *)(a5 + 2 * (int)v16);
      if (v18 <= 0x17E)
      {
        v19 = (char)v38[v18];
        if (v19 == -128)
          break;
        v16 = (v16 + 1);
        a7 = v16;
        if (v38[v18])
          goto LABEL_22;
        goto LABEL_21;
      }
      if (v18 >> 11 > 0x1A)
        break;
      v20 = *((unsigned __int16 *)*v37
            + 4 * *(unsigned __int16 *)((char *)*v37 + ((v18 >> 4) & 0xFFE))
            + (v18 & 0x1F));
      if ((v20 & 8) != 0)
        break;
      v16 = (v16 + 1);
      if (v20 >= 0x80 && (v20 & 2) != 0)
      {
        v19 = (__int16)v20 >> 7;
        a7 = v16;
LABEL_22:
        v22 = a7 + ~(_DWORD)v17;
        if (v22 < 1)
          goto LABEL_29;
        if (a9)
          icu::Edits::addUnchanged(a9, a7 + ~(_DWORD)v17);
        if ((a2 & 0x4000) != 0)
        {
LABEL_29:
          v23 = v14;
        }
        else
        {
          if ((v14 ^ 0x7FFFFFFF) < v22)
            goto LABEL_73;
          v23 = v22 + v14;
          if (v22 + (int)v14 <= a4)
            u_memcpy((UChar *)(a3 + 2 * (int)v14), (const UChar *)(a5 + 2 * (int)v17), v22);
        }
        if (v23 < 0)
          goto LABEL_73;
        LOWORD(v18) = v19 + v18;
        if (v23 < a4)
        {
          *(_WORD *)(a3 + 2 * v23) = v18;
          goto LABEL_36;
        }
        if (v23 == 0x7FFFFFFF)
        {
          v14 = 0xFFFFFFFFLL;
          if (!a9)
          {
LABEL_38:
            LODWORD(v16) = a7;
            if ((v14 & 0x80000000) != 0)
              goto LABEL_73;
            goto LABEL_39;
          }
        }
        else
        {
LABEL_36:
          v14 = (v23 + 1);
          if (!a9)
            goto LABEL_38;
        }
        icu::Edits::addReplace(a9, 1, 1);
        goto LABEL_38;
      }
LABEL_21:
      a7 = v17;
LABEL_39:
      v17 = a7;
      if ((int)v16 >= a8)
        goto LABEL_43;
    }
    a7 = v17;
LABEL_43:
    if ((int)v16 < a8)
    {
      v15 = (v16 + 1);
      v24 = (unsigned __int16)v18;
      if ((v18 & 0xFC00) == 0xD800 && (int)v15 < a8)
      {
        v25 = *(unsigned __int16 *)(a5 + 2 * (int)v15);
        v26 = a1;
        if ((v25 & 0xFC00) == 0xDC00)
        {
          v24 = v25 + ((unsigned __int16)v18 << 10) - 56613888;
          v15 = (v16 + 2);
        }
      }
      else
      {
        v26 = a1;
      }
      *(_QWORD *)v41 = 0;
      if (v26 < 0)
      {
        v27 = ucase_toFullFolding(v24, v41, a2);
      }
      else
      {
        *(_DWORD *)(a6 + 20) = v16;
        *(_DWORD *)(a6 + 24) = v15;
        v27 = ucase_toFullLower(v24, (uint64_t (*)(uint64_t, _QWORD))sub_18BC6A0B0, a6, v41, v26);
      }
      v28 = v27;
      if ((v27 & 0x80000000) == 0)
      {
        v29 = v16 - a7;
        if ((int)v16 - (int)a7 < 1)
          goto LABEL_60;
        if (a9)
          icu::Edits::addUnchanged(a9, v16 - a7);
        if ((a2 & 0x4000) != 0)
        {
LABEL_60:
          v30 = v14;
          goto LABEL_61;
        }
        if ((v14 ^ 0x7FFFFFFF) < v29)
          goto LABEL_73;
        v30 = v29 + v14;
        if ((int)v30 <= a4)
          u_memcpy((UChar *)(a3 + 2 * (int)v14), (const UChar *)(a5 + 2 * (int)a7), v16 - a7);
LABEL_61:
        if ((v30 & 0x80000000) != 0)
          goto LABEL_73;
        v14 = sub_18BC6A1AC(a3, v30, a4, v28, *(__int16 **)v41, (int)v15 - (int)v16, a2, a9);
        a7 = v15;
        if ((v14 & 0x80000000) != 0)
          goto LABEL_73;
      }
      continue;
    }
    break;
  }
  v31 = v16 - a7;
  if ((int)v16 - (int)a7 < 1)
    goto LABEL_71;
  if (a9)
    icu::Edits::addUnchanged(a9, v16 - a7);
  if ((a2 & 0x4000) != 0)
  {
LABEL_71:
    v32 = v14;
  }
  else
  {
    if ((v14 ^ 0x7FFFFFFF) < v31)
      goto LABEL_73;
    v32 = v31 + v14;
    if ((int)v32 <= a4)
      u_memcpy((UChar *)(a3 + 2 * (int)v14), (const UChar *)(a5 + 2 * (int)a7), v16 - a7);
  }
  if ((v32 & 0x80000000) != 0)
  {
LABEL_73:
    v32 = 0;
    *a10 = 8;
  }
  return v32;
}

uint64_t sub_18BC6A6F8(unsigned int a1)
{
  if (a1 - 8487 < 0xFFFFE249 || (a1 - 1024) >> 8 < 0x1B)
    return 0;
  if (a1 <= 0x3FF)
    return word_18BE1A594[a1 - 880];
  if (!(a1 >> 13))
    return word_18BE1A6B4[a1 - 7936];
  if (a1 == 8486)
    return 5033;
  return 0;
}

uint64_t sub_18BC6A770(int a1)
{
  uint64_t result;

  result = 0x4000;
  if ((a1 - 768) <= 0x14)
  {
    if (((1 << a1) & 0x2000F) != 0)
      return result;
    if (((1 << a1) & 0x180050) != 0)
      return 0x20000;
    if (a1 == 776)
      return 0x10000;
  }
  switch(a1)
  {
    case 834:
      return result;
    case 835:
      return 0x20000;
    case 836:
      result = 81920;
      break;
    case 837:
      result = 0x2000;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

BOOL sub_18BC6A804(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  unsigned int v6;
  int v8;
  BOOL v9;
  int v10;
  int TypeOrIgnorable;

  while (a2 < a3)
  {
    v5 = a2 + 1;
    v6 = *(unsigned __int16 *)(a1 + 2 * a2);
    if ((v6 & 0xFC00) == 0xD800 && (_DWORD)v5 != a3)
    {
      v8 = *(unsigned __int16 *)(a1 + 2 * v5);
      v9 = (v8 & 0xFC00) == 56320;
      v10 = v8 + (v6 << 10) - 56613888;
      if (v9)
        LODWORD(v5) = a2 + 2;
      if (v9)
        v6 = v10;
    }
    TypeOrIgnorable = ucase_getTypeOrIgnorable(v6);
    a2 = v5;
    if ((TypeOrIgnorable & 4) == 0)
      return TypeOrIgnorable != 0;
  }
  return 0;
}

uint64_t sub_18BC6A8A4(__int16 a1, uint64_t a2, int a3, uint64_t a4, int a5, icu::Edits *a6, _DWORD *a7)
{
  int v7;
  uint64_t v10;
  char v11;
  uint64_t v12;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  BOOL v18;
  int v19;
  BOOL v20;
  int v21;
  int TypeOrIgnorable;
  char v23;
  int v24;
  char v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  char v36;
  char v37;
  int v38;
  char v39;
  _BOOL4 v40;
  BOOL v41;
  int v42;
  uint64_t v43;
  char v45;
  BOOL v46;
  BOOL v47;
  unsigned int v48;
  int v49;
  __int16 v50;
  __int16 v51;
  uint64_t v52;
  char v53;
  _WORD *v54;
  BOOL v59;
  char v63;
  uint64_t v64;
  uint64_t v65;
  int v66[2];

  if (a5 < 1)
    return 0;
  v7 = a5;
  LODWORD(v10) = 0;
  v11 = 0;
  v12 = 0;
  v14 = (a1 & 0x4000) == 0 && a6 == 0;
  v59 = v14;
  v65 = a5;
  while (1)
  {
    v15 = (int)v10;
    v16 = (int)v10 + 1;
    v17 = *(unsigned __int16 *)(a4 + 2 * (int)v10);
    v18 = (v17 & 0xFC00) != 0xD800 || (_DWORD)v16 == v7;
    LODWORD(v10) = v10 + 1;
    if (!v18)
    {
      v19 = *(unsigned __int16 *)(a4 + 2 * v16);
      v20 = (v19 & 0xFC00) == 56320;
      v21 = v19 + (v17 << 10) - 56613888;
      LODWORD(v10) = v20 ? v15 + 2 : v16;
      if (v20)
        v17 = v21;
    }
    v64 = v15;
    TypeOrIgnorable = ucase_getTypeOrIgnorable(v17);
    v23 = v11;
    v24 = v11 & 1;
    v25 = TypeOrIgnorable != 0;
    if ((TypeOrIgnorable & 4) != 0)
      v25 = v11 & 1;
    v63 = v25;
    v26 = sub_18BC6A6F8(v17);
    if (!v26)
    {
      *(_QWORD *)v66 = 0;
      v34 = ucase_toFullUpper(v17, 0, 0, v66, 4);
      v35 = sub_18BC6A1AC(a2, v12, a3, v34, *(__int16 **)v66, (int)v10 - (int)v64, a1, a6);
      if ((v35 & 0x80000000) != 0)
        break;
      v12 = v35;
      v11 = v63;
      goto LABEL_113;
    }
    v27 = v26;
    v28 = v26 & 0x3FF;
    if ((v26 & 0x1000) != 0 && (v23 & 6) != 0 && (v28 == 933 || v28 == 921))
    {
      if ((v23 & 4) != 0)
        v29 = 0x8000;
      else
        v29 = 0x10000;
      v27 = v26 | v29;
    }
    v30 = (v27 >> 13) & 1;
    if ((int)v10 >= v7)
    {
      v32 = v27;
    }
    else
    {
      v31 = v26 & 0x3FF;
      v10 = (int)v10;
      v32 = v27;
      while (1)
      {
        v33 = sub_18BC6A770(*(unsigned __int16 *)(a4 + 2 * v10));
        if (!v33)
          break;
        v32 |= v33;
        v30 += (v33 >> 13) & 1;
        if (v65 == ++v10)
        {
          LODWORD(v10) = v65;
          break;
        }
      }
      v28 = v31;
    }
    if ((v27 & 0x4000) != 0)
      v36 = 4;
    else
      v36 = 2;
    if ((v32 & 0xD000) == 0x5000)
      v37 = v36;
    else
      v37 = 0;
    if (v28 != 919
      || (v32 & 0x4000) == 0
      || v30
      || v24
      || (v38 = v28, v39 = v37, v40 = sub_18BC6A804(a4, v10, a5), v37 = v39, v28 = v38, v40))
    {
      if ((v32 & 0x8000) != 0)
      {
        v43 = v64;
        if (v28 == 933)
        {
          v32 = 0;
          v41 = 0;
          LOBYTE(v42) = 1;
          v28 = 939;
        }
        else if (v28 == 921)
        {
          v32 = 0;
          v41 = 0;
          LOBYTE(v42) = 1;
          v28 = 938;
        }
        else
        {
          v41 = 0;
          LOBYTE(v42) = 1;
        }
      }
      else
      {
        v41 = 0;
        LOBYTE(v42) = 1;
        v43 = v64;
      }
    }
    else
    {
      v42 = (unsigned __int16)(v27 & 0x4000) >> 14;
      if ((v27 & 0x4000) != 0)
        v28 = 905;
      else
        v28 = 919;
      v43 = v64;
      v41 = (v27 & 0x4000) == 0;
    }
    v11 = v37 | v63;
    if (!v59)
    {
      v45 = v28 != *(unsigned __int16 *)(a4 + 2 * v43) || v30 != 0;
      if ((v32 & 0x18000) != 0)
      {
        v46 = (int)v16 >= (int)v10 || *(_WORD *)(a4 + 2 * (int)v16) != 776;
        v45 |= v46;
        LODWORD(v16) = v43 + 2;
      }
      if ((v42 & 1) == 0)
      {
        v47 = (int)v16 >= (int)v10 || *(_WORD *)(a4 + 2 * (int)v16) != 769;
        v45 |= v47;
        LODWORD(v16) = v16 + 1;
      }
      v48 = v10 - v43;
      v49 = v16 - v43 + v30;
      if ((v45 & 1) != 0 || v48 != v49)
      {
        if (a6)
        {
          v51 = v28;
          icu::Edits::addReplace(a6, v48, v49);
          LOWORD(v28) = v51;
        }
      }
      else
      {
        if (a6)
        {
          v50 = v28;
          icu::Edits::addUnchanged(a6, v48);
          LOWORD(v28) = v50;
        }
        if ((a1 & 0x4000) != 0)
          goto LABEL_113;
      }
    }
    if ((int)v12 >= a3)
    {
      if ((_DWORD)v12 == 0x7FFFFFFF)
        break;
    }
    else
    {
      *(_WORD *)(a2 + 2 * (int)v12) = v28;
    }
    v52 = (v12 + 1);
    if ((int)v12 >= -1 && (v32 & 0x18000) != 0)
    {
      if ((int)v52 >= a3)
      {
        if ((_DWORD)v12 == 2147483646)
          break;
      }
      else
      {
        *(_WORD *)(a2 + 2 * v52) = 776;
      }
      v52 = (v12 + 2);
    }
    v53 = !v41;
    if ((int)v52 < 0)
      v53 = 1;
    if ((v53 & 1) == 0)
    {
      if ((int)v52 >= a3)
      {
        if ((_DWORD)v52 == 0x7FFFFFFF)
          break;
      }
      else
      {
        *(_WORD *)(a2 + 2 * v52) = 769;
      }
      v52 = (v52 + 1);
    }
    if ((v52 & 0x80000000) != 0 || v30 < 1)
    {
      v12 = v52;
    }
    else
    {
      v54 = (_WORD *)(a2 + 2 * (int)v52);
      do
      {
        if ((int)v52 >= a3)
        {
          if ((_DWORD)v52 == 0x7FFFFFFF)
            goto LABEL_115;
        }
        else
        {
          *v54 = 921;
        }
        v12 = (v52 + 1);
        if ((int)v52 < -1)
          break;
        ++v54;
        LODWORD(v52) = v52 + 1;
      }
      while (v30-- > 1);
    }
    if ((v12 & 0x80000000) != 0)
      break;
LABEL_113:
    v7 = a5;
    if ((int)v10 >= a5)
      return v12;
  }
LABEL_115:
  v12 = 0;
  *a7 = 8;
  return v12;
}

uint64_t sub_18BC6AD4C(int a1, __int16 a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, unsigned int a7, icu::Edits *a8, UErrorCode *a9)
{
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[4];

  v14[3] = 0;
  v14[0] = a6;
  v14[1] = 0;
  v14[2] = a7;
  v11 = sub_18BC6A344(a1, a2, a4, a5, a6, (uint64_t)v14, 0, a7, a8, a9);
  v12 = v11;
  if (*(int *)a9 <= 0)
  {
    if ((int)v11 <= a5)
    {
      if (a8)
        icu::Edits::copyErrorTo(a8, a9);
    }
    else
    {
      *a9 = U_BUFFER_OVERFLOW_ERROR;
    }
  }
  return v12;
}

uint64_t sub_18BC6ADE8(int a1, __int16 a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, int a7, icu::Edits *a8, UErrorCode *a9)
{
  int v12;
  UErrorCode *v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  unsigned int v23;
  int32_t v25;
  int v26;
  unsigned int v27;
  int v28;
  BOOL v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v36;
  _UNKNOWN **v39;
  _BYTE *v40;
  _QWORD v43[2];
  uint64_t v44;
  uint64_t v45;
  int v46[2];

  v12 = a5;
  v13 = a9;
  if (a1 == 4)
  {
    v14 = sub_18BC6A8A4(a2, a4, a5, a6, a7, a8, a9);
    goto LABEL_62;
  }
  v45 = 0;
  v43[0] = a6;
  v43[1] = 0;
  v44 = a7;
  v15 = &unk_18BDE82D6;
  if (a1 == 2)
    v15 = &unk_18BDE8456;
  v40 = v15;
  v39 = sub_18BC05D2C();
  v16 = 0;
  v17 = 0;
  LODWORD(v18) = 0;
  while (2)
  {
    if ((int)v18 >= a7)
    {
      LOWORD(v21) = 0;
      LODWORD(v19) = v18;
      goto LABEL_41;
    }
    LODWORD(v19) = v18;
    v20 = v17;
    while (1)
    {
      v21 = *(unsigned __int16 *)(a6 + 2 * (int)v19);
      if (v21 <= 0x17E)
      {
        v22 = (char)v40[v21];
        if (v22 == -128)
          break;
        v19 = (v19 + 1);
        v17 = v19;
        if (v40[v21])
          goto LABEL_20;
        goto LABEL_18;
      }
      if (v21 >> 11 > 0x1A)
        break;
      v23 = *((unsigned __int16 *)*v39
            + 4 * *(unsigned __int16 *)((char *)*v39 + ((v21 >> 4) & 0xFFE))
            + (v21 & 0x1F));
      if ((v23 & 8) != 0)
        break;
      v19 = (v19 + 1);
      if (v23 >= 0x80 && (v23 & 3) == 1)
      {
        v22 = (__int16)v23 >> 7;
        v17 = v19;
LABEL_20:
        v25 = v17 + ~(_DWORD)v20;
        if (v25 < 1)
          goto LABEL_27;
        if (a8)
          icu::Edits::addUnchanged(a8, v17 + ~(_DWORD)v20);
        if ((a2 & 0x4000) != 0)
        {
LABEL_27:
          v26 = v16;
        }
        else
        {
          if ((v16 ^ 0x7FFFFFFF) < v25)
            goto LABEL_61;
          v26 = v25 + v16;
          if (v25 + (int)v16 <= a5)
            u_memcpy((UChar *)(a4 + 2 * (int)v16), (const UChar *)(a6 + 2 * (int)v20), v25);
        }
        if (v26 < 0)
          goto LABEL_61;
        LOWORD(v21) = v22 + v21;
        if (v26 < a5)
        {
          *(_WORD *)(a4 + 2 * v26) = v21;
          goto LABEL_34;
        }
        if (v26 == 0x7FFFFFFF)
        {
          v16 = 0xFFFFFFFFLL;
          if (!a8)
          {
LABEL_36:
            LODWORD(v19) = v17;
            if ((v16 & 0x80000000) != 0)
              goto LABEL_61;
            goto LABEL_37;
          }
        }
        else
        {
LABEL_34:
          v16 = (v26 + 1);
          if (!a8)
            goto LABEL_36;
        }
        icu::Edits::addReplace(a8, 1, 1);
        goto LABEL_36;
      }
LABEL_18:
      v17 = v20;
LABEL_37:
      v20 = v17;
      if ((int)v19 >= a7)
        goto LABEL_41;
    }
    v17 = v20;
LABEL_41:
    if ((int)v19 < a7)
    {
      v18 = (v19 + 1);
      HIDWORD(v44) = v19;
      v27 = (unsigned __int16)v21;
      if ((v21 & 0xFC00) == 0xD800 && (int)v18 < a7)
      {
        v28 = *(unsigned __int16 *)(a6 + 2 * (int)v18);
        v29 = (v28 & 0xFC00) == 56320;
        v30 = v28 + ((unsigned __int16)v21 << 10) - 56613888;
        v18 = v29 ? (v19 + 2) : (v19 + 1);
        if (v29)
          v27 = v30;
      }
      LODWORD(v45) = v18;
      *(_QWORD *)v46 = 0;
      v31 = ucase_toFullUpper(v27, (uint64_t (*)(uint64_t, _QWORD))sub_18BC6A0B0, (uint64_t)v43, v46, a1);
      if ((v31 & 0x80000000) == 0)
      {
        v32 = v31;
        v33 = v19 - v17;
        if ((int)v19 - (int)v17 < 1)
          goto LABEL_58;
        if (a8)
          icu::Edits::addUnchanged(a8, v19 - v17);
        if ((a2 & 0x4000) != 0)
        {
LABEL_58:
          v34 = v16;
          goto LABEL_59;
        }
        if ((v16 ^ 0x7FFFFFFF) < v33)
          goto LABEL_61;
        v34 = v33 + v16;
        if ((int)v34 <= a5)
          u_memcpy((UChar *)(a4 + 2 * (int)v16), (const UChar *)(a6 + 2 * (int)v17), v19 - v17);
LABEL_59:
        if ((v34 & 0x80000000) != 0
          || (v16 = sub_18BC6A1AC(a4, v34, a5, v32, *(__int16 **)v46, (int)v18 - (int)v19, a2, a8),
              v17 = v18,
              (v16 & 0x80000000) != 0))
        {
LABEL_61:
          v14 = 0;
          v13 = a9;
          *a9 = U_INDEX_OUTOFBOUNDS_ERROR;
          v12 = a5;
          goto LABEL_62;
        }
      }
      continue;
    }
    break;
  }
  v36 = v19 - v17;
  if ((int)v19 - (int)v17 < 1)
  {
    v14 = v16;
    v13 = a9;
    v12 = a5;
    goto LABEL_77;
  }
  if (a8)
    icu::Edits::addUnchanged(a8, v19 - v17);
  v13 = a9;
  v12 = a5;
  if ((a2 & 0x4000) != 0)
  {
    v14 = v16;
    goto LABEL_77;
  }
  if ((v16 ^ 0x7FFFFFFF) < v36)
    goto LABEL_78;
  v14 = v36 + v16;
  if ((int)v14 <= a5)
    u_memcpy((UChar *)(a4 + 2 * (int)v16), (const UChar *)(a6 + 2 * (int)v17), v36);
LABEL_77:
  if ((v14 & 0x80000000) != 0)
  {
LABEL_78:
    v14 = 0;
    *v13 = U_INDEX_OUTOFBOUNDS_ERROR;
  }
LABEL_62:
  if (*(int *)v13 <= 0)
  {
    if ((int)v14 <= v12)
    {
      if (a8)
        icu::Edits::copyErrorTo(a8, v13);
    }
    else
    {
      *v13 = U_BUFFER_OVERFLOW_ERROR;
    }
  }
  return v14;
}

