objc_object *sub_1800FD41C(objc_object *a1, double a2)
{
  uint64_t v2;
  char v3;

  __clrex();
  if ((v3 & 2) != 0 && (*(_DWORD *)((v2 & 0xFFFFFFFF8) + 0x28) & 2) != 0)
    return (objc_object *)swiftRetain(a1, a2);
  else
    return -[objc_object retain](a1, sel_retain);
}

id objc_alloc(id result)
{
  if (result)
  {
    if ((*(_WORD *)((*(_QWORD *)result & 0xFFFFFFFF8) + 0x1E) & 0x4000) != 0)
      return _objc_rootAllocWithZone((uint64_t)result);
    else
      return objc_msgSend(result, sel_alloc);
  }
  return result;
}

BOOL object_isClass(id obj)
{
  _BOOL4 v1;

  if ((uint64_t)obj < 1)
    LOBYTE(v1) = 0;
  else
    return (*(unsigned __int16 *)((*(_QWORD *)obj & 0xFFFFFFFF8) + 0x1E) >> 2) & 1;
  return v1;
}

id objc_msgSend(id result, SEL a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t *v20;
  const char *v21;
  uint64_t v22;
  uint64_t *v23;
  unint64_t v24;
  const char *v25;
  BOOL v26;
  unint64_t v27;
  uint64_t v28;

  if ((uint64_t)result > 0)
  {
    v16 = *(_QWORD *)result & 0xFFFFFFFF8;
    goto LABEL_3;
  }
  if (result)
  {
    if ((result & 7) == 7)
      v28 = (uint64_t)result >> 55;
    else
      v28 = result & 7;
    v16 = objc_debug_taggedpointer_classes[v28];
LABEL_3:
    while (1)
    {
      v17 = *(_QWORD *)(v16 + 16);
      v18 = v17 & 0xFFFFFFFFFFFELL;
      if ((v17 & 1) == 0)
        break;
      v27 = *(_QWORD *)(v18 + 8 * (((a2 - (SEL)&unk_1F25805A8) >> SBYTE6(v17)) & (v17 >> 53)));
      if (a2 - (SEL)&unk_1F25805A8 == v27 >> 38)
        return (id)((uint64_t (*)(void))(v16 - ((uint64_t)(v27 << 26) >> 24)))();
      v16 += *(_QWORD *)(v18 - 16);
    }
    v19 = ((unint64_t)a2 ^ ((unint64_t)a2 >> 7)) & HIWORD(v17);
    v20 = (uint64_t *)(v18 + 16 * v19);
    while (1)
    {
      v22 = *v20;
      v21 = (const char *)v20[1];
      v20 -= 2;
      if (v21 == a2)
        return (id)((uint64_t (*)(void))(v22 ^ v16))();
      if (!v21)
        break;
      if ((unint64_t)v20 < v18)
      {
        v23 = (uint64_t *)(v18 + (v17 >> 44));
        v24 = v18 + 16 * v19;
        while (1)
        {
          v22 = *v23;
          v25 = (const char *)v23[1];
          v23 -= 2;
          if (v25 == a2)
            break;
          if (v25)
            v26 = (unint64_t)v23 > v24;
          else
            v26 = 0;
          if (!v26)
            return (id)_objc_msgSend_uncached((objc_object *)result, (objc_selector *)a2, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
        }
        return (id)((uint64_t (*)(void))(v22 ^ v16))();
      }
    }
    return (id)_objc_msgSend_uncached((objc_object *)result, (objc_selector *)a2, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
  }
  return result;
}

objc_object *objc_msgLookup(objc_object *a1, objc_selector *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  objc_selector *v7;
  unint64_t v8;
  unint64_t v9;
  objc_selector *v10;
  BOOL v11;
  uint64_t v12;

  if ((uint64_t)a1 > 0)
  {
    v2 = (uint64_t)a1->isa & 0xFFFFFFFF8;
    goto LABEL_3;
  }
  if (a1)
  {
    if ((a1 & 7) == 7)
      v12 = (uint64_t)a1 >> 55;
    else
      v12 = a1 & 7;
    v2 = objc_debug_taggedpointer_classes[v12];
LABEL_3:
    while (1)
    {
      v3 = *(_QWORD *)(v2 + 16);
      v4 = v3 & 0xFFFFFFFFFFFELL;
      if ((v3 & 1) == 0)
        break;
      if (a2 - (objc_selector *)&unk_1F25805A8 == *(_QWORD *)(v4
                                                             + 8
                                                             * (((a2 - (objc_selector *)&unk_1F25805A8) >> SBYTE6(v3)) & (v3 >> 53))) >> 38)
        return a1;
      v2 += *(_QWORD *)(v4 - 16);
    }
    v5 = ((unint64_t)a2 ^ ((unint64_t)a2 >> 7)) & HIWORD(v3);
    v6 = v4 + 16 * v5;
    while (1)
    {
      v7 = *(objc_selector **)(v6 + 8);
      v6 -= 16;
      if (v7 == a2)
        break;
      if (!v7)
        return _objc_msgLookup_uncached(a1, a2);
      if (v6 < v4)
      {
        v8 = v4 + (v3 >> 44);
        v9 = v4 + 16 * v5;
        while (1)
        {
          v10 = *(objc_selector **)(v8 + 8);
          v8 -= 16;
          if (v10 == a2)
            break;
          if (v10)
            v11 = v8 > v9;
          else
            v11 = 0;
          if (!v11)
            return _objc_msgLookup_uncached(a1, a2);
        }
        return a1;
      }
    }
  }
  return a1;
}

double _objc_msgNil()
{
  return 0.0;
}

double _objc_returnNil()
{
  return _objc_msgNil();
}

id objc_msgSendSuper(objc_super *a1, SEL a2, ...)
{
  JUMPOUT(0x1800FF268);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  objc_object *receiver;
  uint64_t i;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  const char *v23;
  uint64_t v24;
  uint64_t *v26;
  unint64_t v27;
  const char *v28;
  BOOL v29;
  unint64_t v30;

  receiver = (objc_object *)a1->receiver;
  for (i = *((_QWORD *)a1->super_class + 1); ; i += *(_QWORD *)(v20 - 16))
  {
    v19 = *(_QWORD *)(i + 16);
    v20 = v19 & 0xFFFFFFFFFFFELL;
    if ((v19 & 1) == 0)
      break;
    v30 = *(_QWORD *)(v20 + 8 * (((a2 - (SEL)&unk_1F25805A8) >> SBYTE6(v19)) & (v19 >> 53)));
    if (a2 - (SEL)&unk_1F25805A8 == v30 >> 38)
      return (id)((uint64_t (*)(objc_object *))(i - ((uint64_t)(v30 << 26) >> 24)))(receiver);
  }
  v21 = ((unint64_t)a2 ^ ((unint64_t)a2 >> 7)) & HIWORD(v19);
  v22 = (uint64_t *)(v20 + 16 * v21);
  while (1)
  {
    v24 = *v22;
    v23 = (const char *)v22[1];
    v22 -= 2;
    if (v23 == a2)
      return (id)((uint64_t (*)(objc_object *))(v24 ^ i))(receiver);
    if (!v23)
      break;
    if ((unint64_t)v22 < v20)
    {
      v26 = (uint64_t *)(v20 + (v19 >> 44));
      v27 = v20 + 16 * v21;
      while (1)
      {
        v24 = *v26;
        v28 = (const char *)v26[1];
        v26 -= 2;
        if (v28 == a2)
          break;
        if (v28)
          v29 = (unint64_t)v26 > v27;
        else
          v29 = 0;
        if (!v29)
          return (id)_objc_msgSend_uncached(receiver, (objc_selector *)a2, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
      }
      return (id)((uint64_t (*)(objc_object *))(v24 ^ i))(receiver);
    }
  }
  return (id)_objc_msgSend_uncached(receiver, (objc_selector *)a2, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
}

objc_object *objc_msgLookupSuper2(uint64_t a1, objc_selector *a2)
{
  objc_object *result;
  uint64_t i;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  objc_selector *v9;
  unint64_t v10;
  unint64_t v11;
  objc_selector *v12;
  BOOL v13;

  result = *(objc_object **)a1;
  for (i = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8); ; i += *(_QWORD *)(v6 - 16))
  {
    v5 = *(_QWORD *)(i + 16);
    v6 = v5 & 0xFFFFFFFFFFFELL;
    if ((v5 & 1) == 0)
      break;
    if (a2 - (objc_selector *)&unk_1F25805A8 == *(_QWORD *)(v6
                                                           + 8
                                                           * (((a2 - (objc_selector *)&unk_1F25805A8) >> SBYTE6(v5)) & (v5 >> 53))) >> 38)
      return result;
  }
  v7 = ((unint64_t)a2 ^ ((unint64_t)a2 >> 7)) & HIWORD(v5);
  v8 = v6 + 16 * v7;
  while (1)
  {
    v9 = *(objc_selector **)(v8 + 8);
    v8 -= 16;
    if (v9 == a2)
      break;
    if (!v9)
      return _objc_msgLookup_uncached(result, a2);
    if (v8 < v6)
    {
      v10 = v6 + (v5 >> 44);
      v11 = v6 + 16 * v7;
      while (1)
      {
        v12 = *(objc_selector **)(v10 + 8);
        v10 -= 16;
        if (v12 == a2)
          break;
        if (v12)
          v13 = v10 > v11;
        else
          v13 = 0;
        if (!v13)
          return _objc_msgLookup_uncached(result, a2);
      }
      return result;
    }
  }
  return result;
}

uint64_t _objc_msgSend_uncached(objc_object *a1, objc_selector *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9, __n128 a10, __n128 a11, __n128 a12, __n128 a13, __n128 a14, __n128 a15, __n128 a16, ...)
{
  objc_class *v16;
  void (*v17)(void);

  v17 = lookUpImpOrForward(a1, a2, v16, 3u);
  return ((uint64_t (*)(objc_object *, objc_selector *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128))v17)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
}

objc_object *_objc_msgLookup_uncached(objc_object *a1, objc_selector *a2)
{
  objc_class *v2;

  lookUpImpOrForward(a1, a2, v2, 3u);
  return a1;
}

uint64_t cache_getImp(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  unint64_t v15;

  v4 = *(_QWORD *)(a1 + 16);
  v5 = v4 & 0xFFFFFFFFFFFELL;
  if ((v4 & 1) != 0)
  {
    v15 = *(_QWORD *)(v5 + 8 * (((a2 - (_QWORD)&unk_1F25805A8) >> SBYTE6(v4)) & (v4 >> 53)));
    if (a2 - (_QWORD)&unk_1F25805A8 == v15 >> 38)
      return a1 - ((uint64_t)(v15 << 26) >> 24);
    else
      return a3;
  }
  else
  {
    v6 = (a2 ^ (a2 >> 7)) & HIWORD(v4);
    v7 = (uint64_t *)(v5 + 16 * v6);
    while (1)
    {
      v9 = *v7;
      v8 = v7[1];
      v7 -= 2;
      if (v8 == a2)
        break;
      if (!v8)
        return 0;
      if ((unint64_t)v7 < v5)
      {
        v11 = (uint64_t *)(v5 + (v4 >> 44));
        v12 = v5 + 16 * v6;
        while (1)
        {
          v9 = *v11;
          v13 = v11[1];
          v11 -= 2;
          if (v13 == a2)
            break;
          if (v13)
            v14 = (unint64_t)v11 > v12;
          else
            v14 = 0;
          if (!v14)
            return 0;
        }
        break;
      }
    }
    result = v9;
    if (v9)
      return v9 ^ a1;
  }
  return result;
}

void _objc_msgForward(void)
{
  ((void (*)())_objc_forward_handler)();
}

void method_invoke(void)
{
  uint64_t v0;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  void (*ImplementationAndName)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128);
  uint64_t v17;
  __n128 v18;
  __n128 v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  if ((v1 & 1) != 0)
  {
    v18 = v8;
    v19 = v9;
    v20 = v10;
    v21 = v11;
    v22 = v12;
    v23 = v13;
    v24 = v14;
    v25 = v15;
    v26 = v0;
    v27 = v2;
    v28 = v3;
    v29 = v4;
    v30 = v5;
    v31 = v6;
    v32 = v7;
    ImplementationAndName = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128))_method_getImplementationAndName(v1);
    ImplementationAndName(v26, v17, v27, v28, v29, v30, v31, v32, v18, v19, v20, v21, v22, v23, v24, v25);
  }
  else
  {
    (*(void (**)(void))((v1 & 0xFFFFFFFFFFFFFFFCLL) + 16))();
  }
}

Class objc_lookUpClass(Class name)
{
  if (name)
    return look_up_class((char *)name);
  return name;
}

uint64_t load_images(uint64_t a1)
{
  unint64_t v1;
  BOOL v2;
  uint64_t result;
  unint64_t v4;
  unsigned int v6;
  unint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  objc_class *LoadMethod;
  unint64_t v13;
  char *v14;
  char *v15;
  objc_class *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  const char *v20;
  char *v21;
  objc_class *v22;
  objc_class *v23;
  char *v24;
  int v25;
  uint64_t **v26;
  int v27;
  unsigned int v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(uint64_t, char *);
  char *v36;
  char *v37;
  uint64_t v38;
  uint64_t i;
  char *v40;
  uint64_t v41;
  void (*v42)(objc_class *, char *);
  unsigned int v43;
  unint64_t v45;
  objc_class *v46;
  int v47;
  unsigned int v48;
  char *v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  BOOL v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  void *v58;
  char v59;
  const char *v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  const char *v64;
  char *v65;
  uint64_t *context;
  int v67;
  unint64_t StatusReg;

  if (PrintImages)
  {
    v60 = *(const char **)(a1 + 8);
    if (!v60)
      v60 = "<null>";
    _objc_inform("IMAGES: calling +load methods in %s\n", v60);
  }
  if (_dyld_lookup_section_info())
    v2 = v1 > 7;
  else
    v2 = 0;
  if (!v2)
  {
    result = _dyld_lookup_section_info();
    if (!result || v4 < 8)
      return result;
  }
  os_unfair_recursive_lock_lock_with_options();
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v6, runtimeLock))
      goto LABEL_16;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_16:
  loadAllCategoriesIfNeeded();
  v9 = (unint64_t *)_dyld_lookup_section_info();
  if (v9 && v8 >= 8)
  {
    if (v8 >> 3 <= 1)
      v10 = 1;
    else
      v10 = v8 >> 3;
    do
    {
      v11 = remapClass(*v9);
      schedule_class_load(v11);
      ++v9;
      --v10;
    }
    while (v10);
  }
  LoadMethod = (objc_class *)_dyld_lookup_section_info();
  v16 = LoadMethod;
  if (LoadMethod && v13 >= 8)
  {
    if (v13 >> 3 <= 1)
      v17 = 1;
    else
      v17 = v13 >> 3;
    do
    {
      v18 = *(uint64_t **)v16;
      LoadMethod = (objc_class *)remapClass(*(_QWORD *)(*(_QWORD *)v16 + 8));
      if (LoadMethod)
      {
        if ((*((_BYTE *)LoadMethod + 32) & 2) != 0)
        {
          v61 = *v18;
          v62 = objc_class::nameForLogging(LoadMethod);
          _objc_fatal("Category %s on Swift class %s has +load method. Swift class extensions and categories on Swift classes are not allowed to have +load methods.", v63, v64, v65, v61, v62);
        }
        realizeClassWithoutSwift(LoadMethod, 0);
        LoadMethod = (objc_class *)_category_getLoadMethod((unsigned int *)v18[3], v19, v20, v21);
        v22 = LoadMethod;
        if (LoadMethod)
        {
          if (PrintLoading)
          {
            v23 = (objc_class *)remapClass(v18[1]);
            v24 = objc_class::nameForLogging(v23);
            _objc_inform("LOAD: category '%s(%s)' scheduled for +load", v24, (const char *)*v18);
          }
          v25 = loadable_categories_used;
          LoadMethod = (objc_class *)loadable_categories;
          if (loadable_categories_used == loadable_categories_allocated)
          {
            loadable_categories_allocated = 2 * loadable_categories_used + 16;
            LoadMethod = (objc_class *)malloc_type_realloc((void *)loadable_categories, 16 * loadable_categories_allocated, 0xA0040AFF93C70uLL);
            loadable_categories = (uint64_t)LoadMethod;
            v25 = loadable_categories_used;
          }
          v26 = (uint64_t **)((char *)LoadMethod + 16 * v25);
          *v26 = v18;
          v26[1] = (uint64_t *)v22;
          loadable_categories_used = v25 + 1;
        }
      }
      v16 = (objc_class *)((char *)v16 + 8);
      --v17;
    }
    while (v17);
  }
  v27 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v28 = __ldxr(runtimeLock);
    if (v28 != v27)
      break;
    if (!__stlxr(0, runtimeLock))
      goto LABEL_41;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_41:
  if ((call_load_methods::loading & 1) != 0)
    return os_unfair_recursive_lock_unlock();
  call_load_methods::loading = 1;
  context = AutoreleasePoolPage::push((objc_object *)LoadMethod, v13, v14, v15);
  v29 = &unk_1ECCE5000;
  v30 = loadable_classes_used;
  do
  {
    if ((int)v30 >= 1)
    {
      do
      {
        v31 = 0;
        v32 = (char *)loadable_classes;
        loadable_classes = 0;
        loadable_classes_allocated = 0;
        v29[114] = 0;
        v33 = 16 * v30;
        do
        {
          v34 = *(_QWORD *)&v32[v31];
          if (v34)
          {
            v35 = *(void (**)(uint64_t, char *))&v32[v31 + 8];
            if (PrintLoading)
            {
              v36 = objc_class::nameForLogging(*(objc_class **)&v32[v31]);
              _objc_inform("LOAD: +[%s load]\n", v36);
            }
            v35(v34, sel_load);
          }
          v31 += 16;
        }
        while (v33 != v31);
        free(v32);
        v30 = v29[114];
      }
      while ((int)v30 > 0);
    }
    v37 = (char *)loadable_categories;
    v38 = loadable_categories_used;
    v67 = loadable_categories_allocated;
    loadable_categories = 0;
    loadable_categories_allocated = 0;
    loadable_categories_used = 0;
    if ((int)v38 < 1)
    {
      v54 = 0;
      v53 = v38;
      v57 = v67;
      if (v53)
        goto LABEL_87;
      goto LABEL_84;
    }
    for (i = 0; i != v38; ++i)
    {
      v40 = &v37[16 * i];
      v41 = *(_QWORD *)v40;
      if (*(_QWORD *)v40)
      {
        v42 = (void (*)(objc_class *, char *))*((_QWORD *)v40 + 1);
        v43 = *(_DWORD *)(StatusReg + 24);
        while (!__ldaxr(runtimeLock))
        {
          if (!__stxr(v43, runtimeLock))
            goto LABEL_59;
        }
        __clrex();
        os_unfair_lock_lock_with_options();
LABEL_59:
        v45 = remapClass(*(_QWORD *)(v41 + 8));
        v46 = (objc_class *)v45;
        v47 = *(_DWORD *)(StatusReg + 24);
        while (1)
        {
          v48 = __ldxr(runtimeLock);
          if (v48 != v47)
            break;
          if (!__stlxr(0, runtimeLock))
          {
            if (!v45)
              goto LABEL_68;
            goto LABEL_65;
          }
        }
        __clrex();
        os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
        if (!v46)
          continue;
LABEL_65:
        if (PrintLoading)
        {
          v49 = objc_class::nameForLogging(v46);
          _objc_inform("LOAD: +[%s(%s) load]\n", v49, *(const char **)v41);
        }
        v42(v46, sel_load);
        *(_QWORD *)v40 = 0;
      }
LABEL_68:
      ;
    }
    v50 = 0;
    v51 = 0;
    v29 = &unk_1ECCE5000;
    do
    {
      if (*(_QWORD *)&v37[v50])
        *(_OWORD *)&v37[v50 + -16 * v51] = *(_OWORD *)&v37[v50];
      else
        ++v51;
      v50 += 16;
    }
    while (16 * v38 != v50);
    v52 = loadable_categories_used;
    v53 = v38 - v51;
    v54 = loadable_categories_used > 0;
    if (loadable_categories_used >= 1)
    {
      v55 = 0;
      v56 = 0;
      v57 = v67;
      do
      {
        if (v53 + (_DWORD)v56 == v57)
        {
          v57 = 2 * v57 + 16;
          v37 = (char *)malloc_type_realloc(v37, 16 * v57, 0xA0040AFF93C70uLL);
          v52 = loadable_categories_used;
        }
        v58 = (void *)loadable_categories;
        *(_OWORD *)&v37[16 * v53 + v55] = *(_OWORD *)(loadable_categories + v55);
        ++v56;
        v55 += 16;
      }
      while (v56 < v52);
      v53 += v56;
      v29 = (_DWORD *)&unk_1ECCE5000;
LABEL_83:
      free(v58);
      if (v53)
        goto LABEL_87;
      goto LABEL_84;
    }
    v58 = (void *)loadable_categories;
    v57 = v67;
    if (loadable_categories)
      goto LABEL_83;
    v54 = 0;
    if (v53)
      goto LABEL_87;
LABEL_84:
    if (v37)
    {
      free(v37);
      v37 = 0;
    }
    v57 = 0;
LABEL_87:
    loadable_categories = (uint64_t)v37;
    loadable_categories_used = v53;
    loadable_categories_allocated = v57;
    if (v53 && PrintLoading)
      _objc_inform("LOAD: %d categories still waiting for +load\n", v53);
    v30 = v29[114];
    v59 = (int)v30 > 0 || v54;
  }
  while ((v59 & 1) != 0);
  objc_autoreleasePoolPop(context);
  call_load_methods::loading = 0;
  return os_unfair_recursive_lock_unlock();
}

void sub_1800FFCDC(_Unwind_Exception *a1)
{
  os_unfair_recursive_lock_unlock();
  _Unwind_Resume(a1);
}

uint64_t *AutoreleasePoolPage::push(objc_object *this, uint64_t a2, char *a3, char *a4)
{
  unint64_t StatusReg;
  uint64_t v5;
  objc_object *v6;
  unint64_t v7;
  objc_object *v8;
  _QWORD *isa;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_QWORD *)(StatusReg + 352);
  v6 = (objc_object *)(v5 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v5 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    if ((v5 & 2) != 0)
    {
      v7 = *(_QWORD *)(StatusReg + 344);
      if (v7 >= 2)
      {
        if (*(_DWORD *)v7 != -1583242847)
          AutoreleasePoolPage::busted_die(*(AutoreleasePoolPage **)(StatusReg + 344), (uint64_t)v6, a3, a4);
        if (*(_QWORD *)(v7 + 16) == v7 + 4096)
          this = (objc_object *)AutoreleasePoolPage::autoreleaseFullPage(v6, *(objc_object **)(StatusReg + 344), (AutoreleasePoolPage *)a3, a4);
        else
          this = (objc_object *)AutoreleasePoolPage::add(*(AutoreleasePoolPage **)(StatusReg + 344), (uint64_t)v6);
      }
      else
      {
        this = (objc_object *)AutoreleasePoolPage::autoreleaseNoPage(v6, v6);
      }
    }
    else
    {
      *(_QWORD *)(StatusReg + 352) = -1;
      *(_QWORD *)(StatusReg + 360) = 0;
      this = v6;
    }
  }
  *(_QWORD *)(StatusReg + 352) = 0;
  *(_QWORD *)(StatusReg + 360) = 0;
  if (DebugPoolAllocation)
    return AutoreleasePoolPage::autoreleaseNewPage((AutoreleasePoolPage *)this, v6, a3, a4);
  v8 = *(objc_object **)(StatusReg + 344);
  if ((unint64_t)v8 < 2)
    return (uint64_t *)AutoreleasePoolPage::autoreleaseNoPage(0, v8);
  if (LODWORD(v8->isa) != -1583242847)
    AutoreleasePoolPage::busted_die(*(AutoreleasePoolPage **)(StatusReg + 344), (uint64_t)v8, a3, a4);
  isa = v8[2].isa;
  if (isa == (_QWORD *)&v8[512])
    return AutoreleasePoolPage::autoreleaseFullPage(0, v8, (AutoreleasePoolPage *)a3, a4);
  v8[2].isa = (Class)(isa + 1);
  *isa = 0;
  return isa;
}

void objc_autoreleasePoolPop(void *context)
{
  void *v1;
  char *v2;
  char *v3;
  _QWORD *StatusReg;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  AutoreleasePoolPage *v9;
  BOOL v10;
  uint64_t v12;
  const char *v13;
  char *v14;
  AutoreleasePoolPage *v15;

  StatusReg = (_QWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = (void *)(StatusReg[44] & 0xFFFFFFFFFFFFFFFCLL);
  if (v6)
  {
    v7 = StatusReg + 44;
    do
    {
      *v7 = 0;
      StatusReg[45] = 0;

      v6 = (void *)(*v7 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v6);
  }
  if (context == (void *)1)
  {
    v8 = (_QWORD *)StatusReg[43];
    if ((unint64_t)v8 < 2)
    {
      StatusReg[43] = 0;
      return;
    }
    if (*(_DWORD *)v8 != -1583242847)
LABEL_6:
      AutoreleasePoolPage::busted_die((AutoreleasePoolPage *)v8, (uint64_t)v1, v2, v3);
    while (1)
    {
      v9 = (AutoreleasePoolPage *)v8[4];
      if (!v9)
        break;
      v8 = (_QWORD *)v8[4];
      if (*(_DWORD *)v9 != -1583242847)
        AutoreleasePoolPage::busted_die(v9, (uint64_t)v1, v2, v3);
    }
    context = v8 + 7;
  }
  else
  {
    v8 = (_QWORD *)((unint64_t)context & 0xFFFFFFFFFFFFF000);
    if (*(_DWORD *)((unint64_t)context & 0xFFFFFFFFFFFFF000) != -1583242847)
      goto LABEL_6;
  }
  if (*(_QWORD *)context && (context != v8 + 7 || v8[4]))
  {
    AutoreleasePoolPage::badPop((AutoreleasePoolPage *)context, v1);
  }
  else
  {
    if (PrintPoolHiwat)
      v10 = 0;
    else
      v10 = DebugPoolAllocation == 0;
    if (v10 && DebugMissingPools == 0)
    {
      AutoreleasePoolPage::releaseUntil((objc_object ***)v8, (objc_object **)context, v2, v3);
      v15 = (AutoreleasePoolPage *)v8[5];
      if (v15)
      {
        if (v8[2] - (_QWORD)v8 - 56 < 2016 || (v15 = (AutoreleasePoolPage *)*((_QWORD *)v15 + 5)) != 0)
          AutoreleasePoolPage::kill(v15, v12, v13, v14);
      }
    }
    else
    {
      AutoreleasePoolPage::popPageDebug((AutoreleasePoolPage **)v8, (objc_object **)context, (AutoreleasePoolPage *)v2, (objc_object **)v3);
    }
  }
}

void *AutoreleasePoolPage::releaseUntil(objc_object ***this, objc_object **a2, const char *a3, char *a4)
{
  _QWORD *StatusReg;
  AutoreleasePoolPage *v7;
  _QWORD *v8;
  unint64_t v9;
  void *v10;
  int v11;
  void *result;

  StatusReg = (_QWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  while (1)
  {
    while (this[2] != a2)
    {
      v7 = (AutoreleasePoolPage *)StatusReg[43];
      if (!v7)
        goto LABEL_11;
      if (v7 == (AutoreleasePoolPage *)1)
      {
        v7 = 0;
        goto LABEL_11;
      }
      if (*(_DWORD *)v7 != -1583242847)
LABEL_20:
        AutoreleasePoolPage::busted_die(v7, (uint64_t)a2, a3, a4);
LABEL_11:
      while (1)
      {
        v8 = (_QWORD *)*((_QWORD *)v7 + 2);
        if (v8 != (_QWORD *)((char *)v7 + 56))
          break;
        v7 = (AutoreleasePoolPage *)*((_QWORD *)v7 + 4);
        if (v7 && *(_DWORD *)v7 != -1583242847)
          goto LABEL_20;
        StatusReg[43] = v7;
      }
      *((_QWORD *)v7 + 2) = v8 - 1;
      v9 = *(v8 - 1);
      *(v8 - 1) = 0xA3A3A3A3A3A3A3A3;
      v10 = (void *)(v9 & 0xF00FFFFFFFFFFFFLL);
      if ((v9 & 0xF00FFFFFFFFFFFFLL) != 0)
      {
        v11 = ((v9 >> 60) | (v9 >> 44) & 0xFF0) + 1;
        do
        {

          --v11;
        }
        while (v11);
      }
    }
    result = (void *)(StatusReg[44] & 0xFFFFFFFFFFFFFFFCLL);
    if (!result)
      break;
    StatusReg[44] = 0;
    StatusReg[45] = 0;

  }
  if (*(_DWORD *)this != -1583242847)
    AutoreleasePoolPage::busted_die((AutoreleasePoolPage *)this, (uint64_t)a2, a3, a4);
  StatusReg[43] = this;
  return result;
}

void _objc_rootDealloc(unint64_t a1)
{
  if ((a1 & 0x8000000000000000) == 0)
  {
    if ((*(_QWORD *)a1 & 0x140000000007) != 1)
      a1 = (unint64_t)objc_destructInstance((id)a1);
    free((void *)a1);
  }
}

void *__cdecl objc_destructInstance(id obj)
{
  uint64_t v1;
  const char *v2;
  char *v3;
  uint64_t v5;

  if (!obj)
    return obj;
  v5 = *(_QWORD *)obj;
  if ((*(_QWORD *)obj & 1) != 0)
  {
    if (((unint64_t)obj & 0x8000000000000000) == 0)
    {
      if ((v5 & 4) != 0 && (uint64_t)obj >= 1)
        object_cxxDestructFromClass((void (*)(void))obj, (objc_class *)(v5 & 0xFFFFFFFF8));
      if ((v5 & 2) == 0)
        goto LABEL_12;
    }
  }
  else if ((*(_WORD *)((v5 & 0xFFFFFFFF8) + 0x1E) & 1) != 0 && (uint64_t)obj > 0)
  {
    object_cxxDestructFromClass((void (*)(void))obj, (objc_class *)(v5 & 0xFFFFFFFF8));
  }
  _object_remove_associations((uint64_t)obj, 1);
LABEL_12:
  if ((*(_QWORD *)obj & 1) != 0)
  {
    if ((*(_QWORD *)obj & 0x140000000000) != 0)
      objc_object::clearDeallocating_slow((objc_object *)obj, v1, v2, v3);
  }
  else
  {
    objc_object::sidetable_clearDeallocating((objc_object *)obj);
  }
  return obj;
}

void _object_remove_associations(uint64_t a1, int a2)
{
  unint64_t StatusReg;
  unsigned int v5;
  int v7;
  int32x2_t *v8;
  int v9;
  void *v10;
  char *v11;
  void **v12;
  int v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  char v18;
  _QWORD *inserted;
  int v20;
  unsigned int v21;
  char *v22;
  uint64_t v23;
  char *v24;
  unsigned int v25;
  void **v26;
  uint64_t v27;
  void *v28;
  void *v29;
  _QWORD *v30;
  uint64_t i;
  void **v32;
  void *v33;
  int32x2_t *v34;
  void *ptr[4];

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&AssociationsManagerLock))
  {
    if (!__stxr(v5, (unsigned int *)&AssociationsManagerLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v34 = 0;
  v7 = objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(-a1, &v34);
  v8 = v34;
  if (v34 == (int32x2_t *)(objc::AssociationsManager::_mapStorage + 32 * dword_1ECCE5498))
    v9 = 0;
  else
    v9 = v7;
  if (v9 == 1)
  {
    v10 = 0;
    v12 = (void **)&v34[1];
    v11 = (char *)v34[1];
    v13 = v34[2].i32[0];
    v34[1] = 0;
    v8[2] = 0;
    v14 = v8[3].u32[0];
    v8[3].i32[0] = 0;
    if ((a2 & 1) == 0)
    {
      if (!v13)
        goto LABEL_29;
      v15 = v11;
      if ((_DWORD)v14)
      {
        v16 = 24 * v14;
        v15 = v11;
        while (*(_QWORD *)v15 >= 0xFFFFFFFFFFFFFFFELL)
        {
          v15 += 24;
          v16 -= 24;
          if (!v16)
            goto LABEL_29;
        }
      }
      v17 = &v11[24 * v14];
      if (v15 == v17)
      {
LABEL_29:
        v10 = 0;
      }
      else
      {
        v18 = 0;
LABEL_20:
        if ((v15[10] & 1) != 0)
        {
          v34 = 0;
          if ((objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>((uint64_t)&v8[1], *(_QWORD *)v15, &v34) & 1) == 0)
          {
            inserted = objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::InsertIntoBucketImpl<void const*>(v8 + 1, (unint64_t *)v15, v34);
            *inserted = *(_QWORD *)v15;
            *(_OWORD *)(inserted + 1) = *(_OWORD *)(v15 + 8);
          }
          v18 = 1;
        }
        while (1)
        {
          v15 += 24;
          if (v15 == v17)
            break;
          if (*(_QWORD *)v15 < 0xFFFFFFFFFFFFFFFELL)
          {
            if (v15 != v17)
              goto LABEL_20;
            break;
          }
        }
        if ((v18 & 1) != 0)
        {
          v13 = 1;
          goto LABEL_31;
        }
        v10 = *v12;
      }
    }
    free(v10);
    *v8 = (int32x2_t)2;
    qword_1ECCE5490 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE5490, (int32x2_t)0x1FFFFFFFFLL);
    objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::compact();
    goto LABEL_31;
  }
  LODWORD(v14) = 0;
  v13 = 0;
  v11 = 0;
LABEL_31:
  v20 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v21 = __ldxr((unsigned int *)&AssociationsManagerLock);
    if (v21 != v20)
      break;
    if (!__stlxr(0, (unsigned int *)&AssociationsManagerLock))
      goto LABEL_36;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
LABEL_36:
  LODWORD(v34) = 0;
  ptr[0] = 0;
  if (v13)
  {
    v22 = v11;
    if ((_DWORD)v14)
    {
      v23 = 24 * v14;
      v22 = v11;
      while (*(_QWORD *)v22 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v22 += 24;
        v23 -= 24;
        if (!v23)
          goto LABEL_71;
      }
    }
    v24 = &v11[24 * v14];
    if (v22 != v24)
    {
      v25 = 0;
      v26 = ptr;
LABEL_44:
      v28 = v22 + 8;
      v27 = *((_QWORD *)v22 + 1);
      if ((v27 & 0x10000) != 0)
      {
        if (a2)
        {
          if (v25 > 3)
          {
            if (v25 == 4)
            {
              v30 = malloc_type_malloc(0x28uLL, 0x2004093837F09uLL);
              for (i = 0; i != 4; ++i)
                v30[i] = ptr[i];
              v30[4] = v28;
              ptr[0] = v30;
            }
            else
            {
              ptr[0] = malloc_type_realloc(ptr[0], 8 * (v25 + 1), 0x2004093837F09uLL);
              *((_QWORD *)ptr[0] + v25) = v28;
            }
          }
          else
          {
            ptr[v25] = v28;
          }
          LODWORD(v34) = ++v25;
        }
      }
      else if ((v27 & 1) != 0)
      {
        v29 = (void *)*((_QWORD *)v22 + 2);
        if (v29)

      }
      while (1)
      {
        v22 += 24;
        if (v22 == v24)
          break;
        if (*(_QWORD *)v22 < 0xFFFFFFFFFFFFFFFELL)
        {
          if (v22 != v24)
            goto LABEL_44;
          break;
        }
      }
      if (v25 >= 5)
      {
        v26 = (void **)ptr[0];
      }
      else if (!v25)
      {
        goto LABEL_71;
      }
      v32 = &v26[v25];
      do
      {
        v33 = (void *)*((_QWORD *)*v26 + 1);
        if (v33 && (*(_BYTE *)*v26 & 1) != 0)

        ++v26;
      }
      while (v26 != v32);
      if (v34 >= 5)
        free(ptr[0]);
    }
  }
LABEL_71:
  free(v11);
}

void sub_1801005B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, void *a11)
{
  void *v11;
  unsigned int v12;

  if (v12 >= 5)
    free(a11);
  free(v11);
  _Unwind_Resume(a1);
}

uint64_t objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v6;
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  int v10;

  if (dword_1ECCE5498)
  {
    v2 = (dword_1ECCE5498 - 1) & (bswap64(0x8A970BE7488FDA55 * (-a1 ^ ((unint64_t)-a1 >> 4))) ^ (1217387093 * (-(int)a1 ^ ((unint64_t)-a1 >> 4))));
    v3 = (_QWORD *)(objc::AssociationsManager::_mapStorage + 32 * v2);
    if (a1 == *v3)
    {
      v4 = 1;
    }
    else
    {
      v6 = 0;
      v7 = -*v3;
      v8 = 1;
      while (v7 != -1)
      {
        if (v8 > dword_1ECCE5498)
          objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::FatalCorruptHashTables((_QWORD *)objc::AssociationsManager::_mapStorage, dword_1ECCE5498);
        if (v6)
          v9 = 0;
        else
          v9 = v7 == -2;
        if (v9)
          v6 = v3;
        v10 = v2 + v8++;
        v2 = v10 & (dword_1ECCE5498 - 1);
        v3 = (_QWORD *)(objc::AssociationsManager::_mapStorage + 32 * v2);
        v7 = -*v3;
        v4 = 1;
        if (*v3 == a1)
          goto LABEL_5;
      }
      v4 = 0;
      if (v6)
        v3 = v6;
    }
  }
  else
  {
    v3 = 0;
    v4 = 0;
  }
LABEL_5:
  *a2 = v3;
  return v4;
}

uint64_t protocol_conformsToProtocol_nolock(protocol_t *a1, const char **a2)
{
  uint64_t result;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t Protocol;

  result = 0;
  if (a1 && a2)
  {
    if (strcmp(*((const char **)a1 + 1), a2[1]))
    {
      v5 = (unint64_t *)*((_QWORD *)a1 + 2);
      if (!v5 || !*v5)
        return 0;
      v6 = 0;
      while (1)
      {
        v7 = v5[v6 + 1];
        v8 = canonical_protocol ? 0 : 0x20000000;
        if ((v8 & *(_DWORD *)(v7 + 68)) == 0)
        {
          Protocol = getProtocol(*(const char **)(v7 + 8));
          if (Protocol)
            v7 = Protocol;
        }
        if ((const char **)v7 == a2
          || !strcmp(a2[1], *(const char **)(v7 + 8))
          || protocol_conformsToProtocol_nolock((protocol_t *)v7, (protocol_t *)a2))
        {
          break;
        }
        ++v6;
        v5 = (unint64_t *)*((_QWORD *)a1 + 2);
        if (v6 >= *v5)
          return 0;
      }
    }
    return 1;
  }
  return result;
}

void objc_object::sidetable_clearDeallocating(objc_object *this)
{
  int *v2;
  unint64_t StatusReg;
  unsigned int v4;
  const char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t v13;

                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v4 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)v2))
  {
    if (!__stxr(v4, (unsigned int *)v2))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v13 = 0;
  {
    v8 = v13;
    v9 = *((_QWORD *)v2 + 1);
    v10 = v2[6];
  }
  else
  {
    v9 = *((_QWORD *)v2 + 1);
    v10 = v2[6];
    v8 = v9 + 16 * v10;
  }
  if (v9 + 16 * v10 != v8)
  {
    if ((*(_BYTE *)(v8 + 8) & 1) != 0)
      weak_clear_no_lock((_QWORD *)v2 + 4, this, v6, v7);
    *(_QWORD *)v8 = 2;
    *((int32x2_t *)v2 + 2) = vadd_s32(*(int32x2_t *)(v2 + 4), (int32x2_t)0x1FFFFFFFFLL);
  }
  v11 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v12 = __ldxr((unsigned int *)v2);
    if (v12 != v11)
      break;
    if (!__stlxr(0, (unsigned int *)v2))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)v2);
}

uint64_t objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::LookupBucketFor<DisguisedPtr<objc_object const>>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unsigned int v3;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  BOOL v16;
  unsigned int v17;

  v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    v5 = *(_QWORD **)a1;
    v6 = -a2;
    v7 = 0x8A970BE7488FDA55 * (-a2 ^ ((unint64_t)-a2 >> 4));
    v8 = v3 - 1;
    v9 = (v3 - 1) & (bswap64(v7) ^ v7);
    v10 = (_QWORD *)(*(_QWORD *)a1 + 16 * v9);
    if (a2 == *v10)
    {
      v11 = 1;
    }
    else
    {
      v13 = 0;
      v14 = -*v10;
      v15 = 1;
      while (v14 != -1)
      {
        if (v15 > v3)
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, v5, *(unsigned int *)(a1 + 16));
        if (v13)
          v16 = 0;
        else
          v16 = v14 == -2;
        if (v16)
          v13 = (unint64_t)v10;
        if (!(v10[1] | v13))
          v13 = (unint64_t)v10;
        v17 = v9 + v15++;
        v9 = v17 & v8;
        v10 = &v5[2 * (v17 & v8)];
        v14 = -*v10;
        v11 = 1;
        if (!(v6 + *v10))
          goto LABEL_5;
      }
      v11 = 0;
      if (v13)
        v10 = (_QWORD *)v13;
    }
  }
  else
  {
    v10 = 0;
    v11 = 0;
  }
LABEL_5:
  *a3 = v10;
  return v11;
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  char *v1;
  char *v2;
  uint64_t v3;
  unint64_t StatusReg;
  uint64_t *v6;
  _DWORD *v7;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = *(uint64_t **)(StatusReg + 352);
  if (v6 != (uint64_t *)-1)
  {
    v7 = *(_DWORD **)(StatusReg + 360);
    if ((unint64_t)v6 > 3 || v7 != 0)
    {
      *(_QWORD *)(StatusReg + 352) = 0;
      *(_QWORD *)(StatusReg + 360) = 0;
      if (v3 - (_QWORD)v7 == 8 || *v7 == -1440939011)
      {
        if ((v6 & 1) != 0)
          objc_releaseAndReturn((objc_object *)a1);
      }
      else if ((v6 & 1) != 0)
      {
        moveTLSAutoreleaseToPool(v6, (uint64_t)v7, v1, v2);
      }
    }
  }
  return a1;
}

void (*object_cxxDestructFromClass(void (*result)(void), objc_class *a2))(void)
{
  objc_class *v2;
  void (*v3)(void);
  void (*v4)(void);
  char *v5;

  if (a2)
  {
    v2 = a2;
    v3 = result;
    do
    {
      if ((*((_WORD *)v2 + 15) & 1) == 0)
        break;
      result = (void (*)(void))lookupMethodInClassAndLoadCache((uint64_t)v2, (objc_selector *)SEL_cxx_destruct);
      if (result != _objc_msgForward_impcache)
      {
        v4 = result;
        if (PrintCxxCtors)
        {
          v5 = objc_class::nameForLogging(v2);
          _objc_inform("CXX: calling C++ destructors for class %s", v5);
        }
        result = (void (*)(void))((uint64_t (*)(void (*)(void)))v4)(v3);
      }
      v2 = (objc_class *)*((_QWORD *)v2 + 1);
    }
    while (v2);
  }
  return result;
}

unint64_t lookupMethodInClassAndLoadCache(uint64_t a1, objc_selector *a2)
{
  char *v4;
  unint64_t Imp;
  const char *v7;
  unint64_t StatusReg;
  unsigned int v9;
  unint64_t MethodNoSuper_nolock;
  int v12;
  unsigned int v13;

  Imp = cache_getImp(a1, (unint64_t)a2, (uint64_t)_objc_msgForward_impcache);
  if (!Imp)
  {
    v7 = (const char *)a1;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v9 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr((unsigned int *)&runtimeLock))
    {
      if (!__stxr(v9, (unsigned int *)&runtimeLock))
        goto LABEL_8;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_8:
    MethodNoSuper_nolock = getMethodNoSuper_nolock((objc_class *)a1, a2, v7, v4);
    if (MethodNoSuper_nolock)
      Imp = method_t::imp(MethodNoSuper_nolock, 0);
    else
      Imp = (unint64_t)_objc_msgForward_impcache;
    if ((*(_QWORD *)(a1 + 16) & 1) == 0)
      cache_t::insert((cache_t *)(a1 + 16), a2, Imp, 0);
    v12 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v13 = __ldxr((unsigned int *)&runtimeLock);
      if (v13 != v12)
        break;
      if (!__stlxr(0, (unsigned int *)&runtimeLock))
        return Imp;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
  }
  return Imp;
}

void sub_180100C60(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void (*lookUpImpOrForward(objc_object *a1, objc_selector *a2, objc_class *a3, unsigned int a4))(void)
{
  int v7;
  unsigned int v8;
  unint64_t StatusReg;
  unsigned int v10;
  uint64_t v12;
  BOOL v13;
  __objc2_class *v14;
  const char *v15;
  char *v16;
  __objc2_class *v17;
  int v18;
  int v19;
  void (*v20)(void);
  int v21;
  objc_class *v22;
  unint64_t MethodNoSuper_nolock;
  uint64_t v24;
  const char *v25;
  char *v26;
  uint64_t Imp;
  void (*v29)(void);
  int v30;
  unsigned int v31;
  uint64_t v33;
  unsigned int *v34;
  uint64_t v35;
  const char *v36;
  char *v37;
  void (*v38)(__objc2_class *, objc_object *, objc_selector *, void (*)(void));

  v7 = *(_DWORD *)(*((_QWORD *)a3 + 4) & 0xF00007FFFFFFFF8);
  if ((v7 & 1) == 0)
    v7 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)a3 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v7 & 0x20000000) != 0)
    v8 = a4;
  else
    v8 = a4 | 8;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v10 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&runtimeLock))
  {
    if (!__stxr(v10, (unsigned int *)&runtimeLock))
      goto LABEL_11;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_11:
  if ((unint64_t)(*(_QWORD *)a3 - 1) < 0xF
    || (*(_DWORD *)(*((_QWORD *)a3 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (v12 = *(unsigned __int16 *)((*((_QWORD *)a3 + 4) & 0xF00007FFFFFFFF8) + 4),
        dword_1ECCE5988 <= v12)
    || (*(_QWORD *)(qword_1ECCE5980 + 16 * v12) <= (unint64_t)a3
      ? (v13 = *(_QWORD *)(qword_1ECCE5980 + 16 * v12 + 8) > (unint64_t)a3)
      : (v13 = 0),
        !v13))
  {
    if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)a3)
      && (dataSegmentsContain(a3, v33, v34) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v35, v36, v37, a3);
    }
  }
  v14 = realizeAndInitializeIfNeeded_locked(a1, a3, v8 & 1);
  v17 = v14;
  if (!v14 || ((uint64_t)v14->isa & 0xFFFFFFFF8) == 0)
  {
    v20 = (void (*)(void))_objc_returnNil;
    goto LABEL_35;
  }
  v18 = *(_DWORD *)(gdb_objc_realized_classes + 8);
  if (DisablePreopt)
    v19 = 0;
  else
    v19 = _dyld_objc_class_count();
  v21 = 16 * ~(v19 + v18);
  v22 = (objc_class *)v17;
  while ((*((_QWORD *)v22 + 2) & 1) != 0)
  {
    Imp = cache_getImp((uint64_t)v22, (unint64_t)a2, 0);
    if (Imp)
    {
      v20 = (void (*)(void))Imp;
      goto LABEL_42;
    }
    v22 = (objc_class *)((char *)v22 + *(_QWORD *)((*((_QWORD *)v22 + 2) & 0xFFFFFFFFFFFELL) - 16));
LABEL_32:
    if (__CFADD__(v21++, 1))
      _objc_fatal("Memory corruption in class list.", v24, v25, v26);
    v29 = (void (*)(void))cache_getImp((uint64_t)v22, (unint64_t)a2, 0);
    if (v29 == _objc_msgForward_impcache)
      goto LABEL_52;
    v20 = v29;
    if (v29)
      goto LABEL_35;
  }
  MethodNoSuper_nolock = getMethodNoSuper_nolock(v22, a2, v15, v16);
  if (MethodNoSuper_nolock)
  {
    v20 = (void (*)(void))method_t::imp(MethodNoSuper_nolock, 0);
    goto LABEL_35;
  }
  v22 = (objc_class *)*((_QWORD *)v22 + 1);
  if (v22)
    goto LABEL_32;
LABEL_52:
  if ((v8 & 2) != 0)
    return resolveMethod_locked(a1, a2, (objc_class *)v17, v8 ^ 2);
  v20 = _objc_msgForward_impcache;
LABEL_35:
  if ((v8 & 8) == 0)
  {
    while (((uint64_t)v17->cache & 1) != 0)
      v17 = (__objc2_class *)((char *)v17 + *(_QWORD *)(((uint64_t)v17->cache & 0xFFFFFFFFFFFELL) - 16));
    if (msgSendCacheMissHook)
    {
      v38 = (void (*)(__objc2_class *, objc_object *, objc_selector *, void (*)(void)))atomic_load((unint64_t *)&msgSendCacheMissHook);
      v38(v17, a1, a2, v20);
    }
    cache_t::insert((cache_t *)&v17->cache, a2, (unint64_t)v20, a1);
  }
LABEL_42:
  v30 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v31 = __ldxr((unsigned int *)&runtimeLock);
    if (v31 != v30)
      break;
    if (!__stlxr(0, (unsigned int *)&runtimeLock))
      goto LABEL_47;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
LABEL_47:
  if (((v20 == _objc_msgForward_impcache) & (v8 >> 2)) != 0)
    return 0;
  else
    return v20;
}

unint64_t getMethodNoSuper_nolock(objc_class *a1, objc_selector *a2, const char *a3, char *a4)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unint64_t v8;
  unint64_t result;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  unsigned int *v13;
  unint64_t v14;
  uint64_t v16;
  _DWORD *v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int *v21;
  unint64_t v22;
  const char *v23;
  int v24;
  unint64_t v25;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  objc_selector *v31;
  BOOL v32;
  _BOOL4 v33;
  unint64_t v34;
  unsigned int v35;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  objc_selector *v41;
  BOOL v42;
  _BOOL4 v43;
  unint64_t v44;
  unsigned int v45;
  uint64_t v46;
  int v47;
  objc_selector *v48;
  BOOL v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  BOOL v54;
  _BOOL4 v55;
  const char *v56;
  unsigned int v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  objc_selector *v63;
  BOOL v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  unint64_t v68;
  BOOL v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  unint64_t v73;
  unsigned int *v74;
  unint64_t v75;
  unint64_t v77;
  unsigned int *v78;
  unint64_t v79;
  unint64_t v80;
  unsigned int *v81;
  unint64_t v82;

  v4 = *(_QWORD *)((*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) + 8);
  v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
  if ((v4 & 1) == 0)
  {
    v6 = *(_QWORD *)(v5 + 32);
    v7 = (unsigned int *)(v6 & 0xFFFFFFFFFFFFFFFELL);
    if ((v6 & 1) != 0)
      v8 = 0;
    else
      v8 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((v6 & 1) != 0 && v7)
      return getMethodFromRelativeList(v7, a2, a3, a4);
    if (v8)
    {
      v13 = (unsigned int *)v8;
      return getMethodFromListArray<method_list_t **>(v13, a2, a3, a4);
    }
    return 0;
  }
  v10 = *(_QWORD *)(v5 + 8);
  v11 = (unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
  v12 = v10 & 3;
  if ((v10 & 3) != 0)
    v13 = 0;
  else
    v13 = (unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
  if (v12 == 2)
    v14 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  else
    v14 = 0;
  if (v12 != 1 || v11 == 0)
  {
    if (v13)
      return getMethodFromListArray<method_list_t **>(v13, a2, a3, a4);
    if (v14)
    {
      v7 = (unsigned int *)v14;
      return getMethodFromRelativeList(v7, a2, a3, a4);
    }
    return 0;
  }
  if (v13)
    return getMethodFromListArray<method_list_t **>(v13, a2, a3, a4);
  v18 = *v11;
  v17 = v11 + 2;
  v16 = v18;
  if (!v18)
    return 0;
  v19 = 0;
  v20 = a2 - (objc_selector *)&unk_1F25805A8;
  while (1)
  {
    v21 = *(unsigned int **)&v17[2 * v19];
    v22 = *v21;
    v23 = (const char *)((unsigned __int16)v22 & 0xFFFC);
    v24 = (v22 & 0x80000000) == 0 ? 24 : 12;
    v25 = v22 >> 31;
    if ((~(_DWORD)v22 & 3) == 0 && (_DWORD)v23 == v24)
      break;
    if ((v22 & 0x80000000) == 0)
    {
      v72 = (char *)v21[1];
      v73 = v72 * (unint64_t)v23;
      if ((v73 & 0xFFFFFFFF00000000) == 0)
      {
        v74 = v21 + 2;
        result = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
        v75 = ((unint64_t)v74 + v73) & 0xFFFFFFFFFFFFFFFCLL | v25;
        if (result == v75)
          goto LABEL_111;
        while (*(objc_selector **)(result & 0xFFFFFFFFFFFFFFFCLL) != a2)
        {
          result += v23;
          if (result == v75)
            goto LABEL_111;
        }
        goto LABEL_110;
      }
      goto LABEL_138;
    }
    if (dataSegmentsRanges > (unint64_t)v21 || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v21)
    {
      v72 = (char *)v21[1];
      v77 = v72 * (unint64_t)v23;
      if ((v77 & 0xFFFFFFFF00000000) == 0)
      {
        v78 = v21 + 2;
        result = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
        v79 = ((unint64_t)v78 + v77) & 0xFFFFFFFFFFFFFFFCLL | v25;
        if (result == v79)
          goto LABEL_111;
        while (*(objc_selector **)((result & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL)) != a2)
        {
          result += v23;
          if (result == v79)
            goto LABEL_111;
        }
        goto LABEL_110;
      }
      goto LABEL_138;
    }
    if (dataSegmentsRanges <= (unint64_t)a2 && *(_QWORD *)algn_1ECCE5978 > (unint64_t)a2)
    {
      v72 = (char *)v21[1];
      v80 = v72 * (unint64_t)v23;
      if ((v80 & 0xFFFFFFFF00000000) == 0)
      {
        v81 = v21 + 2;
        result = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
        v82 = ((unint64_t)v81 + v80) & 0xFFFFFFFFFFFFFFFCLL | v25;
        if (result == v82)
          goto LABEL_111;
        while ((objc_selector *)((char *)&unk_1F25805A8 + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL)) != a2)
        {
          result += v23;
          if (result == v82)
            goto LABEL_111;
        }
        goto LABEL_110;
      }
LABEL_138:
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, v23, v72, v25, v72, *(_QWORD *)&v17[2 * v19], v23);
    }
LABEL_111:
    if (++v19 == v16)
      return 0;
  }
  if ((v22 & 0x80000000) != 0)
  {
    if (dataSegmentsRanges > (unint64_t)v21 || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v21)
    {
      v37 = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
      v38 = v21[1];
      if (v38 < 5)
      {
        v40 = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
        if (!(_DWORD)v38)
          goto LABEL_111;
LABEL_82:
        v61 = 0;
        v62 = v38 - 1;
        while (1)
        {
          result = v40 + v61;
          v63 = *(objc_selector **)(((v40 + v61) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v40 + v61) & 0xFFFFFFFFFFFFFFFCLL));
          if (v63 == a2)
            break;
          v64 = v63 > a2 || v62-- == 0;
          v61 += v23;
          if (v64)
            goto LABEL_111;
        }
      }
      else
      {
        v39 = (unsigned __int16)v22 & 0xFFFC;
        v40 = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
        while (1)
        {
          result = v40 + ((unsigned __int16)v22 & 0xFFFC) * (unint64_t)(v38 >> 1);
          v41 = *(objc_selector **)((result & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL));
          v42 = v41 >= a2;
          if (v41 == a2)
            break;
          v43 = v41 < a2;
          v44 = result + ((unsigned __int16)v22 & 0xFFFC);
          if (!v42)
            v40 = v44;
          v45 = v38 - v43;
          v38 = (v38 - v43) >> 1;
          if (v45 <= 9)
          {
            if (!(_DWORD)v38)
              goto LABEL_111;
            goto LABEL_82;
          }
        }
        if (result <= v37)
          goto LABEL_110;
        v58 = 0;
        v65 = v40 + ((unsigned __int16)v22 >> 2) * (((2 * v38) & 0x1FFFFFFFCLL) - 4);
        while (*(objc_selector **)(((v65 + v58) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v65 + v58) & 0xFFFFFFFFFFFFFFFCLL)) == a2)
        {
          v58 -= v39;
          v60 = result + v58;
          if (result + v58 <= v37)
            goto LABEL_109;
        }
LABEL_95:
        result += v58;
      }
      goto LABEL_110;
    }
    if (dataSegmentsRanges <= (unint64_t)a2 && *(_QWORD *)algn_1ECCE5978 > (unint64_t)a2)
    {
      v50 = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
      v51 = v21[1];
      if (v51 < 5)
      {
        v52 = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
        if (!(_DWORD)v51)
          goto LABEL_111;
      }
      else
      {
        v52 = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
        do
        {
          result = v52 + ((unsigned __int16)v22 & 0xFFFC) * (unint64_t)(v51 >> 1);
          v53 = *(int *)(result & 0xFFFFFFFFFFFFFFFCLL);
          v54 = v20 > v53;
          if (v20 == v53)
          {
            if (result > v50)
            {
              v70 = 0;
              v71 = v52 + ((unsigned __int16)v22 >> 2) * (((2 * v51) & 0x1FFFFFFFCLL) - 4);
              while (v20 == *(_DWORD *)((v71 + v70) & 0xFFFFFFFFFFFFFFFCLL))
              {
                v70 -= (uint64_t)v23;
                v60 = result + v70;
                if (result + v70 <= v50)
                {
LABEL_109:
                  result = v60;
                  goto LABEL_110;
                }
              }
              result += v70;
            }
            goto LABEL_110;
          }
          v55 = v20 > v53;
          v56 = &v23[result];
          if (v54)
            v52 = (unint64_t)v56;
          v57 = v51 - v55;
          v51 = (v51 - v55) >> 1;
        }
        while (v57 > 9);
        if (!(_DWORD)v51)
          goto LABEL_111;
      }
      v66 = 0;
      v67 = v51 - 1;
      while (1)
      {
        result = v52 + v66;
        v68 = *(int *)((v52 + v66) & 0xFFFFFFFFFFFFFFFCLL);
        if (v20 == v68)
          goto LABEL_110;
        v69 = v20 < v68 || v67-- == 0;
        v66 += v23;
        if (v69)
          goto LABEL_111;
      }
    }
    goto LABEL_111;
  }
  v27 = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
  v28 = v21[1];
  if (v28 >= 5)
  {
    v29 = (unsigned __int16)v22 & 0xFFFC;
    v30 = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
    while (1)
    {
      result = v30 + ((unsigned __int16)v22 & 0xFFFC) * (unint64_t)(v28 >> 1);
      v31 = *(objc_selector **)(result & 0xFFFFFFFFFFFFFFFCLL);
      v32 = v31 >= a2;
      if (v31 == a2)
        break;
      v33 = v31 < a2;
      v34 = result + ((unsigned __int16)v22 & 0xFFFC);
      if (!v32)
        v30 = v34;
      v35 = v28 - v33;
      v28 = (v28 - v33) >> 1;
      if (v35 <= 9)
      {
        if (!(_DWORD)v28)
          goto LABEL_111;
        goto LABEL_58;
      }
    }
    if (result <= v27)
      goto LABEL_110;
    v58 = 0;
    v59 = v30 + ((unsigned __int16)v22 >> 2) * (((2 * v28) & 0x1FFFFFFFCLL) - 4);
    while (*(objc_selector **)((v59 + v58) & 0xFFFFFFFFFFFFFFFCLL) == a2)
    {
      v58 -= v29;
      v60 = result + v58;
      if (result + v58 <= v27)
        goto LABEL_109;
    }
    goto LABEL_95;
  }
  v30 = (unint64_t)(v21 + 2) & 0xFFFFFFFFFFFFFFFCLL | v25;
  if (!(_DWORD)v28)
    goto LABEL_111;
LABEL_58:
  v46 = 0;
  v47 = v28 - 1;
  while (1)
  {
    result = v30 + v46;
    v48 = *(objc_selector **)((v30 + v46) & 0xFFFFFFFFFFFFFFFCLL);
    if (v48 == a2)
      break;
    v49 = v48 > a2 || v47-- == 0;
    v46 += v23;
    if (v49)
      goto LABEL_111;
  }
LABEL_110:
  if (!result)
    goto LABEL_111;
  return result;
}

BOOL class_respondsToSelector_inst(objc_object *a1, objc_selector *a2, objc_class *a3)
{
  _BOOL8 result;
  int v7;
  void (*Imp)(void);

  result = 0;
  if (a2 && a3)
  {
    v7 = *(_DWORD *)(*((_QWORD *)a3 + 4) & 0xF00007FFFFFFFF8);
    if ((v7 & 1) == 0)
      v7 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)a3 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    if ((v7 & 0x20000000) != 0
      && ((Imp = (void (*)(void))cache_getImp((uint64_t)a3, (unint64_t)a2, 0)) != 0
       || (*((_QWORD *)a3 + 2) & 1) != 0
       && (Imp = (void (*)(void))cache_getImp((uint64_t)a3 + *(_QWORD *)((*((_QWORD *)a3 + 2) & 0xFFFFFFFFFFFELL) - 16), (unint64_t)a2, 0)) != 0))
    {
      if (Imp == _objc_msgForward_impcache)
        Imp = 0;
    }
    else
    {
      Imp = lookUpImpOrForward(a1, a2, a3, 6u);
    }
    return Imp != 0;
  }
  return result;
}

unint64_t object_getMethodImplementation(unint64_t result, objc_selector *a2)
{
  __objc2_class *v3;
  int v4;

  if (result)
  {
    if ((result & 0x8000000000000000) != 0)
    {
      v3 = (__objc2_class *)objc_debug_taggedpointer_classes[result & 7];
      if (v3 == __NSUnrecognizedTaggedPointer)
        v3 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[(result >> 55)];
    }
    else
    {
      v3 = (__objc2_class *)(*(_QWORD *)result & 0xFFFFFFFF8);
    }
    result = 0;
    if (a2 && v3)
    {
      v4 = *(_DWORD *)((uint64_t)v3->info & 0xF00007FFFFFFFF8);
      if ((v4 & 1) == 0)
        v4 = *(_DWORD *)(*(_QWORD *)(((uint64_t)v3->isa & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
      if ((v4 & 0x20000000) != 0
        && ((result = cache_getImp((uint64_t)v3, (unint64_t)a2, 0)) != 0
         || ((uint64_t)v3->cache & 1) != 0
         && (result = cache_getImp((uint64_t)v3 + *(_QWORD *)(((uint64_t)v3->cache & 0xFFFFFFFFFFFELL) - 16), (unint64_t)a2, 0)) != 0))
      {
        if ((void (*)(void))result == _objc_msgForward_impcache)
          result = 0;
      }
      else
      {
        result = (unint64_t)lookUpImpOrForward(0, a2, (objc_class *)v3, 7u);
      }
      if (!result)
        return (unint64_t)_objc_msgForward;
    }
  }
  return result;
}

void cache_t::insert(cache_t *this, objc_selector *a2, unint64_t a3, objc_object *a4)
{
  unint64_t v8;
  int v9;
  BOOL v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  const char *v24;
  char *v25;

  v8 = (unint64_t)this - 16;
  v9 = *(_DWORD *)(*((_QWORD *)this + 2) & 0xF00007FFFFFFFF8);
  if ((v9 & 1) == 0)
    v9 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)v8 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v9 & 0x20000000) != 0)
  {
    if ((*(_QWORD *)this & 1) != 0
      || (*(objc_cache **)this != &_objc_empty_cache ? (v10 = HIWORD(*(_QWORD *)this) == 0) : (v10 = 0), v10))
    {
      v22 = objc_class::nameForLogging((cache_t *)((char *)this - 16));
      _objc_fatal("cache_t::insert() called with a preoptimized cache for %s", v23, v24, v25, v22);
    }
    v11 = *((unsigned __int16 *)this + 6);
    if (HIWORD(*(_QWORD *)this))
      LODWORD(v12) = HIWORD(*(_QWORD *)this) + 1;
    else
      LODWORD(v12) = 0;
    if (cache_t::isConstantEmptyCache(this))
    {
      if ((_DWORD)v12)
        v12 = v12;
      else
        v12 = 2;
      atomic_store(cache_t::allocateBuckets((cache_t *)v12) | ((unint64_t)(v12 - 1) << 48), (unint64_t *)this);
      *((_WORD *)this + 6) = 0;
    }
    else if (v11 >= (7 * v12) >> 3 && (v12 > 8 || v12 <= v11))
    {
      v19 = 2 * v12;
      if ((2 * v12) >= 0x10000)
        v19 = 0x10000;
      if ((_DWORD)v12)
        v20 = v19;
      else
        v20 = 2;
      v21 = *(_QWORD *)this & 0xFFFFFFFFFFFLL;
      atomic_store(cache_t::allocateBuckets((cache_t *)v20) | ((unint64_t)(v20 - 1) << 48), (unint64_t *)this);
      *((_WORD *)this + 6) = 0;
      cache_t::collect_free(v21, v12);
      LODWORD(v12) = v20;
    }
    v13 = *(_QWORD *)this & 0xFFFFFFFFFFFLL;
    v14 = (v12 - 1) & (((unint64_t)a2 >> 7) ^ a2);
    while (1)
    {
      v15 = v14;
      v16 = v13 + 16 * v14;
      if (!*(_QWORD *)(v16 + 8))
        break;
      if (*(objc_selector **)(v16 + 8) == a2)
        return;
      v14 = v15 - 1;
      if (!(_DWORD)v15)
        v14 = v12 - 1;
      if (v14 == (((_DWORD)v12 - 1) & (((unint64_t)a2 >> 7) ^ a2)))
        cache_t::bad_cache(this, a4, a2);
    }
    v17 = (unint64_t *)(v13 + 16 * v15);
    ++*((_WORD *)this + 6);
    v18 = v8 ^ a3;
    if (!a3)
      v18 = 0;
    *v17 = v18;
    v17[1] = (unint64_t)a2;
  }
}

BOOL cache_t::isConstantEmptyCache(cache_t *this)
{
  unint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;

  if (*((_WORD *)this + 6))
    return 0;
  v2 = (unint64_t)&_objc_empty_cache & 0xFFFFFFFFFFFLL;
  if (HIWORD(*(_QWORD *)this))
  {
    v3 = HIWORD(*(_QWORD *)this);
    if (v3 >= 0x401)
    {
      v4 = 0;
      v5 = v3 + 1;
      do
      {
        ++v4;
        v6 = v5 > 3;
        v5 >>= 1;
      }
      while (v6);
      if (v4 >= cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount)
        v2 = 0;
      else
        v2 = *(_QWORD *)(cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsList + 8 * v4);
    }
  }
  return v2 == (*(_QWORD *)this & 0xFFFFFFFFFFFLL);
}

unint64_t getMethodFromListArray<method_list_t **>(unsigned int *a1, _BYTE *a2, const char *a3, char *a4)
{
  unint64_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t result;
  _BYTE *v15;
  BOOL v16;
  _BOOL4 v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  BOOL v24;
  _BOOL4 v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  _BYTE *v29;
  BOOL v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  _BYTE *v35;
  BOOL v36;
  _BOOL4 v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  _BYTE *v44;
  BOOL v45;
  unint64_t v46;
  uint64_t v47;
  int v48;
  unint64_t v49;
  BOOL v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unsigned int *v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;

  v5 = *a1;
  v6 = (unsigned __int16)v5 & 0xFFFC;
  if ((v5 & 0x80000000) == 0)
    v7 = 24;
  else
    v7 = 12;
  v8 = v5 >> 31;
  if ((~(_DWORD)v5 & 3) == 0 && (_DWORD)v6 == v7)
  {
    if ((v5 & 0x80000000) != 0)
    {
      if (dataSegmentsRanges <= (unint64_t)a1 && *(_QWORD *)algn_1ECCE5978 > (unint64_t)a1)
      {
        result = 0;
        if (dataSegmentsRanges > (unint64_t)a2 || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)a2)
          return result;
        v19 = a2 - (_BYTE *)&unk_1F25805A8;
        v20 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v8;
        v21 = a1[1];
        if (v21 < 5)
        {
          v22 = v20;
LABEL_67:
          if (!(_DWORD)v21)
            return 0;
          v47 = 0;
          v48 = v21 - 1;
          do
          {
            result = v22 + v47;
            v49 = *(int *)((v22 + v47) & 0xFFFFFFFFFFFFFFFCLL);
            if (v19 == v49)
              break;
            result = 0;
            v50 = v19 < v49 || v48-- == 0;
            v47 += v6;
          }
          while (!v50);
        }
        else
        {
          v22 = v20;
          while (1)
          {
            result = v22 + ((unsigned __int16)v5 & 0xFFFC) * (unint64_t)(v21 >> 1);
            v23 = *(int *)(result & 0xFFFFFFFFFFFFFFFCLL);
            v24 = v19 > v23;
            if (v19 == v23)
              break;
            v25 = v19 > v23;
            if (v24)
              v22 = result + v6;
            v26 = v21 - v25;
            v21 = v26 >> 1;
            if (v26 <= 9)
              goto LABEL_67;
          }
          if (result > v20)
          {
            v51 = 0;
            v52 = v22 + ((unsigned __int16)v5 >> 2) * (((2 * v21) & 0x1FFFFFFFCLL) - 4);
            while (v19 == *(_DWORD *)((v52 + v51) & 0xFFFFFFFFFFFFFFFCLL))
            {
              v51 -= v6;
              v41 = result + v51;
              if (result + v51 <= v20)
                return v41;
            }
            result += v51;
          }
        }
        return result;
      }
      v31 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v8;
      v32 = a1[1];
      if (v32 < 5)
      {
        v34 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v8;
        if (!(_DWORD)v32)
          return 0;
LABEL_52:
        v42 = 0;
        v43 = v32 - 1;
        while (1)
        {
          result = v34 + v42;
          v44 = *(_BYTE **)(((v34 + v42) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v34 + v42) & 0xFFFFFFFFFFFFFFFCLL));
          if (v44 == a2)
            break;
          v45 = v44 > a2 || v43-- == 0;
          v42 += v6;
          if (v45)
            return 0;
        }
        return result;
      }
      v33 = (unsigned __int16)v5 & 0xFFFC;
      v34 = v31;
      while (1)
      {
        result = v34 + ((unsigned __int16)v5 & 0xFFFC) * (unint64_t)(v32 >> 1);
        v35 = *(_BYTE **)((result & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL));
        v36 = v35 >= a2;
        if (v35 == a2)
          break;
        v37 = v35 < a2;
        if (!v36)
          v34 = result + ((unsigned __int16)v5 & 0xFFFC);
        v38 = v32 - v37;
        v32 = v38 >> 1;
        if (v38 <= 9)
        {
          if ((_DWORD)v32)
            goto LABEL_52;
          return 0;
        }
      }
      if (result <= v31)
        return result;
      v39 = 0;
      v46 = v34 + ((unsigned __int16)v5 >> 2) * (((2 * v32) & 0x1FFFFFFFCLL) - 4);
      while (*(_BYTE **)(((v46 + v39) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v46 + v39) & 0xFFFFFFFFFFFFFFFCLL)) == a2)
      {
        v39 -= v33;
        v41 = result + v39;
        if (result + v39 <= v31)
          return v41;
      }
    }
    else
    {
      v10 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v8;
      v11 = a1[1];
      if (v11 < 5)
      {
        v13 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v8;
        if (!(_DWORD)v11)
          return 0;
LABEL_30:
        v27 = 0;
        v28 = v11 - 1;
        while (1)
        {
          result = v13 + v27;
          v29 = *(_BYTE **)((v13 + v27) & 0xFFFFFFFFFFFFFFFCLL);
          if (v29 == a2)
            break;
          v30 = v29 > a2 || v28-- == 0;
          v27 += v6;
          if (v30)
            return 0;
        }
        return result;
      }
      v12 = (unsigned __int16)v5 & 0xFFFC;
      v13 = v10;
      while (1)
      {
        result = v13 + ((unsigned __int16)v5 & 0xFFFC) * (unint64_t)(v11 >> 1);
        v15 = *(_BYTE **)(result & 0xFFFFFFFFFFFFFFFCLL);
        v16 = v15 >= a2;
        if (v15 == a2)
          break;
        v17 = v15 < a2;
        if (!v16)
          v13 = result + ((unsigned __int16)v5 & 0xFFFC);
        v18 = v11 - v17;
        v11 = v18 >> 1;
        if (v18 <= 9)
        {
          if ((_DWORD)v11)
            goto LABEL_30;
          return 0;
        }
      }
      if (result <= v10)
        return result;
      v39 = 0;
      v40 = v13 + ((unsigned __int16)v5 >> 2) * (((2 * v11) & 0x1FFFFFFFCLL) - 4);
      while (*(_BYTE **)((v40 + v39) & 0xFFFFFFFFFFFFFFFCLL) == a2)
      {
        v39 -= v12;
        v41 = result + v39;
        if (result + v39 <= v10)
          return v41;
      }
    }
    result += v39;
    return result;
  }
  if ((v5 & 0x80000000) == 0)
  {
    v53 = a1[1];
    v54 = v53 * (unint64_t)v6;
    if ((v54 & 0xFFFFFFFF00000000) == 0)
    {
      v55 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v8;
      v56 = ((unint64_t)a1 + v54 + 8) & 0xFFFFFFFFFFFFFFFCLL | v8;
      if (v55 != v56)
      {
        v57 = 0;
        do
        {
          result = v55 + v57;
          if (*(_BYTE **)((v55 + v57) & 0xFFFFFFFFFFFFFFFCLL) == a2)
            break;
          result = 0;
          v57 += v6;
        }
        while (v55 + v57 != v56);
        return result;
      }
      return 0;
    }
LABEL_107:
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v53, a1, v6);
  }
  if (dataSegmentsRanges > (unint64_t)a1 || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)a1)
  {
    v53 = a1[1];
    v63 = v53 * (unint64_t)v6;
    if ((v63 & 0xFFFFFFFF00000000) != 0)
      goto LABEL_107;
    v64 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v8;
    v65 = ((unint64_t)a1 + v63 + 8) & 0xFFFFFFFFFFFFFFFCLL | v8;
    if (v64 == v65)
      return 0;
    v66 = 0;
    do
    {
      result = v64 + v66;
      if (*(_BYTE **)(((v64 + v66) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v64 + v66) & 0xFFFFFFFFFFFFFFFCLL)) == a2)
        break;
      result = 0;
      v66 += v6;
    }
    while (v64 + v66 != v65);
  }
  else
  {
    result = 0;
    if (dataSegmentsRanges > (unint64_t)a2 || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)a2)
      return result;
    v53 = a1[1];
    v58 = v53 * (unint64_t)v6;
    if ((v58 & 0xFFFFFFFF00000000) != 0)
      goto LABEL_107;
    v59 = a1 + 2;
    v60 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v8;
    v61 = ((unint64_t)v59 + v58) & 0xFFFFFFFFFFFFFFFCLL | v8;
    if (v60 == v61)
      return 0;
    v62 = 0;
    do
    {
      result = v60 + v62;
      if ((char *)&unk_1F25805A8 + *(int *)((v60 + v62) & 0xFFFFFFFFFFFFFFFCLL) == a2)
        break;
      result = 0;
      v62 += v6;
    }
    while (v60 + v62 != v61);
  }
  return result;
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  id *v5;
  os_unfair_lock_s *v6;
  unint64_t StatusReg;
  unsigned int v8;
  id result;
  id v11;
  int v12;
  unsigned int v13;

  if (offset)
  {
    v5 = (id *)((char *)self + offset);
    if (atomic)
    {
      v6 = (os_unfair_lock_s *)&PropertyLocks[16
                                            * (unint64_t)(((v5 >> 4) ^ (v5 >> 9)) & 7)];
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v8 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr(&v6->_os_unfair_lock_opaque))
      {
        if (!__stxr(v8, &v6->_os_unfair_lock_opaque))
          goto LABEL_12;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_12:
      v11 = *v5;
      v12 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v13 = __ldxr(&v6->_os_unfair_lock_opaque);
        if (v13 != v12)
          break;
        if (!__stlxr(0, &v6->_os_unfair_lock_opaque))
          return v11;
      }
      __clrex();
      os_unfair_lock_unlock(v6);
      return v11;
    }
    else
    {
      return *v5;
    }
  }
  else if (self)
  {
    if (((unint64_t)self & 0x8000000000000000) != 0)
    {
      result = (id)objc_debug_taggedpointer_classes[self & 7];
      if (result == __NSUnrecognizedTaggedPointer)
        return (id)objc_debug_taggedpointer_ext_classes[((unint64_t)self >> 55)];
    }
    else
    {
      return (id)(*(_QWORD *)self & 0xFFFFFFFF8);
    }
  }
  else
  {
    return 0;
  }
  return result;
}

id objc_retainAutorelease(id a1)
{
  return a1;
}

void objc_storeStrong(id *location, id obj)
{
  id v2;
  id v5;

  v2 = *location;
  if (*location != obj)
  {
    v5 = obj;
    *location = obj;

  }
}

unint64_t getMethodFromRelativeList(unsigned int *a1, _BYTE *a2, const char *a3, char *a4)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int v10;
  unint64_t v11;
  unsigned int *v12;
  unint64_t v13;
  char *v14;
  int v15;
  unint64_t v16;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t result;
  _BYTE *v24;
  BOOL v25;
  _BOOL4 v26;
  unint64_t v27;
  unsigned int v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v32;
  unint64_t v33;
  _BYTE *v34;
  BOOL v35;
  _BOOL4 v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  _BYTE *v41;
  BOOL v42;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  _BOOL4 v46;
  char *v47;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  int v52;
  _BYTE *v53;
  BOOL v54;
  uint64_t v55;
  int v56;
  unint64_t v57;
  BOOL v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unsigned int *v68;
  unint64_t v69;
  unsigned int v70;
  uint64_t v71;
  unint64_t v72;
  unsigned int *v74;
  unint64_t v75;
  unsigned int *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;

  if (dataSegmentsRanges <= (unint64_t)a2 && *(_QWORD *)algn_1ECCE5978 > (unint64_t)a2)
  {
    if (DisablePreattachedCategories)
    {
      v7 = *a1;
      v78 = a1[1];
      v79 = v78 * (unint64_t)v7;
      if ((v79 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v78, a1, v7);
      v80 = (uint64_t)a1 + v79 + 8;
      if ((_DWORD)v78)
        v6 = v78;
      else
        v6 = 0;
      if ((_DWORD)v78)
        v5 = (uint64_t *)(v80 - v7);
      else
        v5 = (uint64_t *)v80;
    }
    else
    {
      v5 = (uint64_t *)(a1 + 2);
      v7 = *a1;
      v6 = a1[1];
    }
    v8 = v6 * (unint64_t)v7;
    if ((v8 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v6, a1, v7);
    v9 = (unint64_t)a1 + v8 + 8;
    if ((unint64_t)v5 < v9)
    {
      while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v5 + 8) & 1) == 0)
      {
        v5 = (uint64_t *)((char *)v5 + v7);
        v10 = v7;
        if ((unint64_t)v5 >= v9)
          goto LABEL_14;
      }
    }
    v10 = v7;
LABEL_14:
    if (v5 != (uint64_t *)v9)
    {
      v11 = a2 - (_BYTE *)&unk_1F25805A8;
      do
      {
        v12 = (unsigned int *)((char *)v5 + (*v5 >> 16));
        v13 = *v12;
        v14 = (char *)((unsigned __int16)v13 & 0xFFFC);
        if ((v13 & 0x80000000) == 0)
          v15 = 24;
        else
          v15 = 12;
        v16 = v13 >> 31;
        if ((~(_DWORD)v13 & 3) == 0 && (_DWORD)v14 == v15)
        {
          v18 = (unint64_t)(v12 + 2) & 0xFFFFFFFFFFFFFFFCLL;
          if ((v13 & 0x80000000) != 0)
          {
            v29 = v18 | v16;
            v30 = v12[1];
            if (dataSegmentsRanges <= (unint64_t)v12 && *(_QWORD *)algn_1ECCE5978 > (unint64_t)v12)
            {
              if (v30 >= 5)
              {
                v43 = v29;
                while (1)
                {
                  result = v43 + ((unsigned __int16)v13 & 0xFFFC) * (unint64_t)(v30 >> 1);
                  v44 = *(int *)(result & 0xFFFFFFFFFFFFFFFCLL);
                  v45 = v11 > v44;
                  if (v11 == v44)
                    break;
                  v46 = v11 > v44;
                  v47 = &v14[result];
                  if (v45)
                    v43 = (unint64_t)v47;
                  v48 = v30 - v46;
                  v30 = (v30 - v46) >> 1;
                  if (v48 <= 9)
                  {
                    if (!(_DWORD)v30)
                      goto LABEL_98;
                    goto LABEL_77;
                  }
                }
                if (result > v29)
                {
                  v61 = 0;
                  v62 = v43 + ((unsigned __int16)v13 >> 2) * (((2 * v30) & 0x1FFFFFFFCLL) - 4);
                  while (v11 == *(_DWORD *)((v62 + v61) & 0xFFFFFFFFFFFFFFFCLL))
                  {
                    v61 -= (uint64_t)v14;
                    v60 = result + v61;
                    if (result + v61 <= v29)
                    {
LABEL_95:
                      result = v60;
                      goto LABEL_97;
                    }
                  }
                  result += v61;
                }
LABEL_97:
                if (result)
                  return result;
                goto LABEL_98;
              }
              v43 = v29;
              if ((_DWORD)v30)
              {
LABEL_77:
                v55 = 0;
                v56 = v30 - 1;
                do
                {
                  result = v43 + v55;
                  v57 = *(int *)((v43 + v55) & 0xFFFFFFFFFFFFFFFCLL);
                  if (v11 == v57)
                    goto LABEL_97;
                  v58 = v11 < v57 || v56-- == 0;
                  v55 += v14;
                }
                while (!v58);
              }
            }
            else
            {
              if (v30 >= 5)
              {
                v32 = (unsigned __int16)v13 & 0xFFFC;
                v33 = v29;
                while (1)
                {
                  result = v33 + ((unsigned __int16)v13 & 0xFFFC) * (unint64_t)(v30 >> 1);
                  v34 = *(_BYTE **)((result & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL));
                  v35 = v34 >= a2;
                  if (v34 == a2)
                    break;
                  v36 = v34 < a2;
                  v37 = result + ((unsigned __int16)v13 & 0xFFFC);
                  if (!v35)
                    v33 = v37;
                  v38 = v30 - v36;
                  v30 = (v30 - v36) >> 1;
                  if (v38 <= 9)
                  {
                    if (!(_DWORD)v30)
                      goto LABEL_98;
                    goto LABEL_68;
                  }
                }
                if (result <= v29)
                  goto LABEL_97;
                v49 = 0;
                v59 = v33 + ((unsigned __int16)v13 >> 2) * (((2 * v30) & 0x1FFFFFFFCLL) - 4);
                while (*(_BYTE **)(((v59 + v49) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v59 + v49) & 0xFFFFFFFFFFFFFFFCLL)) == a2)
                {
                  v49 -= v32;
                  v60 = result + v49;
                  if (result + v49 <= v29)
                    goto LABEL_95;
                }
                goto LABEL_90;
              }
              v33 = v29;
              if ((_DWORD)v30)
              {
LABEL_68:
                v51 = 0;
                v52 = v30 - 1;
                do
                {
                  result = v33 + v51;
                  v53 = *(_BYTE **)(((v33 + v51) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v33 + v51) & 0xFFFFFFFFFFFFFFFCLL));
                  if (v53 == a2)
                    goto LABEL_97;
                  v54 = v53 > a2 || v52-- == 0;
                  v51 += v14;
                }
                while (!v54);
              }
            }
          }
          else
          {
            v19 = v18 | v16;
            v20 = v12[1];
            if (v20 >= 5)
            {
              v21 = (unsigned __int16)v13 & 0xFFFC;
              v22 = v19;
              while (1)
              {
                result = v22 + ((unsigned __int16)v13 & 0xFFFC) * (unint64_t)(v20 >> 1);
                v24 = *(_BYTE **)(result & 0xFFFFFFFFFFFFFFFCLL);
                v25 = v24 >= a2;
                if (v24 == a2)
                  break;
                v26 = v24 < a2;
                v27 = result + ((unsigned __int16)v13 & 0xFFFC);
                if (!v25)
                  v22 = v27;
                v28 = v20 - v26;
                v20 = (v20 - v26) >> 1;
                if (v28 <= 9)
                {
                  if (!(_DWORD)v20)
                    goto LABEL_98;
                  goto LABEL_46;
                }
              }
              if (result <= v19)
                goto LABEL_97;
              v49 = 0;
              v50 = v22 + ((unsigned __int16)v13 >> 2) * (((2 * v20) & 0x1FFFFFFFCLL) - 4);
              while (*(_BYTE **)((v50 + v49) & 0xFFFFFFFFFFFFFFFCLL) == a2)
              {
                v49 -= v21;
                if (result + v49 <= v19)
                {
                  result += v49;
                  goto LABEL_97;
                }
              }
LABEL_90:
              result += v49;
              goto LABEL_97;
            }
            v22 = v19;
            if ((_DWORD)v20)
            {
LABEL_46:
              v39 = 0;
              v40 = v20 - 1;
              do
              {
                result = v22 + v39;
                v41 = *(_BYTE **)((v22 + v39) & 0xFFFFFFFFFFFFFFFCLL);
                if (v41 == a2)
                  goto LABEL_97;
                v42 = v41 > a2 || v40-- == 0;
                v39 += v14;
              }
              while (!v42);
            }
          }
        }
        else
        {
          if ((v13 & 0x80000000) != 0)
          {
            v70 = *v12 & 0xFFFC;
            v71 = v12[1];
            v72 = v71 * (unint64_t)v14;
            if (dataSegmentsRanges <= (unint64_t)v12 && *(_QWORD *)algn_1ECCE5978 > (unint64_t)v12)
            {
              if ((v72 & 0xFFFFFFFF00000000) != 0)
LABEL_134:
                _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, (const char *)0xC, v14, v71, (char *)v5 + (*v5 >> 16), v14);
              v76 = v12 + 2;
              result = (unint64_t)(v12 + 2) & 0xFFFFFFFFFFFFFFFCLL | v16;
              v77 = ((unint64_t)v76 + v72) & 0xFFFFFFFFFFFFFFFCLL | v16;
              while (result != v77)
              {
                if ((char *)&unk_1F25805A8 + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL) == a2)
                  goto LABEL_97;
                result += v70;
              }
            }
            else
            {
              if ((v72 & 0xFFFFFFFF00000000) != 0)
                goto LABEL_134;
              v74 = v12 + 2;
              result = (unint64_t)(v12 + 2) & 0xFFFFFFFFFFFFFFFCLL | v16;
              v75 = ((unint64_t)v74 + v72) & 0xFFFFFFFFFFFFFFFCLL | v16;
              while (result != v75)
              {
                if (*(_BYTE **)((result & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL)) == a2)
                  goto LABEL_97;
                result += v70;
              }
            }
            goto LABEL_98;
          }
          v66 = v12[1];
          v67 = v66 * (unint64_t)v14;
          if ((v67 & 0xFFFFFFFF00000000) != 0)
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, (const char *)0xC, v14, v66, (char *)v5 + (*v5 >> 16), v14);
          v68 = v12 + 2;
          result = (unint64_t)(v12 + 2) & 0xFFFFFFFFFFFFFFFCLL | v16;
          v69 = ((unint64_t)v68 + v67) & 0xFFFFFFFFFFFFFFFCLL | v16;
          if (result != v69)
          {
            while (*(_BYTE **)(result & 0xFFFFFFFFFFFFFFFCLL) != a2)
            {
              result += v14;
              if (result == v69)
                goto LABEL_98;
            }
            goto LABEL_97;
          }
        }
LABEL_98:
        v63 = v10;
        v64 = (uint64_t *)((char *)v5 + v10);
        do
        {
          v5 = v64;
          if ((unint64_t)v64 >= v9)
            break;
          v65 = *(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v64 + 8);
          v64 = (uint64_t *)((char *)v64 + v63);
        }
        while ((v65 & 1) == 0);
        v10 = v63;
      }
      while (v5 != (uint64_t *)v9);
    }
  }
  return 0;
}

unint64_t method_t::imp(unint64_t this, int a2)
{
  const method_t *v2;
  int v3;
  unint64_t v4;
  unint64_t StatusReg;
  unsigned int v6;
  uint64_t v8;
  int v9;
  unsigned int v10;

  v2 = (const method_t *)this;
  v3 = this & 3;
  if ((this & 3) == 0 || v3 == 2)
    return *(_QWORD *)((this & 0xFFFFFFFFFFFFFFFCLL) + 16);
  if (v3 == 1)
  {
    v4 = *(int *)((this & 0xFFFFFFFFFFFFFFFCLL) + 8) + (this & 0xFFFFFFFFFFFFFFFCLL) + 8;
    if (a2)
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v6 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr((unsigned int *)&runtimeLock))
      {
        if (!__stxr(v6, (unsigned int *)&runtimeLock))
          goto LABEL_12;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_12:
      v8 = method_t_remappedImp_nolock(v2);
      v9 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v10 = __ldxr((unsigned int *)&runtimeLock);
        if (v10 != v9)
          break;
        if (!__stlxr(0, (unsigned int *)&runtimeLock))
          goto LABEL_17;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
    }
    else
    {
      v8 = method_t_remappedImp_nolock((const method_t *)this);
    }
LABEL_17:
    if (v8)
      return v8;
    else
      return v4;
  }
  return this;
}

void sub_180102720(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t method_t_remappedImp_nolock(const method_t *a1)
{
  int v1;
  uint64_t result;
  uint64_t v3;

  if (!byte_1ECCE5208)
    return 0;
  v3 = 0;
  v1 = objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::LookupBucketFor<method_t const*>((unint64_t)a1, &v3);
  result = 0;
  if (v1)
  {
    if (v3 != objc::smallMethodIMPMap + 16 * dword_1ECCE5200)
      return *(_QWORD *)(v3 + 8);
  }
  return result;
}

objc_object *objc_retain_full(objc_object *result, double a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  if (((unint64_t)result & 0x8000000000000000) == 0)
  {
    v2 = __ldxr((unint64_t *)result);
    if ((*(_BYTE *)((v2 & 0xFFFFFFFF8) + 0x20) & 4) != 0)
    {
      if ((v2 & 1) != 0)
      {
        while (v2 >> 44)
        {
          v3 = __CFADD__(v2, 0x200000000000);
          v4 = v2 + 0x200000000000;
          if (v3)
          {
            __clrex();
            return objc_object::rootRetain_overflow(result, 0);
          }
          if (!__stxr(v4, (unint64_t *)result))
            return result;
          v2 = __ldxr((unint64_t *)result);
          if ((v2 & 1) == 0)
            goto LABEL_14;
        }
      }
      else if ((*(_WORD *)((v2 & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
      {
LABEL_14:
        __clrex();
        return objc_object::sidetable_retain(result, 0);
      }
      __clrex();
    }
    else
    {
      __clrex();
      if (*(__int16 *)((v2 & 0xFFFFFFFF8) + 0x1E) < 0
        && (*(_BYTE *)((v2 & 0xFFFFFFFF8) + 0x20) & 2) != 0
        && (*(_BYTE *)((v2 & 0xFFFFFFFF8) + 0x28) & 2) != 0)
      {
        return (objc_object *)swiftRetain(result, a2);
      }
      else
      {
        return -[objc_object retain](result, sel_retain);
      }
    }
  }
  return result;
}

uint64_t objc_release_full(uint64_t result, double a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char **v5;

  if ((result & 0x8000000000000000) == 0)
  {
    v2 = __ldxr((unint64_t *)result);
    if ((*(_BYTE *)((v2 & 0xFFFFFFFF8) + 0x20) & 4) != 0)
    {
      if ((v2 & 1) != 0)
      {
        while (v2 >> 44)
        {
          v3 = v2 >= 0x200000000000;
          v4 = v2 - 0x200000000000;
          if (!v3)
          {
            __clrex();
            return objc_object::rootRelease_underflow((objc_object *)result, 1);
          }
          if (!__stlxr(v4, (unint64_t *)result))
          {
            if (!(v4 >> 44))
            {
              __dmb(9u);
              if ((*(_WORD *)((*(_QWORD *)result & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0)
                v5 = &selRef__objc_initiateDealloc;
              else
                v5 = &selRef_dealloc;
              return (uint64_t)objc_msgSend((id)result, *v5);
            }
            return result;
          }
          v2 = __ldxr((unint64_t *)result);
          if ((v2 & 1) == 0)
            goto LABEL_18;
        }
      }
      else if ((*(_WORD *)((v2 & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
      {
LABEL_18:
        __clrex();
        return objc_object::sidetable_release((objc_object *)result, 0, 1);
      }
      __clrex();
    }
    else
    {
      __clrex();
      if (*(__int16 *)((v2 & 0xFFFFFFFF8) + 0x1E) < 0
        && (*(_BYTE *)((v2 & 0xFFFFFFFF8) + 0x20) & 2) != 0
        && (*(_BYTE *)((v2 & 0xFFFFFFFF8) + 0x28) & 2) != 0)
      {
        return swiftRelease((objc_object *)result, a2);
      }
      else
      {
        return (uint64_t)objc_msgSend((id)result, sel_release);
      }
    }
  }
  return result;
}

uint64_t objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::LookupBucketFor<method_t const*>(unint64_t a1, _QWORD *a2)
{
  int v2;
  unsigned int v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;

  if (dword_1ECCE5200)
  {
    v2 = dword_1ECCE5200 - 1;
    v3 = (dword_1ECCE5200 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093 * (a1 ^ (a1 >> 4))));
    v4 = (_QWORD *)(objc::smallMethodIMPMap + 16 * v3);
    v5 = *v4;
    if (*v4 == a1)
    {
      v6 = 1;
    }
    else
    {
      v8 = 0;
      v9 = 1;
      while (v5 != -1)
      {
        if (v9 > dword_1ECCE5200)
          objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::FatalCorruptHashTables((_QWORD *)objc::smallMethodIMPMap, dword_1ECCE5200);
        if (v8)
          v10 = 0;
        else
          v10 = v5 == -2;
        if (v10)
          v8 = v4;
        v11 = v3 + v9++;
        v3 = v11 & v2;
        v4 = (_QWORD *)(objc::smallMethodIMPMap + 16 * (v11 & v2));
        v5 = *v4;
        v6 = 1;
        if (*v4 == a1)
          goto LABEL_5;
      }
      v6 = 0;
      if (v8)
        v4 = v8;
    }
  }
  else
  {
    v4 = 0;
    v6 = 0;
  }
LABEL_5:
  *a2 = v4;
  return v6;
}

objc_object *objc_releaseAndReturn(objc_object *a1)
{

  return a1;
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  id v6;
  void *v7;

  if (offset)
  {
    v6 = objc_msgSend(newValue, sel_copyWithZone_, 0);
    v7 = *(void **)((char *)self + offset);
    *(_QWORD *)((char *)self + offset) = v6;

  }
  else
  {
    object_setClass(self, (Class)newValue);
  }
}

uint64_t cache_t::allocateBuckets(cache_t *this)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  BOOL v5;

  if (PrintCaches)
  {
    if (this >= 2)
    {
      v2 = -1;
      v3 = this;
      do
      {
        v4 = v2++;
        v5 = v3 > 3;
        v3 >>= 1;
      }
      while (v5);
      if (v2 > 0xE)
        goto LABEL_9;
      v1 = v4 + 2;
    }
    else
    {
      v1 = 0;
    }
    ++cache_counts[v1];
LABEL_9:
    ++cache_allocations;
  }
  return malloc_type_zone_malloc_with_options_internal();
}

uint64_t *AutoreleasePoolPage::autoreleaseNewPage(AutoreleasePoolPage *this, objc_object *a2, char *a3, char *a4)
{
  objc_object *v4;

  v4 = *(objc_object **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 344);
  if ((unint64_t)v4 < 2)
    return (uint64_t *)AutoreleasePoolPage::autoreleaseNoPage(0, v4);
  if (LODWORD(v4->isa) != -1583242847)
    AutoreleasePoolPage::busted_die((AutoreleasePoolPage *)v4, (uint64_t)v4, a3, a4);
  return AutoreleasePoolPage::autoreleaseFullPage(0, v4, (AutoreleasePoolPage *)a3, a4);
}

unint64_t _category_getLoadMethod(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  BOOL v15;
  _BOOL4 v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  BOOL v23;
  _BOOL4 v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  char *v28;
  BOOL v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  BOOL v35;
  _BOOL4 v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  char *v43;
  BOOL v44;
  unint64_t v45;
  uint64_t v46;
  int v47;
  unint64_t v48;
  BOOL v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;

  if (!a1)
    return 0;
  v4 = *a1;
  v5 = (unsigned __int16)v4 & 0xFFFC;
  if ((v4 & 0x80000000) == 0)
    v6 = 24;
  else
    v6 = 12;
  v7 = v4 >> 31;
  if ((~(_DWORD)v4 & 3) == 0 && (_DWORD)v5 == v6)
  {
    if ((v4 & 0x80000000) != 0)
    {
      if (dataSegmentsRanges <= (unint64_t)a1 && *(_QWORD *)algn_1ECCE5978 > (unint64_t)a1)
      {
        if (dataSegmentsRanges > (unint64_t)sel_load || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)sel_load)
          return 0;
        v18 = sel_load - (char *)&unk_1F25805A8;
        v19 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
        v20 = a1[1];
        if (v20 < 5)
        {
          v21 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
LABEL_68:
          if (!(_DWORD)v20)
            return 0;
          v46 = 0;
          v47 = v20 - 1;
          while (1)
          {
            v13 = v21 + v46;
            v48 = *(int *)((v21 + v46) & 0xFFFFFFFFFFFFFFFCLL);
            if (v18 == v48)
              break;
            v49 = v18 < v48 || v47-- == 0;
            v46 += v5;
            if (v49)
              return 0;
          }
        }
        else
        {
          v21 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
          while (1)
          {
            v13 = v21 + ((unsigned __int16)v4 & 0xFFFC) * (unint64_t)(v20 >> 1);
            v22 = *(int *)(v13 & 0xFFFFFFFFFFFFFFFCLL);
            v23 = v18 > v22;
            if (v18 == v22)
              break;
            v24 = v18 > v22;
            if (v23)
              v21 = v13 + v5;
            v25 = v20 - v24;
            v20 = v25 >> 1;
            if (v25 <= 9)
              goto LABEL_68;
          }
          if (v13 > v19)
          {
            v50 = 0;
            v51 = v21 + ((unsigned __int16)v4 >> 2) * (((2 * v20) & 0x1FFFFFFFCLL) - 4);
            while (v18 == *(_DWORD *)((v51 + v50) & 0xFFFFFFFFFFFFFFFCLL))
            {
              v50 -= v5;
              v40 = v13 + v50;
              if (v13 + v50 <= v19)
                goto LABEL_81;
            }
            v13 += v50;
          }
        }
        goto LABEL_82;
      }
      v30 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
      v31 = a1[1];
      if (v31 < 5)
      {
        v33 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
        if (!(_DWORD)v31)
          return 0;
LABEL_53:
        v41 = 0;
        v42 = v31 - 1;
        while (1)
        {
          v13 = v33 + v41;
          v43 = *(char **)(((v33 + v41) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v33 + v41) & 0xFFFFFFFFFFFFFFFCLL));
          if (sel_load == v43)
            break;
          v44 = sel_load < v43 || v42-- == 0;
          v41 += v5;
          if (v44)
            return 0;
        }
        goto LABEL_82;
      }
      v32 = (unsigned __int16)v4 & 0xFFFC;
      v33 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
      while (1)
      {
        v13 = v33 + ((unsigned __int16)v4 & 0xFFFC) * (unint64_t)(v31 >> 1);
        v34 = *(char **)((v13 & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(v13 & 0xFFFFFFFFFFFFFFFCLL));
        v35 = sel_load > v34;
        if (sel_load == v34)
          break;
        v36 = sel_load > v34;
        if (v35)
          v33 = v13 + ((unsigned __int16)v4 & 0xFFFC);
        v37 = v31 - v36;
        v31 = v37 >> 1;
        if (v37 <= 9)
        {
          if ((_DWORD)v31)
            goto LABEL_53;
          return 0;
        }
      }
      if (v13 <= v30)
        goto LABEL_82;
      v38 = 0;
      v45 = v33 + ((unsigned __int16)v4 >> 2) * (((2 * v31) & 0x1FFFFFFFCLL) - 4);
      while (sel_load == *(char **)(((v45 + v38) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v45 + v38) & 0xFFFFFFFFFFFFFFFCLL)))
      {
        v38 -= v32;
        v40 = v13 + v38;
        if (v13 + v38 <= v30)
        {
LABEL_81:
          v13 = v40;
          goto LABEL_82;
        }
      }
    }
    else
    {
      v9 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
      v10 = a1[1];
      if (v10 < 5)
      {
        v12 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
        if (!(_DWORD)v10)
          return 0;
LABEL_31:
        v26 = 0;
        v27 = v10 - 1;
        while (1)
        {
          v13 = v12 + v26;
          v28 = *(char **)((v12 + v26) & 0xFFFFFFFFFFFFFFFCLL);
          if (sel_load == v28)
            break;
          v29 = sel_load < v28 || v27-- == 0;
          v26 += v5;
          if (v29)
            return 0;
        }
        goto LABEL_82;
      }
      v11 = (unsigned __int16)v4 & 0xFFFC;
      v12 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
      while (1)
      {
        v13 = v12 + ((unsigned __int16)v4 & 0xFFFC) * (unint64_t)(v10 >> 1);
        v14 = *(char **)(v13 & 0xFFFFFFFFFFFFFFFCLL);
        v15 = sel_load > v14;
        if (sel_load == v14)
          break;
        v16 = sel_load > v14;
        if (v15)
          v12 = v13 + ((unsigned __int16)v4 & 0xFFFC);
        v17 = v10 - v16;
        v10 = v17 >> 1;
        if (v17 <= 9)
        {
          if ((_DWORD)v10)
            goto LABEL_31;
          return 0;
        }
      }
      if (v13 <= v9)
        goto LABEL_82;
      v38 = 0;
      v39 = v12 + ((unsigned __int16)v4 >> 2) * (((2 * v10) & 0x1FFFFFFFCLL) - 4);
      while (sel_load == *(char **)((v39 + v38) & 0xFFFFFFFFFFFFFFFCLL))
      {
        v38 -= v11;
        v40 = v13 + v38;
        if (v13 + v38 <= v9)
          goto LABEL_81;
      }
    }
    v13 += v38;
    goto LABEL_82;
  }
  if ((v4 & 0x80000000) == 0)
  {
    v53 = a1[1];
    v54 = v53 * (unint64_t)v5;
    if ((v54 & 0xFFFFFFFF00000000) == 0)
    {
      v55 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
      v56 = ((unint64_t)a1 + v54 + 8) & 0xFFFFFFFFFFFFFFFCLL | v7;
      if (v55 == v56)
        return 0;
      v57 = 0;
      while (1)
      {
        v13 = v55 + v57;
        if (*(char **)((v55 + v57) & 0xFFFFFFFFFFFFFFFCLL) == sel_load)
          break;
        v57 += v5;
        if (v55 + v57 == v56)
          return 0;
      }
      goto LABEL_82;
    }
LABEL_108:
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v53, a1, v5);
  }
  if (dataSegmentsRanges > (unint64_t)a1 || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)a1)
  {
    v53 = a1[1];
    v62 = v53 * (unint64_t)v5;
    if ((v62 & 0xFFFFFFFF00000000) != 0)
      goto LABEL_108;
    v63 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
    v64 = ((unint64_t)a1 + v62 + 8) & 0xFFFFFFFFFFFFFFFCLL | v7;
    if (v63 == v64)
      return 0;
    v65 = 0;
    while (1)
    {
      v13 = v63 + v65;
      if (*(char **)(((v63 + v65) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v63 + v65) & 0xFFFFFFFFFFFFFFFCLL)) == sel_load)
        break;
      v65 += v5;
      if (v63 + v65 == v64)
        return 0;
    }
  }
  else
  {
    if (dataSegmentsRanges > (unint64_t)sel_load || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)sel_load)
      return 0;
    v53 = a1[1];
    v58 = v53 * (unint64_t)v5;
    if ((v58 & 0xFFFFFFFF00000000) != 0)
      goto LABEL_108;
    v59 = (unint64_t)(a1 + 2) & 0xFFFFFFFFFFFFFFFCLL | v7;
    v60 = ((unint64_t)a1 + v58 + 8) & 0xFFFFFFFFFFFFFFFCLL | v7;
    if (v59 == v60)
      return 0;
    v61 = 0;
    while (1)
    {
      v13 = v59 + v61;
      if (sel_load == (char *)&unk_1F25805A8 + *(int *)((v59 + v61) & 0xFFFFFFFFFFFFFFFCLL))
        break;
      v61 += v5;
      if (v59 + v61 == v60)
        return 0;
    }
  }
LABEL_82:
  if (v13)
    return method_t::imp(v13, 0);
  return 0;
}

void (*_objc_setBadAllocHandler(void (*result)(objc_class *)))(objc_class *)
{
  badAllocHandler = result;
  return result;
}

const char *__cdecl sel_getName(const char *sel)
{
  if (!sel)
    return "<null selector>";
  return sel;
}

const char *__cdecl class_getName(Class cls)
{
  const char *v1;
  char *v2;

  if (cls)
    return (const char *)objc_class::demangledName(cls, 1, v1, v2);
  else
    return "nil";
}

SEL sel_registerName(const char *str)
{
  return (SEL)__sel_registerName((char *)str, 1, 1);
}

uint64_t __getPreoptimizedClass_block_invoke(uint64_t result, uint64_t a2, int a3, _BYTE *a4)
{
  if (a3)
  {
    **(_QWORD **)(result + 32) = a2;
    *a4 = 1;
  }
  return result;
}

BOOL class_isMetaClass(Class cls)
{
  if (cls)
    LODWORD(cls) = (*((unsigned __int16 *)cls + 15) >> 2) & 1;
  return (char)cls;
}

id class_createInstance(id cls, size_t extraBytes)
{
  objc_class *v2;
  __int16 v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;

  if (cls)
  {
    v2 = (objc_class *)cls;
    v3 = *((_WORD *)cls + 15);
    if ((v3 & 0xFF8) != 0)
    {
      v4 = (extraBytes + (v3 & 0xFF8) + 7) & 0xFFFFFFFFFFFFFFF0;
    }
    else
    {
      v11 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
      v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
      if ((v11 & 1) != 0)
        v12 = *(_QWORD *)v12;
      v13 = ((*(_DWORD *)(v12 + 8) + 7) & 0xFFFFFFF8) + extraBytes;
      v4 = v13 <= 0x10 ? 16 : v13;
    }
    cls = malloc_type_calloc(1uLL, v4, 0x40000000000uLL);
    if (cls)
    {
      v8 = (unint64_t)v2 & 0xFFFFFFF000000007;
      if ((v3 & 0x2000) != 0)
      {
        if (!v8)
        {
          v10 = (unint64_t)v2 & 0xFFFFFFFF8;
LABEL_12:
          *(_QWORD *)cls = v10;
          if ((v3 & 2) != 0)
            return object_cxxConstructFromClass((void (*)(void))cls, v2, 1);
          return cls;
        }
      }
      else if (!v8)
      {
        v9 = 0x21A000000001;
        if ((v3 & 1) != 0)
          v9 = 0x21A000000005;
        v10 = v9 | (unint64_t)v2 & 0xFFFFFFFF8;
        goto LABEL_12;
      }
      _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v5, v6, v7, v2);
    }
  }
  return cls;
}

BOOL class_respondsToSelector(Class cls, SEL sel)
{
  return class_respondsToSelector_inst(0, (objc_selector *)sel, cls);
}

objc_object *objc_opt_respondsToSelector(objc_object *result, objc_selector *a2)
{
  uint64_t v2;

  if (result)
  {
    if (((unint64_t)result & 0x8000000000000000) != 0)
    {
      v2 = objc_debug_taggedpointer_classes[result & 7];
      if ((__objc2_class *)v2 == __NSUnrecognizedTaggedPointer)
        v2 = objc_debug_taggedpointer_ext_classes[((unint64_t)result >> 55)];
    }
    else
    {
      v2 = (uint64_t)result->isa & 0xFFFFFFFF8;
    }
    if (*(__int16 *)(v2 + 30) < 0)
      return (objc_object *)class_respondsToSelector_inst(result, a2, (objc_class *)v2);
    else
      return (objc_object *)-[objc_object respondsToSelector:](result, sel_respondsToSelector_, a2);
  }
  return result;
}

unint64_t objc_opt_isKindOfClass(unint64_t result, uint64_t a2)
{
  uint64_t v2;
  BOOL v3;

  if (result)
  {
    if ((result & 0x8000000000000000) != 0)
    {
      v2 = objc_debug_taggedpointer_classes[result & 7];
      if ((__objc2_class *)v2 == __NSUnrecognizedTaggedPointer)
        v2 = objc_debug_taggedpointer_ext_classes[(result >> 55)];
    }
    else
    {
      v2 = *(_QWORD *)result & 0xFFFFFFFF8;
    }
    if (*(__int16 *)(v2 + 30) < 0)
    {
      if (v2 == a2)
      {
        return 1;
      }
      else
      {
        do
        {
          v2 = *(_QWORD *)(v2 + 8);
          if (v2)
            v3 = v2 == a2;
          else
            v3 = 1;
        }
        while (!v3);
        return v2 != 0;
      }
    }
    else
    {
      return (unint64_t)objc_msgSend((id)result, sel_isKindOfClass_, a2);
    }
  }
  return result;
}

Method class_getInstanceMethod(Class cls, SEL name)
{
  objc_method *MethodNoSuper_nolock;
  Class v4;
  const char *v5;
  char *v6;
  unint64_t StatusReg;
  unsigned int v8;
  int v10;
  unsigned int v11;

  MethodNoSuper_nolock = 0;
  if (cls && name)
  {
    v4 = cls;
    lookUpImpOrForward(0, (objc_selector *)name, cls, 2u);
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v8 = *(_DWORD *)(StatusReg + 24);
    do
    {
      if (__ldaxr(runtimeLock))
      {
        __clrex();
        os_unfair_lock_lock_with_options();
        break;
      }
    }
    while (__stxr(v8, runtimeLock));
    while (1)
    {
      MethodNoSuper_nolock = (objc_method *)getMethodNoSuper_nolock(v4, (objc_selector *)name, v5, v6);
      if (MethodNoSuper_nolock)
        break;
      v4 = (Class)*((_QWORD *)v4 + 1);
      if (!v4)
      {
        MethodNoSuper_nolock = 0;
        break;
      }
    }
    v10 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v11 = __ldxr(runtimeLock);
      if (v11 != v10)
        break;
      if (!__stlxr(0, runtimeLock))
        return MethodNoSuper_nolock;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return MethodNoSuper_nolock;
}

void sub_180103430(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void objc_copyWeak(id *to, id *from)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained(from);
  objc_initWeak(to, WeakRetained);

}

id objc_loadWeak(id *location)
{
  if (*location)
    return objc_loadWeakRetained(location);
  else
    return 0;
}

id objc_loadWeakRetained(id *location)
{
  objc_object *v1;
  unint64_t StatusReg;
  os_unfair_lock_s *v4;
  unsigned int v5;
  int v7;
  unsigned int v8;
  __objc2_class *v9;
  __objc2_class_ro *info;
  int v11;
  int v12;
  unsigned int v13;
  void (*v14)(void);
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  objc_object *v18;
  int v19;
  unsigned int v20;

  v1 = (objc_object *)*location;
  if ((uint64_t)*location < 1)
    return v1;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  while (1)
  {
                                                                 * (unint64_t)(((v1 >> 4) ^ (v1 >> 9)) & 7)];
    v5 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(&v4->_os_unfair_lock_opaque))
    {
      if (!__stxr(v5, &v4->_os_unfair_lock_opaque))
        goto LABEL_8;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_8:
    if (*location != v1)
    {
      v7 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v8 = __ldxr(&v4->_os_unfair_lock_opaque);
        if (v8 != v7)
          break;
        if (!__stlxr(0, &v4->_os_unfair_lock_opaque))
          goto LABEL_25;
      }
      __clrex();
                                                                                  * (unint64_t)(((v1 >> 4) ^ (v1 >> 9)) & 7)]);
      goto LABEL_25;
    }
    v9 = (__objc2_class *)((uint64_t)v1->isa & 0xFFFFFFFF8);
    info = v9->info;
    if ((info & 4) != 0)
      break;
    v11 = *(_DWORD *)((unint64_t)info & 0xF00007FFFFFFFF8);
    if ((v11 & 1) == 0)
      v11 = *(_DWORD *)(*(_QWORD *)(((uint64_t)v9->isa & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    if ((v11 & 0x20000000) != 0
      || _thisThreadIsInitializingClass((_QWORD *)((uint64_t)v1->isa & 0xFFFFFFFF8)))
    {
      v14 = lookUpImpOrForwardTryCache((uint64_t)v1, (unint64_t)sel_retainWeakReference, v9, 0);
      if (v14 == _objc_msgForward)
      {
        v1 = 0;
      }
      else if (!((unsigned int (*)(objc_object *, char *))v14)(v1, sel_retainWeakReference))
      {
        v1 = 0;
      }
      goto LABEL_48;
    }
    v12 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v13 = __ldxr(&v4->_os_unfair_lock_opaque);
      if (v13 != v12)
        break;
      if (!__stlxr(0, &v4->_os_unfair_lock_opaque))
        goto LABEL_24;
    }
    __clrex();
                                                                                * (unint64_t)(((v1 >> 4) ^ (v1 >> 9)) & 7)]);
LABEL_24:
    class_initialize(v9, v1);
LABEL_25:
    v1 = (objc_object *)*location;
    if ((uint64_t)*location <= 0)
      return v1;
  }
  v15 = __ldxr((unint64_t *)v1);
  if ((v15 & 1) != 0)
  {
    while (1)
    {
      if (!(v15 >> 44))
      {
        v18 = 0;
        __clrex();
        goto LABEL_46;
      }
      v16 = __CFADD__(v15, 0x200000000000);
      v17 = v15 + 0x200000000000;
      if (v16)
        break;
      if (!__stxr(v17, (unint64_t *)v1))
        goto LABEL_45;
      v15 = __ldxr((unint64_t *)v1);
      if ((v15 & 1) == 0)
        goto LABEL_39;
    }
    __clrex();
    v18 = objc_object::rootRetain_overflow(v1, 1);
  }
  else if ((*(_WORD *)((v15 & 0xFFFFFFFF8) + 0x1E) & 4) != 0)
  {
    __clrex();
LABEL_45:
    v18 = v1;
  }
  else
  {
LABEL_39:
    __clrex();
    if (objc_object::sidetable_tryRetain(v1))
      v18 = v1;
    else
      v18 = 0;
  }
LABEL_46:
  if (!v18)
    v1 = 0;
LABEL_48:
  v19 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v20 = __ldxr(&v4->_os_unfair_lock_opaque);
    if (v20 != v19)
      break;
    if (!__stlxr(0, &v4->_os_unfair_lock_opaque))
      return v1;
  }
  __clrex();
  os_unfair_lock_unlock(v4);
  return v1;
}

void (*lookUpImpOrForwardTryCache(uint64_t a1, unint64_t a2, _QWORD *a3, uint64_t a4))(void)
{
  int v8;
  void (*result)(void);

  v8 = *(_DWORD *)(a3[4] & 0xF00007FFFFFFFF8);
  if ((v8 & 1) == 0)
    v8 = *(_DWORD *)(*(_QWORD *)((*a3 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v8 & 0x20000000) == 0)
    return (void (*)(void))lookUpImpOrForward(a1, a2, a3, a4);
  result = (void (*)(void))cache_getImp((uint64_t)a3, a2, 0);
  if (!result)
  {
    if ((a3[2] & 1) == 0)
      return (void (*)(void))lookUpImpOrForward(a1, a2, a3, a4);
    result = (void (*)(void))cache_getImp((uint64_t)a3 + *(_QWORD *)((a3[2] & 0xFFFFFFFFFFFELL) - 16), a2, 0);
    if (!result)
      return (void (*)(void))lookUpImpOrForward(a1, a2, a3, a4);
  }
  if (((result == _objc_msgForward_impcache) & (a4 >> 2)) != 0)
    return 0;
  return result;
}

void (*resolveMethod_locked(objc_object *a1, objc_selector *a2, objc_class *a3, uint64_t a4))(void)
{
  unint64_t StatusReg;
  int v9;
  unsigned int v10;
  const char *v11;
  char *v12;
  unsigned int v13;
  objc_class *MaybeUnrealizedNonMetaClass;
  objc_class *v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  void (*v20)(void);
  unsigned int v21;
  void (*v22)(void);
  char *v24;
  uint64_t v25;
  const char *v26;
  char *v27;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v9 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v10 = __ldxr((unsigned int *)&runtimeLock);
    if (v10 != v9)
      break;
    if (!__stlxr(0, (unsigned int *)&runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
LABEL_6:
  if ((*((_WORD *)a3 + 15) & 4) == 0)
    goto LABEL_25;
  if (lookUpImpOrNilTryCache((uint64_t)a1, (unint64_t)sel_resolveClassMethod_, a3, 0))
  {
    v13 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr((unsigned int *)&runtimeLock))
    {
      if (!__stxr(v13, (unsigned int *)&runtimeLock))
        goto LABEL_13;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_13:
    MaybeUnrealizedNonMetaClass = getMaybeUnrealizedNonMetaClass(a3, a1, v11, v12);
    v16 = MaybeUnrealizedNonMetaClass;
    if ((unint64_t)(*(_QWORD *)MaybeUnrealizedNonMetaClass - 1) < 0xF
      || (*(_DWORD *)(*((_QWORD *)MaybeUnrealizedNonMetaClass + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0)
    {
      v24 = objc_class::nameForLogging(MaybeUnrealizedNonMetaClass);
      _objc_fatal("nonmeta class %s (%p) unexpectedly not realized", v25, v26, v27, v24, v16);
    }
    v17 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v18 = __ldxr((unsigned int *)&runtimeLock);
      if (v18 != v17)
        break;
      if (!__stlxr(0, (unsigned int *)&runtimeLock))
        goto LABEL_20;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
LABEL_20:
    v19 = -[objc_class resolveClassMethod:](v16, sel_resolveClassMethod_, a2);
    v20 = lookUpImpOrNilTryCache((uint64_t)a1, (unint64_t)a2, a3, 0);
    if (v19 && PrintResolving)
    {
      if (v20)
      {
        objc_class::nameForLogging(a3);
        _objc_inform("RESOLVE: method %c[%s %s] dynamically resolved to %p");
      }
      else
      {
        objc_class::nameForLogging(a3);
        objc_class::nameForLogging(a3);
        _objc_inform("RESOLVE: +[%s resolveClassMethod:%s] returned YES, but no new implementation of %c[%s %s] was found");
      }
    }
  }
  if (!lookUpImpOrNilTryCache((uint64_t)a1, (unint64_t)a2, a3, 0))
  {
LABEL_25:
    if (lookUpImpOrNilTryCache((uint64_t)a3, (unint64_t)sel_resolveInstanceMethod_, (_QWORD *)(*(_QWORD *)a3 & 0xFFFFFFFF8), 0))
    {
      v21 = -[objc_class resolveInstanceMethod:](a3, sel_resolveInstanceMethod_, a2);
      v22 = lookUpImpOrNilTryCache((uint64_t)a1, (unint64_t)a2, a3, 0);
      if (v21)
      {
        if (PrintResolving)
        {
          if (v22)
          {
            objc_class::nameForLogging(a3);
            _objc_inform("RESOLVE: method %c[%s %s] dynamically resolved to %p");
          }
          else
          {
            objc_class::nameForLogging(a3);
            objc_class::nameForLogging(a3);
            _objc_inform("RESOLVE: +[%s resolveInstanceMethod:%s] returned YES, but no new implementation of %c[%s %s] was found");
          }
        }
      }
    }
  }
  return lookUpImpOrForwardTryCache((uint64_t)a1, (unint64_t)a2, a3, a4);
}

void sub_180103B48(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void (*lookUpImpOrNilTryCache(uint64_t a1, unint64_t a2, _QWORD *a3, int a4))(void)
{
  uint64_t v7;
  int v8;
  void (*result)(void);

  v7 = a4 | 4u;
  v8 = *(_DWORD *)(a3[4] & 0xF00007FFFFFFFF8);
  if ((v8 & 1) == 0)
    v8 = *(_DWORD *)(*(_QWORD *)((*a3 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v8 & 0x20000000) == 0)
    return (void (*)(void))lookUpImpOrForward(a1, a2, a3, v7);
  result = (void (*)(void))cache_getImp((uint64_t)a3, a2, 0);
  if (!result)
  {
    if ((a3[2] & 1) == 0)
      return (void (*)(void))lookUpImpOrForward(a1, a2, a3, v7);
    result = (void (*)(void))cache_getImp((uint64_t)a3 + *(_QWORD *)((a3[2] & 0xFFFFFFFFFFFELL) - 16), a2, 0);
    if (!result)
      return (void (*)(void))lookUpImpOrForward(a1, a2, a3, v7);
  }
  if (result == _objc_msgForward_impcache)
    return 0;
  return result;
}

BOOL _objc_rootTryRetain(objc_object *a1)
{
  objc_object *v1;
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v1 = a1;
  if (((unint64_t)a1 & 0x8000000000000000) == 0)
  {
    v2 = __ldxr((unint64_t *)a1);
    if ((v2 & 1) != 0)
    {
      while (1)
      {
        if (!(v2 >> 44))
        {
          v1 = 0;
          goto LABEL_13;
        }
        v3 = __CFADD__(v2, 0x200000000000);
        v4 = v2 + 0x200000000000;
        if (v3)
          break;
        if (!__stxr(v4, (unint64_t *)a1))
          return v1 != 0;
        v2 = __ldxr((unint64_t *)a1);
        if ((v2 & 1) == 0)
          goto LABEL_9;
      }
      __clrex();
      v1 = objc_object::rootRetain_overflow(a1, 1);
    }
    else if ((*(_WORD *)((v2 & 0xFFFFFFFF8) + 0x1E) & 4) != 0)
    {
LABEL_13:
      __clrex();
    }
    else
    {
LABEL_9:
      __clrex();
      if (!objc_object::sidetable_tryRetain(a1))
        v1 = 0;
    }
  }
  return v1 != 0;
}

objc_object *_objc_rootRetainCount(objc_object *this)
{
  unint64_t v2;
  Class isa;
  os_unfair_lock_s *v4;
  int v5;
  unsigned int v6;
  os_unfair_lock_s *v7;
  int v8;
  unsigned int v9;

  if (((unint64_t)this & 0x8000000000000000) != 0)
    return this;
  objc_object::sidetable_lock(this);
  isa = this->isa;
  if (((uint64_t)this->isa & 1) != 0)
  {
    v2 = (unint64_t)isa >> 45;
    if (((unint64_t)isa & 0x100000000000) != 0)
      v2 += objc_object::sidetable_getExtraRC_nolock(this);
                                                                 * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
    v8 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    while (1)
    {
      v9 = __ldxr(&v7->_os_unfair_lock_opaque);
      if (v9 != v8)
        break;
      if (!__stlxr(0, &v7->_os_unfair_lock_opaque))
        return (objc_object *)v2;
    }
    __clrex();
    os_unfair_lock_unlock(v7);
    return (objc_object *)v2;
  }
                                                               * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  v5 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (1)
  {
    v6 = __ldxr(&v4->_os_unfair_lock_opaque);
    if (v6 != v5)
      break;
    if (!__stlxr(0, &v4->_os_unfair_lock_opaque))
      return (objc_object *)objc_object::sidetable_retainCount(this);
  }
  __clrex();
  os_unfair_lock_unlock(v4);
  return (objc_object *)objc_object::sidetable_retainCount(this);
}

BOOL objc_object::rootRelease_underflow(objc_object *this, int a2)
{
  unint64_t v4;
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  _BOOL8 result;
  char **v15;

  if (((unint64_t)this & 0x8000000000000000) != 0)
    return 0;
  v4 = __ldxr((unint64_t *)this);
  if ((v4 & 1) != 0)
  {
    v5 = 0;
    while (v4 >> 44)
    {
      v6 = v4 - 0x200000000000;
      if (v4 < 0x200000000000)
      {
        if ((v5 & 1) != 0)
        {
          v7 = objc_object::sidetable_subExtraRC_nolock(this);
          if (!v7)
            goto LABEL_38;
          v9 = (v7 << 45) - 0x200000000000;
          if (!__stlxr(v9 & 0xFFFFE00000000000 | v4 & 0xFFFFFFFFFFFLL | ((unint64_t)(v8 != 0) << 44), (unint64_t *)this))
          {
            if (!v8)
              objc_object::sidetable_clearExtraRC_nolock(this);
            goto LABEL_26;
          }
          v10 = __ldxr((unint64_t *)this);
          if ((v10 & 1) != 0)
          {
            v11 = __CFADD__(v10, v9);
            v12 = v10 + v9;
            if (!v11)
            {
              v13 = v12 & 0xFFFFEFFFFFFFFFFFLL | ((unint64_t)(v8 != 0) << 44);
              if (!__stlxr(v13, (unint64_t *)this))
              {
                if (!v8)
                  objc_object::sidetable_clearExtraRC_nolock(this);
                if (!(v13 >> 44))
                  goto LABEL_38;
LABEL_26:
                objc_object::sidetable_unlock(this);
                return 0;
              }
              __ldxr((unint64_t *)this);
            }
          }
          __clrex();
          objc_object::sidetable_addExtraRC_nolock(this, v7);
        }
        else
        {
          __clrex();
          objc_object::sidetable_lock(this);
        }
        v4 = __ldxr((unint64_t *)this);
        v5 = 1;
        if ((v4 & 1) == 0)
          goto LABEL_31;
      }
      else
      {
        if (!__stlxr(v6, (unint64_t *)this))
        {
          if (v6 >> 44)
          {
            if ((v5 & 1) == 0)
              return 0;
            goto LABEL_26;
          }
          if ((v5 & 1) != 0)
LABEL_38:
            objc_object::sidetable_unlock(this);
          __dmb(9u);
          if (a2)
          {
            if ((*(_WORD *)(((uint64_t)this->isa & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0)
              v15 = &selRef__objc_initiateDealloc;
            else
              v15 = &selRef_dealloc;
            objc_msgSend(this, *v15);
          }
          return 1;
        }
        v4 = __ldxr((unint64_t *)this);
        if ((v4 & 1) == 0)
          goto LABEL_31;
      }
    }
    __clrex();
    if ((v5 & 1) != 0)
      goto LABEL_26;
    return 0;
  }
  if ((*(_WORD *)((v4 & 0xFFFFFFFF8) + 0x1E) & 4) != 0)
  {
    result = 0;
    __clrex();
  }
  else
  {
    v5 = 0;
LABEL_31:
    __clrex();
    return objc_object::sidetable_release(this, v5 & 1, a2);
  }
  return result;
}

objc_object *objc_object::rootRetain_overflow(objc_object *this, int a2)
{
  objc_object *v2;
  unint64_t v4;
  int v5;
  unint64_t v6;

  v2 = this;
  if (((unint64_t)this & 0x8000000000000000) == 0)
  {
    v4 = __ldxr((unint64_t *)this);
    if ((v4 & 1) != 0)
    {
      v5 = 0;
      while (v4 >> 44)
      {
        v6 = v4 + 0x200000000000;
        if (v4 >= 0xFFFFE00000000000)
        {
          if (((a2 | v5) & 1) == 0)
            objc_object::sidetable_lock(v2);
          if (!__stxr(v6 & 0xFFFFFFFFFFFLL | 0x8000100000000000, (unint64_t *)v2))
          {
            objc_object::sidetable_addExtraRC_nolock(v2, 0x40000);
            LOBYTE(v5) = 1;
LABEL_25:
            if (!a2 && (v5 & 1) != 0)
              objc_object::sidetable_unlock(v2);
            return v2;
          }
          v5 = 1;
        }
        else if (!__stxr(v6, (unint64_t *)v2))
        {
          goto LABEL_25;
        }
        v4 = __ldxr((unint64_t *)v2);
        if ((v4 & 1) == 0)
          goto LABEL_15;
      }
      __clrex();
      if ((v5 & 1) != 0)
        objc_object::sidetable_unlock(v2);
      if (a2)
        return 0;
    }
    else if ((*(_WORD *)((v4 & 0xFFFFFFFF8) + 0x1E) & 4) != 0)
    {
      __clrex();
    }
    else
    {
      LOBYTE(v5) = 0;
LABEL_15:
      __clrex();
      if (a2)
      {
        if (!objc_object::sidetable_tryRetain(v2))
          return 0;
      }
      else
      {
        objc_object::sidetable_retain(v2, v5 & 1);
      }
    }
  }
  return v2;
}

unsigned int *objc_object::sidetable_lock(objc_object *this)
{
  unsigned int *result;
  unsigned int v2;

                                                               * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  v2 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (!__ldaxr(result))
  {
    if (!__stxr(v2, result))
      return result;
  }
  __clrex();
  return (unsigned int *)os_unfair_lock_lock_with_options();
}

void objc_object::sidetable_unlock(objc_object *this)
{
  os_unfair_lock_s *v1;
  int v2;
  unsigned int v3;

                                                               * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  v2 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (1)
  {
    v3 = __ldxr(&v1->_os_unfair_lock_opaque);
    if (v3 != v2)
      break;
    if (!__stlxr(0, &v1->_os_unfair_lock_opaque))
      return;
  }
  __clrex();
  os_unfair_lock_unlock(v1);
}

uint64_t *objc_object::sidetable_addExtraRC_nolock(objc_object *this, uint64_t a2)
{
  uint64_t *result;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v6 = -(uint64_t)this;
  v4 = *result;
  if ((*result & 0x8000000000000000) == 0)
  {
    if (__CFADD__(v4, 4 * a2))
      v5 = *result & 3 | 0x8000000000000000;
    else
      v5 = v4 + 4 * a2;
    *result = v5;
  }
  return result;
}

void objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::compact(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 16);
  if (v2)
  {
    if (v3 >= 0x401 && v3 >> 4 > v2)
  }
  else if (v3)
  {
    free(*(void **)a1);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void objc_object::sidetable_clearExtraRC_nolock(objc_object *this)
{
  uint64_t v1;
  int *v2;
  _QWORD *v3;
  _QWORD *v4;

  v1 = ((this >> 4) ^ (this >> 9)) & 7;
  v4 = 0;
  else
    v3 = (_QWORD *)(*((_QWORD *)v2 + 1) + 16 * v2[6]);
  *v3 = 2;
}

uint64_t objc_object::sidetable_tryRetain(objc_object *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;

  v4 = -(uint64_t)this;
  v3 = 4;
  if (!v6)
  {
    v2 = *(_QWORD *)(v5 + 8);
    if ((v2 & 2) != 0)
      return 0;
    if ((v2 & 0x8000000000000000) == 0)
      *(_QWORD *)(v5 + 8) = v2 + 4;
  }
  return 1;
}

BOOL objc_object::sidetable_release(objc_object *this, char a2, int a3)
{
  int *v5;
  unsigned int v6;
  _BOOL4 v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  char **v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;

                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  if ((a2 & 1) == 0)
  {
    v6 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    while (!__ldaxr((unsigned int *)v5))
    {
      if (!__stxr(v6, (unsigned int *)v5))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
  }
LABEL_7:
  v16 = -(uint64_t)this;
  v15 = 2;
  if (v18)
  {
    v8 = 1;
  }
  else
  {
    v9 = *(_QWORD *)(v17 + 8);
    v8 = v9 < 2;
    if (v9 > 1)
    {
      if ((v9 & 0x8000000000000000) != 0)
      {
        v8 = 0;
        goto LABEL_15;
      }
      v10 = v9 - 4;
    }
    else
    {
      v10 = v9 | 2;
    }
    *(_QWORD *)(v17 + 8) = v10;
  }
LABEL_15:
  v11 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (1)
  {
    v12 = __ldxr((unsigned int *)v5);
    if (v12 != v11)
      break;
    if (!__stlxr(0, (unsigned int *)v5))
      goto LABEL_20;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)v5);
LABEL_20:
  if ((v8 & a3) == 1)
  {
    if ((*(_WORD *)(((uint64_t)this->isa & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0)
      v13 = &selRef__objc_initiateDealloc;
    else
      v13 = &selRef_dealloc;
    objc_msgSend(this, *v13);
  }
  return v8;
}

uint64_t objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::try_emplace<unsigned long>(uint64_t a1, int32x2_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result;
  _QWORD *v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;

  v13 = 0;
  v9 = v13;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    v9 = (_QWORD *)result;
    v11 = *a4;
    *(_QWORD *)result = *a3;
    *(_QWORD *)(result + 8) = v11;
    v10 = 1;
  }
  v12 = *(_QWORD *)a2 + 16 * a2[2].u32[0];
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v12;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

void objc_object::clearDeallocating_slow(objc_object *this, uint64_t a2, const char *a3, char *a4)
{
  int *v5;
  unint64_t StatusReg;
  unsigned int v7;
  Class isa;
  int v10;
  unsigned int v11;
  _QWORD *v12;

                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)v5))
  {
    if (!__stxr(v7, (unsigned int *)v5))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  isa = this->isa;
  if (((uint64_t)this->isa & 0x40000000000) != 0)
  {
    weak_clear_no_lock((_QWORD *)v5 + 4, this, a3, a4);
    isa = this->isa;
  }
  if (((unint64_t)isa & 0x100000000000) != 0)
  {
    v12 = 0;
    {
      *v12 = 2;
      *((int32x2_t *)v5 + 2) = vadd_s32(*(int32x2_t *)(v5 + 4), (int32x2_t)0x1FFFFFFFFLL);
    }
  }
  v10 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v11 = __ldxr((unsigned int *)v5);
    if (v11 != v10)
      break;
    if (!__stlxr(0, (unsigned int *)v5))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)v5);
}

void weak_clear_no_lock(_QWORD *a1, const void *a2, const char *a3, char *a4)
{
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  const void **v10;
  const void *v11;

  v6 = weak_entry_for_referent(a1, (unint64_t)a2, a3, a4);
  if (v6)
  {
    v7 = (uint64_t)v6;
    if ((v6[2] & 3) == 2)
    {
      v8 = v6[3] + 1;
      if (v8 < 2)
      {
LABEL_17:
        weak_entry_remove((uint64_t)a1, v7);
        return;
      }
      v9 = (_QWORD *)v6[1];
    }
    else
    {
      v9 = v6 + 1;
      v8 = 4;
    }
    do
    {
      if (*v9)
      {
        v10 = (const void **)-*v9;
        v11 = *v10;
        if (*v10 == a2)
        {
          *v10 = 0;
        }
        else if (v11)
        {
          if (DebugWeakErrors)
          {
            if (DebugWeakErrors == 2)
              ((void (*)(const char *, ...))_objc_fatal)("__weak variable at %p holds %p instead of %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak().%s", v10, v11, a2, "");
            v6 = (_QWORD *)((uint64_t (*)(const char *, ...))_objc_inform)("__weak variable at %p holds %p instead of %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak().%s", v10, v11, a2, " Break on objc_weak_error to debug.");
          }
          v6 = (_QWORD *)gdb_objc_class_changed(v6);
        }
      }
      ++v9;
      --v8;
    }
    while (v8);
    goto LABEL_17;
  }
}

void objc_moveWeak(id *to, id *from)
{
  char *v2;
  unint64_t v4;
  unint64_t StatusReg;
  int *v7;
  unsigned int v8;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;

  v4 = (unint64_t)*from;
  if (*from)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    while (1)
    {
                                               * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)];
      v8 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr((unsigned int *)v7))
      {
        if (!__stxr(v8, (unsigned int *)v7))
          goto LABEL_8;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_8:
      if (*from == (id)v4)
        break;
      v10 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v11 = __ldxr((unsigned int *)v7);
        if (v11 != v10)
          break;
        if (!__stlxr(0, (unsigned int *)v7))
          goto LABEL_14;
      }
      __clrex();
                                                                                  * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)]);
LABEL_14:
      v4 = (unint64_t)*from;
      if (!*from)
        goto LABEL_15;
    }
    weak_unregister_no_lock((_QWORD *)v7 + 4, v4, (const char *)from, v2);
    weak_register_no_lock((char **)v7 + 4, v4, (uint64_t)to, (char *)2);
    *to = (id)v4;
    *from = 0;
    v12 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v13 = __ldxr((unsigned int *)v7);
      if (v13 != v12)
        break;
      if (!__stlxr(0, (unsigned int *)v7))
        return;
    }
    __clrex();
                                                                                * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)]);
  }
  else
  {
LABEL_15:
    *to = 0;
  }
}

void objc_destroyWeak(id *location)
{
  char *v1;
  unint64_t StatusReg;
  id v4;
  int *v5;
  unsigned int v6;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
LABEL_2:
  while (1)
  {
    v4 = *location;
                                             * (unint64_t)(((*location >> 4) ^ (*location >> 9)) & 7)];
    v6 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr((unsigned int *)v5))
    {
      if (!__stxr(v6, (unsigned int *)v5))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_7:
    if (*location == v4)
      break;
    v8 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v9 = __ldxr((unsigned int *)v5);
      if (v9 != v8)
        break;
      if (!__stlxr(0, (unsigned int *)v5))
        goto LABEL_2;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)v5);
  }
  weak_unregister_no_lock((_QWORD *)v5 + 4, (unint64_t)v4, (const char *)location, v1);
  v10 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v11 = __ldxr((unsigned int *)v5);
    if (v11 != v10)
      break;
    if (!__stlxr(0, (unsigned int *)v5))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)v5);
}

id objc_initWeak(id *location, id val)
{
  uint64_t v2;
  __objc2_class *v4;
  int *v5;
  unint64_t StatusReg;
  unsigned int v7;
  __objc2_class *v9;
  int v10;
  int v11;
  unsigned int v12;
  int64_t v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  _QWORD *v18;
  uint64_t v19;

  v2 = (uint64_t)val;
  if (val)
  {
    v4 = 0;
                                             * (unint64_t)(((val >> 4) ^ (val >> 9)) & 7)];
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    while (1)
    {
      v7 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr((unsigned int *)v5))
      {
        if (!__stxr(v7, (unsigned int *)v5))
          goto LABEL_8;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_8:
      if (v2 < 0)
      {
        v9 = (__objc2_class *)objc_debug_taggedpointer_classes[v2 & 7];
        if (v9 == __NSUnrecognizedTaggedPointer)
          v9 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[((unint64_t)v2 >> 55)];
      }
      else
      {
        v9 = (__objc2_class *)(*(_QWORD *)v2 & 0xFFFFFFFF8);
      }
      if (v9 == v4)
        break;
      v10 = *(_DWORD *)((uint64_t)v9->info & 0xF00007FFFFFFFF8);
      if ((v10 & 1) == 0)
        v10 = *(_DWORD *)(*(_QWORD *)(((uint64_t)v9->isa & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
      if ((v10 & 0x20000000) != 0)
        break;
      v11 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v12 = __ldxr((unsigned int *)v5);
        if (v12 != v11)
          break;
        if (!__stlxr(0, (unsigned int *)v5))
          goto LABEL_19;
      }
      __clrex();
                                                                                  * (unint64_t)(((v2 >> 4) ^ (v2 >> 9)) & 7)]);
LABEL_19:
      class_initialize(v9, (objc_object *)v2);
      v4 = v9;
    }
    v13 = weak_register_no_lock((char **)v5 + 4, v2, (uint64_t)location, (char *)1);
    v2 = v13;
    if (v13 >= 1)
    {
      while (1)
      {
        v14 = __ldxr((unint64_t *)v13);
        if ((v14 & 1) == 0)
          break;
        if ((v14 & 0x40000000000) != 0)
        {
          __clrex();
          goto LABEL_26;
        }
        if (!__stxr(v14 | 0x40000000000, (unint64_t *)v13))
          goto LABEL_26;
      }
      __clrex();
      v19 = -v13;
      *v18 |= 1uLL;
    }
LABEL_26:
    *location = (id)v2;
    v15 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v16 = __ldxr((unsigned int *)v5);
      if (v16 != v15)
        break;
      if (!__stlxr(0, (unsigned int *)v5))
        goto LABEL_32;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)v5);
LABEL_32:
    callSetWeaklyReferenced(v2);
  }
  else
  {
    *location = 0;
  }
  return (id)v2;
}

id objc_storeWeak(id *location, id obj)
{
  __objc2_class *v4;
  int *v5;
  uint64_t v6;
  id v7;
  int *v8;
  char *v9;
  __objc2_class *v10;
  int v11;
  int64_t v12;
  void *v13;
  unint64_t v14;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;

  v4 = 0;
                                           * (unint64_t)(((obj >> 4) ^ (obj >> 9)) & 7)];
  v17 = obj & 7;
  v6 = ((unint64_t)obj >> 55);
  while (1)
  {
    while (1)
    {
      v7 = *location;
                                               * (unint64_t)(((*location >> 4) ^ (*location >> 9)) & 7)];
      locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::lockWith((unsigned int *)v8, (unsigned int *)v5);
      if (*location == v7)
        break;
      locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
    }
    if (!obj)
      break;
    if (((unint64_t)obj & 0x8000000000000000) != 0)
    {
      v10 = (__objc2_class *)objc_debug_taggedpointer_classes[v17];
      if (v10 == __NSUnrecognizedTaggedPointer)
        v10 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[v6];
    }
    else
    {
      v10 = (__objc2_class *)(*(_QWORD *)obj & 0xFFFFFFFF8);
    }
    if (v10 == v4)
      break;
    v11 = *(_DWORD *)((uint64_t)v10->info & 0xF00007FFFFFFFF8);
    if ((v11 & 1) == 0)
      v11 = *(_DWORD *)(*(_QWORD *)(((uint64_t)v10->isa & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    if ((v11 & 0x20000000) != 0)
      break;
    locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
    class_initialize(v10, (objc_object *)obj);
    v4 = v10;
  }
  weak_unregister_no_lock((_QWORD *)v8 + 4, (unint64_t)v7, (const char *)location, v9);
  v12 = weak_register_no_lock((char **)v5 + 4, (uint64_t)obj, (uint64_t)location, (char *)1);
  v13 = (void *)v12;
  if (v12 >= 1)
  {
    while (1)
    {
      v14 = __ldxr((unint64_t *)v12);
      if ((v14 & 1) == 0)
        break;
      if ((v14 & 0x40000000000) != 0)
      {
        __clrex();
        goto LABEL_18;
      }
      if (!__stxr(v14 | 0x40000000000, (unint64_t *)v12))
        goto LABEL_18;
    }
    __clrex();
    v18 = -v12;
    *v16 |= 1uLL;
  }
LABEL_18:
  *location = v13;
  locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
  callSetWeaklyReferenced((uint64_t)v13);
  return v13;
}

void weak_unregister_no_lock(_QWORD *a1, unint64_t a2, const char *a3, char *a4)
{
  _QWORD *v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  const char *v18;
  uint64_t (*v19)(const char *, ...);
  unint64_t v20;
  uint64_t v22;

  if (a2)
  {
    v6 = weak_entry_for_referent(a1, a2, a3, a4);
    if (v6)
    {
      v10 = (uint64_t)v6;
      if ((v6[2] & 3) == 2)
      {
        v11 = 0;
        v12 = v6[3];
        v13 = (bswap64(0x8A970BE7488FDA55 * ((unint64_t)a3 ^ ((unint64_t)a3 >> 4))) ^ (1217387093 * (a3 ^ ((unint64_t)a3 >> 4)))) & v12;
        v14 = v6[1];
        v15 = v13;
        while (&a3[*(_QWORD *)(v14 + 8 * v15)])
        {
          v15 = (v15 + 1) & v12;
          if (v15 == v13)
            _objc_fatal("bad weak table at %p. This may be a runtime bug or a memory error somewhere else.", v7, v8, v9, v6);
          if ((unint64_t)++v11 > v6[4])
            goto LABEL_12;
        }
        *(_QWORD *)(v14 + 8 * v15) = 0;
        v20 = v6[2] - 4;
        v6[2] = v20;
      }
      else
      {
        v16 = 0;
        v17 = v6 + 1;
        do
        {
          if (!&a3[v17[v16]])
          {
            v17[v16] = 0;
            goto LABEL_21;
          }
          ++v16;
        }
        while (v16 != 4);
LABEL_12:
        if (DebugWeakErrors)
        {
          if (DebugWeakErrors == 2)
            v18 = "";
          else
            v18 = " Break on objc_weak_error to debug.";
          v19 = (uint64_t (*)(const char *, ...))_objc_inform;
          if (DebugWeakErrors == 2)
            v19 = (uint64_t (*)(const char *, ...))_objc_fatal;
          v6 = (_QWORD *)v19("Attempted to unregister unknown __weak variable at %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak().%s", a3, v18);
        }
        gdb_objc_class_changed(v6);
LABEL_21:
        v20 = *(_QWORD *)(v10 + 16);
      }
      if (v20 < 4 || (v20 & 3) != 2)
      {
        v22 = 8;
        while (!*(_QWORD *)(v10 + v22))
        {
          v22 += 8;
          if (v22 == 40)
          {
            weak_entry_remove((uint64_t)a1, v10);
            return;
          }
        }
      }
    }
  }
}

unint64_t weak_register_no_lock(char **a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v4;
  int v5;
  unint64_t v6;
  objc_object v8;
  void (*v9)(void);
  _QWORD *v10;
  const char *v11;
  char *v12;
  char *v13;
  char *v14;
  size_t v15;
  const char *ClassName;
  uint64_t v18;
  const char *v19;
  char *v20;
  _QWORD v21[5];

  v4 = a2;
  if (a2 < 1)
    return v4;
  v5 = (int)a4;
  v6 = a3;
  if (a4 <= 1)
  {
    v8.isa = *(Class *)a2;
    a3 = *(_QWORD *)a2 & 0xFFFFFFFF8;
    if ((*(_BYTE *)(a3 + 0x20) & 4) == 0)
    {
      v9 = lookUpImpOrForwardTryCache(a2, (unint64_t)sel_allowsWeakReference, (_QWORD *)a3, 0);
      if (v9 == _objc_msgForward)
        return 0;
      if ((((uint64_t (*)(unint64_t, char *))v9)(v4, sel_allowsWeakReference) & 1) != 0)
        goto LABEL_6;
LABEL_21:
      if (v5 == 1)
      {
        ClassName = object_getClassName((id)v4);
        _objc_fatal("Cannot form weak reference to instance (%p) of class %s. It is possible that this object was over-released, or is in the process of deallocation.", v18, v19, v20, v4, ClassName);
      }
      return 0;
    }
    if (((uint64_t)v8.isa & 1) != 0)
    {
      if (!((unint64_t)v8.isa >> 44))
        goto LABEL_21;
    }
    else if (objc_object::sidetable_isDeallocating((objc_object *)a2))
    {
      goto LABEL_21;
    }
  }
LABEL_6:
  v10 = weak_entry_for_referent(a1, v4, (const char *)a3, a4);
  if (v10)
  {
    append_referrer(v10, v6, v11, v12);
  }
  else
  {
    v21[0] = -(uint64_t)v4;
    v21[1] = -(uint64_t)v6;
    memset(&v21[2], 0, 24);
    v13 = a1[2];
    if (v13)
      v14 = v13 + 1;
    else
      v14 = 0;
    if ((unint64_t)a1[1] >= (unint64_t)(3 * (_QWORD)v14) >> 2)
    {
      if (v14)
        v15 = 2 * (_QWORD)v14;
      else
        v15 = 64;
      weak_resize(a1, v15);
    }
    weak_entry_insert(a1, (uint64_t)v21, v11, v12);
  }
  return v4;
}

_QWORD *weak_entry_for_referent(_QWORD *a1, unint64_t a2, const char *a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  if (!*a1)
    return 0;
  v4 = 0;
  v5 = a1[2];
  v6 = (bswap64(0x8A970BE7488FDA55 * (a2 ^ (a2 >> 4))) ^ (1217387093
                                                                        * (a2 ^ (a2 >> 4)))) & v5;
  v7 = v6;
  while (1)
  {
    v8 = (_QWORD *)(*a1 + 40 * v7);
    if (!(*v8 + a2))
      break;
    v7 = (v7 + 1) & v5;
    if (v7 == v6)
      _objc_fatal("bad weak table at %p. This may be a runtime bug or a memory error somewhere else.", a2, a3, a4, *a1);
    if ((unint64_t)++v4 > a1[3])
      return 0;
  }
  return v8;
}

uint64_t callSetWeaklyReferenced(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    if (result < 0)
    {
      result = objc_debug_taggedpointer_classes[result & 7];
      if ((__objc2_class *)result == __NSUnrecognizedTaggedPointer)
        result = objc_debug_taggedpointer_ext_classes[((unint64_t)v1 >> 55)];
    }
    else
    {
      result = *(_QWORD *)result & 0xFFFFFFFF8;
    }
    if ((*(_BYTE *)(result + 32) & 4) == 0 && (v1 < 1 || (*(_WORD *)((*(_QWORD *)v1 & 0xFFFFFFFF8) + 0x1E) & 4) == 0))
    {
      result = (uint64_t)class_getMethodImplementation((Class)result, sel__setWeaklyReferenced);
      if ((void (*)(void))result != _objc_msgForward)
        return ((uint64_t (*)(uint64_t, char *))result)(v1, sel__setWeaklyReferenced);
    }
  }
  return result;
}

IMP class_getMethodImplementation(Class cls, SEL name)
{
  IMP result;
  int v5;

  result = 0;
  if (cls && name)
  {
    v5 = *(_DWORD *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8);
    if ((v5 & 1) == 0)
      v5 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)cls & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    if ((v5 & 0x20000000) != 0
      && ((result = (IMP)cache_getImp((uint64_t)cls, (unint64_t)name, 0)) != 0
       || (*((_QWORD *)cls + 2) & 1) != 0
       && (result = (IMP)cache_getImp((uint64_t)cls + *(_QWORD *)((*((_QWORD *)cls + 2) & 0xFFFFFFFFFFFELL) - 16), (unint64_t)name, 0)) != 0))
    {
      if (result == _objc_msgForward_impcache)
        result = 0;
    }
    else
    {
      result = lookUpImpOrForward(0, (objc_selector *)name, cls, 7u);
    }
    if (!result)
      return _objc_msgForward;
  }
  return result;
}

void append_referrer(_QWORD *a1, unint64_t a2, const char *a3, char *a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  char *v10;
  uint64_t i;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if ((a1[2] & 3) == 2)
  {
    v6 = a1[3];
    v7 = a1[2] >> 2;
  }
  else
  {
    v8 = 0;
    v9 = a1 + 1;
    do
    {
      if (!v9[v8])
      {
        v9[v8] = -(uint64_t)a2;
        return;
      }
      ++v8;
    }
    while (v8 != 4);
    v10 = (char *)malloc_type_calloc(4uLL, 8uLL, 0x80040B8603338uLL);
    for (i = 0; i != 4; ++i)
      *(_QWORD *)&v10[i * 8] = v9[i];
    a1[1] = v10;
    *((_OWORD *)a1 + 1) = xmmword_1801358C0;
    a1[4] = 0;
    v7 = 4;
    v6 = 3;
  }
  if (v7 >= (unint64_t)(3 * v6 + 3) >> 2)
  {
    grow_refs_and_insert(a1, a2);
  }
  else
  {
    v12 = 0;
    v13 = (bswap64(0x8A970BE7488FDA55 * (a2 ^ (a2 >> 4))) ^ (1217387093
                                                                           * (a2 ^ (a2 >> 4)))) & v6;
    v14 = a1[1];
    v15 = v13;
    while (*(_QWORD *)(v14 + 8 * v15))
    {
      ++v12;
      v15 = (v15 + 1) & v6;
      if (v15 == v13)
        _objc_fatal("bad weak table at %p. This may be a runtime bug or a memory error somewhere else.", a2, a3, a4, a1);
    }
    if (v12 > a1[4])
      a1[4] = v12;
    *(_QWORD *)(v14 + 8 * v15) = -(uint64_t)a2;
    a1[2] += 4;
  }
}

unsigned int *locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::lockWith(unsigned int *result, unsigned int *a2)
{
  unsigned int *v3;
  unint64_t StatusReg;
  unsigned int v5;
  unsigned int v8;
  unsigned int v10;

  v3 = result;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  if (result < a2)
  {
    while (!__ldaxr(result))
    {
      if (!__stxr(v5, result))
        goto LABEL_9;
    }
    __clrex();
    result = (unsigned int *)os_unfair_lock_lock_with_options();
LABEL_9:
    v8 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(a2))
    {
      if (!__stxr(v8, a2))
        return result;
    }
LABEL_19:
    __clrex();
    return (unsigned int *)os_unfair_lock_lock_with_options();
  }
  while (!__ldaxr(a2))
  {
    if (!__stxr(v5, a2))
      goto LABEL_14;
  }
  __clrex();
  result = (unsigned int *)os_unfair_lock_lock_with_options();
LABEL_14:
  if (v3 != a2)
  {
    v10 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(v3))
    {
      if (!__stxr(v10, v3))
        return result;
    }
    goto LABEL_19;
  }
  return result;
}

void locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith(os_unfair_lock_t lock, os_unfair_lock_t a2)
{
  unint64_t StatusReg;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v6 = __ldxr(&lock->_os_unfair_lock_opaque);
    if (v6 != v5)
      break;
    if (!__stlxr(0, &lock->_os_unfair_lock_opaque))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock(lock);
LABEL_6:
  if (lock != a2)
  {
    v7 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v8 = __ldxr(&a2->_os_unfair_lock_opaque);
      if (v8 != v7)
        break;
      if (!__stlxr(0, &a2->_os_unfair_lock_opaque))
        return;
    }
    __clrex();
    os_unfair_lock_unlock(a2);
  }
}

_QWORD *weak_entry_insert(_QWORD *result, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;

  v4 = 0x8A970BE7488FDA55 * (-*(_QWORD *)a2 ^ (-*(_QWORD *)a2 >> 4));
  v5 = result[2];
  v6 = v5 & (bswap64(v4) ^ v4);
  v7 = *result + 40 * v6;
  v8 = *(_QWORD *)v7;
  if (*(_QWORD *)v7)
  {
    v8 = 0;
    v9 = v6;
    do
    {
      v9 = (v9 + 1) & v5;
      if (v9 == v6)
        _objc_fatal("bad weak table at %p. This may be a runtime bug or a memory error somewhere else.", a2, a3, a4, *result);
      ++v8;
      v7 = *result + 40 * v9;
    }
    while (*(_QWORD *)v7);
  }
  v10 = *(_OWORD *)a2;
  v11 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(v7 + 32) = *(_QWORD *)(a2 + 32);
  *(_OWORD *)v7 = v10;
  *(_OWORD *)(v7 + 16) = v11;
  ++result[1];
  if (v8 > result[3])
    result[3] = v8;
  return result;
}

void weak_entry_remove(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  if ((*(_QWORD *)(a2 + 16) & 3) == 2)
    free(*(void **)(a2 + 8));
  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 8) - 1;
  *(_QWORD *)(a1 + 8) = v5;
  if (v4)
    v6 = v4 + 1;
  else
    v6 = 0;
  if (v6 >= 0x400 && v6 >> 4 >= v5)
    weak_resize((char **)a1, v6 >> 3);
}

objc_object *objc_object::sidetable_retain(objc_object *this, char a2)
{
  int *v3;
  unsigned int v4;
  _QWORD *v6;
  int v7;
  unsigned int v8;
  uint64_t v10;

                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  if ((a2 & 1) == 0)
  {
    v4 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    while (!__ldaxr((unsigned int *)v3))
    {
      if (!__stxr(v4, (unsigned int *)v3))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
  }
LABEL_7:
  v10 = -(uint64_t)this;
  if ((*v6 & 0x8000000000000000) == 0)
    *v6 += 4;
  v7 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (1)
  {
    v8 = __ldxr((unsigned int *)v3);
    if (v8 != v7)
      break;
    if (!__stlxr(0, (unsigned int *)v3))
      return this;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)v3);
  return this;
}

_QWORD *objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::operator[](int32x2_t *a1, uint64_t *a2)
{
  char v4;
  _QWORD *inserted;
  _QWORD *v7;

  v7 = 0;
  inserted = v7;
  if ((v4 & 1) == 0)
  {
    *inserted = *a2;
    inserted[1] = 0;
  }
  return inserted + 1;
}

void grow_refs_and_insert(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  size_t v6;
  _QWORD *v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;

  v4 = a1[3];
  if (v4)
    v5 = v4 + 1;
  else
    v5 = 0;
  if (v5)
    v6 = 2 * v5;
  else
    v6 = 8;
  v7 = (_QWORD *)a1[1];
  v8 = a1[2];
  a1[3] = v6 - 1;
  v9 = malloc_type_calloc(v6, 8uLL, 0x80040B8603338uLL);
  v10 = a1[2] & 3;
  a1[1] = v9;
  a1[2] = v10;
  a1[4] = 0;
  if (v5)
    v11 = v8 >= 4;
  else
    v11 = 0;
  if (v11)
  {
    v12 = 0;
    v13 = v8 >> 2;
    do
    {
      v14 = v7[v12];
      if (v14)
      {
        append_referrer(a1, -v14);
        --v13;
      }
      ++v12;
    }
    while (v12 < v5 && v13);
    append_referrer(a1, a2);
    goto LABEL_19;
  }
  append_referrer(a1, a2);
  if (v7)
LABEL_19:
    free(v7);
}

uint64_t objc_object::sidetable_isDeallocating(objc_object *this)
{
  int *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;

                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  v2 = (uint64_t *)(v1 + 2);
  v7 = 0;
  {
    v3 = v7;
    v4 = *v2;
    v5 = v1[6];
  }
  else
  {
    v4 = *v2;
    v5 = v1[6];
    v3 = *v2 + 16 * v5;
  }
  if (v4 + 16 * v5 == v3)
    return 0;
  else
    return (*(unsigned __int8 *)(v3 + 8) >> 1) & 1;
}

_QWORD *objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::InsertIntoBucketImpl<DisguisedPtr<objc_object const>>(int32x2_t *a1, uint64_t *a2, _QWORD *a3)
{
  __int32 v5;
  unsigned int v6;
  _QWORD *v8;

  v8 = a3;
  v5 = a1[1].i32[0];
  v6 = a1[2].u32[0];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1].i32[1] > v6 >> 3)
  {
    goto LABEL_3;
  }
  a3 = v8;
LABEL_3:
  if (*a3 == 2)
  {
    a1[1] = vadd_s32(a1[1], (int32x2_t)0xFFFFFFFF00000001);
  }
  else if (-*a3 == -1)
  {
    ++a1[1].i32[0];
  }
  return a3;
}

void objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,`anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t *v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(uint64_t **)a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4)
    v8 = v7 + 1;
  else
    v8 = 4;
  *(_DWORD *)(a1 + 16) = v8;
  v9 = malloc_type_malloc(16 * v8, 0x64B88C75uLL);
  *(_QWORD *)a1 = v9;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
    {
      v11 = 16 * v10;
      do
      {
        *v9 = 1;
        v9 += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if ((_DWORD)v3)
    {
      v12 = 16 * v3;
      v13 = v4 + 1;
      do
      {
        if (*v13)
        {
          v14 = *(v13 - 1);
          if ((unint64_t)(v14 - 1) >= 2)
          {
            v19 = 0;
            v15 = v19;
            v16 = *v13;
            *v19 = *(v13 - 1);
            v15[1] = v16;
            ++*(_DWORD *)(a1 + 8);
          }
        }
        v13 += 2;
        v12 -= 16;
      }
      while (v12);
    }
    free(v4);
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    v17 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v17)
    {
      v18 = 16 * v17;
      do
      {
        *v9 = 1;
        v9 += 2;
        v18 -= 16;
      }
      while (v18);
    }
  }
}

void weak_resize(char **a1, size_t count)
{
  char *v4;
  char *v5;
  char *v6;
  const char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  char *v11;

  v4 = a1[2];
  v5 = *a1;
  v6 = (char *)malloc_type_calloc(count, 0x28uLL, 0x10A20404071C379uLL);
  a1[2] = (char *)(count - 1);
  a1[3] = 0;
  *a1 = v6;
  a1[1] = 0;
  if (v5)
  {
    if (v4)
      v9 = (uint64_t)(v4 + 1);
    else
      v9 = 0;
    if (v9 >= 1)
    {
      v10 = &v5[40 * v9];
      v11 = v5;
      do
      {
        if (*(_QWORD *)v11)
          weak_entry_insert(a1, (uint64_t)v11, v7, v8);
        v11 += 40;
      }
      while (v11 < v10);
    }
    free(v5);
  }
}

void _objc_fatal(char *a1, uint64_t a2, const char *a3, char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _objc_fatalv(a1, va, a3, a4);
}

void _objc_fatalv(char *a1, va_list a2, const char *a3, char *a4)
{
  pid_t v4;
  pid_t v5;
  char *v6;
  char *v7;
  char *v8;

  v8 = 0;
  vasprintf(&v8, a1, a2);
  v7 = 0;
  v4 = getpid();
  asprintf(&v7, "objc[%d]: %s\n", v4, v8);
  _objc_syslog(v7);
  if (!DebugDontCrash)
  {
    _objc_crashlog(v8);
    abort_with_reason();
  }
  v6 = 0;
  v5 = getpid();
  asprintf(&v6, "objc[%d]: HALTED\n", v5);
  _objc_syslog(v6);
  _Exit(1);
}

id objc_storeWeakOrNil(id *location, id obj)
{
  __objc2_class *v4;
  int *v5;
  uint64_t v6;
  id v7;
  int *v8;
  char *v9;
  __objc2_class *v10;
  int v11;
  int64_t v12;
  void *v13;
  unint64_t v14;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;

  v4 = 0;
                                           * (unint64_t)(((obj >> 4) ^ (obj >> 9)) & 7)];
  v17 = obj & 7;
  v6 = ((unint64_t)obj >> 55);
  while (1)
  {
    while (1)
    {
      v7 = *location;
                                               * (unint64_t)(((*location >> 4) ^ (*location >> 9)) & 7)];
      locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::lockWith((unsigned int *)v8, (unsigned int *)v5);
      if (*location == v7)
        break;
      locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
    }
    if (!obj)
      break;
    if (((unint64_t)obj & 0x8000000000000000) != 0)
    {
      v10 = (__objc2_class *)objc_debug_taggedpointer_classes[v17];
      if (v10 == __NSUnrecognizedTaggedPointer)
        v10 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[v6];
    }
    else
    {
      v10 = (__objc2_class *)(*(_QWORD *)obj & 0xFFFFFFFF8);
    }
    if (v10 == v4)
      break;
    v11 = *(_DWORD *)((uint64_t)v10->info & 0xF00007FFFFFFFF8);
    if ((v11 & 1) == 0)
      v11 = *(_DWORD *)(*(_QWORD *)(((uint64_t)v10->isa & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    if ((v11 & 0x20000000) != 0)
      break;
    locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
    class_initialize(v10, (objc_object *)obj);
    v4 = v10;
  }
  weak_unregister_no_lock((_QWORD *)v8 + 4, (unint64_t)v7, (const char *)location, v9);
  v12 = weak_register_no_lock((char **)v5 + 4, (uint64_t)obj, (uint64_t)location, 0);
  v13 = (void *)v12;
  if (v12 >= 1)
  {
    while (1)
    {
      v14 = __ldxr((unint64_t *)v12);
      if ((v14 & 1) == 0)
        break;
      if ((v14 & 0x40000000000) != 0)
      {
        __clrex();
        goto LABEL_18;
      }
      if (!__stxr(v14 | 0x40000000000, (unint64_t *)v12))
        goto LABEL_18;
    }
    __clrex();
    v18 = -v12;
    *v16 |= 1uLL;
  }
LABEL_18:
  *location = v13;
  locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
  callSetWeaklyReferenced((uint64_t)v13);
  return v13;
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  char *v1;
  char *v2;
  uint64_t v3;
  unint64_t StatusReg;
  uint64_t *v6;
  _DWORD *v7;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = *(uint64_t **)(StatusReg + 352);
  if (v6 != (uint64_t *)-1)
  {
    v7 = *(_DWORD **)(StatusReg + 360);
    if ((unint64_t)v6 > 3 || v7 != 0)
    {
      *(_QWORD *)(StatusReg + 352) = 0;
      *(_QWORD *)(StatusReg + 360) = 0;
      if (v3 - (_QWORD)v7 == 8 || *v7 == -1440939011)
      {
        if ((v6 & 1) != 0)
          return a1;
      }
      else if ((v6 & 1) != 0)
      {
        moveTLSAutoreleaseToPool(v6, (uint64_t)v7, v1, v2);
      }
    }
  }
  return a1;
}

id objc_claimAutoreleasedReturnValue(id a1, uint64_t a2, char *a3, char *a4)
{
  uint64_t v4;
  unint64_t StatusReg;
  uint64_t *v7;
  uint64_t v8;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *(uint64_t **)(StatusReg + 352);
  if (v7 != (uint64_t *)-1)
  {
    v8 = *(_QWORD *)(StatusReg + 360);
    if ((unint64_t)v7 > 3 || v8 != 0)
    {
      *(_QWORD *)(StatusReg + 352) = 0;
      *(_QWORD *)(StatusReg + 360) = 0;
      if (v4 - v8 == 4)
      {
        if ((v7 & 1) != 0)
          return a1;
      }
      else if ((v7 & 1) != 0)
      {
        moveTLSAutoreleaseToPool(v7, v8, a3, a4);
      }
    }
  }
  return a1;
}

objc_object *_objc_rootAutorelease(objc_object *this, uint64_t a2, char *a3, char *a4)
{
  uint64_t v4;
  Class isa;
  unint64_t StatusReg;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  int v12;

  if (((unint64_t)this & 0x8000000000000000) != 0)
    return this;
  isa = this->isa;
  if (((uint64_t)this->isa & 1) != 0)
  {
    if (!((unint64_t)isa >> 44))
      return this;
  }
  else if ((*(_WORD *)(((unint64_t)isa & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0
         && (objc_object::sidetable_isDeallocating(this) & 1) != 0)
  {
    return this;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v9 = *(uint64_t **)(StatusReg + 352);
  if (v9 == (uint64_t *)-1)
  {
    v10 = (uint64_t)this->isa & 0xFFFFFFFF8;
  }
  else
  {
    moveTLSAutoreleaseToPool(v9, *(_QWORD *)(StatusReg + 360), a3, a4);
    if ((uint64_t)this <= 0)
    {
      *(_QWORD *)(StatusReg + 352) = 0;
      *(_QWORD *)(StatusReg + 360) = 0;
      return this;
    }
    v10 = (uint64_t)this->isa & 0xFFFFFFFF8;
    v11 = *(_DWORD *)(*(_QWORD *)(v10 + 0x20) & 0xF00007FFFFFFFF8);
    v12 = v11;
    if ((v11 & 1) == 0)
      v12 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)v10 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    if ((v12 & 0x20000000) != 0)
      goto LABEL_13;
    if (v11 < 0 && (unint64_t)(*(_QWORD *)v10 - 16) <= 0xFFFFFFFFFFFFFFF0)
    {
      class_initialize((__objc2_class *)v10, this);
LABEL_13:
      *(_QWORD *)(StatusReg + 352) = (unint64_t)this | 3;
      *(_QWORD *)(StatusReg + 360) = v4;
      return this;
    }
  }
  if ((*(_WORD *)(v10 + 30) & 4) == 0)
    objc_object::rootAutorelease2(this, a2, a3, a4);
  return this;
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  char *v1;
  char *v2;
  _DWORD *v3;
  unint64_t StatusReg;
  uint64_t *v6;
  _DWORD *v7;
  __objc2_class *v8;
  __objc2_class_ro *info;
  int v10;
  int v11;
  unint64_t v12;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = *(uint64_t **)(StatusReg + 352);
  if (v6 == (uint64_t *)-1)
    return objc_retainAutoreleaseAndReturn((objc_object *)a1);
  v7 = v3;
  moveTLSAutoreleaseToPool(v6, *(_QWORD *)(StatusReg + 360), v1, v2);
  if ((uint64_t)a1 < 1)
  {
    v12 = 0;
    v7 = 0;
    goto LABEL_10;
  }
  v8 = (__objc2_class *)(*(_QWORD *)a1 & 0xFFFFFFFF8);
  info = v8->info;
  v10 = *(_DWORD *)((unint64_t)info & 0xF00007FFFFFFFF8);
  v11 = v10;
  if ((v10 & 1) == 0)
    v11 = *(_DWORD *)(*(_QWORD *)(((uint64_t)v8->isa & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v11 & 0x20000000) != 0)
  {
    if ((info & 4) != 0)
    {
LABEL_8:
      v12 = (unint64_t)a1 & 0xFFFFFFFFFFFFFFFCLL | 1;
LABEL_10:
      *(_QWORD *)(StatusReg + 352) = v12;
      *(_QWORD *)(StatusReg + 360) = v7;
      return a1;
    }
  }
  else
  {
    if ((v10 & 0x80000000) == 0 || (unint64_t)&v8->isa[-1].vtable > 0xFFFFFFFFFFFFFFF0)
      return objc_retainAutoreleaseAndReturn((objc_object *)a1);
    class_initialize(v8, (objc_object *)a1);
    if ((*(_QWORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x20) & 4) != 0)
      goto LABEL_8;
  }
  if (*v3 == -1440939011)
    goto LABEL_8;
  return objc_retainAutoreleaseAndReturn((objc_object *)a1);
}

id objc_autoreleaseReturnValue(id a1)
{
  char *v1;
  char *v2;
  _DWORD *v3;
  unint64_t StatusReg;
  uint64_t *v6;
  __objc2_class *v7;
  __objc2_class_ro *info;
  int v9;
  int v10;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = *(uint64_t **)(StatusReg + 352);
  if (v6 == (uint64_t *)-1)
    return a1;
  moveTLSAutoreleaseToPool(v6, *(_QWORD *)(StatusReg + 360), v1, v2);
  if ((uint64_t)a1 <= 0)
  {
    *(_QWORD *)(StatusReg + 352) = 0;
    *(_QWORD *)(StatusReg + 360) = 0;
    return a1;
  }
  v7 = (__objc2_class *)(*(_QWORD *)a1 & 0xFFFFFFFF8);
  info = v7->info;
  v9 = *(_DWORD *)((unint64_t)info & 0xF00007FFFFFFFF8);
  v10 = v9;
  if ((v9 & 1) == 0)
    v10 = *(_DWORD *)(*(_QWORD *)(((uint64_t)v7->isa & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v10 & 0x20000000) != 0)
  {
    if ((info & 4) != 0)
    {
LABEL_8:
      *(_QWORD *)(StatusReg + 352) = (unint64_t)a1 & 0xFFFFFFFFFFFFFFFCLL | 1;
      *(_QWORD *)(StatusReg + 360) = v3;
      return a1;
    }
  }
  else
  {
    if ((v9 & 0x80000000) == 0 || (unint64_t)&v7->isa[-1].vtable > 0xFFFFFFFFFFFFFFF0)
      return a1;
    class_initialize(v7, (objc_object *)a1);
    if ((*(_QWORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x20) & 4) != 0)
      goto LABEL_8;
  }
  if (*v3 == -1440939011)
    goto LABEL_8;
  return a1;
}

uint64_t *moveTLSAutoreleaseToPool(uint64_t *result, uint64_t a2, char *a3, char *a4)
{
  objc_object *v4;
  _QWORD *StatusReg;
  AutoreleasePoolPage *v6;
  unint64_t v7;

  v4 = (objc_object *)((unint64_t)result & 0xFFFFFFFFFFFFFFFCLL);
  if (((unint64_t)result & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    StatusReg = (_QWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    if ((result & 2) != 0)
    {
      v6 = (AutoreleasePoolPage *)StatusReg[43];
      if ((unint64_t)v6 >= 2)
      {
        if (*(_DWORD *)v6 != -1583242847)
          AutoreleasePoolPage::busted_die(v6, (uint64_t)v4, a3, a4);
        if (*((AutoreleasePoolPage **)v6 + 2) == (AutoreleasePoolPage *)((char *)v6 + 4096))
          result = AutoreleasePoolPage::autoreleaseFullPage((objc_object *)((unint64_t)result & 0xFFFFFFFFFFFFFFFCLL), (objc_object *)v6, (AutoreleasePoolPage *)a3, a4);
        else
          result = AutoreleasePoolPage::add(v6, (uint64_t)v4);
      }
      else
      {
        result = (uint64_t *)AutoreleasePoolPage::autoreleaseNoPage((id)((unint64_t)result & 0xFFFFFFFFFFFFFFFCLL), v4);
      }
    }
    else
    {
      StatusReg[44] = -1;
      StatusReg[45] = 0;
      result = v4;
    }
  }
  v7 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  *(_QWORD *)(v7 + 352) = 0;
  *(_QWORD *)(v7 + 360) = 0;
  return result;
}

id objc_autorelease(id a1)
{
  objc_object *v1;
  char *v2;
  char *v3;
  uint64_t v4;
  unint64_t v6;
  unint64_t StatusReg;
  uint64_t v8;
  objc_object *v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  int v13;

  if ((uint64_t)a1 < 1)
    return a1;
  v6 = *(_QWORD *)a1;
  if ((*(_BYTE *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x20) & 4) != 0)
  {
    if ((v6 & 1) != 0)
    {
      if (!(v6 >> 44))
        return a1;
    }
    else if ((*(_WORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0
           && (objc_object::sidetable_isDeallocating((objc_object *)a1) & 1) != 0)
    {
      return a1;
    }
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v8 = *(_QWORD *)(StatusReg + 352);
    if (v8 == -1)
    {
      v10 = *(_QWORD *)a1 & 0xFFFFFFFF8;
    }
    else
    {
      v1 = (objc_object *)(v8 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v8 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        if ((v8 & 2) != 0)
        {
          v11 = *(_QWORD *)(StatusReg + 344);
          if (v11 >= 2)
          {
            if (*(_DWORD *)v11 != -1583242847)
              AutoreleasePoolPage::busted_die(*(AutoreleasePoolPage **)(StatusReg + 344), (uint64_t)v1, v2, v3);
            if (*(_QWORD *)(v11 + 16) == v11 + 4096)
              AutoreleasePoolPage::autoreleaseFullPage(v1, *(objc_object **)(StatusReg + 344), (AutoreleasePoolPage *)v2, v3);
            else
              AutoreleasePoolPage::add(*(AutoreleasePoolPage **)(StatusReg + 344), (uint64_t)v1);
          }
          else
          {
            AutoreleasePoolPage::autoreleaseNoPage(v1, v1);
          }
        }
        else
        {
          *(_QWORD *)(StatusReg + 352) = -1;
          *(_QWORD *)(StatusReg + 360) = 0;
          v9 = v1;
        }
      }
      *(_QWORD *)(StatusReg + 352) = 0;
      *(_QWORD *)(StatusReg + 360) = 0;
      v10 = *(_QWORD *)a1 & 0xFFFFFFFF8;
      v12 = *(_DWORD *)(*(_QWORD *)(v10 + 0x20) & 0xF00007FFFFFFFF8);
      v13 = v12;
      if ((v12 & 1) == 0)
        v13 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)v10 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
      if ((v13 & 0x20000000) != 0)
        goto LABEL_24;
      if (v12 < 0 && (unint64_t)(*(_QWORD *)v10 - 16) <= 0xFFFFFFFFFFFFFFF0)
      {
        class_initialize((__objc2_class *)v10, (objc_object *)a1);
LABEL_24:
        *(_QWORD *)(StatusReg + 352) = (unint64_t)a1 | 3;
        *(_QWORD *)(StatusReg + 360) = v4;
        return a1;
      }
    }
    if ((*(_WORD *)(v10 + 30) & 4) == 0)
      objc_object::rootAutorelease2((objc_object *)a1, (uint64_t)v1, v2, v3);
    return a1;
  }
  return objc_msgSend(a1, sel_autorelease);
}

uint64_t *AutoreleasePoolPage::add(AutoreleasePoolPage *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t *result;
  BOOL v5;
  uint64_t *v6;
  BOOL v7;
  char v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t v15;

  v2 = a2;
  result = (uint64_t *)*((_QWORD *)this + 2);
  if (DisableAutoreleaseCoalescing)
    v5 = DisableAutoreleaseCoalescingLRU == 0;
  else
    v5 = 1;
  if (v5)
  {
    v6 = (uint64_t *)((char *)this + 56);
    if (a2)
      v7 = result == v6;
    else
      v7 = 1;
    v8 = v7;
    if (DisableAutoreleaseCoalescingLRU)
    {
      if ((v8 & 1) == 0)
      {
        v9 = *(result - 1);
        if ((v9 & 0xF00FFFFFFFFFFFFLL) == a2)
        {
          v10 = (v9 >> 44) & 0xFF0 | (v9 >> 60);
          if (v10 != 4095)
          {
            *--result = ((v10 + 1) << 44) & 0xFF000000000000 | ((v10 + 1) << 60) | a2;
            return result;
          }
        }
      }
    }
    else if ((v8 & 1) == 0)
    {
      v11 = 0;
      v12 = result - 1;
      v13 = result - 1;
      do
      {
        if (v13 <= v6)
          break;
        v14 = *v13;
        if (!*v13)
          break;
        if ((v14 & 0xF00FFFFFFFFFFFFLL) == a2)
        {
          v15 = (v14 >> 44) & 0xFF0 | (v14 >> 60);
          if (v15 != 4095)
          {
            if (v11)
            {
              memmove(v13, v13 + 1, 8 * v11);
            }
            else
            {
              v15 = ((unint64_t)*v12 >> 44) & 0xFF0 | ((unint64_t)*v12 >> 60);
              v2 = *v12 & 0xF00FFFFFFFFFFFFLL;
            }
            *v12 = v2 | ((v15 + 1) << 44) & 0xFF000000000000 | ((v15 + 1) << 60);
            return v12;
          }
        }
        ++v11;
        --v13;
      }
      while (v11 != 4);
    }
  }
  *((_QWORD *)this + 2) = result + 1;
  *result = a2;
  return result;
}

objc_object *objc_object::rootAutorelease2(objc_object *this, uint64_t a2, char *a3, char *a4)
{
  AutoreleasePoolPage *v5;

  v5 = *(AutoreleasePoolPage **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 344);
  if ((unint64_t)v5 >= 2)
  {
    if (*(_DWORD *)v5 != -1583242847)
      AutoreleasePoolPage::busted_die(v5, (uint64_t)v5, a3, a4);
    if (*((AutoreleasePoolPage **)v5 + 2) == (AutoreleasePoolPage *)((char *)v5 + 4096))
      AutoreleasePoolPage::autoreleaseFullPage(this, (objc_object *)v5, (AutoreleasePoolPage *)a3, a4);
    else
      AutoreleasePoolPage::add(v5, (uint64_t)this);
  }
  else
  {
    AutoreleasePoolPage::autoreleaseNoPage(this, (objc_object *)v5);
  }
  return this;
}

uint64_t AutoreleasePoolPage::autoreleaseNoPage(id this, objc_object *a2)
{
  unint64_t StatusReg;
  uint64_t v4;
  uint64_t result;
  AutoreleasePoolPage *v6;
  const char *v7;
  char *v8;
  uint64_t v9;
  const char *v10;
  char *v11;
  _QWORD *v12;
  const void *v13;
  const char *ClassName;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  char *v18;
  void *memptr;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v4 = *(_QWORD *)(StatusReg + 344);
  if (v4 == 1)
  {
LABEL_7:
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x1000uLL, 0x1000uLL, 0x778FB154uLL);
    v6 = (AutoreleasePoolPage *)memptr;
    AutoreleasePoolPage::AutoreleasePoolPage((AutoreleasePoolPage *)memptr, 0, v7, v8);
    if (v6 && *(_DWORD *)v6 != -1583242847)
      AutoreleasePoolPage::busted_die(v6, v9, v10, v11);
    *(_QWORD *)(StatusReg + 344) = v6;
    if (v4 == 1)
    {
      v12 = (_QWORD *)*((_QWORD *)v6 + 2);
      *((_QWORD *)v6 + 2) = v12 + 1;
      *v12 = 0;
    }
    return (uint64_t)AutoreleasePoolPage::add(v6, (uint64_t)this);
  }
  if (!this || !DebugMissingPools)
  {
    if (!this && !DebugPoolAllocation)
    {
      result = 1;
      *(_QWORD *)(StatusReg + 344) = 1;
      return result;
    }
    goto LABEL_7;
  }
  v13 = *(const void **)StatusReg;
  ClassName = object_getClassName(this);
  _objc_inform("MISSING POOLS: (%p) Object %p of class %s autoreleased with no pool in place - just leaking - break on objc_autoreleaseNoPool() to debug", v13, this, ClassName);
  gdb_objc_class_changed(v15);
  if (DebugMissingPools == 2)
    _objc_fatal("Missing pools are a fatal error", v16, v17, v18);
  return 0;
}

void sub_180106904(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void AutoreleasePoolPage::AutoreleasePoolPage(AutoreleasePoolPage *this, AutoreleasePoolPage *a2, const char *a3, char *a4)
{
  AutoreleasePoolPage *v4;
  uint64_t *StatusReg;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v11;

  v4 = a2;
  StatusReg = (uint64_t *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *StatusReg;
  if (a2)
  {
    v8 = *((_DWORD *)a2 + 13);
    v9 = *((_DWORD *)a2 + 12) + 1;
  }
  else
  {
    v9 = 0;
    v8 = 0;
  }
  *((_DWORD *)this + 3) = 558191425;
  *(_DWORD *)this = -1583242847;
  *(_QWORD *)((char *)this + 4) = *(_QWORD *)"AUTORELEASE!";
  *((_QWORD *)this + 2) = (char *)this + 56;
  *((_QWORD *)this + 3) = v7;
  *((_QWORD *)this + 4) = a2;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = v9;
  *((_DWORD *)this + 13) = v8;
  if (objc::PageCountWarning != -1)
  {
    {
      if (DisableFaults
        || getpid() == 1
        || (is_root_ramdisk() & 1) != 0
        || !os_variant_has_internal_diagnostics())
      {
        _dyld_get_image_uuid();
        if ((_dyld_get_shared_cache_uuid() & 1) != 0)
          _dyld_get_shared_cache_range();
        _os_log_simple();
      }
      else
      {
        os_fault_with_payload();
      }
      do
    }
    v4 = (AutoreleasePoolPage *)*((_QWORD *)this + 4);
  }
  if (v4)
  {
    if (*(_DWORD *)v4 != -1583242847
      || strncmp((const char *)v4 + 4, "AUTORELEASE!", 0xCuLL)
      || *((_QWORD *)v4 + 3) != *StatusReg)
    {
      AutoreleasePoolPage::busted_die(v4, (uint64_t)a2, a3, a4);
    }
    *((_QWORD *)v4 + 5) = this;
  }
}

void sub_180106B1C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = 0;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

uint64_t *AutoreleasePoolPage::autoreleaseFullPage(objc_object *this, objc_object *a2, AutoreleasePoolPage *a3, char *a4)
{
  objc_object *v4;
  objc_object *isa;
  const char *v7;
  char *v8;
  void *memptr;

  v4 = a2;
  do
  {
    isa = (objc_object *)v4[5].isa;
    if (!isa)
    {
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x1000uLL, 0x1000uLL, 0x778FB154uLL);
      isa = (objc_object *)memptr;
      AutoreleasePoolPage::AutoreleasePoolPage((AutoreleasePoolPage *)memptr, (AutoreleasePoolPage *)v4, v7, v8);
    }
    v4 = isa;
  }
  while ((objc_object *)isa[2].isa == &isa[512]);
  if (LODWORD(isa->isa) != -1583242847)
    AutoreleasePoolPage::busted_die((AutoreleasePoolPage *)isa, (uint64_t)a2, (const char *)a3, a4);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 344) = isa;
  return AutoreleasePoolPage::add((AutoreleasePoolPage *)isa, (uint64_t)this);
}

void sub_180106BD8(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

__objc2_class *class_initialize(__objc2_class *a1, objc_object *a2)
{
  unsigned int v4;

  v4 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v4, runtimeLock))
      return initializeAndMaybeRelock(a1, a2, 0);
  }
  __clrex();
  os_unfair_lock_lock_with_options();
  return initializeAndMaybeRelock(a1, a2, 0);
}

uint64_t is_root_ramdisk()
{
  uint64_t result;
  char v1;
  char v2;
  char v3;

  if ((os_parse_boot_arg_string() & 1) != 0 || (result = os_parse_boot_arg_string(), (_DWORD)result))
  {
    result = 0;
    if (v1 == 109 && v2 == 100)
      return v3 == 0;
  }
  return result;
}

void objc_registerProtocol(Protocol *proto)
{
  const char *v1;
  char *v2;
  unint64_t StatusReg;
  unsigned int v5;
  __objc2_class *v7;
  int v8;
  unsigned int v9;
  uint64_t (***v10)(_QWORD);

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v5, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v7 = (__objc2_class *)((uint64_t)proto->super.isa & 0xFFFFFFFF8);
  if (v7 == Protocol)
  {
    protocol_t::demangledName((char **)proto);
    _objc_inform("objc_registerProtocol: protocol '%s' was already registered!");
  }
  else if (v7 == __IncompleteProtocol)
  {
    objc_object::changeIsa((objc_object *)proto, (uint64_t)Protocol, v1, v2);
    if (!getProtocol((const char *)proto[1].super.isa))
    {
      v10 = (uint64_t (***)(_QWORD))protocols();
      NXMapKeyCopyingInsert(v10, (const char *)proto[1].super.isa, (uint64_t)proto);
    }
  }
  else
  {
    protocol_t::demangledName((char **)proto);
    _objc_inform("objc_registerProtocol: protocol '%s' was not allocated with objc_allocateProtocol!");
  }
  v8 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v9 = __ldxr(runtimeLock);
    if (v9 != v8)
      break;
    if (!__stlxr(0, runtimeLock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
}

void sub_180106E24(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t objc_object::changeIsa(objc_object *this, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v6;
  char v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  __int16 v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  os_unfair_lock_s *v18;
  int v19;
  unsigned int v20;
  uint64_t v22;

  v6 = 0;
  v7 = 0;
  v8 = __ldxr((unint64_t *)this);
  v9 = a2 & 0xFFFFFFF000000007;
  v10 = a2 & 0xFFFFFFFF8;
  if (v8)
    goto LABEL_2;
  while (1)
  {
LABEL_3:
    if ((unint64_t)(*(_QWORD *)a2 - 1) < 0xF
      || (*(_BYTE *)((*(_QWORD *)(a2 + 32) & 0xF00007FFFFFFFF8) + 3) & 0x40) == 0)
    {
      v11 = *(_WORD *)(a2 + 30);
      if ((v11 & 0x2000) == 0)
      {
        if (!v9)
        {
          v12 = v8 & 0xFFFFFFF000000003;
          if (!v8)
            v12 = 0x21A000000001;
          v13 = v12 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v11 & 1));
          goto LABEL_13;
        }
LABEL_34:
        _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", a2, a3, a4, a2);
      }
    }
    if ((v8 & 1) != 0)
      break;
    while (1)
    {
      if (v9)
        goto LABEL_34;
      v13 = v6 & 0xFFFFFFF000000007;
LABEL_13:
      v6 = v13 | v10;
      if (!__stxr(v13 | v10, (unint64_t *)this))
      {
        if ((v7 & 1) == 0)
          return v8 & 0xFFFFFFFF8;
        v14 = ((this >> 4) ^ (this >> 9)) & 7;
        goto LABEL_28;
      }
LABEL_14:
      v8 = __ldxr((unint64_t *)this);
      if (!v8)
        break;
LABEL_2:
      if ((v8 & 1) != 0)
        goto LABEL_3;
    }
  }
  if ((v7 & 1) == 0)
    objc_object::sidetable_lock(this);
  if (v9)
    goto LABEL_34;
  v6 = v6 & 0xFFFFFFF000000007 | v10;
  if (__stxr(v6, (unint64_t *)this))
  {
    v7 = 1;
    goto LABEL_14;
  }
  v14 = ((this >> 4) ^ (this >> 9)) & 7;
  v22 = -(uint64_t)this;
  v16 = ((v8 >> 43) & 0x1FFFFC) - 4;
  v17 = *v15 + v16;
  if (__CFADD__(*v15, v16))
    v17 = 0x8000000000000000;
  if (!(v8 >> 44))
    v17 |= 2uLL;
  *v15 = v17 | (v8 >> 42) & 1;
LABEL_28:
  v19 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (1)
  {
    v20 = __ldxr(&v18->_os_unfair_lock_opaque);
    if (v20 != v19)
      break;
    if (!__stlxr(0, &v18->_os_unfair_lock_opaque))
      return v8 & 0xFFFFFFFF8;
  }
  __clrex();
  os_unfair_lock_unlock(v18);
  return v8 & 0xFFFFFFFF8;
}

Class object_setClass(Class result, Class a2)
{
  const char *v2;
  char *v3;
  objc_object *v5;
  int v6;

  if (result)
  {
    v5 = (objc_object *)result;
    v6 = *(_DWORD *)(*((_QWORD *)a2 + 4) & 0xF00007FFFFFFFF8);
    if ((unint64_t)(*(_QWORD *)a2 - 1) < 0xF || (v6 & 0x40000000) == 0)
    {
      if ((v6 & 1) == 0)
        v6 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)a2 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
      if ((v6 & 0x20000000) == 0)
        lookUpImpOrNilTryCache(0, (unint64_t)sel_initialize, a2, 1);
    }
    return (Class)objc_object::changeIsa(v5, (uint64_t)a2, v2, v3);
  }
  return result;
}

uint64_t NXMapKeyCopyingInsert(uint64_t (***a1)(_QWORD), const char *a2, uint64_t a3)
{
  unsigned int v6;
  void *v7;
  size_t v8;
  unsigned int v9;
  uint64_t v11;

  v6 = (**a1)(a1);
  v7 = (void *)_NXMapMemberWithHash((uint64_t)a1, (uint64_t)a2, v6, &v11);
  if (v7 == (void *)-1)
  {
    v8 = strlen(a2) + 1;
    if ((_dyld_is_memory_immutable() & 1) != 0)
    {
      v7 = (void *)a2;
    }
    else
    {
      v7 = malloc_type_malloc(v8, 0x3F84A03uLL);
      memcpy(v7, a2, v8);
    }
  }
  v9 = ((uint64_t (*)(uint64_t (***)(_QWORD), void *))**a1)(a1, v7);
  return NXMapInsertWithHash((uint64_t)a1, (uint64_t)v7, v9, a3);
}

unint64_t sel_hash(unint64_t a1)
{
  return a1 ^ (a1 >> 7);
}

uint64_t __getPreoptimizedProtocol_block_invoke(uint64_t result, uint64_t a2, int a3, _BYTE *a4)
{
  if (a3)
  {
    **(_QWORD **)(result + 32) = a2;
    *a4 = 1;
  }
  return result;
}

SEL sel_getUid(const char *str)
{
  return (SEL)__sel_registerName((char *)str, 1, 1);
}

SEL method_getName(SEL m)
{
  int v1;
  int *v2;

  if (m)
  {
    v1 = m & 3;
    if ((m & 3) == 0 || v1 == 2)
    {
      return *(SEL *)((unint64_t)m & 0xFFFFFFFFFFFFFFFCLL);
    }
    else if (v1 == 1)
    {
      v2 = (int *)((unint64_t)m & 0xFFFFFFFFFFFFFFFCLL);
      if (dataSegmentsRanges > ((unint64_t)m & 0xFFFFFFFFFFFFFFFCLL)
        || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v2)
      {
        return *(SEL *)((char *)v2 + *v2);
      }
      else
      {
        return (char *)&unk_1F25805A8 + *v2;
      }
    }
  }
  return m;
}

BOOL sel_isEqual(SEL lhs, SEL rhs)
{
  return lhs == rhs;
}

uint64_t readClass(objc_class *a1, int a2, char a3)
{
  unint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  unint64_t i;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  const char *v21;
  char *v22;
  uint64_t v23;
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  BOOL j;
  unint64_t v33;
  unint64_t v34;
  char *v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  char *v49;
  uint64_t v50;
  const char *v51;
  char *v52;
  uint64_t v53;

  v5 = (unint64_t)a1;
  v6 = *((_QWORD *)a1 + 4);
  v7 = (_QWORD *)(v6 & 0xF00007FFFFFFFF8);
  if (v6 < 0)
  {
    v8 = *(_QWORD *)((v6 & 0xF00007FFFFFFFF8) + 8);
    v7 = (_QWORD *)(v8 & 0xFFFFFFFFFFFFFFFELL);
    if ((v8 & 1) != 0)
      v7 = (_QWORD *)*v7;
  }
  v9 = (char *)atomic_load(v7 + 3);
  for (i = *((_QWORD *)a1 + 1); i; i = *((_QWORD *)a1 + 1))
  {
    a1 = (objc_class *)remapClass(i);
    if (!a1)
      goto LABEL_13;
    if ((unint64_t)(*(_QWORD *)a1 - 1) >= 0xF
      && (*(_DWORD *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
    {
      goto LABEL_16;
    }
  }
  v11 = *((_QWORD *)a1 + 4);
  v12 = (_QWORD *)(v11 & 0xF00007FFFFFFFF8);
  if (v11 < 0)
  {
    v13 = *(_QWORD *)((v11 & 0xF00007FFFFFFFF8) + 8);
    v12 = (_QWORD *)(v13 & 0xFFFFFFFFFFFFFFFELL);
    if ((v13 & 1) != 0)
      v12 = (_QWORD *)*v12;
  }
  if ((*(_BYTE *)v12 & 2) == 0)
  {
LABEL_13:
    if (PrintConnecting)
    {
      v35 = objc_class::nameForLogging((objc_class *)v5);
      _objc_inform("CLASS: IGNORING class '%s' with missing weak-linked superclass", v35);
    }
    addRemappedClass((objc_class *)v5, 0);
    v14 = 0;
    *(_QWORD *)(v5 + 8) = 0;
    return v14;
  }
LABEL_16:
  v15 = *(_QWORD *)(v5 + 32);
  if ((v15 & 1) != 0 && (*(_BYTE *)(v5 + 40) & 1) == 0)
    *(_QWORD *)(v5 + 32) = v15 & 0xFFFFFFFFFFFFFFFCLL | 2;
  if (v9)
  {
    v16 = future_named_class_map;
    if (future_named_class_map)
    {
      v17 = (**(uint64_t (***)(uint64_t, char *))future_named_class_map)(future_named_class_map, v9);
      v18 = _NXMapMemberWithHash(v16, (uint64_t)v9, v17, &v53);
      if (v18 != -1)
      {
        v19 = (char *)v18;
        v14 = NXMapRemove(v16, v18);
        strlen(v19);
        if ((_dyld_is_memory_immutable() & 1) == 0)
          free(v19);
        if (v14)
        {
          if (!*(_DWORD *)(future_named_class_map + 8))
          {
            NXFreeMapTable((_QWORD *)future_named_class_map);
            future_named_class_map = 0;
          }
          v24 = (unint64_t *)(v14 + 32);
          v23 = *(_QWORD *)(v14 + 32);
          if ((v23 & 3) != 0)
          {
            v49 = objc_class::nameForLogging((objc_class *)v5);
            _objc_fatal("Can't complete future class request for '%s' because the real class is too big.", v50, v51, v52, v49);
          }
          v25 = v23 & 0xF00007FFFFFFFF8;
          v26 = *(_QWORD *)(v25 + 8);
          v27 = (_QWORD *)(v26 & 0xFFFFFFFFFFFFFFFELL);
          if ((v26 & 1) != 0)
            v27 = (_QWORD *)*v27;
          *(_QWORD *)(v14 + 8) = *(_QWORD *)(v5 + 8);
          if ((v5 & 0x8000000000000000) != 0)
          {
            v28 = objc_debug_taggedpointer_classes[v5 & 7];
            if ((__objc2_class *)v28 == __NSUnrecognizedTaggedPointer)
              v28 = objc_debug_taggedpointer_ext_classes[(v5 >> 55)];
          }
          else
          {
            v28 = *(_QWORD *)v5 & 0xFFFFFFFF8;
          }
          if ((v28 & 0xFFFFFFF000000007) != 0)
            _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v20, v21, v22, v28);
          *(_QWORD *)v14 = v28 & 0xFFFFFFFF8;
          *(_OWORD *)(v14 + 16) = *(_OWORD *)(v5 + 16);
          v29 = *(_QWORD *)(v5 + 32);
          v30 = __ldxr(v24);
          if ((v29 & 4) != 0)
          {
            while (1)
            {
              v36 = v30 ? v30 | 4 : 0x8000000000000004;
              if (!__stlxr(v36, v24))
                break;
              v30 = __ldxr(v24);
            }
          }
          else
          {
            v31 = v30 & 0xFFFFFFFFFFFFFFFBLL;
            for (j = v30 == 0; ; j = v34 == 0)
            {
              v33 = j ? 0x8000000000000000 : v31;
              if (!__stlxr(v33, v24))
                break;
              v34 = __ldxr(v24);
              v31 = v34 & 0xFFFFFFFFFFFFFFFBLL;
            }
          }
          v37 = *(_QWORD *)(v5 + 32);
          v38 = (_QWORD *)(v37 & 0xF00007FFFFFFFF8);
          if (v37 < 0)
          {
            v39 = *(_QWORD *)((v37 & 0xF00007FFFFFFFF8) + 8);
            v38 = (_QWORD *)(v39 & 0xFFFFFFFFFFFFFFFELL);
            if ((v39 & 1) != 0)
              v38 = (_QWORD *)*v38;
          }
          v40 = *(_QWORD *)(v25 + 8);
          if ((v40 & 1) != 0)
            *(_QWORD *)(v40 & 0xFFFFFFFFFFFFFFFELL) = v38;
          else
            *(_QWORD *)(v25 + 8) = v38;
          v41 = (char *)atomic_load(v27 + 3);
          strlen(v41);
          if ((_dyld_is_memory_immutable() & 1) == 0)
            free(v41);
          free(v27);
          addRemappedClass((objc_class *)v5, (objc_class *)v14);
LABEL_42:
          addNamedClass((objc_class *)v14, v9, (objc_class *)v5);
          goto LABEL_57;
        }
      }
    }
  }
  v14 = v5;
  if ((a3 & 1) != 0)
    goto LABEL_58;
  v5 = 0;
  if (v9)
    goto LABEL_42;
LABEL_57:
  addClassTableEntry(v14, 1);
LABEL_58:
  if (a2)
  {
    v42 = *(_QWORD *)(v14 + 32);
    v43 = (_QWORD *)(v42 & 0xF00007FFFFFFFF8);
    if (v42 < 0)
    {
      v44 = *(_QWORD *)((v42 & 0xF00007FFFFFFFF8) + 8);
      v43 = (_QWORD *)(v44 & 0xFFFFFFFFFFFFFFFELL);
      if ((v44 & 1) != 0)
        v43 = (_QWORD *)*v43;
    }
    *(_DWORD *)v43 |= 0x20000000u;
    v45 = *(_QWORD *)((*(_QWORD *)v14 & 0xFFFFFFFF8) + 0x20);
    v46 = (_QWORD *)(v45 & 0xF00007FFFFFFFF8);
    if (v45 < 0)
    {
      v47 = *(_QWORD *)((v45 & 0xF00007FFFFFFFF8) + 8);
      v46 = (_QWORD *)(v47 & 0xFFFFFFFFFFFFFFFELL);
      if ((v47 & 1) != 0)
        v46 = (_QWORD *)*v46;
    }
    *(_DWORD *)v46 |= 0x20000000u;
  }
  return v14;
}

objc_class *realizeClassMaybeSwiftMaybeRelock(objc_class *this, int a2)
{
  objc_class *v3;
  unint64_t StatusReg;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t (*v12)(objc_class *, _QWORD);
  uint64_t v13;
  objc_class *v14;
  unsigned int v15;
  unsigned int v17;
  int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  char *v26;

  v3 = this;
  if ((*((_BYTE *)this + 32) & 3) != 0)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v5 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v6 = __ldxr((unsigned int *)&runtimeLock);
      if (v6 != v5)
        break;
      if (!__stlxr(0, (unsigned int *)&runtimeLock))
        goto LABEL_12;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
LABEL_12:
    v9 = *((_QWORD *)v3 + 4);
    v10 = (_QWORD *)(v9 & 0xF00007FFFFFFFF8);
    if (v9 < 0)
    {
      v11 = *(_QWORD *)((v9 & 0xF00007FFFFFFFF8) + 8);
      v10 = (_QWORD *)(v11 & 0xFFFFFFFFFFFFFFFELL);
      if ((v11 & 1) != 0)
        v10 = (_QWORD *)*v10;
    }
    if ((*(_BYTE *)v10 & 0x40) != 0 && (v12 = (uint64_t (*)(objc_class *, _QWORD))v10[9]) != 0)
    {
      if (PrintConnecting)
      {
        v26 = objc_class::nameForLogging(v3);
        _objc_inform("CLASS: calling Swift metadata initializer for class '%s' (%p)", v26, v3);
      }
      v13 = v12(v3, 0);
      if ((objc_class *)v13 == v3)
      {
LABEL_41:
        if (a2)
        {
          v23 = *(_DWORD *)(StatusReg + 24);
          while (!__ldaxr((unsigned int *)&runtimeLock))
          {
            if (!__stxr(v23, (unsigned int *)&runtimeLock))
              return v3;
          }
          __clrex();
          os_unfair_lock_lock_with_options();
        }
        return v3;
      }
      v14 = (objc_class *)v13;
      v15 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr((unsigned int *)&runtimeLock))
      {
        if (!__stxr(v15, (unsigned int *)&runtimeLock))
          goto LABEL_35;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_35:
      addRemappedClass(v3, v14);
      v21 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v22 = __ldxr((unsigned int *)&runtimeLock);
        if (v22 != v21)
          break;
        if (!__stlxr(0, (unsigned int *)&runtimeLock))
          goto LABEL_40;
      }
    }
    else
    {
      v17 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr((unsigned int *)&runtimeLock))
      {
        if (!__stxr(v17, (unsigned int *)&runtimeLock))
          goto LABEL_29;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_29:
      v14 = realizeClassWithoutSwift(v3, 0);
      v19 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v20 = __ldxr((unsigned int *)&runtimeLock);
        if (v20 != v19)
          break;
        if (!__stlxr(0, (unsigned int *)&runtimeLock))
          goto LABEL_40;
      }
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
LABEL_40:
    v3 = v14;
    goto LABEL_41;
  }
  v3 = realizeClassWithoutSwift(this, 0);
  if ((a2 & 1) == 0)
  {
    v7 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    while (1)
    {
      v8 = __ldxr((unsigned int *)&runtimeLock);
      if (v8 != v7)
        break;
      if (!__stlxr(0, (unsigned int *)&runtimeLock))
        return v3;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
  }
  return v3;
}

void sub_180107950(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

__objc2_class *initializeAndMaybeRelock(__objc2_class *a1, objc_object *a2, int a3)
{
  __objc2_class *v4;
  int v5;
  objc_class *MaybeUnrealizedNonMetaClass;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  objc_class *v10;
  objc_class *v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;

  v4 = a1;
  v5 = *(_DWORD *)((uint64_t)a1->info & 0xF00007FFFFFFFF8);
  if ((v5 & 1) == 0)
    v5 = *(_DWORD *)(*(_QWORD *)(((uint64_t)a1->isa & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v5 & 0x20000000) != 0)
  {
    if ((a3 & 1) == 0)
    {
      v12 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
      while (1)
      {
        v13 = __ldxr((unsigned int *)&runtimeLock);
        if (v13 != v12)
          break;
        if (!__stlxr(0, (unsigned int *)&runtimeLock))
          return v4;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
    }
  }
  else
  {
    MaybeUnrealizedNonMetaClass = (objc_class *)getMaybeUnrealizedNonMetaClass((objc_class *)a1, a2);
    v10 = MaybeUnrealizedNonMetaClass;
    if ((unint64_t)(*(_QWORD *)MaybeUnrealizedNonMetaClass - 1) >= 0xF
      && (*(_DWORD *)(*((_QWORD *)MaybeUnrealizedNonMetaClass + 4) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
    {
      v14 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
      while (1)
      {
        v15 = __ldxr((unsigned int *)&runtimeLock);
        if (v15 != v14)
          break;
        if (!__stlxr(0, (unsigned int *)&runtimeLock))
          goto LABEL_21;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
    }
    else
    {
      v11 = realizeClassMaybeSwiftMaybeRelock(MaybeUnrealizedNonMetaClass, 0);
      v10 = v11;
      if (v11)
      {
        if (((unint64_t)v11 & 0x8000000000000000) != 0)
        {
          v4 = (__objc2_class *)objc_debug_taggedpointer_classes[v11 & 7];
          if (v4 == __NSUnrecognizedTaggedPointer)
            v4 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[((unint64_t)v11 >> 55)];
        }
        else
        {
          v4 = (__objc2_class *)(*(_QWORD *)v11 & 0xFFFFFFFF8);
        }
      }
      else
      {
        v4 = 0;
      }
    }
LABEL_21:
    initializeNonMetaClass(v10, v7, v8, v9);
    if (a3)
    {
      v16 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
      while (!__ldaxr((unsigned int *)&runtimeLock))
      {
        if (!__stxr(v16, (unsigned int *)&runtimeLock))
          return v4;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
    }
  }
  return v4;
}

void initializeNonMetaClass(objc_class *a1, uint64_t a2, uint64_t a3, char *a4)
{
  objc_class *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  int v10;
  void **v11;
  const void **StatusReg;
  unsigned int v13;
  unsigned int *v15;
  unsigned int v16;
  size_t v17;
  const void *v18;
  void *v19;
  int v20;
  unsigned int v21;
  const char *v22;
  char *v23;
  void **v24;
  char *v25;
  const char *v26;
  char *v27;
  char *v28;
  const char *v29;
  char *v30;
  unsigned int v31;
  void *v32[2];

  v5 = (objc_class *)*((_QWORD *)a1 + 1);
  if (v5)
  {
    v6 = *(_DWORD *)(*((_QWORD *)v5 + 4) & 0xF00007FFFFFFFF8);
    if ((v6 & 1) == 0)
      v6 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)v5 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    if ((v6 & 0x20000000) == 0)
      initializeNonMetaClass(*((_QWORD *)a1 + 1));
  }
  WAITING_FOR_A_CLASS__initialize_LOCK(a1, a2, a3, a4);
  v10 = *(_DWORD *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8);
  if ((v10 & 1) == 0)
    v10 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v10 & 0x20000000) != 0)
    goto LABEL_16;
  if ((v10 & 0x10000000) == 0)
    goto LABEL_10;
  if (MultithreadedForkChild != 1 || _thisThreadIsInitializingClass(a1))
  {
LABEL_16:
    unlockClass(a1, v7, v8, v9);
    return;
  }
  WAITING_FOR_A_CLASS__initialize_LOCK(a1, v7, v8, v9);
  _setThisThreadIsInitializingClass(a1);
  performForkChildInitialize(a1, v5, v29, v30);
LABEL_10:
  v11 = v32;
  v32[0] = 0;
  StatusReg = (const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v13 = *((_DWORD *)StatusReg + 6);
  while (!__ldaxr((unsigned int *)&classInitLock))
  {
    if (!__stxr(v13, (unsigned int *)&classInitLock))
      goto LABEL_18;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_18:
  v15 = (unsigned int *)(*(_QWORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  do
    v16 = __ldxr(v15);
  while (__stxr(v16 | 0x10000000, v15));
  v17 = 16 * willInitializeFuncs;
  v31 = willInitializeFuncs;
  if (willInitializeFuncs < 2)
  {
    memcpy(v32, &xmmword_1EDBFC330, 16 * willInitializeFuncs);
  }
  else
  {
    v18 = (const void *)xmmword_1EDBFC330;
    v19 = malloc_type_malloc(16 * willInitializeFuncs, 0x3F84A03uLL);
    memcpy(v19, v18, v17);
    v32[0] = v19;
  }
  v20 = *((_DWORD *)StatusReg + 6);
  while (1)
  {
    v21 = __ldxr((unsigned int *)&classInitLock);
    if (v21 != v20)
      break;
    if (!__stlxr(0, (unsigned int *)&classInitLock))
      goto LABEL_28;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&classInitLock);
LABEL_28:
  _setThisThreadIsInitializingClass(a1);
  if (MultithreadedForkChild == 1)
  {
    performForkChildInitialize(a1, v5, v22, v23);
  }
  else
  {
    if (v31 >= 2uLL)
      v11 = (void **)v32[0];
    if (v31)
    {
      v24 = &v11[2 * v31];
      do
      {
        ((void (*)(void *, objc_class *))*v11)(v11[1], a1);
        v11 += 2;
      }
      while (v11 != v24);
    }
    if (PrintInitializing)
    {
      v25 = objc_class::nameForLogging(a1);
      _objc_inform("INITIALIZE: thread %p: calling +[%s initialize]", *StatusReg, v25);
    }
    CALLING_SOME__initialize_METHOD(a1);
    if (PrintInitializing)
    {
      v28 = objc_class::nameForLogging(a1);
      _objc_inform("INITIALIZE: thread %p: finished +[%s initialize]", *StatusReg, v28);
    }
    lockAndFinishInitializing(a1, v5, v26, v27);
  }
  if (v31 >= 2)
    free(v32[0]);
}

void sub_180107E40(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, void *a13)
{
  __break(1u);
  JUMPOUT(0x180107EA4);
}

void sub_180107EC4(void *a1)
{
  objc_end_catch();
  objc_begin_catch(a1);
  JUMPOUT(0x180107DD8);
}

void sub_180107EE0()
{
  JUMPOUT(0x180107EE8);
}

uint64_t WAITING_FOR_A_CLASS__initialize_LOCK(objc_class *this, uint64_t a2, uint64_t a3, char *a4)
{
  objc_class *v4;
  const void *v6;
  char *v7;

  v4 = this;
  if (PrintInitializing)
  {
    v6 = *(const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v7 = objc_class::nameForLogging(this);
    _objc_inform("INITIALIZE: thread %p: acquiring lock for +[%s initialize]", v6, v7);
  }
  if ((unint64_t)(*(_QWORD *)v4 - 1) < 0xF || (*(_BYTE *)(*((_QWORD *)v4 + 4) & 0xF00007FFFFFFFF8) & 1) == 0)
    v4 = (objc_class *)(*(_QWORD *)v4 & 0xFFFFFFFF8);
  return _objc_sync_enter_kind((uint64_t)v4, 2, a3, a4);
}

uint64_t unlockClass(objc_class *a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((unint64_t)(*(_QWORD *)a1 - 1) < 0xF || (*(_BYTE *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) & 1) == 0)
    a1 = (objc_class *)(*(_QWORD *)a1 & 0xFFFFFFFF8);
  return _objc_sync_exit_kind((uint64_t)a1, 2, a3, a4);
}

objc_class *getMaybeUnrealizedNonMetaClass(objc_class *a1, objc_object *a2, const char *a3, char *a4)
{
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  char *v12;
  char *ClassExceptSomeSwift;
  uint64_t (***v14)(_QWORD, objc_class *);
  unsigned int v15;
  uint64_t v16;
  const char *v17;
  char *v18;
  _QWORD v20[6];
  unint64_t v21;

  ++getMaybeUnrealizedNonMetaClass(objc_class *,objc_object *)::total;
  if ((*((_WORD *)a1 + 15) & 4) == 0)
    return a1;
  if ((objc_class *)(*(_QWORD *)a1 & 0xFFFFFFFF8) != a1
    || (v5 = (_QWORD *)*((_QWORD *)a1 + 1), (objc_class *)(*v5 & 0xFFFFFFFF8) != a1))
  {
    if (!a2 || (v6 = remapClass((unint64_t)a2)) == 0)
    {
LABEL_10:
      v7 = *((_QWORD *)a1 + 4);
      v8 = (_QWORD *)(v7 & 0xF00007FFFFFFFF8);
      if (v7 < 0)
      {
        v9 = *(_QWORD *)((v7 & 0xF00007FFFFFFFF8) + 8);
        v10 = (_QWORD *)(v9 & 0xFFFFFFFFFFFFFFFELL);
        if ((v9 & 1) != 0)
          v10 = (_QWORD *)*v10;
        v5 = (_QWORD *)v10[2];
        if (v5)
          return (objc_class *)v5;
        v11 = v8[1];
        v8 = (_QWORD *)(v11 & 0xFFFFFFFFFFFFFFFELL);
        if ((v11 & 1) != 0)
          v8 = (_QWORD *)*v8;
      }
      else
      {
        v5 = *(_QWORD **)((v7 & 0xF00007FFFFFFFF8) + 0x10);
        if (v5)
          return (objc_class *)v5;
      }
      v12 = (char *)atomic_load(v8 + 3);
      if (!v12)
        v12 = (char *)objc_class::installMangledNameForLazilyNamedClass(a1, (uint64_t)a2, a3, a4);
      ClassExceptSomeSwift = getClassExceptSomeSwift(v12);
      if (ClassExceptSomeSwift
        && (v5 = ClassExceptSomeSwift, (objc_class *)(*(_QWORD *)ClassExceptSomeSwift & 0xFFFFFFFF8) == a1))
      {
        ++getMaybeUnrealizedNonMetaClass(objc_class *,objc_object *)::named;
        if (PrintInitializing)
          _objc_inform("INITIALIZE: %d/%d (%g%%) successful by-name metaclass lookups");
      }
      else
      {
        v14 = (uint64_t (***)(_QWORD, objc_class *))nonMetaClasses();
        v15 = (**v14)(v14, a1);
        v20[0] = 0;
        if (_NXMapMemberWithHash((uint64_t)v14, (uint64_t)a1, v15, v20) == -1)
          v5 = 0;
        else
          v5 = (_QWORD *)v20[0];
        if (v5)
        {
          ++getMaybeUnrealizedNonMetaClass(objc_class *,objc_object *)::secondary;
          if (PrintInitializing)
            _objc_inform("INITIALIZE: %d/%d (%g%%) successful secondary metaclass lookups");
        }
        else
        {
          if (DisablePreopt)
            goto LABEL_39;
          if ((preoptimized & 1) == 0)
            goto LABEL_39;
          v21 = 0;
          objc_class::mangledName(a1, v16, v17, v18);
          v20[0] = MEMORY[0x1E0C809B0];
          v20[1] = 3321888768;
          v20[2] = __getPreoptimizedClassesWithMetaClass_block_invoke;
          v20[3] = &__block_descriptor_48_e8_32c48_ZTSKZ35getPreoptimizedClassesWithMetaClassE3__0_e16_v28__0_v8B16_B20l;
          v20[4] = &v21;
          v20[5] = a1;
          _dyld_for_each_objc_class();
          v5 = (_QWORD *)v21;
          if (!v21)
LABEL_39:
            _objc_fatal("no class for metaclass %p", v16, v17, v18, a1);
          if (PrintInitializing)
          {
            if (dataSegmentsRanges > v21 || *(_QWORD *)algn_1ECCE5978 <= v21)
            {
              ++getMaybeUnrealizedNonMetaClass(objc_class *,objc_object *)::dyld3;
              _objc_inform("INITIALIZE: %d/%d (%g%%) successful dyld closure metaclass lookups");
            }
            else
            {
              ++getMaybeUnrealizedNonMetaClass(objc_class *,objc_object *)::sharedcache;
              _objc_inform("INITIALIZE: %d/%d (%g%%) successful shared cache metaclass lookups");
            }
          }
        }
      }
      return (objc_class *)v5;
    }
    v5 = (_QWORD *)v6;
    while ((objc_class *)(*v5 & 0xFFFFFFFF8) != a1)
    {
      v5 = (_QWORD *)v5[1];
      if (!v5)
        goto LABEL_10;
    }
  }
  return (objc_class *)v5;
}

uint64_t objc_class::setInstanceSize(uint64_t this, unsigned int a2)
{
  uint64_t v2;
  unint64_t v3;
  unsigned int v4;

  v2 = *(_QWORD *)((*(_QWORD *)(this + 32) & 0xF00007FFFFFFFF8) + 8);
  v3 = v2 & 0xFFFFFFFFFFFFFFFELL;
  if ((v2 & 1) != 0)
    v3 = *(_QWORD *)v3;
  if (*(_DWORD *)(v3 + 8) != a2)
    *(_DWORD *)(v3 + 8) = a2;
  v4 = ((_WORD)a2 + 15) & 0xFF8;
  if (v4 < a2)
    LOWORD(v4) = 0;
  *(_WORD *)(this + 30) = *(_WORD *)(this + 30) & 0xF007 | v4;
  return this;
}

objc_class *realizeClassWithoutSwift(objc_class *a1, objc_class *a2)
{
  objc_class *v2;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  objc_class *v19;
  BOOL v20;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int16 *v26;
  unsigned __int16 v27;
  __objc2_class *v28;
  objc_class *v29;
  uint64_t v30;
  objc_class *v31;
  uint64_t v32;
  const char *v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  unsigned __int16 *v39;
  unsigned __int16 v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int *v46;
  char *v47;
  unint64_t v48;
  uint64_t v49;
  const char *v50;
  char *v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unsigned int *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unsigned int v61;
  uint64_t v62;
  int v63;
  unsigned int v64;
  uint64_t v65;
  __objc2_class *v66;
  int *v67;
  int v68;
  int v69;
  int v70;
  int v71;
  const char *v72;
  unsigned int v73;
  uint64_t v74;
  unint64_t ro_writeable_nolock;
  uint64_t v76;
  const char *v77;
  char *v78;
  uint64_t v79;
  unint64_t v80;
  unsigned int *v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unsigned int *v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  int v90;
  uint64_t v91;
  const char *v92;
  char *v93;
  uint64_t v94;
  int v95;
  unsigned __int16 v96;
  unsigned __int16 v97;
  uint64_t v98;
  unsigned __int16 v99;
  uint64_t v100;
  _QWORD *v101;
  __objc2_class *v102;
  uint64_t v103;
  unsigned int *v104;
  method_list_t *v105;
  uint64_t v106;
  _QWORD *v107;
  uint64_t v108;
  uint64_t v109;
  __objc2_class *v111;
  uint64_t *v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  unsigned int *v116;
  unint64_t v117;
  unsigned int v118;
  unsigned int v119;
  unint64_t v120;
  uint64_t *v121;
  uint64_t v122;
  uint64_t v123;
  _QWORD *v124;
  char *v125;
  const char *v126;
  const char *v127;
  uint64_t v128;
  const char *v129;
  uint64_t v130;
  unint64_t v131;
  unsigned int *v132;
  uint64_t *v133;
  uint64_t v134;
  uint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unsigned int v138;
  unint64_t v139;
  char *v140;
  const char *v141;
  unint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  BOOL v147;
  unint64_t v148;
  uint64_t *v149;
  unint64_t v150;
  unsigned int v151;
  int v152;
  int v153;
  unint64_t v154;
  uint64_t v155;
  _DWORD **v156;
  char *v157;
  char *v158;
  const char *v159;
  __objc2_class *v160;
  char *v161;
  const char *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t *v165;
  unint64_t v166;
  uint64_t *i;
  unint64_t v168;
  uint64_t *v169;
  uint64_t v170;
  char *v171;
  unint64_t v172;
  uint64_t v173;
  BOOL v174;
  __objc2_class *v175;
  unint64_t v176;
  unint64_t v177;
  uint64_t v178;
  BOOL v179;
  unint64_t v180;
  char *v181;
  BOOL v182;
  objc_class *v183;
  objc_class *v184;
  _QWORD *v185;
  _QWORD *v186;
  char v187;
  method_list_t *v188;
  method_list_t *v189;

  v2 = a1;
  if (!a1)
    return v2;
  v4 = *((_QWORD *)a1 + 4);
  v5 = v4 & 0xF00007FFFFFFFF8;
  if ((unint64_t)(*(_QWORD *)a1 - 1) >= 0xF && (*(_DWORD *)v5 & 0x80000000) != 0)
    return v2;
  v6 = (_QWORD *)(v4 & 0xF00007FFFFFFFF8);
  if (v4 < 0)
  {
    v7 = *(_QWORD *)((v4 & 0xF00007FFFFFFFF8) + 8);
    v6 = (_QWORD *)(v7 & 0xFFFFFFFFFFFFFFFELL);
    if ((v7 & 1) != 0)
      v6 = (_QWORD *)*v6;
  }
  v185 = v6;
  v8 = *(_DWORD *)v6 & 1;
  if ((*(_DWORD *)v6 & 0x40000000) != 0)
  {
    v11 = *(_QWORD *)(v5 + 8);
    v185 = (_QWORD *)(v11 & 0xFFFFFFFFFFFFFFFELL);
    if ((v11 & 1) != 0)
      v185 = (_QWORD *)*v185;
    while (1)
    {
      v12 = *(_DWORD *)v5;
      v13 = *(_DWORD *)v5 & 0x3FF7FFFF | 0x80080000;
      while (1)
      {
        v14 = __ldaxr((unsigned int *)v5);
        if (v14 != v12)
          break;
        if (!__stlxr(v13, (unsigned int *)v5))
          goto LABEL_19;
      }
      __clrex();
    }
  }
  v9 = (uint64_t)malloc_type_calloc(0x20uLL, 1uLL, 0x1ECB51D3uLL);
  v5 = v9;
  v10 = *(_QWORD *)(v9 + 8);
  if ((v10 & 1) != 0)
    *(_QWORD *)(v10 & 0xFFFFFFFFFFFFFFFELL) = v185;
  else
    *(_QWORD *)(v9 + 8) = v185;
  *(_DWORD *)v9 = v8 | 0x80080000;
  v15 = *((_QWORD *)v2 + 4) & 7 | v9 | 0x8000000000000000;
  __dmb(0xBu);
  *((_QWORD *)v2 + 4) = v15;
LABEL_19:
  if (DisablePreoptCaches
    || (v16 = dataSegmentsRanges, v17 = *(_QWORD *)algn_1ECCE5978, dataSegmentsRanges > (unint64_t)v2 + 16)
    || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v2 + 16
    || (v18 = *((_QWORD *)v2 + 3)) == 0)
  {
    *((_QWORD *)v2 + 2) = &_objc_empty_cache;
    *((_QWORD *)v2 + 3) = 0;
    if (!v8)
      goto LABEL_51;
    goto LABEL_49;
  }
  if (!dyld_shared_cache_some_image_overridden() || !*(_QWORD *)v18)
  {
LABEL_46:
    *((_QWORD *)v2 + 3) = 0;
    atomic_store(v18, (unint64_t *)v2 + 2);
    *((_WORD *)v2 + 14) = 0;
    *((_DWORD *)v2 + 6) = 0;
    *((_WORD *)v2 + 14) = *(_WORD *)(v18 + 10) & 0x3FFF;
    if (!v8)
      goto LABEL_51;
    goto LABEL_49;
  }
  v19 = v2;
  while (1)
  {
    v19 = (objc_class *)*((_QWORD *)v19 + 1);
    v20 = !v19 || v16 > (unint64_t)v19;
    if (v20 || v17 <= (unint64_t)v19)
      break;
    v22 = *((_QWORD *)v19 + 4);
    v23 = (_QWORD *)(v22 & 0xF00007FFFFFFFF8);
    if (v22 < 0)
    {
      v24 = *(_QWORD *)((v22 & 0xF00007FFFFFFFF8) + 8);
      v23 = (_QWORD *)(v24 & 0xFFFFFFFFFFFFFFFELL);
      if ((v24 & 1) != 0)
        v23 = (_QWORD *)*v23;
    }
    if (v16 > (unint64_t)v23 || v17 <= (unint64_t)v23)
      break;
    if (v19 == (objc_class *)((char *)v2 + *(_QWORD *)v18))
      goto LABEL_46;
  }
  *((_QWORD *)v2 + 2) = &_objc_empty_cache;
  *((_QWORD *)v2 + 3) = 0;
  objc_class::setDisallowPreoptCachesRecursively((uint64_t)v2, "roots");
  if (v8)
  {
LABEL_49:
    v26 = (unsigned __int16 *)((char *)v2 + 30);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 | 4, v26));
  }
LABEL_51:
  v28 = Object;
  if (PrintConnecting)
  {
    v125 = objc_class::nameForLogging(v2);
    v126 = "";
    v127 = " (meta)";
    if (!v8)
      v127 = "";
    v128 = *((_QWORD *)v2 + 4);
    v129 = "(swift)";
    if ((v128 & 2) == 0)
      v129 = "";
    if ((v128 & 1) != 0)
      v126 = "(pre-stable swift)";
    _objc_inform("CLASS: realizing class '%s'%s %p %p #%u %s%s", v125, v127, v2, v185, 0, v129, v126);
  }
  v29 = (objc_class *)remapClass(*((_QWORD *)v2 + 1));
  v30 = realizeClassWithoutSwift(v29, 0);
  v31 = (objc_class *)remapClass(*(_QWORD *)v2 & 0xFFFFFFFF8);
  v35 = realizeClassWithoutSwift(v31, 0);
  if (!v30)
  {
    v36 = *((_QWORD *)v2 + 4);
    v37 = (_QWORD *)(v36 & 0xF00007FFFFFFFF8);
    if (v36 < 0)
    {
      v38 = *(_QWORD *)((v36 & 0xF00007FFFFFFFF8) + 8);
      v37 = (_QWORD *)(v38 & 0xFFFFFFFFFFFFFFFELL);
      if ((v38 & 1) != 0)
        v37 = (_QWORD *)*v37;
    }
    if ((*(_BYTE *)v37 & 2) == 0)
    {
      if (PrintConnecting)
      {
        v158 = objc_class::nameForLogging(v2);
        v159 = "";
        if (v8)
          v159 = " (meta)";
        _objc_inform("CLASS: '%s'%s %p has missing weak superclass, disabling.", v158, v159, v2);
      }
      addRemappedClass(v2, 0);
      *(_QWORD *)v2 = 0;
      return 0;
    }
  }
  v39 = (unsigned __int16 *)((char *)v2 + 30);
  if (!v8)
  {
    if (!DisableNonpointerIsa)
    {
      v71 = *v39;
      if ((realizeClassWithoutSwift(objc_class *,objc_class *)::hackedDispatch & 1) == 0)
      {
        v72 = (const char *)atomic_load(v185 + 3);
        if (v72)
        {
          if (!strcmp(v72, "OS_object"))
          {
            LOBYTE(v41) = 0;
            realizeClassWithoutSwift(objc_class *,objc_class *)::hackedDispatch = 1;
            v28 = Object;
            goto LABEL_64;
          }
        }
      }
      if (v30 && *(_QWORD *)(v30 + 8))
      {
        v73 = *(unsigned __int16 *)(v30 + 30);
        v28 = Object;
        if (((v73 | v71) & 0x2000) == 0)
          goto LABEL_65;
        v41 = (v73 >> 13) & 1;
        goto LABEL_64;
      }
      v28 = Object;
      if ((v71 & 0x2000) == 0)
        goto LABEL_65;
    }
    LOBYTE(v41) = 0;
LABEL_64:
    objc_class::setInstancesRequireRawIsaRecursively((uint64_t)v2, v41);
    goto LABEL_65;
  }
  do
    v40 = __ldxr(v39);
  while (__stxr(v40 | 0x2000, v39));
LABEL_65:
  *((_QWORD *)v2 + 1) = v30;
  if (DisableNonpointerIsa || (*(_WORD *)(v35 + 30) & 0x2000) != 0)
  {
    if ((v35 & 0xFFFFFFF000000007) == 0)
    {
      v42 = v35 & 0xFFFFFFFF8;
      goto LABEL_71;
    }
LABEL_255:
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v32, v33, v34, v35);
  }
  if ((v35 & 0xFFFFFFF000000007) != 0)
    goto LABEL_255;
  v42 = v35 & 0xFFFFFFFF8 | 0x21A000000001;
LABEL_71:
  *(_QWORD *)v2 = v42;
  if (v8 || !v30)
  {
    v46 = (int *)v185;
    goto LABEL_131;
  }
  v183 = a2;
  v43 = *((_QWORD *)v2 + 4) & 0xF00007FFFFFFFF8;
  v44 = *(_QWORD *)((*(_QWORD *)(v30 + 32) & 0xF00007FFFFFFFF8) + 8);
  v45 = v44 & 0xFFFFFFFFFFFFFFFELL;
  v46 = (int *)v185;
  if ((v44 & 1) != 0)
    v45 = *(_QWORD *)v45;
  if (DebugNonFragileIvars)
  {
    v47 = (char *)objc_class::mangledName(v2);
    if (!strstr(v47, "NSCF")
      && strncmp(v47, "__CF", 4uLL)
      && strcmp(v47, "NSConstantString")
      && strcmp(v47, "NSSimpleCString"))
    {
      v74 = *((unsigned int *)v185 + 1);
      ro_writeable_nolock = make_ro_writeable_nolock(v43);
      v79 = *(_QWORD *)(v43 + 8);
      v80 = v79 & 0xFFFFFFFFFFFFFFFELL;
      if ((v79 & 1) != 0)
        v80 = *(_QWORD *)v80;
      v81 = *(unsigned int **)(v80 + 48);
      if (!v81)
        goto LABEL_225;
      v82 = *v81;
      v83 = v81[1];
      v84 = v83 * (unint64_t)v82;
      if ((v84 & 0xFFFFFFFF00000000) != 0)
        goto LABEL_283;
      if ((_DWORD)v84)
      {
        v85 = (uint64_t)v81 + v84 + 8;
        v86 = v81 + 2;
        v87 = 8;
        do
        {
          v88 = v86[6];
          if (v88 == -1)
            v89 = 8;
          else
            v89 = 1 << v88;
          if (v89 > v87)
            v87 = v89;
          v86 = (unsigned int *)((char *)v86 + v82);
        }
        while (v86 != (unsigned int *)v85);
      }
      else
      {
LABEL_225:
        v87 = 8;
      }
      v150 = v80;
      v151 = *(_DWORD *)(v80 + 4);
      v152 = v151 / v87 * v87;
      v153 = *(_DWORD *)(ro_writeable_nolock + 8) - v152;
      *(_DWORD *)(ro_writeable_nolock + 4) = v151 - v152;
      *(_DWORD *)(ro_writeable_nolock + 8) = v153;
      if (PrintIvars)
      {
        v171 = objc_class::nameForLogging(v2);
        _objc_inform("IVARS: DEBUG: forcing ivars for class '%s' to slide (instanceStart %zu -> %zu)", v171, v74, *(unsigned int *)(v150 + 4));
        v81 = *(unsigned int **)(v150 + 48);
        if (v81)
        {
LABEL_228:
          v82 = *v81;
          v83 = v81[1];
          v154 = v83 * (unint64_t)v82;
          if ((v154 & 0xFFFFFFFF00000000) == 0)
          {
            if ((_DWORD)v154)
            {
              v155 = (uint64_t)v81 + v154 + 8;
              v156 = (_DWORD **)(v81 + 2);
              do
              {
                if (*v156)
                  **v156 -= v152;
                v156 = (_DWORD **)((char *)v156 + v82);
              }
              while (v156 != (_DWORD **)v155);
            }
            goto LABEL_234;
          }
LABEL_283:
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v76, v77, v78, v83, v81, v82);
        }
      }
      else if (v81)
      {
        goto LABEL_228;
      }
LABEL_234:
      v46 = (int *)v150;
      goto LABEL_78;
    }
    v46 = (int *)v185;
  }
LABEL_78:
  if (v46[1] < *(_DWORD *)(v45 + 8))
  {
    if (PrintIvars)
    {
      v157 = objc_class::nameForLogging(v2);
      _objc_inform("IVARS: sliding ivars for class %s (superclass was %u bytes, now %u)", v157, v46[1], *(_DWORD *)(v45 + 8));
    }
    v48 = make_ro_writeable_nolock(v43);
    v52 = v48;
    v53 = *(_QWORD *)(v43 + 8);
    v186 = (_QWORD *)(v53 & 0xFFFFFFFFFFFFFFFELL);
    if ((v53 & 1) != 0)
      v186 = (_QWORD *)*v186;
    v54 = *(_DWORD *)(v48 + 4);
    v55 = *(_DWORD *)(v45 + 8) - v54;
    v56 = *(unsigned int **)(v48 + 48);
    if (v56)
    {
      v58 = *v56;
      v57 = v56[1];
      v59 = v57 * (unint64_t)v58;
      if ((v59 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v49, v50, v51, v57, *(_QWORD *)(v48 + 48), *v56);
      if ((_DWORD)v59)
      {
        v60 = 0;
        v61 = 1;
        v62 = v59;
        do
        {
          if (*(_QWORD *)((char *)v56 + v60 + 8))
          {
            v63 = *(unsigned int *)((char *)v56 + v60 + 32);
            v64 = v63 == -1 ? 8 : 1 << v63;
            if (v64 > v61)
              v61 = v64;
          }
          v60 += v58;
        }
        while (v62 != v60);
        v65 = 0;
        v55 = (v55 + v61 - 1) & -v61;
        v66 = Object;
        do
        {
          v67 = *(int **)((char *)v56 + v65 + 8);
          if (v67)
          {
            v68 = *v67;
            *v67 += v55;
            if (LODWORD(v66[27].isa))
            {
              v69 = *(unsigned int *)((char *)v56 + v65 + 32);
              if (v69 == -1)
                v70 = 8;
              else
                v70 = 1 << v69;
              _objc_inform("IVARS:    offset %u -> %u for %s (size %u, align %u)", v68, v68 + v55, *(const char **)((char *)v56 + v65 + 16), *(unsigned int *)((char *)v56 + v65 + 36), v70);
              v66 = Object;
            }
          }
          v65 += v58;
        }
        while (v62 != v65);
        v54 = *(_DWORD *)(v52 + 4);
        v28 = Object;
      }
    }
    v90 = *(_DWORD *)(v52 + 8) + v55;
    *(_DWORD *)(v52 + 4) = v55 + v54;
    *(_DWORD *)(v52 + 8) = v90;
    v46 = (int *)v186;
    atomic_load(v186 + 3);
    gdb_objc_class_changed();
  }
  a2 = v183;
LABEL_131:
  objc_class::setInstanceSize((uint64_t)v2, v46[2]);
  v95 = *v46;
  if ((*v46 & 4) != 0)
  {
    do
      v96 = __ldxr(v39);
    while (__stxr(v96 | 1, v39));
    v95 = *v46;
    if ((*v46 & 0x100) == 0)
    {
      do
        v97 = __ldxr(v39);
      while (__stxr(v97 | 2, v39));
      v95 = *v46;
    }
  }
  if ((v95 & 0x400) != 0)
  {
    *(_DWORD *)v5 |= 0x100000u;
    if (v30)
    {
LABEL_141:
      addSubclass(v30, v2);
      v98 = *((_QWORD *)v2 + 4) & 0xF00007FFFFFFFF8;
      goto LABEL_143;
    }
  }
  else if (v30)
  {
    if ((*(_BYTE *)((*(_QWORD *)(v30 + 32) & 0xF00007FFFFFFFF8) + 2) & 0x10) != 0)
      *(_DWORD *)v5 |= 0x100000u;
    goto LABEL_141;
  }
  ++objc_debug_realized_class_generation_count;
  v98 = *((_QWORD *)v2 + 4) & 0xF00007FFFFFFFF8;
  *(_QWORD *)(v98 + 0x18) = _firstRealizedClass;
  _firstRealizedClass = (uint64_t)v2;
LABEL_143:
  v99 = *v39;
  v100 = *(_QWORD *)(v98 + 8);
  v101 = (_QWORD *)(v100 & 0xFFFFFFFFFFFFFFFELL);
  if ((v100 & 1) != 0)
    v101 = (_QWORD *)*v101;
  v102 = v28;
  if (LODWORD(v28[32].info))
  {
    v140 = objc_class::nameForLogging(v2);
    v141 = "(meta)";
    if ((v99 & 4) == 0)
      v141 = "";
    _objc_inform("CLASS: methodizing class '%s' %s", v140, v141);
  }
  v103 = v101[4];
  v104 = (unsigned int *)(v103 & 0xFFFFFFFFFFFFFFFELL);
  if ((v103 & 1) != 0)
    v105 = 0;
  else
    v105 = (method_list_t *)(v103 & 0xFFFFFFFFFFFFFFFELL);
  v189 = v105;
  v187 = v99;
  if (v105)
  {
    v106 = *(_QWORD *)((*((_QWORD *)v2 + 4) & 0xF00007FFFFFFFF8) + 8);
    v107 = (_QWORD *)(v106 & 0xFFFFFFFFFFFFFFFELL);
    if ((v106 & 1) != 0)
      v107 = (_QWORD *)*v107;
    prepareMethodLists(v2, &v189, 1, (char *)1, (*(_DWORD *)v107 >> 29) & 1, 0, v94);
    goto LABEL_153;
  }
  if ((v103 & 1) != 0 && v104)
  {
    v111 = Object;
    if (DisablePreattachedCategories)
    {
      v114 = *v104;
      v113 = v104[1];
      v172 = v113 * (unint64_t)v114;
      if ((v172 & 0xFFFFFFFF00000000) != 0)
        goto LABEL_270;
      v173 = (uint64_t)v104 + v172 + 8;
      v174 = (_DWORD)v113 == 0;
      if ((_DWORD)v113)
        v113 = v113;
      else
        v113 = 0;
      if (v174)
        v112 = (uint64_t *)v173;
      else
        v112 = (uint64_t *)(v173 - v114);
    }
    else
    {
      v112 = (uint64_t *)(v104 + 2);
      v114 = *v104;
      v113 = v104[1];
    }
    v184 = a2;
    v115 = v113 * (unint64_t)v114;
    if ((v115 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v91, v92, v93, v113, v104, v114);
    v116 = v104 + 2;
    v117 = (unint64_t)v104 + v115 + 8;
    if ((unint64_t)v112 < v117)
    {
      while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v112 + 8) & 1) == 0)
      {
        v112 = (uint64_t *)((char *)v112 + v114);
        v118 = v114;
        if ((unint64_t)v112 >= v117)
          goto LABEL_175;
      }
    }
    v118 = v114;
LABEL_175:
    if (v112 == (uint64_t *)v117)
    {
      v119 = 0;
    }
    else
    {
      v119 = 0;
      do
      {
        v188 = 0;
        v188 = (method_list_t *)((char *)v112 + (*v112 >> 16));
        v114 = *v104;
        v113 = v104[1];
        v120 = v113 * (unint64_t)v114;
        if ((v120 & 0xFFFFFFFF00000000) != 0)
          goto LABEL_270;
        v121 = (uint64_t *)((char *)v112 + v118);
        do
        {
          v112 = v121;
          if (v121 >= (uint64_t *)((char *)v116 + v120))
            break;
          v122 = *(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v121 + 8);
          v121 = (uint64_t *)((char *)v121 + v118);
        }
        while ((v122 & 1) == 0);
        v123 = *(_QWORD *)((*((_QWORD *)v2 + 4) & 0xF00007FFFFFFFF8) + 8);
        v124 = (_QWORD *)(v123 & 0xFFFFFFFFFFFFFFFELL);
        if ((v123 & 1) != 0)
          v124 = (_QWORD *)*v124;
        prepareMethodLists(v2, &v188, 1, (char *)(v112 == (uint64_t *)v117), (*(_DWORD *)v124 >> 29) & 1, 0, v94);
        ++v119;
      }
      while (v112 != (uint64_t *)v117);
      LODWORD(v113) = v104[1];
      v111 = Object;
    }
    a2 = v184;
    if (v113 < 0x64 || v119 > v113 >> 1)
      goto LABEL_153;
    if (LODWORD(v102[32].info))
    {
      v160 = v111;
      v161 = objc_class::nameForLogging(v2);
      v162 = "(meta)";
      if ((v187 & 4) == 0)
        v162 = "";
      _objc_inform("CLASS: Copying preoptimized categories for sparsely loaded class '%s' %s - %u lists, %u loaded - loaded lists are:", v161, v162, v104[1], v119);
      if (HIDWORD(v160[29].superclass))
      {
        v164 = *v104;
        v163 = v104[1];
        v180 = v163 * (unint64_t)v164;
        if ((v180 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v91, v92, v93, v163, v104, *v104);
        v181 = (char *)v116 + v180;
        v182 = (_DWORD)v163 == 0;
        v163 = (_DWORD)v163 ? v163 : 0;
        v165 = (uint64_t *)(v182 ? v181 : &v181[-v164]);
        v111 = v160;
      }
      else
      {
        v111 = v160;
        v164 = *v104;
        v163 = v104[1];
        v165 = (uint64_t *)(v104 + 2);
      }
      v166 = v163 * (unint64_t)v164;
      if ((v166 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v91, v92, v93, v163, v104, v164);
      for (i = (uint64_t *)((char *)v116 + v166); v165 < i; v165 = (uint64_t *)((char *)v165 + v164))
      {
        if ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v165 + 8) & 1) != 0)
          break;
      }
      if (v165 != i)
      {
        while (1)
        {
          _objc_inform("    %p", (char *)v165 + (*v165 >> 16));
          v114 = *v104;
          v113 = v104[1];
          v168 = v113 * (unint64_t)v114;
          if ((v168 & 0xFFFFFFFF00000000) != 0)
            break;
          v169 = (uint64_t *)((char *)v165 + v164);
          do
          {
            v165 = v169;
            if (v169 >= (uint64_t *)((char *)v116 + v168))
              break;
            v170 = *(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v169 + 8);
            v169 = (uint64_t *)((char *)v169 + v164);
          }
          while ((v170 & 1) == 0);
          v111 = v160;
          if (v165 == i)
            goto LABEL_196;
        }
LABEL_270:
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v91, v92, v93, v113, v104, v114);
      }
    }
LABEL_196:
    v130 = *(_QWORD *)(v98 + 8);
    v131 = v130 & 0xFFFFFFFFFFFFFFFELL;
    if ((v130 & 1) == 0)
    {
      v175 = v111;
      v176 = class_rw_t::extAlloc(v98, v130 & 0xFFFFFFFFFFFFFFFELL, 0);
      v111 = v175;
      v131 = v176;
    }
    if ((*(_QWORD *)(v131 + 8) & 3) == 2)
      v132 = (unsigned int *)(*(_QWORD *)(v131 + 8) & 0xFFFFFFFFFFFFFFFCLL);
    else
      v132 = 0;
    if (HIDWORD(v111[29].superclass))
    {
      v134 = *v132;
      v135 = v132[1];
      v177 = v135 * (unint64_t)v134;
      if ((v177 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v91, v92, v93, v135, v132, *v132);
      v178 = (uint64_t)v132 + v177 + 8;
      v179 = (_DWORD)v135 == 0;
      if ((_DWORD)v135)
        v135 = v135;
      else
        v135 = 0;
      if (v179)
        v133 = (uint64_t *)v178;
      else
        v133 = (uint64_t *)(v178 - v134);
    }
    else
    {
      v133 = (uint64_t *)(v132 + 2);
      v134 = *v132;
      v135 = v132[1];
    }
    v136 = v135 * (unint64_t)v134;
    if ((v136 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v91, v92, v93, v135, v132, v134);
    v137 = (unint64_t)v132 + v136 + 8;
    if ((unint64_t)v133 < v137)
    {
      while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v133 + 8) & 1) == 0)
      {
        v133 = (uint64_t *)((char *)v133 + v134);
        v138 = v134;
        if ((unint64_t)v133 >= v137)
          goto LABEL_209;
      }
    }
    v138 = v134;
LABEL_209:
    if (v119 == 1)
    {
      v139 = (unint64_t)v133 + (*v133 >> 16);
      *(_QWORD *)(v131 + 8) = v139;
    }
    else
    {
      v142 = (unint64_t)malloc_type_malloc(8 * v119 + 8, 0x8BC14CD7uLL);
      v139 = v142 | 1;
      *(_QWORD *)(v131 + 8) = v142 | 1;
      *(_DWORD *)v142 = v119;
      if (v119)
      {
        v143 = 0;
        v145 = *v132;
        v144 = v132[1];
        v146 = v144 * (unint64_t)v145;
        v147 = (v146 & 0xFFFFFFFF00000000) != 0;
        v148 = (unint64_t)v132 + v146 + 8;
        a2 = v184;
        do
        {
          *(_QWORD *)(v142 + 8 * v143 + 8) = (char *)v133 + (*v133 >> 16);
          if (v147)
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v91, v92, v93, v144, v132, v145);
          ++v143;
          v149 = (uint64_t *)((char *)v133 + v138);
          do
          {
            v133 = v149;
            if ((unint64_t)v149 >= v148)
              break;
            v91 = *(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v149 + 8);
            v149 = (uint64_t *)((char *)v149 + v138);
          }
          while ((v91 & 1) == 0);
        }
        while (v143 != v119);
        goto LABEL_223;
      }
    }
    a2 = v184;
LABEL_223:
    list_array_tt<unsigned long,protocol_list_t,RawPtr>::validate(v139, v91, v92, v93);
  }
LABEL_153:
  if ((objc_class *)(*(_QWORD *)v2 & 0xFFFFFFFF8) == v2)
    addMethod(v2, (objc_selector *)sel_initialize, (void (*)(void))objc_noop_imp, "", 0);
  if (a2)
  {
    if ((v187 & 4) != 0)
      v108 = 2;
    else
      v108 = 4;
    objc::UnattachedCategories::attachToClass(v2, a2, (objc_class *)v108);
  }
  if ((v187 & 4) != 0)
    v109 = 2;
  else
    v109 = 1;
  objc::UnattachedCategories::attachToClass(v2, v2, (objc_class *)v109);
  return v2;
}

unint64_t objc_class::demangledName(objc_class *this, uint64_t a2, const char *a3, char *a4)
{
  int v4;
  uint64_t v6;
  int v7;
  char *v8;
  char *v9;
  _DWORD *v10;
  unint64_t v11;
  unsigned int v12;
  uint64_t v14;
  _QWORD *v15;
  unint64_t StatusReg;
  unsigned int v17;
  int32x2_t *v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  void *v30;
  unint64_t *v31;
  void *v34;
  char **v35;

  v4 = a2;
  if ((unint64_t)(*(_QWORD *)this - 1) >= 0xF)
  {
    v6 = *((_QWORD *)this + 4);
    v7 = *(_DWORD *)(v6 & 0xF00007FFFFFFFF8);
    if (v7 < 0)
    {
      if ((v7 & 0x40000000) == 0 && ((*((_WORD *)this + 15) & 4) != 0 || (v6 & 3) != 0))
      {
        v24 = *(_QWORD *)((v6 & 0xF00007FFFFFFFF8) + 8);
        if ((v24 & 1) != 0)
        {
          v25 = v24 & 0xFFFFFFFFFFFFFFFELL;
          if (v25)
          {
            v8 = *(char **)(v25 + 32);
            if (v8)
              return (unint64_t)v8;
          }
        }
        goto LABEL_4;
      }
    }
    else if ((v7 & 0x40000000) == 0)
    {
      goto LABEL_4;
    }
    v14 = *(_QWORD *)((v6 & 0xF00007FFFFFFFF8) + 8);
    v15 = (_QWORD *)(v14 & 0xFFFFFFFFFFFFFFFELL);
    if ((v14 & 1) != 0)
      v15 = (_QWORD *)*v15;
    return atomic_load(v15 + 3);
  }
LABEL_4:
  v8 = (char *)objc_class::mangledName(this, a2, a3, a4);
  v9 = copySwiftV1DemangledName(v8, 0);
  v34 = v9;
  if ((unint64_t)(*(_QWORD *)this - 1) >= 0xF
    && (v10 = (_DWORD *)(*((_QWORD *)this + 4) & 0xF00007FFFFFFFF8), *v10 >> 30))
  {
    if (v4)
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v17 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr((unsigned int *)&runtimeLock))
      {
        if (!__stxr(v17, (unsigned int *)&runtimeLock))
          goto LABEL_39;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_39:
      v26 = *((_QWORD *)this + 4) & 0xF00007FFFFFFFF8;
      v27 = *(_QWORD *)(v26 + 8);
      v23 = v27 & 0xFFFFFFFFFFFFFFFELL;
      if ((v27 & 1) == 0)
        v23 = class_rw_t::extAlloc(v26, v27 & 0xFFFFFFFFFFFFFFFELL, 0);
      v28 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v29 = __ldxr((unsigned int *)&runtimeLock);
        if (v29 != v28)
          break;
        if (!__stlxr(0, (unsigned int *)&runtimeLock))
          goto LABEL_46;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
    }
    else
    {
      v22 = *(_QWORD *)((*((_QWORD *)this + 4) & 0xF00007FFFFFFFF8) + 8);
      v23 = v22 & 0xFFFFFFFFFFFFFFFELL;
      if ((v22 & 1) == 0)
        v23 = class_rw_t::extAlloc((uint64_t)v10, v22 & 0xFFFFFFFFFFFFFFFELL, 0);
    }
LABEL_46:
    v30 = v34;
    if (!v34)
      v30 = v8;
    v31 = (unint64_t *)(v23 + 32);
    while (!__ldaxr(v31))
    {
      if (!__stlxr((unint64_t)v30, v31))
        return *v31;
    }
    __clrex();
    if (v34)
      free(v34);
    return *v31;
  }
  else if (v9)
  {
    v11 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v12 = *(_DWORD *)(v11 + 24);
    while (!__ldaxr((unsigned int *)&DemangleCacheLock))
    {
      if (!__stxr(v12, (unsigned int *)&DemangleCacheLock))
        goto LABEL_23;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_23:
    v19 = (int32x2_t *)DemangleCache;
    if (!DemangleCache)
    {
      v19 = (int32x2_t *)malloc_type_malloc(0x18uLL, 0xB4ED9BFAuLL);
      *v19 = 0;
      v19[1] = 0;
      v19[2] = 0;
      DemangleCache = (uint64_t)v19;
    }
    objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::try_emplace<objc::detail::DenseSetEmpty&>((uint64_t)&v35, v19, (char **)&v34);
    v8 = *v35;
    v20 = *(_DWORD *)(v11 + 24);
    while (1)
    {
      v21 = __ldxr((unsigned int *)&DemangleCacheLock);
      if (v21 != v20)
        break;
      if (!__stlxr(0, (unsigned int *)&DemangleCacheLock))
        goto LABEL_30;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&DemangleCacheLock);
LABEL_30:
    if (v8 != v34)
      free(v34);
  }
  return (unint64_t)v8;
}

void sub_1801094AC(_Unwind_Exception *exception_object)
{
  os_unfair_lock_s *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(&v1->_os_unfair_lock_opaque);
    if (v5 != v4)
      break;
    if (!__stlxr(0, &v1->_os_unfair_lock_opaque))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock(v1);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void *__cdecl object_getIndexedIvars(id a1)
{
  uint64_t v1;
  unint64_t v2;

  if ((uint64_t)a1 < 1)
    return 0;
  if ((*(_WORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x1E) & 4) != 0)
  {
    if ((*((_BYTE *)a1 + 32) & 3) != 0)
      return (char *)a1 + ((*((_DWORD *)a1 + 14) + 7) & 0xFFFFFFF8) - *((unsigned int *)a1 + 15);
    else
      return (char *)a1 + 40;
  }
  else
  {
    v1 = *(_QWORD *)((*(_QWORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8) + 8);
    v2 = v1 & 0xFFFFFFFFFFFFFFFELL;
    if ((v1 & 1) != 0)
      v2 = *(_QWORD *)v2;
    return (char *)a1 + ((*(_DWORD *)(v2 + 8) + 7) & 0xFFFFFFF8);
  }
}

unint64_t remapClass(unint64_t result)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned int v4;
  int v5;

  if (result && byte_1ECCE4EC8 && dword_1ECCE4EC0)
  {
    LODWORD(v1) = (dword_1ECCE4EC0 - 1) & (bswap64(0x8A970BE7488FDA55 * (result ^ (result >> 4))) ^ (1217387093 * (result ^ (result >> 4))));
    v2 = (uint64_t *)(remappedClasses(BOOL)::remapped_class_map + 16 * v1);
    v3 = *v2;
    if (*v2 == result)
    {
LABEL_5:
      if (v2 != (uint64_t *)(remappedClasses(BOOL)::remapped_class_map + 16 * dword_1ECCE4EC0))
        return v2[1];
    }
    else
    {
      v4 = 1;
      while (v3 != -1)
      {
        if (v4 > dword_1ECCE4EC0)
          objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::FatalCorruptHashTables((_QWORD *)remappedClasses(BOOL)::remapped_class_map, dword_1ECCE4EC0);
        v5 = v1 + v4++;
        v1 = v5 & (dword_1ECCE4EC0 - 1);
        v3 = *(_QWORD *)(remappedClasses(BOOL)::remapped_class_map + 16 * v1);
        if (v3 == result)
        {
          v2 = (uint64_t *)(remappedClasses(BOOL)::remapped_class_map + 16 * v1);
          goto LABEL_5;
        }
      }
    }
  }
  return result;
}

void prepareMethodLists(_QWORD *a1, method_list_t **a2, int a3, char *a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  objc_cache *v11;
  BOOL v12;
  uint64_t v13;
  method_list_t **v14;
  int v15;
  uint64_t v16;
  unsigned int **v17;
  unint64_t v18;
  unsigned int *v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  char *v28;
  BOOL v31;
  BOOL v32;
  BOOL v33;
  BOOL v34;
  BOOL v35;
  BOOL v36;
  BOOL v38;
  BOOL v39;
  BOOL v40;
  BOOL v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v46;
  unint64_t i;
  uint64_t v48;
  char *v49;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  char *v66;
  BOOL v69;
  BOOL v70;
  BOOL v71;
  BOOL v72;
  BOOL v73;
  BOOL v74;
  BOOL v76;
  BOOL v77;
  BOOL v78;
  BOOL v79;

  if (!a3)
    return;
  if ((a4 & 1) == 0)
  {
    v11 = (objc_cache *)a1[2];
    if ((v11 & 1) != 0 || (v11 != &_objc_empty_cache ? (v12 = HIWORD(a1[2]) == 0) : (v12 = 0), v12))
    {
      objc_class::setDisallowPreoptCachesRecursively((uint64_t)a1, (const char *)a6);
    }
    else if ((*(_BYTE *)(a1[4] & 0xF00007FFFFFFFF8) & 4) == 0)
    {
      if (a3 <= 0)
        goto LABEL_17;
      goto LABEL_13;
    }
  }
  if (a3 < 1)
    goto LABEL_17;
LABEL_13:
  v13 = a3;
  v14 = a2;
  do
  {
    if ((~*(_DWORD *)*v14 & 3) != 0)
      fixupMethodList(*v14, a5, (const char *)1, a4);
    ++v14;
    --v13;
  }
  while (v13);
LABEL_17:
  v15 = *(_DWORD *)(a1[4] & 0xF00007FFFFFFFF8);
  if ((v15 & 1) == 0)
    v15 = *(_DWORD *)(*(_QWORD *)((*a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v15 & 0x20000000) != 0 && a3 >= 1)
  {
    v16 = 0;
    v17 = (unsigned int **)&a2[a3];
    do
    {
      v19 = (unsigned int *)*a2++;
      v18 = (unint64_t)v19;
      v20 = *v19;
      v21 = v20 >> 31;
      if ((v20 & 0x80000000) != 0)
      {
        v42 = (unsigned __int16)v20 & 0xFFFC;
        v43 = *(unsigned int *)(v18 + 4);
        v44 = v43 * v42;
        if (dataSegmentsRanges <= v18 && *(_QWORD *)algn_1ECCE5978 > v18)
        {
          if ((v44 & 0xFFFFFFFF00000000) != 0)
LABEL_203:
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v16, sel_retainCount, sel_allowsWeakReference, sel_retainWeakReference, a6, a7, sel_isKindOfClass_, v43, v18, v42);
          v63 = (v18 + 8) & 0xFFFFFFFFFFFFFFFCLL | v21;
          v64 = (v18 + 8 + v44) & 0xFFFFFFFFFFFFFFFCLL | v21;
          while (v63 != v64)
          {
            v65 = 0;
            while (1)
            {
              v66 = (char *)&unk_1F25805A8 + *(int *)((v63 + v65) & 0xFFFFFFFFFFFFFFFCLL);
              a6 = (unint64_t)v66 & objc::InterestingSelectorZeroes;
              a7 = objc::InterestingSelectorOnes & (unint64_t)v66;
              if (((unint64_t)v66 & objc::InterestingSelectorZeroes) == 0 && a7 == objc::InterestingSelectorOnes)
                break;
              v65 += v42;
              a6 = v63 + v65;
              if (v63 + v65 == v64)
                goto LABEL_140;
            }
            if (sel_alloc == v66 || sel_allocWithZone_ == v66)
            {
              v16 = v16 | 1;
            }
            else
            {
              v69 = sel_retain == v66 || sel_release == v66;
              v70 = v69 || sel_autorelease == v66;
              v71 = v70 || sel__tryRetain == v66;
              v72 = v71 || sel__isDeallocating == v66;
              v73 = v72 || sel_retainCount == v66;
              v74 = v73 || sel_allowsWeakReference == v66;
              if (v74 || sel_retainWeakReference == v66)
              {
                v16 = v16 | 4;
              }
              else
              {
                v76 = sel_respondsToSelector_ == v66 || sel_isKindOfClass_ == v66;
                v77 = v76 || sel_class == v66;
                v78 = v77 || sel_self == v66;
                v79 = v78 || &sel_new == (_UNKNOWN *)v66;
                v16 = v79 ? v16 | 0x10 : v16;
              }
            }
            if ((_DWORD)v16 == 21)
              break;
            v63 += v65 + v42;
          }
        }
        else
        {
          if ((v44 & 0xFFFFFFFF00000000) != 0)
            goto LABEL_203;
          a6 = (v18 + 8) & 0xFFFFFFFFFFFFFFFCLL;
          a7 = v21;
          v46 = a6 | v21;
          for (i = (v18 + 8 + v44) & 0xFFFFFFFFFFFFFFFCLL | v21;
                v46 != i;
                v46 += v48 + v42)
          {
            v48 = 0;
            while (1)
            {
              v49 = *(char **)(((v46 + v48) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v46 + v48) & 0xFFFFFFFFFFFFFFFCLL));
              a6 = objc::InterestingSelectorZeroes & (unint64_t)v49;
              a7 = objc::InterestingSelectorOnes & (unint64_t)v49;
              if ((objc::InterestingSelectorZeroes & (unint64_t)v49) == 0 && a7 == objc::InterestingSelectorOnes)
                break;
              v48 += v42;
              a6 = v46 + v48;
              if (v46 + v48 == i)
                goto LABEL_140;
            }
            if (sel_alloc == v49 || sel_allocWithZone_ == v49)
            {
              v16 = v16 | 1;
            }
            else if (sel_retain == v49
                   || sel_release == v49
                   || sel_autorelease == v49
                   || sel__tryRetain == v49
                   || sel__isDeallocating == v49
                   || sel_retainCount == v49
                   || sel_allowsWeakReference == v49
                   || sel_retainWeakReference == v49)
            {
              v16 = v16 | 4;
            }
            else if (sel_respondsToSelector_ == v49
                   || sel_isKindOfClass_ == v49
                   || sel_class == v49
                   || sel_self == v49
                   || &sel_new == (_UNKNOWN *)v49)
            {
              v16 = v16 | 0x10;
            }
            else
            {
              v16 = v16;
            }
            if ((_DWORD)v16 == 21)
              break;
          }
        }
      }
      else
      {
        v22 = (unsigned __int16)v20 & 0xFFFC;
        v23 = *(unsigned int *)(v18 + 4);
        v24 = v23 * (unint64_t)v22;
        if ((v24 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v16, sel_retainCount, sel_allowsWeakReference, sel_retainWeakReference, a6, a7, sel_isKindOfClass_, v23, v18, v22);
        a6 = (v18 + 8) & 0xFFFFFFFFFFFFFFFCLL;
        a7 = v21;
        v25 = a6 | v21;
        v26 = (v18 + 8 + v24) & 0xFFFFFFFFFFFFFFFCLL | v21;
        while (v25 != v26)
        {
          v27 = 0;
          while (1)
          {
            v28 = *(char **)((v25 + v27) & 0xFFFFFFFFFFFFFFFCLL);
            a6 = objc::InterestingSelectorZeroes & (unint64_t)v28;
            a7 = objc::InterestingSelectorOnes & (unint64_t)v28;
            if ((objc::InterestingSelectorZeroes & (unint64_t)v28) == 0 && a7 == objc::InterestingSelectorOnes)
              break;
            v27 += v22;
            a6 = v25 + v27;
            if (v25 + v27 == v26)
              goto LABEL_140;
          }
          if (sel_alloc == v28 || sel_allocWithZone_ == v28)
          {
            v16 = v16 | 1;
          }
          else
          {
            v31 = sel_retain == v28 || sel_release == v28;
            v32 = v31 || sel_autorelease == v28;
            v33 = v32 || sel__tryRetain == v28;
            v34 = v33 || sel__isDeallocating == v28;
            v35 = v34 || sel_retainCount == v28;
            v36 = v35 || sel_allowsWeakReference == v28;
            if (v36 || sel_retainWeakReference == v28)
            {
              v16 = v16 | 4;
            }
            else
            {
              v38 = sel_respondsToSelector_ == v28 || sel_isKindOfClass_ == v28;
              v39 = v38 || sel_class == v28;
              v40 = v39 || sel_self == v28;
              v41 = v40 || &sel_new == (_UNKNOWN *)v28;
              v16 = v41 ? v16 | 0x10 : v16;
            }
          }
          if ((_DWORD)v16 == 21)
            break;
          v25 += v27 + v22;
        }
      }
LABEL_140:
      ;
    }
    while (a2 < (method_list_t **)v17);
    if ((_DWORD)v16)
      objc::Scanner::propagateCustomFlags((uint64_t)a1, v16, 0);
  }
}

uint64_t addSubclass(uint64_t result, objc_class *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int16 v6;
  unsigned __int16 *v7;
  unsigned __int16 v8;
  unsigned __int16 *v9;
  unsigned __int16 v10;
  unsigned __int16 *v11;
  unsigned __int16 v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  _QWORD v18[6];

  if (!result || !a2)
    return result;
  v3 = result;
  ++objc_debug_realized_class_generation_count;
  v4 = *(_QWORD *)(result + 32) & 0xF00007FFFFFFFF8;
  v5 = *((_QWORD *)a2 + 4);
  *(_QWORD *)((v5 & 0xF00007FFFFFFFF8) + 0x18) = *(_QWORD *)(v4 + 0x10);
  *(_QWORD *)(v4 + 16) = a2;
  v6 = *(_WORD *)(result + 30);
  if ((v6 & 2) != 0)
  {
    v7 = (unsigned __int16 *)((char *)a2 + 30);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 | 2, v7));
    v6 = *(_WORD *)(result + 30);
    if ((v6 & 1) == 0)
    {
LABEL_5:
      if ((v6 & 0x1000) == 0)
        goto LABEL_16;
      goto LABEL_13;
    }
  }
  else if ((v6 & 1) == 0)
  {
    goto LABEL_5;
  }
  v9 = (unsigned __int16 *)((char *)a2 + 30);
  do
    v10 = __ldxr(v9);
  while (__stxr(v10 | 1, v9));
  v6 = *(_WORD *)(result + 30);
  if ((v6 & 0x1000) != 0)
  {
LABEL_13:
    v11 = (unsigned __int16 *)((char *)a2 + 30);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 | 0x1000, v11));
    v6 = *(_WORD *)(result + 30);
  }
LABEL_16:
  v13 = *(_QWORD *)(result + 32);
  if (v6 >= 0)
    v14 = (v13 & 4 | ((v6 & 0x4000) == 0)) ^ 4 | 0x10;
  else
    v14 = (v13 & 4 | ((v6 & 0x4000) == 0)) ^ 4;
  if ((*((_WORD *)a2 + 15) & 0x4000) == 0)
    v14 &= 0xFFFFFFFC;
  if ((v5 & 4) != 0)
    v15 = v14;
  else
    v15 = v14 & 0xFFFFFFF3;
  if (*((__int16 *)a2 + 15) >= 0)
    v16 = v15 & 0xFFFFFFEF;
  else
    v16 = v15;
  if (v16)
  {
    result = objc::Scanner::propagateCustomFlags((uint64_t)a2, v16, 1);
    v13 = *(_QWORD *)(v3 + 32);
  }
  v17 = *(_DWORD *)(v13 & 0xF00007FFFFFFFF8);
  if ((v17 & 2) != 0)
  {
    result = objc_class::setDisallowPreoptCachesRecursively((uint64_t)a2, "addSubclass");
  }
  else if ((v17 & 4) != 0 && (*(_BYTE *)(*((_QWORD *)a2 + 4) & 0xF00007FFFFFFFF8) & 4) == 0)
  {
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3321888768;
    v18[2] = ___ZN10objc_class39setDisallowPreoptInlinedSelsRecursivelyEPKc_block_invoke;
    v18[3] = &__block_descriptor_48_e8_32c69_ZTSKZN10objc_class39setDisallowPreoptInlinedSelsRecursivelyEPKcE3__0_e8_B16__0_8l;
    v18[4] = a2;
    v18[5] = "addSubclass";
    result = foreach_realized_class_and_subclass((uint64_t)a2, (uint64_t)v18);
  }
  if ((*(_WORD *)(v3 + 30) & 0x2000) != 0)
  {
    if (*(_QWORD *)(v3 + 8))
      return objc_class::setInstancesRequireRawIsaRecursively((uint64_t)a2, 1);
  }
  return result;
}

void objc::UnattachedCategories::attachToClass(objc::UnattachedCategories *this, objc_class *a2, objc_class *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  objc_class *v13;
  char *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = 0;
  if (objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class const*>((unint64_t)a2, &v20))
  {
    v8 = (_QWORD *)v20;
    if (v20 != objc::unattachedCategories + 24 * dword_1ECCE59C8)
    {
      v9 = (void **)(v20 + 8);
      if ((a3 & 4) != 0)
      {
        v15 = a3 & 0xFFFFFFFB;
        v16 = *(_QWORD *)(v20 + 16);
        if ((v16 & 1) != 0)
          v17 = *(_QWORD *)(v20 + 8);
        else
          v17 = v20 + 8;
        if ((v16 & 1) != 0)
          v18 = v16 >> 1;
        else
          v18 = *(_QWORD *)(v20 + 8) != 0;
        attachCategories(this, v17, (const char *)v18, (char *)(v15 | 1), v5, v6, v7);
        v13 = (objc_class *)(*(_QWORD *)this & 0xFFFFFFFF8);
        v19 = v8[2];
        if ((v19 & 1) != 0)
          v11 = v8[1];
        else
          v11 = (uint64_t)(v8 + 1);
        if ((v19 & 1) != 0)
          v12 = v19 >> 1;
        else
          v12 = v8[1] != 0;
        v14 = (char *)(v15 | 2);
      }
      else
      {
        v10 = *(_QWORD *)(v20 + 16);
        if ((v10 & 1) != 0)
          v11 = *(_QWORD *)(v20 + 8);
        else
          v11 = v20 + 8;
        if ((v10 & 1) != 0)
          v12 = v10 >> 1;
        else
          v12 = *(_QWORD *)(v20 + 8) != 0;
        v13 = this;
        v14 = (char *)a3;
      }
      attachCategories(v13, v11, (const char *)v12, v14, v5, v6, v7);
      if ((v8[2] & 1) != 0)
        free(*v9);
      *v8 = -2;
      qword_1ECCE59C0 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE59C0, (int32x2_t)0x1FFFFFFFFLL);
      objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::compact();
    }
  }
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class const*>(unint64_t a1, _QWORD *a2)
{
  int v2;
  unsigned int v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;

  if (dword_1ECCE59C8)
  {
    v2 = dword_1ECCE59C8 - 1;
    v3 = (dword_1ECCE59C8 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093 * (a1 ^ (a1 >> 4))));
    v4 = (_QWORD *)(objc::unattachedCategories + 24 * v3);
    v5 = *v4;
    if (*v4 == a1)
    {
      v6 = 1;
    }
    else
    {
      v8 = 0;
      v9 = 1;
      while (v5 != -1)
      {
        if (v9 > dword_1ECCE59C8)
          objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::FatalCorruptHashTables((_QWORD *)objc::unattachedCategories, dword_1ECCE59C8);
        if (v8)
          v10 = 0;
        else
          v10 = v5 == -2;
        if (v10)
          v8 = v4;
        v11 = v3 + v9++;
        v3 = v11 & v2;
        v4 = (_QWORD *)(objc::unattachedCategories + 24 * (v11 & v2));
        v5 = *v4;
        v6 = 1;
        if (*v4 == a1)
          goto LABEL_5;
      }
      v6 = 0;
      if (v8)
        v4 = v8;
    }
  }
  else
  {
    v4 = 0;
    v6 = 0;
  }
LABEL_5:
  *a2 = v4;
  return v6;
}

uint64_t objc_class::setInstancesRequireRawIsaRecursively(uint64_t this, char a2)
{
  _QWORD v2[4];
  char v3;
  uint64_t v4;

  if ((*(_WORD *)(this + 30) & 0x2000) == 0)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3321888768;
    v2[2] = ___ZN10objc_class36setInstancesRequireRawIsaRecursivelyEb_block_invoke;
    v2[3] = &__block_descriptor_48_e8_32c64_ZTSKZN10objc_class36setInstancesRequireRawIsaRecursivelyEbE3__0_e8_B16__0_8l;
    v3 = a2;
    v4 = this;
    return foreach_realized_class_and_subclass(this, (uint64_t)v2);
  }
  return this;
}

void lockAndFinishInitializing(objc_class *this, objc_class *a2, const char *a3, char *a4)
{
  unint64_t StatusReg;
  unsigned int v7;
  int v9;
  const void *v10;
  char *v11;
  char *v12;
  _DWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  int32x2_t *v18;
  char v19;
  _QWORD *v20;
  _QWORD *v21;
  __int32 v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  _QWORD *v26;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&pendingInitializeMapLock))
  {
    if (!__stxr(v7, (unsigned int *)&pendingInitializeMapLock))
    {
      if (!a2)
        goto LABEL_19;
      goto LABEL_7;
    }
  }
  __clrex();
  os_unfair_lock_lock_with_options();
  if (!a2)
  {
LABEL_19:
    _finishInitializing(this, a2, a3, a4);
    goto LABEL_28;
  }
LABEL_7:
  v9 = *(_DWORD *)(*((_QWORD *)a2 + 4) & 0xF00007FFFFFFFF8);
  if ((v9 & 1) == 0)
    v9 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)a2 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v9 & 0x20000000) != 0)
    goto LABEL_19;
  if (PrintInitializing)
  {
    v10 = *(const void **)StatusReg;
    v11 = objc_class::nameForLogging(this);
    v12 = objc_class::nameForLogging(a2);
    _objc_inform("INITIALIZE: thread %p: class %s will be marked as fully +initialized after superclass +[%s initialize] completes", v10, v11, v12);
  }
  if (!pendingInitializeMap)
  {
    v13 = malloc_type_malloc(0x18uLL, 0xB4ED9BFAuLL);
    v13[4] = 16;
    v14 = malloc_type_malloc(0x100uLL, 0x64B88C75uLL);
    *(_QWORD *)v13 = v14;
    *((_QWORD *)v13 + 1) = 0;
    v15 = v13[4];
    if ((_DWORD)v15)
    {
      v16 = 16 * v15;
      do
      {
        *v14 = -1;
        v14 += 2;
        v16 -= 16;
      }
      while (v16);
    }
    pendingInitializeMap = (uint64_t)v13;
  }
  v17 = malloc_type_malloc(0x10uLL, 0xB4ED9BFAuLL);
  *v17 = this;
  v17[1] = 0;
  v18 = (int32x2_t *)pendingInitializeMap;
  v26 = 0;
  v19 = objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::LookupBucketFor<objc_class *>(pendingInitializeMap, (unint64_t)a2, &v26);
  v20 = v26;
  if ((v19 & 1) == 0)
  {
    v22 = v18[1].i32[0];
    v23 = v18[2].u32[0];
    if (4 * v22 + 4 >= 3 * v23)
    {
      objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::grow((uint64_t)v18, 2 * v23);
      v26 = 0;
      objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::LookupBucketFor<objc_class *>((uint64_t)v18, (unint64_t)a2, &v26);
    }
    else
    {
      if (v23 + ~v22 - v18[1].i32[1] > v23 >> 3)
      {
LABEL_22:
        if (*v20 == -2)
        {
          v18[1] = vadd_s32(v18[1], (int32x2_t)0xFFFFFFFF00000001);
        }
        else if (*v20 == -1)
        {
          ++v18[1].i32[0];
        }
        *v20 = a2;
        v21 = v20 + 1;
        goto LABEL_27;
      }
      objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::grow((uint64_t)v18, v23);
      v26 = 0;
      objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::LookupBucketFor<objc_class *>((uint64_t)v18, (unint64_t)a2, &v26);
    }
    v20 = v26;
    goto LABEL_22;
  }
  v21 = v26 + 1;
  v17[1] = v26[1];
LABEL_27:
  *v21 = v17;
LABEL_28:
  v24 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v25 = __ldxr((unsigned int *)&pendingInitializeMapLock);
    if (v25 != v24)
      break;
    if (!__stlxr(0, (unsigned int *)&pendingInitializeMapLock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&pendingInitializeMapLock);
}

void sub_18010A240(_Unwind_Exception *a1)
{
  void *v1;
  unsigned int *v2;
  uint64_t v3;
  int v5;
  unsigned int v6;

  free(v1);
  v5 = *(_DWORD *)(v3 + 24);
  while (1)
  {
    v6 = __ldxr(v2);
    if (v6 != v5)
      break;
    if (!__stlxr(0, v2))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&pendingInitializeMapLock);
LABEL_6:
  _Unwind_Resume(a1);
}

_QWORD *_setThisThreadIsInitializingClass(objc_class *a1)
{
  unsigned int *InitializingClassList;
  uint64_t v3;
  const char *v4;
  char *v5;
  unsigned int *v6;
  uint64_t v7;
  _QWORD *result;
  uint64_t v9;
  objc_class **v10;
  unsigned int v11;
  signed int v12;
  uint64_t v13;

  InitializingClassList = (unsigned int *)_fetchInitializingClassList(1);
  v6 = InitializingClassList;
  if ((unint64_t)(*(_QWORD *)a1 - 1) < 0xF || (*(_BYTE *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) & 1) == 0)
    a1 = (objc_class *)(*(_QWORD *)a1 & 0xFFFFFFFF8);
  v7 = *InitializingClassList;
  result = (_QWORD *)*((_QWORD *)InitializingClassList + 1);
  if ((int)v7 < 1)
  {
    v11 = 0;
  }
  else
  {
    v9 = *v6;
    v10 = (objc_class **)*((_QWORD *)v6 + 1);
    do
    {
      if (a1 == *v10)
        _objc_fatal("thread is already initializing this class!", v3, v4, v5);
      ++v10;
      --v9;
    }
    while (v9);
    do
    {
      if (!result[v9])
      {
        result[v9] = a1;
        return result;
      }
      ++v9;
    }
    while (v7 != v9);
    v11 = *v6;
  }
  v12 = (2 * v7) | 1;
  *v6 = v12;
  result = malloc_type_realloc(result, 8 * v12, 0x80040B8603338uLL);
  *((_QWORD *)v6 + 1) = result;
  result[v11] = a1;
  if ((int)(v11 + 1) < (int)*v6)
  {
    v13 = v11 + 1;
    do
      *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * v13++) = 0;
    while ((int)*v6 > (int)v13);
  }
  return result;
}

id CALLING_SOME__initialize_METHOD(void *a1)
{
  return objc_msgSend(a1, sel_initialize);
}

uint64_t objc_opt_self(uint64_t result)
{
  if (result >= 1 && (*(__int16 *)((*(_QWORD *)result & 0xFFFFFFFF8) + 0x1E) & 0x80000000) == 0)
    return (uint64_t)objc_msgSend((id)result, sel_self);
  return result;
}

uint64_t _objc_rootRelease(uint64_t result)
{
  unint64_t v1;
  BOOL v2;
  unint64_t v3;
  char **v4;

  if ((result & 0x8000000000000000) == 0)
  {
    v1 = __ldxr((unint64_t *)result);
    if ((v1 & 1) != 0)
    {
      while (v1 >> 44)
      {
        v2 = v1 >= 0x200000000000;
        v3 = v1 - 0x200000000000;
        if (!v2)
        {
          __clrex();
          return objc_object::rootRelease_underflow((objc_object *)result, 1);
        }
        if (!__stlxr(v3, (unint64_t *)result))
        {
          if (!(v3 >> 44))
          {
            __dmb(9u);
            if ((*(_WORD *)((*(_QWORD *)result & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0)
              v4 = &selRef__objc_initiateDealloc;
            else
              v4 = &selRef_dealloc;
            return (uint64_t)objc_msgSend((id)result, *v4);
          }
          return result;
        }
        v1 = __ldxr((unint64_t *)result);
        if ((v1 & 1) == 0)
          goto LABEL_12;
      }
    }
    else if ((*(_WORD *)((v1 & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
    {
LABEL_12:
      __clrex();
      return objc_object::sidetable_release((objc_object *)result, 0, 1);
    }
    __clrex();
  }
  return result;
}

Class object_getClass(Class result)
{
  Class v1;

  if (result)
  {
    v1 = result;
    if (((unint64_t)result & 0x8000000000000000) != 0)
    {
      result = (Class)objc_debug_taggedpointer_classes[result & 7];
      if (result == (Class)__NSUnrecognizedTaggedPointer)
        return (Class)objc_debug_taggedpointer_ext_classes[((unint64_t)v1 >> 55)];
    }
    else
    {
      return (Class)(*(_QWORD *)result & 0xFFFFFFFF8);
    }
  }
  return result;
}

unint64_t objc_opt_class(unint64_t result)
{
  uint64_t v1;
  int v2;

  if (result)
  {
    if ((result & 0x8000000000000000) != 0)
    {
      v1 = objc_debug_taggedpointer_classes[result & 7];
      if ((__objc2_class *)v1 == __NSUnrecognizedTaggedPointer)
        v1 = objc_debug_taggedpointer_ext_classes[(result >> 55)];
    }
    else
    {
      v1 = *(_QWORD *)result & 0xFFFFFFFF8;
    }
    v2 = *(__int16 *)(v1 + 30);
    if (v2 < 0)
    {
      if ((v2 & 4) == 0)
        return v1;
    }
    else
    {
      return (unint64_t)objc_msgSend((id)result, sel_class);
    }
  }
  return result;
}

Class class_getSuperclass(Class cls)
{
  if (cls)
    return (Class)*((_QWORD *)cls + 1);
  return cls;
}

void *objc_class::mangledName(objc_class *this, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;

  v4 = *((_QWORD *)this + 4);
  v5 = (_QWORD *)(v4 & 0xF00007FFFFFFFF8);
  if (v4 < 0)
  {
    v6 = *(_QWORD *)((v4 & 0xF00007FFFFFFFF8) + 8);
    v5 = (_QWORD *)(v6 & 0xFFFFFFFFFFFFFFFELL);
    if ((v6 & 1) != 0)
      v5 = (_QWORD *)*v5;
  }
  v7 = atomic_load(v5 + 3);
  if (v7)
    return (void *)v7;
  else
    return objc_class::installMangledNameForLazilyNamedClass(this, a2, a3, a4);
}

uint64_t objc_class::setDisallowPreoptCachesRecursively(uint64_t this, const char *a2)
{
  _QWORD v2[6];

  if ((*(_BYTE *)(*(_QWORD *)(this + 32) & 0xF00007FFFFFFFF8) & 2) == 0)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3321888768;
    v2[2] = ___ZN10objc_class34setDisallowPreoptCachesRecursivelyEPKc_block_invoke;
    v2[3] = &__block_descriptor_48_e8_32c64_ZTSKZN10objc_class34setDisallowPreoptCachesRecursivelyEPKcE3__0_e8_B16__0_8l;
    v2[4] = a2;
    v2[5] = this;
    return foreach_realized_class_and_subclass(this, (uint64_t)v2);
  }
  return this;
}

void objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::compact()
{
  uint64_t v1;
  uint64_t v2;

  if ((_DWORD)qword_1ECCE59C0)
  {
    if (dword_1ECCE59C8 >= 0x401 && dword_1ECCE59C8 >> 4 > qword_1ECCE59C0)
      objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::grow(2 * qword_1ECCE59C0);
  }
  else
  {
    if (!dword_1ECCE59C8)
      goto LABEL_16;
    v1 = 24 * dword_1ECCE59C8;
    v2 = objc::unattachedCategories + 8;
    do
    {
      if (*(_QWORD *)(v2 - 8) <= 0xFFFFFFFFFFFFFFFDLL && (*(_BYTE *)(v2 + 8) & 1) != 0)
        free(*(void **)v2);
      v2 += 24;
      v1 -= 24;
    }
    while (v1);
    if (dword_1ECCE59C8)
    {
      free((void *)objc::unattachedCategories);
      objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::init(0);
    }
    else
    {
LABEL_16:
      qword_1ECCE59C0 = 0;
    }
  }
}

void class_setVersion(Class cls, int version)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t StatusReg;
  unsigned int v7;
  uint64_t v9;
  int v10;
  unsigned int v11;

  if (cls)
  {
    v4 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
    if ((v4 & 1) == 0 || (v5 = v4 & 0xFFFFFFFFFFFFFFFELL, (v4 & 0xFFFFFFFFFFFFFFFELL) == 0))
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v7 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr(runtimeLock))
      {
        if (!__stxr(v7, runtimeLock))
          goto LABEL_9;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_9:
      v9 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
      v5 = v9 & 0xFFFFFFFFFFFFFFFELL;
      if ((v9 & 1) == 0)
        v5 = class_rw_t::extAlloc(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8, v9 & 0xFFFFFFFFFFFFFFFELL, 0);
      v10 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v11 = __ldxr(runtimeLock);
        if (v11 != v10)
          break;
        if (!__stlxr(0, runtimeLock))
          goto LABEL_16;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
LABEL_16:
    *(_DWORD *)(v5 + 40) = version;
  }
}

void sub_18010A964(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t objc::Scanner::propagateCustomFlags(uint64_t a1, char a2, int a3)
{
  _QWORD v4[5];
  int v5;
  char v6;
  BOOL v7;
  BOOL v8;

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3321888768;
  v4[2] = ___ZN4objc7Scanner20propagateCustomFlagsEP10objc_classjNS0_11inherited_tE_block_invoke;
  v4[3] = &__block_descriptor_48_e8_32c83_ZTSKZN4objc7Scanner20propagateCustomFlagsEP10objc_classjNS0_11inherited_tEEUlS2_E__e8_B16__0_8l;
  v4[4] = a1;
  v5 = a3;
  v6 = a2 & 1;
  v7 = (a2 & 4) != 0;
  v8 = (a2 & 0x10) != 0;
  return foreach_realized_class_and_subclass(a1, (uint64_t)v4);
}

void *objc_class::installMangledNameForLazilyNamedClass(objc_class *this, uint64_t a2, const char *a3, char *a4)
{
  objc_class *v4;
  uint64_t (*v5)(objc_class *);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  char *v10;
  void *v11;
  objc_class *v12;
  unint64_t StatusReg;
  unsigned int v14;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  int v21;
  unsigned int v22;

  v4 = this;
  v5 = (uint64_t (*)(objc_class *))atomic_load((unint64_t *)&LazyClassNamerHook);
  if (!v5)
    goto LABEL_24;
  if ((*((_WORD *)this + 15) & 4) != 0)
  {
    while (1)
    {
      v18 = *((_QWORD *)v4 + 4);
      v19 = (_QWORD *)(v18 & 0xF00007FFFFFFFF8);
      if (v18 < 0)
      {
        v20 = *(_QWORD *)((v18 & 0xF00007FFFFFFFF8) + 8);
        v19 = (_QWORD *)(v20 & 0xFFFFFFFFFFFFFFFELL);
        if ((v20 & 1) != 0)
          v19 = (_QWORD *)*v19;
      }
      v4 = (objc_class *)v19[2];
      v5 = (uint64_t (*)(objc_class *))atomic_load((unint64_t *)&LazyClassNamerHook);
      if (!v5)
        break;
      if ((*((_WORD *)v4 + 15) & 4) == 0)
        goto LABEL_3;
    }
LABEL_24:
    _objc_fatal("Lazily named class %p with no lazy name handler registered", a2, a3, a4, v4);
  }
LABEL_3:
  v6 = *(_QWORD *)v4;
  v7 = v5(v4);
  if (!v7)
    _objc_fatal("Lazily named class %p wasn't named by lazy name handler", v8, v9, v10, v4);
  v11 = (void *)v7;
  v12 = (objc_class *)(v6 & 0xFFFFFFFF8);
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v14 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&runtimeLock))
  {
    if (!__stxr(v14, (unsigned int *)&runtimeLock))
      goto LABEL_9;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_9:
  v16 = (unint64_t *)(make_ro_writeable_nolock(v4) + 24);
  v17 = atomic_load(v16);
  if (v17)
  {
    free(v11);
    v11 = (void *)v17;
  }
  else
  {
    atomic_store((unint64_t)v11, v16);
    atomic_store((unint64_t)v11, (unint64_t *)(make_ro_writeable_nolock(v12) + 24));
    addNamedClass(v4, (char *)v11, 0);
  }
  v21 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v22 = __ldxr((unsigned int *)&runtimeLock);
    if (v22 != v21)
      break;
    if (!__stlxr(0, (unsigned int *)&runtimeLock))
      return v11;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
  return v11;
}

void _class_setCustomDeallocInitiation(uint64_t a1)
{
  unint64_t StatusReg;
  unsigned int v3;
  int v5;
  unsigned int v6;
  _QWORD v7[5];

  if ((*(_WORD *)(a1 + 30) & 0x1000) == 0)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v3 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v3, runtimeLock))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_7:
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3321888768;
    v7[2] = ___class_setCustomDeallocInitiation_block_invoke;
    v7[3] = &__block_descriptor_33_e8_32c46_ZTSKZ33_class_setCustomDeallocInitiationE3__0_e8_B16__0_8l;
    foreach_realized_class_and_subclass(a1, (uint64_t)v7);
    v5 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v6 = __ldxr(runtimeLock);
      if (v6 != v5)
        break;
      if (!__stlxr(0, runtimeLock))
        return;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_18010ACA8(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

Class objc_getClass(Class name)
{
  if (name)
    return look_up_class((char *)name);
  return name;
}

const char *__cdecl property_getName(objc_property_t property)
{
  return *(const char **)property;
}

int objc_sync_exit(id obj)
{
  uint64_t v1;
  char *v2;
  int v4;

  v4 = _objc_sync_exit_kind((uint64_t)obj, 1, v1, v2);
  if (v4 && DebugSyncErrors)
  {
    if (DebugSyncErrors == 2)
      ((void (*)(const char *, ...))_objc_fatal)("objc_sync_exit(%p) returned error %d", obj, -1);
    _objc_inform("objc_sync_exit(%p) returned error %d", obj, -1);
  }
  return v4;
}

int objc_sync_enter(id obj)
{
  uint64_t v1;
  char *v2;

  _objc_sync_enter_kind((uint64_t)obj, 1, v1, v2);
  return 0;
}

uint64_t _objc_sync_exit_kind(uint64_t result, uint64_t a2, uint64_t a3, char *a4)
{
  if (result)
  {
    if (id2data(result, a2, (const char *)1, a4))
      return os_unfair_recursive_lock_tryunlock4objc() - 1;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t _objc_sync_enter_kind(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t result;
  uint64_t v5;
  const char *v6;
  char *v7;

  if (a1)
  {
    id2data(a1, a2, 0, a4);
    return os_unfair_recursive_lock_lock_with_options();
  }
  else
  {
    if (DebugNilSync)
      _objc_inform("NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug");
    result = gdb_objc_class_changed();
    if (DebugNilSync == 2)
      _objc_fatal("@synchronized(nil) is fatal", v5, v6, v7);
  }
  return result;
}

_DWORD *id2data(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  int v4;
  unsigned int v5;
  unint64_t StatusReg;
  _DWORD *v8;
  unsigned int *v9;
  uint64_t v10;
  int *cache;
  uint64_t v12;
  const char *v13;
  char *v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  void **v18;
  _DWORD *v19;
  os_unfair_lock_s *v20;
  unsigned int *p_os_unfair_lock_opaque;
  unsigned int v22;
  unsigned int *v24;
  unsigned int *v25;
  char *v26;
  unsigned int *v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  void *v31;
  BOOL v32;
  uint64_t v33;
  int *v34;
  unsigned int *v35;
  int *v36;
  _DWORD *v37;
  int v38;
  int v39;
  uint64_t v40;
  unsigned int v41;
  int v43;
  unsigned int v44;
  void *memptr;

  v4 = (int)a3;
  v5 = a2;
  memptr = 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v8 = *(_DWORD **)(StatusReg + 328);
  if (v8 && !(*((_QWORD *)v8 + 1) + a1) && v8[4] == (_DWORD)a2)
  {
    memptr = *(void **)(StatusReg + 328);
    v9 = v8 + 5;
    if ((int)v8[5] < 1 || (v10 = *(_QWORD *)(StatusReg + 336)) == 0)
      _objc_fatal("id2data fastcache is buggy", a2, a3, a4);
    if ((_DWORD)a3 != 1)
    {
      if (!(_DWORD)a3)
        *(_QWORD *)(StatusReg + 336) = v10 + 1;
      return v8;
    }
    v40 = v10 - 1;
    *(_QWORD *)(StatusReg + 336) = v40;
    if (v40)
      return v8;
    *(_QWORD *)(StatusReg + 328) = 0;
    do
      v41 = __ldaxr(v9);
    while (__stlxr(v41 - 1, v9));
    return memptr;
  }
  cache = fetch_cache(0);
  v15 = cache;
  if (!cache || (v16 = cache[1], !(_DWORD)v16))
  {
LABEL_15:
    v20 = (os_unfair_lock_s *)((char *)&sDataLists
                             + 64
                             * (unint64_t)(((a1 >> 4) ^ (a1 >> 9)) & 7));
    p_os_unfair_lock_opaque = &v20[2]._os_unfair_lock_opaque;
    v22 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(p_os_unfair_lock_opaque))
    {
      if (!__stxr(v22, p_os_unfair_lock_opaque))
        goto LABEL_20;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_20:
    v24 = *(unsigned int **)&v20->_os_unfair_lock_opaque;
    if (*(_QWORD *)&v20->_os_unfair_lock_opaque)
    {
      v25 = 0;
      do
      {
        if (!(*((_QWORD *)v24 + 1) + a1) && v24[4] == v5)
        {
          memptr = v24;
          v27 = v24 + 5;
          do
            v28 = __ldaxr(v27);
          while (__stlxr(v28 + 1, v27));
          goto LABEL_36;
        }
        if (!v25)
        {
          if (v24[5])
            v25 = 0;
          else
            v25 = v24;
        }
        v24 = *(unsigned int **)v24;
      }
      while (v24);
      if (v4 == 1)
        goto LABEL_36;
      if (v25)
      {
        memptr = v25;
        *((_QWORD *)v25 + 1) = -a1;
        v25[4] = v5;
        v25[5] = 1;
        goto LABEL_36;
      }
    }
    else if (v4 == 1)
    {
      goto LABEL_36;
    }
    malloc_type_posix_memalign(&memptr, 0x40uLL, 0x40uLL, 0x10A0040571A19FAuLL);
    v26 = (char *)memptr;
    *((_QWORD *)memptr + 1) = -a1;
    *((_DWORD *)v26 + 4) = v5;
    *(_QWORD *)(v26 + 20) = 1;
    *((_DWORD *)v26 + 7) = 0;
    *(_QWORD *)v26 = *(_QWORD *)&v20->_os_unfair_lock_opaque;
    *(_QWORD *)&v20->_os_unfair_lock_opaque = memptr;
LABEL_36:
    v29 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v30 = __ldxr(p_os_unfair_lock_opaque);
      if (v30 != v29)
        break;
      if (!__stlxr(0, p_os_unfair_lock_opaque))
        goto LABEL_41;
    }
    __clrex();
    os_unfair_lock_unlock(v20 + 2);
LABEL_41:
    v31 = memptr;
    if (memptr)
      v32 = v4 == 1;
    else
      v32 = 1;
    if (v32)
      return 0;
    if (*((_QWORD *)memptr + 1) + a1 || *((_DWORD *)memptr + 4) != v5)
      _objc_fatal("id2data is buggy", v12, v13, v14);
    if (!v8)
    {
      *(_QWORD *)(StatusReg + 328) = memptr;
      *(_QWORD *)(StatusReg + 336) = 1;
      return v31;
    }
    if (!v15)
    {
      v15 = fetch_cache(1);
      v31 = memptr;
    }
    v33 = v15[1];
    v34 = &v15[4 * v33];
    *((_QWORD *)v34 + 1) = v31;
    v34[4] = 1;
    v15[1] = v33 + 1;
    return memptr;
  }
  v17 = 0;
  v18 = (void **)(cache + 2);
  while (1)
  {
    v19 = *v18;
    if (!(*((_QWORD *)*v18 + 1) + a1) && v19[4] == v5)
      break;
    ++v17;
    v18 += 2;
    if (v16 == v17)
      goto LABEL_15;
  }
  memptr = *v18;
  v35 = v19 + 5;
  if ((int)v19[5] < 1 || (v36 = &cache[4 * v17], v39 = v36[4], v37 = v36 + 4, (v38 = v39) == 0))
    _objc_fatal("id2data cache is buggy", v12, v13, v14);
  if (v4 == 1)
  {
    v8 = v19;
    *v37 = v38 - 1;
    if (v38 != 1)
      return v8;
    v43 = v16 - 1;
    cache[1] = v43;
    *(_OWORD *)v18 = *(_OWORD *)&cache[4 * v43 + 2];
    do
      v44 = __ldaxr(v35);
    while (__stlxr(v44 - 1, v35));
    return memptr;
  }
  if (!v4)
    *v37 = v38 + 1;
  return v19;
}

int *fetch_cache(int a1)
{
  unint64_t StatusReg;
  _OWORD *v3;
  int *result;
  int v5;
  unsigned int v6;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_OWORD **)(StatusReg + 320);
  if (!a1 || v3)
  {
    if (!v3)
      return 0;
  }
  else
  {
    v3 = malloc_type_malloc(0x48uLL, 0xB4ED9BFAuLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    *((_QWORD *)v3 + 8) = 0;
    *(_QWORD *)(StatusReg + 320) = v3;
  }
  result = (int *)*((_QWORD *)v3 + 1);
  if (result)
  {
    v5 = *result;
    goto LABEL_9;
  }
  if (!a1)
    return 0;
  result = (int *)malloc_type_calloc(1uLL, 0x48uLL, 0x17782B40uLL);
  *((_QWORD *)v3 + 1) = result;
  v5 = 4;
  *result = 4;
LABEL_9:
  if (v5 == result[1])
  {
    v6 = 2 * v5;
    *result = v6;
    result = (int *)malloc_type_realloc(result, (32 * (v6 >> 1)) | 8, 0x675CCBBCuLL);
    *((_QWORD *)v3 + 1) = result;
  }
  return result;
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  void **v4;
  id v5;
  unsigned int *v6;
  unint64_t StatusReg;
  unsigned int v8;
  void *v10;
  int v11;
  unsigned int v12;

  if (offset)
  {
    v4 = (void **)((char *)self + offset);
    v5 = objc_msgSend(newValue, sel_copyWithZone_, 0);
    v6 = (unsigned int *)&PropertyLocks[16
                                      * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)];
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v8 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(v6))
    {
      if (!__stxr(v8, v6))
        goto LABEL_8;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_8:
    v10 = *v4;
    *v4 = v5;
    v11 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v12 = __ldxr(v6);
      if (v12 != v11)
        break;
      if (!__stlxr(0, v6))
        goto LABEL_13;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&PropertyLocks[16
                                                         * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)]);
LABEL_13:

  }
  else
  {
    object_setClass(self, (Class)newValue);
  }
}

unint64_t _thisThreadIsInitializingClass(_QWORD *a1)
{
  unint64_t result;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  result = (unint64_t)_fetchInitializingClassList(0);
  if (result)
  {
    if ((unint64_t)(*a1 - 1) < 0xF || (*(_BYTE *)(a1[4] & 0xF00007FFFFFFFF8) & 1) == 0)
      a1 = (_QWORD *)(*a1 & 0xFFFFFFFF8);
    v3 = *(unsigned int *)result;
    if ((int)v3 < 1)
    {
      return 0;
    }
    else
    {
      v4 = *(_QWORD **)(result + 8);
      v5 = v3 - 1;
      do
      {
        v6 = (_QWORD *)*v4++;
        result = a1 == v6;
      }
      while (a1 != v6 && v5-- != 0);
    }
  }
  return result;
}

Method *__cdecl class_copyMethodList(Class cls, unsigned int *outCount)
{
  uint64_t v2;
  unint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  unint64_t StatusReg;
  unsigned int v8;
  Method *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _BOOL4 v17;
  unsigned int *v18;
  uint64_t v19;
  unsigned int *v20;
  unint64_t v21;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unsigned int v26;
  BOOL v27;
  BOOL v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unsigned int *v33;
  uint64_t v34;
  unsigned int v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  const char *v41;
  char *v42;
  uint64_t v43;
  unsigned int *v44;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t *v49;
  unsigned __int16 *v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  const char *v56;
  char *v57;
  unint64_t v58;
  uint64_t *v59;
  unint64_t v60;
  uint64_t *v61;
  uint64_t *v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  int v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  int v73;
  uint64_t v74;
  unsigned int *v75;
  unsigned int *v76;
  uint64_t *v77;
  unsigned int v78;
  uint64_t v79;
  int *v80;
  uint64_t v81;
  unsigned int *v82;
  int v83;
  unsigned int v84;
  unint64_t v86;
  BOOL v87;
  unint64_t v88;
  unint64_t v89;
  BOOL v90;
  uint64_t *v91;
  unint64_t v92;
  unint64_t v93;
  unsigned __int16 *v94;
  uint64_t v95;
  uint64_t *v96;
  unsigned int *v97;
  unsigned int v98;
  int v99;
  uint64_t *v100;
  uint64_t *v101;
  unsigned int *v102;
  uint64_t *v103;
  uint64_t v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t *v109;
  unsigned int *v110;
  unint64_t *v111;
  uint64_t v112;
  unint64_t *v113;
  uint64_t v114;
  _QWORD *v115;
  uint64_t v116;

  v5 = outCount;
  if (!cls)
  {
    v10 = 0;
    if (outCount)
      *outCount = 0;
    return v10;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v8 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v8, runtimeLock))
      goto LABEL_9;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_9:
  v11 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
  v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
  if ((v11 & 1) != 0)
  {
    v14 = *(_QWORD *)(v12 + 8);
  }
  else
  {
    v13 = *(_QWORD *)(v12 + 32);
    v14 = v13 & 0xFFFFFFFFFFFFFFFELL;
    if ((v13 & 1) != 0)
      v15 = v13 & 0xFFFFFFFFFFFFFFFELL;
    else
      v15 = 0;
    if ((v13 & 1) != 0 || !v14)
    {
      if (v15)
        v14 = v15 | 2;
      else
        v14 = 0;
    }
  }
  v108 = v14;
  v16 = v14 & 3;
  v17 = v16 != 0;
  v18 = (unsigned int *)(v14 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v14 & 0xFFFFFFFFFFFFFFFCLL) == 0)
    v17 = 1;
  if (!v17)
  {
    v19 = 0;
    v21 = 0;
    v20 = (unsigned int *)(v14 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_44:
    v27 = !v17;
    v28 = v16 != 2;
    goto LABEL_45;
  }
  if (v14 >= 4)
  {
    if (v16 != 1 || v18 == 0)
    {
      if (v16 == 2)
        v20 = (unsigned int *)(v14 & 0xFFFFFFFFFFFFFFFCLL);
      else
        v20 = 0;
      if (v20)
      {
        if (DisablePreattachedCategories)
        {
          v23 = *v20;
          v3 = v20[1];
          v86 = v3 * (unint64_t)v23;
          if ((v86 & 0xFFFFFFFF00000000) != 0)
            goto LABEL_194;
          v4 = (unsigned int *)((char *)v20 + v86 + 8);
          v87 = (_DWORD)v3 == 0;
          if ((_DWORD)v3)
            v3 = v3;
          else
            v3 = 0;
          if (!v87)
            v4 = (unsigned int *)((char *)v4 - v23);
        }
        else
        {
          v4 = v20 + 2;
          v23 = *v20;
          v3 = v20[1];
        }
        v24 = v3 * (unint64_t)v23;
        if ((v24 & 0xFFFFFFFF00000000) != 0)
          goto LABEL_194;
        v25 = (unint64_t)v20 + v24 + 8;
        if ((unint64_t)v4 < v25)
        {
          while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v4 + 8) & 1) == 0)
          {
            v4 = (unsigned int *)((char *)v4 + v23);
            v26 = v23;
            if ((unint64_t)v4 >= v25)
              goto LABEL_109;
          }
        }
        v26 = v23;
LABEL_109:
        v19 = v26;
      }
      else
      {
        v19 = 0;
      }
    }
    else
    {
      v19 = 0;
      v20 = v18 + 2;
    }
  }
  else
  {
    v19 = 0;
    v20 = 0;
  }
  v27 = v16 != 1;
  if (v16 == 1 && v18)
  {
    v21 = (unint64_t)&v18[2 * *v18 + 2];
    goto LABEL_44;
  }
  v21 = 0;
  v28 = v16 != 2;
  if (v16 == 2 && v18)
  {
    v23 = *v18;
    v3 = v18[1];
    v36 = v3 * (unint64_t)v23;
    if ((v36 & 0xFFFFFFFF00000000) != 0)
    {
      v20 = (unsigned int *)(v14 & 0xFFFFFFFFFFFFFFFCLL);
      goto LABEL_194;
    }
    v28 = 0;
    outCount = (unsigned int *)((char *)v18 + v36 + 8);
    v21 = v14 & 0xFFFFFFFFFFFFFFFCLL;
  }
LABEL_45:
  v29 = 0;
  v2 = 4;
  if ((v14 & 3) != 0)
    goto LABEL_48;
LABEL_46:
  if (v20 != (unsigned int *)v21)
  {
    v3 = v20[1];
    v20 = 0;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          v29 += v3;
          if ((v14 & 3) == 0)
            goto LABEL_46;
LABEL_48:
          if (v27)
            break;
          if (v20 == (unsigned int *)v21)
            goto LABEL_61;
          v30 = *(_QWORD *)v20;
          v20 += 2;
          v3 = *(unsigned int *)(v30 + 4);
        }
        if (!v28)
          break;
        v3 = MEMORY[4];
      }
      if (v4 == outCount)
        goto LABEL_61;
      v3 = v20[1];
      v31 = v3 * (unint64_t)*v20;
      if ((v31 & 0xFFFFFFFF00000000) != 0)
        break;
      v3 = *(unsigned int *)((char *)v4 + (*(uint64_t *)v4 >> 16) + 4);
      v32 = (unint64_t)v20 + v31 + 8;
      v33 = (unsigned int *)((char *)v4 + v19);
      do
      {
        v4 = v33;
        if ((unint64_t)v33 >= v32)
          break;
        v34 = *(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v33 + 8);
        v33 = (unsigned int *)((char *)v33 + v19);
      }
      while ((v34 & 1) == 0);
    }
    v23 = *v20;
LABEL_194:
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)outCount, (const char *)v2, (char *)v3, v3, v20, v23);
  }
LABEL_61:
  if (!v29)
  {
    v35 = 0;
    v10 = 0;
    if (v5)
      goto LABEL_167;
    goto LABEL_168;
  }
  v91 = (uint64_t *)&v108;
  if (!v17)
  {
    v92 = v14 & 0xFFFFFFFFFFFFFFFCLL;
    v113 = &v108;
LABEL_70:
    v114 = 0;
    goto LABEL_85;
  }
  if (v14 > 3)
  {
    if (v16 == 1 && v18)
    {
      v92 = (unint64_t)(v18 + 2);
      v113 = &v108;
      goto LABEL_78;
    }
    if (v16 == 2 && v18)
    {
      if (DisablePreattachedCategories)
      {
        v37 = *v18;
        v38 = v18[1];
        v88 = v38 * (unint64_t)v37;
        if ((v88 & 0xFFFFFFFF00000000) != 0)
          goto LABEL_197;
        v51 = v37 | (v38 << 32);
        v50 = (unsigned __int16 *)((char *)v18 + v88 + 8);
        v89 = v37 | ((unint64_t)(v38 - 1) << 32);
        v90 = (_DWORD)v38 == 0;
        if ((_DWORD)v38)
          v38 = v38;
        else
          v38 = 0;
        if (!v90)
        {
          v50 = (unsigned __int16 *)((char *)v50 - v37);
          v51 = v89;
        }
      }
      else
      {
        v50 = (unsigned __int16 *)(v18 + 2);
        v51 = *v18;
        v38 = v18[1];
        v37 = v51;
      }
      v52 = v38 * (unint64_t)v37;
      if ((v52 & 0xFFFFFFFF00000000) != 0)
        goto LABEL_197;
      v53 = HIDWORD(v51);
      v54 = (unint64_t)v18 + v52 + 8;
      while ((unint64_t)v50 < v54 && (*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v50 + 8) & 1) == 0)
      {
        v50 = (unsigned __int16 *)((char *)v50 + v51);
        v53 = (v53 + 1);
      }
      v92 = (unint64_t)v18;
      v93 = v51 | (v53 << 32);
      v94 = v50;
    }
  }
  else
  {
    v92 = 0;
  }
  v113 = &v108;
  if (!v16)
    goto LABEL_70;
LABEL_78:
  if (v16 == 1 && v18)
  {
    v114 = (uint64_t)&v18[2 * *v18 + 2];
    goto LABEL_85;
  }
  if (v16 != 2 || !v18)
    goto LABEL_85;
  v37 = *v18;
  v38 = v18[1];
  v39 = v38 * (unint64_t)v37;
  if ((v39 & 0xFFFFFFFF00000000) != 0)
LABEL_197:
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)outCount, (const char *)4, (char *)v3, v38, v18, v37);
  v114 = (uint64_t)v18;
  v115 = (_QWORD *)(v37 | (v38 << 32));
  v116 = (uint64_t)v18 + v39 + 8;
LABEL_85:
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl((uint64_t)&v96, (uint64_t)&v91, (uint64_t)&v113, (char *)v3);
  v43 = v108 & 3;
  v44 = (unsigned int *)(v108 & 0xFFFFFFFFFFFFFFFCLL);
  if (v43 != 1 || v44 == 0)
  {
    if (v43 == 2 && v44)
    {
      v47 = *v44;
      v46 = v44[1];
      v48 = v46 * (unint64_t)v47;
      if ((v48 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v40, v41, v42, v46, v108 & 0xFFFFFFFFFFFFFFFCLL, v47);
      v43 = (uint64_t)v44 + v48 + 8;
      v49 = (unint64_t *)(v47 | (v46 << 32));
      v113 = &v108;
    }
    else
    {
      v44 = 0;
      v49 = &v108;
      v113 = &v108;
      if (v43 != 2)
      {
        if (v43 != 1)
        {
          if ((v108 & 3) != 0)
          {
            v109 = &v108;
          }
          else
          {
            v114 = 0;
            v109 = &v108;
            v110 = 0;
          }
          goto LABEL_113;
        }
        goto LABEL_94;
      }
    }
    v114 = (uint64_t)v44;
    v115 = v49;
    v116 = v43;
    v109 = &v108;
    v110 = v44;
    v111 = v49;
    v112 = v43;
    goto LABEL_113;
  }
  v44 += 2 * *v44 + 2;
  v113 = &v108;
LABEL_94:
  v114 = (uint64_t)v44;
  v109 = &v108;
  v110 = v44;
LABEL_113:
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl((uint64_t)&v91, (uint64_t)&v113, (uint64_t)&v109, v42);
  v10 = (Method *)malloc_type_malloc(8 * (v29 + 1), 0x2004093837F09uLL);
  v35 = 0;
  while (1)
  {
    if (v96 != v91)
      goto LABEL_126;
    v58 = *v96 & 3;
    if (v58 == 2)
      break;
    if (v58 <= 1)
    {
      v59 = (uint64_t *)v97;
      v60 = v92;
      goto LABEL_119;
    }
LABEL_126:
    v63 = v35 + 1;
    v10[v35] = (Method)v105;
    v105 += v104;
    ++HIDWORD(v104);
    ++v35;
    if (v105 == v107)
    {
      v64 = *v96;
      v65 = *v96 & 3;
      if (v65 == 1)
      {
        v97 += 2;
        v64 = *v96;
      }
      else if (!v65)
      {
        v97 = 0;
      }
      if ((v64 & 3) == 2)
      {
        v66 = v100;
        v67 = v99;
        v68 = (uint64_t *)((char *)v100 + v98);
        v100 = v68;
        v70 = *v97;
        v69 = v97[1];
        v71 = v69 * (unint64_t)v70;
        ++v99;
        if ((v71 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v55, v56, v57, v69, v97, v70);
        v72 = (unint64_t)v97 + v71 + 8;
        if ((unint64_t)v68 < v72)
        {
          v73 = v67 + 2;
          do
          {
            if ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)((char *)v66 + v98) + 8) & 1) != 0)
              break;
            v100 = (uint64_t *)((char *)v66 + 2 * v98);
            v99 = v73++;
            v66 = (uint64_t *)((char *)v66 + v98);
          }
          while ((unint64_t)v66 + v98 < v72);
        }
      }
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists(&v96);
      v74 = *v96 & 3;
      if (v96 == v101)
      {
        if (v74 == 2)
        {
          v77 = v100;
          v35 = v63;
          if (v100 != v103)
            goto LABEL_153;
        }
        else if (v74 == 1)
        {
          v76 = v97;
          v35 = v63;
          if (v97 != v102)
            goto LABEL_151;
        }
        else
        {
          if (v74)
            goto LABEL_147;
          v75 = v97;
          v35 = v63;
          if (v97 != v102)
            goto LABEL_154;
        }
      }
      else
      {
        if (v74 == 2)
        {
          v77 = v100;
LABEL_153:
          v75 = (unsigned int *)((char *)v77 + (*v77 >> 16));
          goto LABEL_154;
        }
        if (v74 == 1)
        {
          v76 = v97;
LABEL_151:
          v75 = *(unsigned int **)v76;
          goto LABEL_154;
        }
        if (v74)
        {
LABEL_147:
          v75 = 0;
          goto LABEL_154;
        }
        v75 = v97;
LABEL_154:
        v78 = *v75;
        v104 = (unsigned __int16)*v75 & 0xFFFC;
        v105 = (unint64_t)(v75 + 2) & 0xFFFFFFFFFFFFFFFCLL | ((unint64_t)v78 >> 31);
        v79 = *v96 & 3;
        if (v79 == 2)
        {
          v80 = (int *)((char *)v100 + (*v100 >> 16));
        }
        else if (v79 == 1)
        {
          v80 = *(int **)v97;
        }
        else if (v79)
        {
          v80 = 0;
        }
        else
        {
          v80 = (int *)v97;
        }
        v106 = entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd(v80, v55, v56, v57);
        v107 = v55;
        v35 = v63;
        if (v105 == v55)
        {
          v81 = *v96 & 3;
          if (v81 == 2)
          {
            v82 = (unsigned int *)((char *)v100 + (*v100 >> 16));
          }
          else if (v81 == 1)
          {
            v82 = *(unsigned int **)v97;
          }
          else if (v81)
          {
            v82 = 0;
          }
          else
          {
            v82 = v97;
          }
          _objc_fatal("Assertion failed: (%s) - empty list %p encountered during iteration", v55, v56, v57, "m != mEnd", v82);
        }
      }
    }
  }
  v59 = v100;
  v60 = (unint64_t)v94;
LABEL_119:
  if (v59 != (uint64_t *)v60)
    goto LABEL_126;
  if (v96 != v101 || (v58 == 2 ? (v61 = v100, v62 = v103) : (v61 = (uint64_t *)v97, v62 = (uint64_t *)v102), v61 != v62))
  {
    if (v105 != v95)
      goto LABEL_126;
  }
  v10[v35] = 0;
  if (v5)
LABEL_167:
    *v5 = v35;
LABEL_168:
  v83 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v84 = __ldxr(runtimeLock);
    if (v84 != v83)
      break;
    if (!__stlxr(0, runtimeLock))
      return v10;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v10;
}

void sub_18010BD00(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t **list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists(uint64_t **result)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  int v17;

  v1 = *result;
  v2 = result[4];
  v3 = objc_debug_headerInfoRWs;
  v4 = **result;
  while (1)
  {
    v5 = v4 & 3;
    if (v1 != v2)
    {
      if (v5 == 1)
      {
        v7 = result[1];
        goto LABEL_17;
      }
      if ((v4 & 3) == 0)
      {
        v6 = result[1];
LABEL_10:
        if (*((_DWORD *)v6 + 1))
          return result;
        result[1] = 0;
        goto LABEL_19;
      }
      goto LABEL_14;
    }
    if (v5 == 2)
    {
      if (result[3] == result[7])
        return result;
      goto LABEL_14;
    }
    if (v5 == 1)
      break;
    if ((v4 & 3) == 0)
    {
      v6 = result[1];
      if (v6 == result[5])
        return result;
      goto LABEL_10;
    }
LABEL_14:
    if (*(_DWORD *)((char *)result[3] + (*result[3] >> 16) + 4))
      return result;
LABEL_19:
    if ((v4 & 3) == 2)
    {
      v8 = result[3];
      v9 = *((unsigned int *)result + 4);
      v10 = *((_DWORD *)result + 5);
      result[3] = (uint64_t *)((char *)v8 + v9);
      v11 = (unsigned int *)result[1];
      v12 = *v11;
      v13 = v11[1];
      v14 = v13 * (unint64_t)v12;
      v15 = (char *)(v10 + 1);
      *((_DWORD *)result + 5) = (_DWORD)v15;
      if ((v14 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v12, (const char *)v14, v15, v13, v11, v12);
      v16 = (unint64_t)v11 + v14 + 8;
      if ((unint64_t)v8 + v9 < v16)
      {
        v17 = v10 + 2;
        do
        {
          if ((*(_QWORD *)(v3 + 8 * *(unsigned __int16 *)((char *)v8 + v9) + 8) & 1) != 0)
            break;
          result[3] = (uint64_t *)((char *)v8 + 2 * v9);
          *((_DWORD *)result + 5) = v17++;
          v8 = (uint64_t *)((char *)v8 + v9);
        }
        while ((unint64_t)v8 + v9 < v16);
      }
    }
  }
  v7 = result[1];
  if (v7 == result[5])
    return result;
LABEL_17:
  if (!*(_DWORD *)(*v7 + 4))
  {
    result[1] = v7 + 1;
    v4 = *v1;
    goto LABEL_19;
  }
  return result;
}

unint64_t entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd(int *a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v4;
  int v5;

  v5 = *a1;
  v4 = a1[1];
  if (((v4 * (unint64_t)(*a1 & 0xFFFC)) & 0xFFFFFFFF00000000) != 0)
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v4, a1, v5 & 0xFFFC);
  return (unsigned __int16)v5 & 0xFFFC | (unint64_t)(v4 << 32);
}

uint64_t list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  _QWORD *v5;
  unint64_t v6;
  __int128 v7;
  _QWORD *v8;
  unint64_t v9;
  __int128 v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t *v13;
  _DWORD **v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;

  v5 = *(_QWORD **)a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  v6 = *v5 & 3;
  if (v6 == 2)
  {
    v7 = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v7;
  }
  else if (v6 <= 1)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  }
  v8 = *(_QWORD **)a3;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)a3;
  v9 = *v8 & 3;
  if (v9 == 2)
  {
    v10 = *(_OWORD *)(a3 + 8);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a3 + 24);
    *(_OWORD *)(a1 + 40) = v10;
  }
  else if (v9 <= 1)
  {
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a3 + 8);
  }
  v11 = **(_QWORD **)a2 & 3;
  if (*(_QWORD *)a2 == *(_QWORD *)a3)
  {
    if (v11 != 2)
    {
      if (v11 != 1)
      {
        if (!v11)
        {
          v12 = *(_DWORD **)(a2 + 8);
          if (v12 == *(_DWORD **)(a3 + 8))
            goto LABEL_34;
          goto LABEL_26;
        }
        goto LABEL_19;
      }
      v14 = *(_DWORD ***)(a2 + 8);
      if (v14 == *(_DWORD ***)(a3 + 8))
        goto LABEL_34;
LABEL_25:
      v12 = *v14;
      goto LABEL_26;
    }
    v13 = *(uint64_t **)(a2 + 24);
    if (v13 == *(uint64_t **)(a3 + 24))
      goto LABEL_34;
LABEL_23:
    v12 = (_DWORD *)((char *)v13 + (*v13 >> 16));
    goto LABEL_26;
  }
  if (v11 == 2)
  {
    v13 = *(uint64_t **)(a2 + 24);
    goto LABEL_23;
  }
  if (v11 == 1)
  {
    v14 = *(_DWORD ***)(a2 + 8);
    goto LABEL_25;
  }
  if (v11)
  {
LABEL_19:
    v12 = 0;
    goto LABEL_26;
  }
  v12 = *(_DWORD **)(a2 + 8);
LABEL_26:
  v15 = (unsigned __int16)*v12 & 0xFFFC;
  v16 = (unint64_t)(v12 + 2) & 0xFFFFFFFFFFFFFFFCLL | ((unint64_t)*v12 >> 31);
  *(_QWORD *)(a1 + 64) = v15;
  *(_QWORD *)(a1 + 72) = v16;
  v17 = **(_QWORD **)a2 & 3;
  if (v17 == 2)
  {
    v18 = (int *)(*(_QWORD *)(a2 + 24) + (**(uint64_t **)(a2 + 24) >> 16));
  }
  else if (v17 == 1)
  {
    v18 = **(int ***)(a2 + 8);
  }
  else if (v17)
  {
    v18 = 0;
  }
  else
  {
    v18 = *(int **)(a2 + 8);
  }
  *(_QWORD *)(a1 + 80) = entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd(v18, a2, (const char *)a3, a4);
  *(_QWORD *)(a1 + 88) = v19;
LABEL_34:
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists((uint64_t **)a1);
  return a1;
}

void _finishInitializing(objc_class *a1, objc_class *a2, const char *a3, char *a4)
{
  uint64_t v5;
  unint64_t StatusReg;
  unsigned int v7;
  const char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  _QWORD *InitializingClassList;
  uint64_t v22;
  const char *v23;
  char *v24;
  objc_class *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int32x2_t *v29;
  objc_class *v30;
  uint64_t v31;
  uint64_t v32;
  objc_class **v33;
  objc_class *v34;
  unsigned int v35;
  int v36;
  objc_class *v37;
  int32x2_t v38;
  unsigned int v39;
  const void *v40;
  char *v41;
  objc_class *v42;

  if (PrintInitializing)
  {
    v40 = *(const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v41 = objc_class::nameForLogging(a1);
    _objc_inform("INITIALIZE: thread %p: %s is fully +initialized", v40, v41);
  }
  v5 = *(_QWORD *)a1 & 0xFFFFFFFF8;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&runtimeLock))
  {
    if (!__stxr(v7, (unsigned int *)&runtimeLock))
      goto LABEL_8;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_8:
  objc::Scanner::scanAddedClassImpl((__objc2_class *)a1, 0, a3, a4);
  objc::Scanner::scanAddedClassImpl((__objc2_class *)v5, 1uLL, v9, v10);
  cache_t::maybeConvertToPreoptimized((objc_class *)((char *)a1 + 16));
  cache_t::maybeConvertToPreoptimized((cache_t *)(v5 + 16));
  if (PrintInitializing)
  {
    v14 = objc_class::nameForLogging(a1);
    _objc_inform("INITIALIZE: thread %p: setInitialized(%s)", *(const void **)StatusReg, v14);
  }
  v15 = (unsigned int *)(*(_QWORD *)(v5 + 32) & 0xF00007FFFFFFFF8);
LABEL_11:
  v16 = *v15;
  v17 = *v15 & 0xCFFFFFFF | 0x20000000;
  do
  {
    v18 = __ldaxr(v15);
    if (v18 != v16)
    {
      __clrex();
      goto LABEL_11;
    }
  }
  while (__stlxr(v17, v15));
  v19 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v20 = __ldxr((unsigned int *)&runtimeLock);
    if (v20 != v19)
      break;
    if (!__stlxr(0, (unsigned int *)&runtimeLock))
      goto LABEL_20;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
LABEL_20:
  unlockClass(a1, v11, v12, v13);
  InitializingClassList = _fetchInitializingClassList(0);
  if (!InitializingClassList)
    goto LABEL_28;
  if ((unint64_t)(*(_QWORD *)a1 - 1) < 0xF
    || (v25 = a1, (*(_BYTE *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) & 1) == 0))
  {
    v25 = (objc_class *)(*(_QWORD *)a1 & 0xFFFFFFFF8);
  }
  v26 = *(unsigned int *)InitializingClassList;
  if ((int)v26 < 1)
LABEL_28:
    _objc_fatal("thread is not initializing this class!", v22, v23, v24);
  v27 = 0;
  v28 = InitializingClassList[1];
  while (v25 != *(objc_class **)(v28 + 8 * v27))
  {
    if (v26 == ++v27)
      goto LABEL_28;
  }
  *(_QWORD *)(v28 + 8 * v27) = 0;
  v29 = (int32x2_t *)pendingInitializeMap;
  if (pendingInitializeMap)
  {
    v30 = *(objc_class **)pendingInitializeMap;
    v31 = *(unsigned int *)(pendingInitializeMap + 16);
    if ((_DWORD)v31)
    {
      LODWORD(v32) = (v31 - 1) & (bswap64(0x8A970BE7488FDA55 * ((unint64_t)a1 ^ ((unint64_t)a1 >> 4))) ^ (1217387093 * (a1 ^ ((unint64_t)a1 >> 4))));
      v33 = (objc_class **)((char *)v30 + 16 * v32);
      v34 = *v33;
      if (*v33 == a1)
        goto LABEL_38;
      v35 = 1;
      while (v34 != (objc_class *)-1)
      {
        if (v35 > v31)
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(pendingInitializeMap, v30, v31);
        v36 = v32 + v35++;
        v32 = v36 & (v31 - 1);
        v34 = (objc_class *)*((_QWORD *)v30 + 2 * v32);
        if (v34 == a1)
        {
          v33 = (objc_class **)((char *)v30 + 16 * v32);
          goto LABEL_38;
        }
      }
    }
    v33 = (objc_class **)((char *)v30 + 16 * v31);
LABEL_38:
    if (v33 == (objc_class **)((char *)v30 + 16 * v31))
      return;
    v37 = v33[1];
    *v33 = (objc_class *)-2;
    v38 = vadd_s32(v29[1], (int32x2_t)0x1FFFFFFFFLL);
    v29[1] = v38;
    v39 = v29[2].u32[0];
    if (v38.i32[0])
    {
      if (v39 < 0x401
        || v39 >> 4 <= v38.i32[0]
        || (objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::grow((uint64_t)v29, 2 * v38.i32[0]), v29 = (int32x2_t *)pendingInitializeMap, *(_DWORD *)(pendingInitializeMap + 8)))
      {
LABEL_48:
        if (v37)
        {
          do
          {
            v42 = (objc_class *)*((_QWORD *)v37 + 1);
            if (*(_QWORD *)v37)
              _finishInitializing(*(objc_class **)v37, v30);
            free(v37);
            v37 = v42;
          }
          while (v42);
        }
        return;
      }
    }
    else if (v39)
    {
      free(*(void **)v29);
      *v29 = 0;
      v29[1] = 0;
      v29[2].i32[0] = 0;
    }
    else
    {
      v29[1] = 0;
    }
    free(*(void **)v29);
    free(v29);
    pendingInitializeMap = 0;
    goto LABEL_48;
  }
}

void objc::Scanner::scanAddedClassImpl(__objc2_class *this, unint64_t a2, const char *a3, char *a4)
{
  unsigned __int16 *v4;
  unint64_t v5;
  unint64_t v7;
  __objc2_class *v8;
  __objc2_class *superclass;
  unsigned int vtable_high;
  _BOOL4 v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 v27;
  unint64_t v28;
  _BOOL4 v29;
  unsigned int *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unsigned int *v34;
  BOOL v35;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unsigned __int16 *v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t i;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  unint64_t v65;
  unsigned __int16 *v66;
  unsigned __int16 v67;
  unint64_t *p_info;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  BOOL j;
  unint64_t v73;
  unint64_t v74;
  unsigned __int16 *v75;
  unsigned __int16 v76;
  unsigned __int16 *v77;
  unsigned __int16 v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  unint64_t v84;
  uint64_t v85;
  BOOL v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  BOOL v92;
  unint64_t *v93;
  unint64_t v94;
  unint64_t v95;
  unsigned __int16 *v96;
  unint64_t *v97;
  unint64_t v98;
  unint64_t v99;
  unsigned __int16 *v100;
  unint64_t v101;

  v7 = ((unint64_t)objc::NSObjectSwizzledMask >> a2) & 0x15;
  v8 = NSObject;
  if ((_DWORD)a2)
    v8 = &OBJC_METACLASS___NSObject;
  if (v8 != this)
  {
    superclass = this->superclass;
    if (!superclass)
    {
      v11 = 0;
      v14 = 0;
      v12 = 0;
      LOBYTE(v7) = 21;
      goto LABEL_30;
    }
    vtable_high = HIWORD(superclass->vtable);
    v11 = (vtable_high & 0x4000) == 0;
    v35 = ((uint64_t)superclass->info & 4) == 0;
    v12 = v35;
    v13 = v7 | v11 | 4;
    if (!v35)
      v13 = v7 | v11;
    v14 = (vtable_high >> 15) ^ 1;
    if ((vtable_high & 0x8000u) != 0)
      LODWORD(v7) = v13;
    else
      LODWORD(v7) = v13 | 0x10;
    if ((_DWORD)v7 == 21)
      goto LABEL_30;
    v15 = *(_QWORD *)(((uint64_t)this->info & 0xF00007FFFFFFFF8) + 8);
    v16 = v15 & 0xFFFFFFFFFFFFFFFELL;
    if ((v15 & 1) != 0)
    {
      v18 = *(_QWORD *)(v16 + 8);
    }
    else
    {
      v17 = *(_QWORD *)(v16 + 32);
      v18 = v17 & 0xFFFFFFFFFFFFFFFELL;
      if ((v17 & 1) != 0)
        v19 = v17 & 0xFFFFFFFFFFFFFFFELL;
      else
        v19 = 0;
      if ((v17 & 1) != 0 || !v18)
      {
        v18 = v19 | 2;
        if (!v19)
          v18 = 0;
      }
    }
    v101 = v18;
    v93 = &v101;
    v33 = v18 & 3;
    v34 = (unsigned int *)(v18 & 0xFFFFFFFFFFFFFFFCLL);
    v35 = (v18 & 3) != 0 || v34 == 0;
    if (!v35)
    {
      v94 = v18 & 0xFFFFFFFFFFFFFFFCLL;
      v34 = 0;
LABEL_101:
      v56 = objc::Scanner::scanMethodLists<list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator>((uint64_t)&v93, (unint64_t)v34, (unint64_t)a3);
      goto LABEL_139;
    }
    if (v18 > 3)
    {
      if (v33 == 1 && v34 != 0)
      {
        v94 = (unint64_t)(v34 + 2);
        goto LABEL_94;
      }
      if (v33 == 2 && v34 != 0)
      {
        if (DisablePreattachedCategories)
        {
          v48 = *v34;
          v87 = v34[1];
          v88 = v87 * (unint64_t)v48;
          if ((v88 & 0xFFFFFFFF00000000) != 0)
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)v34, a3, a4, v87, v34, v48, v93, v94, v95, v96, v97, v98, v99, v100, v101);
          v89 = v48 | (v87 << 32);
          v90 = (uint64_t)v34 + v88 + 8;
          v91 = v48 | ((unint64_t)(v87 - 1) << 32);
          v92 = (_DWORD)v87 == 0;
          if ((_DWORD)v87)
            v46 = v87;
          else
            v46 = 0;
          if ((_DWORD)v87)
            v45 = (unsigned __int16 *)(v90 - v48);
          else
            v45 = (unsigned __int16 *)v90;
          if (v92)
            v47 = v89;
          else
            v47 = v91;
        }
        else
        {
          v45 = (unsigned __int16 *)(v34 + 2);
          v47 = *v34;
          v46 = v34[1];
          v48 = v47;
        }
        v49 = v46 * (unint64_t)v48;
        if ((v49 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)v34, a3, a4, v46, v34, v48, v93, v94, v95, v96, v97, v98, v99, v100, v101);
        v50 = HIDWORD(v47);
        for (i = (unint64_t)v34 + v49 + 8; (unint64_t)v45 < i; v50 = (v50 + 1))
        {
          if ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v45 + 8) & 1) != 0)
            break;
          v45 = (unsigned __int16 *)((char *)v45 + v47);
        }
        v94 = (unint64_t)v34;
        v95 = v47 | (v50 << 32);
        v96 = v45;
      }
    }
    else
    {
      v94 = 0;
    }
    if (!v33)
    {
      v34 = 0;
      goto LABEL_101;
    }
LABEL_94:
    if (v33 == 1 && v34)
    {
      v34 += 2 * *v34 + 2;
    }
    else if (v33 == 2 && v34)
    {
      v54 = *v34;
      v53 = v34[1];
      v55 = v53 * (unint64_t)v54;
      if ((v55 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)v34, a3, a4, v53, v34, v54, v93, v94, v95, v96, v97, v98, v99, v100, v101);
      a3 = (char *)v34 + v55 + 8;
    }
    goto LABEL_101;
  }
  v20 = (uint64_t)this->info & 0xF00007FFFFFFFF8;
  v21 = *(_QWORD *)(v20 + 8);
  v22 = v21 & 0xFFFFFFFFFFFFFFFELL;
  if ((v21 & 1) != 0)
  {
    v24 = *(_QWORD *)(v22 + 8);
  }
  else
  {
    v23 = *(_QWORD *)(v22 + 32);
    v24 = v23 & 0xFFFFFFFFFFFFFFFELL;
    if ((v23 & 1) != 0)
      v25 = v23 & 0xFFFFFFFFFFFFFFFELL;
    else
      v25 = 0;
    if ((v23 & 1) != 0 || !v24)
    {
      if (v25)
        v24 = v25 | 2;
      else
        v24 = 0;
    }
  }
  v101 = v24;
  v97 = &v101;
  v28 = v24 & 3;
  v29 = v28 != 0;
  v30 = (unsigned int *)(v24 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v24 & 0xFFFFFFFFFFFFFFFCLL) == 0)
    v29 = 1;
  if (!v29)
  {
    v98 = v24 & 0xFFFFFFFFFFFFFFFCLL;
    v4 = (unsigned __int16 *)(v24 & 0xFFFFFFFFFFFFFFFCLL);
    goto LABEL_43;
  }
  if (v24 > 3)
  {
    if (v28 != 1 || v30 == 0)
    {
      if (v28 == 2 && v30 != 0)
      {
        if (DisablePreattachedCategories)
        {
          v40 = *v30;
          v82 = v30[1];
          v83 = v82 * (unint64_t)v40;
          if ((v83 & 0xFFFFFFFF00000000) != 0)
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v82, v24 & 0xFFFFFFFFFFFFFFFCLL, v40, v93, v94, v95, v96, v97, v98, v99, v100, v101);
          v84 = v40 | (v82 << 32);
          v85 = (uint64_t)v30 + v83 + 8;
          a2 = v40 | ((unint64_t)(v82 - 1) << 32);
          v86 = (_DWORD)v82 == 0;
          if ((_DWORD)v82)
            v38 = v82;
          else
            v38 = 0;
          if ((_DWORD)v82)
            v4 = (unsigned __int16 *)(v85 - v40);
          else
            v4 = (unsigned __int16 *)v85;
          if (v86)
            v39 = v84;
          else
            v39 = a2;
        }
        else
        {
          v4 = (unsigned __int16 *)(v30 + 2);
          v39 = *v30;
          v38 = v30[1];
          v40 = v39;
        }
        v41 = v38 * (unint64_t)v40;
        if ((v41 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v38, v24 & 0xFFFFFFFFFFFFFFFCLL, v40, v93, v94, v95, v96, v97, v98, v99, v100, v101);
        v5 = HIDWORD(v39);
        v42 = (unint64_t)v30 + v41 + 8;
        if ((unint64_t)v4 >= v42)
        {
          v24 = v39 | (v5 << 32);
          v98 = (unint64_t)v30;
          v99 = v24;
          v100 = v4;
LABEL_103:
          if (v28 == 2 && v30)
          {
            if (DisablePreattachedCategories)
            {
              v57 = *v30;
              v79 = v30[1];
              v80 = v79 * (unint64_t)v57;
              if ((v80 & 0xFFFFFFFF00000000) != 0)
                _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v79, v30, v57, v93, v94, v95, v96, v97, v98, v99, v100, v101);
              v81 = (uint64_t)v30 + v80 + 8;
              if ((_DWORD)v79)
                v58 = v79;
              else
                v58 = 0;
              if ((_DWORD)v79)
                v24 = v81 - v57;
              else
                v24 = v81;
            }
            else
            {
              v24 = (unint64_t)(v30 + 2);
              v57 = *v30;
              v58 = v30[1];
            }
            v59 = v58 * (unint64_t)v57;
            if ((v59 & 0xFFFFFFFF00000000) != 0)
              _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v58, v30, v57, v93, v94, v95, v96, v97, v98, v99, v100, v101);
            v5 = (unint64_t)v30 + v59 + 8;
            if (v24 >= v5)
            {
              v52 = 1;
              v4 = (unsigned __int16 *)v30;
              goto LABEL_113;
            }
            do
            {
              if ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v24 + 8) & 1) != 0)
                break;
              v24 += v57;
            }
            while (v24 < v5);
            v4 = (unsigned __int16 *)v30;
          }
          goto LABEL_40;
        }
        do
        {
          if ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v4 + 8) & 1) != 0)
            break;
          v4 = (unsigned __int16 *)((char *)v4 + v39);
          v5 = (v5 + 1);
        }
        while ((unint64_t)v4 < v42);
        v5 = v39 | (v5 << 32);
        v98 = v24 & 0xFFFFFFFFFFFFFFFCLL;
        v99 = v5;
        v100 = v4;
        v4 = (unsigned __int16 *)(v24 & 0xFFFFFFFFFFFFFFFCLL);
        if (!v29)
        {
LABEL_43:
          v31 = 0;
          v32 = 0;
          if (!v4)
            goto LABEL_138;
          goto LABEL_123;
        }
      }
    }
    else
    {
      v24 = (unint64_t)(v30 + 2);
      v98 = (unint64_t)(v30 + 2);
    }
    if (v28 == 1 && v30)
    {
      v4 = (unsigned __int16 *)(v30 + 2);
      goto LABEL_91;
    }
    goto LABEL_103;
  }
  v4 = 0;
  v98 = 0;
LABEL_40:
  if (!v28)
    goto LABEL_43;
LABEL_91:
  v52 = v28 != 1;
  if (v28 == 1 && v30)
  {
    v31 = (uint64_t)&v30[2 * *v30 + 2];
    v32 = v31;
    goto LABEL_122;
  }
LABEL_113:
  v32 = 0;
  if (v30 && v28 == 2)
  {
    v5 = *v30;
    v60 = v30[1];
    v61 = v60 * (unint64_t)v5;
    if ((v61 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", 0, a3, a4, v60, v30, v5, v93, v94, v95, v96, v97, v98, v99, v100, v101);
    a3 = (char *)v30 + v61 + 8;
    v32 = (unint64_t)v30;
  }
  if (!v52)
  {
    v31 = (uint64_t)v30;
LABEL_122:
    if (v4 == (unsigned __int16 *)v32)
    {
      v32 = (unint64_t)v4;
      goto LABEL_138;
    }
    goto LABEL_123;
  }
  v31 = (uint64_t)v30;
  if (v28 == 2 && (const char *)v24 == a3)
  {
LABEL_136:
    v32 = (unint64_t)v30;
    goto LABEL_138;
  }
LABEL_123:
  v62 = *(_QWORD *)(v20 + 8);
  v63 = (_QWORD *)(v62 & 0xFFFFFFFFFFFFFFFELL);
  if ((v62 & 1) != 0)
    v63 = (_QWORD *)*v63;
  if (v63[4] > 1uLL)
  {
    if (v28 == 1)
      v64 = -1;
    else
      v64 = 0;
    v65 = v31 + 8 * v64;
    if (v29)
      v32 = v65;
    else
      v32 = (unint64_t)v30;
    if (v28 == 2)
    {
      do
        a3 -= v5;
      while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)a3 + 8) & 1) == 0);
    }
    goto LABEL_138;
  }
  v30 = (unsigned int *)v31;
  if (v28 == 2)
    goto LABEL_136;
LABEL_138:
  v56 = objc::Scanner::scanMethodLists<list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator>((uint64_t)&v97, v32, (unint64_t)a3);
  v12 = 0;
  v14 = 0;
  v11 = 0;
LABEL_139:
  LOBYTE(v7) = v56 | v7;
  if ((v7 & 1) == 0)
  {
    v66 = (unsigned __int16 *)&this->vtable + 3;
    do
      v67 = __ldxr(v66);
    while (__stxr(v67 | 0x4000, v66));
    goto LABEL_142;
  }
LABEL_30:
  v26 = (unsigned __int16 *)&this->vtable + 3;
  do
    v27 = __ldxr(v26);
  while (__stxr(v27 & 0xBFFF, v26));
  if (PrintCustomAWZ)
    objc::Scanner::printCustom("CUSTOM AWZ", (objc_class *)this, v11);
LABEL_142:
  p_info = (unint64_t *)&this->info;
  v69 = __ldxr((unint64_t *)&this->info);
  if ((v7 & 4) != 0)
  {
    v71 = v69 & 0xFFFFFFFFFFFFFFFBLL;
    for (j = v69 == 0; ; j = v74 == 0)
    {
      v73 = j ? 0x8000000000000000 : v71;
      if (!__stlxr(v73, p_info))
        break;
      v74 = __ldxr(p_info);
      v71 = v74 & 0xFFFFFFFFFFFFFFFBLL;
    }
    if (PrintCustomRR)
      objc::Scanner::printCustom("CUSTOM RR", (objc_class *)this, v12);
  }
  else
  {
    while (1)
    {
      v70 = v69 ? v69 | 4 : 0x8000000000000004;
      if (!__stlxr(v70, p_info))
        break;
      v69 = __ldxr(p_info);
    }
  }
  if ((v7 & 0x10) == 0 || objc::Scanner::isSwiftObject((objc::Scanner *)this, (objc_class *)a2))
  {
    v75 = (unsigned __int16 *)&this->vtable + 3;
    do
      v76 = __ldxr(v75);
    while (__stxr(v76 | 0x8000, v75));
  }
  else
  {
    v77 = (unsigned __int16 *)&this->vtable + 3;
    do
      v78 = __ldxr(v77);
    while (__stxr(v78 & 0x7FFF, v77));
    if (PrintCustomCore)
      objc::Scanner::printCustom("CUSTOM Core", (objc_class *)this, v14);
  }
}

void cache_t::maybeConvertToPreoptimized(cache_t *this)
{
  uint64_t v1;
  uint64_t v2;
  int v4;
  __int16 v5;
  objc_class *v6;
  const char *v7;
  char *v8;

  v1 = *(_QWORD *)this & 0xFFFFFFFFFFFLL;
  v2 = *(_QWORD *)(v1 + 8);
  if (v2 < 0)
  {
    if (*((_DWORD *)this + 2))
    {
      __break(1u);
      JUMPOUT(0x18010CC48);
    }
    v4 = *(_DWORD *)(*((_QWORD *)this + 2) & 0xF00007FFFFFFFF8);
    if ((v4 & 2) != 0 || (v4 & 4) != 0 && (v2 & 0x40000000) != 0)
    {
      if (PrintCaches)
      {
        v6 = (cache_t *)((char *)this - 16);
        if ((*((_WORD *)this + 7) & 4) != 0)
          v7 = "meta";
        else
          v7 = "";
        v8 = objc_class::nameForLogging(v6);
        _objc_inform("CACHES: %sclass %s: dropping cache (from %s)", v7, v8, "setInitialized");
      }
      v5 = 0;
      atomic_store((unint64_t)&_objc_empty_cache & 0xFFFFFFFFFFFLL, (unint64_t *)this);
    }
    else
    {
      *(_QWORD *)this = ((v1 | (v2 << 48)) + 16) | 1;
      v5 = *(_WORD *)(v1 + 10) & 0x3FFF;
    }
    *((_WORD *)this + 6) = v5;
  }
}

_QWORD *_fetchInitializingClassList(int a1)
{
  unint64_t StatusReg;
  _OWORD *v3;
  _QWORD *v4;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_OWORD **)(StatusReg + 320);
  if (!a1 || v3)
  {
    if (!v3)
      return 0;
  }
  else
  {
    v3 = malloc_type_malloc(0x48uLL, 0xB4ED9BFAuLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    *((_QWORD *)v3 + 8) = 0;
    *(_QWORD *)(StatusReg + 320) = v3;
  }
  v4 = *(_QWORD **)v3;
  if (*(_QWORD *)v3)
    goto LABEL_8;
  if (!a1)
    return 0;
  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0x10800407411B482uLL);
  *(_QWORD *)v3 = v4;
LABEL_8:
  if (!v4[1])
  {
    *(_DWORD *)v4 = 4;
    v4[1] = malloc_type_calloc(4uLL, 8uLL, 0x80040B8603338uLL);
  }
  return v4;
}

uint64_t objc::Scanner::scanMethodLists<list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t *v3;
  unsigned int *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t result;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int *v12;
  unint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned int *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  char *v62;

  v5 = **(_QWORD **)a1 & 3;
  if (v5 == 2)
  {
    v4 = *(unsigned int **)(a1 + 8);
    v6 = *(unsigned int *)(a1 + 16);
    v3 = *(uint64_t **)(a1 + 24);
  }
  else
  {
    v6 = 0;
    if (v5 <= 1)
      v4 = *(unsigned int **)(a1 + 8);
  }
  result = 0;
  while (v5 == 2)
  {
    if ((unint64_t)v3 >= a3)
      return result;
    v10 = *v4;
    v9 = v4[1];
    v11 = v9 * (unint64_t)v10;
    if ((v11 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, sel_retain, sel_release, sel_autorelease, sel__tryRetain, sel__isDeallocating, sel_retainCount, v9, v4, v10);
    v12 = (unsigned int *)((char *)v3 + (*v3 >> 16));
    v13 = (unint64_t)v4 + v11 + 8;
    v14 = (uint64_t *)((char *)v3 + v6);
    do
    {
      v3 = v14;
      if ((unint64_t)v14 >= v13)
        break;
      v15 = *(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v14 + 8);
      v14 = (uint64_t *)((char *)v14 + v6);
    }
    while ((v15 & 1) == 0);
LABEL_20:
    v8 = v4;
    v4 = v12;
LABEL_21:
    v17 = *v4;
    v18 = v17 >> 31;
    if ((v17 & 0x80000000) != 0)
    {
      v19 = (unsigned __int16)v17 & 0xFFFC;
      v20 = v4[1];
      v40 = v20 * (unint64_t)v19;
      if (dataSegmentsRanges > (unint64_t)v4 || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v4)
      {
        if ((v40 & 0xFFFFFFFF00000000) != 0)
LABEL_198:
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, sel_retain, sel_release, sel_autorelease, sel__tryRetain, sel__isDeallocating, sel_retainCount, v20, v4, v19);
        v59 = (unint64_t)(v4 + 2) & 0xFFFFFFFFFFFFFFFCLL | v18;
        v60 = ((unint64_t)v4 + v40 + 8) & 0xFFFFFFFFFFFFFFFCLL | v18;
        v4 = v8;
        if (v59 != v60)
        {
          do
          {
            v61 = 0;
            while (1)
            {
              v62 = *(char **)(((v59 + v61) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v59 + v61) & 0xFFFFFFFFFFFFFFFCLL));
              if ((objc::InterestingSelectorZeroes & (unint64_t)v62) == 0
                && (objc::InterestingSelectorOnes & (unint64_t)v62) == objc::InterestingSelectorOnes)
              {
                break;
              }
              v61 += v19;
              if (v59 + v61 == v60)
                goto LABEL_194;
            }
            if (sel_alloc == v62 || sel_allocWithZone_ == v62)
            {
              result = result | 1;
            }
            else if (sel_retain == v62
                   || sel_release == v62
                   || sel_autorelease == v62
                   || sel__tryRetain == v62
                   || sel__isDeallocating == v62
                   || sel_retainCount == v62
                   || sel_allowsWeakReference == v62
                   || sel_retainWeakReference == v62)
            {
              result = result | 4;
            }
            else if (sel_respondsToSelector_ == v62
                   || sel_isKindOfClass_ == v62
                   || sel_class == v62
                   || sel_self == v62
                   || &sel_new == (_UNKNOWN *)v62)
            {
              result = result | 0x10;
            }
            else
            {
              result = result;
            }
            if ((_DWORD)result == 21)
              break;
            v59 += v61 + v19;
          }
          while (v59 != v60);
LABEL_194:
          v4 = v8;
        }
      }
      else
      {
        if ((v40 & 0xFFFFFFFF00000000) != 0)
          goto LABEL_198;
        v41 = (unint64_t)(v4 + 2) & 0xFFFFFFFFFFFFFFFCLL | v18;
        v42 = ((unint64_t)v4 + v40 + 8) & 0xFFFFFFFFFFFFFFFCLL | v18;
        v4 = v8;
        if (v41 != v42)
        {
          do
          {
            v43 = 0;
            while (1)
            {
              v44 = v41 + v43;
              v45 = (char *)&unk_1F25805A8 + *(int *)((v41 + v43) & 0xFFFFFFFFFFFFFFFCLL);
              if (((unint64_t)v45 & objc::InterestingSelectorZeroes) == 0
                && (objc::InterestingSelectorOnes & (unint64_t)v45) == objc::InterestingSelectorOnes)
              {
                break;
              }
              v43 += v19;
              if (v41 + v43 == v42)
                goto LABEL_194;
            }
            if (sel_alloc == v45 || sel_allocWithZone_ == v45)
            {
              result = result | 1;
            }
            else if (sel_retain == v45
                   || sel_release == v45
                   || sel_autorelease == v45
                   || sel__tryRetain == v45
                   || sel__isDeallocating == v45
                   || sel_retainCount == v45
                   || sel_allowsWeakReference == v45
                   || sel_retainWeakReference == v45)
            {
              result = result | 4;
            }
            else if (sel_respondsToSelector_ == v45
                   || sel_isKindOfClass_ == v45
                   || sel_class == v45
                   || sel_self == v45
                   || &sel_new == (_UNKNOWN *)v45)
            {
              result = result | 0x10;
            }
            else
            {
              result = result;
            }
            if ((_DWORD)result == 21)
              break;
            v41 = v44 + v19;
          }
          while (v44 + v19 != v42);
          goto LABEL_194;
        }
      }
    }
    else
    {
      v19 = (unsigned __int16)v17 & 0xFFFC;
      v20 = v4[1];
      v21 = v20 * (unint64_t)v19;
      if ((v21 & 0xFFFFFFFF00000000) != 0)
        goto LABEL_198;
      v22 = (unint64_t)(v4 + 2) & 0xFFFFFFFFFFFFFFFCLL | v18;
      v23 = ((unint64_t)v4 + v21 + 8) & 0xFFFFFFFFFFFFFFFCLL | v18;
      v4 = v8;
      if (v22 != v23)
      {
        do
        {
          v24 = 0;
          while (1)
          {
            v25 = v22 + v24;
            v26 = *(char **)((v22 + v24) & 0xFFFFFFFFFFFFFFFCLL);
            if ((objc::InterestingSelectorZeroes & (unint64_t)v26) == 0
              && (objc::InterestingSelectorOnes & (unint64_t)v26) == objc::InterestingSelectorOnes)
            {
              break;
            }
            v24 += v19;
            if (v22 + v24 == v23)
              goto LABEL_194;
          }
          if (sel_alloc == v26 || sel_allocWithZone_ == v26)
          {
            result = result | 1;
          }
          else if (sel_retain == v26
                 || sel_release == v26
                 || sel_autorelease == v26
                 || sel__tryRetain == v26
                 || sel__isDeallocating == v26
                 || sel_retainCount == v26
                 || sel_allowsWeakReference == v26
                 || sel_retainWeakReference == v26)
          {
            result = result | 4;
          }
          else if (sel_respondsToSelector_ == v26
                 || sel_isKindOfClass_ == v26
                 || sel_class == v26
                 || sel_self == v26
                 || &sel_new == (_UNKNOWN *)v26)
          {
            result = result | 0x10;
          }
          else
          {
            result = result;
          }
          if ((_DWORD)result == 21)
            break;
          v22 = v25 + v19;
        }
        while (v25 + v19 != v23);
        goto LABEL_194;
      }
    }
  }
  if (v5 == 1)
  {
    if ((unint64_t)v4 >= a2)
      return result;
    v16 = *(unsigned int **)v4;
    v4 += 2;
    v12 = v16;
    goto LABEL_20;
  }
  if (!v5)
  {
    if (!v4 || a2)
      return result;
    v8 = 0;
    goto LABEL_21;
  }
  return 0;
}

BOOL objc::Scanner::isSwiftObject(objc::Scanner *this, objc_class *a2)
{
  const char *v2;
  _BOOL8 result;

  result = 0;
  if (!*((_QWORD *)this + 1) || (objc::Scanner *)(*(_QWORD *)this & 0xFFFFFFFF8) == this)
  {
    v2 = (const char *)objc_class::mangledName(this);
    if (!strcmp(v2, "_TtCs12_SwiftObject"))
      return 1;
  }
  return result;
}

id objc_opt_new(void (*a1)(void))
{
  int v1;
  SEL *v2;

  if (a1 && (v1 = *(__int16 *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x1E), v1 < 0))
  {
    if ((v1 & 0x4000) != 0)
      a1 = _objc_rootAllocWithZone((uint64_t)a1);
    else
      a1 = (void (*)(void))objc_msgSend(a1, sel_alloc);
    v2 = (SEL *)&selRef_init;
  }
  else
  {
    v2 = (SEL *)&selRef_new;
  }
  return objc_msgSend(a1, *v2);
}

id objc_alloc_init(void (*a1)(void))
{
  if (a1)
  {
    if ((*(_WORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x1E) & 0x4000) != 0)
      a1 = _objc_rootAllocWithZone((uint64_t)a1);
    else
      a1 = (void (*)(void))objc_msgSend(a1, sel_alloc);
  }
  return objc_msgSend(a1, sel_init);
}

void (*_objc_rootAlloc(uint64_t a1))(void)
{
  if ((*(_WORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x1E) & 0x4000) != 0)
    return _objc_rootAllocWithZone(a1);
  else
    return (void (*)(void))objc_msgSend((id)a1, sel_allocWithZone_, 0);
}

void (*_objc_rootAllocWithZone(uint64_t a1))(void)
{
  __int16 v2;
  size_t v3;
  void (*result)(void);
  uint64_t v5;
  const char *v6;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;

  v2 = *(_WORD *)(a1 + 30);
  v3 = v2 & 0xFF0;
  if ((v2 & 0xFF0) == 0)
  {
    v11 = *(_QWORD *)((*(_QWORD *)(a1 + 32) & 0xF00007FFFFFFFF8) + 8);
    v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
    if ((v11 & 1) != 0)
      v12 = *(_QWORD *)v12;
    v13 = (*(_DWORD *)(v12 + 8) + 7) & 0xFFFFFFF8;
    if (v13 <= 0x10)
      v3 = 16;
    else
      v3 = v13;
  }
  result = (void (*)(void))malloc_type_calloc(1uLL, v3, 0x40000000000uLL);
  if (!result)
    _objc_callBadAllocHandler((objc_class *)a1);
  v8 = a1 & 0xFFFFFFF000000007;
  if ((v2 & 0x2000) != 0)
  {
    if (!v8)
    {
      v10 = a1 & 0xFFFFFFFF8;
      goto LABEL_10;
    }
LABEL_18:
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v5, v6, v7, a1);
  }
  if (v8)
    goto LABEL_18;
  v9 = 0x21A000000001;
  if ((v2 & 1) != 0)
    v9 = 0x21A000000005;
  v10 = v9 | a1 & 0xFFFFFFFF8;
LABEL_10:
  *(_QWORD *)result = v10;
  if ((v2 & 2) != 0)
    return object_cxxConstructFromClass(result, (objc_class *)a1, 3);
  return result;
}

id objc_allocWithZone(id result)
{
  if (result)
  {
    if ((*(_WORD *)((*(_QWORD *)result & 0xFFFFFFFF8) + 0x1E) & 0x4000) != 0)
      return _objc_rootAllocWithZone((uint64_t)result);
    else
      return objc_msgSend(result, sel_allocWithZone_, 0);
  }
  return result;
}

void (*object_cxxConstructFromClass(void (*a1)(void), objc_class *a2, char a3))(void)
{
  void (*v5)(void);
  uint64_t v6;
  void (*Cache)(void);
  void (*v8)(void);
  char *v10;
  objc_class *v11;

  v5 = a1;
  v6 = *((_QWORD *)a2 + 1);
  if (v6 && (*(_WORD *)(v6 + 30) & 2) != 0 && !object_cxxConstructFromClass(a1))
    return 0;
  Cache = (void (*)(void))lookupMethodInClassAndLoadCache((uint64_t)a2, (objc_selector *)SEL_cxx_construct);
  if (Cache != _objc_msgForward_impcache)
  {
    v8 = Cache;
    if (PrintCxxCtors)
    {
      v10 = objc_class::nameForLogging(a2);
      _objc_inform("CXX: calling C++ constructors for class %s", v10);
    }
    if (!((uint64_t (*)(void (*)(void)))v8)(v5))
    {
      v11 = (objc_class *)*((_QWORD *)a2 + 1);
      if (v11)
        object_cxxDestructFromClass(v5, v11);
      if ((a3 & 1) != 0)
        free(v5);
      if ((a3 & 2) != 0)
        _objc_callBadAllocHandler(a2);
      return 0;
    }
  }
  return v5;
}

char *objc_class::nameForLogging(objc_class *this)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  unint64_t StatusReg;
  _OWORD *v11;
  void *v12;
  __int128 v13;
  char *v15;

  if ((unint64_t)(*(_QWORD *)this - 1) < 0xF)
  {
    v15 = 0;
    asprintf(&v15, "<stub class %p>");
LABEL_17:
    v9 = v15;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v11 = *(_OWORD **)(StatusReg + 320);
    if (!v11)
    {
      v11 = malloc_type_malloc(0x48uLL, 0xB4ED9BFAuLL);
      *v11 = 0u;
      v11[1] = 0u;
      v11[2] = 0u;
      v11[3] = 0u;
      *((_QWORD *)v11 + 8) = 0;
      *(_QWORD *)(StatusReg + 320) = v11;
    }
    v12 = (void *)*((_QWORD *)v11 + 3);
    if (v12)
      free(v12);
    v13 = v11[2];
    *((_QWORD *)v11 + 5) = *((_QWORD *)v11 + 6);
    *(_OWORD *)((char *)v11 + 24) = v13;
    *((_QWORD *)v11 + 6) = v9;
    return v15;
  }
  v1 = *((_QWORD *)this + 4);
  v2 = (_QWORD *)(v1 & 0xF00007FFFFFFFF8);
  if (!(*(_DWORD *)(v1 & 0xF00007FFFFFFFF8) >> 30))
  {
LABEL_4:
    v15 = 0;
    if (v1 < 0)
    {
      v3 = *(_QWORD *)((v1 & 0xF00007FFFFFFFF8) + 8);
      v2 = (_QWORD *)(v3 & 0xFFFFFFFFFFFFFFFELL);
      if ((v3 & 1) != 0)
        v2 = (_QWORD *)*v2;
    }
    v4 = (char *)atomic_load(v2 + 3);
    if (v4)
    {
      v5 = copySwiftV1DemangledName(v4, 0);
      if (!v5)
        v5 = strdup(v4);
      v15 = v5;
    }
    else
    {
      asprintf(&v15, "<lazily named class %p>");
    }
    goto LABEL_17;
  }
  v6 = *(_QWORD *)((v1 & 0xF00007FFFFFFFF8) + 8);
  v7 = (_QWORD *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  if ((v1 & 3) != 0)
  {
    if ((v6 & 1) != 0)
    {
      if (v7)
      {
        v8 = v7[4];
        if (v8)
          return (char *)v8;
      }
    }
    goto LABEL_4;
  }
  if ((v6 & 1) != 0)
    v7 = (_QWORD *)*v7;
  return (char *)atomic_load(v7 + 3);
}

Ivar class_getInstanceVariable(Class cls, const char *name)
{
  const char *v2;
  char *v3;

  if (cls && name)
    return (Ivar)_class_getVariable(cls, name, v2, v3);
  else
    return 0;
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  void **v4;
  id v5;
  unsigned int *v6;
  unint64_t StatusReg;
  unsigned int v8;
  void *v10;
  int v11;
  unsigned int v12;

  if (offset)
  {
    v4 = (void **)((char *)self + offset);
    if (*(id *)((char *)self + offset) != newValue)
    {
      v5 = newValue;
      v6 = (unsigned int *)&PropertyLocks[16
                                        * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)];
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v8 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr(v6))
      {
        if (!__stxr(v8, v6))
          goto LABEL_10;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_10:
      v10 = *v4;
      *v4 = v5;
      v11 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v12 = __ldxr(v6);
        if (v12 != v11)
          break;
        if (!__stlxr(0, v6))
          goto LABEL_15;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)&PropertyLocks[16
                                                           * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)]);
LABEL_15:

    }
  }
  else
  {
    object_setClass(self, (Class)newValue);
  }
}

void objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  _QWORD *v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(_QWORD **)a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4)
    v8 = v7 + 1;
  else
    v8 = 4;
  *(_DWORD *)(a1 + 16) = v8;
  v9 = malloc_type_malloc(24 * v8, 0x64B88C75uLL);
  *(_QWORD *)a1 = v9;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
    {
      v11 = 24 * v10;
      do
      {
        *v9 = -1;
        v9 += 3;
        v11 -= 24;
      }
      while (v11);
    }
    if ((_DWORD)v3)
    {
      v12 = 24 * v3;
      v13 = v4 + 2;
      do
      {
        v14 = *(v13 - 2);
        if (v14 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v20 = 0;
          objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>(a1, v14, &v20);
          v15 = v20;
          v16 = *(v13 - 2);
          v20[1] = 0;
          v15[2] = 0;
          *v15 = v16;
          v15[1] = *(v13 - 1);
          *(v13 - 1) = 0;
          v17 = v15[2];
          v15[2] = *v13;
          *v13 = v17;
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 3;
        v12 -= 24;
      }
      while (v12);
    }
    free(v4);
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    v18 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v18)
    {
      v19 = 24 * v18;
      do
      {
        *v9 = -1;
        v9 += 3;
        v19 -= 24;
      }
      while (v19);
    }
  }
}

_QWORD *objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::InsertIntoBucketImpl<void const*>(int32x2_t *a1, unint64_t *a2, _QWORD *a3)
{
  __int32 v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = a1[1].i32[0];
  v6 = a1[2].u32[0];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1].i32[1] > v6 >> 3)
  {
    goto LABEL_3;
  }
  objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::grow((uint64_t)a1, v6);
  v8 = 0;
  objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_3:
  if (*a3 == -2)
  {
    a1[1] = vadd_s32(a1[1], (int32x2_t)0xFFFFFFFF00000001);
  }
  else if (*a3 == -1)
  {
    ++a1[1].i32[0];
  }
  return a3;
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
  __objc2_class *v7;
  id v8;
  id v9;
  unint64_t StatusReg;
  unsigned int v11;
  char v13;
  int32x2_t *v14;
  int v15;
  int32x2_t *v16;
  int v17;
  void **v18;
  int v19;
  int32x2_t *v20;
  int v21;
  void *v22;
  int32x2_t v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  int32x2_t *v27;
  int32x2_t *inserted;
  int v29;
  unsigned int v30;
  char v31;
  uint64_t v32;
  unint64_t v33;
  void (*MethodImplementation)(void);
  const char *ClassName;
  uint64_t v36;
  const char *v37;
  char *v38;
  const void *v39;
  int32x2_t *v40;

  v39 = key;
  if (!((unint64_t)object | (unint64_t)value))
    return;
  if (((unint64_t)object & 0x8000000000000000) != 0)
  {
    v7 = (__objc2_class *)objc_debug_taggedpointer_classes[object & 7];
    if (v7 == __NSUnrecognizedTaggedPointer)
      v7 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[((unint64_t)object >> 55)];
  }
  else
  {
    v7 = (__objc2_class *)(*(_QWORD *)object & 0xFFFFFFFF8);
  }
  if ((*(_BYTE *)(((uint64_t)v7->info & 0xF00007FFFFFFFF8) + 2) & 0x10) != 0)
  {
    ClassName = object_getClassName(object);
    _objc_fatal("objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects", v36, v37, v38, object, ClassName);
  }
  if (value)
  {
    if (policy == 3)
    {
      v9 = objc_msgSend(value, sel_copy);
      goto LABEL_11;
    }
    v8 = value;
    if (policy == 1)
    {
      v9 = value;
LABEL_11:
      v8 = v9;
    }
  }
  else
  {
    v8 = 0;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v11 = *(_DWORD *)(StatusReg + 24);
  do
  {
    if (__ldaxr((unsigned int *)&AssociationsManagerLock))
    {
      __clrex();
      os_unfair_lock_lock_with_options();
      if (!value)
        goto LABEL_23;
LABEL_16:
      v40 = 0;
      v13 = objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(-(uint64_t)object, &v40);
      v14 = v40;
      if ((v13 & 1) != 0)
      {
LABEL_46:
        v40 = 0;
        if ((objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>((uint64_t)&v14[1], (unint64_t)v39, &v40) & 1) != 0)
        {
          v27 = v40 + 2;
          v22 = (void *)v40[2];
          v14 = (int32x2_t *)v40[1];
          v40[1] = (int32x2_t)policy;
        }
        else
        {
          inserted = (int32x2_t *)objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::InsertIntoBucketImpl<void const*>(v14 + 1, (unint64_t *)&v39, v40);
          LOBYTE(v14) = 0;
          v22 = 0;
          *inserted = (int32x2_t)v39;
          inserted[1] = (int32x2_t)policy;
          v27 = inserted + 2;
        }
        *v27 = (int32x2_t)v8;
        v29 = *(_DWORD *)(StatusReg + 24);
        while (1)
        {
          v30 = __ldxr((unsigned int *)&AssociationsManagerLock);
          if (v30 != v29)
            break;
          if (!__stlxr(0, (unsigned int *)&AssociationsManagerLock))
            goto LABEL_54;
        }
        __clrex();
        os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
LABEL_54:
        if ((uint64_t)object < 0)
          v31 = 1;
        else
          v31 = v13;
        if ((v31 & 1) != 0)
        {
LABEL_62:
          if (!v22)
            return;
        }
        else
        {
          if ((*(_QWORD *)object & 1) == 0)
          {
            v32 = *(_QWORD *)((*(_QWORD *)object & 0xFFFFFFFF8) + 0x20);
            if ((v32 & 4) == 0
              && ((unint64_t)(*(_QWORD *)(*(_QWORD *)object & 0xFFFFFFFF8) - 1) < 0xF
               || (*(_BYTE *)((v32 & 0xF00007FFFFFFFF8) + 3) & 0x40) == 0)
              && (*(_WORD *)((*(_QWORD *)object & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
            {
              MethodImplementation = (void (*)(void))object_getMethodImplementation((unint64_t)object, (objc_selector *)sel__noteAssociatedObjects);
              if (MethodImplementation != _objc_msgForward)
                ((void (*)(id, char *))MethodImplementation)(object, sel__noteAssociatedObjects);
            }
          }
          while (1)
          {
            v33 = __ldxr((unint64_t *)object);
            if ((v33 & 3) != 1)
              break;
            if (!__stxr(v33 | 2, (unint64_t *)object))
              goto LABEL_62;
          }
          __clrex();
          if (!v22)
            return;
        }
LABEL_63:
        if ((v14 & 1) != 0)

        return;
      }
      if (4 * (int)qword_1ECCE5490 + 4 >= (3 * dword_1ECCE5498))
      {
        objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::grow(2 * dword_1ECCE5498);
        v40 = 0;
        objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(-(uint64_t)object, &v40);
      }
      else
      {
        if (dword_1ECCE5498 + ~(_DWORD)qword_1ECCE5490 - HIDWORD(qword_1ECCE5490) > dword_1ECCE5498 >> 3)
        {
LABEL_19:
          if (*v14 == 2)
          {
            qword_1ECCE5490 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE5490, (int32x2_t)0xFFFFFFFF00000001);
          }
          else if (-*(_QWORD *)v14 == -1)
          {
            LODWORD(qword_1ECCE5490) = qword_1ECCE5490 + 1;
          }
          else
          {
            free(*(void **)&v14[1]);
          }
          v14[1] = 0;
          v14[2] = 0;
          *v14 = (int32x2_t)-(uint64_t)object;
          v14[3].i32[0] = 0;
          goto LABEL_46;
        }
        objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::grow(dword_1ECCE5498);
        v40 = 0;
        objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(-(uint64_t)object, &v40);
      }
      v14 = v40;
      goto LABEL_19;
    }
  }
  while (__stxr(v11, (unsigned int *)&AssociationsManagerLock));
  if (value)
    goto LABEL_16;
LABEL_23:
  v40 = 0;
  v15 = objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(-(uint64_t)object, &v40);
  v16 = v40;
  if (v40 == (int32x2_t *)(objc::AssociationsManager::_mapStorage + 32 * dword_1ECCE5498))
    v17 = 0;
  else
    v17 = v15;
  if (v17 == 1
    && ((v18 = (void **)&v40[1],
         v40 = 0,
         v19 = objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>((uint64_t)&v16[1], (unint64_t)v39, &v40), v20 = v40, v40 != (int32x2_t *)(*(_QWORD *)&v16[1] + 24 * v16[3].u32[0]))? (v21 = v19): (v21 = 0), v21 == 1))
  {
    v14 = (int32x2_t *)v40[1];
    v22 = (void *)v40[2];
    v40[1] = (int32x2_t)policy;
    v20[2] = (int32x2_t)v8;
    *v20 = (int32x2_t)-2;
    v23 = vadd_s32(v16[2], (int32x2_t)0x1FFFFFFFFLL);
    v16[2] = v23;
    v24 = v16[3].u32[0];
    if (v23.i32[0])
    {
      if (v24 >= 0x401 && v24 >> 4 > v23.i32[0])
      {
        objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::grow((uint64_t)&v16[1], 2 * v23.i32[0]);
        if (!v16[2].i32[0])
          goto LABEL_70;
      }
    }
    else
    {
      if (v24)
      {
        free(*v18);
        *v18 = 0;
        v16[2] = 0;
        v16[3].i32[0] = 0;
      }
      else
      {
        v16[2] = 0;
      }
LABEL_70:
      free(*(void **)&v16[1]);
      *v16 = (int32x2_t)2;
      qword_1ECCE5490 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE5490, (int32x2_t)0x1FFFFFFFFLL);
      objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::compact();
    }
  }
  else
  {
    LOBYTE(v14) = (_BYTE)policy;
    v22 = v8;
  }
  v25 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v26 = __ldxr((unsigned int *)&AssociationsManagerLock);
    if (v26 != v25)
      break;
    if (!__stlxr(0, (unsigned int *)&AssociationsManagerLock))
      goto LABEL_62;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
  if (v22)
    goto LABEL_63;
}

id objc_getAssociatedObject(id object, const void *key)
{
  unint64_t StatusReg;
  unsigned int v5;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  void *v13;
  uint64_t v14;
  id v15;
  int v16;
  unsigned int v17;
  uint64_t v19;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&AssociationsManagerLock))
  {
    if (!__stxr(v5, (unsigned int *)&AssociationsManagerLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v19 = 0;
  v7 = objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(-(uint64_t)object, &v19);
  v8 = v19;
  if (v19 == objc::AssociationsManager::_mapStorage + 32 * dword_1ECCE5498)
    v9 = 0;
  else
    v9 = v7;
  if (v9 == 1
    && ((v10 = v19 + 8,
         v19 = 0,
         v11 = objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>(v10, (unint64_t)key, &v19), v19 != *(_QWORD *)(v8 + 8) + 24 * *(unsigned int *)(v8 + 24))? (v12 = v11): (v12 = 0), v12 == 1))
  {
    v14 = *(_QWORD *)(v19 + 8);
    v13 = *(void **)(v19 + 16);
    if (v13)
    {
      if ((v14 & 0x100) != 0)
        v15 = v13;
    }
  }
  else
  {
    v13 = 0;
    LOWORD(v14) = 0;
  }
  v16 = *(_DWORD *)(StatusReg + 24);
  do
  {
    v17 = __ldxr((unsigned int *)&AssociationsManagerLock);
    if (v17 != v16)
    {
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
      if (v13)
        goto LABEL_24;
      return v13;
    }
  }
  while (__stlxr(0, (unsigned int *)&AssociationsManagerLock));
  if (!v13)
    return v13;
LABEL_24:
  if ((v14 & 0x200) == 0)
    return v13;
  return v13;
}

void sub_18010E108(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  unsigned int v11;
  BOOL v12;
  unsigned int v13;

  v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    v4 = v3 - 1;
    v5 = (v3 - 1) & (bswap64(0x8A970BE7488FDA55 * (a2 ^ (a2 >> 4))) ^ (1217387093 * (a2 ^ (a2 >> 4))));
    v6 = (_QWORD *)(*(_QWORD *)a1 + 24 * v5);
    v7 = *v6;
    if (*v6 == a2)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -1)
      {
        if (v11 > v3)
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, *(_QWORD **)a1, *(unsigned int *)(a1 + 16));
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -2;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(*(_QWORD *)a1 + 24 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a2)
          goto LABEL_5;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_5:
  *a3 = v6;
  return v8;
}

void objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::compact()
{
  uint64_t v1;
  void **v2;

  if ((_DWORD)qword_1ECCE5490)
  {
    if (dword_1ECCE5498 >= 0x401 && dword_1ECCE5498 >> 4 > qword_1ECCE5490)
      objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::grow(2 * qword_1ECCE5490);
  }
  else
  {
    if (!dword_1ECCE5498)
      goto LABEL_15;
    v1 = 32 * dword_1ECCE5498;
    v2 = (void **)(objc::AssociationsManager::_mapStorage + 8);
    do
    {
      if ((char *)*(v2 - 1) - 1 >= (char *)2)
        free(*v2);
      v2 += 4;
      v1 -= 32;
    }
    while (v1);
    if (dword_1ECCE5498)
    {
      free((void *)objc::AssociationsManager::_mapStorage);
      objc::AssociationsManager::_mapStorage = 0;
      qword_1ECCE5490 = 0;
      dword_1ECCE5498 = 0;
    }
    else
    {
LABEL_15:
      qword_1ECCE5490 = 0;
    }
  }
}

void objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::grow(int a1)
{
  uint64_t v1;
  _DWORD *v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v1 = dword_1ECCE5498;
  v2 = (_DWORD *)objc::AssociationsManager::_mapStorage;
  v3 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
  v5 = v4 | HIWORD(v4);
  if ((v5 + 1) > 4)
    v6 = v5 + 1;
  else
    v6 = 4;
  dword_1ECCE5498 = v6;
  v7 = malloc_type_malloc(32 * v6, 0x64B88C75uLL);
  objc::AssociationsManager::_mapStorage = (uint64_t)v7;
  if (v2)
  {
    qword_1ECCE5490 = 0;
    if (dword_1ECCE5498)
    {
      v8 = 32 * dword_1ECCE5498;
      do
      {
        *v7 = 1;
        v7 += 4;
        v8 -= 32;
      }
      while (v8);
    }
    if ((_DWORD)v1)
    {
      v9 = 32 * v1;
      v10 = v2 + 6;
      do
      {
        v11 = *((_QWORD *)v10 - 3);
        if ((unint64_t)(v11 - 1) >= 2)
        {
          v15 = 0;
          objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(v11, &v15);
          v12 = v15;
          v13 = *((_QWORD *)v10 - 3);
          *(_DWORD *)(v15 + 24) = 0;
          *(_QWORD *)(v12 + 8) = 0;
          *(_QWORD *)(v12 + 16) = 0;
          *(_QWORD *)v12 = v13;
          *(_QWORD *)(v12 + 8) = *((_QWORD *)v10 - 2);
          *((_QWORD *)v10 - 2) = 0;
          *(_DWORD *)(v12 + 16) = *(v10 - 2);
          *(v10 - 2) = 0;
          LODWORD(v13) = *(_DWORD *)(v12 + 20);
          *(_DWORD *)(v12 + 20) = *(v10 - 1);
          *(v10 - 1) = v13;
          LODWORD(v13) = *(_DWORD *)(v12 + 24);
          *(_DWORD *)(v12 + 24) = *v10;
          *v10 = v13;
          LODWORD(qword_1ECCE5490) = qword_1ECCE5490 + 1;
        }
        v10 += 8;
        v9 -= 32;
      }
      while (v9);
    }
    free(v2);
  }
  else
  {
    qword_1ECCE5490 = 0;
    if (dword_1ECCE5498)
    {
      v14 = 32 * dword_1ECCE5498;
      do
      {
        *v7 = 1;
        v7 += 4;
        v14 -= 32;
      }
      while (v14);
    }
  }
}

void objc_exception_throw(id exception)
{
  _QWORD *v2;
  unint64_t v3;
  __objc2_class *v4;
  const char *ClassName;
  const char *v6;
  int v7;
  int v8;
  void *v9[2];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v2 = __cxa_allocate_exception(0x20uLL);
  v3 = exception_preprocessor[0]((objc_object *)exception);
  objc_msgSend((id)v3, sel_retain);
  *v2 = v3;
  v2[1] = off_1E0DF3828;
  v2[2] = object_getClassName((id)v3);
  if (v3)
  {
    if ((v3 & 0x8000000000000000) != 0)
    {
      v4 = (__objc2_class *)objc_debug_taggedpointer_classes[v3 & 7];
      if (v4 == __NSUnrecognizedTaggedPointer)
        v4 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[(v3 >> 55)];
    }
    else
    {
      v4 = (__objc2_class *)(*(_QWORD *)v3 & 0xFFFFFFFF8);
    }
  }
  else
  {
    v4 = 0;
  }
  v2[3] = v4;
  if (PrintExceptions)
  {
    ClassName = object_getClassName((id)v3);
    _objc_inform("EXCEPTIONS: throwing %p (object %p, a %s)", v2, (const void *)v3, ClassName);
  }
  if (PrintExceptionThrow)
  {
    if (!PrintExceptions)
    {
      v6 = object_getClassName((id)v3);
      _objc_inform("EXCEPTIONS: throwing %p (object %p, a %s)", v2, (const void *)v3, v6);
    }
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    *(_OWORD *)v9 = 0u;
    v10 = 0u;
    v7 = backtrace(v9, 500);
    v8 = fileno((FILE *)*MEMORY[0x1E0C80C10]);
    backtrace_symbols_fd(v9, v7, v8);
  }
  __cxa_throw(v2, (struct type_info *)(v2 + 1), (void (*)(void *))_objc_exception_destructor);
}

const char *__cdecl object_getClassName(id a1)
{
  const char *v1;
  char *v2;
  __objc2_class *v4;

  if (!a1)
    return "nil";
  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    v4 = (__objc2_class *)objc_debug_taggedpointer_classes[a1 & 7];
    if (v4 == __NSUnrecognizedTaggedPointer)
      v4 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[((unint64_t)a1 >> 55)];
  }
  else
  {
    v4 = (__objc2_class *)(*(_QWORD *)a1 & 0xFFFFFFFF8);
  }
  if (v4)
    return (const char *)objc_class::demangledName((objc_class *)v4, 1, v1, v2);
  else
    return "nil";
}

objc_object *objc_retainAutoreleaseAndReturn(objc_object *a1)
{
  return a1;
}

objc_object *_objc_rootRetain(objc_object *result)
{
  unint64_t v1;
  BOOL v2;
  unint64_t v3;

  if (((unint64_t)result & 0x8000000000000000) == 0)
  {
    v1 = __ldxr((unint64_t *)result);
    if ((v1 & 1) != 0)
    {
      while (v1 >> 44)
      {
        v2 = __CFADD__(v1, 0x200000000000);
        v3 = v1 + 0x200000000000;
        if (v2)
        {
          __clrex();
          return objc_object::rootRetain_overflow(result, 0);
        }
        if (!__stxr(v3, (unint64_t *)result))
          return result;
        v1 = __ldxr((unint64_t *)result);
        if ((v1 & 1) == 0)
          goto LABEL_9;
      }
    }
    else if ((*(_WORD *)((v1 & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
    {
LABEL_9:
      __clrex();
      return objc_object::sidetable_retain(result, 0);
    }
    __clrex();
  }
  return result;
}

const char *__cdecl property_getAttributes(objc_property_t property)
{
  return (const char *)*((_QWORD *)property + 1);
}

void objc_removeAssociatedObjects(id object)
{
  if (object && (((unint64_t)object & 0x8000000000000000) != 0 || (*(_QWORD *)object & 3) != 1))
    _object_remove_associations((uint64_t)object, 0);
}

BOOL class_addProtocol(Class cls, Protocol *protocol)
{
  Class v3;
  unint64_t StatusReg;
  unsigned int v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  const char *v11;
  int v12;
  unsigned int v13;
  _QWORD *v15;

  if (cls)
  {
    v3 = cls;
    if (class_conformsToProtocol(cls, protocol))
    {
      LOBYTE(cls) = 0;
    }
    else
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v5 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr(runtimeLock))
      {
        if (!__stxr(v5, runtimeLock))
          goto LABEL_9;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_9:
      v7 = *((_QWORD *)v3 + 4) & 0xF00007FFFFFFFF8;
      v8 = *(_QWORD *)(v7 + 8);
      v9 = v8 & 0xFFFFFFFFFFFFFFFELL;
      if ((v8 & 1) == 0)
        v9 = class_rw_t::extAlloc(v7, v8 & 0xFFFFFFFFFFFFFFFELL, 0);
      v10 = malloc_type_malloc(0x10uLL, 0xE73314F2uLL);
      v15 = v10;
      *v10 = 1;
      v10[1] = protocol;
      if (PrintPreopt)
        v11 = "protocols";
      else
        v11 = 0;
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(v9 + 24), (uint64_t)&v15, (const char *)1, 0, v11);
      v12 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v13 = __ldxr(runtimeLock);
        if (v13 != v12)
          break;
        if (!__stlxr(0, runtimeLock))
          goto LABEL_19;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_19:
      LOBYTE(cls) = 1;
    }
  }
  return (char)cls;
}

void sub_18010E878(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

Ivar object_setInstanceVariableWithStrongDefault(id obj, const char *name, void *value)
{
  char *v3;
  unsigned int *Variable;
  id *v7;
  unsigned int v9;
  uint64_t v10;

  Variable = 0;
  if ((uint64_t)obj >= 1)
  {
    if (name)
    {
      Variable = (unsigned int *)_class_getVariable((objc_class *)(*(_QWORD *)obj & 0xFFFFFFFF8), name, (const char *)value, v3);
      if (Variable)
      {
        v10 = 0;
        v9 = 0;
        _class_lookUpIvar(*(_QWORD *)obj & 0xFFFFFFFF8, Variable, (char *)&v10, (char *)&v9);
        v7 = (id *)((char *)obj + v10);
        if (v9 < 2)
        {
          objc_storeStrong(v7, value);
        }
        else if (v9 == 3)
        {
          *v7 = value;
        }
        else if (v9 == 2)
        {
          objc_storeWeak(v7, value);
        }
      }
    }
  }
  return (Ivar)Variable;
}

BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)
{
  int v5;
  const char *v8;
  const char *v9;
  BOOL v10;
  unint64_t StatusReg;
  unsigned int v12;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  uint64_t Ivar;
  uint64_t v21;
  const char *v22;
  char *v23;
  uint64_t v24;
  _QWORD *v25;
  unsigned int *v26;
  uint64_t v27;
  unint64_t v28;
  size_t v29;
  unsigned int *v30;
  uint64_t v31;
  const char *v32;
  char *v33;
  uint64_t v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  _DWORD *v40;
  int v41;
  uint64_t v42;
  size_t v43;
  void *v44;
  size_t v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  unint64_t ro_writeable_nolock;
  char *__s;

  if (!cls)
    return 0;
  v5 = alignment;
  v8 = "";
  if (types)
    v8 = types;
  __s = (char *)v8;
  if (name)
  {
    if (*name)
      v9 = name;
    else
      v9 = 0;
  }
  else
  {
    v9 = 0;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v12 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v12, runtimeLock))
      goto LABEL_15;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_15:
  if ((unint64_t)(*(_QWORD *)cls - 1) < 0xF
    || (*(_DWORD *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (v14 = *(unsigned __int16 *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
        dword_1ECCE5988 <= v14)
    || (*(_QWORD *)(qword_1ECCE5980 + 16 * v14) <= (unint64_t)cls
      ? (v15 = *(_QWORD *)(qword_1ECCE5980 + 16 * v14 + 8) > (unint64_t)cls)
      : (v15 = 0),
        !v15))
  {
    if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)cls)
      && (dataSegmentsContain(cls, v47, (unsigned int *)size) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v48, (const char *)size, (char *)alignment, cls);
    }
  }
  if ((*((_WORD *)cls + 15) & 4) != 0)
    goto LABEL_25;
  v16 = *((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8;
  if ((*(_BYTE *)(v16 + 3) & 4) == 0)
    goto LABEL_25;
  if (v9)
  {
    Ivar = getIvar(cls, v9, (const char *)size, (char *)alignment);
    v10 = 0;
    if (HIDWORD(size) || Ivar)
      goto LABEL_26;
    v16 = *((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8;
  }
  else if (HIDWORD(size))
  {
LABEL_25:
    v10 = 0;
    goto LABEL_26;
  }
  ro_writeable_nolock = make_ro_writeable_nolock(v16);
  v24 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
  v25 = (_QWORD *)(v24 & 0xFFFFFFFFFFFFFFFELL);
  if ((v24 & 1) != 0)
    v25 = (_QWORD *)*v25;
  v26 = (unsigned int *)v25[6];
  if (v26)
  {
    v27 = *v26;
    v28 = v26[1] * (unint64_t)v27;
    if ((v28 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: count %u with entsize %u", v21, v22, v23, v26[1], v27);
    v29 = v28 + 8;
    v30 = (unsigned int *)malloc_type_calloc(v29 + v27, 1uLL, 0x6A23870CuLL);
    memcpy(v30, v26, v29);
    free(v26);
  }
  else
  {
    v30 = (unsigned int *)malloc_type_calloc(0x28uLL, 1uLL, 0x2B3CB0EDuLL);
    *v30 = 32;
  }
  v34 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
  v35 = v34 & 0xFFFFFFFFFFFFFFFELL;
  if ((v34 & 1) != 0)
    v35 = *(_QWORD *)v35;
  v36 = *(_DWORD *)(v35 + 8);
  v38 = *v30;
  v37 = v30[1];
  v30[1] = v37 + 1;
  v39 = v37 * (unint64_t)v38;
  if ((v39 & 0xFFFFFFFF00000000) != 0)
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v31, v32, v33, v37, v30, v38);
  v40 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  v41 = (v36 + ~(-1 << v5)) & (-1 << v5);
  v42 = (uint64_t)v30 + v39 + 8;
  *(_QWORD *)v42 = v40;
  v49 = v41;
  *v40 = v41;
  if (v9)
  {
    v43 = strlen(v9) + 1;
    if ((_dyld_is_memory_immutable() & 1) == 0)
    {
      v44 = malloc_type_malloc(v43, 0x3F84A03uLL);
      memcpy(v44, v9, v43);
      v9 = (const char *)v44;
    }
  }
  *(_QWORD *)(v42 + 8) = v9;
  v45 = strlen(__s) + 1;
  if ((_dyld_is_memory_immutable() & 1) != 0)
  {
    v46 = __s;
  }
  else
  {
    v46 = malloc_type_malloc(v45, 0x3F84A03uLL);
    memcpy(v46, __s, v45);
  }
  *(_QWORD *)(v42 + 16) = v46;
  *(_DWORD *)(v42 + 24) = v5;
  *(_DWORD *)(v42 + 28) = size;
  *(_QWORD *)(ro_writeable_nolock + 48) = v30;
  objc_class::setInstanceSize((uint64_t)cls, v49 + size);
  v10 = 1;
LABEL_26:
  v17 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v18 = __ldxr(runtimeLock);
    if (v18 != v17)
      break;
    if (!__stlxr(0, runtimeLock))
      return v10;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v10;
}

void sub_18010ED40(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  unsigned int *v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v1 + 24);
  while (1)
  {
    v5 = __ldxr(v2);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v2))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t _class_getVariable(objc_class *a1, const char *a2, const char *a3, char *a4)
{
  objc_class *v5;
  unint64_t StatusReg;
  unsigned int v7;
  uint64_t Ivar;
  int v10;
  unsigned int v11;

  v5 = a1;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v7, runtimeLock))
    {
      if (a1)
        goto LABEL_5;
      goto LABEL_7;
    }
  }
  __clrex();
  os_unfair_lock_lock_with_options();
  if (!v5)
  {
LABEL_7:
    Ivar = 0;
    goto LABEL_8;
  }
LABEL_5:
  while (1)
  {
    Ivar = getIvar(v5, a2, a3, a4);
    if (Ivar)
      break;
    v5 = (objc_class *)*((_QWORD *)v5 + 1);
    if (!v5)
      goto LABEL_7;
  }
LABEL_8:
  v10 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v11 = __ldxr(runtimeLock);
    if (v11 != v10)
      break;
    if (!__stlxr(0, runtimeLock))
      return Ivar;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return Ivar;
}

void sub_18010EE54(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t getIvar(objc_class *a1, const char *__s1, const char *a3, char *a4)
{
  uint64_t v5;
  _QWORD *v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;

  v5 = *(_QWORD *)((*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) + 8);
  v6 = (_QWORD *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  if ((v5 & 1) != 0)
    v6 = (_QWORD *)*v6;
  v7 = (unsigned int *)v6[6];
  if (!v7)
    return 0;
  v9 = *v7;
  v8 = v7[1];
  v10 = v8 * (unint64_t)v9;
  if ((v10 & 0xFFFFFFFF00000000) != 0)
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)__s1, a3, a4, v8, v7, v9);
  if (!(_DWORD)v10)
    return 0;
  v11 = 0;
  v12 = v10;
  while (1)
  {
    if (*(_QWORD *)((char *)v7 + v11 + 8))
    {
      v13 = *(const char **)((char *)v7 + v11 + 16);
      if (v13)
      {
        if (!strcmp(__s1, v13))
          break;
      }
    }
    v11 += v9;
    if (v12 == v11)
      return 0;
  }
  return (uint64_t)v7 + v11 + 8;
}

uint64_t _class_getIvarMemoryManagement(uint64_t a1, unsigned int *a2)
{
  unsigned int v3;
  uint64_t v4;

  v4 = 0;
  v3 = 0;
  _class_lookUpIvar(a1, a2, (char *)&v4, (char *)&v3);
  return v3;
}

id object_getIvar(id a1, Ivar a2)
{
  id result;
  id *v4;
  int v5;
  uint64_t v6;

  result = 0;
  if ((uint64_t)a1 >= 1 && a2)
  {
    v6 = 0;
    v5 = 0;
    _class_lookUpIvar(*(_QWORD *)a1 & 0xFFFFFFFF8, (unsigned int *)a2, (char *)&v6, (char *)&v5);
    v4 = (id *)((char *)a1 + v6);
    if (v5 == 2)
      return objc_loadWeak(v4);
    else
      return *v4;
  }
  return result;
}

void object_setIvar(id obj, Ivar ivar, id value)
{
  uint64_t v3;
  uint64_t v4;
  id *v7;
  int v8;
  _QWORD v9[5];

  if ((uint64_t)obj >= 1 && ivar)
  {
    v9[3] = v3;
    v9[4] = v4;
    v9[0] = 0;
    v8 = 0;
    _class_lookUpIvar(*(_QWORD *)obj & 0xFFFFFFFF8, (unsigned int *)ivar, (char *)v9, (char *)&v8);
    v7 = (id *)((char *)obj + v9[0]);
    switch(v8)
    {
      case 0:
      case 3:
        *v7 = value;
        break;
      case 1:
        objc_storeStrong(v7, value);
        break;
      case 2:
        objc_storeWeak(v7, value);
        break;
      default:
        return;
    }
  }
}

void _class_lookUpIvar(uint64_t a1, unsigned int *a2, char *a3, char *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t StatusReg;
  unsigned int v13;
  uint64_t v15;
  _QWORD *v16;
  unsigned int *v17;
  unsigned int *v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  unsigned __int8 *v33;
  uint64_t v34;
  int64_t v35;
  char v36;
  unsigned int v37;
  uint64_t v38;
  int v40;
  uint64_t v41;
  _QWORD *v42;
  unsigned __int8 *v43;
  uint64_t v44;
  int64_t v45;
  char v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v50;
  _QWORD *v51;

  v7 = a1;
  if (a2)
    v8 = **(int **)a2;
  else
    v8 = 0;
  *(_QWORD *)a3 = v8;
  if (!a1)
    goto LABEL_62;
  v9 = a1;
  while (1)
  {
    v10 = *(_QWORD *)((*(_QWORD *)(v9 + 32) & 0xF00007FFFFFFFF8) + 8);
    v11 = (_QWORD *)(v10 & 0xFFFFFFFFFFFFFFFELL);
    if ((v10 & 1) != 0)
      v11 = (_QWORD *)*v11;
    if ((*(_WORD *)v11 & 0x280) != 0)
      break;
    v9 = *(_QWORD *)(v9 + 8);
    if (!v9)
      goto LABEL_62;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v13 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v13, runtimeLock))
      goto LABEL_16;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
  do
  {
LABEL_16:
    v15 = *(_QWORD *)((*(_QWORD *)(v7 + 32) & 0xF00007FFFFFFFF8) + 8);
    v16 = (_QWORD *)(v15 & 0xFFFFFFFFFFFFFFFELL);
    if ((v15 & 1) != 0)
      v16 = (_QWORD *)*v16;
    v17 = (unsigned int *)v16[6];
    v18 = v17 + 2;
    if (v17)
      v19 = v18 > a2;
    else
      v19 = 1;
    if (!v19)
    {
      v21 = *v17;
      v20 = v17[1];
      v22 = v20 * (unint64_t)v21;
      if ((v22 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v20, v17, v21);
      if ((unsigned int *)((char *)v18 + v22) > a2)
        break;
    }
    v7 = *(_QWORD *)(v7 + 8);
  }
  while (v7);
  v23 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v24 = __ldxr(runtimeLock);
    if (v24 != v23)
      break;
    if (!__stlxr(0, runtimeLock))
      goto LABEL_30;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_30:
  v25 = *(_QWORD *)((*(_QWORD *)(v7 + 32) & 0xF00007FFFFFFFF8) + 8);
  v26 = (_QWORD *)(v25 & 0xFFFFFFFFFFFFFFFELL);
  if ((v25 & 1) != 0)
    v26 = (_QWORD *)*v26;
  if ((*(_WORD *)v26 & 0x280) == 0)
    goto LABEL_62;
  v27 = *(_QWORD *)((*(_QWORD *)(v7 + 32) & 0xF00007FFFFFFFF8) + 8);
  v28 = v27 & 0xFFFFFFFFFFFFFFFELL;
  if ((v27 & 1) != 0)
    v28 = *(_QWORD *)v28;
  v29 = (*(_DWORD *)(v28 + 4) + 7) & 0xFFFFFFF8;
  v30 = *(_QWORD *)((*(_QWORD *)(v7 + 32) & 0xF00007FFFFFFFF8) + 8);
  v31 = (_QWORD *)(v30 & 0xFFFFFFFFFFFFFFFELL);
  if ((v30 & 1) != 0)
    v31 = (_QWORD *)*v31;
  v32 = *(_QWORD *)a3 - v29;
  if ((*(_BYTE *)v31 & 1) != 0)
    goto LABEL_48;
  v33 = (unsigned __int8 *)v31[2];
  if (!v33)
    goto LABEL_48;
  v34 = 0;
  v35 = v32 >> 3;
  do
  {
    v37 = *v33++;
    v36 = v37;
    v38 = v34 + ((unint64_t)v37 >> 4);
    if (!v37 || v38 > v35)
      break;
    v34 = v38 + (v36 & 0xF);
    v40 = 1;
  }
  while (v34 <= v35);
  if (v7)
  {
LABEL_48:
    v41 = *(_QWORD *)((*(_QWORD *)(v7 + 32) & 0xF00007FFFFFFFF8) + 8);
    v42 = (_QWORD *)(v41 & 0xFFFFFFFFFFFFFFFELL);
    if ((v41 & 1) != 0)
      v42 = (_QWORD *)*v42;
    v43 = (unsigned __int8 *)v42[7];
    if (v43)
    {
      v44 = 0;
      v45 = v32 >> 3;
      while (1)
      {
        v47 = *v43++;
        v46 = v47;
        v48 = v44 + ((unint64_t)v47 >> 4);
        if (!v47 || v48 > v45)
          break;
        v44 = v48 + (v46 & 0xF);
        if (v44 > v45)
        {
          v40 = 2;
          goto LABEL_63;
        }
      }
    }
  }
  v50 = *(_QWORD *)((*(_QWORD *)(v7 + 32) & 0xF00007FFFFFFFF8) + 8);
  v51 = (_QWORD *)(v50 & 0xFFFFFFFFFFFFFFFELL);
  if ((v50 & 1) != 0)
    v51 = (_QWORD *)*v51;
  if ((*(_BYTE *)v51 & 0x80) != 0)
    v40 = 3;
  else
LABEL_62:
    v40 = 0;
LABEL_63:
  *(_DWORD *)a4 = v40;
}

void sub_18010F354(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  char *v5;
  unint64_t StatusReg;
  unsigned int v7;
  int v9;
  unsigned int v10;
  char *v12;

  if (look_up_class((char *)name))
    return 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v7, runtimeLock))
      goto LABEL_8;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_8:
  if (getClassExceptSomeSwift((char *)name)
    || superclass
    && ((unint64_t)(*(_QWORD *)superclass - 1) < 0xF
     || (*(_DWORD *)(*((_QWORD *)superclass + 4) & 0xF00007FFFFFFFF8) & 0x84000000) != 0x80000000))
  {
    v5 = 0;
  }
  else
  {
    v5 = alloc_class_for_subclass(superclass);
    v12 = alloc_class_for_subclass(superclass);
    objc_initializeClassPair_internal(superclass, name, (objc_class *)v5, (uint64_t)v12);
  }
  v9 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v10 = __ldxr(runtimeLock);
    if (v10 != v9)
      break;
    if (!__stlxr(0, runtimeLock))
      return (Class)v5;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return (Class)v5;
}

void sub_18010F4BC(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

objc_class *objc_readClassPair(objc_class *a1)
{
  unint64_t StatusReg;
  unsigned int v3;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  objc_class *v9;
  objc_class *Class;
  int v11;
  unsigned int v12;
  char *v14;
  uint64_t v15;
  const char *v16;
  char *v17;
  objc_class *v18;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v3, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v5 = *((_QWORD *)a1 + 4);
  v6 = (_QWORD *)(v5 & 0xF00007FFFFFFFF8);
  if (v5 < 0)
  {
    v7 = *(_QWORD *)((v5 & 0xF00007FFFFFFFF8) + 8);
    v6 = (_QWORD *)(v7 & 0xFFFFFFFFFFFFFFFELL);
    if ((v7 & 1) != 0)
      v6 = (_QWORD *)*v6;
  }
  v8 = (_QWORD *)*((_QWORD *)a1 + 1);
  if (v8)
  {
    if ((unint64_t)(*v8 - 1) < 0xF || (*(_DWORD *)(v8[4] & 0xF00007FFFFFFFF8) & 0x84000000) != 0x80000000)
      goto LABEL_12;
LABEL_14:
    Class = (objc_class *)readClass(a1, 0, 0);
    if (Class != a1)
    {
      v18 = Class;
      v14 = objc_class::nameForLogging(Class);
      _objc_fatal("objc_readClassPair for class %s changed %p to %p", v15, v16, v17, v14, a1, v18);
    }
    v9 = realizeClassWithoutSwift(a1, 0);
    goto LABEL_16;
  }
  if ((*(_BYTE *)v6 & 2) != 0)
    goto LABEL_14;
LABEL_12:
  v9 = 0;
LABEL_16:
  v11 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v12 = __ldxr(runtimeLock);
    if (v12 != v11)
      break;
    if (!__stlxr(0, runtimeLock))
      return v9;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v9;
}

void sub_18010F650(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

char *alloc_class_for_subclass(objc_class *a1)
{
  size_t v2;
  char *v3;
  char *v4;
  char *v5;
  uint64_t *v6;
  uint64_t v7;
  void (*v8)(objc_class *, char *);

  if (!a1 || (*((_BYTE *)a1 + 32) & 3) == 0)
    return (char *)malloc_type_zone_malloc_with_options_internal();
  v2 = *((unsigned int *)a1 + 14);
  v3 = (char *)a1 - *((unsigned int *)a1 + 15);
  v4 = (char *)malloc_type_zone_malloc_with_options_internal();
  memcpy(v4, v3, v2);
  v5 = &v4[*((unsigned int *)a1 + 15)];
  *((_QWORD *)v5 + 4) = 0;
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_QWORD *)v5 + 8) = 0;
  if (classCopyFixupHandlers >= 2uLL)
    v6 = (uint64_t *)qword_1ECCE5680;
  else
    v6 = &qword_1ECCE5680;
  if (classCopyFixupHandlers)
  {
    v7 = 8 * classCopyFixupHandlers;
    do
    {
      v8 = (void (*)(objc_class *, char *))*v6++;
      v8(a1, v5);
      v7 -= 8;
    }
    while (v7);
  }
  return v5;
}

uint64_t objc_initializeClassPair_internal(objc_class *a1, const char *a2, objc_class *a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  void *v10;
  unint64_t *v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  BOOL v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  size_t v37;
  uint64_t v38;
  const char *v39;
  char *v40;
  void *v41;
  unsigned __int16 *v42;
  unsigned __int16 v43;
  unsigned __int16 v44;
  int v45;
  uint64_t v46;
  objc_class *v47;
  unint64_t v48;
  unint64_t v50;
  unint64_t v51;

  v8 = (unint64_t)malloc_type_calloc(0x20uLL, 1uLL, 0x1ECB51D3uLL);
  v9 = (unint64_t)malloc_type_calloc(0x20uLL, 1uLL, 0x1ECB51D3uLL);
  v10 = malloc_type_calloc(0x48uLL, 1uLL, 0xD8E12CD6uLL);
  v11 = (unint64_t *)malloc_type_calloc(0x48uLL, 1uLL, 0xF9518B77uLL);
  v12 = v11;
  *(_DWORD *)v8 = -1945632768;
  *(_DWORD *)v9 = -1945632767;
  *(_DWORD *)v10 = 0;
  *(_DWORD *)v11 = 1;
  v13 = (unint64_t *)((char *)a3 + 32);
  v14 = *((_QWORD *)a3 + 4) & 7 | v8 | 0x8000000000000000;
  __dmb(0xBu);
  *((_QWORD *)a3 + 4) = v14;
  v15 = *(_QWORD *)(v8 + 8);
  if ((v15 & 1) != 0)
    *(_QWORD *)(v15 & 0xFFFFFFFFFFFFFFFELL) = v10;
  else
    *(_QWORD *)(v8 + 8) = v10;
  v16 = (unint64_t *)(a4 + 32);
  v17 = *(_QWORD *)(a4 + 32) & 7 | v9 | 0x8000000000000000;
  __dmb(0xBu);
  *(_QWORD *)(a4 + 32) = v17;
  v18 = *(_QWORD *)(v9 + 8);
  if ((v18 & 1) != 0)
    *(_QWORD *)(v18 & 0xFFFFFFFFFFFFFFFELL) = v11;
  else
    *(_QWORD *)(v9 + 8) = v11;
  if (a1)
  {
    v19 = *((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8;
    *(_DWORD *)v8 |= *(_DWORD *)v19 & 0x100000;
    v20 = *(_QWORD *)(v19 + 8);
    v21 = v20 & 0xFFFFFFFFFFFFFFFELL;
    if ((v20 & 1) != 0)
      v21 = *(_QWORD *)v21;
    *((_DWORD *)v10 + 1) = *(_DWORD *)(v21 + 8);
    v22 = *(_QWORD *)((*(_QWORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8) + 8);
    v23 = v22 & 0xFFFFFFFFFFFFFFFELL;
    if ((v22 & 1) != 0)
      v23 = *(_QWORD *)v23;
    *((_DWORD *)v11 + 1) = *(_DWORD *)(v23 + 8);
    objc_class::setInstanceSize((uint64_t)a3, *((_DWORD *)v10 + 1));
    objc_class::setInstanceSize(a4, *((_DWORD *)v12 + 1));
    if ((*((_BYTE *)a1 + 32) & 2) != 0)
    {
      do
      {
        v24 = __ldxr(v13);
        if (v24)
          v25 = v24 & 0xFFFFFFFFFFFFFFFCLL | 2;
        else
          v25 = 0x8000000000000002;
      }
      while (__stlxr(v25, v13));
      do
      {
        v26 = __ldxr(v16);
        if (v26)
          v27 = v26 & 0xFFFFFFFFFFFFFFFCLL | 2;
        else
          v27 = 0x8000000000000002;
      }
      while (__stlxr(v27, v16));
    }
    if ((*((_BYTE *)a1 + 32) & 1) != 0)
    {
      v28 = __ldxr(v13);
      v29 = v28 & 0xFFFFFFFFFFFFFFFCLL | 1;
      v30 = v28 == 0;
      v31 = 0x8000000000000001;
      if (v30)
        v29 = 0x8000000000000001;
      while (__stlxr(v29, v13))
      {
        v32 = __ldxr(v13);
        if (v32)
          v29 = v32 & 0xFFFFFFFFFFFFFFFCLL | 1;
        else
          v29 = 0x8000000000000001;
      }
      v36 = __ldxr(v16);
      if (v36)
        v31 = v36 & 0xFFFFFFFFFFFFFFFCLL | 1;
      if (__stlxr(v31, v16))
      {
        do
        {
          v50 = __ldxr(v16);
          if (v50)
            v51 = v50 & 0xFFFFFFFFFFFFFFFCLL | 1;
          else
            v51 = 0x8000000000000001;
        }
        while (__stlxr(v51, v16));
      }
    }
  }
  else
  {
    *(_DWORD *)v10 |= 2u;
    v33 = *(_DWORD *)v11 | 2;
    *((_DWORD *)v10 + 1) = 0;
    *(_DWORD *)v11 = v33;
    *((_DWORD *)v11 + 1) = 40;
    v34 = *(_QWORD *)((*v13 & 0xF00007FFFFFFFF8) + 8);
    v35 = v34 & 0xFFFFFFFFFFFFFFFELL;
    if ((v34 & 1) != 0)
      v35 = *(_QWORD *)v35;
    if (*(_DWORD *)(v35 + 8) != 8)
      *(_DWORD *)(v35 + 8) = 8;
    *((_WORD *)a3 + 15) = *((_WORD *)a3 + 15) & 0xF007 | 0x10;
    objc_class::setInstanceSize(a4, *((_DWORD *)v11 + 1));
  }
  v37 = strlen(a2) + 1;
  if ((_dyld_is_memory_immutable() & 1) == 0)
  {
    v41 = malloc_type_malloc(v37, 0x3F84A03uLL);
    memcpy(v41, a2, v37);
    a2 = (const char *)v41;
  }
  atomic_store((unint64_t)a2, (unint64_t *)v10 + 3);
  atomic_store((unint64_t)a2, v12 + 3);
  *((_QWORD *)v10 + 2) = &UnsetLayout;
  *((_QWORD *)v10 + 7) = &UnsetLayout;
  *((_QWORD *)a3 + 2) = &_objc_empty_cache;
  *((_QWORD *)a3 + 3) = 0;
  *(_QWORD *)(a4 + 16) = &_objc_empty_cache;
  *(_QWORD *)(a4 + 24) = 0;
  v42 = (unsigned __int16 *)(a4 + 30);
  do
    v43 = __ldxr(v42);
  while (__stxr(v43 | 4, v42));
  do
    v44 = __ldxr(v42);
  while (__stxr(v44 | 0x2000, v42));
  v45 = DisableNonpointerIsa;
  if (!DisableNonpointerIsa && (*v42 & 0x2000) == 0)
  {
    if ((a4 & 0xFFFFFFF000000007) != 0)
      goto LABEL_60;
    *(_QWORD *)a3 = a4 & 0xFFFFFFFF8 | 0x21A000000001;
    if (a1)
    {
      v46 = *(_QWORD *)(*(_QWORD *)a1 & 0xFFFFFFFF8) & 0xFFFFFFFF8;
      goto LABEL_49;
    }
LABEL_53:
    if ((*v42 & 0x2000) == 0)
    {
      if ((a4 & 0xFFFFFFF000000007) == 0)
      {
        v48 = a4 & 0xFFFFFFFF8 | 0x21A000000001;
LABEL_58:
        *(_QWORD *)a4 = v48;
        *((_QWORD *)a3 + 1) = 0;
        *(_QWORD *)(a4 + 8) = a3;
        ++objc_debug_realized_class_generation_count;
        *(_QWORD *)((*((_QWORD *)a3 + 4) & 0xF00007FFFFFFFF8) + 0x18) = _firstRealizedClass;
        _firstRealizedClass = (uint64_t)a3;
        v47 = a3;
        goto LABEL_59;
      }
      goto LABEL_60;
    }
LABEL_56:
    if ((a4 & 0xFFFFFFF000000007) == 0)
    {
      v48 = a4 & 0xFFFFFFFF8;
      goto LABEL_58;
    }
LABEL_60:
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v38, v39, v40, a4);
  }
  if ((a4 & 0xFFFFFFF000000007) != 0)
    goto LABEL_60;
  *(_QWORD *)a3 = a4 & 0xFFFFFFFF8;
  if (!a1)
  {
    if (v45)
      goto LABEL_56;
    goto LABEL_53;
  }
  v46 = *(_QWORD *)(*(_QWORD *)a1 & 0xFFFFFFFF8) & 0xFFFFFFFF8;
  if (!v45)
  {
LABEL_49:
    if ((*(_WORD *)(v46 + 30) & 0x2000) == 0)
      v46 |= 0x21A000000001uLL;
  }
  *(_QWORD *)a4 = v46;
  *((_QWORD *)a3 + 1) = a1;
  *(_QWORD *)(a4 + 8) = *(_QWORD *)a1 & 0xFFFFFFFF8;
  addSubclass((uint64_t)a1, a3);
  v47 = (objc_class *)(*(_QWORD *)a1 & 0xFFFFFFFF8);
LABEL_59:
  addSubclass((uint64_t)v47, (objc_class *)a4);
  return addClassTableEntry((uint64_t)a3, 1);
}

Protocol **__cdecl class_copyProtocolList(Class cls, unsigned int *outCount)
{
  char *v2;
  char *v3;
  unsigned int *v4;
  unint64_t StatusReg;
  unsigned int v7;
  Protocol **v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  BOOL v18;
  unint64_t v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  unint64_t v24;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unsigned int v30;
  char v31;
  int v32;
  _QWORD *v33;
  unint64_t v34;
  uint64_t *v35;
  _QWORD *v36;
  const char *v37;
  char *v38;
  const char *v39;
  char *v40;
  unsigned int v41;
  uint64_t v42;
  const char *v43;
  char *v44;
  uint64_t v45;
  int v46;
  uint64_t Protocol;
  int v48;
  unsigned int v49;
  unint64_t v51;
  unint64_t v52;
  BOOL v53;
  _QWORD v54[10];
  uint64_t *v55[8];
  uint64_t *v56;
  unint64_t v57;

  v4 = outCount;
  if (!cls)
  {
    v9 = 0;
    if (outCount)
      *outCount = 0;
    return v9;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v7, runtimeLock))
      goto LABEL_9;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_9:
  v10 = *((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8;
  v11 = *(_QWORD *)(v10 + 8);
  v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
  if ((v11 & 1) != 0)
  {
    v14 = *(_QWORD *)(v12 + 24);
    goto LABEL_19;
  }
  v57 = 0;
  v13 = *(_QWORD *)(v12 + 40);
  v14 = v13 & 0xFFFFFFFFFFFFFFFELL;
  if ((v13 & 1) == 0 && v14)
    goto LABEL_19;
  v15 = v13 & 1;
  if (v14)
    v16 = v15 == 0;
  else
    v16 = 1;
  if (!v16)
  {
    v14 |= 2uLL;
LABEL_19:
    v57 = v14;
    goto LABEL_20;
  }
  v14 = 0;
LABEL_20:
  if ((unint64_t)(*(_QWORD *)cls - 1) < 0xF
    || (*(_DWORD *)v10 & 0x80000000) == 0
    || (v17 = *(unsigned __int16 *)(v10 + 4), dword_1ECCE5988 <= v17)
    || (*(_QWORD *)(qword_1ECCE5980 + 16 * v17) <= (unint64_t)cls
      ? (v18 = *(_QWORD *)(qword_1ECCE5980 + 16 * v17 + 8) > (unint64_t)cls)
      : (v18 = 0),
        !v18))
  {
    if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)cls)
      && (dataSegmentsContain(cls, (uint64_t)outCount, (unsigned int *)v2) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", (uint64_t)outCount, v2, v3, cls);
    }
  }
  v19 = v14 & 3;
  v20 = (unsigned int *)(v14 & 0xFFFFFFFFFFFFFFFCLL);
  v21 = (v14 & 0xFFFFFFFFFFFFFFFCLL) == 0 || (v14 & 3) != 0;
  if ((_DWORD)v21 != 1)
  {
    v22 = 0;
    v24 = 0;
    v23 = (unsigned int *)(v14 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_54:
    v31 = v21 ^ 1;
    goto LABEL_55;
  }
  if (v14 >= 4)
  {
    if (v19 != 1 || v20 == 0)
    {
      if (v19 == 2)
        v23 = (unsigned int *)(v14 & 0xFFFFFFFFFFFFFFFCLL);
      else
        v23 = 0;
      if (v23)
      {
        if (DisablePreattachedCategories)
        {
          v26 = *v23;
          v27 = v23[1];
          v52 = v27 * (unint64_t)v26;
          if ((v52 & 0xFFFFFFFF00000000) != 0)
            goto LABEL_107;
          v11 = (unint64_t)v23 + v52 + 8;
          v53 = (_DWORD)v27 == 0;
          if ((_DWORD)v27)
            v27 = v27;
          else
            v27 = 0;
          if (!v53)
            v11 -= v26;
        }
        else
        {
          v11 = (unint64_t)(v23 + 2);
          v26 = *v23;
          v27 = v23[1];
        }
        v28 = v27 * (unint64_t)v26;
        if ((v28 & 0xFFFFFFFF00000000) != 0)
          goto LABEL_107;
        v29 = (unint64_t)v23 + v28 + 8;
        if (v11 < v29)
        {
          while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v11 + 8) & 1) == 0)
          {
            v11 += v26;
            v30 = v26;
            if (v11 >= v29)
              goto LABEL_94;
          }
        }
        v30 = v26;
LABEL_94:
        v22 = v30;
      }
      else
      {
        v22 = 0;
      }
    }
    else
    {
      v22 = 0;
      v23 = v20 + 2;
    }
  }
  else
  {
    v22 = 0;
    v23 = 0;
  }
  v31 = v19 != 1;
  if (v19 == 1 && v20)
  {
    v24 = (unint64_t)&v20[2 * *v20 + 2];
    goto LABEL_54;
  }
  v24 = 0;
  if (v20 && v19 == 2)
  {
    v26 = *v20;
    v27 = v20[1];
    v51 = v27 * (unint64_t)v26;
    if ((v51 & 0xFFFFFFFF00000000) != 0)
    {
      v23 = (unsigned int *)(v14 & 0xFFFFFFFFFFFFFFFCLL);
      goto LABEL_107;
    }
    v21 = (uint64_t)v20 + v51 + 8;
    v24 = v14 & 0xFFFFFFFFFFFFFFFCLL;
  }
LABEL_55:
  v32 = 0;
  if ((v14 & 3) != 0)
    goto LABEL_58;
LABEL_56:
  if (v23 != (unsigned int *)v24)
  {
    v33 = *(_QWORD **)v23;
    v23 = 0;
    while (1)
    {
      while (1)
      {
        v32 += (int)v33;
        if ((v14 & 3) == 0)
          goto LABEL_56;
LABEL_58:
        if ((v31 & 1) != 0)
          break;
        if (v23 == (unsigned int *)v24)
          goto LABEL_69;
        v36 = *(_QWORD **)v23;
        v23 += 2;
        v33 = (_QWORD *)*v36;
      }
      if (v11 == v21)
        goto LABEL_69;
      v27 = v23[1];
      outCount = (unsigned int *)(v27 * (unint64_t)*v23);
      if (((unint64_t)outCount & 0xFFFFFFFF00000000) != 0)
        break;
      v33 = *(_QWORD **)((*(uint64_t *)v11 >> 16) + v11);
      v34 = (unint64_t)v23 + outCount + 8;
      v35 = (uint64_t *)(v11 + v22);
      do
      {
        v11 = (unint64_t)v35;
        if ((unint64_t)v35 >= v34)
          break;
        v2 = *(char **)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v35 + 8);
        v35 = (uint64_t *)((char *)v35 + v22);
      }
      while ((v2 & 1) == 0);
    }
    v26 = *v23;
LABEL_107:
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)outCount, v2, v3, v27, v23, v26);
  }
LABEL_69:
  if (v32)
  {
    v9 = (Protocol **)malloc_type_malloc(8 * (v32 + 1), 0x80040B8603338uLL);
    list_array_tt<unsigned long,protocol_list_t,RawPtr>::begin((uint64_t)v55, &v57, v37, v38);
    list_array_tt<unsigned long,protocol_list_t,RawPtr>::end((uint64_t)v54, &v57, v39, v40);
    v41 = 0;
    while (!list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator==((uint64_t)v55, v54))
    {
      v45 = *v56;
      if (canonical_protocol)
        v46 = 0;
      else
        v46 = 0x20000000;
      if ((v46 & *(_DWORD *)(*v56 + 68)) == 0)
      {
        Protocol = getProtocol(*(const char **)(v45 + 8));
        if (Protocol)
          v45 = Protocol;
      }
      v9[v41] = (Protocol *)v45;
      list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator++(v55, v42, v43, v44);
      ++v41;
    }
    v9[v41] = 0;
    if (v4)
      goto LABEL_80;
  }
  else
  {
    v9 = 0;
    v41 = 0;
    if (v4)
LABEL_80:
      *v4 = v41;
  }
  v48 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v49 = __ldxr(runtimeLock);
    if (v49 != v48)
      break;
    if (!__stlxr(0, runtimeLock))
      return v9;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v9;
}

void sub_18011011C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

BOOL class_conformsToProtocol(Class cls, Protocol *protocol)
{
  char *v2;
  char *v3;
  BOOL v4;
  unint64_t StatusReg;
  unsigned int v8;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  BOOL v17;
  const char *v18;
  char *v19;
  BOOL v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  char *v26;
  int v27;
  unsigned int v28;
  uint64_t v30;
  uint64_t v31;
  _QWORD v32[10];
  uint64_t *v33[8];
  uint64_t *v34;
  unint64_t v35;

  v4 = 0;
  if (!cls || !protocol)
    return v4;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v8 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v8, runtimeLock))
      goto LABEL_8;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_8:
  if ((unint64_t)(*(_QWORD *)cls - 1) < 0xF
    || (*(_DWORD *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (v10 = *(unsigned __int16 *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
        dword_1ECCE5988 <= v10)
    || (*(_QWORD *)(qword_1ECCE5980 + 16 * v10) <= (unint64_t)cls
      ? (v11 = *(_QWORD *)(qword_1ECCE5980 + 16 * v10 + 8) > (unint64_t)cls)
      : (v11 = 0),
        !v11))
  {
    if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)cls)
      && (dataSegmentsContain(cls, v30, (unsigned int *)v2) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v31, v2, v3, cls);
    }
  }
  v12 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
  v13 = v12 & 0xFFFFFFFFFFFFFFFELL;
  if ((v12 & 1) != 0)
  {
    v15 = *(_QWORD *)(v13 + 24);
  }
  else
  {
    v35 = 0;
    v14 = *(_QWORD *)(v13 + 40);
    v15 = v14 & 0xFFFFFFFFFFFFFFFELL;
    if ((v14 & 1) != 0 || !v15)
    {
      v16 = v14 & 1;
      if (v15)
        v17 = v16 == 0;
      else
        v17 = 1;
      if (v17)
        goto LABEL_26;
      v15 |= 2uLL;
    }
  }
  v35 = v15;
LABEL_26:
  list_array_tt<unsigned long,protocol_list_t,RawPtr>::begin((uint64_t)v33, &v35, v2, v3);
  list_array_tt<unsigned long,protocol_list_t,RawPtr>::end((uint64_t)v32, &v35, v18, v19);
  while (1)
  {
    v20 = list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator==((uint64_t)v33, v32);
    if (v20)
      break;
    v21 = *v34;
    v22 = canonical_protocol ? 0 : 0x20000000;
    if ((v22 & *(_DWORD *)(*v34 + 68)) == 0)
    {
      v23 = getProtocol(*(const char **)(v21 + 8));
      if (v23)
        v21 = v23;
    }
    if ((Protocol *)v21 == protocol
      || (protocol_conformsToProtocol_nolock((protocol_t *)v21, (const char **)protocol) & 1) != 0)
    {
      break;
    }
    list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator++(v33, v24, v25, v26);
  }
  v4 = !v20;
  v27 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v28 = __ldxr(runtimeLock);
    if (v28 != v27)
      break;
    if (!__stlxr(0, runtimeLock))
      return v4;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v4;
}

void sub_180110388(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

BOOL list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator==(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_QWORD **)a1;
  if (*(_QWORD *)a1 != *a2)
    return 0;
  v3 = *v2 & 3;
  if (v3 == 2)
  {
    v4 = *(_QWORD *)(a1 + 24);
    v5 = a2[3];
  }
  else
  {
    if (v3 > 1)
      return 0;
    v4 = *(_QWORD *)(a1 + 8);
    v5 = a2[1];
  }
  if (v4 != v5)
    return 0;
  if (v2 == *(_QWORD **)(a1 + 32)
    && (v3 == 2
      ? (v7 = *(_QWORD *)(a1 + 24), v8 = *(_QWORD *)(a1 + 56))
      : (v7 = *(_QWORD *)(a1 + 8), v8 = *(_QWORD *)(a1 + 40)),
        v7 == v8))
  {
    return 1;
  }
  else
  {
    return *(_QWORD *)(a1 + 64) == a2[8];
  }
}

uint64_t **list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator++(uint64_t **a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  const char *v20;
  char *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;

  v5 = a1[9];
  v6 = (uint64_t)(a1[8] + 1);
  a1[8] = (uint64_t *)v6;
  if ((uint64_t *)v6 != v5)
    return a1;
  v7 = *a1;
  v8 = **a1;
  if ((v8 & 3) == 1)
  {
    ++a1[1];
    v8 = *v7;
  }
  else if ((v8 & 3) == 0)
  {
    a1[1] = 0;
  }
  if ((v8 & 3) == 2)
  {
    v9 = a1[3];
    v10 = *((unsigned int *)a1 + 4);
    v11 = *((_DWORD *)a1 + 5);
    a1[3] = (uint64_t *)((char *)v9 + v10);
    v12 = (unsigned int *)a1[1];
    v14 = *v12;
    v13 = v12[1];
    v15 = v13 * (unint64_t)v14;
    *((_DWORD *)a1 + 5) = v11 + 1;
    if ((v15 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v13, v12, v14);
    v16 = (unint64_t)v12 + v15 + 8;
    if ((unint64_t)v9 + v10 < v16)
    {
      v17 = objc_debug_headerInfoRWs;
      v18 = v11 + 2;
      do
      {
        if ((*(_QWORD *)(v17 + 8 * *(unsigned __int16 *)((char *)v9 + v10) + 8) & 1) != 0)
          break;
        a1[3] = (uint64_t *)((char *)v9 + 2 * v10);
        *((_DWORD *)a1 + 5) = v18++;
        v9 = (uint64_t *)((char *)v9 + v10);
      }
      while ((unint64_t)v9 + v10 < v16);
    }
  }
  list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::skipEmptyLists(a1);
  v22 = **a1 & 3;
  if (*a1 != a1[4])
  {
    if (v22 != 1)
    {
      if (!v22)
      {
        v23 = a1[1];
LABEL_20:
        v24 = *v23;
        v25 = (uint64_t)&v23[*v23 + 1];
        a1[8] = v23 + 1;
        a1[9] = (uint64_t *)v25;
        if (!v24)
          goto LABEL_36;
        return a1;
      }
      goto LABEL_28;
    }
    v26 = a1[1];
LABEL_26:
    v27 = (_QWORD *)*v26;
    v28 = *v26 + 8;
    a1[8] = (uint64_t *)v28;
    v22 = 1;
    goto LABEL_29;
  }
  if (v22 != 2)
  {
    if (v22 != 1)
    {
      if (!v22)
      {
        v23 = a1[1];
        if (v23 == a1[5])
          return a1;
        goto LABEL_20;
      }
      v22 = 3;
      goto LABEL_28;
    }
    v26 = a1[1];
    if (v26 == a1[5])
      return a1;
    goto LABEL_26;
  }
  if (a1[3] == a1[7])
    return a1;
  v22 = 2;
LABEL_28:
  v29 = a1[3];
  v28 = (uint64_t)v29 + (*v29 >> 16) + 8;
  a1[8] = (uint64_t *)v28;
  v27 = (uint64_t *)((char *)v29 + (*v29 >> 16));
LABEL_29:
  v30 = (uint64_t)&v27[*v27 + 1];
  a1[9] = (uint64_t *)v30;
  if (v28 == v30)
  {
    if (v22 == 2)
    {
      v23 = (uint64_t *)((char *)a1[3] + (*a1[3] >> 16));
    }
    else if (v22 == 1)
    {
      v23 = (uint64_t *)*a1[1];
    }
    else
    {
      v23 = 0;
    }
LABEL_36:
    _objc_fatal("Assertion failed: (%s) - empty list %p encountered during iteration", v19, v20, v21, "m != mEnd", v23);
  }
  return a1;
}

uint64_t **list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::skipEmptyLists(uint64_t **result)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  int v17;

  v1 = *result;
  v2 = result[4];
  v3 = objc_debug_headerInfoRWs;
  v4 = **result;
  while (1)
  {
    v5 = v4 & 3;
    if (v1 != v2)
    {
      if (v5 == 1)
      {
        v7 = result[1];
        goto LABEL_17;
      }
      if ((v4 & 3) == 0)
      {
        v6 = result[1];
LABEL_10:
        if (*v6)
          return result;
        result[1] = 0;
        goto LABEL_19;
      }
      goto LABEL_14;
    }
    if (v5 == 2)
    {
      if (result[3] == result[7])
        return result;
      goto LABEL_14;
    }
    if (v5 == 1)
      break;
    if ((v4 & 3) == 0)
    {
      v6 = result[1];
      if (v6 == result[5])
        return result;
      goto LABEL_10;
    }
LABEL_14:
    if (*(uint64_t *)((char *)result[3] + (*result[3] >> 16)))
      return result;
LABEL_19:
    if ((v4 & 3) == 2)
    {
      v8 = result[3];
      v9 = *((unsigned int *)result + 4);
      v10 = *((_DWORD *)result + 5);
      result[3] = (uint64_t *)((char *)v8 + v9);
      v11 = (unsigned int *)result[1];
      v12 = *v11;
      v13 = v11[1];
      v14 = v13 * (unint64_t)v12;
      v15 = (char *)(v10 + 1);
      *((_DWORD *)result + 5) = (_DWORD)v15;
      if ((v14 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v12, (const char *)v14, v15, v13, v11, v12);
      v16 = (unint64_t)v11 + v14 + 8;
      if ((unint64_t)v8 + v9 < v16)
      {
        v17 = v10 + 2;
        do
        {
          if ((*(_QWORD *)(v3 + 8 * *(unsigned __int16 *)((char *)v8 + v9) + 8) & 1) != 0)
            break;
          result[3] = (uint64_t *)((char *)v8 + 2 * v9);
          *((_DWORD *)result + 5) = v17++;
          v8 = (uint64_t *)((char *)v8 + v9);
        }
        while ((unint64_t)v8 + v9 < v16);
      }
    }
  }
  v7 = result[1];
  if (v7 == result[5])
    return result;
LABEL_17:
  if (!*(_QWORD *)*v7)
  {
    result[1] = v7 + 1;
    v4 = *v1;
    goto LABEL_19;
  }
  return result;
}

uint64_t list_array_tt<unsigned long,protocol_list_t,RawPtr>::end(uint64_t a1, _QWORD *a2, const char *a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;

  v5 = *a2 & 3;
  v6 = (unsigned int *)(*a2 & 0xFFFFFFFFFFFFFFFCLL);
  if (v5 == 1 && v6 != 0)
  {
    v6 += 2 * *v6 + 2;
    v17 = a2;
LABEL_15:
    v18 = v6;
    v13 = a2;
    v14 = v6;
    return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, (uint64_t)&v13);
  }
  if (v5 == 2 && v6 != 0)
  {
    v10 = *v6;
    v9 = v6[1];
    v11 = v9 * (unint64_t)v10;
    if ((v11 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v9, *a2 & 0xFFFFFFFFFFFFFFFCLL, v10);
    v5 = (uint64_t)v6 + v11 + 8;
    v4 = v10 | (v9 << 32);
    v17 = a2;
    goto LABEL_18;
  }
  v6 = 0;
  v17 = a2;
  if (v5 == 2)
  {
LABEL_18:
    v18 = v6;
    v19 = v4;
    v20 = v5;
    v13 = a2;
    v14 = v6;
    v15 = v4;
    v16 = v5;
    return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, (uint64_t)&v13);
  }
  if (v5 == 1)
    goto LABEL_15;
  if (v5)
  {
    v13 = a2;
  }
  else
  {
    v18 = 0;
    v13 = a2;
    v14 = 0;
  }
  return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, (uint64_t)&v13);
}

uint64_t list_array_tt<unsigned long,protocol_list_t,RawPtr>::begin(uint64_t a1, _QWORD *a2, const char *a3, char *a4)
{
  uint64_t v4;
  unsigned int *v5;
  BOOL v6;
  unsigned __int16 *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t i;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  BOOL v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  unint64_t v32;
  unsigned __int16 *v33;

  v30 = a2;
  v4 = *a2 & 3;
  v5 = (unsigned int *)(*a2 & 0xFFFFFFFFFFFFFFFCLL);
  if (v4)
    v6 = 1;
  else
    v6 = v5 == 0;
  if (!v6)
  {
    v31 = *a2 & 0xFFFFFFFFFFFFFFFCLL;
    v26 = a2;
LABEL_9:
    v27 = 0;
    return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v30, (uint64_t)&v26);
  }
  if (*a2 > 3uLL)
  {
    if (v4 == 1 && v5 != 0)
    {
      v31 = (unint64_t)(v5 + 2);
      v26 = a2;
      goto LABEL_26;
    }
    if (v4 == 2 && v5 != 0)
    {
      if (DisablePreattachedCategories)
      {
        v12 = *v5;
        v20 = v5[1];
        v21 = v20 * (unint64_t)v12;
        if ((v21 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v20, *a2 & 0xFFFFFFFFFFFFFFFCLL, v12);
        v22 = v12 | (v20 << 32);
        v23 = (uint64_t)v5 + v21 + 8;
        v24 = v12 | ((unint64_t)(v20 - 1) << 32);
        v25 = (_DWORD)v20 == 0;
        if ((_DWORD)v20)
          v10 = v20;
        else
          v10 = 0;
        if ((_DWORD)v20)
          v9 = (unsigned __int16 *)(v23 - v12);
        else
          v9 = (unsigned __int16 *)v23;
        if (v25)
          v11 = v22;
        else
          v11 = v24;
      }
      else
      {
        v9 = (unsigned __int16 *)(v5 + 2);
        v11 = *v5;
        v10 = v5[1];
        v12 = v11;
      }
      v13 = v10 * (unint64_t)v12;
      if ((v13 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v10, *a2 & 0xFFFFFFFFFFFFFFFCLL, v12);
      v14 = HIDWORD(v11);
      for (i = (unint64_t)v5 + v13 + 8; (unint64_t)v9 < i; v14 = (v14 + 1))
      {
        if ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v9 + 8) & 1) != 0)
          break;
        v9 = (unsigned __int16 *)((char *)v9 + v11);
      }
      v31 = *a2 & 0xFFFFFFFFFFFFFFFCLL;
      v32 = v11 | (v14 << 32);
      v33 = v9;
    }
  }
  else
  {
    v31 = 0;
  }
  v26 = a2;
  if (!v4)
    goto LABEL_9;
LABEL_26:
  if (v4 == 1 && v5)
  {
    v27 = (uint64_t)&v5[2 * *v5 + 2];
  }
  else if (v4 == 2 && v5)
  {
    v17 = *v5;
    v16 = v5[1];
    v18 = v16 * (unint64_t)v17;
    if ((v18 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v16, v5, v17);
    v27 = (uint64_t)v5;
    v28 = v17 | (v16 << 32);
    v29 = (uint64_t)v5 + v18 + 8;
  }
  return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v30, (uint64_t)&v26);
}

uint64_t list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  unint64_t v5;
  __int128 v6;
  _QWORD *v7;
  unint64_t v8;
  __int128 v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t *v13;

  v4 = *(_QWORD **)a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  v5 = *v4 & 3;
  if (v5 == 2)
  {
    v6 = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v6;
  }
  else if (v5 <= 1)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  }
  v7 = *(_QWORD **)a3;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)a3;
  v8 = *v7 & 3;
  if (v8 == 2)
  {
    v9 = *(_OWORD *)(a3 + 8);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a3 + 24);
    *(_OWORD *)(a1 + 40) = v9;
  }
  else if (v8 <= 1)
  {
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a3 + 8);
  }
  v10 = **(_QWORD **)a2 & 3;
  if (*(_QWORD *)a2 != *(_QWORD *)a3)
  {
    if (v10 != 2)
    {
      if (v10 == 1)
      {
        v11 = *(_QWORD **)(a2 + 8);
LABEL_16:
        *(_QWORD *)(a1 + 64) = *v11 + 8;
        v12 = **(_QWORD ***)(a2 + 8);
LABEL_23:
        *(_QWORD *)(a1 + 72) = &v12[*v12 + 1];
        goto LABEL_24;
      }
      v12 = *(_QWORD **)(a2 + 8);
LABEL_22:
      *(_QWORD *)(a1 + 64) = v12 + 1;
      goto LABEL_23;
    }
    v13 = *(uint64_t **)(a2 + 24);
LABEL_20:
    *(_QWORD *)(a1 + 64) = (char *)v13 + (*v13 >> 16) + 8;
    v12 = (uint64_t *)((char *)v13 + (*v13 >> 16));
    goto LABEL_23;
  }
  if (v10 == 2)
  {
    v13 = *(uint64_t **)(a2 + 24);
    if (v13 != *(uint64_t **)(a3 + 24))
      goto LABEL_20;
  }
  else if (v10 == 1)
  {
    v11 = *(_QWORD **)(a2 + 8);
    if (v11 != *(_QWORD **)(a3 + 8))
      goto LABEL_16;
  }
  else
  {
    v12 = *(_QWORD **)(a2 + 8);
    if (v12 != *(_QWORD **)(a3 + 8))
      goto LABEL_22;
  }
LABEL_24:
  list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::skipEmptyLists((uint64_t **)a1);
  return a1;
}

uint64_t addClassTableEntry(uint64_t result, char a2)
{
  objc_class *i;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  unsigned int *v7;
  objc_class *v8;
  _BYTE v9[24];

  for (i = (objc_class *)result; ; i = (objc_class *)(*(_QWORD *)i & 0xFFFFFFFF8))
  {
    v8 = i;
    if ((unint64_t)(*(_QWORD *)i - 1) < 0xF
      || (*(_DWORD *)(*((_QWORD *)i + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
      || (v4 = *(unsigned __int16 *)((*((_QWORD *)i + 4) & 0xF00007FFFFFFFF8) + 4), dword_1ECCE5988 <= v4)
      || (*(_QWORD *)(qword_1ECCE5980 + 16 * v4) <= (unint64_t)i
        ? (v5 = *(_QWORD *)(qword_1ECCE5980 + 16 * v4 + 8) > (unint64_t)i)
        : (v5 = 0),
          !v5))
    {
      result = objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)i);
      if (objc::allocatedClasses + 8 * qword_1ECCE5760 == result)
      {
        result = dataSegmentsContain(i, v6, v7);
        if ((result & 1) == 0)
          result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::try_emplace<objc::detail::DenseSetEmpty&>((uint64_t)v9, (int32x2_t *)&objc::allocatedClasses, (unint64_t *)&v8);
      }
    }
    if ((a2 & 1) == 0)
      break;
    a2 = 0;
  }
  return result;
}

uint64_t objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find(unint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned int v4;
  int v5;

  if (!(_DWORD)qword_1ECCE5760)
    return objc::allocatedClasses + 8 * qword_1ECCE5760;
  LODWORD(v1) = (qword_1ECCE5760 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093
                                                                                           * (a1 ^ (a1 >> 4))));
  v2 = (uint64_t *)(objc::allocatedClasses + 8 * v1);
  v3 = *v2;
  if (*v2 != a1)
  {
    v4 = 1;
    while (v3 != -1)
    {
      if (v4 > qword_1ECCE5760)
        objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables((uint64_t)&objc::allocatedClasses, (_QWORD *)objc::allocatedClasses, qword_1ECCE5760);
      v5 = v1 + v4++;
      v1 = v5 & (qword_1ECCE5760 - 1);
      v3 = *(_QWORD *)(objc::allocatedClasses + 8 * v1);
      if (v3 == a1)
        return objc::allocatedClasses + 8 * v1;
    }
    return objc::allocatedClasses + 8 * qword_1ECCE5760;
  }
  return (uint64_t)v2;
}

uint64_t dataSegmentsContain(objc_class *a1, uint64_t a2, unsigned int *a3)
{
  uint64_t result;
  int v5;

  v5 = 0;
  result = objc::SafeRanges::find(a1, &v5, a3);
  if ((_DWORD)result
    && (unint64_t)(*(_QWORD *)a1 - 1) >= 0xF
    && (*(_DWORD *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
  {
    *(_WORD *)((*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) + 4) = v5;
  }
  return result;
}

uint64_t objc::SafeRanges::find(objc::SafeRanges *this, _DWORD *a2, unsigned int *a3)
{
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t result;

  if ((dword_1ECCE598C & 0x80000000) == 0)
  {
    v5 = 126 - 2 * __clz(dword_1ECCE5988);
    if (dword_1ECCE5988)
      v6 = v5;
    else
      v6 = 0;
    std::__introsort<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *,false>(qword_1ECCE5980, (unint64_t *)(qword_1ECCE5980 + 16 * dword_1ECCE5988), v6, 1);
    dword_1ECCE598C |= 0x80000000;
  }
  v7 = dword_1ECCE5988;
  if (dword_1ECCE5988)
  {
    v8 = 0;
    do
    {
      v9 = (v7 + v8) >> 1;
      if (*(_QWORD *)(qword_1ECCE5980 + 16 * v9) <= (unint64_t)this)
      {
        if (*(_QWORD *)(qword_1ECCE5980 + 16 * v9 + 8) > (unint64_t)this)
        {
          result = 1;
          goto LABEL_15;
        }
        v8 = v9 + 1;
      }
      else
      {
        v7 = (v7 + v8) >> 1;
      }
    }
    while (v8 < v7);
  }
  result = 0;
  LODWORD(v9) = -1;
LABEL_15:
  *a2 = v9;
  return result;
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::try_emplace<objc::detail::DenseSetEmpty&>(uint64_t a1, int32x2_t *a2, unint64_t *a3)
{
  uint64_t result;
  unint64_t *v7;
  char v8;
  __int32 v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t *v12;

  v12 = 0;
  result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::LookupBucketFor<objc_class *>((uint64_t)a2, *a3, &v12);
  v7 = v12;
  if ((result & 1) != 0)
  {
    v8 = 0;
    goto LABEL_10;
  }
  v9 = a2[1].i32[0];
  v10 = a2[2].u32[0];
  if (4 * v9 + 4 >= 3 * v10)
  {
    v10 *= 2;
    goto LABEL_12;
  }
  if (v10 + ~v9 - a2[1].i32[1] <= v10 >> 3)
  {
LABEL_12:
    objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::grow((uint64_t)a2, v10);
    v12 = 0;
    result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::LookupBucketFor<objc_class *>((uint64_t)a2, *a3, &v12);
    v7 = v12;
  }
  if (*v7 == -2)
  {
    a2[1] = vadd_s32(a2[1], (int32x2_t)0xFFFFFFFF00000001);
  }
  else if (*v7 == -1)
  {
    ++a2[1].i32[0];
  }
  *v7 = *a3;
  v8 = 1;
LABEL_10:
  v11 = *(_QWORD *)a2 + 8 * a2[2].u32[0];
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v8;
  return result;
}

void objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  unint64_t *v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(unint64_t **)a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4)
    v8 = v7 + 1;
  else
    v8 = 4;
  *(_DWORD *)(a1 + 16) = v8;
  v9 = malloc_type_malloc(8 * v8, 0x64B88C75uLL);
  *(_QWORD *)a1 = v9;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
      memset(v9, 255, 8 * v10);
    if ((_DWORD)v3)
    {
      v11 = 8 * v3;
      v12 = v4;
      do
      {
        v13 = *v12;
        if (*v12 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v15 = 0;
          objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::LookupBucketFor<objc_class *>(a1, v13, &v15);
          *v15 = *v12;
          ++*(_DWORD *)(a1 + 8);
        }
        ++v12;
        v11 -= 8;
      }
      while (v11);
    }
    free(v4);
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    v14 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v14)
      memset(v9, 255, 8 * v14);
  }
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::LookupBucketFor<objc_class *>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  unsigned int v11;
  BOOL v12;
  unsigned int v13;

  v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    v4 = v3 - 1;
    v5 = (v3 - 1) & (bswap64(0x8A970BE7488FDA55 * (a2 ^ (a2 >> 4))) ^ (1217387093 * (a2 ^ (a2 >> 4))));
    v6 = (_QWORD *)(*(_QWORD *)a1 + 8 * v5);
    v7 = *v6;
    if (*v6 == a2)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -1)
      {
        if (v11 > v3)
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, *(_QWORD **)a1, *(unsigned int *)(a1 + 16));
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -2;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(*(_QWORD *)a1 + 8 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a2)
          goto LABEL_5;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_5:
  *a3 = v6;
  return v8;
}

void std::__introsort<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *,false>(uint64_t a1, unint64_t *a2, uint64_t a3, char a4)
{
  __int128 *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  __int128 *v22;
  __int128 v23;
  unint64_t v24;
  unint64_t v25;
  BOOL v26;
  unint64_t v27;
  unint64_t v28;
  _OWORD *v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  __int128 *v34;
  __int128 *v35;
  __int128 *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  unint64_t *v40;
  BOOL v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _QWORD *v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  uint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  BOOL v57;
  unint64_t *v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t *v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _OWORD *v67;
  unint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t *v76;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;

LABEL_1:
  v8 = (__int128 *)(a2 - 2);
  v9 = a1;
  while (2)
  {
    a1 = v9;
    v10 = (uint64_t)a2 - v9;
    v11 = (uint64_t)((uint64_t)a2 - v9) >> 4;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (*(_QWORD *)v8 < *(_QWORD *)v9)
        {
          v85 = *(_OWORD *)v9;
          *(_OWORD *)v9 = *v8;
          *v8 = v85;
        }
        return;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)v9, (unint64_t *)(v9 + 16), a2 - 2);
        return;
      case 4uLL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)v9, (unint64_t *)(v9 + 16), (unint64_t *)(v9 + 32), (_OWORD *)a2 - 1);
        return;
      case 5uLL:
        v34 = (__int128 *)(v9 + 16);
        v35 = (__int128 *)(v9 + 32);
        v36 = (__int128 *)(v9 + 48);
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)v9, (unint64_t *)(v9 + 16), (unint64_t *)(v9 + 32), (_OWORD *)(v9 + 48));
        if (*(_QWORD *)v8 < *(_QWORD *)(v9 + 48))
        {
          v37 = *v36;
          *v36 = *v8;
          *v8 = v37;
          if (*(_QWORD *)v36 < *(_QWORD *)v35)
          {
            v38 = *v35;
            *v35 = *v36;
            *v36 = v38;
            if (*(_QWORD *)v35 < *(_QWORD *)v34)
            {
              v39 = *v34;
              *v34 = *v35;
              *v35 = v39;
              if (*(_QWORD *)(v9 + 16) < *(_QWORD *)v9)
              {
                v86 = *(_OWORD *)v9;
                *(_OWORD *)v9 = *v34;
                *v34 = v86;
              }
            }
          }
        }
        return;
      default:
        if (v10 <= 383)
        {
          v40 = (unint64_t *)(v9 + 16);
          v42 = (unint64_t *)v9 == a2 || v40 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v42)
            {
              v43 = 0;
              v44 = (unint64_t *)v9;
              do
              {
                v45 = v40;
                v46 = v44[2];
                if (v46 < *v44)
                {
                  v47 = v44[3];
                  v48 = v43;
                  while (1)
                  {
                    *(_OWORD *)(v9 + v48 + 16) = *(_OWORD *)(v9 + v48);
                    if (!v48)
                      break;
                    v49 = *(_QWORD *)(v9 + v48 - 16);
                    v48 -= 16;
                    if (v46 >= v49)
                    {
                      v50 = (_QWORD *)(v9 + v48 + 16);
                      goto LABEL_76;
                    }
                  }
                  v50 = (_QWORD *)v9;
LABEL_76:
                  *v50 = v46;
                  v50[1] = v47;
                }
                v40 = v45 + 2;
                v43 += 16;
                v44 = v45;
              }
              while (v45 + 2 != a2);
            }
          }
          else if (!v42)
          {
            do
            {
              v78 = (uint64_t)v40;
              v79 = *(_QWORD *)(a1 + 16);
              if (v79 < *(_QWORD *)a1)
              {
                v80 = *(_QWORD *)(a1 + 24);
                v81 = v78;
                do
                {
                  *(_OWORD *)v81 = *(_OWORD *)(v81 - 16);
                  v82 = *(_QWORD *)(v81 - 32);
                  v81 -= 16;
                }
                while (v79 < v82);
                *(_QWORD *)v81 = v79;
                *(_QWORD *)(v81 + 8) = v80;
              }
              v40 = (unint64_t *)(v78 + 16);
              a1 = v78;
            }
            while ((unint64_t *)(v78 + 16) != a2);
          }
          return;
        }
        if (!a3)
        {
          if ((unint64_t *)v9 != a2)
          {
            v51 = (v11 - 2) >> 1;
            v52 = v51;
            do
            {
              v53 = v52;
              if (v51 >= v52)
              {
                v54 = (2 * v52) | 1;
                v55 = (unint64_t *)(v9 + 16 * v54);
                if (2 * v53 + 2 >= (uint64_t)v11)
                {
                  v56 = *v55;
                }
                else
                {
                  v56 = v55[2];
                  v57 = *v55 >= v56;
                  if (*v55 > v56)
                    v56 = *v55;
                  if (!v57)
                  {
                    v55 += 2;
                    v54 = 2 * v53 + 2;
                  }
                }
                v58 = (unint64_t *)(v9 + 16 * v53);
                v59 = *v58;
                if (v56 >= *v58)
                {
                  v60 = v58[1];
                  do
                  {
                    v61 = v58;
                    v58 = v55;
                    *(_OWORD *)v61 = *(_OWORD *)v55;
                    if (v51 < v54)
                      break;
                    v62 = (2 * v54) | 1;
                    v55 = (unint64_t *)(v9 + 16 * v62);
                    v54 = 2 * v54 + 2;
                    if (v54 >= (uint64_t)v11)
                    {
                      v63 = *v55;
                      v54 = v62;
                    }
                    else
                    {
                      v63 = *v55;
                      v64 = v55[2];
                      if (*v55 <= v64)
                        v63 = v55[2];
                      if (*v55 >= v64)
                        v54 = v62;
                      else
                        v55 += 2;
                    }
                  }
                  while (v63 >= v59);
                  *v58 = v59;
                  v58[1] = v60;
                }
              }
              v52 = v53 - 1;
            }
            while (v53);
            v65 = (unint64_t)v10 >> 4;
            do
            {
              v66 = 0;
              v87 = *(_OWORD *)v9;
              v67 = (_OWORD *)v9;
              do
              {
                v68 = (unint64_t *)&v67[v66 + 1];
                v69 = (2 * v66) | 1;
                v70 = 2 * v66 + 2;
                if (v70 < v65 && *v68 < v68[2])
                {
                  v68 += 2;
                  v69 = v70;
                }
                *v67 = *(_OWORD *)v68;
                v67 = v68;
                v66 = v69;
              }
              while (v69 <= (uint64_t)((unint64_t)(v65 - 2) >> 1));
              a2 -= 2;
              if (v68 == a2)
              {
                *(_OWORD *)v68 = v87;
              }
              else
              {
                *(_OWORD *)v68 = *(_OWORD *)a2;
                *(_OWORD *)a2 = v87;
                v71 = (uint64_t)v68 - v9 + 16;
                if (v71 >= 17)
                {
                  v72 = (((unint64_t)v71 >> 4) - 2) >> 1;
                  v73 = (unint64_t *)(v9 + 16 * v72);
                  v74 = *v68;
                  if (*v73 < *v68)
                  {
                    v75 = v68[1];
                    do
                    {
                      v76 = v68;
                      v68 = v73;
                      *(_OWORD *)v76 = *(_OWORD *)v73;
                      if (!v72)
                        break;
                      v72 = (v72 - 1) >> 1;
                      v73 = (unint64_t *)(v9 + 16 * v72);
                    }
                    while (*v73 < v74);
                    *v68 = v74;
                    v68[1] = v75;
                  }
                }
              }
            }
            while (v65-- > 2);
          }
          return;
        }
        v12 = v11 >> 1;
        v13 = (unint64_t *)(v9 + 16 * (v11 >> 1));
        if ((unint64_t)v10 < 0x801)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)(a1 + 16 * (v11 >> 1)), (unint64_t *)a1, a2 - 2);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)a1, (unint64_t *)(a1 + 16 * (v11 >> 1)), a2 - 2);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)(a1 + 16), v13 - 2, a2 - 4);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)(a1 + 32), (unint64_t *)(a1 + 16 + 16 * v12), a2 - 6);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)v13 - 1, v13, (unint64_t *)(a1 + 16 + 16 * v12));
          v83 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)v13;
          *(_OWORD *)v13 = v83;
        }
        --a3;
        v14 = *(_QWORD *)a1;
        if ((a4 & 1) == 0 && *(_QWORD *)(a1 - 16) >= v14)
        {
          if (v14 >= *(_QWORD *)v8)
          {
            v28 = a1 + 16;
            do
            {
              v9 = v28;
              if (v28 >= (unint64_t)a2)
                break;
              v28 += 16;
            }
            while (v14 >= *(_QWORD *)v9);
          }
          else
          {
            v9 = a1;
            do
            {
              v27 = *(_QWORD *)(v9 + 16);
              v9 += 16;
            }
            while (v14 >= v27);
          }
          v29 = a2;
          if (v9 < (unint64_t)a2)
          {
            v29 = a2;
            do
              v30 = *((_QWORD *)v29-- - 2);
            while (v14 < v30);
          }
          v31 = *(_QWORD *)(a1 + 8);
          while (v9 < (unint64_t)v29)
          {
            v84 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *v29;
            *v29 = v84;
            do
            {
              v32 = *(_QWORD *)(v9 + 16);
              v9 += 16;
            }
            while (v14 >= v32);
            do
              v33 = *((_QWORD *)v29-- - 2);
            while (v14 < v33);
          }
          if (v9 - 16 != a1)
            *(_OWORD *)a1 = *(_OWORD *)(v9 - 16);
          a4 = 0;
          *(_QWORD *)(v9 - 16) = v14;
          *(_QWORD *)(v9 - 8) = v31;
          continue;
        }
        v15 = *(_QWORD *)(a1 + 8);
        v16 = a1;
        do
        {
          v17 = v16;
          v18 = *(_QWORD *)(v16 + 16);
          v16 += 16;
        }
        while (v18 < v14);
        v19 = a2;
        if (v17 == a1)
        {
          v19 = a2;
          do
          {
            if (v16 >= (unint64_t)v19)
              break;
            v21 = *(v19 - 2);
            v19 -= 2;
          }
          while (v21 >= v14);
        }
        else
        {
          do
          {
            v20 = *(v19 - 2);
            v19 -= 2;
          }
          while (v20 >= v14);
        }
        v9 = v16;
        if (v16 < (unint64_t)v19)
        {
          v22 = (__int128 *)v19;
          do
          {
            v23 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *v22;
            *v22 = v23;
            do
            {
              v24 = *(_QWORD *)(v9 + 16);
              v9 += 16;
            }
            while (v24 < v14);
            do
              v25 = *((_QWORD *)v22-- - 2);
            while (v25 >= v14);
          }
          while (v9 < (unint64_t)v22);
        }
        if (v9 - 16 != a1)
          *(_OWORD *)a1 = *(_OWORD *)(v9 - 16);
        *(_QWORD *)(v9 - 16) = v14;
        *(_QWORD *)(v9 - 8) = v15;
        if (v16 < (unint64_t)v19)
        {
LABEL_29:
          std::__introsort<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *,false>(a1, v9 - 16, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v26 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(a1, (unint64_t *)(v9 - 16));
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(v9, a2))
        {
          if (v26)
            continue;
          goto LABEL_29;
        }
        a2 = (unint64_t *)(v9 - 16);
        if (!v26)
          goto LABEL_1;
        return;
    }
  }
}

void objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(uint64_t a1, _QWORD *ptr, uint64_t a3)
{
  size_t v6;
  uint64_t v7;
  const char *v8;
  char *v9;

  v6 = malloc_size(ptr);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v7, v8, v9, a1, ptr, v6, a3, *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *ptr, ptr[1], ptr[2], ptr[3]);
}

uint64_t empty_getClass(const char *a1, objc_class **a2)
{
  *a2 = 0;
  return 0;
}

const char *__cdecl protocol_getName(Protocol *p)
{
  if (p)
    return (const char *)protocol_t::demangledName((char **)p);
  else
    return "nil";
}

size_t class_getInstanceSize(size_t cls)
{
  uint64_t v1;
  unint64_t v2;

  if (cls)
  {
    v1 = *(_QWORD *)((*(_QWORD *)(cls + 32) & 0xF00007FFFFFFFF8) + 8);
    v2 = v1 & 0xFFFFFFFFFFFFFFFELL;
    if ((v1 & 1) != 0)
      v2 = *(_QWORD *)v2;
    return (*(_DWORD *)(v2 + 8) + 7) & 0xFFFFFFF8;
  }
  return cls;
}

void class_replaceMethodsBulk(objc_class *a1, objc_selector **a2, void (**a3)(void), const char **a4, method_list_t *a5)
{
  unint64_t StatusReg;
  unsigned int v11;
  int v13;
  unsigned int v14;

  if (a1)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v11 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v11, runtimeLock))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_7:
    addMethods(a1, a2, a3, a4, a5, 1u, 0);
    v13 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v14 = __ldxr(runtimeLock);
      if (v14 != v13)
        break;
      if (!__stlxr(0, runtimeLock))
        return;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_180111AB0(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void *class_addMethodsBulk(objc_class *a1, objc_selector **a2, void (**a3)(void), const char **a4, method_list_t *a5, unsigned int *a6)
{
  unint64_t StatusReg;
  unsigned int v13;
  size_t v15;
  void *v16;
  int v17;
  unsigned int v18;

  if (a1)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v13 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v13, runtimeLock))
        goto LABEL_10;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_10:
    v16 = addMethods(a1, a2, a3, a4, a5, 0, a6);
    v17 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v18 = __ldxr(runtimeLock);
      if (v18 != v17)
        break;
      if (!__stlxr(0, runtimeLock))
        return v16;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  else
  {
    if (a6)
      *a6 = a5;
    v15 = 8 * a5;
    v16 = malloc_type_malloc(v15, 0x3F84A03uLL);
    memcpy(v16, a2, v15);
  }
  return v16;
}

void sub_180111BF4(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

char *__cdecl method_copyReturnType(char *m)
{
  uint64_t v1;
  uint64_t v2;
  const char *v3;
  char *v4;
  char *v5;
  size_t v6;
  char *v7;

  if (m)
  {
    m = (char *)method_t::types((unint64_t)m, v1);
    if (m)
    {
      v5 = m;
      v6 = SkipFirstType(m, v2, v3, v4) - m;
      v7 = (char *)malloc_type_malloc(v6 + 1, 0x8B5561D0uLL);
      m = strncpy(v7, v5, v6);
      m[v6] = 0;
    }
  }
  return m;
}

char *__cdecl method_copyArgumentType(char *m, unsigned int index)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  char *v6;
  char *v7;
  size_t v8;
  char *v9;
  char v10[4];
  char *v11;

  if (m)
  {
    v3 = *(_QWORD *)&index;
    m = (char *)method_t::types((unint64_t)m, v2);
    v11 = m;
    if (m)
    {
      encoding_getArgumentInfo(m, v3, (char *)&v11, v10);
      v7 = v11;
      if (v11)
      {
        v8 = SkipFirstType(v11, v4, v5, v6) - v7;
        v9 = (char *)malloc_type_malloc(v8 + 1, 0x619B5C91uLL);
        m = strncpy(v9, v7, v8);
        m[v8] = 0;
      }
      else
      {
        return 0;
      }
    }
  }
  return m;
}

void fixupProtocolMethodList(uint64_t a1, unsigned int *a2, int a3, char *a4)
{
  uint64_t *v6;
  int v7;
  uint64_t v9;
  unint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  const char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  _DWORD v31[9];

  if (a2 && (~*a2 & 3) != 0)
  {
    v6 = (uint64_t *)(a1 + 72);
    if ((unint64_t)*(unsigned int *)(a1 + 64) + a1 <= a1 + 72)
    {
      fixupMethodList((method_list_t *)a2, 1, (const char *)1, a4);
    }
    else
    {
      v7 = (int)a4;
      v9 = *v6;
      fixupMethodList((method_list_t *)a2, 1, (const char *)(*v6 == 0), a4);
      if (v9)
      {
        if ((*a2 & 0x80000000) == 0)
        {
          v10 = a2[1];
          v31[0] = 0;
          v11 = a2 + 2;
          getExtendedTypesIndexesForMethod((_QWORD *)a1, (unint64_t)(a2 + 2) & 0xFFFFFFFFFFFFFFFCLL, a3, v7, v31, &v30);
          if ((_DWORD)v10)
          {
            v15 = 0;
            v16 = 1;
            v17 = v31[0];
            do
            {
              v18 = v15 + 1;
              if (v15 + 1 < v10)
              {
                v19 = (v17 + v15);
                v20 = v16;
                do
                {
                  v21 = (unsigned __int16)*a2 & 0xFFFC;
                  v22 = v15 * v21;
                  if ((v22 & 0xFFFFFFFF00000000) != 0)
                    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v12, v13, v14, v15, a2, v21);
                  v23 = v20 * (unint64_t)v21;
                  if ((v23 & 0xFFFFFFFF00000000) != 0)
                    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v12, v13, v14, v20, a2, v21);
                  v24 = ((unint64_t)v11 + v22) & 0xFFFFFFFFFFFFFFFCLL;
                  v25 = ((unint64_t)v11 + v23) & 0xFFFFFFFFFFFFFFFCLL;
                  if (*(_QWORD *)v24 > *(_QWORD *)v25)
                  {
                    v26 = *(_QWORD *)(v24 + 16);
                    v27 = *(_OWORD *)v24;
                    v28 = *(_QWORD *)(v25 + 16);
                    *(_OWORD *)v24 = *(_OWORD *)v25;
                    *(_QWORD *)(v24 + 16) = v28;
                    *(_OWORD *)v25 = v27;
                    *(_QWORD *)(v25 + 16) = v26;
                    v29 = *(_QWORD *)(v9 + 8 * v19);
                    *(_QWORD *)(v9 + 8 * v19) = *(_QWORD *)(v9 + 8 * (v17 + v20));
                    *(_QWORD *)(v9 + 8 * (v17 + v20)) = v29;
                  }
                  v20 = (v20 + 1);
                }
                while ((_DWORD)v10 != (_DWORD)v20);
              }
              v16 = (v16 + 1);
              ++v15;
            }
            while (v18 != v10);
          }
        }
      }
    }
  }
}

uint64_t _protocol_getMethodTypeEncoding(protocol_t *a1, objc_selector *a2, const char *a3, char *a4)
{
  unint64_t StatusReg;
  unsigned int v9;
  uint64_t MethodTypeEncoding_nolock;
  int v12;
  int v13;
  unsigned int v14;

  if (!a1)
    return 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v9 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v9, runtimeLock))
      goto LABEL_8;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_8:
  if (fixed_up_protocol)
    v12 = -1073741824;
  else
    v12 = 0x40000000;
  if ((*((_DWORD *)a1 + 17) & 0xC0000000) != v12)
    fixupProtocol(a1);
  MethodTypeEncoding_nolock = protocol_getMethodTypeEncoding_nolock((uint64_t)a1, a2, a3, a4);
  v13 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v14 = __ldxr(runtimeLock);
    if (v14 != v13)
      break;
    if (!__stlxr(0, runtimeLock))
      return MethodTypeEncoding_nolock;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return MethodTypeEncoding_nolock;
}

void sub_180111FC0(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t protocol_getMethodTypeEncoding_nolock(uint64_t result, objc_selector *a2, const char *a3, char *a4)
{
  int v4;
  int v5;
  _QWORD *v7;
  unsigned int **v8;
  unsigned int **v9;
  unint64_t MethodFromList;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t Protocol;
  uint64_t v16;

  if (result)
  {
    v4 = (int)a4;
    v5 = (int)a3;
    v7 = (_QWORD *)result;
    if ((unint64_t)*(unsigned int *)(result + 64) + result <= result + 72 || !a2 || !*(_QWORD *)(result + 72))
      goto LABEL_14;
    v8 = (unsigned int **)(result + 48);
    if ((_DWORD)a4)
      v8 = (unsigned int **)(result + 40);
    v9 = (unsigned int **)(result + 32);
    if ((_DWORD)a4)
      v9 = (unsigned int **)(result + 24);
    if ((_DWORD)a3)
      v8 = v9;
    if (*v8 && (MethodFromList = getMethodFromListArray<method_list_t **>(*v8, a2, a3, a4)) != 0)
    {
      v16 = 0;
      getExtendedTypesIndexesForMethod(v7, MethodFromList, v5, v4, (_DWORD *)&v16 + 1, &v16);
      return *(_QWORD *)(v7[9] + 8 * (v16 + HIDWORD(v16)));
    }
    else
    {
LABEL_14:
      v11 = (unint64_t *)v7[2];
      if (v11 && *v11)
      {
        v12 = 0;
        while (1)
        {
          v13 = v11[v12 + 1];
          v14 = canonical_protocol ? 0 : 0x20000000;
          if ((v14 & *(_DWORD *)(v13 + 68)) == 0)
          {
            Protocol = getProtocol(*(const char **)(v13 + 8));
            if (Protocol)
              v13 = Protocol;
          }
          result = protocol_getMethodTypeEncoding_nolock((protocol_t *)v13, a2, v5, v4);
          if (result)
            break;
          ++v12;
          v11 = (unint64_t *)v7[2];
          if (v12 >= *v11)
            return 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
{
  BOOL v4;
  const char *v5;
  unint64_t Method;
  unint64_t v7;
  char *v8;
  const char *v9;
  objc_method_description result;

  Method = protocol_getMethod((protocol_t *)p, (objc_selector *)aSel, (const char *)isRequiredMethod, (char *)isInstanceMethod, v4);
  if (Method)
  {
    v7 = Method & 3;
    if ((Method & 3) == 0 || (_DWORD)v7 == 2)
    {
      v7 = Method & 0xFFFFFFFFFFFFFFFCLL;
      v5 = *(const char **)(Method & 0xFFFFFFFFFFFFFFFCLL);
    }
    else if ((_DWORD)v7 == 1)
    {
      v7 = Method & 0xFFFFFFFFFFFFFFFCLL;
      if (dataSegmentsRanges > (Method & 0xFFFFFFFFFFFFFFFCLL) || *(_QWORD *)algn_1ECCE5978 <= v7)
      {
        v5 = *(const char **)(v7 + *(int *)v7);
      }
      else
      {
        v7 = *(int *)v7;
        v5 = (char *)&unk_1F25805A8 + v7;
      }
    }
    v8 = (char *)method_t::types(Method, v7);
  }
  else
  {
    v5 = 0;
    v8 = 0;
  }
  v9 = v5;
  result.types = v8;
  result.name = v9;
  return result;
}

unint64_t protocol_getMethod(protocol_t *a1, objc_selector *a2, const char *a3, char *a4, BOOL a5)
{
  unint64_t StatusReg;
  unsigned int v10;
  unint64_t Method_nolock;
  int v13;
  int v14;
  unsigned int v15;

  if (!a1)
    return 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v10 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v10, runtimeLock))
      goto LABEL_8;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_8:
  if (fixed_up_protocol)
    v13 = -1073741824;
  else
    v13 = 0x40000000;
  if ((*((_DWORD *)a1 + 17) & 0xC0000000) != v13)
    fixupProtocol(a1);
  Method_nolock = protocol_getMethod_nolock(a1, a2, a3, a4, a5);
  v14 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v15 = __ldxr(runtimeLock);
    if (v15 != v14)
      break;
    if (!__stlxr(0, runtimeLock))
      return Method_nolock;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return Method_nolock;
}

void sub_1801122E4(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t protocol_getMethod_nolock(protocol_t *a1, objc_selector *a2, const char *a3, char *a4, BOOL a5)
{
  unint64_t result;
  BOOL v8;
  BOOL v9;
  unsigned int **v10;
  unsigned int **v11;
  _QWORD *v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  uint64_t Protocol;

  result = 0;
  if (a1 && a2)
  {
    v8 = (char)a4;
    v9 = (char)a3;
    v10 = (unsigned int **)((char *)a1 + 48);
    if ((_DWORD)a4)
      v10 = (unsigned int **)((char *)a1 + 40);
    v11 = (unsigned int **)((char *)a1 + 32);
    if ((_DWORD)a4)
      v11 = (unsigned int **)((char *)a1 + 24);
    if ((_DWORD)a3)
      v10 = v11;
    if (!*v10 || (result = getMethodFromListArray<method_list_t **>(*v10, a2, a3, a4)) == 0)
    {
      v12 = (_QWORD *)*((_QWORD *)a1 + 2);
      if (v12 && *v12)
      {
        v13 = 0;
        v14 = 1;
        while (1)
        {
          v15 = v12[v13 + 1];
          v16 = canonical_protocol ? 0 : 0x20000000;
          if ((v16 & *(_DWORD *)(v15 + 68)) == 0)
          {
            Protocol = getProtocol(*(const char **)(v15 + 8));
            if (Protocol)
              v15 = Protocol;
          }
          result = protocol_getMethod_nolock((protocol_t *)v15, a2, v9, v8, a5);
          if (result)
            break;
          v13 = v14;
          v12 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (*v12 <= (unint64_t)v14++)
            return 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

_QWORD *getExtendedTypesIndexesForMethod(_QWORD *result, uint64_t a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  _DWORD *v6;
  unint64_t v7;
  _DWORD *v8;

  *a5 = 0;
  v6 = (_DWORD *)result[3];
  if (v6)
  {
    if (a3 && a4)
    {
      v7 = (a2 - (uint64_t)v6) / (unint64_t)((unsigned __int16)*v6 & 0xFFFC);
LABEL_18:
      *a6 = v7;
      return result;
    }
    LODWORD(v6) = v6[1];
    *a5 = (_DWORD)v6;
  }
  v8 = (_DWORD *)result[4];
  if (v8)
  {
    if (a3 && (a4 & 1) == 0)
      goto LABEL_17;
    LODWORD(v6) = (_DWORD)v6 + v8[1];
    *a5 = (_DWORD)v6;
  }
  v8 = (_DWORD *)result[5];
  if (!v8)
    goto LABEL_14;
  if (a4 && (a3 & 1) == 0)
  {
LABEL_17:
    v7 = (a2 - (uint64_t)v8) / (unint64_t)((unsigned __int16)*v8 & 0xFFFC);
    goto LABEL_18;
  }
  LODWORD(v6) = (_DWORD)v6 + v8[1];
  *a5 = (_DWORD)v6;
LABEL_14:
  v8 = (_DWORD *)result[6];
  if (!v8)
    return result;
  if ((a3 & 1) == 0 && (a4 & 1) == 0)
    goto LABEL_17;
  *a5 = (_DWORD)v6 + v8[1];
  return result;
}

objc_method_description *__cdecl protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount)
{
  unsigned int *v4;
  _BOOL4 v5;
  _BOOL4 v6;
  unint64_t StatusReg;
  unsigned int v9;
  objc_method_description *v11;
  int v12;
  Protocol *v13;
  Protocol *v14;
  int *isa;
  unint64_t v16;
  uint64_t v17;
  const char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  unint64_t v30;
  uint64_t v31;
  _QWORD *p_name;
  int v33;
  unsigned int v34;
  unsigned int *v36;
  unint64_t v37;

  v4 = outCount;
  if (!p)
  {
    v11 = 0;
    if (outCount)
      *outCount = 0;
    return v11;
  }
  v5 = isInstanceMethod;
  v6 = isRequiredMethod;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v9 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v9, runtimeLock))
      goto LABEL_9;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_9:
  if (fixed_up_protocol)
    v12 = -1073741824;
  else
    v12 = 0x40000000;
  if ((HIDWORD(p[8].super.isa) & 0xC0000000) != v12)
    fixupProtocol((protocol_t *)p);
  v13 = p + 6;
  if (v5)
    v13 = p + 5;
  v14 = p + 4;
  if (v5)
    v14 = p + 3;
  if (v6)
    v13 = v14;
  isa = (int *)v13->super.isa;
  if (!v13->super.isa)
  {
    v11 = 0;
    if (!v4)
      goto LABEL_37;
    goto LABEL_36;
  }
  v11 = (objc_method_description *)malloc_type_calloc((isa[1] + 1), 0x10uLL, 0x90040C859B4A5uLL);
  v16 = *isa;
  entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd(isa, v17, v18, v19);
  v21 = v20;
  v22 = (unint64_t)(isa + 2) & 0xFFFFFFFFFFFFFFFCLL | (v16 >> 31);
  if (v22 == v20)
  {
    LODWORD(isa) = 0;
    if (!v4)
      goto LABEL_37;
LABEL_36:
    *v4 = isa;
    goto LABEL_37;
  }
  v36 = v4;
  v37 = StatusReg;
  v23 = 0;
  LODWORD(isa) = 0;
  v24 = (unsigned __int16)v16 & 0xFFFC;
  v25 = &dataSegmentsRanges;
  v27 = dataSegmentsRanges;
  v26 = *(_QWORD *)algn_1ECCE5978;
  do
  {
    v28 = v22 + v23;
    v29 = (v22 + v23) & 3;
    if (!v29 || v29 == 2)
    {
      v25 = *(uint64_t **)(v28 & 0xFFFFFFFFFFFFFFFCLL);
    }
    else if (v29 == 1)
    {
      v30 = v28 & 0xFFFFFFFFFFFFFFFCLL;
      v31 = *(int *)(v28 & 0xFFFFFFFFFFFFFFFCLL);
      if (v27 > (v28 & 0xFFFFFFFFFFFFFFFCLL) || v26 <= v30)
        v25 = *(uint64_t **)(v30 + v31);
      else
        v25 = (uint64_t *)((char *)&unk_1F25805A8 + v31);
    }
    p_name = &v11[isa].name;
    *p_name = v25;
    p_name[1] = method_t::types(v28, (uint64_t)v25);
    LODWORD(isa) = (_DWORD)isa + 1;
    v23 += v24;
    v25 = (uint64_t *)(v22 + v23);
  }
  while (v22 + v23 != v21);
  v4 = v36;
  StatusReg = v37;
  if (v36)
    goto LABEL_36;
LABEL_37:
  v33 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v34 = __ldxr(runtimeLock);
    if (v34 != v33)
      break;
    if (!__stlxr(0, runtimeLock))
      return v11;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v11;
}

void sub_18011270C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void method_getReturnType(Method m, char *dst, size_t dst_len)
{
  uint64_t v3;
  char *v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  const char *v10;
  const char *Type;
  unint64_t v12;
  size_t v13;
  size_t v14;
  char *v15;

  if (!m)
  {
    if (!dst)
      return;
    goto LABEL_10;
  }
  v6 = (char *)method_t::types((unint64_t)m, v3);
  if (!dst)
    return;
  v10 = v6;
  if (!v6)
  {
LABEL_10:
    v15 = dst;
    v14 = dst_len;
    goto LABEL_11;
  }
  Type = SkipFirstType(v6, v7, v8, v9);
  v12 = Type - v10;
  if (Type - v10 >= dst_len)
    v13 = dst_len;
  else
    v13 = Type - v10;
  strncpy(dst, v10, v13);
  v14 = dst_len - v12;
  if (dst_len > v12)
  {
    v15 = &dst[v12];
LABEL_11:
    bzero(v15, v14);
  }
}

void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len)
{
  uint64_t v4;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  const char *v10;
  char *v11;
  char *v12;
  const char *Type;
  unint64_t v14;
  size_t v15;
  size_t v16;
  char *v17;
  char v18[4];
  char *v19;

  if (!m)
  {
    if (!dst)
      return;
    goto LABEL_11;
  }
  v7 = *(_QWORD *)&index;
  v8 = (char *)method_t::types((unint64_t)m, v4);
  v19 = v8;
  if (!dst)
    return;
  if (!v8 || (encoding_getArgumentInfo(v8, v7, (char *)&v19, v18), (v12 = v19) == 0))
  {
LABEL_11:
    v17 = dst;
    v16 = dst_len;
    goto LABEL_12;
  }
  Type = SkipFirstType(v19, v9, v10, v11);
  v14 = Type - v12;
  if (Type - v12 >= dst_len)
    v15 = dst_len;
  else
    v15 = Type - v12;
  strncpy(dst, v12, v15);
  v16 = dst_len - v14;
  if (dst_len > v14)
  {
    v17 = &dst[v14];
LABEL_12:
    bzero(v17, v16);
  }
}

unsigned int method_getNumberOfArguments(Method m)
{
  uint64_t v1;
  char *v2;
  uint64_t v3;
  const char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  int v10;
  int v11;
  unsigned int v12;
  const char *Type;
  const char *v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;

  if (!m)
    return 0;
  v2 = (char *)method_t::types((unint64_t)m, v1);
  v6 = (char *)(SkipFirstType(v2, v3, v4, v5) - 1);
  do
  {
    v11 = *++v6;
    v10 = v11;
  }
  while ((v11 - 48) < 0xA);
  if (!v10)
    return 0;
  v12 = 0;
  do
  {
    Type = SkipFirstType(v6, v7, v8, v9);
    v14 = Type + 1;
    v15 = *(unsigned __int8 *)Type;
    if (v15 != 43)
      v14 = Type;
    v16 = *(unsigned __int8 *)v14 == 45;
    if (v15 == 43)
      ++v16;
    v6 = (char *)&Type[v16 - 1];
    do
    {
      v18 = *++v6;
      v17 = v18;
    }
    while ((v18 - 48) < 0xA);
    ++v12;
  }
  while (v17);
  return v12;
}

uint64_t method_t::types@<X0>(unint64_t this@<X0>, uint64_t a2@<X8>)
{
  int v2;
  uint64_t v3;

  v2 = this & 3;
  if ((this & 3) == 0 || v2 == 2)
    return *(_QWORD *)((this & 0xFFFFFFFFFFFFFFFCLL) + 8);
  if (v2 == 1)
  {
    v3 = *(int *)((this & 0xFFFFFFFFFFFFFFFCLL) + 4);
    a2 = v3 + (this & 0xFFFFFFFFFFFFFFFCLL) + 4;
    if (!(_DWORD)v3)
      return 0;
  }
  return a2;
}

char *encoding_getArgumentInfo(char *a1, uint64_t a2, char *a3, char *a4)
{
  int v6;
  char *result;
  uint64_t v8;
  const char *v9;
  char *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  BOOL v15;
  int v16;
  const char *Type;
  const char *v18;
  _BOOL8 v19;
  char *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v27;
  _BOOL8 v28;
  char *v29;
  int v30;
  int v31;
  int v32;
  char *v33;
  int v34;
  int v35;

  v6 = a2;
  result = (char *)(SkipFirstType(a1, a2, a3, a4) - 1);
  do
  {
    v12 = *++result;
    v11 = v12;
  }
  while ((v12 - 48) < 0xA);
  v15 = v11 == 0;
  v13 = v11 != 0;
  v14 = 0;
  v15 = v15 || v6 == 0;
  if (!v15)
  {
    v16 = 0;
    do
    {
      Type = SkipFirstType(result, v8, v9, v10);
      v18 = Type;
      v19 = *(unsigned __int8 *)Type == 43;
      if (*Type == 43)
        v20 = (char *)(Type + 1);
      else
        v20 = (char *)Type;
      v21 = *v20;
      if (v21 == 45)
        result = v20 + 1;
      else
        result = v20;
      if (v16)
      {
        result = (char *)&v18[(v21 == 45) - 1 + v19];
        do
        {
          v23 = *++result;
          v22 = v23;
        }
        while ((v23 - 48) < 0xA);
      }
      else
      {
        v24 = *result;
        if ((v24 - 48) > 9)
        {
          v22 = *result;
        }
        else
        {
          do
          {
            v25 = *++result;
            v22 = v25;
            v14 = v24 + 10 * v14 - 48;
            v24 = v25;
          }
          while ((v25 - 48) < 0xA);
        }
        if (v21 == 45)
          v14 = -v14;
      }
      ++v16;
      v15 = v22 == 0;
      v13 = v22 != 0;
    }
    while (!v15 && v16 != v6);
  }
  if (v13)
  {
    *(_QWORD *)a3 = result;
    result = (char *)SkipFirstType(result, v8, v9, v10);
    if (v6)
    {
      v27 = *result;
      v28 = v27 == 43;
      if (v27 == 43)
        v29 = result + 1;
      else
        v29 = result;
      v30 = *v29;
      if (v30 == 45)
        ++v29;
      v31 = *v29;
      if ((v31 - 48) > 9)
      {
        v32 = 0;
      }
      else
      {
        v32 = 0;
        v33 = &result[(v30 == 45) + 1 + v28];
        do
        {
          v32 = v31 + 10 * v32 - 48;
          v34 = *v33++;
          v31 = v34;
        }
        while ((v34 - 48) < 0xA);
      }
      if (v30 == 45)
        v35 = -v32;
      else
        v35 = v32;
      v13 = v35 - v14;
    }
    else
    {
      v13 = 0;
    }
  }
  else
  {
    *(_QWORD *)a3 = 0;
  }
  *(_DWORD *)a4 = v13;
  return result;
}

const char *SkipFirstType(char *a1, uint64_t a2, const char *a3, char *a4)
{
  char *v5;
  int v6;
  int v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  int v11;
  const char *v12;

  do
  {
    v5 = a1;
    v7 = *a1++;
    v6 = v7;
    v8 = (v7 - 78);
    if (v8 > 0x2D)
      goto LABEL_8;
  }
  while (((1 << v8) & 0x1300010103) != 0);
  if (v8 == 13)
  {
    do
      v11 = *++v5;
    while ((v11 - 48) < 0xA);
    v12 = &v5[(int)SubtypeUntil(v5, 93, a3, a4)];
    return v12 + 1;
  }
  if (v8 == 45)
  {
    v9 = a1;
    v10 = 125;
LABEL_14:
    v12 = &a1[(int)SubtypeUntil(v9, v10, a3, a4)];
    return v12 + 1;
  }
LABEL_8:
  if (v6 == 40)
  {
    v9 = a1;
    v10 = 41;
    goto LABEL_14;
  }
  if (v6 != 64)
    return v5 + 1;
  if (v5[1] == 63)
    return v5 + 2;
  return a1;
}

_QWORD *addMethods(objc_class *a1, objc_selector **a2, void (**a3)(void), const char **a4, method_list_t *a5, unsigned int a6, unsigned int *a7)
{
  unsigned int v8;
  const char **v9;
  void (**v10)(void);
  int *MethodList;
  const char *v14;
  char *v15;
  int *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t MethodNoSuper_nolock;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  const char *v29;
  size_t v30;
  _QWORD *v31;
  uint64_t v32;
  void *v33;
  int v34;
  unint64_t v35;
  uint64_t v36;
  unsigned int *v38;
  unint64_t v39;
  unint64_t v40;
  size_t size;
  int *v42;
  objc_class *v43;

  v8 = a5;
  v9 = a4;
  v10 = a3;
  MethodList = method_list_t::allocateMethodList(a5, 3, (const char *)a3, (char *)a4);
  v16 = MethodList;
  MethodList[1] = 0;
  if (v8)
  {
    v17 = 0;
    v18 = 0;
    v19 = v8;
    v38 = a7;
    v39 = *(_QWORD *)algn_1ECCE5978;
    v40 = dataSegmentsRanges;
    size = v8 + 1;
    v42 = MethodList;
    v43 = a1;
    do
    {
      MethodNoSuper_nolock = getMethodNoSuper_nolock(a1, *a2, v14, v15);
      if (MethodNoSuper_nolock)
      {
        v25 = MethodNoSuper_nolock;
        v26 = a6;
        if ((a6 & 1) != 0)
        {
          _method_setImplementation(a1, MethodNoSuper_nolock, *v10);
        }
        else
        {
          if (!v18)
            v18 = malloc_type_calloc(8uLL, size, 0x95961078uLL);
          v34 = v25 & 3;
          if ((v25 & 3) == 0 || v34 == 2)
          {
            v26 = *(_QWORD *)(v25 & 0xFFFFFFFFFFFFFFFCLL);
          }
          else if (v34 == 1)
          {
            v35 = v25 & 0xFFFFFFFFFFFFFFFCLL;
            v36 = *(int *)(v25 & 0xFFFFFFFFFFFFFFFCLL);
            if (v40 > (v25 & 0xFFFFFFFFFFFFFFFCLL) || v39 <= v35)
              v26 = *(_QWORD *)(v35 + v36);
            else
              v26 = (unint64_t)&unk_1F25805A8 + v36;
          }
          v18[v17] = v26;
          v17 = (v17 + 1);
        }
      }
      else
      {
        entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd(v16, v21, v14, v15);
        v28 = v27 & 0xFFFFFFFFFFFFFFFCLL;
        *(_QWORD *)(v27 & 0xFFFFFFFFFFFFFFFCLL) = *a2;
        v29 = *v9;
        v30 = strlen(*v9) + 1;
        if ((_dyld_is_memory_immutable() & 1) == 0)
        {
          v31 = v18;
          v32 = v17;
          v33 = malloc_type_malloc(v30, 0x3F84A03uLL);
          memcpy(v33, v29, v30);
          v29 = (const char *)v33;
          v17 = v32;
          v18 = v31;
          v16 = v42;
        }
        *(_QWORD *)(v28 + 8) = v29;
        *(_QWORD *)(v28 + 16) = *v10;
        ++v16[1];
        a1 = v43;
      }
      ++v10;
      ++v9;
      ++a2;
      --v19;
    }
    while (v19);
    if (v16[1])
    {
      addMethods_finish(a1, (method_list_t *)v16, v14, v15, v22, v23, v24);
      a7 = v38;
      if (!v38)
        return v18;
      goto LABEL_28;
    }
    a7 = v38;
  }
  else
  {
    LODWORD(v17) = 0;
    v18 = 0;
  }
  free((void *)((unint64_t)v16 & 0xFFFFFFFFFFFFFFFLL));
  if (a7)
LABEL_28:
    *a7 = v17;
  return v18;
}

_DWORD *method_list_t::allocateMethodList(method_list_t *this, uint64_t a2, const char *a3, char *a4)
{
  int v4;
  uint64_t v5;
  int v6;
  _DWORD *result;

  v4 = (int)this;
  v5 = 24 * this;
  if ((v5 & 0xFFFFFFFF00000000) != 0)
    _objc_fatal("entsize_list_tt overflow: count %u with entsize %u", a2, a3, a4, 24, this);
  v6 = a2;
  result = malloc_type_calloc(v5 + 8, 1uLL, 0xB48A38ECuLL);
  *result = v6 | 0x18;
  result[1] = v4;
  return result;
}

uint64_t SubtypeUntil(char *a1, uint64_t a2, const char *a3, char *a4)
{
  char v4;
  int v5;
  const char *v6;
  int v7;

  v4 = *a1;
  if (!*a1)
LABEL_16:
    _objc_fatal("Object: SubtypeUntil: end of type encountered prematurely\n", a2, a3, a4);
  v5 = 0;
  v6 = a1;
  while (v5 || v4 != a2)
  {
    if (v4 <= 92)
    {
      if (v4 == 40)
        goto LABEL_14;
      if (v4 != 41)
      {
        if (v4 != 91)
          goto LABEL_15;
LABEL_14:
        ++v5;
        goto LABEL_15;
      }
LABEL_13:
      --v5;
      goto LABEL_15;
    }
    switch(v4)
    {
      case '}':
        goto LABEL_13;
      case '{':
        goto LABEL_14;
      case ']':
        goto LABEL_13;
    }
LABEL_15:
    v7 = *(unsigned __int8 *)++v6;
    v4 = v7;
    if (!v7)
      goto LABEL_16;
  }
  return ((_DWORD)v6 - (_DWORD)a1);
}

void fixupProtocol(protocol_t *a1)
{
  unint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t Protocol;
  unsigned int v8;
  int v9;
  int v10;

  v2 = (unint64_t *)*((_QWORD *)a1 + 2);
  if (v2 && *v2)
  {
    v3 = 0;
    do
    {
      v4 = v2[v3 + 1];
      v5 = *(_DWORD *)(v4 + 68);
      if (canonical_protocol)
        v6 = 0;
      else
        v6 = 0x20000000;
      if ((v6 & v5) == 0)
      {
        Protocol = getProtocol(*(const char **)(v4 + 8));
        if (Protocol)
          v4 = Protocol;
        v5 = *(_DWORD *)(v4 + 68);
      }
      v8 = v5 & 0xC0000000;
      if (fixed_up_protocol)
        v9 = -1073741824;
      else
        v9 = 0x40000000;
      if (v8 != v9)
        fixupProtocol((protocol_t *)v4);
      ++v3;
      v2 = (unint64_t *)*((_QWORD *)a1 + 2);
    }
    while (v3 < *v2);
  }
  fixupProtocolMethodList((uint64_t)a1, *((unsigned int **)a1 + 3), 1, (char *)1);
  fixupProtocolMethodList((uint64_t)a1, *((unsigned int **)a1 + 4), 1, 0);
  fixupProtocolMethodList((uint64_t)a1, *((unsigned int **)a1 + 5), 0, (char *)1);
  fixupProtocolMethodList((uint64_t)a1, *((unsigned int **)a1 + 6), 0, 0);
  if (fixed_up_protocol)
    v10 = -1073741824;
  else
    v10 = 0x40000000;
  *((_DWORD *)a1 + 17) = v10 | *((_DWORD *)a1 + 17) & 0x3FFFFFFF;
}

IMP method_setImplementation(Method m, IMP imp)
{
  unint64_t StatusReg;
  unsigned int v5;
  void (*v7)(void);
  int v8;
  unsigned int v9;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v5, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v7 = (void (*)(void))_method_setImplementation(0, (uint64_t)m, imp);
  v8 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v9 = __ldxr(runtimeLock);
    if (v9 != v8)
      break;
    if (!__stlxr(0, runtimeLock))
      return v7;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v7;
}

void sub_180113108(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void method_exchangeImplementations(Method m1, Method m2)
{
  char *v2;
  char *v3;
  unint64_t StatusReg;
  unsigned int v7;
  void (*v9)(void);
  void (*v10)(void);
  int v11;
  int *v12;
  int v13;
  int *v14;
  char *v15;
  const method_t *v16;
  char *v17;
  const method_t *v18;
  char *v19;
  int v20;
  unsigned int v21;
  _QWORD v22[8];

  if (m1 && m2)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v7 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v7, runtimeLock))
        goto LABEL_8;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_8:
    v9 = (void (*)(void))method_t::imp((unint64_t)m1, 0);
    v10 = (void (*)(void))method_t::imp((unint64_t)m2, 0);
    v11 = m1 & 3;
    if ((m1 & 3) == 0 || v11 == 2)
    {
      v2 = *(char **)((unint64_t)m1 & 0xFFFFFFFFFFFFFFFCLL);
    }
    else if (v11 == 1)
    {
      v12 = (int *)((unint64_t)m1 & 0xFFFFFFFFFFFFFFFCLL);
      if (dataSegmentsRanges > ((unint64_t)m1 & 0xFFFFFFFFFFFFFFFCLL)
        || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v12)
      {
        v2 = *(char **)((char *)v12 + *v12);
      }
      else
      {
        v2 = (char *)&unk_1F25805A8 + *v12;
      }
    }
    v13 = m2 & 3;
    if ((m2 & 3) == 0 || v13 == 2)
    {
      v3 = *(char **)((unint64_t)m2 & 0xFFFFFFFFFFFFFFFCLL);
    }
    else if (v13 == 1)
    {
      v14 = (int *)((unint64_t)m2 & 0xFFFFFFFFFFFFFFFCLL);
      if (dataSegmentsRanges > ((unint64_t)m2 & 0xFFFFFFFFFFFFFFFCLL)
        || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v14)
      {
        v3 = *(char **)((char *)v14 + *v14);
      }
      else
      {
        v3 = (char *)&unk_1F25805A8 + *v14;
      }
    }
    method_t::setImp((uint64_t)m1, v10);
    method_t::setImp((uint64_t)m2, v9);
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3321888768;
    v22[2] = __method_exchangeImplementations_block_invoke;
    v22[3] = &__block_descriptor_64_e8_32c43_ZTSKZ30method_exchangeImplementationsE3__0_e8_B16__0_8l;
    v22[4] = v2;
    v22[5] = v3;
    v22[6] = v9;
    v22[7] = v10;
    flushCaches(0, (uint64_t)"method_exchangeImplementations", (const char *)v22, v15);
    objc::Scanner::scanChangedMethod(0, (unint64_t)m1, v16, v17);
    objc::Scanner::scanChangedMethod(0, (unint64_t)m2, v18, v19);
    v20 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v21 = __ldxr(runtimeLock);
      if (v21 != v20)
        break;
      if (!__stlxr(0, runtimeLock))
        return;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_18011334C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t _method_setImplementation(objc_class *a1, uint64_t this, void (*a3)(void))
{
  char *v3;
  unint64_t v4;
  int v8;
  int *v9;
  char *v10;
  const method_t *v11;
  char *v12;
  _QWORD v14[6];

  v4 = 0;
  if (this && a3)
  {
    v4 = method_t::imp(this, 0);
    v8 = this & 3;
    if ((this & 3) == 0 || v8 == 2)
    {
      v3 = *(char **)(this & 0xFFFFFFFFFFFFFFFCLL);
    }
    else if (v8 == 1)
    {
      v9 = (int *)(this & 0xFFFFFFFFFFFFFFFCLL);
      if (dataSegmentsRanges > (this & 0xFFFFFFFFFFFFFFFCLL) || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v9)
        v3 = *(char **)((char *)v9 + *v9);
      else
        v3 = (char *)&unk_1F25805A8 + *v9;
    }
    method_t::setImp(this, a3);
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3321888768;
    v14[2] = ___ZL25_method_setImplementationP10objc_classP8method_tPFvvE_block_invoke;
    v14[3] = &__block_descriptor_48_e8_32c67_ZTSKZL25_method_setImplementationP10objc_classP8method_tPFvvEE3__0_e8_B16__0_8l;
    v14[4] = v3;
    v14[5] = v4;
    flushCaches((uint64_t)a1, (uint64_t)"_method_setImplementation", (const char *)v14, v10);
    objc::Scanner::scanChangedMethod((uint64_t)a1, this, v11, v12);
  }
  return v4;
}

uint64_t objc::Scanner::scanChangedMethod(uint64_t this, unint64_t a2, const method_t *a3, char *a4)
{
  int v5;
  int *v6;
  char *v7;
  int v9;
  int v10;
  char v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  const char *v26;
  char *v27;
  uint64_t v28;
  const char *v29;
  char *v30;
  _QWORD v31[12];
  uint64_t *v32[9];
  objc_class *v33;
  unint64_t v34;

  v5 = a2 & 3;
  if ((a2 & 3) == 0 || v5 == 2)
  {
    v7 = *(char **)(a2 & 0xFFFFFFFFFFFFFFFCLL);
  }
  else
  {
    if (v5 != 1)
      goto LABEL_36;
    v6 = (int *)(a2 & 0xFFFFFFFFFFFFFFFCLL);
    if (dataSegmentsRanges > (a2 & 0xFFFFFFFFFFFFFFFCLL) || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v6)
      v7 = *(char **)((char *)v6 + *v6);
    else
      v7 = (char *)&unk_1F25805A8 + *v6;
  }
  if (sel_alloc != v7 && sel_allocWithZone_ != v7)
  {
    v9 = 4;
    v10 = 1;
    if (sel_retain != v7
      && sel_release != v7
      && sel_autorelease != v7
      && sel__tryRetain != v7
      && sel__isDeallocating != v7
      && sel_retainCount != v7
      && sel_allowsWeakReference != v7
      && sel_retainWeakReference != v7)
    {
      v9 = 16;
      v10 = 1;
      if (&sel_new != (_UNKNOWN *)v7 && sel_self != v7 && sel_class != v7 && sel_isKindOfClass_ != v7)
      {
        if (sel_respondsToSelector_ != v7)
          return this;
        v10 = 1;
      }
    }
    if (this)
      goto LABEL_27;
    goto LABEL_37;
  }
LABEL_36:
  v10 = 0;
  v9 = 1;
  if (this)
  {
LABEL_27:
    if ((*(_WORD *)(this + 30) & 4) != 0)
    {
      if ((__objc2_class *)this == &OBJC_METACLASS___NSObject
        && (objc::NSObjectSwizzledMask & (2 * v9)) == 0)
      {
        return (uint64_t)objc::Scanner::setNSObjectSwizzled(&OBJC_METACLASS___NSObject, v9, 1);
      }
    }
    else
    {
      v11 = v10 ^ 1;
      if ((__objc2_class *)this != NSObject)
        v11 = 1;
      if ((v11 & 1) == 0 && (objc::NSObjectSwizzledMask & v9) == 0)
        return (uint64_t)objc::Scanner::setNSObjectSwizzled(NSObject, v9, 0);
    }
    return this;
  }
LABEL_37:
  v12 = objc::NSObjectSwizzledMask;
  if ((objc::NSObjectSwizzledMask & v9) != 0)
    v10 = 0;
  if (v10 == 1)
  {
    v13 = *(_QWORD *)(((uint64_t)OBJC_CLASS___NSObject.info & 0xF00007FFFFFFFF8) + 8);
    v14 = v13 & 0xFFFFFFFFFFFFFFFELL;
    if ((v13 & 1) != 0)
    {
      v16 = *(_QWORD *)(v14 + 8);
    }
    else
    {
      v15 = *(_QWORD *)(v14 + 32);
      v16 = v15 & 0xFFFFFFFFFFFFFFFELL;
      if ((v15 & 1) != 0)
        v17 = v15 & 0xFFFFFFFFFFFFFFFELL;
      else
        v17 = 0;
      if ((v15 & 1) != 0 || !v16)
      {
        v16 = v17 | 2;
        if (!v17)
          v16 = 0;
      }
    }
    v34 = v16;
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::begin((uint64_t)v32, &v34, (const char *)a3, a4);
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::end((uint64_t)v31, &v34, v18, v19);
    while (1)
    {
      this = list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v32, v31);
      if ((this & 1) != 0)
        break;
      if (v33 == (objc_class *)a2)
      {
        this = (uint64_t)objc::Scanner::setNSObjectSwizzled(NSObject, v9, 0);
        break;
      }
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator++(v32, v20, (const char *)a3, a4);
    }
    v12 = objc::NSObjectSwizzledMask;
  }
  if ((v12 & (2 * v9)) == 0)
  {
    v21 = *(_QWORD *)(((uint64_t)OBJC_METACLASS___NSObject.info & 0xF00007FFFFFFFF8) + 8);
    v22 = v21 & 0xFFFFFFFFFFFFFFFELL;
    if ((v21 & 1) != 0)
    {
      v24 = *(_QWORD *)(v22 + 8);
    }
    else
    {
      v23 = *(_QWORD *)(v22 + 32);
      v24 = v23 & 0xFFFFFFFFFFFFFFFELL;
      if ((v23 & 1) != 0)
        v25 = v23 & 0xFFFFFFFFFFFFFFFELL;
      else
        v25 = 0;
      if ((v23 & 1) != 0 || !v24)
      {
        v24 = v25 | 2;
        if (!v25)
          v24 = 0;
      }
    }
    v34 = v24;
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::begin((uint64_t)v32, &v34, (const char *)a3, a4);
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::end((uint64_t)v31, &v34, v26, v27);
    while (1)
    {
      this = list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v32, v31);
      if ((this & 1) != 0)
        break;
      if (v33 == (objc_class *)a2)
        return (uint64_t)objc::Scanner::setNSObjectSwizzled(&OBJC_METACLASS___NSObject, v9, 1);
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator++(v32, v28, v29, v30);
    }
  }
  return this;
}

uint64_t method_t::setImp(uint64_t this, void (*a2)(void))
{
  unint64_t v3;
  int v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t *v7;

  v3 = this;
  v4 = this & 3;
  if ((this & 3) != 0 && v4 != 2)
  {
    if (v4 != 1)
      return this;
    if (!byte_1ECCE5208)
    {
      objc::smallMethodIMPMap = 0;
      qword_1ECCE51F8 = 0;
      dword_1ECCE5200 = 0;
      byte_1ECCE5208 = 1;
    }
    v7 = 0;
    this = objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::LookupBucketFor<method_t const*>(this, &v7);
    v5 = v7;
    if ((this & 1) != 0)
      goto LABEL_15;
    this = dword_1ECCE5200;
    if (4 * (int)qword_1ECCE51F8 + 4 >= (3 * dword_1ECCE5200))
    {
      LODWORD(this) = 2 * dword_1ECCE5200;
    }
    else if (dword_1ECCE5200 + ~(_DWORD)qword_1ECCE51F8 - HIDWORD(qword_1ECCE51F8) > dword_1ECCE5200 >> 3)
    {
LABEL_9:
      if (*v5 == -2)
      {
        qword_1ECCE51F8 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE51F8, (int32x2_t)0xFFFFFFFF00000001);
      }
      else if (*v5 == -1)
      {
        LODWORD(qword_1ECCE51F8) = qword_1ECCE51F8 + 1;
      }
      *v5 = v3;
      v5[1] = 0;
LABEL_15:
      v6 = v5 + 1;
      goto LABEL_16;
    }
    objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::grow(this);
    v7 = 0;
    this = objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::LookupBucketFor<method_t const*>(v3, &v7);
    v5 = v7;
    goto LABEL_9;
  }
  v6 = (_QWORD *)((this & 0xFFFFFFFFFFFFFFFCLL) + 16);
LABEL_16:
  *v6 = a2;
  return this;
}

void objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::grow(int a1)
{
  uint64_t v1;
  unint64_t *v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  unint64_t *v14;

  v1 = dword_1ECCE5200;
  v2 = (unint64_t *)objc::smallMethodIMPMap;
  v3 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
  v5 = v4 | HIWORD(v4);
  if ((v5 + 1) > 4)
    v6 = v5 + 1;
  else
    v6 = 4;
  dword_1ECCE5200 = v6;
  v7 = malloc_type_malloc(16 * v6, 0x64B88C75uLL);
  objc::smallMethodIMPMap = (uint64_t)v7;
  if (v2)
  {
    qword_1ECCE51F8 = 0;
    if (dword_1ECCE5200)
    {
      v8 = 16 * dword_1ECCE5200;
      do
      {
        *v7 = -1;
        v7 += 2;
        v8 -= 16;
      }
      while (v8);
    }
    if ((_DWORD)v1)
    {
      v9 = 16 * v1;
      v10 = v2;
      do
      {
        v11 = *v10;
        if (*v10 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v14 = 0;
          objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::LookupBucketFor<method_t const*>(v11, &v14);
          v12 = v14;
          *v14 = *v10;
          v12[1] = v10[1];
          LODWORD(qword_1ECCE51F8) = qword_1ECCE51F8 + 1;
        }
        v10 += 2;
        v9 -= 16;
      }
      while (v9);
    }
    free(v2);
  }
  else
  {
    qword_1ECCE51F8 = 0;
    if (dword_1ECCE5200)
    {
      v13 = 16 * dword_1ECCE5200;
      do
      {
        *v7 = -1;
        v7 += 2;
        v13 -= 16;
      }
      while (v13);
    }
  }
}

IMP method_getImplementation(IMP m)
{
  if (m)
    return (IMP)method_t::imp((unint64_t)m, 1);
  return m;
}

Protocol *__cdecl objc_getProtocol(const char *name)
{
  unint64_t StatusReg;
  unsigned int v3;
  Protocol *Protocol;
  int v6;
  unsigned int v7;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v3, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  Protocol = (Protocol *)getProtocol(name);
  v6 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v7 = __ldxr(runtimeLock);
    if (v7 != v6)
      break;
    if (!__stlxr(0, runtimeLock))
      return Protocol;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return Protocol;
}

void sub_180113B70(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void _NXMapRehash(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  BOOL v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_QWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 12);
  v5 = v3 + 1;
  v6 = v3 == -1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 2 * (v3 + 1) - 1;
  *(_QWORD *)(a1 + 16) = allocBuckets(2 * (v3 + 1));
  if (!v6)
  {
    v7 = (uint64_t *)(v2 + 8);
    do
    {
      v8 = *(v7 - 1);
      if (v8 != -1)
      {
        v9 = *v7;
        v10 = (**(uint64_t (***)(uint64_t, _QWORD))a1)(a1, *(v7 - 1));
        NXMapInsertWithHash(a1, v8, v10, v9);
      }
      v7 += 2;
      --v5;
    }
    while (v5);
  }
  if (v4 != *(_DWORD *)(a1 + 8))
    _objc_inform("*** maptable: count differs after rehashing; probably indicates a broken invariant: there are x and y such as isEq"
      "ual(x, y) is TRUE but hash(x) != hash (y)\n");
  free((void *)(v2 - 16));
}

void objc_registerClassPair(Class cls)
{
  unint64_t StatusReg;
  unsigned int v3;
  uint64_t v5;
  BOOL v6;
  _DWORD *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;
  int v16;
  unsigned int v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  _QWORD *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int *v27;
  uint64_t v28;
  const char *v29;
  char *v30;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v3, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  if ((unint64_t)(*(_QWORD *)cls - 1) < 0xF
    || (*(_DWORD *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (v5 = *(unsigned __int16 *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 4), dword_1ECCE5988 <= v5)
    || (*(_QWORD *)(qword_1ECCE5980 + 16 * v5) <= (unint64_t)cls
      ? (v6 = *(_QWORD *)(qword_1ECCE5980 + 16 * v5 + 8) > (unint64_t)cls)
      : (v6 = 0),
        !v6))
  {
    if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)cls)
      && (dataSegmentsContain(cls, v26, v27) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v28, v29, v30, cls);
    }
  }
  v7 = (_DWORD *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8);
  if ((*v7 & 0x2000000) != 0
    || (v8 = (unsigned int *)(*(_QWORD *)((*(_QWORD *)cls & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8),
        (*v8 & 0x2000000) != 0))
  {
    v12 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
    v13 = (_QWORD *)(v12 & 0xFFFFFFFFFFFFFFFELL);
    v14 = "objc_registerClassPair: class '%s' was already registered!";
    if ((v12 & 1) != 0)
LABEL_38:
      v13 = (_QWORD *)*v13;
LABEL_23:
    v15 = atomic_load(v13 + 3);
    _objc_inform(v14, v15);
    goto LABEL_24;
  }
  if ((*v7 & *v8 & 0x4000000) == 0)
  {
    v25 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
    v13 = (_QWORD *)(v25 & 0xFFFFFFFFFFFFFFFELL);
    v14 = "objc_registerClassPair: class '%s' was not allocated with objc_allocateClassPair!";
    if ((v25 & 1) != 0)
      goto LABEL_38;
    goto LABEL_23;
  }
LABEL_17:
  v9 = *v8;
  v10 = *v8 & 0xF9F7FFFF | 0x2000000;
  do
  {
    v11 = __ldaxr(v8);
    if (v11 != v9)
    {
      __clrex();
      goto LABEL_17;
    }
  }
  while (__stlxr(v10, v8));
  v18 = (unsigned int *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8);
LABEL_29:
  v19 = *v18;
  v20 = *v18 & 0xF9F7FFFF | 0x2000000;
  do
  {
    v21 = __ldaxr(v18);
    if (v21 != v19)
    {
      __clrex();
      goto LABEL_29;
    }
  }
  while (__stlxr(v20, v18));
  v22 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
  v23 = (_QWORD *)(v22 & 0xFFFFFFFFFFFFFFFELL);
  if ((v22 & 1) != 0)
    v23 = (_QWORD *)*v23;
  v24 = (char *)atomic_load(v23 + 3);
  addNamedClass(cls, v24, 0);
LABEL_24:
  v16 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v17 = __ldxr(runtimeLock);
    if (v17 != v16)
      break;
    if (!__stlxr(0, runtimeLock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
}

void sub_180113EB8(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t NXMapInsertWithHash(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  int v12;
  uint64_t v13;
  int v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;

  if (a2 == -1)
  {
    _objc_inform("*** NXMapInsert: invalid key: -1\n");
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 16);
    v9 = *(_DWORD *)(a1 + 12);
    v10 = v9 & a3;
    v11 = (uint64_t *)(v8 + 16 * v10);
    v12 = v9 + 1;
    v13 = *v11;
    if (*v11 == -1)
    {
LABEL_8:
      *v11 = a2;
      v15 = (_QWORD *)(v8 + 16 * v10);
LABEL_9:
      v15[1] = a4;
      v16 = *(_DWORD *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v16;
      if (3 * v12 < (4 * v16))
        _NXMapRehash(a1);
    }
    else
    {
      while (1)
      {
        if (v13 == a2 || (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, v13, a2))
        {
          v17 = v8 + 16 * v10;
LABEL_19:
          v22 = *(_QWORD *)(v17 + 8);
          v20 = (_QWORD *)(v17 + 8);
          v21 = v22;
          if (v22 != a4)
          {
            *v20 = a4;
            return v21;
          }
          return a4;
        }
        if (*(_DWORD *)(a1 + 8) != v12)
          break;
        _NXMapRehash(a1);
        v8 = *(_QWORD *)(a1 + 16);
        v14 = *(_DWORD *)(a1 + 12);
        v10 = v14 & a3;
        v12 = v14 + 1;
        v13 = *(_QWORD *)(v8 + 16 * v10);
        if (v13 == -1)
        {
          v11 = (uint64_t *)(v8 + 16 * v10);
          goto LABEL_8;
        }
      }
      LODWORD(v18) = v10;
      while (1)
      {
        v18 = *(_DWORD *)(a1 + 12) & (v18 + 1);
        if ((_DWORD)v18 == (_DWORD)v10)
          break;
        v19 = *(_QWORD *)(v8 + 16 * v18);
        if (v19 == -1)
        {
          v15 = (_QWORD *)(v8 + 16 * v18);
          *v15 = a2;
          goto LABEL_9;
        }
        if (v19 == a2 || (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, v19, a2))
        {
          v17 = v8 + 16 * v18;
          goto LABEL_19;
        }
      }
      _objc_inform("**** NXMapInsert: bug\n");
    }
  }
  return 0;
}

uint64_t addNamedClass(objc_class *a1, char *a2, objc_class *a3)
{
  char *ClassExceptSomeSwift;
  char *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  const char *v11;
  const char *v12;
  unsigned int v13;
  uint64_t v14;
  const char *v15;
  mach_header_64 *v16;
  char *v17;
  char *v18;
  mach_header_64 *v19;
  char *v20;
  uint64_t v21;
  uint64_t (***v22)(_QWORD, uint64_t);
  uint64_t v23;
  uint64_t size;

  ClassExceptSomeSwift = getClassExceptSomeSwift(a2);
  if (!ClassExceptSomeSwift || (v7 = ClassExceptSomeSwift, ClassExceptSomeSwift == (char *)a3))
  {
    v13 = _mapStrHash((uint64_t)ClassExceptSomeSwift, a2);
    v14 = gdb_objc_realized_classes;
    v15 = a2;
    return NXMapInsertWithHash(v14, (uint64_t)v15, v13, (uint64_t)a1);
  }
  v8 = _headerForClass((unint64_t)ClassExceptSomeSwift);
  v9 = _headerForClass((unint64_t)a1);
  v10 = v9;
  if (v8)
  {
    v11 = (const char *)dyld_image_path_containing_address();
    if (v10)
    {
LABEL_5:
      v12 = (const char *)dyld_image_path_containing_address();
      goto LABEL_9;
    }
  }
  else
  {
    v11 = "??";
    if (v9)
      goto LABEL_5;
  }
  v12 = "??";
LABEL_9:
  v16 = _NSGetMachExecuteHeader();
  size = 0;
  v17 = getsectdatafromheader_64(v16, "__DATA_CONST", "__objc_dupclass", &size);
  v18 = &v17[_dyld_get_image_slide()];
  while (1)
  {
    v19 = _NSGetMachExecuteHeader();
    size = 0;
    v20 = getsectdatafromheader_64(v19, "__DATA_CONST", "__objc_dupclass", &size);
    if (v18 >= &v20[_dyld_get_image_slide() + size])
      break;
    v21 = *(_QWORD *)v18;
    v18 += 8;
    if (!strcmp((const char *)(v21 + 8), a2))
      goto LABEL_17;
  }
  if (DebugDuplicateClasses)
  {
    if (DebugDuplicateClasses == 2)
      ((void (*)(const char *, ...))_objc_fatal)("Class %s is implemented in both %s (%p) and %s (%p). One of the two will be used. Which one is undefined.", a2, v11, v7, v12, a1);
    _objc_inform("Class %s is implemented in both %s (%p) and %s (%p). One of the two will be used. Which one is undefined.", a2, v11, v7, v12, a1);
  }
LABEL_17:
  v22 = (uint64_t (***)(_QWORD, uint64_t))nonMetaClasses();
  v23 = *(_QWORD *)a1 & 0xFFFFFFFF8;
  v13 = (**v22)(v22, v23);
  v14 = (uint64_t)v22;
  v15 = (const char *)v23;
  return NXMapInsertWithHash(v14, (uint64_t)v15, v13, (uint64_t)a1);
}

void map_images_nolock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _BYTE *v5;
  objc::SafeRanges *shared_cache_range;
  const char *v7;
  int v8;
  __objc2_class *v9;
  uint64_t prog_image_header;
  uint64_t v11;
  const char *v12;
  char *v13;
  const mach_header_64 *v14;
  int v15;
  header_info **v16;
  uint64_t v17;
  uint64_t v18;
  const mach_header_64 *v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  const mach_header_64 *v28;
  uint32_t magic;
  uint64_t v32;
  BOOL v33;
  char *v34;
  _BYTE *v35;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v37;
  int v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  _QWORD *v47;
  unint64_t i;
  uint64_t v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t *v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t j;
  __int128 v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  char *v69;
  const char *v70;
  const char *v71;
  const char *v72;
  const char *v73;
  unsigned int v74;
  unsigned int v75;
  void *v76;
  unint64_t StatusReg;
  unsigned int v78;
  int v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  _QWORD **v87;
  const char *v88;
  uint64_t k;
  uint32_t v90;
  unsigned __int8 v91;
  int v92;
  uint64_t v93;
  unint64_t v94;
  unsigned int v95;
  header_info **v97;
  header_info *v98;
  int v99;
  uint64_t v100;
  unint64_t v101;
  char **v102;
  char *v103;
  int v104;
  unsigned int v105;
  void *v106;
  uint64_t v107;
  header_info **v108;
  header_info *v109;
  int v110;
  char v111;
  const char *v112;
  const char *v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  int v118;
  char v119;
  objc_class *v120;
  uint64_t Class;
  uint64_t v122;
  header_info **v124;
  unint64_t v125;
  unint64_t *v126;
  uint64_t v127;
  BOOL v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t *v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  int v137;
  int v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  void *v142;
  unint64_t *v143;
  char **Protocol;
  char **v145;
  const char *v146;
  int v147;
  int v148;
  int v149;
  int v150;
  uint64_t PreoptimizedProtocol;
  char **v152;
  BOOL v153;
  char v154;
  unint64_t *v155;
  const char *v156;
  const char *v157;
  uint64_t v158;
  const char *v159;
  char *v160;
  int v161;
  const char *v162;
  const char *v163;
  unint64_t v164;
  header_info **v165;
  unint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  int v171;
  uint64_t v172;
  uint64_t v173;
  header_info **v174;
  uint64_t v175;
  header_info **v176;
  header_info **v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t *v180;
  unint64_t v181;
  objc_class *v182;
  uint64_t v183;
  _QWORD *v184;
  uint64_t v185;
  objc_class **v186;
  uint64_t v187;
  char *v188;
  _QWORD *v189;
  char *v190;
  int v191;
  const char *v192;
  uint64_t v193;
  uint64_t v194;
  unint64_t v195;
  unint64_t *v196;
  unint64_t v197;
  uint64_t v198;
  const char *v199;
  char *v200;
  _QWORD *v201;
  uint64_t v202;
  const char *v203;
  char *v204;
  uint64_t *v205;
  uint64_t *v206;
  _QWORD *v207;
  int v208;
  void (*v209)(uint64_t);
  _QWORD *v210;
  header_info **v211;
  uint64_t v212;
  char *v213;
  uint64_t v214;
  const char *v215;
  char *v216;
  char *v217;
  uint64_t v218;
  const char *v219;
  char *v220;
  _BYTE *v221;
  uint64_t v222;
  uint64_t v223;
  header_info **v224;
  uint64_t v225;
  uint64_t v226;
  int v227;
  unint64_t v228;
  char *v229;
  unint64_t v230;
  __int128 v231;
  unsigned int v232;
  header_info **v233;
  unint64_t v234;
  header_info **v235;
  uint64_t v236;
  unint64_t v237[2];
  __int128 v238;
  unint64_t v239;
  unint64_t v240;
  unint64_t size[2];
  uint64_t (*v242)(uint64_t, unint64_t, int, _BYTE *);
  unint64_t *v243;
  unint64_t *v244;
  uint64_t v245;

  v236 = a4;
  v226 = a2;
  v245 = *MEMORY[0x1E0C80C00];
  v225 = a1;
  MEMORY[0x1E0C80A78]();
  v229 = (char *)&v221 - v4;
  v221 = v5;
  *v5 = 0;
  if ((map_images_nolock::firstTime & 1) != 0)
  {
    loadAllCategoriesIfNeeded();
  }
  else
  {
    size[0] = 0;
    shared_cache_range = (objc::SafeRanges *)_dyld_get_shared_cache_range();
    if (shared_cache_range)
    {
      dataSegmentsRanges = (uint64_t)shared_cache_range;
      *(_QWORD *)algn_1ECCE5978 = (char *)shared_cache_range + size[0];
      objc::SafeRanges::add(shared_cache_range, (uint64_t)shared_cache_range + size[0]);
    }
    headerInfoROs = _dyld_for_objc_header_opt_ro();
    objc_debug_headerInfoRWs = _dyld_for_objc_header_opt_rw();
    opt = &_objc_opt_data;
    if (DisablePreopt)
    {
      v7 = "(by OBJC_DISABLE_PREOPTIMIZATION)";
    }
    else if (headerInfoROs)
    {
      v7 = "libobjc is not in the shared cache";
      if (dataSegmentsRanges <= (unint64_t)&_objc_empty_cache
        && *(_QWORD *)algn_1ECCE5978 > (unint64_t)&_objc_empty_cache)
      {
        preoptimized = 1;
        if (PrintPreopt)
          _objc_inform("PREOPTIMIZATION: is ENABLED (version %d)", 16);
        goto LABEL_9;
      }
    }
    else
    {
      v7 = "(dyld shared cache is absent or out of date)";
    }
    preoptimized = 0;
    opt = 0;
    fixed_up_protocol = 1;
    canonical_protocol = 1;
    if (PrintPreopt)
      _objc_inform("PREOPTIMIZATION: is DISABLED %s", v7);
  }
LABEL_9:
  v8 = v225;
  v224 = (header_info **)v225;
  v9 = Object;
  if (PrintImages)
    _objc_inform("IMAGES: processing %u newly-mapped images...\n", v225);
  prog_image_header = _dyld_get_prog_image_header();
  if (v8)
  {
    v14 = (const mach_header_64 *)prog_image_header;
    v232 = 0;
    v222 = 0;
    v234 = 0;
    v15 = 0;
    v228 = *(_QWORD *)algn_1ECCE5978;
    v230 = dataSegmentsRanges;
    v16 = v224;
    v223 = prog_image_header;
    while (1)
    {
      v16 = (header_info **)((char *)v16 - 1);
      v17 = v16;
      v18 = v226 + 32 * v16;
      v19 = *(const mach_header_64 **)v18;
      v20 = *(_QWORD *)(v18 + 16);
      if (headerInfoROs)
      {
        v21 = *(_DWORD *)headerInfoROs;
        if ((*(_DWORD *)headerInfoROs & 0x80000000) == 0)
          break;
      }
LABEL_23:
      magic = v19->magic;
      if (v19->magic + 17958194 >= 2 && magic != -805638658 && magic != -822415874)
        goto LABEL_111;
      v235 = v16;
      size[0] = 0;
      v32 = _dyld_lookup_section_info();
      if (getsegmentdata(v19, "__OBJC", size))
        v33 = 0;
      else
        v33 = v32 == 0;
      if (!v33)
      {
        v34 = (char *)malloc_type_calloc(0x20uLL, 1uLL, 0x28110169uLL);
        v27 = (uint64_t)v34;
        v35 = &addHeader(mach_header_64 const*,char const*,_dyld_section_location_info_s *,int &,int &)::emptyInfo;
        if (v32)
          v35 = (_BYTE *)v32;
        *(_QWORD *)v34 = (char *)v19 - v34;
        *((_QWORD *)v34 + 1) = v35 - (v34 + 8);
        *((_QWORD *)v34 + 2) = v20 - (_QWORD)(v34 + 16);
        PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v34);
        v37 = (_QWORD *)(v27 + 24);
        if (PreoptimizedHeaderRW)
          v37 = (_QWORD *)PreoptimizedHeaderRW;
        *v37 |= 1uLL;
        v38 = 1;
        goto LABEL_46;
      }
LABEL_110:
      v16 = v235;
LABEL_111:
      if (!v17)
        goto LABEL_114;
    }
    v22 = 0;
    v23 = headerInfoROs + 8;
    v24 = *(_DWORD *)(headerInfoROs + 4);
    while (1)
    {
      v25 = v21 + v22;
      if (v21 + v22 < 0 != __OFADD__(v21, v22))
        ++v25;
      v26 = v25 >> 1;
      v27 = v23 + (v24 * v26);
      v28 = (const mach_header_64 *)(*(_QWORD *)v27 + v27);
      if (v19 == v28)
        break;
      if (v19 < v28)
        v21 = v26 - 1;
      else
        v22 = v26 + 1;
      if (v22 > v21)
        goto LABEL_23;
    }
    v39 = getPreoptimizedHeaderRW(v23 + (v24 * v26));
    v40 = (uint64_t *)(v27 + 24);
    if (v39)
      v40 = (uint64_t *)v39;
    v41 = *v40;
    if ((*v40 & 1) != 0)
      goto LABEL_111;
    v235 = v16;
    *v40 = v41 | 1;
    if (PrintPreopt)
    {
      v42 = (const char *)dyld_image_path_containing_address();
      _objc_inform("PREOPTIMIZATION: honoring preoptimized header info at %p for %s", (const void *)v27, v42);
    }
    v38 = 0;
LABEL_46:
    size[0] = 0;
    v43 = header_info::classlist((header_info *)v27, size);
    if (v38)
      v44 = size[0];
    else
      v44 = 0;
    if (!v43)
      v44 = 0;
    LODWORD(v233) = v44;
    if (v43)
      v45 = size[0];
    else
      v45 = 0;
    v46 = getPreoptimizedHeaderRW(v27);
    v47 = (_QWORD *)(v27 + 24);
    if (v46)
      v47 = (_QWORD *)v46;
    *v47 &= 3uLL;
    if (FirstHeader)
    {
      i = LastHeader;
      if (!LastHeader)
      {
        for (i = FirstHeader; ; i = v60 & 0xFFFFFFFFFFFFFFFCLL)
        {
          LastHeader = i;
          v58 = getPreoptimizedHeaderRW(i);
          v59 = (unint64_t *)(i + 24);
          if (v58)
            v59 = (unint64_t *)v58;
          v60 = *v59;
          if (v60 < 4)
            break;
        }
      }
      v49 = getPreoptimizedHeaderRW(i);
      v50 = (_QWORD *)(i + 24);
      if (v49)
        v50 = (_QWORD *)v49;
      *v50 = v27 & 0xFFFFFFFFFFFFFFFCLL | *v50 & 3;
      LastHeader = v27;
    }
    else
    {
      LastHeader = v27;
      FirstHeader = v27;
    }
    v51 = *(_QWORD *)v27 + v27;
    if (v230 > v51 || v228 <= v51)
    {
      v53 = size;
      size[0] = (unint64_t)&unk_1E0DF36B0;
      v243 = size;
      v54 = *(unsigned int *)(v51 + 16);
      if ((_DWORD)v54)
      {
        LODWORD(v231) = v45;
        v55 = v51 + 32;
        v56 = v54;
        v57 = v51 + 32;
        v227 = v15;
        while (*(_DWORD *)v57 != 25 || strncmp((const char *)(v57 + 8), "__TEXT", 0x10uLL))
        {
          v57 += *(unsigned int *)(v57 + 4);
          if (!--v56)
            goto LABEL_79;
        }
        v56 = v51 - *(_QWORD *)(v57 + 24);
LABEL_79:
        for (j = 0; j < v54; ++j)
        {
          if (*(_DWORD *)v55 == 25
            && (!strncmp((const char *)(v55 + 8), "__DATA", 6uLL) || !strncmp((const char *)(v55 + 8), "__AUTH", 6uLL)))
          {
            v237[0] = v55;
            v240 = v56;
            if (!v243)
            {
              std::__throw_bad_function_call[abi:nn180100]();
              __break(1u);
              return;
            }
            (*(void (**)(unint64_t *, unint64_t *, unint64_t *))(*v243 + 48))(v243, v237, &v240);
            v54 = *(unsigned int *)(v51 + 16);
          }
          v55 += *(unsigned int *)(v55 + 4);
        }
        v53 = v243;
        if (v243 == size)
        {
          v53 = size;
          v61 = 4;
          v15 = v227;
          v9 = Object;
          v14 = (const mach_header_64 *)v223;
          v45 = v231;
        }
        else
        {
          v15 = v227;
          v9 = Object;
          v14 = (const mach_header_64 *)v223;
          v45 = v231;
          if (!v243)
            goto LABEL_91;
          v61 = 5;
        }
      }
      else
      {
        v61 = 4;
        v14 = (const mach_header_64 *)v223;
      }
      (*(void (**)(void))(*v53 + 8 * v61))();
    }
LABEL_91:
    *(_OWORD *)size = *(_OWORD *)v18;
    *((_QWORD *)&v63 + 1) = size[1];
    v242 = *(uint64_t (**)(uint64_t, unint64_t, int, _BYTE *))(v18 + 16);
    *(_QWORD *)&v63 = *(_QWORD *)(v18 + 24);
    v231 = v63;
    if (v19 != v14)
    {
LABEL_101:
      v69 = &v229[40 * v232];
      *(_QWORD *)v69 = v27;
      *(_OWORD *)(v69 + 8) = *(_OWORD *)size;
      *((_QWORD *)v69 + 3) = v242;
      *((_QWORD *)v69 + 4) = v231;
      if (HIDWORD(v9[31].vtable))
      {
        v70 = (const char *)dyld_image_path_containing_address();
        v71 = " (bundle)";
        if (v19->filetype != 8)
          v71 = "";
        v72 = " (has class properties)";
        if ((*(_DWORD *)(*(_QWORD *)(v27 + 8) + v27 + 8 + 4) & 0x40) == 0)
          v72 = "";
        v73 = " (preoptimized)";
        if ((*(_DWORD *)(*(_QWORD *)(v27 + 8) + v27 + 8 + 4) & 8) == 0)
          v73 = "";
        _objc_inform("IMAGES: loading image for %s%s%s%s\n", v70, v71, v72, v73);
      }
      v15 += (int)v233;
      v234 = (v45 + v234);
      ++v232;
      goto LABEL_110;
    }
    if ((v63 & 1) != 0)
    {
      if ((preoptimized & 1) == 0)
      {
        v68 = *(_QWORD *)v27 + v27;
LABEL_99:
        if (hasSignedClassROPointers(v68))
          map_images_nolock::executableHasClassROSigning = 1;
        goto LABEL_101;
      }
      v237[0] = 0;
      header_info::selrefs((header_info *)v27, v237);
      v64 = v237[0];
      v65 = _dyld_lookup_section_info();
      v67 = v66 >> 4;
      if (!v65)
        v67 = 0;
      v222 += v64 + v67;
    }
    v68 = *(_QWORD *)v27 + v27;
    goto LABEL_99;
  }
  v15 = 0;
  v234 = 0;
  v222 = 0;
  v232 = 0;
LABEL_114:
  if ((map_images_nolock::firstTime & 1) == 0)
  {
    if (PrintPreopt)
      _objc_inform("PREOPTIMIZATION: using dyld selector opt");
    if ((_DWORD)v222)
    {
      v74 = (4 * (int)v222 / 3u + 1) | ((4 * (int)v222 / 3u + 1) >> 1);
      v75 = v74 | (v74 >> 2) | ((v74 | (v74 >> 2)) >> 4);
      dword_1ECCE5718 = (v75 | (v75 >> 8) | ((v75 | (v75 >> 8)) >> 16)) + 1;
      v76 = malloc_type_malloc(8 * dword_1ECCE5718, 0x64B88C75uLL);
      namedSelectors[0] = (int32x2_t)v76;
      unk_1ECCE5710 = 0;
      if (dword_1ECCE5718)
        memset(v76, 255, 8 * dword_1ECCE5718);
    }
    else
    {
      namedSelectors[0] = 0;
      unk_1ECCE5710 = 0;
      dword_1ECCE5718 = 0;
    }
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v78 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr((unsigned int *)&selLock))
    {
      if (!__stxr(v78, (unsigned int *)&selLock))
        goto LABEL_131;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_131:
    SEL_cxx_construct = (uint64_t)__sel_registerName(".cxx_construct", 0, 0);
    SEL_cxx_destruct = (uint64_t)__sel_registerName(".cxx_destruct", 0, 0);
    v80 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v81 = __ldxr((unsigned int *)&selLock);
      if (v81 != v80)
        break;
      if (!__stlxr(0, (unsigned int *)&selLock))
        goto LABEL_136;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
LABEL_136:
    objc::AssociationsManager::_mapStorage = 0;
    qword_1ECCE5490 = 0;
    dword_1ECCE5498 = 0;
    pthread_key_init_np();
    pthread_key_init_np();
    if (DebugScanWeakTables)
    {
      _objc_inform("Starting background scan of weak references.");
      size[0] = 0;
      v82 = pthread_create((pthread_t *)size, 0, (void *(__cdecl *)(void *))weakTableScan, 0);
      v83 = v82;
      if ((_DWORD)v82)
      {
        v217 = strerror(v82);
        _objc_fatal("pthread_create failed with error %d (%s)", v218, v219, v220, v83, v217);
      }
      pthread_detach((pthread_t)size[0]);
    }
    v84 = _dyld_get_prog_image_header();
    if (v84)
    {
      if (*(_DWORD *)(v84 + 4) == 16777228 && (*(_DWORD *)(v84 + 8) & 0xFFFFFF) == 2)
      {
        map_images_nolock::executableIsARM64e = 1;
LABEL_144:
        if (DebugClassRXSigning)
          v85 = map_images_nolock::executableHasClassROSigning;
        else
          v85 = 0;
        if (!v232)
          goto LABEL_360;
        v86 = v232;
        v87 = (_QWORD **)v229;
        while (1)
        {
          if ((hasSignedClassROPointers((unint64_t)*v87 + **v87) & 1) == 0)
          {
            if (objc::disableEnforceClassRXPtrAuth)
            {
              if (!v85)
                goto LABEL_155;
LABEL_154:
              v88 = (const char *)dyld_image_path_containing_address();
              _objc_inform("%s has un-signed class_ro_t pointers, but the main executable was compiled with class_ro_t pointer signing enabled", v88);
              goto LABEL_155;
            }
            *v221 = 1;
            objc::disableEnforceClassRXPtrAuth = 1;
            if (v85)
              goto LABEL_154;
          }
LABEL_155:
          v87 += 5;
          if (!--v86)
            goto LABEL_156;
        }
      }
    }
  }
  if (map_images_nolock::executableIsARM64e == 1)
    goto LABEL_144;
LABEL_156:
  if (!v232)
    goto LABEL_360;
  v239 = 0;
  v227 = _read_images::doneOnce;
  if ((_read_images::doneOnce & 1) == 0)
  {
    _read_images::doneOnce = 1;
    if (DisableTaggedPointers)
    {
      objc_debug_taggedpointer_mask = 0;
      objc_debug_taggedpointer_slot_shift = 0;
      objc_debug_taggedpointer_slot_mask = 0;
      objc_debug_taggedpointer_payload_lshift = 0;
      objc_debug_taggedpointer_payload_rshift = 0;
      objc_debug_taggedpointer_ext_mask = 0;
      objc_debug_taggedpointer_ext_slot_shift = 0;
      objc_debug_taggedpointer_ext_slot_mask = 0;
      objc_debug_taggedpointer_ext_payload_lshift = 0;
      objc_debug_taggedpointer_ext_payload_rshift = 0;
    }
    if (DisableTaggedPointerObfuscation || !dyld_program_sdk_at_least())
    {
      objc_debug_taggedpointer_obfuscator = 0;
    }
    else
    {
      arc4random_buf(&objc_debug_taggedpointer_obfuscator, 8uLL);
      objc_debug_taggedpointer_obfuscator &= 0x3FFFFFFFFFFFFFF8uLL;
      for (k = 6u; k != -1; --k)
      {
        v90 = arc4random_uniform(k + 1);
        v91 = objc_debug_tag60_permutations[k];
        objc_debug_tag60_permutations[k] = objc_debug_tag60_permutations[v90];
        objc_debug_tag60_permutations[v90] = v91;
      }
    }
    if (PrintConnecting)
      _objc_inform("CLASS: found %d classes during launch", v234);
    if (preoptimized)
      v92 = v15;
    else
      v92 = v234;
    *(_OWORD *)v237 = NXStrValueMapPrototype;
    v238 = *(_OWORD *)&off_1E0DF3648;
    gdb_objc_realized_classes = (uint64_t)NXCreateMapTable(v237, 4 * v92 / 3);
  }
  v93 = v232;
  v94 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v95 = *(_DWORD *)(v94 + 24);
  while (!__ldaxr((unsigned int *)&selLock))
  {
    if (!__stxr(v95, (unsigned int *)&selLock))
      goto LABEL_177;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_177:
  v97 = (header_info **)v229;
  v223 = v93;
  v235 = (header_info **)&v229[40 * v93];
  do
  {
    v98 = *v97;
    if (((_BYTE)v97[4] & 1) == 0 || (preoptimized & 1) == 0)
    {
      v99 = *(_DWORD *)((char *)v98 + *(_QWORD *)v98 + 12);
      v100 = header_info::selrefs(v98, &v239);
      v101 = v239;
      _read_images::UnfixedSelectors += v239;
      if (v239)
      {
        v102 = (char **)v100;
        do
        {
          v103 = (char *)__sel_registerName(*v102, 0, v99 == 8);
          if (*v102 != v103)
            *v102 = v103;
          ++v102;
          --v101;
        }
        while (v101);
      }
    }
    v97 += 5;
  }
  while (v97 != v235);
  v104 = *(_DWORD *)(v94 + 24);
  while (1)
  {
    v105 = __ldxr((unsigned int *)&selLock);
    if (v105 != v104)
      break;
    if (!__stlxr(0, (unsigned int *)&selLock))
      goto LABEL_191;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
LABEL_191:
  LODWORD(v234) = dyld_shared_cache_some_image_overridden();
  v106 = 0;
  v107 = 0;
  v108 = (header_info **)v229;
  do
  {
    v109 = *v108;
    v110 = *((_DWORD *)v108 + 8);
    if ((v110 & 1) == 0 || preoptimized != 1)
      goto LABEL_201;
    v111 = v234;
    if ((*((_BYTE *)opt + 4) & 2) == 0)
      v111 = 1;
    v112 = "the image may contain classes with missing weak superclasses";
    if ((v111 & 1) != 0
      || future_named_class_map
      && (v112 = "there are unresolved future classes pending", *(_DWORD *)(future_named_class_map + 8)))
    {
      if (PrintPreopt)
      {
        v113 = (const char *)dyld_image_path_containing_address();
        _objc_inform("PREOPTIMIZATION: reading classes manually from %s because %s", v113, v112);
      }
LABEL_201:
      v114 = header_info::classlist(v109, &v239);
      v115 = v239;
      if (v239)
      {
        v116 = v114;
        v117 = 0;
        v118 = *(_DWORD *)((char *)v109 + *(_QWORD *)v109 + 12);
        v119 = v110 & 1 & preoptimized;
        do
        {
          v120 = *(objc_class **)(v116 + 8 * v117);
          Class = readClass(v120, v118 == 8, v119);
          v122 = Class;
          if ((objc_class *)Class != v120 && Class != 0)
          {
            v106 = malloc_type_realloc(v106, 8 * (v107 + 1), 0x80040B8603338uLL);
            *((_QWORD *)v106 + v107) = v122;
            v115 = v239;
            ++v107;
          }
          ++v117;
        }
        while (v117 < v115);
      }
    }
    v108 += 5;
  }
  while (v108 != v235);
  if (byte_1ECCE4EC8)
  {
    v124 = (header_info **)v229;
    do
    {
      v126 = (unint64_t *)_dyld_lookup_section_info();
      v127 = v232 + ~(-858993459 * ((unint64_t)((char *)v124 - v229) >> 3));
      if (v126)
        v128 = v125 >= 8;
      else
        v128 = 0;
      if (v128)
      {
        v129 = v125 >> 3;
        do
        {
          v130 = remapClass(*v126);
          if (*v126 != v130)
          {
            (*(void (**)(uint64_t, uint64_t))(v236 + 16))(v236, v127);
            *v126 = v130;
          }
          ++v126;
          --v129;
        }
        while (v129);
      }
      v132 = (unint64_t *)_dyld_lookup_section_info();
      if (v132)
        v133 = v131 >> 3;
      else
        v133 = 0;
      if (v133)
      {
        v134 = v133;
        do
        {
          v135 = remapClass(*v132);
          if (*v132 != v135)
          {
            (*(void (**)(uint64_t, uint64_t))(v236 + 16))(v236, v127);
            *v132 = v135;
          }
          ++v132;
          --v134;
        }
        while (v134);
      }
      v124 += 5;
    }
    while (v124 != v235);
    v239 = v133;
  }
  v228 = *(_QWORD *)algn_1ECCE5978;
  v230 = dataSegmentsRanges;
  v233 = (header_info **)v229;
  while (2)
  {
    v136 = protocols();
    if (((_BYTE)v233[4] & 1) != 0)
    {
      v137 = preoptimized;
      if (((v227 | preoptimized ^ 1) & 1) != 0)
        goto LABEL_235;
      if (PrintProtocols)
      {
        v163 = (const char *)dyld_image_path_containing_address();
        _objc_inform("PROTOCOLS: Skipping reading protocols in image: %s", v163);
      }
    }
    else
    {
      v137 = 0;
LABEL_235:
      v138 = *(_DWORD *)((char *)*v233 + *(_QWORD *)*v233 + 12);
      v139 = header_info::protocollist(*v233, &v239);
      v140 = v239;
      if (v239)
      {
        v141 = v139;
        LODWORD(v231) = v232 + ~(-858993459 * ((unint64_t)((char *)v233 - v229) >> 3));
        v142 = NXMapInsert;
        if (v138 == 8)
          v142 = NXMapKeyCopyingInsert;
        v234 = (unint64_t)v142;
        do
        {
          v143 = *(unint64_t **)v141;
          Protocol = (char **)getProtocol(*(const char **)(*(_QWORD *)v141 + 8));
          v145 = Protocol;
          if (Protocol)
          {
            if (Protocol != (char **)v143)
            {
              if (PrintProtocols)
              {
                v146 = (const char *)protocol_t::demangledName(Protocol);
                _objc_inform("PROTOCOLS: protocol at %p is %s  (duplicate of %p)", v143, v146, v145);
              }
              if (v137)
              {
                v147 = canonical_protocol ? 0 : 0x20000000;
                if ((v147 & *((_DWORD *)v145 + 17)) == 0 && !DisablePreopt && (preoptimized & 1) != 0)
                {
                  v240 = 0;
                  size[0] = MEMORY[0x1E0C809B0];
                  size[1] = 3321888768;
                  v242 = __getSharedCachePreoptimizedProtocol_block_invoke;
                  v243 = (unint64_t *)&__block_descriptor_40_e8_32c47_ZTSKZ34getSharedCachePreoptimizedProtocolE3__0_e16_v28__0_v8B16_B20l;
                  v244 = &v240;
                  _dyld_for_each_objc_protocol();
                  if (v240)
                  {
                    v148 = *(_DWORD *)(v240 + 68);
                    v149 = canonical_protocol ? 0 : 0x20000000;
                    if ((v149 & v148) != 0)
                    {
                      if (canonical_protocol)
                        v150 = -1;
                      else
                        v150 = -536870913;
                      *(_DWORD *)(v240 + 68) = v150 & v148;
                    }
                  }
                }
              }
            }
          }
          else if (v137)
          {
            PreoptimizedProtocol = getPreoptimizedProtocol();
            v152 = (char **)PreoptimizedProtocol;
            if (PreoptimizedProtocol)
              v153 = PreoptimizedProtocol == (_QWORD)v143;
            else
              v153 = 1;
            v154 = v153;
            if (v153)
              v155 = v143;
            else
              v155 = (unint64_t *)PreoptimizedProtocol;
            ((void (*)(unint64_t, unint64_t, unint64_t *))v234)(v136, v155[1], v155);
            if (PrintProtocols)
            {
              v156 = (const char *)protocol_t::demangledName((char **)v155);
              _objc_inform("PROTOCOLS: protocol at %p is %s", v155, v156);
              if ((v154 & 1) == 0)
              {
                v157 = (const char *)protocol_t::demangledName(v152);
                _objc_inform("PROTOCOLS: protocol at %p is %s  (duplicate of %p)", v143, v157, v152);
              }
            }
          }
          else
          {
            (*(void (**)(uint64_t, _QWORD))(v236 + 16))(v236, v231);
            if (((unint64_t)Protocol & 0xFFFFFFF000000007) != 0)
              _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v158, v159, v160, Protocol);
            *v143 = (unint64_t)Protocol & 0xFFFFFFFF8;
            if (v230 <= (unint64_t)v143 && v228 > (unint64_t)v143 && (preoptimized & 1) == 0)
            {
              if (fixed_up_protocol)
                v161 = -1073741824;
              else
                v161 = 0x40000000;
              if ((*((_DWORD *)v143 + 17) & 0xC0000000) != v161)
                fixupProtocol((protocol_t *)v143);
              protocol_t::demangledName((char **)v143);
            }
            ((void (*)(unint64_t, unint64_t, unint64_t *))v234)(v136, v143[1], v143);
            if (PrintProtocols)
            {
              v162 = (const char *)protocol_t::demangledName((char **)v143);
              _objc_inform("PROTOCOLS: protocol at %p is %s", v143, v162);
            }
          }
          v141 += 8;
          --v140;
        }
        while (v140);
      }
    }
    v233 += 5;
    if (v233 != v235)
      continue;
    break;
  }
  v164 = v239;
  v165 = (header_info **)v229;
  do
  {
    if ((v227 & 1) != 0 || !preoptimized || (*((_BYTE *)*v165 + *((_QWORD *)*v165 + 1) + 12) & 8) == 0)
    {
      v167 = _dyld_lookup_section_info();
      v164 = v167 ? v166 >> 3 : 0;
      if (v164)
      {
        v168 = 0;
        v169 = v232 + ~(-858993459 * ((unint64_t)((char *)v165 - v229) >> 3));
        do
        {
          v170 = *(_QWORD *)(v167 + 8 * v168);
          if (canonical_protocol)
            v171 = 0;
          else
            v171 = 0x20000000;
          if ((v171 & *(_DWORD *)(v170 + 68)) == 0)
          {
            v172 = getProtocol(*(const char **)(v170 + 8));
            if (v172)
              v170 = v172;
            if (*(_QWORD *)(v167 + 8 * v168) != v170)
            {
              (*(void (**)(uint64_t, uint64_t))(v236 + 16))(v236, v169);
              *(_QWORD *)(v167 + 8 * v168) = v170;
              ++UnfixedProtocolReferences;
            }
          }
          ++v168;
        }
        while (v164 != v168);
      }
    }
    v165 += 5;
  }
  while (v165 != v235);
  v239 = v164;
  if (didInitialAttachCategories == 1)
  {
    v173 = 40 * v223;
    v174 = (header_info **)v229;
    do
    {
      if ((*((_BYTE *)*v174 + *((_QWORD *)*v174 + 1) + 12) & 1) != 0)
        load_categories_nolock(*v174);
      v174 += 5;
      v173 -= 40;
    }
    while (v173);
    v175 = 40 * v223;
    v176 = (header_info **)v229;
    do
    {
      if ((*((_BYTE *)*v176 + *((_QWORD *)*v176 + 1) + 12) & 1) == 0)
        load_categories_nolock(*v176);
      v176 += 5;
      v175 -= 40;
    }
    while (v175);
  }
  v177 = (header_info **)v229;
  do
  {
    v178 = header_info::nlclslist(*v177, &v239);
    v179 = v239;
    if (v239)
    {
      v180 = (unint64_t *)v178;
      do
      {
        v181 = remapClass(*v180);
        v182 = (objc_class *)v181;
        if (v181)
        {
          addClassTableEntry(v181, 1);
          v183 = *((_QWORD *)v182 + 4);
          if ((v183 & 2) != 0)
          {
            v184 = (_QWORD *)(v183 & 0xF00007FFFFFFFF8);
            if (v183 < 0)
            {
              v185 = *(_QWORD *)((v183 & 0xF00007FFFFFFFF8) + 8);
              v184 = (_QWORD *)(v185 & 0xFFFFFFFFFFFFFFFELL);
              if ((v185 & 1) != 0)
                v184 = (_QWORD *)*v184;
            }
            if ((*(_BYTE *)v184 & 0x40) != 0 && v184[9])
            {
              v213 = objc_class::nameForLogging(v182);
              _objc_fatal("Swift class %s with a metadata initializer is not allowed to be non-lazy", v214, v215, v216, v213);
            }
          }
          realizeClassWithoutSwift(v182, 0);
        }
        ++v180;
        --v179;
      }
      while (v179);
    }
    v177 += 5;
  }
  while (v177 != v235);
  if (v106)
  {
    if (v107)
    {
      v186 = (objc_class **)v106;
      do
      {
        v187 = (uint64_t)*v186;
        if ((*((_BYTE *)*v186 + 32) & 2) != 0)
          _objc_fatal("Swift class is not allowed to be future", v11, v12, v13);
        realizeClassWithoutSwift(*v186, 0);
        objc_class::setInstancesRequireRawIsaRecursively(v187, 0);
        ++v186;
        --v107;
      }
      while (v107);
    }
    free(v106);
  }
  if (DebugNonFragileIvars)
    realizeAllClasses();
  if (PrintPreopt)
  {
    v188 = v229;
    do
    {
      v189 = *(_QWORD **)v188;
      v190 = v188;
      v191 = *((_DWORD *)v188 + 8);
      if ((v191 & 1) != 0 && (v192 = "PREOPTIMIZATION: honoring preoptimized selectors in %s", (preoptimized & 1) != 0)
        || (v192 = "PREOPTIMIZATION: IGNORING preoptimized selectors in %s", (*((_BYTE *)v189 + v189[1] + 12) & 8) != 0))
      {
        v193 = dyld_image_path_containing_address();
        _objc_inform(v192, v193);
      }
      v194 = header_info::classlist((header_info *)v189, &v239);
      v195 = v239;
      if (v239)
      {
        v196 = (unint64_t *)v194;
        do
        {
          v197 = remapClass(*v196);
          v201 = (_QWORD *)v197;
          if (v197)
          {
            ++_read_images::PreoptTotalClasses;
            if ((v191 & 1) != 0 && preoptimized == 1)
              ++_read_images::PreoptOptimizedClasses;
            _read_images::$_1::operator()(*(__objc2_class **)(v197 + 32), v198, v199, v200);
            _read_images::$_1::operator()(*(__objc2_class **)((*v201 & 0xFFFFFFFF8) + 0x20), v202, v203, v204);
          }
          ++v196;
          --v195;
        }
        while (v195);
      }
      v188 = v190 + 40;
    }
    while (v190 + 40 != (char *)v235);
    _objc_inform("PREOPTIMIZATION: %zu selector references not pre-optimized", _read_images::UnfixedSelectors);
    if (_read_images::PreoptTotalMethodLists)
      _objc_inform("PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted", _read_images::PreoptOptimizedMethodLists, _read_images::PreoptTotalMethodLists, (double)_read_images::PreoptOptimizedMethodLists* 100.0/ (double)_read_images::PreoptTotalMethodLists);
    else
      _objc_inform("PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted", _read_images::PreoptOptimizedMethodLists, 0, 0.0);
    if (_read_images::PreoptTotalClasses)
      _objc_inform("PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered", _read_images::PreoptOptimizedClasses, _read_images::PreoptTotalClasses, (double)_read_images::PreoptOptimizedClasses* 100.0/ (double)_read_images::PreoptTotalClasses);
    else
      _objc_inform("PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered", _read_images::PreoptOptimizedClasses, 0, 0.0);
    _objc_inform("PREOPTIMIZATION: %zu protocol references not pre-optimized", UnfixedProtocolReferences);
  }
LABEL_360:
  map_images_nolock::firstTime = 1;
  if (loadImageCallbacks[0] >= 5uLL)
    v205 = (uint64_t *)qword_1ECCE56A8;
  else
    v205 = &qword_1ECCE56A8;
  if (loadImageCallbacks[0])
  {
    v206 = &v205[2 * loadImageCallbacks[0]];
    v207 = (_QWORD *)(v226 + 16);
    do
    {
      v208 = *((unsigned __int8 *)v205 + 8);
      if ((v208 - 1) >= 2)
        _objc_fatal("Corrupt load image callback, unknown kind %u, func %p", v11, v12, v13, *((unsigned __int8 *)v205 + 8), *v205);
      if ((_DWORD)v225)
      {
        v209 = (void (*)(uint64_t))*v205;
        v210 = v207;
        v211 = v224;
        do
        {
          v212 = *(v210 - 2);
          if (v208 == 1)
            v209(v212);
          else
            ((void (*)(uint64_t, _QWORD))v209)(v212, *v210);
          v210 += 4;
          v211 = (header_info **)((char *)v211 - 1);
        }
        while (v211);
      }
      v205 += 2;
    }
    while (v205 != v206);
  }
}

void sub_180115DCC(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t getProtocol(const char *a1)
{
  uint64_t (***v2)(_QWORD, const char *);
  unsigned int v3;
  uint64_t PreoptimizedProtocol;
  char *v5;
  char *v6;
  uint64_t (***v7)(_QWORD, char *);
  unsigned int v8;
  uint64_t v10;

  v2 = (uint64_t (***)(_QWORD, const char *))protocols();
  v3 = (**v2)(v2, a1);
  v10 = 0;
  if (_NXMapMemberWithHash((uint64_t)v2, (uint64_t)a1, v3, &v10) == -1)
    PreoptimizedProtocol = 0;
  else
    PreoptimizedProtocol = v10;
  if (!PreoptimizedProtocol)
  {
    PreoptimizedProtocol = getPreoptimizedProtocol();
    if (!PreoptimizedProtocol)
    {
      v5 = copySwiftV1MangledName(a1, 1);
      if (v5)
      {
        v6 = v5;
        v7 = (uint64_t (***)(_QWORD, char *))protocols();
        v8 = (**v7)(v7, v6);
        v10 = 0;
        if (_NXMapMemberWithHash((uint64_t)v7, (uint64_t)v6, v8, &v10) == -1)
          PreoptimizedProtocol = 0;
        else
          PreoptimizedProtocol = v10;
        if (!PreoptimizedProtocol)
          PreoptimizedProtocol = getPreoptimizedProtocol();
        free(v6);
      }
      else
      {
        return 0;
      }
    }
  }
  return PreoptimizedProtocol;
}

objc_class *look_up_class(char *a1)
{
  unint64_t StatusReg;
  unsigned int v3;
  char *ClassExceptSomeSwift;
  objc_class *v6;
  int v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  const char **v11;
  uint64_t v12;
  unsigned int v13;
  _QWORD *v14;
  unsigned int (*v15)(char *, objc_class **);
  unsigned int v16;
  objc_class *v18;

  if (!a1)
    return 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&runtimeLock))
  {
    if (!__stxr(v3, (unsigned int *)&runtimeLock))
      goto LABEL_7;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_7:
  ClassExceptSomeSwift = getClassExceptSomeSwift(a1);
  v6 = (objc_class *)ClassExceptSomeSwift;
  if (!ClassExceptSomeSwift
    || (unint64_t)(*(_QWORD *)ClassExceptSomeSwift - 1) >= 0xF
    && (*(_DWORD *)(*((_QWORD *)ClassExceptSomeSwift + 4) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
  {
    v7 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v8 = __ldxr((unsigned int *)&runtimeLock);
      if (v8 != v7)
        break;
      if (!__stlxr(0, (unsigned int *)&runtimeLock))
      {
        if (ClassExceptSomeSwift)
          return v6;
        goto LABEL_16;
      }
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
    if (v6)
      return v6;
  }
  else
  {
    v6 = realizeClassMaybeSwiftMaybeRelock((objc_class *)ClassExceptSomeSwift, 0);
    if (v6)
      return v6;
  }
LABEL_16:
  v9 = *(unsigned int **)(StatusReg + 320);
  if (!v9)
  {
    v9 = (unsigned int *)malloc_type_malloc(0x48uLL, 0xB4ED9BFAuLL);
    *(_OWORD *)v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    *((_OWORD *)v9 + 2) = 0u;
    *((_OWORD *)v9 + 3) = 0u;
    *((_QWORD *)v9 + 8) = 0;
    *(_QWORD *)(StatusReg + 320) = v9;
  }
  v10 = v9[17];
  if (v10)
  {
    v11 = (const char **)*((_QWORD *)v9 + 7);
    v12 = v9[17];
    while (strcmp(a1, *v11))
    {
      ++v11;
      if (!--v12)
        goto LABEL_22;
    }
    return 0;
  }
LABEL_22:
  if (v10 == v9[16])
  {
    v13 = 2 * v10;
    if (2 * v10 <= 1)
      v13 = 1;
    v9[16] = v13;
    v14 = malloc_type_realloc(*((void **)v9 + 7), 8 * v13, 0x992452D7uLL);
    *((_QWORD *)v9 + 7) = v14;
    v10 = v9[17];
  }
  else
  {
    v14 = (_QWORD *)*((_QWORD *)v9 + 7);
  }
  v9[17] = v10 + 1;
  v14[v10] = a1;
  v18 = 0;
  v15 = (unsigned int (*)(char *, objc_class **))atomic_load((unint64_t *)&GetClassHook);
  if (v15(a1, &v18))
    v6 = v18;
  else
    v6 = 0;
  v16 = v9[17] - 1;
  v9[17] = v16;
  *(_QWORD *)(*((_QWORD *)v9 + 7) + 8 * v16) = 0;
  return v6;
}

char *getClassExceptSomeSwift(char *a1)
{
  char *result;
  char *v3;
  uint64_t Class_impl;

  result = (char *)getClass_impl(a1);
  if (!result)
  {
    result = copySwiftV1MangledName(a1, 0);
    if (result)
    {
      v3 = result;
      Class_impl = getClass_impl(result);
      free(v3);
      return (char *)Class_impl;
    }
  }
  return result;
}

uint64_t _NXMapMemberWithHash(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;

  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_DWORD *)(a1 + 12) & a3;
  v7 = (uint64_t *)(v5 + 16 * v6);
  v8 = *v7;
  if (*v7 != -1)
  {
    if (v8 == a2 || (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, v8, a2))
    {
LABEL_10:
      *a4 = *(_QWORD *)(v5 + 16 * v6 + 8);
      return *v7;
    }
    LODWORD(v11) = v6;
    while (1)
    {
      v11 = *(_DWORD *)(a1 + 12) & (v11 + 1);
      if ((_DWORD)v11 == (_DWORD)v6)
        break;
      v12 = *(_QWORD *)(v5 + 16 * v11);
      if (v12 == -1)
        break;
      if (v12 == a2 || (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, v12, a2))
      {
        v7 = (uint64_t *)(v5 + 16 * v11);
        v6 = v11;
        goto LABEL_10;
      }
    }
  }
  return -1;
}

BOOL _mapStrIsEqual(int a1, char *__s1, char *__s2)
{
  int v3;

  if (__s1 == __s2)
    return 1;
  if (!__s1)
  {
    v3 = *__s2;
    return v3 == 0;
  }
  v3 = *__s1;
  if (!__s2)
    return v3 == 0;
  if (v3 != *__s2)
    return 0;
  return strcmp(__s1, __s2) == 0;
}

unint64_t protocols(void)
{
  _QWORD *v1;
  _OWORD v3[2];

  if (!protocols(void)::protocol_map[0])
  {
    v3[0] = NXStrValueMapPrototype;
    v3[1] = *(_OWORD *)&off_1E0DF3648;
    v1 = NXCreateMapTable(v3, 0x10u);
    while (!protocols(void)::protocol_map[0])
    {
      while (!__ldaxr(protocols(void)::protocol_map))
      {
        if (!__stlxr((unint64_t)v1, protocols(void)::protocol_map))
          return protocols(void)::protocol_map[0];
      }
      __clrex();
    }
    NXFreeMapTable(v1);
  }
  return protocols(void)::protocol_map[0];
}

uint64_t _mapStrHash(uint64_t a1, _BYTE *a2)
{
  int v2;
  unsigned int v3;
  unsigned __int8 *v4;
  int v5;

  if (a2 && (v2 = *a2, *a2))
  {
    v3 = 0;
    v4 = a2 + 4;
    do
    {
      v3 ^= v2;
      if (!*(v4 - 3))
        break;
      v3 ^= *(v4 - 3) << 8;
      if (!*(v4 - 2))
        break;
      v3 ^= *(v4 - 2) << 16;
      if (!*(v4 - 1))
        break;
      v3 ^= *(v4 - 1) << 24;
      v5 = *v4;
      v4 += 4;
      v2 = v5;
    }
    while (v5);
  }
  else
  {
    v3 = 0;
  }
  return v3 + 65521 * ((unsigned __int16)v3 ^ HIWORD(v3));
}

uint64_t getPreoptimizedProtocol()
{
  if (DisablePreopt || preoptimized != 1)
    return 0;
  _dyld_for_each_objc_protocol();
  return 0;
}

uint64_t header_info::classlist(header_info *this, unint64_t *a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  result = _dyld_lookup_section_info();
  v5 = v4 >> 3;
  if (!result)
    v5 = 0;
  *a2 = v5;
  return result;
}

uint64_t header_info::nlclslist(header_info *this, unint64_t *a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  result = _dyld_lookup_section_info();
  v5 = v4 >> 3;
  if (!result)
    v5 = 0;
  *a2 = v5;
  return result;
}

char *copySwiftV1MangledName(const char *a1, int a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  const char *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  char *v10;

  if (!a1)
    return 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  while (1)
  {
    v5 = &a1[v2];
    if (a1[v2] != 46)
      break;
    ++v3;
    v4 = v2;
LABEL_7:
    ++v2;
  }
  if (a1[v2])
    goto LABEL_7;
  v6 = 0;
  if (v3 == 1 && v4 && v4 < v5 - a1 - 1)
  {
    v10 = 0;
    if (v4 == 5 && (*(_DWORD *)a1 == 1718187859 ? (v7 = a1[4] == 116) : (v7 = 0), v7))
    {
      asprintf(&v10, "_Tt%cs%zu%.*s%s");
    }
    else
    {
      v8 = 67;
      if (a2)
        v8 = 80;
      asprintf(&v10, "_Tt%c%zu%.*s%zu%.*s%s", v8, v4);
    }
    return v10;
  }
  return (char *)v6;
}

uint64_t header_info::protocollist(header_info *this, unint64_t *a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  result = _dyld_lookup_section_info();
  v5 = v4 >> 3;
  if (!result)
    v5 = 0;
  *a2 = v5;
  return result;
}

void loadAllCategoriesIfNeeded()
{
  header_info *v0;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v2;

  if ((didInitialAttachCategories & 1) == 0 && didCallDyldNotifyRegister)
  {
    if (PrintImages)
      _objc_inform("IMAGES: performing initial category attach\n");
    v0 = (header_info *)FirstHeader;
    if (FirstHeader)
    {
      do
      {
        load_categories_nolock(v0);
        PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v0);
        v2 = (_QWORD *)((char *)v0 + 24);
        if (PreoptimizedHeaderRW)
          v2 = (_QWORD *)PreoptimizedHeaderRW;
        v0 = (header_info *)(*v2 & 0xFFFFFFFFFFFFFFFCLL);
      }
      while (v0);
    }
    didInitialAttachCategories = 1;
  }
}

void load_categories_nolock(header_info *a1)
{
  header_info *v1;
  _QWORD *v2;
  int v3;
  _BOOL4 v4;
  int v5;
  int v6;
  int v7;
  BOOL v8;
  char *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  const char *v16;
  _QWORD v17[4];
  unint64_t v18;
  BOOL v19;
  char v20;
  header_info *v21;

  v1 = a1;
  v21 = a1;
  v2 = (_QWORD *)((char *)a1 + 8);
  v3 = *(_DWORD *)((char *)a1 + *((_QWORD *)a1 + 1) + 12);
  v4 = DisablePreattachedCategories == 0;
  v5 = v3 & v4;
  v20 = v3 & v4;
  v6 = dyld_shared_cache_some_image_overridden();
  v7 = v6;
  v19 = (*((_BYTE *)v2 + *v2 + 4) & 0x40) != 0;
  v18 = 0;
  v17[0] = &v18;
  v17[1] = &v21;
  v17[2] = &v19;
  v17[3] = &v20;
  if ((didInitialAttachCategories & 1) == 0 && (v5 ? (v8 = v6 == 0) : (v8 = 0), v8))
  {
    if (PrintPreopt)
    {
      v9 = (char *)v1 + *(_QWORD *)v1;
      v10 = (const char *)dyld_image_path_containing_address();
      _objc_inform("PREOPTIMIZATION: IGNORING preoptimized categories in image %p %s", v9, v10);
    }
  }
  else
  {
    if (PrintPreopt)
    {
      v15 = (char *)v1 + *(_QWORD *)v1;
      v16 = (const char *)dyld_image_path_containing_address();
      _objc_inform("PREOPTIMIZATION: SCANNING categories in image %p %s - didInitialAttachCategories=%d hi->info()->dyldCategoriesOptimized()=%d hasRoot=%d", v15, v16, didInitialAttachCategories, *(_DWORD *)((_BYTE *)v21 + *((_QWORD *)v21 + 1) + 12) & 1, v7);
      v1 = v21;
    }
    v11 = header_info::catlist(v1, &v18);
    load_categories_nolock(header_info *)::$_0::operator()((uint64_t)v17, v11);
  }
  v12 = _dyld_lookup_section_info();
  v14 = v13 >> 3;
  if (!v12)
    v14 = 0;
  v18 = v14;
  load_categories_nolock(header_info *)::$_0::operator()((uint64_t)v17, v12);
}

void objc::UnattachedCategories::addForClass(const char **a1, const char **a2, objc_class *this)
{
  char v6;
  uint64_t v7;
  void **v8;
  uint64_t v9;
  _QWORD *v10;
  __int128 v11;
  int v12;
  unsigned int v13;
  char *v14;
  int v15;
  unsigned int v16;
  const char ***v17;
  uint64_t v18;
  char *v19;
  __int128 v20;
  uint64_t v21;

  if (PrintConnecting)
  {
    v18 = 45;
    if ((unint64_t)(*(_QWORD *)this - 1) >= 0xF)
    {
      if ((*(_DWORD *)(*((_QWORD *)this + 4) & 0xF00007FFFFFFFF8) & 1) != 0)
        v18 = 43;
      else
        v18 = 45;
    }
    v19 = objc_class::nameForLogging(this);
    _objc_inform("CLASS: found category %c%s(%s)", v18, v19, *a1);
  }
  v21 = 0;
  v6 = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class const*>((unint64_t)this, &v21);
  v7 = v21;
  if ((v6 & 1) != 0)
  {
    v8 = (void **)(v21 + 8);
    v9 = *(_QWORD *)(v21 + 16);
    if ((v9 & 1) != 0)
    {
      v13 = v9 >> 1;
      v14 = (char *)*v8;
      if (v9 >> 1 == HIDWORD(v9))
      {
        v15 = 1 << (30 - __clz(v13));
        if (v9 < 0x10)
          v15 = 2;
        v16 = v15 + v13;
        *(_QWORD *)(v21 + 16) = *(_QWORD *)(v21 + 16) | ((unint64_t)v16 << 32);
        v14 = (char *)reallocf(v14, 16 * v16);
        *(_QWORD *)(v7 + 8) = v14;
        v9 = *(_QWORD *)(v7 + 16);
      }
      *(_QWORD *)(v7 + 16) = v9 & 0xFFFFFFFF00000001 | (2
                                                        * (((unint64_t)(v9 + 2) >> 1) & 0x7FFFFFFF));
      v17 = (const char ***)&v14[16 * (v9 >> 1)];
      *v17 = a1;
      v17[1] = a2;
    }
    else if (*v8)
    {
      v10 = malloc_type_malloc(0x20uLL, 0x907FE284uLL);
      *(_OWORD *)v10 = *(_OWORD *)v8;
      v10[2] = a1;
      v10[3] = a2;
      *(_QWORD *)(v7 + 8) = v10;
      *(_QWORD *)(v7 + 16) = 0x200000005;
    }
    else
    {
      *(_QWORD *)(v21 + 8) = a1;
      *(_QWORD *)(v7 + 16) = a2;
    }
    return;
  }
  *(_QWORD *)&v11 = a1;
  v12 = dword_1ECCE59C8;
  if (4 * (int)qword_1ECCE59C0 + 4 >= (3 * dword_1ECCE59C8))
  {
    v12 = 2 * dword_1ECCE59C8;
    goto LABEL_28;
  }
  if (dword_1ECCE59C8 + ~(_DWORD)qword_1ECCE59C0 - HIDWORD(qword_1ECCE59C0) <= dword_1ECCE59C8 >> 3)
  {
LABEL_28:
    objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::grow(v12);
    v21 = 0;
    objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class const*>((unint64_t)this, &v21);
    *(_QWORD *)&v11 = a1;
    v7 = v21;
  }
  *((_QWORD *)&v11 + 1) = a2;
  if (*(_QWORD *)v7 == -2)
  {
    qword_1ECCE59C0 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE59C0, (int32x2_t)0xFFFFFFFF00000001);
  }
  else if (*(_QWORD *)v7 == -1)
  {
    LODWORD(qword_1ECCE59C0) = qword_1ECCE59C0 + 1;
  }
  else if ((*(_BYTE *)(v7 + 16) & 1) != 0)
  {
    v20 = v11;
    free(*(void **)(v7 + 8));
    v11 = v20;
  }
  *(_QWORD *)v7 = this;
  *(_OWORD *)(v7 + 8) = v11;
}

uint64_t header_info::catlist(header_info *this, unint64_t *a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  result = _dyld_lookup_section_info();
  v5 = v4 >> 3;
  if (!result)
    v5 = 0;
  *a2 = v5;
  return result;
}

_QWORD *_headerForClass(unint64_t a1)
{
  _QWORD *v1;
  uint64_t v3;
  uint8_t *v4;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v7;
  unint64_t size;

  v1 = (_QWORD *)FirstHeader;
  if (FirstHeader)
  {
LABEL_2:
    v3 = 0;
    while (1)
    {
      size = 0;
      v4 = getsegmentdata((const mach_header_64 *)((char *)v1 + *v1), off_1E0DF4470[v3], &size);
      if (v4)
      {
        if ((unint64_t)v4 <= a1 && (unint64_t)&v4[size] > a1)
          break;
      }
      if (++v3 == 4)
      {
        PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v1);
        v7 = v1 + 3;
        if (PreoptimizedHeaderRW)
          v7 = (_QWORD *)PreoptimizedHeaderRW;
        v1 = (_QWORD *)(*v7 & 0xFFFFFFFFFFFFFFFCLL);
        if (v1)
          goto LABEL_2;
        return v1;
      }
    }
  }
  return v1;
}

uint64_t getPreoptimizedHeaderRW(uint64_t a1)
{
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 8) + a1 + 8 + 4) & 8) == 0)
    return 0;
  if (!headerInfoROs || objc_debug_headerInfoRWs == 0)
    return 0;
  else
    return objc_debug_headerInfoRWs
         + ((uint64_t)(((a1 - headerInfoROs - 8) / (unint64_t)*(unsigned int *)(headerInfoROs + 4)) << 32) >> 29)
         + 8;
}

unint64_t _mapPtrHash(uint64_t a1, unint64_t a2)
{
  return a2 >> 3;
}

char *objc::SafeRanges::add(objc::SafeRanges *this, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  char *result;
  unsigned int v9;
  char *v10;

  v4 = qword_1ECCE5988;
  if ((_DWORD)qword_1ECCE5988 == (HIDWORD(qword_1ECCE5988) & 0x7FFFFFFF))
  {
    v5 = 1 << (29 - __clz(qword_1ECCE5988));
    if (qword_1ECCE5988 >= 0x10)
      v6 = v5;
    else
      v6 = 4;
    v7 = v6 + HIDWORD(qword_1ECCE5988);
    HIDWORD(qword_1ECCE5988) = HIDWORD(qword_1ECCE5988) & 0x80000000 | v7 & 0x7FFFFFFF;
    result = (char *)malloc_type_realloc((void *)qword_1ECCE5980, 16 * (v7 & 0x7FFFFFFF), 0x1000040451B5BE8uLL);
    qword_1ECCE5980 = (uint64_t)result;
    v4 = qword_1ECCE5988;
  }
  else
  {
    result = (char *)qword_1ECCE5980;
  }
  v9 = v4 + 1;
  v10 = &result[16 * v4];
  *(_QWORD *)v10 = this;
  *((_QWORD *)v10 + 1) = a2;
  qword_1ECCE5988 = __PAIR64__(HIDWORD(qword_1ECCE5988), v9) & 0x7FFFFFFFFFFFFFFFLL;
  return result;
}

void _objc_inform(const char *a1, ...)
{
  pid_t v1;
  char *v2;
  char *v3[2];
  va_list va;

  va_start(va, a1);
  v3[0] = 0;
  v2 = 0;
  va_copy((va_list)&v3[1], va);
  vasprintf(v3, a1, va);
  v1 = getpid();
  asprintf(&v2, "objc[%d]: %s\n", v1, v3[0]);
  _objc_syslog(v2);
  free(v2);
  free(v3[0]);
}

uint64_t nonMetaClasses(void)
{
  uint64_t result;
  _QWORD *v1;
  _OWORD v3[2];

  result = nonmeta_class_map[0];
  if (!nonmeta_class_map[0])
  {
    v3[0] = NXPtrValueMapPrototype;
    v3[1] = *(_OWORD *)&off_1E0DF35D8;
    v1 = NXCreateMapTable(v3, 0x20u);
    while (!nonmeta_class_map[0])
    {
      while (!__ldaxr(nonmeta_class_map))
      {
        if (!__stlxr((unint64_t)v1, nonmeta_class_map))
          return nonmeta_class_map[0];
      }
      __clrex();
    }
    NXFreeMapTable(v1);
    return nonmeta_class_map[0];
  }
  return result;
}

ssize_t _objc_syslog(const char *a1)
{
  ssize_t result;
  int v3;
  size_t v4;
  stat v5;

  getpid();
  if (!sandbox_check()
    || (_simple_asl_log(), result = fstat(2, &v5), (result & 0x80000000) == 0)
    && ((v5.st_mode & 0xB000) == 0x8000 || (v3 = v5.st_mode & 0xF000, v3 == 0x2000) || v3 == 4096))
  {
    v4 = strlen(a1);
    return write(2, a1, v4);
  }
  return result;
}

BOOL _mapPtrIsEqual(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2 == a3;
}

_DWORD *NXCreateMapTable(_OWORD *a1, unsigned int a2)
{
  _DWORD *v4;
  NXHashTable *v5;
  _OWORD *v6;
  __int128 v7;
  char v8;
  char v9;
  BOOL v10;
  NXHashTablePrototype v12;

  v4 = malloc_type_malloc(0x18uLL, 0x10E0040A403B16CuLL);
  v5 = (NXHashTable *)prototypes;
  if (!prototypes)
  {
    v12 = *(NXHashTablePrototype *)protoPrototype;
    v5 = NXCreateHashTable(&v12, 0, 0);
    prototypes = (uint64_t)v5;
  }
  if (*(_QWORD *)a1 && *((_QWORD *)a1 + 1) && *((_QWORD *)a1 + 2) && !*((_DWORD *)a1 + 6))
  {
    v6 = NXHashGet(v5, a1);
    if (!v6)
    {
      v6 = malloc_type_malloc(0x20uLL, 0x1080040AA79BA9DuLL);
      v7 = a1[1];
      *v6 = *a1;
      v6[1] = v7;
      NXHashInsert((NXHashTable *)prototypes, v6);
    }
    *(_QWORD *)v4 = v6;
    v4[2] = 0;
    v8 = 1;
    if (a2 >= 2)
    {
      v9 = -1;
      do
      {
        ++v9;
        v10 = a2 > 3;
        a2 >>= 1;
      }
      while (v10);
      v8 = v9 + 2;
    }
    v4[3] = (1 << v8) - 1;
    *((_QWORD *)v4 + 2) = allocBuckets(1 << v8);
  }
  else
  {
    _objc_inform("*** NXCreateMapTable: invalid creation parameters\n");
    return 0;
  }
  return v4;
}

_QWORD *allocBuckets(int a1)
{
  int v1;
  _QWORD *result;
  _QWORD *v3;

  v1 = a1;
  result = (char *)malloc_type_malloc(16 * (a1 + 1), 0xC0040D1025EB5uLL) + 16;
  if (v1)
  {
    v3 = result;
    do
    {
      *v3 = -1;
      v3[1] = 0;
      v3 += 2;
      --v1;
    }
    while (v1);
  }
  return result;
}

void objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::grow(int a1)
{
  uint64_t v1;
  char *v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v1 = dword_1ECCE59C8;
  v2 = (char *)objc::unattachedCategories;
  v3 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
  v5 = v4 | HIWORD(v4);
  if ((v5 + 1) > 4)
    v6 = v5 + 1;
  else
    v6 = 4;
  dword_1ECCE59C8 = v6;
  v7 = malloc_type_malloc(24 * v6, 0x64B88C75uLL);
  objc::unattachedCategories = (uint64_t)v7;
  if (v2)
  {
    qword_1ECCE59C0 = 0;
    if (dword_1ECCE59C8)
    {
      v8 = 24 * dword_1ECCE59C8;
      do
      {
        *v7 = -1;
        v7 += 3;
        v8 -= 24;
      }
      while (v8);
    }
    if ((_DWORD)v1)
    {
      v9 = 24 * v1;
      v10 = v2 + 8;
      do
      {
        v11 = *((_QWORD *)v10 - 1);
        if (v11 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v15 = 0;
          objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class const*>(v11, &v15);
          v12 = v15;
          v13 = *((_QWORD *)v10 - 1);
          *(_QWORD *)(v15 + 8) = 0;
          *(_QWORD *)(v12 + 16) = 0;
          *(_QWORD *)v12 = v13;
          *(_OWORD *)(v12 + 8) = *(_OWORD *)v10;
          *(_QWORD *)v10 = 0;
          *((_QWORD *)v10 + 1) = 0;
          LODWORD(qword_1ECCE59C0) = qword_1ECCE59C0 + 1;
        }
        v10 += 24;
        v9 -= 24;
      }
      while (v9);
    }
    free(v2);
  }
  else
  {
    qword_1ECCE59C0 = 0;
    if (dword_1ECCE59C8)
    {
      v14 = 24 * dword_1ECCE59C8;
      do
      {
        *v7 = -1;
        v7 += 3;
        v14 -= 24;
      }
      while (v14);
    }
  }
}

uint64_t header_info::selrefs(header_info *this, unint64_t *a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  result = _dyld_lookup_section_info();
  v5 = v4 >> 3;
  if (!result)
    v5 = 0;
  *a2 = v5;
  return result;
}

uint64_t NXMapInsert(uint64_t (***a1)(_QWORD), uint64_t a2, uint64_t a3)
{
  unsigned int v6;

  v6 = (**a1)(a1);
  return NXMapInsertWithHash((uint64_t)a1, a2, v6, a3);
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  id v6;
  void *v7;

  if (offset)
  {
    if (*(id *)((char *)self + offset) != newValue)
    {
      v6 = newValue;
      v7 = *(void **)((char *)self + offset);
      *(_QWORD *)((char *)self + offset) = v6;

    }
  }
  else
  {
    object_setClass(self, (Class)newValue);
  }
}

Method class_getClassMethod(Class cls, SEL name)
{
  if (!cls || !name)
    return 0;
  if ((unint64_t)(*(_QWORD *)cls - 1) < 0xF
    || (*(_BYTE *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) & 1) == 0)
  {
    cls = (Class)(*(_QWORD *)cls & 0xFFFFFFFF8);
  }
  return class_getInstanceMethod(cls, name);
}

uint64_t _class_isSwift(uint64_t result)
{
  if (result)
    return (*(unsigned __int8 *)(result + 32) >> 1) & 1;
  return result;
}

id objc_constructInstance(Class cls, void *bytes)
{
  const char *v2;
  char *v3;
  id result;
  __int16 v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;

  result = 0;
  if (cls && bytes)
  {
    v6 = *((_WORD *)cls + 15);
    v7 = (unint64_t)cls & 0xFFFFFFF000000007;
    if ((v6 & 0x2000) != 0)
    {
      if (!v7)
      {
        v9 = (unint64_t)cls & 0xFFFFFFFF8;
LABEL_10:
        *(_QWORD *)bytes = v9;
        result = bytes;
        if ((v6 & 2) != 0)
          return object_cxxConstructFromClass((void (*)(void))bytes, cls, 0);
        return result;
      }
    }
    else if (!v7)
    {
      v8 = 0x21A000000001;
      if ((v6 & 1) != 0)
        v8 = 0x21A000000005;
      v9 = v8 | (unint64_t)cls & 0xFFFFFFFF8;
      goto LABEL_10;
    }
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", (uint64_t)bytes, v2, v3, cls);
  }
  return result;
}

Class class_setSuperclass(Class cls, Class newSuper)
{
  unint64_t StatusReg;
  unsigned int v5;
  uint64_t *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  int v12;
  unsigned int v13;
  _QWORD v15[5];
  _QWORD v16[5];

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v5, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v7 = (uint64_t *)*((_QWORD *)cls + 1);
  removeSubclass(v7[4], cls);
  removeSubclass(*(_QWORD *)((*v7 & 0xFFFFFFFF8) + 0x20), (objc_class *)(*(_QWORD *)cls & 0xFFFFFFFF8));
  *((_QWORD *)cls + 1) = newSuper;
  *(_QWORD *)((*(_QWORD *)cls & 0xFFFFFFFF8) + 8) = *(_QWORD *)newSuper & 0xFFFFFFFF8;
  addSubclass((uint64_t)newSuper, cls);
  addSubclass(*(_QWORD *)newSuper & 0xFFFFFFFF8, (objc_class *)(*(_QWORD *)cls & 0xFFFFFFFF8));
  v8 = MEMORY[0x1E0C809B0];
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3321888768;
  v16[2] = ___ZL13setSuperclassP10objc_classS0__block_invoke;
  v16[3] = &__block_descriptor_33_e8_32c43_ZTSKZL13setSuperclassP10objc_classS0_E3__0_e8_B16__0_8l;
  flushCaches((uint64_t)cls, (uint64_t)"setSuperclass", (const char *)v16, v9);
  v10 = *(_QWORD *)cls & 0xFFFFFFFF8;
  v15[0] = v8;
  v15[1] = 3321888768;
  v15[2] = ___ZL13setSuperclassP10objc_classS0__block_invoke_182;
  v15[3] = &__block_descriptor_33_e8_32c43_ZTSKZL13setSuperclassP10objc_classS0_E3__1_e8_B16__0_8l;
  flushCaches(v10, (uint64_t)"setSuperclass", (const char *)v15, v11);
  v12 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v13 = __ldxr(runtimeLock);
    if (v13 != v12)
      break;
    if (!__stlxr(0, runtimeLock))
      return (Class)v7;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return (Class)v7;
}

void sub_1801176CC(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t removeSubclass(uint64_t result, objc_class *a2)
{
  _QWORD *v2;
  objc_class *v3;
  BOOL v4;
  uint64_t v5;
  BOOL v6;

  ++objc_debug_realized_class_generation_count;
  v2 = (_QWORD *)((result & 0xF00007FFFFFFFF8) + 16);
  v3 = *(objc_class **)((result & 0xF00007FFFFFFFF8) + 0x10);
  if (v3)
    v4 = v3 == a2;
  else
    v4 = 1;
  if (!v4)
  {
    do
    {
      v5 = *((_QWORD *)v3 + 4) & 0xF00007FFFFFFFF8;
      v3 = *(objc_class **)(v5 + 0x18);
      if (v3)
        v6 = v3 == a2;
      else
        v6 = 1;
    }
    while (!v6);
    v2 = (_QWORD *)(v5 + 24);
  }
  *v2 = *(_QWORD *)((*((_QWORD *)a2 + 4) & 0xF00007FFFFFFFF8) + 0x18);
  return result;
}

IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)
{
  unint64_t StatusReg;
  unsigned int v9;
  void (*v11)(void);
  char *v12;
  int v13;
  unsigned int v14;

  if (!cls)
    return 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v9 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v9, runtimeLock))
      goto LABEL_8;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_8:
  if (types)
    v12 = (char *)types;
  else
    v12 = "";
  v11 = (void (*)(void))addMethod(cls, (objc_selector *)name, imp, v12, 1);
  v13 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v14 = __ldxr(runtimeLock);
    if (v14 != v13)
      break;
    if (!__stlxr(0, runtimeLock))
      return v11;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v11;
}

void sub_180117844(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
  unint64_t StatusReg;
  unsigned int v9;
  BOOL v11;
  char *v12;
  int v13;
  unsigned int v14;

  if (!cls)
    return 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v9 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v9, runtimeLock))
      goto LABEL_8;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_8:
  if (types)
    v12 = (char *)types;
  else
    v12 = "";
  v11 = addMethod(cls, (objc_selector *)name, imp, v12, 0) == 0;
  v13 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v14 = __ldxr(runtimeLock);
    if (v14 != v13)
      break;
    if (!__stlxr(0, runtimeLock))
      return v11;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v11;
}

void sub_180117958(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t addMethod(objc_class *a1, objc_selector *a2, void (*a3)(void), char *a4, char a5)
{
  const char *v6;
  uint64_t v10;
  BOOL v11;
  unint64_t MethodNoSuper_nolock;
  method_list_t *v14;
  _QWORD *v15;
  size_t v16;
  const char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;

  v6 = a4;
  if ((unint64_t)(*(_QWORD *)a1 - 1) < 0xF
    || (*(_DWORD *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (v10 = *(unsigned __int16 *)((*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) + 4),
        dword_1ECCE5988 <= v10)
    || (*(_QWORD *)(qword_1ECCE5980 + 16 * v10) <= (unint64_t)a1
      ? (v11 = *(_QWORD *)(qword_1ECCE5980 + 16 * v10 + 8) > (unint64_t)a1)
      : (v11 = 0),
        !v11))
  {
    if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)a1)
      && (dataSegmentsContain(a1, v23, (unsigned int *)a3) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v24, (const char *)a3, a4, a1);
    }
  }
  MethodNoSuper_nolock = getMethodNoSuper_nolock(a1, a2, (const char *)a3, a4);
  if (MethodNoSuper_nolock)
  {
    if ((a5 & 1) != 0)
      return _method_setImplementation(a1, MethodNoSuper_nolock, a3);
    else
      return method_t::imp(MethodNoSuper_nolock, 0);
  }
  else
  {
    v14 = (method_list_t *)malloc_type_calloc(0x20uLL, 1uLL, 0xB48A38ECuLL);
    *(_QWORD *)v14 = 0x10000001BLL;
    v15 = (_QWORD *)(((unint64_t)v14 + 8) & 0xFFFFFFFFFFFFFFFCLL);
    *v15 = a2;
    v16 = strlen(v6) + 1;
    if ((_dyld_is_memory_immutable() & 1) == 0)
    {
      v22 = malloc_type_malloc(v16, 0x3F84A03uLL);
      memcpy(v22, v6, v16);
      v6 = (const char *)v22;
    }
    v15[1] = v6;
    v15[2] = a3;
    addMethods_finish(a1, v14, v17, v18, v19, v20, v21);
    return 0;
  }
}

void list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists(unint64_t *a1, uint64_t a2, const char *a3, char *a4, const char *a5)
{
  uint64_t v6;
  unint64_t *v7;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  _DWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int16 *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unsigned int v33;
  uint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unsigned __int16 *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  BOOL v47;
  _DWORD *v48;

  if ((_DWORD)a3)
  {
    LODWORD(v6) = (_DWORD)a3;
    v7 = (unint64_t *)a2;
    v9 = *a1;
    if ((_DWORD)a4)
    {
      if ((*a1 & 3) == 2 && (v9 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        if (a5)
          _objc_inform("PREOPTIMIZATION: not attaching preoptimized category, class's %s list %p is still original.", a5, (const void *)(v9 & 0xFFFFFFFFFFFFFFFCLL));
        return;
      }
      if (a5)
      {
        _objc_inform("PREOPTIMIZATION: copying preoptimized category, class's %s list has already been copied.", a5);
        v9 = *a1;
      }
    }
    if ((_DWORD)v6 == 1 && v9 <= 3)
    {
      v11 = *v7;
LABEL_13:
      *a1 = v11;
LABEL_39:
      list_array_tt<unsigned long,protocol_list_t,RawPtr>::validate(v11, a2, a3, a4);
      return;
    }
    if (v9 < 4)
    {
      if (v9)
      {
        v12 = 0;
LABEL_32:
        if (v12)
          v23 = v6 + 1;
        else
          v23 = v6;
        v24 = (unint64_t)malloc_type_malloc(8 * v23 + 8, 0x7ABC97A5uLL);
        v11 = v24 | 1;
        *a1 = v24 | 1;
        *(_DWORD *)v24 = v23;
        v25 = v6;
        if (v12)
          *(_QWORD *)(v24 + 8 * v6 + 8) = v12;
        v26 = (_QWORD *)(v24 + 8);
        do
        {
          v27 = *v7++;
          *v26++ = v27;
          --v25;
        }
        while (v25);
        goto LABEL_39;
      }
LABEL_31:
      v12 = v9 & 0xFFFFFFFFFFFFFFFCLL;
      goto LABEL_32;
    }
    v13 = v9 & 3;
    if ((v9 & 3) == 0)
      goto LABEL_31;
    v14 = (unsigned int *)(v9 & 0xFFFFFFFFFFFFFFFCLL);
    if (v13 == 1 && v14)
    {
      v15 = *v14;
      v16 = *v14 + v6;
      v17 = malloc_type_malloc(8 * v16 + 8, 0xB6D94A04uLL);
      v18 = (unint64_t)v17;
      *v17 = v16;
      v19 = v15 - 1;
      if ((int)(v15 - 1) >= 0)
      {
        do
        {
          *(_QWORD *)&v17[2 * (v6 + v19) + 2] = *(_QWORD *)&v14[2 * v19 + 2];
          --v19;
        }
        while (v19 != -1);
      }
      if (v6 <= 1)
        v20 = 1;
      else
        v20 = v6;
      v21 = v17 + 2;
      do
      {
        v22 = *v7++;
        *v21++ = v22;
        --v20;
      }
      while (v20);
      free(v14);
      v11 = v18 | 1;
      goto LABEL_13;
    }
    if (v13 == 2 && v14)
    {
      if (DisablePreattachedCategories)
      {
        v29 = *v14;
        v30 = v14[1];
        v45 = v30 * (unint64_t)v29;
        if ((v45 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v30, v14, *v14);
        v46 = (uint64_t)v14 + v45 + 8;
        v47 = (_DWORD)v30 == 0;
        if ((_DWORD)v30)
          v30 = v30;
        else
          v30 = 0;
        if (v47)
          v28 = (unsigned __int16 *)v46;
        else
          v28 = (unsigned __int16 *)(v46 - v29);
      }
      else
      {
        v28 = (unsigned __int16 *)(v14 + 2);
        v29 = *v14;
        v30 = v14[1];
      }
      v31 = v30 * (unint64_t)v29;
      if ((v31 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v30, v14, v29);
      v32 = (unint64_t)v14 + v31 + 8;
      if ((unint64_t)v28 < v32)
      {
        while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v28 + 8) & 1) == 0)
        {
          v28 = (unsigned __int16 *)((char *)v28 + v29);
          v33 = v29;
          if ((unint64_t)v28 >= v32)
            goto LABEL_50;
        }
      }
      v33 = v29;
LABEL_50:
      v34 = relative_list_list_t<protocol_list_t>::countLists(v14, a2, a3, a4) + v6;
      v35 = (unint64_t)malloc_type_malloc(8 * v34 + 8, 0xA45900CBuLL);
      *(_DWORD *)v35 = v34;
      v36 = (_QWORD *)(v35 + 8);
      if (v6 <= 1)
        v6 = 1;
      else
        v6 = v6;
      v37 = v6;
      do
      {
        v38 = *v7++;
        *v36++ = v38;
        --v37;
      }
      while (v37);
      if (v6 < v34)
      {
        do
        {
          v39 = *(_QWORD *)v28;
          if (a5)
          {
            v48 = (_DWORD *)v35;
            _objc_inform("PREOPTIMIZATION: copying preoptimized %s list %p", a5, (char *)v28 + (v39 >> 16));
            v35 = (unint64_t)v48;
            v39 = *(_QWORD *)v28;
          }
          *(_QWORD *)(v35 + 8 * v6 + 8) = (char *)v28 + (v39 >> 16);
          v41 = *v14;
          v40 = v14[1];
          v42 = v40 * (unint64_t)v41;
          if ((v42 & 0xFFFFFFFF00000000) != 0)
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v40, v14, v41);
          v43 = (unsigned __int16 *)((char *)v28 + v33);
          do
          {
            v28 = v43;
            if (v43 >= (unsigned __int16 *)((char *)v14 + v42 + 8))
              break;
            v44 = *(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v43 + 8);
            v43 = (unsigned __int16 *)((char *)v43 + v33);
          }
          while ((v44 & 1) == 0);
          ++v6;
        }
        while (v6 != v34);
      }
      v11 = v35 | 1;
      goto LABEL_13;
    }
  }
}

uint64_t addMethods_finish(objc_class *a1, method_list_t *a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const char *v12;
  char *v13;
  _QWORD v15[5];
  method_list_t *v16;

  v16 = a2;
  v9 = *((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8;
  v10 = *(_QWORD *)(v9 + 8);
  v11 = v10 & 0xFFFFFFFFFFFFFFFELL;
  if ((v10 & 1) == 0)
    v11 = class_rw_t::extAlloc(v9, v10 & 0xFFFFFFFFFFFFFFFELL, 0);
  if (*((_DWORD *)a2 + 1) >= 2u)
    method_list_t::sortBySELAddress(a2, (uint64_t)a2, a3, a4);
  prepareMethodLists(a1, &v16, 1, 0, 0, (unint64_t)"addMethods_finish", a7);
  if (PrintPreopt)
    v12 = "methods";
  else
    v12 = 0;
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(v11 + 8), (uint64_t)&v16, (const char *)1, 0, v12);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3321888768;
  v15[2] = ___ZL17addMethods_finishP10objc_classP13method_list_t_block_invoke;
  v15[3] = &__block_descriptor_33_e8_32c60_ZTSKZL17addMethods_finishP10objc_classP13method_list_tE3__0_e8_B16__0_8l;
  return flushCaches((uint64_t)a1, (uint64_t)"addMethods_finish", (const char *)v15, v13);
}

uint64_t flushCaches(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t);
  void *v13;
  const char *v14;
  uint64_t v15;

  v10 = MEMORY[0x1E0C809B0];
  v11 = 3221225472;
  v12 = ___ZL11flushCachesP10objc_classPKcU13block_pointerFbS0_E_block_invoke;
  v13 = &unk_1E0DF3AC0;
  v14 = a3;
  v15 = a2;
  if (a1)
    return foreach_realized_class_and_subclass(a1, (uint64_t)&v10);
  v5 = *(_DWORD *)(gdb_objc_realized_classes + 8);
  if (DisablePreopt)
    result = 0;
  else
    result = _dyld_objc_class_count();
  v6 = _firstRealizedClass;
  if (_firstRealizedClass)
  {
    v7 = 16 * (result + v5) + 16;
    do
    {
      if (!--v7)
LABEL_21:
        _objc_fatal("Memory corruption in class list.", a2, a3, a4, v10, v11);
      v8 = v6;
      while (1)
      {
        result = v12((uint64_t)&v10, v8);
        if (!(_DWORD)result || (v9 = *(_QWORD *)((*(_QWORD *)(v8 + 32) & 0xF00007FFFFFFFF8) + 0x10)) == 0)
        {
          while (1)
          {
            v9 = *(_QWORD *)((*(_QWORD *)(v8 + 32) & 0xF00007FFFFFFFF8) + 0x18);
            if (v8 == v6 || v9)
              break;
            v8 = *(_QWORD *)(v8 + 8);
            if (!--v7)
              goto LABEL_21;
          }
          if (v8 == v6)
            break;
        }
        v8 = v9;
        if (!--v7)
          goto LABEL_21;
      }
      v6 = *(_QWORD *)((*(_QWORD *)(v6 + 32) & 0xF00007FFFFFFFF8) + 0x18);
    }
    while (v6);
  }
  return result;
}

uint64_t foreach_realized_class_and_subclass(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  const char *v10;
  char *v11;
  uint64_t v12;

  v4 = *(_DWORD *)(gdb_objc_realized_classes + 8);
  if (DisablePreopt)
    v5 = 0;
  else
    v5 = _dyld_objc_class_count();
  v6 = (16 * (v5 + v4)) | 0xF;
  v7 = a1;
  while (1)
  {
    result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v7);
    if (!(_DWORD)result || (v12 = *(_QWORD *)((*(_QWORD *)(v7 + 32) & 0xF00007FFFFFFFF8) + 0x10)) == 0)
    {
      while (1)
      {
        v12 = *(_QWORD *)((*(_QWORD *)(v7 + 32) & 0xF00007FFFFFFFF8) + 0x18);
        if (v7 == a1 || v12)
          break;
        v7 = *(_QWORD *)(v7 + 8);
        if (!--v6)
          goto LABEL_13;
      }
      if (v7 == a1)
        return result;
    }
    v7 = v12;
    if (!--v6)
LABEL_13:
      _objc_fatal("Memory corruption in class list.", v9, v10, v11);
  }
}

uint64_t ___ZL11flushCachesP10objc_classPKcU13block_pointerFbS0_E_block_invoke(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 32) + 16))())
    cache_t::eraseNolock((cache_t *)(a2 + 16), *(const char **)(a1 + 40));
  return 1;
}

BOOL cache_t::shouldFlush(cache_t *this, objc_selector *a2, void (*a3)(void))
{
  uint64_t v3;
  unint64_t v6;

  if ((*(_QWORD *)this & 1) == 0 && (v3 = *(_QWORD *)((*(_QWORD *)this & 0xFFFFFFFFFFFLL) + 8), v3 < 0))
  {
    if (*((_DWORD *)this + 2))
    {
      __break(1u);
      JUMPOUT(0x1801182F4);
    }
    v6 = *(_QWORD *)((*(_QWORD *)this & 0xFFFFFFFFFFFLL)
                   + 8
                   * ((unsigned __int16)((unint64_t)(a2 - (objc_selector *)&unk_1F25805A8) >> (v3 & 0x1F)) & (unsigned __int16)(v3 >> 5) & 0x7FF)
                   + 0x10);
    if (a2 - (objc_selector *)&unk_1F25805A8 != v6 >> 38)
      return 0;
    return (char *)((char *)this - ((uint64_t)(v6 << 26) >> 24) - 16) == (char *)a3;
  }
  else
  {
    return cache_getImp((uint64_t)this - 16, (unint64_t)a2, 0) == (_QWORD)a3;
  }
}

void cache_t::eraseNolock(cache_t *this, const char *a2)
{
  BOOL v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  BOOL v13;
  const void *v14;
  char *v15;
  uint64_t v16;
  char *v17;
  objc_class *v19;
  const char *v20;
  char *v21;

  if ((*(_QWORD *)this & 1) != 0
    || (*(objc_cache **)this != &_objc_empty_cache ? (v4 = HIWORD(*(_QWORD *)this) == 0) : (v4 = 0), v4))
  {
    if (PrintCaches)
    {
      v19 = (cache_t *)((char *)this - 16);
      if ((*((_WORD *)this + 7) & 4) != 0)
        v20 = "meta";
      else
        v20 = "";
      v21 = objc_class::nameForLogging(v19);
      _objc_inform("CACHES: %sclass %s: dropping and disallowing preopt cache (from %s)", v20, v21, a2);
    }
    atomic_store((unint64_t)&_objc_empty_cache & 0xFFFFFFFFFFFLL, (unint64_t *)this);
    *((_WORD *)this + 6) = 0;
    v8 = (unsigned int *)(*((_QWORD *)this + 2) & 0xF00007FFFFFFFF8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 | 6, v8));
  }
  else if (*((_WORD *)this + 6))
  {
    v5 = (unint64_t)&_objc_empty_cache & 0xFFFFFFFFFFFLL;
    v6 = *(_QWORD *)this;
    if (HIWORD(*(_QWORD *)this))
    {
      v10 = HIWORD(v6);
      v7 = HIWORD(v6) + 1;
      v6 = *(_QWORD *)this;
      if (v10 >= 0x401)
      {
        v11 = 0;
        v12 = v7;
        do
        {
          ++v11;
          v13 = v12 > 3;
          v12 >>= 1;
        }
        while (v13);
        if (v11 >= cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount)
        {
          v14 = (const void *)malloc_type_zone_malloc_with_options_internal();
          v15 = (char *)malloc_type_realloc((void *)cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsList, 8 * (v11 + 1), 0x2004093837F09uLL);
          cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsList = (uint64_t)v15;
          if (cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount < (v11 + 1))
          {
            v16 = ~v11 + cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount;
            v17 = &v15[8 * cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount];
            do
            {
              *(_QWORD *)v17 = v14;
              v17 += 8;
            }
            while (!__CFADD__(v16++, 1));
          }
          cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount = v11 + 1;
          if (PrintCaches)
            _objc_inform("CACHES: new empty buckets at %p (capacity %zu)", v14, v7);
        }
        v5 = *(_QWORD *)(cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsList + 8 * v11);
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
    atomic_store(v5 | ((unint64_t)(v7 - 1) << 48), (unint64_t *)this);
    *((_WORD *)this + 6) = 0;
    cache_t::collect_free(v6 & 0xFFFFFFFFFFFLL, v7);
  }
}

BOOL __method_exchangeImplementations_block_invoke(uint64_t a1, uint64_t a2)
{
  cache_t *v3;

  v3 = (cache_t *)(a2 + 16);
  return cache_t::shouldFlush((cache_t *)(a2 + 16), *(objc_selector **)(a1 + 32), *(void (**)(void))(a1 + 48))
      || cache_t::shouldFlush(v3, *(objc_selector **)(a1 + 40), *(void (**)(void))(a1 + 56));
}

void cache_t::collect_free(uint64_t a1, unsigned int a2)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  if (PrintCaches)
  {
    if (a2 < 2)
    {
      v4 = 0;
LABEL_8:
      --cache_counts[v4];
      goto LABEL_9;
    }
    v5 = -1;
    v6 = a2;
    do
    {
      v7 = v5++;
      v8 = v6 > 3;
      v6 >>= 1;
    }
    while (v8);
    if (v5 <= 0xE)
    {
      v4 = v7 + 2;
      goto LABEL_8;
    }
  }
LABEL_9:
  if ((_garbage_make_room(void)::first & 1) == 0)
  {
    _garbage_make_room(void)::first = 1;
    v10 = malloc_type_malloc(0x400uLL, 0x80040B8603338uLL);
    garbage_refs = (uint64_t)v10;
    v11 = 128;
    goto LABEL_13;
  }
  v9 = garbage_count;
  v10 = (_QWORD *)garbage_refs;
  if (garbage_count == garbage_max)
  {
    v10 = malloc_type_realloc((void *)garbage_refs, 16 * garbage_count, 0x80040B8603338uLL);
    garbage_refs = (uint64_t)v10;
    v11 = 2 * garbage_max;
LABEL_13:
    garbage_max = v11;
    v9 = garbage_count;
  }
  garbage_byte_size += 16 * a2;
  garbage_count = v9 + 1;
  v10[v9] = a1;
  cache_t::collectNolock(0);
}

void cache_t::collectNolock(cache_t *this)
{
  BOOL v1;
  uint64_t v2;
  const void *v3;
  size_t v4;
  size_t v5;
  _QWORD *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;

  if ((unint64_t)garbage_byte_size >> 15)
    v1 = 0;
  else
    v1 = (_DWORD)this == 0;
  if (v1)
    return;
  if ((_DWORD)this)
  {
    while (_collecting_in_critical())
      ;
LABEL_11:
    if (PrintCaches)
      _objc_inform("CACHES: COLLECTING %zu bytes (%zu allocations, %zu collections)", garbage_byte_size, cache_allocations, ++cache_collections);
    v2 = garbage_count;
    if (DebugScribbleCaches)
    {
      if (!garbage_count)
      {
LABEL_23:
        garbage_count = 0;
        garbage_byte_size = 0;
        if (PrintCaches)
        {
          v9 = 0;
          v10 = 0;
          for (i = 0; i != 16; ++i)
          {
            v12 = (int)cache_counts[i];
            if ((_DWORD)v12)
            {
              _objc_inform("CACHES: %4d slots: %4d caches, %6zu bytes", 1 << i, v12, 16 * (int)((_DWORD)v12 << i));
              v10 += v12;
              v9 += 16 * (int)((_DWORD)v12 << i);
            }
          }
          _objc_inform("CACHES:      total: %4zu caches, %6zu bytes", v10, v9);
        }
        return;
      }
      do
      {
        --v2;
        v3 = *(const void **)(garbage_refs + 8 * v2);
        v4 = malloc_size(v3);
        if (v4 >= 0x10)
        {
          v5 = v4 >> 4;
          v6 = v3;
          do
          {
            *v6 = v3;
            v6 += 2;
            --v5;
          }
          while (v5);
        }
      }
      while (v2);
      v2 = garbage_count;
    }
    if (v2)
    {
      v7 = garbage_refs - 8;
      do
      {
        v8 = *(void **)(v7 + 8 * v2);
        *(_QWORD *)(v7 + 8 * v2) = 0;
        free(v8);
        --v2;
      }
      while (v2);
    }
    goto LABEL_23;
  }
  if (!_collecting_in_critical())
    goto LABEL_11;
  if (PrintCaches)
    _objc_inform("CACHES: not collecting; objc_msgSend in progress");
}

unint64_t list_array_tt<unsigned long,protocol_list_t,RawPtr>::validate(unint64_t result, uint64_t a2, const char *a3, char *a4)
{
  unsigned __int16 *v4;
  uint64_t v5;
  unint64_t v6;
  unsigned int *v7;
  _BOOL4 v8;
  uint64_t v9;
  unsigned int *v10;
  unint64_t v11;
  BOOL v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;

  v6 = result & 3;
  v7 = (unsigned int *)(result & 0xFFFFFFFFFFFFFFFCLL);
  v8 = (result & 0xFFFFFFFFFFFFFFFCLL) == 0 || (result & 3) != 0;
  if (!v8)
  {
    v9 = 0;
    v11 = 0;
    v10 = (unsigned int *)(result & 0xFFFFFFFFFFFFFFFCLL);
LABEL_14:
    v12 = !v8;
    v13 = v6 != 2;
    goto LABEL_15;
  }
  if (result >= 4)
  {
    if (v6 == 1 && v7)
    {
      v9 = 0;
      v10 = v7 + 2;
    }
    else
    {
      if (v6 == 2)
        v10 = (unsigned int *)(result & 0xFFFFFFFFFFFFFFFCLL);
      else
        v10 = 0;
      if (v10)
      {
        if (DisablePreattachedCategories)
        {
          v23 = *v10;
          v27 = v10[1];
          v28 = v27 * (unint64_t)v23;
          if ((v28 & 0xFFFFFFFF00000000) != 0)
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v27, v10, v23);
          v29 = (uint64_t)v10 + v28 + 8;
          if ((_DWORD)v27)
            v24 = v27;
          else
            v24 = 0;
          if ((_DWORD)v27)
            v4 = (unsigned __int16 *)(v29 - v23);
          else
            v4 = (unsigned __int16 *)v29;
        }
        else
        {
          v4 = (unsigned __int16 *)(v10 + 2);
          v23 = *v10;
          v24 = v10[1];
        }
        v25 = v24 * (unint64_t)v23;
        if ((v25 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v24, v10, v23);
        v26 = (unint64_t)v10 + v25 + 8;
        if ((unint64_t)v4 < v26)
        {
          while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v4 + 8) & 1) == 0)
          {
            v4 = (unsigned __int16 *)((char *)v4 + v23);
            v5 = v23 | 0x100000000;
            v23 = v5;
            if ((unint64_t)v4 >= v26)
              goto LABEL_46;
          }
        }
        v5 = v23;
LABEL_46:
        v9 = v5;
      }
      else
      {
        v9 = 0;
      }
    }
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  v12 = v6 != 1;
  if (v6 == 1 && v7)
  {
    v11 = (unint64_t)&v7[2 * *v7 + 2];
    goto LABEL_14;
  }
  v11 = 0;
  v13 = v6 != 2;
  if (v6 == 2 && v7)
  {
    v21 = *v7;
    v20 = v7[1];
    v22 = v20 * (unint64_t)v21;
    if ((v22 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v20, result & 0xFFFFFFFFFFFFFFFCLL, v21);
    v13 = 0;
    v5 = (uint64_t)v7 + v22 + 8;
    v11 = result & 0xFFFFFFFFFFFFFFFCLL;
  }
  while (1)
  {
    while (1)
    {
LABEL_15:
      while (!v6)
      {
        v19 = v10 == (unsigned int *)v11;
        v10 = 0;
        if (v19)
          return result;
      }
      if (!v12)
        break;
      if (!v13)
      {
        if (v4 == (unsigned __int16 *)v5)
          return result;
        v14 = *v10;
        v15 = v10[1];
        v16 = v15 * (unint64_t)v14;
        if ((v16 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v16, a3, a4, v15, v10, v14);
        v17 = (unint64_t)v10 + v16 + 8;
        result = (unint64_t)v4 + v9;
        do
        {
          v4 = (unsigned __int16 *)result;
          if (result >= v17)
            break;
          v18 = *(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)result + 8);
          result += v9;
        }
        while ((v18 & 1) == 0);
      }
    }
    if (v10 == (unsigned int *)v11)
      break;
    v10 += 2;
  }
  return result;
}

BOOL ___ZL17addMethods_finishP10objc_classP13method_list_t_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_cache *v2;

  v2 = *(objc_cache **)(a2 + 16);
  if ((v2 & 1) != 0)
    return 0;
  return v2 == &_objc_empty_cache || HIWORD(*(_QWORD *)(a2 + 16)) != 0;
}

BOOL ___ZL25_method_setImplementationP10objc_classP8method_tPFvvE_block_invoke(uint64_t a1, uint64_t a2)
{
  return cache_t::shouldFlush((cache_t *)(a2 + 16), *(objc_selector **)(a1 + 32), *(void (**)(void))(a1 + 40));
}

unint64_t class_rw_t::extAlloc(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  const char *v6;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  method_list_t *v11;
  const char *v12;
  uint64_t v13;
  unint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  const char *v25;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  BOOL v35;
  uint64_t v36;
  _DWORD *v38;
  _DWORD *v39;

  v8 = (unint64_t)malloc_type_calloc(0x30uLL, 1uLL, 0x1ECB51D3uLL);
  *(_DWORD *)(v8 + 40) = ((int)(*(_DWORD *)a2 << 31) >> 31) & 7;
  v9 = *(_QWORD *)(a2 + 32);
  v10 = (unsigned int *)(v9 & 0xFFFFFFFFFFFFFFFELL);
  if ((v9 & 1) != 0)
    v11 = 0;
  else
    v11 = (method_list_t *)(v9 & 0xFFFFFFFFFFFFFFFELL);
  v39 = v11;
  if (v11)
  {
    if (a3)
      v39 = method_list_t::duplicate(v11, v5, v6, v7);
    if (PrintPreopt)
      v12 = "methods";
    else
      v12 = 0;
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(v8 + 8), (uint64_t)&v39, (const char *)1, 0, v12);
    goto LABEL_11;
  }
  if ((v9 & 1) == 0 || !v10)
    goto LABEL_11;
  if (!a3)
  {
    *(_QWORD *)(v8 + 8) = v9 & 0xFFFFFFFFFFFFFFFCLL | 2;
    goto LABEL_11;
  }
  if (DisablePreattachedCategories)
  {
    v18 = *v10;
    v19 = v10[1];
    v33 = v19 * (unint64_t)v18;
    if ((v33 & 0xFFFFFFFF00000000) != 0)
    {
      v36 = *v10;
LABEL_65:
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v5, v6, v7, v19, v10, v36);
    }
    v34 = (uint64_t)v10 + v33 + 8;
    v35 = (_DWORD)v19 == 0;
    if ((_DWORD)v19)
      v19 = v19;
    else
      v19 = 0;
    if (v35)
      v17 = (uint64_t *)v34;
    else
      v17 = (uint64_t *)(v34 - v18);
  }
  else
  {
    v17 = (uint64_t *)(v10 + 2);
    v18 = *v10;
    v19 = v10[1];
  }
  v20 = v19 * (unint64_t)v18;
  if ((v20 & 0xFFFFFFFF00000000) != 0)
  {
    v36 = v18;
    goto LABEL_65;
  }
  v21 = (unint64_t)v10 + v20 + 8;
  if ((unint64_t)v17 < v21)
  {
    while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v17 + 8) & 1) == 0)
    {
      v17 = (uint64_t *)((char *)v17 + v18);
      v22 = v18;
      if ((unint64_t)v17 >= v21)
        goto LABEL_46;
    }
  }
  v22 = v18;
LABEL_46:
  while (v17 != (uint64_t *)v21)
  {
    v38 = 0;
    v38 = method_list_t::duplicate((method_list_t *)((char *)v17 + (*v17 >> 16)), v5, v6, v7);
    if (PrintPreopt)
      v27 = "methods";
    else
      v27 = 0;
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(v8 + 8), (uint64_t)&v38, (const char *)1, 0, v27);
    v29 = *v10;
    v28 = v10[1];
    v30 = v28 * (unint64_t)v29;
    if ((v30 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v5, v6, v7, v28, v10, v29);
    v31 = (uint64_t *)((char *)v17 + v22);
    do
    {
      v17 = v31;
      if (v31 >= (uint64_t *)((char *)v10 + v30 + 8))
        break;
      v32 = *(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v31 + 8);
      v31 = (uint64_t *)((char *)v31 + v22);
    }
    while ((v32 & 1) == 0);
  }
LABEL_11:
  v13 = *(_QWORD *)(a2 + 64);
  if ((v13 & 1) != 0)
    v14 = 0;
  else
    v14 = v13 & 0xFFFFFFFFFFFFFFFELL;
  v39 = (_DWORD *)v14;
  if (v14)
  {
    if (PrintPreopt)
      v15 = "properties";
    else
      v15 = 0;
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(v8 + 16), (uint64_t)&v39, (const char *)1, 0, v15);
    v16 = a1;
  }
  else
  {
    v16 = a1;
    if ((v13 & 1) != 0 && (v13 & 0xFFFFFFFFFFFFFFFELL) != 0)
      *(_QWORD *)(v8 + 16) = v13 & 0xFFFFFFFFFFFFFFFCLL | 2;
  }
  v23 = *(_QWORD *)(a2 + 40);
  if ((v23 & 1) != 0)
    v24 = 0;
  else
    v24 = v23 & 0xFFFFFFFFFFFFFFFELL;
  v39 = (_DWORD *)v24;
  if (v24)
  {
    if (PrintPreopt)
      v25 = "protocols";
    else
      v25 = 0;
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(v8 + 24), (uint64_t)&v39, (const char *)1, 0, v25);
  }
  else if ((v23 & 1) != 0 && (v23 & 0xFFFFFFFFFFFFFFFELL) != 0)
  {
    *(_QWORD *)(v8 + 24) = v23 & 0xFFFFFFFFFFFFFFFCLL | 2;
  }
  *(_QWORD *)v8 = a2;
  atomic_store(v8 | 1, (unint64_t *)(v16 + 8));
  return v8;
}

BOOL ___ZN10objc_class34setDisallowPreoptCachesRecursivelyEPKc_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int *v2;
  unsigned int v3;
  objc_class *v6;
  unsigned int v7;
  const char *v9;
  char *v10;

  v2 = (unsigned int *)(*(_QWORD *)(a2 + 32) & 0xF00007FFFFFFFF8);
  v3 = *v2;
  if ((*v2 & 2) == 0)
  {
    v6 = *(objc_class **)(a1 + 40);
    if ((*(_QWORD *)(a2 + 16) & 1) != 0)
    {
      cache_t::eraseNolock((cache_t *)(a2 + 16), *(const char **)(a1 + 32));
    }
    else
    {
      if (PrintCaches)
      {
        if ((*((_WORD *)v6 + 15) & 4) != 0)
          v9 = "meta";
        else
          v9 = "";
        v10 = objc_class::nameForLogging(v6);
        _objc_inform("CACHES: %sclass %s: disallow preopt cache (from %s)", v9, v10, *(const char **)(a1 + 32));
        v2 = (unsigned int *)(*(_QWORD *)(a2 + 32) & 0xF00007FFFFFFFF8);
      }
      do
        v7 = __ldxr(v2);
      while (__stxr(v7 | 6, v2));
    }
  }
  return (v3 & 2) == 0;
}

BOOL ___ZN10objc_class36setInstancesRequireRawIsaRecursivelyEb_block_invoke(uint64_t a1, objc_class *this)
{
  unsigned __int16 *v2;
  __int16 v3;
  unsigned __int16 v5;
  const char *v7;
  char *v8;
  const char *v9;

  v2 = (unsigned __int16 *)((char *)this + 30);
  v3 = *((_WORD *)this + 15);
  if ((v3 & 0x2000) == 0)
  {
    do
      v5 = __ldxr(v2);
    while (__stxr(v5 | 0x2000, v2));
    if (PrintRawIsa)
    {
      v7 = " (inherited)";
      if (!*(_BYTE *)(a1 + 32) && *(objc_class **)(a1 + 40) == this)
        v7 = "";
      v8 = objc_class::nameForLogging(this);
      if ((*((_WORD *)this + 15) & 4) != 0)
        v9 = " (meta)";
      else
        v9 = "";
      _objc_inform("RAW ISA:  %s%s%s", v8, v9, v7);
    }
  }
  return (v3 & 0x2000) == 0;
}

uint64_t ___ZL13setSuperclassP10objc_classS0__block_invoke()
{
  return 1;
}

uint64_t relative_list_list_t<protocol_list_t>::countLists(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unsigned __int16 *v7;
  unint64_t v8;
  uint64_t result;

  v4 = *a1;
  v5 = a1[1];
  v6 = v5 * (unint64_t)v4;
  if ((v6 & 0xFFFFFFFF00000000) != 0)
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v5, a1, v4);
  v7 = (unsigned __int16 *)(a1 + 2);
  v8 = (unint64_t)a1 + v6 + 8;
  if (DisablePreattachedCategories)
  {
    if (!(_DWORD)v5)
      return 0;
    v7 = (unsigned __int16 *)(v8 - v4);
  }
  for (; (unint64_t)v7 < v8; v7 = (unsigned __int16 *)((char *)v7 + v4))
  {
    if ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v7 + 8) & 1) != 0)
      break;
  }
  if ((unint64_t)v7 >= v8)
    return 0;
  result = 0;
  do
  {
    do
      v7 = (unsigned __int16 *)((char *)v7 + v4);
    while ((unint64_t)v7 < v8 && (*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v7 + 8) & 1) == 0);
    ++result;
  }
  while ((unint64_t)v7 < v8);
  return result;
}

uint64_t ___ZN4objc7Scanner20propagateCustomFlagsEP10objc_classjNS0_11inherited_tE_block_invoke(uint64_t a1, objc_class *this)
{
  int v4;
  uint64_t result;
  int v6;
  unsigned __int16 *v7;
  unsigned __int16 v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int16 *v13;
  unsigned __int16 v14;

  if (*(objc_class **)(a1 + 32) == this)
  {
    v6 = *(_DWORD *)(a1 + 40);
  }
  else
  {
    v4 = *(_DWORD *)(*((_QWORD *)this + 4) & 0xF00007FFFFFFFF8);
    if ((v4 & 1) == 0)
      v4 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)this & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    if ((v4 & 0x20000000) == 0)
      return 0;
    v6 = 1;
  }
  if (*(_BYTE *)(a1 + 44) && (v7 = (unsigned __int16 *)((char *)this + 30), (*((_WORD *)this + 15) & 0x4000) != 0))
  {
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 & 0xBFFF, v7));
    if (PrintCustomAWZ)
      objc::Scanner::printCustom("CUSTOM AWZ", this, v6);
    result = 1;
  }
  else
  {
    result = 0;
  }
  if (*(_BYTE *)(a1 + 45))
  {
    v9 = (unint64_t *)((char *)this + 32);
    if ((*((_BYTE *)this + 32) & 4) != 0)
    {
      v10 = __ldxr(v9);
      v11 = v10 & 0xFFFFFFFFFFFFFFFBLL;
      if (!v10)
        v11 = 0x8000000000000000;
      while (__stlxr(v11, v9))
      {
        v12 = __ldxr(v9);
        if (v12)
          v11 = v12 & 0xFFFFFFFFFFFFFFFBLL;
        else
          v11 = 0x8000000000000000;
      }
      if (PrintCustomRR)
        objc::Scanner::printCustom("CUSTOM RR", this, v6);
      result = 1;
    }
  }
  if (*(_BYTE *)(a1 + 46))
  {
    v13 = (unsigned __int16 *)((char *)this + 30);
    if (*((__int16 *)this + 15) < 0)
    {
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 & 0x7FFF, v13));
      if (PrintCustomCore)
        objc::Scanner::printCustom("CUSTOM Core", this, v6);
      return 1;
    }
  }
  return result;
}

uint64_t _collecting_in_critical(void)
{
  mach_port_t v0;
  ipc_space_t *v1;
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  char *v5;
  uint64_t v6;
  thread_read_t v7;
  BOOL v8;
  unint64_t v9;
  uint64_t *v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  const char *v18;
  char *v19;
  unint64_t i;
  uint64_t v21;
  mach_msg_type_number_t act_listCnt;
  thread_act_array_t act_list;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[64];
  unint64_t v27;

  if ((shouldUseRestartableRanges & 1) != 0)
  {
    act_list = 0;
    act_listCnt = 0;
    v0 = pthread_mach_thread_np(*(pthread_t *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)));
    v1 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    v2 = task_threads(*MEMORY[0x1E0C83DA0], &act_list, &act_listCnt);
    if ((_DWORD)v2)
      _objc_fatal("task_threads failed (result 0x%x)\n", v3, v4, v5, v2);
    if (act_listCnt)
    {
      v6 = 0;
      while (1)
      {
        v7 = act_list[v6];
        if (v7 != v0)
        {
          old_stateCnt = 68;
          if (thread_get_state(v7, 6, old_state, &old_stateCnt))
            v8 = 1;
          else
            v8 = v27 == 1;
          if (v8)
            goto LABEL_21;
          v9 = objc_restartableRanges;
          if (objc_restartableRanges)
            break;
        }
LABEL_16:
        if (++v6 >= (unint64_t)act_listCnt)
        {
          v14 = 0;
          if (!act_listCnt)
            goto LABEL_26;
          goto LABEL_22;
        }
      }
      v10 = &qword_1ECCE41F0;
      while (1)
      {
        v11 = v27 >= v9;
        v12 = v27 - v9;
        if (v12 != 0 && v11 && v12 < *((unsigned __int16 *)v10 - 4))
          break;
        v13 = *v10;
        v10 += 2;
        v9 = v13;
        if (!v13)
          goto LABEL_16;
      }
LABEL_21:
      v14 = 1;
      if (!act_listCnt)
        goto LABEL_26;
LABEL_22:
      for (i = 0; i < act_listCnt; mach_port_deallocate(*v1, act_list[i++]))
        ;
      v21 = 4 * act_listCnt;
    }
    else
    {
      v14 = 0;
LABEL_26:
      v21 = 0;
    }
    MEMORY[0x186DA0570](*v1, act_list, v21);
  }
  else
  {
    v15 = task_restartable_ranges_synchronize();
    v14 = v15;
    if ((_DWORD)v15)
    {
      v16 = mach_error_string(v15);
      _objc_fatal("task_restartable_ranges_synchronize failed (result 0x%x: %s)", v17, v18, v19, v14, v16);
    }
  }
  return v14;
}

uint64_t ___class_setCustomDeallocInitiation_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned __int16 *v2;
  unsigned __int16 v3;

  v2 = (unsigned __int16 *)(a2 + 30);
  do
    v3 = __ldxr(v2);
  while (__stxr(v3 | 0x1000, v2));
  return 1;
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
  os_unfair_lock_s *v8;

  if (atomic)
  {
    v8 = (os_unfair_lock_s *)&StructLocks[16
                                        * (unint64_t)(((dest >> 4) ^ (dest >> 9)) & 7)];
    locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::lockWith((unsigned int *)&StructLocks[16* (unint64_t)(((src >> 4) ^ (src >> 9)) & 7)], &v8->_os_unfair_lock_opaque);
    memmove(dest, src, size);
    locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)&StructLocks[16* (unint64_t)(((src >> 4) ^ (src >> 9)) & 7)], v8);
  }
  else
  {
    memmove(dest, src, size);
  }
}

ptrdiff_t ivar_getOffset(ptrdiff_t v)
{
  if (v)
    return **(int **)v;
  return v;
}

Protocol **__cdecl protocol_copyProtocolList(Protocol *proto, unsigned int *outCount)
{
  unint64_t StatusReg;
  unsigned int v5;
  Protocol **v7;
  Class isa;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t Protocol;
  int v14;
  unsigned int v15;
  unint64_t v17;

  if (!proto)
  {
    v7 = 0;
    if (outCount)
      *outCount = 0;
    return v7;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v5, runtimeLock))
      goto LABEL_9;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_9:
  isa = proto[2].super.isa;
  if (!isa)
  {
    LODWORD(v9) = 0;
LABEL_22:
    v7 = 0;
    if (!outCount)
      goto LABEL_24;
    goto LABEL_23;
  }
  v9 = *(_QWORD *)isa;
  if (!*(_QWORD *)isa)
    goto LABEL_22;
  v17 = StatusReg;
  v7 = (Protocol **)malloc_type_malloc((8 * v9 + 8) & 0x7FFFFFFF8, 0x80040B8603338uLL);
  v10 = 0;
  do
  {
    v11 = *(_QWORD *)((char *)proto[2].super.isa + v10 * 8 + 8);
    if (canonical_protocol)
      v12 = 0;
    else
      v12 = 0x20000000;
    if ((v12 & *(_DWORD *)(v11 + 68)) == 0)
    {
      Protocol = getProtocol(*(const char **)(v11 + 8));
      if (Protocol)
        v11 = Protocol;
    }
    v7[v10++] = (Protocol *)v11;
  }
  while (v9 != v10);
  StatusReg = v17;
  v7[v9] = 0;
  if (outCount)
LABEL_23:
    *outCount = v9;
LABEL_24:
  v14 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v15 = __ldxr(runtimeLock);
    if (v15 != v14)
      break;
    if (!__stlxr(0, runtimeLock))
      return v7;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v7;
}

void sub_1801195F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  unsigned int *v10;
  int v12;
  unsigned int v13;

  v12 = *(_DWORD *)(a10 + 24);
  while (1)
  {
    v13 = __ldxr(v10);
    if (v13 != v12)
      break;
    if (!__stlxr(0, v10))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sel_lookUpByName(char *a1)
{
  uint64_t objc_selector;
  unint64_t StatusReg;
  unsigned int v4;
  BOOL v6;
  int v8;
  unsigned int v9;
  char **v11;

  if (!a1)
    return 0;
  objc_selector = _dyld_get_objc_selector();
  if (!objc_selector)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v4 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr((unsigned int *)&selLock))
    {
      if (!__stxr(v4, (unsigned int *)&selLock))
        goto LABEL_9;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_9:
    v11 = 0;
    v6 = objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>((uint64_t)namedSelectors, a1, &v11);
    if (v11 != (char **)(*(_QWORD *)namedSelectors + 8 * dword_1ECCE5718) && v6)
      objc_selector = (uint64_t)*v11;
    else
      objc_selector = 0;
    v8 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v9 = __ldxr((unsigned int *)&selLock);
      if (v9 != v8)
        break;
      if (!__stlxr(0, (unsigned int *)&selLock))
        return objc_selector;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
  }
  return objc_selector;
}

void sub_18011972C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void fixupMethodList(method_list_t *a1, uint64_t a2, const char *a3, char *a4)
{
  int v4;
  int v6;
  unsigned int v7;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  BOOL v20;
  const void *v21;
  _QWORD *v22;
  int v23;
  unsigned int v24;
  int v25;
  int v26;
  unint64_t StatusReg;
  unint64_t v28;

  if (*((_DWORD *)a1 + 1))
  {
    v4 = (int)a3;
    if ((*(_DWORD *)a1 & 0x80000001) == 0)
    {
      v6 = a2;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v7 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr((unsigned int *)&selLock))
      {
        if (!__stxr(v7, (unsigned int *)&selLock))
          goto LABEL_8;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_8:
      v26 = v4;
      v9 = *(unsigned int *)a1;
      entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd((int *)a1, a2, a3, a4);
      v10 = a2;
      v11 = ((unint64_t)a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | (v9 >> 31);
      if (v11 != a2)
      {
        v12 = 0;
        v13 = (unsigned __int16)v9 & 0xFFFC;
        v14 = *(_QWORD *)algn_1ECCE5978;
        v28 = dataSegmentsRanges;
        while (1)
        {
          v15 = v11 + v12;
          v16 = (v11 + v12) & 3;
          if (v16 && v16 != 2)
          {
            v18 = v15 & 0xFFFFFFFFFFFFFFFCLL;
            v19 = *(int *)(v15 & 0xFFFFFFFFFFFFFFFCLL);
            v20 = v28 <= (v15 & 0xFFFFFFFFFFFFFFFCLL) && v14 > v18;
            v17 = v20 ? (char *)&unk_1F25805A8 + v19 : *(char **)(v18 + v19);
          }
          else
          {
            v17 = *(char **)(v15 & 0xFFFFFFFFFFFFFFFCLL);
          }
          v21 = __sel_registerName(v17, 0, v6);
          if (!v16 || v16 == 2)
            break;
          if (v16 == 1)
          {
            v22 = (_QWORD *)((v15 & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(v15 & 0xFFFFFFFFFFFFFFFCLL));
LABEL_24:
            *v22 = v21;
          }
          v12 += v13;
          if (v11 + v12 == v10)
            goto LABEL_26;
        }
        v22 = (_QWORD *)(v15 & 0xFFFFFFFFFFFFFFFCLL);
        goto LABEL_24;
      }
LABEL_26:
      v23 = *(_DWORD *)(StatusReg + 24);
      v4 = v26;
      while (1)
      {
        v24 = __ldxr((unsigned int *)&selLock);
        if (v24 != v23)
          break;
        if (!__stlxr(0, (unsigned int *)&selLock))
          goto LABEL_31;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
    }
LABEL_31:
    v25 = *(_DWORD *)a1;
    if (v4 && (v25 & 0x8000FFFC) == 0x18)
    {
      method_list_t::sortBySELAddress(a1, a2, a3, a4);
      v25 = *(_DWORD *)a1;
    }
    if ((v25 & 0x80000000) == 0)
      *(_DWORD *)a1 = v25 | 3;
  }
}

void sub_180119948(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  unsigned int *v10;
  int v12;
  unsigned int v13;

  v12 = *(_DWORD *)(a10 + 24);
  while (1)
  {
    v13 = __ldxr(v10);
    if (v13 != v12)
      break;
    if (!__stlxr(0, v10))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

const void *__sel_registerName(char *a1, int a2, int a3)
{
  const void *objc_selector;
  unsigned int v6;
  const void **v8;
  size_t v9;
  void *v10;
  int v11;
  unsigned int v12;
  char *__s;
  const void **v15;
  char v16;

  __s = a1;
  if (!a1)
    return 0;
  objc_selector = (const void *)_dyld_get_objc_selector();
  if (!objc_selector)
  {
    if (a2)
    {
      v6 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
      while (!__ldaxr((unsigned int *)&selLock))
      {
        if (!__stxr(v6, (unsigned int *)&selLock))
          goto LABEL_10;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
    }
LABEL_10:
    objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::try_emplace<objc::detail::DenseSetEmpty&>((uint64_t)&v15, namedSelectors, &__s);
    v8 = v15;
    if (v16)
    {
      objc_selector = __s;
      if (a3)
      {
        v9 = strlen(__s) + 1;
        if ((_dyld_is_memory_immutable() & 1) == 0)
        {
          v10 = malloc_type_malloc(v9, 0x3F84A03uLL);
          memcpy(v10, objc_selector, v9);
          objc_selector = v10;
        }
      }
      *v8 = objc_selector;
      if (!a2)
        return objc_selector;
    }
    else
    {
      objc_selector = *v15;
      if (!a2)
        return objc_selector;
    }
    v11 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    while (1)
    {
      v12 = __ldxr((unsigned int *)&selLock);
      if (v12 != v11)
        break;
      if (!__stlxr(0, (unsigned int *)&selLock))
        return objc_selector;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
  }
  return objc_selector;
}

void sub_180119AD8(_Unwind_Exception *exception_object)
{
  int v1;
  int v3;
  unsigned int v4;

  if (v1)
  {
    v3 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    while (1)
    {
      v4 = __ldxr((unsigned int *)&selLock);
      if (v4 != v3)
        break;
      if (!__stlxr(0, (unsigned int *)&selLock))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
  }
LABEL_7:
  _Unwind_Resume(exception_object);
}

BOOL objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::try_emplace<objc::detail::DenseSetEmpty&>(uint64_t a1, int32x2_t *a2, char **a3)
{
  _BOOL8 result;
  char **v7;
  char v8;
  __int32 v9;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  char **v13;

  v13 = 0;
  result = objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>((uint64_t)a2, *a3, &v13);
  v7 = v13;
  if (result)
  {
    v8 = 0;
    goto LABEL_10;
  }
  v9 = a2[1].i32[0];
  v10 = a2[2].u32[0];
  if (4 * v9 + 4 >= 3 * v10)
  {
    v10 *= 2;
    goto LABEL_12;
  }
  if (v10 + ~v9 - a2[1].i32[1] <= v10 >> 3)
  {
LABEL_12:
    objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::grow((uint64_t)a2, v10);
    v13 = 0;
    objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>((uint64_t)a2, *a3, &v13);
    v7 = v13;
  }
  v11 = *v7;
  result = objc::DenseMapInfo<char const*>::isEqual(*v7, (char *)0xFFFFFFFFFFFFFFFFLL);
  if (result)
  {
    ++a2[1].i32[0];
  }
  else
  {
    result = objc::DenseMapInfo<char const*>::isEqual(v11, (char *)0xFFFFFFFFFFFFFFFELL);
    if (result)
      a2[1] = vadd_s32(a2[1], (int32x2_t)0xFFFFFFFF00000001);
  }
  *v7 = *a3;
  v8 = 1;
LABEL_10:
  v12 = *(_QWORD *)a2 + 8 * a2[2].u32[0];
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = v12;
  *(_BYTE *)(a1 + 16) = v8;
  return result;
}

BOOL objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>(uint64_t a1, char *__s1, char ***a3)
{
  uint64_t v4;
  unsigned int v7;
  _QWORD *v8;
  char *v9;
  unsigned int v10;
  int v11;
  int v12;
  int i;
  unsigned int v14;
  char **v15;
  char *v16;
  _BOOL8 isEqual;
  BOOL v18;
  char **v19;
  unsigned int v21;
  char **v22;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4)
  {
    v7 = 0;
    v8 = *(_QWORD **)a1;
    v9 = __s1;
    do
    {
      v10 = v7;
      v11 = *v9++;
      v7 = 257 * v7 + v11;
    }
    while (v11);
    v22 = 0;
    v12 = v4 - 1;
    for (i = 1; ; i = v21 + 1)
    {
      v21 = i;
      v14 = v10 & v12;
      v15 = (char **)&v8[v10 & v12];
      v16 = *v15;
      isEqual = objc::DenseMapInfo<char const*>::isEqual(__s1, *v15);
      if (isEqual)
        break;
      if (objc::DenseMapInfo<char const*>::isEqual(v16, (char *)0xFFFFFFFFFFFFFFFFLL))
      {
        if (v22)
          v15 = v22;
        break;
      }
      if (v21 > v4)
        objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, v8, v4);
      v18 = objc::DenseMapInfo<char const*>::isEqual(v16, (char *)0xFFFFFFFFFFFFFFFELL);
      v19 = v22;
      if (v18 && v22 == 0)
        v19 = (char **)&v8[v14];
      v22 = v19;
      v10 = v14 + v21;
    }
  }
  else
  {
    v15 = 0;
    isEqual = 0;
  }
  *a3 = v15;
  return isEqual;
}

BOOL objc::DenseMapInfo<char const*>::isEqual(char *__s1, char *a2)
{
  _BOOL8 result;

  if (__s1 == a2)
    return 1;
  result = 0;
  if (a2 != (char *)-2 && __s1 != (char *)-2 && __s1 != (char *)-1 && a2 != (char *)-1)
    return strcmp(__s1, a2) == 0;
  return result;
}

void method_list_t::sortBySELAddress(method_list_t *this, uint64_t a2, const char *a3, char *a4)
{
  __n128 *v4;
  __n128 v5;
  uint64_t v6;
  __n128 *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  void *v11;
  BOOL v12;
  void *v13;

  if ((*(_DWORD *)this & 0x80000000) != 0)
    _objc_fatal("Cannot sort small method list %p", a2, a3, a4, this);
  v4 = (__n128 *)(((unint64_t)this + 8) & 0xFFFFFFFFFFFFFFFCLL);
  entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd((int *)this, a2, a3, a4);
  v7 = (__n128 *)(v6 & 0xFFFFFFFFFFFFFFFCLL);
  v8 = (v6 & 0xFFFFFFFFFFFFFFFCLL) - (_QWORD)v4;
  v9 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
  if (v8 < 3073)
  {
LABEL_6:
    std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v4, v7, v9, 0, 0, v5);
  }
  else
  {
    v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    while (1)
    {
      v11 = malloc_type_malloc(24 * v10, 0xECB36C86uLL);
      if (v11)
        break;
      v12 = v10 > 1;
      v10 >>= 1;
      if (!v12)
        goto LABEL_6;
    }
    v13 = v11;
    std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v4, v7, v9, (uint64_t)v11, v10, v5);
    free(v13);
  }
}

__n128 std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(__n128 *a1, __n128 *a2, unint64_t a3, uint64_t a4, uint64_t a5, __n128 result)
{
  __n128 *v7;
  __n128 *v8;
  unint64_t v9;
  unint64_t v10;
  __int8 *v12;
  uint64_t v13;
  __n128 *v14;
  __n128 *v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v21;
  unint64_t v22;
  __n128 *v23;
  unint64_t v24;
  __n128 v25;
  uint64_t v26;
  __n128 *v27;
  __n128 *v28;
  unint64_t v29;
  __n128 *v30;
  uint64_t v31;
  __n128 *v32;
  __n128 v33;

  if (a3 >= 2)
  {
    v7 = a1;
    if (a3 == 2)
    {
      v8 = (__n128 *)((char *)a2 - 24);
      if (a2[-2].n128_u64[1] < a1->n128_u64[0])
      {
        v9 = a1[1].n128_u64[0];
        result = *a1;
        v10 = a2[-1].n128_u64[1];
        *a1 = *v8;
        a1[1].n128_u64[0] = v10;
        *v8 = result;
        a2[-1].n128_u64[1] = v9;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      v21 = a4;
      v22 = a3 >> 1;
      v23 = (__n128 *)((char *)a1 + 24 * (a3 >> 1));
      v24 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        v25 = std::__stable_sort_move<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(a1, v23, v24, a4, result);
        v26 = v21 + 24 * v22;
        result.n128_u64[0] = std::__stable_sort_move<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>((__n128 *)((char *)v7 + 24 * (a3 >> 1)), a2, a3 - (a3 >> 1), v26, v25).n128_u64[0];
        v27 = (__n128 *)(v21 + 24 * a3);
        v28 = (__n128 *)v26;
        while (v28 != v27)
        {
          if (v28->n128_u64[0] >= *(_QWORD *)v21)
          {
            result = *(__n128 *)v21;
            v7[1].n128_u64[0] = *(_QWORD *)(v21 + 16);
            *v7 = result;
            v21 += 24;
          }
          else
          {
            result = *v28;
            v7[1].n128_u64[0] = v28[1].n128_u64[0];
            *v7 = result;
            v28 = (__n128 *)((char *)v28 + 24);
          }
          v7 = (__n128 *)((char *)v7 + 24);
          if (v21 == v26)
          {
            if (v28 != v27)
            {
              v29 = 0;
              do
              {
                v30 = (__n128 *)((char *)v7 + v29);
                result = *(__n128 *)((char *)v28 + v29);
                v30[1].n128_u64[0] = v28[1].n128_u64[v29 / 8];
                *v30 = result;
                v29 += 24;
              }
              while ((__n128 *)((char *)v28 + v29) != v27);
            }
            return result;
          }
        }
        if (v21 != v26)
        {
          v31 = 0;
          do
          {
            v32 = (__n128 *)((char *)v7 + v31);
            result = *(__n128 *)(v21 + v31);
            v32[1].n128_u64[0] = *(_QWORD *)(v21 + v31 + 16);
            *v32 = result;
            v31 += 24;
          }
          while (v21 + v31 != v26);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(a1, v23, v24, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>((char *)v7 + 24 * (a3 >> 1), a2, a3 - (a3 >> 1), v21, a5);
        std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>((char *)v7, (char *)v7 + 24 * (a3 >> 1), (char *)a2, a3 >> 1, a3 - (a3 >> 1), (char *)v21, a5);
      }
    }
    else if (a1 != a2)
    {
      v12 = &a1[1].n128_i8[8];
      if (&a1[1].n128_i8[8] != (__int8 *)a2)
      {
        v13 = 0;
        v14 = a1;
        do
        {
          v15 = (__n128 *)v12;
          v16 = v14[1].n128_u64[1];
          if (v16 < v14->n128_u64[0])
          {
            v33 = v14[2];
            v17 = v13;
            while (1)
            {
              v18 = (char *)a1 + v17;
              *(__n128 *)(v18 + 24) = *(__n128 *)((char *)a1 + v17);
              *((_QWORD *)v18 + 5) = *(unint64_t *)((char *)a1[1].n128_u64 + v17);
              if (!v17)
                break;
              v17 -= 24;
              if (v16 >= *((_QWORD *)v18 - 3))
              {
                v19 = (uint64_t)&a1[1].n128_i64[1] + v17;
                goto LABEL_15;
              }
            }
            v19 = (uint64_t)a1;
LABEL_15:
            *(_QWORD *)v19 = v16;
            result = v33;
            *(__n128 *)(v19 + 8) = v33;
          }
          v12 = &v15[1].n128_i8[8];
          v13 += 24;
          v14 = v15;
        }
        while (&v15[1].n128_i8[8] != (__int8 *)a2);
      }
    }
  }
  return result;
}

__n128 std::__stable_sort_move<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(__n128 *a1, __n128 *a2, unint64_t a3, uint64_t a4, __n128 result)
{
  __n128 *v5;
  __n128 *v8;
  __n128 *v9;
  __n128 v10;
  unint64_t v11;
  __n128 *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  __n128 v19;
  __n128 *v20;
  __n128 *v21;
  unint64_t v22;
  __n128 *v23;
  unint64_t v24;
  __n128 *v25;

  if (a3)
  {
    v5 = (__n128 *)a4;
    v8 = a1;
    if (a3 == 2)
    {
      v9 = (__n128 *)((char *)a2 - 24);
      if (a2[-2].n128_u64[1] >= a1->n128_u64[0])
      {
        v19 = *a1;
        *(_QWORD *)(a4 + 16) = a1[1].n128_u64[0];
        *(__n128 *)a4 = v19;
        result = *v9;
        v11 = a2[-1].n128_u64[1];
      }
      else
      {
        v10 = *v9;
        *(_QWORD *)(a4 + 16) = a2[-1].n128_u64[1];
        *(__n128 *)a4 = v10;
        result = *a1;
        v11 = a1[1].n128_u64[0];
      }
      *(_QWORD *)(a4 + 40) = v11;
      *(__n128 *)(a4 + 24) = result;
    }
    else if (a3 == 1)
    {
      result = *a1;
      *(_QWORD *)(a4 + 16) = a1[1].n128_u64[0];
      *(__n128 *)a4 = result;
    }
    else if ((uint64_t)a3 > 8)
    {
      v20 = (__n128 *)((char *)a1 + 24 * (a3 >> 1));
      std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(a1, v20, a3 >> 1, a4, a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>((char *)v8 + 24 * (a3 >> 1), a2, a3 - (a3 >> 1), (char *)v5 + 24 * (a3 >> 1), a3 - (a3 >> 1));
      v21 = (__n128 *)((char *)v8 + 24 * (a3 >> 1));
      while (v21 != a2)
      {
        if (v21->n128_u64[0] >= v8->n128_u64[0])
        {
          result = *v8;
          v5[1].n128_u64[0] = v8[1].n128_u64[0];
          *v5 = result;
          v8 = (__n128 *)((char *)v8 + 24);
        }
        else
        {
          result = *v21;
          v5[1].n128_u64[0] = v21[1].n128_u64[0];
          *v5 = result;
          v21 = (__n128 *)((char *)v21 + 24);
        }
        v5 = (__n128 *)((char *)v5 + 24);
        if (v8 == v20)
        {
          if (v21 != a2)
          {
            v22 = 0;
            do
            {
              v23 = (__n128 *)((char *)v5 + v22);
              result = *(__n128 *)((char *)v21 + v22);
              v23[1].n128_u64[0] = v21[1].n128_u64[v22 / 8];
              *v23 = result;
              v22 += 24;
            }
            while ((__n128 *)((char *)v21 + v22) != a2);
          }
          return result;
        }
      }
      if (v8 != v20)
      {
        v24 = 0;
        do
        {
          v25 = (__n128 *)((char *)v5 + v24);
          result = *(__n128 *)((char *)v8 + v24);
          v25[1].n128_u64[0] = v8[1].n128_u64[v24 / 8];
          *v25 = result;
          v24 += 24;
        }
        while ((__n128 *)((char *)v8 + v24) != v20);
      }
    }
    else if (a1 != a2)
    {
      result = *a1;
      *(_QWORD *)(a4 + 16) = a1[1].n128_u64[0];
      *(__n128 *)a4 = result;
      v12 = (__n128 *)((char *)a1 + 24);
      if (&a1[1].n128_i8[8] != (__int8 *)a2)
      {
        v13 = 0;
        v14 = (_QWORD *)a4;
        do
        {
          v15 = v14;
          v16 = *v14;
          v14 += 3;
          v17 = v14;
          if (v12->n128_u64[0] < v16)
          {
            *(_OWORD *)v14 = *(_OWORD *)v15;
            v14[2] = v15[2];
            v17 = (_QWORD *)a4;
            if (v15 != (_QWORD *)a4)
            {
              v18 = v13;
              while (1)
              {
                v17 = (_QWORD *)(a4 + v18);
                if (v12->n128_u64[0] >= *(_QWORD *)(a4 + v18 - 24))
                  break;
                *(_OWORD *)v17 = *(_OWORD *)(a4 + v18 - 24);
                v17[2] = *(_QWORD *)(a4 + v18 - 8);
                v18 -= 24;
                if (!v18)
                {
                  v17 = (_QWORD *)a4;
                  break;
                }
              }
            }
          }
          result = *v12;
          v17[2] = v12[1].n128_u64[0];
          *(__n128 *)v17 = result;
          v12 = (__n128 *)((char *)v12 + 24);
          v13 += 24;
        }
        while (v12 != a2);
      }
    }
  }
  return result;
}

void objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  char **v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  char **v12;
  char *v13;
  uint64_t v14;
  char **v15;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(char ***)a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4)
    v8 = v7 + 1;
  else
    v8 = 4;
  *(_DWORD *)(a1 + 16) = v8;
  v9 = malloc_type_malloc(8 * v8, 0x64B88C75uLL);
  *(_QWORD *)a1 = v9;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
      memset(v9, 255, 8 * v10);
    if ((_DWORD)v3)
    {
      v11 = 8 * v3;
      v12 = v4;
      do
      {
        v13 = *v12;
        if (!objc::DenseMapInfo<char const*>::isEqual(*v12, (char *)0xFFFFFFFFFFFFFFFFLL)
          && !objc::DenseMapInfo<char const*>::isEqual(v13, (char *)0xFFFFFFFFFFFFFFFELL))
        {
          v15 = 0;
          objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>(a1, v13, &v15);
          *v15 = *v12;
          ++*(_DWORD *)(a1 + 8);
        }
        ++v12;
        v11 -= 8;
      }
      while (v11);
    }
    free(v4);
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    v14 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v14)
      memset(v9, 255, 8 * v14);
  }
}

const char *__cdecl method_getTypeEncoding(const char *m)
{
  uint64_t v1;

  if (m)
    return (const char *)method_t::types((unint64_t)m, v1);
  return m;
}

objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)
{
  const char **Property_nolock;
  _BOOL8 v6;
  _BOOL8 v7;
  unint64_t StatusReg;
  unsigned int v10;
  int v12;
  unsigned int v13;

  Property_nolock = 0;
  if (proto && name)
  {
    v6 = isInstanceProperty;
    v7 = isRequiredProperty;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v10 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v10, runtimeLock))
        goto LABEL_8;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_8:
    Property_nolock = protocol_getProperty_nolock((protocol_t *)proto, name, (const char *)v7, (char *)v6);
    v12 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v13 = __ldxr(runtimeLock);
      if (v13 != v12)
        break;
      if (!__stlxr(0, runtimeLock))
        return (objc_property_t)Property_nolock;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return (objc_property_t)Property_nolock;
}

void sub_18011A618(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

const char **protocol_getProperty_nolock(protocol_t *a1, const char *a2, const char *a3, char *a4)
{
  BOOL v4;
  unsigned int **v7;
  unsigned int *v8;
  const char **v9;
  uint64_t v10;
  const char **v11;
  const char **v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t Protocol;
  uint64_t Property_nolock;

  if (!(_DWORD)a3)
    return 0;
  v4 = (char)a4;
  if ((_DWORD)a4)
  {
    v7 = (unsigned int **)((char *)a1 + 56);
  }
  else
  {
    v7 = (unsigned int **)((char *)a1 + 88);
    if ((char *)a1 + *((unsigned int *)a1 + 16) <= (char *)a1 + 88)
      goto LABEL_10;
  }
  v8 = *v7;
  if (!*v7
    || (v9 = (const char **)(v8 + 2),
        v10 = *v8,
        entsize_list_tt<property_t,property_list_t,0u,PointerModifierNop>::end(v8, (uint64_t)a2, a3, a4),
        v9 == v11))
  {
LABEL_10:
    v13 = (unint64_t *)*((_QWORD *)a1 + 2);
    if (v13 && *v13)
    {
      v14 = 0;
      while (1)
      {
        v15 = v13[v14 + 1];
        v16 = canonical_protocol ? 0 : 0x20000000;
        if ((v16 & *(_DWORD *)(v15 + 68)) == 0)
        {
          Protocol = getProtocol(*(const char **)(v15 + 8));
          if (Protocol)
            v15 = Protocol;
        }
        Property_nolock = protocol_getProperty_nolock((protocol_t *)v15, a2, 1, v4);
        if (Property_nolock)
          break;
        ++v14;
        v13 = (unint64_t *)*((_QWORD *)a1 + 2);
        if (v14 >= *v13)
          return 0;
      }
      return (const char **)Property_nolock;
    }
    return 0;
  }
  v12 = v11;
  while (strcmp(a2, *v9))
  {
    v9 = (const char **)((char *)v9 + v10);
    if (v9 == v12)
      goto LABEL_10;
  }
  return v9;
}

objc_property_t *__cdecl protocol_copyPropertyList2(Protocol *proto, unsigned int *outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
{
  _BOOL4 v5;
  unint64_t StatusReg;
  unsigned int v8;
  Protocol *v10;
  objc_property_t *v11;
  unsigned int *isa;
  unsigned int v13;
  objc_property *v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  char *v18;
  unsigned int *v19;
  int v20;
  int v21;
  unsigned int v22;

  if (!proto || !isRequiredProperty)
  {
    v11 = 0;
    if (outCount)
      *outCount = 0;
    return v11;
  }
  v5 = isInstanceProperty;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v8 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v8, runtimeLock))
    {
      if (isInstanceProperty)
        goto LABEL_7;
LABEL_11:
      v10 = proto + 11;
      if ((Protocol *)((char *)proto + LODWORD(proto[8].super.isa)) > &proto[11])
        goto LABEL_12;
      goto LABEL_18;
    }
  }
  __clrex();
  os_unfair_lock_lock_with_options();
  if (!v5)
    goto LABEL_11;
LABEL_7:
  v10 = proto + 7;
LABEL_12:
  isa = (unsigned int *)v10->super.isa;
  if (!v10->super.isa)
  {
LABEL_18:
    v13 = 0;
LABEL_19:
    v11 = 0;
    if (!outCount)
      goto LABEL_21;
    goto LABEL_20;
  }
  v13 = isa[1];
  if (!v13)
    goto LABEL_19;
  v11 = (objc_property_t *)malloc_type_malloc(8 * (v13 + 1), 0x2004093837F09uLL);
  v14 = (objc_property *)(isa + 2);
  v15 = *isa;
  entsize_list_tt<property_t,property_list_t,0u,PointerModifierNop>::end(isa, v16, v17, v18);
  if (isa + 2 == v19)
  {
    v13 = 0;
  }
  else
  {
    v20 = 0;
    do
    {
      v13 = v20 + 1;
      v11[v20] = v14;
      v14 = (objc_property *)((char *)v14 + v15);
      ++v20;
    }
    while (v14 != (objc_property *)v19);
  }
  v11[v13] = 0;
  if (outCount)
LABEL_20:
    *outCount = v13;
LABEL_21:
  v21 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v22 = __ldxr(runtimeLock);
    if (v22 != v21)
      break;
    if (!__stlxr(0, runtimeLock))
      return v11;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v11;
}

void sub_18011A8D8(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

objc_property_t *__cdecl class_copyPropertyList(Class cls, unsigned int *outCount)
{
  char *v2;
  unint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  unint64_t StatusReg;
  unsigned int v9;
  objc_property_t *v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  BOOL v19;
  _BOOL4 v20;
  uint64_t v21;
  unsigned int *v22;
  uint64_t v23;
  BOOL v24;
  char v25;
  unint64_t v26;
  unsigned int *v27;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  const char *v40;
  char *v41;
  const char *v42;
  char *v43;
  unsigned int i;
  _BOOL4 v45;
  uint64_t v46;
  const char *v47;
  char *v48;
  uint64_t v49;
  int v50;
  unsigned int v51;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  BOOL v57;
  _QWORD v58[12];
  uint64_t *v59[12];
  unint64_t v60;

  if (!cls)
  {
    v11 = 0;
    if (outCount)
      *outCount = 0;
    return v11;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v9 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v9, runtimeLock))
      goto LABEL_9;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_9:
  if ((unint64_t)(*(_QWORD *)cls - 1) < 0xF
    || (*(_DWORD *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (v12 = *(unsigned __int16 *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
        dword_1ECCE5988 <= v12)
    || (*(_QWORD *)(qword_1ECCE5980 + 16 * v12) <= (unint64_t)cls
      ? (v13 = *(_QWORD *)(qword_1ECCE5980 + 16 * v12 + 8) > (unint64_t)cls)
      : (v13 = 0),
        !v13))
  {
    if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)cls)
      && (dataSegmentsContain(cls, v54, (unsigned int *)v2) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v55, v2, (char *)v3, cls);
    }
  }
  v14 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
  v15 = v14 & 0xFFFFFFFFFFFFFFFELL;
  if ((v14 & 1) != 0)
  {
    v17 = *(_QWORD *)(v15 + 16);
  }
  else
  {
    v60 = 0;
    v16 = *(_QWORD *)(v15 + 64);
    v17 = v16 & 0xFFFFFFFFFFFFFFFELL;
    if ((v16 & 1) != 0 || !v17)
    {
      v18 = v16 & 1;
      if (v17)
        v19 = v18 == 0;
      else
        v19 = 1;
      if (v19)
      {
        v20 = 0;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v24 = 1;
        v25 = 1;
        goto LABEL_54;
      }
      v17 |= 2uLL;
    }
  }
  v60 = v17;
  v26 = v17 & 3;
  v20 = v26 != 0;
  v27 = (unsigned int *)(v17 & 0xFFFFFFFFFFFFFFFCLL);
  v5 = (v17 & 0xFFFFFFFFFFFFFFFCLL) == 0 || (v17 & 3) != 0;
  if ((_DWORD)v5 != 1)
  {
    v21 = 0;
    v23 = 0;
    v22 = (unsigned int *)(v17 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_53:
    v25 = v5 ^ 1;
    v24 = v26 != 2;
    goto LABEL_54;
  }
  if (v17 >= 4)
  {
    if (v26 != 1 || v27 == 0)
    {
      if (v26 == 2)
        v22 = (unsigned int *)(v17 & 0xFFFFFFFFFFFFFFFCLL);
      else
        v22 = 0;
      if (v22)
      {
        if (DisablePreattachedCategories)
        {
          v30 = *v22;
          v29 = v22[1];
          v56 = v29 * (unint64_t)v30;
          if ((v56 & 0xFFFFFFFF00000000) != 0)
            goto LABEL_103;
          v4 = (uint64_t *)((char *)v22 + v56 + 8);
          v57 = (_DWORD)v29 == 0;
          if ((_DWORD)v29)
            v29 = v29;
          else
            v29 = 0;
          if (!v57)
            v4 = (uint64_t *)((char *)v4 - v30);
        }
        else
        {
          v4 = (uint64_t *)(v22 + 2);
          v30 = *v22;
          v29 = v22[1];
        }
        v31 = v29 * (unint64_t)v30;
        if ((v31 & 0xFFFFFFFF00000000) != 0)
          goto LABEL_103;
        v32 = (unint64_t)v22 + v31 + 8;
        if ((unint64_t)v4 < v32)
        {
          while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v4 + 8) & 1) == 0)
          {
            v4 = (uint64_t *)((char *)v4 + v30);
            v33 = v30;
            if ((unint64_t)v4 >= v32)
              goto LABEL_90;
          }
        }
        v33 = v30;
LABEL_90:
        v21 = v33;
      }
      else
      {
        v21 = 0;
      }
    }
    else
    {
      v21 = 0;
      v22 = v27 + 2;
    }
  }
  else
  {
    v21 = 0;
    v22 = 0;
  }
  v25 = v26 != 1;
  if (v26 == 1 && v27)
  {
    v23 = (uint64_t)&v27[2 * *v27 + 2];
    goto LABEL_53;
  }
  v23 = 0;
  v19 = v26 == 2;
  v24 = v26 != 2;
  if (v19 && v27)
  {
    v30 = *v27;
    v29 = v27[1];
    v53 = v29 * (unint64_t)v30;
    if ((v53 & 0xFFFFFFFF00000000) != 0)
    {
      v22 = v27;
      goto LABEL_103;
    }
    v24 = 0;
    v5 = (uint64_t)v27 + v53 + 8;
    v23 = (uint64_t)v27;
  }
LABEL_54:
  v34 = 0;
  if (v20)
    goto LABEL_57;
LABEL_55:
  if (v22 != (unsigned int *)v23)
  {
    v35 = v22[1];
    v22 = 0;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          v34 += v35;
          if (!v20)
            goto LABEL_55;
LABEL_57:
          if ((v25 & 1) != 0)
            break;
          if (v22 == (unsigned int *)v23)
            goto LABEL_70;
          v36 = *(_QWORD *)v22;
          v22 += 2;
          v35 = *(_DWORD *)(v36 + 4);
        }
        if (!v24)
          break;
        v35 = MEMORY[4];
      }
      if (v4 == (uint64_t *)v5)
        goto LABEL_70;
      v2 = (char *)*v22;
      v29 = v22[1];
      v3 = v29 * (unint64_t)v2;
      if ((v3 & 0xFFFFFFFF00000000) != 0)
        break;
      v35 = *(_DWORD *)((char *)v4 + (*v4 >> 16) + 4);
      v37 = (unint64_t)v22 + v3 + 8;
      v38 = (uint64_t *)((char *)v4 + v21);
      do
      {
        v4 = v38;
        if ((unint64_t)v38 >= v37)
          break;
        v39 = *(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v38 + 8);
        v38 = (uint64_t *)((char *)v38 + v21);
      }
      while ((v39 & 1) == 0);
    }
    v30 = *v22;
LABEL_103:
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v29, v2, (char *)v3, v29, v22, v30);
  }
LABEL_70:
  if (v34)
  {
    v11 = (objc_property_t *)malloc_type_malloc(8 * (v34 + 1), 0x2004093837F09uLL);
    list_array_tt<property_t,property_list_t,RawPtr>::begin((uint64_t)v59, &v60, v40, v41);
    list_array_tt<property_t,property_list_t,RawPtr>::end((uint64_t)v58, &v60, v42, v43);
    for (i = 0; ; ++i)
    {
      v45 = list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v59, v58);
      v49 = i;
      if (v45)
        break;
      v11[v49] = (objc_property_t)v59[9];
      list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator++(v59, v46, v47, v48);
    }
    v11[i] = 0;
    if (outCount)
      goto LABEL_75;
  }
  else
  {
    v11 = 0;
    i = 0;
    if (outCount)
LABEL_75:
      *outCount = i;
  }
  v50 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v51 = __ldxr(runtimeLock);
    if (v51 != v50)
      break;
    if (!__stlxr(0, runtimeLock))
      return v11;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v11;
}

void sub_18011AD7C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

objc_property_t class_getProperty(Class cls, const char *name)
{
  char *v2;
  char *v3;
  objc_property *v4;
  Class v6;
  unint64_t StatusReg;
  unsigned int v8;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  BOOL v17;
  const char *v18;
  char *v19;
  uint64_t v20;
  const char *v21;
  char *v22;
  int v23;
  unsigned int v24;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[12];
  uint64_t *v29[9];
  const char **v30;
  unint64_t v31;

  v4 = 0;
  if (!cls || !name)
    return v4;
  v6 = cls;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v8 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v8, runtimeLock))
      goto LABEL_8;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_8:
  if ((unint64_t)(*(_QWORD *)v6 - 1) < 0xF
    || (*(_DWORD *)(*((_QWORD *)v6 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (v10 = *(unsigned __int16 *)((*((_QWORD *)v6 + 4) & 0xF00007FFFFFFFF8) + 4),
        qword_1ECCE5988 <= v10)
    || (*(_QWORD *)(qword_1ECCE5980 + 16 * v10) <= (unint64_t)v6
      ? (v11 = *(_QWORD *)(qword_1ECCE5980 + 16 * v10 + 8) > (unint64_t)v6)
      : (v11 = 0),
        !v11))
  {
    if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)v6)
      && (dataSegmentsContain(v6, v26, (unsigned int *)v2) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v27, v2, v3, v6);
    }
  }
  do
  {
    v12 = *(_QWORD *)((*((_QWORD *)v6 + 4) & 0xF00007FFFFFFFF8) + 8);
    v13 = v12 & 0xFFFFFFFFFFFFFFFELL;
    if ((v12 & 1) != 0)
    {
      v15 = *(_QWORD *)(v13 + 16);
    }
    else
    {
      v31 = 0;
      v14 = *(_QWORD *)(v13 + 64);
      v15 = v14 & 0xFFFFFFFFFFFFFFFELL;
      if ((v14 & 1) != 0 || !v15)
      {
        v16 = v14 & 1;
        if (v15)
          v17 = v16 == 0;
        else
          v17 = 1;
        if (v17)
          goto LABEL_26;
        v15 |= 2uLL;
      }
    }
    v31 = v15;
LABEL_26:
    list_array_tt<property_t,property_list_t,RawPtr>::begin((uint64_t)v29, &v31, v2, v3);
    list_array_tt<property_t,property_list_t,RawPtr>::end((uint64_t)v28, &v31, v18, v19);
    while (!list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v29, v28))
    {
      v4 = (objc_property *)v30;
      if (!strcmp(name, *v30))
        goto LABEL_32;
      list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator++(v29, v20, v21, v22);
    }
    v6 = (Class)*((_QWORD *)v6 + 1);
  }
  while (v6);
  v4 = 0;
LABEL_32:
  v23 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v24 = __ldxr(runtimeLock);
    if (v24 != v23)
      break;
    if (!__stlxr(0, runtimeLock))
      return v4;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v4;
}

void sub_18011AFB8(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

BOOL list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_QWORD **)a1;
  if (*(_QWORD *)a1 != *a2)
    return 0;
  v3 = *v2 & 3;
  if (v3 == 2)
  {
    v4 = *(_QWORD *)(a1 + 24);
    v5 = a2[3];
  }
  else
  {
    if (v3 > 1)
      return 0;
    v4 = *(_QWORD *)(a1 + 8);
    v5 = a2[1];
  }
  if (v4 != v5)
    return 0;
  if (v2 == *(_QWORD **)(a1 + 32)
    && (v3 == 2
      ? (v7 = *(_QWORD *)(a1 + 24), v8 = *(_QWORD *)(a1 + 56))
      : (v7 = *(_QWORD *)(a1 + 8), v8 = *(_QWORD *)(a1 + 40)),
        v7 == v8))
  {
    return 1;
  }
  else
  {
    return *(_QWORD *)(a1 + 72) == a2[9];
  }
}

uint64_t **list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator++(uint64_t **a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  const char *v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  unsigned int *v24;
  uint64_t *v25;
  unsigned int **v26;
  uint64_t v27;
  unsigned int *v28;
  uint64_t v29;
  const char *v30;
  char *v31;
  uint64_t v33;
  uint64_t v34;

  v5 = a1[8];
  v6 = (uint64_t *)((char *)a1[9] + v5);
  a1[9] = v6;
  *((_DWORD *)a1 + 17) = HIDWORD(v5) + 1;
  if (v6 != a1[11])
    return a1;
  v7 = *a1;
  v8 = **a1;
  if ((v8 & 3) == 1)
  {
    ++a1[1];
    v8 = *v7;
  }
  else if ((v8 & 3) == 0)
  {
    a1[1] = 0;
  }
  if ((v8 & 3) == 2)
  {
    v9 = a1[3];
    v10 = *((unsigned int *)a1 + 4);
    v11 = *((_DWORD *)a1 + 5);
    a1[3] = (uint64_t *)((char *)v9 + v10);
    v12 = (unsigned int *)a1[1];
    v14 = *v12;
    v13 = v12[1];
    v15 = v13 * (unint64_t)v14;
    *((_DWORD *)a1 + 5) = v11 + 1;
    if ((v15 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v13, v12, v14);
    v16 = (unint64_t)v12 + v15 + 8;
    if ((unint64_t)v9 + v10 < v16)
    {
      v17 = objc_debug_headerInfoRWs;
      v18 = v11 + 2;
      do
      {
        if ((*(_QWORD *)(v17 + 8 * *(unsigned __int16 *)((char *)v9 + v10) + 8) & 1) != 0)
          break;
        a1[3] = (uint64_t *)((char *)v9 + 2 * v10);
        *((_DWORD *)a1 + 5) = v18++;
        v9 = (uint64_t *)((char *)v9 + v10);
      }
      while ((unint64_t)v9 + v10 < v16);
    }
  }
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists(a1);
  v22 = *a1;
  v23 = **a1 & 3;
  if (*a1 == a1[4])
  {
    if (v23 != 2)
    {
      if (v23 != 1)
      {
        if (!v23)
        {
          v24 = (unsigned int *)a1[1];
          if (v24 == (unsigned int *)a1[5])
            return a1;
          goto LABEL_29;
        }
LABEL_22:
        v24 = 0;
        goto LABEL_29;
      }
      v26 = (unsigned int **)a1[1];
      if (v26 == (unsigned int **)a1[5])
        return a1;
      goto LABEL_28;
    }
    v25 = a1[3];
    if (v25 == a1[7])
      return a1;
LABEL_26:
    v24 = (unsigned int *)((char *)v25 + (*v25 >> 16));
    goto LABEL_29;
  }
  if (v23 == 2)
  {
    v25 = a1[3];
    goto LABEL_26;
  }
  if (v23 != 1)
  {
    if (!v23)
    {
      v24 = (unsigned int *)a1[1];
      goto LABEL_29;
    }
    goto LABEL_22;
  }
  v26 = (unsigned int **)a1[1];
LABEL_28:
  v24 = *v26;
LABEL_29:
  a1[8] = (uint64_t *)*v24;
  a1[9] = (uint64_t *)(v24 + 2);
  v27 = *v22 & 3;
  if (v27 == 2)
  {
    v28 = (unsigned int *)((char *)a1[3] + (*a1[3] >> 16));
  }
  else if (v27 == 1)
  {
    v28 = (unsigned int *)*a1[1];
  }
  else if (v27)
  {
    v28 = 0;
  }
  else
  {
    v28 = (unsigned int *)a1[1];
  }
  a1[10] = (uint64_t *)entsize_list_tt<property_t,property_list_t,0u,PointerModifierNop>::end(v28, v19, v20, v21);
  a1[11] = (uint64_t *)v29;
  if (a1[9] == (uint64_t *)v29)
  {
    v33 = **a1 & 3;
    if (v33 == 2)
    {
      v34 = (uint64_t)a1[3] + (*a1[3] >> 16);
    }
    else if (v33 == 1)
    {
      v34 = *a1[1];
    }
    else if (v33)
    {
      v34 = 0;
    }
    else
    {
      v34 = (uint64_t)a1[1];
    }
    _objc_fatal("Assertion failed: (%s) - empty list %p encountered during iteration", v29, v30, v31, "m != mEnd", v34);
  }
  return a1;
}

uint64_t list_array_tt<property_t,property_list_t,RawPtr>::begin(uint64_t a1, _QWORD *a2, const char *a3, char *a4)
{
  uint64_t v4;
  unsigned int *v5;
  BOOL v6;
  unsigned __int16 *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t i;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  BOOL v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  unint64_t v32;
  unsigned __int16 *v33;

  v30 = a2;
  v4 = *a2 & 3;
  v5 = (unsigned int *)(*a2 & 0xFFFFFFFFFFFFFFFCLL);
  if (v4)
    v6 = 1;
  else
    v6 = v5 == 0;
  if (!v6)
  {
    v31 = *a2 & 0xFFFFFFFFFFFFFFFCLL;
    v26 = a2;
LABEL_9:
    v27 = 0;
    return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v30, (uint64_t)&v26, a4);
  }
  if (*a2 > 3uLL)
  {
    if (v4 == 1 && v5 != 0)
    {
      v31 = (unint64_t)(v5 + 2);
      v26 = a2;
      goto LABEL_26;
    }
    if (v4 == 2 && v5 != 0)
    {
      if (DisablePreattachedCategories)
      {
        v12 = *v5;
        v20 = v5[1];
        v21 = v20 * (unint64_t)v12;
        if ((v21 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v20, *a2 & 0xFFFFFFFFFFFFFFFCLL, v12);
        v22 = v12 | (v20 << 32);
        v23 = (uint64_t)v5 + v21 + 8;
        v24 = v12 | ((unint64_t)(v20 - 1) << 32);
        v25 = (_DWORD)v20 == 0;
        if ((_DWORD)v20)
          v10 = v20;
        else
          v10 = 0;
        if ((_DWORD)v20)
          v9 = (unsigned __int16 *)(v23 - v12);
        else
          v9 = (unsigned __int16 *)v23;
        if (v25)
          v11 = v22;
        else
          v11 = v24;
      }
      else
      {
        v9 = (unsigned __int16 *)(v5 + 2);
        v11 = *v5;
        v10 = v5[1];
        v12 = v11;
      }
      v13 = v10 * (unint64_t)v12;
      if ((v13 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v10, *a2 & 0xFFFFFFFFFFFFFFFCLL, v12);
      v14 = HIDWORD(v11);
      for (i = (unint64_t)v5 + v13 + 8; (unint64_t)v9 < i; v14 = (v14 + 1))
      {
        if ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v9 + 8) & 1) != 0)
          break;
        v9 = (unsigned __int16 *)((char *)v9 + v11);
      }
      v31 = *a2 & 0xFFFFFFFFFFFFFFFCLL;
      v32 = v11 | (v14 << 32);
      v33 = v9;
    }
  }
  else
  {
    v31 = 0;
  }
  v26 = a2;
  if (!v4)
    goto LABEL_9;
LABEL_26:
  if (v4 == 1 && v5)
  {
    v27 = (uint64_t)&v5[2 * *v5 + 2];
  }
  else if (v4 == 2 && v5)
  {
    v17 = *v5;
    v16 = v5[1];
    v18 = v16 * (unint64_t)v17;
    if ((v18 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v16, v5, v17);
    v27 = (uint64_t)v5;
    v28 = v17 | (v16 << 32);
    v29 = (uint64_t)v5 + v18 + 8;
  }
  return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v30, (uint64_t)&v26, a4);
}

uint64_t list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  _QWORD *v5;
  unint64_t v6;
  __int128 v7;
  _QWORD *v8;
  unint64_t v9;
  __int128 v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t *v13;
  unsigned int **v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;

  v5 = *(_QWORD **)a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  v6 = *v5 & 3;
  if (v6 == 2)
  {
    v7 = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v7;
  }
  else if (v6 <= 1)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  }
  v8 = *(_QWORD **)a3;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)a3;
  v9 = *v8 & 3;
  if (v9 == 2)
  {
    v10 = *(_OWORD *)(a3 + 8);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a3 + 24);
    *(_OWORD *)(a1 + 40) = v10;
  }
  else if (v9 <= 1)
  {
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a3 + 8);
  }
  v11 = **(_QWORD **)a2 & 3;
  if (*(_QWORD *)a2 == *(_QWORD *)a3)
  {
    if (v11 != 2)
    {
      if (v11 != 1)
      {
        if (!v11)
        {
          v12 = *(unsigned int **)(a2 + 8);
          if (v12 == *(unsigned int **)(a3 + 8))
            goto LABEL_34;
          goto LABEL_26;
        }
        goto LABEL_19;
      }
      v14 = *(unsigned int ***)(a2 + 8);
      if (v14 == *(unsigned int ***)(a3 + 8))
        goto LABEL_34;
LABEL_25:
      v12 = *v14;
      goto LABEL_26;
    }
    v13 = *(uint64_t **)(a2 + 24);
    if (v13 == *(uint64_t **)(a3 + 24))
      goto LABEL_34;
LABEL_23:
    v12 = (unsigned int *)((char *)v13 + (*v13 >> 16));
    goto LABEL_26;
  }
  if (v11 == 2)
  {
    v13 = *(uint64_t **)(a2 + 24);
    goto LABEL_23;
  }
  if (v11 == 1)
  {
    v14 = *(unsigned int ***)(a2 + 8);
    goto LABEL_25;
  }
  if (v11)
  {
LABEL_19:
    v12 = 0;
    goto LABEL_26;
  }
  v12 = *(unsigned int **)(a2 + 8);
LABEL_26:
  *(_QWORD *)(a1 + 64) = *v12;
  *(_QWORD *)(a1 + 72) = v12 + 2;
  v15 = **(_QWORD **)a2 & 3;
  if (v15 == 2)
  {
    v16 = (unsigned int *)(*(_QWORD *)(a2 + 24) + (**(uint64_t **)(a2 + 24) >> 16));
  }
  else if (v15 == 1)
  {
    v16 = **(unsigned int ***)(a2 + 8);
  }
  else if (v15)
  {
    v16 = 0;
  }
  else
  {
    v16 = *(unsigned int **)(a2 + 8);
  }
  *(_QWORD *)(a1 + 80) = entsize_list_tt<property_t,property_list_t,0u,PointerModifierNop>::end(v16, a2, (const char *)a3, a4);
  *(_QWORD *)(a1 + 88) = v17;
LABEL_34:
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists((uint64_t **)a1);
  return a1;
}

uint64_t entsize_list_tt<property_t,property_list_t,0u,PointerModifierNop>::end(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;

  v5 = *a1;
  v4 = a1[1];
  if (((v4 * (unint64_t)v5) & 0xFFFFFFFF00000000) != 0)
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v4, a1, v5);
  return v5 | (v4 << 32);
}

uint64_t list_array_tt<property_t,property_list_t,RawPtr>::end(uint64_t a1, _QWORD *a2, const char *a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;

  v5 = *a2 & 3;
  v6 = (unsigned int *)(*a2 & 0xFFFFFFFFFFFFFFFCLL);
  if (v5 == 1 && v6 != 0)
  {
    v6 += 2 * *v6 + 2;
    v17 = a2;
LABEL_15:
    v18 = v6;
    v13 = a2;
    v14 = v6;
    return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, (uint64_t)&v13, a4);
  }
  if (v5 == 2 && v6 != 0)
  {
    v10 = *v6;
    v9 = v6[1];
    v11 = v9 * (unint64_t)v10;
    if ((v11 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v9, *a2 & 0xFFFFFFFFFFFFFFFCLL, v10);
    v5 = (uint64_t)v6 + v11 + 8;
    v4 = v10 | (v9 << 32);
    v17 = a2;
    goto LABEL_18;
  }
  v6 = 0;
  v17 = a2;
  if (v5 == 2)
  {
LABEL_18:
    v18 = v6;
    v19 = v4;
    v20 = v5;
    v13 = a2;
    v14 = v6;
    v15 = v4;
    v16 = v5;
    return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, (uint64_t)&v13, a4);
  }
  if (v5 == 1)
    goto LABEL_15;
  if (v5)
  {
    v13 = a2;
  }
  else
  {
    v18 = 0;
    v13 = a2;
    v14 = 0;
  }
  return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, (uint64_t)&v13, a4);
}

unint64_t protocol_t::demangledName(char **this)
{
  unint64_t *v2;
  char *v3;
  unint64_t v6;

  v2 = (unint64_t *)(this + 10);
  if ((char **)((char *)this + *((unsigned int *)this + 16)) <= this + 10)
  {
    v2 = (unint64_t *)(this + 1);
  }
  else if (!*v2)
  {
    v3 = copySwiftV1DemangledName(this[1], 1);
    if (v3)
    {
      while (!__ldaxr(v2))
      {
        if (!__stlxr((unint64_t)v3, v2))
          return *v2;
      }
      __clrex();
      free(v3);
    }
    else
    {
      v6 = (unint64_t)this[1];
      while (!__ldaxr(v2))
      {
        if (!__stlxr(v6, v2))
          return *v2;
      }
      __clrex();
    }
  }
  return *v2;
}

char *copySwiftV1DemangledName(char *result, int a2)
{
  char *v3;
  const char *v4;
  const char *v5;
  _BOOL4 v6;
  char *v7;
  int v8;
  char *v9;
  int v10;
  char *v11;
  char *v12;

  if (result)
  {
    v3 = result;
    if (a2)
      v4 = "_TtP";
    else
      v4 = "_TtC";
    if (strncmp(result, v4, 4uLL))
      return 0;
    v12 = v3 + 4;
    v5 = &v3[strlen(v3 + 4) + 4];
    v11 = 0;
    v10 = 0;
    if (v3[4] == 115)
    {
      v10 = 5;
      v11 = "Swift";
      v12 = v3 + 5;
    }
    else if (!scanMangledField((const char **)&v12, v5, (const char **)&v11, &v10))
    {
      return 0;
    }
    v9 = 0;
    v8 = 0;
    v6 = scanMangledField((const char **)&v12, v5, (const char **)&v9, &v8);
    result = 0;
    if (v6)
    {
      if (a2)
      {
        if (!strcmp(v12, "_"))
          goto LABEL_16;
      }
      else if (v12 == v5)
      {
LABEL_16:
        v7 = 0;
        asprintf(&v7, "%.*s.%.*s", v10, v11, v8, v9);
        return v7;
      }
      return 0;
    }
  }
  return result;
}

BOOL scanMangledField(const char **a1, const char *a2, const char **a3, int *a4)
{
  const char *v4;
  int v6;
  uint64_t v7;
  char *v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  BOOL v12;
  const char *v13;

  v4 = *a1;
  if (**a1 == 48)
    return 0;
  v6 = 0;
  *a4 = 0;
  *a3 = v4;
  v7 = MEMORY[0x1E0C80978];
  while (1)
  {
    v8 = (char *)*a3;
    if (*a3 >= a2)
      break;
    v9 = *v8;
    if ((v9 & 0x80000000) != 0 || (*(_DWORD *)(v7 + 4 * v9 + 60) & 0x400) == 0)
      break;
    *a3 = v8 + 1;
    v10 = 10 * v6;
    *a4 = v10;
    if (v10 == (int)v10)
    {
      v11 = v9 - 48;
      v12 = __OFADD__((_DWORD)v10, v11);
      v6 = v10 + v11;
      *a4 = v6;
      if (!v12)
        continue;
    }
    return 0;
  }
  v13 = &v8[v6];
  *a1 = v13;
  return v6 > 0 && v13 <= a2;
}

BOOL protocol_isEqual(Protocol *proto, Protocol *other)
{
  Protocol *v2;

  if (proto == other)
  {
    LOBYTE(proto) = 1;
  }
  else
  {
    v2 = proto;
    LOBYTE(proto) = 0;
    if (v2)
    {
      if (other)
      {
        LODWORD(proto) = protocol_conformsToProtocol(v2, other);
        if ((_DWORD)proto)
          LOBYTE(proto) = protocol_conformsToProtocol(other, v2);
      }
    }
  }
  return (char)proto;
}

BOOL protocol_conformsToProtocol(Protocol *proto, Protocol *other)
{
  unint64_t StatusReg;
  unsigned int v5;
  char v7;
  int v8;
  unsigned int v9;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v5, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v7 = protocol_conformsToProtocol_nolock((protocol_t *)proto, (const char **)other);
  v8 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v9 = __ldxr(runtimeLock);
    if (v9 != v8)
      break;
    if (!__stlxr(0, runtimeLock))
      return v7;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v7;
}

void sub_18011BBC4(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

objc_property_attribute_t *__cdecl property_copyAttributeList(objc_property_t property, unsigned int *outCount)
{
  unint64_t StatusReg;
  unsigned int v5;
  objc_property_attribute_t *v7;
  const char *v8;
  unsigned int v9;
  _BYTE *i;
  size_t v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  uint64_t v17;
  objc_property_attribute_t *v18;

  if (!property)
  {
    v7 = 0;
    if (outCount)
      *outCount = 0;
    return v7;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v5, runtimeLock))
      goto LABEL_9;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_9:
  v8 = (const char *)*((_QWORD *)property + 1);
  if (!v8)
  {
    v7 = 0;
    if (outCount)
      *outCount = 0;
    goto LABEL_22;
  }
  v9 = 1;
  for (i = (_BYTE *)*((_QWORD *)property + 1); *i == 44; ++i)
  {
    ++v9;
LABEL_15:
    ;
  }
  if (*i)
    goto LABEL_15;
  v11 = strlen(v8);
  v7 = (objc_property_attribute_t *)malloc_type_calloc(2 * v9 + 16 * v9 + v11 + 16, 1uLL, 0xEC10EE0uLL);
  v17 = (uint64_t)&v7[v9 + 1];
  v18 = v7;
  v12 = iteratePropertyAttributes(v8, (uint64_t (*)(uint64_t, void *, void *, const char *, int64_t, uint64_t, const char *))copyOneAttribute, &v18, &v17);
  v13 = v12;
  if (!v12)
  {
    free(v7);
    v7 = 0;
  }
  if (outCount)
    *outCount = v13;
LABEL_22:
  v14 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v15 = __ldxr(runtimeLock);
    if (v15 != v14)
      break;
    if (!__stlxr(0, runtimeLock))
      return v7;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v7;
}

void sub_18011BD68(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

char *__cdecl property_copyAttributeValue(objc_property_t property, const char *attributeName)
{
  char *v2;
  unint64_t StatusReg;
  unsigned int v6;
  const char *v8;
  int v9;
  unsigned int v10;
  char *v12;

  v2 = 0;
  if (property && attributeName)
  {
    if (*attributeName)
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v6 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr(runtimeLock))
      {
        if (!__stxr(v6, runtimeLock))
          goto LABEL_10;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_10:
      v8 = (const char *)*((_QWORD *)property + 1);
      v12 = 0;
      iteratePropertyAttributes(v8, (uint64_t (*)(uint64_t, void *, void *, const char *, int64_t, uint64_t, const char *))findOneAttribute, (void *)attributeName, &v12);
      v2 = v12;
      v9 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v10 = __ldxr(runtimeLock);
        if (v10 != v9)
          break;
        if (!__stlxr(0, runtimeLock))
          return v2;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void sub_18011BE7C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t iteratePropertyAttributes(const char *__s, uint64_t (*a2)(uint64_t, void *, void *, const char *, int64_t, uint64_t, const char *), void *a3, void *a4)
{
  const char *v4;
  int v5;
  uint64_t v9;
  size_t v10;
  const char *v11;
  const char *v12;
  _BYTE *v13;
  size_t v14;
  uint64_t v15;
  int v16;

  if (!__s)
    return 0;
  v4 = __s;
  v5 = *(unsigned __int8 *)__s;
  if (!*__s)
    return 0;
  v9 = 0;
  do
  {
    v10 = strcspn(v4, ",");
    v11 = &v4[v10];
    if (v4[v10])
      v12 = &v4[v10 + 1];
    else
      v12 = &v4[v10];
    if (v10)
    {
      v13 = v4 + 1;
      if (v5 == 34)
      {
        v14 = strcspn(++v4, "\",");
        v13 += v14;
        v15 = (uint64_t)(*v13 == 34 ? v13 + 1 : v13);
      }
      else
      {
        v15 = (uint64_t)(v4 + 1);
      }
      v16 = a2(v9, a3, a4, v4, v13 - v4, v15, &v11[-v15]);
      v9 = (v9 + 1);
      if (!v16)
        break;
    }
    v5 = *(unsigned __int8 *)v12;
    v4 = v12;
  }
  while (*v12);
  return v9;
}

uint64_t findOneAttribute(unsigned int a1, char *__s, _QWORD *a3, const char *a4, size_t a5, const char *a6, size_t a7)
{
  uint64_t result;
  void *v14;

  if (strlen(__s) != a5 || strncmp(a4, __s, a5))
    return 1;
  v14 = malloc_type_calloc(a7 + 1, 1uLL, 0xCAE7772DuLL);
  memcpy(v14, a6, a7);
  result = 0;
  *((_BYTE *)v14 + a7) = 0;
  *a3 = v14;
  return result;
}

uint64_t copyOneAttribute(unsigned int a1, _QWORD *a2, void **a3, const char *__src, size_t __n, const char *a6, size_t a7)
{
  _QWORD *v12;
  char *v13;
  char *v14;

  v12 = (_QWORD *)*a2;
  v13 = (char *)*a3;
  *(_QWORD *)*a2 = *a3;
  memcpy(v13, __src, __n);
  v14 = &v13[__n];
  *v14++ = 0;
  v12[1] = v14;
  memcpy(v14, a6, a7);
  v14[a7] = 0;
  *a2 = v12 + 2;
  *a3 = &v14[a7 + 1];
  return 1;
}

objc_property_t *__cdecl protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)
{
  return protocol_copyPropertyList2(proto, outCount, 1, 1);
}

const char *__cdecl ivar_getTypeEncoding(const char *v)
{
  if (v)
    return (const char *)*((_QWORD *)v + 2);
  return v;
}

unint64_t _method_getImplementationAndName(unint64_t a1)
{
  return method_t::imp(a1, 1);
}

uint64_t _objc_rootIsDeallocating(objc_object *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000) != 0)
    return 0;
  if (((uint64_t)a1->isa & 1) != 0)
    return (unint64_t)a1->isa >> 44 == 0;
  return objc_object::sidetable_isDeallocating(a1);
}

uint64_t schedule_class_load(uint64_t result)
{
  objc_class *v1;
  uint64_t v2;
  const char *v3;
  char *v4;
  uint64_t v5;
  int v6;
  objc_class **v7;
  unsigned int *v8;
  unsigned int v9;
  char *v10;

  if (result)
  {
    v1 = (objc_class *)result;
    if ((*(_BYTE *)((*(_QWORD *)(result + 32) & 0xF00007FFFFFFFF8) + 2) & 0x80) == 0)
    {
      schedule_class_load(*(objc_class **)(result + 8));
      result = objc_class::getLoadMethod(v1, v2, v3, v4);
      if (result)
      {
        v5 = result;
        if (PrintLoading)
        {
          v10 = objc_class::nameForLogging(v1);
          _objc_inform("LOAD: class '%s' scheduled for +load", v10);
        }
        v6 = loadable_classes_used;
        result = loadable_classes;
        if (loadable_classes_used == loadable_classes_allocated)
        {
          loadable_classes_allocated = 2 * loadable_classes_used + 16;
          result = (uint64_t)malloc_type_realloc((void *)loadable_classes, 16 * loadable_classes_allocated, 0x80040803F642BuLL);
          loadable_classes = result;
          v6 = loadable_classes_used;
        }
        v7 = (objc_class **)(result + 16 * v6);
        *v7 = v1;
        v7[1] = (objc_class *)v5;
        loadable_classes_used = v6 + 1;
      }
      v8 = (unsigned int *)(*((_QWORD *)v1 + 4) & 0xF00007FFFFFFFF8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 | 0x800000, v8));
    }
  }
  return result;
}

unint64_t objc_class::getLoadMethod(objc_class *this, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned int *v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  BOOL v19;
  _BOOL4 v20;
  unsigned int v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unsigned __int16 *v27;
  unsigned __int16 *v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  unint64_t v32;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  BOOL v39;
  _BOOL4 v40;
  unsigned int v41;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  BOOL v48;
  _BOOL4 v49;
  unsigned int v50;
  uint64_t v51;
  int v52;
  char *v53;
  BOOL v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  BOOL v60;
  _BOOL4 v61;
  unsigned int v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  char *v68;
  BOOL v69;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  BOOL v76;
  _BOOL4 v77;
  unsigned int v78;
  uint64_t v79;
  int v80;
  char *v81;
  BOOL v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  unint64_t v86;
  BOOL v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  BOOL v93;
  _BOOL4 v94;
  unsigned int v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  int v100;
  char *v101;
  BOOL v102;
  unint64_t v103;
  uint64_t v104;
  int v105;
  unint64_t v106;
  BOOL v107;
  unint64_t v108;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  uint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  uint64_t v142;

  v4 = *(_QWORD *)((*(_QWORD *)((*(_QWORD *)this & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8) + 8);
  v5 = (_QWORD *)(v4 & 0xFFFFFFFFFFFFFFFELL);
  if ((v4 & 1) != 0)
    v5 = (_QWORD *)*v5;
  v6 = v5[4];
  v7 = (unsigned int *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  if ((v6 & 1) != 0 || !v7)
  {
    v22 = v6 & 1;
    if (v7)
      v23 = v22 == 0;
    else
      v23 = 1;
    if (v23)
      return 0;
    v24 = *v7;
    v25 = v7[1];
    v26 = v25 * (unint64_t)v24;
    if ((v26 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v25, v7, v24);
    v27 = (unsigned __int16 *)(v7 + 2);
    v28 = (unsigned __int16 *)((char *)v7 + v26 + 8);
    if (DisablePreattachedCategories)
    {
      if (!(_DWORD)v25)
        return 0;
      v27 = (unsigned __int16 *)((char *)v28 - v24);
    }
    for (; v27 < v28; v27 = (unsigned __int16 *)((char *)v27 + v24))
    {
      if ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v27 + 8) & 1) != 0)
        break;
    }
    if (v28 == v27)
      return 0;
    v29 = -v24;
    do
      v28 = (unsigned __int16 *)((char *)v28 + v29);
    while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * (unsigned __int16)*(_QWORD *)v28 + 8) & 1) == 0);
    v7 = (unsigned int *)((char *)v28 + (*(uint64_t *)v28 >> 16));
    if (!v7)
      return 0;
    v30 = *v7;
    v9 = (unsigned __int16)v30 & 0xFFFC;
    if ((v30 & 0x80000000) == 0)
      v31 = 24;
    else
      v31 = 12;
    v32 = v30 >> 31;
    if ((~(_DWORD)v30 & 3) != 0 || (_DWORD)v9 != v31)
    {
      if ((v30 & 0x80000000) != 0)
      {
        if (dataSegmentsRanges <= (unint64_t)v7 && *(_QWORD *)algn_1ECCE5978 > (unint64_t)v7)
        {
          if (dataSegmentsRanges > (unint64_t)sel_load
            || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)sel_load)
          {
            return 0;
          }
          v110 = v7[1];
          v138 = v110 * (unint64_t)v9;
          if ((v138 & 0xFFFFFFFF00000000) != 0)
            goto LABEL_237;
          v139 = (unint64_t)(v7 + 2);
          v140 = v139 & 0xFFFFFFFFFFFFFFFCLL | v32;
          v141 = (v139 + v138) & 0xFFFFFFFFFFFFFFFCLL | v32;
          if (v140 == v141)
            return 0;
          v142 = 0;
          while (1)
          {
            v17 = v140 + v142;
            if (sel_load == (char *)&unk_1F25805A8 + *(int *)((v140 + v142) & 0xFFFFFFFFFFFFFFFCLL))
              break;
            v142 += v9;
            if (v140 + v142 == v141)
              return 0;
          }
        }
        else
        {
          v110 = v7[1];
          v133 = v110 * (unint64_t)v9;
          if ((v133 & 0xFFFFFFFF00000000) != 0)
            goto LABEL_237;
          v134 = (unint64_t)(v7 + 2);
          v135 = v134 & 0xFFFFFFFFFFFFFFFCLL | v32;
          v136 = (v134 + v133) & 0xFFFFFFFFFFFFFFFCLL | v32;
          if (v135 == v136)
            return 0;
          v137 = 0;
          while (1)
          {
            v17 = v135 + v137;
            if (*(char **)(((v135 + v137) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v135 + v137) & 0xFFFFFFFFFFFFFFFCLL)) == sel_load)
              break;
            v137 += v9;
            if (v135 + v137 == v136)
              return 0;
          }
        }
      }
      else
      {
        v110 = v7[1];
        v122 = v110 * (unint64_t)v9;
        if ((v122 & 0xFFFFFFFF00000000) != 0)
          goto LABEL_237;
        v123 = (unint64_t)(v7 + 2);
        v124 = v123 & 0xFFFFFFFFFFFFFFFCLL | v32;
        v125 = (v123 + v122) & 0xFFFFFFFFFFFFFFFCLL | v32;
        if (v124 == v125)
          return 0;
        v126 = 0;
        while (1)
        {
          v17 = v124 + v126;
          if (*(char **)((v124 + v126) & 0xFFFFFFFFFFFFFFFCLL) == sel_load)
            break;
          v126 += v9;
          if (v124 + v126 == v125)
            return 0;
        }
      }
      goto LABEL_181;
    }
    if ((v30 & 0x80000000) == 0)
    {
      v34 = (unint64_t)(v7 + 2) & 0xFFFFFFFFFFFFFFFCLL | v32;
      v35 = v7[1];
      if (v35 < 5)
      {
        v37 = v34;
LABEL_107:
        if (!(_DWORD)v35)
          return 0;
        v79 = 0;
        v80 = v35 - 1;
        while (1)
        {
          v17 = v37 + v79;
          v81 = *(char **)((v37 + v79) & 0xFFFFFFFFFFFFFFFCLL);
          if (sel_load == v81)
            break;
          v82 = sel_load < v81 || v80-- == 0;
          v79 += v9;
          if (v82)
            return 0;
        }
        goto LABEL_181;
      }
      v36 = (unsigned __int16)v30 & 0xFFFC;
      v37 = v34;
      while (1)
      {
        v17 = v37 + ((unsigned __int16)v30 & 0xFFFC) * (unint64_t)(v35 >> 1);
        v38 = *(char **)(v17 & 0xFFFFFFFFFFFFFFFCLL);
        v39 = sel_load > v38;
        if (sel_load == v38)
          break;
        v40 = sel_load > v38;
        if (v39)
          v37 = v17 + ((unsigned __int16)v30 & 0xFFFC);
        v41 = v35 - v40;
        v35 = v41 >> 1;
        if (v41 <= 9)
          goto LABEL_107;
      }
      if (v17 > v34)
      {
        v63 = 0;
        v96 = v37 + ((unsigned __int16)v30 >> 2) * (((2 * v35) & 0x1FFFFFFFCLL) - 4);
        while (sel_load == *(char **)((v96 + v63) & 0xFFFFFFFFFFFFFFFCLL))
        {
          v63 -= v36;
          v65 = v17 + v63;
          if (v17 + v63 <= v34)
            goto LABEL_180;
        }
        goto LABEL_165;
      }
      goto LABEL_181;
    }
    if (dataSegmentsRanges > (unint64_t)v7 || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v7)
    {
      v71 = (unint64_t)(v7 + 2) & 0xFFFFFFFFFFFFFFFCLL | v32;
      v72 = v7[1];
      if (v72 < 5)
      {
        v74 = v71;
LABEL_151:
        if (!(_DWORD)v72)
          return 0;
        v99 = 0;
        v100 = v72 - 1;
        while (1)
        {
          v17 = v74 + v99;
          v101 = *(char **)(((v74 + v99) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v74 + v99) & 0xFFFFFFFFFFFFFFFCLL));
          if (sel_load == v101)
            break;
          v102 = sel_load < v101 || v100-- == 0;
          v99 += v9;
          if (v102)
            return 0;
        }
        goto LABEL_181;
      }
      v73 = (unsigned __int16)v30 & 0xFFFC;
      v74 = v71;
      while (1)
      {
        v17 = v74 + ((unsigned __int16)v30 & 0xFFFC) * (unint64_t)(v72 >> 1);
        v75 = *(char **)((v17 & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(v17 & 0xFFFFFFFFFFFFFFFCLL));
        v76 = sel_load > v75;
        if (sel_load == v75)
          break;
        v77 = sel_load > v75;
        if (v76)
          v74 = v17 + ((unsigned __int16)v30 & 0xFFFC);
        v78 = v72 - v77;
        v72 = v78 >> 1;
        if (v78 <= 9)
          goto LABEL_151;
      }
      if (v17 > v71)
      {
        v63 = 0;
        v103 = v74 + ((unsigned __int16)v30 >> 2) * (((2 * v72) & 0x1FFFFFFFCLL) - 4);
        while (sel_load == *(char **)(((v103 + v63) & 0xFFFFFFFFFFFFFFFCLL)
                                     + *(int *)((v103 + v63) & 0xFFFFFFFFFFFFFFFCLL)))
        {
          v63 -= v73;
          v65 = v17 + v63;
          if (v17 + v63 <= v71)
            goto LABEL_180;
        }
        goto LABEL_165;
      }
      goto LABEL_181;
    }
    if (dataSegmentsRanges > (unint64_t)sel_load || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)sel_load)
      return 0;
    v88 = sel_load - (char *)&unk_1F25805A8;
    v89 = (unint64_t)(v7 + 2) & 0xFFFFFFFFFFFFFFFCLL | v32;
    v90 = v7[1];
    if (v90 < 5)
    {
      v91 = v89;
LABEL_167:
      if (!(_DWORD)v90)
        return 0;
      v104 = 0;
      v105 = v90 - 1;
      while (1)
      {
        v17 = v91 + v104;
        v106 = *(int *)((v91 + v104) & 0xFFFFFFFFFFFFFFFCLL);
        if (v88 == v106)
          break;
        v107 = v88 < v106 || v105-- == 0;
        v104 += v9;
        if (v107)
          return 0;
      }
      goto LABEL_181;
    }
    v91 = v89;
    while (1)
    {
      v17 = v91 + ((unsigned __int16)v30 & 0xFFFC) * (unint64_t)(v90 >> 1);
      v92 = *(int *)(v17 & 0xFFFFFFFFFFFFFFFCLL);
      v93 = v88 > v92;
      if (v88 == v92)
        break;
      v94 = v88 > v92;
      if (v93)
        v91 = v17 + v9;
      v95 = v90 - v94;
      v90 = v95 >> 1;
      if (v95 <= 9)
        goto LABEL_167;
    }
    if (v17 <= v89)
      goto LABEL_181;
    v97 = 0;
    v108 = v91 + ((unsigned __int16)v30 >> 2) * (((2 * v90) & 0x1FFFFFFFCLL) - 4);
    while (v88 == *(_DWORD *)((v108 + v97) & 0xFFFFFFFFFFFFFFFCLL))
    {
      v97 -= v9;
      v65 = v17 + v97;
      if (v17 + v97 <= v89)
      {
LABEL_180:
        v17 = v65;
        goto LABEL_181;
      }
    }
LABEL_183:
    v17 += v97;
    goto LABEL_181;
  }
  v8 = *v7;
  v9 = (unsigned __int16)v8 & 0xFFFC;
  if ((v8 & 0x80000000) == 0)
    v10 = 24;
  else
    v10 = 12;
  v11 = v8 >> 31;
  if ((~(_DWORD)v8 & 3) != 0 || (_DWORD)v9 != v10)
  {
    if ((v8 & 0x80000000) == 0)
    {
      v110 = v7[1];
      v111 = v110 * (unint64_t)v9;
      if ((v111 & 0xFFFFFFFF00000000) == 0)
      {
        v112 = (unint64_t)(v7 + 2);
        v113 = v112 & 0xFFFFFFFFFFFFFFFCLL | v11;
        v114 = (v112 + v111) & 0xFFFFFFFFFFFFFFFCLL | v11;
        if (v113 == v114)
          return 0;
        v115 = 0;
        while (1)
        {
          v17 = v113 + v115;
          if (*(char **)((v113 + v115) & 0xFFFFFFFFFFFFFFFCLL) == sel_load)
            break;
          v115 += v9;
          if (v113 + v115 == v114)
            return 0;
        }
        goto LABEL_181;
      }
LABEL_237:
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v110, v7, v9);
    }
    if (dataSegmentsRanges <= (unint64_t)v7 && *(_QWORD *)algn_1ECCE5978 > (unint64_t)v7)
    {
      if (dataSegmentsRanges > (unint64_t)sel_load || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)sel_load)
        return 0;
      v110 = v7[1];
      v127 = v110 * (unint64_t)v9;
      if ((v127 & 0xFFFFFFFF00000000) != 0)
        goto LABEL_237;
      v128 = (unint64_t)(v7 + 2);
      v129 = v128 & 0xFFFFFFFFFFFFFFFCLL | v11;
      v130 = (v128 + v127) & 0xFFFFFFFFFFFFFFFCLL | v11;
      if (v129 == v130)
        return 0;
      v131 = 0;
      while (1)
      {
        v17 = v129 + v131;
        if (sel_load == (char *)&unk_1F25805A8 + *(int *)((v129 + v131) & 0xFFFFFFFFFFFFFFFCLL))
          break;
        v131 += v9;
        if (v129 + v131 == v130)
          return 0;
      }
    }
    else
    {
      v110 = v7[1];
      v117 = v110 * (unint64_t)v9;
      if ((v117 & 0xFFFFFFFF00000000) != 0)
        goto LABEL_237;
      v118 = (unint64_t)(v7 + 2);
      v119 = v118 & 0xFFFFFFFFFFFFFFFCLL | v11;
      v120 = (v118 + v117) & 0xFFFFFFFFFFFFFFFCLL | v11;
      if (v119 == v120)
        return 0;
      v121 = 0;
      while (1)
      {
        v17 = v119 + v121;
        if (*(char **)(((v119 + v121) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v119 + v121) & 0xFFFFFFFFFFFFFFFCLL)) == sel_load)
          break;
        v121 += v9;
        if (v119 + v121 == v120)
          return 0;
      }
    }
    goto LABEL_181;
  }
  if ((v8 & 0x80000000) == 0)
  {
    v13 = (unint64_t)(v7 + 2) & 0xFFFFFFFFFFFFFFFCLL | v11;
    v14 = v7[1];
    if (v14 < 5)
    {
      v16 = v13;
      if (!(_DWORD)v14)
        return 0;
LABEL_63:
      v51 = 0;
      v52 = v14 - 1;
      while (1)
      {
        v17 = v16 + v51;
        v53 = *(char **)((v16 + v51) & 0xFFFFFFFFFFFFFFFCLL);
        if (sel_load == v53)
          break;
        v54 = sel_load < v53 || v52-- == 0;
        v51 += v9;
        if (v54)
          return 0;
      }
      goto LABEL_181;
    }
    v15 = (unsigned __int16)v8 & 0xFFFC;
    v16 = v13;
    while (1)
    {
      v17 = v16 + ((unsigned __int16)v8 & 0xFFFC) * (unint64_t)(v14 >> 1);
      v18 = *(char **)(v17 & 0xFFFFFFFFFFFFFFFCLL);
      v19 = sel_load > v18;
      if (sel_load == v18)
        break;
      v20 = sel_load > v18;
      if (v19)
        v16 = v17 + ((unsigned __int16)v8 & 0xFFFC);
      v21 = v14 - v20;
      v14 = v21 >> 1;
      if (v21 <= 9)
      {
        if ((_DWORD)v14)
          goto LABEL_63;
        return 0;
      }
    }
    if (v17 <= v13)
      goto LABEL_181;
    v63 = 0;
    v64 = v16 + ((unsigned __int16)v8 >> 2) * (((2 * v14) & 0x1FFFFFFFCLL) - 4);
    while (sel_load == *(char **)((v64 + v63) & 0xFFFFFFFFFFFFFFFCLL))
    {
      v63 -= v15;
      v65 = v17 + v63;
      if (v17 + v63 <= v13)
        goto LABEL_180;
    }
LABEL_165:
    v17 += v63;
    goto LABEL_181;
  }
  if (dataSegmentsRanges <= (unint64_t)v7 && *(_QWORD *)algn_1ECCE5978 > (unint64_t)v7)
  {
    if (dataSegmentsRanges > (unint64_t)sel_load || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)sel_load)
      return 0;
    v55 = sel_load - (char *)&unk_1F25805A8;
    v56 = (unint64_t)(v7 + 2) & 0xFFFFFFFFFFFFFFFCLL | v11;
    v57 = v7[1];
    if (v57 < 5)
    {
      v58 = v56;
LABEL_122:
      if (!(_DWORD)v57)
        return 0;
      v84 = 0;
      v85 = v57 - 1;
      while (1)
      {
        v17 = v58 + v84;
        v86 = *(int *)((v58 + v84) & 0xFFFFFFFFFFFFFFFCLL);
        if (v55 == v86)
          break;
        v87 = v55 < v86 || v85-- == 0;
        v84 += v9;
        if (v87)
          return 0;
      }
      goto LABEL_181;
    }
    v58 = v56;
    while (1)
    {
      v17 = v58 + ((unsigned __int16)v8 & 0xFFFC) * (unint64_t)(v57 >> 1);
      v59 = *(int *)(v17 & 0xFFFFFFFFFFFFFFFCLL);
      v60 = v55 > v59;
      if (v55 == v59)
        break;
      v61 = v55 > v59;
      if (v60)
        v58 = v17 + v9;
      v62 = v57 - v61;
      v57 = v62 >> 1;
      if (v62 <= 9)
        goto LABEL_122;
    }
    if (v17 <= v56)
      goto LABEL_181;
    v97 = 0;
    v98 = v58 + ((unsigned __int16)v8 >> 2) * (((2 * v57) & 0x1FFFFFFFCLL) - 4);
    while (v55 == *(_DWORD *)((v98 + v97) & 0xFFFFFFFFFFFFFFFCLL))
    {
      v97 -= v9;
      v65 = v17 + v97;
      if (v17 + v97 <= v56)
        goto LABEL_180;
    }
    goto LABEL_183;
  }
  v43 = (unint64_t)(v7 + 2) & 0xFFFFFFFFFFFFFFFCLL | v11;
  v44 = v7[1];
  if (v44 < 5)
  {
    v46 = v43;
LABEL_86:
    if (!(_DWORD)v44)
      return 0;
    v66 = 0;
    v67 = v44 - 1;
    while (1)
    {
      v17 = v46 + v66;
      v68 = *(char **)(((v46 + v66) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v46 + v66) & 0xFFFFFFFFFFFFFFFCLL));
      if (sel_load == v68)
        break;
      v69 = sel_load < v68 || v67-- == 0;
      v66 += v9;
      if (v69)
        return 0;
    }
    goto LABEL_181;
  }
  v45 = (unsigned __int16)v8 & 0xFFFC;
  v46 = v43;
  while (1)
  {
    v17 = v46 + ((unsigned __int16)v8 & 0xFFFC) * (unint64_t)(v44 >> 1);
    v47 = *(char **)((v17 & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(v17 & 0xFFFFFFFFFFFFFFFCLL));
    v48 = sel_load > v47;
    if (sel_load == v47)
      break;
    v49 = sel_load > v47;
    if (v48)
      v46 = v17 + ((unsigned __int16)v8 & 0xFFFC);
    v50 = v44 - v49;
    v44 = v50 >> 1;
    if (v50 <= 9)
      goto LABEL_86;
  }
  if (v17 > v43)
  {
    v63 = 0;
    v83 = v46 + ((unsigned __int16)v8 >> 2) * (((2 * v44) & 0x1FFFFFFFCLL) - 4);
    while (sel_load == *(char **)(((v83 + v63) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v83 + v63) & 0xFFFFFFFFFFFFFFFCLL)))
    {
      v63 -= v45;
      v65 = v17 + v63;
      if (v17 + v63 <= v43)
        goto LABEL_180;
    }
    goto LABEL_165;
  }
LABEL_181:
  if (v17)
    return method_t::imp(v17, 0);
  return 0;
}

const char *__cdecl class_getImageName(const char *cls)
{
  unsigned int (*v1)(const char *, const char **);
  const char *v2;

  if (cls)
  {
    v2 = 0;
    v1 = (unsigned int (*)(const char *, const char **))atomic_load((unint64_t *)&GetImageNameHook);
    if (v1(cls, &v2))
      return v2;
    else
      return 0;
  }
  return cls;
}

BOOL internal_class_getImageName(objc_class *a1, const char **a2)
{
  const char *v3;

  v3 = (const char *)dyld_image_path_containing_address();
  *a2 = v3;
  return v3 != 0;
}

objc_method_description *__cdecl method_getDescription(Method m)
{
  objc_method_description *v1;
  int v2;

  if (!m)
    return 0;
  v2 = m & 3;
  if ((m & 3) == 0)
    return (objc_method_description *)((unint64_t)m & 0xFFFFFFFFFFFFFFFCLL);
  if (v2 == 2 || v2 == 1)
    return (objc_method_description *)method_t::getCachedDescription((unint64_t)m);
  return v1;
}

void objc_tls_direct_base<AutoreleasePoolPage *,(tls_key)3,AutoreleasePoolPage::HotPageDealloc>::dtor_(_QWORD *a1, uint64_t a2, const char *a3, char *a4)
{
  _QWORD *StatusReg;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  AutoreleasePoolPage *v9;

  StatusReg = (_QWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = (void *)(StatusReg[44] & 0xFFFFFFFFFFFFFFFCLL);
  if (v6)
  {
    v7 = StatusReg + 44;
    do
    {
      *v7 = 0;
      StatusReg[45] = 0;

      v6 = (void *)(*v7 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v6);
  }
  if (a1 != (_QWORD *)1)
  {
    if (a1)
    {
      if (*(_DWORD *)a1 != -1583242847)
        AutoreleasePoolPage::busted_die((AutoreleasePoolPage *)a1, a2, a3, a4);
      v8 = StatusReg + 43;
      StatusReg[43] = a1;
      while (1)
      {
        v9 = (AutoreleasePoolPage *)a1[4];
        if (!v9)
          break;
        a1 = (_QWORD *)a1[4];
        if (*(_DWORD *)v9 != -1583242847)
          AutoreleasePoolPage::busted_die(v9, a2, a3, a4);
      }
      if ((_QWORD *)a1[2] != a1 + 7)
        objc_autoreleasePoolPop(a1 + 7);
      if (!(DebugMissingPools | DebugPoolAllocation))
        AutoreleasePoolPage::kill((AutoreleasePoolPage *)a1, a2, a3, a4);
    }
    else
    {
      v8 = StatusReg + 43;
    }
    *v8 = 0;
  }
}

void AutoreleasePoolPage::kill(AutoreleasePoolPage *this, uint64_t a2, const char *a3, char *a4)
{
  AutoreleasePoolPage *v5;
  AutoreleasePoolPage *v6;
  _QWORD *StatusReg;
  AutoreleasePoolPage *v8;
  BOOL v9;

  v5 = this;
  do
  {
    v6 = v5;
    v5 = (AutoreleasePoolPage *)*((_QWORD *)v5 + 5);
  }
  while (v5);
  StatusReg = (_QWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  do
  {
    v8 = (AutoreleasePoolPage *)*((_QWORD *)v6 + 4);
    if (v8)
      *((_QWORD *)v8 + 5) = 0;
    if (*(_DWORD *)v6 != -1583242847
      || strncmp((const char *)v6 + 4, "AUTORELEASE!", 0xCuLL)
      || *((_QWORD *)v6 + 3) != *StatusReg)
    {
      AutoreleasePoolPage::busted_die(v6, a2, a3, a4);
    }
    *(_QWORD *)v6 = 0;
    *((_QWORD *)v6 + 1) = 0;
    free(v6);
    v9 = v6 == this;
    v6 = v8;
  }
  while (!v9);
}

void sub_18011D0D8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = 0;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

void objc_setForwardHandler(void *fwd, void *fwd_stret)
{
  _objc_forward_handler = (void (*)(objc_object *, objc_selector *))fwd;
}

void objc_setEnumerationMutationHandler(void (__cdecl *handler)(id))
{
  enumerationMutationHandler = handler;
}

IMP imp_implementationWithBlock(id block)
{
  uint64_t v1;
  const char *v2;
  char *v3;
  void *v4;
  void *v5;
  void *v6;
  _QWORD *v7;
  const mach_header_64 *v8;
  uint8_t *v9;
  unint64_t v10;
  unint64_t StatusReg;
  unsigned int v13;
  _QWORD *v15;
  unint64_t v16;
  vm_address_t v17;
  vm_size_t v18;
  vm_map_t *v19;
  uint64_t v20;
  uint64_t *v21;
  _QWORD *v22;
  _QWORD *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  char *v31;
  char *v32;
  uint64_t v33;
  const char *v34;
  char *v35;
  vm_prot_t cur_protection[2];
  vm_address_t target_address;
  unint64_t size;

  v4 = _Block_copy(block);
  if (!Trampolines[0])
  {
    v5 = dlopen("/usr/lib/libobjc-trampolines.dylib", 262);
    if (!v5)
    {
      v32 = dlerror();
      _objc_fatal("couldn't dlopen libobjc-trampolines.dylib: %s", v33, v34, v35, v32);
    }
    v6 = v5;
    v7 = malloc_type_malloc(0x20uLL, 0xB4ED9BFAuLL);
    TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress::TrampolineAddress((TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress *)v7, v6, "Impl");
    TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress::TrampolineAddress((TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress *)(v7 + 1), v6, "Start");
    v8 = (const mach_header_64 *)dyld_image_header_containing_address();
    size = 0;
    v9 = getsegmentdata(v8, "__TEXT", &size);
    v10 = size;
    v7[2] = v9;
    v7[3] = v10;
    while (!__ldxr(Trampolines))
    {
      if (!__stlxr((unint64_t)v7, Trampolines))
        goto LABEL_8;
    }
    __clrex();
    free(v7);
  }
LABEL_8:
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v13 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v13, runtimeLock))
      goto LABEL_13;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_13:
  v15 = (_QWORD *)HeadPageGroup;
  if (HeadPageGroup)
  {
    v16 = *(_QWORD *)(HeadPageGroup + 16);
    if (v16 != 2048)
      goto LABEL_23;
    v15 = *(_QWORD **)(HeadPageGroup + 8);
    if (v15)
    {
      v16 = v15[2];
      goto LABEL_23;
    }
  }
  size = 0;
  v17 = *(_QWORD *)(Trampolines[0] + 16);
  v18 = *(_QWORD *)(Trampolines[0] + 24);
  v19 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  v20 = vm_allocate(*MEMORY[0x1E0C83DA0], &size, v18 + 0x4000, 687865857);
  if ((_DWORD)v20)
  {
    v31 = "vm_allocate trampolines failed (%d)";
    goto LABEL_41;
  }
  *(_QWORD *)cur_protection = 0;
  target_address = size + 0x4000;
  v20 = vm_remap(*v19, &target_address, v18, 0, 0x4000, *v19, v17, 1, &cur_protection[1], cur_protection, 0);
  if ((_DWORD)v20)
  {
    v31 = "vm_remap trampolines failed (%d)";
LABEL_41:
    _objc_fatal(v31, v1, v2, v3, v20);
  }
  v15 = (_QWORD *)size;
  *(_QWORD *)size = 0;
  v15[1] = 0;
  v16 = (*(_QWORD *)(Trampolines[0] + 8) - *(_QWORD *)Trampolines[0]) >> 3;
  v15[2] = v16;
  v15[3] = v15 + 2048;
  v21 = &HeadPageGroup;
  v22 = (_QWORD *)HeadPageGroup;
  if (HeadPageGroup)
  {
    do
    {
      v23 = v22;
      v22 = (_QWORD *)*v22;
    }
    while (v22);
    *v23 = v15;
    v21 = (uint64_t *)(HeadPageGroup + 8);
  }
  *v21 = (uint64_t)v15;
LABEL_23:
  v24 = v15[v16];
  if (!v24)
    v24 = v16 + 1;
  v15[2] = v24;
  if (v24 == 2048)
  {
    v25 = HeadPageGroup;
    while (v25)
    {
      v26 = v25;
      v25 = *(_QWORD *)(v25 + 8);
      if ((_QWORD *)v25 == v15)
      {
        *(_QWORD *)(v26 + 8) = v15[1];
        v15[1] = 0;
        break;
      }
    }
  }
  v15[v16] = v4;
  if (v16 > 0x7FF || (*(_QWORD *)(Trampolines[0] + 8) - *(_QWORD *)Trampolines[0]) >> 3 > v16)
    _objc_fatal("Trampoline block %p, requested invalid index %lu", v1, v2, v3, v15, v16);
  v27 = v16;
  v28 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v29 = __ldxr(runtimeLock);
    if (v29 != v28)
      break;
    if (!__stlxr(0, runtimeLock))
      return (IMP)&v15[v27 + 4096];
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return (IMP)&v15[v27 + 4096];
}

void sub_18011D400(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress *TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress::TrampolineAddress(TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress *this, void *a2, const char *__s)
{
  char *v6;
  void *v7;
  uint64_t v8;
  const char *v9;
  char *v10;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  strlen(__s);
  v6 = (char *)v12 - ((MEMORY[0x1E0C80A78]() + 37) & 0xFFFFFFFFFFFFFFF0);
  strcpy(v6, "_objc_blockTrampoline");
  strcat(v6, __s);
  v7 = dlsym(a2, v6);
  *(_QWORD *)this = v7;
  if (!v7)
    _objc_fatal("couldn't dlsym %s", v8, v9, v10, v6);
  return this;
}

_QWORD *_objc_getClassForTag(unsigned int a1)
{
  _QWORD *result;

  result = classSlotForTagIndex(a1);
  if (result)
    return (_QWORD *)*result;
  return result;
}

objc_class **_objc_registerTaggedPointerClass(unsigned int a1, objc_class *a2, const char *a3, char *a4)
{
  objc_class **result;
  uint64_t v7;
  const char *v8;
  char *v9;
  objc_class *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  const char *v14;
  char *v15;

  if (!objc_debug_taggedpointer_mask)
    _objc_fatal("tagged pointers are disabled", (uint64_t)a2, a3, a4);
  result = (objc_class **)classSlotForTagIndex(a1);
  if (!result)
    _objc_fatal("tag index %u is invalid", v7, v8, v9, a1);
  if (a2)
  {
    v10 = *result;
    if (*result)
    {
      if (v10 != a2)
      {
        v11 = objc_class::nameForLogging(*result);
        v12 = objc_class::nameForLogging(a2);
        _objc_fatal("tag index %u used for two different classes (was %p %s, now %p %s)", v13, v14, v15, a1, v10, v11, a2, v12);
      }
    }
  }
  *result = a2;
  if (a1 >= 7 && !objc_debug_taggedpointer_classes[byte_1ECCE41D7])
    objc_debug_taggedpointer_classes[byte_1ECCE41D7] = __NSUnrecognizedTaggedPointer;
  return result;
}

_QWORD *classSlotForTagIndex(unsigned int a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  if (a1 <= 6)
  {
    v1 = objc_debug_tag60_permutations[a1];
    v2 = objc_debug_taggedpointer_classes;
    return &v2[v1];
  }
  v3 = 0;
  if (a1 != 7 && a1 <= 0x107)
  {
    v4 = ((unint64_t)objc_debug_taggedpointer_obfuscator >> 55);
    if (a1 > 0x87)
      v4 = 0;
    v1 = v4 ^ (a1 - 8);
    v2 = objc_debug_taggedpointer_ext_classes;
    return &v2[v1];
  }
  return (_QWORD *)v3;
}

Class objc_getMetaClass(Class name)
{
  const char *v1;
  objc_class *v2;

  if (name)
  {
    v1 = (const char *)name;
    v2 = look_up_class((char *)name);
    if (v2)
    {
      return (Class)(*(_QWORD *)v2 & 0xFFFFFFFF8);
    }
    else
    {
      return 0;
    }
  }
  return name;
}

Class objc_getFutureClass(const char *name)
{
  objc_class *v2;
  objc_class *v3;
  unint64_t StatusReg;
  unsigned int v5;
  _DWORD *v7;
  unsigned int v8;
  objc_class *v9;
  unint64_t v10;
  _QWORD *v11;
  size_t v12;
  void *v13;
  uint64_t v14;
  unint64_t v15;
  _DWORD *v16;
  int v17;
  unsigned int v18;
  __int128 v20;
  __int128 v21;

  v2 = look_up_class((char *)name);
  if (v2)
  {
    v3 = v2;
    if (PrintFuture)
      _objc_inform("FUTURE: found %p already in use for %s", v2, name);
  }
  else
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v5 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v5, runtimeLock))
        goto LABEL_9;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_9:
    v7 = (_DWORD *)future_named_class_map;
    if (!future_named_class_map)
    {
      v20 = NXStrValueMapPrototype;
      v21 = *(_OWORD *)&off_1E0DF3648;
      v7 = NXCreateMapTable(&v20, 0x20u);
      future_named_class_map = (uint64_t)v7;
    }
    v8 = (**(uint64_t (***)(_DWORD *, const char *))v7)(v7, name);
    *(_QWORD *)&v20 = 0;
    if (_NXMapMemberWithHash((uint64_t)v7, (uint64_t)name, v8, &v20) == -1)
      v3 = 0;
    else
      v3 = (objc_class *)v20;
    if (!v3)
    {
      v9 = (objc_class *)malloc_type_zone_malloc_with_options_internal();
      v3 = v9;
      if (PrintFuture)
        _objc_inform("FUTURE: reserving %p for %s", v9, name);
      v10 = (unint64_t)malloc_type_calloc(0x20uLL, 1uLL, 0x1ECB51D3uLL);
      v11 = malloc_type_calloc(0x48uLL, 1uLL, 0xF421F30EuLL);
      v12 = strlen(name) + 1;
      v13 = (void *)name;
      if ((_dyld_is_memory_immutable() & 1) == 0)
      {
        v13 = malloc_type_malloc(v12, 0x3F84A03uLL);
        memcpy(v13, name, v12);
      }
      v11[3] = v13;
      v14 = *(_QWORD *)(v10 + 8);
      if ((v14 & 1) != 0)
        *(_QWORD *)(v14 & 0xFFFFFFFFFFFFFFFELL) = v11;
      else
        *(_QWORD *)(v10 + 8) = v11;
      v15 = *((_QWORD *)v3 + 4) & 7 | v10 | 0x8000000000000000;
      __dmb(0xBu);
      *((_QWORD *)v3 + 4) = v15;
      *(_DWORD *)(v10 & 0xF00007FFFFFFFF8) = 0x40000000;
      v16 = (_DWORD *)future_named_class_map;
      if (!future_named_class_map)
      {
        v20 = NXStrValueMapPrototype;
        v21 = *(_OWORD *)&off_1E0DF3648;
        v16 = NXCreateMapTable(&v20, 0x20u);
        future_named_class_map = (uint64_t)v16;
      }
      NXMapKeyCopyingInsert((uint64_t (***)(_QWORD))v16, name, (uint64_t)v3);
    }
    v17 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v18 = __ldxr(runtimeLock);
      if (v18 != v17)
        break;
      if (!__stlxr(0, runtimeLock))
        return v3;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v3;
}

void sub_18011D944(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

const char *__cdecl ivar_getName(const char *v)
{
  if (v)
    return (const char *)*((_QWORD *)v + 1);
  return v;
}

objc_uncaught_exception_handler objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler fn)
{
  void (__cdecl *v1)(id);

  v1 = (void (__cdecl *)(id))uncaught_handler;
  uncaught_handler = (uint64_t (*)(objc_object *))fn;
  return v1;
}

objc_exception_preprocessor objc_setExceptionPreprocessor(objc_exception_preprocessor fn)
{
  id (__cdecl *v1)(id);

  v1 = (id (__cdecl *)(id))exception_preprocessor[0];
  exception_preprocessor[0] = (uint64_t (*)(objc_object *))fn;
  return v1;
}

objc_exception_matcher objc_setExceptionMatcher(objc_exception_matcher fn)
{
  int (__cdecl *v1)(Class, id);

  v1 = (int (__cdecl *)(Class, id))exception_matcher;
  exception_matcher = (uint64_t (*)(objc_class *, objc_object *))fn;
  return v1;
}

id object_dispose(id a1)
{
  void *v1;

  if (a1)
  {
    v1 = objc_destructInstance(a1);
    free(v1);
  }
  return 0;
}

Class _objc_realizeClassFromSwift(Class cls, void *previously)
{
  const char *v2;
  char *v3;
  objc_class *Class;
  BOOL v6;
  char v7;
  unint64_t StatusReg;
  unsigned int v9;
  char v11;
  uint64_t v12;
  const char *v13;
  char *v14;
  char *v15;
  objc_class *v16;
  int v17;
  unsigned int v18;
  int v19;
  unsigned int v20;

  if (!cls)
    _objc_fatal("Swift requested that class %p be ignored, but libobjc does not support that.", (uint64_t)previously, v2, v3, previously);
  Class = cls;
  if (previously)
    v6 = previously == cls;
  else
    v6 = 1;
  v7 = v6;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v9 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v9, runtimeLock))
    {
      v11 = 1;
      if ((v7 & 1) == 0)
        goto LABEL_12;
      goto LABEL_19;
    }
  }
  v11 = 0;
  __clrex();
  if ((v7 & 1) == 0)
  {
LABEL_12:
    if ((v11 & 1) == 0)
      os_unfair_lock_lock_with_options();
    addRemappedClass((objc_class *)previously, Class);
    addClassTableEntry((uint64_t)Class, 1);
    v15 = (char *)objc_class::mangledName(Class, v12, v13, v14);
    addNamedClass(Class, v15, 0);
    v16 = realizeClassWithoutSwift(Class, (objc_class *)previously);
    v17 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v18 = __ldxr(runtimeLock);
      if (v18 != v17)
        break;
      if (!__stlxr(0, runtimeLock))
        return v16;
    }
    goto LABEL_27;
  }
LABEL_19:
  if ((v11 & 1) == 0)
    os_unfair_lock_lock_with_options();
  if (!previously)
    Class = (objc_class *)readClass(Class, 0, 0);
  v16 = realizeClassWithoutSwift(Class, 0);
  v19 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v20 = __ldxr(runtimeLock);
    if (v20 != v19)
      break;
    if (!__stlxr(0, runtimeLock))
      return v16;
  }
LABEL_27:
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v16;
}

uint64_t addRemappedClass(objc_class *this, objc_class *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t result;
  _QWORD *v7;
  char *v8;
  _QWORD *v9;

  if (PrintFuture)
  {
    v8 = objc_class::nameForLogging(this);
    _objc_inform("FUTURE: using %p instead of %p for %s", a2, this, v8);
  }
  if (!byte_1ECCE4EC8)
  {
    dword_1ECCE4EC0 = 64;
    v4 = malloc_type_malloc(0x400uLL, 0x64B88C75uLL);
    remappedClasses(BOOL)::remapped_class_map = (uint64_t)v4;
    qword_1ECCE4EB8 = 0;
    if (dword_1ECCE4EC0)
    {
      v5 = 16 * dword_1ECCE4EC0;
      do
      {
        *v4 = -1;
        v4 += 2;
        v5 -= 16;
      }
      while (v5);
    }
    byte_1ECCE4EC8 = 1;
  }
  v9 = 0;
  result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::LookupBucketFor<objc_class *>((unint64_t)this, &v9);
  if ((result & 1) == 0)
  {
    result = dword_1ECCE4EC0;
    if (4 * (int)qword_1ECCE4EB8 + 4 >= (3 * dword_1ECCE4EC0))
    {
      LODWORD(result) = 2 * dword_1ECCE4EC0;
    }
    else if (dword_1ECCE4EC0 + ~(_DWORD)qword_1ECCE4EB8 - HIDWORD(qword_1ECCE4EB8) > dword_1ECCE4EC0 >> 3)
    {
LABEL_11:
      v7 = v9;
      if (*v9 == -2)
      {
        qword_1ECCE4EB8 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE4EB8, (int32x2_t)0xFFFFFFFF00000001);
      }
      else if (*v9 == -1)
      {
        LODWORD(qword_1ECCE4EB8) = qword_1ECCE4EB8 + 1;
      }
      *v9 = this;
      v7[1] = a2;
      return result;
    }
    objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::grow(result);
    v9 = 0;
    result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::LookupBucketFor<objc_class *>((unint64_t)this, &v9);
    goto LABEL_11;
  }
  return result;
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::LookupBucketFor<objc_class *>(unint64_t a1, _QWORD *a2)
{
  int v2;
  unsigned int v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;

  if (dword_1ECCE4EC0)
  {
    v2 = dword_1ECCE4EC0 - 1;
    v3 = (dword_1ECCE4EC0 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093 * (a1 ^ (a1 >> 4))));
    v4 = (_QWORD *)(remappedClasses(BOOL)::remapped_class_map + 16 * v3);
    v5 = *v4;
    if (*v4 == a1)
    {
      v6 = 1;
    }
    else
    {
      v8 = 0;
      v9 = 1;
      while (v5 != -1)
      {
        if (v9 > dword_1ECCE4EC0)
          objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::FatalCorruptHashTables((_QWORD *)remappedClasses(BOOL)::remapped_class_map, dword_1ECCE4EC0);
        if (v8)
          v10 = 0;
        else
          v10 = v5 == -2;
        if (v10)
          v8 = v4;
        v11 = v3 + v9++;
        v3 = v11 & v2;
        v4 = (_QWORD *)(remappedClasses(BOOL)::remapped_class_map + 16 * (v11 & v2));
        v5 = *v4;
        v6 = 1;
        if (*v4 == a1)
          goto LABEL_5;
      }
      v6 = 0;
      if (v8)
        v4 = v8;
    }
  }
  else
  {
    v4 = 0;
    v6 = 0;
  }
LABEL_5:
  *a2 = v4;
  return v6;
}

NXHashTable *__cdecl NXCreateHashTable(NXHashTablePrototype *prototype, unsigned int capacity, const void *info)
{
  NXHashTable *v6;
  NXHashTable *v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  const NXHashTablePrototype *v11;
  _OWORD *v12;
  __int128 v13;
  char v14;
  char v15;
  BOOL v16;
  size_t v17;

  v6 = (NXHashTable *)malloc_type_malloc(0x20uLL, 0x10E00402E54A04BuLL);
  v7 = (NXHashTable *)prototypes;
  if (!prototypes)
  {
    v8 = malloc_type_malloc(8uLL, 0x587677AEuLL);
    free(v8);
    v9 = malloc_type_malloc(0x20uLL, 0x10E00402E54A04BuLL);
    prototypes = (uint64_t)v9;
    *v9 = &protoPrototype;
    v9[1] = 0x100000001;
    v10 = malloc_type_calloc(1uLL, 0x10uLL, 0x10C20406D26F19BuLL);
    v7 = (NXHashTable *)prototypes;
    *(_QWORD *)(prototypes + 16) = v10;
    v7->info = 0;
    *(_DWORD *)v10 = 1;
    v10[1] = &protoPrototype;
  }
  if (!prototype->hash)
    prototype->hash = NXPtrHash;
  if (!prototype->isEqual)
    prototype->isEqual = NXPtrIsEqual;
  if (!prototype->free)
    prototype->free = NXNoEffectFree;
  if (prototype->style)
  {
    _objc_inform("*** NXCreateHashTable: invalid style\n");
    return 0;
  }
  v11 = (const NXHashTablePrototype *)NXHashGet(v7, prototype);
  if (!v11)
  {
    v12 = malloc_type_malloc(0x20uLL, 0x1080040AA79BA9DuLL);
    v13 = *(_OWORD *)&prototype->free;
    *v12 = *(_OWORD *)&prototype->hash;
    v12[1] = v13;
    NXHashInsert((NXHashTable *)prototypes, v12);
    v11 = (const NXHashTablePrototype *)NXHashGet((NXHashTable *)prototypes, prototype);
    if (!v11)
    {
      _objc_inform("*** NXCreateHashTable: bug\n");
      return 0;
    }
  }
  v6->prototype = v11;
  v6->count = 0;
  v6->info = info;
  if (capacity >= 2)
  {
    v15 = -1;
    do
    {
      ++v15;
      v16 = capacity > 3;
      capacity >>= 1;
    }
    while (v16);
    v14 = v15 + 2;
  }
  else
  {
    v14 = 1;
  }
  v17 = ~(-1 << v14);
  v6->nbBuckets = v17;
  v6->buckets = malloc_type_calloc(v17, 0x10uLL, 0x10C20406D26F19BuLL);
  return v6;
}

void *__cdecl NXHashGet(NXHashTable *table, const void *data)
{
  _DWORD *buckets;
  unint64_t v5;
  int v6;
  char *v7;
  void **i;
  const void *v9;

  buckets = table->buckets;
  v5 = ((uint64_t (*)(const void *))table->prototype->hash)(table->info) % (unint64_t)table->nbBuckets;
  v6 = buckets[4 * v5];
  if (!v6)
    return 0;
  if (v6 == 1)
  {
    v7 = (char *)&buckets[4 * v5];
    v9 = (const void *)*((_QWORD *)v7 + 1);
    i = (void **)(v7 + 8);
    if (v9 != data)
    {
      if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
        return *i;
      return 0;
    }
  }
  else
  {
    for (i = *(void ***)&buckets[4 * v5 + 2]; *i != data; ++i)
    {
      if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
        return *i;
      if (!--v6)
        return 0;
    }
  }
  return (void *)data;
}

BOOL isEqualPrototype(const void *a1, _QWORD *a2, _QWORD *a3)
{
  return *a2 == *a3 && a2[1] == a3[1] && a2[2] == a3[2] && *((_DWORD *)a2 + 6) == *((_DWORD *)a3 + 6);
}

void _NXHashRehashToCapacity(uint64_t a1, unsigned int a2)
{
  void *v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int v10;
  _DWORD *v11;
  const void **v12;
  int v13;
  int i;

  v4 = malloc_type_malloc(0x20uLL, 0x10E00402E54A04BuLL);
  *(_QWORD *)v4 = *(_QWORD *)a1;
  *((_QWORD *)v4 + 1) = *(_QWORD *)(a1 + 8);
  *((_QWORD *)v4 + 2) = *(_QWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = a2;
  v5 = 0;
  *(_QWORD *)(a1 + 16) = malloc_type_calloc(a2, 0x10uLL, 0x10C20406D26F19BuLL);
  v6 = *((_DWORD *)v4 + 3);
  while (1)
  {
    v7 = *((_QWORD *)v4 + 2);
    if (!v5)
      break;
LABEL_7:
    --v5;
    v11 = (_DWORD *)(v7 + 16 * v6);
    v13 = *v11;
    v12 = (const void **)(v11 + 2);
    if (v13 != 1)
      v12 = (const void **)((char *)*v12 + 8 * v5);
    NXHashInsert((NXHashTable *)a1, *v12);
  }
  v8 = v6;
  v9 = (int *)(v7 + 16 * v6 - 16);
  while (v8)
  {
    --v8;
    v10 = *v9;
    v9 -= 4;
    v5 = v10;
    if (v10)
    {
      v6 = v8;
      goto LABEL_7;
    }
  }
  for (i = *((_DWORD *)v4 + 3); i; --i)
  {
    if (*(_DWORD *)v7)
    {
      if (*(_DWORD *)v7 != 1)
        free((void *)(*(_QWORD *)(v7 + 8) - 8));
      *(_DWORD *)v7 = 0;
      *(_QWORD *)(v7 + 8) = 0;
    }
    v7 += 16;
  }
  if (*((_DWORD *)v4 + 2) != *(_DWORD *)(a1 + 8))
    _objc_inform("*** hashtable: count differs after rehashing; probably indicates a broken invariant: there are x and y such as isE"
      "qual(x, y) is TRUE but hash(x) != hash (y)\n");
  free(*((void **)v4 + 2));
  free(v4);
}

void *__cdecl NXHashInsert(NXHashTable *table, const void *data)
{
  _QWORD *buckets;
  unint64_t v5;
  char *v6;
  _DWORD *v7;
  int v8;
  void *result;
  void **v10;
  const void *v11;
  char *v12;
  const void **v13;
  void **v14;
  void **v15;
  char *v16;
  const void **v17;
  uint64_t v18;
  _QWORD *v19;
  void *v20;
  unsigned int nbBuckets;
  unsigned int v22;

  buckets = table->buckets;
  v5 = ((uint64_t (*)(const void *))table->prototype->hash)(table->info) % (unint64_t)table->nbBuckets;
  v6 = (char *)&buckets[2 * v5];
  v7 = v6;
  v8 = *(_DWORD *)v6;
  if (*(_DWORD *)v6 != 1)
  {
    if (!v8)
    {
      result = 0;
      *(_DWORD *)v6 = 1;
      buckets[2 * v5 + 1] = data;
      ++table->count;
      return result;
    }
    v12 = (char *)&buckets[2 * v5];
    v15 = (void **)*((_QWORD *)v12 + 1);
    v13 = (const void **)(v12 + 8);
    v14 = v15;
    while (*v14 != data)
    {
      if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
      {
        result = *v14;
        goto LABEL_17;
      }
      ++v14;
      if (!--v8)
      {
        v16 = (char *)malloc_type_calloc((*v7 + 2), 8uLL, 0x80040B8603338uLL);
        v17 = (const void **)(v16 + 8);
        v18 = *v7;
        if ((_DWORD)v18)
          memmove(v16 + 16, *v13, 8 * v18);
        *v17 = data;
        free((char *)*v13 - 8);
        ++*v7;
        *v13 = v17;
LABEL_19:
        nbBuckets = table->nbBuckets;
        v22 = table->count + 1;
        table->count = v22;
        if (v22 > nbBuckets)
          _NXHashRehashToCapacity((uint64_t)table, (2 * nbBuckets) | 1);
        return 0;
      }
    }
    result = (void *)data;
LABEL_17:
    *v14 = (void *)data;
    return result;
  }
  v11 = (const void *)*((_QWORD *)v6 + 1);
  v10 = (void **)(v6 + 8);
  result = (void *)data;
  if (v11 != data)
  {
    if (!((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
    {
      v19 = malloc_type_calloc(3uLL, 8uLL, 0x80040B8603338uLL);
      v20 = *v10;
      v19[1] = data;
      v19[2] = v20;
      ++*v7;
      *v10 = v19 + 1;
      goto LABEL_19;
    }
    result = *v10;
  }
  *v10 = (void *)data;
  return result;
}

uint64_t hashPrototype(const void *a1, int *a2)
{
  return a2[6] ^ ((*((_QWORD *)a2 + 1) ^ *(_QWORD *)a2 ^ *((_QWORD *)a2 + 2)) >> 16) ^ *(_QWORD *)a2 ^ *((_QWORD *)a2 + 1) ^ *((_QWORD *)a2 + 2);
}

void freeBuckets(NXHashTable *a1)
{
  unsigned int nbBuckets;
  _QWORD *buckets;
  int v4;
  uint64_t v5;
  void (__cdecl *free)(const void *, void *);
  const void *info;
  uint64_t *v8;
  uint64_t v9;

  nbBuckets = a1->nbBuckets;
  if (nbBuckets)
  {
    buckets = a1->buckets;
    do
    {
      if (*(_DWORD *)buckets)
      {
        v4 = *(_DWORD *)buckets;
        v5 = buckets[1];
        free = a1->prototype->free;
        info = a1->info;
        if (*(_DWORD *)buckets == 1)
        {
          ((void (*)(const void *, _QWORD))free)(a1->info, buckets[1]);
        }
        else
        {
          v8 = (uint64_t *)buckets[1];
          do
          {
            --v4;
            v9 = *v8++;
            ((void (*)(const void *, uint64_t))free)(info, v9);
          }
          while (v4);
          ::free((void *)(v5 - 8));
        }
        *(_DWORD *)buckets = 0;
        buckets[1] = 0;
      }
      buckets += 2;
      --nbBuckets;
    }
    while (nbBuckets);
  }
}

id _objc_deallocOnMainThreadHelper(void *a1)
{
  return objc_msgSend(a1, sel_dealloc);
}

void objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  unint64_t *v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(unint64_t **)a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4)
    v8 = v7 + 1;
  else
    v8 = 4;
  *(_DWORD *)(a1 + 16) = v8;
  v9 = malloc_type_malloc(16 * v8, 0x64B88C75uLL);
  *(_QWORD *)a1 = v9;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
    {
      v11 = 16 * v10;
      do
      {
        *v9 = -1;
        v9 += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if ((_DWORD)v3)
    {
      v12 = 16 * v3;
      v13 = v4;
      do
      {
        v14 = *v13;
        if (*v13 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v18 = 0;
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::LookupBucketFor<objc_class *>(a1, v14, &v18);
          v15 = v18;
          *v18 = *v13;
          v15[1] = v13[1];
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 2;
        v12 -= 16;
      }
      while (v12);
    }
    free(v4);
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    v16 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v16)
    {
      v17 = 16 * v16;
      do
      {
        *v9 = -1;
        v9 += 2;
        v17 -= 16;
      }
      while (v17);
    }
  }
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::LookupBucketFor<objc_class *>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  unsigned int v11;
  BOOL v12;
  unsigned int v13;

  v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    v4 = v3 - 1;
    v5 = (v3 - 1) & (bswap64(0x8A970BE7488FDA55 * (a2 ^ (a2 >> 4))) ^ (1217387093 * (a2 ^ (a2 >> 4))));
    v6 = (_QWORD *)(*(_QWORD *)a1 + 16 * v5);
    v7 = *v6;
    if (*v6 == a2)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -1)
      {
        if (v11 > v3)
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, *(_QWORD **)a1, *(unsigned int *)(a1 + 16));
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -2;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(*(_QWORD *)a1 + 16 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a2)
          goto LABEL_5;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_5:
  *a3 = v6;
  return v8;
}

unint64_t method_t::getCachedDescription(unint64_t this)
{
  unint64_t StatusReg;
  unsigned int v3;
  char v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  char *v10;
  int v11;
  int *v12;
  int v13;
  unsigned int v14;
  unint64_t *v16;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v3, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  if (!byte_1ECCE4E28)
  {
    objc::methodDescriptionMap = 0;
    qword_1ECCE4E18 = 0;
    dword_1ECCE4E20 = 0;
    byte_1ECCE4E28 = 1;
  }
  v16 = 0;
  v5 = objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>(this, &v16);
  v6 = v16;
  if ((v5 & 1) == 0)
  {
    if (4 * (int)qword_1ECCE4E18 + 4 >= (3 * dword_1ECCE4E20))
    {
      objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::grow(2 * dword_1ECCE4E20);
      v16 = 0;
      objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>(this, &v16);
    }
    else
    {
      if (dword_1ECCE4E20 + ~(_DWORD)qword_1ECCE4E18 - HIDWORD(qword_1ECCE4E18) > dword_1ECCE4E20 >> 3)
      {
LABEL_13:
        if (*v6 == -2)
        {
          qword_1ECCE4E18 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE4E18, (int32x2_t)0xFFFFFFFF00000001);
        }
        else if (*v6 == -1)
        {
          LODWORD(qword_1ECCE4E18) = qword_1ECCE4E18 + 1;
        }
        *v6 = this;
        v6[1] = 0;
        v8 = v6 + 1;
        goto LABEL_18;
      }
      objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::grow(dword_1ECCE4E20);
      v16 = 0;
      objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>(this, &v16);
    }
    v6 = v16;
    goto LABEL_13;
  }
  v8 = v16 + 1;
  v7 = v16[1];
  if (!v7)
  {
LABEL_18:
    v9 = malloc_type_malloc(0x10uLL, 0x90040C859B4A5uLL);
    *v8 = (unint64_t)v9;
    v11 = this & 3;
    if ((this & 3) == 0 || v11 == 2)
    {
      v10 = *(char **)(this & 0xFFFFFFFFFFFFFFFCLL);
    }
    else if (v11 == 1)
    {
      v12 = (int *)(this & 0xFFFFFFFFFFFFFFFCLL);
      if (dataSegmentsRanges > (this & 0xFFFFFFFFFFFFFFFCLL) || *(_QWORD *)algn_1ECCE5978 <= (unint64_t)v12)
        v10 = *(char **)((char *)v12 + *v12);
      else
        v10 = (char *)&unk_1F25805A8 + *v12;
    }
    *v9 = v10;
    *(_QWORD *)(*v8 + 8) = method_t::types(this, (uint64_t)v10);
    v7 = *v8;
  }
  v13 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v14 = __ldxr(runtimeLock);
    if (v14 != v13)
      break;
    if (!__stlxr(0, runtimeLock))
      return v7;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v7;
}

void sub_18011E9B8(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>(unint64_t a1, _QWORD *a2)
{
  int v2;
  unsigned int v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;

  if (dword_1ECCE4E20)
  {
    v2 = dword_1ECCE4E20 - 1;
    v3 = (dword_1ECCE4E20 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093 * (a1 ^ (a1 >> 4))));
    v4 = (_QWORD *)(objc::methodDescriptionMap + 16 * v3);
    v5 = *v4;
    if (*v4 == a1)
    {
      v6 = 1;
    }
    else
    {
      v8 = 0;
      v9 = 1;
      while (v5 != -1)
      {
        if (v9 > dword_1ECCE4E20)
          objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::FatalCorruptHashTables((_QWORD *)objc::methodDescriptionMap, dword_1ECCE4E20);
        if (v8)
          v10 = 0;
        else
          v10 = v5 == -2;
        if (v10)
          v8 = v4;
        v11 = v3 + v9++;
        v3 = v11 & v2;
        v4 = (_QWORD *)(objc::methodDescriptionMap + 16 * (v11 & v2));
        v5 = *v4;
        v6 = 1;
        if (*v4 == a1)
          goto LABEL_5;
      }
      v6 = 0;
      if (v8)
        v4 = v8;
    }
  }
  else
  {
    v4 = 0;
    v6 = 0;
  }
LABEL_5:
  *a2 = v4;
  return v6;
}

void map_images(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t StatusReg;
  unsigned int v7;
  uint64_t v9;
  const char *v10;
  char *v11;
  int v12;
  unsigned int v13;
  char v14;

  v14 = 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v7, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  map_images_nolock(a1, a2, (uint64_t)&v14, a3);
  v12 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v13 = __ldxr(runtimeLock);
    if (v13 != v12)
      break;
    if (!__stlxr(0, runtimeLock))
      goto LABEL_11;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_11:
  if (v14)
  {
    if (DebugClassRXSigning == 2)
      _objc_fatal("class_rx signing mismatch", v9, v10, v11);
    if (!(DisableFaults | DisableClassROFaults) && getpid() != 1 && (is_root_ramdisk() & 1) == 0)
    {
      if (os_variant_has_internal_diagnostics())
        os_fault_with_payload();
    }
  }
}

void objc_setHook_getClass(objc_hook_getClass newValue, objc_hook_getClass *outOldValue)
{
  uint64_t (*v2)(const char *, objc_class **);
  BOOL (__cdecl *v3)(const char *, Class *);
  unint64_t v4;
  int v5;

  v2 = GetClassHook;
  *outOldValue = (objc_hook_getClass)GetClassHook;
  v3 = (BOOL (__cdecl *)(const char *, Class *))__ldxr((unint64_t *)&GetClassHook);
  if ((char *)v3 != (char *)v2)
  {
    __clrex();
LABEL_5:
    while (1)
    {
      *outOldValue = v3;
      v4 = __ldxr((unint64_t *)&GetClassHook);
      if ((BOOL (__cdecl *)(const char *, Class *))v4 != v3)
        break;
      if (__stlxr((unint64_t)newValue, (unint64_t *)&GetClassHook))
        goto LABEL_9;
      v5 = 1;
LABEL_10:
      v3 = (BOOL (__cdecl *)(const char *, Class *))v4;
      if (v5)
        return;
    }
    __clrex();
LABEL_9:
    v5 = 0;
    goto LABEL_10;
  }
  if (__stlxr((unint64_t)newValue, (unint64_t *)&GetClassHook))
    goto LABEL_5;
}

Ivar *__cdecl class_copyIvarList(Class cls, unsigned int *outCount)
{
  unint64_t StatusReg;
  unsigned int v5;
  Ivar *v7;
  uint64_t v8;
  _QWORD *v9;
  unsigned int *v10;
  unsigned int v11;
  Ivar *v12;
  uint64_t v13;
  const char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int *v21;
  int v22;
  unsigned int v23;

  if (!cls)
  {
    v7 = 0;
    if (outCount)
      *outCount = 0;
    return v7;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v5, runtimeLock))
      goto LABEL_9;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_9:
  v8 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
  v9 = (_QWORD *)(v8 & 0xFFFFFFFFFFFFFFFELL);
  if ((v8 & 1) != 0)
    v9 = (_QWORD *)*v9;
  v10 = (unsigned int *)v9[6];
  if (!v10 || (v11 = v10[1]) == 0)
  {
    v7 = 0;
    v20 = 0;
    if (!outCount)
      goto LABEL_22;
    goto LABEL_21;
  }
  v12 = (Ivar *)malloc_type_malloc(8 * (v11 + 1), 0x2004093837F09uLL);
  v16 = *v10;
  v17 = v10[1];
  v18 = v17 * (unint64_t)v16;
  if ((v18 & 0xFFFFFFFF00000000) != 0)
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v13, v14, v15, v17, v10, v16);
  v7 = v12;
  if ((_DWORD)v18)
  {
    v19 = 0;
    v20 = 0;
    v21 = v10 + 2;
    do
    {
      if (*(_QWORD *)((char *)v21 + v19))
        v12[v20++] = (Ivar)((char *)v21 + v19);
      v19 += v16;
    }
    while (v18 != v19);
  }
  else
  {
    v20 = 0;
  }
  v12[v20] = 0;
  if (outCount)
LABEL_21:
    *outCount = v20;
LABEL_22:
  v22 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v23 = __ldxr(runtimeLock);
    if (v23 != v22)
      break;
    if (!__stlxr(0, runtimeLock))
      return v7;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v7;
}

void sub_18011EE5C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *objc_copyClassNamesForImageHeader(header_info *a1, unsigned int *a2)
{
  unint64_t StatusReg;
  unsigned int v5;
  _QWORD *v7;
  header_info *v8;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v10;
  int v11;
  unsigned int v12;

  if (a1)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v5 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v5, runtimeLock))
        goto LABEL_9;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_9:
    v8 = (header_info *)FirstHeader;
    if (FirstHeader)
    {
      while ((header_info *)((char *)v8 + *(_QWORD *)v8) != a1)
      {
        PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v8);
        v10 = (_QWORD *)((char *)v8 + 24);
        if (PreoptimizedHeaderRW)
          v10 = (_QWORD *)PreoptimizedHeaderRW;
        v8 = (header_info *)(*v10 & 0xFFFFFFFFFFFFFFFCLL);
        if (!v8)
          goto LABEL_14;
      }
      v7 = copyClassNamesForImage_nolock(v8, a2);
    }
    else
    {
LABEL_14:
      v7 = 0;
      if (a2)
        *a2 = 0;
    }
    v11 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v12 = __ldxr(runtimeLock);
      if (v12 != v11)
        break;
      if (!__stlxr(0, runtimeLock))
        return v7;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  else
  {
    v7 = 0;
    if (a2)
      *a2 = 0;
  }
  return v7;
}

void sub_18011EFA0(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *copyClassNamesForImage_nolock(header_info *a1, unsigned int *a2)
{
  unint64_t *v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  objc_class *v10;
  const char *v11;
  char *v12;
  uint64_t v13;
  unint64_t v15;

  v15 = 0;
  v3 = (unint64_t *)header_info::classlist(a1, &v15);
  v4 = v15;
  v5 = malloc_type_malloc(8 * v15 + 8, 0x50040EE9192B6uLL);
  v6 = v5;
  if (v4)
  {
    v7 = 0;
    v8 = v5;
    v9 = v4;
    do
    {
      v10 = (objc_class *)remapClass(*v3);
      if (v10)
        v8[-v7] = objc_class::demangledName(v10, 0, v11, v12);
      else
        ++v7;
      ++v8;
      ++v3;
      --v9;
    }
    while (v9);
    v13 = v4 - v7;
  }
  else
  {
    v13 = 0;
  }
  v6[v13] = 0;
  if (a2)
    *a2 = v13;
  return v6;
}

void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer newValue, objc_hook_lazyClassNamer *oldOutValue)
{
  uint64_t (*v2)(objc_class *);
  const char *(__cdecl *v3)(Class);
  unint64_t v4;
  int v5;

  v2 = LazyClassNamerHook;
  *oldOutValue = (objc_hook_lazyClassNamer)LazyClassNamerHook;
  v3 = (const char *(__cdecl *)(Class))__ldxr((unint64_t *)&LazyClassNamerHook);
  if ((char *)v3 != (char *)v2)
  {
    __clrex();
LABEL_5:
    while (1)
    {
      *oldOutValue = v3;
      v4 = __ldxr((unint64_t *)&LazyClassNamerHook);
      if ((const char *(__cdecl *)(Class))v4 != v3)
        break;
      if (__stlxr((unint64_t)newValue, (unint64_t *)&LazyClassNamerHook))
        goto LABEL_9;
      v5 = 1;
LABEL_10:
      v3 = (const char *(__cdecl *)(Class))v4;
      if (v5)
        return;
    }
    __clrex();
LABEL_9:
    v5 = 0;
    goto LABEL_10;
  }
  if (__stlxr((unint64_t)newValue, (unint64_t *)&LazyClassNamerHook))
    goto LABEL_5;
}

void objc_addLoadImageFunc2(void (*a1)(char *, uint64_t), uint64_t a2, const char *a3, char *a4)
{
  unint64_t StatusReg;
  unsigned int v6;
  _QWORD *v8;
  uint64_t v9;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v11;
  int v12;
  unsigned int v13;
  void (*v14)(char *, uint64_t);
  char v15;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v6, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v8 = (_QWORD *)FirstHeader;
  if (FirstHeader)
  {
    do
    {
      if (preoptimized == 1 && (*((_BYTE *)v8 + v8[1] + 12) & 8) != 0 && *(_DWORD *)(headerInfoROs + 4) < 0x18u)
        v9 = 0;
      else
        v9 = (uint64_t)v8 + v8[2] + 16;
      a1((char *)v8 + *v8, v9);
      PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v8);
      v11 = v8 + 3;
      if (PreoptimizedHeaderRW)
        v11 = (_QWORD *)PreoptimizedHeaderRW;
      v8 = (_QWORD *)(*v11 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v8);
  }
  v14 = a1;
  v15 = 2;
  GlobalSmallVector<loadImageCallback,4u>::append((uint64_t *)&v14, a2, a3, a4);
  v12 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v13 = __ldxr(runtimeLock);
    if (v13 != v12)
      break;
    if (!__stlxr(0, runtimeLock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
}

void sub_18011F2A0(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void GlobalSmallVector<loadImageCallback,4u>::append(uint64_t *a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v5;
  uint64_t v6;
  int *v7;
  char *v8;
  _BYTE *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  const char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  const char *v26;
  char *v27;
  int v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;

  LODWORD(v5) = loadImageCallbacks[0];
  if (loadImageCallbacks[0] <= 3u)
  {
    v6 = *((unsigned __int8 *)a1 + 8);
    if ((v6 - 1) < 2)
    {
      v7 = &loadImageCallbacks[4 * loadImageCallbacks[0]];
      *((_QWORD *)v7 + 1) = *a1;
      *((_BYTE *)v7 + 16) = v6;
      goto LABEL_19;
    }
    v31 = *a1;
LABEL_25:
    _objc_fatal("Corrupt load image callback, unknown kind %u, func %p", a2, a3, a4, v6, v31);
  }
  if (loadImageCallbacks[0] == 4)
  {
    v8 = (char *)malloc_type_malloc(0x50uLL, 0x10C2040E6EFC850uLL);
    v5 = loadImageCallbacks[0];
    if (loadImageCallbacks[0])
    {
      v9 = v8 + 8;
      v10 = (unsigned __int8 *)&byte_1ECCE56B0;
      v11 = loadImageCallbacks[0];
      do
      {
        v12 = *v10;
        v13 = *((_QWORD *)v10 - 1);
        if ((v12 - 1) >= 2)
          _objc_fatal("Corrupt load image callback, unknown kind %u, func %p", a2, a3, a4, *v10, v13);
        v10 += 16;
        *((_QWORD *)v9 - 1) = v13;
        *v9 = v12;
        v9 += 16;
        --v11;
      }
      while (v11);
      v14 = v5;
    }
    else
    {
      v14 = 0;
    }
    v6 = *((unsigned __int8 *)a1 + 8);
    if ((v6 - 1) < 2)
    {
      v30 = &v8[16 * v14];
      *(_QWORD *)v30 = *a1;
      v30[8] = v6;
      qword_1ECCE56A8 = (uint64_t)v8;
      goto LABEL_19;
    }
    v31 = *a1;
    goto LABEL_25;
  }
  v15 = (char *)malloc_type_malloc(16 * (loadImageCallbacks[0] + 1), 0x10C2040E6EFC850uLL);
  v19 = (uint64_t)v15;
  if (loadImageCallbacks[0])
  {
    v20 = 0;
    v21 = 0;
    do
    {
      v22 = *(unsigned __int8 *)(qword_1ECCE56A8 + v20 + 8);
      v23 = *(_QWORD *)(qword_1ECCE56A8 + v20);
      if ((v22 - 1) >= 2)
        _objc_fatal("Corrupt load image callback, unknown kind %u, func %p", v16, v17, v18, v22, v23);
      v24 = &v15[v20];
      *(_QWORD *)v24 = v23;
      v24[8] = v22;
      ++v21;
      v20 += 16;
    }
    while (v21 < loadImageCallbacks[0]);
  }
  free((void *)qword_1ECCE56A8);
  qword_1ECCE56A8 = v19;
  v28 = *((unsigned __int8 *)a1 + 8);
  if ((v28 - 1) >= 2)
    _objc_fatal("Corrupt load image callback, unknown kind %u, func %p", v25, v26, v27, *((unsigned __int8 *)a1 + 8), *a1);
  v29 = v19 + 16 * loadImageCallbacks[0];
  *(_QWORD *)v29 = *a1;
  *(_BYTE *)(v29 + 8) = v28;
  LODWORD(v5) = loadImageCallbacks[0];
LABEL_19:
  loadImageCallbacks[0] = v5 + 1;
}

int __objc_personality_v0(int version, int actions, uint64_t exceptionClass, _Unwind_Exception *exceptionObject, _Unwind_Context *context)
{
  const char *v8;
  const void *v9;
  const void *CFA;

  if (PrintExceptions)
  {
    if ((actions & 0xA) != 0)
      v8 = "unwinding";
    else
      v8 = "searching";
    v9 = (const void *)(_Unwind_GetIP(context) - 1);
    CFA = (const void *)_Unwind_GetCFA(context);
    _objc_inform("EXCEPTIONS: %s through frame [ip=%p sp=%p] for exception %p", v8, v9, CFA, exceptionObject);
  }
  return __gxx_personality_v0();
}

void objc_setHook_getImageName(objc_hook_getImageName newValue, objc_hook_getImageName *outOldValue)
{
  uint64_t (*v2)(objc_class *, const char **);
  BOOL (__cdecl *v3)(Class, const char **);
  unint64_t v4;
  int v5;

  v2 = GetImageNameHook;
  *outOldValue = (objc_hook_getImageName)GetImageNameHook;
  v3 = (BOOL (__cdecl *)(Class, const char **))__ldxr((unint64_t *)&GetImageNameHook);
  if ((char *)v3 != (char *)v2)
  {
    __clrex();
LABEL_5:
    while (1)
    {
      *outOldValue = v3;
      v4 = __ldxr((unint64_t *)&GetImageNameHook);
      if ((BOOL (__cdecl *)(Class, const char **))v4 != v3)
        break;
      if (__stlxr((unint64_t)newValue, (unint64_t *)&GetImageNameHook))
        goto LABEL_9;
      v5 = 1;
LABEL_10:
      v3 = (BOOL (__cdecl *)(Class, const char **))v4;
      if (v5)
        return;
    }
    __clrex();
LABEL_9:
    v5 = 0;
    goto LABEL_10;
  }
  if (__stlxr((unint64_t)newValue, (unint64_t *)&GetImageNameHook))
    goto LABEL_5;
}

void objc_end_catch(void)
{
  if (PrintExceptions)
    _objc_inform("EXCEPTIONS: finishing handler");
  __cxa_end_catch();
}

BOOL objc_isUniquelyReferenced(objc_object *this)
{
  Class isa;
  os_unfair_lock_s *v3;
  int v4;
  unsigned int v5;
  char *v7;
  os_unfair_lock_s *v8;
  int v9;
  unsigned int v10;
  char *v11;

  if ((uint64_t)this < 1)
    return 0;
  if ((*(_BYTE *)(((uint64_t)this->isa & 0xFFFFFFFF8) + 0x20) & 4) != 0)
  {
    objc_object::sidetable_lock(this);
    isa = this->isa;
    if (((uint64_t)this->isa & 1) != 0)
    {
      v7 = (char *)((unint64_t)isa >> 45);
      if (((unint64_t)isa & 0x100000000000) != 0)
        v7 += objc_object::sidetable_getExtraRC_nolock(this);
                                                                   * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
      v9 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
      while (1)
      {
        v10 = __ldxr(&v8->_os_unfair_lock_opaque);
        if (v10 != v9)
          break;
        if (!__stlxr(0, &v8->_os_unfair_lock_opaque))
          return v7 == (char *)1;
      }
      __clrex();
      os_unfair_lock_unlock(v8);
      return v7 == (char *)1;
    }
                                                                 * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
    v4 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    while (1)
    {
      v5 = __ldxr(&v3->_os_unfair_lock_opaque);
      if (v5 != v4)
        break;
      if (!__stlxr(0, &v3->_os_unfair_lock_opaque))
        goto LABEL_16;
    }
    __clrex();
    os_unfair_lock_unlock(v3);
LABEL_16:
    v11 = (char *)objc_object::sidetable_retainCount(this);
  }
  else
  {
    v11 = (char *)-[objc_object retainCount](this, sel_retainCount);
  }
  v7 = v11;
  return v7 == (char *)1;
}

void objc_exception_rethrow(void)
{
  if (PrintExceptions)
    _objc_inform("EXCEPTIONS: rethrowing current exception");
  __cxa_rethrow();
}

id objc_begin_catch(void *exc_buf)
{
  const void *v1;

  if (PrintExceptions)
    _objc_inform("EXCEPTIONS: handling exception %p at %p", exc_buf, v1);
  return __cxa_begin_catch(exc_buf);
}

uint64_t __getSharedCachePreoptimizedProtocol_block_invoke(uint64_t result, unint64_t a2, int a3, _BYTE *a4)
{
  if (a3)
  {
    if (dataSegmentsRanges <= a2 && *(_QWORD *)algn_1ECCE5978 > a2)
    {
      **(_QWORD **)(result + 32) = a2;
      *a4 = 1;
    }
  }
  return result;
}

void objc_copyCppObjectAtomic(void *dest, const void *src, void (__cdecl *copyHelper)(void *, const void *))
{
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;

  v6 = (os_unfair_lock_s *)&CppObjectLocks[16
                                         * (unint64_t)(((src >> 4) ^ (src >> 9)) & 7)];
  v7 = (os_unfair_lock_s *)&CppObjectLocks[16
                                         * (unint64_t)(((dest >> 4) ^ (dest >> 9)) & 7)];
  locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::lockWith(&v6->_os_unfair_lock_opaque, &v7->_os_unfair_lock_opaque);
  ((void (*)(void *, const void *))copyHelper)(dest, src);
  locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith(v6, v7);
}

uint64_t _initializeSwiftRefcountingThenCallRelease(objc_object *a1, double a2)
{
  double Helper_x9__swift_retain;
  uint64_t v3;
  uint64_t v4;
  double Helper_x9__swift_release;
  uint64_t v6;
  uint64_t v7;

  Helper_x9__swift_retain = gotLoadHelper_x9__swift_retain(a2);
  *(_QWORD *)(v4 + 408) = *(_QWORD *)(v3 + 3656);
  Helper_x9__swift_release = gotLoadHelper_x9__swift_release(Helper_x9__swift_retain);
  *(_QWORD *)(v7 + 400) = *(_QWORD *)(v6 + 3632);
  return (*(uint64_t (**)(double))(v7 + 400))(Helper_x9__swift_release);
}

uint64_t _initializeSwiftRefcountingThenCallRetain(objc_object *a1, double a2)
{
  double Helper_x9__swift_retain;
  uint64_t v3;
  uint64_t v4;
  double Helper_x10__swift_release;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  Helper_x9__swift_retain = gotLoadHelper_x9__swift_retain(a2);
  *(_QWORD *)(v4 + 408) = *(_QWORD *)(v3 + 3656);
  Helper_x10__swift_release = gotLoadHelper_x10__swift_release(Helper_x9__swift_retain);
  *(_QWORD *)(v7 + 400) = *(_QWORD *)(v6 + 3632);
  return (*(uint64_t (**)(double))(v8 + 408))(Helper_x10__swift_release);
}

void tls_autoptr_direct_impl<_objc_pthread_data,(tls_key)0>::dtor_(char *a1)
{
  _QWORD *v2;
  void *v3;
  void *v4;
  uint64_t i;
  void *v6;

  if (a1)
  {
    v2 = *(_QWORD **)a1;
    if (*(_QWORD *)a1)
    {
      v3 = (void *)v2[1];
      if (v3)
        free(v3);
      free(v2);
    }
    v4 = (void *)*((_QWORD *)a1 + 1);
    if (v4)
      free(v4);
    for (i = 24; i != 56; i += 8)
    {
      v6 = *(void **)&a1[i];
      if (v6)
        free(v6);
    }
    free(*((void **)a1 + 7));
    free(a1);
  }
}

void _objc_setClassCopyFixupHandler(uint64_t a1)
{
  unint64_t StatusReg;
  unsigned int v3;
  uint64_t v5;
  _QWORD *v6;
  uint64_t *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v3, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  LODWORD(v5) = classCopyFixupHandlers;
  if (classCopyFixupHandlers == 1)
  {
    v6 = malloc_type_malloc(0x10uLL, 0x80040B8603338uLL);
    v5 = classCopyFixupHandlers;
    if (classCopyFixupHandlers)
    {
      v7 = &qword_1ECCE5680;
      v8 = v6;
      v9 = classCopyFixupHandlers;
      do
      {
        v10 = *v7++;
        *v8++ = v10;
        --v9;
      }
      while (v9);
      v11 = v5;
    }
    else
    {
      v11 = 0;
    }
    v6[v11] = a1;
    qword_1ECCE5680 = (uint64_t)v6;
  }
  else if (classCopyFixupHandlers)
  {
    qword_1ECCE5680 = (uint64_t)malloc_type_realloc((void *)qword_1ECCE5680, 8 * (classCopyFixupHandlers + 1), 0x80040B8603338uLL);
    LODWORD(v5) = classCopyFixupHandlers;
    *(_QWORD *)(qword_1ECCE5680 + 8 * classCopyFixupHandlers) = a1;
  }
  else
  {
    qword_1ECCE5680 = a1;
  }
  classCopyFixupHandlers = v5 + 1;
  v12 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v13 = __ldxr(runtimeLock);
    if (v13 != v12)
      break;
    if (!__stlxr(0, runtimeLock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
}

void sub_18011FAC8(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

id _objc_exception_destructor(id *a1)
{
  id v1;
  const char *ClassName;

  v1 = *a1;
  if (PrintExceptions)
  {
    ClassName = object_getClassName(*a1);
    _objc_inform("EXCEPTIONS: releasing completed exception %p (object %p, a %s)", a1, v1, ClassName);
  }
  return objc_msgSend(v1, sel_release);
}

void _objc_init()
{
  __objc2_class *v0;
  uint64_t i;
  char *v2;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t objc_selector;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  char **v14;
  char *v15;
  char v16;
  int v17;
  int v18;
  char *v19;
  char *v20;
  unint64_t v21;
  const char *v22;
  size_t *v23;
  uint64_t v24;
  _DWORD **v25;
  char *v26;
  char *v27;
  char *v28;
  unint64_t v29;
  const char **v30;
  int v31;
  char *v32;
  char *v33;
  uint64_t v34;
  const char *v35;
  char *v36;
  _QWORD __s[6];

  if ((_objc_init::initialized & 1) != 0)
    return;
  _objc_init::initialized = 1;
  if (MEMORY[0x1E0C84478] && getpid() == 1)
    objc_bp_assist_cfg_np();
  classInitLock = 0;
  pendingInitializeMapLock = 0;
  selLock = 0;
  loadMethodLock = 0;
  crashlog_lock = 0;
  objcMsgLogLock = 0;
  AltHandlerDebugLock = 0;
  AssociationsManagerLock = 0;
  runtimeLock[0] = 0;
  DemangleCacheLock = 0;
  v0 = Object;
  if (!issetugid())
  {
    if ((dyld_program_sdk_at_least() & 1) == 0)
      DisableAutoreleaseCoalescingLRU = 1;
    if ((_os_feature_enabled_simple_impl() & 1) == 0)
      DisableClassRXSigningEnforcement = 1;
    if ((_os_feature_enabled_simple_impl() & 1) == 0)
      DisableClassROFaults = 1;
    v14 = *_NSGetEnviron();
    if (v14)
    {
      v15 = *v14;
      if (*v14)
      {
        v16 = 0;
        v17 = 0;
        v18 = 0;
        do
        {
          if (!strncmp(v15, "Malloc", 6uLL)
            || !strncmp(v15, "DYLD", 4uLL)
            || !strncmp(v15, "NSZombiesEnabled", 0x10uLL))
          {
            v16 = 1;
          }
          if (!strncmp(v15, "OBJC_", 5uLL))
          {
            if (!strncmp(v15, "OBJC_HELP=", 0xAuLL))
            {
              v18 = 1;
            }
            else if (!strncmp(v15, "OBJC_PRINT_OPTIONS=", 0x13uLL))
            {
              v17 = 1;
            }
            else if (!strncmp(v15, "OBJC_DEBUG_POOL_DEPTH=", 0x16uLL))
            {
              v24 = strtol(v15 + 22, 0, 10);
              if ((unint64_t)(v24 + 1) <= 0x80000000 && (_DWORD)v24)
                objc::PageCountWarning = v24;
            }
            else
            {
              v20 = strchr(v15, 61);
              if (*v20)
              {
                v21 = 0;
                v22 = v20 + 1;
                v23 = (size_t *)&qword_1E0DF3C90;
                while (v21 >= 0x30 && !os_variant_allows_internal_security_policies()
                     || v22 - *v14 != *v23 + 1
                     || strncmp(*v14, (const char *)*(v23 - 2), *v23))
                {
                  ++v21;
                  v23 += 5;
                  if (v21 == 51)
                    goto LABEL_42;
                }
                v25 = (_DWORD **)((char *)&Settings + 40 * v21);
                if (!strcasecmp(v22, "fatal") || !strcasecmp(v22, "halt"))
                  **v25 = 2;
                else
                  **v25 = !strcasecmp(v22, "yes")
                       || !strcasecmp(v22, "warn")
                       || !strcasecmp(v22, "true")
                       || !strcasecmp(v22, "on")
                       || !strcasecmp(v22, "y")
                       || !strcmp(v22, "1");
              }
            }
          }
LABEL_42:
          v19 = v14[1];
          ++v14;
          v15 = v19;
        }
        while (v19);
        if ((v16 & 1) != 0)
        {
          v26 = getenv("DYLD_INSERT_LIBRARIES");
          v27 = getenv("NSZombiesEnabled");
          v28 = getenv("OBJC_DEBUG_POOL_ALLOCATION");
          if (getenv("MallocStackLogging")
            || getenv("MallocStackLoggingNoCompact")
            || v27 && (*v27 | 0x20) == 0x79)
          {
            v0 = Object;
            if (v28)
              goto LABEL_80;
            goto LABEL_77;
          }
          v0 = Object;
          if (v26)
          {
            v32 = strstr(v26, "libgmalloc");
            if (!v28)
            {
              if (v32)
LABEL_77:
                DebugPoolAllocation = 1;
            }
          }
        }
        else
        {
          v0 = Object;
        }
      }
      else
      {
        v17 = 0;
        v18 = 0;
      }
LABEL_80:
      if ((_os_feature_enabled_simple_impl() & 1) == 0)
        DisablePreoptCaches = 1;
      if (((v18 | v17) & 1) != 0)
      {
        if ((v18 & 1) != 0)
        {
          _objc_inform("Objective-C runtime debugging. Set variable=YES to enable.");
          _objc_inform("OBJC_HELP: describe available environment variables");
          if ((v17 & 1) != 0)
            _objc_inform("OBJC_HELP is set");
          _objc_inform("OBJC_PRINT_OPTIONS: list which options are set");
          if ((v17 & 1) == 0)
            goto LABEL_85;
        }
        else if ((v17 & 1) == 0)
        {
LABEL_85:
          v29 = 0;
          v30 = (const char **)off_1E0DF3C80;
          while (1)
          {
            if (v29 < 0x30 || os_variant_allows_internal_security_policies())
            {
              if ((v18 & 1) != 0)
              {
                _objc_inform("%s: %s", *v30, v30[1]);
                if ((v17 & 1) != 0)
                {
LABEL_90:
                  v31 = *(_DWORD *)*(v30 - 1);
                  if (v31 == 1)
                  {
                    _objc_inform("%s is set");
                  }
                  else if (v31 == 2)
                  {
                    _objc_inform("%s is fatal");
                  }
                }
              }
              else if ((v17 & 1) != 0)
              {
                goto LABEL_90;
              }
            }
            ++v29;
            v30 += 5;
            if (v29 == 51)
              goto LABEL_6;
          }
        }
        _objc_inform("OBJC_PRINT_OPTIONS is set");
        goto LABEL_85;
      }
    }
  }
LABEL_6:
  pthread_key_init_np();
  for (i = 0; i != 512; i += 64)
  {
    v2 = (char *)&sDataLists + i;
    *(_QWORD *)v2 = 0;
    *((_DWORD *)v2 + 2) = 0;
  }
  for (j = 0; j != 128; j += 16)
    PropertyLocks[j] = 0;
  for (k = 0; k != 128; k += 16)
    StructLocks[k] = 0;
  for (m = 0; m != 128; m += 16)
    CppObjectLocks[m] = 0;
  do
  {
    *v6 = 0;
    *((_QWORD *)v6 + 1) = 0;
    *((_QWORD *)v6 + 2) = 0;
    v6[6] = 0;
    *((_OWORD *)v6 + 2) = 0uLL;
    *((_OWORD *)v6 + 3) = 0uLL;
    v6 += 16;
  }
  while (v6 != (int *)&objc_debug_headerInfoRWs);
  static_init();
  v7 = 0;
  v8 = -1;
  v9 = -1;
  while (1)
  {
    objc_selector = _dyld_get_objc_selector();
    if (!objc_selector)
      break;
    v8 &= ~objc_selector;
    v9 &= objc_selector;
    v7 += 8;
    if (v7 == 120)
      goto LABEL_21;
  }
  v9 = 0;
  v8 = 0;
LABEL_21:
  objc::InterestingSelectorOnes = v9;
  objc::InterestingSelectorZeroes = v8;
  objc::disableEnforceClassRXPtrAuth = LODWORD(v0[10].vtable);
  objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::init((_QWORD *)0x20);
  objc::allocatedClasses = 0;
  qword_1ECCE5758 = 0;
  qword_1ECCE5760 = 0;
  old_terminate = (uint64_t (*)(void))std::set_terminate((std::terminate_handler)_objc_terminate);
  v11 = -1;
  do
    ++v11;
  while (objc_restartableRanges[2 * v11]);
  v12 = task_restartable_ranges_register();
  if ((_DWORD)v12)
  {
    v13 = v12;
    if ((_DWORD)v12 != 6)
    {
      v33 = mach_error_string(v12);
      _objc_fatal("task_restartable_ranges_register failed (result 0x%x: %s)", v34, v35, v36, v13, v33);
    }
    shouldUseRestartableRanges = 1;
  }
  __s[0] = 3;
  __s[1] = map_images;
  __s[2] = load_images;
  __s[3] = unmap_image;
  __s[4] = _objc_patch_root_of_class;
  _dyld_objc_register_callbacks();
  memset_s(__s, 0x28uLL, 0, 0x28uLL);
  didCallDyldNotifyRegister = 1;
}

_QWORD *objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::init(_QWORD *result)
{
  unsigned int v1;
  unsigned int v2;
  uint64_t v3;

  if ((_DWORD)result)
  {
    v1 = (4 * (int)result / 3u + 1) | ((4 * (int)result / 3u + 1) >> 1);
    v2 = v1 | (v1 >> 2) | ((v1 | (v1 >> 2)) >> 4);
    dword_1ECCE59C8 = (v2 | (v2 >> 8) | ((v2 | (v2 >> 8)) >> 16)) + 1;
    result = malloc_type_malloc(24 * dword_1ECCE59C8, 0x64B88C75uLL);
    objc::unattachedCategories = (uint64_t)result;
    qword_1ECCE59C0 = 0;
    if (dword_1ECCE59C8)
    {
      v3 = 24 * dword_1ECCE59C8;
      do
      {
        *result = -1;
        result += 3;
        v3 -= 24;
      }
      while (v3);
    }
  }
  else
  {
    objc::unattachedCategories = 0;
    qword_1ECCE59C0 = 0;
    dword_1ECCE59C8 = 0;
  }
  return result;
}

uint64_t _objc_exception_do_catch(uint64_t a1, uint64_t (***a2)(), objc_object ***a3)
{
  objc_object *v4;
  unint64_t v5;
  unint64_t StatusReg;
  unsigned int v7;
  unint64_t v9;
  objc_class *v10;
  int v11;
  unsigned int v12;

  if (*a2 == off_1E0DF3828)
  {
    v4 = **a3;
    *a3 = (objc_object **)v4;
    if ((uint64_t (**)())a1 == &OBJC_EHTYPE_id)
    {
      if (PrintExceptions)
        _objc_inform("EXCEPTIONS: catch(id)");
    }
    else
    {
      v5 = *(_QWORD *)(a1 + 16);
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v7 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr(runtimeLock))
      {
        if (!__stxr(v7, runtimeLock))
          goto LABEL_13;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_13:
      v9 = remapClass(v5);
      v10 = (objc_class *)v9;
      v11 = *(_DWORD *)(StatusReg + 24);
      do
      {
        v12 = __ldxr(runtimeLock);
        if (v12 != v11)
        {
          __clrex();
          os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
          if (!v10)
            goto LABEL_23;
          goto LABEL_19;
        }
      }
      while (__stlxr(0, runtimeLock));
      if (!v9)
      {
LABEL_23:
        if (PrintExceptions)
        {
          objc_class::nameForLogging(v10);
          _objc_inform("EXCEPTIONS: skipping catch(%s)");
        }
        return 0;
      }
LABEL_19:
      if (!exception_matcher(v10, v4))
        goto LABEL_23;
      if (PrintExceptions)
      {
        objc_class::nameForLogging(v10);
        _objc_inform("EXCEPTIONS: catch(%s)");
      }
    }
    return 1;
  }
  else
  {
    if (PrintExceptions)
      _objc_inform("EXCEPTIONS: skipping catch(?)");
    return 0;
  }
}

void sub_18012067C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

BOOL imp_removeBlock(IMP anImp)
{
  void (*v1)(void);
  unint64_t StatusReg;
  unsigned int v3;
  uint64_t *v5;
  uint64_t *v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  int v11;
  unsigned int v12;
  unint64_t v14;

  if (anImp)
  {
    v1 = anImp;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v3 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v3, runtimeLock))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_7:
    v14 = 0;
    v5 = pageAndIndexContainingIMP(v1, &v14);
    v6 = v5;
    if (v5)
    {
      v7 = (const void *)v5[v14];
      v5[v14] = v5[2];
      v5[2] = v14;
      v8 = HeadPageGroup;
      do
      {
        v9 = v8;
        v8 = *(_QWORD *)(v8 + 8);
        if (v8)
          v10 = v8 == (_QWORD)v5;
        else
          v10 = 1;
      }
      while (!v10);
      if (!v8)
      {
        *(_QWORD *)(v9 + 8) = v5;
        v5[1] = 0;
      }
    }
    else
    {
      v7 = 0;
    }
    v11 = *(_DWORD *)(StatusReg + 24);
    do
    {
      v12 = __ldxr(runtimeLock);
      if (v12 != v11)
      {
        __clrex();
        os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
        if (v6)
          goto LABEL_21;
        goto LABEL_23;
      }
    }
    while (__stlxr(0, runtimeLock));
    if (v5)
    {
LABEL_21:
      _Block_release(v7);
      LOBYTE(anImp) = 1;
      return (char)anImp;
    }
LABEL_23:
    LOBYTE(anImp) = 0;
  }
  return (char)anImp;
}

uint64_t *pageAndIndexContainingIMP(void (*a1)(void), unint64_t *a2)
{
  uint64_t *result;
  unint64_t v4;

  result = &HeadPageGroup;
  while (1)
  {
    result = (uint64_t *)*result;
    if (!result)
      break;
    v4 = (char *)a1 - (char *)(result + 4096);
    if (v4 >= 8
      && result + 6144 > (uint64_t *)a1
      && (char *)result + ((*(_QWORD *)(Trampolines + 8) - *(_QWORD *)Trampolines) & 0xFFFFFFFFFFFFFFF8) + 0x8000 <= (char *)a1)
    {
      if (a2)
        *a2 = v4 >> 3;
      return result;
    }
  }
  return result;
}

void objc_enumerateClasses(const void *image, const char *namePrefix, Protocol *conformingTo, Class subclassing, void *block)
{
  const void *v9;
  uint64_t v10;
  const void *v11;
  unint64_t *Class;
  char v13;
  _QWORD v14[8];

  if (image != (const void *)-1)
  {
    v9 = image;
    if (image)
    {
      image = (const void *)_dyld_get_dlopen_image_header();
      if (!image)
      {
        v10 = dyld_image_header_containing_address();
        if (!v9 || (v11 = (const void *)v10, image = v9, v11 != v9))
        {
          _objc_inform("unable to find mach header for image");
          return;
        }
      }
    }
    else
    {
      image = (const void *)dyld_image_header_containing_address();
      if (!image)
      {
        _objc_inform("unable to find caller's image");
        return;
      }
    }
  }
  _objc_beginClassEnumeration((uint64_t)image, (char *)namePrefix, (uint64_t)conformingTo, (uint64_t)subclassing, (uint64_t)v14);
  v13 = 0;
  do
  {
    Class = _objc_enumerateNextClass((uint64_t)v14);
    if (!Class)
      break;
    (*((void (**)(void *, unint64_t *, char *))block + 2))(block, Class, &v13);
  }
  while (!v13);
  if (v14[0] == -1)
    free((void *)v14[5]);
}

unint64_t *_objc_enumerateNextClass(uint64_t a1)
{
  unint64_t StatusReg;
  unsigned int v3;
  unint64_t v5;
  objc_class *v6;
  const char *v7;
  char *v8;
  unint64_t *v9;
  const void *v10;
  const char **v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char v18;
  unint64_t v19;
  const char *v20;
  char *v21;
  const char **v22;
  int v23;
  uint64_t Protocol;
  uint64_t v25;
  const char *v26;
  char *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  _BOOL4 v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  const char ***v42;
  uint64_t v43;
  uint64_t v44;
  const char **v45;
  int v46;
  uint64_t v47;
  unint64_t i;
  unint64_t *v49;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v51;
  uint64_t v52;
  int v53;
  unsigned int v54;
  uint64_t *v56;
  uint64_t v57;
  char v58;
  unint64_t v59;
  _QWORD v60[10];
  uint64_t *v61[8];
  const char ***v62;
  _QWORD v63[2];

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v3, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  if (*(_QWORD *)(a1 + 40))
  {
    v5 = *(_QWORD *)(a1 + 48);
  }
  else
  {
    v9 = (unint64_t *)FirstHeader;
    if (!FirstHeader)
      goto LABEL_93;
    v49 = *(unint64_t **)a1;
    while (v49 != (unint64_t *)((char *)v9 + *v9))
    {
      PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v9);
      v51 = v9 + 3;
      if (PreoptimizedHeaderRW)
        v51 = (_QWORD *)PreoptimizedHeaderRW;
      v9 = (unint64_t *)(*v51 & 0xFFFFFFFFFFFFFFFCLL);
      if (!v9)
        goto LABEL_93;
    }
    v52 = header_info::classlist((header_info *)v9, (unint64_t *)(a1 + 56));
    *(_QWORD *)(a1 + 40) = v52;
    if (!v52)
    {
LABEL_92:
      v9 = 0;
      goto LABEL_93;
    }
    v5 = 0;
    *(_QWORD *)(a1 + 48) = 0;
  }
  if (v5 >= *(_QWORD *)(a1 + 56))
    goto LABEL_92;
  v59 = StatusReg;
  do
  {
    *(_QWORD *)(a1 + 48) = v5 + 1;
    v6 = (objc_class *)remapClass(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v5));
    v9 = (unint64_t *)v6;
    if (!v6)
      goto LABEL_13;
    if (*(_QWORD *)(a1 + 8))
    {
      v10 = (const void *)objc_class::demangledName(v6, 0, v7, v8);
      if (memcmp(v10, *(const void **)(a1 + 8), *(_QWORD *)(a1 + 32)))
        goto LABEL_13;
    }
    v11 = *(const char ***)(a1 + 16);
    if (!v11)
      goto LABEL_77;
    v12 = v9;
    while (1)
    {
      v63[0] = 0;
      v13 = v12[4];
      v14 = (_QWORD *)(v13 & 0xF00007FFFFFFFF8);
      if ((unint64_t)(*v12 - 1) >= 0xF && (*(_DWORD *)v14 & 0x80000000) != 0)
      {
        v28 = *(_QWORD *)((v13 & 0xF00007FFFFFFFF8) + 8);
        v29 = v28 & 0xFFFFFFFFFFFFFFFELL;
        if ((v28 & 1) != 0)
        {
          v19 = *(_QWORD *)(v29 + 24);
        }
        else
        {
          v30 = *(_QWORD *)(v29 + 40);
          v19 = v30 & 0xFFFFFFFFFFFFFFFELL;
          if ((v30 & 1) != 0 || !v19)
          {
            v31 = v19 != 0;
            v19 = v30 & 0xFFFFFFFFFFFFFFFCLL | 2;
            if ((v31 & v30) == 0)
              v19 = 0;
          }
        }
      }
      else
      {
        if (v13 < 0)
        {
          v15 = *(_QWORD *)((v13 & 0xF00007FFFFFFFF8) + 8);
          v14 = (_QWORD *)(v15 & 0xFFFFFFFFFFFFFFFELL);
          if ((v15 & 1) != 0)
            v14 = (_QWORD *)*v14;
        }
        v16 = v14[5];
        v17 = v16 & 0xFFFFFFFFFFFFFFFELL;
        v18 = v16 | ((v16 & 0xFFFFFFFFFFFFFFFELL) == 0);
        if ((((v16 & 0xFFFFFFFFFFFFFFFELL) != 0) & v16) != 0)
          v19 = v16 & 0xFFFFFFFFFFFFFFFCLL | 2;
        else
          v19 = 0;
        if ((v18 & 1) == 0)
          v19 = v17;
      }
      v63[0] = v19;
      list_array_tt<unsigned long,protocol_list_t,RawPtr>::begin((uint64_t)v61, v63, v7, v8);
      list_array_tt<unsigned long,protocol_list_t,RawPtr>::end((uint64_t)v60, v63, v20, v21);
      while (!list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator==((uint64_t)v61, v60))
      {
        v22 = *v62;
        if (canonical_protocol)
          v23 = 0;
        else
          v23 = 0x20000000;
        if ((v23 & *((_DWORD *)*v62 + 17)) == 0)
        {
          Protocol = getProtocol(v22[1]);
          if (Protocol)
            v22 = (const char **)Protocol;
        }
        if (v22 == v11 || (protocol_conformsToProtocol_nolock((protocol_t *)v22, v11) & 1) != 0)
          goto LABEL_77;
        list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator++(v61, v25, v26, v27);
      }
      if ((unint64_t)(*v12 - 1) < 0xF)
      {
        v58 = 0;
        goto LABEL_48;
      }
      v32 = *(_DWORD *)(v12[4] & 0xF00007FFFFFFFF8);
      if ((v32 & 0x80000000) == 0)
        break;
LABEL_74:
      v12 = (_QWORD *)remapClass(v12[1]);
      if (!v12)
        goto LABEL_13;
    }
    v58 = v32 & 1;
LABEL_48:
    v61[0] = 0;
    v33 = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class const*>((unint64_t)v12, v61);
    if (v61[0] == (uint64_t *)(objc::unattachedCategories + 24 * dword_1ECCE59C8))
      v34 = 0;
    else
      v34 = v33;
    if (v34 != 1)
      goto LABEL_74;
    v35 = v61[0][2];
    v36 = v35 >> 1;
    v37 = (v35 & 1) != 0 ? (uint64_t *)v61[0][1] : v61[0] + 1;
    v38 = (v61[0][2] & 1) != 0 ? v36 : (v61[0][1] != 0);
    v56 = v37;
    v57 = v38;
    if (!(_DWORD)v38)
      goto LABEL_74;
    v39 = 0;
    while (1)
    {
      if ((v58 & 1) == 0)
      {
        v40 = *(_QWORD **)(v56[2 * v39] + 32);
        if (v40)
        {
          v43 = *v40;
          v42 = (const char ***)(v40 + 1);
          v41 = v43;
          if (v43)
            break;
        }
      }
LABEL_73:
      if (++v39 == v57)
        goto LABEL_74;
    }
    v44 = 8 * v41;
    while (1)
    {
      v45 = *v42;
      if (canonical_protocol)
        v46 = 0;
      else
        v46 = 0x20000000;
      if ((v46 & *((_DWORD *)*v42 + 17)) == 0)
      {
        v47 = getProtocol(v45[1]);
        if (v47)
          v45 = (const char **)v47;
      }
      if (v45 == v11 || (protocol_conformsToProtocol_nolock((protocol_t *)v45, v11) & 1) != 0)
        break;
      ++v42;
      v44 -= 8;
      if (!v44)
        goto LABEL_73;
    }
LABEL_77:
    if (!*(_QWORD *)(a1 + 24))
    {
LABEL_89:
      StatusReg = v59;
      realizeClassMaybeSwiftMaybeRelock((objc_class *)v9, 1);
      goto LABEL_93;
    }
    for (i = remapClass(v9[1]); i; i = remapClass(*(_QWORD *)(i + 8)))
    {
      if (i == *(_QWORD *)(a1 + 24))
        goto LABEL_89;
    }
LABEL_13:
    v5 = *(_QWORD *)(a1 + 48);
  }
  while (v5 < *(_QWORD *)(a1 + 56));
  v9 = 0;
  StatusReg = v59;
LABEL_93:
  v53 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v54 = __ldxr(runtimeLock);
    if (v54 != v53)
      break;
    if (!__stlxr(0, runtimeLock))
      return v9;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v9;
}

void sub_180120DDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  unsigned int *v13;
  int v15;
  unsigned int v16;

  v15 = *(_DWORD *)(v12 + 24);
  while (1)
  {
    v16 = __ldxr(v13);
    if (v16 != v15)
      break;
    if (!__stlxr(0, v13))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

Class objc_getRequiredClass(const char *name)
{
  uint64_t v1;
  const char *v2;
  char *v3;
  Class result;
  uint64_t v6;
  const char *v7;
  char *v8;

  if (!name)
    _objc_fatal("link error: class '%s' not found.", v1, v2, v3, 0);
  result = look_up_class((char *)name);
  if (!result)
    _objc_fatal("link error: class '%s' not found.", v6, v7, v8, name);
  return result;
}

uint64_t objc_loadClassref(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if ((result & 1) != 0)
  {
    result = (*(uint64_t (**)(unint64_t, _QWORD))((result & 0xFFFFFFFFFFFFFFFELL) + 8))(result & 0xFFFFFFFFFFFFFFFELL, 0);
    *a1 = result;
  }
  return result;
}

void protocol_addProtocol(Protocol *proto, Protocol *addition)
{
  unint64_t StatusReg;
  unsigned int v5;
  Class isa;
  objc_class *v8;
  uint64_t v9;
  int v10;
  unsigned int v11;

  if (proto && addition)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v5 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v5, runtimeLock))
        goto LABEL_8;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_8:
    if ((__objc2_class *)((uint64_t)proto->super.isa & 0xFFFFFFFF8) == __IncompleteProtocol)
    {
      if ((__objc2_class *)((uint64_t)addition->super.isa & 0xFFFFFFFF8) == __IncompleteProtocol)
      {
        protocol_t::demangledName((char **)addition);
        _objc_inform("protocol_addProtocol: added protocol '%s' is still under construction!");
      }
      else
      {
        isa = proto[2].super.isa;
        if (isa)
          v8 = (objc_class *)malloc_type_realloc(isa, 8 * *(_QWORD *)isa + 16, 0x89BCB4C0uLL);
        else
          v8 = (objc_class *)malloc_type_calloc(1uLL, 0x10uLL, 0xD9C3E683uLL);
        v9 = (*(_QWORD *)v8)++;
        *((_QWORD *)v8 + v9 + 1) = addition;
        proto[2].super.isa = v8;
      }
    }
    else
    {
      protocol_t::demangledName((char **)proto);
      _objc_inform("protocol_addProtocol: modified protocol '%s' is not under construction!");
    }
    v10 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v11 = __ldxr(runtimeLock);
      if (v11 != v10)
        break;
      if (!__stlxr(0, runtimeLock))
        return;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_180121030(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

Protocol *__cdecl objc_allocateProtocol(const char *name)
{
  unint64_t StatusReg;
  unsigned int v3;
  Protocol *v5;
  Protocol *v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  unint64_t v10;
  size_t v11;
  void *v12;
  int v13;
  unsigned int v14;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v3, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  if (!getProtocol(name))
  {
    v6 = (Protocol *)malloc_type_calloc(0x60uLL, 1uLL, 0x59DDB3E2uLL);
    v5 = v6;
    if (DisableNonpointerIsa || (HIWORD(OBJC_CLASS_____IncompleteProtocol.vtable) & 0x2000) != 0)
    {
      if (((unint64_t)__IncompleteProtocol & 0xFFFFFFF000000007) == 0)
      {
        v10 = (unint64_t)__IncompleteProtocol & 0xFFFFFFFF8;
        goto LABEL_14;
      }
    }
    else if (((unint64_t)__IncompleteProtocol & 0xFFFFFFF000000007) == 0)
    {
      v10 = (unint64_t)__IncompleteProtocol & 0xFFFFFFFF8 | 0x21A000000001;
LABEL_14:
      v6->super.isa = (Class)v10;
      LODWORD(v6[8].super.isa) = 96;
      v11 = strlen(name) + 1;
      if ((_dyld_is_memory_immutable() & 1) == 0)
      {
        v12 = malloc_type_malloc(v11, 0x3F84A03uLL);
        memcpy(v12, name, v11);
        name = (const char *)v12;
      }
      v5[1].super.isa = (Class)name;
      goto LABEL_17;
    }
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v7, v8, v9, __IncompleteProtocol);
  }
  v5 = 0;
LABEL_17:
  v13 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v14 = __ldxr(runtimeLock);
    if (v14 != v13)
      break;
    if (!__stlxr(0, runtimeLock))
      return v5;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v5;
}

void sub_1801211F0(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void _objc_atfork_parent()
{
  uint64_t v0;
  unint64_t StatusReg;
  os_unfair_lock_s *v2;
  int v3;
  unsigned int v4;
  uint64_t i;
  os_unfair_lock_s *v6;
  int v7;
  unsigned int v8;
  uint64_t j;
  os_unfair_lock_s *v10;
  int v11;
  unsigned int v12;
  unint64_t v13;
  os_unfair_lock_s *v14;
  int v15;
  unsigned int v16;
  unint64_t v17;
  os_unfair_lock_s *v18;
  os_unfair_lock_s *v19;
  int v20;
  unsigned int v21;
  unint64_t v22;
  os_unfair_lock_s *v23;
  int v24;
  unsigned int v25;
  unint64_t v26;
  int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;

  os_unfair_recursive_lock_unlock();
  v0 = 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  do
  {
    v2 = (os_unfair_lock_s *)&PropertyLocks[16 * v0];
    v3 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v4 = __ldxr(&v2->_os_unfair_lock_opaque);
      if (v4 != v3)
        break;
      if (!__stlxr(0, &v2->_os_unfair_lock_opaque))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_unlock(v2);
LABEL_7:
    ++v0;
  }
  while (v0 != 8);
  for (i = 0; i != 8; ++i)
  {
    v6 = (os_unfair_lock_s *)&StructLocks[16 * i];
    v7 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v8 = __ldxr(&v6->_os_unfair_lock_opaque);
      if (v8 != v7)
        break;
      if (!__stlxr(0, &v6->_os_unfair_lock_opaque))
        goto LABEL_14;
    }
    __clrex();
    os_unfair_lock_unlock(v6);
LABEL_14:
    ;
  }
  for (j = 0; j != 8; ++j)
  {
    v10 = (os_unfair_lock_s *)&CppObjectLocks[16 * j];
    v11 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v12 = __ldxr(&v10->_os_unfair_lock_opaque);
      if (v12 != v11)
        break;
      if (!__stlxr(0, &v10->_os_unfair_lock_opaque))
        goto LABEL_21;
    }
    __clrex();
    os_unfair_lock_unlock(v10);
LABEL_21:
    ;
  }
  v13 = 0;
  v14 = (os_unfair_lock_s *)&dword_1ECCE5B88;
  do
  {
    v15 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v16 = __ldxr(&v14->_os_unfair_lock_opaque);
      if (v16 != v15)
        break;
      if (!__stlxr(0, &v14->_os_unfair_lock_opaque))
        goto LABEL_28;
    }
    __clrex();
    os_unfair_lock_unlock(v14);
LABEL_28:
    v17 = v13 + 1;
    v18 = (os_unfair_lock_s *)((char *)&sDataLists + 64 * v13 + 64);
    if (v13 > 6)
      v18 = 0;
    v19 = v18 + 2;
    if (v13 <= 6)
      v14 = v19;
    else
      v14 = 0;
    ++v13;
  }
  while (v17 != 8);
  v20 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v21 = __ldxr((unsigned int *)&AssociationsManagerLock);
    if (v21 != v20)
      break;
    if (!__stlxr(0, (unsigned int *)&AssociationsManagerLock))
      goto LABEL_39;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
LABEL_39:
  v22 = 0;
  do
  {
    v24 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v25 = __ldxr(&v23->_os_unfair_lock_opaque);
      if (v25 != v24)
        break;
      if (!__stlxr(0, &v23->_os_unfair_lock_opaque))
        goto LABEL_45;
    }
    __clrex();
    os_unfair_lock_unlock(v23);
LABEL_45:
    v26 = v22 + 1;
    if (v22 <= 6)
    else
      v23 = 0;
    ++v22;
  }
  while (v26 != 8);
  v27 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v28 = __ldxr((unsigned int *)&classInitLock);
    if (v28 != v27)
      break;
    if (!__stlxr(0, (unsigned int *)&classInitLock))
      goto LABEL_54;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&classInitLock);
LABEL_54:
  v29 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v30 = __ldxr((unsigned int *)&pendingInitializeMapLock);
    if (v30 != v29)
      break;
    if (!__stlxr(0, (unsigned int *)&pendingInitializeMapLock))
      goto LABEL_59;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&pendingInitializeMapLock);
LABEL_59:
  v31 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v32 = __ldxr(runtimeLock);
    if (v32 != v31)
      break;
    if (!__stlxr(0, runtimeLock))
      goto LABEL_64;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_64:
  v33 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v34 = __ldxr((unsigned int *)&DemangleCacheLock);
    if (v34 != v33)
      break;
    if (!__stlxr(0, (unsigned int *)&DemangleCacheLock))
      goto LABEL_69;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&DemangleCacheLock);
LABEL_69:
  v35 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v36 = __ldxr((unsigned int *)&selLock);
    if (v36 != v35)
      break;
    if (!__stlxr(0, (unsigned int *)&selLock))
      goto LABEL_74;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
LABEL_74:
  v37 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v38 = __ldxr((unsigned int *)&objcMsgLogLock);
    if (v38 != v37)
      break;
    if (!__stlxr(0, (unsigned int *)&objcMsgLogLock))
      goto LABEL_79;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&objcMsgLogLock);
LABEL_79:
  v39 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v40 = __ldxr((unsigned int *)&AltHandlerDebugLock);
    if (v40 != v39)
      break;
    if (!__stlxr(0, (unsigned int *)&AltHandlerDebugLock))
      goto LABEL_84;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&AltHandlerDebugLock);
LABEL_84:
  v41 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v42 = __ldxr((unsigned int *)&crashlog_lock);
    if (v42 != v41)
      break;
    if (!__stlxr(0, (unsigned int *)&crashlog_lock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&crashlog_lock);
}

int *_objc_atfork_prepare()
{
  uint64_t v0;
  unint64_t StatusReg;
  unsigned int *v2;
  unsigned int v3;
  uint64_t i;
  unsigned int *v6;
  unsigned int v7;
  uint64_t j;
  unsigned int *v10;
  unsigned int v11;
  unint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unint64_t v17;
  char *v18;
  unsigned int *v19;
  unsigned int v20;
  unint64_t v22;
  int *result;
  unsigned int v24;
  unint64_t v26;
  unsigned int v27;
  unsigned int v29;
  unsigned int v31;
  unsigned int v33;
  unsigned int v35;
  unsigned int v37;
  unsigned int v39;
  unsigned int v41;

  ForkIsMultithreaded = pthread_is_threaded_np() != 0;
  os_unfair_recursive_lock_lock_with_options();
  v0 = 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  do
  {
    v2 = (unsigned int *)&PropertyLocks[16 * v0];
    v3 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(v2))
    {
      if (!__stxr(v3, v2))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_7:
    ++v0;
  }
  while (v0 != 8);
  for (i = 0; i != 8; ++i)
  {
    v6 = (unsigned int *)&StructLocks[16 * i];
    v7 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(v6))
    {
      if (!__stxr(v7, v6))
        goto LABEL_14;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_14:
    ;
  }
  for (j = 0; j != 8; ++j)
  {
    v10 = (unsigned int *)&CppObjectLocks[16 * j];
    v11 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(v10))
    {
      if (!__stxr(v11, v10))
        goto LABEL_21;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_21:
    ;
  }
  v13 = 0;
  v14 = (unsigned int *)&dword_1ECCE5B88;
  do
  {
    v15 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(v14))
    {
      if (!__stxr(v15, v14))
        goto LABEL_28;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_28:
    v17 = v13 + 1;
    v18 = (char *)&sDataLists + 64 * v13 + 64;
    if (v13 > 6)
      v18 = 0;
    v19 = (unsigned int *)(v18 + 8);
    if (v13 <= 6)
      v14 = v19;
    else
      v14 = 0;
    ++v13;
  }
  while (v17 != 8);
  v20 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&AssociationsManagerLock))
  {
    if (!__stxr(v20, (unsigned int *)&AssociationsManagerLock))
      goto LABEL_39;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_39:
  v22 = 0;
  do
  {
    v24 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr((unsigned int *)result))
    {
      if (!__stxr(v24, (unsigned int *)result))
        goto LABEL_45;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_45:
    v26 = v22 + 1;
    if (v22 <= 6)
    else
      result = 0;
    ++v22;
  }
  while (v26 != 8);
  v27 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(classInitLock))
  {
    if (!__stxr(v27, classInitLock))
      goto LABEL_54;
  }
  __clrex();
  result = (int *)os_unfair_lock_lock_with_options();
LABEL_54:
  v29 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(pendingInitializeMapLock))
  {
    if (!__stxr(v29, pendingInitializeMapLock))
      goto LABEL_59;
  }
  __clrex();
  result = (int *)os_unfair_lock_lock_with_options();
LABEL_59:
  v31 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v31, runtimeLock))
      goto LABEL_64;
  }
  __clrex();
  result = (int *)os_unfair_lock_lock_with_options();
LABEL_64:
  v33 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(DemangleCacheLock))
  {
    if (!__stxr(v33, DemangleCacheLock))
      goto LABEL_69;
  }
  __clrex();
  result = (int *)os_unfair_lock_lock_with_options();
LABEL_69:
  v35 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(selLock))
  {
    if (!__stxr(v35, selLock))
      goto LABEL_74;
  }
  __clrex();
  result = (int *)os_unfair_lock_lock_with_options();
LABEL_74:
  v37 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(objcMsgLogLock))
  {
    if (!__stxr(v37, objcMsgLogLock))
      goto LABEL_79;
  }
  __clrex();
  result = (int *)os_unfair_lock_lock_with_options();
LABEL_79:
  v39 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&AltHandlerDebugLock))
  {
    if (!__stxr(v39, (unsigned int *)&AltHandlerDebugLock))
      goto LABEL_84;
  }
  __clrex();
  result = (int *)os_unfair_lock_lock_with_options();
LABEL_84:
  v41 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&crashlog_lock))
  {
    if (!__stxr(v41, (unsigned int *)&crashlog_lock))
      return result;
  }
  __clrex();
  return (int *)os_unfair_lock_lock_with_options();
}

void _objc_beginClassEnumeration(uint64_t a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t StatusReg;
  unsigned int v8;
  uint64_t v10;
  char *v11;
  unsigned int v12;
  unsigned int v13;
  _QWORD *v14;
  _QWORD *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  int v23;
  unsigned int v24;
  unsigned int v25;

  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_QWORD *)a5 = a1;
  *(_QWORD *)(a5 + 8) = __s;
  *(_QWORD *)(a5 + 16) = a3;
  *(_QWORD *)(a5 + 24) = a4;
  if (__s)
    *(_QWORD *)(a5 + 32) = strlen(__s);
  if (a1 == -1)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v8 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v8, runtimeLock))
        goto LABEL_9;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_9:
    v10 = qword_1ECCE5760;
    if ((_DWORD)qword_1ECCE5760)
    {
      v11 = (char *)malloc_type_malloc(8 * qword_1ECCE5760, 0x64B88C75uLL);
      v25 = qword_1ECCE5758;
      memcpy(v11, (const void *)objc::allocatedClasses, 8 * v10);
      v12 = v25;
    }
    else
    {
      v11 = 0;
      v12 = 0;
    }
    v13 = v12;
    v14 = malloc_type_calloc(8uLL, v12, 0x9CB45D16uLL);
    v15 = v14;
    if (!v13)
      goto LABEL_26;
    v16 = v11;
    if ((_DWORD)v10)
    {
      v17 = 8 * v10;
      v16 = v11;
      while (*(_QWORD *)v16 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v16 += 8;
        v17 -= 8;
        if (!v17)
          goto LABEL_26;
      }
    }
    v18 = &v11[8 * v10];
    if (v16 == v18)
    {
LABEL_26:
      v19 = 0;
    }
    else
    {
      v19 = 0;
      v20 = *(_QWORD *)v16;
LABEL_20:
      if ((*(_DWORD *)(*(_QWORD *)(v20 + 32) & 0xF00007FFFFFFFF8) & 0x2000001) == 0x2000000)
        v14[v19++] = v20;
      while (1)
      {
        v16 += 8;
        if (v16 == v18)
          break;
        v20 = *(_QWORD *)v16;
        if (*(_QWORD *)v16 < 0xFFFFFFFFFFFFFFFELL)
        {
          if (v16 != v18)
            goto LABEL_20;
          break;
        }
      }
    }
    v21 = malloc_type_realloc(v14, 8 * v19, 0x80040B8603338uLL);
    if (v21)
      v22 = v21;
    else
      v22 = v15;
    *(_QWORD *)(a5 + 40) = v22;
    *(_QWORD *)(a5 + 48) = 0;
    *(_QWORD *)(a5 + 56) = v19;
    free(v11);
    v23 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v24 = __ldxr(runtimeLock);
      if (v24 != v23)
        break;
      if (!__stlxr(0, runtimeLock))
        return;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_180121B70(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void *objc_tls_direct_base<unsigned long,(tls_key)4,ReturnAutoreleaseInfo::TlsDealloc>::dtor_(uint64_t a1)
{
  unint64_t StatusReg;
  void *result;
  _QWORD *v3;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  result = (void *)(*(_QWORD *)(StatusReg + 352) & 0xFFFFFFFFFFFFFFFCLL);
  if (result)
  {
    v3 = (_QWORD *)(StatusReg + 352);
    do
    {
      *v3 = 0;
      v3[1] = 0;

      result = (void *)(*v3 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (result);
  }
  return result;
}

uintptr_t NXPtrHash(const void *info, const void *data)
{
  return (unint64_t)data ^ ((unint64_t)data >> 16);
}

int NXPtrIsEqual(const void *info, const void *data1, const void *data2)
{
  return data1 == data2;
}

uintptr_t NXStrHash(const void *info, const void *data)
{
  unsigned int v2;
  uintptr_t result;
  unsigned __int8 *v4;
  unsigned int v5;

  if (!data)
    return 0;
  v2 = *(unsigned __int8 *)data;
  if (!*(_BYTE *)data)
    return 0;
  result = 0;
  v4 = (unsigned __int8 *)data + 4;
  do
  {
    result ^= v2;
    if (!*(v4 - 3))
      break;
    result ^= (unint64_t)*(v4 - 3) << 8;
    if (!*(v4 - 2))
      break;
    result ^= (unint64_t)*(v4 - 2) << 16;
    if (!*(v4 - 1))
      break;
    result ^= (unint64_t)*(v4 - 1) << 24;
    v5 = *v4;
    v4 += 4;
    v2 = v5;
  }
  while (v5);
  return result;
}

int NXStrIsEqual(const void *info, const void *data1, const void *data2)
{
  int v3;

  if (data1 == data2)
    return 1;
  if (!data1)
  {
    v3 = *(unsigned __int8 *)data2;
    return v3 == 0;
  }
  v3 = *(unsigned __int8 *)data1;
  if (!data2)
    return v3 == 0;
  if (v3 != *(unsigned __int8 *)data2)
    return 0;
  return strcmp((const char *)data1, (const char *)data2) == 0;
}

uint64_t hashPtrStructKey(const void *a1, _QWORD *a2)
{
  return *a2 ^ (*a2 >> 16);
}

BOOL isEqualPtrStructKey(const void *a1, _QWORD *a2, _QWORD *a3)
{
  return *a2 == *a3;
}

void NXReallyFree(const void *info, void *data)
{
  free(data);
}

uintptr_t hashStrStructKey(const void *a1, const void **a2)
{
  return NXStrHash(a1, *a2);
}

uint64_t isEqualStrStructKey(const void *a1, const void **a2, const void **a3)
{
  return NXStrIsEqual(a1, *a2, *a3);
}

NXHashTable *__cdecl NXCreateHashTableFromZone(NXHashTablePrototype *prototype, unsigned int capacity, const void *info, void *zone)
{
  __int128 v4;
  NXHashTablePrototype v6;

  v4 = *(_OWORD *)&prototype->free;
  *(_OWORD *)&v6.hash = *(_OWORD *)&prototype->hash;
  *(_OWORD *)&v6.free = v4;
  return NXCreateHashTable(&v6, capacity, info);
}

void NXFreeHashTable(NXHashTable *table)
{
  freeBuckets(table);
  free(table->buckets);
  free(table);
}

void NXEmptyHashTable(NXHashTable *table)
{
  unsigned int nbBuckets;
  _QWORD *buckets;

  nbBuckets = table->nbBuckets;
  if (nbBuckets)
  {
    buckets = table->buckets;
    do
    {
      if (*(_DWORD *)buckets)
      {
        if (*(_DWORD *)buckets != 1)
          free((void *)(buckets[1] - 8));
        *(_DWORD *)buckets = 0;
        buckets[1] = 0;
      }
      buckets += 2;
      --nbBuckets;
    }
    while (nbBuckets);
  }
  table->count = 0;
}

void NXResetHashTable(NXHashTable *table)
{
  freeBuckets(table);
  table->count = 0;
}

BOOL NXCompareHashTables(NXHashTable *table1, NXHashTable *table2)
{
  int v4;
  signed int nbBuckets;
  char *buckets;
  uint64_t v7;
  char *v8;
  int v9;
  char *v10;
  const void **v11;
  int v12;
  int v13;

  if (table1 == table2)
  {
    LOBYTE(v13) = 1;
  }
  else if (table1->count == table2->count)
  {
    v4 = 0;
    nbBuckets = table1->nbBuckets;
    while (1)
    {
      buckets = (char *)table1->buckets;
      if (!v4)
        break;
LABEL_9:
      --v4;
      v10 = &buckets[16 * nbBuckets];
      v12 = *(_DWORD *)v10;
      v11 = (const void **)(v10 + 8);
      if (v12 != 1)
        v11 = (const void **)((char *)*v11 + 8 * v4);
      v13 = NXHashMember(table2, *v11);
      if (!v13)
        return v13;
    }
    v7 = nbBuckets;
    v8 = &buckets[16 * nbBuckets - 16];
    while (v7)
    {
      --v7;
      v9 = *(_DWORD *)v8;
      v8 -= 16;
      v4 = v9;
      if (v9)
      {
        nbBuckets = v7;
        goto LABEL_9;
      }
    }
    LOBYTE(v13) = 1;
  }
  else
  {
    LOBYTE(v13) = 0;
  }
  return v13;
}

int NXHashMember(NXHashTable *table, const void *data)
{
  _DWORD *buckets;
  unint64_t v5;
  int v6;
  char *v7;
  const void **i;

  buckets = table->buckets;
  v5 = ((uint64_t (*)(const void *))table->prototype->hash)(table->info) % (unint64_t)table->nbBuckets;
  v6 = buckets[4 * v5];
  if (v6)
  {
    v7 = (char *)&buckets[4 * v5];
    if (v6 == 1)
    {
      if (*((const void **)v7 + 1) != data)
        return ((uint64_t (*)(const void *, const void *))table->prototype->isEqual)(table->info, data) != 0;
    }
    else
    {
      for (i = (const void **)*((_QWORD *)v7 + 1);
            *i != data
         && !((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data);
            ++i)
      {
        if (!--v6)
          return v6;
      }
    }
    return 1;
  }
  return v6;
}

unsigned int NXCountHashTable(NXHashTable *table)
{
  return table->count;
}

NXHashState NXInitHashState(NXHashTable *table)
{
  return (NXHashState)table->nbBuckets;
}

int NXNextHashState(NXHashTable *table, NXHashState *state, void **data)
{
  char *buckets;
  int j;
  int i;
  uint64_t v6;
  int *v7;
  int v8;
  int v9;
  int v10;
  char *v11;
  void **v12;
  int v13;

  buckets = (char *)table->buckets;
  i = state->i;
  j = state->j;
  if (j)
  {
LABEL_6:
    v10 = j - 1;
    state->j = v10;
    v11 = &buckets[16 * i];
    v13 = *(_DWORD *)v11;
    v12 = (void **)(v11 + 8);
    if (v13 != 1)
      v12 = (void **)((char *)*v12 + 8 * v10);
    *data = *v12;
    return 1;
  }
  else
  {
    v6 = i;
    v7 = (int *)&buckets[16 * i - 16];
    while (v6)
    {
      v8 = v6 - 1;
      v9 = *v7;
      v7 -= 4;
      j = v9;
      state->i = v6 - 1;
      state->j = v9;
      --v6;
      if (v9)
      {
        i = v8;
        goto LABEL_6;
      }
    }
    return 0;
  }
}

NXHashTable *__cdecl NXCopyHashTable(NXHashTable *table)
{
  signed int nbBuckets;
  NXHashTable *v3;
  size_t v4;
  int v5;
  char *buckets;
  uint64_t v7;
  char *v8;
  int v9;
  char *v10;
  const void **v11;
  int v12;

  nbBuckets = table->nbBuckets;
  v3 = (NXHashTable *)malloc_type_malloc(0x20uLL, 0x10E00402E54A04BuLL);
  v3->prototype = table->prototype;
  v3->info = table->info;
  v4 = table->nbBuckets;
  v3->count = 0;
  v3->nbBuckets = v4;
  v5 = 0;
  v3->buckets = malloc_type_calloc(v4, 0x10uLL, 0x10C20406D26F19BuLL);
  while (1)
  {
    buckets = (char *)table->buckets;
    if (!v5)
      break;
LABEL_7:
    --v5;
    v10 = &buckets[16 * nbBuckets];
    v12 = *(_DWORD *)v10;
    v11 = (const void **)(v10 + 8);
    if (v12 != 1)
      v11 = (const void **)((char *)*v11 + 8 * v5);
    NXHashInsert(v3, *v11);
  }
  v7 = nbBuckets;
  v8 = &buckets[16 * nbBuckets - 16];
  while (v7)
  {
    --v7;
    v9 = *(_DWORD *)v8;
    v8 -= 16;
    v5 = v9;
    if (v9)
    {
      nbBuckets = v7;
      goto LABEL_7;
    }
  }
  return v3;
}

void *__cdecl NXHashInsertIfAbsent(NXHashTable *table, const void *data)
{
  _QWORD *buckets;
  unint64_t v5;
  char *v6;
  _DWORD *v7;
  int v8;
  void **v9;
  const void *v10;
  char *v11;
  const void **v12;
  void **v13;
  void **v14;
  char *v15;
  const void **v16;
  uint64_t v17;
  _QWORD *v18;
  void *v19;
  unsigned int nbBuckets;
  unsigned int v21;

  buckets = table->buckets;
  v5 = ((uint64_t (*)(const void *))table->prototype->hash)(table->info) % (unint64_t)table->nbBuckets;
  v6 = (char *)&buckets[2 * v5];
  v7 = v6;
  v8 = *(_DWORD *)v6;
  if (*(_DWORD *)v6 == 1)
  {
    v10 = (const void *)*((_QWORD *)v6 + 1);
    v9 = (void **)(v6 + 8);
    if (v10 != data)
    {
      if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
      {
        return *v9;
      }
      else
      {
        v18 = malloc_type_calloc(3uLL, 8uLL, 0x80040B8603338uLL);
        v19 = *v9;
        v18[1] = data;
        v18[2] = v19;
        ++*v7;
        *v9 = v18 + 1;
LABEL_16:
        nbBuckets = table->nbBuckets;
        v21 = table->count + 1;
        table->count = v21;
        if (v21 > nbBuckets)
          _NXHashRehashToCapacity((uint64_t)table, (2 * nbBuckets) | 1);
      }
    }
  }
  else if (v8)
  {
    v11 = (char *)&buckets[2 * v5];
    v14 = (void **)*((_QWORD *)v11 + 1);
    v12 = (const void **)(v11 + 8);
    v13 = v14;
    while (*v13 != data)
    {
      if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
        return *v13;
      ++v13;
      if (!--v8)
      {
        v15 = (char *)malloc_type_calloc((*v7 + 2), 8uLL, 0x80040B8603338uLL);
        v16 = (const void **)(v15 + 8);
        v17 = *v7;
        if ((_DWORD)v17)
          memmove(v15 + 16, *v12, 8 * v17);
        *v16 = data;
        free((char *)*v12 - 8);
        ++*v7;
        *v12 = v16;
        goto LABEL_16;
      }
    }
  }
  else
  {
    *(_DWORD *)v6 = 1;
    buckets[2 * v5 + 1] = data;
    ++table->count;
  }
  return (void *)data;
}

void *__cdecl NXHashRemove(NXHashTable *table, const void *data)
{
  char *buckets;
  unint64_t v5;
  int *v6;
  int v7;
  char *v8;
  const void **v9;
  const void *v10;
  int v11;
  char *v12;
  const void **v13;
  const void **v14;
  const void **v15;
  const void **v16;
  const void **v17;
  int v18;
  size_t v19;
  char *v20;
  int v21;
  char *v22;
  unsigned int v23;
  int v25;

  buckets = (char *)table->buckets;
  v5 = ((uint64_t (*)(const void *))table->prototype->hash)(table->info) % (unint64_t)table->nbBuckets;
  v6 = (int *)&buckets[16 * v5];
  v7 = *v6;
  if (!*v6)
    return 0;
  if (v7 == 1)
  {
    v8 = &buckets[16 * v5];
    v10 = (const void *)*((_QWORD *)v8 + 1);
    v9 = (const void **)(v8 + 8);
    if (v10 == data)
    {
      v11 = 0;
      goto LABEL_16;
    }
    if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
    {
      data = *v9;
      v11 = *v6 - 1;
LABEL_16:
      --table->count;
      *v6 = v11;
      *v9 = 0;
      return (void *)data;
    }
    return 0;
  }
  v12 = &buckets[16 * v5];
  v15 = (const void **)*((_QWORD *)v12 + 1);
  v14 = (const void **)(v12 + 8);
  v13 = v15;
  if (v7 == 2)
  {
    if (*v13 == data
      || ((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
    {
      v16 = v13 + 1;
      v17 = v13;
      goto LABEL_10;
    }
    v17 = v13 + 1;
    if (v13[1] == data)
    {
      v16 = v13;
      goto LABEL_10;
    }
    v25 = ((uint64_t (*)(const void *, const void *))table->prototype->isEqual)(table->info, data);
    v16 = v13;
    if (v25)
    {
LABEL_10:
      *v14 = *v16;
      data = *v17;
      free(v13 - 1);
      --table->count;
      --*v6;
      return (void *)data;
    }
    return 0;
  }
  while (1)
  {
    v18 = v7 - 1;
    if (*v13 == data)
      break;
    if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
    {
      data = *v13;
      break;
    }
    ++v13;
    --v7;
    if (!v18)
      return 0;
  }
  v19 = *v6;
  if ((_DWORD)v19 == 1)
  {
    v20 = 0;
    v21 = 1;
  }
  else
  {
    v20 = (char *)malloc_type_calloc(v19, 8uLL, 0x80040B8603338uLL) + 8;
    v21 = *v6;
  }
  v22 = (char *)*v14;
  v23 = v21 - v7;
  if (v23)
  {
    memmove(v20, v22, 8 * v23);
    v22 = (char *)*v14;
  }
  if (v7 != 1)
  {
    memmove(&v20[8 * *v6 - 8 + -8 * (v7 - 1)], &v22[8 * *v6 + -8 * (v7 - 1)], 8 * (v7 - 1));
    v22 = (char *)*v14;
  }
  free(v22 - 8);
  --table->count;
  --*v6;
  *v14 = v20;
  return (void *)data;
}

uint64_t hashPrototype(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)a2 ^ *(_QWORD *)(a2 + 8) ^ *(int *)(a2 + 24) ^ ((*(_QWORD *)a2 ^ *(_QWORD *)(a2 + 8) ^ *(_QWORD *)(a2 + 16)) >> 16) ^ *(_QWORD *)(a2 + 16);
}

BOOL isEqualPrototype(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_QWORD *)a2 == *(_QWORD *)a3
      && *(_QWORD *)(a2 + 8) == *(_QWORD *)(a3 + 8)
      && *(_QWORD *)(a2 + 16) == *(_QWORD *)(a3 + 16)
      && *(_DWORD *)(a2 + 24) == *(_DWORD *)(a3 + 24);
}

_DWORD *NXCreateMapTableFromZone(_OWORD *a1, unsigned int a2)
{
  __int128 v2;
  _OWORD v4[2];

  v2 = a1[1];
  v4[0] = *a1;
  v4[1] = v2;
  return NXCreateMapTable(v4, a2);
}

void NXFreeMapTable(_QWORD *a1)
{
  NXResetMapTable((uint64_t)a1);
  free((void *)(a1[2] - 16));
  free(a1);
}

uint64_t NXResetMapTable(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t (*v3)(uint64_t, uint64_t, _QWORD);
  int v4;
  _QWORD *v5;
  uint64_t v6;

  v1 = result;
  v2 = *(_DWORD *)(result + 12);
  if (v2 != -1)
  {
    v3 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)result + 16);
    v4 = v2 + 1;
    v5 = (_QWORD *)(*(_QWORD *)(result + 16) + 8);
    do
    {
      v6 = *(v5 - 1);
      if (v6 != -1)
      {
        result = v3(v1, v6, *v5);
        *(v5 - 1) = -1;
        *v5 = 0;
      }
      v5 += 2;
      --v4;
    }
    while (v4);
  }
  *(_DWORD *)(v1 + 8) = 0;
  return result;
}

uint64_t NXCompareMapTables(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t *v6;
  _BOOL8 v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v13;

  if (a1 == a2)
    return 1;
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  v4 = *(_DWORD *)(a1 + 12) + 1;
LABEL_4:
  v5 = v4;
  v6 = (uint64_t *)(*(_QWORD *)(a1 + 16) + 16 * v4 - 16);
  while (1)
  {
    v7 = v5 == 0;
    if (!v5)
      return v7;
    --v5;
    v9 = *v6;
    v6 -= 2;
    v8 = v9;
    if (v9 != -1)
    {
      v10 = (**(uint64_t (***)(uint64_t, uint64_t))a2)(a2, v8);
      v11 = _NXMapMemberWithHash(a2, v8, v10, &v13);
      v4 = v5;
      if (v11 != -1)
        goto LABEL_4;
      return v7;
    }
  }
}

uint64_t NXInitMapState(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 12) + 1);
}

uint64_t NXNextMapState(uint64_t a1, int *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 16);
  v5 = *a2;
  v6 = (uint64_t *)(v4 + 16 * v5 - 16);
  while (v5)
  {
    --v5;
    v8 = *v6;
    v6 -= 2;
    v7 = v8;
    if (v8 != -1)
    {
      *a2 = v5;
      *a3 = v7;
      *a4 = *(_QWORD *)(v4 + 16 * v5 + 8);
      return 1;
    }
  }
  result = 0;
  *a2 = -1;
  return result;
}

uint64_t NXMapMember(uint64_t (***a1)(_QWORD), uint64_t a2, _QWORD *a3)
{
  unsigned int v6;

  v6 = (**a1)(a1);
  return _NXMapMemberWithHash((uint64_t)a1, a2, v6, a3);
}

uint64_t NXCountMapTable(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t NXMapGet(uint64_t (***a1)(_QWORD), uint64_t a2)
{
  unsigned int v4;
  uint64_t v6;

  v4 = (**a1)(a1);
  v6 = 0;
  if (_NXMapMemberWithHash((uint64_t)a1, a2, v4, &v6) == -1)
    return 0;
  else
    return v6;
}

uint64_t NXMapGetWithHash(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = 0;
  if (_NXMapMemberWithHash(a1, a2, a3, &v4) == -1)
    return 0;
  else
    return v4;
}

uint64_t NXMapRemove(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int v15;
  unsigned int v16;
  _QWORD *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  char v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a1 + 12) & (**(unsigned int (***)(uint64_t))a1)(a1);
  v6 = *(_QWORD *)(v4 + 16 * v5);
  if (v6 == -1)
    return 0;
  if (v6 == a2 || (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, v6, a2))
  {
    v7 = *(_QWORD *)(v4 + 16 * v5 + 8);
    v8 = 1;
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  v9 = *(_DWORD *)(a1 + 12) & (v5 + 1);
  v10 = 1;
  while (v9 != (_DWORD)v5)
  {
    v11 = *(_QWORD *)(v4 + 16 * v9);
    if (v11 == -1)
      break;
    v12 = v9;
    if (v11 == a2 || (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, v11, a2))
    {
      ++v8;
      v7 = *(_QWORD *)(v4 + 16 * v12 + 8);
    }
    ++v10;
    v9 = *(_DWORD *)(a1 + 12) & (v12 + 1);
  }
  if (!v8)
    return 0;
  if (v8 != 1)
    _objc_inform("**** NXMapRemove: incorrect table\n");
  if (v10 < 0x11)
  {
    v13 = &v24;
    if (!v10)
    {
      v15 = 0;
      goto LABEL_26;
    }
  }
  else
  {
    v13 = (char *)malloc_type_malloc(16 * (v10 - 1), 0xC0040D1025EB5uLL);
  }
  v15 = 0;
  v16 = v10;
  do
  {
    v17 = (_QWORD *)(v4 + 16 * v5);
    if (*v17 != a2 && !(*(unsigned int (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 8))(a1, *v17, a2))
      *(_OWORD *)&v13[16 * v15++] = *(_OWORD *)v17;
    *v17 = -1;
    *(_QWORD *)(v4 + 16 * v5 + 8) = 0;
    LODWORD(v5) = *(_DWORD *)(a1 + 12) & (v5 + 1);
    --v16;
  }
  while (v16);
LABEL_26:
  *(_DWORD *)(a1 + 8) -= v10;
  if (v15 == v10 - 1)
  {
    if (!v15)
      goto LABEL_30;
  }
  else
  {
    _objc_inform("**** NXMapRemove: bug\n");
    if (!v15)
      goto LABEL_30;
  }
  v18 = v15 - 1;
  do
  {
    v19 = v18;
    v20 = (uint64_t *)&v13[16 * v18];
    v21 = *v20;
    v22 = v20[1];
    v23 = (**(uint64_t (***)(uint64_t, uint64_t))a1)(a1, *v20);
    NXMapInsertWithHash(a1, v21, v23, v22);
    --v18;
  }
  while (v19);
LABEL_30:
  if (v10 >= 0x11)
    free(v13);
  return v7;
}

uint64_t objc_cache_buckets(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFLL;
}

uint64_t objc_cache_preoptCache(_QWORD *a1)
{
  return (*a1 & 0xFFFFFFFFFFFELL) - 16;
}

BOOL objc_cache_isConstantOptimizedCache(uint64_t *a1, char a2, uint64_t a3)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t v6;

  v4 = *a1;
  result = *a1 & 1;
  if ((v4 & 1) == 0 && (a2 & 1) == 0)
  {
    v6 = HIWORD(*a1);
    return v4 != a3 && v6 == 0;
  }
  return result;
}

uint64_t objc_cache_preoptCapacity(_QWORD *a1)
{
  return (*(unsigned __int16 *)((*a1 & 0xFFFFFFFFFFFELL) - 8) >> 5) + 1;
}

uint64_t objc_cache_preoptFallbackClass(_QWORD *a1)
{
  return (uint64_t)a1 + *(_QWORD *)((*a1 & 0xFFFFFFFFFFFELL) - 16) - 16;
}

uint64_t objc_cache_bytesForCapacity(unsigned int a1)
{
  return 16 * a1;
}

uint64_t objc_cache_occupied(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 12);
}

uint64_t objc_cache_capacity(_QWORD *a1)
{
  if (HIWORD(*a1))
    return HIWORD(*a1) + 1;
  else
    return 0;
}

void object_setIvarWithStrongDefault(id obj, Ivar ivar, id value)
{
  uint64_t v3;
  uint64_t v4;
  id *v7;
  unsigned int v8;
  _QWORD v9[5];

  if ((uint64_t)obj >= 1 && ivar)
  {
    v9[3] = v3;
    v9[4] = v4;
    v9[0] = 0;
    v8 = 0;
    _class_lookUpIvar(*(_QWORD *)obj & 0xFFFFFFFF8, (unsigned int *)ivar, (char *)v9, (char *)&v8);
    v7 = (id *)((char *)obj + v9[0]);
    if (v8 < 2)
    {
      objc_storeStrong(v7, value);
    }
    else if (v8 == 3)
    {
      *v7 = value;
    }
    else if (v8 == 2)
    {
      objc_storeWeak(v7, value);
    }
  }
}

Ivar object_setInstanceVariable(id obj, const char *name, void *value)
{
  char *v3;
  unsigned int *Variable;
  id *v7;
  int v9;
  uint64_t v10;

  Variable = 0;
  if ((uint64_t)obj >= 1)
  {
    if (name)
    {
      Variable = (unsigned int *)_class_getVariable((objc_class *)(*(_QWORD *)obj & 0xFFFFFFFF8), name, (const char *)value, v3);
      if (Variable)
      {
        v10 = 0;
        v9 = 0;
        _class_lookUpIvar(*(_QWORD *)obj & 0xFFFFFFFF8, Variable, (char *)&v10, (char *)&v9);
        v7 = (id *)((char *)obj + v10);
        switch(v9)
        {
          case 0:
          case 3:
            *v7 = value;
            break;
          case 1:
            objc_storeStrong(v7, value);
            break;
          case 2:
            objc_storeWeak(v7, value);
            break;
          default:
            return (Ivar)Variable;
        }
      }
    }
  }
  return (Ivar)Variable;
}

Ivar object_getInstanceVariable(id obj, const char *name, void **outValue)
{
  char *v3;
  objc_class *v6;
  objc_ivar *Variable;
  objc_ivar *v8;
  id Ivar;

  if ((uint64_t)obj < 1)
    goto LABEL_8;
  if (!name)
    goto LABEL_8;
  v6 = (objc_class *)(*(_QWORD *)obj & 0xFFFFFFFF8);
  if (!v6)
    goto LABEL_8;
  Variable = (objc_ivar *)_class_getVariable(v6, name, (const char *)outValue, v3);
  v8 = Variable;
  if (outValue && Variable)
  {
    Ivar = object_getIvar(obj, Variable);
LABEL_9:
    *outValue = Ivar;
    return v8;
  }
  if (!Variable)
  {
LABEL_8:
    Ivar = 0;
    v8 = 0;
    if (outValue)
      goto LABEL_9;
  }
  return v8;
}

Ivar class_getClassVariable(Class cls, const char *name)
{
  const char *v2;
  char *v3;
  objc_class *v4;

  if (cls && name && (v4 = (objc_class *)(*(_QWORD *)cls & 0xFFFFFFFF8)) != 0)
    return (Ivar)_class_getVariable(v4, name, v2, v3);
  else
    return 0;
}

BOOL class_respondsToMethod(Class cls, SEL sel)
{
  if ((class_respondsToMethod::warned & 1) == 0)
  {
    class_respondsToMethod::warned = 1;
    _objc_inform_deprecated("class_respondsToMethod", sel);
  }
  return class_respondsToSelector_inst(0, (objc_selector *)sel, cls);
}

IMP class_lookupMethod(Class cls, SEL sel)
{
  char *v2;
  int v5;
  IMP result;

  if ((class_lookupMethod::warned & 1) != 0)
  {
    if (sel)
      goto LABEL_3;
LABEL_17:
    __objc_error((objc_object *)cls, sel, v2);
  }
  class_lookupMethod::warned = 1;
  _objc_inform_deprecated("class_lookupMethod", sel);
  if (!sel)
    goto LABEL_17;
LABEL_3:
  if (!cls)
    return 0;
  v5 = *(_DWORD *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8);
  if ((v5 & 1) == 0)
    v5 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)cls & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v5 & 0x20000000) != 0
    && ((result = (IMP)cache_getImp((uint64_t)cls, (unint64_t)sel, 0)) != 0
     || (*((_QWORD *)cls + 2) & 1) != 0
     && (result = (IMP)cache_getImp((uint64_t)cls + *(_QWORD *)((*((_QWORD *)cls + 2) & 0xFFFFFFFFFFFELL) - 16), (unint64_t)sel, 0)) != 0))
  {
    if (result == _objc_msgForward_impcache)
      result = 0;
  }
  else
  {
    result = lookUpImpOrForward(0, (objc_selector *)sel, cls, 7u);
  }
  if (!result)
    return _objc_msgForward;
  return result;
}

char *copyPropertyAttributeString(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  const char **v5;
  uint64_t v6;
  size_t v7;
  size_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  char *v12;
  int v13;
  uint64_t v14;
  const char *v15;
  char *v16;
  char *result;
  char *v18;

  if (!a2)
    return strdup("");
  v3 = 0;
  v4 = a2;
  v5 = (const char **)(a1 + 8);
  v6 = a2;
  do
  {
    if (*v5)
    {
      v7 = strlen(*(v5 - 1));
      if (v7 <= 1)
        v8 = v7;
      else
        v8 = v7 + 2;
      v3 += strlen(*v5) + v8 + 1;
    }
    v5 += 2;
    --v6;
  }
  while (v6);
  v9 = (char *)malloc_type_malloc(v3 + 1, 0x7CD87uLL);
  v10 = &v9[v3 + 1];
  v11 = (_QWORD *)(a1 + 8);
  v18 = v9;
  v12 = v9;
  do
  {
    if (*v11)
    {
      if (strlen((const char *)*(v11 - 1)) <= 1)
        v13 = snprintf(v12, v10 - v12, "%s%s,");
      else
        v13 = snprintf(v12, v10 - v12, "\"%s\"%s,");
      if (v10 - v12 < (unint64_t)v13)
        _objc_fatal("Incorrect buffer calculation for property string. Partial string is %s, calculated length is %zu.", v14, v15, v16, v18, v3);
      v12 += v13;
    }
    v11 += 2;
    --v4;
  }
  while (v4);
  result = v18;
  if (v12 > v18)
    *(v12 - 1) = 0;
  return result;
}

void _objc_crashlog(const char *__s1)
{
  unint64_t StatusReg;
  unsigned int v3;
  void *v5;
  size_t v6;
  const char *v7;
  char v8;
  char *v9;
  size_t v10;
  int v11;
  unsigned int v12;
  char *v13;

  v13 = 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)&crashlog_lock))
  {
    if (!__stxr(v3, (unsigned int *)&crashlog_lock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v5 = (void *)__crashreporter_info__;
  if (__crashreporter_info__)
  {
    v6 = strlen((const char *)__crashreporter_info__);
    if (v6 < 0x1F41)
    {
      asprintf(&v13, "%s\n%s", (const char *)__crashreporter_info__, __s1);
    }
    else
    {
      v7 = (const char *)(v6 + __crashreporter_info__ - 8001);
      do
        v8 = *++v7;
      while ((v8 & 0xC0) == 0x80);
      asprintf(&v13, "... %s\n%s", v7, __s1);
    }
    v9 = v13;
    if (v13)
      goto LABEL_15;
  }
  else
  {
    v9 = strdup(__s1);
    v13 = v9;
    if (v9)
    {
LABEL_15:
      v10 = strlen(v9) - 1;
      if (v9[v10] == 10)
        v9[v10] = 0;
      if (v5)
        free(v5);
      __crashreporter_info__ = (uint64_t)v13;
    }
  }
  v11 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v12 = __ldxr((unsigned int *)&crashlog_lock);
    if (v12 != v11)
      break;
    if (!__stlxr(0, (unsigned int *)&crashlog_lock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&crashlog_lock);
}

void sub_1801231B0(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)&crashlog_lock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void _objc_exception_abort1(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  _objc_fatal("unexpected call into objc exception typeinfo vtable %d", a2, a3, a4, 1);
}

void _objc_exception_abort2(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  _objc_fatal("unexpected call into objc exception typeinfo vtable %d", a2, a3, a4, 2);
}

void _objc_exception_abort3(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  _objc_fatal("unexpected call into objc exception typeinfo vtable %d", a2, a3, a4, 3);
}

void _objc_exception_abort4(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  _objc_fatal("unexpected call into objc exception typeinfo vtable %d", a2, a3, a4, 4);
}

uint64_t _objc_exception_false()
{
  return 0;
}

uint64_t _objc_default_exception_matcher(__objc2_class *a1, unint64_t a2)
{
  __objc2_class *v2;

  if ((a2 & 0x8000000000000000) != 0)
  {
    v2 = (__objc2_class *)objc_debug_taggedpointer_classes[a2 & 7];
    if (v2 == __NSUnrecognizedTaggedPointer)
      v2 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[(a2 >> 55)];
  }
  else
  {
    v2 = (__objc2_class *)(*(_QWORD *)a2 & 0xFFFFFFFF8);
  }
  if (!v2)
    return 0;
  while (v2 != a1)
  {
    v2 = v2->superclass;
    if (!v2)
      return 0;
  }
  return 1;
}

uint64_t _objc_terminate(void)
{
  if (PrintExceptions)
    _objc_inform("EXCEPTIONS: terminating");
  if (__cxa_current_exception_type())
    __cxa_rethrow();
  return old_terminate();
}

void sub_180123350(void *a1, int a2)
{
  objc_object *v3;

  v3 = (objc_object *)objc_begin_catch(a1);
  if (a2 == 2)
    v3 = (objc_object *)uncaught_handler(v3);
  ((void (*)(objc_object *))old_terminate)(v3);
  objc_end_catch();
}

void sub_180123394(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void performForkChildInitialize(objc_class *this, objc_class *a2, const char *a3, char *a4)
{
  objc_class *v6;
  void (*v7)(void);
  void (*v8)(void);
  BOOL v9;
  const void *v10;
  char *v11;
  const void *v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  const char *v17;
  char *v18;

  if (*((_QWORD *)this + 1))
  {
    v6 = (objc_class *)(*(_QWORD *)this & 0xFFFFFFFF8);
    if (v6 != this)
    {
      v7 = lookUpImpOrNilTryCache(*(_QWORD *)((*(_QWORD *)v6 & 0xFFFFFFFF8) + 8), (unint64_t)sel_initialize, (_QWORD *)(**(_QWORD **)((*(_QWORD *)v6 & 0xFFFFFFFF8) + 8) & 0xFFFFFFFF8), 0);
      v8 = lookUpImpOrNilTryCache((uint64_t)this, (unint64_t)sel_initialize, (_QWORD *)(*(_QWORD *)this & 0xFFFFFFFF8), 0);
      v9 = !v8 || (char *)v8 == (char *)objc_noop_imp;
      if (!v9 && v8 != v7)
      {
        if (PrintInitializing)
        {
          v12 = *(const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          v13 = objc_class::nameForLogging(this);
          _objc_inform("INITIALIZE: thread %p: refusing to call +[%s initialize] in fork() child process because it may have been in progress when fork() was called", v12, v13);
        }
        v14 = objc_class::nameForLogging(this);
        _objc_inform_now_and_on_crash("+[%s initialize] may have been in progress in another thread when fork() was called.", v14);
        gdb_objc_class_changed();
        v15 = objc_class::nameForLogging(this);
        _objc_fatal("+[%s initialize] may have been in progress in another thread when fork() was called. We cannot safely call it or ignore it in the fork() child process. Crashing instead. Set a breakpoint on objc_initializeAfterForkError to debug.", v16, v17, v18, v15);
      }
    }
  }
  if (PrintInitializing)
  {
    v10 = *(const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v11 = objc_class::nameForLogging(this);
    _objc_inform("INITIALIZE: thread %p: skipping trivial +[%s initialize] in fork() child process", v10, v11);
  }
  lockAndFinishInitializing(this, a2, a3, a4);
}

void _objc_addWillInitializeClassFunc(void (*a1)(uint64_t), uint64_t a2, const char *a3, char *a4)
{
  unint64_t StatusReg;
  unsigned int v7;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  _OWORD *v15;
  __int128 *v16;
  _OWORD *v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  void (**v21)(uint64_t);
  void (**v22)(uint64_t);
  int v23;
  unsigned int v24;
  unint64_t v25;
  unint64_t v26;
  unsigned int v27;

  v27 = 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(classInitLock))
  {
    if (!__stxr(v7, classInitLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v9 = objc_copyRealizedClassList(&v27, a2, a3, a4);
  v10 = v9;
  v11 = v27;
  if (v27)
  {
    v12 = v9;
    do
    {
      v13 = *(_DWORD *)(*(_QWORD *)(*v12 + 32) & 0xF00007FFFFFFFF8);
      if ((v13 & 1) == 0)
        v13 = *(_DWORD *)(*(_QWORD *)((*(_QWORD *)*v12 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
      if ((v13 & 0x10000000) == 0 && (v13 & 0x20000000) == 0)
        *v12 = 0;
      ++v12;
      --v11;
    }
    while (v11);
  }
  LODWORD(v14) = willInitializeFuncs;
  if (willInitializeFuncs == 1)
  {
    v15 = malloc_type_malloc(0x20uLL, 0x80040803F642BuLL);
    v14 = willInitializeFuncs;
    if (willInitializeFuncs)
    {
      v16 = &xmmword_1EDBFC330;
      v17 = v15;
      v18 = willInitializeFuncs;
      do
      {
        v19 = *v16++;
        *v17++ = v19;
        --v18;
      }
      while (v18);
      v20 = v14;
    }
    else
    {
      v20 = 0;
    }
    v22 = (void (**)(uint64_t))&v15[v20];
    *v22 = a1;
    v22[1] = (void (*)(uint64_t))a2;
    *(_QWORD *)&xmmword_1EDBFC330 = v15;
  }
  else if (willInitializeFuncs)
  {
    *(_QWORD *)&xmmword_1EDBFC330 = malloc_type_realloc((void *)xmmword_1EDBFC330, 16 * (willInitializeFuncs + 1), 0x80040803F642BuLL);
    LODWORD(v14) = willInitializeFuncs;
    v21 = (void (**)(uint64_t))(xmmword_1EDBFC330 + 16 * willInitializeFuncs);
    *v21 = a1;
    v21[1] = (void (*)(uint64_t))a2;
  }
  else
  {
    *(_QWORD *)&xmmword_1EDBFC330 = a1;
    *((_QWORD *)&xmmword_1EDBFC330 + 1) = a2;
  }
  willInitializeFuncs = v14 + 1;
  v23 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v24 = __ldxr(classInitLock);
    if (v24 != v23)
      break;
    if (!__stlxr(0, classInitLock))
      goto LABEL_29;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)classInitLock);
LABEL_29:
  v25 = v27;
  if (v27)
  {
    v26 = 0;
    do
    {
      if (v10[v26])
      {
        a1(a2);
        v25 = v27;
      }
      ++v26;
    }
    while (v26 < v25);
  }
  free(v10);
}

void sub_18012370C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)classInitLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *objc_copyRealizedClassList_nolock(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  _QWORD v11[6];
  int v12;
  _QWORD v13[5];
  unsigned int v14;

  v14 = 0;
  v5 = MEMORY[0x1E0C809B0];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3321888768;
  v13[2] = ___ZL33objc_copyRealizedClassList_nolockPj_block_invoke;
  v13[3] = &__block_descriptor_40_e8_32c49_ZTSKZL33objc_copyRealizedClassList_nolockPjE3__0_e8_B16__0_8l;
  v13[4] = &v14;
  foreach_realized_class((uint64_t)v13, a2, a3, a4);
  if (!v14)
  {
    v6 = 0;
    if (!a1)
      return v6;
    goto LABEL_3;
  }
  v12 = 0;
  v6 = malloc_type_malloc(8 * (v14 + 1), 0x80040B8603338uLL);
  v11[0] = v5;
  v11[1] = 3321888768;
  v11[2] = ___ZL33objc_copyRealizedClassList_nolockPj_block_invoke_36;
  v11[3] = &__block_descriptor_48_e8_32c49_ZTSKZL33objc_copyRealizedClassList_nolockPjE3__1_e8_B16__0_8l;
  v11[4] = &v12;
  v11[5] = v6;
  foreach_realized_class((uint64_t)v11, v7, v8, v9);
  v6[v12] = 0;
  if (a1)
LABEL_3:
    *a1 = v14;
  return v6;
}

uint64_t ___ZL33objc_copyRealizedClassList_nolockPj_block_invoke(uint64_t a1)
{
  ++**(_DWORD **)(a1 + 32);
  return 1;
}

uint64_t foreach_realized_class(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  int v5;
  uint64_t result;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v5 = *(_DWORD *)(gdb_objc_realized_classes + 8);
  if (DisablePreopt)
    result = 0;
  else
    result = _dyld_objc_class_count();
  v7 = _firstRealizedClass;
  if (_firstRealizedClass)
  {
    v8 = 16 * (result + v5) + 16;
    do
    {
      if (!--v8)
LABEL_20:
        _objc_fatal("Memory corruption in class list.", a2, a3, a4);
      v9 = v7;
      while (1)
      {
        if ((*(_WORD *)(v9 + 30) & 4) != 0
          || (result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 16))(a1, v9), !(_DWORD)result)
          || (v10 = *(_QWORD *)((*(_QWORD *)(v9 + 32) & 0xF00007FFFFFFFF8) + 0x10)) == 0)
        {
          while (1)
          {
            v10 = *(_QWORD *)((*(_QWORD *)(v9 + 32) & 0xF00007FFFFFFFF8) + 0x18);
            if (v9 == v7 || v10)
              break;
            v9 = *(_QWORD *)(v9 + 8);
            if (!--v8)
              goto LABEL_20;
          }
          if (v9 == v7)
            break;
        }
        v9 = v10;
        if (!--v8)
          goto LABEL_20;
      }
      v7 = *(_QWORD *)((*(_QWORD *)(v7 + 32) & 0xF00007FFFFFFFF8) + 0x18);
    }
    while (v7);
  }
  return result;
}

uint64_t ___ZL33objc_copyRealizedClassList_nolockPj_block_invoke_36(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _DWORD *v3;
  uint64_t v4;

  v3 = *(_DWORD **)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  v4 = *v3;
  *v3 = v4 + 1;
  *(_QWORD *)(v2 + 8 * v4) = a2;
  return 1;
}

__n128 __copy_helper_block_e8_32c49_ZTSKZL33objc_copyRealizedClassList_nolockPjE3__1(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[2] = result;
  return result;
}

uint64_t __copy_helper_block_e8_32c49_ZTSKZL33objc_copyRealizedClassList_nolockPjE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::grow(int a1)
{
  uint64_t v1;
  unint64_t *v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  unint64_t *v14;

  v1 = dword_1ECCE4E20;
  v2 = (unint64_t *)objc::methodDescriptionMap;
  v3 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
  v5 = v4 | HIWORD(v4);
  if ((v5 + 1) > 4)
    v6 = v5 + 1;
  else
    v6 = 4;
  dword_1ECCE4E20 = v6;
  v7 = malloc_type_malloc(16 * v6, 0x64B88C75uLL);
  objc::methodDescriptionMap = (uint64_t)v7;
  if (v2)
  {
    qword_1ECCE4E18 = 0;
    if (dword_1ECCE4E20)
    {
      v8 = 16 * dword_1ECCE4E20;
      do
      {
        *v7 = -1;
        v7 += 2;
        v8 -= 16;
      }
      while (v8);
    }
    if ((_DWORD)v1)
    {
      v9 = 16 * v1;
      v10 = v2;
      do
      {
        v11 = *v10;
        if (*v10 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v14 = 0;
          objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>(v11, &v14);
          v12 = v14;
          *v14 = *v10;
          v12[1] = v10[1];
          LODWORD(qword_1ECCE4E18) = qword_1ECCE4E18 + 1;
        }
        v10 += 2;
        v9 -= 16;
      }
      while (v9);
    }
    free(v2);
  }
  else
  {
    qword_1ECCE4E18 = 0;
    if (dword_1ECCE4E20)
    {
      v13 = 16 * dword_1ECCE4E20;
      do
      {
        *v7 = -1;
        v7 += 2;
        v13 -= 16;
      }
      while (v13);
    }
  }
}

_DWORD *method_list_t::duplicate(method_list_t *this, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v5;
  unint64_t v6;
  const char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  _QWORD *v25;
  char *v26;
  int v27;
  int *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  char **v32;
  _DWORD *MethodList;
  unint64_t v35;

  v5 = *(unsigned int *)this;
  v6 = ((unint64_t)this + 8) & 0xFFFFFFFFFFFFFFFCLL | (v5 >> 31);
  entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd((int *)this, a2, a3, a4);
  v10 = v9;
  if (*(int *)this >= 0)
    v11 = *(_DWORD *)this & 0xFFFF0003;
  else
    v11 = 0;
  MethodList = method_list_t::allocateMethodList((method_list_t *)*((unsigned int *)this + 1), v11, v7, v8);
  if (v6 != v10)
  {
    v15 = 0;
    v16 = 0;
    v17 = *MethodList;
    v18 = (unsigned __int16)v5 & 0xFFFC;
    v19 = (unsigned __int16)v17 & 0xFFFC;
    v20 = (unint64_t)(MethodList + 2) & 0xFFFFFFFFFFFFFFFCLL | (v17 >> 31);
    v21 = dataSegmentsRanges;
    v35 = *(_QWORD *)algn_1ECCE5978;
    do
    {
      v22 = v20 + v16;
      v23 = v6 + v15;
      v24 = (v20 + v16) & 3;
      if (v24)
      {
        if (v24 != 2)
        {
          if (v24 == 1)
            _objc_fatal("Cannot assign to small method %p from method %p", v12, v13, v14, v20 + v16, v6 + v15);
          goto LABEL_25;
        }
        v25 = (_QWORD *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
        v25[2] = method_t::imp(v6 + v15, 0);
        v29 = v6 + v15;
        v30 = (v6 + v15) & 3;
        if (!v30 || v30 == 2)
        {
          v32 = (char **)(v29 & 0xFFFFFFFFFFFFFFFCLL);
          goto LABEL_23;
        }
        if (v30 == 1)
        {
          v28 = (int *)(v29 & 0xFFFFFFFFFFFFFFFCLL);
          goto LABEL_18;
        }
      }
      else
      {
        v25 = (_QWORD *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
        v25[2] = method_t::imp(v6 + v15, 0);
        v27 = v23 & 3;
        if ((v23 & 3) == 0 || v27 == 2)
        {
          v32 = (char **)(v23 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_23:
          v26 = *v32;
          goto LABEL_24;
        }
        if (v27 == 1)
        {
          v28 = (int *)(v23 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_18:
          v31 = *v28;
          if (v21 > (unint64_t)v28 || v35 <= (unint64_t)v28)
            v26 = *(char **)((char *)v28 + v31);
          else
            v26 = (char *)&unk_1F25805A8 + v31;
        }
      }
LABEL_24:
      *v25 = v26;
      v25[1] = method_t::types(v6 + v15, (uint64_t)v26);
LABEL_25:
      v16 += v19;
      v15 += v18;
    }
    while (v6 + v15 != v10);
  }
  return MethodList;
}

void objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::grow(int a1)
{
  uint64_t v1;
  unint64_t *v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  unint64_t *v14;

  v1 = dword_1ECCE4EC0;
  v2 = (unint64_t *)remappedClasses(BOOL)::remapped_class_map;
  v3 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
  v5 = v4 | HIWORD(v4);
  if ((v5 + 1) > 4)
    v6 = v5 + 1;
  else
    v6 = 4;
  dword_1ECCE4EC0 = v6;
  v7 = malloc_type_malloc(16 * v6, 0x64B88C75uLL);
  remappedClasses(BOOL)::remapped_class_map = (uint64_t)v7;
  if (v2)
  {
    qword_1ECCE4EB8 = 0;
    if (dword_1ECCE4EC0)
    {
      v8 = 16 * dword_1ECCE4EC0;
      do
      {
        *v7 = -1;
        v7 += 2;
        v8 -= 16;
      }
      while (v8);
    }
    if ((_DWORD)v1)
    {
      v9 = 16 * v1;
      v10 = v2;
      do
      {
        v11 = *v10;
        if (*v10 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v14 = 0;
          objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::LookupBucketFor<objc_class *>(v11, &v14);
          v12 = v14;
          *v14 = *v10;
          v12[1] = v10[1];
          LODWORD(qword_1ECCE4EB8) = qword_1ECCE4EB8 + 1;
        }
        v10 += 2;
        v9 -= 16;
      }
      while (v9);
    }
    free(v2);
  }
  else
  {
    qword_1ECCE4EB8 = 0;
    if (dword_1ECCE4EC0)
    {
      v13 = 16 * dword_1ECCE4EC0;
      do
      {
        *v7 = -1;
        v7 += 2;
        v13 -= 16;
      }
      while (v13);
    }
  }
}

unint64_t make_ro_writeable_nolock(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  int v4;
  size_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t result;

  if ((*(_BYTE *)(a1 + 3) & 8) == 0)
  {
    v2 = *(_QWORD *)(a1 + 8);
    v3 = (_QWORD *)(v2 & 0xFFFFFFFFFFFFFFFELL);
    if ((v2 & 1) != 0)
      v3 = (_QWORD *)*v3;
    v4 = *(_DWORD *)v3;
    if ((*(_DWORD *)v3 & 0x40) != 0)
      v5 = 80;
    else
      v5 = 72;
    v6 = malloc_type_malloc(v5, 0x3F84A03uLL);
    memcpy(v6, v3, v5);
    if ((v4 & 0x40) != 0)
      v6[9] = v3[9];
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & 1) != 0)
      *(_QWORD *)(v7 & 0xFFFFFFFFFFFFFFFELL) = v6;
    else
      *(_QWORD *)(a1 + 8) = v6;
    *(_DWORD *)a1 |= 0x8000000u;
  }
  v8 = *(_QWORD *)(a1 + 8);
  result = v8 & 0xFFFFFFFFFFFFFFFELL;
  if ((v8 & 1) != 0)
    return *(_QWORD *)result;
  return result;
}

void attachCategories(objc_class *a1, uint64_t a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  char v7;
  uint64_t v8;
  const char ***v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  uint64_t v14;
  const char **v15;
  const char **v16;
  const char *v17;
  int v18;
  _BOOL4 v19;
  char v20;
  unsigned int *v21;
  unsigned int *v22;
  unsigned int v23;
  const char *v24;
  uint64_t *v25;
  uint64_t v26;
  _DWORD *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int *v30;
  const char *v31;
  const char *v32;
  _DWORD *v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int *v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  char *v43;
  const char *v44;
  uint64_t v45;
  const char ***v46;
  const char **v47;
  unint64_t *v48;
  unint64_t v50;
  _QWORD v51[4];
  unint64_t v52;
  char v53;
  unsigned int v54[130];
  _DWORD v55[130];
  _DWORD v56[130];
  unsigned int v57[130];
  _DWORD v58[130];
  _DWORD v59[131];
  int v60;
  objc_class *v61;

  v7 = (char)a4;
  LODWORD(v8) = (_DWORD)a3;
  v9 = (const char ***)a2;
  v61 = a1;
  v60 = (int)a4;
  if (PrintReplacedMethods)
    printReplacements((uint64_t)a1, a2, a3, a4);
  if (PrintConnecting)
  {
    if ((v7 & 8) != 0)
      v42 = " existing";
    else
      v42 = "";
    v43 = objc_class::nameForLogging(a1);
    v10 = v7 & 2;
    v44 = " (meta)";
    if ((v7 & 2) == 0)
      v44 = "";
    _objc_inform("CLASS: attaching %d categories to%s class '%s'%s", v8, v42, v43, v44);
    if ((_DWORD)v8)
    {
      v45 = v8;
      v46 = v9;
      do
      {
        v47 = *v46;
        v46 += 2;
        _objc_inform("    category: (%s) %p", *v47, v47);
        --v45;
      }
      while (v45);
    }
  }
  else
  {
    v10 = v7 & 2;
  }
  v57[128] = 0;
  v58[128] = 0;
  v59[128] = 0;
  v54[128] = 0;
  v55[128] = 0;
  v56[128] = 0;
  v53 = 0;
  v52 = 0;
  v11 = *(_QWORD *)((*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) + 8);
  v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
  if ((v11 & 1) == 0)
    v12 = class_rw_t::extAlloc(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8, v12, 0);
  v50 = v12;
  v52 = v12;
  if ((_DWORD)v8)
  {
    v13 = 0;
    v8 = v8;
    v48 = (unint64_t *)(v12 + 24);
    while (1)
    {
      if (v10)
        v14 = 3;
      else
        v14 = 2;
      v15 = *v9;
      v16 = v9[1];
      v17 = (*v9)[v14];
      v18 = *((unsigned __int8 *)v16 + (_QWORD)v16[1] + 12);
      v19 = DisablePreattachedCategories == 0;
      v20 = v18 & v19;
      if ((v18 & v19) != 0)
        v21 = v57;
      else
        v21 = v54;
      if (v17)
      {
        if ((v18 & (DisablePreattachedCategories == 0)) != 0)
          v22 = v57;
        else
          v22 = v54;
        v23 = v22[128];
        if (v23 >= 0x40)
        {
          prepareMethodLists(a1, (method_list_t **)v21, v23, 0, v13 != 0, (unint64_t)"attachCategories", a7);
          if (PrintPreopt)
            v24 = "methods";
          else
            v24 = 0;
          list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(v50 + 8), (uint64_t)v21, (const char *)v22[128], (char *)(v20 & 1), v24);
          v23 = 0;
          v13 = v53;
          v15 = *v9;
          v16 = v9[1];
        }
        v22[128] = v23 + 1;
        *(_QWORD *)&v21[2 * (v23 ^ 0x3F)] = v17;
        v13 |= *(_DWORD *)((char *)v16 + (_QWORD)*v16 + 12) == 8;
        v53 = v13;
      }
      if (!v10)
        break;
      if ((*((_BYTE *)v16 + (_QWORD)v16[1] + 12) & 0x40) != 0)
      {
        v25 = (uint64_t *)(v15 + 6);
LABEL_29:
        v26 = *v25;
        if (*v25)
        {
          if ((v20 & 1) != 0)
            v27 = v58;
          else
            v27 = v55;
          if ((v20 & 1) != 0)
            v28 = v57;
          else
            v28 = v54;
          v29 = v28[258];
          if (v29 >= 0x40)
          {
            if ((v20 & 1) != 0)
              v30 = v57;
            else
              v30 = v54;
            if (PrintPreopt)
              v31 = "properties";
            else
              v31 = 0;
            list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(v50 + 16), (uint64_t)v27, (const char *)v30[258], (char *)(v20 & 1), v31);
            v29 = 0;
          }
          v28[258] = v29 + 1;
          *(_QWORD *)&v27[2 * (v29 ^ 0x3F)] = v26;
        }
        if (!v10)
        {
          v32 = (*v9)[4];
          if (v32)
          {
            if ((v20 & 1) != 0)
              v33 = v59;
            else
              v33 = v56;
            if ((v20 & 1) != 0)
              v34 = v57;
            else
              v34 = v54;
            v35 = v34[388];
            if (v35 >= 0x40)
            {
              if ((v20 & 1) != 0)
                v36 = v57;
              else
                v36 = v54;
              if (PrintPreopt)
                v37 = "protocols";
              else
                v37 = 0;
              list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists(v48, (uint64_t)v33, (const char *)v36[388], (char *)(v20 & 1), v37);
              v35 = 0;
            }
            v34[388] = v35 + 1;
            *(_QWORD *)&v33[2 * (v35 ^ 0x3F)] = v32;
          }
        }
      }
      v9 += 2;
      if (!--v8)
        goto LABEL_63;
    }
    v25 = (uint64_t *)(v15 + 5);
    goto LABEL_29;
  }
LABEL_63:
  v51[0] = &v61;
  v51[1] = &v53;
  v51[2] = &v52;
  v51[3] = &v60;
  attachCategories(objc_class *,locstamped_category_t const*,unsigned int,objc_class *,int)::$_0::operator()((uint64_t)v51, v57, (char *)1, (uint64_t)a4, a5, a6, a7);
  attachCategories(objc_class *,locstamped_category_t const*,unsigned int,objc_class *,int)::$_0::operator()((uint64_t)v51, v54, 0, v38, v39, v40, v41);
}

void attachCategories(objc_class *,locstamped_category_t const*,unsigned int,objc_class *,int)::$_0::operator()(uint64_t a1, unsigned int *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  unsigned int *v11;
  const char *v12;
  char *v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  _QWORD v17[5];

  v10 = a2[128];
  if ((_DWORD)v10)
  {
    v11 = a2 + 128;
    prepareMethodLists(**(_QWORD ***)a1, (method_list_t **)&a2[-2 * v10 + 128], v10, 0, **(unsigned __int8 **)(a1 + 8), (unint64_t)"operator()", a7);
    v12 = PrintPreopt ? "methods" : 0;
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(**(_QWORD **)(a1 + 16) + 8), (uint64_t)&v11[-2 * *v11], (const char *)*v11, a3, v12);
    if ((**(_BYTE **)(a1 + 24) & 8) != 0)
    {
      v14 = **(_QWORD **)a1;
      v17[0] = MEMORY[0x1E0C809B0];
      v17[1] = 3321888768;
      v17[2] = ___ZZL16attachCategoriesP10objc_classPK21locstamped_category_tjS0_iENK3__0clEPZL16attachCategoriesS0_S3_jS0_iE5Listsb_block_invoke;
      v17[3] = &__block_descriptor_33_e8_32c127_ZTSKZZL16attachCategoriesP10objc_classPK21locstamped_category_tjS0_iENK3__0clEPZL16attachCategoriesS0_S3_jS0_iE5ListsbEUlS0_E__e8_B16__0_8l;
      flushCaches(v14, (uint64_t)"operator()", (const char *)v17, v13);
    }
  }
  if (PrintPreopt)
    v15 = "properties";
  else
    v15 = 0;
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(**(_QWORD **)(a1 + 16) + 16), (uint64_t)&a2[-2 * a2[258] + 258], (const char *)a2[258], a3, v15);
  if (PrintPreopt)
    v16 = "protocols";
  else
    v16 = 0;
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(**(_QWORD **)(a1 + 16) + 24), (uint64_t)&a2[-2 * a2[388] + 388], (const char *)a2[388], a3, v16);
}

BOOL ___ZZL16attachCategoriesP10objc_classPK21locstamped_category_tjS0_iENK3__0clEPZL16attachCategoriesS0_S3_jS0_iE5Listsb_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_cache *v2;

  v2 = *(objc_cache **)(a2 + 16);
  if ((v2 & 1) != 0)
    return 0;
  return v2 == &_objc_empty_cache || HIWORD(*(_QWORD *)(a2 + 16)) != 0;
}

unint64_t method_t::impRaw(unint64_t this)
{
  unint64_t v1;
  int v2;

  v1 = this;
  v2 = this & 3;
  if ((this & 3) == 0 || v2 == 2)
    return *(_QWORD *)((this & 0xFFFFFFFFFFFFFFFCLL) + 16);
  if (v2 == 1)
  {
    this = method_t_remappedImp_nolock((const method_t *)this);
    if (!this)
      return *(int *)((v1 & 0xFFFFFFFFFFFFFFFCLL) + 8) + (v1 & 0xFFFFFFFFFFFFFFFCLL) + 8;
  }
  return this;
}

uint64_t list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::begin(uint64_t a1, _QWORD *a2, const char *a3, char *a4)
{
  uint64_t v4;
  unsigned int *v5;
  BOOL v6;
  unsigned __int16 *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t i;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  BOOL v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  unint64_t v32;
  unsigned __int16 *v33;

  v30 = a2;
  v4 = *a2 & 3;
  v5 = (unsigned int *)(*a2 & 0xFFFFFFFFFFFFFFFCLL);
  if (v4)
    v6 = 1;
  else
    v6 = v5 == 0;
  if (!v6)
  {
    v31 = *a2 & 0xFFFFFFFFFFFFFFFCLL;
    v26 = a2;
LABEL_9:
    v27 = 0;
    return list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v30, (uint64_t)&v26, a4);
  }
  if (*a2 > 3uLL)
  {
    if (v4 == 1 && v5 != 0)
    {
      v31 = (unint64_t)(v5 + 2);
      v26 = a2;
      goto LABEL_26;
    }
    if (v4 == 2 && v5 != 0)
    {
      if (DisablePreattachedCategories)
      {
        v12 = *v5;
        v20 = v5[1];
        v21 = v20 * (unint64_t)v12;
        if ((v21 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v20, *a2 & 0xFFFFFFFFFFFFFFFCLL, v12);
        v22 = v12 | (v20 << 32);
        v23 = (uint64_t)v5 + v21 + 8;
        v24 = v12 | ((unint64_t)(v20 - 1) << 32);
        v25 = (_DWORD)v20 == 0;
        if ((_DWORD)v20)
          v10 = v20;
        else
          v10 = 0;
        if ((_DWORD)v20)
          v9 = (unsigned __int16 *)(v23 - v12);
        else
          v9 = (unsigned __int16 *)v23;
        if (v25)
          v11 = v22;
        else
          v11 = v24;
      }
      else
      {
        v9 = (unsigned __int16 *)(v5 + 2);
        v11 = *v5;
        v10 = v5[1];
        v12 = v11;
      }
      v13 = v10 * (unint64_t)v12;
      if ((v13 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v10, *a2 & 0xFFFFFFFFFFFFFFFCLL, v12);
      v14 = HIDWORD(v11);
      for (i = (unint64_t)v5 + v13 + 8; (unint64_t)v9 < i; v14 = (v14 + 1))
      {
        if ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *v9 + 8) & 1) != 0)
          break;
        v9 = (unsigned __int16 *)((char *)v9 + v11);
      }
      v31 = *a2 & 0xFFFFFFFFFFFFFFFCLL;
      v32 = v11 | (v14 << 32);
      v33 = v9;
    }
  }
  else
  {
    v31 = 0;
  }
  v26 = a2;
  if (!v4)
    goto LABEL_9;
LABEL_26:
  if (v4 == 1 && v5)
  {
    v27 = (uint64_t)&v5[2 * *v5 + 2];
  }
  else if (v4 == 2 && v5)
  {
    v17 = *v5;
    v16 = v5[1];
    v18 = v16 * (unint64_t)v17;
    if ((v18 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v16, v5, v17);
    v27 = (uint64_t)v5;
    v28 = v17 | (v16 << 32);
    v29 = (uint64_t)v5 + v18 + 8;
  }
  return list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v30, (uint64_t)&v26, a4);
}

uint64_t list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::end(uint64_t a1, _QWORD *a2, const char *a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;

  v5 = *a2 & 3;
  v6 = (unsigned int *)(*a2 & 0xFFFFFFFFFFFFFFFCLL);
  if (v5 == 1 && v6 != 0)
  {
    v6 += 2 * *v6 + 2;
    v17 = a2;
LABEL_15:
    v18 = v6;
    v13 = a2;
    v14 = v6;
    return list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, (uint64_t)&v13, a4);
  }
  if (v5 == 2 && v6 != 0)
  {
    v10 = *v6;
    v9 = v6[1];
    v11 = v9 * (unint64_t)v10;
    if ((v11 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v9, *a2 & 0xFFFFFFFFFFFFFFFCLL, v10);
    v5 = (uint64_t)v6 + v11 + 8;
    v4 = v10 | (v9 << 32);
    v17 = a2;
    goto LABEL_18;
  }
  v6 = 0;
  v17 = a2;
  if (v5 == 2)
  {
LABEL_18:
    v18 = v6;
    v19 = v4;
    v20 = v5;
    v13 = a2;
    v14 = v6;
    v15 = v4;
    v16 = v5;
    return list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, (uint64_t)&v13, a4);
  }
  if (v5 == 1)
    goto LABEL_15;
  if (v5)
  {
    v13 = a2;
  }
  else
  {
    v18 = 0;
    v13 = a2;
    v14 = 0;
  }
  return list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, (uint64_t)&v13, a4);
}

uint64_t **list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator++(uint64_t **a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  const char *v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  const char *v32;
  char *v33;
  uint64_t v35;
  uint64_t v36;

  v5 = a1[8];
  v6 = (uint64_t *)((char *)a1[9] + v5);
  a1[9] = v6;
  *((_DWORD *)a1 + 17) = HIDWORD(v5) + 1;
  if (v6 != a1[11])
    return a1;
  v7 = *a1;
  v8 = **a1;
  if ((v8 & 3) == 1)
  {
    ++a1[1];
    v8 = *v7;
  }
  else if ((v8 & 3) == 0)
  {
    a1[1] = 0;
  }
  if ((v8 & 3) == 2)
  {
    v9 = a1[3];
    v10 = *((unsigned int *)a1 + 4);
    v11 = *((_DWORD *)a1 + 5);
    a1[3] = (uint64_t *)((char *)v9 + v10);
    v12 = (unsigned int *)a1[1];
    v14 = *v12;
    v13 = v12[1];
    v15 = v13 * (unint64_t)v14;
    *((_DWORD *)a1 + 5) = v11 + 1;
    if ((v15 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v13, v12, v14);
    v16 = (unint64_t)v12 + v15 + 8;
    if ((unint64_t)v9 + v10 < v16)
    {
      v17 = objc_debug_headerInfoRWs;
      v18 = v11 + 2;
      do
      {
        if ((*(_QWORD *)(v17 + 8 * *(unsigned __int16 *)((char *)v9 + v10) + 8) & 1) != 0)
          break;
        a1[3] = (uint64_t *)((char *)v9 + 2 * v10);
        *((_DWORD *)a1 + 5) = v18++;
        v9 = (uint64_t *)((char *)v9 + v10);
      }
      while ((unint64_t)v9 + v10 < v16);
    }
  }
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists(a1);
  v22 = *a1;
  v23 = **a1 & 3;
  if (*a1 == a1[4])
  {
    if (v23 != 2)
    {
      if (v23 != 1)
      {
        if (!v23)
        {
          v24 = a1[1];
          if (v24 == a1[5])
            return a1;
          goto LABEL_29;
        }
LABEL_22:
        v24 = 0;
        goto LABEL_29;
      }
      v26 = a1[1];
      if (v26 == a1[5])
        return a1;
      goto LABEL_28;
    }
    v25 = a1[3];
    if (v25 == a1[7])
      return a1;
LABEL_26:
    v24 = (uint64_t *)((char *)v25 + (*v25 >> 16));
    goto LABEL_29;
  }
  if (v23 == 2)
  {
    v25 = a1[3];
    goto LABEL_26;
  }
  if (v23 != 1)
  {
    if (!v23)
    {
      v24 = a1[1];
      goto LABEL_29;
    }
    goto LABEL_22;
  }
  v26 = a1[1];
LABEL_28:
  v24 = (uint64_t *)*v26;
LABEL_29:
  v27 = (uint64_t *)((unsigned __int16)*(_DWORD *)v24 & 0xFFFC);
  v28 = (unint64_t)(v24 + 1) & 0xFFFFFFFFFFFFFFFCLL | ((unint64_t)*(unsigned int *)v24 >> 31);
  a1[8] = v27;
  a1[9] = (uint64_t *)v28;
  v29 = *v22 & 3;
  if (v29 == 2)
  {
    v30 = (int *)((char *)a1[3] + (*a1[3] >> 16));
  }
  else if (v29 == 1)
  {
    v30 = (int *)*a1[1];
  }
  else if (v29)
  {
    v30 = 0;
  }
  else
  {
    v30 = (int *)a1[1];
  }
  a1[10] = (uint64_t *)entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd(v30, v19, v20, v21);
  a1[11] = (uint64_t *)v31;
  if (a1[9] == (uint64_t *)v31)
  {
    v35 = **a1 & 3;
    if (v35 == 2)
    {
      v36 = (uint64_t)a1[3] + (*a1[3] >> 16);
    }
    else if (v35 == 1)
    {
      v36 = *a1[1];
    }
    else if (v35)
    {
      v36 = 0;
    }
    else
    {
      v36 = (uint64_t)a1[1];
    }
    _objc_fatal("Assertion failed: (%s) - empty list %p encountered during iteration", v31, v32, v33, "m != mEnd", v36);
  }
  return a1;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  unint64_t v13;
  char *v14;
  unint64_t v15;
  char *v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  unint64_t v26;
  char *v27;
  char *v28;
  unint64_t v29;
  uint64_t v30;
  char *v31;
  char *v32;
  __int128 v33;
  int64_t v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  __int128 v43;
  uint64_t v44;
  char *v45;
  char *v46;
  char *v47;
  __int128 v48;
  unint64_t v49;
  BOOL v50;
  char v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  __int128 v64;
  char *v65;
  char *v66;
  unint64_t v67;
  unint64_t v68;
  BOOL v69;
  char *v70;
  __int128 v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  __int128 v75;
  char *v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  unint64_t v80;
  char *v81;
  __int128 v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char *v87;
  char *v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;

  if (a5)
  {
    v9 = result;
    while (a5 > a7 && a4 > a7)
    {
      if (!a4)
        return result;
      while (*(_QWORD *)a2 >= *(_QWORD *)v9)
      {
        v9 += 24;
        if (!--a4)
          return result;
      }
      if (a4 >= a5)
      {
        if (a4 == 1)
        {
          v98 = *((_QWORD *)v9 + 2);
          v93 = *(_OWORD *)v9;
          v79 = *(_OWORD *)a2;
          *((_QWORD *)v9 + 2) = *((_QWORD *)a2 + 2);
          *(_OWORD *)v9 = v79;
          *((_QWORD *)a2 + 2) = v98;
          *(_OWORD *)a2 = v93;
          return result;
        }
        if (a4 >= 0)
          v20 = a4;
        else
          v20 = a4 + 1;
        v21 = v20 >> 1;
        v14 = &v9[24 * (v20 >> 1)];
        if (a3 == a2)
        {
          v12 = a3;
          v27 = a3;
        }
        else
        {
          v22 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 3);
          v12 = a2;
          do
          {
            v23 = v22 >> 1;
            v24 = &v12[24 * (v22 >> 1)];
            v26 = *(_QWORD *)v24;
            v25 = v24 + 24;
            v22 += ~(v22 >> 1);
            if (v26 < *(_QWORD *)v14)
              v12 = v25;
            else
              v22 = v23;
          }
          while (v22);
          v27 = a2;
        }
        v11 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v27) >> 3);
      }
      else
      {
        if (a5 >= 0)
          v10 = a5;
        else
          v10 = a5 + 1;
        v11 = v10 >> 1;
        v12 = &a2[24 * (v10 >> 1)];
        if (a2 == v9)
        {
          v14 = a2;
          v19 = a2;
        }
        else
        {
          v13 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v9) >> 3);
          v14 = v9;
          do
          {
            v15 = v13 >> 1;
            v16 = &v14[24 * (v13 >> 1)];
            v18 = *(_QWORD *)v16;
            v17 = v16 + 24;
            v13 += ~(v13 >> 1);
            if (*(_QWORD *)v12 < v18)
              v13 = v15;
            else
              v14 = v17;
          }
          while (v13);
          v19 = v9;
        }
        v21 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v19) >> 3);
      }
      v28 = v12;
      if (v14 != a2)
      {
        v28 = v14;
        if (a2 != v12)
        {
          if (v14 + 24 == a2)
          {
            v95 = *((_QWORD *)v14 + 2);
            v90 = *(_OWORD *)v14;
            v34 = v12 - a2;
            v85 = a5;
            v87 = a6;
            v35 = a3;
            v83 = a7;
            v36 = v11;
            memmove(v14, a2, v12 - a2);
            v11 = v36;
            a7 = v83;
            a5 = v85;
            a3 = v35;
            a6 = v87;
            v28 = &v14[v34];
            *(_OWORD *)v28 = v90;
            *((_QWORD *)v28 + 2) = v95;
          }
          else if (a2 + 24 == v12)
          {
            v28 = v14 + 24;
            v96 = *((_QWORD *)v12 - 1);
            v91 = *(_OWORD *)(v12 - 24);
            if (v12 - 24 != v14)
            {
              v86 = a5;
              v88 = a6;
              v37 = a3;
              v84 = a7;
              v38 = v11;
              memmove(v14 + 24, v14, v12 - 24 - v14);
              v11 = v38;
              a7 = v84;
              a5 = v86;
              a3 = v37;
              a6 = v88;
            }
            *((_QWORD *)v14 + 2) = v96;
            *(_OWORD *)v14 = v91;
          }
          else
          {
            v29 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v14) >> 3);
            if (v29 == 0xAAAAAAAAAAAAAAABLL * ((v12 - a2) >> 3))
            {
              v30 = 0;
              do
              {
                v31 = &a2[v30];
                v32 = &v14[v30];
                v94 = *(_QWORD *)&v14[v30 + 16];
                v89 = *(_OWORD *)&v14[v30];
                v33 = *(_OWORD *)&a2[v30];
                *((_QWORD *)v32 + 2) = *(_QWORD *)&a2[v30 + 16];
                *(_OWORD *)v32 = v33;
                *((_QWORD *)v31 + 2) = v94;
                *(_OWORD *)v31 = v89;
                if (&v14[v30 + 24] == a2)
                  break;
                v30 += 24;
              }
              while (v31 + 24 != v12);
              v28 = a2;
            }
            else
            {
              v39 = 0xAAAAAAAAAAAAAAABLL * ((v12 - a2) >> 3);
              v40 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v14) >> 3);
              do
              {
                v41 = v40;
                v40 = v39;
                v39 = v41 % v39;
              }
              while (v39);
              if (v40)
              {
                v42 = &v14[24 * v40];
                do
                {
                  v43 = *(_OWORD *)(v42 - 24);
                  v44 = *((_QWORD *)v42 - 1);
                  v42 -= 24;
                  v97 = v44;
                  v92 = v43;
                  v45 = &v42[8 * ((a2 - v14) >> 3)];
                  v46 = v42;
                  do
                  {
                    v47 = v46;
                    v46 = v45;
                    v48 = *(_OWORD *)v45;
                    *((_QWORD *)v47 + 2) = *((_QWORD *)v45 + 2);
                    *(_OWORD *)v47 = v48;
                    v49 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v45) >> 3);
                    v50 = __OFSUB__(v29, v49);
                    v52 = v29 - v49;
                    v51 = (v52 < 0) ^ v50;
                    v45 = &v14[24 * v52];
                    if (v51)
                      v45 = &v46[8 * ((a2 - v14) >> 3)];
                  }
                  while (v45 != v42);
                  *((_QWORD *)v46 + 2) = v97;
                  *(_OWORD *)v46 = v92;
                }
                while (v42 != v14);
              }
              v28 = &v14[8 * ((v12 - a2) >> 3)];
            }
          }
        }
      }
      a4 -= v21;
      v53 = a5 - v11;
      if (v21 + v11 >= a4 + v53)
      {
        v60 = a4;
        v57 = a6;
        v58 = a7;
        v61 = v11;
        result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v28, v12, a3, v60);
        v12 = v14;
        a5 = v61;
        a4 = v21;
        a3 = v28;
      }
      else
      {
        v54 = v9;
        v55 = v21;
        v56 = v53;
        v57 = a6;
        v58 = a7;
        v59 = a3;
        result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v54, v14, v28, v55);
        a5 = v56;
        a3 = v59;
        v9 = v28;
      }
      a2 = v12;
      a6 = v57;
      a7 = v58;
      if (!a5)
        return result;
    }
    if (a4 <= a5)
    {
      if (v9 != a2)
      {
        v73 = 0;
        do
        {
          v74 = &a6[v73];
          v75 = *(_OWORD *)&v9[v73];
          *((_QWORD *)v74 + 2) = *(_QWORD *)&v9[v73 + 16];
          *(_OWORD *)v74 = v75;
          v73 += 24;
        }
        while (&v9[v73] != a2);
        v76 = &a6[v73];
        if (v76 != a6)
        {
          while (a2 != a3)
          {
            if (*(_QWORD *)a2 >= *(_QWORD *)a6)
            {
              v78 = *(_OWORD *)a6;
              *((_QWORD *)v9 + 2) = *((_QWORD *)a6 + 2);
              *(_OWORD *)v9 = v78;
              a6 += 24;
            }
            else
            {
              v77 = *(_OWORD *)a2;
              *((_QWORD *)v9 + 2) = *((_QWORD *)a2 + 2);
              *(_OWORD *)v9 = v77;
              a2 += 24;
            }
            v9 += 24;
            if (a6 == v76)
              return result;
          }
          return (char *)memmove(v9, a6, v76 - a6);
        }
      }
    }
    else if (a2 != a3)
    {
      v62 = 0;
      do
      {
        v63 = &a6[v62];
        v64 = *(_OWORD *)&a2[v62];
        *((_QWORD *)v63 + 2) = *(_QWORD *)&a2[v62 + 16];
        *(_OWORD *)v63 = v64;
        v62 += 24;
      }
      while (&a2[v62] != a3);
      v65 = &a6[v62];
      if (v65 != a6)
      {
        v66 = a3 - 24;
        while (a2 != v9)
        {
          v67 = *((_QWORD *)v65 - 3);
          v68 = *((_QWORD *)a2 - 3);
          v69 = v67 >= v68;
          if (v67 >= v68)
            v70 = v65 - 24;
          else
            v70 = a2 - 24;
          if (!v69)
            a2 -= 24;
          v71 = *(_OWORD *)v70;
          v72 = *((_QWORD *)v70 + 2);
          if (v69)
            v65 -= 24;
          *((_QWORD *)v66 + 2) = v72;
          *(_OWORD *)v66 = v71;
          v66 -= 24;
          if (v65 == a6)
            return result;
        }
        v80 = 0;
        do
        {
          v81 = &v66[v80];
          v82 = *(_OWORD *)&v65[v80 - 24];
          *((_QWORD *)v81 + 2) = *(_QWORD *)&v65[v80 - 8];
          *(_OWORD *)v81 = v82;
          v80 -= 24;
        }
        while (&v65[v80] != a6);
      }
    }
  }
  return result;
}

_QWORD *objc::Scanner::setNSObjectSwizzled(_QWORD *result, int a2, char a3)
{
  int v3;
  _QWORD v4[5];
  int v5;
  char v6;
  BOOL v7;
  BOOL v8;

  objc::NSObjectSwizzledMask |= (a2 << a3);
  v3 = *(_DWORD *)(result[4] & 0xF00007FFFFFFFF8);
  if ((v3 & 1) == 0)
    v3 = *(_DWORD *)(*(_QWORD *)((*result & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  if ((v3 & 0x20000000) != 0)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 3321888768;
    v4[2] = ___ZN4objc7Scanner20propagateCustomFlagsEP10objc_classjNS0_11inherited_tE_block_invoke;
    v4[3] = &__block_descriptor_48_e8_32c83_ZTSKZN4objc7Scanner20propagateCustomFlagsEP10objc_classjNS0_11inherited_tEEUlS2_E__e8_B16__0_8l;
    v4[4] = result;
    v5 = 0;
    v6 = a2 & 1;
    v7 = (a2 & 4) != 0;
    v8 = (a2 & 0x10) != 0;
    return (_QWORD *)foreach_realized_class_and_subclass((uint64_t)result, (uint64_t)v4);
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c83_ZTSKZN4objc7Scanner20propagateCustomFlagsEP10objc_classjNS0_11inherited_tEEUlS2_E_(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 39) = *(_QWORD *)(a2 + 39);
  *(_QWORD *)(result + 32) = v2;
  return result;
}

void objc::Scanner::printCustom(const char *a1, objc_class *this, int a3)
{
  char *v6;
  const char *v7;
  const char *v8;

  v6 = objc_class::nameForLogging(this);
  if ((*((_WORD *)this + 15) & 4) != 0)
    v7 = " (meta)";
  else
    v7 = "";
  v8 = " (inherited)";
  if (a3 != 1)
    v8 = "";
  _objc_inform("%s: %s%s%s", a1, v6, v7, v8);
}

__n128 __copy_helper_block_e8_32c67_ZTSKZL25_method_setImplementationP10objc_classP8method_tPFvvEE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[2] = result;
  return result;
}

BOOL ___ZN10objc_class39setDisallowPreoptInlinedSelsRecursivelyEPKc_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v6;
  objc_class *v8;
  const char *v9;
  char *v10;

  v2 = (unsigned int *)(*(_QWORD *)(a2 + 32) & 0xF00007FFFFFFFF8);
  v3 = *v2;
  if ((*v2 & 4) == 0)
  {
    if (PrintCaches)
    {
      v8 = *(objc_class **)(a1 + 32);
      if ((*((_WORD *)v8 + 15) & 4) != 0)
        v9 = "meta";
      else
        v9 = "";
      v10 = objc_class::nameForLogging(v8);
      _objc_inform("CACHES: %sclass %s: disallow sel-inlined preopt cache (from %s)", v9, v10, *(const char **)(a1 + 40));
      v2 = (unsigned int *)(*(_QWORD *)(a2 + 32) & 0xF00007FFFFFFFF8);
    }
    do
      v6 = __ldxr(v2);
    while (__stxr(v6 | 4, v2));
    if ((*(_QWORD *)(a2 + 16) & 1) != 0 && (*(_DWORD *)((*(_QWORD *)(a2 + 16) & 0xFFFFFFFFFFFELL) - 6) & 0x4000) != 0)
      cache_t::eraseNolock((cache_t *)(a2 + 16), *(const char **)(a1 + 40));
  }
  return (v3 & 4) == 0;
}

__n128 __copy_helper_block_e8_32c69_ZTSKZN10objc_class39setDisallowPreoptInlinedSelsRecursivelyEPKcE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[2] = result;
  return result;
}

__n128 __copy_helper_block_e8_32c64_ZTSKZN10objc_class34setDisallowPreoptCachesRecursivelyEPKcE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[2] = result;
  return result;
}

unint64_t make_ro_writeable_nolock(objc_class *a1)
{
  _DWORD *v2;

  if ((unint64_t)(*(_QWORD *)a1 - 1) < 0xF
    || (v2 = (_DWORD *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8), (*v2 & 0x80000000) == 0))
  {
    realizeAndInitializeIfNeeded_locked(0, a1, 0);
    v2 = (_DWORD *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8);
  }
  return make_ro_writeable_nolock((uint64_t)v2);
}

uint64_t getClass_impl(char *a1)
{
  unsigned int v2;
  uint64_t result;
  _QWORD v4[5];
  uint64_t v5;

  v2 = _mapStrHash((uint64_t)a1, a1);
  v4[0] = 0;
  if (_NXMapMemberWithHash(gdb_objc_realized_classes, (uint64_t)a1, v2, v4) == -1)
    result = 0;
  else
    result = v4[0];
  if (!result)
  {
    if (DisablePreopt || preoptimized != 1)
    {
      return 0;
    }
    else
    {
      v5 = 0;
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 3321888768;
      v4[2] = __getPreoptimizedClass_block_invoke;
      v4[3] = &__block_descriptor_40_e8_32c33_ZTSKZ20getPreoptimizedClassE3__0_e16_v28__0_v8B16_B20l;
      v4[4] = &v5;
      _dyld_for_each_objc_class();
      return v5;
    }
  }
  return result;
}

__objc2_class *realizeAndInitializeIfNeeded_locked(objc_object *a1, objc_class *this, int a3)
{
  uint64_t v5;
  uint64_t v6;
  objc_class *v7;
  BOOL v8;
  int v9;
  objc_class *v11;

  v5 = *(_QWORD *)this;
  if ((unint64_t)(*(_QWORD *)this - 1) < 0xF
    || (*(_DWORD *)(*((_QWORD *)this + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0)
  {
    v11 = realizeClassMaybeSwiftMaybeRelock(this, 1);
    this = v11;
    if (!v11)
      return (__objc2_class *)this;
    v5 = *(_QWORD *)v11;
  }
  v6 = v5 & 0xFFFFFFFF8;
  if (v6)
    v7 = this;
  else
    v7 = 0;
  if (v6)
    v8 = a3 == 0;
  else
    v8 = 1;
  if (v8)
    return (__objc2_class *)v7;
  v9 = *(_DWORD *)(*((_QWORD *)this + 4) & 0xF00007FFFFFFFF8);
  if ((v9 & 1) == 0)
    v9 = *(_DWORD *)(*(_QWORD *)(v6 + 32) & 0xF00007FFFFFFFF8);
  if ((v9 & 0x20000000) != 0)
    return (__objc2_class *)this;
  return initializeAndMaybeRelock((__objc2_class *)this, a1, 1);
}

uint64_t empty_lazyClassNamer(objc_class *a1)
{
  return 0;
}

__n128 __copy_helper_block_e8_32c64_ZTSKZN10objc_class36setInstancesRequireRawIsaRecursivelyEbE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[2] = result;
  return result;
}

_QWORD *_class_isFutureClass(_QWORD *result)
{
  if (result)
  {
    if ((unint64_t)(*result - 1) >= 0xF)
      return (_QWORD *)((*(unsigned __int8 *)((result[4] & 0xF00007FFFFFFFF8) + 3) >> 6) & 1);
    else
      return 0;
  }
  return result;
}

void _objc_flush_caches(Class cls)
{
  char *v1;
  unint64_t StatusReg;
  unsigned int v4;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v15;
  unsigned int v16;
  _QWORD v17[5];
  _QWORD v18[5];

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v4 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v4, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v6 = MEMORY[0x1E0C809B0];
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3321888768;
  v18[2] = ___objc_flush_caches_block_invoke;
  v18[3] = &__block_descriptor_33_e8_32c31_ZTSKZ18_objc_flush_cachesE3__0_e8_B16__0_8l;
  flushCaches((uint64_t)cls, (uint64_t)"_objc_flush_caches", (const char *)v18, v1);
  if (cls)
  {
    if ((*((_WORD *)cls + 15) & 4) == 0)
    {
      if (*((_QWORD *)cls + 1))
      {
        v8 = *(_QWORD *)cls & 0xFFFFFFFF8;
        v17[0] = v6;
        v17[1] = 3321888768;
        v17[2] = ___objc_flush_caches_block_invoke_7;
        v17[3] = &__block_descriptor_33_e8_32c31_ZTSKZ18_objc_flush_cachesE3__1_e8_B16__0_8l;
        flushCaches(v8, (uint64_t)"_objc_flush_caches", (const char *)v17, v7);
      }
    }
    v9 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v10 = __ldxr(runtimeLock);
      if (v10 != v9)
        break;
      if (!__stlxr(0, runtimeLock))
        return;
    }
  }
  else
  {
    v11 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v12 = __ldxr(runtimeLock);
      if (v12 != v11)
        break;
      if (!__stlxr(0, runtimeLock))
        goto LABEL_19;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_19:
    v13 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v13, runtimeLock))
        goto LABEL_24;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_24:
    cache_t::collectNolock((cache_t *)1);
    v15 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v16 = __ldxr(runtimeLock);
      if (v16 != v15)
        break;
      if (!__stlxr(0, runtimeLock))
        return;
    }
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
}

void sub_180125558(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

BOOL ___objc_flush_caches_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_cache *v2;

  v2 = *(objc_cache **)(a2 + 16);
  if ((v2 & 1) != 0)
    return 0;
  return v2 == &_objc_empty_cache || HIWORD(*(_QWORD *)(a2 + 16)) != 0;
}

BOOL ___objc_flush_caches_block_invoke_7(uint64_t a1, uint64_t a2)
{
  objc_cache *v2;

  v2 = *(objc_cache **)(a2 + 16);
  if ((v2 & 1) != 0)
    return 0;
  return v2 == &_objc_empty_cache || HIWORD(*(_QWORD *)(a2 + 16)) != 0;
}

void _objc_map_images(unsigned int a1, uint64_t a2, uint64_t a3)
{
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  __int128 v18;
  char *v19;

  if (a1)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = a1;
    do
    {
      v10 = *(_QWORD *)(a3 + 8 * v8);
      v11 = *(_QWORD *)(a2 + 8 * v8);
      if (v6 >= v7)
      {
        v12 = (v6 - v5) >> 5;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 59)
          abort();
        if ((v7 - v5) >> 4 > v13)
          v13 = (v7 - v5) >> 4;
        if ((unint64_t)(v7 - v5) >= 0x7FFFFFFFFFFFFFE0)
          v14 = 0x7FFFFFFFFFFFFFFLL;
        else
          v14 = v13;
        if (v14)
        {
          if (v14 >> 59)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v15 = (char *)malloc_type_malloc(32 * v14, 0xB4ED9BFAuLL);
        }
        else
        {
          v15 = 0;
        }
        v16 = &v15[32 * v12];
        *(_QWORD *)v16 = v10;
        *((_QWORD *)v16 + 1) = v11;
        *((_QWORD *)v16 + 2) = 0;
        *((_QWORD *)v16 + 3) = 0;
        if (v6 == v5)
        {
          v19 = &v15[32 * v12];
        }
        else
        {
          v17 = &v15[32 * v12];
          do
          {
            v18 = *((_OWORD *)v6 - 1);
            v19 = v17 - 32;
            *((_OWORD *)v17 - 2) = *((_OWORD *)v6 - 2);
            *((_OWORD *)v17 - 1) = v18;
            v6 -= 32;
            v17 -= 32;
          }
          while (v6 != v5);
        }
        v7 = &v15[32 * v14];
        v6 = v16 + 32;
        if (v5)
          free(v5);
        v5 = v19;
      }
      else
      {
        *(_QWORD *)v6 = v10;
        *((_QWORD *)v6 + 1) = v11;
        *((_QWORD *)v6 + 2) = 0;
        *((_QWORD *)v6 + 3) = 0;
        v6 += 32;
      }
      ++v8;
    }
    while (v8 != v9);
  }
  else
  {
    v5 = 0;
  }
  map_images(a1, (uint64_t)v5, (uint64_t)&__block_literal_global);
  if (v5)
    free(v5);
}

void sub_1801257B0(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    free(v1);
  _Unwind_Resume(exception_object);
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
  abort();
}

void load_categories_nolock(header_info *)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  const char **v8;
  objc_class *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char **v13;
  objc_class *v14;
  const char **v15;
  const char **v16;
  objc_class *v17;
  BOOL v18;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  char *v24;
  char *v25;
  char *v26;
  const char *v27;
  char *v28;
  const char *v29;
  const char *v30;
  const char *v31;
  _QWORD v32[2];

  if (**(_QWORD **)a1)
  {
    v4 = 0;
    v5 = 1;
    v6 = dataSegmentsRanges;
    v7 = *(_QWORD *)algn_1ECCE5978;
    do
    {
      v8 = *(const char ***)(a2 + 8 * v4);
      v9 = (objc_class *)remapClass((unint64_t)v8[1]);
      v13 = **(const char ****)(a1 + 8);
      v32[0] = v8;
      v32[1] = v13;
      if (!v9)
      {
        if (PrintConnecting)
          _objc_inform("CLASS: IGNORING category ???(%s) %p with missing weak-linked target class", *v8, v8);
        goto LABEL_38;
      }
      v14 = v9;
      if ((unint64_t)(*(_QWORD *)v9 - 1) > 0xE)
      {
        if ((didInitialAttachCategories & 1) == 0)
        {
          v18 = !**(_BYTE **)(a1 + 24) || v6 > (unint64_t)v9;
          if (!v18 && v7 > (unint64_t)v9)
          {
            v20 = *((_QWORD *)v9 + 4);
            v21 = (_QWORD *)(v20 & 0xF00007FFFFFFFF8);
            if (v20 < 0)
            {
              v22 = *(_QWORD *)((v20 & 0xF00007FFFFFFFF8) + 8);
              v21 = (_QWORD *)(v22 & 0xFFFFFFFFFFFFFFFELL);
              if ((v22 & 1) != 0)
                v21 = (_QWORD *)*v21;
            }
            if (v6 <= (unint64_t)v21 && v7 > (unint64_t)v21)
              goto LABEL_38;
          }
        }
        if (v8[2] || v8[4] || v8[5])
        {
          if ((*(_DWORD *)(*((_QWORD *)v9 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
          {
            if (PrintConnecting)
            {
              v31 = *v8;
              v26 = objc_class::nameForLogging(v9);
              _objc_inform("CLASS: Attaching category (%s) %p to class %s", v31, v8, v26);
            }
            attachCategories(v14, (uint64_t)v32, (const char *)1, (char *)8, v10, v11, v12);
          }
          else
          {
            if (PrintConnecting)
            {
              v30 = *v8;
              v25 = objc_class::nameForLogging(v9);
              _objc_inform("CLASS: Adding unattached category (%s) %p for class %s", v30, v8, v25);
            }
            objc::UnattachedCategories::addForClass(v8, v13, v14);
          }
        }
        if (!v8[3] && !v8[4] && (!**(_BYTE **)(a1 + 16) || !v8[6]))
          goto LABEL_38;
        v17 = (objc_class *)(*(_QWORD *)v14 & 0xFFFFFFFF8);
        if ((unint64_t)(*(_QWORD *)v17 - 1) >= 0xF
          && (*(_DWORD *)(*(_QWORD *)((*(_QWORD *)v14 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
        {
          if (PrintConnecting)
          {
            v27 = *v8;
            v28 = objc_class::nameForLogging(v14);
            _objc_inform("CLASS: Attaching category (%s) %p to metaclass %s", v27, v8, v28);
            v17 = (objc_class *)(*(_QWORD *)v14 & 0xFFFFFFFF8);
          }
          attachCategories(v17, (uint64_t)v32, (const char *)1, (char *)0xA, v10, v11, v12);
          goto LABEL_38;
        }
        if (PrintConnecting)
        {
          v29 = *v8;
          v24 = objc_class::nameForLogging(v14);
          _objc_inform("CLASS: Adding unattached category (%s) %p for metaclass %s", v29, v8, v24);
          v17 = (objc_class *)(*(_QWORD *)v14 & 0xFFFFFFFF8);
        }
        v15 = v8;
        v16 = v13;
      }
      else
      {
        if (!v8[2] && !v8[4] && !v8[5] && !v8[3] && (!**(_BYTE **)(a1 + 16) || !v8[6]))
          goto LABEL_38;
        v15 = v8;
        v16 = v13;
        v17 = v14;
      }
      objc::UnattachedCategories::addForClass(v15, v16, v17);
LABEL_38:
      v4 = v5;
      v18 = **(_QWORD **)a1 > (unint64_t)v5++;
    }
    while (v18);
  }
}

uint64_t _objc_load_image(uint64_t a1, uint64_t a2)
{
  _QWORD v3[4];

  v3[0] = a2;
  v3[1] = a1;
  v3[2] = 0;
  v3[3] = 0;
  return load_images((uint64_t)v3);
}

void unmap_image(uint64_t a1, header_info *a2)
{
  unint64_t StatusReg;
  unsigned int v4;
  header_info *v6;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char **v15;
  unint64_t v16;
  int v17;
  _QWORD *v18;
  int v19;
  void **v20;
  unint64_t v21;
  BOOL v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  void **v26;
  uint64_t v27;
  void **v28;
  objc_class *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t *v36;
  objc_class **v37;
  int v38;
  objc_class **v39;
  objc_class **v40;
  uint64_t v41;
  objc_class *v42;
  uint64_t v43;
  objc_class **v44;
  char *v45;
  objc_class **v46;
  objc_class *v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  unint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  unint64_t v58;
  _QWORD *v60;
  unint64_t v61;
  char *v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t i;
  int v68;
  unsigned int v69;
  unint64_t v70;
  unint64_t v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  _QWORD v76[3];
  _QWORD *v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v4 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v4, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  if (PrintImages)
    _objc_inform("IMAGES: processing 1 newly-unmapped image...\n");
  v6 = (header_info *)FirstHeader;
  if (FirstHeader)
  {
    while ((header_info *)((char *)v6 + *(_QWORD *)v6) != a2)
    {
      PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v6);
      v8 = (_QWORD *)((char *)v6 + 24);
      if (PreoptimizedHeaderRW)
        v8 = (_QWORD *)PreoptimizedHeaderRW;
      v6 = (header_info *)(*v8 & 0xFFFFFFFFFFFFFFFCLL);
      if (!v6)
        goto LABEL_144;
    }
    if (PrintImages)
    {
      v9 = (const char *)dyld_image_path_containing_address();
      if (*(_DWORD *)((char *)v6 + *(_QWORD *)v6 + 12) == 8)
        v10 = " (bundle)";
      else
        v10 = "";
      _objc_inform("IMAGES: unloading image for %s%s\n", v9, v10);
    }
    v75 = 0;
    v11 = header_info::catlist(v6, &v75);
    v70 = StatusReg;
    v12 = v75;
    if (v75)
    {
      v13 = v11;
      v14 = 0;
      while (1)
      {
        v15 = *(const char ***)(v13 + 8 * v14);
        v16 = remapClass((unint64_t)v15[1]);
        if (v16)
          break;
LABEL_53:
        if (++v14 == v12)
          goto LABEL_54;
      }
      v76[0] = 0;
      v17 = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class const*>(v16, v76);
      v18 = (_QWORD *)v76[0];
      if (v76[0] == objc::unattachedCategories + 24 * dword_1ECCE59C8)
        v19 = 0;
      else
        v19 = v17;
      if (v19 != 1)
      {
LABEL_45:
        if (loadable_categories && loadable_categories_used >= 1)
        {
          v27 = 0;
          v28 = (void **)loadable_categories;
          while (*v28 != v15)
          {
            ++v27;
            v28 += 2;
            if (loadable_categories_used == v27)
              goto LABEL_53;
          }
          *(_QWORD *)(loadable_categories + 16 * v27) = 0;
          if (PrintLoading)
          {
            v29 = (objc_class *)remapClass((unint64_t)v15[1]);
            v30 = objc_class::nameForLogging(v29);
            _objc_inform("LOAD: category '%s(%s)' unscheduled for +load", v30, *v15);
          }
        }
        goto LABEL_53;
      }
      v20 = (void **)(v76[0] + 8);
      v21 = *(_QWORD *)(v76[0] + 16);
      if ((v21 & 1) != 0)
      {
        if (v21 >= 2)
        {
          v23 = 0;
          v24 = v21 >> 1;
          if (v21 >> 1 <= 1)
            v25 = 1;
          else
            v25 = v24;
          v26 = (void **)*v20;
          while (*v26 != v15)
          {
            ++v23;
            v26 += 2;
            if (v25 == v23)
              goto LABEL_38;
          }
          memmove((char *)*v20 + 16 * v23, (char *)*v20 + 16 * (v23 + 1), 16 * (v24 + ~(_DWORD)v23));
          v21 = v18[2] & 0xFFFFFFFF00000001 | (2 * (((unint64_t)(v18[2] - 2) >> 1) & 0x7FFFFFFF));
          v18[2] = v21;
        }
      }
      else if (*v20 == v15)
      {
        *v20 = 0;
        v18[2] = 0;
        v22 = 1;
        goto LABEL_39;
      }
LABEL_38:
      v22 = (v21 & 1) == 0;
      if ((v21 & 1) != 0)
      {
        if (v21 >> 1)
          goto LABEL_45;
LABEL_42:
        if (!v22)
          free(*v20);
        *v18 = -2;
        qword_1ECCE59C0 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE59C0, (int32x2_t)0x1FFFFFFFFLL);
        objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::compact();
        goto LABEL_45;
      }
LABEL_39:
      if (*v20)
        goto LABEL_45;
      goto LABEL_42;
    }
LABEL_54:
    v72 = 0;
    v73 = 0;
    v74 = 0;
    v31 = header_info::classlist(v6, &v75);
    v32 = v75;
    if (v75)
    {
      v33 = (unint64_t *)v31;
      do
      {
        v71 = remapClass(*v33);
        if (v71)
          objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::try_emplace<objc::detail::DenseSetEmpty&>((uint64_t)v76, (int32x2_t *)&v72, &v71);
        ++v33;
        --v32;
      }
      while (v32);
    }
    v34 = header_info::nlclslist(v6, &v75);
    v35 = v75;
    if (v75)
    {
      v36 = (unint64_t *)v34;
      do
      {
        v71 = remapClass(*v36);
        if (v71)
          objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::try_emplace<objc::detail::DenseSetEmpty&>((uint64_t)v76, (int32x2_t *)&v72, &v71);
        ++v36;
        --v35;
      }
      while (v35);
    }
    v37 = (objc_class **)v72;
    if ((_DWORD)v73)
    {
      v38 = v74;
      v39 = (objc_class **)((char *)v72 + 8 * v74);
      v40 = (objc_class **)v72;
      if ((_DWORD)v74)
      {
        v41 = 0;
        while (*(_QWORD *)((char *)v72 + v41) >= 0xFFFFFFFFFFFFFFFELL)
        {
          v41 += 8;
          if (8 * v74 == v41)
            goto LABEL_88;
        }
        v40 = (objc_class **)((char *)v72 + v41);
      }
      if (v40 != v39)
      {
        v42 = *v40;
LABEL_73:
        if (loadable_classes && loadable_classes_used >= 1)
        {
          v43 = 0;
          v44 = (objc_class **)loadable_classes;
          while (*v44 != v42)
          {
            ++v43;
            v44 += 2;
            if (loadable_classes_used == v43)
              goto LABEL_81;
          }
          *(_QWORD *)(loadable_classes + 16 * v43) = 0;
          if (PrintLoading)
          {
            v45 = objc_class::nameForLogging(v42);
            _objc_inform("LOAD: class '%s' unscheduled for +load", v45);
          }
        }
LABEL_81:
        detach_class((objc_class *)(*(_QWORD *)v42 & 0xFFFFFFFF8), 1);
        detach_class(v42, 0);
        while (++v40 != v39)
        {
          v42 = *v40;
          if ((unint64_t)*v40 < 0xFFFFFFFFFFFFFFFELL)
          {
            if (v40 != v39)
              goto LABEL_73;
            break;
          }
        }
        v37 = (objc_class **)v72;
        if (!(_DWORD)v73)
          goto LABEL_99;
        v38 = v74;
        v39 = (objc_class **)((char *)v72 + 8 * v74);
      }
      v46 = v37;
      if (v38)
      {
LABEL_88:
        v46 = v37;
        while ((unint64_t)*v46 >= 0xFFFFFFFFFFFFFFFELL)
        {
          if (++v46 == v39)
            goto LABEL_99;
        }
      }
      if (v46 != v39)
      {
        v47 = *v46;
LABEL_94:
        free_class((objc_class *)(*(_QWORD *)v47 & 0xFFFFFFFF8));
        free_class(v47);
        while (++v46 != v39)
        {
          v47 = *v46;
          if ((unint64_t)*v46 < 0xFFFFFFFFFFFFFFFELL)
          {
            if (v46 != v39)
              goto LABEL_94;
            break;
          }
        }
        v37 = (objc_class **)v72;
      }
    }
LABEL_99:
    free(v37);
    v48 = FirstHeader;
    StatusReg = v70;
    if (!FirstHeader)
    {
LABEL_119:
      v58 = (unint64_t)v6 + *(_QWORD *)v6;
      if (dataSegmentsRanges > v58 || *(_QWORD *)algn_1ECCE5978 <= v58)
      {
        v60 = v76;
        v76[0] = off_1E0DF36F8;
        v77 = v76;
        v61 = *(unsigned int *)(v58 + 16);
        if ((_DWORD)v61)
        {
          v62 = (char *)(v58 + 32);
          v63 = *(unsigned int *)(v58 + 16);
          v64 = v58 + 32;
          while (*(_DWORD *)v64 != 25 || strncmp((const char *)(v64 + 8), "__TEXT", 0x10uLL))
          {
            v64 += *(unsigned int *)(v64 + 4);
            if (!--v63)
            {
              v65 = 0;
              goto LABEL_131;
            }
          }
          v65 = v58 - *(_QWORD *)(v64 + 24);
LABEL_131:
          for (i = 0; i < v61; ++i)
          {
            if (*(_DWORD *)v62 == 25 && (!strncmp(v62 + 8, "__DATA", 6uLL) || !strncmp(v62 + 8, "__AUTH", 6uLL)))
            {
              v72 = v62;
              v75 = v65;
              if (!v77)
              {
                std::__throw_bad_function_call[abi:nn180100]();
                __break(1u);
                return;
              }
              (*(void (**)(_QWORD *, void **, unint64_t *))(*v77 + 48))(v77, &v72, &v75);
              v61 = *(unsigned int *)(v58 + 16);
            }
            v62 += *((unsigned int *)v62 + 1);
          }
          v60 = v77;
          if (v77 == v76)
          {
            v66 = 4;
            v60 = v76;
            StatusReg = v70;
          }
          else
          {
            StatusReg = v70;
            if (!v77)
              goto LABEL_143;
            v66 = 5;
          }
        }
        else
        {
          v66 = 4;
        }
        (*(void (**)(void))(*v60 + 8 * v66))();
      }
LABEL_143:
      free(v6);
      goto LABEL_144;
    }
    if ((header_info *)FirstHeader != v6)
    {
      while (1)
      {
        v49 = getPreoptimizedHeaderRW(v48);
        v50 = (_QWORD *)(v48 + 24);
        if (v49)
          v50 = (_QWORD *)v49;
        v51 = *v50 & 0xFFFFFFFFFFFFFFFCLL;
        if (!v51)
          goto LABEL_119;
        v52 = v48;
        v48 = v51;
        if (v6 == (header_info *)v51)
          goto LABEL_107;
      }
    }
    v52 = 0;
LABEL_107:
    v53 = getPreoptimizedHeaderRW((uint64_t)v6);
    v54 = (_QWORD *)((char *)v6 + 24);
    if (v53)
      v54 = (_QWORD *)v53;
    v55 = *v54 & 0xFFFFFFFFFFFFFFFCLL;
    if (v52)
    {
      v56 = getPreoptimizedHeaderRW(v52);
      v57 = (_QWORD *)(v52 + 24);
      if (v56)
        v57 = (_QWORD *)v56;
      *v57 = *v57 & 3 | v55;
      if ((header_info *)LastHeaderRealizedAllClasses != v6)
        goto LABEL_117;
    }
    else
    {
      FirstHeader = *v54 & 0xFFFFFFFFFFFFFFFCLL;
      if ((header_info *)LastHeaderRealizedAllClasses != v6)
        goto LABEL_117;
      v52 = 0;
    }
    LastHeaderRealizedAllClasses = v52;
LABEL_117:
    if ((header_info *)LastHeader == v6)
      LastHeader = 0;
    goto LABEL_119;
  }
LABEL_144:
  v68 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v69 = __ldxr(runtimeLock);
    if (v69 != v68)
      break;
    if (!__stlxr(0, runtimeLock))
      goto LABEL_149;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_149:
  os_unfair_recursive_lock_unlock();
}

void sub_1801262F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  unsigned int *v21;
  int v23;
  unsigned int v24;

  free(a14);
  v23 = *(_DWORD *)(a12 + 24);
  while (1)
  {
    v24 = __ldxr(v21);
    if (v24 != v23)
      break;
    if (!__stlxr(0, v21))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  os_unfair_recursive_lock_unlock();
  _Unwind_Resume(a1);
}

void realizeAllClasses(void)
{
  header_info *v0;
  uint64_t v1;
  BOOL v2;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v5;
  BOOL v6;
  unint64_t StatusReg;
  uint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  objc_class *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v0 = (header_info *)FirstHeader;
  v1 = LastHeaderRealizedAllClasses;
  if (LastHeaderRealizedAllClasses)
    v2 = FirstHeader == 0;
  else
    v2 = 1;
  if (!v2 && FirstHeader != LastHeaderRealizedAllClasses)
  {
    do
    {
      PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v0);
      v5 = (_QWORD *)((char *)v0 + 24);
      if (PreoptimizedHeaderRW)
        v5 = (_QWORD *)PreoptimizedHeaderRW;
      v0 = (header_info *)(*v5 & 0xFFFFFFFFFFFFFFFCLL);
      if (v0)
        v6 = v1 == (_QWORD)v0;
      else
        v6 = 1;
    }
    while (!v6);
  }
  if (v0)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    do
    {
      v23 = 0;
      v8 = header_info::classlist(v0, &v23);
      v9 = v23;
      if (v23)
      {
        v10 = (unint64_t *)v8;
        do
        {
          v11 = (objc_class *)remapClass(*v10);
          if (v11)
            realizeClassMaybeSwiftMaybeRelock(v11, 1);
          ++v10;
          --v9;
        }
        while (v9);
      }
      v12 = _dyld_lookup_section_info();
      v14 = v13 >> 3;
      if (!v12)
        v14 = 0;
      v23 = v14;
      if (v14)
      {
        v15 = v12;
        v16 = 0;
        do
        {
          if (remapClass(*(_QWORD *)(v15 + 8 * v16)) == *(_QWORD *)(v15 + 8 * v16))
          {
            v17 = *(_DWORD *)(StatusReg + 24);
            while (1)
            {
              v18 = __ldxr(runtimeLock);
              if (v18 != v17)
                break;
              if (!__stlxr(0, runtimeLock))
                goto LABEL_32;
            }
            __clrex();
            os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_32:
            (*(void (**)(void))(*(_QWORD *)(v15 + 8 * v16) + 8))();
            v19 = *(_DWORD *)(StatusReg + 24);
            while (!__ldaxr(runtimeLock))
            {
              if (!__stxr(v19, runtimeLock))
                goto LABEL_37;
            }
            __clrex();
            os_unfair_lock_lock_with_options();
          }
LABEL_37:
          ++v16;
        }
        while (v16 < v23);
      }
      LastHeaderRealizedAllClasses = (uint64_t)v0;
      v21 = getPreoptimizedHeaderRW((uint64_t)v0);
      v22 = (_QWORD *)((char *)v0 + 24);
      if (v21)
        v22 = (_QWORD *)v21;
      v0 = (header_info *)(*v22 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v0);
  }
}

__objc2_class *_read_images::$_1::operator()(__objc2_class *result, uint64_t a2, const char *a3, char *a4)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  BOOL v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  BOOL v24;

  v4 = (_QWORD *)((unint64_t)result & 0xF00007FFFFFFFF8);
  if (((unint64_t)result & 0x8000000000000000) != 0)
  {
    v5 = *(_QWORD *)(((unint64_t)result & 0xF00007FFFFFFFF8) + 8);
    v4 = (_QWORD *)(v5 & 0xFFFFFFFFFFFFFFFELL);
    if ((v5 & 1) != 0)
      v4 = (_QWORD *)*v4;
  }
  v6 = v4[4];
  v7 = (unsigned int *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  if ((v6 & 1) != 0 || !v7)
  {
    v8 = v6 & 1;
    if (v7)
      v9 = v8 == 0;
    else
      v9 = 1;
    if (!v9)
    {
      if (DisablePreattachedCategories)
      {
        v12 = *v7;
        v11 = v7[1];
        v23 = v11 * (unint64_t)v12;
        if ((v23 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v11, v7, *v7);
        v10 = (uint64_t *)((char *)v7 + v23 + 8);
        v24 = (_DWORD)v11 == 0;
        if ((_DWORD)v11)
          v11 = v11;
        else
          v11 = 0;
        if (!v24)
          v10 = (uint64_t *)((char *)v10 - v12);
      }
      else
      {
        v10 = (uint64_t *)(v7 + 2);
        v12 = *v7;
        v11 = v7[1];
      }
      v13 = v11 * (unint64_t)v12;
      if ((v13 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v11, v7, v12);
      v14 = (unint64_t)v7 + v13 + 8;
      if ((unint64_t)v10 < v14)
      {
        while ((*(_QWORD *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v10 + 8) & 1) == 0)
        {
          v10 = (uint64_t *)((char *)v10 + v12);
          v15 = v12;
          if ((unint64_t)v10 >= v14)
            goto LABEL_20;
        }
      }
      v15 = v12;
LABEL_20:
      if (v10 != (uint64_t *)v14)
      {
        v16 = _read_images::PreoptTotalMethodLists;
        result = Object;
        do
        {
          v17 = *v10 >> 16;
          _read_images::PreoptTotalMethodLists = ++v16;
          if ((~*(_DWORD *)((char *)v10 + v17) & 3) == 0)
            ++_read_images::PreoptOptimizedMethodLists;
          v18 = *v7;
          v19 = v18 * (unint64_t)v11;
          if ((v19 & 0xFFFFFFFF00000000) != 0)
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v18, (const char *)v19, a4, v11, v7, *v7);
          v20 = v15;
          v21 = (unint64_t)v7 + v19 + 8;
          v22 = (uint64_t *)((char *)v10 + v15);
          do
          {
            v10 = v22;
            if ((unint64_t)v22 >= v21)
              break;
            a4 = *(char **)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v22 + 8);
            v22 = (uint64_t *)((char *)v22 + v20);
          }
          while ((a4 & 1) == 0);
          v15 = v20;
        }
        while (v10 != (uint64_t *)v14);
      }
    }
  }
  else
  {
    ++_read_images::PreoptTotalMethodLists;
    if ((~*v7 & 3) == 0)
      ++_read_images::PreoptOptimizedMethodLists;
  }
  return result;
}

void detach_class(objc_class *a1, char a2)
{
  uint64_t v4;
  const char *v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  unsigned int v11;
  uint64_t v12;
  objc_class *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v17;
  objc_class *v18;
  uint64_t v19;
  uint64_t v20;

  v20 = 0;
  if (objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class const*>((unint64_t)a1, &v20))
  {
    v7 = (_QWORD *)v20;
    if ((*(_BYTE *)(v20 + 16) & 1) != 0)
      free(*(void **)(v20 + 8));
    *v7 = -2;
    qword_1ECCE59C0 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE59C0, (int32x2_t)0x1FFFFFFFFLL);
    objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::compact();
  }
  if ((unint64_t)(*(_QWORD *)a1 - 1) < 0xF
    || (v8 = *((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8, (*(_DWORD *)v8 & 0x80000000) == 0))
  {
LABEL_9:
    if ((a2 & 1) != 0)
      goto LABEL_16;
    goto LABEL_10;
  }
  v9 = *((_QWORD *)a1 + 1);
  if (v9)
  {
    removeSubclass(*(_QWORD *)(v9 + 32), a1);
    goto LABEL_9;
  }
  ++objc_debug_realized_class_generation_count;
  v17 = &_firstRealizedClass;
  v18 = (objc_class *)_firstRealizedClass;
  if ((objc_class *)_firstRealizedClass != a1)
  {
    do
    {
      v19 = *((_QWORD *)v18 + 4) & 0xF00007FFFFFFFF8;
      v18 = *(objc_class **)(v19 + 0x18);
    }
    while (v18 != a1);
    v17 = (uint64_t *)(v19 + 24);
  }
  *v17 = *(_QWORD *)(v8 + 24);
  if ((a2 & 1) == 0)
  {
LABEL_10:
    v10 = objc_class::mangledName(a1, v4, v5, v6);
    v11 = _mapStrHash((uint64_t)v10, v10);
    v20 = 0;
    v12 = _NXMapMemberWithHash(gdb_objc_realized_classes, (uint64_t)v10, v11, &v20);
    v13 = (objc_class *)v20;
    if (v12 == -1)
      v13 = 0;
    if (v13 == a1)
    {
      v14 = gdb_objc_realized_classes;
      v15 = (uint64_t)v10;
    }
    else
    {
      v14 = nonMetaClasses();
      v15 = *(_QWORD *)a1 & 0xFFFFFFFF8;
    }
    NXMapRemove(v14, v15);
  }
LABEL_16:
  v20 = 0;
  if (objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::LookupBucketFor<objc_class *>((uint64_t)&objc::allocatedClasses, (unint64_t)a1, &v20))
  {
    *(_QWORD *)v20 = -2;
    qword_1ECCE5758 = (uint64_t)vadd_s32((int32x2_t)qword_1ECCE5758, (int32x2_t)0x1FFFFFFFFLL);
    if ((_DWORD)qword_1ECCE5758)
    {
      if (qword_1ECCE5760 >= 0x401 && qword_1ECCE5760 >> 4 > qword_1ECCE5758)
        objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::grow((uint64_t)&objc::allocatedClasses, 2 * qword_1ECCE5758);
    }
    else if ((_DWORD)qword_1ECCE5760)
    {
      free((void *)objc::allocatedClasses);
      objc::allocatedClasses = 0;
      qword_1ECCE5758 = 0;
      LODWORD(qword_1ECCE5760) = 0;
    }
    else
    {
      qword_1ECCE5758 = 0;
    }
  }
}

void free_class(objc_class *a1)
{
  objc_class *v1;
  _DWORD *v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;
  uint64_t *v15;
  const char *v16;
  char *v17;
  uint64_t v18;
  method_t *v19;
  void *v20;
  uint64_t v21;
  const char *v22;
  char *v23;
  void *v24;
  int32x2_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  BOOL v30;
  unint64_t v32;
  uint64_t v33;
  void *v34;
  unsigned int *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  void *v42;
  void *v43;
  uint64_t *v44;
  const char *v45;
  char *v46;
  uint64_t v47;
  const char *v48;
  char *v49;
  method_t *v50;
  void *v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  BOOL v57;
  unint64_t v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  _DWORD *v63;
  unint64_t v65;
  uint64_t v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  _QWORD v71[12];
  uint64_t *v72[9];
  method_t *v73;
  _QWORD *v74;

  if ((unint64_t)(*(_QWORD *)a1 - 1) < 0xF)
    return;
  v1 = a1;
  v2 = (_DWORD *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8);
  if ((*v2 & 0x80000000) == 0)
    return;
  v3 = (uint64_t *)(*(_QWORD *)((*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) + 8) & ((uint64_t)(*(_QWORD *)((*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) + 8) << 63) >> 63) & 0xFFFFFFFFFFFFFFFELL);
  v4 = *(_QWORD *)((*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) + 8);
  v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
  if ((v4 & 1) != 0)
    v5 = *(_QWORD *)v5;
  v6 = (_QWORD *)((char *)a1 + 16);
  if (!cache_t::isConstantEmptyCache((objc_class *)((char *)a1 + 16))
    && (*v6 & 1) == 0
    && ((objc_cache *)*v6 == &_objc_empty_cache || HIWORD(*v6)))
  {
    if (PrintCaches)
    {
      v10 = HIWORD(*v6);
      if (v10)
      {
        v10 = HIWORD(*v6);
        if ((_DWORD)v10)
        {
          v11 = v10 + 1;
          v12 = -1;
          do
          {
            v13 = v12++;
            v14 = v11 > 3;
            v11 >>= 1;
          }
          while (v14);
          if (v12 > 0xE)
            goto LABEL_17;
          LODWORD(v10) = v13 + 2;
        }
      }
      --cache_counts[v10];
    }
LABEL_17:
    free((void *)(*v6 & 0xFFFFFFFFFFFLL));
  }
  if (!v3)
    goto LABEL_55;
  v15 = v3 + 1;
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::begin((uint64_t)v72, v3 + 1, v8, v9);
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::end((uint64_t)v71, v3 + 1, v16, v17);
  while (!list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v72, v71))
  {
    v19 = v73;
    v20 = (void *)method_t::types((unint64_t)v73, v18);
    if (v20)
    {
      v24 = v20;
      if (malloc_size(v20))
        free(v24);
    }
    if (byte_1ECCE4E28)
    {
      v74 = 0;
      if (objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>((unint64_t)v19, &v74))
      {
        *v74 = -2;
        v25 = vadd_s32((int32x2_t)qword_1ECCE4E18, (int32x2_t)0x1FFFFFFFFLL);
        qword_1ECCE4E18 = (uint64_t)v25;
        if (v25.i32[0])
        {
          if (dword_1ECCE4E20 >= 0x401 && dword_1ECCE4E20 >> 4 > v25.i32[0])
            objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::grow(2 * v25.i32[0]);
        }
        else if (dword_1ECCE4E20)
        {
          free((void *)objc::methodDescriptionMap);
          objc::methodDescriptionMap = 0;
          qword_1ECCE4E18 = 0;
          dword_1ECCE4E20 = 0;
        }
        else
        {
          qword_1ECCE4E18 = 0;
        }
      }
    }
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator++(v72, v21, v22, v23);
  }
  v26 = *v15;
  v27 = *v15 & 3;
  v28 = (_DWORD *)(*v15 & 0xFFFFFFFFFFFFFFFCLL);
  if (v27 != 1 || v28 == 0)
  {
    if (v27)
      v30 = 1;
    else
      v30 = v28 == 0;
    v28 = (_DWORD *)(v26 & 0xFFFFFFFFFFFFFFCLL);
    if (v30 || v28 == 0)
      goto LABEL_55;
  }
  else if (*v28)
  {
    v32 = 0;
    do
    {
      v33 = *(_QWORD *)&v28[2 * v32 + 2];
      v34 = (void *)(v33 & 0xFFFFFFFFFFFFFFFLL);
      if ((v33 & 0xFFFFFFFFFFFFFFFLL) != 0 && malloc_size((const void *)(v33 & 0xFFFFFFFFFFFFFFFLL)))
        free(v34);
      ++v32;
    }
    while (v32 < *v28);
  }
  if (malloc_size(v28))
    free(v28);
LABEL_55:
  v35 = *(unsigned int **)(v5 + 48);
  if (v35)
  {
    v37 = *v35;
    v36 = v35[1];
    v38 = v36 * (unint64_t)v37;
    if ((v38 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v7, v8, v9, v36, *(_QWORD *)(v5 + 48), v37);
    if ((_DWORD)v38)
    {
      v39 = 0;
      v40 = v38;
      do
      {
        v41 = *(void **)((char *)v35 + v39 + 8);
        if (v41 && malloc_size(*(const void **)((char *)v35 + v39 + 8)))
          free(v41);
        v42 = *(void **)((char *)v35 + v39 + 16);
        if (v42 && malloc_size(*(const void **)((char *)v35 + v39 + 16)))
          free(v42);
        v43 = *(void **)((char *)v35 + v39 + 24);
        if (v43 && malloc_size(*(const void **)((char *)v35 + v39 + 24)))
          free(v43);
        v39 += v37;
      }
      while (v40 != v39);
    }
    if (malloc_size(v35))
      free(v35);
  }
  if (!v3)
    goto LABEL_119;
  v44 = v3 + 2;
  list_array_tt<property_t,property_list_t,RawPtr>::begin((uint64_t)v72, v3 + 2, v8, v9);
  list_array_tt<property_t,property_list_t,RawPtr>::end((uint64_t)v71, v3 + 2, v45, v46);
  while (!list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v72, v71))
  {
    v50 = v73;
    v51 = *(void **)v73;
    if (*(_QWORD *)v73 && malloc_size(*(const void **)v73))
      free(v51);
    v52 = (void *)*((_QWORD *)v50 + 1);
    if (v52 && malloc_size(*((const void **)v50 + 1)))
      free(v52);
    list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator++(v72, v47, v48, v49);
  }
  v53 = *v44;
  v54 = *v44 & 3;
  v55 = (_DWORD *)(*v44 & 0xFFFFFFFFFFFFFFFCLL);
  if (v54 != 1 || v55 == 0)
  {
    if (v54)
      v57 = 1;
    else
      v57 = v55 == 0;
    v55 = (_DWORD *)(v53 & 0xFFFFFFFFFFFFFFCLL);
    if (v57 || v55 == 0)
      goto LABEL_102;
  }
  else if (*v55)
  {
    v59 = 0;
    do
    {
      v60 = *(_QWORD *)&v55[2 * v59 + 2];
      v61 = (void *)(v60 & 0xFFFFFFFFFFFFFFFLL);
      if ((v60 & 0xFFFFFFFFFFFFFFFLL) != 0 && malloc_size((const void *)(v60 & 0xFFFFFFFFFFFFFFFLL)))
        free(v61);
      ++v59;
    }
    while (v59 < *v55);
  }
  if (malloc_size(v55))
    free(v55);
LABEL_102:
  v62 = v3[3];
  v63 = (_DWORD *)(v62 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v62 & 3) == 1 && v63 != 0)
  {
    if (*v63)
    {
      v65 = 0;
      do
      {
        v66 = *(_QWORD *)&v63[2 * v65 + 2];
        v67 = (void *)(v66 & 0xFFFFFFFFFFFFFFFLL);
        if ((v66 & 0xFFFFFFFFFFFFFFFLL) != 0 && malloc_size((const void *)(v66 & 0xFFFFFFFFFFFFFFFLL)))
          free(v67);
        ++v65;
      }
      while (v65 < *v63);
    }
    goto LABEL_117;
  }
  if ((v62 & 3) == 0)
  {
    if (v63)
    {
      v63 = (_DWORD *)(v62 & 0xFFFFFFFFFFFFFFCLL);
      if ((v62 & 0xFFFFFFFFFFFFFFCLL) != 0)
      {
LABEL_117:
        if (malloc_size(v63))
          free(v63);
      }
    }
  }
LABEL_119:
  if ((*(_BYTE *)v5 & 1) == 0)
  {
    v68 = *(void **)(v5 + 16);
    if (v68)
    {
      if (malloc_size(*(const void **)(v5 + 16)))
        free(v68);
    }
  }
  v69 = *(void **)(v5 + 56);
  if (v69 && malloc_size(*(const void **)(v5 + 56)))
    free(v69);
  if ((*((_WORD *)v1 + 15) & 4) == 0)
  {
    v70 = (void *)atomic_load((unint64_t *)(v5 + 24));
    if (v70)
    {
      if (malloc_size(v70))
        free(v70);
    }
  }
  if (malloc_size((const void *)v5))
    free((void *)v5);
  free(v3);
  free(v2);
  if ((*((_BYTE *)v1 + 32) & 2) != 0)
    v1 = (objc_class *)((char *)v1 - *((unsigned int *)v1 + 15));
  if (malloc_size(v1))
    free(v1);
}

void _method_setImplementationRawUnsafe(method_t *this, void (*a2)(void))
{
  unint64_t StatusReg;
  unsigned int v5;
  int v7;
  unsigned int v8;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v5, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  method_t::setImp((uint64_t)this, a2);
  v7 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v8 = __ldxr(runtimeLock);
    if (v8 != v7)
      break;
    if (!__stlxr(0, runtimeLock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
}

void sub_180126FC0(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

__n128 __copy_helper_block_e8_32c43_ZTSKZ30method_exchangeImplementationsE3__0(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 32);
  v3 = *(_OWORD *)(a2 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

void protocol_addMethodDescription(Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod)
{
  _BOOL4 v6;
  const char *v7;
  unint64_t StatusReg;
  unsigned int v11;
  const char *v13;
  Protocol *v14;
  Protocol *v15;
  _DWORD *isa;
  uint64_t v17;
  unint64_t v18;
  objc_class *v19;
  uint64_t v20;
  const char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  size_t v27;
  void *v28;
  int v29;
  unsigned int v30;

  if (proto)
  {
    v6 = isRequiredMethod;
    v7 = types;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v11 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v11, runtimeLock))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_7:
    if ((__objc2_class *)((uint64_t)proto->super.isa & 0xFFFFFFFF8) == __IncompleteProtocol)
    {
      if (!v6 || !isInstanceMethod)
      {
        if (!isInstanceMethod || v6)
          v15 = proto + 6;
        else
          v15 = proto + 5;
        if (!v6 || isInstanceMethod)
          v14 = v15;
        else
          v14 = proto + 4;
      }
      else
      {
        v14 = proto + 3;
      }
      isa = v14->super.isa;
      if (v14->super.isa)
      {
        v17 = *isa & 0xFFFCLL;
        v18 = isa[1] * (unint64_t)v17;
        if ((v18 & 0xFFFFFFFF00000000) != 0)
          _objc_fatal("entsize_list_tt overflow: count %u with entsize %u", (uint64_t)name, types, (char *)isRequiredMethod, isa[1], v17);
        v19 = (objc_class *)malloc_type_realloc(isa, v17 + v18 + 8, 0x4755E9A6uLL);
        v14->super.isa = v19;
        v23 = (unsigned __int16)*(_DWORD *)v19 & 0xFFFC;
      }
      else
      {
        v19 = (objc_class *)malloc_type_calloc(0x20uLL, 1uLL, 0x8B7F0322uLL);
        v14->super.isa = v19;
        v23 = 24;
        *(_DWORD *)v19 = 24;
      }
      v24 = *((unsigned int *)v19 + 1);
      *((_DWORD *)v19 + 1) = v24 + 1;
      v25 = v24 * (unint64_t)v23;
      if ((v25 & 0xFFFFFFFF00000000) != 0)
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v20, v21, v22, v24, v19, v23);
      v26 = (_QWORD *)(((unint64_t)v19 + v25 + 8) & 0xFFFFFFFFFFFFFFFCLL);
      *v26 = name;
      if (v7)
      {
        v27 = strlen(v7) + 1;
        if ((_dyld_is_memory_immutable() & 1) == 0)
        {
          v28 = malloc_type_malloc(v27, 0x3F84A03uLL);
          memcpy(v28, v7, v27);
          v7 = (const char *)v28;
        }
      }
      else
      {
        v7 = "";
      }
      v26[1] = v7;
      v26[2] = 0;
    }
    else
    {
      v13 = (const char *)protocol_t::demangledName((char **)proto);
      _objc_inform("protocol_addMethodDescription: protocol '%s' is not under construction!", v13);
    }
    v29 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v30 = __ldxr(runtimeLock);
      if (v30 != v29)
        break;
      if (!__stlxr(0, runtimeLock))
        return;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_18012724C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void protocol_addProperty(Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
{
  const char *v6;
  _BOOL4 v7;
  _BOOL4 v8;
  unint64_t StatusReg;
  unsigned int v13;
  const char *v15;
  Protocol *v16;
  unsigned int *isa;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  const char *v22;
  char *v23;
  objc_class *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  size_t v28;
  void *v29;
  char *v30;
  int v31;
  unsigned int v32;

  if (!proto)
    return;
  v6 = name;
  if (!name)
    return;
  v7 = isInstanceProperty;
  v8 = isRequiredProperty;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v13 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v13, runtimeLock))
      goto LABEL_8;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_8:
  if ((__objc2_class *)((uint64_t)proto->super.isa & 0xFFFFFFFF8) != __IncompleteProtocol)
  {
    v15 = (const char *)protocol_t::demangledName((char **)proto);
    _objc_inform("protocol_addProperty: protocol '%s' is not under construction!", v15);
    goto LABEL_24;
  }
  if (v8 && v7)
  {
    v16 = proto + 7;
  }
  else
  {
    if (!v8 || v7)
      goto LABEL_24;
    v16 = proto + 11;
  }
  isa = (unsigned int *)v16->super.isa;
  if (v16->super.isa)
  {
    v18 = *isa;
    v19 = isa[1] + 1;
    isa[1] = v19;
    v20 = v18 * (unint64_t)v19;
    if ((v20 & 0xFFFFFFFF00000000) != 0)
      _objc_fatal("entsize_list_tt overflow: count %u with entsize %u", (uint64_t)name, (const char *)attributes, *(char **)&attributeCount, v19, v18);
    v24 = (objc_class *)malloc_type_realloc(isa, v20 + 8, 0x216364AEuLL);
    v16->super.isa = v24;
    v25 = *(unsigned int *)v24;
    v26 = (*((_DWORD *)v24 + 1) - 1);
  }
  else
  {
    v24 = (objc_class *)malloc_type_calloc(0x18uLL, 1uLL, 0xEE94C62CuLL);
    v26 = 0;
    v16->super.isa = v24;
    *(_QWORD *)v24 = 0x100000010;
    v25 = 16;
  }
  v27 = v26 * (unint64_t)v25;
  if ((v27 & 0xFFFFFFFF00000000) != 0)
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v21, v22, v23, v26, v24, v25);
  v28 = strlen(v6) + 1;
  if ((_dyld_is_memory_immutable() & 1) == 0)
  {
    v29 = malloc_type_malloc(v28, 0x3F84A03uLL);
    memcpy(v29, v6, v28);
    v6 = (const char *)v29;
  }
  v30 = (char *)v24 + v27;
  *((_QWORD *)v30 + 1) = v6;
  *((_QWORD *)v30 + 2) = copyPropertyAttributeString((uint64_t)attributes, attributeCount);
LABEL_24:
  v31 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v32 = __ldxr(runtimeLock);
    if (v32 != v31)
      break;
    if (!__stlxr(0, runtimeLock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
}

void sub_1801274B8(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t _objc_getRealizedClassList_trylock(objc_class **a1, uint64_t a2)
{
  const char *v4;
  char *v5;
  uint64_t RealizedClassList_nolock;
  int v7;
  unsigned int v8;

  if (!os_unfair_lock_trylock((os_unfair_lock_t)runtimeLock))
    return -1;
  RealizedClassList_nolock = objc_getRealizedClassList_nolock(a1, a2, v4, v5);
  v7 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (1)
  {
    v8 = __ldxr(runtimeLock);
    if (v8 != v7)
      break;
    if (!__stlxr(0, runtimeLock))
      return RealizedClassList_nolock;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return RealizedClassList_nolock;
}

uint64_t objc_getRealizedClassList_nolock(objc_class **a1, uint64_t a2, const char *a3, char *a4)
{
  _QWORD *v4;
  _QWORD v6[5];
  _QWORD v7[8];
  uint64_t v8;
  uint64_t v9;

  v9 = 0;
  if (a1)
  {
    v8 = 0;
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3321888768;
    v7[2] = ___ZL32objc_getRealizedClassList_nolockPP10objc_classm_block_invoke;
    v7[3] = &__block_descriptor_64_e8_32c61_ZTSKZL32objc_getRealizedClassList_nolockPP10objc_classmE3__0_e8_B16__0_8l;
    v7[4] = &v9;
    v7[5] = &v8;
    v7[6] = a2;
    v7[7] = a1;
    v4 = v7;
  }
  else
  {
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3321888768;
    v6[2] = ___ZL32objc_getRealizedClassList_nolockPP10objc_classm_block_invoke_161;
    v6[3] = &__block_descriptor_40_e8_32c61_ZTSKZL32objc_getRealizedClassList_nolockPP10objc_classmE3__1_e8_B16__0_8l;
    v6[4] = &v9;
    v4 = v6;
  }
  foreach_realized_class((uint64_t)v4, a2, a3, a4);
  return v9;
}

uint64_t ___ZL32objc_getRealizedClassList_nolockPP10objc_classm_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(uint64_t **)(a1 + 40);
  ++**(_QWORD **)(a1 + 32);
  v3 = *v2;
  if ((unint64_t)*v2 < *(_QWORD *)(a1 + 48))
  {
    v4 = *(_QWORD *)(a1 + 56);
    *v2 = v3 + 1;
    *(_QWORD *)(v4 + 8 * v3) = a2;
  }
  return 1;
}

uint64_t ___ZL32objc_getRealizedClassList_nolockPP10objc_classm_block_invoke_161(uint64_t a1)
{
  ++**(_QWORD **)(a1 + 32);
  return 1;
}

uint64_t __copy_helper_block_e8_32c61_ZTSKZL32objc_getRealizedClassList_nolockPP10objc_classmE3__1(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

__n128 __copy_helper_block_e8_32c61_ZTSKZL32objc_getRealizedClassList_nolockPP10objc_classmE3__0(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 32);
  v3 = *(_OWORD *)(a2 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

int objc_getClassList(Class *buffer, int bufferCount)
{
  unint64_t StatusReg;
  unsigned int v5;
  const char *v7;
  char *v8;
  int RealizedClassList_nolock;
  int v10;
  unsigned int v11;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v5, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  realizeAllClasses();
  RealizedClassList_nolock = objc_getRealizedClassList_nolock(buffer, bufferCount, v7, v8);
  v10 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v11 = __ldxr(runtimeLock);
    if (v11 != v10)
      break;
    if (!__stlxr(0, runtimeLock))
      return RealizedClassList_nolock;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return RealizedClassList_nolock;
}

void sub_18012772C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *objc_copyRealizedClassList(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  unint64_t StatusReg;
  unsigned int v6;
  _QWORD *v8;
  int v9;
  unsigned int v10;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v6, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v8 = objc_copyRealizedClassList_nolock(a1, a2, a3, a4);
  v9 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v10 = __ldxr(runtimeLock);
    if (v10 != v9)
      break;
    if (!__stlxr(0, runtimeLock))
      return v8;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v8;
}

void sub_1801277FC(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

Class *__cdecl objc_copyClassList(unsigned int *outCount)
{
  unint64_t StatusReg;
  unsigned int v3;
  uint64_t v5;
  const char *v6;
  char *v7;
  Class *v8;
  int v9;
  unsigned int v10;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v3, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  realizeAllClasses();
  v8 = (Class *)objc_copyRealizedClassList_nolock(outCount, v5, v6, v7);
  v9 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v10 = __ldxr(runtimeLock);
    if (v10 != v9)
      break;
    if (!__stlxr(0, runtimeLock))
      return v8;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v8;
}

void sub_1801278D0(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void _objc_endClassEnumeration(uint64_t a1)
{
  if (*(_QWORD *)a1 == -1)
    free(*(void **)(a1 + 40));
}

unint64_t _objc_setHook_msgSendCacheMiss(unint64_t result, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  int v5;

  v2 = msgSendCacheMissHook;
  *a2 = msgSendCacheMissHook;
  v3 = __ldxr((unint64_t *)&msgSendCacheMissHook);
  if (v3 != v2)
  {
    __clrex();
LABEL_5:
    while (1)
    {
      *a2 = v3;
      v4 = __ldxr((unint64_t *)&msgSendCacheMissHook);
      if (v4 != v3)
        break;
      if (__stlxr(result, (unint64_t *)&msgSendCacheMissHook))
        goto LABEL_9;
      v5 = 1;
LABEL_10:
      v3 = v4;
      if (v5)
        return result;
    }
    __clrex();
LABEL_9:
    v5 = 0;
    goto LABEL_10;
  }
  if (__stlxr(result, (unint64_t *)&msgSendCacheMissHook))
    goto LABEL_5;
  return result;
}

char *class_copyImpCache(uint64_t a1, _DWORD *a2)
{
  unint64_t StatusReg;
  unsigned int v5;
  uint64_t v7;
  char *v8;
  char *v9;
  _QWORD *v10;
  objc_cache *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  char *v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  unint64_t v22;
  int v23;
  unint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v5, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v7 = *(unsigned __int16 *)(a1 + 28);
  if (*(_WORD *)(a1 + 28))
  {
    v8 = (char *)malloc_type_calloc(v7 + 1, 0x10uLL, 0x80040803F642BuLL);
    v9 = v8;
    v10 = (_QWORD *)(a1 + 16);
    v11 = *(objc_cache **)(a1 + 16);
    if ((v11 & 1) == 0 && (v11 == &_objc_empty_cache || HIWORD(*v10)))
    {
      if (HIWORD(*v10))
      {
        v22 = 0;
        v23 = 0;
        v24 = HIWORD(*v10);
        v25 = (_QWORD *)((*v10 & 0xFFFFFFFFFFFLL) + 8);
        do
        {
          if (*v25)
          {
            v26 = *(v25 - 1);
            if (v26)
              v27 = v26 ^ a1;
            else
              v27 = 0;
            v28 = &v8[16 * v23];
            *((_QWORD *)v28 + 1) = v27;
            *(_QWORD *)v28 = *v25;
            ++v23;
          }
          if (v22 >= v24)
            break;
          ++v22;
          v25 += 2;
        }
        while (v23 < (int)v7);
      }
    }
    else
    {
      v12 = 0;
      v13 = *v10 & 0xFFFFFFFFFFFELL;
      v14 = (unint64_t)*(unsigned __int16 *)(v13 - 8) >> 5;
      if (v14 >= (v7 - 1))
        v14 = (v7 - 1);
      v15 = 16 * v14 + 16;
      v16 = (uint64_t *)(*v10 & 0xFFFFFFFFFFFELL);
      do
      {
        v17 = &v8[v12];
        *(_QWORD *)v17 = (unint64_t)*v16 >> 38;
        v18 = *v16++;
        *((_QWORD *)v17 + 1) = v13 - (v18 << 26 >> 24);
        v12 += 16;
      }
      while (v15 != v12);
    }
  }
  else
  {
    v9 = 0;
  }
  if (a2)
    *a2 = v7;
  v19 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v20 = __ldxr(runtimeLock);
    if (v20 != v19)
      break;
    if (!__stlxr(0, runtimeLock))
      return v9;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v9;
}

void sub_180127B60(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

Protocol **__cdecl objc_copyProtocolList(unsigned int *outCount)
{
  unint64_t StatusReg;
  unsigned int v3;
  unint64_t v5;
  header_info *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t PreoptimizedProtocol;
  char *v15;
  char **v16;
  char *v17;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v19;
  __int32 v20;
  unsigned int v21;
  Protocol **v22;
  Protocol **v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  char *v30;
  int64x2_t v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  unsigned int *v36;
  unint64_t v37;
  void *v38;
  int32x2_t v39;
  unsigned int v40;
  int64x2_t v41;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v3, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v5 = protocols();
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v6 = (header_info *)FirstHeader;
  if (FirstHeader)
  {
    v36 = outCount;
    do
    {
      v37 = 0;
      v7 = header_info::protocollist(v6, &v37);
      v8 = v37;
      if (v37)
      {
        v9 = v7;
        do
        {
          v10 = *(_QWORD *)v9;
          v11 = *(_QWORD *)(*(_QWORD *)v9 + 8);
          v12 = (**(uint64_t (***)(unint64_t, uint64_t))v5)(v5, v11);
          v41.i64[0] = 0;
          if (_NXMapMemberWithHash(v5, v11, v12, &v41) == -1 || v41.i64[0] == 0)
          {
            PreoptimizedProtocol = getPreoptimizedProtocol();
            v15 = *(char **)(v10 + 8);
            v41.i64[0] = 0;
            if (!objc::DenseMapBase<objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>,char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::LookupBucketFor<char const*>((uint64_t)&v38, v15, (char ***)&v41))
            {
              if (4 * v39.i32[0] + 4 >= 3 * v40)
              {
                objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::grow((uint64_t)&v38, 2 * v40);
                v41.i64[0] = 0;
                objc::DenseMapBase<objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>,char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::LookupBucketFor<char const*>((uint64_t)&v38, v15, (char ***)&v41);
              }
              else if (v40 + ~v39.i32[0] - v39.i32[1] <= v40 >> 3)
              {
                objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::grow((uint64_t)&v38, v40);
                v41.i64[0] = 0;
                objc::DenseMapBase<objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>,char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::LookupBucketFor<char const*>((uint64_t)&v38, v15, (char ***)&v41);
              }
              v16 = (char **)v41.i64[0];
              v17 = *(char **)v41.i64[0];
              if (objc::DenseMapInfo<char const*>::isEqual(*(char **)v41.i64[0], (char *)0xFFFFFFFFFFFFFFFFLL))
              {
                ++v39.i32[0];
              }
              else if (objc::DenseMapInfo<char const*>::isEqual(v17, (char *)0xFFFFFFFFFFFFFFFELL))
              {
                v39 = vadd_s32(v39, (int32x2_t)0xFFFFFFFF00000001);
              }
              *v16 = v15;
              v16[1] = (char *)PreoptimizedProtocol;
            }
          }
          v9 += 8;
          --v8;
        }
        while (v8);
      }
      PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v6);
      v19 = (_QWORD *)((char *)v6 + 24);
      if (PreoptimizedHeaderRW)
        v19 = (_QWORD *)PreoptimizedHeaderRW;
      v6 = (header_info *)(*v19 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v6);
    v20 = v39.i32[0];
    outCount = v36;
  }
  else
  {
    v20 = 0;
  }
  v21 = v20 + *(_DWORD *)(v5 + 8);
  if (v21)
  {
    v22 = (Protocol **)malloc_type_malloc(8 * (v21 + 1), 0x80040B8603338uLL);
    v23 = v22;
    v24 = 0;
    v25 = *(_DWORD *)(v5 + 12) + 1;
LABEL_34:
    v26 = *(_QWORD *)(v5 + 16);
    v27 = v25;
    v28 = (uint64_t *)(v26 + 16 * v25 - 16);
    while (v27)
    {
      --v27;
      v29 = *v28;
      v28 -= 2;
      if (v29 != -1)
      {
        v22[v24++] = *(Protocol **)(v26 + 16 * v27 + 8);
        v25 = v27;
        goto LABEL_34;
      }
    }
    v30 = (char *)v38 + 16 * v40;
    if (v39.i32[0])
    {
      v41.i64[0] = (uint64_t)v38;
      v41.i64[1] = (uint64_t)v38 + 16 * v40;
      objc::DenseMapIterator<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>,false>::AdvancePastEmptyBuckets((char ***)&v41);
      v31 = v41;
    }
    else
    {
      v31 = vdupq_n_s64((unint64_t)v30);
    }
    v41 = v31;
    v32 = v31.i64[0];
    while ((char *)v32 != v30)
    {
      v23[v24] = *(Protocol **)(v32 + 8);
      v41.i64[0] = v32 + 16;
      objc::DenseMapIterator<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>,false>::AdvancePastEmptyBuckets((char ***)&v41);
      v32 = v41.i64[0];
      ++v24;
    }
    v23[v24] = 0;
    if (outCount)
      goto LABEL_47;
  }
  else
  {
    v23 = 0;
    if (outCount)
    {
      v21 = 0;
LABEL_47:
      *outCount = v21;
    }
  }
  free(v38);
  v33 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v34 = __ldxr(runtimeLock);
    if (v34 != v33)
      break;
    if (!__stlxr(0, runtimeLock))
      return v23;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return v23;
}

void sub_180127EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  unsigned int *v12;
  uint64_t v13;
  int v15;
  unsigned int v16;

  free(a12);
  v15 = *(_DWORD *)(v13 + 24);
  while (1)
  {
    v16 = __ldxr(v12);
    if (v16 != v15)
      break;
    if (!__stlxr(0, v12))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(a1);
}

char ***objc::DenseMapIterator<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>,false>::AdvancePastEmptyBuckets(char ***result)
{
  char **v1;
  char **v2;
  char ***v3;
  char *v4;

  v1 = *result;
  v2 = result[1];
  if (*result != v2)
  {
    v3 = result;
    do
    {
      v4 = *v1;
      result = (char ***)objc::DenseMapInfo<char const*>::isEqual(*v1, (char *)0xFFFFFFFFFFFFFFFFLL);
      if ((result & 1) == 0)
      {
        result = (char ***)objc::DenseMapInfo<char const*>::isEqual(v4, (char *)0xFFFFFFFFFFFFFFFELL);
        if (!(_DWORD)result)
          break;
      }
      v1 += 2;
      *v3 = v1;
    }
    while (v1 != v2);
  }
  return result;
}

BOOL objc::DenseMapBase<objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>,char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::LookupBucketFor<char const*>(uint64_t a1, char *__s1, char ***a3)
{
  uint64_t v4;
  unsigned int v7;
  _QWORD *v8;
  char *v9;
  unsigned int v10;
  int v11;
  int v12;
  int i;
  unsigned int v14;
  char **v15;
  char *v16;
  _BOOL8 isEqual;
  BOOL v18;
  char **v19;
  unsigned int v21;
  char **v22;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4)
  {
    v7 = 0;
    v8 = *(_QWORD **)a1;
    v9 = __s1;
    do
    {
      v10 = v7;
      v11 = *v9++;
      v7 = 257 * v7 + v11;
    }
    while (v11);
    v22 = 0;
    v12 = v4 - 1;
    for (i = 1; ; i = v21 + 1)
    {
      v21 = i;
      v14 = v10 & v12;
      v15 = (char **)&v8[2 * (v10 & v12)];
      v16 = *v15;
      isEqual = objc::DenseMapInfo<char const*>::isEqual(__s1, *v15);
      if (isEqual)
        break;
      if (objc::DenseMapInfo<char const*>::isEqual(v16, (char *)0xFFFFFFFFFFFFFFFFLL))
      {
        if (v22)
          v15 = v22;
        break;
      }
      if (v21 > v4)
        objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, v8, v4);
      v18 = objc::DenseMapInfo<char const*>::isEqual(v16, (char *)0xFFFFFFFFFFFFFFFELL);
      v19 = v22;
      if (v18 && v22 == 0)
        v19 = (char **)&v8[2 * v14];
      v22 = v19;
      v10 = v14 + v21;
    }
  }
  else
  {
    v15 = 0;
    isEqual = 0;
  }
  *a3 = v15;
  return isEqual;
}

void objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  char **v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char **v13;
  char *v14;
  char **v15;
  uint64_t v16;
  uint64_t v17;
  char **v18;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(char ***)a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4)
    v8 = v7 + 1;
  else
    v8 = 4;
  *(_DWORD *)(a1 + 16) = v8;
  v9 = malloc_type_malloc(16 * v8, 0x64B88C75uLL);
  *(_QWORD *)a1 = v9;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
    {
      v11 = 16 * v10;
      do
      {
        *v9 = -1;
        v9 += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if ((_DWORD)v3)
    {
      v12 = 16 * v3;
      v13 = v4;
      do
      {
        v14 = *v13;
        if (!objc::DenseMapInfo<char const*>::isEqual(*v13, (char *)0xFFFFFFFFFFFFFFFFLL)
          && !objc::DenseMapInfo<char const*>::isEqual(v14, (char *)0xFFFFFFFFFFFFFFFELL))
        {
          v18 = 0;
          objc::DenseMapBase<objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>,char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::LookupBucketFor<char const*>(a1, v14, &v18);
          v15 = v18;
          *v18 = *v13;
          v15[1] = v13[1];
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 2;
        v12 -= 16;
      }
      while (v12);
    }
    free(v4);
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    v16 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v16)
    {
      v17 = 16 * v16;
      do
      {
        *v9 = -1;
        v9 += 2;
        v17 -= 16;
      }
      while (v17);
    }
  }
}

const char **__cdecl objc_copyImageNames(unsigned int *outCount)
{
  unsigned int v1;
  _QWORD *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v16;
  int v17;
  unsigned int v18;
  _QWORD *v19;
  void *v20;
  unsigned int v21;
  char *v22;
  uint64_t v23;
  unint64_t StatusReg;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v1 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v1, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v3 = (_QWORD *)FirstHeader;
  if (FirstHeader)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    do
    {
      v7 = (char *)v3 + *v3;
      if (v5 >= v6)
      {
        v9 = (v5 - v4) >> 3;
        v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) >> 61)
          abort();
        if ((v6 - v4) >> 2 > v10)
          v10 = (v6 - v4) >> 2;
        if ((unint64_t)(v6 - v4) >= 0x7FFFFFFFFFFFFFF8)
          v11 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v11 = v10;
        if (v11)
        {
          if (v11 >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v12 = (char *)malloc_type_malloc(8 * v11, 0xB4ED9BFAuLL);
        }
        else
        {
          v12 = 0;
        }
        v13 = &v12[8 * v9];
        *(_QWORD *)v13 = v7;
        v8 = v13 + 8;
        while (v5 != v4)
        {
          v14 = *((_QWORD *)v5 - 1);
          v5 -= 8;
          *((_QWORD *)v13 - 1) = v14;
          v13 -= 8;
        }
        v6 = &v12[8 * v11];
        if (v4)
          free(v4);
        v4 = v13;
      }
      else
      {
        *(_QWORD *)v5 = v7;
        v8 = v5 + 8;
      }
      PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v3);
      v16 = v3 + 3;
      if (PreoptimizedHeaderRW)
        v16 = (_QWORD *)PreoptimizedHeaderRW;
      v5 = v8;
      v3 = (_QWORD *)(*v16 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v3);
  }
  else
  {
    v4 = 0;
    v8 = 0;
  }
  v17 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v18 = __ldxr(runtimeLock);
    if (v18 != v17)
      break;
    if (!__stlxr(0, runtimeLock))
      goto LABEL_36;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_36:
  v19 = malloc_type_malloc(v8 - v4 + 8, 0x10040436913F5uLL);
  v20 = v19;
  if (v4 == v8)
  {
    *v19 = 0;
LABEL_44:
    free(v20);
    v21 = 0;
    v20 = 0;
    goto LABEL_45;
  }
  v21 = 0;
  v22 = v4;
  do
  {
    v23 = dyld_image_path_containing_address();
    if (v23)
      *((_QWORD *)v20 + v21++) = v23;
    v22 += 8;
  }
  while (v22 != v8);
  *((_QWORD *)v20 + v21) = 0;
  if (!v21)
    goto LABEL_44;
LABEL_45:
  if (outCount)
    *outCount = v21;
  if (v4)
    free(v4);
  return (const char **)v20;
}

void sub_18012845C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;

  if (v10)
    free(v10);
  _Unwind_Resume(exception_object);
}

const char **__cdecl objc_copyClassNamesForImage(const char *image, unsigned int *outCount)
{
  unsigned int v3;
  _QWORD *v5;
  header_info **v6;
  header_info **v7;
  char *v8;
  header_info *v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v18;
  int v19;
  unsigned int v20;
  header_info **v21;
  const char *v22;
  int v23;
  header_info *v24;
  unsigned int v25;
  header_info *v27;
  uint64_t v28;
  _QWORD *v29;
  BOOL v30;
  int v31;
  unsigned int v32;
  const char **result;
  unsigned int *v34;
  const char **v35;
  unint64_t StatusReg;
  __int128 v37;

  if (!image)
  {
    if (!outCount)
      return 0;
LABEL_78:
    result = 0;
    *outCount = 0;
    return result;
  }
  v34 = outCount;
  v35 = 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  do
  {
    v3 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v3, runtimeLock))
        goto LABEL_8;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_8:
    v5 = (_QWORD *)FirstHeader;
    if (FirstHeader)
    {
      v6 = 0;
      v7 = 0;
      v8 = 0;
      do
      {
        if (_dyld_get_image_uuid())
        {
          v9 = (header_info *)((char *)v5 + *v5);
          if (v7 >= (header_info **)v8)
          {
            v10 = 0xAAAAAAAAAAAAAAABLL * (v7 - v6) + 1;
            if (v10 > 0xAAAAAAAAAAAAAAALL)
              abort();
            if (0x5555555555555556 * ((v8 - (char *)v6) >> 3) > v10)
              v10 = 0x5555555555555556 * ((v8 - (char *)v6) >> 3);
            if (0xAAAAAAAAAAAAAAABLL * ((v8 - (char *)v6) >> 3) >= 0x555555555555555)
              v11 = 0xAAAAAAAAAAAAAAALL;
            else
              v11 = v10;
            if (v11)
            {
              if (v11 > 0xAAAAAAAAAAAAAAALL)
                std::__throw_bad_array_new_length[abi:nn180100]();
              v12 = (char *)malloc_type_malloc(24 * v11, 0xB4ED9BFAuLL);
            }
            else
            {
              v12 = 0;
            }
            v13 = &v12[8 * (v7 - v6)];
            *(_QWORD *)v13 = v9;
            *(_OWORD *)(v13 + 8) = v37;
            if (v7 == v6)
            {
              v15 = &v12[8 * (v7 - v6)];
            }
            else
            {
              v14 = &v12[8 * (v7 - v6)];
              do
              {
                v15 = v14 - 24;
                v16 = *(_OWORD *)(v7 - 3);
                *((_QWORD *)v14 - 1) = *(v7 - 1);
                *(_OWORD *)(v14 - 24) = v16;
                v7 -= 3;
                v14 -= 24;
              }
              while (v7 != v6);
            }
            v8 = &v12[24 * v11];
            v7 = (header_info **)(v13 + 24);
            if (v6)
              free(v6);
            v6 = (header_info **)v15;
          }
          else
          {
            *v7 = v9;
            *(_OWORD *)(v7 + 1) = v37;
            v7 += 3;
          }
        }
        PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v5);
        v18 = v5 + 3;
        if (PreoptimizedHeaderRW)
          v18 = (_QWORD *)PreoptimizedHeaderRW;
        v5 = (_QWORD *)(*v18 & 0xFFFFFFFFFFFFFFFCLL);
      }
      while (v5);
    }
    else
    {
      v7 = 0;
      v6 = 0;
    }
    v19 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v20 = __ldxr(runtimeLock);
      if (v20 != v19)
        break;
      if (!__stlxr(0, runtimeLock))
        goto LABEL_41;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_41:
    v21 = v6;
    if (v6 == v7)
      goto LABEL_45;
    while (1)
    {
      v22 = (const char *)dyld_image_path_containing_address();
      if (v22)
      {
        if (!strcmp(v22, image))
          break;
      }
      v21 += 3;
      if (v21 == v7)
        goto LABEL_45;
    }
    if (v21 == v7)
    {
LABEL_45:
      v23 = 1;
    }
    else
    {
      v24 = *v21;
      v25 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr(runtimeLock))
      {
        if (!__stxr(v25, runtimeLock))
          goto LABEL_56;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_56:
      v27 = (header_info *)FirstHeader;
      if (!FirstHeader)
        goto LABEL_67;
      while (v24 != (header_info *)((char *)v27 + *(_QWORD *)v27))
      {
        v28 = getPreoptimizedHeaderRW((uint64_t)v27);
        v29 = (_QWORD *)((char *)v27 + 24);
        if (v28)
          v29 = (_QWORD *)v28;
        v27 = (header_info *)(*v29 & 0xFFFFFFFFFFFFFFFCLL);
        if (!v27)
          goto LABEL_67;
      }
      v37 = 0uLL;
      if (_dyld_get_image_uuid() && (!v21[1] ? (v30 = v21[2] == 0) : (v30 = 0), v30))
      {
        v35 = (const char **)copyClassNamesForImage_nolock(v27, v34);
        v23 = 1;
      }
      else
      {
LABEL_67:
        v23 = 0;
      }
      v31 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v32 = __ldxr(runtimeLock);
        if (v32 != v31)
          break;
        if (!__stlxr(0, runtimeLock))
          goto LABEL_46;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
LABEL_46:
    if (v6)
      free(v6);
  }
  while (!v23);
  outCount = v34;
  if (!v34)
    return v35;
  result = v35;
  if (!v35)
    goto LABEL_78;
  return result;
}

void sub_180128870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unsigned int *v12;
  void *v13;
  int v15;
  unsigned int v16;

  v15 = *(_DWORD *)(a12 + 24);
  while (1)
  {
    v16 = __ldxr(v12);
    if (v16 != v15)
      break;
    if (!__stlxr(0, v12))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  if (v13)
    free(v13);
  _Unwind_Resume(exception_object);
}

_QWORD *objc_copyClassesForImage(const char *a1, _DWORD *a2)
{
  unsigned int v3;
  _QWORD *v5;
  header_info **v6;
  header_info **v7;
  char *v8;
  header_info *v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v18;
  int v19;
  unsigned int v20;
  header_info **v21;
  const char *v22;
  int v23;
  header_info *v24;
  unsigned int v25;
  header_info *v27;
  uint64_t v28;
  _QWORD *v29;
  BOOL v30;
  int v31;
  unsigned int v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  _QWORD *result;
  _DWORD *v41;
  _QWORD *v42;
  unint64_t StatusReg;
  unint64_t v44[3];
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if (!a2)
      return 0;
LABEL_88:
    result = 0;
    *a2 = 0;
    return result;
  }
  v41 = a2;
  v42 = 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  do
  {
    v3 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v3, runtimeLock))
        goto LABEL_8;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_8:
    v5 = (_QWORD *)FirstHeader;
    if (FirstHeader)
    {
      v6 = 0;
      v7 = 0;
      v8 = 0;
      do
      {
        if (_dyld_get_image_uuid())
        {
          v9 = (header_info *)((char *)v5 + *v5);
          *(_OWORD *)v44 = v45;
          if (v7 >= (header_info **)v8)
          {
            v10 = 0xAAAAAAAAAAAAAAABLL * (v7 - v6) + 1;
            if (v10 > 0xAAAAAAAAAAAAAAALL)
              abort();
            if (0x5555555555555556 * ((v8 - (char *)v6) >> 3) > v10)
              v10 = 0x5555555555555556 * ((v8 - (char *)v6) >> 3);
            if (0xAAAAAAAAAAAAAAABLL * ((v8 - (char *)v6) >> 3) >= 0x555555555555555)
              v11 = 0xAAAAAAAAAAAAAAALL;
            else
              v11 = v10;
            if (v11)
            {
              if (v11 > 0xAAAAAAAAAAAAAAALL)
                std::__throw_bad_array_new_length[abi:nn180100]();
              v12 = (char *)malloc_type_malloc(24 * v11, 0xB4ED9BFAuLL);
            }
            else
            {
              v12 = 0;
            }
            v13 = &v12[8 * (v7 - v6)];
            *(_QWORD *)v13 = v9;
            *(_OWORD *)(v13 + 8) = *(_OWORD *)v44;
            if (v7 == v6)
            {
              v15 = &v12[8 * (v7 - v6)];
            }
            else
            {
              v14 = &v12[8 * (v7 - v6)];
              do
              {
                v15 = v14 - 24;
                v16 = *(_OWORD *)(v7 - 3);
                *((_QWORD *)v14 - 1) = *(v7 - 1);
                *(_OWORD *)(v14 - 24) = v16;
                v7 -= 3;
                v14 -= 24;
              }
              while (v7 != v6);
            }
            v8 = &v12[24 * v11];
            v7 = (header_info **)(v13 + 24);
            if (v6)
              free(v6);
            v6 = (header_info **)v15;
          }
          else
          {
            *v7 = v9;
            *(_OWORD *)(v7 + 1) = *(_OWORD *)v44;
            v7 += 3;
          }
        }
        PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v5);
        v18 = v5 + 3;
        if (PreoptimizedHeaderRW)
          v18 = (_QWORD *)PreoptimizedHeaderRW;
        v5 = (_QWORD *)(*v18 & 0xFFFFFFFFFFFFFFFCLL);
      }
      while (v5);
    }
    else
    {
      v7 = 0;
      v6 = 0;
    }
    v19 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v20 = __ldxr(runtimeLock);
      if (v20 != v19)
        break;
      if (!__stlxr(0, runtimeLock))
        goto LABEL_41;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_41:
    v21 = v6;
    if (v6 == v7)
      goto LABEL_45;
    while (1)
    {
      v22 = (const char *)dyld_image_path_containing_address();
      if (v22)
      {
        if (!strcmp(v22, a1))
          break;
      }
      v21 += 3;
      if (v21 == v7)
        goto LABEL_45;
    }
    if (v21 == v7)
    {
LABEL_45:
      v23 = 1;
    }
    else
    {
      v24 = *v21;
      v25 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr(runtimeLock))
      {
        if (!__stxr(v25, runtimeLock))
          goto LABEL_56;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_56:
      v27 = (header_info *)FirstHeader;
      if (!FirstHeader)
        goto LABEL_67;
      while (v24 != (header_info *)((char *)v27 + *(_QWORD *)v27))
      {
        v28 = getPreoptimizedHeaderRW((uint64_t)v27);
        v29 = (_QWORD *)((char *)v27 + 24);
        if (v28)
          v29 = (_QWORD *)v28;
        v27 = (header_info *)(*v29 & 0xFFFFFFFFFFFFFFFCLL);
        if (!v27)
          goto LABEL_67;
      }
      v45 = 0uLL;
      if (_dyld_get_image_uuid()
        && ((header_info *)v45 == v21[1] ? (v30 = *((_QWORD *)&v45 + 1) == (_QWORD)v21[2]) : (v30 = 0), v30))
      {
        v44[0] = 0;
        v33 = (unint64_t *)header_info::classlist(v27, v44);
        v34 = v44[0];
        v42 = malloc_type_malloc(8 * v44[0] + 8, 0x80040B8603338uLL);
        if (v34)
        {
          v35 = 0;
          v36 = v42;
          v37 = v34;
          do
          {
            v38 = remapClass(*v33);
            if (v38)
              v36[-v35] = v38;
            else
              ++v35;
            ++v36;
            ++v33;
            --v37;
          }
          while (v37);
          v39 = v34 - v35;
        }
        else
        {
          v39 = 0;
        }
        v42[v39] = 0;
        if (v41)
          *v41 = v39;
        v23 = 1;
      }
      else
      {
LABEL_67:
        v23 = 0;
      }
      v31 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v32 = __ldxr(runtimeLock);
        if (v32 != v31)
          break;
        if (!__stlxr(0, runtimeLock))
          goto LABEL_46;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
LABEL_46:
    if (v6)
      free(v6);
  }
  while (!v23);
  a2 = v41;
  if (!v41)
    return v42;
  result = v42;
  if (!v42)
    goto LABEL_88;
  return result;
}

void sub_180128D28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unsigned int *v12;
  void *v13;
  int v15;
  unsigned int v16;

  v15 = *(_DWORD *)(a12 + 24);
  while (1)
  {
    v16 = __ldxr(v12);
    if (v16 != v15)
      break;
    if (!__stlxr(0, v12))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  if (v13)
    free(v13);
  _Unwind_Resume(exception_object);
}

const char *objc_debug_class_getNameRaw(objc_class *a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;

  if (!a1)
    return "nil";
  v4 = *((_QWORD *)a1 + 4);
  v5 = (_QWORD *)(v4 & 0xF00007FFFFFFFF8);
  if (v4 < 0)
  {
    v6 = *(_QWORD *)((v4 & 0xF00007FFFFFFFF8) + 8);
    v5 = (_QWORD *)(v6 & 0xFFFFFFFFFFFFFFFELL);
    if ((v6 & 1) != 0)
      v5 = (_QWORD *)*v5;
  }
  v7 = atomic_load(v5 + 3);
  if (!v7)
    return (const char *)objc_class::installMangledNameForLazilyNamedClass(a1, a2, a3, a4);
  return (const char *)v7;
}

int class_getVersion(Class cls)
{
  uint64_t v1;
  unint64_t v2;

  if (cls)
  {
    v1 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
    if ((v1 & 1) != 0 && (v2 = v1 & 0xFFFFFFFFFFFFFFFELL) != 0)
      LODWORD(cls) = *(_DWORD *)(v2 + 40);
    else
      LODWORD(cls) = (*((unsigned __int16 *)cls + 15) << 29 >> 31) & 7;
  }
  return (int)cls;
}

objc_class *gdb_class_getClass(objc_class *a1, uint64_t a2, const char *a3, char *a4)
{
  char *v4;

  v4 = (char *)objc_class::mangledName(a1, a2, a3, a4);
  if (v4 && *v4)
    return look_up_class(v4);
  else
    return 0;
}

objc_class *gdb_object_getClass(objc_class *result, uint64_t a2, const char *a3, char *a4)
{
  __objc2_class *v4;

  if (result)
  {
    if (((unint64_t)result & 0x8000000000000000) != 0)
    {
      v4 = (__objc2_class *)objc_debug_taggedpointer_classes[result & 7];
      if (v4 == __NSUnrecognizedTaggedPointer)
        v4 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[((unint64_t)result >> 55)];
    }
    else
    {
      v4 = (__objc2_class *)(*(_QWORD *)result & 0xFFFFFFFF8);
    }
    return gdb_class_getClass((objc_class *)v4, a2, a3, a4);
  }
  return result;
}

const uint8_t *__cdecl class_getIvarLayout(const uint8_t *cls)
{
  uint64_t v1;
  unint64_t v2;

  if (cls)
  {
    v1 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
    v2 = v1 & 0xFFFFFFFFFFFFFFFELL;
    if ((v1 & 1) != 0)
      v2 = *(_QWORD *)v2;
    if ((*(_BYTE *)v2 & 1) != 0)
      return 0;
    else
      return *(const uint8_t **)(v2 + 16);
  }
  return cls;
}

const uint8_t *__cdecl class_getWeakIvarLayout(const uint8_t *cls)
{
  uint64_t v1;
  unint64_t v2;

  if (cls)
  {
    v1 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
    v2 = v1 & 0xFFFFFFFFFFFFFFFELL;
    if ((v1 & 1) != 0)
      v2 = *(_QWORD *)v2;
    return *(const uint8_t **)(v2 + 56);
  }
  return cls;
}

void class_setIvarLayout(Class cls, const uint8_t *layout)
{
  unint64_t StatusReg;
  unsigned int v5;
  uint64_t v7;
  BOOL v8;
  char *v9;
  unint64_t ro_writeable_nolock;
  unint64_t v11;
  void *v12;
  size_t v13;
  void *v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  const char *v20;
  char *v21;

  if (cls)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v5 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v5, runtimeLock))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_7:
    if ((unint64_t)(*(_QWORD *)cls - 1) < 0xF
      || (*(_DWORD *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
      || (v7 = *(unsigned __int16 *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
          qword_1ECCE5988 <= v7)
      || (*(_QWORD *)(qword_1ECCE5980 + 16 * v7) <= (unint64_t)cls
        ? (v8 = *(_QWORD *)(qword_1ECCE5980 + 16 * v7 + 8) > (unint64_t)cls)
        : (v8 = 0),
          !v8))
    {
      if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)cls)
        && (dataSegmentsContain(cls, v17, v18) & 1) == 0)
      {
        _objc_fatal("Attempt to use unknown class %p.", v19, v20, v21, cls);
      }
    }
    if ((*(_BYTE *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 3) & 4) != 0)
    {
      ro_writeable_nolock = make_ro_writeable_nolock(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8);
      v11 = ro_writeable_nolock;
      if ((*(_BYTE *)ro_writeable_nolock & 1) == 0)
      {
        v12 = *(void **)(ro_writeable_nolock + 16);
        if (v12)
        {
          if (malloc_size(*(const void **)(ro_writeable_nolock + 16)))
            free(v12);
        }
      }
      if (layout)
      {
        v13 = strlen((const char *)layout) + 1;
        if ((_dyld_is_memory_immutable() & 1) == 0)
        {
          v14 = malloc_type_malloc(v13, 0x3F84A03uLL);
          memcpy(v14, layout, v13);
          layout = (const uint8_t *)v14;
        }
      }
      *(_QWORD *)(v11 + 16) = layout;
    }
    else
    {
      v9 = objc_class::nameForLogging(cls);
      _objc_inform("*** Can't set ivar layout for already-registered class '%s'", v9);
    }
    v15 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v16 = __ldxr(runtimeLock);
      if (v16 != v15)
        break;
      if (!__stlxr(0, runtimeLock))
        return;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_180129118(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void class_setWeakIvarLayout(Class cls, const uint8_t *layout)
{
  unint64_t StatusReg;
  unsigned int v5;
  uint64_t v7;
  BOOL v8;
  char *v9;
  unint64_t ro_writeable_nolock;
  unint64_t v11;
  void *v12;
  size_t v13;
  void *v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  const char *v20;
  char *v21;

  if (cls)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v5 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v5, runtimeLock))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_7:
    if ((unint64_t)(*(_QWORD *)cls - 1) < 0xF
      || (*(_DWORD *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
      || (v7 = *(unsigned __int16 *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
          qword_1ECCE5988 <= v7)
      || (*(_QWORD *)(qword_1ECCE5980 + 16 * v7) <= (unint64_t)cls
        ? (v8 = *(_QWORD *)(qword_1ECCE5980 + 16 * v7 + 8) > (unint64_t)cls)
        : (v8 = 0),
          !v8))
    {
      if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)cls)
        && (dataSegmentsContain(cls, v17, v18) & 1) == 0)
      {
        _objc_fatal("Attempt to use unknown class %p.", v19, v20, v21, cls);
      }
    }
    if ((*(_BYTE *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 3) & 4) != 0)
    {
      ro_writeable_nolock = make_ro_writeable_nolock(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8);
      v11 = ro_writeable_nolock;
      v12 = *(void **)(ro_writeable_nolock + 56);
      if (v12 && malloc_size(*(const void **)(ro_writeable_nolock + 56)))
        free(v12);
      if (layout)
      {
        v13 = strlen((const char *)layout) + 1;
        if ((_dyld_is_memory_immutable() & 1) == 0)
        {
          v14 = malloc_type_malloc(v13, 0x3F84A03uLL);
          memcpy(v14, layout, v13);
          layout = (const uint8_t *)v14;
        }
      }
      *(_QWORD *)(v11 + 56) = layout;
    }
    else
    {
      v9 = objc_class::nameForLogging(cls);
      _objc_inform("*** Can't set weak ivar layout for already-registered class '%s'", v9);
    }
    v15 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v16 = __ldxr(runtimeLock);
      if (v16 != v15)
        break;
      if (!__stlxr(0, runtimeLock))
        return;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_180129338(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)
{
  return _class_addProperty(cls, name, attributes, attributeCount, 0);
}

uint64_t _class_addProperty(Class cls, const char *name, const objc_property_attribute_t *a3, unsigned int a4, int a5)
{
  uint64_t result;
  const char *v7;
  objc_property_t Property;
  objc_property_t v12;
  unint64_t StatusReg;
  unsigned int v14;
  char v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  size_t v20;
  void *v21;
  const char *v22;
  int v23;
  unsigned int v24;
  void *v25;
  int v26;
  unsigned int v27;
  _QWORD *v28;

  result = 0;
  if (cls)
  {
    v7 = name;
    if (name)
    {
      Property = class_getProperty(cls, name);
      v12 = Property;
      if (!Property || a5)
      {
        StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        v14 = *(_DWORD *)(StatusReg + 24);
        while (!__ldaxr(runtimeLock))
        {
          if (!__stxr(v14, runtimeLock))
          {
            v16 = 1;
            if (!Property)
              goto LABEL_10;
            goto LABEL_24;
          }
        }
        v16 = 0;
        __clrex();
        if (!Property)
        {
LABEL_10:
          if ((v16 & 1) == 0)
            os_unfair_lock_lock_with_options();
          v17 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
          v18 = v17 & 0xFFFFFFFFFFFFFFFELL;
          if ((v17 & 1) == 0)
            v18 = class_rw_t::extAlloc(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8, v17 & 0xFFFFFFFFFFFFFFFELL, 0);
          v19 = malloc_type_malloc(0x18uLL, 0x899C19F0uLL);
          v28 = v19;
          *v19 = 0x100000010;
          v20 = strlen(v7) + 1;
          if ((_dyld_is_memory_immutable() & 1) == 0)
          {
            v21 = malloc_type_malloc(v20, 0x3F84A03uLL);
            memcpy(v21, v7, v20);
            v7 = (const char *)v21;
          }
          v19[1] = v7;
          v19[2] = copyPropertyAttributeString((uint64_t)a3, a4);
          if (PrintPreopt)
            v22 = "properties";
          else
            v22 = 0;
          list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(v18 + 16), (uint64_t)&v28, (const char *)1, 0, v22);
          v23 = *(_DWORD *)(StatusReg + 24);
          while (1)
          {
            v24 = __ldxr(runtimeLock);
            if (v24 != v23)
              break;
            if (!__stlxr(0, runtimeLock))
              return 1;
          }
          goto LABEL_33;
        }
LABEL_24:
        if ((v16 & 1) == 0)
          os_unfair_lock_lock_with_options();
        v25 = (void *)*((_QWORD *)v12 + 1);
        if (v25 && malloc_size(*((const void **)v12 + 1)))
          free(v25);
        *((_QWORD *)v12 + 1) = copyPropertyAttributeString((uint64_t)a3, a4);
        v26 = *(_DWORD *)(StatusReg + 24);
        while (1)
        {
          v27 = __ldxr(runtimeLock);
          if (v27 != v26)
            break;
          if (!__stlxr(0, runtimeLock))
            return 1;
        }
LABEL_33:
        __clrex();
        os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void sub_1801295A0(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)
{
  _class_addProperty(cls, name, attributes, attributeCount, 1);
}

Class objc_duplicateClass(Class original, const char *name, size_t extraBytes)
{
  unint64_t StatusReg;
  unsigned int v6;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  size_t v19;
  unint64_t *v20;
  size_t v21;
  uint64_t v22;
  const char *v23;
  char *v24;
  void *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  size_t v32;
  unint64_t v33;
  uint64_t v34;
  const char *v35;
  char *v36;
  unint64_t v37;
  _DWORD *v39;
  uint64_t v40;
  char *v41;
  char *v42;
  unsigned int *v43;
  unsigned int v44;
  int v45;
  unsigned int v46;
  uint64_t v48;
  unsigned int *v49;
  uint64_t v50;
  const char *v51;
  char *v52;
  unint64_t v53;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v6, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v53 = StatusReg;
  if ((unint64_t)(*(_QWORD *)original - 1) < 0xF
    || (*(_DWORD *)(*((_QWORD *)original + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (v8 = *(unsigned __int16 *)((*((_QWORD *)original + 4) & 0xF00007FFFFFFFF8) + 4),
        qword_1ECCE5988 <= v8)
    || (*(_QWORD *)(qword_1ECCE5980 + 16 * v8) <= (unint64_t)original
      ? (v9 = *(_QWORD *)(qword_1ECCE5980 + 16 * v8 + 8) > (unint64_t)original)
      : (v9 = 0),
        !v9))
  {
    if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)original)
      && (dataSegmentsContain(original, v48, v49) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v50, v51, v52, original);
    }
  }
  v10 = *((_QWORD *)original + 4) & 0xF00007FFFFFFFF8;
  v11 = *(_QWORD *)(v10 + 8);
  v12 = (_QWORD *)(v11 & 0xFFFFFFFFFFFFFFFELL);
  if ((v11 & 1) != 0)
    v12 = (_QWORD *)*v12;
  v13 = alloc_class_for_subclass(original);
  v14 = v13;
  v15 = *(_QWORD *)original & 0xFFFFFFFF8;
  if (!DisableNonpointerIsa && (*(_WORD *)((*(_QWORD *)original & 0xFFFFFFFF8) + 0x1E) & 0x2000) == 0)
    v15 |= 0x21A000000001uLL;
  *(_QWORD *)v13 = v15;
  *((_QWORD *)v13 + 1) = *((_QWORD *)original + 1);
  *((_QWORD *)v13 + 2) = &_objc_empty_cache;
  *((_QWORD *)v13 + 3) = 0;
  v16 = (uint64_t)malloc_type_calloc(0x20uLL, 1uLL, 0x1ECB51D3uLL);
  *(_DWORD *)v16 = *(_DWORD *)v10 | 0x8080000;
  *(_QWORD *)(v16 + 16) = 0;
  *(_QWORD *)(v16 + 24) = 0;
  v17 = *((_QWORD *)original + 4);
  *((_QWORD *)v14 + 4) = v17;
  __dmb(0xBu);
  *((_QWORD *)v14 + 4) = v17 & 7 | v16 | 0x8000000000000000;
  v18 = *(_DWORD *)v12;
  if ((*(_DWORD *)v12 & 0x40) != 0)
    v19 = 80;
  else
    v19 = 72;
  v20 = (unint64_t *)malloc_type_malloc(v19, 0x3F84A03uLL);
  memcpy(v20, v12, v19);
  if ((v18 & 0x40) != 0)
    v20[9] = v12[9];
  v21 = strlen(name) + 1;
  v25 = (void *)name;
  if ((_dyld_is_memory_immutable() & 1) == 0)
  {
    v25 = malloc_type_malloc(v21, 0x3F84A03uLL);
    memcpy(v25, name, v21);
  }
  v26 = v11 & (v11 << 63 >> 63) & 0xFFFFFFFFFFFFFFFELL;
  v20[3] = (unint64_t)v25;
  v27 = *(_QWORD *)(v16 + 8);
  if ((v27 & 1) != 0)
  {
    *(_QWORD *)(v27 & 0xFFFFFFFFFFFFFFFELL) = v20;
    if (v26)
      goto LABEL_28;
LABEL_38:
    if (v20[4] >= 2)
      class_rw_t::extAlloc(v16, (uint64_t)v20, 1);
    goto LABEL_45;
  }
  *(_QWORD *)(v16 + 8) = v20;
  if (!v26)
    goto LABEL_38;
LABEL_28:
  v28 = *(_QWORD *)(v16 + 8);
  v29 = v28 & 0xFFFFFFFFFFFFFFFELL;
  if ((v28 & 1) == 0)
    v29 = class_rw_t::extAlloc(v16, v28 & 0xFFFFFFFFFFFFFFFELL, 0);
  *(_DWORD *)(v29 + 40) = *(_DWORD *)((v11 & (v11 << 63 >> 63) & 0xFFFFFFFFFFFFFFFELL) + 0x28);
  v30 = *(_QWORD *)((v11 & (v11 << 63 >> 63) & 0xFFFFFFFFFFFFFFFELL) + 8);
  v31 = (_DWORD *)(v30 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v30 & 3) == 1 && v31)
  {
    v32 = 8 * *v31 + 8;
    v33 = (unint64_t)malloc_type_malloc(v32, 0x3F84A03uLL);
    memcpy((void *)v33, v31, v32);
    *(_QWORD *)(v29 + 8) = v33 | 1;
    if (*v31)
    {
      v37 = 1;
      do
        *(_QWORD *)(v33 + 8 * v37) = method_list_t::duplicate(*(method_list_t **)&v31[2 * v37], v34, v35, v36);
      while (v37++ < *v31);
    }
  }
  else
  {
    v39 = 0;
    if ((v30 & 3) == 0 && v31)
      v39 = method_list_t::duplicate((method_list_t *)(v30 & 0xFFFFFFFFFFFFFFFCLL), v22, v23, v24);
    *(_QWORD *)(v29 + 8) = v39;
  }
  *(_QWORD *)(v29 + 16) = *(_QWORD *)(v26 + 16);
  *(_QWORD *)(v29 + 24) = *(_QWORD *)(v26 + 24);
LABEL_45:
  v40 = *((_QWORD *)v14 + 1);
  if (v40)
  {
    addSubclass(v40, (objc_class *)v14);
  }
  else
  {
    ++objc_debug_realized_class_generation_count;
    *(_QWORD *)((*((_QWORD *)v14 + 4) & 0xF00007FFFFFFFF8) + 0x18) = _firstRealizedClass;
    _firstRealizedClass = (uint64_t)v14;
  }
  v41 = (char *)atomic_load(v20 + 3);
  addNamedClass((objc_class *)v14, v41, 0);
  addClassTableEntry((uint64_t)v14, 0);
  if (PrintConnecting)
  {
    v42 = objc_class::nameForLogging(original);
    _objc_inform("CLASS: realizing class '%s' (duplicate of %s) %p %p", name, v42, v14, v20);
  }
  v43 = (unsigned int *)(*((_QWORD *)v14 + 4) & 0xF00007FFFFFFFF8);
  do
    v44 = __ldxr(v43);
  while (__stxr(v44 & 0xFFF7FFFF, v43));
  v45 = *(_DWORD *)(v53 + 24);
  while (1)
  {
    v46 = __ldxr(runtimeLock);
    if (v46 != v45)
      break;
    if (!__stlxr(0, runtimeLock))
      return (Class)v14;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return (Class)v14;
}

void sub_180129A64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  unsigned int *v14;
  int v16;
  unsigned int v17;

  v16 = *(_DWORD *)(a14 + 24);
  while (1)
  {
    v17 = __ldxr(v14);
    if (v17 != v16)
      break;
    if (!__stlxr(0, v14))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

objc_class *objc_initializeClassPair(objc_class *a1, char *a2, objc_class *a3, uint64_t a4)
{
  unint64_t StatusReg;
  unsigned int v9;
  int v11;
  unsigned int v12;

  if (look_up_class(a2))
    return 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v9 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v9, runtimeLock))
      goto LABEL_8;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_8:
  if (getClassExceptSomeSwift(a2)
    || a1
    && ((unint64_t)(*(_QWORD *)a1 - 1) < 0xF
     || (*(_DWORD *)(*((_QWORD *)a1 + 4) & 0xF00007FFFFFFFF8) & 0x84000000) != 0x80000000))
  {
    a3 = 0;
  }
  else
  {
    objc_initializeClassPair_internal(a1, a2, a3, a4);
  }
  v11 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v12 = __ldxr(runtimeLock);
    if (v12 != v11)
      break;
    if (!__stlxr(0, runtimeLock))
      return a3;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  return a3;
}

void sub_180129BCC(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void objc_disposeClassPair(Class cls)
{
  unint64_t StatusReg;
  unsigned int v3;
  uint64_t v5;
  BOOL v6;
  objc_class *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  const char *v11;
  char *v12;
  uint64_t v13;
  _QWORD *v14;
  const char *v15;
  char *v16;
  uint64_t v17;
  _QWORD *v18;
  const char *v19;
  unint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int *v25;
  uint64_t v26;
  const char *v27;
  char *v28;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v3, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  if ((unint64_t)(*(_QWORD *)cls - 1) < 0xF
    || (*(_DWORD *)(*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (v5 = *(unsigned __int16 *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
        qword_1ECCE5988 <= v5)
    || (*(_QWORD *)(qword_1ECCE5980 + 16 * v5) <= (unint64_t)cls
      ? (v6 = *(_QWORD *)(qword_1ECCE5980 + 16 * v5 + 8) > (unint64_t)cls)
      : (v6 = 0),
        !v6))
  {
    if (objc::allocatedClasses + 8 * qword_1ECCE5760 == objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::find((unint64_t)cls)
      && (dataSegmentsContain(cls, v24, v25) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v26, v27, v28, cls);
    }
  }
  if ((*(_BYTE *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 3) & 6) != 0
    && (v7 = (objc_class *)(*(_QWORD *)cls & 0xFFFFFFFF8),
        v8 = *((_QWORD *)v7 + 4) & 0xF00007FFFFFFFF8,
        (*(_BYTE *)(v8 + 3) & 6) != 0))
  {
    if ((*((_WORD *)cls + 15) & 4) == 0)
    {
      if (*(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 0x10))
      {
        v9 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
        v10 = (_QWORD *)(v9 & 0xFFFFFFFFFFFFFFFELL);
        if ((v9 & 1) != 0)
          v10 = (_QWORD *)*v10;
        v11 = (const char *)atomic_load(v10 + 3);
        v12 = objc_class::nameForLogging(*(objc_class **)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 0x10));
        _objc_inform("objc_disposeClassPair: class '%s' still has subclasses, including '%s'!", v11, v12);
        v7 = (objc_class *)(*(_QWORD *)cls & 0xFFFFFFFF8);
        v8 = *((_QWORD *)v7 + 4) & 0xF00007FFFFFFFF8;
      }
      if (*(_QWORD *)(v8 + 16))
      {
        v13 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
        v14 = (_QWORD *)(v13 & 0xFFFFFFFFFFFFFFFELL);
        if ((v13 & 1) != 0)
          v14 = (_QWORD *)*v14;
        v15 = (const char *)atomic_load(v14 + 3);
        v16 = objc_class::nameForLogging(*(objc_class **)((*(_QWORD *)((*(_QWORD *)cls & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8)
                                                        + 0x10));
        _objc_inform("objc_disposeClassPair: class '%s' still has subclasses, including '%s'!", v15, v16);
        v7 = (objc_class *)(*(_QWORD *)cls & 0xFFFFFFFF8);
      }
      detach_class(v7, 1);
      detach_class(cls, 0);
      free_class((objc_class *)(*(_QWORD *)cls & 0xFFFFFFFF8));
      free_class(cls);
      goto LABEL_28;
    }
    v23 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
    v18 = (_QWORD *)(v23 & 0xFFFFFFFFFFFFFFFELL);
    v19 = "objc_disposeClassPair: class '%s' is a metaclass, not a class!";
    if ((v23 & 1) != 0)
      goto LABEL_34;
  }
  else
  {
    v17 = *(_QWORD *)((*((_QWORD *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
    v18 = (_QWORD *)(v17 & 0xFFFFFFFFFFFFFFFELL);
    v19 = "objc_disposeClassPair: class '%s' was not allocated with objc_allocateClassPair!";
    if ((v17 & 1) != 0)
LABEL_34:
      v18 = (_QWORD *)*v18;
  }
  v20 = atomic_load(v18 + 3);
  _objc_inform(v19, v20);
LABEL_28:
  v21 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v22 = __ldxr(runtimeLock);
    if (v22 != v21)
      break;
    if (!__stlxr(0, runtimeLock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
}

void sub_180129EA0(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t class_createInstances(unint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  unint64_t v6;
  size_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  const char *v11;
  char *v12;
  uint64_t v13;
  int v14;
  __int16 v15;
  void (*v16)(void);
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;

  if (result)
  {
    v4 = a4;
    v6 = result;
    if ((*(_WORD *)(result + 30) & 0xFF8) != 0)
    {
      v7 = (a2 + (*(_WORD *)(result + 30) & 0xFF8) + 7) & 0xFFFFFFFFFFFFFFF0;
      if (a4)
        goto LABEL_4;
    }
    else
    {
      v17 = *(_QWORD *)((*(_QWORD *)(result + 32) & 0xF00007FFFFFFFF8) + 8);
      v18 = v17 & 0xFFFFFFFFFFFFFFFELL;
      if ((v17 & 1) != 0)
        v18 = *(_QWORD *)v18;
      v19 = ((*(_DWORD *)(v18 + 8) + 7) & 0xFFFFFFF8) + a2;
      if (v19 <= 0x10)
        v7 = 16;
      else
        v7 = v19;
      if (a4)
      {
LABEL_4:
        v8 = 0;
        while (1)
        {
          v9 = malloc_type_calloc(1uLL, v7, 0x40000000000uLL);
          *(_QWORD *)(a3 + 8 * v8) = v9;
          if (!v9)
            break;
          if (v4 == ++v8)
          {
            if (!v4)
              goto LABEL_24;
            goto LABEL_10;
          }
        }
        v4 = v8;
        if (!(_DWORD)v8)
          goto LABEL_24;
LABEL_10:
        if ((v6 & 0xFFFFFFF000000007) != 0)
          _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v10, v11, v12, v6);
        v13 = 0;
        v14 = 0;
        v15 = *(_WORD *)(v6 + 30);
        do
        {
          v16 = *(void (**)(void))(a3 + 8 * v13);
          *(_QWORD *)v16 = v6 & 0xFFFFFFFF8;
          if ((v15 & 2) != 0 && (v16 = object_cxxConstructFromClass(v16, (objc_class *)v6, 1)) == 0)
            ++v14;
          else
            *(_QWORD *)(a3 + 8 * (v13 - v14)) = v16;
          ++v13;
        }
        while (v4 != v13);
        return (v4 - v14);
      }
    }
LABEL_24:
    v14 = 0;
    return (v4 - v14);
  }
  return result;
}

id object_copy(id a1, size_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  __int16 v4;
  size_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _BYTE *v19;
  unsigned int v20;
  void **v21;
  int v22;
  void *v23;
  void *v24;
  id v25;
  unsigned int v26;
  uint64_t v27;
  _QWORD *v28;
  _BYTE *v29;
  unsigned int v30;
  id *v31;
  id *v32;
  int v33;
  id WeakRetained;
  unsigned int v35;
  uint64_t v37;
  unint64_t v38;
  size_t v39;

  v2 = a1;
  if ((uint64_t)a1 >= 1)
  {
    v3 = *(_QWORD *)a1 & 0xFFFFFFFF8;
    v4 = *(_WORD *)(v3 + 0x1E);
    if ((v4 & 0xFF8) != 0)
    {
      v5 = (a2 + (v4 & 0xFF8) + 7) & 0xFFFFFFFFFFFFFFF0;
    }
    else
    {
      v37 = *(_QWORD *)((*(_QWORD *)((*(_QWORD *)a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8) + 8);
      v38 = v37 & 0xFFFFFFFFFFFFFFFELL;
      if ((v37 & 1) != 0)
        v38 = *(_QWORD *)v38;
      v39 = ((*(_DWORD *)(v38 + 8) + 7) & 0xFFFFFFF8) + a2;
      if (v39 <= 0x10)
        v5 = 16;
      else
        v5 = v39;
    }
    v6 = (char *)malloc_type_calloc(1uLL, v5, 0x40000000000uLL);
    if (v6)
    {
      v7 = v6;
      v8 = 0x21A000000001;
      if ((v4 & 1) != 0)
        v8 = 0x21A000000005;
      if ((v4 & 0x2000) != 0)
        v8 = 0;
      *(_QWORD *)v6 = v3 | v8;
      memmove(v6 + 8, v2 + 1, v5 - 8);
      for (i = *v2 & 0xFFFFFFFF8; i; i = *(_QWORD *)(i + 8))
      {
        v10 = *(_QWORD *)(i + 32) & 0xF00007FFFFFFFF8;
        v11 = *(_QWORD *)(v10 + 8);
        v12 = (_QWORD *)(v11 & 0xFFFFFFFFFFFFFFFELL);
        if ((v11 & 1) != 0)
          v12 = (_QWORD *)*v12;
        if ((*(_WORD *)v12 & 0x280) != 0)
        {
          v13 = *(_QWORD *)((*(_QWORD *)(i + 32) & 0xF00007FFFFFFFF8) + 8);
          v14 = v13 & 0xFFFFFFFFFFFFFFFELL;
          if ((v13 & 1) != 0)
            v14 = *(_QWORD *)v14;
          v15 = *(_DWORD *)(v14 + 4);
          v16 = *(_QWORD *)((*(_QWORD *)(i + 32) & 0xF00007FFFFFFFF8) + 8);
          v17 = (_QWORD *)(v16 & 0xFFFFFFFFFFFFFFFELL);
          if ((v16 & 1) != 0)
            v17 = (_QWORD *)*v17;
          v18 = (v15 + 7) & 0xFFFFFFF8;
          if ((*(_BYTE *)v17 & 1) == 0)
          {
            v19 = (_BYTE *)v17[2];
            if (v19)
            {
              v20 = *v19;
              if (*v19)
              {
                v21 = (void **)&v7[v18];
                do
                {
                  v21 += v20 >> 4;
                  v22 = v20 & 0xF;
                  if ((v20 & 0xF) != 0)
                  {
                    do
                    {
                      v24 = *v21++;
                      v23 = v24;
                      if (v24)
                        v25 = v23;
                      --v22;
                    }
                    while (v22);
                  }
                  v26 = *++v19;
                  v20 = v26;
                }
                while (v26);
                v10 = *(_QWORD *)(i + 32) & 0xF00007FFFFFFFF8;
              }
            }
          }
          v27 = *(_QWORD *)(v10 + 8);
          v28 = (_QWORD *)(v27 & 0xFFFFFFFFFFFFFFFELL);
          if ((v27 & 1) != 0)
            v28 = (_QWORD *)*v28;
          v29 = (_BYTE *)v28[7];
          if (v29)
          {
            v30 = *v29;
            if (*v29)
            {
              v31 = (id *)((char *)v2 + v18);
              v32 = (id *)&v7[v18];
              do
              {
                v32 += v30 >> 4;
                v31 += v30 >> 4;
                v33 = v30 & 0xF;
                if ((v30 & 0xF) != 0)
                {
                  do
                  {
                    --v33;
                    WeakRetained = objc_loadWeakRetained(v31);
                    objc_initWeak(v32, WeakRetained);

                    ++v32;
                    ++v31;
                  }
                  while (v33);
                }
                v35 = *++v29;
                v30 = v35;
              }
              while (v35);
            }
          }
        }
      }
      return v7;
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t _objc_getFreedObjectClass()
{
  return 0;
}

uint64_t ___ZL13setSuperclassP10objc_classS0__block_invoke_182()
{
  return 1;
}

__int128 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(__int128 *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v3 = *a2;
  v4 = *a3;
  if (*a2 >= *(_QWORD *)result)
  {
    if (v4 < v3)
    {
      v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (*a2 < *(_QWORD *)result)
      {
        v7 = *result;
        *result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v8 = *result;
      *result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (*a3 >= *a2)
        return result;
      v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      v5 = *result;
      *result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(__int128 *a1, unint64_t *a2, unint64_t *a3, _OWORD *a4)
{
  __n128 result;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(a1, a2, a3);
  if (*(_QWORD *)a4 < *a3)
  {
    result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (*a3 < *a2)
    {
      result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (*a2 < *(_QWORD *)a1)
      {
        result = (__n128)*a1;
        *a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(uint64_t a1, unint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  __int128 *v17;
  __int128 *v18;
  __int128 *v19;
  __int128 *v20;
  unint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (*(a2 - 2) < *(_QWORD *)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)a1, (unint64_t *)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)a1, (unint64_t *)(a1 + 16), (unint64_t *)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      v17 = (__int128 *)(a1 + 16);
      v18 = (__int128 *)(a1 + 32);
      v19 = (__int128 *)(a1 + 48);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)a1, (unint64_t *)(a1 + 16), (unint64_t *)(a1 + 32), (_OWORD *)(a1 + 48));
      v21 = *(a2 - 2);
      v20 = (__int128 *)(a2 - 2);
      if (v21 < *(_QWORD *)(a1 + 48))
      {
        v22 = *v19;
        *v19 = *v20;
        *v20 = v22;
        if (*(_QWORD *)v19 < *(_QWORD *)v18)
        {
          v23 = *v18;
          *v18 = *v19;
          *v19 = v23;
          if (*(_QWORD *)v18 < *(_QWORD *)v17)
          {
            v24 = *v17;
            *v17 = *v18;
            *v18 = v24;
            if (*(_QWORD *)(a1 + 16) < *(_QWORD *)a1)
            {
              v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v17;
              *v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      v8 = (unint64_t *)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((__int128 *)a1, (unint64_t *)(a1 + 16), (unint64_t *)(a1 + 32));
      v9 = (unint64_t *)(a1 + 48);
      if ((unint64_t *)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (*v9 < *v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = *(_QWORD *)(a1 + v14 + 16);
        v14 -= 16;
        if (v12 >= v15)
        {
          v16 = (unint64_t *)(a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      v16 = (unint64_t *)a1;
LABEL_13:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__throw_bad_function_call[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_function_call was thrown in -fno-exceptions mode");
  JUMPOUT(0x18012A5FCLL);
}

_QWORD *std::__function::__func<appendHeader::$_0,std::allocator<appendHeader::$_0>,void ()(segment_command_64 const*,long)>::__clone()
{
  _QWORD *result;

  result = malloc_type_malloc(0x10uLL, 0xB4ED9BFAuLL);
  *result = &unk_1E0DF36B0;
  return result;
}

void std::__function::__func<appendHeader::$_0,std::allocator<appendHeader::$_0>,void ()(segment_command_64 const*,long)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &unk_1E0DF36B0;
}

char *std::__function::__func<appendHeader::$_0,std::allocator<appendHeader::$_0>,void ()(segment_command_64 const*,long)>::operator()(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  objc::SafeRanges *v3;

  v3 = (objc::SafeRanges *)(*(_QWORD *)(*(_QWORD *)a2 + 24) + *a3);
  return objc::SafeRanges::add(v3, (uint64_t)v3 + *(_QWORD *)(*(_QWORD *)a2 + 32));
}

_QWORD *std::__function::__func<removeHeader::$_0,std::allocator<removeHeader::$_0>,void ()(segment_command_64 const*,long)>::__clone()
{
  _QWORD *result;

  result = malloc_type_malloc(0x10uLL, 0xB4ED9BFAuLL);
  *result = off_1E0DF36F8;
  return result;
}

void std::__function::__func<removeHeader::$_0,std::allocator<removeHeader::$_0>,void ()(segment_command_64 const*,long)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1E0DF36F8;
}

__n128 std::__function::__func<removeHeader::$_0,std::allocator<removeHeader::$_0>,void ()(segment_command_64 const*,long)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  objc::SafeRanges *v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  char *v7;
  __n128 result;
  unsigned int v9;
  unsigned int v10;

  v3 = (objc::SafeRanges *)(*(_QWORD *)(*(_QWORD *)a2 + 24) + *(_QWORD *)a3);
  v4 = (char *)v3 + *(_QWORD *)(*(_QWORD *)a2 + 32);
  v10 = 0;
  if (!objc::SafeRanges::find(v3, &v10, a3) || *(char **)(qword_1ECCE5980 + 16 * v10 + 8) != v4)
    _objc_fatal("Cannot find range %#lx..%#lx", v5, v6, v7, v3, v4);
  v9 = qword_1ECCE5988 - 1;
  LODWORD(qword_1ECCE5988) = v9;
  if (v10 < v9)
  {
    result = *(__n128 *)(qword_1ECCE5980 + 16 * v9);
    *(__n128 *)(qword_1ECCE5980 + 16 * v10) = result;
    HIDWORD(qword_1ECCE5988) &= ~0x80000000;
  }
  return result;
}

void logReplacedMethod(const char *a1, char *a2, int a3, const char *a4, void *a5, const void *a6)
{
  int v12;
  BOOL v13;
  const char *dli_fname;
  int v15;
  const char *v16;
  BOOL v17;
  const char *v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  Dl_info v23;

  if (sel_load != a2)
  {
    v12 = dladdr(a5, &v23);
    if (v23.dli_fname)
      v13 = v12 == 0;
    else
      v13 = 1;
    if (v13)
      dli_fname = "??";
    else
      dli_fname = v23.dli_fname;
    v15 = dladdr(a6, &v23);
    v16 = v23.dli_fname;
    if (v23.dli_fname)
      v17 = v15 == 0;
    else
      v17 = 1;
    if (v17)
      v16 = "??";
    v18 = "<null selector>";
    v19 = "by category ";
    if (a2)
      v18 = a2;
    v20 = "";
    if (a4)
      v20 = a4;
    else
      v19 = "";
    v22 = v18;
    v21 = 45;
    if (a3)
      v21 = 43;
    _objc_inform("REPLACED: %c[%s %s]  %s%s  (IMP was %p (%s), now %p (%s))", v21, a1, v22, v19, v20, a5, dli_fname, a6, v16);
  }
}

void objc_enumerationMutation(id obj)
{
  const char *v1;
  char *v2;

  if (!enumerationMutationHandler)
    _objc_fatal("mutation detected during 'for (... in ...)'  enumeration of object %p.", 0, v1, v2, obj);
  enumerationMutationHandler(obj);
}

BOOL sel_isMapped(SEL sel)
{
  char *v1;
  unint64_t StatusReg;
  unsigned int v3;
  _BOOL4 v5;
  _BOOL4 v6;
  int v7;
  unsigned int v8;
  char **v10;

  v1 = (char *)sel;
  if (sel)
  {
    if ((SEL)_dyld_get_objc_selector() == sel)
    {
      LOBYTE(v1) = 1;
    }
    else
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v3 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr(selLock))
      {
        if (!__stxr(v3, selLock))
          goto LABEL_9;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_9:
      v10 = 0;
      v5 = objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>((uint64_t)namedSelectors, v1, &v10);
      v6 = v10 != (char **)(*(_QWORD *)namedSelectors + 8 * dword_1ECCE5718) && v5;
      LOBYTE(v1) = v6 && *v10 == v1;
      v7 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v8 = __ldxr(selLock);
        if (v8 != v7)
          break;
        if (!__stlxr(0, selLock))
          return (char)v1;
      }
      __clrex();
      os_unfair_lock_unlock((os_unfair_lock_t)selLock);
    }
  }
  return (char)v1;
}

void sub_18012A99C(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)selLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t objc_sync_try_enter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5;
  const char *v6;
  char *v7;

  if (a1)
  {
    id2data(a1, 1, 0, a4);
    return os_unfair_recursive_lock_trylock();
  }
  else
  {
    if (DebugNilSync)
      _objc_inform("NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug");
    gdb_objc_class_changed(a1);
    if (DebugNilSync == 2)
      _objc_fatal("@synchronized(nil) is fatal", v5, v6, v7);
    return 1;
  }
}

void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, char shouldCopy)
{
  id *v7;
  id v8;
  id v9;
  unsigned int *v10;
  unint64_t StatusReg;
  unsigned int v12;
  id v14;
  int v15;
  unsigned int v16;

  if (!offset)
  {
    object_setClass(self, (Class)newValue);
    return;
  }
  v7 = (id *)((char *)self + offset);
  if ((shouldCopy & 0xFD) != 0)
  {
    v8 = objc_msgSend(newValue, sel_copyWithZone_, 0);
  }
  else if (shouldCopy == 2)
  {
    v8 = objc_msgSend(newValue, sel_mutableCopyWithZone_, 0);
  }
  else
  {
    if (*v7 == newValue)
      return;
    v8 = newValue;
  }
  v9 = v8;
  if (atomic)
  {
    v10 = (unsigned int *)&PropertyLocks[16
                                       * (unint64_t)(((v7 >> 4) ^ (v7 >> 9)) & 7)];
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v12 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(v10))
    {
      if (!__stxr(v12, v10))
        goto LABEL_14;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_14:
    v14 = *v7;
    *v7 = v9;
    v15 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v16 = __ldxr(v10);
      if (v16 != v15)
        break;
      if (!__stlxr(0, v10))
        goto LABEL_19;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)&PropertyLocks[16
                                                         * (unint64_t)(((v7 >> 4) ^ (v7 >> 9)) & 7)]);
  }
  else
  {
    v14 = *v7;
    *v7 = v8;
  }
LABEL_19:

}

void objc_addLoadImageFunc(objc_func_loadImage func)
{
  uint64_t v1;
  const char *v2;
  char *v3;
  unint64_t StatusReg;
  unsigned int v6;
  _QWORD *v8;
  uint64_t PreoptimizedHeaderRW;
  _QWORD *v10;
  int v11;
  unsigned int v12;
  objc_func_loadImage v13;
  char v14;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v6 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v6, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v8 = (_QWORD *)FirstHeader;
  if (FirstHeader)
  {
    do
    {
      ((void (*)(char *))func)((char *)v8 + *v8);
      PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v8);
      v10 = v8 + 3;
      if (PreoptimizedHeaderRW)
        v10 = (_QWORD *)PreoptimizedHeaderRW;
      v8 = (_QWORD *)(*v10 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v8);
  }
  v13 = func;
  v14 = 1;
  GlobalSmallVector<loadImageCallback,4u>::append((uint64_t *)&v13, v1, v2, v3);
  v11 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v12 = __ldxr(runtimeLock);
    if (v12 != v11)
      break;
    if (!__stlxr(0, runtimeLock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
}

void sub_18012AD08(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t hasSignedClassROPointers(unint64_t a1)
{
  uint64_t v2;

  if (dataSegmentsRanges <= a1 && *(_QWORD *)algn_1ECCE5978 > a1)
    return 1;
  v2 = _dyld_lookup_section_info();
  if (v2)
    return (*(unsigned __int8 *)(v2 + 4) >> 4) & 1;
  else
    return 1;
}

void _objc_patch_root_of_class(int a1, objc_class *this, const char *a3, char *a4)
{
  unint64_t StatusReg;
  unsigned int v8;
  char *v10;
  uint64_t v11;
  int v12;
  unsigned int v13;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v8 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr(runtimeLock))
  {
    if (!__stxr(v8, runtimeLock))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  if (PrintConnecting)
  {
    v10 = objc_class::nameForLogging(this);
    _objc_inform("CLASS: patching class '%s' (%p) to point to body of %p", v10, this, a4);
  }
  if (((unint64_t)a4 & 0x8000000000000000) != 0)
  {
    v11 = objc_debug_taggedpointer_classes[a4 & 7];
    if ((__objc2_class *)v11 == __NSUnrecognizedTaggedPointer)
      v11 = objc_debug_taggedpointer_ext_classes[((unint64_t)a4 >> 55)];
  }
  else
  {
    v11 = *(_QWORD *)a4 & 0xFFFFFFFF8;
  }
  if ((v11 & 0xFFFFFFF000000007) != 0)
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", (uint64_t)this, a3, a4, v11);
  *(_QWORD *)this = v11 & 0xFFFFFFFF8;
  *((_QWORD *)this + 1) = *((_QWORD *)a4 + 1);
  *((_QWORD *)this + 2) = &_objc_empty_cache;
  *((_QWORD *)this + 3) = 0;
  hasSignedClassROPointers((unint64_t)a3);
  *((_QWORD *)this + 4) = *((_QWORD *)a4 + 4);
  v12 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v13 = __ldxr(runtimeLock);
    if (v13 != v12)
      break;
    if (!__stlxr(0, runtimeLock))
      return;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
}

void sub_18012AF00(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;

  v4 = *(_DWORD *)(v2 + 24);
  while (1)
  {
    v5 = __ldxr(v1);
    if (v5 != v4)
      break;
    if (!__stlxr(0, v1))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
LABEL_6:
  _Unwind_Resume(exception_object);
}

objc_class *_objc_atfork_child()
{
  BOOL v0;
  uint64_t v1;
  uint64_t i;
  uint64_t j;
  unint64_t v4;
  int *v5;
  char *v6;
  unint64_t v7;
  char *v8;
  unint64_t v9;
  int *v10;
  int *v11;
  unint64_t v12;
  _QWORD *StatusReg;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  _QWORD **v17;
  _QWORD *v18;
  _QWORD *v19;
  objc_class *result;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  objc_class *v24;
  int v25;
  uint64_t v26;

  if (ForkIsMultithreaded)
    v0 = DisableInitializeForkSafety == 0;
  else
    v0 = 0;
  if (v0)
    MultithreadedForkChild = 1;
  v1 = 0;
  loadMethodLock = 0;
  do
  {
    PropertyLocks[v1] = 0;
    v1 += 16;
  }
  while (v1 != 128);
  for (i = 0; i != 128; i += 16)
    StructLocks[i] = 0;
  for (j = 0; j != 128; j += 16)
    CppObjectLocks[j] = 0;
  v4 = 0;
  v5 = &dword_1ECCE5B88;
  v6 = (char *)&unk_1ECCE5BC0;
  do
  {
    *v5 = 0;
    v7 = v4 + 1;
    if (v4 <= 6)
      v8 = v6;
    else
      v8 = 0;
    v5 = (int *)(v8 + 8);
    if (v4 > 6)
      v5 = 0;
    v6 += 64;
    ++v4;
  }
  while (v7 != 8);
  v9 = 0;
  AssociationsManagerLock = 0;
  v11 = (int *)&unk_1ECCE5DC0;
  do
  {
    v12 = v9 + 1;
    *v10 = 0;
    if (v9 <= 6)
      v10 = v11;
    else
      v10 = 0;
    v11 += 16;
    ++v9;
  }
  while (v12 != 8);
  classInitLock[0] = 0;
  pendingInitializeMapLock[0] = 0;
  runtimeLock[0] = 0;
  DemangleCacheLock[0] = 0;
  selLock[0] = 0;
  objcMsgLogLock[0] = 0;
  AltHandlerDebugLock = 0;
  crashlog_lock = 0;
  StatusReg = (_QWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v14 = StatusReg[40];
  if (v14)
  {
    v15 = *(void **)(v14 + 8);
    if (v15)
      free(v15);
    *(_QWORD *)(v14 + 8) = 0;
  }
  v16 = 0;
  StatusReg[41] = 0;
  StatusReg[42] = 0;
  do
  {
    v17 = (_QWORD **)((char *)&sDataLists + 64 * v16);
    v18 = *v17;
    if (*v17)
    {
      do
      {
        v19 = (_QWORD *)*v18;
        free(v18);
        v18 = v19;
      }
      while (v19);
    }
    *v17 = 0;
    ++v16;
  }
  while (v16 != 8);
  result = (objc_class *)_fetchInitializingClassList(0);
  if (result)
  {
    v24 = result;
    v25 = *(_DWORD *)result;
    if (*(int *)result >= 1)
    {
      v26 = 0;
      do
      {
        result = *(objc_class **)(*((_QWORD *)v24 + 1) + 8 * v26);
        if (result)
        {
          result = (objc_class *)WAITING_FOR_A_CLASS__initialize_LOCK(result, v21, v22, v23);
          v25 = *(_DWORD *)v24;
        }
        ++v26;
      }
      while (v26 < v25);
    }
  }
  return result;
}

id imp_getBlock(IMP anImp)
{
  void (*v1)(void);
  unint64_t StatusReg;
  unsigned int v3;
  uint64_t *v5;
  int v6;
  unsigned int v7;
  unint64_t v9;

  v1 = anImp;
  if (anImp)
  {
    v9 = 0;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v3 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr(runtimeLock))
    {
      if (!__stxr(v3, runtimeLock))
        goto LABEL_7;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_7:
    v5 = pageAndIndexContainingIMP(v1, &v9);
    if (v5)
    {
      if ((unint64_t)v5[v9] <= 0x800)
        v1 = 0;
      else
        v1 = (void (*)(void))v5[v9];
    }
    else
    {
      v1 = 0;
    }
    v6 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v7 = __ldxr(runtimeLock);
      if (v7 != v6)
        break;
      if (!__stlxr(0, runtimeLock))
        return v1;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v1;
}

void defaultBadAllocHandler(objc_class *a1)
{
  char *v1;
  uint64_t v2;
  const char *v3;
  char *v4;

  v1 = objc_class::nameForLogging(a1);
  _objc_fatal("attempt to allocate object of class '%s' failed", v2, v3, v4, v1);
}

uint64_t objc_object::sidetable_getExtraRC_nolock(objc_object *this)
{
  int *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;

                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  v2 = (uint64_t *)(v1 + 2);
  v7 = 0;
  {
    v3 = v7;
    v4 = *v2;
    v5 = v1[6];
  }
  else
  {
    v4 = *v2;
    v5 = v1[6];
    v3 = *v2 + 16 * v5;
  }
  if (v4 + 16 * v5 == v3)
    return 0;
  else
    return *(_QWORD *)(v3 + 8) >> 2;
}

uint64_t objc_object::sidetable_retainCount(objc_object *this)
{
  int *v2;
  unint64_t StatusReg;
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v13;

                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v4 = *(_DWORD *)(StatusReg + 24);
  while (!__ldaxr((unsigned int *)v2))
  {
    if (!__stxr(v4, (unsigned int *)v2))
      goto LABEL_6;
  }
  __clrex();
  os_unfair_lock_lock_with_options();
LABEL_6:
  v13 = 0;
  {
    v6 = v13;
    v7 = *((_QWORD *)v2 + 1);
    v8 = v2[6];
  }
  else
  {
    v7 = *((_QWORD *)v2 + 1);
    v8 = v2[6];
    v6 = v7 + 16 * v8;
  }
  if (v7 + 16 * v8 == v6)
    v9 = 1;
  else
    v9 = (*(_QWORD *)(v6 + 8) >> 2) + 1;
  v10 = *(_DWORD *)(StatusReg + 24);
  while (1)
  {
    v11 = __ldxr((unsigned int *)v2);
    if (v11 != v10)
      break;
    if (!__stlxr(0, (unsigned int *)v2))
      return v9;
  }
  __clrex();
  os_unfair_lock_unlock((os_unfair_lock_t)v2);
  return v9;
}

void AutoreleasePoolPage::busted<void (*)(char const*,...)>(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  _objc_fatal("autorelease pool page %p corrupted\n  magic     0x%08x 0x%08x 0x%08x 0x%08x\n  should be 0x%08x 0x%08x 0x%08x 0x%08x\n  pthread   %p\n  should be %p\n", a2, a3, a4, a1, *a1, a1[1], a1[2], a1[3], 2711724449, 1330926913, 1162626386, 558191425, *((_QWORD *)a1 + 3), *(_QWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)));
}

void sub_18012B664(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = 0;
  *(_QWORD *)(v1 - 16) = 0;
  _Unwind_Resume(a1);
}

uint64_t objc_object::sidetable_subExtraRC_nolock(objc_object *this)
{
  int *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  v2 = (uint64_t *)(v1 + 2);
  v8 = 0;
  {
    v3 = v8;
    v4 = *v2;
    v5 = v1[6];
  }
  else
  {
    v4 = *v2;
    v5 = v1[6];
    v3 = *v2 + 16 * v5;
  }
  if (v4 + 16 * v5 == v3)
    return 0;
  v6 = *(_QWORD *)(v3 + 8);
  if (!v6)
    return 0;
  *(_QWORD *)(v3 + 8) = v6 - 0x100000;
  return 0x40000;
}

uint64_t objc_should_deallocate()
{
  return 1;
}

id objc_retain_autorelease(id a1)
{
  return a1;
}

id objc_initWeakOrNil(id *location, id val)
{
  uint64_t v2;
  __objc2_class *v4;
  int *v5;
  unint64_t StatusReg;
  unsigned int v7;
  __objc2_class *v9;
  int v10;
  int v11;
  unsigned int v12;
  int64_t v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  _QWORD *v18;
  uint64_t v19;

  v2 = (uint64_t)val;
  if (val)
  {
    v4 = 0;
                                             * (unint64_t)(((val >> 4) ^ (val >> 9)) & 7)];
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    while (1)
    {
      v7 = *(_DWORD *)(StatusReg + 24);
      while (!__ldaxr((unsigned int *)v5))
      {
        if (!__stxr(v7, (unsigned int *)v5))
          goto LABEL_8;
      }
      __clrex();
      os_unfair_lock_lock_with_options();
LABEL_8:
      if (v2 < 0)
      {
        v9 = (__objc2_class *)objc_debug_taggedpointer_classes[v2 & 7];
        if (v9 == __NSUnrecognizedTaggedPointer)
          v9 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[((unint64_t)v2 >> 55)];
      }
      else
      {
        v9 = (__objc2_class *)(*(_QWORD *)v2 & 0xFFFFFFFF8);
      }
      if (v9 == v4)
        break;
      v10 = *(_DWORD *)((uint64_t)v9->info & 0xF00007FFFFFFFF8);
      if ((v10 & 1) == 0)
        v10 = *(_DWORD *)(*(_QWORD *)(((uint64_t)v9->isa & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
      if ((v10 & 0x20000000) != 0)
        break;
      v11 = *(_DWORD *)(StatusReg + 24);
      while (1)
      {
        v12 = __ldxr((unsigned int *)v5);
        if (v12 != v11)
          break;
        if (!__stlxr(0, (unsigned int *)v5))
          goto LABEL_19;
      }
      __clrex();
                                                                                  * (unint64_t)(((v2 >> 4) ^ (v2 >> 9)) & 7)]);
LABEL_19:
      class_initialize(v9, (objc_object *)v2);
      v4 = v9;
    }
    v13 = weak_register_no_lock((char **)v5 + 4, v2, (uint64_t)location, 0);
    v2 = v13;
    if (v13 >= 1)
    {
      while (1)
      {
        v14 = __ldxr((unint64_t *)v13);
        if ((v14 & 1) == 0)
          break;
        if ((v14 & 0x40000000000) != 0)
        {
          __clrex();
          goto LABEL_26;
        }
        if (!__stxr(v14 | 0x40000000000, (unint64_t *)v13))
          goto LABEL_26;
      }
      __clrex();
      v19 = -v13;
      *v18 |= 1uLL;
    }
LABEL_26:
    *location = (id)v2;
    v15 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v16 = __ldxr((unsigned int *)v5);
      if (v16 != v15)
        break;
      if (!__stlxr(0, (unsigned int *)v5))
        goto LABEL_32;
    }
    __clrex();
    os_unfair_lock_unlock((os_unfair_lock_t)v5);
LABEL_32:
    callSetWeaklyReferenced(v2);
  }
  else
  {
    *location = 0;
  }
  return (id)v2;
}

void objc_clear_deallocating(objc_object *this, uint64_t a2, const char *a3, char *a4)
{
  if (((unint64_t)this & 0x8000000000000000) == 0)
  {
    if (((uint64_t)this->isa & 1) != 0)
    {
      if (((uint64_t)this->isa & 0x140000000000) != 0)
        objc_object::clearDeallocating_slow(this, a2, a3, a4);
    }
    else
    {
      objc_object::sidetable_clearDeallocating(this);
    }
  }
}

uint64_t _objc_rootReleaseWasZero(unint64_t *a1)
{
  unint64_t v1;
  BOOL v2;
  unint64_t v3;
  uint64_t result;

  if (((unint64_t)a1 & 0x8000000000000000) != 0)
    return 0;
  v1 = __ldxr(a1);
  if ((v1 & 1) != 0)
  {
    while (v1 >> 44)
    {
      v2 = v1 >= 0x200000000000;
      v3 = v1 - 0x200000000000;
      if (!v2)
      {
        __clrex();
        return objc_object::rootRelease_underflow((objc_object *)a1, 0);
      }
      if (!__stlxr(v3, a1))
      {
        if (v3 >> 44)
          return 0;
        __dmb(9u);
        return 1;
      }
      v1 = __ldxr(a1);
      if ((v1 & 1) == 0)
        goto LABEL_15;
    }
    goto LABEL_16;
  }
  if ((*(_WORD *)((v1 & 0xFFFFFFFF8) + 0x1E) & 4) != 0)
  {
LABEL_16:
    result = 0;
    __clrex();
    return result;
  }
LABEL_15:
  __clrex();
  return objc_object::sidetable_release((objc_object *)a1, 0, 0);
}

void _objc_rootFinalize(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  _objc_fatal("_objc_rootFinalize called with garbage collection off", a2, a3, a4);
}

uint64_t _objc_rootZone()
{
  return 0;
}

void weakTableScan(void *a1)
{
  char *v1;
  unint64_t v2;
  uint64_t v3;
  unint64_t StatusReg;
  int *v5;
  uint64_t v6;
  const char *v7;
  char *v8;
  unsigned int v9;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  _QWORD *v20;
  int v21;
  unsigned int v22;
  timespec __rqtp;

  pthread_setname_np("ObjC weak reference scanner");
  __rqtp = (timespec)xmmword_1801358D0;
  v1 = getenv("OBJC_DEBUG_SCAN_WEAK_TABLES_INTERVAL_NANOSECONDS");
  if (v1)
  {
    v2 = strtoull(v1, 0, 10);
    __rqtp.tv_sec = v2 / 0x3B9ACA00;
    __rqtp.tv_nsec = v2 % 0x3B9ACA00;
  }
  v3 = 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  while (1)
  {
    nanosleep(&__rqtp, 0);
    v9 = *(_DWORD *)(StatusReg + 24);
    while (!__ldaxr((unsigned int *)v5))
    {
      if (!__stxr(v9, (unsigned int *)v5))
        goto LABEL_9;
    }
    __clrex();
    os_unfair_lock_lock_with_options();
LABEL_9:
    v11 = *((_QWORD *)v5 + 6);
    if (v11)
    {
      v12 = 0;
      v13 = *((_QWORD *)v5 + 4);
      do
      {
        v14 = (uint64_t *)(v13 + 40 * v12);
        v15 = v14 + 1;
        if ((v14[2] & 3) == 2)
        {
          v15 = (_QWORD *)*v15;
          v16 = *(_QWORD *)(v13 + 40 * v12 + 24) + 1;
        }
        else
        {
          v16 = 4;
        }
        v17 = *v14;
        if (v17)
          v18 = v16 == 0;
        else
          v18 = 1;
        if (!v18)
        {
          v19 = -v17;
          do
          {
            if (*v15)
            {
              v20 = (_QWORD *)-*v15;
              if (*v20 != v19)
                _objc_fatal("Weak reference at %p contains %p, should contain %p", v6, v7, v8, v20, *v20, v19);
            }
            ++v15;
            --v16;
          }
          while (v16);
        }
        ++v12;
      }
      while (v12 <= v11);
    }
    v21 = *(_DWORD *)(StatusReg + 24);
    while (1)
    {
      v22 = __ldxr((unsigned int *)v5);
      if (v22 != v21)
        break;
      if (!__stlxr(0, (unsigned int *)v5))
        goto LABEL_28;
    }
    __clrex();
LABEL_28:
    if (v3 == 7)
      v3 = 0;
    else
      ++v3;
  }
}

uint64_t __copy_helper_block_e8_32c47_ZTSKZ34getSharedCachePreoptimizedProtocolE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

uint64_t __copy_helper_block_e8_32c36_ZTSKZ23getPreoptimizedProtocolE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

uint64_t __copy_helper_block_e8_32c33_ZTSKZ20getPreoptimizedClassE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

uint64_t __getPreoptimizedClassesWithMetaClass_block_invoke(uint64_t result, _QWORD *a2, int a3, _BYTE *a4)
{
  if (a3)
  {
    if (*(_QWORD *)(result + 40) == (*a2 & 0xFFFFFFFF8))
    {
      **(_QWORD **)(result + 32) = a2;
      *a4 = 1;
    }
  }
  return result;
}

__n128 __copy_helper_block_e8_32c48_ZTSKZ35getPreoptimizedClassesWithMetaClassE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[2] = result;
  return result;
}

void cache_t::bad_cache(cache_t *this, objc_object *a2, objc_selector *a3)
{
  const char *v6;
  size_t v7;
  size_t v8;
  const char *v9;
  char *v10;
  uint64_t v11;
  const char *v12;
  char *v13;

  _objc_inform_now_and_on_crash("Method cache corrupted. This may be a message to an invalid object, or a memory error somewhere else.");
  if (a2)
    v6 = "receiver";
  else
    v6 = "unused";
  _objc_inform_now_and_on_crash("%s %p, SEL %p, isa %p, cache %p, buckets and mask 0x%lx, occupied 0x%x", v6, a2, a3, (char *)this - 16, this, *(_QWORD *)this, *((unsigned __int16 *)this + 6));
  v7 = malloc_size(a2);
  v8 = malloc_size((const void *)(*(_QWORD *)this & 0xFFFFFFFFFFFLL));
  _objc_inform_now_and_on_crash("%s %zu bytes, buckets %zu bytes", v6, v7, v8);
  v9 = "<null selector>";
  if (a3)
    v9 = (const char *)a3;
  _objc_inform_now_and_on_crash("selector '%s'", v9);
  v10 = objc_class::nameForLogging((cache_t *)((char *)this - 16));
  _objc_inform_now_and_on_crash("isa '%s'", v10);
  _objc_fatal("Method cache corrupted. This may be a message to an invalid object, or a memory error somewhere else.", v11, v12, v13);
}

void _objc_error(objc_object *a1, va_list a2, char *a3)
{
  const char *ClassName;
  uint64_t v5;
  const char *v6;
  char *v7;
  char *v8;

  v8 = 0;
  vasprintf(&v8, "invalid selector (null)", a2);
  ClassName = object_getClassName(a1);
  _objc_fatal("%s: %s", v5, v6, v7, ClassName, v8);
}

void __objc_error(objc_object *a1, const char *a2, char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  _objc_error(a1, va, a3);
}

void _objc_inform_now_and_on_crash(const char *a1, ...)
{
  pid_t v1;
  char *__s1;
  char *v3[2];
  va_list va;

  va_start(va, a1);
  v3[0] = 0;
  __s1 = 0;
  va_copy((va_list)&v3[1], va);
  vasprintf(v3, a1, va);
  v1 = getpid();
  asprintf(&__s1, "objc[%d]: %s\n", v1, v3[0]);
  _objc_crashlog(__s1);
  _objc_syslog(__s1);
  free(__s1);
  free(v3[0]);
}

uint64_t _objc_inform_deprecated(const char *a1, const char *a2)
{
  if (PrintDeprecation)
    _objc_inform("The function %s is obsolete. Do not use it. Set a breakpoint on _objc_warn_deprecated to find the culprit.", a1);
  return gdb_objc_class_changed(a1);
}

void objc_terminate(void)
{
  std::terminate();
}

void objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::FatalCorruptHashTables(_QWORD *a1, uint64_t a2)
{
  size_t v4;
  uint64_t v5;
  const char *v6;
  char *v7;

  v4 = malloc_size(a1);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v5, v6, v7, &objc::smallMethodIMPMap, a1, v4, a2, qword_1ECCE51F8, HIDWORD(qword_1ECCE51F8), *a1, a1[1], a1[2], a1[3]);
}

void objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::FatalCorruptHashTables(_QWORD *a1, uint64_t a2)
{
  size_t v4;
  uint64_t v5;
  const char *v6;
  char *v7;

  v4 = malloc_size(a1);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v5, v6, v7, &objc::methodDescriptionMap, a1, v4, a2, qword_1ECCE4E18, HIDWORD(qword_1ECCE4E18), *a1, a1[1], a1[2], a1[3]);
}

void objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::FatalCorruptHashTables(_QWORD *a1, uint64_t a2)
{
  size_t v4;
  uint64_t v5;
  const char *v6;
  char *v7;

  v4 = malloc_size(a1);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v5, v6, v7, &remappedClasses(BOOL)::remapped_class_map, a1, v4, a2, qword_1ECCE4EB8, HIDWORD(qword_1ECCE4EB8), *a1, a1[1], a1[2], a1[3]);
}

void objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::FatalCorruptHashTables(_QWORD *a1, uint64_t a2)
{
  size_t v4;
  uint64_t v5;
  const char *v6;
  char *v7;

  v4 = malloc_size(a1);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v5, v6, v7, &objc::unattachedCategories, a1, v4, a2, qword_1ECCE59C0, HIDWORD(qword_1ECCE59C0), *a1, a1[1], a1[2], a1[3]);
}

void printReplacements(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  int *v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  char *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v16;
  const char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  unint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unsigned int v39;
  char *v40;
  int v41;
  const char *v42;
  void *v43;
  const void *v44;
  const char *v45;
  char *v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  const char *v50;
  char *v51;
  unint64_t v52;
  uint64_t v53;
  char *v55;
  int v56;
  const char *v57;
  void *v58;
  const void *v59;
  uint64_t v60;
  const char **v61;
  uint64_t v62;
  unsigned int v64;
  __int16 v65;
  _QWORD v67[12];
  uint64_t *v68[9];
  unint64_t v69;
  _QWORD v70[2];

  if ((_DWORD)a3)
  {
    v4 = 0;
    v65 = *(_WORD *)(a1 + 30);
    v60 = a3;
    v6 = dataSegmentsRanges;
    v5 = *(_QWORD *)algn_1ECCE5978;
    do
    {
      v7 = 3;
      if ((v65 & 4) == 0)
        v7 = 2;
      v61 = *(const char ***)(a2 + 16 * v4);
      v8 = (int *)v61[v7];
      if (v8)
      {
        v9 = *v8;
        v10 = (unint64_t)(v8 + 2) & 0xFFFFFFFFFFFFFFFCLL | (v9 >> 31);
        entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd(v8, a2, a3, a4);
        v62 = a2;
        if (v10 != a2)
        {
          v11 = v9 & 0xFFFC;
          do
          {
            v64 = v11;
            if ((v10 & 3) != 0 && (v10 & 3) != 2)
            {
              v13 = v10 & 0xFFFFFFFFFFFFFFFCLL;
              v14 = *(int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
              if (v6 <= (v10 & 0xFFFFFFFFFFFFFFFCLL) && v5 > v13)
                v12 = (char *)&unk_1F25805A8 + v14;
              else
                v12 = *(char **)(v13 + v14);
            }
            else
            {
              v12 = *(char **)(v10 & 0xFFFFFFFFFFFFFFFCLL);
            }
            v19 = (char *)__sel_registerName(v12, 1, 1);
            if (v4)
            {
              v20 = 0;
              while (1)
              {
                v21 = 24;
                if ((v65 & 4) == 0)
                  v21 = 16;
                v22 = *(unsigned int **)(*(_QWORD *)(a2 + 16 * v20) + v21);
                if (v22)
                {
                  v23 = *v22;
                  v24 = v22[1];
                  v25 = *v22 & 0xFFFC;
                  v26 = v24 * (unint64_t)((unsigned __int16)v23 & 0xFFFC);
                  if ((v26 & 0xFFFFFFFF00000000) != 0)
                    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v16, v17, v18, v24, v22, v23 & 0xFFFC);
                  v27 = (unint64_t)(v22 + 2);
                  v28 = v27 & 0xFFFFFFFFFFFFFFFCLL | (v23 >> 31);
                  v29 = (v27 + v26) & 0xFFFFFFFFFFFFFFFCLL | (v23 >> 31);
                  if (v28 != v29)
                    break;
                }
LABEL_35:
                if (++v20 == v4)
                  goto LABEL_36;
              }
              while (1)
              {
                if ((v28 & 3) != 0 && (v28 & 3) != 2)
                {
                  v31 = v28 & 0xFFFFFFFFFFFFFFFCLL;
                  v32 = *(int *)(v28 & 0xFFFFFFFFFFFFFFFCLL);
                  v33 = v6 <= (v28 & 0xFFFFFFFFFFFFFFFCLL) && v5 > v31;
                  v30 = v33 ? (char *)&unk_1F25805A8 + v32 : *(char **)(v31 + v32);
                }
                else
                {
                  v30 = *(char **)(v28 & 0xFFFFFFFFFFFFFFFCLL);
                }
                if (v19 == __sel_registerName(v30, 1, 1))
                  break;
                v28 += v25;
                if (v28 == v29)
                  goto LABEL_35;
              }
              v40 = objc_class::nameForLogging((objc_class *)a1);
              v41 = (*(unsigned __int16 *)(a1 + 30) >> 2) & 1;
              v42 = *v61;
              v43 = (void *)method_t::impRaw(v28);
              v44 = (const void *)method_t::impRaw(v10);
              logReplacedMethod(v40, v19, v41, v42, v43, v44);
              v39 = v64;
            }
            else
            {
LABEL_36:
              v34 = *(_QWORD *)((*(_QWORD *)(a1 + 32) & 0xF00007FFFFFFFF8) + 8);
              v35 = v34 & 0xFFFFFFFFFFFFFFFELL;
              if ((v34 & 1) != 0)
              {
                v37 = *(_QWORD *)(v35 + 8);
                v39 = v64;
              }
              else
              {
                v36 = *(_QWORD *)(v35 + 32);
                v37 = v36 & 0xFFFFFFFFFFFFFFFELL;
                if ((v36 & 1) != 0)
                  v38 = v36 & 0xFFFFFFFFFFFFFFFELL;
                else
                  v38 = 0;
                v39 = v64;
                if ((v36 & 1) != 0 || !v37)
                {
                  v37 = v38 | 2;
                  if (!v38)
                    v37 = 0;
                }
              }
              v70[0] = v37;
              list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::begin((uint64_t)v68, v70, v17, v18);
              list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::end((uint64_t)v67, v70, v45, v46);
              while (!list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v68, v67))
              {
                v47 = v69;
                if ((v69 & 3) != 0 && (v69 & 3) != 2)
                {
                  v52 = v69 & 0xFFFFFFFFFFFFFFFCLL;
                  v53 = *(int *)(v69 & 0xFFFFFFFFFFFFFFFCLL);
                  if (v6 <= (v69 & 0xFFFFFFFFFFFFFFFCLL) && v5 > v52)
                    v48 = (char *)&unk_1F25805A8 + v53;
                  else
                    v48 = *(char **)(v52 + v53);
                }
                else
                {
                  v48 = *(char **)(v69 & 0xFFFFFFFFFFFFFFFCLL);
                }
                if (v19 == __sel_registerName(v48, 1, 1))
                {
                  v55 = objc_class::nameForLogging((objc_class *)a1);
                  v56 = (*(unsigned __int16 *)(a1 + 30) >> 2) & 1;
                  v57 = *v61;
                  v58 = (void *)method_t::impRaw(v47);
                  v59 = (const void *)method_t::impRaw(v10);
                  logReplacedMethod(v55, v19, v56, v57, v58, v59);
                  break;
                }
                list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator++(v68, v49, v50, v51);
              }
            }
            v10 += v39;
            v11 = v39;
          }
          while (v10 != v62);
        }
      }
      ++v4;
    }
    while (v4 != v60);
  }
}

void objc_defaultForwardHandler(objc_object *a1, objc_selector *a2)
{
  Class Class;
  uint64_t v5;
  const char *ClassName;
  uint64_t v7;
  const char *v8;
  char *v9;
  const char *v10;

  Class = object_getClass(a1);
  v5 = 45;
  if (Class)
  {
    if ((*((_WORD *)Class + 15) & 4) != 0)
      v5 = 43;
    else
      v5 = 45;
  }
  ClassName = object_getClassName(a1);
  v10 = "<null selector>";
  if (a2)
    v10 = (const char *)a2;
  _objc_fatal("%c[%s %s]: unrecognized selector sent to instance %p (no message forward handler is installed)", v7, v8, v9, v5, ClassName, v10, a1);
}

void objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::FatalCorruptHashTables(_QWORD *a1, uint64_t a2)
{
  size_t v4;
  uint64_t v5;
  const char *v6;
  char *v7;

  v4 = malloc_size(a1);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v5, v6, v7, &objc::AssociationsManager::_mapStorage, a1, v4, a2, qword_1ECCE5490, HIDWORD(qword_1ECCE5490), *a1, a1[1], a1[2], a1[3]);
}

void AutoreleasePoolPage::busted_die(AutoreleasePoolPage *this, uint64_t a2, const char *a3, char *a4)
{
  AutoreleasePoolPage::busted<void (*)(char const*,...)>((unsigned int *)this, a2, a3, a4);
}

void _objc_callBadAllocHandler(objc_class *a1)
{
  badAllocHandler(a1);
}

uint64_t AutoreleasePoolPage::badPop(AutoreleasePoolPage *this, void *a2)
{
  AutoreleasePoolPage *v2;
  char v3;
  uint64_t result;
  uint64_t v5;
  const char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = this;
  if (DebugPoolAllocation == 2
    || (this = (AutoreleasePoolPage *)dyld_program_sdk_at_least(), (this & 1) != 0)
    || (this = (AutoreleasePoolPage *)dyld_program_sdk_at_least(), (this & 1) != 0)
    || (this = (AutoreleasePoolPage *)dyld_program_sdk_at_least(), (this & 1) != 0)
    || (this = (AutoreleasePoolPage *)dyld_program_sdk_at_least(), (this & 1) != 0))
  {
    v3 = 1;
  }
  else
  {
    this = (AutoreleasePoolPage *)dyld_program_sdk_at_least();
    v3 = (char)this;
  }
  if ((AutoreleasePoolPage::badPop(void *)::complained & 1) == 0)
  {
    AutoreleasePoolPage::badPop(void *)::complained = 1;
    _objc_inform_now_and_on_crash("Invalid or prematurely-freed autorelease pool %p. Set a breakpoint on objc_autoreleasePoolInvalid to debug. ", v2);
    if ((v3 & 1) == 0)
    {
      _objc_inform("Proceeding anyway.  Memory errors are likely.");
      return gdb_objc_class_changed(v9);
    }
    gdb_objc_class_changed(v8);
LABEL_14:
    _objc_fatal("Invalid autorelease pools are a fatal error", v5, v6, v7);
  }
  result = gdb_objc_class_changed(this);
  if ((v3 & 1) != 0)
    goto LABEL_14;
  return result;
}

void AutoreleasePoolPage::popPageDebug(AutoreleasePoolPage **this, objc_object **a2, AutoreleasePoolPage *a3, objc_object **a4)
{
  uint64_t v6;
  const char *v7;
  char *v8;
  AutoreleasePoolPage *v9;
  AutoreleasePoolPage *v10;
  uint64_t v11;
  const char *v12;
  char *v13;

  if (PrintPoolHiwat)
    AutoreleasePoolPage::printHiwat((AutoreleasePoolPage *)this, (uint64_t)a2, (const char *)a3, (char *)a4);
  AutoreleasePoolPage::releaseUntil((objc_object ***)this, a2, (const char *)a3, (char *)a4);
  if (DebugPoolAllocation && this[2] == (AutoreleasePoolPage *)(this + 7))
  {
    v10 = this[4];
    AutoreleasePoolPage::kill((AutoreleasePoolPage *)this, v6, v7, v8);
    if (v10 && *(_DWORD *)v10 != -1583242847)
      AutoreleasePoolPage::busted_die(v10, v11, v12, v13);
    *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 344) = v10;
  }
  else if (DebugMissingPools && this[2] == (AutoreleasePoolPage *)(this + 7) && !this[4])
  {
    AutoreleasePoolPage::kill((AutoreleasePoolPage *)this, v6, v7, v8);
    *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 344) = 0;
  }
  else
  {
    v9 = this[5];
    if (v9)
    {
      if (this[2] - (AutoreleasePoolPage *)this - 56 <= 2015
        || (v9 = (AutoreleasePoolPage *)*((_QWORD *)v9 + 5)) != 0)
      {
        AutoreleasePoolPage::kill(v9, v6, v7, v8);
      }
    }
  }
}

void AutoreleasePoolPage::printHiwat(AutoreleasePoolPage *this, uint64_t a2, const char *a3, char *a4)
{
  unint64_t StatusReg;
  uint64_t v5;
  unsigned int v6;
  int v7;
  int v8;
  char **v9;
  char **v10;
  uint64_t v11;
  const char **v12;
  const char *v13;
  void *v14[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v5 = *(_QWORD *)(StatusReg + 344);
  if (v5)
  {
    if (v5 == 1)
    {
      v5 = 0;
    }
    else if (*(_DWORD *)v5 != -1583242847)
    {
      AutoreleasePoolPage::busted_die(*(AutoreleasePoolPage **)(StatusReg + 344), a2, a3, a4);
    }
  }
  v6 = ((unint64_t)(*(_QWORD *)(v5 + 16) - v5 - 56) >> 3) + (*(_DWORD *)(v5 + 48) << 9);
  if (*(_DWORD *)(v5 + 52) + 256 < v6)
  {
    v7 = 0;
    do
    {
      *(_DWORD *)(v5 + 52) = v6;
      v7 += AutoreleasePoolPage::sumOfExtraReleases((AutoreleasePoolPage *)v5);
      v5 = *(_QWORD *)(v5 + 32);
    }
    while (v5);
    _objc_inform("POOL HIGHWATER: new high water mark of %u pending releases for thread %p:", v6, *(const void **)StatusReg);
    if (v7)
      _objc_inform("POOL HIGHWATER: extra sequential autoreleases of objects: %u", v7);
    v44 = 0u;
    v45 = 0u;
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    *(_OWORD *)v14 = 0u;
    v15 = 0u;
    v8 = backtrace(v14, 128);
    v9 = backtrace_symbols(v14, v8);
    v10 = v9;
    if (v8 >= 1)
    {
      v11 = v8;
      v12 = (const char **)v9;
      do
      {
        v13 = *v12++;
        _objc_inform("POOL HIGHWATER:     %s", v13);
        --v11;
      }
      while (v11);
    }
    free(v10);
  }
}

uint64_t AutoreleasePoolPage::sumOfExtraReleases(AutoreleasePoolPage *this)
{
  unint64_t *v1;
  unint64_t v2;
  uint64_t result;
  unint64_t v4;
  unsigned int v5;

  v1 = (unint64_t *)((char *)this + 56);
  v2 = *((_QWORD *)this + 2);
  if ((unint64_t)this + 56 >= v2)
    return 0;
  LODWORD(result) = 0;
  do
  {
    v4 = *v1++;
    v5 = result + ((v4 >> 44) & 0xFF0 | (v4 >> 60));
    if (v4)
      result = v5;
    else
      result = result;
  }
  while ((unint64_t)v1 < v2);
  return result;
}

void AutoreleasePoolPage::printAll(AutoreleasePoolPage *this)
{
  unint64_t StatusReg;
  uint64_t v2;
  const char *v3;
  char *v4;
  AutoreleasePoolPage *v5;
  AutoreleasePoolPage *v6;
  AutoreleasePoolPage *v7;

  _objc_inform("##############");
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  _objc_inform("AUTORELEASE POOLS for thread %p", *(const void **)StatusReg);
  v5 = *(AutoreleasePoolPage **)(StatusReg + 344);
  if ((unint64_t)v5 >= 2)
  {
    if (*(_DWORD *)v5 != -1583242847)
LABEL_14:
      AutoreleasePoolPage::busted_die(v5, v2, v3, v4);
    while (1)
    {
      v6 = (AutoreleasePoolPage *)*((_QWORD *)v5 + 4);
      if (!v6)
        break;
      v5 = (AutoreleasePoolPage *)*((_QWORD *)v5 + 4);
      if (*(_DWORD *)v6 != -1583242847)
        AutoreleasePoolPage::busted_die(v6, v2, v3, v4);
    }
    do
    {
      v6 = (AutoreleasePoolPage *)((char *)v6 + ((*((_QWORD *)v5 + 2) - (_QWORD)v5 - 56) >> 3));
      v5 = (AutoreleasePoolPage *)*((_QWORD *)v5 + 5);
    }
    while (v5);
  }
  else
  {
    v6 = 0;
  }
  _objc_inform("%llu releases pending.", v6);
  v7 = *(AutoreleasePoolPage **)(StatusReg + 344);
  if (v7 == (AutoreleasePoolPage *)1)
  {
    _objc_inform("[%p]  ................  PAGE (placeholder)", (const void *)1);
    _objc_inform("[%p]  ################  POOL (placeholder)", (const void *)1);
  }
  else if ((unint64_t)v7 >= 2)
  {
    if (*(_DWORD *)v7 != -1583242847)
      AutoreleasePoolPage::busted_die(v7, v2, v3, v4);
    while (1)
    {
      v5 = (AutoreleasePoolPage *)*((_QWORD *)v7 + 4);
      if (!v5)
        break;
      v7 = (AutoreleasePoolPage *)*((_QWORD *)v7 + 4);
      if (*(_DWORD *)v5 != -1583242847)
        goto LABEL_14;
    }
    do
    {
      AutoreleasePoolPage::print(v7, v2, v3, v4);
      v7 = (AutoreleasePoolPage *)*((_QWORD *)v7 + 5);
    }
    while (v7);
  }
  _objc_inform("##############");
}

void AutoreleasePoolPage::print(AutoreleasePoolPage *this, uint64_t a2, const char *a3, char *a4)
{
  const char *v5;
  const char *v6;
  unint64_t StatusReg;
  AutoreleasePoolPage *v8;
  AutoreleasePoolPage *v9;
  const char *v10;
  AutoreleasePoolPage *v11;
  int v12;
  int v13;
  const void *v14;
  id *v15;
  unint64_t v16;

  v5 = "";
  if (*((AutoreleasePoolPage **)this + 2) == (AutoreleasePoolPage *)((char *)this + 4096))
    v6 = "(full)";
  else
    v6 = "";
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v8 = *(AutoreleasePoolPage **)(StatusReg + 344);
  if (v8)
  {
    if (v8 == (AutoreleasePoolPage *)1)
    {
      v9 = 0;
      goto LABEL_9;
    }
    if (*(_DWORD *)v8 != -1583242847)
      goto LABEL_32;
  }
  v9 = *(AutoreleasePoolPage **)(StatusReg + 344);
LABEL_9:
  if (v9 == this)
    v10 = "(hot)";
  else
    v10 = "";
  if ((unint64_t)v8 >= 2)
  {
    while (*(_DWORD *)v8 == -1583242847)
    {
      v11 = v8;
      v8 = (AutoreleasePoolPage *)*((_QWORD *)v8 + 4);
      if (!v8)
        goto LABEL_16;
    }
LABEL_32:
    AutoreleasePoolPage::busted_die(v8, a2, a3, a4);
  }
  v11 = 0;
LABEL_16:
  if (v11 == this)
    v5 = "(cold)";
  _objc_inform("[%p]  ................  PAGE %s %s %s", this, v6, v10, v5);
  v12 = *(_DWORD *)this;
  if (*(_DWORD *)this != -1583242847)
  {
    v14 = *(const void **)StatusReg;
LABEL_23:
    _objc_inform("autorelease pool page %p corrupted\n  magic     0x%08x 0x%08x 0x%08x 0x%08x\n  should be 0x%08x 0x%08x 0x%08x 0x%08x\n  pthread   %p\n  should be %p\n", this, v12, *((_DWORD *)this + 1), *((_DWORD *)this + 2), *((_DWORD *)this + 3), -1583242847, 1330926913, 1162626386, 558191425, *((const void **)this + 3), v14);
    goto LABEL_24;
  }
  v13 = strncmp((const char *)this + 4, "AUTORELEASE!", 0xCuLL);
  v14 = *(const void **)StatusReg;
  if (v13 || *((const void **)this + 3) != v14)
    goto LABEL_23;
LABEL_24:
  v15 = (id *)((char *)this + 56);
  if ((unint64_t)this + 56 < *((_QWORD *)this + 2))
  {
    do
    {
      v16 = (unint64_t)*v15;
      if (*v15)
      {
        if ((v16 >> 44) & 0xFF0 | (v16 >> 60))
        {
          object_getClassName((id)(v16 & 0xF00FFFFFFFFFFFFLL));
          _objc_inform("[%p]  %#16lx  %s  autorelease count %lu");
        }
        else
        {
          object_getClassName(*v15);
          _objc_inform("[%p]  %#16lx  %s");
        }
      }
      else
      {
        _objc_inform("[%p]  ################  POOL %p");
      }
      ++v15;
    }
    while ((unint64_t)v15 < *((_QWORD *)this + 2));
  }
}

void sub_18012CC28(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 72) = 0;
  *(_QWORD *)(v1 - 80) = 0;
  _Unwind_Resume(a1);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

void _Exit(int a1)
{
  MEMORY[0x1E0C80980](*(_QWORD *)&a1);
}

char ***_NSGetEnviron(void)
{
  return (char ***)MEMORY[0x1E0C809D0]();
}

mach_header_64 *_NSGetMachExecuteHeader(void)
{
  return (mach_header_64 *)MEMORY[0x1E0C809E0]();
}

uintptr_t _Unwind_GetCFA(_Unwind_Context *a1)
{
  return MEMORY[0x1E0C809F8](a1);
}

uintptr_t _Unwind_GetIP(_Unwind_Context *context)
{
  return MEMORY[0x1E0C80A00](context);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
  MEMORY[0x1E0DE4930](__format);
}

std::terminate_handler std::set_terminate(std::terminate_handler a1)
{
  return (std::terminate_handler)MEMORY[0x1E0DE5170](a1);
}

void std::terminate(void)
{
  MEMORY[0x1E0DE5178]();
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE51D0](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE51D8](a1);
}

struct type_info *__cxa_current_exception_type(void)
{
  return (struct type_info *)MEMORY[0x1E0DE51E0]();
}

void __cxa_end_catch(void)
{
  MEMORY[0x1E0DE51F8]();
}

void __cxa_rethrow(void)
{
  MEMORY[0x1E0DE5230]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE5240](a1, lptinfo, a3);
}

uint64_t __gxx_personality_v0()
{
  return MEMORY[0x1E0DE5258]();
}

uint64_t _dyld_for_each_objc_class()
{
  return MEMORY[0x1E0C80E38]();
}

uint64_t _dyld_for_each_objc_protocol()
{
  return MEMORY[0x1E0C80E40]();
}

uint64_t _dyld_for_objc_header_opt_ro()
{
  return MEMORY[0x1E0C80E48]();
}

uint64_t _dyld_for_objc_header_opt_rw()
{
  return MEMORY[0x1E0C80E50]();
}

uint64_t _dyld_get_dlopen_image_header()
{
  return MEMORY[0x1E0C80E58]();
}

uint64_t _dyld_get_image_slide()
{
  return MEMORY[0x1E0C80E70]();
}

uint64_t _dyld_get_image_uuid()
{
  return MEMORY[0x1E0C80E78]();
}

uint64_t _dyld_get_objc_selector()
{
  return MEMORY[0x1E0C80E88]();
}

uint64_t _dyld_get_prog_image_header()
{
  return MEMORY[0x1E0C80E90]();
}

uint64_t _dyld_get_shared_cache_range()
{
  return MEMORY[0x1E0C80E98]();
}

uint64_t _dyld_get_shared_cache_uuid()
{
  return MEMORY[0x1E0C80EA0]();
}

uint64_t _dyld_is_memory_immutable()
{
  return MEMORY[0x1E0C80EC8]();
}

uint64_t _dyld_lookup_section_info()
{
  return MEMORY[0x1E0C80ED8]();
}

uint64_t _dyld_objc_class_count()
{
  return MEMORY[0x1E0C80EE8]();
}

uint64_t _dyld_objc_register_callbacks()
{
  return MEMORY[0x1E0C80EF0]();
}

uint64_t _os_feature_enabled_simple_impl()
{
  return MEMORY[0x1E0C81018]();
}

uint64_t _os_log_simple()
{
  return MEMORY[0x1E0C81078]();
}

uint64_t _simple_asl_log()
{
  return MEMORY[0x1E0C81210]();
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

uint64_t abort_with_reason()
{
  return MEMORY[0x1E0C813C0]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
  MEMORY[0x1E0C81580](__buf, __nbytes);
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1E0C81588](*(_QWORD *)&__upper_bound);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1E0C81608](a1, a2);
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1E0C816B8](a1, *(_QWORD *)&a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return (char **)MEMORY[0x1E0C816C8](a1, *(_QWORD *)&a2);
}

void backtrace_symbols_fd(void *const *a1, int a2, int a3)
{
  MEMORY[0x1E0C816D0](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1E0C83028](a1, a2);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1E0C83038]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

uint64_t dyld_image_header_containing_address()
{
  return MEMORY[0x1E0C830F8]();
}

uint64_t dyld_image_path_containing_address()
{
  return MEMORY[0x1E0C83100]();
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1E0C83158]();
}

uint64_t dyld_shared_cache_some_image_overridden()
{
  return MEMORY[0x1E0C831A8]();
}

int fileno(FILE *a1)
{
  return MEMORY[0x1E0C833B0](a1);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1E0C83560](*(_QWORD *)&a1, a2);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1E0C83660](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x1E0C83760]();
}

char *__cdecl getsectdatafromheader_64(const mach_header_64 *mhp, const char *segname, const char *sectname, uint64_t *size)
{
  return (char *)MEMORY[0x1E0C837D8](mhp, segname, sectname, size);
}

uint8_t *__cdecl getsegmentdata(const mach_header_64 *mhp, const char *segname, unint64_t *size)
{
  return (uint8_t *)MEMORY[0x1E0C837F0](mhp, segname, size);
}

int issetugid(void)
{
  return MEMORY[0x1E0C839B8]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1E0C83C80](*(_QWORD *)&error_value);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1E0C83CF8](*(_QWORD *)&task, *(_QWORD *)&name);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x1E0C83EE0](ptr);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x1E0C83F08](memptr, alignment, size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

uint64_t malloc_type_zone_malloc_with_options_internal()
{
  return MEMORY[0x1E0C83F30]();
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return MEMORY[0x1E0C840D0](__s, __smax, *(_QWORD *)&__c, __n);
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  return MEMORY[0x1E0C84238](__rqtp, __rmtp);
}

uint64_t objc_bp_assist_cfg_np()
{
  return MEMORY[0x1E0C84478]();
}

uint64_t os_fault_with_payload()
{
  return MEMORY[0x1E0C846F0]();
}

uint64_t os_parse_boot_arg_string()
{
  return MEMORY[0x1E0C84900]();
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x1E0C849A0]();
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return MEMORY[0x1E0C849A8](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C849B0](lock);
}

uint64_t os_unfair_recursive_lock_lock_with_options()
{
  return MEMORY[0x1E0C849B8]();
}

uint64_t os_unfair_recursive_lock_trylock()
{
  return MEMORY[0x1E0C849C0]();
}

uint64_t os_unfair_recursive_lock_tryunlock4objc()
{
  return MEMORY[0x1E0C849C8]();
}

uint64_t os_unfair_recursive_lock_unlock()
{
  return MEMORY[0x1E0C849D0]();
}

uint64_t os_variant_allows_internal_security_policies()
{
  return MEMORY[0x1E0C849D8]();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1E0C849F8]();
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1E0C84D50](a1, a2, a3, a4);
}

int pthread_detach(pthread_t a1)
{
  return MEMORY[0x1E0C84D78](a1);
}

int pthread_is_threaded_np(void)
{
  return MEMORY[0x1E0C84DD0]();
}

uint64_t pthread_key_init_np()
{
  return MEMORY[0x1E0C84DF0]();
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x1E0C84E00](a1);
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x1E0C84F08](a1);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1E0C85030](__ptr, __size);
}

uint64_t sandbox_check()
{
  return MEMORY[0x1E0C85178]();
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x1E0C85500](a1, a2);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85510](__s1, __s2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C85518](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

size_t strcspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1E0C85538](__s, __charset);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1E0C85548](*(_QWORD *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1E0C855B0](__dst, __src, __n);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85610](__s1, __s2);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85658](__str, __endptr, *(_QWORD *)&__base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C856A8](__str, __endptr, *(_QWORD *)&__base);
}

uint64_t task_restartable_ranges_register()
{
  return MEMORY[0x1E0C85868]();
}

uint64_t task_restartable_ranges_synchronize()
{
  return MEMORY[0x1E0C85870]();
}

kern_return_t task_threads(task_inspect_t target_task, thread_act_array_t *act_list, mach_msg_type_number_t *act_listCnt)
{
  return MEMORY[0x1E0C858A0](*(_QWORD *)&target_task, act_list, act_listCnt);
}

kern_return_t thread_get_state(thread_read_t target_act, thread_state_flavor_t flavor, thread_state_t old_state, mach_msg_type_number_t *old_stateCnt)
{
  return MEMORY[0x1E0C858F0](*(_QWORD *)&target_act, *(_QWORD *)&flavor, old_state, old_stateCnt);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x1E0C85A58](a1, a2, a3);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x1E0C85A80](*(_QWORD *)&target_task, address, size, *(_QWORD *)&flags);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1E0C85A98](*(_QWORD *)&target_task, address, size);
}

kern_return_t vm_remap(vm_map_t target_task, vm_address_t *target_address, vm_size_t size, vm_address_t mask, int flags, vm_map_t src_task, vm_address_t src_address, BOOLean_t copy, vm_prot_t *cur_protection, vm_prot_t *max_protection, vm_inherit_t inheritance)
{
  return MEMORY[0x1E0C85B08](*(_QWORD *)&target_task, target_address, size, mask, *(_QWORD *)&flags, *(_QWORD *)&src_task, src_address, *(_QWORD *)&copy);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1E0C85D40](*(_QWORD *)&__fd, __buf, __nbyte);
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_libswiftCore_dylib(double a1)
{
  dlopen("/usr/lib/swift/libswiftCore.dylib", 0);
  atomic_store(1u, (unsigned int *)&dlopenHelperFlag_libswiftCore_dylib);
  return a1;
}

double gotLoadHelper_x9__swift_retain(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_libswiftCore_dylib))
    return dlopenHelper_libswiftCore_dylib(result);
  return result;
}

double gotLoadHelper_x10__swift_release(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_libswiftCore_dylib))
    return dlopenHelper_libswiftCore_dylib(result);
  return result;
}

double gotLoadHelper_x9__swift_release(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_libswiftCore_dylib))
    return dlopenHelper_libswiftCore_dylib(result);
  return result;
}
