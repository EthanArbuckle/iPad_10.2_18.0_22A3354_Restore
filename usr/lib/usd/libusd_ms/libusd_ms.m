BOOL tbb::internal::hash_map_segment_base::internal_grow_predicate(tbb::internal::hash_map_segment_base *this)
{
  unint64_t v1;
  unint64_t v2;

  v1 = *((_QWORD *)this + 1);
  __dmb(0xBu);
  v2 = *((_QWORD *)this + 2);
  return v1 >= v2 && v2 >> 58 == 0;
}

uint64_t tbb::internal::micro_queue::push(uint64_t result, uint64_t a2, unint64_t a3, _QWORD *a4, int a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unsigned int *v14;
  int v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;

  v8 = result;
  v9 = a3 & 0xFFFFFFFFFFFFFFF8;
  v10 = (a4[3] - 1) & (a3 >> 3);
  if (v10)
  {
    v11 = 0;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *))(*a4 + 32))(a4);
    v11 = result;
    *(_QWORD *)result = 0;
    *(_QWORD *)(result + 8) = 0;
  }
  v13 = (unint64_t *)(v8 + 24);
  v12 = *(_QWORD *)(v8 + 24);
  __dmb(0xBu);
  if (v12 != v9)
  {
    while (1)
    {
      result = sched_yield();
      v17 = *v13;
      __dmb(0xBu);
      if (v17 == v9)
        break;
      if ((v17 & 1) != 0)
      {
        v18 = (unint64_t *)(a4[1] + 48);
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 + 1, v18));
        tbb::internal::throw_exception_v4(2);
      }
    }
  }
  if (v11)
  {
    v14 = (unsigned int *)((v8 + 32) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_7:
    v15 = *v14 & ~(255 << (8 * ((v8 + 32) & 3)));
    do
    {
      while (1)
      {
        v16 = __ldaxr(v14);
        if (v16 == v15)
          break;
        __clrex();
        if (*v14 != v15)
        {
          result = sched_yield();
          goto LABEL_7;
        }
      }
    }
    while (__stlxr(v15 | (1 << (8 * ((v8 + 32) & 3))), v14));
    v20 = *(uint64_t **)(v8 + 16);
    __dmb(0xBu);
    if (v20)
    {
      *v20 = v11;
    }
    else
    {
      __dmb(0xBu);
      *(_QWORD *)v8 = v11;
    }
    __dmb(0xBu);
    *(_QWORD *)(v8 + 16) = v11;
    __dmb(0xBu);
    *(_BYTE *)(v8 + 32) = 0;
  }
  if (a2)
  {
    v21 = *(_QWORD *)(v8 + 16);
    __dmb(0xBu);
    result = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*a4 + ((unint64_t)(a5 != 0) << 6)))(a4, v21, v10, a2);
    *(_QWORD *)(v21 + 8) |= 1 << v10;
  }
  else
  {
    v22 = (unint64_t *)(a4[1] + 48);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 + 1, v22));
  }
  do
    v24 = __ldaxr(v13);
  while (__stlxr(v24 + 8, v13));
  return result;
}

void sub_20BDC1198(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  __cxa_begin_catch(a1);
  v4 = (unint64_t *)(*(_QWORD *)(v1 + 8) + 48);
  do
    v5 = __ldaxr(v4);
  while (__stlxr(v5 + 1, v4));
  tbb::internal::micro_queue::make_invalid(v2, v3);
  __cxa_rethrow();
}

void sub_20BDC11C4()
{
  __break(1u);
}

void sub_20BDC1208()
{
  __cxa_end_catch();
  JUMPOUT(0x20BDC1210);
}

uint64_t tbb::internal::micro_queue::make_invalid(uint64_t this, uint64_t a2)
{
  uint64_t v3;
  unsigned int *v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  _QWORD *v9;

  v3 = this;
  qword_254784D60 = (uint64_t)&unk_25473B0D0;
  v4 = (unsigned int *)((this + 32) & 0xFFFFFFFFFFFFFFFCLL);
  v5 = 1 << (8 * ((this + 32) & 3));
  v6 = ~(255 << (8 * ((this + 32) & 3)));
LABEL_2:
  v7 = *v4 & v6;
  do
  {
    while (1)
    {
      v8 = __ldaxr(v4);
      if (v8 == v7)
        break;
      __clrex();
      if (*v4 != v7)
      {
        this = sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v7 | v5, v4));
  __dmb(0xBu);
  *(_QWORD *)(v3 + 24) = a2 + 9;
  v9 = *(_QWORD **)(v3 + 16);
  __dmb(0xBu);
  if (v9)
  {
    *v9 = &unk_25473B0D0;
  }
  else
  {
    __dmb(0xBu);
    *(_QWORD *)v3 = &unk_25473B0D0;
  }
  __dmb(0xBu);
  *(_QWORD *)(v3 + 16) = &unk_25473B0D0;
  __dmb(0xBu);
  *(_BYTE *)(v3 + 32) = 0;
  return this;
}

void sub_20BDC12F4(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

uint64_t tbb::internal::micro_queue::abort_push(tbb::internal::micro_queue *this, unint64_t a2, tbb::internal::concurrent_queue_base_v3 *a3)
{
  return tbb::internal::micro_queue::push((uint64_t)this, 0, a2, a3, 0);
}

BOOL tbb::internal::micro_queue::pop(tbb::internal::micro_queue *this, void *a2, unint64_t a3, tbb::internal::concurrent_queue_base_v3 *a4)
{
  unint64_t v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v19[4];

  v8 = a3 & 0xFFFFFFFFFFFFFFF8;
  for (i = *((_QWORD *)this + 1); ; i = *((_QWORD *)this + 1))
  {
    __dmb(0xBu);
    if (i == v8)
      break;
    sched_yield();
  }
  while (1)
  {
    v10 = *((_QWORD *)this + 3);
    __dmb(0xBu);
    if (v10 != v8)
      break;
    sched_yield();
  }
  v11 = *(_QWORD *)this;
  __dmb(0xBu);
  v12 = *((_QWORD *)a4 + 3) - 1;
  v13 = v12 & (a3 >> 3);
  if (v13 == v12)
    v14 = v11;
  else
    v14 = 0;
  v19[0] = v8 + 8;
  v19[1] = (uint64_t)this;
  v19[2] = v14;
  v19[3] = (uint64_t)a4;
  v15 = *(_QWORD *)(v11 + 8) & (1 << v13);
  if (v15)
  {
    (*(void (**)(tbb::internal::concurrent_queue_base_v3 *, void *))(*(_QWORD *)a4 + 8))(a4, a2);
  }
  else
  {
    v16 = (unint64_t *)(*((_QWORD *)a4 + 1) + 48);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
  }
  sub_20BDC2830(v19);
  return v15 != 0;
}

void sub_20BDC140C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_20BDC2830(&a9);
  _Unwind_Resume(a1);
}

_QWORD *tbb::internal::micro_queue::assign(_QWORD *a1, uint64_t *a2, _QWORD *a3, int a4)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t i;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v4 = a1;
  v5 = a2[1];
  __dmb(0xBu);
  a1[1] = v5;
  v6 = a2[3];
  __dmb(0xBu);
  a1[3] = v6;
  v7 = *a2;
  __dmb(0xBu);
  if (v7)
  {
    v11 = a1[1];
    __dmb(0xBu);
    v12 = a1[3];
    __dmb(0xBu);
    v13 = a1[1];
    __dmb(0xBu);
    v14 = a1[1];
    __dmb(0xBu);
    v15 = v12 - v13;
    v16 = a3[3];
    v17 = (v16 - 1) & (v14 >> 3);
    v18 = v17 + (v15 >> 3);
    if (v18 >= v16)
      v19 = a3[3];
    else
      v19 = v18;
    v20 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*a3 + 32))(a3);
    v21 = *(_QWORD *)(v7 + 8);
    *v20 = 0;
    v20[1] = v21;
    if (v17 != v19)
    {
      if (a4)
        v22 = 7;
      else
        v22 = 6;
      v23 = v11 + v19 - v17;
      do
      {
        if (((v20[1] >> v17) & 1) != 0)
          (*(void (**)(_QWORD *, _QWORD *, uint64_t, uint64_t, uint64_t))(*a3 + 8 * v22))(a3, v20, v17, v7, v17);
        ++v17;
        ++v11;
      }
      while (v19 != v17);
      v11 = v23;
      v4 = a1;
    }
    __dmb(0xBu);
    *v4 = v20;
    v24 = (_QWORD *)*v4;
    __dmb(0xBu);
    v25 = a2[2];
    __dmb(0xBu);
    if (v7 != v25)
    {
      v26 = *(_QWORD **)v7;
      v27 = (_QWORD *)a2[2];
      __dmb(0xBu);
      if (v26 == v27)
      {
        v31 = v24;
      }
      else
      {
        if (a4)
          v28 = 7;
        else
          v28 = 6;
        do
        {
          v30 = a3[3];
          v31 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*a3 + 32))(a3);
          v32 = v26[1];
          *v31 = 0;
          v31[1] = v32;
          if (v30)
          {
            for (i = 0; i != v30; ++i)
            {
              if (((v31[1] >> i) & 1) != 0)
                (*(void (**)(_QWORD *, _QWORD *, uint64_t, _QWORD *, uint64_t))(*a3 + 8 * v28))(a3, v31, i, v26, i);
            }
            v11 += v30;
          }
          *v24 = v31;
          v26 = (_QWORD *)*v26;
          v29 = (_QWORD *)a2[2];
          __dmb(0xBu);
          v24 = v31;
        }
        while (v26 != v29);
      }
      v4 = a1;
      v34 = a1[3];
      __dmb(0xBu);
      v35 = (a3[3] - 1) & (v34 >> 3);
      if (v35)
        v36 = v35;
      else
        v36 = a3[3];
      v24 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*a3 + 32))(a3);
      v37 = v26[1];
      *v24 = 0;
      v24[1] = v37;
      if (v36)
      {
        v38 = 0;
        if (a4)
          v39 = 7;
        else
          v39 = 6;
        do
        {
          if (((v24[1] >> v38) & 1) != 0)
            (*(void (**)(_QWORD *, _QWORD *, uint64_t, _QWORD *, uint64_t))(*a3 + 8 * v39))(a3, v24, v38, v26, v38);
          ++v38;
        }
        while (v36 != v38);
      }
      *v31 = v24;
    }
    __dmb(0xBu);
    v4[2] = v24;
  }
  else
  {
    __dmb(0xBu);
    a1[2] = 0;
    __dmb(0xBu);
    *a1 = 0;
  }
  return v4;
}

void sub_20BDC16E8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, tbb::internal::micro_queue *a10)
{
  uint64_t v10;

  __cxa_begin_catch(a1);
  tbb::internal::micro_queue::make_invalid((uint64_t)a10, v10);
  __cxa_rethrow();
}

void sub_20BDC171C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *tbb::internal::micro_queue::make_copy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, int a7)
{
  _QWORD *v13;
  uint64_t v14;
  uint64_t v16;

  v13 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  v14 = *(_QWORD *)(a3 + 8);
  *v13 = 0;
  v13[1] = v14;
  if (a4 != a5)
  {
    if (a7)
      v16 = 7;
    else
      v16 = 6;
    do
    {
      if (((v13[1] >> a4) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 8 * v16))(a2, v13, a4, a3, a4);
      ++a4;
      ++*a6;
    }
    while (a5 != a4);
  }
  return v13;
}

tbb::internal::concurrent_queue_base_v3 *tbb::internal::concurrent_queue_base_v3::concurrent_queue_base_v3(tbb::internal::concurrent_queue_base_v3 *this, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v6;
  unint64_t v7;
  void *v8;
  uint64_t v9;

  *(_QWORD *)this = &unk_24C515D28;
  if (a2 >= 9)
  {
    if (a2 >= 0x11)
    {
      if (a2 >= 0x21)
      {
        if (a2 >= 0x41)
        {
          v6 = 1;
          if (a2 < 0x81)
            v6 = 2;
        }
        else
        {
          v6 = 4;
        }
      }
      else
      {
        v6 = 8;
      }
    }
    else
    {
      v6 = 16;
    }
  }
  else
  {
    v6 = 32;
  }
  v7 = 2;
  if (a2 > 2)
    v7 = a2;
  *((_QWORD *)this + 2) = 0xFFFFFFFFFFFFFFFFLL / v7;
  *((_QWORD *)this + 3) = v6;
  v8 = (void *)tbb::internal::NFS_Allocate(1uLL, 584, 0, a4);
  *((_QWORD *)this + 1) = v8;
  bzero(v8, 0x248uLL);
  v9 = *((_QWORD *)this + 1);
  *(_BYTE *)(v9 + 9) = 0;
  *(_QWORD *)(v9 + 24) = v9 + 24;
  *(_QWORD *)(v9 + 32) = v9 + 24;
  *(_QWORD *)(v9 + 16) = 0;
  *(_DWORD *)(v9 + 40) = 0;
  *(_BYTE *)(v9 + 137) = 0;
  *(_QWORD *)(v9 + 152) = v9 + 152;
  *(_QWORD *)(v9 + 160) = v9 + 152;
  *(_QWORD *)(v9 + 144) = 0;
  *(_DWORD *)(v9 + 168) = 0;
  *((_QWORD *)this + 4) = a2;
  return this;
}

void tbb::internal::concurrent_queue_base_v3::~concurrent_queue_base_v3(tbb::internal **this, void *a2)
{
  *this = (tbb::internal *)&unk_24C515D28;
  tbb::internal::NFS_Free(this[1], a2);
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_push(tbb::internal::concurrent_queue_base_v3 *this, uint64_t a2)
{
  return tbb::internal::concurrent_queue_base_v3::internal_insert_item(this, a2, 0);
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_insert_item(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t *v6;
  int v7;
  unint64_t *v8;
  unint64_t v9;
  int64_t v10;
  uint64_t v11;
  uint64_t v12;
  int64_t v13;
  int v14;
  _QWORD v16[2];
  semaphore_t semaphore;
  int v18;
  char v19;
  __int16 v20;
  char v21;
  uint64_t v22;

  v6 = (uint64_t *)a1[1];
  v7 = *((_DWORD *)v6 + 144);
  __dmb(0xBu);
  v8 = (unint64_t *)(v6 + 16);
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 + 1, v8));
  v10 = a1[2];
  v11 = *v6;
  __dmb(0xBu);
  if ((uint64_t)(v9 - v11) >= v10)
  {
    v16[0] = 3452816845;
    v16[1] = 3452816845;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v18 = 0;
    __dmb(0xBu);
    v19 = 0;
    tbb::internal::concurrent_monitor::prepare_wait((uint64_t)(v6 + 17), (tbb::internal::concurrent_monitor::thread_context *)v16, v9 - v10);
    while (1)
    {
      v12 = *v6;
      __dmb(0xBu);
      v13 = a1[2];
      if ((uint64_t)(v9 - v12) < v13)
      {
        tbb::internal::concurrent_monitor::cancel_wait((uint64_t)(v6 + 17), (tbb::internal::concurrent_monitor::thread_context *)v16);
        goto LABEL_14;
      }
      v14 = *((_DWORD *)v6 + 144);
      __dmb(0xBu);
      if (v14 != v7)
      {
        tbb::internal::concurrent_monitor::cancel_wait((uint64_t)(v6 + 17), (tbb::internal::concurrent_monitor::thread_context *)v16);
        tbb::internal::throw_exception_v4(18);
      }
      if (v18 == *((_DWORD *)v6 + 42))
        break;
      tbb::internal::concurrent_monitor::cancel_wait((uint64_t)(v6 + 17), (tbb::internal::concurrent_monitor::thread_context *)v16);
      tbb::internal::concurrent_monitor::prepare_wait((uint64_t)(v6 + 17), (tbb::internal::concurrent_monitor::thread_context *)v16, v9 - v13);
    }
    while (MEMORY[0x212B93828](semaphore) == 14)
      ;
    if (HIBYTE(v20))
      tbb::internal::throw_exception_v4(18);
LABEL_14:
    if (v21)
    {
      if ((_BYTE)v20)
      {
        while (MEMORY[0x212B93828](semaphore) == 14)
          ;
      }
      semaphore_destroy(*MEMORY[0x24BDAEC58], semaphore);
    }
  }
  tbb::internal::micro_queue::push((uint64_t)&v6[5 * ((3 * v9) & 7) + 32], a2, v9, a1, a3);
  v16[0] = v9;
  __dmb(0xBu);
  return sub_20BDC292C((uint64_t)(v6 + 1), v16);
}

void sub_20BDC1AE0(void *a1, int a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;

  __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    tbb::internal::micro_queue::push(v4 + 40 * ((3 * (_BYTE)v3) & 7) + 256, 0, v3, v2, 0);
    __cxa_rethrow();
  }
  __cxa_rethrow();
}

void sub_20BDC1B44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  __cxa_end_catch();
  sub_20BDC1B74((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_20BDC1B50()
{
  __cxa_end_catch();
  JUMPOUT(0x20BDC1B58);
}

uint64_t tbb::internal::concurrent_queue_base_v8::internal_push_move(tbb::internal::concurrent_queue_base_v8 *this, uint64_t a2)
{
  return tbb::internal::concurrent_queue_base_v3::internal_insert_item(this, a2, 1);
}

uint64_t sub_20BDC1B74(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 27))
  {
    if (*(_BYTE *)(a1 + 25))
    {
      while (MEMORY[0x212B93828](*(unsigned int *)(a1 + 16)) == 14)
        ;
    }
    semaphore_destroy(*MEMORY[0x24BDAEC58], *(_DWORD *)(a1 + 16));
  }
  return a1;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_pop(tbb::internal::concurrent_queue_base_v3 *this, void *a2)
{
  uint64_t v4;
  int v5;
  task_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  _QWORD v12[2];
  semaphore_t semaphore;
  int v14;
  char v15;
  __int16 v16;
  char v17;
  uint64_t v18;

  v4 = *((_QWORD *)this + 1);
  v5 = *(_DWORD *)(v4 + 576);
  __dmb(0xBu);
  v6 = (task_t *)MEMORY[0x24BDAEC58];
  do
  {
    do
      v7 = __ldaxr((unint64_t *)v4);
    while (__stlxr(v7 + 1, (unint64_t *)v4));
    v8 = *(_QWORD *)(v4 + 128);
    __dmb(0xBu);
    if ((uint64_t)(v8 - v7) <= 0)
    {
      v12[0] = 3452816845;
      v12[1] = 3452816845;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v14 = 0;
      __dmb(0xBu);
      v15 = 0;
      tbb::internal::concurrent_monitor::prepare_wait(v4 + 8, (tbb::internal::concurrent_monitor::thread_context *)v12, v7);
      while (1)
      {
        v9 = *(_QWORD *)(v4 + 128);
        __dmb(0xBu);
        if ((uint64_t)(v9 - v7) > 0)
        {
          tbb::internal::concurrent_monitor::cancel_wait(v4 + 8, (tbb::internal::concurrent_monitor::thread_context *)v12);
          goto LABEL_16;
        }
        v10 = *(_DWORD *)(v4 + 576);
        __dmb(0xBu);
        if (v10 != v5)
        {
          tbb::internal::concurrent_monitor::cancel_wait(v4 + 8, (tbb::internal::concurrent_monitor::thread_context *)v12);
          tbb::internal::throw_exception_v4(18);
        }
        if (v14 == *(_DWORD *)(v4 + 40))
          break;
        tbb::internal::concurrent_monitor::cancel_wait(v4 + 8, (tbb::internal::concurrent_monitor::thread_context *)v12);
        tbb::internal::concurrent_monitor::prepare_wait(v4 + 8, (tbb::internal::concurrent_monitor::thread_context *)v12, v7);
      }
      while (MEMORY[0x212B93828](semaphore) == 14)
        ;
      if (HIBYTE(v16))
        tbb::internal::throw_exception_v4(18);
LABEL_16:
      if (v17)
      {
        if ((_BYTE)v16)
        {
          while (MEMORY[0x212B93828](semaphore) == 14)
            ;
        }
        semaphore_destroy(*v6, semaphore);
      }
    }
  }
  while (!tbb::internal::micro_queue::pop((tbb::internal::micro_queue *)(v4 + 40 * ((3 * (_BYTE)v7) & 7) + 256), a2, v7, this));
  v12[0] = v7;
  __dmb(0xBu);
  return sub_20BDC292C(v4 + 136, v12);
}

void sub_20BDC1D90(void *a1, int a2)
{
  unint64_t *v2;
  unint64_t v4;

  __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    do
      v4 = __ldaxr(v2);
    while (__stlxr(v4 - 1, v2));
    __cxa_rethrow();
  }
  __cxa_rethrow();
}

void sub_20BDC1DDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  __cxa_end_catch();
  sub_20BDC1B74((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_20BDC1DE8()
{
  __cxa_end_catch();
  JUMPOUT(0x20BDC1DF0);
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_abort(tbb::internal::concurrent_queue_base_v3 *this)
{
  uint64_t v1;
  unsigned int *v2;
  unsigned int v3;

  v1 = *((_QWORD *)this + 1);
  v2 = (unsigned int *)(v1 + 576);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 + 1, v2));
  __dmb(0xBu);
  tbb::internal::concurrent_monitor::abort_all_relaxed(v1 + 8);
  __dmb(0xBu);
  return tbb::internal::concurrent_monitor::abort_all_relaxed(v1 + 136);
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_pop_if_present(tbb::internal::concurrent_queue_base_v3 *this, void *a2)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v11;

  v4 = (unint64_t *)*((_QWORD *)this + 1);
  do
  {
    v5 = *v4;
    __dmb(0xBu);
    v6 = v4[16];
    __dmb(0xBu);
    if ((uint64_t)(v6 - v5) < 1)
      return 0;
    do
    {
      while (1)
      {
        v7 = __ldaxr(v4);
        if (v7 == v5)
          break;
        __clrex();
        do
          v8 = __ldxr(v4);
        while (__stxr(v8, v4));
        if (v8 != v5)
        {
          v9 = v4[16];
          __dmb(0xBu);
          v5 = v8;
          if ((uint64_t)(v9 - v8) < 1)
            return 0;
        }
      }
    }
    while (__stlxr(v5 + 1, v4));
  }
  while (!tbb::internal::micro_queue::pop((tbb::internal::micro_queue *)&v4[5 * ((3 * v5) & 7) + 32], a2, v5, this));
  v11 = v5;
  __dmb(0xBu);
  sub_20BDC292C((uint64_t)(v4 + 17), &v11);
  return 1;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_push_if_not_full(tbb::internal::concurrent_queue_base_v3 *this, uint64_t a2)
{
  _QWORD *v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v7;
  unint64_t v8;
  uint64_t result;
  uint64_t v10;
  unint64_t v11;

  v2 = (_QWORD *)*((_QWORD *)this + 1);
  v3 = v2 + 16;
  v4 = v2[16];
  __dmb(0xBu);
  v5 = *v2;
  __dmb(0xBu);
  if ((int64_t)(v4 - v5) >= *((_QWORD *)this + 2))
    return 0;
  do
  {
    while (1)
    {
      v7 = __ldaxr(v3);
      if (v7 == v4)
        break;
      __clrex();
      do
        v8 = __ldxr(v3);
      while (__stxr(v8, v3));
      if (v8 != v4)
      {
        result = 0;
        v10 = *v2;
        __dmb(0xBu);
        v4 = v8;
        if ((int64_t)(v8 - v10) >= *((_QWORD *)this + 2))
          return result;
      }
    }
  }
  while (__stlxr(v4 + 1, v3));
  tbb::internal::micro_queue::push((uint64_t)&v2[5 * ((3 * v4) & 7) + 32], a2, v4, this, 0);
  v11 = v4;
  __dmb(0xBu);
  sub_20BDC292C((uint64_t)(v2 + 1), &v11);
  return 1;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_insert_if_not_full(_QWORD *a1, uint64_t a2, int a3)
{
  _QWORD *v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v8;
  unint64_t v9;
  uint64_t result;
  uint64_t v11;
  unint64_t v12;

  v3 = (_QWORD *)a1[1];
  v4 = v3 + 16;
  v5 = v3[16];
  __dmb(0xBu);
  v6 = *v3;
  __dmb(0xBu);
  if ((int64_t)(v5 - v6) >= a1[2])
    return 0;
  do
  {
    while (1)
    {
      v8 = __ldaxr(v4);
      if (v8 == v5)
        break;
      __clrex();
      do
        v9 = __ldxr(v4);
      while (__stxr(v9, v4));
      if (v9 != v5)
      {
        result = 0;
        v11 = *v3;
        __dmb(0xBu);
        v5 = v9;
        if ((int64_t)(v9 - v11) >= a1[2])
          return result;
      }
    }
  }
  while (__stlxr(v5 + 1, v4));
  tbb::internal::micro_queue::push((uint64_t)&v3[5 * ((3 * v5) & 7) + 32], a2, v5, a1, a3);
  v12 = v5;
  __dmb(0xBu);
  sub_20BDC292C((uint64_t)(v3 + 1), &v12);
  return 1;
}

uint64_t tbb::internal::concurrent_queue_base_v8::internal_push_move_if_not_full(tbb::internal::concurrent_queue_base_v8 *this, uint64_t a2)
{
  _QWORD *v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v11;

  v2 = (_QWORD *)*((_QWORD *)this + 1);
  v3 = v2 + 16;
  v4 = v2[16];
  __dmb(0xBu);
  v5 = *v2;
  __dmb(0xBu);
  if ((int64_t)(v4 - v5) >= *((_QWORD *)this + 2))
    return 0;
  do
  {
    while (1)
    {
      v6 = __ldaxr(v3);
      if (v6 == v4)
        break;
      __clrex();
      do
        v7 = __ldxr(v3);
      while (__stxr(v7, v3));
      if (v7 != v4)
      {
        v8 = 0;
        v9 = *v2;
        __dmb(0xBu);
        v4 = v7;
        if ((int64_t)(v7 - v9) >= *((_QWORD *)this + 2))
          return v8;
      }
    }
  }
  while (__stlxr(v4 + 1, v3));
  v8 = 1;
  tbb::internal::micro_queue::push((uint64_t)&v2[5 * ((3 * v4) & 7) + 32], a2, v4, this, 1);
  v11 = v4;
  __dmb(0xBu);
  sub_20BDC292C((uint64_t)(v2 + 1), &v11);
  return v8;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_size(tbb::internal::concurrent_queue_base_v3 *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(*((_QWORD *)this + 1) + 128);
  __dmb(0xBu);
  v2 = **((_QWORD **)this + 1);
  __dmb(0xBu);
  v3 = *(_QWORD *)(*((_QWORD *)this + 1) + 48);
  __dmb(0xBu);
  return v1 - (v2 + v3);
}

BOOL tbb::internal::concurrent_queue_base_v3::internal_empty(tbb::internal::concurrent_queue_base_v3 *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *(_QWORD *)(*((_QWORD *)this + 1) + 128);
  __dmb(0xBu);
  v2 = **((_QWORD **)this + 1);
  __dmb(0xBu);
  v3 = *(_QWORD *)(*((_QWORD *)this + 1) + 128);
  __dmb(0xBu);
  if (v1 != v3)
    return 0;
  v4 = *(_QWORD *)(*((_QWORD *)this + 1) + 48);
  __dmb(0xBu);
  return v1 - (v2 + v4) < 1;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_set_capacity(uint64_t this, unint64_t a2)
{
  uint64_t v2;

  v2 = 0x7FFFFFFFFFFFFFFFLL;
  if (a2 < 0x7FFFFFFFFFFFFFFFLL)
    v2 = a2;
  *(_QWORD *)(this + 16) = v2;
  return this;
}

_QWORD *tbb::internal::concurrent_queue_base_v3::internal_finish_clear(_QWORD *this)
{
  _QWORD *v1;
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v1 = this;
  for (i = 272; i != 592; i += 40)
  {
    v4 = *(_QWORD *)(v1[1] + i);
    __dmb(0xBu);
    if (v4)
    {
      if (qword_254784D60 != v4)
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v1 + 40))(v1);
      v3 = v1[1];
      __dmb(0xBu);
      *(_QWORD *)(v3 + i) = 0;
    }
  }
  return this;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_throw_exception(tbb::internal::concurrent_queue_base_v3 *this)
{
  return tbb::internal::throw_exception_v4(1);
}

_QWORD *tbb::internal::concurrent_queue_base_v3::internal_assign(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  v6 = *(_QWORD **)(a1 + 8);
  v7 = **(_QWORD **)(a2 + 8);
  __dmb(0xBu);
  *v6 = v7;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 128);
  __dmb(0xBu);
  *(_QWORD *)(v8 + 128) = v9;
  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 48);
  __dmb(0xBu);
  *(_QWORD *)(v10 + 48) = v11;
  v12 = *(_QWORD *)(a1 + 8);
  LODWORD(v11) = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 576);
  __dmb(0xBu);
  *(_DWORD *)(v12 + 576) = v11;
  tbb::internal::micro_queue::assign((_QWORD *)(*(_QWORD *)(a1 + 8) + 256), (uint64_t *)(*(_QWORD *)(a2 + 8) + 256), (_QWORD *)a1, a3);
  tbb::internal::micro_queue::assign((_QWORD *)(*(_QWORD *)(a1 + 8) + 296), (uint64_t *)(*(_QWORD *)(a2 + 8) + 296), (_QWORD *)a1, a3);
  tbb::internal::micro_queue::assign((_QWORD *)(*(_QWORD *)(a1 + 8) + 336), (uint64_t *)(*(_QWORD *)(a2 + 8) + 336), (_QWORD *)a1, a3);
  tbb::internal::micro_queue::assign((_QWORD *)(*(_QWORD *)(a1 + 8) + 376), (uint64_t *)(*(_QWORD *)(a2 + 8) + 376), (_QWORD *)a1, a3);
  tbb::internal::micro_queue::assign((_QWORD *)(*(_QWORD *)(a1 + 8) + 416), (uint64_t *)(*(_QWORD *)(a2 + 8) + 416), (_QWORD *)a1, a3);
  tbb::internal::micro_queue::assign((_QWORD *)(*(_QWORD *)(a1 + 8) + 456), (uint64_t *)(*(_QWORD *)(a2 + 8) + 456), (_QWORD *)a1, a3);
  tbb::internal::micro_queue::assign((_QWORD *)(*(_QWORD *)(a1 + 8) + 496), (uint64_t *)(*(_QWORD *)(a2 + 8) + 496), (_QWORD *)a1, a3);
  return tbb::internal::micro_queue::assign((_QWORD *)(*(_QWORD *)(a1 + 8) + 536), (uint64_t *)(*(_QWORD *)(a2 + 8) + 536), (_QWORD *)a1, a3);
}

_QWORD *tbb::internal::concurrent_queue_base_v3::assign(tbb::internal::concurrent_queue_base_v3 *this, const tbb::internal::concurrent_queue_base_v3 *a2)
{
  return tbb::internal::concurrent_queue_base_v3::internal_assign((uint64_t)this, (uint64_t)a2, 0);
}

_QWORD *tbb::internal::concurrent_queue_base_v8::move_content(uint64_t a1, uint64_t a2)
{
  return tbb::internal::concurrent_queue_base_v3::internal_assign(a1, a2, 1);
}

unint64_t *tbb::internal::concurrent_queue_iterator_base_v3::initialize(unint64_t **this, const tbb::internal::concurrent_queue_base_v3 *a2, unint64_t a3, void *a4)
{
  unint64_t *result;
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;

  result = (unint64_t *)tbb::internal::NFS_Allocate(1uLL, 88, 0, a4);
  *this = result;
  v8 = **((_QWORD **)a2 + 1);
  __dmb(0xBu);
  *result = v8;
  result[1] = (unint64_t)a2;
  result[2] = a3;
  v9 = (_QWORD *)*((_QWORD *)a2 + 1);
  v10 = v9[32];
  __dmb(0xBu);
  result[3] = v10;
  v11 = v9[37];
  __dmb(0xBu);
  result[4] = v11;
  v12 = v9[42];
  __dmb(0xBu);
  result[5] = v12;
  v13 = v9[47];
  __dmb(0xBu);
  result[6] = v13;
  v14 = v9[52];
  __dmb(0xBu);
  result[7] = v14;
  v15 = v9[57];
  __dmb(0xBu);
  result[8] = v15;
  v16 = v9[62];
  __dmb(0xBu);
  result[9] = v16;
  v17 = v9[67];
  __dmb(0xBu);
  result[10] = v17;
  v18 = *this;
  v19 = **this;
  v20 = *(_QWORD *)(*(_QWORD *)((*this)[1] + 8) + 128);
  __dmb(0xBu);
  if (v20 == v19)
  {
LABEL_2:
    this[1] = 0;
    return result;
  }
  v21 = v18[((3 * v19) & 7) + 3];
  v22 = v18[1];
  v23 = (*(_QWORD *)(v22 + 24) - 1) & (v19 >> 3);
  v24 = v21 + v18[2] + *(_QWORD *)(v22 + 32) * v23;
  v25 = *(_QWORD *)(v21 + 8);
  this[1] = (unint64_t *)v24;
  if (((v25 >> v23) & 1) == 0)
  {
    while (1)
    {
      v31 = *this;
      v32 = **this;
      v33 = (*this)[1];
      if (((*(_QWORD *)(v33 + 24) - 1) & ~(v32 >> 3)) == 0)
      {
        v34 = &v31[(3 * (_BYTE)v32) & 7];
        v34[3] = *(_QWORD *)v34[3];
        v31 = *this;
        v33 = (*this)[1];
      }
      v35 = v32 + 1;
      *v31 = v35;
      v36 = *(_QWORD *)(*(_QWORD *)(v33 + 8) + 128);
      __dmb(0xBu);
      if (v36 == v35)
        break;
      v26 = v31[((3 * v35) & 7) + 3];
      v27 = v31[1];
      v28 = (*(_QWORD *)(v27 + 24) - 1) & (v35 >> 3);
      v29 = v26 + v31[2] + *(_QWORD *)(v27 + 32) * v28;
      v30 = *(_QWORD *)(v26 + 8);
      this[1] = (unint64_t *)v29;
      if (((v30 >> v28) & 1) != 0)
        return result;
    }
    goto LABEL_2;
  }
  return result;
}

unint64_t **tbb::internal::concurrent_queue_iterator_base_v3::advance(unint64_t **this)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;

  while (1)
  {
    v1 = *this;
    v2 = **this;
    v3 = (*this)[1];
    if (((*(_QWORD *)(v3 + 24) - 1) & ~(v2 >> 3)) == 0)
    {
      v4 = &v1[(3 * (_BYTE)v2) & 7];
      v4[3] = *(_QWORD *)v4[3];
      v1 = *this;
      v3 = (*this)[1];
    }
    v5 = v2 + 1;
    *v1 = v5;
    v6 = *(_QWORD *)(*(_QWORD *)(v3 + 8) + 128);
    __dmb(0xBu);
    if (v6 == v5)
      break;
    v7 = v1[((3 * v5) & 7) + 3];
    v8 = v1[1];
    v9 = (*(_QWORD *)(v8 + 24) - 1) & (v5 >> 3);
    v10 = v7 + v1[2] + *(_QWORD *)(v8 + 32) * v9;
    v11 = *(_QWORD *)(v7 + 8);
    this[1] = (unint64_t *)v10;
    if (((v11 >> v9) & 1) != 0)
      return this;
  }
  this[1] = 0;
  return this;
}

unint64_t **tbb::internal::concurrent_queue_iterator_base_v3::concurrent_queue_iterator_base_v3(unint64_t **this, const tbb::internal::concurrent_queue_base_v3 *a2, uint64_t a3, void *a4)
{
  tbb::internal::concurrent_queue_iterator_base_v3::initialize(this, a2, 0, a4);
  return this;
}

{
  tbb::internal::concurrent_queue_iterator_base_v3::initialize(this, a2, 0, a4);
  return this;
}

unint64_t **tbb::internal::concurrent_queue_iterator_base_v3::concurrent_queue_iterator_base_v3(unint64_t **this, const tbb::internal::concurrent_queue_base_v3 *a2, unint64_t a3, void *a4)
{
  tbb::internal::concurrent_queue_iterator_base_v3::initialize(this, a2, a3, a4);
  return this;
}

{
  tbb::internal::concurrent_queue_iterator_base_v3::initialize(this, a2, a3, a4);
  return this;
}

uint64_t tbb::internal::concurrent_queue_iterator_base_v3::assign(tbb::internal::concurrent_queue_iterator_base_v3 *this, const tbb::internal::concurrent_queue_iterator_base_v3 *a2, uint64_t a3, void *a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  result = *(_QWORD *)this;
  v7 = *(_QWORD *)a2;
  if (result != *(_QWORD *)a2)
  {
    if (result)
    {
      result = tbb::internal::NFS_Free((tbb::internal *)result, a2);
      *(_QWORD *)this = 0;
      v7 = *(_QWORD *)a2;
    }
    if (v7)
    {
      result = tbb::internal::NFS_Allocate(1uLL, 88, 0, a4);
      *(_QWORD *)this = result;
      v8 = *(_QWORD *)a2;
      v9 = *(_OWORD *)(*(_QWORD *)a2 + 16);
      *(_OWORD *)result = *(_OWORD *)*(_QWORD *)a2;
      *(_OWORD *)(result + 16) = v9;
      v10 = *(_OWORD *)(v8 + 32);
      v11 = *(_OWORD *)(v8 + 48);
      v12 = *(_OWORD *)(v8 + 64);
      *(_QWORD *)(result + 80) = *(_QWORD *)(v8 + 80);
      *(_OWORD *)(result + 48) = v11;
      *(_OWORD *)(result + 64) = v12;
      *(_OWORD *)(result + 32) = v10;
    }
  }
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  return result;
}

void tbb::internal::concurrent_queue_iterator_base_v3::~concurrent_queue_iterator_base_v3(tbb::internal **this, void *a2)
{
  tbb::internal::NFS_Free(*this, a2);
  *this = 0;
}

{
  tbb::internal::NFS_Free(*this, a2);
  *this = 0;
}

uint64_t *sub_20BDC2830(uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;
  unsigned int *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = (uint64_t *)a1[2];
  if (v2)
  {
    v3 = a1[1] + 32;
    v4 = (unsigned int *)(v3 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_3:
    v5 = *v4 & ~(255 << (8 * (v3 & 3)));
    do
    {
      while (1)
      {
        v6 = __ldaxr(v4);
        if (v6 == v5)
          break;
        __clrex();
        if (*v4 != v5)
        {
          sched_yield();
          goto LABEL_3;
        }
      }
    }
    while (__stlxr(v5 | (1 << (8 * (v3 & 3))), v4));
    v7 = *v2;
    v8 = (_QWORD *)a1[1];
    __dmb(0xBu);
    *v8 = v7;
    if (!v7)
    {
      v9 = a1[1];
      __dmb(0xBu);
      *(_QWORD *)(v9 + 16) = 0;
    }
    __dmb(0xBu);
    *(_BYTE *)v3 = 0;
    v10 = *a1;
    v11 = a1[1];
    __dmb(0xBu);
    *(_QWORD *)(v11 + 8) = v10;
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)a1[3] + 40))(a1[3], v2);
  }
  else
  {
    v12 = *a1;
    v13 = a1[1];
    __dmb(0xBu);
    *(_QWORD *)(v13 + 8) = v12;
  }
  return a1;
}

uint64_t sub_20BDC292C(uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  _BYTE *v4;
  unsigned int *v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;

  if (*(_QWORD *)(result + 8))
  {
    v3 = result;
    v16 = &v16;
    v17 = &v16;
    v15 = 0;
    v4 = (_BYTE *)(result + 1);
    v5 = (unsigned int *)((result + 1) & 0xFFFFFFFFFFFFFFFCLL);
    v6 = 1 << (8 * ((result + 1) & 3));
    v7 = ~(255 << (8 * ((result + 1) & 3)));
LABEL_3:
    v8 = *v5 & v7;
    do
    {
      while (1)
      {
        v9 = __ldaxr(v5);
        if (v9 == v8)
          break;
        __clrex();
        if (*v5 != v8)
        {
          result = sched_yield();
          goto LABEL_3;
        }
      }
    }
    while (__stlxr(v8 | v6, v5));
    ++*(_DWORD *)(v3 + 32);
    v10 = *(_QWORD **)(v3 + 24);
    if (v10 != (_QWORD *)(v3 + 16))
    {
      do
      {
        v13 = (_QWORD *)v10[1];
        if (*a2 >= v10[4])
        {
          --*(_QWORD *)(v3 + 8);
          *v13 = *v10;
          *(_QWORD *)(*v10 + 8) = v13;
          __dmb(0xBu);
          *((_BYTE *)v10 + 24) = 0;
          ++v15;
          v14 = v17;
          *v10 = &v16;
          v10[1] = v14;
          *v17 = v10;
          v17 = v10;
        }
        v10 = v13;
      }
      while (v13 != (_QWORD *)(v3 + 16));
    }
    __dmb(0xBu);
    *v4 = 0;
    v11 = v16;
    if (v16 != &v16)
    {
      do
      {
        v12 = (_QWORD *)*v11;
        result = MEMORY[0x212B9381C](*((unsigned int *)v11 + 4));
        v11 = v12;
      }
      while (v12 != &v16);
    }
  }
  return result;
}

unint64_t tbb::internal::concurrent_vector_base_v3::helper::extend_segment_table(unint64_t this, tbb::internal::concurrent_vector_base_v3 *a2, unint64_t a3, void *a4)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  uint64_t i;
  unint64_t v18;
  unint64_t v19;

  v4 = (_QWORD *)this;
  if ((unint64_t)a2 >= 8)
    v5 = 8;
  else
    v5 = (unint64_t)a2;
  v6 = (unint64_t *)(this + 24);
  if (v5)
  {
    v7 = 0;
    v8 = this + 32;
    do
    {
      v9 = *v6;
      __dmb(0xBu);
      if (v8 != v9)
        break;
      v10 = &v4[v7];
      v12 = v10[4];
      v11 = v10 + 4;
      if (!v12)
      {
        do
        {
          this = sched_yield();
          v13 = *v6;
          __dmb(0xBu);
        }
        while (v8 == v13 && !*v11);
      }
      ++v7;
    }
    while (((1 << v7) & 0xFFFFFFFFFFFFFFFELL) < v5);
  }
  v14 = (_QWORD *)v4[3];
  __dmb(0xBu);
  v15 = v4 + 4;
  if (v4 + 4 == v14)
  {
    this = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
    for (i = 0; i != 512; i += 8)
      *(_QWORD *)(this + i) = 0;
    *(_QWORD *)this = v4[4];
    *(_QWORD *)(this + 8) = v4[5];
    *(_QWORD *)(this + 16) = v4[6];
    do
    {
      while (1)
      {
        v18 = __ldaxr(v6);
        if ((_QWORD *)v18 != v15)
          break;
        if (!__stlxr(this, v6))
          return this;
      }
      __clrex();
      do
        v19 = __ldxr(v6);
      while (__stxr(v19, v6));
    }
    while ((_QWORD *)v19 == v15);
    return tbb::internal::NFS_Free((tbb::internal *)this, v16);
  }
  return this;
}

uint64_t tbb::internal::concurrent_vector_base_v3::helper::enable_segment(tbb::internal::concurrent_vector_base_v3::helper *this, unint64_t a2, uint64_t a3)
{
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;

  v6 = (unint64_t *)*((_QWORD *)this + 3);
  __dmb(0xBu);
  v7 = 1 << a2;
  v9 = (unint64_t *)((char *)this + 8);
  v8 = *((_QWORD *)this + 1);
  __dmb(0xBu);
  if (!a2)
  {
    if (!v8)
    {
      do
      {
        while (!__ldaxr(v9))
        {
          if (!__stlxr(1uLL, v9))
            goto LABEL_14;
        }
        __clrex();
        do
          v14 = __ldxr(v9);
        while (__stxr(v14, v9));
      }
      while (!v14);
    }
LABEL_14:
    v15 = *v9;
    __dmb(0xBu);
    v10 = 1 << v15;
    v11 = 2;
    goto LABEL_24;
  }
  if (v8)
  {
    v10 = 1 << a2;
    v11 = v7;
  }
  else
  {
    do
    {
      sched_yield();
      v12 = *v9;
      __dmb(0xBu);
    }
    while (!v12);
    v11 = v7;
    v10 = v7;
    if (!a2)
      goto LABEL_24;
  }
  v16 = *v9;
  __dmb(0xBu);
  if (v16 > a2)
  {
    v17 = *v6;
    __dmb(0xBu);
    if (!v17)
    {
      while (!*v6)
        sched_yield();
      v17 = *v6;
      __dmb(0xBu);
    }
    v18 = (uint64_t *)&v6[a2];
    if (v17 <= 0x3F)
      tbb::internal::throw_exception_v4(2);
    v19 = v17 + (v7 & 0xFFFFFFFFFFFFFFFELL) * a3;
    goto LABEL_26;
  }
LABEL_24:
  v18 = (uint64_t *)&v6[a2];
  v19 = (*(uint64_t (**)(tbb::internal::concurrent_vector_base_v3::helper *, uint64_t))this)(this, v10);
  if (!v19)
    tbb::internal::throw_exception_v4(1);
LABEL_26:
  __dmb(0xBu);
  *v18 = v19;
  return v11;
}

void sub_20BDC2D58(_Unwind_Exception *a1)
{
  _QWORD *v1;

  __dmb(0xBu);
  *v1 = 63;
  _Unwind_Resume(a1);
}

void tbb::internal::concurrent_vector_base_v3::helper::cleanup(tbb::internal::concurrent_vector_base_v3::helper *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  BOOL v18;
  _BOOL4 v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;

  v2 = *((_QWORD *)this + 3);
  if (v2)
    goto LABEL_61;
  v3 = *((_QWORD *)this + 2);
  v4 = *((_QWORD *)this + 5) - 1;
  v5 = v4 | 1;
  v6 = HIDWORD(v4);
  v7 = v6 != 0;
  if (!v6)
    v6 = v5;
  v8 = 32 * v7;
  if (v6 >= 0x10000)
  {
    v6 >>= 16;
    v8 = (32 * v7) | 0x10;
  }
  if (v6 >= 0x100)
  {
    v6 >>= 8;
    v8 |= 8uLL;
  }
  if (v6 >= 0x10)
  {
    v6 >>= 4;
    v8 |= 4uLL;
  }
  if (v6 < 4)
  {
    v9 = v8;
  }
  else
  {
    v6 >>= 2;
    v9 = v8 + 2;
  }
  v10 = (v6 >> 1) & 1;
  if (((1 << v3) & 0xFFFFFFFFFFFFFFFELL) < *((_QWORD *)this + 4))
  {
    v11 = *(_QWORD *)this;
    v12 = *(_QWORD *)(*(_QWORD *)this + 8 * v3);
    __dmb(0xBu);
    if (!v12)
    {
      while (!*(_QWORD *)(v11 + 8 * v3))
        sched_yield();
    }
    ++v3;
  }
  v13 = v10 + v9;
  v14 = *((_QWORD *)this + 1);
  if (v3 < v14)
  {
    v15 = *(unint64_t **)this;
    if (*((_QWORD *)this + 4))
    {
      v16 = *v15;
      __dmb(0xBu);
      if (!v16)
      {
        while (!*v15)
          sched_yield();
      }
    }
    v17 = *v15;
    if (v3)
      v18 = 1;
    else
      v18 = v17 == 0;
    if (!v18)
      ++v3;
    v14 = *((_QWORD *)this + 1);
    v20 = v3 < v14 && v3 <= v13;
    if (v17 <= 0x3F)
    {
      if (v20)
      {
        do
        {
          v25 = v3;
          v26 = *(_QWORD *)this;
          __dmb(0xBu);
          *(_QWORD *)(v26 + 8 * v3++) = 63;
          v14 = *((_QWORD *)this + 1);
        }
        while (v3 < v14 && v25 < v13);
      }
    }
    else if (v20)
    {
      do
      {
        v21 = v3;
        v22 = *(_QWORD *)this;
        v23 = v17 + *((_QWORD *)this + 6) * ((1 << v3) & 0xFFFFFFFFFFFFFFFELL);
        __dmb(0xBu);
        *(_QWORD *)(v22 + 8 * v3++) = v23;
        v14 = *((_QWORD *)this + 1);
      }
      while (v3 < v14 && v21 < v13);
    }
  }
  if (v3 <= v13)
  {
    do
    {
      v28 = *(_QWORD *)(*(_QWORD *)this + 8 * v3);
      __dmb(0xBu);
      if (!v28)
      {
        v29 = *(_QWORD *)this;
        __dmb(0xBu);
        *(_QWORD *)(v29 + 8 * v3) = 63;
      }
      ++v3;
    }
    while (v3 <= v13);
    v14 = *((_QWORD *)this + 1);
  }
  v30 = *((_QWORD *)this + 2);
  if (v30 < v14)
  {
    v30 = 0;
    *((_QWORD *)this + 2) = 0;
  }
  v31 = (1 << v30) & 0xFFFFFFFFFFFFFFFELL;
  v32 = *((_QWORD *)this + 5) - v31;
  v33 = *((_QWORD *)this + 4) - v31;
  v2 = 1 << v14;
  if (v30)
    v2 = (1 << v30) & 0xFFFFFFFFFFFFFFFELL;
  *((_QWORD *)this + 4) = v33;
  *((_QWORD *)this + 5) = v32;
  *((_QWORD *)this + 3) = v2;
  while (1)
  {
    v36 = *(_QWORD *)(*(_QWORD *)this + 8 * v30);
    if (v36 >= 0x40)
    {
      if (v2 >= v32)
        v2 = v32;
      bzero((void *)(v36 + v33 * *((_QWORD *)this + 6)), (v2 - v33) * *((_QWORD *)this + 6));
      v2 = *((_QWORD *)this + 3);
    }
LABEL_61:
    v34 = *((_QWORD *)this + 5);
    v32 = v34 - v2;
    if (v34 < v2)
      break;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 5) = v32;
    v35 = *((_QWORD *)this + 2);
    if (v35)
    {
      v30 = v35 + 1;
      v2 = 1 << v30;
      *((_QWORD *)this + 3) = 1 << v30;
    }
    else
    {
      v30 = *((_QWORD *)this + 1);
    }
    v33 = 0;
    *((_QWORD *)this + 2) = v30;
  }
}

void tbb::internal::concurrent_vector_base_v3::~concurrent_vector_base_v3(tbb::internal::concurrent_vector_base_v3 *this, void *a2)
{
  tbb::internal *v3;

  v3 = (tbb::internal *)*((_QWORD *)this + 3);
  __dmb(0xBu);
  if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) != v3)
  {
    __dmb(0xBu);
    *((_QWORD *)this + 3) = (char *)this + 32;
    tbb::internal::NFS_Free(v3, a2);
  }
}

{
  tbb::internal *v3;

  v3 = (tbb::internal *)*((_QWORD *)this + 3);
  __dmb(0xBu);
  if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) != v3)
  {
    __dmb(0xBu);
    *((_QWORD *)this + 3) = (char *)this + 32;
    tbb::internal::NFS_Free(v3, a2);
  }
}

unint64_t tbb::internal::concurrent_vector_base_v3::internal_capacity(tbb::internal::concurrent_vector_base_v3 *this)
{
  uint64_t v1;
  tbb::internal::concurrent_vector_base_v3 *v2;
  uint64_t v3;

  v1 = 0;
  v2 = (tbb::internal::concurrent_vector_base_v3 *)*((_QWORD *)this + 3);
  __dmb(0xBu);
  v3 = 64;
  if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) == v2)
    v3 = 3;
  while (*((_QWORD *)v2 + v1) >= 0x40uLL)
  {
    if (v3 == ++v1)
    {
      LOBYTE(v1) = v3;
      return (1 << v1) & 0xFFFFFFFFFFFFFFFELL;
    }
  }
  return (1 << v1) & 0xFFFFFFFFFFFFFFFELL;
}

uint64_t tbb::internal::concurrent_vector_base_v3::internal_throw_exception(tbb::internal::concurrent_vector_base_v3 *this, uint64_t a2)
{
  return tbb::internal::throw_exception_v4(dword_20CA4DBAC[a2]);
}

unint64_t *tbb::internal::concurrent_vector_base_v3::internal_reserve(unint64_t *this, unint64_t a2, uint64_t a3, void *a4)
{
  unint64_t *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  _BOOL4 v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t *v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;
  uint64_t i;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;

  v6 = this;
  if (a2 > (unint64_t)a4)
    this = (unint64_t *)tbb::internal::throw_exception_v4(16);
  v7 = v6 + 1;
  v8 = v6[1];
  __dmb(0xBu);
  if (!v8)
  {
    v9 = (a2 - 1) >> 32;
    v10 = v9 != 0;
    if (!v9)
      v9 = (a2 - 1) | 1;
    if (v9 < 0x10000)
    {
      v11 = 32 * v10;
    }
    else
    {
      v9 >>= 16;
      v11 = (32 * v10) | 0x10;
    }
    if (v9 >= 0x100)
    {
      v9 >>= 8;
      v11 |= 8uLL;
    }
    if (v9 >= 0x10)
    {
      v9 >>= 4;
      v11 |= 4uLL;
    }
    v12 = v9 >= 4;
    if (v9 >= 4)
      v9 >>= 2;
    v13 = (v9 >> 1) & 1;
    v14 = v11 + 2;
    if (!v12)
      v14 = v11;
    v15 = v14 + v13 + 1;
    do
    {
      while (!__ldaxr(v7))
      {
        if (!__stlxr(v15, v7))
          goto LABEL_23;
      }
      __clrex();
      do
        v17 = __ldxr(v7);
      while (__stxr(v17, v7));
    }
    while (!v17);
  }
LABEL_23:
  v18 = 0;
  v20 = v6 + 3;
  v19 = (unint64_t *)v6[3];
  __dmb(0xBu);
  v21 = v6 + 4;
  v22 = 64;
  if (v6 + 4 == v19)
    v22 = 3;
  while (v19[v18] >= 0x40)
  {
    if (v22 == ++v18)
    {
      v18 = v22;
      break;
    }
  }
  while (((1 << v18) & 0xFFFFFFFFFFFFFFFELL) < a2)
  {
    if (v18 >= 3)
    {
      v23 = *v20;
      __dmb(0xBu);
      if (v21 == (_QWORD *)v23)
      {
        v24 = *v20;
        __dmb(0xBu);
        if (v21 == (_QWORD *)v24)
        {
          this = (unint64_t *)tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
          for (i = 0; i != 64; ++i)
            this[i] = 0;
          *this = v6[4];
          this[1] = v6[5];
          this[2] = v6[6];
          do
          {
            while (1)
            {
              v27 = __ldaxr(v20);
              if ((_QWORD *)v27 != v21)
                break;
              if (!__stlxr((unint64_t)this, v20))
                goto LABEL_43;
            }
            __clrex();
            do
              v28 = __ldxr(v20);
            while (__stxr(v28, v20));
          }
          while ((_QWORD *)v28 == v21);
          this = (unint64_t *)tbb::internal::NFS_Free((tbb::internal *)this, v25);
        }
      }
    }
LABEL_43:
    v29 = *v20;
    __dmb(0xBu);
    if (*(_QWORD *)(v29 + 8 * v18) <= 0x3FuLL)
      this = (unint64_t *)tbb::internal::concurrent_vector_base_v3::helper::enable_segment((tbb::internal::concurrent_vector_base_v3::helper *)v6, v18, a3);
    ++v18;
  }
  return this;
}

unint64_t *tbb::internal::concurrent_vector_base_v3::internal_copy(unint64_t *this, const tbb::internal::concurrent_vector_base_v3 *a2, uint64_t a3, void (*a4)(void *, const void *, unint64_t))
{
  unint64_t v4;
  tbb::internal::concurrent_vector_base_v3::helper *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  _BOOL4 v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  tbb::internal *v34;
  void *v35;
  uint64_t i;
  unint64_t v37;
  unint64_t v38;

  v4 = *((_QWORD *)a2 + 2);
  __dmb(0xBu);
  if (v4)
  {
    v8 = (tbb::internal::concurrent_vector_base_v3::helper *)this;
    v9 = this + 1;
    v10 = this[1];
    __dmb(0xBu);
    if (!v10)
    {
      v11 = (v4 - 1) >> 32;
      v12 = v11 != 0;
      if (!v11)
        v11 = (v4 - 1) | 1;
      if (v11 < 0x10000)
      {
        v13 = 32 * v12;
      }
      else
      {
        v11 >>= 16;
        v13 = (32 * v12) | 0x10;
      }
      if (v11 >= 0x100)
      {
        v11 >>= 8;
        v13 |= 8uLL;
      }
      if (v11 >= 0x10)
      {
        v11 >>= 4;
        v13 |= 4uLL;
      }
      v14 = v11 >= 4;
      if (v11 >= 4)
        v11 >>= 2;
      v15 = (v11 >> 1) & 1;
      v16 = v13 + 2;
      if (!v14)
        v16 = v13;
      v17 = v16 + v15 + 1;
      do
      {
        while (!__ldaxr(v9))
        {
          if (!__stlxr(v17, v9))
            goto LABEL_22;
        }
        __clrex();
        do
          v19 = __ldxr(v9);
        while (__stxr(v19, v9));
      }
      while (!v19);
    }
LABEL_22:
    v20 = 0;
    v21 = 0;
    v22 = (char *)a2 + 32;
    v23 = this + 3;
    v24 = this + 4;
    while (1)
    {
      v30 = (char *)*((_QWORD *)a2 + 3);
      __dmb(0xBu);
      if (v21 >= 3 && v22 == v30)
        break;
      v31 = *((_QWORD *)a2 + 3);
      __dmb(0xBu);
      if (*(_QWORD *)(v31 + 8 * v21) <= 0x3FuLL)
        break;
      if (v21 >= 3)
      {
        v32 = *v23;
        __dmb(0xBu);
        if (v24 == (_QWORD *)v32)
        {
          v33 = *v23;
          __dmb(0xBu);
          if (v24 == (_QWORD *)v33)
          {
            v34 = (tbb::internal *)tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
            for (i = 0; i != 512; i += 8)
              *(_QWORD *)((char *)v34 + i) = 0;
            *(_QWORD *)v34 = *((_QWORD *)v8 + 4);
            *((_QWORD *)v34 + 1) = *((_QWORD *)v8 + 5);
            *((_QWORD *)v34 + 2) = *((_QWORD *)v8 + 6);
            do
            {
              while (1)
              {
                v37 = __ldaxr(v23);
                if ((_QWORD *)v37 != v24)
                  break;
                if (!__stlxr((unint64_t)v34, v23))
                  goto LABEL_23;
              }
              __clrex();
              do
                v38 = __ldxr(v23);
              while (__stxr(v38, v23));
            }
            while ((_QWORD *)v38 == v24);
            tbb::internal::NFS_Free(v34, v35);
          }
        }
      }
LABEL_23:
      v25 = tbb::internal::concurrent_vector_base_v3::helper::enable_segment(v8, v21, a3);
      if (v25 >= v4 - v20)
        v26 = v4 - v20;
      else
        v26 = v25;
      __dmb(0xBu);
      *((_QWORD *)v8 + 2) = v26 + v20;
      v27 = *((_QWORD *)v8 + 3);
      __dmb(0xBu);
      v28 = *(_QWORD *)(v27 + 8 * v21);
      v29 = *((_QWORD *)a2 + 3);
      __dmb(0xBu);
      this = (unint64_t *)((uint64_t (*)(uint64_t, _QWORD))a4)(v28, *(_QWORD *)(v29 + 8 * v21++));
      v20 = (1 << v21) & 0xFFFFFFFFFFFFFFFELL;
      if (v20 >= v4)
        return this;
    }
    __dmb(0xBu);
    *((_QWORD *)v8 + 2) = v20;
  }
  return this;
}

unint64_t *tbb::internal::concurrent_vector_base_v3::internal_assign(unint64_t *this, const tbb::internal::concurrent_vector_base_v3 *a2, uint64_t a3, uint64_t (*a4)(unint64_t, unint64_t), void (*a5)(void *, const void *, unint64_t), uint64_t (*a6)(uint64_t, uint64_t, unint64_t))
{
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _BOOL4 v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  uint64_t v39;
  const tbb::internal::concurrent_vector_base_v3 *v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  void *v44;
  uint64_t i;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v62;

  v8 = this;
  v9 = *((_QWORD *)a2 + 2);
  __dmb(0xBu);
  v10 = this[2];
  __dmb(0xBu);
  if (v10 > v9)
  {
    do
    {
      v16 = v8[2];
      __dmb(0xBu);
      v17 = --v16 | 1;
      v18 = HIDWORD(v16);
      v19 = v18 != 0;
      if (!v18)
        v18 = v17;
      v20 = 32 * v19;
      if (v18 >= 0x10000)
      {
        v18 >>= 16;
        v20 = (32 * v19) | 0x10;
      }
      if (v18 >= 0x100)
      {
        v18 >>= 8;
        v20 |= 8uLL;
      }
      if (v18 >= 0x10)
      {
        v18 >>= 4;
        v20 |= 4uLL;
      }
      if (v18 >= 4)
      {
        v18 >>= 2;
        v20 += 2;
      }
      v21 = ((v18 >> 1) & 1) + v20;
      v22 = (1 << v21) & 0xFFFFFFFFFFFFFFFELL;
      if (v22 <= v9)
        v23 = v9;
      else
        v23 = (1 << v21) & 0xFFFFFFFFFFFFFFFELL;
      v24 = v8[3];
      __dmb(0xBu);
      if (*(_QWORD *)(v24 + 8 * v21) <= 0x3FuLL)
        tbb::internal::throw_exception_v4(2);
      v12 = v8[3];
      __dmb(0xBu);
      v13 = *(_QWORD *)(v12 + 8 * v21) + (v23 - v22) * a3;
      v14 = v8[2];
      __dmb(0xBu);
      this = (unint64_t *)a4(v13, v14 - v23);
      __dmb(0xBu);
      v8[2] = v23;
      v15 = v8[2];
      __dmb(0xBu);
    }
    while (v15 > v9);
  }
  v62 = v8[2];
  __dmb(0xBu);
  v8[2] = v9;
  v25 = v8 + 1;
  v26 = v8[1];
  __dmb(0xBu);
  if (!v26)
  {
    v27 = v9 | 1;
    if (HIDWORD(v9))
      v27 = HIDWORD(v9);
    if (v27 < 0x10000)
    {
      v28 = 32 * (HIDWORD(v9) != 0);
    }
    else
    {
      v27 >>= 16;
      v28 = (32 * (HIDWORD(v9) != 0)) | 0x10;
    }
    if (v27 >= 0x100)
    {
      v27 >>= 8;
      v28 |= 8uLL;
    }
    if (v27 >= 0x10)
    {
      v27 >>= 4;
      v28 |= 4uLL;
    }
    v29 = v27 >= 4;
    if (v27 >= 4)
      v27 >>= 2;
    v30 = (v27 >> 1) & 1;
    v31 = v28 + 2;
    if (!v29)
      v31 = v28;
    v32 = v31 + v30 + 1;
    do
    {
      while (!__ldaxr(v25))
      {
        if (!__stlxr(v32, v25))
          goto LABEL_39;
      }
      __clrex();
      do
        v34 = __ldxr(v25);
      while (__stxr(v34, v25));
    }
    while (!v34);
  }
LABEL_39:
  if (!v9)
    return this;
  v35 = 0;
  v36 = 0;
  v37 = v8 + 3;
  v38 = v8 + 4;
  v39 = 1;
  while (1)
  {
    v40 = (const tbb::internal::concurrent_vector_base_v3 *)*((_QWORD *)a2 + 3);
    __dmb(0xBu);
    if (v36 >= 3 && (const tbb::internal::concurrent_vector_base_v3 *)((char *)a2 + 32) == v40)
      break;
    v41 = *((_QWORD *)a2 + 3);
    __dmb(0xBu);
    if (*(_QWORD *)(v41 + 8 * v36) <= 0x3FuLL)
      break;
    if (v36 >= 3)
    {
      v42 = *v37;
      __dmb(0xBu);
      if (v38 == (_QWORD *)v42)
      {
        v43 = *v37;
        __dmb(0xBu);
        if (v38 == (_QWORD *)v43)
        {
          this = (unint64_t *)tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
          for (i = 0; i != 64; ++i)
            this[i] = 0;
          *this = v8[4];
          this[1] = v8[5];
          this[2] = v8[6];
          do
          {
            while (1)
            {
              v46 = __ldaxr(v37);
              if ((_QWORD *)v46 != v38)
                break;
              if (!__stlxr((unint64_t)this, v37))
                goto LABEL_57;
            }
            __clrex();
            do
              v47 = __ldxr(v37);
            while (__stxr(v47, v37));
          }
          while ((_QWORD *)v47 == v38);
          this = (unint64_t *)tbb::internal::NFS_Free((tbb::internal *)this, v44);
        }
      }
    }
LABEL_57:
    v48 = *v37;
    __dmb(0xBu);
    if (*(_QWORD *)(v48 + 8 * v36))
    {
      v49 = *v37;
      __dmb(0xBu);
      if (*(_QWORD *)(v49 + 8 * v36) <= 0x3FuLL)
        this = (unint64_t *)tbb::internal::throw_exception_v4(2);
    }
    else
    {
      this = (unint64_t *)tbb::internal::concurrent_vector_base_v3::helper::enable_segment((tbb::internal::concurrent_vector_base_v3::helper *)v8, v36, a3);
    }
    v50 = 2;
    if (v36)
      v50 = v39;
    if (v50 >= v9 - v35)
      v51 = v9 - v35;
    else
      v51 = v50;
    if (v62 > v35)
    {
      if (v62 - v35 >= v51)
        v52 = v51;
      else
        v52 = v62 - v35;
      v53 = *v37;
      __dmb(0xBu);
      v54 = *(_QWORD *)(v53 + 8 * v36);
      v55 = *((_QWORD *)a2 + 3);
      __dmb(0xBu);
      this = (unint64_t *)((uint64_t (*)(uint64_t, _QWORD, unint64_t))a5)(v54, *(_QWORD *)(v55 + 8 * v36), v52);
      v51 -= v52;
      v56 = v52 * a3;
      if (!v51)
        goto LABEL_41;
LABEL_73:
      v57 = *v37;
      __dmb(0xBu);
      v58 = *(_QWORD *)(v57 + 8 * v36) + v56;
      v59 = *((_QWORD *)a2 + 3);
      __dmb(0xBu);
      this = (unint64_t *)a6(v58, *(_QWORD *)(v59 + 8 * v36) + v56, v51);
      goto LABEL_41;
    }
    v56 = 0;
    if (v51)
      goto LABEL_73;
LABEL_41:
    v39 = 1 << ++v36;
    v35 = (1 << v36) & 0xFFFFFFFFFFFFFFFELL;
    if (v35 >= v9)
      return this;
  }
  __dmb(0xBu);
  v8[2] = v35;
  return this;
}

unint64_t tbb::internal::concurrent_vector_base_v3::internal_push_back(tbb::internal::concurrent_vector_base_v3 *this, uint64_t a2, unint64_t *a3, void *a4)
{
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  tbb::internal::concurrent_vector_base_v3 *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = (unint64_t *)((char *)this + 16);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 + 1, v6));
  *a3 = v7;
  v8 = v7 | 1;
  if (HIDWORD(v7))
    v8 = HIDWORD(v7);
  v9 = 32 * (HIDWORD(v7) != 0);
  if (v8 >= 0x10000)
  {
    v8 >>= 16;
    v9 = (32 * (HIDWORD(v7) != 0)) | 0x10;
  }
  if (v8 >= 0x100)
  {
    v8 >>= 8;
    v9 |= 8uLL;
  }
  if (v8 >= 0x10)
  {
    v8 >>= 4;
    v9 |= 4uLL;
  }
  if (v8 >= 4)
  {
    v8 >>= 2;
    v9 += 2;
  }
  v10 = ((v8 >> 1) & 1) + v9;
  if (v10 >= 3)
  {
    v11 = (tbb::internal::concurrent_vector_base_v3 *)*((_QWORD *)this + 3);
    __dmb(0xBu);
    if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) == v11)
      tbb::internal::concurrent_vector_base_v3::helper::extend_segment_table((unint64_t)this, (tbb::internal::concurrent_vector_base_v3 *)v7, (unint64_t)a3, a4);
  }
  v12 = (1 << v10) & 0xFFFFFFFFFFFFFFFELL;
  v13 = *((_QWORD *)this + 3);
  __dmb(0xBu);
  v14 = *(_QWORD *)(v13 + 8 * v10);
  __dmb(0xBu);
  if (!v14)
  {
    if (v7 == v12)
    {
      tbb::internal::concurrent_vector_base_v3::helper::enable_segment(this, v10, a2);
    }
    else
    {
      while (!*(_QWORD *)(v13 + 8 * v10))
        sched_yield();
    }
  }
  if (*(_QWORD *)(v13 + 8 * v10) <= 0x3FuLL)
    tbb::internal::throw_exception_v4(2);
  return *(_QWORD *)(v13 + 8 * v10) + (v7 - v12) * a2;
}

unint64_t tbb::internal::concurrent_vector_base_v3::internal_grow_to_at_least_with_result(tbb::internal::concurrent_vector_base_v3 *this, unint64_t a2, void *a3, void (*a4)(void *, const void *, unint64_t), const void *a5)
{
  unint64_t *v7;
  tbb::internal::concurrent_vector_base_v3 *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _BOOL4 v12;
  uint64_t v13;
  unint64_t v14;
  tbb::internal::concurrent_vector_base_v3 *v15;
  tbb::internal::concurrent_vector_base_v3 *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v7 = (unint64_t *)((char *)this + 16);
  v8 = (tbb::internal::concurrent_vector_base_v3 *)*((_QWORD *)this + 2);
  __dmb(0xBu);
  if ((unint64_t)v8 < a2)
  {
    do
    {
      while (1)
      {
        v9 = __ldaxr(v7);
        if ((tbb::internal::concurrent_vector_base_v3 *)v9 == v8)
          break;
        __clrex();
        do
          v10 = __ldxr(v7);
        while (__stxr(v10, v7));
        if ((tbb::internal::concurrent_vector_base_v3 *)v10 != v8)
        {
          v8 = (tbb::internal::concurrent_vector_base_v3 *)v10;
          if (v10 >= a2)
            goto LABEL_12;
        }
      }
    }
    while (__stlxr(a2, v7));
    tbb::internal::concurrent_vector_base_v3::internal_grow(this, v8, a2, a3, a4, a5);
  }
  v10 = (unint64_t)v8;
LABEL_12:
  v11 = (a2 - 1) >> 32;
  v12 = v11 != 0;
  if (!v11)
    v11 = (a2 - 1) | 1;
  v13 = 32 * v12;
  if (v11 >= 0x10000)
  {
    v11 >>= 16;
    v13 = (32 * v12) | 0x10;
  }
  if (v11 >= 0x100)
  {
    v11 >>= 8;
    v13 |= 8uLL;
  }
  if (v11 >= 0x10)
  {
    v11 >>= 4;
    v13 |= 4uLL;
  }
  if (v11 >= 4)
  {
    v11 >>= 2;
    v13 += 2;
  }
  v14 = ((v11 >> 1) & 1) + v13;
  if (v14 >= 3)
  {
    v15 = (tbb::internal::concurrent_vector_base_v3 *)*((_QWORD *)this + 3);
    __dmb(0xBu);
    if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) == v15)
    {
      while (1)
      {
        v16 = (tbb::internal::concurrent_vector_base_v3 *)*((_QWORD *)this + 3);
        __dmb(0xBu);
        if (v15 != v16)
          break;
        sched_yield();
      }
    }
  }
  v17 = 0;
  do
  {
    v18 = *((_QWORD *)this + 3);
    __dmb(0xBu);
    if (!*(_QWORD *)(v18 + 8 * v17))
    {
      do
      {
        sched_yield();
        v19 = *((_QWORD *)this + 3);
        __dmb(0xBu);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        __dmb(0xBu);
      }
      while (!v20);
    }
    v21 = *((_QWORD *)this + 3);
    __dmb(0xBu);
    if (*(_QWORD *)(v21 + 8 * v17) <= 0x3FuLL)
      tbb::internal::throw_exception_v4(2);
    ++v17;
  }
  while (v17 <= v14);
  return v10;
}

void tbb::internal::concurrent_vector_base_v3::internal_grow(tbb::internal::concurrent_vector_base_v3 *this, tbb::internal::concurrent_vector_base_v3 *a2, unint64_t a3, void *a4, void (*a5)(void *, const void *, unint64_t), const void *a6)
{
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _BOOL4 v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  unint64_t v22;
  tbb::internal::concurrent_vector_base_v3 *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  tbb::internal::concurrent_vector_base_v3 *v41;
  unint64_t v42;
  void *v43;

  v12 = (unint64_t)a2 | 1;
  if ((unint64_t)a2 >> 32)
    v12 = (unint64_t)a2 >> 32;
  v13 = 32 * ((unint64_t)a2 >> 32 != 0);
  if (v12 >= 0x10000)
  {
    v12 >>= 16;
    v13 = (32 * ((unint64_t)a2 >> 32 != 0)) | 0x10;
  }
  if (v12 >= 0x100)
  {
    v12 >>= 8;
    v13 |= 8uLL;
  }
  if (v12 >= 0x10)
  {
    v12 >>= 4;
    v13 |= 4uLL;
  }
  if (v12 >= 4)
  {
    v12 >>= 2;
    v13 += 2;
  }
  v14 = ((v12 >> 1) & 1) + v13;
  v15 = (a3 - 1) >> 32;
  v16 = v15 != 0;
  if (!v15)
    v15 = (a3 - 1) | 1;
  v17 = 32 * v16;
  if (v15 >= 0x10000)
  {
    v15 >>= 16;
    v17 = (32 * v16) | 0x10;
  }
  if (v15 >= 0x100)
  {
    v15 >>= 8;
    v17 |= 8uLL;
  }
  if (v15 >= 0x10)
  {
    v15 >>= 4;
    v17 |= 4uLL;
  }
  if (v15 >= 4)
  {
    v15 >>= 2;
    v17 += 2;
  }
  v18 = ((v15 >> 1) & 1) + v17;
  v19 = (unint64_t *)((char *)this + 8);
  v20 = *((_QWORD *)this + 1);
  __dmb(0xBu);
  if (!v20)
  {
    do
    {
      while (!__ldaxr(v19))
      {
        if (!__stlxr(v18 + 1, v19))
          goto LABEL_28;
      }
      __clrex();
      do
        v22 = __ldxr(v19);
      while (__stxr(v22, v19));
    }
    while (!v22);
  }
LABEL_28:
  if (v18 >= 3)
  {
    v23 = (tbb::internal::concurrent_vector_base_v3 *)*((_QWORD *)this + 3);
    __dmb(0xBu);
    if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) == v23)
      tbb::internal::concurrent_vector_base_v3::helper::extend_segment_table((unint64_t)this, a2, a3, a4);
  }
  v24 = *((_QWORD *)this + 3);
  __dmb(0xBu);
  v25 = *((_QWORD *)this + 1);
  __dmb(0xBu);
  v37 = v24;
  v38 = v25;
  v39 = v14;
  v40 = 0;
  v41 = a2;
  v42 = a3;
  v43 = a4;
  while (v18 > v14 && v18 >= v25)
  {
    v26 = *((_QWORD *)this + 3);
    __dmb(0xBu);
    v27 = *(_QWORD *)(v26 + 8 * v18);
    __dmb(0xBu);
    if (!v27)
      tbb::internal::concurrent_vector_base_v3::helper::enable_segment(this, v18, (uint64_t)a4);
    if (*(_QWORD *)(v26 + 8 * v18) <= 0x3FuLL)
      tbb::internal::throw_exception_v4(2);
    --v18;
    v25 = v38;
  }
  if (v14 <= v18)
  {
    do
    {
      v28 = *((_QWORD *)this + 3);
      __dmb(0xBu);
      v29 = *(_QWORD *)(v28 + 8 * v14);
      __dmb(0xBu);
      if (!v29)
      {
        if (((1 << v14) & 0xFFFFFFFFFFFFFFFELL) >= (unint64_t)a2)
        {
          tbb::internal::concurrent_vector_base_v3::helper::enable_segment(this, v14, (uint64_t)a4);
        }
        else
        {
          while (!*(_QWORD *)(v28 + 8 * v14))
            sched_yield();
        }
      }
      if (*(_QWORD *)(v28 + 8 * v14) <= 0x3FuLL)
        tbb::internal::throw_exception_v4(2);
      ++v14;
    }
    while (v14 <= v18);
    v25 = v38;
  }
  v30 = v39;
  if (v39 < v25)
  {
    v30 = 0;
    v39 = 0;
  }
  v31 = (1 << v30) & 0xFFFFFFFFFFFFFFFELL;
  v32 = v42 - v31;
  v33 = (char *)v41 - v31;
  if (v30)
    v34 = (1 << v30) & 0xFFFFFFFFFFFFFFFELL;
  else
    v34 = 1 << v25;
  v41 = (tbb::internal::concurrent_vector_base_v3 *)((char *)v41 - v31);
  v42 -= v31;
  v40 = v34;
  v35 = v32 - v34;
  if (v32 <= v34)
  {
    v35 = v32;
  }
  else
  {
    a5((void *)(*(_QWORD *)(v37 + 8 * v30) + (_QWORD)v43 * (_QWORD)v33), a6, v34 - (_QWORD)v33);
    v41 = 0;
    v42 = v35;
    v36 = v25;
    if (v30)
    {
      v36 = v30 + 1;
      v34 = 1 << (v30 + 1);
      v40 = v34;
    }
    v39 = v36;
    if (v34 >= v35)
    {
      v33 = 0;
      v30 = v36;
    }
    else
    {
      do
      {
        a5(*(void **)(v37 + 8 * v36), a6, v34);
        v35 -= v34;
        v41 = 0;
        v42 = v35;
        v30 = v25;
        if (v36)
        {
          v30 = v36 + 1;
          v34 = 1 << (v36 + 1);
          v40 = v34;
        }
        v39 = v30;
        v36 = v30;
      }
      while (v34 < v35);
      v33 = 0;
    }
  }
  a5((void *)(*(_QWORD *)(v37 + 8 * v30) + (_QWORD)v43 * (_QWORD)v33), a6, v35 - (_QWORD)v33);
  if (v34 < v35)
    tbb::internal::concurrent_vector_base_v3::helper::cleanup((tbb::internal::concurrent_vector_base_v3::helper *)&v37);
}

void sub_20BDC40C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDC4134((tbb::internal::concurrent_vector_base_v3::helper *)va);
  _Unwind_Resume(a1);
}

tbb::internal::concurrent_vector_base_v3 *tbb::internal::concurrent_vector_base_v3::internal_grow_by(tbb::internal::concurrent_vector_base_v3 *this, uint64_t a2, void *a3, void (*a4)(void *, const void *, unint64_t), const void *a5)
{
  unint64_t *v5;
  tbb::internal::concurrent_vector_base_v3 *v6;

  v5 = (unint64_t *)((char *)this + 16);
  do
    v6 = (tbb::internal::concurrent_vector_base_v3 *)__ldaxr(v5);
  while (__stlxr((unint64_t)v6 + a2, v5));
  tbb::internal::concurrent_vector_base_v3::internal_grow(this, v6, (unint64_t)v6 + a2, a3, a4, a5);
  return v6;
}

tbb::internal::concurrent_vector_base_v3::helper *sub_20BDC4134(tbb::internal::concurrent_vector_base_v3::helper *this)
{
  if (*((_QWORD *)this + 3) < *((_QWORD *)this + 5))
    tbb::internal::concurrent_vector_base_v3::helper::cleanup(this);
  return this;
}

void tbb::internal::concurrent_vector_base_v3::internal_resize(tbb::internal::concurrent_vector_base_v3 *this, unint64_t a2, uint64_t a3, void *a4, const void *a5, void (*a6)(void *, unint64_t), void (*a7)(void *, const void *, unint64_t))
{
  uint64_t v7;
  unint64_t v10;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;

  v7 = a3;
  v10 = *((_QWORD *)this + 2);
  __dmb(0xBu);
  if (v10 >= a2)
  {
    __dmb(0xBu);
    *((_QWORD *)this + 2) = a2;
    v27 = *((_QWORD *)this + 3);
    __dmb(0xBu);
    v28 = *((_QWORD *)this + 1);
    __dmb(0xBu);
    v29 = a2 | 1;
    if (HIDWORD(a2))
      v29 = HIDWORD(a2);
    v30 = 32 * (HIDWORD(a2) != 0);
    if (v29 >= 0x10000)
    {
      v29 >>= 16;
      v30 = (32 * (HIDWORD(a2) != 0)) | 0x10;
    }
    if (v29 >= 0x100)
    {
      v29 >>= 8;
      v30 |= 8uLL;
    }
    if (v29 >= 0x10)
    {
      v29 >>= 4;
      v30 |= 4uLL;
    }
    if (v29 >= 4)
    {
      v29 >>= 2;
      v30 += 2;
    }
    v40 = v27;
    v41 = v28;
    v31 = ((v29 >> 1) & 1) + v30;
    v42 = v31;
    v46 = a3;
    if (v31 < v28)
    {
      v31 = 0;
      v42 = 0;
    }
    v32 = (1 << v31) & 0xFFFFFFFFFFFFFFFELL;
    v33 = v10 - v32;
    v34 = a2 - v32;
    if (v31)
      v35 = (1 << v31) & 0xFFFFFFFFFFFFFFFELL;
    else
      v35 = 1 << v28;
    v44 = a2 - v32;
    v45 = v10 - v32;
    v43 = v35;
    v36 = v33 - v35;
    if (v33 <= v35)
    {
      v36 = v10 - v32;
    }
    else
    {
      if (*(_QWORD *)(v27 + 8 * v31) >= 0x40uLL)
        a6((void *)(*(_QWORD *)(v27 + 8 * v31) + v34 * a3), v35 - v34);
      v44 = 0;
      v45 = v36;
      v37 = v28;
      if (v31)
      {
        v37 = v31 + 1;
        v35 = 1 << (v31 + 1);
        v43 = v35;
      }
      v42 = v37;
      if (v35 >= v36)
      {
        v34 = 0;
        v31 = v37;
      }
      else
      {
        do
        {
          if (*(_QWORD *)(v27 + 8 * v37) >= 0x40uLL)
            a6(*(void **)(v27 + 8 * v37), v35);
          v36 -= v35;
          v44 = 0;
          v45 = v36;
          v31 = v28;
          if (v37)
          {
            v31 = v37 + 1;
            v35 = 1 << (v37 + 1);
            v43 = v35;
          }
          v42 = v31;
          v37 = v31;
        }
        while (v35 < v36);
        v34 = 0;
      }
    }
    if (*(_QWORD *)(v27 + 8 * v31) >= 0x40uLL)
      a6((void *)(*(_QWORD *)(v27 + 8 * v31) + v34 * v7), v36 - v34);
    if (v35 < v36)
      goto LABEL_70;
  }
  else
  {
    tbb::internal::concurrent_vector_base_v3::internal_reserve((unint64_t *)this, a2, a3, a4);
    __dmb(0xBu);
    *((_QWORD *)this + 2) = a2;
    v13 = *((_QWORD *)this + 3);
    __dmb(0xBu);
    v14 = *((_QWORD *)this + 1);
    __dmb(0xBu);
    v15 = v10 | 1;
    if (HIDWORD(v10))
      v15 = HIDWORD(v10);
    v16 = 32 * (HIDWORD(v10) != 0);
    if (v15 >= 0x10000)
    {
      v15 >>= 16;
      v16 = (32 * (HIDWORD(v10) != 0)) | 0x10;
    }
    if (v15 >= 0x100)
    {
      v15 >>= 8;
      v16 |= 8uLL;
    }
    if (v15 >= 0x10)
    {
      v15 >>= 4;
      v16 |= 4uLL;
    }
    if (v15 >= 4)
    {
      v15 >>= 2;
      v16 += 2;
    }
    v40 = v13;
    v41 = v14;
    v17 = ((v15 >> 1) & 1) + v16;
    v42 = v17;
    v46 = v7;
    if (v17 < v14)
    {
      v17 = 0;
      v42 = 0;
    }
    v18 = (1 << v17) & 0xFFFFFFFFFFFFFFFELL;
    v19 = a2 - v18;
    v20 = v10 - v18;
    if (v17)
      v21 = (1 << v17) & 0xFFFFFFFFFFFFFFFELL;
    else
      v21 = 1 << v14;
    v44 = v10 - v18;
    v45 = v19;
    v43 = v21;
    v22 = v19 - v21;
    if (v19 <= v21)
    {
      v22 = v19;
    }
    else
    {
      v23 = *(_QWORD *)(v13 + 8 * v17);
      if (v23 <= 0x3F)
        tbb::internal::throw_exception_v4(2);
      a7((void *)(v23 + v20 * v7), a5, v21 - v20);
      v39 = v7;
      v44 = 0;
      v45 = v22;
      v24 = v14;
      if (v17)
      {
        v24 = v17 + 1;
        v21 = 2 << v17;
        v43 = 2 << v17;
      }
      v42 = v24;
      if (v21 >= v22)
      {
        v20 = 0;
        v17 = v24;
      }
      else
      {
        do
        {
          v25 = *(void **)(v13 + 8 * v24);
          if ((unint64_t)v25 <= 0x3F)
            tbb::internal::throw_exception_v4(2);
          a7(v25, a5, v21);
          v22 -= v21;
          v44 = 0;
          v45 = v22;
          v17 = v14;
          if (v24)
          {
            v17 = v24 + 1;
            v21 = 1 << (v24 + 1);
            v43 = v21;
          }
          v42 = v17;
          v24 = v17;
        }
        while (v21 < v22);
        v20 = 0;
      }
      v7 = v39;
    }
    v38 = *(_QWORD *)(v13 + 8 * v17);
    if (v38 <= 0x3F)
      tbb::internal::throw_exception_v4(2);
    a7((void *)(v38 + v20 * v7), a5, v22 - v20);
    if (v21 < v22)
LABEL_70:
      tbb::internal::concurrent_vector_base_v3::helper::cleanup((tbb::internal::concurrent_vector_base_v3::helper *)&v40);
  }
}

void sub_20BDC4594(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDC4134((tbb::internal::concurrent_vector_base_v3::helper *)va);
  _Unwind_Resume(a1);
}

unint64_t sub_20BDC45C4(_QWORD *a1, void (**a2)(unint64_t, unint64_t))
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;

  result = a1[2];
  v5 = a1[1];
  if (result < v5)
  {
    result = 0;
    a1[2] = 0;
  }
  v6 = (1 << result) & 0xFFFFFFFFFFFFFFFELL;
  v7 = a1[5] - v6;
  v8 = a1[4] - v6;
  v9 = 1 << v5;
  if (result)
    v10 = (1 << result) & 0xFFFFFFFFFFFFFFFELL;
  else
    v10 = v9;
  a1[4] = v8;
  a1[5] = v7;
  a1[3] = v10;
  if (v10 < v7)
  {
    if (*(_QWORD *)(*a1 + 8 * result) >= 0x40uLL)
    {
      (*a2)(*(_QWORD *)(*a1 + 8 * result) + v8 * a1[6], v10 - v8);
      v7 = a1[5];
      result = a1[2];
      v10 = a1[3];
    }
    v7 -= v10;
    a1[4] = 0;
    a1[5] = v7;
    if (result)
    {
      v10 = 1 << ++result;
      a1[3] = 1 << result;
    }
    else
    {
      result = a1[1];
    }
    for (a1[2] = result; v10 < v7; a1[2] = result)
    {
      if (*(_QWORD *)(*a1 + 8 * result) >= 0x40uLL)
      {
        ((void (*)(_QWORD))*a2)(*(_QWORD *)(*a1 + 8 * result));
        v7 = a1[5];
        result = a1[2];
        v10 = a1[3];
      }
      v7 -= v10;
      a1[4] = 0;
      a1[5] = v7;
      if (result)
      {
        v10 = 1 << ++result;
        a1[3] = 1 << result;
      }
      else
      {
        result = a1[1];
      }
    }
    v8 = 0;
  }
  if (*(_QWORD *)(*a1 + 8 * result) >= 0x40uLL)
  {
    (*a2)(*(_QWORD *)(*a1 + 8 * result) + v8 * a1[6], v7 - v8);
    return a1[2];
  }
  return result;
}

unint64_t tbb::internal::concurrent_vector_base_v3::internal_clear(tbb::internal::concurrent_vector_base_v3 *this, void (*a2)(void *, unint64_t))
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  tbb::internal::concurrent_vector_base_v3 *v11;
  uint64_t v12;
  _QWORD v14[2];
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;

  v4 = *((_QWORD *)this + 2);
  __dmb(0xBu);
  *((_QWORD *)this + 2) = 0;
  v5 = *((_QWORD *)this + 3);
  __dmb(0xBu);
  v6 = *((_QWORD *)this + 1);
  __dmb(0xBu);
  v14[0] = v5;
  v14[1] = v6;
  v18 = v4;
  v19 = 0;
  v7 = 1 << v6;
  v15 = 0;
  v16 = 1 << v6;
  v17 = 0;
  if (1 << v6 >= v4)
  {
    v9 = 0;
  }
  else
  {
    v8 = 0;
    do
    {
      if (*(_QWORD *)(v5 + 8 * v8) >= 0x40uLL)
        a2(*(void **)(v5 + 8 * v8), v7);
      v4 -= v7;
      v17 = 0;
      v18 = v4;
      v9 = v6;
      if (v8)
      {
        v9 = v8 + 1;
        v7 = 1 << (v8 + 1);
        v16 = v7;
      }
      v15 = v9;
      v8 = v9;
    }
    while (v7 < v4);
  }
  if (*(_QWORD *)(v5 + 8 * v9) >= 0x40uLL)
    a2(*(void **)(v5 + 8 * v9), v4);
  v10 = 0;
  v11 = (tbb::internal::concurrent_vector_base_v3 *)*((_QWORD *)this + 3);
  __dmb(0xBu);
  v12 = 64;
  if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) == v11)
    v12 = 3;
  while (*((_QWORD *)v11 + v10) >= 0x40uLL)
  {
    if (v12 == ++v10)
    {
      v10 = v12;
      break;
    }
  }
  if (v16 < v18)
    tbb::internal::concurrent_vector_base_v3::helper::cleanup((tbb::internal::concurrent_vector_base_v3::helper *)v14);
  if (v9 >= v10)
    return v9 + 1;
  else
    return v10;
}

void sub_20BDC488C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDC4134((tbb::internal::concurrent_vector_base_v3::helper *)va);
  _Unwind_Resume(a1);
}

unint64_t *tbb::internal::concurrent_vector_base_v3::internal_compact(tbb::internal::concurrent_vector_base_v3 **this, uint64_t a2, unint64_t *a3, void (*a4)(void *, unint64_t), void (*a5)(void *, const void *, unint64_t))
{
  unint64_t *v5;
  tbb::internal::concurrent_vector_base_v3 *v6;
  unint64_t v7;
  unint64_t v8;
  tbb::internal::concurrent_vector_base_v3 *v9;
  uint64_t v10;
  unint64_t v11;
  _BOOL4 v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  tbb::internal::concurrent_vector_base_v3 *v18;
  uint64_t i;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  BOOL v27;
  uint64_t j;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  BOOL v37;
  unint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v45;
  unint64_t v48;

  v5 = a3;
  v6 = (tbb::internal::concurrent_vector_base_v3 *)this;
  v7 = 0;
  v8 = (unint64_t)this[2];
  __dmb(0xBu);
  v9 = this[3];
  v10 = 64;
  if (this + 4 == (tbb::internal::concurrent_vector_base_v3 **)v9)
    v10 = 3;
  __dmb(0xBu);
  while (*((_QWORD *)v9 + v7) >= 0x40uLL)
  {
    if (v10 == ++v7)
    {
      v7 = v10;
      break;
    }
  }
  if (v8)
  {
    v11 = (v8 - 1) >> 32;
    v12 = v11 != 0;
    if (!v11)
      v11 = (v8 - 1) | 1;
    v13 = 32 * v12;
    if (v11 >= 0x10000)
    {
      v11 >>= 16;
      v13 = (32 * v12) | 0x10;
    }
    if (v11 >= 0x100)
    {
      v11 >>= 8;
      v13 |= 8uLL;
    }
    if (v11 >= 0x10)
    {
      v11 >>= 4;
      v13 |= 4uLL;
    }
    if (v11 >= 4)
    {
      v11 >>= 2;
      v13 += 2;
    }
    v14 = v13 + ((v11 >> 1) & 1) + 1;
  }
  else
  {
    v14 = 0;
  }
  v15 = (unint64_t)this[1];
  __dmb(0xBu);
  v16 = v14;
  v48 = v15;
  if (v14 >= v15)
  {
    v16 = v15;
    if (v15 < v14)
    {
      v16 = v15;
      while (1)
      {
        v17 = a2 << v16;
        if ((unint64_t)(a2 << v16) >= 0x1000 && (v17 >> 19 || (((_DWORD)v17 - 1) & 0x800) != 0))
          break;
        if (v14 == ++v16)
        {
          v16 = v14;
          break;
        }
      }
    }
  }
  if (v14 == v7 && v16 == v48)
    return 0;
  v45 = v14;
  v18 = this[3];
  __dmb(0xBu);
  for (i = 1; i != 65; ++i)
    a3[i] = 0;
  *a3 = 0;
  if (v16 != v48 && v16)
  {
    v20 = ((uint64_t (*)(tbb::internal::concurrent_vector_base_v3 **, uint64_t))*this)(this, 1 << v16);
    if (!v20)
      tbb::internal::throw_exception_v4(1);
    v5[1] = v20;
    *v5 = v16;
    if (v8)
    {
      v21 = 0;
      v22 = 0;
      v23 = 1 << v48;
      do
      {
        v24 = v21 + v23;
        v25 = v8 - v21;
        if (v24 >= v8)
          v26 = v25;
        else
          v26 = v23;
        a5((void *)(v20 + ((1 << v22) & 0xFFFFFFFFFFFFFFFELL) * a2), *((const void **)v18 + v22), v26);
        v21 = 2 << v22;
        v27 = v22 == 0;
        if (v22)
          ++v22;
        else
          v22 = v48;
        if (v27)
          v21 = 1 << v48;
        if (v22 >= v16)
          break;
        v23 = v21;
      }
      while (v21 < v8);
    }
    for (j = 0; j != v16; ++j)
      v5[j + 1] = *(_QWORD *)((char *)v18 + j * 8);
    v29 = 0;
    if (v16 <= 1)
      v30 = 1;
    else
      v30 = v16;
    do
    {
      *((_QWORD *)v18 + v29) = v20 + ((1 << v29) & 0xFFFFFFFFFFFFFFFELL) * a2;
      ++v29;
    }
    while (v30 != v29);
    *v5 = v48;
    __dmb(0xBu);
    v6 = (tbb::internal::concurrent_vector_base_v3 *)this;
    this[1] = (tbb::internal::concurrent_vector_base_v3 *)v16;
    if (v8)
    {
      v31 = 0;
      v32 = 0;
      v33 = 1 << v48;
      do
      {
        v34 = v31 + v33;
        v35 = v8 - v31;
        if (v34 >= v8)
          v36 = v35;
        else
          v36 = v33;
        a4((void *)v5[v32 + 1], v36);
        v31 = 2 << v32;
        v37 = v32 == 0;
        if (v32)
          ++v32;
        else
          v32 = v48;
        if (v37)
          v31 = 1 << v48;
        if (v32 >= v16)
          break;
        v33 = v31;
      }
      while (v31 < v8);
    }
  }
  v38 = v45 - v7;
  if (v45 < v7)
  {
    *v5 = v48;
    v39 = v45;
    v40 = (_QWORD *)((char *)v18 + 8 * v45);
    do
    {
      v5[v39 + 1] = *(_QWORD *)((char *)v18 + v39 * 8);
      ++v39;
    }
    while (v7 != v39);
    if (v7 != v45)
    {
      do
        *v40++ = 0;
      while (!__CFADD__(v38++, 1));
    }
    if (!v16)
    {
      __dmb(0xBu);
      *((_QWORD *)v6 + 1) = 0;
    }
  }
  return v5;
}

void sub_20BDC4C50(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void (*a12)(unint64_t, unint64_t), uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void (*a17)(unint64_t, unint64_t), uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  __cxa_begin_catch(a1);
  v27 = *v24;
  a18 = a10;
  a19 = v27;
  a20 = 0;
  a21 = 0;
  a22 = 0;
  a23 = v26 + v25;
  a24 = a14;
  a17 = a12;
  sub_20BDC45C4(&a18, &a17);
  __cxa_rethrow();
}

void sub_20BDC4C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  sub_20BDC4134((tbb::internal::concurrent_vector_base_v3::helper *)va);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *tbb::internal::concurrent_vector_base_v3::internal_swap(_QWORD *this, tbb::internal::concurrent_vector_base_v3 *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = this[2];
  __dmb(0xBu);
  v3 = *((_QWORD *)a2 + 2);
  if (v2 | v3)
  {
    v4 = (_QWORD *)this[3];
    v5 = (char *)*((_QWORD *)a2 + 3);
    v6 = this[4];
    v7 = (char *)a2 + 32;
    this[4] = *((_QWORD *)a2 + 4);
    *((_QWORD *)a2 + 4) = v6;
    v8 = this[5];
    this[5] = *((_QWORD *)a2 + 5);
    *((_QWORD *)a2 + 5) = v8;
    v9 = this[6];
    this[6] = *((_QWORD *)a2 + 6);
    *((_QWORD *)a2 + 6) = v9;
    v10 = this[1];
    this[1] = *((_QWORD *)a2 + 1);
    *((_QWORD *)a2 + 1) = v10;
    v11 = this[3];
    this[3] = *((_QWORD *)a2 + 3);
    *((_QWORD *)a2 + 3) = v11;
    if (this + 4 == v4)
    {
      *((_QWORD *)a2 + 3) = v7;
      if (v7 != v5)
        goto LABEL_4;
    }
    else if (v7 != v5)
    {
LABEL_4:
      this[2] = v3;
      __dmb(0xBu);
      *((_QWORD *)a2 + 2) = v2;
      return this;
    }
    this[3] = this + 4;
    goto LABEL_4;
  }
  return this;
}

uint64_t tbb::internal::dynamic_link(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  if (a4)
    *a4 = 0;
  return 0;
}

const char *tbb::internal::initialize_handler_pointers(tbb::internal *this)
{
  const char *v1;
  const char *v2;

  if ((tbb::internal::dynamic_link((uint64_t)"libtbbmalloc.dylib", (uint64_t)&off_24C515DC0, 4, 0) & 1) != 0)
  {
    v2 = "scalable_malloc";
  }
  else
  {
    off_25473B0E0 = (uint64_t (*)(void))MEMORY[0x24BDAE450];
    off_25473B0E8[0] = (uint64_t (*)())MEMORY[0x24BDAED08];
    off_25473B0F0 = (uint64_t (*)(_QWORD, _QWORD))sub_20BDC4E00;
    off_25473B0F8 = (uint64_t (*)(_QWORD))sub_20BDC4E44;
    v2 = "malloc";
  }
  return tbb::internal::PrintExtraVersionInfo("ALLOCATOR", v2, v1);
}

unint64_t sub_20BDC4E00(uint64_t a1, uint64_t a2)
{
  void *v3;
  unint64_t v4;

  v3 = malloc(a2 + a1);
  if (!v3)
    return 0;
  v4 = ((unint64_t)v3 + a2) & -a2;
  *(_QWORD *)(v4 - 8) = v3;
  return v4;
}

void sub_20BDC4E44(uint64_t a1)
{
  if (a1)
    free(*(void **)(a1 - 8));
}

void tbb::internal::initialize_cache_aligned_allocator(tbb::internal *this)
{
  int v1;
  int v2;
  int v4;
  int v5;
  const char *v6;
  const char *v7;

  v1 = dword_254784D68;
  __dmb(0xBu);
  if (v1 != 2)
  {
    while (1)
    {
      v2 = dword_254784D68;
      __dmb(0xBu);
      if (!v2)
        break;
LABEL_9:
      while (1)
      {
        v4 = dword_254784D68;
        __dmb(0xBu);
        if (v4 != 1)
          break;
        sched_yield();
      }
      v5 = dword_254784D68;
      __dmb(0xBu);
      if (v5 == 2)
        return;
    }
    do
    {
      while (__ldaxr((unsigned int *)&dword_254784D68))
      {
        __clrex();
        if (dword_254784D68)
          goto LABEL_9;
      }
    }
    while (__stlxr(1u, (unsigned int *)&dword_254784D68));
    if ((tbb::internal::dynamic_link((uint64_t)"libtbbmalloc.dylib", (uint64_t)&off_24C515DC0, 4, 0) & 1) != 0)
    {
      v7 = "scalable_malloc";
    }
    else
    {
      off_25473B0E0 = (uint64_t (*)(void))MEMORY[0x24BDAE450];
      off_25473B0E8[0] = (uint64_t (*)())MEMORY[0x24BDAED08];
      off_25473B0F0 = (uint64_t (*)(_QWORD, _QWORD))sub_20BDC4E00;
      off_25473B0F8 = (uint64_t (*)(_QWORD))sub_20BDC4E44;
      v7 = "malloc";
    }
    tbb::internal::PrintExtraVersionInfo("ALLOCATOR", v7, v6);
    __dmb(0xBu);
    dword_254784D68 = 2;
  }
}

uint64_t tbb::internal::NFS_GetLineSize(tbb::internal *this)
{
  return 128;
}

uint64_t tbb::internal::NFS_Allocate(unint64_t this, uint64_t a2, unint64_t a3, void *a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = a2 * this;
  if (a2 * this < this || v4 >= 0xFFFFFFFFFFFFFF80)
    tbb::internal::throw_exception_v4(1);
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  v6 = off_25473B0F0(v5, 128);
  if (!v6)
    tbb::internal::throw_exception_v4(1);
  return v6;
}

uint64_t tbb::internal::NFS_Free(tbb::internal *this, void *a2)
{
  return off_25473B0F8(this);
}

uint64_t tbb::internal::allocate_via_handler_v3(tbb::internal *this)
{
  uint64_t v1;

  v1 = off_25473B0E8(this);
  if (!v1)
    tbb::internal::throw_exception_v4(1);
  return v1;
}

uint64_t tbb::internal::deallocate_via_handler_v3(uint64_t this, void *a2)
{
  if (this)
    return off_25473B0E0();
  return this;
}

BOOL tbb::internal::is_malloc_used_v3(tbb::internal *this)
{
  uint64_t (*v1)(_QWORD);
  uint64_t v2;

  v1 = off_25473B0E8;
  if ((char *)off_25473B0E8 == (char *)sub_20BDC509C)
  {
    tbb::internal::initialize_cache_aligned_allocator(this);
    v2 = off_25473B0E8(1);
    off_25473B0E0(v2);
    v1 = off_25473B0E8;
  }
  return v1 == MEMORY[0x24BDAED08];
}

uint64_t sub_20BDC509C(tbb::internal *a1)
{
  tbb::internal::initialize_cache_aligned_allocator(a1);
  return off_25473B0E8(a1);
}

uint64_t sub_20BDC50C8(tbb::internal *a1)
{
  tbb::internal::initialize_cache_aligned_allocator(a1);
  return off_25473B0E0(a1);
}

uint64_t sub_20BDC50F4(tbb::internal *a1, uint64_t a2)
{
  tbb::internal::initialize_cache_aligned_allocator(a1);
  return off_25473B0F0(a1, a2);
}

uint64_t sub_20BDC5128(tbb::internal *a1)
{
  tbb::internal::initialize_cache_aligned_allocator(a1);
  return off_25473B0F8(a1);
}

tbb::internal *tbb::internal::input_buffer::grow(tbb::internal::input_buffer *this, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  void *v8;
  uint64_t v9;
  tbb::internal *result;
  _BYTE *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  __int128 v16;
  unint64_t v17;

  v5 = *((_QWORD *)this + 2);
  v6 = 2 * v5;
  if (!v5)
    v6 = 4;
  do
  {
    v7 = v6;
    v6 *= 2;
  }
  while (v7 < a2);
  v9 = tbb::internal::NFS_Allocate(v7, 24, 0, a4);
  result = *(tbb::internal **)this;
  if (v7)
  {
    v11 = (_BYTE *)(v9 + 41);
    v12 = v7;
    do
    {
      *(v11 - 24) = 0;
      *v11 = 0;
      v11 += 48;
      v12 -= 2;
    }
    while (v12);
  }
  if (v5)
  {
    v13 = *((_QWORD *)this + 3);
    v14 = v5 - 1;
    do
    {
      v15 = (char *)result + 24 * (v13 & v14);
      v16 = *(_OWORD *)v15;
      v17 = v9 + 24 * (v13 & (v7 - 1));
      *(_QWORD *)(v17 + 16) = *((_QWORD *)v15 + 2);
      *(_OWORD *)v17 = v16;
      ++v13;
      --v5;
    }
    while (v5);
    *(_QWORD *)this = v9;
    *((_QWORD *)this + 2) = v7;
  }
  else
  {
    *(_QWORD *)this = v9;
    *((_QWORD *)this + 2) = v7;
    if (!result)
      return result;
  }
  return (tbb::internal *)tbb::internal::NFS_Free(result, v8);
}

tbb::internal::stage_task *tbb::internal::stage_task::execute(tbb::internal::stage_task *this)
{
  tbb::internal::stage_task *v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  _QWORD *v38;
  _BYTE *v39;
  unsigned int *v40;
  int v41;
  unsigned int v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v48;
  uint64_t v49;
  _BYTE *v50;
  int v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;

  v1 = this;
  v2 = *((unsigned __int8 *)this + 48);
  v3 = *((_QWORD *)this + 5);
  if (v2)
  {
    if ((*(_BYTE *)(v3 + 24) & 1) != 0)
    {
      v21 = (**(uint64_t (***)(uint64_t, _QWORD))v3)(v3, *((_QWORD *)v1 + 1));
      *((_QWORD *)v1 + 1) = v21;
      v22 = *(unsigned __int8 *)(*((_QWORD *)v1 + 5) + 24);
      if (!v21)
      {
        v25 = *((_QWORD *)v1 + 4);
        if ((v22 & 0x40) == 0 || *(_BYTE *)(v25 + 48))
        {
          v1 = 0;
          *(_BYTE *)(v25 + 48) = 1;
          return v1;
        }
      }
      if ((v22 & 0x11111111) == 1)
      {
        v23 = (unint64_t *)(*((_QWORD *)v1 + 4) + 40);
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 + 1, v23));
        *((_QWORD *)v1 + 2) = v24;
        *((_BYTE *)v1 + 24) = 1;
      }
      else if ((v22 & 0xEu) >= 6)
      {
        v26 = *((_QWORD *)v1 + 4);
        if (*(_BYTE *)(v26 + 49))
        {
          v27 = (unint64_t *)(v26 + 40);
          do
            v28 = __ldaxr(v27);
          while (__stlxr(v28 + 1, v27));
        }
      }
      if (!*(_QWORD *)(*((_QWORD *)v1 + 5) + 8))
      {
        *((_QWORD *)v1 + 1) = 0;
        *((_QWORD *)v1 + 2) = 0;
        *((_WORD *)v1 + 12) = 0;
        v45 = *((_QWORD *)v1 + 4);
LABEL_65:
        *((_QWORD *)v1 + 5) = *(_QWORD *)(v45 + 8);
        *((_BYTE *)v1 + 48) = 1;
LABEL_66:
        *((_BYTE *)v1 - 12) = 3;
        return v1;
      }
      v29 = (unint64_t *)(*((_QWORD *)v1 + 4) + 32);
      do
      {
        v30 = __ldaxr(v29);
        v31 = v30 - 1;
      }
      while (__stlxr(v31, v29));
      if (v31)
      {
        v32 = *((_QWORD *)v1 - 4);
        v54 = 0;
        v55 = v32;
        v33 = tbb::internal::allocate_additional_child_of_proxy::allocate((tbb::internal::allocate_additional_child_of_proxy *)&v54, 0x38uLL);
        v34 = *((_QWORD *)v1 + 4);
        *(_BYTE *)(v33 - 11) = 1;
        *(_QWORD *)v33 = &off_24C515E88;
        *(_QWORD *)(v33 + 32) = v34;
        *(_QWORD *)(v33 + 40) = *(_QWORD *)(v34 + 8);
        *(_BYTE *)(v33 + 48) = 1;
        *(_QWORD *)(v33 + 8) = 0;
        *(_QWORD *)(v33 + 16) = 0;
        *(_WORD *)(v33 + 24) = 0;
        (***(void (****)(_QWORD, unint64_t, uint64_t))(v33 - 40))(*(_QWORD *)(v33 - 40), v33, v33 - 8);
      }
    }
    else
    {
      v4 = *((_QWORD *)v1 + 4);
      if (*(_BYTE *)(v4 + 48))
        return 0;
      if ((*(_BYTE *)(v3 + 24) & 0xEu) >= 6 && *(_BYTE *)(v4 + 49))
      {
        v5 = (unint64_t *)(v4 + 40);
        do
          v6 = __ldaxr(v5);
        while (__stlxr(v6 + 1, v5));
        v4 = *((_QWORD *)v1 + 4);
      }
      v7 = (unint64_t *)(v4 + 32);
      do
      {
        v8 = __ldaxr(v7);
        v9 = v8 - 1;
      }
      while (__stlxr(v9, v7));
      if (v9)
      {
        v10 = *((_QWORD *)v1 - 4);
        v54 = 0;
        v55 = v10;
        v11 = tbb::internal::allocate_additional_child_of_proxy::allocate((tbb::internal::allocate_additional_child_of_proxy *)&v54, 0x38uLL);
        v12 = *((_QWORD *)v1 + 4);
        *(_BYTE *)(v11 - 11) = 1;
        *(_QWORD *)v11 = &off_24C515E88;
        *(_QWORD *)(v11 + 32) = v12;
        *(_QWORD *)(v11 + 40) = *(_QWORD *)(v12 + 8);
        *(_BYTE *)(v11 + 48) = 1;
        *(_QWORD *)(v11 + 8) = 0;
        *(_QWORD *)(v11 + 16) = 0;
        *(_WORD *)(v11 + 24) = 0;
        (***(void (****)(_QWORD, unint64_t, uint64_t))(v11 - 40))(*(_QWORD *)(v11 - 40), v11, v11 - 8);
      }
      v13 = (***((uint64_t (****)(_QWORD, _QWORD))v1 + 5))(*((_QWORD *)v1 + 5), *((_QWORD *)v1 + 1));
      *((_QWORD *)v1 + 1) = v13;
      if (!v13)
      {
        v15 = *((_QWORD *)v1 + 5);
        v16 = *(_BYTE *)(v15 + 24);
        if ((v16 & 0x40) == 0)
        {
LABEL_17:
          v17 = *((_QWORD *)v1 + 4);
          *(_BYTE *)(v17 + 48) = 1;
          if ((v16 & 0xEu) >= 6 && *(_BYTE *)(v17 + 49))
          {
            v18 = (unint64_t *)(v17 + 40);
            v1 = 0;
            do
              v19 = __ldaxr(v18);
            while (__stlxr(v19 - 1, v18));
            return v1;
          }
          return 0;
        }
        if (pthread_getspecific(*(_QWORD *)(*(_QWORD *)(v15 + 16) + 56)))
        {
          v16 = *(_BYTE *)(*((_QWORD *)v1 + 5) + 24);
          goto LABEL_17;
        }
      }
    }
    *((_BYTE *)v1 + 48) = 0;
  }
  else
  {
    *((_QWORD *)v1 + 1) = (**(uint64_t (***)(uint64_t, _QWORD))v3)(v3, *((_QWORD *)v1 + 1));
    v20 = *((_QWORD *)v1 + 5);
    if ((*(_BYTE *)(v20 + 24) & 1) != 0)
      sub_20BDC56C8(*(_QWORD *)(v20 + 16), *((_QWORD *)v1 + 2), (uint64_t)v1);
  }
  v35 = *(_QWORD *)(*((_QWORD *)v1 + 5) + 8);
  *((_QWORD *)v1 + 5) = v35;
  if (!v35)
  {
    v43 = (unint64_t *)(*((_QWORD *)v1 + 4) + 32);
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 + 1, v43));
    v45 = *((_QWORD *)v1 + 4);
    v46 = *(_QWORD *)(v45 + 8);
    if ((*(_BYTE *)(v46 + 24) & 0x20) != 0)
    {
      if (!v44)
      {
        MEMORY[0x212B9381C](**(unsigned int **)(*(_QWORD *)(v46 + 16) + 8));
        return 0;
      }
      return 0;
    }
    if (v44 - 1 < 0xFFFFFFFFFFFFFFFELL || *(_BYTE *)(v45 + 48))
      return 0;
    *((_QWORD *)v1 + 1) = 0;
    *((_QWORD *)v1 + 2) = 0;
    *((_WORD *)v1 + 12) = 0;
    goto LABEL_65;
  }
  if ((*(_BYTE *)(v35 + 24) & 1) == 0
    || !sub_20BDC588C(*(_QWORD *)(v35 + 16), (__int128 *)((char *)v1 + 8), 0, v14))
  {
    goto LABEL_66;
  }
  v36 = *((_QWORD *)v1 + 5);
  if ((*(_BYTE *)(v36 + 24) & 0x20) != 0)
  {
    while (1)
    {
      v36 = *(_QWORD *)(v36 + 8);
      if (!v36)
        break;
      v37 = *(_BYTE *)(v36 + 24);
      if ((v37 & 0x20) == 0)
      {
        *((_QWORD *)v1 + 5) = v36;
        v38 = *(_QWORD **)(v36 + 16);
        v39 = v38 + 4;
        v40 = (unsigned int *)((unint64_t)(v38 + 4) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_50:
        v41 = *v40 & ~(255 << (8 * (((_BYTE)v38 + 32) & 3)));
        do
        {
          while (1)
          {
            v42 = __ldaxr(v40);
            if (v42 == v41)
              break;
            __clrex();
            if (*v40 != v41)
            {
              sched_yield();
              goto LABEL_50;
            }
          }
        }
        while (__stlxr(v41 | (1 << (8 * (((_BYTE)v38 + 32) & 3))), v40));
        v48 = (v38[2] - 1) & v38[3];
        v49 = *v38 + 24 * v48;
        v51 = *(unsigned __int8 *)(v49 + 17);
        v50 = (_BYTE *)(v49 + 17);
        if (!v51)
        {
          __dmb(0xBu);
          *v39 = 0;
          break;
        }
        v52 = *v38 + 24 * v48;
        v53 = *(_OWORD *)v52;
        *((_QWORD *)v1 + 3) = *(_QWORD *)(v52 + 16);
        *(_OWORD *)((char *)v1 + 8) = v53;
        *v50 = 0;
        if ((v37 & 1) == 0)
          ++v38[3];
        __dmb(0xBu);
        *v39 = 0;
        goto LABEL_66;
      }
    }
  }
  *((_QWORD *)v1 + 5) = 0;
  return 0;
}

uint64_t sub_20BDC56C8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _BYTE *v6;
  unsigned int *v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  __int128 *v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  __int128 v17;
  int v18;
  __int16 v19;
  _QWORD v20[2];
  __int128 v21;
  char v22;
  uint64_t v23;

  v5 = result;
  v23 = *MEMORY[0x24BDAC8D0];
  v21 = 0uLL;
  v22 = 0;
  v6 = (_BYTE *)(result + 32);
  v7 = (unsigned int *)((result + 32) & 0xFFFFFFFFFFFFFFFCLL);
  v8 = 1 << (8 * ((result + 32) & 3));
  v9 = ~(255 << (8 * ((result + 32) & 3)));
LABEL_2:
  v10 = *v7 & v9;
  do
  {
    while (1)
    {
      v11 = __ldaxr(v7);
      if (v11 == v10)
        break;
      __clrex();
      if (*v7 != v10)
      {
        result = sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v10 | v8, v7));
  if (*(_BYTE *)(v5 + 48))
  {
    if (*(_QWORD *)(v5 + 24) != a2)
    {
      __dmb(0xBu);
      *v6 = 0;
      return result;
    }
  }
  else
  {
    a2 = *(_QWORD *)(v5 + 24);
  }
  v12 = *(_QWORD *)v5;
  *(_QWORD *)(v5 + 24) = a2 + 1;
  v13 = (__int128 *)(v12 + 24 * ((*(_QWORD *)(v5 + 16) - 1) & (a2 + 1)));
  v21 = *v13;
  v22 = *((_BYTE *)v13 + 16);
  v14 = *((unsigned __int8 *)v13 + 17);
  v18 = *(_DWORD *)((char *)v13 + 18);
  v19 = *((_WORD *)v13 + 11);
  *((_BYTE *)v13 + 17) = 0;
  __dmb(0xBu);
  *(_BYTE *)(v5 + 32) = 0;
  if (v14)
  {
    v15 = *(_QWORD *)(a3 - 32);
    v20[0] = 0;
    v20[1] = v15;
    v16 = tbb::internal::allocate_additional_child_of_proxy::allocate((tbb::internal::allocate_additional_child_of_proxy *)v20, 0x38uLL);
    *(_BYTE *)(v16 - 11) = 1;
    v17 = *(_OWORD *)(a3 + 32);
    *(_BYTE *)(v16 + 24) = v22;
    *(_OWORD *)(v16 + 8) = v21;
    *(_BYTE *)(v16 + 25) = v14;
    *(_WORD *)(v16 + 30) = v19;
    *(_DWORD *)(v16 + 26) = v18;
    *(_QWORD *)v16 = &off_24C515E88;
    *(_OWORD *)(v16 + 32) = v17;
    *(_BYTE *)(v16 + 48) = 0;
    return (***(uint64_t (****)(_QWORD, unint64_t, uint64_t))(v16 - 40))(*(_QWORD *)(v16 - 40), v16, v16 - 8);
  }
  return result;
}

uint64_t sub_20BDC588C(uint64_t a1, __int128 *a2, int a3, void *a4)
{
  _BYTE *v7;
  unsigned int *v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t result;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  void *v24;
  tbb::internal *v25;
  _BYTE *v26;
  unint64_t v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  unint64_t v31;
  __int128 v32;
  unint64_t v33;

  *((_BYTE *)a2 + 17) = 1;
  v7 = (_BYTE *)(a1 + 32);
  v8 = (unsigned int *)((a1 + 32) & 0xFFFFFFFFFFFFFFFCLL);
  v9 = 1 << (8 * ((a1 + 32) & 3));
  v10 = ~(255 << (8 * ((a1 + 32) & 3)));
LABEL_2:
  v11 = *v8 & v10;
  do
  {
    while (1)
    {
      v12 = __ldaxr(v8);
      if (v12 == v11)
        break;
      __clrex();
      if (*v8 != v11)
      {
        sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v11 | v9, v8));
  v13 = *(_QWORD *)a1;
  v15 = *(_QWORD *)(a1 + 16);
  v14 = *(_QWORD *)(a1 + 24);
  v16 = v15 - 1;
  v17 = *(unsigned __int8 *)(*(_QWORD *)a1 + 24 * ((v15 - 1) & v14) + 17);
  if (*(_BYTE *)(a1 + 48))
  {
    if (*((_BYTE *)a2 + 16))
    {
      v18 = *((_QWORD *)a2 + 1);
      v19 = v18 - v14;
      if (v19)
        goto LABEL_18;
    }
    else
    {
      v18 = *(_QWORD *)(a1 + 40);
      *(_QWORD *)(a1 + 40) = v18 + 1;
      *((_QWORD *)a2 + 1) = v18;
      *((_BYTE *)a2 + 16) = 1;
      v19 = v18 - v14;
      if (v19)
        goto LABEL_18;
    }
  }
  else
  {
    v18 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(a1 + 40) = v18 + 1;
    v19 = v18 - v14;
    if (v19)
      goto LABEL_18;
  }
  if (!*(_BYTE *)(a1 + 49) && !a3)
  {
    result = 0;
    goto LABEL_36;
  }
LABEL_18:
  if (v19 < v15)
  {
    v21 = v15;
    goto LABEL_32;
  }
  v22 = v19 + 1;
  v23 = 2 * v15;
  if (!v15)
    v23 = 4;
  do
  {
    v21 = v23;
    v23 *= 2;
  }
  while (v21 < v22);
  v13 = tbb::internal::NFS_Allocate(v21, 24, 0, a4);
  v25 = *(tbb::internal **)a1;
  if (v21)
  {
    v26 = (_BYTE *)(v13 + 41);
    v27 = v21;
    do
    {
      *(v26 - 24) = 0;
      *v26 = 0;
      v26 += 48;
      v27 -= 2;
    }
    while (v27);
  }
  if (v15)
  {
    v28 = *(_QWORD *)(a1 + 24);
    do
    {
      v29 = (char *)v25 + 24 * (v28 & v16);
      v30 = *(_OWORD *)v29;
      v31 = v13 + 24 * (v28 & (v21 - 1));
      *(_QWORD *)(v31 + 16) = *((_QWORD *)v29 + 2);
      *(_OWORD *)v31 = v30;
      ++v28;
      --v15;
    }
    while (v15);
    *(_QWORD *)a1 = v13;
    *(_QWORD *)(a1 + 16) = v21;
  }
  else
  {
    *(_QWORD *)a1 = v13;
    *(_QWORD *)(a1 + 16) = v21;
    if (!v25)
      goto LABEL_32;
  }
  tbb::internal::NFS_Free(v25, v24);
  v13 = *(_QWORD *)a1;
  v21 = *(_QWORD *)(a1 + 16);
LABEL_32:
  v32 = *a2;
  v33 = v13 + 24 * ((v21 - 1) & v18);
  *(_QWORD *)(v33 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)v33 = v32;
  if (!v17 && *(_BYTE *)(a1 + 49))
    MEMORY[0x212B9381C](**(unsigned int **)(a1 + 8));
  result = 1;
LABEL_36:
  __dmb(0xBu);
  *v7 = 0;
  return result;
}

void sub_20BDC5AC0(_Unwind_Exception *a1)
{
  _BYTE *v1;

  __dmb(0xBu);
  *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t tbb::pipeline::clear_filters(uint64_t this)
{
  uint64_t i;
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  int v9;

  for (i = *(_QWORD *)(this + 8); i; i = *(_QWORD *)(i + 8))
  {
    if ((*(_BYTE *)(i + 24) & 0xC) != 0)
    {
      v2 = *(_QWORD **)(i + 16);
      if (v2)
      {
        v3 = v2[2];
        if (v3)
        {
          v4 = 0;
          v5 = v2[3];
          do
          {
            v6 = (v3 - 1) & (v5 + v4);
            v7 = *v2 + 24 * v6;
            v9 = *(unsigned __int8 *)(v7 + 17);
            v8 = (_BYTE *)(v7 + 17);
            if (v9)
            {
              this = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)i + 24))(i, *(_QWORD *)(*v2 + 24 * v6));
              *v8 = 0;
              v3 = v2[2];
            }
            ++v4;
          }
          while (v4 < v3);
        }
      }
    }
  }
  return this;
}

uint64_t tbb::pipeline::pipeline(uint64_t this)
{
  *(_WORD *)(this + 48) = 0;
  *(_QWORD *)this = off_24C515E10;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  __dmb(0xBu);
  *(_QWORD *)(this + 40) = 0;
  __dmb(0xBu);
  *(_QWORD *)(this + 32) = 0;
  return this;
}

{
  *(_WORD *)(this + 48) = 0;
  *(_QWORD *)this = off_24C515E10;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  __dmb(0xBu);
  *(_QWORD *)(this + 40) = 0;
  __dmb(0xBu);
  *(_QWORD *)(this + 32) = 0;
  return this;
}

void tbb::pipeline::~pipeline(tbb::pipeline *this, void *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unsigned int v7;

  *(_QWORD *)this = off_24C515E10;
  v3 = (_QWORD *)((char *)this + 8);
  v2 = *((_QWORD *)this + 1);
  while (v2)
  {
    v4 = v2;
    v5 = *(_QWORD *)(v2 + 16);
    if (v5)
    {
      v6 = (void *)sub_20BDC6714(v5, a2);
      operator delete(v6);
      *(_QWORD *)(v4 + 16) = 0;
    }
    v2 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(v4 + 8) = -1;
    v7 = *(_BYTE *)(v4 + 24) & 0xE;
    if ((*(_BYTE *)(v4 + 24) & 0xE) != 0)
    {
      *(_QWORD *)(v4 + 32) = -1;
      *(_QWORD *)(v4 + 40) = 0;
      if (v7 >= 6)
        *(_QWORD *)(v4 + 48) = 0;
    }
  }
  *v3 = 0;
  v3[1] = 0;
}

{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unsigned int v7;

  *(_QWORD *)this = off_24C515E10;
  v3 = (_QWORD *)((char *)this + 8);
  v2 = *((_QWORD *)this + 1);
  while (v2)
  {
    v4 = v2;
    v5 = *(_QWORD *)(v2 + 16);
    if (v5)
    {
      v6 = (void *)sub_20BDC6714(v5, a2);
      operator delete(v6);
      *(_QWORD *)(v4 + 16) = 0;
    }
    v2 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(v4 + 8) = -1;
    v7 = *(_BYTE *)(v4 + 24) & 0xE;
    if ((*(_BYTE *)(v4 + 24) & 0xE) != 0)
    {
      *(_QWORD *)(v4 + 32) = -1;
      *(_QWORD *)(v4 + 40) = 0;
      if (v7 >= 6)
        *(_QWORD *)(v4 + 48) = 0;
    }
  }
  *v3 = 0;
  v3[1] = 0;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unsigned int v7;

  *(_QWORD *)this = off_24C515E10;
  v3 = *((_QWORD *)this + 1);
  while (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)(v3 + 16);
    if (v5)
    {
      v6 = (void *)sub_20BDC6714(v5, a2);
      operator delete(v6);
      *(_QWORD *)(v4 + 16) = 0;
    }
    v3 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(v4 + 8) = -1;
    v7 = *(_BYTE *)(v4 + 24) & 0xE;
    if ((*(_BYTE *)(v4 + 24) & 0xE) != 0)
    {
      *(_QWORD *)(v4 + 32) = -1;
      *(_QWORD *)(v4 + 40) = 0;
      if (v7 >= 6)
        *(_QWORD *)(v4 + 48) = 0;
    }
  }
  operator delete(this);
}

void tbb::pipeline::clear(tbb::pipeline *this, void *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unsigned int v7;

  v3 = (_QWORD *)((char *)this + 8);
  v2 = *((_QWORD *)this + 1);
  while (v2)
  {
    v4 = v2;
    v5 = *(_QWORD *)(v2 + 16);
    if (v5)
    {
      v6 = (void *)sub_20BDC6714(v5, a2);
      operator delete(v6);
      *(_QWORD *)(v4 + 16) = 0;
    }
    v2 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(v4 + 8) = -1;
    v7 = *(_BYTE *)(v4 + 24) & 0xE;
    if ((*(_BYTE *)(v4 + 24) & 0xE) != 0)
    {
      *(_QWORD *)(v4 + 32) = -1;
      *(_QWORD *)(v4 + 40) = 0;
      if (v7 >= 6)
        *(_QWORD *)(v4 + 48) = 0;
    }
  }
  *v3 = 0;
  v3[1] = 0;
}

uint64_t tbb::pipeline::add_filter(uint64_t this, tbb::filter *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  _QWORD *v9;
  void *v10;
  void *v11;
  pthread_key_t *v12;
  void *v13;
  const char *v14;

  v3 = *((unsigned __int8 *)a2 + 24);
  if ((v3 & 0xE) == 0)
  {
    v9 = *(_QWORD **)(this + 16);
    if (!v9)
    {
      v9 = (_QWORD *)(this + 8);
      *(_QWORD *)(this + 16) = this + 8;
    }
    *v9 = a2;
    *(_QWORD *)(this + 16) = (char *)a2 + 8;
    *((_QWORD *)a2 + 1) = 0;
    goto LABEL_13;
  }
  v5 = *(_QWORD *)(this + 8);
  v4 = *(_QWORD *)(this + 16);
  *((_QWORD *)a2 + 4) = v4;
  *((_QWORD *)a2 + 5) = this;
  if (v5)
    v6 = v4;
  else
    v6 = this;
  *(_QWORD *)(v6 + 8) = a2;
  *((_QWORD *)a2 + 1) = 0;
  *(_QWORD *)(this + 16) = a2;
  if ((v3 & 0xEu) <= 5)
  {
LABEL_13:
    if ((v3 & 1) == 0)
      return this;
    v7 = operator new(0x48uLL);
    this = sub_20BDC6788((uint64_t)v7, (v3 & 0x11111111) == 1, 0, v10);
    goto LABEL_18;
  }
  if ((v3 & 1) != 0)
  {
    if ((v3 & 0x20) != 0)
      *(_BYTE *)(this + 49) = 1;
    v7 = operator new(0x48uLL);
    this = sub_20BDC6788((uint64_t)v7, (v3 & 0x11111111) == 1, (v3 & 0x20) != 0, v11);
LABEL_18:
    *((_QWORD *)a2 + 2) = v7;
    return this;
  }
  if (v4)
  {
    if ((*(_BYTE *)(v4 + 24) & 0x20) == 0)
      return this;
    v7 = operator new(0x48uLL);
    this = sub_20BDC6788((uint64_t)v7, 0, 0, v8);
    goto LABEL_18;
  }
  if ((v3 & 0x40) != 0)
  {
    v12 = (pthread_key_t *)operator new(0x48uLL);
    sub_20BDC6788((uint64_t)v12, 0, 0, v13);
    *((_QWORD *)a2 + 2) = v12;
    this = pthread_key_create(v12 + 7, 0);
    if ((_DWORD)this)
      tbb::internal::handle_perror((tbb::internal *)this, "TLS not allocated for filter", v14);
    *((_BYTE *)v12 + 64) = 1;
  }
  return this;
}

void sub_20BDC5F3C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void tbb::pipeline::remove_filter(tbb::filter **this, tbb::filter *a2)
{
  tbb::filter **v3;
  char *v4;
  tbb::filter *v5;
  _QWORD *v6;
  uint64_t v7;
  void *v8;

  if (this[1] == a2)
    v3 = this;
  else
    v3 = (tbb::filter **)*((_QWORD *)a2 + 4);
  v3[1] = (tbb::filter *)*((_QWORD *)a2 + 1);
  v5 = this[2];
  v4 = (char *)(this + 2);
  if (v5 == a2)
    v6 = v4;
  else
    v6 = (_QWORD *)(*((_QWORD *)a2 + 1) + 32);
  *v6 = *((_QWORD *)a2 + 4);
  v7 = *((_QWORD *)a2 + 2);
  if (v7)
  {
    v8 = (void *)sub_20BDC6714(v7, a2);
    operator delete(v8);
    *((_QWORD *)a2 + 2) = 0;
  }
  *((_QWORD *)a2 + 4) = -1;
  *((_QWORD *)a2 + 1) = -1;
  if ((*((_BYTE *)a2 + 24) & 0xEu) >= 6)
    *((_QWORD *)a2 + 6) = 0;
  *((_QWORD *)a2 + 5) = 0;
}

uint64_t *tbb::pipeline::run(uint64_t *this, uint64_t a2, tbb::task_group_context *a3)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t j;
  tbb::task_group_context *v10;
  uint64_t *v11;

  if (this[1])
  {
    v4 = this;
    v11 = this;
    *((_BYTE *)this + 48) = 0;
    __dmb(0xBu);
    this[4] = a2;
    if (*((_BYTE *)this + 49))
    {
      v5 = this[1];
      if ((*(_BYTE *)(v5 + 24) & 0x20) != 0)
        MEMORY[0x212B9381C](**(unsigned int **)(*(_QWORD *)(v5 + 16) + 8));
    }
    v10 = a3;
    v6 = tbb::internal::allocate_root_with_context_proxy::allocate(&v10, 0x18uLL);
    *(_BYTE *)(v6 - 11) = 1;
    *(_QWORD *)v6 = &unk_24C515F10;
    *(_QWORD *)(v6 + 8) = v4;
    *(_BYTE *)(v6 + 16) = 0;
    v7 = v4[1];
    if ((*(_BYTE *)(v7 + 24) & 0xEu) >= 6)
    {
      for (i = *(_QWORD *)(v7 + 8); i; i = *(_QWORD *)(i + 8))
      {
        if ((*(_BYTE *)(*(_QWORD *)(i + 32) + 24) & 0x20) != 0 && (*(_BYTE *)(i + 24) & 0x20) == 0)
        {
          *(_BYTE *)(v6 + 16) = 1;
          *(_QWORD *)(v7 + 48) = i;
          v7 = i;
        }
      }
    }
    v4[3] = v6;
    (*(void (**)(_QWORD, unint64_t, unint64_t))(**(_QWORD **)(v6 - 40) + 16))(*(_QWORD *)(v6 - 40), v6, v6 - 8);
    if (*((_BYTE *)v4 + 49))
    {
      for (j = *(_QWORD *)(v4[1] + 8); j; j = *(_QWORD *)(j + 8))
      {
        if ((*(_BYTE *)(j + 24) & 0x20) != 0)
          MEMORY[0x212B9381C](**(unsigned int **)(*(_QWORD *)(j + 16) + 8));
      }
    }
    return sub_20BDC6B2C((uint64_t *)&v11);
  }
  return this;
}

void sub_20BDC6120(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDC6B2C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void tbb::pipeline::run(tbb::pipeline *this, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4;
  unint64_t v7;
  _DWORD v8[32];
  uint64_t v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 1);
  if (v4)
  {
    v7 = (unint64_t)(*(_BYTE *)(v4 + 24) & 0x80) >> 7;
    v8[0] = 1;
    v9 = ((v7 & 1) << 16) | 3;
    v10 = 55;
    tbb::task_group_context::init((uint64_t)v8, a2, a3, a4);
    tbb::pipeline::run((uint64_t *)this, a2, (tbb::task_group_context *)v8);
    tbb::task_group_context::~task_group_context((tbb::task_group_context *)v8);
  }
}

void sub_20BDC61E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  tbb::task_group_context::~task_group_context((tbb::task_group_context *)va);
  _Unwind_Resume(a1);
}

BOOL tbb::filter::has_more_work(tbb::filter *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*((_QWORD *)this + 5) + 40);
  __dmb(0xBu);
  return v1 != *(_QWORD *)(*((_QWORD *)this + 2) + 24);
}

void tbb::filter::~filter(tbb::filter *this, void *a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  tbb::filter *v8;
  _QWORD *v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)this = &unk_24C515E30;
  v3 = *((_BYTE *)this + 24) & 0xE;
  if ((*((_BYTE *)this + 24) & 0xE) != 0)
  {
    v4 = *((_QWORD *)this + 1);
    if (v4 != -1)
    {
      v6 = *((_QWORD *)this + 4);
      v5 = *((_QWORD *)this + 5);
      if (*(tbb::filter **)(v5 + 8) == this)
        v6 = *((_QWORD *)this + 5);
      *(_QWORD *)(v6 + 8) = v4;
      v8 = *(tbb::filter **)(v5 + 16);
      v7 = (_QWORD *)(v5 + 16);
      if (v8 == this)
        v9 = v7;
      else
        v9 = (_QWORD *)(*((_QWORD *)this + 1) + 32);
      *v9 = *((_QWORD *)this + 4);
      v10 = *((_QWORD *)this + 2);
      if (v10)
      {
        v11 = (void *)sub_20BDC6714(v10, a2);
        operator delete(v11);
        *((_QWORD *)this + 2) = 0;
        v3 = *((_BYTE *)this + 24) & 0xE;
      }
      *((_QWORD *)this + 4) = -1;
      *((_QWORD *)this + 1) = -1;
      if (v3 >= 6)
        *((_QWORD *)this + 6) = 0;
      *((_QWORD *)this + 5) = 0;
    }
  }
}

uint64_t tbb::filter::set_end_of_input(uint64_t this)
{
  if ((*(_BYTE *)(this + 24) & 1) == 0)
    return pthread_setspecific(*(_QWORD *)(*(_QWORD *)(this + 16) + 56), (const void *)1);
  *(_BYTE *)(*(_QWORD *)(this + 40) + 48) = 1;
  return this;
}

uint64_t tbb::thread_bound_filter::process_item(tbb::thread_bound_filter *this)
{
  return tbb::thread_bound_filter::internal_process_item(this, 1);
}

uint64_t tbb::thread_bound_filter::internal_process_item(tbb::thread_bound_filter *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  unsigned int *v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  int v24;
  uint64_t v25;
  __int128 v26;
  void *v27;
  uint64_t v28;
  unsigned int *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;

  v41 = 0uLL;
  LOWORD(v42) = 0;
  v4 = *((_QWORD *)this + 5);
  if (*(_BYTE *)(v4 + 48))
  {
    v5 = *(_QWORD *)(v4 + 40);
    __dmb(0xBu);
    if (v5 == *(_QWORD *)(*((_QWORD *)this + 2) + 24))
      return 2;
  }
  if (*((_QWORD *)this + 4))
  {
    while (1)
    {
      v6 = *((_QWORD *)this + 2);
      v7 = (unsigned int *)((v6 + 32) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_5:
      v8 = *v7 & ~(255 << (8 * ((v6 + 32) & 3)));
      do
      {
        while (1)
        {
          v9 = __ldaxr(v7);
          if (v9 == v8)
            break;
          __clrex();
          if (*v7 != v8)
          {
            sched_yield();
            goto LABEL_5;
          }
        }
      }
      while (__stlxr(v8 | (1 << (8 * ((v6 + 32) & 3))), v7));
      v10 = *(unsigned __int8 *)(*(_QWORD *)v6 + 24 * ((*(_QWORD *)(v6 + 16) - 1) & *(_QWORD *)(v6 + 24)) + 17);
      __dmb(0xBu);
      *(_BYTE *)(v6 + 32) = 0;
      if (v10)
        break;
      if (!a2)
        return 1;
      v11 = *(unsigned int **)(*((_QWORD *)this + 2) + 8);
      while (MEMORY[0x212B93828](*v11) == 14)
        ;
      v12 = *((_QWORD *)this + 5);
      if (*(_BYTE *)(v12 + 48))
      {
        v13 = *(_QWORD *)(v12 + 40);
        __dmb(0xBu);
        if (v13 == *(_QWORD *)(*((_QWORD *)this + 2) + 24))
          return 2;
      }
    }
    v16 = *((_QWORD *)this + 2);
    v17 = (unsigned int *)((v16 + 32) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_21:
    v18 = *v17 & ~(255 << (8 * ((v16 + 32) & 3)));
    do
    {
      while (1)
      {
        v19 = __ldaxr(v17);
        if (v19 == v18)
          break;
        __clrex();
        if (*v17 != v18)
        {
          sched_yield();
          goto LABEL_21;
        }
      }
    }
    while (__stlxr(v18 | (1 << (8 * ((v16 + 32) & 3))), v17));
    v20 = *(_QWORD *)(v16 + 24);
    v21 = (*(_QWORD *)(v16 + 16) - 1) & v20;
    v22 = *(_QWORD *)v16 + 24 * v21;
    v24 = *(unsigned __int8 *)(v22 + 17);
    v23 = (_BYTE *)(v22 + 17);
    if (v24)
    {
      v25 = *(_QWORD *)v16 + 24 * v21;
      v26 = *(_OWORD *)v25;
      v42 = *(_QWORD *)(v25 + 16);
      v41 = v26;
      *v23 = 0;
      *(_QWORD *)(v16 + 24) = v20 + 1;
    }
    __dmb(0xBu);
    *(_BYTE *)(v16 + 32) = 0;
    *(_QWORD *)&v41 = (**(uint64_t (***)(tbb::thread_bound_filter *, _QWORD))this)(this, v41);
    goto LABEL_42;
  }
  v14 = *((_QWORD *)this + 5);
  if (*(_BYTE *)(v14 + 48))
    return 2;
  v28 = *(_QWORD *)(v14 + 32);
  __dmb(0xBu);
  if (!v28)
  {
    if (!a2)
      return 1;
    do
    {
      v29 = *(unsigned int **)(*((_QWORD *)this + 2) + 8);
      while (MEMORY[0x212B93828](*v29) == 14)
        ;
      v30 = *(_QWORD *)(*((_QWORD *)this + 5) + 32);
      __dmb(0xBu);
    }
    while (!v30);
  }
  *(_QWORD *)&v41 = (**(uint64_t (***)(tbb::thread_bound_filter *, _QWORD))this)(this, v41);
  v31 = *((_QWORD *)this + 5);
  if (!(_QWORD)v41)
  {
    *(_BYTE *)(v31 + 48) = 1;
    return 2;
  }
  v32 = (unint64_t *)(v31 + 32);
  do
    v33 = __ldaxr(v32);
  while (__stlxr(v33 - 1, v32));
  if ((*((_BYTE *)this + 24) & 0x11) == 1)
  {
    v34 = *(_QWORD *)(*((_QWORD *)this + 5) + 40);
    __dmb(0xBu);
    *((_QWORD *)&v41 + 1) = v34;
    LOBYTE(v42) = 1;
  }
  v35 = (unint64_t *)(*((_QWORD *)this + 5) + 40);
  do
    v36 = __ldaxr(v35);
  while (__stlxr(v36 + 1, v35));
LABEL_42:
  v37 = *((_QWORD *)this + 1);
  if (v37)
  {
    sub_20BDC588C(*(_QWORD *)(v37 + 16), &v41, 1, v27);
    return 0;
  }
  v38 = (unint64_t *)(*((_QWORD *)this + 5) + 32);
  do
    v39 = __ldaxr(v38);
  while (__stlxr(v39 + 1, v38));
  result = 0;
  v40 = *(_QWORD *)(*((_QWORD *)this + 5) + 8);
  if ((*(_BYTE *)(v40 + 24) & 0x20) != 0 && !v39)
  {
    MEMORY[0x212B9381C](**(unsigned int **)(*(_QWORD *)(v40 + 16) + 8));
    return 0;
  }
  return result;
}

uint64_t tbb::thread_bound_filter::try_process_item(tbb::thread_bound_filter *this)
{
  return tbb::thread_bound_filter::internal_process_item(this, 0);
}

_QWORD *sub_20BDC6660(_QWORD *a1)
{
  _BYTE *v2;

  *a1 = &off_24C515E88;
  v2 = (_BYTE *)a1[5];
  if (v2 && a1[1] && (v2[24] & 0xC) != 0)
  {
    (*(void (**)(_BYTE *))(*(_QWORD *)v2 + 24))(v2);
    a1[1] = 0;
  }
  return a1;
}

void sub_20BDC66BC(_QWORD *__p)
{
  _BYTE *v2;

  *__p = &off_24C515E88;
  v2 = (_BYTE *)__p[5];
  if (v2 && __p[1] && (v2[24] & 0xC) != 0)
    (*(void (**)(_BYTE *))(*(_QWORD *)v2 + 24))(v2);
  operator delete(__p);
}

uint64_t sub_20BDC6714(uint64_t a1, void *a2)
{
  semaphore_t *v3;
  tbb::internal *v4;
  const char *v5;

  tbb::internal::NFS_Free(*(tbb::internal **)a1, a2);
  v3 = *(semaphore_t **)(a1 + 8);
  if (v3)
  {
    semaphore_destroy(*MEMORY[0x24BDAEC58], *v3);
    operator delete(v3);
  }
  if (*(_BYTE *)(a1 + 64))
  {
    v4 = (tbb::internal *)pthread_key_delete(*(_QWORD *)(a1 + 56));
    if ((_DWORD)v4)
      tbb::internal::handle_perror(v4, "Failed to destroy filter TLS", v5);
  }
  return a1;
}

uint64_t sub_20BDC6788(uint64_t a1, char a2, char a3, void *a4)
{
  void *v5;
  _BYTE *v6;
  tbb::internal *v7;
  semaphore_t *v8;

  *(_QWORD *)(a1 + 40) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 48) = a2;
  *(_BYTE *)(a1 + 49) = a3;
  *(_BYTE *)(a1 + 64) = 0;
  v6 = (_BYTE *)tbb::internal::NFS_Allocate(4uLL, 24, 0, a4);
  v7 = *(tbb::internal **)a1;
  v6[17] = 0;
  v6[41] = 0;
  v6[65] = 0;
  v6[89] = 0;
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + 16) = 4;
  if (v7)
    tbb::internal::NFS_Free(v7, v5);
  if (*(_BYTE *)(a1 + 49))
  {
    v8 = (semaphore_t *)operator new(4uLL);
    *v8 = 0;
    semaphore_create(*MEMORY[0x24BDAEC58], v8, 0, 0);
    *(_QWORD *)(a1 + 8) = v8;
  }
  return a1;
}

void sub_20BDC6838(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

tbb::internal::allocate_child_proxy *sub_20BDC6850(tbb::internal::allocate_child_proxy *this)
{
  tbb::internal::allocate_child_proxy *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  char v15;
  _BYTE *v16;
  unsigned int *v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  int v24;
  uint64_t v25;
  tbb::internal::allocate_child_proxy *v26;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t *v31;
  __int128 v32;
  uint64_t v33;

  v1 = this;
  v2 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v2 + 48) && (*(_BYTE *)(*(_QWORD *)(v2 + 8) + 24) & 0x20) == 0)
  {
    v3 = *(_QWORD *)(v2 + 32);
    __dmb(0xBu);
    if (v3)
    {
      *((_BYTE *)this - 12) = 3;
      *((_QWORD *)this - 3) = 1;
      v4 = tbb::internal::allocate_child_proxy::allocate(this, 0x38uLL);
      v5 = *((_QWORD *)v1 + 1);
      *(_BYTE *)(v4 - 11) = 1;
      *(_QWORD *)v4 = &off_24C515E88;
      *(_QWORD *)(v4 + 32) = v5;
      *(_QWORD *)(v4 + 40) = *(_QWORD *)(v5 + 8);
      *(_BYTE *)(v4 + 48) = 1;
      *(_QWORD *)(v4 + 8) = 0;
      *(_QWORD *)(v4 + 16) = 0;
      *(_WORD *)(v4 + 24) = 0;
      return (tbb::internal::allocate_child_proxy *)v4;
    }
  }
  v6 = *((_QWORD *)this + 1);
  if (!*((_BYTE *)this + 16))
  {
    if (!*(_BYTE *)(v6 + 48))
    {
      *((_BYTE *)this - 12) = 3;
      return v1;
    }
    return 0;
  }
  v7 = *(_QWORD *)(v6 + 8);
  v8 = *(_QWORD *)(v7 + 48);
  if (!v8)
    return 0;
  v28 = *(_QWORD *)(v7 + 48);
  while (1)
  {
    if (*(_BYTE *)(*((_QWORD *)v1 + 1) + 48))
    {
      v9 = *(_QWORD *)(*(_QWORD *)(v8 + 40) + 40);
      __dmb(0xBu);
      if (v9 == *(_QWORD *)(*(_QWORD *)(v8 + 16) + 24))
      {
        v8 = *(_QWORD *)(v28 + 48);
        v28 = v8;
        goto LABEL_9;
      }
    }
    v29 = 0;
    v30 = 0;
    v10 = 0;
    v32 = 0uLL;
    LOWORD(v33) = 0;
    v31 = (unint64_t *)&v30;
    while (1)
    {
      v14 = *(_QWORD **)(v8 + 16);
      v15 = *(_BYTE *)(v8 + 24);
      v16 = v14 + 4;
      v17 = (unsigned int *)((unint64_t)(v14 + 4) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_17:
      v18 = *v17 & ~(255 << (8 * (((_BYTE)v14 + 32) & 3)));
      do
      {
        while (1)
        {
          v19 = __ldaxr(v17);
          if (v19 == v18)
            break;
          __clrex();
          if (*v17 != v18)
          {
            sched_yield();
            goto LABEL_17;
          }
        }
      }
      while (__stlxr(v18 | (1 << (8 * (((_BYTE)v14 + 32) & 3))), v17));
      v20 = v14[3];
      v21 = (v14[2] - 1) & v20;
      v22 = *v14 + 24 * v21;
      v24 = *(unsigned __int8 *)(v22 + 17);
      v23 = (_BYTE *)(v22 + 17);
      if (!v24)
        break;
      v25 = *v14 + 24 * v21;
      v32 = *(_OWORD *)v25;
      v33 = *(_QWORD *)(v25 + 16);
      *v23 = 0;
      if ((v15 & 1) == 0)
        v14[3] = v20 + 1;
      __dmb(0xBu);
      *v16 = 0;
      v11 = tbb::internal::allocate_child_proxy::allocate(v1, 0x38uLL);
      v12 = *((_QWORD *)v1 + 1);
      *(_BYTE *)(v11 - 11) = 1;
      v13 = v33;
      *(_OWORD *)(v11 + 8) = v32;
      *(_QWORD *)v11 = &off_24C515E88;
      *(_QWORD *)(v11 + 24) = v13;
      *(_QWORD *)(v11 + 32) = v12;
      *(_QWORD *)(v11 + 40) = v8;
      *(_BYTE *)(v11 + 48) = 0;
      if (v10)
      {
        *(_QWORD *)(v11 - 8) = 0;
        *v31 = v11;
        v31 = (unint64_t *)(v11 - 8);
      }
      else
      {
        v29 = v11;
      }
      ++v10;
      v32 = 0uLL;
      LOWORD(v33) = 0;
    }
    __dmb(0xBu);
    *v16 = 0;
    if (v10)
      break;
    v8 = *(_QWORD *)(v8 + 48);
    if (!v8)
    {
      if (!*(_BYTE *)(*((_QWORD *)v1 + 1) + 48))
      {
        v26 = v1;
        goto LABEL_39;
      }
      sched_yield();
      v8 = v28;
    }
LABEL_9:
    if (!v8)
      return 0;
  }
  *((_QWORD *)v1 - 3) = v10;
  if (v10 != 1 && v30)
    (***(void (****)(_QWORD, uint64_t, unint64_t *))(v30 - 40))(*(_QWORD *)(v30 - 40), v30, v31);
  v26 = (tbb::internal::allocate_child_proxy *)v29;
LABEL_39:
  *((_BYTE *)v1 - 12) = 3;
  return v26;
}

uint64_t *sub_20BDC6B2C(uint64_t *a1)
{
  _BOOL4 is_group_execution_cancelled;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  int v12;

  is_group_execution_cancelled = tbb::task_group_context::is_group_execution_cancelled(*(tbb::task_group_context **)(*(_QWORD *)(*a1 + 24) - 56));
  v3 = *a1;
  if (is_group_execution_cancelled)
  {
    v4 = *(_QWORD *)(v3 + 8);
    if (v4)
    {
      do
      {
        if ((*(_BYTE *)(v4 + 24) & 0xC) != 0)
        {
          v5 = *(_QWORD **)(v4 + 16);
          if (v5)
          {
            v6 = v5[2];
            if (v6)
            {
              v7 = 0;
              v8 = v5[3];
              do
              {
                v9 = (v6 - 1) & (v8 + v7);
                v10 = *v5 + 24 * v9;
                v12 = *(unsigned __int8 *)(v10 + 17);
                v11 = (_BYTE *)(v10 + 17);
                if (v12)
                {
                  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 24))(v4, *(_QWORD *)(*v5 + 24 * v9));
                  *v11 = 0;
                  v6 = v5[2];
                }
                ++v7;
              }
              while (v7 < v6);
            }
          }
        }
        v4 = *(_QWORD *)(v4 + 8);
      }
      while (v4);
      v3 = *a1;
    }
  }
  *(_QWORD *)(v3 + 24) = 0;
  return a1;
}

unint64_t **tbb::queuing_mutex::scoped_lock::acquire(unint64_t **result, unint64_t *a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v3 = (unint64_t)result;
  result[1] = 0;
  result[2] = 0;
  *result = a2;
LABEL_2:
  v4 = *a2;
  do
  {
    while (1)
    {
      v5 = __ldaxr(a2);
      if (v5 == v4)
        break;
      __clrex();
      do
        v6 = __ldxr(a2);
      while (__stxr(v6, a2));
      if (v6 != v4)
      {
        result = (unint64_t **)sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v3, a2));
  if (v4)
  {
    for (*(_QWORD *)(v4 + 8) = v3; !*(_QWORD *)(v3 + 16); result = (unint64_t **)sched_yield())
      ;
  }
  __dmb(0xBu);
  return result;
}

uint64_t tbb::queuing_mutex::scoped_lock::try_acquire(unint64_t **a1, unint64_t *a2)
{
  uint64_t v3;
  unint64_t v4;

  a1[1] = 0;
  a1[2] = 0;
  do
  {
    while (__ldaxr(a2))
    {
      v3 = 0;
      __clrex();
      do
        v4 = __ldxr(a2);
      while (__stxr(v4, a2));
      if (v4)
        return v3;
    }
  }
  while (__stlxr((unint64_t)a1, a2));
  v3 = 1;
  __dmb(0xBu);
  *a1 = a2;
  return v3;
}

unint64_t tbb::queuing_mutex::scoped_lock::release(unint64_t this)
{
  _QWORD *v1;
  uint64_t i;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;

  v1 = (_QWORD *)this;
  i = *(_QWORD *)(this + 8);
  if (i)
  {
LABEL_2:
    __dmb(0xBu);
    *(_QWORD *)(i + 16) = 1;
    goto LABEL_3;
  }
  v3 = *(unint64_t **)this;
  do
  {
    while (1)
    {
      v4 = __ldaxr(v3);
      if (v4 == this)
        break;
      __clrex();
      do
        v5 = __ldxr(v3);
      while (__stxr(v5, v3));
      if (v5 != this)
        goto LABEL_12;
    }
  }
  while (__stlxr(0, v3));
  v5 = this;
LABEL_12:
  if (v5 != this)
  {
    for (i = *(_QWORD *)(this + 8); !i; i = v1[1])
      this = sched_yield();
    goto LABEL_2;
  }
LABEL_3:
  *v1 = 0;
  v1[2] = 0;
  return this;
}

unint64_t tbb::queuing_rw_mutex::scoped_lock::acquire(unint64_t result, unint64_t *a2, int a3)
{
  unint64_t v5;
  char v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int *v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int *v17;
  char v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;

  v5 = result;
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_BYTE *)(result + 25) = 0;
  if (a3)
    v6 = 1;
  else
    v6 = 2;
  __dmb(0xBu);
  *(_BYTE *)(result + 24) = v6;
  v7 = result + 24;
  *(_BYTE *)(result + 26) = 0;
LABEL_5:
  v8 = *a2;
  do
  {
    while (1)
    {
      v9 = __ldaxr(a2);
      if (v9 == v8)
        break;
      __clrex();
      do
        v10 = __ldxr(a2);
      while (__stxr(v10, a2));
      if (v10 != v8)
      {
        result = sched_yield();
        goto LABEL_5;
      }
    }
  }
  while (__stlxr(v5, a2));
  if (a3)
  {
    if (v8)
    {
      __dmb(0xBu);
      *(_QWORD *)((v8 & 0xFFFFFFFFFFFFFFFELL) + 16) = v5;
      while (*(_BYTE *)(v5 + 25) != 1)
        result = sched_yield();
    }
    goto LABEL_46;
  }
  if (v8)
  {
    if ((v8 & 1) != 0)
    {
      *(_QWORD *)(v5 + 8) = v8 & 0xFFFFFFFFFFFFFFFELL;
      __dmb(0xBu);
      *(_QWORD *)((v8 & 0xFFFFFFFFFFFFFFFELL) + 16) = v5;
    }
    else
    {
      v11 = (unsigned int *)((v8 + 24) & 0xFFFFFFFFFFFFFFFCLL);
      v12 = 255 << (8 * ((v8 + 24) & 3));
      while (1)
      {
        v13 = *v11 & ~v12;
        v14 = v13 | (2 << (8 * ((v8 + 24) & 3)));
        v15 = v13 | (4 << (8 * ((v8 + 24) & 3)));
        do
        {
          while (1)
          {
            v16 = __ldaxr(v11);
            if (v16 != v14)
              break;
            if (!__stlxr(v15, v11))
              goto LABEL_29;
          }
          __clrex();
        }
        while (*v11 == v14);
        if (((*v11 ^ v14) & v12) != 0)
          break;
        result = sched_yield();
      }
      v14 = *v11;
LABEL_29:
      *(_QWORD *)(v5 + 8) = v8;
      __dmb(0xBu);
      *(_QWORD *)(v8 + 16) = v5;
      if (((v14 & v12) >> (8 * ((v8 + 24) & 3))) == 8)
        goto LABEL_33;
    }
    while (*(_BYTE *)(v5 + 25) != 1)
      result = sched_yield();
  }
LABEL_33:
  v17 = (unsigned int *)(v7 & 0xFFFFFFFFFFFFFFFCLL);
  v18 = 8 * (v7 & 3);
  v19 = 255 << v18;
  while (1)
  {
    v20 = *v17 & ~v19;
    v21 = v20 | (2 << v18);
    v22 = v20 | (8 << v18);
    do
    {
      while (1)
      {
        v23 = __ldaxr(v17);
        if (v23 != v21)
          break;
        if (!__stlxr(v22, v17))
          goto LABEL_42;
      }
      __clrex();
    }
    while (*v17 == v21);
    if (((*v17 ^ v21) & v19) != 0)
      break;
    result = sched_yield();
  }
  v21 = *v17;
LABEL_42:
  if (((v21 & v19) >> v18) != 2)
  {
    for (; !*(_QWORD *)(v5 + 16); result = sched_yield())
      ;
    __dmb(0xBu);
    *(_BYTE *)(v5 + 24) = 8;
    v24 = *(_QWORD *)(v5 + 16);
    __dmb(0xBu);
    *(_BYTE *)(v24 + 25) = 1;
  }
LABEL_46:
  __dmb(0xBu);
  return result;
}

uint64_t tbb::queuing_rw_mutex::scoped_lock::try_acquire(unint64_t a1, unint64_t *a2, int a3)
{
  char v3;
  unint64_t v5;

  if (*a2)
    return 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 25) = 0;
  if (a3)
    v3 = 1;
  else
    v3 = 8;
  __dmb(0xBu);
  *(_BYTE *)(a1 + 24) = v3;
  *(_BYTE *)(a1 + 26) = 0;
  do
  {
    while (__ldaxr(a2))
    {
      __clrex();
      do
        v5 = __ldxr(a2);
      while (__stxr(v5, a2));
      if (v5)
        return 0;
    }
  }
  while (__stlxr(a1, a2));
  __dmb(0xBu);
  *(_QWORD *)a1 = a2;
  return 1;
}

uint64_t tbb::queuing_rw_mutex::scoped_lock::release(uint64_t this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _BYTE *v9;
  unsigned int *v10;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int *v17;
  int v18;
  unsigned int v19;
  unsigned int *v20;
  int v21;
  unsigned int v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  int v35;
  _BYTE *v36;
  unsigned int *v37;
  int v38;
  unsigned int v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;

  v1 = this;
  v2 = *(unsigned __int8 *)(this + 24);
  __dmb(0xBu);
  if (v2 == 1)
  {
    v3 = *(_QWORD *)(this + 16);
    __dmb(0xBu);
    if (!v3)
    {
      v4 = *(unint64_t **)this;
      do
      {
        while (1)
        {
          v5 = __ldaxr(v4);
          if (v5 == this)
            break;
          __clrex();
          do
            v6 = __ldxr(v4);
          while (__stxr(v6, v4));
          if (v6 != this)
            goto LABEL_77;
        }
      }
      while (__stlxr(0, v4));
      v6 = this;
LABEL_77:
      if (v6 == this)
        goto LABEL_125;
      while (!*(_QWORD *)(v1 + 16))
        this = sched_yield();
      v3 = *(_QWORD *)(v1 + 16);
      __dmb(0xBu);
    }
    *(_BYTE *)(v3 + 25) = 2;
    v35 = *(unsigned __int8 *)(v3 + 24);
    __dmb(0xBu);
    if (v35 == 32)
    {
      v36 = (_BYTE *)(v1 + 26);
      v37 = (unsigned int *)((v1 + 26) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_84:
      v38 = *v37 & ~(255 << (8 * ((v1 + 26) & 3)));
      do
      {
        while (1)
        {
          v39 = __ldaxr(v37);
          if (v39 == v38)
            break;
          __clrex();
          if (*v37 != v38)
          {
            this = sched_yield();
            goto LABEL_84;
          }
        }
      }
      while (__stlxr(v38 | (1 << (8 * ((v1 + 26) & 3))), v37));
      v40 = (unint64_t *)(v3 + 8);
LABEL_91:
      v41 = *v40;
      do
      {
        while (1)
        {
          v42 = __ldaxr(v40);
          if (v42 == v41)
            break;
          __clrex();
          do
            v43 = __ldxr(v40);
          while (__stxr(v43, v40));
          if (v43 != v41)
          {
            this = sched_yield();
            goto LABEL_91;
          }
        }
      }
      while (__stlxr(0, v40));
      __dmb(0xBu);
      *(_BYTE *)(v3 + 24) = 64;
      __dmb(0xBu);
      *(_BYTE *)(v3 + 25) = 1;
      if ((v41 & 1) != 0)
      {
        while (*v36)
          this = sched_yield();
      }
      else
      {
        __dmb(0xBu);
        *v36 = 0;
      }
    }
    else
    {
      *(_QWORD *)(v3 + 8) = 0;
      __dmb(0xBu);
      *(_BYTE *)(v3 + 25) = 1;
    }
    goto LABEL_125;
  }
  v7 = (unint64_t *)(this + 8);
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 + 1, v7));
  if (v8)
  {
    while (2)
    {
      v9 = (_BYTE *)(v8 + 26);
      v10 = (unsigned int *)((v8 + 26) & 0xFFFFFFFFFFFFFFFCLL);
      v11 = 255 << (8 * ((v8 + 26) & 3));
      while (2)
      {
        v12 = *v10 & ~v11;
        do
        {
          while (1)
          {
            v13 = __ldaxr(v10);
            if (v13 != v12)
              break;
            if (!__stlxr(v12 | (1 << (8 * ((v8 + 26) & 3))), v10))
            {
              *(_QWORD *)(v1 + 8) = v8;
              v20 = (unsigned int *)((v1 + 26) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_42:
              v21 = *v20 & ~(255 << (8 * ((v1 + 26) & 3)));
              do
              {
                while (1)
                {
                  v22 = __ldaxr(v20);
                  if (v22 == v21)
                    break;
                  __clrex();
                  if (*v20 != v21)
                  {
                    this = sched_yield();
                    goto LABEL_42;
                  }
                }
              }
              while (__stlxr(v21 | (1 << (8 * ((v1 + 26) & 3))), v20));
              __dmb(0xBu);
              *(_QWORD *)(v8 + 16) = 0;
              if (!*(_QWORD *)(v1 + 16))
              {
                v32 = *(unint64_t **)v1;
                do
                {
                  while (1)
                  {
                    v33 = __ldaxr(v32);
                    if (v33 == v1)
                      break;
                    __clrex();
                    do
                      v34 = __ldxr(v32);
                    while (__stxr(v34, v32));
                    if (v34 != v1)
                      goto LABEL_103;
                  }
                }
                while (__stlxr(v8, v32));
                v34 = v1;
LABEL_103:
                if (v34 != v1 && !*(_QWORD *)(v1 + 16))
                {
                  do
                    this = sched_yield();
                  while (!*(_QWORD *)(v1 + 16));
                }
              }
              v23 = *(_QWORD *)(v1 + 16);
              __dmb(0xBu);
              if (v23)
              {
                v24 = (unint64_t *)(v23 + 8);
LABEL_51:
                v23 = *v24;
                do
                {
                  while (1)
                  {
                    v25 = __ldaxr(v24);
                    if (v25 == v23)
                      break;
                    __clrex();
                    do
                      v26 = __ldxr(v24);
                    while (__stxr(v26, v24));
                    if (v26 != v23)
                    {
                      this = sched_yield();
                      goto LABEL_51;
                    }
                  }
                }
                while (__stlxr(v8, v24));
                v27 = *(_QWORD *)(v1 + 16);
                __dmb(0xBu);
                *(_QWORD *)(v8 + 16) = v27;
              }
              __dmb(0xBu);
              *v9 = 0;
              if ((v23 & 1) != 0)
                goto LABEL_108;
              goto LABEL_123;
            }
          }
          __clrex();
        }
        while (*v10 == v12);
        if ((*v10 & v11) == 0)
        {
          this = sched_yield();
          continue;
        }
        break;
      }
      v14 = v8 | 1;
      do
      {
        while (1)
        {
          v15 = __ldaxr(v7);
          if (v15 != v14)
            break;
          if (!__stlxr(v8, v7))
            goto LABEL_33;
        }
        __clrex();
        do
          v16 = __ldxr(v7);
        while (__stxr(v16, v7));
      }
      while (v16 == v14);
      if ((v16 & 1) == 0)
      {
        while (*v7 == v14)
          this = sched_yield();
        __dmb(0xBu);
        *v9 = 0;
      }
      do
LABEL_33:
        v8 = __ldaxr(v7);
      while (__stlxr(v8 + 1, v7));
      if (v8)
        continue;
      break;
    }
  }
  v17 = (unsigned int *)((v1 + 26) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_36:
  v18 = *v17 & ~(255 << (8 * ((v1 + 26) & 3)));
  do
  {
    while (1)
    {
      v19 = __ldaxr(v17);
      if (v19 == v18)
        break;
      __clrex();
      if (*v17 != v18)
      {
        this = sched_yield();
        goto LABEL_36;
      }
    }
  }
  while (__stlxr(v18 | (1 << (8 * ((v1 + 26) & 3))), v17));
  v28 = *(_QWORD *)(v1 + 16);
  __dmb(0xBu);
  if (!v28)
  {
    v29 = *(unint64_t **)v1;
    do
    {
      while (1)
      {
        v30 = __ldaxr(v29);
        if (v30 != v1)
          break;
        if (!__stlxr(0, v29))
          goto LABEL_123;
      }
      __clrex();
      do
        v31 = __ldxr(v29);
      while (__stxr(v31, v29));
    }
    while (v31 == v1);
    while (!*(_QWORD *)(v1 + 16))
      this = sched_yield();
    v28 = *(_QWORD *)(v1 + 16);
  }
  *(_BYTE *)(v28 + 25) = 2;
  v44 = (unint64_t *)(v28 + 8);
LABEL_115:
  v45 = *v44;
  do
  {
    while (1)
    {
      v46 = __ldaxr(v44);
      if (v46 == v45)
        break;
      __clrex();
      do
        v47 = __ldxr(v44);
      while (__stxr(v47, v44));
      if (v47 != v45)
      {
        this = sched_yield();
        goto LABEL_115;
      }
    }
  }
  while (__stlxr(0, v44));
  __dmb(0xBu);
  *(_BYTE *)(v28 + 25) = 1;
  if ((v45 & 1) != 0)
  {
LABEL_108:
    while (*(_BYTE *)(v1 + 26))
      this = sched_yield();
  }
  else
  {
LABEL_123:
    __dmb(0xBu);
    *(_BYTE *)(v1 + 26) = 0;
  }
LABEL_125:
  while (*(_BYTE *)(v1 + 25) == 2)
    this = sched_yield();
  *(_QWORD *)v1 = 0;
  *(_WORD *)(v1 + 25) = 0;
  return this;
}

uint64_t tbb::queuing_rw_mutex::scoped_lock::downgrade_to_reader(tbb::queuing_rw_mutex::scoped_lock *this)
{
  int v1;
  unint64_t v2;
  tbb::queuing_rw_mutex::scoped_lock **v4;
  tbb::queuing_rw_mutex::scoped_lock *v5;
  unsigned int *v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  char v13;
  int v14;

  v2 = (unint64_t)this + 24;
  v1 = *((unsigned __int8 *)this + 24);
  __dmb(0xBu);
  if (v1 == 8)
    return 1;
  __dmb(0xBu);
  *((_BYTE *)this + 24) = 2;
  if (*((_QWORD *)this + 2))
    goto LABEL_17;
  v4 = *(tbb::queuing_rw_mutex::scoped_lock ***)this;
  __dmb(0xBu);
  v5 = *v4;
  __dmb(0xBu);
  if (v5 != this)
    goto LABEL_16;
  v6 = (unsigned int *)(v2 & 0xFFFFFFFFFFFFFFFCLL);
  v7 = 255 << (8 * (v2 & 3));
  while (1)
  {
    v8 = *v6 & ~v7;
    v9 = v8 | (2 << (8 * (v2 & 3)));
    v10 = v8 | (8 << (8 * (v2 & 3)));
    do
    {
      while (1)
      {
        v11 = __ldaxr(v6);
        if (v11 != v9)
          break;
        if (!__stlxr(v10, v6))
          goto LABEL_13;
      }
      __clrex();
    }
    while (*v6 == v9);
    if (((*v6 ^ v9) & v7) != 0)
      break;
    sched_yield();
  }
  v9 = *v6;
LABEL_13:
  if (((v9 & v7) >> (8 * (v2 & 3))) != 2)
  {
LABEL_16:
    while (!*((_QWORD *)this + 2))
      sched_yield();
LABEL_17:
    v12 = *((_QWORD *)this + 2);
    __dmb(0xBu);
    v13 = *(_BYTE *)(v12 + 24);
    __dmb(0xBu);
    if ((v13 & 6) != 0)
    {
      __dmb(0xBu);
      *(_BYTE *)(v12 + 25) = 1;
    }
    else
    {
      v14 = *(unsigned __int8 *)(v12 + 24);
      __dmb(0xBu);
      if (v14 == 32)
      {
        __dmb(0xBu);
        *(_BYTE *)(v12 + 24) = 64;
      }
    }
    __dmb(0xBu);
    *(_BYTE *)v2 = 8;
  }
  return 1;
}

BOOL tbb::queuing_rw_mutex::scoped_lock::upgrade_to_writer(tbb::queuing_rw_mutex::scoped_lock *this)
{
  int v2;
  unint64_t v3;
  _BOOL8 result;
  _BYTE *v5;
  unsigned int *v6;
  unint64_t v7;
  unint64_t *v8;
  int v9;
  unsigned int v10;
  unint64_t *v11;
  tbb::queuing_rw_mutex::scoped_lock *v12;
  tbb::queuing_rw_mutex::scoped_lock *v13;
  unint64_t v14;
  char v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char v21;
  unint64_t v22;
  unint64_t *v23;
  _BYTE *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unsigned int *v29;
  int v30;
  int v31;
  unsigned int v32;
  char v33;
  int v34;
  unsigned int *v35;
  int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  unsigned int *v44;
  char v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  _BYTE *v53;

  v3 = (unint64_t)this + 24;
  v2 = *((unsigned __int8 *)this + 24);
  __dmb(0xBu);
  result = 1;
  if (v2 != 1)
  {
    __dmb(0xBu);
    *((_BYTE *)this + 24) = 16;
    v5 = (char *)this + 26;
    v6 = (unsigned int *)(((unint64_t)this + 26) & 0xFFFFFFFFFFFFFFFCLL);
    v7 = (unint64_t)this | 1;
    v8 = (unint64_t *)((char *)this + 16);
    v53 = (char *)this + 26;
LABEL_4:
    while (1)
    {
      v9 = *v6 & ~(255 << (8 * (((_BYTE)this + 26) & 3)));
      do
      {
        while (1)
        {
          v10 = __ldaxr(v6);
          if (v10 == v9)
            break;
          __clrex();
          if (*v6 != v9)
          {
            sched_yield();
            goto LABEL_4;
          }
        }
      }
      while (__stlxr(v9 | (1 << (8 * (((_BYTE)this + 26) & 3))), v6));
      v11 = *(unint64_t **)this;
      do
      {
        while (1)
        {
          v12 = (tbb::queuing_rw_mutex::scoped_lock *)__ldaxr(v11);
          if (v12 != this)
            break;
          if (!__stlxr(v7, v11))
          {
            __dmb(0xBu);
            *v5 = 0;
            goto LABEL_92;
          }
        }
        __clrex();
        do
          v13 = (tbb::queuing_rw_mutex::scoped_lock *)__ldxr(v11);
        while (__stxr((unint64_t)v13, v11));
      }
      while (v13 == this);
      while (!*v8)
        sched_yield();
      do
        v14 = __ldaxr(v8);
      while (__stlxr(v14 + 1, v8));
      v15 = *(_BYTE *)(v14 + 24);
      __dmb(0xBu);
      if ((v15 & 6) != 0)
      {
        __dmb(0xBu);
        *(_BYTE *)(v14 + 25) = 1;
      }
      v16 = (unint64_t *)(v14 + 8);
LABEL_20:
      v17 = *v16;
      do
      {
        while (1)
        {
          v18 = __ldaxr(v16);
          if (v18 == v17)
            break;
          __clrex();
          do
            v19 = __ldxr(v16);
          while (__stxr(v19, v16));
          if (v19 != v17)
          {
            sched_yield();
            goto LABEL_20;
          }
        }
      }
      while (__stlxr((unint64_t)this, v16));
      if ((v17 & 1) != 0)
      {
        v5 = (char *)this + 26;
        while (*v53)
          sched_yield();
      }
      else
      {
        __dmb(0xBu);
        v5 = (char *)this + 26;
        *v53 = 0;
      }
      if ((v15 & 0x1E) == 0)
        break;
      v20 = v14 | 1;
      while (*v8 == v20)
      {
        v21 = *(_BYTE *)v3;
        __dmb(0xBu);
        if ((v21 & 0x60) != 0)
        {
          v22 = *v8;
          __dmb(0xBu);
          if (v22 == v20)
            *v8 = v14;
          goto LABEL_40;
        }
        sched_yield();
      }
    }
    *v8 = v14;
LABEL_92:
    v44 = (unsigned int *)(v3 & 0xFFFFFFFFFFFFFFFCLL);
    v45 = 8 * (v3 & 3);
    v46 = 255 << v45;
    v47 = 16 << v45;
    v48 = 32 << v45;
    while (1)
    {
      v49 = *v44 & ~v46;
      v50 = v49 | v47;
      v51 = v49 | v48;
      do
      {
        while (1)
        {
          v52 = __ldaxr(v44);
          if (v52 != v50)
            break;
          if (!__stlxr(v51, v44))
            goto LABEL_40;
        }
        __clrex();
      }
      while (*v44 == v50);
      if (((*v44 ^ v50) & v46) != 0)
        break;
      sched_yield();
    }
LABEL_40:
    v23 = (unint64_t *)((char *)this + 8);
    while (1)
    {
      v25 = *(unint64_t **)this;
      do
      {
        while (1)
        {
          v26 = __ldaxr(v25);
          if (v26 != v7)
            break;
          if (!__stlxr((unint64_t)this, v25))
            goto LABEL_49;
        }
        __clrex();
        do
          v27 = __ldxr(v25);
        while (__stxr(v27, v25));
      }
      while (v27 == v7);
      do
LABEL_49:
        v28 = __ldaxr(v23);
      while (__stlxr(v28 + 1, v23));
      if (!v28)
        break;
      v29 = (unsigned int *)((v28 + 26) & 0xFFFFFFFFFFFFFFFCLL);
      v30 = 255 << (8 * ((v28 + 26) & 3));
      while (1)
      {
        v31 = *v29 & ~v30;
        do
        {
          while (1)
          {
            v32 = __ldaxr(v29);
            if (v32 != v31)
              break;
            if (!__stlxr(v31 | (1 << (8 * ((v28 + 26) & 3))), v29))
            {
              v33 = 1;
              goto LABEL_62;
            }
          }
          v33 = 0;
          __clrex();
        }
        while (*v29 == v31);
        if ((*v29 & v30) != 0)
          break;
        sched_yield();
      }
LABEL_62:
      v34 = 255 << (8 * ((v28 + 24) & 3));
      v35 = (unsigned int *)((v28 + 24) & 0xFFFFFFFFFFFFFFFCLL);
      while (1)
      {
        v36 = *v35 & ~v34;
        v37 = v36 | (16 << (8 * ((v28 + 24) & 3)));
        v38 = v36 | (32 << (8 * ((v28 + 24) & 3)));
        do
        {
          while (1)
          {
            v39 = __ldaxr(v35);
            if (v39 != v37)
              break;
            if (!__stlxr(v38, v35))
              goto LABEL_70;
          }
          __clrex();
        }
        while (*v35 == v37);
        if (((*v35 ^ v37) & v34) != 0)
          break;
        sched_yield();
      }
LABEL_70:
      if ((v33 & 1) != 0)
      {
        *v23 = v28;
        __dmb(0xBu);
        *(_BYTE *)(v28 + 26) = 0;
        v24 = (char *)this + 26;
        while (*v23 == v28)
          sched_yield();
LABEL_42:
        if (!*v23)
          goto LABEL_85;
      }
      else
      {
        v40 = v28 | 1;
        v24 = (char *)this + 26;
        do
        {
          while (1)
          {
            v41 = __ldaxr(v23);
            if (v41 != v40)
              break;
            if (!__stlxr(v28, v23))
              goto LABEL_80;
          }
          __clrex();
          do
            v42 = __ldxr(v23);
          while (__stxr(v42, v23));
        }
        while (v42 == v40);
        if ((v42 & 1) != 0)
        {
LABEL_80:
          while (*v23 == v28)
            sched_yield();
          goto LABEL_42;
        }
        while (*v23 == v40)
          sched_yield();
        __dmb(0xBu);
        *(_BYTE *)(v28 + 26) = 0;
      }
    }
    *v23 = 0;
    v24 = (char *)this + 26;
LABEL_85:
    while (*v24)
      sched_yield();
    while (*((_BYTE *)this + 25) == 2)
      sched_yield();
    __dmb(0xBu);
    v43 = *((unsigned __int8 *)this + 24);
    __dmb(0xBu);
    result = v43 != 64;
    __dmb(0xBu);
    *((_BYTE *)this + 24) = 1;
    *((_BYTE *)this + 25) = 1;
  }
  return result;
}

_QWORD *tbb::interface5::reader_writer_lock::internal_construct(_QWORD *this)
{
  __dmb(0xBu);
  *this = 0;
  __dmb(0xBu);
  this[1] = 0;
  __dmb(0xBu);
  this[2] = 0;
  __dmb(0xBu);
  this[4] = 0;
  this[3] = 0;
  return this;
}

uint64_t tbb::interface5::reader_writer_lock::lock(tbb::interface5::reader_writer_lock *this)
{
  _opaque_pthread_t *v2;
  uint64_t v3;

  v2 = (_opaque_pthread_t *)*((_QWORD *)this + 3);
  if (v2 == tbb::internal::thread_get_id_v3())
    return tbb::internal::throw_exception_v4(9);
  v3 = tbb::internal::allocate_via_handler_v3((tbb::internal *)0x18);
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(v3 + 16) = 1;
  return tbb::interface5::reader_writer_lock::start_write(this, (tbb::interface5::reader_writer_lock::scoped_lock *)v3);
}

BOOL tbb::interface5::reader_writer_lock::is_current_writer(tbb::interface5::reader_writer_lock *this)
{
  pthread_t v1;

  v1 = (pthread_t)*((_QWORD *)this + 3);
  return v1 == tbb::internal::thread_get_id_v3();
}

uint64_t tbb::interface5::reader_writer_lock::scoped_lock::scoped_lock(uint64_t this)
{
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(this + 16) = 1;
  return this;
}

{
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(this + 16) = 1;
  return this;
}

uint64_t tbb::interface5::reader_writer_lock::start_write(tbb::interface5::reader_writer_lock *this, tbb::interface5::reader_writer_lock::scoped_lock *a2)
{
  tbb::interface5::reader_writer_lock::scoped_lock *i;
  pthread_t id_v3;
  int v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v12;
  int v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  tbb::interface5::reader_writer_lock::scoped_lock *v20;
  tbb::interface5::reader_writer_lock::scoped_lock *v21;

  id_v3 = tbb::internal::thread_get_id_v3();
  v6 = *((_DWORD *)a2 + 4);
  __dmb(0xBu);
  v7 = (unint64_t *)((char *)this + 16);
  if (!v6)
  {
    do
    {
      while (!__ldaxr(v7))
      {
        if (!__stlxr((unint64_t)a2, v7))
          goto LABEL_20;
      }
      __clrex();
      do
        v12 = __ldxr(v7);
      while (__stxr(v12, v7));
    }
    while (!v12);
    if (!a2)
      return 0;
    if (*(_QWORD *)a2)
      tbb::interface5::reader_writer_lock::end_write(*(unint64_t **)a2, a2);
    goto LABEL_46;
  }
LABEL_2:
  v8 = *v7;
  do
  {
    while (1)
    {
      v9 = __ldaxr(v7);
      if (v9 == v8)
        break;
      __clrex();
      do
        v10 = __ldxr(v7);
      while (__stxr(v10, v7));
      if (v10 != v8)
      {
        sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr((unint64_t)a2, v7));
  if (!v8)
  {
LABEL_20:
    tbb::interface5::reader_writer_lock::set_next_writer((uint64_t)this, a2);
    v13 = *((_DWORD *)a2 + 4);
    __dmb(0xBu);
    if (v13)
      goto LABEL_31;
    i = (tbb::interface5::reader_writer_lock::scoped_lock *)*((_QWORD *)a2 + 1);
    if (!i)
    {
      v14 = (unint64_t *)((char *)this + 8);
LABEL_23:
      v15 = *v14;
      do
      {
        while (1)
        {
          v16 = __ldaxr(v14);
          if (v16 == v15)
            break;
          __clrex();
          do
            v17 = __ldxr(v14);
          while (__stxr(v17, v14));
          if (v17 != v15)
          {
            sched_yield();
            goto LABEL_23;
          }
        }
      }
      while (__stlxr(0, v14));
      do
      {
        while (1)
        {
          v20 = (tbb::interface5::reader_writer_lock::scoped_lock *)__ldaxr(v7);
          if (v20 == a2)
            break;
          __clrex();
          do
            v21 = (tbb::interface5::reader_writer_lock::scoped_lock *)__ldxr(v7);
          while (__stxr((unint64_t)v21, v7));
          if (v21 != a2)
            goto LABEL_40;
        }
      }
      while (__stlxr(0, v7));
      v21 = a2;
LABEL_40:
      if (v21 == a2)
      {
        if (!a2)
          return 0;
        goto LABEL_44;
      }
      for (i = (tbb::interface5::reader_writer_lock::scoped_lock *)*((_QWORD *)a2 + 1);
            !i;
            i = (tbb::interface5::reader_writer_lock::scoped_lock *)*((_QWORD *)a2 + 1))
      {
        sched_yield();
      }
    }
    tbb::interface5::reader_writer_lock::set_next_writer((uint64_t)this, i);
LABEL_44:
    if (*(_QWORD *)a2)
      tbb::interface5::reader_writer_lock::end_write(*(unint64_t **)a2, a2);
LABEL_46:
    __dmb(0xBu);
    *((_DWORD *)a2 + 4) = 3;
    tbb::internal::deallocate_via_handler_v3((uint64_t)a2, i);
    return 0;
  }
  *(_QWORD *)(v8 + 8) = a2;
LABEL_31:
  while (1)
  {
    v18 = *((_DWORD *)a2 + 4);
    __dmb(0xBu);
    if (v18 != 1)
      break;
    sched_yield();
  }
  *((_QWORD *)this + 3) = id_v3;
  return 1;
}

uint64_t tbb::interface5::reader_writer_lock::try_lock(tbb::interface5::reader_writer_lock *this)
{
  _opaque_pthread_t *v2;
  uint64_t v3;

  v2 = (_opaque_pthread_t *)*((_QWORD *)this + 3);
  if (v2 == tbb::internal::thread_get_id_v3())
    return 0;
  v3 = tbb::internal::allocate_via_handler_v3((tbb::internal *)0x18);
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(v3 + 16) = 1;
  __dmb(0xBu);
  *(_DWORD *)(v3 + 16) = 0;
  return tbb::interface5::reader_writer_lock::start_write(this, (tbb::interface5::reader_writer_lock::scoped_lock *)v3);
}

uint64_t tbb::interface5::reader_writer_lock::set_next_writer(uint64_t this, tbb::interface5::reader_writer_lock::scoped_lock *a2)
{
  int v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v16;

  __dmb(0xBu);
  *(_QWORD *)(this + 8) = a2;
  v3 = *((_DWORD *)a2 + 4);
  __dmb(0xBu);
  v4 = (unint64_t *)(this + 32);
  if (v3)
  {
LABEL_2:
    v5 = *v4;
    __dmb(0xBu);
    do
    {
      while (1)
      {
        v6 = __ldaxr(v4);
        if (v6 == v5)
          break;
        __clrex();
        do
          v7 = __ldxr(v4);
        while (__stxr(v7, v4));
        if (v7 != v5)
        {
          this = sched_yield();
          goto LABEL_2;
        }
      }
    }
    while (__stlxr(v5 | 1, v4));
    if ((v5 & 4) == 0)
    {
      while (1)
      {
        v8 = *v4;
        v9 = *v4 | 2;
        do
        {
          while (1)
          {
            v10 = __ldaxr(v4);
            if (v10 != v8)
              break;
            if (!__stlxr(v9, v4))
              goto LABEL_19;
          }
          __clrex();
          do
            v11 = __ldxr(v4);
          while (__stxr(v11, v4));
        }
        while (v11 == v8);
        this = sched_yield();
      }
    }
    while (1)
    {
      v12 = *v4;
      __dmb(0xBu);
      if ((v12 & 2) != 0)
        break;
      this = sched_yield();
    }
LABEL_19:
    v13 = *v4;
    __dmb(0xBu);
    if (v13 >= 8)
    {
      do
      {
        this = sched_yield();
        v14 = *v4;
        __dmb(0xBu);
      }
      while (v14 > 7);
    }
LABEL_21:
    __dmb(0xBu);
    *((_DWORD *)a2 + 4) = 2;
  }
  else
  {
    do
    {
      while (!__ldaxr(v4))
      {
        if (!__stlxr(3uLL, v4))
          goto LABEL_21;
      }
      __clrex();
      do
        v16 = __ldxr(v4);
      while (__stxr(v16, v4));
    }
    while (!v16);
  }
  return this;
}

unint64_t *tbb::interface5::reader_writer_lock::lock_read(tbb::interface5::reader_writer_lock *this)
{
  _opaque_pthread_t *v2;
  unint64_t *result;
  unint64_t *v4;
  unint64_t v5;
  _QWORD v6[2];
  int v7;

  v2 = (_opaque_pthread_t *)*((_QWORD *)this + 3);
  if (v2 == tbb::internal::thread_get_id_v3())
    return (unint64_t *)tbb::internal::throw_exception_v4(9);
  v6[0] = 0;
  v6[1] = 0;
  __dmb(0xBu);
  v7 = 1;
  result = tbb::interface5::reader_writer_lock::start_read((unint64_t *)this, (tbb::interface5::reader_writer_lock::scoped_lock_read *)v6);
  if (v6[0])
  {
    v4 = (unint64_t *)(v6[0] + 32);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 8, v4));
  }
  __dmb(0xBu);
  v7 = 3;
  return result;
}

void sub_20BDC80C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unint64_t *v10;
  unint64_t v11;

  if (a10)
  {
    v10 = (unint64_t *)(a10 + 32);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 8, v10));
  }
  __dmb(0xBu);
  _Unwind_Resume(a1);
}

uint64_t tbb::interface5::reader_writer_lock::scoped_lock_read::scoped_lock_read(uint64_t this)
{
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(this + 16) = 1;
  return this;
}

{
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(this + 16) = 1;
  return this;
}

unint64_t *tbb::interface5::reader_writer_lock::start_read(unint64_t *this, tbb::interface5::reader_writer_lock::scoped_lock_read *a2)
{
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;

  v3 = this;
LABEL_2:
  v4 = *v3;
  do
  {
    while (1)
    {
      v5 = __ldaxr(v3);
      if (v5 == v4)
        break;
      __clrex();
      do
        v6 = __ldxr(v3);
      while (__stxr(v6, v3));
      if (v6 != v4)
      {
        this = (unint64_t *)sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr((unint64_t)a2, v3));
  *((_QWORD *)a2 + 1) = v4;
  if (!v4)
  {
    v7 = v3 + 4;
LABEL_11:
    v8 = *v7;
    __dmb(0xBu);
    do
    {
      while (1)
      {
        v9 = __ldaxr(v7);
        if (v9 == v8)
          break;
        __clrex();
        do
          v10 = __ldxr(v7);
        while (__stxr(v10, v7));
        if (v10 != v8)
        {
          this = (unint64_t *)sched_yield();
          goto LABEL_11;
        }
      }
    }
    while (__stlxr(v8 | 4, v7));
    if ((v8 & 3) == 0)
    {
      do
        v11 = __ldaxr(v7);
      while (__stlxr(v11 + 4, v7));
      v12 = *v7;
      __dmb(0xBu);
      if ((v12 & 1) != 0)
      {
        v13 = *v7;
        __dmb(0xBu);
        if ((v13 & 2) == 0)
        {
          while (1)
          {
            v14 = *v7;
            v15 = *v7 | 2;
            do
            {
              while (1)
              {
                v16 = __ldaxr(v7);
                if (v16 != v14)
                  break;
                if (!__stlxr(v15, v7))
                  goto LABEL_29;
              }
              __clrex();
              do
                v17 = __ldxr(v7);
              while (__stxr(v17, v7));
            }
            while (v17 == v14);
            this = (unint64_t *)sched_yield();
          }
        }
      }
LABEL_29:
      v18 = *v3;
      do
      {
        while (1)
        {
          v19 = __ldaxr(v3);
          if (v19 == v18)
            break;
          __clrex();
          do
            v20 = __ldxr(v3);
          while (__stxr(v20, v3));
          if (v20 != v18)
          {
            this = (unint64_t *)sched_yield();
            goto LABEL_29;
          }
        }
      }
      while (__stlxr(0, v3));
      __dmb(0xBu);
      *(_DWORD *)(v18 + 16) = 2;
    }
  }
  while (1)
  {
    v21 = *((_DWORD *)a2 + 4);
    __dmb(0xBu);
    if (v21 != 1)
      break;
    this = (unint64_t *)sched_yield();
  }
  if (*((_QWORD *)a2 + 1))
  {
    v22 = v3 + 4;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 + 8, v22));
    v24 = *((_QWORD *)a2 + 1);
    __dmb(0xBu);
    *(_DWORD *)(v24 + 16) = 2;
  }
  return this;
}

uint64_t tbb::interface5::reader_writer_lock::try_lock_read(tbb::interface5::reader_writer_lock *this)
{
  _opaque_pthread_t *v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;

  v2 = (_opaque_pthread_t *)*((_QWORD *)this + 3);
  if (v2 == tbb::internal::thread_get_id_v3())
    return 0;
  v3 = (unint64_t *)((char *)this + 32);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 8, v3));
  if ((v4 & 3) != 0)
  {
    do
      v5 = __ldaxr(v3);
    while (__stlxr(v5 - 8, v3));
    return 0;
  }
  return 1;
}

unint64_t *tbb::interface5::reader_writer_lock::unblock_readers(unint64_t *this)
{
  unint64_t *v1;
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  v1 = this;
  v2 = this + 4;
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 + 4, v2));
  v4 = *v2;
  __dmb(0xBu);
  if ((v4 & 1) != 0)
  {
    v5 = *v2;
    __dmb(0xBu);
    if ((v5 & 2) == 0)
    {
      while (1)
      {
        v6 = *v2;
        v7 = *v2 | 2;
        do
        {
          while (1)
          {
            v8 = __ldaxr(v2);
            if (v8 != v6)
              break;
            if (!__stlxr(v7, v2))
              goto LABEL_12;
          }
          __clrex();
          do
            v9 = __ldxr(v2);
          while (__stxr(v9, v2));
        }
        while (v9 == v6);
        this = (unint64_t *)sched_yield();
      }
    }
  }
LABEL_12:
  v10 = *v1;
  do
  {
    while (1)
    {
      v11 = __ldaxr(v1);
      if (v11 == v10)
        break;
      __clrex();
      do
        v12 = __ldxr(v1);
      while (__stxr(v12, v1));
      if (v12 != v10)
      {
        this = (unint64_t *)sched_yield();
        goto LABEL_12;
      }
    }
  }
  while (__stlxr(0, v1));
  __dmb(0xBu);
  *(_DWORD *)(v10 + 16) = 2;
  return this;
}

unint64_t *tbb::interface5::reader_writer_lock::unlock(unint64_t *this)
{
  tbb::interface5::reader_writer_lock::scoped_lock *v1;
  void *v2;
  unint64_t *v3;
  unint64_t v4;

  if (this[3])
  {
    v1 = (tbb::interface5::reader_writer_lock::scoped_lock *)this[1];
    __dmb(0xBu);
    this = tbb::interface5::reader_writer_lock::end_write(this, v1);
    if (v1)
    {
      if (*(_QWORD *)v1)
        tbb::interface5::reader_writer_lock::end_write(*(unint64_t **)v1, v1);
      __dmb(0xBu);
      *((_DWORD *)v1 + 4) = 3;
      return (unint64_t *)tbb::internal::deallocate_via_handler_v3((uint64_t)v1, v2);
    }
  }
  else
  {
    v3 = this + 4;
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 8, v3));
  }
  return this;
}

unint64_t *tbb::interface5::reader_writer_lock::end_write(unint64_t *this, tbb::interface5::reader_writer_lock::scoped_lock *a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  tbb::interface5::reader_writer_lock::scoped_lock *v25;
  tbb::interface5::reader_writer_lock::scoped_lock *v26;
  tbb::interface5::reader_writer_lock::scoped_lock *i;

  v2 = this;
  this[3] = 0;
  v3 = *((_QWORD *)a2 + 1);
  if (v3)
  {
    __dmb(0xBu);
    this[1] = v3;
    v4 = this[1];
    __dmb(0xBu);
    __dmb(0xBu);
    *(_DWORD *)(v4 + 16) = 2;
  }
  else
  {
    v6 = this + 4;
LABEL_5:
    v7 = *v6;
    __dmb(0xBu);
    do
    {
      while (1)
      {
        v8 = __ldaxr(v6);
        if (v8 == v7)
          break;
        __clrex();
        do
          v9 = __ldxr(v6);
        while (__stxr(v9, v6));
        if (v9 != v7)
        {
          this = (unint64_t *)sched_yield();
          goto LABEL_5;
        }
      }
    }
    while (__stlxr(v7 & 0xFFFFFFFFFFFFFFFCLL, v6));
    if ((v7 & 4) != 0)
    {
      do
        v10 = __ldaxr(v6);
      while (__stlxr(v10 + 4, v6));
      v11 = *v6;
      __dmb(0xBu);
      if ((v11 & 1) != 0)
      {
        v12 = *v6;
        __dmb(0xBu);
        if ((v12 & 2) == 0)
        {
          while (1)
          {
            v13 = *v6;
            v14 = *v6 | 2;
            do
            {
              while (1)
              {
                v15 = __ldaxr(v6);
                if (v15 != v13)
                  break;
                if (!__stlxr(v14, v6))
                  goto LABEL_23;
              }
              __clrex();
              do
                v16 = __ldxr(v6);
              while (__stxr(v16, v6));
            }
            while (v16 == v13);
            this = (unint64_t *)sched_yield();
          }
        }
      }
LABEL_23:
      v17 = *v2;
      do
      {
        while (1)
        {
          v18 = __ldaxr(v2);
          if (v18 == v17)
            break;
          __clrex();
          do
            v19 = __ldxr(v2);
          while (__stxr(v19, v2));
          if (v19 != v17)
          {
            this = (unint64_t *)sched_yield();
            goto LABEL_23;
          }
        }
      }
      while (__stlxr(0, v2));
      __dmb(0xBu);
      *(_DWORD *)(v17 + 16) = 2;
    }
    v20 = v2 + 1;
LABEL_32:
    v21 = *v20;
    do
    {
      while (1)
      {
        v22 = __ldaxr(v20);
        if (v22 == v21)
          break;
        __clrex();
        do
          v23 = __ldxr(v20);
        while (__stxr(v23, v20));
        if (v23 != v21)
        {
          this = (unint64_t *)sched_yield();
          goto LABEL_32;
        }
      }
    }
    while (__stlxr(0, v20));
    v24 = v2 + 2;
    do
    {
      while (1)
      {
        v25 = (tbb::interface5::reader_writer_lock::scoped_lock *)__ldaxr(v24);
        if (v25 == a2)
          break;
        __clrex();
        do
          v26 = (tbb::interface5::reader_writer_lock::scoped_lock *)__ldxr(v24);
        while (__stxr((unint64_t)v26, v24));
        if (v26 != a2)
          goto LABEL_47;
      }
    }
    while (__stlxr(0, v24));
    v26 = a2;
LABEL_47:
    if (v26 != a2)
    {
      for (i = (tbb::interface5::reader_writer_lock::scoped_lock *)*((_QWORD *)a2 + 1);
            !i;
            i = (tbb::interface5::reader_writer_lock::scoped_lock *)*((_QWORD *)a2 + 1))
      {
        sched_yield();
      }
      return (unint64_t *)tbb::interface5::reader_writer_lock::set_next_writer((uint64_t)v2, i);
    }
  }
  return this;
}

uint64_t tbb::interface5::reader_writer_lock::end_read(uint64_t this)
{
  unint64_t *v1;
  unint64_t v2;

  v1 = (unint64_t *)(this + 32);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 8, v1));
  return this;
}

uint64_t tbb::interface5::reader_writer_lock::scoped_lock::internal_construct(tbb::interface5::reader_writer_lock::scoped_lock *this, tbb::interface5::reader_writer_lock *a2)
{
  _opaque_pthread_t *v3;

  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = 0;
  __dmb(0xBu);
  *((_DWORD *)this + 4) = 1;
  v3 = *(_opaque_pthread_t **)(*(_QWORD *)this + 24);
  if (v3 == tbb::internal::thread_get_id_v3())
    return tbb::internal::throw_exception_v4(9);
  else
    return tbb::interface5::reader_writer_lock::start_write(*(tbb::interface5::reader_writer_lock **)this, this);
}

unint64_t *tbb::interface5::reader_writer_lock::scoped_lock_read::internal_construct(tbb::interface5::reader_writer_lock::scoped_lock_read *this, tbb::interface5::reader_writer_lock *a2)
{
  _opaque_pthread_t *v3;

  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = 0;
  __dmb(0xBu);
  *((_DWORD *)this + 4) = 1;
  v3 = *(_opaque_pthread_t **)(*(_QWORD *)this + 24);
  if (v3 == tbb::internal::thread_get_id_v3())
    return (unint64_t *)tbb::internal::throw_exception_v4(9);
  else
    return tbb::interface5::reader_writer_lock::start_read(*(unint64_t **)this, this);
}

unint64_t *tbb::interface5::reader_writer_lock::scoped_lock::internal_destroy(unint64_t **this)
{
  unint64_t *result;

  result = *this;
  if (result)
    result = tbb::interface5::reader_writer_lock::end_write(result, (tbb::interface5::reader_writer_lock::scoped_lock *)this);
  __dmb(0xBu);
  *((_DWORD *)this + 4) = 3;
  return result;
}

_DWORD *tbb::interface5::reader_writer_lock::scoped_lock_read::internal_destroy(_DWORD *this)
{
  unint64_t *v1;
  unint64_t v2;

  if (*(_QWORD *)this)
  {
    v1 = (unint64_t *)(*(_QWORD *)this + 32);
    do
      v2 = __ldaxr(v1);
    while (__stlxr(v2 - 8, v1));
  }
  __dmb(0xBu);
  this[4] = 3;
  return this;
}

uint64_t tbb::spin_rw_mutex_v3::internal_acquire_writer(tbb::spin_rw_mutex_v3 *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  while (1)
  {
    v2 = *(_QWORD *)this;
    if ((*(_QWORD *)this & 0xFFFFFFFFFFFFFFFDLL) != 0)
    {
      if ((v2 & 2) == 0)
      {
        while (1)
        {
          v3 = *(_QWORD *)this;
          v4 = *(_QWORD *)this | 2;
          do
          {
            while (1)
            {
              v5 = __ldaxr((unint64_t *)this);
              if (v5 != v3)
                break;
              if (!__stlxr(v4, (unint64_t *)this))
                goto LABEL_3;
            }
            __clrex();
            do
              v6 = __ldxr((unint64_t *)this);
            while (__stxr(v6, (unint64_t *)this));
          }
          while (v6 == v3);
          sched_yield();
        }
      }
      goto LABEL_3;
    }
    v7 = *(_QWORD *)this;
    do
    {
      while (1)
      {
        v8 = __ldaxr((unint64_t *)this);
        if (v8 != v2)
          break;
        if (!__stlxr(1uLL, (unint64_t *)this))
          goto LABEL_2;
      }
      __clrex();
      do
        v9 = __ldxr((unint64_t *)this);
      while (__stxr(v9, (unint64_t *)this));
    }
    while (v9 == v2);
    v7 = v9;
LABEL_2:
    if (v7 == v2)
      return 0;
LABEL_3:
    sched_yield();
  }
}

unint64_t *tbb::spin_rw_mutex_v3::internal_release_writer(unint64_t *this)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  v1 = this;
LABEL_2:
  v2 = *v1;
  v3 = *v1 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    while (1)
    {
      v4 = __ldaxr(v1);
      if (v4 == v2)
        break;
      __clrex();
      do
        v5 = __ldxr(v1);
      while (__stxr(v5, v1));
      if (v5 != v2)
      {
        this = (unint64_t *)sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v3, v1));
  return this;
}

unint64_t *tbb::spin_rw_mutex_v3::internal_acquire_reader(unint64_t *this)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t v3;

  v1 = this;
  while (1)
  {
    if ((*(_BYTE *)v1 & 3) != 0)
      goto LABEL_2;
    do
      v2 = __ldaxr(v1);
    while (__stlxr(v2 + 4, v1));
    if ((v2 & 1) == 0)
      return this;
    do
      v3 = __ldaxr(v1);
    while (__stlxr(v3 - 4, v1));
LABEL_2:
    this = (unint64_t *)sched_yield();
  }
}

uint64_t tbb::spin_rw_mutex_v3::internal_upgrade(tbb::spin_rw_mutex_v3 *this)
{
  unint64_t v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  v2 = *(_QWORD *)this;
  do
  {
    v3 = (v2 & 2) == 0 || (v2 & 0xFFFFFFFFFFFFFFFCLL) == 4;
    v4 = v3;
    if (!v3)
    {
      do
        v8 = __ldaxr((unint64_t *)this);
      while (__stlxr(v8 - 4, (unint64_t *)this));
      while (1)
      {
        v9 = *(_QWORD *)this;
        if ((*(_QWORD *)this & 0xFFFFFFFFFFFFFFFDLL) != 0)
        {
          if ((v9 & 2) == 0)
          {
            while (1)
            {
              v10 = *(_QWORD *)this;
              v11 = *(_QWORD *)this | 2;
              do
              {
                while (1)
                {
                  v12 = __ldaxr((unint64_t *)this);
                  if (v12 != v10)
                    break;
                  if (!__stlxr(v11, (unint64_t *)this))
                    goto LABEL_21;
                }
                __clrex();
                do
                  v13 = __ldxr((unint64_t *)this);
                while (__stxr(v13, (unint64_t *)this));
              }
              while (v13 == v10);
              sched_yield();
            }
          }
        }
        else
        {
          v14 = *(_QWORD *)this;
          do
          {
            while (1)
            {
              v15 = __ldaxr((unint64_t *)this);
              if (v15 != v9)
                break;
              if (!__stlxr(1uLL, (unint64_t *)this))
                goto LABEL_20;
            }
            __clrex();
            do
              v16 = __ldxr((unint64_t *)this);
            while (__stxr(v16, (unint64_t *)this));
          }
          while (v16 == v9);
          v14 = v16;
LABEL_20:
          if (v14 == v9)
            return v4;
        }
LABEL_21:
        sched_yield();
      }
    }
    v5 = v2;
    do
    {
      while (1)
      {
        v6 = __ldaxr((unint64_t *)this);
        if (v6 != v2)
          break;
        if (!__stlxr(v2 | 3, (unint64_t *)this))
          goto LABEL_2;
      }
      __clrex();
      do
        v7 = __ldxr((unint64_t *)this);
      while (__stxr(v7, (unint64_t *)this));
    }
    while (v7 == v2);
    v5 = v7;
LABEL_2:
    v3 = v5 == v2;
    v2 = v5;
  }
  while (!v3);
  while ((*(_QWORD *)this & 0xFFFFFFFFFFFFFFFCLL) != 4)
    sched_yield();
  do
    v17 = __ldaxr((unint64_t *)this);
  while (__stlxr(v17 - 6, (unint64_t *)this));
  return v4;
}

unint64_t *tbb::spin_rw_mutex_v3::internal_release_reader(unint64_t *this)
{
  unint64_t v1;

  do
    v1 = __ldaxr(this);
  while (__stlxr(v1 - 4, this));
  return this;
}

unint64_t *tbb::spin_rw_mutex_v3::internal_downgrade(unint64_t *this)
{
  unint64_t v1;

  do
    v1 = __ldaxr(this);
  while (__stlxr(v1 + 3, this));
  return this;
}

BOOL tbb::spin_rw_mutex_v3::internal_try_acquire_writer(tbb::spin_rw_mutex_v3 *this)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v1 = *(_QWORD *)this;
  if ((*(_QWORD *)this & 0xFFFFFFFFFFFFFFFDLL) != 0)
    return 0;
  v2 = *(_QWORD *)this;
  do
  {
    while (1)
    {
      v3 = __ldaxr((unint64_t *)this);
      if (v3 != v1)
        break;
      if (!__stlxr(1uLL, (unint64_t *)this))
        return v2 == v1;
    }
    __clrex();
    do
      v4 = __ldxr((unint64_t *)this);
    while (__stxr(v4, (unint64_t *)this));
  }
  while (v4 == v1);
  v2 = v4;
  return v2 == v1;
}

uint64_t tbb::spin_rw_mutex_v3::internal_try_acquire_reader(tbb::spin_rw_mutex_v3 *this)
{
  unint64_t v1;
  unint64_t v3;

  if ((*(_BYTE *)this & 3) == 0)
  {
    do
      v1 = __ldaxr((unint64_t *)this);
    while (__stlxr(v1 + 4, (unint64_t *)this));
    if ((v1 & 1) == 0)
      return 1;
    do
      v3 = __ldaxr((unint64_t *)this);
    while (__stlxr(v3 - 4, (unint64_t *)this));
  }
  return 0;
}

_QWORD *tbb::spin_mutex::scoped_lock::internal_acquire(_QWORD *result, uint64_t a2)
{
  _QWORD *v3;
  unsigned int *v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;

  v3 = result;
  v4 = (unsigned int *)(a2 & 0xFFFFFFFFFFFFFFFCLL);
  v5 = 1 << (8 * (a2 & 3));
  v6 = ~(255 << (8 * (a2 & 3)));
LABEL_2:
  v7 = *v4 & v6;
  do
  {
    while (1)
    {
      v8 = __ldaxr(v4);
      if (v8 == v7)
        break;
      __clrex();
      if (*v4 != v7)
      {
        result = (_QWORD *)sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v7 | v5, v4));
  *v3 = a2;
  return result;
}

_BYTE **tbb::spin_mutex::scoped_lock::internal_release(_BYTE **this)
{
  _BYTE *v1;

  v1 = *this;
  __dmb(0xBu);
  *v1 = 0;
  *this = 0;
  return this;
}

uint64_t tbb::spin_mutex::scoped_lock::internal_try_acquire(_QWORD *a1, uint64_t a2)
{
  unsigned int *v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t result;

  v4 = (unsigned int *)(a2 & 0xFFFFFFFFFFFFFFFCLL);
  v5 = 255 << (8 * (a2 & 3));
  v6 = 1 << (8 * (a2 & 3));
  while (1)
  {
    v7 = *v4 & ~v5;
    do
    {
      while (1)
      {
        v8 = __ldaxr(v4);
        if (v8 != v7)
          break;
        if (!__stlxr(v7 | v6, v4))
        {
          result = 1;
          *a1 = a2;
          return result;
        }
      }
      result = 0;
      __clrex();
    }
    while (*v4 == v7);
    if ((*v4 & v5) != 0)
      break;
    sched_yield();
  }
  return result;
}

tbb::internal *tbb::mutex::scoped_lock::internal_acquire(tbb::mutex::scoped_lock *this, pthread_mutex_t *a2)
{
  tbb::internal *result;
  const char *v5;

  result = (tbb::internal *)pthread_mutex_lock(a2);
  if ((_DWORD)result)
    tbb::internal::handle_perror(result, "mutex::scoped_lock: pthread_mutex_lock failed", v5);
  *(_QWORD *)this = a2;
  return result;
}

uint64_t tbb::mutex::scoped_lock::internal_release(pthread_mutex_t **this)
{
  uint64_t result;

  result = pthread_mutex_unlock(*this);
  *this = 0;
  return result;
}

BOOL tbb::mutex::scoped_lock::internal_try_acquire(tbb::mutex::scoped_lock *this, pthread_mutex_t *a2)
{
  int v4;

  v4 = pthread_mutex_trylock(a2);
  if (!v4)
    *(_QWORD *)this = a2;
  return v4 == 0;
}

tbb::internal *tbb::mutex::internal_construct(pthread_mutex_t *this)
{
  tbb::internal *result;
  const char *v2;

  result = (tbb::internal *)pthread_mutex_init(this, 0);
  if ((_DWORD)result)
    tbb::internal::handle_perror(result, "mutex: pthread_mutex_init failed", v2);
  return result;
}

tbb::internal *tbb::recursive_mutex::scoped_lock::internal_acquire(_QWORD *a1, pthread_mutex_t *a2)
{
  tbb::internal *result;
  const char *v5;

  result = (tbb::internal *)pthread_mutex_lock(a2);
  if ((_DWORD)result)
    tbb::internal::handle_perror(result, "recursive_mutex::scoped_lock: pthread_mutex_lock failed", v5);
  *a1 = a2;
  return result;
}

uint64_t tbb::recursive_mutex::scoped_lock::internal_release(pthread_mutex_t **this)
{
  uint64_t result;

  result = pthread_mutex_unlock(*this);
  *this = 0;
  return result;
}

BOOL tbb::recursive_mutex::scoped_lock::internal_try_acquire(_QWORD *a1, pthread_mutex_t *a2)
{
  int v4;

  v4 = pthread_mutex_trylock(a2);
  if (!v4)
    *a1 = a2;
  return v4 == 0;
}

uint64_t tbb::recursive_mutex::internal_construct(pthread_mutex_t *this)
{
  tbb::internal *v2;
  const char *v3;
  tbb::internal *v4;
  const char *v5;
  pthread_mutexattr_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = (tbb::internal *)pthread_mutexattr_init(&v7);
  if ((_DWORD)v2)
    tbb::internal::handle_perror(v2, "recursive_mutex: pthread_mutexattr_init failed", v3);
  pthread_mutexattr_settype(&v7, 2);
  v4 = (tbb::internal *)pthread_mutex_init(this, &v7);
  if ((_DWORD)v4)
    tbb::internal::handle_perror(v4, "recursive_mutex: pthread_mutex_init failed", v5);
  return pthread_mutexattr_destroy(&v7);
}

tbb::internal *tbb::internal::tbb_thread_v3::join(pthread_t *this, uint64_t a2, const char *a3)
{
  const char *v4;
  tbb::internal *result;
  const char *v6;

  if (!*this)
    tbb::internal::handle_perror((tbb::internal *)0x16, "tbb_thread::join", a3);
  if (pthread_self() == *this)
    tbb::internal::handle_perror((tbb::internal *)0xB, "tbb_thread::join", v4);
  result = (tbb::internal *)pthread_join(*this, 0);
  if ((_DWORD)result)
    tbb::internal::handle_perror(result, "pthread_join", v6);
  *this = 0;
  return result;
}

tbb::internal *tbb::internal::tbb_thread_v3::detach(_opaque_pthread_t **this, uint64_t a2, const char *a3)
{
  _opaque_pthread_t *v4;
  tbb::internal *result;
  const char *v6;

  v4 = *this;
  if (!v4)
    tbb::internal::handle_perror((tbb::internal *)0x16, "tbb_thread::detach", a3);
  result = (tbb::internal *)pthread_detach(v4);
  if ((_DWORD)result)
    tbb::internal::handle_perror(result, "pthread_detach", v6);
  *this = 0;
  return result;
}

void sub_20BDC9020()
{
  pthread_t *v0;

  if (!pthread_detach(*v0))
    JUMPOUT(0x20BDC9000);
  JUMPOUT(0x20BDC8FF4);
}

tbb::internal *tbb::internal::tbb_thread_v3::internal_start(tbb::internal::tbb_thread_v3 *this, void *(__cdecl *a2)(void *), void *a3)
{
  tbb::internal *v6;
  int v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  size_t active;
  tbb::internal *v12;
  const char *v13;
  tbb::internal *v14;
  const char *v15;
  tbb::internal *result;
  const char *v17;
  pthread_t v18;
  pthread_attr_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v18 = 0;
  v6 = (tbb::internal *)pthread_attr_init(&v19);
  if ((_DWORD)v6)
    tbb::internal::handle_perror(v6, "pthread_attr_init", v8);
  active = tbb::interface9::global_control::active_value((tbb::interface9::global_control *)1, v7, (uint64_t)v8, v9, v10);
  v12 = (tbb::internal *)pthread_attr_setstacksize(&v19, active);
  if ((_DWORD)v12)
    tbb::internal::handle_perror(v12, "pthread_attr_setstacksize", v13);
  v14 = (tbb::internal *)pthread_create(&v18, &v19, a2, a3);
  if ((_DWORD)v14)
    tbb::internal::handle_perror(v14, "pthread_create", v15);
  result = (tbb::internal *)pthread_attr_destroy(&v19);
  if ((_DWORD)result)
    tbb::internal::handle_perror(result, "pthread_attr_destroy", v17);
  *(_QWORD *)this = v18;
  return result;
}

uint64_t tbb::internal::tbb_thread_v3::hardware_concurrency(tbb::internal::tbb_thread_v3 *this)
{
  uint64_t result;
  size_t v2;
  int v3;
  int v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  result = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(_QWORD *)v4 = 0x1900000006;
    v3 = 0;
    v2 = 4;
    sysctl(v4, 2u, &v3, &v2, 0, 0);
    if (v3 <= 1)
      result = 1;
    else
      result = v3;
    tbb::internal::governor::DefaultNumberOfThreads = result;
  }
  return result;
}

void sub_20BDC91B4(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  sub_20BDC12F4(a1);
}

_opaque_pthread_t *tbb::internal::move_v3(_opaque_pthread_t **this, _opaque_pthread_t **a2, tbb::internal::tbb_thread_v3 *a3)
{
  _opaque_pthread_t *result;
  const char *v6;

  result = *this;
  if (result)
  {
    result = (_opaque_pthread_t *)pthread_detach(result);
    if ((_DWORD)result)
      tbb::internal::handle_perror((tbb::internal *)result, "pthread_detach", v6);
    *this = 0;
  }
  *this = *a2;
  *a2 = 0;
  return result;
}

uint64_t tbb::internal::thread_sleep_v3(uint64_t *a1)
{
  double v1;
  timespec v3;

  v1 = (double)*a1 * 0.000001;
  v3.tv_sec = (uint64_t)v1;
  v3.tv_nsec = (uint64_t)((v1 - (double)(uint64_t)v1) * 1000000000.0);
  return nanosleep(&v3, 0);
}

uint64_t tbb::internal::concurrent_monitor::thread_context::init(tbb::internal::concurrent_monitor::thread_context *this)
{
  char *v1;
  uint64_t result;

  *((_DWORD *)this + 4) = 0;
  v1 = (char *)this + 16;
  result = semaphore_create(*MEMORY[0x24BDAEC58], (semaphore_t *)this + 4, 0, 0);
  v1[11] = 1;
  return result;
}

void tbb::internal::concurrent_monitor::~concurrent_monitor(tbb::internal::concurrent_monitor *this)
{
  __dmb(0xBu);
  tbb::internal::concurrent_monitor::abort_all_relaxed((uint64_t)this);
}

{
  __dmb(0xBu);
  tbb::internal::concurrent_monitor::abort_all_relaxed((uint64_t)this);
}

uint64_t tbb::internal::concurrent_monitor::prepare_wait(uint64_t this, tbb::internal::concurrent_monitor::thread_context *a2, uint64_t a3)
{
  uint64_t v5;
  unsigned int *v6;
  int v7;
  unsigned int v8;
  uint64_t v9;

  v5 = this;
  if (*((_BYTE *)a2 + 27))
  {
    if (*((_BYTE *)a2 + 25))
    {
      *((_BYTE *)a2 + 25) = 0;
      do
        this = MEMORY[0x212B93828](*((unsigned int *)a2 + 4));
      while ((_DWORD)this == 14);
    }
  }
  else
  {
    this = tbb::internal::concurrent_monitor::thread_context::init(a2);
  }
  *((_QWORD *)a2 + 4) = a3;
  __dmb(0xBu);
  *((_BYTE *)a2 + 24) = 1;
  v6 = (unsigned int *)((v5 + 1) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_8:
  v7 = *v6 & ~(255 << (8 * ((v5 + 1) & 3)));
  do
  {
    while (1)
    {
      v8 = __ldaxr(v6);
      if (v8 == v7)
        break;
      __clrex();
      if (*v6 != v7)
      {
        this = sched_yield();
        goto LABEL_8;
      }
    }
  }
  while (__stlxr(v7 | (1 << (8 * ((v5 + 1) & 3))), v6));
  *((_DWORD *)a2 + 5) = *(_DWORD *)(v5 + 32);
  ++*(_QWORD *)(v5 + 8);
  v9 = *(_QWORD *)(v5 + 24);
  *(_QWORD *)a2 = v5 + 16;
  *((_QWORD *)a2 + 1) = v9;
  **(_QWORD **)(v5 + 24) = a2;
  *(_QWORD *)(v5 + 24) = a2;
  __dmb(0xBu);
  *(_BYTE *)(v5 + 1) = 0;
  __dmb(0xBu);
  return this;
}

uint64_t tbb::internal::concurrent_monitor::cancel_wait(uint64_t this, tbb::internal::concurrent_monitor::thread_context *a2)
{
  char v2;
  uint64_t v4;
  _BYTE *v5;
  unsigned int *v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  char v11;
  _QWORD *v12;

  *((_BYTE *)a2 + 25) = 1;
  v2 = *((_BYTE *)a2 + 24);
  __dmb(0xBu);
  if ((v2 & 1) != 0)
  {
    v4 = this;
    v5 = (_BYTE *)(this + 1);
    v6 = (unsigned int *)((this + 1) & 0xFFFFFFFFFFFFFFFCLL);
    v7 = 1 << (8 * ((this + 1) & 3));
    v8 = ~(255 << (8 * ((this + 1) & 3)));
LABEL_3:
    v9 = *v6 & v8;
    do
    {
      while (1)
      {
        v10 = __ldaxr(v6);
        if (v10 == v9)
          break;
        __clrex();
        if (*v6 != v9)
        {
          this = sched_yield();
          goto LABEL_3;
        }
      }
    }
    while (__stlxr(v9 | v7, v6));
    v11 = *((_BYTE *)a2 + 24);
    __dmb(0xBu);
    if ((v11 & 1) != 0)
    {
      --*(_QWORD *)(v4 + 8);
      v12 = (_QWORD *)*((_QWORD *)a2 + 1);
      *v12 = *(_QWORD *)a2;
      *(_QWORD *)(*(_QWORD *)a2 + 8) = v12;
      __dmb(0xBu);
      *((_BYTE *)a2 + 24) = 0;
      *((_BYTE *)a2 + 25) = 0;
    }
    __dmb(0xBu);
    *v5 = 0;
  }
  return this;
}

uint64_t tbb::internal::concurrent_monitor::notify_one_relaxed(uint64_t this)
{
  uint64_t v1;
  _BYTE *v2;
  unsigned int *v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  _QWORD *v9;

  if (*(_QWORD *)(this + 8))
  {
    v1 = this;
    v2 = (_BYTE *)(this + 1);
    v3 = (unsigned int *)((this + 1) & 0xFFFFFFFFFFFFFFFCLL);
    v4 = 1 << (8 * ((this + 1) & 3));
    v5 = ~(255 << (8 * ((this + 1) & 3)));
LABEL_3:
    v6 = *v3 & v5;
    do
    {
      while (1)
      {
        v7 = __ldaxr(v3);
        if (v7 == v6)
          break;
        __clrex();
        if (*v3 != v6)
        {
          this = sched_yield();
          goto LABEL_3;
        }
      }
    }
    while (__stlxr(v6 | v4, v3));
    v8 = *(_QWORD *)(v1 + 16);
    ++*(_DWORD *)(v1 + 32);
    if (v8 != v1 + 16)
    {
      --*(_QWORD *)(v1 + 8);
      v9 = *(_QWORD **)(v8 + 8);
      *v9 = *(_QWORD *)v8;
      *(_QWORD *)(*(_QWORD *)v8 + 8) = v9;
      __dmb(0xBu);
      *(_BYTE *)(v8 + 24) = 0;
      __dmb(0xBu);
      *(_BYTE *)(v1 + 1) = 0;
      JUMPOUT(0x212B9381CLL);
    }
    __dmb(0xBu);
    *v2 = 0;
  }
  return this;
}

uint64_t tbb::internal::concurrent_monitor::notify_all_relaxed(uint64_t this)
{
  uint64_t v1;
  _BYTE *v2;
  unsigned int *v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  __int128 v9;
  __int128 *i;
  __int128 *v11;
  __int128 *v12;
  __int128 v13;

  if (*(_QWORD *)(this + 8))
  {
    v1 = this;
    *(_QWORD *)&v13 = &v13;
    *((_QWORD *)&v13 + 1) = &v13;
    v2 = (_BYTE *)(this + 1);
    v3 = (unsigned int *)((this + 1) & 0xFFFFFFFFFFFFFFFCLL);
    v4 = 1 << (8 * ((this + 1) & 3));
    v5 = ~(255 << (8 * ((this + 1) & 3)));
LABEL_3:
    v6 = *v3 & v5;
    do
    {
      while (1)
      {
        v7 = __ldaxr(v3);
        if (v7 == v6)
          break;
        __clrex();
        if (*v3 != v6)
        {
          this = sched_yield();
          goto LABEL_3;
        }
      }
    }
    while (__stlxr(v6 | v4, v3));
    ++*(_DWORD *)(v1 + 32);
    if (*(_QWORD *)(v1 + 8))
    {
      v9 = *(_OWORD *)(v1 + 16);
      v8 = v1 + 16;
      v13 = v9;
      *(_QWORD *)(v9 + 8) = &v13;
      **(_QWORD **)(v8 + 8) = &v13;
      *(_QWORD *)v8 = v8;
      *(_QWORD *)(v8 + 8) = v8;
      *(_QWORD *)(v8 - 8) = 0;
    }
    for (i = (__int128 *)v13; i != &v13; i = *(__int128 **)i)
    {
      __dmb(0xBu);
      *((_BYTE *)i + 24) = 0;
    }
    __dmb(0xBu);
    *v2 = 0;
    v11 = (__int128 *)v13;
    if ((__int128 *)v13 != &v13)
    {
      do
      {
        v12 = *(__int128 **)v11;
        this = MEMORY[0x212B9381C](*((unsigned int *)v11 + 4));
        v11 = v12;
      }
      while (v12 != &v13);
    }
  }
  return this;
}

uint64_t tbb::internal::concurrent_monitor::abort_all_relaxed(uint64_t this)
{
  uint64_t v1;
  _BYTE *v2;
  unsigned int *v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  __int128 v9;
  __int128 *i;
  __int128 *v11;
  __int128 *v12;
  __int128 v13;

  if (*(_QWORD *)(this + 8))
  {
    v1 = this;
    *(_QWORD *)&v13 = &v13;
    *((_QWORD *)&v13 + 1) = &v13;
    v2 = (_BYTE *)(this + 1);
    v3 = (unsigned int *)((this + 1) & 0xFFFFFFFFFFFFFFFCLL);
    v4 = 1 << (8 * ((this + 1) & 3));
    v5 = ~(255 << (8 * ((this + 1) & 3)));
LABEL_3:
    v6 = *v3 & v5;
    do
    {
      while (1)
      {
        v7 = __ldaxr(v3);
        if (v7 == v6)
          break;
        __clrex();
        if (*v3 != v6)
        {
          this = sched_yield();
          goto LABEL_3;
        }
      }
    }
    while (__stlxr(v6 | v4, v3));
    ++*(_DWORD *)(v1 + 32);
    if (*(_QWORD *)(v1 + 8))
    {
      v9 = *(_OWORD *)(v1 + 16);
      v8 = v1 + 16;
      v13 = v9;
      *(_QWORD *)(v9 + 8) = &v13;
      **(_QWORD **)(v8 + 8) = &v13;
      *(_QWORD *)v8 = v8;
      *(_QWORD *)(v8 + 8) = v8;
      *(_QWORD *)(v8 - 8) = 0;
    }
    for (i = (__int128 *)v13; i != &v13; i = *(__int128 **)i)
    {
      __dmb(0xBu);
      *((_BYTE *)i + 24) = 0;
    }
    __dmb(0xBu);
    *v2 = 0;
    v11 = (__int128 *)v13;
    if ((__int128 *)v13 != &v13)
    {
      do
      {
        v12 = *(__int128 **)v11;
        *((_BYTE *)v11 + 26) = 1;
        this = MEMORY[0x212B9381C](*((unsigned int *)v11 + 4));
        v11 = v12;
      }
      while (v12 != &v13);
    }
  }
  return this;
}

uint64_t rml::internal::thread_monitor::join(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  uint64_t result;
  FILE *v3;
  char *v4;

  result = pthread_join(this, 0);
  if ((_DWORD)result)
  {
    v3 = (FILE *)*MEMORY[0x24BDAC8D8];
    v4 = strerror(result);
    fprintf(v3, "thread_monitor %s in %s\n", v4, "pthread_join");
    exit(1);
  }
  return result;
}

uint64_t rml::internal::thread_monitor::detach_thread(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  uint64_t result;
  FILE *v3;
  char *v4;

  result = pthread_detach(this);
  if ((_DWORD)result)
  {
    v3 = (FILE *)*MEMORY[0x24BDAC8D8];
    v4 = strerror(result);
    fprintf(v3, "thread_monitor %s in %s\n", v4, "pthread_detach");
    exit(1);
  }
  return result;
}

uint64_t tbb::internal::rml::private_worker::thread_routine(tbb::internal::rml::private_worker *this, void *a2)
{
  tbb::internal::rml::private_worker::run(this);
  return 0;
}

uint64_t tbb::internal::rml::private_worker::run(tbb::internal::rml::private_worker *this)
{
  tbb::internal::rml::private_server *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t result;
  unsigned int *v8;
  unsigned int v9;
  tbb::internal *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  void *v14;
  unsigned __int8 *v15;
  unsigned int *v16;
  char v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int *v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  unsigned int *v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  tbb::internal::rml::private_server *v43;
  uint64_t v44;
  _BYTE *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v2 = (tbb::internal::rml::private_server *)*((_QWORD *)this + 1);
  v3 = *((_QWORD *)v2 + 6);
  __dmb(0xBu);
  if (v3)
    tbb::internal::rml::private_server::wake_some(v2, 0);
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 24))(*((_QWORD *)this + 2));
  v5 = v4;
  v6 = *(_DWORD *)this;
  __dmb(0xBu);
  if (v6 != 3)
  {
    v15 = (unsigned __int8 *)this + 40;
    v16 = (unsigned int *)(((unint64_t)this + 40) & 0xFFFFFFFFFFFFFFFCLL);
    v17 = 8 * (((_BYTE)this + 40) & 3);
    v18 = 255 << v17;
    v19 = ~(255 << v17);
    v47 = v4;
    do
    {
      v21 = *(_DWORD *)(*((_QWORD *)this + 1) + 32);
      __dmb(0xBu);
      if (v21 < 0)
      {
        if (*((_BYTE *)this + 41))
        {
          *((_BYTE *)this + 41) = 0;
          while (MEMORY[0x212B93828](*((unsigned int *)this + 11)) == 14)
            ;
        }
        v22 = *((_QWORD *)this + 4);
        __dmb(0xBu);
        v48 = v22;
        __dmb(0xBu);
        *((_BYTE *)this + 40) = 1;
        __dmb(0xBu);
        LODWORD(v22) = *(_DWORD *)this;
        __dmb(0xBu);
        if ((_DWORD)v22 != 3)
        {
          v23 = *((_QWORD *)this + 1);
          v24 = (unsigned int *)((v23 + 56) & 0xFFFFFFFFFFFFFFFCLL);
          v45 = (_BYTE *)(v23 + 56);
          v25 = 255 << (8 * ((v23 + 56) & 3));
          v26 = 1 << (8 * ((v23 + 56) & 3));
LABEL_19:
          v27 = *v24 & ~v25;
          do
          {
            while (1)
            {
              v28 = __ldaxr(v24);
              if (v28 == v27)
                break;
              __clrex();
              if (*v24 != v27)
              {
                if ((*v24 & v25) != 0)
                  goto LABEL_31;
                v46 = v23;
                sched_yield();
                v23 = v46;
                goto LABEL_19;
              }
            }
          }
          while (__stlxr(v27 | v26, v24));
          v29 = (unsigned int *)(v23 + 32);
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 + 1, v29));
          if ((v30 & 0x80000000) != 0)
          {
            v36 = *(_QWORD *)(v23 + 48);
            __dmb(0xBu);
            *((_QWORD *)this + 7) = v36;
            __dmb(0xBu);
            *(_QWORD *)(v23 + 48) = this;
            __dmb(0xBu);
            *(_BYTE *)(v23 + 56) = 0;
            v37 = v48;
            __dmb(0xBu);
            v38 = *((_QWORD *)this + 4);
            __dmb(0xBu);
            if (v37 == v38)
            {
              v5 = v47;
              while (MEMORY[0x212B93828](*((unsigned int *)this + 11)) == 14)
                ;
            }
            else
            {
              while (1)
              {
                v39 = *v15;
                while (1)
                {
                  v40 = *v16 & v19;
                  v41 = v40 | (v39 << v17);
                  do
                  {
                    while (1)
                    {
                      v42 = __ldaxr(v16);
                      if (v42 != v41)
                        break;
                      if (!__stlxr(v40, v16))
                        goto LABEL_55;
                    }
                    __clrex();
                  }
                  while (*v16 == v41);
                  if (((*v16 ^ v41) & v18) != 0)
                    break;
                  sched_yield();
                }
                v41 = *v16;
LABEL_55:
                if (v39 == ((v41 & v18) >> v17))
                  break;
                sched_yield();
              }
              *((_BYTE *)this + 41) = (v39 & 1) == 0;
              v5 = v47;
            }
            v43 = (tbb::internal::rml::private_server *)*((_QWORD *)this + 1);
            v44 = *((_QWORD *)v43 + 6);
            __dmb(0xBu);
            if (v44)
              tbb::internal::rml::private_server::wake_some(v43, 0);
            goto LABEL_12;
          }
          do
            v31 = __ldaxr(v29);
          while (__stlxr(v31 - 1, v29));
          __dmb(0xBu);
          *v45 = 0;
        }
LABEL_31:
        while (1)
        {
          v32 = *v15;
          while (1)
          {
            v33 = *v16 & v19;
            v34 = v33 | (v32 << v17);
            do
            {
              while (1)
              {
                v35 = __ldaxr(v16);
                if (v35 != v34)
                  break;
                if (!__stlxr(v33, v16))
                  goto LABEL_40;
              }
              __clrex();
            }
            while (*v16 == v34);
            if (((*v16 ^ v34) & v18) != 0)
              break;
            sched_yield();
          }
          v34 = *v16;
LABEL_40:
          if (v32 == ((v34 & v18) >> v17))
            break;
          sched_yield();
        }
        *((_BYTE *)this + 41) = (v32 & 1) == 0;
        v5 = v47;
      }
      else
      {
        (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 2) + 56))(*((_QWORD *)this + 2), v5);
      }
LABEL_12:
      v20 = *(_DWORD *)this;
      __dmb(0xBu);
    }
    while (v20 != 3);
  }
  result = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 2) + 48))(*((_QWORD *)this + 2), v5);
  v8 = (unsigned int *)(*((_QWORD *)this + 1) + 32);
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 + 1, v8));
  v10 = (tbb::internal *)*((_QWORD *)this + 1);
  v11 = (unsigned int *)((char *)v10 + 36);
  do
  {
    v12 = __ldaxr(v11);
    v13 = v12 - 1;
  }
  while (__stlxr(v13, v11));
  if (!v13)
  {
    (*(void (**)(_QWORD))(**((_QWORD **)v10 + 1) + 32))(*((_QWORD *)v10 + 1));
    (*(void (**)(tbb::internal *))(*(_QWORD *)v10 + 48))(v10);
    return tbb::internal::NFS_Free(v10, v14);
  }
  return result;
}

uint64_t tbb::internal::rml::private_worker::release_handle(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  uint64_t result;
  FILE *v3;
  char *v4;
  const char *v5;

  if ((_DWORD)a2)
  {
    result = pthread_join(this, 0);
    if ((_DWORD)result)
    {
      v3 = (FILE *)*MEMORY[0x24BDAC8D8];
      v4 = strerror(result);
      v5 = "pthread_join";
      goto LABEL_7;
    }
  }
  else
  {
    result = pthread_detach(this);
    if ((_DWORD)result)
    {
      v3 = (FILE *)*MEMORY[0x24BDAC8D8];
      v4 = strerror(result);
      v5 = "pthread_detach";
LABEL_7:
      fprintf(v3, "thread_monitor %s in %s\n", v4, v5);
      exit(1);
    }
  }
  return result;
}

uint64_t tbb::internal::rml::private_worker::start_shutdown(uint64_t this)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int *v5;
  char v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  tbb::internal *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  void *v16;
  _opaque_pthread_t *v17;
  _opaque_pthread_t *does_client_join_workers;

  v1 = this;
LABEL_2:
  v2 = *(_DWORD *)this;
  __dmb(0xBu);
  do
  {
    while (1)
    {
      v3 = __ldaxr((unsigned int *)this);
      if (v3 == v2)
        break;
      __clrex();
      if (*(_DWORD *)this != v2)
        goto LABEL_2;
    }
  }
  while (__stlxr(3u, (unsigned int *)this));
  if (v2 - 1 > 1)
  {
    if (!v2)
    {
      v12 = *(tbb::internal **)(this + 8);
      v13 = (unsigned int *)((char *)v12 + 36);
      do
      {
        v14 = __ldaxr(v13);
        v15 = v14 - 1;
      }
      while (__stlxr(v15, v13));
      if (!v15)
      {
        (*(void (**)(_QWORD))(**((_QWORD **)v12 + 1) + 32))(*((_QWORD *)v12 + 1));
        (*(void (**)(tbb::internal *))(*(_QWORD *)v12 + 48))(v12);
        return tbb::internal::NFS_Free(v12, v16);
      }
    }
  }
  else
  {
    v4 = *(_QWORD *)(this + 32);
    __dmb(0xBu);
    __dmb(0xBu);
    *(_QWORD *)(this + 32) = v4 + 1;
    v5 = (unsigned int *)((this + 40) & 0xFFFFFFFFFFFFFFFCLL);
    v6 = 8 * ((this + 40) & 3);
    v7 = 255 << v6;
    while (1)
    {
      v8 = *(unsigned __int8 *)(v1 + 40);
      while (1)
      {
        v9 = *v5 & ~v7;
        v10 = v9 | (v8 << v6);
        do
        {
          while (1)
          {
            v11 = __ldaxr(v5);
            if (v11 != v10)
              break;
            if (!__stlxr(v9, v5))
              goto LABEL_17;
          }
          __clrex();
        }
        while (*v5 == v10);
        if (((*v5 ^ v10) & v7) != 0)
          break;
        this = sched_yield();
      }
      v10 = *v5;
LABEL_17:
      if (v8 == ((v10 & v7) >> v6))
        break;
      this = sched_yield();
    }
    if ((v8 & 1) != 0)
      this = MEMORY[0x212B9381C](*(unsigned int *)(v1 + 44));
    if (v2 == 2)
    {
      v17 = *(_opaque_pthread_t **)(v1 + 48);
      does_client_join_workers = (_opaque_pthread_t *)tbb::internal::governor::does_client_join_workers(*(_QWORD *)(v1 + 16));
      return tbb::internal::rml::private_worker::release_handle(v17, does_client_join_workers);
    }
  }
  return this;
}

uint64_t tbb::internal::rml::private_server::private_server(uint64_t a1, uint64_t a2)
{
  int v4;
  void *v5;
  uint64_t v6;
  unint64_t v7;
  task_t *v8;
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)a1 = off_24C515F58;
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  *(_QWORD *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  v4 = *(_DWORD *)(a1 + 16) + 1;
  __dmb(0xBu);
  *(_DWORD *)(a1 + 36) = v4;
  __dmb(0xBu);
  *(_DWORD *)(a1 + 32) = 0;
  __dmb(0xBu);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 40) = tbb::internal::NFS_Allocate(*(unsigned int *)(a1 + 16), 128, 0, v5);
  if (*(_DWORD *)(a1 + 16))
  {
    v6 = 0;
    v7 = 0;
    v8 = (task_t *)MEMORY[0x24BDAEC58];
    do
    {
      v9 = *(_QWORD *)(a1 + 40) + v6;
      *(_QWORD *)(v9 + 8) = a1;
      *(_QWORD *)(v9 + 16) = a2;
      *(_QWORD *)(v9 + 24) = v7;
      *(_BYTE *)(v9 + 41) = 0;
      *(_DWORD *)(v9 + 44) = 0;
      semaphore_create(*v8, (semaphore_t *)(v9 + 44), 0, 0);
      __dmb(0xBu);
      *(_QWORD *)(v9 + 32) = 0;
      __dmb(0xBu);
      *(_BYTE *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      __dmb(0xBu);
      *(_DWORD *)v9 = 0;
      v10 = *(_QWORD *)(a1 + 48);
      __dmb(0xBu);
      *(_QWORD *)(v9 + 56) = v10;
      __dmb(0xBu);
      *(_QWORD *)(a1 + 48) = v9;
      ++v7;
      v6 += 128;
    }
    while (v7 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

void tbb::internal::rml::private_server::~private_server(tbb::internal::rml::private_server *this, void *a2)
{
  unint64_t v3;
  task_t *v4;
  unint64_t v5;

  *(_QWORD *)this = off_24C515F58;
  v3 = ((unint64_t)*((unsigned int *)this + 4) << 7) - 84;
  v4 = (task_t *)MEMORY[0x24BDAEC58];
  while (1)
  {
    v5 = v3 - 128;
    if (v3 == -84)
      break;
    semaphore_destroy(*v4, *(_DWORD *)(*((_QWORD *)this + 5) + v3));
    v3 = v5;
  }
  tbb::internal::NFS_Free(*((tbb::internal **)this + 5), a2);
}

{
  unint64_t v3;
  task_t *v4;
  unint64_t v5;

  *(_QWORD *)this = off_24C515F58;
  v3 = ((unint64_t)*((unsigned int *)this + 4) << 7) - 84;
  v4 = (task_t *)MEMORY[0x24BDAEC58];
  while (1)
  {
    v5 = v3 - 128;
    if (v3 == -84)
      break;
    semaphore_destroy(*v4, *(_DWORD *)(*((_QWORD *)this + 5) + v3));
    v3 = v5;
  }
  tbb::internal::NFS_Free(*((tbb::internal **)this + 5), a2);
}

{
  unint64_t v3;
  task_t *v4;
  unint64_t v5;

  *(_QWORD *)this = off_24C515F58;
  v3 = ((unint64_t)*((unsigned int *)this + 4) << 7) - 84;
  v4 = (task_t *)MEMORY[0x24BDAEC58];
  while (1)
  {
    v5 = v3 - 128;
    if (v3 == -84)
      break;
    semaphore_destroy(*v4, *(_DWORD *)(*((_QWORD *)this + 5) + v3));
    v3 = v5;
  }
  tbb::internal::NFS_Free(*((tbb::internal **)this + 5), a2);
  operator delete(this);
}

pthread_t tbb::internal::rml::private_server::wake_some(pthread_t this, int a2)
{
  uint64_t v3;
  char *v4;
  unsigned int *v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int *v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v3 = (uint64_t)this;
  v27 = *MEMORY[0x24BDAC8D0];
  v25 = 0;
  v26 = 0;
  v4 = &this->__opaque[40];
  v5 = (unsigned int *)((unint64_t)&this->__opaque[40] & 0xFFFFFFFFFFFFFFFCLL);
  v6 = 1 << (8 * (((_BYTE)this + 56) & 3));
  v7 = ~(255 << (8 * (((_BYTE)this + 56) & 3)));
LABEL_2:
  v8 = *v5 & v7;
  do
  {
    while (1)
    {
      v9 = __ldaxr(v5);
      if (v9 == v8)
        break;
      __clrex();
      if (*v5 != v8)
      {
        this = (pthread_t)sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v8 | v6, v5));
  v10 = *(_QWORD *)(v3 + 48);
  __dmb(0xBu);
  if (!v10)
  {
    v15 = &v25;
    goto LABEL_18;
  }
  v11 = (unsigned int *)(v3 + 32);
  v12 = *(_DWORD *)(v3 + 32);
  __dmb(0xBu);
  if (a2 <= 0)
  {
    if (v12 < 1)
    {
      v15 = &v25;
    }
    else
    {
      while (1)
      {
        while (1)
        {
          v20 = __ldaxr(v11);
          if (v20 != v12)
            break;
          if (!__stlxr(v12 - 1, v11))
            goto LABEL_12;
        }
        __clrex();
        if (*v11 != v12)
        {
          v12 = *v11;
          __dmb(0xBu);
          v15 = &v25;
          if (v12 <= 0)
            break;
        }
      }
    }
  }
  else
  {
    if (v12 + a2 < 1)
    {
      v15 = &v25;
      goto LABEL_29;
    }
    --a2;
LABEL_12:
    v13 = *(_QWORD *)(v3 + 48);
    __dmb(0xBu);
    v25 = v13;
    v14 = *(_QWORD *)(v13 + 56);
    __dmb(0xBu);
    *(_QWORD *)(v3 + 48) = v14;
    v15 = &v26;
    v16 = *(_QWORD *)(v3 + 48);
    __dmb(0xBu);
    if (!v16)
    {
LABEL_18:
      if (!a2)
        goto LABEL_31;
      goto LABEL_29;
    }
    v17 = *v11;
    __dmb(0xBu);
    if (a2 > 0)
    {
      if (v17 + a2 >= 1)
      {
        --a2;
LABEL_16:
        v18 = *(_QWORD *)(v3 + 48);
        __dmb(0xBu);
        v26 = v18;
        v19 = *(_QWORD *)(v18 + 56);
        __dmb(0xBu);
        *(_QWORD *)(v3 + 48) = v19;
        v15 = &v27;
        __dmb(0xBu);
        goto LABEL_18;
      }
LABEL_29:
      v21 = (unsigned int *)(v3 + 32);
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 + a2, v21));
      goto LABEL_31;
    }
    if (v17 >= 1)
    {
      while (1)
      {
        while (1)
        {
          v24 = __ldaxr(v11);
          if (v24 != v17)
            break;
          if (!__stlxr(v17 - 1, v11))
            goto LABEL_16;
        }
        __clrex();
        if (*v11 != v17)
        {
          v17 = *v11;
          __dmb(0xBu);
          if (v17 <= 0)
            break;
        }
      }
    }
  }
LABEL_31:
  __dmb(0xBu);
  *v4 = 0;
  while (v15 > &v25)
  {
    v23 = *--v15;
    *(_QWORD *)(v23 + 56) = 0;
    this = sub_20BDCA434((pthread_t)v23);
  }
  return this;
}

pthread_t sub_20BDCA434(pthread_t result)
{
  pthread_t v1;
  unsigned int sig;
  uint64_t v4;
  unsigned int *v5;
  char v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  _opaque_pthread_t *v13;
  _opaque_pthread_t *does_client_join_workers;

  v1 = result;
  sig = result->__sig;
  __dmb(0xBu);
  if (sig)
  {
LABEL_6:
    v4 = *(_QWORD *)&result->__opaque[16];
    __dmb(0xBu);
    __dmb(0xBu);
    *(_QWORD *)&result->__opaque[16] = v4 + 1;
    v5 = (unsigned int *)((unint64_t)&result->__opaque[24] & 0xFFFFFFFFFFFFFFFCLL);
    v6 = 8 * (((_BYTE)result + 40) & 3);
    v7 = 255 << v6;
    while (1)
    {
      v8 = v1->__opaque[24];
      while (1)
      {
        v9 = *v5 & ~v7;
        v10 = v9 | (v8 << v6);
        do
        {
          while (1)
          {
            v11 = __ldaxr(v5);
            if (v11 != v10)
              break;
            if (!__stlxr(v9, v5))
              goto LABEL_16;
          }
          __clrex();
        }
        while (*v5 == v10);
        if (((*v5 ^ v10) & v7) != 0)
          break;
        result = (pthread_t)sched_yield();
      }
      v10 = *v5;
LABEL_16:
      if (v8 == ((v10 & v7) >> v6))
        break;
      result = (pthread_t)sched_yield();
    }
    if ((v8 & 1) != 0)
      JUMPOUT(0x212B9381CLL);
  }
  else
  {
    do
    {
      while (__ldaxr((unsigned int *)result))
      {
        __clrex();
        if (LODWORD(result->__sig))
          goto LABEL_6;
      }
    }
    while (__stlxr(1u, (unsigned int *)result));
    result = sub_20BDCA770((void *(__cdecl *)(void *))tbb::internal::rml::private_worker::thread_routine, result, (size_t)result->__cleanup_stack[1].__routine);
    *(_QWORD *)&v1->__opaque[32] = result;
    do
    {
      while (1)
      {
        v12 = __ldaxr((unsigned int *)v1);
        if (v12 != 1)
          break;
        if (!__stlxr(2u, (unsigned int *)v1))
          return result;
      }
      __clrex();
    }
    while (LODWORD(v1->__sig) == 1);
    v13 = *(_opaque_pthread_t **)&v1->__opaque[32];
    does_client_join_workers = (_opaque_pthread_t *)tbb::internal::governor::does_client_join_workers(*(_QWORD *)v1->__opaque);
    return (pthread_t)tbb::internal::rml::private_worker::release_handle(v13, does_client_join_workers);
  }
  return result;
}

pthread_t tbb::internal::rml::private_server::adjust_job_count_estimate(pthread_t this, int a2)
{
  unsigned int *v2;
  unsigned int v3;

  if (a2 < 0)
  {
    v2 = (unsigned int *)&this->__opaque[16];
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + a2, v2));
  }
  else if (a2)
  {
    return tbb::internal::rml::private_server::wake_some(this, a2);
  }
  return this;
}

uint64_t tbb::internal::rml::make_private_server(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5;

  v5 = tbb::internal::NFS_Allocate(1uLL, 64, 0, a4);
  return tbb::internal::rml::private_server::private_server(v5, a1);
}

uint64_t sub_20BDCA620()
{
  return 0;
}

uint64_t sub_20BDCA628(uint64_t result)
{
  tbb::internal *v1;
  uint64_t v2;
  unint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  void *v7;

  v1 = (tbb::internal *)result;
  if (*(_DWORD *)(result + 16))
  {
    v2 = 0;
    v3 = 0;
    do
    {
      result = tbb::internal::rml::private_worker::start_shutdown(*((_QWORD *)v1 + 5) + v2);
      ++v3;
      v2 += 128;
    }
    while (v3 < *((unsigned int *)v1 + 4));
  }
  v4 = (unsigned int *)((char *)v1 + 36);
  do
  {
    v5 = __ldaxr(v4);
    v6 = v5 - 1;
  }
  while (__stlxr(v6, v4));
  if (!v6)
  {
    (*(void (**)(_QWORD))(**((_QWORD **)v1 + 1) + 32))(*((_QWORD *)v1 + 1));
    (*(void (**)(tbb::internal *))(*(_QWORD *)v1 + 48))(v1);
    return tbb::internal::NFS_Free(v1, v7);
  }
  return result;
}

uint64_t sub_20BDCA6CC()
{
  int v0;
  size_t v2;
  int v3;
  int v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v0 = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(_QWORD *)v4 = 0x1900000006;
    v3 = 0;
    v2 = 4;
    sysctl(v4, 2u, &v3, &v2, 0, 0);
    v0 = v3;
    if (v3 <= 1)
      v0 = 1;
    tbb::internal::governor::DefaultNumberOfThreads = v0;
  }
  return (v0 - 1);
}

pthread_t sub_20BDCA770(void *(__cdecl *a1)(void *), void *a2, size_t a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  FILE *v11;
  char *v12;
  const char *v13;
  pthread_t v14;
  pthread_attr_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v6 = pthread_attr_init(&v15);
  if (v6)
  {
    v11 = (FILE *)*MEMORY[0x24BDAC8D8];
    v12 = strerror(v6);
    v13 = "pthread_attr_init";
    goto LABEL_11;
  }
  if (a3)
  {
    v7 = pthread_attr_setstacksize(&v15, a3);
    if (v7)
    {
      v11 = (FILE *)*MEMORY[0x24BDAC8D8];
      v12 = strerror(v7);
      v13 = "pthread_attr_setstack_size";
LABEL_11:
      fprintf(v11, "thread_monitor %s in %s\n", v12, v13);
      exit(1);
    }
  }
  v14 = 0;
  v8 = pthread_create(&v14, &v15, a1, a2);
  if (v8)
  {
    v11 = (FILE *)*MEMORY[0x24BDAC8D8];
    v12 = strerror(v8);
    v13 = "pthread_create";
    goto LABEL_11;
  }
  v9 = pthread_attr_destroy(&v15);
  if (v9)
  {
    v11 = (FILE *)*MEMORY[0x24BDAC8D8];
    v12 = strerror(v9);
    v13 = "pthread_attr_destroy";
    goto LABEL_11;
  }
  return v14;
}

uint64_t tbb::internal::rml::tbb_factory::open(tbb::internal::rml::tbb_factory *this)
{
  _QWORD *v2;
  int v4;
  uint64_t (*v5)(tbb::internal::rml::tbb_factory *, int *, uint64_t);
  _QWORD v6[9];

  v6[8] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)((char *)this + 16);
  v5 = 0;
  v6[0] = "__RML_open_factory";
  v6[1] = &v5;
  v6[2] = "__TBB_make_rml_server";
  v6[3] = (char *)this + 24;
  v6[4] = "__RML_close_factory";
  v6[5] = (char *)this + 8;
  v6[6] = "__TBB_call_with_my_server_info";
  v6[7] = (char *)this + 32;
  if (tbb::internal::dynamic_link((uint64_t)"libirml.dylib", (uint64_t)v6, 4, (_QWORD *)this + 2))
  {
    v4 = 0;
    return v5(this, &v4, 2);
  }
  else
  {
    *v2 = 0;
    return 2;
  }
}

unint64_t tbb::internal::rml::tbb_factory::close(unint64_t this)
{
  unint64_t v1;
  void *v2;

  if (*(_QWORD *)(this + 16))
  {
    v1 = this;
    (*(void (**)(void))(this + 8))();
    this = *(_QWORD *)(v1 + 16);
    if (this >= 2)
    {
      this = tbb::internal::dynamic_unlink((tbb::internal *)this, v2);
      *(_QWORD *)(v1 + 16) = 0;
    }
  }
  return this;
}

uint64_t tbb::internal::rml::tbb_factory::make_server(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 24))();
}

uint64_t tbb::internal::rml::tbb_factory::call_with_server_info(tbb::internal::rml::tbb_factory *this, void (*a2)(void *, const char *), void *a3)
{
  return (*((uint64_t (**)(_QWORD, void *))this + 4))(a2, a3);
}

void *tbb::set_assertion_handler(tbb *this, void (*a2)(const char *, int, const char *, const char *))
{
  void *v2;

  v2 = off_254784D70;
  off_254784D70 = this;
  return v2;
}

const char *tbb::assertion_failure(const char *this, const char *a2, const char *a3, const char *a4, const char *a5)
{
  if (off_254784D70)
    return (const char *)off_254784D70(this, a2, a3, a4);
  if ((byte_254784D78 & 1) == 0)
    sub_20C96AE98(a3, (int)a2, this, a4);
  return this;
}

uint64_t tbb::internal::runtime_warning(tbb::internal *this, const char *a2, ...)
{
  char __str[1024];
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  v5 = *MEMORY[0x24BDAC8D0];
  bzero(__str, 0x400uLL);
  vsnprintf(__str, 0x3FFuLL, (const char *)this, va);
  return fprintf((FILE *)*MEMORY[0x24BDAC8D8], "TBB Warning: %s\n", __str);
}

const char *tbb::bad_last_alloc::what(tbb::bad_last_alloc *this)
{
  return "bad allocation in previous or concurrent attempt";
}

const char *tbb::improper_lock::what(tbb::improper_lock *this)
{
  return "attempted recursive lock on critical section or non-recursive mutex";
}

const char *tbb::user_abort::what(tbb::user_abort *this)
{
  return "User-initiated abort has terminated this operation";
}

const char *tbb::invalid_multiple_scheduling::what(tbb::invalid_multiple_scheduling *this)
{
  return "The same task_handle object cannot be executed more than once";
}

const char *tbb::missing_wait::what(tbb::missing_wait *this)
{
  return "wait() was not called on the structured_task_group";
}

uint64_t tbb::internal::DefaultSystemPageSize(tbb::internal *this)
{
  return sysconf(29);
}

void tbb::internal::handle_perror(tbb::internal *this, const char *a2, const char *a3)
{
  char *v4;
  std::runtime_error *exception;
  char __str[256];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v4 = strerror((int)this);
  snprintf(__str, 0x100uLL, "%s: %s", a2, v4);
  __str[255] = 0;
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, __str);
  __cxa_throw(exception, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
}

void sub_20BDCAB90(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void tbb::internal::throw_bad_last_alloc_exception_v4(tbb::internal *this)
{
  std::bad_alloc *exception;
  std::bad_alloc *v2;

  exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
  exception->__vftable = 0;
  v2 = sub_20BDCAF24(exception);
}

uint64_t tbb::internal::throw_exception_v4(uint64_t result)
{
  std::bad_alloc *exception;
  std::bad_alloc *v2;
  std::bad_alloc *v3;
  std::bad_alloc *v4;
  std::logic_error *v5;
  std::logic_error *v6;
  std::runtime_error *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  std::runtime_error *v11;
  std::logic_error *v12;
  _QWORD *v13;

  switch((int)result)
  {
    case 1:
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v2 = std::bad_alloc::bad_alloc(exception);
      __cxa_throw(v2, MEMORY[0x24BEDB758], MEMORY[0x24BEDB670]);
    case 2:
      v3 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v3->__vftable = 0;
      v4 = sub_20BDCAF24(v3);
    case 3:
      v5 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_20BDCAF48(v5, "Step must be positive");
      goto LABEL_18;
    case 4:
      v6 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_20BDCAF6C(v6, "Index out of requested size range");
      goto LABEL_21;
    case 5:
      v7 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_20BDCAF90(v7, "Index out of allocated segment slots");
      goto LABEL_8;
    case 6:
      v7 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_20BDCAF90(v7, "Index is not allocated");
LABEL_8:
      __cxa_throw(v7, (struct type_info *)off_24C514D50, MEMORY[0x24BEDAAD0]);
    case 7:
      v8 = __cxa_allocate_exception(8uLL);
      *v8 = &off_24C516138;
    case 8:
      v9 = __cxa_allocate_exception(8uLL);
      *v9 = &off_24C516110;
    case 9:
      v10 = __cxa_allocate_exception(8uLL);
      *v10 = &off_24C5160C0;
    case 10:
      v11 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v11, "Resource deadlock would occur");
      break;
    case 11:
      v11 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v11, "Operation not permitted");
      break;
    case 12:
      v11 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v11, "Wait on condition variable failed");
      break;
    case 13:
      v6 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_20BDCAF6C(v6, "Invalid hash load factor");
      goto LABEL_21;
    case 14:
      v6 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_20BDCAF6C(v6, "[backward compatibility] Invalid number of buckets");
      goto LABEL_21;
    case 15:
      v5 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_20BDCAF48(v5, "swap() is invalid on non-equal allocators");
LABEL_18:
      __cxa_throw(v5, (struct type_info *)off_24C514D78, MEMORY[0x24BEDAB88]);
    case 16:
      v12 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_20BDCAFB8(v12, "reservation size exceeds permitted max size");
      __cxa_throw(v12, (struct type_info *)off_24C514D60, MEMORY[0x24BEDAAF0]);
    case 17:
      v6 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_20BDCAF6C(v6, "invalid key");
LABEL_21:
      __cxa_throw(v6, (struct type_info *)off_24C514D68, MEMORY[0x24BEDAB00]);
    case 18:
      v13 = __cxa_allocate_exception(8uLL);
      *v13 = &off_24C5160E8;
    case 19:
      v11 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v11, "Blocking terminate failed");
      break;
    case 20:
      v11 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v11, "Illegal tagged_msg cast");
      break;
    default:
      return result;
  }
  __cxa_throw(v11, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
}

void sub_20BDCAEDC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::bad_alloc *sub_20BDCAF24(std::bad_alloc *a1)
{
  std::bad_alloc *result;

  result = std::bad_alloc::bad_alloc(a1);
  result->__vftable = (std::bad_alloc_vtbl *)&off_24C516098;
  return result;
}

std::logic_error *sub_20BDCAF48(std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8D0] + 16);
  return result;
}

std::logic_error *sub_20BDCAF6C(std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  return result;
}

std::runtime_error *sub_20BDCAF90(std::runtime_error *a1, const char *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x24BEDB8A0] + 16);
  return result;
}

std::logic_error *sub_20BDCAFB8(std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

uint64_t tbb::internal::gcc_rethrow_exception_broken(tbb::internal *this)
{
  return 0;
}

uint64_t tbb::internal::PrintVersion(tbb::internal *this)
{
  byte_254784D79 = 1;
  return fputs("TBB: VERSION\t\t2020.3\nTBB: INTERFACE VERSION\t11103\nTBB: BUILD_DATE\t\tSat Aug 3 14:27:06 UTC 2024\nTBB: BUILD_HOST\t\tghxrl (i386)\nTBB: BUILD_OS\t\tmacOS version 13.0\nTBB: BUILD_KERNEL\tDarwin Kernel Version 22.1.0: Thu Dec 15 17:42:24 PST 2022; root:xnu-8792.41.9.100.2~1/DEV"
           "ELOPMENT_X86_64\n"
           "TBB: BUILD_CLANG\tApple clang version 16.0.0 (clang-1600.0.25.3) [+internal-os]\n"
           "TBB: BUILD_XCODE\tXcode 16.0\n"
           "TBB: BUILD_TARGET\tarm64 arm64e on cc_ios\n"
           "TBB: BUILD_COMMAND\tclang++ -g -O2 -Werror=global-constructors -DUSE_PTHREAD -stdlib=libc++ -arch arm64 -arch"
           " arm64e -isysroot /AppleInternal/Library/BuildRoots/ae269ea5-5122-11ef-a621-12147c76fa9d/Applications/Xcode.a"
           "pp/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk -fPIC -D__TBB_BUIL"
           "D=1 -Wall -Wno-non-virtual-dtor -Wno-dangling-else -D__TBB_DYNAMIC_LOAD_ENABLED=0 -D__TBB_SOURCE_DIRECTLY_INC"
           "LUDED=1 -DTBB_SUPPRESS_DEPRECATED_MESSAGES=1 -std=c++14 -I/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB"
           "-2020.3/./src -I/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/rml/include -I/Library/Cache"
           "s/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./include -I.\n"
           "TBB: TBB_USE_DEBUG\t0\n"
           "TBB: TBB_USE_ASSERT\t0\n"
           "TBB: DO_ITT_NOTIFY\tundefined\n",
           (FILE *)*MEMORY[0x24BDAC8D8]);
}

const char *tbb::internal::PrintExtraVersionInfo(const char *this, const char *a2, const char *a3, ...)
{
  const char *v4;
  char __str[1024];
  uint64_t v6;
  va_list va;

  va_start(va, a3);
  v6 = *MEMORY[0x24BDAC8D0];
  if (byte_254784D79 == 1)
  {
    v4 = this;
    bzero(__str, 0x400uLL);
    vsnprintf(__str, 0x3FFuLL, a2, va);
    return (const char *)fprintf((FILE *)*MEMORY[0x24BDAC8D8], "TBB: %s\t%s\n", v4, __str);
  }
  return this;
}

const char *tbb::internal::PrintRMLVersionInfo(tbb::internal *this, tbb::internal *a2, const char *a3)
{
  return tbb::internal::PrintExtraVersionInfo((const char *)a2, (const char *)this, a3);
}

uint64_t tbb::internal::cpu_has_speculation(tbb::internal *this)
{
  return 0;
}

uint64_t TBB_runtime_interface_version()
{
  return 11103;
}

void sub_20BDCB0E0(std::bad_alloc *a1)
{
  void *v1;

  std::bad_alloc::~bad_alloc(a1);
  operator delete(v1);
}

void sub_20BDCB0F4(std::exception *a1)
{
  void *v1;

  std::exception::~exception(a1);
  operator delete(v1);
}

unint64_t tbb::internal::allocate_root_proxy::allocate(tbb::internal::allocate_root_proxy *this)
{
  unint64_t v2;
  tbb::internal::generic_scheduler *inited;

  v2 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v2)
    inited = (tbb::internal::generic_scheduler *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  else
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  return tbb::internal::generic_scheduler::allocate_task(inited, (unint64_t)this, 0, *(tbb::task_group_context **)(*((_QWORD *)inited + 7) - 56));
}

unint64_t tbb::internal::allocate_root_proxy::free(tbb::internal::allocate_root_proxy *this, tbb::task *a2)
{
  unint64_t v3;
  void *v4;
  unint64_t result;

  v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3)
    result = v3 & 0xFFFFFFFFFFFFFFFELL;
  else
    result = tbb::internal::governor::init_scheduler_weak(0);
  *((_BYTE *)this - 12) = 4;
  if (*((_QWORD *)this - 6) != result)
    return tbb::internal::NFS_Free((tbb::internal::allocate_root_proxy *)((char *)this - 64), v4);
  *((_QWORD *)this - 1) = *(_QWORD *)(result + 136);
  *(_QWORD *)(result + 136) = this;
  return result;
}

unint64_t tbb::internal::allocate_root_with_context_proxy::allocate(tbb::task_group_context **this, unint64_t a2)
{
  unint64_t v4;
  unint64_t inited;
  uint64_t v6;
  void *v7;
  unint64_t task;
  tbb::task_group_context *v9;

  v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4)
    inited = v4 & 0xFFFFFFFFFFFFFFFELL;
  else
    inited = tbb::internal::governor::init_scheduler_weak(0);
  task = tbb::internal::generic_scheduler::allocate_task((tbb::internal::generic_scheduler *)inited, a2, 0, *this);
  v9 = *this;
  if (*(_DWORD *)*this != 1)
  {
LABEL_7:
    if (*(_DWORD *)v9)
      return task;
    goto LABEL_8;
  }
  if ((~*(unsigned __int8 *)(inited + 74) & 3) == 0)
  {
    *(_DWORD *)v9 = 0;
    goto LABEL_7;
  }
  tbb::task_group_context::bind_to((uint64_t)v9, (tbb::internal::generic_scheduler *)inited, v6, v7);
  v9 = *this;
  if (*(_DWORD *)*this)
    return task;
LABEL_8:
  if ((*((_BYTE *)v9 + 130) & 2) == 0)
    tbb::task_group_context::copy_fp_settings(v9, *(const tbb::task_group_context **)(*(_QWORD *)(inited + 144) - 56), v6, v7);
  return task;
}

unint64_t tbb::internal::allocate_root_with_context_proxy::free(tbb::internal::allocate_root_with_context_proxy *this, tbb::task *a2)
{
  unint64_t v3;
  void *v4;
  unint64_t result;

  v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3)
    result = v3 & 0xFFFFFFFFFFFFFFFELL;
  else
    result = tbb::internal::governor::init_scheduler_weak(0);
  *((_BYTE *)a2 - 12) = 4;
  if (*((_QWORD *)a2 - 6) != result)
    return tbb::internal::NFS_Free((tbb::task *)((char *)a2 - 64), v4);
  *((_QWORD *)a2 - 1) = *(_QWORD *)(result + 136);
  *(_QWORD *)(result + 136) = a2;
  return result;
}

unint64_t tbb::internal::allocate_continuation_proxy::allocate(tbb::internal::allocate_continuation_proxy *this, unint64_t a2)
{
  unint64_t v4;
  tbb::internal::generic_scheduler *inited;
  tbb::task *v6;

  v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4)
    inited = (tbb::internal::generic_scheduler *)(v4 & 0xFFFFFFFFFFFFFFFELL);
  else
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  v6 = (tbb::task *)*((_QWORD *)this - 4);
  *((_QWORD *)this - 4) = 0;
  return tbb::internal::generic_scheduler::allocate_task(inited, a2, v6, *((tbb::task_group_context **)this - 7));
}

unint64_t tbb::internal::allocate_continuation_proxy::free(tbb::internal::allocate_continuation_proxy *this, tbb::task *a2)
{
  unint64_t v3;
  void *v4;
  unint64_t result;

  *((_QWORD *)this - 4) = *((_QWORD *)a2 - 4);
  v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3)
    result = v3 & 0xFFFFFFFFFFFFFFFELL;
  else
    result = tbb::internal::governor::init_scheduler_weak(0);
  *((_BYTE *)a2 - 12) = 4;
  if (*((_QWORD *)a2 - 6) != result)
    return tbb::internal::NFS_Free((tbb::task *)((char *)a2 - 64), v4);
  *((_QWORD *)a2 - 1) = *(_QWORD *)(result + 136);
  *(_QWORD *)(result + 136) = a2;
  return result;
}

unint64_t tbb::internal::allocate_child_proxy::allocate(tbb::internal::allocate_child_proxy *this, unint64_t a2)
{
  unint64_t v4;
  tbb::internal::generic_scheduler *inited;

  v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4)
    inited = (tbb::internal::generic_scheduler *)(v4 & 0xFFFFFFFFFFFFFFFELL);
  else
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  return tbb::internal::generic_scheduler::allocate_task(inited, a2, this, *((tbb::task_group_context **)this - 7));
}

unint64_t tbb::internal::allocate_child_proxy::free(tbb::internal::allocate_child_proxy *this, tbb::task *a2)
{
  unint64_t v3;
  void *v4;
  unint64_t result;

  v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3)
    result = v3 & 0xFFFFFFFFFFFFFFFELL;
  else
    result = tbb::internal::governor::init_scheduler_weak(0);
  *((_BYTE *)a2 - 12) = 4;
  if (*((_QWORD *)a2 - 6) != result)
    return tbb::internal::NFS_Free((tbb::task *)((char *)a2 - 64), v4);
  *((_QWORD *)a2 - 1) = *(_QWORD *)(result + 136);
  *(_QWORD *)(result + 136) = a2;
  return result;
}

unint64_t tbb::internal::allocate_additional_child_of_proxy::allocate(tbb::internal::allocate_additional_child_of_proxy *this, unint64_t a2)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  tbb::internal::generic_scheduler *inited;

  v4 = (unint64_t *)(*((_QWORD *)this + 1) - 24);
  do
    v5 = __ldaxr(v4);
  while (__stlxr(v5 + 1, v4));
  v6 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v6)
    inited = (tbb::internal::generic_scheduler *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  else
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  return tbb::internal::generic_scheduler::allocate_task(inited, a2, *((tbb::task **)this + 1), *(tbb::task_group_context **)(*((_QWORD *)this + 1) - 56));
}

unint64_t tbb::internal::allocate_additional_child_of_proxy::free(tbb::internal::allocate_additional_child_of_proxy *this, tbb::task *a2)
{
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  void *v6;
  unint64_t result;

  v3 = (unint64_t *)(*((_QWORD *)this + 1) - 24);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 - 1, v3));
  v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v5)
    result = v5 & 0xFFFFFFFFFFFFFFFELL;
  else
    result = tbb::internal::governor::init_scheduler_weak(0);
  *((_BYTE *)a2 - 12) = 4;
  if (*((_QWORD *)a2 - 6) != result)
    return tbb::internal::NFS_Free((tbb::task *)((char *)a2 - 64), v6);
  *((_QWORD *)a2 - 1) = *(_QWORD *)(result + 136);
  *(_QWORD *)(result + 136) = a2;
  return result;
}

unint64_t tbb::task::internal_decrement_ref_count(tbb::task *this)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t result;

  v1 = (unint64_t *)((char *)this - 24);
  do
  {
    v2 = __ldaxr(v1);
    result = v2 - 1;
  }
  while (__stlxr(v2 - 1, v1));
  return result;
}

uint64_t tbb::internal::get_initial_auto_partitioner_divisor(tbb::internal *this)
{
  unint64_t v1;
  unint64_t inited;

  v1 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v1 & 1) != 0)
    inited = v1 & 0xFFFFFFFFFFFFFFFELL;
  else
    inited = tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  return 4 * *(unsigned int *)(*(_QWORD *)(inited + 48) + 328);
}

void tbb::internal::affinity_partitioner_base_v3::resize(tbb::internal **this, void *a2, uint64_t a3, void *a4)
{
  int v5;
  unint64_t v6;
  unint64_t inited;
  unint64_t v8;
  tbb::internal *v9;

  if ((_DWORD)a2)
  {
    v5 = (int)a2;
    v6 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
    if ((v6 & 1) != 0)
      inited = v6 & 0xFFFFFFFFFFFFFFFELL;
    else
      inited = tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
    v8 = (*(_DWORD *)(*(_QWORD *)(inited + 48) + 328) * v5);
  }
  else
  {
    v8 = 0;
  }
  if ((tbb::internal *)v8 != this[1])
  {
    if (*this)
    {
      tbb::internal::NFS_Free(*this, a2);
      *this = 0;
      this[1] = 0;
    }
    if (v8)
    {
      v9 = (tbb::internal *)tbb::internal::NFS_Allocate(v8, 2, 0, a4);
      *this = v9;
      bzero(v9, 2 * v8);
      this[1] = (tbb::internal *)v8;
    }
  }
}

uint64_t tbb::task::internal_set_ref_count(uint64_t this, int a2)
{
  *(_QWORD *)(this - 24) = a2;
  return this;
}

uint64_t tbb::task::self(tbb::task *this)
{
  unint64_t v1;
  unint64_t inited;

  v1 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v1)
    inited = v1 & 0xFFFFFFFFFFFFFFFELL;
  else
    inited = tbb::internal::governor::init_scheduler_weak(0);
  return *(_QWORD *)(inited + 56);
}

uint64_t tbb::task::is_owned_by_current_thread(tbb::task *this)
{
  return 1;
}

tbb::internal::generic_scheduler *tbb::interface5::internal::task_base::destroy(tbb::interface5::internal::task_base *this, tbb::task *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  void *v7;
  tbb::internal::generic_scheduler *result;
  unint64_t v9;

  v3 = *((_QWORD *)this - 4);
  (**(void (***)(tbb::interface5::internal::task_base *, tbb::task *))this)(this, a2);
  if (v3)
  {
    v4 = (unint64_t *)(v3 - 24);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
  }
  v6 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v6)
    result = (tbb::internal::generic_scheduler *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  else
    result = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  *((_BYTE *)this - 12) = 4;
  v9 = *((_QWORD *)this - 6);
  if ((tbb::internal::generic_scheduler *)v9 == result)
  {
    *((_QWORD *)this - 1) = *((_QWORD *)result + 17);
    *((_QWORD *)result + 17) = this;
  }
  else if (!v9 || v9 >= 0x1000)
  {
    if (v9)
      return (tbb::internal::generic_scheduler *)tbb::internal::generic_scheduler::free_nonlocal_small_task(result, this);
    else
      return (tbb::internal::generic_scheduler *)tbb::internal::NFS_Free((tbb::interface5::internal::task_base *)((char *)this - 64), v7);
  }
  return result;
}

uint64_t tbb::task::spawn_and_wait_for_all(uint64_t a1, uint64_t *a2)
{
  unint64_t v4;
  void *v5;
  tbb::internal::generic_scheduler *inited;
  uint64_t v7;
  tbb::task **v8;

  v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v4 & 1) != 0)
  {
    inited = (tbb::internal::generic_scheduler *)(v4 & 0xFFFFFFFFFFFFFFFELL);
    v7 = *a2;
    if (!*a2)
      return (*(uint64_t (**)(tbb::internal::generic_scheduler *, uint64_t, uint64_t))(*(_QWORD *)inited + 48))(inited, a1, v7);
  }
  else
  {
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
    v7 = *a2;
    if (!*a2)
      return (*(uint64_t (**)(tbb::internal::generic_scheduler *, uint64_t, uint64_t))(*(_QWORD *)inited + 48))(inited, a1, v7);
  }
  v8 = (tbb::task **)a2[1];
  if ((tbb::task **)(v7 - 8) != v8)
    tbb::internal::generic_scheduler::local_spawn(inited, *(tbb::task **)(v7 - 8), v8, v5);
  *a2 = 0;
  a2[1] = (uint64_t)a2;
  return (*(uint64_t (**)(tbb::internal::generic_scheduler *, uint64_t, uint64_t))(*(_QWORD *)inited + 48))(inited, a1, v7);
}

void tbb::task::change_group(tbb::task *this, tbb::task_group_context *a2)
{
  unint64_t v3;
  uint64_t v4;
  void *v5;
  unint64_t inited;

  *((_QWORD *)this - 7) = a2;
  v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3)
    inited = v3 & 0xFFFFFFFFFFFFFFFELL;
  else
    inited = tbb::internal::governor::init_scheduler_weak(0);
  if (*(_DWORD *)a2 == 1)
  {
    if ((~*(unsigned __int8 *)(inited + 74) & 3) != 0)
    {
      tbb::task_group_context::bind_to((uint64_t)a2, (tbb::internal::generic_scheduler *)inited, v4, v5);
      if (*(_DWORD *)a2)
        return;
      goto LABEL_8;
    }
    *(_DWORD *)a2 = 0;
  }
  if (*(_DWORD *)a2)
    return;
LABEL_8:
  if ((*((_BYTE *)a2 + 130) & 2) == 0)
    tbb::task_group_context::copy_fp_settings(a2, *(const tbb::task_group_context **)(*(_QWORD *)(inited + 144) - 56), v4, v5);
}

void tbb::captured_exception::~captured_exception(tbb::captured_exception *this, void *a2)
{
  void *v3;

  *(_QWORD *)this = off_24C5161D0;
  tbb::internal::deallocate_via_handler_v3(*((_QWORD *)this + 2), a2);
  tbb::internal::deallocate_via_handler_v3(*((_QWORD *)this + 3), v3);
  *(_QWORD *)this = &unk_24C516248;
  std::exception::~exception((std::exception *)this);
}

{
  void *v3;

  *(_QWORD *)this = off_24C5161D0;
  tbb::internal::deallocate_via_handler_v3(*((_QWORD *)this + 2), a2);
  tbb::internal::deallocate_via_handler_v3(*((_QWORD *)this + 3), v3);
  *(_QWORD *)this = &unk_24C516248;
  std::exception::~exception((std::exception *)this);
}

{
  void *v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = off_24C5161D0;
  tbb::internal::deallocate_via_handler_v3(*((_QWORD *)this + 2), a2);
  tbb::internal::deallocate_via_handler_v3(*((_QWORD *)this + 3), v3);
  *(_QWORD *)this = &unk_24C516248;
  std::exception::~exception((std::exception *)this);
  tbb::internal::deallocate_via_handler_v3(v4, v5);
}

uint64_t tbb::captured_exception::clear(tbb::captured_exception *this, void *a2)
{
  void *v3;

  tbb::internal::deallocate_via_handler_v3(*((_QWORD *)this + 2), a2);
  return tbb::internal::deallocate_via_handler_v3(*((_QWORD *)this + 3), v3);
}

char *tbb::captured_exception::set(tbb::captured_exception *this, const char *__s, const char *a3)
{
  tbb::internal *v6;
  char *v7;
  tbb::internal *v8;
  char *v9;
  char *result;

  if (!__s)
  {
    *((_QWORD *)this + 2) = 0;
    if (a3)
      goto LABEL_3;
LABEL_5:
    result = 0;
    goto LABEL_6;
  }
  v6 = (tbb::internal *)(strlen(__s) + 1);
  v7 = (char *)tbb::internal::allocate_via_handler_v3(v6);
  *((_QWORD *)this + 2) = strncpy(v7, __s, (size_t)v6);
  if (!a3)
    goto LABEL_5;
LABEL_3:
  v8 = (tbb::internal *)(strlen(a3) + 1);
  v9 = (char *)tbb::internal::allocate_via_handler_v3(v8);
  result = strncpy(v9, a3, (size_t)v8);
LABEL_6:
  *((_QWORD *)this + 3) = result;
  return result;
}

__n128 tbb::captured_exception::move(__n128 *this)
{
  uint64_t v2;
  __n128 result;

  v2 = tbb::internal::allocate_via_handler_v3((tbb::internal *)0x20);
  if (v2)
  {
    *(_QWORD *)v2 = off_24C5161D0;
    *(_QWORD *)(v2 + 16) = 0;
    *(_QWORD *)(v2 + 24) = 0;
    result = this[1];
    *(__n128 *)(v2 + 16) = result;
    *(_BYTE *)(v2 + 8) = 1;
    this[1].n128_u64[0] = 0;
    this[1].n128_u64[1] = 0;
  }
  return result;
}

uint64_t tbb::captured_exception::destroy(uint64_t this, void *a2)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;

  if (*(_BYTE *)(this + 8))
  {
    v2 = this;
    *(_QWORD *)this = off_24C5161D0;
    tbb::internal::deallocate_via_handler_v3(*(_QWORD *)(this + 16), a2);
    tbb::internal::deallocate_via_handler_v3(*(_QWORD *)(v2 + 24), v3);
    *(_QWORD *)v2 = &unk_24C516248;
    std::exception::~exception((std::exception *)v2);
    return tbb::internal::deallocate_via_handler_v3(v4, v5);
  }
  return this;
}

tbb::captured_exception *tbb::captured_exception::allocate(tbb::captured_exception *this, const char *a2, const char *a3)
{
  tbb::captured_exception *v5;
  tbb::captured_exception *v6;

  v5 = (tbb::captured_exception *)tbb::internal::allocate_via_handler_v3((tbb::internal *)0x20);
  v6 = v5;
  if (v5)
  {
    *(_QWORD *)v5 = off_24C5161D0;
    *((_BYTE *)v5 + 8) = 0;
    tbb::captured_exception::set(v5, (const char *)this, a2);
    *((_BYTE *)v6 + 8) = 1;
  }
  return v6;
}

uint64_t tbb::captured_exception::name(tbb::captured_exception *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t tbb::captured_exception::what(tbb::captured_exception *this)
{
  return *((_QWORD *)this + 3);
}

std::exception_ptr *tbb::internal::tbb_exception_ptr::allocate(tbb::internal::tbb_exception_ptr *this)
{
  std::exception_ptr *v1;
  std::exception_ptr *v2;
  std::exception_ptr v4;

  std::current_exception();
  v1 = (std::exception_ptr *)tbb::internal::allocate_via_handler_v3((tbb::internal *)8);
  v2 = v1;
  if (v1)
    std::exception_ptr::exception_ptr(v1, &v4);
  std::exception_ptr::~exception_ptr(&v4);
  return v2;
}

void sub_20BDCBBC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

std::exception_ptr *tbb::internal::tbb_exception_ptr::allocate()
{
  std::exception_ptr *v0;
  std::exception_ptr *v1;
  std::exception_ptr v3;

  std::current_exception();
  v0 = (std::exception_ptr *)tbb::internal::allocate_via_handler_v3((tbb::internal *)8);
  v1 = v0;
  if (v0)
    std::exception_ptr::exception_ptr(v0, &v3);
  std::exception_ptr::~exception_ptr(&v3);
  return v1;
}

void sub_20BDCBC2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

uint64_t tbb::internal::tbb_exception_ptr::allocate(tbb::internal::tbb_exception_ptr *this, tbb::captured_exception *a2)
{
  uint64_t v3;

  v3 = tbb::internal::allocate_via_handler_v3((tbb::internal *)8);
  if (v3)
    sub_20BDCCB2C(v3, (uint64_t)this);
  (*(void (**)(tbb::internal::tbb_exception_ptr *))(*(_QWORD *)this + 32))(this);
  return 0;
}

uint64_t tbb::internal::tbb_exception_ptr::destroy(std::exception_ptr *this)
{
  uint64_t v1;
  void *v2;

  std::exception_ptr::~exception_ptr(this);
  return tbb::internal::deallocate_via_handler_v3(v1, v2);
}

void tbb::task_group_context::~task_group_context(tbb::task_group_context *this, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  tbb::internal *v31;
  std::exception_ptr *v32;
  uint64_t v33;
  void *v34;
  unsigned int *v35;
  int v36;
  unsigned int v37;

  if (*(_DWORD *)this == 2)
  {
    if (tbb::internal::governor::is_set(*((_QWORD *)this + 18)))
    {
      v3 = *((_QWORD *)this + 18);
      v4 = *(_QWORD *)(v3 + 320);
      *(_QWORD *)(v3 + 328) = 1;
      __dmb(0xBu);
      v5 = *((_QWORD *)this + 18);
      if (*(_QWORD *)(v5 + 368))
      {
        v6 = v5 + 312;
        v7 = (unsigned int *)((v5 + 312) & 0xFFFFFFFFFFFFFFFCLL);
        v8 = 1 << (8 * ((v5 + 56) & 3));
        v9 = ~(255 << (8 * ((v5 + 56) & 3)));
LABEL_5:
        v10 = *v7 & v9;
        do
        {
          while (1)
          {
            v11 = __ldaxr(v7);
            if (v11 == v10)
              break;
            __clrex();
            if (*v7 != v10)
            {
              sched_yield();
              goto LABEL_5;
            }
          }
        }
        while (__stlxr(v10 | v8, v7));
        v15 = *((_QWORD *)this + 2);
        *(_QWORD *)(v15 + 8) = *((_QWORD *)this + 3);
        **((_QWORD **)this + 3) = v15;
        *(_QWORD *)(*((_QWORD *)this + 18) + 328) = 0;
LABEL_19:
        __dmb(0xBu);
        *(_BYTE *)v6 = 0;
      }
      else
      {
        v30 = *((_QWORD *)this + 2);
        *(_QWORD *)(v30 + 8) = *((_QWORD *)this + 3);
        **((_QWORD **)this + 3) = v30;
        __dmb(0xBu);
        *(_QWORD *)(v5 + 328) = 0;
        if (v4 != tbb::internal::the_context_state_propagation_epoch)
        {
          v6 = *((_QWORD *)this + 18) + 312;
          v35 = (unsigned int *)(v6 & 0xFFFFFFFFFFFFFFFCLL);
          while (1)
          {
            v36 = *v35 & ~(255 << (8 * (v6 & 3)));
            do
            {
              while (1)
              {
                v37 = __ldaxr(v35);
                if (v37 != v36)
                  break;
                if (!__stlxr(v36 | (1 << (8 * (v6 & 3))), v35))
                  goto LABEL_19;
              }
              __clrex();
            }
            while (*v35 == v36);
            sched_yield();
          }
        }
      }
    }
    else
    {
LABEL_11:
      v12 = *(_DWORD *)this;
      do
      {
        while (1)
        {
          v13 = __ldaxr((unsigned int *)this);
          if (v13 == v12)
            break;
          __clrex();
          if (*(_DWORD *)this != v12)
          {
            sched_yield();
            goto LABEL_11;
          }
        }
      }
      while (__stlxr(4u, (unsigned int *)this));
      if (v12 == 3)
      {
        v14 = *((_QWORD *)this + 2);
        *(_QWORD *)(v14 + 8) = *((_QWORD *)this + 3);
        **((_QWORD **)this + 3) = v14;
      }
      else
      {
        v16 = (unint64_t *)(*((_QWORD *)this + 18) + 368);
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 + 1, v16));
        v18 = *((_QWORD *)this + 18);
        while (1)
        {
          v19 = *(_QWORD *)(v18 + 328);
          __dmb(0xBu);
          if (!v19)
            break;
          sched_yield();
        }
        v20 = *((_QWORD *)this + 18) + 312;
        v21 = (unsigned int *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
        LOBYTE(v20) = 8 * (v20 & 3);
        v22 = 1 << v20;
        v23 = ~(255 << v20);
LABEL_26:
        v24 = *v21 & v23;
        do
        {
          while (1)
          {
            v25 = __ldaxr(v21);
            if (v25 == v24)
              break;
            __clrex();
            if (*v21 != v24)
            {
              sched_yield();
              goto LABEL_26;
            }
          }
        }
        while (__stlxr(v24 | v22, v21));
        v26 = *((_QWORD *)this + 2);
        *(_QWORD *)(v26 + 8) = *((_QWORD *)this + 3);
        **((_QWORD **)this + 3) = v26;
        v27 = *((_QWORD *)this + 18);
        __dmb(0xBu);
        *(_BYTE *)(v27 + 312) = 0;
        v28 = (unint64_t *)(*((_QWORD *)this + 18) + 368);
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
      }
    }
  }
  v31 = (tbb::internal *)*((_QWORD *)this + 14);
  if (v31)
    tbb::internal::NFS_Free(v31, a2);
  v32 = (std::exception_ptr *)*((_QWORD *)this + 17);
  if (v32)
  {
    std::exception_ptr::~exception_ptr(v32);
    tbb::internal::deallocate_via_handler_v3(v33, v34);
  }
}

uint64_t tbb::task_group_context::init(uint64_t this, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4;
  fenv_t *v5;

  *(_OWORD *)(this + 8) = 0u;
  *(_OWORD *)(this + 24) = 0u;
  *(_QWORD *)(this + 136) = 0;
  *(_QWORD *)(this + 144) = 0;
  *(_QWORD *)(this + 152) = 0;
  *(_QWORD *)(this + 160) = 1;
  *(_QWORD *)(this + 112) = 0;
  *(_QWORD *)(this + 120) = 0;
  if ((*(_BYTE *)(this + 130) & 2) != 0)
  {
    v4 = this;
    v5 = (fenv_t *)tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
    *(_QWORD *)(v4 + 112) = v5;
    return fegetenv(v5);
  }
  return this;
}

_QWORD *tbb::task_group_context::register_with(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  unsigned int *v6;
  int v7;
  unsigned int v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;

  v3 = result;
  result[2] = a2 + 37;
  v4 = result + 2;
  result[18] = a2;
  a2[41] = 1;
  __dmb(0xBu);
  if (a2[46])
  {
    v5 = result[18] + 312;
    v6 = (unsigned int *)(v5 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_3:
    v7 = *v6 & ~(255 << (8 * (v5 & 3)));
    do
    {
      while (1)
      {
        v8 = __ldaxr(v6);
        if (v8 == v7)
          break;
        __clrex();
        if (*v6 != v7)
        {
          result = (_QWORD *)sched_yield();
          goto LABEL_3;
        }
      }
    }
    while (__stlxr(v7 | (1 << (8 * (v5 & 3))), v6));
    v9 = (_QWORD *)a2[38];
    *v9 = v4;
    v3[3] = v9;
    *(_QWORD *)(v3[18] + 328) = 0;
    a2[38] = v4;
    __dmb(0xBu);
    *(_BYTE *)v5 = 0;
  }
  else
  {
    v10 = (_QWORD *)a2[38];
    *v10 = v4;
    result[3] = v10;
    v11 = result[18];
    __dmb(0xBu);
    *(_QWORD *)(v11 + 328) = 0;
    __dmb(0xBu);
    a2[38] = v4;
  }
  return result;
}

uint64_t tbb::task_group_context::bind_to(uint64_t this, tbb::internal::generic_scheduler *a2, uint64_t a3, void *a4)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  int v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  char v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;

  v5 = this;
  v6 = *(_QWORD **)(*((_QWORD *)a2 + 7) - 56);
  *(_QWORD *)(this + 8) = v6;
  if ((*(_BYTE *)(this + 130) & 2) != 0)
  {
    v7 = v6[19];
    if ((v7 & 1) != 0)
      goto LABEL_3;
LABEL_13:
    v6[19] = v7 | 1;
    if (v6[1])
      goto LABEL_4;
    goto LABEL_14;
  }
  *(_QWORD *)(this + 112) = 0;
  this = tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
  *(_QWORD *)(v5 + 112) = this;
  *(_OWORD *)this = *(_OWORD *)v6[14];
  *(_QWORD *)(v5 + 128) |= 0x20000uLL;
  v6 = *(_QWORD **)(v5 + 8);
  v7 = v6[19];
  if ((v7 & 1) == 0)
    goto LABEL_13;
LABEL_3:
  if (v6[1])
  {
LABEL_4:
    v8 = *(_QWORD *)(v6[18] + 320);
    __dmb(0xBu);
    *(_QWORD *)(v5 + 16) = (char *)a2 + 296;
    v9 = v5 + 16;
    v10 = *(_QWORD *)(v5 + 8);
    *(_QWORD *)(v5 + 120) = *(_QWORD *)(v10 + 120);
    *(_QWORD *)(v5 + 160) = *(_QWORD *)(v10 + 160);
    *(_QWORD *)(v5 + 144) = a2;
    *((_QWORD *)a2 + 41) = 1;
    __dmb(0xBu);
    if (*((_QWORD *)a2 + 46))
    {
      v11 = *(_QWORD *)(v5 + 144) + 312;
      v12 = (unsigned int *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_6:
      v13 = *v12 & ~(255 << (8 * (v11 & 3)));
      do
      {
        while (1)
        {
          v14 = __ldaxr(v12);
          if (v14 == v13)
            break;
          __clrex();
          if (*v12 != v13)
          {
            this = sched_yield();
            goto LABEL_6;
          }
        }
      }
      while (__stlxr(v13 | (1 << (8 * (v11 & 3))), v12));
      v20 = (uint64_t *)*((_QWORD *)a2 + 38);
      *v20 = v9;
      *(_QWORD *)(v5 + 24) = v20;
      *(_QWORD *)(*(_QWORD *)(v5 + 144) + 328) = 0;
      *((_QWORD *)a2 + 38) = v9;
      __dmb(0xBu);
      *(_BYTE *)v11 = 0;
    }
    else
    {
      v21 = (uint64_t *)*((_QWORD *)a2 + 38);
      *v21 = v9;
      *(_QWORD *)(v5 + 24) = v21;
      v22 = *(_QWORD *)(v5 + 144);
      __dmb(0xBu);
      *(_QWORD *)(v22 + 328) = 0;
      __dmb(0xBu);
      *((_QWORD *)a2 + 38) = v9;
    }
    if (v8 != tbb::internal::the_context_state_propagation_epoch)
    {
LABEL_24:
      v23 = 8 * (&tbb::internal::the_context_state_propagation_mutex & 3);
      v24 = *(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v23);
      v25 = v24 | (1 << v23);
      do
      {
        while (1)
        {
          v26 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL));
          if (v26 == v24)
            break;
          __clrex();
          if (*(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) != v24)
          {
            this = sched_yield();
            goto LABEL_24;
          }
        }
      }
      while (__stlxr(v25, (unsigned int *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL)));
      v27 = *(_QWORD *)(v5 + 8);
      *(_QWORD *)(v5 + 120) = *(_QWORD *)(v27 + 120);
      *(_QWORD *)(v5 + 160) = *(_QWORD *)(v27 + 160);
      __dmb(0xBu);
      LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
    }
    goto LABEL_32;
  }
LABEL_14:
  *(_QWORD *)(v5 + 16) = (char *)a2 + 296;
  v15 = v5 + 16;
  *(_QWORD *)(v5 + 144) = a2;
  *((_QWORD *)a2 + 41) = 1;
  __dmb(0xBu);
  if (*((_QWORD *)a2 + 46))
  {
    v16 = *(_QWORD *)(v5 + 144) + 312;
    v17 = (unsigned int *)(v16 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_16:
    v18 = *v17 & ~(255 << (8 * (v16 & 3)));
    do
    {
      while (1)
      {
        v19 = __ldaxr(v17);
        if (v19 == v18)
          break;
        __clrex();
        if (*v17 != v18)
        {
          this = sched_yield();
          goto LABEL_16;
        }
      }
    }
    while (__stlxr(v18 | (1 << (8 * (v16 & 3))), v17));
    v28 = (uint64_t *)*((_QWORD *)a2 + 38);
    *v28 = v15;
    *(_QWORD *)(v5 + 24) = v28;
    *(_QWORD *)(*(_QWORD *)(v5 + 144) + 328) = 0;
    *((_QWORD *)a2 + 38) = v15;
    __dmb(0xBu);
    *(_BYTE *)v16 = 0;
  }
  else
  {
    v29 = (uint64_t *)*((_QWORD *)a2 + 38);
    *v29 = v15;
    *(_QWORD *)(v5 + 24) = v29;
    v30 = *(_QWORD *)(v5 + 144);
    __dmb(0xBu);
    *(_QWORD *)(v30 + 328) = 0;
    __dmb(0xBu);
    *((_QWORD *)a2 + 38) = v15;
  }
  v31 = *(_QWORD *)(v5 + 8);
  *(_QWORD *)(v5 + 120) = *(_QWORD *)(v31 + 120);
  *(_QWORD *)(v5 + 160) = *(_QWORD *)(v31 + 160);
LABEL_32:
  *(_DWORD *)v5 = 2;
  return this;
}

__n128 tbb::task_group_context::copy_fp_settings(tbb::task_group_context *this, const tbb::task_group_context *a2, uint64_t a3, void *a4)
{
  __n128 *v6;
  __n128 result;

  *((_QWORD *)this + 14) = 0;
  v6 = (__n128 *)tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
  *((_QWORD *)this + 14) = v6;
  result = *(__n128 *)*((_QWORD *)a2 + 14);
  *v6 = result;
  *((_QWORD *)this + 16) |= 0x20000uLL;
  return result;
}

uint64_t tbb::task_group_context::cancel_group_execution(tbb::task_group_context *this)
{
  unint64_t *v1;
  unint64_t v4;
  uint64_t v5;
  unint64_t v7;
  unint64_t inited;

  v1 = (unint64_t *)((char *)this + 120);
  if (*((_QWORD *)this + 15))
    return 0;
  do
  {
    while (__ldaxr(v1))
    {
      __clrex();
      do
        v4 = __ldxr(v1);
      while (__stxr(v4, v1));
      if (v4)
        return 0;
    }
  }
  while (__stlxr(1uLL, v1));
  v7 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v7)
    inited = v7 & 0xFFFFFFFFFFFFFFFELL;
  else
    inited = tbb::internal::governor::init_scheduler_weak(0);
  v5 = 1;
  sub_20BDCC4E0(*(_QWORD *)(inited + 120), 120, (uint64_t)this, 1);
  return v5;
}

uint64_t sub_20BDCC4E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  char v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  _BOOL4 v35;
  uint64_t v36;
  uint64_t i;

  v4 = 1;
  if ((*(_BYTE *)(a3 + 152) & 1) != 0)
  {
LABEL_2:
    v8 = 8 * (&tbb::internal::the_context_state_propagation_mutex & 3);
    v9 = *(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v8);
    v10 = v9 | (1 << v8);
    do
    {
      while (1)
      {
        v11 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL));
        if (v11 == v9)
          break;
        __clrex();
        if (*(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) != v9)
        {
          sched_yield();
          goto LABEL_2;
        }
      }
    }
    while (__stlxr(v10, (unsigned int *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL)));
    v35 = *(_QWORD *)(a3 + a2) == a4;
    if (*(_QWORD *)(a3 + a2) == a4)
    {
      do
        v12 = __ldaxr((unint64_t *)&tbb::internal::the_context_state_propagation_epoch);
      while (__stlxr(v12 + 1, (unint64_t *)&tbb::internal::the_context_state_propagation_epoch));
      v13 = *(unsigned int *)(a1 + 36);
      __dmb(0xBu);
      v36 = v13;
      if ((_DWORD)v13)
      {
        v14 = 0;
        do
        {
          v16 = *(_QWORD *)(a1 + 8 * v14 + 248);
          if (v16)
          {
            v17 = (unsigned int *)((v16 + 312) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_16:
            v18 = *v17 & ~(255 << (8 * ((v16 + 56) & 3)));
            do
            {
              while (1)
              {
                v19 = __ldaxr(v17);
                if (v19 == v18)
                  break;
                __clrex();
                if (*v17 != v18)
                {
                  sched_yield();
                  goto LABEL_16;
                }
              }
            }
            while (__stlxr(v18 | (1 << (8 * ((v16 + 56) & 3))), v17));
            v20 = *(_QWORD *)(v16 + 304);
            __dmb(0xBu);
            while (v20 != v16 + 296)
            {
              v21 = v20 - 16;
              if (v20 - 16 != a3 && *(_QWORD *)(v20 - 16 + a2) != a4)
              {
                v23 = v20 - 16;
                while (1)
                {
                  v23 = *(_QWORD *)(v23 + 8);
                  if (!v23)
                    break;
                  if (v23 == a3)
                  {
                    do
                    {
                      *(_QWORD *)(v21 + a2) = a4;
                      v21 = *(_QWORD *)(v21 + 8);
                    }
                    while (v21 != a3);
                    break;
                  }
                }
              }
              v20 = *(_QWORD *)(v20 + 8);
            }
            v15 = tbb::internal::the_context_state_propagation_epoch;
            __dmb(0xBu);
            *(_QWORD *)(v16 + 320) = v15;
            __dmb(0xBu);
            *(_BYTE *)(v16 + 312) = 0;
          }
          ++v14;
        }
        while (v14 != v36);
      }
      v24 = *(_QWORD *)(a1 + 232);
      for (i = a1 + 224; v24 != i; v24 = *(_QWORD *)(v24 + 8))
      {
        if (v24)
          v27 = v24 - 16;
        else
          v27 = 0;
        v28 = (unsigned int *)((v27 + 312) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_41:
        v29 = *v28 & ~(255 << (8 * ((v27 + 56) & 3)));
        do
        {
          while (1)
          {
            v30 = __ldaxr(v28);
            if (v30 == v29)
              break;
            __clrex();
            if (*v28 != v29)
            {
              sched_yield();
              goto LABEL_41;
            }
          }
        }
        while (__stlxr(v29 | (1 << (8 * ((v27 + 56) & 3))), v28));
        v31 = *(_QWORD *)(v27 + 304);
        __dmb(0xBu);
        while (v31 != v27 + 296)
        {
          v32 = v31 - 16;
          if (v31 - 16 != a3 && *(_QWORD *)(v31 - 16 + a2) != a4)
          {
            v34 = v31 - 16;
            while (1)
            {
              v34 = *(_QWORD *)(v34 + 8);
              if (!v34)
                break;
              if (v34 == a3)
              {
                do
                {
                  *(_QWORD *)(v32 + a2) = a4;
                  v32 = *(_QWORD *)(v32 + 8);
                }
                while (v32 != a3);
                break;
              }
            }
          }
          v31 = *(_QWORD *)(v31 + 8);
        }
        v26 = tbb::internal::the_context_state_propagation_epoch;
        __dmb(0xBu);
        *(_QWORD *)(v27 + 320) = v26;
        __dmb(0xBu);
        *(_BYTE *)(v27 + 312) = 0;
      }
    }
    __dmb(0xBu);
    LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
    return v35;
  }
  return v4;
}

void sub_20BDCC7E8(_Unwind_Exception *a1)
{
  _BYTE *v1;

  __dmb(0xBu);
  *v1 = 0;
  _Unwind_Resume(a1);
}

BOOL tbb::task_group_context::is_group_execution_cancelled(tbb::task_group_context *this)
{
  return *((_QWORD *)this + 15) != 0;
}

std::exception_ptr *tbb::task_group_context::reset(tbb::task_group_context *this)
{
  std::exception_ptr *result;
  uint64_t v3;
  void *v4;

  result = (std::exception_ptr *)*((_QWORD *)this + 17);
  if (result)
  {
    std::exception_ptr::~exception_ptr(result);
    result = (std::exception_ptr *)tbb::internal::deallocate_via_handler_v3(v3, v4);
    *((_QWORD *)this + 17) = 0;
  }
  *((_QWORD *)this + 15) = 0;
  return result;
}

uint64_t tbb::task_group_context::capture_fp_settings(tbb::task_group_context *this, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5;
  fenv_t *v6;

  v5 = *((_QWORD *)this + 16);
  if ((v5 & 0x20000) == 0)
  {
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 16) = v5 | 0x20000;
LABEL_4:
    v6 = (fenv_t *)tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
    *((_QWORD *)this + 14) = v6;
    return fegetenv(v6);
  }
  v6 = (fenv_t *)*((_QWORD *)this + 14);
  if (!v6)
    goto LABEL_4;
  return fegetenv(v6);
}

uint64_t tbb::task_group_context::register_pending_exception(uint64_t this)
{
  if (!*(_QWORD *)(this + 120))
    __cxa_rethrow();
  return this;
}

uint64_t tbb::task_group_context::set_priority(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;

  v2 = result;
  v3 = (a2 - 0x1FFFFFFF) / 0x1FFFFFFF;
  if (*(_QWORD *)(result + 160) != v3 || (*(_BYTE *)(result + 152) & 1) != 0)
  {
    *(_QWORD *)(result + 160) = v3;
    result = (uint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
    v4 = (uint64_t *)(result & 0xFFFFFFFFFFFFFFFELL);
    if ((result & 0xFFFFFFFFFFFFFFFELL) != 0)
    {
      if (v4[6])
      {
        result = sub_20BDCC4E0(v4[15], 160, v2, v3);
        if ((_DWORD)result)
        {
          if (!*(_BYTE *)(v4[7] - 12))
            return tbb::internal::market::update_arena_priority(v4[15], v4[6], v3);
        }
      }
    }
  }
  return result;
}

uint64_t tbb::task_group_context::priority(tbb::task_group_context *this)
{
  return dword_20CA4E23C[*((_QWORD *)this + 20)];
}

void sub_20BDCCAA0(uint64_t a1)
{
  tbb::captured_exception *exception;

  exception = (tbb::captured_exception *)__cxa_allocate_exception(0x20uLL);
  sub_20BDCCAF0(exception, a1);
}

void sub_20BDCCADC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

tbb::captured_exception *sub_20BDCCAF0(tbb::captured_exception *a1, uint64_t a2)
{
  *(_QWORD *)a1 = off_24C5161D0;
  *((_BYTE *)a1 + 8) = 0;
  tbb::captured_exception::set(a1, *(const char **)(a2 + 16), *(const char **)(a2 + 24));
  return a1;
}

void sub_20BDCCB2C(uint64_t a1, uint64_t a2)
{
  void (**v2)(tbb::captured_exception *__hidden);
  char v3;

  v2 = off_24C5161D0;
  v3 = 0;
  tbb::captured_exception::set((tbb::captured_exception *)&v2, *(const char **)(a2 + 16), *(const char **)(a2 + 24));
  sub_20BDCCBB0((uint64_t)&v2);
}

uint64_t sub_20BDCCB6C(int a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, tbb::internal *a11, tbb::internal *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16;
  void *v17;
  std::exception v19[8];

  tbb::internal::deallocate_via_handler_v3((uint64_t)v19[2].__vftable, a2);
  tbb::internal::deallocate_via_handler_v3((uint64_t)v19[3].__vftable, v17);
  v19[0].__vftable = (std::exception_vtbl *)&unk_24C516248;
  std::exception::~exception(v19);
  return v16;
}

void sub_20BDCCBB0(uint64_t a1)
{
  tbb::captured_exception *exception;

  exception = (tbb::captured_exception *)__cxa_allocate_exception(0x20uLL);
  *(_QWORD *)exception = off_24C5161D0;
  *((_BYTE *)exception + 8) = 0;
  tbb::captured_exception::set(exception, *(const char **)(a1 + 16), *(const char **)(a1 + 24));
}

void sub_20BDCCC08(void *a1)
{
  __cxa_begin_catch(a1);
  std::current_exception();
  __cxa_end_catch();
}

uint64_t tbb::internal::initialize_cilk_interop(tbb::internal *this)
{
  return tbb::internal::dynamic_link((uint64_t)"libcilkrts.so", (uint64_t)&off_24C516280, 1, 0);
}

tbb::internal *tbb::internal::governor::acquire_resources(tbb::internal::governor *this)
{
  tbb::internal *v1;
  tbb::internal *v2;
  NSObject *v3;
  tbb::internal *has_speculation;

  v1 = (tbb::internal *)pthread_key_create((pthread_key_t *)&tbb::internal::governor::theTLS, (void (__cdecl *)(void *))tbb::internal::governor::auto_terminate);
  v2 = v1;
  if ((_DWORD)v1)
  {
    if (qword_254784DB8 != -1)
      dispatch_once(&qword_254784DB8, &unk_24C5162B0);
    v3 = qword_254784DB0;
    v1 = (tbb::internal *)os_log_type_enabled((os_log_t)qword_254784DB0, OS_LOG_TYPE_ERROR);
    if ((_DWORD)v1)
      sub_20C96AF04((int)v2, v3);
  }
  has_speculation = (tbb::internal *)tbb::internal::cpu_has_speculation(v1);
  tbb::internal::governor::is_speculation_enabled = (char)has_speculation;
  tbb::internal::governor::is_rethrow_broken = tbb::internal::gcc_rethrow_exception_broken(has_speculation);
  return v2;
}

uint64_t tbb::internal::governor::auto_terminate(uint64_t this, void *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  _BOOL8 v6;

  v2 = this & 0xFFFFFFFFFFFFFFFELL;
  if ((this & 0xFFFFFFFFFFFFFFFELL) != 0)
  {
    if (*(_BYTE *)(v2 + 160))
    {
      v3 = *(_QWORD *)(v2 + 152) - 1;
      *(_QWORD *)(v2 + 152) = v3;
      if (!v3)
      {
        v4 = this;
        v5 = pthread_getspecific(tbb::internal::governor::theTLS);
        if (*(_QWORD *)(v2 + 48))
        {
          if ((void *)(v4 | 1) != v5)
          {
            v6 = 1;
LABEL_9:
            pthread_setspecific(tbb::internal::governor::theTLS, (const void *)(v6 | v2));
          }
        }
        else
        {
          v6 = (*(_BYTE *)(v2 + 74) & 1) == 0;
          if ((void *)(v2 | v6) != v5)
            goto LABEL_9;
        }
        return tbb::internal::generic_scheduler::cleanup_master(v2, 0);
      }
    }
  }
  return this;
}

uint64_t tbb::internal::governor::release_resources(tbb::internal::governor *this)
{
  tbb::internal *v1;
  char *v2;
  const char *v3;

  tbb::internal::rml::tbb_factory::close((unint64_t)&tbb::internal::governor::theRMLServerFactory);
  v1 = (tbb::internal *)pthread_key_delete(tbb::internal::governor::theTLS);
  if ((_DWORD)v1)
  {
    v2 = strerror((int)v1);
    v1 = (tbb::internal *)tbb::internal::runtime_warning((tbb::internal *)"failed to destroy task scheduler TLS: %s", v3, v2);
  }
  return tbb::internal::dynamic_unlink_all(v1);
}

uint64_t tbb::internal::governor::create_rml_server(uint64_t a1, const char *a2, uint64_t a3, void *a4)
{
  uint64_t server;

  if (!tbb::internal::governor::UsePrivateRML)
  {
    server = tbb::internal::rml::tbb_factory::make_server((uint64_t)&tbb::internal::governor::theRMLServerFactory);
    if ((_DWORD)server)
    {
      tbb::internal::governor::UsePrivateRML = 1;
      tbb::internal::runtime_warning((tbb::internal *)"rml::tbb_factory::make_server failed with status %x, falling back on private rml", a2, server);
    }
  }
  return tbb::internal::rml::make_private_server(a1, (uint64_t)a2, a3, a4);
}

unint64_t tbb::internal::governor::tls_value_of(unint64_t result)
{
  if (result)
  {
    if (*(_QWORD *)(result + 48))
      result |= 1uLL;
    else
      result |= (*(_BYTE *)(result + 74) & 1) == 0;
  }
  return result;
}

uint64_t tbb::internal::governor::assume_scheduler(uint64_t a1)
{
  _BOOL8 v1;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 48))
      v1 = 1;
    else
      v1 = (*(_BYTE *)(a1 + 74) & 1) == 0;
  }
  else
  {
    v1 = 0;
  }
  return pthread_setspecific(tbb::internal::governor::theTLS, (const void *)(v1 | a1));
}

BOOL tbb::internal::governor::is_set(uint64_t a1)
{
  void *v2;
  _BOOL8 v3;

  v2 = pthread_getspecific(tbb::internal::governor::theTLS);
  if (a1)
  {
    if (*(_QWORD *)(a1 + 48))
      v3 = 1;
    else
      v3 = (*(_BYTE *)(a1 + 74) & 1) == 0;
  }
  else
  {
    v3 = 0;
  }
  return (v3 | a1) == (_QWORD)v2;
}

uint64_t tbb::internal::governor::sign_on(uint64_t a1)
{
  _BOOL8 v2;
  uint64_t result;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 48))
      v2 = 1;
    else
      v2 = (*(_BYTE *)(a1 + 74) & 1) == 0;
  }
  else
  {
    v2 = 0;
  }
  result = pthread_setspecific(tbb::internal::governor::theTLS, (const void *)(v2 | a1));
  if (off_254784D80)
  {
    result = off_254784D80(a1 + 376, tbb::internal::governor::stack_op_handler, a1);
    if ((_DWORD)result)
      *(_QWORD *)(a1 + 376) = 0;
  }
  return result;
}

uint64_t tbb::internal::governor::stack_op_handler(int a1, uint64_t this)
{
  _BOOL8 v2;
  pthread_key_t v3;
  const void *v4;

  switch(a1)
  {
    case 0:
      v3 = tbb::internal::governor::theTLS;
      v4 = 0;
LABEL_12:
      pthread_setspecific(v3, v4);
      return 0;
    case 2:
      *(_QWORD *)(this + 376) = 0;
      tbb::internal::governor::auto_terminate(this, (void *)this);
      break;
    case 1:
      if (this)
      {
        if (*(_QWORD *)(this + 48))
          v2 = 1;
        else
          v2 = (*(_BYTE *)(this + 74) & 1) == 0;
      }
      else
      {
        v2 = 0;
      }
      v4 = (const void *)(v2 | this);
      v3 = tbb::internal::governor::theTLS;
      goto LABEL_12;
  }
  return 0;
}

uint64_t tbb::internal::governor::sign_off(uint64_t a1)
{
  uint64_t result;
  uint64_t (*v3)(_QWORD);

  result = pthread_setspecific(tbb::internal::governor::theTLS, 0);
  v3 = *(uint64_t (**)(_QWORD))(a1 + 376);
  if (v3)
    return v3(*(_QWORD *)(a1 + 384));
  return result;
}

uint64_t tbb::internal::governor::one_time_init(uint64_t this)
{
  int v1;
  int v2;
  int v3;
  int v5;
  int v6;
  int v7;

  v1 = tbb::internal::__TBB_InitOnce::InitializationDone;
  __dmb(0xBu);
  if (!v1)
    this = (uint64_t)tbb::internal::DoOneTimeInitializations((tbb::internal *)this);
  v2 = dword_254784D88;
  __dmb(0xBu);
  if (v2 != 2)
  {
    while (1)
    {
      v3 = dword_254784D88;
      __dmb(0xBu);
      if (!v3)
        break;
LABEL_11:
      while (1)
      {
        v5 = dword_254784D88;
        __dmb(0xBu);
        if (v5 != 1)
          break;
        this = sched_yield();
      }
      v6 = dword_254784D88;
      __dmb(0xBu);
      if (v6 == 2)
        return this;
    }
    do
    {
      while (__ldaxr((unsigned int *)&dword_254784D88))
      {
        __clrex();
        if (dword_254784D88)
          goto LABEL_11;
      }
    }
    while (__stlxr(1u, (unsigned int *)&dword_254784D88));
    this = tbb::internal::dynamic_link((uint64_t)"libcilkrts.so", (uint64_t)&off_24C516280, 1, 0);
    if ((_DWORD)this)
      v7 = 2;
    else
      v7 = 0;
    __dmb(0xBu);
    dword_254784D88 = v7;
  }
  return this;
}

uint64_t tbb::internal::governor::init_scheduler_weak(tbb::internal::governor *this)
{
  tbb::internal::arena *v1;
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  uint64_t result;

  tbb::internal::governor::one_time_init((uint64_t)this);
  result = tbb::internal::generic_scheduler::create_master(0, v1, v2, v3, v4);
  *(_BYTE *)(result + 160) = 1;
  return result;
}

uint64_t tbb::internal::governor::init_scheduler(tbb::internal::governor *this, uint64_t a2, char a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t master;
  uint64_t v11;
  tbb::internal::arena *arena;
  tbb::internal::arena *v13;
  tbb::internal::arena *v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  size_t v19;
  int v20;
  int v21[2];
  uint64_t v22;

  v5 = (unint64_t)this;
  v22 = *MEMORY[0x24BDAC8D0];
  tbb::internal::governor::one_time_init((uint64_t)this);
  v6 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v6)
  {
    v9 = v6;
    master = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((v6 & 1) == 0)
    {
      v11 = tbb::internal::governor::DefaultNumberOfThreads;
      if (!tbb::internal::governor::DefaultNumberOfThreads)
      {
        *(_QWORD *)v21 = 0x1900000006;
        v20 = 0;
        v19 = 4;
        sysctl(v21, 2u, &v20, &v19, 0, 0);
        if (v20 <= 1)
          v11 = 1;
        else
          v11 = v20;
        tbb::internal::governor::DefaultNumberOfThreads = v11;
      }
      arena = tbb::internal::market::create_arena((tbb::internal::market *)v11, 1, 0, v7, v8);
      tbb::internal::generic_scheduler::attach_arena(master, (uint64_t)arena, 0, 1);
      **(_QWORD **)(master + 40) = master;
      *(_QWORD *)(*(_QWORD *)(master + 48) + 320) = *(_QWORD *)(*(_QWORD *)(master + 144) - 56);
      pthread_setspecific(tbb::internal::governor::theTLS, (const void *)(v9 | 1));
    }
    if ((a3 & 1) == 0)
      ++*(_QWORD *)(master + 152);
  }
  else
  {
    if ((_DWORD)v5 == -1)
    {
      v5 = tbb::internal::governor::DefaultNumberOfThreads;
      if (!tbb::internal::governor::DefaultNumberOfThreads)
      {
        *(_QWORD *)v21 = 0x1900000006;
        v20 = 0;
        v19 = 4;
        sysctl(v21, 2u, &v20, &v19, 0, 0);
        if (v20 <= 1)
          v5 = 1;
        else
          v5 = v20;
        tbb::internal::governor::DefaultNumberOfThreads = v5;
      }
    }
    v13 = tbb::internal::market::create_arena((tbb::internal::market *)v5, 1, a2, v7, v8);
    master = tbb::internal::generic_scheduler::create_master(v13, v14, v15, v16, v17);
    *(_BYTE *)(master + 160) = a3;
  }
  return master;
}

uint64_t sub_20BDCD348()
{
  uint64_t result;
  size_t v1;
  int v2;
  int v3[2];
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  result = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(_QWORD *)v3 = 0x1900000006;
    v2 = 0;
    v1 = 4;
    sysctl(v3, 2u, &v2, &v1, 0, 0);
    if (v2 <= 1)
      result = 1;
    else
      result = v2;
    tbb::internal::governor::DefaultNumberOfThreads = result;
  }
  return result;
}

uint64_t tbb::internal::governor::terminate_scheduler(tbb::internal::governor *this, tbb::internal::generic_scheduler *a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 19) - 1;
  *((_QWORD *)this + 19) = v2;
  if (v2)
    return 0;
  else
    return tbb::internal::generic_scheduler::cleanup_master((uint64_t)this, (uint64_t)a2);
}

const char *tbb::internal::governor::print_version_info(tbb::internal::governor *this, uint64_t a2, const char *a3)
{
  const char *result;
  const char *v4;

  if (tbb::internal::governor::UsePrivateRML)
  {
    result = tbb::internal::PrintExtraVersionInfo("RML", "private", a3);
  }
  else
  {
    tbb::internal::PrintExtraVersionInfo("RML", "shared", a3);
    result = (const char *)tbb::internal::rml::tbb_factory::call_with_server_info((tbb::internal::rml::tbb_factory *)&tbb::internal::governor::theRMLServerFactory, (void (*)(void *, const char *))tbb::internal::PrintRMLVersionInfo, "");
  }
  if (off_254784D80)
    return tbb::internal::PrintExtraVersionInfo("CILK", "libcilkrts.so", v4);
  return result;
}

uint64_t tbb::internal::governor::initialize_rml_factory(tbb::internal::governor *this)
{
  uint64_t result;

  result = tbb::internal::rml::tbb_factory::open((tbb::internal::rml::tbb_factory *)&tbb::internal::governor::theRMLServerFactory);
  tbb::internal::governor::UsePrivateRML = (_DWORD)result != 0;
  return result;
}

void tbb::internal::numa_topology::initialization_impl(tbb::internal::numa_topology *this)
{
  unsigned __int8 v1;

  tbb::internal::governor::one_time_init((uint64_t)this);
  v1 = atomic_load((unsigned __int8 *)&qword_254784D90);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_254784D90))
  {
    dword_254784D8C = sub_20BDCD348();
    __cxa_guard_release(&qword_254784D90);
  }
  byte_254784D98 = 1;
  qword_254784DA0 = (uint64_t)&dword_254784D8C;
}

void sub_20BDCD534(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784D90);
  _Unwind_Resume(a1);
}

void tbb::internal::numa_topology::initialize(uint64_t this)
{
  int v1;
  int v2;
  int v4;
  int v5;
  unsigned __int8 v6;
  int v7;
  size_t v8;
  int v9;
  int v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v1 = dword_254784DA8;
  __dmb(0xBu);
  if (v1 != 2)
  {
    while (1)
    {
      v2 = dword_254784DA8;
      __dmb(0xBu);
      if (!v2)
        break;
LABEL_9:
      while (1)
      {
        v4 = dword_254784DA8;
        __dmb(0xBu);
        if (v4 != 1)
          break;
        this = sched_yield();
      }
      v5 = dword_254784DA8;
      __dmb(0xBu);
      if (v5 == 2)
        return;
    }
    do
    {
      while (__ldaxr((unsigned int *)&dword_254784DA8))
      {
        __clrex();
        if (dword_254784DA8)
          goto LABEL_9;
      }
    }
    while (__stlxr(1u, (unsigned int *)&dword_254784DA8));
    tbb::internal::governor::one_time_init(this);
    v6 = atomic_load((unsigned __int8 *)&qword_254784D90);
    if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_254784D90))
    {
      v7 = tbb::internal::governor::DefaultNumberOfThreads;
      if (!tbb::internal::governor::DefaultNumberOfThreads)
      {
        *(_QWORD *)v10 = 0x1900000006;
        v9 = 0;
        v8 = 4;
        sysctl(v10, 2u, &v9, &v8, 0, 0);
        v7 = v9;
        if (v9 <= 1)
          v7 = 1;
        tbb::internal::governor::DefaultNumberOfThreads = v7;
      }
      dword_254784D8C = v7;
      __cxa_guard_release(&qword_254784D90);
    }
    byte_254784D98 = 1;
    qword_254784DA0 = (uint64_t)&dword_254784D8C;
    __dmb(0xBu);
    dword_254784DA8 = 2;
  }
}

void sub_20BDCD6D0(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784D90);
  _Unwind_Resume(a1);
}

uint64_t tbb::internal::numa_topology::nodes_count(tbb::internal::numa_topology *this)
{
  tbb::internal::numa_topology::initialize((uint64_t)this);
  return byte_254784D98;
}

void tbb::internal::numa_topology::fill(tbb::internal::numa_topology *this, int *a2)
{
  tbb::internal::numa_topology::initialize((uint64_t)this);
  if (byte_254784D98 == 1)
    *(_DWORD *)this = -1;
}

uint64_t tbb::internal::numa_topology::default_concurrency(tbb::internal::numa_topology *this)
{
  unsigned int v1;
  uint64_t result;
  size_t v3;
  int v4;
  int v5[2];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if ((this & 0x80000000) != 0)
  {
    result = tbb::internal::governor::DefaultNumberOfThreads;
    if (!tbb::internal::governor::DefaultNumberOfThreads)
    {
      *(_QWORD *)v5 = 0x1900000006;
      v4 = 0;
      v3 = 4;
      sysctl(v5, 2u, &v4, &v3, 0, 0);
      if (v4 <= 1)
        result = 1;
      else
        result = v4;
      tbb::internal::governor::DefaultNumberOfThreads = result;
    }
  }
  else
  {
    v1 = this;
    tbb::internal::numa_topology::initialize((uint64_t)this);
    return *(unsigned int *)(qword_254784DA0 + 4 * v1);
  }
  return result;
}

uint64_t tbb::internal::construct_binding_handler(tbb::internal *this)
{
  return 0;
}

uint64_t tbb::task_scheduler_init::initialize(uint64_t this, tbb::internal::governor *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  _QWORD *v6;

  if ((_DWORD)a2 != -2)
  {
    v6 = (_QWORD *)this;
    if (*(_QWORD *)this)
      tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x1FF, "!my_scheduler", "task_scheduler_init already initialized", a5);
    if ((_DWORD)a2 != -1 && (int)a2 <= 0)
      tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x201, "number_of_threads==automatic || number_of_threads > 0", "number_of_threads for task_scheduler_init must be automatic or positive", a5);
    this = tbb::internal::governor::init_scheduler(a2, 0, 0);
    if ((~*(unsigned __int8 *)(this + 74) & 3) == 0)
      this |= (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(this + 144) - 56) + 128) >> 16) & 1;
    *v6 = this;
  }
  return this;
}

{
  unint64_t v5;
  char v6;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;

  v5 = a3 & 0xFFFFFFFFFFFFFFFCLL;
  if ((_DWORD)a2 == -2)
  {
    if (v5)
      return (uint64_t)tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x212, "!thread_stack_size", "deferred initialization ignores stack size setting", a5);
  }
  else
  {
    v6 = a3;
    v8 = (_QWORD *)this;
    if (*(_QWORD *)this)
      tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x1FF, "!my_scheduler", "task_scheduler_init already initialized", a5);
    if ((_DWORD)a2 != -1 && (int)a2 <= 0)
      tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x201, "number_of_threads==automatic || number_of_threads > 0", "number_of_threads for task_scheduler_init must be automatic or positive", a5);
    this = tbb::internal::governor::init_scheduler(a2, v5, 0);
    if ((~*(unsigned __int8 *)(this + 74) & 3) == 0)
    {
      v9 = *(_QWORD *)(*(_QWORD *)(this + 144) - 56);
      v10 = *(_QWORD *)(v9 + 128);
      v11 = (v10 >> 16) & 1;
      v12 = v10 & 0xFFFFFFFFFFFEFFFFLL;
      if ((v6 & 2) == 0)
        v12 = *(_QWORD *)(v9 + 128);
      v13 = v10 | 0x10000;
      if ((v6 & 1) == 0)
        v13 = v12;
      *(_QWORD *)(v9 + 128) = v13;
      this |= v11;
    }
    *v8 = this;
  }
  return this;
}

uint64_t tbb::task_scheduler_init::internal_terminate(tbb::task_scheduler_init *this, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  v6 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
  if ((v6 & 0xFFFFFFFFFFFFFFFELL) == 0)
    tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x21D, "s", "task_scheduler_init::terminate without corresponding task_scheduler_init::initialize()", a5);
  if ((~*(unsigned __int8 *)(v7 + 74) & 3) == 0)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 144) - 56) + 128) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 144) - 56)
                                                                               + 128) & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)(v6 & 1) << 16);
  v8 = *(_QWORD *)(v7 + 152) - 1;
  *(_QWORD *)(v7 + 152) = v8;
  if (v8)
    return 0;
  else
    return tbb::internal::generic_scheduler::cleanup_master(v6 & 0xFFFFFFFFFFFFFFFELL, a2);
}

const char *tbb::task_scheduler_init::terminate(const char *this, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;

  v5 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  v6 = v5 & 0xFFFFFFFFFFFFFFFELL;
  if ((v5 & 0xFFFFFFFFFFFFFFFELL) == 0)
    this = tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x21D, "s", "task_scheduler_init::terminate without corresponding task_scheduler_init::initialize()", a5);
  if ((~*(unsigned __int8 *)(v6 + 74) & 3) == 0)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 144) - 56) + 128) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 144) - 56)
                                                                               + 128) & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)(v5 & 1) << 16);
  v7 = *(_QWORD *)(v6 + 152) - 1;
  *(_QWORD *)(v6 + 152) = v7;
  if (!v7)
    return (const char *)tbb::internal::generic_scheduler::cleanup_master(v5 & 0xFFFFFFFFFFFFFFFELL, 0);
  return this;
}

uint64_t tbb::task_scheduler_init::internal_blocking_terminate(tbb::task_scheduler_init *this, int a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
  if ((v6 & 0xFFFFFFFFFFFFFFFELL) == 0)
    tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x21D, "s", "task_scheduler_init::terminate without corresponding task_scheduler_init::initialize()", a5);
  if ((~*(unsigned __int8 *)(v7 + 74) & 3) == 0)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 144) - 56) + 128) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 144) - 56)
                                                                               + 128) & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)(v6 & 1) << 16);
  v8 = *(_QWORD *)(v7 + 152) - 1;
  *(_QWORD *)(v7 + 152) = v8;
  if (v8)
  {
    v9 = 0;
    if (!a2)
      return v9;
  }
  else
  {
    v9 = tbb::internal::generic_scheduler::cleanup_master(v6 & 0xFFFFFFFFFFFFFFFELL, 1);
    if (!a2)
      return v9;
  }
  if ((v9 & 1) == 0)
    tbb::internal::throw_exception_v4(19);
  return v9;
}

uint64_t tbb::task_scheduler_init::default_num_threads(tbb::task_scheduler_init *this)
{
  uint64_t result;
  size_t v2;
  int v3;
  int v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  result = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(_QWORD *)v4 = 0x1900000006;
    v3 = 0;
    v2 = 4;
    sysctl(v4, 2u, &v3, &v2, 0, 0);
    if (v3 <= 1)
      result = 1;
    else
      result = v3;
    tbb::internal::governor::DefaultNumberOfThreads = result;
  }
  return result;
}

os_log_t sub_20BDCDC64()
{
  os_log_t result;

  result = os_log_create("com.apple.usdlib", "tbbgovernor");
  qword_254784DB0 = (uint64_t)result;
  return result;
}

uint64_t tbb::internal::market::insert_arena_into_list(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result + 40 * a2[17];
  v3 = a2[17];
  v4 = *(_QWORD *)(v2 + 80);
  v5 = *(_QWORD *)(v2 + 88);
  *a2 = v2 + 72;
  a2[1] = v4;
  **(_QWORD **)(v2 + 80) = a2;
  *(_QWORD *)(v2 + 80) = a2;
  *(_QWORD *)(v2 + 88) = v5 + 1;
  if (!v5)
    *(_QWORD *)(result + 40 * v3 + 96) = a2;
  return result;
}

uint64_t tbb::internal::market::remove_arena_from_list(uint64_t result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;

  v2 = (_QWORD *)(result + 72 + 40 * a2[17]);
  if ((_QWORD *)v2[3] == a2)
  {
    v3 = a2[1];
    if ((_QWORD *)v3 == v2)
    {
      v3 = result + 72 + 40 * a2[17];
      if (v2[2] >= 2uLL)
        v3 = v2[1];
    }
    v2[3] = v3;
  }
  --v2[2];
  v4 = (_QWORD *)a2[1];
  *v4 = *a2;
  *(_QWORD *)(*a2 + 8) = v4;
  return result;
}

int64x2_t *tbb::internal::market::market(int64x2_t *this, const char *a2, uint64_t a3, void *a4)
{
  this->i64[0] = (uint64_t)off_24C5162E0;
  this->i64[1] = 0;
  this[1].i32[2] = a3;
  this[1].i32[3] = (int)a2;
  this[3] = vdupq_n_s64(1uLL);
  this[5].i64[0] = (uint64_t)&this[4].i64[1];
  this[5].i64[1] = 0;
  this[4].i64[1] = (uint64_t)&this[4].i64[1];
  this[7].i64[1] = (uint64_t)this[7].i64;
  this[8].i64[0] = 0;
  this[7].i64[0] = (uint64_t)this[7].i64;
  this[10].i64[0] = (uint64_t)&this[9].i64[1];
  this[10].i64[1] = 0;
  this[9].i64[1] = (uint64_t)&this[9].i64[1];
  this[12].i32[2] = 1;
  this[13].i64[0] = (uint64_t)a4;
  this[13].i32[3] = (int)a2;
  this[14].i64[1] = (uint64_t)this[14].i64;
  this[15].i64[0] = 0;
  this[14].i64[0] = (uint64_t)this[14].i64;
  this[9].i32[1] = (int)a2;
  this[1].i64[0] = tbb::internal::governor::create_rml_server((uint64_t)this, a2, a3, a4);
  return this;
}

{
  this->i64[0] = (uint64_t)off_24C5162E0;
  this->i64[1] = 0;
  this[1].i32[2] = a3;
  this[1].i32[3] = (int)a2;
  this[3] = vdupq_n_s64(1uLL);
  this[5].i64[0] = (uint64_t)&this[4].i64[1];
  this[5].i64[1] = 0;
  this[4].i64[1] = (uint64_t)&this[4].i64[1];
  this[7].i64[1] = (uint64_t)this[7].i64;
  this[8].i64[0] = 0;
  this[7].i64[0] = (uint64_t)this[7].i64;
  this[10].i64[0] = (uint64_t)&this[9].i64[1];
  this[10].i64[1] = 0;
  this[9].i64[1] = (uint64_t)&this[9].i64[1];
  this[12].i32[2] = 1;
  this[13].i64[0] = (uint64_t)a4;
  this[13].i32[3] = (int)a2;
  this[14].i64[1] = (uint64_t)this[14].i64;
  this[15].i64[0] = 0;
  this[14].i64[0] = (uint64_t)this[14].i64;
  this[9].i32[1] = (int)a2;
  this[1].i64[0] = tbb::internal::governor::create_rml_server((uint64_t)this, a2, a3, a4);
  return this;
}

int64x2_t *tbb::internal::market::global_market(uint64_t this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  unint64_t v5;
  int v7;
  char v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  int64x2_t *v12;
  __int32 v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  tbb::internal::market *v18;
  char v19;
  unsigned int v20;
  unsigned int v21;
  tbb::internal::__TBB_InitOnce *v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  const char *v28;
  uint64_t v29;
  void *v30;
  uint64_t rml_server;
  uint64_t v32;
  const char *v33;
  int v34;
  uint64_t v35;
  int v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int v39;
  size_t v41;
  int v42;
  int v43[2];
  uint64_t v44;

  v5 = a3;
  v7 = this;
  v44 = *MEMORY[0x24BDAC8D0];
LABEL_2:
  v8 = 8 * (&tbb::internal::market::theMarketMutex & 3);
  v9 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v8);
  v10 = v9 | (1 << v8);
  do
  {
    while (1)
    {
      v11 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL));
      if (v11 == v9)
        break;
      __clrex();
      if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v9)
      {
        this = sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v10, (unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL)));
  v12 = (int64x2_t *)tbb::internal::market::theMarket;
  if (tbb::internal::market::theMarket)
  {
    ++*(_DWORD *)(tbb::internal::market::theMarket + 200);
    if ((v7 & 1) != 0)
    {
      v13 = v12[12].i32[3];
      v12[12].i32[3] = v13 + 1;
      __dmb(0xBu);
      LOBYTE(tbb::internal::market::theMarketMutex) = 0;
      if (!v13)
      {
        v14 = v12[1].u32[2];
        v15 = tbb::internal::market::app_parallelism_limit((tbb::internal::market *)this);
        if (v15)
        {
          v16 = v15 - 1;
        }
        else
        {
          v34 = tbb::internal::governor::DefaultNumberOfThreads;
          if (!tbb::internal::governor::DefaultNumberOfThreads)
          {
            *(_QWORD *)v43 = 0x1900000006;
            v42 = 0;
            v41 = 4;
            sysctl(v43, 2u, &v42, &v41, 0, 0);
            v34 = v42;
            if (v42 <= 1)
              v34 = 1;
            tbb::internal::governor::DefaultNumberOfThreads = v34;
          }
          v16 = v34 - 1;
          if (v16 <= a2)
            v16 = a2;
        }
        if (v16 >= v14)
          v35 = v14 - 1;
        else
          v35 = v16;
        tbb::internal::market::set_active_num_workers(v35);
      }
    }
    else
    {
      __dmb(0xBu);
      LOBYTE(tbb::internal::market::theMarketMutex) = 0;
    }
    v36 = tbb::internal::governor::DefaultNumberOfThreads;
    if (!tbb::internal::governor::DefaultNumberOfThreads)
    {
      *(_QWORD *)v43 = 0x1900000006;
      v42 = 0;
      v41 = 4;
      sysctl(v43, 2u, &v42, &v41, 0, 0);
      v36 = v42;
      if (v42 <= 1)
        v36 = 1;
      tbb::internal::governor::DefaultNumberOfThreads = v36;
    }
    if (v36 - 1 != (_DWORD)a2)
    {
      v37 = &v12[13].u32[3];
      v38 = v12[13].u32[3];
      if (v38 < a2)
      {
        tbb::internal::runtime_warning((tbb::internal *)"The number of workers is currently limited to %u. The request for %u workers is ignored. Further requests for more workers will be silently ignored until the limit changes.\n", a2, v12[13].u32[3], a2);
        do
        {
          while (1)
          {
            v39 = __ldaxr(v37);
            if (v39 == v38)
              break;
            __clrex();
            if (*v37 != v38)
              goto LABEL_66;
          }
        }
        while (__stlxr(0xFFFFFFFF, v37));
      }
    }
LABEL_66:
    if (v12[13].i64[0] < v5)
      tbb::internal::runtime_warning((tbb::internal *)"Thread stack size has been already set to %u. The request for larger stack (%u) cannot be satisfied.\n", a2, v12[13].i64[0], v5);
  }
  else
  {
    if (!v5)
    {
      this = tbb::interface9::global_control::active_value((tbb::interface9::global_control *)1, (int)a2, a3, a4, a5);
      v5 = this;
    }
    v17 = tbb::internal::governor::DefaultNumberOfThreads;
    if (!tbb::internal::governor::DefaultNumberOfThreads)
    {
      *(_QWORD *)v43 = 0x1900000006;
      v42 = 0;
      v41 = 4;
      this = sysctl(v43, 2u, &v42, &v41, 0, 0);
      if (v42 <= 1)
        v17 = 1;
      else
        v17 = v42;
      tbb::internal::governor::DefaultNumberOfThreads = v17;
    }
    v18 = (tbb::internal::market *)tbb::internal::market::app_parallelism_limit((tbb::internal::market *)this);
    if (v17 >= 0x81)
      v19 = 1;
    else
      v19 = 2;
    v20 = v17 << v19;
    if (v20 <= v18)
      v20 = v18;
    if (v20 <= 0x100)
      v21 = 256;
    else
      v21 = v20;
    v22 = (tbb::internal::__TBB_InitOnce *)tbb::internal::market::app_parallelism_limit(v18);
    if ((_DWORD)v22)
    {
      v23 = (_DWORD)v22 - 1;
    }
    else
    {
      v24 = tbb::internal::governor::DefaultNumberOfThreads;
      if (!tbb::internal::governor::DefaultNumberOfThreads)
      {
        *(_QWORD *)v43 = 0x1900000006;
        v42 = 0;
        v41 = 4;
        v22 = (tbb::internal::__TBB_InitOnce *)sysctl(v43, 2u, &v42, &v41, 0, 0);
        v24 = v42;
        if (v42 <= 1)
          v24 = 1;
        tbb::internal::governor::DefaultNumberOfThreads = v24;
      }
      v23 = v24 - 1;
      if (v23 <= a2)
        v23 = a2;
    }
    if (v23 >= v21)
      v25 = v21 - 1;
    else
      v25 = v23;
    tbb::internal::__TBB_InitOnce::add_ref(v22);
    v26 = 8 * (v21 - 1) + 256;
    v12 = (int64x2_t *)tbb::internal::NFS_Allocate(1uLL, v26, 0, v27);
    bzero(v12, v26);
    v12->i64[0] = (uint64_t)off_24C5162E0;
    v12->i64[1] = 0;
    v12[1].i32[2] = v21;
    v12[1].i32[3] = v25;
    v12[3] = vdupq_n_s64(1uLL);
    v12[5].i64[0] = (uint64_t)&v12[4].i64[1];
    v12[5].i64[1] = 0;
    v12[4].i64[1] = (uint64_t)&v12[4].i64[1];
    v12[7].i64[1] = (uint64_t)v12[7].i64;
    v12[8].i64[0] = 0;
    v12[7].i64[0] = (uint64_t)v12[7].i64;
    v12[10].i64[0] = (uint64_t)&v12[9].i64[1];
    v12[10].i64[1] = 0;
    v12[9].i64[1] = (uint64_t)&v12[9].i64[1];
    v12[12].i32[2] = 1;
    v12[13].i64[0] = v5;
    v12[13].i32[3] = v25;
    v12[14].i64[1] = (uint64_t)v12[14].i64;
    v12[15].i64[0] = 0;
    v12[14].i64[0] = (uint64_t)v12[14].i64;
    v12[9].i32[1] = v25;
    rml_server = tbb::internal::governor::create_rml_server((uint64_t)v12, v28, v29, v30);
    v12[1].i64[0] = rml_server;
    if (v7)
      v12[12].i32[3] = 1;
    tbb::internal::market::theMarket = (uint64_t)v12;
    if (!tbb::internal::governor::UsePrivateRML
      && (*(unsigned int (**)(uint64_t))(*(_QWORD *)rml_server + 32))(rml_server) < v25)
    {
      v32 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12[1].i64[0] + 32))(v12[1].i64[0]);
      tbb::internal::runtime_warning((tbb::internal *)"RML might limit the number of workers to %u while %u is requested.\n", v33, v32, v25);
    }
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
  }
  return v12;
}

void sub_20BDCE2A4(_Unwind_Exception *a1)
{
  _BYTE *v1;

  __dmb(0xBu);
  *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t tbb::internal::market::set_active_num_workers(uint64_t this)
{
  int v1;
  char v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t k;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t i;
  uint64_t v26;
  uint64_t v27;
  uint64_t j;
  uint64_t v29;
  uint64_t v30;
  uint64_t m;

  v1 = this;
LABEL_2:
  v2 = 8 * (&tbb::internal::market::theMarketMutex & 3);
  v3 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v2);
  v4 = v3 | (1 << v2);
  do
  {
    while (1)
    {
      v5 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL));
      if (v5 == v3)
        break;
      __clrex();
      if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v3)
      {
        this = sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v4, (unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL)));
  v6 = tbb::internal::market::theMarket;
  if (!tbb::internal::market::theMarket || *(_DWORD *)(tbb::internal::market::theMarket + 28) == v1)
    goto LABEL_34;
  ++*(_DWORD *)(tbb::internal::market::theMarket + 200);
  __dmb(0xBu);
  LOBYTE(tbb::internal::market::theMarketMutex) = 0;
  v7 = (unint64_t *)(v6 + 8);
  tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::spin_rw_mutex_v3 *)(v6 + 8));
  if (!*(_DWORD *)(v6 + 28))
  {
    v23 = *(_DWORD *)(v6 + 44);
    if (v23 >= 1)
    {
      v24 = *(int *)(v6 + 48);
      for (i = *(_QWORD *)(v6 + 56); i <= v24; --v24)
      {
        v26 = v6 + 40 * v24;
        v27 = v26 + 72;
        for (j = *(_QWORD *)(v26 + 80); j != v27; j = *(_QWORD *)(j + 8))
        {
          if (*(_BYTE *)(j + 337))
          {
            *(_BYTE *)(j + 337) = 0;
            *(_DWORD *)(v6 + 44) = --v23;
          }
        }
      }
    }
  }
  __dmb(0xBu);
  *(_DWORD *)(v6 + 28) = v1;
  *(_DWORD *)(v6 + 220) = v1;
  v8 = *(_QWORD *)(v6 + 48);
  if (!v1)
  {
    v9 = *(_QWORD *)(v6 + 56);
    for (k = (int)v8; v9 <= k; --k)
    {
      v29 = v6 + 40 * k;
      v30 = v29 + 72;
      for (m = *(_QWORD *)(v29 + 80); m != v30; m = *(_QWORD *)(m + 8))
      {
        if (*(_QWORD *)(m + 8 * k + 152))
        {
          *(_BYTE *)(m + 337) = 1;
          ++*(_DWORD *)(v6 + 44);
        }
      }
    }
  }
  v11 = *(_DWORD *)(v6 + 32);
  v12 = *(_DWORD *)(v6 + 40);
  if (v12 >= v1)
    v12 = v1;
  if (*(int *)(v6 + 44) >= 1)
    v12 = 1;
  *(_DWORD *)(v6 + 32) = v12;
  *(_DWORD *)(v6 + 40 * v8 + 108) = v12;
  this = tbb::internal::market::update_allotment(v6, v8);
  v13 = *(_DWORD *)(v6 + 32);
LABEL_18:
  v14 = *v7;
  v15 = *v7 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    while (1)
    {
      v16 = __ldaxr(v7);
      if (v16 == v14)
        break;
      __clrex();
      do
        v17 = __ldxr(v7);
      while (__stxr(v17, v7));
      if (v17 != v14)
      {
        this = sched_yield();
        goto LABEL_18;
      }
    }
  }
  while (__stlxr(v15, v7));
  if (v13 != v11)
    this = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v6 + 16) + 40))(*(_QWORD *)(v6 + 16), (v13 - v11));
LABEL_27:
  v18 = 8 * (&tbb::internal::market::theMarketMutex & 3);
  v19 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v18);
  v20 = v19 | (1 << v18);
  do
  {
    while (1)
    {
      v21 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL));
      if (v21 == v19)
        break;
      __clrex();
      if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v19)
      {
        this = sched_yield();
        goto LABEL_27;
      }
    }
  }
  while (__stlxr(v20, (unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL)));
  v22 = *(_DWORD *)(v6 + 200) - 1;
  *(_DWORD *)(v6 + 200) = v22;
  if (v22)
  {
LABEL_34:
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
  }
  else
  {
    tbb::internal::market::theMarket = 0;
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
    *(_BYTE *)(v6 + 216) = 0;
    return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v6 + 16) + 8))(*(_QWORD *)(v6 + 16), 0);
  }
  return this;
}

tbb::internal::governor *tbb::internal::market::destroy(tbb::internal::market *this, void *a2)
{
  tbb::internal::governor *v2;

  v2 = (tbb::internal::governor *)tbb::internal::NFS_Free(this, a2);
  return tbb::internal::__TBB_InitOnce::remove_ref(v2);
}

uint64_t tbb::internal::market::release(tbb::internal::market *this, int a2, uint64_t a3)
{
  char v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  char v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;

LABEL_1:
  v6 = 8 * (&tbb::internal::market::theMarketMutex & 3);
  v7 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v6);
  v8 = v7 | (1 << v6);
  do
  {
    while (1)
    {
      v9 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL));
      if (v9 == v7)
        break;
      __clrex();
      if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v7)
      {
        sched_yield();
        goto LABEL_1;
      }
    }
  }
  while (__stlxr(v8, (unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL)));
  if ((_DWORD)a3 && *((_DWORD *)this + 51) == 1)
  {
    do
    {
      if (*((_DWORD *)this + 50) < 2u)
        break;
      __dmb(0xBu);
      LOBYTE(tbb::internal::market::theMarketMutex) = 0;
      while (1)
      {
        v10 = *((_DWORD *)this + 51);
        __dmb(0xBu);
        if (v10 != 1)
          break;
        v11 = *((_DWORD *)this + 50);
        __dmb(0xBu);
        if (v11 < 2)
          break;
        sched_yield();
      }
LABEL_15:
      v12 = 8 * (&tbb::internal::market::theMarketMutex & 3);
      v13 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v12);
      v14 = v13 | (1 << v12);
      do
      {
        while (1)
        {
          v15 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL));
          if (v15 == v13)
            break;
          __clrex();
          if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v13)
          {
            sched_yield();
            goto LABEL_15;
          }
        }
      }
      while (__stlxr(v14, (unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL)));
    }
    while (*((_DWORD *)this + 51) == 1);
  }
  if (a2)
    --*((_DWORD *)this + 51);
  v16 = *((_DWORD *)this + 50) - 1;
  *((_DWORD *)this + 50) = v16;
  if (v16)
  {
    a3 = 0;
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
  }
  else
  {
    tbb::internal::market::theMarket = 0;
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
    *((_BYTE *)this + 216) = a3;
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 2) + 8))(*((_QWORD *)this + 2), 0);
  }
  return a3;
}

  v9 = a2 - 3;
  v10 = (const void **)a1;
LABEL_2:
  v11 = 1 - a4;
  while (2)
  {
    a1 = (uint64_t)v10;
    v12 = v11;
    v13 = (char *)a2 - (char *)v10;
    v14 = 0xAAAAAAAAAAAAAAABLL * (a2 - v10);
    switch(v14)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (sub_20BDDDF74(a3, a2 - 3, v10))
        {
          v29 = v10[2];
          v27 = *(_OWORD *)v10;
          v25 = *(_OWORD *)v9;
          v10[2] = *(a2 - 1);
          *(_OWORD *)v10 = v25;
          *(_OWORD *)v9 = v27;
          *(a2 - 1) = v29;
        }
        return;
      case 3uLL:
        sub_20BEDB574(v10, v10 + 3, a2 - 3, a3);
        return;
      case 4uLL:
        sub_20BEDBC08((uint64_t)v10, v10 + 3, v10 + 6, (__int128 *)(a2 - 3), a3);
        return;
      case 5uLL:
        sub_20BEDBCF0((uint64_t)v10, v10 + 3, v10 + 6, (__int128 *)(v10 + 9), (__int128 *)(a2 - 3), a3);
        return;
      default:
        if (v13 <= 575)
        {
          if ((a5 & 1) != 0)
            sub_20BEDB350((uint64_t)v10, a2, a3);
          else
            sub_20BEDB470(v10, a2, a3);
          return;
        }
        if (v12 != 1)
        {
          v15 = v14 >> 1;
          v16 = &v10[3 * (v14 >> 1)];
          if ((unint64_t)v13 < 0xC01)
          {
            sub_20BEDB574(&v10[3 * v15], v10, a2 - 3, a3);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          else
          {
            sub_20BEDB574(v10, &v10[3 * v15], a2 - 3, a3);
            v17 = 3 * v15;
            v18 = &v10[3 * v15 - 3];
            sub_20BEDB574(v10 + 3, v18, a2 - 6, a3);
            v19 = v10 + 6;
            v20 = &v10[v17 + 3];
            sub_20BEDB574(v19, v20, a2 - 9, a3);
            sub_20BEDB574(v18, v16, v20, a3);
            v28 = *(const void **)(a1 + 16);
            v26 = *(_OWORD *)a1;
            v21 = *(_OWORD *)v16;
            *(_QWORD *)(a1 + 16) = v16[2];
            *(_OWORD *)a1 = v21;
            v16[2] = v28;
            *(_OWORD *)v16 = v26;
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          if (!sub_20BDDDF74(a3, (const void **)(a1 - 24), (const void **)a1))
          {
            v10 = sub_20BEDB6BC((const void **)a1, (unint64_t)a2, a3);
            goto LABEL_16;
          }
LABEL_11:
          v22 = sub_20BEDB84C((__int128 *)a1, a2, a3);
          if ((v23 & 1) == 0)
            goto LABEL_14;
          v24 = sub_20BEDB9D8(a1, v22, a3);
          v10 = (const void **)(v22 + 24);
          if (!sub_20BEDB9D8(v22 + 24, (uint64_t)a2, a3))
          {
            v11 = v12 + 1;
            if (v24)
              continue;
LABEL_14:
            sub_20BEDAFAC(a1, v22, a3, -v12, a5 & 1);
            v10 = (const void **)(v22 + 24);
LABEL_16:
            a5 = 0;
            a4 = -v12;
            goto LABEL_2;
          }
          a4 = -v12;
          a2 = (const void **)v22;
          if (v24)
            return;
          goto LABEL_1;
        }
        if (v10 != a2)
          sub_20BEDBE10((uint64_t)v10, (__int128 *)a2, (__int128 *)a2, a3);
        return;
    }
  }
}

  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = ((char *)a2 - (char *)v9) >> 5;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v24 = *(a2 - 4);
        v25 = *v9;
        if (v24 < *v9)
          goto LABEL_23;
        if (v25 >= v24 && pxrInternal__aapl__pxrReserved__::TraceThreadId::operator<(a2 - 3, v9 + 1))
        {
          v25 = *v9;
          v24 = *(a2 - 4);
LABEL_23:
          *v9 = v24;
          *(a2 - 4) = v25;
          v26 = v9[1];
          *(_QWORD *)((char *)&v30 + 7) = *(unint64_t *)((char *)v9 + 23);
          *(_QWORD *)&v30 = v9[2];
          v27 = *((_BYTE *)v9 + 31);
          v9[2] = 0;
          v9[3] = 0;
          v9[1] = 0;
          v28 = *(_OWORD *)(a2 - 3);
          v9[3] = *(a2 - 1);
          *(_OWORD *)(v9 + 1) = v28;
          *(a2 - 3) = v26;
          *(a2 - 2) = v30;
          *(unint64_t *)((char *)a2 - 9) = *(_QWORD *)((char *)&v30 + 7);
          *((_BYTE *)a2 - 1) = v27;
        }
        return;
      case 3uLL:
        sub_20BF21700(v9, v9 + 4, a2 - 4);
        return;
      case 4uLL:
        sub_20BF22274((uint64_t)v9, (uint64_t)(v9 + 4), (uint64_t)(v9 + 8), (uint64_t)(a2 - 4));
        return;
      case 5uLL:
        sub_20BF2248C((uint64_t)v9, (uint64_t)(v9 + 4), (uint64_t)(v9 + 8), (uint64_t)(v9 + 12), a2 - 4);
        return;
      default:
        if (v12 <= 767)
        {
          if ((a5 & 1) != 0)
            sub_20BF213F8(v9, a2);
          else
            sub_20BF21594(v9, a2);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[4 * (v13 >> 1)];
          if ((unint64_t)v12 <= 0x1000)
          {
            sub_20BF21700(&v9[4 * (v13 >> 1)], v9, a2 - 4);
            if ((a5 & 1) != 0)
              goto LABEL_13;
          }
          else
          {
            sub_20BF21700(v9, &v9[4 * (v13 >> 1)], a2 - 4);
            sub_20BF21700(v9 + 4, v15 - 4, a2 - 8);
            sub_20BF21700(v9 + 8, &v9[4 * v14 + 4], a2 - 12);
            sub_20BF21700(v15 - 4, v15, &v9[4 * v14 + 4]);
            v16 = *v9;
            v17 = v9[1];
            *v9 = *v15;
            *v15 = v16;
            *(_QWORD *)((char *)&v29 + 7) = *(unint64_t *)((char *)v9 + 23);
            *(_QWORD *)&v29 = v9[2];
            v18 = *((_BYTE *)v9 + 31);
            v9[2] = 0;
            v9[3] = 0;
            v9[1] = 0;
            v19 = *(_OWORD *)(v15 + 1);
            v9[3] = v15[3];
            *(_OWORD *)(v9 + 1) = v19;
            v15[1] = v17;
            *(unint64_t *)((char *)v15 + 23) = *(_QWORD *)((char *)&v29 + 7);
            v15[2] = v29;
            *((_BYTE *)v15 + 31) = v18;
            if ((a5 & 1) != 0)
              goto LABEL_13;
          }
          v20 = *(v9 - 4);
          if (v20 >= *v9 && (*v9 < v20 || !pxrInternal__aapl__pxrReserved__::TraceThreadId::operator<(v9 - 3, v9 + 1)))
          {
            v9 = sub_20BF21A04((uint64_t *)v9, (unint64_t)a2);
            goto LABEL_18;
          }
LABEL_13:
          v21 = sub_20BF21CB8((uint64_t *)v9, (unint64_t)a2);
          if ((v22 & 1) == 0)
            goto LABEL_16;
          v23 = sub_20BF21F64((uint64_t)v9, (unint64_t *)v21);
          v9 = (unint64_t *)(v21 + 4);
          if (!sub_20BF21F64((uint64_t)(v21 + 4), a2))
          {
            v10 = v11 + 1;
            if (v23)
              continue;
LABEL_16:
            sub_20BF20F3C(a1, v21, a3, -v11, a5 & 1);
            v9 = (unint64_t *)(v21 + 4);
LABEL_18:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = (unint64_t *)v21;
          if (v23)
            return;
          goto LABEL_1;
        }
        if (v9 != a2)
          sub_20BF22738((uint64_t)v9, (uint64_t)a2, (uint64_t)a2, a3);
        return;
    }
  }
}

  v4 = 8 * (&dword_2549853B8 & 3);
  v5 = *(_DWORD *)((unint64_t)&dword_2549853B8 & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v4);
  v6 = v5 | (1 << v4);
  do
  {
    while (1)
    {
      v7 = __ldaxr((unsigned int *)((unint64_t)&dword_2549853B8 & 0xFFFFFFFFFFFFFFFCLL));
      if (v7 == v5)
        break;
      __clrex();
      if (*(_DWORD *)((unint64_t)&dword_2549853B8 & 0xFFFFFFFFFFFFFFFCLL) != v5)
      {
        sched_yield();
        goto LABEL_1;
      }
    }
  }
  while (__stlxr(v6, (unsigned int *)((unint64_t)&dword_2549853B8 & 0xFFFFFFFFFFFFFFFCLL)));
  sub_20BEB4F9C(a1 + 8, a2, (uint64_t)a2);
  result = v8 & 1;
  __dmb(0xBu);
  LOBYTE(dword_2549853B8) = 0;
  return result;
}

  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = a2 - v9;
    v13 = 0x6DB6DB6DB6DB6DB7 * ((a2 - v9) >> 3);
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (pxrInternal__aapl__pxrReserved__::SdfReference::operator<(a2 - 56, v9))
          sub_20C02B118((uint64_t)v9, (__int128 *)(a2 - 56));
        return;
      case 3uLL:
        sub_20C02A7D8(v9, v9 + 56, a2 - 56);
        return;
      case 4uLL:
        sub_20C02B2D8(v9, v9 + 56, v9 + 112, (__int128 *)(a2 - 56));
        return;
      case 5uLL:
        sub_20C02B370(v9, v9 + 56, v9 + 112, (__int128 *)(v9 + 168), (__int128 *)(a2 - 56));
        return;
      default:
        if (v12 <= 1343)
        {
          if ((a5 & 1) != 0)
            sub_20C02A368(v9, a2);
          else
            sub_20C02A5BC((uint64_t)v9, a2);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[56 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x1C01)
          {
            sub_20C02A7D8(v15, v9, a2 - 56);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          else
          {
            sub_20C02A7D8(v9, v15, a2 - 56);
            v16 = 56 * v14;
            v17 = &v9[56 * v14 - 56];
            sub_20C02A7D8(v9 + 56, v17, a2 - 112);
            v18 = v9 + 112;
            v19 = &v9[v16 + 56];
            sub_20C02A7D8(v18, v19, a2 - 168);
            sub_20C02A7D8(v17, v15, v19);
            sub_20C02B118((uint64_t)a1, (__int128 *)v15);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          if (!pxrInternal__aapl__pxrReserved__::SdfReference::operator<(a1 - 56, a1))
          {
            v9 = sub_20C02A898((uint64_t)a1, a2);
            goto LABEL_16;
          }
LABEL_11:
          v20 = sub_20C02AB2C((uint64_t)a1, a2);
          if ((v21 & 1) == 0)
            goto LABEL_14;
          v22 = sub_20C02ADD4((uint64_t)a1, (uint64_t)v20);
          v9 = v20 + 56;
          if (!sub_20C02ADD4((uint64_t)(v20 + 56), (uint64_t)a2))
          {
            v10 = v11 + 1;
            if (v22)
              continue;
LABEL_14:
            sub_20C029FE4(a1, v20, a3, -v11, a5 & 1);
            v9 = v20 + 56;
LABEL_16:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = v20;
          if (v22)
            return;
          goto LABEL_1;
        }
        if (v9 != a2)
          sub_20C02B434((__int128 *)v9, (__int128 *)a2, a2, a3);
        return;
    }
  }
}

  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)v9) >> 4);
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (pxrInternal__aapl__pxrReserved__::SdfPayload::operator<(a2 - 6, v9))
          sub_20C02DDC8((uint64_t)v9, (__int128 *)a2 - 3);
        return;
      case 3uLL:
        sub_20C02D570(v9, (const void **)v9 + 6, a2 - 6);
        return;
      case 4uLL:
        sub_20C02DF38(v9, (const void **)v9 + 6, (const void **)v9 + 12, (__int128 *)a2 - 3);
        return;
      case 5uLL:
        sub_20C02DFD0(v9, (const void **)v9 + 6, (const void **)v9 + 12, (__int128 *)v9 + 9, (__int128 *)a2 - 3);
        return;
      default:
        if (v12 <= 1151)
        {
          if ((a5 & 1) != 0)
            sub_20C02D198((const void **)v9, a2);
          else
            sub_20C02D394((const void **)v9, a2);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[48 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x1801)
          {
            sub_20C02D570(v15, (const void **)v9, a2 - 6);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          else
          {
            sub_20C02D570(v9, (const void **)v15, a2 - 6);
            v16 = 3 * v14;
            v17 = (const void **)&v9[48 * v14 - 48];
            sub_20C02D570(v9 + 48, v17, a2 - 12);
            v18 = v9 + 96;
            v19 = (const void **)&v9[16 * v16 + 48];
            sub_20C02D570(v18, v19, a2 - 18);
            sub_20C02D570((unsigned __int8 *)v17, (const void **)v15, v19);
            sub_20C02DDC8((uint64_t)a1, (__int128 *)v15);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          if (!pxrInternal__aapl__pxrReserved__::SdfPayload::operator<((const void **)a1 - 6, a1))
          {
            v9 = sub_20C02D630((uint64_t)a1, (unsigned __int8 *)a2);
            goto LABEL_16;
          }
LABEL_11:
          v20 = sub_20C02D880((uint64_t)a1, a2);
          if ((v21 & 1) == 0)
            goto LABEL_14;
          v22 = sub_20C02DAD8((uint64_t)a1, (uint64_t)v20);
          v9 = (unsigned __int8 *)(v20 + 6);
          if (!sub_20C02DAD8((uint64_t)(v20 + 6), (uint64_t)a2))
          {
            v10 = v11 + 1;
            if (v22)
              continue;
LABEL_14:
            sub_20C02CE28(a1, v20, a3, -v11, a5 & 1);
            v9 = (unsigned __int8 *)(v20 + 6);
LABEL_16:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = v20;
          if (v22)
            return;
          goto LABEL_1;
        }
        if (v9 != (unsigned __int8 *)a2)
          sub_20C02E094((__int128 *)v9, (__int128 *)a2, a2, a3);
        return;
    }
  }
}

  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = a2 - v9;
    v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v9) >> 3);
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v34 = *(char **)(a2 - 24);
        v33 = a2 - 24;
        v32 = v34;
        if (*(char *)(v33 + 23) >= 0)
          v32 = (char *)v33;
        v35 = *v32;
        if (*(char *)(v9 + 23) >= 0)
          v36 = (char *)v9;
        else
          v36 = *(char **)v9;
        if ((v35 & 0x80000000) == 0)
        {
          v37 = *v36;
          if ((v37 & 0x80000000) == 0)
          {
            v38 = v35;
            v39 = v37;
            v40 = (v37 ^ v38) & 0xFFFFFFDF;
            v41 = v38 < 0x40 || v40 == 0;
            if (!v41 && v39 >= 0x40)
            {
              if ((((_BYTE)v38 + 5) & 0x1Fu) >= (((_BYTE)v39 + 5) & 0x1Fu))
                return;
              goto LABEL_47;
            }
          }
        }
        if (pxrInternal__aapl__pxrReserved__::TfDictionaryLessThan::_LessImpl(a3, v33, v9))
        {
LABEL_47:
          v46 = *(_QWORD *)(v9 + 16);
          v44 = *(_OWORD *)v9;
          v42 = *(_OWORD *)v33;
          *(_QWORD *)(v9 + 16) = *(_QWORD *)(v33 + 16);
          *(_OWORD *)v9 = v42;
          *(_OWORD *)v33 = v44;
          *(_QWORD *)(v33 + 16) = v46;
          return;
        }
        return;
      case 3uLL:
        sub_20C2BD834(v9, v9 + 24, a2 - 24, a3);
        return;
      case 4uLL:
        sub_20C2BE82C(v9, v9 + 24, v9 + 48, a2 - 24, a3);
        return;
      case 5uLL:
        sub_20C2BEA60(v9, v9 + 24, v9 + 48, v9 + 72, a2 - 24, a3);
        return;
      default:
        if (v12 <= 575)
        {
          if ((a5 & 1) != 0)
            sub_20C2BD3F8(v9, a2, a3);
          else
            sub_20C2BD628(v9, a2, a3);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = v9 + 24 * (v13 >> 1);
          if ((unint64_t)v12 < 0xC01)
          {
            sub_20C2BD834(v9 + 24 * v14, v9, a2 - 24, a3);
            if ((a5 & 1) != 0)
              goto LABEL_23;
          }
          else
          {
            sub_20C2BD834(v9, v9 + 24 * v14, a2 - 24, a3);
            v16 = 3 * v14;
            v17 = v9 + 24 * v14 - 24;
            sub_20C2BD834(v9 + 24, v17, a2 - 48, a3);
            v18 = v9 + 48;
            v19 = v9 + 24 + 8 * v16;
            sub_20C2BD834(v18, v19, a2 - 72, a3);
            sub_20C2BD834(v17, v15, v19, a3);
            v45 = *(_QWORD *)(a1 + 16);
            v43 = *(_OWORD *)a1;
            v20 = *(_OWORD *)v15;
            *(_QWORD *)(a1 + 16) = *(_QWORD *)(v15 + 16);
            *(_OWORD *)a1 = v20;
            *(_QWORD *)(v15 + 16) = v45;
            *(_OWORD *)v15 = v43;
            if ((a5 & 1) != 0)
              goto LABEL_23;
          }
          v21 = *(char **)(a1 - 24);
          if (*(char *)(a1 - 1) >= 0)
            v21 = (char *)(a1 - 24);
          v22 = *v21;
          if (*(char *)(a1 + 23) >= 0)
            v23 = (char *)a1;
          else
            v23 = *(char **)a1;
          if (v22 < 0
            || (v24 = *v23, v24 < 0)
            || ((v25 = v22,
                 v26 = v24,
                 v27 = (v24 ^ v25) & 0xFFFFFFDF,
                 v25 >= 0x40)
              ? (v28 = v27 == 0)
              : (v28 = 1),
                v28 || v26 < 0x40))
          {
            if ((pxrInternal__aapl__pxrReserved__::TfDictionaryLessThan::_LessImpl(a3, a1 - 24, a1) & 1) == 0)
            {
LABEL_28:
              v9 = sub_20C2BDBB0((__int128 *)a1, a2, a3);
              goto LABEL_30;
            }
          }
          else if ((((_BYTE)v25 + 5) & 0x1Fu) >= (((_BYTE)v26 + 5) & 0x1Fu))
          {
            goto LABEL_28;
          }
LABEL_23:
          v29 = sub_20C2BE04C((__int128 *)a1, a2, a3);
          if ((v30 & 1) == 0)
            goto LABEL_29;
          v31 = sub_20C2BE484(a1, v29, a3);
          v9 = v29 + 24;
          if (!sub_20C2BE484(v29 + 24, a2, a3))
          {
            v10 = v11 + 1;
            if (v31)
              continue;
LABEL_29:
            sub_20C2BCF78(a1, v29, a3, -v11, a5 & 1);
            v9 = v29 + 24;
LABEL_30:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = v29;
          if (v31)
            return;
          goto LABEL_1;
        }
        if (v9 != a2)
          sub_20C2BED40(v9, a2, a2, a3);
        return;
    }
  }
}

  v8 = (uint64_t)(a2 - 6);
  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = (uint64_t)a2 - v9;
    v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v9) >> 4);
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (sub_20C6A64B0(a3, (const void **)v8, (const void **)v9))
        {
          v33 = *(_QWORD *)(v9 + 16);
          v31 = *(_OWORD *)v9;
          v25 = *(_OWORD *)v8;
          *(_QWORD *)(v9 + 16) = *(_QWORD *)(v8 + 16);
          *(_OWORD *)v9 = v25;
          *(_OWORD *)v8 = v31;
          *(_QWORD *)(v8 + 16) = v33;
          v26 = *(const void **)(v9 + 40);
          v27 = *(_OWORD *)(v9 + 24);
          v28 = (uint64_t)*(a2 - 1);
          *(_OWORD *)(v9 + 24) = *(_OWORD *)(a2 - 3);
          *(_QWORD *)(v9 + 40) = v28;
          *(_OWORD *)(a2 - 3) = v27;
          *(a2 - 1) = v26;
        }
        return;
      case 3uLL:
        sub_20C6A682C((__int128 *)v9, (__int128 *)(v9 + 48), (__int128 *)v8, a3);
        return;
      case 4uLL:
        sub_20C6A7034(v9, v9 + 48, v9 + 96, v8, a3);
        return;
      case 5uLL:
        sub_20C6A7184(v9, v9 + 48, v9 + 96, v9 + 144, v8, a3);
        return;
      default:
        if (v12 <= 1151)
        {
          if ((a5 & 1) != 0)
            sub_20C6A65D8(v9, a2, a3);
          else
            sub_20C6A6718((const void **)v9, a2, a3);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = v9 + 48 * (v13 >> 1);
          if ((unint64_t)v12 < 0x1801)
          {
            sub_20C6A682C((__int128 *)v15, (__int128 *)v9, (__int128 *)v8, a3);
          }
          else
          {
            sub_20C6A682C((__int128 *)v9, (__int128 *)v15, (__int128 *)v8, a3);
            v16 = v8;
            v17 = v9 + 48 * v14;
            sub_20C6A682C((__int128 *)(v9 + 48), (__int128 *)(v17 - 48), (__int128 *)a2 - 6, a3);
            sub_20C6A682C((__int128 *)(v9 + 96), (__int128 *)(v9 + 48 + 48 * v14), (__int128 *)a2 - 9, a3);
            sub_20C6A682C((__int128 *)(v17 - 48), (__int128 *)v15, (__int128 *)(v9 + 48 + 48 * v14), a3);
            v32 = *(_QWORD *)(v9 + 16);
            v30 = *(_OWORD *)v9;
            v18 = *(_OWORD *)v15;
            *(_QWORD *)(v9 + 16) = *(_QWORD *)(v15 + 16);
            *(_OWORD *)v9 = v18;
            *(_QWORD *)(v15 + 16) = v32;
            *(_OWORD *)v15 = v30;
            v19 = *(_OWORD *)(v9 + 24);
            v20 = *(_QWORD *)(v9 + 40);
            v21 = *(_QWORD *)(v17 + 40);
            *(_OWORD *)(v9 + 24) = *(_OWORD *)(v17 + 24);
            *(_QWORD *)(v9 + 40) = v21;
            *(_QWORD *)(v17 + 40) = v20;
            *(_OWORD *)(v17 + 24) = v19;
            v8 = v16;
          }
          if ((a5 & 1) == 0 && (sub_20C6A64B0(a3, (const void **)(v9 - 48), (const void **)v9) & 1) == 0)
          {
            v9 = sub_20C6A6A20(v9, (unint64_t)a2, a3);
            goto LABEL_16;
          }
          v22 = sub_20C6A6BF8(v9, a2, a3);
          if ((v23 & 1) == 0)
            goto LABEL_14;
          v24 = sub_20C6A6DD4(v9, (uint64_t)v22, a3);
          v9 = (unint64_t)(v22 + 3);
          if (!sub_20C6A6DD4((uint64_t)(v22 + 3), (uint64_t)a2, a3))
          {
            v10 = v11 + 1;
            if (v24)
              continue;
LABEL_14:
            sub_20C6A60A0(a1, v22, a3, -v11, a5 & 1);
            v9 = (unint64_t)(v22 + 3);
LABEL_16:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = (const void **)v22;
          if (v24)
            return;
          goto LABEL_1;
        }
        if ((const void **)v9 != a2)
          sub_20C6A7338(v9, (uint64_t)a2, (uint64_t)a2, a3);
        return;
    }
  }
}

  v8 = a1;
  while (2)
  {
    a1 = v8;
    v9 = (uint64_t)a2 - v8;
    v10 = (uint64_t)((uint64_t)a2 - v8) >> 4;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v33 = *(a2 - 2);
        v32 = a2 - 2;
        if (v33 < *(double *)v8)
        {
          v85 = *(_OWORD *)v8;
          *(_OWORD *)v8 = *(_OWORD *)v32;
          *(_OWORD *)v32 = v85;
        }
        return;
      case 3uLL:
        sub_20C6B6E64((double *)v8, (double *)(v8 + 16), a2 - 2);
        return;
      case 4uLL:
        sub_20C6B7174((double *)v8, (double *)(v8 + 16), (double *)(v8 + 32), (unint64_t *)a2 - 2);
        return;
      case 5uLL:
        v34 = (__int128 *)(v8 + 16);
        v35 = (__int128 *)(v8 + 32);
        v36 = (__int128 *)(v8 + 48);
        sub_20C6B7174((double *)v8, (double *)(v8 + 16), (double *)(v8 + 32), (unint64_t *)(v8 + 48));
        v38 = *(a2 - 2);
        v37 = a2 - 2;
        if (v38 < *(double *)(v8 + 48))
        {
          v39 = *v36;
          *v36 = *(_OWORD *)v37;
          *(_OWORD *)v37 = v39;
          if (*(double *)v36 < *(double *)v35)
          {
            v40 = *v35;
            *v35 = *v36;
            *v36 = v40;
            if (*(double *)v35 < *(double *)v34)
            {
              v41 = *v34;
              *v34 = *v35;
              *v35 = v41;
              if (*(double *)(v8 + 16) < *(double *)v8)
              {
                v86 = *(_OWORD *)v8;
                *(_OWORD *)v8 = *v34;
                *v34 = v86;
              }
            }
          }
        }
        return;
      default:
        if (v9 <= 383)
        {
          v42 = (double *)(v8 + 16);
          v44 = (double *)v8 == a2 || v42 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v44)
            {
              v45 = 0;
              v46 = v8;
              do
              {
                v47 = v42;
                v48 = *(double *)(v46 + 16);
                if (v48 < *(double *)v46)
                {
                  v49 = *(_QWORD *)(v46 + 24);
                  v50 = v45;
                  while (1)
                  {
                    *(_OWORD *)(v8 + v50 + 16) = *(_OWORD *)(v8 + v50);
                    if (!v50)
                      break;
                    v51 = *(double *)(v8 + v50 - 16);
                    v50 -= 16;
                    if (v48 >= v51)
                    {
                      v52 = v8 + v50 + 16;
                      goto LABEL_76;
                    }
                  }
                  v52 = v8;
LABEL_76:
                  *(double *)v52 = v48;
                  *(_QWORD *)(v52 + 8) = v49;
                }
                v42 = v47 + 2;
                v45 += 16;
                v46 = (unint64_t)v47;
              }
              while (v47 + 2 != a2);
            }
          }
          else if (!v44)
          {
            do
            {
              v77 = (uint64_t)v42;
              v78 = *(double *)(a1 + 16);
              if (v78 < *(double *)a1)
              {
                v79 = *(_QWORD *)(a1 + 24);
                v80 = v42;
                do
                {
                  *(_OWORD *)v80 = *((_OWORD *)v80 - 1);
                  v81 = *(v80 - 4);
                  v80 -= 2;
                }
                while (v78 < v81);
                *v80 = v78;
                *((_QWORD *)v80 + 1) = v79;
              }
              v42 += 2;
              a1 = v77;
            }
            while ((double *)(v77 + 16) != a2);
          }
          return;
        }
        if (!a3)
        {
          if ((double *)v8 != a2)
          {
            v53 = (v10 - 2) >> 1;
            v54 = v53;
            do
            {
              v55 = v54;
              if (v53 >= v54)
              {
                v56 = (2 * v54) | 1;
                v57 = (double *)(v8 + 16 * v56);
                if (2 * v55 + 2 < (uint64_t)v10 && *v57 < v57[2])
                {
                  v57 += 2;
                  v56 = 2 * v55 + 2;
                }
                v58 = (double *)(v8 + 16 * v55);
                v59 = *v58;
                if (*v57 >= *v58)
                {
                  v60 = *((_QWORD *)v58 + 1);
                  do
                  {
                    v61 = v58;
                    v58 = v57;
                    *(_OWORD *)v61 = *(_OWORD *)v57;
                    if (v53 < v56)
                      break;
                    v62 = 2 * v56;
                    v56 = (2 * v56) | 1;
                    v57 = (double *)(v8 + 16 * v56);
                    v63 = v62 + 2;
                    if (v63 < (uint64_t)v10 && *v57 < v57[2])
                    {
                      v57 += 2;
                      v56 = v63;
                    }
                  }
                  while (*v57 >= v59);
                  *v58 = v59;
                  *((_QWORD *)v58 + 1) = v60;
                }
              }
              v54 = v55 - 1;
            }
            while (v55);
            v64 = (unint64_t)v9 >> 4;
            do
            {
              v65 = 0;
              v87 = *(_OWORD *)v8;
              v66 = (double *)v8;
              do
              {
                v67 = v66;
                v66 += 2 * v65 + 2;
                v68 = 2 * v65;
                v65 = (2 * v65) | 1;
                v69 = v68 + 2;
                if (v69 < v64 && *v66 < v66[2])
                {
                  v66 += 2;
                  v65 = v69;
                }
                *(_OWORD *)v67 = *(_OWORD *)v66;
              }
              while (v65 <= (uint64_t)((unint64_t)(v64 - 2) >> 1));
              a2 -= 2;
              if (v66 == a2)
              {
                *(_OWORD *)v66 = v87;
              }
              else
              {
                *(_OWORD *)v66 = *(_OWORD *)a2;
                *(_OWORD *)a2 = v87;
                v70 = (uint64_t)v66 - v8 + 16;
                if (v70 >= 17)
                {
                  v71 = (((unint64_t)v70 >> 4) - 2) >> 1;
                  v72 = (double *)(v8 + 16 * v71);
                  v73 = *v66;
                  if (*v72 < *v66)
                  {
                    v74 = *((_QWORD *)v66 + 1);
                    do
                    {
                      v75 = v66;
                      v66 = v72;
                      *(_OWORD *)v75 = *(_OWORD *)v72;
                      if (!v71)
                        break;
                      v71 = (v71 - 1) >> 1;
                      v72 = (double *)(v8 + 16 * v71);
                    }
                    while (*v72 < v73);
                    *v66 = v73;
                    *((_QWORD *)v66 + 1) = v74;
                  }
                }
              }
            }
            while (v64-- > 2);
          }
          return;
        }
        v11 = v10 >> 1;
        v12 = (double *)(v8 + 16 * (v10 >> 1));
        if ((unint64_t)v9 < 0x801)
        {
          sub_20C6B6E64((double *)(a1 + 16 * (v10 >> 1)), (double *)a1, a2 - 2);
        }
        else
        {
          sub_20C6B6E64((double *)a1, (double *)(a1 + 16 * (v10 >> 1)), a2 - 2);
          sub_20C6B6E64((double *)(a1 + 16), v12 - 2, a2 - 4);
          sub_20C6B6E64((double *)(a1 + 32), (double *)(a1 + 16 + 16 * v11), a2 - 6);
          sub_20C6B6E64(v12 - 2, v12, (double *)(a1 + 16 + 16 * v11));
          v82 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)v12;
          *(_OWORD *)v12 = v82;
        }
        --a3;
        v13 = *(double *)a1;
        if ((a4 & 1) == 0 && *(double *)(a1 - 16) >= v13)
        {
          if (v13 >= *(a2 - 2))
          {
            v26 = a1 + 16;
            do
            {
              v8 = v26;
              if (v26 >= (unint64_t)a2)
                break;
              v26 += 16;
            }
            while (v13 >= *(double *)v8);
          }
          else
          {
            v8 = a1;
            do
            {
              v25 = *(double *)(v8 + 16);
              v8 += 16;
            }
            while (v13 >= v25);
          }
          v27 = a2;
          if (v8 < (unint64_t)a2)
          {
            v27 = a2;
            do
            {
              v28 = *(v27 - 2);
              v27 -= 2;
            }
            while (v13 < v28);
          }
          v29 = *(_QWORD *)(a1 + 8);
          while (v8 < (unint64_t)v27)
          {
            v84 = *(_OWORD *)v8;
            *(_OWORD *)v8 = *(_OWORD *)v27;
            *(_OWORD *)v27 = v84;
            do
            {
              v30 = *(double *)(v8 + 16);
              v8 += 16;
            }
            while (v13 >= v30);
            do
            {
              v31 = *(v27 - 2);
              v27 -= 2;
            }
            while (v13 < v31);
          }
          if (v8 - 16 != a1)
            *(_OWORD *)a1 = *(_OWORD *)(v8 - 16);
          a4 = 0;
          *(double *)(v8 - 16) = v13;
          *(_QWORD *)(v8 - 8) = v29;
          continue;
        }
        v14 = 0;
        v15 = *(_QWORD *)(a1 + 8);
        do
        {
          v16 = *(double *)(a1 + v14 + 16);
          v14 += 16;
        }
        while (v16 < v13);
        v17 = a1 + v14;
        v18 = a2;
        if (v14 == 16)
        {
          v18 = a2;
          do
          {
            if (v17 >= (unint64_t)v18)
              break;
            v20 = *(v18 - 2);
            v18 -= 2;
          }
          while (v20 >= v13);
        }
        else
        {
          do
          {
            v19 = *(v18 - 2);
            v18 -= 2;
          }
          while (v19 >= v13);
        }
        v8 = a1 + v14;
        if (v17 < (unint64_t)v18)
        {
          v21 = v18;
          do
          {
            v83 = *(_OWORD *)v8;
            *(_OWORD *)v8 = *(_OWORD *)v21;
            *(_OWORD *)v21 = v83;
            do
            {
              v22 = *(double *)(v8 + 16);
              v8 += 16;
            }
            while (v22 < v13);
            do
            {
              v23 = *(v21 - 2);
              v21 -= 2;
            }
            while (v23 >= v13);
          }
          while (v8 < (unint64_t)v21);
        }
        if (v8 - 16 != a1)
          *(_OWORD *)a1 = *(_OWORD *)(v8 - 16);
        *(double *)(v8 - 16) = v13;
        *(_QWORD *)(v8 - 8) = v15;
        if (v17 < (unint64_t)v18)
        {
LABEL_29:
          sub_20C6B6710(a1, v8 - 16, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v24 = sub_20C6B6F40(a1, v8 - 16);
        if (!sub_20C6B6F40(v8, (uint64_t)a2))
        {
          if (v24)
            continue;
          goto LABEL_29;
        }
        a2 = (double *)(v8 - 16);
        if (!v24)
          goto LABEL_1;
        return;
    }
  }
}

  v6 = a2;
  v679 = (uint64_t *)(a2 - 16);
  while (2)
  {
    v7 = i;
    v8 = v6 - (char *)i;
    v9 = (v6 - (char *)i) >> 4;
    v685 = i;
    switch(v9)
    {
      case 0:
      case 1:
        return;
      case 2:
        v321 = *((_QWORD *)a2 - 2);
        v322 = (std::__shared_weak_count *)*((_QWORD *)a2 - 1);
        if (v322)
        {
          p_shared_owners = (unint64_t *)&v322->__shared_owners_;
          do
            v324 = __ldxr(p_shared_owners);
          while (__stxr(v324 + 1, p_shared_owners));
        }
        v325 = *i;
        v326 = (std::__shared_weak_count *)i[1];
        if (v326)
        {
          v327 = (unint64_t *)&v326->__shared_owners_;
          do
            v328 = __ldxr(v327);
          while (__stxr(v328 + 1, v327));
        }
        v331 = *(const void **)(v321 + 48);
        v329 = v321 + 48;
        v330 = v331;
        v332 = *(char *)(v329 + 23);
        v335 = *(const void **)(v325 + 48);
        v333 = v325 + 48;
        v334 = v335;
        v336 = *(char *)(v333 + 23);
        if (v336 >= 0)
          v337 = *(unsigned __int8 *)(v333 + 23);
        else
          v337 = *(_QWORD *)(v333 + 8);
        if (v336 >= 0)
          v338 = (const void *)v333;
        else
          v338 = v334;
        if (v332 >= 0)
          v339 = *(unsigned __int8 *)(v329 + 23);
        else
          v339 = *(_QWORD *)(v329 + 8);
        if (v332 >= 0)
          v340 = (const void *)v329;
        else
          v340 = v330;
        if (v339 >= v337)
          v341 = v337;
        else
          v341 = v339;
        v342 = memcmp(v338, v340, v341);
        if (v342)
          v343 = v342 < 0;
        else
          v343 = v337 < v339;
        if (v326)
        {
          v344 = (unint64_t *)&v326->__shared_owners_;
          do
            v345 = __ldaxr(v344);
          while (__stlxr(v345 - 1, v344));
          if (!v345)
          {
            ((void (*)(std::__shared_weak_count *))v326->__on_zero_shared)(v326);
            std::__shared_weak_count::__release_weak(v326);
          }
        }
        if (v322)
        {
          v346 = (unint64_t *)&v322->__shared_owners_;
          do
            v347 = __ldaxr(v346);
          while (__stlxr(v347 - 1, v346));
          if (!v347)
          {
            ((void (*)(std::__shared_weak_count *))v322->__on_zero_shared)(v322);
            std::__shared_weak_count::__release_weak(v322);
          }
        }
        if (v343)
        {
          v348 = *i;
          *i = *((_QWORD *)a2 - 2);
          *((_QWORD *)a2 - 2) = v348;
          v349 = i[1];
          i[1] = *((_QWORD *)a2 - 1);
          *((_QWORD *)a2 - 1) = v349;
        }
        return;
      case 3:
        sub_20C954C34(i, i + 2, v679);
        return;
      case 4:
        sub_20C9556E0(i, i + 2, i + 4, v679);
        return;
      case 5:
        sub_20C954764(i, i + 2, i + 4, i + 6, v679);
        return;
      default:
        if (v8 <= 383)
        {
          if ((a4 & 1) != 0)
          {
            if (i == (uint64_t *)v6)
              return;
            v350 = i + 2;
            if (i + 2 == (uint64_t *)a2)
              return;
            v351 = (uint64_t)i;
            while (1)
            {
              v352 = v350;
              v353 = *(_QWORD *)(v351 + 16);
              v354 = *(std::__shared_weak_count **)(v351 + 24);
              if (v354)
              {
                v355 = (unint64_t *)&v354->__shared_owners_;
                do
                  v356 = __ldxr(v355);
                while (__stxr(v356 + 1, v355));
              }
              v357 = *(_QWORD *)v351;
              v358 = *(std::__shared_weak_count **)(v351 + 8);
              if (v358)
              {
                v359 = (unint64_t *)&v358->__shared_owners_;
                do
                  v360 = __ldxr(v359);
                while (__stxr(v360 + 1, v359));
              }
              v363 = *(const void **)(v353 + 48);
              v361 = v353 + 48;
              v362 = v363;
              v364 = *(char *)(v361 + 23);
              v367 = *(const void **)(v357 + 48);
              v365 = v357 + 48;
              v366 = v367;
              v368 = *(char *)(v365 + 23);
              if (v368 >= 0)
                v369 = *(unsigned __int8 *)(v365 + 23);
              else
                v369 = *(_QWORD *)(v365 + 8);
              if (v368 >= 0)
                v370 = (const void *)v365;
              else
                v370 = v366;
              if (v364 >= 0)
                v371 = *(unsigned __int8 *)(v361 + 23);
              else
                v371 = *(_QWORD *)(v361 + 8);
              if (v364 >= 0)
                v372 = (const void *)v361;
              else
                v372 = v362;
              if (v371 >= v369)
                v373 = v369;
              else
                v373 = v371;
              v374 = memcmp(v370, v372, v373);
              if (v374)
                v375 = v374 < 0;
              else
                v375 = v369 < v371;
              if (v358)
              {
                v376 = (unint64_t *)&v358->__shared_owners_;
                do
                  v377 = __ldaxr(v376);
                while (__stlxr(v377 - 1, v376));
                if (!v377)
                {
                  ((void (*)(std::__shared_weak_count *))v358->__on_zero_shared)(v358);
                  std::__shared_weak_count::__release_weak(v358);
                }
              }
              if (!v354)
                goto LABEL_552;
              v378 = (unint64_t *)&v354->__shared_owners_;
              do
                v379 = __ldaxr(v378);
              while (__stlxr(v379 - 1, v378));
              if (!v379)
              {
                ((void (*)(std::__shared_weak_count *))v354->__on_zero_shared)(v354);
                std::__shared_weak_count::__release_weak(v354);
                if (!v375)
                  goto LABEL_601;
              }
              else
              {
LABEL_552:
                if (!v375)
                  goto LABEL_601;
              }
              v687 = *(_OWORD *)(v351 + 16);
              *v352 = 0;
              v352[1] = 0;
              sub_20BDE82DC((uint64_t)v352, (__int128 *)v351);
              v380 = (uint64_t)i;
              if ((uint64_t *)v351 == i)
                goto LABEL_596;
              while (1)
              {
                v381 = v687;
                if (*((_QWORD *)&v687 + 1))
                {
                  v382 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                  do
                    v383 = __ldxr(v382);
                  while (__stxr(v383 + 1, v382));
                }
                v384 = *(_QWORD *)(v351 - 16);
                v386 = *(std::__shared_weak_count **)(v351 - 8);
                v385 = (uint64_t *)(v351 - 16);
                if (v386)
                {
                  v387 = (unint64_t *)&v386->__shared_owners_;
                  do
                    v388 = __ldxr(v387);
                  while (__stxr(v388 + 1, v387));
                }
                v389 = *(char *)(v381 + 71);
                v392 = *(_QWORD *)(v384 + 48);
                v390 = v384 + 48;
                v391 = v392;
                v393 = *(char *)(v390 + 23);
                v394 = v393 >= 0 ? *(unsigned __int8 *)(v390 + 23) : *(_QWORD *)(v390 + 8);
                v395 = (const void *)(v393 >= 0 ? v390 : v391);
                v396 = v389 >= 0 ? *(unsigned __int8 *)(v381 + 71) : *(_QWORD *)(v381 + 56);
                v397 = v389 >= 0 ? (const void *)(v381 + 48) : *(const void **)(v381 + 48);
                v398 = v396 >= v394 ? v394 : v396;
                v399 = memcmp(v395, v397, v398);
                v400 = v399 ? v399 < 0 : v394 < v396;
                if (!v386)
                  goto LABEL_582;
                v401 = (unint64_t *)&v386->__shared_owners_;
                do
                  v402 = __ldaxr(v401);
                while (__stlxr(v402 - 1, v401));
                if (!v402)
                {
                  ((void (*)(std::__shared_weak_count *))v386->__on_zero_shared)(v386);
                  std::__shared_weak_count::__release_weak(v386);
                  if (!*((_QWORD *)&v381 + 1))
                    goto LABEL_586;
                }
                else
                {
LABEL_582:
                  if (!*((_QWORD *)&v381 + 1))
                    goto LABEL_586;
                }
                v403 = (unint64_t *)(*((_QWORD *)&v381 + 1) + 8);
                do
                  v404 = __ldaxr(v403);
                while (__stlxr(v404 - 1, v403));
                if (v404)
                {
LABEL_586:
                  if (!v400)
                    break;
                  goto LABEL_591;
                }
                (*(void (**)(_QWORD))(**((_QWORD **)&v381 + 1) + 16))(*((_QWORD *)&v381 + 1));
                std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v381 + 1));
                if (!v400)
                  break;
LABEL_591:
                sub_20BDE82DC(v351, (__int128 *)(v351 - 16));
                v351 -= 16;
                v380 = (uint64_t)i;
                if (v385 == i)
                  goto LABEL_596;
              }
              v380 = v351;
LABEL_596:
              sub_20BDE82DC(v380, &v687);
              v405 = (std::__shared_weak_count *)*((_QWORD *)&v687 + 1);
              if (*((_QWORD *)&v687 + 1))
              {
                v406 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                do
                  v407 = __ldaxr(v406);
                while (__stlxr(v407 - 1, v406));
                if (!v407)
                {
                  ((void (*)(std::__shared_weak_count *))v405->__on_zero_shared)(v405);
                  std::__shared_weak_count::__release_weak(v405);
                }
              }
LABEL_601:
              v350 = v352 + 2;
              v351 = (uint64_t)v352;
              if (v352 + 2 == (_QWORD *)a2)
                return;
            }
          }
          if (i == (uint64_t *)v6)
            return;
          v620 = (char *)(i + 2);
LABEL_895:
          if (v620 == a2)
            return;
          v621 = v620;
          v622 = v7[2];
          v623 = (std::__shared_weak_count *)v7[3];
          v624 = (__int128 *)v7;
          if (v623)
          {
            v625 = (unint64_t *)&v623->__shared_owners_;
            do
              v626 = __ldxr(v625);
            while (__stxr(v626 + 1, v625));
          }
          v627 = *v7;
          v628 = (std::__shared_weak_count *)v7[1];
          if (v628)
          {
            v629 = (unint64_t *)&v628->__shared_owners_;
            do
              v630 = __ldxr(v629);
            while (__stxr(v630 + 1, v629));
          }
          v633 = *(const void **)(v622 + 48);
          v631 = v622 + 48;
          v632 = v633;
          v634 = *(char *)(v631 + 23);
          v637 = *(const void **)(v627 + 48);
          v635 = v627 + 48;
          v636 = v637;
          v638 = *(char *)(v635 + 23);
          if (v638 >= 0)
            v639 = *(unsigned __int8 *)(v635 + 23);
          else
            v639 = *(_QWORD *)(v635 + 8);
          if (v638 >= 0)
            v640 = (const void *)v635;
          else
            v640 = v636;
          if (v634 >= 0)
            v641 = *(unsigned __int8 *)(v631 + 23);
          else
            v641 = *(_QWORD *)(v631 + 8);
          if (v634 >= 0)
            v642 = (const void *)v631;
          else
            v642 = v632;
          if (v641 >= v639)
            v643 = v639;
          else
            v643 = v641;
          v644 = memcmp(v640, v642, v643);
          if (v644)
            v645 = v644 < 0;
          else
            v645 = v639 < v641;
          if (v628)
          {
            v646 = (unint64_t *)&v628->__shared_owners_;
            do
              v647 = __ldaxr(v646);
            while (__stlxr(v647 - 1, v646));
            if (!v647)
            {
              ((void (*)(std::__shared_weak_count *))v628->__on_zero_shared)(v628);
              std::__shared_weak_count::__release_weak(v628);
            }
          }
          if (!v623)
            goto LABEL_929;
          v648 = (unint64_t *)&v623->__shared_owners_;
          do
            v649 = __ldaxr(v648);
          while (__stlxr(v649 - 1, v648));
          if (!v649)
          {
            ((void (*)(std::__shared_weak_count *))v623->__on_zero_shared)(v623);
            std::__shared_weak_count::__release_weak(v623);
            if (!v645)
              goto LABEL_972;
          }
          else
          {
LABEL_929:
            if (!v645)
              goto LABEL_972;
          }
          v687 = *(_OWORD *)v621;
          *(_QWORD *)v621 = 0;
          *((_QWORD *)v621 + 1) = 0;
          v650 = (uint64_t)v621;
          while (1)
          {
            v651 = v650;
            v650 = (uint64_t)v624;
            sub_20BDE82DC(v651, v624);
            v652 = v687;
            if (*((_QWORD *)&v687 + 1))
            {
              v653 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
              do
                v654 = __ldxr(v653);
              while (__stxr(v654 + 1, v653));
            }
            v655 = *((_QWORD *)v624-- - 2);
            v656 = *(std::__shared_weak_count **)(v650 - 8);
            if (v656)
            {
              v657 = (unint64_t *)&v656->__shared_owners_;
              do
                v658 = __ldxr(v657);
              while (__stxr(v658 + 1, v657));
            }
            v659 = *(char *)(v652 + 71);
            v662 = *(const void **)(v655 + 48);
            v660 = v655 + 48;
            v661 = v662;
            v663 = *(char *)(v660 + 23);
            if (v663 >= 0)
              v664 = *(unsigned __int8 *)(v660 + 23);
            else
              v664 = *(_QWORD *)(v660 + 8);
            if (v663 >= 0)
              v665 = (const void *)v660;
            else
              v665 = v661;
            if (v659 >= 0)
              v666 = *(unsigned __int8 *)(v652 + 71);
            else
              v666 = *(_QWORD *)(v652 + 56);
            if (v659 >= 0)
              v667 = (const void *)(v652 + 48);
            else
              v667 = *(const void **)(v652 + 48);
            if (v666 >= v664)
              v668 = v664;
            else
              v668 = v666;
            v669 = memcmp(v665, v667, v668);
            if (v669)
              v670 = v669 < 0;
            else
              v670 = v664 < v666;
            if (!v656)
              goto LABEL_959;
            v671 = (unint64_t *)&v656->__shared_owners_;
            do
              v672 = __ldaxr(v671);
            while (__stlxr(v672 - 1, v671));
            if (!v672)
            {
              ((void (*)(std::__shared_weak_count *))v656->__on_zero_shared)(v656);
              std::__shared_weak_count::__release_weak(v656);
              if (*((_QWORD *)&v652 + 1))
              {
LABEL_960:
                v673 = (unint64_t *)(*((_QWORD *)&v652 + 1) + 8);
                do
                  v674 = __ldaxr(v673);
                while (__stlxr(v674 - 1, v673));
                if (!v674)
                {
                  (*(void (**)(_QWORD))(**((_QWORD **)&v652 + 1) + 16))(*((_QWORD *)&v652 + 1));
                  std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v652 + 1));
                }
              }
            }
            else
            {
LABEL_959:
              if (*((_QWORD *)&v652 + 1))
                goto LABEL_960;
            }
            if (!v670)
            {
              sub_20BDE82DC(v650, &v687);
              v675 = (std::__shared_weak_count *)*((_QWORD *)&v687 + 1);
              if (*((_QWORD *)&v687 + 1))
              {
                v676 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                do
                  v677 = __ldaxr(v676);
                while (__stlxr(v677 - 1, v676));
                if (!v677)
                {
                  ((void (*)(std::__shared_weak_count *))v675->__on_zero_shared)(v675);
                  std::__shared_weak_count::__release_weak(v675);
                }
              }
LABEL_972:
              v620 = v621 + 16;
              v7 = (uint64_t *)v621;
              goto LABEL_895;
            }
          }
        }
        if (!a3)
        {
          if (i == (uint64_t *)v6)
            return;
          v678 = v6 - (char *)i;
          v408 = (unint64_t)(v9 - 2) >> 1;
          v683 = v408;
          while (1)
          {
            v409 = v408;
            if (v683 < v408)
              goto LABEL_760;
            v410 = (2 * v408) | 1;
            v411 = &v7[2 * v410];
            v412 = 2 * v408 + 2;
            v680 = v408;
            if (v412 >= v9)
              goto LABEL_642;
            v413 = *v411;
            v414 = (std::__shared_weak_count *)v411[1];
            if (v414)
            {
              v415 = (unint64_t *)&v414->__shared_owners_;
              do
                v416 = __ldxr(v415);
              while (__stxr(v416 + 1, v415));
            }
            v417 = v411[2];
            v418 = (std::__shared_weak_count *)v411[3];
            if (v418)
            {
              v419 = (unint64_t *)&v418->__shared_owners_;
              do
                v420 = __ldxr(v419);
              while (__stxr(v420 + 1, v419));
            }
            v423 = *(const void **)(v413 + 48);
            v421 = v413 + 48;
            v422 = v423;
            v424 = *(char *)(v421 + 23);
            v427 = *(const void **)(v417 + 48);
            v425 = v417 + 48;
            v426 = v427;
            v428 = *(char *)(v425 + 23);
            if (v428 >= 0)
              v429 = *(unsigned __int8 *)(v425 + 23);
            else
              v429 = *(_QWORD *)(v425 + 8);
            if (v428 >= 0)
              v430 = (const void *)v425;
            else
              v430 = v426;
            if (v424 >= 0)
              v431 = *(unsigned __int8 *)(v421 + 23);
            else
              v431 = *(_QWORD *)(v421 + 8);
            if (v424 >= 0)
              v432 = (const void *)v421;
            else
              v432 = v422;
            if (v431 >= v429)
              v433 = v429;
            else
              v433 = v431;
            v434 = memcmp(v430, v432, v433);
            if (v434)
              v435 = v434 < 0;
            else
              v435 = v429 < v431;
            if (v418)
            {
              v436 = (unint64_t *)&v418->__shared_owners_;
              do
                v437 = __ldaxr(v436);
              while (__stlxr(v437 - 1, v436));
              if (!v437)
              {
                ((void (*)(std::__shared_weak_count *))v418->__on_zero_shared)(v418);
                std::__shared_weak_count::__release_weak(v418);
              }
            }
            v409 = v680;
            if (v414)
            {
              v438 = (unint64_t *)&v414->__shared_owners_;
              do
                v439 = __ldaxr(v438);
              while (__stlxr(v439 - 1, v438));
              if (!v439)
                break;
            }
            if (v435)
              goto LABEL_641;
LABEL_642:
            v440 = *v411;
            v441 = (std::__shared_weak_count *)v411[1];
            if (v441)
            {
              v442 = (unint64_t *)&v441->__shared_owners_;
              do
                v443 = __ldxr(v442);
              while (__stxr(v443 + 1, v442));
            }
            v444 = &v685[2 * v409];
            v445 = *v444;
            v446 = (std::__shared_weak_count *)v444[1];
            if (v446)
            {
              v447 = (unint64_t *)&v446->__shared_owners_;
              do
                v448 = __ldxr(v447);
              while (__stxr(v448 + 1, v447));
            }
            v451 = *(const void **)(v440 + 48);
            v449 = v440 + 48;
            v450 = v451;
            v452 = *(char *)(v449 + 23);
            v455 = *(const void **)(v445 + 48);
            v453 = v445 + 48;
            v454 = v455;
            v456 = *(char *)(v453 + 23);
            if (v456 >= 0)
              v457 = *(unsigned __int8 *)(v453 + 23);
            else
              v457 = *(_QWORD *)(v453 + 8);
            if (v456 >= 0)
              v458 = (const void *)v453;
            else
              v458 = v454;
            if (v452 >= 0)
              v459 = *(unsigned __int8 *)(v449 + 23);
            else
              v459 = *(_QWORD *)(v449 + 8);
            if (v452 >= 0)
              v460 = (const void *)v449;
            else
              v460 = v450;
            if (v459 >= v457)
              v461 = v457;
            else
              v461 = v459;
            v462 = memcmp(v458, v460, v461);
            if (v462)
              v463 = v462 < 0;
            else
              v463 = v457 < v459;
            if (v446)
            {
              v464 = (unint64_t *)&v446->__shared_owners_;
              do
                v465 = __ldaxr(v464);
              while (__stlxr(v465 - 1, v464));
              if (!v465)
              {
                ((void (*)(std::__shared_weak_count *))v446->__on_zero_shared)(v446);
                std::__shared_weak_count::__release_weak(v446);
              }
            }
            v409 = v680;
            if (v441)
            {
              v466 = (unint64_t *)&v441->__shared_owners_;
              do
                v467 = __ldaxr(v466);
              while (__stlxr(v467 - 1, v466));
              if (!v467)
              {
                ((void (*)(std::__shared_weak_count *))v441->__on_zero_shared)(v441);
                std::__shared_weak_count::__release_weak(v441);
                v409 = v680;
              }
            }
            v7 = v685;
            if (!v463)
            {
              v687 = *(_OWORD *)v444;
              *v444 = 0;
              v444[1] = 0;
              while (1)
              {
                v468 = (uint64_t)v444;
                v444 = v411;
                sub_20BDE82DC(v468, (__int128 *)v411);
                if (v683 < v410)
                {
LABEL_754:
                  sub_20BDE82DC((uint64_t)v444, &v687);
                  v521 = (std::__shared_weak_count *)*((_QWORD *)&v687 + 1);
                  v409 = v680;
                  if (*((_QWORD *)&v687 + 1))
                  {
                    v522 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                    do
                      v523 = __ldaxr(v522);
                    while (__stlxr(v523 - 1, v522));
                    if (!v523)
                    {
                      ((void (*)(std::__shared_weak_count *))v521->__on_zero_shared)(v521);
                      std::__shared_weak_count::__release_weak(v521);
                      v409 = v680;
                    }
                  }
                  v7 = v685;
                  break;
                }
                v469 = 2 * v410;
                v410 = (2 * v410) | 1;
                v411 = &v685[2 * v410];
                v470 = v469 + 2;
                if (v469 + 2 < v9)
                {
                  v471 = *v411;
                  v472 = (std::__shared_weak_count *)v411[1];
                  if (v472)
                  {
                    v473 = (unint64_t *)&v472->__shared_owners_;
                    do
                      v474 = __ldxr(v473);
                    while (__stxr(v474 + 1, v473));
                  }
                  v475 = v411[2];
                  v476 = (std::__shared_weak_count *)v411[3];
                  if (v476)
                  {
                    v477 = (unint64_t *)&v476->__shared_owners_;
                    do
                      v478 = __ldxr(v477);
                    while (__stxr(v478 + 1, v477));
                  }
                  v481 = *(const void **)(v471 + 48);
                  v479 = v471 + 48;
                  v480 = v481;
                  v482 = *(char *)(v479 + 23);
                  v485 = *(const void **)(v475 + 48);
                  v483 = v475 + 48;
                  v484 = v485;
                  v486 = *(char *)(v483 + 23);
                  if (v486 >= 0)
                    v487 = *(unsigned __int8 *)(v483 + 23);
                  else
                    v487 = *(_QWORD *)(v483 + 8);
                  if (v486 >= 0)
                    v488 = (const void *)v483;
                  else
                    v488 = v484;
                  if (v482 >= 0)
                    v489 = *(unsigned __int8 *)(v479 + 23);
                  else
                    v489 = *(_QWORD *)(v479 + 8);
                  if (v482 >= 0)
                    v490 = (const void *)v479;
                  else
                    v490 = v480;
                  if (v489 >= v487)
                    v491 = v487;
                  else
                    v491 = v489;
                  v492 = memcmp(v488, v490, v491);
                  if (v492)
                    v493 = v492 < 0;
                  else
                    v493 = v487 < v489;
                  if (!v476)
                    goto LABEL_708;
                  v494 = (unint64_t *)&v476->__shared_owners_;
                  do
                    v495 = __ldaxr(v494);
                  while (__stlxr(v495 - 1, v494));
                  if (!v495)
                  {
                    ((void (*)(std::__shared_weak_count *))v476->__on_zero_shared)(v476);
                    std::__shared_weak_count::__release_weak(v476);
                    if (!v472)
                      goto LABEL_712;
                  }
                  else
                  {
LABEL_708:
                    if (!v472)
                      goto LABEL_712;
                  }
                  v496 = (unint64_t *)&v472->__shared_owners_;
                  do
                    v497 = __ldaxr(v496);
                  while (__stlxr(v497 - 1, v496));
                  if (v497)
                  {
LABEL_712:
                    if (!v493)
                      goto LABEL_714;
LABEL_713:
                    v411 += 2;
                    v410 = v470;
                    goto LABEL_714;
                  }
                  ((void (*)(std::__shared_weak_count *))v472->__on_zero_shared)(v472);
                  std::__shared_weak_count::__release_weak(v472);
                  if (v493)
                    goto LABEL_713;
                }
LABEL_714:
                v498 = *v411;
                v499 = (std::__shared_weak_count *)v411[1];
                if (v499)
                {
                  v500 = (unint64_t *)&v499->__shared_owners_;
                  do
                    v501 = __ldxr(v500);
                  while (__stxr(v501 + 1, v500));
                }
                v502 = v687;
                if (*((_QWORD *)&v687 + 1))
                {
                  v503 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                  do
                    v504 = __ldxr(v503);
                  while (__stxr(v504 + 1, v503));
                }
                v507 = *(const void **)(v498 + 48);
                v505 = v498 + 48;
                v506 = v507;
                v508 = *(char *)(v505 + 23);
                v509 = *(char *)(v502 + 71);
                if (v509 >= 0)
                  v510 = *(unsigned __int8 *)(v502 + 71);
                else
                  v510 = *(_QWORD *)(v502 + 56);
                if (v509 >= 0)
                  v511 = (const void *)(v502 + 48);
                else
                  v511 = *(const void **)(v502 + 48);
                if (v508 >= 0)
                  v512 = *(unsigned __int8 *)(v505 + 23);
                else
                  v512 = *(_QWORD *)(v505 + 8);
                if (v508 >= 0)
                  v513 = (const void *)v505;
                else
                  v513 = v506;
                if (v512 >= v510)
                  v514 = v510;
                else
                  v514 = v512;
                v515 = memcmp(v511, v513, v514);
                if (v515)
                  v516 = v515 < 0;
                else
                  v516 = v510 < v512;
                if (!*((_QWORD *)&v502 + 1))
                  goto LABEL_742;
                v517 = (unint64_t *)(*((_QWORD *)&v502 + 1) + 8);
                do
                  v518 = __ldaxr(v517);
                while (__stlxr(v518 - 1, v517));
                if (!v518)
                {
                  (*(void (**)(_QWORD))(**((_QWORD **)&v502 + 1) + 16))(*((_QWORD *)&v502 + 1));
                  std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v502 + 1));
                  if (v499)
                  {
LABEL_743:
                    v519 = (unint64_t *)&v499->__shared_owners_;
                    do
                      v520 = __ldaxr(v519);
                    while (__stlxr(v520 - 1, v519));
                    if (!v520)
                    {
                      ((void (*)(std::__shared_weak_count *))v499->__on_zero_shared)(v499);
                      std::__shared_weak_count::__release_weak(v499);
                    }
                  }
                }
                else
                {
LABEL_742:
                  if (v499)
                    goto LABEL_743;
                }
                if (v516)
                  goto LABEL_754;
              }
            }
LABEL_760:
            v408 = v409 - 1;
            if (!v409)
            {
              v524 = v678 >> 4;
              while (1)
              {
                v525 = 0;
                v686 = *(_OWORD *)v7;
                *v7 = 0;
                v7[1] = 0;
                v526 = (unint64_t)(v524 - 2) >> 1;
                v527 = (uint64_t)v7;
                v684 = v524;
                do
                {
                  v528 = v527;
                  v527 += 16 * (v525 + 1);
                  v529 = 2 * v525;
                  v525 = (2 * v525) | 1;
                  v530 = v529 + 2;
                  if (v529 + 2 >= v524)
                    goto LABEL_801;
                  v531 = *(_QWORD *)v527;
                  v532 = *(std::__shared_weak_count **)(v527 + 8);
                  if (v532)
                  {
                    v533 = (unint64_t *)&v532->__shared_owners_;
                    do
                      v534 = __ldxr(v533);
                    while (__stxr(v534 + 1, v533));
                  }
                  v535 = *(_QWORD *)(v527 + 16);
                  v536 = *(std::__shared_weak_count **)(v527 + 24);
                  if (v536)
                  {
                    v537 = (unint64_t *)&v536->__shared_owners_;
                    do
                      v538 = __ldxr(v537);
                    while (__stxr(v538 + 1, v537));
                  }
                  v541 = *(const void **)(v531 + 48);
                  v539 = v531 + 48;
                  v540 = v541;
                  v542 = *(char *)(v539 + 23);
                  v545 = *(const void **)(v535 + 48);
                  v543 = v535 + 48;
                  v544 = v545;
                  v546 = *(char *)(v543 + 23);
                  if (v546 >= 0)
                    v547 = *(unsigned __int8 *)(v543 + 23);
                  else
                    v547 = *(_QWORD *)(v543 + 8);
                  if (v546 >= 0)
                    v548 = (const void *)v543;
                  else
                    v548 = v544;
                  if (v542 >= 0)
                    v549 = *(unsigned __int8 *)(v539 + 23);
                  else
                    v549 = *(_QWORD *)(v539 + 8);
                  if (v542 >= 0)
                    v550 = (const void *)v539;
                  else
                    v550 = v540;
                  if (v549 >= v547)
                    v551 = v547;
                  else
                    v551 = v549;
                  v552 = memcmp(v548, v550, v551);
                  if (v552)
                    v553 = v552 < 0;
                  else
                    v553 = v547 < v549;
                  if (v536)
                  {
                    v554 = (unint64_t *)&v536->__shared_owners_;
                    do
                      v555 = __ldaxr(v554);
                    while (__stlxr(v555 - 1, v554));
                    if (!v555)
                    {
                      ((void (*)(std::__shared_weak_count *))v536->__on_zero_shared)(v536);
                      std::__shared_weak_count::__release_weak(v536);
                    }
                  }
                  v524 = v684;
                  if (!v532)
                    goto LABEL_799;
                  v556 = (unint64_t *)&v532->__shared_owners_;
                  do
                    v557 = __ldaxr(v556);
                  while (__stlxr(v557 - 1, v556));
                  if (v557)
                  {
LABEL_799:
                    if (!v553)
                      goto LABEL_801;
LABEL_800:
                    v527 += 16;
                    v525 = v530;
                    goto LABEL_801;
                  }
                  ((void (*)(std::__shared_weak_count *))v532->__on_zero_shared)(v532);
                  std::__shared_weak_count::__release_weak(v532);
                  if (v553)
                    goto LABEL_800;
LABEL_801:
                  sub_20BDE82DC(v528, (__int128 *)v527);
                }
                while (v525 <= v526);
                v558 = (__int128 *)(a2 - 16);
                v559 = v527 == (_QWORD)(a2 - 16);
                a2 -= 16;
                if (v559)
                {
                  sub_20BDE82DC(v527, &v686);
                  goto LABEL_885;
                }
                sub_20BDE82DC(v527, v558);
                sub_20BDE82DC((uint64_t)v558, &v686);
                v7 = v685;
                v560 = v527 - (_QWORD)v685 + 16;
                if (v560 >= 17)
                {
                  v561 = (((unint64_t)v560 >> 4) - 2) >> 1;
                  v562 = &v685[2 * v561];
                  v563 = *v562;
                  v564 = (std::__shared_weak_count *)v562[1];
                  if (v564)
                  {
                    v565 = (unint64_t *)&v564->__shared_owners_;
                    do
                      v566 = __ldxr(v565);
                    while (__stxr(v566 + 1, v565));
                  }
                  v567 = *(_QWORD *)v527;
                  v568 = *(std::__shared_weak_count **)(v527 + 8);
                  if (v568)
                  {
                    v569 = (unint64_t *)&v568->__shared_owners_;
                    do
                      v570 = __ldxr(v569);
                    while (__stxr(v570 + 1, v569));
                  }
                  v573 = *(const void **)(v563 + 48);
                  v571 = v563 + 48;
                  v572 = v573;
                  v574 = *(char *)(v571 + 23);
                  v577 = *(const void **)(v567 + 48);
                  v575 = v567 + 48;
                  v576 = v577;
                  v578 = *(char *)(v575 + 23);
                  if (v578 >= 0)
                    v579 = *(unsigned __int8 *)(v575 + 23);
                  else
                    v579 = *(_QWORD *)(v575 + 8);
                  if (v578 >= 0)
                    v580 = (const void *)v575;
                  else
                    v580 = v576;
                  if (v574 >= 0)
                    v581 = *(unsigned __int8 *)(v571 + 23);
                  else
                    v581 = *(_QWORD *)(v571 + 8);
                  if (v574 >= 0)
                    v582 = (const void *)v571;
                  else
                    v582 = v572;
                  if (v581 >= v579)
                    v583 = v579;
                  else
                    v583 = v581;
                  v584 = memcmp(v580, v582, v583);
                  if (v584)
                    v585 = v584 < 0;
                  else
                    v585 = v579 < v581;
                  if (v568)
                  {
                    v586 = (unint64_t *)&v568->__shared_owners_;
                    do
                      v587 = __ldaxr(v586);
                    while (__stlxr(v587 - 1, v586));
                    if (!v587)
                    {
                      ((void (*)(std::__shared_weak_count *))v568->__on_zero_shared)(v568);
                      std::__shared_weak_count::__release_weak(v568);
                    }
                  }
                  if (v564)
                  {
                    v588 = (unint64_t *)&v564->__shared_owners_;
                    do
                      v589 = __ldaxr(v588);
                    while (__stlxr(v589 - 1, v588));
                    if (!v589)
                    {
                      ((void (*)(std::__shared_weak_count *))v564->__on_zero_shared)(v564);
                      std::__shared_weak_count::__release_weak(v564);
                    }
                  }
                  v7 = v685;
                  if (v585)
                  {
                    v687 = *(_OWORD *)v527;
                    *(_QWORD *)v527 = 0;
                    *(_QWORD *)(v527 + 8) = 0;
                    while (1)
                    {
                      v590 = v527;
                      v527 = (uint64_t)v562;
                      sub_20BDE82DC(v590, (__int128 *)v562);
                      if (!v561)
                      {
LABEL_879:
                        sub_20BDE82DC(v527, &v687);
                        v614 = (std::__shared_weak_count *)*((_QWORD *)&v687 + 1);
                        if (*((_QWORD *)&v687 + 1))
                        {
                          v615 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                          do
                            v616 = __ldaxr(v615);
                          while (__stlxr(v616 - 1, v615));
                          if (!v616)
                          {
                            ((void (*)(std::__shared_weak_count *))v614->__on_zero_shared)(v614);
                            std::__shared_weak_count::__release_weak(v614);
                          }
                        }
LABEL_885:
                        v7 = v685;
                        break;
                      }
                      v561 = (v561 - 1) >> 1;
                      v562 = &v685[2 * v561];
                      v591 = *v562;
                      v592 = (std::__shared_weak_count *)v562[1];
                      if (v592)
                      {
                        v593 = (unint64_t *)&v592->__shared_owners_;
                        do
                          v594 = __ldxr(v593);
                        while (__stxr(v594 + 1, v593));
                      }
                      v595 = v687;
                      if (*((_QWORD *)&v687 + 1))
                      {
                        v596 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                        do
                          v597 = __ldxr(v596);
                        while (__stxr(v597 + 1, v596));
                      }
                      v600 = *(const void **)(v591 + 48);
                      v598 = v591 + 48;
                      v599 = v600;
                      v601 = *(char *)(v598 + 23);
                      v602 = *(char *)(v595 + 71);
                      if (v602 >= 0)
                        v603 = *(unsigned __int8 *)(v595 + 71);
                      else
                        v603 = *(_QWORD *)(v595 + 56);
                      if (v602 >= 0)
                        v604 = (const void *)(v595 + 48);
                      else
                        v604 = *(const void **)(v595 + 48);
                      if (v601 >= 0)
                        v605 = *(unsigned __int8 *)(v598 + 23);
                      else
                        v605 = *(_QWORD *)(v598 + 8);
                      if (v601 >= 0)
                        v606 = (const void *)v598;
                      else
                        v606 = v599;
                      if (v605 >= v603)
                        v607 = v603;
                      else
                        v607 = v605;
                      v608 = memcmp(v604, v606, v607);
                      if (v608)
                        v609 = v608 < 0;
                      else
                        v609 = v603 < v605;
                      if (!*((_QWORD *)&v595 + 1))
                        goto LABEL_872;
                      v610 = (unint64_t *)(*((_QWORD *)&v595 + 1) + 8);
                      do
                        v611 = __ldaxr(v610);
                      while (__stlxr(v611 - 1, v610));
                      if (!v611)
                      {
                        (*(void (**)(_QWORD))(**((_QWORD **)&v595 + 1) + 16))(*((_QWORD *)&v595 + 1));
                        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v595 + 1));
                        if (v592)
                        {
LABEL_873:
                          v612 = (unint64_t *)&v592->__shared_owners_;
                          do
                            v613 = __ldaxr(v612);
                          while (__stlxr(v613 - 1, v612));
                          if (!v613)
                          {
                            ((void (*)(std::__shared_weak_count *))v592->__on_zero_shared)(v592);
                            std::__shared_weak_count::__release_weak(v592);
                          }
                        }
                      }
                      else
                      {
LABEL_872:
                        if (v592)
                          goto LABEL_873;
                      }
                      if (!v609)
                        goto LABEL_879;
                    }
                  }
                }
                v617 = (std::__shared_weak_count *)*((_QWORD *)&v686 + 1);
                if (*((_QWORD *)&v686 + 1))
                {
                  v618 = (unint64_t *)(*((_QWORD *)&v686 + 1) + 8);
                  do
                    v619 = __ldaxr(v618);
                  while (__stlxr(v619 - 1, v618));
                  v7 = v685;
                  if (!v619)
                  {
                    ((void (*)(std::__shared_weak_count *))v617->__on_zero_shared)(v617);
                    std::__shared_weak_count::__release_weak(v617);
                    v7 = v685;
                  }
                }
                v524 = v684 - 1;
                if (v684 <= 2)
                  return;
              }
            }
          }
          ((void (*)(std::__shared_weak_count *))v414->__on_zero_shared)(v414);
          std::__shared_weak_count::__release_weak(v414);
          v409 = v680;
          if (!v435)
            goto LABEL_642;
LABEL_641:
          v411 += 2;
          v410 = v412;
          goto LABEL_642;
        }
        v10 = (unint64_t)v9 >> 1;
        v11 = &i[2 * ((unint64_t)v9 >> 1)];
        if ((unint64_t)v8 < 0x801)
        {
          sub_20C954C34(v11, i, v679);
          v13 = i;
        }
        else
        {
          sub_20C954C34(i, v11, v679);
          sub_20C954C34(i + 2, v11 - 2, (_QWORD *)a2 - 4);
          v12 = &i[2 * v10 + 2];
          sub_20C954C34(v685 + 4, v12, (_QWORD *)a2 - 6);
          sub_20C954C34(v11 - 2, v11, v12);
          v13 = v685;
          v14 = *(_OWORD *)v685;
          *(_OWORD *)v685 = *(_OWORD *)v11;
          *(_OWORD *)v11 = v14;
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v15 = *(v13 - 2);
          v16 = (std::__shared_weak_count *)*(v13 - 1);
          if (v16)
          {
            v17 = (unint64_t *)&v16->__shared_owners_;
            do
              v18 = __ldxr(v17);
            while (__stxr(v18 + 1, v17));
          }
          v19 = *v685;
          v20 = (std::__shared_weak_count *)v685[1];
          if (v20)
          {
            v21 = (unint64_t *)&v20->__shared_owners_;
            do
              v22 = __ldxr(v21);
            while (__stxr(v22 + 1, v21));
          }
          v25 = *(const void **)(v15 + 48);
          v23 = v15 + 48;
          v24 = v25;
          v26 = *(char *)(v23 + 23);
          v29 = *(const void **)(v19 + 48);
          v27 = v19 + 48;
          v28 = v29;
          v30 = *(char *)(v27 + 23);
          if (v30 >= 0)
            v31 = *(unsigned __int8 *)(v27 + 23);
          else
            v31 = *(_QWORD *)(v27 + 8);
          if (v30 >= 0)
            v32 = (const void *)v27;
          else
            v32 = v28;
          if (v26 >= 0)
            v33 = *(unsigned __int8 *)(v23 + 23);
          else
            v33 = *(_QWORD *)(v23 + 8);
          if (v26 >= 0)
            v34 = (const void *)v23;
          else
            v34 = v24;
          if (v33 >= v31)
            v35 = v31;
          else
            v35 = v33;
          v36 = memcmp(v32, v34, v35);
          if (v36)
            v37 = v36 >= 0;
          else
            v37 = v31 >= v33;
          if (!v20)
            goto LABEL_37;
          v38 = (unint64_t *)&v20->__shared_owners_;
          do
            v39 = __ldaxr(v38);
          while (__stlxr(v39 - 1, v38));
          if (!v39)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
            if (!v16)
              goto LABEL_41;
          }
          else
          {
LABEL_37:
            if (!v16)
              goto LABEL_41;
          }
          v40 = (unint64_t *)&v16->__shared_owners_;
          do
            v41 = __ldaxr(v40);
          while (__stlxr(v41 - 1, v40));
          if (v41)
          {
LABEL_41:
            v13 = v685;
            if (!v37)
              goto LABEL_42;
            goto LABEL_244;
          }
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
          v13 = v685;
          if (!v37)
            goto LABEL_42;
LABEL_244:
          v171 = *v13;
          v172 = (std::__shared_weak_count *)v13[1];
          *(_QWORD *)&v687 = *v13;
          *((_QWORD *)&v687 + 1) = v172;
          *v13 = 0;
          v13[1] = 0;
          if (v172)
          {
            v173 = (unint64_t *)&v172->__shared_owners_;
            do
              v174 = __ldxr(v173);
            while (__stxr(v174 + 1, v173));
          }
          v175 = *((_QWORD *)a2 - 2);
          v176 = (std::__shared_weak_count *)*((_QWORD *)a2 - 1);
          if (v176)
          {
            v177 = (unint64_t *)&v176->__shared_owners_;
            do
              v178 = __ldxr(v177);
            while (__stxr(v178 + 1, v177));
          }
          v181 = *(const void **)(v171 + 48);
          v179 = v171 + 48;
          v180 = v181;
          v182 = *(char *)(v179 + 23);
          v185 = *(const void **)(v175 + 48);
          v183 = v175 + 48;
          v184 = v185;
          v186 = *(char *)(v183 + 23);
          if (v186 >= 0)
            v187 = *(unsigned __int8 *)(v183 + 23);
          else
            v187 = *(_QWORD *)(v183 + 8);
          if (v186 >= 0)
            v188 = (const void *)v183;
          else
            v188 = v184;
          if (v182 >= 0)
            v189 = *(unsigned __int8 *)(v179 + 23);
          else
            v189 = *(_QWORD *)(v179 + 8);
          if (v182 >= 0)
            v190 = (const void *)v179;
          else
            v190 = v180;
          if (v189 >= v187)
            v191 = v187;
          else
            v191 = v189;
          v192 = memcmp(v188, v190, v191);
          if (v192)
            v193 = v192 < 0;
          else
            v193 = v187 < v189;
          if (v176)
          {
            v194 = (unint64_t *)&v176->__shared_owners_;
            do
              v195 = __ldaxr(v194);
            while (__stlxr(v195 - 1, v194));
            if (!v195)
            {
              ((void (*)(std::__shared_weak_count *))v176->__on_zero_shared)(v176);
              std::__shared_weak_count::__release_weak(v176);
            }
          }
          if (v172)
          {
            v196 = (unint64_t *)&v172->__shared_owners_;
            do
              v197 = __ldaxr(v196);
            while (__stlxr(v197 - 1, v196));
            if (!v197)
            {
              ((void (*)(std::__shared_weak_count *))v172->__on_zero_shared)(v172);
              std::__shared_weak_count::__release_weak(v172);
            }
          }
          i = v685;
          if (!v193)
          {
            v221 = v685;
            for (i = v685 + 2; ; i += 2)
            {
              if (i >= (uint64_t *)a2)
                goto LABEL_355;
              v222 = i;
              v223 = v687;
              if (*((_QWORD *)&v687 + 1))
              {
                v224 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                do
                  v225 = __ldxr(v224);
                while (__stxr(v225 + 1, v224));
              }
              v226 = *i;
              v227 = (std::__shared_weak_count *)v221[3];
              if (v227)
              {
                v228 = (unint64_t *)&v227->__shared_owners_;
                do
                  v229 = __ldxr(v228);
                while (__stxr(v229 + 1, v228));
              }
              v230 = *(char *)(v223 + 71);
              v233 = *(const void **)(v226 + 48);
              v231 = v226 + 48;
              v232 = v233;
              v234 = *(char *)(v231 + 23);
              if (v234 >= 0)
                v235 = *(unsigned __int8 *)(v231 + 23);
              else
                v235 = *(_QWORD *)(v231 + 8);
              if (v234 >= 0)
                v236 = (const void *)v231;
              else
                v236 = v232;
              if (v230 >= 0)
                v237 = *(unsigned __int8 *)(v223 + 71);
              else
                v237 = *(_QWORD *)(v223 + 56);
              if (v230 >= 0)
                v238 = (const void *)(v223 + 48);
              else
                v238 = *(const void **)(v223 + 48);
              if (v237 >= v235)
                v239 = v235;
              else
                v239 = v237;
              v240 = memcmp(v236, v238, v239);
              if (v240)
                v241 = v240 >= 0;
              else
                v241 = v235 >= v237;
              if (!v227)
                goto LABEL_345;
              v242 = (unint64_t *)&v227->__shared_owners_;
              do
                v243 = __ldaxr(v242);
              while (__stlxr(v243 - 1, v242));
              if (!v243)
              {
                ((void (*)(std::__shared_weak_count *))v227->__on_zero_shared)(v227);
                std::__shared_weak_count::__release_weak(v227);
                if (!*((_QWORD *)&v223 + 1))
                  goto LABEL_349;
              }
              else
              {
LABEL_345:
                if (!*((_QWORD *)&v223 + 1))
                  goto LABEL_349;
              }
              v244 = (unint64_t *)(*((_QWORD *)&v223 + 1) + 8);
              do
                v245 = __ldaxr(v244);
              while (__stlxr(v245 - 1, v244));
              if (v245)
              {
LABEL_349:
                if (!v241)
                  goto LABEL_355;
                goto LABEL_354;
              }
              (*(void (**)(_QWORD))(**((_QWORD **)&v223 + 1) + 16))(*((_QWORD *)&v223 + 1));
              std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v223 + 1));
              if (!v241)
                goto LABEL_355;
LABEL_354:
              v221 = v222;
            }
          }
          do
          {
            v198 = v687;
            if (*((_QWORD *)&v687 + 1))
            {
              v199 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
              do
                v200 = __ldxr(v199);
              while (__stxr(v200 + 1, v199));
            }
            v201 = i[2];
            v202 = (std::__shared_weak_count *)i[3];
            if (v202)
            {
              v203 = (unint64_t *)&v202->__shared_owners_;
              do
                v204 = __ldxr(v203);
              while (__stxr(v204 + 1, v203));
            }
            v205 = *(char *)(v198 + 71);
            v208 = *(const void **)(v201 + 48);
            v206 = v201 + 48;
            v207 = v208;
            v209 = *(char *)(v206 + 23);
            if (v209 >= 0)
              v210 = *(unsigned __int8 *)(v206 + 23);
            else
              v210 = *(_QWORD *)(v206 + 8);
            if (v209 >= 0)
              v211 = (const void *)v206;
            else
              v211 = v207;
            if (v205 >= 0)
              v212 = *(unsigned __int8 *)(v198 + 71);
            else
              v212 = *(_QWORD *)(v198 + 56);
            if (v205 >= 0)
              v213 = (const void *)(v198 + 48);
            else
              v213 = *(const void **)(v198 + 48);
            if (v212 >= v210)
              v214 = v210;
            else
              v214 = v212;
            v215 = memcmp(v211, v213, v214);
            if (v215)
              v216 = v215 < 0;
            else
              v216 = v210 < v212;
            if (v202)
            {
              v217 = (unint64_t *)&v202->__shared_owners_;
              do
                v218 = __ldaxr(v217);
              while (__stlxr(v218 - 1, v217));
              if (!v218)
              {
                ((void (*)(std::__shared_weak_count *))v202->__on_zero_shared)(v202);
                std::__shared_weak_count::__release_weak(v202);
              }
            }
            if (*((_QWORD *)&v198 + 1))
            {
              v219 = (unint64_t *)(*((_QWORD *)&v198 + 1) + 8);
              do
                v220 = __ldaxr(v219);
              while (__stlxr(v220 - 1, v219));
              if (!v220)
              {
                (*(void (**)(_QWORD))(**((_QWORD **)&v198 + 1) + 16))(*((_QWORD *)&v198 + 1));
                std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v198 + 1));
              }
            }
            i += 2;
          }
          while (!v216);
LABEL_355:
          v246 = a2;
          if (i < (uint64_t *)a2)
          {
            v246 = a2;
            do
            {
              v247 = v687;
              if (*((_QWORD *)&v687 + 1))
              {
                v248 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                do
                  v249 = __ldxr(v248);
                while (__stxr(v249 + 1, v248));
              }
              v250 = *((_QWORD *)v246 - 2);
              v251 = (std::__shared_weak_count *)*((_QWORD *)v246 - 1);
              if (v251)
              {
                v252 = (unint64_t *)&v251->__shared_owners_;
                do
                  v253 = __ldxr(v252);
                while (__stxr(v253 + 1, v252));
              }
              v254 = *(char *)(v247 + 71);
              v257 = *(const void **)(v250 + 48);
              v255 = v250 + 48;
              v256 = v257;
              v258 = *(char *)(v255 + 23);
              if (v258 >= 0)
                v259 = *(unsigned __int8 *)(v255 + 23);
              else
                v259 = *(_QWORD *)(v255 + 8);
              if (v258 >= 0)
                v260 = (const void *)v255;
              else
                v260 = v256;
              if (v254 >= 0)
                v261 = *(unsigned __int8 *)(v247 + 71);
              else
                v261 = *(_QWORD *)(v247 + 56);
              if (v254 >= 0)
                v262 = (const void *)(v247 + 48);
              else
                v262 = *(const void **)(v247 + 48);
              if (v261 >= v259)
                v263 = v259;
              else
                v263 = v261;
              v264 = memcmp(v260, v262, v263);
              if (v264)
                v265 = v264 < 0;
              else
                v265 = v259 < v261;
              if (v251)
              {
                v266 = (unint64_t *)&v251->__shared_owners_;
                do
                  v267 = __ldaxr(v266);
                while (__stlxr(v267 - 1, v266));
                if (!v267)
                {
                  ((void (*)(std::__shared_weak_count *))v251->__on_zero_shared)(v251);
                  std::__shared_weak_count::__release_weak(v251);
                }
              }
              if (*((_QWORD *)&v247 + 1))
              {
                v268 = (unint64_t *)(*((_QWORD *)&v247 + 1) + 8);
                do
                  v269 = __ldaxr(v268);
                while (__stlxr(v269 - 1, v268));
                if (!v269)
                {
                  (*(void (**)(_QWORD))(**((_QWORD **)&v247 + 1) + 16))(*((_QWORD *)&v247 + 1));
                  std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v247 + 1));
                }
              }
              v246 -= 16;
            }
            while (v265);
          }
LABEL_464:
          if (i < (uint64_t *)v246)
          {
            v270 = *i;
            *i = *(_QWORD *)v246;
            *(_QWORD *)v246 = v270;
            v271 = i[1];
            i[1] = *((_QWORD *)v246 + 1);
            *((_QWORD *)v246 + 1) = v271;
            while (1)
            {
              v272 = v687;
              if (*((_QWORD *)&v687 + 1))
              {
                v273 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                do
                  v274 = __ldxr(v273);
                while (__stxr(v274 + 1, v273));
              }
              v275 = i[2];
              v276 = (std::__shared_weak_count *)i[3];
              if (v276)
              {
                v277 = (unint64_t *)&v276->__shared_owners_;
                do
                  v278 = __ldxr(v277);
                while (__stxr(v278 + 1, v277));
              }
              v279 = *(char *)(v272 + 71);
              v282 = *(const void **)(v275 + 48);
              v280 = v275 + 48;
              v281 = v282;
              v283 = *(char *)(v280 + 23);
              if (v283 >= 0)
                v284 = *(unsigned __int8 *)(v280 + 23);
              else
                v284 = *(_QWORD *)(v280 + 8);
              if (v283 >= 0)
                v285 = (const void *)v280;
              else
                v285 = v281;
              if (v279 >= 0)
                v286 = *(unsigned __int8 *)(v272 + 71);
              else
                v286 = *(_QWORD *)(v272 + 56);
              if (v279 >= 0)
                v287 = (const void *)(v272 + 48);
              else
                v287 = *(const void **)(v272 + 48);
              if (v286 >= v284)
                v288 = v284;
              else
                v288 = v286;
              v289 = memcmp(v285, v287, v288);
              if (v289)
                v290 = v289 < 0;
              else
                v290 = v284 < v286;
              if (!v276)
                goto LABEL_422;
              v291 = (unint64_t *)&v276->__shared_owners_;
              do
                v292 = __ldaxr(v291);
              while (__stlxr(v292 - 1, v291));
              if (!v292)
              {
                ((void (*)(std::__shared_weak_count *))v276->__on_zero_shared)(v276);
                std::__shared_weak_count::__release_weak(v276);
                if (*((_QWORD *)&v272 + 1))
                {
LABEL_423:
                  v293 = (unint64_t *)(*((_QWORD *)&v272 + 1) + 8);
                  do
                    v294 = __ldaxr(v293);
                  while (__stlxr(v294 - 1, v293));
                  if (!v294)
                  {
                    (*(void (**)(_QWORD))(**((_QWORD **)&v272 + 1) + 16))(*((_QWORD *)&v272 + 1));
                    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v272 + 1));
                  }
                }
              }
              else
              {
LABEL_422:
                if (*((_QWORD *)&v272 + 1))
                  goto LABEL_423;
              }
              i += 2;
              if (v290)
              {
                while (1)
                {
                  v295 = v687;
                  if (*((_QWORD *)&v687 + 1))
                  {
                    v296 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
                    do
                      v297 = __ldxr(v296);
                    while (__stxr(v297 + 1, v296));
                  }
                  v298 = *((_QWORD *)v246 - 2);
                  v299 = (std::__shared_weak_count *)*((_QWORD *)v246 - 1);
                  if (v299)
                  {
                    v300 = (unint64_t *)&v299->__shared_owners_;
                    do
                      v301 = __ldxr(v300);
                    while (__stxr(v301 + 1, v300));
                  }
                  v302 = *(char *)(v295 + 71);
                  v305 = *(const void **)(v298 + 48);
                  v303 = v298 + 48;
                  v304 = v305;
                  v306 = *(char *)(v303 + 23);
                  if (v306 >= 0)
                    v307 = *(unsigned __int8 *)(v303 + 23);
                  else
                    v307 = *(_QWORD *)(v303 + 8);
                  if (v306 >= 0)
                    v308 = (const void *)v303;
                  else
                    v308 = v304;
                  if (v302 >= 0)
                    v309 = *(unsigned __int8 *)(v295 + 71);
                  else
                    v309 = *(_QWORD *)(v295 + 56);
                  if (v302 >= 0)
                    v310 = (const void *)(v295 + 48);
                  else
                    v310 = *(const void **)(v295 + 48);
                  if (v309 >= v307)
                    v311 = v307;
                  else
                    v311 = v309;
                  v312 = memcmp(v308, v310, v311);
                  if (v312)
                    v313 = v312 < 0;
                  else
                    v313 = v307 < v309;
                  if (!v299)
                    goto LABEL_457;
                  v314 = (unint64_t *)&v299->__shared_owners_;
                  do
                    v315 = __ldaxr(v314);
                  while (__stlxr(v315 - 1, v314));
                  if (!v315)
                  {
                    ((void (*)(std::__shared_weak_count *))v299->__on_zero_shared)(v299);
                    std::__shared_weak_count::__release_weak(v299);
                    if (*((_QWORD *)&v295 + 1))
                    {
LABEL_458:
                      v316 = (unint64_t *)(*((_QWORD *)&v295 + 1) + 8);
                      do
                        v317 = __ldaxr(v316);
                      while (__stlxr(v317 - 1, v316));
                      if (!v317)
                      {
                        (*(void (**)(_QWORD))(**((_QWORD **)&v295 + 1) + 16))(*((_QWORD *)&v295 + 1));
                        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v295 + 1));
                      }
                    }
                  }
                  else
                  {
LABEL_457:
                    if (*((_QWORD *)&v295 + 1))
                      goto LABEL_458;
                  }
                  v246 -= 16;
                  if (!v313)
                    goto LABEL_464;
                }
              }
            }
          }
          if (i - 2 != v685)
            sub_20BDE82DC((uint64_t)v685, (__int128 *)i - 1);
          sub_20BDE82DC((uint64_t)(i - 2), &v687);
          v318 = (std::__shared_weak_count *)*((_QWORD *)&v687 + 1);
          v6 = a2;
          if (*((_QWORD *)&v687 + 1))
          {
            v319 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
            do
              v320 = __ldaxr(v319);
            while (__stlxr(v320 - 1, v319));
            if (!v320)
            {
              ((void (*)(std::__shared_weak_count *))v318->__on_zero_shared)(v318);
              std::__shared_weak_count::__release_weak(v318);
            }
          }
          a4 = 0;
          continue;
        }
LABEL_42:
        v687 = *(_OWORD *)v13;
        *v13 = 0;
        v13[1] = 0;
        v42 = v13;
        do
        {
          v43 = (uint64_t)v42;
          v44 = v42[2];
          v45 = (std::__shared_weak_count *)v42[3];
          v42 += 2;
          if (v45)
          {
            v46 = (unint64_t *)&v45->__shared_owners_;
            do
              v47 = __ldxr(v46);
            while (__stxr(v47 + 1, v46));
          }
          v48 = v687;
          if (*((_QWORD *)&v687 + 1))
          {
            v49 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
            do
              v50 = __ldxr(v49);
            while (__stxr(v50 + 1, v49));
          }
          v53 = *(const void **)(v44 + 48);
          v51 = v44 + 48;
          v52 = v53;
          v54 = *(char *)(v51 + 23);
          v55 = *(char *)(v48 + 71);
          if (v55 >= 0)
            v56 = *(unsigned __int8 *)(v48 + 71);
          else
            v56 = *(_QWORD *)(v48 + 56);
          if (v55 >= 0)
            v57 = (const void *)(v48 + 48);
          else
            v57 = *(const void **)(v48 + 48);
          if (v54 >= 0)
            v58 = *(unsigned __int8 *)(v51 + 23);
          else
            v58 = *(_QWORD *)(v51 + 8);
          if (v54 >= 0)
            v59 = (const void *)v51;
          else
            v59 = v52;
          if (v58 >= v56)
            v60 = v56;
          else
            v60 = v58;
          v61 = memcmp(v57, v59, v60);
          if (v61)
            v62 = v61 < 0;
          else
            v62 = v56 < v58;
          if (!*((_QWORD *)&v48 + 1))
            goto LABEL_71;
          v63 = (unint64_t *)(*((_QWORD *)&v48 + 1) + 8);
          do
            v64 = __ldaxr(v63);
          while (__stlxr(v64 - 1, v63));
          if (!v64)
          {
            (*(void (**)(_QWORD))(**((_QWORD **)&v48 + 1) + 16))(*((_QWORD *)&v48 + 1));
            std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v48 + 1));
            if (!v45)
              continue;
          }
          else
          {
LABEL_71:
            if (!v45)
              continue;
          }
          v65 = (unint64_t *)&v45->__shared_owners_;
          do
            v66 = __ldaxr(v65);
          while (__stlxr(v66 - 1, v65));
          if (!v66)
          {
            ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
            std::__shared_weak_count::__release_weak(v45);
          }
        }
        while (v62);
        v67 = a2;
        if ((uint64_t *)v43 != v685)
        {
          while (1)
          {
            v68 = *((_QWORD *)v67 - 2);
            v69 = (std::__shared_weak_count *)*((_QWORD *)v67 - 1);
            v67 -= 16;
            if (v69)
            {
              v70 = (unint64_t *)&v69->__shared_owners_;
              do
                v71 = __ldxr(v70);
              while (__stxr(v71 + 1, v70));
            }
            v72 = v687;
            if (*((_QWORD *)&v687 + 1))
            {
              v73 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
              do
                v74 = __ldxr(v73);
              while (__stxr(v74 + 1, v73));
            }
            v77 = *(const void **)(v68 + 48);
            v75 = v68 + 48;
            v76 = v77;
            v78 = *(char *)(v75 + 23);
            v79 = *(char *)(v72 + 71);
            if (v79 >= 0)
              v80 = *(unsigned __int8 *)(v72 + 71);
            else
              v80 = *(_QWORD *)(v72 + 56);
            if (v79 >= 0)
              v81 = (const void *)(v72 + 48);
            else
              v81 = *(const void **)(v72 + 48);
            if (v78 >= 0)
              v82 = *(unsigned __int8 *)(v75 + 23);
            else
              v82 = *(_QWORD *)(v75 + 8);
            if (v78 >= 0)
              v83 = (const void *)v75;
            else
              v83 = v76;
            if (v82 >= v80)
              v84 = v80;
            else
              v84 = v82;
            v85 = memcmp(v81, v83, v84);
            if (v85)
              v86 = v85 < 0;
            else
              v86 = v80 < v82;
            if (!*((_QWORD *)&v72 + 1))
              goto LABEL_107;
            v87 = (unint64_t *)(*((_QWORD *)&v72 + 1) + 8);
            do
              v88 = __ldaxr(v87);
            while (__stlxr(v88 - 1, v87));
            if (!v88)
            {
              (*(void (**)(_QWORD))(**((_QWORD **)&v72 + 1) + 16))(*((_QWORD *)&v72 + 1));
              std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v72 + 1));
              if (v69)
              {
LABEL_108:
                v89 = (unint64_t *)&v69->__shared_owners_;
                do
                  v90 = __ldaxr(v89);
                while (__stlxr(v90 - 1, v89));
                if (!v90)
                {
                  ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
                  std::__shared_weak_count::__release_weak(v69);
                }
              }
            }
            else
            {
LABEL_107:
              if (v69)
                goto LABEL_108;
            }
            if (v86)
              goto LABEL_155;
          }
        }
        v67 = a2;
        if (v42 < (uint64_t *)a2)
        {
          v67 = a2;
          do
          {
            v91 = *((_QWORD *)v67 - 2);
            v92 = (std::__shared_weak_count *)*((_QWORD *)v67 - 1);
            v67 -= 16;
            if (v92)
            {
              v93 = (unint64_t *)&v92->__shared_owners_;
              do
                v94 = __ldxr(v93);
              while (__stxr(v94 + 1, v93));
            }
            v95 = v687;
            if (*((_QWORD *)&v687 + 1))
            {
              v96 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
              do
                v97 = __ldxr(v96);
              while (__stxr(v97 + 1, v96));
            }
            v100 = *(const void **)(v91 + 48);
            v98 = v91 + 48;
            v99 = v100;
            v101 = *(char *)(v98 + 23);
            v102 = *(char *)(v95 + 71);
            if (v102 >= 0)
              v103 = *(unsigned __int8 *)(v95 + 71);
            else
              v103 = *(_QWORD *)(v95 + 56);
            if (v102 >= 0)
              v104 = (const void *)(v95 + 48);
            else
              v104 = *(const void **)(v95 + 48);
            if (v101 >= 0)
              v105 = *(unsigned __int8 *)(v98 + 23);
            else
              v105 = *(_QWORD *)(v98 + 8);
            if (v101 >= 0)
              v106 = (const void *)v98;
            else
              v106 = v99;
            if (v105 >= v103)
              v107 = v103;
            else
              v107 = v105;
            v108 = memcmp(v104, v106, v107);
            if (v108)
              v109 = v108 >= 0;
            else
              v109 = v103 >= v105;
            if (!*((_QWORD *)&v95 + 1))
              goto LABEL_145;
            v110 = (unint64_t *)(*((_QWORD *)&v95 + 1) + 8);
            do
              v111 = __ldaxr(v110);
            while (__stlxr(v111 - 1, v110));
            if (!v111)
            {
              (*(void (**)(_QWORD))(**((_QWORD **)&v95 + 1) + 16))(*((_QWORD *)&v95 + 1));
              std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v95 + 1));
              if (v92)
              {
LABEL_146:
                v112 = (unint64_t *)&v92->__shared_owners_;
                do
                  v113 = __ldaxr(v112);
                while (__stlxr(v113 - 1, v112));
                if (!v113)
                {
                  ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
                  std::__shared_weak_count::__release_weak(v92);
                }
              }
            }
            else
            {
LABEL_145:
              if (v92)
                goto LABEL_146;
            }
          }
          while (v42 < (uint64_t *)v67 && v109);
        }
LABEL_155:
        if (v42 >= (uint64_t *)v67)
          goto LABEL_229;
        v115 = v42;
        v116 = v67;
        while (2)
        {
          v117 = *v115;
          *v115 = *(_QWORD *)v116;
          *(_QWORD *)v116 = v117;
          v118 = v115[1];
          v115[1] = *((_QWORD *)v116 + 1);
          *((_QWORD *)v116 + 1) = v118;
          while (2)
          {
            v43 = (uint64_t)v115;
            v119 = v115[2];
            v120 = (std::__shared_weak_count *)v115[3];
            v115 += 2;
            if (v120)
            {
              v121 = (unint64_t *)&v120->__shared_owners_;
              do
                v122 = __ldxr(v121);
              while (__stxr(v122 + 1, v121));
            }
            v123 = v687;
            if (*((_QWORD *)&v687 + 1))
            {
              v124 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
              do
                v125 = __ldxr(v124);
              while (__stxr(v125 + 1, v124));
            }
            v128 = *(const void **)(v119 + 48);
            v126 = v119 + 48;
            v127 = v128;
            v129 = *(char *)(v126 + 23);
            v130 = *(char *)(v123 + 71);
            if (v130 >= 0)
              v131 = *(unsigned __int8 *)(v123 + 71);
            else
              v131 = *(_QWORD *)(v123 + 56);
            if (v130 >= 0)
              v132 = (const void *)(v123 + 48);
            else
              v132 = *(const void **)(v123 + 48);
            if (v129 >= 0)
              v133 = *(unsigned __int8 *)(v126 + 23);
            else
              v133 = *(_QWORD *)(v126 + 8);
            if (v129 >= 0)
              v134 = (const void *)v126;
            else
              v134 = v127;
            if (v133 >= v131)
              v135 = v131;
            else
              v135 = v133;
            v136 = memcmp(v132, v134, v135);
            if (v136)
              v137 = v136 < 0;
            else
              v137 = v131 < v133;
            if (!*((_QWORD *)&v123 + 1))
              goto LABEL_186;
            v138 = (unint64_t *)(*((_QWORD *)&v123 + 1) + 8);
            do
              v139 = __ldaxr(v138);
            while (__stlxr(v139 - 1, v138));
            if (!v139)
            {
              (*(void (**)(_QWORD))(**((_QWORD **)&v123 + 1) + 16))(*((_QWORD *)&v123 + 1));
              std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v123 + 1));
              if (v120)
              {
LABEL_187:
                v140 = (unint64_t *)&v120->__shared_owners_;
                do
                  v141 = __ldaxr(v140);
                while (__stlxr(v141 - 1, v140));
                if (!v141)
                {
                  ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
                  std::__shared_weak_count::__release_weak(v120);
                }
              }
            }
            else
            {
LABEL_186:
              if (v120)
                goto LABEL_187;
            }
            if (v137)
              continue;
            break;
          }
          while (2)
          {
            v142 = *((_QWORD *)v116 - 2);
            v143 = (std::__shared_weak_count *)*((_QWORD *)v116 - 1);
            v116 -= 16;
            if (v143)
            {
              v144 = (unint64_t *)&v143->__shared_owners_;
              do
                v145 = __ldxr(v144);
              while (__stxr(v145 + 1, v144));
            }
            v146 = v687;
            if (*((_QWORD *)&v687 + 1))
            {
              v147 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
              do
                v148 = __ldxr(v147);
              while (__stxr(v148 + 1, v147));
            }
            v151 = *(const void **)(v142 + 48);
            v149 = v142 + 48;
            v150 = v151;
            v152 = *(char *)(v149 + 23);
            v153 = *(char *)(v146 + 71);
            if (v153 >= 0)
              v154 = *(unsigned __int8 *)(v146 + 71);
            else
              v154 = *(_QWORD *)(v146 + 56);
            if (v153 >= 0)
              v155 = (const void *)(v146 + 48);
            else
              v155 = *(const void **)(v146 + 48);
            if (v152 >= 0)
              v156 = *(unsigned __int8 *)(v149 + 23);
            else
              v156 = *(_QWORD *)(v149 + 8);
            if (v152 >= 0)
              v157 = (const void *)v149;
            else
              v157 = v150;
            if (v156 >= v154)
              v158 = v154;
            else
              v158 = v156;
            v159 = memcmp(v155, v157, v158);
            if (v159)
              v160 = v159 < 0;
            else
              v160 = v154 < v156;
            if (!*((_QWORD *)&v146 + 1))
              goto LABEL_221;
            v161 = (unint64_t *)(*((_QWORD *)&v146 + 1) + 8);
            do
              v162 = __ldaxr(v161);
            while (__stlxr(v162 - 1, v161));
            if (!v162)
            {
              (*(void (**)(_QWORD))(**((_QWORD **)&v146 + 1) + 16))(*((_QWORD *)&v146 + 1));
              std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v146 + 1));
              if (v143)
              {
LABEL_222:
                v163 = (unint64_t *)&v143->__shared_owners_;
                do
                  v164 = __ldaxr(v163);
                while (__stlxr(v164 - 1, v163));
                if (!v164)
                {
                  ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
                  std::__shared_weak_count::__release_weak(v143);
                }
              }
            }
            else
            {
LABEL_221:
              if (v143)
                goto LABEL_222;
            }
            if (!v160)
              continue;
            break;
          }
          if (v115 < (uint64_t *)v116)
            continue;
          break;
        }
LABEL_229:
        if ((uint64_t *)v43 != v685)
          sub_20BDE82DC((uint64_t)v685, (__int128 *)v43);
        sub_20BDE82DC(v43, &v687);
        v165 = (std::__shared_weak_count *)*((_QWORD *)&v687 + 1);
        if (*((_QWORD *)&v687 + 1))
        {
          v166 = (unint64_t *)(*((_QWORD *)&v687 + 1) + 8);
          do
            v167 = __ldaxr(v166);
          while (__stlxr(v167 - 1, v166));
          if (!v167)
          {
            ((void (*)(std::__shared_weak_count *))v165->__on_zero_shared)(v165);
            std::__shared_weak_count::__release_weak(v165);
          }
        }
        v168 = v42 >= (uint64_t *)v67;
        v6 = a2;
        v169 = v685;
        if (!v168)
        {
LABEL_240:
          sub_20C9526D0(v169, v43, a3, a4 & 1);
          a4 = 0;
          i = (uint64_t *)(v43 + 16);
          continue;
        }
        v170 = sub_20C955210(v685, (char *)v43);
        i = (uint64_t *)(v43 + 16);
        if (!sub_20C955210((uint64_t *)(v43 + 16), a2))
        {
          v169 = v685;
          if (v170)
            continue;
          goto LABEL_240;
        }
        a2 = (char *)v43;
        i = v685;
        if (!v170)
          goto LABEL_1;
        return;
    }
  }
}

void sub_20BDCE79C(_Unwind_Exception *a1)
{
  _BYTE *v1;

  __dmb(0xBu);
  *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t tbb::internal::market::update_workers_request(tbb::internal::market *this)
{
  int v2;
  int v3;
  uint64_t v4;

  v2 = *((_DWORD *)this + 7);
  v3 = *((_DWORD *)this + 8);
  if (*((_DWORD *)this + 10) < v2)
    v2 = *((_DWORD *)this + 10);
  if (*((int *)this + 11) >= 1)
    v2 = 1;
  *((_DWORD *)this + 8) = v2;
  v4 = *((_QWORD *)this + 6);
  *((_DWORD *)this + 10 * v4 + 27) = v2;
  tbb::internal::market::update_allotment((uint64_t)this, v4);
  return (*((_DWORD *)this + 8) - v3);
}

uint64_t tbb::internal::market::update_allotment(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  BOOL v19;

  v2 = *(_QWORD *)(this + 56);
  if (v2 <= a2)
  {
    v7 = *(_DWORD *)(this + 40 * a2 + 108);
    while (1)
    {
      v9 = this + 40 * a2;
      *(_DWORD *)(v9 + 108) = v7;
      v10 = *(_DWORD *)(v9 + 104);
      if (v10)
      {
        v11 = this + 40 * a2;
        v12 = v11 + 72;
        v13 = v10 >= v7 ? v7 : v10;
        v14 = *(_QWORD *)(v11 + 80);
        if (v14 == v12)
        {
          v8 = 0;
        }
        else
        {
          v8 = 0;
          v15 = 0;
          do
          {
            v18 = *(_DWORD *)(v14 + 212);
            if (v18 >= 1)
            {
              if (*(_DWORD *)(this + 28))
              {
                v16 = v15 + v18 * v13;
                v17 = v16 / v10;
                v15 = v16 % v10;
                if (v17 >= *(_DWORD *)(v14 + 208))
                  v17 = *(_DWORD *)(v14 + 208);
              }
              else
              {
                if (*(_BYTE *)(v14 + 337))
                  v19 = v8 < v13;
                else
                  v19 = 0;
                v17 = v19;
              }
              *(_DWORD *)(v14 + 128) = v17;
              v8 += v17;
            }
            v14 = *(_QWORD *)(v14 + 8);
          }
          while (v14 != v12);
        }
        v7 -= v8;
        if (v7 < 1)
          break;
      }
      v3 = a2 - 1;
      v19 = a2-- <= v2;
      if (v19)
        goto LABEL_3;
    }
  }
  v3 = a2;
LABEL_3:
  while (v3 > v2)
  {
    --v3;
    v4 = this + 40 * v3;
    v5 = v4 + 72;
    *(_DWORD *)(v4 + 108) = 0;
    for (i = *(_QWORD *)(v4 + 80); i != v5; i = *(_QWORD *)(i + 8))
      *(_DWORD *)(i + 128) = 0;
  }
  return this;
}

uint64_t tbb::internal::market::disable_mandatory_concurrency_impl(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(a2 + 337) = 0;
  --*(_DWORD *)(result + 44);
  return result;
}

uint64_t tbb::internal::market::enable_mandatory_concurrency_impl(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(a2 + 337) = 1;
  ++*(_DWORD *)(result + 44);
  return result;
}

uint64_t sub_20BDCE940(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;

  v2 = *(unint64_t **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)a1 = 0;
    if (*(_BYTE *)(a1 + 8))
    {
      while (1)
      {
        v3 = *v2;
        v4 = *v2 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          while (1)
          {
            v5 = __ldaxr(v2);
            if (v5 != v3)
              break;
            if (!__stlxr(v4, v2))
              return a1;
          }
          __clrex();
          do
            v6 = __ldxr(v2);
          while (__stxr(v6, v2));
        }
        while (v6 == v3);
        sched_yield();
      }
    }
    do
      v7 = __ldaxr(v2);
    while (__stlxr(v7 - 4, v2));
  }
  return a1;
}

uint64_t tbb::internal::governor::does_client_join_workers(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 216);
}

tbb::internal::arena *tbb::internal::market::create_arena(tbb::internal::market *this, int a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int64x2_t *v7;
  void *v8;
  tbb::internal::arena *arena;
  unint64_t *v10;
  __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;

  v7 = tbb::internal::market::global_market(1, (const char *)((_DWORD)this - a2), a3, a4, a5);
  arena = tbb::internal::arena::allocate_arena((tbb::internal::arena *)v7, this, a2, v8);
  v10 = &v7->u64[1];
  tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::spin_rw_mutex_v3 *)&v7->u64[1]);
  v11 = &v7->i8[40 * *((_QWORD *)arena + 17)];
  v12 = *((_QWORD *)arena + 17);
  v13 = *((_QWORD *)v11 + 10);
  v14 = *((_QWORD *)v11 + 11);
  *(_QWORD *)arena = v11 + 72;
  *((_QWORD *)arena + 1) = v13;
  **((_QWORD **)v11 + 10) = arena;
  *((_QWORD *)v11 + 10) = arena;
  *((_QWORD *)v11 + 11) = v14 + 1;
  if (!v14)
    v7[6].i64[5 * v12] = (uint64_t)arena;
LABEL_3:
  v15 = *v10;
  v16 = *v10 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    while (1)
    {
      v17 = __ldaxr(v10);
      if (v17 == v15)
        break;
      __clrex();
      do
        v18 = __ldxr(v10);
      while (__stxr(v18, v10));
      if (v18 != v15)
      {
        sched_yield();
        goto LABEL_3;
      }
    }
  }
  while (__stlxr(v16, v10));
  return arena;
}

uint64_t tbb::internal::market::detach_arena(uint64_t result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  if (*(_BYTE *)(a2 + 337))
  {
    *(_BYTE *)(a2 + 337) = 0;
    --*(_DWORD *)(result + 44);
  }
  v2 = (_QWORD *)(result + 72 + 40 * *(_QWORD *)(a2 + 136));
  if (v2[3] == a2)
  {
    v3 = *(_QWORD *)(a2 + 8);
    if ((_QWORD *)v3 == v2)
    {
      v3 = result + 72 + 40 * *(_QWORD *)(a2 + 136);
      if (v2[2] >= 2uLL)
        v3 = v2[1];
    }
    v2[3] = v3;
  }
  --v2[2];
  v4 = *(_QWORD **)(a2 + 8);
  *v4 = *(_QWORD *)a2;
  *(_QWORD *)(*(_QWORD *)a2 + 8) = v4;
  v5 = *(_QWORD *)(a2 + 312);
  if (v5 == *(_QWORD *)(result + 192))
    *(_QWORD *)(result + 192) = v5 + 1;
  return result;
}

uint64_t tbb::internal::market::try_destroy_arena(tbb::internal::market *this, tbb::internal::arena *a2, uint64_t a3)
{
  unint64_t *v6;
  uint64_t result;
  void *v8;
  tbb::internal::arena *v9;
  tbb::internal::arena *v10;
  tbb::internal::arena *v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;

  v6 = (unint64_t *)((char *)this + 8);
  result = tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::internal::market *)((char *)this + 8));
  v9 = (tbb::internal::market *)((char *)this + 152);
  while (1)
  {
    v9 = (tbb::internal::arena *)*((_QWORD *)v9 + 1);
    if (v9 == (tbb::internal::market *)((char *)this + 152))
      break;
    if (v9 == a2)
    {
LABEL_12:
      if (*((_QWORD *)a2 + 39) != a3 || *((_DWORD *)a2 + 53) || (v12 = *((_DWORD *)a2 + 33), __dmb(0xBu), v12))
      {
        if ((*(_BYTE *)v6 & 1) != 0)
        {
          while (1)
          {
            v14 = *v6;
            v15 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
            do
            {
              while (1)
              {
                v16 = __ldaxr(v6);
                if (v16 != v14)
                  break;
                if (!__stlxr(v15, v6))
                  return result;
              }
              __clrex();
              do
                v17 = __ldxr(v6);
              while (__stxr(v17, v6));
            }
            while (v17 == v14);
            result = sched_yield();
          }
        }
        do
          v13 = __ldaxr(v6);
        while (__stlxr(v13 - 4, v6));
      }
      else
      {
        if (*((_BYTE *)a2 + 337))
        {
          *((_BYTE *)a2 + 337) = 0;
          --*((_DWORD *)this + 11);
        }
        v23 = (char *)this + 40 * *((_QWORD *)a2 + 17) + 72;
        if (*((tbb::internal::arena **)v23 + 3) == a2)
        {
          v24 = (char *)*((_QWORD *)a2 + 1);
          if (v24 == v23)
          {
            v24 = (char *)this + 40 * *((_QWORD *)a2 + 17) + 72;
            if (*((_QWORD *)v23 + 2) >= 2uLL)
              v24 = (char *)*((_QWORD *)v23 + 1);
          }
          *((_QWORD *)v23 + 3) = v24;
        }
        --*((_QWORD *)v23 + 2);
        v25 = (_QWORD *)*((_QWORD *)a2 + 1);
        *v25 = *(_QWORD *)a2;
        *(_QWORD *)(*(_QWORD *)a2 + 8) = v25;
        v26 = *((_QWORD *)a2 + 39);
        if (v26 == *((_QWORD *)this + 24))
          *((_QWORD *)this + 24) = v26 + 1;
        if ((*(_BYTE *)v6 & 1) != 0)
        {
          while (1)
          {
            v28 = *v6;
            v29 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
            do
            {
              while (1)
              {
                v30 = __ldaxr(v6);
                if (v30 != v28)
                  break;
                if (!__stlxr(v29, v6))
                  return tbb::internal::arena::free_arena(a2, v8);
              }
              __clrex();
              do
                v31 = __ldxr(v6);
              while (__stxr(v31, v6));
            }
            while (v31 == v28);
            sched_yield();
          }
        }
        do
          v27 = __ldaxr(v6);
        while (__stlxr(v27 - 4, v6));
        return tbb::internal::arena::free_arena(a2, v8);
      }
      return result;
    }
  }
  v10 = (tbb::internal::market *)((char *)this + 112);
  while (1)
  {
    v10 = (tbb::internal::arena *)*((_QWORD *)v10 + 1);
    if (v10 == (tbb::internal::market *)((char *)this + 112))
      break;
    if (v10 == a2)
      goto LABEL_12;
  }
  v11 = (tbb::internal::market *)((char *)this + 72);
  while (1)
  {
    v11 = (tbb::internal::arena *)*((_QWORD *)v11 + 1);
    if (v11 == (tbb::internal::market *)((char *)this + 72))
      break;
    if (v11 == a2)
      goto LABEL_12;
  }
  if ((*(_BYTE *)v6 & 1) != 0)
  {
    while (1)
    {
      v19 = *v6;
      v20 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        while (1)
        {
          v21 = __ldaxr(v6);
          if (v21 != v19)
            break;
          if (!__stlxr(v20, v6))
            return result;
        }
        __clrex();
        do
          v22 = __ldxr(v6);
        while (__stxr(v22, v6));
      }
      while (v22 == v19);
      result = sched_yield();
    }
  }
  do
    v18 = __ldaxr(v6);
  while (__stlxr(v18 - 4, v6));
  return result;
}

uint64_t tbb::internal::market::arena_in_need(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;

  if (*(_QWORD *)(a2 + 8) == a2)
    return 0;
  result = a3;
  while (1)
  {
    v4 = *(_QWORD *)(result + 8);
    v5 = *(_QWORD *)(a2 + 8);
    v6 = *(_DWORD *)(result + 132);
    __dmb(0xBu);
    if (*(_DWORD *)(result + 128) > v6 >> 12)
      break;
    if (v4 == a2)
      result = v5;
    else
      result = v4;
    if (result == a3)
      return 0;
  }
  v7 = (unsigned int *)(result + 132);
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 + 4096, v7));
  return result;
}

uint64_t tbb::internal::market::update_allotment(uint64_t a1, uint64_t a2, int a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  BOOL v11;

  if (a3 >= a4)
    v4 = a4;
  else
    v4 = a3;
  v5 = *(_QWORD *)(a2 + 8);
  if (v5 == a2)
    return 0;
  v6 = 0;
  v7 = 0;
  do
  {
    v10 = *(_DWORD *)(v5 + 212);
    if (v10 >= 1)
    {
      if (*(_DWORD *)(a1 + 28))
      {
        v8 = v7 + v10 * v4;
        v9 = v8 / a3;
        v7 = v8 % a3;
        if (v9 >= *(_DWORD *)(v5 + 208))
          v9 = *(_DWORD *)(v5 + 208);
      }
      else
      {
        if (*(_BYTE *)(v5 + 337))
          v11 = (int)v6 < v4;
        else
          v11 = 0;
        v9 = v11;
      }
      *(_DWORD *)(v5 + 128) = v9;
      v6 = (v9 + v6);
    }
    v5 = *(_QWORD *)(v5 + 8);
  }
  while (v5 != a2);
  return v6;
}

BOOL tbb::internal::market::is_arena_in_list(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _BOOL8 result;

  if (!a3)
    return 0;
  v3 = a2;
  do
  {
    v3 = *(_QWORD *)(v3 + 8);
    result = v3 != a2;
  }
  while (v3 != a3 && v3 != a2);
  return result;
}

_QWORD *tbb::internal::market::arena_in_need(uint64_t a1, _QWORD *a2)
{
  int v2;
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *result;
  _QWORD *v10;
  _QWORD *v11;
  unsigned int v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int v21;
  unint64_t v22;
  unsigned int *v23;
  unsigned int v24;

  v2 = *(_DWORD *)(a1 + 40);
  __dmb(0xBu);
  if (v2 < 1)
    return 0;
  v5 = (unint64_t *)(a1 + 8);
  tbb::spin_rw_mutex_v3::internal_acquire_reader((unint64_t *)(a1 + 8));
  v6 = *(int *)(a1 + 48);
  if (a2)
  {
    v7 = a1 + 40 * (int)v6 + 72;
    v8 = v7;
    while (1)
    {
      v8 = *(_QWORD *)(v8 + 8);
      if (v8 == v7)
        break;
      if ((_QWORD *)v8 == a2)
      {
        if (*(_QWORD *)(a1 + 40 * (int)v6 + 80) == v7)
          break;
        result = a2;
        while (1)
        {
          v10 = (_QWORD *)result[1];
          v11 = *(_QWORD **)(a1 + 40 * (int)v6 + 80);
          v12 = *((_DWORD *)result + 33);
          __dmb(0xBu);
          if (*((_DWORD *)result + 32) > v12 >> 12)
            break;
          if (v10 == (_QWORD *)v7)
            result = v11;
          else
            result = v10;
          if (result == a2)
            goto LABEL_13;
        }
        v23 = (unsigned int *)result + 33;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 + 4096, v23));
        goto LABEL_29;
      }
    }
  }
LABEL_13:
  if (*(_QWORD *)(a1 + 56) <= v6)
  {
    while (1)
    {
      v13 = a1 + 40 * v6;
      v16 = *(_QWORD **)(v13 + 96);
      v14 = (_QWORD *)(v13 + 96);
      v15 = v16;
      if ((_QWORD *)*(v14 - 2) != v14 - 3)
        break;
LABEL_17:
      if (*(_QWORD *)(a1 + 56) > --v6)
        goto LABEL_14;
    }
    result = v15;
    while (1)
    {
      v17 = (_QWORD *)result[1];
      v18 = (_QWORD *)*(v14 - 2);
      v19 = *((_DWORD *)result + 33);
      __dmb(0xBu);
      if (*((_DWORD *)result + 32) > v19 >> 12)
        break;
      if (v17 == v14 - 3)
        result = v18;
      else
        result = v17;
      if (result == v15)
        goto LABEL_17;
    }
    v20 = (unsigned int *)result + 33;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 + 4096, v20));
    __dmb(0xBu);
    *v14 = result;
  }
  else
  {
LABEL_14:
    result = 0;
  }
  do
LABEL_29:
    v22 = __ldaxr(v5);
  while (__stlxr(v22 - 4, v5));
  return result;
}

uint64_t tbb::internal::market::enable_mandatory_concurrency(uint64_t a1, uint64_t a2)
{
  unint64_t *v4;
  uint64_t result;
  uint64_t v6;
  char v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char v18;

  v4 = (unint64_t *)(a1 + 8);
  result = tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::spin_rw_mutex_v3 *)(a1 + 8));
  if (*(_DWORD *)(a1 + 28))
  {
    v6 = 0;
    v7 = 1;
  }
  else
  {
    v7 = 1;
    if (*(_BYTE *)(a2 + 337))
    {
      v6 = 0;
    }
    else
    {
      *(_BYTE *)(a2 + 337) = 1;
      v9 = *(_DWORD *)(a1 + 40);
      v8 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a1 + 44) = v8 + 1;
      v10 = *(_DWORD *)(a1 + 32);
      v11 = v9 & (v9 >> 31);
      if (v8 >= 0)
        v12 = 1;
      else
        v12 = v11;
      *(_DWORD *)(a1 + 32) = v12;
      v13 = *(_QWORD *)(a1 + 48);
      *(_DWORD *)(a1 + 40 * v13 + 108) = v12;
      result = tbb::internal::market::update_allotment(a1, v13);
      v7 = 0;
      v6 = (*(_DWORD *)(a1 + 32) - v10);
    }
  }
LABEL_9:
  v14 = *v4;
  v15 = *v4 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    while (1)
    {
      v16 = __ldaxr(v4);
      if (v16 == v14)
        break;
      __clrex();
      do
        v17 = __ldxr(v4);
      while (__stxr(v17, v4));
      if (v17 != v14)
      {
        result = sched_yield();
        goto LABEL_9;
      }
    }
  }
  while (__stlxr(v15, v4));
  if ((_DWORD)v6)
    v18 = v7;
  else
    v18 = 1;
  if ((v18 & 1) == 0)
    return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16), v6);
  return result;
}

uint64_t tbb::internal::market::mandatory_concurrency_disable(tbb::internal::market *this, tbb::internal::arena *a2)
{
  unint64_t *v4;
  char v5;
  uint64_t result;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  BOOL v11;
  int v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char v19;

  v4 = (unint64_t *)((char *)this + 8);
  v5 = 1;
  result = tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::internal::market *)((char *)this + 8));
  if (*((_BYTE *)a2 + 337) && (result = tbb::internal::arena::has_enqueued_tasks(a2), (result & 1) == 0))
  {
    *((_BYTE *)a2 + 337) = 0;
    v9 = *((_DWORD *)this + 10);
    v8 = *((_DWORD *)this + 11);
    v10 = *((_DWORD *)this + 8);
    if (v9 >= *((_DWORD *)this + 7))
      v9 = *((_DWORD *)this + 7);
    v11 = __OFSUB__(v8, 1);
    v12 = v8 - 1;
    *((_DWORD *)this + 11) = v12;
    if ((v12 < 0) ^ v11 | (v12 == 0))
      v13 = v9;
    else
      v13 = 1;
    *((_DWORD *)this + 8) = v13;
    v14 = *((_QWORD *)this + 6);
    *((_DWORD *)this + 10 * v14 + 27) = v13;
    result = tbb::internal::market::update_allotment((uint64_t)this, v14);
    v5 = 0;
    v7 = (*((_DWORD *)this + 8) - v10);
  }
  else
  {
    v7 = 0;
  }
LABEL_10:
  v15 = *v4;
  v16 = *v4 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    while (1)
    {
      v17 = __ldaxr(v4);
      if (v17 == v15)
        break;
      __clrex();
      do
        v18 = __ldxr(v4);
      while (__stxr(v18, v4));
      if (v18 != v15)
      {
        result = sched_yield();
        goto LABEL_10;
      }
    }
  }
  while (__stlxr(v16, v4));
  if ((_DWORD)v7)
    v19 = v5;
  else
    v19 = 1;
  if ((v19 & 1) == 0)
    return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 2) + 40))(*((_QWORD *)this + 2), v7);
  return result;
}

void sub_20BDCF254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_20BDCE940((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t tbb::internal::market::adjust_demand(uint64_t result, uint64_t a2, int a3)
{
  int v3;
  uint64_t v5;
  unint64_t *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  int *v27;
  int v28;
  BOOL v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int *v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  BOOL v42;
  int v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  int v49;
  unsigned int v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  BOOL v56;
  int v57;
  uint64_t v58;

  if (!a3)
    return result;
  v3 = a3;
  v5 = result;
  v6 = (unint64_t *)(result + 8);
  result = tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::spin_rw_mutex_v3 *)(result + 8));
  v7 = *(_DWORD *)(a2 + 212);
  v8 = v7 + v3;
  *(_DWORD *)(a2 + 212) = v7 + v3;
  if (!((v7 + v3 < 0) ^ __OFADD__(v7, v3) | (v7 + v3 == 0)))
  {
    if (v7 < 0)
      v3 += v7;
LABEL_8:
    v9 = *(_DWORD *)(v5 + 44);
    *(_DWORD *)(v5 + 40) += v3;
    if (v9 >= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)(v5 + 28);
    v11 = *(_QWORD *)(a2 + 136);
    v12 = v5 + 40 * v11;
    v14 = *(_DWORD *)(v12 + 104);
    v13 = (_DWORD *)(v12 + 104);
    *v13 = v14 + v3;
    if (v8 <= 0)
    {
      if (*(_QWORD *)(a2 + 136) != 1)
      {
        v15 = *(_QWORD *)(a2 + 136);
        v16 = (_QWORD *)(v5 + 72 + 40 * v15);
        if (v16[3] == a2)
        {
          v17 = *(_QWORD *)(a2 + 8);
          if ((_QWORD *)v17 == v16)
          {
            v17 = v5 + 72 + 40 * *(_QWORD *)(a2 + 136);
            if (v16[2] >= 2uLL)
              v17 = v16[1];
          }
          v16[3] = v17;
        }
        --v16[2];
        v18 = *(_QWORD **)(a2 + 8);
        *v18 = *(_QWORD *)a2;
        *(_QWORD *)(*(_QWORD *)a2 + 8) = v18;
        *(_QWORD *)(a2 + 136) = 1;
        v19 = v5 + 40 * *(_QWORD *)(a2 + 136);
        v20 = *(_QWORD *)(a2 + 136);
        v21 = *(_QWORD *)(v19 + 80);
        v22 = *(_QWORD *)(v19 + 88);
        *(_QWORD *)a2 = v19 + 72;
        *(_QWORD *)(a2 + 8) = v21;
        **(_QWORD **)(v19 + 80) = a2;
        *(_QWORD *)(v19 + 80) = a2;
        *(_QWORD *)(v19 + 88) = v22 + 1;
        if (!v22)
          *(_QWORD *)(v5 + 40 * v20 + 96) = a2;
        v23 = (unint64_t *)(a2 + 272);
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 + 1, v23));
        v25 = *(_DWORD *)(a2 + 212);
        *(_DWORD *)(v5 + 40 * v15 + 104) -= v25;
        *(_DWORD *)(v5 + 144) += v25;
      }
      *(_QWORD *)(a2 + 264) = 1;
    }
    v26 = *(_QWORD *)(v5 + 48);
    if (v11 == v26)
    {
      if (!*v13)
      {
        v27 = (int *)(v5 + 40 * v11 + 64);
        while (v11 > *(_QWORD *)(v5 + 56))
        {
          --v11;
          v28 = *v27;
          v27 -= 10;
          if (v28)
            goto LABEL_59;
        }
        v11 = 1;
        *(_QWORD *)(v5 + 56) = 1;
LABEL_59:
        *(_QWORD *)(v5 + 48) = v11;
        if (*(_DWORD *)(v5 + 28))
          v42 = 1;
        else
          v42 = *(_DWORD *)(v5 + 44) == 0;
        if (v42)
          v43 = *(_DWORD *)(v5 + 28);
        else
          v43 = 1;
        *(_DWORD *)(v5 + 40 * v11 + 108) = v43;
        v44 = *(_QWORD *)(v5 + 64) + 1;
        __dmb(0xBu);
        *(_QWORD *)(v5 + 64) = v44;
      }
      v11 = *(_QWORD *)(v5 + 48);
      *(_DWORD *)(v5 + 40 * v11 + 108) = v10;
    }
    else if (v11 <= v26)
    {
      v34 = *(_QWORD *)(v5 + 56);
      if (v11 == v34)
      {
        if (!*v13)
        {
          v35 = (int *)(v5 + 40 * v11 + 144);
          while (v26 != v11)
          {
            ++v11;
            v36 = *v35;
            v35 += 10;
            if (v36)
            {
              *(_QWORD *)(v5 + 56) = v11;
              goto LABEL_68;
            }
          }
          *(int64x2_t *)(v5 + 48) = vdupq_n_s64(1uLL);
          if (*(_DWORD *)(v5 + 28))
            v56 = 1;
          else
            v56 = *(_DWORD *)(v5 + 44) == 0;
          if (v56)
            v57 = *(_DWORD *)(v5 + 28);
          else
            v57 = 1;
          *(_DWORD *)(v5 + 148) = v57;
          v58 = *(_QWORD *)(v5 + 64) + 1;
          __dmb(0xBu);
          *(_QWORD *)(v5 + 64) = v58;
          goto LABEL_68;
        }
      }
      else if (v11 < v34)
      {
        *(_QWORD *)(v5 + 56) = v11;
        v11 = (int)v34;
      }
    }
    else
    {
      *(_QWORD *)(v5 + 48) = v11;
      if (*(_DWORD *)(v5 + 28))
        v29 = 1;
      else
        v29 = *(_DWORD *)(v5 + 44) == 0;
      if (v29)
        v30 = *(_DWORD *)(v5 + 28);
      else
        v30 = 1;
      v31 = v5 + 40 * v11;
      *(_DWORD *)(v31 + 108) = v30;
      v32 = *(_QWORD *)(v5 + 64) + 1;
      __dmb(0xBu);
      *(_QWORD *)(v5 + 64) = v32;
      v33 = *(_DWORD *)(a2 + 212);
      if (v10 < v33)
        v33 = v10;
      *(_DWORD *)(a2 + 128) = v33;
      --v11;
      *(_DWORD *)(v31 + 68) = v10 - v33;
    }
    tbb::internal::market::update_allotment(v5, v11);
LABEL_68:
    v45 = *(_DWORD *)(v5 + 32);
    v46 = v45 + v3;
    if (v3 < 1)
    {
      v48 = *(_DWORD *)(v5 + 40);
      if (v48 >= v10)
        v49 = v10;
      else
        v49 = *(_DWORD *)(v5 + 40);
      v50 = v49 - v45;
      if (v46 < v48)
        v47 = v50;
      else
        v47 = v3;
    }
    else if (v46 <= v10)
    {
      v47 = v3;
    }
    else
    {
      v47 = (v10 - v45);
    }
    *(_DWORD *)(v5 + 32) = v45 + v47;
    if ((*(_BYTE *)(v5 + 8) & 1) != 0)
    {
      while (1)
      {
        v52 = *v6;
        v53 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          while (1)
          {
            v54 = __ldaxr(v6);
            if (v54 != v52)
              break;
            if (!__stlxr(v53, v6))
              return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 16) + 40))(*(_QWORD *)(v5 + 16), v47);
          }
          __clrex();
          do
            v55 = __ldxr(v6);
          while (__stxr(v55, v6));
        }
        while (v55 == v52);
        sched_yield();
      }
    }
    do
      v51 = __ldaxr(v6);
    while (__stlxr(v51 - 4, v6));
    return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 16) + 40))(*(_QWORD *)(v5 + 16), v47);
  }
  *(_DWORD *)(a2 + 128) = 0;
  if (v7 > 0)
  {
    v3 = -v7;
    goto LABEL_8;
  }
  if ((*(_BYTE *)v6 & 1) != 0)
  {
    while (1)
    {
      v38 = *v6;
      v39 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        while (1)
        {
          v40 = __ldaxr(v6);
          if (v40 != v38)
            break;
          if (!__stlxr(v39, v6))
            return result;
        }
        __clrex();
        do
          v41 = __ldxr(v6);
        while (__stxr(v41, v6));
      }
      while (v41 == v38);
      result = sched_yield();
    }
  }
  do
    v37 = __ldaxr(v6);
  while (__stlxr(v37 - 4, v6));
  return result;
}

uint64_t tbb::internal::market::update_arena_top_priority(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  int v13;

  v3 = *(_QWORD *)(a2 + 136);
  v4 = (_QWORD *)(result + 72 + 40 * v3);
  if (v4[3] == a2)
  {
    v5 = *(_QWORD *)(a2 + 8);
    if ((_QWORD *)v5 == v4)
    {
      v5 = result + 72 + 40 * *(_QWORD *)(a2 + 136);
      if (v4[2] >= 2uLL)
        v5 = v4[1];
    }
    v4[3] = v5;
  }
  --v4[2];
  v6 = *(_QWORD **)(a2 + 8);
  *v6 = *(_QWORD *)a2;
  *(_QWORD *)(*(_QWORD *)a2 + 8) = v6;
  *(_QWORD *)(a2 + 136) = a3;
  v7 = result + 40 * *(_QWORD *)(a2 + 136);
  v8 = *(_QWORD *)(a2 + 136);
  v9 = *(_QWORD *)(v7 + 80);
  v10 = *(_QWORD *)(v7 + 88);
  *(_QWORD *)a2 = v7 + 72;
  *(_QWORD *)(a2 + 8) = v9;
  **(_QWORD **)(v7 + 80) = a2;
  *(_QWORD *)(v7 + 80) = a2;
  *(_QWORD *)(v7 + 88) = v10 + 1;
  if (!v10)
    *(_QWORD *)(result + 40 * v8 + 96) = a2;
  v11 = (unint64_t *)(a2 + 272);
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 + 1, v11));
  v13 = *(_DWORD *)(a2 + 212);
  *(_DWORD *)(result + 72 + 40 * v3 + 32) -= v13;
  *(_DWORD *)(result + 72 + 40 * a3 + 32) += v13;
  return result;
}

tbb::internal::arena *tbb::internal::market::process(uint64_t a1, uint64_t a2)
{
  tbb::internal::generic_scheduler *v3;
  tbb::internal::arena *i;
  tbb::internal::arena *result;

  v3 = (tbb::internal::generic_scheduler *)(a2 - 8);
  for (i = (tbb::internal::arena *)tbb::internal::market::arena_in_need(a1, *(_QWORD **)(a2 + 40));
        i;
        i = (tbb::internal::arena *)tbb::internal::market::arena_in_need(a1, 0))
  {
    tbb::internal::arena::process(i, v3);
  }
  sched_yield();
  while (1)
  {
    result = (tbb::internal::arena *)tbb::internal::market::arena_in_need(a1, 0);
    if (!result)
      break;
    tbb::internal::arena::process(result, v3);
  }
  return result;
}

uint64_t tbb::internal::market::cleanup(uint64_t a1, uint64_t a2)
{
  tbb::internal::observer_proxy **v2;
  unint64_t v3;

  v2 = (tbb::internal::observer_proxy **)(a2 - 8);
  v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS) & 0xFFFFFFFFFFFFFFFELL;
  if (v2 == (tbb::internal::observer_proxy **)v3)
    return tbb::internal::generic_scheduler::cleanup_worker(v2, (void *)1);
  tbb::internal::governor::assume_scheduler((uint64_t)v2);
  tbb::internal::generic_scheduler::cleanup_worker(v2, (void *)(v3 != 0));
  return tbb::internal::governor::assume_scheduler(v3);
}

tbb::internal::governor *tbb::internal::market::acknowledge_close_connection(tbb::internal::market *this, void *a2)
{
  tbb::internal::governor *v2;

  v2 = (tbb::internal::governor *)tbb::internal::NFS_Free(this, a2);
  return tbb::internal::__TBB_InitOnce::remove_ref(v2);
}

uint64_t tbb::internal::market::create_one_job(tbb::internal::market *this)
{
  unsigned int *v2;
  unsigned int v3;
  tbb::internal::market *v4;
  uint64_t worker;

  v2 = (unsigned int *)((char *)this + 36);
  do
  {
    v3 = __ldaxr(v2);
    v4 = (tbb::internal::market *)(v3 + 1);
  }
  while (__stlxr(v4, v2));
  worker = tbb::internal::generic_scheduler::create_worker(this, v4, 1);
  *((_QWORD *)this + v3 + 31) = worker;
  if (worker)
    return worker + 8;
  else
    return 0;
}

BOOL tbb::internal::market::lower_arena_priority(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  int v24;
  BOOL v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;

  v8 = (unint64_t *)(a1 + 8);
  tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::spin_rw_mutex_v3 *)(a1 + 8));
  v9 = *(_QWORD *)(a2 + 272);
  if (v9 == a4)
  {
    v10 = *(_QWORD *)(a2 + 136);
    v11 = (_QWORD *)(a1 + 72 + 40 * v10);
    if (v11[3] == a2)
    {
      v12 = *(_QWORD *)(a2 + 8);
      if ((_QWORD *)v12 == v11)
      {
        v12 = a1 + 72 + 40 * *(_QWORD *)(a2 + 136);
        if (v11[2] >= 2uLL)
          v12 = v11[1];
      }
      v11[3] = v12;
    }
    --v11[2];
    v13 = *(_QWORD **)(a2 + 8);
    *v13 = *(_QWORD *)a2;
    *(_QWORD *)(*(_QWORD *)a2 + 8) = v13;
    *(_QWORD *)(a2 + 136) = a3;
    v14 = a1 + 40 * *(_QWORD *)(a2 + 136);
    v15 = *(_QWORD *)(a2 + 136);
    v16 = *(_QWORD *)(v14 + 80);
    v17 = *(_QWORD *)(v14 + 88);
    *(_QWORD *)a2 = v14 + 72;
    *(_QWORD *)(a2 + 8) = v16;
    **(_QWORD **)(v14 + 80) = a2;
    *(_QWORD *)(v14 + 80) = a2;
    *(_QWORD *)(v14 + 88) = v17 + 1;
    if (!v17)
      *(_QWORD *)(a1 + 40 * v15 + 96) = a2;
    v18 = (unint64_t *)(a2 + 272);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 + 1, v18));
    v20 = *(_DWORD *)(a2 + 212);
    *(_DWORD *)(a1 + 72 + 40 * v10 + 32) -= v20;
    *(_DWORD *)(a1 + 72 + 40 * a3 + 32) += v20;
    if (v20 >= 1)
    {
      v21 = *(_QWORD *)(a1 + 56);
      if (v21 > a3)
      {
        *(_QWORD *)(a1 + 56) = a3;
        v21 = a3;
      }
      if (v10 == *(_QWORD *)(a1 + 48) && !*(_DWORD *)(a1 + 40 * v10 + 104))
      {
        v22 = v10 - 1;
        if (v21 < v10 - 1)
          v22 = v21;
        v23 = (int *)(a1 + 40 * v10 + 64);
        while (--v10 > v21)
        {
          v24 = *v23;
          v23 -= 10;
          if (v24)
            goto LABEL_23;
        }
        v10 = v22;
LABEL_23:
        *(_QWORD *)(a1 + 48) = v10;
        if (*(_DWORD *)(a1 + 28))
          v25 = 1;
        else
          v25 = *(_DWORD *)(a1 + 44) == 0;
        if (v25)
          v26 = *(_DWORD *)(a1 + 28);
        else
          v26 = 1;
        *(_DWORD *)(a1 + 40 * v10 + 108) = v26;
        v27 = *(_QWORD *)(a1 + 64) + 1;
        __dmb(0xBu);
        *(_QWORD *)(a1 + 64) = v27;
      }
      tbb::internal::market::update_allotment(a1, v10);
    }
  }
LABEL_31:
  v28 = *v8;
  v29 = *v8 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    while (1)
    {
      v30 = __ldaxr(v8);
      if (v30 == v28)
        break;
      __clrex();
      do
        v31 = __ldxr(v8);
      while (__stxr(v31, v8));
      if (v31 != v28)
      {
        sched_yield();
        goto LABEL_31;
      }
    }
  }
  while (__stlxr(v29, v8));
  return v9 == a4;
}

uint64_t tbb::internal::market::update_arena_priority(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  BOOL v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  int v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  int *v33;
  int v34;

  v6 = (unint64_t *)(a1 + 8);
  tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::spin_rw_mutex_v3 *)(a1 + 8));
  if (*(_QWORD *)(a2 + 136) != a3)
  {
    if (*(_QWORD *)(a2 + 136) > a3)
    {
      v7 = 0;
      if (*(_QWORD *)(a2 + 264) > a3)
        *(_QWORD *)(a2 + 264) = a3;
      goto LABEL_37;
    }
    if (*(int *)(a2 + 212) < 1)
    {
      v7 = 0;
      goto LABEL_37;
    }
    v8 = *(_QWORD *)(a2 + 136);
    if (v8 <= a3)
      v9 = a3;
    else
      v9 = *(_QWORD *)(a2 + 136);
    v10 = *(_QWORD *)(a2 + 136);
    v11 = (_QWORD *)(a1 + 72 + 40 * v10);
    if (v11[3] == a2)
    {
      v12 = *(_QWORD *)(a2 + 8);
      if ((_QWORD *)v12 == v11)
      {
        v12 = a1 + 72 + 40 * *(_QWORD *)(a2 + 136);
        if (v11[2] >= 2uLL)
          v12 = v11[1];
      }
      v11[3] = v12;
    }
    --v11[2];
    v13 = *(_QWORD **)(a2 + 8);
    *v13 = *(_QWORD *)a2;
    *(_QWORD *)(*(_QWORD *)a2 + 8) = v13;
    *(_QWORD *)(a2 + 136) = a3;
    v14 = a1 + 40 * *(_QWORD *)(a2 + 136);
    v15 = *(_QWORD *)(a2 + 136);
    v16 = *(_QWORD *)(v14 + 80);
    v17 = *(_QWORD *)(v14 + 88);
    *(_QWORD *)a2 = v14 + 72;
    *(_QWORD *)(a2 + 8) = v16;
    **(_QWORD **)(v14 + 80) = a2;
    *(_QWORD *)(v14 + 80) = a2;
    *(_QWORD *)(v14 + 88) = v17 + 1;
    if (!v17)
      *(_QWORD *)(a1 + 40 * v15 + 96) = a2;
    v18 = (unint64_t *)(a2 + 272);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 + 1, v18));
    v20 = *(_DWORD *)(a2 + 212);
    *(_DWORD *)(a1 + 72 + 40 * v10 + 32) -= v20;
    *(_DWORD *)(a1 + 72 + 40 * a3 + 32) += v20;
    v21 = *(_QWORD *)(a1 + 48);
    if (v21 >= a3)
    {
      if (v21 == a3)
      {
LABEL_30:
        v24 = *(_QWORD *)(a1 + 64) + 1;
        __dmb(0xBu);
        *(_QWORD *)(a1 + 64) = v24;
LABEL_31:
        if (v8 == *(_QWORD *)(a1 + 56))
        {
          v25 = *(_QWORD *)(a1 + 48);
          if (v8 < v25)
          {
            v26 = (int *)(a1 + 40 * v8 + 104);
            do
            {
              v27 = *v26;
              v26 += 10;
              if (v27)
                break;
              *(_QWORD *)(a1 + 56) = ++v8;
            }
            while (v25 != v8);
          }
        }
        tbb::internal::market::update_allotment(a1, v9);
        v7 = 1;
        goto LABEL_37;
      }
      if (v8 != v21 || *(_DWORD *)(a1 + 40 * v8 + 104))
        goto LABEL_31;
      v33 = (int *)(a1 + 40 * v8 + 64);
      a3 = v8;
      do
      {
        --a3;
        v34 = *v33;
        v33 -= 10;
        v8 = a3;
        v9 = a3;
      }
      while (!v34);
    }
    *(_QWORD *)(a1 + 48) = a3;
    if (*(_DWORD *)(a1 + 28))
      v22 = 1;
    else
      v22 = *(_DWORD *)(a1 + 44) == 0;
    if (v22)
      v23 = *(_DWORD *)(a1 + 28);
    else
      v23 = 1;
    *(_DWORD *)(a1 + 40 * a3 + 108) = v23;
    goto LABEL_30;
  }
  v7 = 0;
LABEL_37:
  v28 = *v6;
  v29 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    while (1)
    {
      v30 = __ldaxr(v6);
      if (v30 == v28)
        break;
      __clrex();
      do
        v31 = __ldxr(v6);
      while (__stxr(v31, v6));
      if (v31 != v28)
      {
        sched_yield();
        goto LABEL_37;
      }
    }
  }
  while (__stlxr(v29, v6));
  return v7;
}

uint64_t sub_20BDCFD70(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_20BDCFD78(uint64_t a1)
{
  return *(_QWORD *)(a1 + 208);
}

uint64_t sub_20BDCFD80()
{
  return 1;
}

tbb::internal::task_scheduler_observer_v3 *tbb::internal::construct_binding_observer(tbb::internal::numa_topology *a1, int a2, tbb::internal *a3)
{
  tbb::internal::task_scheduler_observer_v3 *v6;

  if (a2 < 0 || tbb::internal::numa_topology::nodes_count(a1) < 2)
    return 0;
  v6 = (tbb::internal::task_scheduler_observer_v3 *)operator new(0x30uLL);
  sub_20BDCFE1C((uint64_t)v6, (uint64_t)a1, a2, a3);
  if (!*((_QWORD *)v6 + 1))
    *((_QWORD *)v6 + 2) = 0x8000000000000000;
  tbb::internal::task_scheduler_observer_v3::observe(v6, 1);
  return v6;
}

void sub_20BDCFE08(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDCFE1C(uint64_t a1, uint64_t a2, int a3, tbb::internal *this)
{
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)a1 = &unk_24C5163D8;
  *(_DWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = tbb::internal::construct_binding_handler(this);
  return a1;
}

void sub_20BDCFE68(_Unwind_Exception *exception_object)
{
  tbb::internal::task_scheduler_observer_v3 *v1;
  uint64_t v3;

  *(_QWORD *)v1 = &unk_24C516448;
  if (!*((_QWORD *)v1 + 1))
  {
    *(_QWORD *)v1 = &unk_24C516478;
    _Unwind_Resume(exception_object);
  }
  tbb::internal::task_scheduler_observer_v3::observe(v1, 0);
  v3 = *((_QWORD *)v1 + 1);
  *(_QWORD *)v1 = &unk_24C516478;
  if (v3)
    tbb::internal::task_scheduler_observer_v3::observe(v1, 0);
  _Unwind_Resume(exception_object);
}

void tbb::internal::destroy_binding_observer(tbb::internal::task_scheduler_observer_v3 *a1)
{
  tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
  if (a1)
    (*(void (**)(tbb::internal::task_scheduler_observer_v3 *))(*(_QWORD *)a1 + 24))(a1);
}

uint64_t tbb::internal::generic_scheduler::attach_arena(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  _QWORD *v5;

  *(_QWORD *)(result + 32) = a3;
  *(_QWORD *)(result + 40) = a2 + (a3 << 8) + 384;
  *(_QWORD *)(result + 48) = a2;
  v4 = a2 - ((unint64_t)(unsigned __int16)(a3 + 1) << 7);
  *(_QWORD *)(result + 64) = v4;
  *(_WORD *)(result + 72) = a3 + 1;
  if (a4)
  {
    if (a2 && *(_BYTE *)(v4 + 20))
      *(_BYTE *)(v4 + 20) = 0;
    v5 = (_QWORD *)(a2 + 272);
    *(_QWORD *)(result + 96) = a2 + 136;
    *(_QWORD *)(result + 104) = a2 + 272;
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(result + 144) - 56) = *(_QWORD *)(a2 + 320);
    v5 = *(_QWORD **)(result + 104);
  }
  *(_QWORD *)(result + 352) = *v5;
  return result;
}

uint64_t tbb::internal::arena::occupy_free_slot_in_range(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v11;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v16;

  if (a4 <= a3)
    return -1;
  v4 = *(_QWORD *)(a2 + 32);
  if (v4 < a3 || v4 >= a4)
  {
    v6 = *(unsigned int *)(a2 + 128);
    *(_DWORD *)(a2 + 128) = *(_DWORD *)(a2 + 132) - 1640531535 * v6;
    v4 = (v6 >> 16) % (a4 - a3) + a3;
  }
  if (v4 < a4)
  {
    v7 = v4;
    do
    {
      v8 = a1 + (v7 << 8);
      if (!*(_QWORD *)(v8 + 384))
      {
        v9 = (unint64_t *)(v8 + 384);
        do
        {
          while (!__ldaxr(v9))
          {
            if (!__stlxr(a2, v9))
              return v7;
          }
          __clrex();
          do
            v11 = __ldxr(v9);
          while (__stxr(v11, v9));
        }
        while (!v11);
      }
      ++v7;
    }
    while (v7 != a4);
  }
  if (v4 > a3)
  {
    while (1)
    {
      v13 = a1 + (a3 << 8);
      if (!*(_QWORD *)(v13 + 384))
        break;
LABEL_22:
      ++a3;
      v7 = -1;
      if (a3 == v4)
        return v7;
    }
    v14 = (unint64_t *)(v13 + 384);
    do
    {
      while (__ldaxr(v14))
      {
        __clrex();
        do
          v16 = __ldxr(v14);
        while (__stxr(v16, v14));
        if (v16)
          goto LABEL_22;
      }
    }
    while (__stlxr(a2, v14));
    return a3;
  }
  else
  {
    return -1;
  }
}

tbb::internal::market *tbb::internal::arena::process(tbb::internal::arena *this, tbb::internal::generic_scheduler *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  tbb::internal::observer_proxy **v7;
  char *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  tbb::internal::market *result;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;

  v4 = sub_20BDD026C(this, (unint64_t)a2);
  if (v4 != -1)
  {
    v5 = v4;
    *(_QWORD *)(*((_QWORD *)a2 + 18) - 56) = *((_QWORD *)this + 40);
    v7 = (tbb::internal::observer_proxy **)((char *)a2 + 88);
    v6 = *((_QWORD *)a2 + 11);
    v8 = (char *)this + 256 * v4 + 384;
    *((_QWORD *)a2 + 4) = v4;
    *((_QWORD *)a2 + 5) = v8;
    *((_QWORD *)a2 + 6) = this;
    *((_QWORD *)a2 + 8) = (char *)this - 128 * (unint64_t)(unsigned __int16)(v4 + 1);
    *((_WORD *)a2 + 36) = v4 + 1;
    *((_QWORD *)a2 + 44) = **((_QWORD **)a2 + 13);
    if (v6 != *((_QWORD *)this + 29))
    {
      tbb::internal::observer_list::do_notify_entry_observers((tbb::internal::observer_proxy **)this + 28, (tbb::internal::observer_proxy **)a2 + 11, 1);
      v8 = (char *)*((_QWORD *)a2 + 5);
    }
    if (*((_QWORD *)v8 + 1))
      (*(void (**)(tbb::internal::generic_scheduler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, *((_QWORD *)a2 + 18), 0);
    while (1)
    {
      v9 = *((_DWORD *)this + 33);
      __dmb(0xBu);
      if (*((_DWORD *)this + 32) < v9 >> 12)
        break;
      v10 = (*(uint64_t (**)(tbb::internal::generic_scheduler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 56))(a2, *((_QWORD *)a2 + 18) - 24, 0);
      if (v10)
      {
        v11 = *((_QWORD *)a2 + 18);
        *((_QWORD *)a2 + 7) = v11;
        (*(void (**)(tbb::internal::generic_scheduler *, uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, v11, v10);
      }
    }
    if (*v7)
      tbb::internal::observer_list::do_notify_exit_observers((tbb::internal::observer_proxy **)this + 28, *v7, 1);
    *((_QWORD *)a2 + 11) = 0;
    if (*((_QWORD *)a2 + 42))
    {
      v12 = (unint64_t *)((char *)this + 288);
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 + 1, v12));
      v14 = (unint64_t *)((char *)this + 280);
      do
      {
        v16 = *v14;
        **((_QWORD **)a2 + 43) = *v14;
        v17 = *((_QWORD *)a2 + 42);
        do
        {
          while (1)
          {
            v18 = __ldaxr(v14);
            if (v18 == v16)
              break;
            __clrex();
            do
              v15 = __ldxr(v14);
            while (__stxr(v15, v14));
            if (v15 != v16)
              goto LABEL_16;
          }
        }
        while (__stlxr(v17, v14));
        v15 = v16;
LABEL_16:
        ;
      }
      while (v16 != v15);
      *((_QWORD *)a2 + 42) = 0;
    }
    __dmb(0xBu);
    *((_QWORD *)this + 32 * v5 + 48) = 0;
    *((_QWORD *)a2 + 5) = 0;
    *((_QWORD *)a2 + 8) = 0;
  }
  result = (tbb::internal::market *)*((_QWORD *)this + 38);
  v20 = *((_QWORD *)this + 39);
  v21 = (unsigned int *)((char *)this + 132);
  do
  {
    v22 = __ldaxr(v21);
    v23 = v22 - 4096;
  }
  while (__stlxr(v23, v21));
  if (!v23)
    return (tbb::internal::market *)tbb::internal::market::try_destroy_arena(result, this, v20);
  return result;
}

uint64_t sub_20BDD026C(_DWORD *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  unint64_t v7;
  _DWORD *v8;
  unint64_t *v9;
  unint64_t v11;
  _DWORD *v12;
  unint64_t *v13;
  unint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;

  v2 = a1[83];
  v3 = a1[82];
  if (v2 >= v3)
    return -1;
  v4 = *(_QWORD *)(a2 + 32);
  if (v4 < v2 || v4 >= v3)
  {
    v6 = *(unsigned int *)(a2 + 128);
    *(_DWORD *)(a2 + 128) = *(_DWORD *)(a2 + 132) - 1640531535 * v6;
    v4 = (v6 >> 16) % (v3 - v2) + v2;
  }
  if (v4 < v3)
  {
    v7 = v4;
    while (1)
    {
      v8 = &a1[64 * v7];
      if (!*((_QWORD *)v8 + 48))
        break;
LABEL_10:
      if (++v7 == v3)
        goto LABEL_19;
    }
    v9 = (unint64_t *)(v8 + 96);
    do
    {
      while (__ldaxr(v9))
      {
        __clrex();
        do
          v11 = __ldxr(v9);
        while (__stxr(v11, v9));
        if (v11)
          goto LABEL_10;
      }
    }
    while (__stlxr(a2, v9));
    v2 = v7;
LABEL_31:
    if (v2 != -1)
    {
      v18 = a1[36];
      v16 = a1 + 36;
      v17 = v18;
      v19 = v2 + 1;
      while (1)
      {
        __dmb(0xBu);
        if (v17 >= v19)
          break;
        do
        {
          while (1)
          {
            v20 = __ldaxr(v16);
            if (v20 != v17)
              break;
            if (!__stlxr(v19, v16))
              return v2;
          }
          __clrex();
        }
        while (*v16 == v17);
        v17 = *v16;
      }
      return v2;
    }
    return -1;
  }
LABEL_19:
  if (v4 <= v2)
    return -1;
  do
  {
    v12 = &a1[64 * v2];
    if (!*((_QWORD *)v12 + 48))
    {
      v13 = (unint64_t *)(v12 + 96);
      do
      {
        while (!__ldaxr(v13))
        {
          if (!__stlxr(a2, v13))
            goto LABEL_31;
        }
        __clrex();
        do
          v15 = __ldxr(v13);
        while (__stxr(v15, v13));
      }
      while (!v15);
    }
    ++v2;
  }
  while (v2 != v4);
  return -1;
}

uint64_t tbb::internal::arena::orphan_offloaded_tasks(uint64_t result, uint64_t a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = (unint64_t *)(result + 288);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 + 1, v2));
  v4 = (unint64_t *)(result + 280);
  do
  {
    v6 = *v4;
    **(_QWORD **)(a2 + 344) = *v4;
    v7 = *(_QWORD *)(a2 + 336);
    do
    {
      while (1)
      {
        v8 = __ldaxr(v4);
        if (v8 == v6)
          break;
        __clrex();
        do
          v5 = __ldxr(v4);
        while (__stxr(v5, v4));
        if (v5 != v6)
          goto LABEL_5;
      }
    }
    while (__stlxr(v7, v4));
    v5 = v6;
LABEL_5:
    ;
  }
  while (v6 != v5);
  *(_QWORD *)(a2 + 336) = 0;
  return result;
}

tbb::internal::arena *tbb::internal::arena::arena(tbb::internal::arena *this, tbb::internal::market *a2, unsigned int a3, int a4)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v10;
  _DWORD *v11;
  int v12;
  uint64_t v13;
  char *v14;

  *(_OWORD *)((char *)this + 152) = 0u;
  *((_DWORD *)this + 50) = 0;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_BYTE *)this + 345) = 0;
  *((_QWORD *)this + 45) = (char *)this + 360;
  *((_QWORD *)this + 46) = (char *)this + 360;
  *((_QWORD *)this + 44) = 0;
  *((_DWORD *)this + 94) = 0;
  *((_QWORD *)this + 38) = a2;
  __dmb(0xBu);
  *((_DWORD *)this + 36) = 1;
  if (a3 <= 2)
    v5 = 2;
  else
    v5 = a3;
  *((_DWORD *)this + 82) = v5;
  *((_DWORD *)this + 83) = a4;
  *((_DWORD *)this + 52) = a3 - a4;
  __dmb(0xBu);
  *((_DWORD *)this + 33) = 1;
  *((_QWORD *)this + 17) = 1;
  *((_QWORD *)this + 33) = *((_QWORD *)this + 17);
  *((_QWORD *)this + 39) = *((_QWORD *)a2 + 24);
  *((_QWORD *)this + 31) = this;
  v6 = *((unsigned int *)this + 82);
  if ((_DWORD)v6)
  {
    if ((_DWORD)v6 == 1)
    {
      v7 = 0;
LABEL_7:
      v8 = (_DWORD *)((char *)this + 256 * v7 + 512);
      do
      {
        *v8 = v7;
        ((_QWORD *)this - 16 * (unint64_t)(unsigned __int16)(v7 + 1))[1] = (char *)this
                                                                                - 128
                                                                                * (unint64_t)(unsigned __int16)(v7 + 1);
        v8 += 64;
        ++v7;
      }
      while (v6 != v7);
      goto LABEL_9;
    }
    v7 = 0;
    if (!(_WORD)v6)
      goto LABEL_7;
    if ((unint64_t)(v6 - 1) >> 16)
      goto LABEL_7;
    v10 = 0;
    v7 = v6 & 0xFFFFFFFE;
    v11 = (_DWORD *)((char *)this + 768);
    do
    {
      v12 = v10 + 1;
      *(v11 - 64) = v10;
      v13 = v10 + 2;
      v14 = (char *)this + ((~(_DWORD)v10 << 7) | 0xFFFFFFFFFF800080);
      *((_QWORD *)v14 + 1) = v14;
      ((_QWORD *)this - 16 * (unint64_t)((unsigned __int16)v13 & 0xFFFE))[1] = (char *)this
                                                                                    - 128
                                                                                    * (unint64_t)((unsigned __int16)v13 & 0xFFFE);
      *v11 = v12;
      v11 += 128;
      v10 = v13;
    }
    while (v7 != v13);
    if (v7 != v6)
      goto LABEL_7;
  }
LABEL_9:
  sub_20BDD05CC((uint64_t)this + 152, v6);
  *((_WORD *)this + 168) = 0;
  return this;
}

void sub_20BDD05B0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  void *v4;

  tbb::internal::concurrent_monitor::~concurrent_monitor((tbb::internal::concurrent_monitor *)(v2 + 344));
  sub_20BDD2B84(v1, v4);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDD05CC(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  char v6;
  uint64_t v7;
  unint64_t v8;
  size_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *result;
  _QWORD *v17;

  if (a2 <= 0x3F)
  {
    v3 = 2;
    if (a2 >= 3)
    {
      v4 = a2 - 1;
      if (a2 >= 0x11)
        v4 >>= 4;
      if (v4 >= 4)
        v5 = v4 >> 2;
      else
        LOBYTE(v5) = v4;
      if (v4 >= 4)
        v6 = (4 * (a2 > 0x10)) | 2;
      else
        v6 = 4 * (a2 > 0x10);
      v3 = 2 << (v6 & 0xFE | ((v5 & 2) != 0));
    }
  }
  else
  {
    v3 = 64;
  }
  *(_DWORD *)(a1 + 48) = v3;
  v7 = v3;
  v8 = (unint64_t)v3 << 7;
  v9 = v8 | 0x10;
  v10 = operator new[](v9);
  *v10 = 128;
  v10[1] = v7;
  v11 = v10 + 2;
  do
  {
    *((_BYTE *)v11 + 48) = 0;
    *((_OWORD *)v11 + 1) = 0uLL;
    *((_OWORD *)v11 + 2) = 0uLL;
    *(_OWORD *)v11 = 0uLL;
    v11 += 16;
    v8 -= 128;
  }
  while (v8);
  *(_QWORD *)(a1 + 24) = v10 + 2;
  v12 = operator new[](v9);
  *v12 = 128;
  v12[1] = v7;
  v13 = v7 << 7;
  v14 = v7 << 7;
  v15 = v12 + 2;
  do
  {
    *((_BYTE *)v15 + 48) = 0;
    *((_OWORD *)v15 + 1) = 0uLL;
    *((_OWORD *)v15 + 2) = 0uLL;
    *(_OWORD *)v15 = 0uLL;
    v15 += 16;
    v14 -= 128;
  }
  while (v14);
  *(_QWORD *)(a1 + 32) = v12 + 2;
  result = operator new[](v9);
  *result = 128;
  result[1] = v7;
  v17 = result + 2;
  do
  {
    *((_BYTE *)v17 + 48) = 0;
    *((_OWORD *)v17 + 1) = 0uLL;
    *((_OWORD *)v17 + 2) = 0uLL;
    *(_OWORD *)v17 = 0uLL;
    v17 += 16;
    v13 -= 128;
  }
  while (v13);
  *(_QWORD *)(a1 + 40) = result + 2;
  return result;
}

tbb::internal::arena *tbb::internal::arena::allocate_arena(tbb::internal::arena *this, tbb::internal::market *a2, int a3, void *a4)
{
  unsigned int v5;
  uint64_t v7;
  size_t v8;
  char *v9;

  v5 = a2;
  if (a2 <= 2)
    v7 = 2;
  else
    v7 = a2;
  v8 = 384 * (int)v7 + 384;
  v9 = (char *)tbb::internal::NFS_Allocate(1uLL, v8, 0, a4);
  bzero(v9, v8);
  return tbb::internal::arena::arena((tbb::internal::arena *)&v9[128 * v7], this, v5, a3);
}

uint64_t tbb::internal::arena::free_arena(tbb::internal::arena *this, void *a2)
{
  unint64_t v3;
  char *v4;
  tbb::internal *v5;
  char *v6;
  uint64_t *v7;
  uint64_t i;
  void *v9;
  tbb::internal *v10;
  void *v11;
  void *v12;

  if (*((_DWORD *)this + 82))
  {
    v3 = 0;
    do
    {
      v4 = (char *)this + 256 * v3;
      v5 = (tbb::internal *)*((_QWORD *)v4 + 67);
      if (v5)
      {
        v6 = v4 + 384;
        tbb::internal::NFS_Free(v5, a2);
        *((_QWORD *)v6 + 18) = 0;
        *((_QWORD *)v6 + 19) = 0;
      }
      v7 = (uint64_t *)((char *)this - 128 * (unint64_t)(unsigned __int16)++v3);
      for (i = *v7; *v7; i = *v7)
      {
        *v7 = *(_QWORD *)(i + 16);
        tbb::internal::NFS_Free((tbb::internal *)(i - 64), a2);
      }
    }
    while (v3 < *((unsigned int *)this + 82));
  }
  tbb::internal::market::release(*((tbb::internal::market **)this + 38), 0, 0);
  tbb::task_group_context::~task_group_context(*((tbb::task_group_context **)this + 40));
  tbb::internal::NFS_Free(*((tbb::internal **)this + 40), v9);
  if (*((_QWORD *)this + 28))
    tbb::internal::observer_list::clear((tbb::internal::arena *)((char *)this + 224));
  v10 = (tbb::internal::arena *)((char *)this - 128 * (unint64_t)*((unsigned __int16 *)this + 164));
  tbb::internal::concurrent_monitor::~concurrent_monitor((tbb::internal::arena *)((char *)this + 344));
  sub_20BDD2B84((_QWORD *)this + 19, v11);
  return tbb::internal::NFS_Free(v10, v12);
}

BOOL tbb::internal::arena::has_enqueued_tasks(tbb::internal::arena *this)
{
  if (*((_QWORD *)this + 19))
    return 1;
  if (*((_QWORD *)this + 20))
    return 1;
  return *((_QWORD *)this + 21) != 0;
}

_QWORD *tbb::internal::arena::restore_priority_if_need(_QWORD *this)
{
  _QWORD *v1;

  v1 = this;
  if (this[19] || this[20] || this[21])
  {
    this = (_QWORD *)sub_20BDD095C((uint64_t)this);
    if (v1[19] && ((uint64_t)v1[33] > 0 || (v1[17] & 0x8000000000000000) != 0))
      this = (_QWORD *)tbb::internal::market::update_arena_priority(v1[38], (uint64_t)v1, 0);
    if (v1[20] && ((uint64_t)v1[33] > 1 || (uint64_t)v1[17] <= 0))
      this = (_QWORD *)tbb::internal::market::update_arena_priority(v1[38], (uint64_t)v1, 1);
    if (v1[21] && ((uint64_t)v1[33] > 2 || (uint64_t)v1[17] <= 1))
      return (_QWORD *)tbb::internal::market::update_arena_priority(v1[38], (uint64_t)v1, 2);
  }
  return this;
}

uint64_t sub_20BDD095C(uint64_t result)
{
  uint64_t v1;
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v12;

  v1 = result;
  v2 = *(_DWORD *)(*(_QWORD *)(result + 304) + 28);
  __dmb(0xBu);
  if (!v2)
  {
    v3 = *(unsigned __int8 *)(result + 337);
    __dmb(0xBu);
    if ((v3 & 1) == 0)
      result = tbb::internal::market::enable_mandatory_concurrency(*(_QWORD *)(result + 304), result);
  }
  if (!*(_DWORD *)(v1 + 208) && *(_DWORD *)(v1 + 332) == 1)
  {
    *(_BYTE *)(v1 + 336) = 1;
    __dmb(0xBu);
    *(_QWORD *)(v1 + 216) = -1;
    *(_DWORD *)(v1 + 208) = 1;
    v4 = *(_QWORD *)(v1 + 304);
    v5 = v1;
    v6 = 1;
    return tbb::internal::market::adjust_demand(v4, v5, v6);
  }
  __dmb(0xBu);
  v7 = (unint64_t *)(v1 + 216);
  v8 = *(_QWORD *)(v1 + 216);
  __dmb(0xBu);
  if (v8 != -1)
  {
    do
    {
      while (1)
      {
        v9 = __ldaxr(v7);
        if (v9 == v8)
          break;
        __clrex();
        do
          v10 = __ldxr(v7);
        while (__stxr(v10, v7));
        if (v10 != v8)
        {
          if (v10)
            return result;
          goto LABEL_17;
        }
      }
    }
    while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v7));
    if (v8)
      return result;
LABEL_17:
    if (!v8)
    {
LABEL_25:
      v4 = *(_QWORD *)(v1 + 304);
      v6 = *(_DWORD *)(v1 + 208);
      v5 = v1;
      return tbb::internal::market::adjust_demand(v4, v5, v6);
    }
    do
    {
      while (!__ldaxr(v7))
      {
        if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v7))
          goto LABEL_25;
      }
      __clrex();
      do
        v12 = __ldxr(v7);
      while (__stxr(v12, v7));
    }
    while (!v12);
  }
  return result;
}

uint64_t tbb::internal::arena::is_out_of_work(tbb::internal::arena *this)
{
  uint64_t v1;
  unint64_t *v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v7;
  uint64_t v8;
  int64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  BOOL v13;
  uint64_t v14;
  char v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  _BOOL4 v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  BOOL v32;
  _BOOL4 v33;
  int64_t v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;

  v2 = (unint64_t *)((char *)this + 216);
  v1 = *((_QWORD *)this + 27);
  __dmb(0xBu);
  if (!v1)
    return 1;
  if (v1 != -1)
    return 0;
  v44 = (uint64_t)&v44;
  do
  {
    while (1)
    {
      v4 = __ldaxr(v2);
      if (v4 == -1)
        break;
      __clrex();
      do
        v5 = __ldxr(v2);
      while (__stxr(v5, v2));
      if (v5 != -1)
        return 0;
    }
  }
  while (__stlxr((unint64_t)&v44, v2));
  v7 = *((unsigned int *)this + 36);
  __dmb(0xBu);
  v8 = *((_QWORD *)this + 34);
  __dmb(0xBu);
  v9 = *((_QWORD *)this + 17);
  v10 = 0;
  if ((_DWORD)v7)
  {
    v11 = (_QWORD *)((char *)this + 392);
    while (!*v11 || v11[1] >= v11[16])
    {
      v12 = *v2;
      __dmb(0xBu);
      if (v12 != v44)
        return 0;
      ++v10;
      v11 += 32;
      if (v7 == v10)
        goto LABEL_18;
    }
  }
  if (v10 != v7)
  {
    v23 = *v2;
    __dmb(0xBu);
    if (v23 == v44)
      goto LABEL_73;
    return 0;
  }
LABEL_18:
  v13 = *((_QWORD *)this + 35) != 0;
  v14 = *((_QWORD *)this + 36);
  __dmb(0xBu);
LABEL_19:
  v15 = 8 * (&tbb::internal::the_context_state_propagation_mutex & 3);
  v16 = *(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v15);
  v17 = v16 | (1 << v15);
  do
  {
    while (1)
    {
      v18 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL));
      if (v18 == v16)
        break;
      __clrex();
      if (*(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) != v16)
      {
        sched_yield();
        goto LABEL_19;
      }
    }
  }
  while (__stlxr(v17, (unsigned int *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL)));
  v19 = *((_QWORD *)this + 48);
  if (v19 && *(tbb::internal::arena **)(v19 + 48) == this)
  {
    v28 = *(_BYTE *)(v19 + 74) & 3;
    v20 = v28 == 2;
    if (!*(_BYTE *)(v19 + 360))
    {
      if (!*(_QWORD *)(v19 + 336))
        goto LABEL_28;
      if (*(_QWORD *)(v19 + 352) >= **(_QWORD **)(v19 + 104))
      {
        v13 = 1;
        goto LABEL_28;
      }
    }
    v22 = 0;
    v20 = v28 == 2;
    __dmb(0xBu);
    LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
LABEL_44:
    v13 = 1;
    goto LABEL_46;
  }
  v20 = 0;
LABEL_28:
  __dmb(0xBu);
  LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
  if (v7 >= 2)
  {
    v24 = 1;
    v25 = 640;
    do
    {
      v26 = *v2;
      __dmb(0xBu);
      if (v26 != v44)
        return 0;
      v27 = *(_QWORD *)((char *)this + v25);
      if (v27 && *(tbb::internal::arena **)(v27 + 48) == this)
      {
        v20 |= (*(_BYTE *)(v27 + 74) & 3) == 2;
        if (*(_BYTE *)(v27 + 360))
        {
          v22 = 0;
          goto LABEL_44;
        }
        if (*(_QWORD *)(v27 + 336))
        {
          v13 = 1;
          if (*(_QWORD *)(v27 + 352) < **(_QWORD **)(v27 + 104))
            goto LABEL_30;
        }
      }
      ++v24;
      v25 += 256;
    }
    while (v24 < v7);
  }
  v21 = *((_QWORD *)this + 35);
  __dmb(0xBu);
  if (v21)
  {
LABEL_30:
    v22 = 0;
  }
  else
  {
    v29 = *((_QWORD *)this + 36);
    __dmb(0xBu);
    v22 = v14 == v29;
  }
LABEL_46:
  v30 = *v2;
  __dmb(0xBu);
  if (v30 != v44)
    return 0;
  v31 = *((_QWORD *)this + (int)v9 + 19);
  if (v20)
    v32 = v31 == 0;
  else
    v32 = 1;
  v33 = v32 && v22;
  if (!v33 || v9 != *((_QWORD *)this + 17) || v8 != *((_QWORD *)this + 34))
    goto LABEL_73;
  if (v9 > *((_QWORD *)this + 33))
  {
    if (tbb::internal::market::lower_arena_priority(*((_QWORD *)this + 38), (uint64_t)this, v9 - 1, v8))
    {
      if (*((_QWORD *)this + (int)v9 + 19))
      {
        v34 = *((_QWORD *)this + 37);
        __dmb(0xBu);
        if (v34 < v9)
        {
          v35 = (unint64_t *)((char *)this + 296);
          while (1)
          {
            while (1)
            {
              v36 = __ldaxr(v35);
              if (v36 != v34)
                break;
              if (!__stlxr(v9, v35))
                goto LABEL_73;
            }
            __clrex();
            do
              v37 = __ldxr(v35);
            while (__stxr(v37, v35));
            if (v37 != v34)
            {
              v34 = *v35;
              __dmb(0xBu);
              if (v34 >= v9)
                break;
            }
          }
        }
      }
    }
    goto LABEL_73;
  }
  if (v13 || *((_QWORD *)this + 35) || v31)
  {
LABEL_73:
    v38 = v44;
    do
    {
      while (1)
      {
        v39 = __ldaxr(v2);
        if (v39 != v38)
          break;
        if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v2))
          return 0;
      }
      __clrex();
      do
        v40 = __ldxr(v2);
      while (__stxr(v40, v2));
    }
    while (v40 == v38);
    return 0;
  }
  v41 = *((_DWORD *)this + 52);
  do
  {
    while (1)
    {
      v42 = __ldaxr(v2);
      if (v42 != v30)
        break;
      if (!__stlxr(0, v2))
        goto LABEL_89;
    }
    __clrex();
    do
      v43 = __ldxr(v2);
    while (__stxr(v43, v2));
  }
  while (v43 == v30);
  v30 = v43;
LABEL_89:
  if (v30 != v44)
    return 0;
  tbb::internal::market::adjust_demand(*((_QWORD *)this + 38), (uint64_t)this, -v41);
  tbb::internal::arena::restore_priority_if_need(this);
  return 1;
}

uint64_t tbb::internal::arena::enqueue_task(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v5;
  uint64_t result;

  *(_BYTE *)(a2 - 12) = 2;
  *(_BYTE *)(a2 - 11) |= 0x10u;
  if (a3)
    v5 = ((int)a3 - 0x1FFFFFFF) / 0x1FFFFFFF;
  else
    v5 = 1;
  sub_20BDD0F84(a1 + 19, a2, v5, a4);
  if (v5 != a1[17])
    tbb::internal::market::update_arena_priority(a1[38], (uint64_t)a1, v5);
  result = sub_20BDD095C((uint64_t)a1);
  if (v5 != a1[17])
    return tbb::internal::market::update_arena_priority(a1[38], (uint64_t)a1, v5);
  return result;
}

uint64_t *sub_20BDD0F84(uint64_t *result, uint64_t a2, int a3, unsigned int *a4)
{
  uint64_t *v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  int v12;
  int v13;
  unsigned int v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;

  v6 = result;
  v26 = a3;
  v7 = &result[a3 + 3];
LABEL_2:
  v8 = *a4;
  *a4 = a4[1] - 1640531535 * *a4;
  v9 = (*((_DWORD *)v6 + 12) - 1) & HIWORD(v8);
  v10 = *v7 + (v9 << 7) + 48;
  v11 = (unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
  v12 = 255 << (8 * (v10 & 3));
LABEL_3:
  v13 = *v11 & ~v12;
  do
  {
    while (1)
    {
      v14 = __ldaxr(v11);
      if (v14 == v13)
        break;
      __clrex();
      if (*v11 != v13)
      {
        if ((*v11 & v12) != 0)
          goto LABEL_2;
        result = (uint64_t *)sched_yield();
        goto LABEL_3;
      }
    }
  }
  while (__stlxr(v13 | (1 << (8 * (v10 & 3))), v11));
  v15 = (_QWORD *)(*v7 + (v9 << 7));
  v16 = v15[2];
  v17 = v15[1];
  if (v16 == v17)
    v18 = 0;
  else
    v18 = ((v16 - v17) << 6) - 1;
  v19 = v15[5];
  v20 = v19 + v15[4];
  if (v18 == v20)
  {
    result = sub_20BDD3028((uint64_t *)(*v7 + (v9 << 7)));
    v17 = v15[1];
    v19 = v15[5];
    v20 = v15[4] + v19;
  }
  *(_QWORD *)(*(_QWORD *)(v17 + ((v20 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v20 & 0x1FF)) = a2;
  v15[5] = v19 + 1;
  v21 = (unint64_t *)&v6[v26];
LABEL_16:
  v22 = *v21;
  v23 = *v21 | (1 << v9);
  do
  {
    while (1)
    {
      v24 = __ldaxr(v21);
      if (v24 == v22)
        break;
      __clrex();
      do
        v25 = __ldxr(v21);
      while (__stxr(v25, v21));
      if (v25 != v22)
      {
        result = (uint64_t *)sched_yield();
        goto LABEL_16;
      }
    }
  }
  while (__stlxr(v23, v21));
  __dmb(0xBu);
  *(_BYTE *)v10 = 0;
  return result;
}

void sub_20BDD1140(_Unwind_Exception *a1)
{
  _BYTE *v1;

  __dmb(0xBu);
  *v1 = 0;
  _Unwind_Resume(a1);
}

void tbb::internal::generic_scheduler::nested_arena_entry(tbb::internal::generic_scheduler *this, tbb::internal::arena *a2, unint64_t a3)
{
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  tbb::internal::observer_proxy **v15;

  if (*((_QWORD *)this + 42))
  {
    v5 = *((_QWORD *)this + 6);
    v6 = (unint64_t *)(v5 + 288);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
    v8 = (unint64_t *)(v5 + 280);
    do
    {
      v10 = *v8;
      **((_QWORD **)this + 43) = *v8;
      v11 = *((_QWORD *)this + 42);
      do
      {
        while (1)
        {
          v12 = __ldaxr(v8);
          if (v12 == v10)
            break;
          __clrex();
          do
            v9 = __ldxr(v8);
          while (__stxr(v9, v8));
          if (v9 != v10)
            goto LABEL_6;
        }
      }
      while (__stlxr(v11, v8));
      v9 = v10;
LABEL_6:
      ;
    }
    while (v10 != v9);
  }
  *((_QWORD *)this + 42) = 0;
  *((_QWORD *)this + 4) = a3;
  *((_QWORD *)this + 5) = (char *)a2 + 256 * a3 + 384;
  *((_QWORD *)this + 6) = a2;
  v13 = (char *)a2 - 128 * (unint64_t)(unsigned __int16)(a3 + 1);
  *((_QWORD *)this + 8) = v13;
  *((_WORD *)this + 36) = a3 + 1;
  if (a2 && v13[20])
    v13[20] = 0;
  *((_QWORD *)this + 12) = (char *)a2 + 136;
  *((_QWORD *)this + 13) = (char *)a2 + 272;
  *((_QWORD *)this + 44) = *((_QWORD *)a2 + 34);
  tbb::internal::governor::assume_scheduler((uint64_t)this);
  v14 = *((_QWORD *)this + 6);
  if ((*((_BYTE *)this + 74) & 1) != 0 && *(unsigned int *)(v14 + 332) <= a3)
  {
    tbb::internal::market::adjust_demand(*(_QWORD *)(v14 + 304), v14, -1);
    v14 = *((_QWORD *)this + 6);
  }
  *((_QWORD *)this + 11) = 0;
  v15 = (tbb::internal::observer_proxy **)((char *)this + 88);
  if (*(_QWORD *)(v14 + 232))
    tbb::internal::observer_list::do_notify_entry_observers((tbb::internal::observer_proxy **)(v14 + 224), v15, 0);
}

uint64_t tbb::internal::generic_scheduler::nested_arena_exit(tbb::internal::generic_scheduler *this)
{
  tbb::internal::observer_proxy *v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;

  v2 = (tbb::internal::observer_proxy *)*((_QWORD *)this + 11);
  if (v2)
    tbb::internal::observer_list::do_notify_exit_observers((tbb::internal::observer_proxy **)(*((_QWORD *)this + 6) + 224), v2, 0);
  if (*((_QWORD *)this + 42))
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (unint64_t *)(v3 + 288);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
    v6 = (unint64_t *)(v3 + 280);
    do
    {
      v8 = *v6;
      **((_QWORD **)this + 43) = *v6;
      v9 = *((_QWORD *)this + 42);
      do
      {
        while (1)
        {
          v10 = __ldaxr(v6);
          if (v10 == v8)
            break;
          __clrex();
          do
            v7 = __ldxr(v6);
          while (__stxr(v7, v6));
          if (v7 != v8)
            goto LABEL_8;
        }
      }
      while (__stlxr(v9, v6));
      v7 = v8;
LABEL_8:
      ;
    }
    while (v8 != v7);
    *((_QWORD *)this + 42) = 0;
  }
  v11 = *((_QWORD *)this + 6);
  v12 = *((_QWORD *)this + 4);
  if ((*((_BYTE *)this + 74) & 1) != 0 && v12 >= *(unsigned int *)(v11 + 332))
  {
    tbb::internal::market::adjust_demand(*(_QWORD *)(v11 + 304), v11, 1);
    v11 = *((_QWORD *)this + 6);
    v12 = *((_QWORD *)this + 4);
  }
  __dmb(0xBu);
  *(_QWORD *)(v11 + (v12 << 8) + 384) = 0;
  v13 = *((_QWORD *)this + 6) + 344;
  __dmb(0xBu);
  return tbb::internal::concurrent_monitor::notify_one_relaxed(v13);
}

_QWORD *tbb::internal::generic_scheduler::wait_until_empty(_QWORD *this)
{
  _QWORD *v1;
  uint64_t i;
  uint64_t v3;

  v1 = this;
  ++*(_QWORD *)(this[18] - 24);
  for (i = this[6]; ; i = v1[6])
  {
    v3 = *(_QWORD *)(i + 216);
    __dmb(0xBu);
    if (!v3)
      break;
    this = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD, _QWORD))(*v1 + 48))(v1, v1[18], 0);
  }
  --*(_QWORD *)(v1[18] - 24);
  return this;
}

void *tbb::interface7::internal::task_arena_base::internal_initialize(tbb::interface7::internal::task_arena_base *this)
{
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  tbb::internal::arena *arena;
  uint64_t v7;
  const char *v8;
  int64x2_t *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  tbb::internal::numa_topology *v18;
  unint64_t v20;
  uint64_t v21;
  tbb::internal::market *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  tbb::internal *v27;
  tbb::internal::task_scheduler_observer_v3 *v28;
  uint64_t v29;
  void *result;

  tbb::internal::governor::one_time_init((uint64_t)this);
  v4 = *((unsigned int *)this + 4);
  if ((int)v4 <= 0)
  {
    if ((*((_BYTE *)this + 24) & 1) != 0)
      v5 = *((unsigned int *)this + 9);
    else
      v5 = 0xFFFFFFFFLL;
    v4 = tbb::internal::numa_topology::default_concurrency((tbb::internal::numa_topology *)v5);
    *((_DWORD *)this + 4) = v4;
  }
  arena = tbb::internal::market::create_arena((tbb::internal::market *)v4, *((_DWORD *)this + 5), 0, v2, v3);
  v9 = tbb::internal::market::global_market(0, 0, 0, v7, v8);
  v11 = tbb::internal::NFS_Allocate(1uLL, 256, 0, v10);
  *(_DWORD *)v11 = 0;
  *(_QWORD *)(v11 + 128) = 65539;
  *(_DWORD *)(v11 + 168) = 55;
  tbb::task_group_context::init(v11, v12, v13, v14);
  *((_QWORD *)arena + 40) = v11;
  v18 = (tbb::internal::numa_topology *)tbb::task_group_context::capture_fp_settings((tbb::task_group_context *)v11, v15, v16, v17);
  do
  {
    while (__ldaxr((unint64_t *)this))
    {
      __clrex();
      do
        v20 = __ldxr((unint64_t *)this);
      while (__stxr(v20, (unint64_t *)this));
      if (v20)
      {
        tbb::internal::market::release((tbb::internal::market *)v9, 1, 0);
        v22 = (tbb::internal::market *)*((_QWORD *)arena + 38);
        v21 = *((_QWORD *)arena + 39);
        if (*((_DWORD *)arena + 82) != *((_DWORD *)arena + 83)
          && !*((_DWORD *)v22 + 7)
          && !*((_BYTE *)arena + 337)
          && (tbb::internal::arena::is_out_of_work(arena) & 1) == 0
          && (tbb::internal::arena::is_out_of_work(arena) & 1) == 0)
        {
          tbb::internal::arena::is_out_of_work(arena);
        }
        v23 = (unsigned int *)((char *)arena + 132);
        do
        {
          v24 = __ldaxr(v23);
          v25 = v24 - 1;
        }
        while (__stlxr(v25, v23));
        if (!v25)
          tbb::internal::market::try_destroy_arena(v22, arena, v21);
        while (!*((_QWORD *)this + 1))
          sched_yield();
        goto LABEL_33;
      }
    }
  }
  while (__stlxr((unint64_t)arena, (unint64_t *)this));
  if ((*((_BYTE *)this + 24) & 1) == 0
    || (v26 = *((_DWORD *)this + 9), v26 < 0)
    || (v27 = (tbb::internal *)*(unsigned int *)(*(_QWORD *)this + 328),
        tbb::internal::numa_topology::nodes_count(v18) < 2))
  {
    v28 = 0;
  }
  else
  {
    v28 = (tbb::internal::task_scheduler_observer_v3 *)operator new(0x30uLL);
    sub_20BDCFE1C((uint64_t)v28, (uint64_t)this, v26, v27);
    if (!*((_QWORD *)v28 + 1))
      *((_QWORD *)v28 + 2) = 0x8000000000000000;
    tbb::internal::task_scheduler_observer_v3::observe(v28, 1);
  }
  *(_QWORD *)(*(_QWORD *)this + 256) = v28;
  v29 = *((_QWORD *)arena + 40);
  *(_QWORD *)(v29 + 128) |= *((_QWORD *)this + 3) & 0x10000;
  __dmb(0xBu);
  *((_QWORD *)this + 1) = v29;
LABEL_33:
  result = pthread_getspecific(tbb::internal::governor::theTLS);
  if (!result)
    return (void *)tbb::internal::governor::init_scheduler_weak(0);
  return result;
}

void sub_20BDD1610(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t tbb::interface7::internal::task_arena_base::internal_terminate(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  tbb::internal::market *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v2 = this;
    v3 = *(_QWORD *)(v1 + 256);
    if (v3)
    {
      tbb::internal::task_scheduler_observer_v3::observe(*(tbb::internal::task_scheduler_observer_v3 **)(v1 + 256), 0);
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
      v1 = *(_QWORD *)v2;
      *(_QWORD *)(*(_QWORD *)v2 + 256) = 0;
    }
    this = tbb::internal::market::release(*(tbb::internal::market **)(v1 + 304), 1, 0);
    v4 = *(unsigned int **)v2;
    v6 = *(tbb::internal::market **)(*(_QWORD *)v2 + 304);
    v5 = *(_QWORD *)(*(_QWORD *)v2 + 312);
    if (*(_DWORD *)(*(_QWORD *)v2 + 328) != *(_DWORD *)(*(_QWORD *)v2 + 332)
      && !*((_DWORD *)v6 + 7)
      && !*((_BYTE *)v4 + 337))
    {
      this = tbb::internal::arena::is_out_of_work(*(tbb::internal::arena **)v2);
      if ((this & 1) == 0)
      {
        this = tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v4);
        if ((this & 1) == 0)
          this = tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v4);
      }
    }
    v7 = v4 + 33;
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      this = tbb::internal::market::try_destroy_arena(v6, (tbb::internal::arena *)v4, v5);
    *(_QWORD *)v2 = 0;
    *(_QWORD *)(v2 + 8) = 0;
  }
  return this;
}

int64x2_t *tbb::interface7::internal::task_arena_base::internal_attach(tbb::interface7::internal::task_arena_base *this)
{
  int64x2_t *result;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;

  result = (int64x2_t *)pthread_getspecific(tbb::internal::governor::theTLS);
  if (((unint64_t)result & 0xFFFFFFFFFFFFFFFELL) != 0)
  {
    v5 = *(_QWORD *)(((unint64_t)result & 0xFFFFFFFFFFFFFFFELL) + 48);
    if (v5)
    {
      *(_QWORD *)this = v5;
      v6 = (unsigned int *)(v5 + 132);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 + 1, v6));
      v8 = *(_QWORD *)this;
      v9 = *(_QWORD *)(*(_QWORD *)this + 320);
      *((_QWORD *)this + 1) = v9;
      *((_QWORD *)this + 3) |= *(_QWORD *)(v9 + 128) & 0x10000;
      LODWORD(v9) = *(_DWORD *)(v8 + 332);
      *((_DWORD *)this + 4) = *(_DWORD *)(v8 + 208) + v9;
      *((_DWORD *)this + 5) = v9;
      return tbb::internal::market::global_market(1, 0, 0, v3, v4);
    }
  }
  return result;
}

uint64_t tbb::interface7::internal::task_arena_base::internal_enqueue(tbb::interface7::internal::task_arena_base *this, tbb::task *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t inited;
  _QWORD *v8;
  uint64_t v9;
  uint64_t result;

  v6 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v6)
    inited = v6 & 0xFFFFFFFFFFFFFFFELL;
  else
    inited = tbb::internal::governor::init_scheduler_weak(0);
  v8 = *(_QWORD **)this;
  *((_BYTE *)a2 - 12) = 2;
  *((_BYTE *)a2 - 11) |= 0x10u;
  if (a3)
    v9 = ((int)a3 - 0x1FFFFFFF) / 0x1FFFFFFF;
  else
    v9 = 1;
  sub_20BDD0F84(v8 + 19, (uint64_t)a2, v9, (unsigned int *)(inited + 128));
  if (v9 != v8[17])
    tbb::internal::market::update_arena_priority(v8[38], (uint64_t)v8, v9);
  result = sub_20BDD095C((uint64_t)v8);
  if (v9 != v8[17])
    return tbb::internal::market::update_arena_priority(v8[38], (uint64_t)v8, v9);
  return result;
}

void tbb::interface7::internal::task_arena_base::internal_execute(tbb::interface7::internal::task_arena_base *a1, void (***a2)(_QWORD))
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t inited;
  unint64_t v9;
  __int128 *v10;
  tbb::internal::arena *v11;
  tbb::internal::arena *v12;
  void *v13;
  _DWORD *v14;
  uint64_t v15;
  _OWORD *v16;
  tbb::internal::arena *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  __int128 v26;
  __int128 v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  _QWORD *task;
  tbb::internal::arena *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  tbb::internal::arena *v44;
  unint64_t v45;
  tbb::internal::arena *v46;
  uint64_t v47;
  tbb::internal *v48;
  tbb::internal::arena *v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  std::exception_ptr *v57;
  std::exception_ptr v58;
  std::exception_ptr v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  char v66;
  _QWORD v67[2];
  semaphore_t semaphore;
  int v69;
  char v70;
  __int16 v71;
  char v72;
  uint64_t v73;
  tbb::task_group_context *v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;
  BOOL v81;
  uint64_t v82;
  std::exception_ptr *v83;
  int v84;
  uint64_t v85;

  v85 = *MEMORY[0x24BDAC8D0];
  v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4)
    inited = v4 & 0xFFFFFFFFFFFFFFFELL;
  else
    inited = tbb::internal::governor::init_scheduler_weak(0);
  v10 = (__int128 *)(inited + 32);
  v9 = *(_QWORD *)(inited + 32);
  v11 = *(tbb::internal::arena **)(inited + 48);
  v12 = *(tbb::internal::arena **)a1;
  if (v11 != *(tbb::internal::arena **)a1 && (v9 = sub_20BDD1FAC(*(_DWORD **)a1, inited), v9 == -1))
  {
    v28 = __dynamic_cast(a2, (const struct __class_type_info *)&unk_24C516388, (const struct __class_type_info *)&unk_24C5163B0, 0);
    if (v28)
    {
      v32 = v28;
      v74 = (tbb::task_group_context *)*((_QWORD *)a1 + 1);
      v33 = (_QWORD *)tbb::internal::allocate_root_with_context_proxy::allocate(&v74, 0x10uLL);
      v34 = (_QWORD *)v32[1];
      *((_BYTE *)v33 - 11) = 1;
      *v33 = &unk_24C516580;
      v33[1] = *v34;
      tbb::interface7::internal::task_arena_base::internal_enqueue(a1, (tbb::task *)v33, 0);
    }
    else
    {
      v67[0] = 3452816845;
      v67[1] = 3452816845;
      v71 = 0;
      v72 = 0;
      v73 = 0;
      v69 = 0;
      __dmb(0xBu);
      v70 = 0;
      v35 = *((_QWORD *)a1 + 3) & 0x10000;
      LODWORD(v74) = 0;
      v82 = v35 | 3;
      v84 = 55;
      tbb::task_group_context::init((uint64_t)&v74, v29, v30, v31);
      tbb::task_group_context::copy_fp_settings((tbb::task_group_context *)&v74, *((const tbb::task_group_context **)a1 + 1), v36, v37);
      task = (_QWORD *)tbb::internal::generic_scheduler::allocate_task((tbb::internal::generic_scheduler *)inited, 8uLL, 0, (tbb::task_group_context *)&v74);
      *((_BYTE *)task - 11) = 1;
      *task = &unk_24C5164A8;
      *(task - 3) = 2;
      v39 = *(tbb::internal::arena **)a1;
      v59.__ptr_ = &v74;
      v40 = (_QWORD *)tbb::internal::allocate_root_with_context_proxy::allocate((tbb::task_group_context **)&v59, 0x20uLL);
      v41 = *(_QWORD *)a1 + 344;
      *v40 = &unk_24C5164F0;
      v40[1] = a2;
      v40[2] = v41;
      v40[3] = task;
      *((_WORD *)v40 - 6) = 4354;
      sub_20BDD0F84((uint64_t *)v39 + 19, (uint64_t)v40, 1, (unsigned int *)(inited + 128));
      if (*((_QWORD *)v39 + 17) != 1)
        tbb::internal::market::update_arena_priority(*((_QWORD *)v39 + 38), (uint64_t)v39, 1);
      sub_20BDD095C((uint64_t)v39);
      if (*((_QWORD *)v39 + 17) != 1)
        tbb::internal::market::update_arena_priority(*((_QWORD *)v39 + 38), (uint64_t)v39, 1);
      while (1)
      {
        tbb::internal::concurrent_monitor::prepare_wait(*(_QWORD *)a1 + 344, (tbb::internal::concurrent_monitor::thread_context *)v67, (uint64_t)a2);
        v43 = *(task - 3);
        __dmb(0xBu);
        v44 = *(tbb::internal::arena **)a1;
        if (v43 <= 1)
        {
          tbb::internal::concurrent_monitor::cancel_wait((uint64_t)v44 + 344, (tbb::internal::concurrent_monitor::thread_context *)v67);
LABEL_36:
          v47 = *(_QWORD *)a1 + 344;
          __dmb(0xBu);
          v48 = (tbb::internal *)tbb::internal::concurrent_monitor::notify_one_relaxed(v47);
          goto LABEL_38;
        }
        v45 = sub_20BDD1FAC(v44, inited);
        v46 = *(tbb::internal::arena **)a1;
        if (v45 != -1)
          break;
        if (v69 == *((_DWORD *)v46 + 94))
        {
          while (MEMORY[0x212B93828](semaphore) == 14)
            ;
          if (HIBYTE(v71))
            tbb::internal::throw_exception_v4(18);
        }
        else
        {
          tbb::internal::concurrent_monitor::cancel_wait((uint64_t)v46 + 344, (tbb::internal::concurrent_monitor::thread_context *)v67);
        }
        v42 = *(task - 3);
        __dmb(0xBu);
        if (v42 != 2)
          goto LABEL_36;
      }
      tbb::internal::concurrent_monitor::cancel_wait((uint64_t)v46 + 344, (tbb::internal::concurrent_monitor::thread_context *)v67);
      v49 = *(tbb::internal::arena **)a1;
      v59.__ptr_ = (void *)inited;
      v66 = 0;
      v50 = *(_OWORD *)(inited + 48);
      v51 = *(_OWORD *)(inited + 64);
      v52 = *(_OWORD *)(inited + 96);
      v63 = *(_OWORD *)(inited + 80);
      v64 = v52;
      v61 = v50;
      v62 = v51;
      v60 = *v10;
      *(_BYTE *)(inited + 74) |= 3u;
      v53 = *(_QWORD *)(inited + 144);
      *(_QWORD *)(inited + 56) = v53;
      v65 = *(_QWORD *)(v53 - 56);
      v54 = v65;
      *(_QWORD *)(v53 - 56) = *((_QWORD *)v49 + 40);
      tbb::internal::generic_scheduler::nested_arena_entry((tbb::internal::generic_scheduler *)inited, v49, v45);
      (*(void (**)(uint64_t, _QWORD *, _QWORD))(*(_QWORD *)inited + 48))(inited, task, 0);
      *(_QWORD *)(*(_QWORD *)(inited + 144) - 56) = v54;
      tbb::internal::generic_scheduler::nested_arena_exit((tbb::internal::generic_scheduler *)inited);
      *v10 = v60;
      v55 = v64;
      *(_OWORD *)(inited + 80) = v63;
      *(_OWORD *)(inited + 96) = v55;
      v56 = v62;
      *(_OWORD *)(inited + 48) = v61;
      *(_OWORD *)(inited + 64) = v56;
      *(_QWORD *)(inited + 352) = **((_QWORD **)&v64 + 1);
      v48 = (tbb::internal *)tbb::internal::governor::assume_scheduler(inited);
LABEL_38:
      v57 = v83;
      if (v83)
      {
        if (tbb::internal::governor::is_rethrow_broken)
          tbb::internal::fix_broken_rethrow(v48);
        std::exception_ptr::exception_ptr(&v59, v57);
        v58.__ptr_ = &v59;
        std::rethrow_exception(v58);
        __break(1u);
      }
      else
      {
        *((_BYTE *)task - 12) = 4;
        *(task - 1) = *(_QWORD *)(inited + 136);
        *(_QWORD *)(inited + 136) = task;
        tbb::task_group_context::~task_group_context((tbb::task_group_context *)&v74);
        if (v72)
        {
          if ((_BYTE)v71)
          {
            while (MEMORY[0x212B93828](semaphore) == 14)
              ;
          }
          semaphore_destroy(*MEMORY[0x24BDAEC58], semaphore);
        }
      }
    }
  }
  else
  {
    sub_20BDD22B4(&v59, v5, v6, v7);
    v14 = (_DWORD *)*((_QWORD *)a1 + 1);
    v15 = *((_QWORD *)v14 + 14);
    v16 = (_OWORD *)*((_QWORD *)&v60 + 1);
    if (*(_QWORD *)v15 != **((_QWORD **)&v60 + 1) || *(_QWORD *)(v15 + 8) != *(_QWORD *)(*((_QWORD *)&v60 + 1) + 8))
    {
      if (!*((_QWORD *)&v60 + 1))
      {
        v16 = (_OWORD *)tbb::internal::NFS_Allocate(1uLL, 16, 0, v13);
        *((_QWORD *)&v60 + 1) = v16;
        v15 = *((_QWORD *)v14 + 14);
      }
      *v16 = *(_OWORD *)v15;
      fesetenv(*((const fenv_t **)&v60 + 1));
    }
    v18 = *(tbb::internal::arena **)a1;
    v74 = (tbb::task_group_context *)inited;
    *(_QWORD *)&v77 = 0;
    v81 = v11 == v12;
    if (v11 == v12)
    {
      BYTE10(v77) = *(_BYTE *)(inited + 74);
      *((_QWORD *)&v76 + 1) = *(_QWORD *)(inited + 56);
      *(_BYTE *)(inited + 74) = BYTE10(v77) | 3;
      v24 = *(_QWORD *)(inited + 144);
      *(_QWORD *)(inited + 56) = v24;
      v23 = *(_QWORD *)(v24 - 56);
      v80 = v23;
      *(_QWORD *)(v24 - 56) = *((_QWORD *)v18 + 40);
    }
    else
    {
      v20 = *(_OWORD *)(inited + 48);
      v19 = *(_OWORD *)(inited + 64);
      v21 = *(_OWORD *)(inited + 96);
      v78 = *(_OWORD *)(inited + 80);
      v79 = v21;
      v76 = v20;
      v77 = v19;
      v75 = *v10;
      *(_BYTE *)(inited + 74) |= 3u;
      v22 = *(_QWORD *)(inited + 144);
      *(_QWORD *)(inited + 56) = v22;
      v23 = *(_QWORD *)(v22 - 56);
      v80 = v23;
      *(_QWORD *)(v22 - 56) = *((_QWORD *)v18 + 40);
      tbb::internal::generic_scheduler::nested_arena_entry((tbb::internal::generic_scheduler *)inited, v18, v9);
    }
    (**a2)(a2);
    *(_QWORD *)(*(_QWORD *)(inited + 144) - 56) = v23;
    if (v11 == v12)
    {
      *(_BYTE *)(inited + 74) = BYTE10(v77);
      *(_QWORD *)(inited + 56) = *((_QWORD *)&v76 + 1);
    }
    else
    {
      tbb::internal::generic_scheduler::nested_arena_exit((tbb::internal::generic_scheduler *)inited);
      *v10 = v75;
      v26 = v79;
      *(_OWORD *)(inited + 80) = v78;
      *(_OWORD *)(inited + 96) = v26;
      v27 = v77;
      *(_OWORD *)(inited + 48) = v76;
      *(_OWORD *)(inited + 64) = v27;
      *(_QWORD *)(inited + 352) = **((_QWORD **)&v79 + 1);
      tbb::internal::governor::assume_scheduler(inited);
    }
    sub_20BDD3AC0((uint64_t)&v59, v25);
  }
}

void sub_20BDD1F18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v3;
  va_list va;

  va_start(va, a2);
  __cxa_end_catch();
  sub_20BDD3AC0((uint64_t)va, v3);
  _Unwind_Resume(a1);
}

void sub_20BDD1F54(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_20BDD1F60(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  sub_20BDC12F4(exception_object);
}

void sub_20BDD1F78(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  *(_BYTE *)(v2 - 12) = 4;
  *(_QWORD *)(v2 - 8) = *(_QWORD *)(v1 + 136);
  *(_QWORD *)(v1 + 136) = v2;
  tbb::task_group_context::~task_group_context((tbb::task_group_context *)&v5);
  sub_20BDC1B74(&v4);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDD1FAC(_DWORD *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unsigned int v4;
  uint64_t i;
  _DWORD *v6;
  unint64_t *v7;
  unint64_t v9;
  _DWORD *v10;
  unint64_t *v11;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v18;
  unint64_t v19;
  _DWORD *v20;
  unint64_t *v21;
  unint64_t v23;
  _DWORD *v25;
  unint64_t *v26;
  unint64_t v28;
  unsigned int *v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;

  v2 = a1[83];
  if (!(_DWORD)v2)
    goto LABEL_26;
  v3 = *(_QWORD *)(a2 + 32);
  if (v3 >= v2)
  {
    v4 = *(_DWORD *)(a2 + 128);
    *(_DWORD *)(a2 + 128) = *(_DWORD *)(a2 + 132) - 1640531535 * v4;
    v3 = HIWORD(v4) % v2;
  }
  i = v3;
  while (1)
  {
    v6 = &a1[64 * i];
    if (!*((_QWORD *)v6 + 48))
      break;
LABEL_5:
    if (++i == v2)
    {
      if (v3)
      {
        for (i = 0; i != v3; ++i)
        {
          v10 = &a1[64 * i];
          if (!*((_QWORD *)v10 + 48))
          {
            v11 = (unint64_t *)(v10 + 96);
            do
            {
              while (!__ldaxr(v11))
              {
                if (!__stlxr(a2, v11))
                  goto LABEL_25;
              }
              __clrex();
              do
                v13 = __ldxr(v11);
              while (__stxr(v13, v11));
            }
            while (!v13);
          }
        }
      }
      goto LABEL_26;
    }
  }
  v7 = (unint64_t *)(v6 + 96);
  do
  {
    while (__ldaxr(v7))
    {
      __clrex();
      do
        v9 = __ldxr(v7);
      while (__stxr(v9, v7));
      if (v9)
        goto LABEL_5;
    }
  }
  while (__stlxr(a2, v7));
LABEL_25:
  if (i == -1)
  {
LABEL_26:
    v14 = a1[83];
    v15 = a1[82];
    if (v14 < v15)
    {
      v16 = *(_QWORD *)(a2 + 32);
      if (v16 < v14 || v16 >= v15)
      {
        v18 = *(unsigned int *)(a2 + 128);
        *(_DWORD *)(a2 + 128) = *(_DWORD *)(a2 + 132) - 1640531535 * v18;
        v16 = (v18 >> 16) % (v15 - v14) + v14;
      }
      if (v16 < v15)
      {
        v19 = v16;
        while (1)
        {
          v20 = &a1[64 * v19];
          if (!*((_QWORD *)v20 + 48))
            break;
LABEL_35:
          if (++v19 == v15)
            goto LABEL_44;
        }
        v21 = (unint64_t *)(v20 + 96);
        do
        {
          while (__ldaxr(v21))
          {
            __clrex();
            do
              v23 = __ldxr(v21);
            while (__stxr(v23, v21));
            if (v23)
              goto LABEL_35;
          }
        }
        while (__stlxr(a2, v21));
        v14 = v19;
LABEL_56:
        i = v14;
        if (v14 == -1)
          return i;
        goto LABEL_57;
      }
LABEL_44:
      if (v16 > v14)
      {
        do
        {
          v25 = &a1[64 * v14];
          if (!*((_QWORD *)v25 + 48))
          {
            v26 = (unint64_t *)(v25 + 96);
            do
            {
              while (!__ldaxr(v26))
              {
                if (!__stlxr(a2, v26))
                  goto LABEL_56;
              }
              __clrex();
              do
                v28 = __ldxr(v26);
              while (__stxr(v28, v26));
            }
            while (!v28);
          }
          ++v14;
          i = -1;
        }
        while (v14 != v16);
        return i;
      }
    }
    return -1;
  }
LABEL_57:
  v31 = a1[36];
  v29 = a1 + 36;
  v30 = v31;
  v32 = i + 1;
  while (1)
  {
    __dmb(0xBu);
    if (v30 >= v32)
      break;
    do
    {
      while (1)
      {
        v33 = __ldaxr(v29);
        if (v33 != v30)
          break;
        if (!__stlxr(v32, v29))
          return i;
      }
      __clrex();
    }
    while (*v29 == v30);
    v30 = *v29;
  }
  return i;
}

uint64_t *sub_20BDD21E8(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  _OWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v2 = a1[11];
  v3 = *a1;
  *(_QWORD *)(*(_QWORD *)(v3 + 144) - 56) = v2;
  if (*((_BYTE *)a1 + 96))
  {
    *(_BYTE *)(v3 + 74) = *((_BYTE *)a1 + 50);
    *(_QWORD *)(*a1 + 56) = a1[4];
  }
  else
  {
    tbb::internal::generic_scheduler::nested_arena_exit((tbb::internal::generic_scheduler *)v3);
    v4 = (_OWORD *)*a1;
    v4[2] = *(_OWORD *)(a1 + 1);
    v5 = *(_OWORD *)(a1 + 3);
    v6 = *(_OWORD *)(a1 + 5);
    v7 = *(_OWORD *)(a1 + 9);
    v4[5] = *(_OWORD *)(a1 + 7);
    v4[6] = v7;
    v4[3] = v5;
    v4[4] = v6;
    v8 = *a1;
    *(_QWORD *)(v8 + 352) = *(_QWORD *)a1[10];
    tbb::internal::governor::assume_scheduler(v8);
  }
  return a1;
}

void sub_20BDD2278(std::exception_ptr *a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  std::exception_ptr::exception_ptr(&v2, a1);
  v1.__ptr_ = &v2;
  std::rethrow_exception(v1);
  __break(1u);
}

void sub_20BDD22A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDD22B4(_QWORD *a1, uint64_t a2, uint64_t a3, void *a4)
{
  fenv_t *v5;
  void *v6;
  _OWORD *v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v5 = (fenv_t *)tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
  a1[1] = v5;
  fegetenv(v5);
  v7 = (_OWORD *)a1[2];
  if (!v7)
  {
    v7 = (_OWORD *)tbb::internal::NFS_Allocate(1uLL, 16, 0, v6);
    a1[2] = v7;
  }
  *v7 = *(_OWORD *)a1[1];
  return a1;
}

void sub_20BDD231C(_Unwind_Exception *exception_object, void *a2)
{
  uint64_t v2;
  tbb::internal *v4;
  tbb::internal *v5;

  v4 = *(tbb::internal **)(v2 + 16);
  if (v4)
    tbb::internal::NFS_Free(v4, a2);
  v5 = *(tbb::internal **)(v2 + 8);
  if (v5)
    tbb::internal::NFS_Free(v5, a2);
  _Unwind_Resume(exception_object);
}

__n128 sub_20BDD2348(uint64_t a1)
{
  const fenv_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v8;
  _OWORD *v9;
  __n128 *v10;
  __n128 result;

  v4 = a1 + 8;
  v2 = *(const fenv_t **)(a1 + 8);
  v3 = *(uint64_t **)(v4 + 8);
  v6 = *v3;
  v5 = v3[1];
  if (v6 != v2->__fpsr || v5 != v2->__fpcr)
  {
    fesetenv(v2);
    v9 = *(_OWORD **)(a1 + 16);
    if (!v9)
    {
      v9 = (_OWORD *)tbb::internal::NFS_Allocate(1uLL, 16, 0, v8);
      *(_QWORD *)(a1 + 16) = v9;
    }
    v10 = *(__n128 **)(a1 + 8);
    result = *v10;
    *v9 = *v10;
  }
  return result;
}

void tbb::interface7::internal::task_arena_base::internal_wait(tbb::internal::generic_scheduler **this)
{
  unint64_t v2;
  tbb::internal::generic_scheduler *inited;
  unsigned int *v4;
  tbb::internal::generic_scheduler *v5;
  task_t *v6;
  tbb::internal::generic_scheduler *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v12;
  _QWORD *v13;
  tbb::internal::arena *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  unsigned int v22;
  unsigned int i;
  uint64_t v24;
  semaphore_t semaphore;
  tbb::internal::generic_scheduler *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char v33;

  v2 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v2)
    inited = (tbb::internal::generic_scheduler *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  else
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  v4 = (unsigned int *)*((_QWORD *)inited + 6);
  v5 = *this;
  if (v4 == (unsigned int *)*this)
  {
    if (!*((_QWORD *)inited + 4))
    {
      for (i = v4[33]; ; i = *((_DWORD *)*this + 33))
      {
        __dmb(0xBu);
        if (i < 0x1000)
          break;
        ++*(_QWORD *)(*((_QWORD *)inited + 18) - 24);
        while (1)
        {
          v24 = *(_QWORD *)(*((_QWORD *)inited + 6) + 216);
          __dmb(0xBu);
          if (!v24)
            break;
          (*(void (**)(tbb::internal::generic_scheduler *, _QWORD, _QWORD))(*(_QWORD *)inited + 48))(inited, *((_QWORD *)inited + 18), 0);
        }
        --*(_QWORD *)(*((_QWORD *)inited + 18) - 24);
      }
    }
  }
  else
  {
    v6 = (task_t *)MEMORY[0x24BDAEC58];
    while (1)
    {
      while (1)
      {
        v8 = *((_QWORD *)v5 + 27);
        __dmb(0xBu);
        if (!v8)
          break;
        v9 = *((_QWORD *)*this + 48);
        __dmb(0xBu);
        if (v9)
        {
LABEL_17:
          semaphore = 0;
          semaphore_create(*v6, &semaphore, 0, 0);
          v26 = this[1];
          v13 = (_QWORD *)tbb::internal::allocate_root_with_context_proxy::allocate(&v26, 0x10uLL);
          *((_BYTE *)v13 - 11) = 1;
          *v13 = &unk_24C516538;
          v13[1] = &semaphore;
          tbb::interface7::internal::task_arena_base::internal_enqueue((tbb::interface7::internal::task_arena_base *)this, (tbb::task *)v13, 0);
          while (MEMORY[0x212B93828](semaphore) == 14)
            ;
          semaphore_destroy(*v6, semaphore);
        }
        else
        {
          v10 = (unint64_t *)((char *)*this + 384);
          do
          {
            while (__ldaxr(v10))
            {
              __clrex();
              do
                v12 = __ldxr(v10);
              while (__stxr(v12, v10));
              if (v12)
                goto LABEL_17;
            }
          }
          while (__stlxr((unint64_t)inited, v10));
          v14 = *this;
          v26 = inited;
          v33 = 0;
          v15 = *((_OWORD *)inited + 3);
          v16 = *((_OWORD *)inited + 4);
          v17 = *((_OWORD *)inited + 6);
          v30 = *((_OWORD *)inited + 5);
          v31 = v17;
          v28 = v15;
          v29 = v16;
          v27 = *((_OWORD *)inited + 2);
          *((_BYTE *)inited + 74) = *((_BYTE *)inited + 74) & 0xFC | 2;
          v18 = *((_QWORD *)inited + 18);
          *((_QWORD *)inited + 7) = v18;
          v32 = *(_QWORD *)(v18 - 56);
          *(_QWORD *)(v18 - 56) = *((_QWORD *)v14 + 40);
          tbb::internal::generic_scheduler::nested_arena_entry(inited, v14, 0);
          ++*(_QWORD *)(*((_QWORD *)inited + 18) - 24);
          while (1)
          {
            v19 = *(_QWORD *)(*((_QWORD *)inited + 6) + 216);
            __dmb(0xBu);
            if (!v19)
              break;
            (*(void (**)(tbb::internal::generic_scheduler *, _QWORD, _QWORD))(*(_QWORD *)inited + 48))(inited, *((_QWORD *)inited + 18), 0);
          }
          --*(_QWORD *)(*((_QWORD *)inited + 18) - 24);
          v7 = v26;
          *(_QWORD *)(*((_QWORD *)v26 + 18) - 56) = v32;
          if (v33)
          {
            *((_BYTE *)v7 + 74) = BYTE10(v29);
            *((_QWORD *)v7 + 7) = *((_QWORD *)&v28 + 1);
          }
          else
          {
            tbb::internal::generic_scheduler::nested_arena_exit(v7);
            *((_OWORD *)v7 + 2) = v27;
            v20 = v31;
            *((_OWORD *)v7 + 5) = v30;
            *((_OWORD *)v7 + 6) = v20;
            v21 = v29;
            *((_OWORD *)v7 + 3) = v28;
            *((_OWORD *)v7 + 4) = v21;
            *((_QWORD *)v7 + 44) = **((_QWORD **)&v31 + 1);
            tbb::internal::governor::assume_scheduler((uint64_t)v7);
          }
        }
        v5 = *this;
      }
      v22 = *((_DWORD *)*this + 33);
      __dmb(0xBu);
      if (v22 <= 0xFFF && !*((_QWORD *)*this + 48))
        break;
      sched_yield();
      v5 = *this;
    }
  }
}

void sub_20BDD26A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, semaphore_t a10)
{
  sub_20BDD26D4(&a10);
  _Unwind_Resume(a1);
}

semaphore_t *sub_20BDD26D4(semaphore_t *a1)
{
  semaphore_destroy(*MEMORY[0x24BDAEC58], *a1);
  return a1;
}

uint64_t tbb::interface7::internal::task_arena_base::internal_current_slot(tbb::interface7::internal::task_arena_base *this)
{
  unint64_t v1;

  v1 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v1 & 0xFFFFFFFFFFFFFFFELL) != 0)
    return *(unsigned int *)((v1 & 0xFFFFFFFFFFFFFFFELL) + 32);
  else
    return 0xFFFFFFFFLL;
}

uint64_t tbb::interface7::internal::isolate_within_arena(uint64_t (***a1)(_QWORD), uint64_t (***a2)(_QWORD))
{
  unint64_t v4;
  unint64_t inited;
  uint64_t v6;
  uint64_t v7;
  uint64_t (***v8)(_QWORD);
  uint64_t result;

  v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4)
    inited = v4 & 0xFFFFFFFFFFFFFFFELL;
  else
    inited = tbb::internal::governor::init_scheduler_weak(0);
  v6 = *(_QWORD *)(inited + 56);
  v7 = *(_QWORD *)(v6 - 64);
  if (a2)
    v8 = a2;
  else
    v8 = a1;
  *(_QWORD *)(v6 - 64) = v8;
  result = (**a1)(a1);
  *(_QWORD *)(v6 - 64) = v7;
  return result;
}

void sub_20BDD27B4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 - 64) = v2;
  _Unwind_Resume(a1);
}

uint64_t tbb::interface7::internal::task_arena_base::internal_max_concurrency(uint64_t *a1)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t result;
  size_t v4;
  int v5;
  int v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = *a1;
    if (!*a1)
      goto LABEL_7;
    return (*(_DWORD *)(v1 + 208) + *(_DWORD *)(v1 + 332));
  }
  v2 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS) & 0xFFFFFFFFFFFFFFFELL;
  if (v2)
  {
    v1 = *(_QWORD *)(v2 + 48);
    if (v1)
      return (*(_DWORD *)(v1 + 208) + *(_DWORD *)(v1 + 332));
  }
LABEL_7:
  result = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(_QWORD *)v6 = 0x1900000006;
    v5 = 0;
    v4 = 4;
    sysctl(v6, 2u, &v5, &v4, 0, 0);
    if (v5 <= 1)
      result = 1;
    else
      result = v5;
    tbb::internal::governor::DefaultNumberOfThreads = result;
  }
  return result;
}

uint64_t sub_20BDD28A0(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unsigned int v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v3 & 0xFFFFFFFFFFFFFFFELL) != 0)
    v4 = *(_DWORD *)((v3 & 0xFFFFFFFFFFFFFFFELL) + 32);
  else
    v4 = -1;
  if (v4 >= 0xFFFFFFFE)
    v5 = 4294967294;
  else
    v5 = v4;
  return tbb::internal::bind_thread_to_node(v2, v5, *(unsigned int *)(a1 + 32));
}

uint64_t sub_20BDD28F8(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unsigned int v3;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0)
    v3 = *(_DWORD *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 32);
  else
    v3 = -1;
  if (v3 >= 0xFFFFFFFE)
    v4 = 4294967294;
  else
    v4 = v3;
  return tbb::internal::restore_affinity_mask(v1, v4);
}

void sub_20BDD294C(tbb::internal::task_scheduler_observer_v3 *a1)
{
  tbb::internal::task_scheduler_observer_v3 *v1;

  v1 = sub_20BDD2AE4(a1);
  operator delete(v1);
}

tbb::internal::task_scheduler_observer_v3 *sub_20BDD2960(tbb::internal::task_scheduler_observer_v3 *a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &unk_24C516448;
  if (*((_QWORD *)a1 + 1))
  {
    tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
    v2 = *((_QWORD *)a1 + 1);
    *(_QWORD *)a1 = &unk_24C516478;
    if (v2)
      tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
  }
  else
  {
    *(_QWORD *)a1 = &unk_24C516478;
  }
  return a1;
}

void sub_20BDD29E4(tbb::internal::task_scheduler_observer_v3 *__p)
{
  uint64_t v2;

  *(_QWORD *)__p = &unk_24C516448;
  if (*((_QWORD *)__p + 1))
  {
    tbb::internal::task_scheduler_observer_v3::observe(__p, 0);
    v2 = *((_QWORD *)__p + 1);
    *(_QWORD *)__p = &unk_24C516478;
    if (v2)
      tbb::internal::task_scheduler_observer_v3::observe(__p, 0);
  }
  operator delete(__p);
}

tbb::internal::task_scheduler_observer_v3 *sub_20BDD2A54(tbb::internal::task_scheduler_observer_v3 *a1)
{
  *(_QWORD *)a1 = &unk_24C516478;
  if (*((_QWORD *)a1 + 1))
    tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
  return a1;
}

void sub_20BDD2A9C(tbb::internal::task_scheduler_observer_v3 *__p)
{
  *(_QWORD *)__p = &unk_24C516478;
  if (*((_QWORD *)__p + 1))
    tbb::internal::task_scheduler_observer_v3::observe(__p, 0);
  operator delete(__p);
}

tbb::internal::task_scheduler_observer_v3 *sub_20BDD2AE4(tbb::internal::task_scheduler_observer_v3 *a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &unk_24C5163D8;
  tbb::internal::destroy_binding_handler(*((_QWORD *)a1 + 5));
  *(_QWORD *)a1 = &unk_24C516448;
  if (*((_QWORD *)a1 + 1))
  {
    tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
    v2 = *((_QWORD *)a1 + 1);
    *(_QWORD *)a1 = &unk_24C516478;
    if (v2)
      tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
  }
  else
  {
    *(_QWORD *)a1 = &unk_24C516478;
  }
  return a1;
}

_QWORD *sub_20BDD2B84(_QWORD *a1, void *a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = a1[3];
  if (v3)
  {
    v4 = (void *)(v3 - 16);
    v5 = *(_QWORD *)(v3 - 8);
    if (v5)
    {
      v6 = v3 - 128;
      v7 = v5 << 7;
      do
      {
        sub_20BDD2C48((uint64_t *)(v6 + v7), a2);
        v7 -= 128;
      }
      while (v7);
    }
    operator delete[](v4);
  }
  v8 = a1[4];
  if (v8)
  {
    v9 = (void *)(v8 - 16);
    v10 = *(_QWORD *)(v8 - 8);
    if (v10)
    {
      v11 = v10 << 7;
      v12 = v8 - 128;
      do
      {
        sub_20BDD2C48((uint64_t *)(v12 + v11), a2);
        v11 -= 128;
      }
      while (v11);
    }
    operator delete[](v9);
  }
  v13 = a1[5];
  if (v13)
  {
    v14 = (void *)(v13 - 16);
    v15 = *(_QWORD *)(v13 - 8);
    if (v15)
    {
      v16 = v15 << 7;
      v17 = v13 - 128;
      do
      {
        sub_20BDD2C48((uint64_t *)(v17 + v16), a2);
        v16 -= 128;
      }
      while (v16);
    }
    operator delete[](v14);
  }
  return a1;
}

uint64_t *sub_20BDD2C48(uint64_t *a1, void *a2)
{
  uint64_t *v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = (uint64_t *)a1[1];
  v4 = (uint64_t *)a1[2];
  a1[5] = 0;
  v5 = (char *)v4 - (char *)v3;
  if ((unint64_t)((char *)v4 - (char *)v3) >= 0x11)
  {
    do
    {
      tbb::internal::deallocate_via_handler_v3(*v3, a2);
      v4 = (uint64_t *)a1[2];
      v3 = (uint64_t *)(a1[1] + 8);
      a1[1] = (uint64_t)v3;
      v5 = (char *)v4 - (char *)v3;
    }
    while ((unint64_t)((char *)v4 - (char *)v3) > 0x10);
  }
  v6 = v5 >> 3;
  if (v6 == 1)
  {
    v7 = 256;
    goto LABEL_7;
  }
  if (v6 == 2)
  {
    v7 = 512;
LABEL_7:
    a1[4] = v7;
  }
  if (v3 != v4)
  {
    do
      tbb::internal::deallocate_via_handler_v3(*v3++, a2);
    while (v3 != v4);
    v9 = a1[1];
    v8 = a1[2];
    if (v8 != v9)
      a1[2] = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*a1)
    tbb::internal::deallocate_via_handler_v3(*a1, a2);
  return a1;
}

_QWORD *sub_20BDD2D1C(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  *a1 = &unk_24C5164F0;
  v2 = a1[3];
  __dmb(0xBu);
  *(_QWORD *)(v2 - 24) = 1;
  v3 = a1[2];
  __dmb(0xBu);
  sub_20BDD2E4C(v3, (uint64_t)a1);
  return a1;
}

void sub_20BDD2D70(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  *a1 = &unk_24C5164F0;
  v2 = a1[3];
  __dmb(0xBu);
  *(_QWORD *)(v2 - 24) = 1;
  v3 = a1[2];
  __dmb(0xBu);
  sub_20BDD2E4C(v3, (uint64_t)a1);
  operator delete(a1);
}

uint64_t sub_20BDD2DC4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 - 40);
  v3 = *(_QWORD *)(v2 + 144);
  v4 = *(_BYTE *)(v2 + 74);
  v5 = *(_QWORD *)(a1 - 56);
  *(_QWORD *)(a1 - 56) = *(_QWORD *)(*(_QWORD *)(v2 + 48) + 320);
  *(_QWORD *)(v2 + 144) = a1;
  *(_BYTE *)(v2 + 74) |= 1u;
  (***(void (****)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 8));
  *(_QWORD *)(a1 - 56) = v5;
  *(_BYTE *)(v2 + 74) = v4;
  *(_QWORD *)(v2 + 144) = v3;
  return 0;
}

void sub_20BDD2E3C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  uint64_t v5;

  *(_QWORD *)(v1 - 56) = v5;
  *(_BYTE *)(v2 + 74) = v4;
  *(_QWORD *)(v2 + 144) = v3;
  _Unwind_Resume(a1);
}

uint64_t sub_20BDD2E4C(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  unsigned int *v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;

  if (*(_QWORD *)(result + 8))
  {
    v3 = result;
    v16 = &v16;
    v17 = &v16;
    v15 = 0;
    v4 = (_BYTE *)(result + 1);
    v5 = (unsigned int *)((result + 1) & 0xFFFFFFFFFFFFFFFCLL);
    v6 = 1 << (8 * ((result + 1) & 3));
    v7 = ~(255 << (8 * ((result + 1) & 3)));
LABEL_3:
    v8 = *v5 & v7;
    do
    {
      while (1)
      {
        v9 = __ldaxr(v5);
        if (v9 == v8)
          break;
        __clrex();
        if (*v5 != v8)
        {
          result = sched_yield();
          goto LABEL_3;
        }
      }
    }
    while (__stlxr(v8 | v6, v5));
    ++*(_DWORD *)(v3 + 32);
    v10 = *(_QWORD **)(v3 + 24);
    if (v10 != (_QWORD *)(v3 + 16))
    {
      do
      {
        v13 = (_QWORD *)v10[1];
        if (*(_QWORD *)(a2 + 8) == v10[4])
        {
          --*(_QWORD *)(v3 + 8);
          *v13 = *v10;
          *(_QWORD *)(*v10 + 8) = v13;
          __dmb(0xBu);
          *((_BYTE *)v10 + 24) = 0;
          ++v15;
          v14 = v17;
          *v10 = &v16;
          v10[1] = v14;
          *v17 = v10;
          v17 = v10;
        }
        v10 = v13;
      }
      while (v13 != (_QWORD *)(v3 + 16));
    }
    __dmb(0xBu);
    *v4 = 0;
    v11 = v16;
    if (v16 != &v16)
    {
      do
      {
        v12 = (_QWORD *)*v11;
        result = MEMORY[0x212B9381C](*((unsigned int *)v11 + 4));
        v11 = v12;
      }
      while (v12 != &v16);
    }
  }
  return result;
}

uint64_t sub_20BDD2FB4(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;

  v2 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  v3 = v2 & 0xFFFFFFFFFFFFFFFELL;
  if ((*(_BYTE *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 74) & 1) != 0)
  {
    tbb::internal::arena::is_out_of_work(*(tbb::internal::arena **)(v3 + 48));
  }
  else
  {
    *(_QWORD *)(v3 + 56) = *(_QWORD *)(v3 + 144);
    (*(void (**)(unint64_t))(*(_QWORD *)v3 + 48))(v2 & 0xFFFFFFFFFFFFFFFELL);
    *(_QWORD *)(v3 + 56) = a1;
  }
  MEMORY[0x212B9381C](**(unsigned int **)(a1 + 8));
  return 0;
}

uint64_t *sub_20BDD3028(uint64_t *result)
{
  uint64_t *v1;
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  int64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  tbb::internal *v27;
  int64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  tbb::internal *v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t *v41;
  uint64_t *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t *v45;
  uint64_t *v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  void *v51;
  uint64_t *v52;
  uint64_t *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t *v56;
  unint64_t v57;
  tbb::internal *v58;
  tbb::internal *v59;
  tbb::internal *v60;
  uint64_t v61;
  unint64_t v62;
  tbb::internal *v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  __int128 *v68;
  _OWORD *v69;
  uint64_t v70;
  __int128 v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  tbb::internal *v77;
  __int128 *v78;
  _OWORD *v79;
  uint64_t v80;
  __int128 v81;
  uint64_t v82;
  tbb::internal *v83;
  uint64_t *i;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  uint64_t *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t *v91;
  __int128 *v92;
  _OWORD *v93;
  uint64_t v94;
  __int128 v95;
  uint64_t v96;
  uint64_t v97;
  tbb::internal *v98[2];
  __int128 v99;
  uint64_t *v100;

  v1 = result;
  v2 = result[4];
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    result[4] = v4;
    v5 = (uint64_t *)result[1];
    v6 = (uint64_t *)result[2];
    v9 = *v5;
    v7 = v5 + 1;
    v8 = v9;
    result[1] = (uint64_t)v7;
    if (v6 != (uint64_t *)result[3])
      goto LABEL_50;
    v10 = (uint64_t)v7 - *result;
    if ((unint64_t)v7 > *result)
      goto LABEL_5;
    v37 = ((uint64_t)v6 - *result) >> 2;
    if (v6 == (uint64_t *)*result)
      v37 = 1;
    v38 = v37 >> 2;
    v39 = v37;
    result = (uint64_t *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v37));
    v41 = &result[v38];
    v42 = (uint64_t *)v1[1];
    v6 = v41;
    v43 = v1[2] - (_QWORD)v42;
    if (v43)
    {
      v6 = (uint64_t *)((char *)v41 + (v43 & 0xFFFFFFFFFFFFFFF8));
      v44 = v43 - 8;
      if ((unint64_t)(v43 - 8) < 0x38)
      {
        v45 = &result[v38];
        do
        {
LABEL_46:
          v72 = *v42++;
          *v45++ = v72;
        }
        while (v45 != v6);
        goto LABEL_47;
      }
      v64 = &result[v38];
      v45 = v64;
      if ((unint64_t)((char *)v64 - (char *)v42) < 0x20)
        goto LABEL_46;
      v65 = (v44 >> 3) + 1;
      v66 = v65 & 0x3FFFFFFFFFFFFFFCLL;
      v45 = &v41[v66];
      v67 = &v42[v66];
      v68 = (__int128 *)(v42 + 2);
      v69 = v64 + 2;
      v70 = v65 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v71 = *v68;
        *(v69 - 1) = *(v68 - 1);
        *v69 = v71;
        v68 += 2;
        v69 += 2;
        v70 -= 4;
      }
      while (v70);
      v42 = v67;
      if (v65 != (v65 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_46;
    }
LABEL_47:
    v73 = *v1;
    *v1 = (uint64_t)result;
    v1[1] = (uint64_t)v41;
    v1[2] = (uint64_t)v6;
    v1[3] = (uint64_t)&result[v39];
    if (v73)
    {
      result = (uint64_t *)tbb::internal::deallocate_via_handler_v3(v73, v40);
LABEL_49:
      v6 = (uint64_t *)v1[2];
    }
LABEL_50:
    *v6 = v8;
    v1[2] += 8;
    return result;
  }
  v19 = result[2];
  v20 = (v19 - result[1]) >> 3;
  v21 = result[3];
  v22 = v21 - *result;
  if (v20 < v22 >> 3)
  {
    if (v21 != v19)
    {
      v98[0] = (tbb::internal *)tbb::internal::allocate_via_handler_v3((tbb::internal *)0x1000);
      return sub_20BDD3578(v1, v98);
    }
    v98[0] = (tbb::internal *)tbb::internal::allocate_via_handler_v3((tbb::internal *)0x1000);
    result = sub_20BDD36F8(v1, (uint64_t *)v98);
    v46 = (uint64_t *)v1[1];
    v6 = (uint64_t *)v1[2];
    v47 = *v46;
    v7 = v46 + 1;
    v8 = v47;
    v1[1] = (uint64_t)v7;
    if (v6 != (uint64_t *)v1[3])
      goto LABEL_50;
    v10 = (uint64_t)v7 - *v1;
    if ((unint64_t)v7 <= *v1)
    {
      v48 = ((uint64_t)v6 - *v1) >> 2;
      if (v6 == (uint64_t *)*v1)
        v48 = 1;
      v49 = v48 >> 2;
      v50 = v48;
      result = (uint64_t *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v48));
      v52 = &result[v49];
      v53 = (uint64_t *)v1[1];
      v6 = v52;
      v54 = v1[2] - (_QWORD)v53;
      if (!v54)
        goto LABEL_73;
      v6 = (uint64_t *)((char *)v52 + (v54 & 0xFFFFFFFFFFFFFFF8));
      v55 = v54 - 8;
      if ((unint64_t)(v54 - 8) >= 0x38)
      {
        v88 = &result[v49];
        v56 = v88;
        if ((unint64_t)((char *)v88 - (char *)v53) >= 0x20)
        {
          v89 = (v55 >> 3) + 1;
          v90 = v89 & 0x3FFFFFFFFFFFFFFCLL;
          v56 = &v52[v90];
          v91 = &v53[v90];
          v92 = (__int128 *)(v53 + 2);
          v93 = v88 + 2;
          v94 = v89 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v95 = *v92;
            *(v93 - 1) = *(v92 - 1);
            *v93 = v95;
            v92 += 2;
            v93 += 2;
            v94 -= 4;
          }
          while (v94);
          v53 = v91;
          if (v89 == (v89 & 0x3FFFFFFFFFFFFFFCLL))
            goto LABEL_73;
        }
      }
      else
      {
        v56 = &result[v49];
      }
      do
      {
        v96 = *v53++;
        *v56++ = v96;
      }
      while (v56 != v6);
LABEL_73:
      v97 = *v1;
      *v1 = (uint64_t)result;
      v1[1] = (uint64_t)v52;
      v1[2] = (uint64_t)v6;
      v1[3] = (uint64_t)&result[v50];
      if (!v97)
        goto LABEL_50;
      result = (uint64_t *)tbb::internal::deallocate_via_handler_v3(v97, v51);
      goto LABEL_49;
    }
LABEL_5:
    v11 = v10 >> 3;
    v12 = v10 >> 3 < -1;
    v13 = (v10 >> 3) + 2;
    if (v12)
      v14 = v13;
    else
      v14 = v11 + 1;
    v15 = v14 >> 1;
    v16 = -v15;
    v17 = &v7[-v15];
    v18 = (char *)v6 - (char *)v7;
    if (v6 != v7)
    {
      result = (uint64_t *)memmove(&v7[-v15], v7, (char *)v6 - (char *)v7);
      v7 = (uint64_t *)v1[1];
    }
    v6 = (uint64_t *)((char *)v17 + v18);
    v1[1] = (uint64_t)&v7[v16];
    v1[2] = (uint64_t)v17 + v18;
    goto LABEL_50;
  }
  v23 = (unint64_t)v22 >> 2;
  if (v21 == *result)
    v23 = 1;
  v100 = result + 3;
  v24 = 8 * v23;
  v98[0] = (tbb::internal *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v23));
  v98[1] = (tbb::internal *)((char *)v98[0] + 8 * v20);
  *(tbb::internal **)&v99 = v98[1];
  *((_QWORD *)&v99 + 1) = (char *)v98[0] + v24;
  v26 = tbb::internal::allocate_via_handler_v3((tbb::internal *)0x1000);
  v27 = v98[1];
  if (v98[1] == *((tbb::internal **)&v99 + 1))
  {
    v28 = v98[1] - v98[0];
    if (v98[1] > v98[0])
    {
      v29 = v28 >> 3;
      v12 = v28 >> 3 < -1;
      v30 = (v28 >> 3) + 2;
      if (v12)
        v31 = v30;
      else
        v31 = v29 + 1;
      v32 = v31 >> 1;
      v33 = -v32;
      v34 = (char *)v98[1] - 8 * v32;
      v35 = v99 - (unint64_t)v98[1];
      if ((tbb::internal *)v99 != v98[1])
      {
        memmove((char *)v98[1] - 8 * v32, v98[1], v99 - (unint64_t)v98[1]);
        v27 = v98[1];
      }
      v36 = (tbb::internal *)((char *)v27 + 8 * v33);
      v27 = (tbb::internal *)&v34[v35];
      v98[1] = v36;
      *(_QWORD *)&v99 = &v34[v35];
      goto LABEL_58;
    }
    if ((tbb::internal *)v99 == v98[0])
      v57 = 1;
    else
      v57 = (uint64_t)(v99 - (unint64_t)v98[0]) >> 2;
    v58 = (tbb::internal *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v57));
    v59 = (tbb::internal *)((char *)v58 + 8 * (v57 >> 2));
    v60 = v98[1];
    v27 = v59;
    v61 = v99 - (unint64_t)v98[1];
    if ((tbb::internal *)v99 != v98[1])
    {
      v27 = (tbb::internal *)((char *)v59 + (v61 & 0xFFFFFFFFFFFFFFF8));
      v62 = v61 - 8;
      if (v62 < 0x38)
      {
        v63 = (tbb::internal *)((char *)v58 + 8 * (v57 >> 2));
        do
        {
LABEL_55:
          v82 = *(_QWORD *)v60;
          v60 = (tbb::internal *)((char *)v60 + 8);
          *(_QWORD *)v63 = v82;
          v63 = (tbb::internal *)((char *)v63 + 8);
        }
        while (v63 != v27);
        goto LABEL_56;
      }
      v74 = (char *)v58 + 8 * (v57 >> 2);
      v63 = (tbb::internal *)v74;
      if ((unint64_t)(v74 - (char *)v98[1]) < 0x20)
        goto LABEL_55;
      v75 = (v62 >> 3) + 1;
      v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
      v63 = (tbb::internal *)((char *)v59 + v76);
      v77 = (tbb::internal *)((char *)v98[1] + v76);
      v78 = (__int128 *)((char *)v98[1] + 16);
      v79 = v74 + 16;
      v80 = v75 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v81 = *v78;
        *(v79 - 1) = *(v78 - 1);
        *v79 = v81;
        v78 += 2;
        v79 += 2;
        v80 -= 4;
      }
      while (v80);
      v60 = v77;
      if (v75 != (v75 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_55;
    }
LABEL_56:
    v83 = v98[0];
    v98[0] = v58;
    v98[1] = (tbb::internal *)((char *)v58 + 8 * (v57 >> 2));
    *(_QWORD *)&v99 = v27;
    *((_QWORD *)&v99 + 1) = (char *)v58 + 8 * v57;
    if (v83)
    {
      tbb::internal::deallocate_via_handler_v3((uint64_t)v83, v25);
      v27 = (tbb::internal *)v99;
    }
  }
LABEL_58:
  *(_QWORD *)v27 = v26;
  *(_QWORD *)&v99 = v99 + 8;
  for (i = (uint64_t *)v1[2]; i != (uint64_t *)v1[1]; sub_20BDD3884((uint64_t *)v98, i))
    --i;
  v85 = *(_OWORD *)v98;
  v86 = v99;
  v98[0] = (tbb::internal *)*v1;
  v98[1] = (tbb::internal *)i;
  v87 = *((_OWORD *)v1 + 1);
  *(_OWORD *)v1 = v85;
  *((_OWORD *)v1 + 1) = v86;
  v99 = v87;
  if ((uint64_t *)v87 != i)
    *(_QWORD *)&v99 = v87 + (((unint64_t)i - v87 + 7) & 0xFFFFFFFFFFFFFFF8);
  result = (uint64_t *)v98[0];
  if (v98[0])
    return (uint64_t *)tbb::internal::deallocate_via_handler_v3((uint64_t)v98[0], v25);
  return result;
}

void sub_20BDD3544(_Unwind_Exception *a1, void *a2, uint64_t a3, ...)
{
  void *v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  sub_20BDD3A10((uint64_t *)va, a2);
  sub_20BDD3A44((uint64_t *)va1, v4);
  _Unwind_Resume(a1);
}

uint64_t *sub_20BDD3578(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  void *v19;
  char *v20;
  uint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  __int128 *v29;
  _OWORD *v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;

  v3 = result;
  v4 = (char *)result[2];
  if (v4 != (char *)result[3])
    goto LABEL_21;
  v5 = (char *)result[1];
  v6 = (uint64_t)&v5[-*result];
  if ((unint64_t)v5 > *result)
  {
    v7 = v6 >> 3;
    v8 = v6 >> 3 < -1;
    v9 = (v6 >> 3) + 2;
    if (v8)
      v10 = v9;
    else
      v10 = v7 + 1;
    v11 = v10 >> 1;
    v12 = -v11;
    v13 = &v5[-8 * v11];
    v14 = v4 - v5;
    if (v4 != v5)
    {
      result = (uint64_t *)memmove(&v5[-8 * v11], v5, v4 - v5);
      v4 = (char *)v3[1];
    }
    v15 = &v4[8 * v12];
    v4 = &v13[v14];
    v3[1] = (uint64_t)v15;
    v3[2] = (uint64_t)&v13[v14];
    goto LABEL_21;
  }
  v16 = (uint64_t)&v4[-*result] >> 2;
  if (v4 == (char *)*result)
    v16 = 1;
  v17 = v16 >> 2;
  v18 = v16;
  result = (uint64_t *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v16));
  v20 = (char *)&result[v17];
  v21 = (uint64_t *)v3[1];
  v4 = v20;
  v22 = v3[2] - (_QWORD)v21;
  if (v22)
  {
    v4 = &v20[v22 & 0xFFFFFFFFFFFFFFF8];
    v23 = v22 - 8;
    if ((unint64_t)(v22 - 8) < 0x38)
    {
      v24 = (char *)&result[v17];
      do
      {
LABEL_18:
        v33 = *v21++;
        *(_QWORD *)v24 = v33;
        v24 += 8;
      }
      while (v24 != v4);
      goto LABEL_19;
    }
    v25 = &result[v17];
    v24 = (char *)v25;
    if ((unint64_t)((char *)v25 - (char *)v21) < 0x20)
      goto LABEL_18;
    v26 = (v23 >> 3) + 1;
    v27 = v26 & 0x3FFFFFFFFFFFFFFCLL;
    v24 = &v20[v27 * 8];
    v28 = &v21[v27];
    v29 = (__int128 *)(v21 + 2);
    v30 = v25 + 2;
    v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v32 = *v29;
      *(v30 - 1) = *(v29 - 1);
      *v30 = v32;
      v29 += 2;
      v30 += 2;
      v31 -= 4;
    }
    while (v31);
    v21 = v28;
    if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      goto LABEL_18;
  }
LABEL_19:
  v34 = *v3;
  *v3 = (uint64_t)result;
  v3[1] = (uint64_t)v20;
  v3[2] = (uint64_t)v4;
  v3[3] = (uint64_t)&result[v18];
  if (v34)
  {
    result = (uint64_t *)tbb::internal::deallocate_via_handler_v3(v34, v19);
    v4 = (char *)v3[2];
  }
LABEL_21:
  *(_QWORD *)v4 = *a2;
  v3[2] += 8;
  return result;
}

uint64_t *sub_20BDD36F8(uint64_t *result, uint64_t *a2)
{
  uint64_t *v3;
  char *v4;
  uint64_t *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  __int128 *v24;
  _OWORD *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;

  v3 = result;
  v4 = (char *)result[1];
  if (v4 != (char *)*result)
  {
    v5 = (uint64_t *)result[1];
    goto LABEL_22;
  }
  v6 = (_BYTE *)result[2];
  v7 = (_BYTE *)result[3];
  if (v6 < v7)
  {
    v8 = (v7 - v6) >> 3;
    if (v8 >= -1)
      v9 = v8 + 1;
    else
      v9 = v8 + 2;
    v10 = v9 >> 1;
    v5 = (uint64_t *)&v4[8 * (v9 >> 1)];
    if (v6 != v4)
    {
      result = (uint64_t *)memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
      v4 = (char *)v3[2];
    }
    v3[1] = (uint64_t)v5;
    v3[2] = (uint64_t)&v4[8 * v10];
    goto LABEL_22;
  }
  v11 = (v7 - v4) >> 2;
  if (v7 == v4)
    v11 = 1;
  v12 = (unint64_t)(v11 + 3) >> 2;
  v13 = v11;
  result = (uint64_t *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v11));
  v5 = &result[v12];
  v15 = (uint64_t *)v3[1];
  v16 = (char *)v5;
  v17 = v3[2] - (_QWORD)v15;
  if (v17)
  {
    v16 = (char *)v5 + (v17 & 0xFFFFFFFFFFFFFFF8);
    v18 = v17 - 8;
    if ((unint64_t)(v17 - 8) < 0x38)
    {
      v19 = &result[v12];
      do
      {
LABEL_19:
        v28 = *v15++;
        *v19++ = v28;
      }
      while (v19 != (uint64_t *)v16);
      goto LABEL_20;
    }
    v20 = &result[v12];
    v19 = v20;
    if ((unint64_t)((char *)v20 - (char *)v15) < 0x20)
      goto LABEL_19;
    v21 = (v18 >> 3) + 1;
    v22 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v19 = &v5[v22];
    v23 = &v15[v22];
    v24 = (__int128 *)(v15 + 2);
    v25 = v20 + 2;
    v26 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v27 = *v24;
      *(v25 - 1) = *(v24 - 1);
      *v25 = v27;
      v24 += 2;
      v25 += 2;
      v26 -= 4;
    }
    while (v26);
    v15 = v23;
    if (v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL))
      goto LABEL_19;
  }
LABEL_20:
  v29 = *v3;
  *v3 = (uint64_t)result;
  v3[1] = (uint64_t)v5;
  v3[2] = (uint64_t)v16;
  v3[3] = (uint64_t)&result[v13];
  if (v29)
  {
    result = (uint64_t *)tbb::internal::deallocate_via_handler_v3(v29, v14);
    v5 = (uint64_t *)v3[1];
  }
LABEL_22:
  *(v5 - 1) = *a2;
  v3[1] -= 8;
  return result;
}

uint64_t *sub_20BDD3884(uint64_t *result, uint64_t *a2)
{
  uint64_t *v3;
  char *v4;
  uint64_t *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  __int128 *v24;
  _OWORD *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;

  v3 = result;
  v4 = (char *)result[1];
  if (v4 != (char *)*result)
  {
    v5 = (uint64_t *)result[1];
    goto LABEL_22;
  }
  v6 = (_BYTE *)result[2];
  v7 = (_BYTE *)result[3];
  if (v6 < v7)
  {
    v8 = (v7 - v6) >> 3;
    if (v8 >= -1)
      v9 = v8 + 1;
    else
      v9 = v8 + 2;
    v10 = v9 >> 1;
    v5 = (uint64_t *)&v4[8 * (v9 >> 1)];
    if (v6 != v4)
    {
      result = (uint64_t *)memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
      v4 = (char *)v3[2];
    }
    v3[1] = (uint64_t)v5;
    v3[2] = (uint64_t)&v4[8 * v10];
    goto LABEL_22;
  }
  v11 = (v7 - v4) >> 2;
  if (v7 == v4)
    v11 = 1;
  v12 = (unint64_t)(v11 + 3) >> 2;
  v13 = v11;
  result = (uint64_t *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v11));
  v5 = &result[v12];
  v15 = (uint64_t *)v3[1];
  v16 = (char *)v5;
  v17 = v3[2] - (_QWORD)v15;
  if (v17)
  {
    v16 = (char *)v5 + (v17 & 0xFFFFFFFFFFFFFFF8);
    v18 = v17 - 8;
    if ((unint64_t)(v17 - 8) < 0x38)
    {
      v19 = &result[v12];
      do
      {
LABEL_19:
        v28 = *v15++;
        *v19++ = v28;
      }
      while (v19 != (uint64_t *)v16);
      goto LABEL_20;
    }
    v20 = &result[v12];
    v19 = v20;
    if ((unint64_t)((char *)v20 - (char *)v15) < 0x20)
      goto LABEL_19;
    v21 = (v18 >> 3) + 1;
    v22 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v19 = &v5[v22];
    v23 = &v15[v22];
    v24 = (__int128 *)(v15 + 2);
    v25 = v20 + 2;
    v26 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v27 = *v24;
      *(v25 - 1) = *(v24 - 1);
      *v25 = v27;
      v24 += 2;
      v25 += 2;
      v26 -= 4;
    }
    while (v26);
    v15 = v23;
    if (v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL))
      goto LABEL_19;
  }
LABEL_20:
  v29 = *v3;
  *v3 = (uint64_t)result;
  v3[1] = (uint64_t)v5;
  v3[2] = (uint64_t)v16;
  v3[3] = (uint64_t)&result[v13];
  if (v29)
  {
    result = (uint64_t *)tbb::internal::deallocate_via_handler_v3(v29, v14);
    v5 = (uint64_t *)v3[1];
  }
LABEL_22:
  *(v5 - 1) = *a2;
  v3[1] -= 8;
  return result;
}

uint64_t *sub_20BDD3A10(uint64_t *a1, void *a2)
{
  uint64_t v3;

  v3 = *a1;
  *a1 = 0;
  if (v3)
    tbb::internal::deallocate_via_handler_v3(v3, a2);
  return a1;
}

uint64_t *sub_20BDD3A44(uint64_t *a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v4 = a1[1];
  v3 = a1[2];
  if (v3 != v4)
    a1[2] = v3 + ((v4 - v3 + 7) & 0xFFFFFFFFFFFFFFF8);
  v5 = *a1;
  if (*a1)
    tbb::internal::deallocate_via_handler_v3(v5, a2);
  return a1;
}

uint64_t sub_20BDD3A94(uint64_t a1)
{
  (***(void (****)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 8) - 40))(*(_QWORD *)(*(_QWORD *)(a1 + 8) - 40), *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 8) - 8);
  return 0;
}

uint64_t sub_20BDD3AC0(uint64_t a1, void *a2)
{
  tbb::internal *v3;
  _QWORD *v4;
  tbb::internal *v6;

  v3 = *(tbb::internal **)(a1 + 16);
  v4 = *(_QWORD **)(a1 + 8);
  if (*(_QWORD *)v3 != *v4 || *((_QWORD *)v3 + 1) != v4[1])
  {
    fesetenv(*(const fenv_t **)(a1 + 8));
    v3 = *(tbb::internal **)(a1 + 16);
  }
  if (v3)
    tbb::internal::NFS_Free(v3, a2);
  v6 = *(tbb::internal **)(a1 + 8);
  if (v6)
    tbb::internal::NFS_Free(v6, a2);
  return a1;
}

uint64_t tbb::internal::Scheduler_OneTimeInitialization(tbb::internal *this)
{
  uint64_t (*v1)();
  uint64_t result;

  v1 = tbb::internal::custom_scheduler<tbb::internal::IntelSchedulerTraits>::allocate_scheduler;
  if ((_DWORD)this)
    v1 = tbb::internal::custom_scheduler<tbb::internal::DefaultSchedulerTraits>::allocate_scheduler;
  tbb::internal::AllocateSchedulerPtr = v1;
  *(_QWORD *)(sub_20BDD3C78() + 152) = 2;
  result = sub_20BDD3C78();
  *(_QWORD *)(result + 160) = 2;
  return result;
}

tbb::internal::generic_scheduler *tbb::internal::custom_scheduler<tbb::internal::DefaultSchedulerTraits>::allocate_scheduler(tbb::internal::market *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5;
  tbb::internal::generic_scheduler *result;

  v5 = tbb::internal::NFS_Allocate(1uLL, 392, 0, a4);
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 192) = 0u;
  *(_OWORD *)(v5 + 208) = 0u;
  *(_OWORD *)(v5 + 224) = 0u;
  *(_OWORD *)(v5 + 240) = 0u;
  *(_OWORD *)(v5 + 256) = 0u;
  *(_OWORD *)(v5 + 272) = 0u;
  *(_OWORD *)(v5 + 288) = 0u;
  *(_OWORD *)(v5 + 304) = 0u;
  *(_OWORD *)(v5 + 320) = 0u;
  *(_OWORD *)(v5 + 336) = 0u;
  *(_OWORD *)(v5 + 352) = 0u;
  *(_OWORD *)(v5 + 368) = 0u;
  *(_QWORD *)(v5 + 384) = 0;
  result = tbb::internal::generic_scheduler::generic_scheduler((tbb::internal::generic_scheduler *)v5, a1);
  *(_QWORD *)result = &unk_24C5166C8;
  return result;
}

tbb::internal::generic_scheduler *tbb::internal::custom_scheduler<tbb::internal::IntelSchedulerTraits>::allocate_scheduler(tbb::internal::market *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5;
  tbb::internal::generic_scheduler *result;

  v5 = tbb::internal::NFS_Allocate(1uLL, 392, 0, a4);
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 192) = 0u;
  *(_OWORD *)(v5 + 208) = 0u;
  *(_OWORD *)(v5 + 224) = 0u;
  *(_OWORD *)(v5 + 240) = 0u;
  *(_OWORD *)(v5 + 256) = 0u;
  *(_OWORD *)(v5 + 272) = 0u;
  *(_OWORD *)(v5 + 288) = 0u;
  *(_OWORD *)(v5 + 304) = 0u;
  *(_OWORD *)(v5 + 320) = 0u;
  *(_OWORD *)(v5 + 336) = 0u;
  *(_OWORD *)(v5 + 352) = 0u;
  *(_OWORD *)(v5 + 368) = 0u;
  *(_QWORD *)(v5 + 384) = 0;
  result = tbb::internal::generic_scheduler::generic_scheduler((tbb::internal::generic_scheduler *)v5, a1);
  *(_QWORD *)result = &unk_24C516740;
  return result;
}

uint64_t sub_20BDD3C78()
{
  unsigned __int8 v0;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v0 = atomic_load((unsigned __int8 *)&qword_254784DC8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_254784DC8))
  {
    v2 = operator new(0x100uLL);
    *(_DWORD *)v2 = 0;
    v2[16] = 65539;
    *((_DWORD *)v2 + 42) = 55;
    tbb::task_group_context::init((uint64_t)v2, v3, v4, v5);
    qword_254784DC0 = (uint64_t)v2;
    __cxa_guard_release(&qword_254784DC8);
  }
  return qword_254784DC0;
}

void sub_20BDD3CF4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  __cxa_guard_abort(&qword_254784DC8);
  _Unwind_Resume(a1);
}

tbb::internal::generic_scheduler *tbb::internal::generic_scheduler::generic_scheduler(tbb::internal::generic_scheduler *this, tbb::internal::market *a2)
{
  int v4;
  void *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;

  *((_QWORD *)this + 8) = 0;
  *(_QWORD *)this = &off_24C5165C8;
  *((_QWORD *)this + 15) = a2;
  v4 = -1168702475 * ((HIDWORD(this) + (_DWORD)this) | 1);
  *((_DWORD *)this + 32) = v4 ^ ((HIDWORD(this) + (_DWORD)this) >> 1);
  *((_DWORD *)this + 33) = v4;
  *((_QWORD *)this + 19) = 1;
  *((_QWORD *)this + 21) = 1;
  *((_BYTE *)this + 312) = 0;
  v6 = sub_20BDD3C78();
  v7 = *((_QWORD *)this + 17);
  if (v7)
  {
LABEL_2:
    *((_QWORD *)this + 17) = *(_QWORD *)(v7 - 8);
  }
  else
  {
    v9 = (unint64_t *)((char *)this + 176);
    if (*((_QWORD *)this + 22))
    {
      while (1)
      {
        v7 = *v9;
        do
        {
          while (1)
          {
            v10 = __ldaxr(v9);
            if (v10 != v7)
              break;
            if (!__stlxr(0, v9))
              goto LABEL_2;
          }
          __clrex();
          do
            v11 = __ldxr(v9);
          while (__stxr(v11, v9));
        }
        while (v11 == v7);
        sched_yield();
      }
    }
    v12 = tbb::internal::NFS_Allocate(1uLL, 256, 0, v5);
    v7 = v12 + 64;
    *(_QWORD *)(v12 + 16) = this;
    *(_QWORD *)(v12 + 56) = 0;
    ++*((_QWORD *)this + 21);
  }
  *(_QWORD *)(v7 - 24) = 0;
  *(_QWORD *)(v7 - 16) = 0x300000000;
  *(_QWORD *)(v7 - 40) = this;
  *(_QWORD *)(v7 - 32) = 0;
  *(_QWORD *)(v7 - 64) = 0;
  *(_QWORD *)(v7 - 56) = v6;
  *((_QWORD *)this + 18) = v7;
  *((_QWORD *)this + 7) = v7;
  *((_BYTE *)this + 74) |= 2u;
  *((_QWORD *)this + 12) = (char *)a2 + 48;
  *((_QWORD *)this + 13) = (char *)a2 + 64;
  *((_QWORD *)this + 40) = tbb::internal::the_context_state_propagation_epoch;
  *((_QWORD *)this + 37) = (char *)this + 296;
  *((_QWORD *)this + 38) = (char *)this + 296;
  return this;
}

unint64_t tbb::internal::generic_scheduler::allocate_task(tbb::internal::generic_scheduler *this, unint64_t a2, tbb::task *a3, tbb::task_group_context *a4)
{
  unint64_t result;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;

  if (a2 > 0xC0)
  {
    v8 = tbb::internal::NFS_Allocate(1uLL, a2 + 64, 0, a4);
    result = v8 + 64;
    *(_QWORD *)(v8 + 16) = 0;
  }
  else
  {
    result = *((_QWORD *)this + 17);
    if (result)
    {
LABEL_3:
      *((_QWORD *)this + 17) = *(_QWORD *)(result - 8);
    }
    else
    {
      v9 = (unint64_t *)((char *)this + 176);
      if (*((_QWORD *)this + 22))
      {
        while (1)
        {
          result = *v9;
          do
          {
            while (1)
            {
              v10 = __ldaxr(v9);
              if (v10 != result)
                break;
              if (!__stlxr(0, v9))
                goto LABEL_3;
            }
            __clrex();
            do
              v11 = __ldxr(v9);
            while (__stxr(v11, v9));
          }
          while (v11 == result);
          sched_yield();
        }
      }
      v12 = tbb::internal::NFS_Allocate(1uLL, 256, 0, a4);
      result = v12 + 64;
      *(_QWORD *)(v12 + 16) = this;
      *(_QWORD *)(v12 + 56) = 0;
      ++*((_QWORD *)this + 21);
    }
  }
  *(_QWORD *)(result - 24) = 0;
  *(_QWORD *)(result - 16) = 0x300000000;
  *(_QWORD *)(result - 40) = this;
  *(_QWORD *)(result - 32) = a3;
  *(_QWORD *)(result - 64) = 0;
  *(_QWORD *)(result - 56) = a4;
  return result;
}

uint64_t tbb::internal::generic_scheduler::init_stack_info(uint64_t this)
{
  char v1;

  *(_QWORD *)(this + 112) = &v1 - (*(_QWORD *)(*(_QWORD *)(this + 120) + 208) >> 1);
  return this;
}

uint64_t tbb::internal::generic_scheduler::cleanup_local_context_list(uint64_t this)
{
  _QWORD *v1;
  uint64_t v2;
  BOOL v3;
  _BYTE *v4;
  unsigned int *v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  _QWORD *v10;
  char v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;

  v1 = (_QWORD *)this;
  v2 = *(_QWORD *)(this + 320);
  *(_QWORD *)(this + 328) = 1;
  __dmb(0xBu);
  if (*(_QWORD *)(this + 368))
    v3 = 0;
  else
    v3 = v2 == tbb::internal::the_context_state_propagation_epoch;
  if (!v3)
  {
    v4 = (_BYTE *)(this + 312);
    v5 = (unsigned int *)((this + 312) & 0xFFFFFFFFFFFFFFFCLL);
    v6 = 1 << (8 * ((this + 56) & 3));
    v7 = ~(255 << (8 * ((this + 56) & 3)));
    while (1)
    {
      v8 = *v5 & v7;
      do
      {
        while (1)
        {
          v9 = __ldaxr(v5);
          if (v9 != v8)
            break;
          if (!__stlxr(v8 | v6, v5))
            goto LABEL_13;
        }
        __clrex();
      }
      while (*v5 == v8);
      this = sched_yield();
    }
  }
  v4 = 0;
LABEL_13:
  v10 = (_QWORD *)v1[38];
  if (v10 == v1 + 37)
  {
    v11 = 0;
  }
  else
  {
    v11 = 0;
    do
    {
      v12 = (unsigned int *)(v10 - 2);
      v10 = (_QWORD *)v10[1];
LABEL_17:
      v13 = *v12;
      do
      {
        while (1)
        {
          v14 = __ldaxr(v12);
          if (v14 == v13)
            break;
          __clrex();
          if (*v12 != v13)
          {
            this = sched_yield();
            goto LABEL_17;
          }
        }
      }
      while (__stlxr(3u, v12));
      v11 |= v13 == 4;
    }
    while (v10 != v1 + 37);
  }
  if (v4)
  {
    __dmb(0xBu);
    *v4 = 0;
  }
  __dmb(0xBu);
  v1[41] = 0;
  if ((v11 & 1) != 0)
  {
    while (1)
    {
      v15 = v1[46];
      __dmb(0xBu);
      if (!v15)
        break;
      this = sched_yield();
    }
  }
  return this;
}

void sub_20BDD40D0(_Unwind_Exception *a1)
{
  _BYTE *v1;

  __dmb(0xBu);
  *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t tbb::internal::generic_scheduler::destroy(tbb::internal::generic_scheduler *this)
{
  void *v2;

  (*(void (**)(tbb::internal::generic_scheduler *))(*(_QWORD *)this + 24))(this);
  return tbb::internal::NFS_Free(this, v2);
}

uint64_t tbb::internal::generic_scheduler::cleanup_scheduler(tbb::internal::generic_scheduler *this)
{
  void *v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t result;
  unint64_t *v10;
  unint64_t v11;
  void *v12;

  tbb::internal::generic_scheduler::cleanup_local_context_list((uint64_t)this);
  v4 = *((_QWORD *)this + 17);
  v3 = *((_QWORD *)this + 18);
  *(_BYTE *)(v3 - 12) = 4;
  *(_QWORD *)(v3 - 8) = v4;
  v5 = (unint64_t *)((char *)this + 176);
  v6 = 1;
LABEL_2:
  for (*((_QWORD *)this + 17) = v3; v3; v3 = *((_QWORD *)this + 17))
  {
    *((_QWORD *)this + 17) = *(_QWORD *)(v3 - 8);
    tbb::internal::NFS_Free((tbb::internal *)(v3 - 64), v2);
    ++v6;
  }
  if (*v5 != -1)
  {
    while (1)
    {
      v3 = *v5;
      do
      {
        while (1)
        {
          v7 = __ldaxr(v5);
          if (v7 != v3)
            break;
          if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v5))
            goto LABEL_2;
        }
        __clrex();
        do
          v8 = __ldxr(v5);
        while (__stxr(v8, v5));
      }
      while (v8 == v3);
      sched_yield();
    }
  }
  result = tbb::internal::governor::sign_off((uint64_t)this);
  v10 = (unint64_t *)((char *)this + 168);
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - v6, v10));
  if (v11 == v6)
  {
    (*(void (**)(tbb::internal::generic_scheduler *))(*(_QWORD *)this + 24))(this);
    return tbb::internal::NFS_Free(this, v12);
  }
  return result;
}

uint64_t tbb::internal::generic_scheduler::free_nonlocal_small_task(tbb::internal::generic_scheduler *this, tbb::task *a2)
{
  tbb::internal *v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  void *v11;

  v2 = (tbb::internal *)*((_QWORD *)a2 - 6);
  v3 = (unint64_t *)((char *)v2 + 176);
  while (1)
  {
    v5 = *v3;
    if (*v3 == -1)
      break;
    *((_QWORD *)a2 - 1) = v5;
    do
    {
      while (1)
      {
        v6 = __ldaxr(v3);
        if (v6 == v5)
          break;
        __clrex();
        do
          v4 = __ldxr(v3);
        while (__stxr(v4, v3));
        if (v4 != v5)
          goto LABEL_3;
      }
    }
    while (__stlxr((unint64_t)a2, v3));
    v4 = v5;
LABEL_3:
    if (v5 == v4)
      return result;
  }
  result = tbb::internal::NFS_Free((tbb::task *)((char *)a2 - 64), a2);
  v8 = (unint64_t *)((char *)v2 + 168);
  do
  {
    v9 = __ldaxr(v8);
    v10 = v9 - 1;
  }
  while (__stlxr(v10, v8));
  if (!v10)
  {
    (*(void (**)(tbb::internal *))(*(_QWORD *)v2 + 24))(v2);
    return tbb::internal::NFS_Free(v2, v11);
  }
  return result;
}

_BYTE *tbb::internal::generic_scheduler::local_spawn(tbb::internal::generic_scheduler *this, tbb::task *a2, tbb::task **a3, void *a4)
{
  tbb::task *v4;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  unint64_t v10;
  uint64_t v11;
  tbb::task *v12;
  tbb::task **v13;
  _BYTE *result;
  void *v15;
  uint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v40;
  char v41;
  _BYTE *v42;
  int64x2_t v43;
  _BYTE *v44;
  unint64_t v45;
  uint64_t v46;
  _BYTE v47[520];
  uint64_t v48;

  v4 = a2;
  v48 = *MEMORY[0x24BDAC8D0];
  if ((tbb::task **)((char *)a2 - 8) == a3)
  {
    v28 = sub_20BDD4668((uint64_t)this, (void *)1, (uint64_t)a3, a4);
    result = sub_20BDD48B4((uint64_t)this, (unint64_t)v4, v29, v30);
    *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 5) + 152) + 8 * v28) = result;
    v31 = *((_QWORD *)this + 5);
    __dmb(0xBu);
    *(_QWORD *)(v31 + 136) = v28 + 1;
    v32 = *((_QWORD *)this + 5);
    if (!*(_QWORD *)(v32 + 8))
    {
      v33 = *(_QWORD *)(v32 + 152);
      __dmb(0xBu);
      *(_QWORD *)(v32 + 8) = v33;
    }
  }
  else
  {
    v7 = 0;
    v8 = 0;
    v9 = v47;
    memset(v47, 0, 512);
    v42 = v47;
    v10 = 64;
    v43 = vdupq_n_s64(0x40uLL);
    v11 = 64;
    v45 = 0;
    v46 = 0;
    do
    {
      v13 = (tbb::task **)((char *)v4 - 8);
      v12 = (tbb::task *)*((_QWORD *)v4 - 1);
      result = sub_20BDD48B4((uint64_t)this, (unint64_t)v4, (uint64_t)a3, a4);
      v16 = (uint64_t)result;
      if (!v11)
      {
        if (!v8)
        {
          v45 = 1;
          v44 = v9;
          v8 = 1;
        }
        v7 += v10;
        v46 = v7;
        v10 *= 2;
        v43.i64[0] = v10;
        v43.i64[1] = v10;
        result = (_BYTE *)tbb::internal::NFS_Allocate(v10, 8, 0, a4);
        v17 = &(&v42)[v8++];
        v42 = result;
        v45 = v8;
        v17[3] = result;
        v9 = v42;
        v11 = v10;
      }
      v43.i64[1] = --v11;
      *(_QWORD *)&v9[8 * v11] = v16;
      v4 = v12;
    }
    while (v13 != a3);
    v18 = v10 + v7 - v11;
    if (v10 + v7 != v11)
    {
      v19 = sub_20BDD4668((uint64_t)this, (void *)(v10 + v7 - v11), (uint64_t)a3, a4);
      v20 = (char *)(*(_QWORD *)(*((_QWORD *)this + 5) + 152) + 8 * v19);
      result = memcpy(v20, &v42[8 * v11], 8 * (v10 - v11));
      if (v8 >= 2)
      {
        v21 = &v20[8 * (v10 - v11)];
        do
        {
          v10 >>= 1;
          result = memcpy(v21, (const void *)v43.i64[v8], 8 * v10);
          v21 += 8 * v10;
          --v8;
        }
        while (v8 != 1);
      }
      v22 = *((_QWORD *)this + 5);
      __dmb(0xBu);
      *(_QWORD *)(v22 + 136) = v19 + v18;
      v23 = *((_QWORD *)this + 5);
      if (!*(_QWORD *)(v23 + 8))
      {
        v24 = *(_QWORD *)(v23 + 152);
        __dmb(0xBu);
        *(_QWORD *)(v23 + 8) = v24;
      }
    }
    v25 = v45;
    if (v45 >= 2)
    {
      v26 = 4;
      do
      {
        result = (_BYTE *)tbb::internal::NFS_Free((tbb::internal *)(&v42)[v26], v15);
        v27 = v26 - 2;
        ++v26;
      }
      while (v27 < v25);
    }
  }
  v34 = *((_QWORD *)this + 6);
  v35 = (unint64_t *)(v34 + 216);
  v36 = *(_QWORD *)(v34 + 216);
  __dmb(0xBu);
  if (v36 != -1)
  {
    do
    {
      while (1)
      {
        v37 = __ldaxr(v35);
        if (v37 == v36)
          break;
        __clrex();
        do
          v38 = __ldxr(v35);
        while (__stxr(v38, v35));
        if (v38 != v36)
        {
          if (v38)
            return result;
          goto LABEL_30;
        }
      }
    }
    while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v35));
    if (v36)
      return result;
LABEL_30:
    if (v36)
    {
      do
      {
        while (!__ldaxr(v35))
        {
          if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v35))
            goto LABEL_38;
        }
        __clrex();
        do
          v40 = __ldxr(v35);
        while (__stxr(v40, v35));
      }
      while (!v40);
    }
    else
    {
LABEL_38:
      if (*(_BYTE *)(v34 + 336))
      {
        *(_DWORD *)(v34 + 208) = 0;
        *(_BYTE *)(v34 + 336) = 0;
      }
      else
      {
        v41 = *(_BYTE *)(v34 + 337);
        __dmb(0xBu);
        if ((v41 & 1) != 0)
          tbb::internal::market::mandatory_concurrency_disable(*(tbb::internal::market **)(v34 + 304), (tbb::internal::arena *)v34);
        return (_BYTE *)tbb::internal::market::adjust_demand(*(_QWORD *)(v34 + 304), v34, *(_DWORD *)(v34 + 208));
      }
    }
  }
  return result;
}

void sub_20BDD462C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_20BDD4638(_Unwind_Exception *a1, void *a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_20BDD4AF8((uint64_t)va, a2);
  _Unwind_Resume(a1);
}

unint64_t sub_20BDD4668(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v9;
  unint64_t *v10;
  tbb::internal *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int64x2_t v19;
  int64x2_t v20;
  int64x2_t *v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v4 = *(_QWORD **)(a1 + 40);
  v5 = v4[17];
  v6 = v4[18];
  if ((unint64_t)a2 + v5 <= v6)
    return v5;
  v7 = (unint64_t)a2;
  if (v6)
  {
    v9 = v4[1];
    if (v9)
    {
      while (1)
      {
        if (v9 != -1)
        {
          v10 = v4 + 1;
          v11 = (tbb::internal *)v4[19];
          do
          {
            while (1)
            {
              v12 = __ldaxr(v10);
              if ((tbb::internal *)v12 != v11)
                break;
              if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v10))
                goto LABEL_5;
            }
            __clrex();
            do
              v13 = __ldxr(v10);
            while (__stxr(v13, v10));
          }
          while ((tbb::internal *)v13 == v11);
          v11 = (tbb::internal *)v13;
LABEL_5:
          v4 = *(_QWORD **)(a1 + 40);
          if ((tbb::internal *)v4[19] == v11)
            break;
        }
        sched_yield();
        v4 = *(_QWORD **)(a1 + 40);
        v9 = v4[1];
      }
    }
    else
    {
      v11 = (tbb::internal *)v4[19];
    }
    v16 = v4[2];
    v17 = v5 - v16;
    if (v5 <= v16)
      goto LABEL_29;
    if (v17 >= 4)
    {
      v18 = v16 + (v17 & 0xFFFFFFFFFFFFFFFCLL);
      v19 = 0uLL;
      v20 = (int64x2_t)v7;
      v21 = (int64x2_t *)((char *)v11 + 8 * v16 + 16);
      v22 = v17 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v20 = vsubq_s64(v20, vtstq_s64(v21[-1], v21[-1]));
        v19 = vsubq_s64(v19, vtstq_s64(*v21, *v21));
        v21 += 2;
        v22 -= 4;
      }
      while (v22);
      v7 = vaddvq_s64(vaddq_s64(v19, v20));
      if (v17 == (v17 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_29:
        v26 = v4[18];
        v27 = v26 - 16;
        if (v7 > v26 - 16)
        {
          v28 = 2 * v26;
          if (v7 > v28)
            v28 = v7;
          v29 = (8 * v28 + 127) & 0xFFFFFFFFFFFFFF80;
          v4[18] = v29 >> 3;
          v4[19] = tbb::internal::NFS_Allocate(1uLL, v29, 0, a4);
        }
        v30 = v5 - v16;
        if (v5 <= v16)
        {
          v5 = 0;
        }
        else
        {
          v5 = 0;
          v31 = (_QWORD *)((char *)v11 + 8 * v16);
          do
          {
            if (*v31)
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 152) + 8 * v5++) = *v31;
            ++v31;
            --v30;
          }
          while (v30);
        }
        if (v7 > v27)
          tbb::internal::NFS_Free(v11, a2);
        v32 = *(_QWORD *)(a1 + 40);
        *(_QWORD *)(v32 + 16) = 0;
        __dmb(0xBu);
        *(_QWORD *)(v32 + 136) = v5;
        v33 = *(_QWORD *)(a1 + 40);
        if (*(_QWORD *)(v33 + 8))
        {
          v34 = *(_QWORD *)(v33 + 152);
          __dmb(0xBu);
          *(_QWORD *)(v33 + 8) = v34;
        }
        return v5;
      }
    }
    else
    {
      v18 = v4[2];
    }
    v23 = v5 - v18;
    v24 = (_QWORD *)((char *)v11 + 8 * v18);
    do
    {
      if (*v24++)
        ++v7;
      --v23;
    }
    while (v23);
    goto LABEL_29;
  }
  v14 = 64;
  if ((unint64_t)a2 > 0x40)
    v14 = (uint64_t)a2;
  v15 = (8 * v14 + 127) & 0xFFFFFFFFFFFFFF80;
  v4[18] = v15 >> 3;
  v5 = 0;
  v4[19] = tbb::internal::NFS_Allocate(1uLL, v15, 0, a4);
  return v5;
}

_QWORD *sub_20BDD48B4(uint64_t a1, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  tbb::internal *v10;
  uint64_t v11;
  unsigned int *v12;
  int v13;
  unsigned int v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;

  *(_BYTE *)(a2 - 12) = 2;
  v5 = *(unsigned __int16 *)(a2 - 10);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 56) - 64);
  *(_QWORD *)(a2 - 64) = v6;
  if (!(_DWORD)v5 || (_DWORD)v5 == *(unsigned __int16 *)(a1 + 72))
    return (_QWORD *)a2;
  v8 = *(_QWORD **)(a1 + 136);
  if (v8)
  {
LABEL_6:
    *(_QWORD *)(a1 + 136) = *(v8 - 1);
  }
  else
  {
    v24 = (unint64_t *)(a1 + 176);
    if (*(_QWORD *)(a1 + 176))
    {
      while (1)
      {
        v8 = (_QWORD *)*v24;
        do
        {
          while (1)
          {
            v25 = __ldaxr(v24);
            if ((_QWORD *)v25 != v8)
              break;
            if (!__stlxr(0, v24))
              goto LABEL_6;
          }
          __clrex();
          do
            v26 = __ldxr(v24);
          while (__stxr(v26, v24));
        }
        while ((_QWORD *)v26 == v8);
        sched_yield();
      }
    }
    v27 = tbb::internal::NFS_Allocate(1uLL, 256, 0, a4);
    v8 = (_QWORD *)(v27 + 64);
    *(_QWORD *)(v27 + 16) = a1;
    *(_QWORD *)(v27 + 56) = 0;
    ++*(_QWORD *)(a1 + 168);
  }
  *(v8 - 8) = v6;
  *(v8 - 7) = 0;
  v10 = (tbb::internal *)(v8 - 8);
  *((_QWORD *)v10 + 3) = a1;
  *((_QWORD *)v10 + 4) = 0;
  *((_QWORD *)v10 + 5) = 0;
  *((_QWORD *)v10 + 6) = 0x200300000000;
  v11 = *(_QWORD *)(a1 + 48) - (v5 << 7);
  v8[3] = v11;
  v8[1] = a2 | 3;
  v12 = (unsigned int *)(v11 + 16);
  v13 = *(_DWORD *)(v11 + 16);
  __dmb(0xBu);
  if (v13 > 32)
  {
    *((_BYTE *)v8 - 12) = 4;
    v19 = *(v8 - 6);
    if (v19 == a1)
    {
      *(v8 - 1) = *(_QWORD *)(a1 + 136);
      *(_QWORD *)(a1 + 136) = v8;
    }
    else if (!v19 || v19 >= 0x1000)
    {
      if (v19)
      {
        v20 = (unint64_t *)(v19 + 176);
        while (1)
        {
          v22 = *v20;
          if (*v20 == -1)
            break;
          *(v8 - 1) = v22;
          do
          {
            while (1)
            {
              v23 = __ldaxr(v20);
              if (v23 == v22)
                break;
              __clrex();
              do
                v21 = __ldxr(v20);
              while (__stxr(v21, v20));
              if (v21 != v22)
                goto LABEL_23;
            }
          }
          while (__stlxr((unint64_t)v8, v20));
          v21 = v22;
LABEL_23:
          if (v22 == v21)
            return (_QWORD *)a2;
        }
        tbb::internal::NFS_Free(v10, (void *)a2);
        v28 = (unint64_t *)(v19 + 168);
        do
        {
          v29 = __ldaxr(v28);
          v30 = v29 - 1;
        }
        while (__stlxr(v30, v28));
        if (v30)
          return (_QWORD *)a2;
        (*(void (**)(unint64_t))(*(_QWORD *)v19 + 24))(v19);
        v10 = (tbb::internal *)v19;
      }
      tbb::internal::NFS_Free(v10, (void *)a2);
    }
    return (_QWORD *)a2;
  }
  do
    v14 = __ldaxr(v12);
  while (__stlxr(v14 + 1, v12));
  v8[2] = 0;
  v15 = (unint64_t *)(v11 + 8);
LABEL_10:
  v16 = (_QWORD *)*v15;
  do
  {
    while (1)
    {
      v17 = __ldaxr(v15);
      if ((_QWORD *)v17 == v16)
        break;
      __clrex();
      do
        v18 = __ldxr(v15);
      while (__stxr(v18, v15));
      if ((_QWORD *)v18 != v16)
      {
        sched_yield();
        goto LABEL_10;
      }
    }
  }
  while (__stlxr((unint64_t)(v8 + 2), v15));
  *v16 = v8;
  return v8;
}

uint64_t sub_20BDD4AF8(uint64_t a1, void *a2)
{
  uint64_t v3;
  unint64_t v4;

  if (*(_QWORD *)(a1 + 152) >= 2uLL)
  {
    v3 = 4;
    do
    {
      tbb::internal::NFS_Free(*(tbb::internal **)(a1 + 8 * v3), a2);
      v4 = v3 - 2;
      ++v3;
    }
    while (v4 < *(_QWORD *)(a1 + 152));
  }
  return a1;
}

uint64_t tbb::internal::generic_scheduler::local_spawn_root_and_wait(tbb::internal::generic_scheduler *this, tbb::task *a2, tbb::task **a3, void *a4)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  tbb::task **v10;
  tbb::task *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t result;
  uint64_t v16;

  v7 = *((_QWORD *)a2 - 7);
  v8 = (_QWORD *)*((_QWORD *)this + 17);
  if (v8)
  {
LABEL_2:
    *((_QWORD *)this + 17) = *(v8 - 1);
  }
  else
  {
    v12 = (unint64_t *)((char *)this + 176);
    if (*((_QWORD *)this + 22))
    {
      while (1)
      {
        v8 = (_QWORD *)*v12;
        do
        {
          while (1)
          {
            v13 = __ldaxr(v12);
            if ((_QWORD *)v13 != v8)
              break;
            if (!__stlxr(0, v12))
              goto LABEL_2;
          }
          __clrex();
          do
            v14 = __ldxr(v12);
          while (__stxr(v14, v12));
        }
        while ((_QWORD *)v14 == v8);
        sched_yield();
      }
    }
    v16 = tbb::internal::NFS_Allocate(1uLL, 256, 0, a4);
    v8 = (_QWORD *)(v16 + 64);
    *(_QWORD *)(v16 + 16) = this;
    *(_QWORD *)(v16 + 56) = 0;
    ++*((_QWORD *)this + 21);
  }
  *(v8 - 5) = this;
  *(v8 - 4) = 0;
  *(v8 - 3) = 0;
  *(v8 - 2) = 0x10300000000;
  *(v8 - 8) = 0;
  *(v8 - 7) = v7;
  *v8 = &unk_24C5164A8;
  *((_QWORD *)a2 - 4) = v8;
  if ((tbb::task **)((char *)a2 - 8) == a3)
  {
    *(v8 - 3) = 2;
  }
  else
  {
    v9 = 2;
    v10 = (tbb::task **)((char *)a2 - 8);
    do
    {
      v11 = *v10;
      *((_QWORD *)v11 - 4) = v8;
      v10 = (tbb::task **)((char *)v11 - 8);
      ++v9;
    }
    while (v10 != a3);
    *(v8 - 3) = v9;
    tbb::internal::generic_scheduler::local_spawn(this, *((tbb::task **)a2 - 1), a3, a4);
  }
  result = (*(uint64_t (**)(tbb::internal::generic_scheduler *, _QWORD *, tbb::task *))(*(_QWORD *)this + 48))(this, v8, a2);
  *((_BYTE *)v8 - 12) = 4;
  *(v8 - 1) = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = v8;
  return result;
}

void sub_20BDD4CA0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_BYTE *)(v2 - 12) = 4;
  *(_QWORD *)(v2 - 8) = *(_QWORD *)(v1 + 136);
  *(_QWORD *)(v1 + 136) = v2;
  _Unwind_Resume(a1);
}

_BYTE *tbb::internal::generic_scheduler::spawn(tbb::internal::generic_scheduler *this, tbb::task *a2, tbb::task **a3)
{
  unint64_t v5;
  void *v6;
  tbb::internal::generic_scheduler *inited;

  v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v5 & 1) != 0)
    inited = (tbb::internal::generic_scheduler *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  else
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  return tbb::internal::generic_scheduler::local_spawn(inited, a2, a3, v6);
}

uint64_t tbb::internal::generic_scheduler::spawn_root_and_wait(tbb::internal::generic_scheduler *this, tbb::task *a2, tbb::task **a3)
{
  unint64_t v5;
  void *v6;
  tbb::internal::generic_scheduler *inited;

  v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v5 & 1) != 0)
    inited = (tbb::internal::generic_scheduler *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  else
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  return tbb::internal::generic_scheduler::local_spawn_root_and_wait(inited, a2, a3, v6);
}

uint64_t tbb::internal::generic_scheduler::enqueue(tbb::internal::generic_scheduler *this, tbb::task *a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t inited;

  v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v5 & 1) != 0)
    inited = v5 & 0xFFFFFFFFFFFFFFFELL;
  else
    inited = tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  return tbb::internal::arena::enqueue_task(*(_QWORD **)(inited + 48), (uint64_t)a2, a3, (unsigned int *)(inited + 128));
}

unint64_t tbb::internal::generic_scheduler::get_task_and_activate_task_pool(tbb::internal::generic_scheduler *this, unint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  char v15;

  v4 = a3;
  v5 = a2;
  v15 = 0;
  if (a3 <= a2)
  {
    v10 = 0;
  }
  else
  {
    v8 = a3;
    do
    {
      v9 = sub_20BDD4ED4((uint64_t)this, (void *)--v4, a4, &v15);
      v10 = v9;
      v11 = v15 + v8;
      v8 = v11 - 1;
    }
    while (!v9 && v4 > v5);
    if (v9)
    {
      if (v15)
      {
        *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 5) + 152) + 8 * v4) = 0;
        if (v5 == v4)
          ++v5;
      }
    }
    v4 = v11 - 1;
  }
  v12 = (_QWORD *)*((_QWORD *)this + 5);
  if (v5 < v4)
  {
    v12[2] = v5;
    v12[17] = v4;
    v13 = v12[19];
    __dmb(0xBu);
LABEL_14:
    v12[1] = v13;
    goto LABEL_15;
  }
  v13 = 0;
  v12[2] = 0;
  v12[17] = 0;
  if (v12[1])
    goto LABEL_14;
LABEL_15:
  if (v15 && *((_QWORD *)this + 7) == v10)
    (*(void (**)(unint64_t, _QWORD))(*(_QWORD *)v10 + 24))(v10, *((unsigned __int16 *)this + 36));
  return v10;
}

unint64_t sub_20BDD4ED4(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  unint64_t result;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  tbb::internal *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;

  result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 152) + 8 * (_QWORD)a2);
  if (!result)
    return result;
  if (a3 && *(_QWORD *)(result - 64) != a3)
  {
    result = 0;
    *a4 = 1;
    return result;
  }
  if (*(_BYTE *)(result - 11) != 32)
    return result;
  v9 = (unint64_t *)(result + 8);
  v8 = *(_QWORD *)(result + 8);
  __dmb(0xBu);
  if (v8 == 1)
    goto LABEL_17;
  do
  {
    while (1)
    {
      v10 = __ldaxr(v9);
      if (v10 == v8)
        break;
      __clrex();
      do
        v11 = __ldxr(v9);
      while (__stxr(v11, v9));
      if (v11 != v8)
        goto LABEL_17;
    }
  }
  while (__stlxr(2uLL, v9));
  v12 = v8 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v8 & 0xFFFFFFFFFFFFFFFCLL) == 0)
  {
LABEL_17:
    *(_BYTE *)(result - 12) = 4;
    v13 = *(_QWORD *)(result - 48);
    if (v13 == a1)
    {
      *(_QWORD *)(result - 8) = *(_QWORD *)(a1 + 136);
      *(_QWORD *)(a1 + 136) = result;
    }
    else if (!v13 || v13 >= 0x1000)
    {
      if (v13)
      {
        v14 = (unint64_t *)(v13 + 176);
        while (1)
        {
          v16 = *v14;
          if (*v14 == -1)
            break;
          *(_QWORD *)(result - 8) = v16;
          do
          {
            while (1)
            {
              v17 = __ldaxr(v14);
              if (v17 == v16)
                break;
              __clrex();
              do
                v15 = __ldxr(v14);
              while (__stxr(v15, v14));
              if (v15 != v16)
                goto LABEL_23;
            }
          }
          while (__stlxr(result, v14));
          v15 = v16;
LABEL_23:
          if (v16 == v15)
            goto LABEL_39;
        }
        tbb::internal::NFS_Free((tbb::internal *)(result - 64), a2);
        v19 = (unint64_t *)(v13 + 168);
        do
        {
          v20 = __ldaxr(v19);
          v21 = v20 - 1;
        }
        while (__stlxr(v21, v19));
        if (v21)
          goto LABEL_39;
        (*(void (**)(unint64_t))(*(_QWORD *)v13 + 24))(v13);
        v18 = (tbb::internal *)v13;
      }
      else
      {
        v18 = (tbb::internal *)(result - 64);
      }
      tbb::internal::NFS_Free(v18, a2);
    }
LABEL_39:
    result = 0;
    if (*a4)
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 152) + 8 * (_QWORD)a2) = 0;
    return result;
  }
  *(_QWORD *)(a1 + 56) = v12;
  result = v8 & 0xFFFFFFFFFFFFFFFCLL;
  if (!*a4)
  {
    (*(void (**)(unint64_t, _QWORD))(*(_QWORD *)v12 + 24))(v12, *(unsigned __int16 *)(a1 + 72));
    return v12;
  }
  return result;
}

unint64_t tbb::internal::generic_scheduler::winnow_task_pool(tbb::internal::generic_scheduler *this, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t result;

  *((_BYTE *)this + 360) = 1;
  v4 = (_QWORD *)*((_QWORD *)this + 5);
  v5 = v4[1];
  if (v5)
  {
    if (v5 == -1)
      goto LABEL_11;
    while (1)
    {
      v6 = v4 + 1;
      v7 = v4[19];
      do
      {
        while (1)
        {
          v8 = __ldaxr(v6);
          if (v8 != v7)
            break;
          if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v6))
            goto LABEL_10;
        }
        __clrex();
        do
          v9 = __ldxr(v6);
        while (__stxr(v9, v6));
      }
      while (v9 == v7);
      v7 = v9;
LABEL_10:
      v4 = (_QWORD *)*((_QWORD *)this + 5);
      if (v4[19] == v7)
        break;
      do
      {
LABEL_11:
        sched_yield();
        v4 = (_QWORD *)*((_QWORD *)this + 5);
      }
      while (v4[1] == -1);
    }
  }
  v10 = v4[17];
  v11 = v4[2];
  if (v11 >= v10)
  {
    v12 = 0;
  }
  else
  {
    v12 = 0;
    do
    {
      v14 = *(_QWORD *)(*((_QWORD *)this + 5) + 152);
      v15 = *(_QWORD *)(v14 + 8 * v11);
      if (v15)
      {
        if (*(_BYTE *)(v15 - 11) == 32 || *(_QWORD *)(*(_QWORD *)(v15 - 56) + 160) >= **((_QWORD **)this + 12))
        {
          v13 = (_QWORD *)(v14 + 8 * v12++);
        }
        else
        {
          *(_QWORD *)(v15 - 40) = *((_QWORD *)this + 42);
          v13 = (_QWORD *)((char *)this + 336);
        }
        *v13 = v15;
      }
      ++v11;
    }
    while (v10 != v11);
  }
  result = tbb::internal::generic_scheduler::get_task_and_activate_task_pool(this, 0, v12, a2);
  *((_BYTE *)this + 360) = 0;
  return result;
}

void sub_20BDD51E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 360) = 0;
  _Unwind_Resume(a1);
}

void sub_20BDD51EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 360) = 0;
  _Unwind_Resume(a1);
}

unint64_t tbb::internal::generic_scheduler::reload_tasks(tbb::internal::generic_scheduler *this, tbb::task **a2, tbb::task ***a3, void *a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  tbb::task *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  tbb::task **v20;
  uint64_t v21;
  _QWORD *v22;
  tbb::task *v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  unint64_t task_and_activate_task_pool;
  uint64_t v32;
  unint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v38;
  char v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  tbb::task ***v44;
  _BYTE *v46;
  int64x2_t v47;
  _BYTE *v48;
  unint64_t v49;
  uint64_t v50;
  _BYTE v51[520];
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v9 = *((_QWORD *)this + 5);
  v10 = *(_QWORD *)(v9 + 8);
  if (v10)
  {
    while (1)
    {
      if (v10 != -1)
      {
        v11 = (unint64_t *)(v9 + 8);
        v12 = *(_QWORD *)(v9 + 152);
        do
        {
          while (1)
          {
            v13 = __ldaxr(v11);
            if (v13 != v12)
              break;
            if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v11))
              goto LABEL_3;
          }
          __clrex();
          do
            v14 = __ldxr(v11);
          while (__stxr(v14, v11));
        }
        while (v14 == v12);
        v12 = v14;
LABEL_3:
        if (*(_QWORD *)(*((_QWORD *)this + 5) + 152) == v12)
          break;
      }
      sched_yield();
      v9 = *((_QWORD *)this + 5);
      v10 = *(_QWORD *)(v9 + 8);
    }
  }
  memset(v51, 0, 512);
  v46 = v51;
  v15 = 64;
  v47 = vdupq_n_s64(0x40uLL);
  v49 = 0;
  v50 = 0;
  v16 = *a2;
  if (*a2)
  {
    v44 = a3;
    v17 = 0;
    v18 = 0;
    v15 = 64;
    v19 = 64;
    v20 = a2;
    do
    {
      while (*(_QWORD *)(*((_QWORD *)v16 - 7) + 160) < (uint64_t)a4)
      {
        v20 = (tbb::task **)((char *)v16 - 40);
        v16 = (tbb::task *)*((_QWORD *)v16 - 5);
        if (!v16)
          goto LABEL_22;
      }
      if (!v19)
      {
        if (!v18)
        {
          v49 = 1;
          v48 = v46;
          v18 = 1;
        }
        v17 += v15;
        v50 = v17;
        v15 *= 2;
        v47.i64[0] = v15;
        v47.i64[1] = v15;
        v21 = tbb::internal::NFS_Allocate(v15, 8, 0, a4);
        v22 = &(&v46)[v18++];
        v46 = (_BYTE *)v21;
        v49 = v18;
        v22[3] = v21;
        v19 = v15;
      }
      v47.i64[1] = --v19;
      *(_QWORD *)&v46[8 * v19] = v16;
      v23 = (tbb::task *)*((_QWORD *)v16 - 5);
      *((_QWORD *)v16 - 5) = this;
      *v20 = v23;
      v16 = v23;
    }
    while (v23);
LABEL_22:
    if (v20 != a2)
    {
      *v20 = 0;
      *v44 = v20;
      goto LABEL_26;
    }
  }
  else
  {
    v18 = 0;
    v19 = 64;
  }
  *a2 = 0;
LABEL_26:
  v24 = v15 + v50 - v19;
  if (v15 + v50 == v19)
  {
    v25 = *((_QWORD *)this + 5);
    v26 = 0;
    if (*(_QWORD *)(v25 + 8))
    {
      v27 = *(_QWORD *)(v25 + 152);
      __dmb(0xBu);
      *(_QWORD *)(v25 + 8) = v27;
    }
  }
  else
  {
    v28 = sub_20BDD4668((uint64_t)this, (void *)(v15 + v50 - v19), (uint64_t)a3, a4);
    v29 = (char *)(*(_QWORD *)(*((_QWORD *)this + 5) + 152) + 8 * v28);
    memcpy(v29, &v46[8 * v19], 8 * (v15 - v19));
    if (v18 >= 2)
    {
      v30 = &v29[8 * (v15 - v19)];
      do
      {
        v15 >>= 1;
        memcpy(v30, (const void *)v47.i64[v18], 8 * v15);
        v30 += 8 * v15;
        --v18;
      }
      while (v18 != 1);
    }
    task_and_activate_task_pool = tbb::internal::generic_scheduler::get_task_and_activate_task_pool(this, *(_QWORD *)(*((_QWORD *)this + 5) + 16), v28 + v24, a5);
    v26 = task_and_activate_task_pool;
    if (v24 != 1 || !task_and_activate_task_pool)
    {
      v32 = *((_QWORD *)this + 6);
      v33 = (unint64_t *)(v32 + 216);
      v34 = *(_QWORD *)(v32 + 216);
      __dmb(0xBu);
      if (v34 != -1)
      {
        do
        {
          while (1)
          {
            v35 = __ldaxr(v33);
            if (v35 == v34)
              break;
            __clrex();
            do
              v36 = __ldxr(v33);
            while (__stxr(v36, v33));
            if (v36 != v34)
            {
              if (v36)
                goto LABEL_58;
              goto LABEL_45;
            }
          }
        }
        while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v33));
        if (v34)
          goto LABEL_58;
LABEL_45:
        if (v34)
        {
          do
          {
            while (!__ldaxr(v33))
            {
              if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v33))
                goto LABEL_53;
            }
            __clrex();
            do
              v38 = __ldxr(v33);
            while (__stxr(v38, v33));
          }
          while (!v38);
        }
        else
        {
LABEL_53:
          if (*(_BYTE *)(v32 + 336))
          {
            *(_DWORD *)(v32 + 208) = 0;
            *(_BYTE *)(v32 + 336) = 0;
          }
          else
          {
            v39 = *(_BYTE *)(v32 + 337);
            __dmb(0xBu);
            if ((v39 & 1) != 0)
              tbb::internal::market::mandatory_concurrency_disable(*(tbb::internal::market **)(v32 + 304), (tbb::internal::arena *)v32);
            tbb::internal::market::adjust_demand(*(_QWORD *)(v32 + 304), v32, *(_DWORD *)(v32 + 208));
          }
        }
      }
    }
  }
LABEL_58:
  v40 = v49;
  if (v49 >= 2)
  {
    v41 = 4;
    do
    {
      tbb::internal::NFS_Free((tbb::internal *)(&v46)[v41], a2);
      v42 = v41 - 2;
      ++v41;
    }
    while (v42 < v40);
  }
  return v26;
}

void sub_20BDD55F4(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_20BDD4AF8((uint64_t)va, a2);
  _Unwind_Resume(a1);
}

void sub_20BDD5610(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  sub_20BDC12F4(exception_object);
}

unint64_t tbb::internal::generic_scheduler::reload_tasks(tbb::internal::generic_scheduler *this, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v5;
  unsigned int v6;
  void **v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v17;

  v2 = **((_QWORD **)this + 13);
  if (*((_QWORD *)this + 44) == v2)
    return 0;
  if ((*((_BYTE *)this + 74) & 3) == 2
    && (v5 = *((_QWORD *)this + 6),
        v6 = *(_DWORD *)(v5 + 128),
        LODWORD(v5) = *(_DWORD *)(v5 + 132),
        __dmb(0xBu),
        v6 >= v5 >> 12))
  {
    v7 = (void **)(*((_QWORD *)this + 6) + 136);
  }
  else
  {
    v7 = (void **)*((_QWORD *)this + 12);
  }
  v8 = *v7;
  v3 = tbb::internal::generic_scheduler::reload_tasks(this, (tbb::task **)this + 42, (tbb::task ***)this + 43, *v7, a2);
  v9 = *((_QWORD *)this + 42);
  if (v9)
  {
    v10 = *((_QWORD *)this + 6);
    if (*(_QWORD *)(v10 + 264) >= (uint64_t)v8 || !*(_DWORD *)(v10 + 212))
    {
      tbb::internal::market::update_arena_priority(*((_QWORD *)this + 15), v10, *(_QWORD *)(*(_QWORD *)(v9 - 56) + 160));
      v11 = *((_QWORD *)this + 6);
      __dmb(0xBu);
      v12 = (unint64_t *)(v11 + 216);
      v13 = *(_QWORD *)(v11 + 216);
      __dmb(0xBu);
      if (v13 != -1)
      {
        do
        {
          while (1)
          {
            v14 = __ldaxr(v12);
            if (v14 == v13)
              break;
            __clrex();
            do
              v15 = __ldxr(v12);
            while (__stxr(v15, v12));
            if (v15 != v13)
            {
              if (v15)
                goto LABEL_29;
              goto LABEL_20;
            }
          }
        }
        while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v12));
        if (v13)
          goto LABEL_29;
LABEL_20:
        if (v13)
        {
          do
          {
            while (!__ldaxr(v12))
            {
              if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v12))
                goto LABEL_28;
            }
            __clrex();
            do
              v17 = __ldxr(v12);
            while (__stxr(v17, v12));
          }
          while (!v17);
        }
        else
        {
LABEL_28:
          tbb::internal::market::adjust_demand(*(_QWORD *)(v11 + 304), v11, *(_DWORD *)(v11 + 208));
        }
      }
    }
  }
LABEL_29:
  *((_QWORD *)this + 44) = v2;
  return v3;
}

unint64_t tbb::internal::generic_scheduler::steal_task(tbb::internal::generic_scheduler *this, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  int v4;
  unint64_t v5;
  unint64_t v7;
  void *v8;
  int v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  tbb::internal::generic_scheduler *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  tbb::internal *v20;
  unint64_t *v21;
  unint64_t v22;

  v2 = *((_DWORD *)this + 32);
  v3 = HIWORD(v2);
  *((_DWORD *)this + 32) = *((_DWORD *)this + 33) - 1640531535 * v2;
  v4 = *(_DWORD *)(*((_QWORD *)this + 6) + 144);
  __dmb(0xBu);
  v5 = *((_QWORD *)this + 6)
     + ((unint64_t)(v3 % (v4 - 1)) << 8)
     + ((unint64_t)(*((_QWORD *)this + 4) <= (unint64_t)(v3 % (v4 - 1))) << 8);
  if (!*(_QWORD *)(v5 + 392))
    return 0;
  v7 = tbb::internal::generic_scheduler::steal_task_from((uint64_t)this, (_QWORD *)(v5 + 384), a2);
  if (!v7)
    return 0;
  v9 = *(unsigned __int8 *)(v7 - 11);
  if (v9 != 32)
  {
    v14 = v7;
    goto LABEL_13;
  }
  v11 = (unint64_t *)(v7 + 8);
  v10 = *(_QWORD *)(v7 + 8);
  __dmb(0xBu);
  if (v10 == 1)
    goto LABEL_17;
  do
  {
    while (1)
    {
      v12 = __ldaxr(v11);
      if (v12 == v10)
        break;
      __clrex();
      do
        v13 = __ldxr(v11);
      while (__stxr(v13, v11));
      if (v13 != v10)
        goto LABEL_17;
    }
  }
  while (__stlxr(2uLL, v11));
  v14 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v10 & 0xFFFFFFFFFFFFFFFCLL) == 0)
  {
LABEL_17:
    *(_BYTE *)(v7 - 12) = 4;
    v15 = *(tbb::internal::generic_scheduler **)(v7 - 48);
    if (v15 == this)
    {
      v14 = 0;
      *(_QWORD *)(v7 - 8) = *((_QWORD *)this + 17);
      *((_QWORD *)this + 17) = v7;
      return v14;
    }
    if (!v15 || (unint64_t)v15 >= 0x1000)
    {
      if (v15)
      {
        v16 = (unint64_t *)((char *)v15 + 176);
        while (1)
        {
          v18 = *v16;
          if (*v16 == -1)
            break;
          *(_QWORD *)(v7 - 8) = v18;
          do
          {
            while (1)
            {
              v19 = __ldaxr(v16);
              if (v19 == v18)
                break;
              __clrex();
              do
                v17 = __ldxr(v16);
              while (__stxr(v17, v16));
              if (v17 != v18)
                goto LABEL_23;
            }
          }
          while (__stlxr(v7, v16));
          v17 = v18;
LABEL_23:
          v14 = 0;
          if (v18 == v17)
            return v14;
        }
        tbb::internal::NFS_Free((tbb::internal *)(v7 - 64), v8);
        v21 = (unint64_t *)((char *)v15 + 168);
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (v22 != 1)
          return 0;
        (*(void (**)(tbb::internal::generic_scheduler *))(*(_QWORD *)v15 + 24))(v15);
        v20 = v15;
      }
      else
      {
        v20 = (tbb::internal *)(v7 - 64);
      }
      tbb::internal::NFS_Free(v20, v8);
    }
    return 0;
  }
  LOBYTE(v9) = *(_BYTE *)(v14 - 11);
LABEL_13:
  *(_BYTE *)(v14 - 11) = v9 | 0x80;
  if ((v9 & 0xF) != 0)
  {
    *((_QWORD *)this + 7) = v14;
    *(_QWORD *)(v14 - 40) = this;
    (*(void (**)(unint64_t, _QWORD))(*(_QWORD *)v14 + 24))(v14, *((unsigned __int16 *)this + 36));
  }
  return v14;
}

uint64_t tbb::internal::generic_scheduler::steal_task_from(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v22;

  v6 = a2 + 1;
  while (1)
  {
    v8 = *v6;
    if (*v6 != -1)
    {
      if (!v8)
        return 0;
      do
      {
        while (1)
        {
          v9 = __ldaxr(v6);
          if (v9 == v8)
            break;
          __clrex();
          do
            v7 = __ldxr(v6);
          while (__stxr(v7, v6));
          if (v7 != v8)
            goto LABEL_3;
        }
      }
      while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v6));
      v7 = v8;
LABEL_3:
      if (v8 == v7)
        break;
    }
    sched_yield();
  }
  v10 = a2[2];
  a2[2] = v10 + 1;
  __dmb(0xBu);
  if (v10 + 1 > a2[17])
  {
    v11 = 0;
    a2[2] = v10;
    __dmb(0xBu);
    a2[1] = v8;
    return v11;
  }
  v13 = 0;
  v14 = v10;
  while (1)
  {
    __dmb(0xBu);
    v11 = *(_QWORD *)(v8 + 8 * v10);
    if (!v11)
    {
      if ((v13 & 1) == 0)
        v14 = v10 + 1;
      goto LABEL_20;
    }
    if ((!a3 || *(_QWORD *)(v11 - 64) == a3)
      && (*(_BYTE *)(v11 - 11) != 32 || (~*(_DWORD *)(v11 + 8) & 3) != 0 || !*(_BYTE *)(*(_QWORD *)(v11 + 24) + 20)))
    {
      break;
    }
    v13 = 1;
LABEL_20:
    v15 = v10 + 2;
    a2[2] = v10 + 2;
    __dmb(0xBu);
    ++v10;
    if (v15 > a2[17])
    {
      v11 = 0;
      a2[2] = v14;
      __dmb(0xBu);
      a2[1] = v8;
      if ((v13 & 1) == 0)
        return v11;
      goto LABEL_31;
    }
  }
  if ((v13 & 1) == 0)
  {
    __dmb(0xBu);
    *v6 = v8;
    return v11;
  }
  *(_QWORD *)(v8 + 8 * v10) = 0;
  a2[2] = v14;
  __dmb(0xBu);
  a2[1] = v8;
LABEL_31:
  v16 = *(_QWORD *)(a1 + 48);
  __dmb(0xBu);
  v17 = (unint64_t *)(v16 + 216);
  v18 = *(_QWORD *)(v16 + 216);
  __dmb(0xBu);
  if (v18 != -1)
  {
    do
    {
      while (1)
      {
        v19 = __ldaxr(v17);
        if (v19 == v18)
          break;
        __clrex();
        do
          v20 = __ldxr(v17);
        while (__stxr(v20, v17));
        if (v20 != v18)
          goto LABEL_41;
      }
    }
    while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v17));
    v20 = v18;
LABEL_41:
    if (!v20)
    {
      if (v18)
      {
        do
        {
          while (!__ldaxr(v17))
          {
            if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v17))
              goto LABEL_50;
          }
          __clrex();
          do
            v22 = __ldxr(v17);
          while (__stxr(v22, v17));
        }
        while (!v22);
      }
      else
      {
LABEL_50:
        tbb::internal::market::adjust_demand(*(_QWORD *)(v16 + 304), v16, *(_DWORD *)(v16 + 208));
      }
    }
  }
  return v11;
}

unint64_t tbb::internal::generic_scheduler::get_mailbox_task(tbb::internal::generic_scheduler *this, void *a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t *v6;
  unint64_t v7;
  unint64_t i;
  unint64_t *v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t result;
  tbb::internal::generic_scheduler *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  tbb::internal *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;

  v2 = (unint64_t *)*((_QWORD *)this + 8);
  v3 = *v2;
  if (*v2)
  {
    while (1)
    {
      if (a2)
      {
        v6 = v2;
        if (*(void **)(v3 - 64) != a2)
        {
          while (1)
          {
            v7 = v3;
            v3 = *(_QWORD *)(v3 + 16);
            if (!v3)
              return 0;
            if (*(void **)(v3 - 64) == a2)
            {
              v6 = (unint64_t *)(v7 + 16);
              break;
            }
          }
        }
      }
      else
      {
        v6 = v2;
      }
      __dmb(0xBu);
      v9 = (unint64_t *)(v3 + 16);
      i = *(_QWORD *)(v3 + 16);
      if (i)
        goto LABEL_12;
      *v6 = 0;
      v16 = v2 + 1;
      do
      {
        while (1)
        {
          v17 = __ldaxr(v16);
          if ((unint64_t *)v17 == v9)
            break;
          __clrex();
          do
            v18 = __ldxr(v16);
          while (__stxr(v18, v16));
          if ((unint64_t *)v18 != v9)
            goto LABEL_47;
        }
      }
      while (__stlxr((unint64_t)v6, v16));
      v18 = v3 + 16;
LABEL_47:
      if (v9 != (unint64_t *)v18)
        break;
LABEL_13:
      v10 = (unsigned int *)(v2 + 2);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      v13 = (unint64_t *)(v3 + 8);
      v12 = *(_QWORD *)(v3 + 8);
      __dmb(0xBu);
      if (v12 != 2)
      {
        do
        {
          while (1)
          {
            v14 = __ldaxr(v13);
            if (v14 == v12)
              break;
            __clrex();
            do
              v15 = __ldxr(v13);
            while (__stxr(v15, v13));
            if (v15 != v12)
              goto LABEL_31;
          }
        }
        while (__stlxr(1uLL, v13));
        result = v12 & 0xFFFFFFFFFFFFFFFCLL;
        if ((v12 & 0xFFFFFFFFFFFFFFFCLL) != 0)
        {
          *(_BYTE *)(result - 11) |= 0x80u;
          return result;
        }
      }
LABEL_31:
      *(_BYTE *)(v3 - 12) = 4;
      v20 = *(tbb::internal::generic_scheduler **)(v3 - 48);
      if (v20 == this)
      {
        *(_QWORD *)(v3 - 8) = *((_QWORD *)this + 17);
        *((_QWORD *)this + 17) = v3;
      }
      else if (!v20 || (unint64_t)v20 >= 0x1000)
      {
        if (v20)
        {
          v21 = (unint64_t *)((char *)v20 + 176);
          while (1)
          {
            v23 = *v21;
            if (*v21 == -1)
              break;
            *(_QWORD *)(v3 - 8) = v23;
            do
            {
              while (1)
              {
                v24 = __ldaxr(v21);
                if (v24 == v23)
                  break;
                __clrex();
                do
                  v22 = __ldxr(v21);
                while (__stxr(v22, v21));
                if (v22 != v23)
                  goto LABEL_37;
              }
            }
            while (__stlxr(v3, v21));
            v22 = v23;
LABEL_37:
            if (v23 == v22)
              goto LABEL_4;
          }
          tbb::internal::NFS_Free((tbb::internal *)(v3 - 64), a2);
          v26 = (unint64_t *)((char *)v20 + 168);
          do
          {
            v27 = __ldaxr(v26);
            v28 = v27 - 1;
          }
          while (__stlxr(v28, v26));
          if (v28)
            goto LABEL_4;
          (*(void (**)(tbb::internal::generic_scheduler *))(*(_QWORD *)v20 + 24))(v20);
          v25 = v20;
        }
        else
        {
          v25 = (tbb::internal *)(v3 - 64);
        }
        tbb::internal::NFS_Free(v25, a2);
      }
LABEL_4:
      v2 = (unint64_t *)*((_QWORD *)this + 8);
      v3 = *v2;
      if (!*v2)
        return 0;
    }
    for (i = *v9; !*v9; i = *v9)
      sched_yield();
LABEL_12:
    *v6 = i;
    goto LABEL_13;
  }
  return 0;
}

uint64_t tbb::internal::generic_scheduler::create_worker(tbb::internal::generic_scheduler *this, tbb::internal::market *a2, uint64_t a3)
{
  int v3;
  uint64_t SchedulerPtr;
  uint64_t v6;
  _BYTE v8[8];

  v3 = a3;
  SchedulerPtr = tbb::internal::AllocateSchedulerPtr(this, a3);
  v6 = SchedulerPtr;
  *(_QWORD *)(SchedulerPtr + 32) = a2;
  *(_QWORD *)(*(_QWORD *)(SchedulerPtr + 144) - 24) = 2;
  *(_BYTE *)(SchedulerPtr + 74) &= ~1u;
  if (v3)
    *(_QWORD *)(SchedulerPtr + 112) = &v8[-(*(_QWORD *)(*(_QWORD *)(SchedulerPtr + 120) + 208) >> 1)];
  tbb::internal::governor::sign_on(SchedulerPtr);
  return v6;
}

uint64_t tbb::internal::generic_scheduler::create_master(tbb::internal::generic_scheduler *this, tbb::internal::arena *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int64x2_t *v6;
  uint64_t SchedulerPtr;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  char v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  tbb::internal *v23;
  uint64_t v24;
  _BYTE v26[8];

  v6 = tbb::internal::market::global_market(0, 0, 0, a4, a5);
  SchedulerPtr = tbb::internal::AllocateSchedulerPtr(v6, 1);
  v8 = *(_QWORD *)(SchedulerPtr + 144);
  *(_BYTE *)(SchedulerPtr + 74) |= 1u;
  *(_QWORD *)(v8 - 24) = 1;
  v10 = tbb::internal::NFS_Allocate(1uLL, 256, 0, v9);
  *(_DWORD *)v10 = 0;
  *(_QWORD *)(v10 + 128) = 65539;
  *(_DWORD *)(v10 + 168) = 55;
  tbb::task_group_context::init(v10, v11, v12, v13);
  *(_QWORD *)(v8 - 56) = v10;
  tbb::task_group_context::capture_fp_settings(*(tbb::task_group_context **)(*(_QWORD *)(SchedulerPtr + 144) - 56), v14, v15, v16);
  *(_QWORD *)(SchedulerPtr + 112) = &v26[-(*(_QWORD *)(*(_QWORD *)(SchedulerPtr + 120) + 208) >> 1)];
LABEL_2:
  v17 = 8 * (&tbb::internal::the_context_state_propagation_mutex & 3);
  v18 = *(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v17);
  v19 = v18 | (1 << v17);
  do
  {
    while (1)
    {
      v20 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL));
      if (v20 == v18)
        break;
      __clrex();
      if (*(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) != v18)
      {
        sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v19, (unsigned int *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL)));
  v21 = *(_QWORD *)(SchedulerPtr + 120);
  *(_QWORD *)(SchedulerPtr + 16) = v21 + 224;
  v22 = *(_QWORD *)(v21 + 240);
  *(_QWORD *)(SchedulerPtr + 24) = *(_QWORD *)(v21 + 232);
  **(_QWORD **)(v21 + 232) = SchedulerPtr + 16;
  *(_QWORD *)(v21 + 232) = SchedulerPtr + 16;
  *(_QWORD *)(v21 + 240) = v22 + 1;
  __dmb(0xBu);
  LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
  if (this)
  {
    tbb::internal::generic_scheduler::attach_arena(SchedulerPtr, (uint64_t)this, 0, 1);
    **(_QWORD **)(SchedulerPtr + 40) = SchedulerPtr;
    *((_QWORD *)this + 40) = *(_QWORD *)(*(_QWORD *)(SchedulerPtr + 144) - 56);
  }
  v23 = (tbb::internal *)tbb::internal::governor::sign_on(SchedulerPtr);
  v24 = tbb::internal::the_global_observer_list(v23);
  if (*(_QWORD *)(SchedulerPtr + 80) != *(_QWORD *)(v24 + 8))
    tbb::internal::observer_list::do_notify_entry_observers((tbb::internal::observer_proxy **)v24, (tbb::internal::observer_proxy **)(SchedulerPtr + 80), 0);
  return SchedulerPtr;
}

uint64_t tbb::internal::generic_scheduler::cleanup_worker(tbb::internal::observer_proxy **this, void *a2)
{
  tbb::internal::observer_proxy **v3;
  tbb::internal::observer_proxy *v4;

  if ((_DWORD)a2)
  {
    v3 = (tbb::internal::observer_proxy **)tbb::internal::the_global_observer_list((tbb::internal *)this);
    v4 = this[10];
    if (v4)
      tbb::internal::observer_list::do_notify_exit_observers(v3, v4, 1);
  }
  return tbb::internal::generic_scheduler::cleanup_scheduler((tbb::internal::generic_scheduler *)this);
}

uint64_t tbb::internal::generic_scheduler::cleanup_master(uint64_t this, uint64_t a2)
{
  tbb::internal::generic_scheduler *v3;
  uint64_t v4;
  tbb::internal::market *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  tbb::internal::observer_proxy **v13;
  tbb::internal::observer_proxy *v14;
  void *v15;
  tbb::internal::observer_proxy *v16;
  tbb::internal::observer_proxy **v17;
  tbb::internal::observer_proxy *v18;
  _QWORD *v19;
  char v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  _QWORD *v24;
  uint64_t v25;
  tbb::internal::market *v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;

  v3 = (tbb::internal::generic_scheduler *)this;
  v4 = *(_QWORD *)(this + 48);
  v5 = *(tbb::internal::market **)(this + 120);
  if (v4)
  {
    v6 = *(_QWORD *)(this + 40);
    v7 = *(_QWORD *)(v6 + 8);
    if (v7)
    {
      while (1)
      {
        if (v7 != -1)
        {
          v9 = (unint64_t *)(v6 + 8);
          v10 = *(_QWORD *)(v6 + 152);
          do
          {
            while (1)
            {
              v11 = __ldaxr(v9);
              if (v11 != v10)
                break;
              if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v9))
                goto LABEL_4;
            }
            __clrex();
            do
              v12 = __ldxr(v9);
            while (__stxr(v12, v9));
          }
          while (v12 == v10);
          v10 = v12;
LABEL_4:
          v8 = (_QWORD *)*((_QWORD *)v3 + 5);
          if (v8[19] == v10)
            break;
        }
        this = sched_yield();
        v6 = *((_QWORD *)v3 + 5);
        v7 = *(_QWORD *)(v6 + 8);
      }
      if (v8[1] && v8[2] < v8[17])
      {
        __dmb(0xBu);
        v8[1] = v10;
        *(_QWORD *)(*((_QWORD *)v3 + 18) - 24) = 2;
        this = (*(uint64_t (**)(tbb::internal::generic_scheduler *))(*(_QWORD *)v3 + 48))(v3);
      }
      else
      {
        v8[1] = 0;
      }
    }
    v16 = (tbb::internal::observer_proxy *)*((_QWORD *)v3 + 11);
    if (v16)
      tbb::internal::observer_list::do_notify_exit_observers((tbb::internal::observer_proxy **)(v4 + 224), v16, 0);
    v17 = (tbb::internal::observer_proxy **)tbb::internal::the_global_observer_list((tbb::internal *)this);
    v18 = (tbb::internal::observer_proxy *)*((_QWORD *)v3 + 10);
    if (v18)
      tbb::internal::observer_list::do_notify_exit_observers(v17, v18, 0);
    v19 = (_QWORD *)*((_QWORD *)v3 + 5);
    __dmb(0xBu);
    *v19 = 0;
  }
  else
  {
    v13 = (tbb::internal::observer_proxy **)tbb::internal::the_global_observer_list((tbb::internal *)this);
    v14 = (tbb::internal::observer_proxy *)*((_QWORD *)v3 + 10);
    if (v14)
      tbb::internal::observer_list::do_notify_exit_observers(v13, v14, 0);
    tbb::task_group_context::~task_group_context(*(tbb::task_group_context **)(*((_QWORD *)v3 + 18) - 56));
    tbb::internal::NFS_Free(*(tbb::internal **)(*((_QWORD *)v3 + 18) - 56), v15);
  }
LABEL_26:
  v20 = 8 * (&tbb::internal::the_context_state_propagation_mutex & 3);
  v21 = *(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v20);
  v22 = v21 | (1 << v20);
  do
  {
    while (1)
    {
      v23 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL));
      if (v23 == v21)
        break;
      __clrex();
      if (*(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) != v21)
      {
        sched_yield();
        goto LABEL_26;
      }
    }
  }
  while (__stlxr(v22, (unsigned int *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL)));
  --*(_QWORD *)(*((_QWORD *)v3 + 15) + 240);
  v24 = (_QWORD *)*((_QWORD *)v3 + 3);
  *v24 = *((_QWORD *)v3 + 2);
  *(_QWORD *)(*((_QWORD *)v3 + 2) + 8) = v24;
  __dmb(0xBu);
  LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
  *((_QWORD *)v3 + 5) = 0;
  tbb::internal::generic_scheduler::cleanup_scheduler(v3);
  if (v4)
  {
    v26 = *(tbb::internal::market **)(v4 + 304);
    v25 = *(_QWORD *)(v4 + 312);
    if (*(_DWORD *)(v4 + 328) != *(_DWORD *)(v4 + 332)
      && !*((_DWORD *)v26 + 7)
      && !*(_BYTE *)(v4 + 337)
      && (tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v4) & 1) == 0
      && (tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v4) & 1) == 0)
    {
      tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v4);
    }
    v27 = (unsigned int *)(v4 + 132);
    do
    {
      v28 = __ldaxr(v27);
      v29 = v28 - 1;
    }
    while (__stlxr(v29, v27));
    if (!v29)
      tbb::internal::market::try_destroy_arena(v26, (tbb::internal::arena *)v4, v25);
  }
  return tbb::internal::market::release(v5, v4 != 0, a2);
}

uint64_t sub_20BDD6310(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  void *v6;
  tbb::internal::generic_scheduler *inited;

  v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v5 & 1) != 0)
    inited = (tbb::internal::generic_scheduler *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  else
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  return sub_20BDD6364(inited, a2, a3, v6);
}

uint64_t sub_20BDD6364(tbb::internal::generic_scheduler *a1, uint64_t a2, uint64_t a3, void *a4)
{
  tbb::task *v4;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  _BOOL4 v10;
  int v11;
  char v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  int v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  const std::exception_ptr *v21;
  tbb::internal *v22;
  void *v24;
  std::exception_ptr v25;
  uint64_t v27;
  fenv_t *v28;
  tbb::internal *v29;
  std::exception_ptr v30;

  v4 = (tbb::task *)a3;
  sub_20BDD22B4(&v27, a2, a3, a4);
  v7 = *((_QWORD *)a1 + 7);
  v8 = *((unsigned __int8 *)a1 + 74);
  v9 = *((_QWORD *)a1 + 18);
  v10 = v9 == a2;
  v11 = (v7 == v9) & (v8 >> 1);
  if (v11)
    v12 = 2;
  else
    v12 = 0;
  *((_BYTE *)a1 + 74) = v12 | v8 & 0xFD;
  v13 = *((_QWORD *)a1 + 12);
  v14 = (_QWORD *)*((_QWORD *)a1 + 13);
  if ((v11 & 1) == 0)
  {
    v15 = (_QWORD *)(*((_QWORD *)a1 + 6) + 272);
    *((_QWORD *)a1 + 12) = *(_QWORD *)(a2 - 56) + 160;
    *((_QWORD *)a1 + 13) = v15;
    if (v15 != v14)
      *((_QWORD *)a1 + 44) = *v15 - 1;
  }
  v16 = *(void **)(v7 - 64);
  if (v4 && v16)
    *((_QWORD *)v4 - 8) = v16;
  v17 = v8 & v10;
  v18 = (_QWORD *)(a2 - 24);
  while ((sub_20BDD6BB8(a1, &v27, v4, v16) & 1) != 0)
  {
    if (*v18 == 1)
    {
      __dmb(0xBu);
LABEL_19:
      *((_QWORD *)a1 + 7) = v7;
      *((_BYTE *)a1 + 74) = v8;
      *((_QWORD *)a1 + 12) = v13;
      if (*((_QWORD **)a1 + 13) != v14)
        *((_QWORD *)a1 + 44) = *v14 - 1;
      *((_QWORD *)a1 + 13) = v14;
      v20 = *(_QWORD *)(a2 - 56);
      if ((*(_BYTE *)(v20 + 130) & 4) == 0)
      {
        if (*v18 != 1)
          return sub_20BDD3AC0((uint64_t)&v27, v19);
        *v18 = 0;
      }
      if (*(_QWORD *)(v20 + 120))
      {
        v21 = *(const std::exception_ptr **)(v20 + 136);
        if ((~*((unsigned __int8 *)a1 + 74) & 3) == 0 && v20 == *(_QWORD *)(*((_QWORD *)a1 + 18) - 56))
        {
          *(_QWORD *)(v20 + 120) = 0;
          *(_QWORD *)(v20 + 152) &= ~1uLL;
        }
        if (v21)
        {
          v22 = (tbb::internal *)v28;
          if (*(_QWORD *)v29 != v28->__fpsr || *((_QWORD *)v29 + 1) != v28->__fpcr)
          {
            fesetenv(v28);
            v22 = v29;
            if (!v29)
            {
              v22 = (tbb::internal *)tbb::internal::NFS_Allocate(1uLL, 16, 0, v24);
              v29 = v22;
            }
            *(fenv_t *)v22 = *v28;
          }
          if (tbb::internal::governor::is_rethrow_broken)
            tbb::internal::fix_broken_rethrow(v22);
          std::exception_ptr::exception_ptr(&v30, v21);
          v25.__ptr_ = &v30;
          std::rethrow_exception(v25);
          __break(1u);
LABEL_39:
          *((_QWORD *)a1 + 7) = v7;
          *((_BYTE *)a1 + 74) = v8;
          *((_QWORD *)a1 + 12) = v13;
          if (*((_QWORD **)a1 + 13) != v14)
            *((_QWORD *)a1 + 44) = *v14 - 1;
          *((_QWORD *)a1 + 13) = v14;
          return sub_20BDD3AC0((uint64_t)&v27, v19);
        }
      }
      return sub_20BDD3AC0((uint64_t)&v27, v19);
    }
    if (*(_QWORD *)(*((_QWORD *)a1 + 5) + 8))
    {
      v4 = (tbb::task *)sub_20BDD704C((uint64_t)a1, (uint64_t)v16);
      if (v4)
        continue;
    }
    if (v17)
      goto LABEL_39;
    v4 = (tbb::task *)(*(uint64_t (**)(tbb::internal::generic_scheduler *, uint64_t, void *))(*(_QWORD *)a1 + 56))(a1, a2 - 24, v16);
    if (!v4)
      goto LABEL_19;
  }
  return sub_20BDD3AC0((uint64_t)&v27, v19);
}

void sub_20BDD671C(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, std::exception_ptr a14)
{
  sub_20BDD3AC0((uint64_t)&a11, a2);
  _Unwind_Resume(a1);
}

unint64_t sub_20BDD6774(tbb::internal::generic_scheduler *this, _QWORD *a2, void *a3)
{
  char v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  BOOL v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  void *v28;
  tbb::internal *mailbox_task;
  uint64_t v30;
  uint64_t v31;
  int v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  tbb::task *v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unsigned int v40;
  void **v41;
  unint64_t v42;
  tbb::task **v43;
  uint64_t v44;
  uint64_t v45;
  BOOL v47;
  tbb::task **v48;
  tbb::task *v49;

  v6 = *((_BYTE *)this + 74);
  v7 = *((_QWORD *)this + 14);
  v8 = *((_QWORD *)this + 8);
  if (v8)
    *(_BYTE *)(v8 + 20) = 1;
  if ((v6 & 2) != 0)
  {
    v9 = *(_QWORD *)(*((_QWORD *)this + 6) + 296);
    __dmb(0xBu);
    if (v9)
    {
      v10 = (unint64_t *)(*((_QWORD *)this + 6) + 296);
      do
      {
        while (1)
        {
          v11 = __ldaxr(v10);
          if (v11 == v9)
            break;
          __clrex();
          do
            v12 = __ldxr(v10);
          while (__stxr(v12, v10));
          if (v12 != v9)
            goto LABEL_14;
        }
      }
      while (__stlxr(0, v10));
      v13 = *((_QWORD *)this + 6);
      if (v9 > *(_QWORD *)(v13 + 136))
        tbb::internal::market::update_arena_priority(*((_QWORD *)this + 15), v13, v9);
    }
  }
LABEL_14:
  v14 = *(_DWORD *)(*((_QWORD *)this + 6) + 144);
  __dmb(0xBu);
  if (*a2 == 1)
  {
LABEL_15:
    v15 = 0;
    __dmb(0xBu);
    goto LABEL_16;
  }
  v17 = 0;
  v18 = v6 & 3;
  v19 = (v14 - 1);
  v21 = (v6 & 2) == 0 || a3 != 0;
  v47 = v21;
  v22 = -1;
  while (1)
  {
    if (v18 == 2)
    {
      v26 = *((_QWORD *)this + 6);
      v27 = *(_DWORD *)(v26 + 128);
      LODWORD(v26) = *(_DWORD *)(v26 + 132);
      __dmb(0xBu);
      if (v27 < v26 >> 12)
        return 0;
    }
    v28 = *(void **)(*((_QWORD *)this + 6) + 136);
    if (v19 && **((_QWORD **)this + 8))
    {
      mailbox_task = (tbb::internal *)tbb::internal::generic_scheduler::get_mailbox_task(this, a3);
      v15 = (unint64_t)mailbox_task;
      if (a3 && !mailbox_task)
      {
        v30 = *((_QWORD *)this + 8);
        if (*(_QWORD *)v30 && *(_BYTE *)(v30 + 20))
          *(_BYTE *)(v30 + 20) = 0;
        goto LABEL_42;
      }
      if (mailbox_task)
        goto LABEL_86;
    }
    if (!v47)
    {
      v31 = *((_QWORD *)this + 6) + 152;
      if (*(_QWORD *)(v31 + 8 * (int)v28))
      {
        mailbox_task = (tbb::internal *)sub_20BDD736C(v31, v28, (unsigned int *)(*((_QWORD *)this + 5) + 128));
        if (mailbox_task)
          break;
      }
    }
LABEL_42:
    if (*((_QWORD *)this + 42))
    {
      mailbox_task = (tbb::internal *)tbb::internal::generic_scheduler::reload_tasks(this, (uint64_t)a3);
      if (mailbox_task)
        break;
    }
    if (v7 < (unint64_t)&v49)
    {
      if (v19)
      {
        mailbox_task = (tbb::internal *)tbb::internal::generic_scheduler::steal_task(this, (uint64_t)a3);
        if (mailbox_task)
          break;
      }
    }
    if (v22 == -1)
      v25 = 0;
    else
      v25 = v22;
    sched_yield();
    v32 = 2 * v19 + 2;
    if (v25 < v32)
      goto LABEL_28;
    sched_yield();
    v23 = *((_QWORD *)this + 6);
    if (*(_QWORD *)(v23 + 280))
    {
      v33 = (unint64_t *)(v23 + 288);
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 + 1, v33));
      v49 = 0;
      v35 = (unint64_t *)(*((_QWORD *)this + 6) + 280);
LABEL_55:
      v36 = (tbb::task *)*v35;
      do
      {
        while (1)
        {
          v37 = __ldaxr(v35);
          if ((tbb::task *)v37 == v36)
            break;
          __clrex();
          do
            v38 = __ldxr(v35);
          while (__stxr(v38, v35));
          if ((tbb::task *)v38 != v36)
          {
            sched_yield();
            goto LABEL_55;
          }
        }
      }
      while (__stlxr(0, v35));
      v49 = v36;
      if (v36)
      {
        v48 = 0;
        --*((_QWORD *)this + 44);
        if ((*((_BYTE *)this + 74) & 3) == 2
          && (v39 = *((_QWORD *)this + 6),
              v40 = *(_DWORD *)(v39 + 128),
              LODWORD(v39) = *(_DWORD *)(v39 + 132),
              __dmb(0xBu),
              v40 >= v39 >> 12))
        {
          v41 = (void **)(*((_QWORD *)this + 6) + 136);
        }
        else
        {
          v41 = (void **)*((_QWORD *)this + 12);
        }
        v42 = tbb::internal::generic_scheduler::reload_tasks(this, &v49, &v48, *v41, (uint64_t)a3);
        v15 = v42;
        if (v49)
        {
          v43 = v48;
          *v48 = (tbb::task *)*((_QWORD *)this + 42);
          if (!*((_QWORD *)this + 42))
            *((_QWORD *)this + 43) = v43;
          *((_QWORD *)this + 42) = v49;
        }
        if (v42)
          goto LABEL_16;
      }
      v23 = *((_QWORD *)this + 6);
    }
    if (v17 >= 10)
    {
      if (v18 == 2)
      {
        if ((tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v23) & 1) != 0)
          return 0;
        if (*((_QWORD *)this + 42))
          --*((_QWORD *)this + 44);
        goto LABEL_26;
      }
      if (*(_QWORD *)(v23 + 136) <= *(_QWORD *)(v23 + 264))
      {
        if (!*((_QWORD *)this + 42))
          goto LABEL_27;
        --*((_QWORD *)this + 44);
      }
      else
      {
        tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v23);
        if (!*((_QWORD *)this + 42))
        {
LABEL_26:
          v23 = *((_QWORD *)this + 6);
          goto LABEL_27;
        }
        --*((_QWORD *)this + 44);
        v23 = *((_QWORD *)this + 6);
      }
      if (**((_QWORD **)this + 12) > *(_QWORD *)(v23 + 136))
        *((_QWORD *)this + 12) = v23 + 136;
    }
LABEL_27:
    ++v17;
    v24 = *(_DWORD *)(v23 + 144);
    __dmb(0xBu);
    v19 = (v24 - 1);
    v25 = v32;
LABEL_28:
    v22 = v25 + 1;
    if (*a2 == 1)
      goto LABEL_15;
  }
  v15 = (unint64_t)mailbox_task;
LABEL_86:
  v44 = *((_QWORD *)this + 6);
  if (*((_QWORD *)this + 11) != *(_QWORD *)(v44 + 232))
    tbb::internal::observer_list::do_notify_entry_observers((tbb::internal::observer_proxy **)(v44 + 224), (tbb::internal::observer_proxy **)this + 11, (*((_BYTE *)this + 74) & 1) == 0);
  v45 = tbb::internal::the_global_observer_list(mailbox_task);
  if (*((_QWORD *)this + 10) != *(_QWORD *)(v45 + 8))
    tbb::internal::observer_list::do_notify_entry_observers((tbb::internal::observer_proxy **)v45, (tbb::internal::observer_proxy **)this + 10, (*((_BYTE *)this + 74) & 1) == 0);
LABEL_16:
  v16 = *((_QWORD *)this + 8);
  if (v16 && *(_BYTE *)(v16 + 20))
    *(_BYTE *)(v16 + 20) = 0;
  return v15;
}

uint64_t sub_20BDD6BB8(tbb::internal::generic_scheduler *this, _QWORD *a2, tbb::task *a3, void *a4)
{
  tbb::task *v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v19;
  uint64_t v20;
  tbb::task *v21;
  void *v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  BOOL v26;
  int64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  BOOL v31;
  int64_t v32;
  tbb::internal::generic_scheduler *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t v40;
  void *v41;
  uint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v48;
  unsigned int *v50;

  if (!a3)
    return 1;
  v5 = a3;
  v50 = (unsigned int *)((char *)this + 128);
  while (1)
  {
    v8 = *((_QWORD *)v5 - 7);
    v9 = *(_QWORD *)(v8 + 160);
    if (v9 == **((_QWORD **)this + 12) || (*((_BYTE *)v5 - 11) & 0x10) != 0)
      goto LABEL_20;
    v10 = *((_QWORD *)this + 6);
    if (v9 != *(_QWORD *)(v10 + 136))
      tbb::internal::market::update_arena_priority(*((_QWORD *)this + 15), v10, *(_QWORD *)(v8 + 160));
    if ((*((_BYTE *)this + 74) & 3) == 2
      && (v11 = *((_QWORD *)this + 6),
          v12 = *(_DWORD *)(v11 + 128),
          LODWORD(v11) = *(_DWORD *)(v11 + 132),
          __dmb(0xBu),
          v12 >= v11 >> 12))
    {
      v13 = (_QWORD *)(*((_QWORD *)this + 6) + 136);
    }
    else
    {
      v13 = (_QWORD *)*((_QWORD *)this + 12);
    }
    if (v9 >= *v13)
    {
      v8 = *((_QWORD *)v5 - 7);
LABEL_20:
      *((_QWORD *)this + 7) = v5;
      *((_QWORD *)v5 - 5) = this;
      *((_BYTE *)v5 - 12) = 0;
      v16 = *(_QWORD *)(v8 + 112);
      v17 = a2[2];
      if (*(_QWORD *)v16 != *(_QWORD *)v17 || *(_QWORD *)(v16 + 8) != *(_QWORD *)(v17 + 8))
      {
        if (!v17)
        {
          v17 = tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
          a2[2] = v17;
          v16 = *(_QWORD *)(v8 + 112);
        }
        *(_OWORD *)v17 = *(_OWORD *)v16;
        fesetenv((const fenv_t *)a2[2]);
      }
      if (*a2 != v8)
        *a2 = v8;
      v19 = (_QWORD *)((char *)v5 - 64);
      if (*(_QWORD *)(*((_QWORD *)v5 - 7) + 120))
      {
        v15 = 0;
      }
      else
      {
        v20 = (*(uint64_t (**)(tbb::task *))(*(_QWORD *)v5 + 16))(v5);
        v15 = v20;
        if (v20)
        {
          *(_BYTE *)(v20 - 11) &= 0x6Fu;
          *(_QWORD *)(v20 - 64) = *v19;
        }
      }
      switch(*((_BYTE *)v5 - 12))
      {
        case 0:
          v21 = (tbb::task *)*((_QWORD *)v5 - 4);
          (**(void (***)(tbb::task *))v5)(v5);
          if (v21)
          {
            v23 = *v19;
            v24 = (unint64_t *)((char *)v21 - 24);
            do
            {
              v25 = __ldaxr(v24);
              v26 = __OFSUB__(v25, 1);
              v27 = v25 - 1;
            }
            while (__stlxr(v27, v24));
            if ((v27 < 0) ^ v26 | (v27 == 0))
            {
              __dmb(0xBu);
              if (v23)
                *((_QWORD *)v21 - 8) = v23;
              if (*((_BYTE *)v21 - 12) == 6)
              {
                tbb::internal::arena::enqueue_task(*((_QWORD **)this + 6), (uint64_t)v21, 0, v50);
              }
              else if (v15)
              {
                tbb::internal::generic_scheduler::local_spawn(this, v21, (tbb::task **)v21 - 1, a4);
              }
              else
              {
                v15 = (unint64_t)v21;
              }
            }
          }
          *((_BYTE *)v5 - 12) = 4;
          v33 = (tbb::internal::generic_scheduler *)*((_QWORD *)v5 - 6);
          if (v33 == this)
          {
            *((_QWORD *)v5 - 1) = *((_QWORD *)this + 17);
            *((_QWORD *)this + 17) = v5;
            goto LABEL_4;
          }
          if (v33 && (unint64_t)v33 < 0x1000)
            goto LABEL_4;
          if (!v33)
          {
            tbb::internal::NFS_Free((tbb::task *)((char *)v5 - 64), v22);
            goto LABEL_4;
          }
          v34 = (unint64_t *)((char *)v33 + 176);
          break;
        case 1:
          *((_BYTE *)v5 - 12) = 3;
          *((_BYTE *)v5 - 11) &= 0x6Fu;
          goto LABEL_54;
        case 3:
          *((_BYTE *)v5 - 11) &= 0x6Fu;
          goto LABEL_4;
        case 5:
          *((_BYTE *)v5 - 12) = 3;
          goto LABEL_45;
        case 6:
LABEL_45:
          *((_BYTE *)v5 - 11) &= 0x6Fu;
          v28 = *((_QWORD *)v5 - 8);
          v29 = (unint64_t *)((char *)v5 - 24);
          do
          {
            v30 = __ldaxr(v29);
            v31 = __OFSUB__(v30, 1);
            v32 = v30 - 1;
          }
          while (__stlxr(v32, v29));
          if ((v32 < 0) ^ v31 | (v32 == 0))
          {
            __dmb(0xBu);
            if (v28)
              *v19 = v28;
            if (*((_BYTE *)v5 - 12) == 6)
            {
              tbb::internal::arena::enqueue_task(*((_QWORD **)this + 6), (uint64_t)v5, 0, v50);
            }
            else if (v15)
            {
LABEL_54:
              tbb::internal::generic_scheduler::local_spawn(this, v5, (tbb::task **)v5 - 1, a4);
            }
            else
            {
              v15 = (unint64_t)v5;
            }
          }
          goto LABEL_4;
        default:
          goto LABEL_4;
      }
      while (1)
      {
        v36 = *v34;
        if (*v34 == -1)
          break;
        *((_QWORD *)v5 - 1) = v36;
        do
        {
          while (1)
          {
            v37 = __ldaxr(v34);
            if (v37 == v36)
              break;
            __clrex();
            do
              v35 = __ldxr(v34);
            while (__stxr(v35, v34));
            if (v35 != v36)
              goto LABEL_65;
          }
        }
        while (__stlxr((unint64_t)v5, v34));
        v35 = v36;
LABEL_65:
        if (v36 == v35)
          goto LABEL_4;
      }
      tbb::internal::NFS_Free((tbb::task *)((char *)v5 - 64), v22);
      v38 = (unint64_t *)((char *)v33 + 168);
      do
      {
        v39 = __ldaxr(v38);
        v40 = v39 - 1;
      }
      while (__stlxr(v40, v38));
      if (!v40)
      {
        (*(void (**)(tbb::internal::generic_scheduler *))(*(_QWORD *)v33 + 24))(v33);
        tbb::internal::NFS_Free(v33, v41);
      }
      goto LABEL_4;
    }
    v14 = *((_QWORD *)this + 42);
    if (!v14)
    {
      *((_QWORD *)this + 43) = (char *)v5 - 40;
      *((_QWORD *)v5 - 5) = 0;
      v14 = *((_QWORD *)this + 42);
    }
    *((_QWORD *)v5 - 5) = v14;
    *((_QWORD *)this + 42) = v5;
    if (!*(_QWORD *)(*((_QWORD *)this + 5) + 8))
      break;
    v15 = tbb::internal::generic_scheduler::winnow_task_pool(this, (uint64_t)a4);
    if (!v15)
      return 1;
LABEL_4:
    v5 = (tbb::task *)v15;
    if (!v15)
      return 1;
  }
  v42 = *((_QWORD *)this + 6);
  __dmb(0xBu);
  v43 = (unint64_t *)(v42 + 216);
  v44 = *(_QWORD *)(v42 + 216);
  __dmb(0xBu);
  if (v44 != -1)
  {
    do
    {
      while (1)
      {
        v45 = __ldaxr(v43);
        if (v45 == v44)
          break;
        __clrex();
        do
          v46 = __ldxr(v43);
        while (__stxr(v46, v43));
        if (v46 != v44)
          goto LABEL_89;
      }
    }
    while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v43));
    v46 = v44;
LABEL_89:
    if (!v46)
    {
      if (v44)
      {
        do
        {
          while (!__ldaxr(v43))
          {
            if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v43))
              goto LABEL_98;
          }
          __clrex();
          do
            v48 = __ldxr(v43);
          while (__stxr(v48, v43));
        }
        while (!v48);
      }
      else
      {
LABEL_98:
        tbb::internal::market::adjust_demand(*(_QWORD *)(v42 + 304), v42, *(_DWORD *)(v42 + 208));
      }
    }
  }
  return 1;
}

unint64_t sub_20BDD704C(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unint64_t *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v31;
  unint64_t v33;
  char v35;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 136);
  v35 = 0;
  v5 = -1;
  v6 = v4;
  while (1)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 136) = --v6;
    __dmb(0xBu);
    v7 = *(_QWORD **)(a1 + 40);
    if (v7[2] <= v6)
      goto LABEL_19;
    v8 = v7[1];
    if (v8)
    {
      while (1)
      {
        if (v8 != -1)
        {
          v10 = v7 + 1;
          v11 = v7[19];
          do
          {
            while (1)
            {
              v12 = __ldaxr(v10);
              if (v12 != v11)
                break;
              if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v10))
                goto LABEL_7;
            }
            __clrex();
            do
              v13 = __ldxr(v10);
            while (__stxr(v13, v10));
          }
          while (v13 == v11);
          v11 = v13;
LABEL_7:
          v7 = *(_QWORD **)(a1 + 40);
          if (v7[19] == v11)
            break;
        }
        sched_yield();
        v7 = *(_QWORD **)(a1 + 40);
        v8 = v7[1];
      }
    }
    v5 = v7[2];
    if (v5 > v6)
      break;
    if (v5 == v6)
    {
      v7[17] = 0;
      v7[2] = 0;
      v9 = 1;
      v5 = v6;
      v7[1] = 0;
      goto LABEL_20;
    }
    if (v7[1])
    {
      v9 = 0;
      v14 = v7[19];
      __dmb(0xBu);
      v7[1] = v14;
      goto LABEL_20;
    }
LABEL_19:
    v9 = 0;
LABEL_20:
    __dmb(0xBu);
    v15 = sub_20BDD4ED4(a1, (void *)v6, a2, &v35);
    if (v15)
    {
      v16 = v15;
      if (!v35)
        return v16;
      if (v9)
        goto LABEL_38;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 152) + 8 * v6) = 0;
      v17 = *(_QWORD *)(a1 + 40);
      __dmb(0xBu);
      *(_QWORD *)(v17 + 136) = v4;
      v18 = *(_QWORD *)(a1 + 48);
      __dmb(0xBu);
      v19 = (unint64_t *)(v18 + 216);
      v20 = *(_QWORD *)(v18 + 216);
      __dmb(0xBu);
      if (v20 == -1)
        goto LABEL_70;
      do
      {
        while (1)
        {
          v21 = __ldaxr(v19);
          if (v21 == v20)
            break;
          __clrex();
          do
            v22 = __ldxr(v19);
          while (__stxr(v22, v19));
          if (v22 != v20)
          {
            if (v22)
              goto LABEL_70;
            goto LABEL_61;
          }
        }
      }
      while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v19));
      if (v20)
        goto LABEL_70;
LABEL_61:
      if (v20)
      {
        do
        {
          while (!__ldaxr(v19))
          {
            if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v19))
              goto LABEL_69;
          }
          __clrex();
          do
            v33 = __ldxr(v19);
          while (__stxr(v33, v19));
        }
        while (!v33);
        goto LABEL_70;
      }
      goto LABEL_69;
    }
    if (!v35)
      v4 = v6;
    if ((v9 & 1) != 0)
    {
      v16 = 0;
      if (!v35)
        return v16;
      goto LABEL_38;
    }
  }
  v16 = 0;
  v7[17] = 0;
  v7[2] = 0;
  v7[1] = 0;
  if (!v35)
    return v16;
LABEL_38:
  if (v16)
    v23 = v5 + 1;
  else
    v23 = v5;
  if (v23 < v4)
  {
    v24 = *(_QWORD **)(a1 + 40);
    v24[2] = v23;
    v24[17] = v4;
    v25 = v24[19];
    __dmb(0xBu);
    v24[1] = v25;
    v18 = *(_QWORD *)(a1 + 48);
    __dmb(0xBu);
    v26 = (unint64_t *)(v18 + 216);
    v27 = *(_QWORD *)(v18 + 216);
    __dmb(0xBu);
    if (v27 != -1)
    {
      do
      {
        while (1)
        {
          v28 = __ldaxr(v26);
          if (v28 == v27)
            break;
          __clrex();
          do
            v29 = __ldxr(v26);
          while (__stxr(v29, v26));
          if (v29 != v27)
          {
            if (v29)
              goto LABEL_70;
            goto LABEL_52;
          }
        }
      }
      while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v26));
      if (v27)
        goto LABEL_70;
LABEL_52:
      if (v27)
      {
        do
        {
          while (!__ldaxr(v26))
          {
            if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v26))
              goto LABEL_69;
          }
          __clrex();
          do
            v31 = __ldxr(v26);
          while (__stxr(v31, v26));
        }
        while (!v31);
        goto LABEL_70;
      }
LABEL_69:
      tbb::internal::market::adjust_demand(*(_QWORD *)(v18 + 304), v18, *(_DWORD *)(v18 + 208));
    }
  }
LABEL_70:
  if (*(_QWORD *)(a1 + 56) == v16)
    (*(void (**)(unint64_t, _QWORD))(*(_QWORD *)v16 + 24))(v16, *(unsigned __int16 *)(a1 + 72));
  return v16;
}

uint64_t sub_20BDD736C(uint64_t a1, void *a2, unsigned int *a3)
{
  unsigned int v3;
  unint64_t *v4;
  unint64_t v5;
  _QWORD *v7;
  _BYTE *v8;
  unsigned int *v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unsigned int *v23;
  _QWORD *v24;

  v3 = (*(_DWORD *)(a1 + 48) - 1) & (*a3 + 1);
  v4 = (unint64_t *)(a1 + 8 * (int)a2);
  v5 = *v4;
  if (!*v4)
  {
    v14 = 0;
    goto LABEL_22;
  }
  v23 = a3;
  v24 = (_QWORD *)(a1 + 8 * (int)a2 + 24);
  while (((1 << v3) & v5) == 0)
  {
LABEL_3:
    v3 = (*(_DWORD *)(a1 + 48) - 1) & (v3 + 1);
    v5 = *v4;
    if (!*v4)
    {
      v14 = 0;
      goto LABEL_21;
    }
  }
  v7 = (_QWORD *)(*v24 + ((unint64_t)v3 << 7));
  v8 = v7 + 6;
  v9 = (unsigned int *)((unint64_t)(v7 + 6) & 0xFFFFFFFFFFFFFFFCLL);
  v10 = 255 << (8 * (((_BYTE)v7 + 48) & 3));
LABEL_6:
  v11 = *v9 & ~v10;
  do
  {
    while (1)
    {
      v12 = __ldaxr(v9);
      if (v12 == v11)
        break;
      __clrex();
      if (*v9 != v11)
      {
        if ((*v9 & v10) != 0)
          goto LABEL_3;
        sched_yield();
        goto LABEL_6;
      }
    }
  }
  while (__stlxr(v11 | (1 << (8 * (((_BYTE)v7 + 48) & 3))), v9));
  v13 = v7[5];
  if (!v13)
  {
    __dmb(0xBu);
    *v8 = 0;
    goto LABEL_3;
  }
  v15 = (uint64_t *)v7[1];
  v14 = *(_QWORD *)(*(uint64_t *)((char *)v15 + ((v7[4] >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v7[4] & 0x1FFLL));
  v16 = v13 - 1;
  v17 = v7[4] + 1;
  v7[4] = v17;
  v7[5] = v16;
  if (v17 >= 0x400)
  {
    tbb::internal::deallocate_via_handler_v3(*v15, a2);
    v7[1] += 8;
    v16 = v7[5];
    v7[4] -= 512;
  }
  if (!v16)
  {
    while (1)
    {
      v19 = *v4;
      v20 = *v4 & ~(1 << v3);
      do
      {
        while (1)
        {
          v21 = __ldaxr(v4);
          if (v21 != v19)
            break;
          if (!__stlxr(v20, v4))
            goto LABEL_20;
        }
        __clrex();
        do
          v22 = __ldxr(v4);
        while (__stxr(v22, v4));
      }
      while (v22 == v19);
      sched_yield();
    }
  }
LABEL_20:
  __dmb(0xBu);
  *v8 = 0;
LABEL_21:
  a3 = v23;
LABEL_22:
  *a3 = v3;
  return v14;
}

void sub_20BDD7554(_Unwind_Exception *a1)
{
  _BYTE *v1;

  __dmb(0xBu);
  *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t sub_20BDD7564(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  void *v6;
  tbb::internal::generic_scheduler *inited;

  v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v5 & 1) != 0)
    inited = (tbb::internal::generic_scheduler *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  else
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  return sub_20BDD75B8(inited, a2, a3, v6);
}

uint64_t sub_20BDD75B8(tbb::internal::generic_scheduler *a1, uint64_t a2, uint64_t a3, void *a4)
{
  tbb::task *v4;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  _BOOL4 v10;
  int v11;
  char v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  int v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  const std::exception_ptr *v21;
  tbb::internal *v22;
  void *v24;
  std::exception_ptr v25;
  uint64_t v27;
  fenv_t *v28;
  tbb::internal *v29;
  std::exception_ptr v30;

  v4 = (tbb::task *)a3;
  sub_20BDD22B4(&v27, a2, a3, a4);
  v7 = *((_QWORD *)a1 + 7);
  v8 = *((unsigned __int8 *)a1 + 74);
  v9 = *((_QWORD *)a1 + 18);
  v10 = v9 == a2;
  v11 = (v7 == v9) & (v8 >> 1);
  if (v11)
    v12 = 2;
  else
    v12 = 0;
  *((_BYTE *)a1 + 74) = v12 | v8 & 0xFD;
  v13 = *((_QWORD *)a1 + 12);
  v14 = (_QWORD *)*((_QWORD *)a1 + 13);
  if ((v11 & 1) == 0)
  {
    v15 = (_QWORD *)(*((_QWORD *)a1 + 6) + 272);
    *((_QWORD *)a1 + 12) = *(_QWORD *)(a2 - 56) + 160;
    *((_QWORD *)a1 + 13) = v15;
    if (v15 != v14)
      *((_QWORD *)a1 + 44) = *v15 - 1;
  }
  v16 = *(void **)(v7 - 64);
  if (v4 && v16)
    *((_QWORD *)v4 - 8) = v16;
  v17 = v8 & v10;
  v18 = (_QWORD *)(a2 - 24);
  while ((sub_20BDD7E04(a1, (uint64_t)&v27, v4, v16) & 1) != 0)
  {
    if (*v18 == 1)
    {
      __dmb(0xBu);
LABEL_19:
      *((_QWORD *)a1 + 7) = v7;
      *((_BYTE *)a1 + 74) = v8;
      *((_QWORD *)a1 + 12) = v13;
      if (*((_QWORD **)a1 + 13) != v14)
        *((_QWORD *)a1 + 44) = *v14 - 1;
      *((_QWORD *)a1 + 13) = v14;
      v20 = *(_QWORD *)(a2 - 56);
      if ((*(_BYTE *)(v20 + 130) & 4) == 0)
      {
        if (*v18 != 1)
          return sub_20BDD3AC0((uint64_t)&v27, v19);
        *v18 = 0;
      }
      if (*(_QWORD *)(v20 + 120))
      {
        v21 = *(const std::exception_ptr **)(v20 + 136);
        if ((~*((unsigned __int8 *)a1 + 74) & 3) == 0 && v20 == *(_QWORD *)(*((_QWORD *)a1 + 18) - 56))
        {
          *(_QWORD *)(v20 + 120) = 0;
          *(_QWORD *)(v20 + 152) &= ~1uLL;
        }
        if (v21)
        {
          v22 = (tbb::internal *)v28;
          if (*(_QWORD *)v29 != v28->__fpsr || *((_QWORD *)v29 + 1) != v28->__fpcr)
          {
            fesetenv(v28);
            v22 = v29;
            if (!v29)
            {
              v22 = (tbb::internal *)tbb::internal::NFS_Allocate(1uLL, 16, 0, v24);
              v29 = v22;
            }
            *(fenv_t *)v22 = *v28;
          }
          if (tbb::internal::governor::is_rethrow_broken)
            tbb::internal::fix_broken_rethrow(v22);
          std::exception_ptr::exception_ptr(&v30, v21);
          v25.__ptr_ = &v30;
          std::rethrow_exception(v25);
          __break(1u);
LABEL_39:
          *((_QWORD *)a1 + 7) = v7;
          *((_BYTE *)a1 + 74) = v8;
          *((_QWORD *)a1 + 12) = v13;
          if (*((_QWORD **)a1 + 13) != v14)
            *((_QWORD *)a1 + 44) = *v14 - 1;
          *((_QWORD *)a1 + 13) = v14;
          return sub_20BDD3AC0((uint64_t)&v27, v19);
        }
      }
      return sub_20BDD3AC0((uint64_t)&v27, v19);
    }
    if (*(_QWORD *)(*((_QWORD *)a1 + 5) + 8))
    {
      v4 = (tbb::task *)sub_20BDD704C((uint64_t)a1, (uint64_t)v16);
      if (v4)
        continue;
    }
    if (v17)
      goto LABEL_39;
    v4 = (tbb::task *)(*(uint64_t (**)(tbb::internal::generic_scheduler *, uint64_t, void *))(*(_QWORD *)a1 + 56))(a1, a2 - 24, v16);
    if (!v4)
      goto LABEL_19;
  }
  return sub_20BDD3AC0((uint64_t)&v27, v19);
}

void sub_20BDD7970(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, std::exception_ptr a14)
{
  sub_20BDD3AC0((uint64_t)&a11, a2);
  _Unwind_Resume(a1);
}

unint64_t sub_20BDD79C8(tbb::internal::generic_scheduler *this, _QWORD *a2, void *a3)
{
  char v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  BOOL v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  void *v27;
  tbb::internal *mailbox_task;
  uint64_t v29;
  uint64_t v30;
  int v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  tbb::task *v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unsigned int v39;
  void **v40;
  unint64_t v41;
  tbb::task **v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v46;
  tbb::task **v47;
  tbb::task *v48;

  v6 = *((_BYTE *)this + 74);
  v7 = *((_QWORD *)this + 14);
  v8 = *((_QWORD *)this + 8);
  if (v8)
    *(_BYTE *)(v8 + 20) = 1;
  if ((v6 & 2) != 0)
  {
    v9 = *(_QWORD *)(*((_QWORD *)this + 6) + 296);
    __dmb(0xBu);
    if (v9)
    {
      v10 = (unint64_t *)(*((_QWORD *)this + 6) + 296);
      do
      {
        while (1)
        {
          v11 = __ldaxr(v10);
          if (v11 == v9)
            break;
          __clrex();
          do
            v12 = __ldxr(v10);
          while (__stxr(v12, v10));
          if (v12 != v9)
            goto LABEL_14;
        }
      }
      while (__stlxr(0, v10));
      v13 = *((_QWORD *)this + 6);
      if (v9 > *(_QWORD *)(v13 + 136))
        tbb::internal::market::update_arena_priority(*((_QWORD *)this + 15), v13, v9);
    }
  }
LABEL_14:
  v14 = *(_DWORD *)(*((_QWORD *)this + 6) + 144);
  __dmb(0xBu);
  if (*a2 == 1)
  {
LABEL_15:
    v15 = 0;
    __dmb(0xBu);
    goto LABEL_16;
  }
  v17 = 0;
  v18 = 0;
  v19 = v6 & 3;
  v20 = (v14 - 1);
  v22 = (v6 & 2) == 0 || a3 != 0;
  v46 = v22;
  while (1)
  {
    if (v19 == 2)
    {
      v25 = *((_QWORD *)this + 6);
      v26 = *(_DWORD *)(v25 + 128);
      LODWORD(v25) = *(_DWORD *)(v25 + 132);
      __dmb(0xBu);
      if (v26 < v25 >> 12)
        return 0;
    }
    v27 = *(void **)(*((_QWORD *)this + 6) + 136);
    if (v20 && **((_QWORD **)this + 8))
    {
      mailbox_task = (tbb::internal *)tbb::internal::generic_scheduler::get_mailbox_task(this, a3);
      v15 = (unint64_t)mailbox_task;
      if (a3 && !mailbox_task)
      {
        v29 = *((_QWORD *)this + 8);
        if (*(_QWORD *)v29 && *(_BYTE *)(v29 + 20))
          *(_BYTE *)(v29 + 20) = 0;
        goto LABEL_42;
      }
      if (mailbox_task)
        goto LABEL_83;
    }
    if (!v46)
    {
      v30 = *((_QWORD *)this + 6) + 152;
      if (*(_QWORD *)(v30 + 8 * (int)v27))
      {
        mailbox_task = (tbb::internal *)sub_20BDD736C(v30, v27, (unsigned int *)(*((_QWORD *)this + 5) + 128));
        if (mailbox_task)
          break;
      }
    }
LABEL_42:
    if (*((_QWORD *)this + 42))
    {
      mailbox_task = (tbb::internal *)tbb::internal::generic_scheduler::reload_tasks(this, (uint64_t)a3);
      if (mailbox_task)
        break;
    }
    if (v7 < (unint64_t)&v48)
    {
      if (v20)
      {
        mailbox_task = (tbb::internal *)tbb::internal::generic_scheduler::steal_task(this, (uint64_t)a3);
        if (mailbox_task)
          break;
      }
    }
    sched_yield();
    v31 = 2 * v20 + 2;
    if (v17 < v31)
      goto LABEL_28;
    sched_yield();
    v23 = *((_QWORD *)this + 6);
    if (*(_QWORD *)(v23 + 280))
    {
      v32 = (unint64_t *)(v23 + 288);
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 + 1, v32));
      v48 = 0;
      v34 = (unint64_t *)(*((_QWORD *)this + 6) + 280);
LABEL_52:
      v35 = (tbb::task *)*v34;
      do
      {
        while (1)
        {
          v36 = __ldaxr(v34);
          if ((tbb::task *)v36 == v35)
            break;
          __clrex();
          do
            v37 = __ldxr(v34);
          while (__stxr(v37, v34));
          if ((tbb::task *)v37 != v35)
          {
            sched_yield();
            goto LABEL_52;
          }
        }
      }
      while (__stlxr(0, v34));
      v48 = v35;
      if (v35)
      {
        v47 = 0;
        --*((_QWORD *)this + 44);
        if ((*((_BYTE *)this + 74) & 3) == 2
          && (v38 = *((_QWORD *)this + 6),
              v39 = *(_DWORD *)(v38 + 128),
              LODWORD(v38) = *(_DWORD *)(v38 + 132),
              __dmb(0xBu),
              v39 >= v38 >> 12))
        {
          v40 = (void **)(*((_QWORD *)this + 6) + 136);
        }
        else
        {
          v40 = (void **)*((_QWORD *)this + 12);
        }
        v41 = tbb::internal::generic_scheduler::reload_tasks(this, &v48, &v47, *v40, (uint64_t)a3);
        v15 = v41;
        if (v48)
        {
          v42 = v47;
          *v47 = (tbb::task *)*((_QWORD *)this + 42);
          if (!*((_QWORD *)this + 42))
            *((_QWORD *)this + 43) = v42;
          *((_QWORD *)this + 42) = v48;
        }
        if (v41)
          goto LABEL_16;
      }
      v23 = *((_QWORD *)this + 6);
    }
    if (v18 >= 10)
    {
      if (v19 == 2)
      {
        if ((tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v23) & 1) != 0)
          return 0;
        if (*((_QWORD *)this + 42))
          --*((_QWORD *)this + 44);
        goto LABEL_26;
      }
      if (*(_QWORD *)(v23 + 136) <= *(_QWORD *)(v23 + 264))
      {
        if (!*((_QWORD *)this + 42))
          goto LABEL_27;
        --*((_QWORD *)this + 44);
      }
      else
      {
        tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v23);
        if (!*((_QWORD *)this + 42))
        {
LABEL_26:
          v23 = *((_QWORD *)this + 6);
          goto LABEL_27;
        }
        --*((_QWORD *)this + 44);
        v23 = *((_QWORD *)this + 6);
      }
      if (**((_QWORD **)this + 12) > *(_QWORD *)(v23 + 136))
        *((_QWORD *)this + 12) = v23 + 136;
    }
LABEL_27:
    ++v18;
    v24 = *(_DWORD *)(v23 + 144);
    __dmb(0xBu);
    v20 = (v24 - 1);
    v17 = v31;
LABEL_28:
    ++v17;
    if (*a2 == 1)
      goto LABEL_15;
  }
  v15 = (unint64_t)mailbox_task;
LABEL_83:
  v43 = *((_QWORD *)this + 6);
  if (*((_QWORD *)this + 11) != *(_QWORD *)(v43 + 232))
    tbb::internal::observer_list::do_notify_entry_observers((tbb::internal::observer_proxy **)(v43 + 224), (tbb::internal::observer_proxy **)this + 11, (*((_BYTE *)this + 74) & 1) == 0);
  v44 = tbb::internal::the_global_observer_list(mailbox_task);
  if (*((_QWORD *)this + 10) != *(_QWORD *)(v44 + 8))
    tbb::internal::observer_list::do_notify_entry_observers((tbb::internal::observer_proxy **)v44, (tbb::internal::observer_proxy **)this + 10, (*((_BYTE *)this + 74) & 1) == 0);
LABEL_16:
  v16 = *((_QWORD *)this + 8);
  if (v16 && *(_BYTE *)(v16 + 20))
    *(_BYTE *)(v16 + 20) = 0;
  return v15;
}

uint64_t sub_20BDD7E04(tbb::internal::generic_scheduler *this, uint64_t a2, tbb::task *a3, void *a4)
{
  tbb::task *v5;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v19;
  uint64_t v20;
  tbb::task *v21;
  void *v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  BOOL v26;
  int64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  BOOL v31;
  int64_t v32;
  tbb::internal::generic_scheduler *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t v40;
  void *v41;
  uint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v48;
  unsigned int *v50;

  if (!a3)
    return 1;
  v5 = a3;
  v50 = (unsigned int *)((char *)this + 128);
  while (1)
  {
    v8 = (_QWORD *)*((_QWORD *)v5 - 7);
    v9 = v8[20];
    if (v9 == **((_QWORD **)this + 12) || (*((_BYTE *)v5 - 11) & 0x10) != 0)
      goto LABEL_20;
    v10 = *((_QWORD *)this + 6);
    if (v9 != *(_QWORD *)(v10 + 136))
      tbb::internal::market::update_arena_priority(*((_QWORD *)this + 15), v10, v8[20]);
    if ((*((_BYTE *)this + 74) & 3) == 2
      && (v11 = *((_QWORD *)this + 6),
          v12 = *(_DWORD *)(v11 + 128),
          LODWORD(v11) = *(_DWORD *)(v11 + 132),
          __dmb(0xBu),
          v12 >= v11 >> 12))
    {
      v13 = (_QWORD *)(*((_QWORD *)this + 6) + 136);
    }
    else
    {
      v13 = (_QWORD *)*((_QWORD *)this + 12);
    }
    if (v9 >= *v13)
    {
      v8 = (_QWORD *)*((_QWORD *)v5 - 7);
LABEL_20:
      *((_QWORD *)this + 7) = v5;
      *((_QWORD *)v5 - 5) = this;
      *((_BYTE *)v5 - 12) = 0;
      v16 = v8[14];
      v17 = *(_QWORD *)(a2 + 16);
      if (*(_QWORD *)v16 != *(_QWORD *)v17 || *(_QWORD *)(v16 + 8) != *(_QWORD *)(v17 + 8))
      {
        if (!v17)
        {
          v17 = tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
          *(_QWORD *)(a2 + 16) = v17;
          v16 = v8[14];
        }
        *(_OWORD *)v17 = *(_OWORD *)v16;
        fesetenv(*(const fenv_t **)(a2 + 16));
        v8 = (_QWORD *)*((_QWORD *)v5 - 7);
      }
      v19 = (_QWORD *)((char *)v5 - 64);
      if (v8[15])
      {
        v15 = 0;
      }
      else
      {
        v20 = (*(uint64_t (**)(tbb::task *))(*(_QWORD *)v5 + 16))(v5);
        v15 = v20;
        if (v20)
        {
          *(_BYTE *)(v20 - 11) &= 0x6Fu;
          *(_QWORD *)(v20 - 64) = *v19;
        }
      }
      switch(*((_BYTE *)v5 - 12))
      {
        case 0:
          v21 = (tbb::task *)*((_QWORD *)v5 - 4);
          (**(void (***)(tbb::task *))v5)(v5);
          if (v21)
          {
            v23 = *v19;
            v24 = (unint64_t *)((char *)v21 - 24);
            do
            {
              v25 = __ldaxr(v24);
              v26 = __OFSUB__(v25, 1);
              v27 = v25 - 1;
            }
            while (__stlxr(v27, v24));
            if ((v27 < 0) ^ v26 | (v27 == 0))
            {
              __dmb(0xBu);
              if (v23)
                *((_QWORD *)v21 - 8) = v23;
              if (*((_BYTE *)v21 - 12) == 6)
              {
                tbb::internal::arena::enqueue_task(*((_QWORD **)this + 6), (uint64_t)v21, 0, v50);
              }
              else if (v15)
              {
                tbb::internal::generic_scheduler::local_spawn(this, v21, (tbb::task **)v21 - 1, a4);
              }
              else
              {
                v15 = (unint64_t)v21;
              }
            }
          }
          *((_BYTE *)v5 - 12) = 4;
          v33 = (tbb::internal::generic_scheduler *)*((_QWORD *)v5 - 6);
          if (v33 == this)
          {
            *((_QWORD *)v5 - 1) = *((_QWORD *)this + 17);
            *((_QWORD *)this + 17) = v5;
            goto LABEL_4;
          }
          if (v33 && (unint64_t)v33 < 0x1000)
            goto LABEL_4;
          if (!v33)
          {
            tbb::internal::NFS_Free((tbb::task *)((char *)v5 - 64), v22);
            goto LABEL_4;
          }
          v34 = (unint64_t *)((char *)v33 + 176);
          break;
        case 1:
          *((_BYTE *)v5 - 12) = 3;
          *((_BYTE *)v5 - 11) &= 0x6Fu;
          goto LABEL_52;
        case 3:
          *((_BYTE *)v5 - 11) &= 0x6Fu;
          goto LABEL_4;
        case 5:
          *((_BYTE *)v5 - 12) = 3;
          goto LABEL_43;
        case 6:
LABEL_43:
          *((_BYTE *)v5 - 11) &= 0x6Fu;
          v28 = *((_QWORD *)v5 - 8);
          v29 = (unint64_t *)((char *)v5 - 24);
          do
          {
            v30 = __ldaxr(v29);
            v31 = __OFSUB__(v30, 1);
            v32 = v30 - 1;
          }
          while (__stlxr(v32, v29));
          if ((v32 < 0) ^ v31 | (v32 == 0))
          {
            __dmb(0xBu);
            if (v28)
              *v19 = v28;
            if (*((_BYTE *)v5 - 12) == 6)
            {
              tbb::internal::arena::enqueue_task(*((_QWORD **)this + 6), (uint64_t)v5, 0, v50);
            }
            else if (v15)
            {
LABEL_52:
              tbb::internal::generic_scheduler::local_spawn(this, v5, (tbb::task **)v5 - 1, a4);
            }
            else
            {
              v15 = (unint64_t)v5;
            }
          }
          goto LABEL_4;
        default:
          goto LABEL_4;
      }
      while (1)
      {
        v36 = *v34;
        if (*v34 == -1)
          break;
        *((_QWORD *)v5 - 1) = v36;
        do
        {
          while (1)
          {
            v37 = __ldaxr(v34);
            if (v37 == v36)
              break;
            __clrex();
            do
              v35 = __ldxr(v34);
            while (__stxr(v35, v34));
            if (v35 != v36)
              goto LABEL_63;
          }
        }
        while (__stlxr((unint64_t)v5, v34));
        v35 = v36;
LABEL_63:
        if (v36 == v35)
          goto LABEL_4;
      }
      tbb::internal::NFS_Free((tbb::task *)((char *)v5 - 64), v22);
      v38 = (unint64_t *)((char *)v33 + 168);
      do
      {
        v39 = __ldaxr(v38);
        v40 = v39 - 1;
      }
      while (__stlxr(v40, v38));
      if (!v40)
      {
        (*(void (**)(tbb::internal::generic_scheduler *))(*(_QWORD *)v33 + 24))(v33);
        tbb::internal::NFS_Free(v33, v41);
      }
      goto LABEL_4;
    }
    v14 = *((_QWORD *)this + 42);
    if (!v14)
    {
      *((_QWORD *)this + 43) = (char *)v5 - 40;
      *((_QWORD *)v5 - 5) = 0;
      v14 = *((_QWORD *)this + 42);
    }
    *((_QWORD *)v5 - 5) = v14;
    *((_QWORD *)this + 42) = v5;
    if (!*(_QWORD *)(*((_QWORD *)this + 5) + 8))
      break;
    v15 = tbb::internal::generic_scheduler::winnow_task_pool(this, (uint64_t)a4);
    if (!v15)
      return 1;
LABEL_4:
    v5 = (tbb::task *)v15;
    if (!v15)
      return 1;
  }
  v42 = *((_QWORD *)this + 6);
  __dmb(0xBu);
  v43 = (unint64_t *)(v42 + 216);
  v44 = *(_QWORD *)(v42 + 216);
  __dmb(0xBu);
  if (v44 != -1)
  {
    do
    {
      while (1)
      {
        v45 = __ldaxr(v43);
        if (v45 == v44)
          break;
        __clrex();
        do
          v46 = __ldxr(v43);
        while (__stxr(v46, v43));
        if (v46 != v44)
          goto LABEL_87;
      }
    }
    while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v43));
    v46 = v44;
LABEL_87:
    if (!v46)
    {
      if (v44)
      {
        do
        {
          while (!__ldaxr(v43))
          {
            if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v43))
              goto LABEL_96;
          }
          __clrex();
          do
            v48 = __ldxr(v43);
          while (__stxr(v48, v43));
        }
        while (!v48);
      }
      else
      {
LABEL_96:
        tbb::internal::market::adjust_demand(*(_QWORD *)(v42 + 304), v42, *(_DWORD *)(v42 + 208));
      }
    }
  }
  return 1;
}

uint64_t tbb::internal::the_global_observer_list(tbb::internal *this)
{
  unsigned __int8 v1;
  _OWORD *v3;

  v1 = atomic_load((unsigned __int8 *)&qword_254784DD8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_254784DD8))
  {
    v3 = operator new(0x80uLL);
    v3[6] = 0u;
    v3[7] = 0u;
    v3[4] = 0u;
    v3[5] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    *v3 = 0u;
    v3[1] = 0u;
    qword_254784DD0 = (uint64_t)v3;
    __cxa_guard_release(&qword_254784DD8);
  }
  return qword_254784DD0;
}

void sub_20BDD82F8(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784DD8);
  _Unwind_Resume(a1);
}

uint64_t tbb::internal::observer_proxy::get_v6_observer(tbb::internal::observer_proxy *this)
{
  if (*((_BYTE *)this + 40) == 6)
    return *((_QWORD *)this + 4);
  else
    return 0;
}

BOOL tbb::internal::observer_proxy::is_global(tbb::internal::observer_proxy *this)
{
  uint64_t v1;

  return *((_BYTE *)this + 40) != 6 || (v1 = *((_QWORD *)this + 4)) == 0 || *(_QWORD *)(v1 + 24) == 0;
}

uint64_t tbb::internal::observer_proxy::observer_proxy(uint64_t result, uint64_t a2)
{
  char v2;

  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = a2;
  __dmb(0xBu);
  *(_DWORD *)result = 1;
  if (*(_QWORD *)(*(_QWORD *)(result + 32) + 16) == 0x8000000000000000)
    v2 = 6;
  else
    v2 = 0;
  *(_BYTE *)(result + 40) = v2;
  return result;
}

{
  char v2;

  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = a2;
  __dmb(0xBu);
  *(_DWORD *)result = 1;
  if (*(_QWORD *)(*(_QWORD *)(result + 32) + 16) == 0x8000000000000000)
    v2 = 6;
  else
    v2 = 0;
  *(_BYTE *)(result + 40) = v2;
  return result;
}

void tbb::internal::observer_list::clear(tbb::internal::observer_list *this)
{
  unint64_t *v2;
  _QWORD *v3;
  uint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  tbb::internal::observer_list *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;

  v2 = (unint64_t *)((char *)this + 16);
  v15 = (unint64_t *)((char *)this + 16);
  tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::internal::observer_list *)((char *)this + 16));
  v3 = *(_QWORD **)this;
  if (!*(_QWORD *)this)
    goto LABEL_20;
  do
  {
    v4 = v3[4];
    v3 = (_QWORD *)v3[2];
    if (v4)
    {
      v5 = (unint64_t *)(v4 + 8);
LABEL_7:
      v6 = (_QWORD *)*v5;
      do
      {
        while (1)
        {
          v7 = __ldaxr(v5);
          if ((_QWORD *)v7 == v6)
            break;
          __clrex();
          do
            v8 = __ldxr(v5);
          while (__stxr(v8, v5));
          if ((_QWORD *)v8 != v6)
          {
            sched_yield();
            goto LABEL_7;
          }
        }
      }
      while (__stlxr(0, v5));
      if (v6)
      {
        v9 = (_QWORD *)((char *)this + 8);
        if (*((_QWORD **)this + 1) != v6)
          v9 = (_QWORD *)(v6[2] + 24);
        *v9 = v6[3];
        v10 = this;
        if (*(_QWORD **)this != v6)
          v10 = (tbb::internal::observer_list *)(v6[3] + 16);
        *(_QWORD *)v10 = v6[2];
        operator delete(v6);
      }
    }
  }
  while (v3);
  v2 = v15;
  if (v15)
  {
LABEL_20:
    while (1)
    {
      v11 = *v2;
      v12 = *v2 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        while (1)
        {
          v13 = __ldaxr(v2);
          if (v13 != v11)
            break;
          if (!__stlxr(v12, v2))
            goto LABEL_28;
        }
        __clrex();
        do
          v14 = __ldxr(v2);
        while (__stxr(v14, v2));
      }
      while (v14 == v11);
      sched_yield();
    }
  }
LABEL_28:
  while (*(_QWORD *)this)
    sched_yield();
}

void sub_20BDD852C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_20BDCE940((uint64_t)&a9);
  _Unwind_Resume(a1);
}

tbb::internal::observer_proxy **tbb::internal::observer_list::remove(tbb::internal::observer_proxy **this, tbb::internal::observer_proxy *a2)
{
  _QWORD *v2;

  v2 = this + 1;
  if (this[1] != a2)
    v2 = (_QWORD *)(*((_QWORD *)a2 + 2) + 24);
  *v2 = *((_QWORD *)a2 + 3);
  if (*this != a2)
    this = (tbb::internal::observer_proxy **)(*((_QWORD *)a2 + 3) + 16);
  *this = (tbb::internal::observer_proxy *)*((_QWORD *)a2 + 2);
  return this;
}

uint64_t tbb::internal::observer_list::insert(tbb::internal::observer_list *this, tbb::internal::observer_proxy *a2)
{
  unint64_t *v4;
  uint64_t result;
  tbb::internal::observer_list *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v4 = (unint64_t *)((char *)this + 16);
  result = tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::internal::observer_list *)((char *)this + 16));
  v6 = this;
  if (*(_QWORD *)this)
  {
    v7 = *((_QWORD *)this + 1);
    *((_QWORD *)a2 + 3) = v7;
    v6 = (tbb::internal::observer_list *)(v7 + 16);
  }
  *(_QWORD *)v6 = a2;
  *((_QWORD *)this + 1) = a2;
LABEL_4:
  v8 = *v4;
  v9 = *v4 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    while (1)
    {
      v10 = __ldaxr(v4);
      if (v10 == v8)
        break;
      __clrex();
      do
        v11 = __ldxr(v4);
      while (__stxr(v11, v4));
      if (v11 != v8)
      {
        result = sched_yield();
        goto LABEL_4;
      }
    }
  }
  while (__stlxr(v9, v4));
  return result;
}

void tbb::internal::observer_list::remove_ref(tbb::internal::observer_proxy **this, tbb::internal::observer_proxy *a2)
{
  tbb::internal::observer_proxy **v3;
  int v4;
  unsigned int v5;
  unint64_t *v6;
  unsigned int v7;
  unsigned int v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  v3 = this;
  v4 = *(_DWORD *)a2;
  __dmb(0xBu);
  if (v4 >= 2)
  {
    while (1)
    {
      while (1)
      {
        v5 = __ldaxr((unsigned int *)a2);
        if (v5 != v4)
          break;
        if (!__stlxr(v4 - 1, (unsigned int *)a2))
          return;
      }
      __clrex();
      if (*(_DWORD *)a2 != v4)
      {
        v4 = *(_DWORD *)a2;
        if (*(int *)a2 <= 1)
          break;
      }
    }
  }
  v6 = (unint64_t *)(this + 2);
  tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::spin_rw_mutex_v3 *)(this + 2));
  do
  {
    v7 = __ldaxr((unsigned int *)a2);
    v8 = v7 - 1;
  }
  while (__stlxr(v8, (unsigned int *)a2));
  if (v8)
  {
    while (1)
    {
      v14 = *v6;
      v15 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        while (1)
        {
          v16 = __ldaxr(v6);
          if (v16 != v14)
            break;
          if (!__stlxr(v15, v6))
            return;
        }
        __clrex();
        do
          v17 = __ldxr(v6);
        while (__stxr(v17, v6));
      }
      while (v17 == v14);
      sched_yield();
    }
  }
  v9 = v3 + 1;
  if (v3[1] != a2)
    v9 = (_QWORD *)(*((_QWORD *)a2 + 2) + 24);
  *v9 = *((_QWORD *)a2 + 3);
  if (*v3 != a2)
    v3 = (tbb::internal::observer_proxy **)(*((_QWORD *)a2 + 3) + 16);
  *v3 = (tbb::internal::observer_proxy *)*((_QWORD *)a2 + 2);
LABEL_16:
  v10 = *v6;
  v11 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    while (1)
    {
      v12 = __ldaxr(v6);
      if (v12 == v10)
        break;
      __clrex();
      do
        v13 = __ldxr(v6);
      while (__stxr(v13, v6));
      if (v13 != v10)
      {
        sched_yield();
        goto LABEL_16;
      }
    }
  }
  while (__stlxr(v11, v6));
  operator delete(a2);
}

void tbb::internal::observer_list::do_notify_entry_observers(tbb::internal::observer_proxy **this, tbb::internal::observer_proxy **a2, uint64_t a3)
{
  tbb::internal::observer_proxy *v6;
  unint64_t *v7;
  tbb::internal::observer_proxy *v8;
  void (***v9)(_QWORD, uint64_t);
  tbb::internal::observer_proxy *v10;
  unsigned int v11;
  int v12;
  unint64_t *v13;
  unsigned int v14;
  unint64_t *v15;
  unint64_t v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;

  v6 = *a2;
  v7 = (unint64_t *)(this + 2);
  while (2)
  {
    v22 = v7;
    tbb::spin_rw_mutex_v3::internal_acquire_reader(v7);
    v8 = v6;
    do
    {
      if (v6)
      {
        v10 = (tbb::internal::observer_proxy *)*((_QWORD *)v6 + 2);
        if (!v10)
        {
          if (v6 != v8)
          {
            do
              v17 = __ldaxr((unsigned int *)v6);
            while (__stlxr(v17 + 1, (unsigned int *)v6));
            if (v8)
            {
              v22 = 0;
              do
                v18 = __ldaxr(v7);
              while (__stlxr(v18 - 4, v7));
              tbb::internal::observer_list::remove_ref(this, v8);
            }
          }
          v9 = 0;
          v12 = 0;
          *a2 = v6;
          v13 = v22;
          if (v22)
            goto LABEL_26;
          goto LABEL_27;
        }
        if (v6 == v8 && *((_QWORD *)v8 + 4))
        {
          do
            v11 = __ldaxr((unsigned int *)v8);
          while (__stlxr(v11 - 1, (unsigned int *)v8));
          v8 = 0;
        }
        v6 = v10;
      }
      else
      {
        v6 = *this;
        if (!*this)
        {
          v9 = 0;
          v12 = 0;
          v13 = v7;
          if (!v7)
            goto LABEL_27;
          goto LABEL_26;
        }
      }
      v9 = (void (***)(_QWORD, uint64_t))*((_QWORD *)v6 + 4);
    }
    while (!v9);
    do
      v14 = __ldaxr((unsigned int *)v6);
    while (__stlxr(v14 + 1, (unsigned int *)v6));
    v15 = (unint64_t *)(v9 + 2);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 + 1, v15));
    v12 = 1;
    v13 = v7;
    if (v7)
    {
      do
LABEL_26:
        v19 = __ldaxr(v13);
      while (__stlxr(v19 - 4, v13));
    }
LABEL_27:
    if (v12)
    {
      if (v8)
        tbb::internal::observer_list::remove_ref(this, v8);
      v20 = (unint64_t *)(v9 + 2);
      (**v9)(v9, a3);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      continue;
    }
    break;
  }
}

void sub_20BDD89B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_20BDCE940((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void tbb::internal::observer_list::do_notify_exit_observers(tbb::internal::observer_proxy **this, tbb::internal::observer_proxy *a2, uint64_t a3)
{
  tbb::internal::observer_proxy *v6;
  unint64_t *v7;
  tbb::internal::observer_proxy *v8;
  tbb::internal::observer_proxy **v9;
  unint64_t *v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t *v13;
  unint64_t v14;
  int v15;
  unint64_t *v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;

  v6 = 0;
  v7 = (unint64_t *)(this + 2);
  while (2)
  {
    tbb::spin_rw_mutex_v3::internal_acquire_reader(v7);
    v8 = v6;
    while (!v6)
    {
      v9 = this;
LABEL_4:
      v6 = *v9;
      v10 = (unint64_t *)*((_QWORD *)*v9 + 4);
      if (v10)
      {
        if (v6 != a2)
        {
          do
            v12 = __ldaxr((unsigned int *)v6);
          while (__stlxr(v12 + 1, (unsigned int *)v6));
        }
        v13 = v10 + 2;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 + 1, v13));
        v15 = 1;
        v16 = v7;
        if (v7)
          goto LABEL_24;
        goto LABEL_25;
      }
    }
    if (v6 != a2)
    {
      if (v6 == v8)
      {
        v8 = v6;
        if (*((_QWORD *)v6 + 4))
        {
          do
            v11 = __ldaxr((unsigned int *)v6);
          while (__stlxr(v11 - 1, (unsigned int *)v6));
          v8 = 0;
        }
      }
      v9 = (tbb::internal::observer_proxy **)((char *)v6 + 16);
      goto LABEL_4;
    }
    if (*((_QWORD *)a2 + 4))
    {
      do
        v17 = __ldaxr((unsigned int *)a2);
      while (__stlxr(v17 - 1, (unsigned int *)a2));
      v6 = 0;
      v15 = 0;
      v10 = 0;
      v16 = v7;
      if (!v7)
        goto LABEL_25;
      do
LABEL_24:
        v19 = __ldaxr(v16);
      while (__stlxr(v19 - 4, v16));
      goto LABEL_25;
    }
    do
      v18 = __ldaxr(v7);
    while (__stlxr(v18 - 4, v7));
    tbb::internal::observer_list::remove_ref(this, a2);
    v15 = 0;
    v10 = 0;
    v6 = a2;
LABEL_25:
    if (v15)
    {
      if (v8)
        tbb::internal::observer_list::remove_ref(this, v8);
      v20 = v10 + 2;
      (*(void (**)(unint64_t *, uint64_t))(*v10 + 8))(v10, a3);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      continue;
    }
    break;
  }
}

void sub_20BDD8C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_20BDCE940((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void tbb::internal::task_scheduler_observer_v3::observe(tbb::internal::task_scheduler_observer_v3 *this, char a2)
{
  unint64_t *v3;
  _QWORD *v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t inited;
  unint64_t v9;
  tbb::interface7::internal::task_arena_base *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t *v16;
  unsigned int v17;
  unsigned int v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  unsigned __int8 v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unsigned __int8 v36;
  tbb::internal::observer_proxy **v37;
  tbb::internal::observer_proxy **v38;
  unint64_t *v39;
  unint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  _OWORD *v47;
  _OWORD *v48;

  v3 = (unint64_t *)((char *)this + 8);
  if ((a2 & 1) != 0)
  {
    if (*v3)
      return;
    v4 = operator new(0x30uLL);
    v4[1] = 0;
    v4[2] = 0;
    v4[3] = 0;
    v4[4] = this;
    __dmb(0xBu);
    *(_DWORD *)v4 = 1;
    if (*(_QWORD *)(v4[4] + 16) == 0x8000000000000000)
      v5 = 6;
    else
      v5 = 0;
    *((_BYTE *)v4 + 40) = v5;
    *((_QWORD *)this + 1) = v4;
    __dmb(0xBu);
    *((_QWORD *)this + 2) = 0;
    v6 = *((_QWORD *)this + 1);
    if (*(_BYTE *)(v6 + 40) == 6)
    {
      v7 = *(_QWORD *)(v6 + 32);
      if (v7)
      {
        if (*(_QWORD *)(v7 + 24))
        {
          inited = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS) & 0xFFFFFFFFFFFFFFFELL;
          v9 = *v3;
          v10 = *(tbb::interface7::internal::task_arena_base **)(*(_QWORD *)(*v3 + 32) + 24);
          if (v10 == (tbb::interface7::internal::task_arena_base *)1)
          {
            if (!inited || (v11 = *(_QWORD **)(inited + 48)) == 0)
            {
              inited = tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
              v10 = (tbb::interface7::internal::task_arena_base *)(inited + 48);
LABEL_13:
              v11 = *(_QWORD **)v10;
              v9 = *v3;
            }
          }
          else
          {
            v11 = *(_QWORD **)v10;
            if (!*(_QWORD *)v10)
            {
              if (!*((_BYTE *)v10 + 32))
              {
                tbb::interface7::internal::task_arena_base::internal_initialize(v10);
                *((_BYTE *)v10 + 32) = 1;
                goto LABEL_13;
              }
              v11 = 0;
            }
          }
          v39 = v11 + 28;
          *(_QWORD *)(v9 + 8) = v11 + 28;
          v40 = v11 + 30;
          tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::spin_rw_mutex_v3 *)(v11 + 30));
          if (v11[28])
          {
            v41 = v11[29];
            *(_QWORD *)(v9 + 24) = v41;
            v39 = (unint64_t *)(v41 + 16);
          }
          *v39 = v9;
          v11[29] = v9;
LABEL_63:
          v42 = *v40;
          v43 = *v40 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            while (1)
            {
              v44 = __ldaxr(v40);
              if (v44 == v42)
                break;
              __clrex();
              do
                v45 = __ldxr(v40);
              while (__stxr(v45, v40));
              if (v45 != v42)
              {
                sched_yield();
                goto LABEL_63;
              }
            }
          }
          while (__stlxr(v43, v40));
          if (!inited)
            return;
          v46 = *(_QWORD *)(inited + 48);
          v37 = (tbb::internal::observer_proxy **)(v46 + 224);
          if (v46 + 224 != *(_QWORD *)(*v3 + 8))
            return;
          v38 = (tbb::internal::observer_proxy **)(inited + 88);
          if (*(_QWORD *)(inited + 88) == *(_QWORD *)(v46 + 232))
            return;
LABEL_56:
          tbb::internal::observer_list::do_notify_entry_observers(v37, v38, (*(_BYTE *)(inited + 74) & 1) == 0);
          return;
        }
      }
    }
    v25 = tbb::internal::__TBB_InitOnce::InitializationDone;
    __dmb(0xBu);
    if (!v25)
      tbb::internal::DoOneTimeInitializations((tbb::internal *)v4);
    v26 = atomic_load((unsigned __int8 *)&qword_254784DD8);
    if ((v26 & 1) == 0 && __cxa_guard_acquire(&qword_254784DD8))
    {
      v47 = operator new(0x80uLL);
      v47[6] = 0u;
      v47[7] = 0u;
      v47[4] = 0u;
      v47[5] = 0u;
      v47[2] = 0u;
      v47[3] = 0u;
      *v47 = 0u;
      v47[1] = 0u;
      qword_254784DD0 = (uint64_t)v47;
      __cxa_guard_release(&qword_254784DD8);
    }
    v27 = (unint64_t *)qword_254784DD0;
    v28 = *v3;
    *(_QWORD *)(v28 + 8) = qword_254784DD0;
    v29 = v27 + 2;
    tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::spin_rw_mutex_v3 *)(v27 + 2));
    v30 = v27;
    if (*v27)
    {
      v31 = v27[1];
      *(_QWORD *)(v28 + 24) = v31;
      v30 = (unint64_t *)(v31 + 16);
    }
    *v30 = v28;
    v27[1] = v28;
LABEL_46:
    v32 = *v29;
    v33 = *v29 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      while (1)
      {
        v34 = __ldaxr(v29);
        if (v34 == v32)
          break;
        __clrex();
        do
          v35 = __ldxr(v29);
        while (__stxr(v35, v29));
        if (v35 != v32)
        {
          sched_yield();
          goto LABEL_46;
        }
      }
    }
    while (__stlxr(v33, v29));
    inited = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS) & 0xFFFFFFFFFFFFFFFELL;
    if (inited)
    {
      v36 = atomic_load((unsigned __int8 *)&qword_254784DD8);
      if ((v36 & 1) == 0 && __cxa_guard_acquire(&qword_254784DD8))
      {
        v48 = operator new(0x80uLL);
        v48[6] = 0u;
        v48[7] = 0u;
        v48[4] = 0u;
        v48[5] = 0u;
        v48[2] = 0u;
        v48[3] = 0u;
        *v48 = 0u;
        v48[1] = 0u;
        qword_254784DD0 = (uint64_t)v48;
        __cxa_guard_release(&qword_254784DD8);
      }
      v37 = (tbb::internal::observer_proxy **)qword_254784DD0;
      v38 = (tbb::internal::observer_proxy **)(inited + 80);
      if (*(_QWORD *)(inited + 80) != *(_QWORD *)(qword_254784DD0 + 8))
        goto LABEL_56;
    }
  }
  else
  {
LABEL_14:
    v12 = *v3;
    do
    {
      while (1)
      {
        v13 = __ldaxr(v3);
        if (v13 == v12)
          break;
        __clrex();
        do
          v14 = __ldxr(v3);
        while (__stxr(v14, v3));
        if (v14 != v12)
        {
          sched_yield();
          goto LABEL_14;
        }
      }
    }
    while (__stlxr(0, v3));
    if (v12)
    {
      v15 = *(_QWORD **)(v12 + 8);
      v16 = v15 + 2;
      tbb::spin_rw_mutex_v3::internal_acquire_writer((tbb::spin_rw_mutex_v3 *)(v15 + 2));
      *(_QWORD *)(v12 + 32) = 0;
      do
      {
        v17 = __ldaxr((unsigned int *)v12);
        v18 = v17 - 1;
      }
      while (__stlxr(v18, (unsigned int *)v12));
      if (!v18)
      {
        v19 = v15 + 1;
        if (v15[1] != v12)
          v19 = (_QWORD *)(*(_QWORD *)(v12 + 16) + 24);
        *v19 = *(_QWORD *)(v12 + 24);
        if (*v15 != v12)
          v15 = (_QWORD *)(*(_QWORD *)(v12 + 24) + 16);
        *v15 = *(_QWORD *)(v12 + 16);
        operator delete((void *)v12);
      }
LABEL_30:
      v20 = *v16;
      v21 = *v16 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        while (1)
        {
          v22 = __ldaxr(v16);
          if (v22 == v20)
            break;
          __clrex();
          do
            v23 = __ldxr(v16);
          while (__stxr(v23, v16));
          if (v23 != v20)
          {
            sched_yield();
            goto LABEL_30;
          }
        }
      }
      while (__stlxr(v21, v16));
      while (1)
      {
        v24 = *((_QWORD *)this + 2);
        __dmb(0xBu);
        if (!v24)
          break;
        sched_yield();
      }
    }
  }
}

void sub_20BDD9070(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784DD8);
  _Unwind_Resume(a1);
}

tbb::internal *tbb::internal::__TBB_InitOnce::add_ref(tbb::internal::__TBB_InitOnce *this)
{
  unsigned int v1;
  NSObject *v2;

  do
    v1 = __ldaxr((unsigned int *)&tbb::internal::__TBB_InitOnce::count);
  while (__stlxr(v1 + 1, (unsigned int *)&tbb::internal::__TBB_InitOnce::count));
  if (!v1)
    return tbb::internal::governor::acquire_resources(this);
  if (qword_254784DE8 != -1)
    dispatch_once(&qword_254784DE8, &unk_24C5167C8);
  v2 = qword_254784DE0;
  if (os_log_type_enabled((os_log_t)qword_254784DE0, OS_LOG_TYPE_ERROR))
    sub_20C96AF78(v2);
  return (tbb::internal *)0xFFFFFFFFLL;
}

tbb::internal::governor *tbb::internal::__TBB_InitOnce::remove_ref(tbb::internal::governor *this)
{
  unsigned int v1;
  unsigned int v2;

  do
  {
    v1 = __ldaxr((unsigned int *)&tbb::internal::__TBB_InitOnce::count);
    v2 = v1 - 1;
  }
  while (__stlxr(v2, (unsigned int *)&tbb::internal::__TBB_InitOnce::count));
  if (!v2)
    return (tbb::internal::governor *)tbb::internal::governor::release_resources(this);
  return this;
}

tbb::internal *tbb::internal::DoOneTimeInitializations(tbb::internal *this)
{
  char v1;
  int v2;
  unsigned int v3;
  unsigned int v4;
  tbb::internal *v5;
  char *v6;
  char *v7;
  char *v8;
  tbb::internal::governor *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  int v13;
  const char *v14;
  size_t v16;
  int v17;
  int v18[2];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
LABEL_2:
  v1 = 8 * (&tbb::internal::__TBB_InitOnce::InitializationLock & 3);
  v2 = *(_DWORD *)((unint64_t)&tbb::internal::__TBB_InitOnce::InitializationLock & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v1);
  v3 = v2 | (1 << v1);
  do
  {
    while (1)
    {
      v4 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::__TBB_InitOnce::InitializationLock & 0xFFFFFFFFFFFFFFFCLL));
      if (v4 == v2)
        break;
      __clrex();
      if (*(_DWORD *)((unint64_t)&tbb::internal::__TBB_InitOnce::InitializationLock & 0xFFFFFFFFFFFFFFFCLL) != v2)
      {
        this = (tbb::internal *)sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v3, (unsigned int *)((unint64_t)&tbb::internal::__TBB_InitOnce::InitializationLock & 0xFFFFFFFFFFFFFFFCLL)));
  if (tbb::internal::__TBB_InitOnce::InitializationDone)
  {
    v5 = 0;
  }
  else
  {
    v5 = tbb::internal::__TBB_InitOnce::add_ref(this);
    v6 = getenv("TBB_VERSION");
    if (v6)
    {
      v7 = v6;
      v6 = (char *)strspn(v6, " ");
      if (v6[(_QWORD)v7] == 49)
      {
        v8 = v6 + 1;
        v6 = (char *)strspn(&v6[(_QWORD)v7 + 1], " ");
        if (!v7[(unint64_t)&v8[(_QWORD)v6]])
          v6 = (char *)tbb::internal::PrintVersion((tbb::internal *)v6);
      }
    }
    tbb::internal::initialize_cache_aligned_allocator((tbb::internal *)v6);
    tbb::internal::governor::initialize_rml_factory(v9);
    v10 = tbb::internal::Scheduler_OneTimeInitialization(0);
    if (!tbb::internal::governor::DefaultNumberOfThreads)
    {
      *(_QWORD *)v18 = 0x1900000006;
      v17 = 0;
      v16 = 4;
      v10 = sysctl(v18, 2u, &v17, &v16, 0, 0);
      v13 = v17;
      if (v17 <= 1)
        v13 = 1;
      tbb::internal::governor::DefaultNumberOfThreads = v13;
    }
    if (!tbb::internal::governor::DefaultPageSize)
    {
      v10 = tbb::internal::DefaultSystemPageSize((tbb::internal *)v10);
      tbb::internal::governor::DefaultPageSize = v10;
    }
    tbb::internal::governor::print_version_info((tbb::internal::governor *)v10, v11, v12);
    tbb::internal::PrintExtraVersionInfo("Tools support", "disabled", v14);
    tbb::internal::__TBB_InitOnce::InitializationDone = 1;
  }
  __dmb(0xBu);
  tbb::internal::__TBB_InitOnce::InitializationLock = 0;
  return v5;
}

_QWORD *tbb::internal::itt_store_pointer_with_release_v3(_QWORD *this, void *a2, void *a3)
{
  __dmb(0xBu);
  *this = a2;
  return this;
}

uint64_t tbb::internal::itt_load_pointer_with_acquire_v3(tbb::internal *this, const void *a2)
{
  uint64_t result;

  result = *(_QWORD *)this;
  __dmb(0xBu);
  return result;
}

uint64_t tbb::internal::itt_load_pointer_v3(tbb::internal *this, const void *a2)
{
  return *(_QWORD *)this;
}

uint64_t tbb::internal::market::app_parallelism_limit(tbb::internal::market *this)
{
  unsigned __int8 v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;

  v1 = atomic_load((unsigned __int8 *)&qword_254784DF8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_254784DF8))
  {
    v5 = operator new(0x80uLL);
    v5[2] = 0;
    *((_BYTE *)v5 + 24) = 0;
    *v5 = &unk_24C5167F8;
    qword_254784DF0 = (uint64_t)v5;
    __cxa_guard_release(&qword_254784DF8);
  }
  v2 = qword_254784DF0;
  v3 = *(_QWORD *)(qword_254784DF0 + 16);
  __dmb(0xBu);
  if (v3)
    return *(unsigned int *)(v2 + 8);
  else
    return 0;
}

void sub_20BDD93F4(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784DF8);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDD940C()
{
  unsigned __int8 v0;
  _QWORD *v2;

  v0 = atomic_load((unsigned __int8 *)&qword_254784DF8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_254784DF8))
  {
    v2 = operator new(0x80uLL);
    v2[2] = 0;
    *((_BYTE *)v2 + 24) = 0;
    *v2 = &unk_24C5167F8;
    qword_254784DF0 = (uint64_t)v2;
    __cxa_guard_release(&qword_254784DF8);
  }
  return qword_254784DF0;
}

void sub_20BDD9480(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784DF8);
  _Unwind_Resume(a1);
}

uint64_t tbb::interface9::global_control::internal_create(tbb::interface9::global_control *this, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v6;
  unsigned int *v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;

  if (*((int *)this + 4) >= 2)
    tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/tbb_main.cpp", (const char *)0x226, "my_param < global_control::parameter_max", 0, a5);
  v6 = *(_QWORD *)(sub_20BDD95BC() + 8 * *((unsigned int *)this + 4));
  v7 = (unsigned int *)((v6 + 24) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_4:
  v8 = *v7 & ~(255 << (8 * ((v6 + 24) & 3)));
  do
  {
    while (1)
    {
      v9 = __ldaxr(v7);
      if (v9 == v8)
        break;
      __clrex();
      if (*v7 != v8)
      {
        sched_yield();
        goto LABEL_4;
      }
    }
  }
  while (__stlxr(v8 | (1 << (8 * ((v6 + 24) & 3))), v7));
  v10 = *(_QWORD *)(v6 + 16);
  __dmb(0xBu);
  if (!v10
    || (result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v6 + 16))(v6, *(_QWORD *)this, *(_QWORD *)(v6 + 8)), (_DWORD)result))
  {
    *(_QWORD *)(v6 + 8) = *(_QWORD *)this;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  }
  v12 = *(_QWORD *)(v6 + 16);
  __dmb(0xBu);
  *((_QWORD *)this + 1) = v12;
  __dmb(0xBu);
  *(_QWORD *)(v6 + 16) = this;
  __dmb(0xBu);
  *(_BYTE *)(v6 + 24) = 0;
  return result;
}

void sub_20BDD95B0(_Unwind_Exception *a1)
{
  _BYTE *v1;

  __dmb(0xBu);
  *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t sub_20BDD95BC()
{
  unsigned __int8 v0;
  _QWORD *v2;

  v0 = atomic_load((unsigned __int8 *)&qword_254784E08);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_254784E08))
  {
    v2 = operator new(0x10uLL);
    *v2 = sub_20BDD940C();
    v2[1] = sub_20BDD9A74();
    qword_254784E00 = (uint64_t)v2;
    __cxa_guard_release(&qword_254784E08);
  }
  return qword_254784E00;
}

void sub_20BDD962C(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784E08);
  _Unwind_Resume(a1);
}

uint64_t tbb::interface9::global_control::internal_destroy(tbb::interface9::global_control *this, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t result;
  _QWORD *v7;
  unsigned int *v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  tbb::interface9::global_control *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  tbb::interface9::global_control *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;

  if (*((int *)this + 4) >= 2)
    tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/tbb_main.cpp", (const char *)0x238, "my_param < global_control::parameter_max", 0, a5);
  result = sub_20BDD95BC();
  v7 = *(_QWORD **)(result + 8 * *((unsigned int *)this + 4));
  v8 = (unsigned int *)((unint64_t)(v7 + 3) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_4:
  v9 = *v8 & ~(255 << (8 * (((_BYTE)v7 + 24) & 3)));
  do
  {
    while (1)
    {
      v10 = __ldaxr(v8);
      if (v10 == v9)
        break;
      __clrex();
      if (*v8 != v9)
      {
        result = sched_yield();
        goto LABEL_4;
      }
    }
  }
  while (__stlxr(v9 | (1 << (8 * (((_BYTE)v7 + 24) & 3))), v8));
  v11 = v7[1];
  v12 = (tbb::interface9::global_control *)v7[2];
  __dmb(0xBu);
  v13 = (uint64_t *)v7[2];
  __dmb(0xBu);
  if (v12 != this)
    goto LABEL_13;
  if (v13[1])
  {
    v14 = v7[2];
    __dmb(0xBu);
    v13 = *(uint64_t **)(v14 + 8);
LABEL_13:
    v15 = *v13;
    goto LABEL_14;
  }
  v15 = -1;
LABEL_14:
  v16 = (tbb::interface9::global_control *)v7[2];
  __dmb(0xBu);
  if (v16)
  {
    v17 = 0;
    do
    {
      v19 = v17;
      v17 = (uint64_t *)v16;
      if (v16 == this)
      {
        v18 = *((_QWORD *)this + 1);
        if (v19)
        {
          v19[1] = v18;
        }
        else
        {
          __dmb(0xBu);
          v7[2] = v18;
        }
      }
      else
      {
        result = (*(uint64_t (**)(_QWORD *, _QWORD, uint64_t))(*v7 + 16))(v7, *(_QWORD *)v16, v15);
        if ((_DWORD)result)
          v15 = *v17;
      }
      v16 = (tbb::interface9::global_control *)v17[1];
    }
    while (v16);
  }
  v20 = v7[2];
  __dmb(0xBu);
  if (v20)
  {
    if (v15 == v11)
      goto LABEL_28;
    goto LABEL_27;
  }
  result = (*(uint64_t (**)(_QWORD *))*v7)(v7);
  v15 = result;
  if (result != v11)
  {
LABEL_27:
    v7[1] = v15;
    result = (*(uint64_t (**)(_QWORD *))(*v7 + 8))(v7);
  }
LABEL_28:
  __dmb(0xBu);
  *((_BYTE *)v7 + 24) = 0;
  return result;
}

void sub_20BDD9808(_Unwind_Exception *a1)
{
  _BYTE *v1;

  __dmb(0xBu);
  *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t tbb::interface9::global_control::active_value(tbb::interface9::global_control *this, int a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int v5;
  uint64_t v6;

  v5 = (int)this;
  if ((int)this >= 2)
    tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/tbb_main.cpp", (const char *)0x25E, "param < global_control::parameter_max", 0, a5);
  v6 = *(_QWORD *)(sub_20BDD95BC() + 8 * v5);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
}

os_log_t sub_20BDD9868()
{
  os_log_t result;

  result = os_log_create("com.apple.usdlib", "tbbmain");
  qword_254784DE0 = (uint64_t)result;
  return result;
}

uint64_t sub_20BDD9894()
{
  unsigned int v0;
  size_t v2;
  int v3;
  int v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v0 = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(_QWORD *)v4 = 0x1900000006;
    v3 = 0;
    v2 = 4;
    sysctl(v4, 2u, &v3, &v2, 0, 0);
    v0 = v3;
    if (v3 <= 1)
      v0 = 1;
    tbb::internal::governor::DefaultNumberOfThreads = v0;
  }
  return v0;
}

uint64_t sub_20BDD9934(uint64_t a1)
{
  return tbb::internal::market::set_active_num_workers((*(_DWORD *)(a1 + 8) - 1));
}

BOOL sub_20BDD9940(uint64_t a1, unint64_t a2, unint64_t a3)
{
  return a2 < a3;
}

uint64_t sub_20BDD994C(uint64_t a1)
{
  uint64_t v2;
  char v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 16);
  __dmb(0xBu);
  if (!v2)
    return (**(uint64_t (***)(uint64_t))a1)(a1);
LABEL_2:
  v3 = 8 * (&tbb::internal::market::theMarketMutex & 3);
  v4 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v3);
  v5 = v4 | (1 << v3);
  do
  {
    while (1)
    {
      v6 = __ldaxr((unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL));
      if (v6 == v4)
        break;
      __clrex();
      if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v4)
      {
        sched_yield();
        goto LABEL_2;
      }
    }
  }
  while (__stlxr(v5, (unsigned int *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL)));
  if (!tbb::internal::market::theMarket)
  {
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
    return *(_QWORD *)(a1 + 8);
  }
  v7 = *(unsigned int *)(tbb::internal::market::theMarket + 24);
  __dmb(0xBu);
  LOBYTE(tbb::internal::market::theMarketMutex) = 0;
  if (!(_DWORD)v7)
    return *(_QWORD *)(a1 + 8);
  if ((unint64_t)(v7 + 1) < *(_QWORD *)(a1 + 8))
    return v7 + 1;
  else
    return *(_QWORD *)(a1 + 8);
}

BOOL sub_20BDD9A48(uint64_t a1, unint64_t a2, unint64_t a3)
{
  return a2 > a3;
}

uint64_t sub_20BDD9A54(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  __dmb(0xBu);
  if (v1)
    return *(_QWORD *)(a1 + 8);
  else
    return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t sub_20BDD9A74()
{
  unsigned __int8 v0;
  _QWORD *v2;

  v0 = atomic_load((unsigned __int8 *)&qword_254784E18);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_254784E18))
  {
    v2 = operator new(0x80uLL);
    v2[2] = 0;
    *((_BYTE *)v2 + 24) = 0;
    *v2 = &unk_24C516880;
    qword_254784E10 = (uint64_t)v2;
    __cxa_guard_release(&qword_254784E18);
  }
  return qword_254784E10;
}

void sub_20BDD9AE8(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784E18);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDD9B00()
{
  return 0x400000;
}

unint64_t *tbb::internal::concurrent_vector_base::internal_grow_to_at_least(unint64_t *this, unint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, unint64_t))
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  v7 = *this;
  __dmb(0xBu);
  if (v7 < a2)
  {
    do
    {
      while (1)
      {
        v8 = __ldaxr(this);
        if (v8 == v7)
          break;
        __clrex();
        do
          v9 = __ldxr(this);
        while (__stxr(v9, this));
        if (v9 != v7)
        {
          v7 = v9;
          if (v9 >= a2)
            return this;
        }
      }
    }
    while (__stlxr(a2, this));
    return (unint64_t *)tbb::internal::concurrent_vector_base::internal_grow((tbb::internal::concurrent_vector_base *)this, v7, a2, a3, a4);
  }
  return this;
}

uint64_t tbb::internal::concurrent_vector_base::internal_grow(tbb::internal::concurrent_vector_base *this, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, unint64_t))
{
  unint64_t *v7;
  _QWORD *v8;
  _QWORD *v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t result;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  void *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;

  v7 = (unint64_t *)((char *)this + 8);
  v8 = (_QWORD *)((char *)this + 16);
  v9 = (_QWORD *)((char *)this + 24);
  do
  {
    v16 = a2 | 8;
    if (HIDWORD(a2))
      v16 = HIDWORD(a2);
    v17 = 32 * (HIDWORD(a2) != 0);
    if (v16 >= 0x10000)
    {
      v16 >>= 16;
      v17 = (32 * (HIDWORD(a2) != 0)) | 0x10;
    }
    if (v16 >= 0x100)
    {
      v16 >>= 8;
      v17 |= 8uLL;
    }
    if (v16 >= 0x10)
    {
      v16 >>= 4;
      v17 |= 4uLL;
    }
    if (v16 >= 4)
    {
      v16 >>= 2;
      v17 += 2;
    }
    v18 = v17 + ((v16 >> 1) & 1);
    v19 = v18 - 3;
    v20 = 8 << (v18 - 3);
    if (v18 == 3)
      v21 = 16;
    else
      v21 = v20;
    if (v19 >= 2)
    {
      v22 = *v7;
      __dmb(0xBu);
      if (v8 == (_QWORD *)v22)
      {
        v24 = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, (void *)a4);
        *(_OWORD *)v24 = 0u;
        *(_OWORD *)(v24 + 16) = 0u;
        *(_OWORD *)(v24 + 32) = 0u;
        *(_OWORD *)(v24 + 48) = 0u;
        *(_OWORD *)(v24 + 64) = 0u;
        *(_OWORD *)(v24 + 80) = 0u;
        *(_OWORD *)(v24 + 96) = 0u;
        *(_OWORD *)(v24 + 112) = 0u;
        *(_OWORD *)(v24 + 128) = 0u;
        *(_OWORD *)(v24 + 144) = 0u;
        *(_OWORD *)(v24 + 160) = 0u;
        *(_OWORD *)(v24 + 176) = 0u;
        *(_OWORD *)(v24 + 192) = 0u;
        *(_OWORD *)(v24 + 208) = 0u;
        *(_OWORD *)(v24 + 224) = 0u;
        *(_OWORD *)(v24 + 240) = 0u;
        *(_OWORD *)(v24 + 256) = 0u;
        *(_OWORD *)(v24 + 272) = 0u;
        *(_OWORD *)(v24 + 288) = 0u;
        *(_OWORD *)(v24 + 304) = 0u;
        *(_OWORD *)(v24 + 320) = 0u;
        *(_OWORD *)(v24 + 336) = 0u;
        *(_OWORD *)(v24 + 352) = 0u;
        *(_OWORD *)(v24 + 368) = 0u;
        *(_OWORD *)(v24 + 384) = 0u;
        *(_OWORD *)(v24 + 400) = 0u;
        *(_OWORD *)(v24 + 416) = 0u;
        *(_OWORD *)(v24 + 432) = 0u;
        *(_OWORD *)(v24 + 448) = 0u;
        *(_OWORD *)(v24 + 464) = 0u;
        *(_OWORD *)(v24 + 480) = 0u;
        *(_OWORD *)(v24 + 496) = 0u;
        while (!*v8 || !*v9)
          sched_yield();
        *(_QWORD *)v24 = *v8;
        *(_QWORD *)(v24 + 8) = *v9;
        do
        {
          while (1)
          {
            v25 = __ldaxr(v7);
            if (v25 != v22)
              break;
            if (!__stlxr(v24, v7))
              goto LABEL_2;
          }
          __clrex();
          do
            v26 = __ldxr(v7);
          while (__stxr(v26, v7));
        }
        while (v26 == v22);
        if (v8 != (_QWORD *)v26)
          tbb::internal::NFS_Free((tbb::internal *)v24, v23);
      }
    }
LABEL_2:
    v10 = v20 & 0xFFFFFFF0;
    v11 = (int)(v20 & 0xFFFFFFF0);
    v12 = *v7;
    __dmb(0xBu);
    v13 = *(_QWORD *)(v12 + 8 * v19);
    if (!v13)
    {
      if (a2 == v10)
      {
        v13 = tbb::internal::NFS_Allocate(v21, a4, 0, (void *)a4);
        *(_QWORD *)(v12 + 8 * v19) = v13;
      }
      else
      {
        while (!*(_QWORD *)(v12 + 8 * v19))
          sched_yield();
        v13 = *(_QWORD *)(v12 + 8 * v19);
      }
    }
    if (v21 >= a3 - v11)
      v14 = a3 - v11;
    else
      v14 = v21;
    result = a5(v13 + (a2 - v11) * a4, v14 - (a2 - v11));
    a2 = v14 + v11;
  }
  while (v14 + v11 < a3);
  return result;
}

uint64_t tbb::internal::concurrent_vector_base::helper::extend_segment(tbb::internal::concurrent_vector_base::helper *this, tbb::internal::concurrent_vector_base *a2, uint64_t a3, void *a4)
{
  uint64_t result;
  void *v6;
  tbb::internal *v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;

  result = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
  v7 = (tbb::internal *)result;
  *(_OWORD *)result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_OWORD *)(result + 128) = 0u;
  *(_OWORD *)(result + 144) = 0u;
  *(_OWORD *)(result + 160) = 0u;
  *(_OWORD *)(result + 176) = 0u;
  *(_OWORD *)(result + 192) = 0u;
  *(_OWORD *)(result + 208) = 0u;
  *(_OWORD *)(result + 224) = 0u;
  *(_OWORD *)(result + 240) = 0u;
  *(_OWORD *)(result + 256) = 0u;
  *(_OWORD *)(result + 272) = 0u;
  *(_OWORD *)(result + 288) = 0u;
  *(_OWORD *)(result + 304) = 0u;
  *(_OWORD *)(result + 320) = 0u;
  *(_OWORD *)(result + 336) = 0u;
  *(_OWORD *)(result + 352) = 0u;
  *(_OWORD *)(result + 368) = 0u;
  *(_OWORD *)(result + 384) = 0u;
  *(_OWORD *)(result + 400) = 0u;
  *(_OWORD *)(result + 416) = 0u;
  *(_OWORD *)(result + 432) = 0u;
  *(_OWORD *)(result + 448) = 0u;
  *(_OWORD *)(result + 464) = 0u;
  v8 = (_QWORD *)((char *)this + 24);
  v9 = (_QWORD *)((char *)this + 16);
  *(_OWORD *)(result + 480) = 0u;
  *(_OWORD *)(result + 496) = 0u;
  while (!*v9 || !*v8)
    result = sched_yield();
  *(_QWORD *)v7 = *v9;
  *((_QWORD *)v7 + 1) = *v8;
  v10 = (unint64_t *)((char *)this + 8);
  do
  {
    while (1)
    {
      v11 = __ldaxr(v10);
      if ((_QWORD *)v11 != v9)
        break;
      if (!__stlxr((unint64_t)v7, v10))
        return result;
    }
    __clrex();
    do
      v12 = __ldxr(v10);
    while (__stxr(v12, v10));
  }
  while ((_QWORD *)v12 == v9);
  return tbb::internal::NFS_Free(v7, v6);
}

uint64_t tbb::internal::concurrent_vector_base::internal_capacity(tbb::internal::concurrent_vector_base *this)
{
  uint64_t v1;
  tbb::internal::concurrent_vector_base *v2;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;

  v1 = 0;
  v2 = (tbb::internal::concurrent_vector_base *)*((_QWORD *)this + 1);
  __dmb(0xBu);
  v3 = (tbb::internal::concurrent_vector_base *)((char *)this + 16) == v2;
  v4 = 64;
  if (v3)
    v4 = 2;
  while (1)
  {
    v5 = *((_QWORD *)this + 1);
    __dmb(0xBu);
    if (!*(_QWORD *)(v5 + 8 * v1))
      break;
    if (v4 == ++v1)
    {
      LOBYTE(v1) = v4;
      return (int)((8 << v1) & 0xFFFFFFF0);
    }
  }
  return (int)((8 << v1) & 0xFFFFFFF0);
}

unint64_t *tbb::internal::concurrent_vector_base::internal_reserve(unint64_t *this, unint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v6;
  unint64_t *v7;
  unint64_t *v8;
  _QWORD *v9;
  BOOL v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  void *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  std::logic_error *exception;

  if (a2 > (unint64_t)a4)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    sub_20BDCAFB8(exception, "argument to concurrent_vector::reserve exceeds concurrent_vector::max_size()");
    __cxa_throw(exception, (struct type_info *)off_24C514D60, MEMORY[0x24BEDAAF0]);
  }
  v6 = 0;
  v8 = this + 1;
  v7 = (unint64_t *)this[1];
  __dmb(0xBu);
  v9 = this + 2;
  v10 = this + 2 == v7;
  v11 = 64;
  if (v10)
    v11 = 2;
  while (1)
  {
    v12 = *v8;
    __dmb(0xBu);
    if (!*(_QWORD *)(v12 + 8 * v6))
      break;
    if (v11 == ++v6)
    {
      v6 = v11;
      break;
    }
  }
  v13 = 8 << v6;
  if ((int)((8 << v6) & 0xFFFFFFF0) < a2)
  {
    v14 = this + 3;
    do
    {
      if (v6 >= 2)
      {
        v17 = (_QWORD *)*v8;
        __dmb(0xBu);
        if (v9 == v17)
        {
          v19 = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
          *(_OWORD *)v19 = 0u;
          *(_OWORD *)(v19 + 16) = 0u;
          *(_OWORD *)(v19 + 32) = 0u;
          *(_OWORD *)(v19 + 48) = 0u;
          *(_OWORD *)(v19 + 64) = 0u;
          *(_OWORD *)(v19 + 80) = 0u;
          *(_OWORD *)(v19 + 96) = 0u;
          *(_OWORD *)(v19 + 112) = 0u;
          *(_OWORD *)(v19 + 128) = 0u;
          *(_OWORD *)(v19 + 144) = 0u;
          *(_OWORD *)(v19 + 160) = 0u;
          *(_OWORD *)(v19 + 176) = 0u;
          *(_OWORD *)(v19 + 192) = 0u;
          *(_OWORD *)(v19 + 208) = 0u;
          *(_OWORD *)(v19 + 224) = 0u;
          *(_OWORD *)(v19 + 240) = 0u;
          *(_OWORD *)(v19 + 256) = 0u;
          *(_OWORD *)(v19 + 272) = 0u;
          *(_OWORD *)(v19 + 288) = 0u;
          *(_OWORD *)(v19 + 304) = 0u;
          *(_OWORD *)(v19 + 320) = 0u;
          *(_OWORD *)(v19 + 336) = 0u;
          *(_OWORD *)(v19 + 352) = 0u;
          *(_OWORD *)(v19 + 368) = 0u;
          *(_OWORD *)(v19 + 384) = 0u;
          *(_OWORD *)(v19 + 400) = 0u;
          *(_OWORD *)(v19 + 416) = 0u;
          *(_OWORD *)(v19 + 432) = 0u;
          *(_OWORD *)(v19 + 448) = 0u;
          *(_OWORD *)(v19 + 464) = 0u;
          *(_OWORD *)(v19 + 480) = 0u;
          *(_OWORD *)(v19 + 496) = 0u;
          while (!*v9 || !*v14)
            sched_yield();
          *(_QWORD *)v19 = *v9;
          *(_QWORD *)(v19 + 8) = *v14;
          do
          {
            while (1)
            {
              v20 = __ldaxr(v8);
              if ((_QWORD *)v20 != v17)
                break;
              if (!__stlxr(v19, v8))
                goto LABEL_9;
            }
            __clrex();
            do
              v21 = __ldxr(v8);
            while (__stxr(v21, v8));
          }
          while ((_QWORD *)v21 == v17);
          if (v9 != (_QWORD *)v21)
            tbb::internal::NFS_Free((tbb::internal *)v19, v18);
        }
      }
LABEL_9:
      if (v6)
        v15 = v13;
      else
        v15 = 16;
      this = (unint64_t *)tbb::internal::NFS_Allocate(v15, a3, 0, a4);
      v16 = *v8;
      __dmb(0xBu);
      *(_QWORD *)(v16 + 8 * v6++) = this;
      v13 = 8 << v6;
    }
    while ((int)((8 << v6) & 0xFFFFFFF0) < a2);
  }
  return this;
}

void sub_20BDDA104(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unint64_t *tbb::internal::concurrent_vector_base::internal_copy(unint64_t *this, const tbb::internal::concurrent_vector_base *a2, uint64_t a3, void (*a4)(void *, const void *, unint64_t))
{
  unint64_t v4;
  _QWORD *v5;
  unint64_t *v6;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  void *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;

  v4 = *(_QWORD *)a2;
  __dmb(0xBu);
  *this = v4;
  v5 = this + 2;
  __dmb(0xBu);
  this[1] = (unint64_t)(this + 2);
  v6 = this + 1;
  if (v4)
  {
    v8 = 0;
    v9 = 0;
    v10 = this + 3;
    v11 = 8;
    do
    {
      if (v9 >= 2)
      {
        v19 = *v6;
        __dmb(0xBu);
        if (v5 == (_QWORD *)v19)
        {
          v21 = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
          *(_OWORD *)v21 = 0u;
          *(_OWORD *)(v21 + 16) = 0u;
          *(_OWORD *)(v21 + 32) = 0u;
          *(_OWORD *)(v21 + 48) = 0u;
          *(_OWORD *)(v21 + 64) = 0u;
          *(_OWORD *)(v21 + 80) = 0u;
          *(_OWORD *)(v21 + 96) = 0u;
          *(_OWORD *)(v21 + 112) = 0u;
          *(_OWORD *)(v21 + 128) = 0u;
          *(_OWORD *)(v21 + 144) = 0u;
          *(_OWORD *)(v21 + 160) = 0u;
          *(_OWORD *)(v21 + 176) = 0u;
          *(_OWORD *)(v21 + 192) = 0u;
          *(_OWORD *)(v21 + 208) = 0u;
          *(_OWORD *)(v21 + 224) = 0u;
          *(_OWORD *)(v21 + 240) = 0u;
          *(_OWORD *)(v21 + 256) = 0u;
          *(_OWORD *)(v21 + 272) = 0u;
          *(_OWORD *)(v21 + 288) = 0u;
          *(_OWORD *)(v21 + 304) = 0u;
          *(_OWORD *)(v21 + 320) = 0u;
          *(_OWORD *)(v21 + 336) = 0u;
          *(_OWORD *)(v21 + 352) = 0u;
          *(_OWORD *)(v21 + 368) = 0u;
          *(_OWORD *)(v21 + 384) = 0u;
          *(_OWORD *)(v21 + 400) = 0u;
          *(_OWORD *)(v21 + 416) = 0u;
          *(_OWORD *)(v21 + 432) = 0u;
          *(_OWORD *)(v21 + 448) = 0u;
          *(_OWORD *)(v21 + 464) = 0u;
          *(_OWORD *)(v21 + 480) = 0u;
          *(_OWORD *)(v21 + 496) = 0u;
          while (!*v5 || !*v10)
            sched_yield();
          *(_QWORD *)v21 = *v5;
          *(_QWORD *)(v21 + 8) = *v10;
          do
          {
            while (1)
            {
              v22 = __ldaxr(v6);
              if (v22 != v19)
                break;
              if (!__stlxr(v21, v6))
                goto LABEL_3;
            }
            __clrex();
            do
              v23 = __ldxr(v6);
            while (__stxr(v23, v6));
          }
          while (v23 == v19);
          if (v5 != (_QWORD *)v23)
            tbb::internal::NFS_Free((tbb::internal *)v21, v20);
        }
      }
LABEL_3:
      if (v9)
        v12 = v11;
      else
        v12 = 16;
      v13 = tbb::internal::NFS_Allocate(v12, a3, 0, a4);
      v14 = *v6;
      __dmb(0xBu);
      *(_QWORD *)(v14 + 8 * v9) = v13;
      if (v12 >= v4 - v8)
        v15 = v4 - v8;
      else
        v15 = v12;
      v16 = *v6;
      __dmb(0xBu);
      v17 = *(_QWORD *)(v16 + 8 * v9);
      v18 = *((_QWORD *)a2 + 1);
      __dmb(0xBu);
      this = (unint64_t *)((uint64_t (*)(uint64_t, _QWORD, unint64_t))a4)(v17, *(_QWORD *)(v18 + 8 * v9++), v15);
      v11 = 8 << v9;
      v8 = (int)((8 << v9) & 0xFFFFFFF0);
    }
    while (v4 > v8);
  }
  return this;
}

uint64_t tbb::internal::concurrent_vector_base::internal_assign(uint64_t this, const tbb::internal::concurrent_vector_base *a2, uint64_t a3, uint64_t (*a4)(uint64_t, unint64_t), void (*a5)(void *, const void *, unint64_t), uint64_t (*a6)(uint64_t, uint64_t, unint64_t))
{
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  _QWORD *v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  tbb::internal *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v48;

  v7 = (unint64_t *)this;
  v8 = *(_QWORD *)a2;
  __dmb(0xBu);
  v9 = *(_QWORD *)this;
  __dmb(0xBu);
  if (v9 > v8)
  {
    do
    {
      v11 = *v7;
      __dmb(0xBu);
      v12 = --v11 | 8;
      v13 = HIDWORD(v11);
      v14 = v13 != 0;
      if (!v13)
        v13 = v12;
      v15 = 32 * v14;
      if (v13 >= 0x10000)
      {
        v13 >>= 16;
        v15 = (32 * v14) | 0x10;
      }
      if (v13 >= 0x100)
      {
        v13 >>= 8;
        v15 |= 8uLL;
      }
      if (v13 >= 0x10)
      {
        v13 >>= 4;
        v15 |= 4uLL;
      }
      if (v13 >= 4)
      {
        v13 >>= 2;
        v15 += 2;
      }
      v16 = v15 + ((v13 >> 1) & 1) - 3;
      v17 = (int)((8 << v16) & 0xFFFFFFF0);
      v18 = v7[1];
      __dmb(0xBu);
      v19 = *(_QWORD *)(v18 + 8 * v16);
      if (v17 <= v8)
        v20 = v8;
      else
        v20 = v17;
      v21 = v19 + (v20 - v17) * a3;
      v22 = *v7;
      __dmb(0xBu);
      this = a4(v21, v22 - v20);
      __dmb(0xBu);
      *v7 = v20;
      v23 = *v7;
      __dmb(0xBu);
    }
    while (v23 > v8);
  }
  v48 = *v7;
  __dmb(0xBu);
  *v7 = v8;
  if (v8)
  {
    v24 = 0;
    v25 = 0;
    v26 = v7 + 1;
    v27 = v7 + 2;
    v28 = v7 + 3;
    v29 = 8;
    while (1)
    {
      if (v25 >= 2)
      {
        v30 = *v26;
        __dmb(0xBu);
        if (v27 == (_QWORD *)v30)
        {
          this = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
          v43 = (tbb::internal *)this;
          *(_OWORD *)this = 0u;
          *(_OWORD *)(this + 16) = 0u;
          *(_OWORD *)(this + 32) = 0u;
          *(_OWORD *)(this + 48) = 0u;
          *(_OWORD *)(this + 64) = 0u;
          *(_OWORD *)(this + 80) = 0u;
          *(_OWORD *)(this + 96) = 0u;
          *(_OWORD *)(this + 112) = 0u;
          *(_OWORD *)(this + 128) = 0u;
          *(_OWORD *)(this + 144) = 0u;
          *(_OWORD *)(this + 160) = 0u;
          *(_OWORD *)(this + 176) = 0u;
          *(_OWORD *)(this + 192) = 0u;
          *(_OWORD *)(this + 208) = 0u;
          *(_OWORD *)(this + 224) = 0u;
          *(_OWORD *)(this + 240) = 0u;
          *(_OWORD *)(this + 256) = 0u;
          *(_OWORD *)(this + 272) = 0u;
          *(_OWORD *)(this + 288) = 0u;
          *(_OWORD *)(this + 304) = 0u;
          *(_OWORD *)(this + 320) = 0u;
          *(_OWORD *)(this + 336) = 0u;
          *(_OWORD *)(this + 352) = 0u;
          *(_OWORD *)(this + 368) = 0u;
          *(_OWORD *)(this + 384) = 0u;
          *(_OWORD *)(this + 400) = 0u;
          *(_OWORD *)(this + 416) = 0u;
          *(_OWORD *)(this + 432) = 0u;
          *(_OWORD *)(this + 448) = 0u;
          *(_OWORD *)(this + 464) = 0u;
          *(_OWORD *)(this + 480) = 0u;
          *(_OWORD *)(this + 496) = 0u;
          while (!*v27 || !*v28)
            this = sched_yield();
          *(_QWORD *)v43 = *v27;
          *((_QWORD *)v43 + 1) = *v28;
          do
          {
            while (1)
            {
              v44 = __ldaxr(v26);
              if (v44 != v30)
                break;
              if (!__stlxr((unint64_t)v43, v26))
                goto LABEL_21;
            }
            __clrex();
            do
              v45 = __ldxr(v26);
            while (__stxr(v45, v26));
          }
          while (v45 == v30);
          if (v27 != (_QWORD *)v45)
            this = tbb::internal::NFS_Free(v43, v42);
        }
      }
LABEL_21:
      if (v25)
        v31 = v29;
      else
        v31 = 16;
      v32 = *v26;
      __dmb(0xBu);
      if (!*(_QWORD *)(v32 + 8 * v25))
      {
        this = tbb::internal::NFS_Allocate(v31, a3, 0, a4);
        v33 = *v26;
        __dmb(0xBu);
        *(_QWORD *)(v33 + 8 * v25) = this;
      }
      if (v31 >= v8 - v24)
        v31 = v8 - v24;
      if (v48 > v24)
        break;
      v38 = 0;
      if (v31)
        goto LABEL_35;
LABEL_18:
      v29 = 8 << ++v25;
      v24 = (int)((8 << v25) & 0xFFFFFFF0);
      if (v8 <= v24)
        return this;
    }
    if (v48 - v24 >= v31)
      v34 = v31;
    else
      v34 = v48 - v24;
    v35 = *v26;
    __dmb(0xBu);
    v36 = *(_QWORD *)(v35 + 8 * v25);
    v37 = *((_QWORD *)a2 + 1);
    __dmb(0xBu);
    this = ((uint64_t (*)(uint64_t, _QWORD, unint64_t))a5)(v36, *(_QWORD *)(v37 + 8 * v25), v34);
    v31 -= v34;
    v38 = v34 * a3;
    if (!v31)
      goto LABEL_18;
LABEL_35:
    v39 = *v26;
    __dmb(0xBu);
    v40 = *(_QWORD *)(v39 + 8 * v25) + v38;
    v41 = *((_QWORD *)a2 + 1);
    __dmb(0xBu);
    this = a6(v40, *(_QWORD *)(v41 + 8 * v25) + v38, v31);
    goto LABEL_18;
  }
  return this;
}

unint64_t tbb::internal::concurrent_vector_base::internal_push_back(tbb::internal::concurrent_vector_base *this, uint64_t a2, unint64_t *a3, void *a4)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  signed int v10;
  unint64_t *v11;
  tbb::internal::concurrent_vector_base *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  void *v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;

  do
    v6 = __ldaxr((unint64_t *)this);
  while (__stlxr(v6 + 1, (unint64_t *)this));
  *a3 = v6;
  v7 = v6 | 8;
  if (HIDWORD(v6))
    v7 = HIDWORD(v6);
  v8 = 32 * (HIDWORD(v6) != 0);
  if (v7 >= 0x10000)
  {
    v7 >>= 16;
    v8 = (32 * (HIDWORD(v6) != 0)) | 0x10;
  }
  if (v7 >= 0x100)
  {
    v7 >>= 8;
    v8 |= 8uLL;
  }
  if (v7 >= 0x10)
  {
    v7 >>= 4;
    v8 |= 4uLL;
  }
  if (v7 >= 4)
  {
    v7 >>= 2;
    v8 += 2;
  }
  v9 = v8 + ((v7 >> 1) & 1) - 3;
  v10 = (8 << v9) & 0xFFFFFFF0;
  if (v9 >= 2)
  {
    v11 = (unint64_t *)((char *)this + 8);
    v12 = (tbb::internal::concurrent_vector_base *)*((_QWORD *)this + 1);
    __dmb(0xBu);
    if ((tbb::internal::concurrent_vector_base *)((char *)this + 16) == v12)
    {
      v17 = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
      *(_OWORD *)v17 = 0u;
      *(_OWORD *)(v17 + 16) = 0u;
      *(_OWORD *)(v17 + 32) = 0u;
      *(_OWORD *)(v17 + 48) = 0u;
      *(_OWORD *)(v17 + 64) = 0u;
      *(_OWORD *)(v17 + 80) = 0u;
      *(_OWORD *)(v17 + 96) = 0u;
      *(_OWORD *)(v17 + 112) = 0u;
      *(_OWORD *)(v17 + 128) = 0u;
      *(_OWORD *)(v17 + 144) = 0u;
      *(_OWORD *)(v17 + 160) = 0u;
      *(_OWORD *)(v17 + 176) = 0u;
      *(_OWORD *)(v17 + 192) = 0u;
      *(_OWORD *)(v17 + 208) = 0u;
      *(_OWORD *)(v17 + 224) = 0u;
      *(_OWORD *)(v17 + 240) = 0u;
      *(_OWORD *)(v17 + 256) = 0u;
      *(_OWORD *)(v17 + 272) = 0u;
      *(_OWORD *)(v17 + 288) = 0u;
      *(_OWORD *)(v17 + 304) = 0u;
      *(_OWORD *)(v17 + 320) = 0u;
      *(_OWORD *)(v17 + 336) = 0u;
      *(_OWORD *)(v17 + 352) = 0u;
      *(_OWORD *)(v17 + 368) = 0u;
      *(_OWORD *)(v17 + 384) = 0u;
      *(_OWORD *)(v17 + 400) = 0u;
      *(_OWORD *)(v17 + 416) = 0u;
      *(_OWORD *)(v17 + 432) = 0u;
      *(_OWORD *)(v17 + 448) = 0u;
      *(_OWORD *)(v17 + 464) = 0u;
      v18 = (_QWORD *)((char *)this + 24);
      *(_OWORD *)(v17 + 480) = 0u;
      *(_OWORD *)(v17 + 496) = 0u;
      while (!*(_QWORD *)v12 || !*v18)
        sched_yield();
      *(_QWORD *)v17 = *(_QWORD *)v12;
      *(_QWORD *)(v17 + 8) = *v18;
      do
      {
        while (1)
        {
          v19 = __ldaxr(v11);
          if ((tbb::internal::concurrent_vector_base *)v19 != v12)
            break;
          if (!__stlxr(v17, v11))
            goto LABEL_14;
        }
        __clrex();
        do
          v20 = __ldxr(v11);
        while (__stxr(v20, v11));
      }
      while ((tbb::internal::concurrent_vector_base *)v20 == v12);
      tbb::internal::NFS_Free((tbb::internal *)v17, v16);
    }
  }
LABEL_14:
  v13 = *((_QWORD *)this + 1);
  __dmb(0xBu);
  v14 = *(_QWORD *)(v13 + 8 * v9);
  if (!v14)
  {
    if (v6 == v10)
    {
      if (v9)
        v15 = 8 << v9;
      else
        v15 = 16;
      v14 = tbb::internal::NFS_Allocate(v15, a2, 0, a4);
      *(_QWORD *)(v13 + 8 * v9) = v14;
    }
    else
    {
      while (!*(_QWORD *)(v13 + 8 * v9))
        sched_yield();
      v14 = *(_QWORD *)(v13 + 8 * v9);
    }
  }
  return v14 + (v6 - v10) * a2;
}

unint64_t tbb::internal::concurrent_vector_base::internal_grow_by(tbb::internal::concurrent_vector_base *this, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, unint64_t))
{
  unint64_t v4;

  do
    v4 = __ldaxr((unint64_t *)this);
  while (__stlxr(v4 + a2, (unint64_t *)this));
  tbb::internal::concurrent_vector_base::internal_grow(this, v4, v4 + a2, a3, a4);
  return v4;
}

tbb::internal *tbb::internal::concurrent_vector_base::internal_clear(tbb::internal *this, void (*a2)(void *, unint64_t), int a3)
{
  tbb::internal *v4;
  uint64_t v5;
  unint64_t v7;
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  signed int v12;
  uint64_t v13;
  tbb::internal *v14;
  tbb::internal *v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  tbb::internal *v21;

  v4 = this;
  v5 = *(_QWORD *)this;
  __dmb(0xBu);
  *(_QWORD *)this = 0;
  if (v5)
  {
    do
    {
      v7 = (unint64_t)(v5 - 1) >> 32;
      v8 = v7 != 0;
      if (!v7)
        v7 = (v5 - 1) | 8;
      v9 = 32 * v8;
      if (v7 >= 0x10000)
      {
        v7 >>= 16;
        v9 = (32 * v8) | 0x10;
      }
      if (v7 >= 0x100)
      {
        v7 >>= 8;
        v9 |= 8uLL;
      }
      if (v7 >= 0x10)
      {
        v7 >>= 4;
        v9 |= 4uLL;
      }
      if (v7 >= 4)
      {
        v7 >>= 2;
        v9 += 2;
      }
      v10 = v9 + ((v7 >> 1) & 1) - 3;
      v11 = *((_QWORD *)v4 + 1);
      __dmb(0xBu);
      v12 = (8 << v10) & 0xFFFFFFF0;
      this = (tbb::internal *)((uint64_t (*)(_QWORD, uint64_t))a2)(*(_QWORD *)(v11 + 8 * v10), v5 - v12);
      v5 = v12;
    }
    while (v12);
  }
  if (a3)
  {
    v13 = 0;
    v14 = (tbb::internal *)*((_QWORD *)v4 + 1);
    __dmb(0xBu);
    v15 = (tbb::internal *)((char *)v4 + 16);
    v16 = (tbb::internal *)((char *)v4 + 16) == v14;
    v17 = 64;
    if (v16)
      v17 = 2;
    while (1)
    {
      v18 = *((_QWORD *)v4 + 1);
      __dmb(0xBu);
      if (!*(_QWORD *)(v18 + 8 * v13))
        break;
      if (v17 == ++v13)
      {
        v13 = v17;
        goto LABEL_20;
      }
    }
    if (!v13)
      goto LABEL_22;
LABEL_20:
    v19 = v13 - 1;
    do
    {
      v20 = *((_QWORD *)v4 + 1);
      __dmb(0xBu);
      v21 = *(tbb::internal **)(v20 + 8 * v19);
      *(_QWORD *)(v20 + 8 * v19) = 0;
      tbb::internal::NFS_Free(v21, a2);
      --v19;
    }
    while (v19 != -1);
LABEL_22:
    *((_QWORD *)v4 + 2) = 0;
    *((_QWORD *)v4 + 3) = 0;
    this = (tbb::internal *)*((_QWORD *)v4 + 1);
    __dmb(0xBu);
    if (v15 != this)
    {
      __dmb(0xBu);
      *((_QWORD *)v4 + 1) = v15;
      return (tbb::internal *)tbb::internal::NFS_Free(this, a2);
    }
  }
  return this;
}

uint64_t tbb::internal::micro_queue::push(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  int v14;
  unsigned int v15;
  _QWORD *v16;
  uint64_t result;

  v7 = a3 & 0xFFFFFFFFFFFFFFF8;
  v8 = *(_QWORD *)(a4 + 24);
  v9 = (v8 - 1) & (a3 >> 3);
  if (v9)
  {
    v10 = 0;
  }
  else
  {
    v10 = operator new(*(_QWORD *)(a4 + 32) * v8 + 16);
    *v10 = 0;
    v10[1] = 0;
  }
  v11 = v7 + 8;
  while (1)
  {
    v12 = *(_QWORD *)(a1 + 24);
    __dmb(0xBu);
    if (v12 == v7)
      break;
    sched_yield();
  }
  if (v10)
  {
    v13 = (unsigned int *)((a1 + 32) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_9:
    v14 = *v13 & ~(255 << (8 * ((a1 + 32) & 3)));
    do
    {
      while (1)
      {
        v15 = __ldaxr(v13);
        if (v15 == v14)
          break;
        __clrex();
        if (*v13 != v14)
        {
          sched_yield();
          goto LABEL_9;
        }
      }
    }
    while (__stlxr(v14 | (1 << (8 * ((a1 + 32) & 3))), v13));
    v16 = *(_QWORD **)(a1 + 16);
    __dmb(0xBu);
    if (v16)
    {
      *v16 = v10;
    }
    else
    {
      __dmb(0xBu);
      *(_QWORD *)a1 = v10;
    }
    __dmb(0xBu);
    *(_QWORD *)(a1 + 16) = v10;
    __dmb(0xBu);
    *(_BYTE *)(a1 + 32) = 0;
  }
  else
  {
    v10 = *(_QWORD **)(a1 + 16);
    __dmb(0xBu);
  }
  result = (**(uint64_t (***)(uint64_t, _QWORD *, uint64_t, uint64_t))a4)(a4, v10, v9, a2);
  v10[1] |= 1 << v9;
  __dmb(0xBu);
  *(_QWORD *)(a1 + 24) = v11;
  return result;
}

void sub_20BDDAB78(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  __dmb(0xBu);
  *(_QWORD *)(v1 + 24) = v2;
  _Unwind_Resume(a1);
}

BOOL tbb::internal::micro_queue::pop(tbb::internal::micro_queue *this, void *a2, unint64_t a3, tbb::internal::concurrent_queue_base *a4)
{
  unint64_t v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17[3];

  v8 = a3 & 0xFFFFFFFFFFFFFFF8;
  for (i = *((_QWORD *)this + 1); ; i = *((_QWORD *)this + 1))
  {
    __dmb(0xBu);
    if (i == v8)
      break;
    sched_yield();
  }
  while (1)
  {
    v10 = *((_QWORD *)this + 3);
    __dmb(0xBu);
    if (v10 != v8)
      break;
    sched_yield();
  }
  v11 = *(_QWORD *)this;
  __dmb(0xBu);
  v12 = *((_QWORD *)a4 + 3) - 1;
  v13 = v12 & (a3 >> 3);
  if (v13 == v12)
    v14 = v11;
  else
    v14 = 0;
  v17[0] = v8 + 8;
  v17[1] = (uint64_t)this;
  v17[2] = v14;
  v15 = *(_QWORD *)(v11 + 8) & (1 << v13);
  if (v15)
    (*(void (**)(tbb::internal::concurrent_queue_base *, void *))(*(_QWORD *)a4 + 8))(a4, a2);
  sub_20BDDB334(v17);
  return v15 != 0;
}

void sub_20BDDAC64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDDB334((uint64_t *)va);
  _Unwind_Resume(a1);
}

tbb::internal::concurrent_queue_base *tbb::internal::concurrent_queue_base::concurrent_queue_base(tbb::internal::concurrent_queue_base *this, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v6;
  unint64_t v7;
  void *v8;

  *(_QWORD *)this = &unk_24C5168C8;
  if (a2 >= 9)
  {
    if (a2 >= 0x11)
    {
      if (a2 >= 0x21)
      {
        if (a2 >= 0x41)
        {
          v6 = 1;
          if (a2 < 0x81)
            v6 = 2;
        }
        else
        {
          v6 = 4;
        }
      }
      else
      {
        v6 = 8;
      }
    }
    else
    {
      v6 = 16;
    }
  }
  else
  {
    v6 = 32;
  }
  v7 = 2;
  if (a2 > 2)
    v7 = a2;
  *((_QWORD *)this + 2) = 0xFFFFFFFFFFFFFFFFLL / v7;
  *((_QWORD *)this + 3) = v6;
  v8 = (void *)tbb::internal::NFS_Allocate(1uLL, 576, 0, a4);
  *((_QWORD *)this + 1) = v8;
  bzero(v8, 0x240uLL);
  *((_QWORD *)this + 4) = a2;
  return this;
}

void tbb::internal::concurrent_queue_base::~concurrent_queue_base(tbb::internal::concurrent_queue_base *this, void *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  *(_QWORD *)this = &unk_24C5168C8;
  v3 = *(void **)(*((_QWORD *)this + 1) + 272);
  __dmb(0xBu);
  if (v3)
    operator delete(v3);
  v4 = *(void **)(*((_QWORD *)this + 1) + 312);
  __dmb(0xBu);
  if (v4)
    operator delete(v4);
  v5 = *(void **)(*((_QWORD *)this + 1) + 352);
  __dmb(0xBu);
  if (v5)
    operator delete(v5);
  v6 = *(void **)(*((_QWORD *)this + 1) + 392);
  __dmb(0xBu);
  if (v6)
    operator delete(v6);
  v7 = *(void **)(*((_QWORD *)this + 1) + 432);
  __dmb(0xBu);
  if (v7)
    operator delete(v7);
  v8 = *(void **)(*((_QWORD *)this + 1) + 472);
  __dmb(0xBu);
  if (v8)
    operator delete(v8);
  v9 = *(void **)(*((_QWORD *)this + 1) + 512);
  __dmb(0xBu);
  if (v9)
    operator delete(v9);
  v10 = *(void **)(*((_QWORD *)this + 1) + 552);
  __dmb(0xBu);
  if (v10)
    operator delete(v10);
  tbb::internal::NFS_Free(*((tbb::internal **)this + 1), a2);
}

uint64_t tbb::internal::concurrent_queue_base::internal_push(tbb::internal::concurrent_queue_base *this, uint64_t a2)
{
  _QWORD *v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v8;

  v4 = (_QWORD *)*((_QWORD *)this + 1);
  v5 = v4 + 16;
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + 1, v5));
  if (*((_QWORD *)this + 2) != 0x7FFFFFFFFFFFFFFFLL)
  {
    while (1)
    {
      v8 = *v4;
      __dmb(0xBu);
      if ((int64_t)(v6 - v8) < *((_QWORD *)this + 2))
        break;
      sched_yield();
    }
  }
  return tbb::internal::micro_queue::push((uint64_t)&v4[5 * ((3 * v6) & 7) + 32], a2, v6, (uint64_t)this);
}

BOOL tbb::internal::concurrent_queue_base::internal_pop(tbb::internal::concurrent_queue_base *this, void *a2)
{
  unint64_t *v4;
  unint64_t v5;
  _BOOL8 result;

  v4 = (unint64_t *)*((_QWORD *)this + 1);
  do
  {
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
    result = tbb::internal::micro_queue::pop((tbb::internal::micro_queue *)&v4[5 * ((3 * v5) & 7) + 32], a2, v5, this);
  }
  while (!result);
  return result;
}

BOOL tbb::internal::concurrent_queue_base::internal_pop_if_present(tbb::internal::concurrent_queue_base *this, void *a2)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  _BOOL8 v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v4 = (unint64_t *)*((_QWORD *)this + 1);
  while (1)
  {
    v5 = *v4;
    __dmb(0xBu);
    v6 = v4[16];
    __dmb(0xBu);
    v7 = v6 > v5;
    if (v6 <= v5)
      break;
    do
    {
      while (1)
      {
        v8 = __ldaxr(v4);
        if (v8 == v5)
          break;
        __clrex();
        do
          v9 = __ldxr(v4);
        while (__stxr(v9, v4));
        if (v9 != v5)
        {
          sched_yield();
          v5 = *v4;
          __dmb(0xBu);
          v10 = v4[16];
          __dmb(0xBu);
          if (v10 <= v5)
            return 0;
        }
      }
    }
    while (__stlxr(v5 + 1, v4));
    if (tbb::internal::micro_queue::pop((tbb::internal::micro_queue *)&v4[5 * ((3 * v5) & 7) + 32], a2, v5, this))
    {
      return v7;
    }
  }
  return 0;
}

uint64_t tbb::internal::concurrent_queue_base::internal_push_if_not_full(tbb::internal::concurrent_queue_base *this, uint64_t a2)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t *v4;
  uint64_t v5;
  unint64_t v8;
  unint64_t v9;
  uint64_t result;
  uint64_t v11;

  v2 = (_QWORD *)*((_QWORD *)this + 1);
  v4 = v2 + 16;
  v3 = v2[16];
  __dmb(0xBu);
  v5 = *v2;
  __dmb(0xBu);
  if ((int64_t)(v3 - v5) >= *((_QWORD *)this + 2))
    return 0;
  do
  {
    while (1)
    {
      v8 = __ldaxr(v4);
      if (v8 == v3)
        break;
      __clrex();
      do
        v9 = __ldxr(v4);
      while (__stxr(v9, v4));
      if (v9 != v3)
      {
        sched_yield();
        result = 0;
        v3 = v2[16];
        __dmb(0xBu);
        v11 = *v2;
        __dmb(0xBu);
        if ((int64_t)(v3 - v11) >= *((_QWORD *)this + 2))
          return result;
      }
    }
  }
  while (__stlxr(v3 + 1, v4));
  tbb::internal::micro_queue::push((uint64_t)&v2[5 * ((3 * v3) & 7) + 32], a2, v3, (uint64_t)this);
  return 1;
}

uint64_t tbb::internal::concurrent_queue_base::internal_size(tbb::internal::concurrent_queue_base *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*((_QWORD *)this + 1) + 128);
  __dmb(0xBu);
  v2 = **((_QWORD **)this + 1);
  __dmb(0xBu);
  return v1 - v2;
}

uint64_t tbb::internal::concurrent_queue_base::internal_set_capacity(uint64_t this, unint64_t a2)
{
  uint64_t v2;

  v2 = 0x7FFFFFFFFFFFFFFFLL;
  if (a2 < 0x7FFFFFFFFFFFFFFFLL)
    v2 = a2;
  *(_QWORD *)(this + 16) = v2;
  return this;
}

tbb::internal::concurrent_queue_iterator_base *tbb::internal::concurrent_queue_iterator_base::concurrent_queue_iterator_base(tbb::internal::concurrent_queue_iterator_base *this, const tbb::internal::concurrent_queue_base *a2)
{
  unint64_t *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v4 = (unint64_t *)operator new(0x50uLL);
  v5 = **((_QWORD **)a2 + 1);
  __dmb(0xBu);
  *v4 = v5;
  v4[1] = (unint64_t)a2;
  v6 = (_QWORD *)*((_QWORD *)a2 + 1);
  v7 = v6[32];
  __dmb(0xBu);
  v4[2] = v7;
  v8 = v6[37];
  __dmb(0xBu);
  v4[3] = v8;
  v9 = v6[42];
  __dmb(0xBu);
  v4[4] = v9;
  v10 = v6[47];
  __dmb(0xBu);
  v4[5] = v10;
  v11 = v6[52];
  __dmb(0xBu);
  v4[6] = v11;
  v12 = v6[57];
  __dmb(0xBu);
  v4[7] = v12;
  v13 = v6[62];
  __dmb(0xBu);
  v4[8] = v13;
  v14 = v6[67];
  __dmb(0xBu);
  v4[9] = v14;
  *(_QWORD *)this = v4;
  v15 = *v4;
  v16 = *(_QWORD *)(*(_QWORD *)(v4[1] + 8) + 128);
  __dmb(0xBu);
  if (v16 == v15)
    v17 = 0;
  else
    v17 = v4[((3 * v15) & 7) + 2]
        + ((*(_QWORD *)(v4[1] + 24) - 1) & (v15 >> 3)) * *(_QWORD *)(v4[1] + 32)
        + 16;
  *((_QWORD *)this + 1) = v17;
  return this;
}

void tbb::internal::concurrent_queue_iterator_base::assign(tbb::internal::concurrent_queue_iterator_base *this, const tbb::internal::concurrent_queue_iterator_base *a2)
{
  void *v4;
  _OWORD *v5;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  v4 = *(void **)this;
  v5 = *(_OWORD **)a2;
  if (v4 != *(void **)a2)
  {
    if (v4)
    {
      operator delete(v4);
      *(_QWORD *)this = 0;
      v5 = *(_OWORD **)a2;
    }
    if (v5)
    {
      v6 = operator new(0x50uLL);
      *v6 = *v5;
      v7 = v5[1];
      v8 = v5[2];
      v9 = v5[4];
      v6[3] = v5[3];
      v6[4] = v9;
      v6[1] = v7;
      v6[2] = v8;
      *(_QWORD *)this = v6;
    }
  }
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
}

unint64_t **tbb::internal::concurrent_queue_iterator_base::advance(unint64_t **this)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;

  v1 = *this;
  v2 = **this;
  v3 = (*this)[1];
  if (((*(_QWORD *)(v3 + 24) - 1) & ~(v2 >> 3)) == 0)
  {
    v4 = &v1[(3 * (_BYTE)v2) & 7];
    v4[2] = *(_QWORD *)v4[2];
    v1 = *this;
    v3 = (*this)[1];
  }
  v5 = v2 + 1;
  *v1 = v5;
  v6 = *(_QWORD *)(*(_QWORD *)(v3 + 8) + 128);
  __dmb(0xBu);
  if (v6 == v5)
    this[1] = 0;
  else
    this[1] = (unint64_t *)(v1[((3 * v5) & 7) + 2]
                                 + ((*(_QWORD *)(v1[1] + 24) - 1) & (v5 >> 3)) * *(_QWORD *)(v1[1] + 32)
                                 + 16);
  return this;
}

void tbb::internal::concurrent_queue_iterator_base::~concurrent_queue_iterator_base(void **this)
{
  void *v2;

  v2 = *this;
  if (v2)
    operator delete(v2);
  *this = 0;
}

{
  void *v2;

  v2 = *this;
  if (v2)
    operator delete(v2);
  *this = 0;
}

uint64_t *sub_20BDDB334(uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;
  unsigned int *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = (uint64_t *)a1[2];
  if (v2)
  {
    v3 = a1[1] + 32;
    v4 = (unsigned int *)(v3 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_3:
    v5 = *v4 & ~(255 << (8 * (v3 & 3)));
    do
    {
      while (1)
      {
        v6 = __ldaxr(v4);
        if (v6 == v5)
          break;
        __clrex();
        if (*v4 != v5)
        {
          sched_yield();
          goto LABEL_3;
        }
      }
    }
    while (__stlxr(v5 | (1 << (8 * (v3 & 3))), v4));
    v7 = *v2;
    v8 = (_QWORD *)a1[1];
    __dmb(0xBu);
    *v8 = v7;
    if (!v7)
    {
      v9 = a1[1];
      __dmb(0xBu);
      *(_QWORD *)(v9 + 16) = 0;
    }
    __dmb(0xBu);
    *(_BYTE *)v3 = 0;
    v10 = *a1;
    v11 = a1[1];
    __dmb(0xBu);
    *(_QWORD *)(v11 + 8) = v10;
    operator delete(v2);
  }
  else
  {
    v12 = *a1;
    v13 = a1[1];
    __dmb(0xBu);
    *(_QWORD *)(v13 + 8) = v12;
  }
  return a1;
}

uint64_t tbb::spin_rw_mutex::internal_acquire_writer(unint64_t *a1)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  while (1)
  {
    v2 = *a1;
    if ((*a1 & 0xFFFFFFFFFFFFFFFDLL) != 0)
    {
      if ((v2 & 2) == 0)
      {
        while (1)
        {
          v3 = *a1;
          v4 = *a1 | 2;
          do
          {
            while (1)
            {
              v5 = __ldaxr(a1);
              if (v5 != v3)
                break;
              if (!__stlxr(v4, a1))
                goto LABEL_3;
            }
            __clrex();
            do
              v6 = __ldxr(a1);
            while (__stxr(v6, a1));
          }
          while (v6 == v3);
          sched_yield();
        }
      }
      goto LABEL_3;
    }
    v7 = *a1;
    do
    {
      while (1)
      {
        v8 = __ldaxr(a1);
        if (v8 != v2)
          break;
        if (!__stlxr(1uLL, a1))
          goto LABEL_2;
      }
      __clrex();
      do
        v9 = __ldxr(a1);
      while (__stxr(v9, a1));
    }
    while (v9 == v2);
    v7 = v9;
LABEL_2:
    if (v7 == v2)
      return 0;
LABEL_3:
    sched_yield();
  }
}

_QWORD *tbb::spin_rw_mutex::internal_release_writer(_QWORD *result)
{
  *result = 0;
  return result;
}

unint64_t *tbb::spin_rw_mutex::internal_acquire_reader(unint64_t *result)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  v1 = result;
  while (1)
  {
    v2 = *v1;
    if ((*v1 & 3) == 0)
    {
      v3 = *v1;
      do
      {
        while (1)
        {
          v4 = __ldaxr(v1);
          if (v4 != v2)
            break;
          if (!__stlxr(v2 + 4, v1))
            goto LABEL_2;
        }
        __clrex();
        do
          v5 = __ldxr(v1);
        while (__stxr(v5, v1));
      }
      while (v5 == v2);
      v3 = v5;
LABEL_2:
      if (v3 == v2)
        return result;
    }
    result = (unint64_t *)sched_yield();
  }
}

uint64_t tbb::spin_rw_mutex::internal_upgrade(unint64_t *a1)
{
  unint64_t v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  do
  {
    v2 = *a1;
    v3 = (*a1 & 2) == 0 || (*a1 & 0xFFFFFFFFFFFFFFFCLL) == 4;
    v4 = v3;
    if (!v3)
    {
      do
        v8 = __ldaxr(a1);
      while (__stlxr(v8 - 4, a1));
      while (1)
      {
        v9 = *a1;
        if ((*a1 & 0xFFFFFFFFFFFFFFFDLL) != 0)
        {
          if ((v9 & 2) == 0)
          {
            while (1)
            {
              v10 = *a1;
              v11 = *a1 | 2;
              do
              {
                while (1)
                {
                  v12 = __ldaxr(a1);
                  if (v12 != v10)
                    break;
                  if (!__stlxr(v11, a1))
                    goto LABEL_21;
                }
                __clrex();
                do
                  v13 = __ldxr(a1);
                while (__stxr(v13, a1));
              }
              while (v13 == v10);
              sched_yield();
            }
          }
        }
        else
        {
          v14 = *a1;
          do
          {
            while (1)
            {
              v15 = __ldaxr(a1);
              if (v15 != v9)
                break;
              if (!__stlxr(1uLL, a1))
                goto LABEL_20;
            }
            __clrex();
            do
              v16 = __ldxr(a1);
            while (__stxr(v16, a1));
          }
          while (v16 == v9);
          v14 = v16;
LABEL_20:
          if (v14 == v9)
            return v4;
        }
LABEL_21:
        sched_yield();
      }
    }
    v5 = *a1;
    do
    {
      while (1)
      {
        v6 = __ldaxr(a1);
        if (v6 != v2)
          break;
        if (!__stlxr(v2 | 2, a1))
          goto LABEL_2;
      }
      __clrex();
      do
        v7 = __ldxr(a1);
      while (__stxr(v7, a1));
    }
    while (v7 == v2);
    v5 = v7;
LABEL_2:
    ;
  }
  while (v5 != v2);
  while ((*a1 & 0xFFFFFFFFFFFFFFFCLL) != 4)
    sched_yield();
  *a1 = 1;
  return v4;
}

unint64_t *tbb::spin_rw_mutex::internal_release_reader(unint64_t *result)
{
  unint64_t v1;

  do
    v1 = __ldaxr(result);
  while (__stlxr(v1 - 4, result));
  return result;
}

_QWORD *tbb::spin_rw_mutex::internal_downgrade(_QWORD *result)
{
  *result = 4;
  return result;
}

BOOL tbb::spin_rw_mutex::internal_try_acquire_writer(unint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v1 = *a1;
  if ((*a1 & 0xFFFFFFFFFFFFFFFDLL) != 0)
    return 0;
  v2 = *a1;
  do
  {
    while (1)
    {
      v3 = __ldaxr(a1);
      if (v3 != v1)
        break;
      if (!__stlxr(1uLL, a1))
        return v2 == v1;
    }
    __clrex();
    do
      v4 = __ldxr(a1);
    while (__stxr(v4, a1));
  }
  while (v4 == v1);
  v2 = v4;
  return v2 == v1;
}

BOOL tbb::spin_rw_mutex::internal_try_acquire_reader(unint64_t *a1)
{
  unint64_t v1;
  uint64_t v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v1 = *a1;
  v2 = *a1 & 3;
  if (!v2)
  {
    do
    {
      v4 = v1;
      do
      {
        while (1)
        {
          v5 = __ldaxr(a1);
          if (v5 != v1)
            break;
          if (!__stlxr(v1 + 4, a1))
            goto LABEL_4;
        }
        __clrex();
        do
          v6 = __ldxr(a1);
        while (__stxr(v6, a1));
      }
      while (v6 == v1);
      v4 = v6;
LABEL_4:
      ;
    }
    while (v4 != v1);
  }
  return v2 == 0;
}

tbb::internal::generic_scheduler *tbb::task::destroy(tbb::task *this, tbb::task *a2)
{
  return tbb::interface5::internal::task_base::destroy(a2, a2);
}

uint64_t Alembic::Util::v12::MurmurHash3_x64_128(uint64_t this, unint64_t a2, unint64_t a3, unint64_t *a4, void *a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unsigned __int8 *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;

  if (a2 >= 0x10)
  {
    v6 = 0;
    v5 = 0;
    v7 = a2 >> 4;
    v8 = (_QWORD *)(this + 8);
    do
    {
      v5 = 5
         * (__ROR8__((0x4CF5AD432745937FLL * ((0x88A129EA80000000 * *(v8 - 1)) | ((0x87C37B91114253D5 * *(v8 - 1)) >> 33))) ^ v5, 37)+ v6)+ 1390208809;
      v6 = 5
         * (v5
          + __ROR8__((0x87C37B91114253D5* ((0x4E8B26FE00000000 * *v8) | ((unint64_t)(0x4CF5AD432745937FLL * *v8) >> 31))) ^ v6, 33))+ 944331445;
      v8 += 2;
      --v7;
    }
    while (v7);
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = (unsigned __int8 *)(this + (a2 & 0xFFFFFFFFFFFFFFF0));
  switch(a2 & 0xF)
  {
    case 1uLL:
      goto LABEL_20;
    case 2uLL:
      goto LABEL_19;
    case 3uLL:
      goto LABEL_18;
    case 4uLL:
      goto LABEL_17;
    case 5uLL:
      goto LABEL_16;
    case 6uLL:
      goto LABEL_15;
    case 7uLL:
      goto LABEL_14;
    case 8uLL:
      goto LABEL_13;
    case 9uLL:
      goto LABEL_12;
    case 0xAuLL:
      goto LABEL_11;
    case 0xBuLL:
      goto LABEL_10;
    case 0xCuLL:
      goto LABEL_9;
    case 0xDuLL:
      goto LABEL_8;
    case 0xEuLL:
      goto LABEL_7;
    case 0xFuLL:
      v9 = (unint64_t)v22[14] << 48;
LABEL_7:
      v10 = v9 | ((unint64_t)v22[13] << 40);
LABEL_8:
      v11 = v10 ^ ((unint64_t)v22[12] << 32);
LABEL_9:
      v12 = v11 ^ ((unint64_t)v22[11] << 24);
LABEL_10:
      v13 = v12 ^ ((unint64_t)v22[10] << 16);
LABEL_11:
      v14 = v13 ^ ((unint64_t)v22[9] << 8);
LABEL_12:
      v6 ^= 0x87C37B91114253D5
          * ((0x4E8B26FE00000000 * (v14 ^ v22[8])) | ((0x4CF5AD432745937FLL * (v14 ^ v22[8])) >> 31));
LABEL_13:
      v15 = (unint64_t)v22[7] << 56;
LABEL_14:
      v16 = v15 | ((unint64_t)v22[6] << 48);
LABEL_15:
      v17 = v16 ^ ((unint64_t)v22[5] << 40);
LABEL_16:
      v18 = v17 ^ ((unint64_t)v22[4] << 32);
LABEL_17:
      v19 = v18 ^ ((unint64_t)v22[3] << 24);
LABEL_18:
      v20 = v19 ^ ((unint64_t)v22[2] << 16);
LABEL_19:
      v21 = v20 ^ ((unint64_t)v22[1] << 8);
LABEL_20:
      v5 ^= 0x4CF5AD432745937FLL
          * ((0x88A129EA80000000 * (v21 ^ *v22)) | ((0x87C37B91114253D5 * (v21 ^ *v22)) >> 33));
      break;
    default:
      break;
  }
  v23 = v6 ^ a2;
  v24 = v23 + (v5 ^ a2);
  v25 = v24 + v23;
  v26 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) >> 33));
  v27 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v25 ^ (v25 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v25 ^ (v25 >> 33))) >> 33));
  v28 = v27 ^ (v27 >> 33);
  v29 = v28 + (v26 ^ (v26 >> 33));
  *a4 = v29;
  a4[1] = v29 + v28;
  return this;
}

BOOL Alembic::Util::v12::isStandardName(unsigned __int8 *a1)
{
  unint64_t v1;
  unsigned __int8 *v2;
  int v3;
  unsigned __int8 *v6;
  int v7;
  uint64_t v9;
  unint64_t v10;
  int v11;

  if ((char)a1[23] < 0)
  {
    v1 = *((_QWORD *)a1 + 1);
    if (!v1)
      return 0;
    v2 = *(unsigned __int8 **)a1;
  }
  else
  {
    v1 = a1[23];
    v2 = a1;
    if (!a1[23])
      return 0;
  }
  v3 = *v2;
  if (v3 != 95 && (v3 & 0xFFFFFFDF) - 65 > 0x19)
    return 0;
  if (v1 < 2)
    return 1;
  v6 = (a1[23] & 0x80u) == 0 ? a1 : *(unsigned __int8 **)a1;
  v7 = v6[1];
  if ((v7 - 48) >= 0xA && v7 != 95 && (v7 & 0xFFFFFFDF) - 65 > 0x19)
    return 0;
  v9 = 2;
  do
  {
    v10 = v9;
    if (v1 == v9)
      break;
    v11 = v6[v9++];
  }
  while ((v11 - 48) < 0xA || v11 == 95 || (v11 & 0xFFFFFFDF) - 65 < 0x1A);
  return v10 >= v1;
}

std::string *Alembic::Util::v12::makeStandardName(std::string *result, int a2)
{
  unint64_t size;
  int v3;
  BOOL v4;
  BOOL v5;
  std::string *v6;
  uint64_t i;
  std::string *v8;
  int v9;
  int v11;
  _QWORD *exception;
  _QWORD *v14;
  __int128 __p;
  char v16;
  _QWORD v17[4];
  _BYTE v18[16];
  _QWORD v19[33];

  if (a2 != 95 && ((a2 & 0xDF) - 65) >= 0x1Au)
  {
    sub_20BDDBD68((uint64_t)v18);
    sub_20BDDC1C8(v19, (uint64_t)"Cannot fix bad name (bad fix character).", 40);
    std::stringbuf::str();
    sub_20BDDBF20(v17, &__p);
    if (v16 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v14 = sub_20BDDC09C(exception, (uint64_t)v17);
    __cxa_throw(v14, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if ((SHIBYTE(result->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    size = HIBYTE(result->__r_.__value_.__r.__words[2]);
    v3 = result->__r_.__value_.__s.__data_[0];
    if (*((_BYTE *)&result->__r_.__value_.__s + 23))
      v4 = v3 == 0;
    else
      v4 = 1;
    if (!v4)
    {
      v5 = v3 != 95 && (v3 & 0xFFFFFFDF) - 65 >= 0x1A;
      v6 = result;
      if (!v5)
        goto LABEL_14;
LABEL_13:
      v6->__r_.__value_.__s.__data_[0] = a2;
      goto LABEL_14;
    }
    return std::string::operator=(result, a2);
  }
  size = result->__r_.__value_.__l.__size_;
  if (!size)
    return std::string::operator=(result, a2);
  v6 = (std::string *)result->__r_.__value_.__r.__words[0];
  v11 = *(unsigned __int8 *)result->__r_.__value_.__l.__data_;
  if (!*result->__r_.__value_.__l.__data_)
    return std::string::operator=(result, a2);
  if (v11 != 95 && (v11 & 0xFFFFFFDF) - 65 >= 0x1A)
    goto LABEL_13;
LABEL_14:
  if (size >= 2)
  {
    for (i = 1; i != size; ++i)
    {
      if ((result->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v8 = result;
      else
        v8 = (std::string *)result->__r_.__value_.__r.__words[0];
      v9 = v8->__r_.__value_.__s.__data_[i];
      if ((v9 - 48) >= 0xA && v9 != 95 && (v9 & 0xFFFFFFDF) - 65 >= 0x1A)
        v8->__r_.__value_.__s.__data_[i] = a2;
    }
  }
  return result;
}

void sub_20BDDBD40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDDBD68(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = MEMORY[0x24BEDB858];
  v3 = MEMORY[0x24BEDB858] + 104;
  *(_QWORD *)(a1 + 128) = MEMORY[0x24BEDB858] + 104;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  v4 = a1 + 16;
  v5 = (_QWORD *)MEMORY[0x24BEDB7F0];
  v6 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 16);
  v7 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 24);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + *(_QWORD *)(v6 - 24)) = v7;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v9 = v5[4];
  v10 = v5[5];
  *(_QWORD *)(a1 + 16) = v9;
  *(_QWORD *)(v4 + *(_QWORD *)(v9 - 24)) = v10;
  v11 = v5[1];
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + *(_QWORD *)(v11 - 24)) = v5[6];
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 128) = v3;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 24) = MEMORY[0x24BEDB848] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_20BDDBE6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::iostream::~basic_iostream();
  MEMORY[0x212B92EB0](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDDBE98(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = MEMORY[0x24BEDB7F0];
  v3 = *MEMORY[0x24BEDB7F0];
  *(_QWORD *)a1 = *MEMORY[0x24BEDB7F0];
  v4 = *(_QWORD *)(v2 + 72);
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 64);
  *(_QWORD *)(a1 + 24) = MEMORY[0x24BEDB848] + 16;
  *(_QWORD *)(a1 + 16) = v4;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x212B92EB0](a1 + 128);
  return a1;
}

_QWORD *sub_20BDDBF20(_QWORD *a1, __int128 *a2)
{
  _QWORD *v3;
  __int128 v4;

  v3 = a1 + 1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_20BDDBFAC(v3, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    v3[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)v3 = v4;
  }
  *a1 = off_24C516968;
  return a1;
}

void sub_20BDDBF7C(std::exception *a1)
{
  std::exception *v1;

  v1 = sub_20BDDC194(a1);
  operator delete(v1);
}

uint64_t sub_20BDDBF90(uint64_t a1)
{
  uint64_t result;

  result = a1 + 8;
  if (*(char *)(a1 + 31) < 0)
    return *(_QWORD *)result;
  return result;
}

void *sub_20BDDBFAC(_BYTE *__dst, void *__src, unint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8)
      sub_20BDDC038();
    v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17)
      v6 = a3 | 7;
    v7 = v6 + 1;
    v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    *v5 = v8;
    v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, a3 + 1);
}

void sub_20BDDC038()
{
  sub_20BDDC04C("basic_string");
}

void sub_20BDDC04C(const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_20BDCAFB8(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24C514D60, MEMORY[0x24BEDAAF0]);
}

void sub_20BDDC088(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDDC09C(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  char *v4;
  char *v5;
  char *v6;

  v3 = a1 + 1;
  v6 = *(char **)(a2 + 8);
  v4 = (char *)(a2 + 8);
  v5 = v6;
  if (v4[23] < 0)
    v4 = v5;
  sub_20BDDC0E4(v3, v4);
  *a1 = off_24C516968;
  return a1;
}

_QWORD *sub_20BDDC0E4(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    sub_20BDDC038();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

std::exception *sub_20BDDC194(std::exception *a1)
{
  uint64_t v2;

  std::exception::~exception(a1);
  if (*(char *)(v2 + 31) < 0)
    operator delete(a1[1].__vftable);
  return a1;
}

_QWORD *sub_20BDDC1C8(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x212B92B68](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x24BEDB350]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!sub_20BDDC32C(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x212B92B74](v13);
  return a1;
}

void sub_20BDDC2D0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  MEMORY[0x212B92B74](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x20BDDC2B0);
}

void sub_20BDDC318(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_20BDDC32C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      sub_20BDDC468(__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_20BDDC44C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDDC468(_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    sub_20BDDC038();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

unsigned __int8 *Alembic::Util::v12::SpookyHash::Short(unsigned __int8 *this, unint64_t a2, uint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;

  v5 = a2 & 0x1F;
  v6 = *a3;
  v7 = *a4;
  if (a2 < 0x10)
  {
    v10 = 0xDEADBEEFDEADBEEFLL;
    v9 = 0xDEADBEEFDEADBEEFLL;
  }
  else
  {
    if (((a2 >> 3) & 0x1FFFFFFFFFFFFFFCLL) != 0)
    {
      v8 = (unint64_t)&this[8 * ((a2 >> 3) & 0x1FFFFFFFFFFFFFFCLL)];
      v9 = 0xDEADBEEFDEADBEEFLL;
      v10 = 0xDEADBEEFDEADBEEFLL;
      do
      {
        v11 = *((_QWORD *)this + 1) + v9;
        v12 = v11 + __ROR8__(*(_QWORD *)this + v10, 14);
        v13 = v12 ^ v6;
        v14 = v13 + __ROR8__(v11, 12);
        v15 = v14 ^ v7;
        v16 = v15 + __ROR8__(v13, 34);
        v17 = v16 ^ v12;
        v18 = v17 + __ROR8__(v15, 23);
        v19 = v18 ^ v14;
        v20 = v19 + __ROR8__(v17, 10);
        v21 = v20 ^ v16;
        v22 = v21 + __ROR8__(v19, 16);
        v23 = v22 ^ v18;
        v24 = v23 + __ROR8__(v21, 26);
        v25 = v24 ^ v20;
        v26 = v25 + __ROR8__(v23, 27);
        v27 = v26 ^ v22;
        v28 = v27 + __ROR8__(v25, 2);
        v29 = v28 ^ v24;
        v30 = v29 + __ROR8__(v27, 30);
        v31 = v30 ^ v26;
        v32 = v31 + __ROR8__(v29, 59);
        v10 = v32 ^ v28;
        v33 = __ROR8__(v31, 28);
        v6 = v32 + *((_QWORD *)this + 2);
        v9 = (v10 + v33) ^ v30;
        v7 = v10 + v33 + *((_QWORD *)this + 3);
        this += 32;
      }
      while ((unint64_t)this < v8);
    }
    else
    {
      v10 = 0xDEADBEEFDEADBEEFLL;
      v9 = 0xDEADBEEFDEADBEEFLL;
    }
    v34 = v5 - 16;
    if (v5 >= 0x10)
    {
      v35 = *(_QWORD *)this;
      v36 = *((_QWORD *)this + 1);
      this += 16;
      v37 = v36 + v9;
      v38 = v37 + __ROR8__(v35 + v10, 14);
      v39 = v38 ^ v6;
      v40 = v39 + __ROR8__(v37, 12);
      v41 = v40 ^ v7;
      v42 = v41 + __ROR8__(v39, 34);
      v43 = v42 ^ v38;
      v44 = v43 + __ROR8__(v41, 23);
      v45 = v44 ^ v40;
      v46 = v45 + __ROR8__(v43, 10);
      v47 = v46 ^ v42;
      v48 = v47 + __ROR8__(v45, 16);
      v49 = v48 ^ v44;
      v50 = v49 + __ROR8__(v47, 26);
      v51 = v50 ^ v46;
      v52 = v51 + __ROR8__(v49, 27);
      v53 = v52 ^ v48;
      v54 = v53 + __ROR8__(v51, 2);
      v55 = v54 ^ v50;
      v56 = v55 + __ROR8__(v53, 30);
      v57 = v56 ^ v52;
      v6 = v57 + __ROR8__(v55, 59);
      v10 = v6 ^ v54;
      v7 = v10 + __ROR8__(v57, 28);
      v9 = v7 ^ v56;
      v5 = v34;
    }
  }
  v58 = v9 + (a2 << 56);
  switch(v5)
  {
    case 0uLL:
      v10 -= 0x2152411021524111;
      v58 -= 0x2152411021524111;
      break;
    case 1uLL:
      goto LABEL_14;
    case 2uLL:
      goto LABEL_13;
    case 3uLL:
      v10 += (unint64_t)this[2] << 16;
LABEL_13:
      v10 += (unint64_t)this[1] << 8;
LABEL_14:
      v59 = *this;
      goto LABEL_19;
    case 4uLL:
      goto LABEL_18;
    case 5uLL:
      goto LABEL_17;
    case 6uLL:
      goto LABEL_16;
    case 7uLL:
      v10 += (unint64_t)this[6] << 48;
LABEL_16:
      v10 += (unint64_t)this[5] << 40;
LABEL_17:
      v10 += (unint64_t)this[4] << 32;
LABEL_18:
      v59 = *(unsigned int *)this;
LABEL_19:
      v10 += v59;
      break;
    case 8uLL:
      goto LABEL_28;
    case 9uLL:
      goto LABEL_22;
    case 0xAuLL:
      goto LABEL_21;
    case 0xBuLL:
      v58 += (unint64_t)this[10] << 16;
LABEL_21:
      v58 += (unint64_t)this[9] << 8;
LABEL_22:
      v60 = this[8];
      goto LABEL_27;
    case 0xCuLL:
      goto LABEL_26;
    case 0xDuLL:
      goto LABEL_25;
    case 0xEuLL:
      goto LABEL_24;
    case 0xFuLL:
      v58 += (unint64_t)this[14] << 48;
LABEL_24:
      v58 += (unint64_t)this[13] << 40;
LABEL_25:
      v58 += (unint64_t)this[12] << 32;
LABEL_26:
      v60 = *((unsigned int *)this + 2);
LABEL_27:
      v58 += v60;
LABEL_28:
      v10 += *(_QWORD *)this;
      break;
    default:
      break;
  }
  v61 = (v58 ^ v10) + __ROR8__(v10, 49);
  v62 = (v61 ^ v6) + __ROR8__(v61, 12);
  v63 = (v62 ^ v7) + __ROR8__(v62, 38);
  v64 = (v63 ^ __ROR8__(v10, 49)) + __ROR8__(v63, 13);
  v65 = (v64 ^ __ROR8__(v61, 12)) + __ROR8__(v64, 36);
  v66 = (v65 ^ __ROR8__(v62, 38)) + __ROR8__(v65, 55);
  v67 = (v66 ^ __ROR8__(v63, 13)) + __ROR8__(v66, 17);
  v68 = (v67 ^ __ROR8__(v64, 36)) + __ROR8__(v67, 10);
  v69 = (v68 ^ __ROR8__(v65, 55)) + __ROR8__(v68, 32);
  v70 = (v69 ^ __ROR8__(v66, 17)) + __ROR8__(v69, 39);
  v71 = v70 ^ __ROR8__(v67, 10);
  v72 = __ROR8__(v70, 1);
  *a3 = v72;
  *a4 = v71 + v72;
  return this;
}

unsigned __int8 *Alembic::Util::v12::SpookyHash::Hash128(Alembic::Util::v12::SpookyHash *this, unint64_t a2, uint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  unsigned __int8 *result;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  Alembic::Util::v12::SpookyHash *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v90;
  uint64_t __dst;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;

  v103 = *MEMORY[0x24BDAC8D0];
  if (a2 <= 0xBF)
    return Alembic::Util::v12::SpookyHash::Short((unsigned __int8 *)this, a2, a3, a4, a5);
  v6 = 0xDEADBEEFDEADBEEFLL;
  v7 = *a3;
  v8 = *a4;
  v9 = (Alembic::Util::v12::SpookyHash *)((char *)this + 96 * (a2 / 0x60));
  if ((uint64_t)(96 * (a2 / 0x60)) < 1)
  {
    v18 = *a3;
    v17 = *a4;
    v16 = 0xDEADBEEFDEADBEEFLL;
    v15 = *a3;
    v14 = *a4;
    v13 = 0xDEADBEEFDEADBEEFLL;
    v12 = *a3;
    v11 = *a4;
    v10 = 0xDEADBEEFDEADBEEFLL;
  }
  else
  {
    v10 = 0xDEADBEEFDEADBEEFLL;
    v11 = *a4;
    v12 = *a3;
    v13 = 0xDEADBEEFDEADBEEFLL;
    v14 = *a4;
    v15 = *a3;
    v16 = 0xDEADBEEFDEADBEEFLL;
    v17 = *a4;
    v18 = *a3;
    do
    {
      v19 = *(_QWORD *)this + v18;
      v20 = (v19 ^ v6) + v17;
      v21 = *((_QWORD *)this + 1) + v17;
      v22 = (v21 ^ __ROR8__(v19, 53)) + (v8 ^ v16);
      v23 = *((_QWORD *)this + 2) + (v8 ^ v16);
      v24 = (v23 ^ __ROR8__(v21, 32)) + (v20 ^ v15);
      v25 = (v20 ^ v15) + *((_QWORD *)this + 3);
      v16 = (v25 ^ __ROR8__(v23, 21)) + (v22 ^ v14);
      v26 = (v22 ^ v14) + *((_QWORD *)this + 4);
      v15 = (v26 ^ __ROR8__(v25, 33)) + (v24 ^ v13);
      v27 = (v24 ^ v13) + *((_QWORD *)this + 5);
      v14 = (v27 ^ __ROR8__(v26, 47)) + (v16 ^ v12);
      v28 = (v16 ^ v12) + *((_QWORD *)this + 6);
      v13 = (v28 ^ __ROR8__(v27, 36)) + (v15 ^ v11);
      v29 = (v15 ^ v11) + *((_QWORD *)this + 7);
      v12 = (v29 ^ __ROR8__(v28, 25)) + (v14 ^ v10);
      v30 = (v14 ^ v10) + *((_QWORD *)this + 8);
      v11 = (v30 ^ __ROR8__(v29, 7)) + (v13 ^ v7);
      v31 = (v13 ^ v7) + *((_QWORD *)this + 9);
      v10 = (v31 ^ __ROR8__(v30, 9)) + (v12 ^ v8);
      v32 = (v12 ^ v8) + *((_QWORD *)this + 10);
      v33 = v11 ^ v20;
      v18 = v10 ^ v22;
      v7 = (v32 ^ __ROR8__(v31, 10)) + v33;
      v34 = v33 + *((_QWORD *)this + 11);
      v17 = v7 ^ v24;
      v6 = __ROR8__(v34, 18);
      v8 = (v34 ^ __ROR8__(v32, 42)) + v18;
      this = (Alembic::Util::v12::SpookyHash *)((char *)this + 96);
    }
    while (this < v9);
  }
  v86 = v8;
  v87 = v6;
  v90 = a2 % 0x60;
  memcpy(&__dst, v9, a2 % 0x60);
  bzero((char *)&__dst + v90, 96 - v90);
  HIBYTE(v102) = v90;
  v35 = v92 + v17 + v87 + v102;
  v36 = __dst + v18 + (v35 ^ (v93 + v16));
  v37 = (v36 ^ (v94 + v15)) + __ROR8__(v92 + v17, 20);
  v38 = (v37 ^ (v95 + v14)) + __ROR8__(v35 ^ (v93 + v16), 49);
  v39 = (v38 ^ (v96 + v13)) + __ROR8__(v36 ^ (v94 + v15), 30);
  v40 = (v39 ^ (v97 + v12)) + __ROR8__(v37 ^ (v95 + v14), 43);
  v41 = (v40 ^ (v98 + v11)) + __ROR8__(v38 ^ (v96 + v13), 26);
  v42 = (v41 ^ (v99 + v10)) + __ROR8__(v39 ^ (v97 + v12), 31);
  v43 = (v42 ^ (v100 + v7)) + __ROR8__(v40 ^ (v98 + v11), 54);
  v44 = (v43 ^ (v101 + v86)) + __ROR8__(v41 ^ (v99 + v10), 51);
  v45 = v44 ^ v35;
  v46 = v45 + __ROR8__(v42 ^ (v100 + v7), 26);
  v47 = v46 ^ v36;
  v48 = v47 + __ROR8__(v43 ^ (v101 + v86), 11);
  v49 = v48 ^ v37;
  v50 = v49 + __ROR8__(v45, 22);
  v51 = v50 ^ v38;
  v52 = v51 + __ROR8__(v47, 10);
  v53 = v52 ^ v39;
  v54 = v53 + __ROR8__(v49, 20);
  v55 = v54 ^ v40;
  v56 = v55 + __ROR8__(v51, 49);
  v57 = v56 ^ v41;
  v58 = v57 + __ROR8__(v53, 30);
  v59 = v58 ^ v42;
  v60 = v59 + __ROR8__(v55, 43);
  v61 = v60 ^ v43;
  v62 = v61 + __ROR8__(v57, 26);
  v63 = v62 ^ v44;
  v64 = v63 + __ROR8__(v59, 31);
  v65 = v64 ^ v46;
  v66 = v65 + __ROR8__(v61, 54);
  v67 = v66 ^ v48;
  v68 = v67 + __ROR8__(v63, 51);
  v69 = v68 ^ v50;
  v70 = v69 + __ROR8__(v65, 26);
  v71 = v70 ^ v52;
  result = (unsigned __int8 *)(v71 + __ROR8__(v67, 11));
  v72 = (unint64_t)result ^ v54;
  v73 = v72 + __ROR8__(v69, 22);
  v74 = v73 ^ v56;
  v75 = v74 + __ROR8__(v71, 10);
  v76 = v75 ^ v58;
  v77 = v76 + __ROR8__(v72, 20);
  v78 = v77 ^ v60;
  v79 = (v78 + __ROR8__(v74, 49)) ^ v62;
  v80 = (v79 + __ROR8__(v76, 30)) ^ v64;
  v81 = (v80 + __ROR8__(v78, 43)) ^ v66;
  v82 = (v81 + __ROR8__(v79, 26)) ^ v68;
  v83 = (v82 + __ROR8__(v80, 31)) ^ v70;
  v84 = (v83 + __ROR8__(v81, 54)) ^ (unint64_t)result;
  v85 = (((v84 + __ROR8__(v82, 51)) ^ v73) + __ROR8__(v83, 26)) ^ v75;
  *a3 = __ROR8__(v85, 10);
  *a4 = (v85 + __ROR8__(v84, 11)) ^ v77;
  return result;
}

uint64_t Alembic::Util::v12::SpookyHash::Init(uint64_t this, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(this + 288) = 0;
  *(_BYTE *)(this + 296) = 0;
  *(_QWORD *)(this + 192) = a2;
  *(_QWORD *)(this + 200) = a3;
  return this;
}

void *Alembic::Util::v12::SpookyHash::Update(Alembic::Util::v12::SpookyHash *this, _QWORD *__src, size_t __n)
{
  size_t v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  Alembic::Util::v12::SpookyHash *v7;
  void *result;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  _QWORD *v72;
  size_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  Alembic::Util::v12::SpookyHash *v90;
  unsigned __int8 v91;
  size_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  Alembic::Util::v12::SpookyHash *__dst;

  v3 = __n;
  v4 = __src;
  v5 = *((unsigned __int8 *)this + 296);
  v6 = v5 + __n;
  if (v5 + __n > 0xBF)
  {
    v10 = *((_QWORD *)this + 36);
    v12 = *((_QWORD *)this + 24);
    v11 = *((_QWORD *)this + 25);
    if (v10 >= 0xC0)
    {
      v13 = *((_QWORD *)this + 26);
      v14 = *((_QWORD *)this + 27);
      v15 = *((_QWORD *)this + 28);
      v16 = *((_QWORD *)this + 29);
      v17 = *((_QWORD *)this + 30);
      v18 = *((_QWORD *)this + 31);
      v19 = *((_QWORD *)this + 32);
      v20 = *((_QWORD *)this + 33);
      v21 = *((_QWORD *)this + 34);
      v22 = *((_QWORD *)this + 35);
    }
    else
    {
      v13 = 0xDEADBEEFDEADBEEFLL;
      v14 = *((_QWORD *)this + 24);
      v15 = *((_QWORD *)this + 25);
      v16 = 0xDEADBEEFDEADBEEFLL;
      v17 = v14;
      v18 = v15;
      v19 = 0xDEADBEEFDEADBEEFLL;
      v20 = v14;
      v21 = v15;
      v22 = 0xDEADBEEFDEADBEEFLL;
    }
    *((_QWORD *)this + 36) = v10 + v3;
    if ((_DWORD)v5)
    {
      v91 = -64 - v5;
      v92 = v3;
      v97 = v17;
      __dst = this;
      v93 = v13;
      v95 = v15;
      memcpy((char *)this + v5, __src, (-64 - v5));
      v23 = *(_QWORD *)__dst + v12;
      v24 = (v23 ^ v22) + v11;
      v25 = *((_QWORD *)__dst + 1) + v11;
      v26 = (v25 ^ __ROR8__(v23, 53)) + (v21 ^ v93);
      v27 = *((_QWORD *)__dst + 2) + (v21 ^ v93);
      v28 = (v27 ^ __ROR8__(v25, 32)) + (v24 ^ v14);
      v29 = (v24 ^ v14) + *((_QWORD *)__dst + 3);
      v30 = (v29 ^ __ROR8__(v27, 21)) + (v26 ^ v95);
      v31 = (v26 ^ v95) + *((_QWORD *)__dst + 4);
      v32 = (v31 ^ __ROR8__(v29, 33)) + (v28 ^ v16);
      v33 = (v28 ^ v16) + *((_QWORD *)__dst + 5);
      v34 = (v33 ^ __ROR8__(v31, 47)) + (v30 ^ v97);
      v35 = (v30 ^ v97) + *((_QWORD *)__dst + 6);
      v36 = (v35 ^ __ROR8__(v33, 36)) + (v32 ^ v18);
      v37 = (v32 ^ v18) + *((_QWORD *)__dst + 7);
      v38 = (v37 ^ __ROR8__(v35, 25)) + (v34 ^ v19);
      v39 = (v34 ^ v19) + *((_QWORD *)__dst + 8);
      v40 = (v39 ^ __ROR8__(v37, 7)) + (v36 ^ v20);
      v41 = (v36 ^ v20) + *((_QWORD *)__dst + 9);
      v42 = v40 ^ v24;
      v43 = (v41 ^ __ROR8__(v39, 9)) + (v38 ^ v21);
      v44 = (v38 ^ v21) + *((_QWORD *)__dst + 10);
      v45 = v43 ^ v26;
      v46 = (v44 ^ __ROR8__(v41, 10)) + v42;
      v47 = v42 + *((_QWORD *)__dst + 11);
      v48 = v46 ^ v28;
      v49 = (v47 ^ __ROR8__(v44, 42)) + v45;
      v50 = v45 + *((_QWORD *)__dst + 12);
      v51 = v49 ^ v30;
      v52 = (v50 ^ __ROR8__(v47, 18)) + (v46 ^ v28);
      v53 = v48 + *((_QWORD *)__dst + 13);
      v54 = v52 ^ v32;
      v55 = (v53 ^ __ROR8__(v50, 53)) + v51;
      v56 = v51 + *((_QWORD *)__dst + 14);
      v57 = v55 ^ v34;
      v58 = (v56 ^ __ROR8__(v53, 32)) + v54;
      v59 = v54 + *((_QWORD *)__dst + 15);
      v60 = v58 ^ v36;
      v13 = (v59 ^ __ROR8__(v56, 21)) + v57;
      v61 = v57 + *((_QWORD *)__dst + 16);
      v14 = (v61 ^ __ROR8__(v59, 33)) + v60;
      v62 = v60 + *((_QWORD *)__dst + 17);
      v15 = (v62 ^ __ROR8__(v61, 47)) + (v13 ^ v38);
      v63 = (v13 ^ v38) + *((_QWORD *)__dst + 18);
      v64 = v15 ^ v43;
      v16 = (v63 ^ __ROR8__(v62, 36)) + (v14 ^ v40);
      v65 = (v14 ^ v40) + *((_QWORD *)__dst + 19);
      v66 = v16 ^ v46;
      this = __dst;
      v17 = (v65 ^ __ROR8__(v63, 25)) + (v15 ^ v43);
      v67 = v64 + *((_QWORD *)__dst + 20);
      v18 = (v67 ^ __ROR8__(v65, 7)) + v66;
      v68 = v66 + *((_QWORD *)__dst + 21);
      v19 = (v68 ^ __ROR8__(v67, 9)) + (v17 ^ v49);
      v69 = (v17 ^ v49) + *((_QWORD *)__dst + 22);
      v70 = v18 ^ v52;
      v71 = v70 + *((_QWORD *)__dst + 23);
      v22 = __ROR8__(v71, 18);
      v12 = v19 ^ v55;
      v20 = (v69 ^ __ROR8__(v68, 10)) + v70;
      v11 = v20 ^ v58;
      v21 = (v71 ^ __ROR8__(v69, 42)) + (v19 ^ v55);
      v4 = (_QWORD *)((char *)v4 + v91);
      v3 = v92 - v91;
    }
    v72 = &v4[12 * (v3 / 0x60)];
    v73 = v3 + 160 * (v3 / 0x60);
    if ((uint64_t)(96 * (v3 / 0x60)) >= 1)
    {
      do
      {
        v74 = *v4 + v12;
        v75 = (v74 ^ v22) + v11;
        v76 = v4[1] + v11;
        v77 = (v76 ^ __ROR8__(v74, 53)) + (v21 ^ v13);
        v78 = v4[2] + (v21 ^ v13);
        v79 = (v78 ^ __ROR8__(v76, 32)) + (v75 ^ v14);
        v80 = (v75 ^ v14) + v4[3];
        v13 = (v80 ^ __ROR8__(v78, 21)) + (v77 ^ v15);
        v81 = (v77 ^ v15) + v4[4];
        v14 = (v81 ^ __ROR8__(v80, 33)) + (v79 ^ v16);
        v82 = (v79 ^ v16) + v4[5];
        v15 = (v82 ^ __ROR8__(v81, 47)) + (v13 ^ v17);
        v83 = (v13 ^ v17) + v4[6];
        v16 = (v83 ^ __ROR8__(v82, 36)) + (v14 ^ v18);
        v84 = (v14 ^ v18) + v4[7];
        v17 = (v84 ^ __ROR8__(v83, 25)) + (v15 ^ v19);
        v85 = (v15 ^ v19) + v4[8];
        v18 = (v85 ^ __ROR8__(v84, 7)) + (v16 ^ v20);
        v86 = (v16 ^ v20) + v4[9];
        v19 = (v86 ^ __ROR8__(v85, 9)) + (v17 ^ v21);
        v87 = (v17 ^ v21) + v4[10];
        v88 = v18 ^ v75;
        v12 = v19 ^ v77;
        v20 = (v87 ^ __ROR8__(v86, 10)) + v88;
        v89 = v88 + v4[11];
        v11 = v20 ^ v79;
        v22 = __ROR8__(v89, 18);
        v21 = (v89 ^ __ROR8__(v87, 42)) + v12;
        v4 += 12;
      }
      while (v4 < v72);
    }
    v94 = v13;
    v96 = v15;
    v98 = v17;
    *((_BYTE *)this + 296) = v73;
    v90 = this;
    result = memcpy(this, v72, v73);
    *((_QWORD *)v90 + 24) = v12;
    *((_QWORD *)v90 + 25) = v11;
    *((_QWORD *)v90 + 26) = v94;
    *((_QWORD *)v90 + 27) = v14;
    *((_QWORD *)v90 + 28) = v96;
    *((_QWORD *)v90 + 29) = v16;
    *((_QWORD *)v90 + 30) = v98;
    *((_QWORD *)v90 + 31) = v18;
    *((_QWORD *)v90 + 32) = v19;
    *((_QWORD *)v90 + 33) = v20;
    *((_QWORD *)v90 + 34) = v21;
    *((_QWORD *)v90 + 35) = v22;
  }
  else
  {
    v7 = this;
    result = memcpy((char *)this + v5, __src, __n);
    *((_QWORD *)v7 + 36) += __n;
    *((_BYTE *)v7 + 296) = v6;
  }
  return result;
}

unsigned __int8 *Alembic::Util::v12::SpookyHash::Final(Alembic::Util::v12::SpookyHash *this, unint64_t *a2, unint64_t *a3, uint64_t a4, unint64_t *a5)
{
  Alembic::Util::v12::SpookyHash *v7;
  unint64_t v8;
  unsigned __int8 *result;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t *v97;
  unint64_t *v98;

  v7 = this;
  v8 = *((_QWORD *)this + 36);
  if (v8 > 0xBF)
  {
    v10 = *((unsigned __int8 *)this + 296);
    v11 = *((_QWORD *)this + 24);
    v12 = *((_QWORD *)this + 25);
    v13 = *((_QWORD *)this + 28);
    v14 = *((_QWORD *)this + 29);
    v16 = *((_QWORD *)this + 30);
    v15 = *((_QWORD *)this + 31);
    v18 = *((_QWORD *)this + 32);
    v17 = *((_QWORD *)this + 33);
    v19 = *((_QWORD *)this + 34);
    v20 = *((_QWORD *)this + 35);
    v97 = a2;
    v98 = a3;
    if (v10 < 0x60)
    {
      v93 = *((_QWORD *)this + 34);
      v94 = *((_QWORD *)this + 27);
      v95 = *((_QWORD *)this + 28);
      v96 = *((_QWORD *)this + 26);
    }
    else
    {
      v21 = *(_QWORD *)this + v11;
      v22 = v19 ^ *((_QWORD *)this + 26);
      v23 = (v21 ^ v20) + v12;
      v24 = *((_QWORD *)this + 1) + v12;
      v25 = v23 ^ *((_QWORD *)this + 27);
      v26 = (v24 ^ __ROR8__(v21, 53)) + v22;
      v27 = *((_QWORD *)this + 2) + v22;
      v28 = (v27 ^ __ROR8__(v24, 32)) + v25;
      v29 = v25 + *((_QWORD *)this + 3);
      v30 = (v29 ^ __ROR8__(v27, 21)) + (v26 ^ v13);
      v31 = (v26 ^ v13) + *((_QWORD *)this + 4);
      v96 = v30;
      v32 = __ROR8__(v29, 33);
      v33 = (v28 ^ v14) + *((_QWORD *)this + 5);
      v94 = (v31 ^ v32) + (v28 ^ v14);
      v34 = __ROR8__(v31, 47);
      v35 = (v30 ^ v16) + *((_QWORD *)this + 6);
      v95 = (v33 ^ v34) + (v30 ^ v16);
      v14 = (v35 ^ __ROR8__(v33, 36)) + (v94 ^ v15);
      v36 = (v94 ^ v15) + *((_QWORD *)this + 7);
      v16 = (v36 ^ __ROR8__(v35, 25)) + (v95 ^ v18);
      v37 = (v95 ^ v18) + *((_QWORD *)this + 8);
      v15 = (v37 ^ __ROR8__(v36, 7)) + (v14 ^ v17);
      v38 = (v14 ^ v17) + *((_QWORD *)this + 9);
      v18 = (v38 ^ __ROR8__(v37, 9)) + (v16 ^ v19);
      v39 = *((_QWORD *)this + 11);
      v40 = (v16 ^ v19) + *((_QWORD *)this + 10);
      v41 = v15 ^ v23;
      v11 = v18 ^ v26;
      v17 = (v40 ^ __ROR8__(v38, 10)) + v41;
      v12 = v17 ^ v28;
      v20 = __ROR8__(v41 + v39, 18);
      v93 = ((v41 + v39) ^ __ROR8__(v40, 42)) + (v18 ^ v26);
      v7 = (Alembic::Util::v12::SpookyHash *)((char *)this + 96);
      LOBYTE(v10) = v10 - 96;
    }
    bzero((char *)v7 + v10, 96 - v10);
    *((_BYTE *)v7 + 95) = v10;
    v42 = *((_QWORD *)v7 + 1) + v12 + v20 + *((_QWORD *)v7 + 11);
    v43 = *(_QWORD *)v7 + v11 + (v42 ^ (*((_QWORD *)v7 + 2) + v96));
    v44 = (v43 ^ (*((_QWORD *)v7 + 3) + v94)) + __ROR8__(*((_QWORD *)v7 + 1) + v12, 20);
    v45 = (v44 ^ (*((_QWORD *)v7 + 4) + v95)) + __ROR8__(v42 ^ (*((_QWORD *)v7 + 2) + v96), 49);
    v46 = (v45 ^ (*((_QWORD *)v7 + 5) + v14)) + __ROR8__(v43 ^ (*((_QWORD *)v7 + 3) + v94), 30);
    v47 = (v46 ^ (*((_QWORD *)v7 + 6) + v16)) + __ROR8__(v44 ^ (*((_QWORD *)v7 + 4) + v95), 43);
    v48 = (v47 ^ (*((_QWORD *)v7 + 7) + v15)) + __ROR8__(v45 ^ (*((_QWORD *)v7 + 5) + v14), 26);
    v49 = (v48 ^ (*((_QWORD *)v7 + 8) + v18)) + __ROR8__(v46 ^ (*((_QWORD *)v7 + 6) + v16), 31);
    v50 = (v49 ^ (*((_QWORD *)v7 + 9) + v17)) + __ROR8__(v47 ^ (*((_QWORD *)v7 + 7) + v15), 54);
    v51 = (v50 ^ (*((_QWORD *)v7 + 10) + v93)) + __ROR8__(v48 ^ (*((_QWORD *)v7 + 8) + v18), 51);
    v52 = v51 ^ v42;
    v53 = v52 + __ROR8__(v49 ^ (*((_QWORD *)v7 + 9) + v17), 26);
    v54 = v53 ^ v43;
    v55 = v54 + __ROR8__(v50 ^ (*((_QWORD *)v7 + 10) + v93), 11);
    v56 = v55 ^ v44;
    v57 = v56 + __ROR8__(v52, 22);
    v58 = v57 ^ v45;
    v59 = v58 + __ROR8__(v54, 10);
    v60 = v59 ^ v46;
    v61 = v60 + __ROR8__(v56, 20);
    v62 = v61 ^ v47;
    v63 = v62 + __ROR8__(v58, 49);
    v64 = v63 ^ v48;
    v65 = v64 + __ROR8__(v60, 30);
    v66 = v65 ^ v49;
    v67 = v66 + __ROR8__(v62, 43);
    v68 = v67 ^ v50;
    v69 = v68 + __ROR8__(v64, 26);
    v70 = v69 ^ v51;
    v71 = v70 + __ROR8__(v66, 31);
    v72 = v71 ^ v53;
    v73 = v72 + __ROR8__(v68, 54);
    v74 = v73 ^ v55;
    v75 = v74 + __ROR8__(v70, 51);
    v76 = v75 ^ v57;
    v77 = v76 + __ROR8__(v72, 26);
    v78 = v77 ^ v59;
    result = (unsigned __int8 *)(v78 + __ROR8__(v74, 11));
    v79 = (unint64_t)result ^ v61;
    v80 = v79 + __ROR8__(v76, 22);
    v81 = v80 ^ v63;
    v82 = v81 + __ROR8__(v78, 10);
    v83 = v82 ^ v65;
    v84 = v83 + __ROR8__(v79, 20);
    v85 = v84 ^ v67;
    v86 = (v85 + __ROR8__(v81, 49)) ^ v69;
    v87 = (v86 + __ROR8__(v83, 30)) ^ v71;
    v88 = (v87 + __ROR8__(v85, 43)) ^ v73;
    v89 = (v88 + __ROR8__(v86, 26)) ^ v75;
    v90 = (v89 + __ROR8__(v87, 31)) ^ v77;
    v91 = (v90 + __ROR8__(v88, 54)) ^ (unint64_t)result;
    v92 = (((v91 + __ROR8__(v89, 51)) ^ v80) + __ROR8__(v90, 26)) ^ v82;
    *v97 = __ROR8__(v92, 10);
    *v98 = (v92 + __ROR8__(v91, 11)) ^ v84;
  }
  else
  {
    *a2 = *((_QWORD *)this + 24);
    *a3 = *((_QWORD *)this + 25);
    return Alembic::Util::v12::SpookyHash::Short((unsigned __int8 *)this, v8, (uint64_t *)a2, a3, a5);
  }
  return result;
}

void Alembic::Util::v12::TokenMap::set(uint64_t **a1, std::string *this, std::string::value_type __c, std::string::value_type a4)
{
  std::string::size_type v8;
  std::string::size_type v9;
  std::string::size_type v10;
  std::string::size_type v11;
  std::string::size_type v12;
  _OWORD *v13;
  void **v14;
  std::string __p;
  std::string v16;
  std::string *p_p;

  v8 = 0;
  do
  {
    v9 = std::string::find(this, __c, v8);
    v10 = std::string::find(this, a4, v8);
    if (v10 != -1)
    {
      v11 = v10;
      if (v9 == -1)
        v12 = -1;
      else
        v12 = v9 + ~v10;
      std::string::basic_string(&v16, this, v10 + 1, v12, (std::allocator<char> *)&__p);
      std::string::basic_string(&__p, this, v8, v11 - v8, (std::allocator<char> *)&p_p);
      p_p = &__p;
      v13 = sub_20BDDE428(a1, (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&unk_20CA4E6B7, (_OWORD **)&p_p);
      v14 = (void **)v13 + 7;
      if (*((char *)v13 + 79) < 0)
        operator delete(*v14);
      *(std::string *)v14 = v16;
      *((_BYTE *)&v16.__r_.__value_.__s + 23) = 0;
      v16.__r_.__value_.__s.__data_[0] = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v16.__r_.__value_.__l.__data_);
      }
    }
    v8 = v9 + 1;
  }
  while (v9 != -1);
}

void sub_20BDDD6E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void Alembic::Util::v12::TokenMap::setUnique(uint64_t **a1, std::string *this, std::string::value_type __c, std::string::value_type a4, char a5)
{
  std::string::size_type v10;
  std::string::size_type v11;
  std::string::size_type v12;
  std::string::size_type v13;
  std::string::size_type v14;
  uint64_t *v15;
  void **v16;
  _QWORD *v17;
  std::string *v18;
  std::string::size_type size;
  _QWORD *v20;
  _QWORD *exception;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  __int128 __p;
  char v29;
  std::string v30;
  __int128 *v31[4];
  std::string v32;

  v10 = 0;
  while (1)
  {
    v11 = std::string::find(this, __c, v10);
    v12 = std::string::find(this, a4, v10);
    if (v12 > v11)
      break;
    v13 = v12;
    if (v12 != -1)
    {
      if (v11 == -1)
        v14 = -1;
      else
        v14 = v11 + ~v12;
      std::string::basic_string(&v30, this, v10, v12 - v10, (std::allocator<char> *)&v32);
      if (sub_20BDDDEF8((uint64_t)a1, (const void **)&v30.__r_.__value_.__l.__data_))
      {
        if ((a5 & 1) == 0)
        {
          sub_20BDDBD68((uint64_t)&v32);
          v17 = sub_20BDDC1C8(&v32.__r_.__value_.__r.__words[2], (uint64_t)"TokenMap::setUnique: token: ", 28);
          if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v18 = &v30;
          else
            v18 = (std::string *)v30.__r_.__value_.__r.__words[0];
          if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(v30.__r_.__value_.__r.__words[2]);
          else
            size = v30.__r_.__value_.__l.__size_;
          v20 = sub_20BDDC1C8(v17, (uint64_t)v18, size);
          sub_20BDDC1C8(v20, (uint64_t)" is not unique.", 15);
          std::stringbuf::str();
          sub_20BDDBF20(v31, &__p);
          if (v29 < 0)
            operator delete((void *)__p);
          exception = __cxa_allocate_exception(0x20uLL);
          v22 = sub_20BDDC09C(exception, (uint64_t)v31);
          __cxa_throw(v22, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
        }
      }
      else
      {
        std::string::basic_string(&v32, this, v13 + 1, v14, (std::allocator<char> *)v31);
        v31[0] = (__int128 *)&v30;
        v15 = sub_20BDDDFDC(a1, (const void **)&v30.__r_.__value_.__l.__data_, (uint64_t)&unk_20CA4E6B7, v31);
        v16 = (void **)(v15 + 7);
        if (*((char *)v15 + 79) < 0)
          operator delete(*v16);
        *(std::string *)v16 = v32;
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }
    v10 = v11 + 1;
    if (v11 == -1)
      return;
  }
  if ((a5 & 1) == 0)
  {
    sub_20BDDBD68((uint64_t)&v32);
    v23 = sub_20BDDC1C8(&v32.__r_.__value_.__r.__words[2], (uint64_t)"TokenMap::setUnique: malformed string found:", 44);
    LOBYTE(v31[0]) = a4;
    v24 = sub_20BDDC1C8(v23, (uint64_t)v31, 1);
    v25 = sub_20BDDC1C8(v24, (uint64_t)" before: ", 9);
    LOBYTE(v31[0]) = __c;
    sub_20BDDC1C8(v25, (uint64_t)v31, 1);
    std::stringbuf::str();
    sub_20BDDBF20(v31, (__int128 *)&v30);
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v30.__r_.__value_.__l.__data_);
    v26 = __cxa_allocate_exception(0x20uLL);
    v27 = sub_20BDDC09C(v26, (uint64_t)v31);
    __cxa_throw(v27, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
}

void sub_20BDDD9B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, std::exception a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  sub_20BDDC194(&a18);
  sub_20BDDBE98((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void Alembic::Util::v12::TokenMap::get(Alembic::Util::v12::TokenMap *this, unsigned __int8 a2, std::string::value_type a3, int a4)
{
  char *v8;
  _QWORD *v9;
  char *v10;
  char v11;
  void **v12;
  uint64_t v13;
  std::string *v14;
  std::string::size_type v15;
  _QWORD *v16;
  void **v17;
  uint64_t v18;
  _QWORD *v19;
  std::string *v20;
  std::string::size_type v21;
  char *v22;
  char *v23;
  BOOL v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void **v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  void **v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  std::string *p_dst;
  std::string::size_type size;
  _QWORD *v38;
  _QWORD *v39;
  std::string *v40;
  std::string::size_type v41;
  _QWORD *exception;
  _QWORD *v43;
  __int128 v44;
  char v45;
  _QWORD v46[4];
  char v47[16];
  uint64_t v48[33];
  std::string v49;
  std::string __dst;
  _QWORD v51[2];
  _QWORD v52[11];
  char v53;
  uint64_t v54;
  void **v55;
  uint64_t v56;
  unsigned __int8 v57;
  void **v58;
  uint64_t v59;
  unsigned __int8 v60;
  char __s[10];

  *(_WORD *)__s = a2;
  sub_20BDDC0E4(&v58, __s);
  __s[0] = a3;
  sub_20BDDC0E4(&v55, __s);
  sub_20BDDBD68((uint64_t)v51);
  v10 = *(char **)this;
  v8 = (char *)this + 8;
  v9 = v10;
  if (v10 != v8)
  {
    v11 = 1;
    while (1)
    {
      if (*((char *)v9 + 55) < 0)
        sub_20BDDBFAC(&__dst, (void *)v9[4], v9[5]);
      else
        __dst = *(std::string *)(v9 + 4);
      if (*((char *)v9 + 79) < 0)
        sub_20BDDBFAC(&v49, (void *)v9[7], v9[8]);
      else
        v49 = *(std::string *)(v9 + 7);
      if (a4
        && (std::string::find(&__dst, a2, 0) != -1
         || std::string::find(&__dst, a3, 0) != -1
         || std::string::find(&v49, a2, 0) != -1
         || std::string::find(&v49, a3, 0) != -1))
      {
        sub_20BDDBD68((uint64_t)v47);
        v26 = sub_20BDDC1C8(v48, (uint64_t)"TokenMap::get: Token-Value pair ", 32);
        v27 = sub_20BDDC1C8(v26, (uint64_t)" contains separator characters: ", 32);
        if ((v60 & 0x80u) == 0)
          v28 = (void **)&v58;
        else
          v28 = v58;
        if ((v60 & 0x80u) == 0)
          v29 = v60;
        else
          v29 = v59;
        v30 = sub_20BDDC1C8(v27, (uint64_t)v28, v29);
        v31 = sub_20BDDC1C8(v30, (uint64_t)" or ", 4);
        if ((v57 & 0x80u) == 0)
          v32 = (void **)&v55;
        else
          v32 = v55;
        if ((v57 & 0x80u) == 0)
          v33 = v57;
        else
          v33 = v56;
        v34 = sub_20BDDC1C8(v31, (uint64_t)v32, v33);
        v35 = sub_20BDDC1C8(v34, (uint64_t)" for ", 5);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_dst = &__dst;
        else
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        else
          size = __dst.__r_.__value_.__l.__size_;
        v38 = sub_20BDDC1C8(v35, (uint64_t)p_dst, size);
        v39 = sub_20BDDC1C8(v38, (uint64_t)" or ", 4);
        if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v40 = &v49;
        else
          v40 = (std::string *)v49.__r_.__value_.__r.__words[0];
        if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v41 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
        else
          v41 = v49.__r_.__value_.__l.__size_;
        sub_20BDDC1C8(v39, (uint64_t)v40, v41);
        std::stringbuf::str();
        sub_20BDDBF20(v46, &v44);
        if (v45 < 0)
          operator delete((void *)v44);
        exception = __cxa_allocate_exception(0x20uLL);
        v43 = sub_20BDDC09C(exception, (uint64_t)v46);
        __cxa_throw(v43, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
      }
      if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        break;
      if (v49.__r_.__value_.__l.__size_)
        goto LABEL_18;
LABEL_45:
      operator delete(v49.__r_.__value_.__l.__data_);
LABEL_46:
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__dst.__r_.__value_.__l.__data_);
      v22 = (char *)v9[1];
      if (v22)
      {
        do
        {
          v23 = v22;
          v22 = *(char **)v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          v23 = (char *)v9[2];
          v24 = *(_QWORD *)v23 == (_QWORD)v9;
          v9 = v23;
        }
        while (!v24);
      }
      v9 = v23;
      if (v23 == v8)
        goto LABEL_54;
    }
    if (!*((_BYTE *)&v49.__r_.__value_.__s + 23))
      goto LABEL_46;
LABEL_18:
    if ((v11 & 1) == 0)
    {
      if ((v60 & 0x80u) == 0)
        v12 = (void **)&v58;
      else
        v12 = v58;
      if ((v60 & 0x80u) == 0)
        v13 = v60;
      else
        v13 = v59;
      sub_20BDDC1C8(v52, (uint64_t)v12, v13);
    }
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v14 = &__dst;
    else
      v14 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    else
      v15 = __dst.__r_.__value_.__l.__size_;
    v16 = sub_20BDDC1C8(v52, (uint64_t)v14, v15);
    if ((v57 & 0x80u) == 0)
      v17 = (void **)&v55;
    else
      v17 = v55;
    if ((v57 & 0x80u) == 0)
      v18 = v57;
    else
      v18 = v56;
    v19 = sub_20BDDC1C8(v16, (uint64_t)v17, v18);
    if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v20 = &v49;
    else
      v20 = (std::string *)v49.__r_.__value_.__r.__words[0];
    if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v21 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
    else
      v21 = v49.__r_.__value_.__l.__size_;
    sub_20BDDC1C8(v19, (uint64_t)v20, v21);
    v11 = 0;
    if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_46;
    goto LABEL_45;
  }
LABEL_54:
  std::stringbuf::str();
  v51[0] = *MEMORY[0x24BEDB7F0];
  v25 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
  *(_QWORD *)((char *)v51 + *(_QWORD *)(v51[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
  v52[0] = v25;
  v52[1] = MEMORY[0x24BEDB848] + 16;
  if (v53 < 0)
    operator delete((void *)v52[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x212B92EB0](&v54);
  if ((char)v57 < 0)
    operator delete(v55);
  if ((char)v60 < 0)
    operator delete(v58);
}

void sub_20BDDDE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::exception a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58,uint64_t a59,void *a60,uint64_t a61,int a62,__int16 a63)
{
  char a65;
  char a66;
  uint64_t v66;

  sub_20BDDC194(&a14);
  sub_20BDDBE98((uint64_t)&a18);
  if (a58 < 0)
    operator delete(__p);
  if (a65 < 0)
    operator delete(a60);
  sub_20BDDBE98((uint64_t)&a66);
  if (*(char *)(v66 - 121) < 0)
    operator delete(*(void **)(v66 - 144));
  if (*(char *)(v66 - 97) < 0)
    operator delete(*(void **)(v66 - 120));
  _Unwind_Resume(a1);
}

uint64_t sub_20BDDDEF8(uint64_t a1, const void **a2)
{
  const void **v2;
  uint64_t v4;
  uint64_t v5;

  v2 = *(const void ***)(a1 + 8);
  if (v2)
  {
    v4 = a1 + 16;
    v5 = 1;
    do
    {
      if (!sub_20BDDDF74(v4, a2, v2 + 4))
      {
        if (!sub_20BDDDF74(v4, v2 + 4, a2))
          return v5;
        ++v2;
      }
      v2 = (const void **)*v2;
    }
    while (v2);
  }
  return 0;
}

BOOL sub_20BDDDF74(uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

uint64_t *sub_20BDDDFDC(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v6 = (uint64_t **)sub_20BDDE084((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    sub_20BDDE120((uint64_t)a1, a4, (uint64_t)v10);
    sub_20BDDE1B4(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    sub_20BDDE3A0((uint64_t)v10, 0);
  }
  return v7;
}

_QWORD *sub_20BDDE084(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!sub_20BDDDF74(v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!sub_20BDDDF74(v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

_BYTE *sub_20BDDE120@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _BYTE *result;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = operator new(0x50uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = v6 + 4;
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    result = sub_20BDDBFAC(result, *(void **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    v6[6] = *((_QWORD *)v8 + 2);
    *(_OWORD *)result = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  v6[9] = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_20BDDE19C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BDDE3A0(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t *sub_20BDDE1B4(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = sub_20BDDE208(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_20BDDE208(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void sub_20BDDE3A0(uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_20BDDE3E4((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

void sub_20BDDE3E4(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

_OWORD *sub_20BDDE428(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD v12[2];
  char v13;
  uint64_t v14;

  v6 = (void **)sub_20BDDE084((uint64_t)a1, &v14, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x50uLL);
    v12[1] = a1 + 1;
    v9 = *a4;
    v10 = *((_QWORD *)*a4 + 2);
    v7[2] = **a4;
    *((_QWORD *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    *v9 = 0;
    *((_QWORD *)v7 + 8) = 0;
    *((_QWORD *)v7 + 9) = 0;
    *((_QWORD *)v7 + 7) = 0;
    v13 = 1;
    sub_20BDDE1B4(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0;
    sub_20BDDE3A0((uint64_t)v12, 0);
  }
  return v7;
}

uint64_t Alembic::AbcCoreAbstract::v12::GetLibraryVersionShort(Alembic::AbcCoreAbstract::v12 *this)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD v4[11];
  char v5;
  uint64_t v6;

  sub_20BDDE5E0((uint64_t)v4);
  v1 = (_QWORD *)std::ostream::operator<<();
  sub_20BDDC1C8(v1, (uint64_t)".", 1);
  v2 = (_QWORD *)std::ostream::operator<<();
  sub_20BDDC1C8(v2, (uint64_t)".", 1);
  std::ostream::operator<<();
  std::stringbuf::str();
  v4[0] = *MEMORY[0x24BEDB800];
  *(_QWORD *)((char *)v4 + *(_QWORD *)(v4[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
  v4[1] = MEMORY[0x24BEDB848] + 16;
  if (v5 < 0)
    operator delete((void *)v4[9]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x212B92EB0](&v6);
}

void sub_20BDDE5CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDDE6CC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDDE5E0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x24BEDB870];
  v3 = MEMORY[0x24BEDB870] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x24BEDB870] + 64;
  v4 = *(_QWORD *)(MEMORY[0x24BEDB800] + 8);
  v5 = *(_QWORD *)(MEMORY[0x24BEDB800] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x24BEDB848] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_20BDDE6A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x212B92EB0](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDDE6CC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x24BEDB800];
  v3 = *MEMORY[0x24BEDB800];
  *(_QWORD *)a1 = *MEMORY[0x24BEDB800];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x24BEDB848] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x212B92EB0](a1 + 112);
  return a1;
}

void Alembic::AbcCoreAbstract::v12::GetLibraryVersion(Alembic::AbcCoreAbstract::v12 *this)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD v8[11];
  char v9;
  uint64_t v10;
  void *v11[2];
  unsigned __int8 v12;

  Alembic::AbcCoreAbstract::v12::GetLibraryVersionShort((uint64_t *)v11, this);
  sub_20BDDE5E0((uint64_t)v8);
  v1 = sub_20BDDC1C8(v8, (uint64_t)"Alembic ", 8);
  if ((v12 & 0x80u) == 0)
    v2 = v11;
  else
    v2 = (void **)v11[0];
  if ((v12 & 0x80u) == 0)
    v3 = v12;
  else
    v3 = (uint64_t)v11[1];
  v4 = sub_20BDDC1C8(v1, (uint64_t)v2, v3);
  v5 = sub_20BDDC1C8(v4, (uint64_t)" (built ", 8);
  v6 = sub_20BDDC1C8(v5, (uint64_t)"Aug  3 2024", 11);
  v7 = sub_20BDDC1C8(v6, (uint64_t)" ", 1);
  sub_20BDDC1C8(v7, (uint64_t)"07:27:29)", 9);
  std::stringbuf::str();
  v8[0] = *MEMORY[0x24BEDB800];
  *(_QWORD *)((char *)v8 + *(_QWORD *)(v8[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
  v8[1] = MEMORY[0x24BEDB848] + 16;
  if (v9 < 0)
    operator delete((void *)v8[9]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x212B92EB0](&v10);
  if ((char)v12 < 0)
    operator delete(v11[0]);
}

void sub_20BDDE880(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
    operator delete(*(void **)(v1 - 56));
  _Unwind_Resume(exception_object);
}

Alembic::AbcCoreAbstract::v12::TimeSampling *Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(Alembic::AbcCoreAbstract::v12::TimeSampling *a1, _OWORD *a2, uint64_t a3)
{
  *(_OWORD *)a1 = *a2;
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 0;
  *((_QWORD *)a1 + 4) = 0;
  sub_20BDDF5DC((_QWORD *)a1 + 2, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3);
  Alembic::AbcCoreAbstract::v12::TimeSampling::init(a1);
  return a1;
}

void sub_20BDDE904(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

double Alembic::AbcCoreAbstract::v12::TimeSampling::init(Alembic::AbcCoreAbstract::v12::TimeSampling *this)
{
  uint64_t v2;
  unint64_t v3;
  int v4;
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v5;
  double result;
  double *v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  unsigned int v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *exception;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *__p[2];
  char v23;
  _QWORD v24[4];
  _BYTE v25[16];
  _QWORD v26[33];

  v2 = *((_QWORD *)this + 3) - *((_QWORD *)this + 2);
  v3 = v2 >> 3;
  v4 = *(_DWORD *)this;
  v5 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(this);
  if (v4 != (_DWORD)v5 && v3 != *(_DWORD *)this)
  {
    sub_20BDDBD68((uint64_t)v25);
    sub_20BDDC1C8(v26, (uint64_t)"Incorrect number of time samples specified, expected ", 53);
    v16 = (_QWORD *)std::ostream::operator<<();
    sub_20BDDC1C8(v16, (uint64_t)", got: ", 7);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v24, (__int128 *)__p);
    if (v23 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v18 = sub_20BDDC09C(exception, (uint64_t)v24);
    __cxa_throw(v18, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if ((unint64_t)v2 >= 9)
  {
    v7 = (double *)*((_QWORD *)this + 2);
    result = *v7;
    v8 = 2;
    if (v3 > 2)
      v8 = v2 >> 3;
    v9 = 1;
    do
    {
      v10 = v7[v9];
      if (result >= v10)
      {
        sub_20BDDBD68((uint64_t)v25);
        sub_20BDDC1C8(v26, (uint64_t)"Sample ", 7);
        v12 = (_QWORD *)std::ostream::operator<<();
        sub_20BDDC1C8(v12, (uint64_t)" value: ", 8);
        v13 = (_QWORD *)std::ostream::operator<<();
        sub_20BDDC1C8(v13, (uint64_t)" is not greater than the previous sample: ", 42);
        std::ostream::operator<<();
        std::stringbuf::str();
        sub_20BDDBF20(v24, (__int128 *)__p);
        if (v23 < 0)
          operator delete(__p[0]);
        v14 = __cxa_allocate_exception(0x20uLL);
        v15 = sub_20BDDC09C(v14, (uint64_t)v24);
        __cxa_throw(v15, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
      }
      ++v9;
      result = v10;
    }
    while (v8 != v9);
    if (*(_DWORD *)this >= 2u)
    {
      v11 = *(_DWORD *)this;
      if (v11 < Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v5))
      {
        result = *(double *)(*((_QWORD *)this + 3) - 8) - **((double **)this + 2);
        if (result > *((double *)this + 1))
        {
          sub_20BDDBD68((uint64_t)v25);
          sub_20BDDC1C8(v26, (uint64_t)"Cyclic samples provided are greater than the time per cycle. Expected: ", 71);
          v19 = (_QWORD *)std::ostream::operator<<();
          sub_20BDDC1C8(v19, (uint64_t)" Found: ", 8);
          std::ostream::operator<<();
          std::stringbuf::str();
          sub_20BDDBF20(v24, (__int128 *)__p);
          if (v23 < 0)
            operator delete(__p[0]);
          v20 = __cxa_allocate_exception(0x20uLL);
          v21 = sub_20BDDC09C(v20, (uint64_t)v24);
          __cxa_throw(v21, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
        }
      }
    }
  }
  return result;
}

void sub_20BDDEBC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  std::exception v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

Alembic::AbcCoreAbstract::v12::TimeSampling *Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(Alembic::AbcCoreAbstract::v12::TimeSampling *this, double a2, double a3)
{
  double *v5;

  v5 = sub_20BDDF4B4((double *)this, a2);
  v5[2] = 0.0;
  v5[3] = 0.0;
  v5[4] = 0.0;
  sub_20BDDEC88((uint64_t)(v5 + 2), 1uLL);
  **((double **)this + 2) = a3;
  Alembic::AbcCoreAbstract::v12::TimeSampling::init(this);
  return this;
}

void sub_20BDDEC6C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_20BDDEC88(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    sub_20BDDF6DC((char **)a1, a2 - v2);
  }
}

Alembic::AbcCoreAbstract::v12::TimeSampling *Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(Alembic::AbcCoreAbstract::v12::TimeSampling *this)
{
  *(_DWORD *)this = 1;
  *((_QWORD *)this + 1) = 0x3FF0000000000000;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  sub_20BDDEC88((uint64_t)this + 16, 1uLL);
  **((_QWORD **)this + 2) = 0;
  return this;
}

void sub_20BDDED14(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

Alembic::AbcCoreAbstract::v12::TimeSampling *Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(Alembic::AbcCoreAbstract::v12::TimeSampling *this, const Alembic::AbcCoreAbstract::v12::TimeSampling *a2)
{
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  sub_20BDDF5DC((_QWORD *)this + 2, *((const void **)a2 + 2), *((_QWORD *)a2 + 3), (uint64_t)(*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 3);
  return this;
}

{
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  sub_20BDDF5DC((_QWORD *)this + 2, *((const void **)a2 + 2), *((_QWORD *)a2 + 3), (uint64_t)(*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 3);
  return this;
}

uint64_t Alembic::AbcCoreAbstract::v12::TimeSampling::operator=(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  if (a1 != a2)
    sub_20BDDF7E4((char *)(a1 + 16), *(char **)(a2 + 16), *(_QWORD *)(a2 + 24), (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3);
  return a1;
}

double Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(double **this, uint64_t a2)
{
  unsigned int v4;
  double v5;
  double v6;
  double v7;
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v8;
  double *v9;
  unsigned int v11;
  uint64_t v12;
  _QWORD *exception;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *__p[2];
  char v20;
  _QWORD v21[4];
  _BYTE v22[16];
  _QWORD v23[33];

  v4 = *(_DWORD *)this;
  if (*(_DWORD *)this == 1)
  {
    v5 = *this[2];
    v6 = *((double *)this + 1);
    v7 = (double)a2;
    return v5 + v6 * v7;
  }
  v8 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)this);
  if (v4 != (_DWORD)v8)
  {
    if (*(_DWORD *)this < 2u
      || (v11 = *(_DWORD *)this,
          v11 >= Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v8)))
    {
      sub_20BDDBD68((uint64_t)v22);
      sub_20BDDC1C8(v23, (uint64_t)"should be cyclic", 16);
      std::stringbuf::str();
      sub_20BDDBF20(v21, (__int128 *)__p);
      if (v20 < 0)
        operator delete(__p[0]);
      exception = __cxa_allocate_exception(0x20uLL);
      v14 = sub_20BDDC09C(exception, (uint64_t)v21);
      __cxa_throw(v14, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
    v12 = *(unsigned int *)this;
    v5 = this[2][a2 % v12];
    v6 = *((double *)this + 1);
    v7 = (double)(a2 / v12);
    return v5 + v6 * v7;
  }
  v9 = this[2];
  if (a2 >= (unint64_t)(this[3] - v9))
  {
    sub_20BDDBD68((uint64_t)v22);
    sub_20BDDC1C8(v23, (uint64_t)"Out-of-range acyclic index: ", 28);
    v15 = (_QWORD *)std::ostream::operator<<();
    sub_20BDDC1C8(v15, (uint64_t)", range [0-", 11);
    v16 = (_QWORD *)std::ostream::operator<<();
    sub_20BDDC1C8(v16, (uint64_t)"]", 1);
    std::stringbuf::str();
    sub_20BDDBF20(v21, (__int128 *)__p);
    if (v20 < 0)
      operator delete(__p[0]);
    v17 = __cxa_allocate_exception(0x20uLL);
    v18 = sub_20BDDC09C(v17, (uint64_t)v21);
    __cxa_throw(v18, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return v9[a2];
}

void sub_20BDDEFD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(double **this, double a2, uint64_t a3)
{
  unint64_t v3;
  double SampleTime;
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v8;
  unsigned int v9;
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v10;
  uint64_t v11;
  double *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  double v17;
  uint64_t v18;
  double v20;
  double v21;
  unsigned int v22;
  uint64_t v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  double v33;
  double v34;
  BOOL v35;
  double v36;
  uint64_t v37;
  double v38;
  double v40;
  double v41;
  double v42;
  _QWORD *exception;
  _QWORD *v44;
  __int128 __p;
  char v46;
  _QWORD v47[4];
  long double __y[2];
  _QWORD v49[33];

  v3 = a3 - 1;
  if (a3 < 1)
    return 0;
  SampleTime = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, 0);
  if (SampleTime >= a2)
    return 0;
  if (Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, v3) <= a2)
    return v3;
  v9 = *(_DWORD *)this;
  v10 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v8);
  if (v9 == (_DWORD)v10)
  {
    v11 = 0;
    v12 = this[2];
    v13 = (char *)this[3] - (char *)v12;
    v14 = v13 >> 3;
    v15 = (v13 >> 3) - 1;
    if (v13 >> 3 >= 1)
      v14 = (v13 >> 3) - 1;
    if (v13 < 17 || (result = v14 >> 1, v14 >> 1 >= v15))
    {
LABEL_20:
      v20 = v12[v15];
      v21 = a2 - v20;
      if (v20 >= a2)
        v21 = v20 - a2;
      result = v15;
      if (v21 > 0.00001)
        return v11;
    }
    else
    {
      v11 = 0;
      while (1)
      {
        v17 = v12[result];
        if (v17 == a2)
          break;
        if (v17 > a2)
          v15 = result;
        else
          v11 = result;
        v18 = v15 + v11;
        if (v15 + v11 < 0 != __OFADD__(v15, v11))
          ++v18;
        result = v18 >> 1;
        if (v11 >= v18 >> 1 || result >= v15)
          goto LABEL_20;
      }
    }
  }
  else
  {
    v22 = *(_DWORD *)this;
    if (*(_DWORD *)this == 1)
    {
      v36 = *((double *)this + 1);
      v37 = (uint64_t)((a2 - SampleTime) / v36);
      if (v37 >= a3)
        result = v3;
      else
        result = v37 & ~(v37 >> 63);
      v38 = SampleTime + v36 * (double)result;
      if (v38 <= a2 || result == 0)
        goto LABEL_61;
      v40 = a2 - v38;
      if (v38 >= a2)
        v40 = v38 - a2;
      if (v40 <= 0.00001)
      {
LABEL_61:
        if (result < v3)
        {
          v41 = SampleTime + v36 * (double)(result + 1);
          v42 = a2 - v41;
          if (v41 >= a2)
            v42 = v41 - a2;
          if (v42 <= 0.00001)
            ++result;
        }
      }
      else
      {
        --result;
      }
    }
    else
    {
      if (!v22 || v22 >= Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v10))
      {
        sub_20BDDBD68((uint64_t)__y);
        sub_20BDDC1C8(v49, (uint64_t)"should be cyclic", 16);
        std::stringbuf::str();
        sub_20BDDBF20(v47, &__p);
        if (v46 < 0)
          operator delete((void *)__p);
        exception = __cxa_allocate_exception(0x20uLL);
        v44 = sub_20BDDC09C(exception, (uint64_t)v47);
        __cxa_throw(v44, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
      }
      v23 = *(unsigned int *)this;
      v24 = *((double *)this + 1);
      __y[0] = 0.0;
      v25 = modf((a2 - SampleTime) / v24, __y);
      if (v25 <= 1.0)
        v26 = 1.0 - v25;
      else
        v26 = v25 + -1.0;
      if (v26 <= 0.00001)
        v27 = __y[0] + 1.0;
      else
        v27 = __y[0];
      v28 = v24 * (double)(uint64_t)v27;
      v29 = this[2];
      v30 = 0;
      if ((_DWORD)v23)
      {
        while (v29[v30] < a2 - v28)
        {
          if (v23 == ++v30)
          {
            v30 = v23;
            break;
          }
        }
      }
      v31 = (uint64_t)v27 * v23;
      v32 = v30 - (v30 == v23);
      v33 = v28 + v29[v32];
      v34 = a2 - v33;
      if (v33 >= a2)
        v34 = v33 - a2;
      v35 = v33 <= a2 || v32 < 1;
      if (!v35 && v34 > 0.00001)
        --v32;
      return v32 + v31;
    }
  }
  return result;
}

void sub_20BDDF340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t Alembic::AbcCoreAbstract::v12::TimeSampling::getCeilIndex(double **this, double a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t FloorIndex;
  double v8;
  double v9;

  if (Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, 0) >= a2)
    return 0;
  v6 = a3 - 1;
  if (Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, a3 - 1) > a2)
  {
    FloorIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(this, a2, a3);
    v6 = FloorIndex;
    if (FloorIndex != a3 - 1)
    {
      v9 = a2 - v8;
      if (v8 >= a2)
        v9 = v8 - a2;
      if (v9 > 0.00001)
      {
        v6 = FloorIndex + 1;
        Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, FloorIndex + 1);
      }
    }
  }
  return v6;
}

uint64_t Alembic::AbcCoreAbstract::v12::TimeSampling::getNearIndex(double **this, double a2, uint64_t a3)
{
  uint64_t v3;
  double v6;
  uint64_t FloorIndex;

  v3 = a3 - 1;
  if (a3 < 1)
    return 0;
  FloorIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(this, a2, a3);
  if (FloorIndex != v3
    && vabdd_f64(a2, v6) > vabdd_f64(Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, FloorIndex + 1), a2))
  {
    ++FloorIndex;
  }
  return FloorIndex;
}

double *sub_20BDDF4B4(double *a1, double a2)
{
  _QWORD *v4;
  _QWORD *exception;
  _QWORD *v6;
  __int128 __p;
  char v8;
  _QWORD v9[4];
  _BYTE v10[16];
  _QWORD v11[33];

  *(_DWORD *)a1 = 1;
  a1[1] = a2;
  if (a2 <= 0.0
    || Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)a1) <= a2)
  {
    sub_20BDDBD68((uint64_t)v10);
    v4 = sub_20BDDC1C8(v11, (uint64_t)"Time per cycle must be greater than 0 ", 38);
    sub_20BDDC1C8(v4, (uint64_t)"and can not be ACYCLIC_TIME_PER_CYCLE.", 38);
    std::stringbuf::str();
    sub_20BDDBF20(v9, &__p);
    if (v8 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v6 = sub_20BDDC09C(exception, (uint64_t)v9);
    __cxa_throw(v6, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return a1;
}

void sub_20BDDF58C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BDDF5B4()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x24BEDB748], MEMORY[0x24BEDABB8]);
}

_QWORD *sub_20BDDF5DC(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = sub_20BDDF654(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20BDDF638(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_20BDDF654(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    sub_20BDDF694();
  result = (char *)sub_20BDDF6A8((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void sub_20BDDF694()
{
  sub_20BDDC04C("vector");
}

void *sub_20BDDF6A8(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    sub_20BDDF5B4();
  return operator new(8 * a2);
}

void sub_20BDDF6DC(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 3);
    if (v10 >> 61)
      sub_20BDDF694();
    v11 = v9 >> 3;
    v12 = v5 - v8;
    if (v12 >> 2 > v10)
      v10 = v12 >> 2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)sub_20BDDF6A8(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v11];
    v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      v18 = *((_QWORD *)v7 - 1);
      v7 -= 8;
      *((_QWORD *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

char *sub_20BDDF7E4(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      sub_20BDDF694();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = sub_20BDDF654(v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

uint64_t Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(Alembic::AbcCoreAbstract::v12::TimeSamplingType *this)
{
  return 0xFFFFFFFFLL;
}

double Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle(Alembic::AbcCoreAbstract::v12::TimeSamplingType *this)
{
  return 5.61779105e306;
}

BOOL Alembic::AbcCoreAbstract::v12::TimeSamplingType::operator==(uint64_t a1, uint64_t a2)
{
  double v2;
  double v3;
  double v4;

  if (*(_DWORD *)a1 != *(_DWORD *)a2)
    return 0;
  v2 = *(double *)(a1 + 8);
  v3 = *(double *)(a2 + 8);
  if (v2 <= v3)
    v4 = v3 - v2;
  else
    v4 = v2 - v3;
  return v4 <= 0.000000001;
}

_QWORD *Alembic::AbcCoreAbstract::v12::operator<<(_QWORD *a1, _DWORD *a2)
{
  const char *v4;
  const char *v5;
  void **v6;
  uint64_t v7;
  _QWORD *v8;
  const char *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *__p[2];
  unsigned __int8 v16;

  sub_20BDDC0E4(__p, "");
  if ((*a2 - 2) >= 0xFFFFFFFD)
    v4 = "Acyclic";
  else
    v4 = "Cyclic";
  if (*a2 == 1)
    v5 = "Uniform";
  else
    v5 = v4;
  MEMORY[0x212B929D0](__p, v5);
  if ((v16 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v16 & 0x80u) == 0)
    v7 = v16;
  else
    v7 = (uint64_t)__p[1];
  v8 = sub_20BDDC1C8(a1, (uint64_t)v6, v7);
  sub_20BDDC1C8(v8, (uint64_t)" time sampling", 14);
  if (*a2 == 1)
  {
    v9 = " with ";
    v10 = 6;
    v11 = a1;
  }
  else
  {
    if ((*a2 - 2) > 0xFFFFFFFC)
      goto LABEL_18;
    sub_20BDDC1C8(a1, (uint64_t)" with ", 6);
    v12 = (_QWORD *)std::ostream::operator<<();
    v11 = sub_20BDDC1C8(v12, (uint64_t)" samps/cycle ", 13);
    v9 = "and ";
    v10 = 4;
  }
  sub_20BDDC1C8(v11, (uint64_t)v9, v10);
  v13 = (_QWORD *)std::ostream::operator<<();
  sub_20BDDC1C8(v13, (uint64_t)" chrono_ts/cycle", 16);
LABEL_18:
  if ((char)v16 < 0)
    operator delete(__p[0]);
  return a1;
}

void sub_20BDDFA84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Alembic::AbcCoreAbstract::v12::ArraySample::getKey(Alembic::AbcCoreAbstract::v12::ArraySample *this@<X0>, uint64_t a2@<X8>)
{
  Alembic::AbcCoreAbstract::v12::ArraySample *v2;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  void *v11;
  unint64_t *v12;
  unsigned int v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  _DWORD *v22;
  _DWORD *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  int v30;
  _DWORD *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  int v38;
  _BYTE *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  _BYTE *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  size_t v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  char v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  size_t v63;
  char *v64;
  char *v65;
  _BYTE *v66;
  char v67;
  char *v68;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  _QWORD *v72;
  _QWORD *exception;
  _QWORD *v74;
  unint64_t *v75;
  uint64_t v76;
  Alembic::AbcCoreAbstract::v12::ArraySample *v77;
  __int128 v78;
  char v79;
  _QWORD v80[4];
  void *__p;
  _DWORD *v82;
  _QWORD v83[34];

  v2 = this;
  v4 = (uint64_t *)*((_QWORD *)this + 2);
  v5 = *((_QWORD *)this + 3) - (_QWORD)v4;
  if (v5)
  {
    v6 = v5 >> 3;
    if (v6 <= 1)
      v6 = 1;
    v7 = 1;
    do
    {
      v8 = *v4++;
      v7 *= v8;
      --v6;
    }
    while (v6);
  }
  else
  {
    v7 = 0;
  }
  v9 = *((unsigned __int8 *)this + 12);
  v10 = sub_20BDE00C8((int *)this + 2) * v7;
  *(_QWORD *)(a2 + 16) = 0;
  v12 = (unint64_t *)(a2 + 16);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)a2 = v10;
  v13 = *((_DWORD *)v2 + 2);
  *(_DWORD *)(a2 + 8) = v13;
  *(_DWORD *)(a2 + 12) = v13;
  if (v13 < 0xC)
  {
    Alembic::Util::v12::MurmurHash3_x64_128(*(_QWORD *)v2, v10, qword_20CA4F298[v13], v12, v11);
    return;
  }
  v14 = v7 * v9;
  v76 = v7 * v9;
  v77 = v2;
  if (v13 == 12)
  {
    __p = 0;
    v82 = 0;
    v83[0] = 0;
    if (!v14)
    {
      v40 = 0;
      v68 = 0;
LABEL_105:
      if (v40 == v68)
        v69 = 0;
      else
        v69 = (uint64_t)v68;
      Alembic::Util::v12::MurmurHash3_x64_128(v69, v40 - v68, 1uLL, v12, v11);
      v70 = __p;
      if (__p)
        goto LABEL_116;
      return;
    }
    v75 = (unint64_t *)(a2 + 16);
    v40 = 0;
    v41 = 0;
    while (1)
    {
      v42 = *(_QWORD *)v2 + 24 * v41;
      if (*(char *)(v42 + 23) < 0)
      {
        v43 = *(_QWORD *)(v42 + 8);
        if (v43)
        {
LABEL_61:
          v44 = 0;
          do
          {
            v45 = v42;
            if (*(char *)(v42 + 23) < 0)
              v45 = *(_QWORD *)v42;
            v46 = *(_BYTE *)(v45 + v44);
            if ((unint64_t)v40 >= v83[0])
            {
              v48 = (unint64_t)__p;
              v49 = v40 - (_BYTE *)__p;
              v50 = v40 - (_BYTE *)__p + 1;
              if (v50 < 0)
                sub_20BDDF694();
              v51 = v83[0] - (_QWORD)__p;
              if (2 * (v83[0] - (_QWORD)__p) > (unint64_t)v50)
                v50 = 2 * v51;
              if (v51 >= 0x3FFFFFFFFFFFFFFFLL)
                v52 = 0x7FFFFFFFFFFFFFFFLL;
              else
                v52 = v50;
              if (v52)
                v53 = (char *)operator new(v52);
              else
                v53 = 0;
              v54 = &v53[v49];
              v55 = &v53[v49];
              *v55 = v46;
              v47 = v55 + 1;
              if (v40 != (char *)v48)
              {
                v56 = &v40[~v48];
                do
                {
                  v57 = *--v40;
                  (v56--)[(_QWORD)v53] = v57;
                }
                while (v40 != (char *)v48);
                v40 = (char *)__p;
                v54 = v53;
              }
              __p = v54;
              v83[0] = &v53[v52];
              if (v40)
                operator delete(v40);
            }
            else
            {
              *v40 = v46;
              v47 = v40 + 1;
            }
            v82 = v47;
            ++v44;
            v40 = v47;
          }
          while (v44 != v43);
          goto LABEL_85;
        }
      }
      else
      {
        v43 = *(unsigned __int8 *)(v42 + 23);
        if (*(_BYTE *)(v42 + 23))
          goto LABEL_61;
      }
      v47 = v40;
LABEL_85:
      if ((unint64_t)v47 >= v83[0])
      {
        v59 = (unint64_t)__p;
        v60 = v47 - (_BYTE *)__p;
        v61 = v47 - (_BYTE *)__p + 1;
        v2 = v77;
        if (v61 < 0)
          sub_20BDDF694();
        v62 = v83[0] - (_QWORD)__p;
        if (2 * (v83[0] - (_QWORD)__p) > (unint64_t)v61)
          v61 = 2 * v62;
        if (v62 >= 0x3FFFFFFFFFFFFFFFLL)
          v63 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v63 = v61;
        if (v63)
          v64 = (char *)operator new(v63);
        else
          v64 = 0;
        v65 = &v64[v60];
        v64[v60] = 0;
        v40 = &v64[v60 + 1];
        if (v47 != (_BYTE *)v59)
        {
          v66 = &v47[~v59];
          do
          {
            v67 = *--v47;
            (v66--)[(_QWORD)v64] = v67;
          }
          while (v47 != (_BYTE *)v59);
          v47 = __p;
          v65 = v64;
        }
        __p = v65;
        v83[0] = &v64[v63];
        v58 = v76;
        if (v47)
          operator delete(v47);
      }
      else
      {
        *v47 = 0;
        v40 = v47 + 1;
        v58 = v76;
        v2 = v77;
      }
      v82 = v40;
      if (++v41 == v58)
      {
        v68 = (char *)__p;
        v12 = v75;
        goto LABEL_105;
      }
    }
  }
  if (v13 != 13)
  {
    sub_20BDDBD68((uint64_t)&__p);
    v72 = sub_20BDDC1C8(v83, (uint64_t)"Can't calculate key for: ", 25);
    sub_20BDE00F4(v72, (int *)v2 + 2);
    std::stringbuf::str();
    sub_20BDDBF20(v80, &v78);
    if (v79 < 0)
      operator delete((void *)v78);
    exception = __cxa_allocate_exception(0x20uLL);
    v74 = sub_20BDDC09C(exception, (uint64_t)v80);
    __cxa_throw(v74, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  __p = 0;
  v82 = 0;
  v83[0] = 0;
  if (v14)
  {
    v15 = 0;
    v16 = 0;
    while (1)
    {
      v17 = *(_QWORD *)v2 + 24 * v16;
      if (*(char *)(v17 + 23) < 0)
      {
        v18 = *(_QWORD *)(v17 + 8);
        if (v18)
        {
LABEL_16:
          v19 = 0;
          do
          {
            v20 = v17;
            if (*(char *)(v17 + 23) < 0)
              v20 = *(_QWORD *)v17;
            v21 = *(_DWORD *)(v20 + 4 * v19);
            if ((unint64_t)v15 >= v83[0])
            {
              v23 = __p;
              v24 = ((char *)v15 - (_BYTE *)__p) >> 2;
              v25 = v24 + 1;
              if ((unint64_t)(v24 + 1) >> 62)
                sub_20BDDF694();
              v26 = v83[0] - (_QWORD)__p;
              if ((uint64_t)(v83[0] - (_QWORD)__p) >> 1 > v25)
                v25 = v26 >> 1;
              if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL)
                v27 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v27 = v25;
              if (v27)
              {
                v28 = (char *)sub_20BDE1330((uint64_t)v83, v27);
                v23 = __p;
                v15 = v82;
              }
              else
              {
                v28 = 0;
              }
              v29 = &v28[4 * v24];
              *(_DWORD *)v29 = v21;
              v22 = v29 + 4;
              while (v15 != v23)
              {
                v30 = *--v15;
                *((_DWORD *)v29 - 1) = v30;
                v29 -= 4;
              }
              __p = v29;
              v82 = v22;
              v83[0] = &v28[4 * v27];
              if (v23)
                operator delete(v23);
            }
            else
            {
              *v15 = v21;
              v22 = v15 + 1;
            }
            v82 = v22;
            ++v19;
            v15 = v22;
          }
          while (v19 != v18);
          goto LABEL_39;
        }
      }
      else
      {
        v18 = *(unsigned __int8 *)(v17 + 23);
        if (*(_BYTE *)(v17 + 23))
          goto LABEL_16;
      }
      v22 = v15;
LABEL_39:
      v2 = v77;
      if ((unint64_t)v22 >= v83[0])
      {
        v31 = __p;
        v32 = ((char *)v22 - (_BYTE *)__p) >> 2;
        v33 = v32 + 1;
        if ((unint64_t)(v32 + 1) >> 62)
          sub_20BDDF694();
        v34 = v83[0] - (_QWORD)__p;
        if ((uint64_t)(v83[0] - (_QWORD)__p) >> 1 > v33)
          v33 = v34 >> 1;
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFFCLL)
          v35 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v35 = v33;
        if (v35)
        {
          v36 = (char *)sub_20BDE1330((uint64_t)v83, v35);
          v31 = __p;
          v22 = v82;
        }
        else
        {
          v36 = 0;
        }
        v37 = &v36[4 * v32];
        *(_DWORD *)v37 = 0;
        v15 = v37 + 4;
        while (v22 != v31)
        {
          v38 = *--v22;
          *((_DWORD *)v37 - 1) = v38;
          v37 -= 4;
        }
        __p = v37;
        v82 = v15;
        v83[0] = &v36[4 * v35];
        if (v31)
          operator delete(v31);
      }
      else
      {
        *v22 = 0;
        v15 = v22 + 1;
      }
      v82 = v15;
      if (++v16 == v76)
      {
        v39 = __p;
        v12 = (unint64_t *)(a2 + 16);
        goto LABEL_111;
      }
    }
  }
  v15 = 0;
  v39 = 0;
LABEL_111:
  if (v15 == (_DWORD *)v39)
    v71 = 0;
  else
    v71 = (uint64_t)v39;
  Alembic::Util::v12::MurmurHash3_x64_128(v71, ((char *)v15 - v39) >> 2, 4uLL, v12, v11);
  v70 = __p;
  if (__p)
  {
    v82 = __p;
LABEL_116:
    operator delete(v70);
  }
}

void sub_20BDE0064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::exception a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  sub_20BDDC194(&a15);
  sub_20BDDBE98((uint64_t)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE00C8(int *a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *a1;
  if (v1 > 0xD)
    v2 = 0;
  else
    v2 = qword_20CA4F2F8[v1];
  return v2 * *((unsigned __int8 *)a1 + 4);
}

_QWORD *sub_20BDE00F4(_QWORD *a1, int *a2)
{
  uint64_t v4;
  const char *v5;
  size_t v6;
  _QWORD *v7;

  v4 = *a2;
  if (v4 > 0xD)
    v5 = "UNKNOWN";
  else
    v5 = off_24C516F38[v4];
  v6 = strlen(v5);
  sub_20BDDC1C8(a1, (uint64_t)v5, v6);
  if (*((unsigned __int8 *)a2 + 4) >= 2u)
  {
    sub_20BDDC1C8(a1, (uint64_t)"[", 1);
    v7 = (_QWORD *)std::ostream::operator<<();
    sub_20BDDC1C8(v7, (uint64_t)"]", 1);
  }
  return a1;
}

_QWORD *Alembic::AbcCoreAbstract::v12::AllocateArraySample@<X0>(_QWORD *result@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  switch(*(_DWORD *)result)
  {
    case 0:
      result = sub_20BDE0230(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 1:
      result = sub_20BDE0354(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 2:
      result = sub_20BDE0474(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 3:
      result = sub_20BDE0594(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 4:
      result = sub_20BDE06C0(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 5:
      result = sub_20BDE07EC(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 6:
      result = sub_20BDE091C(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 7:
      result = sub_20BDE0A4C(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 8:
      result = sub_20BDE0B7C(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 9:
      result = sub_20BDE0CAC(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 0xA:
      result = sub_20BDE0DD8(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 0xB:
      result = sub_20BDE0F08(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 0xC:
      result = sub_20BDE1038(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 0xD:
      result = sub_20BDE11B4(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    default:
      *a3 = 0;
      a3[1] = 0;
      break;
  }
  return result;
}

_QWORD *sub_20BDE0230@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  size_t v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v16;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v9 * a1)
  {
    v13 = operator new[](v9 * a1);
    bzero(v13, v12);
    v14 = operator new(0x28uLL);
    *v14 = v13;
    v14[1] = (unint64_t)v3 << 32;
    v14[3] = 0;
    v14[4] = 0;
    v14[2] = 0;
    sub_20BDE1364(v14 + 2, v6, v5, v7 >> 3);
    return sub_20BDE13DC(a3, (uint64_t)v14);
  }
  else
  {
    v16 = operator new(0x28uLL);
    *v16 = 0;
    v16[1] = (unint64_t)v3 << 32;
    v16[3] = 0;
    v16[4] = 0;
    v16[2] = 0;
    sub_20BDE1364(v16 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v16);
  }
}

void sub_20BDE033C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE0354@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  size_t v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v16;

  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v9 * a1)
  {
    v13 = operator new[](v12);
    v14 = operator new(0x28uLL);
    *v14 = v13;
    v14[1] = ((unint64_t)a1 << 32) | 1;
    v14[3] = 0;
    v14[4] = 0;
    v14[2] = 0;
    sub_20BDE1364(v14 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1660(a3, (uint64_t)v14);
  }
  else
  {
    v16 = operator new(0x28uLL);
    *v16 = 0;
    v16[1] = ((unint64_t)a1 << 32) | 1;
    v16[3] = 0;
    v16[4] = 0;
    v16[2] = 0;
    sub_20BDE1364(v16 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v16);
  }
}

void sub_20BDE045C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE0474@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  size_t v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v16;

  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v9 * a1)
  {
    v13 = operator new[](v12);
    v14 = operator new(0x28uLL);
    *v14 = v13;
    v14[1] = ((unint64_t)a1 << 32) | 2;
    v14[3] = 0;
    v14[4] = 0;
    v14[2] = 0;
    sub_20BDE1364(v14 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1738(a3, (uint64_t)v14);
  }
  else
  {
    v16 = operator new(0x28uLL);
    *v16 = 0;
    v16[1] = ((unint64_t)a1 << 32) | 2;
    v16[3] = 0;
    v16[4] = 0;
    v16[2] = 0;
    sub_20BDE1364(v16 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v16);
  }
}

void sub_20BDE057C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE0594@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v17;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v12)
  {
    if (v12 < 0)
      v13 = -1;
    else
      v13 = 2 * v12;
    v14 = operator new[](v13);
    v15 = operator new(0x28uLL);
    *v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 3;
    v15[3] = 0;
    v15[4] = 0;
    v15[2] = 0;
    sub_20BDE1364(v15 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1810(a3, (uint64_t)v15);
  }
  else
  {
    v17 = operator new(0x28uLL);
    *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 3;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v17);
  }
}

void sub_20BDE06A8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE06C0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v17;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v12)
  {
    if (v12 < 0)
      v13 = -1;
    else
      v13 = 2 * v12;
    v14 = operator new[](v13);
    v15 = operator new(0x28uLL);
    *v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 4;
    v15[3] = 0;
    v15[4] = 0;
    v15[2] = 0;
    sub_20BDE1364(v15 + 2, v6, v5, v7 >> 3);
    return sub_20BDE18E8(a3, (uint64_t)v15);
  }
  else
  {
    v17 = operator new(0x28uLL);
    *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 4;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v17);
  }
}

void sub_20BDE07D4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE07EC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v17;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 62)
      v13 = -1;
    else
      v13 = 4 * v12;
    v14 = operator new[](v13);
    v15 = operator new(0x28uLL);
    *v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 5;
    v15[3] = 0;
    v15[4] = 0;
    v15[2] = 0;
    sub_20BDE1364(v15 + 2, v6, v5, v7 >> 3);
    return sub_20BDE19C0(a3, (uint64_t)v15);
  }
  else
  {
    v17 = operator new(0x28uLL);
    *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 5;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v17);
  }
}

void sub_20BDE0904(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE091C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v17;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 62)
      v13 = -1;
    else
      v13 = 4 * v12;
    v14 = operator new[](v13);
    v15 = operator new(0x28uLL);
    *v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 6;
    v15[3] = 0;
    v15[4] = 0;
    v15[2] = 0;
    sub_20BDE1364(v15 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1A98(a3, (uint64_t)v15);
  }
  else
  {
    v17 = operator new(0x28uLL);
    *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 6;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v17);
  }
}

void sub_20BDE0A34(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE0A4C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v17;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 61)
      v13 = -1;
    else
      v13 = 8 * v12;
    v14 = operator new[](v13);
    v15 = operator new(0x28uLL);
    *v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 7;
    v15[3] = 0;
    v15[4] = 0;
    v15[2] = 0;
    sub_20BDE1364(v15 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1B70(a3, (uint64_t)v15);
  }
  else
  {
    v17 = operator new(0x28uLL);
    *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 7;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v17);
  }
}

void sub_20BDE0B64(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE0B7C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v17;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 61)
      v13 = -1;
    else
      v13 = 8 * v12;
    v14 = operator new[](v13);
    v15 = operator new(0x28uLL);
    *v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 8;
    v15[3] = 0;
    v15[4] = 0;
    v15[2] = 0;
    sub_20BDE1364(v15 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1C48(a3, (uint64_t)v15);
  }
  else
  {
    v17 = operator new(0x28uLL);
    *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 8;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v17);
  }
}

void sub_20BDE0C94(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE0CAC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v17;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v12)
  {
    if (v12 < 0)
      v13 = -1;
    else
      v13 = 2 * v12;
    v14 = operator new[](v13);
    v15 = operator new(0x28uLL);
    *v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 9;
    v15[3] = 0;
    v15[4] = 0;
    v15[2] = 0;
    sub_20BDE1364(v15 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1D20(a3, (uint64_t)v15);
  }
  else
  {
    v17 = operator new(0x28uLL);
    *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 9;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v17);
  }
}

void sub_20BDE0DC0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE0DD8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v17;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 62)
      v13 = -1;
    else
      v13 = 4 * v12;
    v14 = operator new[](v13);
    v15 = operator new(0x28uLL);
    *v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 0xA;
    v15[3] = 0;
    v15[4] = 0;
    v15[2] = 0;
    sub_20BDE1364(v15 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1DF8(a3, (uint64_t)v15);
  }
  else
  {
    v17 = operator new(0x28uLL);
    *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 0xA;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v17);
  }
}

void sub_20BDE0EF0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE0F08@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v17;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 61)
      v13 = -1;
    else
      v13 = 8 * v12;
    v14 = operator new[](v13);
    v15 = operator new(0x28uLL);
    *v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 0xB;
    v15[3] = 0;
    v15[4] = 0;
    v15[2] = 0;
    sub_20BDE1364(v15 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1ED0(a3, (uint64_t)v15);
  }
  else
  {
    v17 = operator new(0x28uLL);
    *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 0xB;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v17);
  }
}

void sub_20BDE1020(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE1038@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  _BOOL4 v13;
  size_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v19;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v9 * a1)
  {
    v13 = !is_mul_ok(v12, 0x18uLL);
    if (24 * v12 >= 0xFFFFFFFFFFFFFFF0)
      v13 = 1;
    if (v13)
      v14 = -1;
    else
      v14 = 24 * v12 + 16;
    v15 = operator new[](v14);
    *v15 = 24;
    v15[1] = v12;
    v16 = v15 + 2;
    bzero(v15 + 2, 24 * ((24 * v12 - 24) / 0x18) + 24);
    v17 = operator new(0x28uLL);
    *v17 = v16;
    v17[1] = ((unint64_t)v3 << 32) | 0xC;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1FA8(a3, (uint64_t)v17);
  }
  else
  {
    v19 = operator new(0x28uLL);
    *v19 = 0;
    v19[1] = ((unint64_t)v3 << 32) | 0xC;
    v19[3] = 0;
    v19[4] = 0;
    v19[2] = 0;
    sub_20BDE1364(v19 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v19);
  }
}

void sub_20BDE119C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE11B4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  _BOOL4 v13;
  size_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v19;

  v3 = a1;
  v6 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1)
      v8 = 1;
    else
      v8 = v7 >> 3;
    v9 = 1;
    v10 = *(uint64_t **)a2;
    do
    {
      v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  v12 = v9 * a1;
  if (v9 * a1)
  {
    v13 = !is_mul_ok(v12, 0x18uLL);
    if (24 * v12 >= 0xFFFFFFFFFFFFFFF0)
      v13 = 1;
    if (v13)
      v14 = -1;
    else
      v14 = 24 * v12 + 16;
    v15 = operator new[](v14);
    *v15 = 24;
    v15[1] = v12;
    v16 = v15 + 2;
    bzero(v15 + 2, 24 * ((24 * v12 - 24) / 0x18) + 24);
    v17 = operator new(0x28uLL);
    *v17 = v16;
    v17[1] = ((unint64_t)v3 << 32) | 0xD;
    v17[3] = 0;
    v17[4] = 0;
    v17[2] = 0;
    sub_20BDE1364(v17 + 2, v6, v5, v7 >> 3);
    return sub_20BDE2100(a3, (uint64_t)v17);
  }
  else
  {
    v19 = operator new(0x28uLL);
    *v19 = 0;
    v19[1] = ((unint64_t)v3 << 32) | 0xD;
    v19[3] = 0;
    v19[4] = 0;
    v19[2] = 0;
    sub_20BDE1364(v19 + 2, v6, v5, v7 >> 3);
    return sub_20BDE1558(a3, (uint64_t)v19);
  }
}

void sub_20BDE1318(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_20BDE1330(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    sub_20BDDF5B4();
  return operator new(4 * a2);
}

_QWORD *sub_20BDE1364(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = sub_20BDDF654(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20BDE13C0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDE13DC(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516990;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1428(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE1440(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE1454(int a1, void **__p)
{
  void *v3;

  if (__p)
  {
    if (*__p)
      operator delete[](*__p);
    v3 = __p[2];
    if (v3)
    {
      __p[3] = v3;
      operator delete(v3);
    }
    operator delete(__p);
  }
}

void sub_20BDE149C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE14B0(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE14CC(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C5169D0))
    return a1 + 24;
  else
    return 0;
}

BOOL sub_20BDE150C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

_QWORD *sub_20BDE1558(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &unk_24C5169F0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE15A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;

  a10 = 0;
  if (v10)
    sub_20BDE1628((int)&a10, v10);
  _Unwind_Resume(exception_object);
}

void sub_20BDE15CC(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE15E0(uint64_t a1)
{
  sub_20BDE1628(a1 + 24, *(_QWORD **)(a1 + 24));
}

uint64_t sub_20BDE15E8(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516A40))
    return a1 + 24;
  else
    return 0;
}

void sub_20BDE1628(int a1, _QWORD *__p)
{
  void *v3;

  if (__p)
  {
    v3 = (void *)__p[2];
    if (v3)
    {
      __p[3] = v3;
      operator delete(v3);
    }
    operator delete(__p);
  }
}

_QWORD *sub_20BDE1660(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516A68;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE16AC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE16C4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE16DC(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE16F0(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE16F8(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516AA8))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE1738(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516AC8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1784(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE179C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE17B4(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE17C8(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE17D0(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516B08))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE1810(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516B28;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE185C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE1874(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE188C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE18A0(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE18A8(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516B68))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE18E8(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516B88;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1934(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE194C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE1964(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE1978(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE1980(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516BC8))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE19C0(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516BE8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1A0C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE1A24(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE1A3C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE1A50(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE1A58(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516C28))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE1A98(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516C48;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1AE4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE1AFC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE1B14(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE1B28(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE1B30(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516C88))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE1B70(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516CA8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1BBC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE1BD4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE1BEC(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE1C00(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE1C08(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516CE8))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE1C48(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516D08;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1C94(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE1CAC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE1CC4(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE1CD8(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE1CE0(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516D48))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE1D20(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516D68;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1D6C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE1D84(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE1D9C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE1DB0(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE1DB8(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516DA8))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE1DF8(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516DC8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1E44(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE1E5C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE1E74(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE1E88(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE1E90(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516E08))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE1ED0(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516E28;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1F1C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void **v13;

  __cxa_begin_catch(a1);
  sub_20BDE1454((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE1F34(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE1F4C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE1F60(uint64_t a1)
{
  sub_20BDE1454(a1 + 24, *(void ***)(a1 + 24));
}

uint64_t sub_20BDE1F68(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516E68))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE1FA8(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516E88;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE1FF4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t *v13;

  __cxa_begin_catch(a1);
  sub_20BDE2020((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE200C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE2020(int a1, uint64_t *__p)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (__p)
  {
    v3 = *__p;
    if (*__p)
    {
      v4 = *(_QWORD *)(v3 - 8);
      if (v4)
      {
        v5 = 24 * v4;
        do
        {
          if (*(char *)(v3 + v5 - 1) < 0)
            operator delete(*(void **)(v3 + v5 - 24));
          v5 -= 24;
        }
        while (v5);
      }
      operator delete[]((void *)(v3 - 16));
    }
    v6 = (void *)__p[2];
    if (v6)
    {
      __p[3] = (uint64_t)v6;
      operator delete(v6);
    }
    operator delete(__p);
  }
}

void sub_20BDE20A4(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE20B8(uint64_t a1)
{
  sub_20BDE2020(a1 + 24, *(uint64_t **)(a1 + 24));
}

uint64_t sub_20BDE20C0(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516EC8))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDE2100(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C516EE8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE214C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t *v13;

  __cxa_begin_catch(a1);
  sub_20BDE2020((int)&a13, v13);
  __cxa_rethrow();
}

void sub_20BDE2164(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BDE217C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE2190(uint64_t a1)
{
  sub_20BDE2020(a1 + 24, *(uint64_t **)(a1 + 24));
}

uint64_t sub_20BDE2198(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C516F28))
    return a1 + 24;
  else
    return 0;
}

void Alembic::AbcCoreAbstract::v12::ReadArraySampleCache::~ReadArraySampleCache(Alembic::AbcCoreAbstract::v12::ReadArraySampleCache *this)
{
  std::__shared_weak_count *v1;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

uint64_t Alembic::AbcCoreAbstract::v12::ScalarSample::ScalarSample(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  size_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  void *v11;
  size_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *exception;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *__p[2];
  char v23;
  _QWORD v24[4];
  _BYTE v25[16];
  _QWORD v26[33];

  v3 = *a2;
  *(_QWORD *)a1 = *a2;
  *(_QWORD *)(a1 + 8) = 0;
  if ((_DWORD)v3 == 127 || (v3 & 0xFF00000000) == 0)
  {
    sub_20BDDBD68((uint64_t)v25);
    sub_20BDDC1C8(v26, (uint64_t)"Degenerate data type in scalar sample", 37);
    std::stringbuf::str();
    sub_20BDDBF20(v24, (__int128 *)__p);
    if (v23 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v18 = sub_20BDDC09C(exception, (uint64_t)v24);
    __cxa_throw(v18, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v5 = BYTE4(v3);
  switch((int)v3)
  {
    case 0:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C517040;
      v7 = sub_20BDE2900(v6 + 1, v5);
      v8 = 0;
      do
        *(_BYTE *)(*v7 + v8++) = 0;
      while (v5 != v8);
      break;
    case 1:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C5170B8;
      v13 = sub_20BDE2BE0(v6 + 1, v5);
      v14 = 0;
      do
        *(_BYTE *)(*v13 + v14++) = 0;
      while (v5 != v14);
      break;
    case 2:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C517120;
      v9 = sub_20BDE2E84(v6 + 1, v5);
      v10 = 0;
      do
        *(_BYTE *)(*v9 + v10++) = 0;
      while (v5 != v10);
      break;
    case 3:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C517188;
      sub_20BDE311C(v6 + 1, v5);
      goto LABEL_17;
    case 4:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C5171F0;
      sub_20BDE3428(v6 + 1, v5);
      goto LABEL_17;
    case 5:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C517258;
      sub_20BDE36C4(v6 + 1, v5);
      goto LABEL_26;
    case 6:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C5172C0;
      sub_20BDE39A0(v6 + 1, v5);
      goto LABEL_26;
    case 7:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C517328;
      sub_20BDE3C3C(v6 + 1, v5);
      goto LABEL_28;
    case 8:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C517390;
      sub_20BDE3ED8(v6 + 1, v5);
      goto LABEL_28;
    case 9:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C5173F8;
      sub_20BDE4384(v6 + 1, v5);
LABEL_17:
      v11 = (void *)v6[1];
      v12 = 2 * v5;
      goto LABEL_29;
    case 10:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C517460;
      sub_20BDE4630(v6 + 1, v5);
LABEL_26:
      v11 = (void *)v6[1];
      v12 = 4 * v5;
      goto LABEL_29;
    case 11:
      v6 = operator new(0x20uLL);
      *v6 = &off_24C5174C8;
      sub_20BDE48D4(v6 + 1, v5);
LABEL_28:
      v11 = (void *)v6[1];
      v12 = 8 * v5;
LABEL_29:
      bzero(v11, v12);
      break;
    case 12:
      v6 = operator new(0x20uLL);
      sub_20BDE4948(v6, v5);
      break;
    case 13:
      v6 = operator new(0x20uLL);
      sub_20BDE50C4(v6, v5);
      break;
    default:
      sub_20BDDBD68((uint64_t)v25);
      v19 = sub_20BDDC1C8(v26, (uint64_t)"Unknown datatype in ScalarSample: ", 34);
      sub_20BDE00F4(v19, (int *)a1);
      std::stringbuf::str();
      sub_20BDDBF20(v24, (__int128 *)__p);
      if (v23 < 0)
        operator delete(__p[0]);
      v20 = __cxa_allocate_exception(0x20uLL);
      v21 = sub_20BDDC09C(v20, (uint64_t)v24);
      __cxa_throw(v21, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v15 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v6;
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  return a1;
}

void sub_20BDE25C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  uint64_t v6;
  std::exception v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  v6 = *(_QWORD *)(v4 + 8);
  *(_QWORD *)(v4 + 8) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE2668(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C517040;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE26A4(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C517040;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

uint64_t sub_20BDE26E0(uint64_t result)
{
  unint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(result + 16) - *(_QWORD *)(result + 8);
  if (v1)
  {
    v2 = 0;
    if (v1 <= 1)
      v1 = 1;
    do
      *(_BYTE *)(*(_QWORD *)(result + 8) + v2++) = 0;
    while (v1 != v2);
  }
  return result;
}

uint64_t sub_20BDE2710(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 16) - *(_QWORD *)(result + 8);
  if (v2)
  {
    v3 = 0;
    if (v2 <= 1)
      v2 = 1;
    do
    {
      *(_BYTE *)(*(_QWORD *)(result + 8) + v3) = *(_BYTE *)(a2 + v3);
      ++v3;
    }
    while (v2 != v3);
  }
  return result;
}

BOOL sub_20BDE2744(uint64_t a1, _BYTE *a2)
{
  _BYTE *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;
  unint64_t v7;
  int v8;
  int v9;

  v2 = *(_BYTE **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  if (v3 <= 1)
    v4 = 1;
  else
    v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if ((*v2 != 0) != (*a2 != 0))
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v4 == v6)
      break;
    v8 = v2[v6] != 0;
    v9 = a2[v6++] != 0;
  }
  while (v8 == v9);
  return v7 >= v3;
}

BOOL sub_20BDE27C8(uint64_t a1, _BYTE *a2)
{
  _BYTE *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  char v7;

  v2 = *(_BYTE **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  if (v3 <= 1)
    v4 = 1;
  else
    v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if ((*v2 == 0) == (*a2 != 0))
    return 0;
  v5 = 1;
  do
  {
    v6 = v5;
    if (v4 == v5)
      break;
    v7 = (v2[v5] == 0) ^ (a2[v5] != 0);
    ++v5;
  }
  while ((v7 & 1) != 0);
  return v6 >= v3;
}

uint64_t sub_20BDE284C(uint64_t a1, _BYTE *a2)
{
  _BYTE *v2;
  unint64_t v3;
  uint64_t v4;
  BOOL v5;
  BOOL v6;
  BOOL v7;
  unint64_t v8;
  BOOL v9;
  int v10;
  int v11;
  BOOL v12;
  char v13;

  v2 = *(_BYTE **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    if (v3 <= 1)
      v4 = 1;
    else
      v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
    v5 = *v2 != 0;
    v6 = *a2 == 0;
    if (*v2)
      v7 = 1;
    else
      v7 = *a2 == 0;
    if (v7)
    {
      v8 = 1;
      v9 = 1;
      while (!v5 || !v6)
      {
        v9 = v8 < v3;
        if (v4 == v8)
          goto LABEL_21;
        v10 = v2[v8];
        v11 = a2[v8];
        v5 = v2[v8] != 0;
        v6 = v11 == 0;
        ++v8;
        if (v10)
          v12 = 1;
        else
          v12 = v11 == 0;
        if (!v12)
        {
          LOBYTE(v2) = 1;
          goto LABEL_21;
        }
      }
      LOBYTE(v2) = 0;
LABEL_21:
      v13 = v9 & v2;
    }
    else
    {
      v13 = 1;
    }
  }
  else
  {
    v13 = 0;
  }
  return v13 & 1;
}

uint64_t sub_20BDE28F8(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE2900(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE2970(a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_20BDE2954(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_20BDE2970(_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    sub_20BDDF694();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

_QWORD *sub_20BDE29B0(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C5170B8;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE29EC(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C5170B8;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

uint64_t sub_20BDE2A28(uint64_t result)
{
  unint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(result + 16) - *(_QWORD *)(result + 8);
  if (v1)
  {
    v2 = 0;
    if (v1 <= 1)
      v1 = 1;
    do
      *(_BYTE *)(*(_QWORD *)(result + 8) + v2++) = 0;
    while (v1 != v2);
  }
  return result;
}

uint64_t sub_20BDE2A58(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 16) - *(_QWORD *)(result + 8);
  if (v2)
  {
    v3 = 0;
    if (v2 <= 1)
      v2 = 1;
    do
    {
      *(_BYTE *)(*(_QWORD *)(result + 8) + v3) = *(_BYTE *)(a2 + v3);
      ++v3;
    }
    while (v2 != v3);
  }
  return result;
}

BOOL sub_20BDE2A8C(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  if (v3 <= 1)
    v4 = 1;
  else
    v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (*v2 != *a2)
    return 0;
  v5 = 1;
  do
  {
    v6 = v5;
    if (v4 == v5)
      break;
    v7 = v2[v5];
    v8 = a2[v5++];
  }
  while (v7 == v8);
  return v6 >= v3;
}

BOOL sub_20BDE2AF0(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  if (v3 <= 1)
    v4 = 1;
  else
    v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (*v2 != *a2)
    return 0;
  v5 = 1;
  do
  {
    v6 = v5;
    if (v4 == v5)
      break;
    v7 = v2[v5];
    v8 = a2[v5++];
  }
  while (v7 == v8);
  return v6 >= v3;
}

uint64_t sub_20BDE2B54(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  char v7;
  unint64_t v8;
  BOOL v9;

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    if (v3 <= 1)
      v4 = 1;
    else
      v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
    v5 = *v2;
    v6 = *a2;
    if (v5 >= v6)
    {
      v8 = 1;
      v9 = 1;
      while (v5 <= v6)
      {
        v9 = v8 < v3;
        if (v4 == v8)
          goto LABEL_14;
        v5 = v2[v8];
        v6 = a2[v8++];
        if (v5 < v6)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      v7 = v9 & v2;
    }
    else
    {
      v7 = 1;
    }
  }
  else
  {
    v7 = 0;
  }
  return v7 & 1;
}

uint64_t sub_20BDE2BD8(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE2BE0(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE2970(a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_20BDE2C34(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDE2C50(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C517120;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE2C8C(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C517120;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

uint64_t sub_20BDE2CC8(uint64_t result)
{
  unint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(result + 16) - *(_QWORD *)(result + 8);
  if (v1)
  {
    v2 = 0;
    if (v1 <= 1)
      v1 = 1;
    do
      *(_BYTE *)(*(_QWORD *)(result + 8) + v2++) = 0;
    while (v1 != v2);
  }
  return result;
}

uint64_t sub_20BDE2CF8(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 16) - *(_QWORD *)(result + 8);
  if (v2)
  {
    v3 = 0;
    if (v2 <= 1)
      v2 = 1;
    do
    {
      *(_BYTE *)(*(_QWORD *)(result + 8) + v3) = *(_BYTE *)(a2 + v3);
      ++v3;
    }
    while (v2 != v3);
  }
  return result;
}

BOOL sub_20BDE2D2C(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  if (v3 <= 1)
    v4 = 1;
  else
    v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (*v2 != *a2)
    return 0;
  v5 = 1;
  do
  {
    v6 = v5;
    if (v4 == v5)
      break;
    v7 = v2[v5];
    v8 = a2[v5++];
  }
  while (v7 == v8);
  return v6 >= v3;
}

BOOL sub_20BDE2D90(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  if (v3 <= 1)
    v4 = 1;
  else
    v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (*v2 != *a2)
    return 0;
  v5 = 1;
  do
  {
    v6 = v5;
    if (v4 == v5)
      break;
    v7 = v2[v5];
    v8 = a2[v5++];
  }
  while (v7 == v8);
  return v6 >= v3;
}

uint64_t sub_20BDE2DF4(uint64_t a1, char *a2)
{
  char *v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  char v7;
  unint64_t v8;
  BOOL v9;

  v2 = *(char **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    if (v3 <= 1)
      v4 = 1;
    else
      v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
    v5 = *v2;
    v6 = *a2;
    if (v5 >= v6)
    {
      v8 = 1;
      v9 = 1;
      while ((char)v5 <= (char)v6)
      {
        v9 = v8 < v3;
        if (v4 == v8)
          goto LABEL_14;
        v5 = v2[v8];
        v6 = a2[v8++];
        if (v5 < v6)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      v7 = v9 & v2;
    }
    else
    {
      v7 = 1;
    }
  }
  else
  {
    v7 = 0;
  }
  return v7 & 1;
}

uint64_t sub_20BDE2E7C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE2E84(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE2970(a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_20BDE2ED8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDE2EF4(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C517188;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE2F30(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C517188;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void sub_20BDE2F6C(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v2 = a1 + 8;
  v1 = *(void **)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 8) - (_QWORD)v1;
  if (v3)
  {
    v4 = v3 >> 1;
    if (v4 <= 1)
      v4 = 1;
    bzero(v1, 2 * v4);
  }
}

uint64_t sub_20BDE2F90(uint64_t result, __int16 *a2)
{
  _WORD *v2;
  uint64_t v3;
  unint64_t v4;
  __int16 v5;

  v2 = *(_WORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 1;
    if (v4 <= 1)
      v4 = 1;
    do
    {
      v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_20BDE2FBC(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  int v9;

  v2 = *(unsigned __int16 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 1;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_20BDE3024(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  int v9;

  v2 = *(unsigned __int16 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 1;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_20BDE308C(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  char v8;
  unint64_t v9;
  BOOL v10;

  v2 = *(unsigned __int16 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 1;
    if (v4 <= 1)
      v5 = 1;
    else
      v5 = v4;
    v6 = *v2;
    v7 = *a2;
    if (v6 >= v7)
    {
      v9 = 1;
      v10 = 1;
      while (v6 <= v7)
      {
        v10 = v9 < v4;
        if (v5 == v9)
          goto LABEL_14;
        v6 = v2[v9];
        v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      v8 = v10 & v2;
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_20BDE3114(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE311C(_QWORD *a1, uint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE3190(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_20BDE3174(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_20BDE3190(_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 < 0)
    sub_20BDDF694();
  result = (char *)sub_20BDE31CC((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void *sub_20BDE31CC(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    sub_20BDDF5B4();
  return operator new(2 * a2);
}

_QWORD *sub_20BDE31FC(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C5171F0;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE3238(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C5171F0;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void sub_20BDE3274(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v2 = a1 + 8;
  v1 = *(void **)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 8) - (_QWORD)v1;
  if (v3)
  {
    v4 = v3 >> 1;
    if (v4 <= 1)
      v4 = 1;
    bzero(v1, 2 * v4);
  }
}

uint64_t sub_20BDE3298(uint64_t result, __int16 *a2)
{
  _WORD *v2;
  uint64_t v3;
  unint64_t v4;
  __int16 v5;

  v2 = *(_WORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 1;
    if (v4 <= 1)
      v4 = 1;
    do
    {
      v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_20BDE32C4(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  int v9;

  v2 = *(unsigned __int16 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 1;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_20BDE332C(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  int v9;

  v2 = *(unsigned __int16 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 1;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_20BDE3394(uint64_t a1, __int16 *a2)
{
  __int16 *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  char v8;
  unint64_t v9;
  BOOL v10;

  v2 = *(__int16 **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 1;
    if (v4 <= 1)
      v5 = 1;
    else
      v5 = v4;
    v6 = *v2;
    v7 = *a2;
    if (v6 >= v7)
    {
      v9 = 1;
      v10 = 1;
      while ((__int16)v6 <= (__int16)v7)
      {
        v10 = v9 < v4;
        if (v5 == v9)
          goto LABEL_14;
        v6 = v2[v9];
        v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      v8 = v10 & v2;
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_20BDE3420(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE3428(_QWORD *a1, uint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE3190(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_20BDE3480(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDE349C(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C517258;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE34D8(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C517258;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void sub_20BDE3514(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v2 = a1 + 8;
  v1 = *(void **)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 8) - (_QWORD)v1;
  if (v3)
  {
    v4 = v3 >> 2;
    if (v4 <= 1)
      v4 = 1;
    bzero(v1, 4 * v4);
  }
}

uint64_t sub_20BDE3538(uint64_t result, int *a2)
{
  _DWORD *v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  v2 = *(_DWORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 2;
    if (v4 <= 1)
      v4 = 1;
    do
    {
      v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_20BDE3564(uint64_t a1, _DWORD *a2)
{
  _DWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  int v9;

  v2 = *(_DWORD **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 2;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_20BDE35CC(uint64_t a1, _DWORD *a2)
{
  _DWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  int v9;

  v2 = *(_DWORD **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 2;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_20BDE3634(uint64_t a1, unsigned int *a2)
{
  unsigned int *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  char v8;
  unint64_t v9;
  BOOL v10;

  v2 = *(unsigned int **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 2;
    if (v4 <= 1)
      v5 = 1;
    else
      v5 = v4;
    v6 = *v2;
    v7 = *a2;
    if (*v2 >= *a2)
    {
      v9 = 1;
      v10 = 1;
      while (v6 <= v7)
      {
        v10 = v9 < v4;
        if (v5 == v9)
          goto LABEL_14;
        v6 = v2[v9];
        v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      v8 = v10 & v2;
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_20BDE36BC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE36C4(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE3738(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_20BDE371C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_20BDE3738(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    sub_20BDDF694();
  result = (char *)sub_20BDE1330((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

_QWORD *sub_20BDE3778(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C5172C0;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE37B4(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C5172C0;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void sub_20BDE37F0(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v2 = a1 + 8;
  v1 = *(void **)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 8) - (_QWORD)v1;
  if (v3)
  {
    v4 = v3 >> 2;
    if (v4 <= 1)
      v4 = 1;
    bzero(v1, 4 * v4);
  }
}

uint64_t sub_20BDE3814(uint64_t result, int *a2)
{
  _DWORD *v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  v2 = *(_DWORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 2;
    if (v4 <= 1)
      v4 = 1;
    do
    {
      v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_20BDE3840(uint64_t a1, _DWORD *a2)
{
  _DWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  int v9;

  v2 = *(_DWORD **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 2;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_20BDE38A8(uint64_t a1, _DWORD *a2)
{
  _DWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  int v9;

  v2 = *(_DWORD **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 2;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_20BDE3910(uint64_t a1, int *a2)
{
  int *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  char v8;
  unint64_t v9;
  BOOL v10;

  v2 = *(int **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 2;
    if (v4 <= 1)
      v5 = 1;
    else
      v5 = v4;
    v6 = *v2;
    v7 = *a2;
    if (*v2 >= *a2)
    {
      v9 = 1;
      v10 = 1;
      while (v6 <= v7)
      {
        v10 = v9 < v4;
        if (v5 == v9)
          goto LABEL_14;
        v6 = v2[v9];
        v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      v8 = v10 & v2;
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_20BDE3998(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE39A0(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE3738(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_20BDE39F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDE3A14(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C517328;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE3A50(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C517328;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void sub_20BDE3A8C(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v2 = a1 + 8;
  v1 = *(void **)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 8) - (_QWORD)v1;
  if (v3)
  {
    v4 = v3 >> 3;
    if (v4 <= 1)
      v4 = 1;
    bzero(v1, 8 * v4);
  }
}

uint64_t sub_20BDE3AB0(uint64_t result, uint64_t *a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 3;
    if (v4 <= 1)
      v4 = 1;
    do
    {
      v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_20BDE3ADC(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 3;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_20BDE3B44(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 3;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_20BDE3BAC(uint64_t a1, unint64_t *a2)
{
  unint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  unint64_t v9;
  BOOL v10;

  v2 = *(unint64_t **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 3;
    if (v4 <= 1)
      v5 = 1;
    else
      v5 = v4;
    v6 = *v2;
    v7 = *a2;
    if (*v2 >= *a2)
    {
      v9 = 1;
      v10 = 1;
      while (v6 <= v7)
      {
        v10 = v9 < v4;
        if (v5 == v9)
          goto LABEL_14;
        v6 = v2[v9];
        v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      v8 = v10 & v2;
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_20BDE3C34(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE3C3C(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDDF654(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_20BDE3C94(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDE3CB0(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C517390;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE3CEC(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C517390;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void sub_20BDE3D28(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v2 = a1 + 8;
  v1 = *(void **)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 8) - (_QWORD)v1;
  if (v3)
  {
    v4 = v3 >> 3;
    if (v4 <= 1)
      v4 = 1;
    bzero(v1, 8 * v4);
  }
}

uint64_t sub_20BDE3D4C(uint64_t result, uint64_t *a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 3;
    if (v4 <= 1)
      v4 = 1;
    do
    {
      v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_20BDE3D78(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 3;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_20BDE3DE0(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 3;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v6 = 1;
  do
  {
    v7 = v6;
    if (v5 == v6)
      break;
    v8 = v2[v6];
    v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_20BDE3E48(uint64_t a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  unint64_t v9;
  BOOL v10;

  v2 = *(uint64_t **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 3;
    if (v4 <= 1)
      v5 = 1;
    else
      v5 = v4;
    v6 = *v2;
    v7 = *a2;
    if (*v2 >= *a2)
    {
      v9 = 1;
      v10 = 1;
      while (v6 <= v7)
      {
        v10 = v9 < v4;
        if (v5 == v9)
          goto LABEL_14;
        v6 = v2[v9];
        v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      v8 = v10 & v2;
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_20BDE3ED0(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE3ED8(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDDF654(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_20BDE3F30(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDE3F4C(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C5173F8;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE3F88(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C5173F8;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void sub_20BDE3FC4(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v2 = a1 + 8;
  v1 = *(void **)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 8) - (_QWORD)v1;
  if (v3)
  {
    v4 = v3 >> 1;
    if (v4 <= 1)
      v4 = 1;
    bzero(v1, 2 * v4);
  }
}

uint64_t sub_20BDE3FE8(uint64_t result, __int16 *a2)
{
  _WORD *v2;
  uint64_t v3;
  unint64_t v4;
  __int16 v5;

  v2 = *(_WORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 1;
    if (v4 <= 1)
      v4 = 1;
    do
    {
      v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_20BDE4014(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  float v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  float v25;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  v4 = v3 - v2;
  if (v3 == v2)
  {
    return 1;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    v7 = v4 >> 1;
    if (v7 <= 1)
      v8 = 1;
    else
      v8 = v7;
    do
    {
      v9 = *(__int16 *)(v2 + 2 * v6);
      v10 = (v9 & 0x7FFF) << 13;
      v11 = v9 & 0x80000000;
      v12 = __clz(v10) - 8;
      v13 = (v11 | 0x38800000 | (v10 << v12)) - (v12 << 23);
      if (!v10)
        v13 = v11;
      v14 = v10 | v11;
      v15 = v14 | 0x7F800000;
      v16 = v14 + 939524096;
      if (v10 >> 23 > 0x1E)
        v16 = v15;
      if (v10 < 0x800000)
        v16 = v13;
      v17 = *(float *)&v16;
      v18 = *(__int16 *)(a2 + 2 * v6);
      v19 = (v18 & 0x7FFF) << 13;
      v20 = v18 & 0x80000000;
      v21 = __clz(v19) - 8;
      v22 = (v20 | 0x38800000 | (v19 << v21)) - (v21 << 23);
      if (!v19)
        v22 = v20;
      v23 = v19 | v20;
      v24 = v23 | 0x7F800000;
      LODWORD(v25) = v23 + 939524096;
      if (v19 >> 23 > 0x1E)
        v25 = *(float *)&v24;
      if (v19 < 0x800000)
        v25 = *(float *)&v22;
      if (v17 != v25)
        break;
      v5 = ++v6 >= v7;
    }
    while (v8 != v6);
  }
  return v5;
}

BOOL sub_20BDE4108(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  float v17;
  BOOL v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  float v26;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  v5 = v4 - v3;
  if (v4 == v3)
  {
    return 1;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = v5 >> 1;
    if (v8 <= 1)
      v9 = 1;
    else
      v9 = v8;
    do
    {
      v10 = *(__int16 *)(v3 + 2 * v7);
      v11 = (v10 & 0x7FFF) << 13;
      v12 = v10 & 0x80000000;
      v13 = __clz(v11) - 8;
      v14 = (v12 | 0x38800000 | (v11 << v13)) - (v13 << 23);
      if (!v11)
        v14 = v12;
      v15 = v11 | v12;
      v16 = v15 | 0x7F800000;
      LODWORD(v17) = v15 + 939524096;
      if (v11 >> 23 > 0x1E)
        v17 = *(float *)&v16;
      v18 = v11 >= 0x800000;
      v19 = *(__int16 *)(a2 + 2 * v7);
      if (!v18)
        v17 = *(float *)&v14;
      v20 = (v19 & 0x7FFF) << 13;
      v21 = v19 & 0x80000000;
      v22 = __clz(v20) - 8;
      v23 = (v21 | 0x38800000 | (v20 << v22)) - (v22 << 23);
      if (!v20)
        v23 = v21;
      v24 = v20 | v21;
      v25 = v24 | 0x7F800000;
      LODWORD(v26) = v24 + 939524096;
      if (v20 >> 23 > 0x1E)
        v26 = *(float *)&v25;
      if (v20 < 0x800000)
        v26 = *(float *)&v23;
      if (vabds_f32(v17, v26) >= a3)
        break;
      v6 = ++v7 >= v8;
    }
    while (v9 != v7);
  }
  return v6;
}

uint64_t sub_20BDE4204(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  BOOL v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  float v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  float v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  BOOL v24;
  int v25;
  int v26;
  float v27;
  float v28;
  float v29;
  int v30;
  unsigned int v31;
  char v32;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - v2;
  if (v3)
  {
    v4 = 0;
    v5 = v3 >> 1;
    if ((unint64_t)(v3 >> 1) <= 1)
      v6 = 1;
    else
      v6 = v3 >> 1;
    v7 = 1;
    while (1)
    {
      v8 = *(__int16 *)(v2 + 2 * v4);
      v9 = (v8 & 0x7FFF) << 13;
      v10 = v8 & 0x80000000;
      v11 = v9 >> 23;
      if (v9 < 0x800000)
      {
        v31 = __clz(v9) - 8;
        v12 = (v10 | 0x38800000 | (v9 << v31)) - (v31 << 23);
        if (!v9)
          v12 = v10;
      }
      else
      {
        v12 = (v9 | v10) + 939524096;
        if (v11 > 0x1E)
          v12 = v9 | v10 | 0x7F800000;
      }
      v13 = *(float *)&v12;
      v14 = *(__int16 *)(a2 + 2 * v4);
      v15 = (v14 & 0x7FFF) << 13;
      v16 = v14 & 0x80000000;
      v17 = __clz(v15) - 8;
      v18 = (v16 | 0x38800000 | (v15 << v17)) - (v17 << 23);
      if (v15)
        v19 = *(float *)&v18;
      else
        v19 = *(float *)&v16;
      if (v15 >> 23 <= 0x1E)
        v20 = (v15 | v16) + 939524096;
      else
        v20 = v15 | v16 | 0x7F800000;
      if (v15 >= 0x800000)
        v19 = *(float *)&v20;
      if (v13 < v19)
      {
        LOBYTE(v29) = 1;
        goto LABEL_42;
      }
      v21 = __clz(v9) - 8;
      v22 = (v10 | 0x38800000 | (v9 << v21)) - (v21 << 23);
      if (!v9)
        v22 = v10;
      v23 = v9 | v10;
      v24 = v11 > 0x1E;
      v25 = v23 | 0x7F800000;
      v26 = v23 + 939524096;
      if (v24)
        v26 = v25;
      v27 = v9 >= 0x800000 ? *(float *)&v26 : *(float *)&v22;
      v28 = v27;
      v29 = v15 ? *(float *)&v18 : *(float *)&v16;
      v30 = v15 >> 23 <= 0x1E ? (v15 | v16) + 939524096 : v15 | v16 | 0x7F800000;
      if (v15 >= 0x800000)
        v29 = *(float *)&v30;
      if (v28 > v29)
        break;
      v7 = ++v4 < v5;
      if (v6 == v4)
        goto LABEL_42;
    }
    LOBYTE(v29) = 0;
LABEL_42:
    v32 = v7 & LOBYTE(v29);
  }
  else
  {
    v32 = 0;
  }
  return v32 & 1;
}

uint64_t sub_20BDE437C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE4384(_QWORD *a1, uint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE3190(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_20BDE43DC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDE43F8(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C517460;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE4434(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C517460;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void sub_20BDE4470(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v2 = a1 + 8;
  v1 = *(void **)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 8) - (_QWORD)v1;
  if (v3)
  {
    v4 = v3 >> 2;
    if (v4 <= 1)
      v4 = 1;
    bzero(v1, 4 * v4);
  }
}

float sub_20BDE4494(uint64_t a1, float *a2)
{
  float *v2;
  uint64_t v3;
  unint64_t v4;
  float v5;
  float result;

  v2 = *(float **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 2;
    if (v4 <= 1)
      v4 = 1;
    do
    {
      v5 = *a2++;
      result = v5;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_20BDE44C0(uint64_t a1, float *a2)
{
  float *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v8;
  float v9;
  float v10;

  v2 = *(float **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 2;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v7 = 1;
  do
  {
    v8 = v7;
    if (v5 == v7)
      break;
    v9 = v2[v7];
    v10 = a2[v7++];
  }
  while (v9 == v10);
  return v8 >= v4;
}

BOOL sub_20BDE4528(uint64_t a1, float *a2, double a3)
{
  float *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  double v9;

  v3 = *(float **)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v3;
  if (!v4)
    return 1;
  v5 = v4 >> 2;
  if (v5 <= 1)
    v6 = 1;
  else
    v6 = v5;
  if (vabds_f32(*v3, *a2) >= a3)
    return 0;
  v7 = 1;
  do
  {
    v8 = v7;
    if (v6 == v7)
      break;
    v9 = vabds_f32(v3[v7], a2[v7]);
    ++v7;
  }
  while (v9 < a3);
  return v8 >= v5;
}

uint64_t sub_20BDE45A0(uint64_t a1, float *a2)
{
  float *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  float v6;
  float v7;
  char v8;
  unint64_t v9;
  BOOL v10;

  v2 = *(float **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 2;
    if ((unint64_t)(v3 >> 2) <= 1)
      v5 = 1;
    else
      v5 = v3 >> 2;
    v6 = *v2;
    v7 = *a2;
    if (*v2 >= *a2)
    {
      v9 = 1;
      v10 = 1;
      while (v6 <= v7)
      {
        v10 = v9 < v4;
        if (v5 == v9)
          goto LABEL_14;
        v6 = v2[v9];
        v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      v8 = v10 & v2;
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_20BDE4628(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE4630(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE3738(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_20BDE4688(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDE46A4(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24C5174C8;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_20BDE46E0(_QWORD *__p)
{
  void *v2;

  *__p = &off_24C5174C8;
  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void sub_20BDE471C(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v2 = a1 + 8;
  v1 = *(void **)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 8) - (_QWORD)v1;
  if (v3)
  {
    v4 = v3 >> 3;
    if (v4 <= 1)
      v4 = 1;
    bzero(v1, 8 * v4);
  }
}

double sub_20BDE4740(uint64_t a1, double *a2)
{
  double *v2;
  uint64_t v3;
  unint64_t v4;
  double v5;
  double result;

  v2 = *(double **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 3;
    if (v4 <= 1)
      v4 = 1;
    do
    {
      v5 = *a2++;
      result = v5;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_20BDE476C(uint64_t a1, double *a2)
{
  double *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v8;
  double v9;
  double v10;

  v2 = *(double **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = v3 >> 3;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  if (*v2 != *a2)
    return 0;
  v7 = 1;
  do
  {
    v8 = v7;
    if (v5 == v7)
      break;
    v9 = v2[v7];
    v10 = a2[v7++];
  }
  while (v9 == v10);
  return v8 >= v4;
}

BOOL sub_20BDE47D4(uint64_t a1, double *a2, double a3)
{
  double *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  double v9;

  v3 = *(double **)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16) - (_QWORD)v3;
  if (!v4)
    return 1;
  v5 = v4 >> 3;
  if (v5 <= 1)
    v6 = 1;
  else
    v6 = v5;
  if (vabdd_f64(*v3, *a2) >= a3)
    return 0;
  v7 = 1;
  do
  {
    v8 = v7;
    if (v6 == v7)
      break;
    v9 = vabdd_f64(v3[v7], a2[v7]);
    ++v7;
  }
  while (v9 < a3);
  return v8 >= v5;
}

uint64_t sub_20BDE4844(uint64_t a1, double *a2)
{
  double *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  double v6;
  double v7;
  char v8;
  unint64_t v9;
  BOOL v10;

  v2 = *(double **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v3)
  {
    v4 = v3 >> 3;
    if ((unint64_t)(v3 >> 3) <= 1)
      v5 = 1;
    else
      v5 = v3 >> 3;
    v6 = *v2;
    v7 = *a2;
    if (*v2 >= *a2)
    {
      v9 = 1;
      v10 = 1;
      while (v6 <= v7)
      {
        v10 = v9 < v4;
        if (v5 == v9)
          goto LABEL_14;
        v6 = v2[v9];
        v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      v8 = v10 & v2;
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_20BDE48CC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE48D4(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDDF654(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_20BDE492C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDE4948(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v9;
  uint64_t v10;

  v2 = a2;
  *a1 = off_24C517530;
  v4 = a1 + 1;
  sub_20BDE4F04(a1 + 1, a2);
  if (v2)
  {
    v5 = 0;
    do
    {
      sub_20BDDC0E4(&v9, "");
      v6 = *v4 + v5;
      if (*(char *)(v6 + 23) < 0)
        operator delete(*(void **)v6);
      v7 = v9;
      *(_QWORD *)(v6 + 16) = v10;
      *(_OWORD *)v6 = v7;
      v5 += 24;
      --v2;
    }
    while (v2);
  }
  return a1;
}

void sub_20BDE49EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDE5038((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE4A04(uint64_t a1)
{
  void **v3;

  *(_QWORD *)a1 = off_24C517530;
  v3 = (void **)(a1 + 8);
  sub_20BDE5038(&v3);
  return a1;
}

void sub_20BDE4A48(char *a1)
{
  void **v2;

  *(_QWORD *)a1 = off_24C517530;
  v2 = (void **)(a1 + 8);
  sub_20BDE5038(&v2);
  operator delete(a1);
}

__n128 sub_20BDE4A90(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __n128 result;
  __n128 v8;
  uint64_t v9;

  v1 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
  if (v1)
  {
    v3 = 0;
    v4 = v1 / 24;
    if (v4 <= 1)
      v5 = 1;
    else
      v5 = v4;
    do
    {
      sub_20BDDC0E4(&v8, "");
      v6 = *(_QWORD *)(a1 + 8) + v3;
      if (*(char *)(v6 + 23) < 0)
        operator delete(*(void **)v6);
      result = v8;
      *(_QWORD *)(v6 + 16) = v9;
      *(__n128 *)v6 = result;
      v3 += 24;
      --v5;
    }
    while (v5);
  }
  return result;
}

std::string *sub_20BDE4B3C(std::string *result, uint64_t a2)
{
  int64_t v2;
  std::string *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;

  v2 = result->__r_.__value_.__r.__words[2] - result->__r_.__value_.__l.__size_;
  if (v2)
  {
    v4 = result;
    v5 = 0;
    v6 = v2 / 24;
    if (v6 <= 1)
      v7 = 1;
    else
      v7 = v6;
    do
    {
      result = std::string::operator=((std::string *)(v4->__r_.__value_.__l.__size_ + v5), (const std::string *)(a2 + v5));
      v5 += 24;
      --v7;
    }
    while (v7);
  }
  return result;
}

BOOL sub_20BDE4BB0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 **v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - v2;
  if (v3)
  {
    v5 = 0;
    v6 = 0;
    v7 = (unsigned __int128)(v3 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    v8 = (v7 >> 2) + ((unint64_t)v7 >> 63);
    if (v8 <= 1)
      v9 = 1;
    else
      v9 = (v7 >> 2) + ((unint64_t)v7 >> 63);
    do
    {
      v10 = (unsigned __int8 *)(v2 + 24 * v6);
      v11 = (unsigned __int8 **)(a2 + 24 * v6);
      v12 = v10[23];
      if ((v12 & 0x80u) == 0)
        v13 = (unsigned __int8 *)v10[23];
      else
        v13 = (unsigned __int8 *)*((_QWORD *)v10 + 1);
      v14 = (unsigned __int8 *)*((unsigned __int8 *)v11 + 23);
      v15 = (char)v14;
      if ((char)v14 < 0)
        v14 = v11[1];
      if (v13 != v14)
        break;
      if (v15 >= 0)
        v16 = (unsigned __int8 *)(a2 + 24 * v6);
      else
        v16 = *v11;
      if ((v12 & 0x80) != 0)
      {
        if (memcmp(*(const void **)v10, v16, *((_QWORD *)v10 + 1)))
          return v5;
      }
      else if (v10[23])
      {
        while (*v10 == *v16)
        {
          ++v10;
          ++v16;
          if (!--v12)
            goto LABEL_20;
        }
        return v5;
      }
LABEL_20:
      v5 = ++v6 >= v8;
    }
    while (v6 != v9);
  }
  else
  {
    return 1;
  }
  return v5;
}

BOOL sub_20BDE4CB0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 **v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - v2;
  if (v3)
  {
    v5 = 0;
    v6 = 0;
    v7 = (unsigned __int128)(v3 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    v8 = (v7 >> 2) + ((unint64_t)v7 >> 63);
    if (v8 <= 1)
      v9 = 1;
    else
      v9 = (v7 >> 2) + ((unint64_t)v7 >> 63);
    do
    {
      v10 = (unsigned __int8 *)(v2 + 24 * v6);
      v11 = (unsigned __int8 **)(a2 + 24 * v6);
      v12 = v10[23];
      if ((v12 & 0x80u) == 0)
        v13 = (unsigned __int8 *)v10[23];
      else
        v13 = (unsigned __int8 *)*((_QWORD *)v10 + 1);
      v14 = (unsigned __int8 *)*((unsigned __int8 *)v11 + 23);
      v15 = (char)v14;
      if ((char)v14 < 0)
        v14 = v11[1];
      if (v13 != v14)
        break;
      if (v15 >= 0)
        v16 = (unsigned __int8 *)(a2 + 24 * v6);
      else
        v16 = *v11;
      if ((v12 & 0x80) != 0)
      {
        if (memcmp(*(const void **)v10, v16, *((_QWORD *)v10 + 1)))
          return v5;
      }
      else if (v10[23])
      {
        while (*v10 == *v16)
        {
          ++v10;
          ++v16;
          if (!--v12)
            goto LABEL_20;
        }
        return v5;
      }
LABEL_20:
      v5 = ++v6 >= v8;
    }
    while (v6 != v9);
  }
  else
  {
    return 1;
  }
  return v5;
}

uint64_t sub_20BDE4DB0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  BOOL v9;
  int v10;
  int v11;
  size_t v12;
  const void *v13;
  size_t v14;
  const void *v15;
  size_t v16;
  int v17;
  BOOL v18;
  int v19;
  uint64_t v21;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16) - v2;
  if (v3)
  {
    v4 = 0;
    v5 = 0;
    v6 = (unsigned __int128)(v3 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    v7 = (v6 >> 2) + ((unint64_t)v6 >> 63);
    if (v7 <= 1)
      v8 = 1;
    else
      v8 = (v6 >> 2) + ((unint64_t)v6 >> 63);
    v21 = v8;
    v9 = 1;
    while (1)
    {
      v10 = *(char *)(a2 + v4 + 23);
      v11 = *(char *)(v2 + v4 + 23);
      if (v11 >= 0)
        v12 = *(unsigned __int8 *)(v2 + v4 + 23);
      else
        v12 = *(_QWORD *)(v2 + v4 + 8);
      if (v11 >= 0)
        v13 = (const void *)(v2 + v4);
      else
        v13 = *(const void **)(v2 + v4);
      if (v10 >= 0)
        v14 = *(unsigned __int8 *)(a2 + v4 + 23);
      else
        v14 = *(_QWORD *)(a2 + v4 + 8);
      if (v10 >= 0)
        v15 = (const void *)(a2 + v4);
      else
        v15 = *(const void **)(a2 + v4);
      if (v14 >= v12)
        v16 = v12;
      else
        v16 = v14;
      v17 = memcmp(v13, v15, v16);
      v18 = v12 < v14;
      if (v17)
        v18 = v17 < 0;
      if (v18)
      {
        LOBYTE(v3) = 1;
        goto LABEL_31;
      }
      v19 = memcmp(v15, v13, v16);
      LODWORD(v3) = v14 < v12;
      if (v19)
        LODWORD(v3) = v19 < 0;
      if ((_DWORD)v3 == 1)
        break;
      v9 = ++v5 < v7;
      v4 += 24;
      if (v21 == v5)
        goto LABEL_31;
    }
    LOBYTE(v3) = 0;
LABEL_31:
    LOBYTE(v3) = v9 & v3;
  }
  return v3 & 1;
}

uint64_t sub_20BDE4EFC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE4F04(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE4FA4(a1, a2);
    v4 = (char *)a1[1];
    v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_20BDE4F90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_20BDE5038(&a9);
  _Unwind_Resume(a1);
}

char *sub_20BDE4FA4(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    sub_20BDDF694();
  result = (char *)sub_20BDE4FF4((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *sub_20BDE4FF4(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    sub_20BDDF5B4();
  return operator new(24 * a2);
}

void sub_20BDE5038(void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    sub_20BDE5078((uint64_t *)v2);
    operator delete(**a1);
  }
}

void sub_20BDE5078(uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

_QWORD *sub_20BDE50C4(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v9;
  uint64_t v10;

  v2 = a2;
  *a1 = off_24C517598;
  v4 = a1 + 1;
  sub_20BDE5770(a1 + 1, a2);
  if (v2)
  {
    v5 = 0;
    do
    {
      sub_20BDE5810((uint64_t)&v9, &dword_20CA4F828);
      v6 = *v4 + v5;
      if (*(char *)(v6 + 23) < 0)
        operator delete(*(void **)v6);
      v7 = v9;
      *(_QWORD *)(v6 + 16) = v10;
      *(_OWORD *)v6 = v7;
      v5 += 24;
      --v2;
    }
    while (v2);
  }
  return a1;
}

void sub_20BDE5168(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDE5038((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE5180(uint64_t a1)
{
  void **v3;

  *(_QWORD *)a1 = off_24C517598;
  v3 = (void **)(a1 + 8);
  sub_20BDE5038(&v3);
  return a1;
}

void sub_20BDE51C4(char *a1)
{
  void **v2;

  *(_QWORD *)a1 = off_24C517598;
  v2 = (void **)(a1 + 8);
  sub_20BDE5038(&v2);
  operator delete(a1);
}

__n128 sub_20BDE520C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __n128 result;
  __n128 v8;
  uint64_t v9;

  v1 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
  if (v1)
  {
    v3 = 0;
    v4 = v1 / 24;
    if (v4 <= 1)
      v5 = 1;
    else
      v5 = v4;
    do
    {
      sub_20BDE5810((uint64_t)&v8, &dword_20CA4F828);
      v6 = *(_QWORD *)(a1 + 8) + v3;
      if (*(char *)(v6 + 23) < 0)
        operator delete(*(void **)v6);
      result = v8;
      *(_QWORD *)(v6 + 16) = v9;
      *(__n128 *)v6 = result;
      v3 += 24;
      --v5;
    }
    while (v5);
  }
  return result;
}

std::wstring *sub_20BDE52B8(std::wstring *result, uint64_t a2)
{
  int64_t v2;
  std::wstring *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;

  v2 = result->__r_.__value_.__r.__words[2] - result->__r_.__value_.__l.__size_;
  if (v2)
  {
    v4 = result;
    v5 = 0;
    v6 = v2 / 24;
    if (v6 <= 1)
      v7 = 1;
    else
      v7 = v6;
    do
    {
      result = std::wstring::operator=((std::wstring *)(v4->__r_.__value_.__l.__size_ + v5), (const std::wstring *)(a2 + v5));
      v5 += 24;
      --v7;
    }
    while (v7);
  }
  return result;
}

BOOL sub_20BDE532C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  size_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  unint64_t v16;
  const __int32 *v17;
  const __int32 *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;

  v2 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v5 = (unsigned __int128)(v2 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    v6 = (v5 >> 2) + ((unint64_t)v5 >> 63);
    if (v6 <= 1)
      v7 = 1;
    else
      v7 = (v5 >> 2) + ((unint64_t)v5 >> 63);
    v8 = *(_QWORD *)(a1 + 8);
    v9 = *(char *)(v8 + 23) < 0;
    if (*(char *)(v8 + 23) >= 0)
      v10 = *(unsigned __int8 *)(v8 + 23);
    else
      v10 = *(_QWORD *)(v8 + 8);
    v11 = *(char *)(a2 + 23) < 0;
    v12 = *(unsigned __int8 *)(a2 + 23);
    if ((v12 & 0x80u) != 0)
      v12 = *(_QWORD *)(a2 + 8);
    if (v10 == v12)
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 1;
      do
      {
        if (v10)
        {
          v17 = v11 ? *(const __int32 **)(a2 + v13) : (const __int32 *)(a2 + v13);
          v18 = v9 ? *(const __int32 **)v8 : (const __int32 *)v8;
          if (wmemcmp(v18, v17, v10))
            break;
        }
        v15 = v16 >= v6;
        if (v7 == v16)
          break;
        ++v14;
        v19 = *(_QWORD *)(a1 + 8);
        v8 = v19 + 24 * v14;
        v20 = v19 + v13;
        v21 = *(char *)(v19 + v13 + 47);
        v9 = v21 < 0;
        v22 = *(_QWORD *)(v20 + 32);
        v10 = v21 >= 0 ? v21 : v22;
        v11 = *(char *)(a2 + v13 + 47) < 0;
        v23 = *(_QWORD *)(a2 + v13 + 32);
        if (*(char *)(a2 + v13 + 47) >= 0)
          v23 = *(unsigned __int8 *)(a2 + v13 + 47);
        v13 += 24;
        ++v16;
      }
      while (v10 == v23);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 1;
  }
  return v15;
}

BOOL sub_20BDE5488(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  size_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  unint64_t v16;
  const __int32 *v17;
  const __int32 *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;

  v2 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v5 = (unsigned __int128)(v2 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    v6 = (v5 >> 2) + ((unint64_t)v5 >> 63);
    if (v6 <= 1)
      v7 = 1;
    else
      v7 = (v5 >> 2) + ((unint64_t)v5 >> 63);
    v8 = *(_QWORD *)(a1 + 8);
    v9 = *(char *)(v8 + 23) < 0;
    if (*(char *)(v8 + 23) >= 0)
      v10 = *(unsigned __int8 *)(v8 + 23);
    else
      v10 = *(_QWORD *)(v8 + 8);
    v11 = *(char *)(a2 + 23) < 0;
    v12 = *(unsigned __int8 *)(a2 + 23);
    if ((v12 & 0x80u) != 0)
      v12 = *(_QWORD *)(a2 + 8);
    if (v10 == v12)
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 1;
      do
      {
        if (v10)
        {
          v17 = v11 ? *(const __int32 **)(a2 + v13) : (const __int32 *)(a2 + v13);
          v18 = v9 ? *(const __int32 **)v8 : (const __int32 *)v8;
          if (wmemcmp(v18, v17, v10))
            break;
        }
        v15 = v16 >= v6;
        if (v7 == v16)
          break;
        ++v14;
        v19 = *(_QWORD *)(a1 + 8);
        v8 = v19 + 24 * v14;
        v20 = v19 + v13;
        v21 = *(char *)(v19 + v13 + 47);
        v9 = v21 < 0;
        v22 = *(_QWORD *)(v20 + 32);
        v10 = v21 >= 0 ? v21 : v22;
        v11 = *(char *)(a2 + v13 + 47) < 0;
        v23 = *(_QWORD *)(a2 + v13 + 32);
        if (*(char *)(a2 + v13 + 47) >= 0)
          v23 = *(unsigned __int8 *)(a2 + v13 + 47);
        v13 += 24;
        ++v16;
      }
      while (v10 == v23);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 1;
  }
  return v15;
}

uint64_t sub_20BDE55E4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  size_t v17;
  const __int32 *v18;
  const __int32 *v19;
  int v20;
  int v21;
  unint64_t v22;
  int v23;
  unint64_t v24;
  size_t v25;
  const __int32 *v26;
  const __int32 *v27;
  int v28;

  v2 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
  if (!v2)
    return v2 & 1;
  v5 = 0;
  v6 = 0;
  v7 = (unsigned __int128)(v2 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
  v8 = (v7 >> 2) + ((unint64_t)v7 >> 63);
  if (v8 <= 1)
    v9 = 1;
  else
    v9 = (v7 >> 2) + ((unint64_t)v7 >> 63);
  v10 = 1;
  while (1)
  {
    v11 = *(_QWORD *)(a1 + 8) + v5;
    v12 = a2 + v5;
    v13 = *(char *)(a2 + v5 + 23);
    v14 = v13 >= 0 ? *(unsigned __int8 *)(a2 + v5 + 23) : *(_QWORD *)(a2 + v5 + 8);
    v15 = *(char *)(v11 + 23);
    v16 = v15 >= 0 ? *(unsigned __int8 *)(v11 + 23) : *(_QWORD *)(v11 + 8);
    v17 = v14 >= v16 ? v16 : v14;
    if (v17
      && (v15 >= 0 ? (v18 = (const __int32 *)(*(_QWORD *)(a1 + 8) + v5)) : (v18 = *(const __int32 **)v11),
          v13 >= 0 ? (v19 = (const __int32 *)(a2 + v5)) : (v19 = *(const __int32 **)v12),
          (v20 = wmemcmp(v18, v19, v17)) != 0))
    {
      if (v20 < 0)
        goto LABEL_48;
    }
    else if (v16 < v14)
    {
LABEL_48:
      LOBYTE(v2) = 1;
      goto LABEL_50;
    }
    v2 = *(_QWORD *)(a1 + 8) + v5;
    v21 = *(char *)(v2 + 23);
    v22 = v21 >= 0 ? *(unsigned __int8 *)(v2 + 23) : *(_QWORD *)(v2 + 8);
    v23 = *(char *)(v12 + 23);
    v24 = v23 >= 0 ? *(unsigned __int8 *)(v12 + 23) : *(_QWORD *)(v12 + 8);
    v25 = v22 >= v24 ? v24 : v22;
    if (!v25)
      break;
    v26 = v23 >= 0 ? (const __int32 *)(a2 + v5) : *(const __int32 **)v12;
    v27 = v21 >= 0 ? (const __int32 *)(*(_QWORD *)(a1 + 8) + v5) : *(const __int32 **)v2;
    v28 = wmemcmp(v26, v27, v25);
    if (!v28)
      break;
    if (v28 < 0)
      goto LABEL_49;
LABEL_46:
    v10 = ++v6 < v8;
    v5 += 24;
    if (v9 == v6)
      goto LABEL_50;
  }
  if (v24 >= v22)
    goto LABEL_46;
LABEL_49:
  LOBYTE(v2) = 0;
LABEL_50:
  LOBYTE(v2) = v10 & v2;
  return v2 & 1;
}

uint64_t sub_20BDE5768(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

_QWORD *sub_20BDE5770(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE4FA4(a1, a2);
    v4 = (char *)a1[1];
    v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_20BDE57FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_20BDE5038(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE5810(uint64_t a1, __int32 *a2)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = wcslen(a2);
  if (v4 >= 0x3FFFFFFFFFFFFFF8)
    sub_20BDDC038();
  v5 = v4;
  if (v4 >= 5)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 2;
    if ((v4 | 1) != 5)
      v7 = v4 | 1;
    v6 = sub_20BDE1330(a1, v7 + 1);
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)(a1 + 16) = v8 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_BYTE *)(a1 + 23) = v4;
    v6 = (void *)a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, a2, 4 * v5);
LABEL_9:
  *((_DWORD *)v6 + v5) = 0;
  return a1;
}

void Alembic::AbcCoreAbstract::v12::BasePropertyWriter::asScalarPtr(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void Alembic::AbcCoreAbstract::v12::BasePropertyWriter::asArrayPtr(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void Alembic::AbcCoreAbstract::v12::BasePropertyWriter::asCompoundPtr(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter::getProperty(Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *this)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *))(*(_QWORD *)this + 72))(this);
  return (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *, uint64_t))(*(_QWORD *)this + 88))(this, v2);
}

uint64_t Alembic::AbcCoreAbstract::v12::ObjectWriter::getChild(Alembic::AbcCoreAbstract::v12::ObjectWriter *this)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::ObjectWriter *))(*(_QWORD *)this + 56))(this);
  return (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::ObjectWriter *, uint64_t))(*(_QWORD *)this + 72))(this, v2);
}

void Alembic::AbcCoreAbstract::v12::BasePropertyReader::asScalarPtr(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void Alembic::AbcCoreAbstract::v12::BasePropertyReader::asArrayPtr(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void Alembic::AbcCoreAbstract::v12::BasePropertyReader::asCompoundPtr(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

double Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::getProperty@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double result;
  int v6;
  __int128 v7;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
  if (v4)
  {
    v6 = *(_DWORD *)(v4 + 24);
    if (v6)
    {
      if (v6 == 2)
        (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)a1 + 96))(&v7, a1, v4);
      else
        (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)a1 + 88))(&v7, a1, v4);
    }
    else
    {
      (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)a1 + 104))(&v7, a1, v4);
    }
    result = *(double *)&v7;
    *(_OWORD *)a2 = v7;
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
  return result;
}

uint64_t Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::getScalarProperty@<X0>(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *))(*(_QWORD *)this + 72))(this);
  if (*(_DWORD *)(result + 24) == 1)
    return (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(_QWORD *)this + 88))(this, result);
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::getArrayProperty@<X0>(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *))(*(_QWORD *)this + 72))(this);
  if (*(_DWORD *)(result + 24) == 2)
    return (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(_QWORD *)this + 96))(this, result);
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::getCompoundProperty@<X0>(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *))(*(_QWORD *)this + 72))(this);
  if (!*(_DWORD *)(result + 24))
    return (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(_QWORD *)this + 104))(this, result);
  *a2 = 0;
  a2[1] = 0;
  return result;
}

double Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::getProperty@<D0>(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *this@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v4;
  int v5;
  double result;
  __int128 v7;

  v4 = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *))(*(_QWORD *)this + 72))(this);
  v5 = *(_DWORD *)(v4 + 24);
  if (v5)
  {
    if (v5 == 2)
      (*(void (**)(__int128 *__return_ptr, Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(_QWORD *)this + 96))(&v7, this, v4);
    else
      (*(void (**)(__int128 *__return_ptr, Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(_QWORD *)this + 88))(&v7, this, v4);
  }
  else
  {
    (*(void (**)(__int128 *__return_ptr, Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(_QWORD *)this + 104))(&v7, this, v4);
  }
  result = *(double *)&v7;
  *a2 = v7;
  return result;
}

uint64_t Alembic::AbcCoreAbstract::v12::ObjectReader::getPropertiesHash()
{
  return 0;
}

uint64_t Alembic::AbcCoreAbstract::v12::ObjectReader::getChildrenHash()
{
  return 0;
}

_QWORD *sub_20BDE5C1C(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *exception;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *__p[2];
  char v23;
  _QWORD v24[4];
  _BYTE v25[16];
  _QWORD v26[33];

  result[1] = 0;
  result[2] = 0;
  *result = off_24C517CF0;
  result[3] = *a2;
  v4 = a2[1];
  result[4] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  result[5] = *a3;
  v7 = a3[1];
  result[6] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  result[7] = *a4;
  v10 = result + 7;
  v11 = a4[1];
  result[8] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (!result[3])
  {
    sub_20BDDBD68((uint64_t)v25);
    sub_20BDDC1C8(v26, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v24, (__int128 *)__p);
    if (v23 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v15 = sub_20BDDC09C(exception, (uint64_t)v24);
    __cxa_throw(v15, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!result[5])
  {
    sub_20BDDBD68((uint64_t)v25);
    sub_20BDDC1C8(v26, (uint64_t)"Invalid array property group", 28);
    std::stringbuf::str();
    sub_20BDDBF20(v24, (__int128 *)__p);
    if (v23 < 0)
      operator delete(__p[0]);
    v16 = __cxa_allocate_exception(0x20uLL);
    v17 = sub_20BDDC09C(v16, (uint64_t)v24);
    __cxa_throw(v17, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*v10)
  {
    sub_20BDDBD68((uint64_t)v25);
    sub_20BDDC1C8(v26, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v24, (__int128 *)__p);
    if (v23 < 0)
      operator delete(__p[0]);
    v18 = __cxa_allocate_exception(0x20uLL);
    v19 = sub_20BDDC09C(v18, (uint64_t)v24);
    __cxa_throw(v19, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (*(_DWORD *)(*v10 + 24) != 2)
  {
    sub_20BDDBD68((uint64_t)v25);
    sub_20BDDC1C8(v26, (uint64_t)"Attempted to create a ArrayPropertyReader from a non-array property type", 72);
    std::stringbuf::str();
    sub_20BDDBF20(v24, (__int128 *)__p);
    if (v23 < 0)
      operator delete(__p[0]);
    v20 = __cxa_allocate_exception(0x20uLL);
    v21 = sub_20BDDC09C(v20, (uint64_t)v24);
    __cxa_throw(v21, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return result;
}

void sub_20BDE5EDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  Alembic::AbcCoreAbstract::v12::ArrayPropertyReader *v4;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v5;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v6;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v7;
  std::__shared_weak_count *v9;
  std::exception v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v10.__vftable = va_arg(va1, std::exception_vtbl *);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v7);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v6);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v5);
  v9 = (std::__shared_weak_count *)*((_QWORD *)v4 + 2);
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  Alembic::AbcCoreAbstract::v12::ArrayPropertyReader::~ArrayPropertyReader(v4);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE5F6C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t sub_20BDE5F74(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 24))(*(_QWORD *)(a1 + 24));
}

uint64_t sub_20BDE5F84@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 32);
  *a2 = *(_QWORD *)(result + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

double sub_20BDE5FA8@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_20BDE5FE0(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 56) + 84);
}

BOOL sub_20BDE5FEC(uint64_t a1)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 56) + 88) == 0;
}

void sub_20BDE6000(uint64_t a1, unint64_t a2, uint64_t **a3)
{
  uint64_t v5;
  void *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  Alembic::Ogawa::v12::IData *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  Alembic::Ogawa::v12::IData *v40;
  std::__shared_weak_count *v41;
  void *v42;
  std::__shared_weak_count *v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  void *lpsrc;
  std::__shared_weak_count *v47;
  void *v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  std::__shared_weak_count *v51;

  v5 = sub_20BDE6388(*(unsigned int **)(a1 + 56), a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 24))(&v44, a1);
  (*(void (**)(void **__return_ptr))(*(_QWORD *)v44 + 24))(&lpsrc);
  if (lpsrc
  {
    v7 = v47;
    v48 = v6;
    v49 = v47;
    if (v47)
    {
      p_shared_owners = (unint64_t *)&v47->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v48 = 0;
    v49 = 0;
  }
  sub_20BDE9C40((uint64_t)v6, &v50);
  if (v7)
  {
    v10 = (unint64_t *)&v7->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v12 = v47;
  if (v47)
  {
    v13 = (unint64_t *)&v47->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = 2 * v5;
  v16 = v45;
  if (v45)
  {
    v17 = (unint64_t *)&v45->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = *(_QWORD *)(v50 + 8);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v15 | 1, v19, &v48);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v15, v19, &lpsrc);
  if (v48)
  {
    v20 = (Alembic::Ogawa::v12::IData *)lpsrc;
    if (lpsrc)
    {
      v42 = v48;
      v43 = v49;
      if (v49)
      {
        v21 = (unint64_t *)&v49->__shared_owners_;
        do
          v22 = __ldxr(v21);
        while (__stxr(v22 + 1, v21));
      }
      v40 = v20;
      v41 = v47;
      if (v47)
      {
        v23 = (unint64_t *)&v47->__shared_owners_;
        do
          v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
      }
      sub_20BDFAD30((uint64_t)&v42, &v40, v19, (int *)(*(_QWORD *)(a1 + 56) + 56), a3);
      v25 = v41;
      if (v41)
      {
        v26 = (unint64_t *)&v41->__shared_owners_;
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      v28 = v43;
      if (v43)
      {
        v29 = (unint64_t *)&v43->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
    }
  }
  v31 = v47;
  if (v47)
  {
    v32 = (unint64_t *)&v47->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v49;
  if (v49)
  {
    v35 = (unint64_t *)&v49->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = v51;
  if (v51)
  {
    v38 = (unint64_t *)&v51->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
}

void sub_20BDE631C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  uint64_t v17;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a11);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a15);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a17);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v17 - 48));
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE6388(unsigned int *a1, unint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  int v6;
  _QWORD *v8;
  _QWORD *exception;
  _QWORD *v10;
  __int128 __p;
  char v12;
  _QWORD v13[4];
  _BYTE v14[16];
  _QWORD v15[33];

  if ((a2 & 0x8000000000000000) != 0 || a1[21] <= a2)
  {
    sub_20BDDBD68((uint64_t)v14);
    sub_20BDDC1C8(v15, (uint64_t)"Invalid sample index: ", 22);
    v8 = (_QWORD *)std::ostream::operator<<();
    sub_20BDDC1C8(v8, (uint64_t)", should be between 0 and ", 26);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v13, &__p);
    if (v12 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v10 = sub_20BDDC09C(exception, (uint64_t)v13);
    __cxa_throw(v10, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v2 = a1[22];
  if (v2 <= a2)
  {
    v4 = a1[23];
    v5 = v4 | v2;
    v6 = a2 - v2;
    v3 = v4 - v2 + 1;
    if (v4 > a2)
      v3 = v6 + 1;
    if (!v5)
      return 0;
  }
  else
  {
    return 0;
  }
  return v3;
}

void sub_20BDE64A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  std::exception v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE64C8(uint64_t a1, double a2)
{
  uint64_t v3;
  double **v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t FloorIndex;
  unint64_t *v9;
  unint64_t v10;

  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(double ***)(v3 + 64);
  v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v3 = *(_QWORD *)(a1 + 56);
  }
  FloorIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5)
  {
    v9 = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return FloorIndex;
}

void sub_20BDE6568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE657C(uint64_t a1, double a2)
{
  uint64_t v3;
  double **v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t CeilIndex;
  unint64_t *v9;
  unint64_t v10;

  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(double ***)(v3 + 64);
  v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v3 = *(_QWORD *)(a1 + 56);
  }
  CeilIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getCeilIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5)
  {
    v9 = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return CeilIndex;
}

void sub_20BDE661C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE6630(uint64_t a1, double a2)
{
  uint64_t v3;
  double **v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(double ***)(v3 + 64);
  v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v3 = *(_QWORD *)(a1 + 56);
  }
  v8 = Alembic::AbcCoreAbstract::v12::TimeSampling::getNearIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5)
  {
    v9 = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return v8;
}

void sub_20BDE66D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

BOOL sub_20BDE66E4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  Alembic::Ogawa::v12::IData *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  Alembic::Ogawa::v12::IData *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v30;
  std::__shared_weak_count *v31;
  void *lpsrc;
  std::__shared_weak_count *v33;
  Alembic::Ogawa::v12::IData *v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;

  v5 = *(unsigned int **)(a1 + 56);
  v6 = v5[14];
  *(_DWORD *)(a3 + 8) = v6;
  *(_DWORD *)(a3 + 12) = v6;
  *(_QWORD *)a3 = 0;
  v7 = sub_20BDE6388(v5, a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 24))(&v30, a1);
  (*(void (**)(void **__return_ptr))(*(_QWORD *)v30 + 24))(&lpsrc);
  if (lpsrc
  {
    v9 = v33;
    v34 = v8;
    v35 = v33;
    if (v33)
    {
      p_shared_owners = (unint64_t *)&v33->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
  }
  else
  {
    v9 = 0;
    v8 = 0;
    v34 = 0;
    v35 = 0;
  }
  sub_20BDE9C40((uint64_t)v8, &v36);
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v14 = 2 * v7;
  v15 = v33;
  if (v33)
  {
    v16 = (unint64_t *)&v33->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v31;
  if (v31)
  {
    v19 = (unint64_t *)&v31->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = *(_QWORD *)(v36 + 8);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v14, v21, &v34);
  v22 = v34;
  if (v34 && (unint64_t)Alembic::Ogawa::v12::IData::getSize(v34) >= 0x10)
  {
    *(_QWORD *)a3 = Alembic::Ogawa::v12::IData::getSize(v34) - 16;
    Alembic::Ogawa::v12::IData::read((unint64_t **)v34, 16, (void *)(a3 + 16), 0, v21);
  }
  v23 = v35;
  if (v35)
  {
    v24 = (unint64_t *)&v35->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  v26 = v37;
  if (v37)
  {
    v27 = (unint64_t *)&v37->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  return v22 != 0;
}

void sub_20BDE692C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE6978(uint64_t a1)
{
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 56) + 80);
}

void sub_20BDE6984(uint64_t a1, unint64_t a2, void **a3)
{
  uint64_t v5;
  Alembic::Ogawa::v12::IData *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  Alembic::Ogawa::v12::IData *v39;
  std::__shared_weak_count *v40;
  Alembic::Ogawa::v12::IData *v41;
  std::__shared_weak_count *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  void *lpsrc;
  std::__shared_weak_count *v46;
  Alembic::Ogawa::v12::IData *v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  std::__shared_weak_count *v50;

  v5 = sub_20BDE6388(*(unsigned int **)(a1 + 56), a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 24))(&v43, a1);
  (*(void (**)(void **__return_ptr))(*(_QWORD *)v43 + 24))(&lpsrc);
  if (lpsrc
  {
    v7 = v46;
    v47 = v6;
    v48 = v46;
    if (v46)
    {
      p_shared_owners = (unint64_t *)&v46->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v47 = 0;
    v48 = 0;
  }
  sub_20BDE9C40((uint64_t)v6, &v49);
  if (v7)
  {
    v10 = (unint64_t *)&v7->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v12 = v46;
  if (v46)
  {
    v13 = (unint64_t *)&v46->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = 2 * v5;
  v16 = v44;
  if (v44)
  {
    v17 = (unint64_t *)&v44->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = *(_QWORD *)(v49 + 8);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v15 | 1, v19, &v47);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v15, v19, &lpsrc);
  v41 = v47;
  v42 = v48;
  if (v48)
  {
    v20 = (unint64_t *)&v48->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v39 = (Alembic::Ogawa::v12::IData *)lpsrc;
  v40 = v46;
  if (v46)
  {
    v22 = (unint64_t *)&v46->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  sub_20BDF79DC(&v41, &v39, v19, (int *)(*(_QWORD *)(a1 + 56) + 56), a3);
  v24 = v40;
  if (v40)
  {
    v25 = (unint64_t *)&v40->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v27 = v42;
  if (v42)
  {
    v28 = (unint64_t *)&v42->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v30 = v46;
  if (v46)
  {
    v31 = (unint64_t *)&v46->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = v48;
  if (v48)
  {
    v34 = (unint64_t *)&v48->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  v36 = v50;
  if (v50)
  {
    v37 = (unint64_t *)&v50->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
}

void sub_20BDE6C90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  uint64_t v17;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a11);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a15);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a17);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v17 - 48));
  _Unwind_Resume(a1);
}

void sub_20BDE6CFC(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7;
  Alembic::Ogawa::v12::IData *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  __n128 v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  Alembic::Ogawa::v12::IData *v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  void *lpsrc;
  std::__shared_weak_count *v39;
  Alembic::Ogawa::v12::IData *v40;
  std::__shared_weak_count *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;

  v7 = sub_20BDE6388(*(unsigned int **)(a1 + 56), a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 24))(&v36, a1);
  (*(void (**)(void **__return_ptr))(*(_QWORD *)v36 + 24))(&lpsrc);
  if (lpsrc
  {
    v9 = v39;
    v40 = v8;
    v41 = v39;
    if (v39)
    {
      p_shared_owners = (unint64_t *)&v39->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
  }
  else
  {
    v9 = 0;
    v8 = 0;
    v40 = 0;
    v41 = 0;
  }
  sub_20BDE9C40((uint64_t)v8, &v42);
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v14 = 2 * v7;
  v15 = v39;
  if (v39)
  {
    v16 = (unint64_t *)&v39->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v37;
  if (v37)
  {
    v19 = (unint64_t *)&v37->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = *(_QWORD *)(v42 + 8);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v14, v21, &v40);
  v34 = v40;
  v35 = v41;
  if (v41)
  {
    v22 = (unint64_t *)&v41->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  v24.n128_u64[0] = sub_20BDFA8FC(a3, &v34, v21, (int *)(*(_QWORD *)(a1 + 56) + 56), a4).n64_u64[0];
  v25 = v35;
  if (v35)
  {
    v26 = (unint64_t *)&v35->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v25->__on_zero_shared)(v25, v24);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v41;
  if (v41)
  {
    v29 = (unint64_t *)&v41->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v28->__on_zero_shared)(v28, v24);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v43;
  if (v43)
  {
    v32 = (unint64_t *)&v43->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v31->__on_zero_shared)(v31, v24);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
}

void sub_20BDE6F70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a15);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a17);
  _Unwind_Resume(a1);
}

void sub_20BDE6FC4(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = off_24C517CF0;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 7));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 5));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 3));
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  Alembic::AbcCoreAbstract::v12::ArrayPropertyReader::~ArrayPropertyReader((Alembic::AbcCoreAbstract::v12::ArrayPropertyReader *)a1);
}

void sub_20BDE7010(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  void *v3;

  *a1 = off_24C517CF0;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 7));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 5));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 3));
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  Alembic::AbcCoreAbstract::v12::ArrayPropertyReader::~ArrayPropertyReader((Alembic::AbcCoreAbstract::v12::ArrayPropertyReader *)a1);
  operator delete(v3);
}

void pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

_QWORD *sub_20BDE70B8(_QWORD *a1, _QWORD *a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  v3 = (std::__shared_weak_count *)a2[1];
  *a1 = *a2;
  if (!v3)
  {
    a1[1] = 0;
LABEL_5:
    sub_20BDE70F8();
  }
  v4 = std::__shared_weak_count::lock(v3);
  a1[1] = v4;
  if (!v4)
    goto LABEL_5;
  return a1;
}

void sub_20BDE70F8()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x24BEDB808] + 16;
  __cxa_throw(exception, MEMORY[0x24BEDB6D8], MEMORY[0x24BEDAC00]);
}

_QWORD *sub_20BDE712C(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD *exception;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *__p[2];
  char v28;
  _QWORD v29[4];
  _QWORD v30[2];
  _QWORD v31[33];

  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_24C517DD8;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = *a2;
  v7 = a2[1];
  a1[6] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  a1[7] = *a4;
  v10 = a1 + 7;
  v11 = a4[1];
  a1[8] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = *a3;
  v14 = a1 + 11;
  v15 = a3[1];
  a1[12] = v15;
  if (v15)
  {
    v16 = (unint64_t *)(v15 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v30[0] = 1;
  sub_20BDE8894(a1 + 13, 1uLL, v30);
  a1[16] = a5;
  if (!a1[5])
  {
    sub_20BDDBD68((uint64_t)v30);
    sub_20BDDC1C8(v31, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v29, (__int128 *)__p);
    if (v28 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v20 = sub_20BDDC09C(exception, (uint64_t)v29);
    __cxa_throw(v20, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*v10)
  {
    sub_20BDDBD68((uint64_t)v30);
    sub_20BDDC1C8(v31, (uint64_t)"Invalid property header", 23);
    std::stringbuf::str();
    sub_20BDDBF20(v29, (__int128 *)__p);
    if (v28 < 0)
      operator delete(__p[0]);
    v21 = __cxa_allocate_exception(0x20uLL);
    v22 = sub_20BDDC09C(v21, (uint64_t)v29);
    __cxa_throw(v22, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*v14)
  {
    sub_20BDDBD68((uint64_t)v30);
    sub_20BDDC1C8(v31, (uint64_t)"Invalid group", 13);
    std::stringbuf::str();
    sub_20BDDBF20(v29, (__int128 *)__p);
    if (v28 < 0)
      operator delete(__p[0]);
    v23 = __cxa_allocate_exception(0x20uLL);
    v24 = sub_20BDDC09C(v23, (uint64_t)v29);
    __cxa_throw(v24, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (*(_DWORD *)(*v10 + 24) != 2)
  {
    sub_20BDDBD68((uint64_t)v30);
    sub_20BDDC1C8(v31, (uint64_t)"Attempted to create a ArrayPropertyWriter from a non-array property type", 72);
    std::stringbuf::str();
    sub_20BDDBF20(v29, (__int128 *)__p);
    if (v28 < 0)
      operator delete(__p[0]);
    v25 = __cxa_allocate_exception(0x20uLL);
    v26 = sub_20BDDC09C(v25, (uint64_t)v29);
    __cxa_throw(v26, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return a1;
}

void sub_20BDE7428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  Alembic::AbcCoreAbstract::v12::ArrayPropertyWriter *v4;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v5;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v6;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v7;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v8;
  void **v9;
  void *v11;
  std::__shared_weak_count *v12;
  std::exception v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v13.__vftable = va_arg(va1, std::exception_vtbl *);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  v11 = *v9;
  if (*v9)
  {
    *((_QWORD *)v4 + 14) = v11;
    operator delete(v11);
  }
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v7);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v6);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v5);
  v12 = (std::__shared_weak_count *)*((_QWORD *)v4 + 2);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  Alembic::AbcCoreAbstract::v12::ArrayPropertyWriter::~ArrayPropertyWriter(v4);
  _Unwind_Resume(a1);
}

void sub_20BDE74D8(uint64_t a1)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  void *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  void *v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;

  *(_QWORD *)a1 = off_24C517DD8;
  v2 = (pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 40);
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a1 + 40) + 24))(&v24);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v24 + 24))(&v26);
  v3 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 72))(v26, *(unsigned int *)(*(_QWORD *)(a1 + 56) + 96));
  v7 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 84);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 92))
    v8 = v7;
  else
    v8 = v7 != 0;
  if (v6 < v8)
    (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v26 + 80))(v26, *(unsigned int *)(*(_QWORD *)(a1 + 56) + 96), v8);
  Alembic::Util::v12::SpookyHash::Init((uint64_t)&v24, 0, 0);
  sub_20BDFFE14(*(_QWORD *)(a1 + 56), (Alembic::Util::v12::SpookyHash *)&v24);
  if ((_DWORD)v8)
    Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)&v24, (_QWORD *)(a1 + 72), 0x10uLL);
  v22 = 0;
  v23 = 0;
  Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)&v24, &v23, (unint64_t *)&v22, v9, v10);
  v11 = *(void **)v2;
  if (*(_QWORD *)v2
  {
    v12 = *(std::__shared_weak_count **)(a1 + 48);
    if (v12)
    {
      v13 = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
  }
  else
  {
    v12 = 0;
  }
  sub_20BDF2A44((uint64_t)v11, *(_QWORD *)(a1 + 128), v23, v22);
  if (v12)
  {
    v15 = (unint64_t *)&v12->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v17 = v27;
  if (v27)
  {
    v18 = (unint64_t *)&v27->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = *(void **)(a1 + 104);
  if (v20)
  {
    *(_QWORD *)(a1 + 112) = v20;
    operator delete(v20);
  }
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 88));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 56));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v2);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 24));
  v21 = *(std::__shared_weak_count **)(a1 + 16);
  if (v21)
    std::__shared_weak_count::__release_weak(v21);
  Alembic::AbcCoreAbstract::v12::ArrayPropertyWriter::~ArrayPropertyWriter((Alembic::AbcCoreAbstract::v12::ArrayPropertyWriter *)a1);
}

void sub_20BDE7724(uint64_t a1)
{
  void *v1;

  sub_20BDE74D8(a1);
  operator delete(v1);
}

unsigned __int8 *sub_20BDE7738(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  _BOOL4 v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unsigned __int8 *result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *exception;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *__p[2];
  char v34;
  _QWORD v35[4];
  __int128 v36;
  _QWORD v37[34];

  v2 = *(_QWORD *)(a1 + 56);
  v3 = *(uint64_t **)(v2 + 64);
  v4 = *(_QWORD *)(v2 + 72);
  *(_QWORD *)&v36 = v3;
  *((_QWORD *)&v36 + 1) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = *v3;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)a1) == (_DWORD)v7)
  {
    v8 = *(_QWORD *)(a1 + 56);
    v9 = *(_QWORD *)(v8 + 64);
    v10 = *(std::__shared_weak_count **)(v8 + 72);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
      v13 = *(unsigned int *)(*(_QWORD *)(a1 + 56) + 84) >= (unint64_t)((uint64_t)(*(_QWORD *)(v9 + 24)
                                                                                         - *(_QWORD *)(v9 + 16)) >> 3);
      do
        v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    else
    {
      v13 = *(unsigned int *)(v8 + 84) >= (unint64_t)((uint64_t)(*(_QWORD *)(v9 + 24) - *(_QWORD *)(v9 + 16)) >> 3);
    }
  }
  else
  {
    v13 = 0;
  }
  if (*((_QWORD *)&v36 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v36 + 1) + 16))(*((_QWORD *)&v36 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v36 + 1));
    }
  }
  if (v13)
  {
    sub_20BDDBD68((uint64_t)&v36);
    sub_20BDDC1C8(v37, (uint64_t)"Can not set more samples than we have times for when using Acyclic sampling.", 76);
    std::stringbuf::str();
    sub_20BDDBF20(v35, (__int128 *)__p);
    if (v34 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v30 = sub_20BDDC09C(exception, (uint64_t)v35);
    __cxa_throw(v30, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*(_DWORD *)(*(_QWORD *)(a1 + 56) + 84))
  {
    sub_20BDDBD68((uint64_t)&v36);
    sub_20BDDC1C8(v37, (uint64_t)"Can't set from previous sample before any samples have been written", 67);
    std::stringbuf::str();
    sub_20BDDBF20(v35, (__int128 *)__p);
    if (v34 < 0)
      operator delete(__p[0]);
    v31 = __cxa_allocate_exception(0x20uLL);
    v32 = sub_20BDDC09C(v31, (uint64_t)v35);
    __cxa_throw(v32, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v36 = *(_OWORD *)(*(_QWORD *)(a1 + 24) + 16);
  result = sub_20BE0026C((unsigned __int8 *)(a1 + 104), (unint64_t *)&v36);
  v18 = (*((_QWORD *)&v36 + 1) ^ v36) + __ROR8__(v36, 49);
  v19 = (*(_QWORD *)(a1 + 72) ^ v18) + __ROR8__(v18, 12);
  v20 = (*(_QWORD *)(a1 + 80) ^ v19) + __ROR8__(v19, 38);
  v21 = (v20 ^ __ROR8__(v36, 49)) + __ROR8__(v20, 13);
  v22 = (v21 ^ __ROR8__(v18, 12)) + __ROR8__(v21, 36);
  v23 = (v22 ^ __ROR8__(v19, 38)) + __ROR8__(v22, 55);
  v24 = (v23 ^ __ROR8__(v20, 13)) + __ROR8__(v23, 17);
  v25 = (v24 ^ __ROR8__(v21, 36)) + __ROR8__(v24, 10);
  v26 = (v25 ^ __ROR8__(v22, 55)) + __ROR8__(v25, 32);
  v27 = (v26 ^ __ROR8__(v23, 17)) + __ROR8__(v26, 39);
  v28 = __ROR8__(v27, 1);
  *(_QWORD *)(a1 + 72) = v28;
  *(_QWORD *)(a1 + 80) = (v27 ^ __ROR8__(v24, 10)) + v28;
  ++*(_DWORD *)(*(_QWORD *)(a1 + 56) + 84);
  return result;
}

void sub_20BDE79FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  std::exception v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6.__vftable = va_arg(va1, std::exception_vtbl *);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_20BDE7A40(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  BOOL v15;
  unint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  int *v19;
  uint64_t v20;
  int v21;
  _DWORD *v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  char *v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  std::__shared_weak_count *v84;
  unint64_t *v85;
  unint64_t v86;
  unsigned __int8 *result;
  uint64_t v88;
  int v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  _QWORD *v104;
  _QWORD *v105;
  _QWORD *v106;
  _QWORD *exception;
  _QWORD *v108;
  Alembic::Ogawa::v12::OGroup *v109;
  std::__shared_weak_count *v110;
  uint64_t v111;
  std::__shared_weak_count *v112;
  __int128 v113;
  Alembic::Ogawa::v12::OGroup *v114;
  std::__shared_weak_count *v115;
  uint64_t v116;
  std::__shared_weak_count *v117;
  uint64_t v118;
  std::__shared_weak_count *v119;
  void *__p[2];
  char v121;
  unint64_t v122[5];
  _QWORD *v123;
  uint64_t v124;
  unint64_t v125;
  unint64_t v126;

  v4 = *(_QWORD *)(a1 + 56);
  v5 = *(_QWORD **)(v4 + 64);
  v6 = *(std::__shared_weak_count **)(v4 + 72);
  v123 = v5;
  v124 = (uint64_t)v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = *v5;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)a1) == (_DWORD)v9)
  {
    v10 = *(_QWORD *)(a1 + 56);
    v11 = *(_QWORD *)(v10 + 64);
    v12 = *(std::__shared_weak_count **)(v10 + 72);
    if (v12)
    {
      v13 = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
      v15 = *(unsigned int *)(*(_QWORD *)(a1 + 56) + 84) < (unint64_t)((uint64_t)(*(_QWORD *)(v11 + 24)
                                                                                        - *(_QWORD *)(v11 + 16)) >> 3);
      do
        v16 = __ldaxr(v13);
      while (__stlxr(v16 - 1, v13));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    else
    {
      v15 = *(unsigned int *)(v10 + 84) < (unint64_t)((uint64_t)(*(_QWORD *)(v11 + 24) - *(_QWORD *)(v11 + 16)) >> 3);
    }
  }
  else
  {
    v15 = 1;
  }
  if (v124)
  {
    v17 = (uint64_t *)(v124 + 8);
    do
      v18 = __ldaxr((unint64_t *)v17);
    while (__stlxr(v18 - 1, (unint64_t *)v17));
    if (!v18)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v124 + 16))(v124);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v124);
    }
  }
  if (!v15)
  {
    sub_20BDDBD68((uint64_t)&v123);
    sub_20BDDC1C8(&v125, (uint64_t)"Can not write more samples than we have times for when using Acyclic sampling.", 78);
    std::stringbuf::str();
    sub_20BDDBF20(v122, (__int128 *)__p);
    if (v121 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v108 = sub_20BDDC09C(exception, (uint64_t)v122);
    __cxa_throw(v108, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v19 = (int *)(a2 + 8);
  v20 = *(_QWORD *)(a1 + 56);
  if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(v20 + 56) || *(unsigned __int8 *)(a2 + 12) != *(unsigned __int8 *)(v20 + 60))
  {
    sub_20BDDBD68((uint64_t)&v123);
    v102 = sub_20BDDC1C8(&v125, (uint64_t)"DataType on ArraySample iSamp: ", 31);
    v103 = sub_20BDE00F4(v102, v19);
    v104 = sub_20BDDC1C8(v103, (uint64_t)", does not match the DataType of the Array property: ", 53);
    sub_20BDE00F4(v104, (int *)(*(_QWORD *)(a1 + 56) + 56));
    std::stringbuf::str();
    sub_20BDDBF20(v122, (__int128 *)__p);
    if (v121 < 0)
      operator delete(__p[0]);
    v105 = __cxa_allocate_exception(0x20uLL);
    v106 = sub_20BDDC09C(v105, (uint64_t)v122);
    __cxa_throw(v106, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  Alembic::AbcCoreAbstract::v12::ArraySample::getKey((Alembic::AbcCoreAbstract::v12::ArraySample *)a2, (uint64_t)&v123);
  v21 = v124;
  if ((v124 - 14) <= 0xFFFFFFFD)
  {
    v124 = 0x200000002;
    v21 = 2;
  }
  v22 = *(_DWORD **)(a1 + 56);
  v23 = v22[21];
  if (!v23
    || (v24 = *(_QWORD *)(a1 + 24)) == 0
    || __PAIR128__(__PAIR64__(HIDWORD(v124), v21), (unint64_t)v123) != *(_OWORD *)v24
    || (v25 = v125, v125 != *(_QWORD *)(v24 + 16))
    || (v26 = v126, v126 != *(_QWORD *)(v24 + 24)))
  {
    if (v22[22])
    {
      v27 = (v22[23] + 1);
      if (v27 < v23)
      {
        do
        {
          v28 = *(std::__shared_weak_count **)(a1 + 96);
          v118 = *(_QWORD *)(a1 + 88);
          v119 = v28;
          if (v28)
          {
            v29 = (unint64_t *)&v28->__shared_owners_;
            do
              v30 = __ldxr(v29);
            while (__stxr(v30 + 1, v29));
          }
          v31 = *(std::__shared_weak_count **)(a1 + 32);
          v116 = *(_QWORD *)(a1 + 24);
          v117 = v31;
          if (v31)
          {
            v32 = (unint64_t *)&v31->__shared_owners_;
            do
              v33 = __ldxr(v32);
            while (__stxr(v33 + 1, v32));
          }
          sub_20BE00F2C(&v118, &v116);
          v34 = v117;
          if (v117)
          {
            v35 = (unint64_t *)&v117->__shared_owners_;
            do
              v36 = __ldaxr(v35);
            while (__stlxr(v36 - 1, v35));
            if (!v36)
            {
              ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
              std::__shared_weak_count::__release_weak(v34);
            }
          }
          v37 = v119;
          if (v119)
          {
            v38 = (unint64_t *)&v119->__shared_owners_;
            do
              v39 = __ldaxr(v38);
            while (__stlxr(v39 - 1, v38));
            if (!v39)
            {
              ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
              std::__shared_weak_count::__release_weak(v37);
            }
          }
          v40 = *(std::__shared_weak_count **)(a1 + 96);
          v114 = *(Alembic::Ogawa::v12::OGroup **)(a1 + 88);
          v115 = v40;
          if (v40)
          {
            v41 = (unint64_t *)&v40->__shared_owners_;
            do
              v42 = __ldxr(v41);
            while (__stxr(v42 + 1, v41));
          }
          sub_20BE003D4(&v114, a1 + 104, *v19);
          v43 = v115;
          if (v115)
          {
            v44 = (unint64_t *)&v115->__shared_owners_;
            do
              v45 = __ldaxr(v44);
            while (__stlxr(v45 - 1, v44));
            if (!v45)
            {
              ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
              std::__shared_weak_count::__release_weak(v43);
            }
          }
          ++v27;
        }
        while (v27 < *(unsigned int *)(*(_QWORD *)(a1 + 56) + 84));
      }
    }
    (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)a1 + 24))(__p, a1);
    (*(void (**)(unint64_t *__return_ptr))(*(_QWORD *)__p[0] + 24))(v122);
    v46 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v47 = (unint64_t *)((char *)__p[1] + 8);
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
    v113 = *(_OWORD *)v122;
    if (v122[1])
    {
      v49 = (unint64_t *)(v122[1] + 8);
      do
        v50 = __ldxr(v49);
      while (__stxr(v50 + 1, v49));
    }
    v51 = sub_20BE002F4((const void **)&v113);
    v52 = *(std::__shared_weak_count **)(a1 + 96);
    v111 = *(_QWORD *)(a1 + 88);
    v112 = v52;
    if (v52)
    {
      v53 = (unint64_t *)&v52->__shared_owners_;
      do
        v54 = __ldxr(v53);
      while (__stxr(v54 + 1, v53));
    }
    sub_20BE00464(v51, (uint64_t)&v111, a2, (uint64_t)&v123, (uint64_t *)__p);
    v55 = a1 + 24;
    sub_20BDE82DC(a1 + 24, (__int128 *)__p);
    v56 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v57 = (unint64_t *)((char *)__p[1] + 8);
      do
        v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
        std::__shared_weak_count::__release_weak(v56);
      }
    }
    v59 = v112;
    if (v112)
    {
      v60 = (unint64_t *)&v112->__shared_owners_;
      do
        v61 = __ldaxr(v60);
      while (__stlxr(v61 - 1, v60));
      if (!v61)
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
    }
    v62 = (std::__shared_weak_count *)*((_QWORD *)&v113 + 1);
    if (*((_QWORD *)&v113 + 1))
    {
      v63 = (unint64_t *)(*((_QWORD *)&v113 + 1) + 8);
      do
        v64 = __ldaxr(v63);
      while (__stlxr(v64 - 1, v63));
      if (!v64)
      {
        ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
        std::__shared_weak_count::__release_weak(v62);
      }
    }
    if (a1 + 104 != a2 + 16)
      sub_20BDDF7E4((char *)(a1 + 104), *(char **)(a2 + 16), *(_QWORD *)(a2 + 24), (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3);
    v65 = *(std::__shared_weak_count **)(a1 + 96);
    v109 = *(Alembic::Ogawa::v12::OGroup **)(a1 + 88);
    v110 = v65;
    if (v65)
    {
      v66 = (unint64_t *)&v65->__shared_owners_;
      do
        v67 = __ldxr(v66);
      while (__stxr(v67 + 1, v66));
    }
    sub_20BE003D4(&v109, a1 + 104, *v19);
    v68 = v110;
    if (v110)
    {
      v69 = (unint64_t *)&v110->__shared_owners_;
      do
        v70 = __ldaxr(v69);
      while (__stlxr(v70 - 1, v69));
      if (!v70)
      {
        ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
        std::__shared_weak_count::__release_weak(v68);
      }
    }
    v71 = *(_QWORD *)(a1 + 56);
    if (*(_BYTE *)(v71 + 80))
    {
      v72 = *(uint64_t **)(a1 + 104);
      v73 = *(_QWORD *)(a1 + 112) - (_QWORD)v72;
      if (!v73)
        goto LABEL_100;
      v74 = v73 >> 3;
      v75 = v74 <= 1 ? 1 : v74;
      v76 = 1;
      do
      {
        v77 = *v72++;
        v76 *= v77;
        --v75;
      }
      while (v75);
      if (v76 != 1)
LABEL_100:
        *(_BYTE *)(v71 + 80) = 0;
    }
    if (*(_BYTE *)(v71 + 81) && *(_QWORD *)v55)
    {
      v78 = *(uint64_t **)(a1 + 104);
      v79 = *(_QWORD *)(a1 + 112) - (_QWORD)v78;
      if (v79)
      {
        v80 = v79 >> 3;
        if (v80 <= 1)
          v81 = 1;
        else
          v81 = v80;
        v79 = 1;
        do
        {
          v82 = *v78++;
          v79 *= v82;
          --v81;
        }
        while (v81);
      }
      if (v79 != *(_QWORD *)(*(_QWORD *)v55 + 48))
        *(_BYTE *)(v71 + 81) = 0;
    }
    v83 = *(_DWORD *)(v71 + 84);
    if (!*(_DWORD *)(v71 + 88))
      *(_DWORD *)(v71 + 88) = v83;
    *(_DWORD *)(v71 + 92) = v83;
    v84 = (std::__shared_weak_count *)v122[1];
    if (v122[1])
    {
      v85 = (unint64_t *)(v122[1] + 8);
      do
        v86 = __ldaxr(v85);
      while (__stlxr(v86 - 1, v85));
      if (!v86)
      {
        ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
        std::__shared_weak_count::__release_weak(v84);
      }
    }
    v25 = *(_QWORD *)(*(_QWORD *)v55 + 16);
    v26 = *(_QWORD *)(*(_QWORD *)v55 + 24);
  }
  v122[0] = v25;
  v122[1] = v26;
  result = sub_20BE0026C((unsigned __int8 *)(a1 + 104), v122);
  v88 = *(_QWORD *)(a1 + 56);
  v89 = *(_DWORD *)(v88 + 84);
  if (v89)
  {
    v90 = (v122[1] ^ v122[0]) + __ROR8__(v122[0], 49);
    v91 = (*(_QWORD *)(a1 + 72) ^ v90) + __ROR8__(v90, 12);
    v92 = (*(_QWORD *)(a1 + 80) ^ v91) + __ROR8__(v91, 38);
    v93 = (v92 ^ __ROR8__(v122[0], 49)) + __ROR8__(v92, 13);
    v94 = (v93 ^ __ROR8__(v90, 12)) + __ROR8__(v93, 36);
    v95 = (v94 ^ __ROR8__(v91, 38)) + __ROR8__(v94, 55);
    v96 = (v95 ^ __ROR8__(v92, 13)) + __ROR8__(v95, 17);
    v97 = (v96 ^ __ROR8__(v93, 36)) + __ROR8__(v96, 10);
    v98 = (v97 ^ __ROR8__(v94, 55)) + __ROR8__(v97, 32);
    v99 = (v98 ^ __ROR8__(v95, 17)) + __ROR8__(v98, 39);
    v100 = v99 ^ __ROR8__(v96, 10);
    v101 = __ROR8__(v99, 1);
    *(_QWORD *)(a1 + 72) = v101;
    *(_QWORD *)(a1 + 80) = v100 + v101;
  }
  else
  {
    *(_OWORD *)(a1 + 72) = *(_OWORD *)v122;
    v89 = *(_DWORD *)(v88 + 84);
  }
  *(_DWORD *)(v88 + 84) = v89 + 1;
  return result;
}

void sub_20BDE8224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::exception a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  sub_20BDDC194(&a25);
  sub_20BDDBE98((uint64_t)&a30);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE82DC(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

double sub_20BDE8340@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_20BDE8378(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 56) + 84);
}

void sub_20BDE8384(uint64_t a1, uint64_t a2)
{
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *exception;
  _QWORD *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 __p;
  char v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  _QWORD v24[33];
  uint64_t *v25;
  std::__shared_weak_count *v26;

  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a1 + 40) + 24))(&v20);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v20 + 24))(&v22);
  v4 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)(*(_QWORD *(**)(uint64_t **__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v22 + 56))(&v25, v22, a2);
  v5 = v23;
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = v21;
  if (v21)
  {
    v9 = (unint64_t *)&v21->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = *v25;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v4) == (_DWORD)v11)
  {
    v12 = *(_QWORD *)(a1 + 56);
    if (*(unsigned int *)(v12 + 84) > (unint64_t)((v25[3] - v25[2]) >> 3))
    {
      sub_20BDDBD68((uint64_t)&v22);
      sub_20BDDC1C8(v24, (uint64_t)"Already have written more samples than we have times for when using Acyclic sampling.", 85);
      std::stringbuf::str();
      sub_20BDDBF20(&v20, &__p);
      if (v19 < 0)
        operator delete((void *)__p);
      exception = __cxa_allocate_exception(0x20uLL);
      v14 = sub_20BDDC09C(exception, (uint64_t)&v20);
      __cxa_throw(v14, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 56);
  }
  sub_20BDE881C((_QWORD *)(v12 + 64), (uint64_t *)&v25);
  *(_DWORD *)(*(_QWORD *)(a1 + 56) + 96) = a2;
  v15 = v26;
  if (v26)
  {
    v16 = (unint64_t *)&v26->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_20BDE8558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  std::exception v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v6.__vftable = va_arg(va1, std::exception_vtbl *);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v4 - 48));
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE85B4(uint64_t a1)
{
  uint64_t result;
  _QWORD *exception;
  _QWORD *v3;
  __int128 __p;
  char v5;
  _QWORD v6[4];
  _BYTE v7[16];
  _QWORD v8[33];

  result = *(_QWORD *)(a1 + 56);
  if (!result)
  {
    sub_20BDDBD68((uint64_t)v7);
    sub_20BDDC1C8(v8, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v6, &__p);
    if (v5 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v3 = sub_20BDDC09C(exception, (uint64_t)v6);
    __cxa_throw(v3, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return result;
}

void sub_20BDE864C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE8674(uint64_t a1)
{
  uint64_t v1;
  _QWORD *exception;
  _QWORD *v4;
  __int128 __p;
  char v6;
  _QWORD v7[4];
  _BYTE v8[16];
  _QWORD v9[33];

  v1 = *(_QWORD *)(a1 + 40);
  if (!v1)
  {
    sub_20BDDBD68((uint64_t)v8);
    sub_20BDDC1C8(v9, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v7, &__p);
    if (v6 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v4 = sub_20BDDC09C(exception, (uint64_t)v7);
    __cxa_throw(v4, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
}

void sub_20BDE8714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE873C@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  _QWORD *exception;
  _QWORD *v7;
  __int128 __p;
  char v9;
  _QWORD v10[4];
  _BYTE v11[16];
  _QWORD v12[33];

  v2 = *(_QWORD *)(result + 40);
  if (!v2)
  {
    sub_20BDDBD68((uint64_t)v11);
    sub_20BDDC1C8(v12, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v10, &__p);
    if (v9 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v7 = sub_20BDDC09C(exception, (uint64_t)v10);
    __cxa_throw(v7, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v3 = *(_QWORD *)(result + 48);
  *a2 = v2;
  a2[1] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

void sub_20BDE87F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDE881C(_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

_QWORD *sub_20BDE8894(_QWORD *a1, unint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDDF654(a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_20BDE88F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BDE8914(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4)
{
  _OWORD *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *exception;
  _QWORD *v17;
  _QWORD *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *__p[2];
  char v25;
  _QWORD v26[4];
  _BYTE v27[16];
  _QWORD v28[33];

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_24C517E90;
  v8 = (_OWORD *)(a1 + 24);
  if (*((char *)a2 + 23) < 0)
  {
    sub_20BDDBFAC((_BYTE *)(a1 + 24), *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v9 = *a2;
    *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 2);
    *v8 = v9;
  }
  Alembic::Ogawa::v12::IArchive::IArchive(a1 + 56, a2, a3, a4);
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 120), 0);
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  v10 = operator new(0x48uLL);
  v10[7] = 0;
  v10[8] = 0;
  *(_OWORD *)v10 = 0u;
  *((_OWORD *)v10 + 1) = 0u;
  *((_OWORD *)v10 + 2) = 0u;
  v10[6] = v10 + 7;
  sub_20BDE9D90((_QWORD *)(a1 + 240), (uint64_t)v10);
  sub_20BDFF424(a1 + 256, a3);
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 400) = 0;
  if ((Alembic::Ogawa::v12::IArchive::isValid((Alembic::Ogawa::v12::IStreams **)(a1 + 56)) & 1) != 0)
  {
    if ((Alembic::Ogawa::v12::IArchive::isValid((Alembic::Ogawa::v12::IStreams **)(a1 + 56)) & 1) == 0)
    {
      sub_20BDDBD68((uint64_t)v27);
      v12 = sub_20BDDC1C8(v28, (uint64_t)"Could not open as Ogawa file: ", 30);
      v13 = *(char *)(a1 + 47);
      if (v13 >= 0)
        v14 = (uint64_t)v8;
      else
        v14 = *(_QWORD *)(a1 + 24);
      if (v13 >= 0)
        v15 = *(unsigned __int8 *)(a1 + 47);
      else
        v15 = *(_QWORD *)(a1 + 32);
      sub_20BDDC1C8(v12, v14, v15);
      std::stringbuf::str();
      sub_20BDDBF20(v26, (__int128 *)__p);
      if (v25 < 0)
        operator delete(__p[0]);
      exception = __cxa_allocate_exception(0x20uLL);
      v17 = sub_20BDDC09C(exception, (uint64_t)v26);
      __cxa_throw(v17, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
    if ((Alembic::Ogawa::v12::IArchive::isFrozen((Alembic::Ogawa::v12::IStreams **)(a1 + 56)) & 1) == 0)
    {
      sub_20BDDBD68((uint64_t)v27);
      v18 = sub_20BDDC1C8(v28, (uint64_t)"Ogawa file not cleanly closed while being written: ", 51);
      v19 = *(char *)(a1 + 47);
      if (v19 >= 0)
        v20 = (uint64_t)v8;
      else
        v20 = *(_QWORD *)(a1 + 24);
      if (v19 >= 0)
        v21 = *(unsigned __int8 *)(a1 + 47);
      else
        v21 = *(_QWORD *)(a1 + 32);
      sub_20BDDC1C8(v18, v20, v21);
      std::stringbuf::str();
      sub_20BDDBF20(v26, (__int128 *)__p);
      if (v25 < 0)
        operator delete(__p[0]);
      v22 = __cxa_allocate_exception(0x20uLL);
      v23 = sub_20BDDC09C(v22, (uint64_t)v26);
      __cxa_throw(v23, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
    sub_20BDE8C84(a1);
  }
  else
  {
    *(_DWORD *)(a1 + 184) = -1;
  }
  return a1;
}

void sub_20BDE8B90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  uint64_t v16;
  void **v17;
  Alembic::Ogawa::v12::IArchive *v18;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v19;
  pthread_mutex_t *v20;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v21;
  uint64_t v22;
  void *v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;

  sub_20BDDC194(&a12);
  sub_20BDDBE98((uint64_t)&a16);
  a16 = (void **)(v16 + 384);
  sub_20BDE9F20(&a16);
  sub_20BDFF46C(v22);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v21);
  v24 = *(void **)(v16 + 216);
  if (v24)
  {
    *(_QWORD *)(v16 + 224) = v24;
    operator delete(v24);
  }
  sub_20BDE9EB0(&a16);
  pthread_mutex_destroy(v20);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v19);
  v25 = *(std::__shared_weak_count **)(v16 + 96);
  if (v25)
    std::__shared_weak_count::__release_weak(v25);
  Alembic::Ogawa::v12::IArchive::~IArchive(v18);
  if (*(char *)(v16 + 47) < 0)
    operator delete(*v17);
  v26 = *(std::__shared_weak_count **)(v16 + 16);
  if (v26)
    std::__shared_weak_count::__release_weak(v26);
  Alembic::AbcCoreAbstract::v12::ArchiveReader::~ArchiveReader((Alembic::AbcCoreAbstract::v12::ArchiveReader *)v16);
  _Unwind_Resume(a1);
}

void sub_20BDE8C84(uint64_t a1)
{
  std::__shared_weak_count *size;
  unint64_t *v3;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::string *v18;
  std::string *v19;
  __int128 v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  size_t v27;
  unint64_t **v28;
  uint64_t v29;
  std::string *v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  _QWORD *exception;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  Alembic::Ogawa::v12::IData *v45;
  std::__shared_weak_count *v46;
  Alembic::Ogawa::v12::IData *v47;
  std::__shared_weak_count *v48;
  Alembic::Ogawa::v12::IData *v49[2];
  int v50;
  void *v51[2];
  char v52;
  __int128 v53[2];
  std::string __p[11];
  int v55;
  uint64_t **v56;
  std::__shared_weak_count *v57;

  Alembic::Ogawa::v12::IArchive::getGroup(a1 + 56, &v56);
  v55 = -1;
  if ((unint64_t)Alembic::Ogawa::v12::IGroup::getNumChildren((Alembic::Ogawa::v12::IGroup *)v56) < 6
    || !Alembic::Ogawa::v12::IGroup::isChildData((Alembic::Ogawa::v12::IGroup *)v56, 0)
    || !Alembic::Ogawa::v12::IGroup::isChildData((Alembic::Ogawa::v12::IGroup *)v56, 1uLL)
    || !Alembic::Ogawa::v12::IGroup::isChildGroup((Alembic::Ogawa::v12::IGroup *)v56, 2uLL)
    || !Alembic::Ogawa::v12::IGroup::isChildData((Alembic::Ogawa::v12::IGroup *)v56, 3uLL)
    || !Alembic::Ogawa::v12::IGroup::isChildData((Alembic::Ogawa::v12::IGroup *)v56, 4uLL)
    || !Alembic::Ogawa::v12::IGroup::isChildData((Alembic::Ogawa::v12::IGroup *)v56, 5uLL))
  {
    sub_20BDDBD68((uint64_t)__p);
    sub_20BDDC1C8(&__p[0].__r_.__value_.__r.__words[2], (uint64_t)"Invalid Alembic file.", 21);
    std::stringbuf::str();
    sub_20BDDBF20(v53, (__int128 *)v51);
    if (v52 < 0)
      operator delete(v51[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v38 = sub_20BDDC09C(exception, (uint64_t)v53);
    __cxa_throw(v38, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  Alembic::Ogawa::v12::IGroup::getData((unint64_t **)v56, 0, 0, __p);
  if (Alembic::Ogawa::v12::IData::getSize((Alembic::Ogawa::v12::IData *)__p[0].__r_.__value_.__l.__data_) == 4)
    Alembic::Ogawa::v12::IData::read((unint64_t **)__p[0].__r_.__value_.__l.__data_, 4, &v55, 0, 0);
  size = (std::__shared_weak_count *)__p[0].__r_.__value_.__l.__size_;
  if (__p[0].__r_.__value_.__l.__size_)
  {
    v3 = (unint64_t *)(__p[0].__r_.__value_.__l.__size_ + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }
  if (v55)
  {
    sub_20BDDBD68((uint64_t)__p);
    sub_20BDDC1C8(&__p[0].__r_.__value_.__r.__words[2], (uint64_t)"Unsupported file version detected: ", 35);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v53, (__int128 *)v51);
    if (v52 < 0)
      operator delete(v51[0]);
    v39 = __cxa_allocate_exception(0x20uLL);
    v40 = sub_20BDDC09C(v39, (uint64_t)v53);
    __cxa_throw(v40, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v50 = 0;
  Alembic::Ogawa::v12::IGroup::getData((unint64_t **)v56, 1uLL, 0, v49);
  if (Alembic::Ogawa::v12::IData::getSize(v49[0]) == 4)
    Alembic::Ogawa::v12::IData::read((unint64_t **)v49[0], 4, &v50, 0, 0);
  if (v50 <= 9998)
  {
    sub_20BDDBD68((uint64_t)__p);
    sub_20BDDC1C8(&__p[0].__r_.__value_.__r.__words[2], (uint64_t)"Unsupported Alembic version detected: ", 38);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v53, (__int128 *)v51);
    if (v52 < 0)
      operator delete(v51[0]);
    v41 = __cxa_allocate_exception(0x20uLL);
    v42 = sub_20BDDC09C(v41, (uint64_t)v53);
    __cxa_throw(v42, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  *(_DWORD *)(a1 + 184) = v50;
  Alembic::Ogawa::v12::IGroup::getData((unint64_t **)v56, 4uLL, 0, &v47);
  sub_20BDFAFE8(&v47, (char **)(a1 + 192), a1 + 216);
  v5 = v48;
  if (v48)
  {
    p_shared_owners = (unint64_t *)&v48->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  Alembic::Ogawa::v12::IGroup::getData((unint64_t **)v56, 5uLL, 0, &v45);
  sub_20BDFC03C(&v45, a1 + 384);
  v8 = v46;
  if (v46)
  {
    v9 = (unint64_t *)&v46->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = operator new(0xA0uLL);
  Alembic::Ogawa::v12::IGroup::getGroup(v56, 2uLL, 0, 0, &v43);
  sub_20BDDC0E4(__p, "");
  sub_20BDF3E70(v11, &v43, __p, 0, a1, a1 + 384);
  sub_20BDE9F98(v53, v11);
  sub_20BDE82DC(a1 + 104, v53);
  v12 = (std::__shared_weak_count *)*((_QWORD *)&v53[0] + 1);
  if (*((_QWORD *)&v53[0] + 1))
  {
    v13 = (unint64_t *)(*((_QWORD *)&v53[0] + 1) + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p[0].__r_.__value_.__l.__data_);
  v15 = v44;
  if (v44)
  {
    v16 = (unint64_t *)&v44->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = *(std::string **)(a1 + 240);
  sub_20BDDC0E4(__p, "ABC");
  std::string::operator=(v18, __p);
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p[0].__r_.__value_.__l.__data_);
  v19 = *(std::string **)(a1 + 240);
  sub_20BDDC0E4(__p, "/");
  std::string::operator=(v19 + 1, __p);
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p[0].__r_.__value_.__l.__data_);
  Alembic::Ogawa::v12::IGroup::getData((unint64_t **)v56, 3uLL, 0, __p);
  v20 = *(_OWORD *)&__p[0].__r_.__value_.__l.__data_;
  *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = 0uLL;
  v21 = (std::__shared_weak_count *)v49[1];
  *(_OWORD *)v49 = v20;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = (std::__shared_weak_count *)__p[0].__r_.__value_.__l.__size_;
  if (__p[0].__r_.__value_.__l.__size_)
  {
    v25 = (unint64_t *)(__p[0].__r_.__value_.__l.__size_ + 8);
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  if (Alembic::Ogawa::v12::IData::getSize(v49[0]))
  {
    v27 = Alembic::Ogawa::v12::IData::getSize(v49[0]);
    sub_20BDDC468(__p, v27, 0);
    v28 = (unint64_t **)v49[0];
    v29 = Alembic::Ogawa::v12::IData::getSize(v49[0]);
    v30 = (__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? __p
        : (std::string *)__p[0].__r_.__value_.__r.__words[0];
    Alembic::Ogawa::v12::IData::read(v28, v29, v30, 0, 0);
    sub_20BDE9724(*(_QWORD *)(a1 + 240) + 48, __p);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  v31 = (std::__shared_weak_count *)v49[1];
  if (v49[1])
  {
    v32 = (unint64_t *)((char *)v49[1] + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v57;
  if (v57)
  {
    v35 = (unint64_t *)&v57->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
}

void sub_20BDE92F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::exception a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;

  sub_20BDDC194(&a21);
  sub_20BDDBE98((uint64_t)&__p);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a15);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v30 - 64));
  _Unwind_Resume(a1);
}

uint64_t sub_20BDE9434(uint64_t a1, _QWORD *a2)
{
  Alembic::Ogawa::v12::IStreams **v4;
  _QWORD *v5;
  _QWORD *exception;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *__p[2];
  char v12;
  _QWORD v13[4];
  _BYTE v14[16];
  _QWORD v15[33];

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_24C517E90;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (Alembic::Ogawa::v12::IStreams **)(a1 + 56);
  Alembic::Ogawa::v12::IArchive::IArchive(a1 + 56);
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 120), 0);
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  v5 = operator new(0x48uLL);
  v5[7] = 0;
  v5[8] = 0;
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  v5[6] = v5 + 7;
  sub_20BDE9D90((_QWORD *)(a1 + 240), (uint64_t)v5);
  sub_20BDFF424(a1 + 256, (uint64_t)(a2[1] - *a2) >> 3);
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 400) = 0;
  if ((Alembic::Ogawa::v12::IArchive::isValid(v4) & 1) == 0)
  {
    sub_20BDDBD68((uint64_t)v14);
    sub_20BDDC1C8(v15, (uint64_t)"Could not open as Ogawa file from provided streams.", 51);
    std::stringbuf::str();
    sub_20BDDBF20(v13, (__int128 *)__p);
    if (v12 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v8 = sub_20BDDC09C(exception, (uint64_t)v13);
    __cxa_throw(v8, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if ((Alembic::Ogawa::v12::IArchive::isFrozen(v4) & 1) == 0)
  {
    sub_20BDDBD68((uint64_t)v14);
    sub_20BDDC1C8(v15, (uint64_t)"Ogawa streams not cleanly closed while being written. ", 54);
    std::stringbuf::str();
    sub_20BDDBF20(v13, (__int128 *)__p);
    if (v12 < 0)
      operator delete(__p[0]);
    v9 = __cxa_allocate_exception(0x20uLL);
    v10 = sub_20BDDC09C(v9, (uint64_t)v13);
    __cxa_throw(v10, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDE8C84(a1);
  return a1;
}

void sub_20BDE9634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  uint64_t v16;
  Alembic::Ogawa::v12::IArchive *v17;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v18;
  pthread_mutex_t *v19;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v20;
  uint64_t v21;
  void **v22;
  void *v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;

  sub_20BDDC194(&a12);
  sub_20BDDBE98((uint64_t)&a16);
  a16 = (void **)(v16 + 384);
  sub_20BDE9F20(&a16);
  sub_20BDFF46C(v21);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v20);
  v24 = *(void **)(v16 + 216);
  if (v24)
  {
    *(_QWORD *)(v16 + 224) = v24;
    operator delete(v24);
  }
  sub_20BDE9EB0(&a16);
  pthread_mutex_destroy(v19);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v18);
  v25 = *(std::__shared_weak_count **)(v16 + 96);
  if (v25)
    std::__shared_weak_count::__release_weak(v25);
  Alembic::Ogawa::v12::IArchive::~IArchive(v17);
  if (*(char *)(v16 + 47) < 0)
    operator delete(*v22);
  v26 = *(std::__shared_weak_count **)(v16 + 16);
  if (v26)
    std::__shared_weak_count::__release_weak(v26);
  Alembic::AbcCoreAbstract::v12::ArchiveReader::~ArchiveReader((Alembic::AbcCoreAbstract::v12::ArchiveReader *)v16);
  _Unwind_Resume(a1);
}

void sub_20BDE9724(uint64_t a1, std::string *a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)(a1 + 8);
  sub_20BDE9D48(a1, *(_QWORD **)(a1 + 8));
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + 16) = 0;
  *v4 = 0;
  Alembic::Util::v12::TokenMap::setUnique((uint64_t **)a1, a2, 59, 61, 1);
}

uint64_t sub_20BDE9778(uint64_t a1)
{
  return a1 + 24;
}

uint64_t sub_20BDE9780(uint64_t a1)
{
  return *(_QWORD *)(a1 + 240) + 48;
}

uint64_t sub_20BDE978C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  pthread_mutex_t *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  void *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  uint64_t v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  __int128 v39;

  v4 = (pthread_mutex_t *)(a1 + 120);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 120));
  *a2 = 0;
  a2[1] = 0;
  v5 = *(std::__shared_weak_count **)(a1 + 96);
  if (v5)
  {
    v6 = std::__shared_weak_count::lock(v5);
    a2[1] = (uint64_t)v6;
    if (v6)
    {
      v7 = *(_QWORD *)(a1 + 88);
      *a2 = v7;
      if (v7)
        return pthread_mutex_unlock(v4);
    }
    else if (*a2)
    {
      return pthread_mutex_unlock(v4);
    }
  }
  v8 = operator new(0x58uLL);
  sub_20BDE70B8(&v37, (_QWORD *)(a1 + 8));
  v9 = *(std::__shared_weak_count **)(a1 + 112);
  v35 = *(_QWORD *)(a1 + 104);
  v36 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v12 = *(std::__shared_weak_count **)(a1 + 248);
  v33 = *(_QWORD *)(a1 + 240);
  v34 = v12;
  if (v12)
  {
    v13 = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  sub_20BDF5194(v8, &v37, &v35, &v33);
  sub_20BDEA134((uint64_t *)&v39, (uint64_t)v8);
  sub_20BDE82DC((uint64_t)a2, &v39);
  v15 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
  if (*((_QWORD *)&v39 + 1))
  {
    v16 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v34;
  if (v34)
  {
    v19 = (unint64_t *)&v34->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v36;
  if (v36)
  {
    v22 = (unint64_t *)&v36->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = v38;
  if (v38)
  {
    v25 = (unint64_t *)&v38->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v28 = *a2;
  v27 = a2[1];
  if (v27)
  {
    v29 = (unint64_t *)(v27 + 16);
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
  }
  v31 = *(std::__shared_weak_count **)(a1 + 96);
  *(_QWORD *)(a1 + 88) = v28;
  *(_QWORD *)(a1 + 96) = v27;
  if (v31)
    std::__shared_weak_count::__release_weak(v31);
  return pthread_mutex_unlock(v4);
}

void sub_20BDE99A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  pthread_mutex_t *v13;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v14;
  void *v15;

  operator delete(v15);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v14);
  pthread_mutex_unlock(v13);
  _Unwind_Resume(a1);
}

void sub_20BDE99F8(int64x2_t *a1@<X0>, unsigned int a2@<W1>, _OWORD *a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  int64x2_t *v7;
  Alembic::AbcCoreAbstract::v12::TimeSampling *v9;
  unint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  _QWORD *v19;
  _QWORD *v20;
  char *v21;
  __int128 v22;
  int64x2_t v23;
  _OWORD *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  unint64_t v29;
  __int128 v30;
  unint64_t *v31;
  unint64_t v32;
  __int128 v33;
  uint64_t v34;
  int64x2_t v35;
  uint64_t v36;
  int64x2_t *v37;

  v5 = a1[12].i64[0];
  v6 = a1[12].i64[1];
  v7 = a1 + 12;
  if (v6 == v5)
  {
    v9 = (Alembic::AbcCoreAbstract::v12::TimeSampling *)operator new(0x28uLL);
    Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(v9);
    sub_20BDEA220(&v33, (uint64_t)v9);
    v10 = a1[13].u64[0];
    v11 = (_OWORD *)a1[12].i64[1];
    if ((unint64_t)v11 >= v10)
    {
      v12 = ((uint64_t)v11 - v7->i64[0]) >> 4;
      v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 60)
        sub_20BDDF694();
      v14 = v10 - v7->i64[0];
      if (v14 >> 3 > v13)
        v13 = v14 >> 3;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
        v15 = 0xFFFFFFFFFFFFFFFLL;
      else
        v15 = v13;
      v37 = a1 + 13;
      v16 = (char *)sub_20BDEA2F0((uint64_t)a1[13].i64, v15);
      v18 = &v16[16 * v12];
      *(_OWORD *)v18 = v33;
      v33 = 0uLL;
      v20 = (_QWORD *)a1[12].i64[0];
      v19 = (_QWORD *)a1[12].i64[1];
      if (v19 == v20)
      {
        v23 = vdupq_n_s64((unint64_t)v19);
        v21 = &v16[16 * v12];
      }
      else
      {
        v21 = &v16[16 * v12];
        do
        {
          v22 = *((_OWORD *)v19 - 1);
          v19 -= 2;
          *((_OWORD *)v21 - 1) = v22;
          v21 -= 16;
          *v19 = 0;
          v19[1] = 0;
        }
        while (v19 != v20);
        v23 = *v7;
      }
      v24 = v18 + 16;
      a1[12].i64[0] = (uint64_t)v21;
      a1[12].i64[1] = (uint64_t)(v18 + 16);
      v35 = v23;
      v25 = a1[13].i64[0];
      a1[13].i64[0] = (uint64_t)&v16[16 * v17];
      v36 = v25;
      v34 = v23.i64[0];
      sub_20BDEA324((uint64_t)&v34);
      v26 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
      a1[12].i64[1] = (uint64_t)v24;
      if (v26)
      {
        p_shared_owners = (unint64_t *)&v26->__shared_owners_;
        do
          v28 = __ldaxr(p_shared_owners);
        while (__stlxr(v28 - 1, p_shared_owners));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
    }
    else
    {
      *v11 = v33;
      a1[12].i64[1] = (uint64_t)(v11 + 1);
    }
    v5 = a1[12].i64[0];
    v6 = a1[12].i64[1];
  }
  v29 = (v6 - v5) >> 4;
  if (v29 <= a2)
    v30 = *(_OWORD *)(v5 + 16 * v29 - 16);
  else
    v30 = *(_OWORD *)(v5 + 16 * a2);
  *a3 = v30;
  if (*((_QWORD *)&v30 + 1))
  {
    v31 = (unint64_t *)(*((_QWORD *)&v30 + 1) + 8);
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
  }
}

void sub_20BDE9BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

double sub_20BDE9BE4@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_20BDE9C1C(uint64_t a1, unsigned int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 216);
  if (a2 >= (unint64_t)((*(_QWORD *)(a1 + 224) - v2) >> 3))
    return 0x7FFFFFFFFFFFFFFFLL;
  else
    return *(_QWORD *)(v2 + 8 * a2);
}

_QWORD *sub_20BDE9C40@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  return sub_20BDFF470((_QWORD *)(a1 + 256), a2);
}

void sub_20BDE9C48(uint64_t a1)
{
  void *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  void **v5;

  *(_QWORD *)a1 = off_24C517E90;
  v5 = (void **)(a1 + 384);
  sub_20BDE9F20(&v5);
  sub_20BDFF46C(a1 + 256);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 240));
  v2 = *(void **)(a1 + 216);
  if (v2)
  {
    *(_QWORD *)(a1 + 224) = v2;
    operator delete(v2);
  }
  v5 = (void **)(a1 + 192);
  sub_20BDE9EB0(&v5);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 120));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 104));
  v3 = *(std::__shared_weak_count **)(a1 + 96);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  Alembic::Ogawa::v12::IArchive::~IArchive((Alembic::Ogawa::v12::IArchive *)(a1 + 56));
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  Alembic::AbcCoreAbstract::v12::ArchiveReader::~ArchiveReader((Alembic::AbcCoreAbstract::v12::ArchiveReader *)a1);
}

void sub_20BDE9D08(uint64_t a1)
{
  void *v1;

  sub_20BDE9C48(a1);
  operator delete(v1);
}

uint64_t sub_20BDE9D1C(uint64_t a1)
{
  return a1 + 384;
}

void sub_20BDE9D24(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t sub_20BDE9D30(uint64_t a1)
{
  return (*(_QWORD *)(a1 + 200) - *(_QWORD *)(a1 + 192)) >> 4;
}

uint64_t sub_20BDE9D40(uint64_t a1)
{
  return *(unsigned int *)(a1 + 184);
}

void sub_20BDE9D48(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_20BDE9D48(a1, *a2);
    sub_20BDE9D48(a1, a2[1]);
    sub_20BDDE3E4((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

_QWORD *sub_20BDE9D90(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C517F48;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDE9DDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  a10 = 0;
  if (v10)
    sub_20BDE9E5C((uint64_t)&a10, v10);
  _Unwind_Resume(exception_object);
}

void sub_20BDE9E00(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDE9E14(uint64_t a1)
{
  sub_20BDE9E5C(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t sub_20BDE9E1C(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C517F98))
    return a1 + 24;
  else
    return 0;
}

void sub_20BDE9E5C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_20BDE9D48(a2 + 48, *(_QWORD **)(a2 + 56));
    if (*(char *)(a2 + 47) < 0)
      operator delete(*(void **)(a2 + 24));
    if (*(char *)(a2 + 23) < 0)
      operator delete(*(void **)a2);
    operator delete((void *)a2);
  }
}

void sub_20BDE9EB0(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v4 - 16));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_20BDE9F20(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 24;
        sub_20BDE9D48((uint64_t)(v4 - 24), *((_QWORD **)v4 - 2));
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *sub_20BDE9F98(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C517FC0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  sub_20BDEA008((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_20BDE9FEC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  if (v1)
  {
    v3 = (void *)sub_20BDF3EE8(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_20BDEA008(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  if (a2)
  {
    v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
        do
          v9 = __ldxr(p_shared_weak_owners);
        while (__stxr(v9 + 1, p_shared_weak_owners));
        v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4)
        std::__shared_weak_count::__release_weak(v4);
      if (v5)
      {
        v10 = (unint64_t *)&v5->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }
}

void sub_20BDEA0BC(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDEA0D0(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v2 = (void *)sub_20BDF3EE8(v1);
    operator delete(v2);
  }
}

uint64_t sub_20BDEA0F4(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518010))
    return a1 + 24;
  else
    return 0;
}

uint64_t *sub_20BDEA134(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518038;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BDEA190(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDEA1B4(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BDEA1C8(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BDEA1E0(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518088))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDEA220(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &unk_24C5180B0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDEA270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;

  a10 = 0;
  if (v10)
    sub_20BDE1628((int)&a10, v10);
  _Unwind_Resume(exception_object);
}

void sub_20BDEA294(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDEA2A8(uint64_t a1)
{
  sub_20BDE1628(a1 + 24, *(_QWORD **)(a1 + 24));
}

uint64_t sub_20BDEA2B0(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518100))
    return a1 + 24;
  else
    return 0;
}

void *sub_20BDEA2F0(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    sub_20BDDF5B4();
  return operator new(16 * a2);
}

uint64_t sub_20BDEA324(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(i - 16));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_20BDEA370(uint64_t a1, __int128 *a2, const void ***a3)
{
  _OWORD *v6;
  __int128 v7;
  void **v8;
  _QWORD *v9;
  Alembic::AbcCoreAbstract::v12::TimeSampling *v10;
  unint64_t v11;
  char *v12;
  _QWORD *v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *exception;
  _QWORD *v32;
  __int128 __p;
  char v34;
  _QWORD v35[4];
  char v36[16];
  uint64_t v37[33];
  __int128 v38;

  *(_BYTE *)(a1 + 8) = -1;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = off_24C518128;
  v6 = (_OWORD *)(a1 + 32);
  if (*((char *)a2 + 23) < 0)
  {
    sub_20BDDBFAC((_BYTE *)(a1 + 32), *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v7 = *a2;
    *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 2);
    *v6 = v7;
  }
  sub_20BDEBF8C((uint64_t *)(a1 + 56), a3);
  Alembic::Ogawa::v12::OArchive::OArchive(a1 + 80, a2);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  v8 = (void **)(a1 + 168);
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_DWORD *)(a1 + 224) = 1065353216;
  v9 = operator new(0x18uLL);
  v9[2] = 0;
  v9[1] = 0;
  *v9 = v9 + 1;
  sub_20BDEC9AC((_QWORD *)(a1 + 232), (uint64_t)v9);
  v10 = (Alembic::AbcCoreAbstract::v12::TimeSampling *)operator new(0x28uLL);
  Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(v10);
  sub_20BDEA220(&v38, (uint64_t)v10);
  sub_20BDEA72C((char **)(a1 + 144), &v38);
  v11 = *(_QWORD *)(a1 + 184);
  v12 = *(char **)(a1 + 176);
  if ((unint64_t)v12 >= v11)
  {
    v14 = (char *)*v8;
    v15 = (v12 - (_BYTE *)*v8) >> 3;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61)
      sub_20BDDF694();
    v17 = v11 - (_QWORD)v14;
    if (v17 >> 2 > v16)
      v16 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v16;
    if (v18)
    {
      v19 = (char *)sub_20BDDF6A8(a1 + 184, v18);
      v14 = *(char **)(a1 + 168);
      v12 = *(char **)(a1 + 176);
    }
    else
    {
      v19 = 0;
    }
    v20 = &v19[8 * v15];
    v21 = &v19[8 * v18];
    *(_QWORD *)v20 = 0;
    v13 = v20 + 8;
    while (v12 != v14)
    {
      v22 = *((_QWORD *)v12 - 1);
      v12 -= 8;
      *((_QWORD *)v20 - 1) = v22;
      v20 -= 8;
    }
    *(_QWORD *)(a1 + 168) = v20;
    *(_QWORD *)(a1 + 176) = v13;
    *(_QWORD *)(a1 + 184) = v21;
    if (v14)
      operator delete(v14);
  }
  else
  {
    *(_QWORD *)v12 = 0;
    v13 = v12 + 8;
  }
  *(_QWORD *)(a1 + 176) = v13;
  if (!Alembic::Ogawa::v12::OArchive::isValid((Alembic::Ogawa::v12::OStream **)(a1 + 80)))
  {
    sub_20BDDBD68((uint64_t)v36);
    v27 = sub_20BDDC1C8(v37, (uint64_t)"Could not open file: ", 21);
    v28 = *(char *)(a1 + 55);
    if (v28 >= 0)
      v29 = (uint64_t)v6;
    else
      v29 = *(_QWORD *)(a1 + 32);
    if (v28 >= 0)
      v30 = *(unsigned __int8 *)(a1 + 55);
    else
      v30 = *(_QWORD *)(a1 + 40);
    sub_20BDDC1C8(v27, v29, v30);
    std::stringbuf::str();
    sub_20BDDBF20(v35, &__p);
    if (v34 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v32 = sub_20BDDC09C(exception, (uint64_t)v35);
    __cxa_throw(v32, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDEA86C(a1);
  v23 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
  if (*((_QWORD *)&v38 + 1))
  {
    v24 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  return a1;
}

void sub_20BDEA63C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, uint64_t a10, uint64_t a11, uint64_t a12, std::exception a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v17;
  void **v18;
  uint64_t v19;
  Alembic::Ogawa::v12::OArchive *v20;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v21;
  void **v22;
  uint64_t v23;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v24;
  uint64_t v25;
  void *v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;

  sub_20BDDC194(&a13);
  sub_20BDDBE98((uint64_t)&a17);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v25 - 104));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v24);
  sub_20BDEC38C(v23);
  v26 = *v22;
  if (*v22)
  {
    *(_QWORD *)(v17 + 176) = v26;
    operator delete(v26);
  }
  sub_20BDE9EB0((void ***)&a17);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v21);
  v27 = *(std::__shared_weak_count **)(v17 + 120);
  if (v27)
    std::__shared_weak_count::__release_weak(v27);
  Alembic::Ogawa::v12::OArchive::~OArchive(v20);
  sub_20BDE9D48(v19, *(_QWORD **)(v17 + 64));
  if (*(char *)(v17 + 55) < 0)
    operator delete(*v18);
  v28 = *(std::__shared_weak_count **)(v17 + 24);
  if (v28)
    std::__shared_weak_count::__release_weak(v28);
  Alembic::AbcCoreAbstract::v12::ArchiveWriter::~ArchiveWriter((Alembic::AbcCoreAbstract::v12::ArchiveWriter *)v17);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDEA72C(char **a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;
  int64x2_t v29;
  char *v30;
  uint64_t v31;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v12 = (v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      sub_20BDDF694();
    v14 = v5 - (_QWORD)*a1;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v31 = result;
    v16 = (char *)sub_20BDEA2F0(result, v15);
    v18 = &v16[16 * v12];
    v19 = *a2;
    *(_OWORD *)v18 = *a2;
    if (*((_QWORD *)&v19 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v23 = *a1;
    v22 = a1[1];
    if (v22 == *a1)
    {
      v26 = vdupq_n_s64((unint64_t)v22);
      v24 = &v16[16 * v12];
    }
    else
    {
      v24 = &v16[16 * v12];
      do
      {
        v25 = *((_OWORD *)v22 - 1);
        v22 -= 16;
        *((_OWORD *)v24 - 1) = v25;
        v24 -= 16;
        *(_QWORD *)v22 = 0;
        *((_QWORD *)v22 + 1) = 0;
      }
      while (v22 != v23);
      v26 = *(int64x2_t *)a1;
    }
    v11 = v18 + 16;
    *a1 = v24;
    a1[1] = v18 + 16;
    v29 = v26;
    v27 = a1[2];
    a1[2] = &v16[16 * v17];
    v30 = v27;
    v28 = v26.i64[0];
    result = sub_20BDEA324((uint64_t)&v28);
  }
  else
  {
    *(_QWORD *)v7 = *(_QWORD *)a2;
    v8 = *((_QWORD *)a2 + 1);
    *((_QWORD *)v7 + 1) = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = v7 + 16;
  }
  a1[1] = v11;
  return result;
}

void sub_20BDEA86C(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  Alembic::AbcCoreAbstract::v12 *v15;
  uint64_t *v16;
  _QWORD *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  Alembic::Ogawa::v12::OData *v24;
  _QWORD *v25;
  Alembic::Ogawa::v12::OGroup *v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  _QWORD *v40;
  Alembic::Ogawa::v12::OGroup *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  _QWORD *v54;
  Alembic::Ogawa::v12::OGroup *v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t *v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  std::__shared_weak_count *size;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  __int128 v74;
  Alembic::Ogawa::v12::OGroup *v75;
  std::__shared_weak_count *v76;
  __int128 v77;
  Alembic::Ogawa::v12::OGroup *v78;
  std::__shared_weak_count *v79;
  __int128 v80;
  Alembic::Ogawa::v12::OGroup *v81;
  std::__shared_weak_count *v82;
  uint64_t v83;
  std::__shared_weak_count *v84;
  std::string __str;
  Alembic::Ogawa::v12::OGroup *v86;
  std::__shared_weak_count *v87;
  char v88;
  Alembic::Ogawa::v12::OData *v89;
  std::__shared_weak_count *v90;
  int v91;
  Alembic::Ogawa::v12::OData *v92;
  std::__shared_weak_count *v93;
  int v94;
  Alembic::Ogawa::v12::OGroup **v95;

  v94 = 0;
  v2 = a1 + 80;
  Alembic::Ogawa::v12::OArchive::getGroup(a1 + 80, &v86);
  Alembic::Ogawa::v12::OGroup::addData(v86, &v94, 4, &v92);
  v3 = v93;
  if (v93)
  {
    p_shared_owners = (unint64_t *)&v93->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v6 = v87;
  if (v87)
  {
    v7 = (unint64_t *)&v87->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v91 = 10803;
  Alembic::Ogawa::v12::OArchive::getGroup(v2, &v86);
  Alembic::Ogawa::v12::OGroup::addData(v86, &v91, 4, &v89);
  v9 = v90;
  if (v90)
  {
    v10 = (unint64_t *)&v90->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v87;
  if (v87)
  {
    v13 = (unint64_t *)&v87->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = (Alembic::AbcCoreAbstract::v12 *)sub_20BDDC0E4(&v86, "_ai_AlembicVersion");
  Alembic::AbcCoreAbstract::v12::GetLibraryVersion(v15);
  v95 = &v86;
  v16 = sub_20BDDDFDC((uint64_t **)(a1 + 56), (const void **)&v86, (uint64_t)&unk_20CA4FFEF, (__int128 **)&v95);
  std::string::operator=((std::string *)(v16 + 7), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v88 < 0)
    operator delete(v86);
  v17 = operator new(0x88uLL);
  Alembic::Ogawa::v12::OArchive::getGroup(v2, &v86);
  Alembic::Ogawa::v12::OGroup::addGroup(v86, &v83);
  sub_20BDF595C(v17, &v83);
  sub_20BDEB324((_QWORD *)(a1 + 128), v17);
  v18 = v84;
  if (v84)
  {
    v19 = (unint64_t *)&v84->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v87;
  if (v87)
  {
    v22 = (unint64_t *)&v87->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = (Alembic::Ogawa::v12::OData *)operator new(8uLL);
  Alembic::Ogawa::v12::OData::OData(v24);
  sub_20BDECC34(&v86, (uint64_t)v24);
  v25 = operator new(0x38uLL);
  v26 = v86;
  v27 = v87;
  v81 = v86;
  v82 = v87;
  if (v87)
  {
    v28 = (unint64_t *)&v87->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
    *v25 = 0;
    v25[1] = 0x200000002;
    v25[2] = 0;
    v25[3] = 0;
    v25[4] = v26;
    v25[5] = v27;
    v30 = (unint64_t *)&v27->__shared_owners_;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  else
  {
    *v25 = 0;
    v25[1] = 0x200000002;
    v25[2] = 0;
    v25[3] = 0;
    v25[4] = v26;
    v25[5] = 0;
  }
  v25[6] = 0;
  sub_20BDECD14(&__str, (uint64_t)v25);
  if (v27)
  {
    v32 = (unint64_t *)&v27->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v34 = a1 + 192;
  v80 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
  if (__str.__r_.__value_.__l.__size_)
  {
    v35 = (unint64_t *)(__str.__r_.__value_.__l.__size_ + 8);
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
  }
  sub_20BDEB394(v34, (uint64_t *)&v80);
  v37 = (std::__shared_weak_count *)*((_QWORD *)&v80 + 1);
  if (*((_QWORD *)&v80 + 1))
  {
    v38 = (unint64_t *)(*((_QWORD *)&v80 + 1) + 8);
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  v40 = operator new(0x38uLL);
  v41 = v86;
  v42 = v87;
  v78 = v86;
  v79 = v87;
  if (v87)
  {
    v43 = (unint64_t *)&v87->__shared_owners_;
    do
      v44 = __ldxr(v43);
    while (__stxr(v44 + 1, v43));
    *v40 = 0;
    v40[1] = 0xC0000000CLL;
    v40[2] = 0;
    v40[3] = 0;
    v40[4] = v41;
    v40[5] = v42;
    v45 = (unint64_t *)&v42->__shared_owners_;
    do
      v46 = __ldxr(v45);
    while (__stxr(v46 + 1, v45));
  }
  else
  {
    *v40 = 0;
    v40[1] = 0xC0000000CLL;
    v40[2] = 0;
    v40[3] = 0;
    v40[4] = v41;
    v40[5] = 0;
  }
  v40[6] = 0;
  sub_20BDEB47C(&__str, (uint64_t)v40);
  if (v42)
  {
    v47 = (unint64_t *)&v42->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v77 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
  if (__str.__r_.__value_.__l.__size_)
  {
    v49 = (unint64_t *)(__str.__r_.__value_.__l.__size_ + 8);
    do
      v50 = __ldxr(v49);
    while (__stxr(v50 + 1, v49));
  }
  sub_20BDEB394(v34, (uint64_t *)&v77);
  v51 = (std::__shared_weak_count *)*((_QWORD *)&v77 + 1);
  if (*((_QWORD *)&v77 + 1))
  {
    v52 = (unint64_t *)(*((_QWORD *)&v77 + 1) + 8);
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
  v54 = operator new(0x38uLL);
  v55 = v86;
  v56 = v87;
  v75 = v86;
  v76 = v87;
  if (v87)
  {
    v57 = (unint64_t *)&v87->__shared_owners_;
    do
      v58 = __ldxr(v57);
    while (__stxr(v58 + 1, v57));
    *v54 = 0;
    v54[1] = 0xD0000000DLL;
    v54[2] = 0;
    v54[3] = 0;
    v54[4] = v55;
    v54[5] = v56;
    v59 = (unint64_t *)&v56->__shared_owners_;
    do
      v60 = __ldxr(v59);
    while (__stxr(v60 + 1, v59));
  }
  else
  {
    *v54 = 0;
    v54[1] = 0xD0000000DLL;
    v54[2] = 0;
    v54[3] = 0;
    v54[4] = v55;
    v54[5] = 0;
  }
  v54[6] = 0;
  sub_20BDEB47C(&__str, (uint64_t)v54);
  if (v56)
  {
    v61 = (unint64_t *)&v56->__shared_owners_;
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
  v74 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
  if (__str.__r_.__value_.__l.__size_)
  {
    v63 = (unint64_t *)(__str.__r_.__value_.__l.__size_ + 8);
    do
      v64 = __ldxr(v63);
    while (__stxr(v64 + 1, v63));
  }
  sub_20BDEB394(v34, (uint64_t *)&v74);
  v65 = (std::__shared_weak_count *)*((_QWORD *)&v74 + 1);
  if (*((_QWORD *)&v74 + 1))
  {
    v66 = (unint64_t *)(*((_QWORD *)&v74 + 1) + 8);
    do
      v67 = __ldaxr(v66);
    while (__stlxr(v67 - 1, v66));
    if (!v67)
    {
      ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
      std::__shared_weak_count::__release_weak(v65);
    }
  }
  size = (std::__shared_weak_count *)__str.__r_.__value_.__l.__size_;
  if (__str.__r_.__value_.__l.__size_)
  {
    v69 = (unint64_t *)(__str.__r_.__value_.__l.__size_ + 8);
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }
  v71 = v87;
  if (v87)
  {
    v72 = (unint64_t *)&v87->__shared_owners_;
    do
      v73 = __ldaxr(v72);
    while (__stlxr(v73 - 1, v72));
    if (!v73)
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
}

void sub_20BDEAEA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  uint64_t v29;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a10);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&__p);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v29 - 112));
  _Unwind_Resume(a1);
}

uint64_t sub_20BDEAFA8(uint64_t a1, uint64_t a2, const void ***a3)
{
  void **v5;
  _QWORD *v6;
  Alembic::AbcCoreAbstract::v12::TimeSampling *v7;
  unint64_t v8;
  char *v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  _QWORD *exception;
  _QWORD *v25;
  __int128 __p;
  char v27;
  _QWORD v28[4];
  char v29[16];
  uint64_t v30[33];
  __int128 v31;

  *(_BYTE *)(a1 + 8) = -1;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)a1 = off_24C518128;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  sub_20BDEBF8C((uint64_t *)(a1 + 56), a3);
  Alembic::Ogawa::v12::OArchive::OArchive(a1 + 80, a2);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  v5 = (void **)(a1 + 168);
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_DWORD *)(a1 + 224) = 1065353216;
  v6 = operator new(0x18uLL);
  v6[2] = 0;
  v6[1] = 0;
  *v6 = v6 + 1;
  sub_20BDEC9AC((_QWORD *)(a1 + 232), (uint64_t)v6);
  v7 = (Alembic::AbcCoreAbstract::v12::TimeSampling *)operator new(0x28uLL);
  Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(v7);
  sub_20BDEA220(&v31, (uint64_t)v7);
  sub_20BDEA72C((char **)(a1 + 144), &v31);
  v8 = *(_QWORD *)(a1 + 184);
  v9 = *(char **)(a1 + 176);
  if ((unint64_t)v9 >= v8)
  {
    v11 = (char *)*v5;
    v12 = (v9 - (_BYTE *)*v5) >> 3;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 61)
      sub_20BDDF694();
    v14 = v8 - (_QWORD)v11;
    if (v14 >> 2 > v13)
      v13 = v14 >> 2;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
      v15 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    if (v15)
    {
      v16 = (char *)sub_20BDDF6A8(a1 + 184, v15);
      v11 = *(char **)(a1 + 168);
      v9 = *(char **)(a1 + 176);
    }
    else
    {
      v16 = 0;
    }
    v17 = &v16[8 * v12];
    v18 = &v16[8 * v15];
    *(_QWORD *)v17 = 0;
    v10 = v17 + 8;
    while (v9 != v11)
    {
      v19 = *((_QWORD *)v9 - 1);
      v9 -= 8;
      *((_QWORD *)v17 - 1) = v19;
      v17 -= 8;
    }
    *(_QWORD *)(a1 + 168) = v17;
    *(_QWORD *)(a1 + 176) = v10;
    *(_QWORD *)(a1 + 184) = v18;
    if (v11)
      operator delete(v11);
  }
  else
  {
    *(_QWORD *)v9 = 0;
    v10 = v9 + 8;
  }
  *(_QWORD *)(a1 + 176) = v10;
  if (!Alembic::Ogawa::v12::OArchive::isValid((Alembic::Ogawa::v12::OStream **)(a1 + 80)))
  {
    sub_20BDDBD68((uint64_t)v29);
    sub_20BDDC1C8(v30, (uint64_t)"Could not use the given ostream.", 32);
    std::stringbuf::str();
    sub_20BDDBF20(v28, &__p);
    if (v27 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v25 = sub_20BDDC09C(exception, (uint64_t)v28);
    __cxa_throw(v25, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDEA86C(a1);
  v20 = (std::__shared_weak_count *)*((_QWORD *)&v31 + 1);
  if (*((_QWORD *)&v31 + 1))
  {
    v21 = (unint64_t *)(*((_QWORD *)&v31 + 1) + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  return a1;
}

void sub_20BDEB234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v6;
  Alembic::Ogawa::v12::OArchive *v7;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v8;
  void **v9;
  uint64_t v10;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v11;
  void **v12;
  uint64_t v13;
  void *v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  std::exception v18;
  va_list va;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v18.__vftable = va_arg(va1, std::exception_vtbl *);
  v20 = va_arg(va1, _QWORD);
  v21 = va_arg(va1, _QWORD);
  v22 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v13 - 104));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v11);
  sub_20BDEC38C(v10);
  v15 = *v9;
  if (*v9)
  {
    *(_QWORD *)(v5 + 176) = v15;
    operator delete(v15);
  }
  sub_20BDE9EB0((void ***)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v8);
  v16 = *(std::__shared_weak_count **)(v5 + 120);
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  Alembic::Ogawa::v12::OArchive::~OArchive(v7);
  sub_20BDE9D48(v6, *(_QWORD **)(v5 + 64));
  if (*(char *)(v5 + 55) < 0)
    operator delete(*v12);
  v17 = *(std::__shared_weak_count **)(v5 + 24);
  if (v17)
    std::__shared_weak_count::__release_weak(v17);
  Alembic::AbcCoreAbstract::v12::ArchiveWriter::~ArchiveWriter((Alembic::AbcCoreAbstract::v12::ArchiveWriter *)v5);
  _Unwind_Resume(a1);
}

void sub_20BDEB324(_QWORD *a1, _QWORD *a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  sub_20BDECB48(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

_QWORD *sub_20BDEB394(uint64_t a1, uint64_t *a2)
{
  _OWORD *v3;
  _QWORD *v4;
  _QWORD *exception;
  _QWORD *v7;
  __int128 __p;
  char v9;
  _QWORD v10[4];
  _OWORD *v11[2];
  _QWORD v12[33];

  v3 = (_OWORD *)*a2;
  if (!v3)
  {
    sub_20BDDBD68((uint64_t)v11);
    sub_20BDDC1C8(v12, (uint64_t)"Invalid WrittenSampleIDPtr", 26);
    std::stringbuf::str();
    sub_20BDDBF20(v10, &__p);
    if (v9 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v7 = sub_20BDDC09C(exception, (uint64_t)v10);
    __cxa_throw(v7, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v11[0] = v3;
  v4 = sub_20BDEC400(a1, (uint64_t)v3, (uint64_t)&unk_20CA4FFEF, v11);
  return sub_20BDE881C(v4 + 6, a2);
}

void sub_20BDEB454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BDEB47C(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  sub_20BDECD14(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

uint64_t sub_20BDEB4EC(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_20BDEB4F4(uint64_t a1)
{
  return a1 + 56;
}

double sub_20BDEB4FC@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 16));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_20BDEB534(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  void *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  __int128 v29;

  *a2 = 0;
  a2[1] = 0;
  v4 = (std::__shared_weak_count *)a1[15];
  if (!v4 || (v5 = std::__shared_weak_count::lock(v4), (a2[1] = (uint64_t)v5) == 0) || (v6 = a1[14], (*a2 = v6) == 0))
  {
    v7 = operator new(0x60uLL);
    (*(void (**)(uint64_t *__return_ptr, _QWORD *))(*a1 + 40))(&v27, a1);
    v8 = (std::__shared_weak_count *)a1[17];
    v25 = a1[16];
    v26 = v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
    }
    sub_20BDF70A0(v7, &v27, &v25, a1 + 7);
    sub_20BDECE08((uint64_t *)&v29, (uint64_t)v7);
    sub_20BDE82DC((uint64_t)a2, &v29);
    v11 = (std::__shared_weak_count *)*((_QWORD *)&v29 + 1);
    if (*((_QWORD *)&v29 + 1))
    {
      v12 = (unint64_t *)(*((_QWORD *)&v29 + 1) + 8);
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    v14 = v26;
    if (v26)
    {
      v15 = (unint64_t *)&v26->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    v17 = v28;
    if (v28)
    {
      v18 = (unint64_t *)&v28->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    v21 = *a2;
    v20 = a2[1];
    if (v20)
    {
      v22 = (unint64_t *)(v20 + 16);
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
    v24 = (std::__shared_weak_count *)a1[15];
    a1[14] = v21;
    a1[15] = v20;
    if (v24)
      std::__shared_weak_count::__release_weak(v24);
  }
}

void sub_20BDEB6D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v11;
  void *v12;

  operator delete(v12);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDEB710(_QWORD *a1, const Alembic::AbcCoreAbstract::v12::TimeSampling *a2)
{
  char **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  Alembic::AbcCoreAbstract::v12::TimeSampling *v10;
  unint64_t v11;
  char *v12;
  _QWORD *v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  void *__p;
  char v31;
  _QWORD v32[13];
  char v33;
  uint64_t v34;
  __int128 v35;

  v4 = (char **)(a1 + 18);
  v5 = a1[19] - a1[18];
  if (v5 < 1)
  {
LABEL_7:
    v10 = (Alembic::AbcCoreAbstract::v12::TimeSampling *)operator new(0x28uLL);
    Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(v10, a2);
    sub_20BDEA220(&v35, (uint64_t)v10);
    sub_20BDEA72C(v4, &v35);
    v11 = a1[23];
    v12 = (char *)a1[22];
    if ((unint64_t)v12 >= v11)
    {
      v14 = (char *)a1[21];
      v15 = (v12 - v14) >> 3;
      if ((unint64_t)(v15 + 1) >> 61)
        sub_20BDDF694();
      v16 = v11 - (_QWORD)v14;
      v17 = (uint64_t)(v11 - (_QWORD)v14) >> 2;
      if (v17 <= v15 + 1)
        v17 = v15 + 1;
      if (v16 >= 0x7FFFFFFFFFFFFFF8)
        v18 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v18 = v17;
      if (v18)
      {
        v19 = (char *)sub_20BDDF6A8((uint64_t)(a1 + 23), v18);
        v14 = (char *)a1[21];
        v12 = (char *)a1[22];
      }
      else
      {
        v19 = 0;
      }
      v20 = &v19[8 * v15];
      v21 = &v19[8 * v18];
      *(_QWORD *)v20 = 0;
      v13 = v20 + 8;
      while (v12 != v14)
      {
        v22 = *((_QWORD *)v12 - 1);
        v12 -= 8;
        *((_QWORD *)v20 - 1) = v22;
        v20 -= 8;
      }
      a1[21] = v20;
      a1[22] = v13;
      a1[23] = v21;
      if (v14)
        operator delete(v14);
    }
    else
    {
      *(_QWORD *)v12 = 0;
      v13 = v12 + 8;
    }
    a1[22] = v13;
    v24 = a1[18];
    v23 = a1[19];
    sub_20BDDBD68((uint64_t)v32);
    v7 = ((v23 - v24) >> 4) - 1;
    std::ostream::operator<<();
    std::stringbuf::str();
    if (v31 < 0)
      operator delete(__p);
    v32[0] = *MEMORY[0x24BEDB7F0];
    v25 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
    *(_QWORD *)((char *)v32 + *(_QWORD *)(v32[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
    v32[2] = v25;
    v32[3] = MEMORY[0x24BEDB848] + 16;
    if (v33 < 0)
      operator delete((void *)v32[11]);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x212B92EB0](&v34);
    v26 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
    if (*((_QWORD *)&v35 + 1))
    {
      v27 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = (unint64_t)v5 >> 4;
    if (v8 <= 1)
      v9 = 1;
    else
      v9 = v8;
    while (!sub_20BDEB9A8((uint64_t)a2, *(_QWORD *)&(*v4)[v6]))
    {
      ++v7;
      v6 += 16;
      if (v9 == v7)
        goto LABEL_7;
    }
  }
  return v7;
}

void sub_20BDEB968(_Unwind_Exception *a1)
{
  uint64_t v1;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_20BDEB998()
{
  void *v0;

  operator delete(v0);
  JUMPOUT(0x20BDEB990);
}

BOOL sub_20BDEB9A8(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;
  double *v7;
  uint64_t v8;
  double v9;
  BOOL v10;

  result = Alembic::AbcCoreAbstract::v12::TimeSamplingType::operator==(a1, a2);
  if (result)
  {
    v6 = *(_QWORD *)(a1 + 16);
    v5 = *(_QWORD *)(a1 + 24);
    v7 = *(double **)(a2 + 16);
    if (v5 - v6 == *(_QWORD *)(a2 + 24) - (_QWORD)v7)
    {
      if (v6 == v5)
      {
        return 1;
      }
      else
      {
        v8 = v6 + 8;
        do
        {
          v9 = *v7++;
          result = *(double *)(v8 - 8) == v9;
          v10 = *(double *)(v8 - 8) != v9 || v8 == v5;
          v8 += 8;
        }
        while (!v10);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_20BDEBA20@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, _OWORD *a3@<X8>)
{
  uint64_t v3;
  __int128 v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *exception;
  _QWORD *v8;
  __int128 __p;
  char v10;
  _QWORD v11[4];
  _BYTE v12[16];
  _QWORD v13[33];

  v3 = *(_QWORD *)(result + 144);
  if (a2 >= (unint64_t)((*(_QWORD *)(result + 152) - v3) >> 4))
  {
    sub_20BDDBD68((uint64_t)v12);
    sub_20BDDC1C8(v13, (uint64_t)"Invalid index provided to getTimeSampling.", 42);
    std::stringbuf::str();
    sub_20BDDBF20(v11, &__p);
    if (v10 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v8 = sub_20BDDC09C(exception, (uint64_t)v11);
    __cxa_throw(v8, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v4 = *(_OWORD *)(v3 + 16 * a2);
  *a3 = v4;
  if (*((_QWORD *)&v4 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v4 + 1) + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

void sub_20BDEBAE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDEBB10(uint64_t a1, unsigned int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 168);
  if (a2 >= (unint64_t)((*(_QWORD *)(a1 + 176) - v2) >> 3))
    return 0x7FFFFFFFFFFFFFFFLL;
  else
    return *(_QWORD *)(v2 + 8 * a2);
}

uint64_t sub_20BDEBB34(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(result + 168);
  if (a2 < (unint64_t)((*(_QWORD *)(result + 176) - v3) >> 3))
    *(_QWORD *)(v3 + 8 * a2) = a3;
  return result;
}

void sub_20BDEBB50(Alembic::AbcCoreAbstract::v12::ArchiveWriter *a1)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  void **v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _QWORD *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  void *v35;
  std::__shared_weak_count *v36;
  std::__shared_weak_count *v37;
  Alembic::Ogawa::v12::OGroup *v38;
  std::__shared_weak_count *v39;
  Alembic::Ogawa::v12::OData *v40;
  std::__shared_weak_count *v41;
  Alembic::Ogawa::v12::OGroup *v42;
  std::__shared_weak_count *v43;
  void *__p;
  std::__shared_weak_count *v45;
  uint64_t v46;
  Alembic::Ogawa::v12::OData *v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  void *v51[2];
  unsigned __int8 v52;

  *(_QWORD *)a1 = off_24C518128;
  v2 = (uint64_t)a1 + 192;
  sub_20BDEC958((uint64_t)a1 + 192);
  v3 = *((_QWORD *)a1 + 16);
  if (v3)
  {
    v4 = (std::__shared_weak_count *)*((_QWORD *)a1 + 30);
    v49 = *((_QWORD *)a1 + 29);
    v50 = v4;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    sub_20BDF66A0(v3, &v49, (Alembic::Util::v12::SpookyHash *)v51);
    v7 = v50;
    if (v50)
    {
      v8 = (unint64_t *)&v50->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
  sub_20BDEBF08((_QWORD *)a1 + 16);
  if (Alembic::Ogawa::v12::OArchive::isValid((Alembic::Ogawa::v12::OStream **)a1 + 10))
  {
    Alembic::Util::v12::TokenMap::get((Alembic::AbcCoreAbstract::v12::ArchiveWriter *)((char *)a1 + 56), 0x3Bu, 61, 1);
    Alembic::Ogawa::v12::OArchive::getGroup((uint64_t)a1 + 80, &__p);
    if ((v52 & 0x80u) == 0)
      v10 = v52;
    else
      v10 = (uint64_t)v51[1];
    if ((v52 & 0x80u) == 0)
      v11 = v51;
    else
      v11 = (void **)v51[0];
    Alembic::Ogawa::v12::OGroup::addData((Alembic::Ogawa::v12::OGroup *)__p, v11, v10, &v47);
    v12 = v48;
    if (v48)
    {
      v13 = (unint64_t *)&v48->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    v15 = v45;
    if (v45)
    {
      v16 = (unint64_t *)&v45->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    __p = 0;
    v45 = 0;
    v46 = 0;
    v18 = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::ArchiveWriter *))(*(_QWORD *)a1 + 64))(a1);
    if (v18)
    {
      v19 = 0;
      v20 = v18;
      do
      {
        v21 = *(_QWORD *)(*((_QWORD *)a1 + 21) + 8 * v19);
        (*(void (**)(Alembic::Ogawa::v12::OGroup **__return_ptr, Alembic::AbcCoreAbstract::v12::ArchiveWriter *, uint64_t))(*(_QWORD *)a1 + 56))(&v42, a1, v19);
        sub_20BE01634((unint64_t *)&__p, v21, (uint64_t)v42);
        v22 = v43;
        if (v43)
        {
          v23 = (unint64_t *)&v43->__shared_owners_;
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
        ++v19;
      }
      while (v19 != v20);
    }
    Alembic::Ogawa::v12::OArchive::getGroup((uint64_t)a1 + 80, &v42);
    Alembic::Ogawa::v12::OGroup::addData(v42, __p, (char *)v45 - (_BYTE *)__p, &v40);
    v25 = v41;
    if (v41)
    {
      v26 = (unint64_t *)&v41->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    v28 = v43;
    if (v43)
    {
      v29 = (unint64_t *)&v43->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = (_QWORD *)*((_QWORD *)a1 + 29);
    Alembic::Ogawa::v12::OArchive::getGroup((uint64_t)a1 + 80, &v38);
    sub_20BDF2EE4(v31, &v38);
    v32 = v39;
    if (v39)
    {
      v33 = (unint64_t *)&v39->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    if (__p)
    {
      v45 = (std::__shared_weak_count *)__p;
      operator delete(__p);
    }
    if ((char)v52 < 0)
      operator delete(v51[0]);
  }
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((Alembic::AbcCoreAbstract::v12::ArchiveWriter *)((char *)a1 + 232));
  sub_20BDEC38C(v2);
  v35 = (void *)*((_QWORD *)a1 + 21);
  if (v35)
  {
    *((_QWORD *)a1 + 22) = v35;
    operator delete(v35);
  }
  v51[0] = (char *)a1 + 144;
  sub_20BDE9EB0((void ***)v51);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((Alembic::AbcCoreAbstract::v12::ArchiveWriter *)((char *)a1 + 128));
  v36 = (std::__shared_weak_count *)*((_QWORD *)a1 + 15);
  if (v36)
    std::__shared_weak_count::__release_weak(v36);
  Alembic::Ogawa::v12::OArchive::~OArchive((Alembic::AbcCoreAbstract::v12::ArchiveWriter *)((char *)a1 + 80));
  sub_20BDE9D48((uint64_t)a1 + 56, *((_QWORD **)a1 + 8));
  if (*((char *)a1 + 55) < 0)
    operator delete(*((void **)a1 + 4));
  v37 = (std::__shared_weak_count *)*((_QWORD *)a1 + 3);
  if (v37)
    std::__shared_weak_count::__release_weak(v37);
  Alembic::AbcCoreAbstract::v12::ArchiveWriter::~ArchiveWriter(a1);
}

void sub_20BDEBF08(_QWORD *a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void sub_20BDEBF68(Alembic::AbcCoreAbstract::v12::ArchiveWriter *a1)
{
  void *v1;

  sub_20BDEBB50(a1);
  operator delete(v1);
}

uint64_t sub_20BDEBF7C(uint64_t a1)
{
  return (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 4;
}

uint64_t *sub_20BDEBF8C(uint64_t *a1, const void ***a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_20BDEBFE0(a1, *a2, a2 + 1);
  return a1;
}

void sub_20BDEBFC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BDE9D48(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_20BDEBFE0(uint64_t *result, const void **a2, const void ***a3)
{
  const void **v4;
  uint64_t **v5;
  uint64_t *v6;
  const void **v7;
  const void ***v8;
  BOOL v9;

  if (a2 != (const void **)a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = sub_20BDEC064(v5, v6, v4 + 4, (__int128 *)v4 + 2);
      v7 = (const void **)v4[1];
      if (v7)
      {
        do
        {
          v8 = (const void ***)v7;
          v7 = (const void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (const void ***)v4[2];
          v9 = *v8 == v4;
          v4 = (const void **)v8;
        }
        while (!v9);
      }
      v4 = (const void **)v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_20BDEC064(uint64_t **a1, uint64_t *a2, const void **a3, __int128 *a4)
{
  const void **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;
  const void **v12;

  v6 = sub_20BDEC0F8(a1, a2, &v12, &v11, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    sub_20BDEC290((uint64_t)a1, a4, (uint64_t)v10);
    sub_20BDDE1B4(a1, (uint64_t)v12, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    sub_20BDDE3A0((uint64_t)v10, 0);
  }
  return v7;
}

const void **sub_20BDEC0F8(_QWORD *a1, uint64_t *a2, const void ***a3, uint64_t *a4, const void **a5)
{
  const void **v9;
  const void **v11;
  const void **v12;
  uint64_t v13;
  const void **v14;
  const void **v15;
  uint64_t *v16;
  BOOL v17;
  const void **v18;

  v9 = (const void **)(a1 + 1);
  if (a1 + 1 == a2 || sub_20BDDDF74((uint64_t)(a1 + 2), a5, (const void **)a2 + 4))
  {
    if ((uint64_t *)*a1 == a2)
    {
      v12 = (const void **)a2;
LABEL_16:
      if (*a2)
      {
        *a3 = v12;
        return v12 + 1;
      }
      else
      {
        *a3 = (const void **)a2;
        return (const void **)a2;
      }
    }
    v11 = (const void **)*a2;
    if (*a2)
    {
      do
      {
        v12 = v11;
        v11 = (const void **)v11[1];
      }
      while (v11);
    }
    else
    {
      v16 = a2;
      do
      {
        v12 = (const void **)v16[2];
        v17 = *v12 == v16;
        v16 = (uint64_t *)v12;
      }
      while (v17);
    }
    if (sub_20BDDDF74((uint64_t)(a1 + 2), v12 + 4, a5))
      goto LABEL_16;
    return (const void **)sub_20BDDE084((uint64_t)a1, a3, a5);
  }
  if (sub_20BDDDF74((uint64_t)(a1 + 2), (const void **)a2 + 4, a5))
  {
    a4 = a2 + 1;
    v13 = a2[1];
    if (v13)
    {
      v14 = (const void **)a2[1];
      do
      {
        v15 = v14;
        v14 = (const void **)*v14;
      }
      while (v14);
    }
    else
    {
      v18 = (const void **)a2;
      do
      {
        v15 = (const void **)v18[2];
        v17 = *v15 == v18;
        v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!sub_20BDDDF74((uint64_t)(a1 + 2), a5, v15 + 4))
        return (const void **)sub_20BDDE084((uint64_t)a1, a3, a5);
      v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = (const void **)a2;
    }
    return (const void **)a4;
  }
  *a3 = (const void **)a2;
  *a4 = (uint64_t)a2;
  return (const void **)a4;
}

char *sub_20BDEC290@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  char *result;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x50uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = sub_20BDEC2F8(v6 + 32, a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_20BDEC2E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BDDE3A0(v1, 0);
  _Unwind_Resume(a1);
}

char *sub_20BDEC2F8(char *__dst, __int128 *a2)
{
  __int128 v4;
  _BYTE *v5;
  __int128 v6;

  if (*((char *)a2 + 23) < 0)
  {
    sub_20BDDBFAC(__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    *((_QWORD *)__dst + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_20BDDBFAC(v5, *((void **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v6 = *(__int128 *)((char *)a2 + 24);
    *((_QWORD *)__dst + 5) = *((_QWORD *)a2 + 5);
    *(_OWORD *)v5 = v6;
  }
  return __dst;
}

void sub_20BDEC370(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BDEC38C(uint64_t a1)
{
  void *v2;

  sub_20BDEC3C4(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void sub_20BDEC3C4(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v2 + 6));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

_QWORD *sub_20BDEC400(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  _OWORD *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  uint64_t v26[2];
  char v27;

  v7 = *(_QWORD *)(a2 + 16);
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v4 = *(_QWORD *)(a2 + 16);
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v12 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v12)
    {
      v13 = (_QWORD *)*v12;
      if (*v12)
      {
        do
        {
          v14 = v13[1];
          if (v14 == v7)
          {
            if (sub_20BDEC684((uint64_t)(v13 + 2), a2))
              return v13;
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v8)
                v14 %= v8;
            }
            else
            {
              v14 &= v8 - 1;
            }
            if (v14 != v4)
              break;
          }
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
    }
  }
  v15 = operator new(0x40uLL);
  v26[0] = (uint64_t)v15;
  v26[1] = a1 + 16;
  *v15 = 0;
  v15[1] = v7;
  v16 = *a4;
  *((_OWORD *)v15 + 1) = **a4;
  v15[4] = *((_QWORD *)v16 + 2);
  v15[5] = *((_QWORD *)v16 + 3);
  v15[6] = 0;
  v15[7] = 0;
  v27 = 1;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v8 || (float)(v18 * (float)v8) < v17)
  {
    v19 = 1;
    if (v8 >= 3)
      v19 = (v8 & (v8 - 1)) != 0;
    v20 = v19 | (2 * v8);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    sub_20BDEC6E0(a1, v22);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v24 >= v8)
          v24 %= v8;
      }
      else
      {
        v24 &= v8 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  v13 = (_QWORD *)v26[0];
  v26[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  sub_20BDEC914(v26, 0);
  return v13;
}

void sub_20BDEC66C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDEC914((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

BOOL sub_20BDEC684(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)a1 == *(_QWORD *)a2
      && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
      && *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16)
      && *(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24);
}

void sub_20BDEC6E0(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      sub_20BDEC7BC(a1, prime);
  }
}

void sub_20BDEC7BC(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      sub_20BDDF5B4();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void sub_20BDEC914(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((_BYTE *)a1 + 16))
      pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v2 + 48));
    operator delete((void *)v2);
  }
}

void sub_20BDEC958(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    sub_20BDEC3C4(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

_QWORD *sub_20BDEC9AC(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  char **v6;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C5181D8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  v6 = 0;
  sub_20BDECB08(&v6, 0);
  return a1;
}

void sub_20BDECA0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDECB08((char ***)va, 0);
  _Unwind_Resume(a1);
}

void sub_20BDECA28(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDECA3C(uint64_t a1)
{
  sub_20BDECA84(a1 + 24, *(char ***)(a1 + 24));
}

uint64_t sub_20BDECA44(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518228))
    return a1 + 24;
  else
    return 0;
}

void sub_20BDECA84(uint64_t a1, char **a2)
{
  if (a2)
  {
    sub_20BDECAB8((uint64_t)a2, a2[1]);
    operator delete(a2);
  }
}

void sub_20BDECAB8(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_20BDECAB8(a1, *(_QWORD *)a2);
    sub_20BDECAB8(a1, *((_QWORD *)a2 + 1));
    if (a2[55] < 0)
      operator delete(*((void **)a2 + 4));
    operator delete(a2);
  }
}

void sub_20BDECB08(char ***a1, char **a2)
{
  char **v2;

  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    sub_20BDECAB8((uint64_t)v2, v2[1]);
    operator delete(v2);
  }
}

_QWORD *sub_20BDECB48(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518250;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  sub_20BDEA008((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_20BDECB9C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  if (v1)
  {
    v3 = (void *)sub_20BDF59DC(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_20BDECBBC(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDECBD0(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v2 = (void *)sub_20BDF59DC(v1);
    operator delete(v2);
  }
}

uint64_t sub_20BDECBF4(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C5182A0))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDECC34(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &unk_24C5182C8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDECC7C(_Unwind_Exception *exception_object)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource **v1;
  void *v3;

  if (v1)
  {
    Alembic::Ogawa::v12::OData::~OData(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_20BDECC9C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDECCB0(uint64_t a1)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource **v1;
  void *v2;

  v1 = *(pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource ***)(a1 + 24);
  if (v1)
  {
    Alembic::Ogawa::v12::OData::~OData(v1);
    operator delete(v2);
  }
}

uint64_t sub_20BDECCD4(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518318))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDECD14(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518340;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDECD58(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
  {
    pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v1 + 32));
    operator delete((void *)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_20BDECD7C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDECD90(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v1 + 32));
    operator delete((void *)v1);
  }
}

uint64_t sub_20BDECDC8(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518390))
    return a1 + 24;
  else
    return 0;
}

uint64_t *sub_20BDECE08(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C5183B8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BDECE64(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDECE88(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BDECE9C(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BDECEB4(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518408))
    return a1 + 24;
  else
    return 0;
}

uint64_t sub_20BDECEF4(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  Alembic::Ogawa::v12::IGroup **v6;
  uint64_t **v7;
  uint64_t NumChildren;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  char *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  _QWORD *exception;
  _QWORD *v35;
  unint64_t **v36;
  std::__shared_weak_count *v37;
  void *__p[2];
  char v39;
  void **v40[4];
  char *v41;
  char *v42;
  uint64_t v43[33];

  *(_OWORD *)(a1 + 16) = 0u;
  v6 = (Alembic::Ogawa::v12::IGroup **)(a1 + 16);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 40) = a1 + 48;
  v7 = (uint64_t **)(a1 + 40);
  *(_QWORD *)(a1 + 56) = 0;
  *(_OWORD *)a1 = 0u;
  *(_QWORD *)(a1 + 32) = 0;
  if (!*a2)
  {
    sub_20BDDBD68((uint64_t)&v41);
    sub_20BDDC1C8(v43, (uint64_t)"invalid compound data group", 27);
    std::stringbuf::str();
    sub_20BDDBF20(v40, (__int128 *)__p);
    if (v39 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v35 = sub_20BDDC09C(exception, (uint64_t)v40);
    __cxa_throw(v35, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDE881C((_QWORD *)(a1 + 16), a2);
  NumChildren = Alembic::Ogawa::v12::IGroup::getNumChildren(*v6);
  if (NumChildren)
  {
    v12 = NumChildren - 1;
    if (Alembic::Ogawa::v12::IGroup::isChildData(*v6, NumChildren - 1))
    {
      v41 = 0;
      v42 = 0;
      v43[0] = 0;
      v13 = *(std::__shared_weak_count **)(a1 + 24);
      v36 = *(unint64_t ***)(a1 + 16);
      v37 = v13;
      if (v13)
      {
        p_shared_owners = (unint64_t *)&v13->__shared_owners_;
        do
          v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
      }
      sub_20BDFB78C(&v36, v12, a3, a4, a5, &v41);
      v16 = v37;
      if (v37)
      {
        v17 = (unint64_t *)&v37->__shared_owners_;
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v20 = v41;
      v19 = v42;
      v21 = (v42 - v41) >> 4;
      if (is_mul_ok(v21, 0x60uLL))
        v22 = (96 * ((v42 - v41) >> 4)) | 0x10;
      else
        v22 = -1;
      v23 = operator new[](v22);
      *v23 = 96;
      v23[1] = v21;
      v24 = v23 + 2;
      if (v19 == v20)
      {
        *(_QWORD *)(a1 + 32) = v24;
      }
      else
      {
        v25 = 0;
        v26 = 96 * v21;
        do
        {
          v27 = &v23[v25 / 8];
          *((_OWORD *)v27 + 1) = 0u;
          *((_OWORD *)v27 + 2) = 0u;
          pthread_mutex_init((pthread_mutex_t *)&v23[v25 / 8 + 6], 0);
          v25 += 96;
        }
        while (v26 != v25);
        v28 = v41;
        v29 = v42;
        *(_QWORD *)(a1 + 32) = v24;
        if (v29 != v28)
        {
          v30 = 0;
          v31 = 0;
          v32 = 0;
          do
          {
            __p[0] = *(void **)&v28[v30];
            sub_20BDEEA20(v7, (const void **)__p[0], (uint64_t)&unk_20CA505F0, (__int128 **)__p)[7] = v32;
            sub_20BDE881C((_QWORD *)(*(_QWORD *)(a1 + 32) + v31), (uint64_t *)&v41[v30]);
            ++v32;
            v28 = v41;
            v31 += 96;
            v30 += 16;
          }
          while (v32 < (v42 - v41) >> 4);
        }
      }
      v40[0] = (void **)&v41;
      sub_20BDE9EB0(v40);
    }
  }
  return a1;
}

void sub_20BDED198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v8;
  uint64_t v9;
  std::__shared_weak_count *v11;
  std::exception v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  sub_20BDECAB8(v9, *(char **)(v7 + 48));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v8);
  v11 = *(std::__shared_weak_count **)(v7 + 8);
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
  _Unwind_Resume(a1);
}

void sub_20BDED258(uint64_t a1)
{
  std::__shared_weak_count *v2;

  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
  v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)a1);
}

uint64_t sub_20BDED294(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = 96 * v3;
      do
      {
        pthread_mutex_destroy((pthread_mutex_t *)(v2 + v4 - 64));
        v5 = *(std::__shared_weak_count **)(v2 + v4 - 72);
        if (v5)
          std::__shared_weak_count::__release_weak(v5);
        pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v2 + v4 - 96));
        v4 -= 96;
      }
      while (v4);
    }
    operator delete[]((void *)(v2 - 16));
  }
  sub_20BDECAB8(a1 + 40, *(char **)(a1 + 48));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 16));
  v6 = *(std::__shared_weak_count **)(a1 + 8);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
  return a1;
}

uint64_t sub_20BDED32C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t sub_20BDED334(uint64_t a1, uint64_t a2, unint64_t a3)
{
  _QWORD *v4;
  _QWORD *exception;
  _QWORD *v6;
  __int128 __p;
  char v8;
  _QWORD v9[4];
  _BYTE v10[16];
  _QWORD v11[33];

  if (*(_QWORD *)(a1 + 56) < a3)
  {
    sub_20BDDBD68((uint64_t)v10);
    v4 = sub_20BDDC1C8(v11, (uint64_t)"Out of range index in ", 22);
    sub_20BDDC1C8(v4, (uint64_t)"CprData::getPropertyHeader: ", 28);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v9, &__p);
    if (v8 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v6 = sub_20BDDC09C(exception, (uint64_t)v9);
    __cxa_throw(v6, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96 * a3);
}

void sub_20BDED400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  std::exception v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDED428(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  v5 = sub_20BDEEBA4(a1 + 40, a3);
  if (a1 + 48 == v5)
    return 0;
  v7 = *(std::__shared_weak_count **)(a2 + 8);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = sub_20BDED334(a1, v6, *(_QWORD *)(v5 + 56));
  if (v7)
  {
    v11 = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return v10;
}

void sub_20BDED4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDED4EC@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  pthread_mutex_t *v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count **v16;
  std::__shared_weak_count *v17;
  void **v18;
  void *v19;
  void *v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  __int128 v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  void *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  void *v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  unint64_t *v74;
  unint64_t v75;
  _QWORD *v76;
  int v77;
  const void *v78;
  uint64_t v79;
  _QWORD *v80;
  _QWORD *exception;
  _QWORD *v82;
  _QWORD *v83;
  _QWORD *v84;
  uint64_t v85;
  std::__shared_weak_count *v86;
  uint64_t v87;
  std::__shared_weak_count *v88;
  uint64_t v89;
  std::__shared_weak_count *v90;
  uint64_t v91;
  std::__shared_weak_count *v92;
  uint64_t v93;
  std::__shared_weak_count *v94;
  void *v95[2];
  void *__p[2];
  char v97;
  void *lpsrc;
  std::__shared_weak_count *v99;
  __int128 v100;
  _QWORD v101[34];

  result = sub_20BDEEBA4(a1 + 40, (const void **)a3);
  if (a1 + 48 == result)
  {
    *a4 = 0;
    a4[1] = 0;
    return result;
  }
  v9 = result;
  v10 = *(_QWORD *)(a1 + 32);
  v11 = *(_QWORD *)(result + 56);
  v12 = (_QWORD *)(v10 + 96 * v11);
  if (*(_DWORD *)(*v12 + 24) != 1)
  {
    sub_20BDDBD68((uint64_t)&v100);
    v76 = sub_20BDDC1C8(v101, (uint64_t)"Tried to read a scalar property from a non-scalar: ", 51);
    v77 = *(char *)(a3 + 23);
    if (v77 >= 0)
      v78 = (const void *)a3;
    else
      v78 = *(const void **)a3;
    if (v77 >= 0)
      v79 = *(unsigned __int8 *)(a3 + 23);
    else
      v79 = *(_QWORD *)(a3 + 8);
    v80 = sub_20BDDC1C8(v76, (uint64_t)v78, v79);
    sub_20BDDC1C8(v80, (uint64_t)", type: ", 8);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(&lpsrc, (__int128 *)__p);
    if (v97 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v82 = sub_20BDDC09C(exception, (uint64_t)&lpsrc);
    __cxa_throw(v82, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v13 = v10 + 96 * v11;
  v14 = (pthread_mutex_t *)(v13 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v13 + 32));
  v17 = *(std::__shared_weak_count **)(v13 + 24);
  v16 = (std::__shared_weak_count **)(v13 + 24);
  v15 = v17;
  v18 = (void **)(v16 - 1);
  v95[0] = 0;
  v95[1] = 0;
  if (!v17 || (v95[1] = std::__shared_weak_count::lock(v15)) == 0 || (v19 = *v18, (v95[0] = v19) == 0))
  {
    (*(void (**)(void **__return_ptr))(*(_QWORD *)*a2 + 24))(__p);
    (*(void (**)(void **__return_ptr))(*(_QWORD *)__p[0] + 24))(&lpsrc);
    if (lpsrc
    {
      v21 = v99;
      *(_QWORD *)&v100 = v20;
      *((_QWORD *)&v100 + 1) = v99;
      if (v99)
      {
        p_shared_owners = (unint64_t *)&v99->__shared_owners_;
        do
          v23 = __ldxr(p_shared_owners);
        while (__stxr(v23 + 1, p_shared_owners));
      }
    }
    else
    {
      v21 = 0;
      v20 = 0;
      v100 = 0uLL;
    }
    sub_20BDE9C40((uint64_t)v20, &v93);
    if (v21)
    {
      v24 = (unint64_t *)&v21->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    v26 = v99;
    if (v99)
    {
      v27 = (unint64_t *)&v99->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v29 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v30 = (unint64_t *)((char *)__p[1] + 8);
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    Alembic::Ogawa::v12::IGroup::getGroup(*(uint64_t ***)(a1 + 16), *(_QWORD *)(v9 + 56), 1, *(_QWORD *)(v93 + 8), &v91);
    v32 = v91;
    if (!v91)
    {
      sub_20BDDBD68((uint64_t)&v100);
      sub_20BDDC1C8(v101, (uint64_t)"Scalar Property not backed by a valid group.", 44);
      std::stringbuf::str();
      sub_20BDDBF20(&lpsrc, (__int128 *)__p);
      if (v97 < 0)
        operator delete(__p[0]);
      v83 = __cxa_allocate_exception(0x20uLL);
      v84 = sub_20BDDC09C(v83, (uint64_t)&lpsrc);
      __cxa_throw(v84, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
    v33 = operator new(0x48uLL);
    v34 = (uint64_t)v33;
    v35 = (std::__shared_weak_count *)a2[1];
    v89 = *a2;
    v90 = v35;
    if (v35)
    {
      v36 = (unint64_t *)&v35->__shared_owners_;
      do
        v37 = __ldxr(v36);
      while (__stxr(v37 + 1, v36));
    }
    v87 = v32;
    v88 = v92;
    if (v92)
    {
      v38 = (unint64_t *)&v92->__shared_owners_;
      do
        v39 = __ldxr(v38);
      while (__stxr(v39 + 1, v38));
    }
    v85 = *v12;
    v40 = (std::__shared_weak_count *)v12[1];
    v86 = v40;
    if (v40)
    {
      v41 = (unint64_t *)&v40->__shared_owners_;
      do
        v42 = __ldxr(v41);
      while (__stxr(v42 + 1, v41));
    }
    sub_20BDFD7F0(v33, &v89, &v87, &v85);
    sub_20BDEEC30((uint64_t *)&v100, v34);
    v43 = v100;
    v100 = 0uLL;
    v44 = (std::__shared_weak_count *)v95[1];
    *(_OWORD *)v95 = v43;
    if (v44)
    {
      v45 = (unint64_t *)&v44->__shared_owners_;
      do
        v46 = __ldaxr(v45);
      while (__stlxr(v46 - 1, v45));
      if (!v46)
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
    }
    v47 = (std::__shared_weak_count *)*((_QWORD *)&v100 + 1);
    if (*((_QWORD *)&v100 + 1))
    {
      v48 = (unint64_t *)(*((_QWORD *)&v100 + 1) + 8);
      do
        v49 = __ldaxr(v48);
      while (__stlxr(v49 - 1, v48));
      if (!v49)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
    v50 = v86;
    if (v86)
    {
      v51 = (unint64_t *)&v86->__shared_owners_;
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 - 1, v51));
      if (!v52)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
    v53 = v88;
    if (v88)
    {
      v54 = (unint64_t *)&v88->__shared_owners_;
      do
        v55 = __ldaxr(v54);
      while (__stlxr(v55 - 1, v54));
      if (!v55)
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }
    }
    v56 = v90;
    if (v90)
    {
      v57 = (unint64_t *)&v90->__shared_owners_;
      do
        v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
        std::__shared_weak_count::__release_weak(v56);
      }
    }
    v60 = v95[0];
    v59 = (std::__shared_weak_count *)v95[1];
    if (v95[1])
    {
      v61 = (unint64_t *)((char *)v95[1] + 16);
      do
        v62 = __ldxr(v61);
      while (__stxr(v62 + 1, v61));
    }
    *v18 = v60;
    v63 = *v16;
    *v16 = v59;
    if (v63)
      std::__shared_weak_count::__release_weak(v63);
    v64 = v92;
    if (v92)
    {
      v65 = (unint64_t *)&v92->__shared_owners_;
      do
        v66 = __ldaxr(v65);
      while (__stlxr(v66 - 1, v65));
      if (!v66)
      {
        ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
        std::__shared_weak_count::__release_weak(v64);
      }
    }
    v67 = v94;
    if (v94)
    {
      v68 = (unint64_t *)&v94->__shared_owners_;
      do
        v69 = __ldaxr(v68);
      while (__stlxr(v69 - 1, v68));
      if (!v69)
      {
        ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
        std::__shared_weak_count::__release_weak(v67);
      }
    }
    v19 = v95[0];
    if (!v95[0])
      goto LABEL_85;
  }
  if (v70)
  {
    v71 = (std::__shared_weak_count *)v95[1];
    *a4 = v70;
    a4[1] = v71;
    if (v71)
    {
      v72 = (unint64_t *)&v71->__shared_owners_;
      do
        v73 = __ldxr(v72);
      while (__stxr(v73 + 1, v72));
      goto LABEL_86;
    }
  }
  else
  {
LABEL_85:
    *a4 = 0;
    a4[1] = 0;
    v71 = (std::__shared_weak_count *)v95[1];
    if (v95[1])
    {
LABEL_86:
      v74 = (unint64_t *)&v71->__shared_owners_;
      do
        v75 = __ldaxr(v74);
      while (__stlxr(v75 - 1, v74));
      if (!v75)
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
      }
    }
  }
  return pthread_mutex_unlock(v14);
}

void sub_20BDEDB14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::exception a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  sub_20BDDC194(&a25);
  sub_20BDDBE98((uint64_t)&a29);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDEDBF8@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  pthread_mutex_t *v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count **v16;
  std::__shared_weak_count *v17;
  void **v18;
  void *v19;
  void *v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  __int128 v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  void *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  void *v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  unint64_t *v74;
  unint64_t v75;
  _QWORD *v76;
  int v77;
  const void *v78;
  uint64_t v79;
  _QWORD *v80;
  _QWORD *exception;
  _QWORD *v82;
  _QWORD *v83;
  _QWORD *v84;
  uint64_t v85;
  std::__shared_weak_count *v86;
  uint64_t v87;
  std::__shared_weak_count *v88;
  uint64_t v89;
  std::__shared_weak_count *v90;
  uint64_t v91;
  std::__shared_weak_count *v92;
  uint64_t v93;
  std::__shared_weak_count *v94;
  void *v95[2];
  void *__p[2];
  char v97;
  void *lpsrc;
  std::__shared_weak_count *v99;
  __int128 v100;
  _QWORD v101[34];

  result = sub_20BDEEBA4(a1 + 40, (const void **)a3);
  if (a1 + 48 == result)
  {
    *a4 = 0;
    a4[1] = 0;
    return result;
  }
  v9 = result;
  v10 = *(_QWORD *)(a1 + 32);
  v11 = *(_QWORD *)(result + 56);
  v12 = (_QWORD *)(v10 + 96 * v11);
  if (*(_DWORD *)(*v12 + 24) != 2)
  {
    sub_20BDDBD68((uint64_t)&v100);
    v76 = sub_20BDDC1C8(v101, (uint64_t)"Tried to read an array property from a non-array: ", 50);
    v77 = *(char *)(a3 + 23);
    if (v77 >= 0)
      v78 = (const void *)a3;
    else
      v78 = *(const void **)a3;
    if (v77 >= 0)
      v79 = *(unsigned __int8 *)(a3 + 23);
    else
      v79 = *(_QWORD *)(a3 + 8);
    v80 = sub_20BDDC1C8(v76, (uint64_t)v78, v79);
    sub_20BDDC1C8(v80, (uint64_t)", type: ", 8);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(&lpsrc, (__int128 *)__p);
    if (v97 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v82 = sub_20BDDC09C(exception, (uint64_t)&lpsrc);
    __cxa_throw(v82, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v13 = v10 + 96 * v11;
  v14 = (pthread_mutex_t *)(v13 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v13 + 32));
  v17 = *(std::__shared_weak_count **)(v13 + 24);
  v16 = (std::__shared_weak_count **)(v13 + 24);
  v15 = v17;
  v18 = (void **)(v16 - 1);
  v95[0] = 0;
  v95[1] = 0;
  if (!v17 || (v95[1] = std::__shared_weak_count::lock(v15)) == 0 || (v19 = *v18, (v95[0] = v19) == 0))
  {
    (*(void (**)(void **__return_ptr))(*(_QWORD *)*a2 + 24))(__p);
    (*(void (**)(void **__return_ptr))(*(_QWORD *)__p[0] + 24))(&lpsrc);
    if (lpsrc
    {
      v21 = v99;
      *(_QWORD *)&v100 = v20;
      *((_QWORD *)&v100 + 1) = v99;
      if (v99)
      {
        p_shared_owners = (unint64_t *)&v99->__shared_owners_;
        do
          v23 = __ldxr(p_shared_owners);
        while (__stxr(v23 + 1, p_shared_owners));
      }
    }
    else
    {
      v21 = 0;
      v20 = 0;
      v100 = 0uLL;
    }
    sub_20BDE9C40((uint64_t)v20, &v93);
    if (v21)
    {
      v24 = (unint64_t *)&v21->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    v26 = v99;
    if (v99)
    {
      v27 = (unint64_t *)&v99->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v29 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v30 = (unint64_t *)((char *)__p[1] + 8);
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    Alembic::Ogawa::v12::IGroup::getGroup(*(uint64_t ***)(a1 + 16), *(_QWORD *)(v9 + 56), 1, *(_QWORD *)(v93 + 8), &v91);
    v32 = v91;
    if (!v91)
    {
      sub_20BDDBD68((uint64_t)&v100);
      sub_20BDDC1C8(v101, (uint64_t)"Array Property not backed by a valid group.", 43);
      std::stringbuf::str();
      sub_20BDDBF20(&lpsrc, (__int128 *)__p);
      if (v97 < 0)
        operator delete(__p[0]);
      v83 = __cxa_allocate_exception(0x20uLL);
      v84 = sub_20BDDC09C(v83, (uint64_t)&lpsrc);
      __cxa_throw(v84, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
    v33 = operator new(0x48uLL);
    v34 = (uint64_t)v33;
    v35 = (std::__shared_weak_count *)a2[1];
    v89 = *a2;
    v90 = v35;
    if (v35)
    {
      v36 = (unint64_t *)&v35->__shared_owners_;
      do
        v37 = __ldxr(v36);
      while (__stxr(v37 + 1, v36));
    }
    v87 = v32;
    v88 = v92;
    if (v92)
    {
      v38 = (unint64_t *)&v92->__shared_owners_;
      do
        v39 = __ldxr(v38);
      while (__stxr(v39 + 1, v38));
    }
    v85 = *v12;
    v40 = (std::__shared_weak_count *)v12[1];
    v86 = v40;
    if (v40)
    {
      v41 = (unint64_t *)&v40->__shared_owners_;
      do
        v42 = __ldxr(v41);
      while (__stxr(v42 + 1, v41));
    }
    sub_20BDE5F68(v33, &v89, &v87, &v85);
    sub_20BDEED1C((uint64_t *)&v100, v34);
    v43 = v100;
    v100 = 0uLL;
    v44 = (std::__shared_weak_count *)v95[1];
    *(_OWORD *)v95 = v43;
    if (v44)
    {
      v45 = (unint64_t *)&v44->__shared_owners_;
      do
        v46 = __ldaxr(v45);
      while (__stlxr(v46 - 1, v45));
      if (!v46)
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
    }
    v47 = (std::__shared_weak_count *)*((_QWORD *)&v100 + 1);
    if (*((_QWORD *)&v100 + 1))
    {
      v48 = (unint64_t *)(*((_QWORD *)&v100 + 1) + 8);
      do
        v49 = __ldaxr(v48);
      while (__stlxr(v49 - 1, v48));
      if (!v49)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
    v50 = v86;
    if (v86)
    {
      v51 = (unint64_t *)&v86->__shared_owners_;
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 - 1, v51));
      if (!v52)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
    v53 = v88;
    if (v88)
    {
      v54 = (unint64_t *)&v88->__shared_owners_;
      do
        v55 = __ldaxr(v54);
      while (__stlxr(v55 - 1, v54));
      if (!v55)
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }
    }
    v56 = v90;
    if (v90)
    {
      v57 = (unint64_t *)&v90->__shared_owners_;
      do
        v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
        std::__shared_weak_count::__release_weak(v56);
      }
    }
    v60 = v95[0];
    v59 = (std::__shared_weak_count *)v95[1];
    if (v95[1])
    {
      v61 = (unint64_t *)((char *)v95[1] + 16);
      do
        v62 = __ldxr(v61);
      while (__stxr(v62 + 1, v61));
    }
    *v18 = v60;
    v63 = *v16;
    *v16 = v59;
    if (v63)
      std::__shared_weak_count::__release_weak(v63);
    v64 = v92;
    if (v92)
    {
      v65 = (unint64_t *)&v92->__shared_owners_;
      do
        v66 = __ldaxr(v65);
      while (__stlxr(v66 - 1, v65));
      if (!v66)
      {
        ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
        std::__shared_weak_count::__release_weak(v64);
      }
    }
    v67 = v94;
    if (v94)
    {
      v68 = (unint64_t *)&v94->__shared_owners_;
      do
        v69 = __ldaxr(v68);
      while (__stlxr(v69 - 1, v68));
      if (!v69)
      {
        ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
        std::__shared_weak_count::__release_weak(v67);
      }
    }
    v19 = v95[0];
    if (!v95[0])
      goto LABEL_85;
  }
  if (v70)
  {
    v71 = (std::__shared_weak_count *)v95[1];
    *a4 = v70;
    a4[1] = v71;
    if (v71)
    {
      v72 = (unint64_t *)&v71->__shared_owners_;
      do
        v73 = __ldxr(v72);
      while (__stxr(v73 + 1, v72));
      goto LABEL_86;
    }
  }
  else
  {
LABEL_85:
    *a4 = 0;
    a4[1] = 0;
    v71 = (std::__shared_weak_count *)v95[1];
    if (v95[1])
    {
LABEL_86:
      v74 = (unint64_t *)&v71->__shared_owners_;
      do
        v75 = __ldaxr(v74);
      while (__stlxr(v75 - 1, v74));
      if (!v75)
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
      }
    }
  }
  return pthread_mutex_unlock(v14);
}

void sub_20BDEE220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::exception a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  sub_20BDDC194(&a25);
  sub_20BDDBE98((uint64_t)&a29);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDEE304@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  pthread_mutex_t *v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count **v16;
  std::__shared_weak_count *v17;
  void **v18;
  void *v19;
  void *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  __int128 v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  std::__shared_weak_count *v58;
  void *v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  void *v72;
  std::__shared_weak_count *v73;
  unint64_t *v74;
  unint64_t v75;
  unint64_t *v76;
  unint64_t v77;
  _QWORD *v78;
  int v79;
  const void *v80;
  uint64_t v81;
  _QWORD *v82;
  _QWORD *exception;
  _QWORD *v84;
  _QWORD *v85;
  _QWORD *v86;
  uint64_t v87;
  std::__shared_weak_count *v88;
  uint64_t v89;
  std::__shared_weak_count *v90;
  uint64_t v91;
  std::__shared_weak_count *v92;
  uint64_t v93;
  std::__shared_weak_count *v94;
  uint64_t v95;
  std::__shared_weak_count *v96;
  uint64_t v97;
  std::__shared_weak_count *v98;
  void *v99[2];
  void *__p[2];
  char v101;
  uint64_t v102;
  std::__shared_weak_count *v103;
  void *lpsrc[2];
  _QWORD v105[34];

  result = sub_20BDEEBA4(a1 + 40, (const void **)a3);
  if (a1 + 48 == result)
  {
    *a4 = 0;
    a4[1] = 0;
    return result;
  }
  v9 = result;
  v10 = *(_QWORD *)(a1 + 32);
  v11 = *(_QWORD *)(result + 56);
  v12 = (_QWORD *)(v10 + 96 * v11);
  if (*(_DWORD *)(*v12 + 24))
  {
    sub_20BDDBD68((uint64_t)lpsrc);
    v78 = sub_20BDDC1C8(v105, (uint64_t)"Tried to read a compound property from a non-compound: ", 55);
    v79 = *(char *)(a3 + 23);
    if (v79 >= 0)
      v80 = (const void *)a3;
    else
      v80 = *(const void **)a3;
    if (v79 >= 0)
      v81 = *(unsigned __int8 *)(a3 + 23);
    else
      v81 = *(_QWORD *)(a3 + 8);
    v82 = sub_20BDDC1C8(v78, (uint64_t)v80, v81);
    sub_20BDDC1C8(v82, (uint64_t)", type: ", 8);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(&v102, (__int128 *)__p);
    if (v101 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v84 = sub_20BDDC09C(exception, (uint64_t)&v102);
    __cxa_throw(v84, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v13 = v10 + 96 * v11;
  v14 = (pthread_mutex_t *)(v13 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v13 + 32));
  v17 = *(std::__shared_weak_count **)(v13 + 24);
  v16 = (std::__shared_weak_count **)(v13 + 24);
  v15 = v17;
  v18 = (void **)(v16 - 1);
  v99[0] = 0;
  v99[1] = 0;
  if (!v17 || (v99[1] = std::__shared_weak_count::lock(v15)) == 0 || (v19 = *v18, (v99[0] = v19) == 0))
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)*a2 + 24))(&v102);
    (*(void (**)(void **__return_ptr))(*(_QWORD *)v102 + 24))(lpsrc);
    if (lpsrc[0]
    {
      v97 = (uint64_t)v20;
      v98 = (std::__shared_weak_count *)lpsrc[1];
      if (lpsrc[1])
      {
        v21 = (unint64_t *)((char *)lpsrc[1] + 8);
        do
          v22 = __ldxr(v21);
        while (__stxr(v22 + 1, v21));
      }
    }
    else
    {
      v97 = 0;
      v98 = 0;
    }
    v23 = (std::__shared_weak_count *)lpsrc[1];
    if (lpsrc[1])
    {
      v24 = (unint64_t *)((char *)lpsrc[1] + 8);
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    v26 = v103;
    if (v103)
    {
      p_shared_owners = (unint64_t *)&v103->__shared_owners_;
      do
        v28 = __ldaxr(p_shared_owners);
      while (__stlxr(v28 - 1, p_shared_owners));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v29 = v97;
    sub_20BDE9C40(v97, &v95);
    Alembic::Ogawa::v12::IGroup::getGroup(*(uint64_t ***)(a1 + 16), *(_QWORD *)(v9 + 56), 0, *(_QWORD *)(v95 + 8), &v93);
    v30 = v93;
    if (!v93)
    {
      sub_20BDDBD68((uint64_t)lpsrc);
      sub_20BDDC1C8(v105, (uint64_t)"Compound Property not backed by a valid group.", 46);
      std::stringbuf::str();
      sub_20BDDBF20(&v102, (__int128 *)__p);
      if (v101 < 0)
        operator delete(__p[0]);
      v85 = __cxa_allocate_exception(0x20uLL);
      v86 = sub_20BDDC09C(v85, (uint64_t)&v102);
      __cxa_throw(v86, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
    v31 = operator new(0x58uLL);
    v32 = (std::__shared_weak_count *)a2[1];
    v91 = *a2;
    v92 = v32;
    if (v32)
    {
      v33 = (unint64_t *)&v32->__shared_owners_;
      do
        v34 = __ldxr(v33);
      while (__stxr(v34 + 1, v33));
    }
    v89 = v30;
    v90 = v94;
    if (v94)
    {
      v35 = (unint64_t *)&v94->__shared_owners_;
      do
        v36 = __ldxr(v35);
      while (__stxr(v36 + 1, v35));
    }
    v87 = *v12;
    v37 = (std::__shared_weak_count *)v12[1];
    v88 = v37;
    if (v37)
    {
      v38 = (unint64_t *)&v37->__shared_owners_;
      do
        v39 = __ldxr(v38);
      while (__stxr(v39 + 1, v38));
    }
    v40 = *(_QWORD *)(v95 + 8);
    v41 = (_QWORD *)sub_20BDE9D1C(v29);
    sub_20BDEF450(v31, &v91, &v89, &v87, v40, v41);
    sub_20BDEEE08((uint64_t *)lpsrc, (uint64_t)v31);
    v42 = *(_OWORD *)lpsrc;
    lpsrc[0] = 0;
    lpsrc[1] = 0;
    v43 = (std::__shared_weak_count *)v99[1];
    *(_OWORD *)v99 = v42;
    if (v43)
    {
      v44 = (unint64_t *)&v43->__shared_owners_;
      do
        v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }
    v46 = (std::__shared_weak_count *)lpsrc[1];
    if (lpsrc[1])
    {
      v47 = (unint64_t *)((char *)lpsrc[1] + 8);
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
    v49 = v88;
    if (v88)
    {
      v50 = (unint64_t *)&v88->__shared_owners_;
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }
    v52 = v90;
    if (v90)
    {
      v53 = (unint64_t *)&v90->__shared_owners_;
      do
        v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
    }
    v55 = v92;
    if (v92)
    {
      v56 = (unint64_t *)&v92->__shared_owners_;
      do
        v57 = __ldaxr(v56);
      while (__stlxr(v57 - 1, v56));
      if (!v57)
      {
        ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
        std::__shared_weak_count::__release_weak(v55);
      }
    }
    v59 = v99[0];
    v58 = (std::__shared_weak_count *)v99[1];
    if (v99[1])
    {
      v60 = (unint64_t *)((char *)v99[1] + 16);
      do
        v61 = __ldxr(v60);
      while (__stxr(v61 + 1, v60));
    }
    *v18 = v59;
    v62 = *v16;
    *v16 = v58;
    if (v62)
      std::__shared_weak_count::__release_weak(v62);
    v63 = v94;
    if (v94)
    {
      v64 = (unint64_t *)&v94->__shared_owners_;
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
        std::__shared_weak_count::__release_weak(v63);
      }
    }
    v66 = v96;
    if (v96)
    {
      v67 = (unint64_t *)&v96->__shared_owners_;
      do
        v68 = __ldaxr(v67);
      while (__stlxr(v68 - 1, v67));
      if (!v68)
      {
        ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
        std::__shared_weak_count::__release_weak(v66);
      }
    }
    v69 = v98;
    if (v98)
    {
      v70 = (unint64_t *)&v98->__shared_owners_;
      do
        v71 = __ldaxr(v70);
      while (__stlxr(v71 - 1, v70));
      if (!v71)
      {
        ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
        std::__shared_weak_count::__release_weak(v69);
      }
    }
    v19 = v99[0];
    if (!v99[0])
      goto LABEL_85;
  }
  if (v72)
  {
    v73 = (std::__shared_weak_count *)v99[1];
    *a4 = v72;
    a4[1] = v73;
    if (v73)
    {
      v74 = (unint64_t *)&v73->__shared_owners_;
      do
        v75 = __ldxr(v74);
      while (__stxr(v75 + 1, v74));
      goto LABEL_86;
    }
  }
  else
  {
LABEL_85:
    *a4 = 0;
    a4[1] = 0;
    v73 = (std::__shared_weak_count *)v99[1];
    if (v99[1])
    {
LABEL_86:
      v76 = (unint64_t *)&v73->__shared_owners_;
      do
        v77 = __ldaxr(v76);
      while (__stlxr(v77 - 1, v76));
      if (!v77)
      {
        ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
        std::__shared_weak_count::__release_weak(v73);
      }
    }
  }
  return pthread_mutex_unlock(v14);
}

void sub_20BDEE944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::exception a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  sub_20BDDC194(&a27);
  sub_20BDDBE98((uint64_t)&a31);
  _Unwind_Resume(a1);
}

uint64_t *sub_20BDEEA20(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;

  v6 = (uint64_t **)sub_20BDDE084((uint64_t)a1, &v9, a2);
  result = *v6;
  if (!*v6)
  {
    sub_20BDEEAB4((uint64_t)a1, a4, (uint64_t)&v8);
    sub_20BDDE1B4(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

_BYTE *sub_20BDEEAB4@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  _BYTE *result;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = v6 + 32;
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    result = sub_20BDDBFAC(result, *(void **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    *((_QWORD *)v6 + 6) = *((_QWORD *)v8 + 2);
    *(_OWORD *)result = v9;
  }
  *((_QWORD *)v6 + 7) = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_20BDEEB3C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  sub_20BDEEB58(v3, v2);
  _Unwind_Resume(a1);
}

void sub_20BDEEB58(uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0)
      operator delete(__p[4]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t sub_20BDEEBA4(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t *v8;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = a1 + 8;
  do
  {
    v7 = sub_20BDDDF74(v5, (const void **)(v3 + 32), a2);
    v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      v8 = (uint64_t *)v3;
      v6 = v3;
    }
    v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || sub_20BDDDF74(v5, a2, (const void **)(v6 + 32)))
    return v2;
  return v6;
}

uint64_t *sub_20BDEEC30(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518430;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BDEEC8C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDEECB0(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BDEECC4(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BDEECDC(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518480))
    return a1 + 24;
  else
    return 0;
}

uint64_t *sub_20BDEED1C(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C5184A8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BDEED78(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDEED9C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BDEEDB0(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BDEEDC8(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C5184F8))
    return a1 + 24;
  else
    return 0;
}

uint64_t *sub_20BDEEE08(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518520;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BDEEE64(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDEEE88(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BDEEE9C(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BDEEEB4(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518570))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDEEEF4(_QWORD *a1, _QWORD *a2, uint64_t *a3, _QWORD *a4, unint64_t a5, _QWORD *a6)
{
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD *exception;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  void *__p[2];
  char v46;
  _QWORD v47[4];
  uint64_t v48;
  std::__shared_weak_count *v49;
  _QWORD v50[33];

  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_24C518598;
  a1[3] = *a2;
  v10 = a2[1];
  a1[4] = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  a1[5] = *a4;
  v13 = a1 + 5;
  v14 = a4[1];
  a1[6] = v14;
  if (v14)
  {
    v15 = (unint64_t *)(v14 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  *(_OWORD *)(a1 + 7) = 0u;
  v17 = a1 + 7;
  *(_OWORD *)(a1 + 9) = 0u;
  v18 = a1[3];
  if (!v18)
  {
    sub_20BDDBD68((uint64_t)&v48);
    sub_20BDDC1C8(v50, (uint64_t)"Invalid parent in CprImpl(Compound)", 35);
    std::stringbuf::str();
    sub_20BDDBF20(v47, (__int128 *)__p);
    if (v46 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v34 = sub_20BDDC09C(exception, (uint64_t)v47);
    __cxa_throw(v34, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*v13)
  {
    sub_20BDDBD68((uint64_t)&v48);
    sub_20BDDC1C8(v50, (uint64_t)"invalid header in CprImpl(Compound)", 35);
    std::stringbuf::str();
    sub_20BDDBF20(v47, (__int128 *)__p);
    if (v46 < 0)
      operator delete(__p[0]);
    v35 = __cxa_allocate_exception(0x20uLL);
    v36 = sub_20BDDC09C(v35, (uint64_t)v47);
    __cxa_throw(v36, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (*(_DWORD *)(*v13 + 24))
  {
    sub_20BDDBD68((uint64_t)&v48);
    sub_20BDDC1C8(v50, (uint64_t)"Tried to create compound property with the wrong property type: ", 64);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v47, (__int128 *)__p);
    if (v46 < 0)
      operator delete(__p[0]);
    v37 = __cxa_allocate_exception(0x20uLL);
    v38 = sub_20BDDC09C(v37, (uint64_t)v47);
    __cxa_throw(v38, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v18 + 24))(&v43);
  if (!v43)
  {
    sub_20BDDBD68((uint64_t)&v48);
    sub_20BDDC1C8(v50, (uint64_t)"Invalid object in CprImpl::CprImpl(Compound)", 44);
    std::stringbuf::str();
    sub_20BDDBF20(v47, (__int128 *)__p);
    if (v46 < 0)
      operator delete(__p[0]);
    v39 = __cxa_allocate_exception(0x20uLL);
    v40 = sub_20BDDC09C(v39, (uint64_t)v47);
    __cxa_throw(v40, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDE881C(a1 + 7, &v43);
  v19 = operator new(0x40uLL);
  v20 = a3[1];
  v41 = *a3;
  v42 = (std::__shared_weak_count *)v20;
  if (v20)
  {
    v21 = (unint64_t *)(v20 + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)*v17 + 24))(&v48);
  sub_20BDED290((uint64_t)v19, &v41, a5, v48, a6);
  sub_20BDEF3E0(a1 + 9, v19);
  v23 = v49;
  if (v49)
  {
    p_shared_owners = (unint64_t *)&v49->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  v26 = v42;
  if (v42)
  {
    v27 = (unint64_t *)&v42->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = v44;
  if (v44)
  {
    v30 = (unint64_t *)&v44->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  return a1;
}

void sub_20BDEF2EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *v8;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v9;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v10;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v11;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v12;
  std::__shared_weak_count *v14;
  std::exception v15;
  va_list va;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v15.__vftable = va_arg(va1, std::exception_vtbl *);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v12);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v11);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v10);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v9);
  v14 = (std::__shared_weak_count *)*((_QWORD *)v8 + 2);
  if (v14)
    std::__shared_weak_count::__release_weak(v14);
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader(v8);
  _Unwind_Resume(a1);
}

void sub_20BDEF3E0(_QWORD *a1, _QWORD *a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  sub_20BDEFCE0(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

uint64_t sub_20BDEF454(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  _QWORD *exception;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20[2];
  char v21;
  _QWORD v22[4];
  __int128 __p;
  _QWORD v24[33];

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_24C518598;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  v4 = (_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = *a2;
  v5 = (uint64_t *)(a1 + 56);
  v6 = a2[1];
  *(_QWORD *)(a1 + 64) = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  *(_QWORD *)(a1 + 72) = *a3;
  v9 = a3[1];
  *(_QWORD *)(a1 + 80) = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v12 = *v5;
  if (!*v5)
  {
    sub_20BDDBD68((uint64_t)&__p);
    sub_20BDDC1C8(v24, (uint64_t)"Invalid object in CprImpl(Object)", 33);
    std::stringbuf::str();
    sub_20BDDBF20(v22, (__int128 *)v20);
    if (v21 < 0)
      operator delete(v20[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v17 = sub_20BDDC09C(exception, (uint64_t)v22);
    __cxa_throw(v17, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*(_QWORD *)(a1 + 72))
  {
    sub_20BDDBD68((uint64_t)&__p);
    sub_20BDDC1C8(v24, (uint64_t)"Invalid data in CprImpl(Object)", 31);
    std::stringbuf::str();
    sub_20BDDBF20(v22, (__int128 *)v20);
    if (v21 < 0)
      operator delete(v20[0]);
    v18 = __cxa_allocate_exception(0x20uLL);
    v19 = sub_20BDDC09C(v18, (uint64_t)v22);
    __cxa_throw(v19, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  __p = 0uLL;
  v24[0] = 0;
  v13 = (char *)operator new(0x68uLL);
  v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
  sub_20BDEFC54(v13, &__p, (const void ***)(v14 + 48));
  *((_WORD *)v13 + 40) = 257;
  *(_QWORD *)(v13 + 92) = 0;
  *(_QWORD *)(v13 + 84) = 0;
  sub_20BDEF708(v4, (uint64_t)v13);
  if (SHIBYTE(v24[0]) < 0)
    operator delete((void *)__p);
  return a1;
}

void sub_20BDEF668(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *v21;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v22;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v23;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v24;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v25;
  std::__shared_weak_count *v27;

  sub_20BDDC194(&a12);
  sub_20BDDBE98((uint64_t)&__p);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v25);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v24);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v23);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v22);
  v27 = (std::__shared_weak_count *)*((_QWORD *)v21 + 2);
  if (v27)
    std::__shared_weak_count::__release_weak(v27);
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader(v21);
  _Unwind_Resume(a1);
}

void sub_20BDEF708(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  sub_20BDEFDCC(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_20BDEF77C(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = off_24C518598;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 9));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 7));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 5));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 3));
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader((Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *)a1);
}

void sub_20BDEF7D4(_QWORD *a1)
{
  void *v1;

  sub_20BDEF77C(a1);
  operator delete(v1);
}

uint64_t sub_20BDEF7E8(uint64_t a1)
{
  uint64_t result;
  _QWORD *exception;
  _QWORD *v3;
  __int128 __p;
  char v5;
  _QWORD v6[4];
  _BYTE v7[16];
  _QWORD v8[33];

  result = *(_QWORD *)(a1 + 40);
  if (!result)
  {
    sub_20BDDBD68((uint64_t)v7);
    sub_20BDDC1C8(v8, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v6, &__p);
    if (v5 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v3 = sub_20BDDC09C(exception, (uint64_t)v6);
    __cxa_throw(v3, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return result;
}

void sub_20BDEF880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDEF8A8@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 64);
  *a2 = *(_QWORD *)(result + 56);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t sub_20BDEF8CC@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 32);
  *a2 = *(_QWORD *)(result + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

double sub_20BDEF8F0@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_20BDEF928(uint64_t a1)
{
  return sub_20BDED32C(*(_QWORD *)(a1 + 72));
}

uint64_t sub_20BDEF930(_QWORD *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v3 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v9);
  v4 = sub_20BDED334(v3, (uint64_t)&v9, a2);
  v5 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return v4;
}

void sub_20BDEF9B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDEF9CC(_QWORD *a1, const void **a2)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v3 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v9);
  v4 = sub_20BDED428(v3, (uint64_t)&v9, a2);
  v5 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return v4;
}

void sub_20BDEFA54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDEFA68(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v5 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v9);
  sub_20BDED4EC(v5, &v9, a2, a3);
  v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_20BDEFAF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDEFB0C(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v5 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v9);
  sub_20BDEDBF8(v5, &v9, a2, a3);
  v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_20BDEFB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDEFBB0(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v5 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v9);
  sub_20BDEE304(v5, &v9, a2, a3);
  v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_20BDEFC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDEFC54(_QWORD *__dst, __int128 *a2, const void ***a3)
{
  __int128 v5;

  if (*((char *)a2 + 23) < 0)
  {
    sub_20BDDBFAC(__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    __dst[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)__dst = v5;
  }
  *((_DWORD *)__dst + 6) = 0;
  sub_20BDEBF8C(__dst + 4, a3);
  *((_DWORD *)__dst + 14) = 127;
  *((_BYTE *)__dst + 60) = 0;
  __dst[8] = 0;
  __dst[9] = 0;
  return __dst;
}

void sub_20BDEFCC4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDEFCE0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518660;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  sub_20BDEA008((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_20BDEFD34(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  if (v1)
  {
    v3 = (void *)sub_20BDED328(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_20BDEFD54(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDEFD68(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v2 = (void *)sub_20BDED328(v1);
    operator delete(v2);
  }
}

uint64_t sub_20BDEFD8C(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C5186B0))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDEFDCC(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C5186D8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDEFE18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  a10 = 0;
  if (v10)
    sub_20BDEFE98((uint64_t)&a10, v10);
  _Unwind_Resume(exception_object);
}

void sub_20BDEFE3C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDEFE50(uint64_t a1)
{
  sub_20BDEFE98(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t sub_20BDEFE58(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518728))
    return a1 + 24;
  else
    return 0;
}

void sub_20BDEFE98(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a2 + 64));
    sub_20BDE9D48(a2 + 32, *(_QWORD **)(a2 + 40));
    if (*(char *)(a2 + 23) < 0)
      operator delete(*(void **)a2);
    operator delete((void *)a2);
  }
}

_QWORD *sub_20BDEFEE4(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  *result = 0;
  result[1] = 0;
  v2 = a2[1];
  result[2] = *a2;
  result[3] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  result[4] = 0;
  result[5] = 0;
  result[8] = 0;
  result[9] = 0;
  result[10] = 0;
  result[6] = 0;
  result[7] = result + 8;
  result[11] = 0;
  result[12] = 0;
  return result;
}

uint64_t sub_20BDEFF24(uint64_t a1)
{
  void *v2;
  std::__shared_weak_count *v3;
  void **v5;

  v2 = *(void **)(a1 + 80);
  if (v2)
  {
    *(_QWORD *)(a1 + 88) = v2;
    operator delete(v2);
  }
  sub_20BDF1AD0(a1 + 56, *(_QWORD **)(a1 + 64));
  v5 = (void **)(a1 + 32);
  sub_20BDE9EB0(&v5);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 16));
  v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t sub_20BDEFF90(uint64_t a1)
{
  return (uint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32)) >> 4;
}

double sub_20BDEFFA0(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *exception;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v14;
  void *__p[2];
  char v16;
  _QWORD v17[4];
  _BYTE v18[16];
  _QWORD v19[33];

  v2 = *(_QWORD *)(a1 + 32);
  if (a2 > (*(_QWORD *)(a1 + 40) - v2) >> 4)
  {
    sub_20BDDBD68((uint64_t)v18);
    v8 = sub_20BDDC1C8(v19, (uint64_t)"Out of range index in ", 22);
    sub_20BDDC1C8(v8, (uint64_t)"CpwImpl::getPropertyHeader: ", 28);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v17, (__int128 *)__p);
    if (v16 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v10 = sub_20BDDC09C(exception, (uint64_t)v17);
    __cxa_throw(v10, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v3 = *(_OWORD *)(v2 + 16 * a2);
  v4 = *(std::__shared_weak_count **)(v2 + 16 * a2 + 8);
  if (!*((_QWORD *)&v3 + 1))
  {
    if ((_QWORD)v3)
      return *(double *)&v3;
LABEL_14:
    sub_20BDDBD68((uint64_t)v18);
    sub_20BDDC1C8(v19, (uint64_t)"Invalid property header ptr in CpwImpl", 38);
    std::stringbuf::str();
    sub_20BDDBF20(v17, (__int128 *)__p);
    if (v16 < 0)
      operator delete(__p[0]);
    v11 = __cxa_allocate_exception(0x20uLL);
    v12 = sub_20BDDC09C(v11, (uint64_t)v17);
    __cxa_throw(v12, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v5 = (unint64_t *)(*((_QWORD *)&v3 + 1) + 8);
  do
    v6 = __ldxr(v5);
  while (__stxr(v6 + 1, v5));
  if (!(_QWORD)v3)
    goto LABEL_14;
  do
    v7 = __ldaxr(v5);
  while (__stlxr(v7 - 1, v5));
  if (!v7)
  {
    v14 = v3;
    (*(void (**)(_QWORD))(**((_QWORD **)&v3 + 1) + 16))(*((_QWORD *)&v3 + 1));
    std::__shared_weak_count::__release_weak(v4);
    *(_QWORD *)&v3 = v14;
  }
  return *(double *)&v3;
}

void sub_20BDF014C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  std::exception v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9.__vftable = va_arg(va1, std::exception_vtbl *);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

const void **sub_20BDF01A8(uint64_t a1, unsigned __int8 **a2)
{
  const void ***v2;
  const void ***v3;
  char v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  const void **v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;

  v2 = *(const void ****)(a1 + 32);
  v3 = *(const void ****)(a1 + 40);
  if (v2 != v3)
  {
    v4 = *((_BYTE *)a2 + 23);
    if (v4 >= 0)
      v5 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
    else
      v5 = a2[1];
    if (v4 >= 0)
      v6 = (unsigned __int8 *)a2;
    else
      v6 = *a2;
    do
    {
      v7 = *v2;
      v8 = *((unsigned __int8 *)*v2 + 23);
      if ((v8 & 0x80u) == 0)
        v9 = (unsigned __int8 *)*((unsigned __int8 *)*v2 + 23);
      else
        v9 = (unsigned __int8 *)(*v2)[1];
      if (v9 == v5)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*v7, v6, (size_t)(*v2)[1]))
            return v7;
        }
        else
        {
          if (!*((_BYTE *)*v2 + 23))
            return v7;
          v10 = 0;
          while (*((unsigned __int8 *)v7 + v10) == v6[v10])
          {
            if (v8 == ++v10)
              return v7;
          }
        }
      }
      v2 += 2;
    }
    while (v2 != v3);
  }
  return 0;
}

void sub_20BDF0264(uint64_t a1@<X0>, const void **a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;

  v5 = sub_20BDEEBA4(a1 + 56, a2);
  if (a1 + 64 == v5 || (v6 = *(std::__shared_weak_count **)(v5 + 64)) == 0)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    v7 = *(_QWORD *)(v5 + 56);
    p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
    do
      v9 = __ldxr(p_shared_weak_owners);
    while (__stxr(v9 + 1, p_shared_weak_owners));
    *a3 = 0;
    v10 = std::__shared_weak_count::lock(v6);
    a3[1] = v10;
    if (v10)
      *a3 = v7;
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_20BDF02F0(uint64_t a1@<X0>, _QWORD *a2@<X1>, const void **a3@<X2>, const void ***a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  uint64_t **v14;
  BOOL v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  _WORD *v22;
  void *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  void *v38;
  void *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t *v42;
  std::__shared_weak_count *v43;
  char *v44;
  void **v45;
  char *v46;
  char *v47;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  _QWORD *v56;
  char *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  _QWORD *v72;
  _QWORD *v73;
  _QWORD *v74;
  _QWORD *v75;
  _QWORD *v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *exception;
  _QWORD *v81;
  __int128 v82;
  uint64_t v83;
  std::__shared_weak_count *v84;
  uint64_t v85;
  std::__shared_weak_count *v86;
  void *__p[2];
  char v88;
  __int128 v89[2];
  uint64_t v90;
  std::__shared_weak_count *v91;
  _QWORD v92[33];
  const void **v93;

  v14 = (uint64_t **)(a1 + 56);
  if (sub_20BDDDEF8(a1 + 56, a3))
  {
    sub_20BDDBD68((uint64_t)&v90);
    v76 = sub_20BDDC1C8(v92, (uint64_t)"Already have a property named: ", 31);
    v77 = *((char *)a3 + 23);
    if (v77 >= 0)
      v78 = (uint64_t)a3;
    else
      v78 = (uint64_t)*a3;
    if (v77 >= 0)
      v79 = *((unsigned __int8 *)a3 + 23);
    else
      v79 = (uint64_t)a3[1];
    sub_20BDDC1C8(v76, v78, v79);
    std::stringbuf::str();
    sub_20BDDBF20(v89, (__int128 *)__p);
    if (v88 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v81 = sub_20BDDC09C(exception, (uint64_t)v89);
    __cxa_throw(v81, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*(_BYTE *)(a5 + 4) || (*(_DWORD *)a5 != 127 ? (v15 = *(_DWORD *)a5 == 14) : (v15 = 1), v15))
  {
    sub_20BDDBD68((uint64_t)&v90);
    sub_20BDDC1C8(v92, (uint64_t)"createScalarProperty, illegal DataType provided.", 48);
    std::stringbuf::str();
    sub_20BDDBF20(v89, (__int128 *)__p);
    if (v88 < 0)
      operator delete(__p[0]);
    v72 = __cxa_allocate_exception(0x20uLL);
    v73 = sub_20BDDC09C(v72, (uint64_t)v89);
    __cxa_throw(v73, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (*((char *)a3 + 23) < 0)
  {
    if (!a3[1])
      goto LABEL_94;
  }
  else if (!*((_BYTE *)a3 + 23))
  {
LABEL_94:
    sub_20BDDBD68((uint64_t)&v90);
    sub_20BDDC1C8(v92, (uint64_t)"Invalid name", 12);
    std::stringbuf::str();
    sub_20BDDBF20(v89, (__int128 *)__p);
    if (v88 < 0)
      operator delete(__p[0]);
    v74 = __cxa_allocate_exception(0x20uLL);
    v75 = sub_20BDDC09C(v74, (uint64_t)v89);
    __cxa_throw(v75, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (std::string::find((const std::string *)a3, 47, 0) != -1)
    goto LABEL_94;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)*a2 + 24))(__p);
  (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)__p[0] + 24))(v89);
  (*(void (**)(uint64_t *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)&v89[0] + 56))(&v90, *(_QWORD *)&v89[0], a6);
  v16 = (std::__shared_weak_count *)*((_QWORD *)&v89[0] + 1);
  if (*((_QWORD *)&v89[0] + 1))
  {
    v17 = (unint64_t *)(*((_QWORD *)&v89[0] + 1) + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v20 = (unint64_t *)((char *)__p[1] + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = operator new(0x68uLL);
  sub_20BDF1A10(v22, (__int128 *)a3, 1, a4, (_QWORD *)a5, &v90);
  v22[40] = 257;
  *((_QWORD *)v22 + 11) = 0;
  *((_DWORD *)v22 + 21) = 0;
  *((_DWORD *)v22 + 24) = a6;
  sub_20BDEFDCC(v89, (uint64_t)v22);
  v23 = operator new(0x70uLL);
  v24 = (std::__shared_weak_count *)a2[1];
  v85 = *a2;
  v86 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v26 = __ldxr(p_shared_owners);
    while (__stxr(v26 + 1, p_shared_owners));
  }
  Alembic::Ogawa::v12::OGroup::addGroup(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), &v83);
  v82 = v89[0];
  if (*((_QWORD *)&v89[0] + 1))
  {
    v27 = (unint64_t *)(*((_QWORD *)&v89[0] + 1) + 8);
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  sub_20BDFE1F8(v23, &v85, &v83, &v82, (uint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32)) >> 4);
  sub_20BDF1B58((uint64_t *)__p, (uint64_t)v23);
  v29 = (std::__shared_weak_count *)*((_QWORD *)&v82 + 1);
  if (*((_QWORD *)&v82 + 1))
  {
    v30 = (unint64_t *)(*((_QWORD *)&v82 + 1) + 8);
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v84;
  if (v84)
  {
    v33 = (unint64_t *)&v84->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v86;
  if (v86)
  {
    v36 = (unint64_t *)&v86->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  sub_20BDEA72C((char **)(a1 + 32), v89);
  v39 = __p[0];
  v38 = __p[1];
  if (__p[1])
  {
    v40 = (unint64_t *)((char *)__p[1] + 16);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }
  v93 = a3;
  v42 = sub_20BDF1C44(v14, a3, (uint64_t)&unk_20CA50CFD, (__int128 **)&v93);
  v43 = (std::__shared_weak_count *)v42[8];
  v42[7] = (uint64_t)v39;
  v42[8] = (uint64_t)v38;
  if (v43)
    std::__shared_weak_count::__release_weak(v43);
  v44 = *(char **)(a1 + 96);
  v45 = (void **)(a1 + 80);
  v46 = *(char **)(a1 + 88);
  if (v46 >= v44)
  {
    v48 = (char *)*v45;
    v49 = (v46 - (_BYTE *)*v45) >> 3;
    v50 = v49 + 1;
    if ((unint64_t)(v49 + 1) >> 61)
      sub_20BDDF694();
    v51 = v44 - v48;
    if (v51 >> 2 > v50)
      v50 = v51 >> 2;
    if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8)
      v52 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v52 = v50;
    if (v52)
    {
      v53 = (char *)sub_20BDDF6A8(a1 + 96, v52);
      v48 = *(char **)(a1 + 80);
      v46 = *(char **)(a1 + 88);
    }
    else
    {
      v53 = 0;
    }
    v54 = &v53[8 * v49];
    v44 = &v53[8 * v52];
    *(_QWORD *)v54 = 0;
    v47 = v54 + 8;
    while (v46 != v48)
    {
      v55 = *((_QWORD *)v46 - 1);
      v46 -= 8;
      *((_QWORD *)v54 - 1) = v55;
      v54 -= 8;
    }
    *(_QWORD *)(a1 + 80) = v54;
    *(_QWORD *)(a1 + 88) = v47;
    *(_QWORD *)(a1 + 96) = v44;
    if (v48)
    {
      operator delete(v48);
      v44 = *(char **)(a1 + 96);
    }
  }
  else
  {
    *(_QWORD *)v46 = 0;
    v47 = v46 + 8;
  }
  *(_QWORD *)(a1 + 88) = v47;
  if (v47 >= v44)
  {
    v57 = (char *)*v45;
    v58 = (v47 - (_BYTE *)*v45) >> 3;
    v59 = v58 + 1;
    if ((unint64_t)(v58 + 1) >> 61)
      sub_20BDDF694();
    v60 = v44 - v57;
    if (v60 >> 2 > v59)
      v59 = v60 >> 2;
    if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8)
      v61 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v61 = v59;
    if (v61)
    {
      v62 = (char *)sub_20BDDF6A8(a1 + 96, v61);
      v57 = *(char **)(a1 + 80);
      v47 = *(char **)(a1 + 88);
    }
    else
    {
      v62 = 0;
    }
    v63 = &v62[8 * v58];
    v64 = &v62[8 * v61];
    *(_QWORD *)v63 = 0;
    v56 = v63 + 8;
    while (v47 != v57)
    {
      v65 = *((_QWORD *)v47 - 1);
      v47 -= 8;
      *((_QWORD *)v63 - 1) = v65;
      v63 -= 8;
    }
    *(_QWORD *)(a1 + 80) = v63;
    *(_QWORD *)(a1 + 88) = v56;
    *(_QWORD *)(a1 + 96) = v64;
    if (v57)
      operator delete(v57);
  }
  else
  {
    *(_QWORD *)v47 = 0;
    v56 = v47 + 8;
  }
  *(_QWORD *)(a1 + 88) = v56;
  *a7 = *(_OWORD *)__p;
  v66 = (std::__shared_weak_count *)*((_QWORD *)&v89[0] + 1);
  if (*((_QWORD *)&v89[0] + 1))
  {
    v67 = (unint64_t *)(*((_QWORD *)&v89[0] + 1) + 8);
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }
  v69 = v91;
  if (v91)
  {
    v70 = (unint64_t *)&v91->__shared_owners_;
    do
      v71 = __ldaxr(v70);
    while (__stlxr(v71 - 1, v70));
    if (!v71)
    {
      ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
      std::__shared_weak_count::__release_weak(v69);
    }
  }
}

void sub_20BDF0984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  std::exception v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11.__vftable = va_arg(va1, std::exception_vtbl *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BDF0A7C(uint64_t a1@<X0>, _QWORD *a2@<X1>, const void **a3@<X2>, const void ***a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  uint64_t **v14;
  BOOL v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  _WORD *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  void *v38;
  void *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t *v42;
  std::__shared_weak_count *v43;
  char *v44;
  void **v45;
  char *v46;
  char *v47;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  _QWORD *v56;
  char *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  _QWORD *v72;
  _QWORD *v73;
  _QWORD *v74;
  _QWORD *v75;
  _QWORD *v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *exception;
  _QWORD *v81;
  __int128 v82;
  uint64_t v83;
  std::__shared_weak_count *v84;
  uint64_t v85;
  std::__shared_weak_count *v86;
  void *__p[2];
  char v88;
  __int128 v89[2];
  uint64_t v90;
  std::__shared_weak_count *v91;
  _QWORD v92[33];
  const void **v93;

  v14 = (uint64_t **)(a1 + 56);
  if (sub_20BDDDEF8(a1 + 56, a3))
  {
    sub_20BDDBD68((uint64_t)&v90);
    v76 = sub_20BDDC1C8(v92, (uint64_t)"Already have a property named: ", 31);
    v77 = *((char *)a3 + 23);
    if (v77 >= 0)
      v78 = (uint64_t)a3;
    else
      v78 = (uint64_t)*a3;
    if (v77 >= 0)
      v79 = *((unsigned __int8 *)a3 + 23);
    else
      v79 = (uint64_t)a3[1];
    sub_20BDDC1C8(v76, v78, v79);
    std::stringbuf::str();
    sub_20BDDBF20(v89, (__int128 *)__p);
    if (v88 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v81 = sub_20BDDC09C(exception, (uint64_t)v89);
    __cxa_throw(v81, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*(_BYTE *)(a5 + 4) || (*(_DWORD *)a5 != 127 ? (v15 = *(_DWORD *)a5 == 14) : (v15 = 1), v15))
  {
    sub_20BDDBD68((uint64_t)&v90);
    sub_20BDDC1C8(v92, (uint64_t)"createArrayProperty, illegal DataType provided.", 47);
    std::stringbuf::str();
    sub_20BDDBF20(v89, (__int128 *)__p);
    if (v88 < 0)
      operator delete(__p[0]);
    v72 = __cxa_allocate_exception(0x20uLL);
    v73 = sub_20BDDC09C(v72, (uint64_t)v89);
    __cxa_throw(v73, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (*((char *)a3 + 23) < 0)
  {
    if (!a3[1])
      goto LABEL_94;
  }
  else if (!*((_BYTE *)a3 + 23))
  {
LABEL_94:
    sub_20BDDBD68((uint64_t)&v90);
    sub_20BDDC1C8(v92, (uint64_t)"Invalid name", 12);
    std::stringbuf::str();
    sub_20BDDBF20(v89, (__int128 *)__p);
    if (v88 < 0)
      operator delete(__p[0]);
    v74 = __cxa_allocate_exception(0x20uLL);
    v75 = sub_20BDDC09C(v74, (uint64_t)v89);
    __cxa_throw(v75, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (std::string::find((const std::string *)a3, 47, 0) != -1)
    goto LABEL_94;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)*a2 + 24))(__p);
  (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)__p[0] + 24))(v89);
  (*(void (**)(uint64_t *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)&v89[0] + 56))(&v90, *(_QWORD *)&v89[0], a6);
  v16 = (std::__shared_weak_count *)*((_QWORD *)&v89[0] + 1);
  if (*((_QWORD *)&v89[0] + 1))
  {
    v17 = (unint64_t *)(*((_QWORD *)&v89[0] + 1) + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v20 = (unint64_t *)((char *)__p[1] + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = operator new(0x68uLL);
  sub_20BDF1A10(v22, (__int128 *)a3, 2, a4, (_QWORD *)a5, &v90);
  v22[40] = 257;
  *((_QWORD *)v22 + 11) = 0;
  *((_DWORD *)v22 + 21) = 0;
  *((_DWORD *)v22 + 24) = a6;
  sub_20BDEFDCC(v89, (uint64_t)v22);
  v23 = operator new(0x88uLL);
  v24 = (std::__shared_weak_count *)a2[1];
  v85 = *a2;
  v86 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v26 = __ldxr(p_shared_owners);
    while (__stxr(v26 + 1, p_shared_owners));
  }
  Alembic::Ogawa::v12::OGroup::addGroup(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), &v83);
  v82 = v89[0];
  if (*((_QWORD *)&v89[0] + 1))
  {
    v27 = (unint64_t *)(*((_QWORD *)&v89[0] + 1) + 8);
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  sub_20BDE74D4(v23, &v85, &v83, &v82, (uint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32)) >> 4);
  sub_20BDF1DC0((uint64_t *)__p, (uint64_t)v23);
  v29 = (std::__shared_weak_count *)*((_QWORD *)&v82 + 1);
  if (*((_QWORD *)&v82 + 1))
  {
    v30 = (unint64_t *)(*((_QWORD *)&v82 + 1) + 8);
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v84;
  if (v84)
  {
    v33 = (unint64_t *)&v84->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v86;
  if (v86)
  {
    v36 = (unint64_t *)&v86->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  sub_20BDEA72C((char **)(a1 + 32), v89);
  v39 = __p[0];
  v38 = __p[1];
  if (__p[1])
  {
    v40 = (unint64_t *)((char *)__p[1] + 16);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }
  v93 = a3;
  v42 = sub_20BDF1C44(v14, a3, (uint64_t)&unk_20CA50CFD, (__int128 **)&v93);
  v43 = (std::__shared_weak_count *)v42[8];
  v42[7] = (uint64_t)v39;
  v42[8] = (uint64_t)v38;
  if (v43)
    std::__shared_weak_count::__release_weak(v43);
  v44 = *(char **)(a1 + 96);
  v45 = (void **)(a1 + 80);
  v46 = *(char **)(a1 + 88);
  if (v46 >= v44)
  {
    v48 = (char *)*v45;
    v49 = (v46 - (_BYTE *)*v45) >> 3;
    v50 = v49 + 1;
    if ((unint64_t)(v49 + 1) >> 61)
      sub_20BDDF694();
    v51 = v44 - v48;
    if (v51 >> 2 > v50)
      v50 = v51 >> 2;
    if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8)
      v52 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v52 = v50;
    if (v52)
    {
      v53 = (char *)sub_20BDDF6A8(a1 + 96, v52);
      v48 = *(char **)(a1 + 80);
      v46 = *(char **)(a1 + 88);
    }
    else
    {
      v53 = 0;
    }
    v54 = &v53[8 * v49];
    v44 = &v53[8 * v52];
    *(_QWORD *)v54 = 0;
    v47 = v54 + 8;
    while (v46 != v48)
    {
      v55 = *((_QWORD *)v46 - 1);
      v46 -= 8;
      *((_QWORD *)v54 - 1) = v55;
      v54 -= 8;
    }
    *(_QWORD *)(a1 + 80) = v54;
    *(_QWORD *)(a1 + 88) = v47;
    *(_QWORD *)(a1 + 96) = v44;
    if (v48)
    {
      operator delete(v48);
      v44 = *(char **)(a1 + 96);
    }
  }
  else
  {
    *(_QWORD *)v46 = 0;
    v47 = v46 + 8;
  }
  *(_QWORD *)(a1 + 88) = v47;
  if (v47 >= v44)
  {
    v57 = (char *)*v45;
    v58 = (v47 - (_BYTE *)*v45) >> 3;
    v59 = v58 + 1;
    if ((unint64_t)(v58 + 1) >> 61)
      sub_20BDDF694();
    v60 = v44 - v57;
    if (v60 >> 2 > v59)
      v59 = v60 >> 2;
    if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8)
      v61 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v61 = v59;
    if (v61)
    {
      v62 = (char *)sub_20BDDF6A8(a1 + 96, v61);
      v57 = *(char **)(a1 + 80);
      v47 = *(char **)(a1 + 88);
    }
    else
    {
      v62 = 0;
    }
    v63 = &v62[8 * v58];
    v64 = &v62[8 * v61];
    *(_QWORD *)v63 = 0;
    v56 = v63 + 8;
    while (v47 != v57)
    {
      v65 = *((_QWORD *)v47 - 1);
      v47 -= 8;
      *((_QWORD *)v63 - 1) = v65;
      v63 -= 8;
    }
    *(_QWORD *)(a1 + 80) = v63;
    *(_QWORD *)(a1 + 88) = v56;
    *(_QWORD *)(a1 + 96) = v64;
    if (v57)
      operator delete(v57);
  }
  else
  {
    *(_QWORD *)v47 = 0;
    v56 = v47 + 8;
  }
  *(_QWORD *)(a1 + 88) = v56;
  *a7 = *(_OWORD *)__p;
  v66 = (std::__shared_weak_count *)*((_QWORD *)&v89[0] + 1);
  if (*((_QWORD *)&v89[0] + 1))
  {
    v67 = (unint64_t *)(*((_QWORD *)&v89[0] + 1) + 8);
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }
  v69 = v91;
  if (v91)
  {
    v70 = (unint64_t *)&v91->__shared_owners_;
    do
      v71 = __ldaxr(v70);
    while (__stlxr(v71 - 1, v70));
    if (!v71)
    {
      ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
      std::__shared_weak_count::__release_weak(v69);
    }
  }
}

void sub_20BDF1110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  std::exception v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11.__vftable = va_arg(va1, std::exception_vtbl *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BDF1208(uint64_t a1@<X0>, uint64_t *a2@<X1>, const void **a3@<X2>, const void ***a4@<X3>, _OWORD *a5@<X8>)
{
  uint64_t **v10;
  char *v11;
  _QWORD *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  __int128 v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t *v30;
  std::__shared_weak_count *v31;
  char *v32;
  void **v33;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  _QWORD *v44;
  char *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  _QWORD *v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *exception;
  _QWORD *v62;
  __int128 v63;
  uint64_t v64;
  std::__shared_weak_count *v65;
  uint64_t v66;
  std::__shared_weak_count *v67;
  void *__p[2];
  char v69;
  uint64_t v70[4];
  __int128 v71;
  uint64_t v72[33];

  v10 = (uint64_t **)(a1 + 56);
  if (sub_20BDDDEF8(a1 + 56, a3))
  {
    sub_20BDDBD68((uint64_t)&v71);
    v57 = sub_20BDDC1C8(v72, (uint64_t)"Already have a property named: ", 31);
    v58 = *((char *)a3 + 23);
    if (v58 >= 0)
      v59 = (uint64_t)a3;
    else
      v59 = (uint64_t)*a3;
    if (v58 >= 0)
      v60 = *((unsigned __int8 *)a3 + 23);
    else
      v60 = (uint64_t)a3[1];
    sub_20BDDC1C8(v57, v59, v60);
    std::stringbuf::str();
    sub_20BDDBF20(v70, (__int128 *)__p);
    if (v69 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v62 = sub_20BDDC09C(exception, (uint64_t)v70);
    __cxa_throw(v62, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v11 = (char *)operator new(0x68uLL);
  sub_20BDEFC54(v11, (__int128 *)a3, a4);
  *((_WORD *)v11 + 40) = 257;
  *(_QWORD *)(v11 + 92) = 0;
  *(_QWORD *)(v11 + 84) = 0;
  sub_20BDEFDCC(&v71, (uint64_t)v11);
  v12 = operator new(0x60uLL);
  v13 = (std::__shared_weak_count *)a2[1];
  v66 = *a2;
  v67 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  Alembic::Ogawa::v12::OGroup::addGroup(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), &v64);
  v63 = v71;
  if (*((_QWORD *)&v71 + 1))
  {
    v16 = (unint64_t *)(*((_QWORD *)&v71 + 1) + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  sub_20BDF2748(v12, &v66, &v64, &v63, (uint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32)) >> 4);
  sub_20BDF1EAC(v70, (uint64_t)v12);
  v18 = (std::__shared_weak_count *)*((_QWORD *)&v63 + 1);
  if (*((_QWORD *)&v63 + 1))
  {
    v19 = (unint64_t *)(*((_QWORD *)&v63 + 1) + 8);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v65;
  if (v65)
  {
    v22 = (unint64_t *)&v65->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = v67;
  if (v67)
  {
    v25 = (unint64_t *)&v67->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  sub_20BDEA72C((char **)(a1 + 32), &v71);
  v27 = *(_OWORD *)v70;
  if (v70[1])
  {
    v28 = (unint64_t *)(v70[1] + 16);
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  __p[0] = a3;
  v30 = sub_20BDF1C44(v10, a3, (uint64_t)&unk_20CA50CFD, (__int128 **)__p);
  v31 = (std::__shared_weak_count *)v30[8];
  *(_OWORD *)(v30 + 7) = v27;
  if (v31)
    std::__shared_weak_count::__release_weak(v31);
  v32 = *(char **)(a1 + 96);
  v33 = (void **)(a1 + 80);
  v34 = *(char **)(a1 + 88);
  if (v34 >= v32)
  {
    v36 = (char *)*v33;
    v37 = (v34 - (_BYTE *)*v33) >> 3;
    v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 61)
      sub_20BDDF694();
    v39 = v32 - v36;
    if (v39 >> 2 > v38)
      v38 = v39 >> 2;
    if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8)
      v40 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v40 = v38;
    if (v40)
    {
      v41 = (char *)sub_20BDDF6A8(a1 + 96, v40);
      v36 = *(char **)(a1 + 80);
      v34 = *(char **)(a1 + 88);
    }
    else
    {
      v41 = 0;
    }
    v42 = &v41[8 * v37];
    v32 = &v41[8 * v40];
    *(_QWORD *)v42 = 0;
    v35 = v42 + 8;
    while (v34 != v36)
    {
      v43 = *((_QWORD *)v34 - 1);
      v34 -= 8;
      *((_QWORD *)v42 - 1) = v43;
      v42 -= 8;
    }
    *(_QWORD *)(a1 + 80) = v42;
    *(_QWORD *)(a1 + 88) = v35;
    *(_QWORD *)(a1 + 96) = v32;
    if (v36)
    {
      operator delete(v36);
      v32 = *(char **)(a1 + 96);
    }
  }
  else
  {
    *(_QWORD *)v34 = 0;
    v35 = v34 + 8;
  }
  *(_QWORD *)(a1 + 88) = v35;
  if (v35 >= v32)
  {
    v45 = (char *)*v33;
    v46 = (v35 - (_BYTE *)*v33) >> 3;
    v47 = v46 + 1;
    if ((unint64_t)(v46 + 1) >> 61)
      sub_20BDDF694();
    v48 = v32 - v45;
    if (v48 >> 2 > v47)
      v47 = v48 >> 2;
    if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8)
      v49 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v49 = v47;
    if (v49)
    {
      v50 = (char *)sub_20BDDF6A8(a1 + 96, v49);
      v45 = *(char **)(a1 + 80);
      v35 = *(char **)(a1 + 88);
    }
    else
    {
      v50 = 0;
    }
    v51 = &v50[8 * v46];
    v52 = &v50[8 * v49];
    *(_QWORD *)v51 = 0;
    v44 = v51 + 8;
    while (v35 != v45)
    {
      v53 = *((_QWORD *)v35 - 1);
      v35 -= 8;
      *((_QWORD *)v51 - 1) = v53;
      v51 -= 8;
    }
    *(_QWORD *)(a1 + 80) = v51;
    *(_QWORD *)(a1 + 88) = v44;
    *(_QWORD *)(a1 + 96) = v52;
    if (v45)
      operator delete(v45);
  }
  else
  {
    *(_QWORD *)v35 = 0;
    v44 = v35 + 8;
  }
  *(_QWORD *)(a1 + 88) = v44;
  *a5 = *(_OWORD *)v70;
  v54 = (std::__shared_weak_count *)*((_QWORD *)&v71 + 1);
  if (*((_QWORD *)&v71 + 1))
  {
    v55 = (unint64_t *)(*((_QWORD *)&v71 + 1) + 8);
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }
}

void sub_20BDF166C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  std::exception v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BDF171C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v5;
  __int128 v6;
  unint64_t *v7;
  unint64_t v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  void *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  Alembic::Ogawa::v12::OData *v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  __int128 v32;
  void *__p;
  void *v34;
  uint64_t v35;

  __p = 0;
  v34 = 0;
  v35 = 0;
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 40) != v2)
  {
    v5 = 0;
    do
    {
      v6 = *(_OWORD *)(v2 + 16 * v5);
      v32 = v6;
      if (*((_QWORD *)&v6 + 1))
      {
        v7 = (unint64_t *)(*((_QWORD *)&v6 + 1) + 8);
        do
          v8 = __ldxr(v7);
        while (__stxr(v8 + 1, v7));
      }
      v9 = *(unsigned __int8 *)(v6 + 80);
      v10 = *(unsigned __int8 *)(v6 + 81);
      v11 = *(_DWORD *)(v6 + 84);
      v12 = *(_DWORD *)(v6 + 88);
      v14 = *(_DWORD *)(v6 + 92);
      v13 = *(_DWORD *)(v6 + 96);
      v15 = a2[1];
      v30 = *a2;
      v31 = (std::__shared_weak_count *)v15;
      if (v15)
      {
        v16 = (unint64_t *)(v15 + 8);
        do
          v17 = __ldxr(v16);
        while (__stxr(v17 + 1, v16));
      }
      sub_20BE010E0((uint64_t)&__p, v6, v9 != 0, v10 != 0, v13, v11, v12, v14, &v30);
      v18 = v31;
      if (v31)
      {
        p_shared_owners = (unint64_t *)&v31->__shared_owners_;
        do
          v20 = __ldaxr(p_shared_owners);
        while (__stlxr(v20 - 1, p_shared_owners));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      v21 = (std::__shared_weak_count *)*((_QWORD *)&v32 + 1);
      if (*((_QWORD *)&v32 + 1))
      {
        v22 = (unint64_t *)(*((_QWORD *)&v32 + 1) + 8);
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      ++v5;
      v2 = *(_QWORD *)(a1 + 32);
    }
    while (v5 < (*(_QWORD *)(a1 + 40) - v2) >> 4);
    v24 = v34;
    if (__p != v34)
    {
      Alembic::Ogawa::v12::OGroup::addData(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), __p, (_BYTE *)v34 - (_BYTE *)__p, &v28);
      v25 = v29;
      if (v29)
      {
        v26 = (unint64_t *)&v29->__shared_owners_;
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      v24 = __p;
    }
    if (v24)
    {
      v34 = v24;
      operator delete(v24);
    }
  }
}

void sub_20BDF18D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_20BDF1904(_QWORD *result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *exception;
  _QWORD *v6;
  __int128 __p;
  char v8;
  _QWORD v9[4];
  _BYTE v10[16];
  _QWORD v11[33];

  if (a2 >= (uint64_t)(result[5] - result[4]) >> 4 || (v4 = result[10], 2 * a2 >= (result[11] - v4) >> 3))
  {
    sub_20BDDBD68((uint64_t)v10);
    sub_20BDDC1C8(v11, (uint64_t)"Invalid property requested in CpwData::fillHash", 47);
    std::stringbuf::str();
    sub_20BDDBF20(v9, &__p);
    if (v8 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v6 = sub_20BDDC09C(exception, (uint64_t)v9);
    __cxa_throw(v6, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  *(_QWORD *)(v4 + 16 * a2) = a3;
  *(_QWORD *)(v4 + ((16 * a2) | 8)) = a4;
  return result;
}

void sub_20BDF19C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDF19F0(_QWORD *result, Alembic::Util::v12::SpookyHash *this)
{
  char *v2;
  char *v3;

  v2 = (char *)result[10];
  v3 = (char *)result[11];
  if (v2 != v3)
    return Alembic::Util::v12::SpookyHash::Update(this, v2, v3 - v2);
  return result;
}

_QWORD *sub_20BDF1A10(_QWORD *__dst, __int128 *a2, int a3, const void ***a4, _QWORD *a5, _QWORD *a6)
{
  __int128 v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;

  if (*((char *)a2 + 23) < 0)
  {
    sub_20BDDBFAC(__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v11 = *a2;
    __dst[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)__dst = v11;
  }
  *((_DWORD *)__dst + 6) = a3;
  sub_20BDEBF8C(__dst + 4, a4);
  __dst[7] = *a5;
  v12 = a6[1];
  __dst[8] = *a6;
  __dst[9] = v12;
  if (v12)
  {
    v13 = (unint64_t *)(v12 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  return __dst;
}

void sub_20BDF1AB4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDF1AD0(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_20BDF1AD0(a1, *a2);
    sub_20BDF1AD0(a1, a2[1]);
    sub_20BDF1B18((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_20BDF1B18(uint64_t a1)
{
  std::__shared_weak_count *v2;

  v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t *sub_20BDF1B58(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518750;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BDF1BB4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDF1BD8(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BDF1BEC(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BDF1C04(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C5187A0))
    return a1 + 24;
  else
    return 0;
}

uint64_t *sub_20BDF1C44(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v6 = (uint64_t **)sub_20BDDE084((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    sub_20BDF1CEC((uint64_t)a1, a4, (uint64_t)v10);
    sub_20BDDE1B4(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    sub_20BDF1D7C((uint64_t)v10, 0);
  }
  return v7;
}

_BYTE *sub_20BDF1CEC@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _BYTE *result;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = operator new(0x48uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = v6 + 4;
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    result = sub_20BDDBFAC(result, *(void **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    v6[6] = *((_QWORD *)v8 + 2);
    *(_OWORD *)result = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_20BDF1D64(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BDF1D7C(v1, 0);
  _Unwind_Resume(a1);
}

void sub_20BDF1D7C(uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_20BDF1B18((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

uint64_t *sub_20BDF1DC0(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C5187C8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BDF1E1C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDF1E40(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BDF1E54(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BDF1E6C(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518818))
    return a1 + 24;
  else
    return 0;
}

uint64_t *sub_20BDF1EAC(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518840;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BDF1F08(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDF1F2C(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BDF1F40(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BDF1F58(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518890))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDF1F98(_QWORD *a1, _QWORD *a2, _QWORD *a3, const void ***a4)
{
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *exception;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19[2];
  char v20;
  _QWORD v21[4];
  __int128 __p;
  _QWORD v23[33];

  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_24C5188B8;
  a1[3] = *a2;
  v7 = a2[1];
  a1[4] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  a1[5] = 0;
  a1[6] = 0;
  v10 = (char *)operator new(0x68uLL);
  sub_20BDDC0E4(&__p, "");
  sub_20BDEFC54(v10, &__p, a4);
  *((_WORD *)v10 + 40) = 257;
  *(_QWORD *)(v10 + 92) = 0;
  *(_QWORD *)(v10 + 84) = 0;
  sub_20BDEFDCC(a1 + 7, (uint64_t)v10);
  if (SHIBYTE(v23[0]) < 0)
    operator delete((void *)__p);
  a1[9] = *a3;
  v11 = a3[1];
  a1[10] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  a1[11] = 0;
  if (!a1[3])
  {
    sub_20BDDBD68((uint64_t)&__p);
    sub_20BDDC1C8(v23, (uint64_t)"Invalid object", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v21, (__int128 *)v19);
    if (v20 < 0)
      operator delete(v19[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v16 = sub_20BDDC09C(exception, (uint64_t)v21);
    __cxa_throw(v16, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!a1[9])
  {
    sub_20BDDBD68((uint64_t)&__p);
    sub_20BDDC1C8(v23, (uint64_t)"Invalid compound data", 21);
    std::stringbuf::str();
    sub_20BDDBF20(v21, (__int128 *)v19);
    if (v20 < 0)
      operator delete(v19[0]);
    v17 = __cxa_allocate_exception(0x20uLL);
    v18 = sub_20BDDC09C(v17, (uint64_t)v21);
    __cxa_throw(v18, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return a1;
}

void sub_20BDF21B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *v21;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v22;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v23;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v24;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v25;
  std::__shared_weak_count *v27;

  sub_20BDDC194(&a12);
  sub_20BDDBE98((uint64_t)&__p);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v25);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v24);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v23);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v22);
  v27 = (std::__shared_weak_count *)*((_QWORD *)v21 + 2);
  if (v27)
    std::__shared_weak_count::__release_weak(v27);
  Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter::~CompoundPropertyWriter(v21);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDF2264(_QWORD *a1, _QWORD *a2, uint64_t *a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  const std::string **v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  const std::string *v19;
  _QWORD *v20;
  _QWORD *v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *exception;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  void *__p[2];
  char v40;
  _QWORD v41[4];
  __int128 v42;
  _QWORD v43[33];

  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_24C5188B8;
  a1[3] = 0;
  v7 = (uint64_t)(a1 + 3);
  a1[4] = 0;
  a1[5] = *a2;
  v8 = a1 + 5;
  v9 = a2[1];
  a1[6] = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  a1[7] = *a4;
  v12 = (const std::string **)(a1 + 7);
  v13 = a4[1];
  a1[8] = v13;
  if (v13)
  {
    v14 = (unint64_t *)(v13 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = a5;
  if (!a1[5])
  {
    sub_20BDDBD68((uint64_t)&v42);
    sub_20BDDC1C8(v43, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v41, (__int128 *)__p);
    if (v40 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v32 = sub_20BDDC09C(exception, (uint64_t)v41);
    __cxa_throw(v32, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*v12)
  {
    sub_20BDDBD68((uint64_t)&v42);
    sub_20BDDC1C8(v43, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v41, (__int128 *)__p);
    if (v40 < 0)
      operator delete(__p[0]);
    v33 = __cxa_allocate_exception(0x20uLL);
    v34 = sub_20BDDC09C(v33, (uint64_t)v41);
    __cxa_throw(v34, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)*a2 + 24))(&v42);
  sub_20BDE82DC(v7, &v42);
  v16 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
  if (*((_QWORD *)&v42 + 1))
  {
    v17 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  if (!*v8)
  {
    sub_20BDDBD68((uint64_t)&v42);
    sub_20BDDC1C8(v43, (uint64_t)"Invalid parent object", 21);
    std::stringbuf::str();
    sub_20BDDBF20(v41, (__int128 *)__p);
    if (v40 < 0)
      operator delete(__p[0]);
    v35 = __cxa_allocate_exception(0x20uLL);
    v36 = sub_20BDDC09C(v35, (uint64_t)v41);
    __cxa_throw(v36, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v19 = *v12;
  if (SHIBYTE((*v12)->__r_.__value_.__r.__words[2]) < 0)
  {
    if (!v19->__r_.__value_.__l.__size_)
      goto LABEL_29;
  }
  else if (!*((_BYTE *)&(*v12)->__r_.__value_.__s + 23))
  {
LABEL_29:
    sub_20BDDBD68((uint64_t)&v42);
    sub_20BDDC1C8(v43, (uint64_t)"Invalid name", 12);
    std::stringbuf::str();
    sub_20BDDBF20(v41, (__int128 *)__p);
    if (v40 < 0)
      operator delete(__p[0]);
    v29 = __cxa_allocate_exception(0x20uLL);
    v30 = sub_20BDDC09C(v29, (uint64_t)v41);
    __cxa_throw(v30, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (std::string::find(v19, 47, 0) != -1)
    goto LABEL_29;
  v20 = operator new(0x68uLL);
  v21 = v20;
  v22 = (std::__shared_weak_count *)a3[1];
  v37 = *a3;
  v38 = v22;
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
  }
  sub_20BDEFEE4(v20, &v37);
  sub_20BDF26D8(a1 + 9, v21);
  v25 = v38;
  if (v38)
  {
    v26 = (unint64_t *)&v38->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  return a1;
}

void sub_20BDF2614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *v6;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v7;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v8;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v9;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v10;
  std::__shared_weak_count *v12;
  std::exception v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v13.__vftable = va_arg(va1, std::exception_vtbl *);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v10);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v7);
  v12 = (std::__shared_weak_count *)*((_QWORD *)v6 + 2);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter::~CompoundPropertyWriter(v6);
  _Unwind_Resume(a1);
}

void sub_20BDF26D8(_QWORD *a1, _QWORD *a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  sub_20BDF2D40(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_20BDF274C(uint64_t a1)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  void *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  _QWORD **v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  uint64_t v39;
  unint64_t v40;
  void *lpsrc;
  std::__shared_weak_count *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;

  *(_QWORD *)a1 = off_24C5188B8;
  v2 = (pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 40);
  if (*(_QWORD *)(a1 + 40))
  {
    v3 = *(_QWORD *)(a1 + 24);
    v4 = *(std::__shared_weak_count **)(a1 + 32);
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    (*(void (**)(void **__return_ptr))(*(_QWORD *)v3 + 24))(&lpsrc);
    v8 = v42;
    if (v42)
    {
      v9 = (unint64_t *)&v42->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v12 = *((_QWORD *)v7 + 29);
    v11 = (std::__shared_weak_count *)*((_QWORD *)v7 + 30);
    if (v11)
    {
      v13 = (unint64_t *)&v11->__shared_owners_;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    if (v8)
    {
      v15 = (unint64_t *)&v8->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v17 = v42;
    if (v42)
    {
      v18 = (unint64_t *)&v42->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    if (v4)
    {
      v20 = (unint64_t *)&v4->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    v22 = *(_QWORD *)(a1 + 72);
    v43 = v12;
    v44 = v11;
    if (v11)
    {
      v23 = (unint64_t *)&v11->__shared_owners_;
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }
    sub_20BDF171C(v22, &v43);
    v25 = v44;
    if (v44)
    {
      v26 = (unint64_t *)&v44->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    Alembic::Util::v12::SpookyHash::Init((uint64_t)&lpsrc, 0, 0);
    sub_20BDF19F0(*(_QWORD **)(a1 + 72), (Alembic::Util::v12::SpookyHash *)&lpsrc);
    sub_20BDFFE14(*(_QWORD *)(a1 + 56), (Alembic::Util::v12::SpookyHash *)&lpsrc);
    v39 = 0;
    v40 = 0;
    Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)&lpsrc, &v40, (unint64_t *)&v39, v28, v29);
    v31 = *(std::__shared_weak_count **)(a1 + 48);
    if (v31)
    {
      v32 = (unint64_t *)&v31->__shared_owners_;
      do
        v33 = __ldxr(v32);
      while (__stxr(v33 + 1, v32));
    }
    sub_20BDF1904(v30[9], *(_QWORD *)(a1 + 88), v40, v39);
    if (v31)
    {
      v34 = (unint64_t *)&v31->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    if (v11)
    {
      v36 = (unint64_t *)&v11->__shared_owners_;
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 72));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 56));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v2);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 24));
  v38 = *(std::__shared_weak_count **)(a1 + 16);
  if (v38)
    std::__shared_weak_count::__release_weak(v38);
  Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter::~CompoundPropertyWriter((Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *)a1);
}

_QWORD *sub_20BDF2A44(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_20BDF1904(*(_QWORD **)(a1 + 72), a2, a3, a4);
}

void sub_20BDF2A50(uint64_t a1)
{
  void *v1;

  sub_20BDF274C(a1);
  operator delete(v1);
}

uint64_t sub_20BDF2A64(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t sub_20BDF2A6C@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 32);
  *a2 = *(_QWORD *)(result + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t sub_20BDF2A90@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 48);
  *a2 = *(_QWORD *)(result + 40);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

double sub_20BDF2AB4@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_20BDF2AEC(uint64_t a1)
{
  return sub_20BDEFF90(*(_QWORD *)(a1 + 72));
}

double sub_20BDF2AF4(uint64_t a1, unint64_t a2)
{
  return sub_20BDEFFA0(*(_QWORD *)(a1 + 72), a2);
}

const void **sub_20BDF2AFC(uint64_t a1, unsigned __int8 **a2)
{
  return sub_20BDF01A8(*(_QWORD *)(a1 + 72), a2);
}

void sub_20BDF2B04(uint64_t a1@<X0>, const void **a2@<X1>, _QWORD *a3@<X8>)
{
  sub_20BDF0264(*(_QWORD *)(a1 + 72), a2, a3);
}

void sub_20BDF2B0C(_QWORD *a1@<X0>, const void **a2@<X1>, const void ***a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _OWORD *a6@<X8>)
{
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;

  v11 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v15);
  sub_20BDF02F0(v11, &v15, a2, a3, a4, a5, a6);
  v12 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_20BDF2BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDF2BD0(_QWORD *a1@<X0>, const void **a2@<X1>, const void ***a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _OWORD *a6@<X8>)
{
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;

  v11 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v15);
  sub_20BDF0A7C(v11, &v15, a2, a3, a4, a5, a6);
  v12 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_20BDF2C80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDF2C94(_QWORD *a1@<X0>, const void **a2@<X1>, const void ***a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;

  v7 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v11);
  sub_20BDF1208(v7, &v11, a2, a3, a4);
  v8 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_20BDF2D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDF2D40(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518988;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  sub_20BDEA008((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_20BDF2D94(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  if (v1)
  {
    v3 = (void *)sub_20BDEFF8C(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_20BDF2DB4(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDF2DC8(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v2 = (void *)sub_20BDEFF8C(v1);
    operator delete(v2);
  }
}

uint64_t sub_20BDF2DEC(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C5189D8))
    return a1 + 24;
  else
    return 0;
}

uint64_t sub_20BDF2E2C(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v7;
  __int128 *v8;

  if (*(char *)(a2 + 23) < 0)
  {
    v4 = *(_QWORD *)(a2 + 8);
    if (!v4)
      return 0;
    if (v4 > 0xFF)
      return 255;
  }
  else if (!*(_BYTE *)(a2 + 23))
  {
    return 0;
  }
  v5 = sub_20BDEEBA4(a1, (const void **)a2);
  if (a1 + 8 != v5)
    return (*(_DWORD *)(v5 + 56) + 1);
  v7 = *(_QWORD *)(a1 + 16);
  if (v7 <= 0xFD)
  {
    v8 = (__int128 *)a2;
    *((_DWORD *)sub_20BDF3224((uint64_t **)a1, (const void **)a2, (uint64_t)&unk_20CA51101, &v8) + 14) = v7;
    return (v7 + 1);
  }
  return 255;
}

void sub_20BDF2EE4(_QWORD *a1, Alembic::Ogawa::v12::OGroup **a2)
{
  unint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  unint64_t v16;
  int64_t v17;
  uint64_t v18;
  unint64_t v19;
  size_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char v25;
  uint64_t v26;
  char *v27;
  void *v28;
  char *v29;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  Alembic::Ogawa::v12::OData *v33;
  std::__shared_weak_count *v34;
  void *__p;
  char *v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  v3 = a1[2];
  if (v3)
  {
    v38 = 0;
    v39 = 0;
    v40 = 0;
    sub_20BDF3198(&v38, v3);
    v7 = (_QWORD *)*a1;
    v5 = a1 + 1;
    v6 = v7;
    if (v7 != v5)
    {
      do
      {
        std::string::operator=((std::string *)(v38 + 24 * *((unsigned int *)v6 + 14)), (const std::string *)(v6 + 4));
        v8 = (_QWORD *)v6[1];
        if (v8)
        {
          do
          {
            v9 = v8;
            v8 = (_QWORD *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v9 = (_QWORD *)v6[2];
            v10 = *v9 == (_QWORD)v6;
            v6 = v9;
          }
          while (!v10);
        }
        v6 = v9;
      }
      while (v9 != v5);
    }
    __p = 0;
    v36 = 0;
    v37 = 0;
    v11 = v38;
    v12 = v39;
    if (v38 == v39)
    {
      v28 = 0;
      v29 = 0;
    }
    else
    {
      do
      {
        if (*(char *)(v11 + 23) < 0)
          v13 = *(_QWORD *)(v11 + 8);
        else
          LOBYTE(v13) = *(_BYTE *)(v11 + 23);
        v14 = v36;
        if (v36 >= v37)
        {
          v16 = (unint64_t)__p;
          v17 = v36 - (_BYTE *)__p;
          v18 = v36 - (_BYTE *)__p + 1;
          if (v18 < 0)
            sub_20BDDF694();
          v19 = v37 - (_BYTE *)__p;
          if (2 * (v37 - (_BYTE *)__p) > (unint64_t)v18)
            v18 = 2 * v19;
          if (v19 >= 0x3FFFFFFFFFFFFFFFLL)
            v20 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v20 = v18;
          if (v20)
            v21 = (char *)operator new(v20);
          else
            v21 = 0;
          v22 = &v21[v17];
          v23 = &v21[v17];
          *v23 = v13;
          v15 = v23 + 1;
          if (v14 != (char *)v16)
          {
            v24 = &v14[~v16];
            do
            {
              v25 = *--v14;
              (v24--)[(_QWORD)v21] = v25;
            }
            while (v14 != (char *)v16);
            v14 = (char *)__p;
            v22 = v21;
          }
          __p = v22;
          v36 = v15;
          v37 = &v21[v20];
          if (v14)
            operator delete(v14);
        }
        else
        {
          *v36 = v13;
          v15 = v14 + 1;
        }
        v36 = v15;
        if (*(char *)(v11 + 23) < 0)
        {
          v27 = *(char **)v11;
          v26 = *(_QWORD *)(v11 + 8);
        }
        else
        {
          v26 = *(unsigned __int8 *)(v11 + 23);
          v27 = (char *)v11;
        }
        sub_20BDF36D0((char **)&__p, v15, v27, &v27[v26], v26);
        v11 += 24;
      }
      while (v11 != v12);
      v28 = __p;
      v29 = v36;
    }
    Alembic::Ogawa::v12::OGroup::addData(*a2, v28, v29 - (_BYTE *)v28, &v33);
    v30 = v34;
    if (v34)
    {
      p_shared_owners = (unint64_t *)&v34->__shared_owners_;
      do
        v32 = __ldaxr(p_shared_owners);
      while (__stlxr(v32 - 1, p_shared_owners));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    if (__p)
    {
      v36 = (char *)__p;
      operator delete(__p);
    }
    __p = &v38;
    sub_20BDE5038((void ***)&__p);
  }
  else
  {
    Alembic::Ogawa::v12::OGroup::addEmptyData(*a2);
  }
}

void sub_20BDF3154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char *__p, char *a12, uint64_t a13, char a14)
{
  if (__p)
  {
    a12 = __p;
    operator delete(__p);
  }
  __p = &a14;
  sub_20BDE5038((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_20BDF3198(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_20BDF335C(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 24 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 1) < 0)
        operator delete(*(void **)(v3 - 24));
      v3 -= 24;
    }
    a1[1] = v7;
  }
}

uint64_t *sub_20BDF3224(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;

  v6 = (uint64_t **)sub_20BDDE084((uint64_t)a1, &v9, a2);
  result = *v6;
  if (!*v6)
  {
    sub_20BDF32B8((uint64_t)a1, a4, (uint64_t)&v8);
    sub_20BDDE1B4(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

_BYTE *sub_20BDF32B8@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  _BYTE *result;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = v6 + 32;
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    result = sub_20BDDBFAC(result, *(void **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    *((_QWORD *)v6 + 6) = *((_QWORD *)v8 + 2);
    *(_OWORD *)result = v9;
  }
  *((_DWORD *)v6 + 14) = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_20BDF3340(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  sub_20BDEEB58(v3, v2);
  _Unwind_Resume(a1);
}

void sub_20BDF335C(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      sub_20BDDF694();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)sub_20BDE4FF4(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[24 * v8];
    v18 = &v12[24 * v11];
    v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    v17 = &v16[v14];
    sub_20BDF34C0(a1, &v15);
    sub_20BDF3648((uint64_t)&v15);
  }
}

void sub_20BDF34AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDF3648((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF34C0(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_20BDF3534((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_20BDF3534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  v13 = 1;
  sub_20BDF35D0((uint64_t)v12);
  return a6;
}

uint64_t sub_20BDF35D0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_20BDF3604(a1);
  return a1;
}

void sub_20BDF3604(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 24;
  }
}

uint64_t sub_20BDF3648(uint64_t a1)
{
  sub_20BDF367C(a1, *(void ***)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_20BDF367C(uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

char *sub_20BDF36D0(char **a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  uint64_t v6;
  char *v7;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  char *v18;
  int64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char v25;
  char *v26;
  char *v27;
  char *v28;
  char v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  char v36;

  v5 = __dst;
  if (a5 < 1)
    return v5;
  v6 = a5;
  v7 = __src;
  v10 = a1[1];
  v9 = a1[2];
  if (v9 - v10 >= a5)
  {
    v17 = v10 - __dst;
    if (v10 - __dst >= a5)
    {
      v18 = &__src[a5];
      v20 = a1[1];
    }
    else
    {
      v18 = &__src[v17];
      if (&__src[v17] == a4)
      {
        v20 = a1[1];
      }
      else
      {
        v19 = __src - __dst;
        v20 = a1[1];
        v21 = v20;
        do
          *v21++ = (v20++)[v19];
        while (&v20[v19] != a4);
      }
      a1[1] = v20;
      if (v17 < 1)
        return v5;
    }
    v32 = &__dst[a5];
    v33 = &v20[-a5];
    v34 = v20;
    if (&v20[-a5] < v10)
    {
      v35 = &v10[a5] - v20;
      v34 = v20;
      do
      {
        v36 = *v33++;
        *v34++ = v36;
        --v35;
      }
      while (v35);
    }
    a1[1] = v34;
    if (v20 != v32)
      memmove(&__dst[a5], __dst, v20 - v32);
    if (v18 != v7)
      memmove(v5, v7, v18 - v7);
  }
  else
  {
    v11 = *a1;
    v12 = v10 - *a1 + a5;
    if (v12 < 0)
      sub_20BDDF694();
    v13 = (char *)(__dst - v11);
    v14 = v9 - v11;
    if (2 * v14 > v12)
      v12 = 2 * v14;
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL)
      v15 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v15 = v12;
    if (v15)
      v16 = operator new(v15);
    else
      v16 = 0;
    v22 = &v13[(_QWORD)v16];
    v23 = &v13[(_QWORD)v16 + v6];
    v24 = v22;
    do
    {
      v25 = *v7++;
      *v24++ = v25;
      --v6;
    }
    while (v6);
    v26 = *a1;
    if (*a1 == v5)
    {
      v28 = v22;
    }
    else
    {
      v27 = v5;
      v28 = v22;
      do
      {
        v29 = *--v27;
        *--v28 = v29;
      }
      while (v27 != v26);
      v10 = a1[1];
    }
    v30 = (char *)v16 + v15;
    if (v10 != v5)
      memmove(v23, v5, v10 - v5);
    v31 = *a1;
    *a1 = v28;
    a1[1] = &v23[v10 - v5];
    a1[2] = v30;
    if (v31)
      operator delete(v31);
    return v22;
  }
  return v5;
}

uint64_t sub_20BDF38C4(uint64_t a1, uint64_t *a2, const void **a3, unint64_t a4, uint64_t a5, _QWORD *a6)
{
  Alembic::Ogawa::v12::IGroup **v10;
  uint64_t *v11;
  uint64_t **v12;
  uint64_t v13;
  uint64_t NumChildren;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  _QWORD *exception;
  _QWORD *v49;
  _QWORD *v50;
  uint64_t v51;
  char *v54;
  std::__shared_weak_count *v55;
  unint64_t **v56;
  std::__shared_weak_count *v57;
  void *__p[2];
  char v59;
  __int128 v60[2];
  char *v61;
  char *v62;
  uint64_t v63[33];

  *(_OWORD *)(a1 + 16) = 0u;
  v10 = (Alembic::Ogawa::v12::IGroup **)(a1 + 16);
  *(_QWORD *)(a1 + 32) = 0;
  v11 = (uint64_t *)(a1 + 32);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 40) = a1 + 48;
  v12 = (uint64_t **)(a1 + 40);
  *(_QWORD *)(a1 + 56) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  v13 = a1 + 80;
  *(_OWORD *)(a1 + 64) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 96), 0);
  if (!*a2)
  {
    sub_20BDDBD68((uint64_t)&v61);
    sub_20BDDC1C8(v63, (uint64_t)"Invalid object data group", 25);
    std::stringbuf::str();
    sub_20BDDBF20(v60, (__int128 *)__p);
    if (v59 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v49 = sub_20BDDC09C(exception, (uint64_t)v60);
    __cxa_throw(v49, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDE881C(v10, a2);
  NumChildren = Alembic::Ogawa::v12::IGroup::getNumChildren(*v10);
  if (NumChildren)
  {
    v15 = NumChildren - 1;
    if (Alembic::Ogawa::v12::IGroup::isChildData(*v10, NumChildren - 1))
    {
      v61 = 0;
      v62 = 0;
      v63[0] = 0;
      v16 = *(std::__shared_weak_count **)(a1 + 24);
      v56 = *(unint64_t ***)(a1 + 16);
      v57 = v16;
      if (v16)
      {
        p_shared_owners = (unint64_t *)&v16->__shared_owners_;
        do
          v18 = __ldxr(p_shared_owners);
        while (__stxr(v18 + 1, p_shared_owners));
      }
      v51 = v13;
      sub_20BDFB2E8(&v56, v15, a4, a3, a6, &v61);
      v19 = v57;
      if (v57)
      {
        v20 = (unint64_t *)&v57->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
      v50 = a6;
      if (v61 != v62)
      {
        v22 = (v62 - v61) >> 4;
        if (is_mul_ok(v22, 0x60uLL))
          v23 = (96 * v22) | 0x10;
        else
          v23 = -1;
        v24 = operator new[](v23);
        v25 = 0;
        *v24 = 96;
        v24[1] = v22;
        v26 = 96 * v22;
        do
        {
          v27 = &v24[v25 / 8];
          *((_OWORD *)v27 + 1) = 0u;
          *((_OWORD *)v27 + 2) = 0u;
          pthread_mutex_init((pthread_mutex_t *)&v24[v25 / 8 + 6], 0);
          v25 += 96;
        }
        while (v26 != v25);
        *(_QWORD *)&v60[0] = 0;
        v28 = *v11;
        *v11 = (uint64_t)(v24 + 2);
        if (v28)
        {
          sub_20BDF48B4((uint64_t)v11, v28);
          v29 = *(_QWORD *)&v60[0];
          *(_QWORD *)&v60[0] = 0;
          if (v29)
            sub_20BDF48B4((uint64_t)v60, v29);
        }
        v30 = v61;
        if (v62 != v61)
        {
          v31 = 0;
          v32 = 0;
          v33 = 0;
          do
          {
            __p[0] = *(void **)&v30[v32];
            sub_20BDEEA20(v12, (const void **)__p[0], (uint64_t)&unk_20CA51102, (__int128 **)__p)[7] = v33;
            sub_20BDE881C((_QWORD *)(*v11 + v31), (uint64_t *)&v61[v32]);
            ++v33;
            v30 = v61;
            v32 += 16;
            v31 += 96;
          }
          while (v33 < (v62 - v61) >> 4);
        }
      }
      *(_QWORD *)&v60[0] = &v61;
      sub_20BDE9EB0((void ***)v60);
      v13 = v51;
      a6 = v50;
    }
    if (Alembic::Ogawa::v12::IGroup::isChildGroup(*v10, 0))
    {
      Alembic::Ogawa::v12::IGroup::getGroup((uint64_t **)*v10, 0, 0, a4, &v61);
      v34 = operator new(0x40uLL);
      v35 = v34;
      v54 = v61;
      v55 = (std::__shared_weak_count *)v62;
      if (v62)
      {
        v36 = (unint64_t *)(v62 + 8);
        do
          v37 = __ldxr(v36);
        while (__stxr(v37 + 1, v36));
      }
      sub_20BDED290((uint64_t)v34, (uint64_t *)&v54, a4, a5, a6);
      sub_20BDEFCE0(v60, v35);
      sub_20BDE82DC(v13, v60);
      v38 = (std::__shared_weak_count *)*((_QWORD *)&v60[0] + 1);
      if (*((_QWORD *)&v60[0] + 1))
      {
        v39 = (unint64_t *)(*((_QWORD *)&v60[0] + 1) + 8);
        do
          v40 = __ldaxr(v39);
        while (__stlxr(v40 - 1, v39));
        if (!v40)
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }
      v41 = v55;
      if (v55)
      {
        v42 = (unint64_t *)&v55->__shared_owners_;
        do
          v43 = __ldaxr(v42);
        while (__stlxr(v43 - 1, v42));
        if (!v43)
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }
      v44 = (std::__shared_weak_count *)v62;
      if (v62)
      {
        v45 = (unint64_t *)(v62 + 8);
        do
          v46 = __ldaxr(v45);
        while (__stlxr(v46 - 1, v45));
        if (!v46)
        {
          ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
          std::__shared_weak_count::__release_weak(v44);
        }
      }
    }
  }
  return a1;
}

void sub_20BDF3CEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *a11, pthread_mutex_t *a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v27;
  uint64_t *v28;
  uint64_t v29;
  char **v30;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;

  sub_20BDDC194((std::exception *)&a22);
  sub_20BDDBE98((uint64_t)&a26);
  pthread_mutex_destroy(a12);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(a11);
  v32 = *(std::__shared_weak_count **)(v26 + 72);
  if (v32)
    std::__shared_weak_count::__release_weak(v32);
  sub_20BDECAB8(v29, *v30);
  v33 = *v28;
  *v28 = 0;
  if (v33)
    sub_20BDF48B4((uint64_t)v28, v33);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v27);
  v34 = *(std::__shared_weak_count **)(v26 + 8);
  if (v34)
    std::__shared_weak_count::__release_weak(v34);
  _Unwind_Resume(a1);
}

void sub_20BDF3E38(uint64_t a1)
{
  std::__shared_weak_count *v2;

  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
  v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)a1);
}

uint64_t sub_20BDF3E74(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 96));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 80));
  v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  sub_20BDECAB8(a1 + 40, *(char **)(a1 + 48));
  v3 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = 0;
  if (v3)
    sub_20BDF48B4(a1 + 32, v3);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 16));
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

uint64_t sub_20BDF3EEC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  pthread_mutex_t *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  uint64_t v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  __int128 v37;

  v6 = (pthread_mutex_t *)(a1 + 96);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  *a3 = 0;
  a3[1] = 0;
  v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v7
    || (v8 = std::__shared_weak_count::lock(v7), (a3[1] = (uint64_t)v8) == 0)
    || (v9 = *(_QWORD *)(a1 + 64), (*a3 = v9) == 0))
  {
    v10 = operator new(0x58uLL);
    v11 = (uint64_t)v10;
    v12 = (std::__shared_weak_count *)a2[1];
    v35 = *a2;
    v36 = v12;
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }
    v15 = *(std::__shared_weak_count **)(a1 + 88);
    v33 = *(_QWORD *)(a1 + 80);
    v34 = v15;
    if (v15)
    {
      v16 = (unint64_t *)&v15->__shared_owners_;
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }
    sub_20BDEF778((uint64_t)v10, &v35, &v33);
    sub_20BDEEE08((uint64_t *)&v37, v11);
    sub_20BDE82DC((uint64_t)a3, &v37);
    v18 = (std::__shared_weak_count *)*((_QWORD *)&v37 + 1);
    if (*((_QWORD *)&v37 + 1))
    {
      v19 = (unint64_t *)(*((_QWORD *)&v37 + 1) + 8);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    v21 = v34;
    if (v34)
    {
      v22 = (unint64_t *)&v34->__shared_owners_;
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    v24 = v36;
    if (v36)
    {
      v25 = (unint64_t *)&v36->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v28 = *a3;
    v27 = a3[1];
    if (v27)
    {
      v29 = (unint64_t *)(v27 + 16);
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    v31 = *(std::__shared_weak_count **)(a1 + 72);
    *(_QWORD *)(a1 + 64) = v28;
    *(_QWORD *)(a1 + 72) = v27;
    if (v31)
      std::__shared_weak_count::__release_weak(v31);
  }
  return pthread_mutex_unlock(v6);
}

void sub_20BDF40B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  pthread_mutex_t *v11;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v12;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v12);
  pthread_mutex_unlock(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF40F8(uint64_t a1, uint64_t a2, unint64_t a3)
{
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  _BYTE v9[16];
  _QWORD v10[33];

  if (*(_QWORD *)(a1 + 56) <= a3)
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"Out of range index in OrData::getChildHeader: ", 46);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96 * a3);
}

void sub_20BDF41BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF41E4(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  v5 = sub_20BDEEBA4(a1 + 40, a3);
  if (a1 + 48 == v5)
    return 0;
  v7 = *(std::__shared_weak_count **)(a2 + 8);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = sub_20BDF40F8(a1, v6, *(_QWORD *)(v5 + 56));
  if (v7)
  {
    v11 = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return v10;
}

void sub_20BDF4294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDF42A8(_QWORD *a1@<X0>, uint64_t *a2@<X1>, const void **a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14[2];

  v7 = sub_20BDEEBA4((uint64_t)(a1 + 5), a3);
  if (a1 + 6 == (_QWORD *)v7)
  {
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    v8 = *a2;
    v9 = (std::__shared_weak_count *)a2[1];
    v14[0] = v8;
    v14[1] = (uint64_t)v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    sub_20BDF4384(a1, v14, *(_QWORD *)(v7 + 56), a4);
    if (v9)
    {
      v12 = (unint64_t *)&v9->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
}

void sub_20BDF4370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF4384@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  pthread_mutex_t *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  _QWORD *exception;
  _QWORD *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  uint64_t **v49;
  std::__shared_weak_count *v50;
  uint64_t v51;
  std::__shared_weak_count *v52;
  __int128 __p;
  char v54;
  _QWORD v55[4];
  __int128 v56;
  uint64_t v57[33];

  if (a1[7] <= a3)
  {
    sub_20BDDBD68((uint64_t)&v56);
    sub_20BDDC1C8(v57, (uint64_t)"Out of range index in OrData::getChild: ", 40);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v55, &__p);
    if (v54 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v46 = sub_20BDDC09C(exception, (uint64_t)v55);
    __cxa_throw(v46, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v8 = (pthread_mutex_t *)(a1[4] + 96 * a3 + 32);
  pthread_mutex_lock(v8);
  v9 = a1[4] + 96 * a3;
  *a4 = 0;
  a4[1] = 0;
  v10 = *(std::__shared_weak_count **)(v9 + 24);
  if (v10)
  {
    v11 = std::__shared_weak_count::lock(v10);
    a4[1] = (uint64_t)v11;
    if (v11)
    {
      v12 = *(_QWORD *)(v9 + 16);
      *a4 = v12;
      if (v12)
        return pthread_mutex_unlock(v8);
    }
    else if (*a4)
    {
      return pthread_mutex_unlock(v8);
    }
  }
  v13 = (uint64_t *)operator new(0x58uLL);
  v14 = (uint64_t)v13;
  v15 = (std::__shared_weak_count *)a2[1];
  v51 = *a2;
  v52 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }
  v18 = (std::__shared_weak_count *)a1[3];
  v49 = (uint64_t **)a1[2];
  v50 = v18;
  if (v18)
  {
    v19 = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  v21 = (uint64_t *)(a1[4] + 96 * a3);
  v47 = *v21;
  v22 = v21[1];
  v48 = (std::__shared_weak_count *)v22;
  if (v22)
  {
    v23 = (unint64_t *)(v22 + 8);
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  sub_20BDF4EB8(v13, (uint64_t)&v51, &v49, a3 + 1, &v47);
  sub_20BDEA134((uint64_t *)&v56, v14);
  sub_20BDE82DC((uint64_t)a4, &v56);
  v25 = (std::__shared_weak_count *)*((_QWORD *)&v56 + 1);
  if (*((_QWORD *)&v56 + 1))
  {
    v26 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v48;
  if (v48)
  {
    v29 = (unint64_t *)&v48->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v50;
  if (v50)
  {
    v32 = (unint64_t *)&v50->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v52;
  if (v52)
  {
    v35 = (unint64_t *)&v52->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = a1[4];
  v39 = *a4;
  v38 = a4[1];
  if (v38)
  {
    v40 = (unint64_t *)(v38 + 16);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }
  *(_QWORD *)(v37 + 96 * a3 + 16) = v39;
  v42 = v37 + 96 * a3;
  v43 = *(std::__shared_weak_count **)(v42 + 24);
  *(_QWORD *)(v42 + 24) = v38;
  if (v43)
    std::__shared_weak_count::__release_weak(v43);
  return pthread_mutex_unlock(v8);
}

void sub_20BDF4690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  std::exception v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11.__vftable = va_arg(va1, std::exception_vtbl *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BDF4704(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t NumChildren;
  unint64_t **v7;
  uint64_t Size;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  Alembic::Ogawa::v12::IData *v12;
  std::__shared_weak_count *v13;

  NumChildren = Alembic::Ogawa::v12::IGroup::getNumChildren(*(Alembic::Ogawa::v12::IGroup **)(a1 + 16));
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 16), NumChildren - 1, a3, &v12);
  if (v12 && (unint64_t)Alembic::Ogawa::v12::IData::getSize(v12) >= 0x20)
  {
    v7 = (unint64_t **)v12;
    Size = Alembic::Ogawa::v12::IData::getSize(v12);
    Alembic::Ogawa::v12::IData::read(v7, 16, a2, Size - 32, a3);
  }
  v9 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_20BDF47C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDF47DC(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t NumChildren;
  unint64_t **v7;
  uint64_t Size;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  Alembic::Ogawa::v12::IData *v12;
  std::__shared_weak_count *v13;

  NumChildren = Alembic::Ogawa::v12::IGroup::getNumChildren(*(Alembic::Ogawa::v12::IGroup **)(a1 + 16));
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 16), NumChildren - 1, a3, &v12);
  if (v12 && (unint64_t)Alembic::Ogawa::v12::IData::getSize(v12) >= 0x20)
  {
    v7 = (unint64_t **)v12;
    Size = Alembic::Ogawa::v12::IData::getSize(v12);
    Alembic::Ogawa::v12::IData::read(v7, 16, a2, Size - 16, a3);
  }
  v9 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_20BDF48A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDF48B4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  if (a2)
  {
    v3 = *(_QWORD *)(a2 - 8);
    if (v3)
    {
      v4 = 96 * v3;
      do
      {
        pthread_mutex_destroy((pthread_mutex_t *)(a2 + v4 - 64));
        v5 = *(std::__shared_weak_count **)(a2 + v4 - 72);
        if (v5)
          std::__shared_weak_count::__release_weak(v5);
        pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a2 + v4 - 96));
        v4 -= 96;
      }
      while (v4);
    }
    operator delete[]((void *)(a2 - 16));
  }
}

uint64_t *sub_20BDF492C(uint64_t *a1, uint64_t a2, uint64_t ***a3, unint64_t a4, uint64_t *a5)
{
  uint64_t *v10;
  uint64_t *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  _QWORD *exception;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  void *__p[2];
  char v58;
  uint64_t v59;
  std::__shared_weak_count *v60;
  __int128 v61;
  _QWORD v62[33];

  a1[1] = 0;
  a1[2] = 0;
  *a1 = (uint64_t)off_24C518A00;
  *(_OWORD *)(a1 + 3) = 0u;
  v10 = a1 + 3;
  *(_OWORD *)(a1 + 5) = 0u;
  v11 = a1 + 5;
  *(_OWORD *)(a1 + 7) = 0u;
  v12 = a1 + 7;
  a1[9] = *a5;
  v13 = a1 + 9;
  v14 = a5[1];
  a1[10] = v14;
  if (v14)
  {
    v15 = (unint64_t *)(v14 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  if (*(_QWORD *)a2
  {
    v18 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)&v61 = v17;
    *((_QWORD *)&v61 + 1) = v18;
    if (v18)
    {
      v19 = (unint64_t *)(v18 + 8);
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }
  }
  else
  {
    v61 = 0uLL;
  }
  sub_20BDE82DC((uint64_t)v10, &v61);
  v21 = (std::__shared_weak_count *)*((_QWORD *)&v61 + 1);
  if (*((_QWORD *)&v61 + 1))
  {
    v22 = (unint64_t *)(*((_QWORD *)&v61 + 1) + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = *v10;
  if (!*v10)
  {
    sub_20BDDBD68((uint64_t)&v61);
    sub_20BDDC1C8(v62, (uint64_t)"Invalid parent in OrImpl(Object)", 32);
    std::stringbuf::str();
    sub_20BDDBF20(&v59, (__int128 *)__p);
    if (v58 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v50 = sub_20BDDC09C(exception, (uint64_t)&v59);
    __cxa_throw(v50, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*v13)
  {
    sub_20BDDBD68((uint64_t)&v61);
    sub_20BDDC1C8(v62, (uint64_t)"Invalid header in OrImpl(Object)", 32);
    std::stringbuf::str();
    sub_20BDDBF20(&v59, (__int128 *)__p);
    if (v58 < 0)
      operator delete(__p[0]);
    v51 = __cxa_allocate_exception(0x20uLL);
    v52 = sub_20BDDC09C(v51, (uint64_t)&v59);
    __cxa_throw(v52, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v26 = *(_QWORD *)(v24 + 40);
  v25 = *(_QWORD *)(v24 + 48);
  *(_QWORD *)&v61 = v26;
  *((_QWORD *)&v61 + 1) = v25;
  if (v25)
  {
    v27 = (unint64_t *)(v25 + 8);
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  sub_20BDE82DC((uint64_t)v11, &v61);
  v29 = (std::__shared_weak_count *)*((_QWORD *)&v61 + 1);
  if (*((_QWORD *)&v61 + 1))
  {
    v30 = (unint64_t *)(*((_QWORD *)&v61 + 1) + 8);
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  if (!*v11)
  {
    sub_20BDDBD68((uint64_t)&v61);
    sub_20BDDC1C8(v62, (uint64_t)"Invalid archive in OrImpl(Object)", 33);
    std::stringbuf::str();
    sub_20BDDBF20(&v59, (__int128 *)__p);
    if (v58 < 0)
      operator delete(__p[0]);
    v53 = __cxa_allocate_exception(0x20uLL);
    v54 = sub_20BDDC09C(v53, (uint64_t)&v59);
    __cxa_throw(v54, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDE9C40(*v11, &v61);
  v32 = *(_QWORD *)(v61 + 8);
  Alembic::Ogawa::v12::IGroup::getGroup(*a3, a4, 0, v32, &v59);
  v33 = operator new(0xA0uLL);
  v55 = v59;
  v56 = v60;
  if (v60)
  {
    p_shared_owners = (unint64_t *)&v60->__shared_owners_;
    do
      v35 = __ldxr(p_shared_owners);
    while (__stxr(v35 + 1, p_shared_owners));
  }
  v36 = *a5;
  v37 = *v11;
  v38 = sub_20BDE9D1C(*v11);
  sub_20BDF3E70(v33, &v55, v36 + 24, v32, v37, v38);
  sub_20BDF4E48(v12, v33);
  v39 = v56;
  if (v56)
  {
    v40 = (unint64_t *)&v56->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  v42 = v60;
  if (v60)
  {
    v43 = (unint64_t *)&v60->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v45 = (std::__shared_weak_count *)*((_QWORD *)&v61 + 1);
  if (*((_QWORD *)&v61 + 1))
  {
    v46 = (unint64_t *)(*((_QWORD *)&v61 + 1) + 8);
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  return a1;
}

void sub_20BDF4D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  Alembic::AbcCoreAbstract::v12::ObjectReader *v6;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v7;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v8;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v9;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v10;
  std::__shared_weak_count *v12;
  std::exception v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v13.__vftable = va_arg(va1, std::exception_vtbl *);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v10);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v7);
  v12 = (std::__shared_weak_count *)*((_QWORD *)v6 + 2);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader(v6);
  _Unwind_Resume(a1);
}

void sub_20BDF4E48(_QWORD *a1, _QWORD *a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  sub_20BDE9F98(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

_QWORD *sub_20BDF4EBC(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *exception;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *__p[2];
  char v20;
  _QWORD v21[4];
  _BYTE v22[16];
  _QWORD v23[33];

  result[1] = 0;
  result[2] = 0;
  *result = off_24C518A00;
  result[3] = 0;
  result[4] = 0;
  result[5] = *a2;
  v4 = a2[1];
  result[6] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  result[7] = *a3;
  v7 = a3[1];
  result[8] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  result[9] = *a4;
  v10 = a4[1];
  result[10] = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  if (!result[5])
  {
    sub_20BDDBD68((uint64_t)v22);
    sub_20BDDC1C8(v23, (uint64_t)"Invalid archive in OrImpl(Archive)", 34);
    std::stringbuf::str();
    sub_20BDDBF20(v21, (__int128 *)__p);
    if (v20 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v14 = sub_20BDDC09C(exception, (uint64_t)v21);
    __cxa_throw(v14, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!result[7])
  {
    sub_20BDDBD68((uint64_t)v22);
    sub_20BDDC1C8(v23, (uint64_t)"Invalid data in OrImpl(Archive)", 31);
    std::stringbuf::str();
    sub_20BDDBF20(v21, (__int128 *)__p);
    if (v20 < 0)
      operator delete(__p[0]);
    v15 = __cxa_allocate_exception(0x20uLL);
    v16 = sub_20BDDC09C(v15, (uint64_t)v21);
    __cxa_throw(v16, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!result[9])
  {
    sub_20BDDBD68((uint64_t)v22);
    sub_20BDDC1C8(v23, (uint64_t)"Invalid header in OrImpl(Archive)", 33);
    std::stringbuf::str();
    sub_20BDDBF20(v21, (__int128 *)__p);
    if (v20 < 0)
      operator delete(__p[0]);
    v17 = __cxa_allocate_exception(0x20uLL);
    v18 = sub_20BDDC09C(v17, (uint64_t)v21);
    __cxa_throw(v18, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return result;
}

void sub_20BDF5110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  Alembic::AbcCoreAbstract::v12::ObjectReader *v4;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v5;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v6;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v7;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v8;
  std::__shared_weak_count *v10;
  std::exception v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v11.__vftable = va_arg(va1, std::exception_vtbl *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v7);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v6);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v5);
  v10 = (std::__shared_weak_count *)*((_QWORD *)v4 + 2);
  if (v10)
    std::__shared_weak_count::__release_weak(v10);
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader(v4);
  _Unwind_Resume(a1);
}

void sub_20BDF5198(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = off_24C518A00;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 9));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 7));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 5));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 3));
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader((Alembic::AbcCoreAbstract::v12::ObjectReader *)a1);
}

void sub_20BDF51F0(_QWORD *a1)
{
  void *v1;

  sub_20BDF5198(a1);
  operator delete(v1);
}

uint64_t sub_20BDF5204(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t sub_20BDF520C@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 48);
  *a2 = *(_QWORD *)(result + 40);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t sub_20BDF5230@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 32);
  *a2 = *(_QWORD *)(result + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void sub_20BDF5254(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  v3 = a1[7];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 104))(&v7);
  sub_20BDF3EEC(v3, &v7, a2);
  v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_20BDF52D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF52E8(uint64_t a1)
{
  return sub_20BDED32C(*(_QWORD *)(a1 + 56));
}

uint64_t sub_20BDF52F0(_QWORD *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v3 = a1[7];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 104))(&v9);
  v4 = sub_20BDF40F8(v3, (uint64_t)&v9, a2);
  v5 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return v4;
}

void sub_20BDF5378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF538C(_QWORD *a1, const void **a2)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v3 = a1[7];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 104))(&v9);
  v4 = sub_20BDF41E4(v3, (uint64_t)&v9, a2);
  v5 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return v4;
}

void sub_20BDF5414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDF5428(_QWORD *a1@<X0>, const void **a2@<X1>, uint64_t *a3@<X8>)
{
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v5 = (_QWORD *)a1[7];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 104))(&v9);
  sub_20BDF42A8(v5, &v9, a2, a3);
  v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_20BDF54B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDF54CC(_QWORD *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v5 = (_QWORD *)a1[7];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 104))(&v9);
  sub_20BDF4384(v5, &v9, a2, a3);
  v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_20BDF555C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

double sub_20BDF5570@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_20BDF55A8(uint64_t a1, void *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_20BDE9C40(*(_QWORD *)(a1 + 40), &v8);
  sub_20BDF4704(*(_QWORD *)(a1 + 56), a2, *(_QWORD *)(v8 + 8));
  v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return 1;
}

void sub_20BDF562C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF5640(uint64_t a1, void *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_20BDE9C40(*(_QWORD *)(a1 + 40), &v8);
  sub_20BDF47DC(*(_QWORD *)(a1 + 56), a2, *(_QWORD *)(v8 + 8));
  v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return 1;
}

void sub_20BDF56C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF56D8(uint64_t a1, uint64_t a2)
{
  Alembic::Ogawa::v12::OGroup *v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  _QWORD *exception;
  _QWORD *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  __int128 __p;
  char v20;
  _QWORD v21[4];
  __int128 v22;
  _QWORD v23[33];

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v3 = *(Alembic::Ogawa::v12::OGroup **)a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 24) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
    v3 = *(Alembic::Ogawa::v12::OGroup **)(a1 + 16);
  }
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = a1 + 64;
  *(_QWORD *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_QWORD *)(a1 + 128) = 0;
  if (!v3)
  {
    sub_20BDDBD68((uint64_t)&v22);
    sub_20BDDC1C8(v23, (uint64_t)"Invalid parent group", 20);
    std::stringbuf::str();
    sub_20BDDBF20(v21, &__p);
    if (v20 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v16 = sub_20BDDC09C(exception, (uint64_t)v21);
    __cxa_throw(v16, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v7 = operator new(0x68uLL);
  Alembic::Ogawa::v12::OGroup::addGroup(v3, &v17);
  sub_20BDEFEE4(v7, &v17);
  sub_20BDF2D40(&v22, v7);
  sub_20BDE82DC(a1 + 96, &v22);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
  if (*((_QWORD *)&v22 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return a1;
}

void sub_20BDF58A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v7;
  uint64_t v8;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v9;
  void *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::exception v14;
  va_list va;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v14.__vftable = va_arg(va1, std::exception_vtbl *);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  v11 = *(void **)(v6 + 112);
  if (v11)
  {
    *(_QWORD *)(v6 + 120) = v11;
    operator delete(v11);
  }
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v9);
  v12 = *(std::__shared_weak_count **)(v6 + 88);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  sub_20BDF1AD0(v8, *(_QWORD **)(v6 + 64));
  sub_20BDE9EB0((void ***)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v7);
  v13 = *(std::__shared_weak_count **)(v6 + 8);
  if (v13)
    std::__shared_weak_count::__release_weak(v13);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF5960(uint64_t a1)
{
  void *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  void **v6;

  v2 = *(void **)(a1 + 112);
  if (v2)
  {
    *(_QWORD *)(a1 + 120) = v2;
    operator delete(v2);
  }
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 96));
  v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  sub_20BDF1AD0(a1 + 56, *(_QWORD **)(a1 + 64));
  v6 = (void **)(a1 + 32);
  sub_20BDE9EB0(&v6);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 16));
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_20BDF59E0(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  __int128 v35;

  *a3 = 0;
  a3[1] = 0;
  v6 = (std::__shared_weak_count *)a1[11];
  if (!v6 || (v7 = std::__shared_weak_count::lock(v6), (a3[1] = (uint64_t)v7) == 0) || (v8 = a1[10], (*a3 = v8) == 0))
  {
    v9 = operator new(0x60uLL);
    v10 = (std::__shared_weak_count *)a2[1];
    v33 = *a2;
    v34 = v10;
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    v13 = (std::__shared_weak_count *)a1[13];
    v31 = a1[12];
    v32 = v13;
    if (v13)
    {
      v14 = (unint64_t *)&v13->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v16 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 16))(*a2);
    sub_20BDF2260(v9, &v33, &v31, (const void ***)(v16 + 48));
    sub_20BDF1EAC((uint64_t *)&v35, (uint64_t)v9);
    sub_20BDE82DC((uint64_t)a3, &v35);
    v17 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
    if (*((_QWORD *)&v35 + 1))
    {
      v18 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    v20 = v32;
    if (v32)
    {
      v21 = (unint64_t *)&v32->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = v34;
    if (v34)
    {
      v24 = (unint64_t *)&v34->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    v27 = *a3;
    v26 = a3[1];
    if (v26)
    {
      v28 = (unint64_t *)(v26 + 16);
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }
    v30 = (std::__shared_weak_count *)a1[11];
    a1[10] = v27;
    a1[11] = v26;
    if (v30)
      std::__shared_weak_count::__release_weak(v30);
  }
}

void sub_20BDF5B9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v11;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF5BD4(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t result;
  _QWORD *exception;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  void *__p[2];
  char v9;
  _QWORD v10[4];
  _BYTE v11[16];
  _QWORD v12[33];

  v2 = *(_QWORD *)(a1 + 32);
  if (a2 >= (*(_QWORD *)(a1 + 40) - v2) >> 4)
  {
    sub_20BDDBD68((uint64_t)v11);
    sub_20BDDC1C8(v12, (uint64_t)"Out of range index in OwData::getChildHeader: ", 46);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v10, (__int128 *)__p);
    if (v9 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v10);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  result = *(_QWORD *)(v2 + 16 * a2);
  if (!result)
  {
    sub_20BDDBD68((uint64_t)v11);
    sub_20BDDC1C8(v12, (uint64_t)"Invalid child header: ", 22);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v10, (__int128 *)__p);
    if (v9 < 0)
      operator delete(__p[0]);
    v6 = __cxa_allocate_exception(0x20uLL);
    v7 = sub_20BDDC09C(v6, (uint64_t)v10);
    __cxa_throw(v7, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return result;
}

void sub_20BDF5D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF5D4C(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  char v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40) - v2;
  if (v3)
  {
    v4 = 0;
    v5 = v3 >> 4;
    v6 = *((_BYTE *)a2 + 23);
    if (v6 >= 0)
      v7 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
    else
      v7 = a2[1];
    if (v6 >= 0)
      v8 = (unsigned __int8 *)a2;
    else
      v8 = *a2;
    if (v5 <= 1)
      v9 = 1;
    else
      v9 = v5;
    do
    {
      v10 = *(_QWORD *)(v2 + 16 * v4);
      v11 = *(unsigned __int8 *)(v10 + 23);
      if ((v11 & 0x80u) == 0)
        v12 = (unsigned __int8 *)*(unsigned __int8 *)(v10 + 23);
      else
        v12 = *(unsigned __int8 **)(v10 + 8);
      if (v12 == v7)
      {
        if ((v11 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v10, v8, *(_QWORD *)(v10 + 8)))
            return v10;
        }
        else
        {
          if (!*(_BYTE *)(v10 + 23))
            return v10;
          v13 = 0;
          while (*(unsigned __int8 *)(v10 + v13) == v8[v13])
          {
            if (v11 == ++v13)
              return v10;
          }
        }
      }
      ++v4;
    }
    while (v4 != v9);
  }
  return 0;
}

void sub_20BDF5E1C(uint64_t a1@<X0>, uint64_t *a2@<X1>, void **a3@<X2>, __int128 *a4@<X3>, _OWORD *a5@<X8>)
{
  uint64_t v10;
  std::string *v11;
  char *v12;
  _QWORD *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  void *v28;
  void *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t *v32;
  std::__shared_weak_count *v33;
  char *v34;
  void **v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  char *v44;
  uint64_t v45;
  _QWORD *v46;
  char *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  char *v53;
  char *v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  _QWORD *v59;
  __int128 *p_dst;
  uint64_t v61;
  _QWORD *exception;
  _QWORD *v63;
  _QWORD *v64;
  int v65;
  void *v66;
  uint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  _QWORD *v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  _QWORD *v74;
  _QWORD *v75;
  void *v76;
  std::__shared_weak_count *v77;
  uint64_t v78;
  std::__shared_weak_count *v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  void *v82[2];
  char v83;
  void *__p[2];
  char v85;
  std::string v86;
  __int128 __dst;
  uint64_t v88;
  __int128 *v89;

  if (*((char *)a4 + 23) < 0)
  {
    sub_20BDDBFAC(&__dst, *(void **)a4, *((_QWORD *)a4 + 1));
  }
  else
  {
    __dst = *a4;
    v88 = *((_QWORD *)a4 + 2);
  }
  if (sub_20BDDDEF8(a1 + 56, (const void **)&__dst))
  {
    sub_20BDDBD68((uint64_t)&v86);
    v59 = sub_20BDDC1C8(&v86.__r_.__value_.__r.__words[2], (uint64_t)"Already have an Object named: ", 30);
    if (v88 >= 0)
      p_dst = &__dst;
    else
      p_dst = (__int128 *)__dst;
    if (v88 >= 0)
      v61 = HIBYTE(v88);
    else
      v61 = *((_QWORD *)&__dst + 1);
    sub_20BDDC1C8(v59, (uint64_t)p_dst, v61);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v82);
    if (v83 < 0)
      operator delete(v82[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v63 = sub_20BDDC09C(exception, (uint64_t)__p);
    __cxa_throw(v63, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v10 = HIBYTE(v88);
  if (v88 < 0)
    v10 = *((_QWORD *)&__dst + 1);
  if (!v10)
  {
    sub_20BDDBD68((uint64_t)&v86);
    v64 = sub_20BDDC1C8(&v86.__r_.__value_.__r.__words[2], (uint64_t)"Object not given a name, parent is: ", 36);
    v65 = *((char *)a3 + 23);
    if (v65 >= 0)
      v66 = a3;
    else
      v66 = *a3;
    if (v65 >= 0)
      v67 = *((unsigned __int8 *)a3 + 23);
    else
      v67 = (uint64_t)a3[1];
    sub_20BDDC1C8(v64, (uint64_t)v66, v67);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v82);
    if (v83 < 0)
      operator delete(v82[0]);
    v68 = __cxa_allocate_exception(0x20uLL);
    v69 = sub_20BDDC09C(v68, (uint64_t)__p);
    __cxa_throw(v69, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (std::string::find((const std::string *)a4, 47, 0) != -1)
  {
    sub_20BDDBD68((uint64_t)&v86);
    v70 = sub_20BDDC1C8(&v86.__r_.__value_.__r.__words[2], (uint64_t)"Object has illegal name: ", 25);
    v71 = *((char *)a4 + 23);
    if (v71 >= 0)
      v72 = (uint64_t)a4;
    else
      v72 = *(_QWORD *)a4;
    if (v71 >= 0)
      v73 = *((unsigned __int8 *)a4 + 23);
    else
      v73 = *((_QWORD *)a4 + 1);
    sub_20BDDC1C8(v70, v72, v73);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v82);
    if (v83 < 0)
      operator delete(v82[0]);
    v74 = __cxa_allocate_exception(0x20uLL);
    v75 = sub_20BDDC09C(v74, (uint64_t)__p);
    __cxa_throw(v75, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (*((char *)a3 + 23) < 0)
    sub_20BDDBFAC(&v86, *a3, (unint64_t)a3[1]);
  else
    v86 = *(std::string *)a3;
  if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
  {
    if (v86.__r_.__value_.__l.__size_ == 1)
    {
      v11 = (std::string *)v86.__r_.__value_.__r.__words[0];
LABEL_17:
      if (v11->__r_.__value_.__s.__data_[0] == 47)
        goto LABEL_19;
    }
  }
  else if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) == 1)
  {
    v11 = &v86;
    goto LABEL_17;
  }
  std::string::append(&v86, "/");
LABEL_19:
  v12 = (char *)operator new(0x48uLL);
  pxrInternal__aapl__pxrReserved__::Sdf_CreateIdentifier((const void **)&v86.__r_.__value_.__l.__data_, (const void **)a4, (uint64_t)__p);
  sub_20BDF6B14(v12, a4, (__int128 *)__p, (const void ***)a4 + 6);
  sub_20BDE9D90(v82, (uint64_t)v12);
  if (v85 < 0)
    operator delete(__p[0]);
  v13 = operator new(0x60uLL);
  v14 = (std::__shared_weak_count *)a2[1];
  v80 = *a2;
  v81 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  Alembic::Ogawa::v12::OGroup::addGroup(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), &v78);
  v76 = v82[0];
  v77 = (std::__shared_weak_count *)v82[1];
  if (v82[1])
  {
    v17 = (unint64_t *)((char *)v82[1] + 8);
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  sub_20BDF7460(v13, &v80, &v78, &v76, (uint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32)) >> 4);
  sub_20BDECE08((uint64_t *)__p, (uint64_t)v13);
  v19 = v77;
  if (v77)
  {
    v20 = (unint64_t *)&v77->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v79;
  if (v79)
  {
    v23 = (unint64_t *)&v79->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v81;
  if (v81)
  {
    v26 = (unint64_t *)&v81->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  sub_20BDEA72C((char **)(a1 + 32), (__int128 *)v82);
  v29 = __p[0];
  v28 = __p[1];
  if (__p[1])
  {
    v30 = (unint64_t *)((char *)__p[1] + 16);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v89 = a4;
  v32 = sub_20BDF6C60((uint64_t **)(a1 + 56), (const void **)a4, (uint64_t)&unk_20CA5116E, &v89);
  v33 = (std::__shared_weak_count *)v32[8];
  v32[7] = (uint64_t)v29;
  v32[8] = (uint64_t)v28;
  if (v33)
    std::__shared_weak_count::__release_weak(v33);
  v34 = *(char **)(a1 + 128);
  v35 = (void **)(a1 + 112);
  v36 = *(char **)(a1 + 120);
  if (v36 >= v34)
  {
    v38 = (char *)*v35;
    v39 = (v36 - (_BYTE *)*v35) >> 3;
    v40 = v39 + 1;
    if ((unint64_t)(v39 + 1) >> 61)
      sub_20BDDF694();
    v41 = v34 - v38;
    if (v41 >> 2 > v40)
      v40 = v41 >> 2;
    if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8)
      v42 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v42 = v40;
    if (v42)
    {
      v43 = (char *)sub_20BDDF6A8(a1 + 128, v42);
      v38 = *(char **)(a1 + 112);
      v36 = *(char **)(a1 + 120);
    }
    else
    {
      v43 = 0;
    }
    v44 = &v43[8 * v39];
    v34 = &v43[8 * v42];
    *(_QWORD *)v44 = 0;
    v37 = v44 + 8;
    while (v36 != v38)
    {
      v45 = *((_QWORD *)v36 - 1);
      v36 -= 8;
      *((_QWORD *)v44 - 1) = v45;
      v44 -= 8;
    }
    *(_QWORD *)(a1 + 112) = v44;
    *(_QWORD *)(a1 + 120) = v37;
    *(_QWORD *)(a1 + 128) = v34;
    if (v38)
    {
      operator delete(v38);
      v34 = *(char **)(a1 + 128);
    }
  }
  else
  {
    *(_QWORD *)v36 = 0;
    v37 = v36 + 8;
  }
  *(_QWORD *)(a1 + 120) = v37;
  if (v37 >= v34)
  {
    v47 = (char *)*v35;
    v48 = (v37 - (_BYTE *)*v35) >> 3;
    v49 = v48 + 1;
    if ((unint64_t)(v48 + 1) >> 61)
      sub_20BDDF694();
    v50 = v34 - v47;
    if (v50 >> 2 > v49)
      v49 = v50 >> 2;
    if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8)
      v51 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v51 = v49;
    if (v51)
    {
      v52 = (char *)sub_20BDDF6A8(a1 + 128, v51);
      v47 = *(char **)(a1 + 112);
      v37 = *(char **)(a1 + 120);
    }
    else
    {
      v52 = 0;
    }
    v53 = &v52[8 * v48];
    v54 = &v52[8 * v51];
    *(_QWORD *)v53 = 0;
    v46 = v53 + 8;
    while (v37 != v47)
    {
      v55 = *((_QWORD *)v37 - 1);
      v37 -= 8;
      *((_QWORD *)v53 - 1) = v55;
      v53 -= 8;
    }
    *(_QWORD *)(a1 + 112) = v53;
    *(_QWORD *)(a1 + 120) = v46;
    *(_QWORD *)(a1 + 128) = v54;
    if (v47)
      operator delete(v47);
  }
  else
  {
    *(_QWORD *)v37 = 0;
    v46 = v37 + 8;
  }
  *(_QWORD *)(a1 + 120) = v46;
  *a5 = *(_OWORD *)__p;
  v56 = (std::__shared_weak_count *)v82[1];
  if (v82[1])
  {
    v57 = (unint64_t *)((char *)v82[1] + 8);
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
  if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v86.__r_.__value_.__l.__data_);
  if (SHIBYTE(v88) < 0)
    operator delete((void *)__dst);
}

void sub_20BDF64A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  uint64_t v31;

  sub_20BDDC194((std::exception *)&a19);
  sub_20BDDBE98((uint64_t)&__p);
  if (*(char *)(v31 - 89) < 0)
    operator delete(*(void **)(v31 - 112));
  _Unwind_Resume(a1);
}

uint64_t pxrInternal__aapl__pxrReserved__::Sdf_CreateIdentifier@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  size_t v5;
  size_t v6;
  uint64_t result;
  char *v8;
  const void *v9;
  char *v10;
  const void *v11;

  if (*((char *)a1 + 23) >= 0)
    v5 = *((unsigned __int8 *)a1 + 23);
  else
    v5 = (size_t)a1[1];
  if (*((char *)a2 + 23) >= 0)
    v6 = *((unsigned __int8 *)a2 + 23);
  else
    v6 = (size_t)a2[1];
  result = sub_20BDF6BDC(a3, v6 + v5);
  if (*(char *)(result + 23) >= 0)
    v8 = (char *)result;
  else
    v8 = *(char **)result;
  if (v5)
  {
    if (*((char *)a1 + 23) >= 0)
      v9 = a1;
    else
      v9 = *a1;
    result = (uint64_t)memmove(v8, v9, v5);
  }
  v10 = &v8[v5];
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0)
      v11 = a2;
    else
      v11 = *a2;
    result = (uint64_t)memmove(v10, v11, v6);
  }
  v10[v6] = 0;
  return result;
}

void sub_20BDF66A0(uint64_t a1, uint64_t *a2, Alembic::Util::v12::SpookyHash *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  unint64_t *v20;
  uint64_t v21;
  char *v22;
  char *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  size_t v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  char v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  Alembic::Util::v12::SpookyHash *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  Alembic::Ogawa::v12::OData *v47;
  std::__shared_weak_count *v48;
  _BYTE v49[304];
  uint64_t v50;
  std::__shared_weak_count *v51;
  char *v52;
  char *v53;
  char *v54;
  unint64_t __src;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58[3];

  v58[1] = *MEMORY[0x24BDAC8D0];
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v6 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 40) != v6)
  {
    v7 = 0;
    do
    {
      v8 = *(_QWORD *)(v6 + 16 * v7);
      v9 = a2[1];
      v50 = *a2;
      v51 = (std::__shared_weak_count *)v9;
      if (v9)
      {
        v10 = (unint64_t *)(v9 + 8);
        do
          v11 = __ldxr(v10);
        while (__stxr(v11 + 1, v10));
      }
      sub_20BE014F8((uint64_t)&v52, v8, &v50);
      v12 = v51;
      if (v51)
      {
        p_shared_owners = (unint64_t *)&v51->__shared_owners_;
        do
          v14 = __ldaxr(p_shared_owners);
        while (__stlxr(v14 - 1, p_shared_owners));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      ++v7;
      v6 = *(_QWORD *)(a1 + 32);
    }
    while (v7 < (*(_QWORD *)(a1 + 40) - v6) >> 4);
  }
  Alembic::Util::v12::SpookyHash::Init((uint64_t)v49, 0, 0);
  sub_20BDF19F0(*(_QWORD **)(a1 + 96), (Alembic::Util::v12::SpookyHash *)v49);
  Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)v49, &__src, &v56, v15, v16);
  Alembic::Util::v12::SpookyHash::Init((uint64_t)a3, 0, 0);
  v17 = *(char **)(a1 + 112);
  v18 = *(char **)(a1 + 120);
  if (v17 == v18)
  {
    v57 = 0;
    v58[0] = 0;
  }
  else
  {
    Alembic::Util::v12::SpookyHash::Update(a3, v17, v18 - v17);
    Alembic::Util::v12::SpookyHash::Final(a3, &v57, v58, v19, v20);
  }
  v44 = a3;
  v21 = 0;
  v22 = v53;
  do
  {
    if (v22 >= v54)
    {
      v24 = (unint64_t)v52;
      v25 = v22 - v52;
      v26 = v22 - v52 + 1;
      if (v26 < 0)
        sub_20BDDF694();
      v27 = v54 - v52;
      if (2 * (v54 - v52) > (unint64_t)v26)
        v26 = 2 * v27;
      if (v27 >= 0x3FFFFFFFFFFFFFFFLL)
        v28 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v28 = v26;
      if (v28)
        v29 = (char *)operator new(v28);
      else
        v29 = 0;
      v30 = &v29[v25];
      v31 = &v29[v25];
      *v31 = *((_BYTE *)&__src + v21);
      v23 = v31 + 1;
      if (v22 != (char *)v24)
      {
        v32 = &v22[~v24];
        do
        {
          v33 = *--v22;
          (v32--)[(_QWORD)v29] = v33;
        }
        while (v22 != (char *)v24);
        v22 = v52;
        v30 = v29;
      }
      v52 = v30;
      v53 = v23;
      v54 = &v29[v28];
      if (v22)
        operator delete(v22);
    }
    else
    {
      *v22 = *((_BYTE *)&__src + v21);
      v23 = v22 + 1;
    }
    v53 = v23;
    ++v21;
    v22 = v23;
  }
  while (v21 != 32);
  Alembic::Util::v12::SpookyHash::Update(v44, &__src, 0x10uLL);
  if (v52 != v53)
  {
    Alembic::Ogawa::v12::OGroup::addData(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), v52, v53 - v52, &v47);
    v34 = v48;
    if (v48)
    {
      v35 = (unint64_t *)&v48->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
  }
  v37 = *(_QWORD *)(a1 + 96);
  v38 = a2[1];
  v45 = *a2;
  v46 = (std::__shared_weak_count *)v38;
  if (v38)
  {
    v39 = (unint64_t *)(v38 + 8);
    do
      v40 = __ldxr(v39);
    while (__stxr(v40 + 1, v39));
  }
  sub_20BDF171C(v37, &v45);
  v41 = v46;
  if (v46)
  {
    v42 = (unint64_t *)&v46->__shared_owners_;
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }
  if (v52)
  {
    v53 = v52;
    operator delete(v52);
  }
}

void sub_20BDF69E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  void *v4;
  va_list va;

  va_start(va, a2);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  v4 = *(void **)(v2 - 152);
  if (v4)
  {
    *(_QWORD *)(v2 - 144) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDF6A28(_QWORD *result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *exception;
  _QWORD *v6;
  __int128 __p;
  char v8;
  _QWORD v9[4];
  _BYTE v10[16];
  _QWORD v11[33];

  if (a2 >= (uint64_t)(result[5] - result[4]) >> 4 || (v4 = result[14], 2 * a2 >= (result[15] - v4) >> 3))
  {
    sub_20BDDBD68((uint64_t)v10);
    sub_20BDDC1C8(v11, (uint64_t)"Invalid property index requested in OwData::fillHash", 52);
    std::stringbuf::str();
    sub_20BDDBF20(v9, &__p);
    if (v8 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v6 = sub_20BDDC09C(exception, (uint64_t)v9);
    __cxa_throw(v6, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  *(_QWORD *)(v4 + 16 * a2) = a3;
  *(_QWORD *)(v4 + ((16 * a2) | 8)) = a4;
  return result;
}

void sub_20BDF6AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

char *sub_20BDF6B14(char *__dst, __int128 *a2, __int128 *a3, const void ***a4)
{
  __int128 v7;
  __int128 v8;

  if (*((char *)a2 + 23) < 0)
  {
    sub_20BDDBFAC(__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v7 = *a2;
    *((_QWORD *)__dst + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)__dst = v7;
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_20BDDBFAC(__dst + 24, *(void **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v8 = *a3;
    *((_QWORD *)__dst + 5) = *((_QWORD *)a3 + 2);
    *(_OWORD *)(__dst + 24) = v8;
  }
  sub_20BDEBF8C((uint64_t *)__dst + 6, a4);
  return __dst;
}

void sub_20BDF6BA8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BDF6BDC(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    sub_20BDDC038();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

uint64_t *sub_20BDF6C60(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v6 = (uint64_t **)sub_20BDDE084((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    sub_20BDF6D08((uint64_t)a1, a4, (uint64_t)v10);
    sub_20BDDE1B4(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    sub_20BDF1D7C((uint64_t)v10, 0);
  }
  return v7;
}

_BYTE *sub_20BDF6D08@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _BYTE *result;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = operator new(0x48uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = v6 + 4;
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    result = sub_20BDDBFAC(result, *(void **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    v6[6] = *((_QWORD *)v8 + 2);
    *(_OWORD *)result = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_20BDF6D80(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BDF1D7C(v1, 0);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDF6D98(_QWORD *a1, _QWORD *a2, _QWORD *a3, const void ***a4)
{
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *exception;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19[2];
  char v20;
  void *__p[2];
  char v22;
  __int128 v23;
  _QWORD v24[33];

  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_24C518AC8;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = *a2;
  v7 = a2[1];
  a1[6] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = (char *)operator new(0x48uLL);
  sub_20BDDC0E4(&v23, "ABC");
  sub_20BDDC0E4(__p, "/");
  sub_20BDF6B14(v10, &v23, (__int128 *)__p, a4);
  sub_20BDE9D90(a1 + 7, (uint64_t)v10);
  if (v22 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v24[0]) < 0)
    operator delete((void *)v23);
  a1[9] = *a3;
  v11 = a3[1];
  a1[10] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  a1[11] = 0;
  if (!a1[5])
  {
    sub_20BDDBD68((uint64_t)&v23);
    sub_20BDDC1C8(v24, (uint64_t)"Invalid archive", 15);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v19);
    if (v20 < 0)
      operator delete(v19[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v16 = sub_20BDDC09C(exception, (uint64_t)__p);
    __cxa_throw(v16, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!a1[9])
  {
    sub_20BDDBD68((uint64_t)&v23);
    sub_20BDDC1C8(v24, (uint64_t)"Invalid data", 12);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v19);
    if (v20 < 0)
      operator delete(v19[0]);
    v17 = __cxa_allocate_exception(0x20uLL);
    v18 = sub_20BDDC09C(v17, (uint64_t)__p);
    __cxa_throw(v18, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return a1;
}

void sub_20BDF6FC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  Alembic::AbcCoreAbstract::v12::ObjectWriter *v24;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v25;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v26;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v27;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v28;
  std::__shared_weak_count *v30;

  sub_20BDDC194((std::exception *)&a12);
  sub_20BDDBE98((uint64_t)&__p);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v28);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v27);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v26);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v25);
  v30 = (std::__shared_weak_count *)*((_QWORD *)v24 + 2);
  if (v30)
    std::__shared_weak_count::__release_weak(v30);
  Alembic::AbcCoreAbstract::v12::ObjectWriter::~ObjectWriter(v24);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDF70A4(_QWORD *a1, _QWORD *a2, uint64_t *a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  _QWORD *exception;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  void *__p[2];
  char v37;
  _QWORD v38[4];
  __int128 v39;
  _QWORD v40[33];

  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_24C518AC8;
  a1[3] = *a2;
  v7 = a2[1];
  a1[4] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  a1[5] = 0;
  v10 = a1 + 5;
  a1[6] = 0;
  a1[7] = *a4;
  v11 = a1 + 7;
  v12 = a4[1];
  a1[8] = v12;
  if (v12)
  {
    v13 = (unint64_t *)(v12 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = a5;
  v15 = a1[3];
  if (!v15)
  {
    sub_20BDDBD68((uint64_t)&v39);
    sub_20BDDC1C8(v40, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v38, (__int128 *)__p);
    if (v37 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v29 = sub_20BDDC09C(exception, (uint64_t)v38);
    __cxa_throw(v29, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*v11)
  {
    sub_20BDDBD68((uint64_t)&v39);
    sub_20BDDC1C8(v40, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v38, (__int128 *)__p);
    if (v37 < 0)
      operator delete(__p[0]);
    v30 = __cxa_allocate_exception(0x20uLL);
    v31 = sub_20BDDC09C(v30, (uint64_t)v38);
    __cxa_throw(v31, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v15 + 24))(&v39);
  sub_20BDE82DC((uint64_t)(a1 + 5), &v39);
  v16 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
  if (*((_QWORD *)&v39 + 1))
  {
    v17 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  if (!*v10)
  {
    sub_20BDDBD68((uint64_t)&v39);
    sub_20BDDC1C8(v40, (uint64_t)"Invalid archive", 15);
    std::stringbuf::str();
    sub_20BDDBF20(v38, (__int128 *)__p);
    if (v37 < 0)
      operator delete(__p[0]);
    v32 = __cxa_allocate_exception(0x20uLL);
    v33 = sub_20BDDC09C(v32, (uint64_t)v38);
    __cxa_throw(v33, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v19 = operator new(0x88uLL);
  v20 = v19;
  v21 = (std::__shared_weak_count *)a3[1];
  v34 = *a3;
  v35 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldxr(p_shared_owners);
    while (__stxr(v23 + 1, p_shared_owners));
  }
  sub_20BDF595C(v19, &v34);
  sub_20BDEB324(a1 + 9, v20);
  v24 = v35;
  if (v35)
  {
    v25 = (unint64_t *)&v35->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  return a1;
}

void sub_20BDF73AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  Alembic::AbcCoreAbstract::v12::ObjectWriter *v6;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v7;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v8;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v9;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v10;
  std::__shared_weak_count *v12;
  std::exception v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v13.__vftable = va_arg(va1, std::exception_vtbl *);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v10);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v7);
  v12 = (std::__shared_weak_count *)*((_QWORD *)v6 + 2);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  Alembic::AbcCoreAbstract::v12::ObjectWriter::~ObjectWriter(v6);
  _Unwind_Resume(a1);
}

void sub_20BDF7464(uint64_t a1)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v2;
  void *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  size_t v19;
  _QWORD *p_p;
  uint64_t **v21;
  size_t v22;
  uint64_t v23;
  unint64_t *v24;
  _QWORD **v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t v34;
  unint64_t v35;
  void *__p;
  size_t __n;
  unsigned __int8 v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  _BYTE v41[304];

  *(_QWORD *)a1 = off_24C518AC8;
  v2 = (pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 24);
  if (!*(_QWORD *)(a1 + 24))
    goto LABEL_45;
  v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v8 = *((_QWORD *)v3 + 29);
  v7 = (std::__shared_weak_count *)*((_QWORD *)v3 + 30);
  if (v7)
  {
    v9 = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  if (v4)
  {
    v11 = (unint64_t *)&v4->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  Alembic::Util::v12::SpookyHash::Init((uint64_t)v41, 0, 0);
  v13 = *(_QWORD *)(a1 + 72);
  v39 = v8;
  v40 = v7;
  if (v7)
  {
    v14 = (unint64_t *)&v7->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  sub_20BDF66A0(v13, &v39, (Alembic::Util::v12::SpookyHash *)v41);
  v16 = v40;
  if (v40)
  {
    v17 = (unint64_t *)&v40->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  Alembic::Util::v12::TokenMap::get((Alembic::Util::v12::TokenMap *)(*(_QWORD *)(a1 + 56) + 48), 0x3Bu, 61, 1);
  if ((char)v38 < 0)
  {
    v19 = __n;
    if (__n)
    {
      p_p = __p;
      goto LABEL_26;
    }
  }
  else
  {
    v19 = v38;
    if (v38)
    {
      p_p = &__p;
LABEL_26:
      Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)v41, p_p, v19);
    }
  }
  v21 = *(uint64_t ***)(a1 + 56);
  if (*((char *)v21 + 23) < 0)
  {
    v21 = (uint64_t **)*v21;
    v22 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
  }
  else
  {
    v22 = *((unsigned __int8 *)v21 + 23);
  }
  Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)v41, v21, v22);
  v34 = 0;
  v35 = 0;
  Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)v41, &v35, &v34, v23, v24);
  v26 = *(std::__shared_weak_count **)(a1 + 32);
  if (v26)
  {
    v27 = (unint64_t *)&v26->__shared_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  sub_20BDF6A28(v25[9], *(_QWORD *)(a1 + 88), v35, v34);
  if (v26)
  {
    v29 = (unint64_t *)&v26->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  if ((char)v38 < 0)
    operator delete(__p);
  if (v7)
  {
    v31 = (unint64_t *)&v7->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
LABEL_45:
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 72));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 56));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 40));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v2);
  v33 = *(std::__shared_weak_count **)(a1 + 16);
  if (v33)
    std::__shared_weak_count::__release_weak(v33);
  Alembic::AbcCoreAbstract::v12::ObjectWriter::~ObjectWriter((Alembic::AbcCoreAbstract::v12::ObjectWriter *)a1);
}

void sub_20BDF7724(uint64_t a1)
{
  void *v1;

  sub_20BDF7464(a1);
  operator delete(v1);
}

uint64_t sub_20BDF7738(uint64_t a1)
{
  uint64_t result;
  _QWORD *exception;
  _QWORD *v3;
  __int128 __p;
  char v5;
  _QWORD v6[4];
  _BYTE v7[16];
  _QWORD v8[33];

  result = *(_QWORD *)(a1 + 56);
  if (!result)
  {
    sub_20BDDBD68((uint64_t)v7);
    sub_20BDDC1C8(v8, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v6, &__p);
    if (v5 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v3 = sub_20BDDC09C(exception, (uint64_t)v6);
    __cxa_throw(v3, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return result;
}

void sub_20BDF77D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF77F8@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 48);
  *a2 = *(_QWORD *)(result + 40);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t sub_20BDF781C@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 32);
  *a2 = *(_QWORD *)(result + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void sub_20BDF7840(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  _QWORD *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  v3 = (_QWORD *)a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 88))(&v7);
  sub_20BDF59E0(v3, &v7, a2);
  v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_20BDF78C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDF78D4(uint64_t a1)
{
  return sub_20BDEFF90(*(_QWORD *)(a1 + 72));
}

uint64_t sub_20BDF78DC(uint64_t a1, unint64_t a2)
{
  return sub_20BDF5BD4(*(_QWORD *)(a1 + 72), a2);
}

uint64_t sub_20BDF78E4(uint64_t a1, unsigned __int8 **a2)
{
  return sub_20BDF5D4C(*(_QWORD *)(a1 + 72), a2);
}

void sub_20BDF78EC(uint64_t a1@<X0>, const void **a2@<X1>, _QWORD *a3@<X8>)
{
  sub_20BDF0264(*(_QWORD *)(a1 + 72), a2, a3);
}

void sub_20BDF78F4(_QWORD *a1@<X0>, __int128 *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  v6 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 88))(&v10);
  sub_20BDF5E1C(v6, &v10, (void **)(a1[7] + 24), a2, a3);
  v7 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_20BDF7990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

double sub_20BDF79A4@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_20BDF79DC(Alembic::Ogawa::v12::IData **a1, Alembic::Ogawa::v12::IData **a2, unint64_t a3, int *a4, void **a5)
{
  unint64_t Size;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  void *v16;
  unint64_t v17;
  void *__p;
  _BYTE *v19;

  if (!Alembic::Ogawa::v12::IData::getSize(*a1))
  {
    if (Alembic::Ogawa::v12::IData::getSize(*a2))
    {
      v12 = sub_20BDE00C8(a4);
      if ((unint64_t)Alembic::Ogawa::v12::IData::getSize(*a2) > 0xF)
      {
        if (v12)
        {
          v17 = (Alembic::Ogawa::v12::IData::getSize(*a2) - 16) / v12;
          sub_20BDE8894(&__p, 1uLL, &v17);
          if (&__p != a5)
            goto LABEL_21;
        }
        else
        {
          v17 = 0;
          sub_20BDE8894(&__p, 1uLL, &v17);
          if (&__p != a5)
LABEL_21:
            sub_20BDDF7E4((char *)a5, (char *)__p, (uint64_t)v19, (v19 - (_BYTE *)__p) >> 3);
        }
      }
      else
      {
        v17 = 0;
        sub_20BDE8894(&__p, 1uLL, &v17);
        if (&__p != a5)
          goto LABEL_21;
      }
    }
    else
    {
      v17 = 0;
      sub_20BDE8894(&__p, 1uLL, &v17);
      if (&__p != a5)
        goto LABEL_21;
    }
    v16 = __p;
    if (!__p)
      return;
    v19 = __p;
    goto LABEL_24;
  }
  Size = Alembic::Ogawa::v12::IData::getSize(*a1);
  sub_20BDF7C0C(a5, Size >> 3);
  sub_20BDE3C3C(&__p, Size >> 3);
  v11 = __p;
  if (__p != v19)
  {
    Alembic::Ogawa::v12::IData::read((unint64_t **)*a1, Size & 0xFFFFFFFFFFFFFFF8, __p, 0, a3);
    v11 = __p;
    if (Size >= 8)
    {
      v13 = 0;
      v14 = *a5;
      if (Size >> 3 <= 1)
        v15 = 1;
      else
        v15 = Size >> 3;
      do
      {
        v14[v13] = v11[v13];
        ++v13;
      }
      while (v15 != v13);
      goto LABEL_14;
    }
  }
  if (v11)
  {
LABEL_14:
    v19 = v11;
    v16 = v11;
LABEL_24:
    operator delete(v16);
  }
}

void sub_20BDF7BE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_20BDF7C0C(_QWORD *a1, unint64_t a2)
{
  uint64_t v4;

  v4 = a1[1] - *a1;
  sub_20BDFC880((uint64_t)a1, a2);
  if (a2 > v4 >> 3)
    bzero((void *)(*a1 + (v4 & 0xFFFFFFFFFFFFFFF8)), 8 * a2 - (v4 & 0xFFFFFFFFFFFFFFF8));
}

__n64 sub_20BDF7C6C(int a1, int a2, int *a3, char *a4, unint64_t a5, __n64 result)
{
  int v6;
  int v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  double v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  float v23;
  unint64_t v24;
  char v25;
  unint64_t v26;
  unint64_t v27;
  char v28;
  unint64_t v29;
  unint64_t v30;
  __int16 v31;
  unint64_t v32;
  unint64_t v33;
  __int16 v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  int v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char v45;
  unsigned int v46;
  unint64_t v47;
  char v48;
  unsigned int v49;
  unint64_t v50;
  __int16 v51;
  unsigned int v52;
  unint64_t v53;
  __int16 v54;
  unsigned int v55;
  unint64_t v56;
  unsigned int v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  int64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  float v81;
  double v82;
  unsigned int v83;
  unint64_t v84;
  char v85;
  unsigned int v86;
  unint64_t v87;
  char v88;
  unsigned int v89;
  unint64_t v90;
  unsigned int v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  int v115;
  int v116;
  unint64_t v117;
  int v118;
  int v119;
  unint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  double v129;
  unint64_t v130;
  double v131;
  unint64_t v132;
  double v133;
  unint64_t v134;
  double v135;
  unint64_t v136;
  double v137;
  float v138;
  unint64_t v139;
  float v140;
  unint64_t v141;
  float v142;
  unint64_t v143;
  float v144;
  unint64_t v145;
  float v146;
  unint64_t v147;
  float v148;
  float v149;

  switch(a1)
  {
    case 0:
      switch(a2)
      {
        case 1:
          for (; a5; --a5)
            a4[a5 - 1] = *((_BYTE *)a3 + a5 - 1) != 0;
          break;
        case 2:
          for (; a5; --a5)
            a4[a5 - 1] = *((_BYTE *)a3 + a5 - 1) != 0;
          break;
        case 3:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((_BYTE *)a3 + a5 - 1) != 0;
          break;
        case 4:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((_BYTE *)a3 + a5 - 1) != 0;
          break;
        case 5:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((_BYTE *)a3 + a5 - 1) != 0;
          break;
        case 6:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((_BYTE *)a3 + a5 - 1) != 0;
          break;
        case 7:
          for (; a5; --a5)
            *(_QWORD *)&a4[8 * a5 - 8] = *((_BYTE *)a3 + a5 - 1) != 0;
          break;
        case 8:
          for (; a5; --a5)
            *(_QWORD *)&a4[8 * a5 - 8] = *((_BYTE *)a3 + a5 - 1) != 0;
          break;
        case 9:
          sub_20BDF923C((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 10:
          if (a5)
          {
            result.n64_u32[0] = 0;
            do
            {
              if (*((_BYTE *)a3 + a5 - 1))
                v81 = 1.0;
              else
                v81 = 0.0;
              *(float *)&a4[4 * a5-- - 4] = v81;
            }
            while (a5);
          }
          break;
        case 11:
          if (a5)
          {
            result.n64_f64[0] = 0.0;
            do
            {
              if (*((_BYTE *)a3 + a5 - 1))
                v82 = 1.0;
              else
                v82 = 0.0;
              *(double *)&a4[8 * a5-- - 8] = v82;
            }
            while (a5);
          }
          break;
        default:
          return result;
      }
      break;
    case 1:
      switch(a2)
      {
        case 0:
          for (; a5; --a5)
          {
            v6 = *(unsigned __int8 *)a3;
            a3 = (int *)((char *)a3 + 1);
            *a4++ = v6 != 0;
          }
          break;
        case 2:
          for (; a5; --a5)
          {
            v83 = *((unsigned __int8 *)a3 + a5 - 1);
            if (v83 >= 0x7F)
              LOBYTE(v83) = 127;
            a4[a5 - 1] = v83;
          }
          break;
        case 3:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 4:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 5:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 6:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 7:
          for (; a5; --a5)
            *(_QWORD *)&a4[8 * a5 - 8] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 8:
          for (; a5; --a5)
            *(_QWORD *)&a4[8 * a5 - 8] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 9:
          sub_20BDF933C((uint64_t)a3, (uint64_t)a4, a5, result.n64_f32[0]);
          break;
        case 10:
          for (; a5; --a5)
          {
            result.n64_u8[0] = *((_BYTE *)a3 + a5 - 1);
            result.n64_f32[0] = (float)result.n64_u32[0];
            *(_DWORD *)&a4[4 * a5 - 4] = result.n64_u32[0];
          }
          break;
        case 11:
          for (; a5; --a5)
          {
            result.n64_u8[0] = *((_BYTE *)a3 + a5 - 1);
            result.n64_f64[0] = (double)result.n64_u64[0];
            *(double *)&a4[8 * a5 - 8] = result.n64_f64[0];
          }
          break;
        default:
          return result;
      }
      break;
    case 2:
      switch(a2)
      {
        case 0:
          for (; a5; --a5)
          {
            v7 = *(unsigned __int8 *)a3;
            a3 = (int *)((char *)a3 + 1);
            *a4++ = v7 != 0;
          }
          break;
        case 1:
          for (; a5; --a5)
            a4[a5 - 1] = *((_BYTE *)a3 + a5 - 1) & ~(*((char *)a3 + a5 - 1) >> 31);
          break;
        case 3:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((char *)a3 + a5 - 1) & (unsigned __int16)~(unsigned __int16)(*((char *)a3 + a5 - 1) >> 31);
          break;
        case 4:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((char *)a3 + a5 - 1);
          break;
        case 5:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((char *)a3 + a5 - 1) & ~(*((char *)a3 + a5 - 1) >> 31);
          break;
        case 6:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((char *)a3 + a5 - 1);
          break;
        case 7:
          for (; a5; --a5)
            *(_QWORD *)&a4[8 * a5 - 8] = *((char *)a3 + a5 - 1) & ~(*((char *)a3 + a5 - 1) >> 31);
          break;
        case 8:
          for (; a5; --a5)
            *(_QWORD *)&a4[8 * a5 - 8] = *((char *)a3 + a5 - 1);
          break;
        case 9:
          sub_20BDF9434((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 10:
          for (; a5; --a5)
          {
            result.n64_f32[0] = (float)*((char *)a3 + a5 - 1);
            *(float *)&a4[4 * a5 - 4] = result.n64_f32[0];
          }
          break;
        case 11:
          for (; a5; --a5)
          {
            result.n64_f64[0] = (double)*((char *)a3 + a5 - 1);
            *(double *)&a4[8 * a5 - 8] = result.n64_f64[0];
          }
          break;
        default:
          return result;
      }
      break;
    case 3:
      switch(a2)
      {
        case 0:
          if (a5 >= 2)
          {
            v8 = a5 >> 1;
            do
            {
              v9 = *(unsigned __int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              *a4++ = v9 != 0;
              --v8;
            }
            while (v8);
          }
          break;
        case 1:
          if (a5 >= 2)
          {
            v84 = a5 >> 1;
            do
            {
              v86 = *(unsigned __int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              v85 = v86;
              if (v86 >= 0xFF)
                v85 = -1;
              *a4++ = v85;
              --v84;
            }
            while (v84);
          }
          break;
        case 2:
          if (a5 >= 2)
          {
            v87 = a5 >> 1;
            do
            {
              v89 = *(unsigned __int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              v88 = v89;
              if (v89 >= 0x7F)
                v88 = 127;
              *a4++ = v88;
              --v87;
            }
            while (v87);
          }
          break;
        case 4:
          if (a5 >= 2)
          {
            v90 = a5 >> 1;
            do
            {
              v91 = *((unsigned __int16 *)a3 + v90 - 1);
              if (v91 >= 0x7FFF)
                LOWORD(v91) = 0x7FFF;
              *(_WORD *)&a4[2 * v90-- - 2] = v91;
            }
            while (v90);
          }
          break;
        case 5:
          if (a5 >= 2)
          {
            v92 = a5 >> 1;
            do
            {
              *(_DWORD *)&a4[4 * v92 - 4] = *((unsigned __int16 *)a3 + v92 - 1);
              --v92;
            }
            while (v92);
          }
          break;
        case 6:
          if (a5 >= 2)
          {
            v93 = a5 >> 1;
            do
            {
              *(_DWORD *)&a4[4 * v93 - 4] = *((unsigned __int16 *)a3 + v93 - 1);
              --v93;
            }
            while (v93);
          }
          break;
        case 7:
          if (a5 >= 2)
          {
            v94 = a5 >> 1;
            do
            {
              *(_QWORD *)&a4[8 * v94 - 8] = *((unsigned __int16 *)a3 + v94 - 1);
              --v94;
            }
            while (v94);
          }
          break;
        case 8:
          if (a5 >= 2)
          {
            v95 = a5 >> 1;
            do
            {
              *(_QWORD *)&a4[8 * v95 - 8] = *((unsigned __int16 *)a3 + v95 - 1);
              --v95;
            }
            while (v95);
          }
          break;
        case 9:
          sub_20BDF952C((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 10:
          if (a5 >= 2)
          {
            v96 = a5 >> 1;
            do
            {
              result.n64_u16[0] = *((_WORD *)a3 + v96 - 1);
              result.n64_f32[0] = (float)result.n64_u32[0];
              *(_DWORD *)&a4[4 * v96-- - 4] = result.n64_u32[0];
            }
            while (v96);
          }
          break;
        case 11:
          if (a5 >= 2)
          {
            v97 = a5 >> 1;
            do
            {
              result.n64_u16[0] = *((_WORD *)a3 + v97 - 1);
              result.n64_f64[0] = (double)result.n64_u64[0];
              *(double *)&a4[8 * v97-- - 8] = result.n64_f64[0];
            }
            while (v97);
          }
          break;
        default:
          return result;
      }
      break;
    case 4:
      switch(a2)
      {
        case 0:
          if (a5 >= 2)
          {
            v10 = a5 >> 1;
            do
            {
              v11 = *(unsigned __int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              *a4++ = v11 != 0;
              --v10;
            }
            while (v10);
          }
          break;
        case 1:
          if (a5 >= 2)
          {
            v98 = a5 >> 1;
            do
            {
              v100 = *(__int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              v99 = v100;
              if (v100 >= 255)
                v99 = 255;
              *a4++ = v99 & ~(v99 >> 31);
              --v98;
            }
            while (v98);
          }
          break;
        case 2:
          if (a5 >= 2)
          {
            v101 = a5 >> 1;
            do
            {
              v103 = *(__int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              v102 = v103;
              if (v103 >= 127)
                v102 = 127;
              if (v102 <= -128)
                LOBYTE(v102) = 0x80;
              *a4++ = v102;
              --v101;
            }
            while (v101);
          }
          break;
        case 3:
          if (a5 >= 2)
          {
            v104 = a5 >> 1;
            do
            {
              *(_WORD *)&a4[2 * v104 - 2] = *((_WORD *)a3 + v104 - 1) & ~(*((__int16 *)a3 + v104 - 1) >> 15);
              --v104;
            }
            while (v104);
          }
          break;
        case 5:
          if (a5 >= 2)
          {
            v105 = a5 >> 1;
            do
            {
              *(_DWORD *)&a4[4 * v105 - 4] = *((__int16 *)a3 + v105 - 1) & ~(*((__int16 *)a3 + v105 - 1) >> 31);
              --v105;
            }
            while (v105);
          }
          break;
        case 6:
          if (a5 >= 2)
          {
            v106 = a5 >> 1;
            do
            {
              *(_DWORD *)&a4[4 * v106 - 4] = *((__int16 *)a3 + v106 - 1);
              --v106;
            }
            while (v106);
          }
          break;
        case 7:
          if (a5 >= 2)
          {
            v107 = a5 >> 1;
            do
            {
              *(_QWORD *)&a4[8 * v107 - 8] = *((__int16 *)a3 + v107 - 1) & ~(*((__int16 *)a3 + v107 - 1) >> 31);
              --v107;
            }
            while (v107);
          }
          break;
        case 8:
          if (a5 >= 2)
          {
            v108 = a5 >> 1;
            do
            {
              *(_QWORD *)&a4[8 * v108 - 8] = *((__int16 *)a3 + v108 - 1);
              --v108;
            }
            while (v108);
          }
          break;
        case 9:
          sub_20BDF9638((unint64_t)a3, (uint64_t)a4, a5);
          break;
        case 10:
          if (a5 >= 2)
          {
            v109 = a5 >> 1;
            do
            {
              result.n64_f32[0] = (float)*((__int16 *)a3 + v109 - 1);
              *(float *)&a4[4 * v109-- - 4] = result.n64_f32[0];
            }
            while (v109);
          }
          break;
        case 11:
          if (a5 >= 2)
          {
            v110 = a5 >> 1;
            do
            {
              result.n64_f64[0] = (double)*((__int16 *)a3 + v110 - 1);
              *(double *)&a4[8 * v110-- - 8] = result.n64_f64[0];
            }
            while (v110);
          }
          break;
        default:
          return result;
      }
      break;
    case 5:
      switch(a2)
      {
        case 0:
          if (a5 >= 4)
          {
            v12 = a5 >> 2;
            do
            {
              v13 = *a3++;
              *a4++ = v13 != 0;
              --v12;
            }
            while (v12);
          }
          break;
        case 1:
          if (a5 >= 4)
          {
            v44 = a5 >> 2;
            do
            {
              v46 = *a3++;
              v45 = v46;
              if (v46 >= 0xFF)
                v45 = -1;
              *a4++ = v45;
              --v44;
            }
            while (v44);
          }
          break;
        case 2:
          if (a5 >= 4)
          {
            v47 = a5 >> 2;
            do
            {
              v49 = *a3++;
              v48 = v49;
              if (v49 >= 0x7F)
                v48 = 127;
              *a4++ = v48;
              --v47;
            }
            while (v47);
          }
          break;
        case 3:
          if (a5 >= 4)
          {
            v50 = a5 >> 2;
            do
            {
              v52 = *a3++;
              v51 = v52;
              if (v52 >= 0xFFFF)
                v51 = -1;
              *(_WORD *)a4 = v51;
              a4 += 2;
              --v50;
            }
            while (v50);
          }
          break;
        case 4:
          if (a5 >= 4)
          {
            v53 = a5 >> 2;
            do
            {
              v55 = *a3++;
              v54 = v55;
              if (v55 >= 0x7FFF)
                v54 = 0x7FFF;
              *(_WORD *)a4 = v54;
              a4 += 2;
              --v53;
            }
            while (v53);
          }
          break;
        case 6:
          if (a5 >= 4)
          {
            v56 = a5 >> 2;
            do
            {
              v57 = a3[v56 - 1];
              if (v57 >= 0x7FFFFFFF)
                v57 = 0x7FFFFFFF;
              *(_DWORD *)&a4[4 * v56-- - 4] = v57;
            }
            while (v56);
          }
          break;
        case 7:
          if (a5 >= 4)
          {
            v58 = a5 >> 2;
            do
            {
              *(_QWORD *)&a4[8 * v58 - 8] = a3[v58 - 1];
              --v58;
            }
            while (v58);
          }
          break;
        case 8:
          if (a5 >= 4)
          {
            v59 = a5 >> 2;
            do
            {
              *(_QWORD *)&a4[8 * v59 - 8] = a3[v59 - 1];
              --v59;
            }
            while (v59);
          }
          break;
        case 9:
          if (a5 >= 4)
          {
            while (1)
              ;
          }
          break;
        case 11:
          if (a5 >= 4)
          {
            v60 = a5 >> 2;
            do
            {
              result.n64_u32[0] = a3[v60 - 1];
              result.n64_f64[0] = (double)result.n64_u64[0];
              *(double *)&a4[8 * v60-- - 8] = result.n64_f64[0];
            }
            while (v60);
          }
          break;
        default:
          return result;
      }
      break;
    case 6:
      switch(a2)
      {
        case 0:
          if (a5 >= 4)
          {
            v14 = a5 >> 2;
            do
            {
              v15 = *a3++;
              *a4++ = v15 != 0;
              --v14;
            }
            while (v14);
          }
          break;
        case 1:
          if (a5 >= 4)
          {
            v111 = a5 >> 2;
            do
            {
              v113 = *a3++;
              v112 = v113;
              if (v113 >= 255)
                v112 = 255;
              *a4++ = v112 & ~(v112 >> 31);
              --v111;
            }
            while (v111);
          }
          break;
        case 2:
          if (a5 >= 4)
          {
            v114 = a5 >> 2;
            do
            {
              v116 = *a3++;
              v115 = v116;
              if (v116 >= 127)
                v115 = 127;
              if (v115 <= -128)
                LOBYTE(v115) = 0x80;
              *a4++ = v115;
              --v114;
            }
            while (v114);
          }
          break;
        case 3:
          if (a5 >= 4)
          {
            v117 = a5 >> 2;
            do
            {
              v119 = *a3++;
              v118 = v119;
              if (v119 >= 0xFFFF)
                v118 = 0xFFFF;
              *(_WORD *)a4 = v118 & ~(unsigned __int16)(v118 >> 31);
              a4 += 2;
              --v117;
            }
            while (v117);
          }
          break;
        case 4:
          if (a5 >= 4)
          {
            v120 = a5 >> 2;
            do
            {
              v122 = *a3++;
              v121 = v122;
              if (v122 >= 0x7FFF)
                v121 = 0x7FFF;
              if (v121 <= -32768)
                LOWORD(v121) = 0x8000;
              *(_WORD *)a4 = v121;
              a4 += 2;
              --v120;
            }
            while (v120);
          }
          break;
        case 5:
          if (a5 >= 4)
          {
            v123 = a5 >> 2;
            do
            {
              *(_DWORD *)&a4[4 * v123 - 4] = a3[v123 - 1] & ~(a3[v123 - 1] >> 31);
              --v123;
            }
            while (v123);
          }
          break;
        case 7:
          if (a5 >= 4)
          {
            v124 = a5 >> 2;
            do
            {
              *(_QWORD *)&a4[8 * v124 - 8] = a3[v124 - 1] & ~(a3[v124 - 1] >> 31);
              --v124;
            }
            while (v124);
          }
          break;
        case 8:
          if (a5 >= 4)
          {
            v125 = a5 >> 2;
            do
            {
              *(_QWORD *)&a4[8 * v125 - 8] = a3[v125 - 1];
              --v125;
            }
            while (v125);
          }
          break;
        case 9:
          sub_20BDF9738(a3, a4, a5);
          break;
        case 10:
          if (a5 >= 4)
          {
            v126 = a5 >> 2;
            do
            {
              result.n64_f32[0] = (float)a3[v126 - 1];
              *(_DWORD *)&a4[4 * v126-- - 4] = result.n64_u32[0];
            }
            while (v126);
          }
          break;
        case 11:
          if (a5 >= 4)
          {
            v127 = a5 >> 2;
            do
            {
              result.n64_f64[0] = (double)a3[v127 - 1];
              *(double *)&a4[8 * v127-- - 8] = result.n64_f64[0];
            }
            while (v127);
          }
          break;
        default:
          return result;
      }
      break;
    case 7:
      switch(a2)
      {
        case 0:
          if (a5 >= 8)
          {
            v16 = a5 >> 3;
            do
            {
              v17 = *(_QWORD *)a3;
              a3 += 2;
              *a4++ = v17 != 0;
              --v16;
            }
            while (v16);
          }
          break;
        case 1:
          if (a5 >= 8)
          {
            v24 = a5 >> 3;
            do
            {
              v26 = *(_QWORD *)a3;
              a3 += 2;
              v25 = v26;
              if (v26 >= 0xFF)
                v25 = -1;
              *a4++ = v25;
              --v24;
            }
            while (v24);
          }
          break;
        case 2:
          if (a5 >= 8)
          {
            v27 = a5 >> 3;
            do
            {
              v29 = *(_QWORD *)a3;
              a3 += 2;
              v28 = v29;
              if (v29 >= 0x7F)
                v28 = 127;
              *a4++ = v28;
              --v27;
            }
            while (v27);
          }
          break;
        case 3:
          if (a5 >= 8)
          {
            v30 = a5 >> 3;
            do
            {
              v32 = *(_QWORD *)a3;
              a3 += 2;
              v31 = v32;
              if (v32 >= 0xFFFF)
                v31 = -1;
              *(_WORD *)a4 = v31;
              a4 += 2;
              --v30;
            }
            while (v30);
          }
          break;
        case 4:
          if (a5 >= 8)
          {
            v33 = a5 >> 3;
            do
            {
              v35 = *(_QWORD *)a3;
              a3 += 2;
              v34 = v35;
              if (v35 >= 0x7FFF)
                v34 = 0x7FFF;
              *(_WORD *)a4 = v34;
              a4 += 2;
              --v33;
            }
            while (v33);
          }
          break;
        case 5:
          if (a5 >= 8)
          {
            v36 = a5 >> 3;
            do
            {
              v38 = *(_QWORD *)a3;
              a3 += 2;
              v37 = v38;
              if (v38 >= 0xFFFFFFFF)
                v37 = -1;
              *(_DWORD *)a4 = v37;
              a4 += 4;
              --v36;
            }
            while (v36);
          }
          break;
        case 6:
          if (a5 >= 8)
          {
            v39 = a5 >> 3;
            do
            {
              v41 = *(_QWORD *)a3;
              a3 += 2;
              v40 = v41;
              if (v41 >= 0x7FFFFFFF)
                v40 = 0x7FFFFFFF;
              *(_DWORD *)a4 = v40;
              a4 += 4;
              --v39;
            }
            while (v39);
          }
          break;
        case 8:
          if (a5 >= 8)
          {
            v42 = a5 >> 3;
            do
            {
              v43 = *(_QWORD *)&a3[2 * v42 - 2];
              if (v43 >= 0x7FFFFFFFFFFFFFFFLL)
                v43 = 0x7FFFFFFFFFFFFFFFLL;
              *(_QWORD *)&a4[8 * v42-- - 8] = v43;
            }
            while (v42);
          }
          break;
        case 9:
          if (a5 >= 8)
          {
            while (1)
              ;
          }
          break;
        default:
          return result;
      }
      break;
    case 8:
      switch(a2)
      {
        case 0:
          if (a5 >= 8)
          {
            v20 = a5 >> 3;
            do
            {
              v21 = *(_QWORD *)a3;
              a3 += 2;
              *a4++ = v21 != 0;
              --v20;
            }
            while (v20);
          }
          break;
        case 1:
          if (a5 >= 8)
          {
            v61 = a5 >> 3;
            do
            {
              v63 = *(_QWORD *)a3;
              a3 += 2;
              v62 = v63;
              if (v63 >= 255)
                v62 = 255;
              *a4++ = v62 & ~(v62 >> 63);
              --v61;
            }
            while (v61);
          }
          break;
        case 2:
          if (a5 >= 8)
          {
            v64 = a5 >> 3;
            do
            {
              v66 = *(_QWORD *)a3;
              a3 += 2;
              v65 = v66;
              if (v66 >= 127)
                v65 = 127;
              if (v65 <= -128)
                LOBYTE(v65) = 0x80;
              *a4++ = v65;
              --v64;
            }
            while (v64);
          }
          break;
        case 3:
          if (a5 >= 8)
          {
            v67 = a5 >> 3;
            do
            {
              v69 = *(_QWORD *)a3;
              a3 += 2;
              v68 = v69;
              if (v69 >= 0xFFFF)
                v68 = 0xFFFFLL;
              *(_WORD *)a4 = v68 & ~(unsigned __int16)(v68 >> 63);
              a4 += 2;
              --v67;
            }
            while (v67);
          }
          break;
        case 4:
          if (a5 >= 8)
          {
            v70 = a5 >> 3;
            do
            {
              v72 = *(_QWORD *)a3;
              a3 += 2;
              v71 = v72;
              if (v72 >= 0x7FFF)
                v71 = 0x7FFFLL;
              if (v71 <= -32768)
                LOWORD(v71) = 0x8000;
              *(_WORD *)a4 = v71;
              a4 += 2;
              --v70;
            }
            while (v70);
          }
          break;
        case 5:
          if (a5 >= 8)
          {
            v73 = a5 >> 3;
            do
            {
              v75 = *(_QWORD *)a3;
              a3 += 2;
              v74 = v75;
              if (v75 >= 0xFFFFFFFFLL)
                v74 = 0xFFFFFFFFLL;
              *(_DWORD *)a4 = v74 & ~(v74 >> 63);
              a4 += 4;
              --v73;
            }
            while (v73);
          }
          break;
        case 6:
          if (a5 >= 8)
          {
            v76 = a5 >> 3;
            do
            {
              v78 = *(_QWORD *)a3;
              a3 += 2;
              v77 = v78;
              if (v78 >= 0x7FFFFFFF)
                v77 = 0x7FFFFFFFLL;
              if (v77 <= (uint64_t)0xFFFFFFFF80000000)
                LODWORD(v77) = 0x80000000;
              *(_DWORD *)a4 = v77;
              a4 += 4;
              --v76;
            }
            while (v76);
          }
          break;
        case 7:
          if (a5 >= 8)
          {
            v79 = a5 >> 3;
            do
            {
              *(_QWORD *)&a4[8 * v79 - 8] = *(_QWORD *)&a3[2 * v79 - 2] & ~(*(uint64_t *)&a3[2 * v79 - 2] >> 63);
              --v79;
            }
            while (v79);
          }
          break;
        case 9:
          sub_20BDF9844((uint64_t *)a3, a4, a5);
          break;
        case 11:
          if (a5 >= 8)
          {
            v80 = a5 >> 3;
            do
            {
              result.n64_f64[0] = (double)*(uint64_t *)&a3[2 * v80 - 2];
              *(double *)&a4[8 * v80-- - 8] = result.n64_f64[0];
            }
            while (v80);
          }
          break;
        default:
          return result;
      }
      break;
    case 9:
      switch(a2)
      {
        case 0:
          sub_20BDF9950((unsigned __int16 *)a3, (BOOL *)a4, a5);
          break;
        case 1:
          result.n64_f32[0] = sub_20BDF99C8((__int16 *)a3, a4, a5);
          break;
        case 2:
          sub_20BDF9AC0((__int16 *)a3, a4, a5);
          break;
        case 3:
          sub_20BDF9BBC((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 4:
          sub_20BDF9CC4((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 5:
          sub_20BDF9DF0((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 6:
          sub_20BDF9EF8((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 7:
          sub_20BDFA00C((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 8:
          sub_20BDFA114((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 10:
          sub_20BDFA228((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 11:
          sub_20BDFA334((uint64_t)a3, (uint64_t)a4, a5);
          break;
        default:
          return result;
      }
      break;
    case 10:
      switch(a2)
      {
        case 0:
          if (a5 >= 4)
          {
            v22 = a5 >> 2;
            do
            {
              v23 = *(float *)a3++;
              result.n64_f32[0] = v23;
              *a4++ = v23 != 0.0;
              --v22;
            }
            while (v22);
          }
          break;
        case 1:
          sub_20BDFA448((float *)a3, a4, a5);
          break;
        case 2:
          sub_20BDFA498((float *)a3, a4, a5);
          break;
        case 3:
          sub_20BDFA4E8((float *)a3, a4, a5);
          break;
        case 4:
          sub_20BDFA534((float *)a3, a4, a5);
          break;
        case 5:
          if (a5 >= 4)
          {
            v139 = a5 >> 2;
            do
            {
              v140 = *(float *)&a3[v139 - 1];
              result.n64_u32[0] = 0;
              if (v140 >= 0.0)
              {
                result.n64_u32[0] = a3[v139 - 1];
                if (v140 > 3.4028e38)
                  result.n64_u32[0] = 2139095039;
              }
              *(_DWORD *)&a4[4 * v139-- - 4] = result.n64_f32[0];
            }
            while (v139);
          }
          break;
        case 6:
          if (a5 >= 4)
          {
            v141 = a5 >> 2;
            do
            {
              v142 = *(float *)&a3[v141 - 1];
              result.n64_u32[0] = -8388609;
              if (v142 >= -3.4028e38)
              {
                result.n64_u32[0] = a3[v141 - 1];
                if (v142 > 3.4028e38)
                  result.n64_u32[0] = 2139095039;
              }
              *(_DWORD *)&a4[4 * v141-- - 4] = (int)result.n64_f32[0];
            }
            while (v141);
          }
          break;
        case 7:
          if (a5 >= 4)
          {
            v143 = a5 >> 2;
            do
            {
              v144 = *(float *)&a3[v143 - 1];
              result.n64_u32[0] = 0;
              if (v144 >= 0.0)
              {
                result.n64_u32[0] = a3[v143 - 1];
                if (v144 > 3.4028e38)
                  result.n64_u32[0] = 2139095039;
              }
              *(_QWORD *)&a4[8 * v143-- - 8] = (unint64_t)result.n64_f32[0];
            }
            while (v143);
          }
          break;
        case 8:
          if (a5 >= 4)
          {
            v145 = a5 >> 2;
            do
            {
              v146 = *(float *)&a3[v145 - 1];
              result.n64_u32[0] = -8388609;
              if (v146 >= -3.4028e38)
              {
                result.n64_u32[0] = a3[v145 - 1];
                if (v146 > 3.4028e38)
                  result.n64_u32[0] = 2139095039;
              }
              *(_QWORD *)&a4[8 * v145-- - 8] = (uint64_t)result.n64_f32[0];
            }
            while (v145);
          }
          break;
        case 9:
          sub_20BDFA580((float *)a3, a4, a5);
          break;
        case 11:
          if (a5 >= 4)
          {
            v147 = a5 >> 2;
            do
            {
              v148 = *(float *)&a3[v147 - 1];
              v149 = -3.4028e38;
              if (v148 >= -3.4028e38)
              {
                v149 = *(float *)&a3[v147 - 1];
                if (v148 > 3.4028e38)
                  v149 = 3.4028e38;
              }
              result.n64_f64[0] = v149;
              *(double *)&a4[8 * v147-- - 8] = result.n64_f64[0];
            }
            while (v147);
          }
          break;
        default:
          return result;
      }
      break;
    case 11:
      switch(a2)
      {
        case 0:
          if (a5 >= 8)
          {
            v18 = a5 >> 3;
            do
            {
              v19 = *(double *)a3;
              a3 += 2;
              result.n64_f64[0] = v19;
              *a4++ = v19 != 0.0;
              --v18;
            }
            while (v18);
          }
          break;
        case 1:
          sub_20BDFA6A0((double *)a3, a4, a5);
          break;
        case 2:
          sub_20BDFA6EC((double *)a3, a4, a5);
          break;
        case 3:
          sub_20BDFA73C((double *)a3, a4, a5);
          break;
        case 4:
          sub_20BDFA788((double *)a3, a4, a5);
          break;
        case 5:
          if (a5 >= 8)
          {
            v128 = a5 >> 3;
            result.n64_f64[0] = 4294967300.0;
            do
            {
              v129 = 0.0;
              if (*(double *)a3 >= 0.0)
              {
                v129 = *(double *)a3;
                if (*(double *)a3 > 4294967300.0)
                  v129 = 4294967300.0;
              }
              *(_DWORD *)a4 = v129;
              a4 += 4;
              a3 += 2;
              --v128;
            }
            while (v128);
          }
          break;
        case 6:
          if (a5 >= 8)
          {
            v130 = a5 >> 3;
            result.n64_f64[0] = 2147483650.0;
            do
            {
              v131 = -2147483650.0;
              if (*(double *)a3 >= -2147483650.0)
              {
                v131 = *(double *)a3;
                if (*(double *)a3 > 2147483650.0)
                  v131 = 2147483650.0;
              }
              *(_DWORD *)a4 = (int)v131;
              a4 += 4;
              a3 += 2;
              --v130;
            }
            while (v130);
          }
          break;
        case 7:
          if (a5 >= 8)
          {
            v132 = a5 >> 3;
            do
            {
              v133 = *(double *)&a3[2 * v132 - 2];
              result.n64_f64[0] = 0.0;
              if (v133 >= 0.0)
              {
                result.n64_u64[0] = *(unint64_t *)&a3[2 * v132 - 2];
                if (v133 > 1.79769313e308)
                  result.n64_f64[0] = 1.79769313e308;
              }
              *(_QWORD *)&a4[8 * v132-- - 8] = (unint64_t)result.n64_f64[0];
            }
            while (v132);
          }
          break;
        case 8:
          if (a5 >= 8)
          {
            v134 = a5 >> 3;
            do
            {
              v135 = *(double *)&a3[2 * v134 - 2];
              result.n64_f64[0] = -1.79769313e308;
              if (v135 >= -1.79769313e308)
              {
                result.n64_u64[0] = *(unint64_t *)&a3[2 * v134 - 2];
                if (v135 > 1.79769313e308)
                  result.n64_f64[0] = 1.79769313e308;
              }
              *(_QWORD *)&a4[8 * v134-- - 8] = (uint64_t)result.n64_f64[0];
            }
            while (v134);
          }
          break;
        case 9:
          sub_20BDFA7D8((double *)a3, a4, a5);
          break;
        case 10:
          if (a5 >= 8)
          {
            v136 = a5 >> 3;
            result.n64_f64[0] = -3.40282347e38;
            do
            {
              v137 = -3.40282347e38;
              if (*(double *)a3 >= -3.40282347e38)
              {
                v137 = *(double *)a3;
                if (*(double *)a3 > 3.40282347e38)
                  v137 = 3.40282347e38;
              }
              v138 = v137;
              *(float *)a4 = v138;
              a4 += 4;
              a3 += 2;
              --v136;
            }
            while (v136);
          }
          break;
        default:
          return result;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_20BDF923C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  float v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;

  if (a3)
  {
    v3 = result - 1;
    do
    {
      if (*(_BYTE *)(v3 + a3))
        v4 = 1.0;
      else
        v4 = 0.0;
      result = LODWORD(v4);
      v5 = LODWORD(v4) >> 23;
      if (LODWORD(v4) >> 23 < 0x71)
      {
        if (LODWORD(v4) >= 0x33000001)
        {
          v7 = LODWORD(v4) & 0x7FFFFF | 0x800000;
          result = v7 << (v5 - 94);
          v6 = v7 >> (126 - (LODWORD(v4) >> 23));
          if (result > 0x80000000
            || ((_DWORD)result == 0x80000000 ? (v8 = ((v7 >> (126 - (LODWORD(v4) >> 23))) & 1) == 0) : (v8 = 1), !v8))
          {
            LOWORD(v6) = v6 + 1;
          }
        }
        else
        {
          LOWORD(v6) = 0;
        }
      }
      else if (v5 >= 0xFF)
      {
        LOWORD(v6) = 31744;
        if (v4 != INFINITY)
        {
          result = (((LODWORD(v4) >> 13) & 0x3FF) == 0) | (LODWORD(v4) >> 13) & 0x3FF;
          LOWORD(v6) = (((LODWORD(v4) >> 13) & 0x3FF) == 0) | (LODWORD(v4) >> 13) & 0x3FF | 0x7C00;
        }
      }
      else if (LODWORD(v4) >= 0x477FF000)
      {
        LOWORD(v6) = 31744;
      }
      else
      {
        result = (LODWORD(v4) + 134221823);
        v6 = (result + ((LODWORD(v4) >> 13) & 1)) >> 13;
      }
      *(_WORD *)(a2 - 2 + 2 * a3--) = v6;
    }
    while (a3);
  }
  return result;
}

uint64_t sub_20BDF933C(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;

  if (a3)
  {
    v4 = result - 1;
    do
    {
      LOBYTE(a4) = *(_BYTE *)(v4 + a3);
      a4 = (float)LODWORD(a4);
      result = LODWORD(a4) & 0x7FFFFFFF;
      v5 = HIWORD(LODWORD(a4)) & 0x8000;
      if ((LODWORD(a4) >> 23) < 0x71u)
      {
        if (result >= 0x33000001)
        {
          v7 = 126 - (result >> 23);
          v8 = LODWORD(a4) & 0x7FFFFF | 0x800000;
          result = v8 << ((result >> 23) - 94);
          v5 = (v8 >> v7) | HIWORD(LODWORD(a4)) & 0x8000;
          if (result > 0x80000000
            || ((_DWORD)result == 0x80000000 ? (v9 = ((v8 >> v7) & 1) == 0) : (v9 = 1), !v9))
          {
            LOWORD(v5) = v5 + 1;
          }
        }
      }
      else
      {
        v6 = v5 | ((LODWORD(a4) + 134221823 + ((LODWORD(a4) >> 13) & 1)) >> 13);
        LOWORD(v5) = v5 | 0x7C00;
        if (result >= 0x477FF000)
          LOWORD(v6) = v5;
        if ((_DWORD)result != 2139095040)
          LOWORD(v5) = (((LODWORD(a4) >> 13) & 0x3FF) == 0) | (LODWORD(a4) >> 13) & 0x3FF | v5;
        if (result >> 23 < 0xFF)
          LOWORD(v5) = v6;
      }
      *(_WORD *)(a2 - 2 + 2 * a3--) = v5;
    }
    while (a3);
  }
  return result;
}

uint64_t sub_20BDF9434(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  float v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;

  if (a3)
  {
    v3 = result - 1;
    v4 = a2 - 2;
    do
    {
      v5 = (float)*(char *)(v3 + a3);
      result = COERCE_UNSIGNED_INT(fabs(v5));
      v6 = HIWORD(LODWORD(v5)) & 0x8000;
      if ((LODWORD(v5) >> 23) < 0x71u)
      {
        if (result >= 0x33000001)
        {
          v9 = 126 - (result >> 23);
          v10 = LODWORD(v5) & 0x7FFFFF | 0x800000;
          result = v10 << ((result >> 23) - 94);
          v6 = (v10 >> v9) | HIWORD(LODWORD(v5)) & 0x8000;
          if (result > 0x80000000
            || ((_DWORD)result == 0x80000000 ? (v11 = ((v10 >> v9) & 1) == 0) : (v11 = 1), !v11))
          {
            LOWORD(v6) = v6 + 1;
          }
        }
      }
      else
      {
        v7 = v6 | ((LODWORD(v5) + 134221823 + ((LODWORD(v5) >> 13) & 1)) >> 13);
        v6 |= 0x7C00u;
        if (result >= 0x477FF000)
          LOWORD(v7) = v6;
        v8 = (((LODWORD(v5) >> 13) & 0x3FF) == 0) | (LODWORD(v5) >> 13) & 0x3FF | v6;
        if ((_DWORD)result != 2139095040)
          LOWORD(v6) = v8;
        if (result >> 23 < 0xFF)
          LOWORD(v6) = v7;
      }
      *(_WORD *)(v4 + 2 * a3--) = v6;
    }
    while (a3);
  }
  return result;
}

uint64_t sub_20BDF952C(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  float v7;
  float v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  BOOL v16;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    v4 = result - 2;
    v5 = a2 - 2;
    result = 0x80000000;
    do
    {
      v6 = *(unsigned __int16 *)(v4 + 2 * v3);
      if (v6 >= 0xFFE0)
        v6 = 65504;
      v7 = (float)v6;
      v8 = fabs((float)v6);
      v9 = HIWORD(COERCE_UNSIGNED_INT((float)v6));
      v10 = v9 & 0x8000;
      if ((LODWORD(v7) >> 23) < 0x71u)
      {
        if (LODWORD(v8) >= 0x33000001)
        {
          v13 = 126 - (LODWORD(v8) >> 23);
          v14 = LODWORD(v7) & 0x7FFFFF | 0x800000;
          v15 = v14 << ((LODWORD(v8) >> 23) - 94);
          v10 = (v14 >> v13) | v9 & 0x8000;
          if (v15 > 0x80000000 || (v15 == 0x80000000 ? (v16 = ((v14 >> v13) & 1) == 0) : (v16 = 1), !v16))
            LOWORD(v10) = v10 + 1;
        }
      }
      else
      {
        v11 = v10 | ((LODWORD(v7) + 134221823 + ((LODWORD(v7) >> 13) & 1)) >> 13);
        v10 |= 0x7C00u;
        if (LODWORD(v8) >= 0x477FF000)
          LOWORD(v11) = v10;
        v12 = (((LODWORD(v7) >> 13) & 0x3FF) == 0) | (LODWORD(v7) >> 13) & 0x3FF | v10;
        if (v8 != INFINITY)
          LOWORD(v10) = v12;
        if (LODWORD(v8) >> 23 < 0xFF)
          LOWORD(v10) = v11;
      }
      *(_WORD *)(v5 + 2 * v3--) = v10;
    }
    while (v3);
  }
  return result;
}

unint64_t sub_20BDF9638(unint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  float v6;
  float v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    v4 = result - 2;
    v5 = a2 - 2;
    do
    {
      v6 = (float)*(__int16 *)(v4 + 2 * v3);
      v7 = fabs(v6);
      v8 = HIWORD(LODWORD(v6)) & 0x8000;
      if ((LODWORD(v6) >> 23) < 0x71u)
      {
        if (LODWORD(v7) >= 0x33000001)
        {
          v11 = 126 - (LODWORD(v7) >> 23);
          v12 = LODWORD(v6) & 0x7FFFFF | 0x800000;
          v13 = v12 << ((LODWORD(v7) >> 23) - 94);
          v8 = (v12 >> v11) | HIWORD(LODWORD(v6)) & 0x8000;
          if (v13 > 0x80000000 || (v13 == 0x80000000 ? (v14 = ((v12 >> v11) & 1) == 0) : (v14 = 1), !v14))
            LOWORD(v8) = v8 + 1;
        }
      }
      else
      {
        v9 = v8 | ((LODWORD(v6) + 134221823 + ((LODWORD(v6) >> 13) & 1)) >> 13);
        v8 |= 0x7C00u;
        if (LODWORD(v7) >= 0x477FF000)
          LOWORD(v9) = v8;
        v10 = (((LODWORD(v6) >> 13) & 0x3FF) == 0) | (LODWORD(v6) >> 13) & 0x3FF | v8;
        if (v7 != INFINITY)
          LOWORD(v8) = v10;
        if (LODWORD(v7) >> 23 < 0xFF)
          LOWORD(v8) = v9;
      }
      *(_WORD *)(v5 + 2 * v3) = v8;
      result = v3 - 1;
      v3 = result;
    }
    while (result);
  }
  return result;
}

int *sub_20BDF9738(int *result, _WORD *a2, unint64_t a3)
{
  unint64_t v3;
  int v4;
  int v5;
  float v6;
  float v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  BOOL v15;

  if (a3 >= 4)
  {
    v3 = a3 >> 2;
    do
    {
      v5 = *result++;
      v4 = v5;
      if (v5 >= 65504)
        v4 = 65504;
      if (v4 <= -65504)
        v4 = -65504;
      v6 = (float)v4;
      v7 = fabs((float)v4);
      v8 = HIWORD(COERCE_UNSIGNED_INT((float)v4));
      v9 = v8 & 0x8000;
      if ((LODWORD(v6) >> 23) < 0x71u)
      {
        if (LODWORD(v7) >= 0x33000001)
        {
          v12 = 126 - (LODWORD(v7) >> 23);
          v13 = LODWORD(v6) & 0x7FFFFF | 0x800000;
          v14 = v13 << ((LODWORD(v7) >> 23) - 94);
          v9 = (v13 >> v12) | v8 & 0x8000;
          if (v14 > 0x80000000 || (v14 == 0x80000000 ? (v15 = ((v13 >> v12) & 1) == 0) : (v15 = 1), !v15))
            LOWORD(v9) = v9 + 1;
        }
      }
      else
      {
        v10 = v9 | ((LODWORD(v6) + 134221823 + ((LODWORD(v6) >> 13) & 1)) >> 13);
        v9 |= 0x7C00u;
        if (LODWORD(v7) >= 0x477FF000)
          LOWORD(v10) = v9;
        v11 = (((LODWORD(v6) >> 13) & 0x3FF) == 0) | (LODWORD(v6) >> 13) & 0x3FF | v9;
        if (v7 != INFINITY)
          LOWORD(v9) = v11;
        if (LODWORD(v7) >> 23 < 0xFF)
          LOWORD(v9) = v10;
      }
      *a2++ = v9;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t *sub_20BDF9844(uint64_t *result, _WORD *a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  float v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  BOOL v15;

  if (a3 >= 8)
  {
    v3 = a3 >> 3;
    do
    {
      v5 = *result++;
      v4 = v5;
      if (v5 >= 65504)
        v4 = 65504;
      if (v4 <= -65504)
        v4 = -65504;
      v6 = (float)v4;
      v7 = fabs((float)v4);
      v8 = HIWORD(COERCE_UNSIGNED_INT((float)v4));
      v9 = v8 & 0x8000;
      if ((LODWORD(v6) >> 23) < 0x71u)
      {
        if (LODWORD(v7) >= 0x33000001)
        {
          v12 = 126 - (LODWORD(v7) >> 23);
          v13 = LODWORD(v6) & 0x7FFFFF | 0x800000;
          v14 = v13 << ((LODWORD(v7) >> 23) - 94);
          v9 = (v13 >> v12) | v8 & 0x8000;
          if (v14 > 0x80000000 || (v14 == 0x80000000 ? (v15 = ((v13 >> v12) & 1) == 0) : (v15 = 1), !v15))
            LOWORD(v9) = v9 + 1;
        }
      }
      else
      {
        v10 = v9 | ((LODWORD(v6) + 134221823 + ((LODWORD(v6) >> 13) & 1)) >> 13);
        v9 |= 0x7C00u;
        if (LODWORD(v7) >= 0x477FF000)
          LOWORD(v10) = v9;
        v11 = (((LODWORD(v6) >> 13) & 0x3FF) == 0) | (LODWORD(v6) >> 13) & 0x3FF | v9;
        if (v7 != INFINITY)
          LOWORD(v9) = v11;
        if (LODWORD(v7) >> 23 < 0xFF)
          LOWORD(v9) = v10;
      }
      *a2++ = v9;
      --v3;
    }
    while (v3);
  }
  return result;
}

unsigned __int16 *sub_20BDF9950(unsigned __int16 *result, BOOL *a2, unint64_t a3)
{
  unint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    do
    {
      v4 = *result++;
      v5 = v4 << 13;
      v6 = (v4 << 13) & 0xFFFE000;
      if (v6 < 0x800000)
      {
        if (v6)
        {
          v7 = __clz(v6) - 8;
          v6 = ((v6 << v7) | 0x38800000) - (v7 << 23);
        }
      }
      else if (v6 >> 23 > 0x1E)
      {
        v6 = v5 | 0x7F800000;
      }
      else
      {
        v6 += 939524096;
      }
      *a2++ = (v6 & 0x7FFFFFFF) != 0;
      --v3;
    }
    while (v3);
  }
  return result;
}

float sub_20BDF99C8(__int16 *a1, _BYTE *a2, unint64_t a3)
{
  unint64_t i;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  float v8;
  float v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  float result;

  if (a3 >= 2)
  {
    for (i = a3 >> 1; i; --i)
    {
      v4 = *a1++;
      v5 = (v4 & 0x7FFF) << 13;
      v6 = v4 & 0x80000000;
      v7 = __clz(v5) - 8;
      LODWORD(v8) = (v4 & 0x80000000 | 0x38800000 | (v5 << v7)) - (v7 << 23);
      if (v5)
        v9 = v8;
      else
        v9 = *(float *)&v6;
      v10 = v5 >> 23;
      v11 = v5 | v6 | 0x7F800000;
      if (v5 >> 23 <= 0x1E)
        v12 = (v5 | v6) + 939524096;
      else
        v12 = v5 | v6 | 0x7F800000;
      if (v5 >= 0x800000)
        v9 = *(float *)&v12;
      if (v9 >= 0.0)
      {
        if (!v5)
          v8 = *(float *)&v6;
        if (v10 <= 0x1E)
          v11 = (v5 | v6) + 939524096;
        if (v5 >= 0x800000)
          v8 = *(float *)&v11;
        if (v8 <= 255.0)
        {
          if (v5 < 0x800000)
          {
            if (v5)
              v6 = (v6 | 0x38800000 | (v5 << v7)) - (v7 << 23);
            goto LABEL_24;
          }
          v13 = v5 | v6;
          if (v10 > 0x1E)
          {
            v6 = v13 | 0x7F800000;
            goto LABEL_24;
          }
        }
        else
        {
          v13 = 192872448;
        }
        v6 = v13 + 939524096;
      }
      else
      {
        *(float *)&v6 = 0.0;
      }
LABEL_24:
      result = *(float *)&v6;
      *a2++ = (int)*(float *)&v6;
    }
  }
  return result;
}

__int16 *sub_20BDF9AC0(__int16 *result, _BYTE *a2, unint64_t a3)
{
  unint64_t i;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  float v8;
  float v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;

  if (a3 >= 2)
  {
    for (i = a3 >> 1; i; --i)
    {
      v4 = *result++;
      v5 = (v4 & 0x7FFF) << 13;
      v6 = v4 & 0x80000000;
      v7 = __clz(v5) - 8;
      LODWORD(v8) = (v4 & 0x80000000 | 0x38800000 | (v5 << v7)) - (v7 << 23);
      if (v5)
        v9 = v8;
      else
        v9 = *(float *)&v6;
      v10 = v5 >> 23;
      v11 = v5 | v6 | 0x7F800000;
      if (v5 >> 23 <= 0x1E)
        v12 = (v5 | v6) + 939524096;
      else
        v12 = v5 | v6 | 0x7F800000;
      if (v5 >= 0x800000)
        v9 = *(float *)&v12;
      if (v9 >= -128.0)
      {
        if (!v5)
          v8 = *(float *)&v6;
        if (v10 <= 0x1E)
          v11 = (v5 | v6) + 939524096;
        if (v5 >= 0x800000)
          v8 = *(float *)&v11;
        if (v8 <= 127.0)
        {
          if (v5 < 0x800000)
          {
            if (v5)
              v6 = (v6 | 0x38800000 | (v5 << v7)) - (v7 << 23);
            goto LABEL_24;
          }
          v13 = v5 | v6;
          if (v10 > 0x1E)
          {
            v6 = v13 | 0x7F800000;
            goto LABEL_24;
          }
        }
        else
        {
          v13 = 184418304;
        }
      }
      else
      {
        v13 = -1962934272;
      }
      v6 = v13 + 939524096;
LABEL_24:
      *a2++ = (int)*(float *)&v6;
    }
  }
  return result;
}

uint64_t sub_20BDF9BBC(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  float v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    v4 = result - 2;
    v5 = a2 - 2;
    do
    {
      v6 = *(__int16 *)(v4 + 2 * v3);
      v7 = (v6 & 0x7FFF) << 13;
      v8 = v6 & 0x80000000;
      v9 = __clz(v7) - 8;
      result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7)
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      else
        v10 = *(float *)&v8;
      v11 = v7 >> 23;
      v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E)
        v13 = (v7 | v8) + 939524096;
      else
        v13 = v7 | v8 | 0x7F800000;
      if (v7 >= 0x800000)
        v10 = *(float *)&v13;
      if (v10 >= 0.0)
      {
        if (!v7)
          LODWORD(result) = v8;
        if (v11 <= 0x1E)
          v12 = (v7 | v8) + 939524096;
        if (v7 >= 0x800000)
          result = v12;
        else
          result = result;
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7)
              v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            goto LABEL_25;
          }
          v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          v14 = 260038656;
        }
        v8 = v14 + 939524096;
      }
      else
      {
        *(float *)&v8 = 0.0;
      }
LABEL_25:
      *(_WORD *)(v5 + 2 * v3--) = (int)*(float *)&v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_20BDF9CC4(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  float v11;
  int v12;
  int v13;
  int v14;
  int v15;
  float v16;
  float v17;
  int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    v4 = result - 2;
    v5 = a2 - 2;
    do
    {
      v6 = *(__int16 *)(v4 + 2 * v3);
      v7 = (v6 & 0x7FFF) << 13;
      v8 = v6 & 0x80000000;
      v9 = __clz(v7) - 8;
      v10 = (v6 & 0x80000000 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7)
        v11 = *(float *)&v10;
      else
        LODWORD(v11) = v6 & 0x80000000;
      result = v7 >> 23;
      v12 = v7 | v8 | 0x7F800000;
      v13 = (v7 | v8) + 939524096;
      if (result <= 0x1E)
        v14 = (v7 | v8) + 939524096;
      else
        v14 = v7 | v8 | 0x7F800000;
      if (v7 >= 0x800000)
        v11 = *(float *)&v14;
      if (v11 >= -65504.0)
      {
        if (v7)
          v8 = v10;
        if (result <= 0x1E)
          v16 = *(float *)&v13;
        else
          v16 = *(float *)&v12;
        if (v7 >= 0x800000)
          v17 = v16;
        else
          v17 = *(float *)&v8;
        if (v17 <= 65504.0)
          v18 = *(unsigned __int16 *)(v4 + 2 * v3);
        else
          v18 = 31743;
        v19 = (v18 & 0x7FFF) << 13;
        v20 = (v18 << 16) & 0x80000000;
        if (v19 < 0x800000)
        {
          if (v19)
          {
            v21 = __clz(v19) - 8;
            v20 = (v20 | 0x38800000 | (v19 << v21)) - (v21 << 23);
          }
          goto LABEL_27;
        }
        v15 = v19 | v20;
        if (v19 >> 23 > 0x1E)
        {
          v20 = v15 | 0x7F800000;
          goto LABEL_27;
        }
      }
      else
      {
        v15 = -1887444992;
      }
      v20 = v15 + 939524096;
LABEL_27:
      *(_WORD *)(v5 + 2 * v3--) = (int)*(float *)&v20;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_20BDF9DF0(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  float v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    v4 = result - 2;
    v5 = a2 - 4;
    do
    {
      v6 = *(__int16 *)(v4 + 2 * v3);
      v7 = (v6 & 0x7FFF) << 13;
      v8 = v6 & 0x80000000;
      v9 = __clz(v7) - 8;
      result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7)
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      else
        v10 = *(float *)&v8;
      v11 = v7 >> 23;
      v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E)
        v13 = (v7 | v8) + 939524096;
      else
        v13 = v7 | v8 | 0x7F800000;
      if (v7 >= 0x800000)
        v10 = *(float *)&v13;
      if (v10 >= 0.0)
      {
        if (!v7)
          LODWORD(result) = v8;
        if (v11 <= 0x1E)
          v12 = (v7 | v8) + 939524096;
        if (v7 >= 0x800000)
          result = v12;
        else
          result = result;
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7)
              v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            goto LABEL_25;
          }
          v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          v14 = 260038656;
        }
        v8 = v14 + 939524096;
      }
      else
      {
        *(float *)&v8 = 0.0;
      }
LABEL_25:
      *(_DWORD *)(v5 + 4 * v3--) = *(float *)&v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_20BDF9EF8(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  float v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    v4 = result - 2;
    v5 = a2 - 4;
    do
    {
      v6 = *(__int16 *)(v4 + 2 * v3);
      v7 = (v6 & 0x7FFF) << 13;
      v8 = v6 & 0x80000000;
      v9 = __clz(v7) - 8;
      result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7)
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      else
        v10 = *(float *)&v8;
      v11 = v7 >> 23;
      v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E)
        v13 = (v7 | v8) + 939524096;
      else
        v13 = v7 | v8 | 0x7F800000;
      if (v7 >= 0x800000)
        v10 = *(float *)&v13;
      if (v10 >= -65504.0)
      {
        if (!v7)
          LODWORD(result) = v8;
        if (v11 <= 0x1E)
          v12 = (v7 | v8) + 939524096;
        if (v7 >= 0x800000)
          result = v12;
        else
          result = result;
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7)
              v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            goto LABEL_25;
          }
          v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          v14 = 260038656;
        }
      }
      else
      {
        v14 = -1887444992;
      }
      v8 = v14 + 939524096;
LABEL_25:
      *(_DWORD *)(v5 + 4 * v3--) = (int)*(float *)&v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_20BDFA00C(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  float v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    v4 = result - 2;
    v5 = a2 - 8;
    do
    {
      v6 = *(__int16 *)(v4 + 2 * v3);
      v7 = (v6 & 0x7FFF) << 13;
      v8 = v6 & 0x80000000;
      v9 = __clz(v7) - 8;
      result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7)
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      else
        v10 = *(float *)&v8;
      v11 = v7 >> 23;
      v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E)
        v13 = (v7 | v8) + 939524096;
      else
        v13 = v7 | v8 | 0x7F800000;
      if (v7 >= 0x800000)
        v10 = *(float *)&v13;
      if (v10 >= 0.0)
      {
        if (!v7)
          LODWORD(result) = v8;
        if (v11 <= 0x1E)
          v12 = (v7 | v8) + 939524096;
        if (v7 >= 0x800000)
          result = v12;
        else
          result = result;
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7)
              v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            goto LABEL_25;
          }
          v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          v14 = 260038656;
        }
        v8 = v14 + 939524096;
      }
      else
      {
        *(float *)&v8 = 0.0;
      }
LABEL_25:
      *(_QWORD *)(v5 + 8 * v3--) = (unint64_t)*(float *)&v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_20BDFA114(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  float v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    v4 = result - 2;
    v5 = a2 - 8;
    do
    {
      v6 = *(__int16 *)(v4 + 2 * v3);
      v7 = (v6 & 0x7FFF) << 13;
      v8 = v6 & 0x80000000;
      v9 = __clz(v7) - 8;
      result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7)
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      else
        v10 = *(float *)&v8;
      v11 = v7 >> 23;
      v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E)
        v13 = (v7 | v8) + 939524096;
      else
        v13 = v7 | v8 | 0x7F800000;
      if (v7 >= 0x800000)
        v10 = *(float *)&v13;
      if (v10 >= -65504.0)
      {
        if (!v7)
          LODWORD(result) = v8;
        if (v11 <= 0x1E)
          v12 = (v7 | v8) + 939524096;
        if (v7 >= 0x800000)
          result = v12;
        else
          result = result;
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7)
              v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            goto LABEL_25;
          }
          v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          v14 = 260038656;
        }
      }
      else
      {
        v14 = -1887444992;
      }
      v8 = v14 + 939524096;
LABEL_25:
      *(_QWORD *)(v5 + 8 * v3--) = (uint64_t)*(float *)&v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_20BDFA228(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  float v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    v4 = result - 2;
    v5 = a2 - 4;
    do
    {
      v6 = *(__int16 *)(v4 + 2 * v3);
      v7 = (v6 & 0x7FFF) << 13;
      v8 = v6 & 0x80000000;
      v9 = __clz(v7) - 8;
      result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7)
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      else
        v10 = *(float *)&v8;
      v11 = v7 >> 23;
      v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E)
        v13 = (v7 | v8) + 939524096;
      else
        v13 = v7 | v8 | 0x7F800000;
      if (v7 >= 0x800000)
        v10 = *(float *)&v13;
      if (v10 >= -65504.0)
      {
        if (!v7)
          LODWORD(result) = v8;
        if (v11 <= 0x1E)
          v12 = (v7 | v8) + 939524096;
        if (v7 >= 0x800000)
          result = v12;
        else
          result = result;
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7)
              v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            goto LABEL_25;
          }
          v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          v14 = 260038656;
        }
      }
      else
      {
        v14 = -1887444992;
      }
      v8 = v14 + 939524096;
LABEL_25:
      *(_DWORD *)(v5 + 4 * v3--) = v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_20BDFA334(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  float v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;

  if (a3 >= 2)
  {
    v3 = a3 >> 1;
    v4 = result - 2;
    v5 = a2 - 8;
    do
    {
      v6 = *(__int16 *)(v4 + 2 * v3);
      v7 = (v6 & 0x7FFF) << 13;
      v8 = v6 & 0x80000000;
      v9 = __clz(v7) - 8;
      result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7)
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      else
        v10 = *(float *)&v8;
      v11 = v7 >> 23;
      v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E)
        v13 = (v7 | v8) + 939524096;
      else
        v13 = v7 | v8 | 0x7F800000;
      if (v7 >= 0x800000)
        v10 = *(float *)&v13;
      if (v10 >= -65504.0)
      {
        if (!v7)
          LODWORD(result) = v8;
        if (v11 <= 0x1E)
          v12 = (v7 | v8) + 939524096;
        if (v7 >= 0x800000)
          result = v12;
        else
          result = result;
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7)
              v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            goto LABEL_25;
          }
          v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          v14 = 260038656;
        }
      }
      else
      {
        v14 = -1887444992;
      }
      v8 = v14 + 939524096;
LABEL_25:
      *(double *)(v5 + 8 * v3--) = *(float *)&v8;
    }
    while (v3);
  }
  return result;
}

float *sub_20BDFA448(float *result, _BYTE *a2, unint64_t a3)
{
  unint64_t v3;
  float v4;

  if (a3 >= 4)
  {
    v3 = a3 >> 2;
    do
    {
      v4 = 0.0;
      if (*result >= 0.0)
      {
        v4 = *result;
        if (*result > 255.0)
          v4 = 255.0;
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *sub_20BDFA498(float *result, _BYTE *a2, unint64_t a3)
{
  unint64_t v3;
  float v4;

  if (a3 >= 4)
  {
    v3 = a3 >> 2;
    do
    {
      v4 = -128.0;
      if (*result >= -128.0)
      {
        v4 = *result;
        if (*result > 127.0)
          v4 = 127.0;
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *sub_20BDFA4E8(float *result, _WORD *a2, unint64_t a3)
{
  unint64_t v3;
  float v4;

  if (a3 >= 4)
  {
    v3 = a3 >> 2;
    do
    {
      v4 = 0.0;
      if (*result >= 0.0)
      {
        v4 = *result;
        if (*result > 65535.0)
          v4 = 65535.0;
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *sub_20BDFA534(float *result, _WORD *a2, unint64_t a3)
{
  unint64_t v3;
  float v4;

  if (a3 >= 4)
  {
    v3 = a3 >> 2;
    do
    {
      v4 = -32768.0;
      if (*result >= -32768.0)
      {
        v4 = *result;
        if (*result > 32767.0)
          v4 = 32767.0;
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *sub_20BDFA580(float *result, _WORD *a2, unint64_t a3)
{
  unint64_t v3;
  float v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;

  if (a3 >= 4)
  {
    v3 = a3 >> 2;
    do
    {
      v4 = -65504.0;
      if (*result >= -65504.0)
      {
        v4 = *result;
        if (*result > 65504.0)
          v4 = 65504.0;
      }
      v5 = LODWORD(v4) & 0x7FFFFFFF;
      v6 = HIWORD(LODWORD(v4)) & 0x8000;
      if ((LODWORD(v4) >> 23) < 0x71u)
      {
        if (v5 >= 0x33000001)
        {
          v8 = 126 - (v5 >> 23);
          v9 = LODWORD(v4) & 0x7FFFFF | 0x800000;
          v10 = v9 << ((v5 >> 23) - 94);
          v6 = (v9 >> v8) | HIWORD(LODWORD(v4)) & 0x8000;
          if (v10 > 0x80000000 || (v10 == 0x80000000 ? (v11 = ((v9 >> v8) & 1) == 0) : (v11 = 1), !v11))
            LOWORD(v6) = v6 + 1;
        }
      }
      else
      {
        v7 = v6 | ((LODWORD(v4) + 134221823 + ((LODWORD(v4) >> 13) & 1)) >> 13);
        LOWORD(v6) = v6 | 0x7C00;
        if (v5 >= 0x477FF000)
          LOWORD(v7) = v6;
        if (v5 != 2139095040)
          LOWORD(v6) = (((LODWORD(v4) >> 13) & 0x3FF) == 0) | (LODWORD(v4) >> 13) & 0x3FF | v6;
        if (v5 >> 23 < 0xFF)
          LOWORD(v6) = v7;
      }
      *a2++ = v6;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

double *sub_20BDFA6A0(double *result, _BYTE *a2, unint64_t a3)
{
  unint64_t v3;
  double v4;

  if (a3 >= 8)
  {
    v3 = a3 >> 3;
    do
    {
      v4 = 0.0;
      if (*result >= 0.0)
      {
        v4 = *result;
        if (*result > 255.0)
          v4 = 255.0;
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

double *sub_20BDFA6EC(double *result, _BYTE *a2, unint64_t a3)
{
  unint64_t v3;
  double v4;

  if (a3 >= 8)
  {
    v3 = a3 >> 3;
    do
    {
      v4 = -128.0;
      if (*result >= -128.0)
      {
        v4 = *result;
        if (*result > 127.0)
          v4 = 127.0;
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

double *sub_20BDFA73C(double *result, _WORD *a2, unint64_t a3)
{
  unint64_t v3;
  double v4;

  if (a3 >= 8)
  {
    v3 = a3 >> 3;
    do
    {
      v4 = 0.0;
      if (*result >= 0.0)
      {
        v4 = *result;
        if (*result > 65535.0)
          v4 = 65535.0;
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

double *sub_20BDFA788(double *result, _WORD *a2, unint64_t a3)
{
  unint64_t v3;
  double v4;

  if (a3 >= 8)
  {
    v3 = a3 >> 3;
    do
    {
      v4 = -32768.0;
      if (*result >= -32768.0)
      {
        v4 = *result;
        if (*result > 32767.0)
          v4 = 32767.0;
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

double *sub_20BDFA7D8(double *result, _WORD *a2, unint64_t a3)
{
  unint64_t v3;
  double v4;
  float v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  BOOL v12;

  if (a3 >= 8)
  {
    v3 = a3 >> 3;
    do
    {
      v4 = -65504.0;
      if (*result >= -65504.0)
      {
        v4 = *result;
        if (*result > 65504.0)
          v4 = 65504.0;
      }
      v5 = v4;
      v6 = LODWORD(v5) & 0x7FFFFFFF;
      v7 = HIWORD(LODWORD(v5)) & 0x8000;
      if ((LODWORD(v5) >> 23) < 0x71u)
      {
        if (v6 >= 0x33000001)
        {
          v9 = 126 - (v6 >> 23);
          v10 = LODWORD(v5) & 0x7FFFFF | 0x800000;
          v11 = v10 << ((v6 >> 23) - 94);
          v7 = (v10 >> v9) | HIWORD(LODWORD(v5)) & 0x8000;
          if (v11 > 0x80000000 || (v11 == 0x80000000 ? (v12 = ((v10 >> v9) & 1) == 0) : (v12 = 1), !v12))
            LOWORD(v7) = v7 + 1;
        }
      }
      else
      {
        v8 = v7 | ((LODWORD(v5) + 134221823 + ((LODWORD(v5) >> 13) & 1)) >> 13);
        LOWORD(v7) = v7 | 0x7C00;
        if (v6 >= 0x477FF000)
          LOWORD(v8) = v7;
        if (v6 != 2139095040)
          LOWORD(v7) = (((LODWORD(v5) >> 13) & 0x3FF) == 0) | (LODWORD(v5) >> 13) & 0x3FF | v7;
        if (v6 >> 23 < 0xFF)
          LOWORD(v7) = v8;
      }
      *a2++ = v7;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

__n64 sub_20BDFA8FC(uint64_t a1, Alembic::Ogawa::v12::IData **a2, unint64_t a3, int *a4, int a5)
{
  uint64_t v9;
  unint64_t Size;
  __n64 result;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  void *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  std::wstring::value_type v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  __n64 v29;
  unint64_t v30;
  unint64_t v31;
  void *v32;
  __n64 v33;
  _QWORD *exception;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *__p[2];
  char v39;
  _QWORD v40[4];
  _BYTE v41[16];
  _QWORD v42[33];

  v9 = *a4;
  if ((_DWORD)v9 != a5 && ((a5 - 14) > 0xFFFFFFFD || (v9 - 14) >= 0xFFFFFFFE))
  {
    sub_20BDDBD68((uint64_t)v41);
    sub_20BDDC1C8(v42, (uint64_t)"Cannot convert the data to or from a string, or wstring.", 56);
    std::stringbuf::str();
    sub_20BDDBF20(v40, (__int128 *)__p);
    if (v39 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v35 = sub_20BDDC09C(exception, (uint64_t)v40);
    __cxa_throw(v35, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (*a2)
  {
    Size = Alembic::Ogawa::v12::IData::getSize(*a2);
    if (Size > 0xF)
    {
      if ((_DWORD)v9 == 13)
      {
        if (Size >= 0x11 && (Size & 3) == 0)
        {
          v18 = Size - 16;
          v19 = operator new[]((Size - 16) & 0xFFFFFFFFFFFFFFFCLL);
          Alembic::Ogawa::v12::IData::read((unint64_t **)*a2, v18, v19, 16, a3);
          if (v18 >= 4)
          {
            v20 = 0;
            v21 = 0;
            v22 = v18 >> 2;
            do
            {
              if (*(char *)(a1 + 23) < 0)
                v23 = *(_QWORD *)(a1 + 8);
              else
                v23 = *(unsigned __int8 *)(a1 + 23);
              if (v21 >= v23)
                break;
              v24 = *((_DWORD *)v19 + v20);
              if (v24)
                std::wstring::push_back((std::wstring *)(a1 + 24 * v21), v24);
              else
                ++v21;
              ++v20;
            }
            while (v22 != v20);
          }
          operator delete[](v19);
        }
      }
      else if ((_DWORD)v9 == 12)
      {
        if (Size >= 0x11)
        {
          v12 = Size - 16;
          v13 = (char *)operator new[](Size - 16);
          Alembic::Ogawa::v12::IData::read((unint64_t **)*a2, v12, v13, 16, a3);
          v14 = 0;
          v15 = 0;
          v16 = 0;
          do
          {
            if (!v13[v14])
            {
              v17 = *(char *)(a1 + 23) < 0 ? *(_QWORD *)(a1 + 8) : *(unsigned __int8 *)(a1 + 23);
              if (v15 < v17)
              {
                MEMORY[0x212B929D0](a1 + 24 * v15, &v13[v16]);
                v16 = v14 + 1;
                ++v15;
              }
            }
            ++v14;
          }
          while (v12 != v14);
          operator delete[](v13);
        }
      }
      else if ((_DWORD)v9 == a5)
      {
        Alembic::Ogawa::v12::IData::read((unint64_t **)*a2, Size - 16, (void *)a1, 16, a3);
      }
      else
      {
        if (v9 > 0xB)
          v25 = 0;
        else
          v25 = qword_20CA51570[v9];
        if (a5 > 0xD)
          v26 = 0;
        else
          v26 = qword_20CA515D0[a5];
        if (v25 <= v26)
        {
          v28 = Size - 16;
          Alembic::Ogawa::v12::IData::read((unint64_t **)*a2, Size - 16, (void *)a1, 16, a3);
          return sub_20BDF7C6C(v9, a5, (int *)a1, (char *)a1, v28, v29);
        }
        else
        {
          if (v9 > 0xB)
            v27 = 0;
          else
            v27 = qword_20CA51570[v9];
          if (a5 > 0xD)
            v30 = 0;
          else
            v30 = qword_20CA515D0[a5];
          if (v27 > v30)
          {
            v31 = Size - 16;
            v32 = operator new[](Size - 16);
            Alembic::Ogawa::v12::IData::read((unint64_t **)*a2, v31, v32, 16, a3);
            sub_20BDF7C6C(v9, a5, (int *)v32, (char *)a1, v31, v33);
            operator delete[](v32);
          }
        }
      }
    }
    else if (Size)
    {
      sub_20BDDBD68((uint64_t)v41);
      sub_20BDDC1C8(v42, (uint64_t)"Incorrect data, expected to be empty or to have a key and data", 62);
      std::stringbuf::str();
      sub_20BDDBF20(v40, (__int128 *)__p);
      if (v39 < 0)
        operator delete(__p[0]);
      v36 = __cxa_allocate_exception(0x20uLL);
      v37 = sub_20BDDC09C(v36, (uint64_t)v40);
      __cxa_throw(v37, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
  }
  return result;
}

void sub_20BDFACFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BDFAD30(uint64_t a1, Alembic::Ogawa::v12::IData **a2, unint64_t a3, int *a4, uint64_t **a5)
{
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  Alembic::Ogawa::v12::IData *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  Alembic::Ogawa::v12::IData *v32;
  Alembic::Ogawa::v12::IData *v33;
  unint64_t *v34;
  unint64_t v35;
  __n128 v36;
  unint64_t *v37;
  unint64_t v38;
  Alembic::Ogawa::v12::IData *v39[2];
  __int128 v40;
  Alembic::Ogawa::v12::IData *v41[2];
  Alembic::Ogawa::v12::IData *v42;
  std::__shared_weak_count *v43;
  void *__p;
  void *v45;
  uint64_t v46;

  __p = 0;
  v45 = 0;
  v46 = 0;
  v9 = *(std::__shared_weak_count **)(a1 + 8);
  v42 = *(Alembic::Ogawa::v12::IData **)a1;
  v43 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v12 = a2[1];
  v41[0] = *a2;
  v41[1] = v12;
  if (v12)
  {
    v13 = (unint64_t *)((char *)v12 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  sub_20BDF79DC(&v42, v41, a3, a4, &__p);
  if (v12)
  {
    v15 = (unint64_t *)((char *)v12 + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      (*(void (**)(Alembic::Ogawa::v12::IData *))(*(_QWORD *)v12 + 16))(v12);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v12);
    }
  }
  v17 = v43;
  if (v43)
  {
    v18 = (unint64_t *)&v43->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  Alembic::AbcCoreAbstract::v12::AllocateArraySample(a4, (uint64_t)&__p, &v40);
  sub_20BDE82DC((uint64_t)a5, &v40);
  v20 = (std::__shared_weak_count *)*((_QWORD *)&v40 + 1);
  if (*((_QWORD *)&v40 + 1))
  {
    v21 = (unint64_t *)(*((_QWORD *)&v40 + 1) + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  if (*a2 && (unint64_t)Alembic::Ogawa::v12::IData::getSize(*a2) >= 0x11)
  {
    v23 = (uint64_t *)(*a5)[2];
    v24 = (*a5)[3] - (_QWORD)v23;
    if (v24)
    {
      v25 = v24 >> 3;
      if (v25 <= 1)
        v25 = 1;
      v26 = 1;
      do
      {
        v27 = *v23++;
        v26 *= v27;
        --v25;
      }
      while (v25);
    }
    else
    {
      v26 = 0;
    }
    v28 = *a4;
    if (v28 > 0xD)
      v29 = 0;
    else
      v29 = qword_20CA515D0[v28];
    v30 = *((unsigned __int8 *)a4 + 4);
    if (v26 * v30 * v29 >= (unint64_t)(Alembic::Ogawa::v12::IData::getSize(*a2) - 16))
    {
      v31 = **a5;
      v32 = *a2;
      v33 = a2[1];
      v39[0] = v32;
      v39[1] = v33;
      if (v33)
      {
        v34 = (unint64_t *)((char *)v33 + 8);
        do
          v35 = __ldxr(v34);
        while (__stxr(v35 + 1, v34));
      }
      v36.n128_u64[0] = sub_20BDFA8FC(v31, v39, a3, a4, *a4).n64_u64[0];
      if (v33)
      {
        v37 = (unint64_t *)((char *)v33 + 8);
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          (*(void (**)(Alembic::Ogawa::v12::IData *, __n128))(*(_QWORD *)v33 + 16))(v33, v36);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v33);
        }
      }
    }
  }
  if (__p)
  {
    v45 = __p;
    operator delete(__p);
  }
}

void sub_20BDFAFA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a10);
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_20BDFAFE8(Alembic::Ogawa::v12::IData **a1, char **a2, uint64_t a3)
{
  size_t Size;
  _BYTE *v7;
  Alembic::Ogawa::v12::IData *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  BOOL v27;
  double v28;
  unint64_t v29;
  unint64_t v30;
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v31;
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v32;
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v33;
  void *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  __int128 v38;
  __int128 v39;
  void *__dst[3];
  void *__p;
  _BYTE *v42;

  Size = Alembic::Ogawa::v12::IData::getSize(*a1);
  sub_20BDFC9B8(&__p, Size);
  v7 = __p;
  if (__p != v42)
  {
    v8 = *a1;
    v9 = Alembic::Ogawa::v12::IData::getSize(v8);
    Alembic::Ogawa::v12::IData::read((unint64_t **)v8, v9, __p, 0, 0);
    v10 = 0;
    v11 = v42 - (_BYTE *)__p;
    while (1)
    {
      v7 = __p;
      if (v10 >= v11)
        break;
      v12 = v10 + 16;
      if (v10 + 16 > v11)
        break;
      v13 = *(unsigned int *)((char *)__p + v10);
      v15 = *(_QWORD **)(a3 + 8);
      v14 = *(_QWORD *)(a3 + 16);
      if ((unint64_t)v15 >= v14)
      {
        v17 = *(_QWORD **)a3;
        v18 = ((uint64_t)v15 - *(_QWORD *)a3) >> 3;
        v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 61)
          sub_20BDDF694();
        v20 = v14 - (_QWORD)v17;
        if (v20 >> 2 > v19)
          v19 = v20 >> 2;
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
          v21 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v21 = v19;
        if (v21)
        {
          v22 = (char *)sub_20BDDF6A8(a3 + 16, v21);
          v17 = *(_QWORD **)a3;
          v15 = *(_QWORD **)(a3 + 8);
        }
        else
        {
          v22 = 0;
        }
        v23 = &v22[8 * v18];
        *(_QWORD *)v23 = v13;
        v16 = v23 + 8;
        while (v15 != v17)
        {
          v24 = *--v15;
          *((_QWORD *)v23 - 1) = v24;
          v23 -= 8;
        }
        *(_QWORD *)a3 = v23;
        *(_QWORD *)(a3 + 8) = v16;
        *(_QWORD *)(a3 + 16) = &v22[8 * v21];
        if (v17)
          operator delete(v17);
      }
      else
      {
        *v15 = v13;
        v16 = v15 + 1;
      }
      *(_QWORD *)(a3 + 8) = v16;
      v7 = __p;
      v25 = *(unsigned int *)((char *)__p + v10 + 12);
      v26 = v12 + 8 * v25;
      if ((_DWORD)v25)
        v27 = v26 > v11;
      else
        v27 = 1;
      if (v27)
        goto LABEL_39;
      v28 = *(double *)((char *)__p + v10 + 4);
      sub_20BDE48D4(__dst, *(unsigned int *)((char *)__p + v10 + 12));
      v29 = 8 * v25;
      v30 = v42 - ((_BYTE *)__p + v10) - 16;
      v10 += 16;
      if (8 * v25 <= v30)
      {
        v31 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)memcpy(__dst[0], (char *)__p + v12, 8 * v25);
        v32 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v31);
        LODWORD(v39) = (_DWORD)v32;
        *((_QWORD *)&v39 + 1) = Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle(v32);
        if (v28 != Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle(v33))
        {
          sub_20BDFC364((double *)&v38, v25, v28);
          v39 = v38;
        }
        v34 = operator new(0x28uLL);
        Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(v34, &v39, __dst);
        sub_20BDEA220(&v38, (uint64_t)v34);
        sub_20BDEA72C(a2, &v38);
        v35 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
        if (*((_QWORD *)&v38 + 1))
        {
          v36 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
        }
        v10 = v26;
      }
      if (__dst[0])
      {
        __dst[1] = __dst[0];
        operator delete(__dst[0]);
      }
      if (v29 > v30)
      {
        v7 = __p;
        break;
      }
    }
  }
  if (v7)
  {
LABEL_39:
    v42 = v7;
    operator delete(v7);
  }
}

void sub_20BDFB280(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_20BDFB2E8(unint64_t ***a1, unint64_t a2, unint64_t a3, const void **a4, _QWORD *a5, char **a6)
{
  uint64_t Size;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  size_t v15;
  unint64_t v16;
  BOOL v17;
  unint64_t v18;
  _QWORD *v19;
  std::string *v20;
  size_t v21;
  std::string *v22;
  const void *v23;
  std::string *p_str;
  std::string::size_type v25;
  std::string *v26;
  __int128 v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  size_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *p_shared_owners;
  unint64_t v37;
  _QWORD *exception;
  _QWORD *v39;
  std::string v40;
  __int128 v41;
  std::string __dst;
  std::string __str;
  char *v44;
  char *v45;
  uint64_t v46[33];
  unint64_t **v47;
  std::__shared_weak_count *v48;

  Alembic::Ogawa::v12::IGroup::getData(*a1, a2, a3, &v47);
  if (!v47)
  {
    sub_20BDDBD68((uint64_t)&v44);
    sub_20BDDC1C8(v46, (uint64_t)"ReadObjectHeaders Invalid data at index ", 40);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(&__str, (__int128 *)&__dst);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__dst.__r_.__value_.__l.__data_);
    exception = __cxa_allocate_exception(0x20uLL);
    v39 = sub_20BDDC09C(exception, (uint64_t)&__str);
    __cxa_throw(v39, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if ((unint64_t)Alembic::Ogawa::v12::IData::getSize((Alembic::Ogawa::v12::IData *)v47) >= 0x21)
  {
    Size = Alembic::Ogawa::v12::IData::getSize((Alembic::Ogawa::v12::IData *)v47);
    sub_20BDFC9B8(&v44, Size - 32);
    v11 = v44;
    if (v44 != v45)
    {
      v12 = v45 - v44;
      Alembic::Ogawa::v12::IData::read(v47, v45 - v44, v44, 0, a3);
      v13 = 0;
      while (1)
      {
        if (v13 >= v12
          || (v14 = v13 + 4, v13 + 4 > v12)
          || ((v15 = *(unsigned int *)&v44[v13], v16 = v14 + v15, v13 = v14 + v15 + 1, (_DWORD)v15)
            ? (v17 = v13 > v12)
            : (v17 = 1),
              v17))
        {
LABEL_52:
          v11 = v44;
          break;
        }
        sub_20BDFC7D8(&__str, &v44[v14], v15);
        v18 = v44[v16];
        v19 = operator new(0x48uLL);
        v19[8] = 0;
        v19[7] = 0;
        *(_OWORD *)v19 = 0u;
        *((_OWORD *)v19 + 1) = 0u;
        *((_OWORD *)v19 + 2) = 0u;
        v19[6] = v19 + 7;
        sub_20BDE9D90(&v41, (uint64_t)v19);
        std::string::operator=((std::string *)v41, &__str);
        v20 = (std::string *)v41;
        if (*((char *)a4 + 23) >= 0)
          v21 = *((unsigned __int8 *)a4 + 23);
        else
          v21 = (size_t)a4[1];
        sub_20BDF6BDC((uint64_t)&v40, v21 + 1);
        if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v22 = &v40;
        else
          v22 = (std::string *)v40.__r_.__value_.__r.__words[0];
        if (v21)
        {
          if (*((char *)a4 + 23) >= 0)
            v23 = a4;
          else
            v23 = *a4;
          memmove(v22, v23, v21);
        }
        *(_WORD *)((char *)&v22->__r_.__value_.__l.__data_ + v21) = 47;
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_str = &__str;
        else
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v25 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        else
          v25 = __str.__r_.__value_.__l.__size_;
        v26 = std::string::append(&v40, (const std::string::value_type *)p_str, v25);
        v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
        __dst.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v27;
        v26->__r_.__value_.__l.__size_ = 0;
        v26->__r_.__value_.__r.__words[2] = 0;
        v26->__r_.__value_.__r.__words[0] = 0;
        std::string::operator=(v20 + 1, &__dst);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__dst.__r_.__value_.__l.__data_);
        if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v40.__r_.__value_.__l.__data_);
        if ((_DWORD)v18 == 255)
        {
          v29 = v16 + 5;
          if (v16 + 5 > v12)
          {
            v30 = 0;
            goto LABEL_43;
          }
          v31 = *(unsigned int *)&v44[v13];
          v13 = v29 + v31;
          if (v29 + v31 > v12)
          {
            v30 = 0;
            v13 = v16 + 5;
            goto LABEL_43;
          }
          sub_20BDFC7D8(&__dst, &v44[v29], v31);
          sub_20BDE9724(v41 + 48, &__dst);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__dst.__r_.__value_.__l.__data_);
        }
        else if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a5[1] - *a5) >> 3) > v18)
        {
          v28 = *a5 + 24 * v18;
          if ((_QWORD)v41 + 48 != v28)
            sub_20BDFC4AC((uint64_t **)(v41 + 48), *(__int128 **)v28, (__int128 *)(v28 + 8));
        }
        sub_20BDEA72C(a6, &v41);
        v30 = 1;
LABEL_43:
        v32 = (std::__shared_weak_count *)*((_QWORD *)&v41 + 1);
        if (*((_QWORD *)&v41 + 1))
        {
          v33 = (unint64_t *)(*((_QWORD *)&v41 + 1) + 8);
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
          if (!v34)
          {
            ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
            std::__shared_weak_count::__release_weak(v32);
          }
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__str.__r_.__value_.__l.__data_);
          if ((v30 & 1) == 0)
            goto LABEL_52;
        }
        else if ((v30 & 1) == 0)
        {
          goto LABEL_52;
        }
      }
    }
    if (v11)
    {
      v45 = v11;
      operator delete(v11);
    }
  }
  v35 = v48;
  if (v48)
  {
    p_shared_owners = (unint64_t *)&v48->__shared_owners_;
    do
      v37 = __ldaxr(p_shared_owners);
    while (__stlxr(v37 - 1, p_shared_owners));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
}

void sub_20BDFB6BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *a31,uint64_t a32)
{
  uint64_t v32;

  sub_20BDDC194((std::exception *)&a24);
  sub_20BDDBE98((uint64_t)&a31);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v32 - 112));
  _Unwind_Resume(a1);
}

void sub_20BDFB78C(unint64_t ***a1, unint64_t a2, unint64_t a3, uint64_t a4, _QWORD *a5, char **a6)
{
  size_t Size;
  unint64_t **v11;
  uint64_t v12;
  void *v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  int v18;
  char *v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unint64_t v25;
  int v26;
  int v27;
  int v28;
  unint64_t v29;
  int v30;
  int v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t v35;
  int v36;
  unint64_t *v37;
  char *v38;
  size_t v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t v44;
  size_t v45;
  uint64_t v46;
  _QWORD *v47;
  std::__shared_weak_count *v48;
  unint64_t *p_shared_owners;
  unint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *exception;
  _QWORD *v54;
  _QWORD *v55;
  char **v56;
  __int128 v57;
  uint64_t v58;
  __int128 v59;
  void *v60[2];
  char v61;
  std::string __p;
  std::string __str;
  Alembic::Ogawa::v12::IData *v64;
  std::__shared_weak_count *v65;

  Alembic::Ogawa::v12::IGroup::getData(*a1, a2, a3, &v64);
  if (!v64)
  {
    sub_20BDDBD68((uint64_t)&__str);
    sub_20BDDC1C8(&__str.__r_.__value_.__r.__words[2], (uint64_t)"ReadObjectHeaders Invalid data at index ", 40);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(&__p, (__int128 *)v60);
    if (v61 < 0)
      operator delete(v60[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v54 = sub_20BDDC09C(exception, (uint64_t)&__p);
    __cxa_throw(v54, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (Alembic::Ogawa::v12::IData::getSize(v64))
  {
    Size = Alembic::Ogawa::v12::IData::getSize(v64);
    sub_20BDFC9B8(v60, Size);
    v11 = (unint64_t **)v64;
    v12 = Alembic::Ogawa::v12::IData::getSize(v64);
    Alembic::Ogawa::v12::IData::read(v11, v12, v60[0], 0, a3);
    v13 = v60[1];
    v14 = (char *)v60[1] - (char *)v60[0];
    if (v60[1] != v60[0])
    {
      v55 = a5;
      v56 = a6;
      v15 = 0;
      while (1)
      {
        v16 = operator new(0x68uLL);
        *v16 = 0;
        v16[1] = 0;
        v16[2] = 0;
        *((_DWORD *)v16 + 6) = 1;
        v16[6] = 0;
        v16[5] = 0;
        v16[4] = v16 + 5;
        *((_DWORD *)v16 + 14) = 127;
        *((_BYTE *)v16 + 60) = 0;
        v16[8] = 0;
        v16[9] = 0;
        *((_WORD *)v16 + 40) = 257;
        *(_QWORD *)((char *)v16 + 92) = 0;
        *(_QWORD *)((char *)v16 + 84) = 0;
        sub_20BDEFDCC(&v59, (uint64_t)v16);
        v17 = v15 + 4;
        if (v15 + 4 > v14)
        {
          v18 = 7;
          goto LABEL_82;
        }
        v19 = (char *)v60[0];
        v20 = *(unsigned int *)((char *)v60[0] + v15);
        v21 = v59;
        *(_BYTE *)(v59 + 80) = v20 & 1;
        v22 = v20 & 3;
        if ((v20 & 3) == 0)
        {
          *(_DWORD *)(v21 + 24) = 0;
          v24 = (v20 >> 2) & 3;
          goto LABEL_68;
        }
        if (v22 != 1)
          v22 = 2;
        *(_DWORD *)(v21 + 24) = v22;
        v23 = v20 >> 4;
        if (v23 >= 0xE)
        {
          sub_20BDDBD68((uint64_t)&__str);
          sub_20BDDC1C8(&__str.__r_.__value_.__r.__words[2], (uint64_t)"Read invalid POD type: ", 23);
          std::ostream::operator<<();
          std::stringbuf::str();
          sub_20BDDBF20(&__p, &v57);
          if (SHIBYTE(v58) < 0)
            operator delete((void *)v57);
          v51 = __cxa_allocate_exception(0x20uLL);
          v52 = sub_20BDDC09C(v51, (uint64_t)&__p);
          __cxa_throw(v52, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
        }
        v24 = (v20 >> 2) & 3;
        *(_DWORD *)(v21 + 56) = v23;
        *(_BYTE *)(v21 + 60) = v20 >> 12;
        *(_BYTE *)(v21 + 81) = (v20 & 0x400) != 0;
        if (v24 == 2)
        {
          v25 = v15 + 8;
          if (v15 + 8 > v14)
            goto LABEL_20;
          v26 = *(_DWORD *)&v19[v17];
        }
        else if (v24 == 1)
        {
          v25 = v15 + 6;
          if (v15 + 6 > v14)
            goto LABEL_20;
          v26 = *(unsigned __int16 *)&v19[v17];
        }
        else
        {
          if (v24 || (v25 = v15 + 5, v15 + 5 > v14))
          {
LABEL_20:
            v26 = 0;
            goto LABEL_23;
          }
          v26 = v19[v17];
        }
        v17 = v25;
LABEL_23:
        *(_DWORD *)(v21 + 84) = v26;
        if ((v20 & 0x200) == 0)
        {
          if ((v20 & 0x800) == 0)
          {
            *(_DWORD *)(v21 + 88) = 1;
            v27 = v26 - 1;
            goto LABEL_47;
          }
LABEL_31:
          v27 = 0;
          *(_DWORD *)(v21 + 88) = 0;
          goto LABEL_47;
        }
        if (v24 == 2)
        {
          if (v17 + 4 <= v14)
          {
            v31 = *(_DWORD *)&v19[v17];
            v29 = v17 + 8;
            v17 += 4;
          }
          else
          {
            v31 = 0;
            v29 = v17 + 4;
          }
          *(_DWORD *)(v21 + 88) = v31;
          if (v29 > v14)
            goto LABEL_44;
          v27 = *(_DWORD *)&v19[v17];
        }
        else if (v24 == 1)
        {
          if (v17 + 2 <= v14)
          {
            v30 = *(unsigned __int16 *)&v19[v17];
            v29 = v17 + 4;
            v17 += 2;
          }
          else
          {
            v30 = 0;
            v29 = v17 + 2;
          }
          *(_DWORD *)(v21 + 88) = v30;
          if (v29 > v14)
            goto LABEL_44;
          v27 = *(unsigned __int16 *)&v19[v17];
        }
        else
        {
          if (v24)
            goto LABEL_31;
          if (v17 + 1 <= v14)
          {
            v28 = v19[v17];
            v29 = v17 + 2;
            ++v17;
          }
          else
          {
            v28 = 0;
            v29 = v17 + 1;
          }
          *(_DWORD *)(v21 + 88) = v28;
          if (v29 > v14)
          {
LABEL_44:
            v27 = 0;
            goto LABEL_47;
          }
          v27 = v19[v17];
        }
        v17 = v29;
LABEL_47:
        *(_DWORD *)(v21 + 92) = v27;
        if ((v20 & 0x100) == 0)
        {
          (*(void (**)(std::string *__return_ptr, uint64_t, _QWORD))(*(_QWORD *)a4 + 56))(&__str, a4, 0);
          sub_20BDE881C((_QWORD *)(v21 + 64), (uint64_t *)&__str);
          v32 = (std::__shared_weak_count *)__str.__r_.__value_.__l.__size_;
          if (!__str.__r_.__value_.__l.__size_)
            goto LABEL_68;
          v33 = (unint64_t *)(__str.__r_.__value_.__l.__size_ + 8);
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
          goto LABEL_66;
        }
        switch(v24)
        {
          case 2u:
            v35 = v17 + 4;
            if (v17 + 4 <= v14)
            {
              v36 = *(_DWORD *)&v19[v17];
              goto LABEL_62;
            }
            break;
          case 1u:
            v35 = v17 + 2;
            if (v17 + 2 <= v14)
            {
              v36 = *(unsigned __int16 *)&v19[v17];
              goto LABEL_62;
            }
            break;
          case 0u:
            v35 = v17 + 1;
            if (v17 + 1 <= v14)
            {
              v36 = v19[v17];
LABEL_62:
              v17 = v35;
              goto LABEL_63;
            }
            break;
        }
        v36 = 0;
LABEL_63:
        *(_DWORD *)(v21 + 96) = v36;
        (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)a4 + 56))(&__str, a4);
        sub_20BDE881C((_QWORD *)(v21 + 64), (uint64_t *)&__str);
        v32 = (std::__shared_weak_count *)__str.__r_.__value_.__l.__size_;
        if (!__str.__r_.__value_.__l.__size_)
          goto LABEL_68;
        v37 = (unint64_t *)(__str.__r_.__value_.__l.__size_ + 8);
        do
          v34 = __ldaxr(v37);
        while (__stlxr(v34 - 1, v37));
LABEL_66:
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
LABEL_68:
        if (v24 == 2)
        {
          v15 = v17 + 4;
          if (v17 + 4 > v14)
            goto LABEL_78;
          v38 = (char *)v60[0];
          v39 = *(unsigned int *)((char *)v60[0] + v17);
          if (*(_DWORD *)((char *)v60[0] + v17))
            goto LABEL_80;
        }
        else if (v24 == 1)
        {
          v15 = v17 + 2;
          if (v17 + 2 > v14)
            goto LABEL_78;
          v38 = (char *)v60[0];
          v39 = *(unsigned __int16 *)((char *)v60[0] + v17);
          if (*(_WORD *)((char *)v60[0] + v17))
            goto LABEL_80;
        }
        else
        {
          if (v24 || (v15 = v17 + 1, v17 + 1 > v14))
          {
LABEL_78:
            v18 = 7;
            v15 = v17;
            goto LABEL_82;
          }
          v38 = (char *)v60[0];
          v39 = *((unsigned __int8 *)v60[0] + v17);
          if (*((_BYTE *)v60[0] + v17))
          {
LABEL_80:
            v40 = v15 + v39;
            if (v15 + v39 <= v14)
            {
              sub_20BDFC7D8(&__str, &v38[v15], v39);
              std::string::operator=((std::string *)v59, &__str);
              v44 = (v20 >> 20);
              if ((_DWORD)v44 == 255)
              {
                if (v24 == 2)
                {
                  v15 = v40 + 4;
                  if (v40 + 4 <= v14)
                  {
                    v45 = *(unsigned int *)((char *)v60[0] + v40);
                    goto LABEL_105;
                  }
                }
                else
                {
                  if (v24 != 1)
                  {
                    v15 = v40 + 1;
                    if (v40 + 1 <= v14)
                    {
                      v45 = *((unsigned __int8 *)v60[0] + v40);
                    }
                    else
                    {
                      v45 = 0;
                      v15 = v40;
                    }
LABEL_105:
                    v40 = v15 + v45;
                    if (v15 + v45 > v14)
                    {
                      v18 = 1;
                      goto LABEL_117;
                    }
                    if (v15 == v14)
                    {
                      *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
                      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
                      if ((std::string *)(v59 + 32) == &__p)
                      {
                        v47 = 0;
                      }
                      else
                      {
                        sub_20BDFC4AC((uint64_t **)(v59 + 32), (__int128 *)&__p.__r_.__value_.__r.__words[1], (__int128 *)&__p.__r_.__value_.__r.__words[1]);
                        v47 = (_QWORD *)__p.__r_.__value_.__l.__size_;
                      }
                      sub_20BDE9D48((uint64_t)&__p, v47);
                    }
                    else
                    {
                      sub_20BDFC7D8(&__p, (char *)v60[0] + v15, v45);
                      *((_QWORD *)&v57 + 1) = 0;
                      v58 = 0;
                      *(_QWORD *)&v57 = (char *)&v57 + 8;
                      sub_20BDE9724((uint64_t)&v57, &__p);
                      if ((__int128 *)(v59 + 32) != &v57)
                        sub_20BDFC4AC((uint64_t **)(v59 + 32), (__int128 *)v57, (__int128 *)((char *)&v57 + 8));
                      sub_20BDE9D48((uint64_t)&v57, *((_QWORD **)&v57 + 1));
                      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(__p.__r_.__value_.__l.__data_);
                    }
LABEL_116:
                    sub_20BDEA72C(v56, &v59);
                    v18 = 0;
                    v15 = v40;
LABEL_117:
                    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__str.__r_.__value_.__l.__data_);
                    goto LABEL_82;
                  }
                  v15 = v40 + 2;
                  if (v40 + 2 <= v14)
                  {
                    v45 = *(unsigned __int16 *)((char *)v60[0] + v40);
                    goto LABEL_105;
                  }
                }
                v45 = 0;
                v15 = v40;
                goto LABEL_105;
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v55[1] - *v55) >> 3) > v44)
              {
                v46 = *v55 + 24 * (v20 >> 20);
                if ((_QWORD)v59 + 32 != v46)
                  sub_20BDFC4AC((uint64_t **)(v59 + 32), *(__int128 **)v46, (__int128 *)(v46 + 8));
              }
              goto LABEL_116;
            }
          }
        }
        v18 = 7;
LABEL_82:
        v41 = (std::__shared_weak_count *)*((_QWORD *)&v59 + 1);
        if (*((_QWORD *)&v59 + 1))
        {
          v42 = (unint64_t *)(*((_QWORD *)&v59 + 1) + 8);
          do
            v43 = __ldaxr(v42);
          while (__stlxr(v43 - 1, v42));
          if (!v43)
          {
            ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
            std::__shared_weak_count::__release_weak(v41);
          }
        }
        if (v18 || v15 >= v14)
        {
          v13 = v60[0];
          break;
        }
      }
    }
    if (v13)
    {
      v60[1] = v13;
      operator delete(v13);
    }
  }
  v48 = v65;
  if (v65)
  {
    p_shared_owners = (unint64_t *)&v65->__shared_owners_;
    do
      v50 = __ldaxr(p_shared_owners);
    while (__stlxr(v50 - 1, p_shared_owners));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
}

void sub_20BDFBF48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,_QWORD *a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  sub_20BDE9D48((uint64_t)&a21, a22);
  if (a33 < 0)
    operator delete(__p);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a16);
  if (a18)
  {
    a19 = (uint64_t)a18;
    operator delete(a18);
  }
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v33 - 104));
  _Unwind_Resume(a1);
}

void sub_20BDFC03C(Alembic::Ogawa::v12::IData **a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  size_t Size;
  char *v7;
  Alembic::Ogawa::v12::IData *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *exception;
  _QWORD *v20;
  __int128 v21;
  uint64_t v22;
  std::string __p;
  void *v24;
  char *v25;
  uint64_t v26[33];

  v25 = 0;
  v26[0] = 0;
  v24 = &v25;
  v4 = *(uint64_t **)(a2 + 8);
  if ((unint64_t)v4 >= *(_QWORD *)(a2 + 16))
  {
    v5 = sub_20BDFCA28((uint64_t *)a2, (const void ***)&v24);
  }
  else
  {
    sub_20BDEBF8C(v4, (const void ***)&v24);
    v5 = (uint64_t)(v4 + 3);
    *(_QWORD *)(a2 + 8) = v4 + 3;
  }
  *(_QWORD *)(a2 + 8) = v5;
  sub_20BDE9D48((uint64_t)&v24, v25);
  if ((unint64_t)Alembic::Ogawa::v12::IData::getSize(*a1) > 0x10000)
  {
    sub_20BDDBD68((uint64_t)&v24);
    sub_20BDDC1C8(v26, (uint64_t)"Read invalid: Indexed MetaData buffer unexpectedly big.", 55);
    std::stringbuf::str();
    sub_20BDDBF20(&__p, &v21);
    if (SHIBYTE(v22) < 0)
      operator delete((void *)v21);
    exception = __cxa_allocate_exception(0x20uLL);
    v20 = sub_20BDDC09C(exception, (uint64_t)&__p);
    __cxa_throw(v20, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  Size = Alembic::Ogawa::v12::IData::getSize(*a1);
  sub_20BDFC9B8(&v24, Size);
  v7 = (char *)v24;
  if (v24 != v25)
  {
    v8 = *a1;
    v9 = Alembic::Ogawa::v12::IData::getSize(v8);
    Alembic::Ogawa::v12::IData::read((unint64_t **)v8, v9, v24, 0, 0);
    v7 = v25;
    v10 = v25 - (_BYTE *)v24;
    if (v25 != v24)
    {
      v11 = 0;
      do
      {
        v12 = v11 + 1;
        v13 = *((unsigned __int8 *)v24 + v11);
        v14 = ++v11 + v13;
        if (v14 <= v10)
        {
          if (v12 == v10)
          {
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
            v15 = *(_QWORD *)(a2 + 8);
            if (v15 >= *(_QWORD *)(a2 + 16))
            {
              v16 = sub_20BDFCD40((uint64_t *)a2, (const void ***)&__p);
            }
            else
            {
              sub_20BDEBF8C(*(uint64_t **)(a2 + 8), (const void ***)&__p);
              v16 = v15 + 24;
              *(_QWORD *)(a2 + 8) = v15 + 24;
            }
            *(_QWORD *)(a2 + 8) = v16;
            sub_20BDE9D48((uint64_t)&__p, (_QWORD *)__p.__r_.__value_.__l.__size_);
          }
          else
          {
            sub_20BDFC7D8(&__p, (char *)v24 + v12, v13);
            *((_QWORD *)&v21 + 1) = 0;
            v22 = 0;
            *(_QWORD *)&v21 = (char *)&v21 + 8;
            sub_20BDE9724((uint64_t)&v21, &__p);
            v17 = *(_QWORD *)(a2 + 8);
            if (v17 >= *(_QWORD *)(a2 + 16))
            {
              v18 = sub_20BDFCD40((uint64_t *)a2, (const void ***)&v21);
            }
            else
            {
              sub_20BDEBF8C(*(uint64_t **)(a2 + 8), (const void ***)&v21);
              v18 = v17 + 24;
              *(_QWORD *)(a2 + 8) = v17 + 24;
            }
            *(_QWORD *)(a2 + 8) = v18;
            sub_20BDE9D48((uint64_t)&v21, *((_QWORD **)&v21 + 1));
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
          }
          v11 = v14;
        }
      }
      while (v11 < v10);
      v7 = (char *)v24;
    }
  }
  if (v7)
  {
    v25 = v7;
    operator delete(v7);
  }
}

void sub_20BDFC2B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20)
{
  sub_20BDDC194((std::exception *)&a12);
  sub_20BDDBE98((uint64_t)&__p);
  _Unwind_Resume(a1);
}

double *sub_20BDFC364(double *a1, int a2, double a3)
{
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v4;
  unsigned int v5;
  double v6;
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v7;
  unsigned int v8;
  _QWORD *v10;
  _QWORD *exception;
  _QWORD *v12;
  __int128 __p;
  char v14;
  _QWORD v15[4];
  _BYTE v16[16];
  _QWORD v17[33];

  *(_DWORD *)a1 = a2;
  a1[1] = a3;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)a1) != a3
    || (v5 = *(_DWORD *)a1,
        v4 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v4),
        v5 != (_DWORD)v4))
  {
    v6 = a1[1];
    if (v6 <= 0.0
      || v6 >= Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle(v4)
      || !*(_DWORD *)a1
      || (v8 = *(_DWORD *)a1, v8 >= Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v7)))
    {
      sub_20BDDBD68((uint64_t)v16);
      sub_20BDDC1C8(v17, (uint64_t)"Invalid Time Sampling Type, time per cycle: ", 44);
      v10 = (_QWORD *)std::ostream::operator<<();
      sub_20BDDC1C8(v10, (uint64_t)" samples per cycle: ", 20);
      std::ostream::operator<<();
      std::stringbuf::str();
      sub_20BDDBF20(v15, &__p);
      if (v14 < 0)
        operator delete((void *)__p);
      exception = __cxa_allocate_exception(0x20uLL);
      v12 = sub_20BDDC09C(exception, (uint64_t)v15);
      __cxa_throw(v12, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
  }
  return a1;
}

void sub_20BDFC484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t **sub_20BDFC4AC(uint64_t **result, __int128 *a2, __int128 *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  __int128 *v9;
  uint64_t **v10;
  __int128 *v11;
  BOOL v12;
  __int128 *v13;
  __int128 *v14;
  uint64_t **v15;
  uint64_t *v16;
  const void **v17;
  uint64_t v18;

  v5 = result;
  if (result[2])
  {
    v6 = *result;
    v7 = result[1];
    *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1])
      v8 = (uint64_t *)v6[1];
    else
      v8 = v6;
    v15 = result;
    v16 = v8;
    v17 = (const void **)v8;
    if (v8)
    {
      v16 = sub_20BDFC6B0((uint64_t)v8);
      if (a2 != a3)
      {
        v9 = a2;
        do
        {
          std::string::operator=((std::string *)(v8 + 4), (const std::string *)(v9 + 2));
          std::string::operator=((std::string *)(v8 + 7), (const std::string *)((char *)v9 + 56));
          v10 = (uint64_t **)sub_20BDFC638((uint64_t)v5, &v18, v17 + 4);
          sub_20BDDE1B4(v5, v18, v10, (uint64_t *)v17);
          v17 = (const void **)v16;
          if (v16)
            v16 = sub_20BDFC6B0((uint64_t)v16);
          v11 = (__int128 *)*((_QWORD *)v9 + 1);
          if (v11)
          {
            do
            {
              a2 = v11;
              v11 = *(__int128 **)v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              a2 = (__int128 *)*((_QWORD *)v9 + 2);
              v12 = *(_QWORD *)a2 == (_QWORD)v9;
              v9 = a2;
            }
            while (!v12);
          }
          v8 = (uint64_t *)v17;
          if (v17)
            v12 = a2 == a3;
          else
            v12 = 1;
          v9 = a2;
        }
        while (!v12);
      }
    }
    result = (uint64_t **)sub_20BDFC704((uint64_t)&v15);
  }
  if (a2 != a3)
  {
    do
    {
      result = (uint64_t **)sub_20BDFC758(v5, a2 + 2);
      v13 = (__int128 *)*((_QWORD *)a2 + 1);
      if (v13)
      {
        do
        {
          v14 = v13;
          v13 = *(__int128 **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          v14 = (__int128 *)*((_QWORD *)a2 + 2);
          v12 = *(_QWORD *)v14 == (_QWORD)a2;
          a2 = v14;
        }
        while (!v12);
      }
      a2 = v14;
    }
    while (v14 != a3);
  }
  return result;
}

void sub_20BDFC624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_20BDFC704((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDFC638(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *result;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v5 = (_QWORD *)v4;
        if (!sub_20BDDDF74(v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v5;
        result = v5;
        if (!*v5)
          goto LABEL_9;
      }
      v4 = v5[1];
    }
    while (v4);
    result = v5 + 1;
  }
  else
  {
    result = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v5;
  return result;
}

_QWORD *sub_20BDFC6B0(uint64_t a1)
{
  _QWORD *result;
  _QWORD *v3;
  _QWORD *v4;

  result = *(_QWORD **)(a1 + 16);
  if (result)
  {
    v3 = (_QWORD *)*result;
    if (*result == a1)
    {
      *result = 0;
      while (1)
      {
        v4 = (_QWORD *)result[1];
        if (!v4)
          break;
        do
        {
          result = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; v3 = (_QWORD *)result[1])
      {
        do
        {
          result = v3;
          v3 = (_QWORD *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t sub_20BDFC704(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  sub_20BDE9D48(*(_QWORD *)a1, *(_QWORD **)(a1 + 16));
  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    v3 = (_QWORD *)v2[2];
    if (v3)
    {
      do
      {
        v2 = v3;
        v3 = (_QWORD *)v3[2];
      }
      while (v3);
      *(_QWORD *)(a1 + 8) = v2;
    }
    sub_20BDE9D48(*(_QWORD *)a1, v2);
  }
  return a1;
}

uint64_t *sub_20BDFC758(uint64_t **a1, __int128 *a2)
{
  uint64_t **v3;
  uint64_t *v4;
  uint64_t v6;
  uint64_t *v7[3];

  sub_20BDEC290((uint64_t)a1, a2, (uint64_t)v7);
  v3 = (uint64_t **)sub_20BDFC638((uint64_t)a1, &v6, (const void **)v7[0] + 4);
  sub_20BDDE1B4(a1, v6, v3, v7[0]);
  v4 = v7[0];
  v7[0] = 0;
  sub_20BDDE3A0((uint64_t)v7, 0);
  return v4;
}

void sub_20BDFC7C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDDE3A0((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BDFC7D8(_QWORD *__dst, void *__src, size_t __len)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    sub_20BDDC038();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v6 = __dst;
    if (!__len)
      goto LABEL_9;
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

void sub_20BDFC880(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    sub_20BDFC8B0((char **)a1, a2 - v2);
  }
}

void sub_20BDFC8B0(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 3);
    if (v10 >> 61)
      sub_20BDDF694();
    v11 = v9 >> 3;
    v12 = v5 - v8;
    if (v12 >> 2 > v10)
      v10 = v12 >> 2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)sub_20BDDF6A8(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v11];
    v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      v18 = *((_QWORD *)v7 - 1);
      v7 -= 8;
      *((_QWORD *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

_QWORD *sub_20BDFC9B8(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDE2970(a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_20BDFCA0C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BDFCA28(uint64_t *a1, const void ***a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  void *v13;
  uint64_t *v14;
  uint64_t *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    sub_20BDDF694();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)sub_20BDE4FF4(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (uint64_t *)&v10[24 * v4];
  v16 = &v10[24 * v9];
  sub_20BDEBF8C(v14, a2);
  v15 = v14 + 3;
  sub_20BDFCB2C(a1, &v13);
  v11 = a1[1];
  sub_20BDFCCCC(&v13);
  return v11;
}

void sub_20BDFCB18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDFCCCC((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFCB2C(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_20BDFCBA0((uint64_t)(a1 + 2), a1[1], (const void ***)a1[1], *a1, (const void ***)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_20BDFCBA0(uint64_t a1, uint64_t a2, const void ***a3, uint64_t a4, const void ***a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  const void ***v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 -= 3;
      sub_20BDEBF8C((uint64_t *)(v7 - 24), v9);
      v7 = *((_QWORD *)&v15 + 1) - 24;
      *((_QWORD *)&v15 + 1) -= 24;
    }
    while (v9 != a5);
    v10 = v15;
  }
  v13 = 1;
  sub_20BDFCC58((uint64_t)v12);
  return v10;
}

void sub_20BDFCC44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_20BDFCC58((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFCC58(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_20BDFCC8C(a1);
  return a1;
}

void sub_20BDFCC8C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    sub_20BDE9D48(v1, *(_QWORD **)(v1 + 8));
    v1 += 24;
  }
}

void **sub_20BDFCCCC(void **a1)
{
  sub_20BDFCCFC((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void sub_20BDFCCFC(uint64_t a1)
{
  uint64_t i;
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 24;
    sub_20BDE9D48(i - 24, *(_QWORD **)(i - 16));
  }
}

uint64_t sub_20BDFCD40(uint64_t *a1, const void ***a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  void *v13;
  uint64_t *v14;
  uint64_t *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    sub_20BDDF694();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)sub_20BDE4FF4(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (uint64_t *)&v10[24 * v4];
  v16 = &v10[24 * v9];
  sub_20BDEBF8C(v14, a2);
  v15 = v14 + 3;
  sub_20BDFCB2C(a1, &v13);
  v11 = a1[1];
  sub_20BDFCCCC(&v13);
  return v11;
}

void sub_20BDFCE30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BDFCCCC((void **)va);
  _Unwind_Resume(a1);
}

double Alembic::AbcCoreOgawa::v12::WriteArchive::operator()@<D0>(__int128 *a1@<X1>, const void ***a2@<X2>, _OWORD *a3@<X8>)
{
  void *v6;
  double result;
  __int128 v8;

  v6 = operator new(0xF8uLL);
  sub_20BDEAFA4((uint64_t)v6, a1, a2);
  sub_20BDFD254((uint64_t *)&v8, (uint64_t)v6);
  result = *(double *)&v8;
  *a3 = v8;
  return result;
}

void sub_20BDFCEAC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

double Alembic::AbcCoreOgawa::v12::WriteArchive::operator()@<D0>(uint64_t a1@<X1>, const void ***a2@<X2>, _OWORD *a3@<X8>)
{
  void *v6;
  double result;
  __int128 v8;

  v6 = operator new(0xF8uLL);
  sub_20BDEB320((uint64_t)v6, a1, a2);
  sub_20BDFD254((uint64_t *)&v8, (uint64_t)v6);
  result = *(double *)&v8;
  *a3 = v8;
  return result;
}

void sub_20BDFCF20(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t Alembic::AbcCoreOgawa::v12::ReadArchive::ReadArchive(uint64_t this)
{
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)this = 1;
  *(_BYTE *)(this + 8) = 1;
  return this;
}

{
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)this = 1;
  *(_BYTE *)(this + 8) = 1;
  return this;
}

uint64_t Alembic::AbcCoreOgawa::v12::ReadArchive::ReadArchive(uint64_t this, uint64_t a2, char a3)
{
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)this = a2;
  *(_BYTE *)(this + 8) = a3;
  return this;
}

{
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)this = a2;
  *(_BYTE *)(this + 8) = a3;
  return this;
}

uint64_t Alembic::AbcCoreOgawa::v12::ReadArchive::ReadArchive(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = 1;
  *(_BYTE *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  sub_20BDFD340((_QWORD *)(a1 + 16), *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3);
  return a1;
}

{
  *(_QWORD *)a1 = 1;
  *(_BYTE *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  sub_20BDFD340((_QWORD *)(a1 + 16), *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3);
  return a1;
}

void Alembic::AbcCoreOgawa::v12::ReadArchive::operator()(uint64_t a1@<X0>, __int128 *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v4;
  void *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  void *v11;
  unint64_t *v12;
  __int128 v13;

  *a3 = 0;
  a3[1] = 0;
  v4 = (_QWORD *)(a1 + 16);
  if (*(_QWORD *)(a1 + 16) == *(_QWORD *)(a1 + 24))
  {
    v11 = operator new(0x198uLL);
    sub_20BDE9430((uint64_t)v11, a2, *(_QWORD *)a1, *(unsigned __int8 *)(a1 + 8));
    sub_20BDFD3B8((uint64_t *)&v13, (uint64_t)v11);
    sub_20BDE82DC((uint64_t)a3, &v13);
    v6 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
    if (!*((_QWORD *)&v13 + 1))
      return;
    v12 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v8 = __ldaxr(v12);
    while (__stlxr(v8 - 1, v12));
  }
  else
  {
    v5 = operator new(0x198uLL);
    sub_20BDE9720((uint64_t)v5, v4);
    sub_20BDFD3B8((uint64_t *)&v13, (uint64_t)v5);
    sub_20BDE82DC((uint64_t)a3, &v13);
    v6 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
    if (!*((_QWORD *)&v13 + 1))
      return;
    v7 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
  }
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_20BDFD124(_Unwind_Exception *a1)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v1;
  void *v2;

  operator delete(v2);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v1);
  _Unwind_Resume(a1);
}

uint64_t *Alembic::AbcCoreOgawa::v12::ReadArchive::operator()@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v4;
  void *v5;
  uint64_t *result;
  void *v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;

  v11 = 0;
  v12 = 0;
  v4 = (_QWORD *)(a1 + 16);
  if (*(_QWORD *)(a1 + 16) == *(_QWORD *)(a1 + 24))
  {
    v9 = operator new(0x198uLL);
    sub_20BDE9430((uint64_t)v9, a2, *(_QWORD *)a1, *(unsigned __int8 *)(a1 + 8));
    if ((*(unsigned int (**)(void *))(*(_QWORD *)v9 + 80))(v9) == -1)
    {
      result = (uint64_t *)(*(uint64_t (**)(void *))(*(_QWORD *)v9 + 8))(v9);
      *a3 = 0;
      a3[1] = 0;
      return result;
    }
    result = sub_20BDFD3B8((uint64_t *)&v10, (uint64_t)v9);
  }
  else
  {
    v5 = operator new(0x198uLL);
    sub_20BDE9720((uint64_t)v5, v4);
    result = sub_20BDFD3B8((uint64_t *)&v10, (uint64_t)v5);
  }
  *(_OWORD *)a3 = v10;
  return result;
}

void sub_20BDFD224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_20BDFD254(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518B80;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 16);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BDFD2B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDFD2D4(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BDFD2E8(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BDFD300(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518BD0))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDFD340(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = sub_20BDDF654(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20BDFD39C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_20BDFD3B8(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518BF8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BDFD414(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BDFD438(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BDFD44C(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BDFD464(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518C48))
    return a1 + 24;
  else
    return 0;
}

_QWORD *sub_20BDFD4A4(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *exception;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *__p[2];
  char v23;
  _QWORD v24[4];
  _BYTE v25[16];
  _QWORD v26[33];

  result[1] = 0;
  result[2] = 0;
  *result = off_24C518C70;
  result[3] = *a2;
  v4 = a2[1];
  result[4] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  result[5] = *a3;
  v7 = a3[1];
  result[6] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  result[7] = *a4;
  v10 = result + 7;
  v11 = a4[1];
  result[8] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (!result[3])
  {
    sub_20BDDBD68((uint64_t)v25);
    sub_20BDDC1C8(v26, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v24, (__int128 *)__p);
    if (v23 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v15 = sub_20BDDC09C(exception, (uint64_t)v24);
    __cxa_throw(v15, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!result[5])
  {
    sub_20BDDBD68((uint64_t)v25);
    sub_20BDDC1C8(v26, (uint64_t)"Invalid scalar property group", 29);
    std::stringbuf::str();
    sub_20BDDBF20(v24, (__int128 *)__p);
    if (v23 < 0)
      operator delete(__p[0]);
    v16 = __cxa_allocate_exception(0x20uLL);
    v17 = sub_20BDDC09C(v16, (uint64_t)v24);
    __cxa_throw(v17, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*v10)
  {
    sub_20BDDBD68((uint64_t)v25);
    sub_20BDDC1C8(v26, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v24, (__int128 *)__p);
    if (v23 < 0)
      operator delete(__p[0]);
    v18 = __cxa_allocate_exception(0x20uLL);
    v19 = sub_20BDDC09C(v18, (uint64_t)v24);
    __cxa_throw(v19, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (*(_DWORD *)(*v10 + 24) != 1)
  {
    sub_20BDDBD68((uint64_t)v25);
    sub_20BDDC1C8(v26, (uint64_t)"Attempted to create a ScalarPropertyReader from a non-array property type", 73);
    std::stringbuf::str();
    sub_20BDDBF20(v24, (__int128 *)__p);
    if (v23 < 0)
      operator delete(__p[0]);
    v20 = __cxa_allocate_exception(0x20uLL);
    v21 = sub_20BDDC09C(v20, (uint64_t)v24);
    __cxa_throw(v21, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return result;
}

void sub_20BDFD764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  Alembic::AbcCoreAbstract::v12::ScalarPropertyReader *v4;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v5;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v6;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v7;
  std::__shared_weak_count *v9;
  std::exception v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v10.__vftable = va_arg(va1, std::exception_vtbl *);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v7);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v6);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v5);
  v9 = (std::__shared_weak_count *)*((_QWORD *)v4 + 2);
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  Alembic::AbcCoreAbstract::v12::ScalarPropertyReader::~ScalarPropertyReader(v4);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFD7F4(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t sub_20BDFD7FC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 24))(*(_QWORD *)(a1 + 24));
}

uint64_t sub_20BDFD80C@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 32);
  *a2 = *(_QWORD *)(result + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

double sub_20BDFD830@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_20BDFD868(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 56) + 84);
}

BOOL sub_20BDFD874(uint64_t a1)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 56) + 88) == 0;
}

void sub_20BDFD888(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v7;
  Alembic::Ogawa::v12::IData *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  Alembic::Ogawa::v12::IData *v21;
  uint64_t Size;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  __n128 v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  Alembic::Ogawa::v12::IData *v39;
  std::__shared_weak_count *v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  void *lpsrc;
  std::__shared_weak_count *v44;
  Alembic::Ogawa::v12::IData *v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;

  v7 = sub_20BDE6388(*(unsigned int **)(a1 + 56), a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 24))(&v41, a1);
  (*(void (**)(void **__return_ptr))(*(_QWORD *)v41 + 24))(&lpsrc);
  if (lpsrc
  {
    v9 = v44;
    v45 = v8;
    v46 = v44;
    if (v44)
    {
      p_shared_owners = (unint64_t *)&v44->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
  }
  else
  {
    v9 = 0;
    v8 = 0;
    v45 = 0;
    v46 = 0;
  }
  sub_20BDE9C40((uint64_t)v8, &v47);
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v14 = v44;
  if (v44)
  {
    v15 = (unint64_t *)&v44->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v42;
  if (v42)
  {
    v18 = (unint64_t *)&v42->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = *(_QWORD *)(v47 + 8);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v7, v20, &v45);
  v21 = v45;
  if (v45)
  {
    lpsrc = *(void **)(*(_QWORD *)(a1 + 56) + 56);
    if ((int)lpsrc <= 11)
    {
      Size = Alembic::Ogawa::v12::IData::getSize(v45);
      if (Size != sub_20BDE00C8((int *)&lpsrc) + 16)
        goto LABEL_39;
      v21 = v45;
    }
    v23 = Alembic::Ogawa::v12::IData::getSize(v21);
    v24 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v25 = sub_20BDE00C8((int *)(v24 + 56));
    v26 = v23 - 16;
    if (v23 >= 0x10 && v25 >= v26 && (!a4 || v26 <= a4))
    {
      v39 = v45;
      v40 = v46;
      if (v46)
      {
        v27 = (unint64_t *)&v46->__shared_owners_;
        do
          v28 = __ldxr(v27);
        while (__stxr(v28 + 1, v27));
      }
      v29.n128_u64[0] = sub_20BDFA8FC(a3, &v39, v20, (int *)&lpsrc, (int)lpsrc).n64_u64[0];
      v30 = v40;
      if (v40)
      {
        v31 = (unint64_t *)&v40->__shared_owners_;
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *, __n128))v30->__on_zero_shared)(v30, v29);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
    }
  }
LABEL_39:
  v33 = v46;
  if (v46)
  {
    v34 = (unint64_t *)&v46->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  v36 = v48;
  if (v48)
  {
    v37 = (unint64_t *)&v48->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
}

void sub_20BDFDB6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a15);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFDBD0(uint64_t a1, double a2)
{
  uint64_t v3;
  double **v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t FloorIndex;
  unint64_t *v9;
  unint64_t v10;

  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(double ***)(v3 + 64);
  v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v3 = *(_QWORD *)(a1 + 56);
  }
  FloorIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5)
  {
    v9 = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return FloorIndex;
}

void sub_20BDFDC70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFDC84(uint64_t a1, double a2)
{
  uint64_t v3;
  double **v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t CeilIndex;
  unint64_t *v9;
  unint64_t v10;

  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(double ***)(v3 + 64);
  v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v3 = *(_QWORD *)(a1 + 56);
  }
  CeilIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getCeilIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5)
  {
    v9 = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return CeilIndex;
}

void sub_20BDFDD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFDD38(uint64_t a1, double a2)
{
  uint64_t v3;
  double **v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(double ***)(v3 + 64);
  v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v3 = *(_QWORD *)(a1 + 56);
  }
  v8 = Alembic::AbcCoreAbstract::v12::TimeSampling::getNearIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5)
  {
    v9 = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return v8;
}

void sub_20BDFDDD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BDFDDEC(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = off_24C518C70;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 7));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 5));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 3));
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  Alembic::AbcCoreAbstract::v12::ScalarPropertyReader::~ScalarPropertyReader((Alembic::AbcCoreAbstract::v12::ScalarPropertyReader *)a1);
}

void sub_20BDFDE38(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  void *v3;

  *a1 = off_24C518C70;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 7));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 5));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 3));
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  Alembic::AbcCoreAbstract::v12::ScalarPropertyReader::~ScalarPropertyReader((Alembic::AbcCoreAbstract::v12::ScalarPropertyReader *)a1);
  operator delete(v3);
}

_QWORD *sub_20BDFDE88(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD *exception;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *__p[2];
  char v24;
  _QWORD v25[4];
  _BYTE v26[16];
  _QWORD v27[33];

  result[1] = 0;
  result[2] = 0;
  *result = off_24C518D38;
  result[3] = 0;
  result[4] = 0;
  result[5] = *a2;
  v5 = a2[1];
  result[6] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  result[7] = *a4;
  v8 = result + 7;
  v9 = a4[1];
  result[8] = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  result[9] = 0;
  result[10] = 0;
  result[11] = *a3;
  v12 = a3[1];
  result[12] = v12;
  if (v12)
  {
    v13 = (unint64_t *)(v12 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  result[13] = a5;
  if (!result[5])
  {
    sub_20BDDBD68((uint64_t)v26);
    sub_20BDDC1C8(v27, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v25, (__int128 *)__p);
    if (v24 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v16 = sub_20BDDC09C(exception, (uint64_t)v25);
    __cxa_throw(v16, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!*v8)
  {
    sub_20BDDBD68((uint64_t)v26);
    sub_20BDDC1C8(v27, (uint64_t)"Invalid property header", 23);
    std::stringbuf::str();
    sub_20BDDBF20(v25, (__int128 *)__p);
    if (v24 < 0)
      operator delete(__p[0]);
    v17 = __cxa_allocate_exception(0x20uLL);
    v18 = sub_20BDDC09C(v17, (uint64_t)v25);
    __cxa_throw(v18, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!result[11])
  {
    sub_20BDDBD68((uint64_t)v26);
    sub_20BDDC1C8(v27, (uint64_t)"Invalid group", 13);
    std::stringbuf::str();
    sub_20BDDBF20(v25, (__int128 *)__p);
    if (v24 < 0)
      operator delete(__p[0]);
    v19 = __cxa_allocate_exception(0x20uLL);
    v20 = sub_20BDDC09C(v19, (uint64_t)v25);
    __cxa_throw(v20, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (*(_DWORD *)(*v8 + 24) != 1)
  {
    sub_20BDDBD68((uint64_t)v26);
    sub_20BDDC1C8(v27, (uint64_t)"Attempted to create a ScalarPropertyWriter from a non-scalar property type", 74);
    std::stringbuf::str();
    sub_20BDDBF20(v25, (__int128 *)__p);
    if (v24 < 0)
      operator delete(__p[0]);
    v21 = __cxa_allocate_exception(0x20uLL);
    v22 = sub_20BDDC09C(v21, (uint64_t)v25);
    __cxa_throw(v22, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return result;
}

void sub_20BDFE164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  Alembic::AbcCoreAbstract::v12::ScalarPropertyWriter *v4;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v5;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v6;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v7;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v8;
  std::__shared_weak_count *v10;
  std::exception v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v11.__vftable = va_arg(va1, std::exception_vtbl *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v7);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v6);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v5);
  v10 = (std::__shared_weak_count *)*((_QWORD *)v4 + 2);
  if (v10)
    std::__shared_weak_count::__release_weak(v10);
  Alembic::AbcCoreAbstract::v12::ScalarPropertyWriter::~ScalarPropertyWriter(v4);
  _Unwind_Resume(a1);
}

void sub_20BDFE1FC(uint64_t a1)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  void *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;

  *(_QWORD *)a1 = off_24C518D38;
  v2 = (pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 40);
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a1 + 40) + 24))(&v24);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v24 + 24))(&v26);
  v3 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 72))(v26, *(unsigned int *)(*(_QWORD *)(a1 + 56) + 96));
  v7 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 84);
  if (v7)
    v8 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 92) == 0;
  else
    v8 = 0;
  if (v8)
    v9 = 1;
  else
    v9 = v7;
  if (v6 < v9)
    (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v26 + 80))(v26, *(unsigned int *)(*(_QWORD *)(a1 + 56) + 96), v9);
  Alembic::Util::v12::SpookyHash::Init((uint64_t)&v24, 0, 0);
  sub_20BDFFE14(*(_QWORD *)(a1 + 56), (Alembic::Util::v12::SpookyHash *)&v24);
  if ((_DWORD)v9)
    Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)&v24, (_QWORD *)(a1 + 72), 0x10uLL);
  v22 = 0;
  v23 = 0;
  Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)&v24, &v23, (unint64_t *)&v22, v10, v11);
  v12 = *(void **)v2;
  if (*(_QWORD *)v2
  {
    v13 = *(std::__shared_weak_count **)(a1 + 48);
    if (v13)
    {
      v14 = (unint64_t *)&v13->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
  }
  else
  {
    v13 = 0;
  }
  sub_20BDF2A44((uint64_t)v12, *(_QWORD *)(a1 + 104), v23, v22);
  if (v13)
  {
    v16 = (unint64_t *)&v13->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v18 = v27;
  if (v27)
  {
    v19 = (unint64_t *)&v27->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 88));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 56));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v2);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 24));
  v21 = *(std::__shared_weak_count **)(a1 + 16);
  if (v21)
    std::__shared_weak_count::__release_weak(v21);
  Alembic::AbcCoreAbstract::v12::ScalarPropertyWriter::~ScalarPropertyWriter((Alembic::AbcCoreAbstract::v12::ScalarPropertyWriter *)a1);
}

void sub_20BDFE434(uint64_t a1)
{
  void *v1;

  sub_20BDFE1FC(a1);
  operator delete(v1);
}

void sub_20BDFE448(Alembic::AbcCoreAbstract::v12::TimeSamplingType *a1)
{
  uint64_t v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _BOOL4 v13;
  unint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *exception;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  void *__p[2];
  char v37;
  _QWORD v38[4];
  _QWORD *v39;
  std::__shared_weak_count *v40;
  _QWORD v41[33];

  v2 = *((_QWORD *)a1 + 7);
  v3 = *(_QWORD **)(v2 + 64);
  v4 = *(std::__shared_weak_count **)(v2 + 72);
  v39 = v3;
  v40 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = *v3;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(a1) == (_DWORD)v7)
  {
    v8 = *((_QWORD *)a1 + 7);
    v9 = *(_QWORD *)(v8 + 64);
    v10 = *(std::__shared_weak_count **)(v8 + 72);
    if (v10)
    {
      v11 = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      v13 = *(unsigned int *)(*((_QWORD *)a1 + 7) + 84) >= (unint64_t)((uint64_t)(*(_QWORD *)(v9 + 24)
                                                                                        - *(_QWORD *)(v9 + 16)) >> 3);
      do
        v14 = __ldaxr(v11);
      while (__stlxr(v14 - 1, v11));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    else
    {
      v13 = *(unsigned int *)(v8 + 84) >= (unint64_t)((uint64_t)(*(_QWORD *)(v9 + 24) - *(_QWORD *)(v9 + 16)) >> 3);
    }
  }
  else
  {
    v13 = 0;
  }
  if (v40)
  {
    v15 = &v40->__shared_owners_;
    do
      v16 = __ldaxr((unint64_t *)v15);
    while (__stlxr(v16 - 1, (unint64_t *)v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  if (v13)
  {
    sub_20BDDBD68((uint64_t)&v39);
    sub_20BDDC1C8(v41, (uint64_t)"Can not set more samples than we have times for when using Acyclic sampling.", 76);
    std::stringbuf::str();
    sub_20BDDBF20(v38, (__int128 *)__p);
    if (v37 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v33 = sub_20BDDC09C(exception, (uint64_t)v38);
    __cxa_throw(v33, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v17 = *((_QWORD *)a1 + 7);
  v18 = *(_DWORD *)(v17 + 84);
  if (!v18)
  {
    sub_20BDDBD68((uint64_t)&v39);
    sub_20BDDC1C8(v41, (uint64_t)"Can't set from previous sample before any samples have been written", 67);
    std::stringbuf::str();
    sub_20BDDBF20(v38, (__int128 *)__p);
    if (v37 < 0)
      operator delete(__p[0]);
    v34 = __cxa_allocate_exception(0x20uLL);
    v35 = sub_20BDDC09C(v34, (uint64_t)v38);
    __cxa_throw(v35, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v19 = *((_QWORD *)a1 + 3);
  v20 = *(_QWORD *)(v19 + 16);
  v21 = (*(_QWORD *)(v19 + 24) ^ v20) + __ROR8__(v20, 49);
  v22 = (v21 ^ *((_QWORD *)a1 + 9)) + __ROR8__(v21, 12);
  v23 = (v22 ^ *((_QWORD *)a1 + 10)) + __ROR8__(v22, 38);
  v24 = (v23 ^ __ROR8__(v20, 49)) + __ROR8__(v23, 13);
  v25 = (v24 ^ __ROR8__(v21, 12)) + __ROR8__(v24, 36);
  v26 = (v25 ^ __ROR8__(v22, 38)) + __ROR8__(v25, 55);
  v27 = (v26 ^ __ROR8__(v23, 13)) + __ROR8__(v26, 17);
  v28 = (v27 ^ __ROR8__(v24, 36)) + __ROR8__(v27, 10);
  v29 = (v28 ^ __ROR8__(v25, 55)) + __ROR8__(v28, 32);
  v30 = (v29 ^ __ROR8__(v26, 17)) + __ROR8__(v29, 39);
  v31 = __ROR8__(v30, 1);
  *((_QWORD *)a1 + 9) = v31;
  *((_QWORD *)a1 + 10) = (v30 ^ __ROR8__(v27, 10)) + v31;
  *(_DWORD *)(v17 + 84) = v18 + 1;
}

void sub_20BDFE6F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BDFE734(Alembic::AbcCoreAbstract::v12::TimeSamplingType *a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  BOOL v15;
  unint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  int v21;
  _DWORD *v22;
  unsigned int *v23;
  unsigned int v24;
  uint64_t v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  char *v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  _DWORD *v57;
  int v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _QWORD *exception;
  _QWORD *v80;
  uint64_t v81;
  std::__shared_weak_count *v82;
  void *v83;
  std::__shared_weak_count *v84;
  __int128 v85;
  uint64_t v86;
  std::__shared_weak_count *v87;
  uint64_t v88;
  std::__shared_weak_count *v89;
  void *v90[2];
  char v91;
  void *__p;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  std::__shared_weak_count *v97;
  void *v98;
  void *v99;
  uint64_t v100;

  v4 = *((_QWORD *)a1 + 7);
  v5 = *(_QWORD **)(v4 + 64);
  v6 = *(std::__shared_weak_count **)(v4 + 72);
  v96 = v5;
  v97 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = *v5;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(a1) == (_DWORD)v9)
  {
    v10 = *((_QWORD *)a1 + 7);
    v11 = *(_QWORD *)(v10 + 64);
    v12 = *(std::__shared_weak_count **)(v10 + 72);
    if (v12)
    {
      v13 = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
      v15 = *(unsigned int *)(*((_QWORD *)a1 + 7) + 84) < (unint64_t)((uint64_t)(*(_QWORD *)(v11 + 24)
                                                                                       - *(_QWORD *)(v11 + 16)) >> 3);
      do
        v16 = __ldaxr(v13);
      while (__stlxr(v16 - 1, v13));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    else
    {
      v15 = *(unsigned int *)(v10 + 84) < (unint64_t)((uint64_t)(*(_QWORD *)(v11 + 24) - *(_QWORD *)(v11 + 16)) >> 3);
    }
  }
  else
  {
    v15 = 1;
  }
  if (v97)
  {
    v17 = &v97->__shared_owners_;
    do
      v18 = __ldaxr((unint64_t *)v17);
    while (__stlxr(v18 - 1, (unint64_t *)v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
      std::__shared_weak_count::__release_weak(v97);
    }
  }
  if (!v15)
  {
    sub_20BDDBD68((uint64_t)&v96);
    sub_20BDDC1C8(&v98, (uint64_t)"Can not write more samples than we have times for when using Acyclic sampling.", 78);
    std::stringbuf::str();
    sub_20BDDBF20(&__p, (__int128 *)v90);
    if (v91 < 0)
      operator delete(v90[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v80 = sub_20BDDC09C(exception, (uint64_t)&__p);
    __cxa_throw(v80, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v19 = *((_QWORD *)a1 + 7);
  v90[0] = (void *)1;
  sub_20BDE8894(&__p, 1uLL, v90);
  v20 = *(std::__shared_weak_count **)(v19 + 56);
  v96 = a2;
  v97 = v20;
  v99 = 0;
  v100 = 0;
  v98 = 0;
  sub_20BDE1364(&v98, __p, v93, (v93 - (uint64_t)__p) >> 3);
  if (__p)
  {
    v93 = (uint64_t)__p;
    operator delete(__p);
  }
  Alembic::AbcCoreAbstract::v12::ArraySample::getKey((Alembic::AbcCoreAbstract::v12::ArraySample *)&v96, (uint64_t)&__p);
  v21 = v93;
  if ((v93 - 14) <= 0xFFFFFFFD)
  {
    v93 = 0x200000002;
    v21 = 2;
  }
  v22 = (_DWORD *)*((_QWORD *)a1 + 7);
  v23 = v22 + 21;
  v24 = v22[21];
  if (v24)
  {
    v25 = *((_QWORD *)a1 + 3);
    if (v25)
    {
      if (__p == *(void **)v25
        && __PAIR128__(v94, __PAIR64__(HIDWORD(v93), v21)) == *(_OWORD *)(v25 + 8)
        && v95 == *(_QWORD *)(v25 + 24))
      {
        goto LABEL_82;
      }
    }
  }
  if (v22[22])
  {
    v26 = (v22[23] + 1);
    if (v26 < v24)
    {
      do
      {
        v27 = (std::__shared_weak_count *)*((_QWORD *)a1 + 12);
        v88 = *((_QWORD *)a1 + 11);
        v89 = v27;
        if (v27)
        {
          v28 = (unint64_t *)&v27->__shared_owners_;
          do
            v29 = __ldxr(v28);
          while (__stxr(v29 + 1, v28));
        }
        v30 = (std::__shared_weak_count *)*((_QWORD *)a1 + 4);
        v86 = *((_QWORD *)a1 + 3);
        v87 = v30;
        if (v30)
        {
          v31 = (unint64_t *)&v30->__shared_owners_;
          do
            v32 = __ldxr(v31);
          while (__stxr(v32 + 1, v31));
        }
        sub_20BE00F2C(&v88, &v86);
        v33 = v87;
        if (v87)
        {
          v34 = (unint64_t *)&v87->__shared_owners_;
          do
            v35 = __ldaxr(v34);
          while (__stlxr(v35 - 1, v34));
          if (!v35)
          {
            ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
            std::__shared_weak_count::__release_weak(v33);
          }
        }
        v36 = v89;
        if (v89)
        {
          v37 = (unint64_t *)&v89->__shared_owners_;
          do
            v38 = __ldaxr(v37);
          while (__stlxr(v38 - 1, v37));
          if (!v38)
          {
            ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
            std::__shared_weak_count::__release_weak(v36);
          }
        }
        ++v26;
      }
      while (v26 < *(unsigned int *)(*((_QWORD *)a1 + 7) + 84));
    }
  }
  (*(void (**)(__int128 *__return_ptr, Alembic::AbcCoreAbstract::v12::TimeSamplingType *))(*(_QWORD *)a1 + 24))(&v85, a1);
  (*(void (**)(void **__return_ptr))(*(_QWORD *)v85 + 24))(v90);
  v39 = (std::__shared_weak_count *)*((_QWORD *)&v85 + 1);
  if (*((_QWORD *)&v85 + 1))
  {
    v40 = (unint64_t *)(*((_QWORD *)&v85 + 1) + 8);
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  v83 = v90[0];
  v84 = (std::__shared_weak_count *)v90[1];
  if (v90[1])
  {
    v42 = (unint64_t *)((char *)v90[1] + 8);
    do
      v43 = __ldxr(v42);
    while (__stxr(v43 + 1, v42));
  }
  v44 = sub_20BE002F4((const void **)&v83);
  v45 = (std::__shared_weak_count *)*((_QWORD *)a1 + 12);
  v81 = *((_QWORD *)a1 + 11);
  v82 = v45;
  if (v45)
  {
    v46 = (unint64_t *)&v45->__shared_owners_;
    do
      v47 = __ldxr(v46);
    while (__stxr(v47 + 1, v46));
  }
  sub_20BE00464(v44, (uint64_t)&v81, (uint64_t)&v96, (uint64_t)&__p, (uint64_t *)&v85);
  sub_20BDE82DC((uint64_t)a1 + 24, &v85);
  v48 = (std::__shared_weak_count *)*((_QWORD *)&v85 + 1);
  if (*((_QWORD *)&v85 + 1))
  {
    v49 = (unint64_t *)(*((_QWORD *)&v85 + 1) + 8);
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
  v51 = v82;
  if (v82)
  {
    v52 = (unint64_t *)&v82->__shared_owners_;
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
  v54 = v84;
  if (v84)
  {
    v55 = (unint64_t *)&v84->__shared_owners_;
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }
  v57 = (_DWORD *)*((_QWORD *)a1 + 7);
  v58 = v57[21];
  if (!v57[22])
    v57[22] = v58;
  v57[23] = v58;
  v59 = (std::__shared_weak_count *)v90[1];
  if (v90[1])
  {
    v60 = (unint64_t *)((char *)v90[1] + 8);
    do
      v61 = __ldaxr(v60);
    while (__stlxr(v61 - 1, v60));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  v62 = *((_QWORD *)a1 + 7);
  v63 = *(_DWORD *)(v62 + 84);
  v23 = (unsigned int *)(v62 + 84);
  v24 = v63;
  if (v63)
  {
LABEL_82:
    v64 = *((_QWORD *)a1 + 3);
    v65 = *(_QWORD *)(v64 + 16);
    v66 = (*(_QWORD *)(v64 + 24) ^ v65) + __ROR8__(v65, 49);
    v67 = (v66 ^ *((_QWORD *)a1 + 9)) + __ROR8__(v66, 12);
    v68 = (v67 ^ *((_QWORD *)a1 + 10)) + __ROR8__(v67, 38);
    v69 = (v68 ^ __ROR8__(v65, 49)) + __ROR8__(v68, 13);
    v70 = (v69 ^ __ROR8__(v66, 12)) + __ROR8__(v69, 36);
    v71 = (v70 ^ __ROR8__(v67, 38)) + __ROR8__(v70, 55);
    v72 = (v71 ^ __ROR8__(v68, 13)) + __ROR8__(v71, 17);
    v73 = (v72 ^ __ROR8__(v69, 36)) + __ROR8__(v72, 10);
    v74 = (v73 ^ __ROR8__(v70, 55)) + __ROR8__(v73, 32);
    v75 = (v74 ^ __ROR8__(v71, 17)) + __ROR8__(v74, 39);
    v76 = v75 ^ __ROR8__(v72, 10);
    v77 = __ROR8__(v75, 1);
    *((_QWORD *)a1 + 9) = v77;
    *((_QWORD *)a1 + 10) = v76 + v77;
  }
  else
  {
    v78 = *((_QWORD *)a1 + 3);
    *((_QWORD *)a1 + 9) = *(_QWORD *)(v78 + 16);
    *((_QWORD *)a1 + 10) = *(_QWORD *)(v78 + 24);
    v24 = *v23;
  }
  *v23 = v24 + 1;
  if (v98)
  {
    v99 = v98;
    operator delete(v98);
  }
}

void sub_20BDFED28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void *__p,uint64_t a29)
{
  sub_20BDDC194((std::exception *)&a22);
  sub_20BDDBE98((uint64_t)&a26);
  _Unwind_Resume(a1);
}

double sub_20BDFEDE0@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_20BDFEE18(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 56) + 84);
}

void sub_20BDFEE24(uint64_t a1, uint64_t a2)
{
  Alembic::AbcCoreAbstract::v12::TimeSamplingType *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *exception;
  _QWORD *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 __p;
  char v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  _QWORD v24[33];
  uint64_t *v25;
  std::__shared_weak_count *v26;

  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a1 + 40) + 24))(&v20);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v20 + 24))(&v22);
  v4 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)(*(_QWORD *(**)(uint64_t **__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v22 + 56))(&v25, v22, a2);
  v5 = v23;
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = v21;
  if (v21)
  {
    v9 = (unint64_t *)&v21->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = *v25;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v4) == (_DWORD)v11)
  {
    v12 = *(_QWORD *)(a1 + 56);
    if (*(unsigned int *)(v12 + 84) > (unint64_t)((v25[3] - v25[2]) >> 3))
    {
      sub_20BDDBD68((uint64_t)&v22);
      sub_20BDDC1C8(v24, (uint64_t)"Already have written more samples than we have times for when using Acyclic sampling.", 85);
      std::stringbuf::str();
      sub_20BDDBF20(&v20, &__p);
      if (v19 < 0)
        operator delete((void *)__p);
      exception = __cxa_allocate_exception(0x20uLL);
      v14 = sub_20BDDC09C(exception, (uint64_t)&v20);
      __cxa_throw(v14, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 56);
  }
  sub_20BDE881C((_QWORD *)(v12 + 64), (uint64_t *)&v25);
  *(_DWORD *)(*(_QWORD *)(a1 + 56) + 96) = a2;
  v15 = v26;
  if (v26)
  {
    v16 = (unint64_t *)&v26->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_20BDFEFF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  std::exception v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v6.__vftable = va_arg(va1, std::exception_vtbl *);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v4 - 48));
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFF054(uint64_t a1)
{
  uint64_t result;
  _QWORD *exception;
  _QWORD *v3;
  __int128 __p;
  char v5;
  _QWORD v6[4];
  _BYTE v7[16];
  _QWORD v8[33];

  result = *(_QWORD *)(a1 + 56);
  if (!result)
  {
    sub_20BDDBD68((uint64_t)v7);
    sub_20BDDC1C8(v8, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v6, &__p);
    if (v5 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v3 = sub_20BDDC09C(exception, (uint64_t)v6);
    __cxa_throw(v3, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return result;
}

void sub_20BDFF0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFF114(uint64_t a1)
{
  uint64_t v1;
  _QWORD *exception;
  _QWORD *v4;
  __int128 __p;
  char v6;
  _QWORD v7[4];
  _BYTE v8[16];
  _QWORD v9[33];

  v1 = *(_QWORD *)(a1 + 40);
  if (!v1)
  {
    sub_20BDDBD68((uint64_t)v8);
    sub_20BDDC1C8(v9, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v7, &__p);
    if (v6 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v4 = sub_20BDDC09C(exception, (uint64_t)v7);
    __cxa_throw(v4, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
}

void sub_20BDFF1B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFF1DC@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  _QWORD *exception;
  _QWORD *v7;
  __int128 __p;
  char v9;
  _QWORD v10[4];
  _BYTE v11[16];
  _QWORD v12[33];

  v2 = *(_QWORD *)(result + 40);
  if (!v2)
  {
    sub_20BDDBD68((uint64_t)v11);
    sub_20BDDC1C8(v12, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v10, &__p);
    if (v9 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v7 = sub_20BDDC09C(exception, (uint64_t)v10);
    __cxa_throw(v7, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v3 = *(_QWORD *)(result + 48);
  *a2 = v2;
  a2[1] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

void sub_20BDFF294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

unint64_t *sub_20BDFF2BC(unint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  __int128 v14;

  a1[1] = 0;
  a1[2] = 0;
  v4 = (uint64_t)(a1 + 1);
  a1[3] = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 5), 0);
  a1[14] = 0;
  a1[15] = 0;
  v5 = a1 + 13;
  atomic_store(0, a1 + 13);
  a1[4] = 0;
  *a1 = a2;
  if (a2 >= 2)
  {
    sub_20BDFC880(v4, a2);
    if (*a1)
    {
      v6 = 0;
      do
      {
        *(_QWORD *)(a1[1] + 8 * v6) = v6;
        v7 = *a1;
        if (*a1 <= 0x3F)
        {
          do
            v8 = __ldaxr(v5);
          while (__stlxr(v8 | (1 << v6), v5));
          v7 = *a1;
        }
        ++v6;
      }
      while (v6 < v7);
    }
  }
  v9 = operator new(0x10uLL);
  *v9 = 0;
  v9[1] = 0;
  sub_20BDFF6AC(&v14, (uint64_t)v9);
  sub_20BDE82DC((uint64_t)(a1 + 14), &v14);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
  if (*((_QWORD *)&v14 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return a1;
}

void sub_20BDFF3E8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  pthread_mutex_t *v3;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v4;
  void *v6;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v4);
  pthread_mutex_destroy(v3);
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFF428(uint64_t a1)
{
  void *v2;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 112));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 40));
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

_QWORD *sub_20BDFF470@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  unint64_t *v2;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  _QWORD *v20;

  v2 = result;
  if (*result > 1uLL)
  {
    if (*result <= 0x40uLL)
    {
      v10 = result + 13;
      while (1)
      {
        v11 = atomic_load(v10);
        if (!v11)
          break;
        v12 = __ldaxr(v10);
        if (v12 == v11)
        {
          v13 = __clz(__rbit64(v11));
          if (!__stlxr(v11 & ~(1 << v13), v10))
          {
            v20 = operator new(0x10uLL);
            *v20 = v2;
            v20[1] = v13;
            return sub_20BDFF6AC(a2, (uint64_t)v20);
          }
        }
        else
        {
          __clrex();
        }
      }
      v14 = result[15];
      *a2 = result[14];
      a2[1] = v14;
      if (v14)
      {
        v15 = (unint64_t *)(v14 + 8);
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
    }
    else
    {
      pthread_mutex_lock((pthread_mutex_t *)(result + 5));
      v7 = v2[4];
      if (v7 >= *v2)
      {
        v17 = v2[15];
        *a2 = v2[14];
        a2[1] = v17;
        if (v17)
        {
          v18 = (unint64_t *)(v17 + 8);
          do
            v19 = __ldxr(v18);
          while (__stxr(v19 + 1, v18));
        }
      }
      else
      {
        v8 = operator new(0x10uLL);
        v2[4] = v7 + 1;
        v9 = *(_QWORD *)(v2[1] + 8 * v7);
        *v8 = v2;
        v8[1] = v9;
        sub_20BDFF6AC(a2, (uint64_t)v8);
      }
      return (_QWORD *)pthread_mutex_unlock((pthread_mutex_t *)(v2 + 5));
    }
  }
  else
  {
    v4 = result[15];
    *a2 = result[14];
    a2[1] = v4;
    if (v4)
    {
      v5 = (unint64_t *)(v4 + 8);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
  }
  return result;
}

void sub_20BDFF5CC(_Unwind_Exception *a1)
{
  pthread_mutex_t *v1;

  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BDFF5E4(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;

  v3 = result;
  if (*(_QWORD *)result <= 0x40uLL)
  {
    v5 = (unint64_t *)(result + 104);
    do
    {
      while (1)
      {
        v6 = atomic_load(v5);
        v7 = __ldaxr(v5);
        if (v7 == v6)
          break;
        __clrex();
      }
    }
    while (__stlxr(v6 | (1 << a2), v5));
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(result + 40));
    v4 = *(_QWORD *)(v3 + 32) - 1;
    *(_QWORD *)(v3 + 32) = v4;
    *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = a2;
    return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 40));
  }
  return result;
}

uint64_t *sub_20BDFF678(uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  if (v2)
    sub_20BDFF5E4(v2, a1[1]);
  return a1;
}

_QWORD *sub_20BDFF6AC(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518DF0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BDFF6F0(_Unwind_Exception *exception_object)
{
  uint64_t *v1;
  uint64_t *v3;

  if (v1)
  {
    v3 = sub_20BDFF678(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_20BDFF710(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BDFF724(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;

  v1 = *(uint64_t **)(a1 + 24);
  if (v1)
  {
    v2 = sub_20BDFF678(v1);
    operator delete(v2);
  }
}

uint64_t sub_20BDFF748(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C518E40))
    return a1 + 24;
  else
    return 0;
}

void sub_20BDFF788(unint64_t *a1, int a2, int a3)
{
  unint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  unint64_t v11;
  _BYTE *v12;
  _BYTE *v13;
  unint64_t v14;
  _BYTE *v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  unint64_t v19;
  unint64_t v20;
  _BYTE *v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;
  unint64_t v25;
  unint64_t v26;
  _BYTE *v27;
  unint64_t v28;
  unint64_t v29;
  size_t v30;
  unint64_t v31;
  char *v32;
  _BYTE *v33;
  char v34;
  char *v35;
  _BYTE *v36;
  char v37;
  char *v38;
  _BYTE *v39;
  char v40;
  unint64_t v41;
  _BYTE *v42;
  unint64_t v43;
  _BYTE *v44;
  unint64_t v45;
  unint64_t v46;
  size_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  _BYTE *v52;
  unint64_t v53;
  unint64_t v54;
  size_t v55;
  unint64_t v56;
  char *v57;
  _BYTE *v58;
  char v59;
  char *v60;
  _BYTE *v61;
  char v62;
  unint64_t v63;
  _BYTE *v64;
  unint64_t v65;
  _BYTE *v66;
  unint64_t v67;
  unint64_t v68;
  size_t v69;
  unint64_t v70;
  void *v71;
  char *v72;
  _BYTE *v73;
  char v74;
  unint64_t v75;
  unint64_t v76;
  _BYTE *v77;
  unint64_t v78;
  unint64_t v79;
  size_t v80;
  unint64_t v81;
  char *v82;
  _BYTE *v83;
  char v84;

  switch(a3)
  {
    case 2:
      v9 = (_BYTE *)a1[1];
      v8 = a1[2];
      if ((unint64_t)v9 >= v8)
      {
        v20 = *a1;
        v21 = &v9[-*a1];
        v22 = (unint64_t)(v21 + 1);
        if ((uint64_t)(v21 + 1) < 0)
          goto LABEL_134;
        v23 = v8 - v20;
        if (2 * v23 > v22)
          v22 = 2 * v23;
        if (v23 >= 0x3FFFFFFFFFFFFFFFLL)
          v24 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v24 = v22;
        if (v24)
          v25 = (unint64_t)operator new(v24);
        else
          v25 = 0;
        v35 = (char *)(v25 + v24);
        v21[v25] = a2;
        v10 = &v21[v25 + 1];
        if (v9 == (_BYTE *)v20)
        {
          v25 += (unint64_t)v21;
        }
        else
        {
          v36 = &v9[~v20];
          do
          {
            v37 = *--v9;
            (v36--)[v25] = v37;
          }
          while (v9 != (_BYTE *)v20);
          v9 = (_BYTE *)*a1;
        }
        *a1 = v25;
        a1[1] = (unint64_t)v10;
        a1[2] = (unint64_t)v35;
        if (v9)
          operator delete(v9);
      }
      else
      {
        *v9 = a2;
        v10 = v9 + 1;
      }
      a1[1] = (unint64_t)v10;
      v41 = a1[2];
      if ((unint64_t)v10 < v41)
      {
        *v10 = BYTE1(a2);
        v42 = v10 + 1;
        goto LABEL_93;
      }
      v43 = *a1;
      v44 = &v10[-*a1];
      v45 = (unint64_t)(v44 + 1);
      if ((uint64_t)(v44 + 1) < 0)
        goto LABEL_134;
      v46 = v41 - v43;
      if (2 * v46 > v45)
        v45 = 2 * v46;
      if (v46 >= 0x3FFFFFFFFFFFFFFFLL)
        v47 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v47 = v45;
      if (v47)
        v48 = (unint64_t)operator new(v47);
      else
        v48 = 0;
      v57 = (char *)(v48 + v47);
      v44[v48] = BYTE1(a2);
      v42 = &v44[v48 + 1];
      if (v10 == (_BYTE *)v43)
      {
        *a1 = (unint64_t)&v44[v48];
        a1[1] = (unint64_t)v42;
        a1[2] = (unint64_t)v57;
      }
      else
      {
        v58 = &v10[~v43];
        do
        {
          v59 = *--v10;
          (v58--)[v48] = v59;
        }
        while (v10 != (_BYTE *)v43);
        v10 = (_BYTE *)*a1;
        *a1 = v48;
        a1[1] = (unint64_t)v42;
        a1[2] = (unint64_t)v57;
        if (!v10)
        {
LABEL_93:
          a1[1] = (unint64_t)v42;
          v63 = a1[2];
          if ((unint64_t)v42 >= v63)
          {
            v65 = *a1;
            v66 = &v42[-*a1];
            v67 = (unint64_t)(v66 + 1);
            if ((uint64_t)(v66 + 1) < 0)
              goto LABEL_134;
            v68 = v63 - v65;
            if (2 * v68 > v67)
              v67 = 2 * v68;
            if (v68 >= 0x3FFFFFFFFFFFFFFFLL)
              v69 = 0x7FFFFFFFFFFFFFFFLL;
            else
              v69 = v67;
            if (v69)
              v70 = (unint64_t)operator new(v69);
            else
              v70 = 0;
            v72 = (char *)(v70 + v69);
            v66[v70] = BYTE2(a2);
            v64 = &v66[v70 + 1];
            if (v42 == (_BYTE *)v65)
            {
              *a1 = (unint64_t)&v66[v70];
              a1[1] = (unint64_t)v64;
              a1[2] = (unint64_t)v72;
            }
            else
            {
              v73 = &v42[~v65];
              do
              {
                v74 = *--v42;
                (v73--)[v70] = v74;
              }
              while (v42 != (_BYTE *)v65);
              v42 = (_BYTE *)*a1;
              *a1 = v70;
              a1[1] = (unint64_t)v64;
              a1[2] = (unint64_t)v72;
              if (!v42)
                goto LABEL_113;
            }
            operator delete(v42);
          }
          else
          {
            *v42 = BYTE2(a2);
            v64 = v42 + 1;
          }
LABEL_113:
          a1[1] = (unint64_t)v64;
          v75 = a1[2];
          if ((unint64_t)v64 < v75)
          {
            *v64 = HIBYTE(a2);
            v50 = (uint64_t)(v64 + 1);
            goto LABEL_132;
          }
          v76 = *a1;
          v77 = &v64[-*a1];
          v78 = (unint64_t)(v77 + 1);
          if ((uint64_t)(v77 + 1) < 0)
            goto LABEL_134;
          v79 = v75 - v76;
          if (2 * v79 > v78)
            v78 = 2 * v79;
          if (v79 >= 0x3FFFFFFFFFFFFFFFLL)
            v80 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v80 = v78;
          if (v80)
            v81 = (unint64_t)operator new(v80);
          else
            v81 = 0;
          v82 = (char *)(v81 + v80);
          v77[v81] = HIBYTE(a2);
          v50 = (uint64_t)&v77[v81 + 1];
          if (v64 == (_BYTE *)v76)
          {
            *a1 = (unint64_t)&v77[v81];
            a1[1] = v50;
            a1[2] = (unint64_t)v82;
          }
          else
          {
            v83 = &v64[~v76];
            do
            {
              v84 = *--v64;
              (v83--)[v81] = v84;
            }
            while (v64 != (_BYTE *)v76);
            v64 = (_BYTE *)*a1;
            *a1 = v81;
            a1[1] = v50;
            a1[2] = (unint64_t)v82;
            if (!v64)
              goto LABEL_132;
          }
          v71 = v64;
LABEL_131:
          operator delete(v71);
          goto LABEL_132;
        }
      }
      operator delete(v10);
      goto LABEL_93;
    case 1:
      v12 = (_BYTE *)a1[1];
      v11 = a1[2];
      if ((unint64_t)v12 >= v11)
      {
        v26 = *a1;
        v27 = &v12[-*a1];
        v28 = (unint64_t)(v27 + 1);
        if ((uint64_t)(v27 + 1) < 0)
          goto LABEL_134;
        v29 = v11 - v26;
        if (2 * v29 > v28)
          v28 = 2 * v29;
        if (v29 >= 0x3FFFFFFFFFFFFFFFLL)
          v30 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v30 = v28;
        if (v30)
          v31 = (unint64_t)operator new(v30);
        else
          v31 = 0;
        v38 = (char *)(v31 + v30);
        v27[v31] = a2;
        v13 = &v27[v31 + 1];
        if (v12 == (_BYTE *)v26)
        {
          v31 += (unint64_t)v27;
        }
        else
        {
          v39 = &v12[~v26];
          do
          {
            v40 = *--v12;
            (v39--)[v31] = v40;
          }
          while (v12 != (_BYTE *)v26);
          v12 = (_BYTE *)*a1;
        }
        *a1 = v31;
        a1[1] = (unint64_t)v13;
        a1[2] = (unint64_t)v38;
        if (v12)
          operator delete(v12);
      }
      else
      {
        *v12 = a2;
        v13 = v12 + 1;
      }
      a1[1] = (unint64_t)v13;
      v49 = a1[2];
      if ((unint64_t)v13 < v49)
      {
        *v13 = BYTE1(a2);
        v50 = (uint64_t)(v13 + 1);
LABEL_132:
        a1[1] = v50;
        return;
      }
      v51 = *a1;
      v52 = &v13[-*a1];
      v53 = (unint64_t)(v52 + 1);
      if ((uint64_t)(v52 + 1) < 0)
        goto LABEL_134;
      v54 = v49 - v51;
      if (2 * v54 > v53)
        v53 = 2 * v54;
      if (v54 >= 0x3FFFFFFFFFFFFFFFLL)
        v55 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v55 = v53;
      if (v55)
        v56 = (unint64_t)operator new(v55);
      else
        v56 = 0;
      v60 = (char *)(v56 + v55);
      v52[v56] = BYTE1(a2);
      v50 = (uint64_t)&v52[v56 + 1];
      if (v13 == (_BYTE *)v51)
      {
        *a1 = (unint64_t)&v52[v56];
        a1[1] = v50;
        a1[2] = (unint64_t)v60;
      }
      else
      {
        v61 = &v13[~v51];
        do
        {
          v62 = *--v13;
          (v61--)[v56] = v62;
        }
        while (v13 != (_BYTE *)v51);
        v13 = (_BYTE *)*a1;
        *a1 = v56;
        a1[1] = v50;
        a1[2] = (unint64_t)v60;
        if (!v13)
          goto LABEL_132;
      }
      v71 = v13;
      goto LABEL_131;
    case 0:
      v6 = (_BYTE *)a1[1];
      v5 = a1[2];
      if ((unint64_t)v6 < v5)
      {
        *v6 = a2;
        v7 = (uint64_t)(v6 + 1);
LABEL_52:
        a1[1] = v7;
        return;
      }
      v14 = *a1;
      v15 = &v6[-*a1];
      v16 = (unint64_t)(v15 + 1);
      if ((uint64_t)(v15 + 1) >= 0)
      {
        v17 = v5 - v14;
        if (2 * v17 > v16)
          v16 = 2 * v17;
        if (v17 >= 0x3FFFFFFFFFFFFFFFLL)
          v18 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v18 = v16;
        if (v18)
          v19 = (unint64_t)operator new(v18);
        else
          v19 = 0;
        v32 = (char *)(v19 + v18);
        v15[v19] = a2;
        v7 = (uint64_t)&v15[v19 + 1];
        if (v6 == (_BYTE *)v14)
        {
          v19 += (unint64_t)v15;
        }
        else
        {
          v33 = &v6[~v14];
          do
          {
            v34 = *--v6;
            (v33--)[v19] = v34;
          }
          while (v6 != (_BYTE *)v14);
          v6 = (_BYTE *)*a1;
        }
        *a1 = v19;
        a1[1] = v7;
        a1[2] = (unint64_t)v32;
        if (v6)
          operator delete(v6);
        goto LABEL_52;
      }
LABEL_134:
      sub_20BDDF694();
  }
}

void sub_20BDFFCF0(unint64_t *a1, double a2)
{
  uint64_t v3;
  _BYTE *v4;
  unint64_t v5;
  _BYTE *v6;
  unint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  char *v12;
  char *v13;
  _BYTE *v14;
  _BYTE *v15;
  char v16;
  double v17;

  v3 = 0;
  v17 = a2;
  v4 = (_BYTE *)a1[1];
  do
  {
    v5 = a1[2];
    if ((unint64_t)v4 >= v5)
    {
      v7 = *a1;
      v8 = &v4[-*a1];
      v9 = (unint64_t)(v8 + 1);
      if ((uint64_t)(v8 + 1) < 0)
        sub_20BDDF694();
      v10 = v5 - v7;
      if (2 * v10 > v9)
        v9 = 2 * v10;
      if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
        v11 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v11 = v9;
      if (v11)
        v12 = (char *)operator new(v11);
      else
        v12 = 0;
      v13 = &v8[(_QWORD)v12];
      v14 = &v8[(_QWORD)v12];
      *v14 = *((_BYTE *)&v17 + v3);
      v6 = v14 + 1;
      if (v4 != (_BYTE *)v7)
      {
        v15 = &v4[~v7];
        do
        {
          v16 = *--v4;
          (v15--)[(_QWORD)v12] = v16;
        }
        while (v4 != (_BYTE *)v7);
        v4 = (_BYTE *)*a1;
        v13 = v12;
      }
      *a1 = (unint64_t)v13;
      a1[1] = (unint64_t)v6;
      a1[2] = (unint64_t)&v12[v11];
      if (v4)
        operator delete(v4);
    }
    else
    {
      *v4 = *((_BYTE *)&v17 + v3);
      v6 = v4 + 1;
    }
    a1[1] = (unint64_t)v6;
    ++v3;
    v4 = v6;
  }
  while (v3 != 8);
}

void sub_20BDFFE14(uint64_t a1, Alembic::Util::v12::SpookyHash *a2)
{
  int v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  int v9;
  char *v10;
  char *v11;
  unint64_t v12;
  int64_t v13;
  int64_t v14;
  unint64_t v15;
  size_t v16;
  void *v17;
  char *v18;
  char *v19;
  char v20;
  char v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  size_t v27;
  void *v28;
  char *v29;
  char *v30;
  char v31;
  char *v32;
  unint64_t v33;
  int64_t v34;
  uint64_t v35;
  unint64_t v36;
  size_t v37;
  void *v38;
  char *v39;
  char *v40;
  char v41;
  std::__shared_weak_count *v42;
  uint64_t v43;
  unint64_t *p_shared_owners;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  void *v50[2];
  unsigned __int8 v51;
  void *__p;
  void *__dst;
  unint64_t v54;

  __p = 0;
  __dst = 0;
  v54 = 0;
  v4 = *(char *)(a1 + 23);
  if (v4 >= 0)
    v5 = (char *)a1;
  else
    v5 = *(char **)a1;
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a1 + 23);
  else
    v6 = *(_QWORD *)(a1 + 8);
  sub_20BDF36D0((char **)&__p, 0, v5, &v5[v6], v6);
  Alembic::Util::v12::TokenMap::get((Alembic::Util::v12::TokenMap *)(a1 + 32), 0x3Bu, 61, 1);
  if ((v51 & 0x80u) == 0)
    v7 = (char *)v50;
  else
    v7 = (char *)v50[0];
  if ((v51 & 0x80u) == 0)
    v8 = v51;
  else
    v8 = (uint64_t)v50[1];
  sub_20BDF36D0((char **)&__p, (char *)__dst, v7, &v7[v8], v8);
  if (!*(_DWORD *)(a1 + 24))
    goto LABEL_81;
  v9 = *(_DWORD *)(a1 + 56);
  v10 = (char *)__dst;
  if ((unint64_t)__dst >= v54)
  {
    v12 = (unint64_t)__p;
    v13 = (_BYTE *)__dst - (_BYTE *)__p;
    v14 = (_BYTE *)__dst - (_BYTE *)__p + 1;
    if (v14 < 0)
      sub_20BDDF694();
    v15 = v54 - (_QWORD)__p;
    if (2 * (v54 - (unint64_t)__p) > v14)
      v14 = 2 * v15;
    if (v15 >= 0x3FFFFFFFFFFFFFFFLL)
      v16 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v16 = v14;
    if (v16)
      v17 = operator new(v16);
    else
      v17 = 0;
    v18 = (char *)v17 + v16;
    *((_BYTE *)v17 + v13) = v9;
    v11 = (char *)v17 + v13 + 1;
    if (v10 == (char *)v12)
    {
      v17 = (char *)v17 + v13;
    }
    else
    {
      v19 = &v10[~v12];
      do
      {
        v20 = *--v10;
        (v19--)[(_QWORD)v17] = v20;
      }
      while (v10 != (char *)v12);
      v10 = (char *)__p;
    }
    __p = v17;
    __dst = v11;
    v54 = (unint64_t)v18;
    if (v10)
      operator delete(v10);
  }
  else
  {
    *(_BYTE *)__dst = v9;
    v11 = v10 + 1;
  }
  __dst = v11;
  v21 = *(_BYTE *)(a1 + 60);
  if ((unint64_t)v11 < v54)
  {
    *v11 = v21;
    v22 = v11 + 1;
    goto LABEL_50;
  }
  v23 = (unint64_t)__p;
  v24 = v11 - (_BYTE *)__p;
  v25 = v11 - (_BYTE *)__p + 1;
  if (v25 < 0)
    sub_20BDDF694();
  v26 = v54 - (_QWORD)__p;
  if (2 * (v54 - (unint64_t)__p) > v25)
    v25 = 2 * v26;
  if (v26 >= 0x3FFFFFFFFFFFFFFFLL)
    v27 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v27 = v25;
  if (v27)
    v28 = operator new(v27);
  else
    v28 = 0;
  v29 = (char *)v28 + v27;
  *((_BYTE *)v28 + v24) = v21;
  v22 = (char *)v28 + v24 + 1;
  if (v11 == (char *)v23)
  {
    __p = (char *)v28 + v24;
    __dst = (char *)v28 + v24 + 1;
    v54 = (unint64_t)v29;
LABEL_49:
    operator delete(v11);
    goto LABEL_50;
  }
  v30 = &v11[~v23];
  do
  {
    v31 = *--v11;
    (v30--)[(_QWORD)v28] = v31;
  }
  while (v11 != (char *)v23);
  v11 = (char *)__p;
  __p = v28;
  __dst = (char *)v28 + v24 + 1;
  v54 = (unint64_t)v29;
  if (v11)
    goto LABEL_49;
LABEL_50:
  __dst = v22;
  if (*(_DWORD *)(a1 + 24) == 1)
  {
    if ((unint64_t)v22 >= v54)
    {
      v33 = (unint64_t)__p;
      v34 = v22 - (_BYTE *)__p;
      v35 = v22 - (_BYTE *)__p + 1;
      if (v35 < 0)
        sub_20BDDF694();
      v36 = v54 - (_QWORD)__p;
      if (2 * (v54 - (unint64_t)__p) > v35)
        v35 = 2 * v36;
      if (v36 >= 0x3FFFFFFFFFFFFFFFLL)
        v37 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v37 = v35;
      if (v37)
        v38 = operator new(v37);
      else
        v38 = 0;
      v39 = (char *)v38 + v37;
      *((_BYTE *)v38 + v34) = 0;
      v32 = (char *)v38 + v34 + 1;
      if (v22 == (char *)v33)
      {
        __p = (char *)v38 + v34;
        __dst = (char *)v38 + v34 + 1;
        v54 = (unint64_t)v39;
      }
      else
      {
        v40 = &v22[~v33];
        do
        {
          v41 = *--v22;
          (v40--)[(_QWORD)v38] = v41;
        }
        while (v22 != (char *)v33);
        v22 = (char *)__p;
        __p = v38;
        __dst = (char *)v38 + v34 + 1;
        v54 = (unint64_t)v39;
        if (!v22)
          goto LABEL_69;
      }
      operator delete(v22);
    }
    else
    {
      *v22 = 0;
      v32 = v22 + 1;
    }
LABEL_69:
    __dst = v32;
  }
  v43 = *(_QWORD *)(a1 + 64);
  v42 = *(std::__shared_weak_count **)(a1 + 72);
  if (v42)
  {
    p_shared_owners = (unint64_t *)&v42->__shared_owners_;
    do
      v45 = __ldxr(p_shared_owners);
    while (__stxr(v45 + 1, p_shared_owners));
  }
  sub_20BDFFCF0((unint64_t *)&__p, *(double *)(v43 + 8));
  sub_20BDFF788((unint64_t *)&__p, (*(_QWORD *)(v43 + 24) - *(_QWORD *)(v43 + 16)) >> 3, 2);
  v46 = *(_QWORD *)(v43 + 16);
  if (*(_QWORD *)(v43 + 24) != v46)
  {
    v47 = 0;
    do
    {
      sub_20BDFFCF0((unint64_t *)&__p, *(double *)(v46 + 8 * v47++));
      v46 = *(_QWORD *)(v43 + 16);
    }
    while (v47 < (*(_QWORD *)(v43 + 24) - v46) >> 3);
  }
  if (v42)
  {
    v48 = (unint64_t *)&v42->__shared_owners_;
    do
      v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
LABEL_81:
  if (__p != __dst)
    Alembic::Util::v12::SpookyHash::Update(a2, __p, (_BYTE *)__dst - (_BYTE *)__p);
  if ((char)v51 < 0)
    operator delete(v50[0]);
  if (__p)
  {
    __dst = __p;
    operator delete(__p);
  }
}

void sub_20BE0020C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18)
{
  if (a16 < 0)
    operator delete(__p);
  if (a17)
    operator delete(a17);
  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_20BE0026C(unsigned __int8 *result, unint64_t *a2)
{
  uint64_t v2;
  size_t v3;
  unsigned __int8 *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _BYTE v11[304];

  v2 = *((_QWORD *)result + 1);
  v3 = v2 - *(_QWORD *)result;
  if (v2 != *(_QWORD *)result)
  {
    v5 = result;
    Alembic::Util::v12::SpookyHash::Init((uint64_t)v11, 0, 0);
    Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)v11, *(_QWORD **)v5, v3);
    Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)v11, a2, 0x10uLL);
    v9 = 0;
    v10 = 0;
    result = Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)v11, &v10, &v9, v6, v7);
    v8 = v9;
    *a2 = v10;
    a2[1] = v8;
  }
  return result;
}

char *sub_20BE002F4(const void **a1)
{
  const void *v1;
  char *v2;
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  char v9[16];
  uint64_t v10[33];

  v1 = *a1;
  if (!v1
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"NULL Impl Ptr", 13);
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return v2 + 192;
}

void sub_20BE003AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BE003D4(Alembic::Ogawa::v12::OGroup **a1, uint64_t a2, int a3)
{
  const void *v4;
  unint64_t v5;
  Alembic::Ogawa::v12::OGroup *v6;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  Alembic::Ogawa::v12::OData *v11;
  std::__shared_weak_count *v12;

  v4 = *(const void **)a2;
  v5 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v6 = *a1;
  if ((a3 - 14) > 0xFFFFFFFD || v5 > 0xF)
  {
    Alembic::Ogawa::v12::OGroup::addData(v6, v4, v5, &v11);
    v8 = v12;
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  else
  {
    Alembic::Ogawa::v12::OGroup::addEmptyData(v6);
  }
}

void sub_20BE00464(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  int v25;
  uint64_t *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  char *v39;
  unint64_t v40;
  uint64_t v41;
  int64_t v42;
  unint64_t v43;
  size_t v44;
  char *v45;
  char *v46;
  char *v47;
  char *v48;
  char v49;
  unint64_t v50;
  uint64_t v51;
  int64_t v52;
  unint64_t v53;
  size_t v54;
  char *v55;
  char *v56;
  char *v57;
  char v58;
  __int128 v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  void *v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  char *v80;
  _DWORD *v81;
  char *v82;
  int64_t v83;
  unint64_t v84;
  int64_t v85;
  unint64_t v86;
  char *v87;
  char *v88;
  int v89;
  _BYTE *v90;
  _DWORD *v91;
  uint64_t v92;
  unint64_t v93;
  int64_t v94;
  unint64_t v95;
  char *v96;
  char *v97;
  int v98;
  _BYTE *v99;
  _BYTE *v100;
  int64_t v101;
  _OWORD *v102;
  __int128 v103;
  unint64_t *v104;
  unint64_t v105;
  uint64_t *v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  uint64_t v110;
  __int128 v111;
  uint64_t v112;
  unint64_t *v113;
  unint64_t v114;
  unint64_t *v115;
  unint64_t v116;
  std::__shared_weak_count *v117;
  unint64_t *v118;
  unint64_t v119;
  std::__shared_weak_count *v120;
  unint64_t *v121;
  unint64_t v122;
  std::__shared_weak_count *v123;
  unint64_t *v124;
  unint64_t v125;
  _QWORD *v126;
  _QWORD *v127;
  _QWORD *exception;
  _QWORD *v129;
  Alembic::Ogawa::v12::OGroup **v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t *v133;
  uint64_t *v134;
  _QWORD *v135;
  uint64_t v136;
  uint64_t v138;
  std::__shared_weak_count *v139;
  __int128 v140;
  void *v141[2];
  char v142;
  void *__p[2];
  _QWORD v144[2];
  __int128 v145;
  uint64_t v146[2];
  Alembic::Ogawa::v12::OGroup *v147;
  std::__shared_weak_count *v148;
  unint64_t v149;
  int64_t v150;
  void *v151;
  _BYTE *v152;
  _QWORD v153[35];

  v5 = (_QWORD *)a4;
  v7 = (uint64_t)a1;
  v153[33] = *MEMORY[0x24BDAC8D0];
  v9 = sub_20BE0175C(a1, a4);
  if (v9)
  {
    v10 = v9[6];
    *a5 = v10;
    v11 = v9[7];
    a5[1] = v11;
    if (v11)
    {
      v12 = (unint64_t *)(v11 + 8);
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
      v10 = *a5;
    }
    if (v10)
    {
      v14 = *(std::__shared_weak_count **)(a2 + 8);
      v147 = *(Alembic::Ogawa::v12::OGroup **)a2;
      v148 = v14;
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          v16 = __ldxr(p_shared_owners);
        while (__stxr(v16 + 1, p_shared_owners));
        v10 = *a5;
      }
      v17 = (std::__shared_weak_count *)a5[1];
      v146[0] = v10;
      v146[1] = (uint64_t)v17;
      if (v17)
      {
        v18 = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldxr(v18);
        while (__stxr(v19 + 1, v18));
      }
      sub_20BE00F2C((uint64_t *)&v147, v146);
      if (v17)
      {
        v20 = (unint64_t *)&v17->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      v22 = v148;
      if (v148)
      {
        v23 = (unint64_t *)&v148->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      return;
    }
  }
  else
  {
    *a5 = 0;
    a5[1] = 0;
  }
  v145 = 0uLL;
  v25 = *(_DWORD *)(a3 + 8);
  if (v25 == 13)
  {
    v67 = *(unsigned __int8 *)(a3 + 12);
    v68 = *(uint64_t **)(a3 + 16);
    v69 = *(_QWORD *)(a3 + 24) - (_QWORD)v68;
    v135 = v5;
    if (v69)
    {
      v70 = v69 >> 3;
      if (v70 <= 1)
        v71 = 1;
      else
        v71 = v70;
      v69 = 1;
      do
      {
        v72 = *v68++;
        v69 *= v72;
        --v71;
      }
      while (v71);
    }
    v134 = a5;
    v73 = v69 * v67;
    __p[0] = 0;
    __p[1] = 0;
    v144[0] = 0;
    if (!(v69 * v67))
    {
      v90 = 0;
      v99 = 0;
LABEL_147:
      v5 = v135;
      v151 = v135 + 2;
      v152 = v99;
      v149 = 16;
      v150 = v90 - v99;
      Alembic::Ogawa::v12::OGroup::addData(*(Alembic::Ogawa::v12::OGroup **)a2, &v149, (const void **)&v151, 2, (Alembic::Ogawa::v12::OData **)v141);
      v145 = *(_OWORD *)v141;
      v66 = __p[0];
      a5 = v134;
      if (!__p[0])
        goto LABEL_149;
      goto LABEL_148;
    }
    v131 = a2;
    v74 = 0;
    while (1)
    {
      v75 = *(_QWORD *)a3 + 24 * v74;
      if (std::wstring::find((const std::wstring *)v75, 0, 0) != -1)
      {
        sub_20BDDBD68((uint64_t)&v151);
        sub_20BDDC1C8(v153, (uint64_t)"Illegal NULL character found in wstring data", 44);
        std::stringbuf::str();
        sub_20BDDBF20(&v149, (__int128 *)v141);
        if (v142 < 0)
          operator delete(v141[0]);
        exception = __cxa_allocate_exception(0x20uLL);
        v129 = sub_20BDDC09C(exception, (uint64_t)&v149);
        __cxa_throw(v129, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
      }
      if (*(char *)(v75 + 23) < 0)
      {
        v76 = *(_QWORD *)(v75 + 8);
        if (v76)
        {
LABEL_104:
          v77 = 0;
          do
          {
            v78 = v75;
            if (*(char *)(v75 + 23) < 0)
              v78 = *(_QWORD *)v75;
            v79 = *(_DWORD *)(v78 + 4 * v77);
            v80 = (char *)__p[1];
            if (__p[1] >= (void *)v144[0])
            {
              v82 = (char *)__p[0];
              v83 = ((char *)__p[1] - (char *)__p[0]) >> 2;
              v84 = v83 + 1;
              if ((unint64_t)(v83 + 1) >> 62)
                sub_20BDDF694();
              v85 = v144[0] - (unint64_t)__p[0];
              if ((uint64_t)(v144[0] - (unint64_t)__p[0]) >> 1 > v84)
                v84 = v85 >> 1;
              if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFFCLL)
                v86 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v86 = v84;
              if (v86)
              {
                v87 = (char *)sub_20BDE1330((uint64_t)v144, v86);
                v82 = (char *)__p[0];
                v80 = (char *)__p[1];
              }
              else
              {
                v87 = 0;
              }
              v88 = &v87[4 * v83];
              *(_DWORD *)v88 = v79;
              v81 = v88 + 4;
              while (v80 != v82)
              {
                v89 = *((_DWORD *)v80 - 1);
                v80 -= 4;
                *((_DWORD *)v88 - 1) = v89;
                v88 -= 4;
              }
              __p[0] = v88;
              __p[1] = v81;
              v144[0] = &v87[4 * v86];
              if (v82)
                operator delete(v82);
            }
            else
            {
              *(_DWORD *)__p[1] = v79;
              v81 = v80 + 4;
            }
            __p[1] = v81;
            ++v77;
          }
          while (v77 != v76);
          goto LABEL_127;
        }
      }
      else
      {
        v76 = *(unsigned __int8 *)(v75 + 23);
        if (*(_BYTE *)(v75 + 23))
          goto LABEL_104;
      }
      v81 = __p[1];
LABEL_127:
      if ((unint64_t)v81 >= v144[0])
      {
        v91 = __p[0];
        v92 = ((char *)v81 - (char *)__p[0]) >> 2;
        v93 = v92 + 1;
        if ((unint64_t)(v92 + 1) >> 62)
          sub_20BDDF694();
        v94 = v144[0] - (unint64_t)__p[0];
        if ((uint64_t)(v144[0] - (unint64_t)__p[0]) >> 1 > v93)
          v93 = v94 >> 1;
        if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFFCLL)
          v95 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v95 = v93;
        if (v95)
        {
          v96 = (char *)sub_20BDE1330((uint64_t)v144, v95);
          v91 = __p[0];
          v81 = __p[1];
        }
        else
        {
          v96 = 0;
        }
        v97 = &v96[4 * v92];
        *(_DWORD *)v97 = 0;
        v90 = v97 + 4;
        while (v81 != v91)
        {
          v98 = *--v81;
          *((_DWORD *)v97 - 1) = v98;
          v97 -= 4;
        }
        __p[0] = v97;
        __p[1] = v90;
        v144[0] = &v96[4 * v95];
        if (v91)
          operator delete(v91);
      }
      else
      {
        *v81 = 0;
        v90 = v81 + 1;
      }
      __p[1] = v90;
      if (++v74 == v73)
      {
        v99 = __p[0];
        a2 = v131;
        goto LABEL_147;
      }
    }
  }
  if (v25 != 12)
  {
    v100 = *(_BYTE **)a3;
    v151 = v5 + 2;
    v152 = v100;
    v101 = *v5;
    v149 = 16;
    v150 = v101;
    Alembic::Ogawa::v12::OGroup::addData(*(Alembic::Ogawa::v12::OGroup **)a2, &v149, (const void **)&v151, 2, (Alembic::Ogawa::v12::OData **)__p);
    v145 = *(_OWORD *)__p;
    goto LABEL_149;
  }
  v26 = *(uint64_t **)(a3 + 16);
  v27 = *(_QWORD *)(a3 + 24) - (_QWORD)v26;
  if (v27)
  {
    v28 = v27 >> 3;
    if (v28 <= 1)
      v29 = 1;
    else
      v29 = v28;
    v27 = 1;
    do
    {
      v30 = *v26++;
      v27 *= v30;
      --v29;
    }
    while (v29);
  }
  v130 = (Alembic::Ogawa::v12::OGroup **)a2;
  v132 = v7;
  v133 = a5;
  v31 = v27 * *(unsigned __int8 *)(a3 + 12);
  __p[0] = 0;
  __p[1] = 0;
  v144[0] = 0;
  v136 = v31;
  v32 = 0;
  if (v31)
  {
    v33 = 0;
    while (1)
    {
      v34 = *(_QWORD *)a3 + 24 * v33;
      if (std::string::find((const std::string *)v34, 0, 0) != -1)
      {
        sub_20BDDBD68((uint64_t)&v151);
        sub_20BDDC1C8(v153, (uint64_t)"Illegal NULL character found in string data ", 44);
        std::stringbuf::str();
        sub_20BDDBF20(&v149, (__int128 *)v141);
        if (v142 < 0)
          operator delete(v141[0]);
        v126 = __cxa_allocate_exception(0x20uLL);
        v127 = sub_20BDDC09C(v126, (uint64_t)&v149);
        __cxa_throw(v127, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
      }
      if (*(char *)(v34 + 23) < 0)
      {
        v35 = *(_QWORD *)(v34 + 8);
        if (v35)
        {
LABEL_38:
          v36 = 0;
          do
          {
            v37 = v34;
            if (*(char *)(v34 + 23) < 0)
              v37 = *(_QWORD *)v34;
            v38 = *(_BYTE *)(v37 + v36);
            if ((unint64_t)v32 >= v144[0])
            {
              v40 = (unint64_t)__p[0];
              v41 = v32 - (char *)__p[0];
              v42 = v32 - (char *)__p[0] + 1;
              if (v42 < 0)
                sub_20BDDF694();
              v43 = v144[0] - (unint64_t)__p[0];
              if (2 * (v144[0] - (unint64_t)__p[0]) > v42)
                v42 = 2 * v43;
              if (v43 >= 0x3FFFFFFFFFFFFFFFLL)
                v44 = 0x7FFFFFFFFFFFFFFFLL;
              else
                v44 = v42;
              if (v44)
                v45 = (char *)operator new(v44);
              else
                v45 = 0;
              v46 = &v45[v41];
              v47 = &v45[v41];
              *v47 = v38;
              v39 = v47 + 1;
              if (v32 != (char *)v40)
              {
                v48 = &v32[~v40];
                do
                {
                  v49 = *--v32;
                  (v48--)[(_QWORD)v45] = v49;
                }
                while (v32 != (char *)v40);
                v32 = (char *)__p[0];
                v46 = v45;
              }
              __p[0] = v46;
              v144[0] = &v45[v44];
              if (v32)
                operator delete(v32);
            }
            else
            {
              *v32 = v38;
              v39 = v32 + 1;
            }
            __p[1] = v39;
            ++v36;
            v32 = v39;
          }
          while (v36 != v35);
          goto LABEL_62;
        }
      }
      else
      {
        v35 = *(unsigned __int8 *)(v34 + 23);
        if (*(_BYTE *)(v34 + 23))
          goto LABEL_38;
      }
      v39 = v32;
LABEL_62:
      if ((unint64_t)v39 >= v144[0])
      {
        v50 = (unint64_t)__p[0];
        v51 = v39 - (char *)__p[0];
        v52 = v39 - (char *)__p[0] + 1;
        if (v52 < 0)
          sub_20BDDF694();
        v53 = v144[0] - (unint64_t)__p[0];
        if (2 * (v144[0] - (unint64_t)__p[0]) > v52)
          v52 = 2 * v53;
        if (v53 >= 0x3FFFFFFFFFFFFFFFLL)
          v54 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v54 = v52;
        if (v54)
          v55 = (char *)operator new(v54);
        else
          v55 = 0;
        v56 = &v55[v51];
        v55[v51] = 0;
        v32 = &v55[v51 + 1];
        if (v39 != (char *)v50)
        {
          v57 = &v39[~v50];
          do
          {
            v58 = *--v39;
            (v57--)[(_QWORD)v55] = v58;
          }
          while (v39 != (char *)v50);
          v39 = (char *)__p[0];
          v56 = v55;
        }
        __p[0] = v56;
        v144[0] = &v55[v54];
        if (v39)
          operator delete(v39);
      }
      else
      {
        *v39 = 0;
        v32 = v39 + 1;
      }
      __p[1] = v32;
      if (++v33 == v136)
      {
        v31 = (uint64_t)__p[0];
        break;
      }
    }
  }
  v151 = v5 + 2;
  v152 = (_BYTE *)v31;
  v149 = 16;
  v150 = (int64_t)&v32[-v31];
  Alembic::Ogawa::v12::OGroup::addData(*v130, &v149, (const void **)&v151, 2, (Alembic::Ogawa::v12::OData **)v141);
  v59 = *(_OWORD *)v141;
  v141[0] = 0;
  v141[1] = 0;
  v60 = (std::__shared_weak_count *)*((_QWORD *)&v145 + 1);
  v145 = v59;
  v7 = v132;
  a5 = v133;
  if (v60)
  {
    v61 = (unint64_t *)&v60->__shared_owners_;
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
    }
  }
  v63 = (std::__shared_weak_count *)v141[1];
  if (v141[1])
  {
    v64 = (unint64_t *)((char *)v141[1] + 8);
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }
  v66 = __p[0];
  if (__p[0])
  {
LABEL_148:
    __p[1] = v66;
    operator delete(v66);
  }
LABEL_149:
  v102 = operator new(0x38uLL);
  v103 = v145;
  v140 = v145;
  if (*((_QWORD *)&v145 + 1))
  {
    v104 = (unint64_t *)(*((_QWORD *)&v145 + 1) + 8);
    do
      v105 = __ldxr(v104);
    while (__stxr(v105 + 1, v104));
  }
  v106 = *(uint64_t **)(a3 + 16);
  v107 = *(_QWORD *)(a3 + 24) - (_QWORD)v106;
  if (v107)
  {
    v108 = v107 >> 3;
    if (v108 <= 1)
      v109 = 1;
    else
      v109 = v108;
    v107 = 1;
    do
    {
      v110 = *v106++;
      v107 *= v110;
      --v109;
    }
    while (v109);
  }
  v111 = *((_OWORD *)v5 + 1);
  v112 = v107 * *(unsigned __int8 *)(a3 + 12);
  *v102 = *(_OWORD *)v5;
  v102[1] = v111;
  v102[2] = v103;
  if (*((_QWORD *)&v103 + 1))
  {
    v113 = (unint64_t *)(*((_QWORD *)&v103 + 1) + 8);
    do
      v114 = __ldxr(v113);
    while (__stxr(v114 + 1, v113));
  }
  *((_QWORD *)v102 + 6) = v112;
  sub_20BDEB47C(a5, (uint64_t)v102);
  if (*((_QWORD *)&v103 + 1))
  {
    v115 = (unint64_t *)(*((_QWORD *)&v103 + 1) + 8);
    do
      v116 = __ldaxr(v115);
    while (__stlxr(v116 - 1, v115));
    if (!v116)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v103 + 1) + 16))(*((_QWORD *)&v103 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v103 + 1));
    }
  }
  v117 = (std::__shared_weak_count *)a5[1];
  v138 = *a5;
  v139 = v117;
  if (v117)
  {
    v118 = (unint64_t *)&v117->__shared_owners_;
    do
      v119 = __ldxr(v118);
    while (__stxr(v119 + 1, v118));
  }
  sub_20BDEB394(v7, &v138);
  v120 = v139;
  if (v139)
  {
    v121 = (unint64_t *)&v139->__shared_owners_;
    do
      v122 = __ldaxr(v121);
    while (__stlxr(v122 - 1, v121));
    if (!v122)
    {
      ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
      std::__shared_weak_count::__release_weak(v120);
    }
  }
  v123 = (std::__shared_weak_count *)*((_QWORD *)&v145 + 1);
  if (*((_QWORD *)&v145 + 1))
  {
    v124 = (unint64_t *)(*((_QWORD *)&v145 + 1) + 8);
    do
      v125 = __ldaxr(v124);
    while (__stlxr(v125 - 1, v124));
    if (!v125)
    {
      ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
      std::__shared_weak_count::__release_weak(v123);
    }
  }
}

void sub_20BE00E5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,char a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  if (__p)
    operator delete(__p);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a27);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(a11);
  _Unwind_Resume(a1);
}

void sub_20BE00F2C(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  Alembic::Ogawa::v12::OData *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *exception;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  Alembic::Ogawa::v12::OData *v15;
  std::__shared_weak_count *v16;
  void *__p[2];
  char v18;
  _QWORD v19[4];
  _BYTE v20[16];
  _QWORD v21[33];

  v2 = *a2;
  if (!*a2)
  {
    sub_20BDDBD68((uint64_t)v20);
    sub_20BDDC1C8(v21, (uint64_t)"CopyWrittenData() passed a bogus ref", 36);
    std::stringbuf::str();
    sub_20BDDBF20(v19, (__int128 *)__p);
    if (v18 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v12 = sub_20BDDC09C(exception, (uint64_t)v19);
    __cxa_throw(v12, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v3 = *a1;
  if (!v3)
  {
    sub_20BDDBD68((uint64_t)v20);
    sub_20BDDC1C8(v21, (uint64_t)"CopyWrittenData() passed in a bogus OGroupPtr", 45);
    std::stringbuf::str();
    sub_20BDDBF20(v19, (__int128 *)__p);
    if (v18 < 0)
      operator delete(__p[0]);
    v13 = __cxa_allocate_exception(0x20uLL);
    v14 = sub_20BDDC09C(v13, (uint64_t)v19);
    __cxa_throw(v14, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v5 = *(Alembic::Ogawa::v12::OData **)(v2 + 32);
  v4 = *(std::__shared_weak_count **)(v2 + 40);
  v15 = v5;
  v16 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  Alembic::Ogawa::v12::OGroup::addData(v3, &v15);
  v8 = v16;
  if (v16)
  {
    v9 = (unint64_t *)&v16->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_20BE0109C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  std::exception v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BE010E0(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, uint64_t *a9)
{
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  BOOL v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  char *v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  _QWORD *exception;
  _QWORD *v44;
  __int128 __p;
  char v48;
  _QWORD v49[4];
  char v50[16];
  uint64_t v51[33];
  char *v52;
  uint64_t v53;
  unsigned __int8 v54;

  Alembic::Util::v12::TokenMap::get((Alembic::Util::v12::TokenMap *)(a2 + 32), 0x3Bu, 61, 1);
  if ((v54 & 0x80u) == 0)
    v15 = v54;
  else
    v15 = v53;
  if (*(char *)(a2 + 23) >= 0)
    v16 = *(unsigned __int8 *)(a2 + 23);
  else
    v16 = *(_DWORD *)(a2 + 8);
  if (v15 <= v16)
    v17 = v16;
  else
    v17 = v15;
  if (v17 <= a6)
    v17 = a6;
  if (v17 <= a5)
    v17 = a5;
  v18 = v17 - 256;
  v19 = 2 * ((v17 & 0xFFFF0000) != 0);
  if (v18 >> 8 < 0xFF)
    v20 = 1;
  else
    v20 = v19;
  v21 = sub_20BDF2E2C(*a9, (uint64_t)&v52);
  v22 = (v21 << 20) | (4 * v20);
  if (*(_DWORD *)(a2 + 24))
  {
    v23 = *(_DWORD *)(a2 + 24) & 3 | a3 & 0xFFFFFF0F | (16 * (*(_DWORD *)(a2 + 56) & 0xF)) | v22;
    if (a5)
      v23 |= 0x100u;
    v24 = a8 | a7;
    v25 = v23 | 0x800;
    v26 = a7 == 1 && a6 - 1 == a8;
    v27 = !v26;
    if (!v26)
      v23 |= 0x200u;
    if (v24)
      v28 = v27;
    else
      v28 = 0;
    if (!v24)
      v23 = v25;
    if (a7 > a8 || a7 > a6 || a8 > a6)
    {
      sub_20BDDBD68((uint64_t)v50);
      v36 = sub_20BDDC1C8(v51, (uint64_t)"Illegal Sampling!", 17);
      v37 = sub_20BE01468(v36);
      sub_20BDDC1C8(v37, (uint64_t)"Num Samples: ", 13);
      v38 = (_QWORD *)std::ostream::operator<<();
      v39 = sub_20BE01468(v38);
      sub_20BDDC1C8(v39, (uint64_t)"First Changed Index: ", 21);
      v40 = (_QWORD *)std::ostream::operator<<();
      v41 = sub_20BE01468(v40);
      sub_20BDDC1C8(v41, (uint64_t)"Last Changed Index: ", 20);
      v42 = (_QWORD *)std::ostream::operator<<();
      sub_20BE01468(v42);
      std::stringbuf::str();
      sub_20BDDBF20(v49, &__p);
      if (v48 < 0)
        operator delete((void *)__p);
      exception = __cxa_allocate_exception(0x20uLL);
      v44 = sub_20BDDC09C(exception, (uint64_t)v49);
      __cxa_throw(v44, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
    v29 = v23 | (*(unsigned __int8 *)(a2 + 60) << 12);
    if (a4)
      v30 = v29 | 0x400;
    else
      v30 = v29;
    sub_20BDFF788((unint64_t *)a1, v30, 2);
    sub_20BDFF788((unint64_t *)a1, a6, v20);
    if (v28)
    {
      sub_20BDFF788((unint64_t *)a1, a7, v20);
      sub_20BDFF788((unint64_t *)a1, a8, v20);
    }
    if (a5)
      sub_20BDFF788((unint64_t *)a1, a5, v20);
  }
  else
  {
    sub_20BDFF788((unint64_t *)a1, v22, 2);
  }
  sub_20BDFF788((unint64_t *)a1, v16, v20);
  v31 = *(char *)(a2 + 23);
  if (v31 >= 0)
    v32 = (char *)a2;
  else
    v32 = *(char **)a2;
  if (v31 >= 0)
    v33 = *(unsigned __int8 *)(a2 + 23);
  else
    v33 = *(_QWORD *)(a2 + 8);
  sub_20BDF36D0((char **)a1, *(char **)(a1 + 8), v32, &v32[v33], v33);
  if (v21 == 255)
  {
    sub_20BDFF788((unint64_t *)a1, v15, v20);
    if (v15)
    {
      if ((v54 & 0x80u) == 0)
        v34 = (char *)&v52;
      else
        v34 = v52;
      if ((v54 & 0x80u) == 0)
        v35 = v54;
      else
        v35 = v53;
      sub_20BDF36D0((char **)a1, *(char **)(a1 + 8), v34, &v34[v35], v35);
    }
  }
  if ((char)v54 < 0)
    operator delete(v52);
}

void sub_20BE01418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  std::exception v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v8.__vftable = va_arg(va1, std::exception_vtbl *);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  if (*(char *)(v6 - 89) < 0)
    operator delete(*(void **)(v6 - 112));
  _Unwind_Resume(a1);
}

_QWORD *sub_20BE01468(_QWORD *a1)
{
  const std::locale::facet *v2;
  std::locale v4;

  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
  v2 = std::locale::use_facet(&v4, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  std::ostream::flush();
  return a1;
}

void sub_20BE014E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

void sub_20BE014F8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v6;
  int v7;
  char *v8;
  uint64_t v9;
  int v10;
  int v11;
  char *p_p;
  uint64_t v13;
  void *__p;
  uint64_t v15;
  unsigned __int8 v16;

  if (*(char *)(a2 + 23) >= 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_DWORD *)(a2 + 8);
  sub_20BDFF788((unint64_t *)a1, v6, 2);
  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (char *)a2;
  else
    v8 = *(char **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  sub_20BDF36D0((char **)a1, *(char **)(a1 + 8), v8, &v8[v9], v9);
  Alembic::Util::v12::TokenMap::get((Alembic::Util::v12::TokenMap *)(a2 + 48), 0x3Bu, 61, 1);
  if ((v16 & 0x80u) == 0)
    v10 = v16;
  else
    v10 = v15;
  v11 = sub_20BDF2E2C(*a3, (uint64_t)&__p);
  sub_20BDFF788((unint64_t *)a1, v11, 0);
  if (v11 == 255)
  {
    sub_20BDFF788((unint64_t *)a1, v10, 2);
    if (v10)
    {
      if ((v16 & 0x80u) == 0)
        p_p = (char *)&__p;
      else
        p_p = (char *)__p;
      if ((v16 & 0x80u) == 0)
        v13 = v16;
      else
        v13 = v15;
      sub_20BDF36D0((char **)a1, *(char **)(a1 + 8), p_p, &p_p[v13], v13);
    }
  }
  if ((char)v16 < 0)
    operator delete(__p);
}

void sub_20BE01614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_20BE01634(unint64_t *a1, int a2, uint64_t a3)
{
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *exception;
  _QWORD *v9;
  __int128 __p;
  char v11;
  _QWORD v12[4];
  _BYTE v13[16];
  _QWORD v14[33];

  sub_20BDFF788(a1, a2, 2);
  sub_20BDFFCF0(a1, *(double *)(a3 + 8));
  v5 = *(_QWORD *)(a3 + 24) - *(_QWORD *)(a3 + 16);
  if (!v5)
  {
    sub_20BDDBD68((uint64_t)v13);
    sub_20BDDC1C8(v14, (uint64_t)"No TimeSamples to write!", 24);
    std::stringbuf::str();
    sub_20BDDBF20(v12, &__p);
    if (v11 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v9 = sub_20BDDC09C(exception, (uint64_t)v12);
    __cxa_throw(v9, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDFF788(a1, v5 >> 3, 2);
  v6 = *(_QWORD *)(a3 + 16);
  if (*(_QWORD *)(a3 + 24) != v6)
  {
    v7 = 0;
    do
    {
      sub_20BDFFCF0(a1, *(double *)(v6 + 8 * v7++));
      v6 = *(_QWORD *)(a3 + 16);
    }
    while (v7 < (*(_QWORD *)(a3 + 24) - v6) >> 3);
  }
}

void sub_20BE01734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BE0175C(_QWORD *a1, uint64_t a2)
{
  int8x8_t v2;
  unint64_t v4;
  uint8x8_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  v6 = v5.u32[0];
  if (v5.u32[0] > 1uLL)
  {
    v7 = *(_QWORD *)(a2 + 16);
    if (v4 >= *(_QWORD *)&v2)
      v7 = v4 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = (*(_QWORD *)&v2 - 1) & v4;
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  v9 = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = v9[1];
      if (v4 == v10)
      {
        if (sub_20BDEC684((uint64_t)(v9 + 2), a2))
          return v9;
      }
      else
      {
        if (v6 > 1)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      v9 = (_QWORD *)*v9;
    }
    while (v9);
  }
  return v9;
}

void Alembic::Abc::v12::GetArchiveInfo(char **a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, double *a7)
{
  char *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  unint64_t *v20;
  unint64_t v21;
  const void ***v22;
  unint64_t *v23;
  unint64_t v24;
  char *v25;
  void *__p[2];
  char v27;
  char *v28[2];
  uint64_t v29;
  uint64_t v30[3];

  v14 = a1[4];
  v15 = (std::__shared_weak_count *)a1[5];
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (v18)
    {
      if (!v14)
        return;
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
      if (!v14)
        return;
    }
    v14 = a1[4];
    v19 = a1[5];
    v28[0] = v14;
    v28[1] = v19;
    if (v19)
    {
      v20 = (unint64_t *)(v19 + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
  }
  else
  {
    if (!v14)
      return;
    v28[0] = a1[4];
    v28[1] = 0;
  }
  v22 = (const void ***)(*(uint64_t (**)(char *))(*(_QWORD *)v14 + 24))(v14);
  sub_20BDEBF8C(v30, v22);
  if (v28[1])
  {
    v23 = (unint64_t *)(v28[1] + 8);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      (*(void (**)(char *))(*(_QWORD *)v28[1] + 16))(v28[1]);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v28[1]);
    }
  }
  sub_20BDDC0E4(__p, "_ai_Application");
  sub_20BE01E1C((uint64_t)v30, (const void **)__p, v28);
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  *(_OWORD *)a2 = *(_OWORD *)v28;
  *(_QWORD *)(a2 + 16) = v29;
  HIBYTE(v29) = 0;
  LOBYTE(v28[0]) = 0;
  if (v27 < 0)
    operator delete(__p[0]);
  sub_20BDDC0E4(__p, "_ai_AlembicVersion");
  sub_20BE01E1C((uint64_t)v30, (const void **)__p, v28);
  if (*(char *)(a3 + 23) < 0)
    operator delete(*(void **)a3);
  *(_OWORD *)a3 = *(_OWORD *)v28;
  *(_QWORD *)(a3 + 16) = v29;
  HIBYTE(v29) = 0;
  LOBYTE(v28[0]) = 0;
  if (v27 < 0)
    operator delete(__p[0]);
  *a4 = Alembic::Abc::v12::IArchive::getArchiveVersion((Alembic::Abc::v12::IArchive *)a1);
  sub_20BDDC0E4(__p, "_ai_DateWritten");
  sub_20BE01E1C((uint64_t)v30, (const void **)__p, v28);
  if (*(char *)(a5 + 23) < 0)
    operator delete(*(void **)a5);
  *(_OWORD *)a5 = *(_OWORD *)v28;
  *(_QWORD *)(a5 + 16) = v29;
  HIBYTE(v29) = 0;
  LOBYTE(v28[0]) = 0;
  if (v27 < 0)
    operator delete(__p[0]);
  sub_20BDDC0E4(__p, "_ai_Description");
  sub_20BE01E1C((uint64_t)v30, (const void **)__p, v28);
  if (*(char *)(a6 + 23) < 0)
    operator delete(*(void **)a6);
  *(_OWORD *)a6 = *(_OWORD *)v28;
  *(_QWORD *)(a6 + 16) = v29;
  HIBYTE(v29) = 0;
  LOBYTE(v28[0]) = 0;
  if (v27 < 0)
    operator delete(__p[0]);
  sub_20BDDC0E4(__p, "_ai_DCC_FPS");
  sub_20BE01E1C((uint64_t)v30, (const void **)__p, v28);
  if (SHIBYTE(v29) < 0)
  {
    v25 = v28[0];
    *a7 = atof(v28[0]);
    operator delete(v25);
  }
  else
  {
    *a7 = atof((const char *)v28);
  }
  if (v27 < 0)
    operator delete(__p[0]);
  sub_20BDE9D48((uint64_t)v30, (_QWORD *)v30[1]);
}

void sub_20BE01B50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, _QWORD *a20)
{
  if (a15 < 0)
    operator delete(__p);
  sub_20BDE9D48((uint64_t)&a19, a20);
  _Unwind_Resume(a1);
}

void sub_20BE01BA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  JUMPOUT(0x20BE01B9CLL);
}

void Alembic::Abc::v12::GetArchiveInfo(char **a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  double v6;

  Alembic::Abc::v12::GetArchiveInfo(a1, a2, a3, a4, a5, a6, &v6);
}

uint64_t Alembic::Abc::v12::GetArchiveStartAndEndTime(Alembic::Abc::v12 *this, Alembic::Abc::v12::IArchive *a2, double *a3, double *a4)
{
  uint64_t result;
  unsigned int v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  uint64_t MaxNumSamplesForTimeSamplingIndex;
  uint64_t v16;
  double SampleTime;
  double v18;
  double v19;
  double v20;
  BOOL v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  Alembic::AbcCoreAbstract::v12::TimeSampling *v27;
  std::__shared_weak_count *v28;

  result = Alembic::Abc::v12::IArchive::getNumTimeSamplings(this);
  if (!(_DWORD)result)
    goto LABEL_37;
  v8 = 0;
  v9 = 1.79769313e308;
  v10 = -1.79769313e308;
  v11 = 1.79769313e308;
  v12 = -1.79769313e308;
  v13 = 1.79769313e308;
  v14 = -1.79769313e308;
  do
  {
    MaxNumSamplesForTimeSamplingIndex = Alembic::Abc::v12::IArchive::getMaxNumSamplesForTimeSamplingIndex(this);
    if (MaxNumSamplesForTimeSamplingIndex != 0x7FFFFFFFFFFFFFFFLL)
    {
      v16 = MaxNumSamplesForTimeSamplingIndex;
      Alembic::Abc::v12::IArchive::getTimeSampling(this, &v27);
      if (v27)
      {
        if (v16 >= 2 && v8)
        {
          SampleTime = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v27, 0);
          v18 = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v27, v16 - 1);
          if (v11 >= SampleTime)
            v11 = SampleTime;
          if (v18 >= v12)
            v12 = v18;
        }
        else if (v16 == 1 && v8)
        {
          v19 = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v27, 0);
          v20 = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v27, 0);
          if (v13 >= v19)
            v13 = v19;
          if (v20 >= v14)
            v14 = v20;
        }
        else
        {
          v21 = v16 < 1;
          v22 = v16 - 1;
          if (!v21 && !v8)
          {
            v9 = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v27, 0);
            v10 = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v27, v22);
          }
        }
      }
      v23 = v28;
      if (v28)
      {
        p_shared_owners = (unint64_t *)&v28->__shared_owners_;
        do
          v25 = __ldaxr(p_shared_owners);
        while (__stlxr(v25 - 1, p_shared_owners));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
    }
    ++v8;
    result = Alembic::Abc::v12::IArchive::getNumTimeSamplings(this);
  }
  while (v8 < result);
  if (v11 == 1.79769313e308 || v12 == -1.79769313e308)
  {
    if (v13 == 1.79769313e308 || (v11 = v13, v12 = v14, v14 == -1.79769313e308))
    {
      if (v9 == 1.79769313e308 || (v11 = v9, v12 = v10, v10 == -1.79769313e308))
      {
LABEL_37:
        v12 = -1.79769313e308;
        v11 = 1.79769313e308;
      }
    }
  }
  *(double *)a2 = v11;
  *a3 = v12;
  return result;
}

void sub_20BE01DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BE01E1C@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *result;
  __int128 v6;

  result = (_QWORD *)sub_20BDEEBA4(a1, a2);
  if ((_QWORD *)(a1 + 8) == result)
    return sub_20BDDC0E4(a3, "");
  if (*((char *)result + 79) < 0)
    return sub_20BDDBFAC(a3, (void *)result[7], result[8]);
  v6 = *(_OWORD *)(result + 7);
  a3[2] = result[9];
  *(_OWORD *)a3 = v6;
  return result;
}

void Alembic::Abc::v12::ErrorHandler::operator()(_DWORD *a1, uint64_t a2, const void **a3)
{
  size_t v6;
  std::string *v7;
  const void *v8;
  const std::string::value_type *v9;
  std::string *v10;
  __int128 v11;
  std::string v12;
  void *__p[2];
  std::string::size_type v14;

  if (*((char *)a3 + 23) >= 0)
    v6 = *((unsigned __int8 *)a3 + 23);
  else
    v6 = (size_t)a3[1];
  v7 = &v12;
  sub_20BDF6BDC((uint64_t)&v12, v6 + 19);
  if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v7 = (std::string *)v12.__r_.__value_.__r.__words[0];
  if (v6)
  {
    if (*((char *)a3 + 23) >= 0)
      v8 = a3;
    else
      v8 = *a3;
    memmove(v7, v8, v6);
  }
  strcpy((char *)v7 + v6, "\nERROR: EXCEPTION:\n");
  v9 = (const std::string::value_type *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  v10 = std::string::append(&v12, v9);
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v14 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  Alembic::Abc::v12::ErrorHandler::handleIt(a1, (uint64_t)__p);
  if (SHIBYTE(v14) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v12.__r_.__value_.__l.__data_);
}

{
  size_t v6;
  std::string *v7;
  const void *v8;
  int v9;
  const std::string::value_type *v10;
  std::string::size_type v11;
  std::string *v12;
  __int128 v13;
  std::string v14;
  void *__p[2];
  std::string::size_type v16;

  if (*((char *)a3 + 23) >= 0)
    v6 = *((unsigned __int8 *)a3 + 23);
  else
    v6 = (size_t)a3[1];
  v7 = &v14;
  sub_20BDF6BDC((uint64_t)&v14, v6 + 8);
  if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v7 = (std::string *)v14.__r_.__value_.__r.__words[0];
  if (v6)
  {
    if (*((char *)a3 + 23) >= 0)
      v8 = a3;
    else
      v8 = *a3;
    memmove(v7, v8, v6);
  }
  strcpy((char *)v7 + v6, "\nERROR:\n");
  v9 = *(char *)(a2 + 23);
  if (v9 >= 0)
    v10 = (const std::string::value_type *)a2;
  else
    v10 = *(const std::string::value_type **)a2;
  if (v9 >= 0)
    v11 = *(unsigned __int8 *)(a2 + 23);
  else
    v11 = *(_QWORD *)(a2 + 8);
  v12 = std::string::append(&v14, v10, v11);
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v16 = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  Alembic::Abc::v12::ErrorHandler::handleIt(a1, (uint64_t)__p);
  if (SHIBYTE(v16) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
}

{
  size_t v5;
  void **v6;
  const void *v7;
  void *__p[2];
  char v9;

  if (*((char *)a3 + 23) >= 0)
    v5 = *((unsigned __int8 *)a3 + 23);
  else
    v5 = (size_t)a3[1];
  v6 = __p;
  sub_20BDF6BDC((uint64_t)__p, v5 + 26);
  if (v9 < 0)
    v6 = (void **)__p[0];
  if (v5)
  {
    if (*((char *)a3 + 23) >= 0)
      v7 = a3;
    else
      v7 = *a3;
    memmove(v6, v7, v5);
  }
  strcpy((char *)v6 + v5, "\nERROR: UNKNOWN EXCEPTION\n");
  Alembic::Abc::v12::ErrorHandler::handleIt(a1, (uint64_t)__p);
  if (v9 < 0)
    operator delete(__p[0]);
}

void sub_20BE01FAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

std::string *Alembic::Abc::v12::ErrorHandler::handleIt(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  _QWORD *v5;
  const std::locale::facet *v6;
  std::string *v7;
  int v8;
  const std::string::value_type *v9;
  std::string::size_type v10;
  std::string *v12;
  std::string::size_type v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *exception;
  _QWORD *v18;
  __int128 __p;
  char v20;
  _QWORD v21[4];
  std::locale v22;
  _QWORD v23[33];

  v2 = a2;
  if (*a1)
  {
    if (*a1 != 1)
    {
      sub_20BDDBD68((uint64_t)&v22);
      v14 = *(char *)(v2 + 23);
      if (v14 >= 0)
        v15 = v2;
      else
        v15 = *(_QWORD *)v2;
      if (v14 >= 0)
        v16 = *(unsigned __int8 *)(v2 + 23);
      else
        v16 = *(_QWORD *)(v2 + 8);
      sub_20BDDC1C8(v23, v15, v16);
      std::stringbuf::str();
      sub_20BDDBF20(v21, &__p);
      if (v20 < 0)
        operator delete((void *)__p);
      exception = __cxa_allocate_exception(0x20uLL);
      v18 = sub_20BDDC09C(exception, (uint64_t)v21);
      __cxa_throw(v18, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
    }
    if (*(char *)(a2 + 23) >= 0)
    {
      v4 = *(unsigned __int8 *)(a2 + 23);
    }
    else
    {
      a2 = *(_QWORD *)a2;
      v4 = *(_QWORD *)(v2 + 8);
    }
    v5 = sub_20BDDC1C8(MEMORY[0x24BEDB310], a2, v4);
    std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(_QWORD *)(*v5 - 24)));
    v6 = std::locale::use_facet(&v22, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
    std::locale::~locale(&v22);
    std::ostream::put();
    std::ostream::flush();
    v7 = (std::string *)(a1 + 2);
    v8 = *(char *)(v2 + 23);
    if (v8 >= 0)
      v9 = (const std::string::value_type *)v2;
    else
      v9 = *(const std::string::value_type **)v2;
    if (v8 >= 0)
      v10 = *(unsigned __int8 *)(v2 + 23);
    else
      v10 = *(_QWORD *)(v2 + 8);
    std::string::append(v7, v9, v10);
    return std::string::append(v7, "\n");
  }
  else
  {
    v12 = (std::string *)(a1 + 2);
    if (*(char *)(a2 + 23) >= 0)
    {
      v13 = *(unsigned __int8 *)(a2 + 23);
    }
    else
    {
      a2 = *(_QWORD *)a2;
      v13 = *(_QWORD *)(v2 + 8);
    }
    std::string::append(v12, (const std::string::value_type *)a2, v13);
    return std::string::append(v12, "\n");
  }
}

void sub_20BE0219C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, std::locale a16)
{
  sub_20BDDC194(&a12);
  sub_20BDDBE98((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_20BE022E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void sub_20BE023E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Alembic::Abc::v12::IArchive::~IArchive(void **this)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 4));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

char *Alembic::Abc::v12::IArchive::getName@<X0>(Alembic::Abc::v12::IArchive *this@<X0>, uint64_t a2@<X8>)
{
  char *result;
  __int128 v4;

  result = (char *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4));
  if (result[23] < 0)
    return (char *)sub_20BDDBFAC((_BYTE *)a2, *(void **)result, *((_QWORD *)result + 1));
  v4 = *(_OWORD *)result;
  *(_QWORD *)(a2 + 16) = *((_QWORD *)result + 2);
  *(_OWORD *)a2 = v4;
  return result;
}

void sub_20BE024A0(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v9;
  void *v11;

  v11 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v11);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  sub_20BDDC0E4(v9, "");
  JUMPOUT(0x20BE02490);
}

void sub_20BE024E4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BE02504(uint64_t a1, uint64_t a2)
{
  _DWORD *v3;
  void *__p[2];
  char v5;

  v3 = *(_DWORD **)a1;
  sub_20BDDC0E4(__p, *(char **)(a1 + 8));
  Alembic::Abc::v12::ErrorHandler::operator()(v3, a2, (const void **)__p);
  if (v5 < 0)
    operator delete(__p[0]);
}

void sub_20BE02554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_20BE02570(uint64_t a1, uint64_t a2)
{
  _DWORD *v3;
  void *__p[2];
  char v5;

  v3 = *(_DWORD **)a1;
  sub_20BDDC0E4(__p, *(char **)(a1 + 8));
  Alembic::Abc::v12::ErrorHandler::operator()(v3, a2, (const void **)__p);
  if (v5 < 0)
    operator delete(__p[0]);
}

void sub_20BE025C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Alembic::Abc::v12::IArchive::getTop(Alembic::Abc::v12::IArchive *this@<X0>, uint64_t a2@<X8>)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  Alembic::Abc::v12::IArchive *v10;
  const char *v11;

  v10 = this;
  v11 = "IArchive::getTop()";
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 4) + 32))(&v8);
  LODWORD(v6) = 0;
  v7 = 0;
  sub_20BE02B14(a2, &v8, &v6);
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_20BE02678(void *a1, int a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  void *v7;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  v7 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)va1, (uint64_t)v7);
  else
    sub_20BE02504((uint64_t)va1, 0);
  __cxa_end_catch();
  *(_DWORD *)(v4 + 8) = 2;
  sub_20BDDC0E4((_QWORD *)(v4 + 16), "");
  *(_QWORD *)v4 = off_24C518E68;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_OWORD *)(v4 + 72) = 0u;
  *(_QWORD *)(v4 + 88) = 0;
  JUMPOUT(0x20BE02664);
}

void sub_20BE02704(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *Alembic::Abc::v12::IArchive::getReadArraySampleCachePtr@<X0>(Alembic::Abc::v12::IArchive *this@<X0>, _QWORD *a2@<X8>)
{
  return (*(_QWORD *(**)(_QWORD *__return_ptr))(**((_QWORD **)this + 4) + 40))(a2);
}

void sub_20BE02768(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v9;
  void *v11;

  v11 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v11);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  *v9 = 0;
  v9[1] = 0;
  JUMPOUT(0x20BE02758);
}

void sub_20BE027A0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *Alembic::Abc::v12::IArchive::getTimeSampling@<X0>(Alembic::Abc::v12::IArchive *this@<X0>, _QWORD *a2@<X8>)
{
  return (*(_QWORD *(**)(_QWORD *__return_ptr))(**((_QWORD **)this + 4) + 56))(a2);
}

void sub_20BE02804(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v9;
  void *v11;

  v11 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v11);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  *v9 = 0;
  v9[1] = 0;
  JUMPOUT(0x20BE027F4);
}

void sub_20BE0283C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IArchive::getNumTimeSamplings(Alembic::Abc::v12::IArchive *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 72))(*((_QWORD *)this + 4));
}

void sub_20BE02898(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE02888);
}

void sub_20BE028D0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IArchive::getMaxNumSamplesForTimeSamplingIndex(Alembic::Abc::v12::IArchive *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
}

void sub_20BE0292C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0291CLL);
}

void sub_20BE02964(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IArchive::getArchiveVersion(Alembic::Abc::v12::IArchive *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 80))(*((_QWORD *)this + 4));
}

void sub_20BE029C0(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE029B0);
}

void sub_20BE029F8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IArchive::setReadArraySampleCachePtr(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  const char *v12;

  v11 = a1;
  v12 = "IArchive::setReadArraySampleCachePtr";
  v2 = *(_QWORD *)(a1 + 32);
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 48))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_20BE02AB0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v13;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  v13 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a11, (uint64_t)v13);
  else
    sub_20BE02504((uint64_t)&a11, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE02AA0);
}

void sub_20BE02AF4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_20BE02B14(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t *v17;
  int v18;
  uint64_t *v19;
  int v20;
  uint64_t *v21;
  int v22;
  uint64_t v23;
  std::__shared_weak_count *v24;

  *(_DWORD *)(a1 + 8) = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 16), "");
  *(_QWORD *)a1 = off_24C518E68;
  v7 = *a2;
  v6 = a2[1];
  if (v6)
  {
    v8 = (unint64_t *)(v6 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 40) = v7;
  *(_QWORD *)(a1 + 48) = v6;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 88) = 0;
  v10 = (std::__shared_weak_count *)a2[1];
  v23 = *a2;
  v24 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  LODWORD(v21) = 0;
  v22 = 0;
  LODWORD(v19) = 0;
  v20 = 0;
  LODWORD(v17) = 0;
  v18 = 0;
  *(_DWORD *)(a1 + 8) = sub_20BE02C98((uint64_t)&v23, a3, &v21, &v19, &v17);
  v13 = v24;
  if (v24)
  {
    v14 = (unint64_t *)&v24->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  Alembic::Abc::v12::IObject::initInstance((std::string *)a1);
  return a1;
}

void sub_20BE02C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  void **v15;
  uint64_t v16;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v17;

  if (*(char *)(v16 + 95) < 0)
    operator delete(*(void **)(v16 + 72));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v17);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v16 + 40));
  if (*(char *)(v16 + 39) < 0)
    operator delete(*v15);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE02C98(uint64_t a1, uint64_t **a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  const void **v19;
  _QWORD *v20[4];
  unsigned int v21;
  uint64_t v22[4];
  std::__shared_weak_count *v23;
  int v24;
  uint64_t v25;

  v9 = *(std::__shared_weak_count **)(a1 + 8);
  v20[2] = *(_QWORD **)a1;
  v20[3] = &v9->__vftable;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v20[0] = 0;
  v20[1] = 0;
  v19 = (const void **)v20;
  v21 = 2;
  sub_20BDEBF8C(v22, &v19);
  v22[3] = 0;
  v23 = 0;
  v24 = 0;
  v25 = 1;
  sub_20BDE9D48((uint64_t)&v19, v20[0]);
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  sub_20BE02E30(a2, (uint64_t)&v21);
  sub_20BE02E30(a3, (uint64_t)&v21);
  sub_20BE02E30(a4, (uint64_t)&v21);
  sub_20BE02E30(a5, (uint64_t)&v21);
  v14 = v21;
  v15 = v23;
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  sub_20BDE9D48((uint64_t)v22, (_QWORD *)v22[1]);
  return v14;
}

void sub_20BE02DF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;
  _QWORD *v8;
  uint64_t v9;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v6 = va_arg(va2, _QWORD);
  v8 = va_arg(va2, _QWORD *);
  v9 = va_arg(va2, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  sub_20BDE9D48((uint64_t)va1, v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va2);
  _Unwind_Resume(a1);
}

uint64_t **sub_20BE02E30(uint64_t **result, uint64_t a2)
{
  uint64_t *v2;

  switch(*(_DWORD *)result)
  {
    case 1:
      *(_DWORD *)a2 = *((_DWORD *)result + 2);
      break;
    case 2:
      *(_DWORD *)(a2 + 48) = *((_DWORD *)result + 2);
      break;
    case 3:
      v2 = result[1];
      result = (uint64_t **)(a2 + 8);
      if ((uint64_t *)(a2 + 8) != v2)
        result = sub_20BDFC4AC(result, (__int128 *)*v2, (__int128 *)(v2 + 1));
      break;
    case 4:
      result = (uint64_t **)sub_20BDE881C((_QWORD *)(a2 + 32), result[1]);
      break;
    case 5:
      *(_DWORD *)(a2 + 52) = *((_DWORD *)result + 2);
      break;
    case 6:
      *(_DWORD *)(a2 + 56) = *((_DWORD *)result + 2);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_20BE02EB0(uint64_t a1)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 32));
  sub_20BDE9D48(a1 + 8, *(_QWORD **)(a1 + 16));
  return a1;
}

uint64_t Alembic::Abc::v12::IArrayProperty::IArrayProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t **a5)
{
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v16[2];

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v10 = *(std::__shared_weak_count **)(a2 + 40);
  v16[0] = *(_QWORD *)(a2 + 32);
  v16[1] = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  Alembic::Abc::v12::IArrayProperty::init((_DWORD *)a1, v16, a3, *(_DWORD *)a2, a4, a5);
  if (v10)
  {
    v13 = (unint64_t *)&v10->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return a1;
}

void sub_20BE02FB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  sub_20BE032CC(v9);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IArrayProperty::init(_DWORD *a1, _QWORD *a2, uint64_t a3, int a4, uint64_t **a5, uint64_t **a6)
{
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *exception;
  _QWORD *v22;
  __int128 __p;
  char v24;
  _QWORD v25[4];
  __int128 v26;
  _QWORD v27[37];
  int v28;
  uint64_t v29[4];
  std::__shared_weak_count *v30;
  int v31;
  uint64_t v32;

  *((_QWORD *)&v26 + 1) = 0;
  v27[0] = 0;
  *(_QWORD *)&v26 = (char *)&v26 + 8;
  v27[35] = 0;
  v27[36] = 0;
  v28 = a4;
  sub_20BDEBF8C(v29, (const void ***)&v26);
  v29[3] = 0;
  v30 = 0;
  v31 = 0;
  v32 = 1;
  sub_20BDE9D48((uint64_t)&v26, *((_QWORD **)&v26 + 1));
  sub_20BE02E30(a5, (uint64_t)&v28);
  sub_20BE02E30(a6, (uint64_t)&v28);
  *a1 = v28;
  v27[33] = a1;
  v27[34] = "IArrayProperty::init()";
  if (!(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*a2 + 80))(*a2, a3))
  {
    sub_20BDDBD68((uint64_t)&v26);
    v17 = sub_20BDDC1C8(v27, (uint64_t)"Nonexistent array property: ", 28);
    v18 = *(char *)(a3 + 23);
    if (v18 >= 0)
      v19 = a3;
    else
      v19 = *(_QWORD *)a3;
    if (v18 >= 0)
      v20 = *(unsigned __int8 *)(a3 + 23);
    else
      v20 = *(_QWORD *)(a3 + 8);
    sub_20BDDC1C8(v17, v19, v20);
    std::stringbuf::str();
    sub_20BDDBF20(v25, &__p);
    if (v24 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v22 = sub_20BDDC09C(exception, (uint64_t)v25);
    __cxa_throw(v22, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  (*(void (**)(__int128 *__return_ptr, _QWORD, uint64_t))(*(_QWORD *)*a2 + 96))(&v26, *a2, a3);
  sub_20BDE82DC((uint64_t)(a1 + 8), &v26);
  v11 = (std::__shared_weak_count *)*((_QWORD *)&v26 + 1);
  if (*((_QWORD *)&v26 + 1))
  {
    v12 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v30;
  if (v30)
  {
    p_shared_owners = (unint64_t *)&v30->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  sub_20BDE9D48((uint64_t)v29, (_QWORD *)v29[1]);
}

void sub_20BE031DC(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v6;
  void *v9;
  std::exception v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v10.__vftable = va_arg(va1, std::exception_vtbl *);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  v9 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v5 + 32));
  MEMORY[0x212B929D0](v5 + 8, "");
  if (a2 == 2)
    sub_20BE02570(v6 - 160, (uint64_t)v9);
  else
    sub_20BE02504(v6 - 160, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE030ECLL);
}

void sub_20BE03278(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BE02EB0(v1 - 128);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE032CC(uint64_t a1)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void Alembic::Abc::v12::IArrayProperty::~IArrayProperty(void **this)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 4));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

uint64_t Alembic::Abc::v12::IArrayProperty::getNumSamples(Alembic::Abc::v12::IArrayProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
}

void sub_20BE03380(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE03370);
}

void sub_20BE033B8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IArrayProperty::isConstant(Alembic::Abc::v12::IArrayProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 72))(*((_QWORD *)this + 4));
}

void sub_20BE03414(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE03404);
}

void sub_20BE0344C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IArrayProperty::isScalarLike(Alembic::Abc::v12::IArrayProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 128))(*((_QWORD *)this + 4));
}

void sub_20BE034A8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE03498);
}

void sub_20BE034E0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IArrayProperty::getTimeSampling@<X0>(Alembic::Abc::v12::IArrayProperty *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4));
  v4 = *(_QWORD *)(result + 72);
  *a2 = *(_QWORD *)(result + 64);
  a2[1] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

void sub_20BE03560(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v9;
  void *v11;

  v11 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v11);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  *v9 = 0;
  v9[1] = 0;
  JUMPOUT(0x20BE03550);
}

void sub_20BE03598(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IArrayProperty::get(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  uint64_t Index;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  double **v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  const char *v19;

  v18 = a1;
  v19 = "IArrayProperty::get()";
  v6 = *(_QWORD *)(a1 + 32);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  v8 = *(std::__shared_weak_count **)(v7 + 72);
  v16 = *(double ***)(v7 + 64);
  v17 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  Index = Alembic::Abc::v12::ISampleSelector::getIndex(a3, &v16, v11);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 80))(v6, Index, a2);
  v13 = v17;
  if (v17)
  {
    v14 = (unint64_t *)&v17->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_20BE0369C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v12;

  v12 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a11, (uint64_t)v12);
  else
    sub_20BE02504((uint64_t)&a11, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE03688);
}

void sub_20BE036EC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IArrayProperty::getAs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v13;
  uint64_t Index;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  double **v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  const char *v21;

  v20 = a1;
  v21 = "IArrayProperty::getAs(PlainOldDataType)";
  v8 = *(_QWORD *)(a1 + 32);
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
  v10 = *(std::__shared_weak_count **)(v9 + 72);
  v18 = *(double ***)(v9 + 64);
  v19 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  Index = Alembic::Abc::v12::ISampleSelector::getIndex(a4, &v18, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 136))(v8, Index, a2, a3);
  v15 = v19;
  if (v19)
  {
    v16 = (unint64_t *)&v19->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_20BE03800(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v12;

  v12 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a11, (uint64_t)v12);
  else
    sub_20BE02504((uint64_t)&a11, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE037E8);
}

void sub_20BE03850(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IArrayProperty::getAs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  uint64_t Index;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  double **v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  const char *v20;

  v19 = a1;
  v20 = "IArrayProperty::getAs()";
  v6 = *(_QWORD *)(a1 + 32);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  v8 = *(std::__shared_weak_count **)(v7 + 72);
  v17 = *(double ***)(v7 + 64);
  v18 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  Index = Alembic::Abc::v12::ISampleSelector::getIndex(a3, &v17, v11);
  v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32));
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v6 + 136))(v6, Index, a2, *(unsigned int *)(v13 + 56));
  v14 = v18;
  if (v18)
  {
    v15 = (unint64_t *)&v18->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_20BE0396C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v12;

  v12 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a11, (uint64_t)v12);
  else
    sub_20BE02504((uint64_t)&a11, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE03958);
}

void sub_20BE039BC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IArrayProperty::getKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  uint64_t Index;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  double **v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  const char *v21;

  v20 = a1;
  v21 = "IArrayProperty::getKey()";
  v6 = *(_QWORD *)(a1 + 32);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  v8 = *(std::__shared_weak_count **)(v7 + 72);
  v18 = *(double ***)(v7 + 64);
  v19 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  Index = Alembic::Abc::v12::ISampleSelector::getIndex(a3, &v18, v11);
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 112))(v6, Index, a2);
  v14 = v19;
  if (v19)
  {
    v15 = (unint64_t *)&v19->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  return v13;
}

void sub_20BE03AC8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v12;

  v12 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a11, (uint64_t)v12);
  else
    sub_20BE02504((uint64_t)&a11, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE03AB0);
}

void sub_20BE03B1C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IArrayProperty::getDimensions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  uint64_t Index;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  double **v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  const char *v19;

  v18 = a1;
  v19 = "IArrayProperty::getDimensions()";
  v6 = *(_QWORD *)(a1 + 32);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  v8 = *(std::__shared_weak_count **)(v7 + 72);
  v16 = *(double ***)(v7 + 64);
  v17 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  Index = Alembic::Abc::v12::ISampleSelector::getIndex(a3, &v16, v11);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 120))(v6, Index, a2);
  v13 = v17;
  if (v17)
  {
    v14 = (unint64_t *)&v17->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_20BE03C20(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v12;

  v12 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a11, (uint64_t)v12);
  else
    sub_20BE02504((uint64_t)&a11, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE03C0CLL);
}

void sub_20BE03C70(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IArrayProperty::getParent(Alembic::Abc::v12::IArrayProperty *this@<X0>, uint64_t a2@<X8>)
{
  int v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  _DWORD v8[4];
  _DWORD v9[4];
  uint64_t v10;
  std::__shared_weak_count *v11;
  Alembic::Abc::v12::IArrayProperty *v12;
  const char *v13;

  v12 = this;
  v13 = "IArrayProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 4) + 32))(&v10);
  v4 = *(_DWORD *)this;
  v9[0] = 1;
  v9[2] = v4;
  v8[0] = 0;
  v8[2] = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(a2, &v10, v9, v8);
  v5 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_20BE03D44(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  void *v9;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  v9 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)va1, (uint64_t)v9);
  else
    sub_20BE02504((uint64_t)va1, 0);
  __cxa_end_catch();
  *(_DWORD *)v6 = 2;
  sub_20BDDC0E4((_QWORD *)(v6 + 8), "");
  *(_QWORD *)(v6 + 32) = 0;
  *(_QWORD *)(v6 + 40) = 0;
  JUMPOUT(0x20BE03D30);
}

void sub_20BE03DB0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v14[2];

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v8 = *(std::__shared_weak_count **)(a2 + 40);
  v14[0] = *(_QWORD *)(a2 + 32);
  v14[1] = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  Alembic::Abc::v12::ICompoundProperty::init((_DWORD *)a1, v14, a3, *(_DWORD *)a2, a4);
  if (v8)
  {
    v11 = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return a1;
}

void sub_20BE03E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  sub_20BE032CC(v9);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::ICompoundProperty::init(_DWORD *a1, _QWORD *a2, uint64_t a3, int a4, uint64_t **a5)
{
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  _QWORD *exception;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  void *__p[2];
  char v24;
  _QWORD v25[4];
  __int128 v26;
  _QWORD v27[37];
  int v28;
  uint64_t v29[4];
  std::__shared_weak_count *v30;
  int v31;
  uint64_t v32;

  *((_QWORD *)&v26 + 1) = 0;
  v27[0] = 0;
  *(_QWORD *)&v26 = (char *)&v26 + 8;
  v27[35] = 0;
  v27[36] = 0;
  v28 = a4;
  sub_20BDEBF8C(v29, (const void ***)&v26);
  v29[3] = 0;
  v30 = 0;
  v31 = 0;
  v32 = 1;
  sub_20BDE9D48((uint64_t)&v26, *((_QWORD **)&v26 + 1));
  sub_20BE02E30(a5, (uint64_t)&v28);
  *a1 = v28;
  v27[33] = a1;
  v27[34] = "ICompoundProperty::init()";
  if (!*a2)
  {
    sub_20BDDBD68((uint64_t)&v26);
    sub_20BDDC1C8(v27, (uint64_t)"invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(v25, (__int128 *)__p);
    if (v24 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v16 = sub_20BDDC09C(exception, (uint64_t)v25);
    __cxa_throw(v16, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  if (!(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*a2 + 80))(*a2, a3))
  {
    sub_20BDDBD68((uint64_t)&v26);
    v17 = sub_20BDDC1C8(v27, (uint64_t)"Nonexistent compound property: ", 31);
    v18 = *(char *)(a3 + 23);
    if (v18 >= 0)
      v19 = a3;
    else
      v19 = *(_QWORD *)a3;
    if (v18 >= 0)
      v20 = *(unsigned __int8 *)(a3 + 23);
    else
      v20 = *(_QWORD *)(a3 + 8);
    sub_20BDDC1C8(v17, v19, v20);
    std::stringbuf::str();
    sub_20BDDBF20(v25, (__int128 *)__p);
    if (v24 < 0)
      operator delete(__p[0]);
    v21 = __cxa_allocate_exception(0x20uLL);
    v22 = sub_20BDDC09C(v21, (uint64_t)v25);
    __cxa_throw(v22, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  (*(void (**)(__int128 *__return_ptr, _QWORD, uint64_t))(*(_QWORD *)*a2 + 104))(&v26, *a2, a3);
  sub_20BDE82DC((uint64_t)(a1 + 8), &v26);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v26 + 1);
  if (*((_QWORD *)&v26 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v30;
  if (v30)
  {
    p_shared_owners = (unint64_t *)&v30->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  sub_20BDE9D48((uint64_t)v29, (_QWORD *)v29[1]);
}

void sub_20BE04120(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v6;
  void *v9;
  std::exception v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v10.__vftable = va_arg(va1, std::exception_vtbl *);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  v9 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v5 + 32));
  MEMORY[0x212B929D0](v5 + 8, "");
  if (a2 == 2)
    sub_20BE02570(v6 - 144, (uint64_t)v9);
  else
    sub_20BE02504(v6 - 144, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE03FC0);
}

void sub_20BE041CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BE02EB0(v1 - 112);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(uint64_t a1, uint64_t *a2, uint64_t **a3, uint64_t **a4)
{
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  int v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t *v22;
  int v23;
  uint64_t *v24;
  int v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;

  v6 = *a2;
  v5 = (std::__shared_weak_count *)a2[1];
  v28 = *a2;
  v29 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v9 = (std::__shared_weak_count *)a2[1];
    v26 = *a2;
    v27 = v9;
    if (v9)
    {
      v10 = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
  }
  else
  {
    v26 = v6;
    v27 = 0;
  }
  LODWORD(v24) = 0;
  v25 = 0;
  LODWORD(v22) = 0;
  v23 = 0;
  v12 = sub_20BE04390((uint64_t)&v26, a3, a4, &v24, &v22);
  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = v6;
  *(_QWORD *)(a1 + 40) = v5;
  if (v5)
  {
    v13 = (unint64_t *)&v5->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  *(_DWORD *)a1 = v12;
  v15 = v27;
  if (v27)
  {
    v16 = (unint64_t *)&v27->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v29;
  if (v29)
  {
    v19 = (unint64_t *)&v29->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  return a1;
}

void sub_20BE04374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE04390(uint64_t a1, uint64_t **a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  const void **v19;
  _QWORD *v20[4];
  unsigned int v21;
  uint64_t v22[4];
  std::__shared_weak_count *v23;
  int v24;
  uint64_t v25;

  v9 = *(std::__shared_weak_count **)(a1 + 8);
  v20[2] = *(_QWORD **)a1;
  v20[3] = &v9->__vftable;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v20[0] = 0;
  v20[1] = 0;
  v19 = (const void **)v20;
  v21 = 2;
  sub_20BDEBF8C(v22, &v19);
  v22[3] = 0;
  v23 = 0;
  v24 = 0;
  v25 = 1;
  sub_20BDE9D48((uint64_t)&v19, v20[0]);
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  sub_20BE02E30(a2, (uint64_t)&v21);
  sub_20BE02E30(a3, (uint64_t)&v21);
  sub_20BE02E30(a4, (uint64_t)&v21);
  sub_20BE02E30(a5, (uint64_t)&v21);
  v14 = v21;
  v15 = v23;
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  sub_20BDE9D48((uint64_t)v22, (_QWORD *)v22[1]);
  return v14;
}

void sub_20BE044F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;
  _QWORD *v8;
  uint64_t v9;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v6 = va_arg(va2, _QWORD);
  v8 = va_arg(va2, _QWORD *);
  v9 = va_arg(va2, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  sub_20BDE9D48((uint64_t)va1, v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va2);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t **a4, uint64_t **a5)
{
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  int v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t *v23;
  int v24;
  uint64_t *v25;
  int v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;

  v7 = *a2;
  v6 = (std::__shared_weak_count *)a2[1];
  v29 = *a2;
  v30 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    v10 = (std::__shared_weak_count *)a2[1];
    v27 = *a2;
    v28 = v10;
    if (v10)
    {
      v11 = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
  }
  else
  {
    v27 = v7;
    v28 = 0;
  }
  LODWORD(v25) = 0;
  v26 = 0;
  LODWORD(v23) = 0;
  v24 = 0;
  v13 = sub_20BE04390((uint64_t)&v27, a4, a5, &v25, &v23);
  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = v7;
  *(_QWORD *)(a1 + 40) = v6;
  if (v6)
  {
    v14 = (unint64_t *)&v6->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  *(_DWORD *)a1 = v13;
  v16 = v28;
  if (v28)
  {
    v17 = (unint64_t *)&v28->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v30;
  if (v30)
  {
    v20 = (unint64_t *)&v30->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  return a1;
}

void sub_20BE0467C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va1);
  _Unwind_Resume(a1);
}

uint64_t *Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(uint64_t *a1, Alembic::Abc::v12::IObject *a2, uint64_t **a3, uint64_t **a4)
{
  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4(a1 + 1, "");
  a1[4] = 0;
  a1[5] = 0;
  Alembic::Abc::v12::ICompoundProperty::init(a1, a2, a3, a4);
  return a1;
}

void sub_20BE046FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BE032CC(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::ICompoundProperty::init(uint64_t *a1, Alembic::Abc::v12::IObject *a2, uint64_t **a3, uint64_t **a4)
{
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  void *v13;
  int v14;
  __int128 v15;
  __int128 v16;
  uint64_t *v17;
  const char *v18;
  _BYTE v19[96];

  sub_20BE04EB0((uint64_t)v19, (uint64_t)a2);
  LODWORD(v13) = 0;
  v14 = 0;
  LODWORD(v17) = 0;
  LODWORD(v18) = 0;
  *(_DWORD *)a1 = sub_20BE04D74((uint64_t)v19, a3, a4, (uint64_t **)&v13, &v17);
  Alembic::Abc::v12::IObject::~IObject((Alembic::Abc::v12::IObject *)v19);
  v17 = a1;
  v18 = "ICompoundProperty::init( IObject)";
  Alembic::Abc::v12::IObject::getProperties(a2, (uint64_t)&v13);
  v16 = v15;
  if (*((_QWORD *)&v15 + 1))
  {
    v8 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  sub_20BDE82DC((uint64_t)(a1 + 4), &v16);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
  if (*((_QWORD *)&v16 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty(&v13);
}

void sub_20BE04808(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v10;
  void *v12;
  va_list va;

  va_start(va, a10);
  v12 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v10 + 32));
  MEMORY[0x212B929D0](v10 + 8, "");
  if (a2 == 2)
    sub_20BE02570((uint64_t)va, (uint64_t)v12);
  else
    sub_20BE02504((uint64_t)va, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE047F4);
}

void sub_20BE04864(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t *Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(uint64_t *a1, Alembic::Abc::v12::IObject *a2, uint64_t a3, uint64_t **a4, uint64_t **a5)
{
  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4(a1 + 1, "");
  a1[4] = 0;
  a1[5] = 0;
  Alembic::Abc::v12::ICompoundProperty::init(a1, a2, a4, a5);
  return a1;
}

void sub_20BE048F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BE032CC(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty(void **this)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 4));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

uint64_t Alembic::Abc::v12::ICompoundProperty::getNumProperties(Alembic::Abc::v12::ICompoundProperty *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 64))(result);
  return result;
}

void sub_20BE04990(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE04980);
}

void sub_20BE049C8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(Alembic::Abc::v12::ICompoundProperty *this)
{
  uint64_t v1;
  unsigned __int8 v3;
  _QWORD *v4;

  v1 = *((_QWORD *)this + 4);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 72))(v1);
  v3 = atomic_load((unsigned __int8 *)&qword_254784E28);
  if ((v3 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_254784E28))
    {
      v4 = operator new(0x50uLL);
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      *((_DWORD *)v4 + 6) = 1;
      v4[6] = 0;
      v4[5] = 0;
      v4[4] = v4 + 5;
      *((_DWORD *)v4 + 14) = 127;
      *((_BYTE *)v4 + 60) = 0;
      v4[8] = 0;
      v4[9] = 0;
      qword_254784E20 = (uint64_t)v4;
      __cxa_guard_release(&qword_254784E28);
    }
  }
  return qword_254784E20;
}

void sub_20BE04AA0(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v11;
  unsigned __int8 v12;
  _QWORD *v13;

  __cxa_guard_abort(&qword_254784E28);
  v11 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v11);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  v12 = atomic_load((unsigned __int8 *)&qword_254784E38);
  if ((v12 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_254784E38))
    {
      v13 = operator new(0x50uLL);
      *v13 = 0;
      v13[1] = 0;
      v13[2] = 0;
      *((_DWORD *)v13 + 6) = 1;
      v13[6] = 0;
      v13[5] = 0;
      v13[4] = v13 + 5;
      *((_DWORD *)v13 + 14) = 127;
      *((_BYTE *)v13 + 60) = 0;
      v13[8] = 0;
      v13[9] = 0;
      qword_254784E30 = (uint64_t)v13;
      __cxa_guard_release(&qword_254784E38);
    }
  }
  JUMPOUT(0x20BE04A34);
}

void sub_20BE04B68(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784E38);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 80))(result);
  return result;
}

void sub_20BE04BDC(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE04BCCLL);
}

void sub_20BE04C14(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::ICompoundProperty::getParent(Alembic::Abc::v12::ICompoundProperty *this@<X0>, uint64_t a2@<X8>)
{
  int v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t *v8;
  int v9;
  uint64_t *v10;
  int v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  Alembic::Abc::v12::ICompoundProperty *v14;
  const char *v15;

  v14 = this;
  v15 = "ICompoundProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 4) + 32))(&v12);
  v4 = *(_DWORD *)this;
  LODWORD(v10) = 1;
  v11 = v4;
  LODWORD(v8) = 0;
  v9 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(a2, &v12, &v10, &v8);
  v5 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_20BE04CE8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  void *v9;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  v9 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)va1, (uint64_t)v9);
  else
    sub_20BE02504((uint64_t)va1, 0);
  __cxa_end_catch();
  *(_DWORD *)v6 = 2;
  sub_20BDDC0E4((_QWORD *)(v6 + 8), "");
  *(_QWORD *)(v6 + 32) = 0;
  *(_QWORD *)(v6 + 40) = 0;
  JUMPOUT(0x20BE04CD4);
}

void sub_20BE04D54(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_20BE04D74(uint64_t a1, uint64_t **a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  unsigned int v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  const void **v15;
  _QWORD *v16[2];
  unsigned int v17;
  uint64_t v18[4];
  std::__shared_weak_count *v19;
  int v20;
  uint64_t v21;

  v9 = *(_DWORD *)(a1 + 8);
  v16[0] = 0;
  v16[1] = 0;
  v15 = (const void **)v16;
  v17 = v9;
  sub_20BDEBF8C(v18, &v15);
  v18[3] = 0;
  v19 = 0;
  v20 = 0;
  v21 = 1;
  sub_20BDE9D48((uint64_t)&v15, v16[0]);
  sub_20BE02E30(a2, (uint64_t)&v17);
  sub_20BE02E30(a3, (uint64_t)&v17);
  sub_20BE02E30(a4, (uint64_t)&v17);
  sub_20BE02E30(a5, (uint64_t)&v17);
  v10 = v17;
  v11 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  sub_20BDE9D48((uint64_t)v18, (_QWORD *)v18[1]);
  return v10;
}

void sub_20BE04E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, _QWORD *a13)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a10);
  sub_20BDE9D48((uint64_t)&a12, a13);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE04EB0(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  _BYTE *v11;
  __int128 v12;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  if (*(char *)(a2 + 39) < 0)
  {
    sub_20BDDBFAC((_BYTE *)(a1 + 16), *(void **)(a2 + 16), *(_QWORD *)(a2 + 24));
  }
  else
  {
    v4 = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v4;
  }
  *(_QWORD *)a1 = off_24C518E68;
  v5 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 64) = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = (_BYTE *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0)
  {
    sub_20BDDBFAC(v11, *(void **)(a2 + 72), *(_QWORD *)(a2 + 80));
  }
  else
  {
    v12 = *(_OWORD *)(a2 + 72);
    *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
    *(_OWORD *)v11 = v12;
  }
  return a1;
}

void sub_20BE04FA4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v3;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v4;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v4);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v3);
  if (*(char *)(v1 + 39) < 0)
    operator delete(*v2);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IObject::~IObject(void **this)
{
  *this = off_24C518E68;
  if (*((char *)this + 95) < 0)
    operator delete(this[9]);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 7));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 5));
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
}

{
  void *v1;

  Alembic::Abc::v12::IObject::~IObject(this);
  operator delete(v1);
}

uint64_t Alembic::Abc::v12::IObject::getHeader(Alembic::Abc::v12::IObject *this)
{
  uint64_t v1;
  unsigned __int8 v3;
  _QWORD *v4;

  v1 = *((_QWORD *)this + 5);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
  v3 = atomic_load((unsigned __int8 *)&qword_254784E48);
  if ((v3 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_254784E48))
    {
      v4 = operator new(0x48uLL);
      v4[8] = 0;
      v4[7] = 0;
      *(_OWORD *)v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
      *((_OWORD *)v4 + 2) = 0u;
      v4[6] = v4 + 7;
      qword_254784E40 = (uint64_t)v4;
      __cxa_guard_release(&qword_254784E48);
    }
  }
  return qword_254784E40;
}

void sub_20BE0511C(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784E48);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IObject::getName(Alembic::Abc::v12::IObject *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 7);
  if (!v2)
    v2 = *((_QWORD *)this + 5);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
}

uint64_t Alembic::Abc::v12::IObject::getFullName(Alembic::Abc::v12::IObject *this)
{
  uint64_t result;

  result = (uint64_t)this + 72;
  if ((*((char *)this + 95) & 0x80000000) == 0)
  {
    if (*((_BYTE *)this + 95))
      return result;
    return Alembic::Abc::v12::IObject::getHeader(this) + 24;
  }
  if (!*((_QWORD *)this + 10))
    return Alembic::Abc::v12::IObject::getHeader(this) + 24;
  return result;
}

void Alembic::Abc::v12::IObject::getArchive(Alembic::Abc::v12::IObject *this@<X0>, uint64_t a2@<X8>)
{
  int *v3;
  uint64_t v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  char *v14;
  const char *v15;

  v3 = (int *)((char *)this + 8);
  v14 = (char *)this + 8;
  v15 = "IObject::getArchive()";
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v4 + 24))(&v12);
    v5 = *v3;
    *(_DWORD *)a2 = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 8), "");
    v6 = v13;
    *(_QWORD *)(a2 + 32) = v12;
    *(_QWORD *)(a2 + 40) = v6;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
      v9 = v13;
      *(_DWORD *)a2 = v5;
      if (v9)
      {
        v10 = (unint64_t *)&v9->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
    else
    {
      *(_DWORD *)a2 = v5;
    }
  }
  else
  {
    *(_DWORD *)a2 = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 8), "");
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
  }
}

void sub_20BE052EC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

double Alembic::Abc::v12::IObject::getParent@<D0>(const std::string *this@<X0>, uint64_t a2@<X8>)
{
  std::string::size_type v4;
  std::string::size_type *p_size;
  std::string::size_type v6;
  int v7;
  double result;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::string::size_type size;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type v15;
  uint64_t v16;
  int v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  std::string *p_str;
  unint64_t *v23;
  unint64_t v24;
  __int128 v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  int v35;
  unint64_t *v36;
  unint64_t v37;
  int v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  std::string __str;
  std::string::value_type *v52;
  const char *v53;

  v4 = this[1].__r_.__value_.__r.__words[2];
  if (!v4)
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 16), "");
    *(_QWORD *)a2 = off_24C518E68;
    result = 0.0;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_QWORD *)(a2 + 88) = 0;
    return result;
  }
  p_size = &this->__r_.__value_.__l.__size_;
  v52 = &this->__r_.__value_.__s.__data_[8];
  v53 = "IObject::getParent()";
  if (SHIBYTE(this[3].__r_.__value_.__r.__words[2]) < 0)
  {
    if (this[3].__r_.__value_.__l.__size_)
      goto LABEL_4;
  }
  else if (*((_BYTE *)&this[3].__r_.__value_.__s + 23))
  {
LABEL_4:
    v6 = std::string::rfind(this + 3, 47, 0xFFFFFFFFFFFFFFFFLL);
    if (v6 + 1 > 1)
      std::string::basic_string(&__str, this + 3, 0, v6, (std::allocator<char> *)&v50);
    else
      memset(&__str, 0, sizeof(__str));
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)this[1].__r_.__value_.__r.__words[2] + 32))(&v50);
    if (!(_QWORD)v50)
      goto LABEL_52;
    size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = __str.__r_.__value_.__l.__size_;
    if (!size)
      goto LABEL_52;
    v13 = (*(uint64_t (**)(void))(*(_QWORD *)v50 + 16))();
    v14 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    else
      v15 = __str.__r_.__value_.__l.__size_;
    v16 = *(unsigned __int8 *)(v13 + 47);
    v17 = (char)v16;
    if ((v16 & 0x80u) != 0)
      v16 = *(_QWORD *)(v13 + 32);
    if (v15 == v16)
    {
      v20 = *(unsigned __int8 **)(v13 + 24);
      v18 = (unsigned __int8 *)(v13 + 24);
      v19 = v20;
      if (v17 >= 0)
        v21 = v18;
      else
        v21 = v19;
      if ((*((_BYTE *)&__str.__r_.__value_.__s + 23) & 0x80) == 0)
      {
        if (*((_BYTE *)&__str.__r_.__value_.__s + 23))
        {
          p_str = &__str;
          while (p_str->__r_.__value_.__s.__data_[0] == *v21)
          {
            p_str = (std::string *)((char *)p_str + 1);
            ++v21;
            if (!--v14)
              goto LABEL_52;
          }
          goto LABEL_33;
        }
LABEL_52:
        v35 = 0;
        goto LABEL_53;
      }
      if (!memcmp(__str.__r_.__value_.__l.__data_, v21, __str.__r_.__value_.__l.__size_))
        goto LABEL_52;
    }
LABEL_33:
    v48 = v50;
    if (*((_QWORD *)&v50 + 1))
    {
      v23 = (unint64_t *)(*((_QWORD *)&v50 + 1) + 8);
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }
    sub_20BE057B0((uint64_t *)&v48, &__str, &v49);
    v25 = v49;
    v49 = 0uLL;
    v26 = (std::__shared_weak_count *)*((_QWORD *)&v50 + 1);
    v50 = v25;
    if (v26)
    {
      p_shared_owners = (unint64_t *)&v26->__shared_owners_;
      do
        v28 = __ldaxr(p_shared_owners);
      while (__stlxr(v28 - 1, p_shared_owners));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v29 = (std::__shared_weak_count *)*((_QWORD *)&v49 + 1);
    if (*((_QWORD *)&v49 + 1))
    {
      v30 = (unint64_t *)(*((_QWORD *)&v49 + 1) + 8);
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    v32 = (std::__shared_weak_count *)*((_QWORD *)&v48 + 1);
    if (*((_QWORD *)&v48 + 1))
    {
      v33 = (unint64_t *)(*((_QWORD *)&v48 + 1) + 8);
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    v35 = 1;
LABEL_53:
    v47 = v50;
    if (*((_QWORD *)&v50 + 1))
    {
      v36 = (unint64_t *)(*((_QWORD *)&v50 + 1) + 8);
      do
        v37 = __ldxr(v36);
      while (__stxr(v37 + 1, v36));
    }
    v38 = *(_DWORD *)p_size;
    LODWORD(v49) = 1;
    DWORD2(v49) = v38;
    sub_20BE02B14(a2, (uint64_t *)&v47, (uint64_t **)&v49);
    v39 = (std::__shared_weak_count *)*((_QWORD *)&v47 + 1);
    if (!*((_QWORD *)&v47 + 1))
      goto LABEL_60;
    v40 = (unint64_t *)(*((_QWORD *)&v47 + 1) + 8);
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
      if (!v35)
      {
LABEL_62:
        v42 = (std::__shared_weak_count *)*((_QWORD *)&v50 + 1);
        if (*((_QWORD *)&v50 + 1))
        {
          v43 = (unint64_t *)(*((_QWORD *)&v50 + 1) + 8);
          do
            v44 = __ldaxr(v43);
          while (__stlxr(v44 - 1, v43));
          if (!v44)
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str.__r_.__value_.__l.__data_);
        return result;
      }
    }
    else
    {
LABEL_60:
      if (!v35)
        goto LABEL_62;
    }
    std::string::operator=((std::string *)(a2 + 72), &__str);
    goto LABEL_62;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v4 + 32))(&v45);
  v7 = *(_DWORD *)p_size;
  LODWORD(__str.__r_.__value_.__l.__data_) = 1;
  LODWORD(__str.__r_.__value_.__r.__words[1]) = v7;
  sub_20BE02B14(a2, &v45, (uint64_t **)&__str);
  v9 = v46;
  if (v46)
  {
    v10 = (unint64_t *)&v46->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return result;
}

void sub_20BE05790(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BE057B0(uint64_t *a1@<X0>, const std::string *a2@<X1>, _QWORD *a3@<X8>)
{
  std::string::size_type size;
  int v5;
  uint64_t v6;
  const std::string *v8;
  std::string::size_type v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  _QWORD v21[2];
  uint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;

  size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  v5 = (char)size;
  if ((size & 0x80u) != 0)
    size = a2->__r_.__value_.__l.__size_;
  if (size && (v6 = *a1) != 0)
  {
    if (v5 >= 0)
      v8 = a2;
    else
      v8 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    v9 = v8->__r_.__value_.__s.__data_[0] == 47;
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v6 + 24))(&v22);
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v22 + 32))(&v24);
    v10 = v23;
    if (v23)
    {
      p_shared_owners = (unint64_t *)&v23->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v13 = v25;
    v21[0] = v24;
    v21[1] = v25;
    if (v25)
    {
      v14 = (unint64_t *)&v25->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    sub_20BE06FD4(v21, a2, v9, a3);
    if (v13)
    {
      v16 = (unint64_t *)&v13->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    v18 = v25;
    if (v25)
    {
      v19 = (unint64_t *)&v25->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_20BE0591C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a13);
  _Unwind_Resume(a1);
}

std::string *Alembic::Abc::v12::IObject::setInstancedFullName(std::string *a1, const std::string *a2)
{
  return std::string::operator=(a1 + 3, a2);
}

uint64_t Alembic::Abc::v12::IObject::getNumChildren(Alembic::Abc::v12::IObject *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 5);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
  else
    return 0;
}

void sub_20BE059CC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IObject::getChildHeader(Alembic::Abc::v12::IObject *this)
{
  uint64_t v1;
  unsigned __int8 v3;
  _QWORD *v4;

  v1 = *((_QWORD *)this + 5);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 56))(v1);
  v3 = atomic_load((unsigned __int8 *)&qword_254784E58);
  if ((v3 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_254784E58))
    {
      v4 = operator new(0x48uLL);
      v4[8] = 0;
      v4[7] = 0;
      *(_OWORD *)v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
      *((_OWORD *)v4 + 2) = 0u;
      v4[6] = v4 + 7;
      qword_254784E50 = (uint64_t)v4;
      __cxa_guard_release(&qword_254784E58);
    }
  }
  return qword_254784E50;
}

void sub_20BE05AC4(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784E58);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IObject::getChildHeader(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 64))(v1);
  else
    return 0;
}

void sub_20BE05B74(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

double Alembic::Abc::v12::IObject::getChild@<D0>(Alembic::Abc::v12::IObject *this@<X0>, uint64_t a2@<X8>)
{
  int *v4;
  uint64_t v5;
  int v6;
  double result;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  int v11;
  const std::string::value_type *v12;
  std::string::size_type v13;
  std::string *v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  const std::string::value_type *v19;
  std::string::size_type v20;
  std::string *v21;
  __int128 v22;
  std::string v23;
  std::string v24;
  std::string __str;
  uint64_t v26;
  std::__shared_weak_count *v27;
  char *v28;
  const char *v29;

  v4 = (int *)((char *)this + 8);
  v28 = (char *)this + 8;
  v29 = "IObject::getChild()";
  v5 = *((_QWORD *)this + 5);
  if (!v5)
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 16), "");
    *(_QWORD *)a2 = off_24C518E68;
    result = 0.0;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_QWORD *)(a2 + 88) = 0;
    return result;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v5 + 80))(&v26);
  v6 = *v4;
  LODWORD(__str.__r_.__value_.__l.__data_) = 1;
  LODWORD(__str.__r_.__value_.__r.__words[1]) = v6;
  sub_20BE02B14(a2, &v26, (uint64_t **)&__str);
  v8 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if (*((char *)this + 95) < 0)
  {
    if (!*((_QWORD *)this + 10))
      return result;
  }
  else if (!*((_BYTE *)this + 95))
  {
    return result;
  }
  sub_20BDDC0E4(&v23, "/");
  v11 = *((char *)this + 95);
  if (v11 >= 0)
    v12 = (char *)this + 72;
  else
    v12 = (const std::string::value_type *)*((_QWORD *)this + 9);
  if (v11 >= 0)
    v13 = *((unsigned __int8 *)this + 95);
  else
    v13 = *((_QWORD *)this + 10);
  v14 = std::string::insert(&v23, 0, v12, v13);
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (*(_QWORD *)(a2 + 56))
    v16 = *(_QWORD *)(a2 + 56);
  else
    v16 = *(_QWORD *)(a2 + 40);
  v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 16))(v16);
  v18 = *(char *)(v17 + 23);
  if (v18 >= 0)
    v19 = (const std::string::value_type *)v17;
  else
    v19 = *(const std::string::value_type **)v17;
  if (v18 >= 0)
    v20 = *(unsigned __int8 *)(v17 + 23);
  else
    v20 = *(_QWORD *)(v17 + 8);
  v21 = std::string::append(&v24, v19, v20);
  v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  __str.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  std::string::operator=((std::string *)(a2 + 72), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  return result;
}

void sub_20BE05E30(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

double Alembic::Abc::v12::IObject::getChild@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int *v4;
  uint64_t v5;
  int v6;
  double result;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  int v11;
  const std::string::value_type *v12;
  std::string::size_type v13;
  std::string *v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  const std::string::value_type *v19;
  std::string::size_type v20;
  std::string *v21;
  __int128 v22;
  std::string v23;
  std::string v24;
  std::string __str;
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  const char *v29;

  v4 = (int *)(a1 + 8);
  v28 = a1 + 8;
  v29 = "IObject::getChild()";
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5)
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 16), "");
    *(_QWORD *)a2 = off_24C518E68;
    result = 0.0;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_QWORD *)(a2 + 88) = 0;
    return result;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v5 + 72))(&v26);
  v6 = *v4;
  LODWORD(__str.__r_.__value_.__l.__data_) = 1;
  LODWORD(__str.__r_.__value_.__r.__words[1]) = v6;
  sub_20BE02B14(a2, &v26, (uint64_t **)&__str);
  v8 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if (*(char *)(a1 + 95) < 0)
  {
    if (!*(_QWORD *)(a1 + 80))
      return result;
  }
  else if (!*(_BYTE *)(a1 + 95))
  {
    return result;
  }
  sub_20BDDC0E4(&v23, "/");
  v11 = *(char *)(a1 + 95);
  if (v11 >= 0)
    v12 = (const std::string::value_type *)(a1 + 72);
  else
    v12 = *(const std::string::value_type **)(a1 + 72);
  if (v11 >= 0)
    v13 = *(unsigned __int8 *)(a1 + 95);
  else
    v13 = *(_QWORD *)(a1 + 80);
  v14 = std::string::insert(&v23, 0, v12, v13);
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (*(_QWORD *)(a2 + 56))
    v16 = *(_QWORD *)(a2 + 56);
  else
    v16 = *(_QWORD *)(a2 + 40);
  v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 16))(v16);
  v18 = *(char *)(v17 + 23);
  if (v18 >= 0)
    v19 = (const std::string::value_type *)v17;
  else
    v19 = *(const std::string::value_type **)v17;
  if (v18 >= 0)
    v20 = *(unsigned __int8 *)(v17 + 23);
  else
    v20 = *(_QWORD *)(v17 + 8);
  v21 = std::string::append(&v24, v19, v20);
  v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  __str.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  std::string::operator=((std::string *)(a2 + 72), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  return result;
}

void sub_20BE060EC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IObject::reset(Alembic::Abc::v12::IObject *this)
{
  sub_20BDEBF08((_QWORD *)this + 7);
  if (*((char *)this + 95) < 0)
  {
    **((_BYTE **)this + 9) = 0;
    *((_QWORD *)this + 10) = 0;
  }
  else
  {
    *((_BYTE *)this + 72) = 0;
    *((_BYTE *)this + 95) = 0;
  }
  sub_20BDEBF08((_QWORD *)this + 5);
  JUMPOUT(0x212B929D0);
}

void Alembic::Abc::v12::IObject::getProperties(Alembic::Abc::v12::IObject *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _DWORD v7[4];
  _DWORD v8[4];
  uint64_t v9;
  std::__shared_weak_count *v10;
  char *v11;
  const char *v12;

  v11 = (char *)this + 8;
  v12 = "IObject::getProperties()";
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v3 + 40))(&v9);
    v8[0] = 0;
    v8[2] = 0;
    v7[0] = 0;
    v7[2] = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(a2, &v9, v8, v7);
    v4 = v10;
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 8), "");
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
  }
}

void sub_20BE06280(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IObject::getPropertiesHash(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 88))(v1);
  else
    return 0;
}

void sub_20BE0631C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IObject::getChildrenHash(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 96))(v1);
  else
    return 0;
}

void sub_20BE063B8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

BOOL Alembic::Abc::v12::IObject::isInstanceRoot(Alembic::Abc::v12::IObject *this)
{
  return *((_QWORD *)this + 7) != 0;
}

BOOL Alembic::Abc::v12::IObject::isInstanceDescendant(Alembic::Abc::v12::IObject *this)
{
  uint64_t v1;

  if (*((char *)this + 95) < 0)
    v1 = *((_QWORD *)this + 10);
  else
    v1 = *((unsigned __int8 *)this + 95);
  return v1 != 0;
}

void Alembic::Abc::v12::IObject::instanceSourcePath(Alembic::Abc::v12::IObject *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12[2];
  uint64_t v13;
  uint64_t v14;
  char *v15;
  const char *v16;

  v15 = (char *)this + 8;
  v16 = "IObject::instanceSourcePath()";
  v3 = *((_QWORD *)this + 7);
  if (v3)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v3 + 40))(&v13);
    v4 = (std::__shared_weak_count *)v14;
    v12[0] = v13;
    v12[1] = v14;
    if (v14)
    {
      v5 = (unint64_t *)(v14 + 8);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
    sub_20BE06574(v12, a2);
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    v9 = (std::__shared_weak_count *)v14;
    if (v14)
    {
      v10 = (unint64_t *)(v14 + 8);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
}

void sub_20BE06554(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BE06574(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t *v13;
  int v14;
  uint64_t *v15;
  int v16;
  void *__p[2];
  char v18;
  _DWORD v19[4];
  _DWORD v20[4];
  uint64_t v21;
  std::__shared_weak_count *v22;
  _QWORD v23[2];
  int v24;
  void *v25[2];
  uint64_t v26;
  char v27;
  uint64_t v28;

  v3 = *a1;
  if (!*a1)
    goto LABEL_18;
  sub_20BDDC0E4(v25, ".instanceSource");
  v5 = (*(uint64_t (**)(uint64_t, void **))(*(_QWORD *)v3 + 80))(v3, v25);
  v6 = v5;
  if ((SHIBYTE(v26) & 0x80000000) == 0)
  {
    if (v5)
      goto LABEL_4;
LABEL_18:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return;
  }
  operator delete(v25[0]);
  if (!v6)
    goto LABEL_18;
LABEL_4:
  v7 = (std::__shared_weak_count *)a1[1];
  v21 = *a1;
  v22 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v20[0] = 0;
  v20[2] = 0;
  v19[0] = 0;
  v19[2] = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v23, &v21, v20, v19);
  sub_20BDDC0E4(__p, ".instanceSource");
  LODWORD(v15) = 0;
  v16 = 0;
  LODWORD(v13) = 0;
  v14 = 0;
  sub_20BE07490((uint64_t)v25, (int *)v23, (uint64_t)__p, &v15, &v13);
  if (v18 < 0)
    operator delete(__p[0]);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v23);
  v10 = v22;
  if (v22)
  {
    v11 = (unint64_t *)&v22->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  if (v27 < 0)
  {
    if (!v26)
      goto LABEL_20;
LABEL_22:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    goto LABEL_23;
  }
  if (v27)
    goto LABEL_22;
LABEL_20:
  if (!v28)
    goto LABEL_22;
  v23[0] = 0;
  v23[1] = 0;
  v24 = 2;
  sub_20BE07440((uint64_t)v25, (uint64_t)v23, a2);
LABEL_23:
  Alembic::Abc::v12::IScalarProperty::~IScalarProperty(v25);
}

void sub_20BE06714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26)
{
  uint64_t v26;

  Alembic::Abc::v12::IScalarProperty::~IScalarProperty((void **)(v26 - 80));
  _Unwind_Resume(a1);
}

BOOL Alembic::Abc::v12::IObject::isChildInstance(Alembic::Abc::v12::IObject *this)
{
  _BOOL8 v1;
  void *v3[4];
  char v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  const char *v8;

  v7 = (char *)this + 8;
  v8 = "IObject::isChildInstanced(size_t iChildIndex)";
  Alembic::Abc::v12::IObject::getChild(this, (uint64_t)v3);
  if (v4 < 0)
  {
    if (!v3[3])
      goto LABEL_5;
LABEL_7:
    Alembic::Abc::v12::IObject::~IObject(v3);
    return 0;
  }
  if (v4)
    goto LABEL_7;
LABEL_5:
  if (!v5)
    goto LABEL_7;
  v1 = v6 != 0;
  Alembic::Abc::v12::IObject::~IObject(v3);
  return v1;
}

void sub_20BE067F8(void *a1, int a2)
{
  uint64_t v2;
  void *v4;

  v4 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570(v2 - 32, (uint64_t)v4);
  else
    sub_20BE02504(v2 - 32, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE067E0);
}

void sub_20BE0682C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

BOOL Alembic::Abc::v12::IObject::isChildInstance(uint64_t a1)
{
  _BOOL8 v1;
  void *v3[4];
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;

  v7 = a1 + 8;
  v8 = "IObject::isChildInstance(const std::string &iChildName)";
  Alembic::Abc::v12::IObject::getChild(a1, (uint64_t)v3);
  if (v4 < 0)
  {
    if (!v3[3])
      goto LABEL_5;
LABEL_7:
    Alembic::Abc::v12::IObject::~IObject(v3);
    return 0;
  }
  if (v4)
    goto LABEL_7;
LABEL_5:
  if (!v5)
    goto LABEL_7;
  v1 = v6 != 0;
  Alembic::Abc::v12::IObject::~IObject(v3);
  return v1;
}

void sub_20BE068CC(void *a1, int a2)
{
  uint64_t v2;
  void *v4;

  v4 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570(v2 - 32, (uint64_t)v4);
  else
    sub_20BE02504(v2 - 32, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE068B4);
}

void sub_20BE06900(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IObject::init(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  void *v14;
  int v15;
  __int128 v16;
  __int128 v17;
  uint64_t *v18;
  const char *v19;
  unsigned int v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v20 = *(_DWORD *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_20BDDBFAC(&v21, *(void **)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  else
  {
    v21 = *(_OWORD *)(a2 + 8);
    v22 = *(_QWORD *)(a2 + 24);
  }
  v6 = *(_QWORD *)(a2 + 40);
  v23 = *(_QWORD *)(a2 + 32);
  v24 = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  LODWORD(v14) = 0;
  v15 = 0;
  LODWORD(v18) = 0;
  LODWORD(v19) = 0;
  LODWORD(v17) = 0;
  DWORD2(v17) = 0;
  *(_DWORD *)(a1 + 8) = sub_20BE06AE8(&v20, a3, (uint64_t **)&v14, &v18, (uint64_t **)&v17);
  Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)&v20);
  v18 = (uint64_t *)(a1 + 8);
  v19 = "IObject::init( IArchive)";
  Alembic::Abc::v12::IArchive::getTop((Alembic::Abc::v12::IArchive *)a2, (uint64_t)&v14);
  v17 = v16;
  if (*((_QWORD *)&v16 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  sub_20BDE82DC(a1 + 40, &v17);
  v11 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v12 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  Alembic::Abc::v12::IObject::~IObject(&v14);
}

void sub_20BE06A70(void *a1, int a2)
{
  Alembic::Abc::v12::IObject *v2;
  uint64_t v3;
  void *v5;
  uint64_t v6;

  v5 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    v6 = (uint64_t)v5;
    Alembic::Abc::v12::IObject::reset(v2);
    sub_20BE02570(v3 - 96, v6);
  }
  else
  {
    Alembic::Abc::v12::IObject::reset(v2);
    sub_20BE02504(v3 - 96, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x20BE06A5CLL);
}

void sub_20BE06AB8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_20BE06AE8(unsigned int *a1, uint64_t **a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  unsigned int v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  const void **v15;
  _QWORD *v16[2];
  unsigned int v17;
  uint64_t v18[4];
  std::__shared_weak_count *v19;
  int v20;
  uint64_t v21;

  v9 = *a1;
  v16[0] = 0;
  v16[1] = 0;
  v15 = (const void **)v16;
  v17 = v9;
  sub_20BDEBF8C(v18, &v15);
  v18[3] = 0;
  v19 = 0;
  v20 = 0;
  v21 = 1;
  sub_20BDE9D48((uint64_t)&v15, v16[0]);
  sub_20BE02E30(a2, (uint64_t)&v17);
  sub_20BE02E30(a3, (uint64_t)&v17);
  sub_20BE02E30(a4, (uint64_t)&v17);
  sub_20BE02E30(a5, (uint64_t)&v17);
  v10 = v17;
  v11 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  sub_20BDE9D48((uint64_t)v18, (_QWORD *)v18[1]);
  return v10;
}

void sub_20BE06BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, _QWORD *a13)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a10);
  sub_20BDE9D48((uint64_t)&a12, a13);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IObject::init(uint64_t a1, _QWORD *a2, uint64_t a3, int a4)
{
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  __int128 v8;
  uint64_t v9;
  const char *v10;

  *(_DWORD *)(a1 + 8) = a4;
  v9 = a1 + 8;
  v10 = "IObject::init()";
  (*(void (**)(__int128 *__return_ptr, _QWORD, uint64_t))(*(_QWORD *)*a2 + 72))(&v8, *a2, a3);
  sub_20BDE82DC(a1 + 40, &v8);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_20BE06CB8(void *a1, int a2, uint64_t a3, uint64_t a4, ...)
{
  void *v5;
  va_list va;

  va_start(va, a4);
  v5 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)va, (uint64_t)v5);
  else
    sub_20BE02504((uint64_t)va, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE06CA8);
}

void sub_20BE06CEC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IObject::initInstance(std::string *this)
{
  std::string::size_type v2;
  uint64_t *v3;
  uint64_t v4;
  BOOL v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *data;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::string::size_type size;
  const std::string *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24[2];
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t v27[2];
  void *__p;
  uint64_t v29;
  char v30;
  std::string v31;

  v3 = (uint64_t *)&this[1].__r_.__value_.__r.__words[2];
  v2 = this[1].__r_.__value_.__r.__words[2];
  if (v2)
  {
    v4 = (*(uint64_t (**)(std::string::size_type))(*(_QWORD *)v2 + 16))(v2) + 48;
    sub_20BDDC0E4(&__p, "isInstance");
    sub_20BE01E1C(v4, (const void **)&__p, &v31);
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    {
      v5 = v31.__r_.__value_.__l.__size_ != 1 || *v31.__r_.__value_.__l.__data_ != 49;
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    else
    {
      v5 = SHIBYTE(v31.__r_.__value_.__r.__words[2]) != 1 || v31.__r_.__value_.__s.__data_[0] != 49;
    }
    if (v30 < 0)
    {
      operator delete(__p);
      if (v5)
        return;
    }
    else if (v5)
    {
      return;
    }
    (*(void (**)(void **__return_ptr))(*(_QWORD *)*v3 + 40))(&__p);
    v6 = (std::__shared_weak_count *)v29;
    v27[0] = (uint64_t)__p;
    v27[1] = v29;
    if (v29)
    {
      v7 = (unint64_t *)(v29 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    sub_20BE06574(v27, &v31);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    data = (std::__shared_weak_count *)this[2].__r_.__value_.__l.__data_;
    v24[0] = this[1].__r_.__value_.__r.__words[2];
    v24[1] = (uint64_t)data;
    if (data)
    {
      v12 = (unint64_t *)&data->__shared_owners_;
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    sub_20BE057B0(v24, &v31, &v25);
    if (data)
    {
      v14 = (unint64_t *)&data->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))data->__on_zero_shared)(data);
        std::__shared_weak_count::__release_weak(data);
      }
    }
    sub_20BDE881C(&this[2].__r_.__value_.__l.__size_, v3);
    sub_20BDE881C(v3, &v25);
    size = this[2].__r_.__value_.__l.__size_;
    if (size)
    {
      v17 = (const std::string *)(*(uint64_t (**)(std::string::size_type))(*(_QWORD *)size + 16))(size);
      std::string::operator=(this + 3, v17 + 1);
    }
    v18 = v26;
    if (v26)
    {
      v19 = (unint64_t *)&v26->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
    v21 = (std::__shared_weak_count *)v29;
    if (v29)
    {
      v22 = (unint64_t *)(v29 + 8);
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }
}

void sub_20BE06F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  if (*(char *)(v20 - 33) < 0)
    operator delete(*(void **)(v20 - 56));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&__p);
  _Unwind_Resume(a1);
}

void sub_20BE06FD4(_QWORD *a1@<X0>, const std::string *a2@<X1>, std::string::size_type a3@<X2>, _QWORD *a4@<X8>)
{
  std::string::size_type v8;
  std::string::size_type v9;
  uint64_t v10;
  _BOOL4 v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  __int128 v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  _QWORD v42[2];
  __int128 v43;
  __int128 v44;
  uint64_t v45[2];
  void *__p;
  uint64_t v47;
  char v48;
  __int128 v49;
  std::string v50;
  std::string v51;

  v8 = std::string::find(a2, 47, a3);
  v9 = v8;
  memset(&v51, 0, sizeof(v51));
  if (v8 == -1)
    std::string::basic_string(&v50, a2, a3, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
  else
    std::string::basic_string(&v50, a2, a3, v8 - a3, (std::allocator<char> *)&__p);
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v51.__r_.__value_.__l.__data_);
  v51 = v50;
  (*(void (**)(__int128 *__return_ptr, _QWORD, std::string *))(*(_QWORD *)*a1 + 72))(&v49, *a1, &v51);
  if (v9 == -1 || !(_QWORD)v49)
  {
    v12 = *((_QWORD *)&v49 + 1);
    *a4 = v49;
    a4[1] = v12;
    v49 = 0uLL;
  }
  else
  {
    v10 = (*(uint64_t (**)(void))(*(_QWORD *)v49 + 16))();
    sub_20BDDC0E4(&__p, "isInstance");
    sub_20BE01E1C(v10 + 48, (const void **)&__p, &v50);
    if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
    {
      v11 = v50.__r_.__value_.__l.__size_ == 1 && *v50.__r_.__value_.__l.__data_ == 49;
      operator delete(v50.__r_.__value_.__l.__data_);
    }
    else
    {
      v11 = SHIBYTE(v50.__r_.__value_.__r.__words[2]) == 1 && v50.__r_.__value_.__s.__data_[0] == 49;
    }
    if (v48 < 0)
      operator delete(__p);
    v13 = v49;
    if (v11)
    {
      (*(void (**)(void **__return_ptr))(*(_QWORD *)v49 + 40))(&__p);
      v14 = (std::__shared_weak_count *)v47;
      v45[0] = (uint64_t)__p;
      v45[1] = v47;
      if (v47)
      {
        v15 = (unint64_t *)(v47 + 8);
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
      sub_20BE06574(v45, &v50);
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          v18 = __ldaxr(p_shared_owners);
        while (__stlxr(v18 - 1, p_shared_owners));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      v43 = v49;
      if (*((_QWORD *)&v49 + 1))
      {
        v19 = (unint64_t *)(*((_QWORD *)&v49 + 1) + 8);
        do
          v20 = __ldxr(v19);
        while (__stxr(v20 + 1, v19));
      }
      sub_20BE057B0(&v44, &v43, &v50);
      v21 = v44;
      v44 = 0uLL;
      v22 = (std::__shared_weak_count *)*((_QWORD *)&v49 + 1);
      v49 = v21;
      if (v22)
      {
        v23 = (unint64_t *)&v22->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      v25 = (std::__shared_weak_count *)*((_QWORD *)&v44 + 1);
      if (*((_QWORD *)&v44 + 1))
      {
        v26 = (unint64_t *)(*((_QWORD *)&v44 + 1) + 8);
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      v28 = (std::__shared_weak_count *)*((_QWORD *)&v43 + 1);
      if (*((_QWORD *)&v43 + 1))
      {
        v29 = (unint64_t *)(*((_QWORD *)&v43 + 1) + 8);
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
      if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v50.__r_.__value_.__l.__data_);
      v31 = (std::__shared_weak_count *)v47;
      if (v47)
      {
        v32 = (unint64_t *)(v47 + 8);
        do
          v33 = __ldaxr(v32);
        while (__stlxr(v33 - 1, v32));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
      v13 = v49;
    }
    v34 = (std::__shared_weak_count *)*((_QWORD *)&v49 + 1);
    v42[0] = v13;
    v42[1] = *((_QWORD *)&v49 + 1);
    if (*((_QWORD *)&v49 + 1))
    {
      v35 = (unint64_t *)(*((_QWORD *)&v49 + 1) + 8);
      do
        v36 = __ldxr(v35);
      while (__stxr(v36 + 1, v35));
    }
    sub_20BE06FD4(v42, a2, v9 + 1);
    if (v34)
    {
      v37 = (unint64_t *)&v34->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
  }
  v39 = (std::__shared_weak_count *)*((_QWORD *)&v49 + 1);
  if (*((_QWORD *)&v49 + 1))
  {
    v40 = (unint64_t *)(*((_QWORD *)&v49 + 1) + 8);
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v51.__r_.__value_.__l.__data_);
}

void sub_20BE073A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  uint64_t v24;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a11);
  if (*(char *)(v24 - 81) < 0)
    operator delete(*(void **)(v24 - 104));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&__p);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a24);
  if (*(char *)(v24 - 57) < 0)
    operator delete(*(void **)(v24 - 80));
  _Unwind_Resume(a1);
}

uint64_t sub_20BE07440@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  return Alembic::Abc::v12::IScalarProperty::get(a1, (uint64_t)a3, a2, 24);
}

void sub_20BE07474(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BE07490(uint64_t a1, int *a2, uint64_t a3, uint64_t **a4, uint64_t **a5)
{
  int v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  void **v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *exception;
  _QWORD *v42;
  _QWORD *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  uint64_t v49;
  void *v50[2];
  char v51;
  void *__p[2];
  unsigned __int8 v53;
  __int128 v54;
  _QWORD v55[34];
  std::__shared_weak_count *v56;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62[4];
  std::__shared_weak_count *v63;
  int v64;
  uint64_t v65;

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v10 = *a2;
  *((_QWORD *)&v54 + 1) = 0;
  v55[0] = 0;
  *(_QWORD *)&v54 = (char *)&v54 + 8;
  v59 = 0;
  v60 = 0;
  v61 = v10;
  sub_20BDEBF8C(v62, (const void ***)&v54);
  v62[3] = 0;
  v63 = 0;
  v64 = 0;
  v65 = 1;
  sub_20BDE9D48((uint64_t)&v54, *((_QWORD **)&v54 + 1));
  sub_20BE02E30(a4, (uint64_t)&v61);
  sub_20BE02E30(a5, (uint64_t)&v61);
  *(_DWORD *)a1 = v61;
  v57 = a1;
  v58 = "ITypedScalarProperty::ITypedScalarProperty()";
  v12 = *((_QWORD *)a2 + 4);
  v11 = (std::__shared_weak_count *)*((_QWORD *)a2 + 5);
  v55[33] = v12;
  v56 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  if (!v12)
  {
    sub_20BDDBD68((uint64_t)&v54);
    v40 = sub_20BDDC1C8(v55, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_20BDDC1C8(v40, (uint64_t)"ITypedScalarProperty ctor", 25);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v50);
    if (v51 < 0)
      operator delete(v50[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v42 = sub_20BDDC09C(exception, (uint64_t)__p);
    __cxa_throw(v42, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v12 + 80))(v12, a3);
  v16 = v15;
  if (!v15)
  {
    sub_20BDDBD68((uint64_t)&v54);
    v43 = sub_20BDDC1C8(v55, (uint64_t)"Nonexistent scalar property: ", 29);
    v44 = *(char *)(a3 + 23);
    if (v44 >= 0)
      v45 = a3;
    else
      v45 = *(_QWORD *)a3;
    if (v44 >= 0)
      v46 = *(unsigned __int8 *)(a3 + 23);
    else
      v46 = *(_QWORD *)(a3 + 8);
    sub_20BDDC1C8(v43, v45, v46);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v50);
    if (v51 < 0)
      operator delete(v50[0]);
    v47 = __cxa_allocate_exception(0x20uLL);
    v48 = sub_20BDDC09C(v47, (uint64_t)__p);
    __cxa_throw(v48, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v18 = *(_DWORD *)(v15 + 56) == 12 && *(_BYTE *)(v15 + 60) == 1 && *(_DWORD *)(v15 + 24) == 1;
  if (!v18 || (sub_20BE07A80(v15 + 32, v65) & 1) == 0)
  {
    sub_20BDDBD68((uint64_t)&v54);
    v29 = sub_20BDDC1C8(v55, (uint64_t)"Incorrect match of header datatype: ", 36);
    v30 = sub_20BDE00F4(v29, (int *)(v16 + 56));
    v31 = sub_20BDDC1C8(v30, (uint64_t)" to expected: ", 14);
    v49 = 0x10000000CLL;
    v32 = sub_20BDE00F4(v31, (int *)&v49);
    v33 = sub_20BDDC1C8(v32, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_20BDDC0E4(v50, "interpretation");
    sub_20BE01E1C(v16 + 32, (const void **)v50, __p);
    if ((v53 & 0x80u) == 0)
      v34 = __p;
    else
      v34 = (void **)__p[0];
    if ((v53 & 0x80u) == 0)
      v35 = v53;
    else
      v35 = (uint64_t)__p[1];
    v36 = sub_20BDDC1C8(v33, (uint64_t)v34, v35);
    v37 = sub_20BDDC1C8(v36, (uint64_t)" to expected: ", 14);
    sub_20BDDC1C8(v37, (uint64_t)"", 0);
    if ((char)v53 < 0)
      operator delete(__p[0]);
    if (v51 < 0)
      operator delete(v50[0]);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v50);
    if (v51 < 0)
      operator delete(v50[0]);
    v38 = __cxa_allocate_exception(0x20uLL);
    v39 = sub_20BDDC09C(v38, (uint64_t)__p);
    __cxa_throw(v39, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v12 + 88))(&v54, v12, a3);
  sub_20BDE82DC(a1 + 32, &v54);
  v19 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
  if (*((_QWORD *)&v54 + 1))
  {
    v20 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v56;
  if (v56)
  {
    v23 = (unint64_t *)&v56->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v63;
  if (v63)
  {
    v26 = (unint64_t *)&v63->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  sub_20BDE9D48((uint64_t)v62, (_QWORD *)v62[1]);
  return a1;
}

void sub_20BE0791C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,uint64_t a25)
{
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  void *v30;

  sub_20BDDC194((std::exception *)&__p);
  sub_20BDDBE98((uint64_t)&a24);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v27 - 192));
  v30 = __cxa_begin_catch(a1);
  sub_20BDEBF08(v26);
  MEMORY[0x212B929D0](v25, "");
  if (a2 == 2)
    sub_20BE02570(v27 - 176, (uint64_t)v30);
  else
    sub_20BE02504(v27 - 176, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE07668);
}

void sub_20BE07A40()
{
  uint64_t v0;

  sub_20BE02EB0(v0 - 144);
  JUMPOUT(0x20BE07A70);
}

uint64_t sub_20BE07A80(uint64_t a1, int a2)
{
  _BOOL8 v2;
  void *__p[2];
  char v6;
  void *v7[2];
  char v8;

  if (a2)
    return 1;
  sub_20BDDC0E4(__p, "interpretation");
  sub_20BE01E1C(a1, (const void **)__p, v7);
  if (v8 < 0)
  {
    v2 = v7[1] == 0;
    operator delete(v7[0]);
  }
  else
  {
    v2 = v8 == 0;
  }
  if (v6 < 0)
    operator delete(__p[0]);
  return v2;
}

void sub_20BE07B08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::Abc::v12::ISampleSelector::getIndex(uint64_t a1, double ***a2, uint64_t a3)
{
  uint64_t CeilIndex;
  uint64_t v6;
  int v8;

  CeilIndex = *(_QWORD *)a1;
  if (CeilIndex < 0)
  {
    v8 = *(_DWORD *)(a1 + 16);
    if (v8)
    {
      if (v8 == 2)
        CeilIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getNearIndex(*a2, *(double *)(a1 + 8), a3);
      else
        CeilIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getCeilIndex(*a2, *(double *)(a1 + 8), a3);
    }
    else
    {
      CeilIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(*a2, *(double *)(a1 + 8), a3);
    }
  }
  v6 = a3 - 1;
  if (CeilIndex < a3)
    v6 = CeilIndex;
  if (CeilIndex >= 0)
    return v6;
  else
    return 0;
}

uint64_t Alembic::Abc::v12::IScalarProperty::IScalarProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v14[2];

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v8 = *(std::__shared_weak_count **)(a2 + 40);
  v14[0] = *(_QWORD *)(a2 + 32);
  v14[1] = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  Alembic::Abc::v12::IScalarProperty::init((_DWORD *)a1, v14, a3, *(_DWORD *)a2, a4);
  if (v8)
  {
    v11 = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return a1;
}

void sub_20BE07C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  sub_20BE032CC(v9);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IScalarProperty::init(_DWORD *a1, _QWORD *a2, uint64_t a3, int a4, uint64_t **a5)
{
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *exception;
  _QWORD *v20;
  __int128 __p;
  char v22;
  _QWORD v23[4];
  __int128 v24;
  _QWORD v25[37];
  int v26;
  uint64_t v27[4];
  std::__shared_weak_count *v28;
  int v29;
  uint64_t v30;

  *((_QWORD *)&v24 + 1) = 0;
  v25[0] = 0;
  *(_QWORD *)&v24 = (char *)&v24 + 8;
  v25[35] = 0;
  v25[36] = 0;
  v26 = a4;
  sub_20BDEBF8C(v27, (const void ***)&v24);
  v27[3] = 0;
  v28 = 0;
  v29 = 0;
  v30 = 1;
  sub_20BDE9D48((uint64_t)&v24, *((_QWORD **)&v24 + 1));
  sub_20BE02E30(a5, (uint64_t)&v26);
  *a1 = v26;
  v25[33] = a1;
  v25[34] = "IScalarProperty::init()";
  if (!(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*a2 + 80))(*a2, a3))
  {
    sub_20BDDBD68((uint64_t)&v24);
    v15 = sub_20BDDC1C8(v25, (uint64_t)"Nonexistent scalar property: ", 29);
    v16 = *(char *)(a3 + 23);
    if (v16 >= 0)
      v17 = a3;
    else
      v17 = *(_QWORD *)a3;
    if (v16 >= 0)
      v18 = *(unsigned __int8 *)(a3 + 23);
    else
      v18 = *(_QWORD *)(a3 + 8);
    sub_20BDDC1C8(v15, v17, v18);
    std::stringbuf::str();
    sub_20BDDBF20(v23, &__p);
    if (v22 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v20 = sub_20BDDC09C(exception, (uint64_t)v23);
    __cxa_throw(v20, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  (*(void (**)(__int128 *__return_ptr, _QWORD, uint64_t))(*(_QWORD *)*a2 + 88))(&v24, *a2, a3);
  sub_20BDE82DC((uint64_t)(a1 + 8), &v24);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v24 + 1);
  if (*((_QWORD *)&v24 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v28;
  if (v28)
  {
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  sub_20BDE9D48((uint64_t)v27, (_QWORD *)v27[1]);
}

void sub_20BE07E84(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v6;
  void *v9;
  std::exception v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v10.__vftable = va_arg(va1, std::exception_vtbl *);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  v9 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v5 + 32));
  MEMORY[0x212B929D0](v5 + 8, "");
  if (a2 == 2)
    sub_20BE02570(v6 - 144, (uint64_t)v9);
  else
    sub_20BE02504(v6 - 144, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE07D98);
}

void sub_20BE07F20(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BE02EB0(v1 - 112);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IScalarProperty::~IScalarProperty(void **this)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 4));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

uint64_t Alembic::Abc::v12::IScalarProperty::getNumSamples(Alembic::Abc::v12::IScalarProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
}

void sub_20BE07FF0(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE07FE0);
}

void sub_20BE08028(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IScalarProperty::isConstant(Alembic::Abc::v12::IScalarProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 72))(*((_QWORD *)this + 4));
}

void sub_20BE08084(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE08074);
}

void sub_20BE080BC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IScalarProperty::getTimeSampling@<X0>(Alembic::Abc::v12::IScalarProperty *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4));
  v4 = *(_QWORD *)(result + 72);
  *a2 = *(_QWORD *)(result + 64);
  a2[1] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

void sub_20BE0813C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v9;
  void *v11;

  v11 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v11);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  *v9 = 0;
  v9[1] = 0;
  JUMPOUT(0x20BE0812CLL);
}

void sub_20BE08174(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::IScalarProperty::get(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  uint64_t Index;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  double **v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  const char *v21;

  v20 = a1;
  v21 = "IScalarProperty::get()";
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32));
  v9 = *(std::__shared_weak_count **)(v8 + 72);
  v18 = *(double ***)(v8 + 64);
  v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v12 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  Index = Alembic::Abc::v12::ISampleSelector::getIndex(a3, &v18, v12);
  v14 = v19;
  if (v19)
  {
    v15 = (unint64_t *)&v19->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 32) + 80))(*(_QWORD *)(a1 + 32), Index, a2, a4);
}

void sub_20BE08288(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v12;

  v12 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a11, (uint64_t)v12);
  else
    sub_20BE02504((uint64_t)&a11, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE08270);
}

void sub_20BE082DC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IScalarProperty::getParent(Alembic::Abc::v12::IScalarProperty *this@<X0>, uint64_t a2@<X8>)
{
  int v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  _DWORD v8[4];
  _DWORD v9[4];
  uint64_t v10;
  std::__shared_weak_count *v11;
  Alembic::Abc::v12::IScalarProperty *v12;
  const char *v13;

  v12 = this;
  v13 = "IScalarProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 4) + 32))(&v10);
  v4 = *(_DWORD *)this;
  v9[0] = 1;
  v9[2] = v4;
  v8[0] = 0;
  v8[2] = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(a2, &v10, v9, v8);
  v5 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_20BE083B0(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  void *v9;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  v9 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)va1, (uint64_t)v9);
  else
    sub_20BE02504((uint64_t)va1, 0);
  __cxa_end_catch();
  *(_DWORD *)v6 = 2;
  sub_20BDDC0E4((_QWORD *)(v6 + 8), "");
  *(_QWORD *)(v6 + 32) = 0;
  *(_QWORD *)(v6 + 40) = 0;
  JUMPOUT(0x20BE0839CLL);
}

void sub_20BE0841C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OArchive::~OArchive(void **this)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 4));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

char *Alembic::Abc::v12::OArchive::getName@<X0>(Alembic::Abc::v12::OArchive *this@<X0>, uint64_t a2@<X8>)
{
  char *result;
  __int128 v4;

  result = (char *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4));
  if (result[23] < 0)
    return (char *)sub_20BDDBFAC((_BYTE *)a2, *(void **)result, *((_QWORD *)result + 1));
  v4 = *(_OWORD *)result;
  *(_QWORD *)(a2 + 16) = *((_QWORD *)result + 2);
  *(_OWORD *)a2 = v4;
  return result;
}

void sub_20BE084E0(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v9;
  void *v11;

  v11 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v11);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  sub_20BDDC0E4(v9, "");
  JUMPOUT(0x20BE084D0);
}

void sub_20BE08524(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OArchive::getCompressionHint(Alembic::Abc::v12::OArchive *this)
{
  return *(char *)(*((_QWORD *)this + 4) + 8);
}

uint64_t Alembic::Abc::v12::OArchive::setCompressionHint(uint64_t this, int a2)
{
  int v2;

  if (a2 >= 9)
    v2 = 9;
  else
    v2 = a2;
  if (v2 < 0)
    LOBYTE(v2) = -1;
  *(_BYTE *)(*(_QWORD *)(this + 32) + 8) = v2;
  return this;
}

uint64_t Alembic::Abc::v12::OArchive::addTimeSampling(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

void sub_20BE085AC(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0859CLL);
}

void sub_20BE085E4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *Alembic::Abc::v12::OArchive::getTimeSampling@<X0>(Alembic::Abc::v12::OArchive *this@<X0>, _QWORD *a2@<X8>)
{
  return (*(_QWORD *(**)(_QWORD *__return_ptr))(**((_QWORD **)this + 4) + 56))(a2);
}

void sub_20BE08648(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v9;
  void *v11;

  v11 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v11);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  *v9 = 0;
  v9[1] = 0;
  JUMPOUT(0x20BE08638);
}

void sub_20BE08680(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OArchive::getNumTimeSamplings(Alembic::Abc::v12::OArchive *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
}

void sub_20BE086DC(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE086CCLL);
}

void sub_20BE08714(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OArchive::getTop(Alembic::Abc::v12::OArchive *this@<X0>, uint64_t a2@<X8>)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t *v6;
  int v7;
  uint64_t *v8;
  int v9;
  uint64_t *v10;
  int v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  Alembic::Abc::v12::OArchive *v14;
  const char *v15;

  v14 = this;
  v15 = "OArchive::getTop()";
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 4) + 32))(&v12);
  LODWORD(v10) = 0;
  v11 = 0;
  LODWORD(v8) = 0;
  v9 = 0;
  LODWORD(v6) = 0;
  v7 = 0;
  sub_20BE08884(a2, &v12, &v10, &v8, &v6);
  v3 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_20BE087E8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  uint64_t v9;
  void *v12;
  va_list va;

  va_start(va, a8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  v12 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570(v9 - 48, (uint64_t)v12);
  else
    sub_20BE02504(v9 - 48, 0);
  __cxa_end_catch();
  *(_DWORD *)(v8 + 8) = 2;
  sub_20BDDC0E4((_QWORD *)(v8 + 16), "");
  *(_QWORD *)v8 = off_24C518EC0;
  *(_QWORD *)(v8 + 40) = 0;
  *(_QWORD *)(v8 + 48) = 0;
  JUMPOUT(0x20BE087D4);
}

void sub_20BE08864(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_20BE08884(uint64_t a1, _QWORD *a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t *v20;
  int v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  *(_DWORD *)(a1 + 8) = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 16), "");
  *(_QWORD *)a1 = off_24C518EC0;
  *(_QWORD *)(a1 + 40) = *a2;
  v10 = a2[1];
  *(_QWORD *)(a1 + 48) = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = (std::__shared_weak_count *)a2[1];
  v22 = *a2;
  v23 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  LODWORD(v20) = 0;
  v21 = 0;
  *(_DWORD *)(a1 + 8) = sub_20BE089D4((uint64_t)&v22, a3, a4, a5, &v20);
  v16 = v23;
  if (v23)
  {
    v17 = (unint64_t *)&v23->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  return a1;
}

void sub_20BE089A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  void **v4;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v5;
  va_list va;

  va_start(va, a3);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v5);
  if (*(char *)(v3 + 39) < 0)
    operator delete(*v4);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE089D4(uint64_t a1, uint64_t **a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  const void **v19;
  _QWORD *v20[4];
  unsigned int v21;
  uint64_t v22[4];
  std::__shared_weak_count *v23;
  int v24;
  uint64_t v25;

  v9 = *(std::__shared_weak_count **)(a1 + 8);
  v20[2] = *(_QWORD **)a1;
  v20[3] = &v9->__vftable;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v20[0] = 0;
  v20[1] = 0;
  v19 = (const void **)v20;
  v21 = 2;
  sub_20BDEBF8C(v22, &v19);
  v22[3] = 0;
  v23 = 0;
  v24 = 0;
  v25 = 1;
  sub_20BDE9D48((uint64_t)&v19, v20[0]);
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  sub_20BE02E30(a2, (uint64_t)&v21);
  sub_20BE02E30(a3, (uint64_t)&v21);
  sub_20BE02E30(a4, (uint64_t)&v21);
  sub_20BE02E30(a5, (uint64_t)&v21);
  v14 = v21;
  v15 = v23;
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  sub_20BDE9D48((uint64_t)v22, (_QWORD *)v22[1]);
  return v14;
}

void sub_20BE08B34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;
  _QWORD *v8;
  uint64_t v9;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v6 = va_arg(va2, _QWORD);
  v8 = va_arg(va2, _QWORD *);
  v9 = va_arg(va2, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  sub_20BDE9D48((uint64_t)va1, v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va2);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OArrayProperty::OArrayProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t **a5, uint64_t **a6, uint64_t **a7)
{
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  _QWORD v20[2];

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v14 = *(std::__shared_weak_count **)(a2 + 40);
  v20[0] = *(_QWORD *)(a2 + 32);
  v20[1] = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  Alembic::Abc::v12::OArrayProperty::init((const void **)a1, v20, a3, a4, *(_DWORD *)a2, a5, a6, a7);
  if (v14)
  {
    v17 = (unint64_t *)&v14->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  return a1;
}

void sub_20BE08C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  sub_20BE032CC(v9);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OArrayProperty::init(const void **a1, _QWORD *a2, uint64_t a3, uint64_t a4, int a5, uint64_t **a6, uint64_t **a7, uint64_t **a8)
{
  uint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  __int128 v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  uint64_t v39;
  uint64_t v40;
  const void **v41;
  _QWORD *v42[2];
  int v43;
  uint64_t v44[3];
  uint64_t v45;
  std::__shared_weak_count *v46;
  unsigned int v47;
  uint64_t v48;

  v42[0] = 0;
  v42[1] = 0;
  v40 = 0;
  v41 = (const void **)v42;
  v39 = 0;
  v43 = a5;
  sub_20BDEBF8C(v44, &v41);
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 1;
  sub_20BDE9D48((uint64_t)&v41, v42[0]);
  sub_20BE02E30(a6, (uint64_t)&v43);
  sub_20BE02E30(a7, (uint64_t)&v43);
  sub_20BE02E30(a8, (uint64_t)&v43);
  *(_DWORD *)a1 = v43;
  v41 = a1;
  v42[0] = "OArrayProperty::init()";
  v15 = v45;
  v37 = v45;
  v38 = v46;
  if (v46)
  {
    p_shared_owners = (unint64_t *)&v46->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }
  if (v15)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)*a2 + 24))(&v34);
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v34 + 24))(&v36);
    v18 = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v36 + 48))(v36, v15);
    v19 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
    if (*((_QWORD *)&v36 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v22 = v35;
    if (v35)
    {
      v23 = (unint64_t *)&v35->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
  }
  else
  {
    v18 = v47;
  }
  (*(void (**)(__int128 *__return_ptr, _QWORD, uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)*a2 + 104))(&v36, *a2, a3, v44, a4, v18);
  sub_20BDE82DC((uint64_t)(a1 + 4), &v36);
  v25 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
  if (*((_QWORD *)&v36 + 1))
  {
    v26 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v38;
  if (v38)
  {
    v29 = (unint64_t *)&v38->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v46;
  if (v46)
  {
    v32 = (unint64_t *)&v46->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  sub_20BDE9D48((uint64_t)v44, (_QWORD *)v44[1]);
}

void sub_20BE08F08(void *a1, int a2, uint64_t a3, ...)
{
  uint64_t v3;
  void *v6;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  va_list va1;
  uint64_t v12;
  uint64_t v13;
  va_list va2;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va3;

  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v10 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v13 = va_arg(va3, _QWORD);
  v15 = va_arg(va3, _QWORD);
  v16 = va_arg(va3, _QWORD);
  v17 = va_arg(va3, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va2);
  v6 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v3 + 32));
  MEMORY[0x212B929D0](v3 + 8, "");
  if (a2 == 2)
    sub_20BE02570((uint64_t)va3, (uint64_t)v6);
  else
    sub_20BE02504((uint64_t)va3, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE08EA8);
}

void sub_20BE08FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  sub_20BE02EB0((uint64_t)va);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OArrayProperty::~OArrayProperty(void **this)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 4));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

uint64_t Alembic::Abc::v12::OArrayProperty::getNumSamples(Alembic::Abc::v12::OArrayProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 80))(*((_QWORD *)this + 4));
}

void sub_20BE09074(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE09064);
}

void sub_20BE090AC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OArrayProperty::set(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
}

void sub_20BE09108(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE090F8);
}

void sub_20BE0913C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OArrayProperty::setFromPrevious(Alembic::Abc::v12::OArrayProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 72))(*((_QWORD *)this + 4));
}

void sub_20BE09198(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE09188);
}

void sub_20BE091CC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OArrayProperty::setTimeSampling(Alembic::Abc::v12::OArrayProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 88))(*((_QWORD *)this + 4));
}

void sub_20BE09228(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE09218);
}

void sub_20BE0925C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OArrayProperty::setTimeSampling(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  const char *v22;

  v21 = a1;
  v22 = "OArrayProperty::setTimeSampling()";
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a1 + 32) + 32))(&v15);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v15 + 24))(&v17);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v17 + 24))(&v19);
  v4 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 48))(v19, *a2);
  v5 = v20;
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = v18;
  if (v18)
  {
    v9 = (unint64_t *)&v18->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v16;
  if (v16)
  {
    v12 = (unint64_t *)&v16->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 32) + 88))(*(_QWORD *)(a1 + 32), v4);
}

void sub_20BE093C8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15)
{
  void *v16;

  v16 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a15, (uint64_t)v16);
  else
    sub_20BE02504((uint64_t)&a15, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE093B4);
}

void sub_20BE09444(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OArrayProperty::getParent(Alembic::Abc::v12::OArrayProperty *this@<X0>, uint64_t a2@<X8>)
{
  int v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  _DWORD v8[4];
  _DWORD v9[4];
  uint64_t v10;
  std::__shared_weak_count *v11;
  Alembic::Abc::v12::OArrayProperty *v12;
  const char *v13;

  v12 = this;
  v13 = "OArrayProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 4) + 32))(&v10);
  v4 = *(_DWORD *)this;
  v9[0] = 1;
  v9[2] = v4;
  v8[0] = 0;
  v8[2] = 0;
  Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(a2, &v10, v9, v8);
  v5 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_20BE09518(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  void *v9;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  v9 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)va1, (uint64_t)v9);
  else
    sub_20BE02504((uint64_t)va1, 0);
  __cxa_end_catch();
  *(_DWORD *)v6 = 2;
  sub_20BDDC0E4((_QWORD *)(v6 + 8), "");
  *(_QWORD *)(v6 + 32) = 0;
  *(_QWORD *)(v6 + 40) = 0;
  JUMPOUT(0x20BE09504);
}

void sub_20BE09584(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t **a4, uint64_t **a5)
{
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t *v17;
  int v18;
  _QWORD v19[2];

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v10 = *a2;
  v11 = (std::__shared_weak_count *)a2[1];
  v19[0] = v10;
  v19[1] = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  LODWORD(v17) = 0;
  v18 = 0;
  Alembic::Abc::v12::OCompoundProperty::init(a1, v19, a3, a4, a5, &v17);
  if (v11)
  {
    v14 = (unint64_t *)&v11->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return a1;
}

{
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  int v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t *v23;
  int v24;
  uint64_t *v25;
  int v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;

  v7 = *a2;
  v6 = (std::__shared_weak_count *)a2[1];
  v29 = *a2;
  v30 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    v10 = (std::__shared_weak_count *)a2[1];
    v27 = *a2;
    v28 = v10;
    if (v10)
    {
      v11 = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
  }
  else
  {
    v27 = v7;
    v28 = 0;
  }
  LODWORD(v25) = 0;
  v26 = 0;
  LODWORD(v23) = 0;
  v24 = 0;
  v13 = sub_20BE09CD4((uint64_t)&v27, a4, a5, &v25, &v23);
  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = v7;
  *(_QWORD *)(a1 + 40) = v6;
  if (v6)
  {
    v14 = (unint64_t *)&v6->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  *(_DWORD *)a1 = v13;
  v16 = v28;
  if (v28)
  {
    v17 = (unint64_t *)&v28->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v30;
  if (v30)
  {
    v20 = (unint64_t *)&v30->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  return a1;
}

void sub_20BE0967C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  sub_20BE032CC(v3);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OCompoundProperty::init(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t **a6)
{
  void *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  _QWORD *exception;
  _QWORD *v28;
  void *lpsrc[2];
  char v30;
  __int128 v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  _QWORD *v35[3];
  std::__shared_weak_count *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;

  v39 = a1;
  v40 = "OCompoundProperty::init()";
  if (!*a2)
  {
    sub_20BDDBD68((uint64_t)&v33);
    sub_20BDDC1C8(v35, (uint64_t)"invalid parent", 14);
    std::stringbuf::str();
    sub_20BDDBF20(&v31, (__int128 *)lpsrc);
    if (v30 < 0)
      operator delete(lpsrc[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v28 = sub_20BDDC09C(exception, (uint64_t)&v31);
    __cxa_throw(v28, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  *((_QWORD *)&v31 + 1) = 0;
  v32 = 0;
  *(_QWORD *)&v31 = (char *)&v31 + 8;
  v33 = 2;
  sub_20BDEBF8C(&v34, (const void ***)&v31);
  v35[2] = 0;
  v36 = 0;
  v37 = 0;
  v38 = 1;
  sub_20BDE9D48((uint64_t)&v31, *((_QWORD **)&v31 + 1));
  sub_20BE02E30(a4, (uint64_t)&v33);
  sub_20BE02E30(a5, (uint64_t)&v33);
  sub_20BE02E30(a6, (uint64_t)&v33);
  *(_DWORD *)a1 = v33;
  (*(void (**)(void **__return_ptr, _QWORD, uint64_t))(*(_QWORD *)*a2 + 88))(lpsrc, *a2, a3);
  if (lpsrc[0]
  {
    *(_QWORD *)&v31 = v12;
    *((void **)&v31 + 1) = lpsrc[1];
    if (lpsrc[1])
    {
      v13 = (unint64_t *)((char *)lpsrc[1] + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
  }
  else
  {
    v31 = 0uLL;
  }
  sub_20BDE82DC(a1 + 32, &v31);
  v15 = (std::__shared_weak_count *)*((_QWORD *)&v31 + 1);
  if (*((_QWORD *)&v31 + 1))
  {
    v16 = (unint64_t *)(*((_QWORD *)&v31 + 1) + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = (std::__shared_weak_count *)lpsrc[1];
  if (lpsrc[1])
  {
    v19 = (unint64_t *)((char *)lpsrc[1] + 8);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  if (!*(_QWORD *)(a1 + 32))
  {
    (*(void (**)(__int128 *__return_ptr, _QWORD, uint64_t, uint64_t *))(*(_QWORD *)*a2 + 112))(&v31, *a2, a3, &v34);
    sub_20BDE82DC(a1 + 32, &v31);
    v24 = (std::__shared_weak_count *)*((_QWORD *)&v31 + 1);
    if (*((_QWORD *)&v31 + 1))
    {
      v25 = (unint64_t *)(*((_QWORD *)&v31 + 1) + 8);
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  v21 = v36;
  if (v36)
  {
    p_shared_owners = (unint64_t *)&v36->__shared_owners_;
    do
      v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  sub_20BDE9D48((uint64_t)&v34, v35[0]);
}

void sub_20BE09980(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  uint64_t v8;
  void *v11;
  std::exception v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  v11 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v7 + 32));
  MEMORY[0x212B929D0](v7 + 8, "");
  if (a2 == 2)
    sub_20BE02570(v8 - 80, (uint64_t)v11);
  else
    sub_20BE02504(v8 - 80, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0988CLL);
}

void sub_20BE09A4C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t **a5)
{
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t *v17;
  int v18;
  _QWORD v19[2];

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v10 = *(_QWORD *)(a2 + 32);
  v11 = *(std::__shared_weak_count **)(a2 + 40);
  v19[0] = v10;
  v19[1] = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  LODWORD(v17) = 0;
  v18 = 0;
  Alembic::Abc::v12::OCompoundProperty::init(a1, v19, a3, a4, a5, &v17);
  if (v11)
  {
    v14 = (unint64_t *)&v11->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return a1;
}

void sub_20BE09B48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  sub_20BE032CC(v3);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(uint64_t a1, uint64_t *a2, uint64_t **a3, uint64_t **a4)
{
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  int v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t *v22;
  int v23;
  uint64_t *v24;
  int v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;

  v6 = *a2;
  v5 = (std::__shared_weak_count *)a2[1];
  v28 = *a2;
  v29 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v9 = (std::__shared_weak_count *)a2[1];
    v26 = *a2;
    v27 = v9;
    if (v9)
    {
      v10 = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
  }
  else
  {
    v26 = v6;
    v27 = 0;
  }
  LODWORD(v24) = 0;
  v25 = 0;
  LODWORD(v22) = 0;
  v23 = 0;
  v12 = sub_20BE09CD4((uint64_t)&v26, a3, a4, &v24, &v22);
  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = v6;
  *(_QWORD *)(a1 + 40) = v5;
  if (v5)
  {
    v13 = (unint64_t *)&v5->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  *(_DWORD *)a1 = v12;
  v15 = v27;
  if (v27)
  {
    v16 = (unint64_t *)&v27->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v29;
  if (v29)
  {
    v19 = (unint64_t *)&v29->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  return a1;
}

void sub_20BE09CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE09CD4(uint64_t a1, uint64_t **a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  const void **v19;
  _QWORD *v20[4];
  unsigned int v21;
  uint64_t v22[4];
  std::__shared_weak_count *v23;
  int v24;
  uint64_t v25;

  v9 = *(std::__shared_weak_count **)(a1 + 8);
  v20[2] = *(_QWORD **)a1;
  v20[3] = &v9->__vftable;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v20[0] = 0;
  v20[1] = 0;
  v19 = (const void **)v20;
  v21 = 2;
  sub_20BDEBF8C(v22, &v19);
  v22[3] = 0;
  v23 = 0;
  v24 = 0;
  v25 = 1;
  sub_20BDE9D48((uint64_t)&v19, v20[0]);
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  sub_20BE02E30(a2, (uint64_t)&v21);
  sub_20BE02E30(a3, (uint64_t)&v21);
  sub_20BE02E30(a4, (uint64_t)&v21);
  sub_20BE02E30(a5, (uint64_t)&v21);
  v14 = v21;
  v15 = v23;
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  sub_20BDE9D48((uint64_t)v22, (_QWORD *)v22[1]);
  return v14;
}

void sub_20BE09E34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;
  _QWORD *v8;
  uint64_t v9;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v6 = va_arg(va2, _QWORD);
  v8 = va_arg(va2, _QWORD *);
  v9 = va_arg(va2, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  sub_20BDE9D48((uint64_t)va1, v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va2);
  _Unwind_Resume(a1);
}

void sub_20BE09FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va1);
  _Unwind_Resume(a1);
}

uint64_t *Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(uint64_t *a1, uint64_t a2, uint64_t **a3, uint64_t **a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  void (**v13)(Alembic::Abc::v12::OObject *__hidden);
  int v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4(a1 + 1, "");
  a1[4] = 0;
  a1[5] = 0;
  v14 = *(_DWORD *)(a2 + 8);
  if (*(char *)(a2 + 39) < 0)
  {
    sub_20BDDBFAC(&v15, *(void **)(a2 + 16), *(_QWORD *)(a2 + 24));
  }
  else
  {
    v15 = *(_OWORD *)(a2 + 16);
    v16 = *(_QWORD *)(a2 + 32);
  }
  v9 = *(_QWORD *)(a2 + 40);
  v8 = *(_QWORD *)(a2 + 48);
  v13 = off_24C518EC0;
  v17 = v9;
  v18 = v8;
  if (v8)
  {
    v10 = (unint64_t *)(v8 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  Alembic::Abc::v12::OCompoundProperty::init(a1, (uint64_t)&v13, a3, a4);
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)&v13);
  return a1;
}

void sub_20BE0A0B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BE032CC(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OCompoundProperty::init(uint64_t *a1, uint64_t a2, uint64_t **a3, uint64_t **a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  void *v17;
  int v18;
  __int128 v19;
  __int128 v20;
  uint64_t *v21;
  const char *v22;
  void (**v23)(Alembic::Abc::v12::OObject *__hidden);
  int v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v24 = *(_DWORD *)(a2 + 8);
  if (*(char *)(a2 + 39) < 0)
  {
    sub_20BDDBFAC(&v25, *(void **)(a2 + 16), *(_QWORD *)(a2 + 24));
  }
  else
  {
    v25 = *(_OWORD *)(a2 + 16);
    v26 = *(_QWORD *)(a2 + 32);
  }
  v9 = *(_QWORD *)(a2 + 40);
  v8 = *(_QWORD *)(a2 + 48);
  v23 = off_24C518EC0;
  v27 = v9;
  v28 = v8;
  if (v8)
  {
    v10 = (unint64_t *)(v8 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  LODWORD(v17) = 0;
  v18 = 0;
  LODWORD(v21) = 0;
  LODWORD(v22) = 0;
  *(_DWORD *)a1 = sub_20BE0AA30((uint64_t)&v23, a3, a4, (uint64_t **)&v17, &v21);
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)&v23);
  v21 = a1;
  v22 = "OCompoundProperty::init( OObject)";
  Alembic::Abc::v12::OObject::getProperties((Alembic::Abc::v12::OObject *)a2, (uint64_t)&v17);
  v20 = v19;
  if (*((_QWORD *)&v19 + 1))
  {
    v12 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  sub_20BDE82DC((uint64_t)(a1 + 4), &v20);
  v14 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
  if (*((_QWORD *)&v20 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty(&v17);
}

void sub_20BE0A234(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  void *v13;
  va_list va;

  va_start(va, a11);
  v13 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v11 + 32));
  MEMORY[0x212B929D0](v11 + 8, "");
  if (a2 == 2)
    sub_20BE02570((uint64_t)va, (uint64_t)v13);
  else
    sub_20BE02504((uint64_t)va, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0A220);
}

void sub_20BE0A290(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t *Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t **a5)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  void (**v14)(Alembic::Abc::v12::OObject *__hidden);
  int v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4(a1 + 1, "");
  a1[4] = 0;
  a1[5] = 0;
  v15 = *(_DWORD *)(a2 + 8);
  if (*(char *)(a2 + 39) < 0)
  {
    sub_20BDDBFAC(&v16, *(void **)(a2 + 16), *(_QWORD *)(a2 + 24));
  }
  else
  {
    v16 = *(_OWORD *)(a2 + 16);
    v17 = *(_QWORD *)(a2 + 32);
  }
  v10 = *(_QWORD *)(a2 + 40);
  v9 = *(_QWORD *)(a2 + 48);
  v14 = off_24C518EC0;
  v18 = v10;
  v19 = v9;
  if (v9)
  {
    v11 = (unint64_t *)(v9 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  Alembic::Abc::v12::OCompoundProperty::init(a1, (uint64_t)&v14, a4, a5);
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)&v14);
  return a1;
}

void sub_20BE0A39C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BE032CC(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty(void **this)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 4));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

uint64_t Alembic::Abc::v12::OCompoundProperty::getNumProperties(Alembic::Abc::v12::OCompoundProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
}

void sub_20BE0A43C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0A42CLL);
}

void sub_20BE0A474(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OCompoundProperty::getPropertyHeader(Alembic::Abc::v12::OCompoundProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 72))(*((_QWORD *)this + 4));
}

void sub_20BE0A4D0(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;
  unsigned __int8 v11;
  _QWORD *v12;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  v11 = atomic_load((unsigned __int8 *)&qword_254784E68);
  if ((v11 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_254784E68))
    {
      v12 = operator new(0x50uLL);
      *v12 = 0;
      v12[1] = 0;
      v12[2] = 0;
      *((_DWORD *)v12 + 6) = 1;
      v12[6] = 0;
      v12[5] = 0;
      v12[4] = v12 + 5;
      *((_DWORD *)v12 + 14) = 127;
      *((_BYTE *)v12 + 60) = 0;
      v12[8] = 0;
      v12[9] = 0;
      qword_254784E60 = (uint64_t)v12;
      __cxa_guard_release(&qword_254784E68);
    }
  }
  JUMPOUT(0x20BE0A4C0);
}

void sub_20BE0A578(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784E68);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OCompoundProperty::getPropertyHeader(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 80))(*(_QWORD *)(a1 + 32));
}

void sub_20BE0A5E8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0A5D8);
}

void sub_20BE0A620(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OCompoundProperty::getProperty(Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter **this@<X0>, uint64_t a2@<X8>)
{
  int v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter::getProperty(this[4]);
  v4 = *(_DWORD *)this;
  *(_DWORD *)a2 = 2;
  sub_20BDDC0E4((_QWORD *)(a2 + 8), "");
  *(_QWORD *)(a2 + 32) = v9;
  *(_QWORD *)(a2 + 40) = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    *(_DWORD *)a2 = v4;
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)())v10->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  else
  {
    *(_DWORD *)a2 = v4;
  }
}

void sub_20BE0A708(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;
  void *v14;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  v14 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a11, (uint64_t)v14);
  else
    sub_20BE02504((uint64_t)&a11, 0);
  __cxa_end_catch();
  *(_DWORD *)v11 = 2;
  sub_20BDDC0E4((_QWORD *)(v11 + 8), "");
  *(_QWORD *)(v11 + 32) = 0;
  *(_QWORD *)(v11 + 40) = 0;
  JUMPOUT(0x20BE0A6F4);
}

void sub_20BE0A774(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OCompoundProperty::getProperty(int *a1@<X0>, uint64_t a2@<X8>)
{
  int v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  int *v13;
  const char *v14;

  v13 = a1;
  v14 = "OCompoundProperty::getProperty( name)";
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)a1 + 4) + 88))(&v11);
  v4 = *a1;
  *(_DWORD *)a2 = 2;
  sub_20BDDC0E4((_QWORD *)(a2 + 8), "");
  v5 = v12;
  *(_QWORD *)(a2 + 32) = v11;
  *(_QWORD *)(a2 + 40) = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v8 = v12;
    *(_DWORD *)a2 = v4;
    if (v8)
    {
      v9 = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = v4;
  }
}

void sub_20BE0A864(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;
  void *v14;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  v14 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a11, (uint64_t)v14);
  else
    sub_20BE02504((uint64_t)&a11, 0);
  __cxa_end_catch();
  *(_DWORD *)v11 = 2;
  sub_20BDDC0E4((_QWORD *)(v11 + 8), "");
  *(_QWORD *)(v11 + 32) = 0;
  *(_QWORD *)(v11 + 40) = 0;
  JUMPOUT(0x20BE0A850);
}

void sub_20BE0A8D0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OCompoundProperty::getParent(Alembic::Abc::v12::OCompoundProperty *this@<X0>, uint64_t a2@<X8>)
{
  int v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t *v8;
  int v9;
  uint64_t *v10;
  int v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  Alembic::Abc::v12::OCompoundProperty *v14;
  const char *v15;

  v14 = this;
  v15 = "OCompoundProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 4) + 32))(&v12);
  v4 = *(_DWORD *)this;
  LODWORD(v10) = 1;
  v11 = v4;
  LODWORD(v8) = 0;
  v9 = 0;
  Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(a2, &v12, &v10, &v8);
  v5 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_20BE0A9A4(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  void *v9;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  v9 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)va1, (uint64_t)v9);
  else
    sub_20BE02504((uint64_t)va1, 0);
  __cxa_end_catch();
  *(_DWORD *)v6 = 2;
  sub_20BDDC0E4((_QWORD *)(v6 + 8), "");
  *(_QWORD *)(v6 + 32) = 0;
  *(_QWORD *)(v6 + 40) = 0;
  JUMPOUT(0x20BE0A990);
}

void sub_20BE0AA10(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_20BE0AA30(uint64_t a1, uint64_t **a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  unsigned int v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  const void **v15;
  _QWORD *v16[2];
  unsigned int v17;
  uint64_t v18[4];
  std::__shared_weak_count *v19;
  int v20;
  uint64_t v21;

  v9 = *(_DWORD *)(a1 + 8);
  v16[0] = 0;
  v16[1] = 0;
  v15 = (const void **)v16;
  v17 = v9;
  sub_20BDEBF8C(v18, &v15);
  v18[3] = 0;
  v19 = 0;
  v20 = 0;
  v21 = 1;
  sub_20BDE9D48((uint64_t)&v15, v16[0]);
  sub_20BE02E30(a2, (uint64_t)&v17);
  sub_20BE02E30(a3, (uint64_t)&v17);
  sub_20BE02E30(a4, (uint64_t)&v17);
  sub_20BE02E30(a5, (uint64_t)&v17);
  v10 = v17;
  v11 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  sub_20BDE9D48((uint64_t)v18, (_QWORD *)v18[1]);
  return v10;
}

void sub_20BE0AB3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, _QWORD *a13)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a10);
  sub_20BDE9D48((uint64_t)&a12, a13);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OObject::OObject(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t **a4, uint64_t **a5, uint64_t **a6)
{
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v18[2];

  *(_DWORD *)(a1 + 8) = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 16), "");
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)a1 = off_24C518EC0;
  *(_QWORD *)(a1 + 48) = 0;
  v12 = *(std::__shared_weak_count **)(a2 + 48);
  v18[0] = *(_QWORD *)(a2 + 40);
  v18[1] = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  Alembic::Abc::v12::OObject::init(a1, v18, a3, *(_DWORD *)(a2 + 8), a4, a5, a6);
  if (v12)
  {
    v15 = (unint64_t *)&v12->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return a1;
}

void sub_20BE0AC70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  void **v10;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v11;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v11);
  if (*(char *)(v9 + 39) < 0)
    operator delete(*v10);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OObject::init(uint64_t a1, _QWORD *a2, __int128 *a3, int a4, uint64_t **a5, uint64_t **a6, uint64_t **a7)
{
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  __int128 v19;
  void *__dst;
  _QWORD *v21;
  uint64_t v22;
  void *__p;
  char v24;
  _QWORD *v25[7];
  int v26;
  const void **v27[4];
  std::__shared_weak_count *v28;
  int v29;
  uint64_t v30;

  v21 = 0;
  v22 = 0;
  __dst = &v21;
  v25[5] = 0;
  v25[6] = 0;
  v26 = a4;
  sub_20BDEBF8C((uint64_t *)v27, (const void ***)&__dst);
  v27[3] = 0;
  v28 = 0;
  v29 = 0;
  v30 = 1;
  sub_20BDE9D48((uint64_t)&__dst, v21);
  sub_20BE02E30(a5, (uint64_t)&v26);
  sub_20BE02E30(a6, (uint64_t)&v26);
  sub_20BE02E30(a7, (uint64_t)&v26);
  *(_DWORD *)(a1 + 8) = v26;
  v25[3] = (_QWORD *)(a1 + 8);
  v25[4] = "OObject::init()";
  sub_20BE0C5F0(&__dst, a3, v27);
  (*(void (**)(__int128 *__return_ptr, _QWORD, void **))(*(_QWORD *)*a2 + 80))(&v19, *a2, &__dst);
  sub_20BDE82DC(a1 + 40, &v19);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
  if (*((_QWORD *)&v19 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  sub_20BDE9D48((uint64_t)v25, v25[1]);
  if (v24 < 0)
    operator delete(__p);
  if (SHIBYTE(v22) < 0)
    operator delete(__dst);
  v16 = v28;
  if (v28)
  {
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  sub_20BDE9D48((uint64_t)v27, v27[1]);
}

void sub_20BE0AE54(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  void *v8;
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  sub_20BE0C5A4((uint64_t)va);
  v8 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v5 + 40));
  MEMORY[0x212B929D0](v5 + 16, "");
  if (a2 == 2)
    sub_20BE02570((uint64_t)va1, (uint64_t)v8);
  else
    sub_20BE02504((uint64_t)va1, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0ADF4);
}

void sub_20BE0AED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  sub_20BE02EB0((uint64_t)va);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OObject::~OObject(void **this)
{
  *this = off_24C518EC0;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 5));
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
}

{
  void *v1;

  Alembic::Abc::v12::OObject::~OObject(this);
  operator delete(v1);
}

uint64_t Alembic::Abc::v12::OObject::getHeader(Alembic::Abc::v12::OObject *this)
{
  uint64_t v1;
  unsigned __int8 v3;
  _QWORD *v4;

  v1 = *((_QWORD *)this + 5);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
  v3 = atomic_load((unsigned __int8 *)&qword_254784E78);
  if ((v3 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_254784E78))
    {
      v4 = operator new(0x48uLL);
      v4[8] = 0;
      v4[7] = 0;
      *(_OWORD *)v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
      *((_OWORD *)v4 + 2) = 0u;
      v4[6] = v4 + 7;
      qword_254784E70 = (uint64_t)v4;
      __cxa_guard_release(&qword_254784E78);
    }
  }
  return qword_254784E70;
}

void sub_20BE0B058(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784E78);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OObject::getArchive(Alembic::Abc::v12::OObject *this@<X0>, uint64_t a2@<X8>)
{
  int *v3;
  uint64_t v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  char *v14;
  const char *v15;

  v3 = (int *)((char *)this + 8);
  v14 = (char *)this + 8;
  v15 = "OObject::getArchive()";
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v4 + 24))(&v12);
    v5 = *v3;
    *(_DWORD *)a2 = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 8), "");
    v6 = v13;
    *(_QWORD *)(a2 + 32) = v12;
    *(_QWORD *)(a2 + 40) = v6;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
      v9 = v13;
      *(_DWORD *)a2 = v5;
      if (v9)
      {
        v10 = (unint64_t *)&v9->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
    else
    {
      *(_DWORD *)a2 = v5;
    }
  }
  else
  {
    *(_DWORD *)a2 = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 8), "");
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
  }
}

void sub_20BE0B1CC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OObject::getParent(Alembic::Abc::v12::OObject *this@<X0>, uint64_t a2@<X8>)
{
  int *v3;
  uint64_t v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t *v9;
  int v10;
  uint64_t *v11;
  int v12;
  uint64_t *v13;
  int v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  char *v17;
  const char *v18;

  v3 = (int *)((char *)this + 8);
  v17 = (char *)this + 8;
  v18 = "OObject::getParent()";
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v4 + 32))(&v15);
    v5 = *v3;
    LODWORD(v13) = 1;
    v14 = v5;
    LODWORD(v11) = 0;
    v12 = 0;
    LODWORD(v9) = 0;
    v10 = 0;
    sub_20BE08884(a2, &v15, &v13, &v11, &v9);
    v6 = v16;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 16), "");
    *(_QWORD *)a2 = off_24C518EC0;
    *(_QWORD *)(a2 + 40) = 0;
    *(_QWORD *)(a2 + 48) = 0;
  }
}

void sub_20BE0B328(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OObject::getNumChildren(Alembic::Abc::v12::OObject *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 5);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
  else
    return 0;
}

void sub_20BE0B3C4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OObject::getChildHeader(Alembic::Abc::v12::OObject *this)
{
  uint64_t v1;
  unsigned __int8 v3;
  _QWORD *v4;

  v1 = *((_QWORD *)this + 5);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 56))(v1);
  v3 = atomic_load((unsigned __int8 *)&qword_254784E88);
  if ((v3 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_254784E88))
    {
      v4 = operator new(0x48uLL);
      v4[8] = 0;
      v4[7] = 0;
      *(_OWORD *)v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
      *((_OWORD *)v4 + 2) = 0u;
      v4[6] = v4 + 7;
      qword_254784E80 = (uint64_t)v4;
      __cxa_guard_release(&qword_254784E88);
    }
  }
  return qword_254784E80;
}

void sub_20BE0B4BC(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254784E88);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OObject::getChildHeader(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 64))(v1);
  else
    return 0;
}

void sub_20BE0B56C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OObject::getChild(Alembic::Abc::v12::OObject *this@<X0>, uint64_t a2@<X8>)
{
  int *v3;
  Alembic::AbcCoreAbstract::v12::ObjectWriter *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t *v14;
  int v15;
  uint64_t *v16;
  int v17;
  uint64_t *v18;
  int v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  char *v24;
  const char *v25;

  v3 = (int *)((char *)this + 8);
  v24 = (char *)this + 8;
  v25 = "OObject::getChild( idx)";
  v4 = (Alembic::AbcCoreAbstract::v12::ObjectWriter *)*((_QWORD *)this + 5);
  if (v4)
  {
    Alembic::AbcCoreAbstract::v12::ObjectWriter::getChild(v4);
    v20 = v22;
    v21 = v23;
    if (v23)
    {
      p_shared_owners = (unint64_t *)&v23->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    v7 = *v3;
    LODWORD(v18) = 1;
    v19 = v7;
    LODWORD(v16) = 0;
    v17 = 0;
    LODWORD(v14) = 0;
    v15 = 0;
    sub_20BE08884(a2, &v20, &v18, &v16, &v14);
    v8 = v21;
    if (v21)
    {
      v9 = (unint64_t *)&v21->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v11 = v23;
    if (v23)
    {
      v12 = (unint64_t *)&v23->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 16), "");
    *(_QWORD *)a2 = off_24C518EC0;
    *(_QWORD *)(a2 + 40) = 0;
    *(_QWORD *)(a2 + 48) = 0;
  }
}

void sub_20BE0B720(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OObject::getChild(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int *v3;
  uint64_t v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t *v9;
  int v10;
  uint64_t *v11;
  int v12;
  uint64_t *v13;
  int v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  const char *v18;

  v3 = (int *)(a1 + 8);
  v17 = a1 + 8;
  v18 = "OObject::getChild( name)";
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v4 + 72))(&v15);
    v5 = *v3;
    LODWORD(v13) = 1;
    v14 = v5;
    LODWORD(v11) = 0;
    v12 = 0;
    LODWORD(v9) = 0;
    v10 = 0;
    sub_20BE08884(a2, &v15, &v13, &v11, &v9);
    v6 = v16;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 16), "");
    *(_QWORD *)a2 = off_24C518EC0;
    *(_QWORD *)(a2 + 40) = 0;
    *(_QWORD *)(a2 + 48) = 0;
  }
}

void sub_20BE0B87C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OObject::getProperties(Alembic::Abc::v12::OObject *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _DWORD v7[4];
  _DWORD v8[4];
  uint64_t v9;
  std::__shared_weak_count *v10;
  char *v11;
  const char *v12;

  v11 = (char *)this + 8;
  v12 = "OObject::getProperties()";
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v3 + 40))(&v9);
    v8[0] = 0;
    v8[2] = 0;
    v7[0] = 0;
    v7[2] = 0;
    Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(a2, &v9, 0, v8, v7);
    v4 = v10;
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = 2;
    sub_20BDDC0E4((_QWORD *)(a2 + 8), "");
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
  }
}

void sub_20BE0B9BC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OObject::addChildInstance(Alembic::Abc::v12::OObject *this, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned __int8 *v10;
  uint64_t v11;
  unsigned __int8 *p_dst;
  int v13;
  int v14;
  int v15;
  BOOL v16;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  uint64_t Header;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  std::string *v26;
  const void *v27;
  int v28;
  const std::string::value_type *v29;
  std::string::size_type v30;
  std::string *v31;
  __int128 v32;
  size_t v33;
  void **v34;
  __int128 *v35;
  uint64_t v36;
  char *v37;
  void **v38;
  int64_t v39;
  char *v40;
  int v41;
  char *v42;
  uint64_t v43;
  char *v44;
  char *v45;
  uint64_t *v46;
  int v47;
  uint64_t *v48;
  int v49;
  void *__p;
  int v51;
  char v52;
  int v53[12];
  uint64_t *v54;
  int v55;
  void *v56[7];
  std::string v57;
  uint64_t *v58;
  _QWORD *v59[4];
  void *v60[2];
  unsigned __int8 v61;
  std::string v62[2];
  __int128 v63;
  int64_t v64;
  __int128 __dst;
  uint64_t v66;

  if (*(char *)(a2 + 39) < 0)
  {
    if (!*(_QWORD *)(a2 + 24))
      goto LABEL_5;
    return 0;
  }
  if (*(_BYTE *)(a2 + 39))
    return 0;
LABEL_5:
  if (!*(_QWORD *)(a2 + 40) || !*((_QWORD *)this + 5))
    return 0;
  v6 = *(unsigned __int8 *)(a3 + 23);
  if ((v6 & 0x80u) != 0)
    v6 = *(_QWORD *)(a3 + 8);
  if (!v6)
    return 0;
  Alembic::Abc::v12::OObject::getArchive(this, (uint64_t)&v57);
  Alembic::Abc::v12::OArchive::getName((Alembic::Abc::v12::OArchive *)&v57, (uint64_t)&__dst);
  Alembic::Abc::v12::OObject::getArchive((Alembic::Abc::v12::OObject *)a2, (uint64_t)v62);
  Alembic::Abc::v12::OArchive::getName((Alembic::Abc::v12::OArchive *)v62, (uint64_t)&v63);
  if (v66 >= 0)
    v7 = HIBYTE(v66);
  else
    v7 = *((_QWORD *)&__dst + 1);
  v8 = HIBYTE(v64);
  v9 = SHIBYTE(v64);
  if (v64 < 0)
    v8 = *((_QWORD *)&v63 + 1);
  if (v7 == v8)
  {
    if (v64 >= 0)
      v10 = (unsigned __int8 *)&v63;
    else
      v10 = (unsigned __int8 *)v63;
    if (v66 < 0)
    {
      v16 = memcmp((const void *)__dst, v10, *((size_t *)&__dst + 1)) != 0;
    }
    else if (HIBYTE(v66))
    {
      v11 = HIBYTE(v66) - 1;
      p_dst = (unsigned __int8 *)&__dst;
      do
      {
        v14 = *p_dst++;
        v13 = v14;
        v15 = *v10++;
        v16 = v13 != v15;
      }
      while (v13 == v15 && v11-- != 0);
    }
    else
    {
      v16 = 0;
    }
  }
  else
  {
    v16 = 1;
  }
  if (v9 < 0)
    operator delete((void *)v63);
  Alembic::Abc::v12::OArchive::~OArchive((Alembic::Abc::v12::OArchive *)v62);
  if (SHIBYTE(v66) < 0)
    operator delete((void *)__dst);
  Alembic::Abc::v12::OArchive::~OArchive((Alembic::Abc::v12::OArchive *)&v57);
  if (v16)
    return 0;
  v18 = Alembic::Abc::v12::OObject::getHeader((Alembic::Abc::v12::OObject *)a2) + 48;
  sub_20BDDC0E4(v62, "isInstance");
  sub_20BE01E1C(v18, (const void **)&v62[0].__r_.__value_.__l.__data_, &v57);
  if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
  {
    v19 = v57.__r_.__value_.__l.__size_ == 1 && *v57.__r_.__value_.__l.__data_ == 49;
    operator delete(v57.__r_.__value_.__l.__data_);
  }
  else
  {
    v19 = SHIBYTE(v57.__r_.__value_.__r.__words[2]) == 1 && v57.__r_.__value_.__s.__data_[0] == 49;
  }
  if (SHIBYTE(v62[0].__r_.__value_.__r.__words[2]) < 0)
    operator delete(v62[0].__r_.__value_.__l.__data_);
  if (v19)
    return 0;
  Header = Alembic::Abc::v12::OObject::getHeader((Alembic::Abc::v12::OObject *)a2);
  if (*(char *)(Header + 47) < 0)
  {
    sub_20BDDBFAC(&__dst, *(void **)(Header + 24), *(_QWORD *)(Header + 32));
  }
  else
  {
    __dst = *(_OWORD *)(Header + 24);
    v66 = *(_QWORD *)(Header + 40);
  }
  v23 = Alembic::Abc::v12::OObject::getHeader(this);
  v24 = v23;
  if (*(char *)(v23 + 47) >= 0)
    v25 = *(unsigned __int8 *)(v23 + 47);
  else
    v25 = *(_QWORD *)(v23 + 32);
  v26 = &v57;
  sub_20BDF6BDC((uint64_t)&v57, v25 + 1);
  if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v26 = (std::string *)v57.__r_.__value_.__r.__words[0];
  if (v25)
  {
    if (*(char *)(v24 + 47) >= 0)
      v27 = (const void *)(v24 + 24);
    else
      v27 = *(const void **)(v24 + 24);
    memmove(v26, v27, v25);
  }
  *(_WORD *)((char *)&v26->__r_.__value_.__l.__data_ + v25) = 47;
  v28 = *(char *)(a3 + 23);
  if (v28 >= 0)
    v29 = (const std::string::value_type *)a3;
  else
    v29 = *(const std::string::value_type **)a3;
  if (v28 >= 0)
    v30 = *(unsigned __int8 *)(a3 + 23);
  else
    v30 = *(_QWORD *)(a3 + 8);
  v31 = std::string::append(&v57, v29, v30);
  v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v64 = v31->__r_.__value_.__r.__words[2];
  v63 = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v57.__r_.__value_.__l.__data_);
  if (v66 >= 0)
    v33 = HIBYTE(v66);
  else
    v33 = *((_QWORD *)&__dst + 1);
  v34 = v60;
  sub_20BDF6BDC((uint64_t)v60, v33 + 1);
  if ((v61 & 0x80u) != 0)
    v34 = (void **)v60[0];
  if (v33)
  {
    if (v66 >= 0)
      v35 = &__dst;
    else
      v35 = (__int128 *)__dst;
    memmove(v34, v35, v33);
  }
  *(_WORD *)((char *)v34 + v33) = 47;
  v36 = HIBYTE(v64);
  if (v64 >= 0)
    v37 = (char *)&v63;
  else
    v37 = (char *)v63;
  if ((v61 & 0x80u) == 0)
    v38 = v60;
  else
    v38 = (void **)v60[0];
  if ((v61 & 0x80u) == 0)
    v39 = v61;
  else
    v39 = (int64_t)v60[1];
  if (v39)
  {
    if (v64 < 0)
      v36 = *((_QWORD *)&v63 + 1);
    if (v36 >= v39)
    {
      v40 = &v37[v36];
      v41 = *(char *)v38;
      v42 = v37;
      do
      {
        v43 = v36 - v39;
        if (v43 == -1)
          break;
        v44 = (char *)memchr(v42, v41, v43 + 1);
        if (!v44)
          break;
        v45 = v44;
        if (!memcmp(v44, v38, v39))
        {
          if (v45 == v40 || v45 != v37)
            break;
          goto LABEL_108;
        }
        v42 = v45 + 1;
        v36 = v40 - (v45 + 1);
      }
      while (v36 >= v39);
    }
    v59[2] = (_QWORD *)((char *)this + 8);
    v59[3] = "OObject::addChildInstance()";
    v59[0] = 0;
    v59[1] = 0;
    v58 = (uint64_t *)v59;
    sub_20BDDC0E4(&v57, "isInstance");
    sub_20BDDC0E4(v62, "1");
    sub_20BE0C138(&v58, (__int128 *)&v57, v62);
    if (SHIBYTE(v62[0].__r_.__value_.__r.__words[2]) < 0)
      operator delete(v62[0].__r_.__value_.__l.__data_);
    if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v57.__r_.__value_.__l.__data_);
    sub_20BE0C180((uint64_t)v56, (uint64_t)this);
    LODWORD(v62[0].__r_.__value_.__l.__data_) = 3;
    v62[0].__r_.__value_.__l.__size_ = (std::string::size_type)&v58;
    LODWORD(__p) = 0;
    v51 = 0;
    LODWORD(v54) = 0;
    v55 = 0;
    Alembic::Abc::v12::OObject::OObject((uint64_t)&v57, (uint64_t)v56, (__int128 *)a3, (uint64_t **)v62, (uint64_t **)&__p, &v54);
    Alembic::Abc::v12::OObject::~OObject(v56);
    Alembic::Abc::v12::OObject::getProperties((Alembic::Abc::v12::OObject *)&v57, (uint64_t)v53);
    sub_20BDDC0E4(&__p, ".instanceSource");
    LODWORD(v54) = 0;
    v55 = 0;
    LODWORD(v48) = 0;
    v49 = 0;
    LODWORD(v46) = 0;
    v47 = 0;
    sub_20BE0C69C((uint64_t)v62, v53, (uint64_t)&__p, &v54, &v48, &v46);
    if (v52 < 0)
      operator delete(__p);
    Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v53);
    Alembic::Abc::v12::OScalarProperty::set((Alembic::Abc::v12::OScalarProperty *)v62, &__dst);
    Alembic::Abc::v12::OScalarProperty::~OScalarProperty((void **)&v62[0].__r_.__value_.__l.__data_);
    Alembic::Abc::v12::OObject::~OObject((void **)&v57.__r_.__value_.__l.__data_);
    sub_20BDE9D48((uint64_t)&v58, v59[0]);
    v20 = 1;
  }
  else
  {
LABEL_108:
    v20 = 0;
  }
  if ((char)v61 < 0)
    operator delete(v60[0]);
  if (SHIBYTE(v64) < 0)
    operator delete((void *)v63);
  if (SHIBYTE(v66) < 0)
    operator delete((void *)__dst);
  return v20;
}

void sub_20BE0BF7C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,_QWORD *a46)
{
  uint64_t v46;
  void *v49;

  Alembic::Abc::v12::OScalarProperty::~OScalarProperty((void **)(v46 - 192));
  Alembic::Abc::v12::OObject::~OObject(&a35);
  sub_20BDE9D48((uint64_t)&a45, a46);
  v49 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570(v46 - 232, (uint64_t)v49);
  else
    sub_20BE02504(v46 - 232, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0BF44);
}

void sub_20BE0C06C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  uint64_t v37;

  if (*(char *)(v37 - 193) < 0)
    operator delete(*(void **)(v37 - 216));
  if (*(char *)(v37 - 121) < 0)
    operator delete(*(void **)(v37 - 144));
  if (*(char *)(v37 - 89) < 0)
    operator delete(*(void **)(v37 - 112));
  _Unwind_Resume(exception_object);
}

std::string *sub_20BE0C138(uint64_t **a1, __int128 *a2, const std::string *a3)
{
  uint64_t *v4;
  __int128 *v6;

  v6 = a2;
  v4 = sub_20BDDDFDC(a1, (const void **)a2, (uint64_t)&unk_20CA51B34, &v6);
  return std::string::operator=((std::string *)(v4 + 7), a3);
}

uint64_t sub_20BE0C180(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  v4 = a1 + 16;
  if (*(char *)(a2 + 39) < 0)
  {
    sub_20BDDBFAC((_BYTE *)v4, *(void **)(a2 + 16), *(_QWORD *)(a2 + 24));
  }
  else
  {
    v5 = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(v4 + 16) = *(_QWORD *)(a2 + 32);
    *(_OWORD *)v4 = v5;
  }
  *(_QWORD *)a1 = off_24C518EC0;
  v6 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  return a1;
}

void Alembic::Abc::v12::OObject::init(uint64_t a1, uint64_t a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  __int128 v23;
  uint64_t *v24;
  const char *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;

  v7 = *(std::__shared_weak_count **)(a2 + 40);
  v26 = *(_QWORD *)(a2 + 32);
  v27 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  LODWORD(v24) = 0;
  LODWORD(v25) = 0;
  *(_DWORD *)(a1 + 8) = sub_20BE0C40C((uint64_t)&v26, a3, a4, a5, &v24);
  v10 = v27;
  if (v27)
  {
    v11 = (unint64_t *)&v27->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v24 = (uint64_t *)(a1 + 8);
  v25 = "OObject::init( OArchive)";
  v13 = *(_QWORD *)(a2 + 32);
  v14 = *(std::__shared_weak_count **)(a2 + 40);
  v22 = v14;
  if (v14)
  {
    v15 = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v13 + 32))(&v23);
  sub_20BDE82DC(a1 + 40, &v23);
  v17 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
  if (*((_QWORD *)&v23 + 1))
  {
    v18 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  if (v22)
  {
    v20 = (unint64_t *)&v22->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
}

void sub_20BE0C370(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;
  void *v16;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  v16 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v13 + 40));
  MEMORY[0x212B929D0](v13 + 16, "");
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a13, (uint64_t)v16);
  else
    sub_20BE02504((uint64_t)&a13, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0C35CLL);
}

void sub_20BE0C3DC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_20BE0C40C(uint64_t a1, uint64_t **a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  const void **v19;
  _QWORD *v20[4];
  unsigned int v21;
  uint64_t v22[4];
  std::__shared_weak_count *v23;
  int v24;
  uint64_t v25;

  v9 = *(std::__shared_weak_count **)(a1 + 8);
  v20[2] = *(_QWORD **)a1;
  v20[3] = &v9->__vftable;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v20[0] = 0;
  v20[1] = 0;
  v19 = (const void **)v20;
  v21 = 2;
  sub_20BDEBF8C(v22, &v19);
  v22[3] = 0;
  v23 = 0;
  v24 = 0;
  v25 = 1;
  sub_20BDE9D48((uint64_t)&v19, v20[0]);
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  sub_20BE02E30(a2, (uint64_t)&v21);
  sub_20BE02E30(a3, (uint64_t)&v21);
  sub_20BE02E30(a4, (uint64_t)&v21);
  sub_20BE02E30(a5, (uint64_t)&v21);
  v14 = v21;
  v15 = v23;
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  sub_20BDE9D48((uint64_t)v22, (_QWORD *)v22[1]);
  return v14;
}

void sub_20BE0C56C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;
  _QWORD *v8;
  uint64_t v9;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v6 = va_arg(va2, _QWORD);
  v8 = va_arg(va2, _QWORD *);
  v9 = va_arg(va2, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  sub_20BDE9D48((uint64_t)va1, v8);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE0C5A4(uint64_t a1)
{
  sub_20BDE9D48(a1 + 48, *(_QWORD **)(a1 + 56));
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *sub_20BE0C5F0(_QWORD *__dst, __int128 *a2, const void ***a3)
{
  __int128 v5;

  if (*((char *)a2 + 23) < 0)
  {
    sub_20BDDBFAC(__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    __dst[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)__dst = v5;
  }
  sub_20BDDC0E4(__dst + 3, "");
  sub_20BDEBF8C(__dst + 6, a3);
  return __dst;
}

void sub_20BE0C668(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BE0C69C(uint64_t a1, int *a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t **a6)
{
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  int v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t *v20;
  int v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v12 = (std::__shared_weak_count *)*((_QWORD *)a2 + 5);
  v22 = *((_QWORD *)a2 + 4);
  v23 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v15 = *a2;
  LODWORD(v20) = 1;
  v21 = v15;
  sub_20BE0C7A4((int *)a1, &v22, a3, &v20, a4, a5, a6);
  v16 = v23;
  if (v23)
  {
    v17 = (unint64_t *)&v23->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  return a1;
}

void sub_20BE0C788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void **v3;
  va_list va;

  va_start(va, a3);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  Alembic::Abc::v12::OScalarProperty::~OScalarProperty(v3);
  _Unwind_Resume(a1);
}

void sub_20BE0C7A4(int *a1, uint64_t *a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t **a6, uint64_t **a7)
{
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  _QWORD *exception;
  _QWORD *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  void *__p[2];
  char v39;
  uint64_t v40;
  std::__shared_weak_count *v41;
  const void **v42;
  _QWORD *v43;
  _QWORD v44[37];
  int v45;
  const void **v46[3];
  uint64_t v47;
  std::__shared_weak_count *v48;
  unsigned int v49;
  uint64_t v50;

  v43 = 0;
  v44[0] = 0;
  v42 = (const void **)&v43;
  v44[35] = 0;
  v44[36] = 0;
  v45 = 2;
  sub_20BDEBF8C((uint64_t *)v46, &v42);
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 1;
  sub_20BDE9D48((uint64_t)&v42, v43);
  sub_20BE02E30(a4, (uint64_t)&v45);
  sub_20BE02E30(a5, (uint64_t)&v45);
  sub_20BE02E30(a6, (uint64_t)&v45);
  sub_20BE02E30(a7, (uint64_t)&v45);
  *a1 = v45;
  v44[33] = a1;
  v44[34] = "OTypedScalarProperty::init()";
  if (!*a2)
  {
    sub_20BDDBD68((uint64_t)&v42);
    sub_20BDDC1C8(v44, (uint64_t)"NULL CompoundPropertyWriterPtr", 30);
    std::stringbuf::str();
    sub_20BDDBF20(&v40, (__int128 *)__p);
    if (v39 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v35 = sub_20BDDC09C(exception, (uint64_t)&v40);
    __cxa_throw(v35, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDEBF8C((uint64_t *)&v42, v46);
  v14 = v47;
  v40 = v47;
  v41 = v48;
  if (v48)
  {
    p_shared_owners = (unint64_t *)&v48->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  v17 = *a2;
  if (v14)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v17 + 24))(&v36);
    (*(void (**)(void **__return_ptr))(*(_QWORD *)v36 + 24))(__p);
    v18 = (*(uint64_t (**)(void *, uint64_t))(*(_QWORD *)__p[0] + 48))(__p[0], v14);
    v19 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v20 = (unint64_t *)((char *)__p[1] + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v22 = v37;
    if (v37)
    {
      v23 = (unint64_t *)&v37->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    v17 = *a2;
  }
  else
  {
    v18 = v49;
  }
  v36 = 0x10000000CLL;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const void ***, uint64_t *, uint64_t))(*(_QWORD *)v17 + 96))(__p, v17, a3, &v42, &v36, v18);
  sub_20BDE82DC((uint64_t)(a1 + 8), (__int128 *)__p);
  v25 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v26 = (unint64_t *)((char *)__p[1] + 8);
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v41;
  if (v41)
  {
    v29 = (unint64_t *)&v41->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  sub_20BDE9D48((uint64_t)&v42, v43);
  v31 = v48;
  if (v48)
  {
    v32 = (unint64_t *)&v48->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  sub_20BDE9D48((uint64_t)v46, v46[1]);
}

void sub_20BE0CAF4(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  uint64_t v8;
  void *v11;
  std::exception v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  v11 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v7 + 32));
  MEMORY[0x212B929D0](v7 + 8, "");
  if (a2 == 2)
    sub_20BE02570(v8 - 176, (uint64_t)v11);
  else
    sub_20BE02504(v8 - 176, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0CA1CLL);
}

void sub_20BE0CBD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_20BE02EB0(v1 - 144);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OScalarProperty::OScalarProperty(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t **a5, uint64_t **a6, uint64_t **a7, uint64_t **a8)
{
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD v23[2];

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v16 = *a2;
  v17 = (std::__shared_weak_count *)a2[1];
  v23[0] = v16;
  v23[1] = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldxr(p_shared_owners);
    while (__stxr(v19 + 1, p_shared_owners));
  }
  Alembic::Abc::v12::OScalarProperty::init((const void **)a1, v23, a3, a4, a5, a6, a7, a8);
  if (v17)
  {
    v20 = (unint64_t *)&v17->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  return a1;
}

void sub_20BE0CD18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  sub_20BE032CC(v9);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OScalarProperty::init(const void **a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t **a5, uint64_t **a6, uint64_t **a7, uint64_t **a8)
{
  uint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  __int128 v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  uint64_t v40;
  uint64_t v41;
  const void **v42;
  _QWORD *v43[2];
  int v44;
  uint64_t v45[3];
  uint64_t v46;
  std::__shared_weak_count *v47;
  unsigned int v48;
  uint64_t v49;

  v43[0] = 0;
  v43[1] = 0;
  v41 = 0;
  v42 = (const void **)v43;
  v40 = 0;
  v44 = 2;
  sub_20BDEBF8C(v45, &v42);
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 1;
  sub_20BDE9D48((uint64_t)&v42, v43[0]);
  sub_20BE02E30(a5, (uint64_t)&v44);
  sub_20BE02E30(a6, (uint64_t)&v44);
  sub_20BE02E30(a7, (uint64_t)&v44);
  sub_20BE02E30(a8, (uint64_t)&v44);
  *(_DWORD *)a1 = v44;
  v42 = a1;
  v43[0] = "OScalarProperty::init(p, n)";
  v16 = v46;
  v38 = v46;
  v39 = v47;
  if (v47)
  {
    p_shared_owners = (unint64_t *)&v47->__shared_owners_;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
  }
  if (v16)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)*a2 + 24))(&v35);
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v35 + 24))(&v37);
    v19 = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v37 + 48))(v37, v16);
    v20 = (std::__shared_weak_count *)*((_QWORD *)&v37 + 1);
    if (*((_QWORD *)&v37 + 1))
    {
      v21 = (unint64_t *)(*((_QWORD *)&v37 + 1) + 8);
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = v36;
    if (v36)
    {
      v24 = (unint64_t *)&v36->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
  }
  else
  {
    v19 = v48;
  }
  (*(void (**)(__int128 *__return_ptr, _QWORD, uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)*a2 + 96))(&v37, *a2, a3, v45, a4, v19);
  sub_20BDE82DC((uint64_t)(a1 + 4), &v37);
  v26 = (std::__shared_weak_count *)*((_QWORD *)&v37 + 1);
  if (*((_QWORD *)&v37 + 1))
  {
    v27 = (unint64_t *)(*((_QWORD *)&v37 + 1) + 8);
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = v39;
  if (v39)
  {
    v30 = (unint64_t *)&v39->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v47;
  if (v47)
  {
    v33 = (unint64_t *)&v47->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  sub_20BDE9D48((uint64_t)v45, (_QWORD *)v45[1]);
}

void sub_20BE0CFE8(void *a1, int a2, uint64_t a3, ...)
{
  uint64_t v3;
  void *v6;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  va_list va1;
  uint64_t v12;
  uint64_t v13;
  va_list va2;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va3;

  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v10 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v13 = va_arg(va3, _QWORD);
  v15 = va_arg(va3, _QWORD);
  v16 = va_arg(va3, _QWORD);
  v17 = va_arg(va3, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va1);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va2);
  v6 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v3 + 32));
  MEMORY[0x212B929D0](v3 + 8, "");
  if (a2 == 2)
    sub_20BE02570((uint64_t)va3, (uint64_t)v6);
  else
    sub_20BE02504((uint64_t)va3, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0CF84);
}

void sub_20BE0D084(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  sub_20BE02EB0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OScalarProperty::OScalarProperty(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t **a5, uint64_t **a6, uint64_t **a7)
{
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  int v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t *v21;
  int v22;
  _QWORD v23[2];

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v14 = (std::__shared_weak_count *)*((_QWORD *)a2 + 5);
  v23[0] = *((_QWORD *)a2 + 4);
  v23[1] = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  v17 = *a2;
  LODWORD(v21) = 1;
  v22 = v17;
  Alembic::Abc::v12::OScalarProperty::init((const void **)a1, v23, a3, a4, &v21, a5, a6, a7);
  if (v14)
  {
    v18 = (unint64_t *)&v14->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  return a1;
}

void sub_20BE0D1D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  sub_20BE032CC(v3);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OScalarProperty::~OScalarProperty(void **this)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(this + 4));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

uint64_t Alembic::Abc::v12::OScalarProperty::getNumSamples(Alembic::Abc::v12::OScalarProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 80))(*((_QWORD *)this + 4));
}

void sub_20BE0D26C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0D25CLL);
}

void sub_20BE0D2A4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OScalarProperty::set(Alembic::Abc::v12::OScalarProperty *this, const void *a2)
{
  return (*(uint64_t (**)(_QWORD, const void *))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4), a2);
}

void sub_20BE0D300(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0D2F0);
}

void sub_20BE0D334(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OScalarProperty::setFromPrevious(Alembic::Abc::v12::OScalarProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 72))(*((_QWORD *)this + 4));
}

void sub_20BE0D390(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0D380);
}

void sub_20BE0D3C4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OScalarProperty::setTimeSampling(Alembic::Abc::v12::OScalarProperty *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 88))(*((_QWORD *)this + 4));
}

void sub_20BE0D420(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;

  v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a9, (uint64_t)v10);
  else
    sub_20BE02504((uint64_t)&a9, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0D410);
}

void sub_20BE0D454(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OScalarProperty::setTimeSampling(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  const char *v22;

  v21 = a1;
  v22 = "OScalarProperty::setTimeSampling()";
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a1 + 32) + 32))(&v15);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v15 + 24))(&v17);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v17 + 24))(&v19);
  v4 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 48))(v19, *a2);
  v5 = v20;
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = v18;
  if (v18)
  {
    v9 = (unint64_t *)&v18->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v16;
  if (v16)
  {
    v12 = (unint64_t *)&v16->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 32) + 88))(*(_QWORD *)(a1 + 32), v4);
}

void sub_20BE0D5C0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15)
{
  void *v16;

  v16 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a15, (uint64_t)v16);
  else
    sub_20BE02504((uint64_t)&a15, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0D5ACLL);
}

void sub_20BE0D63C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OScalarProperty::getParent(Alembic::Abc::v12::OScalarProperty *this@<X0>, uint64_t a2@<X8>)
{
  int v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  _DWORD v8[4];
  _DWORD v9[4];
  uint64_t v10;
  std::__shared_weak_count *v11;
  Alembic::Abc::v12::OScalarProperty *v12;
  const char *v13;

  v12 = this;
  v13 = "OScalarProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 4) + 32))(&v10);
  v4 = *(_DWORD *)this;
  v9[0] = 1;
  v9[2] = v4;
  v8[0] = 0;
  v8[2] = 0;
  Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(a2, &v10, v9, v8);
  v5 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_20BE0D710(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  void *v9;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  v9 = __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE02570((uint64_t)va1, (uint64_t)v9);
  else
    sub_20BE02504((uint64_t)va1, 0);
  __cxa_end_catch();
  *(_DWORD *)v6 = 2;
  sub_20BDDC0E4((_QWORD *)(v6 + 8), "");
  *(_QWORD *)(v6 + 32) = 0;
  *(_QWORD *)(v6 + 40) = 0;
  JUMPOUT(0x20BE0D6FCLL);
}

void sub_20BE0D77C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::SetReference(uint64_t **a1)
{
  uint64_t *v2;
  std::string __p;
  void *v4[2];
  char v5;
  void **v6;

  sub_20BDDC0E4(v4, "reference");
  sub_20BDDC0E4(&__p, "1");
  v6 = v4;
  v2 = sub_20BDDDFDC(a1, (const void **)v4, (uint64_t)&unk_20CA51B35, (__int128 **)&v6);
  std::string::operator=((std::string *)(v2 + 7), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v5 < 0)
    operator delete(v4[0]);
}

void sub_20BE0D830(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL Alembic::Abc::v12::isReference(uint64_t a1)
{
  uint64_t v1;
  _BOOL8 v2;
  void *__p[2];
  char v5;
  void *v6[2];
  char v7;

  v1 = a1 + 32;
  sub_20BDDC0E4(__p, "reference");
  sub_20BE01E1C(v1, (const void **)__p, v6);
  if (v7 < 0)
  {
    v2 = v6[1] == (void *)1 && *(_BYTE *)v6[0] == 49;
    operator delete(v6[0]);
  }
  else
  {
    v2 = v7 == 1 && LOBYTE(v6[0]) == 49;
  }
  if (v5 < 0)
    operator delete(__p[0]);
  return v2;
}

void sub_20BE0D908(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Alembic::Abc::v12::SetSourceName(uint64_t **a1, const std::string *a2)
{
  uint64_t *v4;
  void *__p[2];
  char v6;
  void **v7;

  sub_20BDDC0E4(__p, "sourceName");
  v7 = __p;
  v4 = sub_20BDDDFDC(a1, (const void **)__p, (uint64_t)&unk_20CA51B36, (__int128 **)&v7);
  std::string::operator=((std::string *)(v4 + 7), a2);
  if (v6 < 0)
    operator delete(__p[0]);
}

void sub_20BE0D9A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Alembic::Abc::v12::GetSourceName(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  void *__p[2];
  char v5;

  sub_20BDDC0E4(__p, "sourceName");
  sub_20BE01E1C(a1, (const void **)__p, a2);
  if (v5 < 0)
    operator delete(__p[0]);
}

void sub_20BE0DA18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::AbcCoreFactory::v12::IFactory::IFactory(uint64_t this)
{
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_BYTE *)this = 1;
  *(_QWORD *)(this + 8) = 1;
  *(_DWORD *)(this + 16) = 1;
  *(_DWORD *)(this + 40) = 2;
  return this;
}

{
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_BYTE *)this = 1;
  *(_QWORD *)(this + 8) = 1;
  *(_DWORD *)(this + 16) = 1;
  *(_DWORD *)(this + 40) = 2;
  return this;
}

void Alembic::AbcCoreFactory::v12::IFactory::~IFactory(Alembic::AbcCoreFactory::v12::IFactory *this)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((Alembic::AbcCoreFactory::v12::IFactory *)((char *)this + 24));
}

{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((Alembic::AbcCoreFactory::v12::IFactory *)((char *)this + 24));
}

void Alembic::AbcCoreFactory::v12::IFactory::getArchive(uint64_t a1@<X0>, __int128 *a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  char v21;
  void *__p;
  void *v23;
  uint64_t v24;
  int v25;
  void *__src[2];
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  void *v32;
  _BYTE *v33;

  Alembic::AbcCoreOgawa::v12::ReadArchive::ReadArchive((uint64_t)&v30, *(_QWORD *)(a1 + 8), *(_DWORD *)(a1 + 16) == 1);
  v20 = v30;
  v21 = v31;
  v23 = 0;
  v24 = 0;
  __p = 0;
  sub_20BDFD340(&__p, v32, (uint64_t)v33, (v33 - (_BYTE *)v32) >> 3);
  v8 = *(std::__shared_weak_count **)(a1 + 32);
  v18 = *(_QWORD *)(a1 + 24);
  v19 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  sub_20BE0E38C((uint64_t)&v25, (uint64_t)&v20, a2, 0, (uint64_t)&v18);
  v11 = v19;
  if (v19)
  {
    v12 = (unint64_t *)&v19->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  if (__p)
  {
    v23 = __p;
    operator delete(__p);
  }
  if ((SHIBYTE(v27) & 0x80000000) == 0)
  {
    if (!HIBYTE(v27))
    {
      v14 = v28;
      if (v28)
      {
        *a3 = 1;
        v25 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)a4 = v25;
        *(_OWORD *)(a4 + 8) = *(_OWORD *)__src;
        *(_QWORD *)(a4 + 24) = v27;
        goto LABEL_18;
      }
    }
LABEL_22:
    *a3 = 3;
    *(_DWORD *)a4 = 2;
    sub_20BDDC0E4((_QWORD *)(a4 + 8), "");
    *(_QWORD *)(a4 + 32) = 0;
    *(_QWORD *)(a4 + 40) = 0;
    goto LABEL_23;
  }
  if (__src[1] || !v28)
    goto LABEL_22;
  *a3 = 1;
  v25 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)a4 = v25;
  sub_20BDDBFAC((_BYTE *)(a4 + 8), __src[0], 0);
  v14 = v28;
LABEL_18:
  v15 = v29;
  *(_QWORD *)(a4 + 32) = v14;
  *(_QWORD *)(a4 + 40) = v15;
  if (v15)
  {
    v16 = (unint64_t *)(v15 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
LABEL_23:
  Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)&v25);
  if (v32)
  {
    v33 = v32;
    operator delete(v32);
  }
}

void sub_20BE0DC98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  uint64_t v16;
  void *v18;

  Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)&a16);
  v18 = *(void **)(v16 - 56);
  if (v18)
  {
    *(_QWORD *)(v16 - 48) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

void Alembic::AbcCoreFactory::v12::IFactory::getArchive(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  int v3;

  Alembic::AbcCoreFactory::v12::IFactory::getArchive(a1, a2, &v3, a3);
}

void Alembic::AbcCoreFactory::v12::IFactory::getArchive(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v3;

  Alembic::AbcCoreFactory::v12::IFactory::getArchive(a1, a2, &v3, a3);
}

void Alembic::AbcCoreFactory::v12::IFactory::getArchive(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  _QWORD *v26;
  _QWORD *v27;
  char *v28;
  __int128 v29;
  int64x2_t v30;
  char *v31;
  uint64_t *v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  int v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  __int128 v42;
  unint64_t *v43;
  unint64_t v44;
  int v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  _DWORD *v52;
  _OWORD v53[2];
  uint64_t v54;
  std::__shared_weak_count *v55;
  int v56;
  int64x2_t v57;
  char *v58;
  char v59;
  uint64_t v60;
  int64x2_t v61;
  char *v62;
  char **v63;

  Alembic::AbcCoreLayer::v12::ReadArchive::ReadArchive((Alembic::AbcCoreLayer::v12::ReadArchive *)&v59);
  v57 = 0uLL;
  v58 = 0;
  v8 = *(__int128 **)a2;
  if (*(_QWORD *)a2 == *(_QWORD *)(a2 + 8))
    goto LABEL_54;
  v52 = a3;
  v56 = 0;
  do
  {
    Alembic::AbcCoreFactory::v12::IFactory::getArchive(a1, v8, &v56, (uint64_t)v53);
    v10 = v54;
    v9 = v55;
    if (v55)
    {
      p_shared_owners = (unint64_t *)&v55->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (v13)
      {
        if (!v10)
          goto LABEL_31;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
        if (!v10)
          goto LABEL_31;
      }
      v10 = v54;
      v14 = v55;
      if (v55)
      {
        v15 = (unint64_t *)&v55->__shared_owners_;
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
    }
    else
    {
      if (!v54)
        goto LABEL_31;
      v14 = 0;
    }
    v17 = v57.i64[1];
    if (v57.i64[1] >= (unint64_t)v58)
    {
      v19 = (v57.i64[1] - v57.i64[0]) >> 4;
      v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 60)
        sub_20BDDF694();
      v21 = (uint64_t)&v58[-v57.i64[0]];
      if ((uint64_t)&v58[-v57.i64[0]] >> 3 > v20)
        v20 = v21 >> 3;
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0)
        v22 = 0xFFFFFFFFFFFFFFFLL;
      else
        v22 = v20;
      v63 = &v58;
      v23 = (char *)sub_20BDEA2F0((uint64_t)&v58, v22);
      v25 = &v23[16 * v19];
      *(_QWORD *)v25 = v10;
      *((_QWORD *)v25 + 1) = v14;
      v26 = (_QWORD *)v57.i64[1];
      v27 = (_QWORD *)v57.i64[0];
      if (v57.i64[1] == v57.i64[0])
      {
        v30 = vdupq_n_s64(v57.u64[1]);
        v28 = &v23[16 * v19];
      }
      else
      {
        v28 = &v23[16 * v19];
        do
        {
          v29 = *((_OWORD *)v26 - 1);
          v26 -= 2;
          *((_OWORD *)v28 - 1) = v29;
          v28 -= 16;
          *v26 = 0;
          v26[1] = 0;
        }
        while (v26 != v27);
        v30 = v57;
      }
      v18 = v25 + 16;
      v57.i64[0] = (uint64_t)v28;
      v57.i64[1] = (uint64_t)(v25 + 16);
      v61 = v30;
      v31 = v58;
      v58 = &v23[16 * v24];
      v62 = v31;
      v60 = v30.i64[0];
      sub_20BDEA324((uint64_t)&v60);
    }
    else
    {
      *(_QWORD *)v57.i64[1] = v10;
      *(_QWORD *)(v17 + 8) = v14;
      v18 = (_QWORD *)(v17 + 16);
    }
    v57.i64[1] = (uint64_t)v18;
LABEL_31:
    Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)v53);
    v8 = (__int128 *)((char *)v8 + 24);
  }
  while (v8 != *(__int128 **)(a2 + 8));
  v32 = (uint64_t *)v57.i64[0];
  if (v57.i64[1] - v57.i64[0] == 16)
  {
    *v52 = v56;
    v34 = *v32;
    v33 = (std::__shared_weak_count *)v32[1];
    if (v33)
    {
      v35 = (unint64_t *)&v33->__shared_owners_;
      do
        v36 = __ldxr(v35);
      while (__stxr(v36 + 1, v35));
    }
    v37 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)a4 = 2;
    sub_20BDDC0E4((_QWORD *)(a4 + 8), "");
    *(_QWORD *)(a4 + 32) = v34;
    *(_QWORD *)(a4 + 40) = v33;
    if (v33)
    {
      v38 = (unint64_t *)&v33->__shared_owners_;
      do
        v39 = __ldxr(v38);
      while (__stxr(v39 + 1, v38));
      *(_DWORD *)a4 = v37;
      do
        v40 = __ldaxr(v38);
      while (__stlxr(v40 - 1, v38));
      if (!v40)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        v41 = v33;
        goto LABEL_63;
      }
    }
    else
    {
      *(_DWORD *)a4 = v37;
    }
    goto LABEL_55;
  }
  a3 = v52;
  if (v57.i64[0] == v57.i64[1])
  {
LABEL_54:
    *a3 = 3;
    *(_DWORD *)a4 = 2;
    sub_20BDDC0E4((_QWORD *)(a4 + 8), "");
    *(_QWORD *)(a4 + 32) = 0;
    *(_QWORD *)(a4 + 40) = 0;
    goto LABEL_55;
  }
  Alembic::AbcCoreLayer::v12::ReadArchive::operator()((uint64_t)&v57, v53);
  *v52 = 2;
  v42 = v53[0];
  if (*((_QWORD *)&v53[0] + 1))
  {
    v43 = (unint64_t *)(*((_QWORD *)&v53[0] + 1) + 8);
    do
      v44 = __ldxr(v43);
    while (__stxr(v44 + 1, v43));
  }
  v45 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)a4 = 2;
  sub_20BDDC0E4((_QWORD *)(a4 + 8), "");
  *(_OWORD *)(a4 + 32) = v42;
  if (*((_QWORD *)&v42 + 1))
  {
    v46 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
    do
      v47 = __ldxr(v46);
    while (__stxr(v47 + 1, v46));
    *(_DWORD *)a4 = v45;
    do
      v48 = __ldaxr(v46);
    while (__stlxr(v48 - 1, v46));
    if (!v48)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v42 + 1) + 16))(*((_QWORD *)&v42 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v42 + 1));
    }
  }
  else
  {
    *(_DWORD *)a4 = v45;
  }
  v49 = (std::__shared_weak_count *)*((_QWORD *)&v53[0] + 1);
  if (*((_QWORD *)&v53[0] + 1))
  {
    v50 = (unint64_t *)(*((_QWORD *)&v53[0] + 1) + 8);
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      v41 = v49;
LABEL_63:
      std::__shared_weak_count::__release_weak(v41);
    }
  }
LABEL_55:
  *(_QWORD *)&v53[0] = &v57;
  sub_20BDE9EB0((void ***)v53);
}

{
  int v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  void *__p[2];
  char v21;
  uint64_t v22;
  char v23;
  void *v24;
  void *v25;
  uint64_t v26;
  int v27;
  void *__src[2];
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  void *v34;
  _BYTE *v35;

  Alembic::AbcCoreOgawa::v12::ReadArchive::ReadArchive((uint64_t)&v32, a2);
  v22 = v32;
  v23 = v33;
  v25 = 0;
  v26 = 0;
  v24 = 0;
  sub_20BDFD340(&v24, v34, (uint64_t)v35, (v35 - (_BYTE *)v34) >> 3);
  sub_20BDDC0E4(__p, "");
  v7 = *(_DWORD *)(a1 + 40);
  v8 = *(std::__shared_weak_count **)(a1 + 32);
  v18 = *(_QWORD *)(a1 + 24);
  v19 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  sub_20BE0E38C((uint64_t)&v27, (uint64_t)&v22, (__int128 *)__p, v7, (uint64_t)&v18);
  v11 = v19;
  if (v19)
  {
    v12 = (unint64_t *)&v19->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  if (v21 < 0)
    operator delete(__p[0]);
  if (v24)
  {
    v25 = v24;
    operator delete(v24);
  }
  if ((SHIBYTE(v29) & 0x80000000) == 0)
  {
    if (!HIBYTE(v29))
    {
      v14 = v30;
      if (v30)
      {
        *a3 = 1;
        *(_DWORD *)a4 = v27;
        *(_OWORD *)(a4 + 8) = *(_OWORD *)__src;
        *(_QWORD *)(a4 + 24) = v29;
        goto LABEL_20;
      }
    }
LABEL_24:
    *a3 = 3;
    *(_DWORD *)a4 = 2;
    sub_20BDDC0E4((_QWORD *)(a4 + 8), "");
    *(_QWORD *)(a4 + 32) = 0;
    *(_QWORD *)(a4 + 40) = 0;
    goto LABEL_25;
  }
  if (__src[1] || !v30)
    goto LABEL_24;
  *a3 = 1;
  *(_DWORD *)a4 = v27;
  sub_20BDDBFAC((_BYTE *)(a4 + 8), __src[0], 0);
  v14 = v30;
LABEL_20:
  v15 = v31;
  *(_QWORD *)(a4 + 32) = v14;
  *(_QWORD *)(a4 + 40) = v15;
  if (v15)
  {
    v16 = (unint64_t *)(v15 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
LABEL_25:
  Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)&v27);
  if (v34)
  {
    v35 = v34;
    operator delete(v34);
  }
}

void sub_20BE0E0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a10);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a16);
  a16 = (void **)&a23;
  sub_20BDE9EB0(&a16);
  _Unwind_Resume(a1);
}

void sub_20BE0E328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,char a23)
{
  uint64_t v23;
  void *v25;

  Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)&a23);
  v25 = *(void **)(v23 - 56);
  if (v25)
  {
    *(_QWORD *)(v23 - 48) = v25;
    operator delete(v25);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_20BE0E38C(uint64_t a1, uint64_t a2, __int128 *a3, int a4, uint64_t a5)
{
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v19;
  __int128 v20;
  uint64_t v21;
  const char *v22;

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)a1 = a4;
  v21 = a1;
  v22 = "IArchive::IArchive( iFileName)";
  v10 = *(std::__shared_weak_count **)(a5 + 8);
  v19 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  Alembic::AbcCoreOgawa::v12::ReadArchive::operator()(a2, a3, &v20);
  sub_20BDE82DC(a1 + 32, &v20);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
  if (*((_QWORD *)&v20 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v19)
  {
    v16 = (unint64_t *)&v19->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  return a1;
}

void sub_20BE0E4C4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;
  _QWORD *v14;
  void *v17;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  v17 = __cxa_begin_catch(a1);
  sub_20BDEBF08(v14);
  MEMORY[0x212B929D0](v13, "");
  if (a2 == 2)
    sub_20BE02570((uint64_t)&a13, (uint64_t)v17);
  else
    sub_20BE02504((uint64_t)&a13, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE0E4A4);
}

void sub_20BE0E538(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v3;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v3);
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE0E57C(uint64_t a1, __int128 **a2)
{
  void **v3;
  _QWORD *v4;
  _QWORD *v5;
  __int128 *v6;
  __int128 *v7;
  uint64_t v9;
  int v10;
  const std::string::value_type *v11;
  std::string::size_type v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  __int128 v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  _OWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t v34;
  char *v35;
  _QWORD *v36;
  _QWORD *v37;
  char *v38;
  __int128 v39;
  int64x2_t v40;
  _OWORD *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *p_shared_owners;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t *v49;
  _QWORD *v50;
  uint64_t *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  uint64_t *v57;
  uint64_t v58;
  _QWORD *v59;
  _QWORD *v60;
  _QWORD *v61;
  std::string::size_type size;
  int v63;
  const std::string::value_type *v64;
  std::string::size_type v65;
  uint64_t **v66;
  uint64_t *v67;
  _QWORD *v68;
  _QWORD *v69;
  BOOL v70;
  int v71;
  int v72;
  char **v74;
  std::string *v76;
  int64x2_t *v77;
  int v78;
  __int128 v79;
  std::string __str;
  uint64_t v81;
  uint64_t v82;
  __int128 *v83;

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  v76 = (std::string *)(a1 + 24);
  *(_QWORD *)a1 = off_24C518F08;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  v74 = (char **)(a1 + 48);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 88), 0);
  *(_OWORD *)(a1 + 152) = 0u;
  v3 = (void **)(a1 + 176);
  *(_OWORD *)(a1 + 200) = 0u;
  v4 = (_QWORD *)(a1 + 200);
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  v77 = (int64x2_t *)(a1 + 152);
  *(_DWORD *)(a1 + 216) = -1;
  v5 = operator new(0x48uLL);
  v5[7] = 0;
  v5[8] = 0;
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  v5[6] = v5 + 7;
  sub_20BE0EC40((_QWORD *)(a1 + 200), (uint64_t)v5);
  sub_20BE0ECB0(v74, a2[1] - *a2);
  v6 = *a2;
  v7 = a2[1];
  if (v7 != *a2)
  {
    while (!*((_QWORD *)v7-- - 2))
    {
LABEL_89:
      if (v7 == v6)
        return a1;
    }
    sub_20BDEA72C(v74, v7);
    if (*(char *)(a1 + 47) < 0)
    {
      if (!*(_QWORD *)(a1 + 32))
      {
LABEL_8:
        v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v7 + 16))(*(_QWORD *)v7);
        v10 = *(char *)(v9 + 23);
        if (v10 >= 0)
          v11 = (const std::string::value_type *)v9;
        else
          v11 = *(const std::string::value_type **)v9;
        if (v10 >= 0)
          v12 = *(unsigned __int8 *)(v9 + 23);
        else
          v12 = *(_QWORD *)(v9 + 8);
        std::string::append(v76, v11, v12);
        v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v7 + 72))(*(_QWORD *)v7);
        if (v13)
        {
          v14 = 0;
          v78 = v13;
          do
          {
            v15 = v4;
            v16 = *(_QWORD *)(a1 + 160);
            if (v16 == *(_QWORD *)(a1 + 152))
            {
              v17 = 0;
              v23 = *(_QWORD *)(a1 + 160);
            }
            else
            {
              v17 = 0;
              v18 = 0;
              v16 = *(_QWORD *)(a1 + 152);
              do
              {
                (*(void (**)(std::string *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)v7 + 56))(&__str, *(_QWORD *)v7, v14);
                v19 = *(_QWORD *)(v16 + 16 * v17);
                v20 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
                if (__str.__r_.__value_.__l.__size_)
                {
                  v21 = (unint64_t *)(__str.__r_.__value_.__l.__size_ + 8);
                  do
                    v22 = __ldaxr(v21);
                  while (__stlxr(v22 - 1, v21));
                  if (!v22)
                  {
                    (*(void (**)(_QWORD))(**((_QWORD **)&v20 + 1) + 16))(*((_QWORD *)&v20 + 1));
                    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v20 + 1));
                  }
                }
                v16 = *(_QWORD *)(a1 + 152);
                v23 = *(_QWORD *)(a1 + 160);
                if (v19 == (_QWORD)v20)
                  break;
                v17 = ++v18;
              }
              while (v18 < (unint64_t)((v23 - v16) >> 4));
            }
            if (v17 == (v23 - v16) >> 4)
            {
              (*(void (**)(__int128 *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)v7 + 56))(&v79, *(_QWORD *)v7, v14);
              v25 = *(_OWORD **)(a1 + 160);
              v24 = *(_QWORD *)(a1 + 168);
              if ((unint64_t)v25 >= v24)
              {
                v29 = ((uint64_t)v25 - v77->i64[0]) >> 4;
                v30 = v29 + 1;
                if ((unint64_t)(v29 + 1) >> 60)
                  sub_20BDDF694();
                v31 = v24 - v77->i64[0];
                if (v31 >> 3 > v30)
                  v30 = v31 >> 3;
                if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF0)
                  v32 = 0xFFFFFFFFFFFFFFFLL;
                else
                  v32 = v30;
                v82 = a1 + 168;
                v33 = (char *)sub_20BDEA2F0(a1 + 168, v32);
                v35 = &v33[16 * v29];
                *(_OWORD *)v35 = v79;
                v79 = 0uLL;
                v37 = *(_QWORD **)(a1 + 152);
                v36 = *(_QWORD **)(a1 + 160);
                if (v36 == v37)
                {
                  v40 = vdupq_n_s64((unint64_t)v36);
                  v38 = &v33[16 * v29];
                }
                else
                {
                  v38 = &v33[16 * v29];
                  do
                  {
                    v39 = *((_OWORD *)v36 - 1);
                    v36 -= 2;
                    *((_OWORD *)v38 - 1) = v39;
                    v38 -= 16;
                    *v36 = 0;
                    v36[1] = 0;
                  }
                  while (v36 != v37);
                  v40 = *v77;
                }
                v41 = v35 + 16;
                *(_QWORD *)(a1 + 152) = v38;
                *(_QWORD *)(a1 + 160) = v35 + 16;
                *(int64x2_t *)&__str.__r_.__value_.__r.__words[1] = v40;
                v42 = *(_QWORD *)(a1 + 168);
                *(_QWORD *)(a1 + 168) = &v33[16 * v34];
                v81 = v42;
                __str.__r_.__value_.__r.__words[0] = v40.i64[0];
                sub_20BDEA324((uint64_t)&__str);
                v43 = (std::__shared_weak_count *)*((_QWORD *)&v79 + 1);
                *(_QWORD *)(a1 + 160) = v41;
                v4 = v15;
                if (v43)
                {
                  p_shared_owners = (unint64_t *)&v43->__shared_owners_;
                  do
                    v45 = __ldaxr(p_shared_owners);
                  while (__stlxr(v45 - 1, p_shared_owners));
                  if (!v45)
                  {
                    ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
                    std::__shared_weak_count::__release_weak(v43);
                  }
                }
              }
              else
              {
                *v25 = v79;
                *(_QWORD *)(a1 + 160) = v25 + 1;
                v4 = v15;
              }
              v46 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)v7 + 64))(*(_QWORD *)v7, v14);
              v47 = v46;
              v49 = *(uint64_t **)(a1 + 184);
              v48 = *(_QWORD *)(a1 + 192);
              if ((unint64_t)v49 >= v48)
              {
                v51 = (uint64_t *)*v3;
                v52 = ((char *)v49 - (_BYTE *)*v3) >> 3;
                v53 = v52 + 1;
                if ((unint64_t)(v52 + 1) >> 61)
                  sub_20BDDF694();
                v54 = v48 - (_QWORD)v51;
                if (v54 >> 2 > v53)
                  v53 = v54 >> 2;
                if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
                  v55 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v55 = v53;
                if (v55)
                {
                  v56 = (char *)sub_20BDDF6A8(a1 + 192, v55);
                  v51 = *(uint64_t **)(a1 + 176);
                  v49 = *(uint64_t **)(a1 + 184);
                }
                else
                {
                  v56 = 0;
                }
                v57 = (uint64_t *)&v56[8 * v52];
                *v57 = v47;
                v50 = v57 + 1;
                while (v49 != v51)
                {
                  v58 = *--v49;
                  *--v57 = v58;
                }
                *(_QWORD *)(a1 + 176) = v57;
                *(_QWORD *)(a1 + 184) = v50;
                *(_QWORD *)(a1 + 192) = &v56[8 * v55];
                if (v51)
                  operator delete(v51);
              }
              else
              {
                *v49 = v46;
                v50 = v49 + 1;
              }
              *(_QWORD *)(a1 + 184) = v50;
            }
            else
            {
              v26 = *v3;
              v27 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)v7 + 64))(*(_QWORD *)v7, v14);
              v28 = v26[v17];
              if (v28 <= v27)
                v28 = v27;
              *((_QWORD *)*v3 + v17) = v28;
              v4 = v15;
            }
            v14 = (v14 + 1);
          }
          while ((_DWORD)v14 != v78);
        }
        v59 = (_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)v7 + 24))(*(_QWORD *)v7);
        v60 = v59 + 1;
        v61 = (_QWORD *)*v59;
        if ((_QWORD *)*v59 != v59 + 1)
        {
          do
          {
            sub_20BE01E1C(*v4 + 48, (const void **)v61 + 4, &__str);
            size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              size = __str.__r_.__value_.__l.__size_;
            if (size)
              std::string::append(&__str, " , ");
            v63 = *((char *)v61 + 79);
            if (v63 >= 0)
              v64 = (const std::string::value_type *)(v61 + 7);
            else
              v64 = (const std::string::value_type *)v61[7];
            if (v63 >= 0)
              v65 = *((unsigned __int8 *)v61 + 79);
            else
              v65 = v61[8];
            std::string::append(&__str, v64, v65);
            v66 = (uint64_t **)(*v4 + 48);
            v83 = (__int128 *)(v61 + 4);
            v67 = sub_20BDDDFDC(v66, (const void **)v61 + 4, (uint64_t)&unk_20CA51BA2, &v83);
            std::string::operator=((std::string *)(v67 + 7), &__str);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__str.__r_.__value_.__l.__data_);
            v68 = (_QWORD *)v61[1];
            if (v68)
            {
              do
              {
                v69 = v68;
                v68 = (_QWORD *)*v68;
              }
              while (v68);
            }
            else
            {
              do
              {
                v69 = (_QWORD *)v61[2];
                v70 = *v69 == (_QWORD)v61;
                v61 = v69;
              }
              while (!v70);
            }
            v61 = v69;
          }
          while (v69 != v60);
        }
        v71 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v7 + 80))(*(_QWORD *)v7);
        v72 = *(_DWORD *)(a1 + 216);
        if (v72 <= v71)
          v72 = v71;
        *(_DWORD *)(a1 + 216) = v72;
        v6 = *a2;
        goto LABEL_89;
      }
    }
    else if (!*(_BYTE *)(a1 + 47))
    {
      goto LABEL_8;
    }
    std::string::append(v76, ",");
    goto LABEL_8;
  }
  return a1;
}

void sub_20BE0EB48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, pthread_mutex_t *a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;

  v27 = *(std::__shared_weak_count **)(v25 + 80);
  if (v27)
    std::__shared_weak_count::__release_weak(v27);
  a17 = a10;
  sub_20BDE9EB0((void ***)&a17);
  if (*(char *)(v25 + 47) < 0)
    operator delete(*a12);
  v28 = *(std::__shared_weak_count **)(v25 + 16);
  if (v28)
    std::__shared_weak_count::__release_weak(v28);
  Alembic::AbcCoreAbstract::v12::ArchiveReader::~ArchiveReader((Alembic::AbcCoreAbstract::v12::ArchiveReader *)v25);
  _Unwind_Resume(a1);
}

void sub_20BE0EC40(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  sub_20BDE9D90(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

uint64_t sub_20BE0ECB0(char **a1, unint64_t a2)
{
  uint64_t result;
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  __int128 v11;
  int64x2_t v12;
  char *v13;
  uint64_t v14;
  int64x2_t v15;
  char *v16;
  uint64_t v17;

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60)
      sub_20BDDF694();
    v5 = a1[1] - *a1;
    v17 = result;
    v6 = (char *)sub_20BDEA2F0(result, a2);
    v9 = *a1;
    v8 = a1[1];
    if (v8 == *a1)
    {
      v12 = vdupq_n_s64((unint64_t)v8);
      v10 = &v6[v5];
    }
    else
    {
      v10 = &v6[v5];
      do
      {
        v11 = *((_OWORD *)v8 - 1);
        v8 -= 16;
        *((_OWORD *)v10 - 1) = v11;
        v10 -= 16;
        *(_QWORD *)v8 = 0;
        *((_QWORD *)v8 + 1) = 0;
      }
      while (v8 != v9);
      v12 = *(int64x2_t *)a1;
    }
    *a1 = v10;
    a1[1] = &v6[v5];
    v15 = v12;
    v13 = a1[2];
    a1[2] = &v6[16 * v7];
    v16 = v13;
    v14 = v12.i64[0];
    return sub_20BDEA324((uint64_t)&v14);
  }
  return result;
}

void sub_20BE0ED68(uint64_t a1)
{
  void *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  void **v5;

  *(_QWORD *)a1 = off_24C518F08;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 200));
  v2 = *(void **)(a1 + 176);
  if (v2)
  {
    *(_QWORD *)(a1 + 184) = v2;
    operator delete(v2);
  }
  v5 = (void **)(a1 + 152);
  sub_20BDE9EB0(&v5);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 88));
  v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  v5 = (void **)(a1 + 48);
  sub_20BDE9EB0(&v5);
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  Alembic::AbcCoreAbstract::v12::ArchiveReader::~ArchiveReader((Alembic::AbcCoreAbstract::v12::ArchiveReader *)a1);
}

void sub_20BE0EE0C(uint64_t a1)
{
  void *v1;

  sub_20BE0ED68(a1);
  operator delete(v1);
}

uint64_t sub_20BE0EE20(uint64_t a1)
{
  return a1 + 24;
}

uint64_t sub_20BE0EE28(uint64_t a1)
{
  return *(_QWORD *)(a1 + 200) + 48;
}

uint64_t sub_20BE0EE34@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  pthread_mutex_t *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  _QWORD *v17;
  _QWORD *v18;
  char *v19;
  __int128 v20;
  int64x2_t v21;
  _OWORD *v22;
  char *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  void *v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  __int128 v50;
  int64x2_t v51;
  char *v52;
  int64x2_t *v53;
  int64x2_t v54;
  char *v55;
  char **v56;

  v4 = (pthread_mutex_t *)(a1 + 88);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 88));
  *a2 = 0;
  a2[1] = 0;
  v5 = *(std::__shared_weak_count **)(a1 + 80);
  if (v5)
  {
    v6 = std::__shared_weak_count::lock(v5);
    a2[1] = (uint64_t)v6;
    if (v6)
    {
      v7 = *(_QWORD *)(a1 + 72);
      *a2 = v7;
      if (v7)
        return pthread_mutex_unlock(v4);
    }
    else if (*a2)
    {
      return pthread_mutex_unlock(v4);
    }
  }
  v51 = 0uLL;
  v52 = 0;
  sub_20BE0ECB0((char **)&v51, (uint64_t)(*(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48)) >> 4);
  for (i = *(_QWORD *)(a1 + 48); i != *(_QWORD *)(a1 + 56); i += 16)
  {
    (*(void (**)(__int128 *__return_ptr))(**(_QWORD **)i + 32))(&v50);
    v9 = v51.i64[1];
    if (v51.i64[1] >= (unint64_t)v52)
    {
      v10 = (v51.i64[1] - v51.i64[0]) >> 4;
      v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 60)
        sub_20BDDF694();
      v12 = (uint64_t)&v52[-v51.i64[0]];
      if ((uint64_t)&v52[-v51.i64[0]] >> 3 > v11)
        v11 = v12 >> 3;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0)
        v13 = 0xFFFFFFFFFFFFFFFLL;
      else
        v13 = v11;
      v56 = &v52;
      v14 = (char *)sub_20BDEA2F0((uint64_t)&v52, v13);
      v16 = &v14[16 * v10];
      *(_OWORD *)v16 = v50;
      v50 = 0uLL;
      v17 = (_QWORD *)v51.i64[1];
      v18 = (_QWORD *)v51.i64[0];
      if (v51.i64[1] == v51.i64[0])
      {
        v21 = vdupq_n_s64(v51.u64[1]);
        v19 = &v14[16 * v10];
      }
      else
      {
        v19 = &v14[16 * v10];
        do
        {
          v20 = *((_OWORD *)v17 - 1);
          v17 -= 2;
          *((_OWORD *)v19 - 1) = v20;
          v19 -= 16;
          *v17 = 0;
          v17[1] = 0;
        }
        while (v17 != v18);
        v21 = v51;
      }
      v22 = v16 + 16;
      v51.i64[0] = (uint64_t)v19;
      v51.i64[1] = (uint64_t)(v16 + 16);
      v54 = v21;
      v23 = v52;
      v52 = &v14[16 * v15];
      v55 = v23;
      v53 = (int64x2_t *)v21.i64[0];
      sub_20BDEA324((uint64_t)&v53);
      v24 = (std::__shared_weak_count *)*((_QWORD *)&v50 + 1);
      v51.i64[1] = (uint64_t)v22;
      if (*((_QWORD *)&v50 + 1))
      {
        v25 = (unint64_t *)(*((_QWORD *)&v50 + 1) + 8);
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
    }
    else
    {
      *(_OWORD *)v51.i64[1] = v50;
      v51.i64[1] = v9 + 16;
    }
  }
  v27 = operator new(0x118uLL);
  sub_20BDE70B8(&v48, (_QWORD *)(a1 + 8));
  v28 = *(std::__shared_weak_count **)(a1 + 208);
  v46 = *(_QWORD *)(a1 + 200);
  v47 = v28;
  if (v28)
  {
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    do
      v30 = __ldxr(p_shared_owners);
    while (__stxr(v30 + 1, p_shared_owners));
  }
  sub_20BE11AAC(v27, &v48, &v51, &v46);
  sub_20BE0F2B8((uint64_t *)&v53, (uint64_t)v27);
  sub_20BDE82DC((uint64_t)a2, (__int128 *)&v53);
  v31 = (std::__shared_weak_count *)v54.i64[0];
  if (v54.i64[0])
  {
    v32 = (unint64_t *)(v54.i64[0] + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v47;
  if (v47)
  {
    v35 = (unint64_t *)&v47->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = v49;
  if (v49)
  {
    v38 = (unint64_t *)&v49->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  v41 = *a2;
  v40 = a2[1];
  if (v40)
  {
    v42 = (unint64_t *)(v40 + 16);
    do
      v43 = __ldxr(v42);
    while (__stxr(v43 + 1, v42));
  }
  v44 = *(std::__shared_weak_count **)(a1 + 80);
  *(_QWORD *)(a1 + 72) = v41;
  *(_QWORD *)(a1 + 80) = v40;
  if (v44)
    std::__shared_weak_count::__release_weak(v44);
  v53 = &v51;
  sub_20BDE9EB0((void ***)&v53);
  return pthread_mutex_unlock(v4);
}

void sub_20BE0F178(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char *a13, uint64_t a14, char a15)
{
  pthread_mutex_t *v15;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v16;
  void *v17;

  operator delete(v17);
  a13 = &a15;
  sub_20BDE9EB0((void ***)&a13);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v16);
  pthread_mutex_unlock(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE0F1F4@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  __int128 v4;
  unint64_t *v5;
  unint64_t v6;

  v3 = *(_QWORD *)(result + 152);
  if (a2 >= (unint64_t)((*(_QWORD *)(result + 160) - v3) >> 4))
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    v4 = *(_OWORD *)(v3 + 16 * a2);
    *(_OWORD *)a3 = v4;
    if (*((_QWORD *)&v4 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v4 + 1) + 8);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
  }
  return result;
}

double sub_20BE0F238@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_20BE0F270(uint64_t a1, unsigned int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 176);
  if (a2 >= (unint64_t)((*(_QWORD *)(a1 + 184) - v2) >> 3))
    return 0;
  else
    return *(_QWORD *)(v2 + 8 * a2);
}

void sub_20BE0F294(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t sub_20BE0F2A0(uint64_t a1)
{
  return (*(_QWORD *)(a1 + 160) - *(_QWORD *)(a1 + 152)) >> 4;
}

uint64_t sub_20BE0F2B0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 216);
}

uint64_t *sub_20BE0F2B8(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C518FC0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BE0F314(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BE0F338(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BE0F34C(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BE0F364(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C519010))
    return a1 + 24;
  else
    return 0;
}

unint64_t sub_20BE0F3A4(unint64_t a1, uint64_t *a2, __int128 **a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *exception;
  _QWORD *v13;
  __int128 v14;
  char v15;
  _QWORD v16[4];
  __int128 __p;
  uint64_t v18;

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_24C519038;
  v5 = *a2;
  *(_QWORD *)(a1 + 24) = *a2;
  v6 = a2[1];
  *(_QWORD *)(a1 + 32) = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v5 = *(_QWORD *)(a1 + 24);
  }
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 128) = a1 + 136;
  *(_QWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_QWORD *)(a1 + 120) = 0;
  if (!v5)
  {
    sub_20BDDBD68((uint64_t)&__p);
    sub_20BDDC1C8(&v18, (uint64_t)"Invalid object in CprImpl(Object)", 33);
    std::stringbuf::str();
    sub_20BDDBF20(v16, &v14);
    if (v15 < 0)
      operator delete((void *)v14);
    exception = __cxa_allocate_exception(0x20uLL);
    v13 = sub_20BDDC09C(exception, (uint64_t)v16);
    __cxa_throw(v13, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  __p = 0uLL;
  v18 = 0;
  v9 = operator new(0x50uLL);
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
  sub_20BDEFC54(v9, &__p, (const void ***)(v10 + 48));
  sub_20BE0F5E4((_QWORD *)(a1 + 64), (uint64_t)v9);
  sub_20BE0F654(a1, a3);
  if (SHIBYTE(v18) < 0)
    operator delete((void *)__p);
  return a1;
}

void sub_20BE0F534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v22;
  uint64_t v23;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v24;
  uint64_t v25;
  void *v27;
  std::__shared_weak_count *v28;

  sub_20BDDC194(&a12);
  sub_20BDDBE98((uint64_t)&__p);
  sub_20BDECAB8(v25, *(char **)(v21 + 136));
  v27 = *(void **)(v21 + 104);
  if (v27)
  {
    *(_QWORD *)(v21 + 112) = v27;
    operator delete(v27);
  }
  __p = (void *)(v23 + 40);
  sub_20BE104D4((void ***)&__p);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v24);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)v23);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v22);
  v28 = *(std::__shared_weak_count **)(v21 + 16);
  if (v28)
    std::__shared_weak_count::__release_weak(v28);
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader((Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *)v21);
  _Unwind_Resume(a1);
}

void sub_20BE0F5E4(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  sub_20BE10544(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

unint64_t sub_20BE0F654(unint64_t result, __int128 **a2)
{
  __int128 *v2;
  _QWORD *v3;
  uint64_t **v4;
  _QWORD *v5;
  uint64_t *v6;
  unint64_t i;
  uint64_t v8;
  _BOOL4 v9;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  __int128 *v14;
  __int128 *v15;
  __int128 *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *j;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  BOOL v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  char *v56;
  char *v57;
  uint64_t v59;
  void **v60;
  void *__p[2];
  char v62;
  __int128 *v63;
  uint64_t v64;
  char v65;

  v2 = *a2;
  if (*a2 != a2[1])
  {
    v3 = (_QWORD *)result;
    v4 = (uint64_t **)(result + 128);
    v5 = (_QWORD *)(result + 136);
    v6 = (uint64_t *)(result + 80);
    v59 = result + 120;
    v60 = (void **)(result + 104);
    do
    {
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v2 + 64))(*(_QWORD *)v2);
      if (result)
      {
        for (i = 0; i < result; ++i)
        {
          v8 = (*(uint64_t (**)(_QWORD, unint64_t))(**(_QWORD **)v2 + 72))(*(_QWORD *)v2, i);
          sub_20BDDC0E4(__p, "prune");
          sub_20BE01E1C(v8 + 32, (const void **)__p, &v63);
          if (v65 < 0)
          {
            v9 = v64 == 1 && *(unsigned __int8 *)v63 == 49;
            operator delete(v63);
          }
          else
          {
            v9 = v65 == 1 && v63 == 49;
          }
          if (v62 < 0)
            operator delete(__p[0]);
          sub_20BDDC0E4(__p, "replace");
          sub_20BE01E1C(v8 + 32, (const void **)__p, &v63);
          if (v65 < 0)
          {
            v10 = v64 == 1 && *(unsigned __int8 *)v63 == 49;
            operator delete(v63);
          }
          else
          {
            v10 = v65 == 1 && v63 == 49;
          }
          if (v62 < 0)
            operator delete(__p[0]);
          v11 = sub_20BDEEBA4((uint64_t)v4, (const void **)v8);
          if (v5 == (_QWORD *)v11)
          {
            if (!v9)
            {
              v21 = v3[18];
              v63 = (__int128 *)v8;
              sub_20BDEEA20(v4, (const void **)v8, (uint64_t)&unk_20CA51FC4, &v63)[7] = v21;
              sub_20BE10440(v6, v21 + 1);
              sub_20BDEA72C((char **)(v3[10] + 24 * v21), v2);
              v23 = (char *)v3[14];
              v22 = v3[15];
              if ((unint64_t)v23 >= v22)
              {
                v42 = (char *)*v60;
                v43 = (v23 - (_BYTE *)*v60) >> 4;
                v44 = v43 + 1;
                if ((unint64_t)(v43 + 1) >> 60)
                  sub_20BDDF694();
                v45 = v22 - (_QWORD)v42;
                if (v45 >> 3 > v44)
                  v44 = v45 >> 3;
                if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0)
                  v46 = 0xFFFFFFFFFFFFFFFLL;
                else
                  v46 = v44;
                if (v46)
                {
                  v47 = (char *)sub_20BDEA2F0(v59, v46);
                  v42 = (char *)v3[13];
                  v23 = (char *)v3[14];
                }
                else
                {
                  v47 = 0;
                }
                v56 = &v47[16 * v43];
                *(_QWORD *)v56 = 0;
                *((_QWORD *)v56 + 1) = i;
                v57 = v56;
                if (v23 != v42)
                {
                  do
                  {
                    *((_OWORD *)v57 - 1) = *((_OWORD *)v23 - 1);
                    v57 -= 16;
                    v23 -= 16;
                  }
                  while (v23 != v42);
                  v42 = (char *)*v60;
                }
                v24 = v56 + 16;
                v3[13] = v57;
                v3[14] = v56 + 16;
                v3[15] = &v47[16 * v46];
                if (v42)
                  operator delete(v42);
              }
              else
              {
                *(_QWORD *)v23 = 0;
                *((_QWORD *)v23 + 1) = i;
                v24 = v23 + 16;
              }
              v3[14] = v24;
            }
          }
          else
          {
            v12 = v11;
            if (v9)
            {
              v13 = *(_QWORD *)(v11 + 56);
              sub_20BE10A70((uint64_t)&v63, v3[10] + 24 * v13 + 24, v3[11], v3[10] + 24 * v13);
              v15 = v14;
              v16 = (__int128 *)v3[11];
              if (v16 != v14)
              {
                do
                {
                  v16 = (__int128 *)((char *)v16 - 24);
                  v63 = v16;
                  sub_20BDE9EB0((void ***)&v63);
                }
                while (v16 != v15);
              }
              v3[11] = v15;
              v17 = (_QWORD *)v3[14];
              v18 = v3[13] + 16 * v13;
              for (j = (_QWORD *)(v18 + 16); j != v17; j += 2)
              {
                v20 = j[1];
                *(j - 2) = *j;
                *(j - 1) = v20;
                v18 += 16;
              }
              v3[14] = v18;
              sub_20BE10B40(v4, v12);
              v37 = (_QWORD *)v3[16];
              if (v37 != v5)
              {
                do
                {
                  v38 = v37[7];
                  if (v38 > v13)
                    v37[7] = v38 - 1;
                  v39 = (_QWORD *)v37[1];
                  if (v39)
                  {
                    do
                    {
                      v40 = v39;
                      v39 = (_QWORD *)*v39;
                    }
                    while (v39);
                  }
                  else
                  {
                    do
                    {
                      v40 = (_QWORD *)v37[2];
                      v41 = *v40 == (_QWORD)v37;
                      v37 = v40;
                    }
                    while (!v41);
                  }
                  v37 = v40;
                }
                while (v40 != v5);
              }
            }
            else if (*(_DWORD *)(v8 + 24)
                   || (v25 = *(_QWORD *)(v11 + 56),
                       v26 = 24 * v25,
                       v27 = (char *)*v60 + 16 * v25,
                       v28 = *(_QWORD *)(*(_QWORD *)(*v6 + v26) + 16 * *v27),
                       *(_DWORD *)((*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 72))(v28, v27[1]) + 24)))
            {
              v29 = *(_QWORD *)(v12 + 56);
              v30 = *v6;
              v31 = *v6 + 24 * v29;
              v34 = *(_QWORD *)(v31 + 8);
              v33 = (_QWORD *)(v31 + 8);
              v32 = v34;
              v35 = *(_QWORD *)(*v6 + 24 * v29);
              if (v34 != v35)
              {
                do
                  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v32 - 16));
                while (v32 != v35);
                v30 = *v6;
              }
              *v33 = v35;
              sub_20BDEA72C((char **)(v30 + 24 * v29), v2);
              v36 = (char *)*v60 + 16 * v29;
              *v36 = 0;
              v36[1] = i;
            }
            else
            {
              v48 = *(_QWORD *)(v12 + 56);
              v49 = *v6;
              if (v10)
              {
                v50 = v49 + 24 * v48;
                v53 = *(_QWORD *)(v50 + 8);
                v52 = (_QWORD *)(v50 + 8);
                v51 = v53;
                v54 = *(_QWORD *)(v49 + 24 * v48);
                if (v53 != v54)
                {
                  do
                    pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v51 - 16));
                  while (v51 != v54);
                  v49 = *v6;
                }
                *v52 = v54;
              }
              sub_20BDEA72C((char **)(v49 + 24 * v48), v2);
              if (*(_QWORD *)(v8 + 48))
              {
                v55 = (char *)*v60 + 16 * v48;
                *v55 = ((uint64_t)(*(_QWORD *)(*v6 + 24 * v48 + 8) - *(_QWORD *)(*v6 + 24 * v48)) >> 4) - 1;
                v55[1] = i;
              }
            }
          }
          result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v2 + 64))(*(_QWORD *)v2);
        }
      }
      ++v2;
    }
    while (v2 != a2[1]);
  }
  return result;
}

void sub_20BE0FB5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t sub_20BE0FB80(unint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *i;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  _QWORD *v20;
  _QWORD *v21;
  char *v22;
  __int128 v23;
  int64x2_t v24;
  _OWORD *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  _QWORD *exception;
  _QWORD *v32;
  __int128 v33;
  void *__p[2];
  uint64_t v35;
  int64x2_t v36;
  _QWORD v37[2];
  int64x2_t *v38;
  int64x2_t v39;
  uint64_t v40;
  _QWORD *v41;

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_24C519038;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v4 = *a2;
  *(_QWORD *)(a1 + 40) = *a2;
  v5 = a2[1];
  *(_QWORD *)(a1 + 48) = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    v4 = *(_QWORD *)(a1 + 40);
  }
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)(a1 + 56) = a3;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 128) = a1 + 136;
  *(_QWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  if (!v4)
  {
    sub_20BDDBD68((uint64_t)&v38);
    sub_20BDDC1C8(&v39.i64[1], (uint64_t)"Invalid compound in CprImpl(CprImplPtr, size_t)", 47);
    std::stringbuf::str();
    sub_20BDDBF20(&v36, (__int128 *)__p);
    if (SHIBYTE(v35) < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v32 = sub_20BDDC09C(exception, (uint64_t)&v36);
    __cxa_throw(v32, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDE881C((_QWORD *)(a1 + 24), (uint64_t *)(v4 + 24));
  v8 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80) + 24 * *(_QWORD *)(a1 + 56));
  v36 = 0uLL;
  v37[0] = 0;
  v9 = v8 + 1;
  sub_20BE0ECB0((char **)&v36, (uint64_t)(v8[1] - *v8) >> 4);
  v10 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 72))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 56));
  if (*(char *)(v10 + 23) < 0)
  {
    sub_20BDDBFAC(__p, *(void **)v10, *(_QWORD *)(v10 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)v10;
    v35 = *(_QWORD *)(v10 + 16);
  }
  for (i = (_QWORD *)*v8; i != (_QWORD *)*v9; i += 2)
  {
    (*(void (**)(__int128 *__return_ptr, _QWORD, void **))(*(_QWORD *)*i + 104))(&v33, *i, __p);
    v12 = v36.i64[1];
    if (v36.i64[1] >= v37[0])
    {
      v13 = (v36.i64[1] - v36.i64[0]) >> 4;
      v14 = v13 + 1;
      if ((unint64_t)(v13 + 1) >> 60)
        sub_20BDDF694();
      v15 = v37[0] - v36.i64[0];
      if ((v37[0] - v36.i64[0]) >> 3 > v14)
        v14 = v15 >> 3;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0)
        v16 = 0xFFFFFFFFFFFFFFFLL;
      else
        v16 = v14;
      v41 = v37;
      v17 = (char *)sub_20BDEA2F0((uint64_t)v37, v16);
      v19 = &v17[16 * v13];
      *(_OWORD *)v19 = v33;
      v33 = 0uLL;
      v20 = (_QWORD *)v36.i64[1];
      v21 = (_QWORD *)v36.i64[0];
      if (v36.i64[1] == v36.i64[0])
      {
        v24 = vdupq_n_s64(v36.u64[1]);
        v22 = &v17[16 * v13];
      }
      else
      {
        v22 = &v17[16 * v13];
        do
        {
          v23 = *((_OWORD *)v20 - 1);
          v20 -= 2;
          *((_OWORD *)v22 - 1) = v23;
          v22 -= 16;
          *v20 = 0;
          v20[1] = 0;
        }
        while (v20 != v21);
        v24 = v36;
      }
      v25 = v19 + 16;
      v36.i64[0] = (uint64_t)v22;
      v36.i64[1] = (uint64_t)(v19 + 16);
      v39 = v24;
      v26 = v37[0];
      v37[0] = &v17[16 * v18];
      v40 = v26;
      v38 = (int64x2_t *)v24.i64[0];
      sub_20BDEA324((uint64_t)&v38);
      v27 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
      v36.i64[1] = (uint64_t)v25;
      if (*((_QWORD *)&v33 + 1))
      {
        v28 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }
    else
    {
      *(_OWORD *)v36.i64[1] = v33;
      v36.i64[1] = v12 + 16;
    }
  }
  sub_20BE0F654(a1, (__int128 **)&v36);
  if (SHIBYTE(v35) < 0)
    operator delete(__p[0]);
  v38 = &v36;
  sub_20BDE9EB0((void ***)&v38);
  return a1;
}

void sub_20BE0FEC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *a12, char a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v27;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v28;
  void *v30;
  std::__shared_weak_count *v31;

  sub_20BDDC194((std::exception *)&a22);
  sub_20BDDBE98((uint64_t)&a26);
  sub_20BDECAB8(a10, *(char **)(v26 + 136));
  v30 = *(void **)(v26 + 104);
  if (v30)
  {
    *(_QWORD *)(v26 + 112) = v30;
    operator delete(v30);
  }
  a22 = a11;
  sub_20BE104D4((void ***)&a22);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v28);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(a12);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v27);
  v31 = *(std::__shared_weak_count **)(v26 + 16);
  if (v31)
    std::__shared_weak_count::__release_weak(v31);
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader((Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *)v26);
  _Unwind_Resume(a1);
}

void sub_20BE0FF98(uint64_t a1)
{
  void *v2;
  std::__shared_weak_count *v3;
  void **v4;

  *(_QWORD *)a1 = off_24C519038;
  sub_20BDECAB8(a1 + 128, *(char **)(a1 + 136));
  v2 = *(void **)(a1 + 104);
  if (v2)
  {
    *(_QWORD *)(a1 + 112) = v2;
    operator delete(v2);
  }
  v4 = (void **)(a1 + 80);
  sub_20BE104D4(&v4);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 64));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 40));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 24));
  v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader((Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *)a1);
}

void sub_20BE10020(uint64_t a1)
{
  void *v1;

  sub_20BE0FF98(a1);
  operator delete(v1);
}

uint64_t sub_20BE10034(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 64))
    return *(_QWORD *)(a1 + 64);
  else
    return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 72))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 56));
}

uint64_t sub_20BE1005C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 104))(*(_QWORD *)(a1 + 24));
}

uint64_t sub_20BE1006C@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 48);
  *a2 = *(_QWORD *)(result + 40);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

double sub_20BE10090@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

unint64_t sub_20BE100C8(uint64_t a1)
{
  return 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 88) - *(_QWORD *)(a1 + 80)) >> 3);
}

uint64_t sub_20BE100E4(_QWORD *a1, unint64_t a2)
{
  uint64_t v2;
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  _BYTE v9[16];
  _QWORD v10[33];

  v2 = a1[10];
  if (0xAAAAAAAAAAAAAAABLL * ((a1[11] - v2) >> 3) <= a2)
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"Out of range index in CprImpl::getPropertyHeader: ", 50);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(v2 + 24 * a2)
                                                                 + 16 * *(_QWORD *)(a1[13] + 16 * a2))
                                                   + 72))(*(_QWORD *)(*(_QWORD *)(v2 + 24 * a2) + 16 * *(_QWORD *)(a1[13] + 16 * a2)), *(_QWORD *)(a1[13] + 16 * a2 + 8));
}

void sub_20BE101D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE101FC(uint64_t a1, const void **a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;

  v3 = sub_20BDEEBA4(a1 + 128, a2);
  if (a1 + 136 == v3)
    return 0;
  v4 = *(_QWORD *)(v3 + 56);
  v5 = 24 * v4;
  v6 = (_QWORD *)(*(_QWORD *)(a1 + 104) + 16 * v4);
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + v5) + 16 * *v6);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 72))(v7, v6[1]);
}

uint64_t sub_20BE1026C@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  result = sub_20BDEEBA4(a1 + 128, a2);
  if (a1 + 136 == result)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    v6 = result + 32;
    v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 24 * *(_QWORD *)(result + 56) + 8) - 16);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 88))(v7, v6);
  }
  return result;
}

uint64_t sub_20BE102D8@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  result = sub_20BDEEBA4(a1 + 128, a2);
  if (a1 + 136 == result)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    v6 = result + 32;
    v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 24 * *(_QWORD *)(result + 56) + 8) - 16);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, v6);
  }
  return result;
}

void sub_20BE10344(uint64_t a1@<X0>, const void **a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  void *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v5 = sub_20BDEEBA4(a1 + 128, a2);
  if (a1 + 136 == v5)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    v6 = v5;
    v7 = operator new(0x98uLL);
    sub_20BDE70B8(&v11, (_QWORD *)(a1 + 8));
    sub_20BE0FB80((unint64_t)v7, &v11, *(_QWORD *)(v6 + 56));
    sub_20BE10610((uint64_t *)&v13, (uint64_t)v7);
    *(_OWORD *)a3 = v13;
    v13 = 0uLL;
    v8 = v12;
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
}

void sub_20BE1040C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BE10440(uint64_t *a1, unint64_t a2)
{
  void **v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  void **v8;

  v3 = (void **)a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_20BE106FC(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 24 * a2;
    while (v3 != (void **)v7)
    {
      v3 -= 3;
      v8 = v3;
      sub_20BDE9EB0(&v8);
    }
    a1[1] = v7;
  }
}

void sub_20BE104D4(void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        v6 = v4;
        sub_20BDE9EB0(&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *sub_20BE10544(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C519100;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_20BE10590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  a10 = 0;
  if (v10)
    sub_20BDEFE98((uint64_t)&a10, v10);
  _Unwind_Resume(exception_object);
}

void sub_20BE105B4(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_20BE105C8(uint64_t a1)
{
  sub_20BDEFE98(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t sub_20BE105D0(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C519150))
    return a1 + 24;
  else
    return 0;
}

uint64_t *sub_20BE10610(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C519178;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BE1066C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BE10690(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BE106A4(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BE106BC(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C5191C8))
    return a1 + 24;
  else
    return 0;
}

void sub_20BE106FC(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      sub_20BDDF694();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)sub_20BDE4FF4(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[24 * v8];
    v18 = &v12[24 * v11];
    v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    v17 = &v16[v14];
    sub_20BE10860(a1, &v15);
    sub_20BE109F0(&v15);
  }
}

void sub_20BE1084C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BE109F0((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE10860(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_20BE108D4((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_20BE108D4(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  sub_20BE10974((uint64_t)v11);
  return v9;
}

uint64_t sub_20BE10974(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_20BE109A8(a1);
  return a1;
}

void sub_20BE109A8(uint64_t a1)
{
  void **v1;
  void **v2;
  void **v3;

  v1 = *(void ***)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(void ***)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = v1;
    sub_20BDE9EB0(&v3);
    v1 += 3;
  }
}

void **sub_20BE109F0(void **a1)
{
  sub_20BE10A20((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void sub_20BE10A20(uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;
  void **v5;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    v4 = (void **)(i - 24);
    *(_QWORD *)(a1 + 16) = v4;
    v5 = v4;
    sub_20BDE9EB0(&v5);
  }
}

uint64_t sub_20BE10A70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  v5 = a2;
  if (a2 == a3)
    return a2;
  v6 = a3;
  do
  {
    sub_20BE10AE4((void **)a4);
    *(_OWORD *)a4 = *(_OWORD *)v5;
    *(_QWORD *)(a4 + 16) = *(_QWORD *)(v5 + 16);
    *(_QWORD *)v5 = 0;
    *(_QWORD *)(v5 + 8) = 0;
    *(_QWORD *)(v5 + 16) = 0;
    a4 += 24;
    v5 += 24;
  }
  while (v5 != v6);
  return v6;
}

void sub_20BE10AE4(void **a1)
{
  char *v1;
  char *v3;
  void *v4;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
        pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v3 - 16));
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t *sub_20BE10B40(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;

  v3 = sub_20BE10B80(a1, (uint64_t *)a2);
  if (*(char *)(a2 + 55) < 0)
    operator delete(*(void **)(a2 + 32));
  operator delete((void *)a2);
  return v3;
}

uint64_t *sub_20BE10B80(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_20BE10BF0(v6, a2);
  return v3;
}

uint64_t *sub_20BE10BF0(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

uint64_t sub_20BE10F74(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD *exception;
  _QWORD *v14;
  __int128 __p;
  char v16;
  _QWORD v17[4];
  _BYTE v18[16];
  _QWORD v19[34];

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_24C5191F0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = *a2;
  v6 = a2[1];
  *(_QWORD *)(a1 + 56) = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  *(_QWORD *)(a1 + 64) = *a4;
  v9 = a4[1];
  *(_QWORD *)(a1 + 72) = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_QWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 152), 0);
  *(_OWORD *)(a1 + 216) = 0u;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 256) = a1 + 264;
  *(_QWORD *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_QWORD *)(a1 + 248) = 0;
  if (!*(_QWORD *)(a1 + 48))
  {
    sub_20BDDBD68((uint64_t)v18);
    sub_20BDDC1C8(v19, (uint64_t)"Invalid archive in OrImpl(Archive)", 34);
    std::stringbuf::str();
    sub_20BDDBF20(v17, &__p);
    if (v16 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v14 = sub_20BDDC09C(exception, (uint64_t)v17);
    __cxa_throw(v14, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BE111D0(a1, a3);
  return a1;
}

void sub_20BE11110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::exception a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  uint64_t v17;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v18;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v19;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v20;
  pthread_mutex_t *v21;
  uint64_t v22;
  void **v23;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;

  sub_20BDDC194(&a13);
  sub_20BDDBE98((uint64_t)&a17);
  sub_20BDECAB8(v22, *(char **)(v17 + 264));
  v25 = *(std::__shared_weak_count **)(v17 + 248);
  if (v25)
    std::__shared_weak_count::__release_weak(v25);
  sub_20BDE9EB0(&a17);
  pthread_mutex_destroy(v21);
  sub_20BE12C54(&a17);
  a17 = v23 + 3;
  sub_20BE12B74(&a17);
  a17 = v23;
  sub_20BDE9EB0(&a17);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v20);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v19);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v18);
  v26 = *(std::__shared_weak_count **)(v17 + 16);
  if (v26)
    std::__shared_weak_count::__release_weak(v26);
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader((Alembic::AbcCoreAbstract::v12::ObjectReader *)v17);
  _Unwind_Resume(a1);
}

unint64_t sub_20BE111D0(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  unint64_t result;
  uint64_t *v6;
  unint64_t v7;
  _OWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;
  _QWORD *v17;
  char *v18;
  __int128 v19;
  int64x2_t v20;
  _OWORD *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  unint64_t i;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  BOOL v31;
  _BOOL4 v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t j;
  std::__shared_weak_count *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  unint64_t v58;
  uint64_t *v59;
  uint64_t *v60;
  BOOL v61;
  uint64_t **v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t *v66;
  unint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t *v76;
  unint64_t v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  int64x2_t *v81;
  char **v82;
  uint64_t *v83;
  uint64_t **v84;
  void *__p[2];
  char v86;
  __int128 v87;
  unint64_t v88;
  _BYTE __dst[24];
  __int128 v90;
  uint64_t v91;
  const void **v92[4];

  v4 = *(_QWORD **)a2;
  v81 = (int64x2_t *)(a1 + 216);
  result = sub_20BE0ECB0((char **)(a1 + 216), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 4);
  if (v4 != *(_QWORD **)(a2 + 8))
  {
    v6 = (uint64_t *)(a1 + 264);
    v83 = (uint64_t *)(a1 + 104);
    v84 = (uint64_t **)(a1 + 256);
    v82 = (char **)(a1 + 80);
    do
    {
      (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)*v4 + 40))(&v87);
      v8 = *(_OWORD **)(a1 + 224);
      v7 = *(_QWORD *)(a1 + 232);
      if ((unint64_t)v8 >= v7)
      {
        v9 = ((uint64_t)v8 - v81->i64[0]) >> 4;
        v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) >> 60)
          sub_20BDDF694();
        v11 = v7 - v81->i64[0];
        if (v11 >> 3 > v10)
          v10 = v11 >> 3;
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
          v12 = 0xFFFFFFFFFFFFFFFLL;
        else
          v12 = v10;
        *((_QWORD *)&v90 + 1) = a1 + 232;
        v13 = (char *)sub_20BDEA2F0(a1 + 232, v12);
        v15 = &v13[16 * v9];
        *(_OWORD *)v15 = v87;
        v87 = 0uLL;
        v17 = *(_QWORD **)(a1 + 216);
        v16 = *(_QWORD **)(a1 + 224);
        if (v16 == v17)
        {
          v20 = vdupq_n_s64((unint64_t)v16);
          v18 = &v13[16 * v9];
        }
        else
        {
          v18 = &v13[16 * v9];
          do
          {
            v19 = *((_OWORD *)v16 - 1);
            v16 -= 2;
            *((_OWORD *)v18 - 1) = v19;
            v18 -= 16;
            *v16 = 0;
            v16[1] = 0;
          }
          while (v16 != v17);
          v20 = *v81;
        }
        v21 = v15 + 16;
        *(_QWORD *)(a1 + 216) = v18;
        *(_QWORD *)(a1 + 224) = v15 + 16;
        *(int64x2_t *)&__dst[8] = v20;
        v22 = *(_QWORD *)(a1 + 232);
        *(_QWORD *)(a1 + 232) = &v13[16 * v14];
        *(_QWORD *)&v90 = v22;
        *(_QWORD *)__dst = v20.i64[0];
        sub_20BDEA324((uint64_t)__dst);
        v23 = (std::__shared_weak_count *)*((_QWORD *)&v87 + 1);
        *(_QWORD *)(a1 + 224) = v21;
        if (v23)
        {
          p_shared_owners = (unint64_t *)&v23->__shared_owners_;
          do
            v25 = __ldaxr(p_shared_owners);
          while (__stlxr(v25 - 1, p_shared_owners));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
      }
      else
      {
        *v8 = v87;
        *(_QWORD *)(a1 + 224) = v8 + 1;
      }
      result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v4 + 48))(*v4);
      if (result)
      {
        for (i = 0; i < result; ++i)
        {
          v27 = (*(uint64_t (**)(_QWORD, unint64_t))(*(_QWORD *)*v4 + 56))(*v4, i);
          v28 = v27;
          if (*(char *)(v27 + 23) < 0)
          {
            sub_20BDDBFAC(__dst, *(void **)v27, *(_QWORD *)(v27 + 8));
          }
          else
          {
            v29 = *(_OWORD *)v27;
            *(_QWORD *)&__dst[16] = *(_QWORD *)(v27 + 16);
            *(_OWORD *)__dst = v29;
          }
          if (*(char *)(v28 + 47) < 0)
          {
            sub_20BDDBFAC(&v90, *(void **)(v28 + 24), *(_QWORD *)(v28 + 32));
          }
          else
          {
            v30 = *(_OWORD *)(v28 + 24);
            v91 = *(_QWORD *)(v28 + 40);
            v90 = v30;
          }
          sub_20BDEBF8C((uint64_t *)v92, (const void ***)(v28 + 48));
          sub_20BDDC0E4(__p, "prune");
          sub_20BE01E1C((uint64_t)v92, (const void **)__p, &v87);
          if (SHIBYTE(v88) < 0)
          {
            v31 = *((_QWORD *)&v87 + 1) == 1 && *(_BYTE *)v87 == 49;
            operator delete((void *)v87);
          }
          else
          {
            v31 = SHIBYTE(v88) == 1 && v87 == 49;
          }
          if (v86 < 0)
            operator delete(__p[0]);
          sub_20BDDC0E4(__p, "replace");
          sub_20BE01E1C((uint64_t)v92, (const void **)__p, &v87);
          if (SHIBYTE(v88) < 0)
          {
            v32 = *((_QWORD *)&v87 + 1) == 1 && *(unsigned __int8 *)v87 == 49;
            operator delete((void *)v87);
          }
          else
          {
            v32 = SHIBYTE(v88) == 1 && v87 == 49;
          }
          if (v86 < 0)
            operator delete(__p[0]);
          v33 = sub_20BDEEBA4((uint64_t)v84, (const void **)__dst);
          v34 = v33;
          if (v6 == (uint64_t *)v33)
          {
            if (!v31)
            {
              v39 = *(_QWORD *)(a1 + 272);
              *(_QWORD *)&v87 = __dst;
              sub_20BDEEA20(v84, (const void **)__dst, (uint64_t)&unk_20CA52030, (__int128 **)&v87)[7] = v39;
              v40 = operator new(0x48uLL);
              v41 = (uint64_t)v40;
              if ((__dst[23] & 0x80000000) != 0)
              {
                sub_20BDDBFAC(v40, *(void **)__dst, *(unint64_t *)&__dst[8]);
              }
              else
              {
                *(_OWORD *)v40 = *(_OWORD *)__dst;
                v40[2] = *(_QWORD *)&__dst[16];
              }
              if (SHIBYTE(v91) < 0)
              {
                sub_20BDDBFAC((_BYTE *)(v41 + 24), (void *)v90, *((unint64_t *)&v90 + 1));
              }
              else
              {
                *(_OWORD *)(v41 + 24) = v90;
                *(_QWORD *)(v41 + 40) = v91;
              }
              sub_20BDEBF8C((uint64_t *)(v41 + 48), v92);
              sub_20BDE9D90(__p, v41);
              sub_20BDEA72C(v82, (__int128 *)__p);
              sub_20BE1287C(v83, v39 + 1);
              v64 = *v83;
              v65 = v4[1];
              *(_QWORD *)&v87 = *v4;
              *((_QWORD *)&v87 + 1) = v65;
              if (v65)
              {
                v66 = (unint64_t *)(v65 + 8);
                do
                  v67 = __ldxr(v66);
                while (__stxr(v67 + 1, v66));
              }
              v88 = i;
              sub_20BE12910((_QWORD *)(v64 + 24 * v39), (uint64_t)&v87);
              v68 = (std::__shared_weak_count *)*((_QWORD *)&v87 + 1);
              if (*((_QWORD *)&v87 + 1))
              {
                v69 = (unint64_t *)(*((_QWORD *)&v87 + 1) + 8);
                do
                  v70 = __ldaxr(v69);
                while (__stlxr(v70 - 1, v69));
                if (!v70)
                {
                  ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
                  std::__shared_weak_count::__release_weak(v68);
                }
              }
              sub_20BE12A34((uint64_t *)(a1 + 128), v39 + 1);
              v71 = (std::__shared_weak_count *)__p[1];
              if (__p[1])
              {
                v72 = (unint64_t *)((char *)__p[1] + 8);
                do
                  v73 = __ldaxr(v72);
                while (__stlxr(v73 - 1, v72));
                if (!v73)
                {
                  ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
                  std::__shared_weak_count::__release_weak(v71);
                }
              }
            }
          }
          else
          {
            v35 = *(_QWORD *)(v33 + 56);
            if (v31)
            {
              sub_20BE133F8((uint64_t)&v87, *(_QWORD *)(a1 + 104) + 24 * v35 + 24, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 104) + 24 * v35);
              v37 = v36;
              v38 = *(_QWORD *)(a1 + 112);
              while (v38 != v37)
              {
                v38 -= 24;
                *(_QWORD *)&v87 = v38;
                sub_20BE12BE4((void ***)&v87);
              }
              *(_QWORD *)(a1 + 112) = v37;
              sub_20BE134C8((uint64_t)&v87, (__int128 *)(*(_QWORD *)(a1 + 128) + 16 * v35 + 16), *(__int128 **)(a1 + 136), *(_QWORD *)(a1 + 128) + 16 * v35);
              v48 = v47;
              for (j = *(_QWORD *)(a1 + 136); j != v48; j -= 16)
              {
                v50 = *(std::__shared_weak_count **)(j - 8);
                if (v50)
                  std::__shared_weak_count::__release_weak(v50);
              }
              *(_QWORD *)(a1 + 136) = v48;
              v51 = *(_QWORD *)(a1 + 80);
              v52 = *(_QWORD *)(a1 + 88);
              v53 = v51 + 16 * v35;
              v54 = v53 + 16;
              if (v53 + 16 != v52)
              {
                v55 = v51 + 16 * v35;
                do
                {
                  sub_20BDE82DC(v55, (__int128 *)(v55 + 16));
                  v53 += 16;
                  v56 = v55 + 32;
                  v55 += 16;
                }
                while (v56 != v52);
                v54 = *(_QWORD *)(a1 + 88);
              }
              while (v54 != v53)
                pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v54 - 16));
              *(_QWORD *)(a1 + 88) = v53;
              sub_20BE10B40(v84, v34);
              v57 = *v84;
              if (*v84 != v6)
              {
                do
                {
                  v58 = v57[7];
                  if (v58 > v35)
                    v57[7] = v58 - 1;
                  v59 = (uint64_t *)v57[1];
                  if (v59)
                  {
                    do
                    {
                      v60 = v59;
                      v59 = (uint64_t *)*v59;
                    }
                    while (v59);
                  }
                  else
                  {
                    do
                    {
                      v60 = (uint64_t *)v57[2];
                      v61 = *v60 == (_QWORD)v57;
                      v57 = v60;
                    }
                    while (!v61);
                  }
                  v57 = v60;
                }
                while (v60 != v6);
              }
            }
            else
            {
              if (v32)
              {
                v42 = *v83 + 24 * v35;
                v45 = *(_QWORD *)(v42 + 8);
                v44 = (_QWORD *)(v42 + 8);
                v43 = v45;
                v46 = *(_QWORD *)(*v83 + 24 * v35);
                while (v43 != v46)
                  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v43 - 24));
                *v44 = v46;
                *((_QWORD *)&v87 + 1) = 0;
                v88 = 0;
                *(_QWORD *)&v87 = (char *)&v87 + 8;
                v62 = (uint64_t **)(*(_QWORD *)&(*v82)[16 * v35] + 48);
                if (v62 == (uint64_t **)&v87)
                {
                  v63 = 0;
                }
                else
                {
                  sub_20BDFC4AC(v62, (__int128 *)((char *)&v87 + 8), (__int128 *)((char *)&v87 + 8));
                  v63 = (_QWORD *)*((_QWORD *)&v87 + 1);
                }
                sub_20BDE9D48((uint64_t)&v87, v63);
              }
              v74 = *v83;
              v75 = v4[1];
              *(_QWORD *)&v87 = *v4;
              *((_QWORD *)&v87 + 1) = v75;
              if (v75)
              {
                v76 = (unint64_t *)(v75 + 8);
                do
                  v77 = __ldxr(v76);
                while (__stxr(v77 + 1, v76));
              }
              v88 = i;
              sub_20BE12910((_QWORD *)(v74 + 24 * v35), (uint64_t)&v87);
              v78 = (std::__shared_weak_count *)*((_QWORD *)&v87 + 1);
              if (*((_QWORD *)&v87 + 1))
              {
                v79 = (unint64_t *)(*((_QWORD *)&v87 + 1) + 8);
                do
                  v80 = __ldaxr(v79);
                while (__stlxr(v80 - 1, v79));
                if (!v80)
                {
                  ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
                  std::__shared_weak_count::__release_weak(v78);
                }
              }
              sub_20BE12AB0(*(_QWORD *)&(*v82)[16 * v35] + 48, v92);
            }
          }
          sub_20BDE9D48((uint64_t)v92, v92[1]);
          if (SHIBYTE(v91) < 0)
            operator delete((void *)v90);
          if ((__dst[23] & 0x80000000) != 0)
            operator delete(*(void **)__dst);
          result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v4 + 48))(*v4);
        }
      }
      v4 += 2;
    }
    while (v4 != *(_QWORD **)(a2 + 8));
  }
  return result;
}

void sub_20BE11998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a26);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE11AB0(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *i;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  _QWORD *v18;
  _QWORD *v19;
  char *v20;
  __int128 v21;
  int64x2_t v22;
  _OWORD *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD *exception;
  _QWORD *v30;
  void *__p[2];
  char v32;
  int64x2_t v33;
  _QWORD v34[2];
  int64x2_t *v35;
  int64x2_t v36;
  uint64_t v37;
  _QWORD *v38;

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_24C5191F0;
  *(_QWORD *)(a1 + 24) = *a2;
  v4 = a2[1];
  *(_QWORD *)(a1 + 32) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 40) = a3;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_QWORD *)(a1 + 144) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 152), 0);
  *(_OWORD *)(a1 + 216) = 0u;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 256) = a1 + 264;
  *(_QWORD *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_QWORD *)(a1 + 248) = 0;
  v7 = *(_QWORD *)(a1 + 24);
  if (!v7)
  {
    sub_20BDDBD68((uint64_t)&v35);
    sub_20BDDC1C8(&v36.i64[1], (uint64_t)"Invalid object in OrImpl(OrImplPtr, size_t)", 43);
    std::stringbuf::str();
    sub_20BDDBF20(&v33, (__int128 *)__p);
    if (v32 < 0)
      operator delete(__p[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v30 = sub_20BDDC09C(exception, (uint64_t)&v33);
    __cxa_throw(v30, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDE881C((_QWORD *)(a1 + 48), (uint64_t *)(v7 + 48));
  sub_20BDE881C((_QWORD *)(a1 + 64), (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 80) + 16 * *(_QWORD *)(a1 + 40)));
  v8 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 104) + 24 * *(_QWORD *)(a1 + 40));
  v33 = 0uLL;
  v34[0] = 0;
  sub_20BE0ECB0((char **)&v33, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8[1] - *v8) >> 3));
  for (i = (_QWORD *)*v8; i != (_QWORD *)v8[1]; i += 3)
  {
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD))(*(_QWORD *)*i + 80))(__p, *i, i[2]);
    v10 = v33.i64[1];
    if (v33.i64[1] >= v34[0])
    {
      v11 = (v33.i64[1] - v33.i64[0]) >> 4;
      v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 60)
        sub_20BDDF694();
      v13 = v34[0] - v33.i64[0];
      if ((v34[0] - v33.i64[0]) >> 3 > v12)
        v12 = v13 >> 3;
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
        v14 = 0xFFFFFFFFFFFFFFFLL;
      else
        v14 = v12;
      v38 = v34;
      v15 = (char *)sub_20BDEA2F0((uint64_t)v34, v14);
      v17 = &v15[16 * v11];
      *(_OWORD *)v17 = *(_OWORD *)__p;
      __p[0] = 0;
      __p[1] = 0;
      v18 = (_QWORD *)v33.i64[1];
      v19 = (_QWORD *)v33.i64[0];
      if (v33.i64[1] == v33.i64[0])
      {
        v22 = vdupq_n_s64(v33.u64[1]);
        v20 = &v15[16 * v11];
      }
      else
      {
        v20 = &v15[16 * v11];
        do
        {
          v21 = *((_OWORD *)v18 - 1);
          v18 -= 2;
          *((_OWORD *)v20 - 1) = v21;
          v20 -= 16;
          *v18 = 0;
          v18[1] = 0;
        }
        while (v18 != v19);
        v22 = v33;
      }
      v23 = v17 + 16;
      v33.i64[0] = (uint64_t)v20;
      v33.i64[1] = (uint64_t)(v17 + 16);
      v36 = v22;
      v24 = v34[0];
      v34[0] = &v15[16 * v16];
      v37 = v24;
      v35 = (int64x2_t *)v22.i64[0];
      sub_20BDEA324((uint64_t)&v35);
      v25 = (std::__shared_weak_count *)__p[1];
      v33.i64[1] = (uint64_t)v23;
      if (__p[1])
      {
        v26 = (unint64_t *)((char *)__p[1] + 8);
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
    }
    else
    {
      *(_OWORD *)v33.i64[1] = *(_OWORD *)__p;
      v33.i64[1] = v10 + 16;
    }
  }
  sub_20BE111D0(a1, (uint64_t)&v33);
  v35 = &v33;
  sub_20BDE9EB0((void ***)&v35);
  return a1;
}

void sub_20BE11E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *a11, pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *a12, uint64_t a13, pthread_mutex_t *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  uint64_t v23;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v24;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;

  sub_20BDDC194((std::exception *)&a19);
  sub_20BDDBE98((uint64_t)&a23);
  sub_20BDECAB8(a13, *(char **)(v23 + 264));
  v26 = *(std::__shared_weak_count **)(v23 + 248);
  if (v26)
    std::__shared_weak_count::__release_weak(v26);
  sub_20BDE9EB0((void ***)&a19);
  pthread_mutex_destroy(a14);
  a19 = a9;
  sub_20BE12C54((void ***)&a19);
  a19 = (uint64_t)v24 + 56;
  sub_20BE12B74((void ***)&a19);
  a19 = a10;
  sub_20BDE9EB0((void ***)&a19);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(a11);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v24);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(a12);
  v27 = *(std::__shared_weak_count **)(v23 + 16);
  if (v27)
    std::__shared_weak_count::__release_weak(v27);
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader((Alembic::AbcCoreAbstract::v12::ObjectReader *)v23);
  _Unwind_Resume(a1);
}

void sub_20BE11EF8(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  void **v4;

  *(_QWORD *)a1 = off_24C5191F0;
  sub_20BDECAB8(a1 + 256, *(char **)(a1 + 264));
  v2 = *(std::__shared_weak_count **)(a1 + 248);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v4 = (void **)(a1 + 216);
  sub_20BDE9EB0(&v4);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 152));
  v4 = (void **)(a1 + 128);
  sub_20BE12C54(&v4);
  v4 = (void **)(a1 + 104);
  sub_20BE12B74(&v4);
  v4 = (void **)(a1 + 80);
  sub_20BDE9EB0(&v4);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 64));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 48));
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(a1 + 24));
  v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader((Alembic::AbcCoreAbstract::v12::ObjectReader *)a1);
}

void sub_20BE11FBC(uint64_t a1)
{
  void *v1;

  sub_20BE11EF8(a1);
  operator delete(v1);
}

uint64_t sub_20BE11FD0(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t sub_20BE11FD8@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 56);
  *a2 = *(_QWORD *)(result + 48);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t sub_20BE11FFC@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 32);
  *a2 = *(_QWORD *)(result + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t sub_20BE12020@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  pthread_mutex_t *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  void *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v21;
  std::__shared_weak_count *v22;
  __int128 v23;

  v4 = (pthread_mutex_t *)(a1 + 152);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 152));
  *a2 = 0;
  a2[1] = 0;
  v5 = *(std::__shared_weak_count **)(a1 + 248);
  if (!v5
    || (v6 = std::__shared_weak_count::lock(v5), (a2[1] = (uint64_t)v6) == 0)
    || (v7 = *(_QWORD *)(a1 + 240), (*a2 = v7) == 0))
  {
    v8 = operator new(0x98uLL);
    sub_20BDE70B8(&v21, (_QWORD *)(a1 + 8));
    sub_20BE0FB7C((unint64_t)v8, &v21, (__int128 **)(a1 + 216));
    sub_20BE10610((uint64_t *)&v23, (uint64_t)v8);
    sub_20BDE82DC((uint64_t)a2, &v23);
    v9 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
    if (*((_QWORD *)&v23 + 1))
    {
      v10 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    v12 = v22;
    if (v22)
    {
      p_shared_owners = (unint64_t *)&v22->__shared_owners_;
      do
        v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    v16 = *a2;
    v15 = a2[1];
    if (v15)
    {
      v17 = (unint64_t *)(v15 + 16);
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }
    v19 = *(std::__shared_weak_count **)(a1 + 248);
    *(_QWORD *)(a1 + 240) = v16;
    *(_QWORD *)(a1 + 248) = v15;
    if (v19)
      std::__shared_weak_count::__release_weak(v19);
  }
  return pthread_mutex_unlock(v4);
}

void sub_20BE12164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pthread_mutex_t *v9;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v10;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v10);
  pthread_mutex_unlock(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE121B8(uint64_t a1)
{
  return (uint64_t)(*(_QWORD *)(a1 + 88) - *(_QWORD *)(a1 + 80)) >> 4;
}

uint64_t sub_20BE121C8(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  _BYTE v9[16];
  _QWORD v10[33];

  v2 = *(_QWORD *)(a1 + 80);
  if (a2 >= (*(_QWORD *)(a1 + 88) - v2) >> 4)
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"Out of range index in OrData::getChildHeader: ", 46);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return *(_QWORD *)(v2 + 16 * a2);
}

void sub_20BE12288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE122B0(uint64_t a1, const void **a2)
{
  uint64_t v3;

  v3 = sub_20BDEEBA4(a1 + 256, a2);
  if (a1 + 264 == v3)
    return 0;
  else
    return *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16 * *(_QWORD *)(v3 + 56));
}

uint64_t sub_20BE122F8@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result;
  uint64_t v6;
  uint64_t *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  void *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  __int128 v26;

  result = sub_20BDEEBA4(a1 + 256, a2);
  if (a1 + 264 == result)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    v6 = result;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 152));
    v7 = (uint64_t *)(*(_QWORD *)(a1 + 128) + 16 * *(_QWORD *)(v6 + 56));
    *a3 = 0;
    a3[1] = 0;
    v8 = (std::__shared_weak_count *)v7[1];
    if (!v8 || (v9 = std::__shared_weak_count::lock(v8), (a3[1] = (uint64_t)v9) == 0) || (v10 = *v7, *a3 = *v7, !v10))
    {
      v11 = operator new(0x118uLL);
      sub_20BDE70B8(&v24, (_QWORD *)(a1 + 8));
      sub_20BE11AB0((uint64_t)v11, &v24, *(_QWORD *)(v6 + 56));
      sub_20BE0F2B8((uint64_t *)&v26, (uint64_t)v11);
      sub_20BDE82DC((uint64_t)a3, &v26);
      v12 = (std::__shared_weak_count *)*((_QWORD *)&v26 + 1);
      if (*((_QWORD *)&v26 + 1))
      {
        v13 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      v15 = v25;
      if (v25)
      {
        p_shared_owners = (unint64_t *)&v25->__shared_owners_;
        do
          v17 = __ldaxr(p_shared_owners);
        while (__stlxr(v17 - 1, p_shared_owners));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      v18 = (_QWORD *)(*(_QWORD *)(a1 + 128) + 16 * *(_QWORD *)(v6 + 56));
      v20 = *a3;
      v19 = a3[1];
      if (v19)
      {
        v21 = (unint64_t *)(v19 + 16);
        do
          v22 = __ldxr(v21);
        while (__stxr(v22 + 1, v21));
      }
      v23 = (std::__shared_weak_count *)v18[1];
      *v18 = v20;
      v18[1] = v19;
      if (v23)
        std::__shared_weak_count::__release_weak(v23);
    }
    return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 152));
  }
  return result;
}

void sub_20BE1247C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pthread_mutex_t *v9;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v10;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v10);
  pthread_mutex_unlock(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE124D0@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5;
  pthread_mutex_t *v6;
  uint64_t *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  void *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  __int128 v26;

  if (a2 >= (uint64_t)(*(_QWORD *)(result + 88) - *(_QWORD *)(result + 80)) >> 4)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    v5 = result;
    v6 = (pthread_mutex_t *)(result + 152);
    pthread_mutex_lock((pthread_mutex_t *)(result + 152));
    v7 = (uint64_t *)(*(_QWORD *)(v5 + 128) + 16 * a2);
    *a3 = 0;
    a3[1] = 0;
    v8 = (std::__shared_weak_count *)v7[1];
    if (!v8 || (v9 = std::__shared_weak_count::lock(v8), (a3[1] = (uint64_t)v9) == 0) || (v10 = *v7, *a3 = *v7, !v10))
    {
      v11 = operator new(0x118uLL);
      sub_20BDE70B8(&v24, (_QWORD *)(v5 + 8));
      sub_20BE11AB0((uint64_t)v11, &v24, a2);
      sub_20BE0F2B8((uint64_t *)&v26, (uint64_t)v11);
      sub_20BDE82DC((uint64_t)a3, &v26);
      v12 = (std::__shared_weak_count *)*((_QWORD *)&v26 + 1);
      if (*((_QWORD *)&v26 + 1))
      {
        v13 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      v15 = v25;
      if (v25)
      {
        p_shared_owners = (unint64_t *)&v25->__shared_owners_;
        do
          v17 = __ldaxr(p_shared_owners);
        while (__stlxr(v17 - 1, p_shared_owners));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      v18 = (_QWORD *)(*(_QWORD *)(v5 + 128) + 16 * a2);
      v20 = *a3;
      v19 = a3[1];
      if (v19)
      {
        v21 = (unint64_t *)(v19 + 16);
        do
          v22 = __ldxr(v21);
        while (__stxr(v22 + 1, v21));
      }
      v23 = (std::__shared_weak_count *)v18[1];
      *v18 = v20;
      v18[1] = v19;
      if (v23)
        std::__shared_weak_count::__release_weak(v23);
    }
    return pthread_mutex_unlock(v6);
  }
  return result;
}

void sub_20BE12648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pthread_mutex_t *v9;
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *v10;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource(v10);
  pthread_mutex_unlock(v9);
  _Unwind_Resume(a1);
}

double sub_20BE1269C@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;

  sub_20BDE70B8(&v4, (_QWORD *)(a1 + 8));
  result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_20BE126D4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v11;
  std::__shared_weak_count *v12;

  v2 = *(_QWORD *)(a1 + 24);
  if (!v2)
    return 0;
  v4 = *(_QWORD *)(v2 + 104) + 24 * *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD **)v4;
  if (*(_QWORD *)(v4 + 8) - *(_QWORD *)v4 != 24)
    return 0;
  (*(void (**)(uint64_t *__return_ptr, _QWORD, _QWORD))(*(_QWORD *)*v3 + 80))(&v11, *v3, v3[2]);
  v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 88))(v11, a2);
  v7 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return v6;
}

void sub_20BE12794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE127A8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v11;
  std::__shared_weak_count *v12;

  v2 = *(_QWORD *)(a1 + 24);
  if (!v2)
    return 0;
  v4 = *(_QWORD *)(v2 + 104) + 24 * *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD **)v4;
  if (*(_QWORD *)(v4 + 8) - *(_QWORD *)v4 != 24)
    return 0;
  (*(void (**)(uint64_t *__return_ptr, _QWORD, _QWORD))(*(_QWORD *)*v3 + 80))(&v11, *v3, v3[2]);
  v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 96))(v11, a2);
  v7 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return v6;
}

void sub_20BE12868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&a9);
  _Unwind_Resume(a1);
}

void sub_20BE1287C(uint64_t *a1, unint64_t a2)
{
  void **v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  void **v8;

  v3 = (void **)a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_20BE12CDC(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 24 * a2;
    while (v3 != (void **)v7)
    {
      v3 -= 3;
      v8 = v3;
      sub_20BE12BE4(&v8);
    }
    a1[1] = v7;
  }
}

uint64_t sub_20BE12910(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _QWORD v16[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (v7 >= v6)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 3);
    v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
      sub_20BDDF694();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v10;
    v16[4] = result;
    v13 = (char *)sub_20BDE4FF4(result, v12);
    v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *(_OWORD *)v14 = *(_OWORD *)a2;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *((_QWORD *)v14 + 2) = *(_QWORD *)(a2 + 16);
    v16[2] = v14 + 24;
    sub_20BE13050(a1, v16);
    v8 = a1[1];
    result = sub_20BE130B4((uint64_t)v16);
  }
  else
  {
    *(_OWORD *)v7 = *(_OWORD *)a2;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(v7 + 16) = *(_QWORD *)(a2 + 16);
    v8 = v7 + 24;
    a1[1] = v7 + 24;
  }
  a1[1] = v8;
  return result;
}

void sub_20BE12A20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BE130B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_20BE12A34(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 4;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 16 * a2;
      while (v3 != v5)
      {
        v6 = *(std::__shared_weak_count **)(v3 - 8);
        if (v6)
          std::__shared_weak_count::__release_weak(v6);
        v3 -= 16;
      }
      a1[1] = v5;
    }
  }
  else
  {
    sub_20BE13100(a1, a2 - v4);
  }
}

uint64_t sub_20BE12AB0(uint64_t result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t **v4;
  uint64_t *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;
  __int128 *v9;

  v2 = a2 + 1;
  v3 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    v4 = (uint64_t **)result;
    do
    {
      result = sub_20BDDDEF8((uint64_t)v4, (const void **)v3 + 4);
      if (!result)
      {
        v9 = (__int128 *)(v3 + 4);
        v5 = sub_20BDDDFDC(v4, (const void **)v3 + 4, (uint64_t)&unk_20CA52030, &v9);
        result = (uint64_t)std::string::operator=((std::string *)(v5 + 7), (const std::string *)(v3 + 7));
      }
      v6 = (_QWORD *)v3[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v3[2];
          v8 = *v7 == (_QWORD)v3;
          v3 = v7;
        }
        while (!v8);
      }
      v3 = v7;
    }
    while (v7 != v2);
  }
  return result;
}

void sub_20BE12B74(void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        v6 = v4;
        sub_20BE12BE4(&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_20BE12BE4(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v4 - 24));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_20BE12C54(void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    sub_20BE12C94((uint64_t *)v2);
    operator delete(**a1);
  }
}

void sub_20BE12C94(uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  std::__shared_weak_count *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 16)
  {
    v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4)
      std::__shared_weak_count::__release_weak(v4);
  }
  a1[1] = v2;
}

void sub_20BE12CDC(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      sub_20BDDF694();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)sub_20BDE4FF4(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[24 * v8];
    v18 = &v12[24 * v11];
    v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    v17 = &v16[v14];
    sub_20BE12E40(a1, &v15);
    sub_20BE12FD0(&v15);
  }
}

void sub_20BE12E2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BE12FD0((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE12E40(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_20BE12EB4((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_20BE12EB4(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  sub_20BE12F54((uint64_t)v11);
  return v9;
}

uint64_t sub_20BE12F54(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_20BE12F88(a1);
  return a1;
}

void sub_20BE12F88(uint64_t a1)
{
  void **v1;
  void **v2;
  void **v3;

  v1 = *(void ***)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(void ***)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = v1;
    sub_20BE12BE4(&v3);
    v1 += 3;
  }
}

void **sub_20BE12FD0(void **a1)
{
  sub_20BE13000((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void sub_20BE13000(uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;
  void **v5;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    v4 = (void **)(i - 24);
    *(_QWORD *)(a1 + 16) = v4;
    v5 = v4;
    sub_20BE12BE4(&v5);
  }
}

_QWORD *sub_20BE13050(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  __int128 v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (_QWORD *)*result;
  v2 = (_QWORD *)result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)(v4 - 24) = v5;
    v4 -= 24;
    *v2 = 0;
    v2[1] = 0;
    *(_QWORD *)(v4 + 16) = v2[2];
  }
  a2[1] = v4;
  v6 = (_QWORD *)*result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_20BE130B4(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 24;
    pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(i - 24));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_20BE13100(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 4);
    if (v9 >> 60)
      sub_20BDDF694();
    v10 = v8 >> 4;
    v11 = v5 - *a1;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)sub_20BDEA2F0(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[16 * v10];
    v17 = &v13[16 * v12];
    bzero(v15, 16 * a2);
    v16 = &v15[16 * a2];
    sub_20BE13200(a1, &v14);
    sub_20BE13378(&v14);
  }
}

void sub_20BE131EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BE13378((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE13200(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_20BE13274((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_20BE13274(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  _OWORD *v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v8 = (_OWORD *)(a7 - 16);
    do
    {
      v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((_QWORD *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    v10 = v15;
  }
  v13 = 1;
  sub_20BE13304((uint64_t)v12);
  return v10;
}

uint64_t sub_20BE13304(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_20BE13338(a1);
  return a1;
}

void sub_20BE13338(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  std::__shared_weak_count *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3)
      std::__shared_weak_count::__release_weak(v3);
    v1 += 16;
  }
}

void **sub_20BE13378(void **a1)
{
  sub_20BE133A8((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void sub_20BE133A8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  std::__shared_weak_count *v4;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  while (v1 != v2)
  {
    *(_QWORD *)(a1 + 16) = v1 - 16;
    v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_weak(v4);
      v1 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

uint64_t sub_20BE133F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  v5 = a2;
  if (a2 == a3)
    return a2;
  v6 = a3;
  do
  {
    sub_20BE1346C((void **)a4);
    *(_OWORD *)a4 = *(_OWORD *)v5;
    *(_QWORD *)(a4 + 16) = *(_QWORD *)(v5 + 16);
    *(_QWORD *)v5 = 0;
    *(_QWORD *)(v5 + 8) = 0;
    *(_QWORD *)(v5 + 16) = 0;
    a4 += 24;
    v5 += 24;
  }
  while (v5 != v6);
  return v6;
}

void sub_20BE1346C(void **a1)
{
  char *v1;
  char *v3;
  void *v4;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
        pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v3 - 24));
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

__int128 *sub_20BE134C8(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  __int128 *v5;
  __int128 v7;
  std::__shared_weak_count *v8;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      v7 = *v5;
      *(_QWORD *)v5 = 0;
      *((_QWORD *)v5 + 1) = 0;
      v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8)
        std::__shared_weak_count::__release_weak(v8);
      ++v5;
      a4 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

double Alembic::AbcCoreLayer::v12::ReadArchive::operator()@<D0>(uint64_t a1@<X1>, _OWORD *a2@<X8>)
{
  void *v4;
  double result;
  __int128 v6;

  v4 = operator new(0xE0uLL);
  sub_20BE0ED64(v4, a1);
  sub_20BE135A4((uint64_t *)&v6, (uint64_t)v4);
  result = *(double *)&v6;
  *a2 = v6;
  return result;
}

void sub_20BE13590(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_20BE135A4(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_24C5192B8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  sub_20BDEA008((uint64_t)a1, v5, a2);
  return a1;
}

void sub_20BE13600(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void sub_20BE13624(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_20BE13638(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_20BE13650(uint64_t a1, uint64_t a2)
{
  if (sub_20BDE150C(a2, (uint64_t)&unk_24C519308))
    return a1 + 24;
  else
    return 0;
}

void Alembic::AbcCoreLayer::v12::SetPrune(uint64_t **a1, int a2)
{
  uint64_t *v3;
  std::string __p;
  void *v5[2];
  char v6;
  void **v7;

  if (a2)
  {
    sub_20BDDC0E4(v5, "prune");
    sub_20BDDC0E4(&__p, "1");
  }
  else
  {
    sub_20BDDC0E4(v5, "prune");
    sub_20BDDC0E4(&__p, "");
  }
  v7 = v5;
  v3 = sub_20BDDDFDC(a1, (const void **)v5, (uint64_t)&unk_20CA52160, (__int128 **)&v7);
  std::string::operator=((std::string *)(v3 + 7), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v6 < 0)
    operator delete(v5[0]);
}

void sub_20BE1377C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Alembic::AbcCoreLayer::v12::SetReplace(uint64_t **a1, int a2)
{
  uint64_t *v3;
  std::string __p;
  void *v5[2];
  char v6;
  void **v7;

  if (a2)
  {
    sub_20BDDC0E4(v5, "replace");
    sub_20BDDC0E4(&__p, "1");
  }
  else
  {
    sub_20BDDC0E4(v5, "replace");
    sub_20BDDC0E4(&__p, "");
  }
  v7 = v5;
  v3 = sub_20BDDDFDC(a1, (const void **)v5, (uint64_t)&unk_20CA52160, (__int128 **)&v7);
  std::string::operator=((std::string *)(v3 + 7), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v6 < 0)
    operator delete(v5[0]);
}

void sub_20BE138A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Alembic::AbcGeom::v12::GetIArchiveBounds(Alembic::Abc::v12::IArchive *a1@<X0>, uint64_t **a2@<X1>, uint64_t **a3@<X2>, uint64_t a4@<X8>)
{
  void *__p[2];
  char v8;
  _BYTE v9[96];
  int v10[12];

  Alembic::Abc::v12::IArchive::getTop(a1, (uint64_t)v9);
  Alembic::Abc::v12::IObject::getProperties((Alembic::Abc::v12::IObject *)v9, (uint64_t)v10);
  sub_20BDDC0E4(__p, ".childBnds");
  sub_20BE13A80(a4, v10, (uint64_t)__p, a2, a3);
  if (v8 < 0)
    operator delete(__p[0]);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v10);
  Alembic::Abc::v12::IObject::~IObject((Alembic::Abc::v12::IObject *)v9);
}

void sub_20BE13970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  uint64_t v16;

  if (a15 < 0)
    operator delete(__p);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)(v16 - 80));
  Alembic::Abc::v12::IObject::~IObject((Alembic::Abc::v12::IObject *)&a16);
  _Unwind_Resume(a1);
}

void Alembic::AbcGeom::v12::CreateOArchiveBounds(Alembic::Abc::v12::OArchive *a1@<X0>, uint64_t **a2@<X1>, uint64_t **a3@<X2>, uint64_t **a4@<X3>, uint64_t a5@<X8>)
{
  void *__p[2];
  char v10;
  _BYTE v11[56];
  int v12[12];

  Alembic::Abc::v12::OArchive::getTop(a1, (uint64_t)v11);
  Alembic::Abc::v12::OObject::getProperties((Alembic::Abc::v12::OObject *)v11, (uint64_t)v12);
  sub_20BDDC0E4(__p, ".childBnds");
  sub_20BE1415C(a5, v12, (uint64_t)__p, a2, a3, a4);
  if (v10 < 0)
    operator delete(__p[0]);
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v12);
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)v11);
}

void sub_20BE13A44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a14 < 0)
    operator delete(__p);
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)&a22);
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE13A80(uint64_t a1, int *a2, uint64_t a3, uint64_t **a4, uint64_t **a5)
{
  int v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  void **v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *exception;
  _QWORD *v42;
  _QWORD *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  uint64_t v49;
  void *v50[2];
  char v51;
  void *__p[2];
  unsigned __int8 v53;
  __int128 v54;
  _QWORD v55[34];
  std::__shared_weak_count *v56;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62[4];
  std::__shared_weak_count *v63;
  int v64;
  uint64_t v65;

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v10 = *a2;
  *((_QWORD *)&v54 + 1) = 0;
  v55[0] = 0;
  *(_QWORD *)&v54 = (char *)&v54 + 8;
  v59 = 0;
  v60 = 0;
  v61 = v10;
  sub_20BDEBF8C(v62, (const void ***)&v54);
  v62[3] = 0;
  v63 = 0;
  v64 = 0;
  v65 = 1;
  sub_20BDE9D48((uint64_t)&v54, *((_QWORD **)&v54 + 1));
  sub_20BE02E30(a4, (uint64_t)&v61);
  sub_20BE02E30(a5, (uint64_t)&v61);
  *(_DWORD *)a1 = v61;
  v57 = a1;
  v58 = "ITypedScalarProperty::ITypedScalarProperty()";
  v12 = *((_QWORD *)a2 + 4);
  v11 = (std::__shared_weak_count *)*((_QWORD *)a2 + 5);
  v55[33] = v12;
  v56 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  if (!v12)
  {
    sub_20BDDBD68((uint64_t)&v54);
    v40 = sub_20BDDC1C8(v55, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_20BDDC1C8(v40, (uint64_t)"ITypedScalarProperty ctor", 25);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v50);
    if (v51 < 0)
      operator delete(v50[0]);
    exception = __cxa_allocate_exception(0x20uLL);
    v42 = sub_20BDDC09C(exception, (uint64_t)__p);
    __cxa_throw(v42, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v12 + 80))(v12, a3);
  v16 = v15;
  if (!v15)
  {
    sub_20BDDBD68((uint64_t)&v54);
    v43 = sub_20BDDC1C8(v55, (uint64_t)"Nonexistent scalar property: ", 29);
    v44 = *(char *)(a3 + 23);
    if (v44 >= 0)
      v45 = a3;
    else
      v45 = *(_QWORD *)a3;
    if (v44 >= 0)
      v46 = *(unsigned __int8 *)(a3 + 23);
    else
      v46 = *(_QWORD *)(a3 + 8);
    sub_20BDDC1C8(v43, v45, v46);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v50);
    if (v51 < 0)
      operator delete(v50[0]);
    v47 = __cxa_allocate_exception(0x20uLL);
    v48 = sub_20BDDC09C(v47, (uint64_t)__p);
    __cxa_throw(v48, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v18 = *(_DWORD *)(v15 + 56) == 11 && *(_BYTE *)(v15 + 60) == 6 && *(_DWORD *)(v15 + 24) == 1;
  if (!v18 || (sub_20BE14070(v15 + 32, v65) & 1) == 0)
  {
    sub_20BDDBD68((uint64_t)&v54);
    v29 = sub_20BDDC1C8(v55, (uint64_t)"Incorrect match of header datatype: ", 36);
    v30 = sub_20BDE00F4(v29, (int *)(v16 + 56));
    v31 = sub_20BDDC1C8(v30, (uint64_t)" to expected: ", 14);
    v49 = 0x60000000BLL;
    v32 = sub_20BDE00F4(v31, (int *)&v49);
    v33 = sub_20BDDC1C8(v32, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_20BDDC0E4(v50, "interpretation");
    sub_20BE01E1C(v16 + 32, (const void **)v50, __p);
    if ((v53 & 0x80u) == 0)
      v34 = __p;
    else
      v34 = (void **)__p[0];
    if ((v53 & 0x80u) == 0)
      v35 = v53;
    else
      v35 = (uint64_t)__p[1];
    v36 = sub_20BDDC1C8(v33, (uint64_t)v34, v35);
    v37 = sub_20BDDC1C8(v36, (uint64_t)" to expected: ", 14);
    sub_20BDDC1C8(v37, (uint64_t)"box", 3);
    if ((char)v53 < 0)
      operator delete(__p[0]);
    if (v51 < 0)
      operator delete(v50[0]);
    std::stringbuf::str();
    sub_20BDDBF20(__p, (__int128 *)v50);
    if (v51 < 0)
      operator delete(v50[0]);
    v38 = __cxa_allocate_exception(0x20uLL);
    v39 = sub_20BDDC09C(v38, (uint64_t)__p);
    __cxa_throw(v39, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v12 + 88))(&v54, v12, a3);
  sub_20BDE82DC(a1 + 32, &v54);
  v19 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
  if (*((_QWORD *)&v54 + 1))
  {
    v20 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v56;
  if (v56)
  {
    v23 = (unint64_t *)&v56->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v63;
  if (v63)
  {
    v26 = (unint64_t *)&v63->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  sub_20BDE9D48((uint64_t)v62, (_QWORD *)v62[1]);
  return a1;
}

void sub_20BE13F0C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,uint64_t a25)
{
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  void *v30;

  sub_20BDDC194((std::exception *)&__p);
  sub_20BDDBE98((uint64_t)&a24);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v27 - 192));
  v30 = __cxa_begin_catch(a1);
  sub_20BDEBF08(v26);
  MEMORY[0x212B929D0](v25, "");
  if (a2 == 2)
    sub_20BE02570(v27 - 176, (uint64_t)v30);
  else
    sub_20BE02504(v27 - 176, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE13C58);
}

void sub_20BE14030()
{
  uint64_t v0;

  sub_20BE02EB0(v0 - 144);
  JUMPOUT(0x20BE14060);
}

uint64_t sub_20BE14070(uint64_t a1, int a2)
{
  _BOOL8 v2;
  void *__p[2];
  char v8;
  void *v9[2];
  char v10;

  if (a2)
    return 1;
  sub_20BDDC0E4(__p, "interpretation");
  sub_20BE01E1C(a1, (const void **)__p, v9);
  if (v10 < 0)
  {
    v2 = v9[1] == (void *)3 && *(_WORD *)v9[0] == 28514 && *((_BYTE *)v9[0] + 2) == 120;
    operator delete(v9[0]);
  }
  else
  {
    v2 = v10 == 3 && LOWORD(v9[0]) == 28514 && BYTE2(v9[0]) == 120;
  }
  if (v8 < 0)
    operator delete(__p[0]);
  return v2;
}

void sub_20BE14140(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BE1415C(uint64_t a1, int *a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t **a6)
{
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  int v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t *v20;
  int v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  *(_DWORD *)a1 = 2;
  sub_20BDDC0E4((_QWORD *)(a1 + 8), "");
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v12 = (std::__shared_weak_count *)*((_QWORD *)a2 + 5);
  v22 = *((_QWORD *)a2 + 4);
  v23 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v15 = *a2;
  LODWORD(v20) = 1;
  v21 = v15;
  sub_20BE14264((int *)a1, &v22, a3, &v20, a4, a5, a6);
  v16 = v23;
  if (v23)
  {
    v17 = (unint64_t *)&v23->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  return a1;
}

void sub_20BE14248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void **v3;
  va_list va;

  va_start(va, a3);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  Alembic::Abc::v12::OScalarProperty::~OScalarProperty(v3);
  _Unwind_Resume(a1);
}

void sub_20BE14264(int *a1, uint64_t *a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t **a6, uint64_t **a7)
{
  uint64_t *v14;
  void *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *size;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  _QWORD *exception;
  _QWORD *v36;
  uint64_t p_p;
  std::__shared_weak_count *v38;
  std::string __str;
  void *__p;
  std::__shared_weak_count *v41;
  char v42;
  uint64_t *v43;
  _QWORD *v44;
  _QWORD v45[37];
  int v46;
  const void **v47[3];
  void *v48;
  std::__shared_weak_count *v49;
  unsigned int v50;
  uint64_t v51;

  v44 = 0;
  v45[0] = 0;
  v43 = (uint64_t *)&v44;
  v45[35] = 0;
  v45[36] = 0;
  v46 = 2;
  sub_20BDEBF8C((uint64_t *)v47, (const void ***)&v43);
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 1;
  sub_20BDE9D48((uint64_t)&v43, v44);
  sub_20BE02E30(a4, (uint64_t)&v46);
  sub_20BE02E30(a5, (uint64_t)&v46);
  sub_20BE02E30(a6, (uint64_t)&v46);
  sub_20BE02E30(a7, (uint64_t)&v46);
  *a1 = v46;
  v45[33] = a1;
  v45[34] = "OTypedScalarProperty::init()";
  if (!*a2)
  {
    sub_20BDDBD68((uint64_t)&v43);
    sub_20BDDC1C8(v45, (uint64_t)"NULL CompoundPropertyWriterPtr", 30);
    std::stringbuf::str();
    sub_20BDDBF20(&__p, (__int128 *)&__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    exception = __cxa_allocate_exception(0x20uLL);
    v36 = sub_20BDDC09C(exception, (uint64_t)&__p);
    __cxa_throw(v36, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  sub_20BDEBF8C((uint64_t *)&v43, v47);
  sub_20BDDC0E4(&__p, "interpretation");
  sub_20BDDC0E4(&__str, "box");
  p_p = (uint64_t)&__p;
  v14 = sub_20BDDDFDC(&v43, (const void **)&__p, (uint64_t)&unk_20CA52161, (__int128 **)&p_p);
  std::string::operator=((std::string *)(v14 + 7), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v42 < 0)
    operator delete(__p);
  v15 = v48;
  __p = v48;
  v41 = v49;
  if (v49)
  {
    p_shared_owners = (unint64_t *)&v49->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }
  v18 = *a2;
  if (v15)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v18 + 24))(&p_p);
    (*(void (**)(std::string *__return_ptr))(*(_QWORD *)p_p + 24))(&__str);
    v19 = (*(uint64_t (**)(std::string::size_type, void *))(*(_QWORD *)__str.__r_.__value_.__l.__data_ + 48))(__str.__r_.__value_.__r.__words[0], v15);
    size = (std::__shared_weak_count *)__str.__r_.__value_.__l.__size_;
    if (__str.__r_.__value_.__l.__size_)
    {
      v21 = (unint64_t *)(__str.__r_.__value_.__l.__size_ + 8);
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
    }
    v23 = v38;
    if (v38)
    {
      v24 = (unint64_t *)&v38->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    v18 = *a2;
  }
  else
  {
    v19 = v50;
  }
  p_p = 0x60000000BLL;
  (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, uint64_t **, uint64_t *, uint64_t))(*(_QWORD *)v18 + 96))(&__str, v18, a3, &v43, &p_p, v19);
  sub_20BDE82DC((uint64_t)(a1 + 8), (__int128 *)&__str);
  v26 = (std::__shared_weak_count *)__str.__r_.__value_.__l.__size_;
  if (__str.__r_.__value_.__l.__size_)
  {
    v27 = (unint64_t *)(__str.__r_.__value_.__l.__size_ + 8);
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = v41;
  if (v41)
  {
    v30 = (unint64_t *)&v41->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  sub_20BDE9D48((uint64_t)&v43, v44);
  v32 = v49;
  if (v49)
  {
    v33 = (unint64_t *)&v49->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  sub_20BDE9D48((uint64_t)v47, v47[1]);
}

void sub_20BE14624(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,uint64_t a26)
{
  uint64_t v26;
  uint64_t v27;
  void *v30;

  sub_20BDDC194((std::exception *)&__p);
  sub_20BDDBE98((uint64_t)&a25);
  v30 = __cxa_begin_catch(a1);
  sub_20BDEBF08((_QWORD *)(v26 + 32));
  MEMORY[0x212B929D0](v26 + 8, "");
  if (a2 == 2)
    sub_20BE02570(v27 - 184, (uint64_t)v30);
  else
    sub_20BE02504(v27 - 184, 0);
  __cxa_end_catch();
  JUMPOUT(0x20BE1454CLL);
}

void sub_20BE14768()
{
  uint64_t v0;

  sub_20BE02EB0(v0 - 152);
  JUMPOUT(0x20BE14798);
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesQuadrics(unsigned int a1)
{
  if (a1 > 4)
    return 0;
  else
    return qword_20CA52188[a1];
}

BOOL Alembic::AbcGeom::v12::GeometryScopeNumValuesPolygon(unsigned int a1, uint64_t a2)
{
  if (a1 - 2 >= 3)
    return a1 < 2;
  else
    return a2;
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesPointsPolygons(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  result = 1;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = a2;
      break;
    case 2:
    case 3:
      result = a3;
      break;
    case 4:
      result = a4;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

BOOL Alembic::AbcGeom::v12::GeometryScopeNumValuesPoints(unsigned int a1, uint64_t a2)
{
  if (a1 - 2 >= 3)
    return a1 < 2;
  else
    return a2;
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesSubdivisionMesh(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  result = 1;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = a2;
      break;
    case 2:
    case 3:
      result = a3;
      break;
    case 4:
      result = a4;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesBilinearPatch(unsigned int a1)
{
  if (a1 > 4)
    return 0;
  else
    return qword_20CA52188[a1];
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesBicubicPatch(unsigned int a1)
{
  if (a1 > 4)
    return 0;
  else
    return qword_20CA521B0[a1];
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesBilinearPatchMesh(int a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;

  v5 = 1;
  v6 = (a4 - a5) * (a2 - a3);
  if (a1 != 1)
    v6 = 0;
  if (a1)
    v5 = v6;
  if ((a1 - 2) >= 3)
    return v5;
  else
    return a4 * a2;
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesBicubicPatchMesh(int a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  v6 = a2 - 3;
  v7 = a4 - 3;
  result = 1;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = v7 * v6;
      break;
    case 2:
    case 4:
      result = (v7 + a5) * (v6 + a3);
      break;
    case 3:
      result = a4 * a2;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesNuPatch(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = 1;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = a2 - a3 + 1 + (a2 - a3 + 1) * (a4 - a5);
      break;
    case 2:
    case 4:
      result = (a4 - a5 + 2) * (a2 - a3 + 2);
      break;
    case 3:
      result = a4 * a2;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesLinearCurves(int a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;

  v4 = 1;
  v5 = a4 - (a2 << a3);
  if (a1 != 1)
    v5 = 0;
  if (a1)
    v4 = v5;
  if ((a1 - 2) >= 3)
    return v4;
  else
    return a4;
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesCubicCurves(int a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;

  result = 1;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = a4 - a2;
      break;
    case 2:
    case 4:
      if (a3)
        v6 = 0;
      else
        v6 = a2;
      result = a4 - v6;
      break;
    case 3:
      result = a4;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

void Alembic::AbcGeom::v12::SetIsUV(uint64_t **a1, char a2)
{
  uint64_t *v3;
  std::string __p;
  void *v5[2];
  char v6;
  void **v7;

  if ((a2 & 1) == 0)
  {
    sub_20BDDC0E4(v5, "notUV");
    sub_20BDDC0E4(&__p, "1");
    v7 = v5;
    v3 = sub_20BDDDFDC(a1, (const void **)v5, (uint64_t)&unk_20CA52181, (__int128 **)&v7);
    std::string::operator=((std::string *)(v3 + 7), &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (v6 < 0)
      operator delete(v5[0]);
  }
}

void sub_20BE14AD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL Alembic::AbcGeom::v12::isUV(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  _BOOL8 v5;
  void **v6;
  void *v9[2];
  char v10;
  void *__p[2];
  char v12;

  v2 = a1 + 32;
  v3 = sub_20BE14C08(a1 + 32);
  v4 = sub_20BE14E80(a1, 0);
  v5 = 0;
  if (!v4)
    return v5;
  sub_20BDDC0E4(v9, "notUV");
  sub_20BE01E1C(v2, (const void **)v9, __p);
  if (v12 < 0)
  {
    if (__p[1] != (void *)1)
      goto LABEL_10;
    v6 = (void **)__p[0];
  }
  else
  {
    if (v12 != 1)
      goto LABEL_10;
    v6 = __p;
  }
  if (*(_BYTE *)v6 == 49)
  {
    v5 = 0;
    if ((v12 & 0x80000000) == 0)
      goto LABEL_18;
    goto LABEL_17;
  }
LABEL_10:
  v5 = v3 == 4 || (v3 & 0xFFFFFFFE) == 2;
  if ((v12 & 0x80000000) == 0)
    goto LABEL_18;
LABEL_17:
  operator delete(__p[0]);
LABEL_18:
  if (v10 < 0)
    operator delete(v9[0]);
  return v5;
}

void sub_20BE14BEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BE14C08(uint64_t a1)
{
  uint64_t v2;
  uint64_t v6;
  _BYTE *v8;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned int v15;
  int v16;
  void *__p[2];
  char v19;
  void *v20;
  uint64_t v21;
  unsigned __int8 v22;

  sub_20BDDC0E4(__p, "geoScope");
  sub_20BE01E1C(a1, (const void **)__p, &v20);
  if (v19 < 0)
    operator delete(__p[0]);
  v2 = v22;
  if ((v22 & 0x80) == 0)
  {
    if (!v22)
      return v2;
    if (v22 == 3)
    {
      if ((unsigned __int16)v20 == 28515 && BYTE2(v20) == 110)
        return 0;
      if ((unsigned __int16)v20 == 28277 && BYTE2(v20) == 105)
      {
        v13 = 1;
        goto LABEL_68;
      }
      if ((unsigned __int16)v20 != 24950 || BYTE2(v20) != 114)
        goto LABEL_39;
      return 2;
    }
    return 127;
  }
  v6 = v21;
  if (v21 == 3 && *(_WORD *)v20 == 28515 && *((_BYTE *)v20 + 2) == 110)
  {
    v13 = 0;
    goto LABEL_68;
  }
  if (!v21)
  {
    v13 = 0;
LABEL_69:
    v8 = v20;
    goto LABEL_70;
  }
  v8 = v20;
  if (v21 != 3)
    goto LABEL_32;
  if (*(_WORD *)v20 == 28277 && *((_BYTE *)v20 + 2) == 105)
  {
    v13 = 1;
    goto LABEL_69;
  }
  v8 = v20;
  v6 = v21;
LABEL_32:
  if (v6 != 3)
    goto LABEL_60;
  if (*(_WORD *)v8 == 24950 && v8[2] == 114)
  {
    v13 = 2;
    goto LABEL_68;
  }
  if ((v22 & 0x80) != 0)
  {
    v8 = v20;
    if (v21 == 3)
    {
      if (*(_WORD *)v20 == 29814 && *((_BYTE *)v20 + 2) == 120)
      {
        v13 = 3;
        goto LABEL_69;
      }
      v12 = (unsigned __int16 *)v20;
      goto LABEL_58;
    }
LABEL_60:
    v13 = 127;
LABEL_70:
    operator delete(v8);
    return v13;
  }
  if (v22 != 3)
    return 127;
LABEL_39:
  if ((unsigned __int16)v20 == 29814 && BYTE2(v20) == 120)
  {
    v13 = 3;
    goto LABEL_68;
  }
  v12 = (unsigned __int16 *)&v20;
LABEL_58:
  v15 = bswap32(*v12) >> 16;
  if (v15 == 26230)
  {
    v16 = *((unsigned __int8 *)v12 + 2) - 114;
  }
  else if (v15 < 0x6676)
  {
    v16 = -1;
  }
  else
  {
    v16 = 1;
  }
  if (v16)
    v13 = 127;
  else
    v13 = 4;
LABEL_68:
  if ((v22 & 0x80) != 0)
    goto LABEL_69;
  return v13;
}

void sub_20BE14E64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BE14E80(uint64_t a1, int a2)
{
  int v3;
  uint64_t v4;
  void **v5;
  uint64_t v7;
  void *v9;
  int v10;
  char v12;
  void **v13;
  void *v14[2];
  char v15;
  void *__p[2];
  char v17;
  void *v18[2];
  char v19;
  void *v20[2];
  char v21;

  v3 = *(_DWORD *)(a1 + 24);
  if (v3 == 2)
  {
    if (*(_DWORD *)(a1 + 56) == 10 && *(_BYTE *)(a1 + 60) == 2)
      return sub_20BE15084(a1 + 32, a2);
  }
  else if (!v3)
  {
    v4 = a1 + 32;
    sub_20BDDC0E4(v18, "podName");
    sub_20BE01E1C(v4, (const void **)v18, v20);
    if (v21 < 0)
    {
      if (v20[1] != (void *)9)
      {
        v7 = 0;
LABEL_33:
        operator delete(v20[0]);
LABEL_34:
        if (v19 < 0)
          operator delete(v18[0]);
        return v7;
      }
      v5 = (void **)v20[0];
    }
    else
    {
      if (v21 != 9)
      {
        v7 = 0;
        goto LABEL_34;
      }
      v5 = v20;
    }
    v9 = *v5;
    v10 = *((unsigned __int8 *)v5 + 8);
    if (v9 == (void *)0x5F323374616F6C66 && v10 == 116)
    {
      sub_20BDDC0E4(v14, "podExtent");
      sub_20BE01E1C(v4, (const void **)v14, __p);
      v12 = v17;
      if (v17 >= 0)
        v13 = __p;
      else
        v13 = (void **)__p[0];
      if (atoi((const char *)v13) == 2)
      {
        v7 = sub_20BE15084(v4, a2);
        v12 = v17;
      }
      else
      {
        v7 = 0;
      }
      if (v12 < 0)
        operator delete(__p[0]);
      if (v15 < 0)
        operator delete(v14[0]);
      if ((v21 & 0x80) == 0)
        goto LABEL_34;
    }
    else
    {
      v7 = 0;
      if ((v21 & 0x80) == 0)
        goto LABEL_34;
    }
    goto LABEL_33;
  }
  return 0;
}

void sub_20BE15020(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a20 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BE15084(uint64_t a1, int a2)
{
  _BOOL8 v2;
  void *__p[2];
  char v8;
  void *v9[2];
  char v10;

  if (a2)
    return 1;
  sub_20BDDC0E4(__p, "interpretation");
  sub_20BE01E1C(a1, (const void **)__p, v9);
  if (v10 < 0)
  {
    v2 = v9[1] == (void *)6 && *(_DWORD *)v9[0] == 1952671094 && *((_WORD *)v9[0] + 2) == 29295;
    operator delete(v9[0]);
  }
  else
  {
    v2 = v10 == 6 && LODWORD(v9[0]) == 1952671094 && WORD2(v9[0]) == 29295;
  }
  if (v8 < 0)
    operator delete(__p[0]);
  return v2;
}

void sub_20BE1515C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

Alembic::AbcGeom::v12::FilmBackXformOp *Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  uint64_t v3;

  *(_DWORD *)this = 1;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  v3 = 0;
  sub_20BE15BCC((_QWORD *)this + 4, 2uLL, &v3);
  return this;
}

void sub_20BE151D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

int *Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(int *a1, int a2, __int128 *a3)
{
  __int128 v4;
  void **v5;
  void *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;

  *a1 = a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_20BDDBFAC((_BYTE *)a1 + 8, *(void **)a3, *((_QWORD *)a3 + 1));
    a2 = *a1;
  }
  else
  {
    v4 = *a3;
    *((_QWORD *)a1 + 3) = *((_QWORD *)a3 + 2);
    *(_OWORD *)(a1 + 2) = v4;
  }
  *((_QWORD *)a1 + 4) = 0;
  *((_QWORD *)a1 + 5) = 0;
  v5 = (void **)(a1 + 8);
  *((_QWORD *)a1 + 6) = 0;
  if (a2 == 2)
  {
    v10 = 0;
    sub_20BE15BCC(&v11, 9uLL, &v10);
    v6 = *v5;
    if (*v5)
    {
      *((_QWORD *)a1 + 5) = v6;
      operator delete(v6);
      *v5 = 0;
      *((_QWORD *)a1 + 5) = 0;
      *((_QWORD *)a1 + 6) = 0;
    }
    v7 = (_QWORD *)v11;
    *((_OWORD *)a1 + 2) = v11;
    *((_QWORD *)a1 + 6) = v12;
    *v7 = 0x3FF0000000000000;
    v7[4] = 0x3FF0000000000000;
    v7[8] = 0x3FF0000000000000;
  }
  else
  {
    if (a2 == 1)
    {
      v10 = 0;
      sub_20BE15BCC(&v11, 2uLL, &v10);
    }
    else
    {
      if (a2)
        return a1;
      v10 = 0x3FF0000000000000;
      sub_20BE15BCC(&v11, 2uLL, &v10);
    }
    v8 = *v5;
    if (*v5)
    {
      *((_QWORD *)a1 + 5) = v8;
      operator delete(v8);
      *v5 = 0;
      *((_QWORD *)a1 + 5) = 0;
      *((_QWORD *)a1 + 6) = 0;
    }
    *((_OWORD *)a1 + 2) = v11;
    *((_QWORD *)a1 + 6) = v12;
  }
  return a1;
}

void sub_20BE15320(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 40) = v5;
    operator delete(v5);
  }
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(uint64_t a1, const std::string *a2)
{
  void **v3;
  uint64_t v4;
  int v5;
  void *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v10;
  std::string v11;

  *(_OWORD *)(a1 + 8) = 0u;
  v3 = (void **)(a1 + 8);
  v4 = a1 + 32;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
  {
    if (a2->__r_.__value_.__l.__size_)
    {
      v5 = *(unsigned __int8 *)a2->__r_.__value_.__l.__data_;
      goto LABEL_6;
    }
LABEL_12:
    *(_DWORD *)a1 = 1;
    v10 = 0;
    sub_20BE15BCC(&v11, 2uLL, &v10);
    goto LABEL_20;
  }
  if (!*((_BYTE *)&a2->__r_.__value_.__s + 23))
    goto LABEL_12;
  v5 = a2->__r_.__value_.__s.__data_[0];
LABEL_6:
  if (v5 == 109)
  {
    *(_DWORD *)a1 = 2;
    std::string::basic_string(&v11, a2, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v10);
    if (*(char *)(a1 + 31) < 0)
      operator delete(*v3);
    *(std::string *)v3 = v11;
    v10 = 0;
    sub_20BE15BCC(&v11, 9uLL, &v10);
    v6 = *(void **)v4;
    if (*(_QWORD *)v4)
    {
      *(_QWORD *)(a1 + 40) = v6;
      operator delete(v6);
      *(_QWORD *)v4 = 0;
      *(_QWORD *)(v4 + 8) = 0;
      *(_QWORD *)(v4 + 16) = 0;
    }
    v7 = (_QWORD *)v11.__r_.__value_.__r.__words[0];
    *(std::string *)(a1 + 32) = v11;
    *v7 = 0x3FF0000000000000;
    v7[4] = 0x3FF0000000000000;
    v7[8] = 0x3FF0000000000000;
    return a1;
  }
  if (v5 == 115)
  {
    *(_DWORD *)a1 = 0;
    std::string::basic_string(&v11, a2, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v10);
    if (*(char *)(a1 + 31) < 0)
      operator delete(*v3);
    *(std::string *)v3 = v11;
    v10 = 0x3FF0000000000000;
    sub_20BE15BCC(&v11, 2uLL, &v10);
  }
  else
  {
    *(_DWORD *)a1 = 1;
    std::string::basic_string(&v11, a2, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v10);
    if (*(char *)(a1 + 31) < 0)
      operator delete(*v3);
    *(std::string *)v3 = v11;
    v10 = 0;
    sub_20BE15BCC(&v11, 2uLL, &v10);
  }
LABEL_20:
  v8 = *(void **)v4;
  if (*(_QWORD *)v4)
  {
    *(_QWORD *)(a1 + 40) = v8;
    operator delete(v8);
    *(_QWORD *)v4 = 0;
    *(_QWORD *)(v4 + 8) = 0;
    *(_QWORD *)(v4 + 16) = 0;
  }
  *(std::string *)(a1 + 32) = v11;
  return a1;
}

void sub_20BE1554C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v5 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 40) = v5;
    operator delete(v5);
  }
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v3);
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::AbcGeom::v12::FilmBackXformOp::getType(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  return *(unsigned int *)this;
}

char *Alembic::AbcGeom::v12::FilmBackXformOp::getHint@<X0>(char *this@<X0>, uint64_t a2@<X8>)
{
  if (this[31] < 0)
    return (char *)sub_20BDDBFAC((_BYTE *)a2, *((void **)this + 1), *((_QWORD *)this + 2));
  *(_OWORD *)a2 = *(_OWORD *)(this + 8);
  *(_QWORD *)(a2 + 16) = *((_QWORD *)this + 3);
  return this;
}

_QWORD *Alembic::AbcGeom::v12::FilmBackXformOp::getTypeAndHint@<X0>(Alembic::AbcGeom::v12::FilmBackXformOp *this@<X0>, _QWORD *a2@<X8>)
{
  if (*(_DWORD *)this > 2u)
    return sub_20BDDC0E4(a2, "");
  else
    return (_QWORD *)std::operator+<char>();
}

uint64_t Alembic::AbcGeom::v12::FilmBackXformOp::getNumChannels(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  return (uint64_t)(*((_QWORD *)this + 5) - *((_QWORD *)this + 4)) >> 3;
}

double Alembic::AbcGeom::v12::FilmBackXformOp::getChannelValue(Alembic::AbcGeom::v12::FilmBackXformOp *this, unint64_t a2)
{
  uint64_t v2;
  double result;

  v2 = *((_QWORD *)this + 4);
  result = 0.0;
  if (a2 <= (*((_QWORD *)this + 5) - v2) >> 3)
    return *(double *)(v2 + 8 * a2);
  return result;
}

uint64_t Alembic::AbcGeom::v12::FilmBackXformOp::setChannelValue(uint64_t this, unint64_t a2, double a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(this + 32);
  if (a2 < (*(_QWORD *)(this + 40) - v3) >> 3)
    *(double *)(v3 + 8 * a2) = a3;
  return this;
}

BOOL Alembic::AbcGeom::v12::FilmBackXformOp::isTranslateOp(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  return *(_DWORD *)this == 1;
}

BOOL Alembic::AbcGeom::v12::FilmBackXformOp::isScaleOp(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  return *(_DWORD *)this == 0;
}

BOOL Alembic::AbcGeom::v12::FilmBackXformOp::isMatrixOp(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  return *(_DWORD *)this == 2;
}

double Alembic::AbcGeom::v12::FilmBackXformOp::setTranslate(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  double result;
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  _BYTE v9[16];
  _QWORD v10[33];

  if (*(_DWORD *)a1 != 1)
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"Meaningless to set translate on non-translate op.", 49);
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v2 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)v2 = *(_QWORD *)a2;
  result = *(double *)(a2 + 8);
  *(double *)(v2 + 8) = result;
  return result;
}

void sub_20BE15744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

double Alembic::AbcGeom::v12::FilmBackXformOp::setScale(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  double result;
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  _BYTE v9[16];
  _QWORD v10[33];

  if (*(_DWORD *)a1)
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"Meaningless to set scale on non-scale op.", 41);
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v2 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)v2 = *(_QWORD *)a2;
  result = *(double *)(a2 + 8);
  *(double *)(v2 + 8) = result;
  return result;
}

void sub_20BE15818(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

double Alembic::AbcGeom::v12::FilmBackXformOp::setMatrix(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  double result;
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  _BYTE v9[16];
  _QWORD v10[33];

  if (*(_DWORD *)a1 != 2)
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"Cannot set non-matrix op from Abc::M33d", 39);
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v2 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)v2 = *(_QWORD *)a2;
  *(_QWORD *)(v2 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(v2 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(v2 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(v2 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(v2 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(v2 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(v2 + 56) = *(_QWORD *)(a2 + 56);
  result = *(double *)(a2 + 64);
  *(double *)(v2 + 64) = result;
  return result;
}

void sub_20BE15928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

__n128 Alembic::AbcGeom::v12::FilmBackXformOp::getTranslate@<Q0>(Alembic::AbcGeom::v12::FilmBackXformOp *this@<X0>, __n128 *a2@<X8>)
{
  __n128 *v2;
  __n128 result;
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  _BYTE v9[16];
  _QWORD v10[33];

  if (*(_DWORD *)this != 1)
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"Meaningless to get translate vector from non-translate op.", 58);
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v2 = (__n128 *)*((_QWORD *)this + 4);
  result = *v2;
  *a2 = *v2;
  return result;
}

void sub_20BE159F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

__n128 Alembic::AbcGeom::v12::FilmBackXformOp::getScale@<Q0>(Alembic::AbcGeom::v12::FilmBackXformOp *this@<X0>, __n128 *a2@<X8>)
{
  __n128 *v2;
  __n128 result;
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  _BYTE v9[16];
  _QWORD v10[33];

  if (*(_DWORD *)this)
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"Meaningless to get scaling vector from non-scale op.", 52);
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v2 = (__n128 *)*((_QWORD *)this + 4);
  result = *v2;
  *a2 = *v2;
  return result;
}

void sub_20BE15AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

double Alembic::AbcGeom::v12::FilmBackXformOp::getMatrix@<D0>(Alembic::AbcGeom::v12::FilmBackXformOp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  double result;
  _QWORD *exception;
  _QWORD *v7;
  __int128 __p;
  char v9;
  _QWORD v10[4];
  _BYTE v11[16];
  _QWORD v12[33];

  if (*(_DWORD *)this != 2)
  {
    sub_20BDDBD68((uint64_t)v11);
    sub_20BDDC1C8(v12, (uint64_t)"Can't get matrix from non-matrix op.", 36);
    std::stringbuf::str();
    sub_20BDDBF20(v10, &__p);
    if (v9 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v7 = sub_20BDDC09C(exception, (uint64_t)v10);
    __cxa_throw(v7, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v2 = *((_QWORD *)this + 4);
  v3 = *(_OWORD *)(v2 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v2;
  *(_OWORD *)(a2 + 16) = v3;
  v4 = *(_OWORD *)(v2 + 48);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(v2 + 32);
  *(_OWORD *)(a2 + 48) = v4;
  result = *(double *)(v2 + 64);
  *(double *)(a2 + 64) = result;
  return result;
}

void sub_20BE15BA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BE15BCC(_QWORD *a1, unint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_20BDDF654(a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_20BE15C30(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

int64x2_t *Alembic::AbcGeom::v12::CameraSample::CameraSample(int64x2_t *this, double a2, double a3, double a4, double a5)
{
  double v10;
  double v11;
  double v12;

  this[8] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  this[9] = (int64x2_t)xmmword_20CA521E0;
  this[10] = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  this[11].i64[1] = 0;
  this[12].i64[0] = 0;
  this[11].i64[0] = 0;
  sub_20BE15D04((uint64_t)this);
  v10 = (a5 - a4) * 0.5;
  v11 = *(double *)&this->i64[1];
  v12 = (a2 - a3) * 0.5 * v11 / v10;
  *(double *)this[1].i64 = (v10 + a4) * v11 / (v10 + v10);
  *(double *)&this[1].i64[1] = v12;
  *(double *)this[2].i64 = v11 * (v10 * v12 / v11 + a3) * 0.5;
  *(double *)&this[2].i64[1] = v10;
  return this;
}

void sub_20BE15D04(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  *(_OWORD *)a1 = xmmword_20CA521F0;
  *(_OWORD *)(a1 + 16) = xmmword_20CA52200;
  *(_OWORD *)(a1 + 32) = xmmword_20CA52210;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = xmmword_20CA52220;
  *(_OWORD *)(a1 + 96) = xmmword_20CA52230;
  *(_OWORD *)(a1 + 112) = xmmword_20CA52240;
  *(int64x2_t *)(a1 + 128) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(_OWORD *)(a1 + 144) = xmmword_20CA521E0;
  *(int64x2_t *)(a1 + 160) = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v3 = *(_QWORD *)(a1 + 176);
  for (i = *(_QWORD *)(a1 + 184); i != v3; sub_20BE168C0(a1 + 192, i))
    i -= 56;
  *(_QWORD *)(a1 + 184) = v3;
}

double Alembic::AbcGeom::v12::CameraSample::getCoreValue(Alembic::AbcGeom::v12::CameraSample *this, uint64_t a2)
{
  _QWORD *exception;
  _QWORD *v4;
  __int128 __p;
  char v6;
  _QWORD v7[4];
  _BYTE v8[16];
  _QWORD v9[33];

  switch(a2)
  {
    case 0:
      return *(double *)this;
    case 1:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 8);
      break;
    case 2:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 16);
      break;
    case 3:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 24);
      break;
    case 4:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 32);
      break;
    case 5:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 40);
      break;
    case 6:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 48);
      break;
    case 7:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 56);
      break;
    case 8:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 64);
      break;
    case 9:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 72);
      break;
    case 10:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 80);
      break;
    case 11:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 88);
      break;
    case 12:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 96);
      break;
    case 13:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 104);
      break;
    case 14:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 112);
      break;
    case 15:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 120);
      break;
    default:
      sub_20BDDBD68((uint64_t)v8);
      sub_20BDDC1C8(v9, (uint64_t)"Invalid index specified, must be 0-15 not: ", 43);
      std::ostream::operator<<();
      std::stringbuf::str();
      sub_20BDDBF20(v7, &__p);
      if (v6 < 0)
        operator delete((void *)__p);
      exception = __cxa_allocate_exception(0x20uLL);
      v4 = sub_20BDDC09C(exception, (uint64_t)v7);
      __cxa_throw(v4, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return *(double *)this;
}

void sub_20BE15EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

long double Alembic::AbcGeom::v12::CameraSample::getFieldOfView(Alembic::AbcGeom::v12::CameraSample *this)
{
  long double v1;

  v1 = atan(*((double *)this + 1) * 10.0 / (*(double *)this + *(double *)this));
  return v1 * 57.2957795 + v1 * 57.2957795;
}

double Alembic::AbcGeom::v12::CameraSample::getScreenWindow(Alembic::AbcGeom::v12::CameraSample *this, double *a2, double *a3, double *a4, double *a5)
{
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double result;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;

  v9 = *((double *)this + 5);
  v10 = (*((double *)this + 2) + *((double *)this + 2)) * v9 / *((double *)this + 1);
  *a4 = -((*((double *)this + 6) + 1.0) * v9);
  *a5 = (*((double *)this + 7) + 1.0) * *((double *)this + 5);
  v11 = *((double *)this + 1);
  v12 = *((double *)this + 5) * *((double *)this + 3) / v11;
  v13 = (*((double *)this + 4) + *((double *)this + 4)) / v11;
  *a3 = -((*((double *)this + 9) + 1.0) * v12);
  v14 = v12 * (*((double *)this + 8) + 1.0);
  *a2 = v14;
  v15 = *a4;
  v16 = *a5;
  v17 = *a3;
  Alembic::AbcGeom::v12::CameraSample::getFilmBackMatrix(this, &v24);
  v18 = v32 + v14 * v29 + v15 * v26;
  v19 = (v31 + v14 * v28 + v15 * v25) / v18;
  v20 = v32 + v17 * v29 + v16 * v26;
  v21 = (v30 + v17 * v27 + v16 * v24) / v20;
  v22 = (v31 + v17 * v28 + v16 * v25) / v20;
  *a4 = v10 + (v30 + v14 * v27 + v15 * v24) / v18;
  *a2 = v13 + v19;
  *a5 = v10 + v21;
  result = v13 + v22;
  *a3 = v13 + v22;
  return result;
}

void Alembic::AbcGeom::v12::CameraSample::getFilmBackMatrix(Alembic::AbcGeom::v12::CameraSample *this@<X0>, double *a2@<X8>)
{
  uint64_t v3;
  uint64_t v5;
  unint64_t v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  void **v13;
  __int128 v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  __n128 v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  int v41;
  __int128 v42;
  uint64_t v43;
  void *__p;
  void *v45;
  uint64_t v46;

  *a2 = 1.0;
  a2[1] = 0.0;
  a2[2] = 0.0;
  a2[3] = 0.0;
  a2[4] = 1.0;
  a2[5] = 0.0;
  a2[6] = 0.0;
  a2[7] = 0.0;
  a2[8] = 1.0;
  v3 = *((_QWORD *)this + 22);
  if (*((_QWORD *)this + 23) != v3)
  {
    v5 = 0;
    v6 = 0;
    v7 = 1.0;
    v8 = 0.0;
    v31 = 0.0;
    v32 = 0.0;
    v9 = 0.0;
    v10 = 0.0;
    v11 = 1.0;
    v12 = 0.0;
    v30 = 1.0;
    while (1)
    {
      v41 = *(_DWORD *)(v3 + v5);
      v13 = (void **)(v3 + v5 + 8);
      if (*(char *)(v3 + v5 + 31) < 0)
      {
        sub_20BDDBFAC(&v42, *v13, *(_QWORD *)(v3 + v5 + 16));
      }
      else
      {
        v14 = *(_OWORD *)v13;
        v43 = *(_QWORD *)(v3 + v5 + 24);
        v42 = v14;
      }
      __p = 0;
      v45 = 0;
      v46 = 0;
      sub_20BDDF5DC(&__p, *(const void **)(v3 + v5 + 32), *(_QWORD *)(v3 + v5 + 40), (uint64_t)(*(_QWORD *)(v3 + v5 + 40) - *(_QWORD *)(v3 + v5 + 32)) >> 3);
      if (!Alembic::AbcGeom::v12::FilmBackXformOp::isMatrixOp((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41))
        break;
      Alembic::AbcGeom::v12::FilmBackXformOp::getMatrix((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41, (uint64_t)&v33);
      v15 = v33.n128_f64[1];
      v16 = v33.n128_f64[0];
      v17 = v34;
      v18 = v35;
      v19 = v36;
      v20 = v37;
      v22 = v38;
      v21 = v39;
      v23 = v40;
LABEL_15:
      v24 = v7;
      v7 = v15 * v9 + v16 * v7 + v17 * v31;
      v25 = v10;
      v10 = v15 * v11 + v16 * v10 + v17 * v32;
      v26 = v8;
      v8 = v15 * v12 + v16 * v8 + v17 * v30;
      v27 = v9;
      v9 = v19 * v9 + v18 * v24 + v20 * v31;
      v28 = v19 * v11 + v18 * v25 + v20 * v32;
      v29 = v19 * v12 + v18 * v26 + v20 * v30;
      *a2 = v7;
      a2[1] = v10;
      a2[2] = v8;
      a2[3] = v9;
      a2[4] = v28;
      a2[5] = v29;
      v31 = v21 * v27 + v22 * v24 + v23 * v31;
      v32 = v21 * v11 + v22 * v25 + v23 * v32;
      a2[6] = v31;
      a2[7] = v32;
      v30 = v21 * v12 + v22 * v26 + v23 * v30;
      a2[8] = v30;
      if (__p)
      {
        v45 = __p;
        operator delete(__p);
      }
      if (SHIBYTE(v43) < 0)
        operator delete((void *)v42);
      ++v6;
      v3 = *((_QWORD *)this + 22);
      v5 += 56;
      v11 = v28;
      v12 = v29;
      if (v6 >= 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 23) - v3) >> 3))
        return;
    }
    if (Alembic::AbcGeom::v12::FilmBackXformOp::isScaleOp((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41))
    {
      Alembic::AbcGeom::v12::FilmBackXformOp::getScale((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41, &v33);
      v23 = 1.0;
      v19 = v33.n128_f64[1];
      v16 = v33.n128_f64[0];
      v18 = 0.0;
      v21 = 0.0;
    }
    else
    {
      v18 = 0.0;
      v16 = 1.0;
      if (Alembic::AbcGeom::v12::FilmBackXformOp::isTranslateOp((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41))
      {
        Alembic::AbcGeom::v12::FilmBackXformOp::getTranslate((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41, &v33);
        v21 = v33.n128_f64[1];
        v22 = v33.n128_f64[0];
        v19 = 1.0;
        v23 = 1.0;
LABEL_14:
        v20 = 0.0;
        v17 = 0.0;
        v15 = 0.0;
        goto LABEL_15;
      }
      v19 = 1.0;
      v21 = 0.0;
      v23 = 1.0;
    }
    v22 = 0.0;
    goto LABEL_14;
  }
}

void sub_20BE16384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_20BE167D0((uint64_t)&a22);
  _Unwind_Resume(a1);
}

uint64_t Alembic::AbcGeom::v12::CameraSample::addOp(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v4 = a1[24];
  v3 = (uint64_t)(a1 + 24);
  v5 = *(_QWORD *)(v3 - 8);
  if (v5 >= v4)
  {
    v6 = sub_20BE16904((uint64_t *)(v3 - 16), a2);
  }
  else
  {
    sub_20BE16A28(v3, *(_QWORD *)(v3 - 8), a2);
    v6 = v5 + 56;
    a1[23] = v5 + 56;
  }
  a1[23] = v6;
  return 0x6DB6DB6DB6DB6DB7 * ((v6 - a1[22]) >> 3) - 1;
}

void sub_20BE16434(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 184) = v2;
  _Unwind_Resume(a1);
}

_QWORD *Alembic::AbcGeom::v12::CameraSample::getOp@<X0>(Alembic::AbcGeom::v12::CameraSample *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  void **v7;
  __int128 v8;
  _QWORD *exception;
  _QWORD *v11;
  __int128 __p;
  char v13;
  _QWORD v14[4];
  _BYTE v15[16];
  _QWORD v16[33];

  v5 = *((_QWORD *)this + 22);
  if (0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 23) - v5) >> 3) <= a2)
  {
    sub_20BDDBD68((uint64_t)v15);
    sub_20BDDC1C8(v16, (uint64_t)"Invalid index in CameraSample: ", 31);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v14, &__p);
    if (v13 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v11 = sub_20BDDC09C(exception, (uint64_t)v14);
    __cxa_throw(v11, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  v6 = v5 + 56 * a2;
  *(_DWORD *)a3 = *(_DWORD *)v6;
  v7 = (void **)(v6 + 8);
  if (*(char *)(v6 + 31) < 0)
  {
    sub_20BDDBFAC((_BYTE *)(a3 + 8), *v7, *(_QWORD *)(v5 + 56 * a2 + 16));
  }
  else
  {
    v8 = *(_OWORD *)v7;
    *(_QWORD *)(a3 + 24) = *(_QWORD *)(v6 + 24);
    *(_OWORD *)(a3 + 8) = v8;
  }
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_QWORD *)(a3 + 48) = 0;
  return sub_20BDDF5DC((_QWORD *)(a3 + 32), *(const void **)(v5 + 56 * a2 + 32), *(_QWORD *)(v5 + 56 * a2 + 40), (uint64_t)(*(_QWORD *)(v5 + 56 * a2 + 40) - *(_QWORD *)(v5 + 56 * a2 + 32)) >> 3);
}

void sub_20BE16588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t Alembic::AbcGeom::v12::CameraSample::operator[](uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  _BYTE v9[16];
  _QWORD v10[33];

  v2 = *(_QWORD *)(a1 + 176);
  if (*a2 >= (unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*(_QWORD *)(a1 + 184) - v2) >> 3)))
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"Invalid index in CameraSample: ", 31);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return v2 + 56 * *a2;
}

{
  uint64_t v2;
  _QWORD *exception;
  _QWORD *v5;
  __int128 __p;
  char v7;
  _QWORD v8[4];
  _BYTE v9[16];
  _QWORD v10[33];

  v2 = *(_QWORD *)(a1 + 176);
  if (*a2 >= (unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*(_QWORD *)(a1 + 184) - v2) >> 3)))
  {
    sub_20BDDBD68((uint64_t)v9);
    sub_20BDDC1C8(v10, (uint64_t)"Invalid index in CameraSample: ", 31);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_20BDDBF20(v8, &__p);
    if (v7 < 0)
      operator delete((void *)__p);
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = sub_20BDDC09C(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_24C516920, (void (*)(void *))sub_20BDDBE94);
  }
  return v2 + 56 * *a2;
}

void sub_20BE166A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_20BE167A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::exception v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_20BDDC194((std::exception *)va);
  sub_20BDDBE98((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_20BE167D0(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(_QWORD *)(a1 + 40) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

uint64_t Alembic::AbcGeom::v12::CameraSample::getNumOps(Alembic::AbcGeom::v12::CameraSample *this)
{
  return 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)this + 23) - *((_QWORD *)this + 22)) >> 3);
}

uint64_t Alembic::AbcGeom::v12::CameraSample::getNumOpChannels(Alembic::AbcGeom::v12::CameraSample *this)
{
  uint64_t v1;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v1 = *((_QWORD *)this + 22);
  if (*((_QWORD *)this + 23) == v1)
    return 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  do
  {
    v5 += Alembic::AbcGeom::v12::FilmBackXformOp::getNumChannels((Alembic::AbcGeom::v12::FilmBackXformOp *)(v1 + v3));
    ++v4;
    v1 = *((_QWORD *)this + 22);
    v3 += 56;
  }
  while (v4 < 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 23) - v1) >> 3));
  return v5;
}

void sub_20BE168C0(uint64_t a1, uint64_t a2)
{
  void *v3;

  v3 = *(void **)(a2 + 32);
  if (v3)
  {
    *(_QWORD *)(a2 + 40) = v3;
    operator delete(v3);
  }
  if (*(char *)(a2 + 31) < 0)
    operator delete(*(void **)(a2 + 8));
}

uint64_t sub_20BE16904(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x492492492492492)
    sub_20BDDF694();
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3) > v4)
    v4 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3)) >= 0x249249249249249)
    v6 = 0x492492492492492;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)sub_20BE16B34((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = &v7[56 * v3];
  v13 = &v7[56 * v6];
  sub_20BE16A28((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  v12 = v11 + 56;
  sub_20BE16AC0(a1, &v10);
  v8 = a1[1];
  sub_20BE16CC0(&v10);
  return v8;
}

void sub_20BE16A14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_20BE16CC0((void **)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_20BE16A28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BYTE *v5;
  __int128 v6;

  *(_DWORD *)a2 = *(_DWORD *)a3;
  v5 = (_BYTE *)(a2 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_20BDDBFAC(v5, *(void **)(a3 + 8), *(_QWORD *)(a3 + 16));
  }
  else
  {
    v6 = *(_OWORD *)(a3 + 8);
    *(_QWORD *)(a2 + 24) = *(_QWORD *)(a3 + 24);
    *(_OWORD *)v5 = v6;
  }
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return sub_20BDDF5DC((_QWORD *)(a2 + 32), *(const void **)(a3 + 32), *(_QWORD *)(a3 + 40), (uint64_t)(*(_QWORD *)(a3 + 40) - *(_QWORD *)(a3 + 32)) >> 3);
}

void sub_20BE16AA4(_Unwind_Exception *exception_object)
{
  void **v1;
  uint64_t v2;

  if (*(char *)(v2 + 31) < 0)
    operator delete(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_20BE16AC0(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_20BE16B7C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_20BE16B34(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493)
    sub_20BDDF5B4();
  return operator new(56 * a2);
}

uint64_t sub_20BE16B7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  int v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    do
    {
      v8 = *(_DWORD *)(a3 - 56);
      a3 -= 56;
      *(_DWORD *)(v7 - 56) = v8;
      v9 = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 32) = *(_QWORD *)(a3 + 24);
      *(_OWORD *)(v7 - 48) = v9;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 32);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 48);
      *(_QWORD *)(a3 + 32) = 0;
      *(_QWORD *)(a3 + 40) = 0;
      *(_QWORD *)(a3 + 48) = 0;
      v7 = *((_QWORD *)&v15 + 1) - 56;
      *((_QWORD *)&v15 + 1) -= 56;
    }
    while (a3 != a5);
    v10 = v15;
  }
  v13 = 1;
  sub_20BE16C3C((uint64_t)v12);
  return v10;
}

uint64_t sub_20BE16C3C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_20BE16C70((uint64_t *)a1);
  return a1;
}

void sub_20BE16C70(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      sub_20BE168C0(v3, v1);
      v1 += 56;
    }
    while (v1 != v2);
  }
}

void **sub_20BE16CC0(void **a1)
{
  sub_20BE16CF0(a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void sub_20BE16CF0(_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 56;
    sub_20BE168C0(v4, i - 56);
  }
}

void Alembic::AbcGeom::v12::ICameraSchema::init(uint64_t a1, uint64_t **a2, uint64_t **a3)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t PropertyHeader;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void **v52;
  __int128 v53;
  void *v54;
  _QWORD *v55;
  void *v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  void **v72;
  __int128 v73;
  void *v74;
  _QWORD *v75;
  void *v76;
  std::__shared_weak_count *v77;
  unint64_t *v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  unint64_t *v83;
  unint64_t v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  unint64_t *v88;
  unint64_t v89;
  unint64_t *v90;
  std::__shared_weak_count *v91;
  unint64_t *v92;
  unint64_t v93;
  std::__shared_weak_count *v94;
  unint64_t *v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t **v99;
  uint64_t **v100;
  uint64_t **v101;
  uint64_t **v102;
  uint64_t v103;
  std::__shared_weak_count *v104;
  uint64_t v105;
  std::__shared_weak_count *v106;
  uint64_t v107;
  std::__shared_weak_count *v108;
  void *p_p;
  std::string v110;
  __int128 v111;
  uint64_t v112;
  uint64_t v113;
  std::__shared_weak_count *v114;
  uint64_t v115;
  std::__shared_weak_count *v116;
  uint64_t v117;
  std::__shared_weak_count *v118;
  uint64_t v119;
  std::__shared_weak_count *v120;
  int v121;
  int v122;
  void *__p;
  std::__shared_weak_count *v124;
  char v125;
  int v126;
  int v127;
  int v128;
  int v129;
  uint64_t v130;
  std::__shared_weak_count *v131;
  void *v132[8];
  int v133;
  uint64_t v134[4];
  std::__shared_weak_count *v135;
  int v136;
  uint64_t v137;
  uint64_t v138;
  std::__shared_weak_count *v139;
  uint64_t v140;
  const char *v141;

  v6 = a1 + 8;
  v140 = a1 + 8;
  v141 = "ICameraSchema::init()";
  v8 = *(_QWORD *)(a1 + 40);
  v7 = *(std::__shared_weak_count **)(a1 + 48);
  v138 = v8;
  v139 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  *(_OWORD *)&v110.__r_.__value_.__l.__data_ = 0uLL;
  p_p = &v110;
  v132[6] = 0;
  v132[7] = 0;
  v133 = 2;
  sub_20BDEBF8C(v134, (const void ***)&p_p);
  v134[3] = 0;
  v135 = 0;
  v136 = 0;
  v137 = 1;
  sub_20BDE9D48((uint64_t)&p_p, v110.__r_.__value_.__l.__data_);
  sub_20BE02E30(a2, (uint64_t)&v133);
  sub_20BE02E30(a3, (uint64_t)&v133);
  v130 = v8;
  v131 = v7;
  if (v7)
  {
    v11 = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v128 = 0;
  v129 = 0;
  v126 = 0;
  v127 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v132, &v130, &v128, &v126);
  sub_20BDDC0E4(&__p, ".core");
  v121 = 1;
  v122 = v133;
  Alembic::Abc::v12::IScalarProperty::IScalarProperty(&p_p, v132, &__p, &v121);
  *(_DWORD *)(a1 + 56) = (_DWORD)p_p;
  std::string::operator=((std::string *)(a1 + 64), &v110);
  sub_20BDE881C((_QWORD *)(a1 + 88), (uint64_t *)&v111);
  Alembic::Abc::v12::IScalarProperty::~IScalarProperty((Alembic::Abc::v12::IScalarProperty *)&p_p);
  if (v125 < 0)
    operator delete(__p);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v132);
  v13 = v131;
  if (v131)
  {
    v14 = (unint64_t *)&v131->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  sub_20BDDC0E4(&p_p, ".childBnds");
  PropertyHeader = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  v17 = PropertyHeader;
  if (v110.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(p_p);
    if (!v17)
      goto LABEL_28;
  }
  else if (!PropertyHeader)
  {
    goto LABEL_28;
  }
  v119 = v138;
  v120 = v139;
  if (v139)
  {
    v18 = (unint64_t *)&v139->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v128 = 0;
  v129 = 0;
  v126 = 0;
  v127 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v132, &v119, &v128, &v126);
  sub_20BDDC0E4(&__p, ".childBnds");
  sub_20BE13A80((uint64_t)&p_p, (int *)v132, (uint64_t)&__p, a2, a3);
  *(_DWORD *)(a1 + 104) = (_DWORD)p_p;
  std::string::operator=((std::string *)(a1 + 112), &v110);
  sub_20BDE881C((_QWORD *)(a1 + 136), (uint64_t *)&v111);
  Alembic::Abc::v12::IScalarProperty::~IScalarProperty(&p_p);
  if (v125 < 0)
    operator delete(__p);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v132);
  v20 = v120;
  if (v120)
  {
    v21 = (unint64_t *)&v120->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
LABEL_28:
  sub_20BDDC0E4(&p_p, ".arbGeomParams");
  v23 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  v24 = v23;
  if (v110.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(p_p);
    if (!v24)
      goto LABEL_42;
  }
  else if (!v23)
  {
    goto LABEL_42;
  }
  v117 = v138;
  v118 = v139;
  if (v139)
  {
    v25 = (unint64_t *)&v139->__shared_owners_;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  v128 = 0;
  v129 = 0;
  v126 = 0;
  v127 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v132, &v117, &v128, &v126);
  sub_20BDDC0E4(&__p, ".arbGeomParams");
  v121 = 1;
  v122 = v133;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&p_p, v132, &__p, &v121);
  *(_DWORD *)(a1 + 152) = (_DWORD)p_p;
  std::string::operator=((std::string *)(a1 + 160), &v110);
  sub_20BDE881C((_QWORD *)(a1 + 184), (uint64_t *)&v111);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&p_p);
  if (v125 < 0)
    operator delete(__p);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v132);
  v27 = v118;
  if (v118)
  {
    v28 = (unint64_t *)&v118->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
LABEL_42:
  sub_20BDDC0E4(&p_p, ".userProperties");
  v30 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  v31 = v30;
  if (v110.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(p_p);
    if (!v31)
      goto LABEL_56;
  }
  else if (!v30)
  {
    goto LABEL_56;
  }
  v115 = v138;
  v116 = v139;
  if (v139)
  {
    v32 = (unint64_t *)&v139->__shared_owners_;
    do
      v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
  }
  v128 = 0;
  v129 = 0;
  v126 = 0;
  v127 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v132, &v115, &v128, &v126);
  sub_20BDDC0E4(&__p, ".userProperties");
  v121 = 1;
  v122 = v133;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&p_p, v132, &__p, &v121);
  *(_DWORD *)(a1 + 200) = (_DWORD)p_p;
  std::string::operator=((std::string *)(a1 + 208), &v110);
  sub_20BDE881C((_QWORD *)(a1 + 232), (uint64_t *)&v111);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&p_p);
  if (v125 < 0)
    operator delete(__p);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v132);
  v34 = v116;
  if (v116)
  {
    v35 = (unint64_t *)&v116->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
LABEL_56:
  sub_20BDDC0E4(&p_p, ".filmBackOps");
  v37 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  v38 = v37;
  if (v110.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(p_p);
    if (!v38)
      goto LABEL_115;
  }
  else if (!v37)
  {
    goto LABEL_115;
  }
  v39 = *(_DWORD *)(v38 + 24);
  if (v39 == 2)
  {
    v107 = v138;
    v108 = v139;
    if (v139)
    {
      v57 = (unint64_t *)&v139->__shared_owners_;
      do
        v58 = __ldxr(v57);
      while (__stxr(v58 + 1, v57));
    }
    v128 = 0;
    v129 = 0;
    v126 = 0;
    v127 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&p_p, &v107, &v128, &v126);
    sub_20BDDC0E4(&__p, ".filmBackOps");
    sub_20BE18AF0((uint64_t)v132, (int *)&p_p, (uint64_t)&__p, a2, a3);
    if (v125 < 0)
      operator delete(__p);
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&p_p);
    v59 = v108;
    if (v108)
    {
      v60 = (unint64_t *)&v108->__shared_owners_;
      do
        v61 = __ldaxr(v60);
      while (__stlxr(v61 - 1, v60));
      if (!v61)
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
    }
    v98 = v6;
    v100 = a2;
    v102 = a3;
    __p = 0;
    v124 = 0;
    p_p = 0;
    v110.__r_.__value_.__r.__words[0] = 0;
    LODWORD(v110.__r_.__value_.__r.__words[1]) = 2;
    sub_20BE17E28((uint64_t)v132, (uint64_t)&__p, (uint64_t)&p_p);
    if (__p)
    {
      v62 = (uint64_t *)*((_QWORD *)__p + 2);
      v63 = *((_QWORD *)__p + 3) - (_QWORD)v62;
      if (v63)
      {
        v64 = v63 >> 3;
        if (v64 <= 1)
          v64 = 1;
        v65 = 1;
        do
        {
          v66 = *v62++;
          v65 *= v66;
          --v64;
        }
        while (v64);
      }
      else
      {
        v65 = 0;
      }
      v67 = (uint64_t *)(a1 + 344);
      sub_20BE17D90((uint64_t *)(a1 + 344), v65);
      if (v65)
      {
        v68 = 0;
        v69 = 0;
        do
        {
          Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(&p_p, *(_QWORD *)__p + v69);
          v70 = *v67;
          v71 = *v67 + v68;
          *(_DWORD *)v71 = (_DWORD)p_p;
          v72 = (void **)(v71 + 8);
          if (*(char *)(v71 + 31) < 0)
            operator delete(*v72);
          v73 = *(_OWORD *)&v110.__r_.__value_.__l.__data_;
          *(_QWORD *)(v71 + 24) = *((_QWORD *)&v110.__r_.__value_.__l + 2);
          *(_OWORD *)v72 = v73;
          *((_BYTE *)&v110.__r_.__value_.__s + 23) = 0;
          v110.__r_.__value_.__s.__data_[0] = 0;
          v76 = *(void **)(v71 + 32);
          v75 = (_QWORD *)(v71 + 32);
          v74 = v76;
          if (v76)
          {
            *(_QWORD *)(v70 + v68 + 40) = v74;
            operator delete(v74);
            *v75 = 0;
            v75[1] = 0;
            v75[2] = 0;
          }
          *(_OWORD *)v75 = v111;
          *(_QWORD *)(v70 + v68 + 48) = v112;
          v111 = 0uLL;
          v112 = 0;
          if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v110.__r_.__value_.__l.__data_);
          v69 += 24;
          v68 += 56;
          --v65;
        }
        while (v65);
      }
    }
    v77 = v124;
    v6 = v98;
    if (v124)
    {
      v78 = (unint64_t *)&v124->__shared_owners_;
      do
        v79 = __ldaxr(v78);
      while (__stlxr(v79 - 1, v78));
      if (!v79)
      {
        ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
        std::__shared_weak_count::__release_weak(v77);
      }
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty(v132);
    a2 = v100;
    a3 = v102;
  }
  else if (v39 == 1)
  {
    v113 = v138;
    v114 = v139;
    if (v139)
    {
      v40 = (unint64_t *)&v139->__shared_owners_;
      do
        v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
    }
    v128 = 0;
    v129 = 0;
    v126 = 0;
    v127 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&p_p, &v113, &v128, &v126);
    sub_20BDDC0E4(&__p, ".filmBackOps");
    v121 = 1;
    v122 = v133;
    Alembic::Abc::v12::IScalarProperty::IScalarProperty(v132, &p_p, &__p, &v121);
    if (v125 < 0)
      operator delete(__p);
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&p_p);
    v42 = v114;
    if (v114)
    {
      v43 = (unint64_t *)&v114->__shared_owners_;
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
    }
    v45 = *(unsigned __int8 *)(sub_20BE18848((uint64_t)v132) + 60);
    sub_20BDE4F04(&__p, v45);
    p_p = 0;
    v110.__r_.__value_.__r.__words[0] = 0;
    LODWORD(v110.__r_.__value_.__r.__words[1]) = 2;
    Alembic::Abc::v12::IScalarProperty::get((uint64_t)v132, (uint64_t)__p, (uint64_t)&p_p, 0);
    v97 = v6;
    v99 = a2;
    v101 = a3;
    v46 = (uint64_t *)(a1 + 344);
    sub_20BE17D90((uint64_t *)(a1 + 344), 0xAAAAAAAAAAAAAAABLL * (((char *)v124 - (_BYTE *)__p) >> 3));
    if ((_DWORD)v45)
    {
      v47 = 0;
      v48 = 0;
      v49 = 56 * v45;
      do
      {
        Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(&p_p, (char *)__p + v47);
        v50 = *v46;
        v51 = *v46 + v48;
        *(_DWORD *)v51 = (_DWORD)p_p;
        v52 = (void **)(v51 + 8);
        if (*(char *)(v51 + 31) < 0)
          operator delete(*v52);
        v53 = *(_OWORD *)&v110.__r_.__value_.__l.__data_;
        *(_QWORD *)(v51 + 24) = *((_QWORD *)&v110.__r_.__value_.__l + 2);
        *(_OWORD *)v52 = v53;
        *((_BYTE *)&v110.__r_.__value_.__s + 23) = 0;
        v110.__r_.__value_.__s.__data_[0] = 0;
        v56 = *(void **)(v51 + 32);
        v55 = (_QWORD *)(v51 + 32);
        v54 = v56;
        if (v56)
        {
          *(_QWORD *)(v50 + v48 + 40) = v54;
          operator delete(v54);
          *v55 = 0;
          v55[1] = 0;
          v55[2] = 0;
        }
        *(_OWORD *)v55 = v111;
        *(_QWORD *)(v50 + v48 + 48) = v112;
        v111 = 0uLL;
        v112 = 0;
        if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v110.__r_.__value_.__l.__data_);
        v48 += 56;
        v47 += 24;
      }
      while (v49 != v48);
    }
    p_p = &__p;
    sub_20BDE5038((void ***)&p_p);
    Alembic::Abc::v12::IScalarProperty::~IScalarProperty((Alembic::Abc::v12::IScalarProperty *)v132);
    a3 = v101;
    v6 = v97;
    a2 = v99;
  }
LABEL_115:
  sub_20BDDC0E4(&p_p, ".filmBackChannels");
  v80 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  v81 = v80;
  if (v110.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(p_p);
    if (!v81)
      goto LABEL_140;
  }
  else if (!v80)
  {
    goto LABEL_140;
  }
  v82 = *(_DWORD *)(v81 + 24);
  if (v82 == 2)
  {
    v103 = v138;
    v104 = v139;
    if (v139)
    {
      v88 = (unint64_t *)&v139->__shared_owners_;
      do
        v89 = __ldxr(v88);
      while (__stxr(v89 + 1, v88));
    }
    v128 = 0;
    v129 = 0;
    v126 = 0;
    v127 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v132, &v103, &v128, &v126);
    sub_20BDDC0E4(&__p, ".filmBackChannels");
    sub_20BE1917C((uint64_t)&p_p, (int *)v132, (uint64_t)&__p, a2, a3);
    *(_DWORD *)(a1 + 296) = (_DWORD)p_p;
    std::string::operator=((std::string *)(a1 + 304), &v110);
    sub_20BDE881C((_QWORD *)(a1 + 328), (uint64_t *)&v111);
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty(&p_p);
    if (v125 < 0)
      operator delete(__p);
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v132);
    v85 = v104;
    if (v104)
    {
      v90 = (unint64_t *)&v104->__shared_owners_;
      do
        v87 = __ldaxr(v90);
      while (__stlxr(v87 - 1, v90));
LABEL_138:
      if (!v87)
      {
        ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
        std::__shared_weak_count::__release_weak(v85);
      }
    }
  }
  else if (v82 == 1)
  {
    v105 = v138;
    v106 = v139;
    if (v139)
    {
      v83 = (unint64_t *)&v139->__shared_owners_;
      do
        v84 = __ldxr(v83);
      while (__stxr(v84 + 1, v83));
    }
    v128 = 0;
    v129 = 0;
    v126 = 0;
    v127 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v132, &v105, &v128, &v126);
    sub_20BDDC0E4(&__p, ".filmBackChannels");
    v121 = 1;
    v122 = v133;
    Alembic::Abc::v12::IScalarProperty::IScalarProperty(&p_p, v132, &__p, &v121);
    *(_DWORD *)(a1 + 248) = (_DWORD)p_p;
    std::string::operator=((std::string *)(a1 + 256), &v110);
    sub_20BDE881C((_QWORD *)(a1 + 280), (uint64_t *)&v111);
    Alembic::Abc::v12::IScalarProperty::~IScalarProperty((Alembic::Abc::v12::IScalarProperty *)&p_p);
    if (v125 < 0)
      operator delete(__p);
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v132);
    v85 = v106;
    if (v106)
    {
      v86 = (unint64_t *)&v106->__shared_owners_;
      do
        v87 = __ldaxr(v86);
      while (__stlxr(v87 - 1, v86));
      goto LABEL_138;
    }
  }
LABEL_140:
  v91 = v135;
  if (v135)
  {
    v92 = (unint64_t *)&v135->__shared_owners_;
    do
      v93 = __ldaxr(v92);
    while (__stlxr(v93 - 1, v92));
    if (!v93)
    {
      ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
      std::__shared_weak_count::__release_weak(v91);
    }
  }
  sub_20BDE9D48((uint64_t)v134, (_QWORD *)v134[1]);
  v94 = v139;
  if (v139)
  {
    v95 = (unint64_t *)&v139->__shared_owners_;
    do
      v96 = __ldaxr(v95);
    while (__stlxr(v96 - 1, v95));
    if (!v96)
    {
      ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
      std::__shared_weak_count::__release_weak(v94);
    }
  }
}

void sub_20BE179D4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,char a32,uint64_t a33,char a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  _QWORD *v50;
  uint64_t v51;

  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)&__p);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((void **)(v51 - 248));
  sub_20BE02EB0(v51 - 184);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)(v51 - 120));
  __cxa_begin_catch(a1);
  if (a2 == 2)
    sub_20BE17F08(v50);
  sub_20BE17F08(v50);
}

void sub_20BE17D5C()
{
  uint64_t v0;

  sub_20BE02504(v0 - 104, 0);
  JUMPOUT(0x20BE17D68);
}

void sub_20BE17D70(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_20BE17D90(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0x6DB6DB6DB6DB6DB7 * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_20BE18960(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 56 * a2;
    while (v3 != v7)
    {
      v3 -= 56;
      sub_20BE168C0((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void sub_20BE17E28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  __int128 v12;
  __int128 v13;

  v13 = 0uLL;
  Alembic::Abc::v12::IArrayProperty::get(a1, (uint64_t)&v13, a3);
  v12 = v13;
  if (*((_QWORD *)&v13 + 1))
  {
    v4 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  sub_20BDE82DC(a2, &v12);
  v6 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
  if (*((_QWORD *)&v13 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_20BE17EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource::~PcpExpressionVariablesSource((pxrInternal__aapl__pxrReserved__::PcpExpressionVariablesSource *)va);
  _Unwind_Resume(a1);
}

void sub_20BE17F08(_QWORD *a1)
{
  uint64_t i;
  uint64_t v3;

  sub_20BDEBF08(a1 + 11);
  MEMORY[0x212B929D0](a1 + 8, "");
  sub_20BDEBF08(a1 + 17);
  MEMORY[0x212B929D0](a1 + 14, "");
  sub_20BDEBF08(a1 + 23);
  MEMORY[0x212B929D0](a1 + 20, "");
  sub_20BDEBF08(a1 + 29);
  MEMORY[0x212B929D0](a1 + 26, "");
  v3 = a1[43];
  for (i = a1[44]; i != v3; sub_20BE168C0((uint64_t)(a1 + 45), i))
    i -= 56;
  a1[44] = v3;
  sub_20BDEBF08(a1 + 5);
  JUMPOUT(0x212B929D0);
}

uint64_t Alembic::AbcGeom::v12::ICameraSchema::isConstant(Alembic::AbcGeom::v12::ICameraSchema *this)
{
  uint64_t result;

  result = Alembic::Abc::v12::IScalarProperty::isConstant((Alembic::AbcGeom::v12::ICameraSchema *)((char *)this + 56));
  if ((_DWORD)result)
  {
    if (*((char *)this + 279) < 0)
    {
      if (*((_QWORD *)this + 33))
        goto LABEL_8;
    }
    else if (*((_BYTE *)this + 279))
    {
      goto LABEL_8;
    }
    if (!*((_QWORD *)this + 35)
      || (result = Alembic::Abc::v12::IScalarProperty::isConstant((Alembic::AbcGeom::v12::ICameraSchema *)((char *)this + 248)),
          (_DWORD)result))
    {
LABEL_8:
      if (*((char *)this + 327) < 0)
      {
        if (!*((_QWORD *)this + 39))
          goto LABEL_12;
      }
      else if (!*((_BYTE *)this + 327))
      {
LABEL_12:
        if (*((_QWORD *)this + 41))
          return Alembic::Abc::v12::IArrayProperty::isConstant((Alembic::AbcGeom::v12::ICameraSchema *)((char *)this + 296));
      }
      return 1;
    }
  }
  return result;
}

void Alembic::AbcGeom::v12::ICameraSchema::get(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  Alembic::Abc::v12::IScalarProperty *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t (*v11)();
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  int *v25;
  void **v26;
  __int128 v27;
  Alembic::AbcGeom::v12::FilmBackXformOp *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t (*v31)();
  uint64_t NumSamples;
  void *Index;
  std::__shared_weak_count *v34;
  unint64_t *p_shared_owners;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  int *v44;
  void **v45;
  __int128 v46;
  Alembic::AbcGeom::v12::FilmBackXformOp *v47;
  uint64_t NumChannels;
  unint64_t i;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t *v53;
  uint64_t v54;
  int v55;
  __int128 v56;
  uint64_t v57;
  void *v58;
  void *v59;
  uint64_t v60;
  int v61;
  __int128 v62;
  uint64_t v63;
  void *__p;
  void *v65;
  uint64_t v66;
  _QWORD *v67;
  std::__shared_weak_count *v68;
  int v69;
  void *v70;
  std::__shared_weak_count *v71;
  int v72;
  uint64_t v73;
  const char *v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  uint64_t v83;

  v5 = a1;
  v83 = *MEMORY[0x24BDAC8D0];
  v73 = a1 + 8;
  v74 = "ICameraSchema::get()";
  v81 = 0u;
  v82 = 0u;
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  v6 = (Alembic::Abc::v12::IScalarProperty *)(a1 + 56);
  v75 = 0u;
  v76 = 0u;
  Alembic::Abc::v12::IScalarProperty::get(a1 + 56, (uint64_t)&v75, a3, 0);
  sub_20BE15D04(a2);
  v7 = v76;
  *(_OWORD *)a2 = v75;
  *(_OWORD *)(a2 + 16) = v7;
  v8 = v78;
  *(_OWORD *)(a2 + 32) = v77;
  *(_OWORD *)(a2 + 48) = v8;
  v9 = v80;
  *(_OWORD *)(a2 + 64) = v79;
  *(_OWORD *)(a2 + 80) = v9;
  v10 = v82;
  *(_OWORD *)(a2 + 96) = v81;
  *(_OWORD *)(a2 + 112) = v10;
  if (*(char *)(v5 + 279) < 0)
  {
    if (*(_QWORD *)(v5 + 264))
      goto LABEL_3;
  }
  else if (*(_BYTE *)(v5 + 279))
  {
LABEL_3:
    v11 = 0;
    goto LABEL_8;
  }
  if (*(_QWORD *)(v5 + 280))
    v11 = nullsub_4;
  else
    v11 = 0;
LABEL_8:
  v54 = v5;
  if (!v11 || !Alembic::Abc::v12::IScalarProperty::getNumSamples((Alembic::Abc::v12::IScalarProperty *)(v5 + 248)))
  {
    if (*(char *)(v5 + 327) < 0)
    {
      if (*(_QWORD *)(v5 + 312))
        goto LABEL_35;
    }
    else if (*(_BYTE *)(v5 + 327))
    {
LABEL_35:
      v31 = 0;
      goto LABEL_40;
    }
    if (*(_QWORD *)(v5 + 328))
      v31 = nullsub_5;
    else
      v31 = 0;
LABEL_40:
    if (!v31 || !Alembic::Abc::v12::IArrayProperty::getNumSamples((Alembic::Abc::v12::IArrayProperty *)(v5 + 296)))
      return;
    Alembic::Abc::v12::IScalarProperty::getTimeSampling(v6, &v70);
    NumSamples = Alembic::Abc::v12::IArrayProperty::getNumSamples((Alembic::Abc::v12::IArrayProperty *)(v5 + 296));
    Index = (void *)Alembic::Abc::v12::ISampleSelector::getIndex(a3, (double ***)&v70, NumSamples);
    v34 = v71;
    if (v71)
    {
      p_shared_owners = (unint64_t *)&v71->__shared_owners_;
      do
        v36 = __ldaxr(p_shared_owners);
      while (__stlxr(v36 - 1, p_shared_owners));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
    v67 = 0;
    v68 = 0;
    v70 = Index;
    v71 = 0;
    v72 = 2;
    sub_20BE18768(v5 + 296, (uint64_t)&v67, (uint64_t)&v70);
    if (v67)
    {
      v38 = *(_QWORD *)(v5 + 344);
      v37 = *(_QWORD *)(v5 + 352);
      v70 = 0;
      v39 = v37 - v38;
      if (v39)
      {
        v40 = 0;
        v41 = 0;
        v42 = 0x6DB6DB6DB6DB6DB7 * (v39 >> 3);
        do
        {
          v43 = *(_QWORD *)(v5 + 344);
          v44 = (int *)(v43 + 56 * v41);
          v55 = *v44;
          v45 = (void **)(v44 + 2);
          if (*((char *)v44 + 31) < 0)
          {
            sub_20BDDBFAC(&v56, *v45, *(_QWORD *)(v43 + 56 * v41 + 16));
          }
          else
          {
            v46 = *(_OWORD *)v45;
            v57 = *((_QWORD *)v44 + 3);
            v56 = v46;
          }
          v58 = 0;
          v59 = 0;
          v60 = 0;
          sub_20BDDF5DC(&v58, *(const void **)(v43 + 56 * v41 + 32), *(_QWORD *)(v43 + 56 * v41 + 40), (uint64_t)(*(_QWORD *)(v43 + 56 * v41 + 40) - *(_QWORD *)(v43 + 56 * v41 + 32)) >> 3);
          Alembic::AbcGeom::v12::CameraSample::addOp((_QWORD *)a2, (uint64_t)&v55);
          if (v58)
          {
            v59 = v58;
            operator delete(v58);
          }
          if (SHIBYTE(v57) < 0)
            operator delete((void *)v56);
          v47 = (Alembic::AbcGeom::v12::FilmBackXformOp *)Alembic::AbcGeom::v12::CameraSample::operator[](a2, &v70);
          NumChannels = Alembic::AbcGeom::v12::FilmBackXformOp::getNumChannels(v47);
          if (NumChannels)
          {
            for (i = 0; i != NumChannels; ++i)
              Alembic::AbcGeom::v12::FilmBackXformOp::setChannelValue((uint64_t)v47, i, *(double *)(*v67 + 8 * v40 + 8 * i));
            v40 += i;
            v5 = v54;
          }
          v41 = (unint64_t)v70 + 1;
          v70 = (void *)v41;
        }
        while (v41 < v42);
      }
      v50 = v68;
      if (!v68)
        return;
      v51 = (unint64_t *)&v68->__shared_owners_;
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 - 1, v51));
    }
    else
    {
      v50 = v68;
      if (!v68)
        return;
      v53 = (unint64_t *)&v68->__shared_owners_;
      do
        v52 = __ldaxr(v53);
      while (__stlxr(v52 - 1, v53));
    }
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
    return;
  }
  Alembic::Abc::v12::IScalarProperty::getTimeSampling(v6, &v70);
  v12 = Alembic::Abc::v12::IScalarProperty::getNumSamples((Alembic::Abc::v12::IScalarProperty *)(v5 + 248));
  v13 = Alembic::Abc::v12::ISampleSelector::getIndex(a3, (double ***)&v70, v12);
  v14 = v71;
  if (v71)
  {
    v15 = (unint64_t *)&v71->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = sub_20BE18848(v5 + 248);
  sub_20BDE48D4(&v70, *(unsigned __int8 *)(v17 + 60));
  v67 = (_QWORD *)v13;
  v68 = 0;
  v69 = 2;
  Alembic::Abc::v12::IScalarProperty::get(v5 + 248, (uint64_t)v70, (uint64_t)&v67, 0);
  v19 = *(_QWORD *)(v5 + 344);
  v18 = *(_QWORD *)(v5 + 352);
  v67 = 0;
  v20 = v18 - v19;
  if (v20)
  {
    v21 = 0;
    v22 = 0;
    v23 = 0x6DB6DB6DB6DB6DB7 * (v20 >> 3);
    do
    {
      v24 = *(_QWORD *)(v5 + 344);
      v25 = (int *)(v24 + 56 * v22);
      v61 = *v25;
      v26 = (void **)(v25 + 2);
      if (*((char *)v25 + 31) < 0)
      {
        sub_20BDDBFAC(&v62, *v26, *(_QWORD *)(v24 + 56 * v22 + 16));
      }
      else
      {
        v27 = *(_OWORD *)v26;
        v63 = *((_QWORD *)v25 + 3);
        v62 = v27;
      }
      __p = 0;
      v65 = 0;
      v66 = 0;
      sub_20BDDF5DC(&__p, *(const void **)(v24 + 56 * v22 + 32), *(_QWORD *)(v24 + 56 * v22 + 40), (uint64_t)(*(_QWORD *)(v24 + 56 * v22 + 40) - *(_QWORD *)(v24 + 56 * v22 + 32)) >> 3);
      Alembic::AbcGeom::v12::CameraSample::addOp((_QWORD *)a2, (uint64_t)&v61);
      if (__p)
      {
        v65 = __p;
        operator delete(__p);
      }
      if (SHIBYTE(v63) < 0)
        operator delete((void *)v62);
      v28 = (Alembic::AbcGeom::v12::FilmBackXformOp *)Alembic::AbcGeom::v12::CameraSample::operator[](a2, &v67);
      v29 = Alembic::AbcGeom::v12::FilmBackXformOp::getNumChannels(v28);
      if (v29)
      {
        v30 = 0;
        while (v21 + v30 < ((char *)v71 - (_BYTE *)v70) >> 3)
        {
          Alembic::AbcGeom::v12::FilmBackXformOp::setChannelValue((uint64_t)v28, v30, *((double *)v70 + v21 + v30));
          if (v29 == ++v30)
          {
            v21 += v30;
            goto LABEL_30;
          }
        }
        v21 += v30;
      }
LABEL_30:
      v22 = (unint64_t)v67 + 1;
      v67 = (_QWORD *)v22;
      v5 = v54;
    }
    while (v22 < v23);
  }
  if (v70)
  {
    v71 = (std::__shared_weak_count *)v70;
    operator delete(v70);
  }
}

