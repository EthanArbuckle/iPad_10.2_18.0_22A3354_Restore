int xmlNodeIsText(const xmlNode *node)
{
  if (node)
    LODWORD(node) = node->type == XML_TEXT_NODE;
  return (int)node;
}

int *__xmlLineNumbersDefaultValue(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlLineNumbersDefaultValue;
  else
    return &xmlGetGlobalState()->xmlLineNumbersDefaultValue;
}

uint64_t __xmlRandom()
{
  xmlRMutex *v0;
  uint64_t v1;

  v0 = (xmlRMutex *)xmlDictMutex;
  if (!xmlDictMutex)
  {
    pthread_once(&once_control_0, _xmlInitializeDictMutex);
    v0 = (xmlRMutex *)xmlDictMutex;
  }
  xmlRMutexLock(v0);
  v1 = rand_r((unsigned int *)&rand_seed);
  xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
  return v1;
}

void xmlParseMisc(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v4;

  while (ctxt->instate != XML_PARSER_EOF)
  {
    xmlSkipBlankChars(ctxt);
    input = ctxt->input;
    if (!ctxt->progressive && input->end - input->cur <= 249)
    {
      xmlGROW((uint64_t)ctxt);
      input = ctxt->input;
    }
    cur = input->cur;
    if (*cur != 60)
      break;
    v4 = cur[1];
    if (v4 == 33)
    {
      if (cur[2] != 45 || cur[3] != 45)
        return;
      xmlParseComment(ctxt);
    }
    else
    {
      if (v4 != 63)
        return;
      xmlParsePI(ctxt);
    }
  }
}

xmlBufferAllocationScheme *__xmlBufferAllocScheme(void)
{
  if (xmlIsMainThread())
    return (xmlBufferAllocationScheme *)&xmlBufferAllocScheme;
  else
    return &xmlGetGlobalState()->xmlBufferAllocScheme;
}

int xmlIsMainThread(void)
{
  pthread_once(&once_control_2, (void (*)(void))xmlOnceInit);
  return pthread_main_np() == 1;
}

void xmlParseEndTag2(uint64_t a1, _QWORD *a2)
{
  xmlParserInput *v4;
  const xmlChar *cur;
  const xmlChar *v6;
  const xmlChar *v7;
  uint64_t v8;
  _BYTE *v9;
  int v10;
  _BYTE *v11;
  const xmlChar *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  const xmlChar *v18;
  const xmlChar *v19;
  xmlParserInput *v21;
  const xmlChar *v22;
  xmlChar *v23;
  void (*v24)(_QWORD, _QWORD, _QWORD, _QWORD);
  int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  int v29;
  const xmlChar *v30;

  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  v4 = *(xmlParserInput **)(a1 + 56);
  cur = v4->cur;
  if (*cur == 60 && cur[1] == 47)
  {
    v4->cur = cur + 2;
    v4->col += 2;
    if (!cur[2])
      xmlParserInputGrow(v4, 250);
    v6 = (const xmlChar *)*a2;
    v7 = *(const xmlChar **)(a1 + 288);
    if (*a2)
    {
      v8 = *(_QWORD *)(a1 + 56);
      if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(_QWORD *)(v8 + 40) - *(_QWORD *)(v8 + 32)) <= 249)
      {
        xmlGROW(a1);
        v8 = *(_QWORD *)(a1 + 56);
      }
      v30 = 0;
      v9 = *(_BYTE **)(v8 + 32);
      v10 = *v9;
      if (!*v9)
        goto LABEL_30;
      v11 = v9 + 2;
      v12 = v6;
      while (v10 == *v12)
      {
        ++v12;
        v10 = *(v11++ - 1);
        if (!v10)
          goto LABEL_30;
      }
      if (v10 != 58 || *v12)
        goto LABEL_30;
      v14 = (uint64_t)(v11 - 1);
      v15 = *(v11 - 1);
      if (*(v11 - 1))
      {
        v16 = 0;
        while (1)
        {
          v17 = v7[v16];
          if (v15 != v17)
            break;
          v15 = v11[v16++];
          if (!v15)
          {
            v14 = (uint64_t)&v11[v16 - 1];
            v18 = &v7[v16];
            goto LABEL_27;
          }
        }
        v14 = (uint64_t)&v11[v16 - 1];
      }
      else
      {
        v18 = v7;
LABEL_27:
        v15 = 0;
        v17 = *v18;
      }
      if (!v17 && v15 <= 0x3E && ((1 << v15) & 0x4000000100002600) != 0)
      {
        *(_DWORD *)(v8 + 56) += v14 - (_DWORD)v9;
        *(_QWORD *)(v8 + 32) = v14;
        v13 = 1;
      }
      else
      {
LABEL_30:
        v19 = xmlParseQName(a1, &v30);
        if (v30 == v6 && v19 == v7)
          v13 = 1;
        else
          v13 = (uint64_t)v19;
      }
    }
    else
    {
      v13 = xmlParseNameAndCompare(a1, *(unsigned __int8 **)(a1 + 288));
    }
    if (!*(_DWORD *)(a1 + 452)
      && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
    {
      xmlGROW(a1);
    }
    if (*(_DWORD *)(a1 + 272) != -1)
    {
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      v21 = *(xmlParserInput **)(a1 + 56);
      v22 = v21->cur;
      if (*v22 == 62)
      {
        ++v21->col;
        v21->cur = v22 + 1;
        if (!v22[1])
          xmlParserInputGrow(v21, 250);
      }
      else
      {
        xmlFatalErr((_DWORD *)a1, 73, 0);
      }
      if (v13 != 1)
      {
        if (v13)
          v23 = (xmlChar *)v13;
        else
          v23 = (xmlChar *)"unparsable";
        xmlFatalErrMsgStrIntStr((_DWORD *)a1, 76, "Opening and ending tag mismatch: %s line %d and %s\n", *(const xmlChar **)(a1 + 288), *((_DWORD *)a2 + 4), v23);
      }
      if (*(_QWORD *)a1)
      {
        v24 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 240);
        if (v24)
        {
          if (!*(_DWORD *)(a1 + 332))
            v24(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 288), *a2, a2[1]);
        }
      }
      v25 = *(_DWORD *)(a1 + 376);
      if (v25 >= 1)
      {
        v26 = v25 - 2;
        v27 = v25 - 1;
        *(_DWORD *)(a1 + 376) = v27;
        v28 = *(_QWORD *)(a1 + 384);
        if (!v27)
          v26 = 0;
        *(_QWORD *)(a1 + 368) = v28 + 4 * v26;
        *(_DWORD *)(v28 + 4 * v27) = -1;
      }
      v29 = *((_DWORD *)a2 + 5);
      if (v29)
        nsPop(a1, v29);
    }
  }
  else
  {
    xmlFatalErr((_DWORD *)a1, 74, 0);
  }
}

xmlChar *xmlParseStartTag2(uint64_t a1, const xmlChar **a2, uint64_t *a3, _DWORD *a4)
{
  xmlParserInput *v5;
  const xmlChar *cur;
  uint64_t v10;
  int v11;
  const xmlChar *v12;
  const xmlChar *v13;
  const xmlChar *base;
  int id;
  xmlChar *v16;
  uint64_t v17;
  xmlFreeFunc *v18;
  uint64_t v19;
  unsigned __int8 *v20;
  unsigned int v21;
  BOOL v22;
  uint64_t v23;
  const xmlChar *v24;
  const xmlChar *v25;
  xmlChar *v26;
  xmlHashTable *v27;
  _BOOL8 v28;
  xmlChar *v29;
  const xmlChar *v30;
  int v31;
  int v32;
  uint64_t v33;
  xmlChar *v34;
  char v35;
  unsigned __int8 *v36;
  int v37;
  _QWORD *v38;
  char v39;
  int v40;
  int v41;
  xmlChar *v42;
  const char *v43;
  xmlChar *v44;
  xmlFreeFunc *v45;
  int v46;
  xmlChar *v47;
  const char *v48;
  const xmlChar *v49;
  xmlURIPtr v50;
  xmlURI *v51;
  const xmlChar *v52;
  char *v53;
  const xmlChar *v54;
  _DWORD *v55;
  const char *v56;
  xmlChar **v57;
  uint64_t v58;
  _DWORD *v59;
  const char *v60;
  _QWORD *v61;
  uint64_t v62;
  int v63;
  int v64;
  uint64_t v65;
  const xmlChar *v66;
  xmlURIPtr v67;
  const xmlChar *v68;
  xmlChar **v69;
  uint64_t v70;
  int v71;
  int v72;
  int v73;
  _QWORD *v74;
  int v75;
  uint64_t v76;
  xmlHashTable *v77;
  int *v78;
  int *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int *v83;
  xmlChar *v84;
  const xmlChar *v85;
  const xmlChar *v86;
  int v88;
  uint64_t v89;
  const xmlChar **v90;
  xmlChar *v91;
  xmlChar **v92;
  int v93;
  BOOL v94;
  uint64_t v95;
  _QWORD *v96;
  uint64_t v97;
  int v98;
  uint64_t v99;
  const xmlChar *v100;
  const xmlChar **v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int *v106;
  uint64_t v107;
  unint64_t v108;
  const xmlChar *v109;
  xmlChar **v110;
  int v111;
  uint64_t v112;
  xmlChar *v113;
  unint64_t v114;
  const xmlChar *v115;
  const xmlChar *v116;
  const xmlChar *v117;
  uint64_t Namespace;
  uint64_t v119;
  void (*v120)(uint64_t, xmlChar *, const xmlChar *, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t);
  uint64_t v121;
  uint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  xmlURIPtr uri;
  const xmlChar **v127;
  uint64_t *v128;
  int v129;
  int v130;
  xmlChar *v131;
  int v132;
  int v133;
  int v134;
  const xmlChar **v135;
  int v136;
  int len;
  xmlChar *name2;
  const xmlChar *v139;

  v5 = *(xmlParserInput **)(a1 + 56);
  cur = v5->cur;
  if (*cur != 60)
    return 0;
  v10 = *(_QWORD *)(a1 + 464);
  v132 = *(_DWORD *)(a1 + 472);
  v11 = *(_DWORD *)(a1 + 508);
  ++v5->col;
  v5->cur = cur + 1;
  if (!cur[1])
  {
    xmlParserInputGrow(v5, 250);
    v5 = *(xmlParserInput **)(a1 + 56);
  }
  if (!*(_DWORD *)(a1 + 452))
  {
    v12 = v5->cur;
    if (v12 - v5->base >= 501 && v5->end - v12 <= 499)
    {
      xmlSHRINK(a1);
      v5 = *(xmlParserInput **)(a1 + 56);
    }
  }
  v139 = 0;
  base = v5->base;
  v13 = v5->cur;
  id = v5->id;
  *(_DWORD *)(a1 + 508) = v11;
  v16 = (xmlChar *)xmlParseQName(a1, &v139);
  if (!v16)
  {
    xmlFatalErrMsg((_DWORD *)a1, 68, (char)"StartTag: invalid element name\n");
    return v16;
  }
  v129 = id;
  v127 = a2;
  v128 = a3;
  *a4 = (_DWORD)base
      + *(_DWORD *)(*(_QWORD *)(a1 + 56) + 32)
      - ((_DWORD)v13
       + *(_DWORD *)(*(_QWORD *)(a1 + 56) + 24));
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  v133 = 0;
  v17 = 0;
  v134 = 0;
  v130 = 0;
  name2 = 0;
  v135 = (const xmlChar **)(a1 + 496);
  v18 = &xmlFree;
  v131 = v16;
  while (1)
  {
    v19 = *(_QWORD *)(a1 + 56);
    v20 = *(unsigned __int8 **)(v19 + 32);
    v21 = *v20;
    if (v21 == 47)
    {
      if (v20[1] == 62)
        goto LABEL_162;
    }
    else
    {
      if (v21 == 62)
        goto LABEL_162;
      v22 = v21 - 9 < 2 || v21 == 13;
      if (!v22 && v21 < 0x20)
        goto LABEL_162;
    }
    if (*(_DWORD *)(a1 + 272) == -1)
      goto LABEL_162;
    v23 = *(unsigned int *)(v19 + 64);
    v136 = 0;
    len = -1;
    v24 = v139;
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(_QWORD *)(v19 + 40) - (_QWORD)v20) <= 249)
      xmlGROW(a1);
    v25 = xmlParseQName(a1, (const xmlChar **)&name2);
    if (!v25)
    {
      xmlFatalErrMsg((_DWORD *)a1, 68, (char)"error parsing attribute name\n");
LABEL_41:
      v30 = 0;
      v35 = 1;
      goto LABEL_42;
    }
    v26 = (xmlChar *)v25;
    v27 = *(xmlHashTable **)(a1 + 552);
    if (v27)
      v28 = xmlHashQLookup2(v27, v24, v16, name2, v26) != 0;
    else
      v28 = 0;
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    if (**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32) != 61)
    {
      xmlFatalErrMsgStr((_DWORD *)a1, 41, "Specification mandates value for attribute %s\n", v26);
      goto LABEL_41;
    }
    xmlNextChar((xmlParserCtxtPtr)a1);
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    v29 = xmlParseAttValueInternal(a1, &len, &v136, v28);
    v30 = v29;
    if (v28)
    {
      if (v136)
      {
        if (v29)
        {
          v31 = len;
          if (len >= 1)
          {
            v32 = *v29;
            if (v32 == 32)
            {
              v33 = 0;
              do
                v32 = v29[++v33];
              while (v32 == 32);
              v34 = &v29[v33];
            }
            else
            {
              LODWORD(v33) = 0;
              v34 = v29;
            }
            do
            {
              while (v32 != 32)
              {
                if (!v32)
                {
                  if ((_DWORD)v33)
                  {
                    len -= v33;
                    memmove(v29, &v29[v33], v31 - (int)v33 + 1);
                  }
                  goto LABEL_70;
                }
                v40 = *++v34;
                v32 = v40;
              }
              v41 = *++v34;
              v32 = v41;
            }
            while ((v41 | 0x20) != 0x20);
            v42 = xmlStrndup(&v29[v33], len - (int)v33 + 1);
            if (v42)
            {
              v43 = (const char *)v42;
              xmlAttrNormalizeSpace((uint64_t)v42, v42);
              len = strlen(v43);
              if (v43 != (const char *)v30)
              {
                ((void (*)(const xmlChar *))*v18)(v30);
                v30 = (const xmlChar *)v43;
              }
            }
            else
            {
              htmlErrMemory((_DWORD *)a1, 0);
            }
          }
        }
      }
    }
LABEL_70:
    *(_DWORD *)(a1 + 272) = 7;
    if (name2 == *(xmlChar **)(a1 + 480))
    {
      if (*(_DWORD *)(a1 + 420) && xmlStrEqual(v26, (const xmlChar *)"lang"))
      {
        v44 = xmlStrndup(v30, len);
        if (!xmlCheckLanguageID(v44))
          xmlWarningMsg((_DWORD *)a1, 98, "Malformed value for xml:lang : %s\n", v44);
      }
      else
      {
        v44 = 0;
      }
      if (xmlStrEqual(v26, (const xmlChar *)"space"))
      {
        v44 = xmlStrndup(v30, len);
        if (xmlStrEqual(v44, (const xmlChar *)"default"))
        {
          **(_DWORD **)(a1 + 368) = 0;
        }
        else if (xmlStrEqual(v44, (const xmlChar *)"preserve"))
        {
          **(_DWORD **)(a1 + 368) = 1;
        }
        else
        {
          xmlWarningMsg((_DWORD *)a1, 102, "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n", v44);
        }
      }
      if (v44)
        ((void (*)(xmlChar *))*v18)(v44);
    }
    if (v30)
    {
      v45 = v18;
      v46 = len;
      if (len < 0)
      {
        v46 = xmlStrlen(v30);
        len = v46;
      }
      v47 = *(xmlChar **)(a1 + 488);
      if (v26 == v47 && !name2)
      {
        v48 = (const char *)xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v30, v46);
        if (!v48)
        {
          htmlErrMemory((_DWORD *)a1, (const xmlChar *)"dictionary allocation failure");
          v18 = v45;
          if (v136)
            ((void (*)(const xmlChar *))*v45)(v30);
          v16 = 0;
LABEL_270:
          v73 = v133;
          goto LABEL_258;
        }
        v49 = (const xmlChar *)v48;
        v18 = v45;
        if (!*v48)
          goto LABEL_115;
        v50 = xmlParseURI(v48);
        if (v50)
        {
          v51 = v50;
          if (!v50->scheme)
            xmlNsWarn((_DWORD *)a1, "xmlns: URI %s is not absolute\n", v49, 0);
          xmlFreeURI(v51);
        }
        else
        {
          xmlNsErr((_DWORD *)a1, 99, "xmlns: '%s' is not a valid URI\n", v49, 0, 0);
        }
        v18 = v45;
        if (v49 != *v135)
        {
          if (len == 29 && xmlStrEqual(v49, (const xmlChar *)"http://www.w3.org/2000/xmlns/"))
          {
            v59 = (_DWORD *)a1;
            v60 = "reuse of the xmlns namespace name is forbidden\n";
LABEL_129:
            xmlNsErr(v59, 200, v60, 0, 0, 0);
            goto LABEL_142;
          }
LABEL_115:
          v16 = v131;
          if (v134 < 1)
          {
LABEL_119:
            v63 = nsPush(a1, 0, (uint64_t)v49);
            v64 = v134;
            if (v63 > 0)
              v64 = v134 + 1;
            v134 = v64;
          }
          else
          {
            v61 = (_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * *(int *)(a1 + 508) - 16);
            v62 = (v134 + 1) - 1;
            while (*v61)
            {
              v61 -= 2;
              if (!--v62)
                goto LABEL_119;
            }
            xmlErrAttributeDup((_DWORD *)a1, 0, v26);
          }
          goto LABEL_143;
        }
        if (v26 != *(xmlChar **)(a1 + 480))
        {
          v59 = (_DWORD *)a1;
          v60 = "xml namespace URI cannot be the default namespace\n";
          goto LABEL_129;
        }
LABEL_142:
        v16 = v131;
LABEL_143:
        if (!v136)
        {
          v35 = 0;
          goto LABEL_42;
        }
        ((void (*)(const xmlChar *))*v18)(v30);
        v35 = 0;
        goto LABEL_145;
      }
      if (name2 != v47)
      {
        if (v10 && (int)v17 + 5 <= v132)
        {
          v18 = v45;
        }
        else
        {
          v18 = v45;
          if ((xmlCtxtGrowAttrs(a1, (int)v17 + 5) & 0x80000000) != 0)
            goto LABEL_142;
          v132 = *(_DWORD *)(a1 + 472);
          v10 = *(_QWORD *)(a1 + 464);
        }
        v16 = v131;
        *(_DWORD *)(*(_QWORD *)(a1 + 528) + 4 * v133) = v136;
        v57 = (xmlChar **)(v10 + 8 * (int)v17);
        *v57 = v26;
        v57[1] = name2;
        if (v136)
        {
          v58 = 0;
          v130 = 1;
        }
        else
        {
          v58 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 24);
        }
        v35 = 0;
        ++v133;
        *(_QWORD *)(v10 + 8 * ((int)v17 + 2)) = v58;
        v65 = v10 + 8 * (int)v17;
        v66 = &v30[len];
        *(_QWORD *)(v65 + 24) = v30;
        *(_QWORD *)(v65 + 32) = v66;
        v17 = (v17 + 5);
LABEL_145:
        v30 = 0;
        goto LABEL_42;
      }
      v52 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v30, v46);
      v53 = (char *)v52;
      v54 = *(const xmlChar **)(a1 + 496);
      if (v26 == *(xmlChar **)(a1 + 480))
      {
        v18 = v45;
        if (v52 != v54)
        {
          v59 = (_DWORD *)a1;
          v60 = "xml namespace prefix mapped to wrong URI\n";
          goto LABEL_129;
        }
        goto LABEL_142;
      }
      if (v52 == v54)
      {
        v55 = (_DWORD *)a1;
        v56 = "xml namespace URI mapped to wrong prefix\n";
      }
      else if (v26 == *(xmlChar **)(a1 + 488))
      {
        v55 = (_DWORD *)a1;
        v56 = "redefinition of the xmlns prefix is forbidden\n";
      }
      else
      {
        if (len != 29 || !xmlStrEqual(v52, (const xmlChar *)"http://www.w3.org/2000/xmlns/"))
        {
          if (v53 && *v53)
          {
            v67 = xmlParseURI(v53);
            if (v67)
            {
              if (*(_DWORD *)(a1 + 420) && !v67->scheme)
              {
                uri = v67;
                xmlNsWarn((_DWORD *)a1, "xmlns:%s: URI %s is not absolute\n", v26, (xmlChar *)v53);
                v67 = uri;
              }
              xmlFreeURI(v67);
            }
            else
            {
              xmlNsErr((_DWORD *)a1, 99, "xmlns:%s: '%s' is not a valid URI\n", v26, (xmlChar *)v53, 0);
            }
            if (v134 < 1)
            {
LABEL_153:
              v71 = nsPush(a1, (uint64_t)v26, (uint64_t)v53);
              v72 = v134;
              if (v71 > 0)
                v72 = v134 + 1;
              v134 = v72;
            }
            else
            {
              v69 = (xmlChar **)(*(_QWORD *)(a1 + 520) + 8 * *(int *)(a1 + 508) - 16);
              v70 = (v134 + 1) - 1;
              while (*v69 != v26)
              {
                v69 -= 2;
                if (!--v70)
                  goto LABEL_153;
              }
              xmlErrAttributeDup((_DWORD *)a1, v47, v26);
            }
            goto LABEL_141;
          }
          v55 = (_DWORD *)a1;
          v56 = "xmlns:%s: Empty XML namespace is not allowed\n";
          v68 = v26;
LABEL_140:
          xmlNsErr(v55, 200, v56, v68, 0, 0);
LABEL_141:
          v18 = v45;
          goto LABEL_142;
        }
        v55 = (_DWORD *)a1;
        v56 = "reuse of the xmlns namespace name is forbidden\n";
      }
      v68 = 0;
      goto LABEL_140;
    }
    v35 = 0;
    v16 = v131;
LABEL_42:
    if (!*(_DWORD *)(a1 + 452)
      && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
    {
      xmlGROW(a1);
    }
    if (*(_DWORD *)(a1 + 272) == -1)
      goto LABEL_161;
    v36 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
    v37 = *v36;
    if (v37 == 47)
    {
      if (v36[1] == 62)
        goto LABEL_161;
    }
    else if (v37 == 62)
    {
      goto LABEL_161;
    }
    if (!xmlSkipBlankChars((xmlParserCtxtPtr)a1))
      break;
    v38 = *(_QWORD **)(a1 + 56);
    if (v23 == v38[8])
    {
      v39 = v35 ^ 1;
      if (v20 != (unsigned __int8 *)v38[4])
        v39 = 1;
      if ((v39 & 1) == 0 && !v30)
      {
        xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"xmlParseStartTag: problem parsing attributes\n");
        goto LABEL_161;
      }
    }
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(v38[5] - v38[4]) <= 249)
      xmlGROW(a1);
  }
  xmlFatalErrMsg((_DWORD *)a1, 65, (char)"attributes construct error\n");
LABEL_161:
  v19 = *(_QWORD *)(a1 + 56);
LABEL_162:
  v73 = v133;
  if (*(_DWORD *)(v19 + 100) == v129)
  {
    if (v133 >= 1)
    {
      v74 = (_QWORD *)(v10 + 32);
      v75 = v133;
      do
      {
        v76 = *(v74 - 2);
        if (v76)
        {
          *(v74 - 2) = 0;
          *(v74 - 1) = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 24) + *(v74 - 1) - v76;
          *v74 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 24) + *v74 - v76;
        }
        v74 += 5;
        --v75;
      }
      while (v75);
    }
    v77 = *(xmlHashTable **)(a1 + 544);
    if (v77)
    {
      v78 = (int *)xmlHashLookup2(v77, v16, v139);
      if (v78)
      {
        v79 = v78;
        if (*v78 >= 1)
        {
          v80 = 0;
          v81 = 0;
          v82 = v17;
          while (1)
          {
            v83 = &v79[10 * v80];
            v85 = (const xmlChar *)*((_QWORD *)v83 + 1);
            v84 = (xmlChar *)*((_QWORD *)v83 + 2);
            name2 = v84;
            v86 = *(const xmlChar **)(a1 + 488);
            if (v85 == v86 && v84 == 0)
              break;
            v88 = v134;
            if (v84 == v86)
            {
              if (v134 >= 1)
              {
                v101 = (const xmlChar **)(*(_QWORD *)(a1 + 520) + 8 * *(int *)(a1 + 508) - 16);
                v102 = (v134 + 1) - 1;
                while (*v101 != v85)
                {
                  v101 -= 2;
                  if (!--v102)
                    goto LABEL_207;
                }
                goto LABEL_215;
              }
LABEL_207:
              if (xmlGetNamespace(a1, (uint64_t)v85) != *((_QWORD *)v79 + 3))
              {
                v103 = *(_QWORD *)&v79[10 * v80 + 6];
                v104 = a1;
                v105 = (uint64_t)v85;
                goto LABEL_212;
              }
              goto LABEL_215;
            }
            if ((int)v82 >= 1)
            {
              v89 = 0;
              while (v85 != *(const xmlChar **)(v10 + 8 * v89) || v84 != *(xmlChar **)(v10 + 8 * v89 + 8))
              {
                v89 += 5;
                if ((int)v82 <= (int)v89)
                  goto LABEL_182;
              }
              goto LABEL_215;
            }
LABEL_182:
            v17 = (v82 + 5);
            if (!v10 || (int)v17 > v132)
            {
              if ((xmlCtxtGrowAttrs(a1, (int)v82 + 5) & 0x80000000) != 0)
              {
                v16 = 0;
                v18 = &xmlFree;
                goto LABEL_270;
              }
              v132 = *(_DWORD *)(a1 + 472);
              v10 = *(_QWORD *)(a1 + 464);
            }
            v90 = (const xmlChar **)(v10 + 8 * (int)v82);
            *v90 = v85;
            v90[1] = name2;
            v91 = name2;
            if (name2)
            {
              v92 = (xmlChar **)(a1 + 496);
              if (*(xmlChar **)(a1 + 480) == name2)
              {
LABEL_192:
                v91 = *v92;
              }
              else
              {
                v93 = *(_DWORD *)(a1 + 508);
                while (1)
                {
                  v94 = __OFSUB__(v93, 2);
                  v93 -= 2;
                  if (v93 < 0 != v94)
                    break;
                  v95 = *(_QWORD *)(a1 + 520);
                  if (*(xmlChar **)(v95 + 8 * v93) == name2)
                  {
                    v92 = (xmlChar **)(v95 + 8 * (v93 + 1));
                    goto LABEL_192;
                  }
                }
                v91 = 0;
              }
            }
            *(_QWORD *)(v10 + 8 * ((int)v82 + 2)) = v91;
            v106 = &v79[10 * v80];
            v107 = v10 + 8 * (int)v82;
            *(_QWORD *)(v107 + 24) = *((_QWORD *)v106 + 3);
            *(_QWORD *)(v107 + 32) = *((_QWORD *)v106 + 4);
            if (*(_DWORD *)(a1 + 48) == 1 && *((_QWORD *)v106 + 5))
              xmlValidityError((_DWORD *)a1, 538, "standalone: attribute %s on %s defaulted from external subset\n", v85, v16);
            v81 = (v81 + 1);
LABEL_221:
            ++v80;
            v82 = v17;
            if (v80 >= *v79)
              goto LABEL_225;
          }
          v88 = v134;
          if (v134 >= 1)
          {
            v96 = (_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * *(int *)(a1 + 508) - 16);
            v97 = (v134 + 1) - 1;
            while (*v96)
            {
              v96 -= 2;
              if (!--v97)
                goto LABEL_197;
            }
            goto LABEL_215;
          }
LABEL_197:
          if (*(_QWORD *)(a1 + 480))
          {
            v98 = *(_DWORD *)(a1 + 508);
            while (1)
            {
              v94 = __OFSUB__(v98, 2);
              v98 -= 2;
              if (v98 < 0 != v94)
                break;
              v99 = *(_QWORD *)(a1 + 520);
              if (!*(_QWORD *)(v99 + 8 * v98))
              {
                v100 = *(const xmlChar **)(v99 + 8 * (v98 + 1));
                if (*v100)
                  goto LABEL_210;
                break;
              }
            }
            v100 = 0;
          }
          else
          {
            v100 = *v135;
          }
LABEL_210:
          v103 = *(_QWORD *)&v79[10 * v80 + 6];
          if (v100 != (const xmlChar *)v103)
          {
            v104 = a1;
            v105 = 0;
LABEL_212:
            if ((int)nsPush(v104, v105, v103) > 0)
              ++v88;
            v134 = v88;
          }
LABEL_215:
          v17 = v82;
          goto LABEL_221;
        }
      }
    }
    v81 = 0;
LABEL_225:
    if ((int)v17 >= 1)
    {
      v108 = 0;
      while (1)
      {
        v109 = *(const xmlChar **)(v10 + 8 * (v108 + 1));
        if (v109)
          break;
        v113 = 0;
        if (v108)
        {
LABEL_238:
          v114 = 0;
          v115 = *(const xmlChar **)(v10 + 8 * v108);
          while (1)
          {
            if (v115 == *(const xmlChar **)(v10 + 8 * v114))
            {
              v116 = *(const xmlChar **)(v10 + 8 * (v108 + 1));
              if (v116 == *(const xmlChar **)(v10 + 8 * v114 + 8))
              {
                xmlErrAttributeDup((_DWORD *)a1, v116, *(xmlChar **)(v10 + 8 * v108));
                goto LABEL_247;
              }
              if (v113 && *(xmlChar **)(v10 + 8 * v114 + 16) == v113)
                break;
            }
            v114 += 5;
            if (v114 >= v108)
              goto LABEL_247;
          }
          xmlNsErr((_DWORD *)a1, 203, "Namespaced Attribute %s in '%s' redefined\n", v115, v113, 0);
        }
LABEL_247:
        v108 += 5;
        if ((int)v17 <= (int)v108)
          goto LABEL_248;
      }
      v110 = (xmlChar **)(a1 + 496);
      if (*(const xmlChar **)(a1 + 480) == v109)
      {
LABEL_233:
        v113 = *v110;
        if (!*v110)
          goto LABEL_234;
      }
      else
      {
        v111 = *(_DWORD *)(a1 + 508);
        while (1)
        {
          v94 = __OFSUB__(v111, 2);
          v111 -= 2;
          if (v111 < 0 != v94)
            break;
          v112 = *(_QWORD *)(a1 + 520);
          if (*(const xmlChar **)(v112 + 8 * v111) == v109)
          {
            v110 = (xmlChar **)(v112 + 8 * (v111 + 1));
            goto LABEL_233;
          }
        }
LABEL_234:
        xmlNsErr((_DWORD *)a1, 201, "Namespace prefix %s for %s on %s is not defined\n", v109, *(xmlChar **)(v10 + 8 * v108), v16);
        v113 = 0;
      }
      *(_QWORD *)(v10 + 8 * v108 + 16) = v113;
      if (v108)
        goto LABEL_238;
      goto LABEL_247;
    }
LABEL_248:
    v117 = v139;
    Namespace = xmlGetNamespace(a1, (uint64_t)v139);
    v119 = Namespace;
    if (v117 && !Namespace)
      xmlNsErr((_DWORD *)a1, 201, "Namespace prefix %s on %s is not defined\n", v117, v16, 0);
    *v127 = v117;
    *v128 = v119;
    v73 = v133;
    if (*(_QWORD *)a1)
    {
      v120 = *(void (**)(uint64_t, xmlChar *, const xmlChar *, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 232);
      if (v120)
      {
        if (!*(_DWORD *)(a1 + 332))
        {
          v121 = *(_QWORD *)(a1 + 8);
          if (v134 < 1)
            v120(v121, v16, v117, v119, 0, 0, ((int)v17 / 5), v81, v10);
          else
            v120(v121, v16, v117, v119, v134, *(_QWORD *)(a1 + 520) + 8 * (*(_DWORD *)(a1 + 508) - 2 * v134), ((int)v17 / 5), v81, v10);
        }
      }
    }
    v18 = &xmlFree;
  }
  else
  {
    xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"Unexpected change of input\n");
    v16 = 0;
  }
LABEL_258:
  if (v130 && v73 >= 1)
  {
    v122 = 0;
    v123 = (_QWORD *)(v10 + 24);
    v124 = 4 * v73;
    do
    {
      if (*(_DWORD *)(*(_QWORD *)(a1 + 528) + v122) && *v123)
        ((void (*)(void))*v18)();
      v122 += 4;
      v123 += 5;
    }
    while (v124 != v122);
  }
  return v16;
}

int xmlSkipBlankChars(xmlParserCtxtPtr ctxt)
{
  xmlParserInputState instate;
  BOOL v3;
  unint64_t v4;
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v7;
  int v8;
  const xmlChar *v10;
  uint64_t v11;
  unsigned int v12;
  BOOL v13;
  uint64_t v14;

  instate = ctxt->instate;
  if (ctxt->inputNr == 1)
  {
    if (instate == XML_PARSER_DTD)
    {
      v3 = ctxt->external == 0;
      goto LABEL_22;
    }
    goto LABEL_6;
  }
  if (instate == XML_PARSER_EOF)
  {
    v4 = 0;
    goto LABEL_18;
  }
  if (instate == XML_PARSER_START)
  {
LABEL_6:
    v4 = 0;
LABEL_7:
    input = ctxt->input;
    cur = input->cur;
    while (1)
    {
      v7 = *cur;
      if (v7 == 32)
        goto LABEL_13;
      if ((v7 - 9) >= 2)
        break;
      if (v7 != 10)
        goto LABEL_13;
      ++input->line;
      input->col = 1;
LABEL_14:
      v8 = *++cur;
      ++v4;
      if (!v8)
      {
        input->cur = cur;
        xmlParserInputGrow(input, 250);
        goto LABEL_7;
      }
    }
    if (v7 != 13)
    {
      input->cur = cur;
      goto LABEL_18;
    }
LABEL_13:
    ++input->col;
    goto LABEL_14;
  }
  v3 = 0;
LABEL_22:
  v4 = 0;
  do
  {
    v10 = ctxt->input->cur;
    v11 = *v10;
    if (v11 > 0x25)
      break;
    if (((1 << v11) & 0x100002600) != 0)
    {
      xmlNextChar(ctxt);
    }
    else if (*v10)
    {
      if (v11 != 37 || v3)
        break;
      v12 = v10[1];
      v13 = v12 > 0x20;
      v14 = (1 << v12) & 0x100002601;
      if (!v13 && v14 != 0)
        break;
      xmlParsePEReference(ctxt);
    }
    else
    {
      if (ctxt->inputNr < 2)
        break;
      xmlPopInput(ctxt);
    }
    ++v4;
  }
  while (ctxt->instate != XML_PARSER_EOF);
LABEL_18:
  if (v4 >= 0x7FFFFFFF)
    return 0x7FFFFFFF;
  else
    return v4;
}

void xmlNextChar(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  const xmlChar *end;
  xmlParserInputPtr v5;
  const xmlChar *v6;
  int v7;
  int v8;
  unint64_t v9;
  _BYTE *v10;
  int v11;
  int v12;
  const xmlChar *v13;
  const char *v14;
  xmlParserCtxtPtr v15;
  char *v16;
  unsigned int v17;
  char __str[16];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _WORD v28[11];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (ctxt)
  {
    if (ctxt->instate != XML_PARSER_EOF)
    {
      input = ctxt->input;
      if (input)
      {
        cur = input->cur;
        end = input->end;
        if (cur > end)
        {
          xmlErrInternal(ctxt, "Parser input data memory error\n", 0);
          ctxt->errNo = 1;
          xmlStopParser(ctxt);
          return;
        }
        if (end - cur > 0 || xmlParserInputGrow(input, 250) >= 1)
        {
          v5 = ctxt->input;
          v6 = v5->cur;
          v7 = *v6;
          if (ctxt->charset == 1)
          {
            if (v7 == 10)
            {
              ++v5->line;
              v5->col = 1;
            }
            else
            {
              ++v5->col;
            }
            if (*(char *)v6 < 0)
            {
              v8 = *v6;
              if (v8 == 192
                || (v9 = v5->end - v6, v9 <= 1)
                && (xmlParserInputGrow(v5, 250), v5 = ctxt->input, v6 = v5->cur, v9 = v5->end - v6, v9 < 2)
                || (v6[1] & 0xC0) != 0x80)
              {
LABEL_35:
                if (v5->end - v5->cur > 3)
                {
                  v27 = 0u;
                  memset(v28, 0, sizeof(v28));
                  v25 = 0u;
                  v26 = 0u;
                  v23 = 0u;
                  v24 = 0u;
                  v21 = 0u;
                  v22 = 0u;
                  *(_OWORD *)__str = 0u;
                  snprintf(__str, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", *v5->cur, *((unsigned __int8 *)v5->cur + 1), *((unsigned __int8 *)v5->cur + 2), *((unsigned __int8 *)v5->cur + 3));
                  v14 = "Input is not proper UTF-8, indicate encoding !\n%s";
                  v16 = __str;
                  v15 = ctxt;
                }
                else
                {
                  v14 = "Input is not proper UTF-8, indicate encoding !\n";
                  v15 = ctxt;
                  v16 = 0;
                }
                __xmlErrEncoding(v15, 9, v14, (const xmlChar *)v16, 0);
                ctxt->charset = 10;
                ++ctxt->input->cur;
                return;
              }
              if ((~v8 & 0xE0) == 0)
              {
                if (v9 > 2 || (xmlParserInputGrow(v5, 250), v5 = ctxt->input, v6 = v5->cur, v9 = v5->end - v6, v9 >= 3))
                {
                  v10 = v6 + 2;
                  if ((v6[2] & 0xC0) == 0x80)
                  {
                    if ((~v8 & 0xF0) != 0)
                    {
                      v5->cur += 3;
                      v12 = (*v6 & 0xF) << 12;
                      v11 = (v6[1] & 0x3F) << 6;
                      goto LABEL_42;
                    }
                    if (v9 <= 3)
                    {
                      xmlParserInputGrow(v5, 250);
                      v5 = ctxt->input;
                      v6 = v5->cur;
                      v9 = v5->end - v6;
                    }
                    if ((v8 & 0xF8) == 0xF0 && v9 >= 4)
                    {
                      v10 = v6 + 3;
                      if ((v6[3] & 0xC0) == 0x80)
                      {
                        v5->cur += 4;
                        v11 = ((*v6 & 7) << 18) | ((v6[1] & 0x3F) << 12);
                        v12 = (v6[2] & 0x3F) << 6;
LABEL_42:
                        v17 = v11 | v12 | *v10 & 0x3F;
                        if ((v11 | v12) >> 11 == 27
                          || HIWORD(v17) > 0x10u
                          || ((v11 | v12) & 0x1FFFFE | *v10 & 0x3E) == 65534)
                        {
                          xmlErrEncodingInt(ctxt, "Char 0x%X out of allowed range\n", v17);
                          v5 = ctxt->input;
                        }
                        goto LABEL_33;
                      }
                    }
                  }
                }
                goto LABEL_35;
              }
              v13 = v6 + 2;
LABEL_32:
              v5->cur = v13;
LABEL_33:
              if (v5->end - v5->cur <= 0)
                xmlParserInputGrow(v5, 250);
              return;
            }
          }
          else if (v7 == 10)
          {
            ++v5->line;
            v5->col = 1;
          }
          else
          {
            ++v5->col;
          }
          v13 = v6 + 1;
          goto LABEL_32;
        }
      }
    }
  }
}

const xmlChar *xmlParseQName(uint64_t a1, const xmlChar **a2)
{
  const xmlChar *v4;
  int v5;
  const xmlChar *v6;
  xmlChar *v7;
  const xmlChar *v8;
  const xmlChar *v9;
  xmlChar *v10;
  const xmlChar *v11;
  const xmlChar *v12;
  xmlChar *v13;
  xmlChar *v14;
  xmlChar *v15;

  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  v4 = xmlParseNCName(a1);
  v5 = **(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
  if (v4)
  {
    v6 = v4;
    if (v5 == 58)
    {
      xmlNextChar((xmlParserCtxtPtr)a1);
      v7 = (xmlChar *)xmlParseNCName(a1);
      if (v7)
      {
        v8 = v7;
        if (**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32) == 58)
        {
          xmlNsErr((_DWORD *)a1, 202, "Failed to parse QName '%s:%s:'\n", v6, v7, 0);
          xmlNextChar((xmlParserCtxtPtr)a1);
          v9 = xmlParseName((xmlParserCtxtPtr)a1);
          if (v9)
          {
LABEL_11:
            v10 = xmlBuildQName(v9, v8, 0, 0);
            v11 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v10, -1);
            if (v10)
              xmlFree(v10);
            v12 = v6;
            v6 = v11;
            goto LABEL_26;
          }
          if (*(_DWORD *)(a1 + 272) != -1)
          {
            v9 = (const xmlChar *)&byte_1B0865C1A;
            goto LABEL_11;
          }
          return 0;
        }
        v12 = v6;
        v6 = v7;
LABEL_26:
        *a2 = v12;
        return v6;
      }
      if (*(_DWORD *)(a1 + 272) == -1)
        return 0;
      xmlNsErr((_DWORD *)a1, 202, "Failed to parse QName '%s:'\n", v6, 0, 0);
      v13 = xmlParseNmtoken((xmlParserCtxtPtr)a1);
      if (v13)
      {
        v14 = v13;
        v15 = xmlBuildQName(v13, v6, 0, 0);
        xmlFree(v14);
      }
      else
      {
        if (*(_DWORD *)(a1 + 272) == -1)
          return 0;
        v15 = xmlBuildQName((const xmlChar *)&byte_1B0865C1A, v6, 0, 0);
      }
      v6 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v15, -1);
      if (v15)
        xmlFree(v15);
    }
LABEL_25:
    v12 = 0;
    goto LABEL_26;
  }
  if (v5 != 58)
    return 0;
  v6 = xmlParseName((xmlParserCtxtPtr)a1);
  if (v6)
  {
    xmlNsErr((_DWORD *)a1, 202, "Failed to parse QName '%s'\n", v6, 0, 0);
    goto LABEL_25;
  }
  return v6;
}

const xmlChar *xmlParseNCName(uint64_t a1)
{
  int v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  const xmlChar *v6;
  int v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v14;
  const xmlChar *result;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  const xmlChar *v25;
  int v26;
  int v27;
  uint64_t v28;
  _BYTE *v29;
  _BYTE *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int len;

  v2 = *(_DWORD *)(a1 + 564);
  if ((v2 & 0x80000) != 0)
    v3 = 10000000;
  else
    v3 = 50000;
  v4 = *(_QWORD **)(a1 + 56);
  v6 = (const xmlChar *)v4[4];
  v5 = v4[5];
  v7 = *v6;
  if ((v7 & 0xFFFFFFDF) - 65 >= 0x1A)
  {
    if (v7 != 95 || (unint64_t)v6 >= v5)
      goto LABEL_27;
  }
  else if ((unint64_t)v6 >= v5)
  {
    goto LABEL_27;
  }
  v9 = 0;
  do
  {
    v10 = v9;
    v11 = v6[v9 + 1];
    if ((v11 - 48) >= 0xA
      && (v11 & 0xFFFFFFDF) - 65 >= 0x1A
      && ((v11 - 45) > 0x32 || ((1 << (v11 - 45)) & 0x4000000000003) == 0))
    {
      break;
    }
    ++v9;
  }
  while ((unint64_t)&v6[v10 + 1] < v5);
  v14 = (unint64_t)&v6[v10 + 1];
  if (v14 < v5 && (char)v11 >= 1)
  {
    if (v10 + 1 <= v3)
    {
      result = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v6, (int)v10 + 1);
      v16 = *(_QWORD *)(a1 + 56);
      *(_QWORD *)(v16 + 32) = v14;
      *(_DWORD *)(v16 + 56) += v10 + 1;
      if (result)
        return result;
      htmlErrMemory((_DWORD *)a1, 0);
      return 0;
    }
    goto LABEL_65;
  }
LABEL_27:
  if ((v2 & 0x80000) != 0)
    v17 = 10000000;
  else
    v17 = 50000;
  if (!*(_DWORD *)(a1 + 452) && (uint64_t)(v5 - (_QWORD)v6) <= 249)
  {
    xmlGROW(a1);
    v4 = *(_QWORD **)(a1 + 56);
    v6 = (const xmlChar *)v4[4];
  }
  len = 0;
  v18 = v4[3];
  v19 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len);
  v20 = v19;
  if (v19 <= 0x3E && ((1 << v19) & 0x4000800100000000) != 0)
    return 0;
  xmlIsNameStartChar(a1, v19);
  v22 = v21;
  result = 0;
  if (v20 != 58 && v22)
  {
    v23 = 0;
    v24 = 0;
    v25 = &v6[-v18];
    while (v20 > 0x3E || ((1 << v20) & 0x4000800100000000) == 0)
    {
      xmlIsNameChar(a1, v20);
      if (v20 == 58 || !v26)
        break;
      if (v24 < 101)
      {
        ++v24;
      }
      else
      {
        if (!*(_DWORD *)(a1 + 452)
          && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
        {
          xmlGROW(a1);
        }
        if (*(_DWORD *)(a1 + 272) == -1)
          return 0;
        v24 = 0;
      }
      if (v23 <= (len ^ 0x7FFFFFFF))
        v27 = len;
      else
        v27 = 0;
      v28 = *(_QWORD *)(a1 + 56);
      v29 = *(_BYTE **)(v28 + 32);
      v30 = &v29[len];
      if ((unint64_t)v30 <= *(_QWORD *)(v28 + 40))
      {
        if (*v29 == 10)
        {
          ++*(_DWORD *)(v28 + 52);
          *(_DWORD *)(v28 + 56) = 1;
        }
        else
        {
          ++*(_DWORD *)(v28 + 56);
        }
        *(_QWORD *)(v28 + 32) = v30;
      }
      v23 += v27;
      v20 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len);
      if (!v20)
      {
        if (*(_DWORD *)(a1 + 272) == -1)
          return 0;
        v31 = len;
        v32 = *(_QWORD *)(a1 + 56);
        v33 = *(_QWORD *)(v32 + 32) - len;
        *(_QWORD *)(v32 + 32) = v33;
        if (!*(_DWORD *)(a1 + 452) && *(_QWORD *)(v32 + 40) - v33 <= 249)
        {
          xmlGROW(a1);
          if (*(_DWORD *)(a1 + 272) == -1)
            return 0;
          v31 = len;
          v32 = *(_QWORD *)(a1 + 56);
          v33 = *(_QWORD *)(v32 + 32);
        }
        *(_QWORD *)(v32 + 32) = v33 + v31;
        v20 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len);
        v24 = 0;
      }
    }
    if (v23 <= v17)
      return xmlDictLookup(*(xmlDictPtr *)(a1 + 456), &v25[*(_QWORD *)(*(_QWORD *)(a1 + 56) + 24)], v23);
LABEL_65:
    xmlFatalErr((_DWORD *)a1, 110, (const xmlChar *)"NCName");
    return 0;
  }
  return result;
}

const xmlChar *__cdecl xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len)
{
  xmlChar *v3;
  size_t v6;
  size_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int v10;
  const xmlChar *v11;
  size_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t v23;
  const xmlChar *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  size_t v29;
  unint64_t v30;
  size_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  _QWORD *v35;
  _BYTE *v36;
  _QWORD *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v41;

  v3 = 0;
  if (!dict || !name)
    return v3;
  if (len < 0)
    v6 = strlen((const char *)name);
  else
    v6 = len;
  v7 = *((_QWORD *)dict + 7);
  if (v7)
  {
    v3 = 0;
    if (v6 >> 30 || v6 >= v7)
      return v3;
  }
  else if (v6 >> 30)
  {
    return 0;
  }
  v8 = *((_QWORD *)dict + 2);
  if (v8 == 128)
  {
    v9 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *((_DWORD *)dict + 12));
  }
  else
  {
    if (v6)
    {
      v10 = *((_DWORD *)dict + 12);
      v11 = name;
      v12 = v6;
      do
      {
        v13 = *v11++;
        v10 = (1025 * (v10 + v13)) ^ ((1025 * (v10 + v13)) >> 6);
        --v12;
      }
      while (v12);
      v14 = 32769 * ((9 * v10) ^ ((9 * v10) >> 11));
    }
    else
    {
      v14 = 0;
    }
    v9 = v14;
  }
  v15 = *((_QWORD *)dict + 1) + 32 * (v9 % v8);
  v41 = v9 % v8;
  if (!*(_DWORD *)(v15 + 20))
  {
    v17 = 0;
    v15 = 0;
LABEL_32:
    v19 = *((_QWORD *)dict + 5);
    if (v19)
    {
      v20 = *(_QWORD *)(v19 + 16);
      if (v8 == 128)
      {
        if (v20 == 128)
        {
          v21 = v9;
        }
        else if ((int)v6 < 1)
        {
          v21 = 0;
        }
        else
        {
          v22 = *(_DWORD *)(v19 + 48);
          v23 = v6;
          v24 = name;
          do
          {
            v25 = *v24++;
            v22 = (1025 * (v22 + v25)) ^ ((1025 * (v22 + v25)) >> 6);
            --v23;
          }
          while (v23);
          v21 = 32769 * ((9 * v22) ^ ((9 * v22) >> 11));
        }
      }
      else
      {
        v21 = v9;
        if (v20 == 128)
        {
          v21 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *(_DWORD *)(v19 + 48));
          v20 = 128;
        }
      }
      v26 = *(_QWORD *)(v19 + 8) + 32 * (v21 % v20);
      if (*(_DWORD *)(v26 + 20))
      {
        while (*(_QWORD *)v26)
        {
          v27 = v26;
          v26 = *(_QWORD *)v26;
          if (*(_QWORD *)(v27 + 24) == v21 && v6 == *(_DWORD *)(v27 + 16))
          {
            v3 = *(xmlChar **)(v27 + 8);
            if (!memcmp(v3, name, v6))
              return v3;
          }
          ++v17;
        }
        if (*(_QWORD *)(v26 + 24) == v21 && v6 == *(_DWORD *)(v26 + 16))
        {
          v3 = *(xmlChar **)(v26 + 8);
          if (!memcmp(v3, name, v6))
            return v3;
        }
      }
    }
    v28 = (_QWORD *)*((_QWORD *)dict + 4);
    if (v28)
    {
      v29 = 0;
      v30 = 0;
      v31 = v6;
      while (1)
      {
        v3 = (xmlChar *)v28[1];
        if (v28[2] - (_QWORD)v3 > (unint64_t)v6)
          break;
        v32 = v28[3];
        if (v32 > v30)
          v30 = v28[3];
        v29 += v32;
        v28 = (_QWORD *)*v28;
        if (!v28)
        {
          if (v7 && v29 > v7)
            return 0;
          if (!v30)
            goto LABEL_62;
          v33 = 4 * v30;
          goto LABEL_63;
        }
      }
    }
    else
    {
LABEL_62:
      v33 = 1000;
LABEL_63:
      if (v33 <= (4 * v6))
        v34 = (4 * v6);
      else
        v34 = v33;
      v35 = xmlMalloc(v34 + 48);
      if (!v35)
        return 0;
      v28 = v35;
      v35[3] = v34;
      v35[4] = 0;
      v3 = (xmlChar *)(v35 + 5);
      v35[2] = (char *)v35 + v34 + 40;
      *v35 = *((_QWORD *)dict + 4);
      v35[1] = v35 + 5;
      *((_QWORD *)dict + 4) = v35;
      v31 = v6;
    }
    memcpy(v3, name, v31);
    v36 = (_BYTE *)(v28[1] + v31);
    v28[1] = v36 + 1;
    *v36 = 0;
    ++v28[4];
    if (!v3)
      return v3;
    if (v15)
    {
      v37 = xmlMalloc(0x20uLL);
      if (!v37)
        return 0;
      *v37 = 0;
      v37[1] = v3;
      *((_DWORD *)v37 + 4) = v6;
      *((_DWORD *)v37 + 5) = 1;
      v37[3] = v9;
      *(_QWORD *)v15 = v37;
    }
    else
    {
      v38 = *((_QWORD *)dict + 1) + 32 * v41;
      *(_QWORD *)v38 = 0;
      *(_QWORD *)(v38 + 8) = v3;
      *(_DWORD *)(v38 + 16) = v6;
      *(_DWORD *)(v38 + 20) = 1;
      *(_QWORD *)(v38 + 24) = v9;
    }
    ++*((_DWORD *)dict + 6);
    if (v17 < 4)
      return v3;
    v39 = *((_QWORD *)dict + 2);
    if (v39 > 0xAAA || !xmlDictGrow((uint64_t)dict, 6 * v39))
      return v3;
    return 0;
  }
  v16 = *(_QWORD *)v15;
  if (*(_QWORD *)v15)
  {
    v17 = 0;
    while (1)
    {
      v18 = v15;
      v15 = v16;
      if (*(_QWORD *)(v18 + 24) == v9 && v6 == *(_DWORD *)(v18 + 16))
      {
        v3 = *(xmlChar **)(v18 + 8);
        if (!memcmp(v3, name, v6))
          return v3;
      }
      ++v17;
      v16 = *(_QWORD *)v15;
      if (!*(_QWORD *)v15)
        goto LABEL_29;
    }
  }
  v17 = 0;
LABEL_29:
  if (*(_QWORD *)(v15 + 24) != v9)
    goto LABEL_32;
  if (v6 != *(_DWORD *)(v15 + 16))
    goto LABEL_32;
  v3 = *(xmlChar **)(v15 + 8);
  if (memcmp(v3, name, v6))
    goto LABEL_32;
  return v3;
}

uint64_t xmlDictComputeFastKey(unsigned __int8 *a1, int a2, int a3)
{
  uint64_t result;

  result = a3;
  if (a1 && a2 >= 1)
  {
    result = 32 * (*a1 + (uint64_t)a3);
    if (a2 < 0xB)
    {
      switch(a2)
      {
        case 2:
          goto LABEL_13;
        case 3:
          goto LABEL_12;
        case 4:
          goto LABEL_11;
        case 5:
          goto LABEL_10;
        case 6:
          goto LABEL_9;
        case 7:
          goto LABEL_8;
        case 8:
          goto LABEL_7;
        case 9:
          goto LABEL_6;
        case 10:
          goto LABEL_5;
        default:
          return result;
      }
    }
    else
    {
      result += a1[a2 - 1];
LABEL_5:
      result += a1[9];
LABEL_6:
      result += a1[8];
LABEL_7:
      result += a1[7];
LABEL_8:
      result += a1[6];
LABEL_9:
      result += a1[5];
LABEL_10:
      result += a1[4];
LABEL_11:
      result += a1[3];
LABEL_12:
      result += a1[2];
LABEL_13:
      result += a1[1];
    }
  }
  return result;
}

xmlChar *xmlParseAttValueInternal(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  xmlChar *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  uint64_t v32;
  uint64_t v33;
  xmlChar *i;
  int v35;
  int v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  xmlChar *v50;
  xmlChar *v51;
  xmlChar *v52;
  int v53;
  BOOL v54;
  unsigned int v55;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _DWORD *v60;
  unint64_t v61;
  int v62;
  xmlChar *v63;
  int v64;
  unint64_t v65;
  unsigned __int8 **v66;
  unint64_t v67;
  unsigned __int8 *v68;
  int v69;
  xmlEntityPtr v70;
  uint64_t v71;
  xmlChar *v72;
  xmlChar *v73;
  uint64_t v74;
  _BYTE *v75;
  _BYTE *v76;
  xmlChar *v77;
  xmlChar *v78;
  xmlChar *v79;
  unint64_t v80;
  int v81;
  unint64_t v83;
  int v84;
  int v85;
  int v86;
  xmlChar *v87;
  const xmlChar *v88;
  uint64_t v89;
  int v90;
  xmlChar *v91;
  uint64_t v92;
  int v93;
  xmlChar *v94;
  xmlChar *v95;
  xmlChar *v96;
  unint64_t v97;
  unsigned int v98;
  xmlChar v99;
  unint64_t v100;
  _DWORD *v102;
  int v103;
  const char *v104;
  _DWORD *v105;
  int v106;
  int v107;
  unint64_t v108;
  uint64_t v109;
  int v110;
  unint64_t v111;
  _DWORD *v112;
  int v113;
  _DWORD *v114;
  int len;

  v7 = a1;
  if ((*(_BYTE *)(a1 + 566) & 8) != 0)
    v8 = 1000000000;
  else
    v8 = 10000000;
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
  {
    v9 = v8;
    xmlGROW(a1);
    v8 = v9;
  }
  v10 = *(_QWORD *)(v7 + 56);
  v11 = *(unsigned __int8 **)(v10 + 32);
  v12 = *(_DWORD *)(v10 + 52);
  v13 = *v11;
  if (v13 != 34 && v13 != 39)
    goto LABEL_236;
  v14 = *(_DWORD *)(v10 + 56);
  v15 = 12;
  *(_DWORD *)(v7 + 272) = 12;
  v16 = v11 + 1;
  v17 = *v11;
  v18 = *(_QWORD *)(v10 + 40);
  v114 = a3;
  if ((unint64_t)(v11 + 1) >= v18)
  {
    v19 = *(_QWORD *)(v10 + 24);
    if ((uint64_t)(v18 - (_QWORD)v11) <= 249 && *(_DWORD *)(v7 + 452) == 0)
    {
      v21 = v8;
      xmlGROW(v7);
      v8 = v21;
      v15 = *(_DWORD *)(v7 + 272);
      if (v15 == -1)
        return 0;
    }
    else
    {
      v15 = 12;
    }
    v10 = *(_QWORD *)(v7 + 56);
    v22 = *(_QWORD *)(v10 + 24) - v19;
    if (!v22)
      v22 = 0;
    v16 += v22;
    v18 = *(_QWORD *)(v10 + 40);
  }
  v23 = v14 + 1;
  if ((_DWORD)a4)
  {
    while ((unint64_t)v16 < v18)
    {
      v24 = *v16;
      if (v24 == (_DWORD)v17)
        break;
      if (v24 > 0x20 || ((1 << v24) & 0x100002600) == 0)
        break;
      if (v24 == 10)
      {
        ++v12;
        v23 = 1;
      }
      else
      {
        ++v23;
      }
      if ((unint64_t)++v16 >= v18)
      {
        v26 = *(_QWORD *)(v10 + 24);
        if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(_QWORD *)(v10 + 40) - *(_QWORD *)(v10 + 32)) <= 249)
        {
          v27 = v7;
          v28 = v17;
          v29 = v7;
          v30 = a4;
          v31 = a2;
          v32 = v8;
          xmlGROW(v27);
          v8 = v32;
          a2 = v31;
          a4 = v30;
          v7 = v29;
          v17 = v28;
          v15 = *(_DWORD *)(v7 + 272);
        }
        if (v15 == -1)
          return 0;
        v10 = *(_QWORD *)(v7 + 56);
        v33 = *(_QWORD *)(v10 + 24) - v26;
        if (!v33)
          v33 = 0;
        v16 += v33;
        v18 = *(_QWORD *)(v10 + 40);
      }
    }
    v112 = a2;
    v113 = a4;
    i = v16;
    if ((unint64_t)v16 < v18)
    {
      while (1)
      {
        v35 = v23;
        v36 = *v16;
        if ((char)*v16 < 32 || v36 == (_DWORD)v17)
          break;
        if (v36 == 38)
          break;
        if (v36 == 60)
          break;
        ++v23;
        ++v16;
        if (v36 == 32 && *v16 == 32)
          break;
        if ((unint64_t)v16 >= v18)
        {
          v38 = *(_QWORD *)(v10 + 24);
          if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(_QWORD *)(v10 + 40) - *(_QWORD *)(v10 + 32)) <= 249)
          {
            v39 = v7;
            v110 = v17;
            v17 = v7;
            v40 = a4;
            v41 = a2;
            v42 = v8;
            xmlGROW(v39);
            v8 = v42;
            a2 = v41;
            a4 = v40;
            v7 = v17;
            LODWORD(v17) = v110;
            v15 = *(_DWORD *)(v7 + 272);
          }
          if (v15 == -1)
            return 0;
          v10 = *(_QWORD *)(v7 + 56);
          v43 = *(_QWORD *)(v10 + 24) - v38;
          if (!v43)
            v43 = 0;
          i += v43;
          v16 += v43;
          if (v16 - i > v8)
            goto LABEL_102;
          v18 = *(_QWORD *)(v10 + 40);
        }
        if ((unint64_t)v16 >= v18)
        {
          v23 = v35 + 1;
          break;
        }
      }
    }
    v50 = v16;
    v51 = v16;
    v52 = v16;
    do
    {
      v53 = *--v52;
      v54 = v53 == 32 && v51 > i;
      v51 = v52;
    }
    while (v54);
    LODWORD(v16) = (_DWORD)v52 + 1;
    while ((unint64_t)v50 < v18)
    {
      v55 = *v50;
      if (v55 == (_DWORD)v17)
        break;
      if (v55 > 0x20 || ((1 << v55) & 0x100002600) == 0)
        break;
      if (v55 == 10)
      {
        ++v12;
        v23 = 1;
      }
      else
      {
        ++v23;
      }
      if ((unint64_t)++v50 >= v18)
      {
        v57 = *(_QWORD *)(v10 + 24);
        if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(_QWORD *)(v10 + 40) - *(_QWORD *)(v10 + 32)) <= 249)
        {
          v58 = v8;
          xmlGROW(v7);
          v8 = v58;
          v15 = *(_DWORD *)(v7 + 272);
        }
        if (v15 == -1)
          return 0;
        v10 = *(_QWORD *)(v7 + 56);
        v59 = *(_QWORD *)(v10 + 24) - v57;
        if (!v59)
          v59 = 0;
        i += v59;
        v50 += v59;
        if (v50 - i > v8)
          goto LABEL_102;
        LODWORD(v16) = (_DWORD)v16 + v59;
        v18 = *(_QWORD *)(v10 + 40);
      }
    }
    if (v50 - i > v8)
      goto LABEL_102;
    v49 = *v50;
  }
  else
  {
    for (i = v16; (unint64_t)v16 < v18; ++v23)
    {
      v44 = *v16;
      v45 = (char)*v16 < 32 || v44 == (_DWORD)v17;
      if (v45 || v44 == 38 || v44 == 60)
        break;
      if ((unint64_t)++v16 >= v18)
      {
        v46 = *(_QWORD *)(v10 + 24);
        if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(_QWORD *)(v10 + 40) - *(_QWORD *)(v10 + 32)) <= 249)
        {
          v47 = v8;
          xmlGROW(v7);
          v8 = v47;
          v15 = *(_DWORD *)(v7 + 272);
        }
        if (v15 == -1)
          return 0;
        v10 = *(_QWORD *)(v7 + 56);
        v48 = *(_QWORD *)(v10 + 24) - v46;
        if (!v48)
          v48 = 0;
        i += v48;
        v16 += v48;
        if (v16 - i > v8)
          goto LABEL_102;
        v18 = *(_QWORD *)(v10 + 40);
      }
    }
    if (v16 - i > v8)
    {
LABEL_102:
      xmlFatalErrMsg((_DWORD *)v7, 40, (char)"AttValue length too long\n");
      return 0;
    }
    v113 = 0;
    v112 = a2;
    v49 = *v16;
    v50 = v16;
  }
  if (v49 == (_DWORD)v17)
  {
    if (v112)
    {
      *v112 = (_DWORD)v16 - (_DWORD)i;
      v60 = v114;
    }
    else
    {
      v60 = v114;
      if (v114)
        *v114 = 1;
      i = xmlStrndup(i, (int)v16 - (int)i);
      v10 = *(_QWORD *)(v7 + 56);
    }
    *(_QWORD *)(v10 + 32) = v50 + 1;
    *(_DWORD *)(v10 + 52) = v12;
    *(_DWORD *)(v10 + 56) = v23 + 1;
    if (v60)
      *v60 = 0;
    return i;
  }
  if (v114)
    *v114 = 1;
  v61 = (*(_DWORD *)(v7 + 564) & 0x80000) != 0 ? 1000000000 : 10000000;
  len = 0;
  v62 = **(unsigned __int8 **)(v10 + 32);
  if (v62 != 34 && v62 != 39)
  {
LABEL_236:
    xmlFatalErr((_DWORD *)v7, 39, 0);
    return 0;
  }
  *(_DWORD *)(v7 + 272) = 12;
  xmlNextChar((xmlParserCtxtPtr)v7);
  v63 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (!v63)
  {
    v72 = 0;
LABEL_245:
    v66 = 0;
    goto LABEL_246;
  }
  i = v63;
  v64 = xmlCurrentChar((xmlParserCtxtPtr)v7, &len);
  v65 = 0;
  LODWORD(v66) = 0;
  v67 = 100;
  while (1)
  {
    v68 = *(unsigned __int8 **)(*(_QWORD *)(v7 + 56) + 32);
    if (v62 == *v68)
    {
LABEL_250:
      if (*(_DWORD *)(v7 + 272) == -1)
      {
LABEL_257:
        v66 = 0;
        goto LABEL_247;
      }
      if (v113)
      {
        v102 = v112;
        if ((_DWORD)v66 && v65)
        {
          do
          {
            if (i[v65 - 1] != 32)
              break;
            --v65;
          }
          while (v65);
        }
      }
      else
      {
        v102 = v112;
      }
      i[v65] = 0;
      v103 = **(unsigned __int8 **)(*(_QWORD *)(v7 + 56) + 32);
      if (v103 == 60)
      {
        xmlFatalErr((_DWORD *)v7, 38, 0);
        goto LABEL_277;
      }
      if (v62 == v103)
      {
        xmlNextChar((xmlParserCtxtPtr)v7);
        goto LABEL_277;
      }
      if (v64)
      {
        if (v64 > 255)
        {
          if ((v64 - 0x10000) >= 0x100000
            && v64 >> 11 >= 0x1B
            && (v64 - 57344) >> 1 >= 0xFFF)
          {
            goto LABEL_274;
          }
        }
        else if (v64 <= 31 && (v64 > 0xD || ((1 << v64) & 0x2600) == 0))
        {
LABEL_274:
          v104 = "invalid character in attribute value\n";
          v105 = (_DWORD *)v7;
          v106 = 9;
LABEL_276:
          xmlFatalErrMsg(v105, v106, (char)v104);
LABEL_277:
          if (v102)
            *v102 = v65;
          return i;
        }
      }
      v104 = "AttValue: ' expected\n";
      v105 = (_DWORD *)v7;
      v106 = 40;
      goto LABEL_276;
    }
    if (v64 > 255)
    {
      if ((v64 - 0x10000) >= 0x100000
        && v64 >> 11 >= 0x1B
        && (v64 - 57344) >> 1 >= 0xFFF)
      {
        goto LABEL_250;
      }
    }
    else if (v64 <= 31)
    {
      if (v64 > 0xD || ((1 << v64) & 0x2600) == 0)
        goto LABEL_250;
    }
    else if (v64 == 60)
    {
      goto LABEL_250;
    }
    if (*(_DWORD *)(v7 + 272) == -1)
      goto LABEL_257;
    if (v64 > 0x26)
    {
LABEL_147:
      if (len == 1)
        i[v65++] = v64;
      else
        v65 += xmlCopyCharMultiByte(&i[v65], v64);
      if (v65 + 10 <= v67)
      {
        LODWORD(v66) = 0;
      }
      else
      {
        if (2 * v67 + 10 < v67)
          goto LABEL_258;
        v73 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
        if (!v73)
          goto LABEL_258;
        LODWORD(v66) = 0;
        i = v73;
        v67 = 2 * v67 + 10;
      }
      goto LABEL_167;
    }
    if (((1 << v64) & 0x100002600) != 0)
    {
      if (!v113 || v65)
      {
        if (v113 && (_DWORD)v66)
        {
          LODWORD(v66) = 1;
        }
        else
        {
          if (len == 1)
            i[v65++] = 32;
          else
            v65 += xmlCopyCharMultiByte(&i[v65], 32);
          while (1)
          {
            v72 = i;
            if (v65 + 10 <= v67)
              break;
            if (2 * v67 + 10 >= v67)
            {
              i = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
              v67 = 2 * v67 + 10;
              if (i)
                continue;
            }
            goto LABEL_245;
          }
          LODWORD(v66) = 1;
        }
      }
LABEL_167:
      v74 = *(_QWORD *)(v7 + 56);
      v75 = *(_BYTE **)(v74 + 32);
      v76 = &v75[len];
      if ((unint64_t)v76 <= *(_QWORD *)(v74 + 40))
      {
        if (*v75 == 10)
        {
          ++*(_DWORD *)(v74 + 52);
          *(_DWORD *)(v74 + 56) = 1;
        }
        else
        {
          ++*(_DWORD *)(v74 + 56);
        }
        *(_QWORD *)(v74 + 32) = v76;
      }
      goto LABEL_172;
    }
    if (v64 != 38)
      goto LABEL_147;
    if (v68[1] == 35)
    {
      v69 = xmlParseCharRef((xmlParserCtxtPtr)v7);
      LODWORD(v66) = v69;
      if (!v69)
        goto LABEL_172;
      if (v69 == 38)
      {
        if (!*(_DWORD *)(v7 + 28))
        {
          if (v65 + 10 > v67)
          {
            if (2 * v67 + 10 < v67)
              goto LABEL_258;
            v95 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
            v67 = 2 * v67 + 10;
            if (!v95)
              goto LABEL_258;
          }
          else
          {
            v95 = i;
          }
          goto LABEL_220;
        }
        if (v65 + 10 > v67)
        {
          if (2 * v67 + 10 < v67)
            goto LABEL_258;
          v95 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
          v67 = 2 * v67 + 10;
          if (!v95)
            goto LABEL_258;
        }
        else
        {
          v95 = i;
        }
        LODWORD(v66) = 0;
        LOBYTE(v85) = 38;
LABEL_218:
        v95[v65++] = v85;
LABEL_221:
        i = v95;
        goto LABEL_172;
      }
      if (v65 + 10 <= v67)
      {
        v77 = i;
      }
      else
      {
        if (2 * v67 + 10 < v67)
        {
          v66 = 0;
          v72 = i;
          goto LABEL_246;
        }
        v77 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
        v67 = 2 * v67 + 10;
        if (!v77)
          goto LABEL_258;
      }
      v84 = xmlCopyChar(0, &v77[v65], (int)v66);
      LODWORD(v66) = 0;
      v65 += v84;
      i = v77;
      goto LABEL_172;
    }
    v70 = xmlParseEntityRef((xmlParserCtxtPtr)v7);
    v66 = (unsigned __int8 **)v70;
    v71 = *(_QWORD *)(v7 + 696) + 1;
    *(_QWORD *)(v7 + 696) = v71;
    if (!v70)
      goto LABEL_172;
    *(_QWORD *)(v7 + 696) = v71 + v70->owner;
    if (v70->etype == XML_INTERNAL_PREDEFINED_ENTITY)
    {
      if (v65 + 10 <= v67)
      {
        v95 = i;
      }
      else
      {
        if (2 * v67 + 10 < v67)
          goto LABEL_258;
        v95 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
        v67 = 2 * v67 + 10;
        if (!v95)
          goto LABEL_258;
      }
      v85 = *v66[10];
      if (*(_DWORD *)(v7 + 28) || v85 != 38)
      {
        LODWORD(v66) = 0;
        goto LABEL_218;
      }
LABEL_220:
      LODWORD(v66) = 0;
      v96 = &v95[v65];
      *(_DWORD *)v96 = 942875430;
      v65 += 5;
      v96[4] = 59;
      goto LABEL_221;
    }
    if (!*(_DWORD *)(v7 + 28))
    {
      v108 = v61;
      v86 = xmlStrlen(v70->name);
      v87 = v66[2];
      v107 = v86;
      if (*((_DWORD *)v66 + 23) != 6)
      {
        v88 = v66[10];
        if (v88)
        {
          if (!*((_DWORD *)v66 + 33))
          {
            v89 = *(_QWORD *)(v7 + 696);
            ++*(_DWORD *)(v7 + 392);
            v90 = xmlStrlen(v88);
            v91 = xmlStringLenDecodeEntities((xmlParserCtxtPtr)v7, v88, v90, 1, 0, 0, 0);
            --*(_DWORD *)(v7 + 392);
            v92 = *(_QWORD *)(v7 + 696) - v89;
            if ((unint64_t)(v92 + 1) < 0x3FFFFFFF)
              v93 = v92 + 1;
            else
              v93 = 0x3FFFFFFF;
            *((_DWORD *)v66 + 33) = 2 * v93;
            if (v91)
            {
              v94 = v91;
              if (xmlStrchr(v91, 0x3Cu))
                *((_DWORD *)v66 + 33) |= 1u;
              ((void (*)(xmlChar *))xmlFree)(v94);
            }
            else
            {
              *v66[10] = 0;
            }
            v86 = v107;
          }
        }
      }
      v97 = v65 + 1;
      i[v65] = 38;
      v109 = v86 + 10;
      v111 = v65 + v86 + 11;
      while (1)
      {
        v72 = i;
        if (v111 <= v67)
          break;
        if (v109 + 2 * v67 < v67)
        {
          v66 = 0;
          goto LABEL_246;
        }
        i = (xmlChar *)xmlRealloc(i, v109 + 2 * v67);
        v66 = 0;
        v67 = v109 + 2 * v67;
        if (!i)
          goto LABEL_246;
      }
      if (v107 < 1)
      {
        v100 = v65 + 1;
      }
      else
      {
        v98 = v107 + 1;
        do
        {
          v99 = *v87++;
          v100 = v97 + 1;
          i[v97] = v99;
          --v98;
          ++v97;
        }
        while (v98 > 1);
      }
      LODWORD(v66) = 0;
      v65 = v100 + 1;
      i[v100] = 59;
LABEL_235:
      v61 = v108;
      goto LABEL_172;
    }
    ++*(_DWORD *)(v7 + 392);
    v78 = xmlStringDecodeEntities((xmlParserCtxtPtr)v7, v70->content, 1, 0, 0, 0);
    v66 = (unsigned __int8 **)v78;
    --*(_DWORD *)(v7 + 392);
    if (v78)
      break;
LABEL_172:
    if (!*(_DWORD *)(v7 + 452)
      && (uint64_t)(*(_QWORD *)(*(_QWORD *)(v7 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(v7 + 56) + 32)) <= 249)
    {
      xmlGROW(v7);
    }
    v64 = xmlCurrentChar((xmlParserCtxtPtr)v7, &len);
    if (v65 > v61)
    {
      xmlFatalErrMsg((_DWORD *)v7, 40, (char)"AttValue length too long\n");
LABEL_258:
      v66 = 0;
      v72 = i;
      goto LABEL_246;
    }
  }
  v108 = v61;
  v79 = v78;
  do
  {
    v72 = i;
    v80 = v65;
    do
    {
      v81 = *v79;
      if ((v81 - 9) < 2 || v81 == 13)
      {
        LOBYTE(v81) = 32;
      }
      else if (!*v79)
      {
        ((void (*)(unsigned __int8 **))xmlFree)(v66);
        LODWORD(v66) = 0;
        v65 = v80;
        goto LABEL_235;
      }
      i[v80] = v81;
      ++v79;
      v65 = v80 + 1;
      v83 = v80 + 11;
      ++v80;
    }
    while (v83 <= v67);
    if (2 * v67 + 10 < v67)
      break;
    i = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
    v67 = 2 * v67 + 10;
  }
  while (i);
LABEL_246:
  htmlErrMemory((_DWORD *)v7, 0);
  i = v72;
  if (v72)
LABEL_247:
    ((void (*)(xmlChar *))xmlFree)(i);
  if (v66)
    ((void (*)(unsigned __int8 **))xmlFree)(v66);
  return 0;
}

void xmlGROW(uint64_t a1)
{
  xmlParserInput *v2;
  const xmlChar *cur;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  xmlParserInput *v7;
  const xmlChar *v8;

  v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  v4 = v2->end - cur;
  v5 = cur - v2->base;
  v6 = v4 <= 10000000 && v5 <= 10000000;
  if (v6
    || !v2->buf
    || (uint64_t (*)())v2->buf->readcallback == xmlInputReadCallbackNop
    || (*(_BYTE *)(a1 + 566) & 8) != 0)
  {
    xmlParserInputGrow(v2, 250);
    v7 = *(xmlParserInput **)(a1 + 56);
    v8 = v7->cur;
    if (v8 <= v7->end && v8 >= v7->base)
    {
      if (v8)
      {
        if (!*v8)
          xmlParserInputGrow(v7, 250);
      }
    }
    else
    {
      xmlHaltParser((xmlParserCtxtPtr)a1);
      xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"cur index out of bound");
    }
  }
  else
  {
    xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"Huge input lookup");
    xmlHaltParser((xmlParserCtxtPtr)a1);
  }
}

int xmlParserInputGrow(xmlParserInputPtr in, int len)
{
  int result;
  const xmlChar *base;
  const xmlChar *cur;
  xmlBuf *buffer;
  int64_t v8;
  int v9;
  xmlChar *v10;

  result = -1;
  if (in)
  {
    if ((len & 0x80000000) == 0)
    {
      if (in->buf)
      {
        base = in->base;
        if (base)
        {
          cur = in->cur;
          if (cur)
          {
            buffer = in->buf->buffer;
            if (buffer)
            {
              v8 = cur - base;
              if (xmlBufUse(buffer) <= ((_DWORD)cur - (_DWORD)base + 250) && in->buf->readcallback)
              {
                v9 = xmlParserInputBufferGrow(in->buf, len);
                v10 = xmlBufContent(in->buf->buffer);
                in->base = v10;
                in->cur = &v10[v8];
                in->end = xmlBufEnd(in->buf->buffer);
                return v9;
              }
              else
              {
                return 0;
              }
            }
            else
            {
              return -1;
            }
          }
        }
      }
    }
  }
  return result;
}

size_t xmlBufUse(const xmlBufPtr buf)
{
  size_t v1;
  uint64_t v3;
  size_t v5;

  if (!buf || *((_DWORD *)buf + 14))
    return 0;
  v3 = *((unsigned int *)buf + 3);
  if (v3 <= 0x7FFFFFFE && *((_QWORD *)buf + 5) != v3)
    *((_QWORD *)buf + 5) = v3;
  v1 = *((_QWORD *)buf + 4);
  v5 = *((unsigned int *)buf + 2);
  if (v5 <= 0x7FFFFFFE && v1 != v5)
  {
    *((_QWORD *)buf + 4) = v5;
    return v5;
  }
  return v1;
}

xmlChar *__cdecl xmlBufContent(xmlChar *buf)
{
  if (buf)
  {
    if (*((_DWORD *)buf + 14))
      return 0;
    else
      return *(xmlChar **)buf;
  }
  return buf;
}

int xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len)
{
  uint64_t v4;
  xmlChar *v5;
  xmlInputReadCallback readcallback;
  const xmlChar *v7;
  uint64_t v8;
  size_t v9;
  xmlBuf *raw;
  unsigned int v11;
  int v12;
  const xmlChar *v13;
  int v14;
  int v15;
  const char *v16;

  if (!in || in->error)
    goto LABEL_23;
  if (len != 4 && len < 4001)
    v4 = 4000;
  else
    v4 = len;
  if ((xmlBufGrow((uint64_t)in->buffer, (int)v4 + 1) & 0x80000000) != 0)
  {
    v13 = (const xmlChar *)"growing input buffer";
    v14 = 2;
    v15 = 2;
    v16 = 0;
LABEL_22:
    __xmlSimpleError(8u, v15, 0, v16, v13);
    in->error = v14;
LABEL_23:
    LODWORD(v9) = -1;
    return v9;
  }
  v5 = xmlBufEnd(in->buffer);
  readcallback = in->readcallback;
  if (!readcallback)
  {
    v16 = "no input";
    v14 = 1547;
    v15 = 1547;
LABEL_21:
    v13 = 0;
    goto LABEL_22;
  }
  v7 = v5;
  v8 = ((uint64_t (*)(void *, xmlChar *, uint64_t))readcallback)(in->context, v5, v4);
  v9 = v8;
  if ((int)v8 < 1)
  {
    in->readcallback = (xmlInputReadCallback)endOfInput;
    if ((v8 & 0x80000000) != 0)
      goto LABEL_23;
  }
  if (!in->encoder)
  {
    xmlBufAddLen((uint64x2_t *)in->buffer, v8);
    return v9;
  }
  raw = in->raw;
  if (!raw)
  {
    raw = (xmlBuf *)xmlBufCreate();
    in->raw = raw;
  }
  if (xmlBufAdd((uint64x2_t *)raw, v7, v9))
    goto LABEL_23;
  v11 = xmlBufUse(in->raw);
  v12 = xmlCharEncInput((uint64_t)in, 1);
  if (v12 < 0)
  {
    v16 = "encoder error";
    v14 = 1544;
    v15 = 1544;
    goto LABEL_21;
  }
  LODWORD(v9) = v12;
  in->rawconsumed = in->rawconsumed - xmlBufUse(in->raw) + v11;
  return v9;
}

xmlChar *__cdecl xmlBufEnd(xmlChar *buf)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  if (buf)
  {
    if (*((_DWORD *)buf + 14))
    {
      return 0;
    }
    else
    {
      v1 = *((unsigned int *)buf + 3);
      if (v1 <= 0x7FFFFFFE && *((_QWORD *)buf + 5) != v1)
        *((_QWORD *)buf + 5) = v1;
      v3 = *((_QWORD *)buf + 4);
      v4 = *((unsigned int *)buf + 2);
      if (v4 <= 0x7FFFFFFE && v3 != v4)
      {
        *((_QWORD *)buf + 4) = v4;
        v3 = v4;
      }
      return (xmlChar *)(*(_QWORD *)buf + v3);
    }
  }
  return buf;
}

uint64_t xmlBufAddLen(uint64x2_t *a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int8x16_t v10;

  if (!a1 || a1[3].i32[2])
    return 0xFFFFFFFFLL;
  v2 = a1[2].i64[1];
  v3 = a1->u32[3];
  if (v3 <= 0x7FFFFFFE && v2 != v3)
  {
    a1[2].i64[1] = v3;
    v2 = v3;
  }
  v5 = a1[2].i64[0];
  v6 = a1->u32[2];
  if (v6 <= 0x7FFFFFFE && v5 != v6)
  {
    a1[2].i64[0] = v6;
    v5 = v6;
  }
  if (v2 - v5 <= a2)
    return 0xFFFFFFFFLL;
  v8 = 0;
  v9 = v5 + a2;
  a1[2].i64[0] = v9;
  *(_BYTE *)(a1->i64[0] + v9) = 0;
  v10 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFuLL);
  a1->u64[1] = (unint64_t)vmovn_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v10, a1[2]), (int8x16_t)a1[2], v10));
  return v8;
}

uint64_t xmlBufGrow(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (a2)
    {
      LODWORD(result) = xmlBufGrowInternal(a1, a2);
      if (*(_DWORD *)(a1 + 56))
        return 0xFFFFFFFFLL;
      else
        return result;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t xmlBufGrowInternal(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  int v10;
  unint64_t result;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;

  if (*(_DWORD *)(a1 + 56))
    return 0;
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(unsigned int *)(a1 + 12);
  if (v5 <= 0x7FFFFFFE && v4 != v5)
  {
    *(_QWORD *)(a1 + 40) = v5;
    v4 = v5;
  }
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(unsigned int *)(a1 + 8);
  if (v8 <= 0x7FFFFFFE && v7 != v8)
  {
    *(_QWORD *)(a1 + 32) = v8;
    v7 = v8;
  }
  v10 = *(_DWORD *)(a1 + 16);
  if (v10 == 2)
    return 0;
  if (v4 - v7 > a2)
  {
    *(_BYTE *)(*(_QWORD *)a1 + v7 + a2) = 0;
    return *(_QWORD *)(a1 + 40) + ~*(_QWORD *)(a1 + 32);
  }
  if (-2 - v7 < a2)
  {
    v12 = "growing buffer past SIZE_MAX";
    goto LABEL_44;
  }
  v13 = v7 + a2 + 100;
  if (v7 + a2 >= 0xFFFFFFFFFFFFFF9CLL)
    v13 = -1;
  v14 = 2 * v4;
  if (v4 < 0)
    v14 = -1;
  if (v4 > a2)
    v15 = v14;
  else
    v15 = v13;
  if (v10 != 3)
  {
    if (v10 == 5)
    {
      if ((unint64_t)v4 > 0x98967F || a2 + v7 - 9999999 < 0xFFFFFFFFFF676980)
      {
        xmlBufMemoryError(a1, (const xmlChar *)"buffer error: text too long\n");
        return 0;
      }
      if (v15 >= 0x989680)
        v15 = 10000000;
    }
LABEL_36:
    v19 = (char *)xmlRealloc(*(void **)a1, v15);
    if (v19)
      goto LABEL_37;
LABEL_43:
    v12 = "growing buffer";
LABEL_44:
    __xmlSimpleError(0x1Du, 2, 0, 0, (const xmlChar *)v12);
    result = 0;
    if (!*(_DWORD *)(a1 + 56))
    {
      result = 0;
      *(_DWORD *)(a1 + 56) = 2;
    }
    return result;
  }
  v16 = *(void **)(a1 + 24);
  if (!v16)
    goto LABEL_36;
  v17 = *(_QWORD *)a1 - (_QWORD)v16;
  v18 = (char *)xmlRealloc(v16, v17 + v15);
  if (!v18)
    goto LABEL_43;
  *(_QWORD *)(a1 + 24) = v18;
  v19 = &v18[v17];
LABEL_37:
  *(_QWORD *)a1 = v19;
  *(_QWORD *)(a1 + 40) = v15;
  v19[*(_QWORD *)(a1 + 32)] = 0;
  *(_BYTE *)(*(_QWORD *)a1 + *(_QWORD *)(a1 + 32) + a2) = 0;
  LODWORD(v20) = 0x7FFFFFFF;
  v22 = *(_QWORD *)(a1 + 32);
  v21 = *(_QWORD *)(a1 + 40);
  if (v21 >= 0x7FFFFFFF)
    LODWORD(v23) = 0x7FFFFFFF;
  else
    v23 = *(_QWORD *)(a1 + 40);
  if (v22 < 0x7FFFFFFF)
    v20 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 8) = v20;
  *(_DWORD *)(a1 + 12) = v23;
  return v21 + ~v22;
}

uint64_t endOfInput()
{
  return 0;
}

uint64_t xmlGetNamespace(uint64_t a1, uint64_t a2)
{
  int v2;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (*(_QWORD *)(a1 + 480) == a2)
  {
    v6 = a1 + 496;
    return *(_QWORD *)v6;
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 508);
    while (1)
    {
      v3 = __OFSUB__(v2, 2);
      v2 -= 2;
      if (v2 < 0 != v3)
        break;
      v4 = *(_QWORD *)(a1 + 520);
      if (*(_QWORD *)(v4 + 8 * v2) == a2)
      {
        v5 = (v2 + 1);
        if (a2 || **(_BYTE **)(v4 + 8 * v5))
        {
          v6 = v4 + 8 * v5;
          return *(_QWORD *)v6;
        }
        return 0;
      }
    }
    return 0;
  }
}

void xmlSAX2EndElementNs(void *ctx, const xmlChar *localname, const xmlChar *prefix, const xmlChar *URI)
{
  xmlDoc *v5;

  if (ctx)
  {
    *((_DWORD *)ctx + 104) = -1;
    if (*((_DWORD *)ctx + 39))
    {
      if (*((_DWORD *)ctx + 6))
      {
        v5 = (xmlDoc *)*((_QWORD *)ctx + 2);
        if (v5)
        {
          if (v5->intSubset)
            *((_DWORD *)ctx + 38) &= xmlValidateOneElement((xmlValidCtxtPtr)((char *)ctx + 160), v5, *((xmlNodePtr *)ctx + 10));
        }
      }
    }
    nodePop((xmlParserCtxtPtr)ctx);
  }
}

xmlNodePtr nodePop(xmlNodePtr ctxt)
{
  int properties;
  unsigned int v2;
  xmlNs *nsDef;
  xmlChar *v4;

  if (ctxt)
  {
    properties = (int)ctxt->properties;
    v2 = properties - 1;
    if (properties < 1)
    {
      return 0;
    }
    else
    {
      LODWORD(ctxt->properties) = v2;
      nsDef = ctxt->nsDef;
      if (properties == 1)
        v4 = 0;
      else
        v4 = (xmlChar *)*((_QWORD *)&nsDef->next + (properties - 2));
      ctxt->content = v4;
      ctxt = (xmlNodePtr)*((_QWORD *)&nsDef->next + v2);
      *((_QWORD *)&nsDef->next + v2) = 0;
    }
  }
  return ctxt;
}

uint64_t xmlParseNameAndCompare(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4;
  _BYTE *v5;
  unsigned int v6;
  unsigned __int8 *v7;
  _BYTE *v8;
  int v9;
  unsigned int v10;
  uint64_t result;

  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  if (*(_DWORD *)(a1 + 272) == -1)
    return 0;
  v4 = *(_QWORD *)(a1 + 56);
  v5 = *(_BYTE **)(v4 + 32);
  v6 = *v5;
  v7 = a2;
  v8 = v5;
  if (*v5)
  {
    v8 = *(_BYTE **)(v4 + 32);
    v7 = a2;
    while (1)
    {
      v9 = *v7;
      if (v6 != v9)
        break;
      v10 = *++v8;
      v6 = v10;
      ++v7;
      if (!v10)
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    v6 = 0;
    v9 = *v7;
  }
  if (v9 || v6 > 0x3E || ((1 << v6) & 0x4000000100002600) == 0)
  {
    result = (uint64_t)xmlParseName((xmlParserCtxtPtr)a1);
    if ((unsigned __int8 *)result == a2)
      return 1;
  }
  else
  {
    *(_DWORD *)(v4 + 56) += (_DWORD)v8 - (_DWORD)v5;
    *(_QWORD *)(v4 + 32) = v8;
    return 1;
  }
  return result;
}

int xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len)
{
  unsigned int v2;
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v7;
  int v8;
  const xmlChar *v10;
  int v11;
  unint64_t v13;
  char __str[16];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _WORD v22[11];
  uint64_t v23;

  v2 = 0;
  v23 = *MEMORY[0x1E0C80C00];
  if (!ctxt || !len)
    return v2;
  input = ctxt->input;
  if (!input || ctxt->instate == XML_PARSER_EOF)
    return 0;
  cur = input->cur;
  v7 = *(char *)cur;
  if (v7 >= 32)
  {
    *len = 1;
    return *cur;
  }
  if (ctxt->charset != 1)
  {
    *len = 1;
    goto LABEL_19;
  }
  v8 = *cur;
  if ((v7 & 0x80) != 0)
  {
    if (v8 == 192 || (v7 & 0x40) == 0)
      goto LABEL_44;
    v13 = input->end - cur;
    if (v13 <= 1)
    {
      xmlParserInputGrow(input, 250);
      input = ctxt->input;
      cur = input->cur;
      v13 = input->end - cur;
      if (v13 < 2)
        goto LABEL_44;
    }
    if ((cur[1] & 0xC0) != 0x80)
      goto LABEL_44;
    if ((~v8 & 0xE0) != 0)
    {
      *len = 2;
      v2 = cur[1] & 0x3F | ((*cur & 0x1F) << 6);
      if (v2 < 0x80)
        goto LABEL_44;
    }
    else
    {
      if (v13 <= 2)
      {
        xmlParserInputGrow(input, 250);
        input = ctxt->input;
        cur = input->cur;
        v13 = input->end - cur;
        if (v13 < 3)
          goto LABEL_44;
      }
      if ((cur[2] & 0xC0) != 0x80)
        goto LABEL_44;
      if ((~v8 & 0xF0) != 0)
      {
        *len = 3;
        v2 = ((*cur & 0xF) << 12) | ((cur[1] & 0x3F) << 6) | cur[2] & 0x3F;
        if (v2 < 0x800)
          goto LABEL_44;
      }
      else
      {
        if (v13 <= 3)
        {
          xmlParserInputGrow(input, 250);
          input = ctxt->input;
          cur = input->cur;
          v13 = input->end - cur;
        }
        if ((v8 & 0xF8) != 0xF0)
          goto LABEL_44;
        if (v13 < 4)
          goto LABEL_44;
        if ((cur[3] & 0xC0) != 0x80)
          goto LABEL_44;
        *len = 4;
        v2 = ((*cur & 7) << 18) | ((cur[1] & 0x3F) << 12) | ((cur[2] & 0x3F) << 6) | cur[3] & 0x3F;
        if (v2 < 0x10000)
          goto LABEL_44;
      }
    }
    if (v2 >> 11 < 0x1B)
      return v2;
    if ((v2 - 57344) >> 1 < 0xFFF)
      return v2;
    if (v2 - 0x10000 < 0x100000)
      return v2;
    xmlErrEncodingInt(ctxt, "Char 0x%X out of allowed range\n", v2);
    if (ctxt->instate != XML_PARSER_EOF)
      return v2;
    input = ctxt->input;
LABEL_44:
    if (input->end - input->cur <= 3)
    {
      v2 = 0;
      *len = 0;
      return v2;
    }
    v21 = 0u;
    memset(v22, 0, sizeof(v22));
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    *(_OWORD *)__str = 0u;
    snprintf(__str, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", *input->cur, *((unsigned __int8 *)input->cur + 1), *((unsigned __int8 *)input->cur + 2), *((unsigned __int8 *)input->cur + 3));
    __xmlErrEncoding(ctxt, 9, "Input is not proper UTF-8, indicate encoding !\n%s", (const xmlChar *)__str, 0);
    ctxt->charset = 10;
    *len = 1;
    cur = ctxt->input->cur;
    return *cur;
  }
  *len = 1;
  if (input->end - cur <= 0)
  {
    xmlParserInputGrow(input, 250);
    input = ctxt->input;
    cur = input->cur;
  }
  v2 = *cur;
  if (*cur)
    goto LABEL_20;
  if (input->end <= cur)
    return 0;
  xmlErrEncodingInt(ctxt, "Char 0x0 out of allowed range\n", 0);
  input = ctxt->input;
  if (ctxt->instate == XML_PARSER_EOF)
    goto LABEL_44;
  cur = input->cur;
LABEL_19:
  v2 = *cur;
LABEL_20:
  if (v2 == 13)
  {
    v11 = cur[1];
    v10 = cur + 1;
    if (v11 == 10)
      input->cur = v10;
    return 10;
  }
  return v2;
}

uint64_t xmlInputReadCallbackNop()
{
  return 0;
}

uint64_t xmlCtxtGrowAttrs(uint64_t a1, int a2)
{
  uint64_t v2;
  void *v4;
  void *v5;
  void *v6;
  size_t v7;
  void *v8;
  void *v9;
  uint64_t v10;

  v2 = *(unsigned int *)(a1 + 472);
  if (a2 + 5 <= (int)v2)
    return v2;
  if ((_DWORD)v2)
    v2 = (2 * (a2 + 5));
  else
    v2 = 55;
  v4 = xmlMalloc(8 * (int)v2);
  if (!v4)
  {
LABEL_14:
    htmlErrMemory((_DWORD *)a1, 0);
    return 0xFFFFFFFFLL;
  }
  v5 = v4;
  v6 = *(void **)(a1 + 528);
  v7 = 4 * ((int)v2 / 5);
  if (v6)
    v8 = xmlRealloc(v6, v7);
  else
    v8 = xmlMalloc(v7);
  v9 = v8;
  if (!v8)
  {
    xmlFree(v5);
    goto LABEL_14;
  }
  v10 = *(unsigned int *)(a1 + 472);
  if ((int)v10 >= 1)
    memcpy(v5, *(const void **)(a1 + 464), 8 * v10);
  xmlFree(*(void **)(a1 + 464));
  *(_QWORD *)(a1 + 464) = v5;
  *(_QWORD *)(a1 + 528) = v9;
  *(_DWORD *)(a1 + 472) = v2;
  return v2;
}

int xmlParseCharRef(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  const xmlChar *v4;
  const xmlChar *v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  BOOL v12;
  int v13;
  const char *v14;
  int v16;
  int v17;
  int v18;
  int v19;
  xmlParserCtxtPtr v20;
  int v21;

  input = ctxt->input;
  cur = input->cur;
  if (*cur != 38 || cur[1] != 35)
  {
    xmlFatalErr(ctxt, 8, 0);
    v7 = 0;
    goto LABEL_40;
  }
  v4 = cur + 2;
  if (cur[2] == 120)
  {
    input->cur = cur + 3;
    input->col += 3;
    if (!cur[3])
    {
      xmlParserInputGrow(input, 250);
      input = ctxt->input;
    }
    if (!ctxt->progressive && input->end - input->cur <= 249)
    {
      xmlGROW((uint64_t)ctxt);
      input = ctxt->input;
    }
    v5 = input->cur;
    if (*v5 != 59)
    {
      v6 = 0;
      v7 = 0;
      while (1)
      {
        if (v6 < 21)
        {
          v8 = v6 + 1;
        }
        else
        {
          if (!ctxt->progressive && input->end - v5 <= 249)
            xmlGROW((uint64_t)ctxt);
          if (ctxt->instate == XML_PARSER_EOF)
            return 0;
          v8 = 0;
          input = ctxt->input;
        }
        v9 = *input->cur;
        if (v9 - 48 >= 0xA)
        {
          if (v9 < 0x61)
          {
            if (v9 < 0x41 || (v9 <= 0x46 ? (v12 = v8 <= 19) : (v12 = 0), !v12))
            {
LABEL_76:
              v20 = ctxt;
              v21 = 6;
LABEL_77:
              xmlFatalErr(v20, v21, 0);
              v7 = 0;
              input = ctxt->input;
              v5 = input->cur;
              if (*v5 == 59)
                goto LABEL_51;
LABEL_40:
              v14 = "xmlParseCharRef: invalid xmlChar value %d\n";
LABEL_41:
              xmlFatalErrMsgInt(ctxt, 9, v14, v7);
              return 0;
            }
            v10 = -55;
          }
          else
          {
            if (v9 > 0x66 || v8 >= 20)
              goto LABEL_76;
            v10 = -87;
          }
        }
        else
        {
          v10 = -48;
        }
        v13 = v10 + 16 * v7 + v9;
        if (v13 >= 1114112)
          v7 = 1114112;
        else
          v7 = v13;
        xmlNextChar(ctxt);
        v6 = v8 + 1;
        input = ctxt->input;
        v5 = input->cur;
        if (*v5 == 59)
          goto LABEL_51;
      }
    }
LABEL_50:
    v7 = 0;
    goto LABEL_51;
  }
  input->cur = v4;
  input->col += 2;
  if (!*v4)
  {
    xmlParserInputGrow(input, 250);
    input = ctxt->input;
  }
  if (!ctxt->progressive && input->end - input->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    input = ctxt->input;
  }
  v5 = input->cur;
  if (*v5 == 59)
    goto LABEL_50;
  v16 = 0;
  v7 = 0;
  do
  {
    if (v16 < 21)
    {
      v17 = v16 + 1;
    }
    else
    {
      if (!ctxt->progressive && input->end - v5 <= 249)
        xmlGROW((uint64_t)ctxt);
      if (ctxt->instate == XML_PARSER_EOF)
        return 0;
      v17 = 0;
      input = ctxt->input;
    }
    v18 = *input->cur;
    if ((v18 - 48) > 9)
    {
      v20 = ctxt;
      v21 = 7;
      goto LABEL_77;
    }
    v19 = v18 + 10 * v7 - 48;
    if (v19 >= 1114112)
      v7 = 1114112;
    else
      v7 = v19;
    xmlNextChar(ctxt);
    v16 = v17 + 1;
    input = ctxt->input;
    v5 = input->cur;
  }
  while (*v5 != 59);
LABEL_51:
  ++input->col;
  input->cur = v5 + 1;
  if (v7 >= 1114112)
  {
    v14 = "xmlParseCharRef: character reference out of bounds\n";
    goto LABEL_41;
  }
  if (v7 > 255)
  {
    if ((v7 - 0x10000) >= 0xFFFFD800 && (v7 - 57344) >> 1 >= 0xFFF)
      goto LABEL_40;
  }
  else if (v7 <= 31 && (v7 > 0xD || ((1 << v7) & 0x2600) == 0))
  {
    goto LABEL_40;
  }
  return v7;
}

_DWORD *__xmlSimpleError(unsigned int a1, int a2, uint64_t a3, const char *a4, const xmlChar *a5)
{
  uint64_t v6[2];
  __int128 v7;
  const char *v8;
  char v9;

  if (a2 != 2)
    return __xmlRaiseError(0, 0, 0, 0, a3, a1, a2, 2, 0, 0, a5, 0, 0, 0, (unsigned __int128)0 >> 96, a4, (char)a5);
  if (a5)
  {
    v8 = "Memory allocation failed : %s\n";
    v9 = (char)a5;
    v7 = 0uLL;
    *(_OWORD *)v6 = (unint64_t)a5;
  }
  else
  {
    v8 = "Memory allocation failed\n";
    *(_OWORD *)v6 = 0u;
    v7 = 0u;
  }
  return __xmlRaiseError(0, 0, 0, 0, a3, a1, 2, 3, 0, 0, (const xmlChar *)v6[0], (xmlChar *)v6[1], (xmlChar *)v7, SDWORD2(v7), SHIDWORD(v7), v8, v9);
}

uint64_t xmlTextReaderStartElementNs(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(uint64_t);
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  v1 = *(_QWORD *)(result + 424);
  if (v1)
  {
    v2 = *(uint64_t (**)(uint64_t))(v1 + 72);
    if (v2)
    {
      v3 = result;
      result = v2(result);
      v4 = *(_QWORD *)(v3 + 80);
      if (v4)
      {
        v5 = *(_QWORD *)(v3 + 56);
        if (v5)
        {
          v6 = *(_BYTE **)(v5 + 32);
          if (v6)
          {
            if (*v6 == 47 && v6[1] == 62)
              *(_WORD *)(v4 + 114) = 1;
          }
        }
      }
    }
    *(_DWORD *)(v1 + 24) = 1;
  }
  return result;
}

xmlURIPtr xmlParseURI(const char *str)
{
  xmlURIPtr URI;
  xmlURI *v3;

  if (!str)
    return 0;
  URI = xmlCreateURI();
  v3 = URI;
  if (URI && xmlParse3986URIReference((uint64_t)URI, (unsigned __int8 *)str))
  {
    xmlFreeURI(v3);
    return 0;
  }
  return v3;
}

uint64_t xmlParse3986URIReference(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t i;
  unsigned int v5;
  uint64_t v8;
  int v9;
  unsigned __int8 *v10;
  uint64_t v11;
  int k;
  unsigned __int8 *v13;
  void *v14;
  int v15;
  void *v16;
  unsigned int v17;
  unsigned int v18;
  void *v19;
  int v20;
  int v21;
  uint64_t v23;
  unsigned __int8 v24;
  int j;
  unsigned __int8 *v26;
  void *v27;
  int v28;
  void *v29;
  unsigned int v30;
  unsigned int v31;
  void *v32;
  unsigned __int8 *v33;
  int v34;
  xmlChar *v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;

  if (a2)
  {
    xmlCleanURI(a1);
    v36 = a2;
    if ((*a2 & 0xDFu) - 65 > 0x19)
      goto LABEL_68;
    for (i = 0; ; ++i)
    {
      v5 = a2[i + 1];
      if (v5 - 48 >= 0xA && (v5 & 0xFFFFFFDF) - 65 >= 0x1A && (v5 > 0x2E || ((1 << v5) & 0x680000000000) == 0))
        break;
    }
    if (a1)
    {
      if (*(_QWORD *)a1)
        xmlFree(*(void **)a1);
      *(_QWORD *)a1 = xmlStrndup(a2, (int)i + 1);
      v5 = a2[i + 1];
    }
    if (v5 != 58)
      goto LABEL_68;
    v10 = &a2[i + 2];
    v9 = *v10;
    v37 = v10;
    if (v9 == 47)
    {
      if (a2[i + 3] == 47)
      {
        v37 = &a2[i + 4];
        if (xmlParse3986Authority(a1, (const xmlChar **)&v37))
          goto LABEL_68;
        if (!*(_QWORD *)(a1 + 24))
          *(_DWORD *)(a1 + 40) = -1;
        if (xmlParse3986PathAbEmpty(a1, (const xmlChar **)&v37))
          goto LABEL_68;
      }
      else if (xmlParse3986PathAbsolute(a1, &v37))
      {
        goto LABEL_68;
      }
      v10 = v37;
      goto LABEL_60;
    }
    if ((v9 - 48) >= 0xA && (v9 & 0xFFFFFFDF) - 65 >= 0x1A)
    {
      v11 = (v9 - 33);
      if (v11 > 0x3E)
        goto LABEL_52;
      if (((1 << (v9 - 33)) & 0x4000000096003FE9) != 0)
        goto LABEL_31;
      if (v11 == 4)
      {
        if ((a2[i + 3] - 48) >= 0xAu
          && ((v17 = a2[i + 3] - 65, v17 > 0x25) || ((1 << v17) & 0x3F0000003FLL) == 0)
          || (a2[i + 4] - 48) >= 0xAu
          && ((v18 = a2[i + 4] - 65, v18 > 0x25) || ((1 << v18) & 0x3F0000003FLL) == 0))
        {
LABEL_53:
          if (a1)
          {
            v19 = *(void **)(a1 + 48);
            if (v19)
              xmlFree(v19);
            *(_QWORD *)(a1 + 48) = 0;
          }
LABEL_60:
          v36 = v10;
          v20 = *v10;
          if (v20 == 63)
          {
            v36 = v10 + 1;
            if (xmlParse3986Query(a1, (const xmlChar **)&v36))
              goto LABEL_68;
            v10 = v36;
            v20 = *v36;
          }
          if (v20 == 35)
          {
            v36 = v10 + 1;
            if (xmlParse3986Fragment(a1, (const xmlChar **)&v36))
              goto LABEL_68;
            v20 = *v36;
          }
          if (!v20)
            return 0;
          xmlCleanURI(a1);
LABEL_68:
          xmlCleanURI(a1);
          v37 = a2;
          v21 = *a2;
          if (v21 == 47)
          {
            if (a2[1] == 47)
            {
              v37 = a2 + 2;
              v8 = xmlParse3986Authority(a1, (const xmlChar **)&v37);
              if ((_DWORD)v8)
              {
LABEL_119:
                xmlCleanURI(a1);
                return v8;
              }
              if (!xmlParse3986PathAbEmpty(a1, (const xmlChar **)&v37))
              {
LABEL_109:
                v33 = v37;
                v34 = *v37;
                if (v34 == 63)
                {
                  ++v37;
                  if (xmlParse3986Query(a1, (const xmlChar **)&v37))
                  {
LABEL_114:
                    v8 = 0xFFFFFFFFLL;
                    goto LABEL_119;
                  }
                  v33 = v37;
                  v34 = *v37;
                }
                if (v34 == 35)
                {
                  v37 = v33 + 1;
                  if (xmlParse3986Fragment(a1, (const xmlChar **)&v37))
                    goto LABEL_114;
                  v34 = *v37;
                }
                if (v34)
                {
                  xmlCleanURI(a1);
                  goto LABEL_118;
                }
                return 0;
              }
            }
            else if (!xmlParse3986PathAbsolute(a1, &v37))
            {
              goto LABEL_109;
            }
LABEL_118:
            v8 = 1;
            goto LABEL_119;
          }
          if ((v21 - 48) < 0xA || (v21 & 0xFFFFFFDF) - 65 < 0x1A)
          {
LABEL_80:
            v38 = a2;
            v24 = 58;
            for (j = 0; !xmlParse3986Segment(&v38, v24, j); j = 1)
            {
              v26 = v38;
              if (*v38 != 47)
              {
                if (a1)
                {
                  v27 = *(void **)(a1 + 48);
                  if (v27)
                    xmlFree(v27);
                  if (v26 == a2)
                  {
                    v29 = 0;
                  }
                  else
                  {
                    v28 = (_DWORD)v26 - (_DWORD)a2;
                    if ((*(_BYTE *)(a1 + 72) & 2) != 0)
                      v29 = xmlStrndup(a2, v28);
                    else
                      v29 = xmlURIUnescapeString((const char *)a2, v28, 0);
                  }
                  *(_QWORD *)(a1 + 48) = v29;
                }
                v37 = v26;
                goto LABEL_109;
              }
              ++v38;
              v24 = 0;
            }
            goto LABEL_118;
          }
          v23 = (v21 - 33);
          if (v23 > 0x3E)
            goto LABEL_101;
          if (((1 << (v21 - 33)) & 0x4000000096003FE9) != 0)
            goto LABEL_80;
          if (v23 == 4)
          {
            if ((a2[1] - 48) < 0xAu
              || (v30 = a2[1] - 65, v30 <= 0x25) && ((1 << v30) & 0x3F0000003FLL) != 0)
            {
              if ((a2[2] - 48) < 0xAu)
                goto LABEL_80;
              v31 = a2[2] - 65;
              if (v31 <= 0x25 && ((1 << v31) & 0x3F0000003FLL) != 0)
                goto LABEL_80;
            }
          }
          else
          {
LABEL_101:
            if (v21 == 126)
              goto LABEL_80;
          }
          if (a1)
          {
            v32 = *(void **)(a1 + 48);
            if (v32)
              xmlFree(v32);
            *(_QWORD *)(a1 + 48) = 0;
          }
          goto LABEL_109;
        }
      }
      else
      {
LABEL_52:
        if (v9 != 126)
          goto LABEL_53;
      }
    }
LABEL_31:
    v38 = &a2[i + 2];
    for (k = 0; !xmlParse3986Segment(&v38, 0, k); k = 1)
    {
      v13 = v38;
      if (*v38 != 47)
      {
        if (a1)
        {
          v14 = *(void **)(a1 + 48);
          if (v14)
            xmlFree(v14);
          if (v10 == v13)
          {
            v16 = 0;
          }
          else
          {
            v15 = (_DWORD)v13 + -2 - (_DWORD)a2 - i;
            if ((*(_BYTE *)(a1 + 72) & 2) != 0)
              v16 = xmlStrndup(&a2[i + 2], v15);
            else
              v16 = xmlURIUnescapeString((const char *)&a2[i + 2], v15, 0);
          }
          *(_QWORD *)(a1 + 48) = v16;
        }
        v10 = v13;
        goto LABEL_60;
      }
      ++v38;
    }
    goto LABEL_68;
  }
  return 0xFFFFFFFFLL;
}

void xmlFreeURI(xmlURIPtr uri)
{
  char *scheme;
  char *server;
  char *user;
  char *path;
  char *fragment;
  char *opaque;
  char *authority;
  char *query;
  char *query_raw;

  if (uri)
  {
    scheme = uri->scheme;
    if (scheme)
      xmlFree(scheme);
    server = uri->server;
    if (server)
      xmlFree(server);
    user = uri->user;
    if (user)
      xmlFree(user);
    path = uri->path;
    if (path)
      xmlFree(path);
    fragment = uri->fragment;
    if (fragment)
      xmlFree(fragment);
    opaque = uri->opaque;
    if (opaque)
      xmlFree(opaque);
    authority = uri->authority;
    if (authority)
      xmlFree(authority);
    query = uri->query;
    if (query)
      xmlFree(query);
    query_raw = uri->query_raw;
    if (query_raw)
      xmlFree(query_raw);
    xmlFree(uri);
  }
}

xmlURIPtr xmlCreateURI(void)
{
  xmlURI *v0;
  xmlURI *v1;

  v0 = (xmlURI *)xmlMalloc(0x58uLL);
  v1 = v0;
  if (v0)
  {
    v0->query_raw = 0;
    *(_OWORD *)&v0->path = 0u;
    *(_OWORD *)&v0->fragment = 0u;
    *(_OWORD *)&v0->authority = 0u;
    *(_OWORD *)&v0->user = 0u;
    *(_OWORD *)&v0->scheme = 0u;
  }
  else
  {
    xmlURIErrMemory((const xmlChar *)"creating URI structure\n");
  }
  return v1;
}

void xmlCleanURI(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  if (a1)
  {
    v2 = *(void **)a1;
    if (v2)
      xmlFree(v2);
    *(_QWORD *)a1 = 0;
    v3 = *(void **)(a1 + 24);
    if (v3)
      xmlFree(v3);
    *(_QWORD *)(a1 + 24) = 0;
    v4 = *(void **)(a1 + 32);
    if (v4)
      xmlFree(v4);
    *(_QWORD *)(a1 + 32) = 0;
    v5 = *(void **)(a1 + 48);
    if (v5)
      xmlFree(v5);
    *(_QWORD *)(a1 + 48) = 0;
    v6 = *(void **)(a1 + 64);
    if (v6)
      xmlFree(v6);
    *(_QWORD *)(a1 + 64) = 0;
    v7 = *(void **)(a1 + 8);
    if (v7)
      xmlFree(v7);
    *(_QWORD *)(a1 + 8) = 0;
    v8 = *(void **)(a1 + 16);
    if (v8)
      xmlFree(v8);
    *(_QWORD *)(a1 + 16) = 0;
    v9 = *(void **)(a1 + 56);
    if (v9)
      xmlFree(v9);
    *(_QWORD *)(a1 + 56) = 0;
    v10 = *(void **)(a1 + 80);
    if (v10)
      xmlFree(v10);
    *(_QWORD *)(a1 + 80) = 0;
  }
}

uint64_t nsPush(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;

  if ((*(_BYTE *)(a1 + 565) & 0x20) != 0)
  {
    v6 = *(_DWORD *)(a1 + 508);
    while (1)
    {
      v7 = __OFSUB__(v6, 2);
      v6 -= 2;
      if (v6 < 0 != v7)
        break;
      v8 = *(_QWORD *)(a1 + 520);
      if (*(_QWORD *)(v8 + 8 * v6) == a2)
      {
        if (*(_QWORD *)(v8 + 8 * (v6 + 1)) != a3)
          break;
        return 4294967294;
      }
    }
  }
  v9 = *(int *)(a1 + 512);
  if ((_DWORD)v9 && (v10 = *(_QWORD **)(a1 + 520)) != 0)
  {
    if (*(_DWORD *)(a1 + 508) < (int)v9)
    {
LABEL_12:
      v11 = *(int *)(a1 + 508);
      v10[v11] = a2;
      v12 = *(_QWORD *)(a1 + 520);
      result = (v11 + 2);
      *(_DWORD *)(a1 + 508) = result;
      *(_QWORD *)(v12 + 8 * ((int)v11 + 1)) = a3;
      return result;
    }
    *(_DWORD *)(a1 + 512) = 2 * v9;
    v10 = xmlRealloc(v10, 16 * v9);
    if (v10)
    {
      *(_QWORD *)(a1 + 520) = v10;
      goto LABEL_12;
    }
    htmlErrMemory((_DWORD *)a1, 0);
    *(int *)(a1 + 512) /= 2;
  }
  else
  {
    *(_QWORD *)(a1 + 508) = 0xA00000000;
    v10 = xmlMalloc(0x50uLL);
    *(_QWORD *)(a1 + 520) = v10;
    if (v10)
      goto LABEL_12;
    htmlErrMemory((_DWORD *)a1, 0);
    *(_DWORD *)(a1 + 512) = 0;
  }
  return 0xFFFFFFFFLL;
}

_DWORD *xmlFatalErr(_DWORD *result, int a2, const xmlChar *a3)
{
  _DWORD *v3;
  const char *v4;

  v3 = result;
  if (result && result[83] && result[68] == -1)
    return result;
  if ((a2 - 1) <= 0x6D)
  {
    v4 = off_1E6173C68[a2 - 1];
    if (!result)
      goto LABEL_9;
    goto LABEL_8;
  }
  v4 = "Unregistered error message";
  if (result)
LABEL_8:
    result[34] = a2;
LABEL_9:
  if (a3)
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, a3, 0, 0, 0, (unsigned __int128)0 >> 96, "%s: %s\n", (char)v4);
  else
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, 0, 0, 0, 0, 0, "%s\n", (char)v4);
  if (v3)
  {
    v3[6] = 0;
    if (!v3[112])
      v3[83] = 1;
  }
  return result;
}

xmlNodePtr xmlDocGetRootElement(xmlNodePtr doc)
{
  if (doc)
  {
    for (doc = doc->children; doc; doc = doc->next)
    {
      if (doc->type == XML_ELEMENT_NODE)
        break;
    }
  }
  return doc;
}

xmlDocPtr xmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  uint64_t v5;
  xmlDocPtr result;

  v5 = *(_QWORD *)&options;
  xmlInitParser();
  result = (xmlDocPtr)xmlCreateMemoryParserCtxt(buffer, size);
  if (result)
    return xmlDoRead((xmlParserCtxt *)result, (const xmlChar *)URL, (xmlChar *)encoding, v5, 0);
  return result;
}

xmlChar *__cdecl xmlNodeGetContent(const xmlNode *cur)
{
  const xmlChar *content;
  xmlBuf *Size;
  xmlChar *result;
  uint64_t *v5;
  xmlChar *v6;

  if (!cur)
    return 0;
  switch(cur->type)
  {
    case XML_ELEMENT_NODE:
    case XML_DOCUMENT_FRAG_NODE:
      Size = (xmlBuf *)xmlBufCreateSize(64);
      if (!Size)
        return 0;
      goto LABEL_10;
    case XML_ATTRIBUTE_NODE:
      return xmlGetPropNodeValueInternal((uint64_t)cur);
    case XML_TEXT_NODE:
    case XML_CDATA_SECTION_NODE:
    case XML_PI_NODE:
    case XML_COMMENT_NODE:
      content = cur->content;
      if (!content)
        return 0;
      return xmlStrdup(content);
    case XML_ENTITY_REF_NODE:
      if (!xmlGetDocEntity(cur->doc, cur->name))
        return 0;
      goto LABEL_9;
    case XML_DOCUMENT_NODE:
    case XML_HTML_DOCUMENT_NODE:
    case XML_DOCB_DOCUMENT_NODE:
LABEL_9:
      Size = (xmlBuf *)xmlBufCreate();
      if (!Size)
        return 0;
LABEL_10:
      v5 = (uint64_t *)Size;
      xmlBufGetNodeContent(Size, cur);
      v6 = (xmlChar *)xmlBufDetach(v5);
      xmlBufFree(v5);
      result = v6;
      break;
    case XML_NAMESPACE_DECL:
      content = cur->name;
      return xmlStrdup(content);
    default:
      return 0;
  }
  return result;
}

uint64_t xmlBufDetach(uint64_t *a1)
{
  uint64_t v1;

  if (!a1 || *((_DWORD *)a1 + 4) == 2 || a1[6] || *((_DWORD *)a1 + 14))
    return 0;
  v1 = *a1;
  *a1 = 0;
  a1[1] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return v1;
}

xmlParserCtxtPtr xmlCreateMemoryParserCtxt(const char *buffer, int size)
{
  xmlParserCtxt *v2;
  xmlParserInputBufferPtr Mem;
  xmlParserInputBufferPtr v6;
  xmlParserInputPtr v7;
  xmlParserInput *v8;

  v2 = 0;
  if (buffer)
  {
    if (size >= 1)
    {
      v2 = xmlNewParserCtxt();
      if (v2)
      {
        Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
        if (Mem)
        {
          v6 = Mem;
          v7 = xmlNewInputStream(v2);
          if (v7)
          {
            v8 = v7;
            v7->buf = v6;
            v7->filename = 0;
            xmlBufResetInput((uint64_t *)v6->buffer, v7);
            inputPush(v2, v8);
            return v2;
          }
          xmlFreeParserInputBuffer(v6);
        }
        xmlFreeParserCtxt(v2);
        return 0;
      }
    }
  }
  return v2;
}

int inputPush(xmlParserCtxtPtr ctxt, xmlParserInputPtr value)
{
  int result;
  uint64_t inputMax;
  xmlParserInputPtr *inputTab;
  xmlParserInputPtr *v7;

  result = -1;
  if (ctxt && value)
  {
    result = ctxt->inputNr;
    inputMax = ctxt->inputMax;
    if (result < (int)inputMax)
    {
      inputTab = ctxt->inputTab;
LABEL_7:
      inputTab[result] = value;
      ctxt->input = value;
      ctxt->inputNr = result + 1;
      return result;
    }
    v7 = (xmlParserInputPtr *)xmlRealloc(ctxt->inputTab, 16 * inputMax);
    if (v7)
    {
      inputTab = v7;
      ctxt->inputTab = v7;
      ctxt->inputMax = 2 * inputMax;
      result = ctxt->inputNr;
      goto LABEL_7;
    }
    htmlErrMemory(ctxt, 0);
    return -1;
  }
  return result;
}

xmlParserInputPtr xmlNewInputStream(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr result;
  const char *v3;
  int input_id;

  result = (xmlParserInputPtr)xmlMalloc(0x68uLL);
  if (!result)
  {
    v3 = "couldn't allocate a new input stream\n";
    goto LABEL_6;
  }
  *(_QWORD *)&result->standalone = 0;
  *(_OWORD *)&result->consumed = 0u;
  *(_OWORD *)&result->encoding = 0u;
  *(_OWORD *)&result->cur = 0u;
  *(_OWORD *)&result->length = 0u;
  *(_OWORD *)&result->buf = 0u;
  *(_OWORD *)&result->directory = 0u;
  *(_QWORD *)&result->line = 0x100000001;
  result->standalone = -1;
  if (!ctxt)
    return result;
  if (result->id == 0x7FFFFFFF)
  {
    v3 = "Input ID overflow\n";
LABEL_6:
    htmlErrMemory(ctxt, (const xmlChar *)v3);
    return 0;
  }
  input_id = ctxt->input_id;
  ctxt->input_id = input_id + 1;
  result->id = input_id;
  return result;
}

uint64_t xmlBufResetInput(uint64_t *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (!a2)
    return 0xFFFFFFFFLL;
  if (!a1 || *((_DWORD *)a1 + 14))
  {
    a2[4] = &byte_1B0865C1A;
    a2[5] = &byte_1B0865C1A;
    a2[3] = &byte_1B0865C1A;
    return 0xFFFFFFFFLL;
  }
  v4 = *((unsigned int *)a1 + 3);
  if (v4 <= 0x7FFFFFFE && a1[5] != v4)
    a1[5] = v4;
  v6 = a1[4];
  v7 = *((unsigned int *)a1 + 2);
  if (v7 <= 0x7FFFFFFE && v6 != v7)
  {
    a1[4] = v7;
    v6 = v7;
  }
  v2 = 0;
  v8 = *a1;
  a2[3] = *a1;
  a2[4] = v8;
  a2[5] = v8 + v6;
  return v2;
}

xmlParserInputBufferPtr xmlParserInputBufferCreateMem(const char *mem, int size, xmlCharEncoding enc)
{
  xmlParserInputBuffer *v3;
  size_t v4;
  xmlParserInputBufferPtr v6;

  v3 = 0;
  if (mem)
  {
    v4 = *(_QWORD *)&size;
    if ((size & 0x80000000) == 0)
    {
      v6 = xmlAllocParserInputBuffer(enc);
      v3 = v6;
      if (v6)
      {
        v6->context = (void *)mem;
        v6->readcallback = (xmlInputReadCallback)xmlInputReadCallbackNop;
        v6->closecallback = 0;
        if (xmlBufAdd((uint64x2_t *)v6->buffer, (const xmlChar *)mem, v4))
        {
          xmlFree(v3);
          return 0;
        }
      }
    }
  }
  return v3;
}

xmlParserInputBufferPtr xmlAllocParserInputBuffer(xmlCharEncoding enc)
{
  xmlParserInputBuffer *v2;
  xmlParserInputBuffer *v3;
  int *v4;
  xmlBuf *Size;
  xmlCharEncodingHandlerPtr CharEncodingHandler;
  int *v7;

  v2 = (xmlParserInputBuffer *)xmlMalloc(0x40uLL);
  v3 = v2;
  if (v2)
  {
    *(_OWORD *)&v2->buffer = 0u;
    *(_OWORD *)&v2->compressed = 0u;
    *(_OWORD *)&v2->context = 0u;
    *(_OWORD *)&v2->closecallback = 0u;
    v4 = __xmlDefaultBufferSize();
    Size = (xmlBuf *)xmlBufCreateSize(2 * *v4);
    v3->buffer = Size;
    if (Size)
    {
      xmlBufSetAllocationScheme((uint64_t)Size, 0);
      CharEncodingHandler = xmlGetCharEncodingHandler(enc);
      v3->encoder = CharEncodingHandler;
      if (CharEncodingHandler)
      {
        v7 = __xmlDefaultBufferSize();
        CharEncodingHandler = (xmlCharEncodingHandlerPtr)xmlBufCreateSize(2 * *v7);
      }
      v3->raw = (xmlBufPtr)CharEncodingHandler;
      v3->readcallback = 0;
      v3->closecallback = 0;
      v3->context = 0;
      v3->compressed = -1;
      v3->rawconsumed = 0;
    }
    else
    {
      xmlFree(v3);
      return 0;
    }
  }
  else
  {
    __xmlSimpleError(8u, 2, 0, 0, (const xmlChar *)"creating input buffer");
  }
  return v3;
}

_QWORD *xmlBufCreateSize(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  xmlBufferAllocationScheme v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  if (a1 == -1)
    return 0;
  v2 = xmlMalloc(0x40uLL);
  v3 = v2;
  if (v2)
  {
    v2[4] = 0;
    *((_DWORD *)v2 + 14) = 0;
    v2[6] = 0;
    v4 = *__xmlBufferAllocScheme();
    if (a1)
      v5 = a1 + 1;
    else
      v5 = 0;
    v3[5] = v5;
    LODWORD(v6) = 0x7FFFFFFF;
    if (v5 >= 0x7FFFFFFF)
      LODWORD(v5) = 0x7FFFFFFF;
    if (v3[4] < 0x7FFFFFFFuLL)
      v6 = v3[4];
    *((_DWORD *)v3 + 3) = v5;
    *((_DWORD *)v3 + 4) = v4;
    *((_DWORD *)v3 + 2) = v6;
    if (!a1)
    {
      *v3 = 0;
      goto LABEL_15;
    }
    v7 = xmlMallocAtomic(a1 + 1);
    *v3 = v7;
    if (v7)
    {
      bzero(v7, v3[5]);
LABEL_15:
      v3[3] = 0;
      return v3;
    }
    __xmlSimpleError(0x1Du, 2, 0, 0, (const xmlChar *)"creating buffer");
    if (!*((_DWORD *)v3 + 14))
      *((_DWORD *)v3 + 14) = 2;
    xmlFree(v3);
    return 0;
  }
  __xmlSimpleError(0x1Du, 2, 0, 0, (const xmlChar *)"creating buffer");
  return v3;
}

uint64_t xmlBufSetAllocationScheme(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  uint64_t v3;

  if (!a1 || *(_DWORD *)(a1 + 56) || (*(_DWORD *)(a1 + 16) & 0xFFFFFFFE) == 2 || a2 > 5)
    return 0xFFFFFFFFLL;
  if (a2 == 3)
  {
    *(_DWORD *)(a1 + 16) = 3;
    *(_QWORD *)(a1 + 24) = *(_QWORD *)a1;
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 16) = a2;
  v3 = *(_QWORD *)(a1 + 48);
  result = 0;
  if (v3)
    *(_DWORD *)(v3 + 16) = a2;
  return result;
}

xmlCharEncodingHandlerPtr xmlGetCharEncodingHandler(xmlCharEncoding enc)
{
  xmlCharEncodingHandlerPtr result;
  const char *v3;

  if (!handlers)
    xmlInitCharEncodingHandlers();
  result = 0;
  switch(enc)
  {
    case XML_CHAR_ENCODING_ERROR:
    case XML_CHAR_ENCODING_NONE:
    case XML_CHAR_ENCODING_UTF8:
      return result;
    case XML_CHAR_ENCODING_UTF16LE:
      return (xmlCharEncodingHandlerPtr)xmlUTF16LEHandler;
    case XML_CHAR_ENCODING_UTF16BE:
      return (xmlCharEncodingHandlerPtr)xmlUTF16BEHandler;
    case XML_CHAR_ENCODING_UCS4LE:
    case XML_CHAR_ENCODING_UCS4BE:
      result = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
      if (!result)
      {
        result = xmlFindCharEncodingHandler("UCS-4");
        if (!result)
        {
          v3 = "UCS4";
          goto LABEL_30;
        }
      }
      return result;
    case XML_CHAR_ENCODING_EBCDIC:
      result = xmlFindCharEncodingHandler("EBCDIC");
      if (!result)
      {
        result = xmlFindCharEncodingHandler("ebcdic");
        if (!result)
        {
          result = xmlFindCharEncodingHandler("EBCDIC-US");
          if (!result)
          {
            v3 = "IBM-037";
            goto LABEL_30;
          }
        }
      }
      return result;
    case XML_CHAR_ENCODING_UCS2:
      result = xmlFindCharEncodingHandler("ISO-10646-UCS-2");
      if (!result)
      {
        result = xmlFindCharEncodingHandler("UCS-2");
        if (!result)
        {
          v3 = "UCS2";
          goto LABEL_30;
        }
      }
      return result;
    case XML_CHAR_ENCODING_8859_1:
      v3 = "ISO-8859-1";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_2:
      v3 = "ISO-8859-2";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_3:
      v3 = "ISO-8859-3";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_4:
      v3 = "ISO-8859-4";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_5:
      v3 = "ISO-8859-5";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_6:
      v3 = "ISO-8859-6";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_7:
      v3 = "ISO-8859-7";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_8:
      v3 = "ISO-8859-8";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_9:
      v3 = "ISO-8859-9";
      goto LABEL_30;
    case XML_CHAR_ENCODING_2022_JP:
      v3 = "ISO-2022-JP";
      goto LABEL_30;
    case XML_CHAR_ENCODING_SHIFT_JIS:
      result = xmlFindCharEncodingHandler("SHIFT-JIS");
      if (result)
        return result;
      result = xmlFindCharEncodingHandler("SHIFT_JIS");
      if (result)
        return result;
      v3 = "Shift_JIS";
LABEL_30:
      result = xmlFindCharEncodingHandler(v3);
      if (!result)
        return 0;
      return result;
    case XML_CHAR_ENCODING_EUC_JP:
      v3 = "EUC-JP";
      goto LABEL_30;
    default:
      return 0;
  }
}

int *__xmlDefaultBufferSize(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlDefaultBufferSize;
  else
    return &xmlGetGlobalState()->xmlDefaultBufferSize;
}

int xmlInitParserCtxt(xmlParserCtxtPtr ctxt)
{
  xmlDict *dict;
  xmlParserInputPtr *v3;
  xmlParserInput *v4;
  xmlParserInputPtr *p_input;
  xmlNodePtr *v6;
  xmlNodePtr *p_node;
  const xmlChar **v8;
  int *spaceTab;
  int *ExtDtdDefaultValue;
  int v11;
  int *v12;
  int v13;
  int *v14;
  int v15;
  void (*v16)(void *, const char *, ...);
  int *v17;
  int v18;
  int result;

  if (!ctxt)
  {
    __xmlRaiseError(0, 0, 0, 0, 0, 1u, 1, 3, 0, 0, 0, 0, 0, 0, 0, "Got NULL parser context\n", 0);
    return -1;
  }
  xmlDefaultSAXHandlerInit();
  dict = ctxt->dict;
  if (!dict && (dict = xmlDictCreate(), (ctxt->dict = dict) == 0)
    || (xmlDictSetLimit(dict, 0x989680uLL), (dict = (xmlDict *)ctxt->sax) == 0)
    && (dict = (xmlDict *)xmlMalloc(0x100uLL), (ctxt->sax = (_xmlSAXHandler *)dict) == 0))
  {
    htmlErrMemory(dict, (const xmlChar *)"cannot initialize parser context\n");
    return -1;
  }
  xmlSAXVersion((xmlSAXHandler *)dict, 2);
  ctxt->maxatts = 0;
  ctxt->atts = 0;
  if (!ctxt->inputTab)
  {
    v3 = (xmlParserInputPtr *)xmlMalloc(0x28uLL);
    ctxt->inputTab = v3;
    ctxt->inputMax = 5;
    if (!v3)
    {
      htmlErrMemory(0, (const xmlChar *)"cannot initialize parser context\n");
      ctxt->input = 0;
      *(_QWORD *)&ctxt->inputNr = 0;
      return -1;
    }
  }
  while (1)
  {
    v4 = inputPop(ctxt);
    if (!v4)
      break;
    xmlFreeInputStream(v4);
  }
  ctxt->input = 0;
  p_input = &ctxt->input;
  ctxt->inputNr = 0;
  ctxt->version = 0;
  ctxt->encoding = 0;
  *(_QWORD *)&ctxt->hasPErefs = 0;
  ctxt->hasExternalSubset = 0;
  *(_QWORD *)&ctxt->standalone = 0xFFFFFFFFLL;
  *(_QWORD *)&ctxt->instate = 0;
  ctxt->directory = 0;
  if (ctxt->nodeTab || (v6 = (xmlNodePtr *)xmlMalloc(0x50uLL), ctxt->nodeTab = v6, ctxt->nodeMax = 10, v6))
  {
    ctxt->node = 0;
    p_node = &ctxt->node;
    ctxt->nodeNr = 0;
    if (ctxt->nameTab || (v8 = (const xmlChar **)xmlMalloc(0x50uLL), ctxt->nameTab = v8, ctxt->nameMax = 10, v8))
    {
      ctxt->nameNr = 0;
      ctxt->name = 0;
      spaceTab = ctxt->spaceTab;
      if (spaceTab || (spaceTab = (int *)xmlMalloc(0x28uLL), ctxt->spaceTab = spaceTab, ctxt->spaceMax = 10, spaceTab))
      {
        *(_QWORD *)&ctxt->spaceNr = 0xA00000001;
        *spaceTab = -1;
        ctxt->space = spaceTab;
        ctxt->userData = ctxt;
        ctxt->myDoc = 0;
        ctxt->wellFormed = 1;
        ctxt->nsWellFormed = 1;
        ctxt->valid = 1;
        ExtDtdDefaultValue = __xmlLoadExtDtdDefaultValue();
        v11 = *ExtDtdDefaultValue;
        ctxt->loadsubset = *ExtDtdDefaultValue;
        if (v11)
          ctxt->options |= 4u;
        ctxt->validate = *__xmlDoValidityCheckingDefaultValue();
        v12 = __xmlPedanticParserDefaultValue();
        v13 = *v12;
        ctxt->pedantic = *v12;
        if (v13)
          ctxt->options |= 0x80u;
        ctxt->linenumbers = *__xmlLineNumbersDefaultValue();
        v14 = __xmlKeepBlanksDefaultValue();
        v15 = *v14;
        ctxt->keepBlanks = *v14;
        if (!v15)
        {
          ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
          ctxt->options |= 0x100u;
        }
        ctxt->vctxt.finishDtd = -1412623820;
        ctxt->vctxt.userData = ctxt;
        ctxt->vctxt.error = xmlParserValidityError;
        ctxt->vctxt.warning = xmlParserValidityWarning;
        if (ctxt->validate)
        {
          if (*__xmlGetWarningsDefaultValue())
            v16 = xmlParserValidityWarning;
          else
            v16 = 0;
          ctxt->vctxt.warning = v16;
          ctxt->vctxt.nodeMax = 0;
          ctxt->options |= 0x10u;
        }
        v17 = __xmlSubstituteEntitiesDefaultValue();
        v18 = *v17;
        ctxt->replaceEntities = *v17;
        if (v18)
          ctxt->options |= 2u;
        result = 0;
        ctxt->record_info = 0;
        ctxt->checkIndex = 0;
        ctxt->inSubset = 0;
        ctxt->errNo = 0;
        ctxt->depth = 0;
        *(_OWORD *)&ctxt->nbentities = 0u;
        ctxt->charset = 1;
        ctxt->catalogs = 0;
        ctxt->sizeentcopy = 0;
        ctxt->input_id = 1;
        ctxt->node_seq.length = 0;
        ctxt->node_seq.buffer = 0;
        ctxt->node_seq.maximum = 0;
      }
      else
      {
        htmlErrMemory(0, (const xmlChar *)"cannot initialize parser context\n");
        *p_input = 0;
        *(_QWORD *)&ctxt->inputNr = 0;
        *p_node = 0;
        *(_QWORD *)&ctxt->nodeNr = 0;
        ctxt->name = 0;
        *(_QWORD *)&ctxt->nameNr = 0;
        result = -1;
        ctxt->space = 0;
        *(_QWORD *)&ctxt->spaceNr = 0;
      }
    }
    else
    {
      htmlErrMemory(0, (const xmlChar *)"cannot initialize parser context\n");
      *p_input = 0;
      *(_QWORD *)&ctxt->inputNr = 0;
      *p_node = 0;
      *(_QWORD *)&ctxt->nodeNr = 0;
      result = -1;
      ctxt->name = 0;
      *(_QWORD *)&ctxt->nameNr = 0;
    }
  }
  else
  {
    htmlErrMemory(0, (const xmlChar *)"cannot initialize parser context\n");
    *p_input = 0;
    *(_QWORD *)&ctxt->inputNr = 0;
    result = -1;
    ctxt->node = 0;
    *(_QWORD *)&ctxt->nodeNr = 0;
  }
  return result;
}

xmlNodePtr xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns, xmlChar *name, const xmlChar *content)
{
  xmlNodePtr v7;
  xmlNode *v8;
  xmlNodePtr NodeList;
  _xmlNode *next;
  xmlNodePtr v11;

  v7 = xmlNewNodeEatName(ns, name);
  v8 = v7;
  if (v7)
  {
    v7->doc = doc;
    if (content)
    {
      NodeList = xmlStringGetNodeList(doc, content);
      v8->children = NodeList;
      if (NodeList)
      {
        next = NodeList->next;
        if (next)
        {
          do
          {
            v11 = next;
            NodeList->parent = v8;
            next = next->next;
            NodeList = v11;
          }
          while (next);
        }
        else
        {
          v11 = NodeList;
        }
        v11->parent = v8;
        v8->last = v11;
      }
      else
      {
        v8->last = 0;
      }
    }
  }
  else if (doc && name && !xmlDictOwns(doc->dict, name))
  {
    xmlFree(name);
  }
  return v8;
}

xmlNodePtr xmlNewNodeEatName(xmlNsPtr ns, xmlChar *name)
{
  xmlNode *v4;
  xmlNode *v5;
  xmlRegisterNodeFunc *v6;

  if (!name)
    return 0;
  v4 = (xmlNode *)xmlMalloc(0x78uLL);
  v5 = v4;
  if (v4)
  {
    *(_OWORD *)&v4->_private = 0u;
    *(_OWORD *)&v4->name = 0u;
    *(_QWORD *)&v4->line = 0;
    *(_OWORD *)&v4->content = 0u;
    *(_OWORD *)&v4->nsDef = 0u;
    *(_OWORD *)&v4->next = 0u;
    *(_OWORD *)&v4->doc = 0u;
    *(_OWORD *)&v4->last = 0u;
    v4->type = XML_ELEMENT_NODE;
    v4->name = name;
    v4->ns = ns;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v6 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v6)(v5);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building node");
  }
  return v5;
}

void xmlSAX2StartElementNs(void *ctx, const xmlChar *localname, const xmlChar *prefix, const xmlChar *URI, int nb_namespaces, const xmlChar **namespaces, int nb_attributes, int nb_defaulted, const xmlChar **attributes)
{
  xmlNode *v16;
  uint64_t v17;
  xmlChar *v18;
  xmlNodePtr v19;
  const xmlChar *v20;
  xmlDoc *v21;
  _QWORD *v22;
  xmlRegisterNodeFunc *v23;
  xmlNodePtr v24;
  uint64_t v25;
  int v26;
  const xmlChar *v27;
  xmlNs *v28;
  xmlNs **p_nsDef;
  const xmlChar **v30;
  const xmlChar *v31;
  const xmlChar *v32;
  xmlNs *v33;
  xmlNs *v34;
  xmlNs **p_next;
  xmlDoc *v36;
  int v37;
  xmlNsPtr v38;
  xmlNsPtr ns;
  xmlChar *v40;
  const char *v41;
  _DWORD *v42;
  const xmlChar *v43;
  const xmlChar **v44;
  const xmlChar *v45;
  xmlChar *v46;
  xmlChar *v47;
  char *v48;
  xmlChar *v49;
  void *v50;
  const xmlChar *v51;
  xmlChar *v52;
  xmlChar *v53;
  int v54;
  int v55;
  xmlNodePtr parent;
  xmlNodePtr elem;

  if (!ctx)
    return;
  v16 = (xmlNode *)*((_QWORD *)ctx + 10);
  if (*((_DWORD *)ctx + 39))
  {
    v17 = *((_QWORD *)ctx + 2);
    if (!*(_QWORD *)(v17 + 88))
    {
      v22 = *(_QWORD **)(v17 + 80);
      if (!v22 || !v22[9] && !v22[10] && !v22[11] && !v22[12])
      {
        xmlErrValid(ctx, 522, "Validation failed: no DTD found !", 0, 0);
        *((_DWORD *)ctx + 39) = 0;
      }
    }
  }
  if (startElementNSNeedsUndeclaredPrefixQuirk_hasEvaluatedQuirk != -1)
    dispatch_once(&startElementNSNeedsUndeclaredPrefixQuirk_hasEvaluatedQuirk, &__block_literal_global_0);
  v18 = 0;
  if (!startElementNSNeedsUndeclaredPrefixQuirk_needsQuirk && prefix && !URI)
  {
    if (*((_DWORD *)ctx + 142))
    {
      v20 = xmlDictQLookup(*((xmlDictPtr *)ctx + 57), prefix, localname);
      v18 = 0;
      if (v20)
        localname = v20;
    }
    else
    {
      v18 = xmlBuildQName(localname, prefix, 0, 0);
    }
  }
  v19 = (xmlNodePtr)*((_QWORD *)ctx + 72);
  if (v19)
  {
    *((_QWORD *)ctx + 72) = v19->next;
    --*((_DWORD *)ctx + 143);
    *(_OWORD *)&v19->content = 0u;
    *(_OWORD *)&v19->nsDef = 0u;
    *(_QWORD *)&v19->line = 0;
    *(_OWORD *)&v19->next = 0u;
    *(_OWORD *)&v19->doc = 0u;
    *(_OWORD *)&v19->name = 0u;
    *(_OWORD *)&v19->last = 0u;
    *(_OWORD *)&v19->_private = 0u;
    v19->doc = (_xmlDoc *)*((_QWORD *)ctx + 2);
    v19->type = XML_ELEMENT_NODE;
    if (*((_DWORD *)ctx + 142))
    {
      v18 = (xmlChar *)localname;
    }
    else if (!v18)
    {
      v40 = xmlStrdup(localname);
      v19->name = v40;
      if (!v40)
        goto LABEL_74;
      goto LABEL_26;
    }
    v19->name = v18;
LABEL_26:
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v23 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNodePtr))*v23)(v19);
    }
    goto LABEL_32;
  }
  if (*((_DWORD *)ctx + 142))
  {
    v21 = (xmlDoc *)*((_QWORD *)ctx + 2);
    v18 = (xmlChar *)localname;
LABEL_30:
    v24 = xmlNewDocNodeEatName(v21, 0, v18, 0);
    goto LABEL_31;
  }
  v21 = (xmlDoc *)*((_QWORD *)ctx + 2);
  if (v18)
    goto LABEL_30;
  v24 = xmlNewDocNode(v21, 0, localname, 0);
LABEL_31:
  v19 = v24;
  if (!v24)
    goto LABEL_74;
LABEL_32:
  v55 = nb_defaulted;
  if (*((_DWORD *)ctx + 109))
  {
    v25 = *((_QWORD *)ctx + 7);
    if (v25)
    {
      v26 = *(_DWORD *)(v25 + 52);
      if (v26 >= 0xFFFF)
        LOWORD(v26) = -1;
      v19->line = v26;
    }
  }
  v27 = prefix;
  parent = v16;
  if (!v16)
    xmlAddChild(*((xmlNodePtr *)ctx + 2), v19);
  elem = v19;
  if (nb_namespaces >= 1)
  {
    v28 = 0;
    p_nsDef = &v19->nsDef;
    v30 = namespaces + 1;
    do
    {
      v31 = *(v30 - 1);
      v32 = *v30;
      v33 = xmlNewNs(0, *v30, v31);
      if (v33)
      {
        v34 = v33;
        if (v28)
          p_next = &v28->next;
        else
          p_next = p_nsDef;
        *p_next = v33;
        if (URI && v31 == v27)
          elem->ns = v33;
        if (!*((_DWORD *)ctx + 13))
        {
          if (*((_DWORD *)ctx + 39))
          {
            if (*((_DWORD *)ctx + 6))
            {
              v36 = (xmlDoc *)*((_QWORD *)ctx + 2);
              if (v36)
              {
                if (v36->intSubset)
                  *((_DWORD *)ctx + 38) &= xmlValidateOneNamespace((xmlValidCtxtPtr)((char *)ctx + 160), v36, elem, v27, v33, v32);
              }
            }
          }
        }
      }
      else
      {
        v34 = v28;
      }
      v30 += 2;
      v28 = v34;
      --nb_namespaces;
    }
    while (nb_namespaces);
  }
  *((_DWORD *)ctx + 104) = -1;
  if (nodePush((xmlParserCtxtPtr)ctx, elem) < 0)
  {
    xmlUnlinkNode(elem);
    xmlFreeNode(elem);
    return;
  }
  if (parent)
  {
    if (parent->type != XML_ELEMENT_NODE)
    {
      xmlAddSibling(parent, elem);
      if (!v55)
        goto LABEL_65;
      goto LABEL_61;
    }
    xmlAddChild(parent, elem);
  }
  if (!v55)
    goto LABEL_65;
LABEL_61:
  if ((*((_BYTE *)ctx + 432) & 4) != 0)
    v37 = 0;
  else
    v37 = v55;
  nb_attributes -= v37;
LABEL_65:
  if (!URI)
    goto LABEL_84;
  if (elem->ns)
    goto LABEL_84;
  v38 = xmlSearchNs(*((xmlDocPtr *)ctx + 2), parent, v27);
  elem->ns = v38;
  if (v38)
    goto LABEL_84;
  if (xmlStrEqual(v27, (const xmlChar *)"xml"))
  {
    ns = xmlSearchNs(*((xmlDocPtr *)ctx + 2), elem, v27);
    elem->ns = ns;
  }
  else
  {
    ns = elem->ns;
  }
  if (ns)
    goto LABEL_84;
  if (!xmlNewNs(elem, 0, v27))
  {
LABEL_74:
    xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2StartElementNs");
    return;
  }
  if (v27)
  {
    v41 = "Namespace prefix %s was not found\n";
    v42 = ctx;
    v43 = v27;
  }
  else
  {
    v41 = "Namespace default prefix was not found\n";
    v42 = ctx;
    v43 = 0;
  }
  xmlNsWarnMsg(v42, 201, v41, v43, 0);
LABEL_84:
  if (nb_attributes >= 1)
  {
    v44 = attributes + 4;
    do
    {
      v45 = *(v44 - 3);
      if (v45 && !*(v44 - 2))
      {
        if (*((_DWORD *)ctx + 142))
        {
          v51 = xmlDictQLookup(*((xmlDictPtr *)ctx + 57), v45, *(v44 - 4));
          if (v51)
          {
            v46 = (xmlChar *)v51;
            v48 = (char *)*(v44 - 1);
            v49 = (xmlChar *)*v44;
            v50 = ctx;
            v47 = 0;
            goto LABEL_89;
          }
        }
        else
        {
          v52 = xmlBuildQName(*(v44 - 4), v45, 0, 0);
          if (v52)
          {
            v53 = v52;
            xmlSAX2AttributeNs((uint64_t)ctx, v52, 0, (char *)*(v44 - 1), *v44);
            xmlFree(v53);
            goto LABEL_90;
          }
        }
      }
      v46 = (xmlChar *)*(v44 - 4);
      v47 = (xmlChar *)*(v44 - 3);
      v48 = (char *)*(v44 - 1);
      v49 = (xmlChar *)*v44;
      v50 = ctx;
LABEL_89:
      xmlSAX2AttributeNs((uint64_t)v50, v46, v47, v48, v49);
LABEL_90:
      v44 += 5;
      --nb_attributes;
    }
    while (nb_attributes);
  }
  if (*((_DWORD *)ctx + 39) && *((_DWORD *)ctx + 52) == -1412623820)
  {
    v54 = xmlValidateDtdFinal((xmlValidCtxtPtr)((char *)ctx + 160), *((xmlDocPtr *)ctx + 2));
    if (v54 <= 0)
    {
      *((_DWORD *)ctx + 38) = 0;
      if (v54 < 0)
        *((_DWORD *)ctx + 6) = 0;
    }
    *((_DWORD *)ctx + 38) &= xmlValidateRoot((xmlValidCtxtPtr)((char *)ctx + 160), *((xmlDocPtr *)ctx + 2));
    *((_DWORD *)ctx + 52) = -1412623819;
  }
}

void xmlSAX2AttributeNs(uint64_t a1, xmlChar *a2, xmlChar *nameSpace, char *a4, _BYTE *a5)
{
  xmlNs *v10;
  xmlAttrPtr v11;
  xmlChar *v12;
  uint64_t v13;
  _xmlAttr *v14;
  _xmlAttr *v15;
  xmlNode *v16;
  xmlAttrPtr v17;
  xmlRegisterNodeFunc *v18;
  char *v19;
  uint64_t v20;
  xmlChar *v21;
  xmlNodePtr NodeList;
  _xmlDoc *doc;
  xmlNodePtr v24;
  xmlChar *v25;
  xmlChar *v26;
  xmlChar *v27;
  xmlChar *v28;
  _OWORD v29[3];
  __int16 v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (nameSpace)
    v10 = xmlSearchNs(*(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), nameSpace);
  else
    v10 = 0;
  v11 = *(xmlAttrPtr *)(a1 + 592);
  if (v11)
  {
    *(_QWORD *)(a1 + 592) = v11->next;
    --*(_DWORD *)(a1 + 584);
    *(_OWORD *)&v11->_private = 0u;
    *(_OWORD *)&v11->name = 0u;
    *(_OWORD *)&v11->doc = 0u;
    *(_OWORD *)&v11->atype = 0u;
    *(_OWORD *)&v11->last = 0u;
    *(_OWORD *)&v11->next = 0u;
    v11->type = XML_ATTRIBUTE_NODE;
    v11->parent = *(_xmlNode **)(a1 + 80);
    v11->doc = *(_xmlDoc **)(a1 + 16);
    v11->ns = v10;
    v12 = a2;
    if (!*(_DWORD *)(a1 + 568))
      v12 = xmlStrdup(a2);
    v11->name = v12;
    v13 = *(_QWORD *)(a1 + 80);
    v14 = *(_xmlAttr **)(v13 + 88);
    if (v14)
    {
      do
      {
        v15 = v14;
        v14 = v14->next;
      }
      while (v14);
      v15->next = v11;
      v11->prev = v15;
    }
    else
    {
      *(_QWORD *)(v13 + 88) = v11;
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v18 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlAttrPtr))*v18)(v11);
    }
  }
  else
  {
    v16 = *(xmlNode **)(a1 + 80);
    if (*(_DWORD *)(a1 + 568))
      v17 = xmlNewNsPropEatName(v16, v10, a2, 0);
    else
      v17 = xmlNewNsProp(v16, v10, a2, 0);
    v11 = v17;
    if (!v17)
    {
      htmlErrMemory((_DWORD *)a1, (const xmlChar *)"xmlSAX2AttributeNs");
      return;
    }
  }
  if (*(_DWORD *)(a1 + 28) || *(_DWORD *)(a1 + 52))
  {
    if (!a4)
      goto LABEL_23;
    goto LABEL_21;
  }
  if (*a5)
  {
LABEL_21:
    v19 = xmlSAX2TextNode(a1, a4, (int)a5 - (int)a4);
    v11->children = (_xmlNode *)v19;
    v11->last = (_xmlNode *)v19;
    if (v19)
    {
      *((_QWORD *)v19 + 8) = v11->doc;
      *((_QWORD *)v19 + 5) = v11;
    }
    goto LABEL_23;
  }
  NodeList = xmlStringLenGetNodeList(*(const xmlDoc **)(a1 + 16), (const xmlChar *)a4, (int)a5 - (int)a4);
  v11->children = NodeList;
  if (NodeList)
  {
    doc = v11->doc;
    do
    {
      v24 = NodeList;
      NodeList->doc = doc;
      NodeList->parent = (_xmlNode *)v11;
      NodeList = NodeList->next;
    }
    while (NodeList);
    v11->last = v24;
  }
LABEL_23:
  if (!*(_DWORD *)(a1 + 52))
  {
    if (*(_DWORD *)(a1 + 156))
    {
      if (*(_DWORD *)(a1 + 24))
      {
        v20 = *(_QWORD *)(a1 + 16);
        if (v20)
        {
          if (*(_QWORD *)(v20 + 80))
          {
            if (!*(_DWORD *)(a1 + 28))
            {
              v25 = xmlSAX2DecodeAttrEntities((xmlParserCtxtPtr)a1, (const xmlChar *)a4, (unint64_t)a5);
              if (v25)
              {
                v21 = v25;
                if (*(_QWORD *)(a1 + 552))
                {
                  v30 = 0;
                  memset(v29, 0, sizeof(v29));
                  v26 = xmlBuildQName(a2, nameSpace, (xmlChar *)v29, 50);
                  if (!v26)
                    goto LABEL_67;
                  v27 = v26;
                  *(_DWORD *)(a1 + 224) = 1;
                  v28 = xmlValidCtxtNormalizeAttributeValue((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v26, v21);
                  if (*(_DWORD *)(a1 + 224) != 1)
                    *(_DWORD *)(a1 + 152) = 0;
                  if (v27 != (xmlChar *)v29 && v27 != a2)
                    xmlFree(v27);
                  if (v28)
                    xmlFree(v21);
                  else
LABEL_67:
                    v28 = v21;
                  v21 = v28;
                }
                *(_DWORD *)(a1 + 152) &= xmlValidateOneAttribute((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11, v21);
                goto LABEL_70;
              }
              if (!*a5)
              {
                *(_DWORD *)(a1 + 152) &= xmlValidateOneAttribute((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11, (const xmlChar *)a4);
                return;
              }
            }
            v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
            *(_DWORD *)(a1 + 152) &= xmlValidateOneAttribute((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11, v21);
            if (!v21)
              return;
LABEL_70:
            xmlFree(v21);
            return;
          }
        }
      }
    }
  }
  if ((*(_BYTE *)(a1 + 432) & 8) != 0)
    return;
  if (*(_DWORD *)(a1 + 28))
  {
    if (*(_DWORD *)(a1 + 336))
      return;
  }
  else if (*(_DWORD *)(a1 + 148) == 2)
  {
    return;
  }
  if (*(xmlChar **)(a1 + 480) == nameSpace && *a2 == 105 && a2[1] == 100 && !a2[2])
  {
    v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
    if (xmlValidateNCName(v21, 1))
      xmlErrValid((_DWORD *)a1, 539, "xml:id : attribute value %s is not an NCName\n", v21, 0);
  }
  else
  {
    if (!xmlIsID(*(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11))
    {
      if (xmlIsRef(*(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11))
      {
        v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
        xmlAddRef((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), v21, v11);
        if (v21)
          goto LABEL_70;
      }
      return;
    }
    v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
  }
  xmlAddID((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), v21, v11);
  if (v21)
    goto LABEL_70;
}

int xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr)
{
  const xmlChar *name;
  xmlNs *ns;
  const char *prefix;
  xmlNs *v9;
  const xmlChar *v10;
  xmlChar *v11;
  const xmlChar *v12;
  xmlChar *v13;
  xmlAttributePtr DtdAttrDesc;
  _xmlDtd *extSubset;
  _OWORD v17[3];
  __int16 v18;
  xmlChar memory[16];
  __int128 v20;
  __int128 v21;
  __int16 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!attr)
    return 0;
  name = attr->name;
  if (!name)
    return 0;
  ns = attr->ns;
  if (ns)
  {
    prefix = (const char *)ns->prefix;
    if (prefix)
    {
      if (!strcmp((const char *)attr->name, "id") && !strcmp(prefix, "xml"))
        return 1;
    }
  }
  if (!doc || !doc->intSubset && !doc->extSubset && doc->type != XML_HTML_DOCUMENT_NODE)
    return 0;
  if (doc->type != XML_HTML_DOCUMENT_NODE)
  {
    if (!elem)
      return 0;
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    *(_OWORD *)memory = 0u;
    v18 = 0;
    memset(v17, 0, sizeof(v17));
    v9 = elem->ns;
    if (!v9)
      goto LABEL_21;
    v10 = v9->prefix;
    if (v10)
    {
      v11 = xmlBuildQName(elem->name, v10, memory, 50);
      ns = attr->ns;
    }
    else
    {
LABEL_21:
      v11 = (xmlChar *)elem->name;
    }
    if (ns)
    {
      v12 = ns->prefix;
      v13 = (xmlChar *)attr->name;
      if (v12)
        v13 = xmlBuildQName(attr->name, v12, (xmlChar *)v17, 50);
    }
    else
    {
      v13 = (xmlChar *)attr->name;
    }
    DtdAttrDesc = 0;
    if (v11)
    {
      if (v13)
      {
        DtdAttrDesc = xmlGetDtdAttrDesc(doc->intSubset, v11, v13);
        if (!DtdAttrDesc)
        {
          extSubset = doc->extSubset;
          if (extSubset)
            DtdAttrDesc = xmlGetDtdAttrDesc(extSubset, v11, v13);
          else
            DtdAttrDesc = 0;
        }
      }
    }
    if (v13 != (xmlChar *)v17 && v13 != attr->name)
      xmlFree(v13);
    if (v11 != memory && v11 != elem->name)
      xmlFree(v11);
    return DtdAttrDesc && DtdAttrDesc->atype == XML_ATTRIBUTE_ID;
  }
  return xmlStrEqual((const xmlChar *)"id", name)
      || xmlStrEqual((const xmlChar *)"name", attr->name) && (!elem || xmlStrEqual(elem->name, (const xmlChar *)"a"));
}

xmlAttr *xmlNewPropInternal(uint64_t a1, xmlNs *a2, xmlChar *str, const xmlChar *a4, int a5)
{
  xmlChar *v7;
  xmlAttr *v10;
  xmlAttr *v11;
  _xmlDoc *v12;
  xmlDict *dict;
  xmlChar *v14;
  uint64_t v15;
  uint64_t v16;
  xmlNodePtr v17;
  _xmlNode *v18;
  _xmlAttr *v19;
  _xmlAttr *v20;
  xmlRegisterNodeFunc *v21;

  v7 = str;
  if (a1 && *(_DWORD *)(a1 + 8) != 1)
  {
    if (a5 == 1)
    {
      v15 = *(_QWORD *)(a1 + 64);
      if (!v15 || !xmlDictOwns(*(xmlDictPtr *)(v15 + 152), str))
        xmlFree(v7);
    }
    return 0;
  }
  v10 = (xmlAttr *)xmlMalloc(0x60uLL);
  if (!v10)
  {
    if (a5 == 1 && (!a1 || (v16 = *(_QWORD *)(a1 + 64)) == 0 || !xmlDictOwns(*(xmlDictPtr *)(v16 + 152), v7)))
      xmlFree(v7);
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building attribute");
    return 0;
  }
  v11 = v10;
  *(_OWORD *)&v10->doc = 0u;
  *(_OWORD *)&v10->atype = 0u;
  *(_OWORD *)&v10->last = 0u;
  *(_OWORD *)&v10->next = 0u;
  *(_OWORD *)&v10->_private = 0u;
  *(_OWORD *)&v10->name = 0u;
  v10->type = XML_ATTRIBUTE_NODE;
  v10->parent = (_xmlNode *)a1;
  if (!a1)
  {
    v12 = 0;
    v10->ns = a2;
    if (a5)
      goto LABEL_23;
    goto LABEL_21;
  }
  v12 = *(_xmlDoc **)(a1 + 64);
  v10->doc = v12;
  v10->ns = a2;
  if (a5)
    goto LABEL_23;
  if (!v12 || (dict = v12->dict) == 0)
  {
LABEL_21:
    v14 = xmlStrdup(v7);
    goto LABEL_22;
  }
  v14 = (xmlChar *)xmlDictLookup(dict, v7, -1);
LABEL_22:
  v7 = v14;
LABEL_23:
  v11->name = v7;
  if (!a4)
    goto LABEL_28;
  v17 = xmlNewText(a4);
  if (v17)
  {
    v17->doc = v12;
    v11->children = v17;
    do
    {
      v18 = v17;
      v17->parent = (_xmlNode *)v11;
      v17 = v17->next;
    }
    while (v17);
    v11->last = v18;
LABEL_28:
    if (!a1)
      goto LABEL_38;
    goto LABEL_29;
  }
  v11->children = 0;
  v11->last = 0;
  if (!a1)
    goto LABEL_38;
LABEL_29:
  v19 = *(_xmlAttr **)(a1 + 88);
  if (v19)
  {
    do
    {
      v20 = v19;
      v19 = v19->next;
    }
    while (v19);
    v20->next = v11;
    v11->prev = v20;
    if (!a4)
      goto LABEL_38;
LABEL_36:
    if (xmlIsID(*(xmlDocPtr *)(a1 + 64), (xmlNodePtr)a1, v11) == 1)
      xmlAddID(0, *(xmlDocPtr *)(a1 + 64), a4, v11);
    goto LABEL_38;
  }
  *(_QWORD *)(a1 + 88) = v11;
  if (a4)
    goto LABEL_36;
LABEL_38:
  if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
  {
    v21 = __xmlRegisterNodeDefaultValue();
    ((void (*)(xmlAttr *))*v21)(v11);
  }
  return v11;
}

xmlChar *__cdecl xmlStrndup(const xmlChar *cur, int len)
{
  xmlChar *v2;
  size_t v4;
  xmlChar *v5;

  v2 = 0;
  if (cur)
  {
    if ((len & 0x80000000) == 0)
    {
      v4 = len;
      v5 = (xmlChar *)xmlMallocAtomic(len + 1);
      v2 = v5;
      if (v5)
      {
        memcpy(v5, cur, v4);
        v2[v4] = 0;
      }
    }
  }
  return v2;
}

char *xmlSAX2TextNode(uint64_t a1, char *__src, int len)
{
  char *v6;
  int v7;
  unsigned int v8;
  const xmlChar *v9;
  xmlChar *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  xmlRegisterNodeFunc *v18;

  v6 = *(char **)(a1 + 576);
  if (v6)
  {
    *(_QWORD *)(a1 + 576) = *((_QWORD *)v6 + 6);
    --*(_DWORD *)(a1 + 572);
  }
  else
  {
    v6 = (char *)xmlMalloc(0x78uLL);
    if (!v6)
    {
      htmlErrMemory((_DWORD *)a1, (const xmlChar *)"xmlSAX2Characters");
      return v6;
    }
  }
  *((_QWORD *)v6 + 14) = 0;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  *((_OWORD *)v6 + 2) = 0u;
  *(_OWORD *)v6 = 0u;
  if (!*(_DWORD *)(a1 + 568))
    goto LABEL_22;
  v7 = __src[len];
  if (len > 15)
    goto LABEL_12;
  if ((*(_BYTE *)(a1 + 566) & 1) != 0)
  {
    v9 = (const xmlChar *)(v6 + 88);
    memcpy(v6 + 88, __src, len);
    v6[len + 88] = 0;
    *((_DWORD *)v6 + 2) = 3;
    *((_QWORD *)v6 + 2) = "text";
    goto LABEL_33;
  }
  if (len > 3 || v7 != 34 && v7 != 39 && (v7 != 60 || __src[len + 1] == 33))
  {
LABEL_12:
    v8 = *__src;
    if (v8 <= 0x20 && ((1 << v8) & 0x100000600) != 0)
    {
      if (len > 59)
      {
LABEL_22:
        *((_DWORD *)v6 + 2) = 3;
        *((_QWORD *)v6 + 2) = "text";
        goto LABEL_23;
      }
    }
    else if (len > 59 || v8 != 13)
    {
      goto LABEL_22;
    }
    if (v7 != 60 || __src[len + 1] == 33)
      goto LABEL_22;
    if (len >= 2)
    {
      v11 = (unsigned __int8 *)(__src + 1);
      v12 = len - 1;
      do
      {
        v13 = *v11++;
        v14 = (1 << v13) & 0x100002600;
        if (v13 > 0x20 || v14 == 0)
          goto LABEL_22;
      }
      while (--v12);
    }
  }
  v9 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), (const xmlChar *)__src, len);
  *((_DWORD *)v6 + 2) = 3;
  *((_QWORD *)v6 + 2) = "text";
  if (!v9)
  {
LABEL_23:
    v10 = xmlStrndup((const xmlChar *)__src, len);
    *((_QWORD *)v6 + 10) = v10;
    if (!v10)
    {
      xmlSAX2ErrMemory((uint64_t *)a1, "xmlSAX2TextNode");
      xmlFree(v6);
      return 0;
    }
    goto LABEL_34;
  }
LABEL_33:
  *((_QWORD *)v6 + 10) = v9;
LABEL_34:
  if (*(_DWORD *)(a1 + 436))
  {
    v16 = *(_QWORD *)(a1 + 56);
    if (v16)
    {
      v17 = *(unsigned int *)(v16 + 52);
      if ((int)v17 > 65534)
      {
        *((_WORD *)v6 + 56) = -1;
        if ((*(_BYTE *)(a1 + 566) & 0x40) != 0)
          *((_QWORD *)v6 + 13) = v17;
      }
      else
      {
        *((_WORD *)v6 + 56) = v17;
      }
    }
  }
  if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
  {
    v18 = __xmlRegisterNodeDefaultValue();
    ((void (*)(char *))*v18)(v6);
  }
  return v6;
}

void *xmlMallocZero(size_t size)
{
  void *result;

  result = malloc_type_calloc(1uLL, size, 0x298F6196uLL);
  if (!result)
    abort();
  return result;
}

int xmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr)
{
  xmlDocPtr v5;
  xmlDtd *intSubset;
  xmlAttributePtr DtdAttrDesc;

  if (!attr)
  {
    LODWORD(DtdAttrDesc) = 0;
    return (int)DtdAttrDesc;
  }
  v5 = doc;
  if (!doc)
  {
    v5 = attr->doc;
    if (!v5)
      goto LABEL_11;
  }
  intSubset = v5->intSubset;
  if (!intSubset && !v5->extSubset)
    goto LABEL_11;
  if (v5->type == XML_HTML_DOCUMENT_NODE || !elem)
    goto LABEL_11;
  DtdAttrDesc = xmlGetDtdAttrDesc(intSubset, elem->name, attr->name);
  if (DtdAttrDesc
    || (DtdAttrDesc = (xmlAttributePtr)v5->extSubset) != 0
    && (DtdAttrDesc = xmlGetDtdAttrDesc((xmlDtdPtr)DtdAttrDesc, elem->name, attr->name)) != 0)
  {
    if (DtdAttrDesc->atype - 3 <= 1)
    {
      LODWORD(DtdAttrDesc) = 1;
      return (int)DtdAttrDesc;
    }
LABEL_11:
    LODWORD(DtdAttrDesc) = 0;
  }
  return (int)DtdAttrDesc;
}

xmlAttrPtr xmlNewNsPropEatName(xmlNodePtr node, xmlNsPtr ns, xmlChar *name, const xmlChar *value)
{
  if (name)
    return xmlNewPropInternal((uint64_t)node, ns, name, value, 1);
  else
    return 0;
}

xmlNodePtr xmlAddChild(xmlNodePtr parent, xmlNodePtr cur)
{
  xmlNodePtr v3;
  xmlElementType type;
  xmlElementType v5;
  _xmlNode *last;
  _xmlNode *v7;
  _xmlDoc *doc;
  xmlDoc *v9;
  xmlElementType v10;
  xmlNs *ns;
  const xmlChar *href;
  _xmlNode *v13;
  xmlAttributePtr PropNodeInternal;
  xmlAttr *v15;
  _xmlNode *properties;
  _xmlNode *v17;

  if (parent)
  {
    v3 = parent;
    parent = 0;
    if (cur)
    {
      type = v3->type;
      if (type != XML_NAMESPACE_DECL)
      {
        parent = 0;
        if (v3 != cur)
        {
          v5 = cur->type;
          if (v5 != XML_NAMESPACE_DECL)
          {
            if (v5 == XML_TEXT_NODE)
            {
              if (type == XML_TEXT_NODE && v3->content && v3->name == cur->name)
                goto LABEL_20;
              last = v3->last;
              if (last && last->type == XML_TEXT_NODE && last != cur && last->name == cur->name)
              {
                xmlNodeAddContent(last, cur->content);
                xmlFreeNode(cur);
                return v3->last;
              }
            }
            v7 = cur->parent;
            cur->parent = v3;
            doc = cur->doc;
            v9 = v3->doc;
            if (doc != v9)
              xmlSetTreeDoc(cur, v9);
            if (v7 == v3)
              return cur;
            v10 = v3->type;
            if (v10 == XML_TEXT_NODE)
            {
              if (v3->content)
              {
LABEL_20:
                xmlNodeAddContent(v3, cur->content);
                xmlFreeNode(cur);
                return v3;
              }
              if (cur->type == XML_ATTRIBUTE_NODE)
                return 0;
            }
            else if (cur->type == XML_ATTRIBUTE_NODE)
            {
              if (v10 != XML_ELEMENT_NODE)
                return 0;
              if (!v3->properties)
                goto LABEL_43;
              ns = cur->ns;
              if (ns)
                href = ns->href;
              else
                href = 0;
              PropNodeInternal = xmlGetPropNodeInternal((uint64_t)v3, (xmlChar *)cur->name, href, 1);
              v15 = (xmlAttr *)PropNodeInternal;
              if (PropNodeInternal
                && PropNodeInternal != (xmlAttributePtr)cur
                && PropNodeInternal->type != XML_ATTRIBUTE_DECL)
              {
                xmlUnlinkNode((xmlNodePtr)PropNodeInternal);
                xmlFreeProp(v15);
              }
              if (v15 == (xmlAttr *)cur)
                return cur;
              properties = (_xmlNode *)v3->properties;
              if (properties)
              {
                do
                {
                  v17 = properties;
                  properties = properties->next;
                }
                while (properties);
                v17->next = cur;
                cur->prev = v17;
              }
              else
              {
LABEL_43:
                v3->properties = (_xmlAttr *)cur;
              }
              return cur;
            }
            if (v3->children)
            {
              v13 = v3->last;
              v13->next = cur;
              cur->prev = v13;
            }
            else
            {
              v3->children = cur;
            }
            v3->last = cur;
            return cur;
          }
        }
      }
    }
  }
  return parent;
}

int nodePush(xmlParserCtxtPtr ctxt, xmlNodePtr value)
{
  xmlParserCtxtPtr v3;
  uint64_t nodeMax;

  if (ctxt)
  {
    v3 = ctxt;
    LODWORD(ctxt) = ctxt->nodeNr;
    nodeMax = v3->nodeMax;
    if ((int)ctxt >= (int)nodeMax)
    {
      ctxt = (xmlParserCtxtPtr)xmlRealloc(v3->nodeTab, 16 * nodeMax);
      if (!ctxt)
      {
        htmlErrMemory(v3, 0);
        goto LABEL_10;
      }
      v3->nodeTab = (xmlNodePtr *)ctxt;
      LODWORD(ctxt) = v3->nodeNr;
      v3->nodeMax *= 2;
    }
    if (ctxt > xmlParserMaxDepth && (v3->options & 0x80000) == 0)
    {
      xmlFatalErrMsgInt(v3, 1, "Excessive depth in document: %d use XML_PARSE_HUGE option\n", xmlParserMaxDepth);
      xmlHaltParser(v3);
LABEL_10:
      LODWORD(ctxt) = -1;
      return (int)ctxt;
    }
    v3->nodeTab[(int)ctxt] = value;
    v3->node = value;
    v3->nodeNr = (_DWORD)ctxt + 1;
  }
  return (int)ctxt;
}

int xmlSAXVersion(xmlSAXHandler *hdlr, int version)
{
  unsigned int v2;
  int v3;

  if (hdlr)
  {
    if (version == 1)
    {
      hdlr->startElement = xmlSAX2StartElement;
      hdlr->endElement = xmlSAX2EndElement;
      v2 = 1;
      goto LABEL_7;
    }
    if (version == 2)
    {
      hdlr->startElement = 0;
      hdlr->endElement = 0;
      hdlr->startElementNs = xmlSAX2StartElementNs;
      hdlr->endElementNs = xmlSAX2EndElementNs;
      hdlr->serror = 0;
      v2 = -554844497;
LABEL_7:
      v3 = 0;
      hdlr->initialized = v2;
      hdlr->externalSubset = xmlSAX2ExternalSubset;
      hdlr->internalSubset = xmlSAX2InternalSubset;
      hdlr->isStandalone = xmlSAX2IsStandalone;
      hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
      hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
      hdlr->resolveEntity = xmlSAX2ResolveEntity;
      hdlr->getEntity = xmlSAX2GetEntity;
      hdlr->attributeDecl = xmlSAX2AttributeDecl;
      hdlr->elementDecl = xmlSAX2ElementDecl;
      hdlr->entityDecl = xmlSAX2EntityDecl;
      hdlr->notationDecl = xmlSAX2NotationDecl;
      hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
      hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
      hdlr->startDocument = xmlSAX2StartDocument;
      hdlr->endDocument = xmlSAX2EndDocument;
      hdlr->reference = xmlSAX2Reference;
      hdlr->characters = xmlSAX2Characters;
      hdlr->getParameterEntity = xmlSAX2GetParameterEntity;
      hdlr->cdataBlock = xmlSAX2CDataBlock;
      hdlr->ignorableWhitespace = xmlSAX2Characters;
      hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
      hdlr->comment = xmlSAX2Comment;
      hdlr->warning = xmlParserWarning;
      hdlr->error = xmlParserError;
      hdlr->fatalError = xmlParserError;
      return v3;
    }
  }
  return -1;
}

void xmlDefaultSAXHandlerInit(void)
{
  xmlSAXHandler *v0;

  v0 = (xmlSAXHandler *)__xmlDefaultSAXHandler();
  xmlSAXVersion(v0, 1);
}

xmlSAXHandlerV1 *__xmlDefaultSAXHandler(void)
{
  if (xmlIsMainThread())
    return (xmlSAXHandlerV1 *)xmlDefaultSAXHandler;
  else
    return &xmlGetGlobalState()->xmlDefaultSAXHandler;
}

xmlDictPtr xmlDictCreate(void)
{
  _QWORD *v0;
  _QWORD *v1;
  void *v2;

  if (!xmlDictMutex)
  {
    pthread_once(&once_control_0, _xmlInitializeDictMutex);
    if (!xmlDictMutex)
      return 0;
  }
  v0 = xmlMalloc(0x40uLL);
  v1 = v0;
  if (v0)
  {
    *(_DWORD *)v0 = 1;
    v0[7] = 0;
    v0[2] = 128;
    *((_DWORD *)v0 + 6) = 0;
    v2 = xmlMalloc(0x1000uLL);
    v1[1] = v2;
    v1[4] = 0;
    v1[5] = 0;
    if (v2)
    {
      bzero(v2, 0x1000uLL);
      *((_DWORD *)v1 + 12) = __xmlRandom();
      return (xmlDictPtr)v1;
    }
    xmlFree(v1);
    return 0;
  }
  return (xmlDictPtr)v1;
}

int *__xmlKeepBlanksDefaultValue(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlKeepBlanksDefaultValue;
  else
    return &xmlGetGlobalState()->xmlKeepBlanksDefaultValue;
}

void xmlFreeParserCtxt(xmlParserCtxtPtr ctxt)
{
  xmlParserInput *v2;
  int *spaceTab;
  const xmlChar **nameTab;
  xmlNodePtr *nodeTab;
  xmlParserNodeInfo *nodeInfoTab;
  xmlParserInputPtr *inputTab;
  xmlChar *version;
  xmlChar *encoding;
  xmlChar *extSubURI;
  xmlChar *extSubSystem;
  _xmlSAXHandler *sax;
  char *directory;
  xmlNodePtr *v14;
  const xmlChar **atts;
  xmlDict *dict;
  const xmlChar **nsTab;
  xmlStartTag *pushTab;
  int *attallocs;
  xmlHashTable *attsDefault;
  xmlHashTable *attsSpecial;
  xmlNodePtr freeElems;
  xmlNode *next;
  xmlAttrPtr freeAttrs;
  _xmlAttr *v25;
  char *message;
  char *file;
  char *str1;
  char *str2;
  char *str3;
  void *catalogs;

  if (ctxt)
  {
    while (1)
    {
      v2 = inputPop(ctxt);
      if (!v2)
        break;
      xmlFreeInputStream(v2);
    }
    spaceTab = ctxt->spaceTab;
    if (spaceTab)
      xmlFree(spaceTab);
    nameTab = ctxt->nameTab;
    if (nameTab)
      xmlFree(nameTab);
    nodeTab = ctxt->nodeTab;
    if (nodeTab)
      xmlFree(nodeTab);
    nodeInfoTab = ctxt->nodeInfoTab;
    if (nodeInfoTab)
      xmlFree(nodeInfoTab);
    inputTab = ctxt->inputTab;
    if (inputTab)
      xmlFree(inputTab);
    version = (xmlChar *)ctxt->version;
    if (version)
      xmlFree(version);
    encoding = (xmlChar *)ctxt->encoding;
    if (encoding)
      xmlFree(encoding);
    extSubURI = ctxt->extSubURI;
    if (extSubURI)
      xmlFree(extSubURI);
    extSubSystem = ctxt->extSubSystem;
    if (extSubSystem)
      xmlFree(extSubSystem);
    if (ctxt->sax)
    {
      sax = ctxt->sax;
      if (sax != (_xmlSAXHandler *)__xmlDefaultSAXHandler())
        xmlFree(ctxt->sax);
    }
    directory = ctxt->directory;
    if (directory)
      xmlFree(directory);
    v14 = ctxt->vctxt.nodeTab;
    if (v14)
      xmlFree(v14);
    atts = ctxt->atts;
    if (atts)
      xmlFree(atts);
    dict = ctxt->dict;
    if (dict)
      xmlDictFree(dict);
    nsTab = ctxt->nsTab;
    if (nsTab)
      xmlFree(nsTab);
    pushTab = ctxt->pushTab;
    if (pushTab)
      xmlFree(pushTab);
    attallocs = ctxt->attallocs;
    if (attallocs)
      xmlFree(attallocs);
    attsDefault = ctxt->attsDefault;
    if (attsDefault)
      xmlHashFree(attsDefault, xmlHashDefaultDeallocator);
    attsSpecial = ctxt->attsSpecial;
    if (attsSpecial)
      xmlHashFree(attsSpecial, 0);
    freeElems = ctxt->freeElems;
    if (freeElems)
    {
      do
      {
        next = freeElems->next;
        xmlFree(freeElems);
        freeElems = next;
      }
      while (next);
    }
    freeAttrs = ctxt->freeAttrs;
    if (freeAttrs)
    {
      do
      {
        v25 = freeAttrs->next;
        xmlFree(freeAttrs);
        freeAttrs = v25;
      }
      while (v25);
    }
    message = ctxt->lastError.message;
    if (message)
      xmlFree(message);
    file = ctxt->lastError.file;
    if (file)
      xmlFree(file);
    str1 = ctxt->lastError.str1;
    if (str1)
      xmlFree(str1);
    str2 = ctxt->lastError.str2;
    if (str2)
      xmlFree(str2);
    str3 = ctxt->lastError.str3;
    if (str3)
      xmlFree(str3);
    catalogs = ctxt->catalogs;
    if (catalogs)
      xmlCatalogFreeLocal(catalogs);
    xmlFree(ctxt);
  }
}

xmlParserInputPtr inputPop(xmlParserInputPtr ctxt)
{
  int consumed;
  unsigned int v2;
  xmlParserInputDeallocate free;
  uint64_t v4;

  if (ctxt)
  {
    consumed = ctxt->consumed;
    v2 = consumed - 1;
    if (consumed < 1)
    {
      return 0;
    }
    else
    {
      LODWORD(ctxt->consumed) = v2;
      free = ctxt->free;
      if (consumed == 1)
        v4 = 0;
      else
        v4 = *((_QWORD *)free + (consumed - 2));
      *(_QWORD *)&ctxt->col = v4;
      ctxt = (xmlParserInputPtr)*((_QWORD *)free + v2);
      *((_QWORD *)free + v2) = 0;
    }
  }
  return ctxt;
}

void xmlFreeInputStream(xmlParserInputPtr input)
{
  char *filename;
  char *directory;
  xmlChar *encoding;
  xmlChar *version;
  void (*free)(void);

  if (input)
  {
    filename = (char *)input->filename;
    if (filename)
      xmlFree(filename);
    directory = (char *)input->directory;
    if (directory)
      xmlFree(directory);
    encoding = (xmlChar *)input->encoding;
    if (encoding)
      xmlFree(encoding);
    version = (xmlChar *)input->version;
    if (version)
      xmlFree(version);
    free = (void (*)(void))input->free;
    if (free && input->base)
      free();
    if (input->buf)
      xmlFreeParserInputBuffer(input->buf);
    xmlFree(input);
  }
}

void xmlFreeParserInputBuffer(xmlParserInputBufferPtr in)
{
  xmlBufPtr raw;
  xmlCharEncodingHandler *encoder;
  xmlInputCloseCallback closecallback;
  xmlBufPtr buffer;

  if (in)
  {
    raw = in->raw;
    if (raw)
    {
      xmlBufFree(raw);
      in->raw = 0;
    }
    encoder = in->encoder;
    if (encoder)
      xmlCharEncCloseFunc(encoder);
    closecallback = in->closecallback;
    if (closecallback)
      ((void (*)(void *))closecallback)(in->context);
    buffer = in->buffer;
    if (buffer)
    {
      xmlBufFree(buffer);
      in->buffer = 0;
    }
    xmlFree(in);
  }
}

void xmlBufFree(_DWORD *a1)
{
  int v2;
  void *v3;

  if (a1)
  {
    v2 = a1[4];
    if (v2 == 3)
    {
      v3 = (void *)*((_QWORD *)a1 + 3);
      if (!v3)
      {
        v3 = *(void **)a1;
        if (!*(_QWORD *)a1)
          goto LABEL_12;
      }
    }
    else
    {
      v3 = *(void **)a1;
      if (v2 == 2 || v3 == 0)
        goto LABEL_12;
    }
    xmlFree(v3);
LABEL_12:
    xmlFree(a1);
  }
}

int *__xmlLoadExtDtdDefaultValue(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlLoadExtDtdDefaultValue;
  else
    return &xmlGetGlobalState()->xmlLoadExtDtdDefaultValue;
}

size_t xmlDictSetLimit(size_t dict, size_t limit)
{
  size_t v2;

  if (dict)
  {
    v2 = dict;
    dict = *(_QWORD *)(dict + 56);
    *(_QWORD *)(v2 + 56) = limit;
  }
  return dict;
}

int *__xmlSubstituteEntitiesDefaultValue(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlSubstituteEntitiesDefaultValue;
  else
    return &xmlGetGlobalState()->xmlSubstituteEntitiesDefaultValue;
}

int *__xmlPedanticParserDefaultValue(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlPedanticParserDefaultValue;
  else
    return &xmlGetGlobalState()->xmlPedanticParserDefaultValue;
}

int *__xmlDoValidityCheckingDefaultValue(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlDoValidityCheckingDefaultValue;
  else
    return &xmlGetGlobalState()->xmlDoValidityCheckingDefaultValue;
}

xmlParserCtxtPtr xmlNewParserCtxt(void)
{
  xmlParserCtxt *v0;
  xmlParserCtxt *v1;

  v0 = (xmlParserCtxt *)xmlMalloc(0x2F0uLL);
  v1 = v0;
  if (v0)
  {
    bzero(v0, 0x2F0uLL);
    if (xmlInitParserCtxt(v1) < 0)
    {
      xmlFreeParserCtxt(v1);
      return 0;
    }
  }
  else
  {
    htmlErrMemory(0, (const xmlChar *)"cannot allocate parser context\n");
  }
  return v1;
}

int xmlDictReference(xmlDictPtr dict)
{
  xmlRMutex *v2;
  int result;

  v2 = (xmlRMutex *)xmlDictMutex;
  if (xmlDictMutex)
  {
    if (!dict)
      return -1;
    goto LABEL_6;
  }
  pthread_once(&once_control_0, _xmlInitializeDictMutex);
  result = -1;
  if (dict)
  {
    v2 = (xmlRMutex *)xmlDictMutex;
    if (xmlDictMutex)
    {
LABEL_6:
      xmlRMutexLock(v2);
      ++*(_DWORD *)dict;
      xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
      return 0;
    }
  }
  return result;
}

void xmlDictFree(xmlDictPtr dict)
{
  xmlRMutex *v2;
  int v3;
  xmlDict *v4;
  char *v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  char *v9;
  BOOL v10;
  char v11;
  char *v12;
  _QWORD *v13;
  _QWORD *v14;

  if (dict)
  {
    v2 = (xmlRMutex *)xmlDictMutex;
    if (xmlDictMutex
      || (pthread_once(&once_control_0, _xmlInitializeDictMutex), (v2 = (xmlRMutex *)xmlDictMutex) != 0))
    {
      xmlRMutexLock(v2);
      v3 = (*(_DWORD *)dict)--;
      xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
      if (v3 <= 1)
      {
        v4 = (xmlDict *)*((_QWORD *)dict + 5);
        if (v4)
          xmlDictFree(v4);
        v5 = (char *)*((_QWORD *)dict + 1);
        if (v5)
        {
          v6 = *((_QWORD *)dict + 2);
          if (v6)
          {
            v7 = 0;
            v8 = *((_DWORD *)dict + 6);
            while (1)
            {
              v5 = (char *)*((_QWORD *)dict + 1);
              if (!v8)
                break;
              v9 = &v5[32 * v7];
              if (*((_DWORD *)v9 + 5))
                v10 = v5 == 0;
              else
                v10 = 1;
              if (!v10)
              {
                v11 = 0;
                do
                {
                  v12 = *(char **)v9;
                  if ((v11 & 1) != 0)
                  {
                    xmlFree(v9);
                    v8 = *((_DWORD *)dict + 6);
                  }
                  *((_DWORD *)dict + 6) = --v8;
                  v11 = 1;
                  v9 = v12;
                }
                while (v12);
                v6 = *((_QWORD *)dict + 2);
              }
              if (++v7 >= v6)
              {
                v5 = (char *)*((_QWORD *)dict + 1);
                break;
              }
            }
          }
          xmlFree(v5);
        }
        v13 = (_QWORD *)*((_QWORD *)dict + 4);
        if (v13)
        {
          do
          {
            v14 = (_QWORD *)*v13;
            xmlFree(v13);
            v13 = v14;
          }
          while (v14);
        }
        xmlFree(dict);
      }
    }
  }
}

void xmlRMutexUnlock(xmlRMutexPtr tok)
{
  int v2;

  if (tok)
  {
    pthread_mutex_lock((pthread_mutex_t *)tok);
    v2 = *((_DWORD *)tok + 16) - 1;
    *((_DWORD *)tok + 16) = v2;
    if (!v2)
    {
      if (*((_DWORD *)tok + 17))
        pthread_cond_signal((pthread_cond_t *)((char *)tok + 80));
      *((_QWORD *)tok + 9) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)tok);
  }
}

void xmlRMutexLock(xmlRMutexPtr tok)
{
  _opaque_pthread_t *v2;
  _opaque_pthread_t *v3;
  int v4;
  int v5;
  int v6;

  if (tok)
  {
    pthread_mutex_lock((pthread_mutex_t *)tok);
    if (*((_DWORD *)tok + 16))
    {
      v2 = (_opaque_pthread_t *)*((_QWORD *)tok + 9);
      v3 = pthread_self();
      if (pthread_equal(v2, v3))
      {
        v4 = *((_DWORD *)tok + 16) + 1;
LABEL_11:
        *((_DWORD *)tok + 16) = v4;
        pthread_mutex_unlock((pthread_mutex_t *)tok);
        return;
      }
      v6 = *((_DWORD *)tok + 16);
      v5 = *((_DWORD *)tok + 17);
      *((_DWORD *)tok + 17) = v5 + 1;
      if (v6)
      {
        do
          pthread_cond_wait((pthread_cond_t *)((char *)tok + 80), (pthread_mutex_t *)tok);
        while (*((_DWORD *)tok + 16));
        v5 = *((_DWORD *)tok + 17) - 1;
      }
      *((_DWORD *)tok + 17) = v5;
    }
    *((_QWORD *)tok + 9) = pthread_self();
    v4 = 1;
    goto LABEL_11;
  }
}

int xmlBufGetNodeContent(xmlBufPtr buf, const xmlNode *cur)
{
  int result;
  const xmlChar **p_content;
  _xmlNode *i;
  unsigned int v7;
  BOOL v8;
  int v9;
  const xmlNode *children;
  const xmlNode *v12;
  xmlElementType type;
  const xmlChar *content;
  BOOL v15;
  _xmlNode *v16;
  xmlEntityPtr DocEntity;
  const xmlNode *v18;

  result = -1;
  if (buf && cur)
  {
    result = 0;
    switch(cur->type)
    {
      case XML_ELEMENT_NODE:
      case XML_DOCUMENT_FRAG_NODE:
        children = cur;
        while (1)
        {
          do
          {
            v12 = children;
            type = children->type;
            if (type - 3 >= 2)
            {
              if (type == XML_ENTITY_REF_NODE)
                xmlBufGetNodeContent(buf, v12);
            }
            else
            {
              content = v12->content;
              if (content)
                xmlBufCat((uint64x2_t *)buf, content);
            }
            children = v12->children;
          }
          while (children && children->type != XML_ENTITY_DECL);
          if (v12 == cur)
            goto LABEL_29;
          while (1)
          {
            children = v12->next;
            if (children)
              break;
            v12 = v12->parent;
            if (v12)
              v15 = v12 == cur;
            else
              v15 = 1;
            if (v15)
              goto LABEL_29;
          }
        }
      case XML_ATTRIBUTE_NODE:
        v16 = cur->children;
        if (!v16)
          goto LABEL_29;
        do
        {
          if (v16->type == XML_TEXT_NODE)
            xmlBufCat((uint64x2_t *)buf, v16->content);
          else
            xmlBufGetNodeContent(buf, v16);
          result = 0;
          v16 = v16->next;
        }
        while (v16);
        return result;
      case XML_TEXT_NODE:
      case XML_CDATA_SECTION_NODE:
      case XML_PI_NODE:
      case XML_COMMENT_NODE:
        p_content = (const xmlChar **)&cur->content;
        goto LABEL_5;
      case XML_ENTITY_REF_NODE:
        DocEntity = xmlGetDocEntity(cur->doc, cur->name);
        if (DocEntity)
        {
          v18 = DocEntity->children;
          if (v18)
          {
            do
            {
              xmlBufGetNodeContent(buf, v18);
              result = 0;
              v18 = v18->next;
            }
            while (v18);
          }
          else
          {
LABEL_29:
            result = 0;
          }
        }
        else
        {
          result = -1;
        }
        break;
      case XML_DOCUMENT_NODE:
      case XML_HTML_DOCUMENT_NODE:
      case XML_DOCB_DOCUMENT_NODE:
        for (i = cur->children; i; i = i->next)
        {
          v7 = i->type;
          v8 = v7 > 4;
          v9 = (1 << v7) & 0x1A;
          if (!v8 && v9 != 0)
            xmlBufGetNodeContent(buf, i);
        }
        goto LABEL_29;
      case XML_NAMESPACE_DECL:
        p_content = &cur->name;
LABEL_5:
        xmlBufCat((uint64x2_t *)buf, *p_content);
        goto LABEL_29;
      default:
        return result;
    }
  }
  return result;
}

uint64_t xmlBufCat(uint64x2_t *a1, const xmlChar *a2)
{
  uint64_t v3;
  uint64_t v5;

  if (!a1 || a1[3].i32[2])
    return 0xFFFFFFFFLL;
  v3 = a1->u32[3];
  if (v3 <= 0x7FFFFFFE && a1[2].i64[1] != v3)
    a1[2].i64[1] = v3;
  v5 = a1->u32[2];
  if (v5 <= 0x7FFFFFFE && a1[2].i64[0] != v5)
    a1[2].i64[0] = v5;
  if (!a2 || a1[1].i32[0] == 2)
    return 0xFFFFFFFFLL;
  else
    return xmlBufAdd(a1, a2, 0xFFFFFFFFuLL);
}

xmlGlobalStatePtr xmlGetGlobalState(void)
{
  xmlGlobalState *v0;
  xmlGlobalState *v1;
  xmlGenericErrorFunc v2;
  void **v3;

  pthread_once(&once_control_2, (void (*)(void))xmlOnceInit);
  v0 = (xmlGlobalState *)pthread_getspecific(globalkey);
  if (!v0)
  {
    v1 = (xmlGlobalState *)malloc_type_malloc(0x3C8uLL, 0x10D00409EF9DAF4uLL);
    if (v1)
    {
      v0 = v1;
      bzero(v1, 0x3C8uLL);
      xmlInitializeGlobalState(v0);
      pthread_setspecific(globalkey, v0);
    }
    else
    {
      v2 = *__xmlGenericError();
      v3 = __xmlGenericErrorContext();
      v2(*v3, "xmlGetGlobalState: out of memory\n");
      return 0;
    }
  }
  return v0;
}

xmlNsPtr xmlSearchNs(xmlDocPtr doc, xmlNodePtr node, const xmlChar *nameSpace)
{
  xmlNs *i;
  xmlNodePtr v8;
  xmlElementType type;
  const xmlChar *prefix;
  const xmlChar *v12;
  xmlNs *v13;

  if (!node || node->type == XML_NAMESPACE_DECL)
    return 0;
  if (!nameSpace || !xmlStrEqual(nameSpace, (const xmlChar *)"xml"))
  {
    v8 = node;
    while (1)
    {
      type = v8->type;
      if (type == XML_ELEMENT_NODE)
      {
        for (i = v8->nsDef; i; i = i->next)
        {
          prefix = i->prefix;
          if ((unint64_t)nameSpace | (unint64_t)prefix)
          {
            if (nameSpace && prefix && i->href && xmlStrEqual(prefix, nameSpace))
              return i;
          }
          else if (i->href)
          {
            return i;
          }
        }
        if (v8 != node)
        {
          i = v8->ns;
          if (i)
          {
            v12 = i->prefix;
            if ((unint64_t)nameSpace | (unint64_t)v12)
            {
              if (nameSpace && v12 && i->href && xmlStrEqual(v12, nameSpace))
                return i;
            }
            else if (i->href)
            {
              return i;
            }
          }
        }
      }
      else if (type - 5 < 2 || type == XML_ENTITY_DECL)
      {
        return 0;
      }
      v8 = v8->parent;
      if (!v8)
        return 0;
    }
  }
  if (!doc)
  {
    if (node->type == XML_ELEMENT_NODE)
    {
      v13 = (xmlNs *)xmlMalloc(0x30uLL);
      i = v13;
      if (v13)
      {
        *(_OWORD *)&v13->href = 0u;
        *(_OWORD *)&v13->_private = 0u;
        *(_OWORD *)&v13->next = 0u;
        v13->type = XML_NAMESPACE_DECL;
        v13->href = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        i->prefix = xmlStrdup((const xmlChar *)"xml");
        i->next = node->nsDef;
        node->nsDef = i;
      }
      else
      {
        __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"searching namespace");
      }
      return i;
    }
    doc = node->doc;
    if (!doc)
      return 0;
  }
  i = doc->oldNs;
  if (i)
    return i;
  return (xmlNsPtr)xmlTreeEnsureXMLDecl((uint64_t)doc);
}

void xmlSetTreeDoc(xmlNodePtr tree, xmlDocPtr doc)
{
  xmlElementType type;
  _xmlDoc *v5;
  xmlDict *dict;
  _xmlDict *v7;
  _xmlAttr *properties;
  xmlDoc *v9;
  xmlDict *v10;
  _xmlNode *children;

  if (tree)
  {
    type = tree->type;
    if (type != XML_NAMESPACE_DECL)
    {
      v5 = tree->doc;
      if (v5 != doc)
      {
        if (v5)
        {
          dict = v5->dict;
          if (doc)
          {
LABEL_6:
            v7 = doc->dict;
            goto LABEL_9;
          }
        }
        else
        {
          dict = 0;
          if (doc)
            goto LABEL_6;
        }
        v7 = 0;
LABEL_9:
        if (type == XML_ELEMENT_NODE)
        {
          properties = tree->properties;
          if (!properties)
            goto LABEL_22;
          do
          {
            if (properties->atype == XML_ATTRIBUTE_ID)
              xmlRemoveID(tree->doc, properties);
            v9 = properties->doc;
            if (v9 != doc)
            {
              if (v9)
                v10 = v9->dict;
              else
                v10 = 0;
              properties->name = _copyStringForNewDictIfNeeded(v10, v7, (xmlChar *)properties->name);
              properties->doc = doc;
            }
            xmlSetListDoc(properties->children, doc);
            properties = properties->next;
          }
          while (properties);
          type = tree->type;
        }
        if (type == XML_ENTITY_REF_NODE)
        {
          tree->children = 0;
LABEL_27:
          tree->name = _copyStringForNewDictIfNeeded(dict, v7, (xmlChar *)tree->name);
          tree->content = _copyStringForNewDictIfNeeded(dict, 0, tree->content);
          tree->doc = doc;
          return;
        }
LABEL_22:
        children = tree->children;
        if (children && children->type != XML_NAMESPACE_DECL)
        {
          do
          {
            if (children->doc != doc)
              xmlSetTreeDoc(children, doc);
            children = children->next;
          }
          while (children);
        }
        goto LABEL_27;
      }
    }
  }
}

xmlChar *_copyStringForNewDictIfNeeded(xmlDict *a1, xmlDict *a2, xmlChar *str)
{
  if (!str || !a1 || xmlDictOwns(a1, str) != 1)
    return str;
  if (a2)
    return (xmlChar *)xmlDictLookup(a2, str, -1);
  return xmlStrdup(str);
}

uint64_t __xmlGlobalInitMutexUnlock()
{
  return pthread_mutex_unlock(&global_init_lock);
}

xmlNsPtr xmlNewNs(xmlNodePtr node, const xmlChar *href, const xmlChar *prefix)
{
  xmlNs *v6;
  xmlNs *v7;
  xmlNs *nsDef;
  const xmlChar *v9;
  const xmlChar *v10;
  xmlChar *v11;
  xmlChar *v12;
  const xmlChar *v13;
  const xmlChar *v14;
  xmlChar *v16;
  xmlChar *v17;

  if (node && node->type != XML_ELEMENT_NODE
    || prefix
    && xmlStrEqual(prefix, (const xmlChar *)"xml")
    && xmlStrEqual(href, (const xmlChar *)"http://www.w3.org/XML/1998/namespace"))
  {
    return 0;
  }
  v6 = (xmlNs *)xmlMalloc(0x30uLL);
  v7 = v6;
  if (!v6)
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building namespace");
    return v7;
  }
  *(_OWORD *)&v6->href = 0u;
  *(_OWORD *)&v6->_private = 0u;
  *(_OWORD *)&v6->next = 0u;
  v6->type = XML_NAMESPACE_DECL;
  if (href)
    v6->href = xmlStrdup(href);
  if (prefix)
    v7->prefix = xmlStrdup(prefix);
  if (node)
  {
    nsDef = node->nsDef;
    if (!nsDef)
    {
      node->nsDef = v7;
      return v7;
    }
    v9 = nsDef->prefix;
    v10 = v7->prefix;
    if ((unint64_t)v9 | (unint64_t)v10 && !xmlStrEqual(v9, v10))
    {
      do
      {
        if (!nsDef->next)
        {
          nsDef->next = v7;
          return v7;
        }
        v13 = nsDef->next->prefix;
        v14 = v7->prefix;
        if (!((unint64_t)v13 | (unint64_t)v14))
          break;
        nsDef = nsDef->next;
      }
      while (!xmlStrEqual(v13, v14));
      v16 = (xmlChar *)v7->href;
      if (v16)
        xmlFree(v16);
      v17 = (xmlChar *)v7->prefix;
      if (v17)
        xmlFree(v17);
    }
    else
    {
      v11 = (xmlChar *)v7->href;
      if (v11)
        xmlFree(v11);
      v12 = (xmlChar *)v7->prefix;
      if (v12)
        xmlFree(v12);
    }
    ((void (*)(xmlNs *))xmlFree)(v7);
    return 0;
  }
  return v7;
}

void xmlInitializeGlobalState(xmlGlobalStatePtr gs)
{
  xmlMutex *v2;

  v2 = (xmlMutex *)xmlThrDefMutex;
  if (!xmlThrDefMutex)
  {
    pthread_once(&once_control_1, (void (*)(void))_xmlInitGlobalsOnce);
    v2 = (xmlMutex *)xmlThrDefMutex;
  }
  xmlMutexLock(v2);
  initdocbDefaultSAXHandler(&gs->docbDefaultSAXHandler);
  inithtmlDefaultSAXHandler(&gs->htmlDefaultSAXHandler);
  gs->oldXMLWDcompatibility = 0;
  gs->xmlBufferAllocScheme = xmlBufferAllocSchemeThrDef;
  gs->xmlDefaultBufferSize = xmlDefaultBufferSizeThrDef;
  initxmlDefaultSAXHandler(&gs->xmlDefaultSAXHandler, 1);
  gs->xmlDefaultSAXLocator.getSystemId = xmlSAX2GetSystemId;
  gs->xmlDefaultSAXLocator.getLineNumber = xmlSAX2GetLineNumber;
  gs->xmlDefaultSAXLocator.getColumnNumber = xmlSAX2GetColumnNumber;
  gs->xmlDoValidityCheckingDefaultValue = xmlDoValidityCheckingDefaultValueThrDef;
  gs->xmlFree = (xmlFreeFunc)MEMORY[0x1E0C834A8];
  gs->xmlMalloc = (xmlMallocFunc)xmlMallocZero;
  gs->xmlMallocAtomic = (xmlMallocFunc)xmlMallocZero;
  gs->xmlRealloc = (xmlReallocFunc)xmlReallocChecked;
  gs->xmlMemStrdup = (xmlStrdupFunc)xmlStrdup;
  gs->xmlGetWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef;
  gs->xmlIndentTreeOutput = xmlIndentTreeOutputThrDef;
  gs->xmlTreeIndentString = (const char *)xmlTreeIndentStringThrDef;
  gs->xmlKeepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef;
  gs->xmlLineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef;
  gs->xmlLoadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef;
  gs->xmlParserDebugEntities = xmlParserDebugEntitiesThrDef;
  gs->xmlParserVersion = "20913";
  gs->xmlDefaultSAXLocator.getPublicId = xmlSAX2GetPublicId;
  gs->xmlPedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef;
  gs->xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef;
  gs->xmlSubstituteEntitiesDefaultValue = xmlSubstituteEntitiesDefaultValueThrDef;
  gs->xmlGenericError = (xmlGenericErrorFunc)xmlGenericErrorThrDef;
  gs->xmlStructuredError = (xmlStructuredErrorFunc)xmlStructuredErrorThrDef;
  gs->xmlGenericErrorContext = (void *)xmlGenericErrorContextThrDef;
  gs->xmlStructuredErrorContext = (void *)xmlStructuredErrorContextThrDef;
  gs->xmlRegisterNodeDefaultValue = (xmlRegisterNodeFunc)xmlRegisterNodeDefaultValueThrDef;
  gs->xmlDeregisterNodeDefaultValue = (xmlDeregisterNodeFunc)xmlDeregisterNodeDefaultValueThrDef;
  gs->xmlParserInputBufferCreateFilenameValue = (xmlParserInputBufferCreateFilenameFunc)xmlParserInputBufferCreateFilenameValueThrDef;
  gs->xmlOutputBufferCreateFilenameValue = (xmlOutputBufferCreateFilenameFunc)xmlOutputBufferCreateFilenameValueThrDef;
  gs->xmlLastError.node = 0;
  *(_OWORD *)&gs->xmlLastError.str2 = 0u;
  *(_OWORD *)&gs->xmlLastError.int1 = 0u;
  *(_OWORD *)&gs->xmlLastError.level = 0u;
  *(_OWORD *)&gs->xmlLastError.line = 0u;
  *(_OWORD *)&gs->xmlLastError.domain = 0u;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
}

void xmlMutexUnlock(xmlMutexPtr tok)
{
  if (tok)
    pthread_mutex_unlock((pthread_mutex_t *)tok);
}

void xmlMutexLock(xmlMutexPtr tok)
{
  if (tok)
    pthread_mutex_lock((pthread_mutex_t *)tok);
}

void initxmlDefaultSAXHandler(xmlSAXHandlerV1 *hdlr, int warning)
{
  void (*v2)(void *, const char *, ...);

  if (hdlr->initialized != 1)
  {
    hdlr->internalSubset = xmlSAX2InternalSubset;
    hdlr->isStandalone = xmlSAX2IsStandalone;
    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
    hdlr->resolveEntity = xmlSAX2ResolveEntity;
    hdlr->getEntity = xmlSAX2GetEntity;
    hdlr->attributeDecl = xmlSAX2AttributeDecl;
    hdlr->elementDecl = xmlSAX2ElementDecl;
    hdlr->entityDecl = xmlSAX2EntityDecl;
    hdlr->notationDecl = xmlSAX2NotationDecl;
    hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
    hdlr->startDocument = xmlSAX2StartDocument;
    hdlr->endDocument = xmlSAX2EndDocument;
    hdlr->startElement = xmlSAX2StartElement;
    hdlr->endElement = xmlSAX2EndElement;
    hdlr->reference = xmlSAX2Reference;
    hdlr->characters = xmlSAX2Characters;
    hdlr->cdataBlock = xmlSAX2CDataBlock;
    hdlr->externalSubset = xmlSAX2ExternalSubset;
    hdlr->ignorableWhitespace = xmlSAX2Characters;
    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
    v2 = xmlParserWarning;
    if (!warning)
      v2 = 0;
    hdlr->warning = v2;
    hdlr->error = xmlParserError;
    hdlr->fatalError = xmlParserError;
    hdlr->getParameterEntity = xmlSAX2GetParameterEntity;
    hdlr->initialized = 1;
  }
}

void inithtmlDefaultSAXHandler(xmlSAXHandlerV1 *hdlr)
{
  if (hdlr->initialized != 1)
  {
    hdlr->internalSubset = xmlSAX2InternalSubset;
    hdlr->externalSubset = 0;
    *(_OWORD *)&hdlr->isStandalone = 0u;
    *(_OWORD *)&hdlr->hasExternalSubset = 0u;
    hdlr->getEntity = xmlSAX2GetEntity;
    *(_OWORD *)&hdlr->entityDecl = 0u;
    *(_OWORD *)&hdlr->attributeDecl = 0u;
    hdlr->unparsedEntityDecl = 0;
    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
    hdlr->startDocument = xmlSAX2StartDocument;
    hdlr->endDocument = xmlSAX2EndDocument;
    hdlr->startElement = xmlSAX2StartElement;
    hdlr->endElement = xmlSAX2EndElement;
    hdlr->reference = 0;
    hdlr->characters = xmlSAX2Characters;
    hdlr->getParameterEntity = 0;
    hdlr->cdataBlock = xmlSAX2CDataBlock;
    hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
    hdlr->comment = xmlSAX2Comment;
    hdlr->warning = xmlParserWarning;
    hdlr->error = xmlParserError;
    hdlr->fatalError = xmlParserError;
    hdlr->initialized = 1;
  }
}

void initdocbDefaultSAXHandler(xmlSAXHandlerV1 *hdlr)
{
  if (hdlr->initialized != 1)
  {
    hdlr->internalSubset = xmlSAX2InternalSubset;
    hdlr->isStandalone = xmlSAX2IsStandalone;
    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
    hdlr->resolveEntity = xmlSAX2ResolveEntity;
    hdlr->getEntity = xmlSAX2GetEntity;
    hdlr->entityDecl = xmlSAX2EntityDecl;
    *(_OWORD *)&hdlr->notationDecl = 0u;
    *(_OWORD *)&hdlr->elementDecl = 0u;
    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
    hdlr->startDocument = xmlSAX2StartDocument;
    hdlr->endDocument = xmlSAX2EndDocument;
    hdlr->startElement = xmlSAX2StartElement;
    hdlr->endElement = xmlSAX2EndElement;
    hdlr->reference = xmlSAX2Reference;
    hdlr->cdataBlock = 0;
    hdlr->externalSubset = 0;
    hdlr->characters = xmlSAX2Characters;
    hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
    hdlr->processingInstruction = 0;
    hdlr->comment = xmlSAX2Comment;
    hdlr->warning = xmlParserWarning;
    hdlr->error = xmlParserError;
    hdlr->fatalError = xmlParserError;
    hdlr->getParameterEntity = 0;
    hdlr->initialized = 1;
  }
}

_OWORD *xmlTreeEnsureXMLDecl(uint64_t a1)
{
  _OWORD *v1;
  _OWORD *v3;

  v1 = *(_OWORD **)(a1 + 96);
  if (!v1)
  {
    v3 = xmlMalloc(0x30uLL);
    v1 = v3;
    if (v3)
    {
      v3[1] = 0u;
      v3[2] = 0u;
      *v3 = 0u;
      *((_DWORD *)v3 + 2) = 18;
      *((_QWORD *)v3 + 2) = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      *((_QWORD *)v1 + 3) = xmlStrdup((const xmlChar *)"xml");
      *(_QWORD *)(a1 + 96) = v1;
    }
    else
    {
      __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"allocating the XML namespace");
    }
  }
  return v1;
}

xmlNodePtr xmlStringLenGetNodeList(const xmlDoc *doc, const xmlChar *value, int len)
{
  const xmlChar *v4;
  uint64x2_t *Size;
  uint64x2_t *v7;
  xmlNode *Sibling;
  xmlNode *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const xmlChar *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  const xmlChar *v18;
  int v19;
  int v20;
  uint64_t v21;
  unsigned __int8 *v22;
  uint64_t v23;
  xmlChar *v24;
  xmlEntityPtr DocEntity;
  xmlEntityPtr v26;
  xmlChar *v27;
  unsigned __int8 *v28;
  int v29;
  uint64_t v30;
  xmlChar *v31;
  xmlNodePtr v32;
  xmlNode *v33;
  int v34;
  xmlNodePtr v35;
  xmlNodePtr NodeList;
  xmlNodePtr v37;
  xmlNodePtr v38;
  xmlNodePtr v39;
  xmlNode *v40;
  uint64_t v42;
  xmlNode *cur;
  xmlChar out[8];
  __int16 v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!value)
    return 0;
  v4 = value;
  Size = (uint64x2_t *)xmlBufCreateSize(0);
  if (!Size)
    return 0;
  v7 = Size;
  xmlBufSetAllocationScheme((uint64_t)Size, 4u);
  if (len >= 1)
  {
    Sibling = 0;
    v9 = 0;
    v10 = len;
    v11 = (unint64_t)&v4[len];
    v12 = (uint64_t)&v4[v10 - 2];
    v13 = v4;
    while (1)
    {
      if (*v13 != 38)
      {
        if (!*v13)
          goto LABEL_88;
        ++v13;
        goto LABEL_87;
      }
      if (v13 != v4 && xmlBufAdd(v7, v4, ((_DWORD)v13 - (_DWORD)v4)))
        goto LABEL_103;
      v14 = (unsigned __int8 *)(v13 + 2);
      if ((unint64_t)(v13 + 2) < v11 && v13[1] == 35 && *v14 == 120)
      {
        v15 = (unsigned __int8 *)(v13 + 3);
        if ((unint64_t)(v13 + 3) >= v11)
        {
          v16 = 0;
LABEL_46:
          v17 = 0;
          v28 = (unsigned __int8 *)(v13 + 4);
          while (1)
          {
            if ((v16 - 48) < 0xA)
            {
              v29 = -48;
            }
            else if ((v16 - 97) < 6)
            {
              v29 = -87;
            }
            else
            {
              if ((v16 - 65) >= 6)
              {
                __xmlSimpleError(2u, 1300, (uint64_t)doc, "invalid hexadecimal character value\n", 0);
                v30 = 0;
                v17 = 0;
                v15 = v28 - 1;
                goto LABEL_66;
              }
              v29 = -55;
            }
            v17 = v29 + 16 * v17 + v16;
            if (v17 >= 1114112)
              v17 = 1114112;
            if ((unint64_t)v28 >= v11)
              v16 = 0;
            else
              v16 = *v28;
            ++v28;
            if (v16 == 59)
            {
              v15 = v28 - 1;
              goto LABEL_60;
            }
          }
        }
        v16 = *v15;
        if (v16 != 59)
          goto LABEL_46;
        v17 = 0;
LABEL_60:
        v30 = 1;
LABEL_66:
        v13 = &v15[v30];
        if (v17)
        {
LABEL_67:
          v45 = 0;
          *(_QWORD *)out = 0;
          if (v17 < 1114112)
            v34 = v17;
          else
            v34 = 65533;
          out[xmlCopyCharMultiByte(out, v34)] = 0;
          v4 = v13;
          if (xmlBufCat(v7, out))
            goto LABEL_103;
          goto LABEL_87;
        }
        goto LABEL_86;
      }
      v18 = v13 + 1;
      if ((unint64_t)(v13 + 1) >= v11)
        goto LABEL_94;
      v19 = *v18;
      if (v19 == 35)
        break;
      v21 = 0;
      if (!*v18)
      {
LABEL_94:
        __xmlSimpleError(2u, 1302, (uint64_t)doc, "unterminated entity reference %15s\n", v18);
        goto LABEL_103;
      }
      while (v19 != 59)
      {
        if (v12 - (_QWORD)v13 != v21)
        {
          v19 = v13[v21++ + 2];
          if (v19)
            continue;
        }
        goto LABEL_94;
      }
      if (v21)
      {
        v42 = v12;
        cur = Sibling;
        v24 = xmlStrndup(v13 + 1, v21);
        DocEntity = xmlGetDocEntity(doc, v24);
        v26 = DocEntity;
        if (DocEntity && DocEntity->etype == XML_INTERNAL_PREDEFINED_ENTITY)
        {
          v27 = v24;
          v12 = v42;
          Sibling = cur;
          if (xmlBufCat(v7, DocEntity->content))
            goto LABEL_103;
        }
        else
        {
          if (!xmlBufIsEmpty((uint64_t)v7))
          {
            v31 = v24;
            v32 = xmlNewText(0);
            if (!v32)
            {
              if (!v24)
                goto LABEL_103;
              goto LABEL_108;
            }
            v33 = v32;
            v32->doc = (_xmlDoc *)doc;
            v32->content = (xmlChar *)xmlBufDetach(v7->i64);
            if (cur)
            {
              cur = xmlAddNextSibling(cur, v33);
            }
            else
            {
              v9 = v33;
              cur = v33;
            }
            v24 = v31;
          }
          v27 = v24;
          v35 = xmlNewReference(doc, v24);
          if (!v35)
          {
            if (!v24)
              goto LABEL_103;
LABEL_108:
            ((void (*)(xmlChar *))xmlFree)(v24);
            goto LABEL_103;
          }
          Sibling = v35;
          if (v26)
          {
            if (!v26->children)
            {
              v26->children = (_xmlNode *)-1;
              NodeList = xmlStringGetNodeList(doc, v35->content);
              v26->children = NodeList;
              v26->owner = 1;
              if (NodeList)
              {
                do
                {
                  v37 = NodeList;
                  NodeList->parent = (_xmlNode *)v26;
                  NodeList = NodeList->next;
                }
                while (NodeList);
                v26->last = v37;
              }
            }
          }
          if (cur)
            Sibling = xmlAddNextSibling(cur, Sibling);
          else
            v9 = Sibling;
          v12 = v42;
        }
        xmlFree(v27);
      }
      v13 += v21 + 2;
LABEL_86:
      v4 = v13;
LABEL_87:
      if ((unint64_t)v13 >= v11)
      {
LABEL_88:
        if (v13 == v4 || !xmlBufAdd(v7, v4, ((_DWORD)v13 - (_DWORD)v4)))
        {
          if (!xmlBufIsEmpty((uint64_t)v7))
            goto LABEL_99;
          if (!v9)
          {
LABEL_96:
            v38 = xmlNewText((const xmlChar *)&byte_1B0865C1A);
            v9 = v38;
            if (v38)
              v38->doc = (_xmlDoc *)doc;
          }
        }
        goto LABEL_103;
      }
    }
    if ((unint64_t)v14 >= v11)
    {
      v20 = 0;
    }
    else
    {
      v20 = *v14;
      if (v20 == 59)
      {
        v17 = 0;
LABEL_36:
        v23 = 1;
        goto LABEL_38;
      }
    }
    v17 = 0;
    v22 = (unsigned __int8 *)(v13 + 3);
    while ((v20 - 48) <= 9)
    {
      v17 = v20 + 10 * v17 - 48;
      if (v17 >= 1114112)
        v17 = 1114112;
      if ((unint64_t)v22 >= v11)
        v20 = 0;
      else
        v20 = *v22;
      ++v22;
      if (v20 == 59)
      {
        v14 = v22 - 1;
        goto LABEL_36;
      }
    }
    __xmlSimpleError(2u, 1301, (uint64_t)doc, "invalid decimal character value\n", 0);
    v23 = 0;
    v17 = 0;
    v14 = v22 - 1;
LABEL_38:
    v13 = &v14[v23];
    if (v17)
      goto LABEL_67;
    goto LABEL_86;
  }
  if (xmlBufIsEmpty((uint64_t)v7))
    goto LABEL_96;
  v9 = 0;
  Sibling = 0;
LABEL_99:
  v39 = xmlNewText(0);
  if (v39)
  {
    v40 = v39;
    v39->doc = (_xmlDoc *)doc;
    v39->content = (xmlChar *)xmlBufDetach(v7->i64);
    if (Sibling)
      xmlAddNextSibling(Sibling, v40);
    else
      v9 = v40;
  }
LABEL_103:
  xmlBufFree(v7);
  return v9;
}

void xmlFreeTextReader(xmlTextReaderPtr reader)
{
  xmlRelaxNG *v2;
  xmlRelaxNGValidCtxt *v3;
  xmlSchemaSAXPlugStruct *v4;
  xmlSchemaValidCtxt *v5;
  xmlSchema *v6;
  xmlXIncludeCtxt *v7;
  void *v8;
  int v9;
  uint64_t i;
  xmlPattern *v11;
  xmlParserCtxt *v12;
  void *v13;
  _DWORD *v14;
  void *v15;
  xmlDict *v16;

  if (reader)
  {
    v2 = (xmlRelaxNG *)*((_QWORD *)reader + 26);
    if (v2)
    {
      xmlRelaxNGFree(v2);
      *((_QWORD *)reader + 26) = 0;
    }
    v3 = (xmlRelaxNGValidCtxt *)*((_QWORD *)reader + 27);
    if (v3)
    {
      if (!*((_DWORD *)reader + 56))
        xmlRelaxNGFreeValidCtxt(v3);
      *((_QWORD *)reader + 27) = 0;
    }
    v4 = (xmlSchemaSAXPlugStruct *)*((_QWORD *)reader + 33);
    if (v4)
    {
      xmlSchemaSAXUnplug(v4);
      *((_QWORD *)reader + 33) = 0;
    }
    v5 = (xmlSchemaValidCtxt *)*((_QWORD *)reader + 31);
    if (v5)
    {
      if (!*((_DWORD *)reader + 64))
        xmlSchemaFreeValidCtxt(v5);
      *((_QWORD *)reader + 31) = 0;
    }
    v6 = (xmlSchema *)*((_QWORD *)reader + 30);
    if (v6)
    {
      xmlSchemaFree(v6);
      *((_QWORD *)reader + 30) = 0;
    }
    v7 = (xmlXIncludeCtxt *)*((_QWORD *)reader + 36);
    if (v7)
      xmlXIncludeFreeContext(v7);
    v8 = (void *)*((_QWORD *)reader + 39);
    if (v8)
    {
      v9 = *((_DWORD *)reader + 75);
      if (v9 >= 1)
      {
        for (i = 0; i < v9; ++i)
        {
          v11 = *(xmlPattern **)(*((_QWORD *)reader + 39) + 8 * i);
          if (v11)
          {
            xmlFreePattern(v11);
            v9 = *((_DWORD *)reader + 75);
          }
        }
        v8 = (void *)*((_QWORD *)reader + 39);
      }
      xmlFree(v8);
    }
    if (*(_DWORD *)reader != 4)
      xmlTextReaderClose(reader);
    v12 = (xmlParserCtxt *)*((_QWORD *)reader + 4);
    if (v12)
    {
      if ((xmlDictPtr)*((_QWORD *)reader + 20) == v12->dict)
        *((_QWORD *)reader + 20) = 0;
      if ((*((_BYTE *)reader + 20) & 2) != 0)
        xmlFreeParserCtxt(v12);
    }
    v13 = (void *)*((_QWORD *)reader + 5);
    if (v13)
      xmlFree(v13);
    v14 = (_DWORD *)*((_QWORD *)reader + 19);
    if (v14)
      xmlBufFree(v14);
    v15 = (void *)*((_QWORD *)reader + 23);
    if (v15)
      xmlFree(v15);
    v16 = (xmlDict *)*((_QWORD *)reader + 20);
    if (v16)
      xmlDictFree(v16);
    xmlFree(reader);
  }
}

int xmlTextReaderClose(xmlTextReaderPtr reader)
{
  xmlNode *v2;
  xmlParserCtxt *v3;
  xmlValidState *vstateTab;
  uint64_t v5;
  uint64_t v6;
  xmlParserInputBuffer *v7;

  if (reader)
  {
    *((_QWORD *)reader + 14) = 0;
    *((_QWORD *)reader + 15) = 0;
    *(_DWORD *)reader = 4;
    v2 = (xmlNode *)*((_QWORD *)reader + 17);
    if (v2)
    {
      xmlFreeNode(v2);
      *((_QWORD *)reader + 17) = 0;
    }
    v3 = (xmlParserCtxt *)*((_QWORD *)reader + 4);
    if (v3)
    {
      vstateTab = v3->vctxt.vstateTab;
      if (vstateTab && v3->vctxt.vstateMax >= 1)
      {
        if (v3->vctxt.vstateNr >= 1)
        {
          do
          {
            xmlValidatePopElement(&v3->vctxt, 0, 0, 0);
            v3 = (xmlParserCtxt *)*((_QWORD *)reader + 4);
          }
          while (v3->vctxt.vstateNr > 0);
          vstateTab = v3->vctxt.vstateTab;
        }
        xmlFree(vstateTab);
        v3 = (xmlParserCtxt *)*((_QWORD *)reader + 4);
        v3->vctxt.vstateTab = 0;
        v3->vctxt.vstateMax = 0;
      }
      xmlStopParser(v3);
      v5 = *((_QWORD *)reader + 4);
      v6 = *(_QWORD *)(v5 + 16);
      if (v6)
      {
        if (!*((_DWORD *)reader + 36))
        {
          xmlTextReaderFreeDoc((uint64_t)reader, v6);
          v5 = *((_QWORD *)reader + 4);
        }
        *(_QWORD *)(v5 + 16) = 0;
      }
    }
    v7 = (xmlParserInputBuffer *)*((_QWORD *)reader + 6);
    if (v7)
    {
      if ((*((_BYTE *)reader + 20) & 1) != 0)
      {
        xmlFreeParserInputBuffer(v7);
        LODWORD(v7) = 0;
        --*((_DWORD *)reader + 5);
      }
      else
      {
        LODWORD(v7) = 0;
      }
    }
  }
  else
  {
    LODWORD(v7) = -1;
  }
  return (int)v7;
}

void xmlTextReaderFreeDoc(uint64_t a1, uint64_t a2)
{
  xmlDeregisterNodeFunc *v4;
  xmlHashTable *v5;
  xmlRefTable *v6;
  xmlDtd *v7;
  xmlDtd *v8;
  xmlDoc *v9;
  void *v10;
  void *v11;
  void *v12;
  xmlNs *v13;
  void *v14;
  xmlDict *v15;

  if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
  {
    v4 = __xmlDeregisterNodeDefaultValue();
    ((void (*)(uint64_t))*v4)(a2);
  }
  v5 = *(xmlHashTable **)(a2 + 120);
  if (v5)
    xmlHashFree(v5, (xmlHashDeallocator)xmlTextReaderFreeIDTableEntry);
  *(_QWORD *)(a2 + 120) = 0;
  v6 = *(xmlRefTable **)(a2 + 128);
  if (v6)
    xmlFreeRefTable(v6);
  *(_QWORD *)(a2 + 128) = 0;
  v7 = *(xmlDtd **)(a2 + 80);
  v8 = *(xmlDtd **)(a2 + 88);
  if (v8 && v7 != v8)
  {
    xmlUnlinkNode(*(xmlNodePtr *)(a2 + 88));
    *(_QWORD *)(a2 + 88) = 0;
    xmlFreeDtd(v8);
  }
  if (v7)
  {
    xmlUnlinkNode(*(xmlNodePtr *)(a2 + 80));
    *(_QWORD *)(a2 + 80) = 0;
    xmlFreeDtd(v7);
  }
  v9 = *(xmlDoc **)(a2 + 24);
  if (v9)
    xmlTextReaderFreeNodeList(a1, v9);
  v10 = *(void **)(a2 + 104);
  if (v10)
    xmlFree(v10);
  v11 = *(void **)(a2 + 16);
  if (v11)
    xmlFree(v11);
  v12 = *(void **)(a2 + 112);
  if (v12)
    xmlFree(v12);
  v13 = *(xmlNs **)(a2 + 96);
  if (v13)
    xmlFreeNsList(v13);
  v14 = *(void **)(a2 + 136);
  if (v14)
    xmlFree(v14);
  v15 = *(xmlDict **)(a2 + 152);
  if (v15)
    xmlDictFree(v15);
  xmlFree((void *)a2);
}

void xmlStopParser(xmlParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    xmlHaltParser(ctxt);
    ctxt->errNo = 111;
  }
}

void xmlHaltParser(xmlParserCtxtPtr ctxt)
{
  xmlParserInput *v2;
  xmlParserInputPtr input;
  void (*free)(const xmlChar *);

  if (ctxt)
  {
    ctxt->instate = XML_PARSER_EOF;
    ctxt->disableSAX = 1;
    if (ctxt->inputNr >= 2)
    {
      do
      {
        v2 = inputPop(ctxt);
        xmlFreeInputStream(v2);
      }
      while (ctxt->inputNr > 1);
    }
    input = ctxt->input;
    if (input)
    {
      free = (void (*)(const xmlChar *))input->free;
      if (free)
      {
        free(input->base);
        input = ctxt->input;
        input->free = 0;
      }
      if (input->buf)
      {
        xmlFreeParserInputBuffer(input->buf);
        input = ctxt->input;
        input->buf = 0;
      }
      input->length = 0;
      input->base = (const xmlChar *)&byte_1B0865C1A;
      input->cur = (const xmlChar *)&byte_1B0865C1A;
      input->end = (const xmlChar *)&byte_1B0865C1A;
    }
  }
}

void xmlFreeNode(xmlNodePtr cur)
{
  xmlElementType type;
  xmlChar *name;
  _xmlNode *children;
  xmlFreeFunc v5;
  xmlDeregisterNodeFunc *v6;
  _xmlDoc *doc;
  xmlDict *dict;
  xmlElementType v9;
  xmlChar *psvi;
  xmlNs *v11;
  xmlNode *v12;
  _xmlAttr *properties;
  _xmlAttr *next;
  xmlChar *content;
  xmlChar *v19;
  xmlElementType v20;
  xmlNs *nsDef;

  if (cur)
  {
    type = cur->type;
    switch(type)
    {
      case XML_ATTRIBUTE_NODE:
        xmlFreeProp((xmlAttrPtr)cur);
        return;
      case XML_NAMESPACE_DECL:
        name = (xmlChar *)cur->name;
        if (name)
          xmlFree(name);
        children = cur->children;
        if (children)
          xmlFree(children);
        v5 = xmlFree;
        goto LABEL_67;
      case XML_DTD_NODE:
        xmlFreeDtd((xmlDtdPtr)cur);
        return;
    }
    if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
    {
      v6 = __xmlDeregisterNodeDefaultValue();
      ((void (*)(xmlNodePtr))*v6)(cur);
    }
    doc = cur->doc;
    if (doc)
      dict = doc->dict;
    else
      dict = 0;
    v9 = cur->type;
    if (v9 != XML_ENTITY_DECL)
    {
LABEL_31:
      v12 = cur->children;
      if (v12)
      {
        if (v9 == XML_ENTITY_REF_NODE)
        {
LABEL_40:
          content = cur->content;
          if (v9 - 19 >= 2 && v9 != XML_ENTITY_REF_NODE && content != 0 && content != (xmlChar *)&cur->properties)
          {
            if (dict)
            {
              if (xmlDictOwns(dict, content))
                goto LABEL_54;
              content = cur->content;
            }
            xmlFree(content);
          }
LABEL_54:
          v19 = (xmlChar *)cur->name;
          if (v19)
          {
            v20 = cur->type;
            if (v20 == XML_TEXT_NODE || v20 == XML_COMMENT_NODE)
              goto LABEL_62;
            if (!dict)
              goto LABEL_60;
            if (!xmlDictOwns(dict, v19))
            {
              v19 = (xmlChar *)cur->name;
LABEL_60:
              xmlFree(v19);
            }
          }
          v20 = cur->type;
LABEL_62:
          if (v20 <= XML_XINCLUDE_END && ((1 << v20) & 0x180002) != 0)
          {
            nsDef = cur->nsDef;
            if (nsDef)
              xmlFreeNsList(nsDef);
          }
          v5 = xmlFree;
LABEL_67:
          ((void (*)(xmlNodePtr))v5)(cur);
          return;
        }
        xmlFreeNodeList(v12);
        v9 = cur->type;
      }
      if (v9 <= XML_XINCLUDE_END && ((1 << v9) & 0x180002) != 0)
      {
        properties = cur->properties;
        if (properties)
        {
          do
          {
            next = properties->next;
            xmlFreeProp(properties);
            properties = next;
          }
          while (next);
          v9 = cur->type;
        }
      }
      if (v9 == XML_ELEMENT_NODE)
        goto LABEL_54;
      goto LABEL_40;
    }
    psvi = (xmlChar *)cur->psvi;
    if (psvi)
    {
      if (dict)
      {
        if (xmlDictOwns(dict, psvi))
          goto LABEL_25;
        psvi = (xmlChar *)cur->psvi;
      }
      xmlFree(psvi);
    }
LABEL_25:
    v11 = cur->nsDef;
    if (v11)
    {
      if (!dict)
      {
LABEL_29:
        xmlFree(v11);
        goto LABEL_30;
      }
      if (!xmlDictOwns(dict, (const xmlChar *)v11))
      {
        v11 = cur->nsDef;
        goto LABEL_29;
      }
    }
LABEL_30:
    v9 = cur->type;
    goto LABEL_31;
  }
}

int xmlTextReaderRead(xmlTextReaderPtr reader)
{
  uint64_t v2;
  int v3;
  int result;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  BOOL v25;
  int v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  BOOL v30;
  int v31;
  BOOL v32;
  int v33;
  char v34;
  unsigned int v35;
  int v36;
  char v38;
  int v39;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  xmlXIncludeCtxt *v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  _DWORD *v57;
  int v58;
  int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  xmlChar *v63;
  int v64;
  xmlSchemaValidCtxt *v65;

  if (!reader)
    return -1;
  *((_QWORD *)reader + 15) = 0;
  v2 = *((_QWORD *)reader + 1);
  if (v2)
  {
    v3 = *((_DWORD *)reader + 6);
    if (v3 == 2)
      return 0;
    v10 = *((_QWORD *)reader + 14);
    while (1)
    {
      if (v10)
      {
        if (v3 != 4)
        {
          v11 = *(_DWORD *)(v10 + 8);
          if (v11 > 0x13 || ((1 << v11) & 0x84020) == 0)
          {
            v13 = *(_QWORD *)(v10 + 24);
            if (v13)
            {
              v3 = 0;
              *((_QWORD *)reader + 14) = v13;
              ++*((_DWORD *)reader + 32);
              goto LABEL_26;
            }
            if (v11 == 2)
            {
              v3 = 4;
              goto LABEL_27;
            }
          }
        }
        v13 = *(_QWORD *)(v10 + 48);
        if (v13)
        {
          v3 = 0;
          *((_QWORD *)reader + 14) = v13;
LABEL_26:
          v10 = v13;
          goto LABEL_27;
        }
        v13 = *(_QWORD *)(v10 + 40);
        if (v13)
        {
          if ((*(_DWORD *)(v13 + 8) | 4) == 0xD)
          {
LABEL_31:
            result = 0;
            v14 = 2;
            goto LABEL_68;
          }
          *((_QWORD *)reader + 14) = v13;
          --*((_DWORD *)reader + 32);
          v3 = 4;
          goto LABEL_26;
        }
        v3 = 2;
      }
      else
      {
        v10 = *(_QWORD *)(v2 + 24);
        if (!v10)
          goto LABEL_31;
        v3 = 0;
        *((_QWORD *)reader + 14) = v10;
      }
LABEL_27:
      *((_DWORD *)reader + 6) = v3;
      if ((*(_DWORD *)(v10 + 8) - 19) >= 2)
        return 1;
    }
  }
  v5 = *((_QWORD *)reader + 4);
  if (!v5)
    return -1;
  if (!*(_DWORD *)reader)
  {
    *(_DWORD *)reader = 1;
    while (1)
    {
      if ((xmlTextReaderPushData((uint64_t)reader) & 0x80000000) != 0)
        goto LABEL_43;
      v15 = *((_QWORD *)reader + 4);
      if (*(_QWORD *)(v15 + 80))
        break;
      if (*(_DWORD *)reader == 3 || *((_DWORD *)reader + 6) == 5)
      {
        v16 = *(_QWORD *)(v15 + 16);
        if (v16)
        {
          v17 = *(_QWORD *)(v16 + 24);
          *((_QWORD *)reader + 14) = v17;
        }
        else
        {
          v17 = *((_QWORD *)reader + 14);
        }
        if (!v17)
        {
LABEL_43:
          *(_DWORD *)reader = 2;
          *((_DWORD *)reader + 6) = 6;
          return -1;
        }
LABEL_48:
        v7 = 0;
        v6 = 0;
        v9 = 0;
        *((_DWORD *)reader + 6) = 1;
        *((_DWORD *)reader + 32) = 0;
        *(_DWORD *)(v15 + 688) = 5;
        goto LABEL_125;
      }
    }
    v18 = *(_QWORD *)(v15 + 16);
    if (v18)
    {
      v19 = *(_QWORD *)(v18 + 24);
      *((_QWORD *)reader + 14) = v19;
    }
    else
    {
      v19 = *((_QWORD *)reader + 14);
    }
    if (!v19)
      *((_QWORD *)reader + 14) = **(_QWORD **)(v15 + 96);
    goto LABEL_48;
  }
  v6 = *((_DWORD *)reader + 6);
  v7 = *(_DWORD *)(v5 + 88);
  v8 = *((_QWORD *)reader + 14);
  v9 = v8;
  if (!v8)
  {
LABEL_164:
    if (*(_DWORD *)reader == 3)
      return 0;
    else
      return -1;
  }
  while (1)
  {
    while (1)
    {
      while (1)
      {
        v20 = *(_QWORD *)(v8 + 48);
        if (v20)
          break;
        v21 = *((_QWORD *)reader + 4);
        if (*(_DWORD *)(v21 + 88) != v7)
          goto LABEL_69;
        if (v6 != 4)
        {
          v22 = *(_QWORD *)(v8 + 24);
          if (v22)
          {
            v23 = *(_DWORD *)(v8 + 8);
            if (v23 != 5
              && (*(_DWORD *)(v22 + 8) != 3 || *(_QWORD *)(v22 + 48))
              && (v23 > 0xE || ((1 << v23) & 0x6200) == 0))
            {
LABEL_88:
              v35 = *(_DWORD *)(v8 + 8);
              v34 = 1;
              v30 = v35 > 0x13;
              v36 = (1 << v35) & 0x84020;
              if (v30 || v36 == 0)
              {
                *((_QWORD *)reader + 14) = v22;
                ++*((_DWORD *)reader + 32);
                *((_DWORD *)reader + 6) = 1;
                goto LABEL_125;
              }
              goto LABEL_92;
            }
          }
        }
        v24 = *(_QWORD *)(v21 + 80);
        v25 = !v24 || v24 == v8;
        if (!v25 && v24 != *(_QWORD *)(v8 + 40) || *(_DWORD *)(v21 + 272) == -1)
        {
LABEL_69:
          if (v6 == 4)
            goto LABEL_70;
          goto LABEL_87;
        }
        if ((xmlTextReaderPushData((uint64_t)reader) & 0x80000000) != 0)
          goto LABEL_43;
        v8 = *((_QWORD *)reader + 14);
        if (!v8)
          goto LABEL_67;
      }
      if (v6 == 4)
        goto LABEL_100;
LABEL_87:
      v34 = 0;
      v22 = *(_QWORD *)(v8 + 24);
      if (v22)
        goto LABEL_88;
LABEL_92:
      if (!v20)
      {
        if (v6 == 1)
        {
          v40 = *(_DWORD *)(v8 + 8) == 1 ? v34 : 1;
          if ((v40 & 1) == 0 && (*(_WORD *)(v8 + 114) & 1) == 0)
          {
LABEL_113:
            *((_DWORD *)reader + 6) = 2;
            v6 = 1;
            goto LABEL_125;
          }
        }
LABEL_70:
        if (*((_DWORD *)reader + 4) && *(_DWORD *)(v8 + 8) == 1)
        {
          xmlTextReaderValidatePop((uint64_t)reader);
          v8 = *((_QWORD *)reader + 14);
        }
        v26 = *((_DWORD *)reader + 80);
        v27 = v26 - 1;
        if (v26 >= 1)
        {
          v26 = 1;
          if ((*(_WORD *)(v8 + 114) & 4) != 0)
          {
            *((_DWORD *)reader + 80) = v27;
            v26 = v27;
          }
        }
        v28 = *(_QWORD *)(v8 + 40);
        *((_QWORD *)reader + 14) = v28;
        if (!v28
          || ((v29 = *(_DWORD *)(v28 + 8), v30 = v29 > 0x15, v31 = (1 << v29) & 0x202200, !v30)
            ? (v32 = v31 == 0)
            : (v32 = 1),
              !v32))
        {
          if (*(_DWORD *)reader != 3)
          {
            v56 = xmlParseChunk(*((xmlParserCtxtPtr *)reader + 4), &byte_1B0865C1A, 0, 1);
            *((_DWORD *)reader + 6) = 5;
            if (v56)
              return -1;
          }
          *((_QWORD *)reader + 14) = 0;
          *((_DWORD *)reader + 32) = -1;
          if (v9
            && !*((_DWORD *)reader + 80)
            && !*((_DWORD *)reader + 74)
            && !*((_DWORD *)reader + 44)
            && *(_DWORD *)(v9 + 8) != 14
            && (*(_WORD *)(v9 + 114) & 2) == 0)
          {
            xmlUnlinkNode((xmlNodePtr)v9);
            xmlTextReaderFreeNode((uint64_t)reader, (xmlAttr *)v9);
          }
LABEL_67:
          result = 0;
          v14 = 5;
LABEL_68:
          *((_DWORD *)reader + 6) = v14;
          return result;
        }
        if (!v26 && !*((_DWORD *)reader + 74) && !*((_DWORD *)reader + 44))
        {
          v62 = *(_QWORD *)(v28 + 32);
          if (v62)
          {
            if ((*(_WORD *)(v62 + 114) & 2) == 0)
            {
              xmlUnlinkNode(*(xmlNodePtr *)(v28 + 32));
              xmlTextReaderFreeNode((uint64_t)reader, (xmlAttr *)v62);
            }
          }
        }
        --*((_DWORD *)reader + 32);
        v33 = 4;
LABEL_106:
        *((_DWORD *)reader + 6) = v33;
        goto LABEL_125;
      }
      if (v6 == 1)
      {
        v38 = *(_DWORD *)(v8 + 8) == 1 ? v34 : 1;
        if ((v38 & 1) == 0 && (*(_WORD *)(v8 + 114) & 1) == 0 && *((int *)reader + 74) <= 0)
          goto LABEL_113;
      }
LABEL_100:
      if (*((_DWORD *)reader + 4) && *(_DWORD *)(v8 + 8) == 1)
      {
        xmlTextReaderValidatePop((uint64_t)reader);
        v8 = *((_QWORD *)reader + 14);
      }
      v39 = *((_DWORD *)reader + 80);
      if (v39 >= 1)
      {
        if ((*(_WORD *)(v8 + 114) & 4) == 0)
        {
          *((_QWORD *)reader + 14) = *(_QWORD *)(v8 + 48);
          v33 = 1;
          goto LABEL_106;
        }
        *((_DWORD *)reader + 80) = --v39;
      }
      v41 = *(_QWORD *)(v8 + 48);
      *((_QWORD *)reader + 14) = v41;
      *((_DWORD *)reader + 6) = 1;
      if (!v39 && !*((_DWORD *)reader + 74) && !*((_DWORD *)reader + 44))
      {
        v42 = *(_QWORD *)(v41 + 56);
        if (v42)
        {
          if (*(_DWORD *)(v42 + 8) != 14 && (*(_WORD *)(v42 + 114) & 2) == 0)
          {
            if (v9 == v42)
              v9 = 0;
            xmlUnlinkNode((xmlNodePtr)v42);
            xmlTextReaderFreeNode((uint64_t)reader, (xmlAttr *)v42);
          }
        }
      }
LABEL_125:
      v43 = *((_QWORD *)reader + 14);
      if (v43
        && !*(_QWORD *)(v43 + 48)
        && (*(_DWORD *)(v43 + 8) - 3) <= 1
        && !xmlTextReaderExpand(reader))
      {
        return -1;
      }
      if (*((_DWORD *)reader + 68) && !*((_DWORD *)reader + 74) && *((_DWORD *)reader + 6) != 4)
      {
        v44 = *((_QWORD *)reader + 14);
        if (!v44)
          goto LABEL_181;
        if (*(_DWORD *)(v44 + 8) == 1)
        {
          v45 = *(_QWORD *)(v44 + 72);
          if (v45)
          {
            if (xmlStrEqual(*(const xmlChar **)(v45 + 16), (const xmlChar *)"http://www.w3.org/2003/XInclude")
              || xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(*((_QWORD *)reader + 14) + 72) + 16), (const xmlChar *)"http://www.w3.org/2001/XInclude"))
            {
              if (!*((_QWORD *)reader + 36))
              {
                v46 = xmlXIncludeNewContext(*(xmlDocPtr *)(*((_QWORD *)reader + 4) + 16));
                *((_QWORD *)reader + 36) = v46;
                xmlXIncludeSetFlags(v46, *((_DWORD *)reader + 81) & 0xFFFF7FFF);
              }
              if (!xmlTextReaderExpand(reader))
                return -1;
              xmlXIncludeProcessNode(*((xmlXIncludeCtxtPtr *)reader + 36), *((xmlNodePtr *)reader + 14));
            }
          }
        }
      }
      v8 = *((_QWORD *)reader + 14);
      if (!v8)
      {
LABEL_181:
        v57 = (_DWORD *)((char *)reader + 16);
        goto LABEL_182;
      }
      v47 = *(_DWORD *)(v8 + 8);
      if (v47 == 5)
        break;
      v48 = 1;
      if (v47 == 19)
        goto LABEL_146;
      if (v47 != 20)
        goto LABEL_156;
      v48 = -1;
LABEL_146:
      *((_DWORD *)reader + 74) += v48;
    }
    v49 = *((_QWORD *)reader + 4);
    if (!v49)
      goto LABEL_156;
    if (*(_DWORD *)(v49 + 28) == 1)
    {
      v50 = *(_QWORD *)(v8 + 24);
      if (!v50 || *(_DWORD *)(v50 + 8) != 17 || !*(_QWORD *)(v50 + 24))
        goto LABEL_156;
      xmlTextReaderEntPush((uint64_t)reader, v8);
      v8 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)reader + 14) + 24) + 24);
      *((_QWORD *)reader + 14) = v8;
    }
    else
    {
      if (!*((_DWORD *)reader + 4))
        goto LABEL_156;
      xmlTextReaderValidateEntity((uint64_t)reader);
      v8 = *((_QWORD *)reader + 14);
    }
    if (!v8)
      goto LABEL_181;
LABEL_156:
    if (*(_DWORD *)(v8 + 8) != 17)
      break;
    v51 = *((_QWORD *)reader + 21);
    if (!v51 || *(_QWORD *)(v51 + 24) != v8)
      break;
    v8 = 0;
    v52 = *((_DWORD *)reader + 44);
    v53 = v52 - 1;
    if (v52 >= 1)
    {
      v54 = 0;
      *((_DWORD *)reader + 44) = v53;
      v55 = *((_QWORD *)reader + 23);
      if (v52 != 1)
        v54 = *(_QWORD *)(v55 + 8 * (v52 - 2));
      *((_QWORD *)reader + 21) = v54;
      v8 = *(_QWORD *)(v55 + 8 * v53);
      *(_QWORD *)(v55 + 8 * v53) = 0;
    }
    *((_QWORD *)reader + 14) = v8;
    ++*((_DWORD *)reader + 32);
    if (!v8)
      goto LABEL_164;
  }
  v57 = (_DWORD *)((char *)reader + 16);
  if (*((_DWORD *)reader + 4))
  {
    v58 = *(_DWORD *)(v8 + 8);
    if (v58 == 1)
    {
      v59 = *((_DWORD *)reader + 6);
      if (v59 != 2 && v59 != 4)
        xmlTextReaderValidatePush((uint64_t)reader);
    }
    else if ((v58 - 3) <= 1)
    {
      v63 = *(xmlChar **)(v8 + 80);
      v64 = xmlStrlen(v63);
      xmlTextReaderValidateCData((uint64_t)reader, v63, v64);
    }
  }
LABEL_182:
  if (*((int *)reader + 75) >= 1)
  {
    v60 = *((_DWORD *)reader + 6);
    if (v60 != 2 && v60 != 4)
    {
      v61 = 0;
      while (xmlPatternMatch(*(xmlPatternPtr *)(*((_QWORD *)reader + 39) + 8 * v61), *((xmlNodePtr *)reader + 14)) != 1)
      {
        if (++v61 >= *((int *)reader + 75))
          goto LABEL_195;
      }
      xmlTextReaderPreserve(reader);
    }
  }
LABEL_195:
  if (*v57 == 4 && !*((_DWORD *)reader + 65))
  {
    v65 = (xmlSchemaValidCtxt *)*((_QWORD *)reader + 31);
    if (v65)
      *((_DWORD *)reader + 65) = xmlSchemaIsValid(v65) == 0;
  }
  return 1;
}

void xmlTextReaderFreeNode(uint64_t a1, xmlAttr *cur)
{
  uint64_t v4;
  xmlDict *v5;
  xmlElementType type;
  _xmlNode *children;
  xmlDeregisterNodeFunc *v8;
  xmlElementType v9;
  xmlAttr *psvi;
  _xmlAttr *next;
  xmlDtd *v12;
  xmlElementType v13;
  xmlNs *v17;
  xmlChar *name;
  uint64_t v19;
  int v20;

  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
    v5 = *(xmlDict **)(v4 + 456);
  else
    v5 = 0;
  type = cur->type;
  switch(type)
  {
    case XML_ATTRIBUTE_NODE:
      xmlTextReaderFreeProp(a1, cur);
      return;
    case XML_NAMESPACE_DECL:
      xmlFreeNs((xmlNsPtr)cur);
      return;
    case XML_DTD_NODE:
      xmlFreeDtd((xmlDtdPtr)cur);
      return;
  }
  if (type != XML_ENTITY_REF_NODE)
  {
    children = cur->children;
    if (children)
    {
      if ((xmlAttr *)children->parent == cur)
        xmlTextReaderFreeNodeList(a1, (xmlDoc *)children);
      cur->children = 0;
    }
  }
  if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
  {
    v8 = __xmlDeregisterNodeDefaultValue();
    ((void (*)(xmlAttr *))*v8)(cur);
  }
  v9 = cur->type;
  if (v9 <= XML_XINCLUDE_END && ((1 << v9) & 0x180002) != 0)
  {
    psvi = (xmlAttr *)cur->psvi;
    if (psvi)
    {
      do
      {
        next = psvi->next;
        xmlTextReaderFreeProp(a1, psvi);
        psvi = next;
      }
      while (next);
    }
  }
  v12 = *(xmlDtd **)&cur->atype;
  if (v12 == (xmlDtd *)&cur->psvi)
    goto LABEL_34;
  v13 = cur->type;
  if ((v13 > XML_XINCLUDE_END || ((1 << v13) & 0x180022) == 0) && v12 != 0)
  {
    if (v5)
    {
      if (xmlDictOwns(v5, (const xmlChar *)v12))
      {
LABEL_34:
        v13 = cur->type;
        goto LABEL_35;
      }
      v12 = *(xmlDtd **)&cur->atype;
    }
    xmlFree(v12);
    goto LABEL_34;
  }
LABEL_35:
  if (v13 <= XML_XINCLUDE_END && ((1 << v13) & 0x180002) != 0)
  {
    v17 = (xmlNs *)cur[1]._private;
    if (v17)
    {
      xmlFreeNsList(v17);
      v13 = cur->type;
    }
  }
  if (v13 == XML_TEXT_NODE)
    goto LABEL_49;
  if (v13 == XML_COMMENT_NODE)
    goto LABEL_49;
  name = (xmlChar *)cur->name;
  if (!name)
    goto LABEL_49;
  if (!v5)
    goto LABEL_47;
  if (!xmlDictOwns(v5, name))
  {
    name = (xmlChar *)cur->name;
LABEL_47:
    xmlFree(name);
  }
  v13 = cur->type;
LABEL_49:
  if ((v13 | 2) == 3 && (v19 = *(_QWORD *)(a1 + 32)) != 0 && (v20 = *(_DWORD *)(v19 + 572), v20 <= 99))
  {
    cur->next = *(_xmlAttr **)(v19 + 576);
    *(_QWORD *)(v19 + 576) = cur;
    *(_DWORD *)(v19 + 572) = v20 + 1;
  }
  else
  {
    xmlFree(cur);
  }
}

void xmlTextReaderFreeProp(uint64_t a1, xmlAttrPtr attr)
{
  uint64_t v4;
  xmlDict *v5;
  xmlDeregisterNodeFunc *v6;
  _xmlNode *parent;
  xmlDoc *doc;
  _xmlDoc *v9;
  xmlHashTable *ids;
  xmlChar *String;
  xmlChar *v12;
  _QWORD *v13;
  const xmlChar *name;
  _xmlNode *v15;
  xmlDoc *v16;
  _xmlDoc *v17;
  xmlHashTable *refs;
  xmlChar *v19;
  xmlChar *v20;
  xmlList *v21;
  _xmlNode *children;
  xmlChar *v23;
  uint64_t v24;
  int v25;

  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
    v5 = *(xmlDict **)(v4 + 456);
  else
    v5 = 0;
  if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
  {
    v6 = __xmlDeregisterNodeDefaultValue();
    ((void (*)(xmlAttrPtr))*v6)(attr);
  }
  parent = attr->parent;
  if (parent)
  {
    doc = parent->doc;
    if (doc)
    {
      if (xmlIsID(doc, parent, attr))
      {
        v9 = attr->parent->doc;
        if (v9)
        {
          ids = (xmlHashTable *)v9->ids;
          if (ids)
          {
            String = xmlNodeListGetString(v9, attr->children, 1);
            if (String)
            {
              v12 = String;
              v13 = xmlHashLookup(ids, String);
              xmlFree(v12);
              if (v13)
              {
                if ((xmlAttrPtr)v13[2] == attr)
                {
                  name = attr->name;
                  attr->name = 0;
                  v13[2] = 0;
                  v13[3] = name;
                }
              }
            }
          }
        }
      }
      v15 = attr->parent;
      v16 = v15->doc;
      if (v16->intSubset || v16->extSubset)
      {
        if (xmlIsRef(v16, v15, attr))
        {
          v17 = attr->parent->doc;
          if (v17)
          {
            refs = (xmlHashTable *)v17->refs;
            if (refs)
            {
              v19 = xmlNodeListGetString(v17, attr->children, 1);
              if (v19)
              {
                v20 = v19;
                v21 = (xmlList *)xmlHashLookup(refs, v19);
                xmlFree(v20);
                if (v21)
                  xmlListWalk(v21, (xmlListWalker)xmlTextReaderWalkRemoveRef, attr);
              }
            }
          }
        }
      }
    }
  }
  children = attr->children;
  if (children)
    xmlTextReaderFreeNodeList(a1, (xmlNsPtr)children);
  v23 = (xmlChar *)attr->name;
  if (v23)
  {
    if (!v5)
    {
LABEL_30:
      xmlFree(v23);
      goto LABEL_31;
    }
    if (!xmlDictOwns(v5, v23))
    {
      v23 = (xmlChar *)attr->name;
      goto LABEL_30;
    }
  }
LABEL_31:
  v24 = *(_QWORD *)(a1 + 32);
  if (v24 && (v25 = *(_DWORD *)(v24 + 584), v25 <= 99))
  {
    attr->next = *(_xmlAttr **)(v24 + 592);
    *(_QWORD *)(v24 + 592) = attr;
    *(_DWORD *)(v24 + 584) = v25 + 1;
  }
  else
  {
    xmlFree(attr);
  }
}

void xmlFreeDoc(xmlDocPtr cur)
{
  _xmlDict *dict;
  xmlDeregisterNodeFunc *v3;
  xmlIDTable *ids;
  xmlRefTable *refs;
  _xmlDtd *intSubset;
  _xmlDtd *extSubset;
  xmlNode *children;
  _xmlNs *oldNs;
  xmlChar *version;
  char *name;
  xmlChar *encoding;
  xmlChar *URL;

  if (cur)
  {
    dict = cur->dict;
    if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
    {
      v3 = __xmlDeregisterNodeDefaultValue();
      ((void (*)(xmlDocPtr))*v3)(cur);
    }
    ids = (xmlIDTable *)cur->ids;
    if (ids)
      xmlFreeIDTable(ids);
    cur->ids = 0;
    refs = (xmlRefTable *)cur->refs;
    if (refs)
      xmlFreeRefTable(refs);
    cur->refs = 0;
    intSubset = cur->intSubset;
    extSubset = cur->extSubset;
    if (extSubset && intSubset != extSubset)
    {
      xmlUnlinkNode((xmlNodePtr)cur->extSubset);
      cur->extSubset = 0;
      xmlFreeDtd(extSubset);
    }
    if (intSubset)
    {
      xmlUnlinkNode((xmlNodePtr)cur->intSubset);
      cur->intSubset = 0;
      xmlFreeDtd(intSubset);
    }
    children = cur->children;
    if (children)
      xmlFreeNodeList(children);
    oldNs = cur->oldNs;
    if (oldNs)
      xmlFreeNsList(oldNs);
    version = (xmlChar *)cur->version;
    if (version)
    {
      if (dict)
      {
        if (xmlDictOwns(dict, version))
          goto LABEL_23;
        version = (xmlChar *)cur->version;
      }
      xmlFree(version);
    }
LABEL_23:
    name = cur->name;
    if (!name)
      goto LABEL_28;
    if (dict)
    {
      if (xmlDictOwns(dict, (const xmlChar *)name))
        goto LABEL_28;
      name = cur->name;
    }
    xmlFree(name);
LABEL_28:
    encoding = (xmlChar *)cur->encoding;
    if (!encoding)
      goto LABEL_33;
    if (dict)
    {
      if (xmlDictOwns(dict, encoding))
        goto LABEL_33;
      encoding = (xmlChar *)cur->encoding;
    }
    xmlFree(encoding);
LABEL_33:
    URL = (xmlChar *)cur->URL;
    if (URL)
    {
      if (dict)
      {
        if (xmlDictOwns(dict, URL))
        {
          xmlFree(cur);
LABEL_40:
          xmlDictFree(dict);
          return;
        }
        URL = (xmlChar *)cur->URL;
      }
      xmlFree(URL);
    }
    xmlFree(cur);
    if (!dict)
      return;
    goto LABEL_40;
  }
}

void xmlFreeProp(xmlAttrPtr cur)
{
  _xmlDoc *doc;
  xmlDict *dict;
  xmlDeregisterNodeFunc *v4;
  _xmlDoc *v5;
  xmlNode *children;
  xmlChar *name;

  if (cur)
  {
    doc = cur->doc;
    if (doc)
      dict = doc->dict;
    else
      dict = 0;
    if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
    {
      v4 = __xmlDeregisterNodeDefaultValue();
      ((void (*)(xmlAttrPtr))*v4)(cur);
    }
    v5 = cur->doc;
    if (v5 && cur->atype == XML_ATTRIBUTE_ID)
      xmlRemoveID(v5, cur);
    children = cur->children;
    if (children)
      xmlFreeNodeList(children);
    name = (xmlChar *)cur->name;
    if (!name)
      goto LABEL_19;
    if (dict)
    {
      if (xmlDictOwns(dict, name))
      {
LABEL_19:
        xmlFree(cur);
        return;
      }
      name = (xmlChar *)cur->name;
    }
    xmlFree(name);
    goto LABEL_19;
  }
}

void xmlFreeNodeList(xmlNodePtr cur)
{
  xmlNodePtr next;
  _xmlDoc *doc;
  uint64_t v3;
  _DWORD *v4;
  _xmlNode *children;
  xmlNodePtr v6;
  unsigned int type;
  BOOL v8;
  int v9;
  xmlNode *parent;
  unsigned int v12;
  xmlDeregisterNodeFunc *v14;
  xmlAttr *properties;
  _DWORD *v16;
  _xmlAttr *v17;
  int v19;
  xmlNs *nsDef;
  xmlChar *name;
  xmlElementType v23;
  _xmlAttr **content;
  xmlDict *dict;

  if (cur)
  {
    next = cur;
    if (cur->type == XML_NAMESPACE_DECL)
    {
      xmlFreeNsList((xmlNsPtr)cur);
      return;
    }
    doc = cur->doc;
    if (doc)
      dict = doc->dict;
    else
      dict = 0;
    v3 = 0;
    v4 = &unk_1EEEB9000;
    while (1)
    {
      children = next->children;
      if (children)
      {
        while (1)
        {
          v6 = children;
          type = next->type;
          v8 = type > 0x15;
          v9 = (1 << type) & 0x206220;
          if (!v8 && v9 != 0)
            break;
          ++v3;
          children = v6->children;
          next = v6;
          if (!children)
            goto LABEL_17;
        }
      }
      v6 = next;
LABEL_17:
      parent = v6->parent;
      next = v6->next;
      v12 = v6->type;
      if ((int)v12 > 13)
      {
        if (v12 == 14)
          goto LABEL_54;
        if (v12 != 21)
          goto LABEL_26;
      }
      else if (v12 != 9 && v12 != 13)
      {
LABEL_26:
        if (v4[924])
        {
          if (*__xmlDeregisterNodeDefaultValue())
          {
            v14 = __xmlDeregisterNodeDefaultValue();
            ((void (*)(xmlNodePtr))*v14)(v6);
          }
          v12 = v6->type;
        }
        if (v12 <= 0x14 && ((1 << v12) & 0x180002) != 0)
        {
          properties = v6->properties;
          if (properties)
          {
            v16 = v4;
            do
            {
              v17 = properties->next;
              xmlFreeProp(properties);
              properties = v17;
            }
            while (v17);
            v12 = v6->type;
            v4 = v16;
          }
        }
        if (v12 <= 0x14 && ((1 << v12) & 0x180022) != 0)
        {
LABEL_40:
          v8 = v12 > 0x14;
          v19 = (1 << v12) & 0x180002;
          if (!v8 && v19 != 0)
          {
            nsDef = v6->nsDef;
            if (nsDef)
              xmlFreeNsList(nsDef);
          }
          name = (xmlChar *)v6->name;
          if (name)
          {
            v23 = v6->type;
            if (v23 != XML_TEXT_NODE && v23 != XML_COMMENT_NODE)
            {
              if (!dict)
                goto LABEL_52;
              if (!xmlDictOwns(dict, name))
              {
                name = (xmlChar *)v6->name;
LABEL_52:
                xmlFree(name);
              }
            }
          }
          xmlFree(v6);
          goto LABEL_54;
        }
        content = (_xmlAttr **)v6->content;
        if (content != &v6->properties && content != 0)
        {
          if (!dict)
            goto LABEL_65;
          if (!xmlDictOwns(dict, (const xmlChar *)content))
          {
            content = (_xmlAttr **)v6->content;
LABEL_65:
            xmlFree(content);
          }
        }
        v12 = v6->type;
        goto LABEL_40;
      }
      xmlFreeDoc((xmlDocPtr)v6);
LABEL_54:
      if (!next)
      {
        if (!v3 || !parent)
          return;
        --v3;
        parent->children = 0;
        next = parent;
      }
    }
  }
}

int xmlDictOwns(xmlDictPtr dict, const xmlChar *str)
{
  _QWORD *v2;

  if (str)
  {
    while (dict)
    {
      v2 = (_QWORD *)*((_QWORD *)dict + 4);
      if (v2)
      {
        while (v2 + 5 > (_QWORD *)str || v2[1] < (unint64_t)str)
        {
          v2 = (_QWORD *)*v2;
          if (!v2)
            goto LABEL_7;
        }
        LODWORD(dict) = 1;
        return (int)dict;
      }
LABEL_7:
      dict = (xmlDictPtr)*((_QWORD *)dict + 5);
      if (!dict)
        return (int)dict;
    }
  }
  LODWORD(dict) = -1;
  return (int)dict;
}

void xmlTextReaderFreeNodeList(uint64_t a1, xmlDoc *cur)
{
  xmlNsPtr v2;
  uint64_t v4;
  xmlDict *v5;
  xmlNsType type;
  xmlNsType v8;
  const xmlChar *prefix;
  _xmlNs *next;
  xmlNs *context;
  xmlDeregisterNodeFunc *v13;
  unsigned int v14;
  BOOL v15;
  int v16;
  xmlAttr *v18;
  _xmlAttr *v19;
  xmlChar *v20;
  unsigned int v21;
  BOOL v22;
  xmlNs *v25;
  xmlChar *href;
  uint64_t v27;
  int v28;
  uint64_t v29;

  v2 = (xmlNsPtr)cur;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
    v5 = *(xmlDict **)(v4 + 456);
  else
    v5 = 0;
  type = cur->type;
  if (type == XML_DOCUMENT_NODE || type == XML_HTML_DOCUMENT_NODE)
  {
    xmlFreeDoc(cur);
    return;
  }
  if (type != XML_NAMESPACE_DECL)
  {
    v29 = 0;
    while (1)
    {
      while (1)
      {
        v8 = v2->type;
        if (v8 == XML_ENTITY_REF_NODE || v8 == XML_DTD_NODE)
          break;
        prefix = v2->prefix;
        if (!prefix || *((xmlNsPtr *)prefix + 5) != v2)
          break;
        ++v29;
        v2 = (xmlNsPtr)v2->prefix;
      }
      context = (xmlNs *)v2->context;
      next = v2[1].next;
      if (v8 == XML_DTD_NODE)
        goto LABEL_61;
      if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
      {
        v13 = __xmlDeregisterNodeDefaultValue();
        ((void (*)(xmlNsPtr))*v13)(v2);
      }
      v14 = v2->type;
      v15 = v14 > 0x14;
      v16 = (1 << v14) & 0x180002;
      if (!v15 && v16 != 0)
      {
        v18 = (xmlAttr *)v2[1].context;
        if (v18)
        {
          do
          {
            v19 = v18->next;
            xmlTextReaderFreeProp(a1, v18);
            v18 = v19;
          }
          while (v19);
        }
      }
      v20 = (xmlChar *)v2[1]._private;
      if (v20 == (xmlChar *)&v2[1].context)
        goto LABEL_41;
      v21 = v2->type;
      v22 = v21 > 0x14 || ((1 << v21) & 0x180022) == 0;
      if (v22 && v20 != 0)
        break;
LABEL_42:
      if (v21 <= 0x14 && ((1 << v21) & 0x180002) != 0)
      {
        v25 = v2[2].next;
        if (v25)
        {
          xmlFreeNsList(v25);
          v21 = v2->type;
        }
      }
      if (v21 == 3)
        goto LABEL_56;
      if (v21 == 8)
        goto LABEL_56;
      href = (xmlChar *)v2->href;
      if (!href)
        goto LABEL_56;
      if (!v5)
        goto LABEL_54;
      if (!xmlDictOwns(v5, href))
      {
        href = (xmlChar *)v2->href;
LABEL_54:
        xmlFree(href);
      }
      v21 = v2->type;
LABEL_56:
      if ((v21 | 2) == 3 && (v27 = *(_QWORD *)(a1 + 32)) != 0 && (v28 = *(_DWORD *)(v27 + 572), v28 <= 99))
      {
        v2[1].next = *(_xmlNs **)(v27 + 576);
        *(_QWORD *)(v27 + 576) = v2;
        *(_DWORD *)(v27 + 572) = v28 + 1;
      }
      else
      {
        xmlFree(v2);
      }
LABEL_61:
      v2 = next;
      if (!next)
      {
        if (!v29 || !context)
          return;
        --v29;
        context->prefix = 0;
        v2 = context;
      }
    }
    if (v5)
    {
      if (xmlDictOwns(v5, v20))
      {
LABEL_41:
        v21 = v2->type;
        goto LABEL_42;
      }
      v20 = (xmlChar *)v2[1]._private;
    }
    xmlFree(v20);
    goto LABEL_41;
  }
  xmlFreeNsList((xmlNsPtr)cur);
}

void xmlUnlinkNode(xmlNodePtr cur)
{
  xmlElementType type;
  _xmlDoc *v3;
  _xmlDoc *doc;
  _xmlDtd *intSubset;
  _xmlDtd *extSubset;
  _xmlNode *parent;
  _QWORD *p_properties;
  xmlNode *properties;
  _xmlNode **p_next;
  xmlNode *last;
  _xmlNode *next;
  _xmlNode *prev;

  if (!cur)
    return;
  type = cur->type;
  switch(type)
  {
    case XML_NAMESPACE_DECL:
      return;
    case XML_ENTITY_DECL:
      doc = cur->doc;
      if (doc)
      {
        intSubset = doc->intSubset;
        if (intSubset)
        {
          if (xmlHashLookup((xmlHashTablePtr)intSubset->entities, cur->name) == cur)
            xmlHashRemoveEntry((xmlHashTablePtr)doc->intSubset->entities, cur->name, 0);
          if (xmlHashLookup((xmlHashTablePtr)doc->intSubset->pentities, cur->name) == cur)
            xmlHashRemoveEntry((xmlHashTablePtr)doc->intSubset->pentities, cur->name, 0);
        }
        extSubset = doc->extSubset;
        if (extSubset)
        {
          if (xmlHashLookup((xmlHashTablePtr)extSubset->entities, cur->name) == cur)
            xmlHashRemoveEntry((xmlHashTablePtr)doc->extSubset->entities, cur->name, 0);
          if (xmlHashLookup((xmlHashTablePtr)doc->extSubset->pentities, cur->name) == cur)
            xmlHashRemoveEntry((xmlHashTablePtr)doc->extSubset->pentities, cur->name, 0);
        }
      }
      break;
    case XML_DTD_NODE:
      v3 = cur->doc;
      if (v3)
      {
        if ((xmlNodePtr)v3->intSubset == cur)
          v3->intSubset = 0;
        if ((xmlNodePtr)v3->extSubset == cur)
          v3->extSubset = 0;
      }
      break;
  }
  parent = cur->parent;
  if (parent)
  {
    if (cur->type == XML_ATTRIBUTE_NODE)
    {
      properties = (xmlNode *)parent->properties;
      p_properties = &parent->properties;
      if (properties != cur)
      {
LABEL_30:
        cur->parent = 0;
        goto LABEL_31;
      }
      p_next = &cur->next;
    }
    else
    {
      if (parent->children == cur)
        parent->children = cur->next;
      last = parent->last;
      p_properties = &parent->last;
      if (last != cur)
        goto LABEL_30;
      p_next = &cur->prev;
    }
    *p_properties = *p_next;
    goto LABEL_30;
  }
LABEL_31:
  next = cur->next;
  if (next)
    next->prev = cur->prev;
  prev = cur->prev;
  if (prev)
    prev->next = next;
  cur->next = 0;
  cur->prev = 0;
}

void xmlFreeNsList(xmlNsPtr cur)
{
  xmlNsPtr v1;
  _xmlNs *next;
  xmlChar *href;
  xmlChar *prefix;

  if (cur)
  {
    v1 = cur;
    do
    {
      next = v1->next;
      href = (xmlChar *)v1->href;
      if (href)
        xmlFree(href);
      prefix = (xmlChar *)v1->prefix;
      if (prefix)
        xmlFree(prefix);
      xmlFree(v1);
      v1 = next;
    }
    while (next);
  }
}

xmlNodePtr xmlTextReaderExpand(xmlNodePtr reader)
{
  xmlNodePtr v1;

  if (reader)
  {
    v1 = reader;
    reader = *(xmlNodePtr *)&reader->line;
    if (reader)
    {
      if (!*(_QWORD *)&v1->type)
      {
        if (!v1->last || (xmlTextReaderDoExpand((uint64_t)v1) & 0x80000000) != 0)
          return 0;
        else
          return *(xmlNodePtr *)&v1->line;
      }
    }
  }
  return reader;
}

int xmlPatternMatch(xmlPatternPtr comp, xmlNodePtr node)
{
  int result;
  xmlNodePtr v4;
  int v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int type;
  BOOL v12;
  int v13;
  const xmlChar *v15;
  const xmlChar *v16;
  xmlNs *v17;
  const xmlChar *href;
  const xmlChar *v19;
  unsigned int v20;
  unint64_t v21;
  int v22;
  uint64_t v24;
  const xmlChar **v25;
  uint64_t v26;
  _xmlNode *children;
  const xmlChar *name;
  const xmlChar *v29;
  const xmlChar *v30;
  xmlNs *ns;
  unsigned int v32;
  int v33;
  unsigned int v35;
  const xmlChar *v36;
  const xmlChar *v37;
  xmlNs *v38;
  const xmlChar *v39;
  const xmlChar *v40;
  _BOOL4 v41;
  char *v42;
  xmlNs *v43;
  BOOL v44;
  char *v45;
  char *v46;
  int v47;

  result = -1;
  if (!comp)
    return result;
  v4 = node;
  if (!node)
    return result;
  while (2)
  {
    if (*((int *)comp + 9) < 1)
      return 1;
    v5 = 0;
    v47 = 0;
    v6 = 0;
    LODWORD(v7) = 0;
LABEL_5:
    v8 = *((_QWORD *)comp + 6);
    v9 = v8 + 24 * (int)v7;
    v10 = (int)v7;
    switch(*(_DWORD *)v9)
    {
      case 0:
        goto LABEL_94;
      case 1:
        if (v4->type != XML_NAMESPACE_DECL)
        {
          v4 = v4->parent;
          type = v4->type;
          v12 = type > 0x15;
          v13 = (1 << type) & 0x202200;
          if (!v12 && v13 != 0)
            goto LABEL_89;
        }
        goto LABEL_71;
      case 2:
        if (v4->type == XML_ELEMENT_NODE)
          goto LABEL_13;
        goto LABEL_71;
      case 3:
        HIDWORD(v21) = v4->type - 1;
        LODWORD(v21) = HIDWORD(v21);
        v20 = v21 >> 2;
        v12 = v20 > 5;
        v22 = (1 << v20) & 0x2D;
        if (v12 || v22 == 0)
          goto LABEL_71;
        v24 = v8 + 24 * (int)v7;
        v26 = *(_QWORD *)(v24 + 8);
        v25 = (const xmlChar **)(v24 + 8);
        if (!v26)
          goto LABEL_71;
        children = v4->children;
        if (!children)
          goto LABEL_71;
        while (1)
        {
          if (children->type == XML_ELEMENT_NODE)
          {
            name = children->name;
            if (**v25 == *name)
            {
              if (xmlStrEqual(*v25, name))
                goto LABEL_89;
            }
          }
          children = children->next;
          if (!children)
            goto LABEL_71;
        }
      case 4:
        if (v4->type != XML_ATTRIBUTE_NODE)
          goto LABEL_71;
        v29 = *(const xmlChar **)(v8 + 24 * (int)v7 + 8);
        if (v29)
        {
          v30 = v4->name;
          if (*v29 != *v30 || !xmlStrEqual(v29, v30))
            goto LABEL_71;
        }
        ns = v4->ns;
        v19 = *(const xmlChar **)(v8 + 24 * (int)v7 + 16);
        if (ns)
        {
          if (!v19)
            goto LABEL_89;
          href = ns->href;
LABEL_68:
          if (xmlStrEqual(v19, href))
            goto LABEL_89;
          goto LABEL_71;
        }
        if (v19)
          goto LABEL_71;
        goto LABEL_89;
      case 5:
        v32 = v4->type;
        v12 = v32 > 0x15;
        v33 = (1 << v32) & 0x242200;
        if (!v12 && v33 != 0)
          goto LABEL_71;
        v4 = v4->parent;
        if (!v4)
          goto LABEL_71;
LABEL_13:
        v15 = *(const xmlChar **)(v8 + 24 * (int)v7 + 8);
        if (!v15)
          goto LABEL_89;
        v16 = v4->name;
        if (*v15 != *v16 || !xmlStrEqual(v15, v16))
          goto LABEL_71;
        v17 = v4->ns;
        if (v17)
        {
          href = v17->href;
          if (!href)
            goto LABEL_89;
          v19 = *(const xmlChar **)(v8 + 24 * (int)v7 + 16);
          if (!v19)
            goto LABEL_71;
          goto LABEL_68;
        }
        if (*(_QWORD *)(v8 + 24 * (int)v7 + 16))
          goto LABEL_71;
        goto LABEL_89;
      case 6:
        if (!*(_QWORD *)(v8 + 24 * (int)v7 + 8))
        {
          v7 = (int)v7 + 1;
          v9 = v8 + 24 * (v10 + 1);
          if (*(_DWORD *)v9 != 2)
          {
            if (*(_DWORD *)v9 == 1)
              goto LABEL_94;
            goto LABEL_71;
          }
          if (!*(_QWORD *)(v8 + 24 * v7 + 8))
            return -1;
          if (v4)
            goto LABEL_47;
LABEL_71:
          if (!v6)
            goto LABEL_92;
          v44 = __OFSUB__(v5--, 1);
          if (v5 < 0 != v44)
          {
            xmlFree(v6);
LABEL_92:
            comp = (xmlPatternPtr)*((_QWORD *)comp + 2);
            v4 = node;
            if (!comp)
              return 0;
            continue;
          }
          v45 = &v6[16 * v5];
          LODWORD(v7) = *(_DWORD *)v45;
          v4 = (xmlNodePtr)*((_QWORD *)v45 + 1);
          if (*(_DWORD *)v45 >= *((_DWORD *)comp + 9))
            goto LABEL_95;
          goto LABEL_5;
        }
        if (!v4)
          goto LABEL_71;
LABEL_47:
        v35 = v4->type;
        if (v35 <= 0x15 && ((1 << v35) & 0x242200) != 0)
          goto LABEL_71;
        while (1)
        {
          while (1)
          {
            while (1)
            {
              v4 = v4->parent;
              if (!v4)
                goto LABEL_71;
              if (v4->type == XML_ELEMENT_NODE)
              {
                v36 = *(const xmlChar **)(v9 + 8);
                v37 = v4->name;
                if (*v36 == *v37)
                {
                  if (xmlStrEqual(v36, v37))
                    break;
                }
              }
            }
            v38 = v4->ns;
            if (v38)
              break;
            if (!*(_QWORD *)(v9 + 16))
              goto LABEL_59;
          }
          v39 = v38->href;
          if (v39)
          {
            v40 = *(const xmlChar **)(v9 + 16);
            if (v40)
            {
              if (xmlStrEqual(v40, v39))
                break;
            }
          }
        }
LABEL_59:
        v41 = *(_DWORD *)v9 != 6;
        if (v6 && v47 > 0)
        {
          if (v47 <= v5)
          {
            v42 = (char *)xmlRealloc(v6, 16 * (2 * v47));
            if (!v42)
              goto LABEL_89;
            v47 *= 2;
            v6 = v42;
          }
        }
        else
        {
          v6 = (char *)xmlMalloc(0x40uLL);
          v5 = 0;
          v47 = 4;
        }
        v46 = &v6[16 * v5];
        *(_DWORD *)v46 = v7 - v41;
        ++v5;
        *((_QWORD *)v46 + 1) = v4;
LABEL_89:
        LODWORD(v7) = v7 + 1;
        if ((int)v7 < *((_DWORD *)comp + 9))
          goto LABEL_5;
LABEL_94:
        if (v6)
LABEL_95:
          xmlFree(v6);
        return 1;
      case 7:
        if (v4->type != XML_ELEMENT_NODE)
          goto LABEL_71;
        v43 = v4->ns;
        if (v43)
        {
          href = v43->href;
          if (!href)
            goto LABEL_89;
          v19 = *(const xmlChar **)(v8 + 24 * (int)v7 + 8);
          if (!v19)
            goto LABEL_71;
          goto LABEL_68;
        }
        if (*(_QWORD *)(v8 + 24 * (int)v7 + 8))
          goto LABEL_71;
        goto LABEL_89;
      case 8:
        if (v4->type != XML_ELEMENT_NODE)
          goto LABEL_71;
        goto LABEL_89;
      default:
        goto LABEL_89;
    }
  }
}

void xmlNodeDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, int level, int format, const char *encoding)
{
  const char *v12;
  xmlDtdPtr IntSubset;
  __int128 v14;
  uint64_t v15;
  const char *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  xmlInitParser();
  if (buf && cur)
  {
    v12 = "UTF-8";
    v17 = 0u;
    v18 = 0u;
    if (encoding)
      v12 = encoding;
    v24 = 0;
    v22 = 0uLL;
    v23 = 0uLL;
    v20 = 0uLL;
    v21 = 0uLL;
    v19 = 0uLL;
    v14 = 0uLL;
    v15 = 0;
    *((_QWORD *)&v17 + 1) = buf;
    DWORD1(v18) = level;
    DWORD2(v18) = format != 0;
    v16 = v12;
    xmlSaveCtxtInit((int *)&v14);
    LODWORD(v18) = v18 | 0x20;
    IntSubset = xmlGetIntSubset(doc);
    if (IntSubset && xmlIsXHTML(IntSubset->SystemID, IntSubset->ExternalID) >= 1)
      xhtmlNodeDumpOutput((uint64_t)&v14, (uint64_t)cur);
    else
      xmlNodeDumpOutputInternal((uint64_t)&v14, (uint64_t)cur);
  }
}

void htmlParseContentInternal(uint64_t a1)
{
  xmlChar *v2;
  int v3;
  xmlParserInput *v4;
  _BYTE *v5;
  int v6;
  const xmlChar *v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  _BYTE *v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int v14;
  int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  const xmlChar *v18;
  _BYTE *v19;
  uint64_t v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  void (*v26)(_QWORD, const xmlChar *);
  int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  xmlParserInput *v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v2 = xmlStrdup(*(const xmlChar **)(a1 + 288));
  v3 = *(_DWORD *)(a1 + 296);
  while (1)
  {
    if (!*(_DWORD *)(a1 + 452))
    {
      v4 = *(xmlParserInput **)(a1 + 56);
      if (v4->end - v4->cur <= 249)
        xmlParserInputGrow(v4, 250);
    }
    if (*(_DWORD *)(a1 + 272) == -1)
      break;
    v5 = *(_BYTE **)(*(_QWORD *)(a1 + 56) + 32);
    if (*v5 != 60)
      goto LABEL_15;
    v6 = v5[1];
    if (v6 == 47)
    {
      if (htmlParseEndTag((xmlParserCtxt *)a1))
      {
        if (v2)
          goto LABEL_32;
        if (!*(_DWORD *)(a1 + 296))
        {
LABEL_33:
          v2 = xmlStrdup(*(const xmlChar **)(a1 + 288));
          v3 = *(_DWORD *)(a1 + 296);
        }
      }
    }
    else
    {
      if ((v6 & 0xFFFFFFDF) - 65 >= 0x1A && v6 != 95 && v6 != 58)
        goto LABEL_15;
      v7 = htmlParseHTMLName_nonInvasive(a1);
      if (!v7)
      {
        htmlParseErr((_DWORD *)a1, 68, "htmlParseStartTag: invalid element name\n", 0, 0);
        while (!**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32))
          xmlNextChar((xmlParserCtxtPtr)a1);
LABEL_31:
        htmlParserFinishElementParsing((xmlParserCtxtPtr)a1);
        if (!v2)
          goto LABEL_33;
LABEL_32:
        xmlFree(v2);
        goto LABEL_33;
      }
      if (*(_QWORD *)(a1 + 288)
        && (v8 = (uint64_t)v7,
            *(_QWORD *)&v33 = *(_QWORD *)(a1 + 288),
            *((_QWORD *)&v33 + 1) = v7,
            bsearch(&v33, htmlStartClose, 0xFBuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))htmlCompareStartClose)))
      {
        htmlAutoClose((int *)a1, v8);
      }
      else
      {
LABEL_15:
        v9 = *(_DWORD *)(a1 + 296);
        v10 = v9 < 1 || v3 < v9;
        if (!v10 && !xmlStrEqual(v2, *(const xmlChar **)(a1 + 288)))
          goto LABEL_31;
        if (**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32))
        {
          if (xmlStrEqual(v2, (const xmlChar *)"script") || xmlStrEqual(v2, (const xmlChar *)"style"))
          {
            htmlParseScript(a1);
            goto LABEL_93;
          }
          v11 = *(_BYTE **)(*(_QWORD *)(a1 + 56) + 32);
          if (*v11 == 60
            && v11[1] == 33
            && __toupper(v11[2]) == 68
            && __toupper(v11[3]) == 79
            && __toupper(v11[4]) == 67
            && __toupper(v11[5]) == 84
            && __toupper(v11[6]) == 89
            && __toupper(v11[7]) == 80
            && __toupper(v11[8]) == 69)
          {
            htmlParseErr((_DWORD *)a1, 800, "Misplaced DOCTYPE declaration\n", (const xmlChar *)"DOCTYPE", 0);
            htmlParseDocTypeDecl((xmlParserCtxt *)a1);
          }
        }
        v12 = *(_QWORD *)(a1 + 56);
        v13 = *(unsigned __int8 **)(v12 + 32);
        v14 = *v13;
        if (v14 == 38)
        {
          htmlParseReference(a1);
        }
        else if (v14 == 60)
        {
          v15 = v13[1];
          if (v15 == 63)
          {
            htmlParsePI(a1);
          }
          else
          {
            if (v15 != 33 || v13[2] != 45 || v13[3] != 45)
            {
              v35 = 0;
              v33 = 0u;
              v34 = 0u;
              if (*(_DWORD *)(a1 + 272) == -1)
                goto LABEL_90;
              if (*(_DWORD *)(a1 + 104))
              {
                v16 = &v13[*(_QWORD *)(v12 + 64) - *(_QWORD *)(v12 + 24)];
                v17 = *(int *)(v12 + 52);
                *((_QWORD *)&v33 + 1) = v16;
                *(_QWORD *)&v34 = v17;
              }
              if (htmlParseStartTag(a1) == -1 || (v18 = *(const xmlChar **)(a1 + 288)) == 0)
              {
                if (**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32) != 62)
                  goto LABEL_90;
                xmlNextChar((xmlParserCtxtPtr)a1);
                if (v2)
                  goto LABEL_91;
              }
              else
              {
                v19 = bsearch(*(const void **)(a1 + 288), &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
                if (!v19)
                  htmlParseErr((_DWORD *)a1, 801, "Tag %s invalid\n", v18, 0);
                v20 = *(_QWORD *)(a1 + 56);
                v21 = *(unsigned __int8 **)(v20 + 32);
                v22 = *v21;
                if (v22 == 62)
                {
                  xmlNextChar((xmlParserCtxtPtr)a1);
                  if (v19 && v19[11])
                  {
LABEL_76:
                    if (*(_QWORD *)a1)
                    {
                      v26 = *(void (**)(_QWORD, const xmlChar *))(*(_QWORD *)a1 + 120);
                      if (v26)
                        v26(*(_QWORD *)(a1 + 8), v18);
                    }
                    v27 = *(_DWORD *)(a1 + 296);
                    v28 = v27 - 1;
                    if (v27 < 1)
                      goto LABEL_90;
                    *(_DWORD *)(a1 + 296) = v28;
                    v29 = *(_QWORD *)(a1 + 304);
                    if (v27 == 1)
                      v32 = 0;
                    else
                      v32 = *(_QWORD *)(v29 + 8 * (v27 - 2));
                    *(_QWORD *)(a1 + 288) = v32;
                    *(_QWORD *)(v29 + 8 * v28) = 0;
                    if (v2)
LABEL_91:
                      xmlFree(v2);
                  }
                  else
                  {
                    if (!*(_DWORD *)(a1 + 104))
                      goto LABEL_90;
                    htmlNodeInfoPush(a1, &v33);
                    if (v2)
                      goto LABEL_91;
                  }
                }
                else
                {
                  if (v22 == 47 && v21[1] == 62)
                  {
                    *(_QWORD *)(v20 + 32) = v21 + 2;
                    *(_DWORD *)(v20 + 56) += 2;
                    goto LABEL_76;
                  }
                  htmlParseErr((_DWORD *)a1, 73, "Couldn't find end of Start Tag %s\n", v18, 0);
                  if (xmlStrEqual(v18, *(const xmlChar **)(a1 + 288)))
                  {
                    nodePop((xmlParserCtxtPtr)a1);
                    v23 = *(_DWORD *)(a1 + 296);
                    v24 = v23 - 1;
                    if (v23 >= 1)
                    {
                      *(_DWORD *)(a1 + 296) = v24;
                      v25 = *(_QWORD *)(a1 + 304);
                      if (v23 == 1)
                        v30 = 0;
                      else
                        v30 = *(_QWORD *)(v25 + 8 * (v23 - 2));
                      *(_QWORD *)(a1 + 288) = v30;
                      *(_QWORD *)(v25 + 8 * v24) = 0;
                    }
                  }
                  if (*(_DWORD *)(a1 + 104))
                    htmlNodeInfoPush(a1, &v33);
                  htmlParserFinishElementParsing((xmlParserCtxtPtr)a1);
LABEL_90:
                  if (v2)
                    goto LABEL_91;
                }
              }
              v2 = xmlStrdup(*(const xmlChar **)(a1 + 288));
              v3 = *(_DWORD *)(a1 + 296);
              goto LABEL_93;
            }
            htmlParseComment(a1);
          }
        }
        else
        {
          if (!*v13)
          {
            htmlAutoCloseOnEnd(a1);
            break;
          }
          htmlParseCharData(a1);
        }
LABEL_93:
        if (!*(_DWORD *)(a1 + 452))
        {
          v31 = *(xmlParserInput **)(a1 + 56);
          if (v31->end - v31->cur <= 249)
            xmlParserInputGrow(v31, 250);
        }
      }
    }
  }
  if (v2)
    xmlFree(v2);
}

xmlDocPtr xmlDoRead(xmlParserCtxt *a1, const xmlChar *a2, xmlChar *a3, uint64_t a4, int a5)
{
  xmlCharEncodingHandler *CharEncodingHandler;
  xmlParserInputPtr input;
  xmlDocPtr myDoc;
  xmlDoc *v13;

  xmlCtxtUseOptionsInternal((uint64_t *)a1, a4, a3);
  if (a3)
  {
    CharEncodingHandler = xmlFindCharEncodingHandler((const char *)a3);
    if (CharEncodingHandler)
      xmlSwitchToEncoding(a1, CharEncodingHandler);
  }
  if (a2)
  {
    input = a1->input;
    if (input)
    {
      if (!input->filename)
        a1->input->filename = (const char *)xmlStrdup(a2);
    }
  }
  xmlParseDocument(a1);
  if (a1->wellFormed || a1->recovery)
  {
    myDoc = a1->myDoc;
  }
  else
  {
    v13 = a1->myDoc;
    if (v13)
      xmlFreeDoc(v13);
    myDoc = 0;
  }
  a1->myDoc = 0;
  if (!a5)
    xmlFreeParserCtxt(a1);
  return myDoc;
}

uint64_t xmlCtxtUseOptionsInternal(uint64_t *a1, uint64_t a2, xmlChar *cur)
{
  void *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  xmlDict *v15;

  if (a1)
  {
    if (cur)
    {
      v6 = (void *)a1[5];
      if (v6)
        xmlFree(v6);
      a1[5] = (uint64_t)xmlStrdup(cur);
    }
    if ((a2 & 1) != 0)
    {
      a2 = (a2 - 1);
      *((_DWORD *)a1 + 141) |= 1u;
      v7 = 1;
    }
    else
    {
      v7 = 0;
    }
    *((_DWORD *)a1 + 112) = v7;
    if ((a2 & 4) != 0)
    {
      a2 = (a2 - 4);
      *((_DWORD *)a1 + 141) |= 4u;
      v8 = 2;
    }
    else
    {
      v8 = 0;
    }
    *((_DWORD *)a1 + 108) = v8;
    if ((a2 & 8) != 0)
    {
      *((_DWORD *)a1 + 108) = v8 | 4;
      a2 = (a2 - 8);
      *((_DWORD *)a1 + 141) |= 8u;
    }
    if ((a2 & 2) != 0)
    {
      a2 = (a2 - 2);
      *((_DWORD *)a1 + 141) |= 2u;
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
    *((_DWORD *)a1 + 7) = v9;
    if ((a2 & 0x80) != 0)
    {
      a2 = (a2 - 128);
      *((_DWORD *)a1 + 141) |= 0x80u;
      v10 = 1;
    }
    else
    {
      v10 = 0;
    }
    *((_DWORD *)a1 + 105) = v10;
    if ((a2 & 0x100) != 0)
    {
      v11 = 0;
      *(_QWORD *)(*a1 + 144) = xmlSAX2IgnorableWhitespace;
      a2 = (a2 - 256);
      *((_DWORD *)a1 + 141) |= 0x100u;
    }
    else
    {
      v11 = 1;
    }
    *((_DWORD *)a1 + 82) = v11;
    if ((a2 & 0x10) != 0)
    {
      *((_DWORD *)a1 + 39) = 1;
      if ((a2 & 0x40) != 0)
        a1[22] = 0;
      if ((a2 & 0x20) != 0)
        a1[21] = 0;
      a2 = (a2 - 16);
      *((_DWORD *)a1 + 141) |= 0x10u;
      if ((a2 & 0x40) == 0)
      {
LABEL_33:
        if ((a2 & 0x20) != 0)
        {
          v13 = *a1;
          a2 = (a2 - 32);
          *(_QWORD *)(v13 + 176) = 0;
          *(_QWORD *)(v13 + 184) = 0;
          if ((a2 & 0x200) == 0)
          {
LABEL_35:
            if ((a2 & 0x1000) == 0)
            {
LABEL_36:
              v12 = 1;
              goto LABEL_40;
            }
LABEL_39:
            v12 = 0;
            a2 = (a2 - 4096);
            *((_DWORD *)a1 + 141) |= 0x1000u;
LABEL_40:
            *((_DWORD *)a1 + 142) = v12;
            if ((a2 & 0x4000) != 0)
            {
              *(_QWORD *)(*a1 + 200) = 0;
              a2 = (a2 - 0x4000);
              *((_DWORD *)a1 + 141) |= 0x4000u;
              if ((a2 & 0x2000) == 0)
              {
LABEL_42:
                if ((a2 & 0x800) == 0)
                  goto LABEL_43;
                goto LABEL_50;
              }
            }
            else if ((a2 & 0x2000) == 0)
            {
              goto LABEL_42;
            }
            *((_DWORD *)a1 + 141) |= 0x2000u;
            a2 = (a2 - 0x2000);
            if ((a2 & 0x800) == 0)
            {
LABEL_43:
              if ((a2 & 0x10000) == 0)
                goto LABEL_44;
              goto LABEL_51;
            }
LABEL_50:
            *((_DWORD *)a1 + 141) |= 0x800u;
            a2 = (a2 - 2048);
            if ((a2 & 0x10000) == 0)
            {
LABEL_44:
              if ((a2 & 0x20000) == 0)
                goto LABEL_45;
              goto LABEL_52;
            }
LABEL_51:
            *((_DWORD *)a1 + 141) |= 0x10000u;
            a2 = (a2 - 0x10000);
            if ((a2 & 0x20000) == 0)
            {
LABEL_45:
              if ((a2 & 0x40000) == 0)
                goto LABEL_46;
              goto LABEL_53;
            }
LABEL_52:
            *((_DWORD *)a1 + 141) |= 0x20000u;
            a2 = (a2 - 0x20000);
            if ((a2 & 0x40000) == 0)
            {
LABEL_46:
              if ((a2 & 0x80000) == 0)
                goto LABEL_56;
              goto LABEL_54;
            }
LABEL_53:
            *((_DWORD *)a1 + 141) |= 0x40000u;
            a2 = (a2 - 0x40000);
            if ((a2 & 0x80000) == 0)
              goto LABEL_56;
LABEL_54:
            *((_DWORD *)a1 + 141) |= 0x80000u;
            a2 = (a2 - 0x80000);
            v15 = (xmlDict *)a1[57];
            if (v15)
              xmlDictSetLimit(v15, 0);
LABEL_56:
            if ((a2 & 0x100000) != 0)
            {
              *((_DWORD *)a1 + 141) |= 0x100000u;
              a2 = (a2 - 0x100000);
              if ((a2 & 0x200000) == 0)
              {
LABEL_58:
                if ((a2 & 0x400000) == 0)
                {
LABEL_60:
                  *((_DWORD *)a1 + 109) = 1;
                  return a2;
                }
LABEL_59:
                *((_DWORD *)a1 + 141) |= 0x400000u;
                a2 = (a2 - 0x400000);
                goto LABEL_60;
              }
            }
            else if ((a2 & 0x200000) == 0)
            {
              goto LABEL_58;
            }
            *((_DWORD *)a1 + 141) |= 0x200000u;
            a2 = (a2 - 0x200000);
            if ((a2 & 0x400000) == 0)
              goto LABEL_60;
            goto LABEL_59;
          }
        }
        else if ((a2 & 0x200) == 0)
        {
          goto LABEL_35;
        }
        v14 = *a1;
        *(_QWORD *)(v14 + 112) = xmlSAX2StartElement;
        *(_QWORD *)(v14 + 120) = xmlSAX2EndElement;
        *(_QWORD *)(v14 + 232) = 0;
        *(_QWORD *)(v14 + 240) = 0;
        *(_DWORD *)(v14 + 216) = 1;
        a2 = (a2 - 512);
        *((_DWORD *)a1 + 141) |= 0x200u;
        if ((a2 & 0x1000) == 0)
          goto LABEL_36;
        goto LABEL_39;
      }
    }
    else
    {
      *((_DWORD *)a1 + 39) = 0;
      if ((a2 & 0x40) == 0)
        goto LABEL_33;
    }
    *(_QWORD *)(*a1 + 168) = 0;
    a2 = (a2 - 64);
    goto LABEL_33;
  }
  return 0xFFFFFFFFLL;
}

int xmlParseDocument(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  setDocumentLocatorSAXFunc setDocumentLocator;
  void *userData;
  xmlSAXLocator *v5;
  const xmlChar *cur;
  xmlCharEncoding v7;
  xmlParserInputPtr v8;
  const xmlChar *v9;
  int v10;
  unsigned int v11;
  startDocumentSAXFunc startDocument;
  xmlDocPtr myDoc;
  xmlParserInputPtr v14;
  xmlParserInputBufferPtr buf;
  int compressed;
  xmlParserInputPtr v17;
  const xmlChar *v18;
  externalSubsetSAXFunc externalSubset;
  endDocumentSAXFunc endDocument;
  xmlDocPtr v21;
  xmlDocPtr v22;
  int properties;
  int v24;
  int result;
  unsigned __int8 in[4];

  xmlInitParser();
  if (!ctxt)
    return -1;
  input = ctxt->input;
  if (!input)
    return -1;
  if (!ctxt->progressive && input->end - input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  xmlDetectSAX2((const xmlChar *)ctxt);
  if (ctxt->sax)
  {
    setDocumentLocator = ctxt->sax->setDocumentLocator;
    if (setDocumentLocator)
    {
      userData = ctxt->userData;
      v5 = __xmlDefaultSAXLocator();
      ((void (*)(void *, xmlSAXLocator *))setDocumentLocator)(userData, v5);
    }
  }
  if (ctxt->instate == XML_PARSER_EOF)
    return -1;
  *(_DWORD *)in = 0;
  if (!ctxt->encoding)
  {
    cur = ctxt->input->cur;
    if (ctxt->input->end - cur >= 4)
    {
      *(_DWORD *)in = *(_DWORD *)cur;
      v7 = xmlDetectCharEncoding(in, 4);
      if (v7)
        xmlSwitchEncoding(ctxt, v7);
    }
  }
  v8 = ctxt->input;
  v9 = v8->cur;
  v10 = *v9;
  if (!*v9)
  {
    xmlFatalErr(ctxt, 4, 0);
    return -1;
  }
  if (v8->end - v9 <= 34 && !ctxt->progressive)
  {
    xmlGROW((uint64_t)ctxt);
    v9 = ctxt->input->cur;
    v10 = *v9;
  }
  if (v10 == 60
    && v9[1] == 63
    && v9[2] == 120
    && v9[3] == 109
    && v9[4] == 108
    && (v11 = v9[5], v11 <= 0x20)
    && ((1 << v11) & 0x100002600) != 0)
  {
    xmlParseXMLDecl(ctxt);
    if (ctxt->errNo == 32 || ctxt->instate == XML_PARSER_EOF)
      return -1;
    ctxt->standalone = ctxt->input->standalone;
    xmlSkipBlankChars(ctxt);
  }
  else
  {
    ctxt->version = xmlCharStrdup("1.0");
  }
  if (ctxt->sax)
  {
    startDocument = ctxt->sax->startDocument;
    if (startDocument)
    {
      if (!ctxt->disableSAX)
        ((void (*)(void *))startDocument)(ctxt->userData);
    }
  }
  if (ctxt->instate == XML_PARSER_EOF)
    return -1;
  myDoc = ctxt->myDoc;
  if (myDoc)
  {
    v14 = ctxt->input;
    if (v14)
    {
      buf = v14->buf;
      if (buf)
      {
        compressed = buf->compressed;
        if ((compressed & 0x80000000) == 0)
          myDoc->compression = compressed;
      }
    }
  }
  xmlParseMisc(ctxt);
  v17 = ctxt->input;
  if (!ctxt->progressive && v17->end - v17->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    v17 = ctxt->input;
  }
  v18 = v17->cur;
  if (*v18 == 60
    && v18[1] == 33
    && v18[2] == 68
    && v18[3] == 79
    && v18[4] == 67
    && v18[5] == 84
    && v18[6] == 89
    && v18[7] == 80
    && v18[8] == 69)
  {
    ctxt->inSubset = 1;
    xmlParseDocTypeDecl(ctxt);
    if (*ctxt->input->cur == 91)
    {
      ctxt->instate = XML_PARSER_DTD;
      xmlParseInternalSubset((uint64_t)ctxt);
      if (ctxt->instate == XML_PARSER_EOF)
        return -1;
    }
    ctxt->inSubset = 2;
    if (ctxt->sax)
    {
      externalSubset = ctxt->sax->externalSubset;
      if (externalSubset)
      {
        if (!ctxt->disableSAX)
          ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))externalSubset)(ctxt->userData, ctxt->intSubName, ctxt->extSubSystem, ctxt->extSubURI);
      }
    }
    if (ctxt->instate == XML_PARSER_EOF)
      return -1;
    ctxt->inSubset = 0;
    xmlCleanSpecialAttr(ctxt);
    ctxt->instate = XML_PARSER_PROLOG;
    xmlParseMisc(ctxt);
    v17 = ctxt->input;
  }
  if (!ctxt->progressive && v17->end - v17->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    v17 = ctxt->input;
  }
  if (*v17->cur == 60)
  {
    ctxt->instate = XML_PARSER_CONTENT;
    xmlParseElement(ctxt);
    ctxt->instate = XML_PARSER_EPILOG;
    xmlParseMisc(ctxt);
    if (*ctxt->input->cur)
      xmlFatalErr(ctxt, 5, 0);
    ctxt->instate = XML_PARSER_EOF;
  }
  else
  {
    xmlFatalErrMsg(ctxt, 4, (char)"Start tag expected, '<' not found\n");
  }
  if (ctxt->sax)
  {
    endDocument = ctxt->sax->endDocument;
    if (endDocument)
      ((void (*)(void *))endDocument)(ctxt->userData);
  }
  v21 = ctxt->myDoc;
  if (v21 && xmlStrEqual(v21->version, (const xmlChar *)"SAX compatibility mode document"))
  {
    xmlFreeDoc(ctxt->myDoc);
    ctxt->myDoc = 0;
  }
  if (!ctxt->wellFormed)
  {
    ctxt->valid = 0;
    return -1;
  }
  v22 = ctxt->myDoc;
  if (!v22)
    return 0;
  properties = v22->properties;
  v24 = properties | 1;
  v22->properties = properties | 1;
  if (ctxt->valid)
  {
    v24 = properties | 9;
    v22->properties = properties | 9;
  }
  if (ctxt->nsWellFormed)
  {
    v24 |= 2u;
    v22->properties = v24;
  }
  if ((ctxt->options & 0x20000) == 0)
    return 0;
  result = 0;
  v22->properties = v24 | 4;
  return result;
}

void xmlInitParser(void)
{
  if ((xmlParserInitialized & 1) == 0)
  {
    __xmlGlobalInitMutexLock();
    if ((xmlParserInitialized & 1) == 0)
    {
      xmlInitThreads();
      xmlInitGlobals();
      if ((char *)*__xmlGenericError() == (char *)xmlGenericErrorDefaultFunc || !*__xmlGenericError())
        initGenericErrorDefaultFunc(0);
      xmlInitMemory();
      xmlInitializeDict();
      xmlInitCharEncodingHandlers();
      xmlDefaultSAXHandlerInit();
      xmlRegisterDefaultInputCallbacks();
      xmlRegisterDefaultOutputCallbacks();
      htmlInitAutoClose();
      htmlDefaultSAXHandlerInit();
      xmlXPathInit();
      xmlParserInitialized = 1;
    }
    __xmlGlobalInitMutexUnlock();
  }
}

xmlCharEncoding xmlDetectCharEncoding(const unsigned __int8 *in, int len)
{
  int v2;

  if (in)
  {
    if (len < 4)
    {
      if (len != 3)
      {
        if (len < 2)
          goto LABEL_46;
        v2 = *in;
LABEL_19:
        if (v2 != 255)
        {
          if (v2 != 254 || in[1] != 255)
            goto LABEL_46;
          goto LABEL_22;
        }
        if (in[1] != 254)
          goto LABEL_46;
        goto LABEL_35;
      }
      v2 = *in;
    }
    else
    {
      v2 = *in;
      if (v2 == 76)
      {
        if (in[1] == 111 && in[2] == 167 && in[3] == 148)
        {
          LODWORD(in) = 6;
          return (int)in;
        }
        goto LABEL_46;
      }
      if (v2 == 60)
      {
        if (in[1] == 63)
        {
          if (in[2] != 120 || in[3] != 109)
            goto LABEL_46;
          goto LABEL_16;
        }
        if (in[1])
          goto LABEL_46;
        if (!in[2] && !in[3])
        {
          LODWORD(in) = 4;
          return (int)in;
        }
        if (in[2] != 63 || in[3])
          goto LABEL_46;
LABEL_35:
        LODWORD(in) = 2;
        return (int)in;
      }
      if (!*in)
      {
        if (in[1] != 60)
        {
          if (!in[1])
          {
            if (!in[2] && in[3] == 60)
            {
              LODWORD(in) = 5;
              return (int)in;
            }
            if (in[2] == 60 && !in[3])
            {
              LODWORD(in) = 7;
              return (int)in;
            }
          }
LABEL_46:
          LODWORD(in) = 0;
          return (int)in;
        }
        if (!in[2] && !in[3])
        {
          LODWORD(in) = 8;
          return (int)in;
        }
        if (in[2] || in[3] != 63)
          goto LABEL_46;
LABEL_22:
        LODWORD(in) = 3;
        return (int)in;
      }
    }
    if (v2 == 239)
    {
      if (in[1] != 187 || in[2] != 191)
        goto LABEL_46;
LABEL_16:
      LODWORD(in) = 1;
      return (int)in;
    }
    goto LABEL_19;
  }
  return (int)in;
}

const xmlChar *xmlDetectSAX2(const xmlChar *result)
{
  xmlChar *v1;
  uint64_t v2;

  if (result)
  {
    v1 = (xmlChar *)result;
    v2 = *(_QWORD *)result;
    if (*(_QWORD *)result
      && *(_DWORD *)(v2 + 216) == -554844497
      && ((*(_QWORD *)(v2 + 232) || !*(_QWORD *)(v2 + 112)) && (*(_QWORD *)(v2 + 240) || !*(_QWORD *)(v2 + 120))
       || *((_DWORD *)result + 13)
       || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
       || xmlDetectSAX2_cold_1((_DWORD *)(v2 + 216)))
      && (*(_QWORD *)(v2 + 232) || *(_QWORD *)(v2 + 240) || !*(_QWORD *)(v2 + 112) && !*(_QWORD *)(v2 + 120)))
    {
      *((_DWORD *)v1 + 126) = 1;
    }
    *((_QWORD *)v1 + 60) = xmlDictLookup(*((xmlDictPtr *)v1 + 57), (const xmlChar *)"xml", 3);
    *((_QWORD *)v1 + 61) = xmlDictLookup(*((xmlDictPtr *)v1 + 57), (const xmlChar *)"xmlns", 5);
    result = xmlDictLookup(*((xmlDictPtr *)v1 + 57), (const xmlChar *)"http://www.w3.org/XML/1998/namespace", 36);
    *((_QWORD *)v1 + 62) = result;
    if (!*((_QWORD *)v1 + 60) || !*((_QWORD *)v1 + 61) || !result)
      return (const xmlChar *)htmlErrMemory(v1, 0);
  }
  return result;
}

xmlSAXLocator *__xmlDefaultSAXLocator(void)
{
  if (xmlIsMainThread())
    return (xmlSAXLocator *)xmlDefaultSAXLocator;
  else
    return &xmlGetGlobalState()->xmlDefaultSAXLocator;
}

void xmlParseXMLDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  unsigned int v4;
  BOOL v5;
  uint64_t v6;
  xmlChar *v8;
  xmlChar *v9;
  xmlChar *version;
  xmlParserInputPtr v11;
  const xmlChar *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  xmlParserInputPtr v16;
  const xmlChar *i;

  input = ctxt->input;
  input->standalone = -2;
  cur = input->cur;
  input->cur = cur + 5;
  input->col += 5;
  v4 = cur[5];
  if (!v4)
  {
    xmlParserInputGrow(input, 250);
    v4 = *ctxt->input->cur;
  }
  v5 = v4 > 0x20;
  v6 = (1 << v4) & 0x100002600;
  if (v5 || v6 == 0)
    xmlFatalErrMsg(ctxt, 65, (char)"Blank needed after '<?xml'\n");
  xmlSkipBlankChars(ctxt);
  v8 = xmlParseVersionInfo(ctxt);
  if (v8)
  {
    v9 = v8;
    if (!xmlStrEqual(v8, (const xmlChar *)"1.0"))
    {
      if ((ctxt->options & 0x20000) == 0 && *v9 == 49 && v9[1] == 46)
        xmlWarningMsg(ctxt, 97, "Unsupported version '%s'\n", v9);
      else
        xmlFatalErrMsgStr(ctxt, 108, "Unsupported version '%s'\n", v9);
    }
    version = (xmlChar *)ctxt->version;
    if (version)
      xmlFree(version);
    ctxt->version = v9;
  }
  else
  {
    xmlFatalErr(ctxt, 96, 0);
  }
  v11 = ctxt->input;
  v12 = v11->cur;
  v13 = *v12;
  if (v13 > 0x3F)
  {
LABEL_24:
    xmlFatalErrMsg(ctxt, 65, (char)"Blank needed here\n");
    goto LABEL_25;
  }
  if (((1 << v13) & 0x100002600) == 0)
  {
    if (v13 == 63 && v12[1] == 62)
      goto LABEL_39;
    goto LABEL_24;
  }
LABEL_25:
  xmlParseEncodingDecl(ctxt);
  if (ctxt->errNo != 32 && ctxt->instate != XML_PARSER_EOF)
  {
    v11 = ctxt->input;
    if (v11->encoding)
    {
      v12 = v11->cur;
      v14 = *v12;
      if (v14 > 0x3F)
      {
LABEL_32:
        xmlFatalErrMsg(ctxt, 65, (char)"Blank needed here\n");
        goto LABEL_33;
      }
      if (((1 << v14) & 0x100002600) == 0)
      {
        if (v14 == 63 && v12[1] == 62)
          goto LABEL_39;
        goto LABEL_32;
      }
    }
LABEL_33:
    if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
      xmlGROW((uint64_t)ctxt);
    xmlSkipBlankChars(ctxt);
    ctxt->input->standalone = xmlParseSDDecl(ctxt);
    xmlSkipBlankChars(ctxt);
    v11 = ctxt->input;
    v12 = v11->cur;
    v15 = *v12;
    if (v15 == 62)
    {
      xmlFatalErr(ctxt, 57, 0);
    }
    else
    {
      if (v15 == 63 && v12[1] == 62)
      {
LABEL_39:
        v11->cur = v12 + 2;
        v11->col += 2;
        if (!v12[2])
          xmlParserInputGrow(v11, 250);
        return;
      }
      xmlFatalErr(ctxt, 57, 0);
      v16 = ctxt->input;
      for (i = v16->cur; *i++ && *(i - 1) != 62; v16->cur = i)
        ;
    }
    xmlNextChar(ctxt);
  }
}

int xmlStrEqual(const xmlChar *str1, const xmlChar *str2)
{
  int v2;
  int v3;

  if (str1 == str2)
    return 1;
  v2 = 0;
  if (str1 && str2)
  {
    while (1)
    {
      v3 = *str1;
      if (v3 != *str2)
        break;
      ++str1;
      ++str2;
      if (!v3)
        return 1;
    }
    return 0;
  }
  return v2;
}

int xmlParseSDDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v4;
  xmlParserInputPtr v5;
  const xmlChar *v6;
  int v7;
  int v8;
  xmlParserCtxtPtr v9;
  int v10;
  xmlParserInputPtr v11;
  const xmlChar *v12;
  int v13;

  xmlSkipBlankChars(ctxt);
  input = ctxt->input;
  cur = input->cur;
  if (*cur != 115
    || cur[1] != 116
    || cur[2] != 97
    || cur[3] != 110
    || cur[4] != 100
    || cur[5] != 97
    || cur[6] != 108
    || cur[7] != 111
    || cur[8] != 110
    || cur[9] != 101)
  {
    return -2;
  }
  input->cur = cur + 10;
  input->col += 10;
  if (!cur[10])
    xmlParserInputGrow(input, 250);
  xmlSkipBlankChars(ctxt);
  if (*ctxt->input->cur == 61)
  {
    xmlNextChar(ctxt);
    xmlSkipBlankChars(ctxt);
    v4 = *ctxt->input->cur;
    if (v4 != 34)
    {
      if (v4 == 39)
      {
        xmlNextChar(ctxt);
        v5 = ctxt->input;
        v6 = v5->cur;
        v7 = *v6;
        if (v7 == 121)
        {
          if (v6[1] == 101 && v6[2] == 115)
          {
            v5->cur = v6 + 3;
            v5->col += 3;
            if (!v6[3])
              xmlParserInputGrow(v5, 250);
            v8 = 1;
LABEL_39:
            if (*ctxt->input->cur == 39)
            {
LABEL_40:
              xmlNextChar(ctxt);
              return v8;
            }
LABEL_48:
            xmlFatalErr(ctxt, 34, 0);
            return v8;
          }
        }
        else if (v7 == 110 && v6[1] == 111)
        {
          v5->cur = v6 + 2;
          v5->col += 2;
          if (!v6[2])
            xmlParserInputGrow(v5, 250);
          v8 = 0;
          goto LABEL_39;
        }
        xmlFatalErr(ctxt, 78, 0);
        v8 = -2;
        goto LABEL_39;
      }
      v9 = ctxt;
      v10 = 33;
      goto LABEL_30;
    }
    xmlNextChar(ctxt);
    v11 = ctxt->input;
    v12 = v11->cur;
    v13 = *v12;
    if (v13 == 121)
    {
      if (v12[1] == 101 && v12[2] == 115)
      {
        v11->cur = v12 + 3;
        v11->col += 3;
        if (!v12[3])
          xmlParserInputGrow(v11, 250);
        v8 = 1;
LABEL_47:
        if (*ctxt->input->cur == 34)
          goto LABEL_40;
        goto LABEL_48;
      }
    }
    else if (v13 == 110 && v12[1] == 111)
    {
      v11->cur = v12 + 2;
      v11->col += 2;
      if (!v12[2])
        xmlParserInputGrow(v11, 250);
      v8 = 0;
      goto LABEL_47;
    }
    xmlFatalErr(ctxt, 78, 0);
    v8 = -2;
    goto LABEL_47;
  }
  v9 = ctxt;
  v10 = 75;
LABEL_30:
  xmlFatalErr(v9, v10, 0);
  return -2;
}

xmlChar *__cdecl xmlParseVersionInfo(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v4;
  xmlChar *v5;
  xmlParserCtxtPtr v6;
  int v7;

  input = ctxt->input;
  cur = input->cur;
  if (*cur != 118 || cur[1] != 101 || cur[2] != 114 || cur[3] != 115 || cur[4] != 105 || cur[5] != 111 || cur[6] != 110)
    return 0;
  input->cur = cur + 7;
  input->col += 7;
  if (!cur[7])
    xmlParserInputGrow(input, 250);
  xmlSkipBlankChars(ctxt);
  if (*ctxt->input->cur != 61)
  {
    v6 = ctxt;
    v7 = 75;
LABEL_19:
    xmlFatalErr(v6, v7, 0);
    return 0;
  }
  xmlNextChar(ctxt);
  xmlSkipBlankChars(ctxt);
  v4 = *ctxt->input->cur;
  if (v4 == 39)
  {
    xmlNextChar(ctxt);
    v5 = xmlParseVersionNum(ctxt);
    if (*ctxt->input->cur == 39)
      goto LABEL_14;
LABEL_17:
    xmlFatalErr(ctxt, 34, 0);
    return v5;
  }
  if (v4 != 34)
  {
    v6 = ctxt;
    v7 = 33;
    goto LABEL_19;
  }
  xmlNextChar(ctxt);
  v5 = xmlParseVersionNum(ctxt);
  if (*ctxt->input->cur != 34)
    goto LABEL_17;
LABEL_14:
  xmlNextChar(ctxt);
  return v5;
}

xmlChar *__cdecl xmlParseVersionNum(xmlParserCtxtPtr ctxt)
{
  xmlChar *v2;
  xmlChar *v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  xmlChar *v9;
  uint64_t v10;

  v2 = (xmlChar *)xmlMallocAtomic(0xAuLL);
  v3 = v2;
  if (!v2)
  {
    htmlErrMemory(ctxt, 0);
    return v3;
  }
  v4 = *ctxt->input->cur;
  if ((v4 - 48) >= 0xA || (*v2 = v4, xmlNextChar(ctxt), *ctxt->input->cur != 46))
  {
    xmlFree(v3);
    return 0;
  }
  v3[1] = 46;
  xmlNextChar(ctxt);
  v5 = *ctxt->input->cur;
  if ((v5 - 48) > 9)
  {
    v10 = 2;
LABEL_15:
    v3[v10] = 0;
    return v3;
  }
  v6 = 10;
  v7 = 2;
  while (1)
  {
    v8 = v7 + 1;
    if (v7 + 1 >= v6)
      break;
LABEL_9:
    v3[v7] = v5;
    xmlNextChar(ctxt);
    v5 = *ctxt->input->cur;
    ++v7;
    if ((v5 - 48) >= 0xA)
    {
      v10 = v8;
      goto LABEL_15;
    }
  }
  v6 *= 2;
  v9 = (xmlChar *)xmlRealloc(v3, v6);
  if (v9)
  {
    v3 = v9;
    goto LABEL_9;
  }
  xmlFree(v3);
  htmlErrMemory(ctxt, 0);
  return 0;
}

const xmlChar *__cdecl xmlParseEncodingDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v4;
  xmlChar *v5;
  xmlParserInputPtr v6;
  xmlChar *v7;
  xmlCharEncodingHandler *CharEncodingHandler;
  xmlChar *encoding;
  xmlParserInputBufferPtr buf;

  xmlSkipBlankChars(ctxt);
  input = ctxt->input;
  cur = input->cur;
  if (*cur != 101
    || cur[1] != 110
    || cur[2] != 99
    || cur[3] != 111
    || cur[4] != 100
    || cur[5] != 105
    || cur[6] != 110
    || cur[7] != 103)
  {
    return 0;
  }
  input->cur = cur + 8;
  input->col += 8;
  if (!cur[8])
    xmlParserInputGrow(input, 250);
  xmlSkipBlankChars(ctxt);
  if (*ctxt->input->cur != 61)
  {
    xmlFatalErr(ctxt, 75, 0);
    return 0;
  }
  xmlNextChar(ctxt);
  xmlSkipBlankChars(ctxt);
  v4 = *ctxt->input->cur;
  if (v4 == 39)
  {
    xmlNextChar(ctxt);
    v5 = xmlParseEncName(ctxt);
    if (*ctxt->input->cur == 39)
      goto LABEL_15;
LABEL_28:
    xmlFatalErr(ctxt, 34, 0);
    goto LABEL_30;
  }
  if (v4 != 34)
  {
    xmlFatalErr(ctxt, 33, 0);
    v5 = 0;
    if ((ctxt->options & 0x200000) == 0)
      return v5;
    goto LABEL_30;
  }
  xmlNextChar(ctxt);
  v5 = xmlParseEncName(ctxt);
  if (*ctxt->input->cur != 34)
    goto LABEL_28;
LABEL_15:
  xmlNextChar(ctxt);
  if ((ctxt->options & 0x200000) != 0)
  {
LABEL_30:
    xmlFree(v5);
    return 0;
  }
  if (!v5)
    return v5;
  if (!xmlStrcasecmp(v5, (const xmlChar *)"UTF-16") || !xmlStrcasecmp(v5, (const xmlChar *)"UTF16"))
  {
    encoding = (xmlChar *)ctxt->encoding;
    if (encoding)
      goto LABEL_38;
    buf = ctxt->input->buf;
    if (!buf || buf->encoder)
      goto LABEL_39;
    xmlFatalErrMsg(ctxt, 81, (char)"Document labelled UTF-16 but has UTF-8 content\n");
LABEL_37:
    encoding = (xmlChar *)ctxt->encoding;
    if (!encoding)
    {
LABEL_39:
      ctxt->encoding = v5;
      return v5;
    }
LABEL_38:
    xmlFree(encoding);
    goto LABEL_39;
  }
  if (!xmlStrcasecmp(v5, (const xmlChar *)"UTF-8") || !xmlStrcasecmp(v5, (const xmlChar *)"UTF8"))
    goto LABEL_37;
  v6 = ctxt->input;
  v7 = (xmlChar *)v6->encoding;
  if (v7)
  {
    xmlFree(v7);
    v6 = ctxt->input;
  }
  v6->encoding = v5;
  CharEncodingHandler = xmlFindCharEncodingHandler((const char *)v5);
  if (!CharEncodingHandler)
  {
    xmlFatalErrMsgStr(ctxt, 32, "Unsupported encoding %s\n", v5);
    return 0;
  }
  if (xmlSwitchToEncoding(ctxt, CharEncodingHandler) < 0)
  {
    v5 = 0;
    ctxt->errNo = 32;
  }
  return v5;
}

int xmlStrcasecmp(const xmlChar *str1, const xmlChar *str2)
{
  uint64_t v2;
  int v3;

  if (str1 == str2)
    return 0;
  if (!str1)
    return -1;
  if (!str2)
    return 1;
  while (1)
  {
    v2 = *str2;
    v3 = casemap[*str1] - casemap[v2];
    if (v3)
      break;
    ++str1;
    ++str2;
    if (!(_DWORD)v2)
      return 0;
  }
  return v3;
}

xmlChar *__cdecl xmlParseEncName(xmlParserCtxtPtr ctxt)
{
  int v2;
  _BYTE *v3;
  void *v4;
  xmlChar v5;
  int v6;
  uint64_t i;
  BOOL v8;
  void *v9;
  xmlParserInputPtr input;
  xmlChar *cur;

  v2 = *ctxt->input->cur;
  if ((v2 & 0xFFFFFFDF) - 65 > 0x19)
  {
    xmlFatalErr(ctxt, 79, 0);
    return 0;
  }
  else
  {
    v3 = xmlMallocAtomic(0xAuLL);
    v4 = v3;
    if (v3)
    {
      *v3 = v2;
      xmlNextChar(ctxt);
      v5 = *ctxt->input->cur;
      v6 = 10;
      for (i = 1; ; ++i)
      {
        v8 = (v5 - 48) >= 0xAu && ((v5 & 0xDF) - 65) >= 0x1Au;
        if (v8 && (v5 - 45 > 0x32 || ((1 << (v5 - 45)) & 0x4000000000003) == 0))
          break;
        if (v6 <= (int)i + 1)
        {
          v6 *= 2;
          v9 = xmlRealloc(v4, v6);
          if (!v9)
          {
            htmlErrMemory(ctxt, 0);
            xmlFree(v4);
            return 0;
          }
          v4 = v9;
        }
        *((_BYTE *)v4 + i) = v5;
        xmlNextChar(ctxt);
        input = ctxt->input;
        cur = (xmlChar *)input->cur;
        v5 = *cur;
        if (!*cur)
        {
          if (!ctxt->progressive)
          {
            if (cur - input->base < 501
              || input->end - (const xmlChar *)cur > 499
              || (xmlSHRINK((uint64_t)ctxt), input = ctxt->input, !ctxt->progressive))
            {
              if (input->end - input->cur <= 249)
              {
                xmlGROW((uint64_t)ctxt);
                input = ctxt->input;
              }
            }
          }
          v5 = *input->cur;
        }
      }
      *((_BYTE *)v4 + i) = 0;
    }
    else
    {
      htmlErrMemory(ctxt, 0);
    }
  }
  return (xmlChar *)v4;
}

int xmlSwitchEncoding(xmlParserCtxtPtr ctxt, xmlCharEncoding enc)
{
  int v4;
  xmlParserInputPtr v5;
  const xmlChar *v6;
  xmlCharEncodingHandler *CharEncodingHandler;
  int v8;
  const char *v9;
  xmlParserInputPtr input;
  const xmlChar *cur;
  xmlParserInputPtr v12;
  const xmlChar *encoding;

  if (!ctxt)
    return -1;
  switch(enc)
  {
    case XML_CHAR_ENCODING_ERROR:
      __xmlErrEncoding(ctxt, 31, "encoding unknown\n", 0, 0);
      return -1;
    case XML_CHAR_ENCODING_NONE:
LABEL_22:
      v8 = 0;
      ctxt->charset = 1;
      return v8;
    case XML_CHAR_ENCODING_UTF8:
      ctxt->charset = 1;
      input = ctxt->input;
      if (!input)
        goto LABEL_29;
      cur = input->cur;
      if (*cur != 239 || cur[1] != 187 || cur[2] != 191)
        goto LABEL_29;
      v8 = 0;
      input->cur = cur + 3;
      return v8;
    case XML_CHAR_ENCODING_UTF16LE:
    case XML_CHAR_ENCODING_UTF16BE:
      v5 = ctxt->input;
      if (v5)
      {
        v6 = v5->cur;
        if (v6)
        {
          if (*v6 == 239 && v6[1] == 187 && v6[2] == 191)
            v5->cur = v6 + 3;
        }
      }
      goto LABEL_11;
    case XML_CHAR_ENCODING_UCS4LE:
    case XML_CHAR_ENCODING_UCS4BE:
    case XML_CHAR_ENCODING_UCS4_2143:
    case XML_CHAR_ENCODING_UCS4_3412:
      v4 = 180;
      goto LABEL_13;
    case XML_CHAR_ENCODING_EBCDIC:
    case XML_CHAR_ENCODING_8859_1:
    case XML_CHAR_ENCODING_8859_2:
    case XML_CHAR_ENCODING_8859_3:
    case XML_CHAR_ENCODING_8859_4:
    case XML_CHAR_ENCODING_8859_5:
    case XML_CHAR_ENCODING_8859_6:
    case XML_CHAR_ENCODING_8859_7:
    case XML_CHAR_ENCODING_8859_8:
    case XML_CHAR_ENCODING_8859_9:
    case XML_CHAR_ENCODING_2022_JP:
    case XML_CHAR_ENCODING_SHIFT_JIS:
    case XML_CHAR_ENCODING_EUC_JP:
    case XML_CHAR_ENCODING_ASCII:
      v4 = 45;
      goto LABEL_13;
    case XML_CHAR_ENCODING_UCS2:
LABEL_11:
      v4 = 90;
      goto LABEL_13;
    default:
      v4 = -1;
LABEL_13:
      CharEncodingHandler = xmlGetCharEncodingHandler(enc);
      if (!CharEncodingHandler)
      {
        v9 = "USC4 little endian";
        switch(enc)
        {
          case XML_CHAR_ENCODING_UCS4LE:
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS4BE:
            v9 = "USC4 big endian";
            goto LABEL_41;
          case XML_CHAR_ENCODING_EBCDIC:
            v9 = "EBCDIC";
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS4_2143:
            v9 = "UCS4 2143";
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS4_3412:
            v9 = "UCS4 3412";
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS2:
            v9 = "UCS2";
            goto LABEL_41;
          case XML_CHAR_ENCODING_8859_1:
          case XML_CHAR_ENCODING_8859_2:
          case XML_CHAR_ENCODING_8859_3:
          case XML_CHAR_ENCODING_8859_4:
          case XML_CHAR_ENCODING_8859_5:
          case XML_CHAR_ENCODING_8859_6:
          case XML_CHAR_ENCODING_8859_7:
          case XML_CHAR_ENCODING_8859_8:
          case XML_CHAR_ENCODING_8859_9:
            if (ctxt->inputNr == 1 && !ctxt->encoding)
            {
              v12 = ctxt->input;
              if (v12)
              {
                encoding = v12->encoding;
                if (encoding)
                  ctxt->encoding = xmlStrdup(encoding);
              }
            }
            v8 = 0;
            ctxt->charset = enc;
            return v8;
          case XML_CHAR_ENCODING_2022_JP:
            v9 = "ISO-2022-JP";
            goto LABEL_41;
          case XML_CHAR_ENCODING_SHIFT_JIS:
            v9 = "Shift_JIS";
            goto LABEL_41;
          case XML_CHAR_ENCODING_EUC_JP:
            v9 = "EUC-JP";
LABEL_41:
            __xmlErrEncoding(ctxt, 32, "encoding not supported %s\n", (const xmlChar *)v9, 0);
            break;
          case XML_CHAR_ENCODING_ASCII:
            goto LABEL_22;
          default:
            break;
        }
        xmlStopParser(ctxt);
        return -1;
      }
      ctxt->charset = 1;
      v8 = xmlSwitchToEncodingInt(ctxt, CharEncodingHandler, v4);
      if (v8 < 0 || ctxt->errNo == 6003)
      {
        if (!ctxt->html)
        {
          xmlStopParser(ctxt);
          ctxt->errNo = 6003;
        }
      }
      else
      {
LABEL_29:
        v8 = 0;
      }
      break;
  }
  return v8;
}

void xmlSAX2StartDocument(void *ctx)
{
  htmlDocPtr v2;
  xmlDocPtr v3;
  xmlDocPtr v4;
  xmlChar *v5;
  xmlDict *v6;
  uint64_t v7;
  uint64_t v8;
  const xmlChar *v9;
  xmlChar *v10;

  if (ctx)
  {
    if (*((_DWORD *)ctx + 13))
    {
      v2 = (htmlDocPtr)*((_QWORD *)ctx + 2);
      if (!v2)
      {
        v2 = htmlNewDocNoDtD(0, 0);
        *((_QWORD *)ctx + 2) = v2;
        if (!v2)
          goto LABEL_17;
      }
      v2->parseFlags = *((_DWORD *)ctx + 141);
      v2->properties = 128;
    }
    else
    {
      v3 = xmlNewDoc(*((const xmlChar **)ctx + 4));
      *((_QWORD *)ctx + 2) = v3;
      if (!v3)
      {
LABEL_17:
        xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2StartDocument");
        return;
      }
      v4 = v3;
      v3->properties = (*((_DWORD *)ctx + 141) >> 15) & 4;
      v3->parseFlags = *((_DWORD *)ctx + 141);
      v5 = (xmlChar *)*((_QWORD *)ctx + 5);
      if (v5)
        v5 = xmlStrdup(v5);
      v4->encoding = v5;
      v4->standalone = *((_DWORD *)ctx + 12);
      if (*((_DWORD *)ctx + 142))
      {
        v6 = (xmlDict *)*((_QWORD *)ctx + 57);
        v4->dict = v6;
        xmlDictReference(v6);
      }
    }
    v7 = *((_QWORD *)ctx + 2);
    if (v7)
    {
      if (!*(_QWORD *)(v7 + 136))
      {
        v8 = *((_QWORD *)ctx + 7);
        if (v8)
        {
          v9 = *(const xmlChar **)(v8 + 8);
          if (v9)
          {
            v10 = xmlPathToURI(v9);
            *(_QWORD *)(*((_QWORD *)ctx + 2) + 136) = v10;
            if (!v10)
              goto LABEL_17;
          }
        }
      }
    }
  }
}

xmlDocPtr xmlNewDoc(const xmlChar *version)
{
  xmlDoc *v2;
  xmlDoc *v3;
  const xmlChar *v4;
  xmlChar *v5;
  xmlRegisterNodeFunc *v6;

  v2 = (xmlDoc *)xmlMalloc(0xB0uLL);
  v3 = v2;
  if (v2)
  {
    *(_OWORD *)&v2->charset = 0u;
    *(_OWORD *)&v2->psvi = 0u;
    if (version)
      v4 = version;
    else
      v4 = (const xmlChar *)"1.0";
    *(_OWORD *)&v3->encoding = 0uLL;
    *(_OWORD *)&v3->refs = 0uLL;
    *(_OWORD *)&v3->intSubset = 0uLL;
    *(_OWORD *)&v3->oldNs = 0uLL;
    *(_OWORD *)&v3->next = 0uLL;
    *(_OWORD *)&v3->doc = 0uLL;
    *(_OWORD *)&v3->name = 0uLL;
    *(_OWORD *)&v3->last = 0uLL;
    *(_OWORD *)&v3->_private = 0uLL;
    v3->type = XML_DOCUMENT_NODE;
    v5 = xmlStrdup(v4);
    v3->version = v5;
    if (v5)
    {
      *(_QWORD *)&v3->compression = -1;
      v3->doc = v3;
      *(_QWORD *)&v3->parseFlags = 0x2000000000;
      v3->charset = 1;
      if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
      {
        v6 = __xmlRegisterNodeDefaultValue();
        ((void (*)(xmlDoc *))*v6)(v3);
      }
    }
    else
    {
      __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building doc");
      xmlFree(v3);
      return 0;
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building doc");
  }
  return v3;
}

xmlChar *__cdecl xmlStrdup(xmlChar *cur)
{
  uint64_t v1;

  if (cur)
  {
    v1 = 0;
    while (cur[v1++])
      ;
    return xmlStrndup(cur, (int)v1 - 1);
  }
  return cur;
}

void xmlSAX2EndDocument(void *ctx)
{
  xmlDoc *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  const xmlChar *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;

  if (ctx)
  {
    if (*((_DWORD *)ctx + 39))
    {
      if (*((_DWORD *)ctx + 6))
      {
        v2 = (xmlDoc *)*((_QWORD *)ctx + 2);
        if (v2)
        {
          if (v2->intSubset)
            *((_DWORD *)ctx + 38) &= xmlValidateDocumentFinal((xmlValidCtxtPtr)((char *)ctx + 160), v2);
        }
      }
    }
    v3 = *((_QWORD *)ctx + 5);
    if (v3)
    {
      v4 = *((_QWORD *)ctx + 2);
      if (v4)
      {
        if (!*(_QWORD *)(v4 + 112))
        {
          *(_QWORD *)(v4 + 112) = v3;
          *((_QWORD *)ctx + 5) = 0;
        }
      }
    }
    v5 = (uint64_t *)*((_QWORD *)ctx + 9);
    if (v5)
    {
      if (*((int *)ctx + 16) >= 1)
      {
        v6 = *v5;
        if (v6)
        {
          v7 = *(const xmlChar **)(v6 + 80);
          if (v7)
          {
            v8 = *((_QWORD *)ctx + 2);
            if (v8)
            {
              if (!*(_QWORD *)(v8 + 112))
                *(_QWORD *)(*((_QWORD *)ctx + 2) + 112) = xmlStrdup(v7);
            }
          }
        }
      }
    }
    v9 = *((_DWORD *)ctx + 102);
    if (v9)
    {
      v10 = *((_QWORD *)ctx + 2);
      if (v10)
      {
        if (!*(_DWORD *)(v10 + 144))
          *(_DWORD *)(v10 + 144) = v9;
      }
    }
  }
}

void xmlParseElement(xmlParserCtxtPtr ctxt)
{
  if (!xmlParseElementStart((uint64_t)ctxt))
  {
    xmlParseContentInternal((uint64_t)ctxt);
    if (ctxt->instate != XML_PARSER_EOF)
    {
      if (*ctxt->input->cur)
        xmlParseElementEnd(ctxt);
      else
        xmlFatalErrMsgStrIntStr(ctxt, 77, "Premature end of data in tag %s line %d\n", ctxt->nameTab[ctxt->nameNr - 1], *((_DWORD *)ctxt->pushTab + 6 * ctxt->nameNr - 2), 0);
    }
  }
}

void xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr)
{
  if (hdlr)
  {
    if (!hdlr->initialized)
    {
      hdlr->internalSubset = xmlSAX2InternalSubset;
      hdlr->externalSubset = 0;
      *(_OWORD *)&hdlr->isStandalone = 0u;
      *(_OWORD *)&hdlr->hasExternalSubset = 0u;
      hdlr->getEntity = xmlSAX2GetEntity;
      *(_OWORD *)&hdlr->entityDecl = 0u;
      *(_OWORD *)&hdlr->attributeDecl = 0u;
      hdlr->unparsedEntityDecl = 0;
      hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
      hdlr->startDocument = xmlSAX2StartDocument;
      hdlr->endDocument = xmlSAX2EndDocument;
      hdlr->startElement = xmlSAX2StartElement;
      hdlr->endElement = xmlSAX2EndElement;
      hdlr->reference = 0;
      hdlr->characters = xmlSAX2Characters;
      hdlr->getParameterEntity = 0;
      hdlr->cdataBlock = xmlSAX2CDataBlock;
      hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
      hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
      hdlr->comment = xmlSAX2Comment;
      hdlr->warning = xmlParserWarning;
      hdlr->error = xmlParserError;
      hdlr->fatalError = xmlParserError;
      hdlr->initialized = 1;
    }
  }
}

void htmlDefaultSAXHandlerInit(void)
{
  xmlSAXHandler *v0;

  v0 = (xmlSAXHandler *)__htmlDefaultSAXHandler();
  xmlSAX2InitHtmlDefaultSAXHandler(v0);
}

xmlSAXHandlerV1 *__htmlDefaultSAXHandler(void)
{
  if (xmlIsMainThread())
    return (xmlSAXHandlerV1 *)&htmlDefaultSAXHandler;
  else
    return &xmlGetGlobalState()->htmlDefaultSAXHandler;
}

void xmlInitCharEncodingHandlers(void)
{
  if (!handlers)
  {
    handlers = (uint64_t)xmlMalloc(0x190uLL);
    if (handlers)
    {
      xmlNewCharEncodingHandler("UTF-8", (xmlCharEncodingInputFunc)UTF8ToUTF8, (xmlCharEncodingOutputFunc)UTF8ToUTF8);
      xmlUTF16LEHandler = (uint64_t)xmlNewCharEncodingHandler("UTF-16LE", (xmlCharEncodingInputFunc)UTF16LEToUTF8, (xmlCharEncodingOutputFunc)UTF8ToUTF16LE);
      xmlUTF16BEHandler = (uint64_t)xmlNewCharEncodingHandler("UTF-16BE", (xmlCharEncodingInputFunc)UTF16BEToUTF8, (xmlCharEncodingOutputFunc)UTF8ToUTF16BE);
      xmlNewCharEncodingHandler("UTF-16", (xmlCharEncodingInputFunc)UTF16LEToUTF8, (xmlCharEncodingOutputFunc)UTF8ToUTF16);
      xmlNewCharEncodingHandler("ISO-8859-1", isolat1ToUTF8, UTF8Toisolat1);
      xmlNewCharEncodingHandler("ASCII", (xmlCharEncodingInputFunc)asciiToUTF8, (xmlCharEncodingOutputFunc)UTF8Toascii);
      xmlNewCharEncodingHandler("US-ASCII", (xmlCharEncodingInputFunc)asciiToUTF8, (xmlCharEncodingOutputFunc)UTF8Toascii);
      xmlNewCharEncodingHandler("HTML", 0, UTF8ToHtml);
    }
    else
    {
      __xmlSimpleError(0x1Bu, 2, 0, 0, (const xmlChar *)"xmlInitCharEncodingHandlers : out of memory !\n");
    }
  }
}

xmlCharEncodingHandlerPtr xmlNewCharEncodingHandler(const char *name, xmlCharEncodingInputFunc input, xmlCharEncodingOutputFunc output)
{
  const char *EncodingAlias;
  const char *v7;
  uint64_t v8;
  char v9;
  char *v10;
  char *v11;
  xmlCharEncodingHandler *v12;
  xmlCharEncodingHandler *v13;
  char cur[16];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  EncodingAlias = xmlGetEncodingAlias(name);
  if (EncodingAlias)
    v7 = EncodingAlias;
  else
    v7 = name;
  if (!v7)
  {
    __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6000, 3, 0, 0, 0, 0, 0, 0, 0, "xmlNewCharEncodingHandler : no name !\n", 0);
    return 0;
  }
  v8 = 0;
  v46 = 0;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  *(_OWORD *)cur = 0u;
  do
  {
    v9 = __toupper(v7[v8]);
    cur[v8] = v9;
    if (!v9)
      break;
    ++v8;
  }
  while (v8 != 499);
  cur[v8] = 0;
  v10 = xmlMemStrdup(cur);
  if (!v10)
  {
    __xmlSimpleError(0x1Bu, 2, 0, 0, (const xmlChar *)"xmlNewCharEncodingHandler : out of memory !\n");
    return 0;
  }
  v11 = v10;
  v12 = (xmlCharEncodingHandler *)xmlMalloc(0x28uLL);
  v13 = v12;
  if (v12)
  {
    *(_OWORD *)&v12->name = 0u;
    *(_OWORD *)&v12->output = 0u;
    v12->uconv_in = 0;
    v12->uconv_out = 0;
    v12->name = v11;
    v12->input = input;
    v12->output = output;
    xmlRegisterCharEncodingHandler(v12);
  }
  else
  {
    xmlFree(v11);
    __xmlSimpleError(0x1Bu, 2, 0, 0, (const xmlChar *)"xmlNewCharEncodingHandler : out of memory !\n");
  }
  return v13;
}

xmlChar *__cdecl xmlCharStrndup(const char *cur, int len)
{
  xmlChar *result;
  uint64_t v5;
  int v6;

  result = 0;
  if (cur)
  {
    if ((len & 0x80000000) == 0)
    {
      result = (xmlChar *)xmlMallocAtomic(len + 1);
      if (result)
      {
        if (len)
        {
          v5 = 0;
          while (1)
          {
            v6 = cur[v5];
            result[v5] = v6;
            if (!v6)
              break;
            if (len == ++v5)
              goto LABEL_8;
          }
        }
        else
        {
LABEL_8:
          result[len] = 0;
        }
      }
    }
  }
  return result;
}

xmlChar *__cdecl xmlCharStrdup(xmlChar *cur)
{
  uint64_t v1;

  if (cur)
  {
    v1 = 0;
    while (cur[v1++])
      ;
    return xmlCharStrndup((const char *)cur, (int)v1 - 1);
  }
  return cur;
}

void xmlRegisterCharEncodingHandler(xmlCharEncodingHandlerPtr handler)
{
  uint64_t v2;
  uint64_t v3;

  v2 = handlers;
  if (handlers)
  {
    if (!handler)
    {
LABEL_8:
      __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6001, 3, 0, 0, 0, 0, 0, 0, 0, "xmlRegisterCharEncodingHandler: NULL handler !\n", 0);
      if (!handler)
        return;
      goto LABEL_9;
    }
  }
  else
  {
    xmlInitCharEncodingHandlers();
    v2 = handlers;
    if (!handler)
      goto LABEL_8;
  }
  if (!v2)
    goto LABEL_8;
  v3 = nbCharEncodingHandler;
  if (nbCharEncodingHandler < 50)
  {
    ++nbCharEncodingHandler;
    *(_QWORD *)(v2 + 8 * v3) = handler;
    return;
  }
  __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6002, 3, 0, 0, (const xmlChar *)"MAX_ENCODING_HANDLERS", 0, 0, 0, 0, "xmlRegisterCharEncodingHandler: Too many handler registered, see %s\n", (char)"MAX_ENCODING_HANDLERS");
LABEL_9:
  if (handler->name)
    xmlFree(handler->name);
  xmlFree(handler);
}

const char *__cdecl xmlGetEncodingAlias(const char *alias)
{
  const char *result;
  uint64_t v3;
  char v4;
  uint64_t v5;
  const char **i;
  _OWORD v7[6];
  int v8;
  uint64_t v9;

  result = 0;
  v9 = *MEMORY[0x1E0C80C00];
  if (alias && xmlCharEncodingAliases)
  {
    v3 = 0;
    v8 = 0;
    memset(v7, 0, sizeof(v7));
    do
    {
      v4 = __toupper(alias[v3]);
      *((_BYTE *)v7 + v3) = v4;
      if (!v4)
        break;
      ++v3;
    }
    while (v3 != 99);
    *((_BYTE *)v7 + v3) = 0;
    v5 = xmlCharEncodingAliasesNb;
    if (xmlCharEncodingAliasesNb < 1)
    {
      return 0;
    }
    else
    {
      for (i = (const char **)(xmlCharEncodingAliases + 8); strcmp(*i, (const char *)v7); i += 2)
      {
        if (!--v5)
          return 0;
      }
      return *(i - 1);
    }
  }
  return result;
}

void xmlXPathInit(void)
{
  xmlXPathNAN = NAN;
  xmlXPathPINF = INFINITY;
  xmlXPathNINF = -INFINITY;
}

void xmlRegisterDefaultOutputCallbacks(void)
{
  uint64_t v0;
  int (__cdecl **v1)(const char *);
  int (__cdecl **v2)(const char *);

  if ((xmlOutputCallbackInitialized & 1) == 0)
  {
    v0 = xmlOutputCallbackNr;
    if (xmlOutputCallbackNr <= 14)
    {
      v1 = (int (__cdecl **)(const char *))((char *)&xmlOutputCallbackTable + 32 * xmlOutputCallbackNr);
      *v1 = xmlFileMatch;
      v1[1] = (int (__cdecl *)(const char *))xmlFileOpenW;
      v1[2] = (int (__cdecl *)(const char *))xmlFileWrite;
      v1[3] = (int (__cdecl *)(const char *))xmlFileClose;
      xmlOutputCallbackNr = v0 + 1;
      if ((_DWORD)v0 != 14)
      {
        v2 = (int (__cdecl **)(const char *))((char *)&xmlOutputCallbackTable + 32 * v0 + 32);
        *v2 = xmlIOHTTPMatch;
        v2[1] = (int (__cdecl *)(const char *))xmlIOHTTPDfltOpenW;
        v2[2] = (int (__cdecl *)(const char *))xmlIOHTTPWrite;
        v2[3] = (int (__cdecl *)(const char *))xmlIOHTTPClosePut;
        xmlOutputCallbackNr = v0 + 2;
      }
    }
    xmlOutputCallbackInitialized = 1;
  }
}

void xmlRegisterDefaultInputCallbacks(void)
{
  uint64_t v0;
  int (__cdecl **v1)(const char *);
  uint64_t (**v2)();
  int (__cdecl **v3)(const char *);
  int (__cdecl **v4)(const char *);

  if ((xmlInputCallbackInitialized & 1) == 0)
  {
    v0 = xmlInputCallbackNr;
    if (xmlInputCallbackNr <= 14)
    {
      v1 = (int (__cdecl **)(const char *))((char *)&xmlInputCallbackTable + 32 * xmlInputCallbackNr);
      *v1 = xmlFileMatch;
      v1[1] = (int (__cdecl *)(const char *))xmlFileOpen;
      v1[2] = (int (__cdecl *)(const char *))xmlFileRead;
      v1[3] = (int (__cdecl *)(const char *))xmlFileClose;
      xmlInputCallbackNr = v0 + 1;
      if ((_DWORD)v0 != 14)
      {
        v2 = (uint64_t (**)())((char *)&xmlInputCallbackTable + 32 * v0 + 32);
        *v2 = xmlGzfileMatch;
        v2[1] = (uint64_t (*)())xmlGzfileOpen;
        v2[2] = (uint64_t (*)())xmlGzfileRead;
        v2[3] = (uint64_t (*)())xmlGzfileClose;
        xmlInputCallbackNr = v0 + 2;
        if ((int)v0 <= 12)
        {
          v3 = (int (__cdecl **)(const char *))((char *)&xmlInputCallbackTable + 32 * v0 + 64);
          *v3 = xmlIOHTTPMatch;
          v3[1] = (int (__cdecl *)(const char *))xmlIOHTTPOpen;
          v3[2] = (int (__cdecl *)(const char *))xmlIOHTTPRead;
          v3[3] = (int (__cdecl *)(const char *))xmlIOHTTPClose;
          xmlInputCallbackNr = v0 + 3;
          if ((_DWORD)v0 != 12)
          {
            v4 = (int (__cdecl **)(const char *))((char *)&xmlInputCallbackTable + 32 * v0 + 96);
            *v4 = xmlIOFTPMatch;
            v4[1] = (int (__cdecl *)(const char *))xmlIOFTPOpen;
            v4[2] = (int (__cdecl *)(const char *))xmlIOFTPRead;
            v4[3] = (int (__cdecl *)(const char *))xmlIOFTPClose;
            xmlInputCallbackNr = v0 + 4;
          }
        }
      }
    }
    xmlInputCallbackInitialized = 1;
  }
}

int xmlInitializeDict(void)
{
  return 0;
}

int xmlInitMemory(void)
{
  char *v0;
  char *v1;

  if ((xmlMemInitialized & 1) != 0)
  {
    LODWORD(v0) = -1;
  }
  else
  {
    xmlMemInitialized = 1;
    xmlMemMutex = (uint64_t)xmlNewMutex();
    v1 = getenv("XML_MEM_BREAKPOINT");
    if (v1)
      sscanf(v1, "%ud", &xmlMemStopAtBlock);
    v0 = getenv("XML_MEM_TRACE");
    if (v0)
    {
      sscanf(v0, "%p", &xmlMemTraceBlockAt);
      LODWORD(v0) = 0;
    }
  }
  return (int)v0;
}

xmlMutexPtr _xmlInitGlobalsOnce()
{
  xmlMutexPtr result;

  result = xmlNewMutex();
  xmlThrDefMutex = (uint64_t)result;
  return result;
}

xmlMutexPtr xmlNewMutex(void)
{
  pthread_mutex_t *v0;
  xmlMutex *v1;

  v0 = (pthread_mutex_t *)malloc_type_malloc(0x40uLL, 0x1000040FA0F61DDuLL);
  v1 = (xmlMutex *)v0;
  if (v0)
    pthread_mutex_init(v0, 0);
  return v1;
}

void xmlInitGlobals(void)
{
  pthread_once(&once_control_1, (void (*)(void))_xmlInitGlobalsOnce);
}

void initGenericErrorDefaultFunc(xmlGenericErrorFunc *handler)
{
  void (*v1)(void *, const char *, ...);

  if (handler)
    v1 = *handler;
  else
    v1 = (void (*)(void *, const char *, ...))xmlGenericErrorDefaultFunc;
  *__xmlGenericError() = v1;
}

xmlGenericErrorFunc *__xmlGenericError(void)
{
  if (xmlIsMainThread())
    return (xmlGenericErrorFunc *)xmlGenericError;
  else
    return &xmlGetGlobalState()->xmlGenericError;
}

uint64_t __xmlGlobalInitMutexLock()
{
  return pthread_mutex_lock(&global_init_lock);
}

uint64_t htmlParseCharData(uint64_t a1)
{
  xmlParserInput *v2;
  const xmlChar *cur;
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  void (*v10)(_QWORD, unsigned __int8 *, uint64_t);
  xmlParserInput *v11;
  const xmlChar *end;
  const xmlChar *v13;
  const xmlChar *v14;
  xmlParserInput *v15;
  xmlParserInput *v16;
  const xmlChar *v17;
  xmlParserInput *v18;
  uint64_t v19;
  uint64_t (*v20)(_QWORD, unsigned __int8 *, uint64_t);
  int len;
  unsigned __int8 v22[1006];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  bzero(v22, 0x3EEuLL);
  v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (cur - v2->base >= 501 && v2->end - cur <= 499)
    xmlParserInputShrink(v2);
  len = 0;
  result = htmlCurrentChar(a1, &len);
  v5 = result;
  v6 = 0;
  v7 = 0;
  while (1)
  {
    if (v5 == 38)
    {
      if (*(_DWORD *)(a1 + 276) != 38)
        goto LABEL_56;
      goto LABEL_16;
    }
    if (v5 == 60)
    {
      if (*(_DWORD *)(a1 + 276) != 60)
      {
LABEL_56:
        if (!(_DWORD)v6)
          return result;
        goto LABEL_59;
      }
      goto LABEL_16;
    }
    if (!v5)
      break;
    if (v5 > 255)
    {
      if ((v5 - 0x10000) >= 0x100000
        && v5 >> 11 >= 0x1B
        && (v5 - 57344) >> 1 >= 0xFFF)
      {
LABEL_29:
        htmlParseErrInt((_DWORD *)a1, "Invalid char in CDATA 0x%X\n", v5);
        v8 = len;
        goto LABEL_34;
      }
    }
    else if (v5 <= 31 && (v5 > 0xD || ((1 << v5) & 0x2600) == 0))
    {
      goto LABEL_29;
    }
LABEL_16:
    v8 = len;
    if (len == 1)
    {
      v22[(int)v6] = v5;
      v6 = (v6 + 1);
    }
    else
    {
      v6 = (xmlCopyChar(len, &v22[(int)v6], v5) + v6);
    }
    if ((int)v6 >= 1000)
    {
      v22[v6] = 0;
      if (!*(_QWORD *)a1 || *(_DWORD *)(a1 + 332))
        goto LABEL_33;
      if (areBlanks(a1, v22, v6))
      {
        v9 = *(_QWORD *)a1;
        if (!*(_DWORD *)(a1 + 328))
        {
          v10 = *(void (**)(_QWORD, unsigned __int8 *, uint64_t))(v9 + 144);
          if (!v10)
            goto LABEL_33;
LABEL_32:
          v10(*(_QWORD *)(a1 + 8), v22, v6);
LABEL_33:
          v6 = 0;
          goto LABEL_34;
        }
      }
      else
      {
        htmlCheckParagraph(a1);
        v9 = *(_QWORD *)a1;
      }
      v10 = *(void (**)(_QWORD, unsigned __int8 *, uint64_t))(v9 + 136);
      if (v10)
        goto LABEL_32;
      goto LABEL_33;
    }
LABEL_34:
    v11 = *(xmlParserInput **)(a1 + 56);
    v13 = v11->cur;
    end = v11->end;
    v14 = &v13[v8];
    if (v14 <= end)
    {
      if (*v13 == 10)
      {
        ++v11->line;
        v11->col = 1;
      }
      else
      {
        ++v11->col;
      }
      *(_DWORD *)(a1 + 276) = 0;
      v11->cur = v14;
      ++*(_QWORD *)(a1 + 312);
      v13 += v8;
    }
    if (v7 < 100)
    {
      ++v7;
    }
    else
    {
      if (end - v13 <= 499 && v13 - v11->base >= 501)
        xmlParserInputShrink(v11);
      if (!*(_DWORD *)(a1 + 452))
      {
        v15 = *(xmlParserInput **)(a1 + 56);
        if (v15->end - v15->cur <= 249)
          xmlParserInputGrow(v15, 250);
      }
      v7 = 0;
    }
    result = htmlCurrentChar(a1, &len);
    v5 = result;
    if (!(_DWORD)result)
    {
      v16 = *(xmlParserInput **)(a1 + 56);
      v17 = v16->cur;
      if (v17 - v16->base >= 501 && v16->end - v17 <= 499)
        xmlParserInputShrink(v16);
      if (!*(_DWORD *)(a1 + 452))
      {
        v18 = *(xmlParserInput **)(a1 + 56);
        if (v18->end - v18->cur <= 249)
          xmlParserInputGrow(v18, 250);
      }
      result = htmlCurrentChar(a1, &len);
      v5 = result;
    }
  }
  if (!(_DWORD)v6)
  {
    *(_DWORD *)(a1 + 272) = -1;
    return result;
  }
LABEL_59:
  v22[(int)v6] = 0;
  if (!*(_QWORD *)a1 || *(_DWORD *)(a1 + 332))
    return result;
  result = areBlanks(a1, v22, v6);
  if (!(_DWORD)result)
  {
    result = htmlCheckParagraph(a1);
    v19 = *(_QWORD *)a1;
LABEL_67:
    v20 = *(uint64_t (**)(_QWORD, unsigned __int8 *, uint64_t))(v19 + 136);
    if (v20)
      return v20(*(_QWORD *)(a1 + 8), v22, v6);
    return result;
  }
  v19 = *(_QWORD *)a1;
  if (*(_DWORD *)(a1 + 328))
    goto LABEL_67;
  v20 = *(uint64_t (**)(_QWORD, unsigned __int8 *, uint64_t))(v19 + 144);
  if (!v20)
    return result;
  return v20(*(_QWORD *)(a1 + 8), v22, v6);
}

uint64_t htmlCurrentChar(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  const xmlChar *v6;
  int v7;
  const char *v8;
  _DWORD *v9;
  const xmlChar *v10;
  xmlParserInput *v11;
  const xmlChar *cur;
  int v13;
  unint64_t v14;
  _BYTE *v16;
  const xmlChar *v17;
  const xmlChar *v18;
  const xmlChar *v19;
  uint64_t i;
  int v21;
  unsigned int v23;
  BOOL v24;
  uint64_t v25;
  _QWORD *v27;
  xmlChar *v29;
  const char *v30;
  uint64_t v31;
  void *v32;
  xmlCharEncodingHandlerPtr CharEncodingHandler;
  xmlCharEncodingHandler *handler;
  char __str[16];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _WORD v43[11];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 272) == -1)
    return 0;
  if (*(_DWORD *)(a1 + 276))
  {
    *a2 = 0;
    return *(unsigned int *)(a1 + 276);
  }
  if (*(_DWORD *)(a1 + 408) == 1)
  {
LABEL_18:
    v11 = *(xmlParserInput **)(a1 + 56);
    cur = v11->cur;
    v13 = *cur;
    if ((*(char *)cur & 0x80000000) == 0)
    {
      if (!*cur && cur < v11->end)
      {
        htmlParseErrInt((_DWORD *)a1, "Char 0x%X out of allowed range\n", 0);
        *a2 = 1;
        return 32;
      }
      *a2 = 1;
      return *cur;
    }
    if ((v13 & 0x40) == 0)
      goto LABEL_62;
    v14 = v11->end - cur;
    if (v14 <= 1)
    {
      xmlParserInputGrow(v11, 250);
      v11 = *(xmlParserInput **)(a1 + 56);
      cur = v11->cur;
      v14 = v11->end - cur;
      if (v14 < 2)
        goto LABEL_62;
    }
    if ((cur[1] & 0xC0) != 0x80)
      goto LABEL_62;
    if ((~v13 & 0xE0) != 0)
    {
      *a2 = 2;
      v4 = cur[1] & 0x3F | ((*cur & 0x1F) << 6);
      if (v4 < 0x80)
        goto LABEL_62;
    }
    else
    {
      if (v14 <= 2)
      {
        xmlParserInputGrow(v11, 250);
        v11 = *(xmlParserInput **)(a1 + 56);
        cur = v11->cur;
        v14 = v11->end - cur;
        if (v14 < 3)
          goto LABEL_62;
      }
      if ((cur[2] & 0xC0) != 0x80)
        goto LABEL_62;
      if ((~v13 & 0xF0) == 0)
      {
        if (v14 <= 3)
        {
          xmlParserInputGrow(v11, 250);
          v11 = *(xmlParserInput **)(a1 + 56);
          cur = v11->cur;
          v14 = v11->end - cur;
        }
        if ((v13 & 0xF8) == 0xF0 && v14 >= 4 && (cur[3] & 0xC0) == 0x80)
        {
          *a2 = 4;
          v4 = ((*cur & 7) << 18) | ((cur[1] & 0x3F) << 12) | ((cur[2] & 0x3F) << 6) | cur[3] & 0x3Fu;
          if (v4 >= 0x10000)
            goto LABEL_72;
        }
LABEL_62:
        v42 = 0u;
        memset(v43, 0, sizeof(v43));
        v40 = 0u;
        v41 = 0u;
        v38 = 0u;
        v39 = 0u;
        v36 = 0u;
        v37 = 0u;
        *(_OWORD *)__str = 0u;
        if (v11->end - v11->cur < 4)
          snprintf(__str, 0x95uLL, "Bytes: 0x%02X\n");
        else
          snprintf(__str, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n");
        htmlParseErr((_DWORD *)a1, 81, "Input is not proper UTF-8, indicate encoding !\n", (const xmlChar *)__str, 0);
        v27 = *(_QWORD **)(a1 + 56);
        if (*v27 && !*(_QWORD *)(*v27 + 24))
        {
          xmlSwitchEncoding((xmlParserCtxtPtr)a1, XML_CHAR_ENCODING_8859_1);
          v27 = *(_QWORD **)(a1 + 56);
        }
        *a2 = 1;
        cur = (const xmlChar *)v27[4];
        return *cur;
      }
      *a2 = 3;
      v4 = ((*cur & 0xF) << 12) | ((cur[1] & 0x3F) << 6) | cur[2] & 0x3Fu;
      if (v4 < 0x800)
        goto LABEL_62;
    }
LABEL_72:
    if (v4 >> 11 >= 0x1B
      && (v4 - 57344) >> 1 >= 0xFFF
      && (v4 - 0x10000) >= 0x100000)
    {
      htmlParseErrInt((_DWORD *)a1, "Char 0x%X out of allowed range\n", v4);
    }
    return v4;
  }
  v5 = *(_QWORD **)(a1 + 56);
  v6 = (const xmlChar *)v5[4];
  if (*(char *)v6 < 0)
  {
    if (v5[10])
      goto LABEL_11;
    if (!*v5)
      goto LABEL_11;
    if (*(_QWORD *)(*v5 + 24))
      goto LABEL_11;
    v16 = (_BYTE *)v5[5];
    if (!v16)
      goto LABEL_11;
    if (*v16)
      goto LABEL_11;
    v17 = xmlStrcasestr(v6, (const xmlChar *)"HTTP-EQUIV");
    if (!v17)
      goto LABEL_11;
    v18 = xmlStrcasestr(v17, (const xmlChar *)"CONTENT");
    if (!v18)
      goto LABEL_11;
    v19 = xmlStrcasestr(v18, (const xmlChar *)"CHARSET=");
    if (!v19)
      goto LABEL_11;
    for (i = 0; ; ++i)
    {
      v21 = v19[i + 8];
      if ((v21 - 48) >= 0xA && (v21 & 0xFFFFFFDF) - 65 >= 0x1A)
      {
        v23 = v21 - 45;
        v24 = v23 > 0x32;
        v25 = (1 << v23) & 0x4000000002005;
        if (v24 || v25 == 0)
          break;
      }
    }
    if (i && (v29 = xmlStrndup(v19 + 8, i)) != 0)
    {
      v30 = (const char *)v29;
      v31 = *(_QWORD *)(a1 + 56);
      v32 = *(void **)(v31 + 80);
      if (v32)
      {
        xmlFree(v32);
        v31 = *(_QWORD *)(a1 + 56);
      }
      *(_QWORD *)(v31 + 80) = v30;
      CharEncodingHandler = xmlFindCharEncodingHandler(v30);
      if (CharEncodingHandler)
      {
        handler = CharEncodingHandler;
        if (xmlStrEqual((const xmlChar *)CharEncodingHandler->name, (const xmlChar *)"UTF-8")
          || (xmlSwitchToEncoding((xmlParserCtxtPtr)a1, handler) & 0x80000000) == 0)
        {
          goto LABEL_17;
        }
        if (*(_DWORD *)(a1 + 136))
          v7 = *(_DWORD *)(a1 + 136);
        else
          v7 = 6003;
        v8 = "htmlCheckEncoding: error switching to encoding '%s'\n";
        v9 = (_DWORD *)a1;
      }
      else
      {
        v8 = "Unsupported encoding %s";
        v9 = (_DWORD *)a1;
        v7 = 81;
      }
      v10 = (const xmlChar *)v30;
    }
    else
    {
LABEL_11:
      if ((xmlSwitchEncoding((xmlParserCtxtPtr)a1, XML_CHAR_ENCODING_8859_1) & 0x80000000) == 0)
      {
LABEL_17:
        *(_DWORD *)(a1 + 408) = 1;
        goto LABEL_18;
      }
      if (*(_DWORD *)(a1 + 136))
        v7 = *(_DWORD *)(a1 + 136);
      else
        v7 = 6003;
      v8 = "htmlCheckEncoding: error switching to encoding 'ISO-8859-1'\n";
      v9 = (_DWORD *)a1;
      v10 = 0;
    }
    htmlParseErr(v9, v7, v8, v10, 0);
    goto LABEL_17;
  }
  *a2 = 1;
  v4 = *v6;
  if (!*v6 && (unint64_t)v6 < v5[5])
  {
    htmlParseErrInt((_DWORD *)a1, "Char 0x%X out of allowed range\n", 0);
    return 32;
  }
  return v4;
}

int xmlCopyChar(int len, xmlChar *out, int val)
{
  if (!out)
    return 0;
  if (val >= 128)
    return xmlCopyCharMultiByte(out, val);
  *out = val;
  return 1;
}

uint64_t htmlCheckParagraph(uint64_t result)
{
  uint64_t v1;
  const xmlChar *v2;
  uint64_t v3;
  uint64_t (*v4)(_QWORD, const char *, _QWORD);

  v1 = result;
  v2 = *(const xmlChar **)(result + 288);
  if (v2)
  {
    if (!htmlOmittedDefaultValue)
      return result;
    v3 = 0;
    while (1)
    {
      result = xmlStrEqual(v2, (const xmlChar *)htmlNoContentElements[v3]);
      if ((_DWORD)result)
        break;
      if (++v3 == 2)
        return result;
    }
  }
  htmlAutoClose((int *)v1, (uint64_t)"p");
  htmlCheckImplied(v1, (xmlChar *)"p");
  result = (uint64_t)htmlnamePush(v1, (xmlChar *)"p");
  if (*(_QWORD *)v1)
  {
    v4 = *(uint64_t (**)(_QWORD, const char *, _QWORD))(*(_QWORD *)v1 + 112);
    if (v4)
      return v4(*(_QWORD *)(v1 + 8), "p", 0);
  }
  return result;
}

_DWORD *htmlnamePush(uint64_t a1, xmlChar *str1)
{
  int v4;
  int v5;
  uint64_t v6;
  _DWORD *result;

  v4 = *(_DWORD *)(a1 + 52);
  if (v4 > 2)
  {
LABEL_5:
    if (v4 > 9)
      goto LABEL_8;
    goto LABEL_6;
  }
  if (!xmlStrEqual(str1, (const xmlChar *)"head"))
  {
    v4 = *(_DWORD *)(a1 + 52);
    goto LABEL_5;
  }
  *(_DWORD *)(a1 + 52) = 3;
LABEL_6:
  if (xmlStrEqual(str1, (const xmlChar *)"body"))
    *(_DWORD *)(a1 + 52) = 10;
LABEL_8:
  v5 = *(_DWORD *)(a1 + 296);
  v6 = *(int *)(a1 + 300);
  if (v5 < (int)v6)
  {
    result = *(_DWORD **)(a1 + 304);
LABEL_12:
    *(_QWORD *)&result[2 * v5] = str1;
    *(_QWORD *)(a1 + 288) = str1;
    *(_DWORD *)(a1 + 296) = v5 + 1;
    return result;
  }
  *(_DWORD *)(a1 + 300) = 2 * v6;
  result = xmlRealloc(*(void **)(a1 + 304), 16 * v6);
  *(_QWORD *)(a1 + 304) = result;
  if (result)
  {
    v5 = *(_DWORD *)(a1 + 296);
    goto LABEL_12;
  }
  return htmlErrMemory((_DWORD *)a1, 0);
}

int *htmlAutoClose(int *result, uint64_t a2)
{
  int *v2;
  uint64_t i;
  uint64_t (*v5)(_QWORD, _QWORD);
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];

  v2 = result;
  if (!a2)
    return (int *)htmlAutoCloseOnEnd((uint64_t)result);
  for (i = *((_QWORD *)result + 36); i; i = *((_QWORD *)v2 + 36))
  {
    v10[0] = i;
    v10[1] = a2;
    result = (int *)bsearch(v10, htmlStartClose, 0xFBuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))htmlCompareStartClose);
    if (!result)
      break;
    if (*(_QWORD *)v2)
    {
      v5 = *(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v2 + 120);
      if (v5)
        result = (int *)v5(*((_QWORD *)v2 + 1), *((_QWORD *)v2 + 36));
    }
    v6 = v2[74];
    v7 = v6 - 1;
    if (v6 >= 1)
    {
      v2[74] = v7;
      v8 = *((_QWORD *)v2 + 38);
      if (v6 == 1)
        v9 = 0;
      else
        v9 = *(_QWORD *)(v8 + 8 * (v6 - 2));
      *((_QWORD *)v2 + 36) = v9;
      *(_QWORD *)(v8 + 8 * v7) = 0;
    }
  }
  return result;
}

xmlDtdPtr xmlGetIntSubset(xmlDtdPtr doc)
{
  xmlDtdPtr v1;

  if (doc)
  {
    v1 = doc;
    doc = (xmlDtdPtr)doc->children;
    if (doc)
    {
      while (doc->type != XML_DTD_NODE)
      {
        doc = (xmlDtdPtr)doc->next;
        if (!doc)
          return (xmlDtdPtr)v1->elements;
      }
    }
    else
    {
      return (xmlDtdPtr)v1->elements;
    }
  }
  return doc;
}

int xmlCopyCharMultiByte(xmlChar *out, int val)
{
  unsigned int v2;
  char v3;
  char v4;
  uint64_t v5;
  BOOL v6;

  if (out)
  {
    if (val < 128)
    {
      *out = val;
      LODWORD(v5) = 1;
    }
    else
    {
      if (val >= 0x800)
      {
        if (val >= 0x10000)
        {
          if (val >= 0x110000)
          {
            __xmlRaiseError(0, 0, 0, 0, 0, 1u, 9, 3, 0, 0, 0, 0, 0, val, 0, "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n", val);
            LODWORD(v5) = 0;
            return v5;
          }
          v2 = 12;
          v3 = -16;
          v4 = 18;
        }
        else
        {
          v2 = 6;
          v3 = -32;
          v4 = 12;
        }
      }
      else
      {
        v2 = 0;
        v3 = -64;
        v4 = 6;
      }
      *out = v3 | (val >> v4);
      v5 = 1;
      do
      {
        out[v5++] = (val >> v2) & 0x3F | 0x80;
        v6 = v2 > 5;
        v2 -= 6;
      }
      while (v6);
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  return v5;
}

const xmlChar *htmlParseHTMLName_nonInvasive(uint64_t a1)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  _OWORD v9[6];
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32);
  v2 = *(unsigned __int8 *)(v1 + 1);
  if ((v2 & 0xFFFFFFDF) - 65 < 0x1A || v2 == 95 || v2 == 58)
  {
    v3 = 0;
    v4 = v1 + 1;
    while (1)
    {
      v5 = *(unsigned __int8 *)(v4 + v3);
      if ((v5 - 65) >= 0x1A)
      {
        if ((v5 - 97) >= 0x1A
          && (v5 - 48) >= 0xA
          && ((v5 - 45) > 0x32 || ((1 << (v5 - 45)) & 0x4000000002001) == 0))
        {
          return xmlDictLookup(*(xmlDictPtr *)(a1 + 456), (const xmlChar *)v9, v3);
        }
      }
      else
      {
        LOBYTE(v5) = v5 + 32;
      }
      *((_BYTE *)v9 + v3++) = v5;
      if (v3 == 100)
        return xmlDictLookup(*(xmlDictPtr *)(a1 + 456), (const xmlChar *)v9, v3);
    }
  }
  return 0;
}

uint64_t htmlParseReference(uint64_t ctxt)
{
  _BYTE *v1;
  _QWORD *v2;
  unsigned int v3;
  const htmlEntityDesc *v4;
  unsigned int value;
  unsigned int v6;
  void (*v7)(_QWORD, const char *, uint64_t);
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, xmlChar *, uint64_t);
  xmlChar *v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, const char *, uint64_t);
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  xmlChar *str;
  int v20;
  __int16 v21;

  v21 = 0;
  v20 = 0;
  str = 0;
  v1 = *(_BYTE **)(*(_QWORD *)(ctxt + 56) + 32);
  if (*v1 != 38)
    return ctxt;
  v2 = (_QWORD *)ctxt;
  if (v1[1] == 35)
  {
    ctxt = htmlParseCharRef((htmlParserCtxtPtr)ctxt);
    if (!(_DWORD)ctxt)
      return ctxt;
    if (ctxt >= 0x80)
    {
      if (ctxt > 0x7FF)
      {
        if (WORD1(ctxt))
        {
          LOBYTE(v20) = (ctxt >> 18) & 7 | 0xF0;
          v3 = 12;
        }
        else
        {
          LOBYTE(v20) = (ctxt >> 12) | 0xE0;
          v3 = 6;
        }
      }
      else
      {
        v3 = 0;
        LOBYTE(v20) = (ctxt >> 6) | 0xC0;
      }
      v17 = 1;
      do
      {
        *((_BYTE *)&v20 + v17++) = (ctxt >> v3) & 0x3F | 0x80;
        v18 = v3 > 5;
        v3 -= 6;
      }
      while (v18);
      goto LABEL_33;
    }
    LOBYTE(v20) = ctxt;
    goto LABEL_23;
  }
  v4 = htmlParseEntityRef((htmlParserCtxtPtr)ctxt, (const xmlChar **)&str);
  if (str)
  {
    if (!v4 || (value = v4->value) == 0)
    {
      ctxt = htmlCheckParagraph((uint64_t)v2);
      if (*v2)
      {
        v7 = *(void (**)(_QWORD, const char *, uint64_t))(*v2 + 136);
        if (v7)
        {
          v7(v2[1], "&", 1);
          v8 = *v2;
          v9 = v2[1];
          v10 = *(uint64_t (**)(uint64_t, xmlChar *, uint64_t))(v8 + 136);
          v11 = str;
          v12 = xmlStrlen(str);
          return v10(v9, v11, v12);
        }
      }
      return ctxt;
    }
    if (value >= 0x80)
    {
      if (value > 0x7FF)
      {
        if (HIWORD(value))
        {
          LOBYTE(v20) = (value >> 18) & 7 | 0xF0;
          v6 = 12;
        }
        else
        {
          LOBYTE(v20) = (value >> 12) | 0xE0;
          v6 = 6;
        }
      }
      else
      {
        v6 = 0;
        LOBYTE(v20) = (value >> 6) | 0xC0;
      }
      v17 = 1;
      do
      {
        *((_BYTE *)&v20 + v17++) = (value >> v6) & 0x3F | 0x80;
        v18 = v6 > 5;
        v6 -= 6;
      }
      while (v18);
LABEL_33:
      *((_BYTE *)&v20 + v17) = 0;
      ctxt = htmlCheckParagraph((uint64_t)v2);
      if (*v2)
      {
        v13 = *(uint64_t (**)(uint64_t, const char *, uint64_t))(*v2 + 136);
        if (v13)
        {
          v14 = v2[1];
          v15 = (const char *)&v20;
          v16 = v17;
          return v13(v14, v15, v16);
        }
      }
      return ctxt;
    }
    LOBYTE(v20) = v4->value;
LABEL_23:
    v17 = 1;
    goto LABEL_33;
  }
  ctxt = htmlCheckParagraph((uint64_t)v2);
  if (*v2)
  {
    v13 = *(uint64_t (**)(uint64_t, const char *, uint64_t))(*v2 + 136);
    if (v13)
    {
      v14 = v2[1];
      v15 = "&";
      v16 = 1;
      return v13(v14, v15, v16);
    }
  }
  return ctxt;
}

uint64_t xmlTextReaderDoExpand(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  if (*(_QWORD *)(a1 + 112) && *(_QWORD *)(a1 + 32))
  {
    while (1)
    {
      v2 = *(_QWORD *)(a1 + 32);
      if (*(_DWORD *)(v2 + 272) == -1)
        return 1;
      v3 = *(_QWORD *)(a1 + 112);
      if (v3)
      {
        while (!*(_QWORD *)(v3 + 48))
        {
          v3 = *(_QWORD *)(v3 + 40);
          if (!v3)
            goto LABEL_7;
        }
        return 1;
      }
LABEL_7:
      if (*(_DWORD *)(v2 + 88) < *(_DWORD *)(a1 + 128) || *(_DWORD *)a1 == 3)
        return 1;
      if ((xmlTextReaderPushData(a1) & 0x80000000) != 0)
        break;
      result = 1;
      if (*(_DWORD *)a1 == 3)
        return result;
    }
    *(_DWORD *)a1 = 2;
  }
  return 0xFFFFFFFFLL;
}

uint64_t xmlTextReaderPushData(uint64_t a1)
{
  uint64_t v1;
  xmlBuf *v3;
  uint64_t result;
  int v5;
  int AllocationScheme;
  xmlParserCtxt *v7;
  xmlChar *v8;
  int v9;
  uint64_t v10;
  int v11;
  xmlParserCtxt *v12;
  xmlChar *v13;
  int v14;
  size_t v16;
  size_t v17;
  int v18;
  int v19;
  xmlParserCtxt *v20;
  xmlChar *v21;
  int v22;
  uint64_t v23;

  v1 = *(_QWORD *)(a1 + 48);
  if (v1)
  {
    v3 = *(xmlBuf **)(v1 + 32);
    result = 0xFFFFFFFFLL;
    if (!v3)
      return result;
    v5 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 24) = -1;
    AllocationScheme = xmlBufGetAllocationScheme((uint64_t)v3);
    while (*(_DWORD *)(a1 + 24) == -1)
    {
      if (xmlBufUse(v3) < (*(_DWORD *)(a1 + 108) + 512))
      {
        if (*(_DWORD *)a1 == 3)
          goto LABEL_31;
        result = xmlParserInputBufferRead(*(xmlParserInputBufferPtr *)(a1 + 48), 4096);
        if ((_DWORD)result || AllocationScheme != 2)
        {
          if ((result & 0x80000000) != 0)
          {
            *(_DWORD *)a1 = 3;
            *(_DWORD *)(a1 + 24) = v5;
            return result;
          }
          if (!(_DWORD)result)
          {
            *(_DWORD *)a1 = 3;
            goto LABEL_31;
          }
        }
        else if (xmlBufUse(v3) == *(_DWORD *)(a1 + 108))
        {
          *(_DWORD *)a1 = 3;
          *(_DWORD *)(a1 + 24) = v5;
        }
      }
      if (xmlBufUse(v3) < (*(_DWORD *)(a1 + 108) + 512))
      {
        v11 = xmlBufUse(v3) - *(_DWORD *)(a1 + 108);
        v12 = *(xmlParserCtxt **)(a1 + 32);
        v13 = xmlBufContent(v3);
        v14 = xmlParseChunk(v12, (const char *)&v13[*(unsigned int *)(a1 + 108)], v11, 0);
        *(_DWORD *)(a1 + 108) += v11;
        if (!v14)
          break;
        v10 = *(_QWORD *)(a1 + 32);
LABEL_19:
        *(_DWORD *)(v10 + 24) = 0;
        break;
      }
      v7 = *(xmlParserCtxt **)(a1 + 32);
      v8 = xmlBufContent(v3);
      v9 = xmlParseChunk(v7, (const char *)&v8[*(unsigned int *)(a1 + 108)], 512, 0);
      *(_DWORD *)(a1 + 108) += 512;
      v10 = *(_QWORD *)(a1 + 32);
      if (v9)
        goto LABEL_19;
      if (!*(_DWORD *)(v10 + 24))
        break;
    }
    if (*(_DWORD *)a1 != 3)
    {
      if (*(_DWORD *)a1 == 1 && AllocationScheme != 2 && *(_DWORD *)(a1 + 108) >= 0x1000u)
      {
        v16 = xmlBufUse(v3);
        v17 = *(unsigned int *)(a1 + 108);
        if (v16 - v17 <= 0x200)
        {
          v18 = xmlBufShrink(v3, v17);
          if ((v18 & 0x80000000) == 0)
            *(_DWORD *)(a1 + 108) -= v18;
        }
      }
      goto LABEL_35;
    }
LABEL_31:
    if (*(_DWORD *)(a1 + 24) != 5)
    {
      v19 = xmlBufUse(v3) - *(_DWORD *)(a1 + 108);
      v20 = *(xmlParserCtxt **)(a1 + 32);
      v21 = xmlBufContent(v3);
      v22 = xmlParseChunk(v20, (const char *)&v21[*(unsigned int *)(a1 + 108)], v19, 1);
      *(_DWORD *)(a1 + 108) = xmlBufUse(v3);
      *(_DWORD *)(a1 + 24) = 5;
      if (v22)
      {
        v23 = *(_QWORD *)(a1 + 32);
        if (!*(_DWORD *)(v23 + 24))
          return 0xFFFFFFFFLL;
        *(_DWORD *)(v23 + 24) = 0;
      }
    }
LABEL_35:
    *(_DWORD *)(a1 + 24) = v5;
    if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 24))
      return 0;
    *(_DWORD *)a1 = 3;
  }
  return 0xFFFFFFFFLL;
}

int xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size, int terminate)
{
  xmlParserInputState instate;
  int v9;
  size_t v10;
  size_t v11;
  xmlParserInputPtr input;
  unint64_t v13;
  xmlParserInputPtr v14;
  const xmlChar *v15;
  const xmlChar *v16;
  xmlParserInputPtr v17;
  int v18;
  uint64_t v19;
  int v20;
  char v21;
  xmlParserInputPtr v22;
  uint64_t buf;
  uint64_t v24;
  unint64_t InputBase;
  uint64_t v26;
  int v27;
  const xmlChar **encoder;
  unsigned int v29;
  unint64_t rawconsumed;
  unsigned int v31;
  xmlParserInputPtr v32;
  xmlParserInputBufferPtr v33;
  const xmlChar *base;
  xmlParserInputState v35;
  xmlParserInputPtr v36;
  const xmlChar *cur;
  int progressive;
  xmlParserInputPtr v39;
  unint64_t v40;
  xmlParserInputPtr v41;
  uint64_t v42;
  xmlParserInputPtr v43;
  int v44;
  xmlParserInputPtr v45;
  int v46;
  int v47;
  int length;
  int v49;
  xmlParserInputState v50;
  endDocumentSAXFunc endDocument;
  xmlGenericErrorFunc v53;
  void **v54;
  _BOOL4 v55;

  if (!ctxt)
    return 1;
  if (ctxt->wellFormed != 1 && ctxt->disableSAX == 1)
    return ctxt->errNo;
  instate = ctxt->instate;
  if (instate != XML_PARSER_EOF)
  {
    if (instate == XML_PARSER_START)
      xmlDetectSAX2((const xmlChar *)ctxt);
    if (!chunk || (v9 = size - 1, size < 1) || terminate)
    {
      v55 = 0;
    }
    else
    {
      v55 = chunk[v9] == 13;
      if (chunk[v9] == 13)
        --size;
    }
    v10 = 0;
    v11 = 0;
    while (1)
    {
      if (size >= 1)
      {
        if (chunk)
        {
          input = ctxt->input;
          if (input)
          {
            if (input->buf)
              break;
          }
        }
      }
      if (ctxt->instate == XML_PARSER_EOF)
        goto LABEL_46;
      v22 = ctxt->input;
      if (v22)
      {
        buf = (uint64_t)v22->buf;
        if (v22->buf)
        {
          if (*(_QWORD *)(buf + 24))
          {
            v24 = *(_QWORD *)(buf + 32);
            if (v24)
            {
              if (*(_QWORD *)(buf + 40))
              {
                InputBase = xmlBufGetInputBase(v24, (uint64_t)v22);
                v26 = ctxt->input->cur - ctxt->input->base;
                v27 = xmlCharEncInput(buf, terminate);
                xmlBufSetInputBaseCur(*(uint64_t **)(buf + 32), &ctxt->input->buf, InputBase, v26);
                if (v27 < 0)
                {
                  v53 = *__xmlGenericError();
                  v54 = __xmlGenericErrorContext();
                  v53(*v54, "xmlParseChunk: encoder error\n");
                  xmlHaltParser(ctxt);
                  return 81;
                }
              }
            }
          }
LABEL_46:
          v32 = ctxt->input;
          if (v32)
          {
            v33 = v32->buf;
            if (v33)
              v11 = xmlBufUse(v33->buffer);
          }
        }
      }
      if (terminate
        || v11 > 0x989680
        || !v10
        || !v11
        || (_DWORD)v11 - (_DWORD)v10 < 0
        || (base = ctxt->input->base) == 0
        || (v35 = ctxt->instate, v35 != XML_PARSER_START_TAG)
        && v35 != XML_PARSER_END_TAG
        && (progressive = ctxt->progressive, progressive != 2)
        && v35 != XML_PARSER_CDATA_SECTION
        && progressive != 5
        && v35 != XML_PARSER_DTD
        && progressive != 3
        || memchr((void *)&base[v10], 62, (v11 - v10)))
      {
        xmlParseTryOrFinish((uint64_t)ctxt, terminate);
      }
      v18 = 0;
      v21 = 1;
LABEL_59:
      if (ctxt->instate == XML_PARSER_EOF)
        return ctxt->errNo;
      v36 = ctxt->input;
      if (v36)
      {
        cur = v36->cur;
        if ((v36->end - cur > 10000000 || cur - v36->base > 10000000) && (ctxt->options & 0x80000) == 0)
        {
          xmlFatalErr(ctxt, 1, (const xmlChar *)"Huge input lookup");
          xmlHaltParser(ctxt);
        }
      }
      if (ctxt->wellFormed != 1 && ctxt->disableSAX == 1)
        return ctxt->errNo;
      if ((v21 & 1) != 0)
      {
        if (v55)
        {
          v39 = ctxt->input;
          if (v39)
          {
            if (v39->buf)
            {
              v40 = xmlBufGetInputBase((uint64_t)v39->buf->buffer, (uint64_t)v39);
              v41 = ctxt->input;
              v42 = v41->cur - v41->base;
              xmlParserInputBufferPush(v41->buf, 1, "\r");
              xmlBufSetInputBaseCur((uint64_t *)ctxt->input->buf->buffer, &ctxt->input->buf, v40, v42);
            }
          }
        }
        if (terminate)
        {
          v43 = ctxt->input;
          if (v43)
          {
            if (v43->buf)
            {
              v44 = xmlBufUse(v43->buf->buffer);
              v45 = ctxt->input;
              v46 = (int)v45->cur;
              v47 = (int)v45->base;
              length = v44 - v46;
            }
            else
            {
              length = v43->length;
              v47 = LODWORD(v43->base) - LODWORD(v43->cur);
            }
            v49 = length + v47;
          }
          else
          {
            v49 = 0;
          }
          v50 = ctxt->instate;
          if (v50 != XML_PARSER_EOF && v50 != XML_PARSER_EPILOG)
          {
            xmlFatalErr(ctxt, 5, 0);
            v50 = ctxt->instate;
          }
          if (v50 == XML_PARSER_EPILOG && v49 >= 1)
          {
            xmlFatalErr(ctxt, 5, 0);
            v50 = ctxt->instate;
          }
          if (v50 != XML_PARSER_EOF)
          {
            if (ctxt->sax)
            {
              endDocument = ctxt->sax->endDocument;
              if (endDocument)
                ((void (*)(void *))endDocument)(ctxt->userData);
            }
          }
          ctxt->instate = XML_PARSER_EOF;
        }
        if (ctxt->wellFormed)
          return 0;
        return ctxt->errNo;
      }
      chunk += size;
      size = v18;
    }
    if (ctxt->instate != XML_PARSER_EOF)
    {
      v13 = xmlBufGetInputBase((uint64_t)input->buf->buffer, (uint64_t)input);
      v14 = ctxt->input;
      v16 = v14->base;
      v15 = v14->cur;
      v10 = xmlBufUse(v14->buf->buffer);
      v17 = ctxt->input;
      if (ctxt->instate == XML_PARSER_START && v17->buf && (encoder = (const xmlChar **)v17->buf->encoder) != 0)
      {
        if (xmlStrcasestr(*encoder, (const xmlChar *)"UTF-16")
          || xmlStrcasestr((const xmlChar *)ctxt->input->buf->encoder->name, (const xmlChar *)"UTF16"))
        {
          v29 = 90;
        }
        else if (xmlStrcasestr((const xmlChar *)ctxt->input->buf->encoder->name, (const xmlChar *)"UCS-4")
               || xmlStrcasestr((const xmlChar *)ctxt->input->buf->encoder->name, (const xmlChar *)"UCS4"))
        {
          v29 = 180;
        }
        else
        {
          v29 = 45;
        }
        v17 = ctxt->input;
        rawconsumed = v17->buf->rawconsumed;
        if (rawconsumed >= v29)
          LODWORD(rawconsumed) = 0;
        v31 = v29 - rawconsumed;
        if (size >= v31)
          v18 = size - v31;
        else
          v18 = 0;
        if (size >= v31)
          size = v31;
      }
      else
      {
        v18 = 0;
      }
      v19 = v15 - v16;
      v20 = xmlParserInputBufferPush(v17->buf, size, chunk);
      xmlBufSetInputBaseCur((uint64_t *)ctxt->input->buf->buffer, &ctxt->input->buf, v13, v19);
      if (v20 < 0)
      {
        instate = XML_PARSER_EOF;
        ctxt->errNo = -1;
        xmlHaltParser(ctxt);
        return instate;
      }
      if (v18)
      {
        xmlParseTryOrFinish((uint64_t)ctxt, 0);
        v21 = 0;
        goto LABEL_59;
      }
    }
    goto LABEL_46;
  }
  return instate;
}

void xmlParseTryOrFinish(uint64_t a1, int a2)
{
  uint64_t v2;
  int v5;
  const char *v6;
  xmlParserInput *v7;
  uint64_t raw;
  int IsEmpty;
  unint64_t InputBase;
  uint64_t v11;
  uint64_t v12;
  size_t length;
  const xmlChar *base;
  const xmlChar *cur;
  unint64_t v16;
  void (*v17)(uint64_t, xmlSAXLocator *);
  uint64_t v18;
  xmlSAXLocator *v19;
  _BYTE *v20;
  unsigned int v21;
  uint64_t v22;
  const xmlChar *v23;
  void (*v24)(_QWORD);
  uint64_t v25;
  size_t v26;
  xmlGenericErrorFunc v27;
  void *v28;
  const char *v29;
  unsigned int v30;
  uint64_t v31;
  size_t v32;
  size_t v33;
  xmlChar *v34;
  size_t v35;
  unsigned __int8 v36;
  xmlChar *v37;
  int v38;
  uint64_t v39;
  xmlChar *v40;
  size_t v41;
  size_t v42;
  size_t v43;
  uint64_t v44;
  uint64_t v45;
  size_t v46;
  const char *v47;
  int line;
  int v49;
  int v50;
  int v51;
  uint64_t consumed_low;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  int v57;
  const char *v58;
  uint64_t v59;
  void (*v60)(_QWORD, char *, _QWORD);
  xmlGenericErrorFunc v61;
  void *v62;
  xmlGenericErrorFunc v63;
  void *v64;
  xmlGenericErrorFunc v65;
  void *v66;
  uint64_t v67;
  size_t v68;
  xmlGenericErrorFunc v69;
  void *v70;
  xmlGenericErrorFunc v71;
  void *v72;
  void (*v73)(_QWORD, uint64_t, uint64_t);
  xmlCharEncoding v74;
  unsigned __int8 *v75;
  unint64_t v76;
  int v77;
  int v78;
  int v79;
  unsigned __int8 *v80;
  unint64_t v81;
  int v82;
  int v83;
  unsigned __int8 *v84;
  unint64_t v85;
  int v86;
  int v87;
  void (*v88)(uint64_t, xmlSAXLocator *);
  uint64_t v89;
  xmlSAXLocator *v90;
  xmlChar *v91;
  void (*v92)(_QWORD);
  BOOL v93;
  char v94;
  int v95;
  int v96;
  int v97;
  unsigned int v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  const xmlChar *started;
  const xmlChar *v103;
  xmlDoc *v104;
  _xmlNode *v105;
  xmlParserInput *v106;
  const xmlChar *v107;
  int v108;
  uint64_t v109;
  void (*v110)(_QWORD, const xmlChar *, _QWORD, uint64_t);
  int v111;
  int v112;
  unsigned int v113;
  uint64_t v114;
  uint64_t v115;
  int v116;
  unsigned int v117;
  unsigned int v118;
  uint64_t v119;
  void (*v120)(_QWORD, _QWORD, _QWORD, _QWORD);
  void (*v121)(_QWORD, const xmlChar *);
  int v122;
  unsigned int v123;
  unsigned int v124;
  uint64_t v125;
  void (*v126)(_QWORD, _QWORD, _QWORD, _QWORD);
  void (*v127)(_QWORD, uint64_t, uint64_t);
  xmlParserInput *v128;
  int v129;
  uint64_t v130;
  int v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  int v136;
  uint64_t v137;
  void (*v138)(_QWORD, uint64_t, uint64_t);
  xmlParserInput *v139;
  const xmlChar *v140;
  int col;
  unsigned __int8 *v142;
  const char *v143;
  _DWORD *v144;
  unsigned __int8 *v145;
  _DWORD *v146;
  int v147;
  int v148;
  unsigned int v149;
  unsigned int v150;
  uint64_t v151;
  int v152;
  void (*v153)(uint64_t, xmlSAXLocator *);
  uint64_t v154;
  xmlSAXLocator *v155;
  void (*v156)(_QWORD);
  int v157;
  uint64_t v158;
  unint64_t v159;
  unint64_t v160;
  int v161;
  unsigned __int8 in[16];
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  _WORD v170[11];
  uint64_t v171;

  v171 = *MEMORY[0x1E0C80C00];
  v161 = 0;
  v2 = *(_QWORD *)(a1 + 56);
  if (!v2)
    return;
  if ((uint64_t)(*(_QWORD *)(v2 + 32) - *(_QWORD *)(v2 + 24)) > 4096)
  {
    xmlSHRINK(a1);
    *(_QWORD *)(a1 + 320) = 0;
  }
  v159 = 0;
  v160 = 0;
  xmlParseGetLasts(a1, &v160, &v159);
  v5 = *(_DWORD *)(a1 + 272);
  if (v5 == -1)
    return;
  v157 = 0;
  v6 = "1.0";
  while (2)
  {
    if (*(_DWORD *)(a1 + 24) != 1 && *(_DWORD *)(a1 + 332) == 1)
      return;
    v7 = *(xmlParserInput **)(a1 + 56);
    if (!v7)
      return;
    if (v7->buf)
    {
      if (v5)
      {
        raw = (uint64_t)v7->buf->raw;
        if (raw)
        {
          IsEmpty = xmlBufIsEmpty(raw);
          v7 = *(xmlParserInput **)(a1 + 56);
          if (!IsEmpty)
          {
            InputBase = xmlBufGetInputBase((uint64_t)v7->buf->buffer, (uint64_t)v7);
            v11 = *(_QWORD *)(a1 + 56);
            v12 = *(_QWORD *)(v11 + 32) - *(_QWORD *)(v11 + 24);
            xmlParserInputBufferPush(*(xmlParserInputBufferPtr *)v11, 0, &byte_1B0865C1A);
            xmlBufSetInputBaseCur(*(uint64_t **)(**(_QWORD **)(a1 + 56) + 32), *(_QWORD **)(a1 + 56), InputBase, v12);
            v7 = *(xmlParserInput **)(a1 + 56);
          }
        }
      }
      length = xmlBufUse(v7->buf->buffer);
      v7 = *(xmlParserInput **)(a1 + 56);
    }
    else
    {
      length = v7->length;
    }
    base = v7->base;
    cur = v7->cur;
    v16 = (unint64_t)&base[length - (_QWORD)cur];
    if (!v16)
      return;
    v5 = *(_DWORD *)(a1 + 272);
    switch(v5)
    {
      case -1:
        return;
      case 0:
        if (!*(_DWORD *)(a1 + 408))
        {
          *(_DWORD *)in = 0;
          if (v16 >= 4)
          {
            *(_DWORD *)in = *(_DWORD *)cur;
            v74 = xmlDetectCharEncoding(in, 4);
            xmlSwitchEncoding((xmlParserCtxtPtr)a1, v74);
            goto LABEL_291;
          }
          return;
        }
        if (v16 < 2)
          return;
        if (*cur)
        {
          if (*cur == 60 && cur[1] == 63)
          {
            if (v16 < 5 || !a2 && (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) != 0)
              return;
            if (*(_QWORD *)a1)
            {
              v17 = *(void (**)(uint64_t, xmlSAXLocator *))(*(_QWORD *)a1 + 88);
              if (v17)
              {
                v18 = *(_QWORD *)(a1 + 8);
                v19 = __xmlDefaultSAXLocator();
                v17(v18, v19);
              }
            }
            v20 = *(_BYTE **)(*(_QWORD *)(a1 + 56) + 32);
            if (v20[2] == 120 && v20[3] == 109 && v20[4] == 108)
            {
              v21 = v20[5];
              if (v21 <= 0x20 && ((1 << v21) & 0x100002600) != 0)
              {
                xmlParseXMLDecl((xmlParserCtxtPtr)a1);
                if (*(_DWORD *)(a1 + 136) == 32)
                {
                  xmlHaltParser((xmlParserCtxtPtr)a1);
                  return;
                }
                v22 = *(_QWORD *)(a1 + 56);
                *(_DWORD *)(a1 + 48) = *(_DWORD *)(v22 + 96);
                if (!*(_QWORD *)(a1 + 40))
                {
                  v23 = *(const xmlChar **)(v22 + 80);
                  if (v23)
                    *(_QWORD *)(a1 + 40) = xmlStrdup(v23);
                }
                if (*(_QWORD *)a1)
                {
                  v24 = *(void (**)(_QWORD))(*(_QWORD *)a1 + 96);
                  if (v24)
                  {
                    if (!*(_DWORD *)(a1 + 332))
                      v24(*(_QWORD *)(a1 + 8));
                  }
                }
                v157 += 5;
LABEL_200:
                v5 = 1;
                goto LABEL_340;
              }
            }
            *(_QWORD *)(a1 + 32) = xmlCharStrdup(v6);
          }
          else
          {
            if (*(_QWORD *)a1)
            {
              v88 = *(void (**)(uint64_t, xmlSAXLocator *))(*(_QWORD *)a1 + 88);
              if (v88)
              {
                v89 = *(_QWORD *)(a1 + 8);
                v90 = __xmlDefaultSAXLocator();
                v88(v89, v90);
              }
            }
            v91 = xmlCharStrdup(v6);
            *(_QWORD *)(a1 + 32) = v91;
            if (!v91)
            {
              htmlErrMemory((_DWORD *)a1, 0);
              goto LABEL_291;
            }
          }
          if (*(_QWORD *)a1)
          {
            v92 = *(void (**)(_QWORD))(*(_QWORD *)a1 + 96);
            if (v92)
            {
              if (!*(_DWORD *)(a1 + 332))
                v92(*(_QWORD *)(a1 + 8));
            }
          }
          goto LABEL_200;
        }
        if (*(_QWORD *)a1)
        {
          v153 = *(void (**)(uint64_t, xmlSAXLocator *))(*(_QWORD *)a1 + 88);
          if (v153)
          {
            v154 = *(_QWORD *)(a1 + 8);
            v155 = __xmlDefaultSAXLocator();
            v153(v154, v155);
          }
        }
LABEL_391:
        v146 = (_DWORD *)a1;
        v147 = 4;
        goto LABEL_392;
      case 1:
        xmlSkipBlankChars((xmlParserCtxtPtr)a1);
        v25 = *(_QWORD *)(a1 + 56);
        if (*(_QWORD *)v25)
        {
          v26 = xmlBufUse(*(const xmlBufPtr *)(*(_QWORD *)v25 + 32));
          v25 = *(_QWORD *)(a1 + 56);
        }
        else
        {
          v26 = *(int *)(v25 + 48);
        }
        v75 = *(unsigned __int8 **)(v25 + 32);
        v76 = v26 - (_QWORD)v75 + *(_QWORD *)(v25 + 24);
        if (v76 < 2)
          return;
        v77 = *v75;
        v78 = v75[1];
        if (v77 == 60 && v78 == 63)
        {
          if (a2 || (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) == 0)
          {
            xmlParsePI((xmlParserCtxtPtr)a1);
            goto LABEL_146;
          }
          goto LABEL_387;
        }
        if (v77 != 60 || v78 != 33)
          goto LABEL_288;
        v79 = v75[2];
        if (v79 == 68)
        {
          if (v75[3] != 79 || v75[4] != 67 || v75[5] != 84 || v75[6] != 89 || v75[7] != 80 || v75[8] != 69)
            goto LABEL_287;
          if (!a2 && (xmlParseLookupSequence(a1, 62, 0, 0) & 0x80000000) != 0)
          {
            v152 = 3;
            goto LABEL_399;
          }
          *(_DWORD *)(a1 + 336) = 1;
          *(_DWORD *)(a1 + 452) = 0;
          *(_QWORD *)(a1 + 320) = 0;
          xmlParseDocTypeDecl((xmlParserCtxtPtr)a1);
          if (*(_DWORD *)(a1 + 272) == -1)
            return;
          if (**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32) == 91)
          {
LABEL_123:
            v5 = 3;
          }
          else
          {
            *(_DWORD *)(a1 + 336) = 2;
            if (*(_QWORD *)a1)
            {
              if (!*(_DWORD *)(a1 + 332))
              {
                v120 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 208);
                if (v120)
                  v120(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 360), *(_QWORD *)(a1 + 352));
              }
            }
            *(_DWORD *)(a1 + 336) = 0;
            xmlCleanSpecialAttr((void *)a1);
            v5 = 4;
          }
LABEL_340:
          *(_DWORD *)(a1 + 272) = v5;
          goto LABEL_341;
        }
        if (v79 != 45 || v75[3] != 45)
        {
LABEL_287:
          if (v76 < 9)
            return;
LABEL_288:
          *(_DWORD *)(a1 + 272) = 6;
          goto LABEL_289;
        }
        if (!a2 && (xmlParseLookupSequence(a1, 45, 45, 62) & 0x80000000) != 0)
        {
LABEL_398:
          v152 = 5;
          goto LABEL_399;
        }
        xmlParseComment((xmlParserCtxtPtr)a1);
LABEL_146:
        if (*(_DWORD *)(a1 + 272) != -1)
        {
          v5 = 1;
          *(_DWORD *)(a1 + 272) = 1;
          *(_DWORD *)(a1 + 452) = 1;
          goto LABEL_148;
        }
        return;
      case 2:
        v27 = *__xmlGenericError();
        v28 = *__xmlGenericErrorContext();
        v29 = "PP: internal error, state == PI\n";
        goto LABEL_117;
      case 3:
        v30 = (_DWORD)cur - (_DWORD)base;
        if ((_DWORD)cur - (_DWORD)base < 0)
          return;
        v31 = *(_QWORD *)(a1 + 320);
        if (v31 <= v30)
          v32 = v30;
        else
          v32 = v31;
        LODWORD(v33) = v32;
        v34 = xmlBufContent(v7->buf->buffer);
        v35 = xmlBufUse(*(const xmlBufPtr *)(**(_QWORD **)(a1 + 56) + 32));
        if (v35 <= v32)
          goto LABEL_360;
        v36 = 0;
        v37 = v34 + 1;
        while (2)
        {
          v38 = v34[(int)v33];
          if (v36)
          {
            if (v38 == v36)
              v36 = 0;
            goto LABEL_82;
          }
          if (v35 > (v33 + 4) && v38 == 60)
          {
            v39 = (int)v33;
            v40 = &v34[(int)v33];
            if (v40[1] != 33 || v40[2] != 45 || v34[(int)v33 + 3] != 45)
              goto LABEL_81;
            if (v35 <= (v33 + 3))
              goto LABEL_360;
            while (v34[v39] != 45 || v37[v39] != 45 || v37[v39 + 1] != 62)
            {
              v41 = (v39++ + 4);
              if (v35 <= v41)
              {
                LODWORD(v33) = v39;
                goto LABEL_360;
              }
            }
            v36 = 0;
            LODWORD(v33) = v39 + 2;
            goto LABEL_82;
          }
          if (v38 == 34)
          {
            v36 = 34;
            goto LABEL_82;
          }
          if (v38 != 93)
          {
            if (v38 == 39)
            {
              v36 = 39;
              goto LABEL_82;
            }
LABEL_81:
            v36 = 0;
LABEL_82:
            v33 = (v33 + 1);
            if (v35 <= v33)
            {
              if (v36)
                v133 = 0;
              else
LABEL_360:
                v133 = (int)v33;
              *(_QWORD *)(a1 + 320) = v133;
              return;
            }
            continue;
          }
          break;
        }
        v42 = (v33 + 1);
        if (v35 <= v42)
          goto LABEL_360;
        if (v34[(int)v42] == 93)
        {
          v36 = 0;
          LODWORD(v33) = v33 + 1;
          goto LABEL_82;
        }
        LODWORD(v43) = v33 + 1;
        while (1)
        {
          v44 = v34[(int)v43];
          if (v44 > 0x3E)
            goto LABEL_81;
          if (((1 << v44) & 0x100002600) == 0)
            break;
          v43 = (v43 + 1);
          if (v35 <= v43)
            goto LABEL_360;
        }
        if (v44 != 62)
          goto LABEL_81;
        *(_QWORD *)(a1 + 320) = 0;
        xmlParseInternalSubset(a1);
        if (*(_DWORD *)(a1 + 272) == -1)
          return;
        *(_DWORD *)(a1 + 336) = 2;
        if (*(_QWORD *)a1)
        {
          if (!*(_DWORD *)(a1 + 332))
          {
            v126 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 208);
            if (v126)
              v126(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 360), *(_QWORD *)(a1 + 352));
          }
        }
        *(_DWORD *)(a1 + 336) = 0;
        xmlCleanSpecialAttr((void *)a1);
        if (*(_DWORD *)(a1 + 272) == -1)
          return;
        v5 = 4;
        *(_DWORD *)(a1 + 272) = 4;
LABEL_148:
        *(_QWORD *)(a1 + 320) = 0;
LABEL_341:
        if (v5 == -1)
          return;
        continue;
      case 4:
        xmlSkipBlankChars((xmlParserCtxtPtr)a1);
        v45 = *(_QWORD *)(a1 + 56);
        if (*(_QWORD *)v45)
        {
          v46 = xmlBufUse(*(const xmlBufPtr *)(*(_QWORD *)v45 + 32));
          v45 = *(_QWORD *)(a1 + 56);
        }
        else
        {
          v46 = *(int *)(v45 + 48);
        }
        v80 = *(unsigned __int8 **)(v45 + 32);
        v81 = v46 - (_QWORD)v80 + *(_QWORD *)(v45 + 24);
        if (v81 < 2)
          return;
        v82 = *v80;
        v83 = v80[1];
        if (v82 != 60 || v83 != 63)
        {
          if (v82 == 60 && v83 == 33)
          {
            if (v80[2] == 45 && v80[3] == 45)
            {
              if (!a2 && (xmlParseLookupSequence(a1, 45, 45, 62) & 0x80000000) != 0)
                goto LABEL_398;
              xmlParseComment((xmlParserCtxtPtr)a1);
              goto LABEL_164;
            }
            if (v81 < 4)
              return;
          }
          *(_DWORD *)(a1 + 272) = 6;
          if (*(_DWORD *)(a1 + 452))
          {
LABEL_290:
            xmlParseGetLasts(a1, &v160, &v159);
LABEL_291:
            v5 = *(_DWORD *)(a1 + 272);
            goto LABEL_341;
          }
LABEL_289:
          *(_DWORD *)(a1 + 452) = 6;
          goto LABEL_290;
        }
        if (a2 || (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) == 0)
        {
          xmlParsePI((xmlParserCtxtPtr)a1);
LABEL_164:
          if (*(_DWORD *)(a1 + 272) == -1)
            return;
          v5 = 4;
          goto LABEL_189;
        }
        goto LABEL_387;
      case 5:
        v27 = *__xmlGenericError();
        v28 = *__xmlGenericErrorContext();
        v29 = "PP: internal error, state == COMMENT\n";
        goto LABEL_117;
      case 6:
        v47 = v6;
        *(_QWORD *)in = 0;
        v158 = 0;
        line = v7->line;
        v49 = *(_DWORD *)(a1 + 508);
        if (v16 <= 1 && *(_DWORD *)(a1 + 64) == 1)
          return;
        if (*cur != 60)
          goto LABEL_391;
        if (a2)
          goto LABEL_232;
        if (*(_DWORD *)(a1 + 452))
        {
          if ((unint64_t)cur >= v159)
            return;
        }
        else if ((xmlParseLookupSequence(a1, 62, 0, 0) & 0x80000000) != 0)
        {
          return;
        }
LABEL_232:
        if (*(_DWORD *)(a1 + 376))
        {
          if (**(_DWORD **)(a1 + 368) == -2)
            v101 = -1;
          else
            v101 = **(_DWORD **)(a1 + 368);
        }
        else
        {
          v101 = -1;
        }
        spacePush(a1, v101);
        if (*(_DWORD *)(a1 + 504))
          started = xmlParseStartTag2(a1, (const xmlChar **)in, &v158, &v161);
        else
          started = xmlParseStartTag((xmlParserCtxtPtr)a1);
        v103 = started;
        if (*(_DWORD *)(a1 + 272) == -1)
          return;
        if (started)
        {
          if (*(_DWORD *)(a1 + 156))
          {
            if (*(_DWORD *)(a1 + 24))
            {
              v104 = *(xmlDoc **)(a1 + 16);
              if (v104)
              {
                v105 = *(_xmlNode **)(a1 + 80);
                if (v105)
                {
                  if (v105 == v104->children)
                    *(_DWORD *)(a1 + 152) &= xmlValidateRoot((xmlValidCtxtPtr)(a1 + 160), v104);
                }
              }
            }
          }
          v106 = *(xmlParserInput **)(a1 + 56);
          v107 = v106->cur;
          v108 = *v107;
          if (v108 == 62)
          {
            xmlNextChar((xmlParserCtxtPtr)a1);
          }
          else
          {
            if (v108 == 47 && v107[1] == 62)
            {
              v106->cur = v107 + 2;
              v106->col += 2;
              if (!v107[2])
                xmlParserInputGrow(v106, 250);
              v109 = *(_QWORD *)a1;
              if (*(_DWORD *)(a1 + 504))
              {
                if (v109)
                {
                  v110 = *(void (**)(_QWORD, const xmlChar *, _QWORD, uint64_t))(v109 + 240);
                  if (v110)
                  {
                    if (!*(_DWORD *)(a1 + 332))
                      v110(*(_QWORD *)(a1 + 8), v103, *(_QWORD *)in, v158);
                  }
                }
                v111 = *(_DWORD *)(a1 + 508) - v49;
                if (v111 >= 1)
                  nsPop(a1, v111);
              }
              else if (v109)
              {
                v121 = *(void (**)(_QWORD, const xmlChar *))(v109 + 120);
                if (v121)
                {
                  if (!*(_DWORD *)(a1 + 332))
                    v121(*(_QWORD *)(a1 + 8), v103);
                }
              }
              if (*(_DWORD *)(a1 + 272) == -1)
                return;
              v122 = *(_DWORD *)(a1 + 376);
              if (v122 >= 1)
              {
                v123 = v122 - 2;
                v124 = v122 - 1;
                *(_DWORD *)(a1 + 376) = v124;
                v125 = *(_QWORD *)(a1 + 384);
                if (!v124)
                  v123 = 0;
                *(_QWORD *)(a1 + 368) = v125 + 4 * v123;
                *(_DWORD *)(v125 + 4 * v124) = -1;
              }
              if (*(_DWORD *)(a1 + 296))
                v5 = 7;
              else
                v5 = 14;
LABEL_271:
              v6 = v47;
              *(_DWORD *)(a1 + 272) = v5;
              *(_DWORD *)(a1 + 452) = 1;
              goto LABEL_341;
            }
            xmlFatalErrMsgStr((_DWORD *)a1, 73, "Couldn't find end of Start Tag %s\n", v103);
            v112 = *(_DWORD *)(a1 + 88);
            v113 = v112 - 1;
            if (v112 >= 1)
            {
              *(_DWORD *)(a1 + 88) = v113;
              v114 = *(_QWORD *)(a1 + 96);
              if (v112 == 1)
                v115 = 0;
              else
                v115 = *(_QWORD *)(v114 + 8 * (v112 - 2));
              *(_QWORD *)(a1 + 80) = v115;
              *(_QWORD *)(v114 + 8 * v113) = 0;
            }
            v116 = *(_DWORD *)(a1 + 376);
            if (v116 >= 1)
            {
              v117 = v116 - 2;
              v118 = v116 - 1;
              *(_DWORD *)(a1 + 376) = v118;
              v119 = *(_QWORD *)(a1 + 384);
              if (!v118)
                v117 = 0;
              *(_QWORD *)(a1 + 368) = v119 + 4 * v117;
              *(_DWORD *)(v119 + 4 * v118) = -1;
            }
          }
          nameNsPush((_DWORD *)a1, (uint64_t)v103, *(uint64_t *)in, v158, line, *(_DWORD *)(a1 + 508) - v49);
          v5 = 7;
          goto LABEL_271;
        }
        v148 = *(_DWORD *)(a1 + 376);
        if (v148 >= 1)
        {
          v149 = v148 - 2;
          v150 = v148 - 1;
          *(_DWORD *)(a1 + 376) = v150;
          v151 = *(_QWORD *)(a1 + 384);
          if (!v150)
            v149 = 0;
          *(_QWORD *)(a1 + 368) = v151 + 4 * v149;
          *(_DWORD *)(v151 + 4 * v150) = -1;
        }
        goto LABEL_393;
      case 7:
        if (v16 <= 1 && *(_DWORD *)(a1 + 64) == 1)
          return;
        v50 = *cur;
        v51 = cur[1];
        consumed_low = LODWORD(v7->consumed);
        if (v50 == 60 && v51 == 47)
        {
          v5 = 9;
          goto LABEL_340;
        }
        if (v50 == 60 && v51 == 63)
        {
          if (a2 || (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) == 0)
          {
            xmlParsePI((xmlParserCtxtPtr)a1);
LABEL_131:
            *(_DWORD *)(a1 + 272) = 7;
            *(_DWORD *)(a1 + 452) = 1;
LABEL_355:
            v132 = *(_QWORD *)(a1 + 56);
            if (consumed_low == *(_QWORD *)(v132 + 64) && cur == *(const xmlChar **)(v132 + 32))
            {
              xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"detected an error in element content\n");
              xmlHaltParser((xmlParserCtxtPtr)a1);
            }
            goto LABEL_291;
          }
LABEL_387:
          v152 = 2;
LABEL_399:
          *(_DWORD *)(a1 + 452) = v152;
          return;
        }
        if (v50 == 60 && v51 != 33)
        {
LABEL_125:
          v5 = 6;
          goto LABEL_340;
        }
        v93 = v50 == 60 && v51 == 33;
        v94 = v93;
        if (v93)
        {
          v95 = cur[2];
          if (v95 == 45)
          {
            if (cur[3] == 45)
            {
              if (v16 < 4)
                return;
              v7->cur = cur + 4;
              v96 = xmlParseLookupSequence(a1, 45, 45, 62);
              *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32) -= 4;
              if (!a2 && v96 < 0)
                goto LABEL_398;
              xmlParseComment((xmlParserCtxtPtr)a1);
              goto LABEL_131;
            }
            goto LABEL_305;
          }
        }
        else
        {
          if (v50 != 60)
          {
            if (v50 == 38)
            {
              if (!a2 && (xmlParseLookupSequence(a1, 59, 0, 0) & 0x80000000) != 0)
                return;
              xmlParseReference((xmlParserCtxtPtr)a1);
              goto LABEL_355;
            }
            goto LABEL_347;
          }
          if (v51 != 33)
          {
LABEL_347:
            if (!a2 && v16 <= 0x12B && *(_DWORD *)(a1 + 64) == 1)
            {
              if (*(_DWORD *)(a1 + 452))
              {
                if ((unint64_t)cur > v160)
                  return;
              }
              else if ((xmlParseLookupSequence(a1, 60, 0, 0) & 0x80000000) != 0)
              {
                return;
              }
            }
            *(_QWORD *)(a1 + 320) = 0;
            xmlParseCharData((xmlParserCtxtPtr)a1, 0);
            goto LABEL_355;
          }
          v95 = cur[2];
        }
        if (v95 == 91 && cur[3] == 67 && cur[4] == 68 && cur[5] == 65 && cur[6] == 84 && cur[7] == 65 && cur[8] == 91)
        {
          v7->cur = cur + 9;
          v7->col += 9;
          if (!cur[9])
            xmlParserInputGrow(v7, 250);
          v5 = 8;
          *(_DWORD *)(a1 + 272) = 8;
          goto LABEL_341;
        }
LABEL_305:
        if (v16 >= 9)
          v94 = 0;
        if ((v94 & 1) != 0)
          return;
        goto LABEL_347;
      case 8:
        v53 = xmlParseLookupSequence(a1, 93, 93, 62);
        if ((v53 & 0x80000000) != 0)
        {
          if (v16 < 0x12E)
            return;
          v55 = *(_QWORD **)(a1 + 56);
          v134 = v55[4];
          v135 = xmlCheckCdataPush(v134, 300, 0);
          v136 = v135;
          if ((v135 & 0x80000000) == 0)
          {
            v137 = *(_QWORD *)a1;
            if (*(_QWORD *)a1)
            {
              if (!*(_DWORD *)(a1 + 332))
              {
                v138 = *(void (**)(_QWORD, uint64_t, uint64_t))(v137 + 200);
                if (v138 || (v138 = *(void (**)(_QWORD, uint64_t, uint64_t))(v137 + 136)) != 0)
                  v138(*(_QWORD *)(a1 + 8), v134, v135);
              }
            }
            if (*(_DWORD *)(a1 + 272) != -1)
            {
              v139 = *(xmlParserInput **)(a1 + 56);
              if (v136)
              {
                v140 = v139->cur;
                col = v139->col;
                do
                {
                  if (*v140 == 10)
                  {
                    ++v139->line;
                    col = 1;
                  }
                  else
                  {
                    ++col;
                  }
                  v139->col = col;
                  v139->cur = ++v140;
                  --v136;
                }
                while (v136);
              }
              else
              {
                v140 = v139->cur;
              }
              if (!*v140)
                xmlParserInputGrow(v139, 250);
              *(_QWORD *)(a1 + 320) = 0;
            }
            return;
          }
          v142 = (unsigned __int8 *)(v134 + -(int)v135);
        }
        else
        {
          v54 = v53;
          v55 = *(_QWORD **)(a1 + 56);
          v56 = v55[4];
          v57 = xmlCheckCdataPush(v56, v53, 1);
          if ((v57 & 0x80000000) == 0 && v57 == (_DWORD)v54)
          {
            v58 = v6;
            v59 = *(_QWORD *)a1;
            if ((_DWORD)v54 || !v59)
            {
              if ((_DWORD)v54 && v59 && !*(_DWORD *)(a1 + 332))
              {
                v73 = *(void (**)(_QWORD, uint64_t, uint64_t))(v59 + 200);
                if (v73)
                {
                  v73(*(_QWORD *)(a1 + 8), v56, v54);
                }
                else
                {
                  v127 = *(void (**)(_QWORD, uint64_t, uint64_t))(v59 + 136);
                  if (v127)
                    v127(*(_QWORD *)(a1 + 8), v56, v54);
                }
              }
            }
            else
            {
              v60 = *(void (**)(_QWORD, char *, _QWORD))(v59 + 200);
              if (v60
                && !*(_DWORD *)(a1 + 332)
                && v56 - v55[3] >= 9
                && !strncmp((const char *)(v56 - 9), "<![CDATA[", 9uLL))
              {
                v60(*(_QWORD *)(a1 + 8), &byte_1B0865C1A, 0);
              }
            }
            v6 = v58;
            if (*(_DWORD *)(a1 + 272) == -1)
              return;
            v128 = *(xmlParserInput **)(a1 + 56);
            v129 = v128->col;
            v130 = (uint64_t)(v128->cur + 1);
            v131 = ((v54 + 2) & ~(((int)v54 + 2) >> 31)) + 1;
            do
            {
              if (*(_BYTE *)(v130 - 1) == 10)
              {
                ++v128->line;
                v129 = 1;
              }
              else
              {
                ++v129;
              }
              v128->col = v129;
              v128->cur = (const xmlChar *)v130++;
              --v131;
            }
            while (v131);
            if (!*(_BYTE *)(v130 - 1))
              xmlParserInputGrow(v128, 250);
            *(_QWORD *)(a1 + 320) = 0;
LABEL_339:
            v5 = 7;
            goto LABEL_340;
          }
          v142 = (unsigned __int8 *)(v56 + -v57);
        }
        v55[4] = v142;
        if ((uint64_t)(v55[5] - (_QWORD)v142) > 3)
        {
          v169 = 0u;
          memset(v170, 0, sizeof(v170));
          v167 = 0u;
          v168 = 0u;
          v165 = 0u;
          v166 = 0u;
          v163 = 0u;
          v164 = 0u;
          *(_OWORD *)in = 0u;
          snprintf((char *)in, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", *v142, v142[1], v142[2], v142[3]);
          v143 = "Input is not proper UTF-8, indicate encoding !\n%s";
          v145 = in;
          v144 = (_DWORD *)a1;
        }
        else
        {
          v143 = "Input is not proper UTF-8, indicate encoding !\n";
          v144 = (_DWORD *)a1;
          v145 = 0;
        }
        __xmlErrEncoding(v144, 9, v143, v145, 0);
        return;
      case 9:
        if (v16 < 2)
          return;
        if (a2)
          goto LABEL_221;
        if (*(_DWORD *)(a1 + 452))
        {
          if ((unint64_t)cur >= v159)
            return;
        }
        else if ((xmlParseLookupSequence(a1, 62, 0, 0) & 0x80000000) != 0)
        {
          return;
        }
LABEL_221:
        if (*(_DWORD *)(a1 + 504))
        {
          xmlParseEndTag2(a1, (_QWORD *)(*(_QWORD *)(a1 + 536) + 24 * *(int *)(a1 + 296) - 24));
          v97 = *(_DWORD *)(a1 + 296);
          v98 = v97 - 1;
          if (v97 >= 1)
          {
            *(_DWORD *)(a1 + 296) = v98;
            v99 = *(_QWORD *)(a1 + 304);
            if (v97 == 1)
              v100 = 0;
            else
              v100 = *(_QWORD *)(v99 + 8 * (v97 - 2));
            *(_QWORD *)(a1 + 288) = v100;
            *(_QWORD *)(v99 + 8 * v98) = 0;
          }
        }
        else
        {
          xmlParseEndTag1((xmlParserCtxt *)a1);
        }
        if (*(_DWORD *)(a1 + 272) == -1)
          return;
        if (*(_DWORD *)(a1 + 296))
          goto LABEL_339;
        v5 = 14;
        goto LABEL_340;
      case 10:
        v61 = *__xmlGenericError();
        v62 = *__xmlGenericErrorContext();
        v61(v62, "PP: internal error, state == ENTITY_DECL\n");
        goto LABEL_123;
      case 11:
        v27 = *__xmlGenericError();
        v28 = *__xmlGenericErrorContext();
        v29 = "PP: internal error, state == ENTITY_VALUE\n";
LABEL_117:
        v27(v28, v29);
        goto LABEL_339;
      case 12:
        v63 = *__xmlGenericError();
        v64 = *__xmlGenericErrorContext();
        v63(v64, "PP: internal error, state == ATTRIBUTE_VALUE\n");
        goto LABEL_125;
      case 13:
        v65 = *__xmlGenericError();
        v66 = *__xmlGenericErrorContext();
        v65(v66, "PP: internal error, state == SYSTEM_LITERAL\n");
        goto LABEL_125;
      case 14:
        xmlSkipBlankChars((xmlParserCtxtPtr)a1);
        v67 = *(_QWORD *)(a1 + 56);
        if (*(_QWORD *)v67)
        {
          v68 = xmlBufUse(*(const xmlBufPtr *)(*(_QWORD *)v67 + 32));
          v67 = *(_QWORD *)(a1 + 56);
        }
        else
        {
          v68 = *(int *)(v67 + 48);
        }
        v84 = *(unsigned __int8 **)(v67 + 32);
        v85 = v68 - (_QWORD)v84 + *(_QWORD *)(v67 + 24);
        if (v85 < 2)
          return;
        v86 = *v84;
        v87 = v84[1];
        if (v86 == 60 && v87 == 63)
        {
          if (!a2 && (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) != 0)
            goto LABEL_387;
          xmlParsePI((xmlParserCtxtPtr)a1);
LABEL_187:
          if (*(_DWORD *)(a1 + 272) == -1)
            return;
          v5 = 14;
LABEL_189:
          *(_DWORD *)(a1 + 272) = v5;
          *(_DWORD *)(a1 + 452) = 1;
          goto LABEL_341;
        }
        if (v86 == 60 && v87 == 33)
        {
          if (v84[2] == 45 && v84[3] == 45)
          {
            if (!a2 && (xmlParseLookupSequence(a1, 45, 45, 62) & 0x80000000) != 0)
              goto LABEL_398;
            xmlParseComment((xmlParserCtxtPtr)a1);
            goto LABEL_187;
          }
          if (v85 < 4)
            return;
        }
        v146 = (_DWORD *)a1;
        v147 = 5;
LABEL_392:
        xmlFatalErr(v146, v147, 0);
LABEL_393:
        xmlHaltParser((xmlParserCtxtPtr)a1);
        if (*(_QWORD *)a1)
        {
          v156 = *(void (**)(_QWORD))(*(_QWORD *)a1 + 104);
          if (v156)
            v156(*(_QWORD *)(a1 + 8));
        }
        return;
      case 15:
        v69 = *__xmlGenericError();
        v70 = *__xmlGenericErrorContext();
        v69(v70, "PP: internal error, state == IGNORE");
        goto LABEL_123;
      case 16:
        v71 = *__xmlGenericError();
        v72 = *__xmlGenericErrorContext();
        v71(v72, "PP: internal error, state == PUBLIC_LITERAL\n");
        goto LABEL_125;
      default:
        goto LABEL_341;
    }
  }
}

void xmlParseCharData(xmlParserCtxtPtr ctxt, int cdata)
{
  xmlParserInputPtr input;
  int line;
  int col;
  const xmlChar *cur;
  const xmlChar *v8;
  int v9;
  uint64_t v10;
  int v11;
  const xmlChar *v12;
  int v13;
  xmlParserInputPtr v14;
  const xmlChar *v15;
  const xmlChar *v16;
  BOOL v17;
  xmlParserInputPtr v18;
  const xmlChar *v19;
  int v20;
  _xmlSAXHandler *v21;
  void (*v22)(_QWORD, _QWORD, _QWORD);
  charactersSAXFunc v23;
  int *v24;
  const xmlChar *v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  const xmlChar *v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  unsigned __int8 *v35;
  _xmlSAXHandler *v36;
  void (*v37)(_QWORD, _QWORD, _QWORD);
  charactersSAXFunc *p_characters;
  unsigned int v39;
  uint64_t v40;
  BOOL v41;
  int v42;
  _xmlSAXHandler *v43;
  void (*v44)(_QWORD, _QWORD, _QWORD);
  void (*v45)(_QWORD, _QWORD, _QWORD);
  int *v46;
  int v47;
  unsigned __int8 *v48;
  _xmlSAXHandler *sax;
  void (*ignorableWhitespace)(_QWORD, _QWORD, _QWORD);
  int v51;
  _xmlSAXHandler *v52;
  xmlParserInputPtr v53;
  const xmlChar *v54;
  const xmlChar *v55;
  int v56;
  _xmlSAXHandler *v57;
  void (*v58)(_QWORD, _QWORD, _QWORD);
  charactersSAXFunc v59;
  int *v60;
  void (*characters)(_QWORD, _QWORD, _QWORD);
  int *space;
  int len;
  _OWORD v64[19];
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  input = ctxt->input;
  line = input->line;
  col = input->col;
  if (!ctxt->progressive)
  {
    cur = input->cur;
    if (cur - input->base < 501
      || input->end - cur > 499
      || (xmlSHRINK((uint64_t)ctxt), input = ctxt->input, !ctxt->progressive))
    {
      if (input->end - input->cur <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        input = ctxt->input;
      }
    }
  }
  if (!cdata)
  {
    v25 = input->cur;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          v26 = *v25;
          if ((_DWORD)v26 != 10)
            break;
          v27 = input->line + 1;
          do
          {
            input->line = v27;
            input->col = 1;
            v28 = *++v25;
            ++v27;
          }
          while (v28 == 10);
        }
        if (v26 != 32)
          break;
        ++v25;
        ++input->col;
      }
      if (v26 == 60)
      {
        v48 = (unsigned __int8 *)input->cur;
        if ((int)v25 - (int)v48 < 1)
          return;
        input->cur = v25;
        sax = ctxt->sax;
        if (!ctxt->sax)
          return;
        ignorableWhitespace = (void (*)(_QWORD, _QWORD, _QWORD))sax->ignorableWhitespace;
        if (ignorableWhitespace != (void (*)(_QWORD, _QWORD, _QWORD))sax->characters)
        {
          v51 = areBlanks_0(ctxt, v48, (int)v25 - (int)v48, 1);
          v52 = ctxt->sax;
          if (!v51)
          {
            characters = (void (*)(_QWORD, _QWORD, _QWORD))v52->characters;
            if (characters)
              characters(ctxt->userData, v48, ((_DWORD)v25 - (_DWORD)v48));
            space = ctxt->space;
            if (*space == -1)
              *space = -2;
            return;
          }
          ignorableWhitespace = (void (*)(_QWORD, _QWORD, _QWORD))v52->ignorableWhitespace;
        }
        if (ignorableWhitespace)
          ignorableWhitespace(ctxt->userData, v48, ((_DWORD)v25 - (_DWORD)v48));
        return;
      }
      v29 = input->col;
      while (1)
      {
        while (1)
        {
          if (test_char_data[v26])
          {
            v30 = v25;
            do
            {
              v31 = *++v30;
              ++v29;
            }
            while (test_char_data[v31]);
          }
          else
          {
            v30 = v25;
          }
          input->col = v29;
          v32 = *v30;
          if (v32 != 93)
            break;
          v25 = v30 + 1;
          if (v30[1] == 93 && v30[2] == 62)
          {
            xmlFatalErr(ctxt, 62, 0);
            if (ctxt->instate != XML_PARSER_EOF)
              ctxt->input->cur = v25;
            return;
          }
          input->col = ++v29;
          v26 = *v25;
        }
        if (v32 != 10)
          break;
        v33 = input->line + 1;
        do
        {
          v29 = 1;
          input->line = v33;
          input->col = 1;
          v34 = *++v30;
          v26 = v34;
          ++v33;
        }
        while (v34 == 10);
        v25 = v30;
      }
      v35 = (unsigned __int8 *)input->cur;
      if ((int)v30 - (int)v35 >= 1)
      {
        v36 = ctxt->sax;
        if (ctxt->sax)
        {
          p_characters = &v36->characters;
          v37 = (void (*)(_QWORD, _QWORD, _QWORD))v36->characters;
          if ((char *)p_characters[1] == (char *)v37
            || ((v39 = *v35, v17 = v39 > 0x20, v40 = (1 << v39) & 0x100002600, !v17) ? (v41 = v40 == 0) : (v41 = 1),
                v41))
          {
            if (v37)
            {
              v37(ctxt->userData, input->cur, ((_DWORD)v30 - (_DWORD)v35));
              input = ctxt->input;
              v29 = input->col;
            }
            line = input->line;
            col = v29;
          }
          else
          {
            input->cur = v30;
            v42 = areBlanks_0(ctxt, v35, (int)v30 - (int)v35, 0);
            v43 = ctxt->sax;
            if (v42)
            {
              v44 = (void (*)(_QWORD, _QWORD, _QWORD))v43->ignorableWhitespace;
              if (v44)
                v44(ctxt->userData, v35, ((_DWORD)v30 - (_DWORD)v35));
            }
            else
            {
              v45 = (void (*)(_QWORD, _QWORD, _QWORD))v43->characters;
              if (v45)
                v45(ctxt->userData, v35, ((_DWORD)v30 - (_DWORD)v35));
              v46 = ctxt->space;
              if (*v46 == -1)
                *v46 = -2;
            }
            input = ctxt->input;
            line = input->line;
            col = input->col;
          }
        }
        if (ctxt->instate == XML_PARSER_EOF)
          return;
      }
      input->cur = v30;
      v47 = *v30;
      if (v47 != 13)
        break;
      if (v30[1] != 10)
        goto LABEL_117;
      input->cur = v30 + 1;
      v25 = v30 + 2;
      ++input->line;
      input->col = 1;
LABEL_125:
      if (*(char *)v25 <= 31 && *v25 - 9 >= 2)
        goto LABEL_8;
    }
    if (v47 == 38 || v47 == 60)
      return;
LABEL_117:
    if (!ctxt->progressive)
    {
      if (v30 - input->base < 501 || input->end - v30 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249)
          xmlGROW((uint64_t)ctxt);
      }
    }
    if (ctxt->instate == XML_PARSER_EOF)
      return;
    input = ctxt->input;
    v25 = input->cur;
    goto LABEL_125;
  }
LABEL_8:
  input->line = line;
  input->col = col;
  v65 = 0;
  memset(v64, 0, sizeof(v64));
  if (!ctxt->progressive)
  {
    v8 = input->cur;
    if (v8 - input->base < 501 || input->end - v8 > 499)
    {
LABEL_13:
      if (input->end - v8 <= 249)
        xmlGROW((uint64_t)ctxt);
      goto LABEL_15;
    }
    xmlSHRINK((uint64_t)ctxt);
    if (!ctxt->progressive)
    {
      input = ctxt->input;
      v8 = input->cur;
      goto LABEL_13;
    }
  }
LABEL_15:
  len = 0;
  v9 = xmlCurrentChar(ctxt, &len);
  v10 = 0;
  v11 = 0;
  while (v9 != 38 && v9 != 60)
  {
    if (v9 > 255)
    {
      if (v9 >> 11 >= 0x1B
        && (v9 - 57344) >> 1 >= 0xFFF
        && (v9 - 0x10000) >= 0x100000)
      {
        break;
      }
    }
    else if (v9 > 0xD || ((1 << v9) & 0x2600) == 0)
    {
      if (v9 <= 31)
        break;
      if (v9 == 93)
      {
        v12 = ctxt->input->cur;
        if (v12[1] == 93 && v12[2] == 62)
        {
          if (cdata)
            break;
          xmlFatalErr(ctxt, 62, 0);
        }
      }
    }
    if (len == 1)
    {
      *((_BYTE *)v64 + (int)v10) = v9;
      v10 = (v10 + 1);
      v13 = 1;
    }
    else
    {
      v10 = (xmlCopyCharMultiByte((xmlChar *)v64 + (int)v10, v9) + v10);
      v13 = len;
    }
    v14 = ctxt->input;
    v15 = v14->cur;
    v16 = &v15[v13];
    if (v16 <= v14->end)
    {
      if (*v15 == 10)
      {
        ++v14->line;
        v14->col = 1;
      }
      else
      {
        ++v14->col;
      }
      v14->cur = v16;
    }
    v9 = xmlCurrentChar(ctxt, &len);
    if ((int)v10 >= 300)
    {
      *((_BYTE *)v64 + v10) = 0;
      if (ctxt->sax && !ctxt->disableSAX)
      {
        v20 = areBlanks_0(ctxt, (unsigned __int8 *)v64, v10, 0);
        v21 = ctxt->sax;
        if (v20)
        {
          v22 = (void (*)(_QWORD, _QWORD, _QWORD))v21->ignorableWhitespace;
          if (v22)
            v22(ctxt->userData, v64, v10);
        }
        else
        {
          v23 = v21->characters;
          if (v23)
          {
            ((void (*)(void *, _OWORD *, uint64_t))v23)(ctxt->userData, v64, v10);
            v21 = ctxt->sax;
            v23 = ctxt->sax->characters;
          }
          if (v23 != v21->ignorableWhitespace)
          {
            v24 = ctxt->space;
            if (*v24 == -1)
              *v24 = -2;
          }
        }
      }
      if (ctxt->instate != XML_PARSER_CONTENT)
        return;
      v10 = 0;
    }
    v17 = v11++ < 50;
    if (!v17)
    {
      if (!ctxt->progressive)
      {
        v18 = ctxt->input;
        v19 = v18->cur;
        if (v19 - v18->base < 501 || v18->end - v19 > 499)
          goto LABEL_49;
        xmlSHRINK((uint64_t)ctxt);
        if (!ctxt->progressive)
        {
          v18 = ctxt->input;
          v19 = v18->cur;
LABEL_49:
          if (v18->end - v19 <= 249)
            xmlGROW((uint64_t)ctxt);
        }
      }
      v11 = 0;
      if (ctxt->instate == XML_PARSER_EOF)
        return;
    }
  }
  if ((_DWORD)v10)
  {
    *((_BYTE *)v64 + (int)v10) = 0;
    if (ctxt->sax)
    {
      if (!ctxt->disableSAX)
      {
        v56 = areBlanks_0(ctxt, (unsigned __int8 *)v64, v10, 0);
        v57 = ctxt->sax;
        if (v56)
        {
          v58 = (void (*)(_QWORD, _QWORD, _QWORD))v57->ignorableWhitespace;
          if (v58)
            v58(ctxt->userData, v64, v10);
        }
        else
        {
          v59 = v57->characters;
          if (v59)
          {
            ((void (*)(void *, _OWORD *, uint64_t))v59)(ctxt->userData, v64, v10);
            v57 = ctxt->sax;
            v59 = ctxt->sax->characters;
          }
          if (v59 != v57->ignorableWhitespace)
          {
            v60 = ctxt->space;
            if (*v60 == -1)
              *v60 = -2;
          }
        }
      }
    }
  }
  if (v9)
  {
    if (v9 > 255)
    {
      if ((v9 - 57344) >> 1 >= 0xFFF && (v9 - 0x10000) >= 0x100000)
        goto LABEL_137;
    }
    else if (v9 <= 31 && (v9 > 0xD || ((1 << v9) & 0x2600) == 0))
    {
LABEL_137:
      xmlFatalErrMsgInt(ctxt, 9, "PCDATA invalid Char value %d\n", v9);
      v53 = ctxt->input;
      v54 = v53->cur;
      v55 = &v54[len];
      if (v55 <= v53->end)
      {
        if (*v54 == 10)
        {
          ++v53->line;
          v53->col = 1;
        }
        else
        {
          ++v53->col;
        }
        v53->cur = v55;
      }
    }
  }
}

uint64_t xmlSAX2Text(uint64_t result, char *__src, int len, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;
  int v9;
  xmlChar *v10;
  int v11;
  _QWORD *v12;
  int v13;
  xmlChar *v14;
  int v15;
  const char *v16;
  int v17;
  int v18;
  int v19;
  xmlChar *v20;
  uint64_t v21;

  if (!result)
    return result;
  v4 = result;
  v5 = *(_QWORD *)(result + 80);
  if (!v5)
    return result;
  v8 = *(_QWORD *)(v5 + 32);
  if (!v8)
  {
    if (a4 == 3)
    {
      result = (uint64_t)xmlSAX2TextNode(result, __src, len);
      if (!result)
        goto LABEL_46;
    }
    else
    {
      result = (uint64_t)xmlNewCDataBlock(*(xmlDocPtr *)(result + 16), (const xmlChar *)__src, len);
      if (!result)
        goto LABEL_46;
    }
    v12 = *(_QWORD **)(v4 + 80);
    v12[3] = result;
    v12[4] = result;
    *(_QWORD *)(result + 40) = v12;
    *(_QWORD *)(result + 64) = v12[8];
    goto LABEL_22;
  }
  if (*(_DWORD *)(v8 + 8) != a4)
  {
    if (a4 != 3)
    {
      result = (uint64_t)xmlNewCDataBlock(*(xmlDocPtr *)(result + 16), (const xmlChar *)__src, len);
      goto LABEL_20;
    }
LABEL_16:
    result = (uint64_t)xmlSAX2TextNode(result, __src, len);
LABEL_20:
    if (!result)
      return result;
    result = (uint64_t)xmlAddChild(*(xmlNodePtr *)(v4 + 80), (xmlNodePtr)result);
    if (!*(_QWORD *)(*(_QWORD *)(v4 + 80) + 24))
      return result;
LABEL_22:
    *(_DWORD *)(v4 + 412) = len;
    v13 = len + 1;
LABEL_23:
    *(_DWORD *)(v4 + 416) = v13;
    return result;
  }
  if (a4 == 3 && *(const xmlChar **)(v8 + 16) != "text")
    goto LABEL_16;
  v9 = *(_DWORD *)(result + 416);
  if (v9)
  {
    v10 = *(xmlChar **)(v8 + 80);
    if (v10 == (xmlChar *)(v8 + 88))
    {
      v14 = xmlStrdup(*(const xmlChar **)(v8 + 80));
      *(_QWORD *)v10 = 0;
      *(_QWORD *)(v8 + 80) = v14;
      v10 = v14;
    }
    else if (v9 == *(_DWORD *)(result + 412) + 1)
    {
      v11 = xmlDictOwns(*(xmlDictPtr *)(result + 456), *(const xmlChar **)(v8 + 80));
      v10 = *(xmlChar **)(v8 + 80);
      if (v11)
      {
        v10 = xmlStrdup(*(const xmlChar **)(v8 + 80));
        *(_QWORD *)(v8 + 80) = v10;
      }
    }
    if (!v10)
    {
      v16 = "xmlSAX2Characters: xmlStrdup returned NULL";
      return (uint64_t)xmlSAX2ErrMemory((uint64_t *)v4, v16);
    }
    v15 = *(_DWORD *)(v4 + 412);
    if (v15 > (len ^ 0x7FFFFFFF))
    {
      v16 = "xmlSAX2Characters overflow prevented";
      return (uint64_t)xmlSAX2ErrMemory((uint64_t *)v4, v16);
    }
    if (v15 + len >= 10000001 && (*(_BYTE *)(v4 + 566) & 8) == 0)
    {
      v16 = "xmlSAX2Characters: huge text node";
      return (uint64_t)xmlSAX2ErrMemory((uint64_t *)v4, v16);
    }
    v17 = *(_DWORD *)(v4 + 416);
    if (v15 + len < v17)
    {
LABEL_45:
      result = (uint64_t)memcpy(&v10[v15], __src, len);
      v21 = *(int *)(v4 + 412) + (uint64_t)len;
      *(_DWORD *)(v4 + 412) = v21;
      *(_BYTE *)(*(_QWORD *)(v8 + 80) + v21) = 0;
      return result;
    }
    v18 = v17 + len;
    if (v17 > (len ^ 0x7FFFFFFF))
      v18 = 0x7FFFFFFF;
    if (v18 <= 0x3FFFFFFF)
      v19 = 2 * v18;
    else
      v19 = 0x7FFFFFFF;
    v20 = (xmlChar *)xmlRealloc(v10, v19);
    if (v20)
    {
      v10 = v20;
      *(_DWORD *)(v4 + 416) = v19;
      *(_QWORD *)(v8 + 80) = v20;
      v15 = *(_DWORD *)(v4 + 412);
      goto LABEL_45;
    }
LABEL_46:
    v16 = "xmlSAX2Characters";
    return (uint64_t)xmlSAX2ErrMemory((uint64_t *)v4, v16);
  }
  result = xmlTextConcat((xmlNodePtr)v8, (const xmlChar *)__src, len);
  if ((_DWORD)result)
    result = (uint64_t)xmlSAX2ErrMemory((uint64_t *)v4, "xmlSAX2Characters");
  if (*(_QWORD *)(*(_QWORD *)(v4 + 80) + 24))
  {
    result = xmlStrlen(*(const xmlChar **)(v8 + 80));
    *(_DWORD *)(v4 + 412) = result;
    v13 = result + 1;
    goto LABEL_23;
  }
  return result;
}

void xmlSAX2Characters(void *ctx, const xmlChar *ch, int len)
{
  xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3);
}

uint64_t areBlanks(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  const xmlChar *v8;
  uint64_t result;
  const xmlDoc *v10;
  xmlDtdPtr IntSubset;
  xmlDtdPtr v12;
  const xmlChar *ExternalID;
  xmlNodePtr LastChild;
  xmlNodePtr v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (a3 >= 1)
  {
    v4 = a3;
    do
    {
      v5 = *a2++;
      v6 = (1 << v5) & 0x100002600;
      if (v5 > 0x20 || v6 == 0)
        return 0;
    }
    while (--v4);
  }
  if (!**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32))
    return 1;
  if (**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32) != 60)
    return 0;
  v8 = *(const xmlChar **)(a1 + 288);
  if (!v8)
    return 1;
  if (xmlStrEqual(v8, (const xmlChar *)"html"))
    return 1;
  if (xmlStrEqual(*(const xmlChar **)(a1 + 288), (const xmlChar *)"head"))
    return 1;
  if (xmlStrEqual(*(const xmlChar **)(a1 + 288), (const xmlChar *)"body"))
  {
    v10 = *(const xmlDoc **)(a1 + 16);
    if (v10)
    {
      IntSubset = xmlGetIntSubset(v10);
      if (IntSubset)
      {
        v12 = IntSubset;
        ExternalID = IntSubset->ExternalID;
        if (ExternalID)
        {
          if (!xmlStrcasecmp(ExternalID, (const xmlChar *)"-//W3C//DTD HTML 4.01//EN")
            || !xmlStrcasecmp(v12->ExternalID, (const xmlChar *)"-//W3C//DTD HTML 4//EN"))
          {
            return 1;
          }
        }
      }
    }
  }
  result = *(_QWORD *)(a1 + 80);
  if (!result)
    return result;
  LastChild = xmlGetLastChild((const xmlNode *)result);
  if (LastChild)
  {
    v15 = LastChild;
    while (v15->type == XML_COMMENT_NODE)
    {
      v15 = v15->prev;
      if (!v15)
        goto LABEL_25;
    }
    if (!xmlNodeIsText(v15))
    {
      v18 = 0;
      while (!xmlStrEqual(v15->name, (const xmlChar *)allowPCData[v18]))
      {
        ++v18;
        result = 1;
        if (v18 == 53)
          return result;
      }
    }
  }
  else
  {
LABEL_25:
    v16 = *(_QWORD *)(a1 + 80);
    if (*(_DWORD *)(v16 + 8) == 1 || !*(_QWORD *)(v16 + 80))
    {
      v17 = 0;
      while (!xmlStrEqual(*(const xmlChar **)(a1 + 288), (const xmlChar *)allowPCData[v17]))
      {
        ++v17;
        result = 1;
        if (v17 == 53)
          return result;
      }
    }
  }
  return 0;
}

uint64_t areBlanks_0(_QWORD *a1, unsigned __int8 *a2, int a3, int a4)
{
  int *v5;
  int v6;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v13;
  xmlDoc *v14;
  int IsMixedElement;
  unsigned __int8 *v16;
  int v17;
  const xmlNode *v19;
  BOOL v20;
  const xmlNode *LastChild;
  const xmlNode *v22;
  uint64_t v23;

  if (*(_QWORD *)(*a1 + 144) == *(_QWORD *)(*a1 + 136))
    return 0;
  v5 = (int *)a1[46];
  if (!v5)
    return 0;
  v6 = *v5;
  if (v6 == -2 || v6 == 1)
    return 0;
  if (!a4 && a3 >= 1)
  {
    v9 = a3;
    do
    {
      v10 = *a2++;
      v11 = (1 << v10) & 0x100002600;
      if (v10 > 0x20 || v11 == 0)
        return 0;
    }
    while (--v9);
  }
  v13 = a1[10];
  if (!v13)
    return 0;
  v14 = (xmlDoc *)a1[2];
  if (!v14)
  {
LABEL_21:
    v16 = *(unsigned __int8 **)(a1[7] + 32);
    v17 = *v16;
    if (v17 == 60 || v17 == 13)
    {
      v19 = (const xmlNode *)a1[10];
      v20 = v17 == 60 && v19->children == 0;
      if (!v20 || v16[1] != 47)
      {
        LastChild = xmlGetLastChild(v19);
        if (LastChild)
        {
          if (!xmlNodeIsText(LastChild))
          {
            v22 = *(const xmlNode **)(a1[10] + 24);
            if (!v22 || !xmlNodeIsText(v22))
              return 1;
          }
        }
        else
        {
          v23 = a1[10];
          if (*(_DWORD *)(v23 + 8) == 1 || !*(_QWORD *)(v23 + 80))
            return 1;
        }
      }
    }
    return 0;
  }
  IsMixedElement = xmlIsMixedElement(v14, *(const xmlChar **)(v13 + 16));
  if (IsMixedElement)
  {
    if (IsMixedElement == 1)
      return 0;
    goto LABEL_21;
  }
  return 1;
}

void xmlParseContentInternal(uint64_t a1)
{
  int v2;
  uint64_t v3;
  unsigned __int8 *v4;
  int v5;
  uint64_t v6;
  int v7;
  unsigned __int8 *v8;
  uint64_t v10;

  v2 = *(_DWORD *)(a1 + 296);
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(unsigned __int8 **)(v3 + 32);
  v5 = *v4;
  if (*v4)
  {
    do
    {
      if (*(_DWORD *)(a1 + 272) == -1)
        return;
      v6 = *(unsigned int *)(v3 + 64);
      if (v5 == 38)
      {
        xmlParseReference((xmlParserCtxtPtr)a1);
        goto LABEL_29;
      }
      if (v5 != 60)
      {
        xmlParseCharData((xmlParserCtxtPtr)a1, 0);
        goto LABEL_29;
      }
      v7 = v4[1];
      switch(v7)
      {
        case '!':
          if (v4[2] == 91 && v4[3] == 67 && v4[4] == 68 && v4[5] == 65 && v4[6] == 84 && v4[7] == 65 && v4[8] == 91)
          {
            xmlParseCDSect((xmlParserCtxtPtr)a1);
            break;
          }
          if (v4[2] != 45 || v4[3] != 45)
            goto LABEL_28;
          xmlParseComment((xmlParserCtxtPtr)a1);
          if (*(_DWORD *)(a1 + 272) != -1)
            *(_DWORD *)(a1 + 272) = 7;
          break;
        case '/':
          if (*(_DWORD *)(a1 + 296) <= v2)
            return;
          xmlParseElementEnd((xmlParserCtxt *)a1);
          break;
        case '?':
          xmlParsePI((xmlParserCtxtPtr)a1);
          break;
        default:
LABEL_28:
          xmlParseElementStart(a1);
          break;
      }
LABEL_29:
      v3 = *(_QWORD *)(a1 + 56);
      if (!*(_DWORD *)(a1 + 452))
      {
        if ((uint64_t)(*(_QWORD *)(v3 + 40) - *(_QWORD *)(v3 + 32)) > 249
          || (xmlGROW(a1), v3 = *(_QWORD *)(a1 + 56), !*(_DWORD *)(a1 + 452)))
        {
          v10 = *(_QWORD *)(v3 + 32);
          if (v10 - *(_QWORD *)(v3 + 24) >= 501 && *(_QWORD *)(v3 + 40) - v10 <= 499)
          {
            xmlSHRINK(a1);
            v3 = *(_QWORD *)(a1 + 56);
          }
        }
      }
      v8 = *(unsigned __int8 **)(v3 + 32);
      if (v6 == *(_QWORD *)(v3 + 64) && v4 == v8)
      {
        xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"detected an error in element content\n");
        xmlHaltParser((xmlParserCtxtPtr)a1);
        return;
      }
      v5 = *v8;
      v4 = *(unsigned __int8 **)(v3 + 32);
    }
    while (*v8);
  }
}

uint64_t xmlParseElementStart(uint64_t a1)
{
  int v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  int v7;
  const xmlChar *started;
  const xmlChar *v9;
  const xmlChar *v10;
  uint64_t v11;
  const _xmlNode *v12;
  xmlDoc *v13;
  xmlParserInput *v14;
  const xmlChar *cur;
  int v16;
  uint64_t v17;
  void (*v18)(_QWORD, const xmlChar *, const xmlChar *, uint64_t);
  int v19;
  uint64_t result;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  int v36;
  void (*v37)(_QWORD, const xmlChar *);
  int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  int v50;
  xmlParserNodeInfo info;
  uint64_t v52;
  const xmlChar *v53;

  v52 = 0;
  v53 = 0;
  v2 = *(_DWORD *)(a1 + 508);
  if (*(_DWORD *)(a1 + 296) > xmlParserMaxDepth && (*(_BYTE *)(a1 + 566) & 8) == 0)
  {
    xmlFatalErrMsgInt((_DWORD *)a1, 1, "Excessive depth in document: %d use XML_PARSE_HUGE option\n", xmlParserMaxDepth);
    xmlHaltParser((xmlParserCtxtPtr)a1);
    return 0xFFFFFFFFLL;
  }
  memset(&info, 0, sizeof(info));
  if (*(_DWORD *)(a1 + 104))
  {
    v3 = *(_QWORD *)(a1 + 56);
    v4 = *(_QWORD *)(v3 + 64) + *(_QWORD *)(v3 + 32) - *(_QWORD *)(v3 + 24);
    v5 = *(int *)(v3 + 52);
    info.begin_pos = v4;
    info.begin_line = v5;
  }
  if (*(_DWORD *)(a1 + 376))
  {
    if (**(_DWORD **)(a1 + 368) == -2)
      v6 = -1;
    else
      v6 = **(_DWORD **)(a1 + 368);
  }
  else
  {
    v6 = -1;
  }
  spacePush(a1, v6);
  v7 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 52);
  if (*(_DWORD *)(a1 + 504))
    started = xmlParseStartTag2(a1, &v53, &v52, &v50);
  else
    started = xmlParseStartTag((xmlParserCtxtPtr)a1);
  v9 = started;
  if (*(_DWORD *)(a1 + 272) == -1)
    return 0xFFFFFFFFLL;
  if (started)
  {
    v11 = v52;
    v10 = v53;
    nameNsPush((_DWORD *)a1, (uint64_t)started, (uint64_t)v53, v52, v7, *(_DWORD *)(a1 + 508) - v2);
    v12 = *(const _xmlNode **)(a1 + 80);
    if (*(_DWORD *)(a1 + 156))
    {
      if (*(_DWORD *)(a1 + 24))
      {
        v13 = *(xmlDoc **)(a1 + 16);
        if (v13)
        {
          if (v12 && v12 == v13->children)
            *(_DWORD *)(a1 + 152) &= xmlValidateRoot((xmlValidCtxtPtr)(a1 + 160), v13);
        }
      }
    }
    v14 = *(xmlParserInput **)(a1 + 56);
    cur = v14->cur;
    v16 = *cur;
    if (v16 == 62)
    {
      ++v14->col;
      v14->cur = cur + 1;
      if (!cur[1])
        xmlParserInputGrow(v14, 250);
      if (v12 && *(_DWORD *)(a1 + 104))
      {
        info.end_pos = 0;
        info.end_line = 0;
        info.node = v12;
        xmlParserAddNodeInfo((xmlParserCtxtPtr)a1, &info);
      }
      return 0;
    }
    else
    {
      if (v16 != 47 || cur[1] != 62)
      {
        xmlFatalErrMsgStrIntStr((_DWORD *)a1, 73, "Couldn't find end of Start Tag %s line %d\n", v9, v7, 0);
        v24 = *(_DWORD *)(a1 + 88);
        v25 = v24 - 1;
        if (v24 >= 1)
        {
          *(_DWORD *)(a1 + 88) = v25;
          v26 = *(_QWORD *)(a1 + 96);
          if (v24 == 1)
            v27 = 0;
          else
            v27 = *(_QWORD *)(v26 + 8 * (v24 - 2));
          *(_QWORD *)(a1 + 80) = v27;
          *(_QWORD *)(v26 + 8 * v25) = 0;
        }
        v28 = *(_DWORD *)(a1 + 296);
        v29 = v28 - 1;
        if (v28 >= 1)
        {
          *(_DWORD *)(a1 + 296) = v29;
          v30 = *(_QWORD *)(a1 + 304);
          if (v28 == 1)
            v31 = 0;
          else
            v31 = *(_QWORD *)(v30 + 8 * (v28 - 2));
          *(_QWORD *)(a1 + 288) = v31;
          *(_QWORD *)(v30 + 8 * v29) = 0;
        }
        v32 = *(_DWORD *)(a1 + 376);
        if (v32 >= 1)
        {
          v33 = v32 - 2;
          v34 = v32 - 1;
          *(_DWORD *)(a1 + 376) = v34;
          v35 = *(_QWORD *)(a1 + 384);
          if (!v34)
            v33 = 0;
          *(_QWORD *)(a1 + 368) = v35 + 4 * v33;
          *(_DWORD *)(v35 + 4 * v34) = -1;
        }
        v36 = *(_DWORD *)(a1 + 508);
        if (v36 != v2)
          nsPop(a1, v36 - v2);
        return 0xFFFFFFFFLL;
      }
      v14->cur = cur + 2;
      v14->col += 2;
      if (!cur[2])
        xmlParserInputGrow(v14, 250);
      v17 = *(_QWORD *)a1;
      if (*(_DWORD *)(a1 + 504))
      {
        if (v17)
        {
          v18 = *(void (**)(_QWORD, const xmlChar *, const xmlChar *, uint64_t))(v17 + 240);
          if (v18)
          {
            if (!*(_DWORD *)(a1 + 332))
              v18(*(_QWORD *)(a1 + 8), v9, v10, v11);
          }
        }
      }
      else if (v17)
      {
        v37 = *(void (**)(_QWORD, const xmlChar *))(v17 + 120);
        if (v37)
        {
          if (!*(_DWORD *)(a1 + 332))
            v37(*(_QWORD *)(a1 + 8), v9);
        }
      }
      v38 = *(_DWORD *)(a1 + 296);
      v39 = v38 - 1;
      if (v38 >= 1)
      {
        *(_DWORD *)(a1 + 296) = v39;
        v40 = *(_QWORD *)(a1 + 304);
        if (v38 == 1)
          v41 = 0;
        else
          v41 = *(_QWORD *)(v40 + 8 * (v38 - 2));
        *(_QWORD *)(a1 + 288) = v41;
        *(_QWORD *)(v40 + 8 * v39) = 0;
      }
      v42 = *(_DWORD *)(a1 + 376);
      if (v42 >= 1)
      {
        v43 = v42 - 2;
        v44 = v42 - 1;
        *(_DWORD *)(a1 + 376) = v44;
        v45 = *(_QWORD *)(a1 + 384);
        if (!v44)
          v43 = 0;
        *(_QWORD *)(a1 + 368) = v45 + 4 * v43;
        *(_DWORD *)(v45 + 4 * v44) = -1;
      }
      v46 = *(_DWORD *)(a1 + 508);
      if (v46 != v2)
        nsPop(a1, v46 - v2);
      if (v12)
      {
        if (*(_DWORD *)(a1 + 104))
        {
          v47 = *(_QWORD *)(a1 + 56);
          v48 = *(_QWORD *)(v47 + 64) + *(_QWORD *)(v47 + 32) - *(_QWORD *)(v47 + 24);
          info.node = v12;
          v49 = *(int *)(v47 + 52);
          info.end_pos = v48;
          info.end_line = v49;
          xmlParserAddNodeInfo((xmlParserCtxtPtr)a1, &info);
        }
      }
      return 1;
    }
  }
  else
  {
    v19 = *(_DWORD *)(a1 + 376);
    result = 0xFFFFFFFFLL;
    if (v19 >= 1)
    {
      v21 = v19 - 2;
      v22 = v19 - 1;
      *(_DWORD *)(a1 + 376) = v22;
      v23 = *(_QWORD *)(a1 + 384);
      if (!v22)
        v21 = 0;
      *(_QWORD *)(a1 + 368) = v23 + 4 * v21;
      *(_DWORD *)(v23 + 4 * v22) = -1;
    }
  }
  return result;
}

_DWORD *spacePush(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;
  _DWORD *result;
  uint64_t v7;

  v4 = *(_DWORD *)(a1 + 376);
  v5 = *(int *)(a1 + 380);
  if (v4 < (int)v5)
  {
    result = *(_DWORD **)(a1 + 384);
LABEL_5:
    result[v4] = a2;
    v7 = *(int *)(a1 + 376);
    *(_QWORD *)(a1 + 368) = &result[v7];
    *(_DWORD *)(a1 + 376) = v7 + 1;
    return result;
  }
  *(_DWORD *)(a1 + 380) = 2 * v5;
  result = xmlRealloc(*(void **)(a1 + 384), 8 * v5);
  if (result)
  {
    *(_QWORD *)(a1 + 384) = result;
    v4 = *(_DWORD *)(a1 + 376);
    goto LABEL_5;
  }
  result = htmlErrMemory((_DWORD *)a1, 0);
  *(int *)(a1 + 380) /= 2;
  return result;
}

_DWORD *nameNsPush(_DWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  _DWORD *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;

  v11 = result;
  v12 = (int)result[75];
  if (result[74] < (int)v12)
  {
    if (!*((_QWORD *)result + 67))
    {
      result = xmlMalloc(24 * v12);
      *((_QWORD *)v11 + 67) = result;
      if (!result)
        return htmlErrMemory(v11, 0);
    }
LABEL_8:
    v14 = (int)v11[74];
    *(_QWORD *)(*((_QWORD *)v11 + 38) + 8 * v14) = a2;
    *((_QWORD *)v11 + 36) = a2;
    v15 = *((_QWORD *)v11 + 67) + 24 * (int)v14;
    *(_QWORD *)v15 = a3;
    *(_QWORD *)(v15 + 8) = a4;
    *(_DWORD *)(v15 + 16) = a5;
    *(_DWORD *)(v15 + 20) = a6;
    v11[74] = v14 + 1;
    return result;
  }
  result[75] = 2 * v12;
  v13 = xmlRealloc(*((void **)result + 38), 16 * v12);
  if (v13)
  {
    *((_QWORD *)v11 + 38) = v13;
    result = xmlRealloc(*((void **)v11 + 67), 24 * (int)v11[75]);
    if (result)
    {
      *((_QWORD *)v11 + 67) = result;
      goto LABEL_8;
    }
  }
  v11[75] /= 2;
  return htmlErrMemory(v11, 0);
}

void xmlParseElementEnd(xmlParserCtxt *a1)
{
  int nameNr;
  BOOL v2;
  int v3;
  xmlNode *node;
  int v6;
  unsigned int v7;
  const xmlChar **nameTab;
  const xmlChar *v9;
  const xmlParserNodeInfo *NodeInfo;
  xmlParserInputPtr input;
  unint64_t v12;
  unint64_t line;

  nameNr = a1->nameNr;
  v2 = __OFSUB__(nameNr, 1);
  v3 = nameNr - 1;
  if (v3 < 0 != v2)
    return;
  node = a1->node;
  if (!a1->sax2)
  {
    xmlParseEndTag1(a1);
LABEL_8:
    if (!node)
      return;
    goto LABEL_11;
  }
  xmlParseEndTag2((uint64_t)a1, (_QWORD *)a1->pushTab + 3 * v3);
  v6 = a1->nameNr;
  v7 = v6 - 1;
  if (v6 < 1)
    goto LABEL_8;
  a1->nameNr = v7;
  nameTab = a1->nameTab;
  if (v6 == 1)
    v9 = 0;
  else
    v9 = nameTab[v6 - 2];
  a1->name = v9;
  nameTab[v7] = 0;
  if (node)
  {
LABEL_11:
    if (a1->record_info)
    {
      NodeInfo = xmlParserFindNodeInfo(a1, node);
      if (NodeInfo)
      {
        input = a1->input;
        v12 = &input->cur[input->consumed] - input->base;
        line = input->line;
        NodeInfo->end_pos = v12;
        NodeInfo->end_line = line;
      }
    }
  }
}

xmlParserInput *xmlSHRINK(uint64_t a1)
{
  xmlParserInput *result;

  xmlParserInputShrink(*(xmlParserInputPtr *)(a1 + 56));
  result = *(xmlParserInput **)(a1 + 56);
  if (!*result->cur)
    return (xmlParserInput *)xmlParserInputGrow(result, 250);
  return result;
}

void xmlParserInputShrink(xmlParserInputPtr in)
{
  const xmlChar *base;
  const xmlChar *cur;
  xmlBuf *buffer;
  int64_t v5;
  size_t v6;
  xmlChar *v7;

  if (in)
  {
    if (in->buf)
    {
      base = in->base;
      if (base)
      {
        cur = in->cur;
        if (cur)
        {
          buffer = in->buf->buffer;
          if (buffer)
          {
            v5 = cur - base;
            if ((unint64_t)(cur - base) >= 0xFB)
            {
              v6 = xmlBufShrink(buffer, v5 - 80);
              if (v6)
              {
                v5 -= v6;
                in->consumed += v6;
              }
            }
            if (xmlBufUse(in->buf->buffer) <= 0xFA)
              xmlParserInputBufferRead(in->buf, 500);
            v7 = xmlBufContent(in->buf->buffer);
            in->base = v7;
            in->cur = &v7[v5];
            in->end = xmlBufEnd(in->buf->buffer);
          }
        }
      }
    }
  }
}

size_t xmlBufShrink(xmlBufPtr buf, size_t len)
{
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  size_t v7;
  size_t v8;
  size_t v10;
  int v11;
  _BYTE *v12;
  _BYTE *v13;
  unint64_t v14;
  int64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;

  if (!buf || *((_DWORD *)buf + 14))
    return 0;
  v3 = len;
  v4 = *((_QWORD *)buf + 5);
  v5 = *((unsigned int *)buf + 3);
  if (v5 <= 0x7FFFFFFE && v4 != v5)
  {
    *((_QWORD *)buf + 5) = v5;
    v4 = v5;
  }
  v7 = *((_QWORD *)buf + 4);
  v8 = *((unsigned int *)buf + 2);
  if (v8 <= 0x7FFFFFFE && v7 != v8)
  {
    *((_QWORD *)buf + 4) = v8;
    v7 = v8;
  }
  if (len - 1 >= v7)
    return 0;
  v10 = v7 - len;
  *((_QWORD *)buf + 4) = v7 - len;
  v11 = *((_DWORD *)buf + 4);
  if (v11 == 2)
  {
    *(_QWORD *)buf += len;
    v14 = v4 - len;
    goto LABEL_23;
  }
  if (v11 == 3 && (v12 = (_BYTE *)*((_QWORD *)buf + 3)) != 0)
  {
    v13 = (_BYTE *)(*(_QWORD *)buf + len);
    *(_QWORD *)buf = v13;
    v14 = v4 - v3;
    *((_QWORD *)buf + 5) = v14;
    v15 = v13 - v12;
    if (v13 - v12 >= v14)
    {
      memmove(v12, v13, v10);
      v16 = *((_QWORD *)buf + 3);
      v17 = *((_QWORD *)buf + 4);
      *(_QWORD *)buf = v16;
      *(_BYTE *)(v16 + v17) = 0;
      v14 = *((_QWORD *)buf + 5) + v15;
LABEL_23:
      *((_QWORD *)buf + 5) = v14;
    }
  }
  else
  {
    memmove(*(void **)buf, (const void *)(*(_QWORD *)buf + len), v10);
    *(_BYTE *)(*(_QWORD *)buf + *((_QWORD *)buf + 4)) = 0;
    v14 = *((_QWORD *)buf + 5);
  }
  LODWORD(v19) = 0x7FFFFFFF;
  if (v14 >= 0x7FFFFFFF)
    LODWORD(v14) = 0x7FFFFFFF;
  if (*((_QWORD *)buf + 4) < 0x7FFFFFFFuLL)
    v19 = *((_QWORD *)buf + 4);
  *((_DWORD *)buf + 2) = v19;
  *((_DWORD *)buf + 3) = v14;
  return v3;
}

int xmlParserInputBufferRead(xmlParserInputBufferPtr in, int len)
{
  if (!in || in->error)
    return -1;
  if (in->readcallback)
    return xmlParserInputBufferGrow(in, len);
  if (xmlBufGetAllocationScheme((uint64_t)in->buffer) == 2)
    return 0;
  return -1;
}

uint64_t xmlParseLookupSequence(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v4;
  xmlChar *v5;
  uint64_t v6;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;

  v4 = *(_QWORD *)(a1 + 56);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = *(xmlChar **)(v4 + 24);
  v6 = *(_QWORD *)(v4 + 32) - (_QWORD)v5;
  if ((v6 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if (*(_QWORD *)(a1 + 320) <= (uint64_t)v6)
    v11 = *(_DWORD *)(v4 + 32) - (_DWORD)v5;
  else
    v11 = *(_QWORD *)(a1 + 320);
  if (*(_QWORD *)v4)
  {
    v5 = xmlBufContent(*(const xmlBuf **)(*(_QWORD *)v4 + 32));
    v12 = xmlBufUse(*(const xmlBufPtr *)(*(_QWORD *)v4 + 32));
  }
  else
  {
    v12 = *(_DWORD *)(v4 + 48);
  }
  if (a3)
    v13 = -1;
  else
    v13 = 0;
  if (a4)
    v13 = -2;
  v14 = v12 + v13;
  v15 = v11;
  if (v11 >= v14)
  {
LABEL_25:
    *(_QWORD *)(a1 + 320) = v15;
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    if (v5[v15] != a2)
    {
      v16 = v15 + 1;
      goto LABEL_23;
    }
    if (!a4)
      break;
    v16 = v15 + 1;
    if (v5[v15 + 1] == a3 && v5[v15 + 2] == a4)
      goto LABEL_27;
LABEL_23:
    v15 = v16;
    if (v16 == v14)
    {
      v15 = v14;
      goto LABEL_25;
    }
  }
  if (a3)
  {
    v16 = v15 + 1;
    if (v5[v15 + 1] != a3)
      goto LABEL_23;
  }
LABEL_27:
  *(_QWORD *)(a1 + 320) = 0;
  return (v15 + *(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 32));
}

void xmlParseComment(xmlParserCtxtPtr ctxt)
{
  unint64_t v2;
  xmlParserInputPtr input;
  const xmlChar *cur;
  xmlParserInputState instate;
  int id;
  const xmlChar *v7;
  char *v8;
  unint64_t v9;
  const xmlChar *v10;
  int v11;
  size_t v12;
  int v13;
  int v14;
  int col;
  int v16;
  int v18;
  int v19;
  int v20;
  unsigned __int8 *v21;
  size_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  int v26;
  unsigned __int8 *v27;
  const char *v28;
  const xmlChar *v29;
  int v30;
  commentSAXFunc comment;
  void *userData;
  xmlParserInputState v34;

  if ((ctxt->options & 0x80000) != 0)
    v2 = 1000000000;
  else
    v2 = 10000000;
  input = ctxt->input;
  cur = input->cur;
  if (*cur != 60 || cur[1] != 33 || cur[2] != 45 || cur[3] != 45)
    return;
  instate = ctxt->instate;
  ctxt->instate = XML_PARSER_COMMENT;
  id = input->id;
  input->cur = cur + 4;
  input->col += 4;
  if (!cur[4])
  {
    xmlParserInputGrow(input, 250);
    input = ctxt->input;
  }
  v34 = instate;
  if (!ctxt->progressive)
  {
    v7 = input->cur;
    if (v7 - input->base < 501
      || input->end - v7 > 499
      || (xmlSHRINK((uint64_t)ctxt), input = ctxt->input, !ctxt->progressive))
    {
      if (input->end - input->cur <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        input = ctxt->input;
      }
    }
  }
  v8 = 0;
  v9 = 0;
  v10 = input->cur;
  v11 = *v10;
  v12 = 100;
LABEL_17:
  if (v11 == 10)
  {
    v13 = input->line + 1;
    do
    {
      input->line = v13;
      input->col = 1;
      v14 = *++v10;
      ++v13;
    }
    while (v14 == 10);
  }
  while (1)
  {
    while (1)
    {
      col = input->col;
      while (1)
      {
        while (1)
        {
          if (*(char *)v10 <= 45)
          {
            v16 = *v10;
            if (v16 != 9 && (v16 - 32) > 0xC)
              break;
          }
          ++v10;
          ++col;
        }
        input->col = col;
        v18 = *v10;
        if (v18 != 10)
          break;
        v19 = input->line + 1;
        do
        {
          col = 1;
          input->line = v19;
          input->col = 1;
          v20 = *++v10;
          ++v19;
        }
        while (v20 == 10);
      }
      v21 = (unsigned __int8 *)input->cur;
      v22 = v10 - v21;
      if (v10 != v21 && ctxt->sax && ctxt->sax->comment)
      {
        if (v8)
        {
          if (v22 + v9 + 1 >= v12)
          {
            v12 += v22 + v9 + 100;
            v23 = (char *)xmlRealloc(v8, v12);
            if (!v23)
            {
              xmlFree(v8);
LABEL_88:
              htmlErrMemory(ctxt, 0);
              goto LABEL_89;
            }
            v8 = v23;
          }
        }
        else
        {
          if (v18 == 45 && v10[1] == 45)
            v24 = 1;
          else
            v24 = 100;
          v12 = v22 + v24;
          v25 = (char *)xmlMallocAtomic(v22 + v24);
          if (!v25)
            goto LABEL_88;
          v8 = v25;
          v9 = 0;
        }
        memcpy(&v8[v9], ctxt->input->cur, v22);
        v9 += v22;
        v8[v9] = 0;
      }
      if (v9 > v2)
      {
        xmlFatalErrMsgStr(ctxt, 45, "Comment too big found", 0);
LABEL_75:
        xmlFree(v8);
        return;
      }
      input = ctxt->input;
      input->cur = v10;
      v26 = *v10;
      v27 = (unsigned __int8 *)v10;
      if (v26 == 10)
      {
        ++input->line;
        input->col = 1;
        v27 = (unsigned __int8 *)(v10 + 1);
        v26 = v10[1];
      }
      if (v26 != 13 || v27[1] != 10)
        break;
      input->cur = v27 + 1;
      v10 = v27 + 2;
      ++input->line;
      input->col = 1;
    }
    if (!ctxt->progressive)
    {
      if (v10 - input->base < 501 || input->end - v10 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249)
          xmlGROW((uint64_t)ctxt);
      }
    }
    if (ctxt->instate == XML_PARSER_EOF)
      goto LABEL_75;
    input = ctxt->input;
    v10 = input->cur;
    v11 = *v10;
    if (v11 != 45)
    {
      if ((char)v11 > 31 || (v11 - 9) < 2)
        goto LABEL_17;
      xmlParseCommentComplex((uint64_t)ctxt, v8, v9, v12);
      goto LABEL_85;
    }
    if (v10[1] != 45)
    {
      v30 = input->col;
      goto LABEL_67;
    }
    if (v10[2] == 62)
      break;
    if (v8)
    {
      v28 = "Double hyphen within comment: <!--%.50s\n";
      v29 = (const xmlChar *)v8;
    }
    else
    {
      v28 = "Double hyphen within comment\n";
      v29 = 0;
    }
    xmlFatalErrMsgStr(ctxt, 80, v28, v29);
    if (ctxt->instate == XML_PARSER_EOF)
      goto LABEL_75;
    input = ctxt->input;
    v30 = input->col + 1;
    input->col = v30;
    ++v10;
LABEL_67:
    ++v10;
    input->col = v30 + 1;
  }
  if (input->id != id)
  {
    xmlFatalErrMsg(ctxt, 90, (char)"comment doesn't start and stop in the same entity\n");
    input = ctxt->input;
    v10 = input->cur;
  }
  input->cur = v10 + 3;
  input->col += 3;
  if (!v10[3])
    xmlParserInputGrow(input, 250);
  if (!ctxt->sax || (comment = ctxt->sax->comment) == 0 || ctxt->disableSAX)
  {
    if (!v8)
      goto LABEL_85;
    goto LABEL_84;
  }
  userData = ctxt->userData;
  if (v8)
  {
    ((void (*)(void *, char *))comment)(userData, v8);
LABEL_84:
    xmlFree(v8);
    goto LABEL_85;
  }
  ((void (*)(void *, char *))comment)(userData, &byte_1B0865C1A);
LABEL_85:
  if (ctxt->instate == XML_PARSER_EOF)
    return;
LABEL_89:
  ctxt->instate = v34;
}

uint64_t xmlParseGetLasts(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  unint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  int v10;
  _BYTE *v11;
  _BYTE *v12;
  void **v13;
  unint64_t v14;
  int v15;
  xmlGenericErrorFunc v16;

  if (!a2 || !a3)
  {
    v16 = *__xmlGenericError();
    v13 = __xmlGenericErrorContext();
    return ((uint64_t (*)(void *, const char *))v16)(*v13, "Internal error: xmlParseGetLasts\n");
  }
  if (!*(_DWORD *)(result + 452) || *(_DWORD *)(result + 64) != 1)
  {
LABEL_25:
    *a2 = 0;
    goto LABEL_26;
  }
  v3 = *(_QWORD *)(result + 56);
  v4 = *(_QWORD *)(v3 + 24);
  v5 = (unsigned __int8 *)(*(_QWORD *)(v3 + 40) - 1);
  do
  {
    if ((unint64_t)v5 < v4)
      goto LABEL_25;
    v6 = *v5--;
  }
  while (v6 != 60);
  *a2 = v5 + 1;
  v7 = *(_QWORD *)(result + 56);
  v8 = *(_QWORD *)(v7 + 40);
  v9 = v5 + 2;
  while ((unint64_t)v9 < v8)
  {
    v10 = *v9;
    switch(v10)
    {
      case '"':
        v11 = v9 + 1;
        do
        {
          v9 = v11;
          if ((unint64_t)v11 >= v8)
            break;
          ++v11;
        }
        while (*v9 != 34);
LABEL_21:
        if ((unint64_t)v9 < v8)
          ++v9;
        break;
      case '\'':
        v12 = v9 + 1;
        do
        {
          v9 = v12;
          if ((unint64_t)v12 >= v8)
            break;
          ++v12;
        }
        while (*v9 != 39);
        goto LABEL_21;
      case '>':
        *a3 = v9;
        return result;
      default:
        ++v9;
        break;
    }
  }
  v14 = *(_QWORD *)(v7 + 24);
  while ((unint64_t)v5 >= v14)
  {
    v15 = *v5--;
    if (v15 == 62)
    {
      *a3 = v5 + 1;
      return result;
    }
  }
LABEL_26:
  *a3 = 0;
  return result;
}

uint64_t xmlTextReaderCharacters(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  v1 = *(_QWORD *)(result + 424);
  if (v1)
  {
    v2 = *(uint64_t (**)(void))(v1 + 88);
    if (v2)
      return v2();
  }
  return result;
}

int xmlParserInputBufferPush(xmlParserInputBufferPtr in, int len, const char *buf)
{
  size_t v4;
  xmlBuf *raw;
  unsigned int v8;
  int v9;

  if (len < 0)
  {
    LODWORD(v4) = 0;
  }
  else
  {
    if (in && !in->error)
    {
      v4 = *(_QWORD *)&len;
      if (in->encoder)
      {
        raw = in->raw;
        if (!raw)
        {
          raw = (xmlBuf *)xmlBufCreate();
          in->raw = raw;
        }
        if (!xmlBufAdd((uint64x2_t *)raw, (const xmlChar *)buf, v4))
        {
          v8 = xmlBufUse(in->raw);
          v9 = xmlCharEncInput((uint64_t)in, 1);
          if ((v9 & 0x80000000) == 0)
          {
            LODWORD(v4) = v9;
            in->rawconsumed = in->rawconsumed - xmlBufUse(in->raw) + v8;
            return v4;
          }
          __xmlSimpleError(8u, 1544, 0, "encoder error", 0);
          in->error = 1544;
        }
      }
      else if (!xmlBufAdd((uint64x2_t *)in->buffer, (const xmlChar *)buf, *(size_t *)&len))
      {
        return v4;
      }
    }
    LODWORD(v4) = -1;
  }
  return v4;
}

uint64_t xmlBufSetInputBaseCur(uint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a2)
    return 0xFFFFFFFFLL;
  if (!a1 || *((_DWORD *)a1 + 14))
  {
    a2[4] = &byte_1B0865C1A;
    a2[5] = &byte_1B0865C1A;
    a2[3] = &byte_1B0865C1A;
    return 0xFFFFFFFFLL;
  }
  v6 = *((unsigned int *)a1 + 3);
  if (v6 <= 0x7FFFFFFE && a1[5] != v6)
    a1[5] = v6;
  v8 = a1[4];
  v9 = *((unsigned int *)a1 + 2);
  if (v9 <= 0x7FFFFFFE && v8 != v9)
  {
    a1[4] = v9;
    v8 = v9;
  }
  v4 = 0;
  v10 = *a1;
  v11 = *a1 + a3;
  a2[3] = v11;
  a2[4] = v11 + a4;
  a2[5] = v10 + v8;
  return v4;
}

unint64_t xmlBufGetInputBase(uint64_t a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;

  result = 0;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 56))
    {
      return 0;
    }
    else
    {
      v4 = *(_QWORD *)(a1 + 40);
      v5 = *(unsigned int *)(a1 + 12);
      if (v5 <= 0x7FFFFFFE && v4 != v5)
      {
        *(_QWORD *)(a1 + 40) = v5;
        v4 = v5;
      }
      v7 = *(unsigned int *)(a1 + 8);
      if (v7 <= 0x7FFFFFFE && *(_QWORD *)(a1 + 32) != v7)
        *(_QWORD *)(a1 + 32) = v7;
      result = *(_QWORD *)(a2 + 24) - *(_QWORD *)a1;
      if (result > v4)
      {
        __xmlSimpleError(0x1Du, 7000, 0, 0, (const xmlChar *)"Input reference outside of the buffer");
        result = 0;
        if (!*(_DWORD *)(a1 + 56))
        {
          result = 0;
          *(_DWORD *)(a1 + 56) = 7000;
        }
      }
    }
  }
  return result;
}

uint64_t xmlTextReaderEndElementNs(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  v1 = *(_QWORD *)(result + 424);
  if (v1)
  {
    v2 = *(uint64_t (**)(void))(v1 + 80);
    if (v2)
      return v2();
  }
  return result;
}

uint64_t nsPop(uint64_t result, int a2)
{
  int v2;
  uint64_t v3;
  int v4;
  xmlGenericErrorFunc v5;
  void **v6;
  uint64_t v8;

  if (*(_QWORD *)(result + 520))
  {
    v2 = a2;
    v3 = result;
    v4 = *(_DWORD *)(result + 508);
    if (v4 < a2)
    {
      v5 = *__xmlGenericError();
      v6 = __xmlGenericErrorContext();
      result = ((uint64_t (*)(void *, const char *, ...))v5)(*v6, "Pbm popping %d NS\n", v2);
      v4 = *(_DWORD *)(v3 + 508);
      v2 = v4;
    }
    if (v4 >= 1 && v2 >= 1)
    {
      v8 = 8 * v4 - 8;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v3 + 520) + v8) = 0;
        --v4;
        v8 -= 8;
        --v2;
      }
      while (v2);
      *(_DWORD *)(v3 + 508) = v4;
    }
  }
  return result;
}

void xmlSAX2Comment(void *ctx, const xmlChar *value)
{
  uint64_t v3;
  xmlNodePtr v4;
  xmlNode *v5;
  uint64_t v6;
  int v7;
  int v8;
  xmlNode *v9;

  if (ctx)
  {
    v3 = *((_QWORD *)ctx + 10);
    v4 = xmlNewDocComment(*((xmlDocPtr *)ctx + 2), value);
    if (v4)
    {
      v5 = v4;
      if (*((_DWORD *)ctx + 109))
      {
        v6 = *((_QWORD *)ctx + 7);
        if (v6)
        {
          v7 = *(_DWORD *)(v6 + 52);
          if (v7 >= 0xFFFF)
            LOWORD(v7) = -1;
          v4->line = v7;
        }
      }
      v8 = *((_DWORD *)ctx + 84);
      if (v8 == 2)
      {
        v9 = *(xmlNode **)(*((_QWORD *)ctx + 2) + 88);
      }
      else if (v8 == 1)
      {
        v9 = *(xmlNode **)(*((_QWORD *)ctx + 2) + 80);
      }
      else if (v3)
      {
        v9 = (xmlNode *)v3;
        if (*(_DWORD *)(v3 + 8) != 1)
        {
          xmlAddSibling((xmlNodePtr)v3, v5);
          return;
        }
      }
      else
      {
        v9 = (xmlNode *)*((_QWORD *)ctx + 2);
      }
      xmlAddChild(v9, v5);
    }
  }
}

xmlNodePtr xmlNewDocComment(xmlDocPtr doc, const xmlChar *content)
{
  xmlNodePtr result;

  result = xmlNewComment(content);
  if (result)
    result->doc = doc;
  return result;
}

xmlNodePtr xmlNewComment(const xmlChar *content)
{
  xmlNode *v2;
  xmlNode *v3;
  xmlRegisterNodeFunc *v4;

  v2 = (xmlNode *)xmlMalloc(0x78uLL);
  v3 = v2;
  if (v2)
  {
    *(_OWORD *)&v2->_private = 0u;
    *(_OWORD *)&v2->name = 0u;
    *(_QWORD *)&v2->line = 0;
    *(_OWORD *)&v2->content = 0u;
    *(_OWORD *)&v2->nsDef = 0u;
    *(_OWORD *)&v2->next = 0u;
    *(_OWORD *)&v2->doc = 0u;
    *(_OWORD *)&v2->last = 0u;
    v2->type = XML_COMMENT_NODE;
    v2->name = "comment";
    if (content)
      v2->content = xmlStrdup(content);
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v4 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v4)(v3);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building comment");
  }
  return v3;
}

const xmlChar *__cdecl xmlParseStartTag(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  const xmlChar **atts;
  int maxatts;
  const xmlChar *v6;
  uint64_t v7;
  xmlParserInputPtr v8;
  const xmlChar *v9;
  unsigned int v10;
  BOOL v11;
  uint64_t consumed_low;
  xmlChar *v13;
  xmlChar *v14;
  uint64_t v15;
  const xmlChar **v16;
  xmlChar **v17;
  xmlParserInputPtr v18;
  const xmlChar *v19;
  int v20;
  xmlParserInputPtr v21;
  const xmlChar *v22;
  startElementSAXFunc startElement;
  void *userData;
  uint64_t v25;
  xmlChar *v26;
  xmlChar *value;

  input = ctxt->input;
  cur = input->cur;
  if (*cur != 60)
    return 0;
  atts = ctxt->atts;
  maxatts = ctxt->maxatts;
  ++input->col;
  input->cur = cur + 1;
  if (!cur[1])
    xmlParserInputGrow(input, 250);
  v6 = xmlParseName(ctxt);
  if (!v6)
  {
    xmlFatalErrMsg(ctxt, 68, (char)"xmlParseStartTag: invalid element name\n");
    return v6;
  }
  xmlSkipBlankChars(ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  LODWORD(v7) = 0;
  value = 0;
  while (1)
  {
    v8 = ctxt->input;
    v9 = v8->cur;
    v10 = *v9;
    if (v10 == 47)
    {
      if (v9[1] == 62)
        goto LABEL_62;
    }
    else
    {
      if (v10 == 62)
        goto LABEL_62;
      v11 = v10 - 9 < 2 || v10 == 13;
      if (!v11 && v10 < 0x20)
        goto LABEL_62;
    }
    if (ctxt->instate == XML_PARSER_EOF)
      goto LABEL_62;
    consumed_low = LODWORD(v8->consumed);
    v13 = (xmlChar *)xmlParseAttribute(ctxt, &value);
    v14 = value;
    if (v13 && value)
    {
      if ((int)v7 < 1)
      {
        if (!atts)
        {
          v16 = (const xmlChar **)xmlMalloc(0xB0uLL);
          if (!v16)
          {
            htmlErrMemory(ctxt, 0);
            xmlFree(v14);
            atts = 0;
            maxatts = 22;
            goto LABEL_39;
          }
          maxatts = 22;
LABEL_37:
          ctxt->atts = v16;
          ctxt->maxatts = maxatts;
          atts = v16;
LABEL_38:
          v17 = (xmlChar **)&atts[(int)v7];
          *v17 = v13;
          v17[1] = value;
          v7 = (int)v7 + 2;
          atts[v7] = 0;
          v17[3] = 0;
          goto LABEL_39;
        }
LABEL_29:
        if ((int)v7 + 4 <= maxatts)
          goto LABEL_38;
        maxatts *= 2;
        v16 = (const xmlChar **)xmlRealloc(atts, 8 * maxatts);
        if (v16)
          goto LABEL_37;
        htmlErrMemory(ctxt, 0);
      }
      else
      {
        v15 = 0;
        while (!xmlStrEqual(atts[v15], v13))
        {
          v15 += 2;
          if ((int)v7 <= (int)v15)
            goto LABEL_29;
        }
        xmlErrAttributeDup(ctxt, 0, v13);
      }
    }
    else if (!value)
    {
      goto LABEL_39;
    }
    xmlFree(v14);
LABEL_39:
    v18 = ctxt->input;
    if (!ctxt->progressive && v18->end - v18->cur <= 249)
    {
      xmlGROW((uint64_t)ctxt);
      v18 = ctxt->input;
    }
    v19 = v18->cur;
    v20 = *v19;
    if (v20 == 47)
    {
      if (v19[1] == 62)
        goto LABEL_62;
    }
    else if (v20 == 62)
    {
      goto LABEL_62;
    }
    if (!xmlSkipBlankChars(ctxt))
      xmlFatalErrMsg(ctxt, 65, (char)"attributes construct error\n");
    v21 = ctxt->input;
    if (consumed_low == v21->consumed && !v13 && v9 == v21->cur && !value)
      break;
    if (!ctxt->progressive)
    {
      v22 = v21->cur;
      if (v22 - v21->base < 501 || v21->end - v22 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249)
          xmlGROW((uint64_t)ctxt);
      }
    }
  }
  xmlFatalErrMsg(ctxt, 1, (char)"xmlParseStartTag: problem parsing attributes\n");
LABEL_62:
  if (ctxt->sax && (startElement = ctxt->sax->startElement) != 0 && !ctxt->disableSAX)
  {
    userData = ctxt->userData;
    if ((int)v7 >= 1)
    {
      ((void (*)(void *, const xmlChar *, const xmlChar **))startElement)(userData, v6, atts);
      goto LABEL_67;
    }
    ((void (*)(void *, const xmlChar *, _QWORD))startElement)(userData, v6, 0);
  }
  else
  {
LABEL_67:
    if (atts && (int)v7 >= 2)
    {
      v25 = 1;
      do
      {
        v26 = (xmlChar *)atts[v25];
        if (v26)
          xmlFree(v26);
        v25 += 2;
      }
      while ((int)v7 > (int)v25);
    }
  }
  return v6;
}

const xmlChar *__cdecl xmlParseName(xmlParserCtxtPtr ctxt)
{
  unint64_t v2;
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v5;
  unint64_t i;
  int v7;
  const xmlChar *v10;
  const xmlChar *v11;
  xmlParserInputPtr v12;
  int v13;
  signed int v14;
  signed int v15;
  int32x4_t v16;
  unsigned __int8 v17;
  BOOL v18;
  BOOL v19;
  int v20;
  xmlParserInputPtr v21;
  const xmlChar *v22;
  const xmlChar *v23;
  xmlParserInputPtr v24;
  const xmlChar *v25;
  const xmlChar *v26;
  unsigned int v27;
  int v28;
  int32x4_t v29;
  int v30;
  xmlParserInputPtr v31;
  const xmlChar *v32;
  const xmlChar *v33;
  int v34;
  signed int v35;
  signed int v37;
  int v38;
  xmlParserInputPtr v39;
  const xmlChar *v40;
  const xmlChar *v41;
  int v42;
  const char *v43;
  xmlParserCtxtPtr v44;
  int v45;
  const xmlChar *v47;
  xmlDict *dict;
  const xmlChar *v49;
  int len;

  if ((ctxt->options & 0x80000) != 0)
    v2 = 10000000;
  else
    v2 = 50000;
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  input = ctxt->input;
  cur = input->cur;
  v5 = *cur;
  if ((v5 & 0xFFFFFFDF) - 65 >= 0x1A && v5 != 95 && v5 != 58)
    goto LABEL_26;
  for (i = 1; ; ++i)
  {
    v7 = cur[i];
    if ((v7 - 48) >= 0xA
      && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
      && ((v7 - 45) > 0x32 || ((1 << (v7 - 45)) & 0x4000000002003) == 0))
    {
      break;
    }
  }
  if (!cur[i] || (v7 & 0x80) != 0)
  {
LABEL_26:
    if ((ctxt->options & 0x80000) != 0)
      v13 = 10000000;
    else
      v13 = 50000;
    if (!ctxt->progressive && input->end - cur <= 249)
      xmlGROW((uint64_t)ctxt);
    if (ctxt->instate == XML_PARSER_EOF)
      return 0;
    len = 0;
    v14 = xmlCurrentChar(ctxt, &len);
    v15 = v14;
    if ((ctxt->options & 0x20000) == 0)
    {
      if (v14 <= 0x3E && ((1 << v14) & 0x4000800100000000) != 0)
        return 0;
      if ((v14 & 0xFFFFFFDF) - 65 >= 0x1A && v14 != 58 && v14 != 95)
      {
        v16 = vdupq_n_s32(v14);
        v17 = vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B08622B0, (uint32x4_t)vaddq_s32(v16, (int32x4_t)xmmword_1B0862290)), (int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B08622C0, (uint32x4_t)vaddq_s32(v16, (int32x4_t)xmmword_1B08622A0)))));
        v18 = (v14 - 65008) >= 0x20E && (v14 - 0x10000) >= 0xE0000;
        v19 = !v18;
        if (!(v17 & 1 | ((v14 - 63744) < 0x4D0) | v19) && (v14 & 0xFFFFFFFE) != 0x200C)
          return 0;
      }
      v20 = len;
      v21 = ctxt->input;
      v22 = v21->cur;
      v23 = &v22[len];
      if (v23 <= v21->end)
      {
        if (*v22 == 10)
        {
          ++v21->line;
          v21->col = 1;
        }
        else
        {
          ++v21->col;
        }
        v21->cur = v23;
      }
      v27 = xmlCurrentChar(ctxt, &len);
      v28 = 0;
      while (v27 > 0x3E || ((1 << v27) & 0x4000800100000000) == 0)
      {
        if (v27 - 48 >= 0xB
          && (v27 & 0xFFFFFFDF) - 65 >= 0x1A
          && (v27 - 45 > 0x32 || ((1 << (v27 - 45)) & 0x4000000000003) == 0)
          && v27 != 183)
        {
          v29 = vdupq_n_s32(v27);
          if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B08622F0, (uint32x4_t)vaddq_s32(v29, (int32x4_t)xmmword_1B08622D0)), (int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B0862300, (uint32x4_t)vaddq_s32(v29, (int32x4_t)xmmword_1B08622E0))))) & 1) == 0&& v27 - 63744 >= 0x4D0&& v27 - 65008 >= 0x20E&& v27 - 0x10000 >= 0xE0000&& (v27 & 0xFFFFFFFE) != 0x200C)
          {
            break;
          }
        }
        if (v28 < 101)
        {
          ++v28;
        }
        else
        {
          if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
            xmlGROW((uint64_t)ctxt);
          if (ctxt->instate == XML_PARSER_EOF)
            return 0;
          v28 = 0;
        }
        if (v20 <= (len ^ 0x7FFFFFFF))
          v30 = len;
        else
          v30 = 0;
        v31 = ctxt->input;
        v32 = v31->cur;
        v33 = &v32[len];
        if (v33 <= v31->end)
        {
          if (*v32 == 10)
          {
            ++v31->line;
            v31->col = 1;
          }
          else
          {
            ++v31->col;
          }
          v31->cur = v33;
        }
        v20 += v30;
        v27 = xmlCurrentChar(ctxt, &len);
        if (!v27)
        {
          v11 = 0;
          if (ctxt->instate == XML_PARSER_EOF)
            return v11;
        }
      }
LABEL_139:
      if (v20 <= v13)
      {
        v47 = ctxt->input->cur;
        if (v47 - ctxt->input->base >= v20)
        {
          if (*v47 == 10 && *(v47 - 1) == 13)
          {
            dict = ctxt->dict;
            v49 = &v47[~v20];
          }
          else
          {
            dict = ctxt->dict;
            v49 = &v47[-v20];
          }
          return xmlDictLookup(dict, v49, v20);
        }
        v43 = "unexpected change of input buffer";
        v44 = ctxt;
        v45 = 1;
LABEL_141:
        xmlFatalErr(v44, v45, (const xmlChar *)v43);
        return 0;
      }
LABEL_140:
      v43 = "Name";
      v44 = ctxt;
      v45 = 110;
      goto LABEL_141;
    }
    if (v14 <= 0x3E && ((1 << v14) & 0x4000800100000000) != 0)
      return 0;
    if (v14 > 255)
    {
      if (!xmlCharInRange(v14, &xmlIsBaseCharGroup)
        && (v15 - 12321) >= 9
        && v15 != 12295
        && (v15 - 19968) >= 0x51A6)
      {
        return 0;
      }
    }
    else if ((v14 & 0xFFFFFFDF) - 65 >= 0x1A
           && (v14 - 192) >= 0x17
           && v14 <= 247
           && (v14 - 216) >= 0x1F
           && v14 != 95
           && v14 != 58)
    {
      return 0;
    }
    v20 = len;
    v24 = ctxt->input;
    v25 = v24->cur;
    v26 = &v25[len];
    if (v26 <= v24->end)
    {
      if (*v25 == 10)
      {
        ++v24->line;
        v24->col = 1;
      }
      else
      {
        ++v24->col;
      }
      v24->cur = v26;
    }
    v34 = 0;
    while (1)
    {
      v35 = xmlCurrentChar(ctxt, &len);
      if (v35 <= 0x3E && ((1 << v35) & 0x4000800100000000) != 0)
        goto LABEL_139;
      v37 = v35;
      if (v35 > 255)
      {
        if (xmlCharInRange(v35, &xmlIsBaseCharGroup)
          || (v37 - 12321) < 9
          || v37 == 12295
          || (v37 - 19968) < 0x51A6
          || xmlCharInRange(v37, &xmlIsDigitGroup))
        {
          goto LABEL_119;
        }
      }
      else if ((v35 - 192) < 0x17
             || (v35 & 0xFFFFFFDF) - 65 < 0x1A
             || (v35 - 48) < 0xA
             || v35 > 247
             || (v35 - 216) < 0x1F)
      {
        goto LABEL_119;
      }
      if ((v37 - 45) > 0x32 || ((1 << (v37 - 45)) & 0x4000000002003) == 0)
      {
        if (v37 >= 256)
        {
          if (xmlCharInRange(v37, &xmlIsCombiningGroup))
            goto LABEL_119;
          v42 = xmlCharInRange(v37, &xmlIsExtenderGroup);
        }
        else
        {
          v42 = v37 == 183;
        }
        if (!v42)
          goto LABEL_139;
      }
LABEL_119:
      if (v34 < 101)
      {
        ++v34;
      }
      else
      {
        if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
          xmlGROW((uint64_t)ctxt);
        if (ctxt->instate == XML_PARSER_EOF)
          return 0;
        v34 = 0;
      }
      if (v20 <= (len ^ 0x7FFFFFFF))
        v38 = len;
      else
        v38 = 0;
      v20 += v38;
      v39 = ctxt->input;
      v40 = v39->cur;
      v41 = &v40[len];
      if (v41 <= v39->end)
      {
        if (*v40 == 10)
        {
          ++v39->line;
          v39->col = 1;
        }
        else
        {
          ++v39->col;
        }
        v39->cur = v41;
      }
    }
  }
  if (i > v2)
    goto LABEL_140;
  v10 = &cur[i];
  v11 = xmlDictLookup(ctxt->dict, cur, i);
  v12 = ctxt->input;
  v12->cur = v10;
  v12->col += i;
  if (!v11)
  {
    htmlErrMemory(ctxt, 0);
    return 0;
  }
  return v11;
}

int xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader)
{
  uint64_t v1;
  uint64_t *v2;
  int v3;
  uint64_t v4;

  if (!reader)
    return -1;
  v1 = *((_QWORD *)reader + 14);
  if (!v1)
    return -1;
  if (*(_DWORD *)(v1 + 8) != 1)
    return 0;
  v2 = (uint64_t *)*((_QWORD *)reader + 15);
  if (!v2)
  {
    v4 = *(_QWORD *)(v1 + 96);
    if (!v4)
      goto LABEL_11;
LABEL_12:
    *((_QWORD *)reader + 15) = v4;
    return 1;
  }
  v3 = *((_DWORD *)v2 + 2);
  if (v3 == 2)
  {
    v4 = v2[6];
    if (v4)
      goto LABEL_12;
    return 0;
  }
  if (v3 != 18)
    return 0;
  v4 = *v2;
  if (v4)
    goto LABEL_12;
LABEL_11:
  v4 = *(_QWORD *)(v1 + 88);
  if (v4)
    goto LABEL_12;
  return 0;
}

uint64_t htmlCompareTags(const xmlChar *a1, const xmlChar **a2)
{
  return xmlStrcasecmp(a1, *a2);
}

int xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader)
{
  uint64_t v1;

  if (!reader)
    return -1;
  v1 = *((_QWORD *)reader + 14);
  if (!v1)
    return -1;
  if (*(_DWORD *)(v1 + 8) != 1 || *((_QWORD *)reader + 15) || *(_QWORD *)(v1 + 24) || *((_DWORD *)reader + 6) == 2)
    return 0;
  if (*((_QWORD *)reader + 1) || *((int *)reader + 74) > 0)
    return 1;
  return *(_WORD *)(v1 + 114) & 1;
}

const htmlEntityDesc *__cdecl htmlParseEntityRef(htmlParserCtxtPtr ctxt, const xmlChar **str)
{
  xmlParserInputPtr input;
  const xmlChar *v5;
  const xmlChar *v6;
  xmlParserInputPtr v7;
  const htmlEntityDesc *v8;
  uint64_t v9;
  const htmlEntityDesc *result;

  if (str)
    *str = 0;
  if (!ctxt)
    return 0;
  input = ctxt->input;
  if (!input || *input->cur != 38)
    return 0;
  xmlNextChar(ctxt);
  v5 = htmlParseName((uint64_t)ctxt);
  if (!v5)
  {
    htmlParseErr(ctxt, 68, "htmlParseEntityRef: no name\n", 0, 0);
    return 0;
  }
  v6 = v5;
  v7 = ctxt->input;
  if (!ctxt->progressive && v7->end - v7->cur <= 249)
  {
    xmlParserInputGrow(v7, 250);
    v7 = ctxt->input;
  }
  if (*v7->cur != 59)
  {
    htmlParseErr(ctxt, 23, "htmlParseEntityRef: expecting ';'\n", 0, 0);
    if (str)
    {
      result = 0;
      *str = v6;
      return result;
    }
    return 0;
  }
  if (str)
    *str = v6;
  v8 = (const htmlEntityDesc *)html40EntitiesTable;
  v9 = 253;
  while (!xmlStrEqual(v6, (const xmlChar *)v8->name))
  {
    result = 0;
    ++v8;
    if (!--v9)
      return result;
  }
  xmlNextChar(ctxt);
  return v8;
}

const xmlChar *htmlParseNameComplex(uint64_t a1)
{
  uint64_t v1;
  xmlParserInput *v2;
  const xmlChar *base;
  signed int v4;
  signed int v5;
  BOOL v7;
  int v10;
  int v11;
  BOOL v12;
  BOOL v14;
  xmlParserInput *v15;
  int v16;
  uint64_t v17;
  _BYTE *v18;
  _BYTE *v19;
  uint64_t v20;
  int v21;

_htmlParseNameComplex:
  v1 = a1;
  v2 = *(xmlParserInput **)(a1 + 56);
  base = v2->base;
  if (!*(_DWORD *)(v1 + 452) && v2->end - v2->cur <= 249)
    xmlParserInputGrow(v2, 250);
  v21 = 0;
  v4 = htmlCurrentChar(v1, &v21);
  v5 = v4;
  if (v4 <= 0x3E && ((1 << v4) & 0x4000800100000000) != 0)
    return 0;
  if (v4 > 255)
  {
    if (xmlCharInRange(v4, &xmlIsBaseCharGroup))
      v7 = 1;
    else
      v7 = (v5 - 12330) > 0xFFFFFFF6;
    if (!v7 && v5 != 12295 && (v5 - 40870) < 0xFFFFAE5A)
      return 0;
  }
  else if ((v4 - 192) >= 0x17
         && (v4 & 0xFFFFFFDF) - 65 >= 0x1A
         && v4 <= 247
         && (v4 - 216) >= 0x1F
         && v4 != 95
         && v4 != 58)
  {
    return 0;
  }
  v10 = 0;
  v11 = 0;
  while (v5 > 0x3E || ((1 << v5) & 0x4000800100000000) == 0)
  {
    if (v5 > 255)
    {
      if (xmlCharInRange(v5, &xmlIsBaseCharGroup))
        v12 = 0;
      else
        v12 = (v5 - 12321) >= 9;
      v14 = v12 && v5 != 12295 && (v5 - 19968) >= 0x51A6;
      if (!v14 || xmlCharInRange(v5, &xmlIsDigitGroup))
        goto LABEL_50;
    }
    else if ((v5 - 192) < 0x17
           || (v5 & 0xFFFFFFDF) - 65 < 0x1A
           || (v5 - 48) < 0xA
           || v5 > 247
           || (v5 - 216) < 0x1F)
    {
      goto LABEL_50;
    }
    if ((v5 - 45) > 0x32 || ((1 << (v5 - 45)) & 0x4000000002003) == 0)
    {
      if (v5 >= 256)
      {
        if (!xmlCharInRange(v5, &xmlIsCombiningGroup) && !xmlCharInRange(v5, &xmlIsExtenderGroup))
          break;
      }
      else if (v5 != 183)
      {
        break;
      }
    }
LABEL_50:
    if (v11 >= 101)
    {
      if (!*(_DWORD *)(v1 + 452))
      {
        v15 = *(xmlParserInput **)(v1 + 56);
        if (v15->end - v15->cur <= 249)
          xmlParserInputGrow(v15, 250);
      }
      v11 = 0;
    }
    else
    {
      ++v11;
    }
    v16 = v21;
    v17 = *(_QWORD *)(v1 + 56);
    v18 = *(_BYTE **)(v17 + 32);
    v19 = &v18[v21];
    if ((unint64_t)v19 <= *(_QWORD *)(v17 + 40))
    {
      if (*v18 == 10)
      {
        ++*(_DWORD *)(v17 + 52);
        *(_DWORD *)(v17 + 56) = 1;
      }
      else
      {
        ++*(_DWORD *)(v17 + 56);
      }
      *(_DWORD *)(v1 + 276) = 0;
      *(_QWORD *)(v17 + 32) = v19;
      ++*(_QWORD *)(v1 + 312);
    }
    v10 += v16;
    v5 = htmlCurrentChar(v1, &v21);
    if (*(const xmlChar **)(*(_QWORD *)(v1 + 56) + 24) != base)
    {
      a1 = v1;
      goto _htmlParseNameComplex;
    }
  }
  v20 = *(_QWORD *)(*(_QWORD *)(v1 + 56) + 32);
  if (v20 - *(_QWORD *)(*(_QWORD *)(v1 + 56) + 24) < v10)
  {
    htmlParseErr((_DWORD *)v1, 1, "unexpected change of input buffer", 0, 0);
    return 0;
  }
  return xmlDictLookup(*(xmlDictPtr *)(v1 + 456), (const xmlChar *)(v20 - v10), v10);
}

const xmlChar *htmlParseName(uint64_t a1)
{
  xmlParserInput *v2;
  uint64_t v3;
  const xmlChar *v4;
  int v5;
  uint64_t i;
  int v7;
  const xmlChar *v10;
  const xmlChar *result;
  uint64_t v12;

  if (!*(_DWORD *)(a1 + 452))
  {
    v2 = *(xmlParserInput **)(a1 + 56);
    if (v2->end - v2->cur <= 249)
      xmlParserInputGrow(v2, 250);
  }
  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(const xmlChar **)(v3 + 32);
  v5 = *v4;
  if ((v5 & 0xFFFFFFDF) - 65 >= 0x1A && v5 != 95 && v5 != 58)
    return htmlParseNameComplex(a1);
  for (i = 1; ; ++i)
  {
    v7 = v4[i];
    if ((v7 - 48) >= 0xA
      && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
      && ((v7 - 45) > 0x32 || ((1 << (v7 - 45)) & 0x4000000002003) == 0))
    {
      break;
    }
  }
  v10 = &v4[i];
  if (&v4[i] != *(const xmlChar **)(v3 + 40))
  {
    if ((char)v7 >= 1)
    {
      result = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v4, i);
      v12 = *(_QWORD *)(a1 + 56);
      *(_QWORD *)(v12 + 32) = v10;
      *(_DWORD *)(v12 + 56) += i;
      return result;
    }
    return htmlParseNameComplex(a1);
  }
  return 0;
}

_DWORD *htmlParseErr(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  _DWORD *v5;

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 5u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
  v5 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    result = __xmlRaiseError(0, 0, 0, result, 0, 5u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
    v5[6] = 0;
  }
  return result;
}

_DWORD *__xmlRaiseError(xmlStructuredErrorFunc a1, void (*a2)(void *, const char *, ...), void *a3, _QWORD *a4, uint64_t a5, unsigned int a6, int a7, int a8, uint64_t a9, int a10, const xmlChar *a11, xmlChar *cur, xmlChar *a13, int a14, int a15, const char *a16, char a17)
{
  _DWORD *result;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  void **v29;
  char *v30;
  int v31;
  int v32;
  xmlChar *v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  BOOL v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  const xmlChar *v46;
  xmlError *Error;
  void *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  xmlChar *Prop;
  xmlChar *v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  const xmlChar *v59;
  void (*v60)(void *, const char *, ...);
  uint64_t v61;
  uint64_t v62;
  int v63;
  unsigned int v64;
  uint64_t (*v65)(void *, uint64_t);
  _QWORD *v66;
  int LineNo;

  result = __xmlLastError();
  if (!a7)
    return result;
  v26 = (uint64_t)result;
  result = __xmlGetWarningsDefaultValue();
  if (a8 == 1 && !*result)
    return result;
  v27 = 0;
  if (a6 <= 0x17 && ((1 << a6) & 0x80013A) != 0 && (v27 = a4, !a1) && (v27 = a4) != 0)
  {
    v28 = *a4;
    v27 = a4;
    if (*a4)
    {
      v27 = a4;
      if (*(_DWORD *)(v28 + 216) == -554844497)
      {
        a1 = *(xmlStructuredErrorFunc *)(v28 + 248);
        v27 = a4;
        if (a1)
        {
          v29 = (void **)(a4 + 1);
          v27 = a4;
LABEL_15:
          a3 = *v29;
          goto LABEL_16;
        }
      }
    }
  }
  else if (a1)
  {
    goto LABEL_16;
  }
  a1 = *__xmlStructuredError();
  if (a1)
  {
    v29 = __xmlStructuredErrorContext();
    goto LABEL_15;
  }
LABEL_16:
  LineNo = a10;
  v65 = (uint64_t (*)(void *, uint64_t))a1;
  v66 = a4;
  v64 = a6;
  if (a16)
  {
    v30 = (char *)xmlMalloc(0x96uLL);
    if (v30)
    {
      v31 = -1;
      v32 = 150;
      do
      {
        v33 = (xmlChar *)v30;
        if (v32 > 63999)
          break;
        v34 = vsnprintf(v30, v32, a16, &a17);
        if ((v34 & 0x80000000) == 0 && v34 < v32)
        {
          v55 = v31 == v34;
          v31 = v34;
          if (v55)
            break;
        }
        v35 = v34 >= 0 ? v34 + 1 : 100;
        v32 += v35;
        v30 = (char *)xmlRealloc(v33, v32);
      }
      while (v30);
    }
    else
    {
      v33 = 0;
    }
  }
  else
  {
    v33 = xmlStrdup((const xmlChar *)"No error message provided");
  }
  v36 = a9;
  if (v27)
  {
    if (!a9)
    {
      v37 = v27[7];
      if (v37)
      {
        v36 = *(_QWORD *)(v37 + 8);
        if (v36)
        {
LABEL_67:
          LineNo = *(_DWORD *)(v37 + 52);
          a15 = *(_DWORD *)(v37 + 56);
          goto LABEL_68;
        }
        v38 = *((_DWORD *)v27 + 16);
        v39 = __OFSUB__(v38, 2);
        v40 = v38 - 2;
        if (v40 < 0 != v39)
        {
          v36 = 0;
          goto LABEL_67;
        }
        v37 = *(_QWORD *)(v27[9] + 8 * v40);
        if (v37)
        {
          v36 = *(_QWORD *)(v37 + 8);
          goto LABEL_67;
        }
      }
      v36 = 0;
    }
LABEL_68:
    v41 = 0;
    v26 = (uint64_t)(v27 + 75);
    goto LABEL_69;
  }
  v41 = 0;
  if (!a5 || a9)
    goto LABEL_69;
  v42 = *(_QWORD *)(a5 + 64);
  if (v42)
  {
    if (*(_QWORD *)(v42 + 136))
      v41 = a5;
    else
      v41 = 0;
  }
  else
  {
    v41 = 0;
  }
  v43 = 0;
  do
  {
    if (*(_DWORD *)(a5 + 8) == 1)
    {
      v44 = a10;
      if (v41)
        goto LABEL_59;
      goto LABEL_54;
    }
    a5 = *(_QWORD *)(a5 + 40);
    if (v43 > 8)
      break;
    ++v43;
  }
  while (a5);
  v44 = a10;
  if (!v41 && a5)
  {
LABEL_54:
    v45 = *(_QWORD *)(a5 + 64);
    if (v45)
    {
      if (*(_QWORD *)(v45 + 136))
        v41 = a5;
      else
        v41 = 0;
    }
    else
    {
      v41 = 0;
    }
    goto LABEL_59;
  }
  if (!a5)
    goto LABEL_61;
LABEL_59:
  if (*(_DWORD *)(a5 + 8) == 1)
    v44 = *(unsigned __int16 *)(a5 + 112);
LABEL_61:
  if (v44 != 0xFFFF && v44)
    LineNo = v44;
  else
    LineNo = xmlGetLineNo((const xmlNode *)a5);
  v36 = 0;
LABEL_69:
  xmlResetError((xmlErrorPtr)v26);
  *(_DWORD *)v26 = v64;
  *(_DWORD *)(v26 + 4) = a7;
  *(_QWORD *)(v26 + 8) = v33;
  *(_DWORD *)(v26 + 16) = a8;
  if (v36)
  {
    v46 = (const xmlChar *)v36;
LABEL_71:
    *(_QWORD *)(v26 + 24) = xmlStrdup(v46);
  }
  else if (v41)
  {
    v63 = a8;
    v48 = a3;
    v49 = 0;
    v50 = v41;
    do
    {
      v51 = *(_QWORD *)(v50 + 56);
      if (v51)
      {
        v52 = *(_DWORD *)(v51 + 8);
        if (v52 == 20)
        {
          ++v49;
        }
        else if (v52 == 19)
        {
          if (v49 < 1)
          {
            Prop = xmlGetProp((const xmlNode *)v51, (const xmlChar *)"href");
            if (Prop)
            {
              *(_QWORD *)(v26 + 24) = Prop;
              a3 = v48;
              a8 = v63;
              goto LABEL_72;
            }
          }
          else
          {
            --v49;
          }
        }
      }
      else
      {
        v51 = *(_QWORD *)(v50 + 40);
      }
      v50 = v51;
    }
    while (v51);
    v54 = xmlStrdup(*(const xmlChar **)(*(_QWORD *)(v41 + 64) + 136));
    *(_QWORD *)(v26 + 24) = v54;
    if (v54)
      v55 = 1;
    else
      v55 = a5 == 0;
    a3 = v48;
    a8 = v63;
    if (!v55)
    {
      v56 = *(_QWORD *)(a5 + 64);
      if (v56)
      {
        v46 = *(const xmlChar **)(v56 + 136);
        goto LABEL_71;
      }
    }
  }
LABEL_72:
  *(_DWORD *)(v26 + 32) = LineNo;
  if (a11)
    *(_QWORD *)(v26 + 40) = xmlStrdup(a11);
  if (cur)
    *(_QWORD *)(v26 + 48) = xmlStrdup(cur);
  if (a13)
    *(_QWORD *)(v26 + 56) = xmlStrdup(a13);
  *(_DWORD *)(v26 + 64) = a14;
  *(_DWORD *)(v26 + 68) = a15;
  *(_QWORD *)(v26 + 72) = v66;
  *(_QWORD *)(v26 + 80) = a5;
  if ((xmlError *)v26 != __xmlLastError())
  {
    Error = __xmlLastError();
    xmlCopyError((xmlErrorPtr)v26, Error);
  }
  if (v65)
    return (_DWORD *)v65(a3, v26);
  if (a2 || !v27)
  {
    if (a2)
      goto LABEL_107;
    result = __xmlGenericError();
    a2 = *(void (**)(void *, const char *, ...))result;
    if (!v27)
    {
      result = __xmlGenericErrorContext();
      a3 = *(void **)result;
      goto LABEL_106;
    }
LABEL_105:
    a3 = v27;
    goto LABEL_106;
  }
  result = __xmlStructuredError();
  if (*(_QWORD *)result || !*v27)
  {
    result = __xmlGenericError();
    a2 = *(void (**)(void *, const char *, ...))result;
    goto LABEL_105;
  }
  v62 = 176;
  if (a8 == 1)
    v62 = 168;
  a2 = *(void (**)(void *, const char *, ...))(*v27 + v62);
  a3 = (void *)v27[1];
LABEL_106:
  if (a2)
  {
LABEL_107:
    if (a2 == xmlParserValidityWarning
      || a2 == xmlParserValidityError
      || a2 == xmlParserError
      || a2 == xmlParserWarning)
    {
      v57 = v26;
      v58 = (uint64_t)v27;
      v59 = v33;
      v60 = 0;
      v61 = 0;
    }
    else
    {
      if ((char *)a2 != (char *)MEMORY[0x1E0C83478] && (char *)a2 != (char *)xmlGenericErrorDefaultFunc)
        return (_DWORD *)((uint64_t (*)(void *, const char *, ...))a2)(a3, "%s", (const char *)v33);
      v57 = v26;
      v58 = (uint64_t)v27;
      v59 = v33;
      v60 = a2;
      v61 = (uint64_t)a3;
    }
    return (_DWORD *)xmlReportError(v57, v58, v59, v60, v61);
  }
  return result;
}

void xmlSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler)
{
  *__xmlStructuredErrorContext() = ctx;
  *__xmlStructuredError() = handler;
}

xmlStructuredErrorFunc *__xmlStructuredError(void)
{
  if (xmlIsMainThread())
    return (xmlStructuredErrorFunc *)&xmlStructuredError;
  else
    return &xmlGetGlobalState()->xmlStructuredError;
}

void **__xmlStructuredErrorContext(void)
{
  if (xmlIsMainThread())
    return (void **)&xmlStructuredErrorContext;
  else
    return &xmlGetGlobalState()->xmlStructuredErrorContext;
}

xmlError *__xmlLastError(void)
{
  if (xmlIsMainThread())
    return (xmlError *)&xmlLastError;
  else
    return &xmlGetGlobalState()->xmlLastError;
}

void xmlResetError(xmlErrorPtr err)
{
  char *message;
  char *file;
  char *str1;
  char *str2;
  char *str3;

  if (err && err->code)
  {
    message = err->message;
    if (message)
      xmlFree(message);
    file = err->file;
    if (file)
      xmlFree(file);
    str1 = err->str1;
    if (str1)
      xmlFree(str1);
    str2 = err->str2;
    if (str2)
      xmlFree(str2);
    str3 = err->str3;
    if (str3)
      xmlFree(str3);
    err->node = 0;
    *(_OWORD *)&err->str2 = 0u;
    *(_OWORD *)&err->int1 = 0u;
    *(_OWORD *)&err->level = 0u;
    *(_OWORD *)&err->line = 0u;
    *(_OWORD *)&err->domain = 0u;
    err->code = 0;
  }
}

int xmlCopyError(xmlErrorPtr from, xmlErrorPtr to)
{
  int result;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *message;
  char *file;
  char *str1;
  char *str2;
  char *str3;

  result = -1;
  if (from && to)
  {
    v5 = (char *)xmlStrdup((const xmlChar *)from->message);
    v6 = (char *)xmlStrdup((const xmlChar *)from->file);
    v7 = (char *)xmlStrdup((const xmlChar *)from->str1);
    v8 = (char *)xmlStrdup((const xmlChar *)from->str2);
    v9 = (char *)xmlStrdup((const xmlChar *)from->str3);
    message = to->message;
    if (message)
      xmlFree(message);
    file = to->file;
    if (file)
      xmlFree(file);
    str1 = to->str1;
    if (str1)
      xmlFree(str1);
    str2 = to->str2;
    if (str2)
      xmlFree(str2);
    str3 = to->str3;
    if (str3)
      xmlFree(str3);
    result = 0;
    *(_QWORD *)&to->domain = *(_QWORD *)&from->domain;
    to->level = from->level;
    to->line = from->line;
    to->node = from->node;
    *(_QWORD *)&to->int1 = *(_QWORD *)&from->int1;
    *(_OWORD *)&to->ctxt = *(_OWORD *)&from->ctxt;
    to->message = v5;
    to->file = v6;
    to->str1 = v7;
    to->str2 = v8;
    to->str3 = v9;
  }
  return result;
}

int *__xmlGetWarningsDefaultValue(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlGetWarningsDefaultValue;
  else
    return &xmlGetGlobalState()->xmlGetWarningsDefaultValue;
}

int *xmlSaveCtxtInit(int *result)
{
  int *v1;
  const char **v2;
  int v3;
  int v4;
  int v5;
  char *v6;
  const void **v7;

  if (result)
  {
    v1 = result;
    if (!*((_QWORD *)result + 3) && !*((_QWORD *)result + 17))
      *((_QWORD *)result + 17) = xmlEscapeEntities;
    v2 = __xmlTreeIndentString();
    v3 = xmlStrlen((const xmlChar *)*v2);
    if (*__xmlTreeIndentString() && v3)
    {
      v4 = 60 / v3;
      v1[31] = 60 / v3;
      v1[32] = v3;
      if (60 / v3 >= 1)
      {
        v5 = 0;
        do
        {
          v6 = (char *)v1 + v1[32] * (uint64_t)v5 + 60;
          v7 = (const void **)__xmlTreeIndentString();
          memcpy(v6, *v7, v1[32]);
          ++v5;
          v4 = v1[31];
        }
        while (v5 < v4);
        v3 = v1[32];
      }
      *((_BYTE *)v1 + v3 * v4 + 60) = 0;
    }
    else
    {
      *(_OWORD *)((char *)v1 + 105) = 0u;
      *(_OWORD *)(v1 + 23) = 0u;
      *(_OWORD *)(v1 + 19) = 0u;
      *(_OWORD *)(v1 + 15) = 0u;
    }
    result = __xmlSaveNoEmptyTags();
    if (*result)
      v1[12] |= 4u;
  }
  return result;
}

const char **__xmlTreeIndentString(void)
{
  if (xmlIsMainThread())
    return (const char **)&xmlTreeIndentString;
  else
    return &xmlGetGlobalState()->xmlTreeIndentString;
}

int *__xmlSaveNoEmptyTags(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlSaveNoEmptyTags;
  else
    return &xmlGetGlobalState()->xmlSaveNoEmptyTags;
}

xmlNodePtr xmlNewChild(xmlNodePtr parent, xmlNsPtr ns, const xmlChar *name, const xmlChar *content)
{
  xmlNodePtr result;
  unint64_t v6;
  xmlDoc *doc;
  _xmlNode **p_last;
  _xmlNode *last;

  result = 0;
  if (parent && name)
  {
    result = 0;
    HIDWORD(v6) = parent->type - 1;
    LODWORD(v6) = HIDWORD(v6);
    switch((v6 >> 1))
    {
      case 0u:
        doc = parent->doc;
        if (!ns)
          ns = parent->ns;
        goto LABEL_8;
      case 4u:
      case 6u:
        doc = (xmlDoc *)parent;
        goto LABEL_8;
      case 5u:
        doc = parent->doc;
LABEL_8:
        result = xmlNewDocNode(doc, ns, name, content);
        if (result)
        {
          result->type = XML_ELEMENT_NODE;
          result->parent = parent;
          result->doc = parent->doc;
          if (parent->children)
          {
            last = parent->last;
            p_last = &parent->last;
            last->next = result;
            result->prev = last;
          }
          else
          {
            parent->children = result;
            p_last = &parent->last;
          }
          *p_last = result;
        }
        break;
      default:
        return result;
    }
  }
  return result;
}

xmlNodePtr xmlNewDocNode(xmlDocPtr doc, xmlNsPtr ns, const xmlChar *name, const xmlChar *content)
{
  _xmlDict *dict;
  xmlChar *v8;
  xmlNodePtr v9;
  xmlNode *v10;
  xmlNodePtr NodeList;
  _xmlNode *next;
  xmlNodePtr v13;

  if (doc && (dict = doc->dict) != 0)
  {
    v8 = (xmlChar *)xmlDictLookup(dict, name, -1);
    v9 = xmlNewNodeEatName(ns, v8);
  }
  else
  {
    v9 = xmlNewNode(ns, name);
  }
  v10 = v9;
  if (v9)
  {
    v9->doc = doc;
    if (content)
    {
      NodeList = xmlStringGetNodeList(doc, content);
      v10->children = NodeList;
      if (NodeList)
      {
        next = NodeList->next;
        if (next)
        {
          do
          {
            v13 = next;
            NodeList->parent = v10;
            next = next->next;
            NodeList = v13;
          }
          while (next);
        }
        else
        {
          v13 = NodeList;
        }
        v13->parent = v10;
      }
      else
      {
        v13 = 0;
      }
      v10->last = v13;
    }
  }
  return v10;
}

xmlNodePtr xmlNewNode(xmlNsPtr ns, const xmlChar *name)
{
  xmlNode *v4;
  xmlNode *v5;
  xmlRegisterNodeFunc *v6;

  if (!name)
    return 0;
  v4 = (xmlNode *)xmlMalloc(0x78uLL);
  v5 = v4;
  if (v4)
  {
    *(_QWORD *)&v4->line = 0;
    *(_OWORD *)&v4->content = 0u;
    *(_OWORD *)&v4->nsDef = 0u;
    *(_OWORD *)&v4->next = 0u;
    *(_OWORD *)&v4->doc = 0u;
    *(_OWORD *)&v4->name = 0u;
    *(_OWORD *)&v4->last = 0u;
    *(_OWORD *)&v4->_private = 0u;
    v4->type = XML_ELEMENT_NODE;
    v4->name = xmlStrdup(name);
    v5->ns = ns;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v6 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v6)(v5);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building node");
  }
  return v5;
}

xmlNodePtr xmlStringGetNodeList(const xmlDoc *doc, const xmlChar *value)
{
  const xmlChar *v2;
  uint64x2_t *Size;
  uint64x2_t *v5;
  xmlNode *v6;
  xmlNode *Sibling;
  const xmlChar *i;
  int v9;
  int v10;
  const xmlChar *v11;
  int v12;
  const xmlChar *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  xmlEntityPtr DocEntity;
  xmlNodePtr v24;
  xmlNodePtr v25;
  xmlNode *v26;
  xmlNodePtr NodeList;
  xmlNodePtr v28;
  xmlNodePtr v30;
  xmlNode *v31;
  xmlNode *elem;
  xmlNodePtr elema;
  xmlEntityPtr v34;
  xmlChar *name;
  xmlChar out[8];
  __int16 v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (!value)
    return 0;
  v2 = value;
  Size = (uint64x2_t *)xmlBufCreateSize(0);
  if (!Size)
    return 0;
  v5 = Size;
  xmlBufSetAllocationScheme((uint64_t)Size, 4u);
  v6 = 0;
  Sibling = 0;
LABEL_4:
  for (i = v2; *i; ++i)
  {
    if (*i == 38)
    {
      if (i != v2 && xmlBufAdd(v5, v2, ((_DWORD)i - (_DWORD)v2)))
        goto LABEL_73;
      v9 = i[1];
      if (v9 != 35)
      {
        v22 = 2;
        if (!i[1])
        {
LABEL_80:
          __xmlSimpleError(2u, 1302, (uint64_t)doc, "unterminated entity reference %15s\n", i + 1);
          goto LABEL_73;
        }
        while (v9 != 59)
        {
          v9 = i[v22++];
          if (!v9)
            goto LABEL_80;
        }
        if (v22 == 2)
          goto LABEL_67;
        name = xmlStrndup(i + 1, (int)v22 - 2);
        DocEntity = xmlGetDocEntity(doc, name);
        if (DocEntity && DocEntity->etype == XML_INTERNAL_PREDEFINED_ENTITY)
        {
          if (xmlBufCat(v5, DocEntity->content))
            goto LABEL_73;
LABEL_66:
          xmlFree(name);
LABEL_67:
          v2 = &i[v22];
          goto LABEL_4;
        }
        v34 = DocEntity;
        if (xmlBufIsEmpty((uint64_t)v5))
        {
LABEL_57:
          v25 = xmlNewReference(doc, name);
          if (v25)
          {
            v26 = v25;
            if (v34)
            {
              if (!v34->children)
              {
                v34->children = (_xmlNode *)-1;
                elema = v25;
                NodeList = xmlStringGetNodeList(doc, v25->content);
                v26 = elema;
                v34->children = NodeList;
                v34->owner = 1;
                if (NodeList)
                {
                  do
                  {
                    v28 = NodeList;
                    NodeList->parent = (_xmlNode *)v34;
                    NodeList = NodeList->next;
                  }
                  while (NodeList);
                  v34->last = v28;
                }
              }
            }
            if (Sibling)
            {
              Sibling = xmlAddNextSibling(Sibling, v26);
            }
            else
            {
              v6 = v26;
              Sibling = v26;
            }
            goto LABEL_66;
          }
        }
        else
        {
          v24 = xmlNewText(0);
          if (v24)
          {
            v24->doc = (_xmlDoc *)doc;
            elem = v24;
            v24->content = (xmlChar *)xmlBufDetach(v5->i64);
            if (Sibling)
            {
              Sibling = xmlAddNextSibling(Sibling, elem);
            }
            else
            {
              v6 = elem;
              Sibling = elem;
            }
            goto LABEL_57;
          }
        }
        if (name)
          xmlFree(name);
        goto LABEL_73;
      }
      v11 = i + 2;
      v10 = i[2];
      if (v10 == 59)
      {
        v15 = 0;
LABEL_21:
        v17 = 1;
      }
      else
      {
        if (v10 == 120)
        {
          v14 = i[3];
          v13 = i + 3;
          v12 = v14;
          if (v14 != 59)
          {
            v15 = 0;
            while (1)
            {
              if ((v12 - 48) >= 0xA)
              {
                if ((v12 - 97) >= 6)
                {
                  if ((v12 - 65) >= 6)
                  {
                    __xmlSimpleError(2u, 1300, (uint64_t)doc, "invalid hexadecimal character value\n", 0);
                    v20 = 0;
                    v15 = 0;
                    goto LABEL_36;
                  }
                  v18 = -55;
                }
                else
                {
                  v18 = -87;
                }
              }
              else
              {
                v18 = -48;
              }
              v15 = v18 + 16 * v15 + v12;
              if (v15 >= 1114112)
                v15 = 1114112;
              v19 = *++v13;
              v12 = v19;
              if (v19 == 59)
                goto LABEL_35;
            }
          }
          v15 = 0;
LABEL_35:
          v20 = 1;
LABEL_36:
          v2 = &v13[v20];
          if (v15)
            goto LABEL_37;
          goto LABEL_4;
        }
        v15 = 0;
        while ((v10 - 48) <= 9)
        {
          v15 = v10 + 10 * v15 - 48;
          if (v15 >= 1114112)
            v15 = 1114112;
          v16 = *++v11;
          v10 = v16;
          if (v16 == 59)
            goto LABEL_21;
        }
        __xmlSimpleError(2u, 1301, (uint64_t)doc, "invalid decimal character value\n", 0);
        v17 = 0;
        v15 = 0;
      }
      v2 = &v11[v17];
      if (!v15)
        goto LABEL_4;
LABEL_37:
      v37 = 0;
      *(_QWORD *)out = 0;
      if (v15 < 1114112)
        v21 = v15;
      else
        v21 = 65533;
      out[xmlCopyCharMultiByte(out, v21)] = 0;
      if (xmlBufCat(v5, out))
        goto LABEL_73;
      goto LABEL_4;
    }
  }
  if (i != v2 || !v6)
    xmlBufAdd(v5, v2, ((_DWORD)i - (_DWORD)v2));
  if (!xmlBufIsEmpty((uint64_t)v5))
  {
    v30 = xmlNewText(0);
    if (v30)
    {
      v31 = v30;
      v30->doc = (_xmlDoc *)doc;
      v30->content = (xmlChar *)xmlBufDetach(v5->i64);
      if (Sibling)
        xmlAddNextSibling(Sibling, v31);
      else
        v6 = v31;
    }
    else
    {
      v6 = 0;
    }
  }
LABEL_73:
  xmlBufFree(v5);
  return v6;
}

xmlNodePtr xmlNewText(const xmlChar *content)
{
  xmlNode *v2;
  xmlNode *v3;
  xmlRegisterNodeFunc *v4;

  v2 = (xmlNode *)xmlMalloc(0x78uLL);
  v3 = v2;
  if (v2)
  {
    *(_OWORD *)&v2->_private = 0u;
    *(_OWORD *)&v2->name = 0u;
    *(_QWORD *)&v2->line = 0;
    *(_OWORD *)&v2->content = 0u;
    *(_OWORD *)&v2->nsDef = 0u;
    *(_OWORD *)&v2->next = 0u;
    *(_OWORD *)&v2->doc = 0u;
    *(_OWORD *)&v2->last = 0u;
    v2->type = XML_TEXT_NODE;
    v2->name = "text";
    if (content)
      v2->content = xmlStrdup(content);
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v4 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v4)(v3);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building text");
  }
  return v3;
}

uint64_t xmlBufIsEmpty(uint64_t a1)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  if (!a1 || *(_DWORD *)(a1 + 56))
    return 0xFFFFFFFFLL;
  v2 = *(unsigned int *)(a1 + 12);
  if (v2 <= 0x7FFFFFFE && *(_QWORD *)(a1 + 40) != v2)
    *(_QWORD *)(a1 + 40) = v2;
  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(unsigned int *)(a1 + 8);
  if (v5 <= 0x7FFFFFFE && v4 != v5)
  {
    *(_QWORD *)(a1 + 32) = v5;
    v4 = v5;
  }
  return v4 == 0;
}

uint64_t xmlAttrDumpOutput(uint64_t result, uint64_t a2)
{
  xmlOutputBuffer *v2;
  uint64_t v4;
  const char *v5;

  if (a2)
  {
    v2 = *(xmlOutputBuffer **)(result + 40);
    if (v2)
    {
      if (*(_DWORD *)(result + 56) == 2)
        xmlOutputBufferWriteWSNonSig((xmlBufPtr)result, 2);
      else
        xmlOutputBufferWrite(*(xmlOutputBufferPtr *)(result + 40), 1, " ");
      v4 = *(_QWORD *)(a2 + 72);
      if (v4)
      {
        v5 = *(const char **)(v4 + 24);
        if (v5)
        {
          xmlOutputBufferWriteString(v2, v5);
          xmlOutputBufferWrite(v2, 1, ":");
        }
      }
      xmlOutputBufferWriteString(v2, *(const char **)(a2 + 16));
      xmlOutputBufferWrite(v2, 2, "=\"");
      xmlAttrSerializeContent((uint64_t)v2, a2);
      return xmlOutputBufferWrite(v2, 1, "\"");
    }
  }
  return result;
}

uint64_t xmlNodeDumpOutputInternal(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  const char *v14;
  const char *v15;
  int v16;
  const char *v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  int v23;
  const char *v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  _QWORD *i;
  uint64_t j;
  uint64_t v34;
  int v35;
  const char *v36;
  const char *v37;
  int v38;
  uint64_t v39;
  const char *v40;
  int v41;
  BOOL v42;
  int v43;
  int v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  char *buf;

  if (!a2)
    return result;
  v3 = result;
  v4 = 0;
  v5 = *(unsigned int *)(result + 56);
  v6 = "\n";
  v7 = *(_QWORD *)(result + 40);
  v8 = "</";
  v9 = *(_QWORD *)(a2 + 40);
  buf = (char *)(result + 60);
  v10 = a2;
LABEL_3:
  while (2)
  {
    while (1)
    {
      v11 = v9;
      v9 = v10;
      v12 = *(_DWORD *)(v10 + 8);
      if (v12 != 11)
        break;
      if (*(_QWORD *)(v9 + 40) == v11)
      {
        v10 = *(_QWORD *)(v9 + 24);
        if (v10)
          continue;
      }
      goto LABEL_106;
    }
    switch(v12)
    {
      case 1:
        if (v9 != a2 && *(_DWORD *)(v3 + 56) == 1 && *__xmlIndentTreeOutput())
        {
          v13 = *(_DWORD *)(v3 + 52);
          if (v13 >= *(_DWORD *)(v3 + 124))
            v13 = *(_DWORD *)(v3 + 124);
          xmlOutputBufferWrite((xmlOutputBufferPtr)v7, v13 * *(_DWORD *)(v3 + 128), buf);
        }
        if (*(_QWORD *)(v9 + 40) != v11 && *(_QWORD *)(v9 + 24))
        {
          result = xmlNodeDumpOutputInternal(v3, v9);
          goto LABEL_106;
        }
        v29 = v5;
        xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, "<");
        v30 = *(_QWORD *)(v9 + 72);
        if (v30)
        {
          v31 = *(const char **)(v30 + 24);
          if (v31)
          {
            xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, v31);
            xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, ":");
          }
        }
        xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, *(const char **)(v9 + 16));
        for (i = *(_QWORD **)(v9 + 96); i; i = (_QWORD *)*i)
          xmlNsDumpOutput(*(_QWORD *)(v3 + 40), (uint64_t)i, v3);
        for (j = *(_QWORD *)(v9 + 88); j; j = *(_QWORD *)(j + 48))
          xmlAttrDumpOutput(v3, j);
        v34 = *(_QWORD *)(v9 + 24);
        if (v34)
        {
          v35 = *(_DWORD *)(v3 + 56);
          v5 = v29;
          if (v35 == 2)
          {
            xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 1);
          }
          else if (v35 == 1)
          {
            while ((*(_DWORD *)(v34 + 8) - 3) > 2)
            {
              v34 = *(_QWORD *)(v34 + 48);
              if (!v34)
                goto LABEL_113;
            }
            *(_DWORD *)(v3 + 56) = 0;
            v4 = v9;
          }
LABEL_113:
          result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, ">");
          if (*(_DWORD *)(v3 + 56) == 1)
            result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, v6);
          v48 = *(_DWORD *)(v3 + 52);
          if ((v48 & 0x80000000) == 0)
            *(_DWORD *)(v3 + 52) = v48 + 1;
          v10 = *(_QWORD *)(v9 + 24);
          continue;
        }
        v38 = *(_DWORD *)(v3 + 56);
        if ((*(_BYTE *)(v3 + 48) & 4) != 0)
        {
          v5 = v29;
          if (v38 == 2)
            xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 1);
          xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 3, "></");
          v39 = *(_QWORD *)(v9 + 72);
          if (v39)
          {
            v40 = *(const char **)(v39 + 24);
            if (v40)
            {
              xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, v40);
              xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, ":");
            }
          }
          xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, *(const char **)(v9 + 16));
          if (*(_DWORD *)(v3 + 56) == 2)
            xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 0);
          result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, ">");
        }
        else
        {
          v5 = v29;
          if (v38 == 2)
            xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 0);
          result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 2, "/>");
        }
        goto LABEL_106;
      case 2:
        result = xmlAttrDumpOutput(v3, v9);
        goto LABEL_106;
      case 3:
        v14 = *(const char **)(v9 + 80);
        if (v14)
        {
          if (*(const xmlChar **)(v9 + 16) == "textnoenc")
            result = xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, v14);
          else
            result = xmlOutputBufferWriteEscape((xmlOutputBufferPtr)v7, (const xmlChar *)v14, *(xmlCharEncodingOutputFunc *)(v3 + 136));
        }
        goto LABEL_106;
      case 4:
        v15 = *(const char **)(v9 + 80);
        if (!v15 || (v16 = *(unsigned __int8 *)v15, v17 = *(const char **)(v9 + 80), v49 = v4, !*v15))
        {
          result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 12, "<![CDATA[]]>");
          goto LABEL_106;
        }
        while (2)
        {
          if (v16 == 93)
          {
            if (v17[1] == 93)
            {
              v18 = v8;
              v19 = v6;
              v20 = v5;
              v21 = v17 + 2;
              if (v17[2] == 62)
              {
                v22 = v15;
                xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 9, "<![CDATA[");
                v23 = (_DWORD)v21 - (_DWORD)v22;
                v24 = v22;
                v4 = v49;
                xmlOutputBufferWrite((xmlOutputBufferPtr)v7, v23, v24);
                result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 3, "]]>");
                v15 = v21;
                v17 = v21;
              }
              v5 = v20;
              v6 = v19;
              v8 = v18;
            }
            goto LABEL_31;
          }
          if (v16)
          {
LABEL_31:
            v25 = *(unsigned __int8 *)++v17;
            v16 = v25;
            continue;
          }
          break;
        }
        if (v15 != v17)
        {
          v36 = v15;
          xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 9, "<![CDATA[");
          v37 = v36;
          v4 = v49;
          xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, v37);
          result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 3, "]]>");
        }
LABEL_106:
        while (v9 != a2)
        {
          v47 = v9;
          v9 = v11;
          if (*(_DWORD *)(v3 + 56) == 1 && (*(_DWORD *)(v47 + 8) - 19) >= 2)
            result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, v6);
          v10 = *(_QWORD *)(v47 + 48);
          if (v10)
            goto LABEL_3;
          v11 = *(_QWORD *)(v11 + 40);
          if (*(_DWORD *)(v9 + 8) == 1)
          {
            v41 = *(_DWORD *)(v3 + 52);
            v42 = __OFSUB__(v41, 1);
            v43 = v41 - 1;
            if (v43 < 0 == v42)
              *(_DWORD *)(v3 + 52) = v43;
            if (*__xmlIndentTreeOutput() && *(_DWORD *)(v3 + 56) == 1)
            {
              v44 = *(_DWORD *)(v3 + 52);
              if (v44 >= *(_DWORD *)(v3 + 124))
                v44 = *(_DWORD *)(v3 + 124);
              xmlOutputBufferWrite((xmlOutputBufferPtr)v7, v44 * *(_DWORD *)(v3 + 128), buf);
            }
            xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 2, v8);
            v45 = *(_QWORD *)(v9 + 72);
            if (v45)
            {
              v46 = *(const char **)(v45 + 24);
              if (v46)
              {
                xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, v46);
                xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, ":");
              }
            }
            xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, *(const char **)(v9 + 16));
            if (*(_DWORD *)(v3 + 56) == 2)
              xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 0);
            result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, ">");
            if (v9 == v4)
            {
              v4 = 0;
              *(_DWORD *)(v3 + 56) = v5;
            }
          }
        }
        return result;
      case 5:
        xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, "&");
        xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, *(const char **)(v9 + 16));
        result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, ";");
        goto LABEL_106;
      case 7:
        if (v9 != a2 && *(_DWORD *)(v3 + 56) == 1 && *__xmlIndentTreeOutput())
        {
          v26 = *(_DWORD *)(v3 + 52);
          if (v26 >= *(_DWORD *)(v3 + 124))
            v26 = *(_DWORD *)(v3 + 124);
          xmlOutputBufferWrite((xmlOutputBufferPtr)v7, v26 * *(_DWORD *)(v3 + 128), buf);
        }
        v27 = *(_QWORD *)(v9 + 80);
        xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 2, "<?");
        xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, *(const char **)(v9 + 16));
        if (v27)
        {
          if (*(_QWORD *)(v9 + 80))
          {
            if (*(_DWORD *)(v3 + 56) == 2)
              xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 0);
            else
              xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 1, " ");
            xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, *(const char **)(v9 + 80));
          }
        }
        else if (*(_DWORD *)(v3 + 56) == 2)
        {
          xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 0);
        }
        result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 2, "?>");
        goto LABEL_106;
      case 8:
        if (v9 != a2 && *(_DWORD *)(v3 + 56) == 1)
        {
          result = (uint64_t)__xmlIndentTreeOutput();
          if (*(_DWORD *)result)
          {
            v28 = *(_DWORD *)(v3 + 52);
            if (v28 >= *(_DWORD *)(v3 + 124))
              v28 = *(_DWORD *)(v3 + 124);
            result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, v28 * *(_DWORD *)(v3 + 128), buf);
          }
        }
        if (*(_QWORD *)(v9 + 80))
        {
          xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 4, "<!--");
          xmlOutputBufferWriteString((xmlOutputBufferPtr)v7, *(const char **)(v9 + 80));
          result = xmlOutputBufferWrite((xmlOutputBufferPtr)v7, 3, "-->");
        }
        goto LABEL_106;
      case 9:
      case 13:
        result = xmlDocContentDumpOutput(v3, v9);
        goto LABEL_106;
      case 14:
        result = xmlDtdDumpOutput(v3, v9);
        goto LABEL_106;
      case 15:
        result = (uint64_t)xmlBufDumpElementDecl(*(uint64x2_t **)(v7 + 32), (xmlElement *)v9);
        goto LABEL_106;
      case 16:
        result = (uint64_t)xmlBufDumpAttributeDecl(*(uint64x2_t **)(v7 + 32), (xmlAttribute *)v9);
        goto LABEL_106;
      case 17:
        result = (uint64_t)xmlBufDumpEntityDecl(*(uint64x2_t **)(v7 + 32), (xmlEntity *)v9);
        goto LABEL_106;
      case 18:
        result = xmlNsDumpOutput(*(_QWORD *)(v3 + 40), v9, v3);
        goto LABEL_106;
      default:
        goto LABEL_106;
    }
  }
}

int xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf)
{
  int v4;
  int v6;
  xmlBufPtr *p_conv;
  uint64x2_t **p_buffer;
  size_t v10;
  int v12;
  xmlBufPtr *v13;
  size_t v14;
  size_t v15;
  xmlOutputWriteCallback writecallback;
  void *context;
  xmlChar *v18;
  unsigned int v19;
  xmlBufPtr *v20;
  xmlChar *v21;
  int written;
  int v23;
  int v24;

  if (!out || out->error)
    return -1;
  v6 = len;
  if (len < 0)
    return 0;
  v4 = 0;
  p_conv = &out->conv;
  p_buffer = (uint64x2_t **)&out->buffer;
  while (1)
  {
    v10 = v6 >= 16000 ? 16000 : v6;
    if (out->encoder)
    {
      if (!*p_conv)
        *p_conv = (xmlBufPtr)xmlBufCreate();
      if (xmlBufAdd(*p_buffer, (const xmlChar *)buf, v10))
        return -1;
      if (xmlBufUse((const xmlBufPtr)*p_buffer) <= 0xF9F && v6 < 0x3E81)
        return v4;
      v12 = xmlCharEncOutput(out, 0);
      if (v12 < 0 && v12 != -3)
      {
        v24 = 1544;
        __xmlSimpleError(8u, 1544, 0, "encoder error", 0);
        v19 = -1;
        goto LABEL_42;
      }
      v13 = &out->conv;
      if (!out->writecallback)
      {
        LODWORD(v14) = v12 & ~(v12 >> 31);
LABEL_31:
        buf += v10;
        v6 -= v10;
        goto LABEL_37;
      }
    }
    else
    {
      if (xmlBufAdd(*p_buffer, (const xmlChar *)buf, v10))
        return -1;
      LODWORD(v14) = v10;
      v13 = &out->buffer;
      if (!out->writecallback)
        goto LABEL_31;
    }
    v15 = xmlBufUse(*v13);
    v14 = v15;
    writecallback = out->writecallback;
    buf += v10;
    v6 -= v10;
    if (writecallback)
      break;
LABEL_37:
    v4 += v14;
    if (v6 <= 0)
      return v4;
  }
  if ((int)v15 <= 3999 && v6 < 1)
    return v4;
  context = out->context;
  if (out->encoder)
  {
    v18 = xmlBufContent(*p_conv);
    v19 = ((uint64_t (*)(void *, xmlChar *, size_t))writecallback)(context, v18, v14);
    v20 = &out->conv;
    if ((v19 & 0x80000000) != 0)
      goto LABEL_41;
    goto LABEL_33;
  }
  v21 = xmlBufContent((const xmlBuf *)*p_buffer);
  v19 = ((uint64_t (*)(void *, xmlChar *, size_t))writecallback)(context, v21, v14);
  v20 = &out->buffer;
  if ((v19 & 0x80000000) == 0)
  {
LABEL_33:
    xmlBufShrink(*v20, v19);
    written = out->written;
    if (written <= (int)(v19 ^ 0x7FFFFFFF))
      v23 = written + v19;
    else
      v23 = 0x7FFFFFFF;
    out->written = v23;
    goto LABEL_37;
  }
LABEL_41:
  v24 = 1546;
  __xmlSimpleError(8u, 1546, 0, "write error", 0);
LABEL_42:
  out->error = v24;
  return v19;
}

uint64_t xmlBufAdd(uint64x2_t *a1, const xmlChar *__src, size_t __len)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  size_t v11;
  int8x16_t v12;
  size_t v13;
  const char *v14;

  result = 0xFFFFFFFFLL;
  if (a1 && __src && !a1[3].i32[2])
  {
    v6 = a1->u32[3];
    if (v6 <= 0x7FFFFFFE && a1[2].i64[1] != v6)
      a1[2].i64[1] = v6;
    v8 = a1->u32[2];
    if (v8 <= 0x7FFFFFFE && a1[2].i64[0] != v8)
      a1[2].i64[0] = v8;
    if ((int)__len >= -1 && a1[1].i32[0] != 2)
    {
      if (!(_DWORD)__len)
        return 0;
      if ((__len & 0x80000000) != 0)
      {
        LODWORD(__len) = xmlStrlen(__src);
        if ((__len & 0x80000000) != 0)
          return 0xFFFFFFFFLL;
      }
      if (!(_DWORD)__len)
        return 0;
      v9 = __len;
      v10 = a1[2].i64[0];
      if (a1[2].i64[1] - v10 > (unint64_t)__len)
      {
LABEL_20:
        memmove((void *)(a1->i64[0] + v10), __src, v9);
        result = 0;
        v11 = a1[2].i64[0] + v9;
        a1[2].i64[0] = v11;
        *(_BYTE *)(a1->i64[0] + v11) = 0;
        v12 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFuLL);
        a1->u64[1] = (unint64_t)vmovn_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v12, a1[2]), (int8x16_t)a1[2], v12));
        return result;
      }
      if (__len >= (unint64_t)~v10)
      {
        v14 = "growing buffer past SIZE_MAX";
        goto LABEL_27;
      }
      v13 = __len + v10 + 1;
      if (v13 >= 0x989680 && a1[1].i32[0] == 5)
      {
        v14 = "buffer error: text too long\n";
LABEL_27:
        xmlBufMemoryError((uint64_t)a1, (const xmlChar *)v14);
        return 0xFFFFFFFFLL;
      }
      if (xmlBufResize((uint64_t)a1, v13))
      {
        v10 = a1[2].i64[0];
        goto LABEL_20;
      }
      xmlBufMemoryError((uint64_t)a1, (const xmlChar *)"growing buffer");
      return 2;
    }
  }
  return result;
}

uint64_t xmlBufResize(uint64_t result, size_t size)
{
  uint64_t v2;
  size_t v3;
  size_t v4;
  size_t v6;
  size_t v7;
  int v9;
  const char *v10;
  uint64_t v11;
  size_t v12;
  void *v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  int8x16_t v19;

  if (result)
  {
    v2 = result;
    if (*(_DWORD *)(result + 56))
      return 0;
    v3 = *(_QWORD *)(result + 40);
    v4 = *(unsigned int *)(result + 12);
    if (v4 <= 0x7FFFFFFE && v3 != v4)
    {
      *(_QWORD *)(result + 40) = v4;
      v3 = v4;
    }
    v6 = *(_QWORD *)(result + 32);
    v7 = *(unsigned int *)(result + 8);
    if (v7 <= 0x7FFFFFFE && v6 != v7)
    {
      *(_QWORD *)(result + 32) = v7;
      v6 = v7;
    }
    v9 = *(_DWORD *)(result + 16);
    if (v9 == 2)
      return 0;
    if (size >= 0x989680 && v9 == 5)
    {
      v10 = "buffer error: text too long\n";
      goto LABEL_17;
    }
    if (v3 > size)
      return 1;
    switch(v9)
    {
      case 0:
      case 3:
        v11 = size + 10;
        if (size >= 0xFFFFFFFFFFFFFFF6)
          v11 = -1;
        if (v3)
          v12 = v3;
        else
          v12 = v11;
        while (1)
        {
          if (v12 >= size)
            goto LABEL_39;
          if ((v12 & 0x8000000000000000) != 0)
            goto LABEL_56;
          v12 *= 2;
        }
      case 1:
        if (size >= 0xFFFFFFFFFFFFFFF6)
          v12 = -1;
        else
          v12 = size + 10;
        goto LABEL_48;
      case 4:
        if (v6 >= 0x1000)
        {
          v12 = v3;
          if (v3 < size)
          {
            v12 = v3;
            do
            {
              if ((v12 & 0x8000000000000000) != 0)
              {
LABEL_56:
                xmlBufMemoryError(result, (const xmlChar *)"growing buffer");
                return 0;
              }
              v12 *= 2;
            }
            while (v12 < size);
LABEL_39:
            if (v9 == 3)
            {
              v13 = *(void **)(result + 24);
              if (v13)
              {
                v14 = *(_QWORD *)v2 - (_QWORD)v13;
                if (v14 > v12)
                {
                  memmove(v13, *(const void **)v2, v6);
                  v15 = *(char **)(v2 + 24);
                  goto LABEL_59;
                }
                v18 = (char *)xmlRealloc(v13, v14 + v12);
                if (v18)
                {
                  *(_QWORD *)(v2 + 24) = v18;
                  v15 = &v18[v14];
                  goto LABEL_59;
                }
                goto LABEL_61;
              }
            }
          }
        }
        else
        {
          v12 = size;
        }
LABEL_48:
        if (!*(_QWORD *)v2)
        {
          v16 = (char *)xmlMallocAtomic(v12);
LABEL_52:
          v15 = v16;
          if (!v16)
            goto LABEL_61;
LABEL_59:
          *(_QWORD *)v2 = v15;
          *(_QWORD *)(v2 + 40) = v12;
          v15[*(_QWORD *)(v2 + 32)] = 0;
          v19 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFuLL);
          *(int32x2_t *)(v2 + 8) = vmovn_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v19, *(uint64x2_t *)(v2 + 32)), *(int8x16_t *)(v2 + 32), v19));
          return 1;
        }
        if (v3 - v6 <= 0x63)
        {
          v16 = (char *)xmlRealloc(*(void **)v2, v12);
          goto LABEL_52;
        }
        v17 = (char *)xmlMallocAtomic(v12);
        if (v17)
        {
          v15 = v17;
          memcpy(v17, *(const void **)v2, *(_QWORD *)(v2 + 32));
          xmlFree(*(void **)v2);
          goto LABEL_59;
        }
LABEL_61:
        v10 = "growing buffer";
LABEL_17:
        __xmlSimpleError(0x1Du, 2, 0, 0, (const xmlChar *)v10);
        if (!*(_DWORD *)(v2 + 56))
        {
          result = 0;
          *(_DWORD *)(v2 + 56) = 2;
          return result;
        }
        return 0;
      default:
        if (size >= 0xFFFFFFFFFFFFFFF6)
          v12 = -1;
        else
          v12 = size + 10;
        goto LABEL_39;
    }
  }
  return result;
}

void *xmlReallocChecked(void *a1, size_t a2)
{
  void *result;

  result = malloc_type_realloc(a1, a2, 0xF6A93640uLL);
  if (!result)
    abort();
  return result;
}

int xmlStrlen(const xmlChar *str)
{
  unint64_t v1;

  if (str)
  {
    if (*str)
    {
      v1 = 0;
      while (str[++v1])
        ;
      if (v1 >> 31)
        LODWORD(str) = 0;
      else
        LODWORD(str) = v1;
    }
    else
    {
      LODWORD(str) = 0;
    }
  }
  return (int)str;
}

int xmlOutputBufferWriteString(xmlOutputBufferPtr out, const char *str)
{
  int v3;

  if (!out)
    return -1;
  v3 = -1;
  if (str)
  {
    if (!out->error)
    {
      v3 = strlen(str);
      if (v3 >= 1)
        return xmlOutputBufferWrite(out, v3, str);
    }
  }
  return v3;
}

int *__xmlIndentTreeOutput(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlIndentTreeOutput;
  else
    return &xmlGetGlobalState()->xmlIndentTreeOutput;
}

int xmlOutputBufferWriteEscape(xmlOutputBufferPtr out, const xmlChar *str, xmlCharEncodingOutputFunc escaping)
{
  const char *v3;
  unsigned int v4;
  xmlBufPtr buffer;
  unint64_t *p_buffer;
  int v9;
  uint64_t v10;
  uint64_t (*v11)(xmlChar *, int *, const char *, int *);
  xmlBufPtr *p_conv;
  int v13;
  uint64_t v14;
  xmlChar *v15;
  int v16;
  xmlBufPtr *v17;
  size_t v18;
  xmlChar *v19;
  size_t v20;
  xmlOutputWriteCallback writecallback;
  void *context;
  xmlChar *v23;
  xmlBufPtr *v24;
  xmlChar *v25;
  int written;
  int v27;
  BOOL v28;
  const char *v30;
  int v31;
  int v32;
  int v33;
  int v34;

  if (!out)
    return -1;
  v3 = (const char *)str;
  v4 = -1;
  if (str)
  {
    if (!out->error)
    {
      p_buffer = (unint64_t *)&out->buffer;
      buffer = out->buffer;
      if (buffer)
      {
        if (xmlBufGetAllocationScheme((uint64_t)buffer) != 2)
        {
          v9 = strlen(v3);
          if (v9 < 0)
            return 0;
          if (!out->error)
          {
            v10 = 0;
            v34 = 0;
            if (escaping)
              v11 = (uint64_t (*)(xmlChar *, int *, const char *, int *))escaping;
            else
              v11 = (uint64_t (*)(xmlChar *, int *, const char *, int *))xmlEscapeContent;
            p_conv = &out->conv;
            while (1)
            {
              v33 = v9;
              v34 = xmlBufAvail(*p_buffer);
              if (v34 > 39)
                break;
              v13 = xmlBufGrow(*p_buffer, 0x64u);
              v4 = -1;
              v14 = v10;
              LODWORD(v10) = -1;
              if (v13 < 0)
                return v4;
LABEL_45:
              if (v9 < 1)
                return v14;
              v4 = v14;
              v28 = (_DWORD)v10 == (_DWORD)v14;
              v10 = v14;
              if (v28)
                return v4;
            }
            if (out->encoder)
            {
              if (!*p_conv)
                *p_conv = (xmlBufPtr)xmlBufCreate();
              v15 = xmlBufEnd((xmlBufPtr)*p_buffer);
              v4 = -1;
              if ((v11(v15, &v34, v3, &v33) & 0x80000000) != 0 || !v34)
                return v4;
              xmlBufAddLen((uint64x2_t *)*p_buffer, v34);
              if (xmlBufUse((const xmlBufPtr)*p_buffer) <= 0xF9F && v33 == v9)
                return v10;
              v16 = xmlCharEncOutput(out, 0);
              if (v16 < 0 && v16 != -3)
              {
                v30 = "encoder error";
                v31 = 1544;
                v32 = 1544;
                goto LABEL_56;
              }
              v17 = &out->conv;
              if (!out->writecallback)
              {
                LODWORD(v18) = v16 & ~(v16 >> 31);
LABEL_36:
                v3 += v33;
                v9 -= v33;
                goto LABEL_37;
              }
            }
            else
            {
              v19 = xmlBufEnd((xmlBufPtr)*p_buffer);
              v4 = -1;
              if ((v11(v19, &v34, v3, &v33) & 0x80000000) != 0 || !v34)
                return v4;
              xmlBufAddLen((uint64x2_t *)out->buffer, v34);
              v17 = &out->buffer;
              if (!out->writecallback)
              {
                LODWORD(v18) = v34;
                goto LABEL_36;
              }
            }
            v20 = xmlBufUse(*v17);
            v18 = v20;
            writecallback = out->writecallback;
            v3 += v33;
            v9 -= v33;
            if (writecallback)
            {
              if ((int)v20 <= 3999 && v9 < 1)
                return v10;
              context = out->context;
              if (out->encoder)
              {
                v23 = xmlBufContent(*p_conv);
                v4 = ((uint64_t (*)(void *, xmlChar *, size_t))writecallback)(context, v23, v18);
                v24 = &out->conv;
                if ((v4 & 0x80000000) != 0)
                  goto LABEL_55;
              }
              else
              {
                v25 = xmlBufContent((const xmlBuf *)*p_buffer);
                v4 = ((uint64_t (*)(void *, xmlChar *, size_t))writecallback)(context, v25, v18);
                v24 = &out->buffer;
                if ((v4 & 0x80000000) != 0)
                {
LABEL_55:
                  v30 = "write error";
                  v31 = 1546;
                  v32 = 1546;
LABEL_56:
                  __xmlSimpleError(8u, v32, 0, v30, 0);
                  out->error = v31;
                  return v4;
                }
              }
              xmlBufShrink(*v24, v4);
              written = out->written;
              if (written <= (int)(v4 ^ 0x7FFFFFFF))
                v27 = written + v4;
              else
                v27 = 0x7FFFFFFF;
              out->written = v27;
              goto LABEL_44;
            }
LABEL_37:
            if (xmlBufAvail(*p_buffer) <= 0xF9F)
              xmlBufGrow(*p_buffer, 0xFA0u);
LABEL_44:
            v14 = (v18 + v10);
            goto LABEL_45;
          }
        }
      }
    }
  }
  return v4;
}

uint64_t xmlBufGetAllocationScheme(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 16);
  else
    return 0xFFFFFFFFLL;
}

uint64_t xmlEscapeContent(_BYTE *a1, int *a2, unsigned __int8 *a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  unsigned __int8 *i;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;

  v4 = *a2;
  v5 = *a4;
  v6 = (int)v5 < 1 || (int)v4 < 1;
  LODWORD(i) = (_DWORD)a3;
  LODWORD(v8) = (_DWORD)a1;
  if (!v6)
  {
    v9 = (unint64_t)&a1[v4];
    v10 = (unint64_t)&a3[v5];
    v8 = a1;
    for (i = a3; (unint64_t)i < v10 && (unint64_t)v8 < v9; ++i)
    {
      v11 = *i;
      if (v11 > 0x3B)
      {
        if (v11 == 62)
        {
          if ((uint64_t)(v9 - (_QWORD)v8) < 4)
            break;
          *(_DWORD *)v8 = 997484326;
          v8 += 4;
          continue;
        }
        if (v11 == 60)
        {
          if ((uint64_t)(v9 - (_QWORD)v8) < 4)
            break;
          *(_DWORD *)v8 = 997485606;
          v8 += 4;
          continue;
        }
      }
      else
      {
        if (v11 == 13)
        {
          if ((uint64_t)(v9 - (_QWORD)v8) < 5)
            break;
          *(_DWORD *)v8 = 858858278;
          goto LABEL_17;
        }
        if (v11 == 38)
        {
          if ((uint64_t)(v9 - (_QWORD)v8) < 5)
            break;
          *(_DWORD *)v8 = 1886216486;
LABEL_17:
          v8[4] = 59;
          v8 += 5;
          continue;
        }
      }
      *v8++ = v11;
    }
  }
  *a2 = (_DWORD)v8 - (_DWORD)a1;
  *a4 = (_DWORD)i - (_DWORD)a3;
  return 0;
}

unint64_t xmlBufAvail(unint64_t result)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v4;
  unint64_t v5;

  if (result)
  {
    if (*(_DWORD *)(result + 56))
    {
      return 0;
    }
    else
    {
      v1 = *(_QWORD *)(result + 40);
      v2 = *(unsigned int *)(result + 12);
      if (v2 <= 0x7FFFFFFE && v1 != v2)
      {
        *(_QWORD *)(result + 40) = v2;
        v1 = v2;
      }
      v4 = *(_QWORD *)(result + 32);
      v5 = *(unsigned int *)(result + 8);
      if (v5 <= 0x7FFFFFFE && v4 != v5)
      {
        *(_QWORD *)(result + 32) = v5;
        v4 = v5;
      }
      if (v1 <= v4)
        return 0;
      else
        return v1 + ~v4;
    }
  }
  return result;
}

uint64_t xmlAttrSerializeContent(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  int v5;
  uint64x2_t *v6;
  const xmlChar *v7;
  size_t v8;

  v2 = *(_QWORD *)(a2 + 24);
  if (v2)
  {
    v4 = result;
    do
    {
      v5 = *(_DWORD *)(v2 + 8);
      if (v5 == 5)
      {
        xmlBufAdd(*(uint64x2_t **)(v4 + 32), (const xmlChar *)"&", 1uLL);
        v6 = *(uint64x2_t **)(v4 + 32);
        v7 = *(const xmlChar **)(v2 + 16);
        v8 = xmlStrlen(v7);
        xmlBufAdd(v6, v7, v8);
        result = xmlBufAdd(*(uint64x2_t **)(v4 + 32), (const xmlChar *)";", 1uLL);
      }
      else if (v5 == 3)
      {
        result = (uint64_t)xmlBufAttrSerializeTxtContent(*(uint64x2_t **)(v4 + 32), *(_QWORD *)(a2 + 64), a2, *(const xmlChar **)(v2 + 80));
      }
      v2 = *(_QWORD *)(v2 + 48);
    }
    while (v2);
  }
  return result;
}

uint64x2_t *xmlBufAttrSerializeTxtContent(uint64x2_t *result, uint64_t a2, uint64_t a3, const xmlChar *__src)
{
  uint64x2_t *v4;
  const xmlChar *v5;
  unsigned int v6;
  uint64x2_t *v7;
  const char *v8;
  size_t v9;
  xmlChar *v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  const char *v14;
  int v15;
  xmlChar v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t __srca;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!__src)
    return result;
  v4 = result;
  v5 = __src;
  while (1)
  {
    v6 = *v5;
    if (v6 <= 0x21)
      break;
    if (*v5 > 0x3Bu)
    {
      if (v6 == 60)
      {
        if (__src != v5)
          xmlBufAdd(v4, __src, ((_DWORD)v5 - (_DWORD)__src));
        v7 = v4;
        v8 = "&lt;";
        goto LABEL_35;
      }
      if (v6 == 62)
      {
        if (__src != v5)
          xmlBufAdd(v4, __src, ((_DWORD)v5 - (_DWORD)__src));
        v7 = v4;
        v8 = "&gt;";
LABEL_35:
        v9 = 4;
        goto LABEL_36;
      }
LABEL_38:
      if (((char)v6 & 0x80000000) == 0 || (v10 = (xmlChar *)(v5 + 1), !v5[1]) || a2 && *(_QWORD *)(a2 + 112))
      {
        ++v5;
      }
      else
      {
        v23 = 0;
        __srca = 0;
        if (__src != v5)
          xmlBufAdd(v4, __src, ((_DWORD)v5 - (_DWORD)__src));
        v11 = *v5;
        if (v11 <= 0xBF)
        {
          v12 = 1400;
          v13 = a3;
          v14 = "string is not in UTF-8\n";
          goto LABEL_65;
        }
        if (v11 <= 0xDF)
        {
          v15 = (v11 & 0x1F) << 6;
          v16 = *v10;
          v17 = 2;
          goto LABEL_56;
        }
        if (v11 > 0xEF)
        {
          if (v11 > 0xF7)
            goto LABEL_64;
          if (!v5[2])
            goto LABEL_64;
          v16 = v5[3];
          if (!v16)
            goto LABEL_64;
          v15 = (((v11 & 7) << 12) | ((*v10 & 0x3F) << 6) | v5[2] & 0x3F) << 6;
          v17 = 4;
LABEL_56:
          v18 = v15 | v16 & 0x3F;
          if (v18 > 0xFF)
          {
            if (v18 - 0x10000 >= 0x100000 && v18 >> 11 >= 0x1B && (v18 - 57344) >> 1 >= 0xFFF)
              goto LABEL_64;
          }
          else if (v18 <= 0x1F && (v18 > 0xD || ((1 << v18) & 0x2600) == 0))
          {
            goto LABEL_64;
          }
          v19 = v17;
          xmlSerializeHexCharRef((uint64_t)&__srca, v18);
          result = (uint64x2_t *)xmlBufAdd(v4, (const xmlChar *)&__srca, 0xFFFFFFFFuLL);
          __src = &v5[v19];
          v5 += v19;
        }
        else
        {
          v16 = v5[2];
          if (v16)
          {
            v15 = (*v10 & 0x3F | ((v11 & 0xF) << 6)) << 6;
            v17 = 3;
            goto LABEL_56;
          }
LABEL_64:
          v12 = 1401;
          v13 = a3;
          v14 = "invalid character value\n";
LABEL_65:
          __xmlSimpleError(7u, v12, v13, v14, 0);
          xmlSerializeHexCharRef((uint64_t)&__srca, *v5);
          result = (uint64x2_t *)xmlBufAdd(v4, (const xmlChar *)&__srca, 0xFFFFFFFFuLL);
          __src = ++v5;
        }
      }
    }
    else
    {
      if (v6 != 34)
      {
        if (v6 == 38)
        {
          if (__src != v5)
            xmlBufAdd(v4, __src, ((_DWORD)v5 - (_DWORD)__src));
          v7 = v4;
          v8 = "&amp;";
LABEL_31:
          v9 = 5;
          goto LABEL_36;
        }
        goto LABEL_38;
      }
      if (__src != v5)
        xmlBufAdd(v4, __src, ((_DWORD)v5 - (_DWORD)__src));
      v7 = v4;
      v8 = "&quot;";
      v9 = 6;
LABEL_36:
      result = (uint64x2_t *)xmlBufAdd(v7, (const xmlChar *)v8, v9);
      __src = ++v5;
    }
  }
  if (*v5 > 9u)
  {
    if (v6 == 10)
    {
      if (__src != v5)
        xmlBufAdd(v4, __src, ((_DWORD)v5 - (_DWORD)__src));
      v7 = v4;
      v8 = "&#10;";
      goto LABEL_31;
    }
    if (v6 == 13)
    {
      if (__src != v5)
        xmlBufAdd(v4, __src, ((_DWORD)v5 - (_DWORD)__src));
      v7 = v4;
      v8 = "&#13;";
      goto LABEL_31;
    }
    goto LABEL_38;
  }
  if (v6 == 9)
  {
    if (__src != v5)
      xmlBufAdd(v4, __src, ((_DWORD)v5 - (_DWORD)__src));
    v7 = v4;
    v8 = "&#9;";
    goto LABEL_35;
  }
  if (*v5)
    goto LABEL_38;
  if (__src != v5)
    return (uint64x2_t *)xmlBufAdd(v4, __src, ((_DWORD)v5 - (_DWORD)__src));
  return result;
}

int xmlTextReaderGetParserLineNumber(xmlTextReaderPtr reader)
{
  uint64_t v1;
  uint64_t v2;

  if (reader)
  {
    v1 = *((_QWORD *)reader + 4);
    if (v1 && (v2 = *(_QWORD *)(v1 + 56)) != 0)
      LODWORD(reader) = *(_DWORD *)(v2 + 52);
    else
      LODWORD(reader) = 0;
  }
  return (int)reader;
}

int xmlTextReaderGetParserColumnNumber(xmlTextReaderPtr reader)
{
  uint64_t v1;
  uint64_t v2;

  if (reader)
  {
    v1 = *((_QWORD *)reader + 4);
    if (v1 && (v2 = *(_QWORD *)(v1 + 56)) != 0)
      LODWORD(reader) = *(_DWORD *)(v2 + 56);
    else
      LODWORD(reader) = 0;
  }
  return (int)reader;
}

const xmlChar *__cdecl xmlTextReaderConstName(xmlTextReaderPtr reader)
{
  uint64_t v1;
  const xmlChar *v2;
  xmlDict *v3;
  const char *v4;
  const xmlChar *result;
  uint64_t v6;
  const xmlChar *v7;

  if (reader && (v1 = *((_QWORD *)reader + 14)) != 0)
  {
    v2 = 0;
    if (*((_QWORD *)reader + 15))
      v1 = *((_QWORD *)reader + 15);
    switch(*(_DWORD *)(v1 + 8))
    {
      case 1:
      case 2:
        v6 = *(_QWORD *)(v1 + 72);
        if (!v6)
          return *(const xmlChar **)(v1 + 16);
        v4 = *(const char **)(v6 + 24);
        if (!v4)
          return *(const xmlChar **)(v1 + 16);
        v3 = (xmlDict *)*((_QWORD *)reader + 20);
        v7 = *(const xmlChar **)(v1 + 16);
LABEL_13:
        result = xmlDictQLookup(v3, (const xmlChar *)v4, v7);
        break;
      case 3:
        v3 = (xmlDict *)*((_QWORD *)reader + 20);
        v4 = "#text";
        return xmlDictLookup(v3, (const xmlChar *)v4, -1);
      case 4:
        v3 = (xmlDict *)*((_QWORD *)reader + 20);
        v4 = "#cdata-section";
        return xmlDictLookup(v3, (const xmlChar *)v4, -1);
      case 5:
      case 6:
      case 7:
      case 0xA:
      case 0xC:
      case 0xE:
        v3 = (xmlDict *)*((_QWORD *)reader + 20);
        v4 = *(const char **)(v1 + 16);
        return xmlDictLookup(v3, (const xmlChar *)v4, -1);
      case 8:
        v3 = (xmlDict *)*((_QWORD *)reader + 20);
        v4 = "#comment";
        return xmlDictLookup(v3, (const xmlChar *)v4, -1);
      case 9:
      case 0xD:
      case 0x15:
        v3 = (xmlDict *)*((_QWORD *)reader + 20);
        v4 = "#document";
        return xmlDictLookup(v3, (const xmlChar *)v4, -1);
      case 0xB:
        v3 = (xmlDict *)*((_QWORD *)reader + 20);
        v4 = "#document-fragment";
        return xmlDictLookup(v3, (const xmlChar *)v4, -1);
      case 0x12:
        v7 = *(const xmlChar **)(v1 + 24);
        v3 = (xmlDict *)*((_QWORD *)reader + 20);
        v4 = "xmlns";
        if (v7)
          goto LABEL_13;
        return xmlDictLookup(v3, (const xmlChar *)v4, -1);
      default:
        return v2;
    }
  }
  else
  {
    return 0;
  }
  return result;
}

BOOL __xmlInitializeDict()
{
  if (xmlDictMutex)
    return 1;
  pthread_once(&once_control_0, _xmlInitializeDictMutex);
  return xmlDictMutex != 0;
}

void _xmlInitializeDictMutex()
{
  xmlDictMutex = (uint64_t)xmlNewRMutex();
  xmlRMutexLock((xmlRMutexPtr)xmlDictMutex);
  rand_seed = time(0);
  rand_r((unsigned int *)&rand_seed);
  xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
}

xmlRMutexPtr xmlNewRMutex(void)
{
  pthread_mutex_t *v0;
  pthread_mutex_t *v1;

  v0 = (pthread_mutex_t *)malloc_type_malloc(0x80uLL, 0x1020040C717CFCDuLL);
  v1 = v0;
  if (v0)
  {
    pthread_mutex_init(v0, 0);
    v1[1].__sig = 0;
    pthread_cond_init((pthread_cond_t *)&v1[1].__opaque[8], 0);
  }
  return (xmlRMutexPtr)v1;
}

xmlAttrPtr xmlNewProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value)
{
  if (name)
    return xmlNewPropInternal((uint64_t)node, 0, (xmlChar *)name, value, 0);
  else
    return 0;
}

uint64_t htmlCompareStartClose(const char **a1, const char **a2)
{
  uint64_t result;

  result = strcmp(*a1, *a2);
  if (!(_DWORD)result)
    return strcmp(a1[1], a2[1]);
  return result;
}

const xmlChar *__cdecl xmlTextReaderConstValue(const xmlChar *reader)
{
  const xmlChar *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *Size;
  _QWORD *v8;
  xmlGenericErrorFunc v9;
  void **v10;

  if (!reader)
    return reader;
  v1 = reader;
  v2 = *((_QWORD *)reader + 14);
  if (!v2)
    return 0;
  reader = 0;
  if (*((_QWORD *)v1 + 15))
    v3 = *((_QWORD *)v1 + 15);
  else
    v3 = v2;
  v4 = *(_DWORD *)(v3 + 8);
  if (v4 <= 0x12)
  {
    if (((1 << v4) & 0x198) != 0)
      return *(const xmlChar **)(v3 + 80);
    if (v4 != 2)
    {
      if (v4 == 18)
        return *(const xmlChar **)(v3 + 16);
      return reader;
    }
    v5 = *(_QWORD *)(v3 + 24);
    if (v5 && *(_DWORD *)(v5 + 8) == 3 && !*(_QWORD *)(v5 + 48))
      return *(const xmlChar **)(v5 + 80);
    v6 = *((_QWORD *)v1 + 19);
    if (v6)
    {
      xmlBufEmpty(v6);
      goto LABEL_19;
    }
    Size = xmlBufCreateSize(100);
    *((_QWORD *)v1 + 19) = Size;
    if (Size)
    {
      xmlBufSetAllocationScheme((uint64_t)Size, 5u);
LABEL_19:
      xmlBufGetNodeContent(*((xmlBufPtr *)v1 + 19), (const xmlNode *)v3);
      reader = xmlBufContent(*((const xmlBuf **)v1 + 19));
      if (!reader)
      {
        xmlBufFree(*((_DWORD **)v1 + 19));
        v8 = xmlBufCreateSize(100);
        *((_QWORD *)v1 + 19) = v8;
        xmlBufSetAllocationScheme((uint64_t)v8, 5u);
        return (const xmlChar *)&byte_1B0865C1A;
      }
      return reader;
    }
    v9 = *__xmlGenericError();
    v10 = __xmlGenericErrorContext();
    v9(*v10, "xmlTextReaderSetup : malloc failed\n");
    return 0;
  }
  return reader;
}

uint64_t xmlBufEmpty(uint64_t result)
{
  _BYTE *v1;
  unint64_t v2;
  unint64_t v3;
  int v5;
  unint64_t v6;
  _BYTE *v7;
  unint64_t v8;
  int v9;

  if (result)
  {
    if (!*(_DWORD *)(result + 56))
    {
      v1 = *(_BYTE **)result;
      if (*(_QWORD *)result)
      {
        v2 = *(_QWORD *)(result + 40);
        v3 = *(unsigned int *)(result + 12);
        if (v3 <= 0x7FFFFFFE && v2 != v3)
        {
          *(_QWORD *)(result + 40) = v3;
          v2 = v3;
        }
        *(_QWORD *)(result + 32) = 0;
        v5 = *(_DWORD *)(result + 16);
        if (v5 == 3)
        {
          v7 = *(_BYTE **)(result + 24);
          if (v7)
          {
            *(_QWORD *)(result + 40) = v1 - v7 + v2;
            *(_QWORD *)result = v7;
            v1 = v7;
          }
        }
        else if (v5 == 2)
        {
          LODWORD(v6) = 0;
          *(_QWORD *)result = &byte_1B0865C1A;
          if (v2 >= 0x7FFFFFFF)
            LODWORD(v2) = 0x7FFFFFFF;
          *(_DWORD *)(result + 12) = v2;
LABEL_20:
          v9 = v6;
LABEL_21:
          *(_DWORD *)(result + 8) = v9;
          return result;
        }
        *v1 = 0;
        v6 = *(_QWORD *)(result + 32);
        v8 = *(_QWORD *)(result + 40);
        v9 = 0x7FFFFFFF;
        if (v8 >= 0x7FFFFFFF)
          LODWORD(v8) = 0x7FFFFFFF;
        *(_DWORD *)(result + 12) = v8;
        if (v6 > 0x7FFFFFFE)
          goto LABEL_21;
        goto LABEL_20;
      }
    }
  }
  return result;
}

int xmlTextReaderNodeType(xmlTextReaderPtr reader)
{
  const xmlNode *v2;
  uint64_t v3;
  int v4;
  int result;

  if (!reader)
    return -1;
  v2 = (const xmlNode *)*((_QWORD *)reader + 14);
  if (!v2)
    return 0;
  v3 = *((_QWORD *)reader + 15);
  if (!v3)
    v3 = *((_QWORD *)reader + 14);
  v4 = *(_DWORD *)(v3 + 8);
  result = 2;
  switch(v4)
  {
    case 1:
      if (((*((_DWORD *)reader + 6) - 2) & 0xFFFFFFFD) != 0)
        result = 1;
      else
        result = 15;
      break;
    case 2:
    case 18:
      return result;
    case 3:
      if (xmlIsBlankNode(v2))
      {
        if (xmlNodeGetSpacePreserve(*((const xmlNode **)reader + 14)))
          result = 14;
        else
          result = 13;
      }
      else
      {
        result = 3;
      }
      break;
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 11:
    case 12:
      result = v4;
      break;
    case 9:
    case 13:
    case 21:
      result = 9;
      break;
    case 10:
    case 14:
      result = 10;
      break;
    case 15:
    case 16:
    case 17:
    case 19:
    case 20:
      return 0;
    default:
      return -1;
  }
  return result;
}

int xmlIsBlankNode(const xmlNode *node)
{
  xmlChar *content;
  unsigned int v2;

  if (node)
  {
    if (node->type - 3 <= 1)
    {
      content = node->content;
      if (!content)
      {
LABEL_8:
        LODWORD(node) = 1;
        return (int)node;
      }
      while (1)
      {
        v2 = *content;
        if (v2 > 0x20)
          break;
        if (((1 << v2) & 0x100002600) == 0)
        {
          if (*content)
            break;
          goto LABEL_8;
        }
        ++content;
      }
    }
    LODWORD(node) = 0;
  }
  return (int)node;
}

int xmlNodeGetSpacePreserve(const xmlNode *cur)
{
  const xmlNode *v1;
  xmlChar *NsProp;
  xmlChar *v3;
  int v4;

  if (!cur)
    return -1;
  v1 = cur;
  if (cur->type != XML_ELEMENT_NODE)
    return -1;
  while (1)
  {
    NsProp = xmlGetNsProp(v1, (const xmlChar *)"space", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
    if (NsProp)
      break;
LABEL_7:
    v1 = v1->parent;
    if (!v1)
      return -1;
  }
  v3 = NsProp;
  if (xmlStrEqual(NsProp, (const xmlChar *)"preserve"))
  {
    v4 = 1;
    goto LABEL_12;
  }
  if (!xmlStrEqual(v3, (const xmlChar *)"default"))
  {
    xmlFree(v3);
    goto LABEL_7;
  }
  v4 = 0;
LABEL_12:
  xmlFree(v3);
  return v4;
}

BOOL xmlOnceInit()
{
  pthread_key_create((pthread_key_t *)&globalkey, (void (__cdecl *)(void *))xmlFreeGlobalState);
  return __xmlInitializeDict();
}

uint64_t __startElementNSNeedsUndeclaredPrefixQuirk_block_invoke()
{
  uint64_t result;
  BOOL v1;

  result = (uint64_t)_dyld_get_image_name(0);
  if (result
    && (result = (uint64_t)strrchr((char *)result, 47)) != 0
    && (result = strcmp((const char *)(result + 1), "Microsoft Document Connection"), !(_DWORD)result))
  {
    result = dyld_get_program_sdk_version();
    v1 = result >> 8 < 0xA09;
  }
  else
  {
    v1 = 0;
  }
  startElementNSNeedsUndeclaredPrefixQuirk_needsQuirk = v1;
  return result;
}

htmlParserCtxtPtr htmlCreateMemoryParserCtxt(const char *buffer, int size)
{
  xmlParserCtxt *v2;
  xmlParserInputBufferPtr Mem;
  xmlParserInputBufferPtr v6;
  xmlParserInputPtr v7;
  xmlParserInput *v8;

  v2 = 0;
  if (buffer)
  {
    if (size >= 1)
    {
      v2 = htmlNewParserCtxt();
      if (v2)
      {
        Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
        if (Mem)
        {
          v6 = Mem;
          v7 = xmlNewInputStream(v2);
          if (v7)
          {
            v8 = v7;
            v7->buf = v6;
            v7->filename = 0;
            xmlBufResetInput((uint64_t *)v6->buffer, v7);
            inputPush(v2, v8);
            return v2;
          }
          xmlFreeParserInputBuffer(v6);
          xmlFreeParserCtxt(v2);
        }
        return 0;
      }
    }
  }
  return v2;
}

htmlParserCtxtPtr htmlNewParserCtxt(void)
{
  xmlParserCtxt *v0;
  xmlParserCtxt *v1;
  xmlDict *v2;
  _xmlSAXHandler *v3;
  xmlParserInputPtr *v4;
  xmlParserInputPtr *p_input;
  xmlNodePtr *v6;
  const xmlChar **v7;
  xmlSAXHandlerV1 *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  v0 = (xmlParserCtxt *)xmlMalloc(0x2F0uLL);
  v1 = v0;
  if (!v0)
  {
    htmlErrMemory(0, (const xmlChar *)"NewParserCtxt: out of memory\n");
    return v1;
  }
  bzero(v0, 0x2F0uLL);
  bzero(v1, 0x2F0uLL);
  v2 = xmlDictCreate();
  v1->dict = v2;
  if (!v2 || (v2 = (xmlDict *)xmlMalloc(0x100uLL)) == 0)
  {
    htmlErrMemory(v2, (const xmlChar *)"htmlInitParserCtxt: out of memory\n");
LABEL_9:
    xmlFreeParserCtxt(v1);
    return 0;
  }
  v3 = (_xmlSAXHandler *)v2;
  *((_OWORD *)v2 + 14) = 0u;
  *((_OWORD *)v2 + 15) = 0u;
  *((_OWORD *)v2 + 12) = 0u;
  *((_OWORD *)v2 + 13) = 0u;
  *((_OWORD *)v2 + 10) = 0u;
  *((_OWORD *)v2 + 11) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *(_OWORD *)v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  v4 = (xmlParserInputPtr *)xmlMalloc(0x28uLL);
  v1->inputTab = v4;
  if (!v4)
  {
    htmlErrMemory(0, (const xmlChar *)"htmlInitParserCtxt: out of memory\n");
    v1->input = 0;
    *(_QWORD *)&v1->inputNr = 0;
    goto LABEL_9;
  }
  v1->input = 0;
  p_input = &v1->input;
  *(_QWORD *)&v1->inputNr = 0x500000000;
  v1->version = 0;
  v1->encoding = 0;
  v1->standalone = -1;
  v1->instate = XML_PARSER_START;
  v6 = (xmlNodePtr *)xmlMalloc(0x50uLL);
  v1->nodeTab = v6;
  if (!v6)
  {
    htmlErrMemory(0, (const xmlChar *)"htmlInitParserCtxt: out of memory\n");
    *p_input = 0;
    *(_QWORD *)&v1->inputNr = 0;
    v1->node = 0;
    *(_QWORD *)&v1->nodeNr = 0;
    goto LABEL_9;
  }
  v1->node = 0;
  *(_QWORD *)&v1->nodeNr = 0xA00000000;
  v7 = (const xmlChar **)xmlMalloc(0x50uLL);
  v1->nameTab = v7;
  if (!v7)
  {
    htmlErrMemory(0, (const xmlChar *)"htmlInitParserCtxt: out of memory\n");
    *p_input = 0;
    *(_QWORD *)&v1->inputNr = 0;
    v1->node = 0;
    *(_QWORD *)&v1->nodeNr = 0;
    v1->name = 0;
    *(_QWORD *)&v1->nameNr = 0;
    goto LABEL_9;
  }
  *(_QWORD *)&v1->nameNr = 0xA00000000;
  v1->name = 0;
  *(_OWORD *)&v1->nodeInfoNr = 0u;
  v1->sax = v3;
  v8 = __htmlDefaultSAXHandler();
  v9 = *(_OWORD *)&v8->hasInternalSubset;
  *(_OWORD *)&v3->internalSubset = *(_OWORD *)&v8->internalSubset;
  *(_OWORD *)&v3->hasInternalSubset = v9;
  v10 = *(_OWORD *)&v8->unparsedEntityDecl;
  v12 = *(_OWORD *)&v8->resolveEntity;
  v11 = *(_OWORD *)&v8->entityDecl;
  *(_OWORD *)&v3->attributeDecl = *(_OWORD *)&v8->attributeDecl;
  *(_OWORD *)&v3->unparsedEntityDecl = v10;
  *(_OWORD *)&v3->resolveEntity = v12;
  *(_OWORD *)&v3->entityDecl = v11;
  v13 = *(_OWORD *)&v8->ignorableWhitespace;
  v15 = *(_OWORD *)&v8->startDocument;
  v14 = *(_OWORD *)&v8->startElement;
  *(_OWORD *)&v3->reference = *(_OWORD *)&v8->reference;
  *(_OWORD *)&v3->ignorableWhitespace = v13;
  *(_OWORD *)&v3->startDocument = v15;
  *(_OWORD *)&v3->startElement = v14;
  v16 = *(_OWORD *)&v8->externalSubset;
  v18 = *(_OWORD *)&v8->comment;
  v17 = *(_OWORD *)&v8->error;
  *(_OWORD *)&v3->getParameterEntity = *(_OWORD *)&v8->getParameterEntity;
  *(_OWORD *)&v3->externalSubset = v16;
  *(_OWORD *)&v3->comment = v18;
  *(_OWORD *)&v3->error = v17;
  v1->userData = v1;
  v1->myDoc = 0;
  *(_QWORD *)&v1->wellFormed = 1;
  v1->linenumbers = *__xmlLineNumbersDefaultValue();
  v1->keepBlanks = *__xmlKeepBlanksDefaultValue();
  v1->html = 1;
  v1->vctxt.finishDtd = -1412623820;
  v1->vctxt.userData = v1;
  v1->vctxt.error = xmlParserValidityError;
  v1->vctxt.warning = xmlParserValidityWarning;
  v1->record_info = 0;
  v1->validate = 0;
  v1->checkIndex = 0;
  v1->catalogs = 0;
  xmlInitNodeInfoSeq(&v1->node_seq);
  return v1;
}

void xmlInitNodeInfoSeq(xmlParserNodeInfoSeqPtr seq)
{
  if (seq)
  {
    seq->maximum = 0;
    seq->length = 0;
    seq->buffer = 0;
  }
}

uint64_t xmlParse3986Authority(uint64_t a1, const xmlChar **a2)
{
  const xmlChar *v4;
  const xmlChar *v5;
  int v6;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  void *v11;
  int v12;
  xmlChar *v13;
  unsigned int v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  unsigned __int8 *i;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  void *v22;
  void *v23;
  unsigned __int8 *v24;
  int v25;
  void *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t result;
  unsigned __int8 *v33;

  v4 = *a2;
  v5 = *a2;
  while (1)
  {
    v6 = *v5;
    if ((v6 - 48) < 0xA || (v6 & 0xFFFFFFDF) - 65 < 0x1A)
      goto LABEL_9;
    v8 = (v6 - 33);
    if (v8 > 0x3E)
      goto LABEL_21;
    if (((1 << (v6 - 33)) & 0x4000000016003FE9) != 0)
      goto LABEL_9;
    if (v8 != 4)
      break;
    if ((v5[1] - 48) >= 0xAu)
    {
      v9 = v5[1] - 65;
      if (v9 > 0x25 || ((1 << v9) & 0x3F0000003FLL) == 0)
        goto LABEL_32;
    }
    if ((v5[2] - 48) >= 0xAu)
    {
      v10 = v5[2] - 65;
      if (v10 > 0x25 || ((1 << v10) & 0x3F0000003FLL) == 0)
        goto LABEL_32;
    }
LABEL_9:
    if (v6 == 37)
      v5 += 3;
    else
      ++v5;
  }
  if (v8 != 31)
  {
LABEL_21:
    if (v6 != 126)
      goto LABEL_32;
    goto LABEL_9;
  }
  if (!a1)
    goto LABEL_30;
  v11 = *(void **)(a1 + 32);
  if (v11)
    xmlFree(v11);
  v12 = (_DWORD)v5 - (_DWORD)v4;
  v13 = (*(_BYTE *)(a1 + 72) & 2) != 0
      ? xmlStrndup(v4, v12)
      : (xmlChar *)xmlURIUnescapeString((const char *)v4, v12, 0);
  *(_QWORD *)(a1 + 32) = v13;
  if (*v5 != 64)
    v4 = *a2;
  else
LABEL_30:
    v4 = v5 + 1;
LABEL_32:
  v33 = (unsigned __int8 *)v4;
  v14 = *v4;
  if (v14 == 91)
  {
    v15 = (unsigned __int8 *)(v4 + 1);
    while (1)
    {
      v17 = *v15++;
      v16 = v17;
      if (!v17)
        return 1;
      if (v16 == 93)
      {
        v33 = v15;
        goto LABEL_64;
      }
    }
  }
  if (v14 - 48 > 9
    || xmlParse3986DecOctet(&v33)
    || *v33 != 46
    || (++v33, xmlParse3986DecOctet(&v33))
    || *v33 != 46
    || xmlParse3986DecOctet(&v33)
    || *v33 != 46
    || xmlParse3986DecOctet(&v33))
  {
    for (i = (unsigned __int8 *)v4; ; v14 = *i)
    {
      if (v14 - 48 < 0xA || (v14 & 0xDF) - 65 < 0x1A)
        goto LABEL_50;
      v19 = v14 - 33;
      if (v19 > 0x3E)
        goto LABEL_62;
      if (((1 << (v14 - 33)) & 0x4000000014003FE9) != 0)
        goto LABEL_50;
      if (v19 == 4)
      {
        if ((i[1] - 48) >= 0xAu
          && ((v20 = i[1] - 65, v20 > 0x25) || ((1 << v20) & 0x3F0000003FLL) == 0)
          || (i[2] - 48) >= 0xAu
          && ((v21 = i[2] - 65, v21 > 0x25) || ((1 << v21) & 0x3F0000003FLL) == 0))
        {
LABEL_63:
          v33 = i;
          break;
        }
      }
      else
      {
LABEL_62:
        if (v14 != 126)
          goto LABEL_63;
      }
LABEL_50:
      if (v14 == 37)
        i += 3;
      else
        ++i;
    }
  }
LABEL_64:
  if (a1)
  {
    v22 = *(void **)(a1 + 16);
    if (v22)
      xmlFree(v22);
    *(_QWORD *)(a1 + 16) = 0;
    v23 = *(void **)(a1 + 24);
    if (v23)
      xmlFree(v23);
    v24 = v33;
    if (v33 == v4)
    {
      *(_QWORD *)(a1 + 24) = 0;
      v24 = (unsigned __int8 *)v4;
    }
    else
    {
      v25 = (_DWORD)v33 - (_DWORD)v4;
      if ((*(_BYTE *)(a1 + 72) & 2) != 0)
        v26 = xmlStrndup(v4, v25);
      else
        v26 = xmlURIUnescapeString((const char *)v4, v25, 0);
      *(_QWORD *)(a1 + 24) = v26;
    }
  }
  else
  {
    v24 = v33;
  }
  if (*v24 == 58)
  {
    v28 = *++v24;
    v27 = v28;
    if ((v28 - 48) <= 9)
    {
      v29 = 0;
      while (v29 <= 214748364)
      {
        v30 = 10 * v29;
        if (v30 > -2147483601 - v27)
          break;
        v29 = v27 + v30 - 48;
        v31 = *++v24;
        v27 = v31;
        if ((v31 - 48) >= 0xA)
        {
          if (a1)
            *(_DWORD *)(a1 + 40) = v29;
          goto LABEL_84;
        }
      }
    }
    return 1;
  }
LABEL_84:
  result = 0;
  *a2 = v24;
  return result;
}

uint64_t xmlParse3986PathAbEmpty(uint64_t a1, const xmlChar **a2)
{
  const xmlChar *v4;
  uint64_t v5;
  unsigned __int8 *v6;
  void *v7;
  int v8;
  void *v9;
  unsigned __int8 *v11;

  v4 = *a2;
  v11 = (unsigned __int8 *)*a2;
  v5 = 1;
  while (1)
  {
    v6 = v11;
    if (*v11 != 47)
      break;
    ++v11;
    if (xmlParse3986Segment(&v11, 0, 1))
      return v5;
  }
  if (a1)
  {
    v7 = *(void **)(a1 + 48);
    if (v7)
    {
      xmlFree(v7);
      v4 = *a2;
    }
    if (v4 == v6)
    {
      v9 = 0;
    }
    else
    {
      v8 = (_DWORD)v6 - (_DWORD)v4;
      if ((*(_BYTE *)(a1 + 72) & 2) != 0)
        v9 = xmlStrndup(v4, v8);
      else
        v9 = xmlURIUnescapeString((const char *)v4, v8, 0);
    }
    *(_QWORD *)(a1 + 48) = v9;
  }
  v5 = 0;
  *a2 = v6;
  return v5;
}

BOOL xmlParse3986Segment(unsigned __int8 **a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 *v3;
  int v4;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  unsigned int v12;
  BOOL v13;
  uint64_t v14;
  unsigned int v16;
  uint64_t v17;

  v3 = *a1;
  v4 = **a1;
  if ((v4 - 48) < 0xA || (v4 & 0xFFFFFFDF) - 65 < 0x1A)
    goto LABEL_8;
  v6 = (v4 - 33);
  if (v6 > 0x3E)
    goto LABEL_42;
  if (((1 << (v4 - 33)) & 0x4000000096003FE9) != 0)
    goto LABEL_8;
  if (v6 != 4)
  {
LABEL_42:
    if (v4 == 126)
      goto LABEL_8;
    return a3 == 0;
  }
  if ((v3[1] - 48) >= 0xAu)
  {
    v12 = v3[1] - 65;
    v13 = v12 > 0x25;
    v14 = (1 << v12) & 0x3F0000003FLL;
    if (v13 || v14 == 0)
      return a3 == 0;
  }
  if ((v3[2] - 48) >= 0xAu)
  {
    v16 = v3[2] - 65;
    v13 = v16 > 0x25;
    v17 = (1 << v16) & 0x3F0000003FLL;
    if (v13 || v17 == 0)
      return a3 == 0;
  }
  while (1)
  {
LABEL_8:
    if ((v4 - 48) < 0xA || (v4 & 0xDFu) - 65 < 0x1A)
      goto LABEL_12;
    v7 = (v4 - 33);
    if (v7 > 0x3E)
      goto LABEL_26;
    if (((1 << (v4 - 33)) & 0x4000000096003FE9) != 0)
      goto LABEL_12;
    if (v7 != 4)
    {
LABEL_26:
      if (v4 != 126)
        break;
LABEL_12:
      if (v4 == a2)
        break;
      goto LABEL_13;
    }
    if ((v3[1] - 48) >= 0xAu)
    {
      v8 = v3[1] - 65;
      if (v8 > 0x25 || ((1 << v8) & 0x3F0000003FLL) == 0)
        break;
    }
    v9 = v3[2];
    if ((v9 - 48) < 0xA || (v9 - 97) < 6)
      goto LABEL_12;
    if (a2 == 37 || (v9 - 71) < 0xFFFFFFFA)
      break;
LABEL_13:
    if (v4 == 37)
      v3 += 3;
    else
      ++v3;
    v4 = *v3;
  }
  v10 = 0;
  *a1 = v3;
  return v10;
}

char *__cdecl xmlURIUnescapeString(const char *str, int len, char *target)
{
  unsigned int v4;
  const char *v5;
  char *v6;
  int v7;
  int v8;
  int v9;
  BOOL v10;
  unsigned int v11;
  unsigned int v12;
  char v13;
  char v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  char v18;
  char v19;

  if (!str)
    return 0;
  v4 = len;
  v5 = str;
  if (len <= 0)
  {
    v4 = strlen(str);
    if ((v4 & 0x80000000) != 0)
      return 0;
  }
  if (target || (target = (char *)xmlMallocAtomic(v4 + 1)) != 0)
  {
    v6 = target;
    if (v4)
    {
      v6 = target;
      do
      {
        v7 = *(unsigned __int8 *)v5;
        if (v4 >= 3
          && v7 == 37
          && ((v8 = v5[1], (v5[1] - 58) > 0xF5u) || ((v8 & 0xDF) - 71) >= 0xFAu)
          && ((v9 = *((unsigned __int8 *)v5 + 2), (v9 - 58) <= 0xFFFFFFF5)
            ? (v10 = (v9 & 0xFFFFFFDF) - 71 >= 0xFFFFFFFA)
            : (v10 = 1),
              v10))
        {
          v11 = v8 - 48;
          v12 = v8 - 97;
          if ((v8 - 65) >= 6)
            v13 = 0;
          else
            v13 = v8 - 55;
          v14 = v8 - 87;
          if (v12 > 5)
            v14 = v13;
          if (v11 > 9)
            LOBYTE(v11) = v14;
          v15 = v9 - 48;
          v16 = v9 - 97;
          v17 = v9 - 65;
          v18 = v9 + 16 * v11;
          if (v17 <= 5)
            LOBYTE(v11) = v18 - 55;
          if (v16 <= 5)
            LOBYTE(v11) = v18 - 87;
          v19 = v18 - 48;
          if (v15 <= 9)
            LOBYTE(v11) = v19;
          v5 += 3;
          *v6 = v11;
          v4 -= 3;
        }
        else
        {
          ++v5;
          *v6 = v7;
          --v4;
        }
        ++v6;
      }
      while (v4);
    }
    *v6 = 0;
  }
  else
  {
    xmlURIErrMemory((const xmlChar *)"unescaping URI value\n");
  }
  return target;
}

int htmlCtxtUseOptions(htmlParserCtxtPtr ctxt, int options)
{
  int v4;
  int v5;
  int result;
  _xmlSAXHandler *sax;
  int v8;

  if (!ctxt)
    return -1;
  if (htmlParserNeedsNoBlankQuirk_hasEvaluatedQuirk != -1)
    dispatch_once(&htmlParserNeedsNoBlankQuirk_hasEvaluatedQuirk, &__block_literal_global);
  if (htmlParserNeedsNoBlankQuirk_needsQuirk)
    v4 = options | 0x100;
  else
    v4 = options;
  if ((v4 & 0x40) == 0)
  {
    if ((v4 & 0x20) == 0)
      goto LABEL_9;
LABEL_13:
    sax = ctxt->sax;
    ctxt->vctxt.error = 0;
    sax->error = 0;
    sax->fatalError = 0;
    v4 -= 32;
    ctxt->options |= 0x20u;
    if ((v4 & 0x80) == 0)
      goto LABEL_10;
    goto LABEL_14;
  }
  ctxt->sax->warning = 0;
  ctxt->vctxt.warning = 0;
  v4 -= 64;
  ctxt->options |= 0x40u;
  if ((v4 & 0x20) != 0)
    goto LABEL_13;
LABEL_9:
  if ((v4 & 0x80) == 0)
  {
LABEL_10:
    v5 = 0;
    goto LABEL_15;
  }
LABEL_14:
  v4 -= 128;
  ctxt->options |= 0x80u;
  v5 = 1;
LABEL_15:
  ctxt->pedantic = v5;
  if ((v4 & 0x100) != 0)
  {
    v8 = 0;
    ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
    v4 -= 256;
    ctxt->options |= 0x100u;
  }
  else
  {
    v8 = 1;
  }
  ctxt->keepBlanks = v8;
  result = v4 & 0xFFFFFFFE;
  ctxt->recovery = v4 & 1;
  if ((v4 & 0x10000) != 0)
  {
    ctxt->options |= 0x10000u;
    result -= 0x10000;
    if ((result & 0x80000) == 0)
    {
LABEL_20:
      if ((result & 4) == 0)
        goto LABEL_21;
      goto LABEL_27;
    }
  }
  else if ((v4 & 0x80000) == 0)
  {
    goto LABEL_20;
  }
  ctxt->options |= 0x80000u;
  result -= 0x80000;
  if ((result & 4) == 0)
  {
LABEL_21:
    if ((result & 0x200000) == 0)
      goto LABEL_22;
LABEL_28:
    ctxt->options |= 0x200000u;
    result -= 0x200000;
    if ((result & 0x2000) == 0)
      goto LABEL_24;
    goto LABEL_23;
  }
LABEL_27:
  ctxt->options |= 4u;
  result -= 4;
  if ((result & 0x200000) != 0)
    goto LABEL_28;
LABEL_22:
  if ((result & 0x2000) != 0)
  {
LABEL_23:
    ctxt->options |= 0x2000u;
    result -= 0x2000;
  }
LABEL_24:
  ctxt->dictNames = 0;
  return result;
}

xmlOutputBufferPtr xmlOutputBufferCreateIO(xmlOutputBufferPtr iowrite, xmlOutputCloseCallback ioclose, void *ioctx, xmlCharEncodingHandlerPtr encoder)
{
  int (__cdecl *v6)(void *, const char *, int);

  if (iowrite)
  {
    v6 = (int (__cdecl *)(void *, const char *, int))iowrite;
    iowrite = (xmlOutputBufferPtr)xmlAllocOutputBufferInternal((uint64_t)encoder);
    if (iowrite)
    {
      iowrite->context = ioctx;
      iowrite->writecallback = v6;
      iowrite->closecallback = ioclose;
    }
  }
  return iowrite;
}

_QWORD *xmlAllocOutputBufferInternal(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *Size;

  v2 = xmlMalloc(0x38uLL);
  v3 = v2;
  if (v2)
  {
    v2[6] = 0;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *(_OWORD *)v2 = 0u;
    v4 = xmlBufCreate();
    v3[4] = v4;
    if (v4)
    {
      xmlBufSetAllocationScheme((uint64_t)v4, 3u);
      v3[3] = a1;
      if (!a1)
      {
        v3[5] = 0;
        goto LABEL_8;
      }
      Size = xmlBufCreateSize(4000);
      v3[5] = Size;
      if (Size)
      {
        xmlCharEncOutput(v3, 1);
LABEL_8:
        *((_DWORD *)v3 + 12) = 0;
        v3[1] = 0;
        v3[2] = 0;
        *v3 = 0;
        return v3;
      }
      xmlBufFree((_DWORD *)v3[4]);
    }
    xmlFree(v3);
    return 0;
  }
  __xmlSimpleError(8u, 2, 0, 0, (const xmlChar *)"creating output buffer");
  return v3;
}

_QWORD *xmlBufCreate()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v0 = xmlMalloc(0x40uLL);
  v1 = v0;
  if (v0)
  {
    v0[4] = 0;
    *((_DWORD *)v0 + 14) = 0;
    v0[6] = 0;
    v2 = *__xmlDefaultBufferSize();
    v1[5] = v2;
    LODWORD(v3) = 0x7FFFFFFF;
    if (v2 >= 0x7FFFFFFF)
      LODWORD(v2) = 0x7FFFFFFF;
    if (v1[4] < 0x7FFFFFFFuLL)
      v3 = v1[4];
    *((_DWORD *)v1 + 2) = v3;
    *((_DWORD *)v1 + 3) = v2;
    *((xmlBufferAllocationScheme *)v1 + 4) = *__xmlBufferAllocScheme();
    v4 = xmlMallocAtomic(v1[5]);
    *v1 = v4;
    if (v4)
    {
      bzero(v4, v1[5]);
      v1[3] = 0;
    }
    else
    {
      __xmlSimpleError(0x1Du, 2, 0, 0, (const xmlChar *)"creating buffer");
      if (!*((_DWORD *)v1 + 14))
        *((_DWORD *)v1 + 14) = 2;
      xmlFree(v1);
      return 0;
    }
  }
  else
  {
    __xmlSimpleError(0x1Du, 2, 0, 0, (const xmlChar *)"creating buffer");
  }
  return v1;
}

void xmlSetExternalEntityLoader(xmlExternalEntityLoader f)
{
  xmlCurrentExternalEntityLoader = (uint64_t (*)(char *, char *, xmlParserCtxtPtr))f;
}

xmlExternalEntityLoader xmlGetExternalEntityLoader(void)
{
  return (xmlExternalEntityLoader)xmlCurrentExternalEntityLoader;
}

uint64_t htmlParseStartTag(uint64_t a1)
{
  uint64_t v2;
  const xmlChar **v3;
  int v4;
  xmlParserInput *v5;
  const xmlChar *v6;
  xmlChar *v7;
  int v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  xmlParserInput *v13;
  const xmlChar *cur;
  int v15;
  const xmlChar *v16;
  const xmlChar *v17;
  int v18;
  xmlChar *v19;
  _DWORD *v20;
  int v21;
  const char *v22;
  unsigned __int8 *v23;
  int v24;
  uint64_t v25;
  const xmlChar **v26;
  const xmlChar **v27;
  const xmlChar *v28;
  xmlChar *v29;
  const xmlChar **v30;
  xmlChar *v31;
  const xmlChar *v32;
  uint64_t v33;
  xmlChar *v34;
  void (*v35)(uint64_t, xmlChar *, const xmlChar **);
  uint64_t v36;
  xmlChar *str1;
  int v38;
  int v39;

  v2 = *(_QWORD *)(a1 + 56);
  if (!v2)
  {
    htmlParseErr((_DWORD *)a1, 1, "htmlParseStartTag: context error\n", 0, 0);
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 272) == -1 || **(_BYTE **)(v2 + 32) != 60)
    return 0xFFFFFFFFLL;
  xmlNextChar((xmlParserCtxtPtr)a1);
  v3 = *(const xmlChar ***)(a1 + 464);
  v4 = *(_DWORD *)(a1 + 472);
  if (!*(_DWORD *)(a1 + 452))
  {
    v5 = *(xmlParserInput **)(a1 + 56);
    if (v5->end - v5->cur <= 249)
      xmlParserInputGrow(v5, 250);
  }
  v6 = htmlParseHTMLName((xmlParserCtxtPtr)a1);
  if (!v6)
  {
    htmlParseErr((_DWORD *)a1, 68, "htmlParseStartTag: invalid element name\n", 0, 0);
    v9 = 0xFFFFFFFFLL;
    while (1)
    {
      if (!**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32) || **(_BYTE **)(*(_QWORD *)(a1 + 56) + 32) == 62)
        return v9;
      if (*(_DWORD *)(a1 + 272) == -1)
        break;
      xmlNextChar((xmlParserCtxtPtr)a1);
    }
    return 0xFFFFFFFFLL;
  }
  v7 = (xmlChar *)v6;
  v8 = xmlStrEqual(v6, (const xmlChar *)"meta");
  htmlAutoClose((int *)a1, (uint64_t)v7);
  htmlCheckImplied(a1, v7);
  if (*(int *)(a1 + 296) < 1)
  {
    v9 = 0;
    goto LABEL_22;
  }
  if (xmlStrEqual(v7, (const xmlChar *)"html"))
  {
    htmlParseErr((_DWORD *)a1, 800, "htmlParseStartTag: misplaced <html> tag\n", v7, 0);
    ++*(_DWORD *)(a1 + 392);
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  if (*(_DWORD *)(a1 + 296) != 1)
  {
LABEL_22:
    if (xmlStrEqual(v7, (const xmlChar *)"head"))
    {
      htmlParseErr((_DWORD *)a1, 800, "htmlParseStartTag: misplaced <head> tag\n", v7, 0);
      ++*(_DWORD *)(a1 + 392);
      v9 = 1;
    }
  }
  v38 = v8;
  if (xmlStrEqual(v7, (const xmlChar *)"body") && *(int *)(a1 + 296) >= 1)
  {
    v11 = 0;
    do
    {
      if (xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(a1 + 304) + 8 * v11), (const xmlChar *)"body"))
      {
        htmlParseErr((_DWORD *)a1, 800, "htmlParseStartTag: misplaced <body> tag\n", v7, 0);
        ++*(_DWORD *)(a1 + 392);
        v9 = 1;
      }
      ++v11;
    }
    while (v11 < *(int *)(a1 + 296));
  }
  str1 = v7;
  htmlSkipBlankChars(a1);
  LODWORD(v12) = 0;
  while (1)
  {
    v13 = *(xmlParserInput **)(a1 + 56);
    cur = v13->cur;
    v15 = *cur;
    if (v15 == 47)
    {
      v15 = cur[1];
    }
    else if (!*cur)
    {
      break;
    }
    if (v15 == 62)
      break;
    if (!*(_DWORD *)(a1 + 452) && v13->end - cur <= 249)
      xmlParserInputGrow(v13, 250);
    v16 = htmlParseHTMLName((xmlParserCtxtPtr)a1);
    if (!v16)
    {
      htmlParseErr((_DWORD *)a1, 68, "error parsing attribute name\n", 0, 0);
      while (1)
      {
        v23 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
        v24 = *v23;
        if ((v24 | 0x20) == 0x20 || (v24 - 9) < 2)
          goto LABEL_77;
        switch(v24)
        {
          case 47:
            v24 = v23[1];
            break;
          case 13:
            goto LABEL_77;
          case 62:
            goto LABEL_77;
        }
        xmlNextChar((xmlParserCtxtPtr)a1);
      }
    }
    v17 = v16;
    htmlSkipBlankChars(a1);
    if (**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32) != 61)
    {
      v19 = 0;
      goto LABEL_61;
    }
    xmlNextChar((xmlParserCtxtPtr)a1);
    htmlSkipBlankChars(a1);
    v18 = **(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
    if (v18 == 39)
    {
      xmlNextChar((xmlParserCtxtPtr)a1);
      v19 = htmlParseHTMLAttribute(a1, 39);
      if (**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32) == 39)
      {
LABEL_56:
        xmlNextChar((xmlParserCtxtPtr)a1);
        goto LABEL_61;
      }
      v20 = (_DWORD *)a1;
      v21 = 40;
      v22 = "AttValue: ' expected\n";
    }
    else if (v18 == 34)
    {
      xmlNextChar((xmlParserCtxtPtr)a1);
      v19 = htmlParseHTMLAttribute(a1, 34);
      if (**(_BYTE **)(*(_QWORD *)(a1 + 56) + 32) == 34)
        goto LABEL_56;
      v20 = (_DWORD *)a1;
      v21 = 40;
      v22 = "AttValue: \" expected\n";
    }
    else
    {
      v19 = htmlParseHTMLAttribute(a1, 0);
      if (v19)
        goto LABEL_61;
      v20 = (_DWORD *)a1;
      v21 = 41;
      v22 = "AttValue: no value found\n";
    }
    htmlParseErr(v20, v21, v22, 0, 0);
LABEL_61:
    if ((int)v12 < 1)
    {
      if (v3)
      {
LABEL_67:
        if ((int)v12 + 4 <= v4)
          goto LABEL_76;
        v4 *= 2;
        v26 = (const xmlChar **)xmlRealloc(v3, 8 * v4);
        if (v26)
          goto LABEL_75;
        htmlErrMemory((_DWORD *)a1, 0);
        if (v19)
          goto LABEL_72;
      }
      else
      {
        v26 = (const xmlChar **)xmlMalloc(0xB0uLL);
        if (v26)
        {
          v4 = 22;
LABEL_75:
          *(_QWORD *)(a1 + 464) = v26;
          *(_DWORD *)(a1 + 472) = v4;
          v3 = v26;
LABEL_76:
          v27 = &v3[(int)v12];
          *v27 = v17;
          v27[1] = v19;
          v12 = (int)v12 + 2;
          v3[v12] = 0;
          v27[3] = 0;
          goto LABEL_77;
        }
        htmlErrMemory((_DWORD *)a1, 0);
        if (v19)
          xmlFree(v19);
        v3 = 0;
        v4 = 22;
      }
    }
    else
    {
      v25 = 0;
      while (!xmlStrEqual(v3[v25], v17))
      {
        v25 += 2;
        if ((int)v12 <= (int)v25)
          goto LABEL_67;
      }
      htmlParseErr((_DWORD *)a1, 42, "Attribute %s redefined\n", v17, 0);
      if (v19)
LABEL_72:
        xmlFree(v19);
    }
LABEL_77:
    htmlSkipBlankChars(a1);
  }
  if (v38)
  {
    if ((_DWORD)v12)
    {
      if (v3)
      {
        v28 = *v3;
        if (*v3)
        {
          v29 = 0;
          v39 = 0;
          v30 = v3 + 2;
          do
          {
            v31 = (xmlChar *)*(v30 - 1);
            if (v31)
            {
              if (xmlStrcasecmp(v28, (const xmlChar *)"http-equiv")
                || xmlStrcasecmp(v31, (const xmlChar *)"Content-Type"))
              {
                if (xmlStrcasecmp(v28, (const xmlChar *)"charset"))
                {
                  if (!xmlStrcasecmp(v28, (const xmlChar *)"content"))
                    v29 = v31;
                }
                else
                {
                  htmlCheckEncodingDirect(a1, v31);
                }
              }
              else
              {
                v39 = 1;
              }
            }
            v32 = *v30;
            v30 += 2;
            v28 = v32;
          }
          while (v32);
          if (v39 && v29)
            htmlCheckEncoding(a1, v29);
        }
      }
    }
  }
  if (!(_DWORD)v9
    && (htmlnamePush(a1, str1), *(_QWORD *)a1)
    && (v35 = *(void (**)(uint64_t, xmlChar *, const xmlChar **))(*(_QWORD *)a1 + 112)) != 0)
  {
    v36 = *(_QWORD *)(a1 + 8);
    if ((_DWORD)v12)
    {
      v35(v36, str1, v3);
      goto LABEL_100;
    }
    v35(v36, str1, 0);
    return 0;
  }
  else
  {
LABEL_100:
    if (v3 && (int)v12 >= 2)
    {
      v33 = 1;
      do
      {
        v34 = (xmlChar *)v3[v33];
        if (v34)
          xmlFree(v34);
        v33 += 2;
      }
      while ((int)v12 > (int)v33);
    }
  }
  return v9;
}

uint64_t htmlCheckImplied(uint64_t result, xmlChar *str1)
{
  uint64_t v3;
  void (*v4)(_QWORD, const char *, _QWORD);
  uint64_t (*v5)(uint64_t, const char *, _QWORD);
  uint64_t v6;
  const char *v7;
  uint64_t v8;

  if ((*(_BYTE *)(result + 565) & 0x20) != 0)
    return result;
  if (!htmlOmittedDefaultValue)
    return result;
  v3 = result;
  result = xmlStrEqual(str1, (const xmlChar *)"html");
  if ((_DWORD)result)
    return result;
  if (*(int *)(v3 + 296) <= 0)
  {
    htmlnamePush(v3, (xmlChar *)"html");
    if (*(_QWORD *)v3)
    {
      v4 = *(void (**)(_QWORD, const char *, _QWORD))(*(_QWORD *)v3 + 112);
      if (v4)
        v4(*(_QWORD *)(v3 + 8), "html", 0);
    }
  }
  result = xmlStrEqual(str1, (const xmlChar *)"body");
  if ((_DWORD)result)
    return result;
  result = xmlStrEqual(str1, (const xmlChar *)"head");
  if ((_DWORD)result)
    return result;
  if (*(int *)(v3 + 296) <= 1)
  {
    result = xmlStrEqual(str1, (const xmlChar *)"script");
    if ((_DWORD)result
      || (result = xmlStrEqual(str1, (const xmlChar *)"style"), (_DWORD)result)
      || (result = xmlStrEqual(str1, (const xmlChar *)"meta"), (_DWORD)result)
      || (result = xmlStrEqual(str1, (const xmlChar *)"link"), (_DWORD)result)
      || (result = xmlStrEqual(str1, (const xmlChar *)"title"), (_DWORD)result)
      || (result = xmlStrEqual(str1, (const xmlChar *)"base"), (_DWORD)result))
    {
      if (*(int *)(v3 + 52) > 2)
        return result;
      result = (uint64_t)htmlnamePush(v3, (xmlChar *)"head");
      if (!*(_QWORD *)v3)
        return result;
      v5 = *(uint64_t (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v3 + 112);
      if (!v5)
        return result;
      v6 = *(_QWORD *)(v3 + 8);
      v7 = "head";
      return v5(v6, v7, 0);
    }
  }
  result = xmlStrEqual(str1, (const xmlChar *)"noframes");
  if ((_DWORD)result)
    return result;
  result = xmlStrEqual(str1, (const xmlChar *)"frame");
  if ((_DWORD)result)
    return result;
  result = xmlStrEqual(str1, (const xmlChar *)"frameset");
  if ((_DWORD)result || *(int *)(v3 + 52) > 9)
    return result;
  if (*(int *)(v3 + 296) < 1)
  {
LABEL_32:
    result = (uint64_t)htmlnamePush(v3, (xmlChar *)"body");
    if (!*(_QWORD *)v3)
      return result;
    v5 = *(uint64_t (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v3 + 112);
    if (!v5)
      return result;
    v6 = *(_QWORD *)(v3 + 8);
    v7 = "body";
    return v5(v6, v7, 0);
  }
  v8 = 0;
  while (1)
  {
    result = xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v3 + 304) + 8 * v8), (const xmlChar *)"body");
    if ((_DWORD)result)
      return result;
    result = xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v3 + 304) + 8 * v8), (const xmlChar *)"head");
    if ((_DWORD)result)
      return result;
    if (++v8 >= *(int *)(v3 + 296))
      goto LABEL_32;
  }
}

int htmlParseDocument(htmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  setDocumentLocatorSAXFunc setDocumentLocator;
  void *userData;
  xmlSAXLocator *v5;
  const xmlChar *cur;
  char v7;
  int v8;
  xmlCharEncoding v9;
  int errNo;
  startDocumentSAXFunc startDocument;
  const xmlChar *v12;
  int v13;
  int v14;
  const xmlChar *v15;
  endDocumentSAXFunc endDocument;
  const xmlDoc *myDoc;
  unsigned __int8 in[4];
  char __str[8];
  _BYTE v21[16];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  xmlInitParser();
  htmlDefaultSAXHandlerInit();
  if (ctxt && (input = ctxt->input) != 0)
  {
    ctxt->html = 1;
    ctxt->linenumbers = 1;
    if (!ctxt->progressive && input->end - input->cur <= 249)
      xmlParserInputGrow(input, 250);
    if (ctxt->sax)
    {
      setDocumentLocator = ctxt->sax->setDocumentLocator;
      if (setDocumentLocator)
      {
        userData = ctxt->userData;
        v5 = __xmlDefaultSAXLocator();
        ((void (*)(void *, xmlSAXLocator *))setDocumentLocator)(userData, v5);
      }
    }
    *(_DWORD *)in = 0;
    if (!ctxt->encoding)
    {
      cur = ctxt->input->cur;
      if (ctxt->input->end - cur >= 4)
      {
        v7 = ctxt->token ? -1 : *cur;
        in[0] = v7;
        in[1] = cur[1];
        in[2] = cur[2];
        in[3] = cur[3];
        v9 = xmlDetectCharEncoding(in, 4);
        if (v9)
        {
          if (xmlSwitchEncoding(ctxt, v9) < 0)
          {
            *(_QWORD *)__str = 0;
            memset(v21, 0, 11);
            snprintf(__str, 0x14uLL, "0x%02X 0x%02X 0x%02X 0x%02X", in[0], in[1], in[2], in[3]);
            v21[11] = 0;
            if (ctxt->errNo)
              errNo = ctxt->errNo;
            else
              errNo = 6003;
            htmlParseErr(ctxt, errNo, "htmlCheckEncoding: error switching to encoding, bytes %s\n", (const xmlChar *)__str, 0);
          }
        }
      }
    }
    htmlSkipBlankChars((uint64_t)ctxt);
    if (!*ctxt->input->cur)
      htmlParseErr(ctxt, 4, "Document is empty\n", 0, 0);
    if (ctxt->sax)
    {
      startDocument = ctxt->sax->startDocument;
      if (startDocument)
      {
        if (!ctxt->disableSAX)
          ((void (*)(void *))startDocument)(ctxt->userData);
      }
    }
    while (1)
    {
      v12 = ctxt->input->cur;
      if (*v12 != 60)
        break;
      v13 = v12[1];
      if (v13 != 63)
      {
        if (v13 != 33)
          break;
        if (v12[2] != 45 || v12[3] != 45)
        {
          if (__toupper(v12[2]) == 68
            && __toupper(v12[3]) == 79
            && __toupper(v12[4]) == 67
            && __toupper(v12[5]) == 84
            && __toupper(v12[6]) == 89
            && __toupper(v12[7]) == 80
            && __toupper(v12[8]) == 69)
          {
            htmlParseDocTypeDecl(ctxt);
          }
          break;
        }
      }
      htmlParseComment((uint64_t)ctxt);
      htmlParsePI((uint64_t)ctxt);
      htmlSkipBlankChars((uint64_t)ctxt);
    }
    while (1)
    {
      htmlSkipBlankChars((uint64_t)ctxt);
      v15 = ctxt->input->cur;
      if (*v15 != 60)
        break;
      v14 = v15[1];
      if (v14 != 63 && (v14 != 33 || v15[2] != 45 || v15[3] != 45))
        break;
      htmlParseComment((uint64_t)ctxt);
      htmlParsePI((uint64_t)ctxt);
    }
    htmlParseContentInternal((uint64_t)ctxt);
    if (!*ctxt->input->cur)
      htmlAutoCloseOnEnd((uint64_t)ctxt);
    if (ctxt->sax)
    {
      endDocument = ctxt->sax->endDocument;
      if (endDocument)
        ((void (*)(void *))endDocument)(ctxt->userData);
    }
    if ((ctxt->options & 4) == 0)
    {
      myDoc = ctxt->myDoc;
      if (myDoc)
      {
        if (!xmlGetIntSubset(myDoc))
          ctxt->myDoc->intSubset = xmlCreateIntSubset(ctxt->myDoc, (const xmlChar *)"html", (const xmlChar *)"-//W3C//DTD HTML 4.0 Transitional//EN", (const xmlChar *)"http://www.w3.org/TR/REC-html40/loose.dtd");
      }
    }
    if (ctxt->wellFormed)
      return 0;
    else
      return -1;
  }
  else
  {
    v8 = 1;
    htmlParseErr(ctxt, 1, "htmlParseDocument: context error\n", 0, 0);
  }
  return v8;
}

xmlParserInput *htmlSkipBlankChars(uint64_t a1)
{
  xmlParserInput *result;
  const xmlChar *cur;
  unsigned int v4;

  while (1)
  {
    result = *(xmlParserInput **)(a1 + 56);
    cur = result->cur;
    v4 = *cur;
    if (v4 > 0xC)
      break;
    if (v4 == 9)
      goto LABEL_7;
    if (v4 != 10)
      return result;
    ++result->line;
    result->col = 1;
LABEL_8:
    result->cur = cur + 1;
    if (!cur[1])
      xmlParserInputGrow(result, 250);
  }
  if (v4 == 13 || v4 == 32)
  {
LABEL_7:
    ++result->col;
    goto LABEL_8;
  }
  return result;
}

uint64_t htmlAutoCloseOnEnd(uint64_t result)
{
  int v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t (*v4)(_QWORD, _QWORD);
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *(_DWORD *)(result + 296);
  if (v1 >= 1)
  {
    v2 = result;
    v3 = v1 + 1;
    do
    {
      if (*(_QWORD *)v2)
      {
        v4 = *(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v2 + 120);
        if (v4)
        {
          result = v4(*(_QWORD *)(v2 + 8), *(_QWORD *)(v2 + 288));
          v1 = *(_DWORD *)(v2 + 296);
        }
      }
      v5 = v1 - 1;
      if (v1 >= 1)
      {
        *(_DWORD *)(v2 + 296) = v5;
        v6 = *(_QWORD *)(v2 + 304);
        if (v1 == 1)
          v7 = 0;
        else
          v7 = *(_QWORD *)(v6 + 8 * (v1 - 2));
        *(_QWORD *)(v2 + 288) = v7;
        *(_QWORD *)(v6 + 8 * v5) = 0;
        v1 = v5;
      }
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

const xmlChar *htmlParseHTMLName(xmlParserCtxtPtr ctxt)
{
  int v2;
  unsigned int v3;
  BOOL v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  int v8;
  _OWORD v12[6];
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  memset(v12, 0, sizeof(v12));
  v2 = *ctxt->input->cur;
  if ((v2 & 0xFFFFFFDF) - 65 < 0x1A
    || ((v3 = v2 - 46, v4 = v3 > 0x31, v5 = (1 << v3) & 0x2000000001001, !v4) ? (v6 = v5 == 0) : (v6 = 1), !v6))
  {
    v7 = 0;
    while (1)
    {
      v8 = *ctxt->input->cur;
      if ((v8 - 65) >= 0x1A)
      {
        if ((v8 - 97) >= 0x1A
          && (v8 - 48) >= 0xA
          && ((v8 - 45) > 0x32 || ((1 << (v8 - 45)) & 0x4000000002003) == 0))
        {
          return xmlDictLookup(ctxt->dict, (const xmlChar *)v12, v7);
        }
      }
      else
      {
        LOBYTE(v8) = v8 + 32;
      }
      *((_BYTE *)v12 + v7++) = v8;
      xmlNextChar(ctxt);
      if (v7 == 100)
        return xmlDictLookup(ctxt->dict, (const xmlChar *)v12, v7);
    }
  }
  return 0;
}

int xmlOutputBufferClose(xmlOutputBufferPtr out)
{
  xmlOutputCloseCallback closecallback;
  int v3;
  int written;
  xmlBufPtr conv;
  xmlCharEncodingHandler *encoder;
  xmlBufPtr buffer;

  if (!out)
    return -1;
  if (out->writecallback)
    xmlOutputBufferFlush(out);
  closecallback = out->closecallback;
  if (closecallback)
    v3 = ((uint64_t (*)(void *))closecallback)(out->context);
  else
    v3 = 0;
  written = out->written;
  conv = out->conv;
  if (conv)
  {
    xmlBufFree(conv);
    out->conv = 0;
  }
  encoder = out->encoder;
  if (encoder)
    xmlCharEncCloseFunc(encoder);
  buffer = out->buffer;
  if (buffer)
  {
    xmlBufFree(buffer);
    out->buffer = 0;
  }
  if (out->error)
    v3 = -1;
  xmlFree(out);
  if (v3)
    return v3;
  else
    return written;
}

int xmlOutputBufferFlush(xmlOutputBufferPtr out)
{
  unsigned int v2;
  const xmlBuf **p_conv;
  int v5;
  xmlOutputWriteCallback writecallback;
  void *context;
  xmlChar *v8;
  xmlBuf *conv;
  size_t v10;
  int written;
  int v12;

  if (!out || out->error)
    return -1;
  p_conv = &out->conv;
  if (out->conv && out->encoder)
  {
    do
    {
      v5 = xmlCharEncOutput(out, 0);
      if (v5 < 0)
      {
        __xmlSimpleError(8u, 1544, 0, "encoder error", 0);
        out->error = 1544;
        return -1;
      }
    }
    while (v5);
    if (*p_conv)
    {
      if (out->encoder)
      {
        writecallback = out->writecallback;
        if (writecallback)
        {
          context = out->context;
          v8 = xmlBufContent(*p_conv);
          conv = out->conv;
          goto LABEL_15;
        }
      }
    }
  }
  writecallback = out->writecallback;
  if (writecallback)
  {
    context = out->context;
    p_conv = &out->buffer;
    v8 = xmlBufContent(out->buffer);
    conv = out->buffer;
LABEL_15:
    v10 = xmlBufUse(conv);
    v2 = ((uint64_t (*)(void *, xmlChar *, size_t))writecallback)(context, v8, v10);
    if ((v2 & 0x80000000) != 0)
    {
      __xmlSimpleError(8u, 1545, 0, "flush error", 0);
      out->error = 1545;
      return v2;
    }
    xmlBufShrink(*p_conv, v2);
  }
  else
  {
    v2 = 0;
  }
  written = out->written;
  if (written <= (int)(v2 ^ 0x7FFFFFFF))
    v12 = written + v2;
  else
    v12 = 0x7FFFFFFF;
  out->written = v12;
  return v2;
}

xmlTextReaderPtr xmlReaderForMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  xmlParserInputBuffer *Static;
  xmlParserInputBuffer *v9;
  xmlTextReaderPtr v10;
  xmlTextReader *v11;

  Static = xmlParserInputBufferCreateStatic(buffer, size, XML_CHAR_ENCODING_NONE);
  if (!Static)
    return 0;
  v9 = Static;
  v10 = xmlNewTextReader(Static, URL);
  v11 = v10;
  if (v10)
  {
    *((_DWORD *)v10 + 5) |= 1u;
    xmlTextReaderSetup(v10, 0, URL, encoding, options);
  }
  else
  {
    xmlFreeParserInputBuffer(v9);
  }
  return v11;
}

int xmlTextReaderSetup(xmlTextReaderPtr reader, xmlParserInputBufferPtr input, const char *URL, const char *encoding, int options)
{
  xmlParserInputBufferPtr v5;
  __int16 v6;
  int v10;
  xmlParserInputBuffer *v11;
  int v12;
  BOOL v13;
  _QWORD *Size;
  xmlSAXHandler *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  xmlParserCtxt *v21;
  xmlParserInputBufferPtr v22;
  xmlParserInputPtr v23;
  xmlParserInput *v24;
  xmlChar *v25;
  size_t v26;
  xmlSAXHandler *v27;
  xmlChar *v28;
  xmlParserCtxtPtr v29;
  xmlParserCtxtPtr PushParserCtxt;
  xmlGenericErrorFunc v31;
  void **v32;
  int result;
  xmlDict *v34;
  uint64_t v35;
  xmlDictPtr v36;
  xmlXIncludeCtxt *v37;
  uint64_t v38;
  xmlPattern *v39;
  xmlCharEncodingHandler *CharEncodingHandler;
  uint64_t v41;

  v5 = input;
  if (!reader)
  {
    if (input)
LABEL_24:
      xmlFreeParserInputBuffer(v5);
    return -1;
  }
  v6 = options;
  v10 = options | 0x10000;
  *((_QWORD *)reader + 1) = 0;
  *((_DWORD *)reader + 44) = 0;
  *((_DWORD *)reader + 81) = options | 0x10000;
  *((_DWORD *)reader + 4) = 0;
  if (input)
  {
    v11 = (xmlParserInputBuffer *)*((_QWORD *)reader + 6);
    v12 = *((_DWORD *)reader + 5);
    if (v11)
      v13 = (*((_DWORD *)reader + 5) & 1) == 0;
    else
      v13 = 1;
    if (!v13)
    {
      xmlFreeParserInputBuffer(v11);
      v12 = *((_DWORD *)reader + 5) - 1;
    }
    *((_QWORD *)reader + 6) = v5;
    *((_DWORD *)reader + 5) = v12 | 1;
  }
  Size = (_QWORD *)*((_QWORD *)reader + 19);
  if (!Size && (Size = xmlBufCreateSize(100), (*((_QWORD *)reader + 19) = Size) == 0)
    || (xmlBufSetAllocationScheme((uint64_t)Size, 5u), (v15 = (xmlSAXHandler *)*((_QWORD *)reader + 5)) == 0)
    && (v15 = (xmlSAXHandler *)xmlMalloc(0x100uLL), (*((_QWORD *)reader + 5) = v15) == 0))
  {
LABEL_29:
    v31 = *__xmlGenericError();
    v32 = __xmlGenericErrorContext();
    v31(*v32, "xmlTextReaderSetup : malloc failed\n");
    return -1;
  }
  xmlSAXVersion(v15, 2);
  v16 = *((_QWORD *)reader + 5);
  v17 = *(_OWORD *)(v16 + 112);
  *(_QWORD *)(v16 + 112) = xmlTextReaderStartElement;
  *(_OWORD *)((char *)reader + 56) = v17;
  *(_QWORD *)(v16 + 120) = xmlTextReaderEndElement;
  v18 = 0uLL;
  if (*(_DWORD *)(v16 + 216) == -554844497)
  {
    v18 = *(_OWORD *)(v16 + 232);
    *(_QWORD *)(v16 + 232) = xmlTextReaderStartElementNs;
    *(_QWORD *)(v16 + 240) = xmlTextReaderEndElementNs;
  }
  *(_OWORD *)((char *)reader + 72) = v18;
  v19 = *(_QWORD *)(v16 + 136);
  *(_QWORD *)(v16 + 136) = xmlTextReaderCharacters;
  *(_QWORD *)(v16 + 144) = xmlTextReaderCharacters;
  v20 = *(_QWORD *)(v16 + 200);
  *((_QWORD *)reader + 11) = v19;
  *((_QWORD *)reader + 12) = v20;
  *(_QWORD *)(v16 + 200) = xmlTextReaderCDataBlock;
  *(_DWORD *)reader = 0;
  *((_QWORD *)reader + 14) = 0;
  *((_QWORD *)reader + 15) = 0;
  if (v5)
  {
    if (xmlBufUse(*(const xmlBufPtr *)(*((_QWORD *)reader + 6) + 32)) <= 3)
      xmlParserInputBufferRead(v5, 4);
    v21 = (xmlParserCtxt *)*((_QWORD *)reader + 4);
    if (v21)
    {
      xmlCtxtReset(v21);
      v22 = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);
      if (v22)
      {
        v5 = v22;
        v23 = xmlNewInputStream(*((xmlParserCtxtPtr *)reader + 4));
        if (v23)
        {
          v24 = v23;
          if (URL)
            v25 = xmlCanonicPath((const xmlChar *)URL);
          else
            v25 = 0;
          v24->buf = v5;
          v24->filename = (const char *)v25;
          xmlBufResetInput((uint64_t *)v5->buffer, v24);
          inputPush(*((xmlParserCtxtPtr *)reader + 4), v24);
          *((_DWORD *)reader + 27) = 0;
          if (*((_QWORD *)reader + 4))
            goto LABEL_33;
          goto LABEL_29;
        }
        goto LABEL_24;
      }
      return -1;
    }
    v26 = xmlBufUse(*(const xmlBufPtr *)(*((_QWORD *)reader + 6) + 32));
    v27 = (xmlSAXHandler *)*((_QWORD *)reader + 5);
    if (v26 < 4)
    {
      PushParserCtxt = xmlCreatePushParserCtxt(*((xmlSAXHandlerPtr *)reader + 5), 0, 0, 0, URL);
      *((_QWORD *)reader + 4) = PushParserCtxt;
      *((_QWORD *)reader + 13) = 0;
      if (PushParserCtxt)
        goto LABEL_33;
    }
    else
    {
      v28 = xmlBufContent(*(const xmlBuf **)(*((_QWORD *)reader + 6) + 32));
      v29 = xmlCreatePushParserCtxt(v27, 0, (const char *)v28, 4, URL);
      *((_QWORD *)reader + 4) = v29;
      *((_QWORD *)reader + 13) = 0x400000000;
      if (v29)
        goto LABEL_33;
    }
    goto LABEL_29;
  }
LABEL_33:
  v34 = (xmlDict *)*((_QWORD *)reader + 20);
  v35 = *((_QWORD *)reader + 4);
  v36 = *(xmlDictPtr *)(v35 + 456);
  if (v34)
  {
    if (v36)
    {
      if (v34 != v36)
      {
        xmlDictFree(*((xmlDictPtr *)reader + 20));
        v35 = *((_QWORD *)reader + 4);
        *((_QWORD *)reader + 20) = *(_QWORD *)(v35 + 456);
      }
    }
    else
    {
      *(_QWORD *)(v35 + 456) = v34;
    }
  }
  else
  {
    if (!v36)
    {
      v36 = xmlDictCreate();
      v35 = *((_QWORD *)reader + 4);
      *(_QWORD *)(v35 + 456) = v36;
    }
    *((_QWORD *)reader + 20) = v36;
  }
  *(_QWORD *)(v35 + 424) = reader;
  *(_DWORD *)(v35 + 436) = 1;
  *(_DWORD *)(v35 + 568) = 1;
  *(_DWORD *)(v35 + 476) = 1;
  *(_DWORD *)(v35 + 688) = 5;
  v37 = (xmlXIncludeCtxt *)*((_QWORD *)reader + 36);
  if (v37)
  {
    xmlXIncludeFreeContext(v37);
    *((_QWORD *)reader + 36) = 0;
  }
  if ((v6 & 0x400) != 0)
  {
    *((_DWORD *)reader + 68) = 1;
    *((_QWORD *)reader + 35) = xmlDictLookup(*((xmlDictPtr *)reader + 20), (const xmlChar *)"include", -1);
    v10 -= 1024;
  }
  else
  {
    *((_DWORD *)reader + 68) = 0;
  }
  *((_DWORD *)reader + 74) = 0;
  if (*((_QWORD *)reader + 39))
  {
    LODWORD(v38) = *((_DWORD *)reader + 75);
    if ((int)v38 >= 1)
    {
      do
      {
        LODWORD(v38) = v38 - 1;
        *((_DWORD *)reader + 75) = v38;
        v39 = *(xmlPattern **)(*((_QWORD *)reader + 39) + 8 * v38);
        if (v39)
        {
          xmlFreePattern(v39);
          v38 = *((int *)reader + 75);
          *(_QWORD *)(*((_QWORD *)reader + 39) + 8 * v38) = 0;
        }
      }
      while ((int)v38 > 0);
    }
    if ((v10 & 0x10) == 0)
      goto LABEL_53;
    goto LABEL_52;
  }
  *(_QWORD *)((char *)reader + 300) = 0;
  if ((v10 & 0x10) != 0)
LABEL_52:
    *((_DWORD *)reader + 4) = 1;
LABEL_53:
  xmlCtxtUseOptions(*((xmlParserCtxtPtr *)reader + 4), v10);
  if (encoding)
  {
    CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
    if (CharEncodingHandler)
      xmlSwitchToEncoding(*((xmlParserCtxtPtr *)reader + 4), CharEncodingHandler);
  }
  if (URL)
  {
    v41 = *(_QWORD *)(*((_QWORD *)reader + 4) + 56);
    if (v41)
    {
      if (!*(_QWORD *)(v41 + 8))
        *(_QWORD *)(*(_QWORD *)(*((_QWORD *)reader + 4) + 56) + 8) = xmlStrdup((const xmlChar *)URL);
    }
  }
  result = 0;
  *((_QWORD *)reader + 1) = 0;
  return result;
}

int xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)
{
  return xmlCtxtUseOptionsInternal((uint64_t *)ctxt, *(uint64_t *)&options, 0);
}

xmlParserInputBufferPtr xmlParserInputBufferCreateStatic(const char *mem, int size, xmlCharEncoding enc)
{
  xmlParserInputBuffer *v3;
  xmlParserInputBuffer *v7;
  xmlBuf *Static;
  xmlCharEncodingHandlerPtr CharEncodingHandler;
  int *v10;

  v3 = 0;
  if (mem && (size & 0x80000000) == 0)
  {
    v7 = (xmlParserInputBuffer *)xmlMalloc(0x40uLL);
    v3 = v7;
    if (v7)
    {
      *(_OWORD *)&v7->buffer = 0u;
      *(_OWORD *)&v7->compressed = 0u;
      *(_OWORD *)&v7->context = 0u;
      *(_OWORD *)&v7->closecallback = 0u;
      Static = (xmlBuf *)xmlBufCreateStatic(mem, size);
      v3->buffer = Static;
      if (Static)
      {
        CharEncodingHandler = xmlGetCharEncodingHandler(enc);
        v3->encoder = CharEncodingHandler;
        if (CharEncodingHandler)
        {
          v10 = __xmlDefaultBufferSize();
          CharEncodingHandler = (xmlCharEncodingHandlerPtr)xmlBufCreateSize(2 * *v10);
        }
        v3->raw = (xmlBufPtr)CharEncodingHandler;
        v3->compressed = -1;
        v3->readcallback = 0;
        v3->closecallback = 0;
        v3->context = (void *)mem;
      }
      else
      {
        xmlFree(v3);
        return 0;
      }
    }
    else
    {
      __xmlSimpleError(8u, 2, 0, 0, (const xmlChar *)"creating input buffer");
    }
  }
  return v3;
}

xmlTextReaderPtr xmlNewTextReader(xmlParserInputBufferPtr input, const char *URI)
{
  _DWORD *v4;
  _DWORD *v5;
  _QWORD *Size;
  xmlSAXHandler *v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  xmlSAXHandler *v14;
  xmlChar *v15;
  int v16;
  xmlParserCtxtPtr PushParserCtxt;
  xmlGenericErrorFunc v18;
  void **v19;
  xmlGenericErrorFunc v21;
  void **v22;

  if (!input)
    return 0;
  v4 = xmlMalloc(0x150uLL);
  if (!v4)
    goto LABEL_13;
  v5 = v4;
  *((_OWORD *)v4 + 19) = 0u;
  *((_OWORD *)v4 + 20) = 0u;
  *((_OWORD *)v4 + 17) = 0u;
  *((_OWORD *)v4 + 18) = 0u;
  *((_OWORD *)v4 + 15) = 0u;
  *((_OWORD *)v4 + 16) = 0u;
  *((_OWORD *)v4 + 13) = 0u;
  *((_OWORD *)v4 + 14) = 0u;
  *((_OWORD *)v4 + 11) = 0u;
  *((_OWORD *)v4 + 12) = 0u;
  *((_OWORD *)v4 + 9) = 0u;
  *((_OWORD *)v4 + 10) = 0u;
  *((_OWORD *)v4 + 7) = 0u;
  *((_OWORD *)v4 + 8) = 0u;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *(_OWORD *)v4 = 0u;
  *((_QWORD *)v4 + 1) = 0;
  *((_QWORD *)v4 + 22) = 0;
  *((_QWORD *)v4 + 23) = 0;
  *((_QWORD *)v4 + 6) = input;
  Size = xmlBufCreateSize(100);
  *((_QWORD *)v5 + 19) = Size;
  if (!Size)
  {
LABEL_12:
    xmlFree(v5);
LABEL_13:
    v18 = *__xmlGenericError();
    v19 = __xmlGenericErrorContext();
    v18(*v19, "xmlNewTextReader : malloc failed\n");
    return 0;
  }
  xmlBufSetAllocationScheme((uint64_t)Size, 5u);
  v7 = (xmlSAXHandler *)xmlMalloc(0x100uLL);
  *((_QWORD *)v5 + 5) = v7;
  if (!v7)
  {
    xmlBufFree(*((_DWORD **)v5 + 19));
    goto LABEL_12;
  }
  xmlSAXVersion(v7, 2);
  v8 = *((_QWORD *)v5 + 5);
  v9 = *(_OWORD *)(v8 + 112);
  *(_QWORD *)(v8 + 112) = xmlTextReaderStartElement;
  *(_OWORD *)(v5 + 14) = v9;
  *(_QWORD *)(v8 + 120) = xmlTextReaderEndElement;
  v10 = 0uLL;
  if (*(_DWORD *)(v8 + 216) == -554844497)
  {
    v10 = *(_OWORD *)(v8 + 232);
    *(_QWORD *)(v8 + 232) = xmlTextReaderStartElementNs;
    *(_QWORD *)(v8 + 240) = xmlTextReaderEndElementNs;
  }
  *(_OWORD *)(v5 + 18) = v10;
  v11 = *(_QWORD *)(v8 + 136);
  *(_QWORD *)(v8 + 136) = xmlTextReaderCharacters;
  *(_QWORD *)(v8 + 144) = xmlTextReaderCharacters;
  v12 = *(_QWORD *)(v8 + 200);
  *((_QWORD *)v5 + 11) = v11;
  *((_QWORD *)v5 + 12) = v12;
  *(_QWORD *)(v8 + 200) = xmlTextReaderCDataBlock;
  *v5 = 0;
  *((_QWORD *)v5 + 14) = 0;
  *((_QWORD *)v5 + 15) = 0;
  if (xmlBufUse(*(const xmlBufPtr *)(*((_QWORD *)v5 + 6) + 32)) <= 3)
    xmlParserInputBufferRead(input, 4);
  v13 = xmlBufUse(*(const xmlBufPtr *)(*((_QWORD *)v5 + 6) + 32));
  v14 = (xmlSAXHandler *)*((_QWORD *)v5 + 5);
  if (v13 < 4)
  {
    PushParserCtxt = xmlCreatePushParserCtxt(*((xmlSAXHandlerPtr *)v5 + 5), 0, 0, 0, URI);
    v16 = 0;
  }
  else
  {
    v15 = xmlBufContent(*(const xmlBuf **)(*((_QWORD *)v5 + 6) + 32));
    v16 = 4;
    PushParserCtxt = xmlCreatePushParserCtxt(v14, 0, (const char *)v15, 4, URI);
  }
  *((_QWORD *)v5 + 4) = PushParserCtxt;
  v5[26] = 0;
  v5[27] = v16;
  if (PushParserCtxt)
  {
    PushParserCtxt->parseMode = XML_PARSE_READER;
    PushParserCtxt->_private = v5;
    PushParserCtxt->linenumbers = 1;
    PushParserCtxt->dictNames = 1;
    v5[5] = 2;
    PushParserCtxt->docdict = 1;
    *((_QWORD *)v5 + 20) = PushParserCtxt->dict;
    v5[68] = 0;
    v5[76] = 0;
    *((_QWORD *)v5 + 39) = 0;
    return (xmlTextReaderPtr)v5;
  }
  v21 = *__xmlGenericError();
  v22 = __xmlGenericErrorContext();
  v21(*v22, "xmlNewTextReader : malloc failed\n");
  xmlBufFree(*((_DWORD **)v5 + 19));
  xmlFree(*((void **)v5 + 5));
  xmlFree(v5);
  return 0;
}

xmlParserCtxtPtr xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax, void *user_data, const char *chunk, int size, const char *filename)
{
  xmlCharEncoding v10;
  xmlParserInputBufferPtr v11;
  xmlParserInputBufferPtr v12;
  xmlParserCtxtPtr v13;
  xmlParserCtxt *v14;
  xmlSAXHandlerV1 *v15;
  _xmlSAXHandler *v16;
  size_t v17;
  xmlParserInputPtr v18;
  xmlParserInput *v19;
  xmlChar *v20;
  xmlParserInputPtr v21;
  uint64_t input;
  unint64_t InputBase;
  xmlParserInputPtr v24;
  uint64_t v25;

  v10 = XML_CHAR_ENCODING_NONE;
  if (chunk && size >= 4)
    v10 = xmlDetectCharEncoding((const unsigned __int8 *)chunk, size);
  v11 = xmlAllocParserInputBuffer(v10);
  if (!v11)
    return 0;
  v12 = v11;
  v13 = xmlNewParserCtxt();
  v14 = v13;
  if (v13)
  {
    v13->dictNames = 1;
    if (sax)
    {
      v15 = (xmlSAXHandlerV1 *)v13->sax;
      if (v15 != __xmlDefaultSAXHandler())
        xmlFree(v14->sax);
      v16 = (_xmlSAXHandler *)xmlMalloc(0x100uLL);
      v14->sax = v16;
      if (!v16)
      {
        htmlErrMemory(v14, 0);
        xmlFreeParserInputBuffer(v12);
        xmlFreeParserCtxt(v14);
        return 0;
      }
      *(_OWORD *)&v16->_private = 0u;
      *(_OWORD *)&v16->endElementNs = 0u;
      *(_OWORD *)&v16->getParameterEntity = 0u;
      *(_OWORD *)&v16->externalSubset = 0u;
      *(_OWORD *)&v16->comment = 0u;
      *(_OWORD *)&v16->error = 0u;
      *(_OWORD *)&v16->reference = 0u;
      *(_OWORD *)&v16->ignorableWhitespace = 0u;
      *(_OWORD *)&v16->startDocument = 0u;
      *(_OWORD *)&v16->startElement = 0u;
      *(_OWORD *)&v16->attributeDecl = 0u;
      *(_OWORD *)&v16->unparsedEntityDecl = 0u;
      *(_OWORD *)&v16->resolveEntity = 0u;
      *(_OWORD *)&v16->entityDecl = 0u;
      *(_OWORD *)&v16->internalSubset = 0u;
      *(_OWORD *)&v16->hasInternalSubset = 0u;
      if (sax->initialized == -554844497)
        v17 = 256;
      else
        v17 = 224;
      memcpy(v14->sax, sax, v17);
      if (user_data)
        v14->userData = user_data;
    }
    if (filename)
    {
      v14->directory = xmlParserGetDirectory(filename);
      v18 = xmlNewInputStream(v14);
      if (!v18)
        goto LABEL_27;
      v19 = v18;
      v20 = xmlCanonicPath((const xmlChar *)filename);
      v19->filename = (const char *)v20;
      if (!v20)
        goto LABEL_27;
    }
    else
    {
      v14->directory = 0;
      v21 = xmlNewInputStream(v14);
      if (!v21)
      {
LABEL_27:
        xmlFreeParserCtxt(v14);
        xmlFreeParserInputBuffer(v12);
        return 0;
      }
      v19 = v21;
      v21->filename = 0;
    }
    v19->buf = v12;
    xmlBufResetInput((uint64_t *)v12->buffer, v19);
    inputPush(v14, v19);
    if (chunk && size)
    {
      input = (uint64_t)v14->input;
      if (input && *(_QWORD *)input)
      {
        InputBase = xmlBufGetInputBase(*(_QWORD *)(*(_QWORD *)input + 32), input);
        v24 = v14->input;
        v25 = v24->cur - v24->base;
        xmlParserInputBufferPush(v24->buf, size, chunk);
        xmlBufSetInputBaseCur((uint64_t *)v14->input->buf->buffer, &v14->input->buf, InputBase, v25);
      }
    }
    else
    {
      v14->charset = 0;
    }
    if (v10)
      xmlSwitchEncoding(v14, v10);
  }
  else
  {
    htmlErrMemory(0, (const xmlChar *)"creating parser: out of memory\n");
    xmlFreeParserInputBuffer(v12);
  }
  return v14;
}

_QWORD *xmlBufCreateStatic(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  int v4;

  if (result)
  {
    v3 = result;
    result = xmlMalloc(0x40uLL);
    if (result)
    {
      result[4] = a2;
      result[5] = a2;
      v4 = 0x7FFFFFFF;
      if (a2 < 0x7FFFFFFF)
        v4 = a2;
      *((_DWORD *)result + 2) = v4;
      *((_DWORD *)result + 3) = v4;
      *((_DWORD *)result + 4) = 2;
      *result = v3;
      *((_DWORD *)result + 14) = 0;
      result[6] = 0;
    }
    else
    {
      __xmlSimpleError(0x1Du, 2, 0, 0, (const xmlChar *)"creating buffer");
      return 0;
    }
  }
  return result;
}

const xmlChar *__cdecl xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name)
{
  void *v3;
  size_t v7;
  size_t v8;
  size_t v9;
  unint64_t v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v14;
  size_t v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  BOOL v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _BYTE *v35;
  _BYTE *v36;
  _QWORD *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  unsigned int v42;
  unsigned int v43;

  v3 = 0;
  if (dict && name)
  {
    if (!prefix)
      return xmlDictLookup(dict, name, -1);
    v7 = strlen((const char *)name);
    v8 = strlen((const char *)prefix);
    v3 = 0;
    if (!(v7 >> 30) && !(v8 >> 30))
    {
      v9 = v8 + v7;
      v10 = *((_QWORD *)dict + 2);
      v11 = *((_DWORD *)dict + 12);
      v42 = v8;
      if (v10 == 128)
        v12 = xmlDictComputeFastQKey((unsigned __int8 *)prefix, v8, (unsigned __int8 *)name, v7, v11);
      else
        v12 = xmlDictComputeBigQKey((unsigned __int8 *)prefix, v8, (unsigned __int8 *)name, v7, v11);
      v14 = v12;
      v41 = v9;
      v15 = v9 + 1;
      v16 = v12 % v10;
      v17 = *((_QWORD *)dict + 1) + 32 * v16;
      v43 = v7;
      if (*(_DWORD *)(v17 + 20))
      {
        v18 = *(_QWORD **)v17;
        if (*(_QWORD *)v17)
        {
          v19 = 0;
          do
          {
            if (*(_QWORD *)(v17 + 24) == v14 && v15 == *(_DWORD *)(v17 + 16))
            {
              if (xmlStrQEqual(prefix, name, *(const xmlChar **)(v17 + 8)))
                return *(const xmlChar **)(v17 + 8);
              v18 = *(_QWORD **)v17;
            }
            v17 = (uint64_t)v18;
            ++v19;
            v18 = (_QWORD *)*v18;
          }
          while (v18);
        }
        else
        {
          v19 = 0;
        }
        if (*(_QWORD *)(v17 + 24) == v14
          && v15 == *(_DWORD *)(v17 + 16)
          && xmlStrQEqual(prefix, name, *(const xmlChar **)(v17 + 8)))
        {
          return *(const xmlChar **)(v17 + 8);
        }
      }
      else
      {
        v19 = 0;
        v17 = 0;
      }
      v20 = *((_QWORD *)dict + 5);
      if (!v20)
      {
LABEL_45:
        v26 = (_QWORD *)*((_QWORD *)dict + 4);
        if (v26)
        {
          v27 = 0;
          v28 = 0;
          do
          {
            v3 = (void *)v26[1];
            if (v26[2] - (_QWORD)v3 > (unint64_t)v15)
            {
              v40 = v16;
              goto LABEL_64;
            }
            v29 = v26[3];
            if (v29 > v28)
              v28 = v26[3];
            v27 += v29;
            v26 = (_QWORD *)*v26;
          }
          while (v26);
          v30 = *((_QWORD *)dict + 7);
          if (v30)
            v31 = v27 > v30;
          else
            v31 = 0;
          if (v31)
            return 0;
          if (!v28)
            goto LABEL_57;
          v40 = v16;
          v32 = 4 * v28;
        }
        else
        {
LABEL_57:
          v40 = v16;
          v32 = 1000;
        }
        if (v32 <= (4 * v41 + 4))
          v33 = (4 * v41 + 4);
        else
          v33 = v32;
        v34 = xmlMalloc(v33 + 48);
        if (v34)
        {
          v26 = v34;
          v34[3] = v33;
          v34[4] = 0;
          v3 = v34 + 5;
          v34[2] = (char *)v34 + v33 + 40;
          *v34 = *((_QWORD *)dict + 4);
          v34[1] = v34 + 5;
          *((_QWORD *)dict + 4) = v34;
LABEL_64:
          memcpy(v3, prefix, v42);
          v35 = (_BYTE *)(v26[1] + v42);
          v26[1] = v35 + 1;
          *v35 = 58;
          memcpy((void *)v26[1], name, v43);
          v36 = (_BYTE *)(v26[1] + v43);
          v26[1] = v36 + 1;
          *v36 = 0;
          ++v26[4];
          if (!v3)
            return (const xmlChar *)v3;
          if (!v17)
          {
            v38 = *((_QWORD *)dict + 1) + 32 * v40;
            *(_QWORD *)v38 = 0;
            *(_QWORD *)(v38 + 8) = v3;
            *(_DWORD *)(v38 + 16) = v15;
            *(_DWORD *)(v38 + 20) = 1;
            *(_QWORD *)(v38 + 24) = v14;
LABEL_70:
            ++*((_DWORD *)dict + 6);
            if (v19 >= 4)
            {
              v39 = *((_QWORD *)dict + 2);
              if (v39 <= 0xAAA)
                xmlDictGrow((uint64_t)dict, 6 * v39);
            }
            return (const xmlChar *)v3;
          }
          v37 = xmlMalloc(0x20uLL);
          if (v37)
          {
            *v37 = 0;
            v37[1] = v3;
            *((_DWORD *)v37 + 4) = v15;
            *((_DWORD *)v37 + 5) = 1;
            v37[3] = v14;
            *(_QWORD *)v17 = v37;
            goto LABEL_70;
          }
        }
        return 0;
      }
      v21 = *(_QWORD *)(v20 + 16);
      if (*((_QWORD *)dict + 2) == 128)
      {
        if (v21 == 128)
        {
          v22 = v14;
          goto LABEL_33;
        }
        v23 = xmlDictComputeBigQKey((unsigned __int8 *)prefix, v42, (unsigned __int8 *)name, v43, *(_DWORD *)(v20 + 48));
      }
      else
      {
        v22 = v14;
        if (v21 != 128)
          goto LABEL_33;
        v23 = xmlDictComputeFastQKey((unsigned __int8 *)prefix, v42, (unsigned __int8 *)name, v43, *(_DWORD *)(v20 + 48));
      }
      v22 = v23;
LABEL_33:
      v24 = *(_QWORD *)(v20 + 8) + 32 * (v22 % v21);
      if (*(_DWORD *)(v24 + 20))
      {
        v25 = *(_QWORD **)v24;
        if (*(_QWORD *)v24)
        {
          do
          {
            if (*(_QWORD *)(v24 + 24) == v22 && v15 == *(_DWORD *)(v24 + 16))
            {
              if (xmlStrQEqual(prefix, name, *(const xmlChar **)(v24 + 8)))
                return *(const xmlChar **)(v24 + 8);
              v25 = *(_QWORD **)v24;
            }
            v24 = (uint64_t)v25;
            ++v19;
            v25 = (_QWORD *)*v25;
          }
          while (v25);
        }
        if (*(_QWORD *)(v24 + 24) == v22
          && v15 == *(_DWORD *)(v24 + 16)
          && xmlStrQEqual(prefix, name, *(const xmlChar **)(v24 + 8)))
        {
          return *(const xmlChar **)(v24 + 8);
        }
      }
      v16 = v14 % *((_QWORD *)dict + 2);
      goto LABEL_45;
    }
  }
  return (const xmlChar *)v3;
}

uint64_t xmlDictComputeFastQKey(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4, int a5)
{
  uint64_t v5;
  unsigned int v6;
  uint64_t result;

  if (a2)
    v5 = a5 + 30 * *a1;
  else
    v5 = a5 + 1740;
  v6 = a4 - 11;
  if (a4 >= 11)
  {
    if (a4 - a2 - 2 >= 0)
      v6 = a4 - a2 - 2;
    v5 += a3[v6];
    a4 = 10;
    if (a2 >= 10)
      a2 = 10;
  }
  switch(a2)
  {
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_18;
    case 3:
      goto LABEL_17;
    case 4:
      goto LABEL_16;
    case 5:
      goto LABEL_15;
    case 6:
      goto LABEL_14;
    case 7:
      goto LABEL_13;
    case 8:
      goto LABEL_12;
    case 9:
      goto LABEL_11;
    case 10:
      v5 += a1[9];
LABEL_11:
      v5 += a1[8];
LABEL_12:
      v5 += a1[7];
LABEL_13:
      v5 += a1[6];
LABEL_14:
      v5 += a1[5];
LABEL_15:
      v5 += a1[4];
LABEL_16:
      v5 += a1[3];
LABEL_17:
      v5 += a1[2];
LABEL_18:
      v5 += a1[1];
LABEL_19:
      v5 += *a1;
      break;
    default:
      break;
  }
  if (a4 <= a2)
    result = v5;
  else
    result = v5 + 58;
  switch(~(a4 > a2) + a4 - a2)
  {
    case 0:
      goto LABEL_32;
    case 1:
      goto LABEL_31;
    case 2:
      goto LABEL_30;
    case 3:
      goto LABEL_29;
    case 4:
      goto LABEL_28;
    case 5:
      goto LABEL_27;
    case 6:
      goto LABEL_26;
    case 7:
      goto LABEL_25;
    case 8:
      result += a3[8];
LABEL_25:
      result += a3[7];
LABEL_26:
      result += a3[6];
LABEL_27:
      result += a3[5];
LABEL_28:
      result += a3[4];
LABEL_29:
      result += a3[3];
LABEL_30:
      result += a3[2];
LABEL_31:
      result += a3[1];
LABEL_32:
      result += *a3;
      break;
    default:
      return result;
  }
  return result;
}

xmlErrorPtr xmlCtxtGetLastError(xmlErrorPtr ctx)
{
  if (ctx)
  {
    if (HIDWORD(ctx[6].ctxt))
      return (xmlErrorPtr)((char *)ctx + 600);
    else
      return 0;
  }
  return ctx;
}

uint64_t __htmlParserNeedsNoBlankQuirk_block_invoke()
{
  uint64_t result;
  BOOL v1;

  result = (uint64_t)_dyld_get_image_name(0);
  if (result
    && (result = (uint64_t)strrchr((char *)result, 47)) != 0
    && (result = strcmp((const char *)(result + 1), "TaxCut.real"), !(_DWORD)result))
  {
    result = dyld_get_program_sdk_version();
    v1 = result >> 8 < 0xA09;
  }
  else
  {
    v1 = 0;
  }
  htmlParserNeedsNoBlankQuirk_needsQuirk = v1;
  return result;
}

_DWORD *xmlBufMemoryError(uint64_t a1, const xmlChar *a2)
{
  _DWORD *result;

  result = __xmlSimpleError(0x1Du, 2, 0, 0, a2);
  if (a1)
  {
    if (!*(_DWORD *)(a1 + 56))
      *(_DWORD *)(a1 + 56) = 2;
  }
  return result;
}

uint64_t xmlBufLength(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v5;

  if (!a1 || *(_DWORD *)(a1 + 56))
    return 0;
  v3 = *(unsigned int *)(a1 + 12);
  if (v3 <= 0x7FFFFFFE && *(_QWORD *)(a1 + 40) != v3)
    *(_QWORD *)(a1 + 40) = v3;
  v1 = *(_QWORD *)(a1 + 32);
  v5 = *(unsigned int *)(a1 + 8);
  if (v5 <= 0x7FFFFFFE && v1 != v5)
  {
    *(_QWORD *)(a1 + 32) = v5;
    return v5;
  }
  return v1;
}

uint64_t xmlBufWriteQuotedString(uint64x2_t *a1, xmlChar *str)
{
  const xmlChar *v3;
  uint64_t v4;
  uint64_t v6;
  size_t i;
  const char *v10;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (a1[3].i32[2])
    return 0xFFFFFFFFLL;
  v3 = str;
  v4 = a1->u32[3];
  if (v4 <= 0x7FFFFFFE && a1[2].i64[1] != v4)
    a1[2].i64[1] = v4;
  v6 = a1->u32[2];
  if (v6 <= 0x7FFFFFFE && a1[2].i64[0] != v6)
    a1[2].i64[0] = v6;
  if (a1[1].i32[0] == 2)
    return 0xFFFFFFFFLL;
  if (xmlStrchr(str, 0x22u))
  {
    if (xmlStrchr(v3, 0x27u))
    {
      xmlBufCat(a1, (const xmlChar *)"\"");
LABEL_19:
      for (i = 0; v3[i]; ++i)
      {
        if (v3[i] == 34)
        {
          if (i)
            xmlBufAdd(a1, v3, i);
          xmlBufAdd(a1, (const xmlChar *)"&quot;", 6uLL);
          v3 += i + 1;
          goto LABEL_19;
        }
      }
      if (i)
        xmlBufAdd(a1, v3, i);
      v10 = "\"";
      goto LABEL_32;
    }
    v10 = "'";
  }
  else
  {
    v10 = "\"";
  }
  xmlBufCat(a1, (const xmlChar *)v10);
  xmlBufCat(a1, v3);
LABEL_32:
  xmlBufCat(a1, (const xmlChar *)v10);
  return 0;
}

uint32x2_t *xmlBufFromBuffer(uint32x2_t *result)
{
  uint32x2_t *v1;
  uint32x2_t v2;

  if (result)
  {
    v1 = result;
    result = (uint32x2_t *)xmlMalloc(0x40uLL);
    if (result)
    {
      v2 = v1[1];
      result[1] = vmin_u32(v2, (uint32x2_t)0x8000000080000000);
      result[2].i32[0] = v1[2].i32[0];
      *result = *v1;
      result[7].i32[0] = 0;
      result[5] = (uint32x2_t)v2.u32[1];
      result[6] = (uint32x2_t)v1;
      result[3] = v1[3];
      result[4] = (uint32x2_t)v2.u32[0];
    }
    else
    {
      __xmlSimpleError(0x1Du, 2, 0, 0, (const xmlChar *)"creating buffer");
      return 0;
    }
  }
  return result;
}

uint64_t xmlBufBackToBuffer(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v5;
  unint64_t v6;
  uint64_t v8;
  int v9;

  if (!a1)
    return 0;
  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(unsigned int *)(a1 + 12);
  if (v3 <= 0x7FFFFFFE && v2 != v3)
  {
    *(_QWORD *)(a1 + 40) = v3;
    v2 = v3;
  }
  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(unsigned int *)(a1 + 8);
  if (v6 <= 0x7FFFFFFE && v5 != v6)
  {
    *(_QWORD *)(a1 + 32) = v6;
    v5 = v6;
  }
  v8 = *(_QWORD *)(a1 + 48);
  if (*(_DWORD *)(a1 + 56) || !v8)
  {
    xmlBufFree((_DWORD *)a1);
    if (!v8)
      return v8;
    *(_QWORD *)(v8 + 24) = 0;
    *(_QWORD *)v8 = 0;
    *(_QWORD *)(v8 + 8) = 0;
    return 0;
  }
  if (v5 >> 31)
  {
    __xmlSimpleError(0x1Du, 7000, 0, 0, (const xmlChar *)"Used size too big for xmlBuffer");
    if (!*(_DWORD *)(a1 + 56))
      *(_DWORD *)(a1 + 56) = 7000;
    LODWORD(v2) = 0x7FFFFFFF;
    *(_DWORD *)(v8 + 8) = 0x7FFFFFFF;
  }
  else if (v2 >> 31)
  {
    __xmlSimpleError(0x1Du, 7000, 0, 0, (const xmlChar *)"Allocated size too big for xmlBuffer");
    if (!*(_DWORD *)(a1 + 56))
      *(_DWORD *)(a1 + 56) = 7000;
    *(_DWORD *)(v8 + 8) = *(_QWORD *)(a1 + 32);
    LODWORD(v2) = 0x7FFFFFFF;
  }
  else
  {
    *(_DWORD *)(v8 + 8) = v5;
  }
  v9 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(v8 + 12) = v2;
  *(_DWORD *)(v8 + 16) = v9;
  *(_QWORD *)v8 = *(_QWORD *)a1;
  *(_QWORD *)(v8 + 24) = *(_QWORD *)(a1 + 24);
  xmlFree((void *)a1);
  return v8;
}

uint64_t xmlBufMergeBuffer(uint64x2_t *a1, xmlBufferPtr buf)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v7;
  xmlChar *content;
  size_t use;

  if (a1 && !a1[3].i32[2])
  {
    v5 = a1->u32[3];
    if (v5 <= 0x7FFFFFFE && a1[2].i64[1] != v5)
      a1[2].i64[1] = v5;
    v7 = a1->u32[2];
    if (v7 <= 0x7FFFFFFE && a1[2].i64[0] != v7)
      a1[2].i64[0] = v7;
    if (buf && (content = buf->content) != 0 && (use = buf->use, (_DWORD)use))
      v3 = xmlBufAdd(a1, content, use);
    else
      v3 = 0;
  }
  else
  {
    v3 = 0xFFFFFFFFLL;
  }
  xmlBufferFree(buf);
  return v3;
}

int xmlC14NExecute(xmlDocPtr doc, xmlC14NIsVisibleCallback is_visible_callback, void *user_data, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, xmlOutputBufferPtr buf)
{
  const char *v10;
  _OWORD *v15;
  _OWORD *v16;
  _OWORD *v17;
  _xmlNode *children;
  int v19;
  int v20;
  const char *v22;

  if (!doc || !buf)
  {
    v10 = "executing c14n";
LABEL_8:
    xmlC14NErrParam((const xmlChar *)v10);
    return -1;
  }
  if (mode > 2)
  {
    v10 = "invalid mode for executing c14n";
    goto LABEL_8;
  }
  if (buf->encoder)
  {
    __xmlRaiseError(0, 0, 0, 0, (uint64_t)doc, 0x15u, 1951, 2, 0, 0, 0, 0, 0, 0, 0, "%s", (char)"xmlC14NExecute: output buffer encoder != NULL but C14N requires UTF8 output\n");
    return -1;
  }
  v15 = xmlMalloc(0x50uLL);
  if (!v15)
  {
    xmlC14NErrMemory((const xmlChar *)"creating context");
LABEL_19:
    __xmlRaiseError(0, 0, 0, 0, (uint64_t)doc, 0x15u, 1950, 2, 0, 0, 0, 0, 0, 0, 0, "%s", (char)"xmlC14NExecute: unable to create C14N context\n");
    return -1;
  }
  v16 = v15;
  *v15 = 0u;
  v15[1] = 0u;
  v15[3] = 0u;
  v15[4] = 0u;
  v15[2] = 0u;
  *((_DWORD *)v15 + 6) = with_comments;
  *(_QWORD *)v15 = doc;
  *((_QWORD *)v15 + 1) = is_visible_callback;
  *((_QWORD *)v15 + 2) = user_data;
  *((_QWORD *)v15 + 4) = buf;
  *((_QWORD *)v15 + 5) = 0x100000000;
  v17 = xmlMalloc(0x20uLL);
  if (!v17)
  {
    xmlC14NErrMemory((const xmlChar *)"creating namespaces stack");
    *((_QWORD *)v16 + 6) = 0;
    *((_DWORD *)v16 + 18) = 1952;
    __xmlRaiseError(0, 0, 0, v16, (uint64_t)doc, 0x15u, 1952, 2, 0, 0, 0, 0, 0, 0, 0, "%s", (char)"xmlC14NNewCtx: xmlC14NVisibleNsStackCreate failed\n");
    xmlC14NFreeCtx(v16);
    goto LABEL_19;
  }
  *v17 = 0u;
  v17[1] = 0u;
  *((_QWORD *)v16 + 6) = v17;
  *((_DWORD *)v16 + 14) = mode;
  if (mode == 1)
    *((_QWORD *)v16 + 8) = inclusive_ns_prefixes;
  children = doc->children;
  if (children && (xmlC14NProcessNodeList((xmlDocPtr *)v16, (uint64_t)children, (__n128)0) & 0x80000000) != 0)
  {
    v22 = "processing docs children list";
    goto LABEL_24;
  }
  v19 = xmlOutputBufferFlush(buf);
  if (v19 < 0)
  {
    v22 = "flushing output buffer";
LABEL_24:
    xmlC14NErrInternal((const xmlChar *)v22);
    xmlC14NFreeCtx(v16);
    return -1;
  }
  v20 = v19;
  xmlC14NFreeCtx(v16);
  return v20;
}

_DWORD *xmlC14NErrParam(const xmlChar *a1)
{
  return __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 1, 2, 0, 0, a1, 0, 0, 0, 0, "Invalid parameter : %s\n", (char)a1);
}

uint64_t xmlC14NProcessNodeList(xmlDocPtr *a1, uint64_t a2, __n128 a3)
{
  uint64_t v3;
  int (__cdecl *v5)(const void *, void *);
  uint64_t (*v6)(_QWORD, _QWORD, _QWORD);
  int v7;
  uint64_t result;
  char *v9;
  char *v10;
  uint64_t **v11;
  xmlURIPtr v12;
  xmlURI *v13;
  xmlDocPtr v14;
  xmlElementType type;
  uint64_t v16;
  const char *v17;
  _BYTE *v18;
  char *v19;
  char *v20;
  xmlOutputBuffer *v21;
  const char *v22;
  const char *v23;
  _BYTE *v24;
  char *v25;
  char *v26;
  int v27;
  xmlListPtr v28;
  xmlList *v29;
  const xmlChar **v30;
  const xmlChar *v31;
  int v32;
  int v33;
  uint64_t v34;
  xmlNsPtr v35;
  const xmlChar **v36;
  unsigned int (*v37)(xmlDocPtr, const xmlChar **, uint64_t);
  _BOOL4 v38;
  xmlListPtr v39;
  int (__cdecl *v40)(const void *, void *);
  int v41;
  uint64_t v42;
  xmlNs *i;
  unsigned int (*v44)(xmlDocPtr, xmlNs *, uint64_t);
  _BOOL4 v45;
  __int128 *v46;
  xmlNsPtr v47;
  int v48;
  unsigned int (*v49)(xmlDocPtr, xmlNsPtr, uint64_t);
  uint64_t j;
  uint64_t v51;
  uint64_t v52;
  unsigned int (*v53)(xmlDocPtr, uint64_t, uint64_t);
  int v54;
  int *v55;
  int v56;
  xmlListPtr v57;
  xmlList *v58;
  int v59;
  _QWORD *m;
  unsigned int (*v61)(_QWORD, _QWORD, _QWORD);
  uint64_t v62;
  unsigned int (*v63)(_QWORD, _QWORD, _QWORD);
  uint64_t v64;
  _QWORD *n;
  uint64_t v66;
  xmlAttrPtr v67;
  uint64_t v68;
  xmlAttrPtr v69;
  xmlAttrPtr v70;
  uint64_t v71;
  int v72;
  unsigned int (*v73)(xmlDocPtr, uint64_t, uint64_t);
  _QWORD *k;
  unsigned int (*v75)(_QWORD, _QWORD, _QWORD);
  xmlChar *String;
  xmlChar *v77;
  const xmlNode *ii;
  unsigned int (*v79)(xmlDocPtr, const xmlNode *, _xmlNode *);
  xmlAttrPtr v80;
  xmlChar *v81;
  xmlChar *v82;
  int v83;
  xmlChar *v84;
  xmlChar *v85;
  uint64_t v86;
  xmlDocPtr v87;
  const char *v88;
  const char *v89;
  const char *v90;
  const char *v91;
  const char *v92;
  __n128 v93;
  xmlElementType v94;
  int v95;

  if (!a2)
    return 0;
  v3 = a2;
  v5 = (int (__cdecl *)(const void *, void *))xmlC14NPrintNamespacesWalker;
  while (2)
  {
    v6 = (uint64_t (*)(_QWORD, _QWORD, _QWORD))a1[1];
    if (v6)
      v7 = v6(a1[2], v3, *(_QWORD *)(v3 + 40));
    else
      v7 = 1;
    result = 0;
    switch(*(_DWORD *)(v3 + 8))
    {
      case 1:
        v11 = *(uint64_t ***)(v3 + 96);
        if (!v11)
          goto LABEL_19;
        do
        {
          if (xmlStrlen((const xmlChar *)v11[2]) < 1)
            goto LABEL_18;
          v12 = xmlParseURI((const char *)v11[2]);
          if (!v12)
          {
            xmlC14NErrInternal((const xmlChar *)"parsing namespace uri");
LABEL_255:
            v89 = "checking for relative namespaces";
            goto LABEL_256;
          }
          v13 = v12;
          if (!xmlStrlen((const xmlChar *)v12->scheme))
          {
            __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 1955, 2, 0, 0, 0, 0, 0, 0, 0, "Relative namespace UR is invalid here : %s\n", (char)v13->scheme);
            xmlFreeURI(v13);
            goto LABEL_255;
          }
          xmlFreeURI(v13);
LABEL_18:
          v11 = (uint64_t **)*v11;
        }
        while (v11);
LABEL_19:
        v14 = a1[6];
        if (v14)
        {
          a3.n128_u64[0] = (unint64_t)v14->_private;
          v93 = a3;
          type = v14->type;
          if (v7)
            goto LABEL_21;
LABEL_48:
          v95 = 0;
        }
        else
        {
          xmlC14NErrParam((const xmlChar *)"saving namespaces stack");
          type = 0;
          v93 = 0u;
          if (!v7)
            goto LABEL_48;
LABEL_21:
          v95 = *((_DWORD *)a1 + 11);
          if (v95)
            a1[5] = (xmlDocPtr)1;
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], "<");
          v16 = *(_QWORD *)(v3 + 72);
          if (v16 && xmlStrlen(*(const xmlChar **)(v16 + 24)) >= 1)
          {
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(*(_QWORD *)(v3 + 72) + 24));
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ":");
          }
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(v3 + 16));
        }
        v27 = *(_DWORD *)(v3 + 8);
        v94 = type;
        if (*((_DWORD *)a1 + 14) != 1)
        {
          if (v27 == 1)
          {
            v39 = xmlListCreate(0, (xmlListDataCompare)xmlC14NNsCompare);
            if (v39)
            {
              v29 = v39;
              v40 = v5;
              v41 = 0;
              v42 = v3;
              do
              {
                for (i = *(xmlNs **)(v42 + 96); i; i = i->next)
                {
                  if (xmlSearchNs(*(xmlDocPtr *)(v3 + 64), (xmlNodePtr)v3, i->prefix) == i
                    && !xmlC14NIsXmlNs((uint64_t)i))
                  {
                    v44 = (unsigned int (*)(xmlDocPtr, xmlNs *, uint64_t))a1[1];
                    if (!v44 || v44(a1[2], i, v3))
                    {
                      v45 = xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)i);
                      if (v7)
                        xmlC14NVisibleNsStackAdd((int *)a1[6], (uint64_t)i, v3);
                      if (!v45)
                        xmlListInsert(v29, i);
                      if (!xmlStrlen(i->prefix))
                        v41 = 1;
                    }
                  }
                }
                v42 = *(_QWORD *)(v42 + 40);
              }
              while (v42);
              v5 = v40;
              if (v7)
              {
                if (!v41)
                {
                  xmmword_1EEEB9258 = 0u;
                  unk_1EEEB9268 = 0u;
                  xmlC14NProcessNamespacesAxis_ns_default = 0u;
                  if (!xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)&xmlC14NProcessNamespacesAxis_ns_default))
                  {
                    v46 = &xmlC14NProcessNamespacesAxis_ns_default;
                    goto LABEL_139;
                  }
                }
              }
              goto LABEL_140;
            }
            v92 = "creating namespaces list (c14n)";
            goto LABEL_275;
          }
          v91 = "processing namespaces axis (c14n)";
LABEL_272:
          xmlC14NErrParam((const xmlChar *)v91);
LABEL_276:
          v89 = "processing namespaces axis";
          break;
        }
        if (v27 != 1)
        {
          v91 = "processing namespaces axis (exc c14n)";
          goto LABEL_272;
        }
        v28 = xmlListCreate(0, (xmlListDataCompare)xmlC14NNsCompare);
        if (!v28)
        {
          v92 = "creating namespaces list (exc c14n)";
LABEL_275:
          xmlC14NErrInternal((const xmlChar *)v92);
          goto LABEL_276;
        }
        v29 = v28;
        v30 = (const xmlChar **)a1[8];
        if (v30 && (v31 = *v30) != 0)
        {
          v32 = 0;
          v33 = 0;
          v34 = 8;
          do
          {
            if (xmlStrEqual(v31, (const xmlChar *)"#default") || xmlStrEqual(v31, (const xmlChar *)&byte_1B0865C1A))
            {
              v31 = 0;
              v32 = 1;
            }
            v35 = xmlSearchNs(*(xmlDocPtr *)(v3 + 64), (xmlNodePtr)v3, v31);
            if (v35)
            {
              v36 = (const xmlChar **)v35;
              if (!xmlC14NIsXmlNs((uint64_t)v35))
              {
                v37 = (unsigned int (*)(xmlDocPtr, const xmlChar **, uint64_t))a1[1];
                if (!v37 || v37(a1[2], v36, v3))
                {
                  v38 = xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)v36);
                  if (v7)
                    xmlC14NVisibleNsStackAdd((int *)a1[6], (uint64_t)v36, v3);
                  if (!v38)
                    xmlListInsert(v29, v36);
                  if (!xmlStrlen(v36[3]))
                    v33 = 1;
                }
              }
            }
            v31 = *(const xmlChar **)((char *)&a1[8]->_private + v34);
            v34 += 8;
          }
          while (v31);
        }
        else
        {
          v33 = 0;
          v32 = 0;
        }
        v47 = *(xmlNsPtr *)(v3 + 72);
        if (v47)
        {
          v48 = 0;
LABEL_101:
          if (!xmlC14NIsXmlNs((uint64_t)v47))
          {
            if (v7)
            {
              v49 = (unsigned int (*)(xmlDocPtr, xmlNsPtr, uint64_t))a1[1];
              if ((!v49 || v49(a1[2], v47, v3))
                && !xmlExcC14NVisibleNsStackFind((unsigned int *)a1[6], (uint64_t)v47, (uint64_t)a1))
              {
                xmlListInsert(v29, v47);
              }
              xmlC14NVisibleNsStackAdd((int *)a1[6], (uint64_t)v47, v3);
            }
            if (!xmlStrlen(v47->prefix))
              v33 = 1;
          }
        }
        else
        {
          v47 = xmlSearchNs(*(xmlDocPtr *)(v3 + 64), (xmlNodePtr)v3, 0);
          v48 = 1;
          if (v47)
            goto LABEL_101;
        }
        for (j = *(_QWORD *)(v3 + 88); j; j = *(_QWORD *)(j + 48))
        {
          v51 = *(_QWORD *)(j + 72);
          if (v51)
          {
            if (xmlC14NIsXmlNs(v51)
              || (v53 = (unsigned int (*)(xmlDocPtr, uint64_t, uint64_t))a1[1]) != 0 && !v53(a1[2], j, v3))
            {
              v52 = *(_QWORD *)(j + 72);
              if (v52
                && !xmlStrlen(*(const xmlChar **)(v52 + 24))
                && !xmlStrlen(*(const xmlChar **)(*(_QWORD *)(j + 72) + 16)))
              {
                v48 = 1;
              }
            }
            else
            {
              v54 = xmlExcC14NVisibleNsStackFind((unsigned int *)a1[6], *(_QWORD *)(j + 72), (uint64_t)a1);
              xmlC14NVisibleNsStackAdd((int *)a1[6], *(_QWORD *)(j + 72), v3);
              if (v7 && !v54)
                xmlListInsert(v29, *(void **)(j + 72));
              if (!xmlStrlen(*(const xmlChar **)(*(_QWORD *)(j + 72) + 24)))
                v33 = 1;
            }
          }
        }
        if (!v7 || !v48 || v33 || v32)
        {
          if (!v7 || v33)
          {
            v5 = (int (__cdecl *)(const void *, void *))xmlC14NPrintNamespacesWalker;
          }
          else if (v32
                 && (xmmword_1EEEB92B8 = 0u,
                     unk_1EEEB92C8 = 0u,
                     xmlExcC14NProcessNamespacesAxis_ns_default_66 = 0u,
                     !xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)&xmlExcC14NProcessNamespacesAxis_ns_default_66)))
          {
            v46 = &xmlExcC14NProcessNamespacesAxis_ns_default_66;
            v5 = (int (__cdecl *)(const void *, void *))xmlC14NPrintNamespacesWalker;
LABEL_139:
            xmlC14NPrintNamespaces((uint64_t)v46, (uint64_t)a1);
          }
          else
          {
            v5 = (int (__cdecl *)(const void *, void *))xmlC14NPrintNamespacesWalker;
          }
        }
        else
        {
          xmmword_1EEEB9288 = 0u;
          unk_1EEEB9298 = 0u;
          xmlExcC14NProcessNamespacesAxis_ns_default = 0u;
          v5 = (int (__cdecl *)(const void *, void *))xmlC14NPrintNamespacesWalker;
          if (!xmlExcC14NVisibleNsStackFind((unsigned int *)a1[6], (uint64_t)&xmlExcC14NProcessNamespacesAxis_ns_default, (uint64_t)a1))
          {
            v46 = &xmlExcC14NProcessNamespacesAxis_ns_default;
            goto LABEL_139;
          }
        }
LABEL_140:
        xmlListWalk(v29, v5, a1);
        xmlListDelete(v29);
        if (v7)
        {
          v55 = (int *)a1[6];
          if (v55)
          {
            v56 = *v55;
            v55[1] = v55[2];
            v55[2] = v56;
          }
          else
          {
            xmlC14NErrParam((const xmlChar *)"shifting namespaces stack");
          }
        }
        if (*(_DWORD *)(v3 + 8) != 1)
        {
          xmlC14NErrParam((const xmlChar *)"processing attributes axis");
LABEL_268:
          v89 = "processing attributes axis";
          break;
        }
        v57 = xmlListCreate(0, (xmlListDataCompare)xmlC14NAttrsCompare);
        if (!v57)
        {
          xmlC14NErrInternal((const xmlChar *)"creating attributes list");
          goto LABEL_268;
        }
        v58 = v57;
        v59 = *((_DWORD *)a1 + 14);
        if (v59 != 2)
        {
          if (v59 == 1)
          {
            for (k = *(_QWORD **)(v3 + 88); k; k = (_QWORD *)k[6])
            {
              v75 = (unsigned int (*)(_QWORD, _QWORD, _QWORD))a1[1];
              if (!v75 || v75(a1[2], k, v3))
                xmlListInsert(v58, k);
            }
            goto LABEL_231;
          }
          if (v59)
            goto LABEL_167;
          for (m = *(_QWORD **)(v3 + 88); m; m = (_QWORD *)m[6])
          {
            v61 = (unsigned int (*)(_QWORD, _QWORD, _QWORD))a1[1];
            if (!v61 || v61(a1[2], m, v3))
              xmlListInsert(v58, m);
          }
          if (v7)
          {
            v62 = *(_QWORD *)(v3 + 40);
            if (v62)
            {
              v63 = (unsigned int (*)(_QWORD, _QWORD, _QWORD))a1[1];
              if (v63)
              {
                if (!v63(a1[2], v62, *(_QWORD *)(v62 + 40)))
                {
                  v64 = *(_QWORD *)(v3 + 40);
                  if (v64)
                  {
                    do
                    {
                      for (n = *(_QWORD **)(v64 + 88); n; n = (_QWORD *)n[6])
                      {
                        v66 = n[9];
                        if (v66 && xmlC14NIsXmlNs(v66) && !xmlListSearch(v58, n))
                          xmlListInsert(v58, n);
                      }
                      v67 = 0;
                      v64 = *(_QWORD *)(v64 + 40);
                    }
                    while (v64);
                    goto LABEL_232;
                  }
                }
              }
              goto LABEL_231;
            }
LABEL_167:
            v67 = 0;
            goto LABEL_232;
          }
LABEL_228:
          xmlListWalk(v58, (xmlListWalker)xmlC14NPrintAttrs, a1);
          xmlFreePropList(0);
          xmlListDelete(v58);
          goto LABEL_234;
        }
        v68 = *(_QWORD *)(v3 + 88);
        if (!v68)
        {
          v5 = (int (__cdecl *)(const void *, void *))xmlC14NPrintNamespacesWalker;
          if (v7)
          {
            v67 = 0;
            v69 = 0;
            goto LABEL_205;
          }
          goto LABEL_228;
        }
        v69 = 0;
        v70 = 0;
        v67 = 0;
        while (2)
        {
          if (!v7)
            goto LABEL_190;
          v71 = *(_QWORD *)(v68 + 72);
          if (!v71 || !xmlC14NIsXmlNs(v71))
            goto LABEL_190;
          if (!v70 && xmlStrEqual(*(const xmlChar **)(v68 + 16), (const xmlChar *)"lang"))
          {
            v70 = (xmlAttrPtr)v68;
            goto LABEL_193;
          }
          if (v69)
          {
            if (!v67)
              goto LABEL_184;
LABEL_190:
            v73 = (unsigned int (*)(xmlDocPtr, uint64_t, uint64_t))a1[1];
            if (!v73 || v73(a1[2], v68, v3))
              xmlListInsert(v58, (void *)v68);
          }
          else
          {
            v72 = xmlStrEqual(*(const xmlChar **)(v68 + 16), (const xmlChar *)"space");
            if (v72)
              v69 = (xmlAttrPtr)v68;
            else
              v69 = 0;
            if (v72 || v67)
            {
              if (!v72)
              {
                v69 = 0;
                goto LABEL_190;
              }
              v69 = (xmlAttrPtr)v68;
            }
            else
            {
LABEL_184:
              if (!xmlStrEqual(*(const xmlChar **)(v68 + 16), (const xmlChar *)"base"))
              {
                v67 = 0;
                goto LABEL_190;
              }
              v67 = (xmlAttrPtr)v68;
            }
          }
LABEL_193:
          v68 = *(_QWORD *)(v68 + 48);
          if (v68)
            continue;
          break;
        }
        v5 = (int (__cdecl *)(const void *, void *))xmlC14NPrintNamespacesWalker;
        if (!v7)
          goto LABEL_228;
        if (v70)
          goto LABEL_206;
LABEL_205:
        v70 = xmlC14NFindHiddenParentAttr((uint64_t)a1, *(const xmlNode **)(v3 + 40), (const xmlChar *)"lang");
        if (v70)
LABEL_206:
          xmlListInsert(v58, v70);
        if (v69
          || (v69 = xmlC14NFindHiddenParentAttr((uint64_t)a1, *(const xmlNode **)(v3 + 40), (const xmlChar *)"space")) != 0)
        {
          xmlListInsert(v58, v69);
        }
        if (v67
          || (v67 = xmlC14NFindHiddenParentAttr((uint64_t)a1, *(const xmlNode **)(v3 + 40), (const xmlChar *)"base")) != 0)
        {
          if (v67->parent)
          {
            String = xmlNodeListGetString(*a1, v67->children, 1);
            if (String)
            {
              v77 = String;
              for (ii = v67->parent->parent; ii; ii = ii->parent)
              {
                v79 = (unsigned int (*)(xmlDocPtr, const xmlNode *, _xmlNode *))a1[1];
                if (!v79 || v79(a1[2], ii, ii->parent))
                  break;
                v80 = xmlHasNsProp(ii, (const xmlChar *)"base", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
                if (v80)
                {
                  v81 = xmlNodeListGetString(*a1, v80->children, 1);
                  if (!v81)
                  {
                    xmlFree(v77);
                    v88 = "processing xml:base attribute - can't get attr value";
LABEL_250:
                    xmlC14NErrInternal((const xmlChar *)v88);
                    goto LABEL_251;
                  }
                  v82 = v81;
                  v83 = xmlStrlen(v81);
                  if (v83 >= 2 && v82[v83 - 2] == 46)
                  {
                    v84 = xmlStrcat(v82, (const xmlChar *)"/");
                    if (!v84)
                    {
                      xmlFree(v82);
                      xmlFree(v77);
                      xmlC14NErrInternal((const xmlChar *)"processing xml:base attribute - can't modify uri");
                      v67 = 0;
                      v5 = (int (__cdecl *)(const void *, void *))xmlC14NPrintNamespacesWalker;
                      goto LABEL_232;
                    }
                  }
                  else
                  {
                    v84 = v82;
                  }
                  v85 = xmlBuildURI(v77, v84);
                  xmlFree(v84);
                  xmlFree(v77);
                  v77 = v85;
                  if (!v85)
                  {
                    v88 = "processing xml:base attribute - can't construct uri";
                    goto LABEL_250;
                  }
                }
              }
              if (xmlStrEqual(v77, (const xmlChar *)&byte_1B0865C1A))
              {
                xmlFree(v77);
LABEL_251:
                v67 = 0;
                v5 = (int (__cdecl *)(const void *, void *))xmlC14NPrintNamespacesWalker;
              }
              else
              {
                v67 = xmlNewNsProp(0, v67->ns, (const xmlChar *)"base", v77);
                xmlFree(v77);
                v5 = (int (__cdecl *)(const void *, void *))xmlC14NPrintNamespacesWalker;
                if (v67)
                {
                  xmlListInsert(v58, v67);
                  v67->next = 0;
                }
                else
                {
                  xmlC14NErrInternal((const xmlChar *)"processing xml:base attribute - can't construct attribute");
                }
              }
              goto LABEL_232;
            }
            xmlC14NErrInternal((const xmlChar *)"processing xml:base attribute - can't get attr value");
          }
          else
          {
            xmlC14NErrParam((const xmlChar *)"processing xml:base attribute");
          }
LABEL_231:
          v67 = 0;
        }
LABEL_232:
        xmlListWalk(v58, (xmlListWalker)xmlC14NPrintAttrs, a1);
        xmlFreePropList(v67);
        xmlListDelete(v58);
        if (v7)
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ">");
LABEL_234:
        if (*(_QWORD *)(v3 + 24) && (xmlC14NProcessNodeList(a1) & 0x80000000) != 0)
        {
          v89 = "processing childrens list";
          break;
        }
        if (v7)
        {
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], "</");
          v86 = *(_QWORD *)(v3 + 72);
          if (v86 && xmlStrlen(*(const xmlChar **)(v86 + 24)) >= 1)
          {
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(*(_QWORD *)(v3 + 72) + 24));
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ":");
          }
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(v3 + 16));
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ">");
          if (v95)
          {
            *((_DWORD *)a1 + 10) = 2;
            *((_DWORD *)a1 + 11) = v95;
          }
        }
        v87 = a1[6];
        if (v87)
        {
          result = 0;
          a3.n128_u64[1] = v93.n128_u64[1];
          v87->_private = (void *)v93.n128_u64[0];
          v87->type = v94;
        }
        else
        {
          xmlC14NErrParam((const xmlChar *)"restoring namespaces stack");
          result = 0;
        }
LABEL_97:
        v3 = *(_QWORD *)(v3 + 48);
        if (v3 && (result & 0x80000000) == 0)
          continue;
        return result;
      case 2:
        v90 = "XML_ATTRIBUTE_NODE";
        goto LABEL_262;
      case 3:
      case 4:
        if (!v7)
          goto LABEL_96;
        result = *(_QWORD *)(v3 + 80);
        if (!result)
          goto LABEL_97;
        v9 = xmlC11NNormalizeString((_BYTE *)result, 3u);
        if (!v9)
        {
          v89 = "normalizing text node";
          goto LABEL_256;
        }
        v10 = v9;
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v9);
        xmlFree(v10);
        goto LABEL_96;
      case 5:
        v90 = "XML_ENTITY_REF_NODE";
        goto LABEL_262;
      case 6:
        v90 = "XML_ENTITY_NODE";
        goto LABEL_262;
      case 7:
        if (!v7)
          goto LABEL_96;
        if (*((_DWORD *)a1 + 10) == 2)
          v17 = "\n<?";
        else
          v17 = "<?";
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v17);
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(v3 + 16));
        v18 = *(_BYTE **)(v3 + 80);
        if (!v18 || !*v18)
          goto LABEL_35;
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], " ");
        v19 = xmlC11NNormalizeString(*(_BYTE **)(v3 + 80), 2u);
        if (v19)
        {
          v20 = v19;
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v19);
          xmlFree(v20);
LABEL_35:
          v21 = (xmlOutputBuffer *)a1[4];
          if (*((_DWORD *)a1 + 10))
            v22 = "?>";
          else
            v22 = "?>\n";
LABEL_95:
          xmlOutputBufferWriteString(v21, v22);
LABEL_96:
          result = 0;
          goto LABEL_97;
        }
        v89 = "normalizing pi node";
        break;
      case 8:
        if (!v7 || !*((_DWORD *)a1 + 6))
          goto LABEL_96;
        if (*((_DWORD *)a1 + 10) == 2)
          v23 = "\n<!--";
        else
          v23 = "<!--";
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v23);
        v24 = *(_BYTE **)(v3 + 80);
        if (!v24)
          goto LABEL_45;
        v25 = xmlC11NNormalizeString(v24, 1u);
        if (v25)
        {
          v26 = v25;
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v25);
          xmlFree(v26);
LABEL_45:
          v21 = (xmlOutputBuffer *)a1[4];
          if (*((_DWORD *)a1 + 10))
            v22 = "-->";
          else
            v22 = "-->\n";
          goto LABEL_95;
        }
        v89 = "normalizing comment node";
        break;
      case 9:
      case 0xB:
      case 0xD:
      case 0x15:
        if (!*(_QWORD *)(v3 + 24))
          goto LABEL_96;
        a1[5] = (xmlDocPtr)0x100000000;
        result = xmlC14NProcessNodeList(a1);
        goto LABEL_97;
      case 0xA:
      case 0xC:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        goto LABEL_97;
      case 0x12:
        v90 = "XML_NAMESPACE_DECL";
LABEL_262:
        xmlC14NErrInvalidNode((char)v90);
        return 0xFFFFFFFFLL;
      default:
        __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 1954, 2, 0, 0, (const xmlChar *)"processing node", 0, 0, 0, 0, "Unknown node type %d found : %s\n", *(_DWORD *)(v3 + 8));
        return 0xFFFFFFFFLL;
    }
    break;
  }
LABEL_256:
  xmlC14NErrInternal((const xmlChar *)v89);
  return 0xFFFFFFFFLL;
}

_DWORD *xmlC14NErrInternal(const xmlChar *a1)
{
  return __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 1, 2, 0, 0, a1, 0, 0, 0, 0, "Internal error : %s\n", (char)a1);
}

void xmlC14NFreeCtx(_QWORD *a1)
{
  int *v2;
  void *v3;
  void *v4;

  v2 = (int *)a1[6];
  if (v2)
  {
    v3 = (void *)*((_QWORD *)v2 + 2);
    if (v3)
    {
      bzero(v3, 8 * v2[3]);
      xmlFree(*((void **)v2 + 2));
    }
    v4 = (void *)*((_QWORD *)v2 + 3);
    if (v4)
    {
      bzero(v4, 8 * v2[3]);
      xmlFree(*((void **)v2 + 3));
    }
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    xmlFree(v2);
  }
  xmlFree(a1);
}

int xmlC14NDocSaveTo(xmlDocPtr doc, xmlNodeSetPtr nodes, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, xmlOutputBufferPtr buf)
{
  return xmlC14NExecute(doc, (xmlC14NIsVisibleCallback)xmlC14NIsNodeInNodeset, nodes, mode, inclusive_ns_prefixes, with_comments, buf);
}

uint64_t xmlC14NIsNodeInNodeset(xmlNodeSet *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  __int128 v4;
  _OWORD v6[3];

  v3 = 1;
  if (!a1 || !a2)
    return v3;
  if (*(_DWORD *)(a2 + 8) == 18)
  {
    v4 = *(_OWORD *)(a2 + 16);
    v6[0] = *(_OWORD *)a2;
    v6[1] = v4;
    v6[2] = *(_OWORD *)(a2 + 32);
    if (a3)
    {
      if (*(_DWORD *)(a3 + 8) == 2)
        a3 = *(_QWORD *)(a3 + 40);
    }
    *(_QWORD *)&v6[0] = a3;
    return xmlXPathNodeSetContains(a1, (xmlNodePtr)v6);
  }
  return xmlXPathNodeSetContains(a1, (xmlNodePtr)a2);
}

int xmlC14NDocDumpMemory(xmlDocPtr doc, xmlNodeSetPtr nodes, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, xmlChar **doc_txt_ptr)
{
  xmlOutputBuffer *v12;
  xmlOutputBuffer *v13;
  int v14;
  xmlChar *v15;
  const char *v16;

  if (!doc_txt_ptr)
  {
    xmlC14NErrParam((const xmlChar *)"dumping doc to memory");
    return -1;
  }
  *doc_txt_ptr = 0;
  v12 = xmlAllocOutputBuffer(0);
  if (!v12)
  {
    v16 = "creating output buffer";
    goto LABEL_11;
  }
  v13 = v12;
  if (xmlC14NExecute(doc, (xmlC14NIsVisibleCallback)xmlC14NIsNodeInNodeset, nodes, mode, inclusive_ns_prefixes, with_comments, v12) < 0)
  {
    xmlC14NErrInternal((const xmlChar *)"saving doc to output buffer");
    xmlOutputBufferClose(v13);
    return -1;
  }
  v14 = xmlBufUse(v13->buffer);
  if ((v14 & 0x80000000) == 0)
  {
    v15 = xmlBufContent(v13->buffer);
    *doc_txt_ptr = xmlStrndup(v15, v14);
  }
  xmlOutputBufferClose(v13);
  if ((v14 & 0x80000000) == 0 && !*doc_txt_ptr)
  {
    v16 = "copying canonicalized document";
LABEL_11:
    xmlC14NErrMemory((const xmlChar *)v16);
    return -1;
  }
  return v14;
}

_DWORD *xmlC14NErrMemory(const xmlChar *a1)
{
  return __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 2, 2, 0, 0, a1, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a1);
}

int xmlC14NDocSave(xmlDocPtr doc, xmlNodeSetPtr nodes, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, const char *filename, int compression)
{
  xmlOutputBuffer *v13;
  xmlOutputBuffer *v14;

  if (filename)
  {
    if (compression < 0)
      compression = xmlGetCompressMode();
    v13 = xmlOutputBufferCreateFilename(filename, 0, compression);
    if (v13)
    {
      v14 = v13;
      if ((xmlC14NExecute(doc, (xmlC14NIsVisibleCallback)xmlC14NIsNodeInNodeset, nodes, mode, inclusive_ns_prefixes, with_comments, v13) & 0x80000000) == 0)return xmlOutputBufferClose(v14);
      xmlC14NErrInternal((const xmlChar *)"canonize document to buffer");
      xmlOutputBufferClose(v14);
    }
    else
    {
      xmlC14NErrInternal((const xmlChar *)"creating temporary filename");
    }
  }
  else
  {
    xmlC14NErrParam((const xmlChar *)"saving doc");
  }
  return -1;
}

char *xmlC11NNormalizeString(_BYTE *a1, unsigned int a2)
{
  char *v4;
  int v5;
  unsigned __int8 *v6;
  int v7;
  char *v8;
  int v9;
  char *v10;
  int v11;
  int v12;
  int v13;
  const char *v14;

  if (!a1)
    return 0;
  v4 = (char *)xmlMallocAtomic(0x3E8uLL);
  if (!v4)
  {
    v14 = "allocating buffer";
    goto LABEL_41;
  }
  v5 = *a1;
  if (!*a1)
  {
    v8 = v4;
LABEL_39:
    *v4 = 0;
    return v8;
  }
  v6 = a1 + 1;
  v7 = 1000;
  v8 = v4;
  while (1)
  {
    v9 = (_DWORD)v4 - (_DWORD)v8;
    if (v4 - v8 <= v7 - 10)
      goto LABEL_8;
    v7 *= 2;
    v10 = (char *)xmlRealloc(v8, v7);
    if (!v10)
      break;
    v8 = v10;
    v4 = &v10[v9];
    v5 = *(v6 - 1);
LABEL_8:
    if (v5 == 60)
    {
      if (a2 != 3 && a2)
        goto LABEL_33;
      v11 = 997485606;
      goto LABEL_15;
    }
    if (a2 == 3 && v5 == 62)
    {
      v11 = 997484326;
LABEL_15:
      *(_DWORD *)v4 = v11;
      v4 += 4;
      goto LABEL_34;
    }
    if (v5 == 38)
    {
      if (a2 != 3 && a2)
        goto LABEL_33;
      v12 = 1886216486;
LABEL_32:
      *(_DWORD *)v4 = v12;
      v4[4] = 59;
      v4 += 5;
      goto LABEL_34;
    }
    if (a2 || v5 != 34)
    {
      if (a2 || v5 != 9)
      {
        if (a2 || v5 != 10)
        {
          if (a2 > 3 || v5 != 13)
          {
LABEL_33:
            *v4++ = v5;
            goto LABEL_34;
          }
          v12 = 1148724006;
        }
        else
        {
          v12 = 1098392358;
        }
      }
      else
      {
        v12 = 964174630;
      }
      goto LABEL_32;
    }
    *(_DWORD *)v4 = 1869967654;
    *((_WORD *)v4 + 2) = 15220;
    v4 += 6;
LABEL_34:
    v13 = *v6++;
    v5 = v13;
    if (!v13)
      goto LABEL_39;
  }
  v14 = "growing buffer";
LABEL_41:
  xmlC14NErrMemory((const xmlChar *)v14);
  return 0;
}

_DWORD *xmlC14NErrInvalidNode(char a1)
{
  return __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 1953, 2, 0, 0, (const xmlChar *)"processing node", 0, 0, 0, 0, "Node %s is invalid here : %s\n", a1);
}

uint64_t xmlC14NNsCompare(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
    return 0;
  if (!a1)
    return 0xFFFFFFFFLL;
  if (a2)
    return xmlStrcmp(*(const xmlChar **)(a1 + 24), *(const xmlChar **)(a2 + 24));
  return 1;
}

uint64_t xmlC14NIsXmlNs(uint64_t a1)
{
  uint64_t result;

  result = xmlStrEqual(*(const xmlChar **)(a1 + 24), (const xmlChar *)"xml");
  if ((_DWORD)result)
    return xmlStrEqual(*(const xmlChar **)(a1 + 16), (const xmlChar *)"http://www.w3.org/XML/1998/namespace") != 0;
  return result;
}

BOOL xmlC14NVisibleNsStackFind(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char *v3;
  char *v4;
  char *v5;
  uint64_t v6;
  _BOOL8 result;
  int v8;
  uint64_t v9;
  char *v10;
  char *v11;
  int v12;
  char *v13;
  int v14;

  if (!a1)
  {
    xmlC14NErrParam((const xmlChar *)"searching namespaces stack (c14n)");
    return 0;
  }
  v2 = a1;
  v3 = &byte_1B0865C1A;
  if (a2)
  {
    if (*(_QWORD *)(a2 + 24))
      v4 = *(char **)(a2 + 24);
    else
      v4 = &byte_1B0865C1A;
    if (*(_QWORD *)(a2 + 16))
      v5 = *(char **)(a2 + 16);
    else
      v5 = &byte_1B0865C1A;
    v3 = v4;
  }
  else
  {
    v5 = &byte_1B0865C1A;
  }
  if (*v3)
  {
    v6 = *(_QWORD *)(a1 + 16);
    if (!v6)
      return 0;
  }
  else
  {
    v8 = *v5;
    result = *v5 == 0;
    v6 = *(_QWORD *)(v2 + 16);
    if (!v6)
      return result;
    if (!*v5)
    {
      result = 1;
      goto LABEL_18;
    }
  }
  result = 0;
  v8 = *(_DWORD *)(v2 + 4);
LABEL_18:
  LODWORD(v2) = *(_DWORD *)v2;
  while (2)
  {
    if ((int)v2 > v8)
    {
      v2 = (int)v2;
      while (1)
      {
        --v2;
        v9 = *(_QWORD *)(v6 + 8 * v2);
        if (!v9)
          break;
        v10 = *(char **)(v9 + 24);
        if (v3 == v10)
          goto LABEL_32;
        if (!v10)
          break;
        v11 = v3;
        while (1)
        {
          v12 = *v11;
          if (v12 != *v10)
            break;
          ++v11;
          ++v10;
          if (!v12)
            goto LABEL_32;
        }
        if (v2 <= v8)
          return result;
      }
      if (*v3)
        continue;
      if (v9)
      {
LABEL_32:
        v13 = *(char **)(v9 + 16);
        if (v5 == v13)
          return 1;
        if (v13)
        {
          while (1)
          {
            v14 = *v5;
            if (v14 != *v13)
              break;
            ++v5;
            ++v13;
            if (!v14)
              return 1;
          }
          return 0;
        }
      }
      return *v5 == 0;
    }
    return result;
  }
}

_DWORD *xmlC14NVisibleNsStackAdd(int *a1, uint64_t a2, uint64_t a3)
{
  _DWORD *result;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  int v10;
  _OWORD *v11;
  _OWORD *v12;
  uint64_t v13;

  if (!a1)
    return xmlC14NErrParam((const xmlChar *)"adding namespace to stack");
  result = (_DWORD *)*((_QWORD *)a1 + 2);
  v7 = *((_QWORD *)a1 + 3);
  if (result)
  {
    if (v7)
    {
      v8 = a1[3];
      if ((_DWORD)v8 != *a1)
      {
LABEL_14:
        v13 = *a1;
        *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * v13) = a2;
        *(_QWORD *)(*((_QWORD *)a1 + 3) + 8 * v13) = a3;
        *a1 = v13 + 1;
        return result;
      }
      v9 = xmlRealloc(result, 16 * v8);
      if (v9)
      {
        *((_QWORD *)a1 + 2) = v9;
        result = xmlRealloc(*((void **)a1 + 3), 16 * v8);
        if (result)
        {
          v10 = 2 * v8;
          *((_QWORD *)a1 + 3) = result;
LABEL_13:
          a1[3] = v10;
          goto LABEL_14;
        }
      }
      return xmlC14NErrMemory((const xmlChar *)"adding node to stack");
    }
    return xmlC14NErrParam((const xmlChar *)"adding namespace to stack");
  }
  if (v7)
    return xmlC14NErrParam((const xmlChar *)"adding namespace to stack");
  *((_QWORD *)a1 + 2) = xmlMalloc(0x80uLL);
  result = xmlMalloc(0x80uLL);
  *((_QWORD *)a1 + 3) = result;
  v11 = (_OWORD *)*((_QWORD *)a1 + 2);
  if (v11 && result)
  {
    v11[6] = 0u;
    v11[7] = 0u;
    v11[4] = 0u;
    v11[5] = 0u;
    v11[2] = 0u;
    v11[3] = 0u;
    *v11 = 0u;
    v11[1] = 0u;
    v12 = (_OWORD *)*((_QWORD *)a1 + 3);
    v12[6] = 0u;
    v12[7] = 0u;
    v12[4] = 0u;
    v12[5] = 0u;
    v12[2] = 0u;
    v12[3] = 0u;
    *v12 = 0u;
    v12[1] = 0u;
    v10 = 16;
    goto LABEL_13;
  }
  return xmlC14NErrMemory((const xmlChar *)"adding node to stack");
}

uint64_t xmlC14NPrintNamespaces(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  xmlOutputBuffer *v5;
  const char *v6;
  xmlChar *v8;
  uint64_t v9;

  if (a1 && a2)
  {
    v4 = *(_QWORD *)(a1 + 24);
    v5 = *(xmlOutputBuffer **)(a2 + 32);
    if (v4)
    {
      xmlOutputBufferWriteString(v5, " xmlns:");
      xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), *(const char **)(a1 + 24));
      v5 = *(xmlOutputBuffer **)(a2 + 32);
      v6 = "=";
    }
    else
    {
      v6 = " xmlns=";
    }
    xmlOutputBufferWriteString(v5, v6);
    v8 = *(xmlChar **)(a1 + 16);
    v9 = *(_QWORD *)(a2 + 32);
    if (v8)
      xmlBufWriteQuotedString(*(uint64x2_t **)(v9 + 32), v8);
    else
      xmlOutputBufferWriteString((xmlOutputBufferPtr)v9, "\"\"");
    return 1;
  }
  else
  {
    xmlC14NErrParam((const xmlChar *)"writing namespaces");
    return 0;
  }
}

uint64_t xmlExcC14NVisibleNsStackFind(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  char *v3;
  char *v4;
  char *v5;
  _BOOL8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  int v12;
  char *v14;
  int v15;
  uint64_t (*v16)(_QWORD);

  if (a1)
  {
    v3 = &byte_1B0865C1A;
    if (a2)
    {
      v5 = *(char **)(a2 + 16);
      v4 = *(char **)(a2 + 24);
      if (!v4)
        v4 = &byte_1B0865C1A;
      if (!v5)
        v5 = &byte_1B0865C1A;
      v3 = v4;
    }
    else
    {
      v5 = &byte_1B0865C1A;
    }
    if (*v3)
      v6 = 0;
    else
      v6 = *v5 == 0;
    v7 = *((_QWORD *)a1 + 2);
    if (v7)
    {
      v8 = *a1;
      while (2)
      {
        if ((int)v8 >= 1)
        {
          while (1)
          {
            v9 = *(_QWORD *)(v7 + 8 * (v8 - 1));
            if (!v9)
              break;
            v10 = *(char **)(v9 + 24);
            if (v3 == v10)
              goto LABEL_29;
            if (!v10)
              break;
            v11 = v3;
            while (1)
            {
              v12 = *v11;
              if (v12 != *v10)
                break;
              ++v11;
              ++v10;
              if (!v12)
                goto LABEL_29;
            }
            if (v8-- < 2)
              return v6;
          }
          v8 = (v8 - 1);
          if (*v3)
            continue;
          if (!v9)
            goto LABEL_34;
LABEL_29:
          v14 = *(char **)(v9 + 16);
          if (v5 == v14)
            goto LABEL_35;
          if (v14)
          {
            while (1)
            {
              v15 = *v5;
              if (v15 != *v14)
                return 0;
              ++v5;
              ++v14;
              if (!v15)
                goto LABEL_35;
            }
          }
LABEL_34:
          if (*v5)
            return 0;
LABEL_35:
          v16 = *(uint64_t (**)(_QWORD))(a3 + 8);
          if (v16)
            return v16(*(_QWORD *)(a3 + 16));
          return 1;
        }
        break;
      }
    }
  }
  else
  {
    xmlC14NErrParam((const xmlChar *)"searching namespaces stack (exc c14n)");
    return 0;
  }
  return v6;
}

uint64_t xmlC14NAttrsCompare(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (a1 == a2)
    return 0;
  if (!a1)
    return 0xFFFFFFFFLL;
  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 72);
    v5 = *(_QWORD *)(a2 + 72);
    if (v4 == v5)
      return xmlStrcmp(*(const xmlChar **)(a1 + 16), *(const xmlChar **)(a2 + 16));
    if (!v4)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      if (*(_QWORD *)(v4 + 24))
      {
        if (*(_QWORD *)(v5 + 24))
        {
          result = xmlStrcmp(*(const xmlChar **)(v4 + 16), *(const xmlChar **)(v5 + 16));
          if ((_DWORD)result)
            return result;
          return xmlStrcmp(*(const xmlChar **)(a1 + 16), *(const xmlChar **)(a2 + 16));
        }
        return 1;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return 1;
}

xmlAttrPtr xmlC14NFindHiddenParentAttr(uint64_t a1, const xmlNode *a2, const xmlChar *a3)
{
  const xmlNode *v4;
  unsigned int (*v6)(_QWORD, const xmlNode *, _xmlNode *);
  xmlAttrPtr result;

  if (!a2)
    return 0;
  v4 = a2;
  do
  {
    v6 = *(unsigned int (**)(_QWORD, const xmlNode *, _xmlNode *))(a1 + 8);
    if (!v6 || v6(*(_QWORD *)(a1 + 16), v4, v4->parent))
      break;
    result = xmlHasNsProp(v4, a3, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
    if (result)
      return result;
    v4 = v4->parent;
  }
  while (v4);
  return 0;
}

uint64_t xmlC14NPrintAttrs(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  xmlChar *String;
  xmlChar *v6;
  char *v7;

  if (a1 && a2)
  {
    xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), " ");
    v4 = *(_QWORD *)(a1 + 72);
    if (v4)
    {
      if (xmlStrlen(*(const xmlChar **)(v4 + 24)) >= 1)
      {
        xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), *(const char **)(*(_QWORD *)(a1 + 72) + 24));
        xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), ":");
      }
    }
    xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), *(const char **)(a1 + 16));
    xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), "=\"");
    String = xmlNodeListGetString(*(xmlDocPtr *)a2, *(const xmlNode **)(a1 + 24), 1);
    if (!String)
      goto LABEL_9;
    v6 = String;
    v7 = xmlC11NNormalizeString(String, 0);
    xmlFree(v6);
    if (v7)
    {
      xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), v7);
      xmlFree(v7);
LABEL_9:
      xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), "\"");
      return 1;
    }
    xmlC14NErrInternal((const xmlChar *)"normalizing attributes axis");
  }
  else
  {
    xmlC14NErrParam((const xmlChar *)"writing attributes");
  }
  return 0;
}

void xmlFreeCatalog(xmlCatalogPtr catal)
{
  _QWORD *v2;
  _QWORD *v3;
  xmlHashTable *v4;

  if (catal)
  {
    v2 = (_QWORD *)*((_QWORD *)catal + 14);
    if (v2)
    {
      do
      {
        v3 = (_QWORD *)*v2;
        xmlFreeCatalogEntry((uint64_t)v2);
        v2 = v3;
      }
      while (v3);
    }
    v4 = (xmlHashTable *)*((_QWORD *)catal + 12);
    if (v4)
      xmlHashFree(v4, (xmlHashDeallocator)xmlFreeCatalogEntry);
    xmlFree(catal);
  }
}

void xmlFreeCatalogEntry(uint64_t a1)
{
  xmlGenericErrorFunc v2;
  void *v3;
  uint64_t v4;
  const char *v5;
  void *v6;
  void *v7;
  void *v8;

  if (!a1 || *(_DWORD *)(a1 + 60) == 1)
    return;
  if (xmlDebugCatalogs)
  {
    if (*(_QWORD *)(a1 + 32))
    {
      v2 = *__xmlGenericError();
      v3 = *__xmlGenericErrorContext();
    }
    else
    {
      v4 = *(_QWORD *)(a1 + 40);
      v2 = *__xmlGenericError();
      v3 = *__xmlGenericErrorContext();
      if (!v4)
      {
        v5 = "Free catalog entry\n";
        goto LABEL_9;
      }
    }
    v5 = "Free catalog entry %s\n";
LABEL_9:
    v2(v3, v5);
  }
  v6 = *(void **)(a1 + 32);
  if (v6)
    xmlFree(v6);
  v7 = *(void **)(a1 + 40);
  if (v7)
    xmlFree(v7);
  v8 = *(void **)(a1 + 48);
  if (v8)
    xmlFree(v8);
  xmlFree((void *)a1);
}

int xmlConvertSGMLCatalog(xmlCatalogPtr catal)
{
  xmlGenericErrorFunc v2;
  void **v3;
  xmlCatalogPtr data;

  data = catal;
  if (!catal || *(_DWORD *)catal != 2)
    return -1;
  if (xmlDebugCatalogs)
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "Converting SGML catalog to XML\n");
  }
  xmlHashScan(*((xmlHashTablePtr *)catal + 12), (xmlHashScanner)xmlCatalogConvertEntry, &data);
  return 0;
}

xmlHashTable *xmlCatalogConvertEntry(xmlHashTable *result, uint64_t a2)
{
  xmlHashTable *v3;
  int v4;
  uint64_t v5;
  xmlHashTable *v6;
  xmlHashTable **v7;

  if (result)
  {
    if (a2)
    {
      v3 = result;
      result = *(xmlHashTable **)(a2 + 96);
      if (result)
      {
        if (*(_QWORD *)(a2 + 112))
        {
          v4 = *((_DWORD *)v3 + 6) - 13;
          if (v4 < 0xA && ((0x2FFu >> v4) & 1) != 0)
          {
            *((_DWORD *)v3 + 6) = dword_1B0861874[v4];
            result = (xmlHashTable *)xmlHashRemoveEntry(result, *((const xmlChar **)v3 + 4), 0);
            v5 = *(_QWORD *)(a2 + 112);
            *(_QWORD *)v3 = 0;
            *((_QWORD *)v3 + 1) = v5;
            v6 = *(xmlHashTable **)(v5 + 16);
            if (v6)
            {
              do
              {
                v7 = (xmlHashTable **)v6;
                v6 = *(xmlHashTable **)v6;
              }
              while (v6);
              *v7 = v3;
            }
            else
            {
              *(_QWORD *)(v5 + 16) = v3;
            }
          }
          else
          {
            return (xmlHashTable *)xmlHashRemoveEntry(result, *((const xmlChar **)v3 + 4), (xmlHashDeallocator)xmlFreeCatalogEntry);
          }
        }
      }
    }
  }
  return result;
}

xmlDocPtr xmlParseCatalogFile(const char *filename)
{
  xmlParserCtxtPtr v2;
  xmlParserCtxtPtr v3;
  xmlParserInputBufferPtr v4;
  xmlParserInputBufferPtr v5;
  xmlParserInputPtr v6;
  xmlParserInput *v7;
  xmlChar *v8;
  char *Directory;
  xmlDoc *myDoc;
  xmlSAXHandlerV1 *v11;

  v2 = xmlNewParserCtxt();
  if (!v2)
  {
    if (__xmlDefaultSAXHandler()->error)
    {
      v11 = __xmlDefaultSAXHandler();
      v11->error(0, "out of memory\n");
    }
    return 0;
  }
  v3 = v2;
  v4 = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
  if (!v4)
  {
LABEL_14:
    xmlFreeParserCtxt(v3);
    return 0;
  }
  v5 = v4;
  v6 = xmlNewInputStream(v3);
  if (!v6)
  {
    xmlFreeParserInputBuffer(v5);
    goto LABEL_14;
  }
  v7 = v6;
  v8 = xmlCanonicPath((const xmlChar *)filename);
  v7->buf = v5;
  v7->filename = (const char *)v8;
  xmlBufResetInput((uint64_t *)v5->buffer, v7);
  inputPush(v3, v7);
  if (!v3->directory)
  {
    Directory = xmlParserGetDirectory(filename);
    if (!v3->directory)
    {
      if (Directory)
        v3->directory = Directory;
    }
  }
  *(_QWORD *)&v3->valid = 0;
  v3->loadsubset = 0;
  v3->pedantic = 0;
  v3->dictNames = 1;
  xmlParseDocument(v3);
  myDoc = v3->myDoc;
  if (!v3->wellFormed)
  {
    xmlFreeDoc(v3->myDoc);
    myDoc = 0;
    v3->myDoc = 0;
  }
  xmlFreeParserCtxt(v3);
  return myDoc;
}

xmlCatalogPtr xmlLoadSGMLSuperCatalog(const char *filename)
{
  char *FileContent;
  char *v3;
  xmlCatalog *NewCatalog;
  xmlCatalog *v5;
  int v6;

  FileContent = xmlLoadFileContent((char *)filename);
  if (!FileContent)
    return 0;
  v3 = FileContent;
  NewCatalog = (xmlCatalog *)xmlCreateNewCatalog(2, xmlCatalogDefaultPrefer);
  v5 = NewCatalog;
  if (!NewCatalog)
  {
    xmlFree(v3);
    return v5;
  }
  v6 = xmlParseSGMLCatalog((uint64_t)NewCatalog, (unsigned __int8 *)v3, (xmlChar *)filename, 1);
  xmlFree(v3);
  if (v6 < 0)
  {
    xmlFreeCatalog(v5);
    return 0;
  }
  return v5;
}

char *xmlLoadFileContent(char *a1)
{
  char *v1;
  int v2;
  int v3;
  size_t st_size;
  int v5;
  stat v7;

  v1 = a1;
  if (a1)
  {
    memset(&v7, 0, sizeof(v7));
    if ((stat(a1, &v7) & 0x80000000) == 0)
    {
      v2 = open(v1, 0);
      if ((v2 & 0x80000000) == 0)
      {
        v3 = v2;
        st_size = v7.st_size;
        v1 = (char *)xmlMallocAtomic(v7.st_size + 10);
        if (!v1)
        {
          xmlCatalogErrMemory((const xmlChar *)"allocating catalog data");
          close(v3);
          return v1;
        }
        v5 = read(v3, v1, st_size);
        close(v3);
        if ((v5 & 0x80000000) == 0)
        {
          v1[v5] = 0;
          return v1;
        }
        xmlFree(v1);
      }
    }
    return 0;
  }
  return v1;
}

_OWORD *xmlCreateNewCatalog(int a1, int a2)
{
  _OWORD *v4;
  _OWORD *v5;

  v4 = xmlMalloc(0x78uLL);
  v5 = v4;
  if (v4)
  {
    v4[5] = 0u;
    v4[6] = 0u;
    *((_QWORD *)v4 + 14) = 0;
    v4[3] = 0u;
    v4[4] = 0u;
    v4[1] = 0u;
    v4[2] = 0u;
    *v4 = 0u;
    *(_DWORD *)v4 = a1;
    *((_QWORD *)v4 + 11) = 0xA00000000;
    *((_DWORD *)v4 + 26) = a2;
    if (a1 == 2)
      *((_QWORD *)v4 + 12) = xmlHashCreate(10);
  }
  else
  {
    xmlCatalogErrMemory((const xmlChar *)"allocating catalog");
  }
  return v5;
}

uint64_t xmlParseSGMLCatalog(uint64_t a1, unsigned __int8 *a2, xmlChar *cur, int a4)
{
  xmlChar *v7;
  unsigned int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  xmlChar *v11;
  unsigned int v12;
  char v14;
  int v15;
  int v16;
  int v17;
  unsigned __int8 *v18;
  unsigned int v19;
  char v21;
  xmlChar *v22;
  xmlChar *v23;
  xmlChar *v24;
  int v25;
  int v26;
  unsigned __int8 *v27;
  unsigned int v28;
  char v29;
  int v30;
  int v31;
  unsigned __int8 *v32;
  xmlChar *v33;
  xmlChar *v34;
  xmlChar *v35;
  _QWORD *v36;
  xmlChar *v37;
  _QWORD *v38;
  char *v39;
  char *v40;
  int v42;
  xmlChar *str1;
  xmlChar *cura;

  if (!cur)
    return 0xFFFFFFFFLL;
  v7 = xmlStrdup(cur);
  if (!a2)
    goto LABEL_100;
  while (1)
  {
LABEL_3:
    v8 = *a2;
    if (!*a2)
      break;
    v9 = a2 + 2;
    a2 += 4;
    while (v8 <= 0x2D)
    {
      if (((1 << v8) & 0x100002600) == 0)
      {
        if (!v8)
        {
          a2 = v9 - 2;
          goto LABEL_100;
        }
        if (v8 == 45 && *(v9 - 1) == 45)
        {
          while (1)
          {
            if (*(a2 - 2) == 45)
            {
              if (*(a2 - 1) == 45)
                goto LABEL_3;
            }
            else if (!*(a2 - 2))
            {
              a2 = 0;
              goto LABEL_100;
            }
            ++a2;
          }
        }
        break;
      }
      v8 = *(v9++ - 1);
      ++a2;
    }
    str1 = 0;
    cura = 0;
    v10 = xmlParseSGMLCatalogName(v9 - 2, &str1);
    a2 = v10;
    if (!v10)
      break;
    v11 = str1;
    if (!str1)
      break;
    v12 = *v10;
    if (v12 > 0x20 || ((1 << v12) & 0x100002600) == 0)
      goto LABEL_108;
    while (v12 <= 0x20u && ((1 << v12) & 0x100002600) != 0)
    {
      v14 = *++a2;
      LOBYTE(v12) = v14;
    }
    v15 = xmlStrEqual(str1, (const xmlChar *)"SYSTEM");
    if (v15)
    {
      v17 = 13;
LABEL_43:
      v42 = v17;
      xmlFree(v11);
      str1 = 0;
      v18 = xmlParseSGMLCatalogPubid(a2, &str1);
      if (!v18)
        goto LABEL_105;
      a2 = v18;
      if (!v15)
      {
        v22 = str1;
        v23 = xmlCatalogNormalizePublic(str1);
        if (v23)
        {
          v24 = v23;
          if (v22)
            xmlFree(v22);
          if (*v24)
          {
            str1 = v24;
          }
          else
          {
            xmlFree(v24);
            str1 = 0;
          }
        }
      }
      v19 = *a2;
      if (v19 > 0x20 || ((1 << v19) & 0x100002600) == 0)
      {
LABEL_71:
        v30 = v42;
LABEL_82:
        if ((v30 - 13) > 1)
        {
          if (v30 == 22)
          {
            v37 = cura;
            if (a4)
            {
              v38 = xmlNewCatalogEntry(22, cura, 0, 0, 0, 0);
              if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 96), v37, v38) < 0)
                xmlFreeCatalogEntry((uint64_t)v38);
            }
            else
            {
              v39 = (char *)xmlBuildURI(cura, v7);
              if (v39)
              {
                v40 = v39;
                xmlExpandCatalog(a1, v39);
                xmlFree(v40);
              }
            }
          }
        }
        else
        {
          v33 = xmlBuildURI(cura, v7);
          if (v33)
          {
            v34 = v33;
            v35 = str1;
            v36 = xmlNewCatalogEntry(v30, str1, v33, 0, 0, 0);
            if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 96), v35, v36) < 0)
              xmlFreeCatalogEntry((uint64_t)v36);
            xmlFree(v34);
          }
        }
        goto LABEL_93;
      }
      while (v19 <= 0x20u && ((1 << v19) & 0x100002600) != 0)
      {
        v21 = *++a2;
        LOBYTE(v19) = v21;
      }
LABEL_77:
      v32 = xmlParseSGMLCatalogPubid(a2, &cura);
      if (!v32)
      {
LABEL_105:
        if (str1)
          xmlFree(str1);
        a2 = 0;
        v11 = cura;
        if (cura)
        {
LABEL_108:
          xmlFree(v11);
          break;
        }
        break;
      }
      a2 = v32;
      v30 = v42;
      if (v42 != 21)
        goto LABEL_82;
      if (v7)
        xmlFree(v7);
      v7 = xmlStrdup(cura);
LABEL_93:
      if (str1)
        xmlFree(str1);
LABEL_95:
      if (cura)
        xmlFree(cura);
    }
    else
    {
      if (xmlStrEqual(v11, (const xmlChar *)"PUBLIC"))
      {
        v17 = 14;
        goto LABEL_43;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"DELEGATE"))
      {
        v17 = 20;
        goto LABEL_43;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"ENTITY"))
      {
        xmlFree(v11);
        str1 = 0;
        if (*a2 == 37)
          v25 = 16;
        else
          v25 = 15;
        v42 = v25;
        goto LABEL_65;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"DOCTYPE"))
      {
        v26 = 17;
        goto LABEL_64;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"LINKTYPE"))
      {
        v26 = 18;
        goto LABEL_64;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"NOTATION"))
      {
        v26 = 19;
LABEL_64:
        v42 = v26;
        xmlFree(v11);
        str1 = 0;
LABEL_65:
        v27 = xmlParseSGMLCatalogName(a2, &str1);
        if (!v27)
          goto LABEL_105;
        a2 = v27;
        v28 = *v27;
        if (v28 > 0x20 || ((1 << v28) & 0x100002600) == 0)
          goto LABEL_71;
        while (v28 <= 0x20u && ((1 << v28) & 0x100002600) != 0)
        {
          v29 = *++a2;
          LOBYTE(v28) = v29;
        }
        goto LABEL_77;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"SGMLDECL"))
      {
        v31 = 24;
LABEL_76:
        v42 = v31;
        xmlFree(v11);
        str1 = 0;
        goto LABEL_77;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"DOCUMENT"))
      {
        v31 = 23;
        goto LABEL_76;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"CATALOG"))
      {
        v31 = 22;
        goto LABEL_76;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"BASE"))
      {
        v31 = 21;
        goto LABEL_76;
      }
      v16 = xmlStrEqual(v11, (const xmlChar *)"OVERRIDE");
      xmlFree(v11);
      if (!v16)
        goto LABEL_95;
      a2 = xmlParseSGMLCatalogName(a2, &str1);
      if (!str1)
        break;
      xmlFree(str1);
      if (!a2)
        break;
    }
  }
LABEL_100:
  if (v7)
    xmlFree(v7);
  if (a2)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

xmlCatalogPtr xmlLoadACatalog(const char *filename)
{
  char *FileContent;
  unsigned __int8 *v3;
  char *v4;
  int v5;
  xmlCatalog *NewCatalog;
  xmlCatalog *v7;

  FileContent = xmlLoadFileContent((char *)filename);
  if (!FileContent)
    return 0;
  v3 = (unsigned __int8 *)FileContent;
  v4 = FileContent;
  while (1)
  {
    v5 = *v4;
    if (!*v4 || v5 == 45)
    {
LABEL_7:
      NewCatalog = (xmlCatalog *)xmlCreateNewCatalog(2, xmlCatalogDefaultPrefer);
      v7 = NewCatalog;
      if (NewCatalog && (xmlParseSGMLCatalog((uint64_t)NewCatalog, v3, (xmlChar *)filename, 0) & 0x80000000) != 0)
      {
        xmlFreeCatalog(v7);
        v7 = 0;
      }
      goto LABEL_13;
    }
    if (v5 == 60)
      break;
    ++v4;
    if ((v5 & 0xFFFFFFDF) - 65 <= 0x19)
      goto LABEL_7;
  }
  v7 = (xmlCatalog *)xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
  if (v7)
    *((_QWORD *)v7 + 14) = xmlNewCatalogEntry(1, 0, 0, (xmlChar *)filename, xmlCatalogDefaultPrefer, 0);
LABEL_13:
  xmlFree(v3);
  return v7;
}

_QWORD *xmlNewCatalogEntry(int a1, xmlChar *a2, const xmlChar *a3, xmlChar *a4, int a5, uint64_t a6)
{
  _QWORD *v12;
  _QWORD *v13;
  xmlChar *v14;
  xmlChar *v15;
  xmlChar *v16;
  xmlChar *v17;
  xmlChar *v18;

  v12 = xmlMalloc(0x50uLL);
  v13 = v12;
  if (!v12)
  {
    xmlCatalogErrMemory((const xmlChar *)"allocating catalog entry");
    return v13;
  }
  *v12 = 0;
  v12[1] = 0;
  v12[2] = 0;
  *((_DWORD *)v12 + 6) = a1;
  if (a1 == 8 || a1 == 5)
  {
    v14 = xmlCatalogNormalizePublic(a2);
    if (v14)
    {
      v15 = v14;
      if (!*v14)
      {
        v16 = 0;
        goto LABEL_11;
      }
      a2 = v14;
      goto LABEL_9;
    }
  }
  v15 = 0;
  v16 = 0;
  if (a2)
LABEL_9:
    v16 = xmlStrdup(a2);
LABEL_11:
  v13[4] = v16;
  if (v15)
    xmlFree(v15);
  if (a3)
    v17 = xmlStrdup(a3);
  else
    v17 = 0;
  v13[5] = v17;
  if (a4)
    v18 = a4;
  else
    v18 = (xmlChar *)a3;
  if (v18)
    v18 = xmlStrdup(v18);
  v13[6] = v18;
  *((_DWORD *)v13 + 15) = 0;
  *((_DWORD *)v13 + 16) = 0;
  *((_DWORD *)v13 + 14) = a5;
  v13[9] = a6;
  return v13;
}

xmlChar *__cdecl xmlACatalogResolveSystem(xmlCatalogPtr catal, const xmlChar *sysID)
{
  xmlChar *result;
  xmlGenericErrorFunc v5;
  void **v6;

  result = 0;
  if (catal && sysID)
  {
    if (xmlDebugCatalogs)
    {
      v5 = *__xmlGenericError();
      v6 = __xmlGenericErrorContext();
      v5(*v6, "Resolve sysID %s\n", (const char *)sysID);
    }
    if (*(_DWORD *)catal == 1)
    {
      result = (xmlChar *)xmlCatalogListXMLResolve(*((_QWORD *)catal + 14), 0, (uint64_t)sysID);
      if (result == (xmlChar *)-1)
        return 0;
    }
    else
    {
      result = (xmlChar *)*((_QWORD *)catal + 12);
      if (result)
      {
        result = (xmlChar *)xmlHashLookup((xmlHashTablePtr)result, sysID);
        if (result)
        {
          if (*((_DWORD *)result + 6) == 13)
          {
            result = (xmlChar *)*((_QWORD *)result + 6);
            if (result)
              return xmlStrdup(result);
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t xmlCatalogListXMLResolve(uint64_t a1, xmlChar *a2, uint64_t a3)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  xmlChar *v7;
  xmlChar *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  const xmlChar *v18;
  int v19;
  xmlGenericErrorFunc v20;
  void **v21;
  xmlChar *v22;
  xmlChar *v23;
  int v24;
  uint64_t v25;
  int v26;
  const xmlChar *v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  const xmlChar *v32;
  int v33;
  const xmlChar **v34;
  uint64_t v35;
  uint64_t v36;
  xmlGenericErrorFunc v37;
  void **v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  const xmlChar *v46;
  int v47;
  const xmlChar **v48;
  uint64_t v49;
  uint64_t v50;
  xmlGenericErrorFunc v51;
  void **v52;
  xmlGenericErrorFunc v53;
  void **v54;
  const xmlChar *v55;
  xmlGenericErrorFunc v56;
  void **v57;
  xmlChar *v58;
  xmlGenericErrorFunc v59;
  void *v60;
  xmlGenericErrorFunc v61;
  void *v62;
  const char *v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  xmlChar *v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v4 = (const char *)a2;
  if (!((unint64_t)a2 | a3))
    return 0;
  v6 = a1;
  v7 = xmlCatalogNormalizePublic(a2);
  v8 = v7;
  if (v7)
  {
    if (*v7)
      v4 = (const char *)v7;
    else
      v4 = 0;
  }
  if (!xmlStrncmp((const xmlChar *)v4, (const xmlChar *)"urn:publicid:", 13))
  {
    v58 = xmlCatalogUnWrapURN((uint64_t)v4);
    if (xmlDebugCatalogs)
    {
      v59 = *__xmlGenericError();
      v60 = *__xmlGenericErrorContext();
      if (!v58)
      {
        v59(v60, "Public URN ID %s expanded to NULL\n", v4);
        v5 = xmlCatalogListXMLResolve(v6, 0, a3);
        goto LABEL_135;
      }
      v59(v60, "Public URN ID expanded to %s\n", (const char *)v58);
      v5 = xmlCatalogListXMLResolve(v6, v58, a3);
LABEL_134:
      xmlFree(v58);
      goto LABEL_135;
    }
    v64 = v6;
    v65 = v58;
    v66 = a3;
    goto LABEL_133;
  }
  if (!xmlStrncmp((const xmlChar *)a3, (const xmlChar *)"urn:publicid:", 13))
  {
    v58 = xmlCatalogUnWrapURN(a3);
    if (xmlDebugCatalogs)
    {
      v61 = *__xmlGenericError();
      v62 = *__xmlGenericErrorContext();
      if (v58)
        v63 = "System URN ID expanded to %s\n";
      else
        v63 = "System URN ID %s expanded to NULL\n";
      v61(v62, v63);
    }
    if (!v4)
    {
      v64 = v6;
      v65 = v58;
      goto LABEL_131;
    }
    if (xmlStrEqual((const xmlChar *)v4, v58))
    {
      v64 = v6;
      v65 = (void *)v4;
LABEL_131:
      v66 = 0;
      goto LABEL_133;
    }
    v64 = v6;
    v65 = (void *)v4;
    v66 = (uint64_t)v58;
LABEL_133:
    v5 = xmlCatalogListXMLResolve(v64, v65, v66);
    if (!v58)
      goto LABEL_135;
    goto LABEL_134;
  }
  v68 = v8;
  while (1)
  {
    if (*(_DWORD *)(v6 + 24) == 1)
    {
      v9 = *(_QWORD *)(v6 + 16);
      if (v9)
        break;
      xmlFetchXMLCatalogFile(v6);
      v9 = *(_QWORD *)(v6 + 16);
      if (v9)
        break;
    }
LABEL_114:
    v6 = *(_QWORD *)v6;
    if (!v6)
    {
LABEL_115:
      v5 = 0;
      goto LABEL_116;
    }
  }
  v10 = *(_DWORD *)(v9 + 64);
  if (v10 >= 51)
  {
    __xmlRaiseError(0, 0, 0, (_QWORD *)v9, 0, 0x14u, 1654, 2, 0, 0, *(const xmlChar **)(v9 + 32), 0, 0, 0, 0, "Detected recursion in catalog %s\n", *(_QWORD *)(v9 + 32));
    goto LABEL_113;
  }
  *(_DWORD *)(v9 + 64) = v10 + 1;
  if (a3)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = v9;
    while (2)
    {
      switch(*(_DWORD *)(v15 + 24))
      {
        case 3:
          ++v13;
          goto LABEL_28;
        case 6:
          if (!xmlStrEqual((const xmlChar *)a3, *(const xmlChar **)(v15 + 32)))
            goto LABEL_28;
          if (xmlDebugCatalogs)
          {
            v53 = *__xmlGenericError();
            v54 = __xmlGenericErrorContext();
            v53(*v54, "Found system match %s, using %s\n", *(const char **)(v15 + 32), *(const char **)(v15 + 48));
          }
          --*(_DWORD *)(v9 + 64);
          v55 = *(const xmlChar **)(v15 + 48);
          goto LABEL_111;
        case 7:
          v16 = xmlStrlen(*(const xmlChar **)(v15 + 32));
          if (v16 > v11)
          {
            v17 = v16;
            if (!xmlStrncmp((const xmlChar *)a3, *(const xmlChar **)(v15 + 32), v16))
            {
              v12 = v15;
              v11 = v17;
            }
          }
          goto LABEL_28;
        case 9:
          v18 = *(const xmlChar **)(v15 + 32);
          v19 = xmlStrlen(v18);
          if (!xmlStrncmp((const xmlChar *)a3, v18, v19))
            ++v14;
          goto LABEL_28;
        default:
LABEL_28:
          v15 = *(_QWORD *)v15;
          if (v15)
            continue;
          if (v12)
          {
            if (xmlDebugCatalogs)
            {
              v20 = *__xmlGenericError();
              v21 = __xmlGenericErrorContext();
              v20(*v21, "Using rewriting rule %s\n", *(const char **)(v12 + 32));
            }
            v22 = xmlStrdup(*(const xmlChar **)(v12 + 48));
            if (!v22)
            {
              v5 = 0;
LABEL_104:
              --*(_DWORD *)(v9 + 64);
LABEL_112:
              if (v5)
                goto LABEL_116;
LABEL_113:
              if (*(int *)(*(_QWORD *)(v6 + 16) + 64) > 50)
                goto LABEL_115;
              goto LABEL_114;
            }
            v23 = xmlStrcat(v22, (const xmlChar *)(a3 + v11));
LABEL_34:
            v5 = (uint64_t)v23;
            goto LABEL_104;
          }
          if (v14)
          {
            v43 = 0;
            v92 = 0u;
            v93 = 0u;
            v90 = 0u;
            v91 = 0u;
            v88 = 0u;
            v89 = 0u;
            v86 = 0u;
            v87 = 0u;
            v84 = 0u;
            v85 = 0u;
            v82 = 0u;
            v83 = 0u;
            v80 = 0u;
            v81 = 0u;
            v78 = 0u;
            v79 = 0u;
            v76 = 0u;
            v77 = 0u;
            v74 = 0u;
            v75 = 0u;
            v72 = 0u;
            v73 = 0u;
            v70 = 0u;
            v71 = 0u;
            v44 = v9;
            v69 = 0u;
            while (1)
            {
              v45 = v44;
LABEL_83:
              if (*(_DWORD *)(v45 + 24) == 9)
              {
                v46 = *(const xmlChar **)(v45 + 32);
                v47 = xmlStrlen(v46);
                if (!xmlStrncmp((const xmlChar *)a3, v46, v47))
                {
                  if (v43 < 1)
                  {
                    v45 = v44;
                  }
                  else
                  {
                    v48 = (const xmlChar **)&v69;
                    v49 = v43;
                    do
                    {
                      if (xmlStrEqual(*(const xmlChar **)(v45 + 48), *v48))
                      {
                        v45 = *(_QWORD *)v45;
                        if (v45)
                          goto LABEL_83;
                        goto LABEL_102;
                      }
                      ++v48;
                      --v49;
                    }
                    while (v49);
                    if (v43 > 49)
                      goto LABEL_94;
                  }
                  *((_QWORD *)&v69 + v43++) = *(_QWORD *)(v45 + 48);
LABEL_94:
                  v50 = *(_QWORD *)(v45 + 16);
                  if (v50 || (xmlFetchXMLCatalogFile(v45), (v50 = *(_QWORD *)(v45 + 16)) != 0))
                  {
                    if (xmlDebugCatalogs)
                    {
                      v51 = *__xmlGenericError();
                      v52 = __xmlGenericErrorContext();
                      v51(*v52, "Trying system delegate %s\n", *(const char **)(v45 + 48));
                      v50 = *(_QWORD *)(v45 + 16);
                    }
                    v23 = (xmlChar *)xmlCatalogListXMLResolve(v50, 0, a3);
                    if (v23)
                      goto LABEL_34;
                  }
                }
              }
              v44 = *(_QWORD *)v45;
              if (!*(_QWORD *)v45)
                goto LABEL_102;
            }
          }
          break;
      }
      break;
    }
  }
  else
  {
    v13 = 0;
  }
  if (v4)
  {
    v24 = 0;
    v25 = v9;
    do
    {
      v26 = *(_DWORD *)(v25 + 24);
      if (v26 == 3)
      {
        v13 += a3 == 0;
      }
      else if (v26 == 8)
      {
        v27 = *(const xmlChar **)(v25 + 32);
        v28 = xmlStrlen(v27);
        if (!xmlStrncmp((const xmlChar *)v4, v27, v28) && *(_DWORD *)(v25 + 56) == 1)
          ++v24;
      }
      else if (v26 == 5 && xmlStrEqual((const xmlChar *)v4, *(const xmlChar **)(v25 + 32)))
      {
        if (xmlDebugCatalogs)
        {
          v56 = *__xmlGenericError();
          v57 = __xmlGenericErrorContext();
          v56(*v57, "Found public match %s\n", *(const char **)(v25 + 32));
        }
        --*(_DWORD *)(v9 + 64);
        v55 = *(const xmlChar **)(v25 + 48);
LABEL_111:
        v5 = (uint64_t)xmlStrdup(v55);
        goto LABEL_112;
      }
      v25 = *(_QWORD *)v25;
    }
    while (v25);
    if (v24)
    {
      v92 = 0u;
      v93 = 0u;
      v90 = 0u;
      v91 = 0u;
      v88 = 0u;
      v89 = 0u;
      v86 = 0u;
      v87 = 0u;
      v84 = 0u;
      v85 = 0u;
      v82 = 0u;
      v83 = 0u;
      v80 = 0u;
      v81 = 0u;
      v78 = 0u;
      v79 = 0u;
      v76 = 0u;
      v77 = 0u;
      v74 = 0u;
      v75 = 0u;
      v72 = 0u;
      v73 = 0u;
      v70 = 0u;
      v71 = 0u;
      v69 = 0u;
      v29 = 0;
      v30 = v9;
      while (1)
      {
        v31 = v30;
LABEL_51:
        if (*(_DWORD *)(v31 + 24) == 8 && *(_DWORD *)(v31 + 56) == 1)
        {
          v32 = *(const xmlChar **)(v31 + 32);
          v33 = xmlStrlen(v32);
          if (!xmlStrncmp((const xmlChar *)v4, v32, v33))
          {
            if (v29 < 1)
            {
              v31 = v30;
            }
            else
            {
              v34 = (const xmlChar **)&v69;
              v35 = v29;
              do
              {
                if (xmlStrEqual(*(const xmlChar **)(v31 + 48), *v34))
                {
                  v31 = *(_QWORD *)v31;
                  if (v31)
                    goto LABEL_51;
                  goto LABEL_102;
                }
                ++v34;
                --v35;
              }
              while (v35);
              if (v29 > 49)
                goto LABEL_63;
            }
            *((_QWORD *)&v69 + v29++) = *(_QWORD *)(v31 + 48);
LABEL_63:
            v36 = *(_QWORD *)(v31 + 16);
            if (v36 || (xmlFetchXMLCatalogFile(v31), (v36 = *(_QWORD *)(v31 + 16)) != 0))
            {
              if (xmlDebugCatalogs)
              {
                v37 = *__xmlGenericError();
                v38 = __xmlGenericErrorContext();
                v37(*v38, "Trying public delegate %s\n", *(const char **)(v31 + 48));
                v36 = *(_QWORD *)(v31 + 16);
              }
              v23 = (xmlChar *)xmlCatalogListXMLResolve(v36, v4, 0);
              if (v23)
                goto LABEL_34;
            }
          }
        }
        v30 = *(_QWORD *)v31;
        if (!*(_QWORD *)v31)
        {
LABEL_102:
          v5 = -1;
          goto LABEL_104;
        }
      }
    }
  }
  if (!v13)
  {
LABEL_79:
    --*(_DWORD *)(v9 + 64);
    goto LABEL_113;
  }
  v39 = v9;
  while (1)
  {
    if (*(_DWORD *)(v39 + 24) == 3)
    {
      v40 = *(_QWORD *)(v39 + 16);
      if (v40)
        break;
      xmlFetchXMLCatalogFile(v39);
      v40 = *(_QWORD *)(v39 + 16);
      if (v40)
        break;
    }
LABEL_78:
    v39 = *(_QWORD *)v39;
    if (!v39)
      goto LABEL_79;
  }
  v41 = xmlCatalogListXMLResolve(v40, v4, a3);
  v42 = *(_DWORD *)(v9 + 64);
  if (!v41)
  {
    if (v42 > 50)
      goto LABEL_113;
    goto LABEL_78;
  }
  v5 = v41;
  *(_DWORD *)(v9 + 64) = v42 - 1;
LABEL_116:
  v8 = v68;
LABEL_135:
  if (v8)
    xmlFree(v8);
  return v5;
}

xmlChar *__cdecl xmlACatalogResolvePublic(xmlCatalogPtr catal, const xmlChar *pubID)
{
  xmlChar *result;
  xmlGenericErrorFunc v5;
  void **v6;

  result = 0;
  if (catal && pubID)
  {
    if (xmlDebugCatalogs)
    {
      v5 = *__xmlGenericError();
      v6 = __xmlGenericErrorContext();
      v5(*v6, "Resolve pubID %s\n", (const char *)pubID);
    }
    if (*(_DWORD *)catal == 1)
    {
      result = (xmlChar *)xmlCatalogListXMLResolve(*((_QWORD *)catal + 14), (xmlChar *)pubID, 0);
      if (result == (xmlChar *)-1)
        return 0;
    }
    else
    {
      result = (xmlChar *)xmlCatalogGetSGMLPublic(*((xmlHashTable **)catal + 12), (xmlChar *)pubID);
      if (result)
        return xmlStrdup(result);
    }
  }
  return result;
}

xmlHashTable *xmlCatalogGetSGMLPublic(xmlHashTable *result, xmlChar *cur)
{
  xmlHashTable *v3;
  xmlChar *v4;
  xmlChar *v5;
  const xmlChar *v6;
  xmlHashTable *v7;
  xmlHashTable *v8;
  int v9;

  if (result)
  {
    v3 = result;
    v4 = xmlCatalogNormalizePublic(cur);
    if (v4)
    {
      v5 = v4;
      if (*v4)
        v6 = v4;
      else
        v6 = 0;
      v7 = (xmlHashTable *)xmlHashLookup(v3, v6);
      if (!v7)
      {
        xmlFree(v5);
        return 0;
      }
      v8 = v7;
      v9 = *((_DWORD *)v7 + 6);
      xmlFree(v5);
      if (v9 != 14)
        return 0;
    }
    else
    {
      result = (xmlHashTable *)xmlHashLookup(v3, cur);
      if (!result)
        return result;
      v8 = result;
      if (*((_DWORD *)result + 6) != 14)
        return 0;
    }
    return (xmlHashTable *)*((_QWORD *)v8 + 6);
  }
  return result;
}

xmlChar *__cdecl xmlACatalogResolve(xmlCatalogPtr catal, const xmlChar *pubID, const xmlChar *sysID)
{
  xmlChar *result;
  xmlGenericErrorFunc v7;
  void *v8;
  const char *v9;

  result = 0;
  if (catal && (unint64_t)pubID | (unint64_t)sysID)
  {
    if (xmlDebugCatalogs)
    {
      v7 = *__xmlGenericError();
      v8 = *__xmlGenericErrorContext();
      if (pubID && sysID)
      {
        v9 = "Resolve: pubID %s sysID %s\n";
      }
      else if (pubID)
      {
        v9 = "Resolve: pubID %s\n";
      }
      else
      {
        v9 = "Resolve: sysID %s\n";
      }
      v7(v8, v9);
    }
    if (*(_DWORD *)catal == 1)
    {
      result = (xmlChar *)xmlCatalogListXMLResolve(*((_QWORD *)catal + 14), (xmlChar *)pubID, (uint64_t)sysID);
      if (result == (xmlChar *)-1)
        return 0;
    }
    else
    {
      result = (xmlChar *)xmlCatalogSGMLResolve((uint64_t)catal, (xmlChar *)pubID, (xmlChar *)sysID);
      if (result)
        return xmlStrdup(result);
    }
  }
  return result;
}

xmlHashTable *xmlCatalogSGMLResolve(uint64_t a1, xmlChar *a2, xmlChar *name)
{
  xmlHashTable *result;

  result = *(xmlHashTable **)(a1 + 96);
  if (result)
  {
    if (!a2 || (result = xmlCatalogGetSGMLPublic(result, a2)) == 0)
    {
      if (!name)
        return 0;
      result = *(xmlHashTable **)(a1 + 96);
      if (result)
      {
        result = (xmlHashTable *)xmlHashLookup(result, name);
        if (result)
        {
          if (*((_DWORD *)result + 6) == 13)
            return (xmlHashTable *)*((_QWORD *)result + 6);
          return 0;
        }
      }
    }
  }
  return result;
}

xmlChar *__cdecl xmlACatalogResolveURI(xmlCatalogPtr catal, const xmlChar *URI)
{
  xmlChar *result;
  xmlGenericErrorFunc v5;
  void **v6;

  result = 0;
  if (catal && URI)
  {
    if (xmlDebugCatalogs)
    {
      v5 = *__xmlGenericError();
      v6 = __xmlGenericErrorContext();
      v5(*v6, "Resolve URI %s\n", (const char *)URI);
    }
    if (*(_DWORD *)catal == 1)
    {
      result = (xmlChar *)xmlCatalogListXMLResolveURI(*((_QWORD *)catal + 14), (const char *)URI);
      if (result == (xmlChar *)-1)
        return 0;
    }
    else
    {
      result = (xmlChar *)xmlCatalogSGMLResolve((uint64_t)catal, 0, (xmlChar *)URI);
      if (result)
        return xmlStrdup(result);
    }
  }
  return result;
}

uint64_t xmlCatalogListXMLResolveURI(uint64_t a1, const char *a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  const xmlChar *v12;
  int v13;
  xmlGenericErrorFunc v14;
  void **v15;
  xmlChar *v16;
  xmlChar *v17;
  int v18;
  uint64_t v19;
  int v20;
  const xmlChar *v22;
  int v23;
  const xmlChar **v24;
  uint64_t v25;
  uint64_t v26;
  xmlGenericErrorFunc v27;
  void **v28;
  xmlGenericErrorFunc v29;
  void **v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  xmlChar *v34;
  xmlGenericErrorFunc v35;
  void *v36;
  _OWORD v38[25];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v3 = a1;
  if (!xmlStrncmp((const xmlChar *)a2, (const xmlChar *)"urn:publicid:", 13))
  {
    v34 = xmlCatalogUnWrapURN((uint64_t)a2);
    if (!xmlDebugCatalogs)
    {
      v31 = xmlCatalogListXMLResolve(v3, v34, 0);
      if (!v34)
        return v31;
LABEL_70:
      xmlFree(v34);
      return v31;
    }
    v35 = *__xmlGenericError();
    v36 = *__xmlGenericErrorContext();
    if (v34)
    {
      v35(v36, "URN ID expanded to %s\n", (const char *)v34);
      v31 = xmlCatalogListXMLResolve(v3, v34, 0);
      goto LABEL_70;
    }
    v35(v36, "URN ID %s expanded to NULL\n", a2);
    return 0;
  }
LABEL_3:
  if (*(_DWORD *)(v3 + 24) != 1)
    goto LABEL_56;
  v4 = *(_QWORD *)(v3 + 16);
  if (!v4)
  {
    xmlFetchXMLCatalogFile(v3);
    v4 = *(_QWORD *)(v3 + 16);
    if (!v4)
      goto LABEL_56;
  }
  if (*(int *)(v4 + 64) > 50)
  {
    __xmlRaiseError(0, 0, 0, (_QWORD *)v4, 0, 0x14u, 1654, 2, 0, 0, *(const xmlChar **)(v4 + 32), 0, 0, 0, 0, "Detected recursion in catalog %s\n", *(_QWORD *)(v4 + 32));
    goto LABEL_56;
  }
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = v4;
  while (2)
  {
    switch(*(_DWORD *)(v9 + 24))
    {
      case 3:
        ++v7;
        goto LABEL_19;
      case 0xA:
        if (!xmlStrEqual((const xmlChar *)a2, *(const xmlChar **)(v9 + 32)))
          goto LABEL_19;
        if (xmlDebugCatalogs)
        {
          v29 = *__xmlGenericError();
          v30 = __xmlGenericErrorContext();
          v29(*v30, "Found URI match %s\n", *(const char **)(v9 + 32));
        }
        v17 = xmlStrdup(*(const xmlChar **)(v9 + 48));
        goto LABEL_54;
      case 0xB:
        v10 = xmlStrlen(*(const xmlChar **)(v9 + 32));
        if (v10 > v5)
        {
          v11 = v10;
          if (!xmlStrncmp((const xmlChar *)a2, *(const xmlChar **)(v9 + 32), v10))
          {
            v6 = v9;
            v5 = v11;
          }
        }
        goto LABEL_19;
      case 0xC:
        v12 = *(const xmlChar **)(v9 + 32);
        v13 = xmlStrlen(v12);
        if (!xmlStrncmp((const xmlChar *)a2, v12, v13))
          ++v8;
        goto LABEL_19;
      default:
LABEL_19:
        v9 = *(_QWORD *)v9;
        if (v9)
          continue;
        if (v6)
        {
          if (xmlDebugCatalogs)
          {
            v14 = *__xmlGenericError();
            v15 = __xmlGenericErrorContext();
            v14(*v15, "Using rewriting rule %s\n", *(const char **)(v6 + 32));
          }
          v16 = xmlStrdup(*(const xmlChar **)(v6 + 48));
          if (!v16)
            goto LABEL_56;
          v17 = xmlStrcat(v16, (const xmlChar *)&a2[v5]);
          goto LABEL_54;
        }
        if (v8)
        {
          v18 = 0;
          memset(v38, 0, sizeof(v38));
          while (1)
          {
            v19 = v4;
LABEL_28:
            v20 = *(_DWORD *)(v19 + 24);
            if (v20 == 12 || v20 == 9)
            {
              v22 = *(const xmlChar **)(v19 + 32);
              v23 = xmlStrlen(v22);
              if (!xmlStrncmp((const xmlChar *)a2, v22, v23))
              {
                if (v18 < 1)
                {
                  v19 = v4;
                }
                else
                {
                  v24 = (const xmlChar **)v38;
                  v25 = v18;
                  do
                  {
                    if (xmlStrEqual(*(const xmlChar **)(v19 + 48), *v24))
                    {
                      v19 = *(_QWORD *)v19;
                      if (v19)
                        goto LABEL_28;
                      goto LABEL_58;
                    }
                    ++v24;
                    --v25;
                  }
                  while (v25);
                  if (v18 > 49)
                    goto LABEL_43;
                }
                *((_QWORD *)v38 + v18++) = *(_QWORD *)(v19 + 48);
LABEL_43:
                v26 = *(_QWORD *)(v19 + 16);
                if (v26 || (xmlFetchXMLCatalogFile(v19), (v26 = *(_QWORD *)(v19 + 16)) != 0))
                {
                  if (xmlDebugCatalogs)
                  {
                    v27 = *__xmlGenericError();
                    v28 = __xmlGenericErrorContext();
                    v27(*v28, "Trying URI delegate %s\n", *(const char **)(v19 + 48));
                    v26 = *(_QWORD *)(v19 + 16);
                  }
                  v17 = (xmlChar *)xmlCatalogListXMLResolveURI(v26, a2);
                  if (v17)
                    break;
                }
              }
            }
            v4 = *(_QWORD *)v19;
            if (!*(_QWORD *)v19)
            {
LABEL_58:
              v31 = -1;
              goto LABEL_55;
            }
          }
LABEL_54:
          v31 = (uint64_t)v17;
LABEL_55:
          if (v31)
            return v31;
LABEL_56:
          v3 = *(_QWORD *)v3;
          if (!v3)
            return 0;
          goto LABEL_3;
        }
        if (!v7)
          goto LABEL_56;
        while (1)
        {
          if (*(_DWORD *)(v4 + 24) == 3)
          {
            v32 = *(_QWORD *)(v4 + 16);
            if (v32 || (xmlFetchXMLCatalogFile(v4), (v32 = *(_QWORD *)(v4 + 16)) != 0))
            {
              v33 = xmlCatalogListXMLResolveURI(v32, a2);
              if (v33)
                return v33;
            }
          }
          v4 = *(_QWORD *)v4;
          if (!v4)
            goto LABEL_56;
        }
    }
  }
}

void xmlACatalogDump(xmlCatalogPtr catal, FILE *out)
{
  xmlNode *v3;
  xmlDoc *v4;
  xmlNode *v5;
  xmlNode *v6;
  xmlNs *v7;
  xmlNs *v8;
  xmlNodePtr v9;
  xmlNode *v10;
  xmlOutputBuffer *File;

  if (catal && out)
  {
    if (*(_DWORD *)catal == 1)
    {
      v3 = (xmlNode *)*((_QWORD *)catal + 14);
      v4 = xmlNewDoc(0);
      if (v4)
      {
        v5 = (xmlNode *)v4;
        v6 = (xmlNode *)xmlNewDtd(v4, (const xmlChar *)"catalog", (const xmlChar *)"-//OASIS//DTD Entity Resolution XML Catalog V1.0//EN", (const xmlChar *)"http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd");
        xmlAddChild(v5, v6);
        v7 = xmlNewNs(0, (const xmlChar *)"urn:oasis:names:tc:entity:xmlns:xml:catalog", 0);
        if (v7)
        {
          v8 = v7;
          v9 = xmlNewDocNode((xmlDocPtr)v5, v7, (const xmlChar *)"catalog", 0);
          if (v9)
          {
            v10 = v9;
            v9->nsDef = v8;
            xmlAddChild(v5, v9);
            xmlDumpXMLCatalogNode(v3, v10, (xmlDoc *)v5, v8, 0);
            File = xmlOutputBufferCreateFile(out, 0);
            if (File)
              xmlSaveFormatFileTo(File, (xmlDocPtr)v5, 0, 1);
          }
          else
          {
            xmlFreeNs(v8);
          }
        }
        xmlFreeDoc((xmlDocPtr)v5);
      }
    }
    else
    {
      xmlHashScan(*((xmlHashTablePtr *)catal + 12), (xmlHashScanner)xmlCatalogDumpEntry, out);
    }
  }
}

uint64_t xmlCatalogDumpEntry(uint64_t result, FILE *__stream)
{
  uint64_t v3;
  const char *v4;
  size_t v5;
  unsigned int v6;
  int v7;

  if (result && __stream)
  {
    v3 = result;
    switch(*(_DWORD *)(result + 24))
    {
      case 0xD:
        v4 = "SYSTEM ";
        goto LABEL_8;
      case 0xE:
        v4 = "PUBLIC ";
        goto LABEL_8;
      case 0xF:
        v4 = "ENTITY ";
LABEL_8:
        v5 = 7;
        goto LABEL_20;
      case 0x10:
        fprintf(__stream, "ENTITY %%");
        goto LABEL_21;
      case 0x11:
        v4 = "DOCTYPE ";
        goto LABEL_16;
      case 0x12:
        v4 = "LINKTYPE ";
        goto LABEL_19;
      case 0x13:
        v4 = "NOTATION ";
        goto LABEL_19;
      case 0x14:
        v4 = "DELEGATE ";
        goto LABEL_19;
      case 0x15:
        v4 = "BASE ";
        v5 = 5;
        goto LABEL_20;
      case 0x16:
        v4 = "CATALOG ";
LABEL_16:
        v5 = 8;
        goto LABEL_20;
      case 0x17:
        v4 = "DOCUMENT ";
        goto LABEL_19;
      case 0x18:
        v4 = "SGMLDECL ";
LABEL_19:
        v5 = 9;
LABEL_20:
        fwrite(v4, v5, 1uLL, __stream);
LABEL_21:
        v6 = *(_DWORD *)(v3 + 24);
        if (v6 <= 0x18)
        {
          v7 = 1 << v6;
          if ((v7 & 0x1F06000) != 0)
          {
            fprintf(__stream, "\"%s\"", *(const char **)(v3 + 32));
          }
          else if ((v7 & 0xF8000) != 0)
          {
            fputs(*(const char **)(v3 + 32), __stream);
          }
        }
        if ((*(_DWORD *)(v3 + 24) - 13) <= 7)
          fprintf(__stream, " \"%s\"", *(const char **)(v3 + 40));
        result = fputc(10, __stream);
        break;
      default:
        return result;
    }
  }
  return result;
}

int xmlACatalogAdd(xmlCatalogPtr catal, const xmlChar *type, const xmlChar *orig, const xmlChar *replace)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  int v12;
  _QWORD *v13;
  xmlHashTable *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  xmlGenericErrorFunc v18;
  void **v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  xmlGenericErrorFunc v23;
  void **v24;
  void *v25;
  void *v26;
  xmlChar *v27;
  xmlGenericErrorFunc v28;
  void **v29;

  if (!catal)
    goto LABEL_77;
  if (*(_DWORD *)catal != 1)
  {
    if (xmlStrEqual(type, (const xmlChar *)"SYSTEM"))
    {
      v12 = 13;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"PUBLIC"))
    {
      v12 = 14;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"DELEGATE"))
    {
      v12 = 20;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"ENTITY"))
    {
      v12 = 15;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"DOCTYPE"))
    {
      v12 = 17;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"LINKTYPE"))
    {
      v12 = 18;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"NOTATION"))
    {
      v12 = 19;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"SGMLDECL"))
    {
      v12 = 24;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"DOCUMENT"))
    {
      v12 = 23;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"CATALOG"))
    {
      v12 = 22;
    }
    else
    {
      if (!xmlStrEqual(type, (const xmlChar *)"BASE"))
      {
LABEL_77:
        LODWORD(v15) = -1;
        return (int)v15;
      }
      v12 = 21;
    }
    v13 = xmlNewCatalogEntry(v12, (xmlChar *)orig, replace, 0, 0, 0);
    v14 = (xmlHashTable *)*((_QWORD *)catal + 12);
    if (!v14)
    {
      v14 = xmlHashCreate(10);
      *((_QWORD *)catal + 12) = v14;
    }
    LODWORD(v15) = xmlHashAddEntry(v14, orig, v13);
    return (int)v15;
  }
  v8 = *((_QWORD *)catal + 14);
  if (!v8 || (*(_DWORD *)(v8 + 24) - 1) > 1)
    goto LABEL_77;
  v9 = (uint64_t *)(v8 + 16);
  v10 = *(_QWORD *)(v8 + 16);
  if (!v10)
  {
    xmlFetchXMLCatalogFile(v8);
    v10 = *(_QWORD *)(v8 + 16);
  }
  if (xmlStrEqual(type, (const xmlChar *)"system"))
  {
    v11 = 6;
    goto LABEL_52;
  }
  if (xmlStrEqual(type, (const xmlChar *)"public"))
  {
    v11 = 5;
    goto LABEL_52;
  }
  if (xmlStrEqual(type, (const xmlChar *)"rewriteSystem"))
  {
    v11 = 7;
    goto LABEL_52;
  }
  if (xmlStrEqual(type, (const xmlChar *)"delegatePublic"))
  {
    v11 = 8;
    goto LABEL_52;
  }
  if (xmlStrEqual(type, (const xmlChar *)"delegateSystem"))
  {
    v11 = 9;
    goto LABEL_52;
  }
  if (xmlStrEqual(type, (const xmlChar *)"uri"))
  {
    v11 = 10;
    goto LABEL_52;
  }
  if (xmlStrEqual(type, (const xmlChar *)"rewriteURI"))
  {
    v11 = 11;
    goto LABEL_52;
  }
  if (xmlStrEqual(type, (const xmlChar *)"delegateURI"))
  {
    v11 = 12;
    goto LABEL_52;
  }
  if (xmlStrEqual(type, (const xmlChar *)"nextCatalog"))
  {
    v11 = 3;
    goto LABEL_52;
  }
  if (!xmlStrEqual(type, (const xmlChar *)"catalog"))
  {
    if (xmlDebugCatalogs)
    {
      v28 = *__xmlGenericError();
      v29 = __xmlGenericErrorContext();
      v28(*v29, "Failed to add unknown element %s to catalog\n", (const char *)type);
    }
    goto LABEL_77;
  }
  v11 = 1;
LABEL_52:
  v16 = *v9;
  if (*v9)
  {
    while (1)
    {
      v17 = (_QWORD *)v16;
      if (orig)
      {
        if (*(_DWORD *)(v16 + 24) == v11 && xmlStrEqual(orig, *(const xmlChar **)(v16 + 32)))
          break;
      }
      v16 = *v17;
      if (!*v17)
        goto LABEL_59;
    }
    if (xmlDebugCatalogs)
    {
      v23 = *__xmlGenericError();
      v24 = __xmlGenericErrorContext();
      v23(*v24, "Updating element %s to catalog\n", (const char *)type);
    }
    v25 = (void *)v17[5];
    if (v25)
      xmlFree(v25);
    v26 = (void *)v17[6];
    if (v26)
      xmlFree(v26);
    v17[5] = xmlStrdup(replace);
    v27 = xmlStrdup(replace);
    LODWORD(v15) = 0;
    v17[6] = v27;
  }
  else
  {
    v17 = 0;
LABEL_59:
    if (xmlDebugCatalogs)
    {
      v18 = *__xmlGenericError();
      v19 = __xmlGenericErrorContext();
      v18(*v19, "Adding element %s to catalog\n", (const char *)type);
    }
    v20 = xmlNewCatalogEntry(v11, (xmlChar *)orig, replace, 0, *(_DWORD *)(v8 + 56), 0);
    if (v17)
      v21 = v17;
    else
      v21 = (_QWORD *)(v8 + 16);
    *v21 = v20;
    if (v10)
    {
      LODWORD(v15) = 0;
    }
    else
    {
      *(_DWORD *)(v8 + 24) = 1;
      v15 = xmlHashLookup((xmlHashTablePtr)xmlCatalogXMLFiles, *(const xmlChar **)(v8 + 48));
      if (v15)
      {
        v22 = v15;
        LODWORD(v15) = 0;
        v22[2] = *v9;
      }
    }
  }
  return (int)v15;
}

int xmlACatalogRemove(xmlCatalogPtr catal, const xmlChar *value)
{
  int result;
  uint64_t v5;
  uint64_t *v6;
  const xmlChar *v7;
  uint64_t v8;
  xmlGenericErrorFunc v9;
  void *v10;
  uint64_t v11;

  result = -1;
  if (catal && value)
  {
    if (*(_DWORD *)catal == 1)
    {
      v5 = *((_QWORD *)catal + 14);
      if (v5 && (*(_DWORD *)(v5 + 24) - 1) <= 1)
      {
        v6 = *(uint64_t **)(v5 + 16);
        if (v6 || (xmlFetchXMLCatalogFile(v5), (v6 = *(uint64_t **)(v5 + 16)) != 0))
        {
          do
          {
            v7 = (const xmlChar *)v6[4];
            if (v7 && xmlStrEqual(value, v7) || xmlStrEqual(value, (const xmlChar *)v6[5]))
            {
              if (xmlDebugCatalogs)
              {
                v8 = v6[4];
                v9 = *__xmlGenericError();
                v10 = *__xmlGenericErrorContext();
                if (v8)
                  v11 = 4;
                else
                  v11 = 5;
                v9(v10, "Removing element %s from catalog\n", (const char *)v6[v11]);
              }
              *((_DWORD *)v6 + 6) = -1;
            }
            v6 = (uint64_t *)*v6;
          }
          while (v6);
        }
        return 0;
      }
    }
    else
    {
      result = xmlHashRemoveEntry(*((xmlHashTablePtr *)catal + 12), value, (xmlHashDeallocator)xmlFreeCatalogEntry);
      if (result <= 1)
        return 1;
    }
  }
  return result;
}

xmlCatalogPtr xmlNewCatalog(int sgml)
{
  xmlCatalog *NewCatalog;
  xmlCatalog *v2;

  if (!sgml)
    return (xmlCatalogPtr)xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
  NewCatalog = (xmlCatalog *)xmlCreateNewCatalog(2, xmlCatalogDefaultPrefer);
  v2 = NewCatalog;
  if (NewCatalog)
  {
    if (!*((_QWORD *)NewCatalog + 12))
      *((_QWORD *)NewCatalog + 12) = xmlHashCreate(10);
  }
  return v2;
}

int xmlCatalogIsEmpty(xmlCatalogPtr catal)
{
  uint64_t v1;
  xmlHashTable *v3;
  int v4;

  if (!catal)
    return -1;
  if (*(_DWORD *)catal == 1)
  {
    v1 = *((_QWORD *)catal + 14);
    if (v1)
    {
      if ((*(_DWORD *)(v1 + 24) - 1) > 1)
        return -1;
      else
        return *(_QWORD *)(v1 + 16) == 0;
    }
    return 1;
  }
  v3 = (xmlHashTable *)*((_QWORD *)catal + 12);
  if (!v3)
    return 1;
  v4 = xmlHashSize(v3);
  if (v4)
    return v4 >> 31;
  else
    return 1;
}

void xmlInitializeCatalog(void)
{
  xmlRMutex *v0;
  char *v1;
  _OWORD *NewCatalog;
  uint64_t v3;
  unsigned int v4;
  _QWORD *v5;
  char *v6;
  unsigned int v7;
  uint64_t v8;
  xmlChar *v9;
  xmlChar *v10;
  _QWORD *v11;

  v0 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    pthread_once(&once_control, (void (*)(void))_xmlInitializeCatalogData);
    v0 = (xmlRMutex *)xmlCatalogMutex;
  }
  xmlRMutexLock(v0);
  if (getenv("XML_DEBUG_CATALOG"))
    xmlDebugCatalogs = 1;
  if (!xmlDefaultCatalog)
  {
    v1 = getenv("XML_CATALOG_FILES");
    NewCatalog = xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
    if (NewCatalog)
    {
      v3 = (uint64_t)NewCatalog;
      if (!v1)
        v1 = "file:///etc/xml/catalog";
      v4 = *v1;
      if (*v1)
      {
        v5 = NewCatalog + 7;
        do
        {
          v6 = v1;
          while (v4 <= 0x20)
          {
            if (((1 << v4) & 0x100002600) == 0)
            {
              if (!v4)
                goto LABEL_24;
              break;
            }
            v7 = *++v1;
            v4 = v7;
            ++v6;
          }
          v8 = 0;
          while (v4 > 0x20 || ((1 << v4) & 0x100002601) == 0)
            v4 = v1[++v8];
          v9 = xmlStrndup((const xmlChar *)v1, v8);
          v1 += v8;
          if (v9)
          {
            v10 = v9;
            v11 = xmlNewCatalogEntry(1, 0, 0, v9, xmlCatalogDefaultPrefer, 0);
            *v5 = v11;
            if (v11)
              v5 = v11;
            xmlFree(v10);
          }
LABEL_24:
          v4 = *v1;
        }
        while (*v1);
      }
      xmlDefaultCatalog = v3;
    }
  }
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
}

int xmlLoadCatalog(const char *filename)
{
  xmlRMutex *v2;
  int v3;
  xmlCatalogPtr ACatalog;

  v2 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    pthread_once(&once_control, (void (*)(void))_xmlInitializeCatalogData);
    v2 = (xmlRMutex *)xmlCatalogMutex;
  }
  xmlRMutexLock(v2);
  if (xmlDefaultCatalog)
  {
    v3 = xmlExpandCatalog(xmlDefaultCatalog, (char *)filename);
  }
  else
  {
    ACatalog = xmlLoadACatalog(filename);
    if (ACatalog)
    {
      v3 = 0;
      xmlDefaultCatalog = (uint64_t)ACatalog;
    }
    else
    {
      v3 = -1;
    }
  }
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v3;
}

uint64_t xmlExpandCatalog(uint64_t a1, char *a2)
{
  char *FileContent;
  char *v5;
  int v6;
  uint64_t result;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;

  if (!a2)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 == 2)
  {
    FileContent = xmlLoadFileContent(a2);
    if (FileContent)
    {
      v5 = FileContent;
      v6 = xmlParseSGMLCatalog(a1, (int)FileContent, (xmlChar *)a2);
      xmlFree(v5);
      return (v6 >> 31);
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v8 = xmlNewCatalogEntry(1, 0, 0, (xmlChar *)a2, xmlCatalogDefaultPrefer, 0);
    v9 = *(_QWORD **)(a1 + 112);
    if (v9)
    {
      do
      {
        v10 = v9;
        v9 = (_QWORD *)*v9;
      }
      while (v9);
      result = 0;
      *v10 = v8;
    }
    else
    {
      result = 0;
      *(_QWORD *)(a1 + 112) = v8;
    }
  }
  return result;
}

void xmlLoadCatalogs(const char *paths)
{
  const char *v1;
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  xmlChar *v5;
  xmlChar *v6;
  unsigned int v7;

  if (paths)
  {
    v1 = paths;
    v2 = *(unsigned __int8 *)paths;
    if (*paths)
    {
      while (v2 <= 0x20)
      {
        if (((1 << v2) & 0x100002600) != 0)
        {
          v3 = *(unsigned __int8 *)++v1;
          v2 = v3;
        }
        else
        {
          if (v2)
            break;
LABEL_13:
          --v1;
          do
          {
            v7 = *(unsigned __int8 *)++v1;
            v2 = v7;
          }
          while (v7 == 58);
          if (!v2)
            return;
        }
      }
      v4 = 0;
      while (v2 > 0x3A || ((1 << v2) & 0x400000100002601) == 0)
        v2 = v1[++v4];
      v5 = xmlStrndup((const xmlChar *)v1, v4);
      v1 += v4;
      if (v5)
      {
        v6 = v5;
        xmlLoadCatalog((const char *)v5);
        xmlFree(v6);
      }
      goto LABEL_13;
    }
  }
}

void xmlCatalogCleanup(void)
{
  xmlGenericErrorFunc v0;
  void **v1;

  if (xmlCatalogMutex)
  {
    xmlRMutexLock((xmlRMutexPtr)xmlCatalogMutex);
    if (xmlDebugCatalogs)
    {
      v0 = *__xmlGenericError();
      v1 = __xmlGenericErrorContext();
      v0(*v1, "Catalogs cleanup\n");
    }
    if (xmlCatalogXMLFiles)
      xmlHashFree((xmlHashTablePtr)xmlCatalogXMLFiles, (xmlHashDeallocator)xmlFreeCatalogHashEntryList);
    xmlCatalogXMLFiles = 0;
    if (xmlDefaultCatalog)
      xmlFreeCatalog((xmlCatalogPtr)xmlDefaultCatalog);
    xmlDefaultCatalog = 0;
    xmlDebugCatalogs = 0;
    xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  }
}

void xmlFreeCatalogHashEntryList(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 16);
    if (v2)
    {
      do
      {
        v3 = *(_QWORD *)v2;
        *(_DWORD *)(v2 + 60) = 0;
        *(_QWORD *)(v2 + 16) = 0;
        xmlFreeCatalogEntry(v2);
        v2 = v3;
      }
      while (v3);
    }
    *(_DWORD *)(a1 + 60) = 0;
    xmlFreeCatalogEntry(a1);
  }
}

xmlChar *__cdecl xmlCatalogResolveSystem(const xmlChar *sysID)
{
  if (!xmlCatalogMutex)
    xmlInitializeCatalog();
  return xmlACatalogResolveSystem((xmlCatalogPtr)xmlDefaultCatalog, sysID);
}

xmlChar *__cdecl xmlCatalogResolvePublic(const xmlChar *pubID)
{
  if (!xmlCatalogMutex)
    xmlInitializeCatalog();
  return xmlACatalogResolvePublic((xmlCatalogPtr)xmlDefaultCatalog, pubID);
}

xmlChar *__cdecl xmlCatalogResolve(const xmlChar *pubID, const xmlChar *sysID)
{
  if (!xmlCatalogMutex)
    xmlInitializeCatalog();
  return xmlACatalogResolve((xmlCatalogPtr)xmlDefaultCatalog, pubID, sysID);
}

xmlChar *__cdecl xmlCatalogResolveURI(const xmlChar *URI)
{
  if (!xmlCatalogMutex)
    xmlInitializeCatalog();
  return xmlACatalogResolveURI((xmlCatalogPtr)xmlDefaultCatalog, URI);
}

void xmlCatalogDump(FILE *out)
{
  if (out)
  {
    if (!xmlCatalogMutex)
      xmlInitializeCatalog();
    xmlACatalogDump((xmlCatalogPtr)xmlDefaultCatalog, out);
  }
}

int xmlCatalogAdd(const xmlChar *type, const xmlChar *orig, const xmlChar *replace)
{
  xmlRMutex *v6;
  xmlCatalog *v7;
  int v8;
  _QWORD *v10;

  v6 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    pthread_once(&once_control, (void (*)(void))_xmlInitializeCatalogData);
    v6 = (xmlRMutex *)xmlCatalogMutex;
  }
  xmlRMutexLock(v6);
  v7 = (xmlCatalog *)xmlDefaultCatalog;
  if (xmlDefaultCatalog)
    goto LABEL_4;
  if (!xmlStrEqual(type, (const xmlChar *)"catalog"))
  {
    v7 = (xmlCatalog *)xmlDefaultCatalog;
LABEL_4:
    v8 = xmlACatalogAdd(v7, type, orig, replace);
    goto LABEL_5;
  }
  xmlDefaultCatalog = (uint64_t)xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
  if (xmlDefaultCatalog)
  {
    v10 = xmlNewCatalogEntry(1, 0, orig, 0, xmlCatalogDefaultPrefer, 0);
    v8 = 0;
    *(_QWORD *)(xmlDefaultCatalog + 112) = v10;
  }
  else
  {
    v8 = 0;
  }
LABEL_5:
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v8;
}

int xmlCatalogRemove(const xmlChar *value)
{
  xmlRMutex *v2;
  int v3;

  v2 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    xmlInitializeCatalog();
    v2 = (xmlRMutex *)xmlCatalogMutex;
  }
  xmlRMutexLock(v2);
  v3 = xmlACatalogRemove((xmlCatalogPtr)xmlDefaultCatalog, value);
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v3;
}

int xmlCatalogConvert(void)
{
  xmlRMutex *v0;
  int v1;

  v0 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    xmlInitializeCatalog();
    v0 = (xmlRMutex *)xmlCatalogMutex;
  }
  xmlRMutexLock(v0);
  v1 = xmlConvertSGMLCatalog((xmlCatalogPtr)xmlDefaultCatalog);
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v1;
}

xmlCatalogAllow xmlCatalogGetDefaults(void)
{
  return xmlCatalogDefaultAllow;
}

void xmlCatalogSetDefaults(xmlCatalogAllow allow)
{
  BOOL v2;
  char *v3;
  xmlGenericErrorFunc v4;
  void **v5;

  if (xmlDebugCatalogs)
    v2 = allow > XML_CATA_ALLOW_ALL;
  else
    v2 = 1;
  if (!v2)
  {
    v3 = (&off_1E616CBE8)[allow];
    v4 = *__xmlGenericError();
    v5 = __xmlGenericErrorContext();
    v4(*v5, v3);
  }
  xmlCatalogDefaultAllow = allow;
}

xmlCatalogPrefer xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer)
{
  xmlCatalogPrefer v1;
  const char *v3;
  xmlGenericErrorFunc v4;
  void **v5;

  v1 = xmlCatalogDefaultPrefer;
  if (prefer)
  {
    if (!xmlDebugCatalogs)
    {
LABEL_8:
      xmlCatalogDefaultPrefer = prefer;
      return v1;
    }
    if (prefer == XML_CATA_PREFER_PUBLIC)
    {
      v3 = "Setting catalog preference to PUBLIC\n";
      goto LABEL_7;
    }
    if (prefer == XML_CATA_PREFER_SYSTEM)
    {
      v3 = "Setting catalog preference to SYSTEM\n";
LABEL_7:
      v4 = *__xmlGenericError();
      v5 = __xmlGenericErrorContext();
      v4(*v5, v3);
      goto LABEL_8;
    }
  }
  return v1;
}

int xmlCatalogSetDebug(int level)
{
  int v1;

  v1 = xmlDebugCatalogs;
  xmlDebugCatalogs = level & ~(level >> 31);
  return v1;
}

void xmlCatalogFreeLocal(void *catalogs)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = catalogs;
  if (xmlCatalogMutex)
  {
    if (!catalogs)
      return;
  }
  else
  {
    xmlInitializeCatalog();
    if (!v1)
      return;
  }
  do
  {
    v2 = (_QWORD *)*v1;
    xmlFreeCatalogEntry((uint64_t)v1);
    v1 = v2;
  }
  while (v2);
}

void *__cdecl xmlCatalogAddLocal(void *catalogs, const xmlChar *URL)
{
  xmlGenericErrorFunc v4;
  void **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;

  if (!xmlCatalogMutex)
    xmlInitializeCatalog();
  if (URL)
  {
    if (xmlDebugCatalogs)
    {
      v4 = *__xmlGenericError();
      v5 = __xmlGenericErrorContext();
      v4(*v5, "Adding document catalog %s\n", (const char *)URL);
    }
    v6 = xmlNewCatalogEntry(1, 0, URL, 0, xmlCatalogDefaultPrefer, 0);
    if (v6)
    {
      if (catalogs)
      {
        v7 = catalogs;
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
        *v8 = v6;
      }
      else
      {
        return v6;
      }
    }
  }
  return catalogs;
}

xmlChar *__cdecl xmlCatalogLocalResolve(void *catalogs, const xmlChar *pubID, const xmlChar *sysID)
{
  xmlGenericErrorFunc v6;
  void *v7;
  const char *v8;
  xmlChar *result;

  if (!xmlCatalogMutex)
    xmlInitializeCatalog();
  if (!((unint64_t)pubID | (unint64_t)sysID))
    return 0;
  if (xmlDebugCatalogs)
  {
    v6 = *__xmlGenericError();
    v7 = *__xmlGenericErrorContext();
    if (pubID && sysID)
    {
      v8 = "Local Resolve: pubID %s sysID %s\n";
    }
    else if (pubID)
    {
      v8 = "Local Resolve: pubID %s\n";
    }
    else
    {
      v8 = "Local Resolve: sysID %s\n";
    }
    v6(v7, v8);
  }
  if (!catalogs)
    return 0;
  result = (xmlChar *)xmlCatalogListXMLResolve((uint64_t)catalogs, (xmlChar *)pubID, (uint64_t)sysID);
  if ((unint64_t)(result + 1) <= 1)
    return 0;
  return result;
}

xmlChar *__cdecl xmlCatalogLocalResolveURI(void *catalogs, const xmlChar *URI)
{
  xmlGenericErrorFunc v4;
  void **v5;
  xmlChar *result;

  if (xmlCatalogMutex)
  {
    if (!URI)
      return 0;
  }
  else
  {
    xmlInitializeCatalog();
    if (!URI)
      return 0;
  }
  if (xmlDebugCatalogs)
  {
    v4 = *__xmlGenericError();
    v5 = __xmlGenericErrorContext();
    v4(*v5, "Resolve URI %s\n", (const char *)URI);
  }
  if (!catalogs)
    return 0;
  result = (xmlChar *)xmlCatalogListXMLResolveURI((uint64_t)catalogs, (const char *)URI);
  if ((unint64_t)(result + 1) <= 1)
    return 0;
  return result;
}

const xmlChar *__cdecl xmlCatalogGetSystem(const xmlChar *sysID)
{
  xmlGenericErrorFunc v2;
  void **v3;
  const char *v4;
  xmlHashTable *v5;
  void *v6;

  if (!xmlCatalogMutex)
    xmlInitializeCatalog();
  if (!xmlCatalogGetSystem_msg)
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "Use of deprecated xmlCatalogGetSystem() call\n");
    ++xmlCatalogGetSystem_msg;
  }
  if (sysID)
  {
    if (!xmlDefaultCatalog)
      return 0;
    v4 = (const char *)xmlCatalogListXMLResolve(*(_QWORD *)(xmlDefaultCatalog + 112), 0, (uint64_t)sysID);
    if ((unint64_t)(v4 + 1) >= 2)
    {
      sysID = (const xmlChar *)xmlCatalogGetSystem_result;
      snprintf(xmlCatalogGetSystem_result, 0x3E7uLL, "%s", v4);
      byte_1EEEB96DF = 0;
      return sysID;
    }
    if (xmlDefaultCatalog
      && (v5 = *(xmlHashTable **)(xmlDefaultCatalog + 96)) != 0
      && (v6 = xmlHashLookup(v5, sysID)) != 0
      && *((_DWORD *)v6 + 6) == 13)
    {
      return (const xmlChar *)*((_QWORD *)v6 + 6);
    }
    else
    {
      return 0;
    }
  }
  return sysID;
}

const xmlChar *__cdecl xmlCatalogGetPublic(const xmlChar *pubID)
{
  xmlGenericErrorFunc v2;
  void **v3;
  const char *v4;

  if (!xmlCatalogMutex)
    xmlInitializeCatalog();
  if (xmlCatalogGetPublic_msg)
  {
    if (!pubID)
      return pubID;
  }
  else
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "Use of deprecated xmlCatalogGetPublic() call\n");
    ++xmlCatalogGetPublic_msg;
    if (!pubID)
      return pubID;
  }
  if (xmlDefaultCatalog)
  {
    v4 = (const char *)xmlCatalogListXMLResolve(*(_QWORD *)(xmlDefaultCatalog + 112), (xmlChar *)pubID, 0);
    if ((unint64_t)(v4 + 1) >= 2)
    {
      pubID = (const xmlChar *)xmlCatalogGetPublic_result;
      snprintf(xmlCatalogGetPublic_result, 0x3E7uLL, "%s", v4);
      byte_1EEEB9ACB = 0;
      return pubID;
    }
    if (xmlDefaultCatalog)
      return (const xmlChar *)xmlCatalogGetSGMLPublic(*(xmlHashTable **)(xmlDefaultCatalog + 96), (xmlChar *)pubID);
  }
  return 0;
}

_DWORD *xmlCatalogErrMemory(const xmlChar *a1)
{
  return __xmlRaiseError(0, 0, 0, 0, 0, 0x14u, 2, 2, 0, 0, a1, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a1);
}

unsigned __int8 *xmlParseSGMLCatalogName(unsigned __int8 *a1, xmlChar **a2)
{
  unsigned __int8 v3;
  int v6;
  uint64_t v7;
  BOOL v8;
  _OWORD v10[7];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  v3 = *a1;
  if ((*a1 + 40) >= 0x1Fu
    && (*a1 + 64) >= 0x17u
    && ((*a1 & 0xDF) - 65) >= 0x1Au)
  {
    v6 = *a1;
    if ((v6 - 248) >= 8 && v6 != 95 && v6 != 58)
      return 0;
  }
  v7 = 0;
  memset(v10, 0, 105);
  while (1)
  {
    v8 = (v3 & 0xDFu) - 65 >= 0x1A && v3 - 192 >= 0x17;
    if (v8
      && v3 <= 0xF7u
      && v3 - 216 >= 0x1F
      && v3 - 48 >= 0xA
      && v3 - 45 >= 2
      && v3 != 95
      && v3 != 58)
    {
      break;
    }
    *((_BYTE *)v10 + v7) = v3;
    v3 = a1[++v7];
    if (v7 == 100)
      return 0;
  }
  *a2 = xmlStrndup((const xmlChar *)v10, v7);
  return &a1[v7];
}

unsigned __int8 *xmlParseSGMLCatalogPubid(unsigned __int8 *a1, _QWORD *a2)
{
  _QWORD *v2;
  int v3;
  unsigned __int8 *v4;
  int v5;
  unsigned __int8 *v6;
  _BOOL4 v7;
  BOOL v8;
  int v9;
  _BYTE *v10;
  _BYTE *v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  BOOL v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  _BYTE *v19;
  BOOL v20;
  BOOL v21;
  unsigned int v22;
  BOOL v23;
  uint64_t v24;
  _QWORD *v27;

  v2 = a2;
  *a2 = 0;
  v3 = *a1;
  if (v3 == 34)
    v4 = a1 + 1;
  else
    v4 = a1;
  if (v3 == 34)
    v5 = 34;
  else
    v5 = 32;
  if (v3 == 39)
    v6 = a1 + 1;
  else
    v6 = v4;
  v7 = v3 != 39 && v3 != 34;
  v8 = v3 == 39 || v3 == 34;
  if (v3 == 39)
    v9 = 39;
  else
    v9 = v5;
  v10 = xmlMallocAtomic(0x32uLL);
  if (!v10)
  {
    xmlCatalogErrMemory((const xmlChar *)"allocating public ID");
    return 0;
  }
  v11 = v10;
  v12 = 0;
  v13 = *v6;
  v14 = v9 == v13 && v8;
  if (xmlIsPubidChar_tab[*v6])
    v15 = 1;
  else
    v15 = v13 == 63;
  if (v15 && !v14)
  {
    v27 = v2;
    v16 = 0;
    v17 = 50;
    while (1)
    {
      if (v7 && v13 <= 0x20 && ((1 << v13) & 0x100002600) != 0)
      {
        v11[v16] = 0;
        v6 += v16;
        v2 = v27;
        goto LABEL_51;
      }
      v18 = v16 + 1;
      if (v17 <= (int)v16 + 1)
      {
        v17 *= 2;
        v19 = xmlRealloc(v11, v17);
        if (!v19)
        {
          xmlCatalogErrMemory((const xmlChar *)"allocating public ID");
          goto LABEL_57;
        }
        LOBYTE(v13) = v6[v16];
        v11 = v19;
      }
      v11[v16] = v13;
      v13 = v6[v16 + 1];
      v20 = v9 == v13 && v8;
      if (xmlIsPubidChar_tab[v6[v16 + 1]])
        v21 = 1;
      else
        v21 = v13 == 63;
      if (v21)
      {
        ++v16;
        if (!v20)
          continue;
      }
      v12 = v18;
      v6 += v18;
      v2 = v27;
      break;
    }
  }
  v11[v12] = 0;
  if (!v7)
  {
    if (v9 != *v6)
      goto LABEL_57;
    ++v6;
    goto LABEL_55;
  }
LABEL_51:
  v22 = *v6;
  v23 = v22 > 0x20;
  v24 = (1 << v22) & 0x100002600;
  if (v23 || v24 == 0)
  {
LABEL_57:
    xmlFree(v11);
    return 0;
  }
LABEL_55:
  *v2 = v11;
  return v6;
}

xmlChar *xmlCatalogNormalizePublic(xmlChar *cur)
{
  xmlChar *v1;
  unsigned int v2;
  unsigned __int8 *v3;
  int v4;
  uint64_t v5;
  _BOOL4 v6;
  BOOL v7;
  int v8;
  unsigned int v9;
  int v10;
  xmlChar *v11;
  unsigned int v12;

  if (cur)
  {
    v1 = cur;
    v2 = *cur;
    if (*cur)
    {
      v3 = cur + 1;
      v4 = 1;
      do
      {
        v5 = 1 << v2;
        v6 = v2 == 32 && v4 == 0;
        if (v2 == 32 && v4 == 0)
          v4 = 1;
        v7 = (v5 & 0x100002600) == 0;
        v8 = (v5 & 0x100002600) == 0 || v6;
        if (v7)
          v4 = 0;
        if (v2 > 0x20)
        {
          v8 = 1;
          v4 = 0;
        }
        if (!v8)
          break;
        v9 = *v3++;
        v2 = v9;
      }
      while (v9);
      if (v8 && !v4)
        return 0;
    }
    cur = xmlStrdup(cur);
    v10 = 0;
    v11 = cur;
    while (1)
    {
      v12 = *v1;
      if (v12 <= 0x20)
      {
        if (((1 << v12) & 0x100002600) != 0)
        {
          if (v11 != cur)
            v10 = 1;
          goto LABEL_24;
        }
        if (!*v1)
        {
          *v11 = 0;
          return cur;
        }
      }
      if (v10)
      {
        *v11++ = 32;
        LOBYTE(v12) = *v1;
      }
      v10 = 0;
      *v11++ = v12;
LABEL_24:
      ++v1;
    }
  }
  return cur;
}

xmlChar *xmlCatalogUnWrapURN(uint64_t a1)
{
  int v3;
  unsigned __int8 *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  xmlChar v10;
  BOOL v11;
  int v12;
  xmlChar cur[2000];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (xmlStrncmp((const xmlChar *)a1, (const xmlChar *)"urn:publicid:", 13))
    return 0;
  bzero(cur, 0x7D0uLL);
  v5 = *(unsigned __int8 *)(a1 + 13);
  v4 = (unsigned __int8 *)(a1 + 13);
  v3 = v5;
  if (v5)
  {
    v6 = 0;
    LODWORD(v7) = 0;
    while (1)
    {
      if (v3 > 57)
      {
        if (v3 == 58)
        {
          v7 = v7 + 1;
          cur[v6] = 47;
          cur[v7] = 47;
          goto LABEL_21;
        }
        if (v3 == 59)
        {
          v7 = v7 + 1;
          cur[v6] = 58;
          cur[v7] = 58;
          ++v4;
          goto LABEL_22;
        }
LABEL_20:
        cur[v6] = v3;
        goto LABEL_21;
      }
      if (v3 != 37)
      {
        if (v3 == 43)
        {
          cur[v6] = 32;
LABEL_21:
          ++v4;
          goto LABEL_22;
        }
        goto LABEL_20;
      }
      v8 = v4[1];
      if (v8 == 51)
      {
        v12 = v4[2];
        switch(v12)
        {
          case 'A':
            v10 = 58;
            break;
          case 'B':
            v10 = 59;
            break;
          case 'F':
            v10 = 63;
            break;
          default:
            goto LABEL_33;
        }
      }
      else
      {
        if (v8 != 50)
          goto LABEL_33;
        v9 = v4[2];
        if (v9 <= 0x36)
        {
          if (v9 == 51)
          {
            v10 = 35;
          }
          else
          {
            if (v9 != 53)
            {
LABEL_33:
              cur[v6] = 37;
              ++v4;
              goto LABEL_22;
            }
            v10 = 37;
          }
        }
        else
        {
          switch(v9)
          {
            case '7':
              v10 = 39;
              break;
            case 'B':
              v10 = 43;
              break;
            case 'F':
              v10 = 47;
              break;
            default:
              goto LABEL_33;
          }
        }
      }
      cur[v6] = v10;
      v4 += 3;
LABEL_22:
      v6 = (v7 + 1);
      v3 = *v4;
      if (*v4)
      {
        v11 = v7 > 0x7CB;
        LODWORD(v7) = v7 + 1;
        if (!v11)
          continue;
      }
      goto LABEL_41;
    }
  }
  v6 = 0;
LABEL_41:
  cur[v6] = 0;
  return xmlStrdup(cur);
}

void xmlFetchXMLCatalogFile(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  xmlGenericErrorFunc v4;
  void **v5;
  xmlGenericErrorFunc v6;
  void **v7;
  const char *v8;
  uint64_t v9;
  xmlDocPtr v10;
  xmlDoc *v11;
  xmlGenericErrorFunc v12;
  void *v13;
  int ThreadId;
  xmlNodePtr RootElement;
  const xmlNode *v16;
  xmlNs *ns;
  const xmlChar *href;
  _QWORD *v19;
  _QWORD *v20;
  xmlChar *Prop;
  xmlChar *v22;
  xmlGenericErrorFunc v23;
  void **v24;
  _QWORD *v25;
  xmlHashTable *v26;
  xmlGenericErrorFunc v27;
  void **v28;

  if (*(_QWORD *)(a1 + 48))
  {
    xmlRMutexLock((xmlRMutexPtr)xmlCatalogMutex);
    if (!*(_QWORD *)(a1 + 16))
    {
      if (xmlCatalogXMLFiles)
      {
        v2 = xmlHashLookup((xmlHashTablePtr)xmlCatalogXMLFiles, *(const xmlChar **)(a1 + 48));
        if (v2)
        {
          v3 = v2;
          if (xmlDebugCatalogs)
          {
            v4 = *__xmlGenericError();
            v5 = __xmlGenericErrorContext();
            v4(*v5, "Found %s in file hash\n", *(const char **)(a1 + 48));
          }
          if (*(_DWORD *)(a1 + 24) == 1)
            v3 = (_QWORD *)v3[2];
          *(_QWORD *)(a1 + 16) = v3;
          *(_DWORD *)(a1 + 60) = 0;
          goto LABEL_31;
        }
        if (xmlDebugCatalogs)
        {
          v6 = *__xmlGenericError();
          v7 = __xmlGenericErrorContext();
          v6(*v7, "%s not found in file hash\n", *(const char **)(a1 + 48));
        }
      }
      v8 = *(const char **)(a1 + 48);
      if (v8)
      {
        v9 = *(unsigned int *)(a1 + 56);
        v10 = xmlParseCatalogFile(*(const char **)(a1 + 48));
        if (v10)
        {
          v11 = v10;
          if (xmlDebugCatalogs)
          {
            v12 = *__xmlGenericError();
            v13 = *__xmlGenericErrorContext();
            ThreadId = xmlGetThreadId();
            v12(v13, "%d Parsing catalog %s\n", ThreadId, v8);
          }
          RootElement = xmlDocGetRootElement(v11);
          if (RootElement
            && (v16 = RootElement, xmlStrEqual(RootElement->name, (const xmlChar *)"catalog"))
            && (ns = v16->ns) != 0
            && (href = ns->href) != 0
            && xmlStrEqual(href, (const xmlChar *)"urn:oasis:names:tc:entity:xmlns:xml:catalog"))
          {
            v19 = xmlNewCatalogEntry(1, 0, (const xmlChar *)v8, 0, v9, 0);
            if (v19)
            {
              v20 = v19;
              Prop = xmlGetProp(v16, (const xmlChar *)"prefer");
              if (Prop)
              {
                v22 = Prop;
                if (xmlStrEqual(Prop, (const xmlChar *)"system"))
                {
                  v9 = 2;
                }
                else if (xmlStrEqual(v22, (const xmlChar *)"public"))
                {
                  v9 = 1;
                }
                else
                {
                  xmlCatalogErr(0, (uint64_t)v16, 1652, "Invalid value for prefer: '%s'\n", v22, 0, 0);
                }
                xmlFree(v22);
              }
              xmlParseXMLCatalogNodeList(v16->children, v9, v20, 0);
              xmlFreeDoc(v11);
              v25 = v20;
              if (*(_DWORD *)(a1 + 24) == 1)
                v25 = (_QWORD *)v20[2];
              *(_QWORD *)(a1 + 16) = v25;
              *((_DWORD *)v20 + 15) = 1;
              v26 = (xmlHashTable *)xmlCatalogXMLFiles;
              if (xmlCatalogXMLFiles || (v26 = xmlHashCreate(10), (xmlCatalogXMLFiles = (uint64_t)v26) != 0))
              {
                if (xmlDebugCatalogs)
                {
                  v27 = *__xmlGenericError();
                  v28 = __xmlGenericErrorContext();
                  v27(*v28, "%s added to file hash\n", *(const char **)(a1 + 48));
                  v26 = (xmlHashTable *)xmlCatalogXMLFiles;
                }
                xmlHashAddEntry(v26, *(const xmlChar **)(a1 + 48), v20);
              }
              goto LABEL_31;
            }
          }
          else
          {
            __xmlRaiseError(0, 0, 0, 0, (uint64_t)v11, 0x14u, 1653, 2, 0, 0, (const xmlChar *)v8, 0, 0, 0, 0, "File %s is not an XML Catalog\n", (char)v8);
          }
          xmlFreeDoc(v11);
        }
        else if (xmlDebugCatalogs)
        {
          v23 = *__xmlGenericError();
          v24 = __xmlGenericErrorContext();
          v23(*v24, "Failed to parse catalog %s\n", v8);
        }
      }
      *(_DWORD *)(a1 + 24) = 2;
    }
LABEL_31:
    xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  }
}

_DWORD *xmlCatalogErr(_QWORD *a1, uint64_t a2, int a3, const char *a4, const xmlChar *a5, xmlChar *a6, xmlChar *a7)
{
  return __xmlRaiseError(0, 0, 0, a1, a2, 0x14u, a3, 2, 0, 0, a5, a6, a7, 0, 0, a4, (char)a5);
}

void xmlParseXMLCatalogNodeList(const xmlNode *a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  const xmlNode *v7;
  xmlNs *ns;
  const xmlChar *href;
  xmlChar *Prop;
  xmlChar *v11;
  uint64_t v12;
  xmlNode *v13;
  int v14;
  const char *v15;
  char *v16;
  char *v17;
  _QWORD *v18;
  xmlChar *NsProp;
  xmlChar *v20;
  _QWORD *v21;
  _QWORD *i;
  _QWORD *v23;

  if (a1)
  {
    v7 = a1;
    v23 = a3 + 2;
    while (1)
    {
      ns = v7->ns;
      if (!ns)
        goto LABEL_29;
      href = ns->href;
      if (!href || !xmlStrEqual(href, (const xmlChar *)"urn:oasis:names:tc:entity:xmlns:xml:catalog"))
        goto LABEL_29;
      if (xmlStrEqual(v7->name, (const xmlChar *)"group"))
      {
        Prop = xmlGetProp(v7, (const xmlChar *)"prefer");
        v11 = Prop;
        if (Prop)
        {
          if (xmlStrEqual(Prop, (const xmlChar *)"system"))
          {
            v12 = 2;
          }
          else if (xmlStrEqual(v11, (const xmlChar *)"public"))
          {
            v12 = 1;
          }
          else
          {
            __xmlRaiseError(0, 0, 0, a3, (uint64_t)v7, 0x14u, 1652, 2, 0, 0, v11, 0, 0, 0, 0, "Invalid value for prefer: '%s'\n", (char)v11);
            v12 = a2;
          }
          xmlFree(v11);
          LODWORD(v11) = v12;
        }
        else
        {
          v12 = a2;
        }
        v20 = xmlGetProp(v7, (const xmlChar *)"id");
        NsProp = xmlGetNsProp(v7, (const xmlChar *)"base", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        v18 = xmlNewCatalogEntry(4, v20, NsProp, 0, (int)v11, a4);
        xmlFree(v20);
        if (!v18)
          goto LABEL_27;
        goto LABEL_23;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"public"))
      {
        v13 = (xmlNode *)v7;
        v14 = 5;
        v15 = "public";
        v16 = "publicId";
        goto LABEL_17;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"system"))
      {
        v13 = (xmlNode *)v7;
        v14 = 6;
        v15 = "system";
        v16 = "systemId";
        goto LABEL_17;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"rewriteSystem"))
      {
        v13 = (xmlNode *)v7;
        v14 = 7;
        v15 = "rewriteSystem";
        v16 = "systemIdStartString";
        goto LABEL_33;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"delegatePublic"))
      {
        v13 = (xmlNode *)v7;
        v14 = 8;
        v15 = "delegatePublic";
        v16 = "publicIdStartString";
        goto LABEL_38;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"delegateSystem"))
      {
        v13 = (xmlNode *)v7;
        v14 = 9;
        v15 = "delegateSystem";
        v16 = "systemIdStartString";
        goto LABEL_38;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"uri"))
      {
        v13 = (xmlNode *)v7;
        v14 = 10;
        v15 = "uri";
        v16 = "name";
LABEL_17:
        v17 = "uri";
        goto LABEL_18;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"rewriteURI"))
      {
        v13 = (xmlNode *)v7;
        v14 = 11;
        v15 = "rewriteURI";
        v16 = "uriStartString";
LABEL_33:
        v17 = "rewritePrefix";
LABEL_18:
        v18 = xmlParseXMLCatalogOneNode(v13, v14, (const xmlChar *)v15, (xmlChar *)v16, (xmlChar *)v17, a2, a4);
        NsProp = 0;
        v12 = a2;
        if (!v18)
        {
LABEL_27:
          if (NsProp)
            xmlFree(NsProp);
          goto LABEL_29;
        }
LABEL_23:
        v18[1] = a3;
        v21 = (_QWORD *)a3[2];
        for (i = v23; v21; v21 = (_QWORD *)*v21)
          i = v21;
        *i = v18;
        if (*((_DWORD *)v18 + 6) == 4)
          xmlParseXMLCatalogNodeList(v7->children, v12, a3, v18);
        goto LABEL_27;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"delegateURI"))
        break;
      if (xmlStrEqual(v7->name, (const xmlChar *)"nextCatalog"))
      {
        v13 = (xmlNode *)v7;
        v14 = 3;
        v15 = "nextCatalog";
        v16 = 0;
        goto LABEL_38;
      }
LABEL_29:
      v7 = v7->next;
      if (!v7)
        return;
    }
    v13 = (xmlNode *)v7;
    v14 = 12;
    v15 = "delegateURI";
    v16 = "uriStartString";
LABEL_38:
    v17 = "catalog";
    goto LABEL_18;
  }
}

_QWORD *xmlParseXMLCatalogOneNode(xmlNode *node, int a2, const xmlChar *a3, xmlChar *name, xmlChar *a5, int a6, uint64_t a7)
{
  xmlChar *Prop;
  xmlChar *v15;
  xmlChar *v16;
  xmlChar *v17;
  xmlChar *Base;
  xmlChar *v19;
  xmlGenericErrorFunc v20;
  void *v21;
  const char *v22;
  _QWORD *v23;

  if (name)
  {
    Prop = xmlGetProp(node, name);
    if (!Prop)
    {
      __xmlRaiseError(0, 0, 0, 0, (uint64_t)node, 0x14u, 1650, 2, 0, 0, a3, name, 0, 0, 0, "%s entry lacks '%s'\n", (char)a3);
      v15 = xmlGetProp(node, a5);
      if (v15)
        ((void (*)(xmlChar *))xmlFree)(v15);
      else
        __xmlRaiseError(0, 0, 0, 0, (uint64_t)node, 0x14u, 1650, 2, 0, 0, a3, a5, 0, 0, 0, "%s entry lacks '%s'\n", (char)a3);
      return 0;
    }
  }
  else
  {
    Prop = 0;
  }
  v16 = xmlGetProp(node, a5);
  if (!v16)
  {
    __xmlRaiseError(0, 0, 0, 0, (uint64_t)node, 0x14u, 1650, 2, 0, 0, a3, a5, 0, 0, 0, "%s entry lacks '%s'\n", (char)a3);
    if (Prop)
      ((void (*)(xmlChar *))xmlFree)(Prop);
    return 0;
  }
  v17 = v16;
  Base = xmlNodeGetBase(node->doc, node);
  v19 = xmlBuildURI(v17, Base);
  if (v19)
  {
    if (xmlDebugCatalogs >= 2)
    {
      v20 = *__xmlGenericError();
      v21 = *__xmlGenericErrorContext();
      if (Prop)
        v22 = "Found %s: '%s' '%s'\n";
      else
        v22 = "Found %s: '%s'\n";
      v20(v21, v22);
    }
    v23 = xmlNewCatalogEntry(a2, Prop, v17, v19, a6, a7);
    if (!Prop)
      goto LABEL_21;
  }
  else
  {
    __xmlRaiseError(0, 0, 0, 0, (uint64_t)node, 0x14u, 1651, 2, 0, 0, a3, a5, v17, 0, 0, "%s entry '%s' broken ?: %s\n", (char)a3);
    v23 = 0;
    if (!Prop)
      goto LABEL_21;
  }
  xmlFree(Prop);
LABEL_21:
  xmlFree(v17);
  if (Base)
    xmlFree(Base);
  if (v19)
    xmlFree(v19);
  return v23;
}

xmlNodePtr xmlDumpXMLCatalogNode(xmlNodePtr result, xmlNode *a2, xmlDoc *a3, xmlNs *a4, xmlNs *a5)
{
  xmlNodePtr v9;
  const xmlChar **p_name;
  xmlNodePtr v11;
  xmlNode *v12;
  xmlNode *v13;
  const xmlChar *last;
  const char *v15;
  xmlNode *v16;
  const xmlChar *v17;
  const char *v18;
  xmlNode *v19;
  const xmlChar *v20;
  const char *v21;
  xmlNode *v22;
  const xmlChar *parent;
  xmlNs *v24;
  int prev;
  const char *v26;
  const char *v27;

  if (result)
  {
    v9 = result;
    p_name = &result->name;
    v11 = result;
    do
    {
      if (v11->ns == a5)
      {
        switch(LODWORD(v11->children))
        {
          case 1:
          case 2:
            if (v11 == v9)
              v11 = (xmlNodePtr)p_name;
            break;
          case 3:
            v22 = xmlNewDocNode(a3, a4, (const xmlChar *)"nextCatalog", 0);
            v13 = v22;
            parent = (const xmlChar *)v11->parent;
            goto LABEL_22;
          case 4:
            v13 = xmlNewDocNode(a3, a4, (const xmlChar *)"group", 0);
            xmlSetProp(v13, (const xmlChar *)"id", (const xmlChar *)v11->last);
            if (v11->parent)
            {
              v24 = xmlSearchNsByHref(a3, v13, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
              if (v24)
                xmlSetNsProp(v13, v24, (const xmlChar *)"base", (const xmlChar *)v11->parent);
            }
            prev = (int)v11->prev;
            if (prev == 1)
            {
              v26 = "public";
            }
            else
            {
              if (prev != 2)
                goto LABEL_33;
              v26 = "system";
            }
            xmlSetProp(v13, (const xmlChar *)"prefer", (const xmlChar *)v26);
LABEL_33:
            xmlDumpXMLCatalogNode(v11->_private, v13, a3, a4, v11);
LABEL_28:
            result = xmlAddChild(a2, v13);
            break;
          case 5:
            v12 = xmlNewDocNode(a3, a4, (const xmlChar *)"public", 0);
            v13 = v12;
            last = (const xmlChar *)v11->last;
            v15 = "publicId";
            goto LABEL_24;
          case 6:
            v12 = xmlNewDocNode(a3, a4, (const xmlChar *)"system", 0);
            v13 = v12;
            last = (const xmlChar *)v11->last;
            v15 = "systemId";
            goto LABEL_24;
          case 7:
            v16 = xmlNewDocNode(a3, a4, (const xmlChar *)"rewriteSystem", 0);
            v13 = v16;
            v17 = (const xmlChar *)v11->last;
            v18 = "systemIdStartString";
            goto LABEL_26;
          case 8:
            v19 = xmlNewDocNode(a3, a4, (const xmlChar *)"delegatePublic", 0);
            v13 = v19;
            v20 = (const xmlChar *)v11->last;
            v21 = "publicIdStartString";
            goto LABEL_21;
          case 9:
            v19 = xmlNewDocNode(a3, a4, (const xmlChar *)"delegateSystem", 0);
            v13 = v19;
            v20 = (const xmlChar *)v11->last;
            v21 = "systemIdStartString";
            goto LABEL_21;
          case 0xA:
            v12 = xmlNewDocNode(a3, a4, (const xmlChar *)"uri", 0);
            v13 = v12;
            last = (const xmlChar *)v11->last;
            v15 = "name";
LABEL_24:
            xmlSetProp(v12, (const xmlChar *)v15, last);
            parent = (const xmlChar *)v11->parent;
            v22 = v13;
            v27 = "uri";
            goto LABEL_27;
          case 0xB:
            v16 = xmlNewDocNode(a3, a4, (const xmlChar *)"rewriteURI", 0);
            v13 = v16;
            v17 = (const xmlChar *)v11->last;
            v18 = "uriStartString";
LABEL_26:
            xmlSetProp(v16, (const xmlChar *)v18, v17);
            parent = (const xmlChar *)v11->parent;
            v22 = v13;
            v27 = "rewritePrefix";
            goto LABEL_27;
          case 0xC:
            v19 = xmlNewDocNode(a3, a4, (const xmlChar *)"delegateURI", 0);
            v13 = v19;
            v20 = (const xmlChar *)v11->last;
            v21 = "uriStartString";
LABEL_21:
            xmlSetProp(v19, (const xmlChar *)v21, v20);
            parent = (const xmlChar *)v11->parent;
            v22 = v13;
LABEL_22:
            v27 = "catalog";
LABEL_27:
            xmlSetProp(v22, (const xmlChar *)v27, parent);
            goto LABEL_28;
          default:
            break;
        }
      }
      v11 = (xmlNodePtr)v11->_private;
    }
    while (v11);
  }
  return result;
}

xmlRMutexPtr _xmlInitializeCatalogData()
{
  xmlRMutexPtr result;

  if (getenv("XML_DEBUG_CATALOG"))
    xmlDebugCatalogs = 1;
  result = xmlNewRMutex();
  xmlCatalogMutex = (uint64_t)result;
  return result;
}

int xmlCharInRange(unsigned int val, const xmlChRangeGroup *group)
{
  int nbShortRange;
  BOOL v3;
  int v4;
  int v5;
  const xmlChSRange *shortRange;
  int v7;
  int v8;
  uint64_t v9;
  int nbLongRange;
  int v11;
  int v12;
  const xmlChLRange *longRange;
  int v14;
  int v15;
  uint64_t v16;

  if (!group)
    return 0;
  if (!HIWORD(val))
  {
    nbShortRange = group->nbShortRange;
    if (group->nbShortRange)
    {
      v3 = __OFSUB__(nbShortRange, 1);
      v4 = nbShortRange - 1;
      if (v4 < 0 == v3)
      {
        v5 = 0;
        shortRange = group->shortRange;
        do
        {
          v7 = v4 + v5;
          if (v4 + v5 < 0 != __OFADD__(v4, v5))
            ++v7;
          v8 = v7 >> 1;
          v9 = (uint64_t)v7 >> 1;
          if (shortRange[v8].low <= val)
          {
            if (shortRange[v9].high >= (unsigned __int16)val)
              return 1;
            v5 = v9 + 1;
          }
          else
          {
            v4 = v9 - 1;
          }
        }
        while (v5 <= v4);
      }
    }
    return 0;
  }
  nbLongRange = group->nbLongRange;
  if (!nbLongRange)
    return 0;
  v3 = __OFSUB__(nbLongRange, 1);
  v11 = nbLongRange - 1;
  if (v11 < 0 != v3)
    return 0;
  v12 = 0;
  longRange = group->longRange;
  while (1)
  {
    v14 = v11 + v12;
    if (v11 + v12 < 0 != __OFADD__(v11, v12))
      ++v14;
    v15 = v14 >> 1;
    v16 = (uint64_t)v14 >> 1;
    if (longRange[v15].low <= val)
      break;
    v11 = v16 - 1;
LABEL_23:
    if (v12 > v11)
      return 0;
  }
  if (longRange[v16].high < val)
  {
    v12 = v16 + 1;
    goto LABEL_23;
  }
  return 1;
}

int xmlIsBaseChar(unsigned int ch)
{
  if (ch > 0xFF)
    return xmlCharInRange(ch, &xmlIsBaseCharGroup);
  return ch - 192 < 0x17 || (ch & 0xFFFFFFDF) - 65 < 0x1A || ch - 216 < 0x1F || ch > 0xF7;
}

int xmlIsBlank(unsigned int ch)
{
  _BOOL4 v3;

  v3 = ch == 32 || ch - 9 < 2 || ch == 13;
  return ch <= 0xFF && v3;
}

int xmlIsChar(unsigned int ch)
{
  int v1;

  if (ch > 0xFF)
    return ch >> 11 < 0x1B || (ch - 57344) >> 1 < 0xFFF || ch - 0x10000 < 0x100000;
  if (ch > 0xD)
    return ch > 0x1F;
  v1 = 1;
  if (((1 << ch) & 0x2600) == 0)
    return ch > 0x1F;
  return v1;
}

int xmlIsCombining(unsigned int ch)
{
  if (ch >= 0x100)
    return xmlCharInRange(ch, &xmlIsCombiningGroup);
  else
    return 0;
}

int xmlIsDigit(unsigned int ch)
{
  if (ch > 0xFF)
    return xmlCharInRange(ch, &xmlIsDigitGroup);
  else
    return ch - 48 < 0xA;
}

int xmlIsExtender(unsigned int ch)
{
  if (ch > 0xFF)
    return xmlCharInRange(ch, &xmlIsExtenderGroup);
  else
    return ch == 183;
}

int xmlIsIdeographic(unsigned int ch)
{
  _BOOL4 v3;

  v3 = ch == 12295 || ch - 19968 < 0x51A6 || ch - 12321 < 9;
  return ch >= 0x100 && v3;
}

int xmlIsPubidChar(unsigned int ch)
{
  if (ch > 0xFF)
    return 0;
  else
    return xmlIsPubidChar_tab[ch];
}

void xmlDebugDumpString(FILE *output, const xmlChar *str)
{
  FILE *v2;
  uint64_t i;
  int v5;
  const char *v7;
  size_t v8;

  if (output)
    v2 = output;
  else
    v2 = (FILE *)*MEMORY[0x1E0C80C20];
  if (!str)
  {
    v7 = "(NULL)";
    v8 = 6;
    goto LABEL_20;
  }
  for (i = 0; i != 40; ++i)
  {
    v5 = str[i];
    if (v5 == 32)
      goto LABEL_13;
    if (!str[i])
      return;
    if ((v5 - 9) < 2 || v5 == 13)
    {
LABEL_13:
      v5 = 32;
LABEL_14:
      fputc(v5, v2);
      continue;
    }
    if ((v5 & 0x80) == 0)
      goto LABEL_14;
    fprintf(v2, "#%X", str[i]);
  }
  v7 = "...";
  v8 = 3;
LABEL_20:
  fwrite(v7, v8, 1uLL, v2);
}

void xmlDebugDumpAttr(FILE *output, xmlAttrPtr attr, int depth)
{
  __int128 v3;
  FILE *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (output)
  {
    v16 = 0;
    v17 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 0;
    *(_QWORD *)&v3 = 0x2020202020202020;
    *((_QWORD *)&v3 + 1) = 0x2020202020202020;
    v5 = v3;
    v6 = v3;
    v7 = v3;
    v8 = v3;
    v9 = v3;
    v10 = v3;
    v4 = output;
    v11 = 538976288;
    v12 = depth;
    xmlCtxtDumpAttr((size_t)&v4, (uint64_t)attr);
  }
}

size_t xmlCtxtDumpAttr(size_t a1, uint64_t a2)
{
  size_t result;
  int v5;
  uint64_t v6;

  result = xmlCtxtDumpSpaces(a1);
  v5 = *(_DWORD *)(a1 + 144);
  if (a2)
  {
    if (!v5)
    {
      fwrite("ATTRIBUTE ", 0xAuLL, 1uLL, *(FILE **)a1);
      xmlCtxtDumpString(a1, *(_QWORD *)(a2 + 16));
      fputc(10, *(FILE **)a1);
      v6 = *(_QWORD *)(a2 + 24);
      if (v6)
      {
        ++*(_DWORD *)(a1 + 112);
        do
        {
          xmlCtxtDumpNode(a1, v6);
          v6 = *(_QWORD *)(v6 + 48);
        }
        while (v6);
        --*(_DWORD *)(a1 + 112);
      }
    }
    if (!*(_QWORD *)(a2 + 16))
      xmlDebugErr(a1, 5015, (char)"Attribute has no name");
    return xmlCtxtGenericNodeCheck(a1, a2);
  }
  else if (!v5)
  {
    return fwrite("Attr is NULL", 0xCuLL, 1uLL, *(FILE **)a1);
  }
  return result;
}

void xmlDebugDumpEntities(FILE *output, xmlDocPtr doc)
{
  __int128 v3;
  _xmlDtd *intSubset;
  xmlHashTable *entities;
  _xmlDtd *extSubset;
  xmlHashTable *v7;
  FILE *__stream;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (output)
  {
    v16 = 0;
    v20 = 0;
    v21 = 0;
    v18 = 0;
    v19 = 0;
    v17 = 0;
    *(_QWORD *)&v3 = 0x2020202020202020;
    *((_QWORD *)&v3 + 1) = 0x2020202020202020;
    v9 = v3;
    v10 = v3;
    v11 = v3;
    v12 = v3;
    v13 = v3;
    v14 = v3;
    v15 = 538976288;
    __stream = output;
    if (doc)
    {
      xmlCtxtDumpDocHead(&__stream, (uint64_t)doc);
      intSubset = doc->intSubset;
      if (intSubset && (entities = (xmlHashTable *)intSubset->entities) != 0)
      {
        if (!(_DWORD)v20)
          fwrite("Entities in internal subset\n", 0x1CuLL, 1uLL, __stream);
        xmlHashScan(entities, (xmlHashScanner)xmlCtxtDumpEntityCallback, &__stream);
      }
      else
      {
        fwrite("No entities in internal subset\n", 0x1FuLL, 1uLL, __stream);
      }
      extSubset = doc->extSubset;
      if (extSubset && (v7 = (xmlHashTable *)extSubset->entities) != 0)
      {
        if (!(_DWORD)v20)
          fwrite("Entities in external subset\n", 0x1CuLL, 1uLL, __stream);
        xmlHashScan(v7, (xmlHashScanner)xmlCtxtDumpEntityCallback, &__stream);
      }
      else if (!(_DWORD)v20)
      {
        fwrite("No entities in external subset\n", 0x1FuLL, 1uLL, __stream);
      }
    }
  }
}

void xmlDebugDumpAttrList(FILE *output, xmlAttrPtr attr, int depth)
{
  xmlAttrPtr v3;
  __int128 v4;
  FILE *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (output)
  {
    v3 = attr;
    v17 = 0;
    v18 = 0;
    v15 = 0;
    v16 = 0;
    v14 = 0;
    *(_QWORD *)&v4 = 0x2020202020202020;
    *((_QWORD *)&v4 + 1) = 0x2020202020202020;
    v6 = v4;
    v7 = v4;
    v8 = v4;
    v9 = v4;
    v10 = v4;
    v11 = v4;
    v5 = output;
    v12 = 538976288;
    for (i = depth; v3; v3 = v3->next)
      xmlCtxtDumpAttr((size_t)&v5, (uint64_t)v3);
  }
}

void xmlDebugDumpOneNode(FILE *output, xmlNodePtr node, int depth)
{
  __int128 v3;
  FILE *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (output)
  {
    v16 = 0;
    v17 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 0;
    *(_QWORD *)&v3 = 0x2020202020202020;
    *((_QWORD *)&v3 + 1) = 0x2020202020202020;
    v5 = v3;
    v6 = v3;
    v7 = v3;
    v8 = v3;
    v9 = v3;
    v10 = v3;
    v4 = output;
    v11 = 538976288;
    v12 = depth;
    xmlCtxtDumpOneNode((uint64_t)&v4, (uint64_t)node);
  }
}

_DWORD *xmlCtxtDumpOneNode(uint64_t a1, uint64_t a2)
{
  _DWORD *result;
  uint64_t v3;
  size_t v4;
  uint64_t v5;
  int v6;
  FILE *v7;
  const char *v8;
  size_t v9;
  FILE *v10;
  const char *v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  size_t v16;
  FILE *v17;
  const char *v18;
  size_t v19;
  FILE *v20;
  const char *v21;
  size_t v22;
  FILE *v23;
  const char *v24;
  FILE *v25;
  const char *v26;
  FILE *v27;
  int v28;
  _QWORD *v29;
  uint64_t v30;
  xmlEntityPtr DocEntity;
  xmlEntityPtr v32;
  FILE *v33;
  const char *v34;
  size_t v35;
  uint64_t *p_content;
  const xmlChar *v37;
  int v38;
  xmlChar *content;
  xmlElementContent *v40;
  size_t v41;
  size_t v42;
  _QWORD *v43;
  int v44;
  FILE *v45;
  int v46;
  FILE *v47;
  const char *v48;
  size_t v49;
  char buf[5001];
  uint64_t v51;

  result = (_DWORD *)MEMORY[0x1E0C80A78](a1, a2);
  v4 = (size_t)result;
  v51 = *MEMORY[0x1E0C80C00];
  if (!v3)
  {
    if (!result[36])
    {
      xmlCtxtDumpSpaces((uint64_t)result);
      v10 = *(FILE **)v4;
      v11 = "node is NULL\n";
      v12 = 13;
      return (_DWORD *)fwrite(v11, v12, 1uLL, v10);
    }
    return result;
  }
  v5 = v3;
  *((_QWORD *)result + 16) = v3;
  v6 = *(_DWORD *)(v3 + 8);
  switch(v6)
  {
    case 1:
      if (result[36])
        goto LABEL_85;
      xmlCtxtDumpSpaces((uint64_t)result);
      fwrite("ELEMENT ", 8uLL, 1uLL, *(FILE **)v4);
      v13 = *(_QWORD *)(v5 + 72);
      if (v13)
      {
        v14 = *(_QWORD *)(v13 + 24);
        if (v14)
        {
          xmlCtxtDumpString(v4, v14);
          fputc(58, *(FILE **)v4);
        }
      }
      xmlCtxtDumpString(v4, *(_QWORD *)(v5 + 16));
      goto LABEL_83;
    case 2:
      if (!result[36])
        xmlCtxtDumpSpaces((uint64_t)result);
      v7 = *(FILE **)v4;
      v8 = "Error, ATTRIBUTE found here\n";
      v9 = 28;
      goto LABEL_21;
    case 3:
      if (result[36])
        goto LABEL_85;
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(const xmlChar **)(v5 + 16) == "textnoenc")
      {
        v15 = "TEXT no enc";
        v16 = 11;
      }
      else
      {
        v15 = "TEXT";
        v16 = 4;
      }
      fwrite(v15, v16, 1uLL, *(FILE **)v4);
      if ((*(_BYTE *)(v4 + 156) & 1) != 0)
      {
        v37 = *(const xmlChar **)(v5 + 80);
        if (v37 == (const xmlChar *)(v5 + 88))
        {
          v17 = *(FILE **)v4;
          v18 = " compact\n";
LABEL_42:
          v19 = 9;
        }
        else
        {
          v38 = xmlDictOwns(*(xmlDictPtr *)(v4 + 136), v37);
          v17 = *(FILE **)v4;
          if (v38 != 1)
          {
            v27 = *(FILE **)v4;
            goto LABEL_84;
          }
          v18 = " interned\n";
          v19 = 10;
        }
LABEL_43:
        fwrite(v18, v19, 1uLL, v17);
        goto LABEL_85;
      }
LABEL_83:
      v27 = *(FILE **)v4;
LABEL_84:
      fputc(10, v27);
LABEL_85:
      if (!*(_QWORD *)(v5 + 64))
      {
        if (!*(_DWORD *)(v4 + 144))
          xmlCtxtDumpSpaces(v4);
        fwrite("PBM: doc == NULL !!!\n", 0x15uLL, 1uLL, *(FILE **)v4);
      }
      ++*(_DWORD *)(v4 + 112);
      v28 = *(_DWORD *)(v5 + 8);
      if (v28 == 1)
      {
        v29 = *(_QWORD **)(v5 + 96);
        if (!v29)
          goto LABEL_93;
        do
        {
          xmlCtxtDumpNamespace(v4, (uint64_t)v29);
          v29 = (_QWORD *)*v29;
        }
        while (v29);
        v28 = *(_DWORD *)(v5 + 8);
        if (v28 == 1)
        {
LABEL_93:
          v30 = *(_QWORD *)(v5 + 88);
          if (!v30)
            goto LABEL_105;
          do
          {
            xmlCtxtDumpAttr(v4, v30);
            v30 = *(_QWORD *)(v30 + 48);
          }
          while (v30);
          v28 = *(_DWORD *)(v5 + 8);
        }
      }
      if (v28 != 1)
      {
        if (v28 == 5)
        {
          DocEntity = xmlGetDocEntity(*(const xmlDoc **)(v5 + 64), *(const xmlChar **)(v5 + 16));
          if (!DocEntity)
            goto LABEL_105;
          v32 = DocEntity;
          xmlCtxtDumpSpaces(v4);
          if (*(_DWORD *)(v4 + 144))
            goto LABEL_105;
          switch(v32->etype)
          {
            case XML_INTERNAL_GENERAL_ENTITY:
              v33 = *(FILE **)v4;
              v34 = "INTERNAL_GENERAL_ENTITY ";
              v35 = 24;
              goto LABEL_116;
            case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
              v33 = *(FILE **)v4;
              v34 = "EXTERNAL_GENERAL_PARSED_ENTITY ";
              v35 = 31;
              goto LABEL_116;
            case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
              v33 = *(FILE **)v4;
              v34 = "EXTERNAL_GENERAL_UNPARSED_ENTITY ";
              v35 = 33;
              goto LABEL_116;
            case XML_INTERNAL_PARAMETER_ENTITY:
              v33 = *(FILE **)v4;
              v34 = "INTERNAL_PARAMETER_ENTITY ";
              goto LABEL_115;
            case XML_EXTERNAL_PARAMETER_ENTITY:
              v33 = *(FILE **)v4;
              v34 = "EXTERNAL_PARAMETER_ENTITY ";
LABEL_115:
              v35 = 26;
LABEL_116:
              fwrite(v34, v35, 1uLL, v33);
              break;
            default:
              fprintf(*(FILE **)v4, "ENTITY_%d ! ", v32->etype);
              break;
          }
          fprintf(*(FILE **)v4, "%s\n", (const char *)v32->name);
          if (v32->ExternalID)
          {
            xmlCtxtDumpSpaces(v4);
            fprintf(*(FILE **)v4, "ExternalID=%s\n", (const char *)v32->ExternalID);
          }
          if (v32->SystemID)
          {
            xmlCtxtDumpSpaces(v4);
            fprintf(*(FILE **)v4, "SystemID=%s\n", (const char *)v32->SystemID);
          }
          if (v32->URI)
          {
            xmlCtxtDumpSpaces(v4);
            fprintf(*(FILE **)v4, "URI=%s\n", (const char *)v32->URI);
          }
          content = v32->content;
          p_content = (uint64_t *)&v32->content;
          if (!content)
            goto LABEL_105;
        }
        else
        {
          p_content = (uint64_t *)(v5 + 80);
          if (!*(_QWORD *)(v5 + 80) || *(_DWORD *)(v4 + 144))
            goto LABEL_105;
        }
        xmlCtxtDumpSpaces(v4);
        fwrite("content=", 8uLL, 1uLL, *(FILE **)v4);
        xmlCtxtDumpString(v4, *p_content);
        fputc(10, *(FILE **)v4);
      }
LABEL_105:
      --*(_DWORD *)(v4 + 112);
      return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
    case 4:
      if (result[36])
        goto LABEL_85;
      xmlCtxtDumpSpaces((uint64_t)result);
      v17 = *(FILE **)v4;
      v18 = "CDATA_SECTION\n";
      goto LABEL_39;
    case 5:
      if (!result[36])
      {
        xmlCtxtDumpSpaces((uint64_t)result);
        fprintf(*(FILE **)v4, "ENTITY_REF(%s)\n");
      }
      goto LABEL_85;
    case 6:
      if (result[36])
        goto LABEL_85;
      xmlCtxtDumpSpaces((uint64_t)result);
      v17 = *(FILE **)v4;
      v18 = "ENTITY\n";
      v19 = 7;
      goto LABEL_43;
    case 7:
      if (!result[36])
      {
        xmlCtxtDumpSpaces((uint64_t)result);
        fprintf(*(FILE **)v4, "PI %s\n");
      }
      goto LABEL_85;
    case 8:
      if (result[36])
        goto LABEL_85;
      xmlCtxtDumpSpaces((uint64_t)result);
      v17 = *(FILE **)v4;
      v18 = "COMMENT\n";
      v19 = 8;
      goto LABEL_43;
    case 9:
    case 13:
      if (!result[36])
        xmlCtxtDumpSpaces((uint64_t)result);
      v7 = *(FILE **)v4;
      v8 = "Error, DOCUMENT found here\n";
      v9 = 27;
LABEL_21:
      fwrite(v8, v9, 1uLL, v7);
      return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
    case 10:
      if (result[36])
        goto LABEL_85;
      xmlCtxtDumpSpaces((uint64_t)result);
      v17 = *(FILE **)v4;
      v18 = "DOCUMENT_TYPE\n";
      goto LABEL_39;
    case 11:
      if (result[36])
        goto LABEL_85;
      xmlCtxtDumpSpaces((uint64_t)result);
      v17 = *(FILE **)v4;
      v18 = "DOCUMENT_FRAG\n";
LABEL_39:
      v19 = 14;
      goto LABEL_43;
    case 12:
      if (result[36])
        goto LABEL_85;
      xmlCtxtDumpSpaces((uint64_t)result);
      v17 = *(FILE **)v4;
      v18 = "NOTATION\n";
      goto LABEL_42;
    case 14:
      return xmlCtxtDumpDtdNode((uint64_t)result, v3);
    case 15:
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(_DWORD *)(v5 + 8) != 15)
        return xmlDebugErr(v4, 5025, (char)"Node is not an element declaration");
      if (*(_QWORD *)(v5 + 16))
      {
        if (!*(_DWORD *)(v4 + 144))
        {
          fwrite("ELEMDECL(", 9uLL, 1uLL, *(FILE **)v4);
          xmlCtxtDumpString(v4, *(_QWORD *)(v5 + 16));
          fputc(41, *(FILE **)v4);
        }
      }
      else
      {
        xmlDebugErr(v4, 5015, (char)"Element declaration has no name");
      }
      if (!*(_DWORD *)(v4 + 144))
      {
        switch(*(_DWORD *)(v5 + 72))
        {
          case 0:
            v20 = *(FILE **)v4;
            v21 = ", UNDEFINED";
            v22 = 11;
            goto LABEL_130;
          case 1:
            v20 = *(FILE **)v4;
            v21 = ", EMPTY";
            v22 = 7;
            goto LABEL_130;
          case 2:
            v20 = *(FILE **)v4;
            v21 = ", ANY";
            v22 = 5;
            goto LABEL_130;
          case 3:
          case 4:
            v20 = *(FILE **)v4;
            v21 = ", MIXED ";
            v22 = 8;
LABEL_130:
            fwrite(v21, v22, 1uLL, v20);
            break;
          default:
            break;
        }
        if (*(_DWORD *)(v5 + 8) != 1)
        {
          v40 = *(xmlElementContent **)(v5 + 80);
          if (v40)
          {
            bzero(buf, 0x1389uLL);
            xmlSnprintfElementContent(buf, 5000, v40, 1);
            buf[5000] = 0;
            fputs(buf, *(FILE **)v4);
          }
        }
        fputc(10, *(FILE **)v4);
      }
      return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
    case 16:
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(_DWORD *)(v5 + 8) != 16)
        return xmlDebugErr(v4, 5024, (char)"Node is not an attribute declaration");
      if (*(_QWORD *)(v5 + 16))
      {
        if (!*(_DWORD *)(v4 + 144))
          fprintf(*(FILE **)v4, "ATTRDECL(%s)", *(const char **)(v5 + 16));
      }
      else
      {
        xmlDebugErr(v4, 5015, (char)"Node attribute declaration has no name");
      }
      if (*(_QWORD *)(v5 + 112))
      {
        if (!*(_DWORD *)(v4 + 144))
          fprintf(*(FILE **)v4, " for %s", *(const char **)(v5 + 112));
      }
      else
      {
        xmlDebugErr(v4, 5016, (char)"Node attribute declaration has no element name");
      }
      if (*(_DWORD *)(v4 + 144))
        return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
      switch(*(_DWORD *)(v5 + 80))
      {
        case 1:
          v25 = *(FILE **)v4;
          v26 = " CDATA";
          goto LABEL_153;
        case 2:
          v25 = *(FILE **)v4;
          v26 = " ID";
          v42 = 3;
          goto LABEL_163;
        case 3:
          v25 = *(FILE **)v4;
          v26 = " IDREF";
LABEL_153:
          v42 = 6;
          goto LABEL_163;
        case 4:
          v25 = *(FILE **)v4;
          v26 = " IDREFS";
          goto LABEL_156;
        case 5:
          v25 = *(FILE **)v4;
          v26 = " ENTITY";
LABEL_156:
          v42 = 7;
          goto LABEL_163;
        case 6:
          v25 = *(FILE **)v4;
          v26 = " ENTITIES";
          goto LABEL_160;
        case 7:
          v25 = *(FILE **)v4;
          v26 = " NMTOKEN";
          v42 = 8;
          goto LABEL_163;
        case 8:
          v25 = *(FILE **)v4;
          v26 = " NMTOKENS";
LABEL_160:
          v42 = 9;
          goto LABEL_163;
        case 9:
          v25 = *(FILE **)v4;
          v26 = " ENUMERATION";
          v42 = 12;
          goto LABEL_163;
        case 0xA:
          v25 = *(FILE **)v4;
          v26 = " NOTATION ";
          v42 = 10;
LABEL_163:
          fwrite(v26, v42, 1uLL, v25);
          break;
        default:
          break;
      }
      v43 = *(_QWORD **)(v5 + 96);
      if (!v43)
        goto LABEL_173;
      v44 = 5;
      while (1)
      {
        v45 = *(FILE **)v4;
        if (v44 == 5)
          fprintf(v45, " (%s");
        else
          fprintf(v45, "|%s");
        v43 = (_QWORD *)*v43;
        if (!v43)
          break;
        if (!--v44)
        {
          fwrite("...)", 4uLL, 1uLL, *(FILE **)v4);
          goto LABEL_173;
        }
      }
      fputc(41, *(FILE **)v4);
LABEL_173:
      v46 = *(_DWORD *)(v5 + 84);
      switch(v46)
      {
        case 4:
          v47 = *(FILE **)v4;
          v48 = " FIXED";
          v49 = 6;
          break;
        case 3:
          v47 = *(FILE **)v4;
          v48 = " IMPLIED";
          v49 = 8;
          break;
        case 2:
          v47 = *(FILE **)v4;
          v48 = " REQUIRED";
          v49 = 9;
          break;
        default:
          goto LABEL_180;
      }
      fwrite(v48, v49, 1uLL, v47);
LABEL_180:
      if (*(_QWORD *)(v5 + 88))
      {
        fputc(34, *(FILE **)v4);
        xmlCtxtDumpString(v4, *(_QWORD *)(v5 + 88));
        fputc(34, *(FILE **)v4);
      }
LABEL_182:
      fputc(10, *(FILE **)v4);
      return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
    case 17:
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(_DWORD *)(v5 + 8) != 17)
        return xmlDebugErr(v4, 5026, (char)"Node is not an entity declaration");
      if (*(_QWORD *)(v5 + 16))
      {
        if (!*(_DWORD *)(v4 + 144))
        {
          fwrite("ENTITYDECL(", 0xBuLL, 1uLL, *(FILE **)v4);
          xmlCtxtDumpString(v4, *(_QWORD *)(v5 + 16));
          fputc(41, *(FILE **)v4);
        }
      }
      else
      {
        xmlDebugErr(v4, 5015, (char)"Entity declaration has no name");
      }
      if (*(_DWORD *)(v4 + 144))
        return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
      switch(*(_DWORD *)(v5 + 92))
      {
        case 1:
          v23 = *(FILE **)v4;
          v24 = ", internal\n";
          goto LABEL_138;
        case 2:
          v23 = *(FILE **)v4;
          v24 = ", external parsed\n";
          v41 = 18;
          goto LABEL_142;
        case 3:
          v23 = *(FILE **)v4;
          v24 = ", unparsed\n";
LABEL_138:
          v41 = 11;
          goto LABEL_142;
        case 4:
          v23 = *(FILE **)v4;
          v24 = ", parameter\n";
          v41 = 12;
          goto LABEL_142;
        case 5:
          v23 = *(FILE **)v4;
          v24 = ", external parameter\n";
          v41 = 21;
          goto LABEL_142;
        case 6:
          v23 = *(FILE **)v4;
          v24 = ", predefined\n";
          v41 = 13;
LABEL_142:
          fwrite(v24, v41, 1uLL, v23);
          break;
        default:
          break;
      }
      if (*(_QWORD *)(v5 + 96))
      {
        xmlCtxtDumpSpaces(v4);
        fprintf(*(FILE **)v4, " ExternalID=%s\n", *(const char **)(v5 + 96));
      }
      if (*(_QWORD *)(v5 + 104))
      {
        xmlCtxtDumpSpaces(v4);
        fprintf(*(FILE **)v4, " SystemID=%s\n", *(const char **)(v5 + 104));
      }
      if (*(_QWORD *)(v5 + 120))
      {
        xmlCtxtDumpSpaces(v4);
        fprintf(*(FILE **)v4, " URI=%s\n", *(const char **)(v5 + 120));
      }
      if (!*(_QWORD *)(v5 + 80))
        return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
      xmlCtxtDumpSpaces(v4);
      fwrite(" content=", 9uLL, 1uLL, *(FILE **)v4);
      xmlCtxtDumpString(v4, *(_QWORD *)(v5 + 80));
      goto LABEL_182;
    case 18:
      return xmlCtxtDumpNamespace((size_t)result, v3);
    case 19:
      if (result[36])
        return result;
      xmlCtxtDumpSpaces((uint64_t)result);
      v10 = *(FILE **)v4;
      v11 = "INCLUDE START\n";
      v12 = 14;
      return (_DWORD *)fwrite(v11, v12, 1uLL, v10);
    case 20:
      if (result[36])
        return result;
      xmlCtxtDumpSpaces((uint64_t)result);
      v10 = *(FILE **)v4;
      v11 = "INCLUDE END\n";
      v12 = 12;
      return (_DWORD *)fwrite(v11, v12, 1uLL, v10);
    default:
      if (!result[36])
      {
        xmlCtxtDumpSpaces((uint64_t)result);
        v6 = *(_DWORD *)(v5 + 8);
      }
      return xmlDebugErr3(v4, 5011, "Unknown node type %d\n", v6);
  }
}

void xmlDebugDumpNode(FILE *output, xmlNodePtr node, int depth)
{
  FILE *v3;
  __int128 v4;
  FILE *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13 = 0;
  v3 = (FILE *)*MEMORY[0x1E0C80C20];
  if (output)
    v3 = output;
  v17 = 0;
  v18 = 0;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  *(_QWORD *)&v4 = 0x2020202020202020;
  *((_QWORD *)&v4 + 1) = 0x2020202020202020;
  v6 = v4;
  v7 = v4;
  v8 = v4;
  v9 = v4;
  v10 = v4;
  v11 = v4;
  v5 = v3;
  LODWORD(v12) = 538976288;
  LODWORD(v13) = depth;
  xmlCtxtDumpNode(&v5, (uint64_t)node);
}

FILE **xmlCtxtDumpNode(FILE **result, uint64_t a2)
{
  FILE **v2;
  int v4;
  uint64_t v5;

  v2 = result;
  if (a2)
  {
    result = (FILE **)xmlCtxtDumpOneNode((uint64_t)result, a2);
    v4 = *(_DWORD *)(a2 + 8);
    if (v4 != 18)
    {
      v5 = *(_QWORD *)(a2 + 24);
      if (v4 != 5 && v5 != 0)
      {
        ++*((_DWORD *)v2 + 28);
        do
        {
          result = (FILE **)xmlCtxtDumpNode(v2, v5);
          v5 = *(_QWORD *)(v5 + 48);
        }
        while (v5);
        --*((_DWORD *)v2 + 28);
      }
    }
  }
  else if (!*((_DWORD *)result + 36))
  {
    xmlCtxtDumpSpaces((uint64_t)result);
    return (FILE **)fwrite("node is NULL\n", 0xDuLL, 1uLL, *v2);
  }
  return result;
}

void xmlDebugDumpNodeList(FILE *output, xmlNodePtr node, int depth)
{
  FILE *v3;
  __int128 v4;
  xmlNodePtr v5;
  FILE *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 0;
  v3 = (FILE *)*MEMORY[0x1E0C80C20];
  if (output)
    v3 = output;
  v18 = 0;
  v19 = 0;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  *(_QWORD *)&v4 = 0x2020202020202020;
  *((_QWORD *)&v4 + 1) = 0x2020202020202020;
  v7 = v4;
  v8 = v4;
  v9 = v4;
  v10 = v4;
  v11 = v4;
  v12 = v4;
  v6 = v3;
  LODWORD(v13) = 538976288;
  LODWORD(v14) = depth;
  if (node)
  {
    v5 = node;
    do
    {
      xmlCtxtDumpNode(&v6, (uint64_t)v5);
      v5 = v5->next;
    }
    while (v5);
  }
}

void xmlDebugDumpDocumentHead(FILE *output, xmlDocPtr doc)
{
  FILE *v2;
  __int128 v3;
  FILE *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v12 = 0;
  v2 = (FILE *)*MEMORY[0x1E0C80C20];
  if (output)
    v2 = output;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  *(_QWORD *)&v3 = 0x2020202020202020;
  *((_QWORD *)&v3 + 1) = 0x2020202020202020;
  v5 = v3;
  v6 = v3;
  v7 = v3;
  v8 = v3;
  v9 = v3;
  v10 = v3;
  LODWORD(v11) = 538976288;
  v16 = xmmword_1B0861FC0;
  v4 = v2;
  xmlCtxtDumpDocumentHead((size_t)&v4, (uint64_t)doc);
}

size_t xmlCtxtDumpDocumentHead(size_t result, uint64_t a2)
{
  size_t v3;
  _QWORD *i;

  if (a2)
  {
    v3 = result;
    result = (size_t)xmlCtxtDumpDocHead((_DWORD *)result, a2);
    if (!*(_DWORD *)(v3 + 144))
    {
      if (*(_QWORD *)(a2 + 16))
      {
        fwrite("name=", 5uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(_QWORD *)(a2 + 16));
        result = fputc(10, *(FILE **)v3);
      }
      if (*(_QWORD *)(a2 + 104))
      {
        fwrite("version=", 8uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(_QWORD *)(a2 + 104));
        result = fputc(10, *(FILE **)v3);
      }
      if (*(_QWORD *)(a2 + 112))
      {
        fwrite("encoding=", 9uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(_QWORD *)(a2 + 112));
        result = fputc(10, *(FILE **)v3);
      }
      if (*(_QWORD *)(a2 + 136))
      {
        fwrite("URL=", 4uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(_QWORD *)(a2 + 136));
        result = fputc(10, *(FILE **)v3);
      }
      if (*(_DWORD *)(a2 + 76))
        result = fwrite("standalone=true\n", 0x10uLL, 1uLL, *(FILE **)v3);
    }
    for (i = *(_QWORD **)(a2 + 96); i; i = (_QWORD *)*i)
      result = (size_t)xmlCtxtDumpNamespace(v3, (uint64_t)i);
  }
  return result;
}

void xmlDebugDumpDocument(FILE *output, xmlDocPtr doc)
{
  FILE *v2;
  __int128 v3;
  FILE *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v12 = 0;
  v2 = (FILE *)*MEMORY[0x1E0C80C20];
  if (output)
    v2 = output;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  *(_QWORD *)&v3 = 0x2020202020202020;
  *((_QWORD *)&v3 + 1) = 0x2020202020202020;
  v5 = v3;
  v6 = v3;
  v7 = v3;
  v8 = v3;
  v9 = v3;
  v10 = v3;
  LODWORD(v11) = 538976288;
  v16 = xmmword_1B0861FC0;
  v4 = v2;
  xmlCtxtDumpDocument((size_t)&v4, (uint64_t)doc);
}

size_t xmlCtxtDumpDocument(size_t result, uint64_t a2)
{
  size_t v2;
  uint64_t v4;

  v2 = result;
  if (a2)
  {
    result = xmlCtxtDumpDocumentHead(result, a2);
    if ((*(_DWORD *)(a2 + 8) | 4) == 0xD)
    {
      v4 = *(_QWORD *)(a2 + 24);
      if (v4)
      {
        ++*(_DWORD *)(v2 + 112);
        do
        {
          result = (size_t)xmlCtxtDumpNode((FILE **)v2, v4);
          v4 = *(_QWORD *)(v4 + 48);
        }
        while (v4);
        --*(_DWORD *)(v2 + 112);
      }
    }
  }
  else if (!*(_DWORD *)(result + 144))
  {
    return fwrite("DOCUMENT == NULL !\n", 0x13uLL, 1uLL, *(FILE **)result);
  }
  return result;
}

void xmlDebugDumpDTD(FILE *output, xmlDtdPtr dtd)
{
  FILE *v2;
  __int128 v3;
  _xmlNode *children;
  const char *v6;
  size_t v7;
  FILE *__stream;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v16 = 0;
  if (output)
    v2 = output;
  else
    v2 = (FILE *)*MEMORY[0x1E0C80C20];
  v18 = 0;
  v19 = 0;
  v17 = 0;
  *(_QWORD *)&v3 = 0x2020202020202020;
  *((_QWORD *)&v3 + 1) = 0x2020202020202020;
  v9 = v3;
  v10 = v3;
  v11 = v3;
  v12 = v3;
  v13 = v3;
  v14 = v3;
  LODWORD(v15) = 538976288;
  v20 = xmmword_1B0861FC0;
  __stream = v2;
  if (!dtd)
  {
    v6 = "DTD is NULL\n";
    v7 = 12;
LABEL_11:
    fwrite(v6, v7, 1uLL, v2);
    return;
  }
  xmlCtxtDumpDtdNode((uint64_t)&__stream, (uint64_t)dtd);
  children = dtd->children;
  if (!children)
  {
    v2 = __stream;
    v6 = "    DTD is empty\n";
    v7 = 17;
    goto LABEL_11;
  }
  LODWORD(v16) = v16 + 1;
  do
  {
    xmlCtxtDumpNode(&__stream, (uint64_t)children);
    children = children->next;
  }
  while (children);
}

int xmlDebugCheckDocument(FILE *output, xmlDocPtr doc)
{
  FILE *v2;
  __int128 v3;
  FILE *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13 = 0;
  v2 = (FILE *)*MEMORY[0x1E0C80C20];
  if (output)
    v2 = output;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  *(_QWORD *)&v3 = 0x2020202020202020;
  *((_QWORD *)&v3 + 1) = 0x2020202020202020;
  v6 = v3;
  v7 = v3;
  v8 = v3;
  v9 = v3;
  v10 = v3;
  v11 = v3;
  LODWORD(v12) = 538976288;
  v5 = v2;
  v17 = xmmword_1B0861FD0;
  xmlCtxtDumpDocument((size_t)&v5, (uint64_t)doc);
  return DWORD1(v17);
}

int xmlLsCountNode(xmlNodePtr node)
{
  _xmlNode *children;

  if (node)
  {
    switch(node->type)
    {
      case XML_ELEMENT_NODE:
      case XML_ATTRIBUTE_NODE:
      case XML_DOCUMENT_NODE:
      case XML_HTML_DOCUMENT_NODE:
      case XML_DOCB_DOCUMENT_NODE:
        children = node->children;
        if (!children)
          goto LABEL_11;
        LODWORD(node) = 0;
        do
        {
          children = children->next;
          LODWORD(node) = (_DWORD)node + 1;
        }
        while (children);
        break;
      case XML_TEXT_NODE:
      case XML_CDATA_SECTION_NODE:
      case XML_PI_NODE:
      case XML_COMMENT_NODE:
        node = (xmlNodePtr)node->content;
        if (node)
          LODWORD(node) = xmlStrlen((const xmlChar *)node);
        break;
      case XML_ENTITY_REF_NODE:
      case XML_ENTITY_NODE:
      case XML_DOCUMENT_TYPE_NODE:
      case XML_DOCUMENT_FRAG_NODE:
      case XML_NOTATION_NODE:
      case XML_DTD_NODE:
      case XML_ELEMENT_DECL:
      case XML_ATTRIBUTE_DECL:
      case XML_ENTITY_DECL:
      case XML_NAMESPACE_DECL:
      case XML_XINCLUDE_START:
      case XML_XINCLUDE_END:
        LODWORD(node) = 1;
        break;
      default:
LABEL_11:
        LODWORD(node) = 0;
        break;
    }
  }
  return (int)node;
}

void xmlLsOneNode(FILE *output, xmlNodePtr node)
{
  unsigned __int32 v4;
  int v5;
  int v6;
  int v7;
  int v8;
  const char *name;
  xmlNs *ns;
  const char *prefix;
  xmlChar *content;

  if (output)
  {
    if (node)
    {
      v4 = node->type - 1;
      if (v4 > 0x11)
        v5 = 63;
      else
        v5 = dword_1B0861F74[v4];
      fputc(v5, output);
      if (node->type != XML_NAMESPACE_DECL)
      {
        if (node->properties)
          v6 = 97;
        else
          v6 = 45;
        fputc(v6, output);
        if (node->nsDef)
          v7 = 110;
        else
          v7 = 45;
        fputc(v7, output);
      }
      v8 = xmlLsCountNode(node);
      fprintf(output, " %8d ", v8);
      switch(node->type)
      {
        case XML_ELEMENT_NODE:
          name = (const char *)node->name;
          if (name)
          {
            ns = node->ns;
            if (ns)
            {
              prefix = (const char *)ns->prefix;
              if (prefix)
              {
                fprintf(output, "%s:", prefix);
                name = (const char *)node->name;
              }
            }
            goto LABEL_18;
          }
          break;
        case XML_TEXT_NODE:
          content = node->content;
          if (content)
            xmlDebugDumpString(output, content);
          break;
        case XML_CDATA_SECTION_NODE:
        case XML_COMMENT_NODE:
        case XML_DOCUMENT_NODE:
        case XML_DOCUMENT_TYPE_NODE:
        case XML_DOCUMENT_FRAG_NODE:
        case XML_NOTATION_NODE:
        case XML_HTML_DOCUMENT_NODE:
          break;
        case XML_NAMESPACE_DECL:
          if (node->children)
            fprintf(output, "%s -> %s");
          else
            fprintf(output, "default -> %s");
          break;
        default:
          name = (const char *)node->name;
          if (name)
LABEL_18:
            fputs(name, output);
          break;
      }
      fputc(10, output);
    }
    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, output);
    }
  }
}

const char *__cdecl xmlBoolToText(int BOOLval)
{
  if (BOOLval)
    return "True";
  else
    return "False";
}

void xmlShellPrintXPathError(int errorType, const char *arg)
{
  char *v2;
  xmlGenericErrorFunc v3;
  void **v4;

  if (errorType <= 9 && ((0x3FDu >> errorType) & 1) != 0)
  {
    v2 = off_1E616CC98[errorType];
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, v2);
  }
}

void xmlShellPrintNode(xmlNodePtr node)
{
  FILE *v1;
  xmlElementType type;

  if (node)
  {
    v1 = (FILE *)*MEMORY[0x1E0C80C20];
    type = node->type;
    if (type == XML_ATTRIBUTE_NODE)
    {
      xmlDebugDumpAttrList((FILE *)*MEMORY[0x1E0C80C20], (xmlAttrPtr)node, 0);
    }
    else if (type == XML_DOCUMENT_NODE)
    {
      xmlDocDump((FILE *)*MEMORY[0x1E0C80C20], (xmlDocPtr)node);
    }
    else
    {
      xmlElemDump((FILE *)*MEMORY[0x1E0C80C20], node->doc, node);
    }
    fputc(10, v1);
  }
}

int xmlShellList(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  xmlElementType type;
  _xmlNode *children;

  if (ctxt)
  {
    if (node)
    {
      type = node->type;
      if (type == XML_DOCUMENT_NODE || type == XML_HTML_DOCUMENT_NODE)
      {
        children = node->children;
        if (!children)
          return 0;
      }
      else if (type == XML_NAMESPACE_DECL || (children = node->children) == 0)
      {
        xmlLsOneNode(ctxt->output, node);
        return 0;
      }
      do
      {
        xmlLsOneNode(ctxt->output, children);
        children = children->next;
      }
      while (children);
    }
    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, ctxt->output);
    }
  }
  return 0;
}

int xmlShellBase(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  xmlChar *Base;
  FILE *output;
  xmlChar *v7;
  const char *v8;
  size_t v9;

  if (ctxt)
  {
    if (node)
    {
      Base = xmlNodeGetBase(node->doc, node);
      output = ctxt->output;
      if (Base)
      {
        v7 = Base;
        fprintf(output, "%s\n", (const char *)Base);
        xmlFree(v7);
        return 0;
      }
      v8 = " No base found !!!\n";
      v9 = 19;
    }
    else
    {
      output = ctxt->output;
      v8 = "NULL\n";
      v9 = 5;
    }
    fwrite(v8, v9, 1uLL, output);
  }
  return 0;
}

int xmlShellDir(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  xmlElementType type;
  FILE *output;
  __int128 v7;
  FILE *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (ctxt)
  {
    if (node)
    {
      type = node->type;
      if (type == XML_ATTRIBUTE_NODE)
      {
        xmlDebugDumpAttr(ctxt->output, (xmlAttrPtr)node, 0);
      }
      else if (type == XML_HTML_DOCUMENT_NODE || type == XML_DOCUMENT_NODE)
      {
        output = ctxt->output;
        v16 = 0;
        v17 = 0;
        if (!output)
          output = (FILE *)*MEMORY[0x1E0C80C20];
        v18 = 0u;
        v19 = 0u;
        v20 = 0x100000000;
        *(_QWORD *)&v7 = 0x2020202020202020;
        *((_QWORD *)&v7 + 1) = 0x2020202020202020;
        v10 = v7;
        v11 = v7;
        v12 = v7;
        v13 = v7;
        v14 = v7;
        v15 = v7;
        LODWORD(v16) = 538976288;
        v9 = output;
        xmlCtxtDumpDocumentHead((size_t)&v9, (uint64_t)node);
      }
      else
      {
        xmlDebugDumpOneNode(ctxt->output, node, 0);
      }
    }
    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, ctxt->output);
    }
  }
  return 0;
}

int xmlShellCat(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  xmlDocPtr doc;
  xmlElementType type;
  FILE *output;

  if (ctxt)
  {
    if (node)
    {
      doc = ctxt->doc;
      type = node->type;
      output = ctxt->output;
      if (doc->type == XML_HTML_DOCUMENT_NODE)
      {
        if (type == XML_HTML_DOCUMENT_NODE)
          htmlDocDump(output, (xmlDocPtr)node);
        else
          htmlNodeDumpFile(output, doc, node);
      }
      else if (type == XML_DOCUMENT_NODE)
      {
        xmlDocDump(output, (xmlDocPtr)node);
      }
      else
      {
        xmlElemDump(output, doc, node);
      }
      fputc(10, ctxt->output);
    }
    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, ctxt->output);
    }
  }
  return 0;
}

int xmlShellLoad(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node, xmlNodePtr node2)
{
  int result;
  xmlDocPtr doc;
  htmlDocPtr File;
  xmlDoc *v9;
  char *v10;

  result = -1;
  if (ctxt && filename)
  {
    doc = ctxt->doc;
    if (doc && doc->type == XML_HTML_DOCUMENT_NODE)
      File = htmlParseFile(filename, 0);
    else
      File = xmlReadFile(filename, 0, 0);
    v9 = File;
    if (File)
    {
      if (ctxt->loaded == 1)
        xmlFreeDoc(ctxt->doc);
      ctxt->loaded = 1;
      xmlXPathFreeContext(ctxt->pctxt);
      xmlFree(ctxt->filename);
      ctxt->doc = v9;
      ctxt->node = (xmlNodePtr)v9;
      ctxt->pctxt = xmlXPathNewContext(v9);
      v10 = (char *)xmlCanonicPath((const xmlChar *)filename);
      result = 0;
      ctxt->filename = v10;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

int xmlShellWrite(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node, xmlNodePtr node2)
{
  int result;
  xmlElementType type;
  FILE *v9;
  FILE *v10;
  xmlGenericErrorFunc v11;
  void **v12;

  result = -1;
  if (filename && node && *filename)
  {
    type = node->type;
    if (type == XML_HTML_DOCUMENT_NODE)
    {
      if (htmlSaveFile(filename, ctxt->doc) < 0)
        goto LABEL_13;
    }
    else if (type == XML_DOCUMENT_NODE)
    {
      if (xmlSaveFile(filename, ctxt->doc) <= -2)
        goto LABEL_13;
    }
    else
    {
      v9 = fopen(filename, "w");
      if (!v9)
      {
LABEL_13:
        v11 = *__xmlGenericError();
        v12 = __xmlGenericErrorContext();
        v11(*v12, "Failed to write to %s\n", filename);
        return -1;
      }
      v10 = v9;
      xmlElemDump(v9, ctxt->doc, node);
      fclose(v10);
    }
    return 0;
  }
  return result;
}

int xmlShellSave(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node, xmlNodePtr node2)
{
  xmlDocPtr doc;
  xmlElementType type;
  xmlGenericErrorFunc v7;
  void **v8;
  xmlGenericErrorFunc v10;
  void **v11;

  if (!ctxt)
    return -1;
  doc = ctxt->doc;
  if (doc)
  {
    if (filename && *filename || (filename = ctxt->filename) != 0)
    {
      type = doc->type;
      if (type == XML_HTML_DOCUMENT_NODE)
      {
        if ((htmlSaveFile(filename, doc) & 0x80000000) == 0)
          return 0;
        goto LABEL_9;
      }
      if (type == XML_DOCUMENT_NODE)
      {
        if ((xmlSaveFile(filename, doc) & 0x80000000) == 0)
          return 0;
LABEL_9:
        v7 = *__xmlGenericError();
        v8 = __xmlGenericErrorContext();
        v7(*v8, "Failed to save to %s\n", filename);
        return 0;
      }
      v10 = *__xmlGenericError();
      v11 = __xmlGenericErrorContext();
      v10(*v11, "To save to subparts of a document use the 'write' command\n");
    }
  }
  return -1;
}

int xmlShellValidate(xmlShellCtxtPtr ctxt, char *dtd, xmlNodePtr node, xmlNodePtr node2)
{
  xmlDtd *v6;
  xmlDtd *v7;
  int v8;
  xmlValidCtxt v10;

  if (!ctxt || !ctxt->doc)
    return -1;
  memset(&v10, 0, sizeof(v10));
  v10.error = *__xmlGenericError();
  v10.warning = *__xmlGenericError();
  if (!dtd || !*dtd)
    return xmlValidateDocument(&v10, ctxt->doc);
  v6 = xmlParseDTD(0, (const xmlChar *)dtd);
  if (!v6)
    return -1;
  v7 = v6;
  v8 = xmlValidateDtd(&v10, ctxt->doc, v6);
  xmlFreeDtd(v7);
  return v8;
}

int xmlShellDu(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr tree, xmlNodePtr node2)
{
  int result;
  int v7;
  xmlNodePtr v8;
  xmlElementType type;
  int v11;
  xmlNs *ns;
  const char *prefix;
  xmlNode *children;
  _xmlNode *parent;

  result = -1;
  if (!ctxt || !tree)
    return result;
  v7 = 0;
  v8 = tree;
  while (1)
  {
    type = v8->type;
    if (type == XML_HTML_DOCUMENT_NODE || type == XML_DOCUMENT_NODE)
    {
      fwrite("/\n", 2uLL, 1uLL, ctxt->output);
    }
    else
    {
      if (type != XML_ELEMENT_NODE)
        goto LABEL_18;
      v11 = v7;
      if (v7 >= 1)
      {
        do
        {
          fwrite("  ", 2uLL, 1uLL, ctxt->output);
          --v11;
        }
        while (v11);
      }
      ns = v8->ns;
      if (ns)
      {
        prefix = (const char *)ns->prefix;
        if (prefix)
          fprintf(ctxt->output, "%s:", prefix);
      }
      fprintf(ctxt->output, "%s\n", (const char *)v8->name);
    }
    type = v8->type;
LABEL_18:
    if ((type | 4) == 0xD)
    {
      children = v8->children;
      goto LABEL_20;
    }
    children = v8->children;
    if (type != XML_ENTITY_REF_NODE && children != 0)
    {
      ++v7;
      goto LABEL_20;
    }
    if (v8 == tree)
      return 0;
    children = v8->next;
    if (!children)
      break;
LABEL_20:
    v8 = children;
    if (!children)
      return 0;
  }
  while (v8 != tree)
  {
    parent = v8->parent;
    if (parent)
      v8 = v8->parent;
    v7 -= parent != 0;
    if (v8 == tree)
    {
      children = 0;
LABEL_37:
      if (children != tree)
        goto LABEL_20;
      return 0;
    }
    children = v8->next;
    if (!children)
    {
      children = v8->parent;
      if (children)
        continue;
    }
    goto LABEL_37;
  }
  return 0;
}

int xmlShellPwd(xmlShellCtxtPtr ctxt, char *buffer, xmlNodePtr node, xmlNodePtr node2)
{
  int result;
  xmlChar *NodePath;
  xmlChar *v7;

  result = -1;
  if (buffer && node)
  {
    NodePath = xmlGetNodePath(node);
    if (NodePath)
    {
      v7 = NodePath;
      snprintf(buffer, 0x1F3uLL, "%s", (const char *)NodePath);
      buffer[499] = 48;
      xmlFree(v7);
      return 0;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

void xmlShell(xmlDocPtr doc, char *filename, xmlShellReadlineFunc input, FILE *output)
{
  FILE *v8;
  _DWORD *v9;
  uint64_t v10;
  FILE *v11;
  xmlDoc *v12;
  xmlXPathContextPtr v13;
  uint64_t v14;
  uint64_t v15;
  xmlShellCtxt *v16;
  char *v17;
  xmlNode *v18;
  xmlNode *v19;
  xmlShellCtxt *v20;
  xmlShellCtxt *i;
  int filename_low;
  uint64_t v23;
  unsigned __int8 *v24;
  unsigned __int8 *j;
  int v26;
  uint64_t k;
  unsigned __int8 *v29;
  xmlGenericErrorFunc v34;
  void *v35;
  const char *v36;
  xmlRelaxNGParserCtxt *v37;
  void (*v38)(void *, const char *, ...);
  xmlGenericErrorFunc *v39;
  xmlRelaxNG *v40;
  xmlRelaxNGValidCtxt *v41;
  void (*v42)(void *, const char *, ...);
  xmlGenericErrorFunc *v43;
  int v44;
  int v45;
  FILE *v46;
  xmlGenericErrorFunc v47;
  void **v48;
  uint64_t v49;
  int v50;
  FILE *v51;
  xmlChar *v52;
  char *v53;
  xmlNode *v54;
  xmlShellCtxt *v55;
  xmlNode *v56;
  FILE *v57;
  xmlChar *NodePath;
  uint64_t v59;
  uint64_t v61;
  FILE *v62;
  int v63;
  xmlNode *v64;
  xmlXPathContext *v65;
  xmlXPathObjectPtr v66;
  char *v67;
  xmlNode *v68;
  xmlXPathObject *v69;
  const char *v70;
  xmlNodePtr RootElement;
  xmlXPathContext *v72;
  xmlXPathObject *v73;
  _BOOL4 v74;
  xmlNode *v75;
  xmlXPathContext *v76;
  xmlXPathObjectPtr v77;
  char *v78;
  xmlNode *v79;
  int *v80;
  uint64_t v81;
  xmlNode *v82;
  xmlGenericErrorFunc v83;
  void **v84;
  xmlGenericErrorFunc v85;
  void **v86;
  int *p_nodeNr;
  uint64_t v88;
  xmlNode *v89;
  xmlXPathContext *v90;
  xmlXPathObjectPtr v91;
  xmlNode *v92;
  xmlXPathObjectPtr v93;
  const char *v94;
  int *v95;
  uint64_t v96;
  xmlXPathContext *v97;
  int v98;
  uint64_t v99;
  xmlXPathObjectPtr v100;
  xmlXPathObject *v101;
  xmlGenericErrorFunc v102;
  void *v103;
  xmlNode *v104;
  xmlXPathContext *v105;
  xmlXPathObjectPtr v106;
  char *v107;
  xmlNode *v108;
  xmlGenericErrorFunc v109;
  void **v110;
  xmlGenericErrorFunc v111;
  void **v112;
  xmlXPathObject *v113;
  xmlGenericErrorFunc v114;
  void *v115;
  xmlNodeSetPtr nodesetval;
  xmlNodePtr v117;
  xmlGenericErrorFunc v118;
  void **v119;
  xmlGenericErrorFunc v120;
  void *v121;
  xmlGenericErrorFunc v122;
  void *v123;
  xmlGenericErrorFunc v124;
  void *v125;
  xmlGenericErrorFunc v126;
  void *v127;
  xmlGenericErrorFunc v128;
  void *v129;
  xmlGenericErrorFunc v130;
  void *v131;
  int *v132;
  uint64_t v133;
  xmlGenericErrorFunc v134;
  void *v135;
  xmlGenericErrorFunc v136;
  void *v137;
  char buffer[16];
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  int v169;
  char dtd[16];
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  _OWORD v195[6];
  int v196;
  _BYTE __str[20];
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;
  __int128 v225;
  __int128 v226;
  __int128 v227;
  uint64_t v228;

  v228 = *MEMORY[0x1E0C80C00];
  v226 = 0u;
  v227 = 0u;
  v224 = 0u;
  v225 = 0u;
  v222 = 0u;
  v223 = 0u;
  v220 = 0u;
  v221 = 0u;
  v218 = 0u;
  v219 = 0u;
  v216 = 0u;
  v217 = 0u;
  v214 = 0u;
  v215 = 0u;
  v213 = 0u;
  v212 = 0u;
  v211 = 0u;
  v210 = 0u;
  v209 = 0u;
  v208 = 0u;
  v207 = 0u;
  v206 = 0u;
  v205 = 0u;
  v204 = 0u;
  v203 = 0u;
  v202 = 0u;
  v201 = 0u;
  v200 = 0u;
  v199 = 0u;
  v198 = 0u;
  *(_OWORD *)&__str[4] = 0u;
  *(_DWORD *)__str = 540942383;
  if (!doc)
    return;
  if (!filename)
    return;
  if (!input)
    return;
  v8 = (FILE *)*MEMORY[0x1E0C80C20];
  v9 = xmlMalloc(0x38uLL);
  if (!v9)
    return;
  v10 = (uint64_t)v9;
  v196 = 0;
  memset(v195, 0, sizeof(v195));
  *(_OWORD *)dtd = 0u;
  v171 = 0u;
  v172 = 0u;
  v173 = 0u;
  v174 = 0u;
  v175 = 0u;
  v176 = 0u;
  v177 = 0u;
  v178 = 0u;
  v179 = 0u;
  v180 = 0u;
  v181 = 0u;
  v182 = 0u;
  v183 = 0u;
  v184 = 0u;
  v185 = 0u;
  v186 = 0u;
  v187 = 0u;
  v188 = 0u;
  v189 = 0u;
  v190 = 0u;
  v191 = 0u;
  v192 = 0u;
  v193 = 0u;
  v194 = 0u;
  if (output)
    v11 = output;
  else
    v11 = v8;
  v9[8] = 0;
  *((_QWORD *)v9 + 1) = doc;
  *((_QWORD *)v9 + 5) = v11;
  *((_QWORD *)v9 + 6) = input;
  *(_QWORD *)v9 = xmlStrdup((const xmlChar *)filename);
  v12 = *(xmlDoc **)(v10 + 8);
  *(_QWORD *)(v10 + 16) = v12;
  v13 = xmlXPathNewContext(v12);
  *(_QWORD *)(v10 + 24) = v13;
  if (!v13)
  {
    xmlFree((void *)v10);
    return;
  }
  while (1)
  {
    do
    {
      v14 = *(_QWORD *)(v10 + 16);
      if (v14 != *(_QWORD *)(v10 + 8))
      {
        if (!v14 || !*(_QWORD *)(v14 + 16))
        {
          strcpy(__str, "? > ");
          goto LABEL_17;
        }
        v15 = *(_QWORD *)(v14 + 72);
        if (v15 && *(_QWORD *)(v15 + 24))
        {
          snprintf(__str, 0x1F4uLL, "%s:%s > ");
          goto LABEL_17;
        }
      }
      snprintf(__str, 0x1F4uLL, "%s > ");
LABEL_17:
      HIBYTE(v227) = 0;
      v16 = (xmlShellCtxt *)(*(uint64_t (**)(_BYTE *))(v10 + 48))(__str);
      v20 = v16;
      if (!v16)
        goto LABEL_229;
      for (i = v16; ; i = (xmlShellCtxt *)((char *)i + 1))
      {
        filename_low = LOBYTE(i->filename);
        if (filename_low != 9 && filename_low != 32)
          break;
      }
      v23 = 0;
      while (filename_low > 0x20u || ((1 << filename_low) & 0x100002601) == 0)
      {
        v24 = (unsigned __int8 *)i + v23;
        *((_BYTE *)v195 + v23++) = filename_low;
        LOBYTE(filename_low) = v24[1];
      }
      *((_BYTE *)v195 + v23) = 0;
    }
    while (!(_DWORD)v23);
    for (j = (unsigned __int8 *)i + v23; ; ++j)
    {
      v26 = *j;
      if (v26 != 9 && v26 != 32)
        break;
    }
    for (k = 0; v26 > 0xDu || ((1 << v26) & 0x2401) == 0; ++k)
    {
      v29 = &j[k];
      dtd[k] = v26;
      LOBYTE(v26) = v29[1];
    }
    dtd[k] = 0;
    if (!(LODWORD(v195[0]) ^ 0x74697865 | BYTE4(v195[0]))
      || !(LODWORD(v195[0]) ^ 0x74697571 | BYTE4(v195[0]))
      || LODWORD(v195[0]) == 6650210)
    {
      break;
    }
    if (!(LODWORD(v195[0]) ^ 0x706C6568 | BYTE4(v195[0])))
    {
      fwrite("\tbase         display XML base of the node\n", 0x2BuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tsetbase URI  change the XML base of the node\n", 0x2EuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tbye          leave shell\n", 0x1AuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tcat [node]   display node or current node\n", 0x2BuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tcd [path]    change directory to path or to root\n", 0x32uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tdir [path]   dumps information about the node (namespace, attributes, content)\n", 0x50uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tdu [path]    show the structure of the subtree under path or the current node\n", 0x4FuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\texit         leave shell\n", 0x1AuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\thelp         display this help\n", 0x20uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tfree         display memory usage\n", 0x23uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tload [name]  load a new document with name\n", 0x2CuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tls [path]    list contents of path or the current directory\n", 0x3DuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tset xml_fragment replace the current node content with the fragment parsed in context\n", 0x57uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\txpath expr   evaluate the XPath expression in that context and print the result\n", 0x51uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tsetns nsreg  register a namespace to a prefix in the XPath evaluation context\n", 0x4FuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\t             format for nsreg is: prefix=[nsuri] (i.e. prefix= unsets a prefix)\n", 0x51uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tsetrootns    register all namespace found on the root element\n", 0x3FuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\t             the default namespace if any uses 'defaultns' prefix\n", 0x43uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tpwd          display current working directory\n", 0x30uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\twhereis      display absolute path of [path] or current working directory\n", 0x4BuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tquit         leave shell\n", 0x1AuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tsave [name]  save this document to name or the original name\n", 0x3EuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\twrite [name] write the current node to the filename\n", 0x35uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tvalidate     check the document for errors\n", 0x2CuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\trelaxng rng  validate the document against the Relax-NG schemas\n", 0x41uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tgrep string  search for a string in the subtree\n", 0x31uLL, 1uLL, *(FILE **)(v10 + 40));
      goto LABEL_120;
    }
    if (!(*(_QWORD *)&v195[0] ^ 0x65746164696C6176 | BYTE8(v195[0])))
    {
      xmlShellValidate((xmlShellCtxtPtr)v10, dtd, v18, v19);
      goto LABEL_120;
    }
    if (!(LODWORD(v195[0]) ^ 0x64616F6C | BYTE4(v195[0])))
    {
      xmlShellLoad((xmlShellCtxtPtr)v10, dtd, v18, v19);
      goto LABEL_120;
    }
    if (*(_QWORD *)&v195[0] == 0x676E78616C6572)
    {
      v37 = xmlRelaxNGNewParserCtxt(dtd);
      v38 = *__xmlGenericError();
      v39 = __xmlGenericError();
      xmlRelaxNGSetParserErrors(v37, v38, *v39, 0);
      v40 = xmlRelaxNGParse(v37);
      xmlRelaxNGFreeParserCtxt(v37);
      if (v40)
      {
        v41 = xmlRelaxNGNewValidCtxt(v40);
        v42 = *__xmlGenericError();
        v43 = __xmlGenericError();
        xmlRelaxNGSetValidErrors(v41, v42, *v43, 0);
        v44 = xmlRelaxNGValidateDoc(v41, *(xmlDocPtr *)(v10 + 8));
        if (v44)
        {
          v45 = v44;
          v46 = (FILE *)*MEMORY[0x1E0C80C10];
          if (v45 < 1)
            fprintf(v46, "%s validation generated an internal error\n");
          else
            fprintf(v46, "%s fails to validate\n");
        }
        else
        {
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s validates\n");
        }
        xmlRelaxNGFreeValidCtxt(v41);
        xmlRelaxNGFree(v40);
      }
      else
      {
        v47 = *__xmlGenericError();
        v48 = __xmlGenericErrorContext();
        v47(*v48, "Relax-NG schema %s failed to compile\n", dtd);
      }
    }
    else
    {
      if (!(LODWORD(v195[0]) ^ 0x65766173 | BYTE4(v195[0])))
      {
        xmlShellSave((xmlShellCtxtPtr)v10, dtd, v18, v19);
        goto LABEL_120;
      }
      if (LODWORD(v195[0]) == 1953067639 && WORD2(v195[0]) == 101)
      {
        if (dtd[0])
        {
          xmlShellWrite((xmlShellCtxtPtr)v10, dtd, *(xmlNodePtr *)(v10 + 16), v19);
          goto LABEL_120;
        }
        v34 = *__xmlGenericError();
        v35 = *__xmlGenericErrorContext();
        v36 = "Write command requires a filename argument\n";
        goto LABEL_122;
      }
      if (!(LODWORD(v195[0]) ^ 0x70657267 | BYTE4(v195[0])))
      {
        v49 = *(_QWORD *)(v10 + 16);
        if (!v49)
          goto LABEL_120;
        if (!xmlStrchr((const xmlChar *)dtd, 0x3Fu)
          && !xmlStrchr((const xmlChar *)dtd, 0x2Au)
          && !xmlStrchr((const xmlChar *)dtd, 0x2Eu))
        {
          xmlStrchr((const xmlChar *)dtd, 0x5Bu);
        }
        while (2)
        {
          v50 = *(_DWORD *)(v49 + 8);
          if (v50 == 3)
          {
            if (xmlStrstr(*(const xmlChar **)(v49 + 80), (const xmlChar *)dtd))
            {
              v57 = *(FILE **)(v10 + 40);
              NodePath = xmlGetNodePath(*(const xmlNode **)(v49 + 40));
              fprintf(v57, "%s : ", (const char *)NodePath);
              v56 = *(xmlNode **)(v49 + 40);
              v55 = (xmlShellCtxt *)v10;
LABEL_97:
              xmlShellList(v55, v53, v56, v54);
            }
LABEL_98:
            v50 = *(_DWORD *)(v49 + 8);
          }
          else if (v50 == 8)
          {
            if (xmlStrstr(*(const xmlChar **)(v49 + 80), (const xmlChar *)dtd))
            {
              v51 = *(FILE **)(v10 + 40);
              v52 = xmlGetNodePath((const xmlNode *)v49);
              fprintf(v51, "%s : ", (const char *)v52);
              v55 = (xmlShellCtxt *)v10;
              v56 = (xmlNode *)v49;
              goto LABEL_97;
            }
            goto LABEL_98;
          }
          if ((v50 | 4) == 0xD)
          {
            v59 = *(_QWORD *)(v49 + 24);
          }
          else
          {
            v59 = *(_QWORD *)(v49 + 24);
            if (v50 == 5 || v59 == 0)
            {
              v59 = *(_QWORD *)(v49 + 48);
              if (!v59)
              {
                v61 = *(_QWORD *)(v49 + 40);
                while (1)
                {
                  if (v61)
                    v49 = v61;
                  v59 = *(_QWORD *)(v49 + 48);
                  if (v59)
                    break;
                  v61 = *(_QWORD *)(v49 + 40);
                  if (!v61)
                    goto LABEL_120;
                }
              }
            }
          }
          v49 = v59;
          if (!v59)
            goto LABEL_120;
          continue;
        }
      }
      if (LODWORD(v195[0]) ^ 0x65657266 | BYTE4(v195[0]))
      {
        if (LODWORD(v195[0]) == 6584176)
        {
          v169 = 0;
          v167 = 0u;
          v168 = 0u;
          v165 = 0u;
          v166 = 0u;
          v163 = 0u;
          v164 = 0u;
          v161 = 0u;
          v162 = 0u;
          v159 = 0u;
          v160 = 0u;
          v157 = 0u;
          v158 = 0u;
          v155 = 0u;
          v156 = 0u;
          v153 = 0u;
          v154 = 0u;
          v151 = 0u;
          v152 = 0u;
          v149 = 0u;
          v150 = 0u;
          v147 = 0u;
          v148 = 0u;
          v145 = 0u;
          v146 = 0u;
          v143 = 0u;
          v144 = 0u;
          v141 = 0u;
          v142 = 0u;
          v139 = 0u;
          v140 = 0u;
          *(_OWORD *)buffer = 0u;
          if (xmlShellPwd(v16, buffer, *(xmlNodePtr *)(v10 + 16), v19))
            goto LABEL_120;
LABEL_124:
          fprintf(*(FILE **)(v10 + 40), "%s\n", buffer);
          goto LABEL_120;
        }
        if (!(LOWORD(v195[0]) ^ 0x7564 | BYTE2(v195[0])))
        {
          v64 = *(xmlNode **)(v10 + 16);
          if (!dtd[0])
          {
            xmlShellDu((xmlShellCtxtPtr)v10, v17, v64, v19);
            goto LABEL_120;
          }
          v65 = *(xmlXPathContext **)(v10 + 24);
          v65->node = v64;
          v66 = xmlXPathEval((const xmlChar *)dtd, v65);
          if (v66)
          {
            v69 = v66;
            v70 = "%s: no such node\n";
            switch(v66->type)
            {
              case XPATH_UNDEFINED:
                goto LABEL_159;
              case XPATH_NODESET:
                p_nodeNr = &v66->nodesetval->nodeNr;
                if (p_nodeNr && *p_nodeNr >= 1)
                {
                  v88 = 0;
                  do
                  {
                    xmlShellDu((xmlShellCtxtPtr)v10, v67, *(xmlNodePtr *)(*((_QWORD *)p_nodeNr + 1) + 8 * v88++), v68);
                    p_nodeNr = &v69->nodesetval->nodeNr;
                  }
                  while (v88 < *p_nodeNr);
                }
                break;
              case XPATH_BOOLEAN:
LABEL_153:
                v70 = "%s is a Boolean\n";
                goto LABEL_159;
              case XPATH_NUMBER:
LABEL_154:
                v70 = "%s is a number\n";
                goto LABEL_159;
              case XPATH_STRING:
LABEL_155:
                v70 = "%s is a string\n";
                goto LABEL_159;
              case XPATH_POINT:
LABEL_156:
                v70 = "%s is a point\n";
                goto LABEL_159;
              case XPATH_RANGE:
              case XPATH_LOCATIONSET:
LABEL_128:
                v70 = "%s is a range\n";
                goto LABEL_159;
              case XPATH_USERS:
LABEL_157:
                v70 = "%s is user-defined\n";
                goto LABEL_159;
              case XPATH_XSLT_TREE:
LABEL_158:
                v70 = "%s is an XSLT value tree\n";
LABEL_159:
                v85 = *__xmlGenericError();
                v86 = __xmlGenericErrorContext();
                v85(*v86, v70);
                break;
              default:
                break;
            }
LABEL_160:
            xmlXPathFreeObject(v69);
LABEL_161:
            *(_QWORD *)(*(_QWORD *)(v10 + 24) + 8) = 0;
            goto LABEL_120;
          }
LABEL_151:
          v83 = *__xmlGenericError();
          v84 = __xmlGenericErrorContext();
          v83(*v84, "%s: no such node\n", dtd);
          goto LABEL_161;
        }
        if (!(LODWORD(v195[0]) ^ 0x65736162 | BYTE4(v195[0])))
        {
          xmlShellBase((xmlShellCtxtPtr)v10, v17, *(xmlNodePtr *)(v10 + 16), v19);
          goto LABEL_120;
        }
        if (LODWORD(v195[0]) == 7628147)
        {
          xmlShellSetContent(v10, dtd, *(xmlNode **)(v10 + 16));
          goto LABEL_120;
        }
        if (LODWORD(v195[0]) == 1853121907 && WORD2(v195[0]) == 115)
        {
          if (!dtd[0])
          {
            v34 = *__xmlGenericError();
            v35 = *__xmlGenericErrorContext();
            v36 = "setns: prefix=[nsuri] required\n";
            goto LABEL_122;
          }
          xmlShellRegisterNamespace(v10, (xmlChar *)dtd);
        }
        else
        {
          if (*(_QWORD *)&v195[0] == 0x6E746F6F72746573 && WORD4(v195[0]) == 115)
          {
            RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v10 + 8));
            xmlShellRegisterRootNamespaces(v10, (uint64_t)RootElement);
            goto LABEL_120;
          }
          if (LODWORD(v195[0]) == 1952542840 && WORD2(v195[0]) == 104)
          {
            if (!dtd[0])
            {
              v34 = *__xmlGenericError();
              v35 = *__xmlGenericErrorContext();
              v36 = "xpath: expression required\n";
              goto LABEL_122;
            }
            v72 = *(xmlXPathContext **)(v10 + 24);
            v72->node = *(xmlNodePtr *)(v10 + 16);
            v73 = xmlXPathEval((const xmlChar *)dtd, v72);
            xmlXPathDebugDumpObject(*(FILE **)(v10 + 40), v73, 0);
            xmlXPathFreeObject(v73);
          }
          else
          {
            if (*(_QWORD *)&v195[0] == 0x65736162746573)
            {
              xmlNodeSetBase(*(xmlNodePtr *)(v10 + 16), (const xmlChar *)dtd);
              goto LABEL_120;
            }
            if (!(LOWORD(v195[0]) ^ 0x736C | BYTE2(v195[0])) || LODWORD(v195[0]) == 7498084)
            {
              v74 = LODWORD(v195[0]) != 7498084;
              v75 = *(xmlNode **)(v10 + 16);
              if (dtd[0])
              {
                v76 = *(xmlXPathContext **)(v10 + 24);
                v76->node = v75;
                v77 = xmlXPathEval((const xmlChar *)dtd, v76);
                if (v77)
                {
                  v69 = v77;
                  v70 = "%s: no such node\n";
                  switch(v77->type)
                  {
                    case XPATH_UNDEFINED:
                      goto LABEL_159;
                    case XPATH_NODESET:
                      v80 = &v77->nodesetval->nodeNr;
                      if (v80 && *v80 >= 1)
                      {
                        v81 = 0;
                        do
                        {
                          v82 = *(xmlNode **)(*((_QWORD *)v80 + 1) + 8 * v81);
                          if (v74)
                            xmlShellList((xmlShellCtxtPtr)v10, v78, v82, v79);
                          else
                            xmlShellDir((xmlShellCtxtPtr)v10, v78, v82, v79);
                          ++v81;
                          v80 = &v69->nodesetval->nodeNr;
                        }
                        while (v81 < *v80);
                      }
                      break;
                    case XPATH_BOOLEAN:
                      goto LABEL_153;
                    case XPATH_NUMBER:
                      goto LABEL_154;
                    case XPATH_STRING:
                      goto LABEL_155;
                    case XPATH_POINT:
                      goto LABEL_156;
                    case XPATH_RANGE:
                    case XPATH_LOCATIONSET:
                      goto LABEL_128;
                    case XPATH_USERS:
                      goto LABEL_157;
                    case XPATH_XSLT_TREE:
                      goto LABEL_158;
                    default:
                      goto LABEL_160;
                  }
                  goto LABEL_160;
                }
                goto LABEL_151;
              }
              if (LODWORD(v195[0]) == 7498084)
                xmlShellDir((xmlShellCtxtPtr)v10, v17, v75, v19);
              else
                xmlShellList((xmlShellCtxtPtr)v10, v17, v75, v19);
            }
            else
            {
              if (*(_QWORD *)&v195[0] != 0x73696572656877)
              {
                if (LOWORD(v195[0]) ^ 0x6463 | BYTE2(v195[0]))
                {
                  if (LODWORD(v195[0]) != 7627107)
                  {
                    v34 = *__xmlGenericError();
                    v35 = *__xmlGenericErrorContext();
                    v36 = "Unknown command %s\n";
LABEL_122:
                    v34(v35, v36);
                    goto LABEL_120;
                  }
                  v104 = *(xmlNode **)(v10 + 16);
                  if (!dtd[0])
                  {
                    xmlShellCat((xmlShellCtxtPtr)v10, v17, v104, v19);
                    goto LABEL_120;
                  }
                  v105 = *(xmlXPathContext **)(v10 + 24);
                  v105->node = v104;
                  v106 = xmlXPathEval((const xmlChar *)dtd, v105);
                  if (v106)
                  {
                    v93 = v106;
                    v94 = "%s: no such node\n";
                    switch(v106->type)
                    {
                      case XPATH_UNDEFINED:
                        goto LABEL_203;
                      case XPATH_NODESET:
                        v132 = &v106->nodesetval->nodeNr;
                        if (v132 && *v132 >= 1)
                        {
                          v133 = 0;
                          do
                          {
                            if ((_DWORD)k)
                            {
                              fwrite(" -------\n", 9uLL, 1uLL, *(FILE **)(v10 + 40));
                              v132 = &v93->nodesetval->nodeNr;
                            }
                            xmlShellCat((xmlShellCtxtPtr)v10, v107, *(xmlNodePtr *)(*((_QWORD *)v132 + 1) + 8 * v133++), v108);
                            v132 = &v93->nodesetval->nodeNr;
                          }
                          while (v133 < *v132);
                        }
                        break;
                      case XPATH_BOOLEAN:
                        goto LABEL_197;
                      case XPATH_NUMBER:
                        goto LABEL_198;
                      case XPATH_STRING:
                        goto LABEL_199;
                      case XPATH_POINT:
                        goto LABEL_200;
                      case XPATH_RANGE:
                      case XPATH_LOCATIONSET:
                        goto LABEL_191;
                      case XPATH_USERS:
                        goto LABEL_201;
                      case XPATH_XSLT_TREE:
                        goto LABEL_202;
                      default:
                        break;
                    }
LABEL_204:
                    v113 = v93;
LABEL_227:
                    xmlXPathFreeObject(v113);
                    goto LABEL_228;
                  }
                }
                else
                {
                  if (!dtd[0])
                  {
                    *(_QWORD *)(v10 + 16) = *(_QWORD *)(v10 + 8);
                    goto LABEL_120;
                  }
                  v97 = *(xmlXPathContext **)(v10 + 24);
                  v97->node = *(xmlNodePtr *)(v10 + 16);
                  v98 = strlen(dtd);
                  if (v98 >= 2)
                  {
                    v99 = (v98 - 1);
                    if (dtd[v99] == 47)
                    {
                      dtd[v99] = 0;
                      v97 = *(xmlXPathContext **)(v10 + 24);
                    }
                  }
                  v100 = xmlXPathEval((const xmlChar *)dtd, v97);
                  if (v100)
                  {
                    v101 = v100;
                    switch(v100->type)
                    {
                      case XPATH_UNDEFINED:
                        v114 = *__xmlGenericError();
                        v115 = *__xmlGenericErrorContext();
                        v114(v115, "%s: no such node\n");
                        break;
                      case XPATH_NODESET:
                        nodesetval = v100->nodesetval;
                        if (nodesetval)
                        {
                          if (nodesetval->nodeNr == 1)
                          {
                            v117 = *nodesetval->nodeTab;
                            *(_QWORD *)(v10 + 16) = v117;
                            if (v117 && v117->type == XML_NAMESPACE_DECL)
                            {
                              v118 = *__xmlGenericError();
                              v119 = __xmlGenericErrorContext();
                              v118(*v119, "cannot cd to namespace\n");
                              *(_QWORD *)(v10 + 16) = 0;
                            }
                          }
                          else
                          {
                            v136 = *__xmlGenericError();
                            v137 = *__xmlGenericErrorContext();
                            v136(v137, "%s is a %d Node Set\n");
                          }
                        }
                        else
                        {
                          v134 = *__xmlGenericError();
                          v135 = *__xmlGenericErrorContext();
                          v134(v135, "%s is an empty Node Set\n");
                        }
                        break;
                      case XPATH_BOOLEAN:
                        v120 = *__xmlGenericError();
                        v121 = *__xmlGenericErrorContext();
                        v120(v121, "%s is a Boolean\n");
                        break;
                      case XPATH_NUMBER:
                        v122 = *__xmlGenericError();
                        v123 = *__xmlGenericErrorContext();
                        v122(v123, "%s is a number\n");
                        break;
                      case XPATH_STRING:
                        v124 = *__xmlGenericError();
                        v125 = *__xmlGenericErrorContext();
                        v124(v125, "%s is a string\n");
                        break;
                      case XPATH_POINT:
                        v126 = *__xmlGenericError();
                        v127 = *__xmlGenericErrorContext();
                        v126(v127, "%s is a point\n");
                        break;
                      case XPATH_RANGE:
                      case XPATH_LOCATIONSET:
                        v102 = *__xmlGenericError();
                        v103 = *__xmlGenericErrorContext();
                        v102(v103, "%s is a range\n");
                        break;
                      case XPATH_USERS:
                        v128 = *__xmlGenericError();
                        v129 = *__xmlGenericErrorContext();
                        v128(v129, "%s is user-defined\n");
                        break;
                      case XPATH_XSLT_TREE:
                        v130 = *__xmlGenericError();
                        v131 = *__xmlGenericErrorContext();
                        v130(v131, "%s is an XSLT value tree\n");
                        break;
                      default:
                        break;
                    }
                    v113 = v101;
                    goto LABEL_227;
                  }
                }
                goto LABEL_192;
              }
              v169 = 0;
              v167 = 0u;
              v168 = 0u;
              v165 = 0u;
              v166 = 0u;
              v163 = 0u;
              v164 = 0u;
              v161 = 0u;
              v162 = 0u;
              v159 = 0u;
              v160 = 0u;
              v157 = 0u;
              v158 = 0u;
              v155 = 0u;
              v156 = 0u;
              v153 = 0u;
              v154 = 0u;
              v151 = 0u;
              v152 = 0u;
              v149 = 0u;
              v150 = 0u;
              v147 = 0u;
              v148 = 0u;
              v145 = 0u;
              v146 = 0u;
              v143 = 0u;
              v144 = 0u;
              v141 = 0u;
              v142 = 0u;
              v139 = 0u;
              v140 = 0u;
              *(_OWORD *)buffer = 0u;
              v89 = *(xmlNode **)(v10 + 16);
              if (dtd[0])
              {
                v90 = *(xmlXPathContext **)(v10 + 24);
                v90->node = v89;
                v91 = xmlXPathEval((const xmlChar *)dtd, v90);
                if (v91)
                {
                  v93 = v91;
                  v94 = "%s: no such node\n";
                  switch(v91->type)
                  {
                    case XPATH_UNDEFINED:
                      goto LABEL_203;
                    case XPATH_NODESET:
                      v95 = &v91->nodesetval->nodeNr;
                      if (v95 && *v95 >= 1)
                      {
                        v96 = 0;
                        do
                        {
                          LODWORD(v91) = xmlShellPwd((xmlShellCtxtPtr)v91, buffer, *(xmlNodePtr *)(*((_QWORD *)v95 + 1) + 8 * v96), v92);
                          if (!(_DWORD)v91)
                            v91 = (xmlXPathObjectPtr)fprintf(*(FILE **)(v10 + 40), "%s\n", buffer);
                          ++v96;
                          v95 = &v93->nodesetval->nodeNr;
                        }
                        while (v96 < *v95);
                      }
                      goto LABEL_204;
                    case XPATH_BOOLEAN:
LABEL_197:
                      v94 = "%s is a Boolean\n";
                      goto LABEL_203;
                    case XPATH_NUMBER:
LABEL_198:
                      v94 = "%s is a number\n";
                      goto LABEL_203;
                    case XPATH_STRING:
LABEL_199:
                      v94 = "%s is a string\n";
                      goto LABEL_203;
                    case XPATH_POINT:
LABEL_200:
                      v94 = "%s is a point\n";
                      goto LABEL_203;
                    case XPATH_RANGE:
                    case XPATH_LOCATIONSET:
LABEL_191:
                      v94 = "%s is a range\n";
                      goto LABEL_203;
                    case XPATH_USERS:
LABEL_201:
                      v94 = "%s is user-defined\n";
                      goto LABEL_203;
                    case XPATH_XSLT_TREE:
LABEL_202:
                      v94 = "%s is an XSLT value tree\n";
LABEL_203:
                      v111 = *__xmlGenericError();
                      v112 = __xmlGenericErrorContext();
                      v111(*v112, v94);
                      break;
                    default:
                      goto LABEL_204;
                  }
                  goto LABEL_204;
                }
LABEL_192:
                v109 = *__xmlGenericError();
                v110 = __xmlGenericErrorContext();
                v109(*v110, "%s: no such node\n", dtd);
LABEL_228:
                *(_QWORD *)(*(_QWORD *)(v10 + 24) + 8) = 0;
                goto LABEL_120;
              }
              if (!xmlShellPwd(v16, buffer, v89, v19))
                goto LABEL_124;
            }
          }
        }
      }
      else
      {
        if (dtd[0])
        {
          *(_DWORD *)buffer = 0;
          sscanf(dtd, "%d", buffer);
          v62 = *(FILE **)(v10 + 40);
          v63 = *(_DWORD *)buffer;
        }
        else
        {
          v62 = *(FILE **)(v10 + 40);
          v63 = 0;
        }
        xmlMemShow(v62, v63);
      }
    }
LABEL_120:
    free(v20);
  }
LABEL_229:
  xmlXPathFreeContext(*(xmlXPathContextPtr *)(v10 + 24));
  if (*(_DWORD *)(v10 + 32))
    xmlFreeDoc(*(xmlDocPtr *)(v10 + 8));
  if (*(_QWORD *)v10)
    xmlFree(*(void **)v10);
  xmlFree((void *)v10);
  if (v20)
    free(v20);
}

xmlNodePtr xmlShellSetContent(uint64_t a1, char *__s, xmlNode *a3)
{
  int v6;
  xmlNode *children;
  xmlNodePtr lst;

  if (!a3 || !__s)
    return (xmlNodePtr)fwrite("NULL\n", 5uLL, 1uLL, *(FILE **)(a1 + 40));
  lst = 0;
  v6 = strlen(__s);
  if (xmlParseInNodeContext(a3, __s, v6, 0, &lst))
    return (xmlNodePtr)fwrite("failed to parse content\n", 0x18uLL, 1uLL, *(FILE **)(a1 + 40));
  children = a3->children;
  if (children)
  {
    xmlFreeNodeList(children);
    a3->children = 0;
    a3->last = 0;
  }
  return xmlAddChildList(a3, lst);
}

void xmlShellRegisterNamespace(uint64_t a1, xmlChar *cur)
{
  xmlChar *v3;
  const xmlChar *v4;
  const char *v5;
  const xmlChar *v6;
  const char *v7;
  const xmlChar *v8;

  v3 = xmlStrdup(cur);
  v4 = v3;
  while (v4)
  {
    v5 = (const char *)v4;
    if (!*v4)
      break;
    v6 = xmlStrchr(v4, 0x3Du);
    if (!v6)
    {
      fwrite("setns: prefix=[nsuri] required\n", 0x1FuLL, 1uLL, *(FILE **)(a1 + 40));
      break;
    }
    *v6 = 0;
    v7 = (const char *)(v6 + 1);
    v8 = xmlStrchr(v6 + 1, 0x20u);
    v4 = v8;
    if (v8)
    {
      *v8 = 0;
      v4 = v8 + 1;
    }
    if (xmlXPathRegisterNs(*(xmlXPathContextPtr *)(a1 + 24), (const xmlChar *)v5, (const xmlChar *)v7))
    {
      fprintf(*(FILE **)(a1 + 40), "Error: unable to register NS with prefix=\"%s\" and href=\"%s\"\n", v5, v7);
      break;
    }
  }
  xmlFree(v3);
}

uint64_t xmlShellRegisterRootNamespaces(uint64_t result, uint64_t a2)
{
  uint64_t **v2;
  uint64_t v3;
  const xmlChar *v4;

  if (a2)
  {
    if (*(_DWORD *)(a2 + 8) == 1)
    {
      v2 = *(uint64_t ***)(a2 + 96);
      if (v2)
      {
        v3 = result;
        if (*(_QWORD *)(result + 24))
        {
          do
          {
            if (v2[3])
              v4 = (const xmlChar *)v2[3];
            else
              v4 = (const xmlChar *)"defaultns";
            result = xmlXPathRegisterNs(*(xmlXPathContextPtr *)(v3 + 24), v4, (const xmlChar *)v2[2]);
            v2 = (uint64_t **)*v2;
          }
          while (v2);
        }
      }
    }
  }
  return result;
}

uint64_t xmlCtxtDumpSpaces(uint64_t result)
{
  FILE *v1;
  uint64_t v2;
  const char *v3;

  if (!*(_DWORD *)(result + 144))
  {
    v1 = *(FILE **)result;
    if (*(_QWORD *)result)
    {
      v2 = *(unsigned int *)(result + 112);
      if ((int)v2 >= 1)
      {
        if (v2 >= 0x32)
          v3 = (const char *)(result + 8);
        else
          v3 = (const char *)(result + 8 - 2 * v2 + 100);
        return fputs(v3, v1);
      }
    }
  }
  return result;
}

size_t xmlCtxtDumpString(size_t result, uint64_t a2)
{
  FILE **v3;
  uint64_t v4;
  FILE *v6;
  FILE *v7;
  const char *v8;
  size_t v9;

  if (*(_DWORD *)(result + 144))
    return result;
  v3 = (FILE **)result;
  if (a2)
  {
    v4 = 0;
    while (1)
    {
      result = *(unsigned __int8 *)(a2 + v4);
      if ((_DWORD)result == 32)
        goto LABEL_12;
      if (!*(_BYTE *)(a2 + v4))
        return result;
      if ((result - 9) < 2 || (_DWORD)result == 13)
      {
LABEL_12:
        v6 = *v3;
        LODWORD(result) = 32;
      }
      else
      {
        v6 = *v3;
        if ((result & 0x80) != 0)
        {
          fprintf(v6, "#%X", *(unsigned __int8 *)(a2 + v4));
          goto LABEL_14;
        }
      }
      fputc(result, v6);
LABEL_14:
      if (++v4 == 40)
      {
        v7 = *v3;
        v8 = "...";
        v9 = 3;
        return fwrite(v8, v9, 1uLL, v7);
      }
    }
  }
  v7 = *(FILE **)result;
  v8 = "(NULL)";
  v9 = 6;
  return fwrite(v8, v9, 1uLL, v7);
}

_DWORD *xmlDebugErr(uint64_t a1, int a2, char a3)
{
  ++*(_DWORD *)(a1 + 148);
  return __xmlRaiseError(0, 0, 0, 0, *(_QWORD *)(a1 + 128), 0x18u, a2, 2, 0, 0, 0, 0, 0, 0, 0, "%s", a3);
}

uint64_t xmlCtxtGenericNodeCheck(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  _QWORD *i;
  uint64_t v19;
  BOOL v20;
  int v21;
  const xmlChar *v23;
  xmlDict *v24;
  const char *v25;
  uint64_t v26;
  int v27;
  const xmlChar *v28;
  uint64_t v29;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 64);
  if (*(_QWORD *)(a2 + 40))
  {
    if (*(_QWORD *)(a2 + 64))
      goto LABEL_3;
LABEL_11:
    result = (uint64_t)xmlDebugErr(v3, 5014, (char)"Node has no doc\n");
    goto LABEL_12;
  }
  result = (uint64_t)xmlDebugErr(result, 5013, (char)"Node has no parent\n");
  if (!*(_QWORD *)(a2 + 64))
    goto LABEL_11;
LABEL_3:
  v5 = *(_QWORD *)(v4 + 152);
  if (!v5 && !*(_DWORD *)(v3 + 152))
    *(_DWORD *)(v3 + 152) = 1;
  if (!*(_QWORD *)(v3 + 120))
    *(_QWORD *)(v3 + 120) = v4;
  if (!*(_QWORD *)(v3 + 136))
    *(_QWORD *)(v3 + 136) = v5;
LABEL_12:
  v6 = *(_QWORD *)(a2 + 40);
  if (v6)
  {
    if (*(_QWORD *)(a2 + 64) != *(_QWORD *)(v6 + 64))
    {
      result = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"pseudoroot");
      if (!(_DWORD)result)
        result = (uint64_t)xmlDebugErr(v3, 5017, (char)"Node doc differs from parent's one\n");
    }
  }
  v7 = *(_QWORD *)(a2 + 56);
  if (v7)
  {
    if (*(_QWORD *)(v7 + 48) == a2)
      goto LABEL_28;
    v8 = "Node prev->next : back link wrong\n";
    v9 = v3;
    v10 = 5019;
    goto LABEL_27;
  }
  v11 = *(_QWORD *)(a2 + 40);
  if (*(_DWORD *)(a2 + 8) == 2)
  {
    if (v11 && *(_QWORD *)(v11 + 88) != a2)
    {
      v8 = "Attr has no prev and not first of attr list\n";
LABEL_26:
      v9 = v3;
      v10 = 5018;
LABEL_27:
      result = (uint64_t)xmlDebugErr(v9, v10, (char)v8);
    }
  }
  else if (v11 && *(_QWORD *)(v11 + 24) != a2)
  {
    v8 = "Node has no prev and not first of parent list\n";
    goto LABEL_26;
  }
LABEL_28:
  v12 = *(_QWORD *)(a2 + 48);
  if (v12)
  {
    if (*(_QWORD *)(v12 + 56) != a2)
    {
      result = (uint64_t)xmlDebugErr(v3, 5021, (char)"Node next->prev : forward link wrong\n");
      v12 = *(_QWORD *)(a2 + 48);
    }
    if (*(_QWORD *)(v12 + 40) != *(_QWORD *)(a2 + 40))
    {
      v13 = "Node next->prev : forward link wrong\n";
      v14 = v3;
      v15 = 5029;
LABEL_33:
      result = (uint64_t)xmlDebugErr(v14, v15, (char)v13);
    }
  }
  else
  {
    v16 = *(_QWORD *)(a2 + 40);
    if (v16 && *(_DWORD *)(a2 + 8) != 2 && *(_QWORD *)(v16 + 32) != a2 && *(_DWORD *)(v16 + 8) == 1)
    {
      v13 = "Node has no next and not last of parent list\n";
      v14 = v3;
      v15 = 5020;
      goto LABEL_33;
    }
  }
  v17 = *(_DWORD *)(a2 + 8);
  if (v17 == 2)
  {
    v19 = *(_QWORD *)(a2 + 72);
    if (!v19)
      return xmlCtxtCheckName(v3, *(xmlChar **)(a2 + 16));
LABEL_46:
    result = xmlCtxtNsCheckScope(v3, a2, v19);
LABEL_47:
    v17 = *(_DWORD *)(a2 + 8);
    goto LABEL_48;
  }
  if (v17 == 1)
  {
    for (i = *(_QWORD **)(a2 + 96); i; i = (_QWORD *)*i)
      result = xmlCtxtNsCheckScope(v3, a2, (uint64_t)i);
    v19 = *(_QWORD *)(a2 + 72);
    if (!v19)
      goto LABEL_47;
    goto LABEL_46;
  }
LABEL_48:
  v20 = v17 > 0x10;
  v21 = (1 << v17) & 0x1E206;
  if (v20 || v21 == 0)
  {
    v29 = *(_QWORD *)(a2 + 80);
    if (v29)
    {
      if (*(_DWORD *)(v3 + 144))
      {
        result = xmlCheckUTF8(*(const unsigned __int8 **)(a2 + 80));
        if (!(_DWORD)result)
          result = (uint64_t)xmlDebugErr3(v3, 5032, "String is not UTF-8 %s", v29);
      }
    }
  }
  switch(*(_DWORD *)(a2 + 8))
  {
    case 1:
    case 2:
    case 7:
      return xmlCtxtCheckName(v3, *(xmlChar **)(a2 + 16));
    case 3:
      v23 = *(const xmlChar **)(a2 + 16);
      if (v23 == "text" || v23 == "textnoenc")
        return result;
      v24 = *(xmlDict **)(v3 + 136);
      if (!v24)
        goto LABEL_59;
      result = (uint64_t)xmlDictLookup(v24, (const xmlChar *)"nbktext", 7);
      if (v23 != (const xmlChar *)result)
      {
        v23 = *(const xmlChar **)(a2 + 16);
LABEL_59:
        v25 = "Text node has wrong name '%s'";
        v26 = v3;
        v27 = 5036;
        LOBYTE(v28) = (_BYTE)v23;
LABEL_64:
        result = (uint64_t)xmlDebugErr3(v26, v27, v25, (char)v28);
      }
      break;
    case 4:
      v28 = *(const xmlChar **)(a2 + 16);
      if (!v28)
        return result;
      v25 = "CData section has non NULL name '%s'";
      v26 = v3;
      v27 = 5037;
      goto LABEL_64;
    case 8:
      v28 = *(const xmlChar **)(a2 + 16);
      if (v28 == "comment")
        return result;
      v25 = "Comment node has wrong name '%s'";
      v26 = v3;
      v27 = 5036;
      goto LABEL_64;
    default:
      return result;
  }
  return result;
}

uint64_t xmlCtxtNsCheckScope(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  int v7;
  uint64_t v9;
  unsigned int v10;
  uint64_t *v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  int v15;
  const char *v16;
  uint64_t v17;
  int v18;

  v4 = result;
  v5 = *(_DWORD *)(a2 + 8);
  v6 = v5 > 0x13;
  v7 = (1 << v5) & 0x8220E;
  if (!v6 && v7 != 0)
  {
    v9 = a2;
    do
    {
      v10 = *(_DWORD *)(v9 + 8);
      if (v10 > 0x13)
        break;
      if (((1 << v10) & 0xC) == 0)
      {
        if (((1 << v10) & 0x80002) == 0)
        {
          if (((1 << v10) & 0x2200) != 0 && *(_QWORD *)(v9 + 96) == a3)
            return result;
          break;
        }
        v11 = (uint64_t *)(v9 + 96);
        while (1)
        {
          v11 = (uint64_t *)*v11;
          if (!v11)
            break;
          if (v11 == (uint64_t *)a3)
            return result;
          result = xmlStrEqual((const xmlChar *)v11[3], *(const xmlChar **)(a3 + 24));
          if ((_DWORD)result)
            goto LABEL_16;
        }
      }
      v9 = *(_QWORD *)(v9 + 40);
    }
    while (v9);
    v12 = *(_QWORD *)(a3 + 24);
    if (v12)
    {
      v13 = "Reference to namespace '%s' not on ancestor\n";
      v14 = v4;
      v15 = 5031;
      return (uint64_t)xmlDebugErr3(v14, v15, v13, v12);
    }
    v16 = "Reference to default namespace not on ancestor\n";
    v17 = v4;
    v18 = 5031;
    return (uint64_t)xmlDebugErr(v17, v18, (char)v16);
  }
LABEL_16:
  v12 = *(_QWORD *)(a3 + 24);
  if (!v12)
  {
    v16 = "Reference to default namespace not in scope\n";
    v17 = v4;
    v18 = 5030;
    return (uint64_t)xmlDebugErr(v17, v18, (char)v16);
  }
  v13 = "Reference to namespace '%s' not in scope\n";
  v14 = v4;
  v15 = 5030;
  return (uint64_t)xmlDebugErr3(v14, v15, v13, v12);
}

uint64_t xmlCtxtCheckName(uint64_t result, xmlChar *value)
{
  uint64_t v3;
  uint64_t v4;

  if (*(_DWORD *)(result + 144))
  {
    v3 = result;
    if (value)
    {
      if (xmlValidateName(value, 0))
        xmlDebugErr3(v3, 5034, "Name is not an NCName '%s'", (char)value);
      result = *(_QWORD *)(v3 + 136);
      if (result)
      {
        result = xmlDictOwns((xmlDictPtr)result, value);
        if (!(_DWORD)result)
        {
          v4 = *(_QWORD *)(v3 + 120);
          if (!v4 || (*(_BYTE *)(v4 + 169) & 0x12) == 0)
            return (uint64_t)xmlDebugErr3(v3, 5035, "Name is not from the document dictionary '%s'", (char)value);
        }
      }
    }
    else
    {
      return (uint64_t)xmlDebugErr(result, 5015, (char)"Name is NULL");
    }
  }
  return result;
}

_DWORD *xmlDebugErr3(uint64_t a1, int a2, const char *a3, char a4)
{
  ++*(_DWORD *)(a1 + 148);
  return __xmlRaiseError(0, 0, 0, 0, *(_QWORD *)(a1 + 128), 0x18u, a2, 2, 0, 0, 0, 0, 0, 0, 0, a3, a4);
}

_DWORD *xmlCtxtDumpDocHead(_DWORD *result, uint64_t a2)
{
  int v2;
  const char *v3;
  int v4;
  FILE *v5;
  const char *v6;
  size_t v7;

  *((_QWORD *)result + 16) = a2;
  v2 = *(_DWORD *)(a2 + 8);
  switch(v2)
  {
    case 1:
      v3 = "Misplaced ELEMENT node\n";
      v4 = 5000;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 2:
      v3 = "Misplaced ATTRIBUTE node\n";
      v4 = 5001;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 3:
      v3 = "Misplaced TEXT node\n";
      v4 = 5002;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 4:
      v3 = "Misplaced CDATA node\n";
      v4 = 5003;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 5:
      v3 = "Misplaced ENTITYREF node\n";
      v4 = 5004;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 6:
      v3 = "Misplaced ENTITY node\n";
      v4 = 5005;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 7:
      v3 = "Misplaced PI node\n";
      v4 = 5006;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 8:
      v3 = "Misplaced COMMENT node\n";
      v4 = 5007;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 9:
      if (result[36])
        return result;
      v5 = *(FILE **)result;
      v6 = "DOCUMENT\n";
      v7 = 9;
      return (_DWORD *)fwrite(v6, v7, 1uLL, v5);
    case 10:
      v3 = "Misplaced DOCTYPE node\n";
      v4 = 5008;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 11:
      v3 = "Misplaced FRAGMENT node\n";
      v4 = 5009;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 12:
      v3 = "Misplaced NOTATION node\n";
      v4 = 5010;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 13:
      if (result[36])
        return result;
      v5 = *(FILE **)result;
      v6 = "HTML DOCUMENT\n";
      v7 = 14;
      return (_DWORD *)fwrite(v6, v7, 1uLL, v5);
    default:
      return xmlDebugErr3((uint64_t)result, 5011, "Unknown node type %d\n", v2);
  }
}

size_t xmlCtxtDumpEntityCallback(size_t result, uint64_t a2)
{
  int v3;
  size_t v4;
  int v5;
  FILE *v6;
  const char *v7;
  size_t v8;

  v3 = *(_DWORD *)(a2 + 144);
  if (result)
  {
    if (!v3)
    {
      v4 = result;
      fprintf(*(FILE **)a2, "%s : ", *(const char **)(result + 16));
      v5 = *(_DWORD *)(v4 + 92);
      switch(v5)
      {
        case 1:
          v6 = *(FILE **)a2;
          v7 = "INTERNAL GENERAL, ";
          v8 = 18;
          goto LABEL_14;
        case 2:
          v6 = *(FILE **)a2;
          v7 = "EXTERNAL PARSED, ";
          v8 = 17;
          goto LABEL_14;
        case 3:
          v6 = *(FILE **)a2;
          v7 = "EXTERNAL UNPARSED, ";
          v8 = 19;
          goto LABEL_14;
        case 4:
          v6 = *(FILE **)a2;
          v7 = "INTERNAL PARAMETER, ";
          goto LABEL_13;
        case 5:
          v6 = *(FILE **)a2;
          v7 = "EXTERNAL PARAMETER, ";
LABEL_13:
          v8 = 20;
LABEL_14:
          fwrite(v7, v8, 1uLL, v6);
          break;
        default:
          xmlDebugErr3(a2, 5012, "Unknown entity type %d\n", v5);
          break;
      }
      if (*(_QWORD *)(v4 + 96))
        fprintf(*(FILE **)a2, "ID \"%s\"", *(const char **)(v4 + 96));
      if (*(_QWORD *)(v4 + 104))
        fprintf(*(FILE **)a2, "SYSTEM \"%s\"", *(const char **)(v4 + 104));
      if (*(_QWORD *)(v4 + 72))
        fprintf(*(FILE **)a2, "\n orig \"%s\"", *(const char **)(v4 + 72));
      if (*(_DWORD *)(v4 + 8) != 1)
      {
        if (*(_QWORD *)(v4 + 80))
          fprintf(*(FILE **)a2, "\n content \"%s\"", *(const char **)(v4 + 80));
      }
      return fputc(10, *(FILE **)a2);
    }
  }
  else if (!v3)
  {
    return fwrite("Entity is NULL", 0xEuLL, 1uLL, *(FILE **)a2);
  }
  return result;
}

_DWORD *xmlCtxtDumpDtdNode(uint64_t a1, uint64_t a2)
{
  FILE *v4;

  xmlCtxtDumpSpaces(a1);
  if (*(_DWORD *)(a2 + 8) != 14)
    return xmlDebugErr(a1, 5022, (char)"Node is not a DTD");
  if (!*(_DWORD *)(a1 + 144))
  {
    v4 = *(FILE **)a1;
    if (*(_QWORD *)(a2 + 16))
      fprintf(v4, "DTD(%s)", *(const char **)(a2 + 16));
    else
      fwrite("DTD", 3uLL, 1uLL, v4);
    if (*(_QWORD *)(a2 + 104))
      fprintf(*(FILE **)a1, ", PUBLIC %s", *(const char **)(a2 + 104));
    if (*(_QWORD *)(a2 + 112))
      fprintf(*(FILE **)a1, ", SYSTEM %s", *(const char **)(a2 + 112));
    fputc(10, *(FILE **)a1);
  }
  return (_DWORD *)xmlCtxtGenericNodeCheck(a1, a2);
}

_DWORD *xmlCtxtDumpNamespace(size_t a1, uint64_t a2)
{
  _DWORD *result;
  const char *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  FILE *v9;

  result = (_DWORD *)xmlCtxtDumpSpaces(a1);
  if (*(_DWORD *)(a2 + 8) != 18)
  {
    v5 = "Node is not a namespace declaration";
    v6 = a1;
    v7 = 5027;
    return xmlDebugErr(v6, v7, (char)v5);
  }
  if (!*(_QWORD *)(a2 + 16))
  {
    v8 = *(_QWORD *)(a2 + 24);
    if (v8)
      return xmlDebugErr3(a1, 5028, "Incomplete namespace %s href=NULL\n", v8);
    v5 = "Incomplete default namespace href=NULL\n";
    v6 = a1;
    v7 = 5028;
    return xmlDebugErr(v6, v7, (char)v5);
  }
  if (!*(_DWORD *)(a1 + 144))
  {
    v9 = *(FILE **)a1;
    if (*(_QWORD *)(a2 + 24))
      fprintf(v9, "namespace %s href=", *(const char **)(a2 + 24));
    else
      fwrite("default namespace href=", 0x17uLL, 1uLL, v9);
    xmlCtxtDumpString(a1, *(_QWORD *)(a2 + 16));
    return (_DWORD *)fputc(10, *(FILE **)a1);
  }
  return result;
}

xmlDictPtr xmlDictCreateSub(xmlDictPtr sub)
{
  xmlDictPtr v2;
  xmlDict *v3;

  v2 = xmlDictCreate();
  v3 = v2;
  if (sub && v2)
  {
    *((_DWORD *)v2 + 12) = *((_DWORD *)sub + 12);
    *((_QWORD *)v2 + 5) = sub;
    xmlDictReference(sub);
  }
  return v3;
}

uint64_t xmlDictGrow(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  uint64_t v5;
  size_t v6;
  void *v7;
  uint64_t v8;
  uint64_t i;
  char *v10;
  unint64_t v11;
  char *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unint64_t v15;
  BOOL v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  _QWORD *v27;
  uint64_t j;
  unsigned int *v29;
  unsigned int *v30;
  unint64_t v31;
  unsigned __int8 *v32;
  uint64_t v33;
  unint64_t v34;
  BOOL v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  unint64_t v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;

  if (a2 < 8)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return 0xFFFFFFFFLL;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = 32 * a2;
  v7 = xmlMalloc(32 * a2);
  *(_QWORD *)(a1 + 8) = v7;
  if (!v7)
  {
    *(_QWORD *)(a1 + 8) = v3;
    return 0xFFFFFFFFLL;
  }
  bzero(v7, v6);
  *(_QWORD *)(a1 + 16) = a2;
  v8 = 0;
  if (v5)
  {
    for (i = 0; i != v5; ++i)
    {
      v10 = (char *)&v3[4 * i];
      if (*((_DWORD *)v10 + 5))
      {
        if (v5 == 128)
        {
          v11 = *(_QWORD *)(a1 + 16);
          v12 = (char *)&v3[4 * i];
          v13 = (unsigned __int8 *)*((_QWORD *)v12 + 1);
          v14 = *((unsigned int *)v12 + 4);
          if (v11 == 128)
          {
            v15 = xmlDictComputeFastKey(v13, v14, *(_DWORD *)(a1 + 48));
            v11 = 128;
          }
          else
          {
            if (v13)
              v16 = (int)v14 < 1;
            else
              v16 = 1;
            if (v16)
            {
              v17 = 0;
            }
            else
            {
              v18 = *(_DWORD *)(a1 + 48);
              do
              {
                v19 = *v13++;
                v18 = (1025 * (v18 + v19)) ^ ((1025 * (v18 + v19)) >> 6);
                --v14;
              }
              while (v14);
              v17 = 32769 * ((9 * v18) ^ ((9 * v18) >> 11));
            }
            v15 = v17;
          }
        }
        else
        {
          v15 = v3[4 * i + 3];
          v11 = *(_QWORD *)(a1 + 16);
        }
        v20 = v15 % v11;
        v21 = *(_QWORD *)(a1 + 8) + 32 * (v15 % v11);
        if (*(_DWORD *)(v21 + 20))
        {
          v22 = xmlMalloc(0x20uLL);
          if (v22)
          {
            v23 = (char *)&v3[4 * i];
            v24 = *((_QWORD *)v23 + 1);
            LODWORD(v23) = *((_DWORD *)v23 + 4);
            v22[3] = v15;
            v25 = *(_QWORD *)(a1 + 8);
            *v22 = *(_QWORD *)(v25 + 32 * v20);
            v22[1] = v24;
            *((_DWORD *)v22 + 4) = (_DWORD)v23;
            *((_DWORD *)v22 + 5) = 1;
            *(_QWORD *)(v25 + 32 * v20) = v22;
          }
          else
          {
            v8 = 0xFFFFFFFFLL;
          }
        }
        else
        {
          v26 = *((_OWORD *)v10 + 1);
          *(_OWORD *)v21 = *(_OWORD *)v10;
          *(_OWORD *)(v21 + 16) = v26;
          v27 = (_QWORD *)(*(_QWORD *)(a1 + 8) + 32 * v20);
          *v27 = 0;
          v27[3] = v15;
        }
      }
    }
    for (j = 0; j != v5; ++j)
    {
      v29 = (unsigned int *)v3[4 * j];
      if (v29)
      {
        do
        {
          v30 = *(unsigned int **)v29;
          if (v5 == 128)
          {
            v31 = *(_QWORD *)(a1 + 16);
            v32 = (unsigned __int8 *)*((_QWORD *)v29 + 1);
            v33 = v29[4];
            if (v31 == 128)
            {
              v34 = xmlDictComputeFastKey(v32, v33, *(_DWORD *)(a1 + 48));
              v31 = 128;
            }
            else
            {
              if (v32)
                v35 = (int)v33 < 1;
              else
                v35 = 1;
              if (v35)
              {
                v36 = 0;
              }
              else
              {
                v37 = *(_DWORD *)(a1 + 48);
                do
                {
                  v38 = *v32++;
                  v37 = (1025 * (v37 + v38)) ^ ((1025 * (v37 + v38)) >> 6);
                  --v33;
                }
                while (v33);
                v36 = 32769 * ((9 * v37) ^ ((9 * v37) >> 11));
              }
              v34 = v36;
            }
          }
          else
          {
            v34 = *((_QWORD *)v29 + 3);
            v31 = *(_QWORD *)(a1 + 16);
          }
          v39 = v34 % v31;
          v40 = *(_QWORD *)(a1 + 8) + 32 * (v34 % v31);
          if (*(_DWORD *)(v40 + 20))
          {
            *(_QWORD *)v29 = *(_QWORD *)v40;
            *((_QWORD *)v29 + 3) = v34;
            *(_QWORD *)v40 = v29;
          }
          else
          {
            v41 = *((_OWORD *)v29 + 1);
            *(_OWORD *)v40 = *(_OWORD *)v29;
            *(_OWORD *)(v40 + 16) = v41;
            v42 = *(_QWORD *)(a1 + 8) + 32 * v39;
            *(_QWORD *)v42 = 0;
            *(_DWORD *)(v42 + 20) = 1;
            *(_QWORD *)(v42 + 24) = v34;
            xmlFree(v29);
          }
          v29 = v30;
        }
        while (v30);
      }
    }
  }
  xmlFree(v3);
  return v8;
}

const xmlChar *__cdecl xmlDictExists(xmlDictPtr dict, const xmlChar *name, int len)
{
  const xmlChar *v3;
  size_t v6;
  size_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int v10;
  const xmlChar *v11;
  size_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int v18;
  uint64_t v19;
  const xmlChar *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;

  v3 = 0;
  if (dict && name)
  {
    if (len < 0)
      v6 = strlen((const char *)name);
    else
      v6 = len;
    v7 = *((_QWORD *)dict + 7);
    if (v7)
    {
      v3 = 0;
      if (v6 >> 30 || v6 >= v7)
        return v3;
    }
    else if (v6 >> 30)
    {
      return 0;
    }
    v8 = *((_QWORD *)dict + 2);
    if (v8 == 128)
    {
      v9 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *((_DWORD *)dict + 12));
    }
    else if (v6)
    {
      v10 = *((_DWORD *)dict + 12);
      v11 = name;
      v12 = v6;
      do
      {
        v13 = *v11++;
        v10 = (1025 * (v10 + v13)) ^ ((1025 * (v10 + v13)) >> 6);
        --v12;
      }
      while (v12);
      v9 = 32769 * ((9 * v10) ^ ((9 * v10) >> 11));
    }
    else
    {
      v9 = 0;
    }
    v14 = *((_QWORD *)dict + 1) + 32 * (v9 % v8);
    if (!*(_DWORD *)(v14 + 20))
      goto LABEL_50;
    while (*(_QWORD *)v14)
    {
      v15 = v14;
      v14 = *(_QWORD *)v14;
      if (*(_QWORD *)(v15 + 24) == v9 && v6 == *(_DWORD *)(v15 + 16))
      {
        v3 = *(const xmlChar **)(v15 + 8);
        if (!memcmp(v3, name, v6))
          return v3;
      }
    }
    if (*(_QWORD *)(v14 + 24) != v9
      || v6 != *(_DWORD *)(v14 + 16)
      || (v3 = *(const xmlChar **)(v14 + 8), memcmp(v3, name, v6)))
    {
LABEL_50:
      v16 = *((_QWORD *)dict + 5);
      if (!v16)
        return 0;
      v17 = *(_QWORD *)(v16 + 16);
      if (v8 == 128)
      {
        if (v17 != 128)
        {
          if ((int)v6 < 1)
          {
            v9 = 0;
          }
          else
          {
            v18 = *(_DWORD *)(v16 + 48);
            v19 = v6;
            v20 = name;
            do
            {
              v21 = *v20++;
              v18 = (1025 * (v18 + v21)) ^ ((1025 * (v18 + v21)) >> 6);
              --v19;
            }
            while (v19);
            v9 = 32769 * ((9 * v18) ^ ((9 * v18) >> 11));
          }
        }
      }
      else if (v17 == 128)
      {
        v9 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *(_DWORD *)(v16 + 48));
        v17 = 128;
      }
      v22 = *(_QWORD *)(v16 + 8) + 32 * (v9 % v17);
      if (!*(_DWORD *)(v22 + 20))
        return 0;
      while (*(_QWORD *)v22)
      {
        v23 = v22;
        v22 = *(_QWORD *)v22;
        if (*(_QWORD *)(v23 + 24) == v9 && v6 == *(_DWORD *)(v23 + 16))
        {
          v3 = *(const xmlChar **)(v23 + 8);
          if (!memcmp(v3, name, v6))
            return v3;
        }
      }
      if (*(_QWORD *)(v22 + 24) != v9)
        return 0;
      if (v6 != *(_DWORD *)(v22 + 16))
        return 0;
      v3 = *(const xmlChar **)(v22 + 8);
      if (memcmp(v3, name, v6))
        return 0;
    }
  }
  return v3;
}

uint64_t xmlDictComputeBigQKey(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v9;

  if (a2 >= 1)
  {
    v5 = a2;
    do
    {
      v6 = *a1++;
      a5 = (1025 * (a5 + v6)) ^ ((1025 * (a5 + v6)) >> 6);
      --v5;
    }
    while (v5);
  }
  v7 = (1025 * a5 + 59450) ^ ((1025 * a5 + 59450) >> 6);
  if (a4 >= 1)
  {
    v8 = a4;
    do
    {
      v9 = *a3++;
      v7 = (1025 * (v7 + v9)) ^ ((1025 * (v7 + v9)) >> 6);
      --v8;
    }
    while (v8);
  }
  return 32769 * ((9 * v7) ^ ((9 * v7) >> 11));
}

int xmlDictSize(xmlDictPtr dict)
{
  uint64_t v1;
  int result;

  if (!dict)
    return -1;
  v1 = *((_QWORD *)dict + 5);
  result = *((_DWORD *)dict + 6);
  if (v1)
    result += *(_DWORD *)(v1 + 24);
  return result;
}

size_t xmlDictGetUsage(size_t dict)
{
  _QWORD *v1;

  if (dict)
  {
    v1 = *(_QWORD **)(dict + 32);
    if (v1)
    {
      dict = 0;
      do
      {
        dict += v1[3];
        v1 = (_QWORD *)*v1;
      }
      while (v1);
    }
    else
    {
      return 0;
    }
  }
  return dict;
}

int docbEncodeEntities(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen, int quoteChar)
{
  xmlGenericErrorFunc v5;
  void **v6;

  if ((docbEncodeEntities_deprecated & 1) == 0)
  {
    v5 = *__xmlGenericError();
    v6 = __xmlGenericErrorContext();
    v5(*v6, "docbEncodeEntities() deprecated function reached\n");
    docbEncodeEntities_deprecated = 1;
  }
  return -1;
}

int docbParseDocument(docbParserCtxtPtr ctxt)
{
  xmlGenericErrorFunc v2;
  void **v3;

  if ((docbParseDocument_deprecated & 1) == 0)
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "docbParseDocument() deprecated function reached\n");
    docbParseDocument_deprecated = 1;
  }
  return xmlParseDocument(ctxt);
}

void docbFreeParserCtxt(docbParserCtxtPtr ctxt)
{
  xmlGenericErrorFunc v2;
  void **v3;

  if ((docbFreeParserCtxt_deprecated & 1) == 0)
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "docbFreeParserCtxt() deprecated function reached\n");
    docbFreeParserCtxt_deprecated = 1;
  }
  xmlFreeParserCtxt(ctxt);
}

int docbParseChunk(docbParserCtxtPtr ctxt, const char *chunk, int size, int terminate)
{
  xmlGenericErrorFunc v8;
  void **v9;

  if ((docbParseChunk_deprecated & 1) == 0)
  {
    v8 = *__xmlGenericError();
    v9 = __xmlGenericErrorContext();
    v8(*v9, "docbParseChunk() deprecated function reached\n");
    docbParseChunk_deprecated = 1;
  }
  return xmlParseChunk(ctxt, chunk, size, terminate);
}

docbParserCtxtPtr docbCreatePushParserCtxt(docbSAXHandlerPtr sax, void *user_data, const char *chunk, int size, const char *filename, xmlCharEncoding enc)
{
  xmlGenericErrorFunc v11;
  void **v12;

  if ((docbCreatePushParserCtxt_deprecated & 1) == 0)
  {
    v11 = *__xmlGenericError();
    v12 = __xmlGenericErrorContext();
    v11(*v12, "docbParseChunk() deprecated function reached\n");
    docbCreatePushParserCtxt_deprecated = 1;
  }
  return xmlCreatePushParserCtxt(sax, user_data, chunk, size, filename);
}

docbDocPtr docbSAXParseDoc(xmlChar *cur, const char *encoding, docbSAXHandlerPtr sax, void *userData)
{
  xmlGenericErrorFunc v7;
  void **v8;
  int v9;

  if ((docbSAXParseDoc_deprecated & 1) == 0)
  {
    v7 = *__xmlGenericError();
    v8 = __xmlGenericErrorContext();
    v7(*v8, "docbParseChunk() deprecated function reached\n");
    docbSAXParseDoc_deprecated = 1;
  }
  v9 = xmlStrlen(cur);
  return xmlSAXParseMemoryWithData(sax, (const char *)cur, v9, 0, userData);
}

docbDocPtr docbParseDoc(xmlChar *cur, const char *encoding)
{
  xmlGenericErrorFunc v3;
  void **v4;

  if ((docbParseDoc_deprecated & 1) == 0)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "docbParseChunk() deprecated function reached\n");
    docbParseDoc_deprecated = 1;
  }
  return xmlParseDoc(cur);
}

docbParserCtxtPtr docbCreateFileParserCtxt(const char *filename, const char *encoding)
{
  xmlGenericErrorFunc v3;
  void **v4;

  if ((docbCreateFileParserCtxt_deprecated & 1) == 0)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "docbCreateFileParserCtxt() deprecated function reached\n");
    docbCreateFileParserCtxt_deprecated = 1;
  }
  return xmlCreateFileParserCtxt(filename);
}

docbDocPtr docbSAXParseFile(const char *filename, const char *encoding, docbSAXHandlerPtr sax, void *userData)
{
  xmlGenericErrorFunc v7;
  void **v8;

  if ((docbSAXParseFile_deprecated & 1) == 0)
  {
    v7 = *__xmlGenericError();
    v8 = __xmlGenericErrorContext();
    v7(*v8, "docbSAXParseFile() deprecated function reached\n");
    docbSAXParseFile_deprecated = 1;
  }
  return xmlSAXParseFileWithData(sax, filename, 0, userData);
}

docbDocPtr docbParseFile(const char *filename, const char *encoding)
{
  xmlGenericErrorFunc v3;
  void **v4;

  if ((docbParseFile_deprecated & 1) == 0)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "docbParseFile() deprecated function reached\n");
    docbParseFile_deprecated = 1;
  }
  return xmlParseFile(filename);
}

int isolat1ToUTF8(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen)
{
  int v4;
  unsigned __int8 *v5;
  uint64_t v6;
  _BOOL4 v7;
  unsigned __int8 *v8;
  const unsigned __int8 *v9;
  const unsigned __int8 *v10;
  const unsigned __int8 *v11;
  int v12;
  char v13;
  int64_t v14;
  int v15;
  int v16;

  v4 = -1;
  if (inlen && outlen && out && in)
  {
    v5 = &out[*outlen];
    v6 = *inlen;
    v7 = v6 > 0;
    if ((int)v6 < 1)
    {
      v8 = out;
      v9 = in;
    }
    else
    {
      v8 = out;
      v9 = in;
      if (v5 - 1 > out)
      {
        v10 = &in[v6];
        v11 = v10;
        v9 = in;
        v8 = out;
        do
        {
          v12 = *(char *)v9;
          if (v12 < 0)
          {
            *v8 = (v12 >> 6) | 0xC0;
            v13 = *v9++;
            v8[1] = v13 & 0x3F | 0x80;
            v8 += 2;
          }
          if (v11 - v9 > v5 - v8)
            v11 = &v9[v5 - v8];
          if (v9 < v11)
          {
            v14 = v11 - v9;
            while (1)
            {
              v15 = *(char *)v9;
              if (v15 < 0)
                break;
              ++v9;
              *v8++ = v15;
              if (!--v14)
              {
                v9 = v11;
                break;
              }
            }
          }
          v7 = v9 < v10;
        }
        while (v9 < v10 && v8 < v5 - 1);
      }
    }
    if (v7 && v8 < v5)
    {
      v16 = *(char *)v9;
      if ((v16 & 0x80000000) == 0)
      {
        LODWORD(v9) = (_DWORD)v9 + 1;
        *v8 = v16;
        LODWORD(v8) = (_DWORD)v8 + 1;
      }
    }
    *outlen = (_DWORD)v8 - (_DWORD)out;
    *inlen = (_DWORD)v9 - (_DWORD)in;
    return *outlen;
  }
  return v4;
}

int UTF8Toisolat1(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen)
{
  int v4;
  uint64_t v5;
  unsigned __int8 *v6;
  const unsigned __int8 *v7;
  const unsigned __int8 *v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned __int8 v16;
  unsigned int v17;

  v4 = -1;
  if (out && outlen && inlen)
  {
    if (in)
    {
      v5 = *inlen;
      LODWORD(v6) = (_DWORD)out;
      LODWORD(v7) = (_DWORD)in;
      if ((int)v5 >= 1)
      {
        v8 = &in[v5];
        v9 = &out[*outlen];
        v10 = (int)in;
        v6 = out;
        v7 = in;
        while (1)
        {
          v11 = *(char *)v7++;
          v12 = v11;
          if (v11 < 0)
          {
            if (v12 <= 0xBF)
              goto LABEL_31;
            if (v12 > 0xDF)
            {
              if (v12 > 0xEF)
              {
                if (v12 > 0xF7)
                  goto LABEL_31;
                v14 = v12 & 7;
                v13 = 3;
              }
              else
              {
                v14 = v12 & 0xF;
                v13 = 2;
              }
            }
            else
            {
              v14 = v12 & 0x1F;
              v13 = 1;
            }
          }
          else
          {
            v13 = 0;
            v14 = v12;
          }
          if (v8 - v7 < v13)
            break;
          if ((v12 & 0x80) != 0 && v7 < v8)
          {
            v15 = v13 - 1;
            while (1)
            {
              v16 = *v7;
              if ((*v7 & 0xC0) != 0x80)
                break;
              ++v7;
              v17 = v16 & 0x3F | (v14 << 6);
              if (v15-- != 0)
              {
                v14 = v17;
                if (v7 < v8)
                  continue;
              }
              if (v17 <= 0xFF)
                goto LABEL_27;
              break;
            }
LABEL_31:
            *outlen = (_DWORD)v6 - (_DWORD)out;
            *inlen = v10 - (_DWORD)in;
            return -2;
          }
          LOBYTE(v17) = v14;
LABEL_27:
          if (v6 >= v9)
            break;
          *v6++ = v17;
          v10 = (int)v7;
          if (v7 >= v8)
            goto LABEL_33;
        }
        LODWORD(v7) = v10;
      }
LABEL_33:
      *outlen = (_DWORD)v6 - (_DWORD)out;
      *inlen = (_DWORD)v7 - (_DWORD)in;
      return *outlen;
    }
    else
    {
      v4 = 0;
      *outlen = 0;
      *inlen = 0;
    }
  }
  return v4;
}

void xmlCleanupEncodingAliases(void)
{
  char *v0;
  uint64_t v1;
  uint64_t v2;

  v0 = (char *)xmlCharEncodingAliases;
  if (xmlCharEncodingAliases)
  {
    if (xmlCharEncodingAliasesNb >= 1)
    {
      v1 = 0;
      v2 = 0;
      do
      {
        if (*(_QWORD *)&v0[v1])
        {
          xmlFree(*(void **)&v0[v1]);
          v0 = (char *)xmlCharEncodingAliases;
        }
        if (*(_QWORD *)&v0[v1 + 8])
        {
          xmlFree(*(void **)&v0[v1 + 8]);
          v0 = (char *)xmlCharEncodingAliases;
        }
        ++v2;
        v1 += 16;
      }
      while (v2 < xmlCharEncodingAliasesNb);
    }
    xmlCharEncodingAliasesNb = 0;
    xmlCharEncodingAliasesMax = 0;
    xmlFree(v0);
    xmlCharEncodingAliases = 0;
  }
}

int xmlAddEncodingAlias(const char *name, const char *alias)
{
  int result;
  uint64_t v5;
  char v6;
  char *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int v13;
  char *v14;
  _OWORD v15[6];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  result = -1;
  if (!name || !alias)
    return result;
  v5 = 0;
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  do
  {
    v6 = __toupper(alias[v5]);
    *((_BYTE *)v15 + v5) = v6;
    if (!v6)
      break;
    ++v5;
  }
  while (v5 != 99);
  *((_BYTE *)v15 + v5) = 0;
  v7 = (char *)xmlCharEncodingAliases;
  if (xmlCharEncodingAliases)
  {
    v8 = xmlCharEncodingAliasesNb;
    v9 = xmlCharEncodingAliasesMax;
    if (xmlCharEncodingAliasesNb < xmlCharEncodingAliasesMax)
      goto LABEL_11;
    xmlCharEncodingAliasesMax *= 2;
    v7 = (char *)xmlRealloc((void *)xmlCharEncodingAliases, 32 * v9);
    xmlCharEncodingAliases = (uint64_t)v7;
  }
  else
  {
    xmlCharEncodingAliasesNb = 0;
    xmlCharEncodingAliasesMax = 20;
    v7 = (char *)xmlMalloc(0x140uLL);
    xmlCharEncodingAliases = (uint64_t)v7;
    if (!v7)
      return -1;
  }
  v8 = xmlCharEncodingAliasesNb;
LABEL_11:
  if (v8 < 1)
  {
LABEL_15:
    *(_QWORD *)(xmlCharEncodingAliases + 16 * xmlCharEncodingAliasesNb) = xmlMemStrdup(name);
    v12 = xmlMemStrdup((const char *)v15);
    result = 0;
    v13 = xmlCharEncodingAliasesNb;
    *(_QWORD *)(xmlCharEncodingAliases + 16 * xmlCharEncodingAliasesNb + 8) = v12;
    xmlCharEncodingAliasesNb = v13 + 1;
  }
  else
  {
    v10 = 0;
    v11 = 16 * v8;
    while (strcmp(*(const char **)&v7[v10 + 8], (const char *)v15))
    {
      v10 += 16;
      if (v11 == v10)
        goto LABEL_15;
    }
    xmlFree(*(void **)&v7[v10]);
    v14 = xmlMemStrdup(name);
    result = 0;
    *(_QWORD *)(xmlCharEncodingAliases + v10) = v14;
  }
  return result;
}

int xmlDelEncodingAlias(const char *alias)
{
  int result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;

  result = -1;
  if (alias)
  {
    v3 = xmlCharEncodingAliases;
    if (xmlCharEncodingAliases)
    {
      v4 = xmlCharEncodingAliasesNb;
      if (xmlCharEncodingAliasesNb >= 1)
      {
        v5 = 0;
        for (i = 8; strcmp(*(const char **)(v3 + i), alias); i += 16)
        {
          if (v4 == ++v5)
            return -1;
        }
        xmlFree(*(void **)(v3 + i - 8));
        xmlFree(*(void **)(xmlCharEncodingAliases + i));
        v7 = xmlCharEncodingAliasesNb--;
        memmove((void *)(xmlCharEncodingAliases + i - 8), (const void *)(xmlCharEncodingAliases + i + 8), 16 * (v7 - v5) - 16);
        return 0;
      }
    }
  }
  return result;
}

xmlCharEncoding xmlParseCharEncoding(const char *name)
{
  const char *v1;
  const char *EncodingAlias;
  uint64_t v3;
  char v4;
  BOOL v5;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  BOOL v11;
  BOOL v12;
  BOOL v13;
  BOOL v14;
  BOOL v15;
  BOOL v16;
  BOOL v17;
  _OWORD v28[31];
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (name)
  {
    v1 = name;
    v29 = 0;
    memset(v28, 0, sizeof(v28));
    EncodingAlias = xmlGetEncodingAlias(name);
    v3 = 0;
    if (EncodingAlias)
      v1 = EncodingAlias;
    do
    {
      v4 = __toupper(v1[v3]);
      *((_BYTE *)v28 + v3) = v4;
      if (!v4)
        break;
      ++v3;
    }
    while (v3 != 499);
    *((_BYTE *)v28 + v3) = 0;
    if (LOBYTE(v28[0]))
    {
      v5 = LODWORD(v28[0]) == 759583829 && WORD2(v28[0]) == 56;
      if (v5 || !(LODWORD(v28[0]) ^ 0x38465455 | BYTE4(v28[0])))
      {
        LODWORD(name) = 1;
      }
      else
      {
        v6 = LODWORD(v28[0]) == 759583829 && *(_DWORD *)((char *)v28 + 3) == 3551533;
        if (v6 || (LODWORD(v28[0]) == 826692693 ? (v7 = WORD2(v28[0]) == 54) : (v7 = 0), v7))
        {
          LODWORD(name) = 2;
        }
        else
        {
          v8 = *(_QWORD *)&v28[0] == 0x343630312D4F5349 && *((_QWORD *)&v28[0] + 1) == 0x322D5343552D36;
          if (v8
            || (LODWORD(v28[0]) == 760431445 ? (v9 = WORD2(v28[0]) == 50) : (v9 = 0),
                v9 || !(LODWORD(v28[0]) ^ 0x32534355 | BYTE4(v28[0]))))
          {
            LODWORD(name) = 9;
          }
          else
          {
            v10 = *(_QWORD *)&v28[0] == 0x343630312D4F5349 && *((_QWORD *)&v28[0] + 1) == 0x342D5343552D36;
            if (v10
              || (LODWORD(v28[0]) == 760431445 ? (v11 = WORD2(v28[0]) == 52) : (v11 = 0),
                  v11 || !(LODWORD(v28[0]) ^ 0x34534355 | BYTE4(v28[0]))))
            {
              LODWORD(name) = 4;
            }
            else
            {
              v12 = *(_QWORD *)&v28[0] == 0x393538382D4F5349 && *(_QWORD *)((char *)v28 + 3) == 0x312D393538382DLL;
              if (v12
                || (*(_QWORD *)&v28[0] == 0x4954414C2D4F5349 ? (v13 = DWORD2(v28[0]) == 3222862) : (v13 = 0),
                    v13
                 || (*(_QWORD *)&v28[0] == 0x4954414C204F5349 ? (v14 = DWORD2(v28[0]) == 3219534) : (v14 = 0), v14)))
              {
                LODWORD(name) = 10;
              }
              else
              {
                v15 = *(_QWORD *)&v28[0] == 0x393538382D4F5349 && *(_QWORD *)((char *)v28 + 3) == 0x322D393538382DLL;
                if (v15
                  || (*(_QWORD *)&v28[0] == 0x4954414C2D4F5349 ? (v16 = DWORD2(v28[0]) == 3288398) : (v16 = 0),
                      v16
                   || (*(_QWORD *)&v28[0] == 0x4954414C204F5349 ? (v17 = DWORD2(v28[0]) == 3285070) : (v17 = 0), v17)))
                {
                  LODWORD(name) = 11;
                }
                else if (*(_QWORD *)&v28[0] == 0x393538382D4F5349
                       && *(_QWORD *)((char *)v28 + 3) == 0x332D393538382DLL)
                {
                  LODWORD(name) = 12;
                }
                else if (*(_QWORD *)&v28[0] == 0x393538382D4F5349
                       && *(_QWORD *)((char *)v28 + 3) == 0x342D393538382DLL)
                {
                  LODWORD(name) = 13;
                }
                else if (*(_QWORD *)&v28[0] == 0x393538382D4F5349
                       && *(_QWORD *)((char *)v28 + 3) == 0x352D393538382DLL)
                {
                  LODWORD(name) = 14;
                }
                else if (*(_QWORD *)&v28[0] == 0x393538382D4F5349
                       && *(_QWORD *)((char *)v28 + 3) == 0x362D393538382DLL)
                {
                  LODWORD(name) = 15;
                }
                else if (*(_QWORD *)&v28[0] == 0x393538382D4F5349
                       && *(_QWORD *)((char *)v28 + 3) == 0x372D393538382DLL)
                {
                  LODWORD(name) = 16;
                }
                else if (*(_QWORD *)&v28[0] == 0x393538382D4F5349
                       && *(_QWORD *)((char *)v28 + 3) == 0x382D393538382DLL)
                {
                  LODWORD(name) = 17;
                }
                else if (*(_QWORD *)&v28[0] == 0x393538382D4F5349
                       && *(_QWORD *)((char *)v28 + 3) == 0x392D393538382DLL)
                {
                  LODWORD(name) = 18;
                }
                else if (*(_QWORD *)&v28[0] == 0x323230322D4F5349 && DWORD2(v28[0]) == 5261869)
                {
                  LODWORD(name) = 19;
                }
                else if (*(_QWORD *)&v28[0] == 0x494A5F5446494853 && WORD4(v28[0]) == 83)
                {
                  LODWORD(name) = 20;
                }
                else if (LODWORD(v28[0]) ^ 0x2D435545 | *(_DWORD *)((char *)v28 + 3) ^ 0x504A2D)
                {
                  LODWORD(name) = -1;
                }
                else
                {
                  LODWORD(name) = 21;
                }
              }
            }
          }
        }
      }
    }
    else
    {
      LODWORD(name) = 0;
    }
  }
  return (int)name;
}

const char *__cdecl xmlGetCharEncodingName(xmlCharEncoding enc)
{
  if ((enc - 1) > 0x14)
    return 0;
  else
    return off_1E616CCE8[enc - 1];
}

uint64_t UTF8ToUTF8(void *__dst, unsigned int *a2, void *__src, _DWORD *a4)
{
  uint64_t result;
  size_t v8;

  result = 0xFFFFFFFFLL;
  if (__dst && a2 && a4)
  {
    if (__src)
    {
      if ((signed int)*a2 >= *a4)
        v8 = *a4;
      else
        v8 = *a2;
      if ((v8 & 0x80000000) != 0)
      {
        return 0xFFFFFFFFLL;
      }
      else
      {
        memcpy(__dst, __src, v8);
        *a2 = v8;
        *a4 = v8;
        return *a2;
      }
    }
    else
    {
      result = 0;
      *a2 = 0;
      *a4 = 0;
    }
  }
  return result;
}

uint64_t UTF16LEToUTF8(_BYTE *a1, unsigned int *a2, unsigned __int16 *a3, int *a4)
{
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  _BYTE *v8;
  unsigned __int16 *v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int16 *v12;
  unsigned int v13;
  unsigned __int16 v14;
  char v15;
  char v16;
  unsigned int v17;
  BOOL v18;
  uint64_t result;

  v4 = (int)*a2;
  if (!(_DWORD)v4)
  {
    result = 0;
    *a4 = 0;
    return result;
  }
  v5 = *a4;
  if ((*a4 & 0x80000001) == 1)
    *a4 = --v5;
  if (v5 >= 0)
    v6 = v5;
  else
    v6 = v5 + 1;
  v7 = v5 + 1;
  LODWORD(v8) = (_DWORD)a1;
  LODWORD(v9) = (_DWORD)a3;
  if (v7 < 3)
  {
LABEL_39:
    *a2 = (_DWORD)v8 - (_DWORD)a1;
    *a4 = (_DWORD)v9 - (_DWORD)a3;
    return *a2;
  }
  v10 = (unint64_t)&a1[v4];
  v9 = a3;
  v8 = a1;
  v11 = (unint64_t)&a3[v6 >> 1];
  while (1)
  {
    v12 = v9;
    if (v8 - a1 + 5 >= (int)*a2)
    {
LABEL_38:
      LODWORD(v9) = (_DWORD)v12;
      goto LABEL_39;
    }
    ++v9;
    v13 = *v12;
    if ((v13 & 0xFC00) == 0xD800)
      break;
LABEL_14:
    if ((unint64_t)v8 >= v10)
      goto LABEL_38;
    if (v13 <= 0x7F)
    {
      *v8++ = v13;
    }
    else
    {
      if (v13 >= 0x10000)
        v15 = 18;
      else
        v15 = 12;
      if (v13 >= 0x10000)
        v16 = -16;
      else
        v16 = -32;
      if (v13 < 0x800)
      {
        v15 = 6;
        v16 = -64;
      }
      *v8++ = v16 | (v13 >> v15);
      if ((unint64_t)v8 < v10)
      {
        if (v13 >= 0x10000)
          v17 = 12;
        else
          v17 = 6;
        if (v13 < 0x800)
          v17 = 0;
        do
        {
          *v8++ = (v13 >> v17) & 0x3F | 0x80;
          v18 = v17 >= 6;
          v17 -= 6;
        }
        while (v18 && (unint64_t)v8 < v10);
      }
    }
    if ((unint64_t)v9 >= v11)
      goto LABEL_39;
  }
  if ((unint64_t)v9 >= v11)
    goto LABEL_38;
  v14 = *v9;
  if ((*v9 & 0xFC00) == 0xDC00)
  {
    v9 = v12 + 2;
    v13 = (v14 & 0x3FF | ((v13 & 0x3FF) << 10)) + 0x10000;
    goto LABEL_14;
  }
  *a2 = (_DWORD)v8 - (_DWORD)a1;
  *a4 = (_DWORD)v12 - (_DWORD)a3;
  return 4294967294;
}

uint64_t UTF8ToUTF16LE(_WORD *a1, int *a2, char *a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  _WORD *v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  char v18;

  v4 = 0xFFFFFFFFLL;
  if (a1 && a2 && a4)
  {
    if (a3)
    {
      v5 = *a4;
      if (*a2 >= 0)
        v6 = *a2;
      else
        v6 = *a2 + 1;
      LODWORD(v7) = (_DWORD)a1;
      LODWORD(v8) = (_DWORD)a3;
      if ((int)v5 >= 1)
      {
        v9 = (unint64_t)&a3[v5];
        v10 = (unint64_t)&a1[v6 >> 1];
        v11 = a3;
        v7 = a1;
        v8 = a3;
        do
        {
          v12 = *v8++;
          v13 = v12;
          if (v12 < 0)
          {
            if (v13 <= 0xBF)
              goto LABEL_38;
            if (v13 > 0xDF)
            {
              if (v13 > 0xEF)
              {
                if (v13 > 0xF7)
                {
LABEL_38:
                  *a2 = (_DWORD)v7 - (_DWORD)a1;
                  *a4 = (_DWORD)v11 - (_DWORD)a3;
                  return 4294967294;
                }
                v15 = v13 & 7;
                v14 = 3;
              }
              else
              {
                v15 = v13 & 0xF;
                v14 = 2;
              }
            }
            else
            {
              v15 = v13 & 0x1F;
              v14 = 1;
            }
          }
          else
          {
            v14 = 0;
            v15 = v13;
          }
          if ((uint64_t)(v9 - (_QWORD)v8) < v14)
            goto LABEL_35;
          if ((v13 & 0x80) == 0 || (unint64_t)v8 >= v9)
            goto LABEL_27;
          v16 = 0;
          v17 = v14 - 1;
          do
          {
            v8 = &v11[v16 + 2];
            v18 = v11[v16 + 1];
            if ((v18 & 0xC0) != 0x80)
              break;
            v15 = v18 & 0x3F | (v15 << 6);
            if (v17 == (_DWORD)v16)
              break;
            ++v16;
          }
          while ((unint64_t)v8 < v9);
          if (HIWORD(v15))
          {
            if (HIWORD(v15) > 0x10u || (unint64_t)(v7 + 1) >= v10)
            {
LABEL_35:
              LODWORD(v8) = (_DWORD)v11;
              break;
            }
            *v7 = ((v15 + 16711680) >> 10) | 0xD800;
            v7[1] = v15 & 0x3FF | 0xDC00;
            v7 += 2;
          }
          else
          {
LABEL_27:
            if ((unint64_t)v7 >= v10)
              goto LABEL_35;
            *v7++ = v15;
          }
          v11 = v8;
        }
        while ((unint64_t)v8 < v9);
      }
      *a2 = (_DWORD)v7 - (_DWORD)a1;
      *a4 = (_DWORD)v8 - (_DWORD)a3;
      return *a2;
    }
    else
    {
      v4 = 0;
      *a2 = 0;
      *a4 = 0;
    }
  }
  return v4;
}

uint64_t UTF16BEToUTF8(_BYTE *a1, unsigned int *a2, unsigned __int8 *a3, int *a4)
{
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  _BYTE *v8;
  unsigned __int8 *v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 *v12;
  int v13;
  unsigned int v14;
  unsigned __int8 v15;
  char v16;
  char v17;
  unsigned int v18;
  BOOL v19;
  uint64_t result;

  v4 = (int)*a2;
  if (!(_DWORD)v4)
  {
    result = 0;
    *a4 = 0;
    return result;
  }
  v5 = *a4;
  if ((*a4 & 0x80000001) == 1)
    *a4 = --v5;
  if (v5 >= 0)
    v6 = v5;
  else
    v6 = v5 + 1;
  v7 = v5 + 1;
  LODWORD(v8) = (_DWORD)a1;
  LODWORD(v9) = (_DWORD)a3;
  if (v7 < 3)
  {
LABEL_39:
    *a2 = (_DWORD)v8 - (_DWORD)a1;
    *a4 = (_DWORD)v9 - (_DWORD)a3;
    return *a2;
  }
  v10 = (unint64_t)&a1[v4];
  v9 = a3;
  v8 = a1;
  v11 = (unint64_t)&a3[2 * (v6 >> 1)];
  while (1)
  {
    v12 = v9;
    if (v8 - a1 + 5 >= (int)*a2)
    {
LABEL_38:
      LODWORD(v9) = (_DWORD)v12;
      goto LABEL_39;
    }
    v13 = *v9;
    v14 = v9[1] | (v13 << 8);
    v9 += 2;
    if ((v13 & 0xFC) == 0xD8)
      break;
LABEL_14:
    if ((unint64_t)v8 >= v10)
      goto LABEL_38;
    if (v14 <= 0x7F)
    {
      *v8++ = v14;
    }
    else
    {
      if (v14 >= 0x10000)
        v16 = 18;
      else
        v16 = 12;
      if (v14 >= 0x10000)
        v17 = -16;
      else
        v17 = -32;
      if (v14 < 0x800)
      {
        v16 = 6;
        v17 = -64;
      }
      *v8++ = v17 | (v14 >> v16);
      if ((unint64_t)v8 < v10)
      {
        if (v14 >= 0x10000)
          v18 = 12;
        else
          v18 = 6;
        if (v14 < 0x800)
          v18 = 0;
        do
        {
          *v8++ = (v14 >> v18) & 0x3F | 0x80;
          v19 = v18 >= 6;
          v18 -= 6;
        }
        while (v19 && (unint64_t)v8 < v10);
      }
    }
    if ((unint64_t)v9 >= v11)
      goto LABEL_39;
  }
  if ((unint64_t)v9 >= v11)
    goto LABEL_38;
  v15 = *v9;
  if ((*v9 & 0xFC) == 0xDC)
  {
    v9 = v12 + 4;
    v14 = (v12[3] | ((v15 & 3) << 8) & 0x3FF | ((v14 & 0x3FF) << 10)) + 0x10000;
    goto LABEL_14;
  }
  *a2 = (_DWORD)v8 - (_DWORD)a1;
  *a4 = (_DWORD)v12 - (_DWORD)a3;
  return 4294967294;
}

uint64_t UTF8ToUTF16BE(_BYTE *a1, int *a2, char *a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  _BYTE *v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  char v18;
  uint64_t v19;
  uint64_t v20;

  v4 = 0xFFFFFFFFLL;
  if (a1 && a2 && a4)
  {
    if (a3)
    {
      v5 = *a4;
      if (*a2 >= 0)
        v6 = *a2;
      else
        v6 = *a2 + 1;
      LODWORD(v7) = (_DWORD)a1;
      LODWORD(v8) = (_DWORD)a3;
      if ((int)v5 >= 1)
      {
        v9 = (unint64_t)&a3[v5];
        v10 = (unint64_t)&a1[2 * (v6 >> 1)];
        v11 = a3;
        v7 = a1;
        v8 = a3;
        do
        {
          v12 = *v8++;
          v13 = v12;
          if (v12 < 0)
          {
            if (v13 <= 0xBF)
              goto LABEL_38;
            if (v13 > 0xDF)
            {
              if (v13 > 0xEF)
              {
                if (v13 > 0xF7)
                {
LABEL_38:
                  *a2 = (unint64_t)(v7 - a1) >> 1;
                  *a4 = (_DWORD)v11 - (_DWORD)a3;
                  return 4294967294;
                }
                v15 = v13 & 7;
                v14 = 3;
              }
              else
              {
                v15 = v13 & 0xF;
                v14 = 2;
              }
            }
            else
            {
              v15 = v13 & 0x1F;
              v14 = 1;
            }
          }
          else
          {
            v14 = 0;
            v15 = v13;
          }
          if ((uint64_t)(v9 - (_QWORD)v8) < v14)
            goto LABEL_35;
          if ((v13 & 0x80) == 0 || (unint64_t)v8 >= v9)
            goto LABEL_27;
          v16 = 0;
          v17 = v14 - 1;
          do
          {
            v8 = &v11[v16 + 2];
            v18 = v11[v16 + 1];
            if ((v18 & 0xC0) != 0x80)
              break;
            v15 = v18 & 0x3F | (v15 << 6);
            if (v17 == (_DWORD)v16)
              break;
            ++v16;
          }
          while ((unint64_t)v8 < v9);
          if (HIWORD(v15))
          {
            if (HIWORD(v15) > 0x10u || (unint64_t)(v7 + 2) >= v10)
            {
LABEL_35:
              LODWORD(v8) = (_DWORD)v11;
              break;
            }
            *v7 = ((v15 - 0x10000) >> 18) | 0xD8;
            v7[1] = (v15 - 0x10000) >> 10;
            v7[2] = BYTE1(v15) & 3 | 0xDC;
            v19 = 3;
            v20 = 2;
          }
          else
          {
LABEL_27:
            if ((unint64_t)v7 >= v10)
              goto LABEL_35;
            *v7 = BYTE1(v15);
            v19 = 1;
            v20 = 1;
          }
          v7[v19] = v15;
          v11 = v8;
          v7 += 2 * v20;
        }
        while ((unint64_t)v8 < v9);
      }
      *a2 = (_DWORD)v7 - (_DWORD)a1;
      *a4 = (_DWORD)v8 - (_DWORD)a3;
      return *a2;
    }
    else
    {
      v4 = 0;
      *a2 = 0;
      *a4 = 0;
    }
  }
  return v4;
}

uint64_t UTF8ToUTF16(_WORD *a1, int *a2, char *a3, int *a4)
{
  uint64_t result;

  if (a3)
    return UTF8ToUTF16LE(a1, a2, a3, a4);
  if (*a2 < 2)
  {
    result = 0;
    *a2 = 0;
  }
  else
  {
    *a1 = -257;
    result = 2;
    *a2 = 2;
  }
  *a4 = 0;
  return result;
}

uint64_t asciiToUTF8(uint64_t a1, unsigned int *a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  int v9;
  int v10;

  v4 = *a4;
  if ((int)v4 < 1)
  {
    LODWORD(v8) = a1;
    v10 = a3;
LABEL_10:
    *a2 = (_DWORD)v8 - a1;
    *a4 = v10 - a3;
    return *a2;
  }
  else
  {
    v5 = 0;
    v6 = a1 + (int)*a2;
    v7 = a3 + v4;
    while (1)
    {
      v8 = (_BYTE *)(a1 + v5);
      if (v5 + 5 >= (int)*a2 || (unint64_t)v8 >= v6)
      {
        v10 = a3 + v5;
        goto LABEL_10;
      }
      v9 = *(char *)(a3 + v5);
      if (v9 < 0)
        break;
      *v8 = v9;
      v10 = a3 + ++v5;
      if (a3 + v5 >= v7)
      {
        LODWORD(v8) = a1 + v5;
        goto LABEL_10;
      }
    }
    *a2 = v5;
    *a4 = v5;
    return 4294967294;
  }
}

uint64_t UTF8Toascii(_BYTE *a1, unsigned int *a2, char *a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  char *v16;
  char v17;

  v4 = 0xFFFFFFFFLL;
  if (a1 && a2 && a4)
  {
    if (a3)
    {
      v5 = *a4;
      LODWORD(v6) = (_DWORD)a1;
      LODWORD(v7) = (_DWORD)a3;
      if ((int)v5 < 1)
      {
LABEL_30:
        *a2 = (_DWORD)v6 - (_DWORD)a1;
        *a4 = (_DWORD)v7 - (_DWORD)a3;
        return *a2;
      }
      else
      {
        v8 = (unint64_t)&a3[v5];
        v9 = (unint64_t)&a1[*a2];
        v10 = a3;
        v6 = a1;
        v7 = a3;
        while (1)
        {
          v11 = *v7++;
          v12 = v11;
          if (v11 < 0)
          {
            if (v12 <= 0xBF)
              break;
            if (v12 > 0xDF)
            {
              if (v12 > 0xEF)
              {
                if (v12 > 0xF7)
                  break;
                v14 = v12 & 7;
                v13 = 3;
              }
              else
              {
                v14 = v12 & 0xF;
                v13 = 2;
              }
            }
            else
            {
              v14 = v12 & 0x1F;
              v13 = 1;
            }
          }
          else
          {
            v13 = 0;
            v14 = v12;
          }
          if ((uint64_t)(v8 - (_QWORD)v7) < v13)
          {
LABEL_29:
            LODWORD(v7) = (_DWORD)v10;
            goto LABEL_30;
          }
          if ((v12 & 0x80) != 0 && (unint64_t)v7 < v8)
          {
            v15 = v13 - 1;
            v16 = v10 + 2;
            do
            {
              v7 = v16;
              v17 = *(v16 - 1);
              if ((v17 & 0xC0) != 0x80)
                break;
              v14 = v17 & 0x3F | (v14 << 6);
              if (v15-- == 0)
                break;
              v16 = v7 + 1;
            }
            while ((unint64_t)v7 < v8);
          }
          if (v14 > 0x7F)
            break;
          if ((unint64_t)v6 >= v9)
            goto LABEL_29;
          *v6++ = v14;
          v10 = v7;
          if ((unint64_t)v7 >= v8)
            goto LABEL_30;
        }
        *a2 = (_DWORD)v6 - (_DWORD)a1;
        *a4 = (_DWORD)v10 - (_DWORD)a3;
        return 4294967294;
      }
    }
    else
    {
      v4 = 0;
      *a2 = 0;
      *a4 = 0;
    }
  }
  return v4;
}

void xmlCleanupCharEncodingHandlers(void)
{
  _QWORD *v0;
  int v1;
  void **v2;
  void *v3;

  xmlCleanupEncodingAliases();
  v0 = (_QWORD *)handlers;
  if (handlers)
  {
    v1 = nbCharEncodingHandler;
    if (nbCharEncodingHandler >= 1)
    {
      do
      {
        nbCharEncodingHandler = --v1;
        v2 = (void **)v0[v1];
        if (v2)
        {
          v3 = *v2;
          if (v3)
          {
            xmlFree(v3);
            v0 = (_QWORD *)handlers;
            v1 = nbCharEncodingHandler;
          }
          xmlFree((void *)v0[v1]);
          v0 = (_QWORD *)handlers;
          v1 = nbCharEncodingHandler;
        }
      }
      while (v1 > 0);
    }
    xmlFree(v0);
    handlers = 0;
    nbCharEncodingHandler = 0;
  }
}

xmlCharEncodingHandlerPtr xmlFindCharEncodingHandler(const char *name)
{
  const char *v1;
  const char *EncodingAlias;
  uint64_t v3;
  const char *v4;
  char v5;
  const char ***v6;
  uint64_t v7;
  xmlCharEncodingHandler *v8;
  uconv_t *v9;
  unint64_t v10;
  uconv_t *v11;
  xmlCharEncodingHandler *v12;
  xmlCharEncoding v13;
  const char *CharEncodingName;
  const char *v15;
  char __s1[16];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  int v23;
  uint64_t v24;

  while (1)
  {
    v1 = name;
    v24 = *MEMORY[0x1E0C80C00];
    if (handlers)
    {
      if (!name)
        return 0;
    }
    else
    {
      xmlInitCharEncodingHandlers();
      if (!v1)
        return 0;
    }
    if (!*v1)
      return 0;
    v23 = 0;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    *(_OWORD *)__s1 = 0u;
    v18 = 0u;
    EncodingAlias = xmlGetEncodingAlias(v1);
    v3 = 0;
    v4 = EncodingAlias ? EncodingAlias : v1;
    do
    {
      v5 = __toupper(v4[v3]);
      __s1[v3] = v5;
      if (!v5)
        break;
      ++v3;
    }
    while (v3 != 99);
    __s1[v3] = 0;
    v6 = (const char ***)handlers;
    if (handlers)
    {
      v7 = nbCharEncodingHandler;
      if (nbCharEncodingHandler >= 1)
        break;
    }
LABEL_15:
    v9 = (uconv_t *)openIcuConverter((uint64_t)v4, 1);
    v10 = (unint64_t)openIcuConverter((uint64_t)v4, 0);
    v11 = (uconv_t *)v10;
    if (v9 && v10)
    {
      v12 = (xmlCharEncodingHandler *)xmlMalloc(0x28uLL);
      v8 = v12;
      if (v12)
      {
        v12->uconv_out = 0;
        *(_OWORD *)&v12->name = 0u;
        *(_OWORD *)&v12->output = 0u;
        v12->name = xmlMemStrdup(v4);
        v8->input = 0;
        v8->output = 0;
        v8->uconv_in = v9;
        v8->uconv_out = v11;
      }
      else
      {
        ucnv_close();
        ucnv_close();
        xmlFree(v9);
        ucnv_close();
        ucnv_close();
        xmlFree(v11);
      }
      return v8;
    }
    if ((unint64_t)v9 | v10)
    {
      closeIcuConverter(v9);
      closeIcuConverter(v11);
      __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 1, 3, 0, 0, (const xmlChar *)v4, 0, 0, 0, 0, "ICU converter : problems with filters for '%s'\n", (char)v4);
    }
    v13 = xmlParseCharEncoding(v1);
    if (v13 == XML_CHAR_ENCODING_ERROR)
      return 0;
    CharEncodingName = xmlGetCharEncodingName(v13);
    if (!CharEncodingName)
      return 0;
    v15 = CharEncodingName;
    if (!strcmp(v4, CharEncodingName))
      return 0;
    name = v15;
  }
  while (1)
  {
    v8 = (xmlCharEncodingHandler *)*v6;
    if (!strcmp(__s1, **v6))
      return v8;
    ++v6;
    if (!--v7)
      goto LABEL_15;
  }
}

_QWORD *openIcuConverter(uint64_t a1, int a2)
{
  _QWORD *v3;

  v3 = xmlMalloc(0x820uLL);
  if (v3)
  {
    if (linkedOnOrAfterFall2022OSVersions())
    {
      v3[258] = v3 + 2;
      v3[259] = v3 + 2;
    }
    *v3 = ucnv_open();
    if (a2)
      ucnv_setToUCallBack();
    else
      ucnv_setFromUCallBack();
    v3[1] = ucnv_open();
  }
  return v3;
}

void closeIcuConverter(void *a1)
{
  if (a1)
  {
    ucnv_close();
    ucnv_close();
    xmlFree(a1);
  }
}

uint64_t xmlCharEncFirstLineInt(uint64_t a1, xmlBufferPtr buf, uint64_t a3, signed int a4)
{
  uint64_t result;
  unsigned int use;
  signed int v9;
  signed int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int len;
  unsigned int v15;

  result = 0xFFFFFFFFLL;
  if (a1 && buf && a3)
  {
    use = buf->use;
    v9 = buf->size + ~use;
    v10 = *(_DWORD *)(a3 + 8);
    len = v10;
    v15 = v9;
    if (a4 < 0)
    {
      if (v10 >= 181)
      {
        v10 = 180;
        len = 180;
      }
    }
    else if (v10 > a4)
    {
      len = a4;
      v10 = a4;
    }
    if (2 * v10 >= v9)
    {
      xmlBufferGrow(buf, 2 * v10);
      use = buf->use;
      v15 = buf->size + ~use;
    }
    v11 = xmlEncInputChunk(a1, (uint64_t)&buf->content[use], &v15, *(_QWORD *)a3, &len, 0);
    xmlBufferShrink((xmlBufferPtr)a3, len);
    v12 = buf->use + v15;
    buf->use = v12;
    buf->content[v12] = 0;
    if (v11 == -1)
      v13 = -3;
    else
      v13 = v11;
    if (v13 == -3)
      v13 = 0;
    if (v15)
      return v15;
    else
      return v13;
  }
  return result;
}

uint64_t xmlEncInputChunk(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, _DWORD *a5, int a6)
{
  uint64_t (*v6)(uint64_t, _DWORD *, uint64_t, _DWORD *);
  int v7;
  uint64_t v9;

  v6 = *(uint64_t (**)(uint64_t, _DWORD *, uint64_t, _DWORD *))(a1 + 8);
  if (v6)
  {
    v7 = v6(a2, a3, a4, a5);
    return v7 & (v7 >> 31);
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 24);
    if (v9)
    {
      return xmlUconvWrapper(v9, 1, a2, a3, a4, a5, a6);
    }
    else
    {
      *a3 = 0;
      *a5 = 0;
      return 4294967294;
    }
  }
}

int xmlCharEncFirstLine(xmlCharEncodingHandler *handler, xmlBufferPtr out, xmlBufferPtr in)
{
  return xmlCharEncFirstLineInt((uint64_t)handler, out, (uint64_t)in, -1);
}

size_t xmlCharEncFirstLineInput(uint64_t a1, int a2)
{
  xmlBuf *v3;
  const xmlBuf *v4;
  size_t result;
  size_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  xmlChar *v13;
  xmlChar *v14;
  int v15;
  int v16;
  xmlChar *v17;
  unsigned int v18;
  int v19;
  _BYTE len[68];

  *(_QWORD *)&len[60] = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0xFFFFFFFFLL;
  if (!*(_QWORD *)(a1 + 24))
    return 0xFFFFFFFFLL;
  v3 = *(xmlBuf **)(a1 + 32);
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = *(const xmlBuf **)(a1 + 40);
  if (!v4)
    return 0xFFFFFFFFLL;
  result = xmlBufUse(*(const xmlBufPtr *)(a1 + 40));
  if (result)
  {
    v7 = result;
    v8 = xmlBufAvail((unint64_t)v3);
    if (a2 >= 0)
      v9 = a2;
    else
      v9 = 180;
    if (v9 >= v7)
      v10 = v7;
    else
      v10 = v9;
    if (2 * v10 >= v8)
    {
      xmlBufGrow((uint64_t)v3, 2 * v10);
      v8 = xmlBufAvail((unint64_t)v3);
    }
    v11 = 360;
    if (v8 < 0x168)
      v11 = v8;
    v19 = v11;
    *(_DWORD *)len = v10;
    v12 = *(_QWORD *)(a1 + 24);
    v13 = xmlBufEnd(v3);
    v14 = xmlBufContent(v4);
    v15 = xmlEncInputChunk(v12, (uint64_t)v13, &v19, (uint64_t)v14, len, 0);
    xmlBufShrink(v4, *(int *)len);
    xmlBufAddLen((uint64x2_t *)v3, v19);
    if (v15 == -1)
      v16 = -3;
    else
      v16 = v15;
    if (v16 == -2)
    {
      memset(&len[4], 0, 49);
      v17 = xmlBufContent(v4);
      snprintf(&len[4], 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *v17, v17[1], v17[2], v17[3]);
      len[53] = 0;
      __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6003, 3, 0, 0, &len[4], 0, 0, 0, 0, "input conversion failed due to input error, bytes %s\n", (char)&len[4]);
    }
    if (v16 == -3)
      v18 = 0;
    else
      v18 = v16;
    if (v19)
      return v19;
    else
      return v18;
  }
  return result;
}

size_t xmlCharEncInput(uint64_t a1, int a2)
{
  xmlBuf *v3;
  const xmlBuf *v4;
  size_t result;
  uint64_t v8;
  unint64_t v9;
  int v11;
  uint64_t v12;
  xmlChar *v13;
  xmlChar *v14;
  int v15;
  int v16;
  xmlChar *v17;
  int v18;
  int v19;
  _BYTE len[68];

  *(_QWORD *)&len[60] = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0xFFFFFFFFLL;
  if (!*(_QWORD *)(a1 + 24))
    return 0xFFFFFFFFLL;
  v3 = *(xmlBuf **)(a1 + 32);
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = *(const xmlBuf **)(a1 + 40);
  if (!v4)
    return 0xFFFFFFFFLL;
  result = xmlBufUse(*(const xmlBufPtr *)(a1 + 40));
  if (result)
  {
    if (result > 0x10000 && a2 == 0)
      v8 = 0x10000;
    else
      v8 = result;
    v9 = xmlBufAvail((unint64_t)v3);
    if (2 * v8 >= v9)
    {
      xmlBufGrow((uint64_t)v3, 2 * v8);
      v9 = xmlBufAvail((unint64_t)v3);
    }
    if (v9 > 0x20000 && a2 == 0)
      v11 = 0x20000;
    else
      v11 = v9;
    v19 = v11;
    *(_DWORD *)len = v8;
    v12 = *(_QWORD *)(a1 + 24);
    v13 = xmlBufEnd(v3);
    v14 = xmlBufContent(v4);
    v15 = xmlEncInputChunk(v12, (uint64_t)v13, &v19, (uint64_t)v14, len, a2);
    xmlBufShrink(v4, *(int *)len);
    xmlBufAddLen((uint64x2_t *)v3, v19);
    if (v15 == -1)
      v16 = -3;
    else
      v16 = v15;
    if (v16 == -2)
    {
      memset(&len[4], 0, 49);
      v17 = xmlBufContent(v4);
      snprintf(&len[4], 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *v17, v17[1], v17[2], v17[3]);
      len[53] = 0;
      __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6003, 3, 0, 0, &len[4], 0, 0, 0, 0, "input conversion failed due to input error, bytes %s\n", (char)&len[4]);
    }
    if (v16 == -3)
      v18 = 0;
    else
      v18 = v16;
    if (v18 >= 0)
      return v19;
    else
      return v18;
  }
  return result;
}

int xmlCharEncInFunc(xmlCharEncodingHandler *handler, xmlBufferPtr out, xmlBufferPtr in)
{
  int result;
  unsigned int use;
  unsigned int v8;
  unsigned int size;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int len;
  int v16;
  char __str[16];
  __int128 v18;
  __int128 v19;
  char v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = -1;
  if (handler && out && in)
  {
    use = in->use;
    len = use;
    if (use)
    {
      v8 = out->use;
      size = out->size;
      v16 = size + ~v8;
      v10 = 2 * use;
      if (v10 >= v16)
      {
        xmlBufferGrow(out, size + v10);
        v8 = out->use;
        v16 = out->size + ~v8;
      }
      v11 = xmlEncInputChunk((uint64_t)handler, (uint64_t)&out->content[v8], &v16, (uint64_t)in->content, &len, 1);
      xmlBufferShrink(in, len);
      v12 = out->use + v16;
      out->use = v12;
      out->content[v12] = 0;
      if (v11 == -1)
        v13 = -3;
      else
        v13 = v11;
      if (v13 == -2)
      {
        v20 = 0;
        v18 = 0u;
        v19 = 0u;
        *(_OWORD *)__str = 0u;
        snprintf(__str, 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *in->content, in->content[1], in->content[2], in->content[3]);
        v21 = 0;
        __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6003, 3, 0, 0, (const xmlChar *)__str, 0, 0, 0, 0, "input conversion failed due to input error, bytes %s\n", (char)__str);
      }
      if (v13 == -3)
        v14 = 0;
      else
        v14 = v13;
      if (v16)
        return v16;
      else
        return v14;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t xmlCharEncOutput(_QWORD *a1, int a2)
{
  xmlBuf *v3;
  xmlBuf *v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  xmlChar *v9;
  uint64_t v10;
  size_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  xmlChar *v16;
  xmlChar *v17;
  unsigned int v18;
  xmlChar *v19;
  int UTF8Char;
  int v21;
  uint64_t v22;
  xmlChar *v23;
  int len[3];
  char v25[16];
  __int128 v26;
  __int128 v27;
  char v28;
  char v29;
  char __str[8];
  uint64_t v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0xFFFFFFFFLL;
  if (!a1[3])
    return 0xFFFFFFFFLL;
  v3 = (xmlBuf *)a1[4];
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = (xmlBuf *)a1[5];
  if (!v4)
    return 0xFFFFFFFFLL;
  *(_QWORD *)&len[1] = 0;
  v6 = xmlBufAvail((unint64_t)v4);
  v7 = v6;
  if (a2)
  {
    *(_QWORD *)&len[1] = v6;
    v8 = a1[3];
    v9 = xmlBufEnd(v4);
    xmlEncOutputChunk(v8, (uint64_t)v9, &len[1], 0, &len[2]);
    xmlBufAddLen((uint64x2_t *)v4, len[1]);
    return len[1];
  }
  v12 = xmlBufUse(v3);
  v10 = 0;
  if (!v12)
    return v10;
  while (1)
  {
    if (v12 >= 0x10000)
      v13 = 0x10000;
    else
      v13 = v12;
    if (4 * v13 >= v7)
    {
      xmlBufGrow((uint64_t)v4, 4 * v13);
      v7 = xmlBufAvail((unint64_t)v4);
    }
    v14 = v7 >= 0x40000 ? 0x40000 : v7;
    *(_QWORD *)&len[1] = __PAIR64__(v13, v14);
    v15 = a1[3];
    v16 = xmlBufEnd(v4);
    v17 = xmlBufContent(v3);
    v18 = xmlEncOutputChunk(v15, (uint64_t)v16, &len[1], (uint64_t)v17, &len[2]);
    xmlBufShrink(v3, len[2]);
    xmlBufAddLen((uint64x2_t *)v4, len[1]);
    v10 = (len[1] + v10);
    if (v18 == -2)
      break;
    if (v18 != -1)
    {
      if (v18 == -4)
      {
        __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6004, 3, 0, 0, 0, 0, 0, 0, 0, "xmlCharEncOutFunc: no output function !\n", 0);
        v18 = -1;
      }
      goto LABEL_33;
    }
    if (len[1] < 1)
    {
      v18 = -3;
      goto LABEL_33;
    }
LABEL_26:
    v7 = xmlBufAvail((unint64_t)v4);
    v12 = xmlBufUse(v3);
    if (!v12)
      return v10;
  }
  *(_QWORD *)__str = 0;
  v31 = 0;
  v32 = 0;
  len[0] = 0;
  len[0] = xmlBufUse(v3);
  v19 = xmlBufContent(v3);
  UTF8Char = xmlGetUTF8Char(v19, len);
  if (UTF8Char < 1)
  {
    v18 = -2;
    goto LABEL_33;
  }
  v21 = snprintf(__str, 0x14uLL, "&#%d;", UTF8Char);
  xmlBufShrink(v3, len[0]);
  xmlBufGrow((uint64_t)v4, 4 * v21);
  len[1] = xmlBufAvail((unint64_t)v4);
  len[2] = v21;
  v22 = a1[3];
  v23 = xmlBufEnd(v4);
  v18 = xmlEncOutputChunk(v22, (uint64_t)v23, &len[1], (uint64_t)__str, &len[2]);
  if ((v18 & 0x80000000) == 0 && len[2] == v21)
  {
    xmlBufAddLen((uint64x2_t *)v4, len[1]);
    v10 = (len[1] + v10);
    goto LABEL_26;
  }
  v28 = 0;
  v26 = 0u;
  v27 = 0u;
  *(_OWORD *)v25 = 0u;
  snprintf(v25, 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *v19, v19[1], v19[2], v19[3]);
  v29 = 0;
  __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6003, 3, 0, 0, (const xmlChar *)v25, 0, 0, 0, 0, "output conversion failed due to conv error, bytes %s\n", (char)v25);
  if (xmlBufGetAllocationScheme((uint64_t)v3) != 2)
    *v19 = 32;
LABEL_33:
  if ((_DWORD)v10)
    return v10;
  else
    return v18;
}

uint64_t xmlEncOutputChunk(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t (*v5)(uint64_t, _DWORD *, uint64_t, _DWORD *);
  int v6;
  uint64_t v8;

  v5 = *(uint64_t (**)(uint64_t, _DWORD *, uint64_t, _DWORD *))(a1 + 16);
  if (v5)
  {
    v6 = v5(a2, a3, a4, a5);
    return v6 & (v6 >> 31);
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 32);
    if (v8)
    {
      return xmlUconvWrapper(v8, 0, a2, a3, a4, a5, 1);
    }
    else
    {
      *a3 = 0;
      *a5 = 0;
      return 4294967292;
    }
  }
}

int xmlCharEncOutFunc(xmlCharEncodingHandler *handler, xmlBufferPtr out, xmlBufferPtr in)
{
  int result;
  uint64_t use;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  signed int v12;
  unsigned int v13;
  int UTF8Char;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  signed int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int len;
  signed int v23;
  char v24[16];
  __int128 v25;
  __int128 v26;
  char v27;
  char v28;
  char __str[8];
  uint64_t v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  result = -1;
  if (!handler || !out)
    return result;
  use = out->use;
  v8 = out->size - use - ((signed int)(out->size - use) > 0);
  v23 = v8;
  if (!in)
  {
    len = 0;
    xmlEncOutputChunk((uint64_t)handler, (uint64_t)&out->content[use], &v23, 0, &len);
    result = 0;
    v20 = out->use + v23;
    out->use = v20;
    out->content[v20] = 0;
    return result;
  }
  v9 = in->use;
  len = v9;
  if (!v9)
    return 0;
  v10 = 0;
  while (1)
  {
    if ((int)(4 * v9) >= v8)
    {
      xmlBufferGrow(out, 4 * v9);
      LODWORD(use) = out->use;
      v23 = out->size + ~(_DWORD)use;
    }
    v11 = xmlEncOutputChunk((uint64_t)handler, (uint64_t)&out->content[use], &v23, (uint64_t)in->content, &len);
    xmlBufferShrink(in, len);
    v12 = v23;
    v13 = out->use + v23;
    out->use = v13;
    v10 += v12;
    out->content[v13] = 0;
    if (v11 == -2)
      break;
    if (v11 != -1)
    {
      if (v11 == -4)
      {
        __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6004, 3, 0, 0, 0, 0, 0, 0, 0, "xmlCharEncOutFunc: no output function !\n", 0);
        v11 = -1;
      }
      goto LABEL_24;
    }
    if (v23 < 1)
    {
      v11 = -3;
      goto LABEL_24;
    }
LABEL_16:
    LODWORD(use) = out->use;
    v8 = out->size - use - ((signed int)(out->size - use) > 0);
    v9 = in->use;
    len = v9;
    v23 = v8;
    if (!v9)
      return 0;
  }
  *(_QWORD *)__str = 0;
  v30 = 0;
  v31 = 0;
  v21 = in->use;
  UTF8Char = xmlGetUTF8Char(in->content, (int *)&v21);
  if (UTF8Char < 1)
  {
    v11 = -2;
    goto LABEL_24;
  }
  v15 = snprintf(__str, 0x14uLL, "&#%d;", UTF8Char);
  xmlBufferShrink(in, v21);
  xmlBufferGrow(out, 4 * v15);
  v16 = out->use;
  v17 = out->size + ~(_DWORD)v16;
  len = v15;
  v23 = v17;
  v11 = xmlEncOutputChunk((uint64_t)handler, (uint64_t)&out->content[v16], &v23, (uint64_t)__str, &len);
  if ((v11 & 0x80000000) == 0 && len == v15)
  {
    v18 = v23;
    v19 = out->use + v23;
    out->use = v19;
    v10 += v18;
    out->content[v19] = 0;
    goto LABEL_16;
  }
  v27 = 0;
  v25 = 0u;
  v26 = 0u;
  *(_OWORD *)v24 = 0u;
  snprintf(v24, 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *in->content, in->content[1], in->content[2], in->content[3]);
  v28 = 0;
  __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6003, 3, 0, 0, (const xmlChar *)v24, 0, 0, 0, 0, "output conversion failed due to conv error, bytes %s\n", (char)v24);
  if (in->alloc != XML_BUFFER_ALLOC_IMMUTABLE)
    *in->content = 32;
LABEL_24:
  if (v10)
    return v10;
  else
    return v11;
}

int xmlCharEncCloseFunc(xmlCharEncodingHandler *handler)
{
  xmlCharEncodingHandler **v2;
  uint64_t v3;
  uconv_t *uconv_out;
  uconv_t *uconv_in;

  if (!handler)
    return -1;
  if (!handler->name)
    return -1;
  v2 = (xmlCharEncodingHandler **)handlers;
  if (handlers)
  {
    v3 = nbCharEncodingHandler;
    if (nbCharEncodingHandler >= 1)
    {
      while (*v2 != handler)
      {
        ++v2;
        if (!--v3)
          goto LABEL_7;
      }
      return 0;
    }
  }
LABEL_7:
  uconv_out = handler->uconv_out;
  if (uconv_out)
  {
    ucnv_close();
    ucnv_close();
    xmlFree(uconv_out);
    handler->uconv_out = 0;
    uconv_in = handler->uconv_in;
    if (!uconv_in)
      goto LABEL_14;
    goto LABEL_13;
  }
  uconv_in = handler->uconv_in;
  if (uconv_in)
  {
LABEL_13:
    ucnv_close();
    ucnv_close();
    xmlFree(uconv_in);
    handler->uconv_in = 0;
LABEL_14:
    if (handler->name)
      xmlFree(handler->name);
    handler->name = 0;
    xmlFree(handler);
  }
  return 0;
}

uint64_t xmlByteConsumed(xmlParserCtxtPtr ctxt)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  unint64_t v9;
  int v10;
  unint64_t v12;
  BOOL v13;
  uint64_t v14;
  int v15;
  int v16;
  _BYTE v17[32000];
  uint64_t v18;

  v1 = ((uint64_t (*)(xmlParserCtxtPtr))MEMORY[0x1E0C80A78])(ctxt);
  v18 = *MEMORY[0x1E0C80C00];
  if (!v1)
    return -1;
  v2 = *(_QWORD **)(v1 + 56);
  if (!v2)
    return -1;
  v3 = *v2;
  if (!*v2)
    return v2[8] + v2[4] - v2[3];
  v4 = *(_QWORD *)(v3 + 24);
  if (!v4)
    return v2[8] + v2[4] - v2[3];
  v6 = v2[4];
  v5 = v2[5];
  v7 = v5 - v6;
  if (v5 - v6 >= 1)
  {
    bzero(v17, 0x7D00uLL);
    v15 = 32000;
    v16 = v7;
    v8 = 0;
    if ((xmlEncOutputChunk(v4, (uint64_t)v17, &v15, v6, &v16) & 0x80000000) == 0)
    {
LABEL_7:
      v9 = (v15 + v8);
      v3 = *v2;
      goto LABEL_13;
    }
    while (v15 >= 1)
    {
      v8 += v15;
      v6 += v16;
      v10 = *((_DWORD *)v2 + 10) - v6;
      v15 = 32000;
      v16 = v10;
      if ((xmlEncOutputChunk(v4, (uint64_t)v17, &v15, v6, &v16) & 0x80000000) == 0)
        goto LABEL_7;
    }
    return -1;
  }
  v9 = 0;
LABEL_13:
  v12 = *(_QWORD *)(v3 + 56);
  v13 = v12 >= v9;
  v14 = v12 - v9;
  if (v13)
    return v14;
  else
    return -1;
}

uint64_t xmlUconvWrapper(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, _DWORD *a6, int a7)
{
  int v8;
  int v9;
  uint64_t result;
  int v14;
  int v15;
  int v16;

  v15 = a3;
  v16 = a5;
  if (a4 && (v8 = a5, a5) && (v9 = a3, a3) && a6)
  {
    linkedOnOrAfterFall2022OSVersions();
    ucnv_convertEx();
    *a6 = v16 - v8;
    *a4 = v15 - v9;
    v14 = linkedOnOrAfterFall2022OSVersions();
    result = 0;
    if (a7)
    {
      if (v14)
      {
        result = 0;
        *(_QWORD *)(a1 + 2072) = a1 + 16;
        *(_QWORD *)(a1 + 2064) = a1 + 16;
      }
    }
  }
  else
  {
    if (a4)
      *a4 = 0;
    return 0xFFFFFFFFLL;
  }
  return result;
}

xmlEntityPtr xmlGetPredefinedEntity(xmlEntityPtr name)
{
  const xmlChar *v1;
  unsigned int private_low;

  if (name)
  {
    v1 = (const xmlChar *)name;
    private_low = LOBYTE(name->_private);
    if (private_low > 0x6B)
    {
      if (private_low == 113)
      {
        if (xmlStrEqual((const xmlChar *)name, (const xmlChar *)"quot"))
          return (xmlEntityPtr)&xmlEntityQuot;
      }
      else if (private_low == 108 && xmlStrEqual((const xmlChar *)name, (const xmlChar *)"lt"))
      {
        return (xmlEntityPtr)&xmlEntityLt;
      }
    }
    else if (private_low == 97)
    {
      if (xmlStrEqual((const xmlChar *)name, (const xmlChar *)"amp"))
        return (xmlEntityPtr)&xmlEntityAmp;
      if (xmlStrEqual(v1, (const xmlChar *)"apos"))
        return (xmlEntityPtr)&xmlEntityApos;
    }
    else if (private_low == 103 && xmlStrEqual((const xmlChar *)name, (const xmlChar *)"gt"))
    {
      return (xmlEntityPtr)&xmlEntityGt;
    }
    return 0;
  }
  return name;
}

xmlEntityPtr xmlAddDtdEntity(xmlDocPtr doc, const xmlChar *name, int type, const xmlChar *ExternalID, const xmlChar *SystemID, const xmlChar *content)
{
  _xmlDtd *extSubset;
  xmlEntityPtr result;
  _xmlNode *last;
  const char *v9;
  int v10;

  if (!doc)
  {
    v9 = "xmlAddDtdEntity: document is NULL";
    v10 = 521;
LABEL_9:
    __xmlSimpleError(2u, v10, 0, v9, 0);
    return 0;
  }
  extSubset = doc->extSubset;
  if (!extSubset)
  {
    v9 = "xmlAddDtdEntity: document without external subset";
    v10 = 522;
    goto LABEL_9;
  }
  result = (xmlEntityPtr)xmlAddEntity(&doc->extSubset->_private, (xmlChar *)name, type, ExternalID, SystemID, content);
  if (result)
  {
    result->parent = extSubset;
    result->doc = extSubset->doc;
    last = extSubset->last;
    if (last)
    {
      last->next = (_xmlNode *)result;
      result->prev = last;
    }
    else
    {
      extSubset->children = (_xmlNode *)result;
    }
    extSubset->last = (_xmlNode *)result;
  }
  return result;
}

uint64_t xmlAddEntity(_QWORD *a1, xmlChar *name, int a3, const xmlChar *a4, const xmlChar *a5, const xmlChar *a6)
{
  uint64_t v12;
  xmlDict *v13;
  xmlEntityPtr PredefinedEntity;
  unint64_t v15;
  int v16;
  xmlHashTable *Dict;
  unsigned int v19;
  _QWORD *Entity;
  uint64_t v21;
  xmlChar v23[8];

  if (!name)
    return 0;
  v12 = a1[8];
  if (v12)
    v13 = *(xmlDict **)(v12 + 152);
  else
    v13 = 0;
  if ((a3 - 1) >= 3)
  {
    if ((a3 - 4) >= 2)
      return 0;
    Dict = (xmlHashTable *)a1[15];
    if (!Dict)
    {
      Dict = xmlHashCreateDict(0, v13);
      a1[15] = Dict;
      if (!Dict)
        return 0;
    }
    goto LABEL_29;
  }
  PredefinedEntity = xmlGetPredefinedEntity(name);
  if (PredefinedEntity)
  {
    if (a3 == 1 && a6)
    {
      v15 = *PredefinedEntity->content;
      v16 = *a6;
      if (v16 == (_DWORD)v15 && !a6[1] && v15 <= 0x3E && ((1 << v15) & 0x4000008400000000) != 0)
        goto LABEL_27;
      if (v16 == 38 && a6[1] == 35)
      {
        if (a6[2] == 120)
        {
          strcpy((char *)&v23[4], "00;");
          v23[4] = a0123456789abcd[v15 >> 4];
          v23[5] = a0123456789abcd[v15 & 0xF];
          if (!xmlStrcasecmp(a6 + 3, &v23[4]))
            goto LABEL_27;
        }
        else
        {
          strcpy((char *)&v23[2], ";");
          v19 = (205 * v15) >> 11;
          v23[0] = (v19 - 10 * ((unsigned __int16)(26 * v19) >> 8)) | 0x30;
          v23[1] = (v15 - 10 * v19) | 0x30;
          if (xmlStrEqual(a6 + 2, v23))
            goto LABEL_27;
        }
      }
    }
    __xmlSimpleError(2u, 104, 0, "xmlAddEntity: invalid redeclaration of predefined entity", 0);
    return 0;
  }
LABEL_27:
  Dict = (xmlHashTable *)a1[12];
  if (!Dict)
  {
    Dict = xmlHashCreateDict(0, v13);
    a1[12] = Dict;
    if (!Dict)
      return 0;
  }
LABEL_29:
  Entity = xmlCreateEntity(v13, name, a3, a4, a5, a6);
  v21 = (uint64_t)Entity;
  if (Entity)
  {
    Entity[8] = a1[8];
    if (xmlHashAddEntry(Dict, name, Entity))
    {
      xmlFreeEntity(v21);
      return 0;
    }
  }
  return v21;
}

xmlEntityPtr xmlAddDocEntity(xmlDocPtr doc, const xmlChar *name, int type, const xmlChar *ExternalID, const xmlChar *SystemID, const xmlChar *content)
{
  _xmlDtd *intSubset;
  xmlEntityPtr result;
  _xmlNode *last;
  const char *v9;
  int v10;

  if (!doc)
  {
    v9 = "xmlAddDocEntity: document is NULL";
    v10 = 521;
LABEL_9:
    __xmlSimpleError(2u, v10, 0, v9, 0);
    return 0;
  }
  intSubset = doc->intSubset;
  if (!intSubset)
  {
    v9 = "xmlAddDocEntity: document without internal subset";
    v10 = 522;
    goto LABEL_9;
  }
  result = (xmlEntityPtr)xmlAddEntity(&doc->intSubset->_private, (xmlChar *)name, type, ExternalID, SystemID, content);
  if (result)
  {
    result->parent = intSubset;
    result->doc = intSubset->doc;
    last = intSubset->last;
    if (last)
    {
      last->next = (_xmlNode *)result;
      result->prev = last;
    }
    else
    {
      intSubset->children = (_xmlNode *)result;
    }
    intSubset->last = (_xmlNode *)result;
  }
  return result;
}

xmlEntityPtr xmlNewEntity(xmlDocPtr doc, const xmlChar *name, int type, const xmlChar *ExternalID, const xmlChar *SystemID, const xmlChar *content)
{
  _xmlDoc *v6;
  xmlEntityPtr result;

  v6 = doc;
  if (doc)
  {
    if (doc->intSubset)
      return xmlAddDocEntity(doc, name, type, ExternalID, SystemID, content);
    doc = (xmlDocPtr)doc->dict;
  }
  result = (xmlEntityPtr)xmlCreateEntity((xmlDict *)doc, name, type, ExternalID, SystemID, content);
  if (result)
    result->doc = v6;
  return result;
}

_QWORD *xmlCreateEntity(xmlDict *a1, const xmlChar *a2, int a3, const xmlChar *a4, const xmlChar *a5, const xmlChar *a6)
{
  _QWORD *v12;
  _QWORD *v13;
  int v14;
  xmlChar *v15;

  v12 = xmlMalloc(0x88uLL);
  v13 = v12;
  if (!v12)
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"xmlCreateEntity: malloc failed");
    return v13;
  }
  v12[16] = 0;
  *((_OWORD *)v12 + 6) = 0u;
  *((_OWORD *)v12 + 7) = 0u;
  *((_OWORD *)v12 + 4) = 0u;
  *((_OWORD *)v12 + 5) = 0u;
  *((_OWORD *)v12 + 2) = 0u;
  *((_OWORD *)v12 + 3) = 0u;
  *(_OWORD *)v12 = 0u;
  *((_OWORD *)v12 + 1) = 0u;
  *((_DWORD *)v12 + 2) = 17;
  *((_DWORD *)v12 + 33) = 0;
  *((_DWORD *)v12 + 23) = a3;
  if (a1)
  {
    v12[2] = xmlDictLookup(a1, a2, -1);
    v13[12] = xmlStrdup(a4);
  }
  else
  {
    v12[2] = xmlStrdup(a2);
    if (a4)
      v13[12] = xmlStrdup(a4);
    if (!a5)
      goto LABEL_9;
  }
  v13[13] = xmlStrdup(a5);
LABEL_9:
  if (a6)
  {
    v14 = xmlStrlen(a6);
    *((_DWORD *)v13 + 22) = v14;
    v15 = xmlStrndup(a6, v14);
  }
  else
  {
    v15 = 0;
    *((_DWORD *)v13 + 22) = 0;
  }
  v13[15] = 0;
  v13[9] = 0;
  v13[10] = v15;
  *((_DWORD *)v13 + 32) = 0;
  return v13;
}

xmlEntityPtr xmlGetParameterEntity(xmlEntityPtr doc, const xmlChar *name)
{
  xmlEntityPtr v3;
  xmlChar *content;
  xmlHashTable *v5;
  uint64_t v6;

  if (doc)
  {
    v3 = doc;
    content = doc->content;
    if (!content
      || (v5 = (xmlHashTable *)*((_QWORD *)content + 15)) == 0
      || (doc = (xmlEntityPtr)xmlHashLookup(v5, name)) == 0)
    {
      v6 = *(_QWORD *)&v3->length;
      if (v6)
      {
        doc = *(xmlEntityPtr *)(v6 + 120);
        if (doc)
          return (xmlEntityPtr)xmlHashLookup((xmlHashTablePtr)doc, name);
      }
      else
      {
        return 0;
      }
    }
  }
  return doc;
}

xmlEntityPtr xmlGetDtdEntity(xmlDocPtr doc, const xmlChar *name)
{
  _xmlDtd *extSubset;
  xmlHashTable *entities;

  if (doc && (extSubset = doc->extSubset) != 0 && (entities = (xmlHashTable *)extSubset->entities) != 0)
    return (xmlEntityPtr)xmlHashLookup(entities, name);
  else
    return 0;
}

xmlEntityPtr xmlGetDocEntity(const xmlDoc *doc, const xmlChar *name)
{
  _xmlDtd *intSubset;
  xmlHashTable *v5;
  xmlEntityPtr result;
  _xmlDtd *extSubset;
  xmlHashTable *entities;

  if (!doc)
    return xmlGetPredefinedEntity(name);
  intSubset = doc->intSubset;
  if (!intSubset
    || (v5 = (xmlHashTable *)intSubset->entities) == 0
    || (result = (xmlEntityPtr)xmlHashLookup(v5, name)) == 0)
  {
    if (doc->standalone == 1)
      return xmlGetPredefinedEntity(name);
    extSubset = doc->extSubset;
    if (!extSubset)
      return xmlGetPredefinedEntity(name);
    entities = (xmlHashTable *)extSubset->entities;
    if (!entities)
      return xmlGetPredefinedEntity(name);
    result = (xmlEntityPtr)xmlHashLookup(entities, name);
    if (!result)
      return xmlGetPredefinedEntity(name);
  }
  return result;
}

char *xmlEncodeAttributeEntities(uint64_t a1, char *a2)
{
  return xmlEncodeEntitiesInternal(a1, a2, 1);
}

char *xmlEncodeEntitiesInternal(uint64_t a1, char *a2, int a3)
{
  char *v4;
  _BOOL4 v6;
  char *v7;
  char *v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  size_t v12;
  char *v13;
  char *v14;
  const xmlChar *v15;
  char *v16;
  char v17;
  char *v18;
  char v19;
  char v20;
  char *v21;
  int v22;
  int v23;
  int v25;
  char v26;
  char *v27;
  int v28;
  unsigned int v29;
  char v30;
  char *v31;
  char v32;
  unsigned int v33;
  uint64_t v34;
  char v35;
  char *v36;
  int v37;
  __int16 v38;
  int v39;
  char v40;
  char *v41;
  int v42;
  char v43;
  char *v44;
  int v45;
  char __str[16];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v4 = a2;
  if (a1)
    v6 = *(_DWORD *)(a1 + 8) == 13;
  else
    v6 = 0;
  v7 = (char *)xmlMalloc(0x3E8uLL);
  if (!v7)
  {
    __xmlSimpleError(2, 2, 0);
    return 0;
  }
  v8 = v7;
  v9 = *v4;
  if (*v4)
  {
    if (a3)
      v10 = !v6;
    else
      v10 = 1;
    v11 = !v10;
    v12 = 1000;
    v13 = v7;
    while (1)
    {
      if (v8 - v13 + 100 > v12)
      {
        if ((v12 & 0x8000000000000000) != 0 || (v12 *= 2, (v14 = (char *)xmlRealloc(v13, v12)) == 0))
        {
LABEL_111:
          __xmlSimpleError(2, 2, 0);
          xmlFree(v13);
          return 0;
        }
        v8 = &v14[v8 - v13];
        v9 = *v4;
        v13 = v14;
      }
      if (v9 == 38)
      {
        if (v11 && v4[1] == 123 && strchr(v4, 125))
        {
          ++v4;
          v20 = 38;
          do
          {
            *v8++ = v20;
            if (v8 - v13 + 100 > v12)
            {
              if ((v12 & 0x8000000000000000) != 0)
                goto LABEL_111;
              v12 *= 2;
              v21 = (char *)xmlRealloc(v13, v12);
              if (!v21)
                goto LABEL_111;
              v8 = &v21[v8 - v13];
              v13 = v21;
            }
            v22 = *v4++;
            v20 = v22;
          }
          while (v22 != 125);
          *v8++ = v20;
          goto LABEL_79;
        }
        *(_DWORD *)v8 = 1886216486;
        v8[4] = 59;
        v8 += 5;
        goto LABEL_78;
      }
      if (v9 == 62)
        break;
      if (v9 == 60)
      {
        if (v11)
        {
          if (v4[1] == 33 && v4[2] == 45 && v4[3] == 45)
          {
            v15 = xmlStrstr((const xmlChar *)v4, (const xmlChar *)"-->");
            if (v15)
            {
              v16 = (char *)v15;
              if (v4 != (char *)v15)
              {
                do
                {
                  v17 = *v4++;
                  *v8++ = v17;
                  if (v8 - v13 + 100 > v12)
                  {
                    if ((v12 & 0x8000000000000000) != 0)
                      goto LABEL_111;
                    v12 *= 2;
                    v18 = (char *)xmlRealloc(v13, v12);
                    if (!v18)
                      goto LABEL_111;
                    v8 = &v18[v8 - v13];
                    v13 = v18;
                  }
                }
                while (v4 != v16);
                v4 = v16;
              }
              *v8 = *v4;
              v8[1] = v4[1];
              v19 = v4[2];
              v4 += 3;
              v8[2] = v19;
              v8 += 3;
              goto LABEL_79;
            }
          }
        }
        v23 = 997485606;
        goto LABEL_62;
      }
      v25 = v6 && v9 == 13;
      if ((char)v9 <= 31 && v9 - 9 >= 2 && !v25)
      {
        if ((v9 & 0x80) == 0)
        {
          if (v9 <= 0xD && ((1 << v9) & 0x2600) != 0)
          {
            memset(__str, 0, 11);
            snprintf(__str, 0xBuLL, "&#%d;", *v4);
            __str[10] = 0;
            v26 = __str[0];
            if (__str[0])
            {
              v27 = &__str[1];
              do
              {
                *v8++ = v26;
                v28 = *v27++;
                v26 = v28;
              }
              while (v28);
            }
          }
          goto LABEL_78;
        }
        if (a1)
        {
          if (!v6 && !*(_QWORD *)(a1 + 112))
          {
LABEL_67:
            memset(__str, 0, 11);
            v29 = *v4;
            if ((~v29 & 0xC0) == 0)
            {
              v31 = v4 + 1;
              v30 = v4[1];
              if ((v30 & 0xC0) == 0x80 && ((~v29 & 0xE0) != 0 || (v4[2] & 0xC0) == 0x80))
              {
                if (v29 < 0xF0)
                {
                  if ((~v29 & 0xF8) != 0)
                  {
                    v38 = (_WORD)v29 << 6;
                    v39 = v30 & 0x3F;
                    if (v29 > 0xDF)
                    {
                      v33 = v4[2] & 0x3F | ((v38 & 0x3C0 | v39) << 6);
                      v34 = 3;
                    }
                    else
                    {
                      v33 = v38 & 0x7C0 | v39;
                      v34 = 2;
                    }
LABEL_92:
                    if (v33 > 0xFF)
                    {
                      if (v33 >> 11 >= 0x1B && (v33 - 57344) >> 1 >= 0xFFF && v33 - 0x10000 >= 0x100000)
                        goto LABEL_100;
                    }
                    else if (v33 <= 0x1F && (v33 > 0xD || ((1 << v33) & 0x2600) == 0))
                    {
                      goto LABEL_100;
                    }
                    snprintf(__str, 0xBuLL, "&#x%X;", v33);
                    __str[10] = 0;
                    v43 = __str[0];
                    if (__str[0])
                    {
                      v44 = &__str[1];
                      do
                      {
                        *v8++ = v43;
                        v45 = *v44++;
                        v43 = v45;
                      }
                      while (v45);
                    }
                    v31 = &v4[v34];
LABEL_88:
                    v4 = v31;
                    goto LABEL_79;
                  }
                }
                else if ((~v29 & 0xF8) != 0)
                {
                  v32 = v4[3];
                  if ((v32 & 0xC0) == 0x80)
                  {
                    if (v29 <= 0xF7)
                    {
                      v33 = ((v30 & 0x3F | ((v29 & 7) << 6)) << 12) | ((v4[2] & 0x3F) << 6) | v32 & 0x3F;
                      v34 = 4;
                      goto LABEL_92;
                    }
LABEL_100:
                    __xmlSimpleError(2, 9, 0);
                    if (a1)
                      *(_QWORD *)(a1 + 112) = xmlStrdup((const xmlChar *)"ISO-8859-1");
                    snprintf(__str, 0xBuLL, "&#%d;", *v4);
                    __str[10] = 0;
                    v40 = __str[0];
                    if (__str[0])
                    {
                      v41 = &__str[1];
                      do
                      {
                        *v8++ = v40;
                        v42 = *v41++;
                        v40 = v42;
                      }
                      while (v42);
                    }
                    goto LABEL_88;
                  }
                }
              }
            }
            __xmlSimpleError(2, 5032, 0);
            if (a1)
              *(_QWORD *)(a1 + 112) = xmlStrdup((const xmlChar *)"ISO-8859-1");
            snprintf(__str, 0xBuLL, "&#%d;", *v4);
            __str[10] = 0;
            v35 = __str[0];
            if (__str[0])
            {
              v36 = &__str[1];
              do
              {
                *v8++ = v35;
                v37 = *v36++;
                v35 = v37;
              }
              while (v37);
            }
            v31 = v4 + 1;
            goto LABEL_88;
          }
        }
        else if (!v6)
        {
          goto LABEL_67;
        }
      }
      *v8++ = v9;
LABEL_78:
      ++v4;
LABEL_79:
      v9 = *v4;
      if (!*v4)
        goto LABEL_114;
    }
    v23 = 997484326;
LABEL_62:
    *(_DWORD *)v8 = v23;
    v8 += 4;
    goto LABEL_78;
  }
  v13 = v7;
LABEL_114:
  *v8 = 0;
  return v13;
}

xmlChar *__cdecl xmlEncodeEntitiesReentrant(xmlDocPtr doc, const xmlChar *input)
{
  return (xmlChar *)xmlEncodeEntitiesInternal((uint64_t)doc, (char *)input, 0);
}

xmlChar *__cdecl xmlEncodeSpecialChars(const xmlDoc *doc, const xmlChar *input)
{
  const xmlChar *v2;
  xmlChar *v3;
  xmlChar *v4;
  unint64_t v5;
  xmlChar *v6;
  int v7;
  xmlChar *v8;
  int v9;
  int v10;

  if (!input)
    return 0;
  v2 = input;
  v3 = (xmlChar *)xmlMalloc(0x3E8uLL);
  v4 = v3;
  if (v3)
  {
    v5 = 1000;
    v6 = v3;
    while (1)
    {
      v7 = *v2;
      if (!*v2)
      {
        *v6 = 0;
        return v4;
      }
      if (v6 - v4 + 10 > v5)
      {
        if ((v5 & 0x8000000000000000) != 0 || (v8 = (xmlChar *)xmlRealloc(v4, 2 * v5)) == 0)
        {
          __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"xmlEncodeSpecialChars: realloc failed");
          xmlFree(v4);
          return 0;
        }
        v6 = &v8[v6 - v4];
        v7 = *v2;
        v4 = v8;
        v5 *= 2;
      }
      if (v7 <= 37)
      {
        if (v7 == 13)
        {
          v10 = 858858278;
          goto LABEL_22;
        }
        if (v7 == 34)
        {
          *(_DWORD *)v6 = 1869967654;
          *((_WORD *)v6 + 2) = 15220;
          v6 += 6;
          goto LABEL_24;
        }
      }
      else
      {
        switch(v7)
        {
          case '&':
            v10 = 1886216486;
LABEL_22:
            *(_DWORD *)v6 = v10;
            v6[4] = 59;
            v6 += 5;
            goto LABEL_24;
          case '>':
            v9 = 997484326;
            goto LABEL_20;
          case '<':
            v9 = 997485606;
LABEL_20:
            *(_DWORD *)v6 = v9;
            v6 += 4;
            goto LABEL_24;
        }
      }
      *v6++ = v7;
LABEL_24:
      ++v2;
    }
  }
  __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"xmlEncodeSpecialChars: malloc failed");
  return v4;
}

xmlEntitiesTablePtr xmlCreateEntitiesTable(void)
{
  return xmlHashCreate(0);
}

void xmlFreeEntitiesTable(xmlEntitiesTablePtr table)
{
  xmlHashFree(table, (xmlHashDeallocator)xmlFreeEntityWrapper);
}

void xmlFreeEntityWrapper(uint64_t a1)
{
  if (a1)
    xmlFreeEntity(a1);
}

xmlEntitiesTablePtr xmlCopyEntitiesTable(xmlEntitiesTablePtr table)
{
  return xmlHashCopy(table, (xmlHashCopier)xmlCopyEntity);
}

_QWORD *xmlCopyEntity(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  const xmlChar *v4;
  const xmlChar *v5;
  const xmlChar *v6;
  const xmlChar *v7;
  const xmlChar *v8;
  const xmlChar *v9;

  v2 = xmlMalloc(0x88uLL);
  v3 = v2;
  if (v2)
  {
    v2[16] = 0;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_DWORD *)v2 + 2) = 17;
    *((_DWORD *)v2 + 23) = *(_DWORD *)(a1 + 92);
    v4 = *(const xmlChar **)(a1 + 16);
    if (v4)
      v3[2] = xmlStrdup(v4);
    v5 = *(const xmlChar **)(a1 + 96);
    if (v5)
      v3[12] = xmlStrdup(v5);
    v6 = *(const xmlChar **)(a1 + 104);
    if (v6)
      v3[13] = xmlStrdup(v6);
    v7 = *(const xmlChar **)(a1 + 80);
    if (v7)
      v3[10] = xmlStrdup(v7);
    v8 = *(const xmlChar **)(a1 + 72);
    if (v8)
      v3[9] = xmlStrdup(v8);
    v9 = *(const xmlChar **)(a1 + 120);
    if (v9)
      v3[15] = xmlStrdup(v9);
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"xmlCopyEntity:: malloc failed");
  }
  return v3;
}

void xmlDumpEntityDecl(xmlBufferPtr buf, xmlEntityPtr ent)
{
  const char *v4;
  const char *v5;
  const char *v6;
  const xmlChar *SystemID;
  const char *v8;
  xmlChar *orig;

  if (buf && ent)
  {
    switch(ent->etype)
    {
      case XML_INTERNAL_GENERAL_ENTITY:
        v4 = "<!ENTITY ";
        goto LABEL_11;
      case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
        v5 = "<!ENTITY ";
        goto LABEL_14;
      case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
        xmlBufferWriteChar(buf, "<!ENTITY ");
        xmlBufferWriteCHAR(buf, ent->name);
        if (ent->ExternalID)
        {
          xmlBufferWriteChar(buf, " PUBLIC ");
          xmlBufferWriteQuotedString(buf, ent->ExternalID);
          v6 = " ";
        }
        else
        {
          v6 = " SYSTEM ";
        }
        xmlBufferWriteChar(buf, v6);
        xmlBufferWriteQuotedString(buf, ent->SystemID);
        if (ent->content)
        {
          xmlBufferWriteChar(buf, " NDATA ");
          orig = ent->orig;
          if (!orig)
            orig = ent->content;
          xmlBufferWriteCHAR(buf, orig);
        }
        goto LABEL_19;
      case XML_INTERNAL_PARAMETER_ENTITY:
        v4 = "<!ENTITY % ";
LABEL_11:
        xmlBufferWriteChar(buf, v4);
        xmlBufferWriteCHAR(buf, ent->name);
        xmlBufferWriteChar(buf, " ");
        SystemID = ent->orig;
        if (SystemID)
          goto LABEL_18;
        xmlDumpEntityContent((uint64_t)buf, ent->content);
        goto LABEL_19;
      case XML_EXTERNAL_PARAMETER_ENTITY:
        v5 = "<!ENTITY % ";
LABEL_14:
        xmlBufferWriteChar(buf, v5);
        xmlBufferWriteCHAR(buf, ent->name);
        if (ent->ExternalID)
        {
          xmlBufferWriteChar(buf, " PUBLIC ");
          xmlBufferWriteQuotedString(buf, ent->ExternalID);
          v8 = " ";
        }
        else
        {
          v8 = " SYSTEM ";
        }
        xmlBufferWriteChar(buf, v8);
        SystemID = ent->SystemID;
LABEL_18:
        xmlBufferWriteQuotedString(buf, SystemID);
LABEL_19:
        xmlBufferWriteChar(buf, ">\n");
        break;
      default:
        __xmlSimpleError(2u, 535, 0, "xmlDumpEntitiesDecl: internal: unknown type entity type", 0);
        break;
    }
  }
}

void xmlDumpEntityContent(uint64_t a1, xmlChar *str)
{
  const xmlChar *v2;
  uint64_t i;
  int v5;
  const char *v6;

  if (*(_DWORD *)(a1 + 16) != 2)
  {
    v2 = str;
    if (xmlStrchr(str, 0x25u))
    {
      xmlBufferCCat((xmlBufferPtr)a1, "\"");
LABEL_4:
      for (i = 0; ; ++i)
      {
        v5 = v2[i];
        if (!v2[i])
          break;
        if (v5 == 37)
        {
          v6 = "&#x25;";
          if (i)
            goto LABEL_10;
          goto LABEL_11;
        }
        if (v5 == 34)
        {
          v6 = "&quot;";
          if (!i)
            goto LABEL_11;
LABEL_10:
          xmlBufferAdd((xmlBufferPtr)a1, v2, i);
LABEL_11:
          xmlBufferAdd((xmlBufferPtr)a1, (const xmlChar *)v6, 6);
          v2 += i + 1;
          goto LABEL_4;
        }
      }
      if (i)
        xmlBufferAdd((xmlBufferPtr)a1, v2, i);
      xmlBufferCCat((xmlBufferPtr)a1, "\"");
    }
    else
    {
      xmlBufferWriteQuotedString((xmlBufferPtr)a1, v2);
    }
  }
}

void xmlDumpEntitiesTable(xmlBufferPtr buf, xmlEntitiesTablePtr table)
{
  xmlHashScan(table, (xmlHashScanner)xmlDumpEntityDeclScan, buf);
}

void xmlDumpEntityDeclScan(xmlEntityPtr ent, xmlBufferPtr buf)
{
  xmlDumpEntityDecl(buf, ent);
}

void xmlFreeEntity(uint64_t a1)
{
  uint64_t v2;
  xmlDict *v3;
  xmlNode *v4;
  xmlChar *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  v2 = *(_QWORD *)(a1 + 64);
  if (v2)
    v3 = *(xmlDict **)(v2 + 152);
  else
    v3 = 0;
  v4 = *(xmlNode **)(a1 + 24);
  if (v4 && *(_DWORD *)(a1 + 128) == 1 && v4->parent == (_xmlNode *)a1)
    xmlFreeNodeList(v4);
  v5 = *(xmlChar **)(a1 + 16);
  if (v5)
  {
    if (v3)
    {
      if (xmlDictOwns(v3, v5))
        goto LABEL_13;
      v5 = *(xmlChar **)(a1 + 16);
    }
    xmlFree(v5);
  }
LABEL_13:
  v6 = *(void **)(a1 + 96);
  if (v6)
    xmlFree(v6);
  v7 = *(void **)(a1 + 104);
  if (v7)
    xmlFree(v7);
  v8 = *(void **)(a1 + 120);
  if (v8)
    xmlFree(v8);
  v9 = *(void **)(a1 + 80);
  if (v9)
    xmlFree(v9);
  v10 = *(void **)(a1 + 72);
  if (v10)
    xmlFree(v10);
  xmlFree((void *)a1);
}

uint64_t xmlGenericErrorDefaultFunc(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  void *v10;
  void **v11;

  if (!*__xmlGenericErrorContext())
  {
    v10 = (void *)*MEMORY[0x1E0C80C10];
    *__xmlGenericErrorContext() = v10;
  }
  v11 = __xmlGenericErrorContext();
  return vfprintf((FILE *)*v11, a2, &a9);
}

void xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler)
{
  xmlGenericErrorFunc *v3;
  void (*v4)(void *, const char *, ...);

  *__xmlGenericErrorContext() = ctx;
  v3 = __xmlGenericError();
  v4 = (void (*)(void *, const char *, ...))xmlGenericErrorDefaultFunc;
  if (handler)
    v4 = handler;
  *v3 = v4;
}

void xmlParserPrintFileInfo(xmlParserInputPtr input)
{
  const char *filename;
  xmlGenericErrorFunc v2;
  void *v3;
  const char *v4;

  if (input)
  {
    filename = input->filename;
    v2 = *__xmlGenericError();
    v3 = *__xmlGenericErrorContext();
    if (filename)
      v4 = "%s:%d: ";
    else
      v4 = "Entity: line %d: ";
    v2(v3, v4);
  }
}

void xmlParserPrintFileContext(xmlParserInputPtr input)
{
  void (*v2)(uint64_t, const char *, ...);
  void *v3;

  v2 = (void (*)(uint64_t, const char *, ...))*__xmlGenericError();
  v3 = *__xmlGenericErrorContext();
  xmlParserPrintFileContextInternal((uint64_t)input, v2, (uint64_t)v3);
}

uint64_t xmlParserPrintFileContextInternal(uint64_t result, void (*a2)(uint64_t, const char *, ...), uint64_t a3)
{
  unsigned __int8 *v3;
  unint64_t v6;
  unsigned __int8 *v7;
  int v8;
  unsigned int v10;
  int v11;
  uint64_t v13;
  int v15;
  int v16;
  BOOL v17;
  BOOL v18;
  uint64_t v19;
  _WORD *v20;
  _OWORD v21[5];
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v3 = *(unsigned __int8 **)(result + 32);
    if (v3)
    {
      v22 = 0;
      memset(v21, 0, sizeof(v21));
      v6 = *(_QWORD *)(result + 24);
      v7 = v3;
      if ((unint64_t)v3 > v6)
      {
        v7 = v3;
        while (1)
        {
          v8 = *v7;
          if (v8 != 13 && v8 != 10)
            break;
          if ((unint64_t)--v7 <= v6)
          {
            v7 = *(unsigned __int8 **)(result + 24);
            break;
          }
        }
      }
      if ((unint64_t)v7 <= v6)
      {
LABEL_20:
        v11 = *v7;
      }
      else
      {
        v10 = 1;
        while (1)
        {
          v11 = *v7;
          if (v11 == 10 || v11 == 13)
            break;
          --v7;
          if (v10 <= 0x4F)
          {
            ++v10;
            if ((unint64_t)v7 > v6)
              continue;
          }
          goto LABEL_20;
        }
      }
      v13 = 0;
      if (v11 == 13 || v11 == 10)
        ++v7;
      v15 = (_DWORD)v3 - (_DWORD)v7;
      while (1)
      {
        v16 = v7[v13];
        v17 = !v7[v13] || v16 == 10;
        v18 = v17 || v16 == 13;
        if (v18 || v13 > 0x4F)
          break;
        *((_BYTE *)v21 + v13++) = v16;
      }
      *((_BYTE *)v21 + v13) = 0;
      a2(a3, "%s\n", (const char *)v21);
      if (v15)
      {
        v19 = 0;
        v20 = v21;
        do
        {
          if ((_DWORD)v19 == 79)
            break;
          if (*((_BYTE *)v21 + v19) != 9)
          {
            if (!*((_BYTE *)v21 + v19))
              goto LABEL_45;
            *((_BYTE *)v21 + v19) = 32;
          }
          v20 = (_WORD *)((char *)v20 + 1);
          ++v19;
        }
        while (v15 != (_DWORD)v19);
        v20 = (_WORD *)((char *)v21 + v19);
      }
      else
      {
        v20 = v21;
      }
LABEL_45:
      *v20 = 94;
      return ((uint64_t (*)(uint64_t, const char *, ...))a2)(a3, "%s\n", (const char *)v21);
    }
  }
  return result;
}

void xmlParserError(void *ctx, const char *msg, ...)
{
  xmlParserInput *v4;
  int v5;
  BOOL v6;
  int v7;
  xmlParserInput *v8;
  xmlGenericErrorFunc v9;
  void **v10;
  char *v11;
  int v12;
  int v13;
  char *v14;
  int v15;
  BOOL v16;
  int v17;
  xmlGenericErrorFunc v18;
  void **v19;
  xmlGenericErrorFunc v20;
  void **v21;
  xmlParserInput *input;
  va_list va;

  va_start(va, msg);
  if (ctx)
  {
    v4 = (xmlParserInput *)*((_QWORD *)ctx + 7);
    if (v4)
    {
      if (v4->filename || (v5 = *((_DWORD *)ctx + 16), v6 = __OFSUB__(v5, 2), v7 = v5 - 2, (v7 < 0) ^ v6))
      {
        v8 = (xmlParserInput *)*((_QWORD *)ctx + 7);
        v4 = 0;
      }
      else
      {
        v8 = *(xmlParserInput **)(*((_QWORD *)ctx + 9) + 8 * v7);
      }
    }
    else
    {
      v8 = 0;
    }
    input = v8;
    xmlParserPrintFileInfo(v8);
  }
  else
  {
    input = 0;
    v4 = 0;
  }
  v9 = *__xmlGenericError();
  v10 = __xmlGenericErrorContext();
  v9(*v10, "error: ");
  v11 = (char *)xmlMalloc(0x96uLL);
  if (v11)
  {
    v12 = -1;
    v13 = 150;
    do
    {
      v14 = v11;
      if (v13 > 63999)
        break;
      v15 = vsnprintf(v11, v13, msg, va);
      if ((v15 & 0x80000000) == 0 && v15 < v13)
      {
        v16 = v12 == v15;
        v12 = v15;
        if (v16)
          break;
      }
      v17 = v15 >= 0 ? v15 + 1 : 100;
      v13 += v17;
      v11 = (char *)xmlRealloc(v14, v13);
    }
    while (v11);
  }
  else
  {
    v14 = 0;
  }
  v18 = *__xmlGenericError();
  v19 = __xmlGenericErrorContext();
  v18(*v19, "%s", v14);
  if (v14)
    xmlFree(v14);
  if (ctx)
  {
    xmlParserPrintFileContext(input);
    if (v4)
    {
      xmlParserPrintFileInfo(v4);
      v20 = *__xmlGenericError();
      v21 = __xmlGenericErrorContext();
      v20(*v21, "\n");
      xmlParserPrintFileContext(v4);
    }
  }
}

void xmlParserWarning(void *ctx, const char *msg, ...)
{
  xmlParserInput *v4;
  int v5;
  BOOL v6;
  int v7;
  xmlParserInput *v8;
  xmlGenericErrorFunc v9;
  void **v10;
  char *v11;
  int v12;
  int v13;
  char *v14;
  int v15;
  BOOL v16;
  int v17;
  xmlGenericErrorFunc v18;
  void **v19;
  xmlGenericErrorFunc v20;
  void **v21;
  xmlParserInput *input;
  va_list va;

  va_start(va, msg);
  if (ctx)
  {
    v4 = (xmlParserInput *)*((_QWORD *)ctx + 7);
    if (v4)
    {
      if (v4->filename || (v5 = *((_DWORD *)ctx + 16), v6 = __OFSUB__(v5, 2), v7 = v5 - 2, (v7 < 0) ^ v6))
      {
        v8 = (xmlParserInput *)*((_QWORD *)ctx + 7);
        v4 = 0;
      }
      else
      {
        v8 = *(xmlParserInput **)(*((_QWORD *)ctx + 9) + 8 * v7);
      }
    }
    else
    {
      v8 = 0;
    }
    input = v8;
    xmlParserPrintFileInfo(v8);
  }
  else
  {
    input = 0;
    v4 = 0;
  }
  v9 = *__xmlGenericError();
  v10 = __xmlGenericErrorContext();
  v9(*v10, "warning: ");
  v11 = (char *)xmlMalloc(0x96uLL);
  if (v11)
  {
    v12 = -1;
    v13 = 150;
    do
    {
      v14 = v11;
      if (v13 > 63999)
        break;
      v15 = vsnprintf(v11, v13, msg, va);
      if ((v15 & 0x80000000) == 0 && v15 < v13)
      {
        v16 = v12 == v15;
        v12 = v15;
        if (v16)
          break;
      }
      v17 = v15 >= 0 ? v15 + 1 : 100;
      v13 += v17;
      v11 = (char *)xmlRealloc(v14, v13);
    }
    while (v11);
  }
  else
  {
    v14 = 0;
  }
  v18 = *__xmlGenericError();
  v19 = __xmlGenericErrorContext();
  v18(*v19, "%s", v14);
  if (v14)
    xmlFree(v14);
  if (ctx)
  {
    xmlParserPrintFileContext(input);
    if (v4)
    {
      xmlParserPrintFileInfo(v4);
      v20 = *__xmlGenericError();
      v21 = __xmlGenericErrorContext();
      v20(*v21, "\n");
      xmlParserPrintFileContext(v4);
    }
  }
}

void xmlParserValidityError(void *ctx, const char *msg, ...)
{
  int v4;
  xmlParserInput *v5;
  char v6;
  int v7;
  BOOL v8;
  int v9;
  xmlGenericErrorFunc v10;
  void **v11;
  char *v12;
  int v13;
  int v14;
  char *v15;
  int v16;
  BOOL v17;
  int v18;
  xmlGenericErrorFunc v19;
  void **v20;
  va_list va;

  va_start(va, msg);
  v4 = xmlStrlen((const xmlChar *)msg);
  if (v4 < 2 || msg[v4 - 2] == 58)
  {
    v5 = 0;
    v6 = 1;
  }
  else
  {
    if (ctx)
    {
      v5 = (xmlParserInput *)*((_QWORD *)ctx + 7);
      if (!v5->filename)
      {
        v7 = *((_DWORD *)ctx + 16);
        v8 = __OFSUB__(v7, 2);
        v9 = v7 - 2;
        if (v9 < 0 == v8)
          v5 = *(xmlParserInput **)(*((_QWORD *)ctx + 9) + 8 * v9);
      }
      if ((xmlParserValidityError_had_info & 1) == 0)
        xmlParserPrintFileInfo(v5);
    }
    else
    {
      v5 = 0;
    }
    v10 = *__xmlGenericError();
    v11 = __xmlGenericErrorContext();
    v10(*v11, "validity error: ");
    v6 = 0;
  }
  xmlParserValidityError_had_info = v6;
  v12 = (char *)xmlMalloc(0x96uLL);
  if (v12)
  {
    v13 = -1;
    v14 = 150;
    do
    {
      v15 = v12;
      if (v14 > 63999)
        break;
      v16 = vsnprintf(v12, v14, msg, va);
      if ((v16 & 0x80000000) == 0 && v16 < v14)
      {
        v17 = v13 == v16;
        v13 = v16;
        if (v17)
          break;
      }
      v18 = v16 >= 0 ? v16 + 1 : 100;
      v14 += v18;
      v12 = (char *)xmlRealloc(v15, v14);
    }
    while (v12);
  }
  else
  {
    v15 = 0;
  }
  v19 = *__xmlGenericError();
  v20 = __xmlGenericErrorContext();
  v19(*v20, "%s", v15);
  if (v15)
    xmlFree(v15);
  if (ctx)
  {
    if (v5)
      xmlParserPrintFileContext(v5);
  }
}

void xmlParserValidityWarning(void *ctx, const char *msg, ...)
{
  int v4;
  xmlParserInput *v5;
  int v6;
  BOOL v7;
  int v8;
  xmlGenericErrorFunc v9;
  void **v10;
  char *v11;
  int v12;
  int v13;
  char *v14;
  int v15;
  BOOL v16;
  int v17;
  xmlGenericErrorFunc v18;
  void **v19;
  va_list va;

  va_start(va, msg);
  v4 = xmlStrlen((const xmlChar *)msg);
  v5 = 0;
  if (ctx && v4)
  {
    if (msg[v4 - 1] == 58)
    {
      v5 = 0;
    }
    else
    {
      v5 = (xmlParserInput *)*((_QWORD *)ctx + 7);
      if (!v5->filename)
      {
        v6 = *((_DWORD *)ctx + 16);
        v7 = __OFSUB__(v6, 2);
        v8 = v6 - 2;
        if (v8 < 0 == v7)
          v5 = *(xmlParserInput **)(*((_QWORD *)ctx + 9) + 8 * v8);
      }
      xmlParserPrintFileInfo(v5);
    }
  }
  v9 = *__xmlGenericError();
  v10 = __xmlGenericErrorContext();
  v9(*v10, "validity warning: ");
  v11 = (char *)xmlMalloc(0x96uLL);
  if (v11)
  {
    v12 = -1;
    v13 = 150;
    do
    {
      v14 = v11;
      if (v13 > 63999)
        break;
      v15 = vsnprintf(v11, v13, msg, va);
      if ((v15 & 0x80000000) == 0 && v15 < v13)
      {
        v16 = v12 == v15;
        v12 = v15;
        if (v16)
          break;
      }
      v17 = v15 >= 0 ? v15 + 1 : 100;
      v13 += v17;
      v11 = (char *)xmlRealloc(v14, v13);
    }
    while (v11);
  }
  else
  {
    v14 = 0;
  }
  v18 = *__xmlGenericError();
  v19 = __xmlGenericErrorContext();
  v18(*v19, "%s", v14);
  if (v14)
    xmlFree(v14);
  if (ctx)
    xmlParserPrintFileContext(v5);
}

uint64_t xmlReportError(uint64_t result, uint64_t a2, const xmlChar *a3, void (*a4)(void *, const char *, ...), uint64_t a5)
{
  xmlGenericErrorFunc v6;
  uint64_t v9;
  int v10;
  uint64_t v11;
  const char *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  const char *v18;
  int v19;
  BOOL v20;
  int v21;
  unsigned int v22;
  int v23;
  const char *v24;
  const char *v25;
  int v26;
  size_t v27;
  int v28;
  _OWORD __b[10];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v6 = a4;
    v9 = result;
    if (!a4)
    {
      v6 = *__xmlGenericError();
      result = (uint64_t)__xmlGenericErrorContext();
      a5 = *(_QWORD *)result;
    }
    if (*(_DWORD *)(v9 + 4))
    {
      v10 = *(_DWORD *)(v9 + 32);
      v11 = *(_QWORD *)(v9 + 80);
      if (v11 && *(_DWORD *)(v11 + 8) == 1)
        v12 = *(const char **)(v11 + 16);
      else
        v12 = 0;
      v13 = *(_DWORD *)v9;
      v14 = *(int *)(v9 + 16);
      v28 = *(_DWORD *)(v9 + 32);
      if (a2)
      {
        v15 = *(_QWORD *)(a2 + 56);
        if (!v15)
        {
          v16 = 0;
          goto LABEL_28;
        }
        if (*(_QWORD *)(v15 + 8))
        {
          v16 = *(_QWORD *)(a2 + 56);
          v15 = 0;
LABEL_13:
          v17 = "%s:%d: ";
LABEL_14:
          v6((void *)a5, v17);
          goto LABEL_28;
        }
        v19 = *(_DWORD *)(a2 + 64);
        v20 = __OFSUB__(v19, 2);
        v21 = v19 - 2;
        if (v21 < 0 != v20)
        {
          v16 = *(_QWORD *)(a2 + 56);
          v15 = 0;
        }
        else
        {
          v16 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 8 * v21);
          if (!v16)
            goto LABEL_28;
          if (*(_QWORD *)(v16 + 8))
            goto LABEL_13;
        }
        if (v10 && v13 == 1)
        {
          v17 = "Entity: line %d: ";
          goto LABEL_14;
        }
LABEL_28:
        if (v12)
          v6((void *)a5, "element %s: ", v12);
        v22 = v13 - 1;
        if (v13 - 1 <= 0x1D && ((0x3E7FBCFDu >> v22) & 1) != 0)
          v6((void *)a5, off_1E616CD90[v22]);
        if (v14 <= 3)
          v6((void *)a5, off_1E616CE80[v14]);
        if (a3 && ((v23 = xmlStrlen(a3), v23 < 1) || a3[v23 - 1] == 10))
          v24 = "%s";
        else
          v24 = "%s\n";
        result = ((uint64_t (*)(uint64_t, const char *))v6)(a5, v24);
        if (!a2)
          goto LABEL_49;
        result = xmlParserPrintFileContextInternal(v16, (void (*)(uint64_t, const char *, ...))v6, a5);
        if (!v15)
          goto LABEL_49;
        if (*(_QWORD *)(v15 + 8))
        {
          v25 = "%s:%d: \n";
        }
        else
        {
          if (!v28 || v13 != 1)
            goto LABEL_48;
          v25 = "Entity: line %d: \n";
        }
        v6((void *)a5, v25);
LABEL_48:
        result = xmlParserPrintFileContextInternal(v15, (void (*)(uint64_t, const char *, ...))v6, a5);
LABEL_49:
        if (v13 == 12)
        {
          result = *(_QWORD *)(v9 + 40);
          if (result)
          {
            v26 = *(_DWORD *)(v9 + 64);
            if (v26 <= 99)
            {
              result = xmlStrlen((const xmlChar *)result);
              if (v26 < (int)result)
              {
                memset(__b, 0, 150);
                v6((void *)a5, "%s\n", *(const char **)(v9 + 40));
                v27 = *(unsigned int *)(v9 + 64);
                if ((int)v27 < 1)
                  LODWORD(v27) = 0;
                else
                  memset(__b, 32, v27);
                *(_WORD *)((char *)__b + v27) = 94;
                return ((uint64_t (*)(uint64_t, const char *, ...))v6)(a5, "%s\n", (const char *)__b);
              }
            }
          }
        }
        return result;
      }
      if (*(_QWORD *)(v9 + 24))
      {
        v18 = "%s:%d: ";
      }
      else
      {
        if (!v10)
        {
LABEL_27:
          v16 = 0;
          v15 = 0;
          goto LABEL_28;
        }
        v16 = 0;
        if (v13 > 0x13)
        {
          v15 = 0;
          goto LABEL_28;
        }
        v15 = 0;
        if (((1 << v13) & 0xF0012) == 0)
          goto LABEL_28;
        v18 = "Entity: line %d: ";
      }
      v6((void *)a5, v18);
      goto LABEL_27;
    }
  }
  return result;
}

xmlErrorPtr xmlGetLastError(void)
{
  if (__xmlLastError()->code)
    return __xmlLastError();
  else
    return 0;
}

void xmlResetLastError(void)
{
  xmlError *Error;

  if (__xmlLastError()->code)
  {
    Error = __xmlLastError();
    xmlResetError(Error);
  }
}

void xmlCtxtResetLastError(void *ctx)
{
  if (ctx)
  {
    *((_DWORD *)ctx + 34) = 0;
    if (*((_DWORD *)ctx + 151))
      xmlResetError((xmlErrorPtr)((char *)ctx + 600));
  }
}

void xmlCleanupGlobals(void)
{
  if (xmlThrDefMutex)
  {
    xmlFreeMutex((xmlMutexPtr)xmlThrDefMutex);
    xmlThrDefMutex = 0;
  }
  __xmlGlobalInitMutexDestroy();
}

void xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler)
{
  void *v4;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  xmlGenericErrorContextThrDef = (uint64_t)ctx;
  v4 = xmlGenericErrorDefaultFunc;
  if (handler)
    v4 = handler;
  xmlGenericErrorThrDef = (uint64_t)v4;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
}

void xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  xmlStructuredErrorContextThrDef = (uint64_t)ctx;
  xmlStructuredErrorThrDef = (uint64_t)handler;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
}

xmlRegisterNodeFunc xmlRegisterNodeDefault(xmlRegisterNodeFunc func)
{
  void (__cdecl *v1)(xmlNodePtr);

  v1 = (void (__cdecl *)(xmlNodePtr))xmlRegisterNodeDefaultValue;
  __xmlRegisterCallbacks = 1;
  xmlRegisterNodeDefaultValue = (uint64_t)func;
  return v1;
}

xmlRegisterNodeFunc xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func)
{
  void (__cdecl *v2)(xmlNodePtr);

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = (void (__cdecl *)(xmlNodePtr))xmlRegisterNodeDefaultValueThrDef;
  __xmlRegisterCallbacks = 1;
  xmlRegisterNodeDefaultValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlDeregisterNodeFunc xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func)
{
  void (__cdecl *v1)(xmlNodePtr);

  v1 = (void (__cdecl *)(xmlNodePtr))xmlDeregisterNodeDefaultValue;
  __xmlRegisterCallbacks = 1;
  xmlDeregisterNodeDefaultValue = (uint64_t)func;
  return v1;
}

xmlDeregisterNodeFunc xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func)
{
  void (__cdecl *v2)(xmlNodePtr);

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = (void (__cdecl *)(xmlNodePtr))xmlDeregisterNodeDefaultValueThrDef;
  __xmlRegisterCallbacks = 1;
  xmlDeregisterNodeDefaultValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlParserInputBufferCreateFilenameFunc xmlThrDefParserInputBufferCreateFilenameDefault(xmlParserInputBufferCreateFilenameFunc func)
{
  xmlParserInputBufferPtr (__cdecl *v2)(const char *, xmlCharEncoding);

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  if (xmlParserInputBufferCreateFilenameValueThrDef)
    v2 = (xmlParserInputBufferPtr (__cdecl *)(const char *, xmlCharEncoding))xmlParserInputBufferCreateFilenameValueThrDef;
  else
    v2 = __xmlParserInputBufferCreateFilename;
  xmlParserInputBufferCreateFilenameValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlOutputBufferCreateFilenameFunc xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func)
{
  xmlOutputBufferPtr (__cdecl *v2)(const char *, xmlCharEncodingHandlerPtr, int);

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  if (xmlOutputBufferCreateFilenameValueThrDef)
    v2 = (xmlOutputBufferPtr (__cdecl *)(const char *, xmlCharEncodingHandlerPtr, int))xmlOutputBufferCreateFilenameValueThrDef;
  else
    v2 = __xmlOutputBufferCreateFilename;
  xmlOutputBufferCreateFilenameValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlSAXHandlerV1 *__docbDefaultSAXHandler(void)
{
  if (xmlIsMainThread())
    return (xmlSAXHandlerV1 *)docbDefaultSAXHandler;
  else
    return &xmlGetGlobalState()->docbDefaultSAXHandler;
}

int *__oldXMLWDcompatibility(void)
{
  if (xmlIsMainThread())
    return (int *)&oldXMLWDcompatibility;
  else
    return &xmlGetGlobalState()->oldXMLWDcompatibility;
}

xmlBufferAllocationScheme xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v)
{
  xmlBufferAllocationScheme v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlBufferAllocSchemeThrDef;
  xmlBufferAllocSchemeThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefDefaultBufferSize(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlDefaultBufferSizeThrDef;
  xmlDefaultBufferSizeThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefDoValidityCheckingDefaultValue(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlDoValidityCheckingDefaultValueThrDef;
  xmlDoValidityCheckingDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

void **__xmlGenericErrorContext(void)
{
  if (xmlIsMainThread())
    return (void **)&xmlGenericErrorContext;
  else
    return &xmlGetGlobalState()->xmlGenericErrorContext;
}

int xmlThrDefGetWarningsDefaultValue(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlGetWarningsDefaultValueThrDef;
  xmlGetWarningsDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefIndentTreeOutput(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlIndentTreeOutputThrDef;
  xmlIndentTreeOutputThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

const char *__cdecl xmlThrDefTreeIndentString(const char *v)
{
  const char *v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = (const char *)xmlTreeIndentStringThrDef;
  xmlTreeIndentStringThrDef = (uint64_t)v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefKeepBlanksDefaultValue(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlKeepBlanksDefaultValueThrDef;
  xmlKeepBlanksDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefLineNumbersDefaultValue(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlLineNumbersDefaultValueThrDef;
  xmlLineNumbersDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefLoadExtDtdDefaultValue(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlLoadExtDtdDefaultValueThrDef;
  xmlLoadExtDtdDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int *__xmlParserDebugEntities(void)
{
  if (xmlIsMainThread())
    return (int *)&xmlParserDebugEntities;
  else
    return &xmlGetGlobalState()->xmlParserDebugEntities;
}

int xmlThrDefParserDebugEntities(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlParserDebugEntitiesThrDef;
  xmlParserDebugEntitiesThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

const char **__xmlParserVersion(void)
{
  if (xmlIsMainThread())
    return (const char **)&xmlParserVersion;
  else
    return (const char **)xmlGetGlobalState();
}

int xmlThrDefPedanticParserDefaultValue(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlPedanticParserDefaultValueThrDef;
  xmlPedanticParserDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefSaveNoEmptyTags(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlSaveNoEmptyTagsThrDef;
  xmlSaveNoEmptyTagsThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefSubstituteEntitiesDefaultValue(int v)
{
  int v2;

  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  v2 = xmlSubstituteEntitiesDefaultValueThrDef;
  xmlSubstituteEntitiesDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlRegisterNodeFunc *__xmlRegisterNodeDefaultValue(void)
{
  if (xmlIsMainThread())
    return (xmlRegisterNodeFunc *)&xmlRegisterNodeDefaultValue;
  else
    return &xmlGetGlobalState()->xmlRegisterNodeDefaultValue;
}

xmlDeregisterNodeFunc *__xmlDeregisterNodeDefaultValue(void)
{
  if (xmlIsMainThread())
    return (xmlDeregisterNodeFunc *)&xmlDeregisterNodeDefaultValue;
  else
    return &xmlGetGlobalState()->xmlDeregisterNodeDefaultValue;
}

xmlParserInputBufferCreateFilenameFunc *__xmlParserInputBufferCreateFilenameValue(void)
{
  if (xmlIsMainThread())
    return (xmlParserInputBufferCreateFilenameFunc *)&xmlParserInputBufferCreateFilenameValue;
  else
    return &xmlGetGlobalState()->xmlParserInputBufferCreateFilenameValue;
}

xmlOutputBufferCreateFilenameFunc *__xmlOutputBufferCreateFilenameValue(void)
{
  if (xmlIsMainThread())
    return (xmlOutputBufferCreateFilenameFunc *)&xmlOutputBufferCreateFilenameValue;
  else
    return &xmlGetGlobalState()->xmlOutputBufferCreateFilenameValue;
}

xmlHashTablePtr xmlHashCreate(int size)
{
  _DWORD *v2;
  _DWORD *v3;
  unsigned int v4;
  size_t v5;
  void *v6;

  v2 = xmlMalloc(0x20uLL);
  v3 = v2;
  if (v2)
  {
    if (size >= 1)
      v4 = size;
    else
      v4 = 256;
    *((_QWORD *)v2 + 2) = 0;
    v2[2] = v4;
    v2[3] = 0;
    v5 = 48 * v4;
    v6 = xmlMalloc(v5);
    *(_QWORD *)v3 = v6;
    if (v6)
    {
      bzero(v6, v5);
      v3[6] = __xmlRandom();
    }
    else
    {
      xmlFree(v3);
      return 0;
    }
  }
  return (xmlHashTablePtr)v3;
}

xmlHashTablePtr xmlHashCreateDict(int size, xmlDictPtr dict)
{
  xmlHashTablePtr v3;
  xmlHashTable *v4;

  v3 = xmlHashCreate(size);
  v4 = v3;
  if (v3)
  {
    *((_QWORD *)v3 + 2) = dict;
    xmlDictReference(dict);
  }
  return v4;
}

void xmlHashFree(xmlHashTablePtr table, xmlHashDeallocator f)
{
  char *v3;
  int v4;
  int v5;
  uint64_t v8;
  char *v9;
  BOOL v10;
  char v11;
  char *v12;
  char *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  xmlDict *v18;

  if (table)
  {
    v3 = *(char **)table;
    if (v3)
    {
      v4 = *((_DWORD *)table + 2);
      v5 = *((_DWORD *)table + 3);
      if (v4 >= 1 && v5 >= 1)
      {
        v8 = 0;
        do
        {
          v9 = *(char **)table;
          if (*(_DWORD *)(*(_QWORD *)table + 48 * v8 + 40))
            v10 = v9 == 0;
          else
            v10 = 1;
          if (!v10)
          {
            v11 = 0;
            v12 = &v9[48 * v8];
            do
            {
              v13 = *(char **)v12;
              if (f)
              {
                v14 = *((_QWORD *)v12 + 4);
                if (v14)
                  ((void (*)(uint64_t, _QWORD))f)(v14, *((_QWORD *)v12 + 1));
              }
              if (!*((_QWORD *)table + 2))
              {
                v15 = (void *)*((_QWORD *)v12 + 1);
                if (v15)
                  xmlFree(v15);
                v16 = (void *)*((_QWORD *)v12 + 2);
                if (v16)
                  xmlFree(v16);
                v17 = (void *)*((_QWORD *)v12 + 3);
                if (v17)
                  xmlFree(v17);
              }
              *((_QWORD *)v12 + 4) = 0;
              if ((v11 & 1) != 0)
                xmlFree(v12);
              --v5;
              v11 = 1;
              v12 = v13;
            }
            while (v13);
            v4 = *((_DWORD *)table + 2);
          }
          ++v8;
        }
        while (v8 < v4 && v5 > 0);
        v3 = *(char **)table;
      }
      xmlFree(v3);
    }
    v18 = (xmlDict *)*((_QWORD *)table + 2);
    if (v18)
      xmlDictFree(v18);
    xmlFree(table);
  }
}

void xmlHashDefaultDeallocator(void *entry, const xmlChar *name)
{
  xmlFree(entry);
}

int xmlHashAddEntry(xmlHashTablePtr table, const xmlChar *name, void *userdata)
{
  return xmlHashAddEntry3(table, name, 0, 0, userdata);
}

int xmlHashAddEntry3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, void *userdata)
{
  int v5;
  xmlChar *v6;
  xmlDict *v11;
  void *v12;
  int v13;
  _QWORD *v14;
  unint64_t v15;
  xmlChar **v16;
  _QWORD *v17;
  uint64_t v18;
  char *v19;
  unsigned int v20;
  void *v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  _OWORD *v25;
  __int128 v26;
  __int128 v27;
  _BYTE **v28;
  _BYTE *v29;
  unint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;

  v5 = -1;
  if (table)
  {
    v6 = (xmlChar *)name;
    if (name)
    {
      if (*((_DWORD *)table + 3) != 0x7FFFFFFF)
      {
        v11 = (xmlDict *)*((_QWORD *)table + 2);
        if (!v11
          || (xmlDictOwns(v11, name) || (v6 = (xmlChar *)xmlDictLookup(*((xmlDictPtr *)table + 2), v6, -1)) != 0)
          && (!name2
           || xmlDictOwns(*((xmlDictPtr *)table + 2), name2)
           || (name2 = xmlDictLookup(*((xmlDictPtr *)table + 2), name2, -1)) != 0)
          && (!name3
           || xmlDictOwns(*((xmlDictPtr *)table + 2), name3)
           || (name3 = xmlDictLookup(*((xmlDictPtr *)table + 2), name3, -1)) != 0))
        {
          v12 = (void *)(*(_QWORD *)table + 48 * xmlHashComputeKey((uint64_t)table, v6, name2, name3));
          v13 = *((_DWORD *)v12 + 10);
          if (v13)
          {
            v14 = *(_QWORD **)v12;
            v15 = 0;
            if (*((_QWORD *)table + 2))
            {
              if (v14)
              {
                do
                {
                  v16 = (xmlChar **)v12;
                  v12 = v14;
                  if (v16[1] == v6 && v16[2] == name2 && v16[3] == name3)
                    return -1;
                  ++v15;
                  v14 = (_QWORD *)*v14;
                }
                while (*(_QWORD *)v12);
              }
              if (*((xmlChar **)v12 + 1) == v6
                && *((const xmlChar **)v12 + 2) == name2
                && *((const xmlChar **)v12 + 3) == name3)
              {
                return -1;
              }
            }
            else
            {
              if (v14)
              {
                while (!xmlStrEqual(*((const xmlChar **)v12 + 1), v6)
                     || !xmlStrEqual(*((const xmlChar **)v12 + 2), name2)
                     || !xmlStrEqual(*((const xmlChar **)v12 + 3), name3))
                {
                  ++v15;
                  v12 = *(void **)v12;
                  if (!*(_QWORD *)v12)
                    goto LABEL_30;
                }
                return -1;
              }
LABEL_30:
              if (xmlStrEqual(*((const xmlChar **)v12 + 1), v6)
                && xmlStrEqual(*((const xmlChar **)v12 + 2), name2)
                && xmlStrEqual(*((const xmlChar **)v12 + 3), name3))
              {
                return -1;
              }
            }
            v17 = v12;
            v12 = xmlMalloc(0x30uLL);
            if (!v12)
              return -1;
          }
          else
          {
            v17 = 0;
            v15 = 0;
          }
          if (*((_QWORD *)table + 2))
          {
            *((_QWORD *)v12 + 1) = v6;
            *((_QWORD *)v12 + 2) = name2;
          }
          else
          {
            *((_QWORD *)v12 + 1) = xmlStrdup(v6);
            *((_QWORD *)v12 + 2) = xmlStrdup(name2);
            name3 = xmlStrdup(name3);
          }
          *((_QWORD *)v12 + 3) = name3;
          *((_QWORD *)v12 + 4) = userdata;
          *(_QWORD *)v12 = 0;
          *((_DWORD *)v12 + 10) = 1;
          if (v13)
            *v17 = v12;
          ++*((_DWORD *)table + 3);
          if (v15 >= 9)
          {
            v18 = *((unsigned int *)table + 2);
            if ((8 * v18 - 16385) >= 0xFFFFC007)
            {
              v19 = *(char **)table;
              if (*(_QWORD *)table)
              {
                v20 = 8 * v18;
                v21 = xmlMalloc(48 * (8 * v18));
                *(_QWORD *)table = v21;
                if (!v21)
                {
                  v5 = 0;
                  *(_QWORD *)table = v19;
                  return v5;
                }
                bzero(v21, 48 * v20);
                *((_DWORD *)table + 2) = v20;
                if ((int)v18 >= 1)
                {
                  v22 = v19 + 24;
                  v23 = v18;
                  do
                  {
                    if (*((_DWORD *)v22 + 4))
                    {
                      v24 = xmlHashComputeKey((uint64_t)table, *((_BYTE **)v22 - 2), *((_BYTE **)v22 - 1), *(_BYTE **)v22);
                      v25 = (_OWORD *)(*(_QWORD *)table + 48 * v24);
                      v26 = *(_OWORD *)(v22 - 24);
                      v27 = *(_OWORD *)(v22 + 8);
                      v25[1] = *(_OWORD *)(v22 - 8);
                      v25[2] = v27;
                      *v25 = v26;
                      *(_QWORD *)(*(_QWORD *)table + 48 * v24) = 0;
                    }
                    v22 += 48;
                    --v23;
                  }
                  while (v23);
                  do
                  {
                    v28 = *(_BYTE ***)&v19[48 * v23];
                    if (v28)
                    {
                      do
                      {
                        v29 = *v28;
                        v30 = xmlHashComputeKey((uint64_t)table, v28[1], v28[2], v28[3]);
                        v31 = *(_QWORD *)table + 48 * v30;
                        if (*(_DWORD *)(v31 + 40))
                        {
                          *v28 = *(_BYTE **)v31;
                          *(_QWORD *)v31 = v28;
                        }
                        else
                        {
                          v32 = *(_OWORD *)v28;
                          v33 = *((_OWORD *)v28 + 2);
                          *(_OWORD *)(v31 + 16) = *((_OWORD *)v28 + 1);
                          *(_OWORD *)(v31 + 32) = v33;
                          *(_OWORD *)v31 = v32;
                          *(_QWORD *)(*(_QWORD *)table + 48 * v30) = 0;
                          xmlFree(v28);
                        }
                        v28 = (_BYTE **)v29;
                      }
                      while (v29);
                    }
                    ++v23;
                  }
                  while (v23 != v18);
                }
                xmlFree(v19);
              }
            }
          }
          return 0;
        }
      }
    }
  }
  return v5;
}

int xmlHashAddEntry2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, void *userdata)
{
  return xmlHashAddEntry3(table, name, name2, 0, userdata);
}

int xmlHashUpdateEntry(xmlHashTablePtr table, const xmlChar *name, void *userdata, xmlHashDeallocator f)
{
  return xmlHashUpdateEntry3(table, name, 0, 0, userdata, f);
}

int xmlHashUpdateEntry3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, void *userdata, xmlHashDeallocator f)
{
  int v6;
  xmlChar *v7;
  xmlDict *v13;
  void *v14;
  _QWORD *v15;
  xmlChar **v16;
  uint64_t v17;
  xmlChar *v18;
  _QWORD *v19;

  v6 = -1;
  if (!table)
    return v6;
  v7 = (xmlChar *)name;
  if (!name || *((_DWORD *)table + 3) == 0x7FFFFFFF)
    return v6;
  v13 = (xmlDict *)*((_QWORD *)table + 2);
  if (v13)
  {
    if (!xmlDictOwns(v13, name))
    {
      v7 = (xmlChar *)xmlDictLookup(*((xmlDictPtr *)table + 2), v7, -1);
      if (!v7)
        return v6;
    }
    if (name2)
    {
      if (!xmlDictOwns(*((xmlDictPtr *)table + 2), name2))
      {
        name2 = xmlDictLookup(*((xmlDictPtr *)table + 2), name2, -1);
        if (!name2)
          return v6;
      }
    }
    if (name3)
    {
      if (!xmlDictOwns(*((xmlDictPtr *)table + 2), name3))
      {
        name3 = xmlDictLookup(*((xmlDictPtr *)table + 2), name3, -1);
        if (!name3)
          return v6;
      }
    }
  }
  v14 = (void *)(*(_QWORD *)table + 48 * xmlHashComputeKey((uint64_t)table, v7, name2, name3));
  v6 = *((_DWORD *)v14 + 10);
  if (!v6)
  {
    v19 = 0;
LABEL_39:
    if (*((_QWORD *)table + 2))
    {
      *((_QWORD *)v14 + 1) = v7;
      *((_QWORD *)v14 + 2) = name2;
    }
    else
    {
      *((_QWORD *)v14 + 1) = xmlStrdup(v7);
      *((_QWORD *)v14 + 2) = xmlStrdup(name2);
      name3 = xmlStrdup(name3);
    }
    *((_QWORD *)v14 + 3) = name3;
    *((_QWORD *)v14 + 4) = userdata;
    *(_QWORD *)v14 = 0;
    *((_DWORD *)v14 + 10) = 1;
    ++*((_DWORD *)table + 3);
    if (v6)
    {
      v6 = 0;
      *v19 = v14;
    }
    return v6;
  }
  v15 = *(_QWORD **)v14;
  if (!*((_QWORD *)table + 2))
  {
    if (v15)
    {
      while (!xmlStrEqual(*((const xmlChar **)v14 + 1), v7)
           || !xmlStrEqual(*((const xmlChar **)v14 + 2), name2)
           || !xmlStrEqual(*((const xmlChar **)v14 + 3), name3))
      {
        v14 = *(void **)v14;
        if (!*(_QWORD *)v14)
          goto LABEL_31;
      }
    }
    else
    {
LABEL_31:
      if (!xmlStrEqual(*((const xmlChar **)v14 + 1), v7)
        || !xmlStrEqual(*((const xmlChar **)v14 + 2), name2)
        || !xmlStrEqual(*((const xmlChar **)v14 + 3), name3))
      {
LABEL_38:
        v19 = v14;
        v14 = xmlMalloc(0x30uLL);
        if (!v14)
          return -1;
        goto LABEL_39;
      }
    }
    if (f)
    {
      v17 = *((_QWORD *)v14 + 4);
      v18 = (xmlChar *)*((_QWORD *)v14 + 1);
      goto LABEL_36;
    }
LABEL_37:
    v6 = 0;
    *((_QWORD *)v14 + 4) = userdata;
    return v6;
  }
  if (!v15)
  {
LABEL_20:
    if (*((xmlChar **)v14 + 1) == v7 && *((const xmlChar **)v14 + 2) == name2 && *((const xmlChar **)v14 + 3) == name3)
    {
      if (f)
      {
        v17 = *((_QWORD *)v14 + 4);
        v18 = v7;
LABEL_36:
        ((void (*)(uint64_t, xmlChar *))f)(v17, v18);
        goto LABEL_37;
      }
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  while (1)
  {
    v16 = (xmlChar **)v14;
    v14 = v15;
    if (v16[1] == v7 && v16[2] == name2 && v16[3] == name3)
      break;
    v15 = (_QWORD *)*v15;
    if (!*(_QWORD *)v14)
      goto LABEL_20;
  }
  if (f)
    ((void (*)(xmlChar *, xmlChar *))f)(v16[4], v7);
  v6 = 0;
  v16[4] = (xmlChar *)userdata;
  return v6;
}

int xmlHashUpdateEntry2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, void *userdata, xmlHashDeallocator f)
{
  return xmlHashUpdateEntry3(table, name, name2, 0, userdata, f);
}

void *__cdecl xmlHashLookup(xmlHashTablePtr table, const xmlChar *name)
{
  return xmlHashLookup3(table, name, 0, 0);
}

void *__cdecl xmlHashLookup3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3)
{
  void *result;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = 0;
  if (table && name)
  {
    v9 = xmlHashComputeKey((uint64_t)table, name, name2, name3);
    v10 = *(_QWORD *)table + 48 * v9;
    if (*(_DWORD *)(v10 + 40))
    {
      if (*((_QWORD *)table + 2))
      {
        v11 = *(_QWORD *)table + 48 * v9;
        while (*(const xmlChar **)(v11 + 8) != name
             || *(const xmlChar **)(v11 + 16) != name2
             || *(const xmlChar **)(v11 + 24) != name3)
        {
          v11 = *(_QWORD *)v11;
          if (!v11)
          {
            if (*(_QWORD *)table)
              goto LABEL_11;
            return 0;
          }
        }
      }
      else
      {
LABEL_11:
        while (!xmlStrEqual(*(const xmlChar **)(v10 + 8), name)
             || !xmlStrEqual(*(const xmlChar **)(v10 + 16), name2)
             || !xmlStrEqual(*(const xmlChar **)(v10 + 24), name3))
        {
          v10 = *(_QWORD *)v10;
          if (!v10)
            return 0;
        }
        v11 = v10;
      }
      return *(void **)(v11 + 32);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *__cdecl xmlHashLookup2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2)
{
  return xmlHashLookup3(table, name, name2, 0);
}

void *__cdecl xmlHashQLookup(xmlHashTablePtr table, const xmlChar *name, const xmlChar *prefix)
{
  return xmlHashQLookup3(table, name, prefix, 0, 0, 0, 0);
}

void *__cdecl xmlHashQLookup3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *prefix, const xmlChar *name2, const xmlChar *prefix2, const xmlChar *name3, const xmlChar *prefix3)
{
  void *v7;
  const xmlChar *v14;
  unint64_t v15;
  unsigned int v16;
  const xmlChar *v17;
  unsigned int v18;
  unsigned int v19;
  const xmlChar *v20;
  unsigned int v21;
  unint64_t v22;
  unsigned int v23;
  const xmlChar *v24;
  unsigned int v25;
  unsigned int v26;
  const xmlChar *v27;
  unsigned int v28;
  unint64_t v29;
  unsigned int v30;
  const xmlChar *v31;
  unsigned int v32;
  unsigned int v33;
  const xmlChar *v34;
  unsigned int v35;
  unint64_t v36;
  uint64_t v37;
  BOOL v38;
  uint64_t **v39;

  v7 = 0;
  if (table && prefix)
  {
    if (name)
      v14 = name;
    else
      v14 = prefix;
    v15 = *((int *)table + 6) + 30 * *v14;
    if (name)
    {
      v16 = *name;
      if (*name)
      {
        v17 = name + 1;
        do
        {
          v15 ^= (v15 >> 3) + v16 + 32 * v15;
          v18 = *v17++;
          v16 = v18;
        }
        while (v18);
      }
      v15 ^= (v15 >> 3) + 32 * v15 + 58;
    }
    v19 = *prefix;
    if (*prefix)
    {
      v20 = prefix + 1;
      do
      {
        v15 ^= (v15 >> 3) + v19 + 32 * v15;
        v21 = *v20++;
        v19 = v21;
      }
      while (v21);
    }
    v22 = (32 * v15 + (v15 >> 3)) ^ v15;
    if (name2)
    {
      v23 = *name2;
      if (*name2)
      {
        v24 = name2 + 1;
        do
        {
          v22 ^= (v22 >> 3) + v23 + 32 * v22;
          v25 = *v24++;
          v23 = v25;
        }
        while (v25);
      }
      v22 ^= (v22 >> 3) + 32 * v22 + 58;
    }
    if (prefix2)
    {
      v26 = *prefix2;
      if (*prefix2)
      {
        v27 = prefix2 + 1;
        do
        {
          v22 ^= (v22 >> 3) + v26 + 32 * v22;
          v28 = *v27++;
          v26 = v28;
        }
        while (v28);
      }
    }
    v29 = (32 * v22 + (v22 >> 3)) ^ v22;
    if (name3)
    {
      v30 = *name3;
      if (*name3)
      {
        v31 = name3 + 1;
        do
        {
          v29 ^= (v29 >> 3) + v30 + 32 * v29;
          v32 = *v31++;
          v30 = v32;
        }
        while (v32);
      }
      v29 ^= (v29 >> 3) + 32 * v29 + 58;
    }
    if (prefix3)
    {
      v33 = *prefix3;
      if (*prefix3)
      {
        v34 = prefix3 + 1;
        do
        {
          v29 ^= (v29 >> 3) + v33 + 32 * v29;
          v35 = *v34++;
          v33 = v35;
        }
        while (v35);
      }
    }
    v36 = v29 % *((int *)table + 2);
    v37 = *(_QWORD *)table;
    if (*(_DWORD *)(*(_QWORD *)table + 48 * v36 + 40))
      v38 = v37 == 0;
    else
      v38 = 1;
    if (v38)
    {
      return 0;
    }
    else
    {
      v39 = (uint64_t **)(v37 + 48 * v36);
      while (!xmlStrQEqual(name, prefix, (const xmlChar *)v39[1])
           || !xmlStrQEqual(name2, prefix2, (const xmlChar *)v39[2])
           || !xmlStrQEqual(name3, prefix3, (const xmlChar *)v39[3]))
      {
        v39 = (uint64_t **)*v39;
        if (!v39)
          return 0;
      }
      return v39[4];
    }
  }
  return v7;
}

void *__cdecl xmlHashQLookup2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *prefix, const xmlChar *name2, const xmlChar *prefix2)
{
  return xmlHashQLookup3(table, name, prefix, name2, prefix2, 0, 0);
}

unint64_t xmlHashComputeKey(uint64_t a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  unint64_t v4;
  unsigned int v5;
  unsigned __int8 *v6;
  unsigned int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned __int8 *v10;
  unsigned int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned __int8 *v14;
  unsigned int v15;

  v4 = *(int *)(a1 + 24);
  if (a2)
  {
    v5 = *a2;
    v4 += 30 * *a2;
    if (*a2)
    {
      v6 = a2 + 1;
      do
      {
        v4 ^= (v4 >> 3) + v5 + 32 * v4;
        v7 = *v6++;
        v5 = v7;
      }
      while (v7);
    }
  }
  v8 = (32 * v4 + (v4 >> 3)) ^ v4;
  if (a3)
  {
    v9 = *a3;
    if (*a3)
    {
      v10 = a3 + 1;
      do
      {
        v8 ^= 32 * v8 + (v8 >> 3) + v9;
        v11 = *v10++;
        v9 = v11;
      }
      while (v11);
    }
  }
  v12 = (32 * v8 + (v8 >> 3)) ^ v8;
  if (a4)
  {
    v13 = *a4;
    if (*a4)
    {
      v14 = a4 + 1;
      do
      {
        v12 ^= 32 * v12 + (v12 >> 3) + v13;
        v15 = *v14++;
        v13 = v15;
      }
      while (v15);
    }
  }
  return v12 % *(int *)(a1 + 8);
}

void xmlHashScan(xmlHashTablePtr table, xmlHashScanner f, void *data)
{
  _QWORD v3[2];

  v3[0] = f;
  v3[1] = data;
  xmlHashScanFull(table, (xmlHashScannerFull)stubHashScannerFull, v3);
}

void xmlHashScanFull(xmlHashTablePtr table, xmlHashScannerFull f, void *data)
{
  int v5;
  uint64_t i;
  uint64_t v8;
  BOOL v9;
  _QWORD *v10;
  int v11;
  int v12;
  _QWORD *v13;
  uint64_t v14;

  if (table)
  {
    if (f)
    {
      if (*(_QWORD *)table)
      {
        v5 = *((_DWORD *)table + 2);
        if (v5 >= 1)
        {
          for (i = 0; i < v5; ++i)
          {
            v8 = *(_QWORD *)table;
            if (*(_DWORD *)(*(_QWORD *)table + 48 * i + 40))
              v9 = v8 == 0;
            else
              v9 = 1;
            if (!v9)
            {
              v10 = (_QWORD *)(v8 + 48 * i);
              v11 = *((_DWORD *)table + 3);
              do
              {
                v12 = v11;
                v13 = (_QWORD *)*v10;
                v14 = v10[4];
                if (v14)
                {
                  ((void (*)(uint64_t, void *, _QWORD, _QWORD, _QWORD))f)(v14, data, v10[1], v10[2], v10[3]);
                  v11 = *((_DWORD *)table + 3);
                }
                if (v12 != v11 && v10 == (_QWORD *)(*(_QWORD *)table + 48 * i))
                {
                  if ((_QWORD *)*v10 == v13)
                  {
                    v13 = v10;
                    if (!*(_DWORD *)(*(_QWORD *)table + 48 * i + 40))
                      break;
                  }
                  else
                  {
                    v13 = v10;
                  }
                }
                v10 = v13;
              }
              while (v13);
              v5 = *((_DWORD *)table + 2);
            }
          }
        }
      }
    }
  }
}

uint64_t stubHashScannerFull(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))a2)(a1, *(_QWORD *)(a2 + 8));
}

void xmlHashScan3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, xmlHashScanner f, void *data)
{
  _QWORD v6[2];

  v6[0] = f;
  v6[1] = data;
  xmlHashScanFull3(table, name, name2, name3, (xmlHashScannerFull)stubHashScannerFull, v6);
}

void xmlHashScanFull3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, xmlHashScannerFull f, void *data)
{
  int v8;
  uint64_t i;
  uint64_t v14;
  BOOL v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;

  if (table)
  {
    if (f)
    {
      if (*(_QWORD *)table)
      {
        v8 = *((_DWORD *)table + 2);
        if (v8 >= 1)
        {
          for (i = 0; i < v8; ++i)
          {
            v14 = *(_QWORD *)table;
            if (*(_DWORD *)(*(_QWORD *)table + 48 * i + 40))
              v15 = v14 == 0;
            else
              v15 = 1;
            if (!v15)
            {
              v16 = (_QWORD *)(v14 + 48 * i);
              do
              {
                v17 = v16;
                v16 = (_QWORD *)*v16;
                if ((!name || xmlStrEqual(name, (const xmlChar *)v17[1]))
                  && (!name2 || xmlStrEqual(name2, (const xmlChar *)v17[2]))
                  && (!name3 || xmlStrEqual(name3, (const xmlChar *)v17[3])))
                {
                  v18 = v17[4];
                  if (v18)
                    ((void (*)(uint64_t, void *, _QWORD, _QWORD, _QWORD))f)(v18, data, v17[1], v17[2], v17[3]);
                }
              }
              while (v16);
              v8 = *((_DWORD *)table + 2);
            }
          }
        }
      }
    }
  }
}

xmlHashTablePtr xmlHashCopy(xmlHashTablePtr table, xmlHashCopier f)
{
  xmlHashTablePtr v2;
  int v5;
  uint64_t i;
  uint64_t v7;
  BOOL v8;
  _QWORD *v9;
  const xmlChar *v10;
  _QWORD *v11;
  const xmlChar *v12;
  const xmlChar *v13;
  void *v14;

  v2 = 0;
  if (table)
  {
    if (f)
    {
      v2 = xmlHashCreate(*((_DWORD *)table + 2));
      if (v2)
      {
        if (*(_QWORD *)table)
        {
          v5 = *((_DWORD *)table + 2);
          if (v5 >= 1)
          {
            for (i = 0; i < v5; ++i)
            {
              v7 = *(_QWORD *)table;
              if (*(_DWORD *)(*(_QWORD *)table + 48 * i + 40))
                v8 = v7 == 0;
              else
                v8 = 1;
              if (!v8)
              {
                v9 = (_QWORD *)(v7 + 48 * i);
                do
                {
                  v11 = (_QWORD *)*v9;
                  v10 = (const xmlChar *)v9[1];
                  v12 = (const xmlChar *)v9[2];
                  v13 = (const xmlChar *)v9[3];
                  v14 = (void *)((uint64_t (*)(_QWORD, const xmlChar *))f)(v9[4], v10);
                  xmlHashAddEntry3(v2, v10, v12, v13, v14);
                  v9 = v11;
                }
                while (v11);
                v5 = *((_DWORD *)table + 2);
              }
            }
          }
        }
        *((_DWORD *)v2 + 3) = *((_DWORD *)table + 3);
      }
    }
  }
  return v2;
}

int xmlHashSize(xmlHashTablePtr table)
{
  if (table)
    return *((_DWORD *)table + 3);
  else
    return -1;
}

int xmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name, xmlHashDeallocator f)
{
  return xmlHashRemoveEntry3(table, name, 0, 0, f);
}

int xmlHashRemoveEntry3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, xmlHashDeallocator f)
{
  int result;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  __int128 **v15;
  __int128 *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  void *v20;
  __int128 *v21;
  _OWORD *v22;
  __int128 v23;
  __int128 v24;

  result = -1;
  if (table && name)
  {
    v11 = xmlHashComputeKey((uint64_t)table, name, name2, name3);
    v12 = *(_QWORD *)table;
    if (*(_DWORD *)(*(_QWORD *)table + 48 * v11 + 40))
      v13 = v12 == 0;
    else
      v13 = 1;
    if (v13)
    {
      return -1;
    }
    else
    {
      v14 = v11;
      v15 = 0;
      v16 = (__int128 *)(v12 + 48 * v11);
      while (!xmlStrEqual(*((const xmlChar **)v16 + 1), name)
           || !xmlStrEqual(*((const xmlChar **)v16 + 2), name2)
           || !xmlStrEqual(*((const xmlChar **)v16 + 3), name3))
      {
        v15 = (__int128 **)v16;
        v16 = *(__int128 **)v16;
        if (!v16)
          return -1;
      }
      if (f)
      {
        v17 = *((_QWORD *)v16 + 4);
        if (v17)
          ((void (*)(uint64_t, _QWORD))f)(v17, *((_QWORD *)v16 + 1));
      }
      *((_QWORD *)v16 + 4) = 0;
      if (!*((_QWORD *)table + 2))
      {
        v18 = (void *)*((_QWORD *)v16 + 1);
        if (v18)
          xmlFree(v18);
        v19 = (void *)*((_QWORD *)v16 + 2);
        if (v19)
          xmlFree(v19);
        v20 = (void *)*((_QWORD *)v16 + 3);
        if (v20)
          xmlFree(v20);
      }
      v21 = *(__int128 **)v16;
      if (v15)
      {
        *v15 = v21;
        ((void (*)(__int128 *))xmlFree)(v16);
      }
      else if (v21)
      {
        v22 = (_OWORD *)(*(_QWORD *)table + 48 * v14);
        v23 = *v21;
        v24 = v21[2];
        v22[1] = v21[1];
        v22[2] = v24;
        *v22 = v23;
        ((void (*)(__int128 *))xmlFree)(v21);
      }
      else
      {
        *((_DWORD *)v16 + 10) = 0;
      }
      result = 0;
      --*((_DWORD *)table + 3);
    }
  }
  return result;
}

int xmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, xmlHashDeallocator f)
{
  return xmlHashRemoveEntry3(table, name, name2, 0, f);
}

const htmlElemDesc *__cdecl htmlTagLookup(const htmlElemDesc *tag)
{
  if (tag)
    return (const htmlElemDesc *)bsearch(tag, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
  return tag;
}

int htmlAutoCloseTag(htmlDocPtr doc, const xmlChar *name, htmlNodePtr elem)
{
  int result;
  const xmlChar *v7;
  _xmlNode *children;
  _QWORD v9[2];

  if (!elem)
    return 1;
  if (xmlStrEqual(name, elem->name))
    return 0;
  v7 = elem->name;
  v9[0] = name;
  v9[1] = v7;
  if (!bsearch(v9, htmlStartClose, 0xFBuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))htmlCompareStartClose))
  {
    children = elem->children;
    if (!children)
      return 0;
    while (1)
    {
      result = htmlAutoCloseTag(doc, name, children);
      if (result)
        break;
      children = children->next;
      if (!children)
        return result;
    }
  }
  return 1;
}

int htmlIsAutoClosed(htmlDocPtr doc, htmlNodePtr elem)
{
  _xmlNode *children;

  if (!elem)
    return 1;
  children = elem->children;
  if (!children)
    return 0;
  while (!htmlAutoCloseTag(doc, elem->name, children))
  {
    children = children->next;
    if (!children)
      return 0;
  }
  return 1;
}

int htmlIsScriptAttribute(const xmlChar *name)
{
  const xmlChar *v1;
  uint64_t v2;

  if (name)
  {
    v1 = name;
    if (*name == 111 && name[1] == 110)
    {
      v2 = 0;
      while (!xmlStrEqual(v1, (const xmlChar *)htmlScriptAttributes[v2]))
      {
        if (++v2 == 18)
          goto LABEL_7;
      }
      LODWORD(name) = 1;
    }
    else
    {
LABEL_7:
      LODWORD(name) = 0;
    }
  }
  return (int)name;
}

const htmlEntityDesc *__cdecl htmlEntityLookup(const xmlChar *name)
{
  const htmlEntityDesc *v2;
  uint64_t v3;

  v2 = (const htmlEntityDesc *)html40EntitiesTable;
  v3 = 253;
  while (!xmlStrEqual(name, (const xmlChar *)v2->name))
  {
    ++v2;
    if (!--v3)
      return 0;
  }
  return v2;
}

const htmlEntityDesc *__cdecl htmlEntityValueLookup(unsigned int value)
{
  const htmlEntityDesc *result;
  uint64_t v3;

  result = (const htmlEntityDesc *)&html40EntitiesTable;
  v3 = 253;
  while (result->value < value)
  {
    ++result;
    if (!--v3)
      return 0;
  }
  if (result->value <= value)
    return result;
  return 0;
}

int UTF8ToHtml(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen)
{
  int result;
  int v7;
  uint64_t v8;
  unsigned __int8 *v9;
  const unsigned __int8 *v10;
  const unsigned __int8 *v11;
  unsigned __int8 *v12;
  const unsigned __int8 *v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  const unsigned __int8 *v19;
  char v20;
  unint64_t v22;
  unsigned int v23;
  char *v24;
  int v25;
  uint64_t v26;
  char *v27;
  char *v28;
  int v29;
  int *v30;
  char __str[8];
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  result = -1;
  if (!out || !outlen || !inlen)
    return result;
  v7 = (int)in;
  if (!in)
  {
    v29 = 0;
    result = 0;
    *outlen = 0;
    goto LABEL_42;
  }
  v30 = inlen;
  v8 = *inlen;
  LODWORD(v9) = (_DWORD)out;
  LODWORD(v10) = (_DWORD)in;
  if ((int)v8 < 1)
  {
LABEL_40:
    result = 0;
    *outlen = (_DWORD)v9 - (_DWORD)out;
    v29 = (_DWORD)v10 - v7;
    goto LABEL_41;
  }
  v11 = &in[v8];
  v12 = &out[*outlen];
  v13 = in;
  v9 = out;
  v10 = in;
  while (1)
  {
    v14 = *(char *)v10++;
    v15 = v14;
    if ((v14 & 0x80000000) == 0)
    {
      v16 = 0;
      v17 = v15;
      goto LABEL_16;
    }
    if (v15 <= 0xBF)
      break;
    if (v15 <= 0xDF)
    {
      v17 = v15 & 0x1F;
      v16 = 1;
      goto LABEL_16;
    }
    if (v15 <= 0xEF)
    {
      v17 = v15 & 0xF;
      v16 = 2;
      goto LABEL_16;
    }
    if (v15 > 0xF7)
      break;
    v17 = v15 & 7;
    v16 = 3;
LABEL_16:
    if (v11 - v10 < v16)
      goto LABEL_39;
    if ((v15 & 0x80) != 0 && v10 < v11)
    {
      v18 = v16 - 1;
      v19 = v13 + 2;
      do
      {
        v10 = v19;
        v20 = *(v19 - 1);
        if ((v20 & 0xC0) != 0x80)
          break;
        v17 = v20 & 0x3F | (v17 << 6);
        if (v18-- == 0)
          break;
        v19 = v10 + 1;
      }
      while (v10 < v11);
    }
    if (v17 > 0x7F)
    {
      *(_QWORD *)__str = 0;
      v32 = 0;
      v22 = 0x3FFFFFFFFFFFFA12uLL;
      while (1)
      {
        v23 = html40EntitiesTable[v22 + 1518];
        if (v23 >= v17)
          break;
        v22 += 6;
        if (!(v22 * 4))
          goto LABEL_33;
      }
      if (v23 <= v17)
      {
        v24 = *(char **)&html40EntitiesTable[v22 + 1520];
        goto LABEL_34;
      }
LABEL_33:
      v24 = __str;
      snprintf(__str, 0x10uLL, "#%u", v17);
LABEL_34:
      v25 = strlen(v24);
      if (&v9[v25 + 2] >= v12)
      {
LABEL_39:
        LODWORD(v10) = (_DWORD)v13;
        goto LABEL_40;
      }
      v26 = v25;
      *v9 = 38;
      v27 = (char *)(v9 + 1);
      memcpy(v27, v24, v25);
      v28 = &v27[v26];
      *v28 = 59;
      v9 = (unsigned __int8 *)(v28 + 1);
    }
    else
    {
      if (v9 + 1 >= v12)
        goto LABEL_39;
      *v9++ = v17;
    }
    v13 = v10;
    if (v10 >= v11)
      goto LABEL_40;
  }
  *outlen = (_DWORD)v9 - (_DWORD)out;
  v29 = (_DWORD)v13 - v7;
  result = -2;
LABEL_41:
  inlen = v30;
LABEL_42:
  *inlen = v29;
  return result;
}

int htmlEncodeEntities(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen, int quoteChar)
{
  int result;
  int v8;
  uint64_t v9;
  const unsigned __int8 *v11;
  const unsigned __int8 *v12;
  unsigned __int8 *v13;
  const unsigned __int8 *v14;
  unsigned __int8 v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  unsigned __int8 v20;
  BOOL v21;
  BOOL v22;
  unint64_t v23;
  unsigned int v24;
  char *v25;
  size_t v26;
  uint64_t v27;
  char *v28;
  int *v29;
  unsigned __int8 *v30;
  char __str[8];
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  result = -1;
  if (in && out && outlen && inlen)
  {
    v8 = (int)in;
    v9 = *inlen;
    if ((int)v9 < 1)
    {
      result = 0;
      LODWORD(v13) = (_DWORD)out;
      LODWORD(v12) = (_DWORD)in;
LABEL_46:
      *outlen = (_DWORD)v13 - (_DWORD)out;
      *inlen = (_DWORD)v12 - v8;
      return result;
    }
    v29 = outlen;
    v30 = &out[*outlen];
    v11 = &in[v9];
    v12 = in;
    v13 = out;
    v14 = in;
    while (1)
    {
      v15 = *v14++;
      v16 = v15;
      if ((v15 & 0x80) != 0)
        break;
      if (v11 - v14 < 0)
        goto LABEL_44;
LABEL_21:
      v21 = v16 > 0x7F || v16 == quoteChar;
      if (!v21 && (v16 <= 0x3E ? (v22 = ((1 << v16) & 0x5000004000000000) == 0) : (v22 = 1), v22))
      {
        if (v13 >= v30)
          goto LABEL_44;
        *v13 = v16;
      }
      else
      {
        *(_QWORD *)__str = 0;
        v32 = 0;
        v23 = 0x3FFFFFFFFFFFFA12uLL;
        while (1)
        {
          v24 = html40EntitiesTable[v23 + 1518];
          if (v24 >= v16)
            break;
          v23 += 6;
          if (!(v23 * 4))
            goto LABEL_35;
        }
        if (v24 <= v16)
        {
          v25 = *(char **)&html40EntitiesTable[v23 + 1520];
          goto LABEL_36;
        }
LABEL_35:
        v25 = __str;
        snprintf(__str, 0x10uLL, "#%u", v16);
LABEL_36:
        v26 = strlen(v25);
        if (v30 - v13 < (uint64_t)((v26 << 32) + 0x200000000) >> 32)
          goto LABEL_44;
        v27 = v26 << 32;
        *v13 = 38;
        v28 = (char *)(v13 + 1);
        memcpy(v28, v25, (int)v26);
        v13 = (unsigned __int8 *)&v28[v27 >> 32];
        *v13 = 59;
      }
      ++v13;
      v12 = v14;
      if (v14 >= v11)
      {
        result = 0;
        LODWORD(v12) = (_DWORD)v14;
        goto LABEL_45;
      }
    }
    if (v16 >= 0xC0)
    {
      if (v16 < 0xE0)
      {
        v17 = 1;
        v18 = 31;
LABEL_17:
        if (v11 - v14 >= v17)
        {
          v19 = 0;
          v16 &= v18;
          v14 = &v12[v17 + 1];
          while (1)
          {
            v20 = v12[v19 + 1];
            if ((v20 & 0xC0) != 0x80)
              goto LABEL_42;
            v16 = v20 & 0x3F | (v16 << 6);
            if (v17 == (_DWORD)++v19)
              goto LABEL_21;
          }
        }
LABEL_44:
        result = 0;
LABEL_45:
        outlen = v29;
        goto LABEL_46;
      }
      if (v16 < 0xF0)
      {
        v17 = 2;
        v18 = 15;
        goto LABEL_17;
      }
      if (v16 <= 0xF7)
      {
        v17 = 3;
        v18 = 7;
        goto LABEL_17;
      }
    }
LABEL_42:
    result = -2;
    goto LABEL_45;
  }
  return result;
}

htmlDocPtr htmlNewDocNoDtD(const xmlChar *URI, const xmlChar *ExternalID)
{
  char *v4;
  xmlDoc *v5;
  xmlRegisterNodeFunc *v6;

  v4 = (char *)xmlMalloc(0xB0uLL);
  v5 = (xmlDoc *)v4;
  if (v4)
  {
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    *((_OWORD *)v4 + 6) = 0u;
    *((_OWORD *)v4 + 7) = 0u;
    *((_OWORD *)v4 + 9) = 0u;
    *((_OWORD *)v4 + 10) = 0u;
    *((_OWORD *)v4 + 8) = 0u;
    *((_OWORD *)v4 + 2) = 0u;
    *((_OWORD *)v4 + 3) = 0u;
    *((_DWORD *)v4 + 2) = 13;
    *((_OWORD *)v4 + 4) = 0u;
    *((_OWORD *)v4 + 5) = 0u;
    *((_QWORD *)v4 + 8) = v4;
    *(_OWORD *)(v4 + 104) = 0u;
    *((_QWORD *)v4 + 12) = 0;
    *((_QWORD *)v4 + 9) = 0x100000000;
    *(_QWORD *)v4 = 0;
    *(_OWORD *)(v4 + 120) = 0u;
    *((_DWORD *)v4 + 36) = 1;
    *((_DWORD *)v4 + 43) = 160;
    if ((unint64_t)URI | (unint64_t)ExternalID)
      xmlCreateIntSubset((xmlDocPtr)v4, (const xmlChar *)"html", ExternalID, URI);
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v6 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlDoc *))*v6)(v5);
    }
  }
  else
  {
    htmlErrMemory(0, (const xmlChar *)"HTML document creation failed\n");
  }
  return v5;
}

_DWORD *htmlErrMemory(_DWORD *result, const xmlChar *a2)
{
  char v2;

  if (!result)
    goto LABEL_5;
  if (!result[83] || result[68] != -1)
  {
    result[34] = 2;
    result[68] = -1;
    result[83] = 1;
LABEL_5:
    if (a2)
      return __xmlRaiseError(0, 0, 0, result, 0, 1u, 2, 3, 0, 0, a2, 0, 0, 0, (unsigned __int128)0 >> 96, "Memory allocation failed : %s\n", (char)a2);
    else
      return __xmlRaiseError(0, 0, 0, result, 0, 1u, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n", v2);
  }
  return result;
}

htmlDocPtr htmlNewDoc(const xmlChar *URI, const xmlChar *ExternalID)
{
  if (!((unint64_t)URI | (unint64_t)ExternalID))
  {
    URI = (const xmlChar *)"http://www.w3.org/TR/REC-html40/loose.dtd";
    ExternalID = (const xmlChar *)"-//W3C//DTD HTML 4.0 Transitional//EN";
  }
  return htmlNewDocNoDtD(URI, ExternalID);
}

int htmlParseCharRef(htmlParserCtxtPtr ctxt)
{
  htmlParserCtxtPtr v1;
  xmlParserInputPtr input;
  const xmlChar *cur;
  const xmlChar *v4;
  int v5;
  int v6;
  int v7;
  const char *v8;
  int v9;
  int v11;
  int v12;
  _DWORD *v13;
  int v14;

  v1 = ctxt;
  if (!ctxt || (input = ctxt->input) == 0)
  {
    v8 = "htmlParseCharRef: context error\n";
    v9 = 1;
    goto LABEL_19;
  }
  cur = input->cur;
  if (*cur != 38 || cur[1] != 35)
  {
    htmlParseErr(ctxt, 8, "htmlParseCharRef: invalid value\n", 0, 0);
    v6 = 0;
    goto LABEL_21;
  }
  v4 = cur + 2;
  if ((cur[2] | 0x20) != 0x78)
  {
    input->cur = v4;
    input->col += 2;
    v11 = *v4;
    if (v11 != 59)
    {
      v6 = 0;
      do
      {
        if ((v11 - 48) > 9)
        {
          v13 = v1;
          v14 = 7;
          goto LABEL_45;
        }
        v12 = v11 + 10 * v6 - 48;
        if (v6 < 1114112)
          v6 = v12;
        xmlNextChar(v1);
        v11 = *v1->input->cur;
      }
      while (v11 != 59);
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  input->cur = cur + 3;
  input->col += 3;
  v5 = cur[3];
  if (v5 == 59)
  {
LABEL_25:
    v6 = 0;
    goto LABEL_26;
  }
  v6 = 0;
  while ((v5 - 48) <= 9)
  {
    v7 = v5 + 16 * v6 - 48;
LABEL_14:
    if (v6 < 1114112)
      v6 = v7;
    xmlNextChar(v1);
    v5 = *v1->input->cur;
    if (v5 == 59)
      goto LABEL_26;
  }
  if ((v5 - 97) <= 5)
  {
    v7 = v5 + 16 * v6 - 87;
    goto LABEL_14;
  }
  if ((v5 - 65) <= 5)
  {
    v7 = v5 + 16 * v6 - 55;
    goto LABEL_14;
  }
  v13 = v1;
  v14 = 6;
LABEL_45:
  htmlParseErr(v13, v14, "htmlParseCharRef: missing semicolon\n", 0, 0);
  if (*v1->input->cur == 59)
LABEL_26:
    xmlNextChar(v1);
  if (v6 > 255)
  {
    if ((v6 - 0x10000) < 0x100000
      || v6 >> 11 < 0x1B
      || (v6 - 57344) >> 1 < 0xFFF)
    {
      return v6;
    }
    if (v6 < 0x110000)
      goto LABEL_21;
    v8 = "htmlParseCharRef: value too large\n";
    ctxt = v1;
    v9 = 9;
LABEL_19:
    htmlParseErr(ctxt, v9, v8, 0, 0);
    return 0;
  }
  if (v6 <= 31 && (v6 > 0xD || ((1 << v6) & 0x2600) == 0))
  {
LABEL_21:
    htmlParseErrInt(v1, "htmlParseCharRef: invalid xmlChar value %d\n", v6);
    return 0;
  }
  return v6;
}

_DWORD *htmlParseErrInt(_DWORD *result, const char *a2, int a3)
{
  _DWORD *v3;

  v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = 9;
    result = __xmlRaiseError(0, 0, 0, result, 0, 5u, 9, 2, 0, 0, 0, 0, 0, a3, 0, a2, a3);
    v3[6] = 0;
  }
  return result;
}

void htmlParseElement(htmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  unint64_t v3;
  unint64_t line;
  const xmlChar *name;
  _BYTE *v6;
  xmlParserInputPtr v7;
  const xmlChar *cur;
  int v9;
  int nameNr;
  unsigned int v11;
  const xmlChar **nameTab;
  endElementSAXFunc endElement;
  int v14;
  unsigned int v15;
  const xmlChar **v16;
  xmlParserInputPtr v17;
  const xmlChar *v18;
  int v19;
  xmlChar *v20;
  int v21;
  xmlParserInputPtr v22;
  const xmlChar *v23;
  int v24;
  const xmlChar *v25;
  uint64_t v26;
  int v27;
  BOOL v28;
  const xmlChar *v29;
  const xmlChar *v30;
  int v31;
  int v32;
  xmlParserInputPtr v33;
  unint64_t v34;
  unint64_t v35;
  const xmlChar *v36;
  xmlParserInputPtr v37;
  unint64_t v38;
  unint64_t v39;
  const xmlChar *v40;
  xmlChar *v41;
  xmlParserNodeInfo info;
  _QWORD __key[2];

  if (!ctxt || (input = ctxt->input) == 0)
  {
    htmlParseErr(ctxt, 1, "htmlParseElement: context error\n", 0, 0);
    return;
  }
  if (ctxt->instate == XML_PARSER_EOF)
    return;
  memset(&info, 0, sizeof(info));
  if (ctxt->record_info)
  {
    v3 = &input->cur[input->consumed] - input->base;
    line = input->line;
    info.begin_pos = v3;
    info.begin_line = line;
  }
  if (htmlParseStartTag((uint64_t)ctxt) != -1)
  {
    name = ctxt->name;
    if (name)
    {
      v6 = bsearch(ctxt->name, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      if (!v6)
        htmlParseErr(ctxt, 801, "Tag %s invalid\n", name, 0);
      v7 = ctxt->input;
      cur = v7->cur;
      v9 = *cur;
      if (v9 != 62)
      {
        if (v9 != 47 || cur[1] != 62)
        {
          htmlParseErr(ctxt, 73, "Couldn't find end of Start Tag %s\n", name, 0);
          if (xmlStrEqual(name, ctxt->name))
          {
            nodePop(ctxt);
            nameNr = ctxt->nameNr;
            v11 = nameNr - 1;
            if (nameNr >= 1)
            {
              ctxt->nameNr = v11;
              nameTab = ctxt->nameTab;
              if (nameNr == 1)
                v36 = 0;
              else
                v36 = nameTab[nameNr - 2];
              ctxt->name = v36;
              nameTab[v11] = 0;
            }
          }
          if (ctxt->record_info)
          {
            v37 = ctxt->input;
            v38 = &v37->cur[v37->consumed] - v37->base;
            v39 = v37->line;
            info.end_pos = v38;
            info.end_line = v39;
            info.node = ctxt->node;
            xmlParserAddNodeInfo(ctxt, &info);
          }
          return;
        }
        v7->cur = cur + 2;
        v7->col += 2;
LABEL_24:
        if (ctxt->sax)
        {
          endElement = ctxt->sax->endElement;
          if (endElement)
            ((void (*)(void *, const xmlChar *))endElement)(ctxt->userData, name);
        }
        v14 = ctxt->nameNr;
        v15 = v14 - 1;
        if (v14 >= 1)
        {
          ctxt->nameNr = v15;
          v16 = ctxt->nameTab;
          if (v14 == 1)
            v40 = 0;
          else
            v40 = v16[v14 - 2];
          ctxt->name = v40;
          v16[v15] = 0;
        }
        return;
      }
      xmlNextChar(ctxt);
      if (v6 && v6[11])
        goto LABEL_24;
      v41 = xmlStrdup(ctxt->name);
      v17 = ctxt->input;
      v18 = v17->cur;
      if (!*v18)
        goto LABEL_95;
      v19 = ctxt->nameNr;
LABEL_33:
      v20 = xmlStrdup(ctxt->name);
      v21 = ctxt->nameNr;
      while (1)
      {
        while (1)
        {
          if (!ctxt->progressive)
          {
            v22 = ctxt->input;
            if (v22->end - v22->cur <= 249)
              xmlParserInputGrow(v22, 250);
          }
          if (ctxt->instate == XML_PARSER_EOF)
          {
LABEL_90:
            if (!v20)
              goto LABEL_92;
LABEL_91:
            xmlFree(v20);
LABEL_92:
            v17 = ctxt->input;
            if (v18 == v17->cur || (v18 = v17->cur, ctxt->nameNr < v19) || !*v18)
            {
LABEL_95:
              if (v41 && ctxt->record_info)
              {
                v34 = &v18[v17->consumed] - v17->base;
                v35 = v17->line;
                info.end_pos = v34;
                info.end_line = v35;
                info.node = ctxt->node;
                xmlParserAddNodeInfo(ctxt, &info);
                v17 = ctxt->input;
              }
              if (!*v17->cur)
                htmlAutoCloseOnEnd((uint64_t)ctxt);
              if (v41)
                xmlFree(v41);
              return;
            }
            goto LABEL_33;
          }
          v23 = ctxt->input->cur;
          if (*v23 == 60)
            break;
LABEL_51:
          v27 = ctxt->nameNr;
          v28 = v27 < 1 || v21 < v27;
          if (!v28 && !xmlStrEqual(v20, ctxt->name))
            goto LABEL_90;
          if (*ctxt->input->cur)
          {
            if (xmlStrEqual(v20, (const xmlChar *)"script") || xmlStrEqual(v20, (const xmlChar *)"style"))
            {
              htmlParseScript((uint64_t)ctxt);
              goto LABEL_82;
            }
            v29 = ctxt->input->cur;
            if (*v29 == 60
              && v29[1] == 33
              && __toupper(v29[2]) == 68
              && __toupper(v29[3]) == 79
              && __toupper(v29[4]) == 67
              && __toupper(v29[5]) == 84
              && __toupper(v29[6]) == 89
              && __toupper(v29[7]) == 80
              && __toupper(v29[8]) == 69)
            {
              htmlParseErr(ctxt, 800, "Misplaced DOCTYPE declaration\n", (const xmlChar *)"DOCTYPE", 0);
              htmlParseDocTypeDecl(ctxt);
            }
          }
          v30 = ctxt->input->cur;
          v31 = *v30;
          if (v31 == 38)
          {
            htmlParseReference((uint64_t)ctxt);
          }
          else if (v31 == 60)
          {
            v32 = v30[1];
            if (v32 == 63)
            {
              htmlParsePI((uint64_t)ctxt);
            }
            else if (v32 == 33 && v30[2] == 45 && v30[3] == 45)
            {
              htmlParseComment((uint64_t)ctxt);
            }
            else
            {
              htmlParseElement(ctxt);
            }
          }
          else
          {
            if (!*v30)
            {
              htmlAutoCloseOnEnd((uint64_t)ctxt);
              goto LABEL_90;
            }
            htmlParseCharData((uint64_t)ctxt);
          }
LABEL_82:
          if (!ctxt->progressive)
          {
            v33 = ctxt->input;
            if (v33->end - v33->cur <= 249)
              xmlParserInputGrow(v33, 250);
          }
        }
        v24 = v23[1];
        if (v24 == 47)
        {
          if (htmlParseEndTag(ctxt))
          {
            if (v20)
              goto LABEL_91;
            if (!ctxt->nameNr)
              goto LABEL_92;
          }
        }
        else
        {
          if ((v24 & 0xFFFFFFDF) - 65 >= 0x1A && v24 != 95 && v24 != 58)
            goto LABEL_51;
          v25 = htmlParseHTMLName_nonInvasive((uint64_t)ctxt);
          if (!v25)
          {
            htmlParseErr(ctxt, 68, "htmlParseStartTag: invalid element name\n", 0, 0);
            while (*ctxt->input->cur && *ctxt->input->cur != 62)
              xmlNextChar(ctxt);
            goto LABEL_90;
          }
          if (!ctxt->name)
            goto LABEL_51;
          v26 = (uint64_t)v25;
          __key[0] = ctxt->name;
          __key[1] = v25;
          if (!bsearch(__key, htmlStartClose, 0xFBuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))htmlCompareStartClose))goto LABEL_51;
          htmlAutoClose((int *)ctxt, v26);
        }
      }
    }
  }
  if (*ctxt->input->cur == 62)
    xmlNextChar(ctxt);
}

void __htmlParseContent(uint64_t a1)
{
  if (a1)
    htmlParseContentInternal(a1);
}

void htmlParseComment(uint64_t a1)
{
  xmlParserInput *v2;
  const xmlChar *cur;
  int v4;
  const xmlChar *v5;
  xmlChar *v6;
  xmlChar *v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t v14;
  int v15;
  _BYTE *v16;
  _BYTE *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  _BYTE *v25;
  _BYTE *v26;
  int v27;
  xmlParserInput *v28;
  const xmlChar *v29;
  xmlParserInput *v30;
  xmlChar *v31;
  void (*v32)(_QWORD, xmlChar *);
  int v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;

  if (*(_DWORD *)(a1 + 276))
    return;
  v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (*cur != 60 || cur[1] != 33 || cur[2] != 45 || cur[3] != 45)
    return;
  v4 = *(_DWORD *)(a1 + 272);
  *(_DWORD *)(a1 + 272) = 5;
  v5 = cur + 4;
  v2->cur = v5;
  v2->col += 4;
  if (v5 - v2->base >= 501 && v2->end - v5 <= 499)
    xmlParserInputShrink(v2);
  v6 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (!v6)
  {
    htmlErrMemory((_DWORD *)a1, (const xmlChar *)"buffer allocation failed\n");
    *(_DWORD *)(a1 + 272) = v4;
    return;
  }
  v7 = v6;
  v37 = 0;
  *v6 = 0;
  v8 = htmlCurrentChar(a1, &v37);
  if (!v8)
    goto LABEL_64;
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 56);
  v11 = v37;
  v12 = *(_BYTE **)(v10 + 32);
  v13 = &v12[v37];
  if ((unint64_t)v13 <= *(_QWORD *)(v10 + 40))
  {
    if (*v12 == 10)
    {
      ++*(_DWORD *)(v10 + 52);
      *(_DWORD *)(v10 + 56) = 1;
    }
    else
    {
      ++*(_DWORD *)(v10 + 56);
    }
    *(_DWORD *)(a1 + 276) = 0;
    *(_QWORD *)(v10 + 32) = v13;
    ++*(_QWORD *)(a1 + 312);
  }
  v36 = 0;
  v34 = htmlCurrentChar(a1, &v36);
  if (!v34)
  {
LABEL_64:
    htmlParseErr((_DWORD *)a1, 45, "Comment not terminated \n<!--%.50s\n", v7, 0);
    xmlFree(v7);
    return;
  }
  v14 = *(_QWORD *)(a1 + 56);
  v15 = v36;
  v16 = *(_BYTE **)(v14 + 32);
  v17 = &v16[v36];
  if ((unint64_t)v17 <= *(_QWORD *)(v14 + 40))
  {
    if (*v16 == 10)
    {
      ++*(_DWORD *)(v14 + 52);
      *(_DWORD *)(v14 + 56) = 1;
    }
    else
    {
      ++*(_DWORD *)(v14 + 56);
    }
    *(_DWORD *)(a1 + 276) = 0;
    *(_QWORD *)(v14 + 32) = v17;
    ++*(_QWORD *)(a1 + 312);
  }
  v35 = 0;
  v18 = htmlCurrentChar(a1, (_DWORD *)&v35 + 1);
  if (!v18)
  {
    v20 = 0;
LABEL_63:
    v7[v20] = 0;
    goto LABEL_64;
  }
  v19 = v18;
  v33 = v4;
  v20 = 0;
  v21 = 100;
  while (1)
  {
    v22 = v34;
    v34 = v19;
    if (v9 == 45 && v22 == 45 && v19 == 62)
      break;
    v23 = *(_QWORD *)(a1 + 56);
    v24 = HIDWORD(v35);
    v25 = *(_BYTE **)(v23 + 32);
    v26 = &v25[SHIDWORD(v35)];
    if ((unint64_t)v26 <= *(_QWORD *)(v23 + 40))
    {
      if (*v25 == 10)
      {
        ++*(_DWORD *)(v23 + 52);
        v27 = 1;
      }
      else
      {
        v27 = *(_DWORD *)(v23 + 56) + 1;
      }
      *(_DWORD *)(v23 + 56) = v27;
      *(_DWORD *)(a1 + 276) = 0;
      *(_QWORD *)(v23 + 32) = v26;
      ++*(_QWORD *)(a1 + 312);
    }
    v19 = htmlCurrentChar(a1, &v35);
    if (!v19)
    {
      v28 = *(xmlParserInput **)(a1 + 56);
      v29 = v28->cur;
      if (v29 - v28->base >= 501 && v28->end - v29 <= 499)
        xmlParserInputShrink(v28);
      if (!*(_DWORD *)(a1 + 452))
      {
        v30 = *(xmlParserInput **)(a1 + 56);
        if (v30->end - v30->cur <= 249)
          xmlParserInputGrow(v30, 250);
      }
      v19 = htmlCurrentChar(a1, &v35);
    }
    if (v9 == 45 && v22 == 45 && v34 == 33 && v19 == 62)
    {
      htmlParseErr((_DWORD *)a1, 45, "Comment incorrectly closed by '--!>'", 0, 0);
      break;
    }
    if (v20 + 5 >= v21)
    {
      v21 *= 2;
      v31 = (xmlChar *)xmlRealloc(v7, v21);
      if (!v31)
      {
        xmlFree(v7);
        htmlErrMemory((_DWORD *)a1, (const xmlChar *)"growing buffer failed\n");
        goto LABEL_72;
      }
      v7 = v31;
    }
    if (v9 > 255)
    {
      if ((v9 - 0x10000) < 0x100000
        || v9 >> 11 < 0x1B
        || (v9 - 57344) >> 1 <= 0xFFE)
      {
LABEL_57:
        if (v11 == 1)
        {
          v7[v20++] = v9;
          v24 = HIDWORD(v35);
          v15 = v36;
        }
        else
        {
          v20 += xmlCopyChar(v11, &v7[v20], v9);
        }
        goto LABEL_60;
      }
    }
    else if (v9 > 31 || v9 <= 0xD && ((1 << v9) & 0x2600) != 0)
    {
      goto LABEL_57;
    }
    htmlParseErrInt((_DWORD *)a1, "Invalid char in comment 0x%X\n", v9);
LABEL_60:
    v11 = v15;
    HIDWORD(v35) = v35;
    v36 = v24;
    v15 = v24;
    v9 = v22;
    if (!v19)
      goto LABEL_63;
  }
  v7[v20] = 0;
  xmlNextChar((xmlParserCtxtPtr)a1);
  if (*(_QWORD *)a1)
  {
    v32 = *(void (**)(_QWORD, xmlChar *))(*(_QWORD *)a1 + 160);
    if (v32)
    {
      if (!*(_DWORD *)(a1 + 332))
        v32(*(_QWORD *)(a1 + 8), v7);
    }
  }
  xmlFree(v7);
LABEL_72:
  *(_DWORD *)(a1 + 272) = v33;
}

void htmlParsePI(uint64_t a1)
{
  xmlParserInput *v2;
  const xmlChar *cur;
  int v4;
  const xmlChar *v5;
  const xmlChar *v6;
  const xmlChar *v7;
  uint64_t v8;
  _BYTE *v9;
  void (*v10)(_QWORD, const xmlChar *, _QWORD);
  void *v11;
  void *v12;
  unsigned int v13;
  BOOL v14;
  uint64_t v15;
  int v17;
  int v18;
  int v19;
  int v20;
  void *v21;
  xmlParserInput *v22;
  uint64_t v23;
  _BYTE *v24;
  _BYTE *v25;
  xmlParserInput *v26;
  const xmlChar *v27;
  xmlParserInput *v28;
  uint64_t v29;
  void (*v30)(_QWORD, const xmlChar *, void *);
  int len;

  if (*(_DWORD *)(a1 + 276))
    return;
  v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (*cur != 60 || cur[1] != 63)
    return;
  v4 = *(_DWORD *)(a1 + 272);
  *(_DWORD *)(a1 + 272) = 2;
  v5 = cur + 2;
  v2->cur = v5;
  v2->col += 2;
  if (v5 - v2->base >= 501 && v2->end - v5 <= 499)
    xmlParserInputShrink(v2);
  v6 = htmlParseName(a1);
  if (!v6)
  {
    htmlParseErr((_DWORD *)a1, 46, "PI is not started correctly", 0, 0);
    goto LABEL_68;
  }
  v7 = v6;
  if (!*(_DWORD *)(a1 + 276))
  {
    v8 = *(_QWORD *)(a1 + 56);
    v9 = *(_BYTE **)(v8 + 32);
    if (*v9 == 62)
    {
      *(_QWORD *)(v8 + 32) = v9 + 1;
      ++*(_DWORD *)(v8 + 56);
      if (*(_QWORD *)a1 && !*(_DWORD *)(a1 + 332))
      {
        v10 = *(void (**)(_QWORD, const xmlChar *, _QWORD))(*(_QWORD *)a1 + 152);
        if (v10)
          v10(*(_QWORD *)(a1 + 8), v6, 0);
      }
      goto LABEL_68;
    }
  }
  v11 = xmlMallocAtomic(0x64uLL);
  if (!v11)
  {
    htmlErrMemory((_DWORD *)a1, 0);
    goto LABEL_68;
  }
  v12 = v11;
  v13 = **(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
  v14 = v13 > 0x20;
  v15 = (1 << v13) & 0x100002600;
  if (v14 || v15 == 0)
    htmlParseErr((_DWORD *)a1, 65, "ParsePI: PI %s space expected\n", v7, 0);
  len = 0;
  htmlSkipBlankChars(a1);
  v17 = htmlCurrentChar(a1, &len);
  v18 = 0;
  v19 = 0;
  v20 = 100;
  while (v17 && v17 != 62)
  {
    if (v18 + 5 >= v20)
    {
      v20 *= 2;
      v21 = xmlRealloc(v12, v20);
      if (!v21)
      {
        htmlErrMemory((_DWORD *)a1, 0);
        goto LABEL_67;
      }
      v12 = v21;
    }
    if (v19 >= 50)
    {
      if (!*(_DWORD *)(a1 + 452))
      {
        v22 = *(xmlParserInput **)(a1 + 56);
        if (v22->end - v22->cur <= 249)
          xmlParserInputGrow(v22, 250);
      }
      v19 = 0;
    }
    else
    {
      ++v19;
    }
    if (v17 > 255)
    {
      if ((v17 - 0x10000) >= 0x100000
        && v17 >> 11 >= 0x1B
        && (v17 - 57344) >> 1 > 0xFFE)
      {
LABEL_41:
        htmlParseErrInt((_DWORD *)a1, "Invalid char in processing instruction 0x%X\n", v17);
        goto LABEL_45;
      }
    }
    else if (v17 <= 31 && (v17 > 0xD || ((1 << v17) & 0x2600) == 0))
    {
      goto LABEL_41;
    }
    if (len == 1)
      *((_BYTE *)v12 + v18++) = v17;
    else
      v18 += xmlCopyChar(len, (xmlChar *)v12 + v18, v17);
LABEL_45:
    v23 = *(_QWORD *)(a1 + 56);
    v24 = *(_BYTE **)(v23 + 32);
    v25 = &v24[len];
    if ((unint64_t)v25 <= *(_QWORD *)(v23 + 40))
    {
      if (*v24 == 10)
      {
        ++*(_DWORD *)(v23 + 52);
        *(_DWORD *)(v23 + 56) = 1;
      }
      else
      {
        ++*(_DWORD *)(v23 + 56);
      }
      *(_DWORD *)(a1 + 276) = 0;
      *(_QWORD *)(v23 + 32) = v25;
      ++*(_QWORD *)(a1 + 312);
    }
    v17 = htmlCurrentChar(a1, &len);
    if (!v17)
    {
      v26 = *(xmlParserInput **)(a1 + 56);
      v27 = v26->cur;
      if (v27 - v26->base >= 501 && v26->end - v27 <= 499)
        xmlParserInputShrink(v26);
      if (!*(_DWORD *)(a1 + 452))
      {
        v28 = *(xmlParserInput **)(a1 + 56);
        if (v28->end - v28->cur <= 249)
          xmlParserInputGrow(v28, 250);
      }
      v17 = htmlCurrentChar(a1, &len);
    }
  }
  *((_BYTE *)v12 + v18) = 0;
  if (v17 == 62)
  {
    v29 = *(_QWORD *)(a1 + 56);
    ++*(_QWORD *)(v29 + 32);
    ++*(_DWORD *)(v29 + 56);
    if (*(_QWORD *)a1)
    {
      if (!*(_DWORD *)(a1 + 332))
      {
        v30 = *(void (**)(_QWORD, const xmlChar *, void *))(*(_QWORD *)a1 + 152);
        if (v30)
          v30(*(_QWORD *)(a1 + 8), v7, v12);
      }
    }
  }
  else
  {
    htmlParseErr((_DWORD *)a1, 47, "ParsePI: PI %s never end ...\n", v7, 0);
  }
LABEL_67:
  xmlFree(v12);
LABEL_68:
  *(_DWORD *)(a1 + 272) = v4;
}

void htmlParseDocTypeDecl(xmlParserCtxt *a1)
{
  xmlParserInputPtr input;
  const xmlChar *v3;
  xmlParserInputPtr v4;
  unsigned __int8 *cur;
  xmlParserInputPtr v6;
  BOOL v7;
  uint64_t v8;
  xmlChar *v10;
  xmlChar *v11;
  xmlParserInputPtr v12;
  unsigned __int8 *v13;
  xmlParserInputPtr v14;
  unsigned int v15;
  int v16;
  void (*internalSubset)(void *, const xmlChar *, xmlChar *, xmlChar *);

  input = a1->input;
  input->cur += 9;
  input->col += 9;
  htmlSkipBlankChars((uint64_t)a1);
  v3 = htmlParseName((uint64_t)a1);
  if (!v3)
    htmlParseErr(a1, 68, "htmlParseDocTypeDecl : no DOCTYPE name !\n", 0, 0);
  htmlSkipBlankChars((uint64_t)a1);
  v4 = a1->input;
  cur = (unsigned __int8 *)v4->cur;
  if (__toupper(*cur) == 83
    && __toupper(cur[1]) == 89
    && __toupper(cur[2]) == 83
    && __toupper(cur[3]) == 84
    && __toupper(cur[4]) == 69
    && __toupper(cur[5]) == 77)
  {
    v4->cur = cur + 6;
    v6 = a1->input;
    v6->col += 6;
    LODWORD(v6) = *v6->cur;
    v7 = v6 > 0x20;
    v8 = (1 << (char)v6) & 0x100002600;
    if (v7 || v8 == 0)
      htmlParseErr(a1, 65, "Space required after 'SYSTEM'\n", 0, 0);
    htmlSkipBlankChars((uint64_t)a1);
    v10 = htmlParseSystemLiteral(a1);
    if (!v10)
      htmlParseErr(a1, 70, "htmlParseExternalID: SYSTEM, no URI\n", 0, 0);
    v11 = 0;
  }
  else
  {
    v12 = a1->input;
    v13 = (unsigned __int8 *)v12->cur;
    if (__toupper(*v13) == 80
      && __toupper(v13[1]) == 85
      && __toupper(v13[2]) == 66
      && __toupper(v13[3]) == 76
      && __toupper(v13[4]) == 73
      && __toupper(v13[5]) == 67)
    {
      v12->cur = v13 + 6;
      v14 = a1->input;
      v14->col += 6;
      v15 = *v14->cur;
      if (v15 > 0x20 || ((1 << v15) & 0x100002600) == 0)
        htmlParseErr(a1, 65, "Space required after 'PUBLIC'\n", 0, 0);
      htmlSkipBlankChars((uint64_t)a1);
      v11 = htmlParsePubidLiteral(a1);
      if (!v11)
        htmlParseErr(a1, 71, "htmlParseExternalID: PUBLIC, no Public Identifier\n", 0, 0);
      htmlSkipBlankChars((uint64_t)a1);
      v16 = *a1->input->cur;
      if (v16 == 39 || v16 == 34)
      {
        v10 = htmlParseSystemLiteral(a1);
        goto LABEL_34;
      }
    }
    else
    {
      v11 = 0;
    }
    v10 = 0;
  }
LABEL_34:
  htmlSkipBlankChars((uint64_t)a1);
  if (*a1->input->cur == 62)
  {
LABEL_35:
    xmlNextChar(a1);
  }
  else
  {
    htmlParseErr(a1, 61, "DOCTYPE improperly terminated\n", 0, 0);
    while (*a1->input->cur)
    {
      if (*a1->input->cur == 62)
        goto LABEL_35;
      xmlNextChar(a1);
    }
  }
  if (a1->sax)
  {
    internalSubset = (void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))a1->sax->internalSubset;
    if (internalSubset)
    {
      if (!a1->disableSAX)
        internalSubset(a1->userData, v3, v11, v10);
    }
  }
  if (v10)
    xmlFree(v10);
  if (v11)
    xmlFree(v11);
}

int htmlParseChunk(htmlParserCtxtPtr ctxt, const char *chunk, int size, int terminate)
{
  htmlParserCtxtPtr v4;
  xmlParserInputPtr input;
  unint64_t InputBase;
  xmlParserInputPtr v10;
  uint64_t v11;
  int v12;
  int v13;
  const char *v14;
  int v15;
  uint64_t buf;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  xmlParserInputPtr v21;
  BOOL v22;
  size_t length;
  const xmlChar *cur;
  const xmlChar *base;
  uint64_t v26;
  unsigned int v27;
  size_t v29;
  xmlParserInputPtr v30;
  size_t v31;
  _DWORD *v32;
  const char *v33;
  size_t v34;
  void (*characters)(void *, __int16 *, uint64_t);
  unsigned int v36;
  _xmlSAXHandler *v37;
  void (*ignorableWhitespace)(void *, __int16 *, uint64_t);
  int v39;
  size_t v40;
  const xmlChar *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  unsigned __int8 *v46;
  int v47;
  int v48;
  unsigned __int8 *v49;
  int v50;
  int v51;
  unsigned int v52;
  int v53;
  _xmlSAXHandler *sax;
  void (*setDocumentLocator)(void *, xmlSAXLocator *);
  void *userData;
  xmlSAXLocator *v57;
  void (*startDocument)(void *);
  const xmlChar *v59;
  unsigned __int8 *v60;
  unsigned __int8 *v61;
  xmlParserInputPtr v62;
  int64_t v63;
  uint64_t line;
  int started;
  const xmlChar *name;
  _BYTE *v67;
  xmlParserInputPtr v68;
  const xmlChar *v69;
  int v70;
  void (*endElement)(void *, const xmlChar *);
  int nameNr;
  unsigned int v73;
  const xmlChar **nameTab;
  int v75;
  unsigned int v76;
  const xmlChar **v77;
  unsigned __int8 *v78;
  void (*v79)(void *, const xmlChar *);
  int v80;
  unsigned int v81;
  const xmlChar **v82;
  const xmlChar *v83;
  const xmlChar *v84;
  const xmlChar *v85;
  const xmlChar *v86;
  const xmlChar *v87;
  const xmlDoc *myDoc;
  xmlParserInputState instate;
  xmlParserInputState v90;
  void (*v91)(void *);
  void (*v93)(void *);
  void (*endDocument)(void *);
  void (*v95)(void *);
  __int16 v96;
  __int128 v97;
  __int128 v98;
  uint64_t v99;

  v4 = ctxt;
  if (!ctxt || (input = ctxt->input) == 0)
  {
    v14 = "htmlParseChunk: context error\n";
    v13 = 1;
    v15 = 1;
LABEL_10:
    htmlParseErr(ctxt, v15, v14, 0, 0);
    return v13;
  }
  if (chunk && size >= 1 && input->buf && ctxt->instate != XML_PARSER_EOF)
  {
    InputBase = xmlBufGetInputBase((uint64_t)input->buf->buffer, (uint64_t)input);
    v10 = v4->input;
    v11 = v10->cur - v10->base;
    v12 = xmlParserInputBufferPush(v10->buf, size, chunk);
    xmlBufSetInputBaseCur((uint64_t *)v4->input->buf->buffer, &v4->input->buf, InputBase, v11);
    if (v12 < 0)
    {
      v13 = -1;
      v4->errNo = -1;
      v4->disableSAX = 1;
      return v13;
    }
    goto LABEL_17;
  }
  if (ctxt->instate != XML_PARSER_EOF)
  {
    buf = (uint64_t)input->buf;
    if (input->buf)
    {
      if (*(_QWORD *)(buf + 24))
      {
        v17 = *(_QWORD *)(buf + 32);
        if (v17)
        {
          if (*(_QWORD *)(buf + 40))
          {
            v18 = xmlBufGetInputBase(v17, (uint64_t)input);
            v19 = v4->input->cur - v4->input->base;
            v20 = xmlCharEncInput(buf, terminate);
            xmlBufSetInputBaseCur(*(uint64_t **)(buf + 32), &v4->input->buf, v18, v19);
            if (v20 < 0)
            {
              v14 = "encoder error\n";
              v13 = 81;
              ctxt = v4;
              v15 = 81;
              goto LABEL_10;
            }
          }
        }
      }
    }
  }
LABEL_17:
  v99 = 0;
  v97 = 0u;
  v98 = 0u;
  v21 = v4->input;
  if (!v21)
    goto LABEL_269;
  v22 = terminate != 0;
  while (1)
  {
LABEL_19:
    if (v21->buf)
      length = xmlBufUse(v21->buf->buffer);
    else
      length = v21->length;
    base = v21->base;
    cur = v21->cur;
    v26 = (uint64_t)&base[length - (_QWORD)cur];
    if (terminate && !v26)
    {
      htmlAutoCloseOnEnd((uint64_t)v4);
      if (!v4->nameNr && v4->instate != XML_PARSER_EOF)
      {
        v4->instate = XML_PARSER_EOF;
        if (v4->sax)
        {
          endDocument = (void (*)(void *))v4->sax->endDocument;
          if (endDocument)
            endDocument(v4->userData);
        }
      }
LABEL_269:
      v26 = 0;
LABEL_270:
      v22 = terminate != 0;
      if (terminate && !v26)
      {
        htmlAutoCloseOnEnd((uint64_t)v4);
        if (!v4->nameNr && v4->instate != XML_PARSER_EOF)
        {
          v4->instate = XML_PARSER_EOF;
          if (v4->sax)
          {
            v93 = (void (*)(void *))v4->sax->endDocument;
            if (v93)
              v93(v4->userData);
          }
        }
        v22 = 1;
      }
      goto LABEL_274;
    }
    if (v26 < 1)
      goto LABEL_270;
    v27 = *cur;
    if (*cur)
      break;
    v30 = v4->input;
    ++v30->cur;
    ++v30->col;
LABEL_78:
    v21 = v4->input;
    if (!v21)
      goto LABEL_270;
  }
  switch(v4->instate)
  {
    case XML_PARSER_EOF:
      goto LABEL_274;
    case XML_PARSER_START:
      if (v27 <= 0x20 && ((1 << v27) & 0x100002600) != 0)
      {
        htmlSkipBlankChars((uint64_t)v4);
        if (v21->buf)
          v29 = xmlBufUse(v21->buf->buffer);
        else
          v29 = v21->length;
        v26 = (uint64_t)&v21->base[v29 - (unint64_t)v21->cur];
      }
      sax = v4->sax;
      if (v4->sax)
      {
        setDocumentLocator = (void (*)(void *, xmlSAXLocator *))sax->setDocumentLocator;
        if (!setDocumentLocator
          || (userData = v4->userData,
              v57 = __xmlDefaultSAXLocator(),
              setDocumentLocator(userData, v57),
              (sax = v4->sax) != 0))
        {
          startDocument = (void (*)(void *))sax->startDocument;
          if (startDocument)
          {
            if (!v4->disableSAX)
              startDocument(v4->userData);
          }
        }
      }
      v59 = v21->cur;
      if (*v59 == 60 && v59[1] == 33)
      {
        v60 = (unsigned __int8 *)v4->input->cur;
        if (__toupper(v60[2]) == 68
          && __toupper(v60[3]) == 79
          && __toupper(v60[4]) == 67
          && __toupper(v60[5]) == 84
          && __toupper(v60[6]) == 89
          && __toupper(v60[7]) == 80
          && __toupper(v60[8]) == 69)
        {
          goto LABEL_171;
        }
      }
      v4->instate = XML_PARSER_MISC;
      goto LABEL_78;
    case XML_PARSER_MISC:
      htmlSkipBlankChars((uint64_t)v4);
      if (v21->buf)
        v31 = xmlBufUse(v21->buf->buffer);
      else
        v31 = v21->length;
      v46 = (unsigned __int8 *)v21->cur;
      v26 = (uint64_t)&v21->base[v31 - (_QWORD)v46];
      if (v26 < 1)
        goto LABEL_270;
      if (v26 == 1)
      {
        if (!terminate)
          goto LABEL_302;
        goto LABEL_252;
      }
      v47 = v46[1];
      v48 = *v46;
      if (v48 != 60 || v47 != 33)
      {
        if (v48 == 60 && v47 == 63)
        {
          if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 0) & 0x80000000) != 0)
            goto LABEL_302;
          htmlParsePI((uint64_t)v4);
          goto LABEL_163;
        }
LABEL_252:
        v4->instate = XML_PARSER_CONTENT;
        goto LABEL_78;
      }
      if (v46[2] == 45 && v46[3] == 45)
      {
        if (!terminate && (htmlParseLookupCommentEnd((uint64_t)v4) & 0x80000000) != 0)
          goto LABEL_302;
        htmlParseComment((uint64_t)v4);
LABEL_163:
        v4->instate = XML_PARSER_MISC;
        goto LABEL_78;
      }
      v61 = (unsigned __int8 *)v4->input->cur;
      if (__toupper(v61[2]) != 68
        || __toupper(v61[3]) != 79
        || __toupper(v61[4]) != 67
        || __toupper(v61[5]) != 84
        || __toupper(v61[6]) != 89
        || __toupper(v61[7]) != 80
        || __toupper(v61[8]) != 69)
      {
        if ((unint64_t)v26 < 9)
          goto LABEL_274;
        goto LABEL_252;
      }
LABEL_171:
      if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 1) & 0x80000000) != 0)
        goto LABEL_302;
      htmlParseDocTypeDecl(v4);
      v4->instate = XML_PARSER_PROLOG;
      goto LABEL_78;
    case XML_PARSER_PI:
      v32 = v4;
      v33 = "HPP: internal error, state == PI\n";
      goto LABEL_76;
    case XML_PARSER_DTD:
      v32 = v4;
      v33 = "HPP: internal error, state == DTD\n";
      goto LABEL_76;
    case XML_PARSER_PROLOG:
      htmlSkipBlankChars((uint64_t)v4);
      if (v21->buf)
        v34 = xmlBufUse(v21->buf->buffer);
      else
        v34 = v21->length;
      v49 = (unsigned __int8 *)v21->cur;
      v26 = (uint64_t)&v21->base[v34 - (_QWORD)v49];
      if (v26 < 2)
        goto LABEL_270;
      v50 = *v49;
      v51 = v49[1];
      if (v50 == 60 && v51 == 33)
      {
        if (v49[2] != 45 || v49[3] != 45)
        {
          if ((unint64_t)v26 < 4)
            goto LABEL_274;
          goto LABEL_252;
        }
        if (!terminate && (htmlParseLookupCommentEnd((uint64_t)v4) & 0x80000000) != 0)
          goto LABEL_302;
        htmlParseComment((uint64_t)v4);
      }
      else
      {
        if (v50 != 60 || v51 != 63)
          goto LABEL_252;
        if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 0) & 0x80000000) != 0)
          goto LABEL_302;
        htmlParsePI((uint64_t)v4);
      }
      v4->instate = XML_PARSER_PROLOG;
      goto LABEL_78;
    case XML_PARSER_COMMENT:
      v32 = v4;
      v33 = "HPP: internal error, state == COMMENT\n";
      goto LABEL_76;
    case XML_PARSER_START_TAG:
      if ((unint64_t)v26 > 1)
      {
        if (v27 != 60)
          goto LABEL_252;
        if (cur[1] == 47)
        {
          v39 = 9;
LABEL_70:
          v4->instate = v39;
LABEL_77:
          v4->checkIndex = 0;
          goto LABEL_78;
        }
        if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 1) & 0x80000000) != 0)
          goto LABEL_302;
      }
      else
      {
        if (!terminate)
          goto LABEL_302;
        if (v27 != 60)
          goto LABEL_252;
      }
      if (v4->record_info)
      {
        v62 = v4->input;
        v63 = &v62->cur[v62->consumed] - v62->base;
        line = v62->line;
        *((_QWORD *)&v97 + 1) = v63;
        *(_QWORD *)&v98 = line;
      }
      started = htmlParseStartTag((uint64_t)v4);
      if (v4->instate == XML_PARSER_EOF)
        goto LABEL_305;
      if (started == -1 || (name = v4->name) == 0)
      {
        v21 = v4->input;
        if (*v21->cur == 62)
        {
          xmlNextChar(v4);
          goto LABEL_78;
        }
        if (!v21)
          goto LABEL_270;
        goto LABEL_19;
      }
      v67 = bsearch(v4->name, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      if (!v67)
        htmlParseErr(v4, 801, "Tag %s invalid\n", name, 0);
      v68 = v4->input;
      v69 = v68->cur;
      v70 = *v69;
      if (v70 != 62)
      {
        if (v70 == 47 && v69[1] == 62)
        {
          v68->cur = v69 + 2;
          v68->col += 2;
          if (v4->sax)
          {
            endElement = (void (*)(void *, const xmlChar *))v4->sax->endElement;
            if (endElement)
              endElement(v4->userData, name);
          }
          nameNr = v4->nameNr;
          v73 = nameNr - 1;
          if (nameNr >= 1)
          {
            v4->nameNr = v73;
            nameTab = v4->nameTab;
            if (nameNr == 1)
              v85 = 0;
            else
              v85 = nameTab[nameNr - 2];
            v4->name = v85;
            nameTab[v73] = 0;
          }
        }
        else
        {
          htmlParseErr(v4, 73, "Couldn't find end of Start Tag %s\n", name, 0);
          if (xmlStrEqual(name, v4->name))
          {
            nodePop(v4);
            v75 = v4->nameNr;
            v76 = v75 - 1;
            if (v75 >= 1)
            {
              v4->nameNr = v76;
              v77 = v4->nameTab;
              if (v75 == 1)
                v84 = 0;
              else
                v84 = v77[v75 - 2];
              v4->name = v84;
              v77[v76] = 0;
            }
          }
          if (v4->record_info)
            htmlNodeInfoPush((uint64_t)v4, &v97);
        }
        goto LABEL_252;
      }
      xmlNextChar(v4);
      if (v67 && v67[11])
      {
        if (v4->sax)
        {
          v79 = (void (*)(void *, const xmlChar *))v4->sax->endElement;
          if (v79)
            v79(v4->userData, name);
        }
        v80 = v4->nameNr;
        v81 = v80 - 1;
        if (v80 >= 1)
        {
          v4->nameNr = v81;
          v82 = v4->nameTab;
          if (v80 == 1)
            v86 = 0;
          else
            v86 = v82[v80 - 2];
          v4->name = v86;
          v82[v81] = 0;
        }
      }
      if (v4->record_info)
        htmlNodeInfoPush((uint64_t)v4, &v97);
      v4->instate = XML_PARSER_CONTENT;
      goto LABEL_78;
    case XML_PARSER_CONTENT:
      v96 = 0;
      if (v4->token)
      {
        LOBYTE(v96) = v4->token;
        htmlCheckParagraph((uint64_t)v4);
        if (v4->sax)
        {
          characters = (void (*)(void *, __int16 *, uint64_t))v4->sax->characters;
          if (characters)
            characters(v4->userData, &v96, 1);
        }
        v4->token = 0;
        v4->checkIndex = 0;
      }
      if (terminate && v26 == 1)
      {
        v36 = *v21->cur;
        if (v36 == 38 || v36 == 60)
          goto LABEL_274;
        v37 = v4->sax;
        if (!v4->sax)
          goto LABEL_228;
        LOBYTE(v96) = *v21->cur;
        if (v36 <= 0x20 && ((1 << v36) & 0x100002600) != 0)
        {
          if (!v4->keepBlanks)
          {
            ignorableWhitespace = (void (*)(void *, __int16 *, uint64_t))v37->ignorableWhitespace;
            if (!ignorableWhitespace)
              goto LABEL_228;
LABEL_227:
            ignorableWhitespace(v4->userData, &v96, 1);
LABEL_228:
            v4->token = 0;
            v4->checkIndex = 0;
            ++v21->cur;
            goto LABEL_78;
          }
        }
        else
        {
          htmlCheckParagraph((uint64_t)v4);
          v37 = v4->sax;
        }
        ignorableWhitespace = (void (*)(void *, __int16 *, uint64_t))v37->characters;
        if (ignorableWhitespace)
          goto LABEL_227;
        goto LABEL_228;
      }
      if ((unint64_t)v26 < 2)
        goto LABEL_274;
      v41 = v21->cur;
      v42 = *v41;
      v43 = v41[1];
      if (xmlStrEqual(v4->name, (const xmlChar *)"script") || xmlStrEqual(v4->name, (const xmlChar *)"style"))
      {
        if (!terminate)
        {
          v44 = htmlParseLookupSequence((uint64_t)v4, 60, 47, 0);
          if (v44 < 0)
            goto LABEL_274;
          if (!v21->cur[v44 + 2])
          {
LABEL_302:
            v22 = 0;
            goto LABEL_274;
          }
        }
        htmlParseScript((uint64_t)v4);
        if (v42 == 60 && v43 == 47)
        {
LABEL_91:
          v45 = 9;
          goto LABEL_92;
        }
      }
      else if (v42 == 60 && v43 == 33)
      {
        v78 = (unsigned __int8 *)v4->input->cur;
        if (__toupper(v78[2]) != 68
          || __toupper(v78[3]) != 79
          || __toupper(v78[4]) != 67
          || __toupper(v78[5]) != 84
          || __toupper(v78[6]) != 89
          || __toupper(v78[7]) != 80
          || __toupper(v78[8]) != 69)
        {
          v83 = v21->cur;
          if (v83[2] != 45 || v83[3] != 45)
          {
            if ((unint64_t)v26 < 4)
              goto LABEL_274;
            goto LABEL_242;
          }
          if (!terminate && (htmlParseLookupCommentEnd((uint64_t)v4) & 0x80000000) != 0)
            goto LABEL_274;
          htmlParseComment((uint64_t)v4);
          goto LABEL_240;
        }
        if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 1) & 0x80000000) != 0)
          goto LABEL_274;
        htmlParseErr(v4, 800, "Misplaced DOCTYPE declaration\n", (const xmlChar *)"DOCTYPE", 0);
        htmlParseDocTypeDecl(v4);
      }
      else
      {
        if (v42 == 60 && v43 == 63)
        {
          if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 0) & 0x80000000) != 0)
            goto LABEL_274;
          htmlParsePI((uint64_t)v4);
LABEL_240:
          v4->instate = XML_PARSER_CONTENT;
          goto LABEL_78;
        }
        if (v42 == 60 && v43 == 47)
          goto LABEL_91;
        if (v42 == 60)
        {
          if (!(terminate | v43))
            goto LABEL_274;
LABEL_242:
          v45 = 6;
LABEL_92:
          v4->instate = v45;
          v4->checkIndex = 0;
          goto LABEL_78;
        }
        if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 60, 0, 0) & 0x80000000) != 0)
          goto LABEL_274;
        v4->checkIndex = 0;
        if (v4->instate != XML_PARSER_EOF)
        {
          v87 = v21->cur;
          do
          {
            if (v87 >= v21->end)
              break;
            if (v42 == 38)
              htmlParseReference((uint64_t)v4);
            else
              htmlParseCharData((uint64_t)v4);
            if (v4->instate == XML_PARSER_EOF)
              break;
            v87 = v21->cur;
            v42 = *v87;
          }
          while (v42 != 60);
        }
      }
      goto LABEL_78;
    case XML_PARSER_CDATA_SECTION:
      v32 = v4;
      v33 = "HPP: internal error, state == CDATA\n";
      goto LABEL_76;
    case XML_PARSER_END_TAG:
      if ((unint64_t)v26 < 2)
        goto LABEL_274;
      if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 0) & 0x80000000) != 0)
        goto LABEL_302;
      htmlParseEndTag(v4);
      if (v4->nameNr)
        v39 = 7;
      else
        v39 = 14;
      goto LABEL_70;
    case XML_PARSER_ENTITY_DECL:
      v32 = v4;
      v33 = "HPP: internal error, state == ENTITY_DECL\n";
      goto LABEL_76;
    case XML_PARSER_ENTITY_VALUE:
      v32 = v4;
      v33 = "HPP: internal error, state == ENTITY_VALUE\n";
      goto LABEL_76;
    case XML_PARSER_ATTRIBUTE_VALUE:
      htmlParseErr(v4, 1, "HPP: internal error, state == ATTRIBUTE_VALUE\n", 0, 0);
      v39 = 6;
      goto LABEL_70;
    case XML_PARSER_SYSTEM_LITERAL:
      v32 = v4;
      v33 = "HPP: internal error, state == XML_PARSER_SYSTEM_LITERAL\n";
      goto LABEL_76;
    case XML_PARSER_EPILOG:
      if (v21->buf)
      {
        v40 = xmlBufUse(v21->buf->buffer);
        base = v21->base;
        cur = v21->cur;
      }
      else
      {
        v40 = v21->length;
      }
      v26 = (uint64_t)&base[v40 - (_QWORD)cur];
      if (v26 < 1)
        goto LABEL_270;
      v52 = *cur;
      if (v52 <= 0x20 && ((1 << v52) & 0x100002600) != 0)
      {
        htmlParseCharData((uint64_t)v4);
        goto LABEL_274;
      }
      if ((unint64_t)v26 < 2)
        goto LABEL_274;
      v53 = cur[1];
      if (v52 != 60 || v53 != 33)
      {
        if (v52 != 60 || v53 != 63)
          goto LABEL_304;
        if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 0) & 0x80000000) != 0)
          goto LABEL_302;
        htmlParsePI((uint64_t)v4);
        goto LABEL_137;
      }
      if (cur[2] == 45 && cur[3] == 45)
      {
        if (!terminate && (htmlParseLookupCommentEnd((uint64_t)v4) & 0x80000000) != 0)
          goto LABEL_302;
        htmlParseComment((uint64_t)v4);
LABEL_137:
        v4->instate = XML_PARSER_EPILOG;
        goto LABEL_78;
      }
      if ((unint64_t)v26 >= 4)
      {
LABEL_304:
        v4->errNo = 5;
        v4->wellFormed = 0;
        v4->instate = XML_PARSER_EOF;
LABEL_305:
        if (v4->sax)
        {
          v95 = (void (*)(void *))v4->sax->endDocument;
          if (v95)
            v95(v4->userData);
        }
      }
LABEL_274:
      if ((v4->options & 4) == 0)
      {
        myDoc = v4->myDoc;
        if (myDoc)
        {
          if (v22 || (instate = v4->instate, instate == XML_PARSER_EPILOG) || instate == XML_PARSER_EOF)
          {
            if (!xmlGetIntSubset(myDoc))
              v4->myDoc->intSubset = xmlCreateIntSubset(v4->myDoc, (const xmlChar *)"html", (const xmlChar *)"-//W3C//DTD HTML 4.0 Transitional//EN", (const xmlChar *)"http://www.w3.org/TR/REC-html40/loose.dtd");
          }
        }
      }
      if (terminate)
      {
        v90 = v4->instate;
        if (v90 != XML_PARSER_EOF)
        {
          if (v90 != XML_PARSER_MISC && v90 != XML_PARSER_EPILOG)
          {
            v4->errNo = 5;
            v4->wellFormed = 0;
          }
          if (v4->sax)
          {
            v91 = (void (*)(void *))v4->sax->endDocument;
            if (v91)
              v91(v4->userData);
          }
        }
        v4->instate = XML_PARSER_EOF;
      }
      return v4->errNo;
    case XML_PARSER_IGNORE:
      v32 = v4;
      v33 = "HPP: internal error, state == XML_PARSER_IGNORE\n";
      goto LABEL_76;
    case XML_PARSER_PUBLIC_LITERAL:
      v32 = v4;
      v33 = "HPP: internal error, state == XML_PARSER_LITERAL\n";
LABEL_76:
      htmlParseErr(v32, 1, v33, 0, 0);
      v4->instate = XML_PARSER_CONTENT;
      goto LABEL_77;
    default:
      goto LABEL_78;
  }
}

htmlParserCtxtPtr htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax, void *user_data, const char *chunk, int size, const char *filename, xmlCharEncoding enc)
{
  xmlParserInputBufferPtr v12;
  xmlParserInputBufferPtr v13;
  htmlParserCtxtPtr v14;
  xmlParserCtxt *v15;
  xmlSAXHandlerV1 *v16;
  _xmlSAXHandler *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  char *Directory;
  char *v31;
  xmlParserInput *v32;
  xmlChar *v33;
  uint64_t input;
  unint64_t InputBase;
  xmlParserInputPtr v36;
  uint64_t v37;

  xmlInitParser();
  v12 = xmlAllocParserInputBuffer(enc);
  if (!v12)
    return 0;
  v13 = v12;
  v14 = htmlNewParserCtxt();
  v15 = v14;
  if (!v14)
  {
    xmlFreeParserInputBuffer(v13);
    return v15;
  }
  if (enc == XML_CHAR_ENCODING_UTF8 || v13->encoder)
    v14->charset = 1;
  if (sax)
  {
    v16 = (xmlSAXHandlerV1 *)v14->sax;
    if (v16 != __htmlDefaultSAXHandler())
      xmlFree(v15->sax);
    v17 = (_xmlSAXHandler *)xmlMalloc(0x100uLL);
    v15->sax = v17;
    if (!v17)
    {
      xmlFree(v13);
      ((void (*)(xmlParserCtxt *))xmlFree)(v15);
      return 0;
    }
    v18 = *(_OWORD *)&sax->internalSubset;
    v19 = *(_OWORD *)&sax->hasInternalSubset;
    v20 = *(_OWORD *)&sax->entityDecl;
    *(_OWORD *)&v17->resolveEntity = *(_OWORD *)&sax->resolveEntity;
    *(_OWORD *)&v17->entityDecl = v20;
    *(_OWORD *)&v17->internalSubset = v18;
    *(_OWORD *)&v17->hasInternalSubset = v19;
    v21 = *(_OWORD *)&sax->attributeDecl;
    v22 = *(_OWORD *)&sax->unparsedEntityDecl;
    v23 = *(_OWORD *)&sax->startElement;
    *(_OWORD *)&v17->startDocument = *(_OWORD *)&sax->startDocument;
    *(_OWORD *)&v17->startElement = v23;
    *(_OWORD *)&v17->attributeDecl = v21;
    *(_OWORD *)&v17->unparsedEntityDecl = v22;
    v24 = *(_OWORD *)&sax->reference;
    v25 = *(_OWORD *)&sax->ignorableWhitespace;
    v26 = *(_OWORD *)&sax->error;
    *(_OWORD *)&v17->comment = *(_OWORD *)&sax->comment;
    *(_OWORD *)&v17->error = v26;
    *(_OWORD *)&v17->reference = v24;
    *(_OWORD *)&v17->ignorableWhitespace = v25;
    v27 = *(_OWORD *)&sax->getParameterEntity;
    v28 = *(_OWORD *)&sax->externalSubset;
    v29 = *(_OWORD *)&sax->endElementNs;
    *(_OWORD *)&v17->_private = *(_OWORD *)&sax->_private;
    *(_OWORD *)&v17->endElementNs = v29;
    *(_OWORD *)&v17->getParameterEntity = v27;
    *(_OWORD *)&v17->externalSubset = v28;
    if (user_data)
      v15->userData = user_data;
  }
  if (filename)
    Directory = xmlParserGetDirectory(filename);
  else
    Directory = 0;
  v15->directory = Directory;
  v31 = (char *)xmlMalloc(0x68uLL);
  if (!v31)
  {
    htmlErrMemory(v15, (const xmlChar *)"couldn't allocate a new input stream\n");
    xmlFreeParserCtxt(v15);
    ((void (*)(xmlParserInputBufferPtr))xmlFree)(v13);
    return 0;
  }
  v32 = (xmlParserInput *)v31;
  *(_OWORD *)v31 = 0u;
  *((_OWORD *)v31 + 1) = 0u;
  *((_OWORD *)v31 + 2) = 0u;
  *((_OWORD *)v31 + 3) = 0u;
  *((_OWORD *)v31 + 4) = 0u;
  *((_OWORD *)v31 + 5) = 0u;
  *(_OWORD *)(v31 + 8) = 0u;
  *(_OWORD *)(v31 + 24) = 0u;
  *((_DWORD *)v31 + 14) = 1;
  *(_QWORD *)v31 = 0;
  *((_QWORD *)v31 + 11) = 0;
  *((_QWORD *)v31 + 12) = 0;
  *((_QWORD *)v31 + 6) = 0x100000000;
  *((_QWORD *)v31 + 8) = 0;
  *((_QWORD *)v31 + 9) = 0;
  if (filename)
    v33 = xmlCanonicPath((const xmlChar *)filename);
  else
    v33 = 0;
  v32->buf = v13;
  v32->filename = (const char *)v33;
  xmlBufResetInput((uint64_t *)v13->buffer, v32);
  inputPush(v15, v32);
  if (chunk)
  {
    if (size >= 1)
    {
      input = (uint64_t)v15->input;
      if (input)
      {
        if (*(_QWORD *)input)
        {
          InputBase = xmlBufGetInputBase(*(_QWORD *)(*(_QWORD *)input + 32), input);
          v36 = v15->input;
          v37 = v36->cur - v36->base;
          xmlParserInputBufferPush(v36->buf, size, chunk);
          xmlBufSetInputBaseCur((uint64_t *)v15->input->buf->buffer, &v15->input->buf, InputBase, v37);
        }
      }
    }
  }
  v15->progressive = 1;
  return v15;
}

htmlDocPtr htmlSAXParseDoc(const xmlChar *cur, const char *encoding, htmlSAXHandlerPtr sax, void *userData)
{
  xmlParserCtxt *DocParserCtxt;
  xmlParserCtxt *v9;
  _xmlSAXHandler *v10;
  xmlDoc *myDoc;

  xmlInitParser();
  if (!cur)
    return 0;
  DocParserCtxt = htmlCreateDocParserCtxt(cur, (const xmlChar *)encoding);
  if (!DocParserCtxt)
    return 0;
  v9 = DocParserCtxt;
  if (sax)
  {
    v10 = DocParserCtxt->sax;
    if (v9->sax)
      xmlFree(v10);
    v9->sax = sax;
    v9->userData = userData;
    htmlParseDocument(v9);
    myDoc = v9->myDoc;
    v9->sax = 0;
    v9->userData = 0;
  }
  else
  {
    htmlParseDocument(DocParserCtxt);
    myDoc = v9->myDoc;
  }
  xmlFreeParserCtxt(v9);
  return myDoc;
}

xmlParserCtxt *htmlCreateDocParserCtxt(const xmlChar *a1, const xmlChar *a2)
{
  int v4;
  htmlParserCtxtPtr MemoryParserCtxt;
  xmlParserCtxt *v6;
  xmlChar *encoding;
  xmlCharEncoding v8;
  int v9;
  int errNo;
  xmlCharEncodingHandler *CharEncodingHandler;
  int v12;
  const char *v13;
  xmlParserCtxt *v14;

  v4 = xmlStrlen(a1);
  MemoryParserCtxt = htmlCreateMemoryParserCtxt((const char *)a1, v4);
  v6 = MemoryParserCtxt;
  if (!a2 || !MemoryParserCtxt)
    return v6;
  encoding = (xmlChar *)MemoryParserCtxt->input->encoding;
  if (encoding)
    xmlFree(encoding);
  v6->input->encoding = xmlStrdup(a2);
  v8 = xmlParseCharEncoding((const char *)a2);
  if (v8 != XML_CHAR_ENCODING_ERROR)
  {
    v9 = xmlSwitchEncoding(v6, v8);
    errNo = v6->errNo;
    if (errNo != 32)
    {
      if (v9 < 0)
        goto LABEL_12;
      return v6;
    }
LABEL_16:
    v13 = "Unsupported encoding %s\n";
    v14 = v6;
    v12 = 32;
LABEL_17:
    htmlParseErr(v14, v12, v13, a2, 0);
    return v6;
  }
  CharEncodingHandler = xmlFindCharEncodingHandler((const char *)a2);
  if (!CharEncodingHandler)
    goto LABEL_16;
  if (xmlSwitchToEncoding(v6, CharEncodingHandler) < 0)
  {
    errNo = v6->errNo;
LABEL_12:
    if (errNo)
      v12 = errNo;
    else
      v12 = 6003;
    v13 = "htmlCheckEncoding: error switching to encoding '%s'\n";
    v14 = v6;
    goto LABEL_17;
  }
  return v6;
}

htmlDocPtr htmlParseDoc(const xmlChar *cur, const char *encoding)
{
  return htmlSAXParseDoc(cur, encoding, 0, 0);
}

htmlParserCtxtPtr htmlCreateFileParserCtxt(const char *filename, const char *encoding)
{
  xmlParserCtxt *v4;
  xmlChar *v5;
  xmlChar *v6;
  xmlParserInput *ExternalEntity;
  size_t v8;
  size_t v9;
  char *v10;
  xmlChar *v11;
  xmlSAXHandlerV1 *v12;

  if (!filename)
    return 0;
  v4 = htmlNewParserCtxt();
  if (!v4)
    return v4;
  v5 = xmlCanonicPath((const xmlChar *)filename);
  if (!v5)
  {
    if (__xmlDefaultSAXHandler()->error)
    {
      v12 = __xmlDefaultSAXHandler();
      v12->error(0, "out of memory\n");
    }
    goto LABEL_11;
  }
  v6 = v5;
  ExternalEntity = xmlLoadExternalEntity((const char *)v5, 0, v4);
  xmlFree(v6);
  if (!ExternalEntity)
  {
LABEL_11:
    xmlFreeParserCtxt(v4);
    return 0;
  }
  inputPush(v4, ExternalEntity);
  if (encoding)
  {
    v8 = strlen(encoding);
    if (v8 <= 0x3E7)
    {
      v9 = v8 + xmlStrlen((const xmlChar *)"charset=") + 1;
      v10 = (char *)xmlMallocAtomic(v9);
      if (v10)
      {
        v11 = (xmlChar *)v10;
        snprintf(v10, v9, "%s%s", "charset=", encoding);
        htmlCheckEncoding((uint64_t)v4, v11);
        xmlFree(v11);
      }
    }
  }
  return v4;
}

const xmlChar *htmlCheckEncoding(uint64_t a1, xmlChar *str)
{
  const xmlChar *result;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;

  result = xmlStrcasestr(str, (const xmlChar *)"charset");
  if (result)
  {
    v6 = result[7];
    result += 7;
    v5 = v6;
    v7 = (1 << v6) & 0x100002600;
    if (v6 <= 0x20 && v7 != 0)
    {
      result = xmlStrcasestr(str, (const xmlChar *)"=");
      if (!result)
        return result;
      v5 = *result;
    }
    if (v5 == 61)
      return (const xmlChar *)htmlCheckEncodingDirect(a1, (xmlChar *)result + 1);
  }
  return result;
}

htmlDocPtr htmlSAXParseFile(const char *filename, const char *encoding, htmlSAXHandlerPtr sax, void *userData)
{
  htmlParserCtxtPtr FileParserCtxt;
  xmlParserCtxt *v9;
  _xmlSAXHandler *v10;
  xmlDoc *myDoc;

  xmlInitParser();
  FileParserCtxt = htmlCreateFileParserCtxt(filename, encoding);
  if (!FileParserCtxt)
    return 0;
  v9 = FileParserCtxt;
  if (sax)
  {
    v10 = FileParserCtxt->sax;
    FileParserCtxt->sax = sax;
    FileParserCtxt->userData = userData;
    htmlParseDocument(FileParserCtxt);
    myDoc = v9->myDoc;
    v9->sax = v10;
    v9->userData = 0;
  }
  else
  {
    htmlParseDocument(FileParserCtxt);
    myDoc = v9->myDoc;
  }
  xmlFreeParserCtxt(v9);
  return myDoc;
}

htmlDocPtr htmlParseFile(const char *filename, const char *encoding)
{
  return htmlSAXParseFile(filename, encoding, 0, 0);
}

int htmlHandleOmittedElem(int val)
{
  int v1;

  v1 = htmlOmittedDefaultValue;
  htmlOmittedDefaultValue = val;
  return v1;
}

int htmlElementAllowedHere(const htmlElemDesc *a1, const xmlChar *a2)
{
  const htmlElemDesc *v2;
  const htmlElemDesc **subelts;
  const htmlElemDesc **v5;
  const htmlElemDesc *v6;

  v2 = a1;
  LODWORD(a1) = 0;
  if (v2 && a2)
  {
    subelts = (const htmlElemDesc **)v2->subelts;
    if (subelts)
    {
      a1 = *subelts;
      if (*subelts)
      {
        v5 = subelts + 1;
        while (xmlStrcmp((const xmlChar *)a1, a2))
        {
          v6 = *v5++;
          a1 = v6;
          if (!v6)
            return (int)a1;
        }
        LODWORD(a1) = 1;
      }
    }
    else
    {
      LODWORD(a1) = 0;
    }
  }
  return (int)a1;
}

htmlStatus htmlElementStatusHere(const htmlElemDesc *a1, const htmlElemDesc *a2)
{
  htmlStatus result;

  result = HTML_INVALID;
  if (a1 && a2)
  {
    if (htmlElementAllowedHere(a1, (const xmlChar *)a2->name))
    {
      if (a2->dtd)
        return 2;
      else
        return 4;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

htmlStatus htmlAttrAllowed(const htmlElemDesc *a1, const xmlChar *a2, int a3)
{
  htmlStatus result;
  const char **attrs_req;
  const xmlChar *v8;
  const xmlChar **v9;
  const xmlChar *v10;
  const char **attrs_opt;
  const xmlChar *v12;
  const xmlChar **v13;
  const xmlChar *v14;
  const char **attrs_depr;
  const xmlChar *v16;
  const xmlChar **v17;
  const xmlChar *v18;

  result = HTML_INVALID;
  if (a1 && a2)
  {
    attrs_req = a1->attrs_req;
    if (attrs_req && (v8 = (const xmlChar *)*attrs_req) != 0)
    {
      v9 = (const xmlChar **)(attrs_req + 1);
      while (xmlStrcmp(v8, a2))
      {
        v10 = *v9++;
        v8 = v10;
        if (!v10)
          goto LABEL_8;
      }
      return 12;
    }
    else
    {
LABEL_8:
      attrs_opt = a1->attrs_opt;
      if (attrs_opt && (v12 = (const xmlChar *)*attrs_opt) != 0)
      {
        v13 = (const xmlChar **)(attrs_opt + 1);
        while (xmlStrcmp(v12, a2))
        {
          v14 = *v13++;
          v12 = v14;
          if (!v14)
            goto LABEL_13;
        }
        return 4;
      }
      else
      {
LABEL_13:
        if (a3 && (attrs_depr = a1->attrs_depr) != 0 && (v16 = (const xmlChar *)*attrs_depr) != 0)
        {
          v17 = (const xmlChar **)(attrs_depr + 1);
          while (xmlStrcmp(v16, a2))
          {
            v18 = *v17++;
            v16 = v18;
            if (!v18)
              return 1;
          }
          return 2;
        }
        else
        {
          return 1;
        }
      }
    }
  }
  return result;
}

htmlStatus htmlNodeStatus(const htmlNodePtr a1, int a2)
{
  xmlElementType type;
  const htmlElemDesc *v5;
  const htmlElemDesc *name;
  const htmlElemDesc *v8;
  const xmlChar *v9;
  const htmlElemDesc *v10;

  if (!a1)
    return 1;
  type = a1->type;
  if (type == XML_ATTRIBUTE_NODE)
  {
    name = (const htmlElemDesc *)a1->parent->name;
    if (name)
      name = (const htmlElemDesc *)bsearch(name, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
    return htmlAttrAllowed(name, a1->name, a2);
  }
  else if (type == XML_ELEMENT_NODE)
  {
    v5 = (const htmlElemDesc *)a1->parent->name;
    if (a2)
    {
      if (v5)
        v5 = (const htmlElemDesc *)bsearch(v5, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      if (htmlElementAllowedHere(v5, a1->name))
        return 4;
      else
        return 1;
    }
    else
    {
      if (v5)
        v8 = (const htmlElemDesc *)bsearch(v5, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      else
        v8 = 0;
      v9 = a1->name;
      if (v9)
        v10 = (const htmlElemDesc *)bsearch(v9, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      else
        v10 = 0;
      return htmlElementStatusHere(v8, v10);
    }
  }
  else
  {
    return 0;
  }
}

void htmlCtxtReset(htmlParserCtxtPtr ctxt)
{
  xmlDict *dict;
  xmlParserInput *v3;
  int *spaceTab;
  xmlChar *version;
  xmlChar *encoding;
  char *directory;
  xmlChar *extSubURI;
  xmlChar *extSubSystem;
  xmlDoc *myDoc;
  xmlHashTable *attsDefault;
  xmlHashTable *attsSpecial;

  if (!ctxt)
    return;
  xmlInitParser();
  dict = ctxt->dict;
  while (1)
  {
    v3 = inputPop(ctxt);
    if (!v3)
      break;
    xmlFreeInputStream(v3);
  }
  ctxt->inputNr = 0;
  ctxt->input = 0;
  ctxt->spaceNr = 0;
  spaceTab = ctxt->spaceTab;
  if (spaceTab)
    *spaceTab = -1;
  ctxt->space = spaceTab;
  ctxt->nodeNr = 0;
  ctxt->node = 0;
  ctxt->nameNr = 0;
  ctxt->name = 0;
  ctxt->nsNr = 0;
  version = (xmlChar *)ctxt->version;
  if (version)
  {
    if (dict)
    {
      if (xmlDictOwns(dict, version))
        goto LABEL_12;
      version = (xmlChar *)ctxt->version;
    }
    xmlFree(version);
  }
LABEL_12:
  ctxt->version = 0;
  encoding = (xmlChar *)ctxt->encoding;
  if (!encoding)
    goto LABEL_17;
  if (dict)
  {
    if (xmlDictOwns(dict, encoding))
      goto LABEL_17;
    encoding = (xmlChar *)ctxt->encoding;
  }
  xmlFree(encoding);
LABEL_17:
  ctxt->encoding = 0;
  directory = ctxt->directory;
  if (!directory)
    goto LABEL_22;
  if (dict)
  {
    if (xmlDictOwns(dict, (const xmlChar *)directory))
      goto LABEL_22;
    directory = ctxt->directory;
  }
  xmlFree(directory);
LABEL_22:
  ctxt->directory = 0;
  extSubURI = ctxt->extSubURI;
  if (!extSubURI)
    goto LABEL_27;
  if (dict)
  {
    if (xmlDictOwns(dict, extSubURI))
      goto LABEL_27;
    extSubURI = ctxt->extSubURI;
  }
  xmlFree(extSubURI);
LABEL_27:
  ctxt->extSubURI = 0;
  extSubSystem = ctxt->extSubSystem;
  if (extSubSystem)
  {
    if (!dict)
    {
LABEL_31:
      xmlFree(extSubSystem);
      goto LABEL_32;
    }
    if (!xmlDictOwns(dict, extSubSystem))
    {
      extSubSystem = ctxt->extSubSystem;
      goto LABEL_31;
    }
  }
LABEL_32:
  ctxt->extSubSystem = 0;
  myDoc = ctxt->myDoc;
  if (myDoc)
    xmlFreeDoc(myDoc);
  ctxt->myDoc = 0;
  *(_QWORD *)&ctxt->standalone = 0x1FFFFFFFFLL;
  *(_QWORD *)&ctxt->instate = 0;
  ctxt->wellFormed = 1;
  ctxt->nsWellFormed = 1;
  *(_QWORD *)&ctxt->disableSAX = 0;
  ctxt->valid = 1;
  ctxt->vctxt.finishDtd = -1412623820;
  ctxt->vctxt.userData = ctxt;
  ctxt->vctxt.error = xmlParserValidityError;
  ctxt->vctxt.warning = xmlParserValidityWarning;
  ctxt->record_info = 0;
  ctxt->checkIndex = 0;
  *(_QWORD *)&ctxt->errNo = 0;
  *(_QWORD *)&ctxt->hasPErefs = 0;
  ctxt->depth = 0;
  ctxt->charset = 0;
  ctxt->catalogs = 0;
  xmlInitNodeInfoSeq(&ctxt->node_seq);
  attsDefault = ctxt->attsDefault;
  if (attsDefault)
  {
    xmlHashFree(attsDefault, xmlHashDefaultDeallocator);
    ctxt->attsDefault = 0;
  }
  attsSpecial = ctxt->attsSpecial;
  if (attsSpecial)
  {
    xmlHashFree(attsSpecial, 0);
    ctxt->attsSpecial = 0;
  }
}

htmlDocPtr htmlReadDoc(const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  int v8;
  xmlParserCtxt *MemoryParserCtxt;

  if (cur
    && (xmlInitParser(),
        v8 = xmlStrlen(cur),
        (MemoryParserCtxt = htmlCreateMemoryParserCtxt((const char *)cur, v8)) != 0))
  {
    return htmlDoRead(MemoryParserCtxt, (const xmlChar *)URL, encoding, options, 0);
  }
  else
  {
    return 0;
  }
}

xmlDocPtr htmlDoRead(xmlParserCtxt *a1, const xmlChar *a2, const char *a3, int options, int a5)
{
  xmlCharEncodingHandler *CharEncodingHandler;
  xmlChar *encoding;
  xmlParserInputPtr input;
  int errNo;
  xmlDocPtr myDoc;

  htmlCtxtUseOptions(a1, options);
  a1->html = 1;
  if (a3)
  {
    CharEncodingHandler = xmlFindCharEncodingHandler(a3);
    if (CharEncodingHandler)
    {
      if (xmlSwitchToEncoding(a1, CharEncodingHandler) < 0)
      {
        if (a1->errNo)
          errNo = a1->errNo;
        else
          errNo = 6003;
        htmlParseErr(a1, errNo, "htmlCheckEncoding: error switching to encoding '%s'\n", (const xmlChar *)a3, 0);
        if (!a2)
          goto LABEL_15;
        goto LABEL_8;
      }
      encoding = (xmlChar *)a1->input->encoding;
      if (encoding)
        xmlFree(encoding);
      a1->input->encoding = xmlStrdup((const xmlChar *)a3);
    }
  }
  if (!a2)
    goto LABEL_15;
LABEL_8:
  input = a1->input;
  if (input && !input->filename)
    a1->input->filename = (const char *)xmlStrdup(a2);
LABEL_15:
  htmlParseDocument(a1);
  myDoc = a1->myDoc;
  a1->myDoc = 0;
  if (!a5)
  {
    if (a1->dictNames && myDoc && myDoc->dict == a1->dict)
      a1->dict = 0;
    xmlFreeParserCtxt(a1);
  }
  return myDoc;
}

htmlDocPtr htmlReadFile(const char *URL, const char *encoding, int options)
{
  htmlDocPtr result;

  xmlInitParser();
  result = (htmlDocPtr)htmlCreateFileParserCtxt(URL, encoding);
  if (result)
    return htmlDoRead((xmlParserCtxt *)result, 0, 0, options, 0);
  return result;
}

htmlDocPtr htmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  htmlDocPtr result;
  xmlParserCtxt *v11;
  _xmlSAXHandler *sax;
  xmlSAXHandlerV1 *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;

  xmlInitParser();
  result = (htmlDocPtr)xmlCreateMemoryParserCtxt(buffer, size);
  if (result)
  {
    v11 = (xmlParserCtxt *)result;
    htmlDefaultSAXHandlerInit();
    sax = v11->sax;
    if (v11->sax)
    {
      v13 = __htmlDefaultSAXHandler();
      v14 = *(_OWORD *)&v13->hasInternalSubset;
      *(_OWORD *)&sax->internalSubset = *(_OWORD *)&v13->internalSubset;
      *(_OWORD *)&sax->hasInternalSubset = v14;
      v15 = *(_OWORD *)&v13->unparsedEntityDecl;
      v17 = *(_OWORD *)&v13->resolveEntity;
      v16 = *(_OWORD *)&v13->entityDecl;
      *(_OWORD *)&sax->attributeDecl = *(_OWORD *)&v13->attributeDecl;
      *(_OWORD *)&sax->unparsedEntityDecl = v15;
      *(_OWORD *)&sax->resolveEntity = v17;
      *(_OWORD *)&sax->entityDecl = v16;
      v18 = *(_OWORD *)&v13->ignorableWhitespace;
      v20 = *(_OWORD *)&v13->startDocument;
      v19 = *(_OWORD *)&v13->startElement;
      *(_OWORD *)&sax->reference = *(_OWORD *)&v13->reference;
      *(_OWORD *)&sax->ignorableWhitespace = v18;
      *(_OWORD *)&sax->startDocument = v20;
      *(_OWORD *)&sax->startElement = v19;
      v21 = *(_OWORD *)&v13->externalSubset;
      v23 = *(_OWORD *)&v13->comment;
      v22 = *(_OWORD *)&v13->error;
      *(_OWORD *)&sax->getParameterEntity = *(_OWORD *)&v13->getParameterEntity;
      *(_OWORD *)&sax->externalSubset = v21;
      *(_OWORD *)&sax->comment = v23;
      *(_OWORD *)&sax->error = v22;
    }
    return htmlDoRead(v11, (const xmlChar *)URL, encoding, options, 0);
  }
  return result;
}

htmlDocPtr htmlReadFd(int fd, const char *URL, const char *encoding, int options)
{
  xmlParserInputBufferPtr v8;
  xmlParserInputBuffer *v9;
  xmlParserCtxt *v10;
  xmlParserCtxt *v11;
  xmlParserInput *v12;

  if ((fd & 0x80000000) == 0)
  {
    xmlInitParser();
    v8 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
    if (v8)
    {
      v9 = v8;
      v8->closecallback = 0;
      v10 = htmlNewParserCtxt();
      if (v10)
      {
        v11 = v10;
        v12 = xmlNewIOInputStream(v10, v9, XML_CHAR_ENCODING_NONE);
        if (v12)
        {
          inputPush(v11, v12);
          return htmlDoRead(v11, (const xmlChar *)URL, encoding, options, 0);
        }
        xmlFreeParserInputBuffer(v9);
        xmlFreeParserCtxt(v11);
      }
      else
      {
        xmlFreeParserInputBuffer(v9);
      }
    }
  }
  return 0;
}

htmlDocPtr htmlReadIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  xmlParserInputBufferPtr IO;
  xmlParserInputBuffer *v13;
  xmlParserCtxt *v14;
  xmlParserCtxt *v15;
  xmlParserInput *v16;

  if (ioread)
  {
    xmlInitParser();
    IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
    if (IO)
    {
      v13 = IO;
      v14 = htmlNewParserCtxt();
      if (v14)
      {
        v15 = v14;
        v16 = xmlNewIOInputStream(v14, v13, XML_CHAR_ENCODING_NONE);
        if (v16)
        {
          inputPush(v15, v16);
          return htmlDoRead(v15, (const xmlChar *)URL, encoding, options, 0);
        }
        xmlFreeParserInputBuffer(v13);
        xmlFreeParserCtxt(v15);
      }
      else
      {
        xmlFreeParserInputBuffer(v13);
      }
    }
    else if (ioclose)
    {
      ((void (*)(void *))ioclose)(ioctx);
    }
  }
  return 0;
}

htmlDocPtr htmlCtxtReadDoc(xmlParserCtxtPtr ctxt, const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  xmlParserInput *v10;

  if (!ctxt)
    return 0;
  if (!cur)
    return 0;
  xmlInitParser();
  htmlCtxtReset(ctxt);
  v10 = xmlNewStringInputStream(ctxt, cur);
  if (!v10)
    return 0;
  inputPush(ctxt, v10);
  return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
}

htmlDocPtr htmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename, const char *encoding, int options)
{
  xmlParserInput *ExternalEntity;

  if (!ctxt)
    return 0;
  if (!filename)
    return 0;
  xmlInitParser();
  htmlCtxtReset(ctxt);
  ExternalEntity = xmlLoadExternalEntity(filename, 0, ctxt);
  if (!ExternalEntity)
    return 0;
  inputPush(ctxt, ExternalEntity);
  return htmlDoRead(ctxt, 0, encoding, options, 1);
}

htmlDocPtr htmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  xmlParserInputBuffer *Mem;
  xmlParserInputBuffer *v13;
  xmlParserInput *v14;

  if (ctxt)
  {
    if (buffer)
    {
      xmlInitParser();
      htmlCtxtReset(ctxt);
      Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
      if (Mem)
      {
        v13 = Mem;
        v14 = xmlNewIOInputStream(ctxt, Mem, XML_CHAR_ENCODING_NONE);
        if (v14)
        {
          inputPush(ctxt, v14);
          return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
        }
        xmlFreeParserInputBuffer(v13);
      }
    }
  }
  return 0;
}

htmlDocPtr htmlCtxtReadFd(xmlParserCtxtPtr ctxt, int fd, const char *URL, const char *encoding, int options)
{
  xmlParserInputBuffer *v10;
  xmlParserInputBuffer *v11;
  xmlParserInput *v12;

  if (ctxt)
  {
    if ((fd & 0x80000000) == 0)
    {
      xmlInitParser();
      htmlCtxtReset(ctxt);
      v10 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
      if (v10)
      {
        v11 = v10;
        v12 = xmlNewIOInputStream(ctxt, v10, XML_CHAR_ENCODING_NONE);
        if (v12)
        {
          inputPush(ctxt, v12);
          return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
        }
        xmlFreeParserInputBuffer(v11);
      }
    }
  }
  return 0;
}

htmlDocPtr htmlCtxtReadIO(xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  xmlParserInputBuffer *IO;
  xmlParserInputBuffer *v15;
  xmlParserInput *v16;

  if (ctxt && ioread)
  {
    xmlInitParser();
    htmlCtxtReset(ctxt);
    IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
    if (IO)
    {
      v15 = IO;
      v16 = xmlNewIOInputStream(ctxt, IO, XML_CHAR_ENCODING_NONE);
      if (v16)
      {
        inputPush(ctxt, v16);
        return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
      }
      xmlFreeParserInputBuffer(v15);
    }
    else if (ioclose)
    {
      ((void (*)(void *))ioclose)(ioctx);
    }
  }
  return 0;
}

xmlChar *htmlParseHTMLAttribute(uint64_t a1, int a2)
{
  xmlChar *v4;
  xmlChar *v5;
  unsigned __int8 *v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  xmlChar *v10;
  unsigned int v11;
  char v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  BOOL v16;
  const htmlEntityDesc *v17;
  const htmlEntityDesc *v18;
  xmlChar *v19;
  unsigned int value;
  char v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  xmlChar *v25;
  unsigned int v26;
  char v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  xmlChar *v31;
  xmlChar v32;
  xmlChar *v33;
  xmlChar *v34;
  int v35;
  BOOL v36;
  int v38;
  xmlChar *str;

  str = 0;
  v4 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (v4)
  {
    v5 = v4;
    v6 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
    v7 = *v6;
    if (*v6)
      v8 = v7 == a2;
    else
      v8 = 1;
    if (!v8)
    {
      v9 = 100;
      v10 = v4;
      while (1)
      {
        if (!a2 && v7 == 62)
          goto LABEL_8;
        if (a2)
        {
          if (v7 != 38)
            goto LABEL_51;
        }
        else
        {
          if (v7 > 0x26)
            goto LABEL_51;
          if (v7 != 38)
          {
            if (((1 << v7) & 0x100002600) != 0)
              goto LABEL_8;
LABEL_51:
            v38 = 0;
            if (v5 - v10 > v9 - 100)
            {
              v9 *= 2;
              v25 = (xmlChar *)xmlRealloc(v10, v9);
              if (!v25)
                goto LABEL_88;
              v5 = &v25[(int)v5 - (int)v10];
              v10 = v25;
            }
            v26 = htmlCurrentChar(a1, &v38);
            if (*(_DWORD *)(a1 + 272) == -1)
              goto LABEL_89;
            if (v26 < 0x80)
            {
              *v5++ = v26;
            }
            else
            {
              if (HIWORD(v26))
                v27 = (v26 >> 18) & 7 | 0xF0;
              else
                v27 = (v26 >> 12) | 0xE0;
              if (HIWORD(v26))
                v28 = 12;
              else
                v28 = 6;
              v29 = (v26 >> 6) | 0xFFFFFFC0;
              if (v26 <= 0x7FF)
              {
                v30 = 0;
              }
              else
              {
                LOBYTE(v29) = v27;
                v30 = v28;
              }
              *v5++ = v29;
              do
              {
                *v5++ = (v26 >> v30) & 0x3F | 0x80;
                v16 = v30 > 5;
                v30 -= 6;
              }
              while (v16);
            }
            xmlNextChar((xmlParserCtxtPtr)a1);
            goto LABEL_82;
          }
        }
        if (v6[1] == 35)
        {
          v11 = htmlParseCharRef((htmlParserCtxtPtr)a1);
          if (v11 < 0x80)
          {
            *v5++ = v11;
          }
          else
          {
            if (HIWORD(v11))
              v12 = (v11 >> 18) & 7 | 0xF0;
            else
              v12 = (v11 >> 12) | 0xE0;
            if (HIWORD(v11))
              v13 = 12;
            else
              v13 = 6;
            v14 = (v11 >> 6) | 0xFFFFFFC0;
            if (v11 <= 0x7FF)
            {
              v15 = 0;
            }
            else
            {
              LOBYTE(v14) = v12;
              v15 = v13;
            }
            *v5++ = v14;
            do
            {
              *v5++ = (v11 >> v15) & 0x3F | 0x80;
              v16 = v15 > 5;
              v15 -= 6;
            }
            while (v16);
          }
        }
        else
        {
          v17 = htmlParseEntityRef((htmlParserCtxtPtr)a1, (const xmlChar **)&str);
          if (str)
          {
            v18 = v17;
            if (v17)
            {
              if (v5 - v10 > v9 - 100)
              {
                v9 *= 2;
                v19 = (xmlChar *)xmlRealloc(v10, v9);
                if (!v19)
                  goto LABEL_88;
                v5 = &v19[(int)v5 - (int)v10];
                v10 = v19;
              }
              value = v18->value;
              if (v18->value < 0x80)
              {
                *v5++ = value;
              }
              else
              {
                if (HIWORD(value))
                  v21 = (value >> 18) & 7 | 0xF0;
                else
                  v21 = (value >> 12) | 0xE0;
                if (HIWORD(value))
                  v22 = 12;
                else
                  v22 = 6;
                v23 = (value >> 6) | 0xFFFFFFC0;
                if (value <= 0x7FF)
                {
                  v24 = 0;
                }
                else
                {
                  LOBYTE(v23) = v21;
                  v24 = v22;
                }
                *v5++ = v23;
                do
                {
                  *v5++ = (value >> v24) & 0x3F | 0x80;
                  v16 = v24 > 5;
                  v24 -= 6;
                }
                while (v16);
              }
            }
            else
            {
              *v5++ = 38;
              v32 = *str;
              if (*str)
              {
                v33 = str + 1;
                do
                {
                  if (v5 - v10 > v9 - 100)
                  {
                    v9 *= 2;
                    v34 = (xmlChar *)xmlRealloc(v10, v9);
                    if (!v34)
                      goto LABEL_88;
                    v5 = &v34[(int)v5 - (int)v10];
                    v32 = *(v33 - 1);
                    v10 = v34;
                  }
                  *v5++ = v32;
                  v35 = *v33++;
                  v32 = v35;
                }
                while (v35);
              }
            }
            goto LABEL_82;
          }
          *v5++ = 38;
        }
        if (v5 - v10 > v9 - 100)
        {
          v9 *= 2;
          v31 = (xmlChar *)xmlRealloc(v10, v9);
          if (!v31)
          {
LABEL_88:
            htmlErrMemory((_DWORD *)a1, (const xmlChar *)"growing buffer\n");
LABEL_89:
            xmlFree(v10);
            return 0;
          }
          v5 = &v31[(int)v5 - (int)v10];
          v10 = v31;
        }
LABEL_82:
        v6 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
        v7 = *v6;
        if (*v6)
          v36 = v7 == a2;
        else
          v36 = 1;
        if (v36)
          goto LABEL_8;
      }
    }
    v10 = v4;
LABEL_8:
    *v5 = 0;
  }
  else
  {
    htmlErrMemory((_DWORD *)a1, (const xmlChar *)"buffer allocation failed\n");
    return 0;
  }
  return v10;
}

uint64_t htmlCheckEncodingDirect(uint64_t result, xmlChar *cur)
{
  uint64_t v2;
  const xmlChar *i;
  int v4;
  xmlCharEncoding v6;
  uint64_t v7;
  const char *v8;
  _DWORD *v9;
  int v10;
  const xmlChar *v11;
  xmlCharEncodingHandler *CharEncodingHandler;
  _QWORD *v13;
  _QWORD *v14;
  int v15;

  if (!cur)
    return result;
  v2 = result;
  if ((*(_BYTE *)(result + 566) & 0x20) != 0 || *(_QWORD *)(*(_QWORD *)(result + 56) + 80))
    return result;
  for (i = cur; ; ++i)
  {
    v4 = *i;
    if (v4 != 32 && v4 != 9)
      break;
  }
  *(_QWORD *)(*(_QWORD *)(result + 56) + 80) = xmlStrdup(i);
  v6 = xmlParseCharEncoding((const char *)i);
  if ((v6 - 2) >= 4)
  {
    if (v6 == XML_CHAR_ENCODING_ERROR)
    {
      CharEncodingHandler = xmlFindCharEncodingHandler((const char *)i);
      if (!CharEncodingHandler)
      {
        result = (uint64_t)htmlParseErr((_DWORD *)v2, 32, "htmlCheckEncoding: unknown encoding %s\n", i, 0);
        goto LABEL_27;
      }
      result = xmlSwitchToEncoding((xmlParserCtxtPtr)v2, CharEncodingHandler);
      if ((result & 0x80000000) != 0)
        goto LABEL_21;
      goto LABEL_26;
    }
  }
  else
  {
    v7 = **(_QWORD **)(v2 + 56);
    if (v7 && !*(_QWORD *)(v7 + 24))
    {
      v8 = "htmlCheckEncoding: wrong encoding meta\n";
      v9 = (_DWORD *)v2;
      v10 = 81;
      v11 = 0;
LABEL_25:
      result = (uint64_t)htmlParseErr(v9, v10, v8, v11, 0);
      goto LABEL_26;
    }
  }
  result = xmlSwitchEncoding((xmlParserCtxtPtr)v2, v6);
  if ((result & 0x80000000) != 0)
  {
LABEL_21:
    if (*(_DWORD *)(v2 + 136))
      v10 = *(_DWORD *)(v2 + 136);
    else
      v10 = 6003;
    v8 = "htmlCheckEncoding: error switching to encoding '%s'\n";
    v9 = (_DWORD *)v2;
    v11 = i;
    goto LABEL_25;
  }
LABEL_26:
  *(_DWORD *)(v2 + 408) = 1;
LABEL_27:
  v13 = *(_QWORD **)(v2 + 56);
  v14 = (_QWORD *)*v13;
  if (*v13)
  {
    if (v14[3])
    {
      if (v14[5])
      {
        result = v14[4];
        if (result)
        {
          xmlBufShrink((xmlBufPtr)result, v13[4] - v13[3]);
          v15 = xmlCharEncInput(**(_QWORD **)(v2 + 56), 1);
          result = xmlBufResetInput(*(uint64_t **)(**(_QWORD **)(v2 + 56) + 32), *(_QWORD **)(v2 + 56));
          if (v15 < 0)
            return (uint64_t)htmlParseErr((_DWORD *)v2, 81, "htmlCheckEncoding: encoder error\n", 0, 0);
        }
      }
    }
  }
  return result;
}

xmlChar *htmlParseEndTag(xmlParserCtxt *a1)
{
  xmlParserCtxt *v1;
  xmlParserInputPtr input;
  const xmlChar *cur;
  xmlChar *result;
  xmlChar *v5;
  const char *v6;
  int v7;
  const xmlChar *v8;
  uint64_t nameNr;
  uint64_t v10;
  int v11;
  int EndPriority;
  uint64_t v13;
  int v14;
  const xmlChar *name;
  _BYTE *v16;
  void (*endElement)(void *, const xmlChar *);
  int v18;
  unsigned int v19;
  const xmlChar **nameTab;
  const xmlChar *v21;
  void (*v22)(void *, xmlChar *);
  int nodeInfoNr;
  int v24;
  BOOL v25;
  int v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  const xmlChar **v30;
  const xmlChar *v31;

  v1 = a1;
  input = a1->input;
  cur = input->cur;
  if (*cur == 60 && cur[1] == 47)
  {
    input->cur = cur + 2;
    input->col += 2;
    result = (xmlChar *)htmlParseHTMLName(a1);
    if (result)
    {
      v5 = result;
      htmlSkipBlankChars((uint64_t)v1);
      if (*v1->input->cur == 62)
      {
LABEL_5:
        xmlNextChar(v1);
      }
      else
      {
        htmlParseErr(v1, 73, "End tag : expected '>'\n", 0, 0);
        while (*v1->input->cur)
        {
          if (*v1->input->cur == 62)
            goto LABEL_5;
          xmlNextChar(v1);
        }
      }
      if (v1->depth >= 1
        && (xmlStrEqual(v5, (const xmlChar *)"html")
         || xmlStrEqual(v5, (const xmlChar *)"body")
         || xmlStrEqual(v5, (const xmlChar *)"head")))
      {
        result = 0;
        --v1->depth;
      }
      else
      {
        nameNr = v1->nameNr;
        do
        {
          if ((int)nameNr < 1)
          {
            v6 = "Unexpected end tag : %s\n";
            a1 = v1;
            v7 = 76;
            v8 = v5;
            goto LABEL_12;
          }
          v10 = nameNr - 1;
          v11 = xmlStrEqual(v5, v1->nameTab[nameNr - 1]);
          nameNr = v10;
        }
        while (!v11);
        EndPriority = htmlGetEndPriority(v5);
        v13 = v1->nameNr - 1;
        while ((int)v13 + 1 >= 1)
        {
          if (xmlStrEqual(v5, v1->nameTab[v13]))
          {
            while (!xmlStrEqual(v5, v1->name))
            {
              name = v1->name;
              if (name)
              {
                v16 = bsearch(name, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
                if (v16)
                {
                  if (v16[9] == 3)
                    htmlParseErr(v1, 76, "Opening and ending tag mismatch: %s and %s\n", v5, (xmlChar *)v1->name);
                }
              }
              if (v1->sax)
              {
                endElement = (void (*)(void *, const xmlChar *))v1->sax->endElement;
                if (endElement)
                  endElement(v1->userData, v1->name);
              }
              v18 = v1->nameNr;
              v19 = v18 - 1;
              if (v18 >= 1)
              {
                v1->nameNr = v19;
                nameTab = v1->nameTab;
                if (v18 == 1)
                  v21 = 0;
                else
                  v21 = nameTab[v18 - 2];
                v1->name = v21;
                nameTab[v19] = 0;
              }
            }
            break;
          }
          v14 = htmlGetEndPriority((xmlChar *)v1->nameTab[v13--]);
          if (v14 > EndPriority)
            break;
        }
        result = (xmlChar *)v1->name;
        if (result)
        {
          if (!xmlStrEqual(result, v5))
            htmlParseErr(v1, 76, "Opening and ending tag mismatch: %s and %s\n", v5, (xmlChar *)v1->name);
          result = (xmlChar *)v1->name;
          if (result)
          {
            result = (xmlChar *)xmlStrEqual(result, v5);
            if ((_DWORD)result)
            {
              if (v1->sax)
              {
                v22 = (void (*)(void *, xmlChar *))v1->sax->endElement;
                if (v22)
                  v22(v1->userData, v5);
              }
              nodeInfoNr = v1->nodeInfoNr;
              if (nodeInfoNr >= 1)
              {
                v24 = nodeInfoNr - 2;
                v26 = nodeInfoNr - 1;
                v25 = v26 == 0;
                v1->nodeInfoNr = v26;
                v27 = (uint64_t)&v1->nodeInfoTab[v24];
                if (v25)
                  v27 = 0;
                v1->nodeInfo = (xmlParserNodeInfo *)v27;
              }
              v28 = v1->nameNr;
              v29 = v28 - 1;
              if (v28 >= 1)
              {
                v1->nameNr = v29;
                v30 = v1->nameTab;
                if (v28 == 1)
                  v31 = 0;
                else
                  v31 = v30[v28 - 2];
                v1->name = v31;
                v30[v29] = 0;
              }
              return (xmlChar *)1;
            }
          }
        }
      }
    }
  }
  else
  {
    v6 = "htmlParseEndTag: '</' not found\n";
    v7 = 74;
    v8 = 0;
LABEL_12:
    htmlParseErr(a1, v7, v6, v8, 0);
    return 0;
  }
  return result;
}

uint64_t htmlParseScript(uint64_t a1)
{
  xmlParserInput *v2;
  const xmlChar *cur;
  uint64_t result;
  int v5;
  uint64_t v6;
  uint64_t v7;
  const xmlChar *v8;
  const xmlChar *v9;
  int v10;
  int v11;
  uint64_t v12;
  _BYTE *v13;
  _BYTE *v14;
  void (*v15)(_QWORD, xmlChar *, uint64_t);
  xmlParserInput *v16;
  uint64_t v17;
  uint64_t (*v18)(_QWORD, xmlChar *, uint64_t);
  int len;
  xmlChar v20[1005];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  bzero(v20, 0x3EDuLL);
  v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (cur - v2->base >= 501 && v2->end - cur <= 499)
    xmlParserInputShrink(v2);
  len = 0;
  result = htmlCurrentChar(a1, &len);
  v5 = result;
  v6 = 0;
  while (1)
  {
    if (v5 != 60)
    {
      if (!v5)
        break;
      if (v5 > 255)
      {
        if ((v5 - 0x10000) >= 0x100000
          && v5 >> 11 >= 0x1B
          && (v5 - 57344) >> 1 > 0xFFE)
        {
LABEL_19:
          htmlParseErrInt((_DWORD *)a1, "Invalid char in CDATA 0x%X\n", v5);
          v11 = len;
          goto LABEL_24;
        }
      }
      else if (v5 <= 31 && (v5 > 0xD || ((1 << v5) & 0x2600) == 0))
      {
        goto LABEL_19;
      }
      goto LABEL_21;
    }
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32);
    if (*(_BYTE *)(v7 + 1) == 47)
    {
      if (*(_DWORD *)(a1 + 448))
      {
        v8 = *(const xmlChar **)(a1 + 288);
        v9 = (const xmlChar *)(v7 + 2);
        v10 = xmlStrlen(v8);
        result = xmlStrncasecmp(v8, v9, v10);
        if (!(_DWORD)result)
          break;
        htmlParseErr((_DWORD *)a1, 76, "Element %s embeds close tag\n", *(const xmlChar **)(a1 + 288), 0);
        goto LABEL_21;
      }
      if ((*(_BYTE *)(v7 + 2) & 0xDFu) - 65 < 0x1A)
        break;
    }
LABEL_21:
    v11 = len;
    if (len == 1)
    {
      v20[(int)v6] = v5;
      v6 = (v6 + 1);
    }
    else
    {
      v6 = (xmlCopyChar(len, &v20[(int)v6], v5) + v6);
    }
LABEL_24:
    v12 = *(_QWORD *)(a1 + 56);
    v13 = *(_BYTE **)(v12 + 32);
    v14 = &v13[v11];
    if ((unint64_t)v14 <= *(_QWORD *)(v12 + 40))
    {
      if (*v13 == 10)
      {
        ++*(_DWORD *)(v12 + 52);
        *(_DWORD *)(v12 + 56) = 1;
      }
      else
      {
        ++*(_DWORD *)(v12 + 56);
      }
      *(_DWORD *)(a1 + 276) = 0;
      *(_QWORD *)(v12 + 32) = v14;
      ++*(_QWORD *)(a1 + 312);
    }
    if ((int)v6 >= 1000)
    {
      v20[v6] = 0;
      v15 = *(void (**)(_QWORD, xmlChar *, uint64_t))(*(_QWORD *)a1 + 200);
      if (v15 || (v15 = *(void (**)(_QWORD, xmlChar *, uint64_t))(*(_QWORD *)a1 + 136)) != 0)
        v15(*(_QWORD *)(a1 + 8), v20, v6);
      v6 = 0;
    }
    if (!*(_DWORD *)(a1 + 452))
    {
      v16 = *(xmlParserInput **)(a1 + 56);
      if (v16->end - v16->cur <= 249)
        xmlParserInputGrow(v16, 250);
    }
    result = htmlCurrentChar(a1, &len);
    v5 = result;
  }
  if ((_DWORD)v6)
  {
    v17 = *(_QWORD *)a1;
    if (*(_QWORD *)a1)
    {
      if (!*(_DWORD *)(a1 + 332))
      {
        v20[(int)v6] = 0;
        v18 = *(uint64_t (**)(_QWORD, xmlChar *, uint64_t))(v17 + 200);
        if (v18)
          return v18(*(_QWORD *)(a1 + 8), v20, v6);
        v18 = *(uint64_t (**)(_QWORD, xmlChar *, uint64_t))(v17 + 136);
        if (v18)
          return v18(*(_QWORD *)(a1 + 8), v20, v6);
      }
    }
  }
  return result;
}

uint64_t htmlGetEndPriority(xmlChar *str2)
{
  uint64_t v2;
  const xmlChar *v3;
  char **v4;
  char *v5;

  v2 = 0;
  v3 = (const xmlChar *)"div";
  v4 = &off_1E6173800;
  do
  {
    if (xmlStrEqual(v3, str2))
      break;
    ++v2;
    v5 = *v4;
    v4 += 2;
    v3 = (const xmlChar *)v5;
  }
  while (v2 != 11);
  return LODWORD((&htmlEndPriority)[2 * v2 + 1]);
}

void htmlParserFinishElementParsing(xmlParserCtxtPtr ctxt)
{
  xmlNodePtr node;
  xmlParserInputPtr input;
  unint64_t v4;
  xmlParserNodeInfo *nodeInfo;
  unint64_t line;
  int nodeInfoNr;
  int v8;
  BOOL v9;
  int v10;
  xmlParserNodeInfo *v11;

  node = ctxt->node;
  if (node)
  {
    if (ctxt->record_info)
    {
      input = ctxt->input;
      v4 = &input->cur[input->consumed] - input->base;
      nodeInfo = ctxt->nodeInfo;
      line = input->line;
      nodeInfo->end_pos = v4;
      nodeInfo->end_line = line;
      nodeInfo->node = node;
      xmlParserAddNodeInfo(ctxt, nodeInfo);
      nodeInfoNr = ctxt->nodeInfoNr;
      if (nodeInfoNr >= 1)
      {
        v8 = nodeInfoNr - 2;
        v10 = nodeInfoNr - 1;
        v9 = v10 == 0;
        ctxt->nodeInfoNr = v10;
        v11 = &ctxt->nodeInfoTab[v8];
        if (v9)
          v11 = 0;
        ctxt->nodeInfo = v11;
      }
    }
  }
  if (!*ctxt->input->cur)
    htmlAutoCloseOnEnd((uint64_t)ctxt);
}

_DWORD *htmlNodeInfoPush(uint64_t a1, __int128 *a2)
{
  int v4;
  int v5;
  _DWORD *result;
  int v7;
  _DWORD *v8;
  __int128 v9;
  __int128 v10;
  int v11;

  v4 = *(_DWORD *)(a1 + 720);
  v5 = *(_DWORD *)(a1 + 724);
  if (v4 < v5)
  {
    result = *(_DWORD **)(a1 + 728);
LABEL_7:
    v8 = &result[10 * v4];
    v9 = *a2;
    v10 = a2[1];
    *((_QWORD *)v8 + 4) = *((_QWORD *)a2 + 4);
    *(_OWORD *)v8 = v9;
    *((_OWORD *)v8 + 1) = v10;
    v11 = *(_DWORD *)(a1 + 720);
    *(_QWORD *)(a1 + 712) = *(_QWORD *)(a1 + 728) + 40 * v11;
    *(_DWORD *)(a1 + 720) = v11 + 1;
    return result;
  }
  v7 = 2 * v5;
  if (!v5)
    v7 = 10;
  *(_DWORD *)(a1 + 724) = v7;
  result = xmlRealloc(*(void **)(a1 + 728), 40 * v7);
  *(_QWORD *)(a1 + 728) = result;
  if (result)
  {
    v4 = *(_DWORD *)(a1 + 720);
    goto LABEL_7;
  }
  return htmlErrMemory((_DWORD *)a1, 0);
}

xmlChar *htmlParseSystemLiteral(xmlParserCtxtPtr ctxt)
{
  xmlParserCtxtPtr v1;
  int v2;
  xmlParserInputPtr input;
  const xmlChar *cur;
  unint64_t base;
  unint64_t v6;
  unsigned int v7;
  BOOL v8;
  const char *v9;
  int v10;
  int v11;
  int v12;
  const xmlChar *v15;
  BOOL v16;
  xmlChar *v17;

  v1 = ctxt;
  v2 = *ctxt->input->cur;
  if (v2 != 34 && v2 != 39)
  {
    v9 = "SystemLiteral \" or ' expected\n";
    v10 = 43;
LABEL_29:
    htmlParseErr(ctxt, v10, v9, 0, 0);
    return 0;
  }
  xmlNextChar(ctxt);
  input = v1->input;
  base = (unint64_t)input->base;
  cur = input->cur;
  v6 = (unint64_t)&cur[-base];
  if ((unint64_t)cur >= base)
  {
    v7 = *cur;
    if (*cur)
      v8 = v7 == v2;
    else
      v8 = 1;
    if (v8)
    {
      if (v7 == v2)
      {
        v12 = 0;
        goto LABEL_32;
      }
    }
    else
    {
      v11 = 0;
      v12 = 0;
      do
      {
        if (v7 - 9 >= 2 && v7 != 13 && v7 <= 0x1F)
        {
          htmlParseErrInt(v1, "Invalid char in SystemLiteral 0x%X\n", v7);
          v11 = 1;
        }
        xmlNextChar(v1);
        ++v12;
        input = v1->input;
        v15 = input->cur;
        v7 = *v15;
        if (*v15)
          v16 = v7 == v2;
        else
          v16 = 1;
      }
      while (!v16);
      if (v7 == v2)
      {
        if (v11)
        {
          v17 = 0;
LABEL_33:
          xmlNextChar(v1);
          return v17;
        }
LABEL_32:
        v17 = xmlStrndup(&input->base[v6], v12);
        goto LABEL_33;
      }
    }
    v9 = "Unfinished SystemLiteral\n";
    ctxt = v1;
    v10 = 44;
    goto LABEL_29;
  }
  return 0;
}

xmlChar *htmlParsePubidLiteral(xmlParserCtxtPtr ctxt)
{
  xmlParserCtxtPtr v1;
  int v2;
  xmlParserInputPtr input;
  const xmlChar *cur;
  unint64_t base;
  unint64_t v6;
  int v7;
  BOOL v8;
  const char *v9;
  int v10;
  int v11;
  int v12;
  const xmlChar *v13;
  BOOL v14;
  xmlChar *v15;

  v1 = ctxt;
  v2 = *ctxt->input->cur;
  if (v2 != 34 && v2 != 39)
  {
    v9 = "PubidLiteral \" or ' expected\n";
    v10 = 43;
LABEL_23:
    htmlParseErr(ctxt, v10, v9, 0, 0);
    return 0;
  }
  xmlNextChar(ctxt);
  input = v1->input;
  base = (unint64_t)input->base;
  cur = input->cur;
  v6 = (unint64_t)&cur[-base];
  if ((unint64_t)cur >= base)
  {
    v7 = *cur;
    if (*cur)
      v8 = v7 == v2;
    else
      v8 = 1;
    if (v8)
    {
      if (v7 == v2)
      {
        v12 = 0;
        goto LABEL_26;
      }
    }
    else
    {
      v11 = 0;
      v12 = 0;
      do
      {
        if (!xmlIsPubidChar_tab[v7])
        {
          htmlParseErrInt(v1, "Invalid char in PubidLiteral 0x%X\n", v7);
          v11 = 1;
        }
        ++v12;
        xmlNextChar(v1);
        input = v1->input;
        v13 = input->cur;
        v7 = *v13;
        if (*v13)
          v14 = v7 == v2;
        else
          v14 = 1;
      }
      while (!v14);
      if (v7 == v2)
      {
        if (v11)
        {
          v15 = 0;
LABEL_27:
          xmlNextChar(v1);
          return v15;
        }
LABEL_26:
        v15 = xmlStrndup(&input->base[v6], v12);
        goto LABEL_27;
      }
    }
    v9 = "Unfinished PubidLiteral\n";
    ctxt = v1;
    v10 = 44;
    goto LABEL_23;
  }
  return 0;
}

uint64_t htmlParseLookupSequence(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v4;
  xmlChar *v5;
  uint64_t v6;
  int v11;
  int v12;
  uint64_t v13;
  char v14;
  int v15;
  xmlChar *v16;
  unint64_t v17;
  int v18;
  int v19;
  unsigned int v20;

  v4 = *(_QWORD *)(a1 + 56);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = *(xmlChar **)(v4 + 24);
  LODWORD(v6) = *(_QWORD *)(v4 + 32) - (_DWORD)v5;
  if ((v6 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if (*(_QWORD *)(a1 + 320) <= (uint64_t)v6)
  {
    v11 = 0;
  }
  else
  {
    v11 = *(_DWORD *)(a1 + 144) & 1;
    v6 = *(_QWORD *)(a1 + 320);
  }
  if (*(_QWORD *)v4)
  {
    v5 = xmlBufContent(*(const xmlBuf **)(*(_QWORD *)v4 + 32));
    v12 = xmlBufUse(*(const xmlBufPtr *)(*(_QWORD *)v4 + 32));
  }
  else
  {
    v12 = *(_DWORD *)(v4 + 48);
  }
  LODWORD(v13) = v12 - (a3 != 0);
  if ((int)v6 >= (int)v13)
  {
    v13 = (int)v6;
LABEL_26:
    *(_QWORD *)(a1 + 320) = v13;
    v19 = *(_DWORD *)(a1 + 144);
    if (v11)
      v20 = v19 | 1;
    else
      v20 = v19 & 0xFFFFFFFE;
    *(_DWORD *)(a1 + 144) = v20;
    return 0xFFFFFFFFLL;
  }
  v14 = 0;
  v13 = (int)v13;
  v15 = -(int)v6;
  v16 = &v5[(int)v6 + 1];
  v17 = v12 - (unint64_t)(a3 != 0) - (int)v6;
  while (1)
  {
    v18 = *(v16 - 1);
    if (!a4)
      break;
    if (v18 == 39 || v18 == 34)
    {
      if (v11)
      {
        if (v18 != v14)
          break;
        v11 = 0;
      }
      else
      {
        v11 = 1;
        v14 = *(v16 - 1);
      }
    }
    else
    {
      if (!v11)
        break;
      v11 = 1;
    }
LABEL_23:
    ++v16;
    --v15;
    if (!--v17)
      goto LABEL_26;
  }
  if (v18 != a2 || a3 && *v16 != a3)
    goto LABEL_23;
  *(_QWORD *)(a1 + 320) = 0;
  return (*(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 32) - v15);
}

uint64_t htmlParseLookupCommentEnd(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  int v6;
  uint64_t v7;
  int v8;

  v2 = *(_QWORD *)(a1 + 56);
  v4 = *(_QWORD *)(v2 + 24);
  v3 = *(_QWORD *)(v2 + 32);
  result = htmlParseLookupSequence(a1, 45, 45, 0);
  if ((result & 0x80000000) == 0)
  {
    v6 = v3 - v4 + 1;
    do
    {
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32) + result;
      v8 = *(unsigned __int8 *)(v7 + 2);
      if (v8 == 33)
      {
        if (*(_BYTE *)(v7 + 3) == 62)
          return result;
      }
      else if (v8 == 62)
      {
        return result;
      }
      *(_QWORD *)(a1 + 320) = v6 + (int)result;
      result = htmlParseLookupSequence(a1, 45, 45, 0);
    }
    while ((result & 0x80000000) == 0);
  }
  return result;
}

const xmlChar *__cdecl htmlGetMetaEncoding(const xmlChar *doc)
{
  uint64_t v1;
  const xmlChar *v2;
  const xmlChar *v3;
  const xmlChar *v4;
  uint64_t v5;
  int v6;
  const xmlChar *v7;
  uint64_t v8;
  const xmlChar *v9;
  const xmlChar *v10;
  int v11;

  if (!doc)
    return doc;
  v1 = *((_QWORD *)doc + 3);
  if (!v1)
    return 0;
  while (1)
  {
    if (*(_DWORD *)(v1 + 8) != 1)
      goto LABEL_8;
    v2 = *(const xmlChar **)(v1 + 16);
    if (!v2)
      goto LABEL_8;
    if (xmlStrEqual(v2, (const xmlChar *)"html"))
    {
      v1 = *(_QWORD *)(v1 + 24);
      if (v1)
      {
        while (1)
        {
          if (*(_DWORD *)(v1 + 8) == 1)
          {
            v3 = *(const xmlChar **)(v1 + 16);
            if (v3)
            {
              if (xmlStrEqual(v3, (const xmlChar *)"head"))
                goto LABEL_17;
              if (xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"meta"))
                goto LABEL_18;
            }
          }
          doc = 0;
          v1 = *(_QWORD *)(v1 + 48);
          if (!v1)
            return doc;
        }
      }
      return 0;
    }
    if (xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"head"))
    {
LABEL_17:
      v1 = *(_QWORD *)(v1 + 24);
      if (v1)
        break;
      return 0;
    }
    if (xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"meta"))
      break;
LABEL_8:
    v1 = *(_QWORD *)(v1 + 48);
    if (!v1)
      return 0;
  }
LABEL_18:
  while (1)
  {
    if (*(_DWORD *)(v1 + 8) == 1)
    {
      v4 = *(const xmlChar **)(v1 + 16);
      if (v4)
      {
        if (xmlStrEqual(v4, (const xmlChar *)"meta"))
        {
          v5 = *(_QWORD *)(v1 + 88);
          if (v5)
            break;
        }
      }
    }
LABEL_36:
    v1 = *(_QWORD *)(v1 + 48);
    if (!v1)
      return 0;
  }
  v6 = 0;
  v7 = 0;
  while (2)
  {
    v8 = *(_QWORD *)(v5 + 24);
    if (!v8 || *(_DWORD *)(v8 + 8) != 3 || *(_QWORD *)(v8 + 48))
      goto LABEL_33;
    v9 = *(const xmlChar **)(v8 + 80);
    if (!xmlStrcasecmp(*(const xmlChar **)(v5 + 16), (const xmlChar *)"http-equiv")
      && !xmlStrcasecmp(v9, (const xmlChar *)"Content-Type"))
    {
      v6 = 1;
      break;
    }
    if (v9 && !xmlStrcasecmp(*(const xmlChar **)(v5 + 16), (const xmlChar *)"content"))
      v7 = v9;
    if (!v6)
    {
LABEL_33:
      v5 = *(_QWORD *)(v5 + 48);
      if (!v5)
        goto LABEL_36;
      continue;
    }
    break;
  }
  if (!v7)
    goto LABEL_33;
  v10 = xmlStrstr(v7, (const xmlChar *)"charset=");
  if (v10
    || (v10 = xmlStrstr(v7, (const xmlChar *)"Charset=")) != 0
    || (v10 = xmlStrstr(v7, (const xmlChar *)"CHARSET=")) != 0)
  {
    doc = v10 + 8;
LABEL_48:
    while (1)
    {
      v11 = *doc;
      if (v11 != 32 && v11 != 9)
        break;
      ++doc;
    }
  }
  else
  {
    doc = xmlStrstr(v7, (const xmlChar *)"charset =");
    if (doc
      || (doc = xmlStrstr(v7, (const xmlChar *)"Charset =")) != 0
      || (doc = xmlStrstr(v7, (const xmlChar *)"CHARSET =")) != 0)
    {
      doc += 9;
      goto LABEL_48;
    }
  }
  return doc;
}

int htmlSetMetaEncoding(htmlDocPtr doc, const xmlChar *encoding)
{
  _xmlNode *children;
  const xmlChar *name;
  int result;
  const xmlChar *v7;
  xmlNode *parent;
  xmlNode *v9;
  xmlNode *v10;
  const xmlChar *v11;
  _xmlAttr *properties;
  int v13;
  const xmlChar *v14;
  _xmlNode *v15;
  const xmlChar *content;
  char __str[16];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  *(_OWORD *)__str = 0u;
  v18 = 0u;
  if (!doc || !xmlStrcasecmp(encoding, (const xmlChar *)"html"))
    return -1;
  if (encoding)
  {
    snprintf(__str, 0x64uLL, "text/html; charset=%s", (const char *)encoding);
    HIBYTE(v23) = 0;
  }
  children = doc->children;
  if (!children)
    return -1;
  while (1)
  {
    if (children->type == XML_ELEMENT_NODE)
    {
      name = children->name;
      if (name)
        break;
    }
LABEL_11:
    children = children->next;
    if (!children)
      return -1;
  }
  if (!xmlStrcasecmp(name, (const xmlChar *)"html"))
  {
    children = children->children;
    if (children)
    {
      while (1)
      {
        if (children->type == XML_ELEMENT_NODE)
        {
          v7 = children->name;
          if (v7)
          {
            if (!xmlStrcasecmp(v7, (const xmlChar *)"head"))
              goto LABEL_21;
            if (!xmlStrcasecmp(children->name, (const xmlChar *)"meta"))
            {
              parent = children->parent;
              goto LABEL_27;
            }
          }
        }
        children = children->next;
        result = -1;
        if (!children)
          return result;
      }
    }
    return -1;
  }
  if (xmlStrcasecmp(children->name, (const xmlChar *)"head"))
  {
    if (!xmlStrcasecmp(children->name, (const xmlChar *)"meta"))
    {
      parent = 0;
      goto LABEL_27;
    }
    goto LABEL_11;
  }
LABEL_21:
  parent = children;
  children = children->children;
  if (!children)
    goto LABEL_22;
LABEL_27:
  while (2)
  {
    if (children->type != XML_ELEMENT_NODE)
      goto LABEL_30;
    v11 = children->name;
    if (!v11)
      goto LABEL_30;
    if (xmlStrcasecmp(v11, (const xmlChar *)"meta"))
      goto LABEL_30;
    properties = children->properties;
    if (!properties)
      goto LABEL_30;
    v13 = 0;
    v14 = 0;
    while (2)
    {
      v15 = properties->children;
      if (!v15 || v15->type != XML_TEXT_NODE || v15->next)
        goto LABEL_44;
      content = v15->content;
      if (!xmlStrcasecmp(properties->name, (const xmlChar *)"http-equiv")
        && !xmlStrcasecmp(content, (const xmlChar *)"Content-Type"))
      {
        v13 = 1;
        break;
      }
      if (content && !xmlStrcasecmp(properties->name, (const xmlChar *)"content"))
        v14 = content;
      if (!v13)
      {
LABEL_44:
        properties = properties->next;
        if (!properties)
          goto LABEL_48;
        continue;
      }
      break;
    }
    if (!v14)
      goto LABEL_44;
    v13 = 1;
LABEL_48:
    if (v13 && v14)
    {
      if (encoding)
      {
        if (!xmlStrcasestr(v14, encoding))
          xmlSetProp(children, (const xmlChar *)"content", (const xmlChar *)__str);
      }
      else
      {
        xmlUnlinkNode(children);
        xmlFreeNode(children);
      }
      return 0;
    }
LABEL_30:
    children = children->next;
    if (children)
      continue;
    break;
  }
LABEL_22:
  result = 0;
  if (encoding && parent)
  {
    v9 = xmlNewDocNode(doc, 0, (const xmlChar *)"meta", 0);
    v10 = parent->children;
    if (v10)
      xmlAddPrevSibling(v10, v9);
    else
      xmlAddChild(parent, v9);
    xmlNewProp(v9, (const xmlChar *)"http-equiv", (const xmlChar *)"Content-Type");
    xmlNewProp(v9, (const xmlChar *)"content", (const xmlChar *)__str);
    return 0;
  }
  return result;
}

int htmlIsBooleanAttr(const xmlChar *name)
{
  uint64_t v2;

  v2 = 0;
  while (xmlStrcasecmp((const xmlChar *)htmlBooleanAttrs[v2], name))
  {
    if (++v2 == 13)
      return 0;
  }
  return 1;
}

int htmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur)
{
  size_t v3;
  uint32x2_t *v7;
  xmlBuf *v8;
  xmlOutputBuffer *v9;
  xmlOutputBuffer *v10;
  size_t v11;

  LODWORD(v3) = -1;
  if (buf && cur)
  {
    xmlInitParser();
    v7 = xmlBufFromBuffer((uint32x2_t *)buf);
    if (v7)
    {
      v8 = (xmlBuf *)v7;
      v9 = (xmlOutputBuffer *)xmlMalloc(0x38uLL);
      if (v9)
      {
        v10 = v9;
        *(_OWORD *)&v9->closecallback = 0u;
        *(_OWORD *)&v9->buffer = 0u;
        *(_QWORD *)&v9->written = 0;
        *(_OWORD *)&v9->context = 0u;
        v9->buffer = v8;
        v9->written = 0;
        v11 = xmlBufUse(v8);
        htmlNodeDumpFormatOutput(v10, doc, cur, 0, 1);
        xmlFree(v10);
        v3 = xmlBufUse(v8) - v11;
        xmlBufBackToBuffer((uint64_t)v8);
        if ((v3 & 0x80000000) == 0)
          return v3;
      }
      else
      {
        __xmlSimpleError(7u, 2, 0, 0, (const xmlChar *)"allocating HTML output buffer");
        xmlBufBackToBuffer((uint64_t)v8);
      }
    }
    LODWORD(v3) = -1;
  }
  return v3;
}

int htmlNodeDumpFileFormat(FILE *out, xmlDocPtr doc, xmlNodePtr cur, const char *encoding, int format)
{
  xmlCharEncodingHandler *CharEncodingHandler;
  xmlOutputBuffer *File;
  xmlOutputBuffer *v12;

  xmlInitParser();
  if (encoding)
  {
    if (xmlParseCharEncoding(encoding) != XML_CHAR_ENCODING_UTF8)
    {
      CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
      if (CharEncodingHandler)
        goto LABEL_8;
      __xmlSimpleError(7u, 1403, 0, "unknown encoding %s\n", (const xmlChar *)encoding);
    }
    CharEncodingHandler = 0;
  }
  else
  {
    CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler)
      CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
  }
LABEL_8:
  File = xmlOutputBufferCreateFile(out, CharEncodingHandler);
  if (File)
  {
    v12 = File;
    htmlNodeDumpFormatOutput(File, doc, cur, 0, format);
    LODWORD(File) = xmlOutputBufferClose(v12);
  }
  return (int)File;
}

void htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, const char *encoding, int format)
{
  _xmlNode *parent;
  xmlNodePtr children;
  _xmlNode *v10;
  xmlChar *v11;
  xmlChar **v12;
  uint64_t v13;
  xmlOutputBuffer *v14;
  const char *v15;
  const char *content;
  int v18;
  xmlChar *v19;
  xmlChar *v20;
  xmlOutputBuffer *v21;
  const htmlElemDesc *v22;
  const xmlChar *v23;
  const xmlChar *v24;
  xmlNs *ns;
  const char *prefix;
  xmlNs *nsDef;
  uint64_t i;
  _xmlNode **p_children;
  xmlElementType type;
  const xmlChar *name;
  const char *v33;
  xmlNs *v34;
  const char *v35;
  _xmlNode *next;
  xmlElementType v37;
  const xmlChar *v38;
  int v39;
  const htmlElemDesc *v40;
  xmlNs *v41;
  const char *v42;
  const htmlElemDesc *v43;
  _xmlNode *last;
  xmlElementType v45;
  const xmlChar *v47;
  const htmlElemDesc *v48;

  xmlInitParser();
  if (buf && cur)
  {
    parent = cur->parent;
    children = cur;
LABEL_4:
    while (2)
    {
      v10 = parent;
      parent = children;
      switch(children->type)
      {
        case XML_ELEMENT_NODE:
          if (children->parent != v10 && children->children)
          {
            htmlNodeDumpFormatOutput(buf, doc, children, encoding, format);
            goto LABEL_87;
          }
          if (children->ns)
            v22 = 0;
          else
            v22 = htmlTagLookup(children->name);
          xmlOutputBufferWriteString(buf, "<");
          ns = parent->ns;
          if (ns)
          {
            prefix = (const char *)ns->prefix;
            if (prefix)
            {
              xmlOutputBufferWriteString(buf, prefix);
              xmlOutputBufferWriteString(buf, ":");
            }
          }
          v48 = v22;
          xmlOutputBufferWriteString(buf, (const char *)parent->name);
          nsDef = parent->nsDef;
          if (nsDef)
            xmlNsListDumpOutput((uint64_t)buf, nsDef);
          for (i = (uint64_t)parent->properties; i; i = *(_QWORD *)(i + 48))
            htmlAttrDumpOutput(buf, doc, i);
          if (!v48)
          {
            p_children = &parent->children;
            if (parent->children)
            {
              v33 = ">";
LABEL_66:
              xmlOutputBufferWriteString(buf, v33);
LABEL_67:
              children = *p_children;
              continue;
            }
            goto LABEL_72;
          }
          if (!v48->empty)
          {
            p_children = &parent->children;
            if (parent->children)
            {
              xmlOutputBufferWriteString(buf, ">");
              if (!format || v48->isinline)
                goto LABEL_67;
              type = (*p_children)->type;
              if (type == XML_TEXT_NODE || type == XML_ENTITY_REF_NODE)
                goto LABEL_67;
              if (*p_children == parent->last)
                goto LABEL_67;
              name = parent->name;
              if (!name)
                goto LABEL_67;
              v33 = "\n";
              if (*name == 112)
                goto LABEL_67;
              goto LABEL_66;
            }
            if (!v48->saveEndTag
              || !xmlStrcmp((const xmlChar *)v48->name, (const xmlChar *)"html")
              || !xmlStrcmp((const xmlChar *)v48->name, (const xmlChar *)"body"))
            {
LABEL_72:
              xmlOutputBufferWriteString(buf, "></");
              v34 = parent->ns;
              if (v34)
              {
                v35 = (const char *)v34->prefix;
                if (v35)
                {
                  xmlOutputBufferWriteString(buf, v35);
                  xmlOutputBufferWriteString(buf, ":");
                }
              }
              xmlOutputBufferWriteString(buf, (const char *)parent->name);
            }
          }
          xmlOutputBufferWriteString(buf, ">");
          if (!format)
            goto LABEL_87;
          if (!v48)
            goto LABEL_87;
          next = parent->next;
          if (!next || v48->isinline)
            goto LABEL_87;
LABEL_80:
          v37 = next->type;
          if (v37 == XML_TEXT_NODE)
            goto LABEL_87;
          if (v37 == XML_ENTITY_REF_NODE)
            goto LABEL_87;
          if (!v10)
            goto LABEL_87;
          v38 = v10->name;
          if (!v38 || *v38 == 112)
            goto LABEL_87;
LABEL_85:
          v21 = buf;
          content = "\n";
LABEL_86:
          xmlOutputBufferWriteString(v21, content);
LABEL_87:
          while (parent != cur)
          {
            children = parent->next;
            parent = v10;
            if (children)
              goto LABEL_4;
            v10 = v10->parent;
            if ((parent->type | 4) == 0xD)
              goto LABEL_85;
            if (format && !parent->ns)
            {
              v43 = htmlTagLookup(parent->name);
              v40 = v43;
              if (v43)
              {
                if (!v43->isinline)
                {
                  last = parent->last;
                  v45 = last->type;
                  if (v45 != XML_TEXT_NODE && v45 != XML_ENTITY_REF_NODE && parent->children != last)
                  {
                    v47 = parent->name;
                    if (v47)
                    {
                      if (*v47 != 112)
                        xmlOutputBufferWriteString(buf, "\n");
                    }
                  }
                }
                v39 = 1;
              }
              else
              {
                v39 = 0;
              }
            }
            else
            {
              v39 = 0;
              v40 = 0;
            }
            xmlOutputBufferWriteString(buf, "</");
            v41 = parent->ns;
            if (v41)
            {
              v42 = (const char *)v41->prefix;
              if (v42)
              {
                xmlOutputBufferWriteString(buf, v42);
                xmlOutputBufferWriteString(buf, ":");
              }
            }
            xmlOutputBufferWriteString(buf, (const char *)parent->name);
            xmlOutputBufferWriteString(buf, ">");
            if (v39)
            {
              if (!v40->isinline)
              {
                next = parent->next;
                if (next)
                  goto LABEL_80;
              }
            }
          }
          break;
        case XML_ATTRIBUTE_NODE:
          htmlAttrDumpOutput(buf, doc, (uint64_t)children);
          goto LABEL_87;
        case XML_TEXT_NODE:
          content = (const char *)children->content;
          if (!content)
            goto LABEL_87;
          if (children->name == "textnoenc" && "text" != "textnoenc")
            goto LABEL_25;
          if (!v10)
            goto LABEL_22;
          if (xmlStrcasecmp(v10->name, (const xmlChar *)"script"))
          {
            v18 = xmlStrcasecmp(v10->name, (const xmlChar *)"style");
            content = (const char *)parent->content;
            if (v18)
            {
LABEL_22:
              v19 = xmlEncodeEntitiesReentrant(doc, (const xmlChar *)content);
              if (v19)
              {
                v20 = v19;
                xmlOutputBufferWriteString(buf, (const char *)v19);
                xmlFree(v20);
              }
              goto LABEL_87;
            }
          }
          else
          {
            content = (const char *)parent->content;
          }
LABEL_25:
          v21 = buf;
          goto LABEL_86;
        case XML_CDATA_SECTION_NODE:
          content = (const char *)children->content;
          if (content)
            goto LABEL_25;
          goto LABEL_87;
        case XML_ENTITY_REF_NODE:
          xmlOutputBufferWriteString(buf, "&");
          xmlOutputBufferWriteString(buf, (const char *)parent->name);
          v21 = buf;
          content = ";";
          goto LABEL_86;
        case XML_PI_NODE:
          if (!children->name)
            goto LABEL_87;
          xmlOutputBufferWriteString(buf, "<?");
          xmlOutputBufferWriteString(buf, (const char *)parent->name);
          if (parent->content)
          {
            xmlOutputBufferWriteString(buf, " ");
            xmlOutputBufferWriteString(buf, (const char *)parent->content);
          }
          v21 = buf;
          content = ">";
          goto LABEL_86;
        case XML_COMMENT_NODE:
          if (!children->content)
            goto LABEL_87;
          xmlOutputBufferWriteString(buf, "<!--");
          xmlOutputBufferWriteString(buf, (const char *)parent->content);
          v21 = buf;
          content = "-->";
          goto LABEL_86;
        case XML_DOCUMENT_NODE:
        case XML_HTML_DOCUMENT_NODE:
          v11 = children->content;
          if (!v11)
            goto LABEL_40;
          xmlOutputBufferWriteString(buf, "<!DOCTYPE ");
          xmlOutputBufferWriteString(buf, *((const char **)v11 + 2));
          if (*((_QWORD *)v11 + 13))
          {
            xmlOutputBufferWriteString(buf, " PUBLIC ");
            xmlBufWriteQuotedString((uint64x2_t *)buf->buffer, *((xmlChar **)v11 + 13));
            v13 = *((_QWORD *)v11 + 14);
            v12 = (xmlChar **)(v11 + 112);
            if (!v13)
              goto LABEL_39;
            v14 = buf;
            v15 = " ";
            goto LABEL_38;
          }
          v24 = (const xmlChar *)*((_QWORD *)v11 + 14);
          v12 = (xmlChar **)(v11 + 112);
          v23 = v24;
          if (v24 && xmlStrcmp(v23, (const xmlChar *)"about:legacy-compat"))
          {
            v14 = buf;
            v15 = " SYSTEM ";
LABEL_38:
            xmlOutputBufferWriteString(v14, v15);
            xmlBufWriteQuotedString((uint64x2_t *)buf->buffer, *v12);
          }
LABEL_39:
          xmlOutputBufferWriteString(buf, ">\n");
LABEL_40:
          children = parent->children;
          if (!children)
            goto LABEL_85;
          if (parent->parent != v10)
            goto LABEL_87;
          continue;
        default:
          goto LABEL_87;
      }
      break;
    }
  }
}

void htmlNodeDumpFile(FILE *out, xmlDocPtr doc, xmlNodePtr cur)
{
  htmlNodeDumpFileFormat(out, doc, cur, 0, 1);
}

void htmlDocDumpMemoryFormat(xmlDocPtr cur, xmlChar **mem, int *size, int format)
{
  const char *MetaEncoding;
  const char *v9;
  xmlCharEncodingHandlerPtr CharEncodingHandler;
  xmlOutputBuffer *v11;
  xmlOutputBuffer *v12;
  xmlElementType type;
  xmlBuf *conv;
  const xmlBuf **p_conv;
  xmlChar *v16;

  xmlInitParser();
  if (!mem || !size)
    return;
  if (!cur)
  {
LABEL_15:
    *mem = 0;
    *size = 0;
    return;
  }
  MetaEncoding = (const char *)htmlGetMetaEncoding(cur);
  if (MetaEncoding)
  {
    v9 = MetaEncoding;
    if (xmlParseCharEncoding(MetaEncoding) != XML_CHAR_ENCODING_UTF8)
    {
      CharEncodingHandler = xmlFindCharEncodingHandler(v9);
      if (CharEncodingHandler)
        goto LABEL_11;
      __xmlSimpleError(7u, 1403, 0, "unknown encoding %s\n", (const xmlChar *)v9);
    }
    CharEncodingHandler = 0;
  }
  else
  {
    CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler)
      CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
  }
LABEL_11:
  v11 = (xmlOutputBuffer *)xmlAllocOutputBufferInternal((uint64_t)CharEncodingHandler);
  if (!v11)
    goto LABEL_15;
  v12 = v11;
  type = cur->type;
  cur->type = XML_HTML_DOCUMENT_NODE;
  htmlNodeDumpFormatOutput(v11, cur, (xmlNodePtr)cur, 0, format);
  cur->type = type;
  xmlOutputBufferFlush(v12);
  p_conv = &v12->conv;
  conv = v12->conv;
  if (!conv)
  {
    p_conv = &v12->buffer;
    conv = v12->buffer;
  }
  *size = xmlBufUse(conv);
  v16 = xmlBufContent(*p_conv);
  *mem = xmlStrndup(v16, *size);
  xmlOutputBufferClose(v12);
}

void htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf, xmlDocPtr cur, const char *encoding, int format)
{
  xmlElementType type;

  if (cur)
  {
    type = cur->type;
    cur->type = XML_HTML_DOCUMENT_NODE;
    htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, format);
    cur->type = type;
  }
  else
  {
    htmlNodeDumpFormatOutput(buf, 0, 0, 0, format);
  }
}

void htmlDocDumpMemory(xmlDocPtr cur, xmlChar **mem, int *size)
{
  htmlDocDumpMemoryFormat(cur, mem, size, 1);
}

void htmlAttrDumpOutput(xmlOutputBuffer *a1, xmlDoc *a2, uint64_t a3)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  const xmlChar *v9;
  xmlChar *String;
  xmlChar *v11;
  uint64x2_t *buffer;
  uint64_t v13;
  const xmlChar *i;
  unsigned int v15;
  BOOL v16;
  uint64_t v17;
  xmlChar *v19;

  if (a3)
  {
    xmlOutputBufferWriteString(a1, " ");
    v6 = *(_QWORD *)(a3 + 72);
    if (v6)
    {
      v7 = *(const char **)(v6 + 24);
      if (v7)
      {
        xmlOutputBufferWriteString(a1, v7);
        xmlOutputBufferWriteString(a1, ":");
      }
    }
    xmlOutputBufferWriteString(a1, *(const char **)(a3 + 16));
    if (*(_QWORD *)(a3 + 24))
    {
      v8 = 0;
      v9 = *(const xmlChar **)(a3 + 16);
      do
      {
        if (!xmlStrcasecmp((const xmlChar *)htmlBooleanAttrs[v8], v9))
          return;
        ++v8;
      }
      while (v8 != 13);
      String = xmlNodeListGetString(a2, *(const xmlNode **)(a3 + 24), 0);
      if (String)
      {
        v11 = String;
        xmlOutputBufferWriteString(a1, "=");
        if (*(_QWORD *)(a3 + 72)
          || (v13 = *(_QWORD *)(a3 + 40)) == 0
          || *(_QWORD *)(v13 + 72)
          || xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"href")
          && xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"action")
          && xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"src")
          && (xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"name")
           || xmlStrcasecmp(*(const xmlChar **)(*(_QWORD *)(a3 + 40) + 16), (const xmlChar *)"a")))
        {
          buffer = (uint64x2_t *)a1->buffer;
        }
        else
        {
          for (i = v11; ; ++i)
          {
            v15 = *i;
            v16 = v15 > 0x20;
            v17 = (1 << v15) & 0x100002600;
            if (v16 || v17 == 0)
              break;
          }
          v19 = xmlURIEscapeStr(i, (const xmlChar *)"@/:=?;#%&,+<>");
          buffer = (uint64x2_t *)a1->buffer;
          if (v19)
          {
            xmlBufWriteQuotedString(buffer, v19);
            xmlFree(v19);
            goto LABEL_13;
          }
        }
        xmlBufWriteQuotedString(buffer, v11);
LABEL_13:
        xmlFree(v11);
        return;
      }
      xmlOutputBufferWriteString(a1, "=\"\"");
    }
  }
}

void htmlNodeDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, const char *encoding)
{
  htmlNodeDumpFormatOutput(buf, doc, cur, 0, 1);
}

void htmlDocContentDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr cur, const char *encoding)
{
  htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1);
}

int htmlDocDump(FILE *f, xmlDocPtr cur)
{
  const char *MetaEncoding;
  const char *v5;
  xmlCharEncodingHandler *CharEncodingHandler;
  xmlOutputBuffer *File;
  xmlOutputBuffer *v8;

  xmlInitParser();
  if (!f || !cur)
    return -1;
  MetaEncoding = (const char *)htmlGetMetaEncoding(cur);
  if (MetaEncoding)
  {
    v5 = MetaEncoding;
    if (xmlParseCharEncoding(MetaEncoding) != XML_CHAR_ENCODING_UTF8)
    {
      CharEncodingHandler = xmlFindCharEncodingHandler(v5);
      if (CharEncodingHandler)
        goto LABEL_10;
      __xmlSimpleError(7u, 1403, 0, "unknown encoding %s\n", (const xmlChar *)v5);
    }
    CharEncodingHandler = 0;
  }
  else
  {
    CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler)
      CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
  }
LABEL_10:
  File = xmlOutputBufferCreateFile(f, CharEncodingHandler);
  if (File)
  {
    v8 = File;
    htmlNodeDumpFormatOutput(File, cur, (xmlNodePtr)cur, 0, 1);
    return xmlOutputBufferClose(v8);
  }
  return -1;
}

int htmlSaveFile(const char *filename, xmlDocPtr cur)
{
  const char *v2;
  const char *MetaEncoding;
  const char *v5;
  xmlCharEncodingHandler *CharEncodingHandler;
  xmlOutputBuffer *v7;

  v2 = filename;
  LODWORD(filename) = -1;
  if (!v2 || !cur)
    return (int)filename;
  xmlInitParser();
  MetaEncoding = (const char *)htmlGetMetaEncoding(cur);
  if (!MetaEncoding)
  {
    CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler)
      CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
    goto LABEL_10;
  }
  v5 = MetaEncoding;
  if (xmlParseCharEncoding(MetaEncoding) != XML_CHAR_ENCODING_UTF8)
  {
    CharEncodingHandler = xmlFindCharEncodingHandler(v5);
    if (CharEncodingHandler)
      goto LABEL_10;
    __xmlSimpleError(7u, 1403, 0, "unknown encoding %s\n", (const xmlChar *)v5);
  }
  CharEncodingHandler = 0;
LABEL_10:
  filename = (const char *)xmlOutputBufferCreateFilename(v2, CharEncodingHandler, cur->compression);
  if (filename)
  {
    v7 = (xmlOutputBuffer *)filename;
    htmlNodeDumpFormatOutput((xmlOutputBufferPtr)filename, cur, (xmlNodePtr)cur, 0, 1);
    LODWORD(filename) = xmlOutputBufferClose(v7);
  }
  return (int)filename;
}

int htmlSaveFileFormat(const char *filename, xmlDocPtr cur, const char *encoding, int format)
{
  const char *v4;
  xmlCharEncodingHandler *CharEncodingHandler;
  const char *v9;
  xmlOutputBuffer *v10;

  v4 = filename;
  LODWORD(filename) = -1;
  if (v4 && cur)
  {
    xmlInitParser();
    if (encoding)
    {
      if (xmlParseCharEncoding(encoding) == XML_CHAR_ENCODING_UTF8)
      {
        CharEncodingHandler = 0;
      }
      else
      {
        CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
        if (!CharEncodingHandler)
          __xmlSimpleError(7u, 1403, 0, "unknown encoding %s\n", (const xmlChar *)encoding);
      }
      htmlSetMetaEncoding(cur, (const xmlChar *)encoding);
    }
    else
    {
      htmlSetMetaEncoding(cur, (const xmlChar *)"UTF-8");
      CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
      if (!CharEncodingHandler)
        CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
    }
    filename = (const char *)xmlOutputBufferCreateFilename(v4, CharEncodingHandler, 0);
    if (filename)
    {
      v10 = (xmlOutputBuffer *)filename;
      htmlDocContentDumpFormatOutput((xmlOutputBufferPtr)filename, cur, v9, format);
      LODWORD(filename) = xmlOutputBufferClose(v10);
    }
  }
  return (int)filename;
}

int htmlSaveFileEnc(const char *filename, xmlDocPtr cur, const char *encoding)
{
  return htmlSaveFileFormat(filename, cur, encoding, 1);
}

int xmlGetFeaturesList(int *len, const char **result)
{
  int v3;
  unsigned int v4;

  v3 = 42;
  if (len && result)
  {
    v4 = *len;
    if (*len > 0x3E7)
      return -1;
    if (v4 < 0x2B)
    {
      if (!v4)
        return 42;
    }
    else
    {
      v4 = 42;
      *len = 42;
    }
    memcpy(result, xmlFeaturesList, 8 * v4);
    return 42;
  }
  return v3;
}

int xmlGetFeature(xmlParserCtxtPtr ctxt, const char *name, void *result)
{
  int v4;
  int valid;
  void *userData;

  v4 = -1;
  if (ctxt && name && result)
  {
    v4 = strcmp(name, "validate");
    if (v4)
    {
      v4 = strcmp(name, "keep blanks");
      if (v4)
      {
        v4 = strcmp(name, "disable SAX");
        if (v4)
        {
          v4 = strcmp(name, "fetch external entities");
          if (v4)
          {
            v4 = strcmp(name, "substitute entities");
            if (v4)
            {
              v4 = strcmp(name, "gather line info");
              if (v4)
              {
                v4 = strcmp(name, "user data");
                if (!v4)
                {
                  userData = ctxt->userData;
                  goto LABEL_52;
                }
                v4 = strcmp(name, "is html");
                if (v4)
                {
                  v4 = strcmp(name, "is standalone");
                  if (v4)
                  {
                    v4 = strcmp(name, "document");
                    if (v4)
                    {
                      v4 = strcmp(name, "is well formed");
                      if (v4)
                      {
                        v4 = strcmp(name, "is valid");
                        if (v4)
                        {
                          v4 = strcmp(name, "SAX block");
                          if (v4)
                          {
                            v4 = strcmp(name, "SAX function internalSubset");
                            if (v4)
                            {
                              v4 = strcmp(name, "SAX function isStandalone");
                              if (v4)
                              {
                                v4 = strcmp(name, "SAX function hasInternalSubset");
                                if (v4)
                                {
                                  v4 = strcmp(name, "SAX function hasExternalSubset");
                                  if (v4)
                                  {
                                    v4 = strcmp(name, "SAX function resolveEntity");
                                    if (v4)
                                    {
                                      v4 = strcmp(name, "SAX function getEntity");
                                      if (v4)
                                      {
                                        v4 = strcmp(name, "SAX function entityDecl");
                                        if (v4)
                                        {
                                          v4 = strcmp(name, "SAX function notationDecl");
                                          if (v4)
                                          {
                                            v4 = strcmp(name, "SAX function attributeDecl");
                                            if (v4)
                                            {
                                              v4 = strcmp(name, "SAX function elementDecl");
                                              if (v4)
                                              {
                                                v4 = strcmp(name, "SAX function unparsedEntityDecl");
                                                if (v4)
                                                {
                                                  v4 = strcmp(name, "SAX function setDocumentLocator");
                                                  if (v4)
                                                  {
                                                    v4 = strcmp(name, "SAX function startDocument");
                                                    if (v4)
                                                    {
                                                      v4 = strcmp(name, "SAX function endDocument");
                                                      if (v4)
                                                      {
                                                        v4 = strcmp(name, "SAX function startElement");
                                                        if (v4)
                                                        {
                                                          v4 = strcmp(name, "SAX function endElement");
                                                          if (v4)
                                                          {
                                                            v4 = strcmp(name, "SAX function reference");
                                                            if (v4)
                                                            {
                                                              v4 = strcmp(name, "SAX function characters");
                                                              if (v4)
                                                              {
                                                                v4 = strcmp(name, "SAX function ignorableWhitespace");
                                                                if (v4)
                                                                {
                                                                  v4 = strcmp(name, "SAX function processingInstruction");
                                                                  if (v4)
                                                                  {
                                                                    v4 = strcmp(name, "SAX function comment");
                                                                    if (v4)
                                                                    {
                                                                      v4 = strcmp(name, "SAX function warning");
                                                                      if (v4)
                                                                      {
                                                                        v4 = strcmp(name, "SAX function error");
                                                                        if (v4)
                                                                        {
                                                                          v4 = strcmp(name, "SAX function fatalError");
                                                                          if (v4)
                                                                          {
                                                                            v4 = strcmp(name, "SAX function getParameterEntity");
                                                                            if (v4)
                                                                            {
                                                                              v4 = strcmp(name, "SAX function cdataBlock");
                                                                              if (v4)
                                                                              {
                                                                                v4 = strcmp(name, "SAX function externalSubset");
                                                                                if (v4)
                                                                                  return -1;
                                                                                userData = ctxt->sax->externalSubset;
                                                                              }
                                                                              else
                                                                              {
                                                                                userData = ctxt->sax->cdataBlock;
                                                                              }
                                                                            }
                                                                            else
                                                                            {
                                                                              userData = ctxt->sax->getParameterEntity;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            userData = ctxt->sax->fatalError;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          userData = ctxt->sax->error;
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        userData = ctxt->sax->warning;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      userData = ctxt->sax->comment;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    userData = ctxt->sax->processingInstruction;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  userData = ctxt->sax->ignorableWhitespace;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                userData = ctxt->sax->characters;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              userData = ctxt->sax->reference;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            userData = ctxt->sax->endElement;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          userData = ctxt->sax->startElement;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        userData = ctxt->sax->endDocument;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      userData = ctxt->sax->startDocument;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    userData = ctxt->sax->setDocumentLocator;
                                                  }
                                                }
                                                else
                                                {
                                                  userData = ctxt->sax->unparsedEntityDecl;
                                                }
                                              }
                                              else
                                              {
                                                userData = ctxt->sax->elementDecl;
                                              }
                                            }
                                            else
                                            {
                                              userData = ctxt->sax->attributeDecl;
                                            }
                                          }
                                          else
                                          {
                                            userData = ctxt->sax->notationDecl;
                                          }
                                        }
                                        else
                                        {
                                          userData = ctxt->sax->entityDecl;
                                        }
                                      }
                                      else
                                      {
                                        userData = ctxt->sax->getEntity;
                                      }
                                    }
                                    else
                                    {
                                      userData = ctxt->sax->resolveEntity;
                                    }
                                  }
                                  else
                                  {
                                    userData = ctxt->sax->hasExternalSubset;
                                  }
                                }
                                else
                                {
                                  userData = ctxt->sax->hasInternalSubset;
                                }
                              }
                              else
                              {
                                userData = ctxt->sax->isStandalone;
                              }
                            }
                            else
                            {
                              userData = ctxt->sax->internalSubset;
                            }
                          }
                          else
                          {
                            userData = ctxt->sax;
                          }
                          goto LABEL_52;
                        }
                        valid = ctxt->valid;
                      }
                      else
                      {
                        valid = ctxt->wellFormed;
                      }
                      goto LABEL_58;
                    }
                    userData = ctxt->myDoc;
LABEL_52:
                    *(_QWORD *)result = userData;
                    return v4;
                  }
                  valid = ctxt->standalone;
                }
                else
                {
                  valid = ctxt->html;
                }
              }
              else
              {
                valid = ctxt->record_info;
              }
            }
            else
            {
              valid = ctxt->replaceEntities;
            }
          }
          else
          {
            valid = ctxt->loadsubset;
          }
        }
        else
        {
          valid = ctxt->disableSAX;
        }
      }
      else
      {
        valid = ctxt->keepBlanks;
      }
    }
    else
    {
      valid = ctxt->validate;
    }
LABEL_58:
    *(_DWORD *)result = valid;
  }
  return v4;
}

int xmlSetFeature(xmlParserCtxtPtr ctxt, const char *name, void *value)
{
  int result;
  int v7;

  result = -1;
  if (ctxt && name && value)
  {
    if (!strcmp(name, "validate"))
    {
      v7 = *(_DWORD *)value;
      if (!ctxt->validate && v7)
      {
        if (!ctxt->vctxt.warning)
          ctxt->vctxt.warning = xmlParserValidityWarning;
        if (!ctxt->vctxt.error)
          ctxt->vctxt.error = xmlParserValidityError;
        ctxt->vctxt.nodeMax = 0;
      }
      result = 0;
      ctxt->validate = v7;
    }
    else
    {
      result = strcmp(name, "keep blanks");
      if (result)
      {
        result = strcmp(name, "disable SAX");
        if (result)
        {
          result = strcmp(name, "fetch external entities");
          if (result)
          {
            result = strcmp(name, "substitute entities");
            if (result)
            {
              result = strcmp(name, "gather line info");
              if (result)
              {
                result = strcmp(name, "user data");
                if (result)
                {
                  result = strcmp(name, "is html");
                  if (result)
                  {
                    result = strcmp(name, "is standalone");
                    if (result)
                    {
                      result = strcmp(name, "document");
                      if (result)
                      {
                        result = strcmp(name, "is well formed");
                        if (result)
                        {
                          result = strcmp(name, "is valid");
                          if (result)
                          {
                            result = strcmp(name, "SAX block");
                            if (result)
                            {
                              result = strcmp(name, "SAX function internalSubset");
                              if (result)
                              {
                                result = strcmp(name, "SAX function isStandalone");
                                if (result)
                                {
                                  result = strcmp(name, "SAX function hasInternalSubset");
                                  if (result)
                                  {
                                    result = strcmp(name, "SAX function hasExternalSubset");
                                    if (result)
                                    {
                                      result = strcmp(name, "SAX function resolveEntity");
                                      if (result)
                                      {
                                        result = strcmp(name, "SAX function getEntity");
                                        if (result)
                                        {
                                          result = strcmp(name, "SAX function entityDecl");
                                          if (result)
                                          {
                                            result = strcmp(name, "SAX function notationDecl");
                                            if (result)
                                            {
                                              result = strcmp(name, "SAX function attributeDecl");
                                              if (result)
                                              {
                                                result = strcmp(name, "SAX function elementDecl");
                                                if (result)
                                                {
                                                  result = strcmp(name, "SAX function unparsedEntityDecl");
                                                  if (result)
                                                  {
                                                    result = strcmp(name, "SAX function setDocumentLocator");
                                                    if (result)
                                                    {
                                                      result = strcmp(name, "SAX function startDocument");
                                                      if (result)
                                                      {
                                                        result = strcmp(name, "SAX function endDocument");
                                                        if (result)
                                                        {
                                                          result = strcmp(name, "SAX function startElement");
                                                          if (result)
                                                          {
                                                            result = strcmp(name, "SAX function endElement");
                                                            if (result)
                                                            {
                                                              result = strcmp(name, "SAX function reference");
                                                              if (result)
                                                              {
                                                                result = strcmp(name, "SAX function characters");
                                                                if (result)
                                                                {
                                                                  result = strcmp(name, "SAX function ignorableWhitespace");
                                                                  if (result)
                                                                  {
                                                                    result = strcmp(name, "SAX function processingInstruction");
                                                                    if (result)
                                                                    {
                                                                      result = strcmp(name, "SAX function comment");
                                                                      if (result)
                                                                      {
                                                                        result = strcmp(name, "SAX function warning");
                                                                        if (result)
                                                                        {
                                                                          result = strcmp(name, "SAX function error");
                                                                          if (result)
                                                                          {
                                                                            result = strcmp(name, "SAX function fatalError");
                                                                            if (result)
                                                                            {
                                                                              result = strcmp(name, "SAX function getParameterEntity");
                                                                              if (result)
                                                                              {
                                                                                result = strcmp(name, "SAX function cdataBlock");
                                                                                if (result)
                                                                                {
                                                                                  result = strcmp(name, "SAX function externalSubset");
                                                                                  if (result)
                                                                                    return -1;
                                                                                  else
                                                                                    ctxt->sax->externalSubset = *(externalSubsetSAXFunc *)value;
                                                                                }
                                                                                else
                                                                                {
                                                                                  ctxt->sax->cdataBlock = *(cdataBlockSAXFunc *)value;
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                ctxt->sax->getParameterEntity = *(getParameterEntitySAXFunc *)value;
                                                                              }
                                                                            }
                                                                            else
                                                                            {
                                                                              ctxt->sax->fatalError = *(fatalErrorSAXFunc *)value;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            ctxt->sax->error = *(errorSAXFunc *)value;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          ctxt->sax->warning = *(warningSAXFunc *)value;
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        ctxt->sax->comment = *(commentSAXFunc *)value;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      ctxt->sax->processingInstruction = *(processingInstructionSAXFunc *)value;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    ctxt->sax->ignorableWhitespace = *(ignorableWhitespaceSAXFunc *)value;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  ctxt->sax->characters = *(charactersSAXFunc *)value;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                ctxt->sax->reference = *(referenceSAXFunc *)value;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              ctxt->sax->endElement = *(endElementSAXFunc *)value;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            ctxt->sax->startElement = *(startElementSAXFunc *)value;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          ctxt->sax->endDocument = *(endDocumentSAXFunc *)value;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        ctxt->sax->startDocument = *(startDocumentSAXFunc *)value;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      ctxt->sax->setDocumentLocator = *(setDocumentLocatorSAXFunc *)value;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    ctxt->sax->unparsedEntityDecl = *(unparsedEntityDeclSAXFunc *)value;
                                                  }
                                                }
                                                else
                                                {
                                                  ctxt->sax->elementDecl = *(elementDeclSAXFunc *)value;
                                                }
                                              }
                                              else
                                              {
                                                ctxt->sax->attributeDecl = *(attributeDeclSAXFunc *)value;
                                              }
                                            }
                                            else
                                            {
                                              ctxt->sax->notationDecl = *(notationDeclSAXFunc *)value;
                                            }
                                          }
                                          else
                                          {
                                            ctxt->sax->entityDecl = *(entityDeclSAXFunc *)value;
                                          }
                                        }
                                        else
                                        {
                                          ctxt->sax->getEntity = *(getEntitySAXFunc *)value;
                                        }
                                      }
                                      else
                                      {
                                        ctxt->sax->resolveEntity = *(resolveEntitySAXFunc *)value;
                                      }
                                    }
                                    else
                                    {
                                      ctxt->sax->hasExternalSubset = *(hasExternalSubsetSAXFunc *)value;
                                    }
                                  }
                                  else
                                  {
                                    ctxt->sax->hasInternalSubset = *(hasInternalSubsetSAXFunc *)value;
                                  }
                                }
                                else
                                {
                                  ctxt->sax->isStandalone = *(isStandaloneSAXFunc *)value;
                                }
                              }
                              else
                              {
                                ctxt->sax->internalSubset = *(internalSubsetSAXFunc *)value;
                              }
                            }
                            else
                            {
                              ctxt->sax = *(_xmlSAXHandler **)value;
                            }
                          }
                          else
                          {
                            ctxt->valid = *(_DWORD *)value;
                          }
                        }
                        else
                        {
                          ctxt->wellFormed = *(_DWORD *)value;
                        }
                      }
                      else
                      {
                        ctxt->myDoc = *(xmlDocPtr *)value;
                      }
                    }
                    else
                    {
                      ctxt->standalone = *(_DWORD *)value;
                    }
                  }
                  else
                  {
                    ctxt->html = *(_DWORD *)value;
                  }
                }
                else
                {
                  ctxt->userData = *(void **)value;
                }
              }
              else
              {
                ctxt->record_info = *(_DWORD *)value;
              }
            }
            else
            {
              ctxt->replaceEntities = *(_DWORD *)value;
            }
          }
          else
          {
            ctxt->loadsubset = *(_DWORD *)value;
          }
        }
        else
        {
          ctxt->disableSAX = *(_DWORD *)value;
        }
      }
      else
      {
        ctxt->keepBlanks = *(_DWORD *)value;
      }
    }
  }
  return result;
}

xmlChar *__cdecl xmlDecodeEntities(xmlParserCtxtPtr ctxt, int len, int what, xmlChar end, xmlChar end2, xmlChar end3)
{
  xmlGenericErrorFunc v6;
  void **v7;

  if ((xmlDecodeEntities_deprecated & 1) == 0)
  {
    v6 = *__xmlGenericError();
    v7 = __xmlGenericErrorContext();
    v6(*v7, "xmlDecodeEntities() deprecated function reached\n");
    xmlDecodeEntities_deprecated = 1;
  }
  return 0;
}

xmlChar *__cdecl xmlNamespaceParseNCName(xmlParserCtxtPtr ctxt)
{
  xmlGenericErrorFunc v1;
  void **v2;

  if ((xmlNamespaceParseNCName_deprecated & 1) == 0)
  {
    v1 = *__xmlGenericError();
    v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlNamespaceParseNCName() deprecated function reached\n");
    xmlNamespaceParseNCName_deprecated = 1;
  }
  return 0;
}

xmlChar *__cdecl xmlNamespaceParseQName(xmlParserCtxtPtr ctxt, xmlChar **prefix)
{
  xmlGenericErrorFunc v2;
  void **v3;

  if ((xmlNamespaceParseQName_deprecated & 1) == 0)
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "xmlNamespaceParseQName() deprecated function reached\n");
    xmlNamespaceParseQName_deprecated = 1;
  }
  return 0;
}

xmlChar *__cdecl xmlNamespaceParseNSDef(xmlParserCtxtPtr ctxt)
{
  xmlGenericErrorFunc v1;
  void **v2;

  if ((xmlNamespaceParseNSDef_deprecated & 1) == 0)
  {
    v1 = *__xmlGenericError();
    v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlNamespaceParseNSDef() deprecated function reached\n");
    xmlNamespaceParseNSDef_deprecated = 1;
  }
  return 0;
}

xmlChar *__cdecl xmlParseQuotedString(xmlParserCtxtPtr ctxt)
{
  xmlGenericErrorFunc v1;
  void **v2;

  if ((xmlParseQuotedString_deprecated & 1) == 0)
  {
    v1 = *__xmlGenericError();
    v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlParseQuotedString() deprecated function reached\n");
    xmlParseQuotedString_deprecated = 1;
  }
  return 0;
}

void xmlParseNamespace(xmlParserCtxtPtr ctxt)
{
  xmlGenericErrorFunc v1;
  void **v2;

  if ((xmlParseNamespace_deprecated & 1) == 0)
  {
    v1 = *__xmlGenericError();
    v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlParseNamespace() deprecated function reached\n");
    xmlParseNamespace_deprecated = 1;
  }
}

xmlChar *__cdecl xmlScanName(xmlParserCtxtPtr ctxt)
{
  xmlGenericErrorFunc v1;
  void **v2;

  if ((xmlScanName_deprecated & 1) == 0)
  {
    v1 = *__xmlGenericError();
    v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlScanName() deprecated function reached\n");
    xmlScanName_deprecated = 1;
  }
  return 0;
}

void xmlParserHandleReference(xmlParserCtxtPtr ctxt)
{
  xmlGenericErrorFunc v1;
  void **v2;

  if ((xmlParserHandleReference_deprecated & 1) == 0)
  {
    v1 = *__xmlGenericError();
    v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlParserHandleReference() deprecated function reached\n");
    xmlParserHandleReference_deprecated = 1;
  }
}

void xmlHandleEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr entity)
{
  xmlGenericErrorFunc v2;
  void **v3;

  if ((xmlHandleEntity_deprecated & 1) == 0)
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "xmlHandleEntity() deprecated function reached\n");
    xmlHandleEntity_deprecated = 1;
  }
}

xmlNsPtr xmlNewGlobalNs(xmlDocPtr doc, const xmlChar *href, const xmlChar *prefix)
{
  xmlGenericErrorFunc v3;
  void **v4;

  if ((xmlNewGlobalNs_deprecated & 1) == 0)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "xmlNewGlobalNs() deprecated function reached\n");
    xmlNewGlobalNs_deprecated = 1;
  }
  return 0;
}

const xmlChar *__cdecl xmlEncodeEntities(xmlDocPtr doc, const xmlChar *input)
{
  xmlGenericErrorFunc v2;
  void **v3;
  xmlGenericErrorFunc v4;
  void **v5;

  if ((xmlEncodeEntities_warning & 1) == 0)
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "Deprecated API xmlEncodeEntities() used\n");
    v4 = *__xmlGenericError();
    v5 = __xmlGenericErrorContext();
    v4(*v5, "   change code to use xmlEncodeEntitiesReentrant()\n");
    xmlEncodeEntities_warning = 1;
  }
  return 0;
}

const xmlChar *__cdecl getPublicId(void *ctx)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getPublicId");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
  return xmlSAX2GetPublicId(ctx);
}

const xmlChar *__cdecl getSystemId(void *ctx)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getSystemId");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
  return xmlSAX2GetSystemId(ctx);
}

int getLineNumber(void *ctx)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getLineNumber");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
  return xmlSAX2GetLineNumber(ctx);
}

int getColumnNumber(void *ctx)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getColumnNumber");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
  return xmlSAX2GetColumnNumber(ctx);
}

int isStandalone(void *ctx)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "isStandalone");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
  return xmlSAX2IsStandalone(ctx);
}

int hasInternalSubset(void *ctx)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "hasInternalSubset");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
  return xmlSAX2HasInternalSubset(ctx);
}

int hasExternalSubset(void *ctx)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "hasExternalSubset");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
  return xmlSAX2HasExternalSubset(ctx);
}

void internalSubset(void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  int v8;
  xmlGenericErrorFunc v9;
  void **v10;

  v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v9 = *__xmlGenericError();
    v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "internalSubset");
    v8 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v8 + 1;
  xmlSAX2InternalSubset(ctx, name, ExternalID, SystemID);
}

void externalSubset(void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  int v8;
  xmlGenericErrorFunc v9;
  void **v10;

  v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v9 = *__xmlGenericError();
    v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "externalSubset");
    v8 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v8 + 1;
  xmlSAX2ExternalSubset(ctx, name, ExternalID, SystemID);
}

xmlParserInputPtr resolveEntity(void *ctx, const xmlChar *publicId, const xmlChar *systemId)
{
  int v6;
  xmlGenericErrorFunc v7;
  void **v8;

  v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v7 = *__xmlGenericError();
    v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "resolveEntity");
    v6 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v6 + 1;
  return xmlSAX2ResolveEntity(ctx, publicId, systemId);
}

xmlEntityPtr getEntity(void *ctx, const xmlChar *name)
{
  int v4;
  xmlGenericErrorFunc v5;
  void **v6;

  v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v5 = *__xmlGenericError();
    v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "getEntity");
    v4 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v4 + 1;
  return xmlSAX2GetEntity(ctx, name);
}

xmlEntityPtr getParameterEntity(void *ctx, const xmlChar *name)
{
  int v4;
  xmlGenericErrorFunc v5;
  void **v6;

  v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v5 = *__xmlGenericError();
    v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "getParameterEntity");
    v4 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v4 + 1;
  return xmlSAX2GetParameterEntity(ctx, name);
}

void entityDecl(void *ctx, const xmlChar *name, int type, const xmlChar *publicId, const xmlChar *systemId, xmlChar *content)
{
  int v12;
  xmlGenericErrorFunc v13;
  void **v14;

  v12 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v13 = *__xmlGenericError();
    v14 = __xmlGenericErrorContext();
    v13(*v14, "Use of deprecated SAXv1 function %s\n", "entityDecl");
    v12 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v12 + 1;
  xmlSAX2EntityDecl(ctx, name, type, publicId, systemId, content);
}

void attributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname, int type, int def, const xmlChar *defaultValue, xmlEnumerationPtr tree)
{
  int v14;
  xmlGenericErrorFunc v15;
  void **v16;

  v14 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v15 = *__xmlGenericError();
    v16 = __xmlGenericErrorContext();
    v15(*v16, "Use of deprecated SAXv1 function %s\n", "attributeDecl");
    v14 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v14 + 1;
  xmlSAX2AttributeDecl(ctx, elem, fullname, type, def, defaultValue, tree);
}

void elementDecl(void *ctx, const xmlChar *name, int type, xmlElementContentPtr content)
{
  int v8;
  xmlGenericErrorFunc v9;
  void **v10;

  v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v9 = *__xmlGenericError();
    v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "elementDecl");
    v8 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v8 + 1;
  xmlSAX2ElementDecl(ctx, name, type, content);
}

void notationDecl(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId)
{
  int v8;
  xmlGenericErrorFunc v9;
  void **v10;

  v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v9 = *__xmlGenericError();
    v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "notationDecl");
    v8 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v8 + 1;
  xmlSAX2NotationDecl(ctx, name, publicId, systemId);
}

void unparsedEntityDecl(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId, const xmlChar *notationName)
{
  int v10;
  xmlGenericErrorFunc v11;
  void **v12;

  v10 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v11 = *__xmlGenericError();
    v12 = __xmlGenericErrorContext();
    v11(*v12, "Use of deprecated SAXv1 function %s\n", "unparsedEntityDecl");
    v10 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v10 + 1;
  xmlSAX2UnparsedEntityDecl(ctx, name, publicId, systemId, notationName);
}

void setDocumentLocator(void *ctx, xmlSAXLocatorPtr loc)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "setDocumentLocator");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
}

void endDocument(void *ctx)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "endDocument");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
  xmlSAX2EndDocument(ctx);
}

void attribute(void *ctx, const xmlChar *fullname, const xmlChar *value)
{
  int v3;
  xmlGenericErrorFunc v4;
  void **v5;

  v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v4 = *__xmlGenericError();
    v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "attribute");
    v3 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v3 + 1;
}

void endElement(void *ctx, const xmlChar *name)
{
  int v4;
  xmlGenericErrorFunc v5;
  void **v6;

  v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v5 = *__xmlGenericError();
    v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "endElement");
    v4 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v4 + 1;
  xmlSAX2EndElement(ctx, name);
}

void reference(void *ctx, const xmlChar *name)
{
  int v4;
  xmlGenericErrorFunc v5;
  void **v6;

  v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v5 = *__xmlGenericError();
    v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "reference");
    v4 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v4 + 1;
  xmlSAX2Reference(ctx, name);
}

void characters(void *ctx, const xmlChar *ch, int len)
{
  int v6;
  xmlGenericErrorFunc v7;
  void **v8;

  v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v7 = *__xmlGenericError();
    v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "characters");
    v6 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v6 + 1;
  xmlSAX2Characters(ctx, ch, len);
}

void ignorableWhitespace(void *ctx, const xmlChar *ch, int len)
{
  int v3;
  xmlGenericErrorFunc v4;
  void **v5;

  v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v4 = *__xmlGenericError();
    v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "ignorableWhitespace");
    v3 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v3 + 1;
}

void processingInstruction(void *ctx, const xmlChar *target, const xmlChar *data)
{
  int v6;
  xmlGenericErrorFunc v7;
  void **v8;

  v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v7 = *__xmlGenericError();
    v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "processingInstruction");
    v6 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v6 + 1;
  xmlSAX2ProcessingInstruction(ctx, target, data);
}

void globalNamespace(void *ctx, const xmlChar *href, const xmlChar *prefix)
{
  int v3;
  xmlGenericErrorFunc v4;
  void **v5;

  v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v4 = *__xmlGenericError();
    v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "globalNamespace");
    v3 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v3 + 1;
}

void setNamespace(void *ctx, const xmlChar *name)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "setNamespace");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
}

xmlNsPtr getNamespace(void *ctx)
{
  int v1;
  xmlGenericErrorFunc v2;
  void **v3;

  v1 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "Use of deprecated SAXv1 function %s\n", "getNamespace");
    v1 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v1 + 1;
  return 0;
}

int checkNamespace(void *ctx, xmlChar *nameSpace)
{
  int v2;
  xmlGenericErrorFunc v3;
  void **v4;

  v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v3 = *__xmlGenericError();
    v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "checkNamespace");
    v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
  return 0;
}

void namespaceDecl(void *ctx, const xmlChar *href, const xmlChar *prefix)
{
  int v3;
  xmlGenericErrorFunc v4;
  void **v5;

  v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v4 = *__xmlGenericError();
    v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "namespaceDecl");
    v3 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v3 + 1;
}

void comment(void *ctx, const xmlChar *value)
{
  int v4;
  xmlGenericErrorFunc v5;
  void **v6;

  v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v5 = *__xmlGenericError();
    v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "comment");
    v4 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v4 + 1;
  xmlSAX2Comment(ctx, value);
}

void cdataBlock(void *ctx, const xmlChar *value, int len)
{
  int v6;
  xmlGenericErrorFunc v7;
  void **v8;

  v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    v7 = *__xmlGenericError();
    v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "cdataBlock");
    v6 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v6 + 1;
  xmlSAX2CDataBlock(ctx, value, len);
}

xmlListPtr xmlListCreate(xmlListDeallocator deallocator, xmlListDataCompare compare)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  xmlGenericErrorFunc v7;
  void **v8;
  xmlGenericErrorFunc v9;
  void **v10;

  v4 = xmlMalloc(0x18uLL);
  if (!v4)
  {
    v7 = *__xmlGenericError();
    v8 = __xmlGenericErrorContext();
    v7(*v8, "Cannot initialize memory for list");
    return 0;
  }
  v5 = v4;
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  v6 = xmlMalloc(0x18uLL);
  *v5 = v6;
  if (!v6)
  {
    v9 = *__xmlGenericError();
    v10 = __xmlGenericErrorContext();
    v9(*v10, "Cannot initialize memory for sentinel");
    xmlFree(v5);
    return 0;
  }
  *v6 = v6;
  v6[1] = v6;
  v6[2] = 0;
  if (deallocator)
    v5[1] = deallocator;
  if (compare)
    v5[2] = compare;
  else
    v5[2] = xmlLinkCompare;
  return (xmlListPtr)v5;
}

uint64_t xmlLinkCompare(unint64_t a1, unint64_t a2)
{
  if (a1 < a2)
    return 0xFFFFFFFFLL;
  else
    return a1 != a2;
}

void *__cdecl xmlListSearch(void *l, void *data)
{
  if (l)
  {
    l = xmlListLinkSearch((uint64_t)l, (uint64_t)data);
    if (l)
      return (void *)*((_QWORD *)l + 2);
  }
  return l;
}

_QWORD *xmlListLinkSearch(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  v4 = *(_QWORD **)a1;
  do
  {
    v4 = (_QWORD *)*v4;
    if (v4 == *(_QWORD **)a1)
      return 0;
  }
  while (((*(uint64_t (**)(_QWORD, uint64_t))(a1 + 16))(v4[2], a2) & 0x80000000) != 0);
  if (v4 == *(_QWORD **)a1)
    return 0;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(a1 + 16))(v4[2], a2))
    return 0;
  else
    return v4;
}

void *__cdecl xmlListReverseSearch(void *l, void *data)
{
  if (l)
  {
    l = (void *)xmlListLinkReverseSearch((uint64_t *)l, (uint64_t)data);
    if (l)
      return (void *)*((_QWORD *)l + 2);
  }
  return l;
}

uint64_t xmlListLinkReverseSearch(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *a1;
  do
  {
    v4 = *(_QWORD *)(v4 + 8);
    if (v4 == *a1)
      return 0;
  }
  while (((int (*)(_QWORD, uint64_t))a1[2])(*(_QWORD *)(v4 + 16), a2) > 0);
  if (v4 == *a1)
    return 0;
  if (((unsigned int (*)(_QWORD, uint64_t))a1[2])(*(_QWORD *)(v4 + 16), a2))
    return 0;
  else
    return v4;
}

int xmlListInsert(xmlListPtr l, void *data)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  int result;
  uint64_t v8;
  xmlGenericErrorFunc v9;
  void **v10;

  if (!l)
    return 1;
  v4 = *(_QWORD **)l;
  do
    v4 = (_QWORD *)*v4;
  while (v4 != *(_QWORD **)l && ((*((uint64_t (**)(_QWORD, void *))l + 2))(v4[2], data) & 0x80000000) != 0);
  v5 = xmlMalloc(0x18uLL);
  if (v5)
  {
    v6 = v5;
    result = 0;
    v8 = v4[1];
    *v6 = *(_QWORD *)v8;
    *(_QWORD *)(*(_QWORD *)v8 + 8) = v6;
    *(_QWORD *)v8 = v6;
    v6[1] = v8;
    v6[2] = data;
  }
  else
  {
    v9 = *__xmlGenericError();
    v10 = __xmlGenericErrorContext();
    v9(*v10, "Cannot initialize memory for new link");
    return 1;
  }
  return result;
}

int xmlListAppend(xmlListPtr l, void *data)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  int result;
  xmlGenericErrorFunc v8;
  void **v9;

  if (!l)
    return 1;
  v4 = *(_QWORD **)l;
  do
    v4 = (_QWORD *)v4[1];
  while (v4 != *(_QWORD **)l && (*((int (**)(_QWORD, void *))l + 2))(v4[2], data) > 0);
  v5 = xmlMalloc(0x18uLL);
  if (v5)
  {
    v6 = v5;
    result = 0;
    *v6 = *v4;
    *(_QWORD *)(*v4 + 8) = v6;
    *v4 = v6;
    v6[1] = v4;
    v6[2] = data;
  }
  else
  {
    v8 = *__xmlGenericError();
    v9 = __xmlGenericErrorContext();
    v8(*v9, "Cannot initialize memory for new link");
    return 1;
  }
  return result;
}

void xmlListDelete(xmlListPtr l)
{
  if (l)
  {
    xmlListClear(l);
    xmlFree(*(void **)l);
    xmlFree(l);
  }
}

void xmlListClear(xmlListPtr l)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  void (*v5)(_QWORD *);

  if (l)
  {
    v2 = **(_QWORD ***)l;
    if (v2 != *(_QWORD **)l)
    {
      do
      {
        v4 = (_QWORD *)*v2;
        v3 = (_QWORD *)v2[1];
        *v3 = *v2;
        *(_QWORD *)(*v2 + 8) = v3;
        v5 = (void (*)(_QWORD *))*((_QWORD *)l + 1);
        if (v5)
          v5(v2);
        xmlFree(v2);
        v2 = v4;
      }
      while (v4 != *(_QWORD **)l);
    }
  }
}

int xmlListRemoveFirst(xmlListPtr l, void *data)
{
  xmlListPtr v2;
  xmlListPtr v3;
  _QWORD *v4;
  void (*v5)(xmlListPtr);

  if (l)
  {
    v2 = l;
    l = (xmlListPtr)xmlListLinkSearch((uint64_t)l, (uint64_t)data);
    if (l)
    {
      v3 = l;
      v4 = (_QWORD *)*((_QWORD *)l + 1);
      *v4 = *(_QWORD *)l;
      *(_QWORD *)(*(_QWORD *)l + 8) = v4;
      v5 = (void (*)(xmlListPtr))*((_QWORD *)v2 + 1);
      if (v5)
        v5(l);
      xmlFree(v3);
      LODWORD(l) = 1;
    }
  }
  return (int)l;
}

int xmlListRemoveLast(xmlListPtr l, void *data)
{
  xmlListPtr v2;
  xmlListPtr v3;
  _QWORD *v4;
  void (*v5)(xmlListPtr);

  if (l)
  {
    v2 = l;
    l = (xmlListPtr)xmlListLinkReverseSearch((uint64_t *)l, (uint64_t)data);
    if (l)
    {
      v3 = l;
      v4 = (_QWORD *)*((_QWORD *)l + 1);
      *v4 = *(_QWORD *)l;
      *(_QWORD *)(*(_QWORD *)l + 8) = v4;
      v5 = (void (*)(xmlListPtr))*((_QWORD *)v2 + 1);
      if (v5)
        v5(l);
      xmlFree(v3);
      LODWORD(l) = 1;
    }
  }
  return (int)l;
}

int xmlListRemoveAll(xmlListPtr l, void *data)
{
  int v4;

  if (!l)
    return 0;
  v4 = -1;
  do
    ++v4;
  while (xmlListRemoveFirst(l, data));
  return v4;
}

int xmlListEmpty(xmlListPtr l)
{
  if (l)
    return **(_QWORD **)l == *(_QWORD *)l;
  else
    return -1;
}

xmlLinkPtr xmlListFront(xmlLinkPtr l)
{
  if (l)
    return **(xmlLinkPtr **)l;
  return l;
}

xmlLinkPtr xmlListEnd(xmlLinkPtr l)
{
  if (l)
    return *(xmlLinkPtr *)(*(_QWORD *)l + 8);
  return l;
}

int xmlListSize(xmlListPtr l)
{
  _QWORD *v1;
  int result;
  _QWORD *v3;

  if (!l)
    return -1;
  v1 = *(_QWORD **)l;
  result = -1;
  v3 = v1;
  do
  {
    v3 = (_QWORD *)*v3;
    ++result;
  }
  while (v3 != v1);
  return result;
}

void xmlListPopFront(xmlListPtr l)
{
  _QWORD *v1;
  _QWORD *v2;
  void (*v3)(_QWORD *);

  if (l)
  {
    v1 = **(_QWORD ***)l;
    if (v1 != *(_QWORD **)l)
    {
      v2 = (_QWORD *)v1[1];
      *v2 = *v1;
      *(_QWORD *)(*v1 + 8) = v2;
      v3 = (void (*)(_QWORD *))*((_QWORD *)l + 1);
      if (v3)
        v3(v1);
      xmlFree(v1);
    }
  }
}

void xmlListPopBack(xmlListPtr l)
{
  _QWORD *v1;
  _QWORD *v2;
  void (*v3)(_QWORD *);

  if (l && **(_QWORD **)l != *(_QWORD *)l)
  {
    v1 = *(_QWORD **)(*(_QWORD *)l + 8);
    v2 = (_QWORD *)v1[1];
    *v2 = *v1;
    *(_QWORD *)(*v1 + 8) = v2;
    v3 = (void (*)(_QWORD *))*((_QWORD *)l + 1);
    if (v3)
      v3(v1);
    xmlFree(v1);
  }
}

int xmlListPushFront(xmlListPtr l, void *data)
{
  uint64_t v3;
  xmlGenericErrorFunc v4;
  void **v5;

  if (l)
  {
    v3 = *(_QWORD *)l;
    l = (xmlListPtr)xmlMalloc(0x18uLL);
    if (l)
    {
      *(_QWORD *)l = *(_QWORD *)v3;
      *(_QWORD *)(*(_QWORD *)v3 + 8) = l;
      *(_QWORD *)v3 = l;
      *((_QWORD *)l + 1) = v3;
      *((_QWORD *)l + 2) = data;
      LODWORD(l) = 1;
    }
    else
    {
      v4 = *__xmlGenericError();
      v5 = __xmlGenericErrorContext();
      v4(*v5, "Cannot initialize memory for new link");
      LODWORD(l) = 0;
    }
  }
  return (int)l;
}

int xmlListPushBack(xmlListPtr l, void *data)
{
  uint64_t v3;
  xmlGenericErrorFunc v4;
  void **v5;

  if (l)
  {
    v3 = *(_QWORD *)(*(_QWORD *)l + 8);
    l = (xmlListPtr)xmlMalloc(0x18uLL);
    if (l)
    {
      *(_QWORD *)l = *(_QWORD *)v3;
      *(_QWORD *)(*(_QWORD *)v3 + 8) = l;
      *(_QWORD *)v3 = l;
      *((_QWORD *)l + 1) = v3;
      *((_QWORD *)l + 2) = data;
      LODWORD(l) = 1;
    }
    else
    {
      v4 = *__xmlGenericError();
      v5 = __xmlGenericErrorContext();
      v4(*v5, "Cannot initialize memory for new link");
      LODWORD(l) = 0;
    }
  }
  return (int)l;
}

void *__cdecl xmlLinkGetData(void *lk)
{
  if (lk)
    return (void *)*((_QWORD *)lk + 2);
  return lk;
}

void xmlListReverse(xmlListPtr l)
{
  _QWORD **v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;

  if (l)
  {
    v1 = *(_QWORD ***)l;
    v2 = **(_QWORD ***)l;
    v3 = *(_QWORD **)l;
    if (v2 != *(_QWORD **)l)
    {
      v4 = *(_QWORD **)l;
      do
      {
        v3 = v2;
        *v4 = v4[1];
        v4[1] = v2;
        v2 = (_QWORD *)*v2;
        v4 = v3;
      }
      while (v2 != v1);
    }
    *v3 = v3[1];
    v3[1] = v1;
  }
}

void xmlListSort(xmlListPtr l)
{
  xmlListPtr v2;
  xmlList *v3;

  if (l && **(_QWORD **)l != *(_QWORD *)l)
  {
    v2 = xmlListDup(l);
    if (v2)
    {
      v3 = v2;
      xmlListClear(l);
      xmlListCopy(l, v3);
      xmlListClear(v3);
      xmlListClear(v3);
      xmlFree(*(void **)v3);
      xmlFree(v3);
    }
  }
}

xmlListPtr xmlListDup(xmlListPtr old)
{
  xmlList *v1;
  xmlList *v2;

  if (old)
  {
    v1 = old;
    old = xmlListCreate(0, *((xmlListDataCompare *)old + 2));
    if (old)
    {
      v2 = old;
      if (xmlListCopy(old, v1))
        return 0;
      else
        return v2;
    }
  }
  return old;
}

void xmlListMerge(xmlListPtr l1, xmlListPtr l2)
{
  xmlListCopy(l1, l2);
  xmlListClear(l2);
}

void xmlListWalk(xmlListPtr l, xmlListWalker walker, void *user)
{
  _QWORD *v6;

  if (l && walker)
  {
    v6 = *(_QWORD **)l;
    do
      v6 = (_QWORD *)*v6;
    while (v6 != *(_QWORD **)l && ((unsigned int (*)(_QWORD, void *))walker)(v6[2], user));
  }
}

void xmlListReverseWalk(xmlListPtr l, xmlListWalker walker, void *user)
{
  uint64_t v6;

  if (l && walker)
  {
    v6 = *(_QWORD *)l;
    do
      v6 = *(_QWORD *)(v6 + 8);
    while (v6 != *(_QWORD *)l && ((unsigned int (*)(_QWORD, void *))walker)(*(_QWORD *)(v6 + 16), user));
  }
}

int xmlListCopy(xmlListPtr cur, const xmlListPtr old)
{
  int result;
  uint64_t *v5;

  result = 1;
  if (cur && old)
  {
    v5 = *(uint64_t **)old;
    while (1)
    {
      v5 = (uint64_t *)*v5;
      if (v5 == *(uint64_t **)old)
        break;
      if (xmlListInsert(cur, (void *)v5[2]))
      {
        xmlListClear(cur);
        xmlFree(*(void **)cur);
        xmlFree(cur);
        return 1;
      }
    }
    return 0;
  }
  return result;
}

void xmlNanoFTPInit(void)
{
  char *v0;
  char *v1;
  char *v2;
  char *v3;

  if ((initialized & 1) == 0)
  {
    proxyPort = 21;
    v0 = getenv("no_proxy");
    if (!v0 || *v0 != 42 || v0[1])
    {
      v1 = getenv("ftp_proxy");
      if (v1 || (v1 = getenv("FTP_PROXY")) != 0)
        xmlNanoFTPScanProxy(v1);
      v2 = getenv("ftp_proxy_user");
      if (v2)
        proxyUser = (uint64_t)xmlMemStrdup(v2);
      v3 = getenv("ftp_proxy_password");
      if (v3)
        proxyPasswd = (uint64_t)xmlMemStrdup(v3);
      initialized = 1;
    }
  }
}

void xmlNanoFTPScanProxy(const char *URL)
{
  xmlURIPtr v2;
  xmlURI *v3;
  const char *scheme;
  const char *server;

  if (proxy)
  {
    xmlFree((void *)proxy);
    proxy = 0;
  }
  proxyPort = 0;
  if (URL)
  {
    v2 = xmlParseURIRaw(URL, 1);
    if (v2)
    {
      v3 = v2;
      scheme = v2->scheme;
      if (scheme && !strcmp(scheme, "ftp") && (server = v3->server) != 0)
      {
        proxy = (uint64_t)xmlMemStrdup(server);
        if (v3->port)
          proxyPort = v3->port;
      }
      else
      {
        __xmlIOErr(9u, 2003, (const xmlChar *)"Syntax Error\n");
      }
      xmlFreeURI(v3);
    }
    else
    {
      __xmlIOErr(9u, 2003, (const xmlChar *)"Syntax Error\n");
    }
  }
}

void xmlNanoFTPCleanup(void)
{
  if (proxy)
  {
    xmlFree((void *)proxy);
    proxy = 0;
  }
  if (proxyUser)
  {
    xmlFree((void *)proxyUser);
    proxyUser = 0;
  }
  if (proxyPasswd)
  {
    xmlFree((void *)proxyPasswd);
    proxyPasswd = 0;
  }
  initialized = 0;
}

void xmlNanoFTPProxy(const char *host, int port, const char *user, const char *passwd, int type)
{
  if (proxy)
  {
    xmlFree((void *)proxy);
    proxy = 0;
  }
  if (proxyUser)
  {
    xmlFree((void *)proxyUser);
    proxyUser = 0;
  }
  if (proxyPasswd)
  {
    xmlFree((void *)proxyPasswd);
    proxyPasswd = 0;
  }
  if (host)
    proxy = (uint64_t)xmlMemStrdup(host);
  if (user)
    proxyUser = (uint64_t)xmlMemStrdup(user);
  if (passwd)
    proxyPasswd = (uint64_t)xmlMemStrdup(passwd);
  proxyPort = port;
  proxyType = type;
}

int xmlNanoFTPUpdateURL(void *ctx, const char *URL)
{
  int v2;
  xmlURIPtr v4;
  xmlURI *v5;
  const char *server;
  int port;
  void *v9;
  const char *path;

  v2 = -1;
  if (ctx)
  {
    if (URL)
    {
      if (*(_QWORD *)ctx)
      {
        if (*((_QWORD *)ctx + 1))
        {
          v4 = xmlParseURIRaw(URL, 1);
          if (v4)
          {
            v5 = v4;
            if (!v4->scheme)
            {
LABEL_11:
              xmlFreeURI(v5);
              return v2;
            }
            server = v4->server;
            if (!server || strcmp(*(const char **)ctx, v4->scheme) || strcmp(*((const char **)ctx + 1), server))
            {
LABEL_10:
              v2 = -1;
              goto LABEL_11;
            }
            port = v5->port;
            if (port)
            {
              if (*((_DWORD *)ctx + 4) != port)
                goto LABEL_10;
              *((_DWORD *)ctx + 4) = port;
            }
            v9 = (void *)*((_QWORD *)ctx + 3);
            if (v9)
            {
              xmlFree(v9);
              *((_QWORD *)ctx + 3) = 0;
            }
            if (v5->path)
              path = v5->path;
            else
              path = "/";
            v2 = 0;
            *((_QWORD *)ctx + 3) = xmlMemStrdup(path);
            goto LABEL_11;
          }
        }
      }
    }
  }
  return v2;
}

void *__cdecl xmlNanoFTPNewCtxt(const char *URL)
{
  void *v2;
  uint64_t v3;
  char *v4;
  char *v5;

  v2 = xmlMalloc(0x4D8uLL);
  v3 = (uint64_t)v2;
  if (v2)
  {
    bzero(v2, 0x4D8uLL);
    *(_DWORD *)(v3 + 16) = 21;
    *(_DWORD *)(v3 + 192) = 0;
    *(_QWORD *)(v3 + 1224) = 0;
    *(_QWORD *)(v3 + 176) = 0xFFFFFFFF00000001;
    v4 = xmlURIUnescapeString(URL, 0, 0);
    if (v4)
    {
      v5 = v4;
      xmlNanoFTPScanURL(v3, v4);
      xmlFree(v5);
    }
    else if (URL)
    {
      xmlNanoFTPScanURL(v3, (char *)URL);
    }
  }
  else
  {
    __xmlSimpleError(9u, 2, 0, 0, (const xmlChar *)"allocating FTP context");
  }
  return (void *)v3;
}

void xmlNanoFTPScanURL(uint64_t a1, char *str)
{
  void *v4;
  void *v5;
  void *v6;
  xmlURIPtr v7;
  xmlURI *v8;
  const char *scheme;
  const char *path;
  int port;
  const xmlChar *user;
  char *v13;
  char *v14;

  v4 = *(void **)a1;
  if (v4)
  {
    xmlFree(v4);
    *(_QWORD *)a1 = 0;
  }
  v5 = *(void **)(a1 + 8);
  if (v5)
  {
    xmlFree(v5);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v6 = *(void **)(a1 + 24);
  if (v6)
  {
    xmlFree(v6);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v7 = xmlParseURIRaw(str, 1);
  if (v7)
  {
    v8 = v7;
    scheme = v7->scheme;
    if (scheme && v8->server)
    {
      *(_QWORD *)a1 = xmlMemStrdup(scheme);
      *(_QWORD *)(a1 + 8) = xmlMemStrdup(v8->server);
      if (v8->path)
        path = v8->path;
      else
        path = "/";
      *(_QWORD *)(a1 + 24) = xmlMemStrdup(path);
      port = v8->port;
      if (port)
        *(_DWORD *)(a1 + 16) = port;
      user = (const xmlChar *)v8->user;
      if (user)
      {
        v13 = strchr(v8->user, 58);
        if (v13)
        {
          v14 = v13;
          *(_QWORD *)(a1 + 32) = xmlStrndup(user, (int)v13 - (int)user);
          *(_QWORD *)(a1 + 40) = xmlMemStrdup(v14 + 1);
        }
        else
        {
          *(_QWORD *)(a1 + 32) = xmlMemStrdup((const char *)user);
        }
      }
    }
    xmlFreeURI(v8);
  }
}

void xmlNanoFTPFreeCtxt(void *ctx)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  int v6;

  if (ctx)
  {
    v2 = (void *)*((_QWORD *)ctx + 1);
    if (v2)
      xmlFree(v2);
    if (*(_QWORD *)ctx)
      xmlFree(*(void **)ctx);
    v3 = (void *)*((_QWORD *)ctx + 3);
    if (v3)
      xmlFree(v3);
    v4 = (void *)*((_QWORD *)ctx + 4);
    if (v4)
      xmlFree(v4);
    v5 = (void *)*((_QWORD *)ctx + 5);
    if (v5)
      xmlFree(v5);
    *((_DWORD *)ctx + 44) = 1;
    v6 = *((_DWORD *)ctx + 45);
    if (v6 != -1)
      close(v6);
    *((_DWORD *)ctx + 45) = -1;
    *((_QWORD *)ctx + 153) = -1;
    xmlFree(ctx);
  }
}

unint64_t xmlNanoFTPReadResponse(int *a1)
{
  int v2;
  signed int v3;
  int v4;
  int v6;
  uint64_t v7;
  signed int v8;
  unint64_t v9;
  unsigned __int8 *v10;
  unint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unint64_t result;
  _BYTE *v19;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (a1[45] != -1)
  {
    v2 = (_DWORD)a1 + 196;
    v3 = a1[306];
    do
    {
      if (v3 > 0x400)
        break;
      v4 = a1[307];
      if (v4 > 0x400 || v4 < v3)
        break;
      if (v3)
      {
        memmove(a1 + 49, (char *)a1 + v3 + 196, v4 - v3);
        v4 = a1[307] - a1[306];
        a1[307] = v4;
        a1[306] = 0;
      }
      if (v4 == 1024)
      {
        v6 = 0;
        v3 = 1024;
      }
      else
      {
        v6 = recv(a1[45], a1 + 49, 1024 - v4, 0);
        if (v6 < 0)
        {
          __xmlIOErr(9u, 0, (const xmlChar *)"recv failed");
          close(a1[45]);
          result = 0xFFFFFFFFLL;
          a1[45] = -1;
          return result;
        }
        v7 = a1[307] + (uint64_t)v6;
        a1[307] = v7;
        *((_BYTE *)a1 + v7 + 196) = 0;
        v3 = a1[307];
      }
      if (!(v3 | v6))
        return 0xFFFFFFFFLL;
      v8 = a1[306];
      if (v8 < v3)
      {
        v9 = (unint64_t)a1 + v3 + 196;
        v10 = (unsigned __int8 *)a1 + v8 + 196;
        while (1)
        {
          v11 = v9 - (_QWORD)v10;
          if ((int)v9 - (int)v10 >= 3)
          {
            v12 = (char)*v10;
            if ((v12 - 48) <= 9)
            {
              v13 = v10[1];
              if ((v13 - 48) <= 9)
              {
                v14 = v10[2];
                if ((v14 - 48) <= 9)
                {
                  v15 = v14 + 10 * (v13 + 10 * v12);
                  v16 = 5328 - v15;
                  v17 = v15 - 5328;
                  if (v10[3] == 45)
                    v17 = v16;
                  if (v17 > 0)
                    break;
                }
              }
            }
          }
          if ((unint64_t)v10 >= v9)
          {
LABEL_32:
            a1[306] = v3;
            goto LABEL_33;
          }
          ++v10;
          while (*(v10 - 1) != 10)
          {
            ++v10;
            if (!--v11)
              goto LABEL_32;
          }
          if ((unint64_t)v10 >= v9)
            goto LABEL_31;
        }
        v19 = v10 + 3;
        a1[308] = (_DWORD)v10 + 3 - v2;
        while ((unint64_t)v19 < v9 && *v19 != 10)
          ++v19;
        if (*v19 == 10)
          ++v19;
        if (*v19 == 13)
          LODWORD(v19) = (_DWORD)v19 + 1;
        a1[306] = (_DWORD)v19 - v2;
        return v17 / 0x64uLL;
      }
LABEL_31:
      v3 = a1[306];
LABEL_33:
      ;
    }
    while (a1[45] != -1);
  }
  return 0xFFFFFFFFLL;
}

int xmlNanoFTPCheckResponse(void *ctx)
{
  unint64_t v2;
  int result;
  timeval v4;
  fd_set v5;

  if (!ctx)
    return -1;
  v2 = *((int *)ctx + 45);
  if ((_DWORD)v2 == -1)
    return -1;
  v4.tv_sec = 0;
  *(_QWORD *)&v4.tv_usec = 0;
  memset(&v5, 0, sizeof(v5));
  if (__darwin_check_fd_set_overflow(v2, &v5, 0))
    *(__int32_t *)((char *)v5.fds_bits + ((v2 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v2;
  result = select(*((_DWORD *)ctx + 45) + 1, &v5, 0, 0, &v4);
  if (result)
  {
    if (result == -1)
    {
      __xmlIOErr(9u, 0, (const xmlChar *)"select");
      return -1;
    }
    return xmlNanoFTPReadResponse((int *)ctx);
  }
  return result;
}

int xmlNanoFTPQuit(void *ctx)
{
  int v1;
  int v2;
  int v3;
  int result;
  char v5[23];
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!ctx)
    return -1;
  v1 = *((_DWORD *)ctx + 45);
  if (v1 == -1)
    return -1;
  v17 = 0;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  *(_OWORD *)&v5[7] = 0u;
  v6 = 0u;
  strcpy(v5, "QUIT\r\n");
  v2 = strlen(v5);
  v3 = send(v1, v5, v2, 0);
  result = 0;
  if (v3 < 0)
  {
    __xmlIOErr(9u, 0, (const xmlChar *)"send failed");
    return v3;
  }
  return result;
}

int xmlNanoFTPConnect(void *ctx)
{
  uint64_t v2;
  int *v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  hostent *v11;
  size_t h_length;
  addrinfo *v13;
  int ai_family;
  int v16;
  socklen_t v17;
  size_t ai_addrlen;
  int v19;
  int v20;
  int v21;
  int v22;
  const char *v23;
  const char *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  addrinfo *v34;
  addrinfo v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _BYTE v44[32];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (!ctx || !*((_QWORD *)ctx + 1))
    return -1;
  v2 = proxy;
  *((_OWORD *)ctx + 3) = 0u;
  if (v2)
    v3 = &proxyPort;
  else
    v3 = (int *)((char *)ctx + 16);
  v4 = *v3;
  *((_OWORD *)ctx + 4) = 0uLL;
  *((_OWORD *)ctx + 5) = 0uLL;
  if (v4)
    v5 = v4;
  else
    v5 = 21;
  *((_OWORD *)ctx + 6) = 0uLL;
  *((_OWORD *)ctx + 7) = 0uLL;
  *((_OWORD *)ctx + 8) = 0uLL;
  *((_OWORD *)ctx + 9) = 0uLL;
  *((_OWORD *)ctx + 10) = 0uLL;
  v6 = socket(30, 1, 0);
  if (v6 == -1)
  {
    v10 = (const char *)proxy;
    if (!proxy)
      v10 = (const char *)*((_QWORD *)ctx + 1);
    v11 = gethostbyname(v10);
    if (v11)
    {
      h_length = v11->h_length;
      if (h_length < 5)
      {
        *((_BYTE *)ctx + 49) = 2;
        memcpy((char *)ctx + 52, *(const void **)v11->h_addr_list, h_length);
        *((_WORD *)ctx + 25) = bswap32(v5) >> 16;
        v16 = socket(2, 1, 0);
        *((_DWORD *)ctx + 45) = v16;
        v17 = 16;
LABEL_37:
        if (v16 != -1)
        {
          if (connect(v16, (const sockaddr *)ctx + 3, v17) < 0)
          {
            v25 = "Failed to create a connection";
            goto LABEL_53;
          }
          if (xmlNanoFTPReadResponse((int *)ctx) != 2)
            goto LABEL_55;
          if (!proxy)
          {
LABEL_66:
            v43 = 0u;
            memset(v44, 0, 23);
            v41 = 0u;
            v42 = 0u;
            v39 = 0u;
            v40 = 0u;
            v37 = 0u;
            v38 = 0u;
            v36 = 0u;
            memset(&v35, 0, sizeof(v35));
            if (*((_QWORD *)ctx + 4))
              snprintf((char *)&v35, 0xC8uLL, "USER %s\r\n", *((const char **)ctx + 4));
            else
              strcpy((char *)&v35, "USER anonymous\r\n");
            v44[23] = 0;
            v29 = strlen((const char *)&v35);
            if ((send(*((_DWORD *)ctx + 45), &v35, v29, 0) & 0x80000000) == 0)
            {
              v30 = xmlNanoFTPReadResponse((int *)ctx);
              if (v30 == 2)
                return 0;
              if (v30 != 3 || (xmlNanoFTPSendPasswd((uint64_t)ctx) & 0x80000000) != 0)
                goto LABEL_55;
              v31 = xmlNanoFTPReadResponse((int *)ctx);
              if (v31 == 2)
                return 0;
              if (v31 == 3)
              {
                v25 = "FTP server asking for ACCNT on anonymous\n";
                v26 = 2002;
                goto LABEL_54;
              }
LABEL_55:
              close(*((_DWORD *)ctx + 45));
              v21 = -1;
              *((_DWORD *)ctx + 45) = -1;
              return v21;
            }
            v25 = "send failed";
LABEL_53:
            v26 = 0;
LABEL_54:
            __xmlIOErr(9u, v26, (const xmlChar *)v25);
            goto LABEL_55;
          }
          v55 = 0u;
          v56 = 0u;
          v53 = 0u;
          v54 = 0u;
          v51 = 0u;
          v52 = 0u;
          v49 = 0u;
          v50 = 0u;
          v47 = 0u;
          v48 = 0u;
          v45 = 0u;
          v46 = 0u;
          memset(v44, 0, sizeof(v44));
          v42 = 0u;
          v43 = 0u;
          v41 = 0u;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v36 = 0u;
          memset(&v35, 0, sizeof(v35));
          if (!proxyUser)
            goto LABEL_62;
          snprintf((char *)&v35, 0x190uLL, "USER %s\r\n", (const char *)proxyUser);
          HIBYTE(v56) = 0;
          v20 = strlen((const char *)&v35);
          v21 = send(*((_DWORD *)ctx + 45), &v35, v20, 0);
          if (v21 < 0)
            goto LABEL_56;
          v22 = xmlNanoFTPReadResponse((int *)ctx);
          switch(v22)
          {
            case 1:
LABEL_62:
              if (proxyType >= 2)
              {
                if (proxyType != 2)
                  goto LABEL_55;
              }
              else
              {
                snprintf((char *)&v35, 0x190uLL, "SITE %s\r\n", *((const char **)ctx + 1));
                HIBYTE(v56) = 0;
                v28 = strlen((const char *)&v35);
                v21 = send(*((_DWORD *)ctx + 45), &v35, v28, 0);
                if (v21 < 0)
                  goto LABEL_56;
                if (xmlNanoFTPReadResponse((int *)ctx) == 2)
                {
                  proxyType = 1;
                  goto LABEL_66;
                }
                if (proxyType == 1)
                  goto LABEL_55;
              }
              if (*((_QWORD *)ctx + 4))
                snprintf((char *)&v35, 0x190uLL, "USER %s@%s\r\n");
              else
                snprintf((char *)&v35, 0x190uLL, "USER anonymous@%s\r\n");
              HIBYTE(v56) = 0;
              v32 = strlen((const char *)&v35);
              v21 = send(*((_DWORD *)ctx + 45), &v35, v32, 0);
              if ((v21 & 0x80000000) == 0)
              {
                if (xmlNanoFTPReadResponse((int *)ctx) - 1 <= 1)
                  goto LABEL_91;
                if (*((_QWORD *)ctx + 5))
                  snprintf((char *)&v35, 0x190uLL, "PASS %s\r\n", *((const char **)ctx + 5));
                else
                  strcpy((char *)&v35, "PASS anonymous@\r\n");
                HIBYTE(v56) = 0;
                v33 = strlen((const char *)&v35);
                v21 = send(*((_DWORD *)ctx + 45), &v35, v33, 0);
                if ((v21 & 0x80000000) == 0)
                {
                  if (xmlNanoFTPReadResponse((int *)ctx) - 1 > 1)
                    goto LABEL_55;
LABEL_91:
                  v21 = 0;
                  proxyType = 2;
                  return v21;
                }
              }
LABEL_56:
              __xmlIOErr(9u, 0, (const xmlChar *)"send failed");
              close(*((_DWORD *)ctx + 45));
              *((_DWORD *)ctx + 45) = -1;
              return v21;
            case 3:
              v23 = (const char *)proxyPasswd;
              if (!proxyPasswd)
              {
                strcpy((char *)&v35, "PASS anonymous@\r\n");
                goto LABEL_60;
              }
              break;
            case 2:
              v23 = (const char *)proxyPasswd;
              if (!proxyPasswd)
                goto LABEL_62;
              break;
            default:
              goto LABEL_55;
          }
          snprintf((char *)&v35, 0x190uLL, "PASS %s\r\n", v23);
LABEL_60:
          HIBYTE(v56) = 0;
          v27 = strlen((const char *)&v35);
          v21 = send(*((_DWORD *)ctx + 45), &v35, v27, 0);
          if (v21 < 0)
            goto LABEL_56;
          if ((int)xmlNanoFTPReadResponse((int *)ctx) >= 4)
            goto LABEL_55;
          goto LABEL_62;
        }
        v9 = "socket failed";
        goto LABEL_49;
      }
      v9 = "gethostbyname address mismatch";
    }
    else
    {
      v9 = "gethostbyname failed";
    }
  }
  else
  {
    close(v6);
    v34 = 0;
    memset(&v35, 0, sizeof(v35));
    v35.ai_socktype = 1;
    v7 = (const char *)proxy;
    if (!proxy)
      v7 = (const char *)*((_QWORD *)ctx + 1);
    if (!getaddrinfo(v7, 0, &v35, &v34) && v34)
    {
      v13 = v34;
      while (1)
      {
        ai_family = v13->ai_family;
        if (ai_family == 2 || ai_family == 30)
          break;
        v13 = v13->ai_next;
        if (!v13)
        {
          v8 = "getaddrinfo failed";
LABEL_32:
          freeaddrinfo(v34);
          goto LABEL_14;
        }
      }
      ai_addrlen = v13->ai_addrlen;
      if (ai_addrlen > 0x80)
      {
        v8 = "gethostbyname address mismatch";
        goto LABEL_32;
      }
      memcpy((char *)ctx + 48, v13->ai_addr, ai_addrlen);
      *((_WORD *)ctx + 25) = bswap32(v5) >> 16;
      if (ai_family == 30)
        v19 = 30;
      else
        v19 = 2;
      *((_DWORD *)ctx + 45) = socket(v19, 1, 0);
      v17 = v13->ai_addrlen;
      freeaddrinfo(v34);
      v16 = *((_DWORD *)ctx + 45);
      goto LABEL_37;
    }
    v8 = "getaddrinfo failed";
LABEL_14:
    v9 = v8;
  }
LABEL_49:
  __xmlIOErr(9u, 0, (const xmlChar *)v9);
  return -1;
}

ssize_t xmlNanoFTPSendPasswd(uint64_t a1)
{
  int v2;
  ssize_t v3;
  ssize_t result;
  char __str[32];
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[24];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v14 = 0u;
  memset(v15, 0, 23);
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  memset(__str, 0, sizeof(__str));
  if (*(_QWORD *)(a1 + 40))
    snprintf(__str, 0xC8uLL, "PASS %s\r\n", *(const char **)(a1 + 40));
  else
    strcpy(__str, "PASS anonymous@\r\n");
  v15[23] = 0;
  v2 = strlen(__str);
  v3 = send(*(_DWORD *)(a1 + 180), __str, v2, 0);
  result = 0;
  if ((v3 & 0x80000000) != 0)
  {
    __xmlIOErr(9u, 0, (const xmlChar *)"send failed");
    return v3;
  }
  return result;
}

void *__cdecl xmlNanoFTPConnectTo(const char *server, int port)
{
  _QWORD *v4;
  char *v5;

  xmlNanoFTPInit();
  v4 = 0;
  if (server)
  {
    if (port >= 1)
    {
      v4 = xmlNanoFTPNewCtxt(0);
      if (v4)
      {
        v5 = xmlMemStrdup(server);
        v4[1] = v5;
        if (!v5 || (*((_DWORD *)v4 + 4) = port, xmlNanoFTPConnect(v4) < 0))
        {
          xmlNanoFTPFreeCtxt(v4);
          return 0;
        }
      }
    }
  }
  return v4;
}

int xmlNanoFTPCwd(void *ctx, const char *directory)
{
  int v3;
  int v4;
  uint64_t v5;
  char __str[16];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE v30[40];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!ctx || *((_DWORD *)ctx + 45) == -1)
    return -1;
  if (!directory)
    return 0;
  v29 = 0u;
  memset(v30, 0, 31);
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  *(_OWORD *)__str = 0u;
  v8 = 0u;
  snprintf(__str, 0x190uLL, "CWD %s\r\n", directory);
  v30[31] = 0;
  v3 = strlen(__str);
  v4 = send(*((_DWORD *)ctx + 45), __str, v3, 0);
  if (v4 < 0)
  {
    __xmlIOErr(9u, 0, (const xmlChar *)"send failed");
    return v4;
  }
  v5 = (int)xmlNanoFTPReadResponse((int *)ctx) - 2;
  if (v5 <= 3)
    return dword_1B08620C0[v5];
  else
    return 0;
}

int xmlNanoFTPDele(void *ctx, const char *file)
{
  int v2;
  int v4;
  uint64_t v5;
  char __str[16];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE v30[40];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v2 = -1;
  if (ctx && file && *((_DWORD *)ctx + 45) != -1)
  {
    v29 = 0u;
    memset(v30, 0, 31);
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    v9 = 0u;
    v10 = 0u;
    *(_OWORD *)__str = 0u;
    v8 = 0u;
    snprintf(__str, 0x190uLL, "DELE %s\r\n", file);
    v30[31] = 0;
    v4 = strlen(__str);
    v2 = send(*((_DWORD *)ctx + 45), __str, v4, 0);
    if (v2 < 0)
    {
      __xmlIOErr(9u, 0, (const xmlChar *)"send failed");
    }
    else
    {
      v5 = (int)xmlNanoFTPReadResponse((int *)ctx) - 2;
      if (v5 > 3)
        return 0;
      else
        return dword_1B08620C0[v5];
    }
  }
  return v2;
}

int xmlNanoFTPGetConnection(void *ctx)
{
  int v2;
  socklen_t v3;
  unsigned __int16 v4;
  int v5;
  int v6;
  int v7;
  const char *v8;
  int v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;
  const char *v13;
  uint64_t v14;
  int v15;
  const char *v17;
  int v18;
  int v19;
  socklen_t v20;
  char v21[16];
  _WORD v22[15];
  sockaddr v23[8];
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD __s[12];
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (ctx)
  {
    memset(v23, 0, sizeof(v23));
    if (*((_BYTE *)ctx + 49) == 30)
    {
      v2 = socket(30, 1, 6);
      *((_DWORD *)ctx + 46) = v2;
      v23[0].sa_family = 30;
      v3 = 28;
    }
    else
    {
      v2 = socket(2, 1, 6);
      *((_DWORD *)ctx + 46) = v2;
      v23[0].sa_family = 2;
      v3 = 16;
    }
    v20 = v3;
    if (v2 != -1)
    {
      v28 = 0;
      memset(__s, 0, sizeof(__s));
      v25 = 0;
      v26 = 0;
      v24 = 0;
      if (*((_DWORD *)ctx + 44))
      {
        if (*((_BYTE *)ctx + 49) == 30)
        {
          *(_DWORD *)((char *)__s + 3) = 658774;
          v4 = 20549;
        }
        else
        {
          *(_DWORD *)((char *)__s + 3) = 658774;
          v4 = 16720;
        }
        LODWORD(__s[0]) = v4 | 0x56530000;
        v6 = strlen((const char *)__s);
        if ((send(*((_DWORD *)ctx + 45), __s, v6, 0) & 0x80000000) == 0)
        {
          v7 = xmlNanoFTPReadResponse((int *)ctx);
          if (v7 == 2)
          {
LABEL_20:
            v8 = (char *)ctx + *((int *)ctx + 308) + 195;
            do
            {
              v9 = *(unsigned __int8 *)++v8;
              v10 = v9 - 48;
              if (v9)
                v11 = v10 > 9;
              else
                v11 = 0;
            }
            while (v11);
            if (*((_BYTE *)ctx + 49) == 30)
            {
              if (sscanf(v8, "%u", &v24) == 1)
              {
                *(sockaddr *)&v23[0].sa_data[6] = *(sockaddr *)((char *)ctx + 56);
                v12 = bswap32((unsigned __int16)v24) >> 16;
                goto LABEL_33;
              }
              v17 = "Invalid answer to EPSV\n";
              v18 = 2001;
            }
            else
            {
              if (sscanf(v8, "%u,%u,%u,%u,%u,%u", &v24, (char *)&v24 + 4, &v25, (char *)&v25 + 4, &v26, (char *)&v26 + 4) == 6)
              {
                v14 = 0;
                *(_WORD *)&v21[4] = 0;
                *(_DWORD *)v21 = 0;
                do
                {
                  v21[v14] = *((_DWORD *)&v24 + v14);
                  ++v14;
                }
                while (v14 != 6);
                *(_DWORD *)&v23[0].sa_data[2] = *(_DWORD *)v21;
                LOWORD(v12) = *(_WORD *)&v21[4];
LABEL_33:
                *(_WORD *)v23[0].sa_data = v12;
                if (connect(*((_DWORD *)ctx + 46), v23, v3) < 0)
                {
                  v13 = "Failed to create a data connection";
                  goto LABEL_41;
                }
                return *((_DWORD *)ctx + 46);
              }
              v17 = "Invalid answer to PASV\n";
              v18 = 2000;
            }
            __xmlIOErr(9u, v18, (const xmlChar *)v17);
            v19 = *((_DWORD *)ctx + 46);
            v5 = -1;
            if (v19 == -1)
              return v5;
            close(v19);
            goto LABEL_43;
          }
          if (v7 != 5)
          {
            close(*((_DWORD *)ctx + 46));
            *((_DWORD *)ctx + 46) = -1;
            *((_DWORD *)ctx + 44) = 0;
            goto LABEL_20;
          }
LABEL_42:
          close(*((_DWORD *)ctx + 46));
          v5 = -1;
LABEL_43:
          *((_DWORD *)ctx + 46) = -1;
          return v5;
        }
      }
      else
      {
        getsockname(v2, v23, &v20);
        *(_WORD *)v23[0].sa_data = 0;
        if (bind(*((_DWORD *)ctx + 46), v23, v20) < 0)
        {
          v13 = "bind failed";
LABEL_41:
          __xmlIOErr(9u, 0, (const xmlChar *)v13);
          goto LABEL_42;
        }
        getsockname(*((_DWORD *)ctx + 46), v23, &v20);
        if (listen(*((_DWORD *)ctx + 46), 1) < 0)
        {
          v13 = "listen failed";
          goto LABEL_41;
        }
        if (*((_BYTE *)ctx + 49) == 30)
        {
          *(_OWORD *)v21 = 0u;
          memset(v22, 0, sizeof(v22));
          inet_ntop(30, &v23[0].sa_data[6], v21, 0x2Eu);
          snprintf((char *)__s, 0xC8uLL, "EPRT |2|%s|%s|\r\n");
        }
        else
        {
          snprintf((char *)__s, 0xC8uLL, "PORT %d,%d,%d,%d,%d,%d\r\n", v23[0].sa_data[2]);
        }
        HIBYTE(v28) = 0;
        v15 = strlen((const char *)__s);
        if ((send(*((_DWORD *)ctx + 45), __s, v15, 0) & 0x80000000) == 0)
        {
          if (xmlNanoFTPReadResponse((int *)ctx) == 2)
            return *((_DWORD *)ctx + 46);
          goto LABEL_42;
        }
      }
      v13 = "send failed";
      goto LABEL_41;
    }
    __xmlIOErr(9u, 0, (const xmlChar *)"socket failed");
  }
  return -1;
}

int xmlNanoFTPCloseConnection(void *ctx)
{
  int v2;
  int v3;
  int v4;
  int v5;
  __int128 v7;
  fd_set v8;
  fd_set v9;

  if (!ctx)
    return -1;
  v2 = -1;
  if (*((_DWORD *)ctx + 45) != -1)
  {
    close(*((_DWORD *)ctx + 46));
    *((_DWORD *)ctx + 46) = -1;
    v7 = xmmword_1B08620B0;
    DWORD2(v7) = 0;
    memset(&v9, 0, sizeof(v9));
    v3 = *((_DWORD *)ctx + 45);
    if (__darwin_check_fd_set_overflow(v3, &v9, 0))
      *(__int32_t *)((char *)v9.fds_bits + (((unint64_t)v3 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v3;
    memset(&v8, 0, sizeof(v8));
    v4 = *((_DWORD *)ctx + 45);
    if (__darwin_check_fd_set_overflow(v4, &v8, 0))
      *(__int32_t *)((char *)v8.fds_bits + (((unint64_t)v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v4;
    v5 = select(*((_DWORD *)ctx + 45) + 1, &v9, 0, &v8, (timeval *)&v7);
    if ((v5 & 0x80000000) == 0)
    {
      if (!v5)
      {
        v2 = 0;
        goto LABEL_14;
      }
      if (xmlNanoFTPReadResponse((int *)ctx) == 2)
        return 0;
    }
    v2 = -1;
LABEL_14:
    close(*((_DWORD *)ctx + 45));
    *((_DWORD *)ctx + 45) = -1;
  }
  return v2;
}

int xmlNanoFTPList(void *ctx, ftpListCallback callback, void *userData, const char *filename)
{
  uint64_t v4;
  void (*v5)(uint64_t, _BYTE *, _BYTE *, _BYTE *, _BYTE *, uint64_t, uint64_t, uint64_t, int *, unint64_t, int);
  uint64_t v6;
  const char *v7;
  const char *v8;
  uint64_t v9;
  void (*v10)(uint64_t, _BYTE *, _BYTE *, _BYTE *, _BYTE *, uint64_t, uint64_t, uint64_t, int *, unint64_t, int);
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  const char *v24;
  int v25;
  char *v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  unsigned int v56;
  uint64_t v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  char v70;
  int v71;
  int v73;
  uint64_t v74;
  void (*v75)(uint64_t, _BYTE *, _BYTE *, _BYTE *, _BYTE *, uint64_t, uint64_t, uint64_t, int *, unint64_t, int);
  timeval v76;
  fd_set v77;
  fd_set v78;
  int v79;
  char __str[4104];
  _BYTE v81[16];
  _BYTE v82[16];
  _BYTE v83[16];
  _BYTE v84[151];
  uint64_t v85;

  v4 = MEMORY[0x1E0C80A78](ctx, callback);
  v85 = *MEMORY[0x1E0C80C00];
  if (!v4)
    return -1;
  v8 = v7;
  v9 = v6;
  v10 = v5;
  v11 = v4;
  bzero(__str, 0x1001uLL);
  memset(&v77, 0, sizeof(v77));
  *(_QWORD *)&v76.tv_usec = 0;
  if (v8)
  {
    if (*v8 == 47 || xmlNanoFTPCwd((void *)v11, *(const char **)(v11 + 24)) >= 1)
    {
      v12 = xmlNanoFTPGetConnection((void *)v11);
      *(_DWORD *)(v11 + 184) = v12;
      if (v12 != -1)
      {
        snprintf(__str, 0x1001uLL, "LIST -L %s\r\n", v8);
        goto LABEL_10;
      }
    }
    return -1;
  }
  if (xmlNanoFTPCwd((void *)v11, *(const char **)(v11 + 24)) < 1)
    return -1;
  v13 = xmlNanoFTPGetConnection((void *)v11);
  *(_DWORD *)(v11 + 184) = v13;
  if (v13 == -1)
    return -1;
  strcpy(__str, "LIST -L\r\n");
LABEL_10:
  __str[4096] = 0;
  v14 = strlen(__str);
  v15 = send(*(_DWORD *)(v11 + 180), __str, v14, 0);
  if (v15 < 0)
  {
    __xmlIOErr(9u, 0, (const xmlChar *)"send failed");
    close(*(_DWORD *)(v11 + 184));
    goto LABEL_156;
  }
  v16 = xmlNanoFTPReadResponse((int *)v11);
  if (v16 != 1)
  {
    v73 = v16;
    close(*(_DWORD *)(v11 + 184));
    *(_DWORD *)(v11 + 184) = -1;
    return -v73;
  }
  v74 = v9;
  v75 = v10;
  v17 = 0;
  do
  {
    v76.tv_sec = 1;
    v76.tv_usec = 0;
    memset(&v78, 0, sizeof(v78));
    v18 = *(_DWORD *)(v11 + 184);
    if (__darwin_check_fd_set_overflow(v18, &v78, 0))
      *(__int32_t *)((char *)v78.fds_bits + (((unint64_t)v18 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v18;
    memset(&v77, 0, sizeof(v77));
    v19 = *(_DWORD *)(v11 + 184);
    if (__darwin_check_fd_set_overflow(v19, &v77, 0))
      *(__int32_t *)((char *)v77.fds_bits + (((unint64_t)v19 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v19;
    v20 = select(*(_DWORD *)(v11 + 184) + 1, &v78, 0, &v77, &v76);
    if (v20 < 0)
      goto LABEL_159;
    if (!v20)
    {
      v71 = xmlNanoFTPCheckResponse((void *)v11);
      if (v71 < 0)
      {
LABEL_159:
        close(*(_DWORD *)(v11 + 184));
        v15 = -1;
        *(_DWORD *)(v11 + 184) = -1;
        return v15;
      }
      if (v71 != 2)
        continue;
      close(*(_DWORD *)(v11 + 184));
      v15 = 0;
LABEL_156:
      *(_DWORD *)(v11 + 184) = -1;
      return v15;
    }
    v21 = recv(*(_DWORD *)(v11 + 184), &__str[v17], 4097 - (v17 + 1), 0);
    v14 = v21;
    if (v21 < 0)
    {
      __xmlIOErr(9u, 0, (const xmlChar *)"recv");
      goto LABEL_159;
    }
    v22 = 0;
    v23 = v17 + (uint64_t)v21;
    __str[v23] = 0;
    while (1)
    {
      v24 = &__str[v22];
      memset(v84, 0, sizeof(v84));
      memset(v83, 0, 11);
      memset(v82, 0, 11);
      memset(v81, 0, 11);
      v79 = 0;
      if (strncmp(v24, "total", 5uLL))
        break;
      v26 = &__str[v22 + 4];
      do
      {
        v31 = *++v26;
        v30 = v31;
      }
      while (v31 == 32);
      if (v30 - 48 <= 9)
      {
        do
        {
          v32 = *++v26;
          v30 = v32;
        }
        while (v32 - 48 < 0xA);
      }
      while (v30 <= 0x20 && ((1 << v30) & 0x100002400) != 0)
      {
        v33 = *++v26;
        v30 = v33;
      }
LABEL_147:
      v22 += (_DWORD)v26 - (_DWORD)v24;
      if ((int)v26 - (int)v24 <= 0)
        goto LABEL_148;
    }
    v25 = *(unsigned __int8 *)v24;
    if (v25 == 43)
      goto LABEL_148;
    v26 = &__str[v22];
    while (v25 > 12)
    {
      if (v25 != 13 && v25 != 32)
        goto LABEL_31;
LABEL_29:
      v27 = *++v26;
      v25 = v27;
    }
    if (v25 == 10)
      goto LABEL_29;
    if (!v25)
      goto LABEL_148;
LABEL_31:
    v28 = 0;
    while (v25 != 32)
    {
      if (v28 <= 9)
        v83[v28++] = v25;
      v29 = *++v26;
      v25 = v29;
      if (!v29)
        goto LABEL_148;
    }
    v83[10] = 0;
    while (v25 == 32)
    {
      v34 = *++v26;
      v25 = v34;
    }
    if (v25)
    {
      if ((v25 - 48) > 9)
      {
        v35 = 0;
      }
      else
      {
        LODWORD(v35) = 0;
        v36 = v25;
        do
        {
          v37 = *++v26;
          v25 = v37;
          v35 = (v36 + 10 * v35 - 48);
          v36 = v37;
        }
        while ((v37 - 48) < 0xA);
      }
      while (v25 == 32)
      {
        v38 = *++v26;
        v25 = v38;
      }
      if (v25)
      {
        v39 = 0;
        while (v25 != 32)
        {
          if (v39 <= 9)
            v82[v39++] = v25;
          v40 = *++v26;
          v25 = v40;
          if (!v40)
            goto LABEL_148;
        }
        v82[v39] = 0;
        while (1)
        {
          v41 = *v26;
          if (v41 != 32)
            break;
          ++v26;
        }
        if (*v26)
        {
          v42 = 0;
          while (v41 != 32)
          {
            if (v42 <= 9)
              v81[v42++] = v41;
            v43 = *++v26;
            v41 = v43;
            if (!v43)
              goto LABEL_148;
          }
          v81[v42] = 0;
          while (1)
          {
            v44 = *v26;
            if (v44 != 32)
              break;
            ++v26;
          }
          if (*v26)
          {
            if ((v44 - 48) > 9)
            {
              v45 = 0;
            }
            else
            {
              v45 = 0;
              v46 = *v26;
              do
              {
                v47 = *++v26;
                v44 = v47;
                v45 = (v46 - 48) + 10 * v45;
                v46 = v47;
              }
              while ((v47 - 48) < 0xA);
            }
            while (v44 == 32)
            {
              v48 = *++v26;
              v44 = v48;
            }
            if (v44)
            {
              v49 = 0;
              while (v44 != 32)
              {
                if (v49 <= 2)
                  __str[v49++ - 4] = v44;
                v50 = *++v26;
                v44 = v50;
                if (!v50)
                  goto LABEL_148;
              }
              __str[v49 - 4] = 0;
              while (1)
              {
                v51 = *v26;
                if (v51 != 32)
                  break;
                ++v26;
              }
              if (*v26)
              {
                if ((v51 - 48) > 9)
                {
                  v52 = 0;
                }
                else
                {
                  v52 = 0;
                  v53 = *v26;
                  do
                  {
                    v54 = *++v26;
                    v51 = v54;
                    v52 = v53 + 10 * v52 - 48;
                    v53 = v54;
                  }
                  while ((v54 - 48) < 0xA);
                }
                while (v51 == 32)
                {
                  v55 = *++v26;
                  v51 = v55;
                }
                if (v51 && v26[1] && v26[2])
                {
                  v56 = v51 - 48;
                  if (v26[1] == 58 || v26[2] == 58)
                  {
                    if (v56 > 9)
                    {
                      v59 = 0;
                    }
                    else
                    {
                      v59 = 0;
                      v60 = v51;
                      do
                      {
                        v61 = *++v26;
                        v51 = v61;
                        v59 = v60 + 10 * v59 - 48;
                        v60 = v61;
                      }
                      while ((v61 - 48) < 0xA);
                    }
                    if (v51 == 58)
                      ++v26;
                    v51 = *v26;
                    if ((v51 - 48) > 9)
                    {
                      v57 = 0;
                      v62 = 0;
                    }
                    else
                    {
                      v62 = 0;
                      do
                      {
                        v63 = *++v26;
                        v62 = v51 + 10 * v62 - 48;
                        v51 = v63;
                      }
                      while ((v63 - 48) < 0xA);
                      v57 = 0;
                    }
                  }
                  else
                  {
                    if (v56 > 9)
                    {
                      v57 = 0;
                    }
                    else
                    {
                      LODWORD(v57) = 0;
                      do
                      {
                        v58 = *++v26;
                        v57 = (v51 + 10 * v57 - 48);
                        v51 = v58;
                      }
                      while ((v58 - 48) < 0xA);
                    }
                    v62 = 0;
                    v59 = 0;
                  }
                  while (v51 == 32)
                  {
                    v64 = *++v26;
                    v51 = v64;
                  }
                  if (v51)
                  {
                    v65 = 0;
                    while (v51 != 10 && v51 != 13)
                    {
                      if (v65 <= 149)
                        v84[v65++] = v51;
                      v66 = *++v26;
                      v51 = v66;
                      if (!v66)
                        goto LABEL_148;
                    }
                    v84[v65] = 0;
                    v67 = *v26;
                    if (v67 == 13 || v67 == 10)
                    {
                      while (v67 == 13 || v67 == 10)
                      {
                        v70 = *++v26;
                        LOBYTE(v67) = v70;
                      }
                      if (v75)
                        v75(v74, v84, v83, v82, v81, v45, v35, v57, &v79, __PAIR64__(v59, v52), v62);
                      goto LABEL_147;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_148:
    v17 = v23 - v22;
    __memmove_chk();
  }
  while (v14);
  xmlNanoFTPCloseConnection((void *)v11);
  return 0;
}

int xmlNanoFTPGetSocket(void *ctx, const char *filename)
{
  int result;
  int v5;
  int v6;
  int v7;
  char __s[9];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[19];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!ctx || !filename && !*((_QWORD *)ctx + 3))
    return -1;
  result = xmlNanoFTPGetConnection(ctx);
  *((_DWORD *)ctx + 46) = result;
  if (result == -1)
    return result;
  v25 = 0u;
  memset(v26, 0, sizeof(v26));
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  strcpy(__s, "TYPE I\r\n");
  v5 = strlen(__s);
  if ((send(*((_DWORD *)ctx + 45), __s, v5, 0) & 0x80000000) != 0)
    goto LABEL_14;
  if (xmlNanoFTPReadResponse((int *)ctx) != 2)
  {
LABEL_15:
    result = *((_DWORD *)ctx + 46);
    goto LABEL_16;
  }
  if (filename)
    snprintf(__s, 0x12CuLL, "RETR %s\r\n", filename);
  else
    snprintf(__s, 0x12CuLL, "RETR %s\r\n", *((const char **)ctx + 3));
  v26[18] = 0;
  v6 = strlen(__s);
  if ((send(*((_DWORD *)ctx + 45), __s, v6, 0) & 0x80000000) != 0)
  {
LABEL_14:
    __xmlIOErr(9u, 0, (const xmlChar *)"send failed");
    goto LABEL_15;
  }
  v7 = xmlNanoFTPReadResponse((int *)ctx);
  result = *((_DWORD *)ctx + 46);
  if (v7 != 1)
  {
LABEL_16:
    close(result);
    result = -1;
    *((_DWORD *)ctx + 46) = -1;
  }
  return result;
}

int xmlNanoFTPGet(void *ctx, ftpDataCallback callback, void *userData, const char *filename)
{
  uint64_t v4;
  void (*v5)(uint64_t, _BYTE *, ssize_t);
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  void (*v9)(uint64_t, _BYTE *, ssize_t);
  uint64_t v10;
  int result;
  ssize_t v12;
  int v13;
  int v14;
  int v15;
  timeval v16;
  fd_set v17;
  _BYTE v18[4096];
  uint64_t v19;

  v4 = MEMORY[0x1E0C80A78](ctx, callback);
  v19 = *MEMORY[0x1E0C80C00];
  if (!v4)
    return -1;
  v8 = v6;
  v9 = v5;
  v10 = v4;
  if (v7)
  {
    if (!v5)
      return -1;
  }
  else
  {
    result = -1;
    if (!v5 || !*(_QWORD *)(v10 + 24))
      return result;
  }
  result = xmlNanoFTPGetSocket((void *)v10, v7);
  if (result != -1)
  {
    bzero(v18, 0x1000uLL);
    LODWORD(v12) = 0;
    *(_QWORD *)&v16.tv_usec = 0;
    while (1)
    {
      v16.tv_sec = 1;
      v16.tv_usec = 0;
      memset(&v17, 0, sizeof(v17));
      v13 = *(_DWORD *)(v10 + 184);
      if (__darwin_check_fd_set_overflow(v13, &v17, 0))
        *(__int32_t *)((char *)v17.fds_bits + (((unint64_t)v13 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v13;
      v14 = select(*(_DWORD *)(v10 + 184) + 1, &v17, 0, 0, &v16);
      if (v14 < 0)
        goto LABEL_20;
      if (v14)
      {
        v12 = recv(*(_DWORD *)(v10 + 184), v18, 0x1000uLL, 0);
        if ((v12 & 0x80000000) != 0)
        {
          __xmlIOErr(9u, 0, (const xmlChar *)"recv failed");
          v9(v8, v18, v12);
LABEL_20:
          close(*(_DWORD *)(v10 + 184));
          result = -1;
          *(_DWORD *)(v10 + 184) = -1;
          return result;
        }
        v9(v8, v18, v12);
      }
      else
      {
        v15 = xmlNanoFTPCheckResponse((void *)v10);
        if (v15 < 0)
          goto LABEL_20;
        if (v15 == 2)
        {
          close(*(_DWORD *)(v10 + 184));
          result = 0;
          *(_DWORD *)(v10 + 184) = -1;
          return result;
        }
      }
      if (!(_DWORD)v12)
        return xmlNanoFTPCloseConnection((void *)v10);
    }
  }
  return result;
}

int xmlNanoFTPRead(void *ctx, void *dest, int len)
{
  int v4;
  int v5;
  int v6;

  if (!ctx)
    return -1;
  v4 = *((_DWORD *)ctx + 46);
  if (v4 == -1)
    return 0;
  if (!dest)
    return -1;
  if (len < 1)
    return 0;
  v5 = recv(v4, dest, len, 0);
  v6 = v5;
  if (v5 <= 0)
  {
    if (v5 < 0)
      __xmlIOErr(9u, 0, (const xmlChar *)"recv failed");
    xmlNanoFTPCloseConnection(ctx);
  }
  return v6;
}

void *__cdecl xmlNanoFTPOpen(const char *URL)
{
  char *v3;

  xmlNanoFTPInit();
  if (URL)
  {
    if (strncmp("ftp://", URL, 6uLL))
      return 0;
    v3 = (char *)xmlNanoFTPNewCtxt(URL);
    URL = v3;
    if (v3 && (xmlNanoFTPConnect(v3) < 0 || xmlNanoFTPGetSocket((void *)URL, *((const char **)URL + 3)) == -1))
    {
      xmlNanoFTPFreeCtxt((void *)URL);
      return 0;
    }
  }
  return (void *)URL;
}

int xmlNanoFTPClose(void *ctx)
{
  int v2;

  if (!ctx)
    return -1;
  v2 = *((_DWORD *)ctx + 46);
  if (v2 != -1)
  {
    close(v2);
    *((_DWORD *)ctx + 46) = -1;
  }
  if (*((_DWORD *)ctx + 45) != -1)
  {
    xmlNanoFTPQuit(ctx);
    close(*((_DWORD *)ctx + 45));
    *((_DWORD *)ctx + 45) = -1;
  }
  xmlNanoFTPFreeCtxt(ctx);
  return 0;
}

void xmlNanoHTTPInit(void)
{
  char *v0;
  char *v1;

  if ((initialized_0 & 1) == 0)
  {
    if (!proxy_0)
    {
      proxyPort_0 = 80;
      v0 = getenv("no_proxy");
      if (!v0 || *v0 != 42 || v0[1])
      {
        v1 = getenv("http_proxy");
        if (v1 || (v1 = getenv("HTTP_PROXY")) != 0)
          xmlNanoHTTPScanProxy(v1);
      }
    }
    initialized_0 = 1;
  }
}

void xmlNanoHTTPScanProxy(const char *URL)
{
  xmlURIPtr v2;
  xmlURI *v3;
  const char *scheme;
  const char *server;

  if (proxy_0)
  {
    xmlFree((void *)proxy_0);
    proxy_0 = 0;
  }
  proxyPort_0 = 0;
  if (URL)
  {
    v2 = xmlParseURIRaw(URL, 1);
    if (v2)
    {
      v3 = v2;
      scheme = v2->scheme;
      if (scheme && !strcmp(scheme, "http") && (server = v3->server) != 0)
      {
        proxy_0 = (uint64_t)xmlMemStrdup(server);
        if (v3->port)
          proxyPort_0 = v3->port;
      }
      else
      {
        __xmlIOErr(0xAu, 2020, (const xmlChar *)"Syntax Error\n");
      }
      xmlFreeURI(v3);
    }
    else
    {
      __xmlIOErr(0xAu, 2020, (const xmlChar *)"Syntax Error\n");
    }
  }
}

void xmlNanoHTTPCleanup(void)
{
  if (proxy_0)
  {
    xmlFree((void *)proxy_0);
    proxy_0 = 0;
  }
  initialized_0 = 0;
}

void *__cdecl xmlNanoHTTPOpen(const char *URL, char **contentType)
{
  if (contentType)
    *contentType = 0;
  return xmlNanoHTTPMethodRedir(URL, 0, 0, contentType, 0, 0, 0);
}

void *__cdecl xmlNanoHTTPMethod(const char *URL, const char *method, const char *input, char **contentType, const char *headers, int ilen)
{
  return xmlNanoHTTPMethodRedir(URL, method, input, contentType, 0, headers, ilen);
}

void *__cdecl xmlNanoHTTPOpenRedir(const char *URL, char **contentType, char **redir)
{
  if (contentType)
    *contentType = 0;
  if (redir)
    *redir = 0;
  return xmlNanoHTTPMethodRedir(URL, 0, 0, contentType, redir, 0, 0);
}

void *__cdecl xmlNanoHTTPMethodRedir(const char *URL, const char *method, const char *input, char **contentType, char **redir, const char *headers, int ilen)
{
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  const char **v10;
  char *v11;
  int v12;
  const char **v13;
  int v14;
  const char *v15;
  int v16;
  const char *v17;
  xmlStrdupFunc *v18;
  xmlFreeFunc *v19;
  _OWORD *v20;
  xmlStrdupFunc *v21;
  const char *v22;
  const char *v23;
  xmlFreeFunc *v24;
  int v25;
  int v26;
  unsigned int v27;
  const char *v28;
  int v29;
  int v30;
  int v31;
  const char *v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  size_t v38;
  char *v39;
  const char *v40;
  int v41;
  char *v42;
  const char *v43;
  size_t v44;
  int v45;
  char *v46;
  size_t v47;
  int v48;
  char *v49;
  unsigned __int8 *v50;
  int v51;
  int v52;
  const char *v53;
  const char *v54;
  const char *v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  const char *v59;
  const xmlChar *n;
  int v61;
  uint64_t v63;
  unsigned int v64;
  BOOL v65;
  uint64_t v66;
  const xmlChar *v68;
  uint64_t v69;
  const xmlChar *v70;
  unsigned int v71;
  uint64_t v72;
  const char *v74;
  int v75;
  int v76;
  unsigned __int8 v77;
  unsigned int v78;
  int v79;
  unsigned int v81;
  int v82;
  uint64_t v83;
  const char *v85;
  const xmlChar *m;
  int v87;
  const xmlChar *i;
  int v90;
  xmlChar *v92;
  xmlChar *v93;
  xmlChar *v94;
  unsigned __int8 *k;
  int v96;
  uint64_t v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  const xmlChar *v103;
  unsigned int v104;
  uint64_t v105;
  int v107;
  const xmlChar *j;
  int v110;
  z_stream *v112;
  const char *v113;
  int v114;
  _QWORD *v115;
  uint64_t v116;
  const char **v118;
  const char *v119;
  int v120;
  int v121;
  char *v122;
  char *__s;
  const char **v124;
  uint64_t v125;
  char cur[4095];
  _BYTE v127[17];

  v7 = MEMORY[0x1E0C80A78](URL, method);
  v124 = v13;
  *(_QWORD *)&v127[1] = *MEMORY[0x1E0C80C00];
  v119 = (const char *)v7;
  if (!v7)
    return 0;
  v14 = v12;
  v125 = v9;
  v118 = v10;
  v15 = "GET";
  if (v8)
    v15 = v8;
  v122 = (char *)v15;
  __s = v11;
  xmlNanoHTTPInit();
  v16 = 0;
  v17 = 0;
  v18 = &xmlMemStrdup;
  v19 = &xmlFree;
  while (2)
  {
    v20 = xmlNanoHTTPNewCtxt(v119);
    if (!v20)
      return v20;
LABEL_8:
    if (!*(_QWORD *)v20 || strcmp(*(const char **)v20, "http"))
    {
      v113 = "Not a valid HTTP URI";
      v114 = 2020;
LABEL_218:
      __xmlIOErr(0xAu, v114, (const xmlChar *)v113);
LABEL_219:
      xmlNanoHTTPFreeCtxt((uint64_t)v20);
      if (v17)
        ((void (*)(const char *))*v19)(v17);
      return 0;
    }
    v21 = v18;
    v22 = (const char *)*((_QWORD *)v20 + 1);
    if (!v22)
    {
      v113 = "Failed to identify host in URI";
      v114 = 2022;
      goto LABEL_218;
    }
    v121 = v16;
    v23 = v17;
    v24 = v19;
    v25 = strlen(v22);
    v26 = v25;
    if (proxy_0)
    {
      v26 = 2 * v25 + 16;
      v27 = proxyPort_0;
      v28 = (const char *)proxy_0;
    }
    else
    {
      v27 = *((_DWORD *)v20 + 4);
      v28 = (const char *)*((_QWORD *)v20 + 1);
    }
    v29 = xmlNanoHTTPConnectHost(v28, v27);
    if (v29 == -1)
    {
      xmlNanoHTTPFreeCtxt((uint64_t)v20);
      if (v23)
        ((void (*)(const char *))*v19)(v23);
      return 0;
    }
    *((_DWORD *)v20 + 10) = v29;
    if (v125)
      v30 = v14;
    else
      v30 = 0;
    if (v125)
      v31 = v26 + 36;
    else
      v31 = v26;
    if (__s)
      v31 += strlen(__s) + 2;
    if (v124 && *v124)
      v31 += strlen(*v124) + 16;
    v32 = (const char *)*((_QWORD *)v20 + 4);
    if (v32)
      v31 += strlen(v32) + 1;
    v33 = strlen(v122);
    v34 = v31 + v33 + strlen(*((const char **)v20 + 3));
    v120 = v30;
    if (*((_DWORD *)v20 + 4) == 80)
    {
      v35 = v34 + 47;
    }
    else
    {
      v36 = v34 + 24;
      v37 = v36 + 34;
      v35 = v36 + 40;
      if (!proxy_0)
        v35 = v37;
    }
    v38 = v35;
    v39 = (char *)xmlMallocAtomic(v35);
    if (!v39)
    {
      xmlNanoHTTPFreeCtxt((uint64_t)v20);
      __xmlSimpleError(0xAu, 2, 0, 0, (const xmlChar *)"allocating header buffer");
      return 0;
    }
    v40 = v39;
    if (proxy_0)
    {
      if (*((_DWORD *)v20 + 4) == 80)
        v41 = snprintf(v39, v38, "%s http://%s%s");
      else
        v41 = snprintf(v39, v38, "%s http://%s:%d%s");
    }
    else
    {
      v41 = snprintf(v39, v38, "%s %s");
    }
    v42 = (char *)&v40[v41];
    if (*((_QWORD *)v20 + 4))
      v42 += snprintf((char *)&v40[v41], v38 - v41, "?%s", *((const char **)v20 + 4));
    v43 = &v40[v38];
    v44 = v43 - v42;
    if (*((_DWORD *)v20 + 4) == 80)
      v45 = snprintf(v42, v44, " HTTP/1.0\r\nHost: %s\r\n");
    else
      v45 = snprintf(v42, v44, " HTTP/1.0\r\nHost: %s:%d\r\n");
    v46 = &v42[v45 + snprintf(&v42[v45], v43 - &v42[v45], "Accept-Encoding: gzip\r\n")];
    if (v124 && *v124)
      v46 += snprintf(v46, v43 - v46, "Content-Type: %s\r\n", *v124);
    if (__s)
      v46 += snprintf(v46, v43 - v46, "%s", __s);
    v47 = v43 - v46;
    if (v125)
      snprintf(v46, v47, "Content-Length: %d\r\n\r\n");
    else
      snprintf(v46, v47, "\r\n");
    v18 = v21;
    *((_QWORD *)v20 + 6) = v40;
    *((_QWORD *)v20 + 7) = v40;
    *((_DWORD *)v20 + 11) = 1;
    v48 = strlen(v40);
    xmlNanoHTTPSend((ssize_t)v20, (uint64_t)v40, v48);
    if (v125)
      xmlNanoHTTPSend((ssize_t)v20, v125, v14);
    *((_DWORD *)v20 + 11) = 2;
    v19 = v24;
    v17 = v23;
    while (2)
    {
      v49 = cur;
      bzero(cur, 0x1000uLL);
      while (1)
      {
        v50 = (unsigned __int8 *)*((_QWORD *)v20 + 11);
        if (v50 == *((unsigned __int8 **)v20 + 10))
          break;
LABEL_59:
        *((_QWORD *)v20 + 11) = v50 + 1;
        v52 = *v50;
        *v49 = v52;
        if (v52 != 13)
        {
          if (v52 == 10)
            goto LABEL_65;
          ++v49;
        }
        if (v49 - cur >= 4095)
        {
          v49 = v127;
          goto LABEL_65;
        }
      }
      v51 = xmlNanoHTTPRecv((uint64_t)v20);
      if (v51 == -1)
        break;
      if (v51)
      {
        v50 = (unsigned __int8 *)*((_QWORD *)v20 + 11);
        goto LABEL_59;
      }
      if (v49 == cur)
        break;
LABEL_65:
      *v49 = 0;
      v53 = (const char *)((uint64_t (*)(char *))*v18)(cur);
      if (v53)
      {
        v54 = v53;
        if (*v53)
        {
          if (!strncmp(v53, "HTTP/", 5uLL))
          {
            v55 = v54 + 5;
            v56 = *((unsigned __int8 *)v54 + 5);
            if (v56 - 48 > 9)
            {
              v57 = 0;
            }
            else
            {
              v57 = 0;
              do
              {
                v57 = v56 + 10 * v57 - 48;
                v58 = *(unsigned __int8 *)++v55;
                v56 = v58;
              }
              while (v58 - 48 < 0xA);
            }
            if (v56 == 46)
            {
              v76 = v55[1];
              v74 = v55 + 1;
              v75 = v76;
              v77 = v76 - 48;
              if ((v76 - 48) < 0xA)
                ++v74;
              v55 = v74 - 1;
              do
              {
                v78 = *(unsigned __int8 *)++v55;
                v56 = v78;
              }
              while (v78 - 48 < 0xA);
              v79 = 10 * v57 + v75 - 48;
              if (v77 < 0xAu)
                v57 = v79;
            }
            else
            {
              v57 *= 10;
            }
            if (v56 == 32 || v56 == 9)
            {
              while (v56 == 32 || v56 == 9)
              {
                v81 = *(unsigned __int8 *)++v55;
                v56 = v81;
              }
              if (v56 - 58 >= 0xFFFFFFF6)
              {
                v82 = 0;
                v83 = 1;
                do
                {
                  v82 = v56 + 10 * v82 - 48;
                  v56 = v55[v83++];
                }
                while (v56 - 48 < 0xA);
                if (v56 <= 0x20 && ((1 << v56) & 0x100000201) != 0)
                {
                  *((_DWORD *)v20 + 26) = v82;
                  *((_DWORD *)v20 + 27) = v57;
                }
              }
            }
            goto LABEL_189;
          }
          if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Content-Type:", 13))
          {
            if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"ContentType:", 12))
            {
              if (!xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Location:", 9))
              {
                for (i = (const xmlChar *)(v54 + 9); ; ++i)
                {
                  v90 = *i;
                  if (v90 != 32 && v90 != 9)
                    break;
                }
                if (*((_QWORD *)v20 + 16))
                {
                  ((void (*)(void))*v19)();
                  v90 = *i;
                }
                if (v90 == 47)
                {
                  v92 = xmlStrdup((const xmlChar *)"http://");
                  v93 = xmlStrcat(v92, *((const xmlChar **)v20 + 1));
                  v94 = xmlStrcat(v93, i);
                }
                else
                {
                  v94 = (xmlChar *)((uint64_t (*)(const xmlChar *))*v18)(i);
                }
                *((_QWORD *)v20 + 16) = v94;
                goto LABEL_189;
              }
              if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"WWW-Authenticate:", 17))
              {
                if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Proxy-Authenticate:", 19))
                {
                  if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Content-Encoding:", 17))
                  {
                    if (!xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Content-Length:", 15))
                      *((_DWORD *)v20 + 28) = strtol(v54 + 15, 0, 10);
                  }
                  else
                  {
                    for (j = (const xmlChar *)(v54 + 17); ; ++j)
                    {
                      v110 = *j;
                      if (v110 != 32 && v110 != 9)
                        break;
                    }
                    if (!xmlStrncasecmp(j, (const xmlChar *)"gzip", 4))
                    {
                      *((_DWORD *)v20 + 42) = 1;
                      v112 = (z_stream *)xmlMalloc(0x70uLL);
                      *((_QWORD *)v20 + 20) = v112;
                      if (v112)
                      {
                        v112->avail_in = 0;
                        v112->next_in = 0;
                        v112->zfree = 0;
                        v112->opaque = 0;
                        v112->zalloc = 0;
                        inflateInit2_(v112, 31, "1.2.12", 112);
                      }
                    }
                  }
LABEL_189:
                  ((void (*)(const char *))*v19)(v54);
                  continue;
                }
                for (k = (unsigned __int8 *)(v54 + 19); ; ++k)
                {
                  v107 = *k;
                  if (v107 != 32 && v107 != 9)
                    break;
                }
              }
              else
              {
                for (k = (unsigned __int8 *)(v54 + 17); ; ++k)
                {
                  v96 = *k;
                  if (v96 != 32 && v96 != 9)
                    break;
                }
              }
              if (*((_QWORD *)v20 + 17))
                ((void (*)(void))*v19)();
              *((_QWORD *)v20 + 17) = ((uint64_t (*)(unsigned __int8 *))*v18)(k);
              goto LABEL_189;
            }
            if (*((_QWORD *)v20 + 15))
              goto LABEL_189;
            v85 = v54 + 12;
            for (m = (const xmlChar *)(v54 + 12); ; ++m)
            {
              v87 = *m;
              if (v87 != 32 && v87 != 9)
                break;
              ++v85;
            }
            v98 = ((uint64_t (*)(const xmlChar *))*v18)(m);
            v99 = 0;
            *((_QWORD *)v20 + 15) = v98;
            while (1)
            {
              v100 = m[v99];
              v65 = v100 > 0x3B;
              v101 = (1 << v100) & 0x800100100000201;
              if (!v65 && v101 != 0)
                break;
              ++v99;
            }
            if (*((_QWORD *)v20 + 19))
              ((void (*)(void))*v19)();
            *((_QWORD *)v20 + 19) = xmlStrndup(m, v99);
            v103 = xmlStrstr(*((const xmlChar **)v20 + 15), (const xmlChar *)"charset=");
            v18 = v21;
            if (!v103)
              goto LABEL_189;
            v69 = 0;
            v70 = v103 + 8;
            while (1)
            {
              v104 = v70[v69];
              v65 = v104 > 0x3B;
              v105 = (1 << v104) & 0x800100100000201;
              if (!v65 && v105 != 0)
                break;
              ++v69;
            }
          }
          else
          {
            v59 = v54 + 13;
            for (n = (const xmlChar *)(v54 + 13); ; ++n)
            {
              v61 = *n;
              if (v61 != 32 && v61 != 9)
                break;
              ++v59;
            }
            if (*((_QWORD *)v20 + 15))
              ((void (*)(void))*v19)();
            v63 = 0;
            *((_QWORD *)v20 + 15) = ((uint64_t (*)(const xmlChar *))*v21)(n);
            while (1)
            {
              v64 = n[v63];
              v65 = v64 > 0x3B;
              v66 = (1 << v64) & 0x800100100000201;
              if (!v65 && v66 != 0)
                break;
              ++v63;
            }
            if (*((_QWORD *)v20 + 19))
              ((void (*)(void))*v19)();
            *((_QWORD *)v20 + 19) = xmlStrndup(n, v63);
            v68 = xmlStrstr(*((const xmlChar **)v20 + 15), (const xmlChar *)"charset=");
            v18 = v21;
            if (!v68)
              goto LABEL_189;
            v69 = 0;
            v70 = v68 + 8;
            while (1)
            {
              v71 = v70[v69];
              v65 = v71 > 0x3B;
              v72 = (1 << v71) & 0x800100100000201;
              if (!v65 && v72 != 0)
                break;
              ++v69;
            }
          }
          if (*((_QWORD *)v20 + 18))
            ((void (*)(void))*v19)();
          *((_QWORD *)v20 + 18) = xmlStrndup(v70, v69);
          v18 = v21;
          goto LABEL_189;
        }
        *((_QWORD *)v20 + 9) = *((_QWORD *)v20 + 11);
        ((void (*)(const char *))*v19)(v53);
      }
      break;
    }
    if (!*((_QWORD *)v20 + 16) || (*((_DWORD *)v20 + 26) - 300) > 0x63)
    {
      v115 = v124;
      if (v124)
      {
        v116 = *((_QWORD *)v20 + 15);
        if (v116)
        {
          v116 = ((uint64_t (*)(void))*v18)();
          v115 = v124;
        }
        *v115 = v116;
      }
      if (v118 && v23)
      {
        *v118 = v23;
      }
      else
      {
        if (v23)
          ((void (*)(const char *))*v19)(v23);
        if (v118)
          *v118 = 0;
      }
      return v20;
    }
    while ((int)xmlNanoHTTPRecv((uint64_t)v20) > 0)
      ;
    if (v121 == 10)
      goto LABEL_219;
    if (v23)
      ((void (*)(const char *))*v19)(v23);
    v16 = v121 + 1;
    v17 = (const char *)((uint64_t (*)(_QWORD))*v18)(*((_QWORD *)v20 + 16));
    xmlNanoHTTPFreeCtxt((uint64_t)v20);
    v14 = v120;
    if (!v17)
      continue;
    break;
  }
  v20 = xmlNanoHTTPNewCtxt(v17);
  if (v20)
  {
    *((_QWORD *)v20 + 16) = ((uint64_t (*)(const char *))*v18)(v17);
    goto LABEL_8;
  }
  return v20;
}

int xmlNanoHTTPRead(void *ctx, void *dest, int len)
{
  int v3;
  z_stream *v7;
  int v8;
  int avail_in;
  int v10;
  uint64_t v11;
  uInt v12;
  int v13;
  const void *v14;
  uint64_t v15;

  v3 = -1;
  if (!ctx || !dest)
    return v3;
  if (len < 1)
    return 0;
  if (*((_DWORD *)ctx + 42) == 1)
  {
    v7 = (z_stream *)*((_QWORD *)ctx + 20);
    if (v7)
    {
      v8 = 0;
      v7->next_out = (Bytef *)dest;
      v7->avail_out = len;
      avail_in = *((_DWORD *)ctx + 20) - *((_DWORD *)ctx + 22);
      v7->avail_in = avail_in;
      do
      {
        if (!v7->avail_out)
          break;
        if (!avail_in)
        {
          v10 = xmlNanoHTTPRecv((uint64_t)ctx);
          v7 = (z_stream *)*((_QWORD *)ctx + 20);
          if (v10 < 1)
            break;
        }
        v11 = *((_QWORD *)ctx + 11);
        v12 = *((_DWORD *)ctx + 20) - (v8 + v11);
        v7->avail_in = v12;
        v7->next_in = (Bytef *)(v11 + v8);
        v13 = inflate(v7, 0);
        v7 = (z_stream *)*((_QWORD *)ctx + 20);
        avail_in = v7->avail_in;
        v8 += v12 - avail_in;
      }
      while (!v13);
      *((_QWORD *)ctx + 11) += v8;
      return len - v7->avail_out;
    }
    return 0;
  }
  while (1)
  {
    v14 = (const void *)*((_QWORD *)ctx + 11);
    v15 = *((_QWORD *)ctx + 10) - (_QWORD)v14;
    if (v15 >= len)
      break;
    if ((int)xmlNanoHTTPRecv((uint64_t)ctx) <= 0)
    {
      v14 = (const void *)*((_QWORD *)ctx + 11);
      v15 = *((_QWORD *)ctx + 10) - (_QWORD)v14;
      break;
    }
  }
  if (v15 >= len)
    v3 = len;
  else
    v3 = v15;
  memcpy(dest, v14, v3);
  *((_QWORD *)ctx + 11) += v3;
  return v3;
}

ssize_t xmlNanoHTTPRecv(uint64_t a1)
{
  ssize_t result;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int v11;
  pollfd v12;

  if ((*(_BYTE *)(a1 + 44) & 2) == 0)
    return 0;
  v12 = 0;
  while (1)
  {
    v3 = *(char **)(a1 + 64);
    if (v3)
    {
      v4 = *(char **)(a1 + 80);
      v5 = *(char **)(a1 + 88);
    }
    else
    {
      v6 = (char *)xmlMallocAtomic(0xFDE8uLL);
      *(_QWORD *)(a1 + 64) = v6;
      if (!v6)
      {
        __xmlSimpleError(0xAu, 2, 0, 0, (const xmlChar *)"allocating input");
        goto LABEL_29;
      }
      v4 = v6;
      *(_DWORD *)(a1 + 96) = 65000;
      *(_QWORD *)(a1 + 80) = v6;
      *(_QWORD *)(a1 + 88) = v6;
      v3 = v6;
      v5 = v6;
      *(_QWORD *)(a1 + 72) = v6;
    }
    if (v5 > v3 + 4096)
    {
      v7 = (_DWORD)v5 - (_DWORD)v3;
      memmove(v3, v5, (int)v4 - (int)v5);
      v5 = (char *)(*(_QWORD *)(a1 + 88) - ((int)v5 - (int)v3));
      v3 = *(char **)(a1 + 64);
      v4 = (char *)(*(_QWORD *)(a1 + 80) - v7);
      *(_QWORD *)(a1 + 72) -= v7;
      *(_QWORD *)(a1 + 80) = v4;
      *(_QWORD *)(a1 + 88) = v5;
    }
    v8 = *(int *)(a1 + 96);
    if (&v3[v8] < v4 + 4096)
    {
      v9 = *(_QWORD *)(a1 + 72);
      *(_DWORD *)(a1 + 96) = 2 * v8;
      v10 = (char *)xmlRealloc(v3, 2 * v8);
      *(_QWORD *)(a1 + 64) = v10;
      if (v10)
      {
        v4 = &v10[(int)v4 - (int)v3];
        *(_QWORD *)(a1 + 72) = &v10[(int)v9 - (int)v3];
        *(_QWORD *)(a1 + 80) = v4;
        *(_QWORD *)(a1 + 88) = &v10[(int)v5 - (int)v3];
        goto LABEL_14;
      }
      __xmlSimpleError(0xAu, 2, 0, 0, (const xmlChar *)"allocating input buffer");
      xmlFree(v3);
LABEL_29:
      result = 0xFFFFFFFFLL;
      *(_DWORD *)(a1 + 100) = -1;
      return result;
    }
LABEL_14:
    result = recv(*(_DWORD *)(a1 + 40), v4, 0x1000uLL, 0);
    *(_DWORD *)(a1 + 100) = result;
    if ((int)result >= 1)
    {
      *(_QWORD *)(a1 + 80) += result;
      return result;
    }
    if ((_DWORD)result != -1)
    {
      if (!(_DWORD)result)
        return result;
      goto LABEL_19;
    }
    v11 = *__error();
    if ((v11 - 35) >= 2)
      break;
LABEL_19:
    v12.fd = *(_DWORD *)(a1 + 40);
    v12.events = 1;
    if (poll(&v12, 1u, 60000) <= 0 && *__error() != 4 || (*(_BYTE *)(a1 + 44) & 2) == 0)
      return 0;
  }
  result = 0;
  if (v11 != 54 && v11 != 58)
  {
    __xmlIOErr(0xAu, 0, (const xmlChar *)"recv failed\n");
    return 0xFFFFFFFFLL;
  }
  return result;
}

void xmlNanoHTTPClose(void *ctx)
{
  if (ctx)
    xmlNanoHTTPFreeCtxt((uint64_t)ctx);
}

void xmlNanoHTTPFreeCtxt(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  z_stream *v12;
  int v13;

  v2 = *(void **)(a1 + 8);
  if (v2)
    xmlFree(v2);
  if (*(_QWORD *)a1)
    xmlFree(*(void **)a1);
  v3 = *(void **)(a1 + 24);
  if (v3)
    xmlFree(v3);
  v4 = *(void **)(a1 + 32);
  if (v4)
    xmlFree(v4);
  v5 = *(void **)(a1 + 48);
  if (v5)
    xmlFree(v5);
  v6 = *(void **)(a1 + 64);
  if (v6)
    xmlFree(v6);
  v7 = *(void **)(a1 + 120);
  if (v7)
    xmlFree(v7);
  v8 = *(void **)(a1 + 144);
  if (v8)
    xmlFree(v8);
  v9 = *(void **)(a1 + 152);
  if (v9)
    xmlFree(v9);
  v10 = *(void **)(a1 + 128);
  if (v10)
    xmlFree(v10);
  v11 = *(void **)(a1 + 136);
  if (v11)
    xmlFree(v11);
  v12 = *(z_stream **)(a1 + 160);
  if (v12)
  {
    inflateEnd(v12);
    xmlFree(*(void **)(a1 + 160));
  }
  *(_DWORD *)(a1 + 44) = 4;
  v13 = *(_DWORD *)(a1 + 40);
  if (v13 != -1)
    close(v13);
  *(_DWORD *)(a1 + 40) = -1;
  xmlFree((void *)a1);
}

_OWORD *xmlNanoHTTPNewCtxt(const char *a1)
{
  _OWORD *v2;
  _OWORD *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  xmlURIPtr v8;
  xmlURI *v9;
  const char *scheme;
  const char *server;
  int v12;
  void *v13;
  const char *path;
  const char *query;
  int port;

  v2 = xmlMalloc(0xB0uLL);
  v3 = v2;
  if (v2)
  {
    v2[6] = 0u;
    v2[7] = 0u;
    *v2 = 0u;
    v2[1] = 0u;
    v2[9] = 0u;
    v2[10] = 0u;
    v2[8] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *((_DWORD *)v2 + 4) = 80;
    *((_DWORD *)v2 + 26) = 0;
    *((_DWORD *)v2 + 10) = -1;
    *((_DWORD *)v2 + 28) = -1;
    v4 = *(void **)v2;
    if (*(_QWORD *)v3)
    {
      xmlFree(v4);
      *(_QWORD *)v3 = 0;
    }
    v5 = (void *)*((_QWORD *)v3 + 1);
    if (v5)
    {
      xmlFree(v5);
      *((_QWORD *)v3 + 1) = 0;
    }
    v6 = (void *)*((_QWORD *)v3 + 3);
    if (v6)
    {
      xmlFree(v6);
      *((_QWORD *)v3 + 3) = 0;
    }
    v7 = (void *)*((_QWORD *)v3 + 4);
    if (v7)
    {
      xmlFree(v7);
      *((_QWORD *)v3 + 4) = 0;
    }
    v8 = xmlParseURIRaw(a1, 1);
    if (v8)
    {
      v9 = v8;
      scheme = v8->scheme;
      if (scheme && v9->server)
      {
        *(_QWORD *)v3 = xmlMemStrdup(scheme);
        server = v9->server;
        if (server && *server == 91 && (v12 = strlen(v9->server), v12 >= 3) && server[v12 - 1] == 93)
          v13 = xmlCharStrndup(server + 1, v12 - 2);
        else
          v13 = xmlMemStrdup(server);
        *((_QWORD *)v3 + 1) = v13;
        if (v9->path)
          path = v9->path;
        else
          path = "/";
        *((_QWORD *)v3 + 3) = xmlMemStrdup(path);
        query = v9->query;
        if (query)
          *((_QWORD *)v3 + 4) = xmlMemStrdup(query);
        port = v9->port;
        if (port)
          *((_DWORD *)v3 + 4) = port;
      }
      xmlFreeURI(v9);
    }
  }
  else
  {
    __xmlSimpleError(0xAu, 2, 0, 0, (const xmlChar *)"allocating context");
  }
  return v3;
}

uint64_t xmlNanoHTTPConnectHost(const char *a1, unsigned int a2)
{
  const char *v4;
  hostent *v5;
  hostent *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t *v9;
  uint64_t v10;
  addrinfo *v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  addrinfo *v16;
  uint64_t v17;
  addrinfo *v19;
  addrinfo v20;
  uint64_t v21;
  __int128 v22;
  int v23;
  __int128 v24;
  _QWORD v25[3];

  v25[2] = *MEMORY[0x1E0C80C00];
  v24 = 0uLL;
  v25[0] = 0;
  v25[1] = 0;
  v22 = 0uLL;
  v21 = 0;
  v23 = 0;
  if (!have_ipv6())
  {
    v20.ai_flags = 0;
    v5 = gethostbyname(a1);
    if (!v5)
    {
      v4 = "Failed to resolve host";
      goto LABEL_35;
    }
    v6 = v5;
    if (*v5->h_addr_list)
    {
      v7 = 0;
      v8 = bswap32(a2) >> 16;
      do
      {
        if (v6->h_addrtype == 2)
        {
          if (v6->h_length >= 5u)
            goto LABEL_34;
          __memcpy_chk();
          BYTE1(v25[0]) = 2;
          HIDWORD(v25[0]) = v20.ai_flags;
          v9 = v25;
        }
        else
        {
          if (!have_ipv6() || v6->h_addrtype != 30)
            return 0xFFFFFFFFLL;
          if (v6->h_length >= 0x11u)
          {
LABEL_34:
            v4 = "address size mismatch\n";
LABEL_35:
            __xmlIOErr(0xAu, 0, (const xmlChar *)v4);
            return 0xFFFFFFFFLL;
          }
          __memcpy_chk();
          BYTE1(v21) = 30;
          v22 = v24;
          v9 = &v21;
        }
        *((_WORD *)v9 + 1) = v8;
        v10 = xmlNanoHTTPConnectAttempt((const sockaddr *)v9);
        if ((_DWORD)v10 != -1)
          return v10;
      }
      while (v6->h_addr_list[++v7]);
    }
    return 0xFFFFFFFFLL;
  }
  v19 = 0;
  memset(&v20, 0, sizeof(v20));
  v20.ai_socktype = 1;
  if (getaddrinfo(a1, 0, &v20, &v19))
  {
    v4 = "getaddrinfo failed\n";
    goto LABEL_35;
  }
  v12 = v19;
  if (!v19)
    return 0xFFFFFFFFLL;
  v13 = bswap32(a2) >> 16;
  while (1)
  {
    if (v12->ai_family == 2)
    {
      if (v12->ai_addrlen >= 0x11)
        goto LABEL_31;
      v14 = v25;
    }
    else
    {
      if (!have_ipv6() || v12->ai_family != 30)
        goto LABEL_27;
      if (v12->ai_addrlen >= 0x1D)
      {
LABEL_31:
        __xmlIOErr(0xAu, 0, (const xmlChar *)"address size mismatch\n");
        v16 = v19;
LABEL_32:
        freeaddrinfo(v16);
        return 0xFFFFFFFFLL;
      }
      v14 = &v21;
    }
    __memcpy_chk();
    *((_WORD *)v14 + 1) = v13;
    v15 = xmlNanoHTTPConnectAttempt((const sockaddr *)v14);
    if ((_DWORD)v15 != -1)
      break;
LABEL_27:
    v12 = v12->ai_next;
    if (!v12)
    {
      v16 = v19;
      if (!v19)
        return 0xFFFFFFFFLL;
      goto LABEL_32;
    }
  }
  v17 = v15;
  freeaddrinfo(v19);
  return v17;
}

ssize_t xmlNanoHTTPSend(ssize_t result, uint64_t a2, int a3)
{
  ssize_t v4;
  int v7;
  pollfd v8;

  if (a2)
  {
    v4 = result;
    if ((*(_DWORD *)(result + 44) & 1) != 0 && a3 >= 1)
    {
      v7 = 0;
      v8 = 0;
      do
      {
        result = send(*(_DWORD *)(v4 + 40), (const void *)(a2 + v7), a3 - v7, 0);
        if ((int)result < 1)
        {
          if ((_DWORD)result == -1 && *__error() != 35)
            return (ssize_t)__xmlIOErr(0xAu, 0, (const xmlChar *)"send failed\n");
          v8.fd = *(_DWORD *)(v4 + 40);
          v8.events = 4;
          result = poll(&v8, 1u, 60000);
        }
        else
        {
          v7 += result;
        }
      }
      while (v7 < a3);
    }
  }
  return result;
}

int xmlNanoHTTPFetch(const char *URL, const char *filename, char **contentType)
{
  void *v5;
  uint64_t v6;
  int v7;
  int v8;
  int __nbyte[3];

  *(_QWORD *)&__nbyte[1] = 0;
  if (!filename)
    return -1;
  if (contentType)
    *contentType = 0;
  v5 = xmlNanoHTTPMethodRedir(URL, 0, 0, contentType, 0, 0, 0);
  if (!v5)
    return -1;
  v6 = (uint64_t)v5;
  if (!strcmp(filename, "-"))
  {
    v7 = 0;
  }
  else
  {
    v7 = open(filename, 513, 420);
    if (v7 < 0)
    {
      xmlNanoHTTPFreeCtxt(v6);
      if (contentType && *contentType)
      {
        xmlFree(*contentType);
        *contentType = 0;
      }
      return -1;
    }
  }
  __nbyte[0] = 0;
  xmlNanoHTTPFetchContent(v6, &__nbyte[1], __nbyte);
  if (__nbyte[0] < 1)
  {
    v8 = 0;
  }
  else if (write(v7, *(const void **)&__nbyte[1], __nbyte[0]) == -1)
  {
    v8 = -1;
  }
  else
  {
    v8 = 0;
  }
  xmlNanoHTTPFreeCtxt(v6);
  close(v7);
  return v8;
}

ssize_t xmlNanoHTTPFetchContent(ssize_t result, _QWORD *a2, int *a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  v5 = *(_QWORD *)(result + 72);
  if (v5)
  {
    v6 = result;
    v7 = *(_DWORD *)(result + 80) - v5;
    do
    {
      result = xmlNanoHTTPRecv(v6);
      if ((int)result < 1)
        break;
      v7 += result;
      v8 = *(_DWORD *)(v6 + 112);
    }
    while (v8 < 1 || v7 < v8);
    if (a2)
      *a2 = *(_QWORD *)(v6 + 72);
    if (a3)
      *a3 = v7;
  }
  else
  {
    if (a3)
      *a3 = 0;
    if (a2)
      *a2 = 0;
  }
  return result;
}

int xmlNanoHTTPSave(void *ctxt, const char *filename)
{
  int v2;
  int v5;
  int __nbyte[3];

  *(_QWORD *)&__nbyte[1] = 0;
  v2 = -1;
  if (ctxt && filename)
  {
    if (!strcmp(filename, "-"))
    {
      v5 = 0;
    }
    else
    {
      v5 = open(filename, 513, 438);
      if (v5 < 0)
      {
        xmlNanoHTTPFreeCtxt((uint64_t)ctxt);
        return v2;
      }
    }
    __nbyte[0] = 0;
    xmlNanoHTTPFetchContent((ssize_t)ctxt, &__nbyte[1], __nbyte);
    if (__nbyte[0] < 1)
    {
      v2 = 0;
    }
    else if (write(v5, *(const void **)&__nbyte[1], __nbyte[0]) == -1)
    {
      v2 = -1;
    }
    else
    {
      v2 = 0;
    }
    xmlNanoHTTPFreeCtxt((uint64_t)ctxt);
    close(v5);
  }
  return v2;
}

int xmlNanoHTTPReturnCode(void *ctx)
{
  if (ctx)
    return *((_DWORD *)ctx + 26);
  else
    return -1;
}

const char *__cdecl xmlNanoHTTPAuthHeader(const char *ctx)
{
  if (ctx)
    return (const char *)*((_QWORD *)ctx + 17);
  return ctx;
}

int xmlNanoHTTPContentLength(void *ctx)
{
  if (ctx)
    return *((_DWORD *)ctx + 28);
  else
    return -1;
}

const char *__cdecl xmlNanoHTTPRedir(const char *ctx)
{
  if (ctx)
    return (const char *)*((_QWORD *)ctx + 16);
  return ctx;
}

const char *__cdecl xmlNanoHTTPEncoding(const char *ctx)
{
  if (ctx)
    return (const char *)*((_QWORD *)ctx + 18);
  return ctx;
}

const char *__cdecl xmlNanoHTTPMimeType(const char *ctx)
{
  if (ctx)
    return (const char *)*((_QWORD *)ctx + 19);
  return ctx;
}

uint64_t have_ipv6()
{
  int v0;

  v0 = socket(30, 1, 0);
  if (v0 == -1)
    return 0;
  close(v0);
  return 1;
}

uint64_t xmlNanoHTTPConnectAttempt(const sockaddr *a1)
{
  int sa_family;
  int v3;
  socklen_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  const char *v9;
  int v11;
  socklen_t revents;
  int v13;
  pollfd v14;

  sa_family = a1->sa_family;
  if (sa_family == 30)
    v3 = 30;
  else
    v3 = 2;
  if (sa_family == 30)
    v4 = 28;
  else
    v4 = 16;
  v5 = socket(v3, 1, 6);
  v6 = v5;
  if ((_DWORD)v5 == -1)
  {
    __xmlIOErr(0xAu, 0, (const xmlChar *)"socket failed\n");
    return v6;
  }
  v7 = fcntl(v5, 3, 0);
  if (v7 == -1 || (v13 = fcntl(v6, 4, v7 | 4u), v13 < 0))
  {
    v9 = "error setting non-blocking IO\n";
  }
  else
  {
    v14 = 0;
    if (connect(v6, a1, v4) == -1 && (*__error() - 35) >= 2)
    {
      v9 = "error connecting to HTTP server";
    }
    else
    {
      v14.fd = v6;
      v14.events = 4;
      v8 = poll(&v14, 1u, 60000);
      if (v8 == -1)
      {
        v9 = "Connect failed";
      }
      else if (v8)
      {
        if (v14.revents == 4)
        {
          revents = (unsigned __int16)v14.revents;
          if ((getsockopt(v6, 0xFFFF, 4103, &v13, &revents) & 0x80000000) == 0)
          {
            if (!v13)
              return v6;
            __xmlIOErr(0xAu, 0, (const xmlChar *)"Error connecting to remote host");
            close(v6);
            v11 = v13;
            *__error() = v11;
            return 0xFFFFFFFFLL;
          }
          v9 = "getsockopt failed\n";
        }
        else
        {
          v9 = "select failed\n";
        }
      }
      else
      {
        v9 = "Connect attempt timed out";
      }
    }
  }
  __xmlIOErr(0xAu, 0, (const xmlChar *)v9);
  close(v6);
  return 0xFFFFFFFFLL;
}

int xmlHasFeature(xmlFeature feature)
{
  if (feature - 1 > 0x20)
    return 0;
  else
    return dword_1B086220C[feature - 1];
}

int xmlCheckLanguageID(const xmlChar *lang)
{
  unsigned int v1;
  const xmlChar *v2;
  int v3;
  int v4;
  BOOL v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  const xmlChar *v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  const xmlChar *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (lang)
  {
    v1 = *lang;
    if (v1 > 0x68)
    {
      if (v1 != 120 && v1 != 105)
        goto LABEL_12;
    }
    else if (v1 != 73 && v1 != 88)
    {
LABEL_12:
      v6 = 0;
      do
        v7 = lang[v6++];
      while ((v7 & 0xFFFFFFDF) - 65 < 0x1A);
      v8 = v6 - 1;
      if (v6 - 1 >= 4)
      {
        v5 = (unint64_t)v8 < 9 && v7 == 0;
LABEL_18:
        LODWORD(lang) = v5;
        return (int)lang;
      }
      if (v8 >= 2)
      {
        if (!v7)
          goto LABEL_59;
        if (v7 == 45)
        {
          v9 = &lang[v6];
          v10 = lang[v6];
          if ((v10 - 48) < 0xA)
            goto LABEL_26;
          if ((v10 & 0xFFFFFFDF) - 65 <= 0x19)
          {
            do
            {
              v12 = *++v9;
              v10 = v12;
            }
            while ((v12 & 0xFFFFFFDF) - 65 < 0x1A);
          }
          v13 = v9 - lang - v6;
          if (v13 == 2)
            goto LABEL_53;
          if (v13 == 4)
            goto LABEL_33;
          if ((unint64_t)(v13 - 5) < 4)
            goto LABEL_60;
          if (v9 - lang - 3 == v6)
          {
            if (!v10)
              goto LABEL_59;
            if (v10 == 45)
            {
              v14 = v9 + 1;
              if (v9[1] - 48 < 0xA)
                goto LABEL_36;
              v15 = 0;
              do
                v10 = v9[++v15];
              while ((v10 & 0xFFFFFFDF) - 65 < 0x1A);
              v9 += v15;
              if (v15 == 3)
                goto LABEL_53;
              if ((unint64_t)(v15 - 6) < 4)
                goto LABEL_60;
              if (v15 == 5)
              {
LABEL_33:
                if (!v10)
                  goto LABEL_59;
                if (v10 == 45)
                {
                  v14 = v9 + 1;
                  if (v9[1] - 48 < 0xA)
                  {
LABEL_36:
                    v9 = v14;
LABEL_26:
                    if (v9[1] - 48 > 9 || v9[2] - 48 > 9)
                      goto LABEL_58;
                    v11 = v9[3];
                    v9 += 3;
                    v10 = v11;
LABEL_53:
                    if (v10)
                    {
                      if (v10 != 45)
                        goto LABEL_58;
                      v17 = 1;
                      do
                        v10 = v9[v17++];
                      while ((v10 & 0xFFFFFFDF) - 65 < 0x1A);
                      if ((unint64_t)(v17 - 11) < 0xFFFFFFFFFFFFFFFCLL)
                        goto LABEL_58;
LABEL_60:
                      if (v10)
                        v5 = v10 == 45;
                      else
                        v5 = 1;
                      goto LABEL_18;
                    }
LABEL_59:
                    LODWORD(lang) = 1;
                    return (int)lang;
                  }
                  v16 = 0;
                  do
                    v10 = v9[++v16];
                  while ((v10 & 0xFFFFFFDF) - 65 < 0x1A);
                  if ((unint64_t)(v16 - 6) < 4)
                    goto LABEL_60;
                  if (v16 == 3)
                  {
                    v9 += 3;
                    goto LABEL_53;
                  }
                }
              }
            }
          }
        }
      }
LABEL_58:
      LODWORD(lang) = 0;
      return (int)lang;
    }
    if (lang[1] == 45)
    {
      v2 = lang + 2;
      do
      {
        v4 = *v2++;
        v3 = v4;
      }
      while ((v4 & 0xFFFFFFDF) - 65 < 0x1A);
      v5 = v3 == 0;
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  return (int)lang;
}

_DWORD *xmlFatalErrMsgInt(_DWORD *result, int a2, const char *a3, int a4)
{
  _DWORD *v4;

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 3, 0, 0, 0, 0, 0, a4, 0, a3, a4);
  v4 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, 0, 0, 0, a4, 0, a3, a4);
    v4[6] = 0;
    if (!v4[112])
      v4[83] = 1;
  }
  return result;
}

int namePush(xmlParserCtxtPtr ctxt, const xmlChar *value)
{
  int result;
  uint64_t nameMax;
  const xmlChar **nameTab;
  const xmlChar **v7;

  if (!ctxt)
    return -1;
  result = ctxt->nameNr;
  nameMax = ctxt->nameMax;
  if (result < (int)nameMax)
  {
    nameTab = ctxt->nameTab;
LABEL_7:
    nameTab[result] = value;
    ctxt->name = value;
    ctxt->nameNr = result + 1;
    return result;
  }
  v7 = (const xmlChar **)xmlRealloc(ctxt->nameTab, 16 * nameMax);
  if (v7)
  {
    nameTab = v7;
    ctxt->nameTab = v7;
    ctxt->nameMax *= 2;
    result = ctxt->nameNr;
    goto LABEL_7;
  }
  htmlErrMemory(ctxt, 0);
  return -1;
}

const xmlChar *__cdecl namePop(const xmlChar *ctxt)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;

  if (ctxt)
  {
    v1 = *((_DWORD *)ctxt + 74);
    v2 = v1 - 1;
    if (v1 < 1)
    {
      return 0;
    }
    else
    {
      *((_DWORD *)ctxt + 74) = v2;
      v3 = *((_QWORD *)ctxt + 38);
      if (v1 == 1)
        v4 = 0;
      else
        v4 = *(_QWORD *)(v3 + 8 * (v1 - 2));
      *((_QWORD *)ctxt + 36) = v4;
      ctxt = *(const xmlChar **)(v3 + 8 * v2);
      *(_QWORD *)(v3 + 8 * v2) = 0;
    }
  }
  return ctxt;
}

void xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
  const xmlChar *v2;
  const char *v3;
  xmlGenericErrorFunc v4;
  void **v5;
  getParameterEntitySAXFunc getParameterEntity;
  uint64_t v7;
  xmlParserInput *v8;
  const xmlChar *cur;
  xmlCharEncoding v10;
  const xmlChar *v11;
  unsigned int v12;
  unsigned __int8 in[4];

  if (*ctxt->input->cur == 37)
  {
    xmlNextChar(ctxt);
    v2 = xmlParseName(ctxt);
    if (!v2)
    {
      xmlFatalErrMsg(ctxt, 24, (char)"PEReference: no name\n");
      return;
    }
    v3 = (const char *)v2;
    if (*__xmlParserDebugEntities())
    {
      v4 = *__xmlGenericError();
      v5 = __xmlGenericErrorContext();
      v4(*v5, "PEReference: %s\n", v3);
    }
    if (*ctxt->input->cur != 59)
    {
      xmlFatalErr(ctxt, 25, 0);
      return;
    }
    xmlNextChar(ctxt);
    ++ctxt->nbentities;
    if (ctxt->sax && (getParameterEntity = ctxt->sax->getParameterEntity) != 0)
      v7 = ((uint64_t (*)(void *, const char *))getParameterEntity)(ctxt->userData, v3);
    else
      v7 = 0;
    if (ctxt->instate != XML_PARSER_EOF)
    {
      if (!v7)
      {
        if (ctxt->standalone != 1 && (ctxt->hasExternalSubset || ctxt->hasPErefs))
        {
          if (ctxt->validate && ctxt->vctxt.error)
            xmlValidityError(ctxt, 27, "PEReference: %%%s; not found\n", (const xmlChar *)v3, 0);
          else
            xmlWarningMsg(ctxt, 27, "PEReference: %%%s; not found\n", (const xmlChar *)v3);
          ctxt->valid = 0;
        }
        else
        {
          xmlFatalErrMsgStr(ctxt, 26, "PEReference: %%%s; not found\n", (const xmlChar *)v3);
        }
        xmlParserEntityCheck((uint64_t)ctxt, 0, 0, 0);
        goto LABEL_48;
      }
      if ((*(_DWORD *)(v7 + 92) & 0xFFFFFFFE) != 4)
      {
        xmlWarningMsg(ctxt, 27, "Internal: %%%s; is not a parameter entity\n", (const xmlChar *)v3);
LABEL_48:
        ctxt->hasPErefs = 1;
        return;
      }
      *(_DWORD *)in = 0;
      if (!xmlParserEntityCheck((uint64_t)ctxt, 0, v7, 0)
        && (*(_DWORD *)(v7 + 92) != 5 || (ctxt->options & 0x1E) != 0 || ctxt->replaceEntities || ctxt->validate))
      {
        v8 = xmlNewEntityInputStream(ctxt, (xmlEntityPtr)v7);
        if (xmlPushInput(ctxt, v8) < 0)
        {
          xmlFreeInputStream(v8);
          return;
        }
        if (*(_DWORD *)(v7 + 92) != 5)
          goto LABEL_48;
        if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
          xmlGROW((uint64_t)ctxt);
        if (ctxt->instate != XML_PARSER_EOF)
        {
          cur = ctxt->input->cur;
          if (ctxt->input->end - cur >= 4)
          {
            *(_DWORD *)in = *(_DWORD *)cur;
            v10 = xmlDetectCharEncoding(in, 4);
            if (v10)
              xmlSwitchEncoding(ctxt, v10);
          }
          v11 = ctxt->input->cur;
          if (*v11 == 60 && v11[1] == 63 && v11[2] == 120 && v11[3] == 109 && v11[4] == 108)
          {
            v12 = v11[5];
            if (v12 <= 0x20 && ((1 << v12) & 0x100002600) != 0)
              xmlParseTextDecl(ctxt);
          }
          goto LABEL_48;
        }
      }
    }
  }
}

xmlChar xmlPopInput(xmlParserCtxtPtr ctxt)
{
  xmlParserCtxtPtr v1;
  xmlGenericErrorFunc v2;
  void **v3;
  int inputNr;
  unsigned int v5;
  xmlParserInputPtr *inputTab;
  xmlParserInput *v7;
  xmlParserInput *v8;

  if (!ctxt)
    return ctxt;
  v1 = ctxt;
  if (ctxt->inputNr < 2)
  {
    LOBYTE(ctxt) = 0;
    return ctxt;
  }
  if (*__xmlParserDebugEntities())
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "Popping input %d\n", v1->inputNr);
  }
  inputNr = v1->inputNr;
  v5 = inputNr - 1;
  if (inputNr > 1)
  {
    if (v1->inSubset || v1->instate == XML_PARSER_EOF)
    {
      v1->inputNr = v5;
      inputTab = v1->inputTab;
      goto LABEL_14;
    }
    xmlFatalErr(v1, 1, (const xmlChar *)"Unfinished entity outside the DTD");
    inputNr = v1->inputNr;
  }
  v5 = inputNr - 1;
  if (inputNr >= 1)
  {
    v1->inputNr = v5;
    inputTab = v1->inputTab;
    if (inputNr == 1)
    {
      v5 = 0;
      v7 = 0;
LABEL_15:
      v1->input = v7;
      v8 = inputTab[v5];
      inputTab[v5] = 0;
      goto LABEL_17;
    }
LABEL_14:
    v7 = inputTab[inputNr - 2];
    goto LABEL_15;
  }
  v8 = 0;
LABEL_17:
  xmlFreeInputStream(v8);
  LOBYTE(ctxt) = *v1->input->cur;
  if (!(_BYTE)ctxt)
  {
    xmlParserInputGrow(v1->input, 250);
    LOBYTE(ctxt) = *v1->input->cur;
  }
  return ctxt;
}

int xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input)
{
  xmlParserInputPtr v4;
  xmlGenericErrorFunc v5;
  void **v6;
  xmlGenericErrorFunc v7;
  void **v8;
  int inputNr;
  int v10;
  int v11;
  unsigned int v12;
  xmlParserInputPtr *inputTab;
  xmlParserInput *v14;
  xmlParserInput *v15;

  if (!input)
    return -1;
  if (*__xmlParserDebugEntities())
  {
    v4 = ctxt->input;
    if (v4 && v4->filename)
    {
      v5 = *__xmlGenericError();
      v6 = __xmlGenericErrorContext();
      v5(*v6, "%s(%d): ", ctxt->input->filename, ctxt->input->line);
    }
    v7 = *__xmlGenericError();
    v8 = __xmlGenericErrorContext();
    v7(*v8, "Pushing input %d : %.30s\n", ctxt->inputNr + 1, (const char *)input->cur);
  }
  inputNr = ctxt->inputNr;
  if (inputNr >= 41 && (inputNr > 0x400 || (ctxt->options & 0x80000) == 0))
  {
    xmlFatalErr(ctxt, 89, 0);
    v11 = ctxt->inputNr;
    if (v11 >= 2)
    {
      do
      {
        v12 = v11 - 1;
        inputTab = ctxt->inputTab;
        v14 = inputTab[v11 - 2];
        ctxt->inputNr = v12;
        ctxt->input = v14;
        v15 = inputTab[v12];
        inputTab[v12] = 0;
        xmlFreeInputStream(v15);
        v11 = ctxt->inputNr;
      }
      while (v11 > 1);
    }
    return -1;
  }
  if (ctxt->instate == XML_PARSER_EOF)
    return -1;
  v10 = inputPush(ctxt, input);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  return v10;
}

void xmlParserHandlePEReference(xmlParserCtxtPtr ctxt)
{
  int v1;
  unsigned int v2;
  BOOL v3;
  uint64_t v4;

  switch(ctxt->instate)
  {
    case XML_PARSER_EOF:
      v1 = 18;
      goto LABEL_14;
    case XML_PARSER_START:
    case XML_PARSER_MISC:
    case XML_PARSER_PROLOG:
      v1 = 19;
      goto LABEL_14;
    case XML_PARSER_PI:
    case XML_PARSER_COMMENT:
    case XML_PARSER_START_TAG:
    case XML_PARSER_CONTENT:
    case XML_PARSER_CDATA_SECTION:
    case XML_PARSER_END_TAG:
    case XML_PARSER_ENTITY_DECL:
    case XML_PARSER_ENTITY_VALUE:
    case XML_PARSER_ATTRIBUTE_VALUE:
    case XML_PARSER_SYSTEM_LITERAL:
    case XML_PARSER_IGNORE:
    case XML_PARSER_PUBLIC_LITERAL:
      return;
    case XML_PARSER_DTD:
      if (!ctxt->external && ctxt->inputNr == 1)
        return;
      v2 = *((unsigned __int8 *)ctxt->input->cur + 1);
      v3 = v2 > 0x20;
      v4 = (1 << v2) & 0x100002601;
      if (!v3 && v4 != 0)
        return;
      goto LABEL_12;
    case XML_PARSER_EPILOG:
      v1 = 20;
LABEL_14:
      xmlFatalErr(ctxt, v1, 0);
      break;
    default:
LABEL_12:
      xmlParsePEReference(ctxt);
      break;
  }
}

xmlChar *__cdecl xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len, int what, xmlChar end, xmlChar end2, xmlChar end3)
{
  xmlChar *v7;
  const xmlChar *v8;
  int v10;
  int v11;
  int v12;
  xmlParserCtxtPtr v14;
  int depth;
  xmlChar *v16;
  int v17;
  uint64_t v18;
  int v19;
  const xmlChar *v20;
  int v21;
  const xmlChar *v22;
  int v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  xmlGenericErrorFunc v27;
  void **v28;
  xmlChar *v29;
  xmlChar *v30;
  const xmlChar *v31;
  uint64_t (*getParameterEntity)(void *, xmlChar *);
  uint64_t v33;
  xmlGenericErrorFunc v34;
  void **v35;
  xmlChar *v36;
  xmlChar *v37;
  const xmlChar *v38;
  xmlEntityPtr PredefinedEntity;
  xmlEntityPtr v40;
  xmlEntityPtr v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  uint64_t (*getEntity)(void *, xmlChar *);
  xmlEntityPtr Entity;
  xmlParserInputState instate;
  xmlEntityType etype;
  _DWORD *v52;
  int v53;
  const char *v54;
  size_t v55;
  int v56;
  xmlGenericErrorFunc v57;
  void **v58;
  xmlParserInput *v59;
  xmlParserInput *v60;
  int v61;
  const xmlChar *v62;
  xmlBuffer *v63;
  int v64;
  const xmlChar *cur;
  unsigned int v66;
  unsigned int v67;
  xmlParserInputPtr input;
  const xmlChar *v69;
  const xmlChar *v70;
  const xmlChar *content;
  int v72;
  xmlChar *v73;
  xmlChar *v74;
  int v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  const xmlChar *name;
  uint64_t v80;
  int v81;
  size_t v82;
  unsigned int v83;
  xmlChar v84;
  uint64_t v85;
  xmlChar *v86;
  int v87;
  const char *v89;
  xmlChar *v90;
  uint64_t v91;
  xmlBuffer *buf;
  int v93;
  xmlParserCtxt *v94;
  int v95;
  const xmlChar *v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int lena;
  int v101[2];

  v7 = 0;
  lena = 0;
  if (!ctxt)
    return v7;
  v8 = str;
  if (!str || len < 0)
    return v7;
  v10 = end3;
  v11 = end2;
  v12 = end;
  v14 = ctxt;
  depth = ctxt->depth;
  if (depth >= 41 && (depth > 0x400 || (ctxt->options & 0x80000) == 0))
  {
    xmlFatalErr(ctxt, 89, 0);
    return 0;
  }
  v16 = (xmlChar *)xmlMallocAtomic(0x12CuLL);
  if (!v16)
    goto LABEL_252;
  if (len)
    v17 = xmlStringCurrentChar(v14, v8, &lena);
  else
    v17 = 0;
  v18 = 0;
  if (v17 == v10 || v17 == v11 || !v17 || v17 == v12)
  {
LABEL_259:
    v7 = v16;
    goto LABEL_260;
  }
  v18 = 0;
  v96 = &v8[len];
  v97 = 300;
  v95 = what;
LABEL_17:
  if (v14->instate == XML_PARSER_EOF)
    goto LABEL_259;
  v98 = v18;
  if (v17 == 38)
  {
    if (v8[1] == 35)
    {
      if (*v8 != 38)
      {
        xmlFatalErr(v14, 8, 0);
        goto LABEL_256;
      }
      v20 = v8 + 2;
      v19 = v8[2];
      if (v19 == 59)
      {
        v24 = 0;
        v42 = 1;
      }
      else
      {
        if (v19 == 120)
        {
          v23 = v8[3];
          v22 = v8 + 3;
          v21 = v23;
          if (v23 == 59)
          {
            v24 = 0;
            v25 = 1;
            v26 = v97;
            goto LABEL_98;
          }
          v24 = 0;
          v26 = v97;
          while (1)
          {
            if ((v21 - 48) >= 0xA)
            {
              if ((v21 - 97) >= 6)
              {
                if ((v21 - 65) >= 6)
                {
                  xmlFatalErr(v14, 6, 0);
                  v25 = 0;
                  v24 = 0;
LABEL_98:
                  v31 = &v22[v25];
LABEL_99:
                  if (v24 >= 1114112)
                  {
                    v89 = "xmlParseStringCharRef: character reference out of bounds\n";
                  }
                  else
                  {
                    if (v24 <= 255)
                    {
                      if (v24 <= 31 && (v24 > 0xD || ((1 << v24) & 0x2600) == 0))
                        goto LABEL_264;
LABEL_107:
                      v18 += xmlCopyCharMultiByte(&v16[v18], v24);
LABEL_108:
                      if (v18 + 100 > v26)
                      {
                        v55 = 2 * v26 + 100;
                        if (v55 >= v26)
                          goto LABEL_110;
LABEL_252:
                        v74 = 0;
                        goto LABEL_253;
                      }
LABEL_204:
                      v7 = v16;
LABEL_205:
                      if (v31 >= v96)
                        v17 = 0;
                      else
                        v17 = xmlStringCurrentChar(v14, v31, &lena);
                      if (v17 == v10 || v17 == v11 || !v17 || (v16 = v7, v8 = v31, v17 == v12))
                      {
LABEL_260:
                        v7[v18] = 0;
                        return v7;
                      }
                      goto LABEL_17;
                    }
                    if ((v24 - 0x10000) < 0xFFFFD800 || (v24 - 57344) >> 1 < 0xFFF)
                      goto LABEL_107;
LABEL_264:
                    v89 = "xmlParseStringCharRef: invalid xmlChar value %d\n";
                  }
                  xmlFatalErrMsgInt(v14, 9, v89, v24);
                  goto LABEL_256;
                }
                v45 = -55;
              }
              else
              {
                v45 = -87;
              }
            }
            else
            {
              v45 = -48;
            }
            v46 = v21 + 16 * v24 + v45;
            if (v46 >= 1114112)
              v24 = 1114112;
            else
              v24 = v46;
            v47 = *++v22;
            v21 = v47;
            if (v47 == 59)
            {
              v25 = 1;
              goto LABEL_98;
            }
          }
        }
        v24 = 0;
        do
        {
          if ((v19 - 48) > 9)
          {
            xmlFatalErr(v14, 7, 0);
            v42 = 0;
            v24 = 0;
            goto LABEL_60;
          }
          v43 = v19 + 10 * v24 - 48;
          if (v43 >= 1114112)
            v24 = 1114112;
          else
            v24 = v43;
          v44 = *++v20;
          v19 = v44;
        }
        while (v44 != 59);
        v42 = 1;
      }
LABEL_60:
      v31 = &v20[v42];
      v26 = v97;
      goto LABEL_99;
    }
    if ((what & 1) == 0)
    {
LABEL_37:
      v26 = v97;
      if (lena == 1)
      {
        v16[v18++] = v17;
        what = v95;
      }
      else
      {
        v18 += xmlCopyCharMultiByte(&v16[v18], v17);
      }
      v31 = &v8[lena];
      goto LABEL_108;
    }
    if (*__xmlParserDebugEntities())
    {
      v34 = *__xmlGenericError();
      v35 = __xmlGenericErrorContext();
      v34(*v35, "String decoding Entity Reference: %.30s\n", (const char *)v8);
    }
    *(_QWORD *)v101 = v8;
    if (*v8 == 38)
    {
      *(_QWORD *)v101 = v8 + 1;
      v36 = xmlParseStringName(v14, (const xmlChar **)v101);
      if (v36)
      {
        v37 = v36;
        v38 = *(const xmlChar **)v101;
        if (**(_BYTE **)v101 == 59)
        {
          v31 = (const xmlChar *)(*(_QWORD *)v101 + 1);
          if ((v14->options & 0x100000) == 0)
          {
            PredefinedEntity = xmlGetPredefinedEntity(v36);
            if (PredefinedEntity)
            {
              v40 = PredefinedEntity;
              xmlFree(v37);
              xmlParserEntityCheck((int)v14);
              v41 = v40;
              v18 = v98;
LABEL_199:
              v14->nbentities += v41->checked / 2;
              content = v41->content;
              if (v41->etype == XML_INTERNAL_PREDEFINED_ENTITY)
              {
                if (content)
                {
                  v18 += xmlCopyCharMultiByte(&v16[v18], *content);
                  if (v18 + 100 <= v97)
                    goto LABEL_204;
                  v55 = 2 * v97 + 100;
                  if (v55 < v97)
                    goto LABEL_252;
LABEL_110:
                  v7 = (xmlChar *)xmlRealloc(v16, v55);
                  v97 = v55;
                  if (!v7)
                    goto LABEL_252;
                  goto LABEL_205;
                }
                xmlFatalErrMsg(v14, 1, (char)"predefined entity has no content\n");
                goto LABEL_256;
              }
              if (!content)
              {
                v99 = v11;
                v77 = xmlStrlen(v41->name);
                v78 = v18;
                name = v41->name;
                v80 = v78 + 1;
                v16[v78] = 38;
                v81 = v77;
                if (v78 + 1 + v77 + 100 <= v97)
                {
                  v7 = v16;
                }
                else
                {
                  v82 = v77 + 2 * v97 + 100;
                  if (v82 < v97)
                    goto LABEL_252;
                  v7 = (xmlChar *)xmlRealloc(v16, v82);
                  v97 = v82;
                  if (!v7)
                    goto LABEL_252;
                }
                if (v81 < 1)
                {
                  v85 = v80;
                  what = v95;
                }
                else
                {
                  v83 = v81 + 1;
                  what = v95;
                  do
                  {
                    v84 = *name++;
                    v85 = v80 + 1;
                    v7[v80] = v84;
                    --v83;
                    ++v80;
                  }
                  while (v83 > 1);
                }
                v18 = v85 + 1;
                v7[v85] = 59;
                v11 = v99;
                goto LABEL_205;
              }
              ++v14->depth;
              v72 = xmlStrlen(content);
              v73 = xmlStringLenDecodeEntities(v14, content, v72, what, 0, 0, 0);
              --v14->depth;
              if (v73)
              {
                v74 = v73;
                LOBYTE(v75) = *v73;
                if (*v73)
                {
                  v76 = 0;
                  v93 = v10;
                  do
                  {
                    v16[v98 + v76] = v75;
                    if (v98 + v76 + 101 <= v97)
                    {
                      v7 = v16;
                    }
                    else
                    {
                      if (xmlParserEntityCheck((int)v14))
                        goto LABEL_254;
                      if (2 * v97 + 100 < v97)
                        goto LABEL_253;
                      v7 = (xmlChar *)xmlRealloc(v16, 2 * v97 + 100);
                      v97 = 2 * v97 + 100;
                      v10 = v93;
                      if (!v7)
                        goto LABEL_253;
                    }
                    v75 = v74[++v76];
                    v16 = v7;
                  }
                  while (v75);
LABEL_249:
                  v18 = v98 + v76;
LABEL_251:
                  xmlFree(v74);
                  what = v95;
                  goto LABEL_205;
                }
LABEL_250:
                v7 = v16;
                goto LABEL_251;
              }
              v90 = v41->content;
LABEL_271:
              *v90 = 0;
              goto LABEL_256;
            }
          }
          ++v14->nbentities;
          v18 = v98;
          if (!v14->sax)
            goto LABEL_92;
          getEntity = (uint64_t (*)(void *, xmlChar *))v14->sax->getEntity;
          if (getEntity)
          {
            Entity = (xmlEntityPtr)getEntity(v14->userData, v37);
            if (Entity)
              goto LABEL_93;
          }
          if ((v14->options & 0x100000) != 0)
          {
            Entity = xmlGetPredefinedEntity(v37);
            if (Entity)
              goto LABEL_93;
          }
          if (v14->userData == v14)
            Entity = xmlSAX2GetEntity(v14, v37);
          else
LABEL_92:
            Entity = 0;
LABEL_93:
          instate = v14->instate;
          if (instate != XML_PARSER_EOF)
          {
            v41 = Entity;
            if (!Entity)
            {
              if (v14->standalone != 1 && (v14->hasExternalSubset || v14->hasPErefs))
                xmlErrMsgStr(v14, 27, "Entity '%s' not defined\n", v37);
              else
                xmlFatalErrMsgStr(v14, 26, "Entity '%s' not defined\n", v37);
              xmlParserEntityCheck((int)v14);
LABEL_198:
              xmlFree(v37);
              xmlParserEntityCheck((int)v14);
              if (!v41)
                goto LABEL_204;
              goto LABEL_199;
            }
            etype = Entity->etype;
            if (etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY)
            {
              v52 = v14;
              v53 = 28;
              v54 = "Entity reference to unparsed entity %s\n";
            }
            else
            {
              if (instate != XML_PARSER_ATTRIBUTE_VALUE || etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)
              {
                if (instate == XML_PARSER_ATTRIBUTE_VALUE && etype != XML_INTERNAL_PREDEFINED_ENTITY)
                {
                  v62 = Entity->content;
                  if (v62)
                  {
                    if (xmlStrchr(v62, 0x3Cu))
                    {
                      v52 = v14;
                      v53 = 38;
                      v54 = "'<' in entity '%s' is not allowed in attributes values\n";
                      goto LABEL_197;
                    }
                    etype = v41->etype;
                  }
                }
                if ((etype & 0xFFFFFFFE) != 4)
                  goto LABEL_198;
                v52 = v14;
                v53 = 30;
                v54 = "Attempt to reference the parameter entity '%s'\n";
                goto LABEL_197;
              }
              v52 = v14;
              v53 = 29;
              v54 = "Attribute references external entity '%s'\n";
            }
LABEL_197:
            xmlFatalErrMsgStr(v52, v53, v54, v37);
            goto LABEL_198;
          }
          xmlFree(v37);
LABEL_78:
          xmlParserEntityCheck((int)v14);
          v31 = v8;
          goto LABEL_204;
        }
        xmlFatalErr(v14, 23, 0);
        xmlFree(v37);
        v8 = v38;
      }
      else
      {
        xmlFatalErrMsg(v14, 68, (char)"xmlParseStringEntityRef: no name\n");
        v8 = *(const xmlChar **)v101;
      }
    }
    v18 = v98;
    goto LABEL_78;
  }
  if ((what & 2) == 0 || v17 != 37)
    goto LABEL_37;
  if (*__xmlParserDebugEntities())
  {
    v27 = *__xmlGenericError();
    v28 = __xmlGenericErrorContext();
    v27(*v28, "String decoding PE Reference: %.30s\n", (const char *)v8);
  }
  if (!v8)
  {
    v31 = 0;
    v18 = v98;
LABEL_85:
    xmlParserEntityCheck((int)v14);
    goto LABEL_204;
  }
  *(_QWORD *)v101 = v8;
  v18 = v98;
  if (*v8 != 37)
  {
    v31 = v8;
    goto LABEL_85;
  }
  *(_QWORD *)v101 = v8 + 1;
  v29 = xmlParseStringName(v14, (const xmlChar **)v101);
  if (!v29)
  {
    xmlFatalErrMsg(v14, 68, (char)"xmlParseStringPEReference: no name\n");
    v31 = *(const xmlChar **)v101;
    goto LABEL_85;
  }
  v30 = v29;
  v31 = *(const xmlChar **)v101;
  if (**(_BYTE **)v101 != 59)
  {
    xmlFatalErr(v14, 23, 0);
LABEL_84:
    xmlFree(v30);
    goto LABEL_85;
  }
  ++v14->nbentities;
  if (v14->sax && (getParameterEntity = (uint64_t (*)(void *, xmlChar *))v14->sax->getParameterEntity) != 0)
    v33 = getParameterEntity(v14->userData, v29);
  else
    v33 = 0;
  ++v31;
  if (v14->instate == XML_PARSER_EOF)
    goto LABEL_84;
  if (v33)
  {
    if ((*(_DWORD *)(v33 + 92) & 0xFFFFFFFE) != 4)
      xmlWarningMsg(v14, 27, "%%%s; is not a parameter entity\n", v30);
  }
  else
  {
    if (v14->standalone != 1 && (v14->hasExternalSubset || v14->hasPErefs))
    {
      xmlWarningMsg(v14, 27, "PEReference: %%%s; not found\n", v30);
      v14->valid = 0;
    }
    else
    {
      xmlFatalErrMsgStr(v14, 26, "PEReference: %%%s; not found\n", v30);
    }
    xmlParserEntityCheck((int)v14);
  }
  v14->hasPErefs = 1;
  xmlFree(v30);
  xmlParserEntityCheck((int)v14);
  if (!v33)
    goto LABEL_204;
  v14->nbentities += *(_DWORD *)(v33 + 132) / 2;
  if (*(_QWORD *)(v33 + 80))
    goto LABEL_239;
  if ((v14->options & 0x12) != 0 || v14->validate)
  {
    v56 = *(_DWORD *)(v33 + 92);
    if (v56 == 2 || v56 == 5)
    {
      v101[0] = 0;
      if (*__xmlParserDebugEntities())
      {
        v57 = *__xmlGenericError();
        v58 = __xmlGenericErrorContext();
        v57(*v58, "Reading %s entity content input\n", *(const char **)(v33 + 16));
        v18 = v98;
      }
      buf = xmlBufferCreate();
      if (buf)
      {
        v59 = xmlNewEntityInputStream(v14, (xmlEntityPtr)v33);
        if (v59)
        {
          v60 = v59;
          if ((xmlPushInput(v14, v59) & 0x80000000) == 0)
          {
            if (!v14->progressive && v14->input->end - v14->input->cur <= 249)
              xmlGROW((uint64_t)v14);
            v91 = v33;
            v61 = xmlCurrentChar(v14, v101);
            if (v14->input == v60)
            {
              v64 = 0;
              while (1)
              {
                cur = v60->cur;
                if (cur >= v60->end)
                  break;
                if (v61 > 255)
                {
                  if (v61 >> 11 >= 0x1B)
                  {
                    v66 = v61 - 57344;
                    if ((v61 - 57344) >> 1 >= 0xFFF)
                    {
                      v67 = v61 - 0x10000;
                      if ((v61 - 0x10000) >> 20)
                        goto LABEL_189;
                    }
                  }
                }
                else if ((v61 > 0xD || ((1 << v61) & 0x2600) == 0) && v61 <= 31)
                {
                  goto LABEL_138;
                }
                xmlBufferAdd(buf, cur, v101[0]);
                if (v64 < 101)
                {
                  ++v64;
                }
                else
                {
                  if (!v14->progressive && v14->input->end - v14->input->cur <= 249)
                    xmlGROW((uint64_t)v14);
                  if (v14->instate == XML_PARSER_EOF)
                    goto LABEL_193;
                  v64 = 0;
                }
                input = v14->input;
                v69 = input->cur;
                v70 = &v69[v101[0]];
                if (v70 <= input->end)
                {
                  if (*v69 == 10)
                  {
                    ++input->line;
                    input->col = 1;
                  }
                  else
                  {
                    ++input->col;
                  }
                  input->cur = v70;
                }
                v61 = xmlCurrentChar(v14, v101);
                if (!v61)
                {
                  if (!v14->progressive && v14->input->end - v14->input->cur <= 249)
                    xmlGROW((uint64_t)v14);
                  if (v14->instate == XML_PARSER_EOF)
                    goto LABEL_193;
                  v61 = xmlCurrentChar(v14, v101);
                  v64 = 0;
                }
                if (v14->input != v60)
                  goto LABEL_136;
              }
              xmlPopInput(v14);
            }
            else
            {
LABEL_136:
              if (v61 >= 256)
              {
                v66 = v61 - 57344;
                v67 = v61 - 0x10000;
LABEL_189:
                if (v67 >= 0x100000 && v66 >> 1 >= 0xFFF && v61 >> 11 >= 0x1B)
                {
LABEL_192:
                  xmlFatalErrMsgInt(v14, 9, "xmlLoadEntityContent: invalid char value %d\n", v61);
LABEL_193:
                  xmlBufferFree(buf);
                  v33 = v91;
                  goto LABEL_239;
                }
              }
              else if (v61 <= 31)
              {
LABEL_138:
                if (v61 > 0xD || ((1 << v61) & 0x2600) == 0)
                  goto LABEL_192;
              }
            }
            v33 = v91;
            v63 = buf;
            *(_QWORD *)(v91 + 80) = buf->content;
            buf->content = 0;
            goto LABEL_238;
          }
        }
        else
        {
          xmlFatalErr(v14, 1, (const xmlChar *)"xmlLoadEntityContent input error");
        }
        v63 = buf;
LABEL_238:
        xmlBufferFree(v63);
        goto LABEL_239;
      }
    }
    xmlFatalErr(v14, 1, (const xmlChar *)"xmlLoadEntityContent parameter error");
  }
  else
  {
    xmlWarningMsg(v14, 104, "not validating will not read content for PE entity %s\n", *(const xmlChar **)(v33 + 16));
  }
LABEL_239:
  ++v14->depth;
  v86 = xmlStringDecodeEntities(v14, *(const xmlChar **)(v33 + 80), what, 0, 0, 0);
  --v14->depth;
  if (!v86)
  {
    v90 = *(xmlChar **)(v33 + 80);
    if (!v90)
      goto LABEL_256;
    goto LABEL_271;
  }
  v74 = v86;
  LOBYTE(v87) = *v86;
  if (!*v86)
    goto LABEL_250;
  v76 = 0;
  v94 = v14;
  while (1)
  {
    v16[v98 + v76] = v87;
    if (v98 + v76 + 101 > v97)
      break;
    v7 = v16;
LABEL_248:
    v87 = v74[++v76];
    v16 = v7;
    if (!v87)
      goto LABEL_249;
  }
  if (xmlParserEntityCheck((int)v14))
    goto LABEL_254;
  if (2 * v97 + 100 < v97)
  {
    v14 = v94;
    goto LABEL_253;
  }
  v7 = (xmlChar *)xmlRealloc(v16, 2 * v97 + 100);
  v97 = 2 * v97 + 100;
  v14 = v94;
  if (v7)
    goto LABEL_248;
LABEL_253:
  htmlErrMemory(v14, 0);
LABEL_254:
  if (v74)
    xmlFree(v74);
LABEL_256:
  if (v16)
    xmlFree(v16);
  return 0;
}

uint64_t xmlParserEntityCheck(uint64_t result, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  const xmlChar *v8;
  uint64_t v9;
  int v10;
  xmlChar *v11;
  xmlChar *v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  _QWORD *v23;

  if (result)
  {
    v4 = result;
    if ((*(_BYTE *)(result + 566) & 8) == 0)
    {
      if (*(_DWORD *)(result + 604) == 89)
        return 1;
      if (a3)
      {
        if (*(_DWORD *)(a3 + 92) != 6)
        {
          v8 = *(const xmlChar **)(a3 + 80);
          if (v8)
          {
            if (!*(_DWORD *)(a3 + 132) && *(_DWORD *)(result + 136) != 89)
            {
              v9 = *(_QWORD *)(result + 696);
              *(_DWORD *)(a3 + 132) = 1;
              ++*(_DWORD *)(result + 392);
              v10 = xmlStrlen(v8);
              v11 = xmlStringLenDecodeEntities((xmlParserCtxtPtr)v4, v8, v10, 1, 0, 0, 0);
              v12 = v11;
              --*(_DWORD *)(v4 + 392);
              if (!v11 || *(_DWORD *)(v4 + 136) == 89)
                **(_BYTE **)(a3 + 80) = 0;
              v13 = *(_QWORD *)(v4 + 696) - v9;
              if ((unint64_t)(v13 + 1) < 0x3FFFFFFF)
                v14 = v13 + 1;
              else
                v14 = 0x3FFFFFFF;
              *(_DWORD *)(a3 + 132) = 2 * v14;
              if (v11)
              {
                if (xmlStrchr(v11, 0x3Cu))
                  *(_DWORD *)(a3 + 132) |= 1u;
                xmlFree(v12);
              }
            }
          }
        }
      }
      if (*(_DWORD *)(v4 + 272) == 3)
      {
        v15 = *(_QWORD *)(v4 + 696);
        if (v15 >= 0x2711 && (v15 & 0x3FF) == 0)
        {
          v16 = *(unsigned int *)(v4 + 64);
          if ((int)v16 < 1)
            goto LABEL_26;
          v17 = 0;
          v18 = *(_QWORD **)(v4 + 72);
          do
          {
            v19 = (_QWORD *)*v18++;
            v17 = v19[8] + v17 + v19[4] - v19[3];
            --v16;
          }
          while (v16);
          if (v15 > 10 * v17)
          {
LABEL_26:
            xmlFatalErr((_DWORD *)v4, 89, 0);
            *(_DWORD *)(v4 + 272) = -1;
            return 1;
          }
        }
      }
      if (a4)
      {
        if (a4 >= 0x989680)
        {
          v20 = *(_QWORD **)(v4 + 56);
          if (v20)
            v20 = (_QWORD *)(v20[8] + v20[4] - v20[3]);
          if (10 * ((uint64_t)v20 + *(_QWORD *)(v4 + 704)) <= a4)
            goto LABEL_48;
        }
      }
      else if (a2)
      {
        if (a2 >= 0x3E8)
        {
          v21 = *(_QWORD **)(v4 + 56);
          if (v21)
            v21 = (_QWORD *)(v21[8] + v21[4] - v21[3]);
          v22 = 10 * ((_QWORD)v21 + *(_QWORD *)(v4 + 704));
          if (v22 <= a2 || 3 * *(_QWORD *)(v4 + 696) >= v22)
            goto LABEL_48;
        }
      }
      else if (a3)
      {
        v23 = *(_QWORD **)(v4 + 56);
        if (v23)
          v23 = (_QWORD *)(v23[8] + v23[4] - v23[3]);
        if (3 * ((uint64_t)(*(_DWORD *)(a3 + 132) + (*(int *)(a3 + 132) < 0)) >> 1) >= (unint64_t)(10 * ((_QWORD)v23 + *(_QWORD *)(v4 + 704))))
          goto LABEL_48;
      }
      else if ((*(_DWORD *)(v4 + 604) & 0xFFFFFFFE) == 0x1A && *(_QWORD *)(v4 + 696) >= 0x2711uLL)
      {
LABEL_48:
        xmlFatalErr((_DWORD *)v4, 89, 0);
        return 1;
      }
    }
    return 0;
  }
  return result;
}

_DWORD *xmlFatalErrMsg(_DWORD *result, int a2, char a3)
{
  _DWORD *v3;

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 3, 0, 0, 0, 0, 0, 0, 0, "%s", a3);
  v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, 0, 0, 0, 0, 0, "%s", a3);
    v3[6] = 0;
    if (!v3[112])
      v3[83] = 1;
  }
  return result;
}

xmlChar *__cdecl xmlStringDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int what, xmlChar end, xmlChar end2, xmlChar end3)
{
  int v12;

  if (!ctxt || !str)
    return 0;
  v12 = xmlStrlen(str);
  return xmlStringLenDecodeEntities(ctxt, str, v12, what, end, end2, end3);
}

_DWORD *xmlWarningMsg(_DWORD *result, int a2, const char *a3, const xmlChar *a4)
{
  uint64_t v5;
  uint64_t v6;
  void (__cdecl *v7)(void *, xmlErrorPtr);
  void (*v8)(void *, const char *, ...);

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 1, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
  v5 = (uint64_t)result;
  if (!result[83] || result[68] != -1)
  {
    v6 = *(_QWORD *)result;
    if (*(_QWORD *)result)
    {
      if (*(_DWORD *)(v6 + 216) == -554844497)
        v7 = *(void (__cdecl **)(void *, xmlErrorPtr))(v6 + 248);
      else
        v7 = 0;
      v8 = *(void (**)(void *, const char *, ...))(v6 + 168);
    }
    else
    {
      v7 = 0;
      v8 = 0;
    }
    return __xmlRaiseError(v7, v8, *(void **)(v5 + 8), (_QWORD *)v5, 0, 1u, a2, 1, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
  }
  return result;
}

xmlChar *__cdecl xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix)
{
  int v5;
  uint64_t v8;
  unsigned int v9;
  xmlChar *v10;
  const xmlChar *v11;
  int v12;
  int v13;
  xmlChar *v14;
  uint64_t v15;
  xmlChar *v16;
  int v17;
  signed int v18;
  signed int v19;
  const xmlChar *v20;
  int v21;
  unsigned __int8 *v22;
  unint64_t v23;
  BOOL v24;
  int v25;
  xmlChar *v26;
  xmlChar *v27;
  unsigned int v28;
  int v29;
  xmlParserCtxtPtr v30;
  int len;
  _OWORD __src[7];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!prefix)
    return 0;
  *prefix = 0;
  if (!name)
    return 0;
  v5 = *name;
  if (v5 == 58)
    return xmlStrdup(name);
  v8 = 0;
  memset(__src, 0, 105);
  if (v5)
  {
    while (v5 != 58)
    {
      if (v8 == 100)
      {
        v9 = 100;
        goto LABEL_13;
      }
      *((_BYTE *)__src + v8) = v5;
      v5 = name[++v8];
      if (!v5)
        break;
    }
  }
  if (v8 <= 0x63)
  {
    v10 = 0;
    v11 = &name[v8 + 1];
    v12 = 100;
    v13 = v8;
  }
  else
  {
    v9 = v8;
LABEL_13:
    v14 = (xmlChar *)xmlMallocAtomic(2 * v9);
    v10 = v14;
    if (!v14)
      goto LABEL_71;
    v30 = ctxt;
    memcpy(v14, __src, v9);
    v15 = 0;
    v12 = 2 * v9;
    while ((_BYTE)v5 && v5 != 58)
    {
      if ((int)(v9 + v15 + 10) > v12)
      {
        v12 *= 2;
        v16 = (xmlChar *)xmlRealloc(v10, v12);
        if (!v16)
        {
          xmlFree(v10);
          htmlErrMemory(v30, 0);
          return 0;
        }
        v10 = v16;
      }
      v10[v9 + v15] = v5;
      v5 = name[++v15 + v8];
    }
    v13 = v9 + v15;
    v10[v9 + v15] = 0;
    v11 = &name[v8 + 1 + v15];
    ctxt = v30;
  }
  if (v5 == 58 && !*v11)
  {
    if (v10)
      xmlFree(v10);
    *prefix = 0;
    return xmlStrdup(name);
  }
  if (v10)
    v12 = 100;
  else
    v10 = xmlStrndup((const xmlChar *)__src, v13);
  if (v5 == 58)
  {
    LOBYTE(v17) = *v11;
    *prefix = v10;
    if (!(_BYTE)v17)
    {
      v20 = (const xmlChar *)&byte_1B0865C1A;
      v21 = 0;
      return xmlStrndup(v20, v21);
    }
    if (((v17 & 0xDF) - 65) < 0x1Au || v17 == 58 || v17 == 95)
      goto LABEL_51;
    len = 0;
    v18 = xmlStringCurrentChar(ctxt, v11, &len);
    v19 = v18;
    if (v18 > 255)
    {
      if (xmlCharInRange(v18, &xmlIsBaseCharGroup)
        || (v19 - 12330) > 0xFFFFFFF6
        || v19 == 12295
        || (v19 - 40870) > 0xFFFFAE59)
      {
        goto LABEL_51;
      }
    }
    else if ((v18 - 192) < 0x17
           || (v18 & 0xFFFFFFDF) - 65 < 0x1A
           || v18 == 95
           || v18 > 247
           || (v18 - 216) < 0x1F)
    {
      goto LABEL_51;
    }
    xmlFatalErrMsgStr(ctxt, 202, "Name %s is not XML Namespace compliant\n", name);
LABEL_51:
    v22 = (unsigned __int8 *)(v11 + 1);
    if (v12 < 1)
    {
      LODWORD(v23) = 0;
    }
    else
    {
      v23 = 0;
      do
      {
        *((_BYTE *)__src + v23) = v17;
        v17 = v22[v23++];
        if (v17)
          v24 = v23 >= v12;
        else
          v24 = 1;
      }
      while (!v24);
      if (v23 < v12)
      {
        v20 = (const xmlChar *)__src;
        v21 = v23;
        return xmlStrndup(v20, v21);
      }
      v22 += v23;
    }
    v25 = 2 * v23;
    v26 = (xmlChar *)xmlMallocAtomic((2 * v23));
    v10 = v26;
    if (v26)
    {
      v23 = v23;
      memcpy(v26, __src, v23);
      if ((_BYTE)v17)
      {
        while (1)
        {
          if ((int)v23 + 10 > v25)
          {
            v25 *= 2;
            v27 = (xmlChar *)xmlRealloc(v10, v25);
            if (!v27)
            {
              htmlErrMemory(ctxt, 0);
              xmlFree(v10);
              return 0;
            }
            v10 = v27;
          }
          v28 = v23 + 1;
          v10[v23] = v17;
          v29 = *v22++;
          LOBYTE(v17) = v29;
          ++v23;
          if (!v29)
          {
            v23 = v28;
            break;
          }
        }
      }
      v10[v23] = 0;
      return v10;
    }
LABEL_71:
    htmlErrMemory(ctxt, 0);
  }
  return v10;
}

_DWORD *xmlFatalErrMsgStr(_DWORD *result, int a2, const char *a3, const xmlChar *a4)
{
  _DWORD *v4;

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 3, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
  v4 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
    v4[6] = 0;
    if (!v4[112])
      v4[83] = 1;
  }
  return result;
}

xmlChar *__cdecl xmlParseNmtoken(xmlParserCtxtPtr ctxt)
{
  int v2;
  signed int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  xmlParserInputPtr input;
  const xmlChar *cur;
  const xmlChar *v10;
  int v11;
  xmlChar *v12;
  xmlChar *v13;
  int v14;
  xmlChar *v15;
  xmlParserInputPtr v16;
  const xmlChar *v17;
  const xmlChar *v18;
  int len;
  _OWORD __src[7];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  memset(__src, 0, 105);
  if ((ctxt->options & 0x80000) != 0)
    v2 = 10000000;
  else
    v2 = 50000;
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  if (ctxt->instate == XML_PARSER_EOF)
    return 0;
  len = 0;
  v3 = xmlCurrentChar(ctxt, &len);
  v4 = 0;
  v5 = 0;
  do
  {
    xmlIsNameChar((uint64_t)ctxt, v3);
    if (!v6)
    {
      if (!v4)
        return 0;
      return xmlStrndup((const xmlChar *)__src, v4);
    }
    if (v5 >= 101)
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
        xmlGROW((uint64_t)ctxt);
      v5 = 0;
    }
    else
    {
      ++v5;
    }
    if (len == 1)
    {
      *((_BYTE *)__src + v4++) = v3;
      v7 = 1;
    }
    else
    {
      v4 += xmlCopyCharMultiByte((xmlChar *)__src + v4, v3);
      v7 = len;
    }
    input = ctxt->input;
    cur = input->cur;
    v10 = &cur[v7];
    if (v10 <= input->end)
    {
      if (*cur == 10)
      {
        ++input->line;
        input->col = 1;
      }
      else
      {
        ++input->col;
      }
      input->cur = v10;
    }
    v3 = xmlCurrentChar(ctxt, &len);
    if (!v3)
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
        xmlGROW((uint64_t)ctxt);
      if (ctxt->instate == XML_PARSER_EOF)
        return 0;
      v3 = xmlCurrentChar(ctxt, &len);
      v5 = 0;
    }
  }
  while (v4 < 100);
  v11 = 2 * v4;
  v12 = (xmlChar *)xmlMallocAtomic((2 * v4));
  v13 = v12;
  if (!v12)
  {
    htmlErrMemory(ctxt, 0);
    return v13;
  }
  memcpy(v12, __src, v4);
  while (1)
  {
    xmlIsNameChar((uint64_t)ctxt, v3);
    if (!v14)
    {
      v13[v4] = 0;
      return v13;
    }
    if (v5 < 101)
    {
      ++v5;
    }
    else
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
        xmlGROW((uint64_t)ctxt);
      if (ctxt->instate == XML_PARSER_EOF)
        goto LABEL_59;
      v5 = 0;
    }
    if (v4 + 10 <= v11)
      goto LABEL_44;
    v11 *= 2;
    v15 = (xmlChar *)xmlRealloc(v13, v11);
    if (!v15)
      break;
    v13 = v15;
LABEL_44:
    if (len == 1)
      v13[v4++] = v3;
    else
      v4 += xmlCopyCharMultiByte(&v13[v4], v3);
    v16 = ctxt->input;
    v17 = v16->cur;
    v18 = &v17[len];
    if (v18 <= v16->end)
    {
      if (*v17 == 10)
      {
        ++v16->line;
        v16->col = 1;
      }
      else
      {
        ++v16->col;
      }
      v16->cur = v18;
    }
    v3 = xmlCurrentChar(ctxt, &len);
    if (v4 > v2)
    {
      xmlFatalErr(ctxt, 110, (const xmlChar *)"NmToken");
      goto LABEL_59;
    }
  }
  htmlErrMemory(ctxt, 0);
LABEL_59:
  xmlFree(v13);
  return 0;
}

__n128 xmlIsNameChar(uint64_t a1, signed int val)
{
  __n128 result;
  int32x4_t v4;

  if ((*(_BYTE *)(a1 + 566) & 2) != 0)
  {
    if (val > 255)
    {
      if (xmlCharInRange(val, &xmlIsBaseCharGroup)
        || (val - 12321) < 9
        || val == 12295
        || (val - 19968) < 0x51A6
        || xmlCharInRange(val, &xmlIsDigitGroup))
      {
        return result;
      }
    }
    else if ((val - 192) < 0x17
           || (val & 0xFFFFFFDF) - 65 < 0x1A
           || (val - 48) < 0xA
           || val > 247
           || (val - 216) < 0x1F)
    {
      return result;
    }
    if (((val - 45) > 0x32 || ((1 << (val - 45)) & 0x4000000002003) == 0)
      && val >= 256
      && !xmlCharInRange(val, &xmlIsCombiningGroup))
    {
      xmlCharInRange(val, &xmlIsExtenderGroup);
    }
  }
  else if ((val > 0x3E || ((1 << val) & 0x4000800100000000) == 0)
         && (val - 48) >= 0xB
         && (val & 0xFFFFFFDF) - 65 >= 0x1A
         && ((val - 45) > 0x32 || ((1 << (val - 45)) & 0x4000000000003) == 0)
         && val != 183)
  {
    v4 = vdupq_n_s32(val);
    result.n128_u8[0] = vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B08622F0, (uint32x4_t)vaddq_s32(v4, (int32x4_t)xmmword_1B08622D0)), (int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B0862300, (uint32x4_t)vaddq_s32(v4, (int32x4_t)xmmword_1B08622E0)))));
  }
  return result;
}

xmlChar *__cdecl xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig)
{
  int v4;
  int v5;
  void *v6;
  void *v7;
  xmlParserInputPtr input;
  int v9;
  int v10;
  int v11;
  void *v12;
  xmlParserInputPtr v13;
  const xmlChar *end;
  const xmlChar *cur;
  const xmlChar *v16;
  xmlChar *v17;
  const xmlChar *i;
  int v19;
  xmlChar *v20;
  const xmlChar *v22;
  int len;

  len = 0;
  if ((ctxt->options & 0x80000) != 0)
    v4 = 1000000000;
  else
    v4 = 10000000;
  v22 = 0;
  v5 = *ctxt->input->cur;
  if (v5 != 34 && v5 != 39)
  {
    xmlFatalErr(ctxt, 36, 0);
    return 0;
  }
  v6 = xmlMallocAtomic(0x64uLL);
  if (!v6)
  {
    htmlErrMemory(ctxt, 0);
    return 0;
  }
  v7 = v6;
  ctxt->instate = XML_PARSER_ENTITY_VALUE;
  input = ctxt->input;
  if (!ctxt->progressive && input->end - input->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    if (ctxt->instate == XML_PARSER_EOF)
      goto LABEL_62;
  }
  xmlNextChar(ctxt);
  v9 = xmlCurrentChar(ctxt, &len);
  v10 = 0;
  v11 = 100;
  while (1)
  {
    if (v9 > 255)
    {
      if ((v9 - 0x10000) >= 0x100000
        && v9 >> 11 >= 0x1B
        && (v9 - 57344) >> 1 > 0xFFE)
      {
        goto LABEL_47;
      }
    }
    else if (v9 <= 31 && (v9 > 0xD || ((1 << v9) & 0x2600) == 0))
    {
      goto LABEL_47;
    }
    if (v9 == v5 && ctxt->input == input)
      break;
    if (ctxt->instate == XML_PARSER_EOF)
      goto LABEL_47;
    if (v10 + 5 >= v11)
    {
      v11 *= 2;
      v12 = xmlRealloc(v7, v11);
      if (!v12)
      {
        htmlErrMemory(ctxt, 0);
        goto LABEL_65;
      }
      v7 = v12;
    }
    if (len == 1)
      *((_BYTE *)v7 + v10++) = v9;
    else
      v10 += xmlCopyCharMultiByte((xmlChar *)v7 + v10, v9);
    v13 = ctxt->input;
    cur = v13->cur;
    end = v13->end;
    v16 = &cur[len];
    if (v16 <= end)
    {
      if (*cur == 10)
      {
        ++v13->line;
        v13->col = 1;
      }
      else
      {
        ++v13->col;
      }
      v13->cur = v16;
      cur = v16;
    }
    if (!ctxt->progressive && end - cur <= 249)
      xmlGROW((uint64_t)ctxt);
    v9 = xmlCurrentChar(ctxt, &len);
    if (!v9)
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
        xmlGROW((uint64_t)ctxt);
      v9 = xmlCurrentChar(ctxt, &len);
    }
    if (v10 > v4)
    {
      xmlFatalErrMsg(ctxt, 37, (char)"entity value too long\n");
LABEL_65:
      v17 = 0;
      goto LABEL_66;
    }
  }
  v9 = v5;
LABEL_47:
  *((_BYTE *)v7 + v10) = 0;
  if (ctxt->instate == XML_PARSER_EOF)
  {
LABEL_62:
    v17 = 0;
    goto LABEL_66;
  }
  if (v9 != v5)
  {
    xmlFatalErr(ctxt, 37, 0);
    goto LABEL_62;
  }
  xmlNextChar(ctxt);
  for (i = (const xmlChar *)v7; ; ++i)
  {
    v22 = i;
    v19 = *i;
    if (v19 != 37)
      break;
LABEL_55:
    v22 = i + 1;
    v20 = xmlParseStringName(ctxt, &v22);
    if (!v20 || (xmlFree(v20), i = v22, *v22 != 59))
    {
      xmlFatalErrMsgInt(ctxt, 87, "EntityValue: '%c' forbidden except for entities references\n", v19);
      goto LABEL_65;
    }
    if (v19 == 37 && ctxt->inSubset == 1 && ctxt->inputNr == 1)
    {
      xmlFatalErr(ctxt, 88, 0);
      goto LABEL_65;
    }
LABEL_60:
    ;
  }
  if (v19 == 38)
  {
    if (i[1] == 35)
      goto LABEL_60;
    goto LABEL_55;
  }
  if (*i)
    goto LABEL_60;
  ++ctxt->depth;
  v17 = xmlStringDecodeEntities(ctxt, (const xmlChar *)v7, 2, 0, 0, 0);
  --ctxt->depth;
  if (orig)
  {
    *orig = (xmlChar *)v7;
    return v17;
  }
LABEL_66:
  xmlFree(v7);
  return v17;
}

xmlChar *xmlParseStringName(xmlParserCtxt *a1, const xmlChar **a2)
{
  const xmlChar *v4;
  int v5;
  signed int v6;
  int v7;
  uint64_t v8;
  int v9;
  const xmlChar *v10;
  signed int v11;
  int v12;
  int v13;
  int v14;
  _BYTE *v15;
  _BYTE *v16;
  int v17;
  _BYTE *v18;
  int len;
  xmlChar out[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[25];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v25 = 0u;
  memset(v26, 0, sizeof(v26));
  v23 = 0u;
  v24 = 0u;
  *(_OWORD *)out = 0u;
  v22 = 0u;
  v4 = *a2;
  len = 0;
  if ((a1->options & 0x80000) != 0)
    v5 = 10000000;
  else
    v5 = 50000;
  v6 = xmlStringCurrentChar(a1, v4, &len);
  xmlIsNameStartChar((uint64_t)a1, v6);
  if (!v7)
    return 0;
  if (len == 1)
  {
    out[0] = v6;
    v8 = 1;
    v9 = 1;
  }
  else
  {
    v9 = xmlCopyCharMultiByte(out, v6);
    v8 = len;
  }
  v10 = &v4[v8];
  v11 = xmlStringCurrentChar(a1, v10, &len);
  do
  {
    xmlIsNameChar((uint64_t)a1, v11);
    if (!v12)
    {
      if (v9 > v5)
      {
        xmlFatalErr(a1, 110, (const xmlChar *)"NCName");
        return 0;
      }
      *a2 = v10;
      return xmlStrndup(out, v9);
    }
    v13 = len;
    if (len == 1)
    {
      out[v9++] = v11;
    }
    else
    {
      v9 += xmlCopyCharMultiByte(&out[v9], v11);
      v13 = len;
    }
    v10 += v13;
    v11 = xmlStringCurrentChar(a1, v10, &len);
  }
  while (v9 < 100);
  v14 = 2 * v9;
  v15 = xmlMallocAtomic((2 * v9));
  v16 = v15;
  if (!v15)
  {
    htmlErrMemory(a1, 0);
    return v16;
  }
  memcpy(v15, out, v9);
  while (1)
  {
    xmlIsNameChar((uint64_t)a1, v11);
    if (!v17)
    {
      v16[v9] = 0;
      *a2 = v10;
      return v16;
    }
    if (v9 + 10 <= v14)
      goto LABEL_20;
    v14 *= 2;
    v18 = xmlRealloc(v16, v14);
    if (!v18)
      break;
    v16 = v18;
LABEL_20:
    if (len == 1)
      v16[v9++] = v11;
    else
      v9 += xmlCopyCharMultiByte(&v16[v9], v11);
    v10 += len;
    v11 = xmlStringCurrentChar(a1, v10, &len);
    if (v9 > v5)
    {
      xmlFatalErr(a1, 110, (const xmlChar *)"NCName");
      goto LABEL_31;
    }
  }
  htmlErrMemory(a1, 0);
LABEL_31:
  xmlFree(v16);
  return 0;
}

xmlChar *__cdecl xmlParseAttValue(xmlParserCtxtPtr ctxt)
{
  if (ctxt && ctxt->input)
    return xmlParseAttValueInternal((uint64_t)ctxt, 0, 0, 0);
  else
    return 0;
}

xmlChar *__cdecl xmlParseSystemLiteral(xmlParserCtxtPtr ctxt)
{
  int v2;
  xmlParserInputState instate;
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v6;
  xmlChar *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  BOOL v14;
  xmlChar *v15;
  xmlParserInputPtr v16;
  const xmlChar *v17;
  xmlParserInputPtr v18;
  const xmlChar *v19;
  const xmlChar *v20;
  int v21;
  xmlParserInputPtr v22;
  const xmlChar *v23;
  xmlParserInputState v25;
  int len;

  if ((ctxt->options & 0x80000) != 0)
    v2 = 10000000;
  else
    v2 = 50000;
  instate = ctxt->instate;
  if (!ctxt->progressive)
  {
    input = ctxt->input;
    cur = input->cur;
    if (cur - input->base >= 501 && input->end - cur <= 499)
      xmlSHRINK((uint64_t)ctxt);
  }
  len = 0;
  v6 = *ctxt->input->cur;
  if (v6 != 34 && v6 != 39)
  {
    xmlFatalErr(ctxt, 43, 0);
    return 0;
  }
  xmlNextChar(ctxt);
  v7 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (!v7)
  {
    htmlErrMemory(ctxt, 0);
    return v7;
  }
  v25 = instate;
  ctxt->instate = XML_PARSER_SYSTEM_LITERAL;
  v8 = xmlCurrentChar(ctxt, &len);
  v9 = 0;
  v10 = 0;
  v11 = 100;
  while (1)
  {
    if (v8 > 255)
    {
      v14 = v8 >> 11 < 0x1B
         || (v8 - 57344) >> 1 < 0xFFF
         || (v8 - 0x10000) < 0x100000;
      if (v8 != v6 && v14)
        goto LABEL_29;
      v7[v9] = 0;
      ctxt->instate = v25;
      if (v14)
        goto LABEL_64;
LABEL_70:
      xmlFatalErr(ctxt, 44, 0);
      return v7;
    }
    if (v8 <= 31 && (v8 > 0xD || ((1 << v8) & 0x2600) == 0))
    {
      v7[v9] = 0;
      ctxt->instate = v25;
      goto LABEL_70;
    }
    if (v8 == v6)
    {
      v7[v9] = 0;
      ctxt->instate = v25;
LABEL_64:
      xmlNextChar(ctxt);
      return v7;
    }
LABEL_29:
    if (v9 + 5 >= v11)
    {
      v11 *= 2;
      v15 = (xmlChar *)xmlRealloc(v7, v11);
      if (!v15)
      {
        xmlFree(v7);
        htmlErrMemory(ctxt, 0);
        goto LABEL_66;
      }
      v7 = v15;
    }
    if (v10 < 50)
    {
      ++v10;
      goto LABEL_42;
    }
    if (!ctxt->progressive)
    {
      v16 = ctxt->input;
      v17 = v16->cur;
      if (v17 - v16->base < 501 || v16->end - v17 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249)
          xmlGROW((uint64_t)ctxt);
      }
    }
    if (ctxt->instate == XML_PARSER_EOF)
      break;
    v10 = 0;
LABEL_42:
    if (len == 1)
      v7[v9++] = v8;
    else
      v9 += xmlCopyCharMultiByte(&v7[v9], v8);
    v18 = ctxt->input;
    v19 = v18->cur;
    v20 = &v19[len];
    if (v20 <= v18->end)
    {
      if (*v19 == 10)
      {
        ++v18->line;
        v21 = 1;
      }
      else
      {
        v21 = v18->col + 1;
      }
      v18->col = v21;
      v18->cur = v20;
    }
    v8 = xmlCurrentChar(ctxt, &len);
    if (!v8)
    {
      if (!ctxt->progressive)
      {
        if (ctxt->input->end - ctxt->input->cur > 249 || (xmlGROW((uint64_t)ctxt), !ctxt->progressive))
        {
          v22 = ctxt->input;
          v23 = v22->cur;
          if (v23 - v22->base >= 501 && v22->end - v23 <= 499)
            xmlSHRINK((uint64_t)ctxt);
        }
      }
      v8 = xmlCurrentChar(ctxt, &len);
    }
    if (v9 > v2)
    {
      xmlFatalErr(ctxt, 110, (const xmlChar *)"SystemLiteral");
      xmlFree(v7);
LABEL_66:
      v7 = 0;
      ctxt->instate = v25;
      return v7;
    }
  }
  xmlFree(v7);
  return 0;
}

xmlChar *__cdecl xmlParsePubidLiteral(xmlParserCtxtPtr ctxt)
{
  int options;
  xmlParserInputState instate;
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v6;
  void *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  void *v14;
  xmlParserInputPtr v15;
  const xmlChar *v16;
  xmlParserInputPtr v17;
  const xmlChar *v18;
  const xmlChar *v19;
  xmlParserInputState v21;

  options = ctxt->options;
  instate = ctxt->instate;
  if (!ctxt->progressive)
  {
    input = ctxt->input;
    cur = input->cur;
    if (cur - input->base >= 501 && input->end - cur <= 499)
      xmlSHRINK((uint64_t)ctxt);
  }
  v6 = *ctxt->input->cur;
  if (v6 == 34 || v6 == 39)
  {
    xmlNextChar(ctxt);
    v7 = xmlMallocAtomic(0x64uLL);
    if (v7)
    {
      v21 = instate;
      v8 = 0;
      v9 = 0;
      ctxt->instate = XML_PARSER_PUBLIC_LITERAL;
      v10 = *ctxt->input->cur;
      if ((options & 0x80000) != 0)
        v11 = 10000001;
      else
        v11 = 50001;
      v12 = 100;
      while (v6 != v10 && xmlIsPubidChar_tab[v10])
      {
        v13 = v8 + 1;
        if (v8 + 1 >= v12)
        {
          v12 *= 2;
          v14 = xmlRealloc(v7, v12);
          if (!v14)
          {
            htmlErrMemory(ctxt, 0);
            goto LABEL_42;
          }
          v7 = v14;
        }
        *((_BYTE *)v7 + v8) = v10;
        if (v9 < 50)
        {
          ++v9;
        }
        else
        {
          if (!ctxt->progressive)
          {
            v15 = ctxt->input;
            v16 = v15->cur;
            if (v16 - v15->base < 501 || v15->end - v16 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
            {
              if (ctxt->input->end - ctxt->input->cur <= 249)
                xmlGROW((uint64_t)ctxt);
            }
          }
          if (ctxt->instate == XML_PARSER_EOF)
            goto LABEL_42;
          v9 = 0;
        }
        xmlNextChar(ctxt);
        v17 = ctxt->input;
        v18 = v17->cur;
        v10 = *v18;
        if (!*v18)
        {
          if (!ctxt->progressive)
          {
            if (v17->end - v18 > 249 || (xmlGROW((uint64_t)ctxt), v17 = ctxt->input, !ctxt->progressive))
            {
              v19 = v17->cur;
              if (v19 - v17->base >= 501 && v17->end - v19 <= 499)
              {
                xmlSHRINK((uint64_t)ctxt);
                v17 = ctxt->input;
              }
            }
          }
          v10 = *v17->cur;
        }
        ++v8;
        if (v11 == v13)
        {
          xmlFatalErr(ctxt, 110, (const xmlChar *)"Public ID");
LABEL_42:
          xmlFree(v7);
          return 0;
        }
      }
      *((_BYTE *)v7 + v8) = 0;
      if (v6 == v10)
        xmlNextChar(ctxt);
      else
        xmlFatalErr(ctxt, 44, 0);
      ctxt->instate = v21;
    }
    else
    {
      htmlErrMemory(ctxt, 0);
    }
  }
  else
  {
    xmlFatalErr(ctxt, 43, 0);
    return 0;
  }
  return (xmlChar *)v7;
}

xmlChar *__cdecl xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  xmlParserInputPtr v8;
  const xmlChar *v9;
  int v10;
  xmlChar *v11;
  const char *v12;
  xmlChar *v13;
  int v14;
  int v16;

  if (!ctxt->progressive)
  {
    input = ctxt->input;
    cur = input->cur;
    if (cur - input->base >= 501 && input->end - cur <= 499)
      xmlSHRINK((uint64_t)ctxt);
  }
  *publicID = 0;
  v8 = ctxt->input;
  v9 = v8->cur;
  v10 = *v9;
  if (v10 == 80)
  {
    if (v9[1] != 85 || v9[2] != 66 || v9[3] != 76 || v9[4] != 73 || v9[5] != 67)
      return 0;
    v8->cur = v9 + 6;
    v8->col += 6;
    if (!v9[6])
      xmlParserInputGrow(v8, 250);
    if (!xmlSkipBlankChars(ctxt))
      xmlFatalErrMsg(ctxt, 65, (char)"Space required after 'PUBLIC'\n");
    v13 = xmlParsePubidLiteral(ctxt);
    *publicID = v13;
    if (!v13)
      xmlFatalErr(ctxt, 71, 0);
    v14 = xmlSkipBlankChars(ctxt);
    if (strict)
    {
      if (v14)
        goto LABEL_31;
      v12 = "Space required after the Public Identifier\n";
      goto LABEL_30;
    }
    if (!v14)
      return 0;
    v16 = *ctxt->input->cur;
    if (v16 != 39 && v16 != 34)
      return 0;
  }
  else
  {
    v11 = 0;
    if (v10 != 83)
      return v11;
    if (v9[1] != 89 || v9[2] != 83 || v9[3] != 84 || v9[4] != 69 || v9[5] != 77)
      return 0;
    v8->cur = v9 + 6;
    v8->col += 6;
    if (!v9[6])
      xmlParserInputGrow(v8, 250);
    if (!xmlSkipBlankChars(ctxt))
    {
      v12 = "Space required after 'SYSTEM'\n";
LABEL_30:
      xmlFatalErrMsg(ctxt, 65, (char)v12);
    }
  }
LABEL_31:
  v11 = xmlParseSystemLiteral(ctxt);
  if (!v11)
  {
    xmlFatalErr(ctxt, 70, 0);
    return 0;
  }
  return v11;
}

void xmlParseCommentComplex(uint64_t a1, _BYTE *a2, unint64_t a3, size_t a4)
{
  _BYTE *v6;
  unint64_t v8;
  int v9;
  _BYTE *v10;
  int v11;
  int v12;
  uint64_t v13;
  _BYTE *v14;
  _BYTE *v15;
  int v16;
  int v17;
  _DWORD *v18;
  int v19;
  uint64_t v20;
  _BYTE *v21;
  _BYTE *v22;
  int v23;
  int v24;
  unint64_t v25;
  _BYTE *v26;
  int v27;
  int v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  _BYTE *v33;
  int v34;
  int v35;
  _QWORD *v36;
  uint64_t v37;
  const char *v38;
  _DWORD *v39;
  const xmlChar *v40;
  void (*v41)(_QWORD, _BYTE *);
  int v42;
  int len[2];

  v6 = a2;
  if ((*(_BYTE *)(a1 + 566) & 8) != 0)
    v8 = 1000000000;
  else
    v8 = 10000000;
  v9 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 100);
  if (!a2)
  {
    a4 = 100;
    v10 = xmlMallocAtomic(0x64uLL);
    if (!v10)
    {
      htmlErrMemory((_DWORD *)a1, 0);
      return;
    }
    v6 = v10;
    a3 = 0;
  }
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  *(_QWORD *)len = 0;
  v42 = 0;
  v11 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len[1]);
  if (!v11)
    goto LABEL_89;
  v12 = v11;
  if (v11 > 255)
  {
    if ((v11 - 0x10000) >= 0x100000
      && v11 >> 11 >= 0x1B
      && (v11 - 57344) >> 1 >= 0xFFF)
    {
LABEL_34:
      v18 = (_DWORD *)a1;
      v19 = v12;
LABEL_35:
      xmlFatalErrMsgInt(v18, 9, "xmlParseComment: invalid xmlChar value %d\n", v19);
      goto LABEL_92;
    }
  }
  else if (v11 <= 31 && (v11 > 0xD || ((1 << v11) & 0x2600) == 0))
  {
    goto LABEL_34;
  }
  v13 = *(_QWORD *)(a1 + 56);
  v14 = *(_BYTE **)(v13 + 32);
  v15 = &v14[len[1]];
  if ((unint64_t)v15 <= *(_QWORD *)(v13 + 40))
  {
    if (*v14 == 10)
    {
      ++*(_DWORD *)(v13 + 52);
      *(_DWORD *)(v13 + 56) = 1;
    }
    else
    {
      ++*(_DWORD *)(v13 + 56);
    }
    *(_QWORD *)(v13 + 32) = v15;
  }
  v16 = xmlCurrentChar((xmlParserCtxtPtr)a1, len);
  if (!v16)
    goto LABEL_89;
  v17 = v16;
  if (v16 > 255)
  {
    if ((v16 - 0x10000) >= 0x100000
      && v16 >> 11 >= 0x1B
      && (v16 - 57344) >> 1 >= 0xFFF)
    {
      goto LABEL_34;
    }
  }
  else if (v16 <= 31 && (v16 > 0xD || ((1 << v16) & 0x2600) == 0))
  {
    goto LABEL_34;
  }
  v20 = *(_QWORD *)(a1 + 56);
  v21 = *(_BYTE **)(v20 + 32);
  v22 = &v21[len[0]];
  if ((unint64_t)v22 <= *(_QWORD *)(v20 + 40))
  {
    if (*v21 == 10)
    {
      ++*(_DWORD *)(v20 + 52);
      *(_DWORD *)(v20 + 56) = 1;
    }
    else
    {
      ++*(_DWORD *)(v20 + 56);
    }
    *(_QWORD *)(v20 + 32) = v22;
  }
  v23 = xmlCurrentChar((xmlParserCtxtPtr)a1, &v42);
  if (!v23)
  {
LABEL_89:
    v38 = "Comment not terminated\n";
LABEL_90:
    v39 = (_DWORD *)a1;
    v40 = 0;
    goto LABEL_91;
  }
  v24 = v23;
  v25 = 0;
  while (1)
  {
    if (v24 > 255)
    {
      if ((v24 - 0x10000) >= 0x100000
        && v24 >> 11 >= 0x1B
        && (v24 - 57344) >> 1 >= 0xFFF)
      {
        v6[a3] = 0;
LABEL_93:
        v18 = (_DWORD *)a1;
        v19 = v24;
        goto LABEL_35;
      }
      goto LABEL_55;
    }
    if (v24 <= 31)
      break;
    if (v12 == 45 && v17 == 45 && v24 == 62)
    {
      v6[a3] = 0;
      if (v9 != *(_DWORD *)(*(_QWORD *)(a1 + 56) + 100))
        xmlFatalErrMsg((_DWORD *)a1, 90, (char)"Comment doesn't start and stop in the same entity\n");
      xmlNextChar((xmlParserCtxtPtr)a1);
      if (*(_QWORD *)a1)
      {
        v41 = *(void (**)(_QWORD, _BYTE *))(*(_QWORD *)a1 + 160);
        if (v41)
        {
          if (!*(_DWORD *)(a1 + 332))
            v41(*(_QWORD *)(a1 + 8), v6);
        }
      }
      goto LABEL_92;
    }
LABEL_55:
    if (v12 == 45 && v17 == 45)
      xmlFatalErr((_DWORD *)a1, 80, 0);
    if (a3 + 5 >= a4)
    {
      a4 *= 2;
      v26 = xmlRealloc(v6, a4);
      if (!v26)
      {
        xmlFree(v6);
        htmlErrMemory((_DWORD *)a1, 0);
        return;
      }
      v6 = v26;
    }
    if (len[1] == 1)
      v6[a3++] = v12;
    else
      a3 += xmlCopyCharMultiByte(&v6[a3], v12);
    v28 = v42;
    v27 = len[0];
    len[0] = v42;
    len[1] = v27;
    if (v25 < 0x32)
    {
      ++v25;
    }
    else
    {
      if (!*(_DWORD *)(a1 + 452))
      {
        v29 = *(_QWORD **)(a1 + 56);
        v30 = v29[4];
        if (v30 - v29[3] < 501 || v29[5] - v30 > 499 || (xmlSHRINK(a1), !*(_DWORD *)(a1 + 452)))
        {
          if ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
            xmlGROW(a1);
        }
      }
      if (*(_DWORD *)(a1 + 272) == -1)
        goto LABEL_92;
      v25 = 0;
      v28 = v42;
    }
    v31 = *(_QWORD *)(a1 + 56);
    v32 = *(_BYTE **)(v31 + 32);
    v33 = &v32[v28];
    if ((unint64_t)v33 <= *(_QWORD *)(v31 + 40))
    {
      if (*v32 == 10)
      {
        ++*(_DWORD *)(v31 + 52);
        v34 = 1;
      }
      else
      {
        v34 = *(_DWORD *)(v31 + 56) + 1;
      }
      *(_DWORD *)(v31 + 56) = v34;
      *(_QWORD *)(v31 + 32) = v33;
    }
    v35 = xmlCurrentChar((xmlParserCtxtPtr)a1, &v42);
    if (!v35)
    {
      if (!*(_DWORD *)(a1 + 452))
      {
        v36 = *(_QWORD **)(a1 + 56);
        v37 = v36[4];
        if (v37 - v36[3] < 501 || v36[5] - v37 > 499 || (xmlSHRINK(a1), !*(_DWORD *)(a1 + 452)))
        {
          if ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
            xmlGROW(a1);
        }
      }
      v35 = xmlCurrentChar((xmlParserCtxtPtr)a1, &v42);
    }
    v12 = v17;
    v17 = v24;
    v24 = v35;
    if (a3 > v8)
    {
      v38 = "Comment too big found";
      goto LABEL_90;
    }
  }
  if (v24 <= 0xD && ((1 << v24) & 0x2600) != 0)
    goto LABEL_55;
  v6[a3] = 0;
  if (v24)
    goto LABEL_93;
  v38 = "Comment not terminated \n<!--%.50s\n";
  v39 = (_DWORD *)a1;
  v40 = v6;
LABEL_91:
  xmlFatalErrMsgStr(v39, 45, v38, v40);
LABEL_92:
  xmlFree(v6);
}

const xmlChar *__cdecl xmlParsePITarget(xmlParserCtxtPtr ctxt)
{
  const xmlChar *v2;
  const xmlChar *v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;

  v2 = xmlParseName(ctxt);
  v3 = v2;
  if (v2)
  {
    v4 = *v2;
    if ((v4 | 0x20) == 0x78 && (v5 = v2[1], (v5 | 0x20) == 0x6D) && (v6 = v2[2], (v6 | 0x20) == 0x6C))
    {
      if (v4 == 120 && v5 == 109 && v6 == 108)
      {
        if (!v2[3])
        {
          xmlFatalErrMsg(ctxt, 64, (char)"XML declaration allowed only at the start of the document\n");
          return v3;
        }
      }
      else if (!v2[3])
      {
        xmlFatalErr(ctxt, 64, 0);
        return v3;
      }
      v7 = 0;
      while (!xmlStrEqual(v3, (const xmlChar *)xmlW3CPIs[v7]))
      {
        if (++v7 == 2)
        {
          xmlWarningMsg(ctxt, 64, "xmlParsePITarget: invalid name prefix 'xml'\n", 0);
          goto LABEL_15;
        }
      }
    }
    else
    {
LABEL_15:
      if (xmlStrchr(v3, 0x3Au))
        xmlNsErr(ctxt, 205, "colons are forbidden from PI names '%s'\n", v3, 0, 0);
    }
  }
  return v3;
}

_DWORD *xmlNsErr(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5, xmlChar *a6)
{
  _DWORD *v6;

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 3u, a2, 2, 0, 0, a4, a5, a6, 0, 0, a3, (char)a4);
  v6 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    result = __xmlRaiseError(0, 0, 0, result, 0, 3u, a2, 2, 0, 0, a4, a5, a6, 0, 0, a3, (char)a4);
    v6[140] = 0;
  }
  return result;
}

void xmlParsePI(xmlParserCtxtPtr ctxt)
{
  unint64_t v2;
  xmlParserInputPtr input;
  const xmlChar *cur;
  int id;
  xmlParserInputState instate;
  xmlParserInputPtr v7;
  const xmlChar *v8;
  const xmlChar *v9;
  const xmlChar *v10;
  xmlParserInputPtr v11;
  const xmlChar *v12;
  processingInstructionSAXFunc v13;
  _BYTE *v14;
  _BYTE *v15;
  int v16;
  unint64_t v17;
  int v18;
  size_t v19;
  _BYTE *v20;
  xmlParserInputPtr v21;
  const xmlChar *v22;
  xmlParserInputPtr v23;
  const xmlChar *v24;
  const xmlChar *v25;
  xmlParserInputPtr v26;
  const xmlChar *v27;
  xmlParserInputPtr v28;
  const xmlChar *v29;
  processingInstructionSAXFunc processingInstruction;
  int v31;
  xmlParserInputState v32;
  int len;

  if ((ctxt->options & 0x80000) != 0)
    v2 = 1000000000;
  else
    v2 = 10000000;
  len = 0;
  input = ctxt->input;
  cur = input->cur;
  if (*cur == 60 && cur[1] == 63)
  {
    id = input->id;
    instate = ctxt->instate;
    ctxt->instate = XML_PARSER_PI;
    input->cur = cur + 2;
    input->col += 2;
    if (!cur[2])
      xmlParserInputGrow(input, 250);
    if (!ctxt->progressive)
    {
      v7 = ctxt->input;
      v8 = v7->cur;
      if (v8 - v7->base >= 501 && v7->end - v8 <= 499)
        xmlSHRINK((uint64_t)ctxt);
    }
    v9 = xmlParsePITarget(ctxt);
    if (v9)
    {
      v10 = v9;
      v11 = ctxt->input;
      v12 = v11->cur;
      if (*v12 != 63 || v12[1] != 62)
      {
        v14 = xmlMallocAtomic(0x64uLL);
        if (v14)
        {
          v15 = v14;
          v31 = id;
          v32 = instate;
          if (!xmlSkipBlankChars(ctxt))
            xmlFatalErrMsgStr(ctxt, 65, "ParsePI: PI %s space expected\n", v10);
          v16 = xmlCurrentChar(ctxt, &len);
          v17 = 0;
          v18 = 0;
          v19 = 100;
          while (1)
          {
            if (v16 > 255)
            {
              if ((v16 - 0x10000) >= 0x100000
                && v16 >> 11 >= 0x1B
                && (v16 - 57344) >> 1 >= 0xFFF)
              {
LABEL_74:
                v15[v17] = 0;
                xmlFatalErrMsgStr(ctxt, 47, "ParsePI: PI %s never end ...\n", v10);
                instate = v32;
LABEL_75:
                xmlFree(v15);
                goto LABEL_70;
              }
            }
            else if (v16 <= 31)
            {
              if (v16 > 0xD || ((1 << v16) & 0x2600) == 0)
                goto LABEL_74;
            }
            else if (v16 == 63 && *((_BYTE *)ctxt->input->cur + 1) == 62)
            {
              v15[v17] = 0;
              v28 = ctxt->input;
              if (v31 != v28->id)
              {
                xmlFatalErrMsg(ctxt, 90, (char)"PI declaration doesn't start and stop in the same entity\n");
                v28 = ctxt->input;
              }
              v29 = v28->cur;
              v28->cur = v29 + 2;
              v28->col += 2;
              instate = v32;
              if (!v29[2])
                xmlParserInputGrow(v28, 250);
              if (v32 <= XML_PARSER_MISC
                && xmlStrEqual(v10, (const xmlChar *)"oasis-xml-catalog")
                && (xmlCatalogGetDefaults() & 0xFFFFFFFE) == 2)
              {
                xmlParseCatalogPI((uint64_t)ctxt, v15);
              }
              if (ctxt->sax)
              {
                if (!ctxt->disableSAX)
                {
                  processingInstruction = ctxt->sax->processingInstruction;
                  if (processingInstruction)
                    ((void (*)(void *, const xmlChar *, _BYTE *))processingInstruction)(ctxt->userData, v10, v15);
                }
              }
              goto LABEL_75;
            }
            if (v17 + 5 >= v19)
            {
              v19 *= 2;
              v20 = xmlRealloc(v15, v19);
              if (!v20)
              {
                htmlErrMemory(ctxt, 0);
                goto LABEL_77;
              }
              v15 = v20;
            }
            if (v18 < 50)
            {
              ++v18;
            }
            else
            {
              if (!ctxt->progressive)
              {
                v21 = ctxt->input;
                v22 = v21->cur;
                if (v22 - v21->base < 501 || v21->end - v22 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
                {
                  if (ctxt->input->end - ctxt->input->cur <= 249)
                    xmlGROW((uint64_t)ctxt);
                }
              }
              if (ctxt->instate == XML_PARSER_EOF)
              {
                xmlFree(v15);
                return;
              }
              v18 = 0;
            }
            if (len == 1)
              v15[v17++] = v16;
            else
              v17 += xmlCopyCharMultiByte(&v15[v17], v16);
            v23 = ctxt->input;
            v24 = v23->cur;
            v25 = &v24[len];
            if (v25 <= v23->end)
            {
              if (*v24 == 10)
              {
                ++v23->line;
                v23->col = 1;
              }
              else
              {
                ++v23->col;
              }
              v23->cur = v25;
            }
            v16 = xmlCurrentChar(ctxt, &len);
            if (!v16)
            {
              if (!ctxt->progressive)
              {
                v26 = ctxt->input;
                v27 = v26->cur;
                if (v27 - v26->base < 501 || v26->end - v27 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
                {
                  if (ctxt->input->end - ctxt->input->cur <= 249)
                    xmlGROW((uint64_t)ctxt);
                }
              }
              v16 = xmlCurrentChar(ctxt, &len);
            }
            if (v17 > v2)
            {
              xmlFatalErrMsgStr(ctxt, 47, "PI %s too big found", v10);
LABEL_77:
              xmlFree(v15);
              ctxt->instate = v32;
              return;
            }
          }
        }
        htmlErrMemory(ctxt, 0);
LABEL_73:
        ctxt->instate = instate;
        return;
      }
      if (id != v11->id)
      {
        xmlFatalErrMsg(ctxt, 90, (char)"PI declaration doesn't start and stop in the same entity\n");
        v11 = ctxt->input;
        v12 = v11->cur;
      }
      v11->cur = v12 + 2;
      v11->col += 2;
      if (!v12[2])
        xmlParserInputGrow(v11, 250);
      if (ctxt->sax && !ctxt->disableSAX)
      {
        v13 = ctxt->sax->processingInstruction;
        if (v13)
          ((void (*)(void *, const xmlChar *, _QWORD))v13)(ctxt->userData, v10, 0);
      }
    }
    else
    {
      xmlFatalErr(ctxt, 46, 0);
    }
LABEL_70:
    if (ctxt->instate == XML_PARSER_EOF)
      return;
    goto LABEL_73;
  }
}

void xmlParseCatalogPI(uint64_t a1, xmlChar *str1)
{
  const xmlChar *i;
  unsigned int v5;
  BOOL v6;
  uint64_t v7;
  const xmlChar *j;
  uint64_t v10;
  unsigned int v11;
  int v12;
  const xmlChar *v13;
  int v14;
  int v15;
  BOOL v16;
  xmlChar *v17;
  xmlChar *v18;
  uint64_t k;
  unsigned int v20;

  for (i = str1; ; ++i)
  {
    v5 = *i;
    v6 = v5 > 0x20;
    v7 = (1 << v5) & 0x100002600;
    if (v6 || v7 == 0)
      break;
  }
  if (xmlStrncmp(i, (const xmlChar *)"catalog", 7))
  {
LABEL_8:
    xmlWarningMsg((_DWORD *)a1, 93, "Catalog PI syntax error: %s\n", str1);
  }
  else
  {
    for (j = i + 9; ; ++j)
    {
      v10 = *(j - 2);
      if (v10 > 0x3D)
        break;
      if (((1 << v10) & 0x100002600) == 0)
      {
        if (v10 != 61)
          return;
        while (1)
        {
          v11 = *(j - 1);
          if (v11 > 0x27)
            goto LABEL_8;
          if (((1 << v11) & 0x100002600) == 0)
          {
            if (((1 << v11) & 0x8400000000) == 0)
              goto LABEL_8;
            v12 = -1;
            v13 = j;
            do
            {
              v15 = *v13++;
              v14 = v15;
              ++v12;
              if (v15)
                v16 = v14 == v11;
              else
                v16 = 1;
            }
            while (!v16);
            if (!v14)
              goto LABEL_8;
            v17 = xmlStrndup(j, v12);
            v18 = v17;
            for (k = 0; ; ++k)
            {
              v20 = v13[k];
              if (v20 > 0x20)
                break;
              if (((1 << v20) & 0x100002600) == 0)
              {
                if (!v13[k])
                {
                  if (!v17)
                    return;
                  *(_QWORD *)(a1 + 440) = xmlCatalogAddLocal(*(void **)(a1 + 440), v17);
                  goto LABEL_33;
                }
                break;
              }
            }
            xmlWarningMsg((_DWORD *)a1, 93, "Catalog PI syntax error: %s\n", str1);
            if (!v18)
              return;
LABEL_33:
            xmlFree(v18);
            return;
          }
          ++j;
        }
      }
    }
  }
}

void xmlParseNotationDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  int id;
  xmlParserInputPtr v5;
  const xmlChar *v6;
  const xmlChar *v7;
  const xmlChar *v8;
  xmlChar *v9;
  xmlParserInputPtr v10;
  notationDeclSAXFunc notationDecl;
  const char *v12;
  xmlChar *publicID;

  input = ctxt->input;
  cur = input->cur;
  if (*cur != 60
    || cur[1] != 33
    || cur[2] != 78
    || cur[3] != 79
    || cur[4] != 84
    || cur[5] != 65
    || cur[6] != 84
    || cur[7] != 73
    || cur[8] != 79
    || cur[9] != 78)
  {
    return;
  }
  id = input->id;
  input->cur = cur + 10;
  input->col += 10;
  if (!cur[10])
    xmlParserInputGrow(input, 250);
  if (!ctxt->progressive)
  {
    v5 = ctxt->input;
    v6 = v5->cur;
    if (v6 - v5->base >= 501 && v5->end - v6 <= 499)
      xmlSHRINK((uint64_t)ctxt);
  }
  if (!xmlSkipBlankChars(ctxt))
  {
    v12 = "Space required after '<!NOTATION'\n";
LABEL_32:
    xmlFatalErrMsg(ctxt, 65, (char)v12);
    return;
  }
  v7 = xmlParseName(ctxt);
  if (!v7)
  {
    xmlFatalErr(ctxt, 48, 0);
    return;
  }
  v8 = v7;
  if (xmlStrchr(v7, 0x3Au))
    xmlNsErr(ctxt, 205, "colons are forbidden from notation names '%s'\n", v8, 0, 0);
  if (!xmlSkipBlankChars(ctxt))
  {
    v12 = "Space required after the NOTATION name'\n";
    goto LABEL_32;
  }
  publicID = 0;
  v9 = xmlParseExternalID(ctxt, &publicID, 0);
  xmlSkipBlankChars(ctxt);
  v10 = ctxt->input;
  if (*v10->cur == 62)
  {
    if (id != v10->id)
      xmlFatalErrMsg(ctxt, 90, (char)"Notation declaration doesn't start and stop in the same entity\n");
    xmlNextChar(ctxt);
    if (ctxt->sax)
    {
      if (!ctxt->disableSAX)
      {
        notationDecl = ctxt->sax->notationDecl;
        if (notationDecl)
          ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))notationDecl)(ctxt->userData, v8, publicID, v9);
      }
    }
  }
  else
  {
    xmlFatalErr(ctxt, 49, 0);
  }
  if (v9)
    xmlFree(v9);
  if (publicID)
    xmlFree(publicID);
}

void xmlParseEntityDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  int id;
  xmlParserInputPtr v5;
  const xmlChar *v6;
  int v7;
  const xmlChar *v8;
  const xmlChar *v9;
  int v10;
  xmlURI *v11;
  entityDeclSAXFunc entityDecl;
  entityDeclSAXFunc v13;
  xmlDocPtr v14;
  xmlDocPtr v15;
  xmlChar *v16;
  xmlChar *v17;
  xmlChar *v18;
  xmlChar *v19;
  xmlURIPtr v20;
  xmlURIPtr v21;
  xmlURI *v22;
  xmlParserInputPtr v23;
  const xmlChar *v24;
  const xmlChar *v25;
  unparsedEntityDeclSAXFunc unparsedEntityDecl;
  entityDeclSAXFunc v27;
  xmlDocPtr myDoc;
  xmlDocPtr v29;
  xmlParserInputPtr v30;
  _xmlSAXHandler *sax;
  uint64_t (*getParameterEntity)(void *, const xmlChar *);
  xmlEntityPtr Entity;
  uint64_t (*getEntity)(void *, const xmlChar *);
  entityDeclSAXFunc v35;
  xmlChar *v36;
  xmlChar *publicID;

  v36 = 0;
  publicID = 0;
  input = ctxt->input;
  cur = input->cur;
  if (*cur != 60
    || cur[1] != 33
    || cur[2] != 69
    || cur[3] != 78
    || cur[4] != 84
    || cur[5] != 73
    || cur[6] != 84
    || cur[7] != 89)
  {
    return;
  }
  id = input->id;
  input->cur = cur + 8;
  input->col += 8;
  if (!cur[8])
    xmlParserInputGrow(input, 250);
  if (!ctxt->progressive)
  {
    v5 = ctxt->input;
    v6 = v5->cur;
    if (v6 - v5->base >= 501 && v5->end - v6 <= 499)
      xmlSHRINK((uint64_t)ctxt);
  }
  if (!xmlSkipBlankChars(ctxt))
    xmlFatalErrMsg(ctxt, 65, (char)"Space required after '<!ENTITY'\n");
  v7 = *ctxt->input->cur;
  if (v7 == 37)
  {
    xmlNextChar(ctxt);
    if (!xmlSkipBlankChars(ctxt))
      xmlFatalErrMsg(ctxt, 65, (char)"Space required after '%%'\n");
  }
  v8 = xmlParseName(ctxt);
  if (!v8)
  {
    xmlFatalErrMsg(ctxt, 68, (char)"xmlParseEntityDecl: no name\n");
    return;
  }
  v9 = v8;
  if (xmlStrchr(v8, 0x3Au))
    xmlNsErr(ctxt, 205, "colons are forbidden from entities names '%s'\n", v9, 0, 0);
  if (!xmlSkipBlankChars(ctxt))
    xmlFatalErrMsg(ctxt, 65, (char)"Space required after the entity name\n");
  ctxt->instate = XML_PARSER_ENTITY_DECL;
  v10 = *ctxt->input->cur;
  if (v7 == 37)
  {
    if (v10 == 39 || v10 == 34)
    {
      v11 = (xmlURI *)xmlParseEntityValue(ctxt, &v36);
      if (v11)
      {
        if (ctxt->sax)
        {
          if (!ctxt->disableSAX)
          {
            entityDecl = ctxt->sax->entityDecl;
            if (entityDecl)
              ((void (*)(void *, const xmlChar *, uint64_t, _QWORD, _QWORD, xmlURI *))entityDecl)(ctxt->userData, v9, 4, 0, 0, v11);
          }
        }
      }
      goto LABEL_48;
    }
    v18 = xmlParseExternalID(ctxt, &publicID, 1);
    v16 = publicID;
    if (!((unint64_t)v18 | (unint64_t)publicID))
    {
      xmlFatalErr(ctxt, 84, 0);
      v16 = 0;
      v11 = 0;
      goto LABEL_49;
    }
    v17 = v18;
    if (v18)
    {
      v20 = xmlParseURI((const char *)v18);
      v11 = v20;
      if (!v20)
      {
        xmlErrMsgStr(ctxt, 91, "Invalid URI: %s\n", v17);
        goto LABEL_97;
      }
      if (v20->fragment)
      {
        xmlFatalErr(ctxt, 92, 0);
      }
      else if (ctxt->sax)
      {
        if (!ctxt->disableSAX)
        {
          v35 = ctxt->sax->entityDecl;
          if (v35)
            ((void (*)(void *, const xmlChar *, uint64_t, xmlChar *, xmlChar *, _QWORD))v35)(ctxt->userData, v9, 5, v16, v17, 0);
        }
      }
      xmlFreeURI(v11);
    }
LABEL_96:
    v11 = 0;
    goto LABEL_97;
  }
  if (v10 != 39 && v10 != 34)
  {
    v19 = xmlParseExternalID(ctxt, &publicID, 1);
    v17 = v19;
    v16 = publicID;
    if ((unint64_t)v19 | (unint64_t)publicID)
    {
      if (v19)
      {
        v21 = xmlParseURI((const char *)v19);
        if (v21)
        {
          v22 = v21;
          if (v21->fragment)
            xmlFatalErr(ctxt, 92, 0);
          xmlFreeURI(v22);
        }
        else
        {
          xmlErrMsgStr(ctxt, 91, "Invalid URI: %s\n", v17);
        }
      }
    }
    else
    {
      xmlFatalErr(ctxt, 84, 0);
    }
    if (*ctxt->input->cur != 62 && !xmlSkipBlankChars(ctxt))
      xmlFatalErrMsg(ctxt, 65, (char)"Space required before 'NDATA'\n");
    v23 = ctxt->input;
    v24 = v23->cur;
    if (*v24 == 78 && v24[1] == 68 && v24[2] == 65 && v24[3] == 84 && v24[4] == 65)
    {
      v23->cur = v24 + 5;
      v23->col += 5;
      if (!v24[5])
        xmlParserInputGrow(v23, 250);
      if (!xmlSkipBlankChars(ctxt))
        xmlFatalErrMsg(ctxt, 65, (char)"Space required after 'NDATA'\n");
      v25 = xmlParseName(ctxt);
      if (ctxt->sax)
      {
        if (!ctxt->disableSAX)
        {
          unparsedEntityDecl = ctxt->sax->unparsedEntityDecl;
          if (unparsedEntityDecl)
            ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *, const xmlChar *))unparsedEntityDecl)(ctxt->userData, v9, v16, v17, v25);
        }
      }
      goto LABEL_96;
    }
    if (ctxt->sax)
    {
      if (!ctxt->disableSAX)
      {
        v27 = ctxt->sax->entityDecl;
        if (v27)
          ((void (*)(void *, const xmlChar *, uint64_t, xmlChar *, xmlChar *, _QWORD))v27)(ctxt->userData, v9, 2, v16, v17, 0);
      }
    }
    if (!ctxt->replaceEntities)
      goto LABEL_96;
    myDoc = ctxt->myDoc;
    if (!myDoc)
      goto LABEL_91;
    if (!xmlStrEqual(myDoc->version, (const xmlChar *)"SAX compatibility mode document"))
      goto LABEL_96;
    v29 = ctxt->myDoc;
    if (!v29)
    {
LABEL_91:
      v29 = xmlNewDoc((const xmlChar *)"SAX compatibility mode document");
      ctxt->myDoc = v29;
      if (!v29)
      {
        htmlErrMemory(ctxt, (const xmlChar *)"New Doc failed");
        return;
      }
      v29->properties = 64;
    }
    if (!v29->intSubset)
      ctxt->myDoc->intSubset = xmlNewDtd(v29, (const xmlChar *)"fake", 0, 0);
    xmlSAX2EntityDecl(ctxt, v9, 2, v16, v17, 0);
    goto LABEL_96;
  }
  v11 = (xmlURI *)xmlParseEntityValue(ctxt, &v36);
  if (ctxt->sax)
  {
    if (!ctxt->disableSAX)
    {
      v13 = ctxt->sax->entityDecl;
      if (v13)
        ((void (*)(void *, const xmlChar *, uint64_t, _QWORD, _QWORD, xmlURI *))v13)(ctxt->userData, v9, 1, 0, 0, v11);
    }
  }
  v14 = ctxt->myDoc;
  if (!v14)
    goto LABEL_43;
  if (xmlStrEqual(v14->version, (const xmlChar *)"SAX compatibility mode document"))
  {
    v15 = ctxt->myDoc;
    if (v15)
    {
LABEL_45:
      if (!v15->intSubset)
        ctxt->myDoc->intSubset = xmlNewDtd(v15, (const xmlChar *)"fake", 0, 0);
      xmlSAX2EntityDecl(ctxt, v9, 1, 0, 0, (xmlChar *)v11);
      goto LABEL_48;
    }
LABEL_43:
    v15 = xmlNewDoc((const xmlChar *)"SAX compatibility mode document");
    ctxt->myDoc = v15;
    if (!v15)
    {
      htmlErrMemory(ctxt, (const xmlChar *)"New Doc failed");
      return;
    }
    v15->properties = 64;
    goto LABEL_45;
  }
LABEL_48:
  v16 = 0;
LABEL_49:
  v17 = 0;
LABEL_97:
  if (ctxt->instate == XML_PARSER_EOF)
    goto LABEL_116;
  xmlSkipBlankChars(ctxt);
  v30 = ctxt->input;
  if (*v30->cur == 62)
  {
    if (id != v30->id)
      xmlFatalErrMsg(ctxt, 90, (char)"Entity declaration doesn't start and stop in the same entity\n");
    xmlNextChar(ctxt);
  }
  else
  {
    xmlFatalErrMsgStr(ctxt, 37, "xmlParseEntityDecl: entity %s not terminated\n", v9);
    xmlHaltParser(ctxt);
  }
  if (!v36)
    goto LABEL_116;
  sax = ctxt->sax;
  if (v7 == 37)
  {
    if (!sax)
      goto LABEL_116;
    getParameterEntity = (uint64_t (*)(void *, const xmlChar *))sax->getParameterEntity;
    if (!getParameterEntity)
      goto LABEL_116;
    Entity = (xmlEntityPtr)getParameterEntity(ctxt->userData, v9);
    goto LABEL_113;
  }
  if (sax)
  {
    getEntity = (uint64_t (*)(void *, const xmlChar *))sax->getEntity;
    if (getEntity)
    {
      Entity = (xmlEntityPtr)getEntity(ctxt->userData, v9);
      if (Entity)
      {
LABEL_114:
        if (!Entity->orig)
        {
          Entity->orig = v36;
          v36 = 0;
        }
        goto LABEL_116;
      }
    }
  }
  if (ctxt->userData == ctxt)
  {
    Entity = xmlSAX2GetEntity(ctxt, v9);
LABEL_113:
    if (Entity)
      goto LABEL_114;
  }
LABEL_116:
  if (v11)
    xmlFree(v11);
  if (v17)
    xmlFree(v17);
  if (v16)
    xmlFree(v16);
  if (v36)
    xmlFree(v36);
}

_DWORD *xmlErrMsgStr(_DWORD *result, int a2, const char *a3, const xmlChar *a4)
{
  if (!result)
    return __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 2, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    return __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 2, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
  }
  return result;
}

int xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v6;
  int v7;
  xmlChar *v8;

  *value = 0;
  input = ctxt->input;
  cur = input->cur;
  if (*cur != 35)
  {
    v7 = 1;
    goto LABEL_36;
  }
  v6 = cur[1];
  if (v6 == 70)
  {
    if (cur[2] == 73 && cur[3] == 88 && cur[4] == 69 && cur[5] == 68)
    {
      input->cur = cur + 6;
      input->col += 6;
      if (!cur[6])
        xmlParserInputGrow(input, 250);
      if (!xmlSkipBlankChars(ctxt))
        xmlFatalErrMsg(ctxt, 65, (char)"Space required after '#FIXED'\n");
      v7 = 4;
LABEL_35:
      if (!ctxt->input)
      {
        ctxt->instate = XML_PARSER_DTD;
        goto LABEL_39;
      }
LABEL_36:
      v8 = xmlParseAttValueInternal((uint64_t)ctxt, 0, 0, 0);
      ctxt->instate = XML_PARSER_DTD;
      if (v8)
      {
        *value = v8;
        return v7;
      }
LABEL_39:
      xmlFatalErrMsg(ctxt, ctxt->errNo, (char)"Attribute default value declaration error\n");
      return v7;
    }
    goto LABEL_34;
  }
  if (v6 != 73)
  {
    if (v6 == 82
      && cur[2] == 69
      && cur[3] == 81
      && cur[4] == 85
      && cur[5] == 73
      && cur[6] == 82
      && cur[7] == 69
      && cur[8] == 68)
    {
      input->cur = cur + 9;
      input->col += 9;
      if (!cur[9])
        xmlParserInputGrow(input, 250);
      return 2;
    }
    goto LABEL_34;
  }
  if (cur[2] != 77 || cur[3] != 80 || cur[4] != 76 || cur[5] != 73 || cur[6] != 69 || cur[7] != 68)
  {
LABEL_34:
    v7 = 1;
    goto LABEL_35;
  }
  input->cur = cur + 8;
  input->col += 8;
  if (!cur[8])
    xmlParserInputGrow(input, 250);
  return 3;
}

xmlEnumerationPtr xmlParseNotationType(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  xmlEnumeration *v4;
  _QWORD *p_next;
  const xmlChar *v6;
  xmlChar *v7;
  xmlEnumeration *v8;
  xmlEnumerationPtr Enumeration;
  int v10;

  input = ctxt->input;
  cur = input->cur;
  if (*cur == 40)
  {
    if (!ctxt->progressive && cur - input->base >= 501 && input->end - cur <= 499)
      xmlSHRINK((uint64_t)ctxt);
    v4 = 0;
    p_next = 0;
    do
    {
      xmlNextChar(ctxt);
      xmlSkipBlankChars(ctxt);
      v6 = xmlParseName(ctxt);
      if (!v6)
      {
        xmlFatalErrMsg(ctxt, 68, (char)"Name expected in NOTATION declaration\n");
        goto LABEL_24;
      }
      v7 = (xmlChar *)v6;
      v8 = v4;
      if (v4)
      {
        while (!xmlStrEqual(v7, v8->name))
        {
          v8 = v8->next;
          if (!v8)
            goto LABEL_11;
        }
        xmlValidityError(ctxt, 541, "standalone: attribute notation value token %s duplicated\n", v7, 0);
        if (!xmlDictOwns(ctxt->dict, v7))
          xmlFree(v7);
      }
      else
      {
LABEL_11:
        Enumeration = xmlCreateEnumeration(v7);
        if (!Enumeration)
          goto LABEL_24;
        if (p_next)
          *p_next = Enumeration;
        else
          v4 = Enumeration;
        p_next = &Enumeration->next;
      }
      xmlSkipBlankChars(ctxt);
      v10 = *ctxt->input->cur;
    }
    while (v10 == 124);
    if (v10 == 41)
    {
      xmlNextChar(ctxt);
      return v4;
    }
    xmlFatalErr(ctxt, 49, 0);
LABEL_24:
    xmlFreeEnumeration(v4);
  }
  else
  {
    xmlFatalErr(ctxt, 48, 0);
  }
  return 0;
}

_DWORD *xmlValidityError(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  uint64_t v5;
  uint64_t v6;
  void (__cdecl *v7)(void *, xmlErrorPtr);

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 4u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
  v5 = (uint64_t)result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    v6 = *(_QWORD *)result;
    if (*(_QWORD *)result && *(_DWORD *)(v6 + 216) == -554844497)
      v7 = *(void (__cdecl **)(void *, xmlErrorPtr))(v6 + 248);
    else
      v7 = 0;
    result = __xmlRaiseError(v7, *(void (**)(void *, const char *, ...))(v5 + 168), *(void **)(v5 + 160), (_QWORD *)v5, 0, 4u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
    *(_DWORD *)(v5 + 152) = 0;
  }
  return result;
}

xmlEnumerationPtr xmlParseEnumerationType(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  xmlEnumeration *v4;
  _QWORD *p_next;
  xmlChar *v6;
  xmlChar *v7;
  xmlEnumeration *v8;
  xmlEnumerationPtr Enumeration;
  int v10;
  xmlParserCtxtPtr v11;
  int v12;

  input = ctxt->input;
  cur = input->cur;
  if (*cur == 40)
  {
    if (!ctxt->progressive && cur - input->base >= 501 && input->end - cur <= 499)
      xmlSHRINK((uint64_t)ctxt);
    v4 = 0;
    p_next = 0;
    while (1)
    {
      xmlNextChar(ctxt);
      xmlSkipBlankChars(ctxt);
      v6 = xmlParseNmtoken(ctxt);
      if (!v6)
        break;
      v7 = v6;
      v8 = v4;
      if (v4)
      {
        while (!xmlStrEqual(v7, v8->name))
        {
          v8 = v8->next;
          if (!v8)
            goto LABEL_11;
        }
        xmlValidityError(ctxt, 541, "standalone: attribute enumeration value token %s duplicated\n", v7, 0);
        if (!xmlDictOwns(ctxt->dict, v7))
          xmlFree(v7);
      }
      else
      {
LABEL_11:
        Enumeration = xmlCreateEnumeration(v7);
        if (!xmlDictOwns(ctxt->dict, v7))
          xmlFree(v7);
        if (!Enumeration)
        {
          xmlFreeEnumeration(v4);
          return 0;
        }
        if (p_next)
          *p_next = Enumeration;
        else
          v4 = Enumeration;
        p_next = &Enumeration->next;
      }
      xmlSkipBlankChars(ctxt);
      v10 = *ctxt->input->cur;
      if (v10 != 124)
      {
        v11 = ctxt;
        if (v10 == 41)
        {
          xmlNextChar(ctxt);
          return v4;
        }
        v12 = 51;
        goto LABEL_27;
      }
    }
    v11 = ctxt;
    v12 = 67;
LABEL_27:
    xmlFatalErr(v11, v12, 0);
    return v4;
  }
  xmlFatalErr(ctxt, 50, 0);
  return 0;
}

int xmlParseEnumeratedType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree)
{
  xmlParserInputPtr input;
  unsigned __int8 *cur;
  xmlEnumeration *v6;
  BOOL v7;
  int v8;
  xmlEnumeration *v9;

  input = ctxt->input;
  cur = (unsigned __int8 *)input->cur;
  if (__PAIR64__(cur[1], *cur) == 0x4F0000004ELL
    && cur[2] == 84
    && cur[3] == 65
    && cur[4] == 84
    && cur[5] == 73
    && cur[6] == 79
    && cur[7] == 78)
  {
    input->cur = cur + 8;
    input->col += 8;
    if (!cur[8])
      xmlParserInputGrow(input, 250);
    if (!xmlSkipBlankChars(ctxt))
    {
      xmlFatalErrMsg(ctxt, 65, (char)"Space required after 'NOTATION'\n");
      return 0;
    }
    v6 = xmlParseNotationType(ctxt);
    *tree = v6;
    v7 = v6 == 0;
    v8 = 10;
  }
  else
  {
    v9 = xmlParseEnumerationType(ctxt);
    *tree = v9;
    v7 = v9 == 0;
    v8 = 9;
  }
  if (v7)
    return 0;
  else
    return v8;
}

int xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  unsigned int v5;
  int v6;
  const xmlChar *v7;
  xmlParserInputPtr v8;
  const xmlChar *v9;

  input = ctxt->input;
  cur = input->cur;
  v5 = *cur;
  if (v5 > 0x48)
  {
    if (v5 == 73)
    {
      if (cur[1] != 68)
        goto LABEL_56;
      v7 = cur + 2;
      if (cur[2] == 82 && cur[3] == 69 && cur[4] == 70 && cur[5] == 83)
      {
        input->cur = cur + 6;
        input->col += 6;
        if (!cur[6])
          xmlParserInputGrow(input, 250);
        v6 = 4;
      }
      else if (*v7 == 82 && cur[3] == 69 && cur[4] == 70)
      {
        input->cur = cur + 5;
        input->col += 5;
        if (!cur[5])
          xmlParserInputGrow(input, 250);
        v6 = 3;
      }
      else
      {
        input->cur = v7;
        input->col += 2;
        if (!*v7)
          xmlParserInputGrow(input, 250);
        v6 = 2;
      }
    }
    else
    {
      if (v5 != 78 || cur[1] != 77)
        goto LABEL_56;
      if (cur[2] == 84 && cur[3] == 79 && cur[4] == 75 && cur[5] == 69 && cur[6] == 78 && cur[7] == 83)
      {
        input->cur = cur + 8;
        input->col += 8;
        if (!cur[8])
          xmlParserInputGrow(input, 250);
        v6 = 8;
      }
      else
      {
        if (cur[2] != 84 || cur[3] != 79 || cur[4] != 75 || cur[5] != 69 || cur[6] != 78)
          goto LABEL_56;
        input->cur = cur + 7;
        input->col += 7;
        if (!cur[7])
          xmlParserInputGrow(input, 250);
        v6 = 7;
      }
    }
  }
  else
  {
    if (v5 != 67)
    {
      if (v5 == 69 && cur[1] == 78)
      {
        if (cur[2] == 84 && cur[3] == 73 && cur[4] == 84 && cur[5] == 89)
        {
          input->cur = cur + 6;
          input->col += 6;
          if (!cur[6])
            xmlParserInputGrow(input, 250);
          v6 = 5;
          goto LABEL_57;
        }
        if (cur[2] == 84 && cur[3] == 73 && cur[4] == 84 && cur[5] == 73 && cur[6] == 69 && cur[7] == 83)
        {
          input->cur = cur + 8;
          input->col += 8;
          if (!cur[8])
            xmlParserInputGrow(input, 250);
          v6 = 6;
          goto LABEL_57;
        }
      }
LABEL_56:
      v6 = xmlParseEnumeratedType(ctxt, tree);
      goto LABEL_57;
    }
    if (cur[1] != 68 || cur[2] != 65 || cur[3] != 84 || cur[4] != 65)
      goto LABEL_56;
    input->cur = cur + 5;
    input->col += 5;
    if (!cur[5])
      xmlParserInputGrow(input, 250);
    v6 = 1;
  }
LABEL_57:
  if (!ctxt->progressive)
  {
    v8 = ctxt->input;
    v9 = v8->cur;
    if (v9 - v8->base >= 501 && v8->end - v9 <= 499)
      xmlSHRINK((uint64_t)ctxt);
  }
  return v6;
}

void xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  int id;
  const xmlChar *v5;
  xmlChar *v6;
  xmlParserInputPtr v7;
  const xmlChar *v8;
  const xmlChar *v9;
  xmlChar *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  xmlChar *v14;
  xmlParserInputPtr v15;
  attributeDeclSAXFunc attributeDecl;
  int sax2;
  const char *v18;
  xmlParserCtxtPtr v19;
  int v20;
  xmlChar *v21;
  xmlEnumerationPtr tree;

  input = ctxt->input;
  cur = input->cur;
  if (*cur == 60
    && cur[1] == 33
    && cur[2] == 65
    && cur[3] == 84
    && cur[4] == 84
    && cur[5] == 76
    && cur[6] == 73
    && cur[7] == 83
    && cur[8] == 84)
  {
    id = input->id;
    input->cur = cur + 9;
    input->col += 9;
    if (!cur[9])
      xmlParserInputGrow(input, 250);
    if (!xmlSkipBlankChars(ctxt))
      xmlFatalErrMsg(ctxt, 65, (char)"Space required after '<!ATTLIST'\n");
    v5 = xmlParseName(ctxt);
    if (v5)
    {
      v6 = (xmlChar *)v5;
      xmlSkipBlankChars(ctxt);
      v7 = ctxt->input;
      if (!ctxt->progressive && v7->end - v7->cur <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        v7 = ctxt->input;
      }
      v8 = v7->cur;
      if (*v8 != 62)
      {
        while (1)
        {
          if (ctxt->instate == XML_PARSER_EOF)
            goto LABEL_71;
          v21 = 0;
          if (!ctxt->progressive && v7->end - v8 <= 249)
            xmlGROW((uint64_t)ctxt);
          tree = 0;
          v9 = xmlParseName(ctxt);
          if (!v9)
            break;
          v10 = (xmlChar *)v9;
          if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
            xmlGROW((uint64_t)ctxt);
          if (!xmlSkipBlankChars(ctxt))
          {
            v18 = "Space required after the attribute name\n";
            v19 = ctxt;
            v20 = 65;
            goto LABEL_64;
          }
          v11 = xmlParseAttributeType(ctxt, &tree);
          if ((int)v11 < 1)
            goto LABEL_70;
          v12 = v11;
          if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
            xmlGROW((uint64_t)ctxt);
          if (!xmlSkipBlankChars(ctxt))
          {
            xmlFatalErrMsg(ctxt, 65, (char)"Space required after the attribute type\n");
            goto LABEL_68;
          }
          v13 = xmlParseDefaultDecl(ctxt, &v21);
          v14 = v21;
          if ((_DWORD)v12 != 1 && v21)
            xmlAttrNormalizeSpace((uint64_t)v21, v21);
          v15 = ctxt->input;
          if (!ctxt->progressive && v15->end - v15->cur <= 249)
          {
            xmlGROW((uint64_t)ctxt);
            v15 = ctxt->input;
          }
          if (*v15->cur != 62 && !xmlSkipBlankChars(ctxt))
          {
            xmlFatalErrMsg(ctxt, 65, (char)"Space required after the attribute default value\n");
            if (v14)
              xmlFree(v14);
LABEL_68:
            if (tree)
              xmlFreeEnumeration(tree);
LABEL_70:
            v7 = ctxt->input;
            goto LABEL_71;
          }
          if (ctxt->sax && !ctxt->disableSAX && (attributeDecl = ctxt->sax->attributeDecl) != 0)
          {
            ((void (*)(void *, xmlChar *, xmlChar *, uint64_t, uint64_t, xmlChar *, xmlEnumerationPtr))attributeDecl)(ctxt->userData, v6, v10, v12, v13, v14, tree);
          }
          else if (tree)
          {
            xmlFreeEnumeration(tree);
          }
          sax2 = ctxt->sax2;
          if (sax2 && v14 && (_DWORD)v13 != 3 && (_DWORD)v13 != 2)
          {
            xmlAddDefAttrs((uint64_t)ctxt, v6, v10, v14);
            sax2 = ctxt->sax2;
          }
          if (sax2)
            xmlAddSpecialAttr((uint64_t)ctxt, v6, v10, v12);
          if (v14)
            xmlFree(v14);
          v7 = ctxt->input;
          if (!ctxt->progressive && v7->end - v7->cur <= 249)
          {
            xmlGROW((uint64_t)ctxt);
            v7 = ctxt->input;
          }
          v8 = v7->cur;
          if (*v8 == 62)
            goto LABEL_71;
        }
        v18 = "ATTLIST: no name for Attribute\n";
        v19 = ctxt;
        v20 = 68;
LABEL_64:
        xmlFatalErrMsg(v19, v20, (char)v18);
        goto LABEL_70;
      }
LABEL_71:
      if (*v7->cur == 62)
      {
        if (id != v7->id)
          xmlFatalErrMsg(ctxt, 90, (char)"Attribute list declaration doesn't start and stop in the same entity\n");
        xmlNextChar(ctxt);
      }
    }
    else
    {
      xmlFatalErrMsg(ctxt, 68, (char)"ATTLIST: no name for Element\n");
    }
  }
}

uint64_t xmlAttrNormalizeSpace(uint64_t result, _BYTE *a2)
{
  unsigned __int8 *v2;
  int v3;
  int v4;
  int v5;

  v2 = (unsigned __int8 *)(result - 1);
  do
  {
    v4 = *++v2;
    v3 = v4;
  }
  while (v4 == 32);
  while (v3 == 32)
  {
    while (v3 == 32)
    {
      v5 = *++v2;
      v3 = v5;
    }
    if (v3)
    {
      LOBYTE(v3) = 32;
      goto LABEL_9;
    }
LABEL_10:
    v3 = *v2;
  }
  if (v3)
  {
    ++v2;
LABEL_9:
    *a2++ = v3;
    goto LABEL_10;
  }
  *a2 = 0;
  return result;
}

_DWORD *xmlAddDefAttrs(uint64_t a1, xmlChar *name, xmlChar *name2, const xmlChar *a4)
{
  xmlHashTable *v8;
  _DWORD *result;
  xmlHashTablePtr Dict;
  const xmlChar *v11;
  xmlDict *v12;
  const xmlChar *v13;
  const xmlChar *v14;
  int *v15;
  int *v16;
  int v17;
  int *v18;
  int *v19;
  const xmlChar *v20;
  xmlDict *v21;
  const xmlChar *v22;
  const xmlChar *v23;
  int v24;
  int *v25;
  int v26;
  const char *v27;
  int len;

  v8 = *(xmlHashTable **)(a1 + 552);
  if (v8)
  {
    result = xmlHashLookup2(v8, name, name2);
    if (result)
      return result;
  }
  len = 0;
  if (!*(_QWORD *)(a1 + 544))
  {
    Dict = xmlHashCreateDict(10, *(xmlDictPtr *)(a1 + 456));
    *(_QWORD *)(a1 + 544) = Dict;
    if (!Dict)
      return htmlErrMemory((_DWORD *)a1, 0);
  }
  v11 = xmlSplitQName3(name, &len);
  v12 = *(xmlDict **)(a1 + 456);
  if (v11)
  {
    v13 = xmlDictLookup(v12, v11, -1);
    v14 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), name, len);
  }
  else
  {
    v13 = xmlDictLookup(v12, name, -1);
    v14 = 0;
  }
  v15 = (int *)xmlHashLookup2(*(xmlHashTablePtr *)(a1 + 544), v13, v14);
  if (!v15)
  {
    v19 = (int *)xmlMalloc(0xA8uLL);
    if (!v19)
      return htmlErrMemory((_DWORD *)a1, 0);
    v16 = v19;
    *(_QWORD *)v19 = 0x400000000;
LABEL_14:
    if ((xmlHashUpdateEntry2(*(xmlHashTablePtr *)(a1 + 544), v13, v14, v16, 0) & 0x80000000) == 0)
      goto LABEL_15;
    xmlFree(v16);
    return htmlErrMemory((_DWORD *)a1, 0);
  }
  v16 = v15;
  v17 = v15[1];
  if (*v15 >= v17)
  {
    v18 = (int *)xmlRealloc(v15, (16 * ((unint64_t)(10 * v17) >> 1)) | 8);
    if (!v18)
      return htmlErrMemory((_DWORD *)a1, 0);
    v16 = v18;
    v18[1] *= 2;
    goto LABEL_14;
  }
LABEL_15:
  v20 = xmlSplitQName3(name2, &len);
  v21 = *(xmlDict **)(a1 + 456);
  if (v20)
  {
    v22 = xmlDictLookup(v21, v20, -1);
    v23 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), name2, len);
  }
  else
  {
    v22 = xmlDictLookup(v21, name2, -1);
    v23 = 0;
  }
  v24 = 5 * *v16;
  v25 = v16 + 2;
  *(_QWORD *)&v16[10 * *v16 + 2] = v22;
  *(_QWORD *)&v16[2 * v24 + 4] = v23;
  len = xmlStrlen(a4);
  result = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), a4, len);
  v26 = *v16;
  *(_QWORD *)&v25[10 * v26 + 4] = result;
  *(_QWORD *)&v25[10 * v26 + 6] = (char *)result + len;
  if (*(_DWORD *)(a1 + 148))
    v27 = "external";
  else
    v27 = 0;
  *(_QWORD *)&v25[10 * v26 + 8] = v27;
  *v16 = v26 + 1;
  return result;
}

_DWORD *xmlAddSpecialAttr(uint64_t a1, xmlChar *name, xmlChar *name2, unsigned int a4)
{
  xmlHashTable *Dict;
  _DWORD *result;

  Dict = *(xmlHashTable **)(a1 + 552);
  if (!Dict)
  {
    Dict = xmlHashCreateDict(10, *(xmlDictPtr *)(a1 + 456));
    *(_QWORD *)(a1 + 552) = Dict;
    if (!Dict)
      return htmlErrMemory((_DWORD *)a1, 0);
  }
  result = xmlHashLookup2(Dict, name, name2);
  if (!result)
    return (_DWORD *)xmlHashAddEntry2(*(xmlHashTablePtr *)(a1 + 552), name, name2, (void *)a4);
  return result;
}

xmlElementContentPtr xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  xmlParserInputPtr v6;
  const xmlChar *v7;
  int v8;
  xmlElementContentPtr v9;
  xmlElementContentPtr v10;
  xmlParserCtxtPtr v11;
  int v12;
  const xmlChar *v14;
  xmlElementContentPtr v15;
  const xmlChar *v16;
  int v17;
  xmlElementContentPtr v18;
  xmlElementContentPtr v19;
  xmlDoc *myDoc;
  xmlElementContentPtr v21;
  xmlElementContentPtr v22;
  xmlElementContentPtr v23;
  const xmlChar *v24;
  xmlElementContentPtr v25;
  xmlParserInputPtr v26;
  const xmlChar *v27;
  xmlElementContent *v28;

  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  input = ctxt->input;
  cur = input->cur;
  if (*cur == 35 && cur[1] == 80 && cur[2] == 67 && cur[3] == 68 && cur[4] == 65 && cur[5] == 84 && cur[6] == 65)
  {
    input->cur = cur + 7;
    input->col += 7;
    if (!cur[7])
      xmlParserInputGrow(input, 250);
    xmlSkipBlankChars(ctxt);
    v6 = ctxt->input;
    if (!ctxt->progressive)
    {
      v7 = v6->cur;
      if (v7 - v6->base >= 501 && v6->end - v7 <= 499)
      {
        xmlSHRINK((uint64_t)ctxt);
        v6 = ctxt->input;
      }
    }
    v8 = *v6->cur;
    if (v8 == 40 || v8 == 124)
    {
      v10 = xmlNewDocElementContent(ctxt->myDoc, 0, XML_ELEMENT_CONTENT_PCDATA);
      if (!v10)
        return v10;
    }
    else
    {
      if (v8 == 41)
      {
        if (v6->id != inputchk)
          xmlFatalErrMsg(ctxt, 90, (char)"Element content declaration doesn't start and stop in the same entity\n");
        xmlNextChar(ctxt);
        v9 = xmlNewDocElementContent(ctxt->myDoc, 0, XML_ELEMENT_CONTENT_PCDATA);
        v10 = v9;
        if (v9 && *ctxt->input->cur == 42)
        {
          v9->ocur = XML_ELEMENT_CONTENT_MULT;
          xmlNextChar(ctxt);
        }
        return v10;
      }
      v10 = 0;
    }
    v14 = 0;
    v15 = v10;
    while (1)
    {
      v16 = ctxt->input->cur;
      v17 = *v16;
      if (v17 != 124)
      {
        if (v17 != 41 || v16[1] != 42)
        {
LABEL_58:
          xmlFreeDocElementContent(ctxt->myDoc, v10);
          v11 = ctxt;
          v12 = 52;
          goto LABEL_26;
        }
        if (v14)
        {
          v25 = xmlNewDocElementContent(ctxt->myDoc, v14, XML_ELEMENT_CONTENT_ELEMENT);
          v15->c2 = v25;
          if (v25)
            v25->parent = v15;
        }
        if (v10)
          v10->ocur = XML_ELEMENT_CONTENT_MULT;
        v26 = ctxt->input;
        if (v26->id != inputchk)
        {
          xmlFatalErrMsg(ctxt, 90, (char)"Element content declaration doesn't start and stop in the same entity\n");
          v26 = ctxt->input;
        }
        v27 = v26->cur;
        v26->cur = v27 + 2;
        v26->col += 2;
        if (!v27[2])
          xmlParserInputGrow(v26, 250);
        return v10;
      }
      if (ctxt->instate == XML_PARSER_EOF)
        goto LABEL_58;
      xmlNextChar(ctxt);
      v18 = xmlNewDocElementContent(ctxt->myDoc, 0, XML_ELEMENT_CONTENT_OR);
      v19 = v18;
      if (v14)
        break;
      if (!v18)
      {
        myDoc = ctxt->myDoc;
        v28 = v15;
        goto LABEL_61;
      }
      v18->c1 = v15;
      v22 = v15;
      v23 = v18;
      v10 = v18;
      if (v15)
        goto LABEL_42;
LABEL_43:
      xmlSkipBlankChars(ctxt);
      v24 = xmlParseName(ctxt);
      if (!v24)
      {
        xmlFatalErrMsg(ctxt, 68, (char)"xmlParseElementMixedContentDecl : Name expected\n");
        myDoc = ctxt->myDoc;
LABEL_60:
        v28 = v10;
LABEL_61:
        xmlFreeDocElementContent(myDoc, v28);
        return 0;
      }
      v14 = v24;
      xmlSkipBlankChars(ctxt);
      v15 = v19;
      if (!ctxt->progressive)
      {
        v15 = v19;
        if (ctxt->input->end - ctxt->input->cur <= 249)
        {
          xmlGROW((uint64_t)ctxt);
          v15 = v19;
        }
      }
    }
    myDoc = ctxt->myDoc;
    if (!v19)
      goto LABEL_60;
    v21 = xmlNewDocElementContent(myDoc, v14, XML_ELEMENT_CONTENT_ELEMENT);
    v19->c1 = v21;
    if (v21)
      v21->parent = v19;
    v15->c2 = v19;
    v22 = v19;
    v23 = v15;
LABEL_42:
    v22->parent = v23;
    goto LABEL_43;
  }
  v11 = ctxt;
  v12 = 69;
LABEL_26:
  xmlFatalErr(v11, v12, 0);
  return 0;
}

xmlElementContentPtr xmlParseElementChildrenContentDecl(xmlParserCtxtPtr ctxt, int inputchk)
{
  return xmlParseElementChildrenContentDeclPriv((uint64_t)ctxt, inputchk, 1);
}

xmlElementContentPtr xmlParseElementChildrenContentDeclPriv(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  xmlElementContentPtr v8;
  const xmlChar *v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  xmlElementContentPtr v16;
  xmlElementContent *v17;
  int v18;
  uint64_t v19;
  xmlElementContentPtr v20;
  xmlElementContentPtr v21;
  xmlElementContentPtr v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const xmlChar *v26;
  xmlElementContentPtr v27;
  int v28;
  int v29;
  int v30;
  int v31;
  xmlElementContentPtr v32;
  _xmlElementContent *c1;
  int v34;
  int v35;
  _xmlElementContent *v36;
  xmlDoc *v37;
  xmlElementContent *v38;

  if (a3 >= 129 && (a3 > 0x800 || (*(_DWORD *)(a1 + 564) & 0x80000) == 0))
  {
    xmlFatalErrMsgInt((_DWORD *)a1, 55, "xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n", a3);
    return 0;
  }
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  v6 = *(_QWORD *)(a1 + 56);
  if (**(_BYTE **)(v6 + 32) != 40)
  {
    v9 = xmlParseName((xmlParserCtxtPtr)a1);
    if (!v9)
    {
      xmlFatalErr((_DWORD *)a1, 54, 0);
      return 0;
    }
    v8 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), v9, XML_ELEMENT_CONTENT_ELEMENT);
    if (!v8)
    {
      htmlErrMemory((_DWORD *)a1, 0);
      return v8;
    }
    v10 = *(_QWORD *)(a1 + 56);
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(_QWORD *)(v10 + 40) - *(_QWORD *)(v10 + 32)) <= 249)
    {
      xmlGROW(a1);
      v10 = *(_QWORD *)(a1 + 56);
    }
    v11 = **(unsigned __int8 **)(v10 + 32);
    switch(v11)
    {
      case '*':
        v12 = 3;
        break;
      case '+':
        v12 = 4;
        break;
      case '?':
        v12 = 2;
        break;
      default:
        v8->ocur = XML_ELEMENT_CONTENT_ONCE;
        goto LABEL_28;
    }
    v8->ocur = v12;
    xmlNextChar((xmlParserCtxtPtr)a1);
LABEL_28:
    if (*(_DWORD *)(a1 + 452)
      || (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) > 249)
    {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  v7 = *(unsigned int *)(v6 + 100);
  xmlNextChar((xmlParserCtxtPtr)a1);
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  v8 = (xmlElementContentPtr)xmlParseElementChildrenContentDeclPriv(a1, v7, (a3 + 1));
  if (!v8)
    return v8;
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  if (*(_DWORD *)(a1 + 452)
    || (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) >= 250)
  {
    goto LABEL_31;
  }
LABEL_30:
  xmlGROW(a1);
LABEL_31:
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  v13 = *(_QWORD *)(a1 + 56);
  if (!*(_DWORD *)(a1 + 452))
  {
    v14 = *(_QWORD *)(v13 + 32);
    if (v14 - *(_QWORD *)(v13 + 24) >= 501 && *(_QWORD *)(v13 + 40) - v14 <= 499)
    {
      xmlSHRINK(a1);
      v13 = *(_QWORD *)(a1 + 56);
    }
  }
  v15 = **(unsigned __int8 **)(v13 + 32);
  if (v15 == 41)
  {
    v16 = v8;
    goto LABEL_80;
  }
  if (*(_DWORD *)(a1 + 272) == -1)
  {
    v17 = 0;
    v16 = v8;
LABEL_78:
    if (v17)
    {
LABEL_79:
      v16->c2 = v17;
      v17->parent = v16;
    }
LABEL_80:
    if (*(_DWORD *)(v13 + 100) != a2)
      xmlFatalErrMsg((_DWORD *)a1, 90, (char)"Element content declaration doesn't start and stop in the same entity\n");
    xmlNextChar((xmlParserCtxtPtr)a1);
    v30 = **(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
    switch(v30)
    {
      case '*':
        v8->ocur = XML_ELEMENT_CONTENT_MULT;
        if (v8->type == XML_ELEMENT_CONTENT_OR)
        {
          v32 = v8;
          do
          {
            c1 = v32->c1;
            if (c1 && (c1->ocur & 0xFFFFFFFE) == 2)
              c1->ocur = XML_ELEMENT_CONTENT_ONCE;
            v32 = v32->c2;
            if (!v32)
              break;
            if ((v32->ocur & 0xFFFFFFFE) == 2)
              v32->ocur = XML_ELEMENT_CONTENT_ONCE;
          }
          while (v32->type == XML_ELEMENT_CONTENT_OR);
        }
        goto LABEL_115;
      case '+':
        if ((v8->ocur & 0xFFFFFFFE) == 2)
          v34 = 3;
        else
          v34 = 4;
        v8->ocur = v34;
        if (v16->type == XML_ELEMENT_CONTENT_OR)
        {
          v35 = 0;
          do
          {
            v36 = v16->c1;
            if (v36 && (v36->ocur & 0xFFFFFFFE) == 2)
            {
              v35 = 1;
              v36->ocur = XML_ELEMENT_CONTENT_ONCE;
            }
            v16 = v16->c2;
            if (!v16)
              break;
            if ((v16->ocur & 0xFFFFFFFE) == 2)
            {
              v35 = 1;
              v16->ocur = XML_ELEMENT_CONTENT_ONCE;
            }
          }
          while (v16->type == XML_ELEMENT_CONTENT_OR);
        }
        else
        {
          v35 = 0;
        }
        if (!v35)
          goto LABEL_115;
        v31 = 3;
        break;
      case '?':
        if (v8->ocur - 3 >= 2)
          v31 = 2;
        else
          v31 = 3;
        break;
      default:
        return v8;
    }
    v8->ocur = v31;
LABEL_115:
    xmlNextChar((xmlParserCtxtPtr)a1);
    return v8;
  }
  v17 = 0;
  v18 = 0;
  v19 = (a3 + 1);
  v16 = v8;
  v20 = v8;
  while (1)
  {
    if (v15 == 124)
    {
      if (v18 && v18 != 124)
      {
LABEL_120:
        xmlFatalErrMsgInt((_DWORD *)a1, 66, "xmlParseElementChildrenContentDecl : '%c' expected\n", v18);
        goto LABEL_121;
      }
      xmlNextChar((xmlParserCtxtPtr)a1);
      v21 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), 0, XML_ELEMENT_CONTENT_OR);
      if (!v21)
        goto LABEL_121;
    }
    else
    {
      if (v15 != 44)
      {
        xmlFatalErr((_DWORD *)a1, 55, 0);
LABEL_121:
        if (v17 && v17 != v20)
LABEL_123:
          xmlFreeDocElementContent(*(xmlDocPtr *)(a1 + 16), v17);
LABEL_124:
        v37 = *(xmlDoc **)(a1 + 16);
        v38 = v20;
        goto LABEL_127;
      }
      if (v18 && v18 != 44)
        goto LABEL_120;
      xmlNextChar((xmlParserCtxtPtr)a1);
      v21 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), 0, XML_ELEMENT_CONTENT_SEQ);
      if (!v21)
      {
        if (v17 && v17 != v20)
          goto LABEL_123;
        goto LABEL_124;
      }
    }
    v22 = v21;
    if (v17)
    {
      v16->c2 = v21;
      v21->parent = v16;
      v21 = v20;
      v22->c1 = v17;
    }
    else
    {
      v21->c1 = v20;
      v17 = v20;
    }
    v17->parent = v22;
    v16 = v22;
    v8 = v21;
    if (!*(_DWORD *)(a1 + 452)
      && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
    {
      xmlGROW(a1);
    }
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    v23 = *(_QWORD *)(a1 + 56);
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(_QWORD *)(v23 + 40) - *(_QWORD *)(v23 + 32)) <= 249)
    {
      xmlGROW(a1);
      v23 = *(_QWORD *)(a1 + 56);
    }
    if (**(_BYTE **)(v23 + 32) == 40)
    {
      v24 = *(unsigned int *)(v23 + 100);
      xmlNextChar((xmlParserCtxtPtr)a1);
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      v25 = xmlParseElementChildrenContentDeclPriv(a1, v24, v19);
      if (!v25)
        goto LABEL_126;
      v17 = (xmlElementContent *)v25;
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      goto LABEL_71;
    }
    v26 = xmlParseName((xmlParserCtxtPtr)a1);
    if (!v26)
      break;
    v27 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), v26, XML_ELEMENT_CONTENT_ELEMENT);
    if (!v27)
      goto LABEL_126;
    v17 = v27;
    v28 = **(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
    if (v28 == 42)
    {
      v27->ocur = XML_ELEMENT_CONTENT_MULT;
    }
    else
    {
      if (v28 == 43)
      {
        v29 = 4;
      }
      else
      {
        if (v28 != 63)
        {
          v27->ocur = XML_ELEMENT_CONTENT_ONCE;
          goto LABEL_71;
        }
        v29 = 2;
      }
      v27->ocur = v29;
    }
    xmlNextChar((xmlParserCtxtPtr)a1);
LABEL_71:
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    v13 = *(_QWORD *)(a1 + 56);
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(_QWORD *)(v13 + 40) - *(_QWORD *)(v13 + 32)) <= 249)
    {
      xmlGROW(a1);
      v13 = *(_QWORD *)(a1 + 56);
    }
    if (**(_BYTE **)(v13 + 32) == 41)
      goto LABEL_79;
    v18 = v15;
    v20 = v8;
    v15 = **(unsigned __int8 **)(v13 + 32);
    if (*(_DWORD *)(a1 + 272) == -1)
      goto LABEL_78;
  }
  xmlFatalErr((_DWORD *)a1, 54, 0);
LABEL_126:
  v37 = *(xmlDoc **)(a1 + 16);
  v38 = v8;
LABEL_127:
  xmlFreeDocElementContent(v37, v38);
  return 0;
}

int xmlParseElementContentDecl(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlElementContentPtr *result)
{
  int id;
  const xmlChar *cur;
  xmlElementContent *v7;
  int v8;

  id = ctxt->input->id;
  *result = 0;
  if (*ctxt->input->cur != 40)
  {
    xmlFatalErrMsgStr(ctxt, 54, "xmlParseElementContentDecl : %s '(' expected\n", name);
    return -1;
  }
  xmlNextChar(ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  if (ctxt->instate == XML_PARSER_EOF)
    return -1;
  xmlSkipBlankChars(ctxt);
  cur = ctxt->input->cur;
  if (*cur == 35 && cur[1] == 80 && cur[2] == 67 && cur[3] == 68 && cur[4] == 65 && cur[5] == 84 && cur[6] == 65)
  {
    v7 = xmlParseElementMixedContentDecl(ctxt, id);
    v8 = 3;
  }
  else
  {
    v7 = xmlParseElementChildrenContentDeclPriv((uint64_t)ctxt, id, 1);
    v8 = 4;
  }
  xmlSkipBlankChars(ctxt);
  *result = v7;
  return v8;
}

int xmlParseElementDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  int id;
  const xmlChar *v5;
  const xmlChar *v6;
  xmlParserInputPtr v7;
  const xmlChar *v8;
  unsigned int v9;
  uint64_t v10;
  xmlParserInputPtr v11;
  elementDeclSAXFunc elementDecl;
  xmlElementContentPtr v13;
  xmlDoc *myDoc;
  xmlElementContent *v15;
  const char *v16;
  xmlParserCtxtPtr v17;
  int v18;
  const xmlChar *v20;
  xmlElementContentPtr result;

  result = 0;
  input = ctxt->input;
  cur = input->cur;
  if (*cur != 60
    || cur[1] != 33
    || cur[2] != 69
    || cur[3] != 76
    || cur[4] != 69
    || cur[5] != 77
    || cur[6] != 69
    || cur[7] != 78
    || cur[8] != 84)
  {
    goto LABEL_50;
  }
  id = input->id;
  input->cur = cur + 9;
  input->col += 9;
  if (!cur[9])
    xmlParserInputGrow(input, 250);
  if (!xmlSkipBlankChars(ctxt))
  {
    v16 = "Space required after 'ELEMENT'\n";
    v17 = ctxt;
    v18 = 65;
LABEL_49:
    xmlFatalErrMsg(v17, v18, (char)v16);
LABEL_50:
    LODWORD(v10) = -1;
    return v10;
  }
  v5 = xmlParseName(ctxt);
  if (!v5)
  {
    v16 = "xmlParseElementDecl: no name for Element\n";
    v17 = ctxt;
    v18 = 68;
    goto LABEL_49;
  }
  v6 = v5;
  if (!xmlSkipBlankChars(ctxt))
    xmlFatalErrMsg(ctxt, 65, (char)"Space required after the element name\n");
  v7 = ctxt->input;
  v8 = v7->cur;
  v9 = *v8;
  if (v9 <= 0x40)
  {
    if (v9 != 37)
    {
      if (v9 == 40)
      {
        v20 = v6;
        v10 = xmlParseElementContentDecl(ctxt, v6, &result);
        goto LABEL_20;
      }
      goto LABEL_48;
    }
    if (!ctxt->external && ctxt->inputNr == 1)
    {
      v16 = "PEReference: forbidden within markup decl in internal subset\n";
      v17 = ctxt;
      v18 = 21;
      goto LABEL_49;
    }
LABEL_48:
    v16 = "xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n";
    v17 = ctxt;
    v18 = 54;
    goto LABEL_49;
  }
  if (v9 == 65)
  {
    if (v8[1] != 78 || v8[2] != 89)
      goto LABEL_48;
    v20 = v6;
    v7->cur = v8 + 3;
    v7->col += 3;
    if (!v8[3])
      xmlParserInputGrow(v7, 250);
    v10 = 2;
  }
  else
  {
    if (v9 != 69 || v8[1] != 77 || v8[2] != 80 || v8[3] != 84 || v8[4] != 89)
      goto LABEL_48;
    v20 = v6;
    v7->cur = v8 + 5;
    v7->col += 5;
    if (!v8[5])
      xmlParserInputGrow(v7, 250);
    v10 = 1;
  }
LABEL_20:
  xmlSkipBlankChars(ctxt);
  v11 = ctxt->input;
  if (*v11->cur == 62)
  {
    if (id != v11->id)
      xmlFatalErrMsg(ctxt, 90, (char)"Element declaration doesn't start and stop in the same entity\n");
    xmlNextChar(ctxt);
    if (ctxt->sax)
    {
      if (!ctxt->disableSAX)
      {
        elementDecl = ctxt->sax->elementDecl;
        if (elementDecl)
        {
          v13 = result;
          if (!result)
          {
            ((void (*)(void *, const xmlChar *, uint64_t, _QWORD))elementDecl)(ctxt->userData, v20, v10, 0);
            return v10;
          }
          result->parent = 0;
          ((void (*)(void *, const xmlChar *, uint64_t, xmlElementContentPtr))elementDecl)(ctxt->userData, v20, v10, v13);
          if (!v13->parent)
          {
            myDoc = ctxt->myDoc;
            v15 = v13;
LABEL_55:
            xmlFreeDocElementContent(myDoc, v15);
            return v10;
          }
          return v10;
        }
      }
    }
  }
  else
  {
    xmlFatalErr(ctxt, 73, 0);
  }
  v15 = result;
  if (result)
  {
    myDoc = ctxt->myDoc;
    goto LABEL_55;
  }
  return v10;
}

void xmlParseMarkupDecl(xmlParserCtxtPtr ctxt)
{
  const xmlChar *cur;
  int v3;
  unsigned int v4;
  int v5;

  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  cur = ctxt->input->cur;
  if (*cur == 60)
  {
    v3 = cur[1];
    if (v3 == 63)
    {
      xmlParsePI(ctxt);
    }
    else if (v3 == 33)
    {
      v4 = cur[2];
      if (v4 > 0x44)
      {
        if (v4 == 78)
        {
          xmlParseNotationDecl(ctxt);
        }
        else if (v4 == 69)
        {
          v5 = cur[3];
          if (v5 == 78)
          {
            xmlParseEntityDecl(ctxt);
          }
          else if (v5 == 76)
          {
            xmlParseElementDecl(ctxt);
          }
        }
      }
      else if (v4 == 45)
      {
        xmlParseComment(ctxt);
      }
      else if (v4 == 65)
      {
        xmlParseAttributeListDecl(ctxt);
      }
    }
  }
  if (ctxt->instate != XML_PARSER_EOF)
    ctxt->instate = XML_PARSER_DTD;
}

void xmlParseTextDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  const xmlChar *v4;
  unsigned int v5;
  uint64_t v6;
  BOOL v7;
  xmlParserInputState instate;
  xmlChar *v9;
  xmlChar *v10;
  const xmlChar *v11;
  int errNo;
  xmlParserInputPtr v13;
  const xmlChar *v14;
  int v15;
  xmlParserInputPtr v16;
  const xmlChar *i;

  input = ctxt->input;
  cur = input->cur;
  if (*cur != 60
    || cur[1] != 63
    || cur[2] != 120
    || cur[3] != 109
    || cur[4] != 108
    || ((v5 = cur[5], v4 = cur + 5, v6 = (1 << v5) & 0x100002600, v5 <= 0x20) ? (v7 = v6 == 0) : (v7 = 1), v7))
  {
    xmlFatalErr(ctxt, 56, 0);
    return;
  }
  input->cur = v4;
  input->col += 5;
  if (!*v4)
    xmlParserInputGrow(input, 250);
  instate = ctxt->instate;
  ctxt->instate = XML_PARSER_START;
  if (!xmlSkipBlankChars(ctxt))
    xmlFatalErrMsg(ctxt, 65, (char)"Space needed after '<?xml'\n");
  v9 = xmlParseVersionInfo(ctxt);
  if (v9)
  {
    v10 = v9;
    if (!xmlSkipBlankChars(ctxt))
      xmlFatalErrMsg(ctxt, 65, (char)"Space needed here\n");
  }
  else
  {
    v10 = xmlCharStrdup("1.0");
  }
  ctxt->input->version = v10;
  v11 = xmlParseEncodingDecl(ctxt);
  errNo = ctxt->errNo;
  if (errNo != 32)
  {
    if (!v11 && !errNo)
      xmlFatalErrMsg(ctxt, 101, (char)"Missing encoding in text declaration\n");
    xmlSkipBlankChars(ctxt);
    v13 = ctxt->input;
    v14 = v13->cur;
    v15 = *v14;
    if (v15 == 62)
    {
      xmlFatalErr(ctxt, 57, 0);
    }
    else
    {
      if (v15 == 63 && v14[1] == 62)
      {
        v13->cur = v14 + 2;
        v13->col += 2;
        if (!v14[2])
          xmlParserInputGrow(v13, 250);
        goto LABEL_34;
      }
      xmlFatalErr(ctxt, 57, 0);
      v16 = ctxt->input;
      for (i = v16->cur; *i++ && *(i - 1) != 62; v16->cur = i)
        ;
    }
    xmlNextChar(ctxt);
  }
LABEL_34:
  ctxt->instate = instate;
}

void xmlParseExternalSubset(xmlParserCtxtPtr ctxt, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  const xmlChar *cur;
  xmlCharEncoding v7;
  const xmlChar *v8;
  xmlDocPtr myDoc;
  xmlParserInputPtr input;
  const xmlChar *v11;
  int v12;
  int v13;
  uint64_t consumed_low;
  const xmlChar *v15;
  uint64_t v16;
  BOOL v17;
  unsigned __int8 in[4];

  xmlDetectSAX2((const xmlChar *)ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  if (!ctxt->encoding)
  {
    cur = ctxt->input->cur;
    if (ctxt->input->end - cur >= 4)
    {
      *(_DWORD *)in = *(_DWORD *)cur;
      v7 = xmlDetectCharEncoding(in, 4);
      if (v7)
        xmlSwitchEncoding(ctxt, v7);
    }
  }
  v8 = ctxt->input->cur;
  if (*v8 == 60 && v8[1] == 63 && v8[2] == 120 && v8[3] == 109 && v8[4] == 108)
  {
    xmlParseTextDecl(ctxt);
    if (ctxt->errNo == 32)
    {
      xmlHaltParser(ctxt);
      return;
    }
  }
  myDoc = ctxt->myDoc;
  if (!myDoc)
  {
    myDoc = xmlNewDoc((const xmlChar *)"1.0");
    ctxt->myDoc = myDoc;
    if (!myDoc)
    {
      htmlErrMemory(ctxt, (const xmlChar *)"New Doc failed");
      return;
    }
    myDoc->properties = 64;
  }
  if (!myDoc->intSubset)
    xmlCreateIntSubset(myDoc, 0, ExternalID, SystemID);
  ctxt->instate = XML_PARSER_DTD;
  ctxt->external = 1;
  xmlSkipBlankChars(ctxt);
  input = ctxt->input;
  v11 = input->cur;
  while (1)
  {
    v12 = *v11;
    if (v12 != 37)
    {
      if (v12 != 60)
        goto LABEL_38;
      v13 = v11[1];
      if (v13 != 63 && v13 != 33)
        goto LABEL_39;
    }
    consumed_low = LODWORD(input->consumed);
    if (ctxt->progressive)
    {
      v15 = v11;
    }
    else
    {
      v16 = input->end - v11;
      v15 = v11;
      if (v16 <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        v15 = ctxt->input->cur;
        v12 = *v15;
      }
    }
    if (v12 == 60 && v15[1] == 33 && v15[2] == 91)
      xmlParseConditionalSections((uint64_t)ctxt);
    else
      xmlParseMarkupDecl(ctxt);
    xmlSkipBlankChars(ctxt);
    input = ctxt->input;
    v17 = input->cur == v11;
    v11 = input->cur;
    if (v17)
    {
      v11 = input->cur;
      if (consumed_low == input->consumed)
        break;
    }
  }
  xmlFatalErr(ctxt, 60, 0);
  v12 = *ctxt->input->cur;
LABEL_38:
  if (!v12)
    return;
LABEL_39:
  xmlFatalErr(ctxt, 60, 0);
}

void xmlParseConditionalSections(uint64_t a1)
{
  _DWORD *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  xmlParserInput *v9;
  const xmlChar *cur;
  int v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned __int8 *v20;
  int v21;
  _DWORD *v23;
  int v24;

  if (*(_DWORD *)(a1 + 272) == -1)
  {
    v2 = 0;
    goto LABEL_84;
  }
  v2 = 0;
  v3 = 0;
  v4 = 0;
  while (1)
  {
    v5 = *(_QWORD *)(a1 + 56);
    v6 = *(unsigned __int8 **)(v5 + 32);
    v7 = *v6;
    if (v7 == 60)
      break;
    if (!v3 || v7 != 93 || v6[1] != 93 || v6[2] != 62)
      goto LABEL_36;
    if (*(_DWORD *)(v5 + 100) != v2[--v3])
    {
      xmlFatalErrMsg((_DWORD *)a1, 90, (char)"All markup of the conditional section is not in the same entity\n");
      v5 = *(_QWORD *)(a1 + 56);
      v6 = *(unsigned __int8 **)(v5 + 32);
    }
    *(_QWORD *)(v5 + 32) = v6 + 3;
    *(_DWORD *)(v5 + 56) += 3;
    if (!v6[3])
LABEL_78:
      xmlParserInputGrow((xmlParserInputPtr)v5, 250);
LABEL_38:
    if (v3)
    {
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      if (!*(_DWORD *)(a1 + 452)
        && (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 249)
      {
        xmlGROW(a1);
      }
      if (*(_DWORD *)(a1 + 272) != -1)
        continue;
    }
    goto LABEL_84;
  }
  if (v6[1] != 33 || v6[2] != 91)
  {
LABEL_36:
    v14 = *(unsigned int *)(v5 + 64);
    xmlParseMarkupDecl((xmlParserCtxtPtr)a1);
    v15 = *(_QWORD *)(a1 + 56);
    if (*(unsigned __int8 **)(v15 + 32) != v6 || v14 != *(_QWORD *)(v15 + 64))
      goto LABEL_38;
    v23 = (_DWORD *)a1;
    v24 = 60;
    goto LABEL_83;
  }
  v8 = *(_DWORD *)(v5 + 100);
  *(_QWORD *)(v5 + 32) = v6 + 3;
  *(_DWORD *)(v5 + 56) += 3;
  if (!v6[3])
    xmlParserInputGrow((xmlParserInputPtr)v5, 250);
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  v9 = *(xmlParserInput **)(a1 + 56);
  cur = v9->cur;
  if (*cur != 73)
    goto LABEL_80;
  v11 = cur[1];
  if (v11 != 71)
  {
    if (v11 == 78 && cur[2] == 67 && cur[3] == 76 && cur[4] == 85 && cur[5] == 68 && cur[6] == 69)
    {
      v9->cur = cur + 7;
      v9->col += 7;
      if (!cur[7])
        xmlParserInputGrow(v9, 250);
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      v12 = *(_QWORD *)(a1 + 56);
      if (**(_BYTE **)(v12 + 32) == 91)
      {
        if (*(_DWORD *)(v12 + 100) != v8)
          xmlFatalErrMsg((_DWORD *)a1, 90, (char)"All markup of the conditional section is not in the same entity\n");
        xmlNextChar((xmlParserCtxtPtr)a1);
        if (v4 <= v3)
        {
          if (v4)
            v4 *= 2;
          else
            v4 = 4;
          v13 = xmlRealloc(v2, 4 * v4);
          if (!v13)
          {
LABEL_85:
            htmlErrMemory((_DWORD *)a1, 0);
            goto LABEL_84;
          }
          v2 = v13;
        }
        v2[v3++] = v8;
        goto LABEL_38;
      }
      goto LABEL_82;
    }
LABEL_80:
    v23 = (_DWORD *)a1;
    v24 = 95;
LABEL_83:
    xmlFatalErr(v23, v24, 0);
    xmlHaltParser((xmlParserCtxtPtr)a1);
    goto LABEL_84;
  }
  if (cur[2] != 78 || cur[3] != 79 || cur[4] != 82 || cur[5] != 69)
    goto LABEL_80;
  v9->cur = cur + 6;
  v9->col += 6;
  if (!cur[6])
    xmlParserInputGrow(v9, 250);
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  v16 = *(_QWORD *)(a1 + 56);
  if (**(_BYTE **)(v16 + 32) != 91)
  {
LABEL_82:
    v23 = (_DWORD *)a1;
    v24 = 83;
    goto LABEL_83;
  }
  if (*(_DWORD *)(v16 + 100) != v8)
    xmlFatalErrMsg((_DWORD *)a1, 90, (char)"All markup of the conditional section is not in the same entity\n");
  xmlNextChar((xmlParserCtxtPtr)a1);
  v17 = *(_DWORD *)(a1 + 332);
  v18 = *(_DWORD *)(a1 + 272);
  if (!*(_DWORD *)(a1 + 448))
    *(_DWORD *)(a1 + 332) = 1;
  v19 = 0;
  *(_DWORD *)(a1 + 272) = 15;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        v5 = *(_QWORD *)(a1 + 56);
        v20 = *(unsigned __int8 **)(v5 + 32);
        v21 = *v20;
        if (v21 != 60)
          break;
        if (v20[1] != 33 || v20[2] != 91)
          goto LABEL_69;
        *(_QWORD *)(v5 + 32) = v20 + 3;
        *(_DWORD *)(v5 + 56) += 3;
        if (!v20[3])
          xmlParserInputGrow((xmlParserInputPtr)v5, 250);
        if (__CFADD__(v19++, 1))
          goto LABEL_85;
      }
      if (v21 == 93)
        break;
      if (!*v20)
        goto LABEL_74;
LABEL_69:
      xmlNextChar((xmlParserCtxtPtr)a1);
    }
    if (v20[1] != 93 || v20[2] != 62)
      goto LABEL_69;
    if (!v19)
      break;
    *(_QWORD *)(v5 + 32) = v20 + 3;
    *(_DWORD *)(v5 + 56) += 3;
    if (!v20[3])
      xmlParserInputGrow((xmlParserInputPtr)v5, 250);
    --v19;
  }
LABEL_74:
  *(_DWORD *)(a1 + 332) = v17;
  *(_DWORD *)(a1 + 272) = v18;
  if (*v20)
  {
    if (*(_DWORD *)(v5 + 100) != v8)
    {
      xmlFatalErrMsg((_DWORD *)a1, 90, (char)"All markup of the conditional section is not in the same entity\n");
      v5 = *(_QWORD *)(a1 + 56);
      v20 = *(unsigned __int8 **)(v5 + 32);
    }
    *(_QWORD *)(v5 + 32) = v20 + 3;
    *(_DWORD *)(v5 + 56) += 3;
    if (!v20[3])
      goto LABEL_78;
    goto LABEL_38;
  }
  xmlFatalErr((_DWORD *)a1, 59, 0);
LABEL_84:
  xmlFree(v2);
}

void xmlParseReference(xmlParserCtxtPtr ctxt)
{
  const xmlChar *v1;
  int v3;
  int v4;
  uint64_t v5;
  charactersSAXFunc v6;
  uint64_t v7;
  void *v8;
  xmlEntityPtr v9;
  uint64_t v10;
  xmlEntityType etype;
  const xmlChar *content;
  void *userData;
  uint64_t v14;
  referenceSAXFunc reference;
  void *v16;
  xmlChar *v17;
  int checked;
  unint64_t *p_nbentities;
  unint64_t nbentities;
  _xmlSAXHandler *sax;
  void *v22;
  int v23;
  int v24;
  int v25;
  xmlNode **p_children;
  const xmlChar *v27;
  xmlNode *v28;
  uint64_t v29;
  xmlParserCtxt *v30;
  int v31;
  xmlParserCtxt *v32;
  int *p_depth;
  int v34;
  unint64_t v35;
  int v36;
  const xmlChar *v37;
  unint64_t v38;
  xmlNode *v39;
  xmlNodePtr v40;
  xmlNodePtr v41;
  xmlNodePtr v42;
  xmlNodePtr v43;
  int v44;
  xmlDoc *v45;
  _xmlNode *next;
  int v47;
  unint64_t v48;
  xmlNode *v49;
  xmlNode *v50;
  xmlNode *v51;
  xmlNode *v52;
  xmlNodePtr v53;
  xmlNode *v54;
  BOOL v55;
  void (*v56)(uint64_t, xmlNode *, xmlNodePtr);
  uint64_t v57;
  xmlNode *v58;
  _BYTE *v59;
  xmlNodePtr node;
  xmlDocPtr myDoc;
  _QWORD *p_private;
  _QWORD *v63;
  charactersSAXFunc characters;
  xmlNodePtr cur;
  xmlChar out[8];
  uint64_t v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  cur = 0;
  v1 = ctxt->input->cur;
  if (*v1 != 38)
    return;
  if (v1[1] != 35)
  {
    v9 = xmlParseEntityRef(ctxt);
    if (!v9 || !ctxt->wellFormed)
      return;
    v10 = (uint64_t)v9;
    if (!v9->name || (etype = v9->etype, etype == XML_INTERNAL_PREDEFINED_ENTITY))
    {
      content = v9->content;
      if (content && ctxt->sax && ctxt->sax->characters && !ctxt->disableSAX)
      {
        characters = ctxt->sax->characters;
        userData = ctxt->userData;
        v14 = xmlStrlen(content);
        ((void (*)(void *, const xmlChar *, uint64_t))characters)(userData, content, v14);
      }
      return;
    }
    checked = v9->checked;
    if (!checked || !v9->children && (ctxt->options & 2) != 0)
    {
      if (etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)
      {
        p_nbentities = &ctxt->nbentities;
        nbentities = ctxt->nbentities;
        if (etype != XML_INTERNAL_GENERAL_ENTITY)
        {
          xmlErrMsgStr(ctxt, 1, "invalid entity type found\n", 0);
          v31 = 88;
LABEL_76:
          v35 = *p_nbentities - nbentities;
          if (v35 + 1 < 0x3FFFFFFF)
            v36 = v35 + 1;
          else
            v36 = 0x3FFFFFFF;
          *(_DWORD *)(v10 + 132) = 2 * v36;
          v37 = *(const xmlChar **)(v10 + 80);
          if (v37 && xmlStrchr(v37, 0x3Cu))
            *(_DWORD *)(v10 + 132) |= 1u;
          if (v31 == 111 || v31 == 89)
          {
            xmlFatalErr(ctxt, v31, 0);
            xmlHaltParser(ctxt);
LABEL_86:
            xmlFreeNodeList(cur);
            return;
          }
          if (xmlParserEntityCheck((uint64_t)ctxt, 0, v10, 0))
            goto LABEL_86;
          v43 = cur;
          if (v31 || !cur)
          {
            if (v31 && v31 != 27)
            {
              xmlFatalErrMsgStr(ctxt, 26, "Entity '%s' failed to parse\n", *(const xmlChar **)(v10 + 16));
              v59 = *(_BYTE **)(v10 + 80);
              if (v59)
                *v59 = 0;
              xmlParserEntityCheck((uint64_t)ctxt, 0, v10, 0);
LABEL_133:
              if (!*(_DWORD *)(v10 + 132))
                *(_DWORD *)(v10 + 132) = 2;
              p_children = (xmlNode **)(v10 + 24);
              if (!*(_QWORD *)(v10 + 24))
                goto LABEL_136;
              goto LABEL_47;
            }
            if (!cur)
              goto LABEL_133;
          }
          else
          {
            v44 = *(_DWORD *)(v10 + 92);
            if ((v44 - 1) <= 1 && !*(_QWORD *)(v10 + 24))
            {
              *(_QWORD *)(v10 + 24) = cur;
              if (ctxt->replaceEntities
                && ctxt->parseMode != XML_PARSE_READER
                && (v43->type != XML_TEXT_NODE || v43->next))
              {
                *(_DWORD *)(v10 + 128) = 0;
                node = ctxt->node;
                myDoc = ctxt->myDoc;
                p_private = &v43->_private;
                do
                {
                  v63 = p_private;
                  p_private[5] = node;
                  p_private[8] = myDoc;
                  p_private = (_QWORD *)p_private[6];
                }
                while (p_private);
                *(_QWORD *)(v10 + 32) = v63;
                if (v44 == 2 && xmlEntityRefFunc)
                  xmlEntityRefFunc(v10, v43, 0);
                goto LABEL_133;
              }
              *(_DWORD *)(v10 + 128) = 1;
              v43->parent = (_xmlNode *)v10;
              v45 = *(xmlDoc **)(v10 + 64);
              next = v43;
              while (1)
              {
                xmlSetTreeDoc(next, v45);
                next = cur->next;
                if (!next)
                  break;
                cur = cur->next;
                next->parent = (_xmlNode *)v10;
                v45 = *(xmlDoc **)(v10 + 64);
              }
              *(_QWORD *)(v10 + 32) = cur;
LABEL_132:
              cur = 0;
              goto LABEL_133;
            }
          }
          xmlFreeNodeList(cur);
          goto LABEL_132;
        }
        if (ctxt->userData == ctxt)
          v30 = 0;
        else
          v30 = (xmlParserCtxt *)ctxt->userData;
        ++ctxt->depth;
        v24 = xmlParseBalancedChunkMemoryInternal((uint64_t)ctxt, v9->content, v30, &cur);
LABEL_67:
        v31 = v24;
        --ctxt->depth;
        goto LABEL_76;
      }
      if ((ctxt->options & 0x12) != 0)
      {
        p_nbentities = &ctxt->nbentities;
        nbentities = ctxt->nbentities;
        sax = ctxt->sax;
        if (ctxt->userData == ctxt)
          v22 = 0;
        else
          v22 = ctxt->userData;
        v23 = ctxt->depth + 1;
        ctxt->depth = v23;
        v24 = xmlParseExternalEntityPrivate((uint64_t)ctxt->myDoc, (uint64_t)ctxt, sax, v22, v23, v9->URI, (const char *)v9->ExternalID, &cur);
        goto LABEL_67;
      }
    }
    if (checked != 1)
    {
      if (checked >= 0)
        v25 = v9->checked;
      else
        v25 = checked + 1;
      ctxt->nbentities += v25 >> 1;
    }
    p_children = &v9->children;
    if (!v9->children)
    {
      if (checked)
      {
        if (ctxt->userData == ctxt)
          v32 = 0;
        else
          v32 = (xmlParserCtxt *)ctxt->userData;
        if (etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
        {
          p_depth = &ctxt->depth;
          v47 = ctxt->depth + 1;
          ctxt->depth = v47;
          v34 = xmlParseExternalEntityPrivate((uint64_t)ctxt->myDoc, (uint64_t)ctxt, ctxt->sax, v32, v47, v9->URI, (const char *)v9->ExternalID, 0);
        }
        else
        {
          if (etype != XML_INTERNAL_GENERAL_ENTITY)
          {
            xmlErrMsgStr(ctxt, 1, "invalid entity type found\n", 0);
            goto LABEL_136;
          }
          p_depth = &ctxt->depth;
          ++ctxt->depth;
          v34 = xmlParseBalancedChunkMemoryInternal((uint64_t)ctxt, v9->content, v32, 0);
        }
        --*p_depth;
        if (v34 == 89)
        {
          xmlFatalErr(ctxt, 89, 0);
          return;
        }
      }
LABEL_136:
      if (!ctxt->sax)
        return;
      reference = ctxt->sax->reference;
      if (!reference || ctxt->replaceEntities || ctxt->disableSAX)
        return;
      goto LABEL_140;
    }
LABEL_47:
    if (ctxt->sax)
    {
      reference = ctxt->sax->reference;
      if (reference)
      {
        if (!ctxt->replaceEntities && !ctxt->disableSAX)
        {
LABEL_140:
          v16 = ctxt->userData;
          v17 = *(xmlChar **)(v10 + 16);
          goto LABEL_31;
        }
      }
    }
    if (!ctxt->replaceEntities || !ctxt->node)
      return;
    if (cur)
    {
      if (ctxt->parseMode != XML_PARSE_READER)
      {
        if (ctxt->inputNr < 1)
        {
          v27 = xmlDictLookup(ctxt->dict, (const xmlChar *)"nbktext", -1);
          v28 = *p_children;
          if ((*p_children)->type == XML_TEXT_NODE)
            v28->name = v27;
          v29 = *(_QWORD *)(v10 + 32);
          if ((xmlNode *)v29 != v28 && *(_DWORD *)(v29 + 8) == 3)
            *(_QWORD *)(v29 + 16) = v27;
          xmlAddChildList(ctxt->node, v28);
          goto LABEL_162;
        }
LABEL_116:
        v48 = *(int *)(v10 + 88) + ctxt->sizeentcopy + 5;
        ctxt->sizeentcopy = v48;
        if (xmlParserEntityCheck((uint64_t)ctxt, 0, v10, v48))
          return;
        v49 = *(xmlNode **)(v10 + 24);
        v50 = *(xmlNode **)(v10 + 32);
        *(_QWORD *)(v10 + 24) = 0;
        *(_QWORD *)(v10 + 32) = 0;
        if (v49)
        {
          v51 = 0;
          do
          {
            v52 = v49->next;
            v49->parent = 0;
            v49->next = 0;
            v53 = xmlDocCopyNode(v49, ctxt->myDoc, 1);
            v54 = v53;
            if (v53)
            {
              if (!v53->_private)
                v53->_private = v49->_private;
              if (!v51)
                v51 = v49;
              xmlAddChild((xmlNodePtr)v10, v53);
              xmlAddChild(ctxt->node, v49);
            }
            if (v49 == v50)
              break;
            v49 = v52;
          }
          while (v52);
        }
        else
        {
          v54 = 0;
          v51 = 0;
        }
        if (!*(_DWORD *)(v10 + 128))
          *(_DWORD *)(v10 + 128) = 1;
        if (*(_DWORD *)(v10 + 92) == 2)
        {
          v56 = (void (*)(uint64_t, xmlNode *, xmlNodePtr))xmlEntityRefFunc;
          if (xmlEntityRefFunc)
          {
            v57 = v10;
            v58 = v51;
            v42 = v54;
            goto LABEL_161;
          }
        }
        goto LABEL_162;
      }
    }
    else if (*(_DWORD *)(v10 + 128) && ctxt->parseMode != XML_PARSE_READER)
    {
      goto LABEL_116;
    }
    v38 = *(int *)(v10 + 88) + ctxt->sizeentcopy + 5;
    ctxt->sizeentcopy = v38;
    if (xmlParserEntityCheck((uint64_t)ctxt, 0, v10, v38))
      return;
    v39 = *p_children;
    if (*p_children)
    {
      v40 = 0;
      while (1)
      {
        v41 = xmlDocCopyNode(v39, ctxt->myDoc, 1);
        if (v41)
        {
          if (!v41->_private)
            v41->_private = v39->_private;
          if (!v40)
            v40 = v41;
          v42 = xmlAddChild(ctxt->node, v41);
        }
        else
        {
          v42 = 0;
        }
        if (v39 == *(xmlNode **)(v10 + 32))
          break;
        v39 = v39->next;
        if (!v39)
          goto LABEL_149;
      }
      v55 = ctxt->parseMode != XML_PARSE_READER || v42 == 0;
      if (!v55 && v42->type == XML_ELEMENT_NODE && !v42->children)
        v42->extra = 1;
    }
    else
    {
      v42 = 0;
      v40 = 0;
    }
LABEL_149:
    if (*(_DWORD *)(v10 + 92) == 2)
    {
      v56 = (void (*)(uint64_t, xmlNode *, xmlNodePtr))xmlEntityRefFunc;
      if (xmlEntityRefFunc)
      {
        v57 = v10;
        v58 = v40;
LABEL_161:
        v56(v57, v58, v42);
      }
    }
LABEL_162:
    *(_QWORD *)&ctxt->nodelen = 0;
    return;
  }
  *(_QWORD *)out = 0;
  v67 = 0;
  v3 = v1[2];
  v4 = xmlParseCharRef(ctxt);
  if (!v4)
    return;
  if (ctxt->charset == 1)
  {
    v5 = xmlCopyCharMultiByte(out, v4);
    out[(int)v5] = 0;
    if (ctxt->sax)
    {
      v6 = ctxt->sax->characters;
      if (v6)
      {
        if (!ctxt->disableSAX)
        {
          v7 = v5;
          v8 = ctxt->userData;
LABEL_23:
          ((void (*)(void *, xmlChar *, uint64_t))v6)(v8, out, v7);
          return;
        }
      }
    }
    return;
  }
  if (v4 > 255)
  {
    if ((v3 & 0xFFFFFFDF) == 0x58)
      snprintf((char *)out, 0x10uLL, "#x%X");
    else
      snprintf((char *)out, 0x10uLL, "#%d");
    if (!ctxt->sax)
      return;
    reference = ctxt->sax->reference;
    if (!reference || ctxt->disableSAX)
      return;
    v16 = ctxt->userData;
    v17 = out;
LABEL_31:
    ((void (*)(void *, xmlChar *))reference)(v16, v17);
    return;
  }
  out[0] = v4;
  out[1] = 0;
  if (ctxt->sax)
  {
    v6 = ctxt->sax->characters;
    if (v6)
    {
      if (!ctxt->disableSAX)
      {
        v8 = ctxt->userData;
        v7 = 1;
        goto LABEL_23;
      }
    }
  }
}

xmlEntityPtr xmlParseEntityRef(xmlParserCtxtPtr ctxt)
{
  const xmlChar *v2;
  const xmlChar *v3;
  xmlEntityPtr PredefinedEntity;
  getEntitySAXFunc getEntity;
  int wellFormed;
  xmlParserInputState instate;
  xmlEntityType etype;
  const char *v9;
  xmlParserCtxtPtr v10;
  int v11;
  int checked;
  const xmlChar *content;
  referenceSAXFunc reference;

  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  if (ctxt->instate == XML_PARSER_EOF || *ctxt->input->cur != 38)
    return 0;
  xmlNextChar(ctxt);
  v2 = xmlParseName(ctxt);
  if (!v2)
  {
    xmlFatalErrMsg(ctxt, 68, (char)"xmlParseEntityRef: no name\n");
    return 0;
  }
  if (*ctxt->input->cur != 59)
  {
    xmlFatalErr(ctxt, 23, 0);
    return 0;
  }
  v3 = v2;
  xmlNextChar(ctxt);
  if ((ctxt->options & 0x100000) == 0)
  {
    PredefinedEntity = xmlGetPredefinedEntity(v3);
    if (PredefinedEntity)
      return PredefinedEntity;
  }
  ++ctxt->nbentities;
  if (!ctxt->sax)
    goto LABEL_24;
  getEntity = ctxt->sax->getEntity;
  if (getEntity)
    PredefinedEntity = (xmlEntityPtr)((uint64_t (*)(void *, const xmlChar *))getEntity)(ctxt->userData, v3);
  else
    PredefinedEntity = 0;
  wellFormed = ctxt->wellFormed;
  if (wellFormed == 1 && !PredefinedEntity)
  {
    if ((ctxt->options & 0x100000) != 0)
    {
      PredefinedEntity = xmlGetPredefinedEntity(v3);
      wellFormed = ctxt->wellFormed;
    }
    else
    {
      PredefinedEntity = 0;
      wellFormed = 1;
    }
  }
  if (wellFormed == 1 && !PredefinedEntity)
  {
    if (ctxt->userData != ctxt)
    {
LABEL_24:
      PredefinedEntity = 0;
      goto LABEL_25;
    }
    PredefinedEntity = xmlSAX2GetEntity(ctxt, v3);
  }
LABEL_25:
  instate = ctxt->instate;
  if (instate == XML_PARSER_EOF)
    return 0;
  if (PredefinedEntity)
  {
    etype = PredefinedEntity->etype;
    if (etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY)
    {
      v9 = "Entity reference to unparsed entity %s\n";
      v10 = ctxt;
      v11 = 28;
LABEL_36:
      xmlFatalErrMsgStr(v10, v11, v9, v3);
      return PredefinedEntity;
    }
    if (instate == XML_PARSER_ATTRIBUTE_VALUE && etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
    {
      v9 = "Attribute references external entity '%s'\n";
      v10 = ctxt;
      v11 = 29;
      goto LABEL_36;
    }
    if (instate != XML_PARSER_ATTRIBUTE_VALUE)
    {
      if ((etype & 0xFFFFFFFE) != 4)
        return PredefinedEntity;
      v9 = "Attempt to reference the parameter entity '%s'\n";
      v10 = ctxt;
      v11 = 30;
      goto LABEL_36;
    }
    if (etype != XML_INTERNAL_PREDEFINED_ENTITY)
    {
      checked = PredefinedEntity->checked;
      if (!checked || (checked & 1) != 0)
      {
        content = PredefinedEntity->content;
        if (content)
        {
          if (xmlStrchr(content, 0x3Cu))
          {
            v9 = "'<' in entity '%s' is not allowed in attributes values\n";
            v10 = ctxt;
            v11 = 38;
            goto LABEL_36;
          }
        }
      }
    }
  }
  else
  {
    if (ctxt->standalone != 1 && (ctxt->hasExternalSubset || ctxt->hasPErefs))
    {
      xmlErrMsgStr(ctxt, 27, "Entity '%s' not defined\n", v3);
      if (!ctxt->inSubset)
      {
        if (ctxt->sax)
        {
          reference = ctxt->sax->reference;
          if (reference)
            ((void (*)(void *, const xmlChar *))reference)(ctxt->userData, v3);
        }
      }
    }
    else
    {
      xmlFatalErrMsgStr(ctxt, 26, "Entity '%s' not defined\n", v3);
    }
    xmlParserEntityCheck((uint64_t)ctxt, 0, 0, 0);
    PredefinedEntity = 0;
    ctxt->valid = 0;
  }
  return PredefinedEntity;
}

uint64_t xmlParseBalancedChunkMemoryInternal(uint64_t a1, xmlChar *str, xmlParserCtxt *a3, _QWORD *a4)
{
  uint64_t v4;
  int v8;
  int v10;
  xmlParserCtxtPtr MemoryParserCtxt;
  uint64_t v12;
  xmlParserCtxtPtr v13;
  xmlDict *dict;
  xmlDict *v15;
  uint64_t v16;
  uint64_t v17;
  xmlDocPtr v18;
  xmlDoc *v19;
  xmlDocPtr v20;
  xmlDict *v21;
  xmlNodePtr v22;
  xmlNode *v23;
  xmlNode *v24;
  int v25;
  _BYTE *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  xmlDoc *v30;
  xmlNode *v31;
  unsigned int v32;
  __int128 v34;

  v4 = (uint64_t)a4;
  v8 = *(_DWORD *)(a1 + 392);
  if (v8 >= 41 && (v8 > 0x400 || (*(_DWORD *)(a1 + 564) & 0x80000) == 0))
    return 89;
  if (a4)
    *a4 = 0;
  if (!str)
    return 1;
  v10 = xmlStrlen(str);
  MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)str, v10);
  if (!MemoryParserCtxt)
    return 27;
  v12 = (uint64_t)MemoryParserCtxt;
  if (a3)
    v13 = a3;
  else
    v13 = MemoryParserCtxt;
  MemoryParserCtxt->userData = v13;
  dict = MemoryParserCtxt->dict;
  if (dict)
    xmlDictFree(dict);
  v15 = *(xmlDict **)(a1 + 456);
  *(_QWORD *)(v12 + 456) = v15;
  *(_DWORD *)(v12 + 736) = *(_DWORD *)(a1 + 736) + 1;
  *(_QWORD *)(v12 + 480) = xmlDictLookup(v15, (const xmlChar *)"xml", 3);
  *(_QWORD *)(v12 + 488) = xmlDictLookup(*(xmlDictPtr *)(v12 + 456), (const xmlChar *)"xmlns", 5);
  *(_QWORD *)(v12 + 496) = xmlDictLookup(*(xmlDictPtr *)(v12 + 456), (const xmlChar *)"http://www.w3.org/XML/1998/namespace", 36);
  if (*(int *)(a1 + 508) >= 1)
  {
    v16 = 0;
    do
    {
      nsPush(v12, *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v16), *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v16 + 8));
      v16 += 2;
    }
    while (*(_DWORD *)(a1 + 508) > (int)v16);
  }
  v17 = *(_QWORD *)v12;
  *(_QWORD *)v12 = *(_QWORD *)a1;
  xmlDetectSAX2((const xmlChar *)v12);
  *(_DWORD *)(v12 + 28) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(v12 + 564) = *(_DWORD *)(a1 + 564);
  *(_QWORD *)(v12 + 424) = *(_QWORD *)(a1 + 424);
  v18 = *(xmlDocPtr *)(a1 + 16);
  if (v18)
  {
    v19 = 0;
    *(_QWORD *)(v12 + 16) = v18;
    v34 = *(_OWORD *)&v18->children;
    goto LABEL_25;
  }
  v20 = xmlNewDoc((const xmlChar *)"1.0");
  if (!v20)
  {
    *(_QWORD *)v12 = v17;
    *(_QWORD *)(v12 + 456) = 0;
    xmlFreeParserCtxt((xmlParserCtxtPtr)v12);
    return 1;
  }
  v18 = v20;
  v20->properties = 64;
  v21 = *(xmlDict **)(v12 + 456);
  v18->dict = v21;
  xmlDictReference(v21);
  *(_QWORD *)(v12 + 16) = v18;
  v34 = 0u;
  v19 = v18;
LABEL_25:
  v22 = xmlNewDocNode(v18, 0, (const xmlChar *)"pseudoroot", 0);
  if (!v22)
  {
    *(_QWORD *)v12 = v17;
    *(_QWORD *)(v12 + 456) = 0;
    xmlFreeParserCtxt((xmlParserCtxtPtr)v12);
    if (v19)
      xmlFreeDoc(v19);
    return 1;
  }
  v23 = v22;
  v24 = *(xmlNode **)(v12 + 16);
  v24->children = 0;
  v24->last = 0;
  xmlAddChild(v24, v23);
  nodePush((xmlParserCtxtPtr)v12, *(xmlNodePtr *)(*(_QWORD *)(v12 + 16) + 24));
  *(_DWORD *)(v12 + 272) = 7;
  *(_DWORD *)(v12 + 392) = *(_DWORD *)(a1 + 392) + 1;
  *(_DWORD *)(v12 + 156) = 0;
  v25 = *(_DWORD *)(a1 + 432);
  *(_DWORD *)(v12 + 432) = v25;
  if (*(_DWORD *)(a1 + 156) || *(_DWORD *)(a1 + 28))
    *(_DWORD *)(v12 + 432) = v25 | 8;
  *(_DWORD *)(v12 + 568) = *(_DWORD *)(a1 + 568);
  *(_OWORD *)(v12 + 544) = *(_OWORD *)(a1 + 544);
  xmlParseContent((xmlParserCtxtPtr)v12);
  v26 = *(_BYTE **)(*(_QWORD *)(v12 + 56) + 32);
  if (*v26)
  {
    if (*v26 == 60 && v26[1] == 47)
      v27 = 85;
    else
      v27 = 86;
    xmlFatalErr((_DWORD *)v12, v27, 0);
  }
  if (*(_QWORD *)(v12 + 80) != *(_QWORD *)(*(_QWORD *)(v12 + 16) + 24))
    xmlFatalErr((_DWORD *)v12, 85, 0);
  if (*(_DWORD *)(v12 + 24))
  {
    v28 = *(_QWORD *)(v12 + 16);
    if (v4)
    {
      v29 = *(_QWORD *)(*(_QWORD *)(v28 + 24) + 24);
      for (*(_QWORD *)v4 = v29; v29; v29 = *(_QWORD *)(v29 + 48))
      {
        if (*(_DWORD *)(a1 + 156))
        {
          if (*(_DWORD *)(a1 + 24))
          {
            v30 = *(xmlDoc **)(a1 + 16);
            if (v30)
            {
              if (v30->intSubset && *(_DWORD *)(v29 + 8) == 1)
                *(_DWORD *)(a1 + 152) &= xmlValidateElement((xmlValidCtxtPtr)(a1 + 160), v30, (xmlNodePtr)v29);
            }
          }
        }
        *(_QWORD *)(v29 + 40) = 0;
      }
      v4 = 0;
      v31 = *(xmlNode **)(*(_QWORD *)(v12 + 16) + 24);
      v31->children = 0;
      goto LABEL_56;
    }
  }
  else
  {
    v32 = *(_DWORD *)(v12 + 136);
    if (v32 <= 1)
      v4 = 1;
    else
      v4 = v32;
    v28 = *(_QWORD *)(v12 + 16);
  }
  if (v28)
  {
    v31 = *(xmlNode **)(v28 + 24);
LABEL_56:
    xmlFreeNode(v31);
    *(_OWORD *)(*(_QWORD *)(v12 + 16) + 24) = v34;
  }
  *(_QWORD *)(a1 + 696) += *(_QWORD *)(v12 + 696);
  if (*(_DWORD *)(v12 + 604))
    xmlCopyError((xmlErrorPtr)(v12 + 600), (xmlErrorPtr)(a1 + 600));
  *(_QWORD *)v12 = v17;
  *(_QWORD *)(v12 + 456) = 0;
  *(_QWORD *)(v12 + 544) = 0;
  *(_QWORD *)(v12 + 552) = 0;
  xmlFreeParserCtxt((xmlParserCtxtPtr)v12);
  if (v19)
    xmlFreeDoc(v19);
  return v4;
}

uint64_t xmlParseExternalEntityPrivate(uint64_t a1, uint64_t a2, _xmlSAXHandler *a3, void *a4, int a5, const xmlChar *a6, const char *a7, _xmlNode **a8)
{
  uint64_t v14;
  xmlParserCtxt *EntityParserCtxtInternal;
  uint64_t v16;
  _xmlSAXHandler *sax;
  xmlDocPtr v18;
  xmlDoc *v19;
  _xmlDtd **p_intSubset;
  xmlDict *v21;
  const xmlChar *v22;
  xmlNode *v23;
  xmlNode *v24;
  _DWORD *v25;
  xmlCharEncoding v26;
  _BYTE *v27;
  unsigned int v28;
  xmlDict *v29;
  xmlDict *v30;
  int v31;
  _BYTE *v32;
  int v33;
  _xmlNode *children;
  unsigned int v35;
  _QWORD *v36;
  unsigned __int8 in[4];

  if (a5 < 41 || (v14 = 89, a2) && a5 <= 0x400 && (*(_DWORD *)(a2 + 564) & 0x80000) != 0)
  {
    if (a8)
      *a8 = 0;
    v14 = 1;
    if (a1)
    {
      if ((unint64_t)a6 | (unint64_t)a7)
      {
        EntityParserCtxtInternal = xmlCreateEntityParserCtxtInternal(a6, a7, 0, a2);
        if (EntityParserCtxtInternal)
        {
          v16 = (uint64_t)EntityParserCtxtInternal;
          EntityParserCtxtInternal->userData = EntityParserCtxtInternal;
          if (a3)
          {
            sax = EntityParserCtxtInternal->sax;
            EntityParserCtxtInternal->sax = a3;
            if (a4)
              EntityParserCtxtInternal->userData = a4;
          }
          else
          {
            sax = 0;
          }
          xmlDetectSAX2((const xmlChar *)EntityParserCtxtInternal);
          v18 = xmlNewDoc((const xmlChar *)"1.0");
          if (v18)
          {
            v19 = v18;
            *(_OWORD *)&v18->intSubset = *(_OWORD *)(a1 + 80);
            p_intSubset = &v18->intSubset;
            v18->properties = 64;
            v21 = *(xmlDict **)(a1 + 152);
            if (v21)
            {
              v19->dict = v21;
              xmlDictReference(v21);
            }
            v22 = *(const xmlChar **)(a1 + 136);
            if (v22)
              v19->URL = xmlStrdup(v22);
            v23 = xmlNewDocNode(v19, 0, (const xmlChar *)"pseudoroot", 0);
            if (!v23)
            {
              if (a3)
                *(_QWORD *)v16 = sax;
              goto LABEL_77;
            }
            v24 = v23;
            xmlAddChild((xmlNodePtr)v19, v23);
            nodePush((xmlParserCtxtPtr)v16, v19->children);
            *(_QWORD *)(v16 + 16) = a1;
            v24->doc = (_xmlDoc *)a1;
            if (!*(_DWORD *)(v16 + 452)
              && (uint64_t)(*(_QWORD *)(*(_QWORD *)(v16 + 56) + 40) - *(_QWORD *)(*(_QWORD *)(v16 + 56) + 32)) <= 249)
            {
              xmlGROW(v16);
            }
            *(_DWORD *)in = 0;
            v25 = *(_DWORD **)(*(_QWORD *)(v16 + 56) + 32);
            if ((uint64_t)(*(_QWORD *)(*(_QWORD *)(v16 + 56) + 40) - (_QWORD)v25) >= 4)
            {
              *(_DWORD *)in = *v25;
              v26 = xmlDetectCharEncoding(in, 4);
              if (v26)
                xmlSwitchEncoding((xmlParserCtxtPtr)v16, v26);
            }
            v27 = *(_BYTE **)(*(_QWORD *)(v16 + 56) + 32);
            if (*v27 == 60
              && v27[1] == 63
              && v27[2] == 120
              && v27[3] == 109
              && v27[4] == 108
              && (v28 = v27[5], v28 <= 0x20)
              && ((1 << v28) & 0x100002600) != 0)
            {
              xmlParseTextDecl((xmlParserCtxtPtr)v16);
              if (xmlStrEqual(*(const xmlChar **)(a2 + 32), (const xmlChar *)"1.0")
                && !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v16 + 56) + 88), (const xmlChar *)"1.0"))
              {
                xmlFatalErrMsg((_DWORD *)v16, 109, (char)"Version mismatch between document and entity\n");
              }
              *(_DWORD *)(v16 + 272) = 7;
              *(_DWORD *)(v16 + 392) = a5;
            }
            else
            {
              *(_DWORD *)(v16 + 272) = 7;
              *(_DWORD *)(v16 + 392) = a5;
              if (!a2)
              {
                v31 = 0;
                *(_QWORD *)(v16 + 424) = 0;
                *(_DWORD *)(v16 + 156) = 0;
                *(_DWORD *)(v16 + 148) = 2;
                *(_DWORD *)(v16 + 432) = 0;
                goto LABEL_48;
              }
            }
            *(_QWORD *)(v16 + 424) = *(_QWORD *)(a2 + 424);
            *(_DWORD *)(v16 + 432) = *(_DWORD *)(a2 + 432);
            *(_QWORD *)(v16 + 152) = *(_QWORD *)(a2 + 152);
            *(_DWORD *)(v16 + 28) = *(_DWORD *)(a2 + 28);
            if (*(_DWORD *)(a2 + 156))
            {
              *(_QWORD *)(v16 + 176) = *(_QWORD *)(a2 + 176);
              *(_OWORD *)(v16 + 160) = *(_OWORD *)(a2 + 160);
              *(_DWORD *)(v16 + 208) = *(_DWORD *)(a2 + 208);
            }
            *(_DWORD *)(v16 + 148) = *(_DWORD *)(a2 + 148);
            v29 = *(xmlDict **)(v16 + 456);
            if (v29)
              xmlDictFree(v29);
            v30 = *(xmlDict **)(a2 + 456);
            *(_QWORD *)(v16 + 456) = v30;
            *(_QWORD *)(v16 + 480) = xmlDictLookup(v30, (const xmlChar *)"xml", 3);
            *(_QWORD *)(v16 + 488) = xmlDictLookup(*(xmlDictPtr *)(v16 + 456), (const xmlChar *)"xmlns", 5);
            *(_QWORD *)(v16 + 496) = xmlDictLookup(*(xmlDictPtr *)(v16 + 456), (const xmlChar *)"http://www.w3.org/XML/1998/namespace", 36);
            *(_DWORD *)(v16 + 568) = *(_DWORD *)(a2 + 568);
            *(_OWORD *)(v16 + 544) = *(_OWORD *)(a2 + 544);
            *(_DWORD *)(v16 + 436) = *(_DWORD *)(a2 + 436);
            *(_DWORD *)(v16 + 104) = *(_DWORD *)(a2 + 104);
            *(_OWORD *)(v16 + 112) = *(_OWORD *)(a2 + 112);
            *(_QWORD *)(v16 + 128) = *(_QWORD *)(a2 + 128);
            v31 = 1;
LABEL_48:
            xmlParseContent((xmlParserCtxtPtr)v16);
            v32 = *(_BYTE **)(*(_QWORD *)(v16 + 56) + 32);
            if (*v32)
            {
              if (*v32 == 60 && v32[1] == 47)
                v33 = 85;
              else
                v33 = 86;
              xmlFatalErr((_DWORD *)v16, v33, 0);
            }
            if (*(_xmlNode **)(v16 + 80) != v19->children)
              xmlFatalErr((_DWORD *)v16, 85, 0);
            if (*(_DWORD *)(v16 + 24))
            {
              if (a8)
              {
                children = v19->children->children;
                for (*a8 = children; children; children = children->next)
                  children->parent = 0;
                v14 = 0;
                v19->children->children = 0;
                if (!v31)
                  goto LABEL_72;
                goto LABEL_68;
              }
              v14 = 0;
              if (v31)
              {
LABEL_68:
                *(_QWORD *)(a2 + 696) += *(_QWORD *)(v16 + 696);
                v36 = *(_QWORD **)(v16 + 56);
                if (v36)
                  *(_QWORD *)(a2 + 704) = *(_QWORD *)(a2 + 704) + v36[8] + v36[4] - v36[3];
                if (*(_DWORD *)(v16 + 604))
                  xmlCopyError((xmlErrorPtr)(v16 + 600), (xmlErrorPtr)(a2 + 600));
              }
            }
            else
            {
              v35 = *(_DWORD *)(v16 + 136);
              if (v35 <= 1)
                v14 = 1;
              else
                v14 = v35;
              if (v31)
                goto LABEL_68;
            }
LABEL_72:
            if (a3)
              *(_QWORD *)v16 = sax;
            if (v31)
            {
              *(_QWORD *)(v16 + 456) = 0;
              *(_OWORD *)(v16 + 544) = 0u;
              *(_QWORD *)(a2 + 152) = *(_QWORD *)(v16 + 152);
              *(_OWORD *)(a2 + 112) = *(_OWORD *)(v16 + 112);
              *(_QWORD *)(a2 + 128) = *(_QWORD *)(v16 + 128);
            }
            *(_QWORD *)(v16 + 112) = 0;
            *(_QWORD *)(v16 + 120) = 0;
            *(_QWORD *)(v16 + 128) = 0;
LABEL_77:
            xmlFreeParserCtxt((xmlParserCtxtPtr)v16);
            *p_intSubset = 0;
            p_intSubset[1] = 0;
            xmlFreeDoc(v19);
            return v14;
          }
          xmlFreeParserCtxt((xmlParserCtxtPtr)v16);
        }
        else
        {
          return 27;
        }
      }
    }
  }
  return v14;
}

void xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input;
  const xmlChar *cur;
  const xmlChar *v4;
  xmlChar *v5;
  xmlChar *v6;
  xmlChar *v7;
  internalSubsetSAXFunc internalSubset;
  int v9;
  xmlChar *publicID;

  publicID = 0;
  input = ctxt->input;
  cur = input->cur;
  input->cur = cur + 9;
  input->col += 9;
  if (!cur[9])
    xmlParserInputGrow(input, 250);
  xmlSkipBlankChars(ctxt);
  v4 = xmlParseName(ctxt);
  if (!v4)
    xmlFatalErrMsg(ctxt, 68, (char)"xmlParseDocTypeDecl : no DOCTYPE name !\n");
  ctxt->intSubName = v4;
  xmlSkipBlankChars(ctxt);
  v5 = xmlParseExternalID(ctxt, &publicID, 1);
  v6 = v5;
  v7 = publicID;
  if ((unint64_t)v5 | (unint64_t)publicID)
    ctxt->hasExternalSubset = 1;
  ctxt->extSubURI = v5;
  ctxt->extSubSystem = v7;
  xmlSkipBlankChars(ctxt);
  if (ctxt->sax)
  {
    internalSubset = ctxt->sax->internalSubset;
    if (internalSubset)
    {
      if (!ctxt->disableSAX)
        ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))internalSubset)(ctxt->userData, v4, v7, v6);
    }
  }
  if (ctxt->instate != XML_PARSER_EOF)
  {
    v9 = *ctxt->input->cur;
    if (v9 != 62)
    {
      if (v9 == 91)
        return;
      xmlFatalErr(ctxt, 61, 0);
    }
    xmlNextChar(ctxt);
  }
}

const xmlChar *__cdecl xmlParseAttribute(xmlParserCtxtPtr ctxt, xmlChar **value)
{
  const xmlChar *v4;
  xmlChar *v5;

  *value = 0;
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  v4 = xmlParseName(ctxt);
  if (v4)
  {
    xmlSkipBlankChars(ctxt);
    if (*ctxt->input->cur == 61)
    {
      xmlNextChar(ctxt);
      xmlSkipBlankChars(ctxt);
      if (ctxt->input)
        v5 = xmlParseAttValueInternal((uint64_t)ctxt, 0, 0, 0);
      else
        v5 = 0;
      ctxt->instate = XML_PARSER_CONTENT;
      if (ctxt->pedantic && xmlStrEqual(v4, (const xmlChar *)"xml:lang") && !xmlCheckLanguageID(v5))
        xmlWarningMsg(ctxt, 98, "Malformed value for xml:lang : %s\n", v5);
      if (xmlStrEqual(v4, (const xmlChar *)"xml:space"))
      {
        if (xmlStrEqual(v5, (const xmlChar *)"default"))
        {
          *ctxt->space = 0;
        }
        else if (xmlStrEqual(v5, (const xmlChar *)"preserve"))
        {
          *ctxt->space = 1;
        }
        else
        {
          xmlWarningMsg(ctxt, 102, "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n", v5);
        }
      }
      *value = v5;
    }
    else
    {
      xmlFatalErrMsgStr(ctxt, 41, "Specification mandates value for attribute %s\n", v4);
      return 0;
    }
  }
  else
  {
    xmlFatalErrMsg(ctxt, 68, (char)"error parsing attribute name\n");
  }
  return v4;
}

_DWORD *xmlErrAttributeDup(_DWORD *result, const xmlChar *a2, xmlChar *a3)
{
  _DWORD *v3;

  v3 = result;
  if (result)
  {
    if (result[83] && result[68] == -1)
      return result;
    result[34] = 42;
  }
  if (a2)
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, 42, 3, 0, 0, a2, a3, 0, 0, 0, "Attribute %s:%s redefined\n", (char)a2);
  else
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, 42, 3, 0, 0, a3, 0, 0, 0, 0, "Attribute %s redefined\n", (char)a3);
  if (v3)
  {
    v3[6] = 0;
    if (!v3[112])
      v3[83] = 1;
  }
  return result;
}

xmlParserInput *xmlParseEndTag1(xmlParserCtxt *a1)
{
  xmlParserInput *input;
  const xmlChar *cur;
  uint64_t v4;
  xmlParserInput *result;
  const xmlChar *v6;
  xmlChar *v7;
  uint64_t (*endElement)(void *, const xmlChar *);
  int nameNr;
  unsigned int v10;
  const xmlChar **nameTab;
  const xmlChar *v12;
  int spaceNr;
  unsigned int v14;
  unsigned int v15;
  int *spaceTab;

  if (!a1->progressive && a1->input->end - a1->input->cur <= 249)
    xmlGROW((uint64_t)a1);
  input = a1->input;
  cur = input->cur;
  if (*cur != 60 || cur[1] != 47)
    return (xmlParserInput *)xmlFatalErrMsg(a1, 74, (char)"xmlParseEndTag: '</' not found\n");
  input->cur = cur + 2;
  input->col += 2;
  if (!cur[2])
    xmlParserInputGrow(input, 250);
  v4 = xmlParseNameAndCompare((uint64_t)a1, (unsigned __int8 *)a1->name);
  if (!a1->progressive && a1->input->end - a1->input->cur <= 249)
    xmlGROW((uint64_t)a1);
  xmlSkipBlankChars(a1);
  result = a1->input;
  v6 = result->cur;
  if (*v6 == 62)
  {
    ++result->col;
    result->cur = v6 + 1;
    if (!v6[1])
      result = (xmlParserInput *)xmlParserInputGrow(result, 250);
  }
  else
  {
    result = (xmlParserInput *)xmlFatalErr(a1, 73, 0);
  }
  if (v4 != 1)
  {
    if (v4)
      v7 = (xmlChar *)v4;
    else
      v7 = (xmlChar *)"unparsable";
    result = (xmlParserInput *)xmlFatalErrMsgStrIntStr(a1, 76, "Opening and ending tag mismatch: %s line %d and %s\n", a1->name, 0, v7);
  }
  if (a1->sax)
  {
    endElement = (uint64_t (*)(void *, const xmlChar *))a1->sax->endElement;
    if (endElement)
    {
      if (!a1->disableSAX)
        result = (xmlParserInput *)endElement(a1->userData, a1->name);
    }
  }
  nameNr = a1->nameNr;
  v10 = nameNr - 1;
  if (nameNr >= 1)
  {
    a1->nameNr = v10;
    nameTab = a1->nameTab;
    if (nameNr == 1)
      v12 = 0;
    else
      v12 = nameTab[nameNr - 2];
    a1->name = v12;
    nameTab[v10] = 0;
  }
  spaceNr = a1->spaceNr;
  if (spaceNr >= 1)
  {
    v14 = spaceNr - 2;
    v15 = spaceNr - 1;
    a1->spaceNr = v15;
    spaceTab = a1->spaceTab;
    if (!v15)
      v14 = 0;
    a1->space = &spaceTab[v14];
    spaceTab[v15] = -1;
  }
  return result;
}

void xmlParseCDSect(xmlParserCtxtPtr ctxt)
{
  int v2;
  xmlParserInputPtr input;
  const xmlChar *cur;
  int v5;
  int v6;
  xmlParserInputPtr v7;
  const xmlChar *v8;
  const xmlChar *v9;
  int v10;
  int v11;
  xmlParserInputPtr v12;
  const xmlChar *v13;
  const xmlChar *v14;
  int v15;
  xmlChar *v16;
  xmlChar *v17;
  uint64_t v18;
  int v19;
  int v20;
  xmlChar *v21;
  int v22;
  int v23;
  xmlParserInputPtr v24;
  const xmlChar *v25;
  xmlParserInputPtr v26;
  const xmlChar *v27;
  const xmlChar *v28;
  int v29;
  xmlParserInputPtr v30;
  const xmlChar *v31;
  const xmlChar *v32;
  _xmlSAXHandler *sax;
  void (*cdataBlock)(void *, xmlChar *, uint64_t);
  int v35;
  int len[2];

  *(_QWORD *)len = 0;
  v35 = 0;
  if ((ctxt->options & 0x80000) != 0)
    v2 = 1000000000;
  else
    v2 = 10000000;
  input = ctxt->input;
  cur = input->cur;
  if (*cur == 60
    && cur[1] == 33
    && cur[2] == 91
    && cur[3] == 67
    && cur[4] == 68
    && cur[5] == 65
    && cur[6] == 84
    && cur[7] == 65
    && cur[8] == 91)
  {
    input->cur = cur + 9;
    input->col += 9;
    if (!cur[9])
      xmlParserInputGrow(input, 250);
    ctxt->instate = XML_PARSER_CDATA_SECTION;
    v5 = xmlCurrentChar(ctxt, &len[1]);
    v6 = v5;
    if (v5 > 255)
    {
      if ((v5 - 0x10000) >= 0x100000
        && v5 >> 11 >= 0x1B
        && (v5 - 57344) >> 1 >= 0xFFF)
      {
        goto LABEL_36;
      }
    }
    else if (v5 <= 31 && (v5 > 0xD || ((1 << v5) & 0x2600) == 0))
    {
      goto LABEL_36;
    }
    v7 = ctxt->input;
    v8 = v7->cur;
    v9 = &v8[len[1]];
    if (v9 <= v7->end)
    {
      if (*v8 == 10)
      {
        ++v7->line;
        v7->col = 1;
      }
      else
      {
        ++v7->col;
      }
      v7->cur = v9;
    }
    v10 = xmlCurrentChar(ctxt, len);
    v11 = v10;
    if (v10 > 255)
    {
      if ((v10 - 0x10000) >= 0x100000
        && v10 >> 11 >= 0x1B
        && (v10 - 57344) >> 1 >= 0xFFF)
      {
        goto LABEL_36;
      }
    }
    else if (v10 <= 31 && (v10 > 0xD || ((1 << v10) & 0x2600) == 0))
    {
LABEL_36:
      xmlFatalErr(ctxt, 63, 0);
      ctxt->instate = XML_PARSER_CONTENT;
      return;
    }
    v12 = ctxt->input;
    v13 = v12->cur;
    v14 = &v13[len[0]];
    if (v14 <= v12->end)
    {
      if (*v13 == 10)
      {
        ++v12->line;
        v12->col = 1;
      }
      else
      {
        ++v12->col;
      }
      v12->cur = v14;
    }
    v15 = xmlCurrentChar(ctxt, &v35);
    v16 = (xmlChar *)xmlMallocAtomic(0x64uLL);
    if (v16)
    {
      v17 = v16;
      v18 = 0;
      v19 = 0;
      v20 = 100;
      while (1)
      {
        if (v15 > 255)
        {
          if ((v15 - 0x10000) >= 0x100000
            && v15 >> 11 >= 0x1B
            && (v15 - 57344) >> 1 >= 0xFFF)
          {
LABEL_79:
            v17[(int)v18] = 0;
            ctxt->instate = XML_PARSER_CONTENT;
            xmlFatalErrMsgStr(ctxt, 63, "CData section not finished\n%.50s\n", v17);
            goto LABEL_80;
          }
        }
        else if (v15 <= 31)
        {
          if (v15 > 0xD || ((1 << v15) & 0x2600) == 0)
            goto LABEL_79;
        }
        else if (v6 == 93 && v11 == 93 && v15 == 62)
        {
          v17[(int)v18] = 0;
          ctxt->instate = XML_PARSER_CONTENT;
          v30 = ctxt->input;
          v31 = v30->cur;
          v32 = &v31[v35];
          if (v32 <= v30->end)
          {
            if (*v31 == 10)
            {
              ++v30->line;
              v30->col = 1;
            }
            else
            {
              ++v30->col;
            }
            v30->cur = v32;
          }
          sax = ctxt->sax;
          if (ctxt->sax)
          {
            if (!ctxt->disableSAX)
            {
              cdataBlock = (void (*)(void *, xmlChar *, uint64_t))sax->cdataBlock;
              if (cdataBlock || (cdataBlock = (void (*)(void *, xmlChar *, uint64_t))sax->characters) != 0)
                cdataBlock(ctxt->userData, v17, v18);
            }
          }
          goto LABEL_80;
        }
        if ((int)v18 + 5 >= v20)
        {
          v20 *= 2;
          v21 = (xmlChar *)xmlRealloc(v17, v20);
          if (!v21)
          {
            xmlFree(v17);
            break;
          }
          v17 = v21;
        }
        if (len[1] == 1)
        {
          v17[(int)v18] = v6;
          v18 = (v18 + 1);
        }
        else
        {
          v18 = (xmlCopyCharMultiByte(&v17[(int)v18], v6) + v18);
        }
        v23 = v35;
        v22 = len[0];
        len[0] = v35;
        len[1] = v22;
        if (v19 < 50)
        {
          ++v19;
        }
        else
        {
          if (!ctxt->progressive)
          {
            v24 = ctxt->input;
            v25 = v24->cur;
            if (v25 - v24->base < 501 || v24->end - v25 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
            {
              if (ctxt->input->end - ctxt->input->cur <= 249)
                xmlGROW((uint64_t)ctxt);
            }
          }
          if (ctxt->instate == XML_PARSER_EOF)
            goto LABEL_80;
          v19 = 0;
          v23 = v35;
        }
        v26 = ctxt->input;
        v27 = v26->cur;
        v28 = &v27[v23];
        if (v28 <= v26->end)
        {
          if (*v27 == 10)
          {
            ++v26->line;
            v29 = 1;
          }
          else
          {
            v29 = v26->col + 1;
          }
          v26->col = v29;
          v26->cur = v28;
        }
        v6 = v11;
        v11 = v15;
        v15 = xmlCurrentChar(ctxt, &v35);
        if ((int)v18 > v2)
        {
          xmlFatalErrMsg(ctxt, 63, (char)"CData section too big found\n");
LABEL_80:
          xmlFree(v17);
          return;
        }
      }
    }
    htmlErrMemory(ctxt, 0);
  }
}

void xmlParseContent(xmlParserCtxtPtr ctxt)
{
  int nameNr;
  int v3;

  nameNr = ctxt->nameNr;
  xmlParseContentInternal((int)ctxt);
  if (ctxt->instate != XML_PARSER_EOF)
  {
    v3 = ctxt->nameNr;
    if (v3 > nameNr)
      xmlFatalErrMsgStrIntStr(ctxt, 77, "Premature end of data in tag %s line %d\n", ctxt->nameTab[v3 - 1], *((_DWORD *)ctxt->pushTab + 6 * v3 - 2), 0);
  }
}

_DWORD *xmlFatalErrMsgStrIntStr(_DWORD *result, int a2, const char *a3, const xmlChar *a4, int a5, xmlChar *cur)
{
  _DWORD *v6;

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 3, 0, 0, a4, cur, 0, a5, 0, a3, (char)a4);
  v6 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, a4, cur, 0, a5, 0, a3, (char)a4);
    v6[6] = 0;
    if (!v6[112])
      v6[83] = 1;
  }
  return result;
}

void xmlParseInternalSubset(uint64_t a1)
{
  int v2;
  int v3;
  uint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  _QWORD *v7;
  _BYTE *v8;

  v2 = **(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
  if (v2 == 91)
  {
    v3 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 272) = 3;
    xmlNextChar((xmlParserCtxtPtr)a1);
    while (1)
    {
      v4 = *(_QWORD *)(a1 + 56);
      v5 = *(unsigned __int8 **)(v4 + 32);
      v2 = *v5;
      if (v2 == 93 && *(_DWORD *)(a1 + 64) <= v3)
        break;
      if (*(_DWORD *)(a1 + 272) == -1)
        goto LABEL_17;
      v6 = *(unsigned int *)(v4 + 64);
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      xmlParseMarkupDecl((xmlParserCtxtPtr)a1);
      xmlParsePEReference((xmlParserCtxtPtr)a1);
      v7 = *(_QWORD **)(a1 + 56);
      if (*(int *)(a1 + 64) >= 2)
      {
        if (v7[1])
        {
          v8 = (_BYTE *)v7[4];
          if (*v8 == 60 && v8[1] == 33 && v8[2] == 91)
          {
            xmlParseConditionalSections(a1);
            v7 = *(_QWORD **)(a1 + 56);
          }
        }
      }
      if ((unsigned __int8 *)v7[4] == v5 && v6 == v7[8])
      {
        xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"xmlParseInternalSubset: error detected in Markup declaration\n");
        if (*(_DWORD *)(a1 + 64) <= v3)
        {
          v2 = **(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
LABEL_17:
          if (v2 != 93)
            goto LABEL_19;
          break;
        }
        xmlPopInput((xmlParserCtxtPtr)a1);
      }
    }
    xmlNextChar((xmlParserCtxtPtr)a1);
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    v2 = **(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 32);
  }
LABEL_19:
  if (v2 == 62)
    xmlNextChar((xmlParserCtxtPtr)a1);
  else
    xmlFatalErr((_DWORD *)a1, 61, 0);
}

void xmlCleanSpecialAttr(void *data)
{
  xmlHashTable *v2;

  v2 = (xmlHashTable *)*((_QWORD *)data + 69);
  if (v2)
  {
    xmlHashScanFull(v2, (xmlHashScannerFull)xmlCleanSpecialAttrCallback, data);
    if (!xmlHashSize(*((xmlHashTablePtr *)data + 69)))
    {
      xmlHashFree(*((xmlHashTablePtr *)data + 69), 0);
      *((_QWORD *)data + 69) = 0;
    }
  }
}

int xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt)
{
  setDocumentLocatorSAXFunc setDocumentLocator;
  void *userData;
  xmlSAXLocator *v4;
  const xmlChar *cur;
  xmlCharEncoding v6;
  xmlParserInputPtr input;
  const xmlChar *v8;
  unsigned int v9;
  startDocumentSAXFunc startDocument;
  const xmlChar *v11;
  int v12;
  endDocumentSAXFunc endDocument;
  unsigned __int8 in[4];

  if (!ctxt)
    return -1;
  if (!ctxt->input)
    return -1;
  xmlDefaultSAXHandlerInit();
  xmlDetectSAX2((const xmlChar *)ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249)
    xmlGROW((uint64_t)ctxt);
  if (ctxt->sax)
  {
    setDocumentLocator = ctxt->sax->setDocumentLocator;
    if (setDocumentLocator)
    {
      userData = ctxt->userData;
      v4 = __xmlDefaultSAXLocator();
      ((void (*)(void *, xmlSAXLocator *))setDocumentLocator)(userData, v4);
    }
  }
  *(_DWORD *)in = 0;
  cur = ctxt->input->cur;
  if (ctxt->input->end - cur >= 4)
  {
    *(_DWORD *)in = *(_DWORD *)cur;
    v6 = xmlDetectCharEncoding(in, 4);
    if (v6)
      xmlSwitchEncoding(ctxt, v6);
  }
  input = ctxt->input;
  if (!*input->cur)
  {
    xmlFatalErr(ctxt, 4, 0);
    input = ctxt->input;
  }
  if (!ctxt->progressive && input->end - input->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    input = ctxt->input;
  }
  v8 = input->cur;
  if (*v8 != 60
    || v8[1] != 63
    || v8[2] != 120
    || v8[3] != 109
    || v8[4] != 108
    || (v9 = v8[5], v9 > 0x20)
    || ((1 << v9) & 0x100002600) == 0)
  {
    ctxt->version = xmlCharStrdup("1.0");
    goto LABEL_27;
  }
  xmlParseXMLDecl(ctxt);
  if (ctxt->errNo == 32)
    return -1;
  xmlSkipBlankChars(ctxt);
LABEL_27:
  if (ctxt->sax)
  {
    startDocument = ctxt->sax->startDocument;
    if (startDocument)
    {
      if (!ctxt->disableSAX)
        ((void (*)(void *))startDocument)(ctxt->userData);
    }
  }
  if (ctxt->instate == XML_PARSER_EOF)
    return -1;
  ctxt->instate = XML_PARSER_CONTENT;
  ctxt->validate = 0;
  ctxt->loadsubset = 0;
  ctxt->depth = 0;
  xmlParseContent(ctxt);
  if (ctxt->instate == XML_PARSER_EOF)
    return -1;
  v11 = ctxt->input->cur;
  if (*v11)
  {
    if (*v11 == 60 && v11[1] == 47)
      v12 = 85;
    else
      v12 = 86;
    xmlFatalErr(ctxt, v12, 0);
  }
  if (ctxt->sax)
  {
    endDocument = ctxt->sax->endDocument;
    if (endDocument)
      ((void (*)(void *))endDocument)(ctxt->userData);
  }
  if (ctxt->wellFormed)
    return 0;
  else
    return -1;
}

xmlParserCtxtPtr xmlCreateIOParserCtxt(xmlSAXHandlerPtr sax, void *user_data, xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, xmlCharEncoding enc)
{
  xmlParserCtxt *v8;
  xmlParserInputBufferPtr IO;
  xmlParserInputBuffer *v12;
  xmlParserCtxtPtr v13;
  xmlSAXHandlerV1 *v14;
  _xmlSAXHandler *v15;
  size_t v16;
  xmlParserInput *v17;

  if (!ioread)
    return 0;
  v8 = (xmlParserCtxt *)ioclose;
  IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, enc);
  if (!IO)
  {
    if (!v8)
      return v8;
    ((void (*)(void *))v8)(ioctx);
    return 0;
  }
  v12 = IO;
  v13 = xmlNewParserCtxt();
  v8 = v13;
  if (!v13)
  {
    xmlFreeParserInputBuffer(v12);
    return v8;
  }
  if (sax)
  {
    v14 = (xmlSAXHandlerV1 *)v13->sax;
    if (v14 != __xmlDefaultSAXHandler())
      xmlFree(v8->sax);
    v15 = (_xmlSAXHandler *)xmlMalloc(0x100uLL);
    v8->sax = v15;
    if (!v15)
    {
      xmlFreeParserInputBuffer(v12);
      htmlErrMemory(v8, 0);
      goto LABEL_19;
    }
    *(_OWORD *)&v15->_private = 0u;
    *(_OWORD *)&v15->endElementNs = 0u;
    *(_OWORD *)&v15->getParameterEntity = 0u;
    *(_OWORD *)&v15->externalSubset = 0u;
    *(_OWORD *)&v15->comment = 0u;
    *(_OWORD *)&v15->error = 0u;
    *(_OWORD *)&v15->reference = 0u;
    *(_OWORD *)&v15->ignorableWhitespace = 0u;
    *(_OWORD *)&v15->startDocument = 0u;
    *(_OWORD *)&v15->startElement = 0u;
    *(_OWORD *)&v15->attributeDecl = 0u;
    *(_OWORD *)&v15->unparsedEntityDecl = 0u;
    *(_OWORD *)&v15->resolveEntity = 0u;
    *(_OWORD *)&v15->entityDecl = 0u;
    *(_OWORD *)&v15->internalSubset = 0u;
    *(_OWORD *)&v15->hasInternalSubset = 0u;
    if (sax->initialized == -554844497)
      v16 = 256;
    else
      v16 = 224;
    memcpy(v8->sax, sax, v16);
    if (user_data)
      v8->userData = user_data;
  }
  v17 = xmlNewIOInputStream(v8, v12, enc);
  if (!v17)
  {
LABEL_19:
    xmlFreeParserCtxt(v8);
    return 0;
  }
  inputPush(v8, v17);
  return v8;
}

xmlDtdPtr xmlIOParseDTD(xmlSAXHandlerPtr sax, xmlParserInputBufferPtr input, xmlCharEncoding enc)
{
  xmlParserCtxtPtr v6;
  xmlParserCtxtPtr v7;
  _xmlSAXHandler *v8;
  xmlParserInput *v9;
  xmlParserInput *v10;
  const xmlChar *cur;
  xmlDocPtr v12;
  const xmlChar *v13;
  xmlCharEncoding v14;
  xmlDoc *myDoc;
  xmlDtd *extSubset;
  _xmlNode *i;
  unsigned __int8 in[4];

  if (!input)
    return 0;
  v6 = xmlNewParserCtxt();
  if (!v6)
  {
    xmlFreeParserInputBuffer(input);
    return 0;
  }
  v7 = v6;
  v6->options |= 4u;
  if (sax)
  {
    v8 = v6->sax;
    if (v7->sax)
      xmlFree(v8);
    v7->sax = sax;
    v7->userData = v7;
  }
  xmlDetectSAX2((const xmlChar *)v7);
  v9 = xmlNewIOInputStream(v7, input, XML_CHAR_ENCODING_NONE);
  if (!v9)
  {
    if (sax)
      v7->sax = 0;
    xmlFreeParserInputBuffer(input);
    goto LABEL_28;
  }
  v10 = v9;
  if (xmlPushInput(v7, v9) < 0)
  {
    if (sax)
      v7->sax = 0;
LABEL_28:
    xmlFreeParserCtxt(v7);
    return 0;
  }
  if (enc)
    xmlSwitchEncoding(v7, enc);
  v10->filename = 0;
  *(_QWORD *)&v10->line = 0x100000001;
  cur = v7->input->cur;
  v10->base = cur;
  v10->cur = cur;
  v10->free = 0;
  v7->inSubset = 2;
  v12 = xmlNewDoc((const xmlChar *)"1.0");
  v7->myDoc = v12;
  if (!v12)
  {
    htmlErrMemory(v7, (const xmlChar *)"New Doc failed");
    return 0;
  }
  *(_DWORD *)in = 0;
  v12->properties = 64;
  v7->myDoc->extSubset = xmlNewDtd(v12, (const xmlChar *)"none", (const xmlChar *)"none", (const xmlChar *)"none");
  if (enc == XML_CHAR_ENCODING_NONE)
  {
    v13 = v7->input->cur;
    if (v7->input->end - v13 >= 4)
    {
      *(_DWORD *)in = *(_DWORD *)v13;
      v14 = xmlDetectCharEncoding(in, 4);
      if (v14)
        xmlSwitchEncoding(v7, v14);
    }
  }
  xmlParseExternalSubset(v7, (const xmlChar *)"none", (const xmlChar *)"none");
  myDoc = v7->myDoc;
  if (myDoc)
  {
    if (v7->wellFormed)
    {
      extSubset = myDoc->extSubset;
      myDoc->extSubset = 0;
      if (extSubset)
      {
        extSubset->doc = 0;
        for (i = extSubset->children; i; i = i->next)
          i->doc = 0;
      }
    }
    else
    {
      extSubset = 0;
    }
    xmlFreeDoc(myDoc);
    v7->myDoc = 0;
  }
  else
  {
    extSubset = 0;
  }
  if (sax)
    v7->sax = 0;
  xmlFreeParserCtxt(v7);
  return extSubset;
}

xmlDtdPtr xmlSAXParseDTD(xmlSAXHandlerPtr sax, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  xmlParserCtxtPtr v6;
  xmlParserCtxt *v7;
  _xmlSAXHandler *v8;
  xmlChar *v9;
  xmlChar *v10;
  uint64_t (*resolveEntity)(void *, const xmlChar *, xmlChar *);
  xmlParserInput *v12;
  xmlParserInput *v13;
  xmlParserInputPtr input;
  const unsigned __int8 *cur;
  xmlCharEncoding v16;
  xmlDtd *extSubset;
  const xmlChar *v19;
  xmlDocPtr v20;
  xmlDoc *myDoc;
  _xmlNode *i;

  if (!((unint64_t)ExternalID | (unint64_t)SystemID))
    return 0;
  v6 = xmlNewParserCtxt();
  if (!v6)
    return 0;
  v7 = v6;
  v6->options |= 4u;
  if (sax)
  {
    v8 = v6->sax;
    if (v7->sax)
      xmlFree(v8);
    v7->sax = sax;
    v7->userData = v7;
  }
  v9 = xmlCanonicPath(SystemID);
  v10 = v9;
  if (SystemID && !v9)
  {
LABEL_9:
    xmlFreeParserCtxt(v7);
    return 0;
  }
  if (!v7->sax
    || (resolveEntity = (uint64_t (*)(void *, const xmlChar *, xmlChar *))v7->sax->resolveEntity) == 0
    || (v12 = (xmlParserInput *)resolveEntity(v7->userData, ExternalID, v9)) == 0
    || (v13 = v12, xmlPushInput(v7, v12) < 0))
  {
    if (sax)
      v7->sax = 0;
    xmlFreeParserCtxt(v7);
    if (v10)
      xmlFree(v10);
    return 0;
  }
  input = v7->input;
  cur = input->cur;
  if (input->end - cur >= 4)
  {
    v16 = xmlDetectCharEncoding(cur, 4);
    xmlSwitchEncoding(v7, v16);
  }
  if (v13->filename)
    xmlFree(v10);
  else
    v13->filename = (const char *)v10;
  *(_QWORD *)&v13->line = 0x100000001;
  v19 = v7->input->cur;
  v13->base = v19;
  v13->cur = v19;
  v13->free = 0;
  v7->inSubset = 2;
  v20 = xmlNewDoc((const xmlChar *)"1.0");
  v7->myDoc = v20;
  if (!v20)
  {
    htmlErrMemory(v7, (const xmlChar *)"New Doc failed");
    if (sax)
      v7->sax = 0;
    goto LABEL_9;
  }
  v20->properties = 64;
  v7->myDoc->extSubset = xmlNewDtd(v20, (const xmlChar *)"none", ExternalID, SystemID);
  xmlParseExternalSubset(v7, ExternalID, SystemID);
  myDoc = v7->myDoc;
  if (myDoc)
  {
    if (v7->wellFormed)
    {
      extSubset = myDoc->extSubset;
      myDoc->extSubset = 0;
      if (extSubset)
      {
        extSubset->doc = 0;
        for (i = extSubset->children; i; i = i->next)
          i->doc = 0;
      }
    }
    else
    {
      extSubset = 0;
    }
    xmlFreeDoc(myDoc);
    v7->myDoc = 0;
  }
  else
  {
    extSubset = 0;
  }
  if (sax)
    v7->sax = 0;
  xmlFreeParserCtxt(v7);
  return extSubset;
}

xmlDtdPtr xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID)
{
  return xmlSAXParseDTD(0, ExternalID, SystemID);
}

int xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst)
{
  void *userData;

  if (!ctx)
    return -1;
  if (ctx->userData == ctx)
    userData = 0;
  else
    userData = ctx->userData;
  return xmlParseExternalEntityPrivate((uint64_t)ctx->myDoc, (uint64_t)ctx, ctx->sax, userData, ctx->depth + 1, URL, (const char *)ID, lst);
}

int xmlParseExternalEntity(xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst)
{
  return xmlParseExternalEntityPrivate((uint64_t)doc, 0, sax, user_data, depth, URL, (const char *)ID, lst);
}

int xmlParseBalancedChunkMemory(xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst)
{
  return xmlParseBalancedChunkMemoryRecover(doc, sax, user_data, depth, string, lst, 0);
}

int xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst, int recover)
{
  int errNo;
  int v15;
  xmlParserCtxtPtr MemoryParserCtxt;
  xmlParserCtxtPtr v17;
  _xmlSAXHandler *v18;
  xmlDocPtr v19;
  xmlDocPtr v20;
  _xmlDict *dict;
  xmlNode *v22;
  xmlNode *v23;
  _xmlNode *children;
  const xmlChar *cur;
  int v27;
  xmlNode *v28;

  if (depth > 40)
    return 89;
  if (lst)
    *lst = 0;
  if (!string)
    return -1;
  v15 = xmlStrlen(string);
  MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)string, v15);
  if (!MemoryParserCtxt)
    return -1;
  v17 = MemoryParserCtxt;
  MemoryParserCtxt->userData = MemoryParserCtxt;
  if (sax)
  {
    v18 = MemoryParserCtxt->sax;
    MemoryParserCtxt->sax = sax;
    if (user_data)
      MemoryParserCtxt->userData = user_data;
  }
  else
  {
    v18 = 0;
  }
  v19 = xmlNewDoc((const xmlChar *)"1.0");
  if (!v19)
  {
    xmlFreeParserCtxt(v17);
    return -1;
  }
  v20 = v19;
  v19->properties = 64;
  if (doc && doc->dict)
  {
    xmlDictFree(v17->dict);
    dict = doc->dict;
    v17->dict = dict;
    xmlDictReference(dict);
    v17->str_xml = xmlDictLookup(v17->dict, (const xmlChar *)"xml", 3);
    v17->str_xmlns = xmlDictLookup(v17->dict, (const xmlChar *)"xmlns", 5);
    v17->str_xml_ns = xmlDictLookup(v17->dict, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", 36);
    v17->dictNames = 1;
  }
  else
  {
    v17->recovery = 0;
    v17->replaceEntities = 0;
    v17->pedantic = 0;
    v17->keepBlanks = 1;
    v17->validate = 0;
    v17->options |= 0x1000u;
    v17->dictNames = 0;
    *(_QWORD *)&v17->loadsubset = 0x100000000;
    if (!doc)
      goto LABEL_18;
  }
  *(_OWORD *)&v20->intSubset = *(_OWORD *)&doc->intSubset;
LABEL_18:
  v22 = xmlNewDocNode(v20, 0, (const xmlChar *)"pseudoroot", 0);
  if (!v22)
  {
    if (sax)
      v17->sax = v18;
    xmlFreeParserCtxt(v17);
    v20->intSubset = 0;
    v20->extSubset = 0;
    xmlFreeDoc(v20);
    return -1;
  }
  v23 = v22;
  xmlAddChild((xmlNodePtr)v20, v22);
  nodePush(v17, v23);
  v17->myDoc = v20;
  if (doc)
  {
    v20->children->doc = doc;
    xmlSearchNsByHref(doc, (xmlNodePtr)doc, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
    v20->oldNs = doc->oldNs;
  }
  v17->instate = XML_PARSER_CONTENT;
  v17->input_id = 2;
  v17->depth = depth;
  v17->validate = 0;
  v17->loadsubset = 0;
  xmlDetectSAX2((const xmlChar *)v17);
  if (doc)
  {
    children = doc->children;
    doc->children = 0;
    xmlParseContent(v17);
    doc->children = children;
  }
  else
  {
    xmlParseContent(v17);
  }
  cur = v17->input->cur;
  if (*cur)
  {
    if (*cur == 60 && cur[1] == 47)
      v27 = 85;
    else
      v27 = 86;
    xmlFatalErr(v17, v27, 0);
  }
  if (v17->node != v20->children)
    xmlFatalErr(v17, 85, 0);
  if (v17->wellFormed)
  {
    errNo = 0;
    if (!lst)
      goto LABEL_49;
LABEL_44:
    if (recover == 1 || !errNo)
    {
      v28 = v20->children->children;
      for (*lst = v28; v28; v28 = v28->next)
      {
        xmlSetTreeDoc(v28, doc);
        v28->parent = 0;
      }
      v20->children->children = 0;
    }
    goto LABEL_49;
  }
  if (v17->errNo <= 1u)
    errNo = 1;
  else
    errNo = v17->errNo;
  if (lst)
    goto LABEL_44;
LABEL_49:
  if (sax)
    v17->sax = v18;
  xmlFreeParserCtxt(v17);
  v20->intSubset = 0;
  v20->extSubset = 0;
  v20->oldNs = 0;
  xmlFreeDoc(v20);
  return errNo;
}

xmlParserErrors xmlParseInNodeContext(xmlNodePtr node, const char *data, int datalen, int options, xmlNodePtr *lst)
{
  xmlParserErrors errNo;
  xmlNodePtr v6;
  xmlElementType type;
  uint64_t v9;
  xmlElementType v10;
  xmlDoc *doc;
  xmlElementType v13;
  xmlParserCtxtPtr MemoryParserCtxt;
  xmlDict *dict;
  xmlDict *v16;
  const xmlChar *encoding;
  xmlCharEncodingHandler *CharEncodingHandler;
  xmlNode *v19;
  xmlNode *v20;
  int v21;
  xmlNodePtr v22;
  xmlNs *i;
  xmlDict *v24;
  const xmlChar *prefix;
  const xmlChar *href;
  const xmlChar *cur;
  int v28;
  xmlNode *v29;
  xmlNode *next;

  errNo = XML_ERR_INTERNAL_ERROR;
  if (datalen < 0)
    return errNo;
  if (!data)
    return errNo;
  v6 = node;
  if (!node)
    return errNo;
  if (!lst)
    return errNo;
  type = node->type;
  if (type > XML_HTML_DOCUMENT_NODE || ((1 << type) & 0x23BE) == 0)
    return errNo;
  v9 = *(_QWORD *)&options;
  while (1)
  {
    v10 = v6->type;
    if (v10 == XML_ELEMENT_NODE)
      break;
    if (v10 == XML_DOCUMENT_NODE || v10 == XML_HTML_DOCUMENT_NODE)
    {
      doc = (xmlDoc *)v6;
      goto LABEL_17;
    }
    v6 = v6->parent;
    if (!v6)
      return 1;
  }
  doc = v6->doc;
  if (!doc)
    return 1;
LABEL_17:
  v13 = doc->type;
  if (v13 != XML_HTML_DOCUMENT_NODE)
  {
    if (v13 == XML_DOCUMENT_NODE)
    {
      MemoryParserCtxt = xmlCreateMemoryParserCtxt(data, datalen);
      if (!MemoryParserCtxt)
        return 2;
      goto LABEL_23;
    }
    return 1;
  }
  MemoryParserCtxt = htmlCreateMemoryParserCtxt(data, datalen);
  v9 = v9 | 0x2000;
  if (!MemoryParserCtxt)
    return 2;
LABEL_23:
  dict = doc->dict;
  if (dict)
  {
    v16 = MemoryParserCtxt->dict;
    if (v16)
    {
      xmlDictFree(v16);
      dict = doc->dict;
    }
    MemoryParserCtxt->dict = dict;
  }
  else
  {
    v9 = v9 | 0x1000;
  }
  encoding = doc->encoding;
  if (encoding)
  {
    if (MemoryParserCtxt->encoding)
    {
      xmlFree((void *)MemoryParserCtxt->encoding);
      encoding = doc->encoding;
    }
    MemoryParserCtxt->encoding = xmlStrdup(encoding);
    CharEncodingHandler = xmlFindCharEncodingHandler((const char *)doc->encoding);
    if (!CharEncodingHandler)
      return 32;
    xmlSwitchToEncoding(MemoryParserCtxt, CharEncodingHandler);
  }
  xmlCtxtUseOptionsInternal((uint64_t *)MemoryParserCtxt, v9, 0);
  xmlDetectSAX2((const xmlChar *)MemoryParserCtxt);
  MemoryParserCtxt->myDoc = doc;
  MemoryParserCtxt->input_id = 2;
  MemoryParserCtxt->instate = XML_PARSER_CONTENT;
  v19 = xmlNewComment(0);
  if (!v19)
  {
    xmlFreeParserCtxt(MemoryParserCtxt);
    return 2;
  }
  v20 = v19;
  xmlAddChild(v6, v19);
  if (v6->type == XML_ELEMENT_NODE)
  {
    nodePush(MemoryParserCtxt, v6);
    v21 = 0;
    v22 = v6;
    do
    {
      if (v22->type != XML_ELEMENT_NODE)
        break;
      for (i = v22->nsDef; i; i = i->next)
      {
        v24 = MemoryParserCtxt->dict;
        prefix = i->prefix;
        if (v24)
        {
          prefix = xmlDictLookup(v24, i->prefix, -1);
          href = xmlDictLookup(MemoryParserCtxt->dict, i->href, -1);
        }
        else
        {
          href = i->href;
        }
        if (!xmlGetNamespace((uint64_t)MemoryParserCtxt, (uint64_t)prefix))
        {
          nsPush((uint64_t)MemoryParserCtxt, (uint64_t)prefix, (uint64_t)href);
          ++v21;
        }
      }
      v22 = v22->parent;
    }
    while (v22);
  }
  else
  {
    v21 = 0;
  }
  if (MemoryParserCtxt->validate || MemoryParserCtxt->replaceEntities)
    MemoryParserCtxt->loadsubset |= 8u;
  if (doc->type == XML_HTML_DOCUMENT_NODE)
    __htmlParseContent((uint64_t)MemoryParserCtxt);
  else
    xmlParseContent(MemoryParserCtxt);
  nsPop((uint64_t)MemoryParserCtxt, v21);
  cur = MemoryParserCtxt->input->cur;
  if (*cur)
  {
    if (*cur == 60 && cur[1] == 47)
      v28 = 85;
    else
      v28 = 86;
    xmlFatalErr(MemoryParserCtxt, v28, 0);
  }
  v29 = MemoryParserCtxt->node;
  if (!v29 || v29 == v6)
  {
    if (MemoryParserCtxt->wellFormed)
    {
      errNo = XML_ERR_OK;
      goto LABEL_70;
    }
  }
  else
  {
    xmlFatalErr(MemoryParserCtxt, 85, 0);
    MemoryParserCtxt->wellFormed = 0;
  }
  if (MemoryParserCtxt->errNo <= 1u)
    errNo = XML_ERR_INTERNAL_ERROR;
  else
    errNo = MemoryParserCtxt->errNo;
LABEL_70:
  next = v20->next;
  v20->next = 0;
  v6->last = v20;
  if (next)
  {
    next->prev = 0;
    *lst = next;
    do
    {
      next->parent = 0;
      next = next->next;
    }
    while (next);
  }
  else
  {
    *lst = 0;
  }
  xmlUnlinkNode(v20);
  xmlFreeNode(v20);
  if (errNo)
  {
    xmlFreeNodeList(*lst);
    *lst = 0;
  }
  if (doc->dict)
    MemoryParserCtxt->dict = 0;
  xmlFreeParserCtxt(MemoryParserCtxt);
  return errNo;
}

xmlDocPtr xmlSAXParseEntity(xmlSAXHandlerPtr sax, const char *filename)
{
  xmlParserCtxtPtr URLParserCtxt;
  xmlParserCtxt *v4;
  _xmlSAXHandler *v5;
  xmlDoc *myDoc;

  URLParserCtxt = xmlCreateURLParserCtxt(filename, 0);
  if (!URLParserCtxt)
    return 0;
  v4 = URLParserCtxt;
  if (sax)
  {
    v5 = URLParserCtxt->sax;
    if (v4->sax)
      xmlFree(v5);
    v4->sax = sax;
    v4->userData = 0;
  }
  xmlParseExtParsedEnt(v4);
  myDoc = v4->myDoc;
  if (!v4->wellFormed)
  {
    xmlFreeDoc(v4->myDoc);
    myDoc = 0;
    v4->myDoc = 0;
    if (!sax)
      goto LABEL_9;
    goto LABEL_8;
  }
  if (sax)
LABEL_8:
    v4->sax = 0;
LABEL_9:
  xmlFreeParserCtxt(v4);
  return myDoc;
}

xmlParserCtxtPtr xmlCreateFileParserCtxt(const char *filename)
{
  return xmlCreateURLParserCtxt(filename, 0);
}

xmlDocPtr xmlParseEntity(const char *filename)
{
  return xmlSAXParseEntity(0, filename);
}

xmlParserCtxtPtr xmlCreateEntityParserCtxt(const xmlChar *URL, const xmlChar *ID, const xmlChar *base)
{
  return xmlCreateEntityParserCtxtInternal(URL, (const char *)ID, base, 0);
}

xmlParserCtxt *xmlCreateEntityParserCtxtInternal(const xmlChar *a1, const char *a2, const xmlChar *a3, uint64_t a4)
{
  xmlParserCtxtPtr v8;
  xmlParserCtxt *v9;
  xmlChar *v10;
  char *v11;
  xmlParserInput *ExternalEntity;
  char *Directory;
  xmlParserInput *v14;
  char *v15;

  v8 = xmlNewParserCtxt();
  v9 = v8;
  if (!v8)
    return v9;
  if (a4)
  {
    v8->options = *(_DWORD *)(a4 + 564);
    v8->_private = *(void **)(a4 + 424);
    v8->input_id = *(_DWORD *)(a4 + 736) + 1;
  }
  if (!xmlStrcmp(a1, (const xmlChar *)"-"))
    a1 = (const xmlChar *)"./-";
  v10 = xmlBuildURI(a1, a3);
  if (v10)
  {
    v11 = (char *)v10;
    ExternalEntity = xmlLoadExternalEntity((const char *)v10, a2, v9);
    if (ExternalEntity)
    {
      inputPush(v9, ExternalEntity);
      if (!v9->directory)
      {
        Directory = xmlParserGetDirectory(v11);
        if (!v9->directory)
        {
          if (Directory)
            v9->directory = Directory;
        }
      }
      xmlFree(v11);
      return v9;
    }
    xmlFree(v11);
LABEL_19:
    xmlFreeParserCtxt(v9);
    return 0;
  }
  v14 = xmlLoadExternalEntity((const char *)a1, a2, v9);
  if (!v14)
    goto LABEL_19;
  inputPush(v9, v14);
  if (!v9->directory)
  {
    v15 = xmlParserGetDirectory((const char *)a1);
    if (!v9->directory)
    {
      if (v15)
        v9->directory = v15;
    }
  }
  return v9;
}

xmlParserCtxtPtr xmlCreateURLParserCtxt(const char *filename, int options)
{
  uint64_t v2;
  uint64_t *v4;
  xmlParserCtxt *v5;
  xmlParserInput *ExternalEntity;
  char *Directory;

  v2 = *(_QWORD *)&options;
  v4 = (uint64_t *)xmlNewParserCtxt();
  v5 = (xmlParserCtxt *)v4;
  if (v4)
  {
    if ((_DWORD)v2)
      xmlCtxtUseOptionsInternal(v4, v2, 0);
    v5->linenumbers = 1;
    ExternalEntity = xmlLoadExternalEntity(filename, 0, v5);
    if (ExternalEntity)
    {
      inputPush(v5, ExternalEntity);
      if (!v5->directory)
      {
        Directory = xmlParserGetDirectory(filename);
        if (!v5->directory)
        {
          if (Directory)
            v5->directory = Directory;
        }
      }
    }
    else
    {
      xmlFreeParserCtxt(v5);
      return 0;
    }
  }
  else
  {
    htmlErrMemory(0, (const xmlChar *)"cannot allocate parser context");
  }
  return v5;
}

xmlDocPtr xmlSAXParseFileWithData(xmlSAXHandlerPtr sax, const char *filename, int recovery, void *data)
{
  xmlParserCtxtPtr URLParserCtxt;
  xmlParserCtxtPtr v9;
  _xmlSAXHandler *v10;
  xmlDoc *myDoc;
  xmlParserInputBufferPtr buf;
  int compressed;

  xmlInitParser();
  URLParserCtxt = xmlCreateURLParserCtxt(filename, 0);
  if (!URLParserCtxt)
    return 0;
  v9 = URLParserCtxt;
  if (sax)
  {
    v10 = URLParserCtxt->sax;
    if (v9->sax)
      xmlFree(v10);
    v9->sax = sax;
  }
  xmlDetectSAX2((const xmlChar *)v9);
  if (data)
    v9->_private = data;
  if (!v9->directory)
    v9->directory = xmlParserGetDirectory(filename);
  v9->recovery = recovery;
  xmlParseDocument(v9);
  myDoc = v9->myDoc;
  if (v9->wellFormed | recovery)
  {
    if (myDoc)
    {
      buf = v9->input->buf;
      if (buf)
      {
        compressed = buf->compressed;
        if (compressed >= 1)
          compressed = 9;
        myDoc->compression = compressed;
      }
    }
  }
  else
  {
    xmlFreeDoc(v9->myDoc);
    myDoc = 0;
    v9->myDoc = 0;
  }
  if (sax)
    v9->sax = 0;
  xmlFreeParserCtxt(v9);
  return myDoc;
}

xmlDocPtr xmlSAXParseFile(xmlSAXHandlerPtr sax, const char *filename, int recovery)
{
  return xmlSAXParseFileWithData(sax, filename, recovery, 0);
}

xmlDocPtr xmlRecoverDoc(const xmlChar *cur)
{
  return xmlSAXParseDoc(0, cur, 1);
}

xmlDocPtr xmlSAXParseDoc(xmlSAXHandlerPtr sax, const xmlChar *cur, int recovery)
{
  int v6;
  xmlParserCtxtPtr MemoryParserCtxt;
  xmlParserCtxt *v8;
  _xmlSAXHandler *v9;
  xmlDoc *myDoc;

  if (!cur)
    return 0;
  v6 = xmlStrlen(cur);
  MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)cur, v6);
  if (!MemoryParserCtxt)
    return 0;
  v8 = MemoryParserCtxt;
  if (sax)
  {
    v9 = MemoryParserCtxt->sax;
    MemoryParserCtxt->sax = sax;
    MemoryParserCtxt->userData = 0;
  }
  else
  {
    v9 = 0;
  }
  xmlDetectSAX2((const xmlChar *)MemoryParserCtxt);
  xmlParseDocument(v8);
  myDoc = v8->myDoc;
  if (!(v8->wellFormed | recovery))
  {
    xmlFreeDoc(v8->myDoc);
    myDoc = 0;
    v8->myDoc = 0;
  }
  if (sax)
    v8->sax = v9;
  xmlFreeParserCtxt(v8);
  return myDoc;
}

xmlDocPtr xmlParseFile(const char *filename)
{
  return xmlSAXParseFileWithData(0, filename, 0, 0);
}

xmlDocPtr xmlRecoverFile(const char *filename)
{
  return xmlSAXParseFileWithData(0, filename, 1, 0);
}

void xmlSetupParserForBuffer(xmlParserCtxtPtr ctxt, const xmlChar *buffer, const char *filename)
{
  xmlParserInputPtr v6;
  xmlParserInput *v7;

  if (ctxt && buffer)
  {
    v6 = xmlNewInputStream(ctxt);
    if (v6)
    {
      v7 = v6;
      xmlClearParserCtxt(ctxt);
      if (filename)
        v7->filename = (const char *)xmlCanonicPath((const xmlChar *)filename);
      v7->base = buffer;
      v7->cur = buffer;
      v7->end = &buffer[xmlStrlen(buffer)];
      inputPush(ctxt, v7);
    }
    else
    {
      htmlErrMemory(0, (const xmlChar *)"parsing new buffer: out of memory\n");
      xmlClearParserCtxt(ctxt);
    }
  }
}

int xmlSAXUserParseFile(xmlSAXHandlerPtr sax, void *user_data, const char *filename)
{
  xmlParserCtxtPtr URLParserCtxt;
  xmlParserCtxt *v6;
  xmlSAXHandlerV1 *v7;
  int errNo;
  xmlDoc *myDoc;

  URLParserCtxt = xmlCreateURLParserCtxt(filename, 0);
  if (!URLParserCtxt)
    return -1;
  v6 = URLParserCtxt;
  v7 = (xmlSAXHandlerV1 *)URLParserCtxt->sax;
  if (v7 != __xmlDefaultSAXHandler())
    xmlFree(v6->sax);
  v6->sax = sax;
  xmlDetectSAX2((const xmlChar *)v6);
  if (user_data)
    v6->userData = user_data;
  xmlParseDocument(v6);
  if (v6->wellFormed)
  {
    errNo = 0;
    if (sax)
LABEL_8:
      v6->sax = 0;
  }
  else
  {
    if (v6->errNo)
      errNo = v6->errNo;
    else
      errNo = -1;
    if (sax)
      goto LABEL_8;
  }
  myDoc = v6->myDoc;
  if (myDoc)
  {
    xmlFreeDoc(myDoc);
    v6->myDoc = 0;
  }
  xmlFreeParserCtxt(v6);
  return errNo;
}

xmlDocPtr xmlSAXParseMemoryWithData(xmlSAXHandlerPtr sax, const char *buffer, int size, int recovery, void *data)
{
  xmlParserCtxtPtr MemoryParserCtxt;
  xmlParserCtxtPtr v11;
  _xmlSAXHandler *v12;
  xmlDoc *myDoc;

  xmlInitParser();
  MemoryParserCtxt = xmlCreateMemoryParserCtxt(buffer, size);
  if (!MemoryParserCtxt)
    return 0;
  v11 = MemoryParserCtxt;
  if (sax)
  {
    v12 = MemoryParserCtxt->sax;
    if (v11->sax)
      xmlFree(v12);
    v11->sax = sax;
  }
  xmlDetectSAX2((const xmlChar *)v11);
  if (data)
    v11->_private = data;
  v11->recovery = recovery;
  xmlParseDocument(v11);
  myDoc = v11->myDoc;
  if (!(v11->wellFormed | recovery))
  {
    xmlFreeDoc(v11->myDoc);
    myDoc = 0;
    v11->myDoc = 0;
    if (!sax)
      goto LABEL_11;
    goto LABEL_10;
  }
  if (sax)
LABEL_10:
    v11->sax = 0;
LABEL_11:
  xmlFreeParserCtxt(v11);
  return myDoc;
}

xmlDocPtr xmlSAXParseMemory(xmlSAXHandlerPtr sax, const char *buffer, int size, int recovery)
{
  return xmlSAXParseMemoryWithData(sax, buffer, size, recovery, 0);
}

xmlDocPtr xmlParseMemory(const char *buffer, int size)
{
  return xmlSAXParseMemoryWithData(0, buffer, size, 0, 0);
}

xmlDocPtr xmlRecoverMemory(const char *buffer, int size)
{
  return xmlSAXParseMemoryWithData(0, buffer, size, 1, 0);
}

int xmlSAXUserParseMemory(xmlSAXHandlerPtr sax, void *user_data, const char *buffer, int size)
{
  xmlParserCtxtPtr MemoryParserCtxt;
  xmlParserCtxt *v9;
  xmlSAXHandlerV1 *v10;
  int errNo;
  xmlDoc *myDoc;

  xmlInitParser();
  MemoryParserCtxt = xmlCreateMemoryParserCtxt(buffer, size);
  if (!MemoryParserCtxt)
    return -1;
  v9 = MemoryParserCtxt;
  v10 = (xmlSAXHandlerV1 *)MemoryParserCtxt->sax;
  if (v10 != __xmlDefaultSAXHandler())
    xmlFree(v9->sax);
  v9->sax = sax;
  xmlDetectSAX2((const xmlChar *)v9);
  if (user_data)
    v9->userData = user_data;
  xmlParseDocument(v9);
  if (v9->wellFormed)
  {
    errNo = 0;
    if (sax)
LABEL_8:
      v9->sax = 0;
  }
  else
  {
    if (v9->errNo)
      errNo = v9->errNo;
    else
      errNo = -1;
    if (sax)
      goto LABEL_8;
  }
  myDoc = v9->myDoc;
  if (myDoc)
  {
    xmlFreeDoc(myDoc);
    v9->myDoc = 0;
  }
  xmlFreeParserCtxt(v9);
  return errNo;
}

xmlParserCtxtPtr xmlCreateDocParserCtxt(xmlParserCtxtPtr cur)
{
  const char *v1;
  int v2;

  if (cur)
  {
    v1 = (const char *)cur;
    v2 = xmlStrlen((const xmlChar *)cur);
    return xmlCreateMemoryParserCtxt(v1, v2);
  }
  return cur;
}

xmlDocPtr xmlParseDoc(const xmlChar *cur)
{
  return xmlSAXParseDoc(0, cur, 0);
}

void xmlSetEntityReferenceFunc(xmlEntityReferenceFunc func)
{
  xmlEntityRefFunc = func;
}

void xmlCleanupParser(void)
{
  if (xmlParserInitialized == 1)
  {
    xmlCleanupCharEncodingHandlers();
    xmlCatalogCleanup();
    xmlDictCleanup();
    xmlCleanupInputCallbacks();
    xmlCleanupOutputCallbacks();
    xmlSchemaCleanupTypes();
    xmlRelaxNGCleanupTypes();
    xmlResetLastError();
    xmlCleanupGlobals();
    xmlCleanupThreads();
    xmlCleanupMemory();
    xmlParserInitialized = 0;
  }
}

void xmlCtxtReset(xmlParserCtxtPtr ctxt)
{
  xmlDict *dict;
  int inputNr;
  xmlParserInputPtr *inputTab;
  int v5;
  xmlParserInput *v6;
  xmlParserInput *v7;
  int *spaceTab;
  xmlChar *version;
  xmlChar *encoding;
  char *directory;
  xmlChar *extSubURI;
  xmlChar *extSubSystem;
  xmlDoc *myDoc;
  xmlHashTable *attsDefault;
  xmlHashTable *attsSpecial;
  void *catalogs;

  if (!ctxt)
    return;
  dict = ctxt->dict;
  inputNr = ctxt->inputNr;
  if (inputNr >= 1)
  {
    do
    {
      inputTab = ctxt->inputTab;
      v5 = inputNr - 1;
      ctxt->inputNr = inputNr - 1;
      if (inputNr == 1)
        v6 = 0;
      else
        v6 = inputTab[inputNr - 2];
      ctxt->input = v6;
      v7 = inputTab[v5];
      inputTab[v5] = 0;
      if (!v7)
        break;
      xmlFreeInputStream(v7);
      inputNr = ctxt->inputNr;
    }
    while (inputNr > 0);
  }
  ctxt->inputNr = 0;
  ctxt->input = 0;
  ctxt->spaceNr = 0;
  spaceTab = ctxt->spaceTab;
  if (spaceTab)
    *spaceTab = -1;
  ctxt->space = spaceTab;
  ctxt->nodeNr = 0;
  ctxt->node = 0;
  ctxt->nameNr = 0;
  ctxt->name = 0;
  ctxt->nsNr = 0;
  version = (xmlChar *)ctxt->version;
  if (version)
  {
    if (dict)
    {
      if (xmlDictOwns(dict, version))
        goto LABEL_15;
      version = (xmlChar *)ctxt->version;
    }
    xmlFree(version);
  }
LABEL_15:
  ctxt->version = 0;
  encoding = (xmlChar *)ctxt->encoding;
  if (!encoding)
    goto LABEL_20;
  if (dict)
  {
    if (xmlDictOwns(dict, encoding))
      goto LABEL_20;
    encoding = (xmlChar *)ctxt->encoding;
  }
  xmlFree(encoding);
LABEL_20:
  ctxt->encoding = 0;
  directory = ctxt->directory;
  if (!directory)
    goto LABEL_25;
  if (dict)
  {
    if (xmlDictOwns(dict, (const xmlChar *)directory))
      goto LABEL_25;
    directory = ctxt->directory;
  }
  xmlFree(directory);
LABEL_25:
  ctxt->directory = 0;
  extSubURI = ctxt->extSubURI;
  if (!extSubURI)
    goto LABEL_30;
  if (dict)
  {
    if (xmlDictOwns(dict, extSubURI))
      goto LABEL_30;
    extSubURI = ctxt->extSubURI;
  }
  xmlFree(extSubURI);
LABEL_30:
  ctxt->extSubURI = 0;
  extSubSystem = ctxt->extSubSystem;
  if (extSubSystem)
  {
    if (!dict)
    {
LABEL_34:
      xmlFree(extSubSystem);
      goto LABEL_35;
    }
    if (!xmlDictOwns(dict, extSubSystem))
    {
      extSubSystem = ctxt->extSubSystem;
      goto LABEL_34;
    }
  }
LABEL_35:
  ctxt->extSubSystem = 0;
  myDoc = ctxt->myDoc;
  if (myDoc)
    xmlFreeDoc(myDoc);
  ctxt->myDoc = 0;
  *(_QWORD *)&ctxt->standalone = 0xFFFFFFFFLL;
  *(_QWORD *)&ctxt->instate = 0;
  ctxt->wellFormed = 1;
  ctxt->nsWellFormed = 1;
  *(_QWORD *)&ctxt->disableSAX = 0;
  ctxt->valid = 1;
  ctxt->record_info = 0;
  ctxt->checkIndex = 0;
  *(_QWORD *)&ctxt->errNo = 0;
  *(_QWORD *)&ctxt->hasPErefs = 0;
  ctxt->depth = 0;
  ctxt->charset = 1;
  ctxt->catalogs = 0;
  ctxt->sizeentcopy = 0;
  *(_OWORD *)&ctxt->nbentities = 0u;
  xmlInitNodeInfoSeq(&ctxt->node_seq);
  attsDefault = ctxt->attsDefault;
  if (attsDefault)
  {
    xmlHashFree(attsDefault, xmlHashDefaultDeallocator);
    ctxt->attsDefault = 0;
  }
  attsSpecial = ctxt->attsSpecial;
  if (attsSpecial)
  {
    xmlHashFree(attsSpecial, 0);
    ctxt->attsSpecial = 0;
  }
  catalogs = ctxt->catalogs;
  if (catalogs)
    xmlCatalogFreeLocal(catalogs);
  if (ctxt->lastError.code)
    xmlResetError(&ctxt->lastError);
}

int xmlCtxtResetPush(xmlParserCtxtPtr ctxt, const char *chunk, int size, const char *filename, const char *encoding)
{
  xmlCharEncoding v10;
  xmlParserInputBufferPtr v11;
  xmlParserInputBufferPtr v12;
  xmlParserInputPtr v13;
  xmlParserInput *v14;
  xmlChar *v15;
  xmlParserInputPtr v17;
  xmlParserInputPtr input;
  unint64_t InputBase;
  xmlParserInputPtr v20;
  uint64_t v21;
  xmlChar *v22;
  xmlCharEncodingHandler *CharEncodingHandler;

  if (!ctxt)
    return 1;
  v10 = XML_CHAR_ENCODING_NONE;
  if (chunk && size >= 4 && !encoding)
    v10 = xmlDetectCharEncoding((const unsigned __int8 *)chunk, size);
  v11 = xmlAllocParserInputBuffer(v10);
  if (!v11)
    return 1;
  v12 = v11;
  xmlCtxtReset(ctxt);
  if (filename)
  {
    ctxt->directory = xmlParserGetDirectory(filename);
    v13 = xmlNewInputStream(ctxt);
    if (v13)
    {
      v14 = v13;
      v15 = xmlCanonicPath((const xmlChar *)filename);
      goto LABEL_13;
    }
    goto LABEL_23;
  }
  ctxt->directory = 0;
  v17 = xmlNewInputStream(ctxt);
  if (!v17)
  {
LABEL_23:
    xmlFreeParserInputBuffer(v12);
    return 1;
  }
  v14 = v17;
  v15 = 0;
LABEL_13:
  v14->buf = v12;
  v14->filename = (const char *)v15;
  xmlBufResetInput((uint64_t *)v12->buffer, v14);
  inputPush(ctxt, v14);
  if (chunk)
  {
    if (size >= 1)
    {
      input = ctxt->input;
      if (input)
      {
        if (input->buf)
        {
          InputBase = xmlBufGetInputBase((uint64_t)input->buf->buffer, (uint64_t)input);
          v20 = ctxt->input;
          v21 = v20->cur - v20->base;
          xmlParserInputBufferPush(v20->buf, size, chunk);
          xmlBufSetInputBaseCur((uint64_t *)ctxt->input->buf->buffer, &ctxt->input->buf, InputBase, v21);
        }
      }
    }
  }
  if (encoding)
  {
    v22 = (xmlChar *)ctxt->encoding;
    if (v22)
      xmlFree(v22);
    ctxt->encoding = xmlStrdup((const xmlChar *)encoding);
    CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
    if (CharEncodingHandler)
      xmlSwitchToEncoding(ctxt, CharEncodingHandler);
    else
      xmlFatalErrMsgStr(ctxt, 32, "Unsupported encoding %s\n", (const xmlChar *)encoding);
  }
  else if (v10)
  {
    xmlSwitchEncoding(ctxt, v10);
  }
  return 0;
}

xmlDocPtr xmlReadDoc(const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  uint64_t v4;
  int v8;
  xmlParserCtxt *MemoryParserCtxt;

  if (cur
    && (v4 = *(_QWORD *)&options,
        xmlInitParser(),
        v8 = xmlStrlen(cur),
        (MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)cur, v8)) != 0))
  {
    return xmlDoRead(MemoryParserCtxt, (const xmlChar *)URL, (xmlChar *)encoding, v4, 0);
  }
  else
  {
    return 0;
  }
}

xmlDocPtr xmlReadFile(const char *URL, const char *encoding, int options)
{
  uint64_t v3;
  xmlDocPtr result;

  v3 = *(_QWORD *)&options;
  xmlInitParser();
  result = (xmlDocPtr)xmlCreateURLParserCtxt(URL, v3);
  if (result)
    return xmlDoRead((xmlParserCtxt *)result, 0, (xmlChar *)encoding, v3, 0);
  return result;
}

xmlDocPtr xmlReadFd(int fd, const char *URL, const char *encoding, int options)
{
  uint64_t v4;
  xmlParserInputBufferPtr v8;
  xmlParserInputBuffer *v9;
  xmlParserCtxt *v10;
  xmlParserCtxt *v11;
  xmlParserInput *v12;

  if ((fd & 0x80000000) == 0)
  {
    v4 = *(_QWORD *)&options;
    xmlInitParser();
    v8 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
    if (v8)
    {
      v9 = v8;
      v8->closecallback = 0;
      v10 = xmlNewParserCtxt();
      if (v10)
      {
        v11 = v10;
        v12 = xmlNewIOInputStream(v10, v9, XML_CHAR_ENCODING_NONE);
        if (v12)
        {
          inputPush(v11, v12);
          return xmlDoRead(v11, (const xmlChar *)URL, (xmlChar *)encoding, v4, 0);
        }
        xmlFreeParserInputBuffer(v9);
        xmlFreeParserCtxt(v11);
      }
      else
      {
        xmlFreeParserInputBuffer(v9);
      }
    }
  }
  return 0;
}

xmlDocPtr xmlReadIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  uint64_t v6;
  xmlParserInputBufferPtr IO;
  xmlParserInputBuffer *v13;
  xmlParserCtxt *v14;
  xmlParserCtxt *v15;
  xmlParserInput *v16;

  if (ioread)
  {
    v6 = *(_QWORD *)&options;
    xmlInitParser();
    IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
    if (IO)
    {
      v13 = IO;
      v14 = xmlNewParserCtxt();
      if (v14)
      {
        v15 = v14;
        v16 = xmlNewIOInputStream(v14, v13, XML_CHAR_ENCODING_NONE);
        if (v16)
        {
          inputPush(v15, v16);
          return xmlDoRead(v15, (const xmlChar *)URL, (xmlChar *)encoding, v6, 0);
        }
        xmlFreeParserInputBuffer(v13);
        xmlFreeParserCtxt(v15);
      }
      else
      {
        xmlFreeParserInputBuffer(v13);
      }
    }
    else if (ioclose)
    {
      ((void (*)(void *))ioclose)(ioctx);
    }
  }
  return 0;
}

xmlDocPtr xmlCtxtReadDoc(xmlParserCtxtPtr ctxt, const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  uint64_t v6;
  xmlParserInput *v10;

  if (!ctxt)
    return 0;
  if (!cur)
    return 0;
  v6 = *(_QWORD *)&options;
  xmlInitParser();
  xmlCtxtReset(ctxt);
  v10 = xmlNewStringInputStream(ctxt, cur);
  if (!v10)
    return 0;
  inputPush(ctxt, v10);
  return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v6, 1);
}

xmlDocPtr xmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename, const char *encoding, int options)
{
  uint64_t v5;
  xmlParserInput *ExternalEntity;

  if (!ctxt)
    return 0;
  if (!filename)
    return 0;
  v5 = *(_QWORD *)&options;
  xmlInitParser();
  xmlCtxtReset(ctxt);
  ExternalEntity = xmlLoadExternalEntity(filename, 0, ctxt);
  if (!ExternalEntity)
    return 0;
  inputPush(ctxt, ExternalEntity);
  return xmlDoRead(ctxt, 0, (xmlChar *)encoding, v5, 1);
}

xmlDocPtr xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  uint64_t v7;
  xmlParserInputBuffer *Mem;
  xmlParserInputBuffer *v13;
  xmlParserInput *v14;

  if (ctxt)
  {
    if (buffer)
    {
      v7 = *(_QWORD *)&options;
      xmlInitParser();
      xmlCtxtReset(ctxt);
      Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
      if (Mem)
      {
        v13 = Mem;
        v14 = xmlNewIOInputStream(ctxt, Mem, XML_CHAR_ENCODING_NONE);
        if (v14)
        {
          inputPush(ctxt, v14);
          return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v7, 1);
        }
        xmlFreeParserInputBuffer(v13);
      }
    }
  }
  return 0;
}

xmlDocPtr xmlCtxtReadFd(xmlParserCtxtPtr ctxt, int fd, const char *URL, const char *encoding, int options)
{
  uint64_t v6;
  xmlParserInputBufferPtr v10;
  xmlParserInputBuffer *v11;
  xmlParserInput *v12;

  if (ctxt)
  {
    if ((fd & 0x80000000) == 0)
    {
      v6 = *(_QWORD *)&options;
      xmlInitParser();
      xmlCtxtReset(ctxt);
      v10 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
      if (v10)
      {
        v11 = v10;
        v10->closecallback = 0;
        v12 = xmlNewIOInputStream(ctxt, v10, XML_CHAR_ENCODING_NONE);
        if (v12)
        {
          inputPush(ctxt, v12);
          return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v6, 1);
        }
        xmlFreeParserInputBuffer(v11);
      }
    }
  }
  return 0;
}

xmlDocPtr xmlCtxtReadIO(xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  uint64_t v8;
  xmlParserInputBuffer *IO;
  xmlParserInputBuffer *v15;
  xmlParserInput *v16;

  if (ctxt && ioread)
  {
    v8 = *(_QWORD *)&options;
    xmlInitParser();
    xmlCtxtReset(ctxt);
    IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
    if (IO)
    {
      v15 = IO;
      v16 = xmlNewIOInputStream(ctxt, IO, XML_CHAR_ENCODING_NONE);
      if (v16)
      {
        inputPush(ctxt, v16);
        return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v8, 1);
      }
      xmlFreeParserInputBuffer(v15);
    }
    else if (ioclose)
    {
      ((void (*)(void *))ioclose)(ioctx);
    }
  }
  return 0;
}

__n128 xmlIsNameStartChar(uint64_t a1, signed int val)
{
  __n128 result;
  int32x4_t v3;

  if ((*(_BYTE *)(a1 + 566) & 2) != 0)
  {
    if (val > 255)
      xmlCharInRange(val, &xmlIsBaseCharGroup);
  }
  else if ((val > 0x3E || ((1 << val) & 0x4000800100000000) == 0)
         && (val & 0xFFFFFFDF) - 65 >= 0x1A
         && val != 58
         && val != 95)
  {
    v3 = vdupq_n_s32(val);
    result.n128_u8[0] = vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B08622B0, (uint32x4_t)vaddq_s32(v3, (int32x4_t)xmmword_1B0862290)), (int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B08622C0, (uint32x4_t)vaddq_s32(v3, (int32x4_t)xmmword_1B08622A0)))));
  }
  return result;
}

_DWORD *xmlNsWarn(_DWORD *result, const char *a2, const xmlChar *a3, xmlChar *a4)
{
  if (!result || !result[83] || result[68] != -1)
    return __xmlRaiseError(0, 0, 0, result, 0, 3u, 100, 1, 0, 0, a3, a4, 0, 0, 0, a2, (char)a3);
  return result;
}

uint64_t xmlCleanSpecialAttrCallback(uint64_t result, uint64_t a2, xmlChar *name, xmlChar *name2)
{
  if (result == 1)
    return xmlHashRemoveEntry2(*(xmlHashTablePtr *)(a2 + 552), name, name2, 0);
  return result;
}

uint64_t xmlCheckCdataPush(uint64_t a1, int a2, int a3)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;
  int v8;
  char v10;
  unsigned int v11;
  char v13;
  char v14;
  unsigned int v15;
  int v16;
  char v17;
  char v18;
  char v19;
  int v20;
  unsigned int v21;

  result = 0;
  if (a1 && a2 >= 1)
  {
    LODWORD(result) = 0;
    do
    {
      v5 = (int)result;
      v6 = *(unsigned __int8 *)(a1 + (int)result);
      if (*(char *)(a1 + (int)result) < 0)
      {
        if ((v6 & 0xE0) == 0xC0)
        {
          result = (result + 2);
          if ((int)result > a2)
            goto LABEL_50;
          v10 = *(_BYTE *)(v5 + a1 + 1);
          if ((v10 & 0xC0) != 0x80)
            return -(int)v5;
          v11 = v10 & 0x3F | ((v6 & 0x1F) << 6);
          if (v11 <= 0x1F && (v11 > 0xD || ((1 << v11) & 0x2600) == 0))
            return -(int)v5;
        }
        else if ((v6 & 0xF0) == 0xE0)
        {
          result = (result + 3);
          if ((int)result > a2)
            goto LABEL_50;
          v13 = *(_BYTE *)(v5 + a1 + 1);
          if ((v13 & 0xC0) != 0x80)
            return -(int)v5;
          v14 = *(_BYTE *)(v5 + a1 + 2);
          if ((v14 & 0xC0) != 0x80)
            return -(int)v5;
          v15 = ((v6 & 0xF) << 12) | ((v13 & 0x3F) << 6) | v14 & 0x3F;
          if (v15 <= 0xFF)
          {
            if (v15 > 0x1F)
              continue;
            if (v15 > 0xD)
              return -(int)v5;
            v16 = 1 << v15;
            goto LABEL_40;
          }
          if (v15 >> 11 >= 0x1B && (v15 - 57344) >> 1 >= 0xFFF)
            return -(int)v5;
        }
        else
        {
          if ((v6 & 0xF8) != 0xF0)
            return -(int)v5;
          result = (result + 4);
          if ((int)result > a2)
          {
LABEL_50:
            if (a3)
              return -(int)v5;
            else
              return v5;
          }
          v17 = *(_BYTE *)(v5 + a1 + 1);
          if ((v17 & 0xC0) != 0x80)
            return -(int)v5;
          v18 = *(_BYTE *)(v5 + a1 + 2);
          if ((v18 & 0xC0) != 0x80)
            return -(int)v5;
          v19 = *(_BYTE *)(v5 + a1 + 3);
          if ((v19 & 0xC0) != 0x80)
            return -(int)v5;
          v20 = ((v6 & 7) << 18) | ((v17 & 0x3F) << 12);
          v21 = v19 & 0x3F | ((v18 & 0x3F) << 6) | v20;
          if (v21 <= 0xFF)
          {
            if (v21 > 0x1F)
              continue;
            if (v21 > 0xD)
              return -(int)v5;
            v16 = 1 << v21;
LABEL_40:
            if ((v16 & 0x2600) == 0)
              return -(int)v5;
            continue;
          }
          if (v21 >> 11 >= 0x1B && (v21 - 57344) >> 1 >= 0xFFF && (v20 - 0x10000) >= 0x100000)
            return -(int)v5;
        }
      }
      else
      {
        if (v6 < 0x20)
        {
          v7 = v6 > 0xD;
          v8 = (1 << v6) & 0x2600;
          if (v7 || v8 == 0)
            return -(int)v5;
        }
        result = (result + 1);
      }
    }
    while ((int)result < a2);
  }
  return result;
}

void xmlCheckVersion(int version)
{
  xmlGenericErrorFunc v2;
  void **v3;
  xmlGenericErrorFunc v4;
  void **v5;

  xmlInitParser();
  if ((version - 20000) >> 4 >= 0x271)
  {
    v2 = *__xmlGenericError();
    v3 = __xmlGenericErrorContext();
    v2(*v3, "Fatal: program compiled against libxml %d using libxml %d\n", version / 10000, 2);
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "Fatal: program compiled against libxml %d using libxml %d\n", version / 10000, 2);
  }
  if (version >= 21000)
  {
    v4 = *__xmlGenericError();
    v5 = __xmlGenericErrorContext();
    v4(*v5, "Warning: program compiled against libxml %d using older %d\n", version / 0x64u, 209);
  }
}

_DWORD *__xmlErrEncoding(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  _DWORD *v5;

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 3, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
  v5 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
    v5[6] = 0;
    if (!v5[112])
      v5[83] = 1;
  }
  return result;
}

int xmlIsLetter(int c)
{
  unsigned int v2;
  int result;

  if (c > 255)
  {
    return xmlCharInRange(c, &xmlIsBaseCharGroup)
        || c == 12295
        || (c - 19968) < 0x51A6
        || (c - 12321) < 9;
  }
  else
  {
    v2 = c - 192;
    result = 1;
    if (v2 >= 0x17 && (c & 0xFFFFFFDF) - 65 >= 0x1A && c <= 247)
      return (c - 216) < 0x1F;
  }
  return result;
}

int xmlParserInputRead(xmlParserInputPtr in, int len)
{
  return -1;
}

_DWORD *xmlErrInternal(_DWORD *result, const char *a2, const xmlChar *a3)
{
  _DWORD *v3;

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, 1, 3, 0, 0, a3, 0, 0, 0, 0, a2, (char)a3);
  v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = 1;
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, 1, 3, 0, 0, a3, 0, 0, 0, 0, a2, (char)a3);
    v3[6] = 0;
    if (!v3[112])
      v3[83] = 1;
  }
  return result;
}

_DWORD *xmlErrEncodingInt(_DWORD *result, const char *a2, int a3)
{
  _DWORD *v3;

  if (!result)
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, 9, 3, 0, 0, 0, 0, 0, a3, 0, a2, a3);
  v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = 9;
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, 9, 3, 0, 0, 0, 0, 0, a3, 0, a2, a3);
    v3[6] = 0;
    if (!v3[112])
      v3[83] = 1;
  }
  return result;
}

int xmlStringCurrentChar(xmlParserCtxtPtr ctxt, const xmlChar *cur, int *len)
{
  unsigned int v3;
  const xmlChar *v8;
  int v9;
  int v10;
  xmlChar v11;
  xmlParserInputPtr input;
  unsigned __int8 *v13;
  const xmlChar **p_cur;
  unsigned int v15;
  char __str[16];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _WORD v24[11];
  uint64_t v25;

  v3 = 0;
  v25 = *MEMORY[0x1E0C80C00];
  if (!cur || !len)
    return v3;
  if (ctxt && ctxt->charset != 1 || (*(char *)cur & 0x80000000) == 0)
  {
LABEL_6:
    *len = 1;
    return *cur;
  }
  v8 = cur + 1;
  if ((cur[1] & 0xC0) != 0x80)
    goto LABEL_34;
  v9 = *cur;
  if ((~v9 & 0xE0) != 0)
  {
    *len = 2;
    v15 = (*cur & 0x1F) << 6;
    goto LABEL_23;
  }
  v8 = cur + 2;
  if ((cur[2] & 0xC0) != 0x80)
    goto LABEL_34;
  if ((~v9 & 0xF0) != 0)
  {
    *len = 3;
    v10 = (*cur & 0xF) << 12;
    v11 = cur[1];
    goto LABEL_22;
  }
  if ((v9 & 0xF8) != 0xF0 || (v8 = cur + 3, (cur[3] & 0xC0) != 0x80))
  {
LABEL_34:
    if (!ctxt
      || (input = ctxt->input) == 0
      || (p_cur = &input->cur, v13 = (unsigned __int8 *)input->cur, p_cur[1] - v13 <= 3))
    {
      v3 = 0;
      *len = 0;
      return v3;
    }
    v23 = 0u;
    memset(v24, 0, sizeof(v24));
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    *(_OWORD *)__str = 0u;
    snprintf(__str, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", *v13, v13[1], v13[2], v13[3]);
    __xmlErrEncoding(ctxt, 9, "Input is not proper UTF-8, indicate encoding !\n%s", (const xmlChar *)__str, 0);
    goto LABEL_6;
  }
  *len = 4;
  v10 = ((*cur & 7) << 18) | ((cur[1] & 0x3F) << 12);
  v11 = cur[2];
LABEL_22:
  v15 = v10 & 0xFFFFF03F | ((v11 & 0x3F) << 6);
LABEL_23:
  v3 = v15 | *v8 & 0x3F;
  if (v3 > 0xFF)
  {
    if (v3 >> 11 >= 0x1B && (v3 - 57344) >> 1 >= 0xFFF && v3 - 0x10000 >= 0x100000)
      goto LABEL_31;
  }
  else if (v3 <= 0x1F && (v3 > 0xD || ((1 << v3) & 0x2600) == 0))
  {
LABEL_31:
    xmlErrEncodingInt(ctxt, "Char 0x%X out of allowed range\n", v3);
  }
  return v3;
}

uint64_t xmlSwitchToEncodingInt(xmlParserCtxt *a1, xmlCharEncodingHandler *handler, int a3)
{
  uint64_t *input;
  uint64_t result;

  if (handler)
  {
    input = (uint64_t *)a1->input;
    if (input)
    {
      result = xmlSwitchInputEncodingInt(a1, input, handler, a3);
      a1->charset = 1;
      return result;
    }
    xmlErrInternal(a1, "xmlSwitchToEncoding : no input\n", 0);
  }
  return 0xFFFFFFFFLL;
}

int xmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input, xmlCharEncodingHandlerPtr handler)
{
  return xmlSwitchInputEncodingInt(ctxt, (uint64_t *)input, handler, -1);
}

uint64_t xmlSwitchInputEncodingInt(xmlParserCtxt *a1, uint64_t *a2, xmlCharEncodingHandler *handler, int a4)
{
  uint64_t result;
  uint64_t v8;
  xmlCharEncodingHandler *v9;
  _QWORD *v11;
  _QWORD *v12;
  char *name;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  size_t v17;
  _QWORD *v18;
  xmlBuf *v19;
  unsigned int v20;
  uint64_t v21;
  int LineInput;
  int v23;
  size_t v24;

  result = 0xFFFFFFFFLL;
  if (a2 && handler)
  {
    v8 = *a2;
    if (*a2)
    {
      v9 = *(xmlCharEncodingHandler **)(v8 + 24);
      if (v9)
      {
        if (v9 != handler)
        {
          xmlCharEncCloseFunc(v9);
          result = 0;
          *(_QWORD *)(*a2 + 24) = handler;
          return result;
        }
        return 0;
      }
      *(_QWORD *)(v8 + 24) = handler;
      if (xmlBufIsEmpty(*(_QWORD *)(v8 + 32)))
        return 0;
      v11 = xmlBufCreate();
      if (v11)
      {
        v12 = v11;
        name = handler->name;
        if (name)
        {
          if (!strcmp(name, "UTF-16LE") || !strcmp(name, "UTF-16"))
          {
            v14 = (unsigned __int8 *)a2[4];
            if (*v14 == 255 && v14[1] == 254)
              a2[4] = (uint64_t)(v14 + 2);
          }
          if (!strcmp(name, "UTF-16BE"))
          {
            v15 = (unsigned __int8 *)a2[4];
            if (*v15 == 254 && v15[1] == 255)
              a2[4] = (uint64_t)(v15 + 2);
          }
          if (!strcmp(name, "UTF-8"))
          {
            v16 = (unsigned __int8 *)a2[4];
            if (*v16 == 239 && v16[1] == 187 && v16[2] == 191)
              a2[4] = (uint64_t)(v16 + 3);
          }
        }
        v17 = *((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6);
        xmlBufShrink(*(xmlBufPtr *)(*a2 + 32), v17);
        v18 = (_QWORD *)*a2;
        v19 = *(xmlBuf **)(*a2 + 32);
        v18[4] = v12;
        v18[5] = v19;
        v18[7] = v17;
        v20 = xmlBufUse(v19);
        v21 = *a2;
        if (a1->html)
          LineInput = xmlCharEncInput(v21, 1);
        else
          LineInput = xmlCharEncFirstLineInput(v21, a4);
        v23 = LineInput;
        xmlBufResetInput(*(uint64_t **)(*a2 + 32), a2);
        if ((v23 & 0x80000000) == 0)
        {
          v24 = xmlBufUse(*(const xmlBufPtr *)(*a2 + 40));
          result = 0;
          *(_QWORD *)(*a2 + 56) = *(_QWORD *)(*a2 + 56) - v24 + v20;
          return result;
        }
        if (!a1->html)
        {
          xmlErrInternal(a1, "switching encoding: encoder error\n", 0);
          xmlHaltParser(a1);
        }
      }
      else
      {
        htmlErrMemory(a1, 0);
      }
    }
    else
    {
      if (*((_DWORD *)a2 + 12))
      {
        xmlCharEncCloseFunc(handler);
        return 0;
      }
      xmlErrInternal(a1, "switching encoding : no input\n", 0);
      xmlCharEncCloseFunc(handler);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

int xmlSwitchToEncoding(xmlParserCtxtPtr ctxt, xmlCharEncodingHandlerPtr handler)
{
  return xmlSwitchToEncodingInt(ctxt, handler, -1);
}

xmlParserInputPtr xmlNewIOInputStream(xmlParserCtxtPtr ctxt, xmlParserInputBufferPtr input, xmlCharEncoding enc)
{
  xmlGenericErrorFunc v6;
  void **v7;
  xmlParserInputPtr v8;
  xmlParserInput *v9;

  if (!input)
    return 0;
  if (*__xmlParserDebugEntities())
  {
    v6 = *__xmlGenericError();
    v7 = __xmlGenericErrorContext();
    v6(*v7, "new input from I/O\n");
  }
  v8 = xmlNewInputStream(ctxt);
  v9 = v8;
  if (v8)
  {
    v8->buf = input;
    v8->filename = 0;
    xmlBufResetInput((uint64_t *)input->buffer, v8);
    if (enc)
      xmlSwitchEncoding(ctxt, enc);
  }
  return v9;
}

xmlParserInputPtr xmlNewEntityInputStream(xmlParserCtxtPtr ctxt, xmlEntityPtr entity)
{
  xmlParserCtxt *v2;
  xmlGenericErrorFunc v4;
  void **v5;
  xmlParserInputPtr v6;
  const xmlChar *URI;
  xmlChar *content;
  int length;
  const char *v10;
  const xmlChar *name;

  v2 = ctxt;
  if (!entity)
  {
    v10 = "xmlNewEntityInputStream entity = NULL\n";
    name = 0;
LABEL_19:
    xmlErrInternal(ctxt, v10, name);
    return 0;
  }
  if (*__xmlParserDebugEntities())
  {
    v4 = *__xmlGenericError();
    v5 = __xmlGenericErrorContext();
    v4(*v5, "new input from entity: %s\n", (const char *)entity->name);
  }
  if (!entity->content)
  {
    switch(entity->etype)
    {
      case XML_INTERNAL_GENERAL_ENTITY:
        name = entity->name;
        v10 = "Internal entity %s without content !\n";
        goto LABEL_18;
      case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
      case XML_EXTERNAL_PARAMETER_ENTITY:
        return xmlLoadExternalEntity((const char *)entity->URI, (const char *)entity->ExternalID, v2);
      case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
        name = entity->name;
        v10 = "Cannot parse entity %s\n";
        goto LABEL_18;
      case XML_INTERNAL_PARAMETER_ENTITY:
        name = entity->name;
        v10 = "Internal parameter entity %s without content !\n";
        goto LABEL_18;
      case XML_INTERNAL_PREDEFINED_ENTITY:
        name = entity->name;
        v10 = "Predefined entity %s without content !\n";
LABEL_18:
        ctxt = v2;
        break;
      default:
        return 0;
    }
    goto LABEL_19;
  }
  v6 = xmlNewInputStream(v2);
  if (v6)
  {
    URI = entity->URI;
    if (URI)
      v6->filename = (const char *)xmlStrdup(URI);
    content = entity->content;
    v6->base = content;
    length = entity->length;
    if (!length)
    {
      length = xmlStrlen(content);
      entity->length = length;
      content = entity->content;
    }
    v6->length = length;
    v6->cur = content;
    v6->end = &content[length];
  }
  return v6;
}

xmlParserInputPtr xmlNewStringInputStream(xmlParserCtxtPtr ctxt, const xmlChar *buffer)
{
  xmlGenericErrorFunc v4;
  void **v5;
  xmlParserInputPtr v6;
  xmlParserInput *v7;
  int v8;

  if (buffer)
  {
    if (*__xmlParserDebugEntities())
    {
      v4 = *__xmlGenericError();
      v5 = __xmlGenericErrorContext();
      v4(*v5, "new fixed input: %.30s\n", (const char *)buffer);
    }
    v6 = xmlNewInputStream(ctxt);
    v7 = v6;
    if (v6)
    {
      v6->base = buffer;
      v6->cur = buffer;
      v8 = xmlStrlen(buffer);
      v7->length = v8;
      v7->end = &buffer[v8];
    }
    else
    {
      htmlErrMemory(ctxt, (const xmlChar *)"couldn't allocate a new input stream\n");
    }
  }
  else
  {
    xmlErrInternal(ctxt, "xmlNewStringInputStream string = NULL\n", 0);
    return 0;
  }
  return v7;
}

xmlParserInputPtr xmlNewInputFromFile(xmlParserCtxtPtr ctxt, const char *filename)
{
  xmlGenericErrorFunc v4;
  void **v5;
  xmlParserInputBufferPtr v6;
  xmlParserInputBuffer *v7;
  xmlParserInputPtr v8;
  xmlParserInputPtr v9;
  xmlParserInput *v10;
  const char *v11;
  xmlChar *v12;
  char *Directory;
  char *v14;
  const char *v15;
  xmlParserCtxtPtr v16;
  const char *v17;

  if (*__xmlParserDebugEntities())
  {
    v4 = *__xmlGenericError();
    v5 = __xmlGenericErrorContext();
    v4(*v5, "new input from file: %s\n", filename);
  }
  if (!ctxt)
    return 0;
  v6 = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
  if (!v6)
  {
    if (filename)
    {
      v15 = "failed to load external entity \"%s\"\n";
      v16 = ctxt;
      v17 = filename;
    }
    else
    {
      v15 = "failed to load external entity: NULL filename \n";
      v16 = ctxt;
      v17 = 0;
    }
    __xmlLoaderErr(v16, v15, (const xmlChar *)v17);
    return 0;
  }
  v7 = v6;
  v8 = xmlNewInputStream(ctxt);
  if (!v8)
  {
    xmlFreeParserInputBuffer(v7);
    return 0;
  }
  v8->buf = v7;
  v9 = xmlCheckHTTPInput(ctxt, v8);
  v10 = v9;
  if (v9)
  {
    v11 = v9->filename;
    if (!v11)
      v11 = filename;
    v12 = xmlStrdup((const xmlChar *)v11);
    Directory = xmlParserGetDirectory((const char *)v12);
    v14 = (char *)v10->filename;
    if (v14)
      xmlFree(v14);
    v10->filename = (const char *)xmlCanonicPath(v12);
    if (v12)
      xmlFree(v12);
    v10->directory = Directory;
    xmlBufResetInput((uint64_t *)v10->buf->buffer, v10);
    if (!ctxt->directory && Directory)
      ctxt->directory = (char *)xmlStrdup((const xmlChar *)Directory);
  }
  return v10;
}

void xmlClearParserCtxt(xmlParserCtxtPtr ctxt)
{
  xmlParserNodeInfoSeq *p_node_seq;
  xmlParserNodeInfo *buffer;

  if (ctxt)
  {
    p_node_seq = &ctxt->node_seq;
    buffer = ctxt->node_seq.buffer;
    if (buffer)
      xmlFree(buffer);
    p_node_seq->maximum = 0;
    p_node_seq->length = 0;
    p_node_seq->buffer = 0;
    xmlCtxtReset(ctxt);
  }
}

void xmlClearNodeInfoSeq(xmlParserNodeInfoSeqPtr seq)
{
  xmlParserNodeInfo *buffer;

  if (seq)
  {
    buffer = seq->buffer;
    if (buffer)
      xmlFree(buffer);
    seq->maximum = 0;
    seq->length = 0;
    seq->buffer = 0;
  }
}

const xmlParserNodeInfo *__cdecl xmlParserFindNodeInfo(const xmlParserCtxtPtr ctxt, const xmlNodePtr node)
{
  const xmlParserNodeInfo *result;
  unint64_t NodeInfoIndex;

  result = 0;
  if (ctxt)
  {
    if (node)
    {
      NodeInfoIndex = xmlParserFindNodeInfoIndex(&ctxt->node_seq, node);
      if (NodeInfoIndex >= ctxt->node_seq.length)
        return 0;
      result = &ctxt->node_seq.buffer[NodeInfoIndex];
      if (result->node != node)
        return 0;
    }
  }
  return result;
}

unint64_t xmlParserFindNodeInfoIndex(const xmlParserNodeInfoSeqPtr seq, const xmlNodePtr node)
{
  unint64_t length;
  unint64_t v3;
  unint64_t v4;
  const _xmlNode *v5;

  length = -1;
  if (seq)
  {
    if (node)
    {
      length = seq->length;
      if (length)
      {
        v3 = 1;
        do
        {
          v4 = v3 + ((length - v3) >> 1);
          v5 = seq->buffer[v4 - 1].node;
          if (v5 > node)
            length = v4 - 1;
          if (v5 < node)
            v3 = v4 + 1;
        }
        while (v3 <= length && v5 != node);
        if (v4)
        {
          if (seq->buffer[v4 - 1].node >= node)
            return v4 - 1;
          else
            return v4;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return length;
}

void xmlParserAddNodeInfo(xmlParserCtxtPtr ctxt, const xmlParserNodeInfoPtr info)
{
  xmlParserNodeInfoSeq *p_node_seq;
  const _xmlNode *node;
  unint64_t NodeInfoIndex;
  unint64_t v7;
  unint64_t length;
  xmlParserNodeInfo *buffer;
  xmlParserNodeInfo *v10;
  unint64_t maximum;
  xmlParserNodeInfo *v12;
  xmlParserNodeInfo *v13;
  unint64_t v14;
  xmlParserNodeInfo *v15;
  __int128 v16;
  xmlParserNodeInfo *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;

  if (!ctxt || !info)
    return;
  p_node_seq = &ctxt->node_seq;
  node = info->node;
  NodeInfoIndex = xmlParserFindNodeInfoIndex(&ctxt->node_seq, (const xmlNodePtr)info->node);
  v7 = NodeInfoIndex;
  length = ctxt->node_seq.length;
  if (NodeInfoIndex < length)
  {
    buffer = ctxt->node_seq.buffer;
    if (buffer)
    {
      v10 = &buffer[NodeInfoIndex];
      if (v10->node == node)
      {
        v20 = *(_OWORD *)&info->node;
        v21 = *(_OWORD *)&info->begin_line;
        v10->end_line = info->end_line;
        *(_OWORD *)&v10->node = v20;
        *(_OWORD *)&v10->begin_line = v21;
        return;
      }
    }
  }
  maximum = p_node_seq->maximum;
  if (length + 1 > p_node_seq->maximum || (v12 = ctxt->node_seq.buffer) == 0)
  {
    if (!maximum)
    {
      LODWORD(maximum) = 2;
      p_node_seq->maximum = 2;
    }
    v13 = ctxt->node_seq.buffer;
    if (v13)
    {
      v12 = (xmlParserNodeInfo *)xmlRealloc(v13, (80 * maximum));
      if (v12)
      {
LABEL_12:
        ctxt->node_seq.buffer = v12;
        length = ctxt->node_seq.length;
        ctxt->node_seq.maximum *= 2;
        goto LABEL_13;
      }
    }
    else
    {
      v12 = (xmlParserNodeInfo *)xmlMalloc((80 * maximum));
      if (v12)
        goto LABEL_12;
    }
    htmlErrMemory(ctxt, (const xmlChar *)"failed to allocate buffer\n");
    return;
  }
LABEL_13:
  if (length > v7)
  {
    v14 = length;
    do
    {
      v15 = &ctxt->node_seq.buffer[v14];
      --length;
      v16 = *(_OWORD *)&v15[-1].begin_line;
      *(_OWORD *)&v15->node = *(_OWORD *)&v15[-1].node;
      *(_OWORD *)&v15->begin_line = v16;
      v15->end_line = v15[-1].end_line;
      --v14;
    }
    while (length > v7);
    v12 = ctxt->node_seq.buffer;
  }
  v17 = &v12[v7];
  v18 = *(_OWORD *)&info->node;
  v19 = *(_OWORD *)&info->begin_line;
  v17->end_line = info->end_line;
  *(_OWORD *)&v17->node = v18;
  *(_OWORD *)&v17->begin_line = v19;
  ++ctxt->node_seq.length;
}

int xmlPedanticParserDefault(int val)
{
  int v2;

  v2 = *__xmlPedanticParserDefaultValue();
  *__xmlPedanticParserDefaultValue() = val;
  return v2;
}

int xmlLineNumbersDefault(int val)
{
  int v2;

  v2 = *__xmlLineNumbersDefaultValue();
  *__xmlLineNumbersDefaultValue() = val;
  return v2;
}

int xmlSubstituteEntitiesDefault(int val)
{
  int v2;

  v2 = *__xmlSubstituteEntitiesDefaultValue();
  *__xmlSubstituteEntitiesDefaultValue() = val;
  return v2;
}

int xmlKeepBlanksDefault(int val)
{
  int v2;

  v2 = *__xmlKeepBlanksDefaultValue();
  *__xmlKeepBlanksDefaultValue() = val;
  if (!val)
    *__xmlIndentTreeOutput() = 1;
  return v2;
}

void xmlFreePatternList(xmlPatternPtr comp)
{
  xmlPatternPtr v1;
  xmlPattern *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  xmlDict *v11;
  __int128 v12;

  if (comp)
  {
    v1 = comp;
    do
    {
      v2 = (xmlPattern *)*((_QWORD *)v1 + 2);
      *((_QWORD *)v1 + 2) = 0;
      v3 = *((_QWORD *)v1 + 7);
      if (v3)
        xmlFreeStreamComp(v3);
      v4 = (void *)*((_QWORD *)v1 + 3);
      if (v4)
        xmlFree(v4);
      v5 = (void *)*((_QWORD *)v1 + 6);
      if (v5)
      {
        if (!*((_QWORD *)v1 + 1) && *((int *)v1 + 9) >= 1)
        {
          v6 = 0;
          v7 = 0;
          do
          {
            v8 = *((_QWORD *)v1 + 6) + v6;
            v9 = *(void **)(v8 + 8);
            if (v9)
              xmlFree(v9);
            v10 = *(void **)(v8 + 16);
            if (v10)
              xmlFree(v10);
            ++v7;
            v6 += 24;
          }
          while (v7 < *((int *)v1 + 9));
          v5 = (void *)*((_QWORD *)v1 + 6);
        }
        xmlFree(v5);
      }
      v11 = (xmlDict *)*((_QWORD *)v1 + 1);
      if (v11)
        xmlDictFree(v11);
      *(_QWORD *)&v12 = -1;
      *((_QWORD *)&v12 + 1) = -1;
      *((_OWORD *)v1 + 2) = v12;
      *((_OWORD *)v1 + 3) = v12;
      *(_OWORD *)v1 = v12;
      *((_OWORD *)v1 + 1) = v12;
      xmlFree(v1);
      v1 = v2;
    }
    while (v2);
  }
}

void xmlFreeStreamCtxt(xmlStreamCtxtPtr stream)
{
  xmlStreamCtxtPtr v1;
  xmlStreamCtxt *v2;
  void *v3;

  if (stream)
  {
    v1 = stream;
    do
    {
      v2 = *(xmlStreamCtxt **)v1;
      v3 = (void *)*((_QWORD *)v1 + 4);
      if (v3)
        xmlFree(v3);
      xmlFree(v1);
      v1 = v2;
    }
    while (v2);
  }
}

int xmlStreamPush(xmlStreamCtxtPtr stream, const xmlChar *name, const xmlChar *ns)
{
  return xmlStreamPushInternal((uint64_t)stream, (xmlChar *)name, (xmlChar *)ns, 1);
}

uint64_t xmlStreamPushInternal(uint64_t a1, xmlChar *a2, xmlChar *a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  xmlChar *v7;
  xmlChar *v8;
  int v9;
  uint64_t v10;
  BOOL v11;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  unsigned int v28;
  int v29;
  const xmlChar *v30;
  const xmlChar *v31;
  int v32;
  int v33;
  int v34;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int *v41;
  unsigned int v42;
  const xmlChar *v43;
  const xmlChar *v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  xmlChar *str2;
  xmlChar *v63;
  unsigned int v64;

  if (!a1)
    return 0xFFFFFFFFLL;
  v4 = a1;
  v5 = 0xFFFFFFFFLL;
  if ((*(_DWORD *)(a1 + 16) & 0x80000000) == 0)
  {
    v7 = a3;
    v8 = a2;
    v9 = 0;
    v10 = 0;
    if (a2)
      v11 = 0;
    else
      v11 = a4 == 1;
    v13 = v11 && a3 == 0;
    v64 = a4 - 3;
    while (1)
    {
      v14 = 0;
      v15 = v10;
      v16 = v4;
      while (1)
      {
        v17 = *(_QWORD *)(v16 + 8);
        if (v13)
          break;
        if (*(_DWORD *)(v17 + 8))
        {
          if (*(_DWORD *)(v16 + 44) != -1 || v64 <= 0xFFFFFFFD && (*(_BYTE *)(v17 + 25) & 0x40) == 0)
          {
LABEL_79:
            ++*(_DWORD *)(v16 + 24);
            goto LABEL_17;
          }
          v60 = v10;
          v61 = v9;
          str2 = v8;
          v63 = v7;
          v19 = *(_DWORD *)(v16 + 16);
          if (v19 >= 1)
          {
            v20 = 0;
            v21 = *(_DWORD *)(v17 + 24);
            do
            {
              v22 = *(_QWORD *)(v16 + 32);
              if ((v21 & 0x10000) != 0)
              {
                v25 = *(unsigned int *)(v22 + 8 * v20);
                if ((v25 & 0x80000000) != 0)
                  goto LABEL_67;
                v34 = *(_DWORD *)(v22 + ((8 * v20) | 4));
                v24 = *(_DWORD *)(v16 + 24);
                if (v34 > v24)
                  goto LABEL_67;
                v26 = *(_QWORD *)(v17 + 16);
                if (v34 < v24 && (*(_DWORD *)(v26 + 32 * v25) & 1) == 0)
                  goto LABEL_67;
              }
              else
              {
                v23 = 2 * *(_DWORD *)(v16 + 16);
                v24 = *(_DWORD *)(v16 + 24);
                if (*(_DWORD *)(v22 + 4 * (v23 - 1)) < v24)
                  return 0xFFFFFFFFLL;
                LODWORD(v25) = *(_DWORD *)(v22 + 4 * (v23 - 2));
                v26 = *(_QWORD *)(v17 + 16);
                v20 = v19;
              }
              v27 = (int *)(v26 + 32 * (int)v25);
              v28 = *v27;
              v29 = v27[6];
              if (v29 == a4)
              {
                if (a4 != 100)
                {
                  v30 = (const xmlChar *)*((_QWORD *)v27 + 1);
                  v31 = (const xmlChar *)*((_QWORD *)v27 + 2);
                  if (v30)
                  {
                    v32 = 1;
                    if (!str2 || (v63 != 0) == (v31 == 0))
                      goto LABEL_60;
                    if (*v30 != *str2)
                      goto LABEL_59;
                    v56 = v14;
                    v57 = v15;
                    if (!xmlStrEqual(v30, str2))
                    {
                      v32 = 1;
                      v14 = v56;
                      v15 = v57;
                      goto LABEL_60;
                    }
                    LODWORD(v15) = v57;
                    if (v31 != v63)
                    {
                      v33 = xmlStrEqual(v31, v63);
                      v14 = v56;
                      v15 = v57;
                      if (!v33)
                        goto LABEL_59;
                    }
                  }
                  else if (v31)
                  {
                    if (!v63)
                      goto LABEL_59;
                    v58 = v15;
                    v36 = v14;
                    v37 = xmlStrEqual(*((const xmlChar **)v27 + 2), v63);
                    v15 = v58;
                    if (!v37)
                    {
                      v14 = v36;
LABEL_59:
                      v32 = 1;
                      goto LABEL_60;
                    }
                  }
                }
              }
              else if (v29 != 100)
              {
                if (v29 != 2 || (v21 & 0x10000) != 0)
                  goto LABEL_67;
LABEL_65:
                *(_DWORD *)(v16 + 44) = v24 + 1;
                goto LABEL_67;
              }
              if ((v28 & 2) != 0)
              {
                v32 = 0;
                v14 = v28 & 2;
                v15 = 1;
              }
              else
              {
                v38 = v25 + 1;
                v39 = v15;
                xmlStreamCtxtAddState(v16, v38, *(_DWORD *)(v16 + 24) + 1);
                v32 = 0;
                if (v39 == 1)
                  v15 = 1;
                else
                  v15 = (v28 >> 5) & 1;
                v14 = 0;
              }
LABEL_60:
              v21 = *(_DWORD *)(v17 + 24);
              if ((v21 & 0x10000) == 0)
              {
                if ((_DWORD)v14)
                  v32 = 1;
                if (v32 != 1)
                {
                  v14 = 0;
                  goto LABEL_67;
                }
                v24 = *(_DWORD *)(v16 + 24);
                goto LABEL_65;
              }
LABEL_67:
              ++v20;
            }
            while (v20 < v19);
          }
          v40 = *(_DWORD *)(v16 + 24);
          *(_DWORD *)(v16 + 24) = v40 + 1;
          v41 = *(int **)(v17 + 16);
          v42 = *v41;
          if ((*v41 & 4) != 0)
          {
            v9 = v61;
            v7 = v63;
          }
          else
          {
            v43 = (const xmlChar *)*((_QWORD *)v41 + 1);
            v44 = (const xmlChar *)*((_QWORD *)v41 + 2);
            v45 = v41[6];
            v46 = *(_DWORD *)(v16 + 40);
            v7 = v63;
            if ((v46 & 7) != 0)
            {
              if (v40)
              {
                if ((v42 & 1) == 0 && (v40 != 1 || (v46 & 6) == 0))
                  goto LABEL_96;
              }
              else if ((v46 & 6) != 0)
              {
                goto LABEL_96;
              }
            }
            if (v45 == a4)
            {
              if (a4 == 100)
                goto LABEL_94;
              if (v43)
              {
                if (!str2
                  || (v63 != 0) == (v44 == 0)
                  || *v43 != *str2
                  || (v47 = v15, v48 = xmlStrEqual(v43, str2), v15 = v47, !v48)
                  || v44 != v63 && (v49 = xmlStrEqual(v44, v63), v15 = v47, !v49))
                {
LABEL_105:
                  v14 = v42 & 2;
                  v50 = 1;
                  goto LABEL_106;
                }
LABEL_94:
                v14 = v42 & 2;
                if ((v42 & 2) != 0)
                {
LABEL_95:
                  v50 = 0;
                  v15 = 1;
                  goto LABEL_106;
                }
LABEL_102:
                v52 = v15;
                xmlStreamCtxtAddState(v16, 1, *(_DWORD *)(v16 + 24));
                v50 = 0;
                v14 = 0;
                if (v52 == 1)
                  v15 = 1;
                else
                  v15 = (v42 >> 5) & 1;
LABEL_106:
                v10 = v60;
                v9 = v61;
                v8 = str2;
              }
              else
              {
                if (!v44)
                  goto LABEL_94;
                if (!v63)
                  goto LABEL_105;
                v59 = v15;
                v51 = xmlStrEqual(v44, v63);
                v14 = v42 & 2;
                if (v51)
                {
                  LODWORD(v15) = v59;
                  if ((v42 & 2) != 0)
                    goto LABEL_95;
                  goto LABEL_102;
                }
                v50 = 1;
                v10 = v60;
                v9 = v61;
                v8 = str2;
                v15 = v59;
              }
              if ((*(_BYTE *)(v17 + 26) & 1) == 0)
              {
                if ((((_DWORD)v14 == 0) & ~v50) != 0)
                  v14 = 0;
                else
                  *(_DWORD *)(v16 + 44) = *(_DWORD *)(v16 + 24);
              }
              goto LABEL_17;
            }
            if (a4 != 2 && v45 == 100)
              goto LABEL_94;
LABEL_96:
            v9 = v61;
          }
          v8 = str2;
          v10 = v60;
          goto LABEL_17;
        }
        v18 = *(_DWORD *)(v16 + 40);
        if ((v18 & 1) == 0)
        {
          if (a4 != 2 && ((v18 & 7) == 0 || !*(_DWORD *)(v16 + 24)))
            v15 = 1;
          goto LABEL_79;
        }
LABEL_17:
        v16 = *(_QWORD *)v16;
        if (!v16)
        {
          LODWORD(v10) = v15;
LABEL_124:
          if (v9 > 0)
            return 0xFFFFFFFFLL;
          else
            return v10;
        }
      }
      *(_DWORD *)(v4 + 16) = 0;
      *(_DWORD *)(v4 + 24) = 0;
      *(_DWORD *)(v4 + 44) = -1;
      if ((*(_BYTE *)(v17 + 25) & 0x80) != 0)
      {
        v53 = *(_DWORD *)(v17 + 8);
        if (v53)
        {
          if (v53 != 1)
          {
            v54 = *(_QWORD *)(v17 + 16);
LABEL_119:
            if ((*(_BYTE *)v54 & 4) != 0)
              v9 += xmlStreamCtxtAddState(v4, 0, 0) >> 31;
            goto LABEL_121;
          }
          v54 = *(_QWORD *)(v17 + 16);
          if (*(_DWORD *)(v54 + 24) != 100 || (*(_BYTE *)v54 & 1) == 0)
            goto LABEL_119;
        }
        v10 = 1;
      }
LABEL_121:
      v4 = *(_QWORD *)v4;
      if (!v4)
        goto LABEL_124;
    }
  }
  return v5;
}

int xmlStreamPushAttr(xmlStreamCtxtPtr stream, const xmlChar *name, const xmlChar *ns)
{
  return xmlStreamPushInternal((uint64_t)stream, (xmlChar *)name, (xmlChar *)ns, 2);
}

int xmlStreamPop(xmlStreamCtxtPtr stream)
{
  int result;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  int v8;

  result = -1;
  if (stream)
  {
    do
    {
      v3 = *((_DWORD *)stream + 6);
      if (*((_DWORD *)stream + 11) == v3)
        *((_DWORD *)stream + 11) = -1;
      if (v3)
        *((_DWORD *)stream + 6) = --v3;
      v4 = *((unsigned int *)stream + 4);
      if ((int)v4 >= 1)
      {
        v5 = *((_QWORD *)stream + 4);
        v6 = v4 - 1;
        v7 = v4 + 1;
        v8 = 2 * v4 - 2;
        do
        {
          if (*(_DWORD *)(v5 + 4 * (v8 & 0xFFFFFFFE) + 4) <= v3)
            break;
          *((_DWORD *)stream + 4) = v6--;
          --v7;
          v8 -= 2;
        }
        while (v7 > 1);
      }
      stream = *(xmlStreamCtxtPtr *)stream;
    }
    while (stream);
    return 0;
  }
  return result;
}

int xmlStreamWantsAnyNode(xmlStreamCtxtPtr stream)
{
  if (stream)
  {
    while ((*(_BYTE *)(*((_QWORD *)stream + 1) + 25) & 0x40) == 0)
    {
      stream = *(xmlStreamCtxtPtr *)stream;
      if (!stream)
        return (int)stream;
    }
    LODWORD(stream) = 1;
  }
  else
  {
    LODWORD(stream) = -1;
  }
  return (int)stream;
}

xmlPatternPtr xmlPatterncompile(const xmlChar *pattern, xmlDict *dict, int flags, const xmlChar **namespaces)
{
  xmlChar *v4;
  unsigned int v5;
  xmlPattern *v7;
  uint64_t v8;
  xmlPattern *v9;
  _OWORD *v10;
  xmlChar *v11;
  xmlChar *v12;
  _OWORD *v13;
  uint64_t v14;
  void *v15;
  _BYTE *v16;
  _BYTE *i;
  uint64_t v18;
  uint64_t v19;
  _BYTE *k;
  uint64_t v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  BOOL v25;
  uint64_t v26;
  BOOL v27;
  unsigned __int8 *v28;
  uint64_t v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  _BYTE *v32;
  unsigned __int8 *n;
  unsigned int v34;
  uint64_t v35;
  _DWORD *v36;
  _BYTE *v37;
  uint64_t v38;
  unsigned __int8 *j;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  int v43;
  _OWORD *v44;
  uint64_t v45;
  xmlDict *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  _DWORD *v59;
  int v60;
  int v61;
  int v62;
  int v63;
  _DWORD *v64;
  uint64_t v65;
  _DWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _OWORD *v71;
  uint64_t v72;
  uint64_t v73;
  __int128 v74;
  int v75;
  _DWORD *v76;
  int v77;
  _DWORD *v78;
  _OWORD *v79;
  unsigned int v80;
  unsigned __int8 *m;
  uint64_t v82;
  unsigned __int8 *v83;
  _BYTE *v84;
  unsigned int v85;
  uint64_t v86;
  unsigned int v88;
  __int128 v89;
  xmlPattern *v91;
  uint64_t v92;
  unsigned int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  _BOOL4 v101;

  if (!pattern)
    return 0;
  v4 = (xmlChar *)pattern;
  v5 = *pattern;
  if (!*pattern)
    return 0;
  v7 = 0;
  v97 = flags & 6;
  v98 = 0;
  v95 = flags | 0x100;
  v96 = flags | 0x200;
  v94 = flags & 7;
  v101 = 1;
  do
  {
    v8 = 0;
    v9 = v7;
    if (v5)
    {
      while (v5 != 124)
      {
        v5 = v4[++v8];
        if (!v5)
          goto LABEL_7;
      }
      v12 = xmlStrndup(v4, v8);
      v11 = v12;
      if (v12)
        v10 = xmlNewPatParserContext(v12, (uint64_t)dict, (uint64_t *)namespaces);
      else
        v10 = 0;
      v4 += v8 + 1;
      if (!v10)
        goto LABEL_239;
    }
    else
    {
LABEL_7:
      v10 = xmlNewPatParserContext(v4, (uint64_t)dict, (uint64_t *)namespaces);
      v11 = 0;
      v4 += v8;
      if (!v10)
        goto LABEL_239;
    }
    v13 = xmlMalloc(0x40uLL);
    if (!v13)
      goto LABEL_238;
    v14 = (uint64_t)v13;
    v13[2] = 0u;
    v13[3] = 0u;
    *v13 = 0u;
    v13[1] = 0u;
    *((_DWORD *)v13 + 10) = 10;
    v15 = xmlMalloc(0xF0uLL);
    *(_QWORD *)(v14 + 48) = v15;
    if (!v15)
    {
      xmlFree((void *)v14);
      goto LABEL_238;
    }
    if (dict)
    {
      *(_QWORD *)(v14 + 8) = dict;
      xmlDictReference(dict);
    }
    v7 = (xmlPattern *)v14;
    if (v9)
    {
      *(_QWORD *)(v14 + 16) = *((_QWORD *)v9 + 2);
      *((_QWORD *)v9 + 2) = v14;
      v7 = v9;
    }
    *(_DWORD *)(v14 + 32) = flags;
    *((_QWORD *)v10 + 4) = v14;
    v16 = *(_BYTE **)v10;
    if (v97)
    {
      for (i = v16 + 1; ; ++i)
      {
        v18 = *v16;
        if (v18 > 0x2F)
          break;
        if (((1 << v18) & 0x100002600) == 0)
        {
          if (v18 == 47)
            goto LABEL_107;
          break;
        }
        *(_QWORD *)v10 = ++v16;
      }
      *(_DWORD *)(v14 + 32) = v96;
      if (*v16 == 46)
      {
        while (1)
        {
          *(_QWORD *)v10 = i;
          v19 = *i;
          if (v19 > 0x2F)
            break;
          if (((1 << v19) & 0x100002600) == 0)
          {
            if (*i)
            {
              if (v19 != 47)
                break;
              while (1)
              {
                *(_QWORD *)v10 = ++i;
                v23 = *i;
                if (v23 > 0x2F)
                  break;
                if (((1 << v23) & 0x100002600) == 0)
                {
                  if (v23 != 47)
                    break;
                  v24 = *(i - 1);
                  v25 = v24 > 0x20;
                  v26 = (1 << v24) & 0x100002600;
                  v27 = v25 || v26 == 0;
                  if (!v27 || xmlPatternAdd(v14, 6, 0, 0))
                    goto LABEL_107;
                  v28 = *(unsigned __int8 **)v10;
                  if (**(_BYTE **)v10)
                    goto LABEL_103;
                  while (1)
                  {
                    LODWORD(v23) = *v28;
                    if (v23 > 0x20 || ((1 << v23) & 0x100002600) == 0)
                      goto LABEL_82;
LABEL_103:
                    *(_QWORD *)v10 = ++v28;
                  }
                }
              }
LABEL_82:
              if (!(_DWORD)v23)
                break;
              goto LABEL_83;
            }
            if (xmlPatternAdd(v14, 2, 0, 0))
              break;
            goto LABEL_109;
          }
          ++i;
        }
      }
      else
      {
LABEL_83:
        xmlCompileStepPattern((uint64_t *)v10);
        v36 = v10 + 1;
        if (!*((_DWORD *)v10 + 4))
        {
LABEL_91:
          for (j = *(unsigned __int8 **)v10; ; *(_QWORD *)v10 = j)
          {
            v40 = *j++;
            if (v40 > 0x2F)
              break;
            if (((1 << v40) & 0x100002600) == 0)
            {
              if (!*(j - 1))
                goto LABEL_109;
              if (v40 != 47)
                goto LABEL_108;
              if (xmlPatternAdd(*((_QWORD *)v10 + 4), 5, 0, 0))
                goto LABEL_107;
              v37 = *(_BYTE **)v10;
              if (**(_BYTE **)v10)
                goto LABEL_85;
              while (1)
              {
                v38 = *v37;
                if (v38 > 0x2F)
                  goto LABEL_100;
                if (((1 << v38) & 0x100002600) == 0)
                  break;
LABEL_85:
                *(_QWORD *)v10 = ++v37;
              }
              if (!*v37 || v38 == 47)
                goto LABEL_107;
LABEL_100:
              xmlCompileStepPattern((uint64_t *)v10);
              if (!*((_DWORD *)v10 + 4))
                goto LABEL_91;
              goto LABEL_107;
            }
          }
          goto LABEL_108;
        }
      }
LABEL_107:
      v36 = v10 + 1;
LABEL_108:
      *v36 = 1;
      goto LABEL_109;
    }
    for (k = v16 + 1; ; ++k)
    {
      v21 = *(k - 1);
      if (v21 > 0x2F)
        break;
      if (((1 << v21) & 0x100002600) == 0)
      {
        if (v21 == 46)
        {
          v22 = v96;
          goto LABEL_51;
        }
        v22 = v95;
        if (v21 == 47)
          goto LABEL_51;
        break;
      }
      *(_QWORD *)v10 = k;
    }
    v22 = v96;
    if (!v94)
      goto LABEL_52;
LABEL_51:
    *(_DWORD *)(v14 + 32) = v22;
    LODWORD(v21) = *(k - 1);
LABEL_52:
    if ((_DWORD)v21 == 46)
    {
      if (*k != 47 || k[1] != 47)
        goto LABEL_207;
      if (xmlPatternAdd(v14, 6, 0, 0))
        goto LABEL_109;
      v30 = *(unsigned __int8 **)v10;
      if (**(_BYTE **)v10)
      {
        v31 = v30 + 1;
        *(_QWORD *)v10 = v30 + 1;
        if (v30[1])
        {
          v31 = v30 + 2;
          *(_QWORD *)v10 = v30 + 2;
          if (v30[2])
          {
            v30 += 3;
            goto LABEL_197;
          }
        }
        v30 = v31;
      }
      while (1)
      {
        LODWORD(v21) = *v30;
        if (v21 > 0x20)
          goto LABEL_67;
        if (((1 << v21) & 0x100002600) == 0)
          break;
        ++v30;
LABEL_197:
        *(_QWORD *)v10 = v30;
      }
      if (!*v30)
        goto LABEL_107;
    }
    else if ((_DWORD)v21 == 47)
    {
      v29 = v14;
      if (*k != 47)
        goto LABEL_70;
      if (xmlPatternAdd(v14, 6, 0, 0))
        goto LABEL_109;
      v21 = *(_QWORD *)v10;
      if (!**(_BYTE **)v10)
        goto LABEL_207;
      *(_QWORD *)v10 = v21 + 1;
      if (!*(_BYTE *)(v21 + 1))
        goto LABEL_207;
      v30 = (unsigned __int8 *)(v21 + 2);
      *(_QWORD *)v10 = v21 + 2;
      LODWORD(v21) = *(unsigned __int8 *)(v21 + 2);
    }
    else
    {
      v30 = k - 1;
    }
LABEL_67:
    if ((_DWORD)v21 != 64)
    {
      if ((_DWORD)v21 == 47)
      {
        v29 = *((_QWORD *)v10 + 4);
LABEL_70:
        if (xmlPatternAdd(v29, 1, 0, 0))
          goto LABEL_109;
        v32 = *(_BYTE **)v10;
        if (**(_BYTE **)v10)
          goto LABEL_203;
        while (1)
        {
          v80 = *v32;
          if (v80 > 0x20)
            goto LABEL_207;
          if (((1 << v80) & 0x100002600) == 0)
            break;
LABEL_203:
          *(_QWORD *)v10 = ++v32;
        }
        if (!*v32)
          goto LABEL_107;
      }
LABEL_207:
      xmlCompileStepPattern((uint64_t *)v10);
      v36 = v10 + 1;
      if (*((_DWORD *)v10 + 4))
        goto LABEL_109;
      for (m = *(unsigned __int8 **)v10; ; *(_QWORD *)v10 = m)
      {
        v35 = *m;
        if (v35 > 0x2F)
          goto LABEL_234;
        if (((1 << v35) & 0x100002600) == 0)
          break;
        ++m;
      }
      if (v35 == 47)
      {
        while (1)
        {
          v82 = *((_QWORD *)v10 + 4);
          if (m[1] == 47)
          {
            if (xmlPatternAdd(v82, 6, 0, 0))
              goto LABEL_109;
            v83 = *(unsigned __int8 **)v10;
            if (**(_BYTE **)v10)
            {
              *(_QWORD *)v10 = v83 + 1;
              if (v83[1])
              {
                v83 += 2;
                goto LABEL_222;
              }
              ++v83;
            }
            while (1)
            {
              v85 = *v83;
              v25 = v85 > 0x20;
              v86 = (1 << v85) & 0x100002600;
              if (v25 || v86 == 0)
                break;
              ++v83;
LABEL_222:
              *(_QWORD *)v10 = v83;
            }
            goto LABEL_232;
          }
          if (xmlPatternAdd(v82, 5, 0, 0))
            goto LABEL_109;
          v84 = *(_BYTE **)v10;
          if (**(_BYTE **)v10)
LABEL_228:
            *(_QWORD *)v10 = ++v84;
          v88 = *v84;
          if (v88 <= 0x20)
          {
            if (((1 << v88) & 0x100002600) == 0)
            {
              if (!*v84)
                goto LABEL_108;
              goto LABEL_232;
            }
            goto LABEL_228;
          }
LABEL_232:
          xmlCompileStepPattern((uint64_t *)v10);
          if (*((_DWORD *)v10 + 4))
            goto LABEL_109;
          m = *(unsigned __int8 **)v10;
          LODWORD(v35) = **(unsigned __int8 **)v10;
          if ((_DWORD)v35 != 47)
            goto LABEL_234;
        }
      }
      goto LABEL_234;
    }
    *(_QWORD *)v10 = v30 + 1;
    xmlCompileAttributeTest((uint64_t *)v10);
    for (n = *(unsigned __int8 **)v10; ; *(_QWORD *)v10 = n)
    {
      v34 = *n++;
      if (v34 > 0x20)
        break;
      if (((1 << v34) & 0x100002600) == 0)
      {
        if (!*(n - 1))
          goto LABEL_109;
        break;
      }
    }
    xmlCompileStepPattern((uint64_t *)v10);
    if (*((_DWORD *)v10 + 4))
      goto LABEL_109;
    LODWORD(v35) = **(unsigned __int8 **)v10;
LABEL_234:
    if ((_DWORD)v35)
      goto LABEL_107;
LABEL_109:
    if (*((_DWORD *)v10 + 4))
    {
      v9 = v7;
LABEL_238:
      *(_QWORD *)&v89 = -1;
      *((_QWORD *)&v89 + 1) = -1;
      v10[2] = v89;
      v10[3] = v89;
      *v10 = v89;
      v10[1] = v89;
      xmlFree(v10);
LABEL_239:
      v7 = v9;
      if (v9)
LABEL_240:
        xmlFreePatternList(v7);
      if (v11)
        xmlFree(v11);
      return 0;
    }
    *(_QWORD *)&v41 = -1;
    *((_QWORD *)&v41 + 1) = -1;
    v10[2] = v41;
    v10[3] = v41;
    *v10 = v41;
    v10[1] = v41;
    xmlFree(v10);
    if (v101)
    {
      if (v98 == 512)
      {
        v61 = *(_DWORD *)(v14 + 32);
        v101 = !(v61 & 0x100);
        v98 = 512;
        if ((v61 & 0x100) != 0)
          goto LABEL_168;
      }
      else if (v98 == 256)
      {
        v101 = (*(_DWORD *)(v14 + 32) & 0x200) == 0;
        v98 = 256;
        if ((*(_DWORD *)(v14 + 32) & 0x200) != 0)
          goto LABEL_168;
      }
      else
      {
        if (!v98)
          v98 = *(_DWORD *)(v14 + 32) & 0x300;
        v101 = 1;
      }
      v42 = *(_QWORD *)(v14 + 48);
      if (v42)
      {
        v43 = *(_DWORD *)(v14 + 36);
        if (v43 == 1 && *(_DWORD *)v42 == 2 && !*(_QWORD *)(v42 + 8) && !*(_QWORD *)(v42 + 16))
        {
          v79 = xmlNewStreamComp(0);
          if (v79)
          {
            *((_DWORD *)v79 + 6) |= 0x4000u;
            *(_QWORD *)(v14 + 56) = v79;
          }
        }
        else
        {
          v44 = xmlNewStreamComp(v43 / 2 + 1);
          if (v44)
          {
            v45 = (uint64_t)v44;
            v46 = *(xmlDict **)(v14 + 8);
            if (v46)
            {
              *(_QWORD *)v45 = v46;
              xmlDictReference(v46);
            }
            v47 = *(_DWORD *)(v14 + 32);
            if ((v47 & 0x100) != 0)
              *(_DWORD *)(v45 + 24) |= 0x8000u;
            LODWORD(v48) = *(_DWORD *)(v14 + 36);
            if ((int)v48 < 1)
            {
              v52 = 0;
LABEL_162:
              if ((v47 & 7) != 0)
              {
                v62 = *(_DWORD *)(v45 + 8);
              }
              else
              {
                v77 = *(_DWORD *)(v45 + 24);
                if ((v77 & 0x10000) == 0)
                  *(_DWORD *)(v45 + 24) = v77 | 0x10000;
                v62 = *(_DWORD *)(v45 + 8);
                if (v62 >= 1)
                {
                  v78 = *(_DWORD **)(v45 + 16);
                  if ((*v78 & 1) == 0)
                    *v78 |= 1u;
                }
              }
              if (v62 <= v52)
              {
LABEL_167:
                xmlFreeStreamComp(v45);
                goto LABEL_168;
              }
              v59 = (_DWORD *)(*(_QWORD *)(v45 + 16) + 32 * v52);
              v60 = 2;
            }
            else
            {
              v49 = 0;
              v50 = 0;
              v51 = 0;
              v52 = 0;
              v53 = -1;
              do
              {
                while (2)
                {
                  v54 = *(_QWORD *)(v14 + 48) + 24 * v49;
                  if (*(_DWORD *)v54 != 1)
                  {
                    switch(*(_DWORD *)v54)
                    {
                      case 2:
                        v55 = *(_QWORD *)(v54 + 8);
                        v56 = *(_QWORD *)(v54 + 16);
                        if (*(_OWORD *)(v54 + 8) != 0)
                          goto LABEL_140;
                        if (v49 + 1 != v48 || (v50 & 1) == 0)
                          goto LABEL_152;
                        *(_DWORD *)(v45 + 24) |= 0x4000u;
                        v93 = v53;
                        v52 = xmlStreamCompAddStep(v45, 0, 0, 100, v50 | 0x10u);
                        if (v52 < 0)
                          goto LABEL_167;
                        if (v93 == -1)
                          goto LABEL_142;
                        v50 = 0;
                        *(_DWORD *)(*(_QWORD *)(v45 + 16) + 32 * v93) |= 0x20u;
                        goto LABEL_143;
                      case 3:
                        v55 = *(_QWORD *)(v54 + 8);
                        v56 = *(_QWORD *)(v54 + 16);
LABEL_140:
                        v57 = v45;
                        goto LABEL_150;
                      case 4:
                        v52 = xmlStreamCompAddStep(v45, *(_QWORD *)(v54 + 8), *(_QWORD *)(v54 + 16), 2, v50 | 8u);
                        if (v52 < 0)
                          goto LABEL_167;
LABEL_142:
                        v50 = 0;
LABEL_143:
                        v53 = -1;
                        goto LABEL_152;
                      case 6:
                        if ((v50 & 1) == 0)
                        {
                          v58 = *(_DWORD *)(v45 + 24);
                          if ((v58 & 0x10000) == 0)
                            *(_DWORD *)(v45 + 24) = v58 | 0x10000;
                          v50 = 1;
                        }
                        goto LABEL_152;
                      case 7:
                        v56 = *(_QWORD *)(v54 + 8);
                        v57 = v45;
                        v55 = 0;
                        goto LABEL_150;
                      case 8:
                        v57 = v45;
                        v55 = 0;
                        v56 = 0;
LABEL_150:
                        v52 = xmlStreamCompAddStep(v57, v55, v56, 1, v50);
                        if (v52 < 0)
                          goto LABEL_167;
                        v50 = 0;
                        v53 = v52;
LABEL_152:
                        ++v49;
                        v48 = *(int *)(v14 + 36);
                        if (v49 < v48)
                          continue;
                        if (v51)
                          goto LABEL_154;
                        v47 = *(_DWORD *)(v14 + 32);
                        break;
                      default:
                        goto LABEL_152;
                    }
                    goto LABEL_162;
                  }
                  break;
                }
                if (v49)
                  goto LABEL_167;
                v49 = 1;
                v51 = 1;
              }
              while ((int)v48 > 1);
LABEL_154:
              if (*(_DWORD *)(v45 + 8) <= v52)
                goto LABEL_167;
              v59 = *(_DWORD **)(v45 + 16);
              v59[8 * v52] |= 2u;
              v60 = 4;
            }
            *v59 |= v60;
            *(_QWORD *)(v14 + 56) = v45;
          }
        }
      }
    }
    else
    {
      v101 = 0;
    }
LABEL_168:
    v63 = *(_DWORD *)(v14 + 36);
    v64 = *(_DWORD **)(v14 + 48);
    v65 = (v63 - 1);
    if (v63 >= 1 && *v64 == 6)
    {
      if (v63 < 2)
      {
        LODWORD(v65) = 0;
      }
      else
      {
        v66 = v64 + 6;
        v67 = v65;
        do
        {
          *((_OWORD *)v66 - 1) = *(_OWORD *)(v66 + 2);
          *(v66 - 6) = *v66;
          v66 += 6;
          --v67;
        }
        while (v67);
      }
      *(_DWORD *)(v14 + 36) = v65;
      v63 = v65;
    }
    v68 = *(int *)(v14 + 40);
    if (v63 >= (int)v68)
    {
      v64 = xmlRealloc(v64, 48 * v68);
      if (!v64)
        goto LABEL_240;
      *(_QWORD *)(v14 + 48) = v64;
      v63 = *(_DWORD *)(v14 + 36);
      *(_DWORD *)(v14 + 40) *= 2;
    }
    if (v63 <= 1)
    {
      v70 = v63;
    }
    else
    {
      v69 = 0;
      v70 = v63;
      v71 = v64 + 2;
      v72 = v63 - 2;
      v73 = (uint64_t)&v64[6 * v63 - 6];
      do
      {
        v74 = *v71;
        *v71 = *(_OWORD *)(v73 + 8);
        *(_OWORD *)(v73 + 8) = v74;
        v75 = *((_DWORD *)v71 - 2);
        *((_DWORD *)v71 - 2) = *(_DWORD *)v73;
        *(_DWORD *)v73 = v75;
        v73 -= 24;
        ++v69;
        v71 = (_OWORD *)((char *)v71 + 24);
        v25 = v72-- <= v69;
      }
      while (!v25);
    }
    v76 = &v64[6 * v70];
    *((_QWORD *)v76 + 1) = 0;
    *((_QWORD *)v76 + 2) = 0;
    *(_DWORD *)(v14 + 36) = v63 + 1;
    *v76 = 0;
    if (v11)
      xmlFree(v11);
    v5 = *v4;
  }
  while (*v4);
  if (!v101)
  {
    v91 = v7;
    do
    {
      v92 = *((_QWORD *)v91 + 7);
      if (v92)
      {
        xmlFreeStreamComp(v92);
        *((_QWORD *)v91 + 7) = 0;
      }
      v91 = (xmlPattern *)*((_QWORD *)v91 + 2);
    }
    while (v91);
  }
  return v7;
}

_OWORD *xmlNewPatParserContext(_OWORD *result, uint64_t a2, uint64_t *a3)
{
  _OWORD *v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;

  if (result)
  {
    v5 = result;
    result = xmlMalloc(0x40uLL);
    if (result)
    {
      *result = 0u;
      result[1] = 0u;
      result[2] = 0u;
      result[3] = 0u;
      *((_QWORD *)result + 3) = a2;
      *(_QWORD *)result = v5;
      *((_QWORD *)result + 1) = v5;
      if (a3)
      {
        v6 = -1;
        v7 = a3;
        do
        {
          v8 = *v7;
          v7 += 2;
          ++v6;
        }
        while (v8);
      }
      else
      {
        v6 = 0;
      }
      *((_DWORD *)result + 14) = v6;
      *((_QWORD *)result + 6) = a3;
    }
  }
  return result;
}

void xmlFreeStreamComp(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 16);
  if (v2)
    xmlFree(v2);
  if (*(_QWORD *)a1)
    xmlDictFree(*(xmlDictPtr *)a1);
  xmlFree((void *)a1);
}

xmlStreamCtxtPtr xmlPatternGetStreamCtxt(xmlStreamCtxtPtr comp)
{
  xmlStreamCtxtPtr v1;
  xmlStreamCtxtPtr v2;
  uint64_t v3;
  _OWORD *v4;
  _QWORD *v5;
  void *v6;
  xmlStreamCtxt *v7;
  void *v8;

  if (comp)
  {
    v1 = comp;
    if (*((_QWORD *)comp + 7))
    {
      v2 = 0;
      while (1)
      {
        v3 = *((_QWORD *)v1 + 7);
        if (!v3)
          break;
        v4 = xmlMalloc(0x30uLL);
        if (!v4)
          break;
        v5 = v4;
        v4[1] = 0u;
        v4[2] = 0u;
        *v4 = 0u;
        v6 = xmlMalloc(0x20uLL);
        v5[4] = v6;
        if (!v6)
        {
          xmlFree(v5);
          break;
        }
        v5[2] = 0x400000000;
        *((_DWORD *)v5 + 6) = 0;
        v5[1] = v3;
        comp = (xmlStreamCtxtPtr)v5;
        *((_DWORD *)v5 + 11) = -1;
        if (v2)
        {
          *v5 = *(_QWORD *)v2;
          *(_QWORD *)v2 = v5;
          comp = v2;
        }
        *((_DWORD *)v5 + 10) = *((_DWORD *)v1 + 8);
        v1 = (xmlStreamCtxtPtr)*((_QWORD *)v1 + 2);
        v2 = comp;
        if (!v1)
          return comp;
      }
      if (v2)
      {
        do
        {
          v7 = *(xmlStreamCtxt **)v2;
          v8 = (void *)*((_QWORD *)v2 + 4);
          if (v8)
            xmlFree(v8);
          xmlFree(v2);
          v2 = v7;
        }
        while (v7);
      }
    }
    return 0;
  }
  return comp;
}

int xmlPatternStreamable(xmlPatternPtr comp)
{
  if (!comp)
    return -1;
  while (*((_QWORD *)comp + 7))
  {
    comp = (xmlPatternPtr)*((_QWORD *)comp + 2);
    if (!comp)
      return 1;
  }
  return 0;
}

int xmlPatternMaxDepth(xmlPatternPtr comp)
{
  xmlPatternPtr v1;
  int result;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  char v7;

  if (comp)
  {
    v1 = comp;
    result = 0;
    while (1)
    {
      v3 = *((_QWORD *)v1 + 7);
      if (!v3)
        break;
      v4 = *(unsigned int *)(v3 + 8);
      if ((int)v4 >= 1)
      {
        v5 = *(char **)(v3 + 16);
        v6 = v4;
        do
        {
          v7 = *v5;
          v5 += 32;
          if ((v7 & 1) != 0)
            return -2;
        }
        while (--v6);
      }
      if ((int)v4 > result)
        result = v4;
      v1 = (xmlPatternPtr)*((_QWORD *)v1 + 2);
      if (!v1)
        return result;
    }
  }
  return -1;
}

int xmlPatternMinDepth(xmlPatternPtr comp)
{
  xmlPatternPtr v1;
  int result;
  uint64_t v3;
  int v4;

  if (comp)
  {
    v1 = comp;
    result = 12345678;
    while (1)
    {
      v3 = *((_QWORD *)v1 + 7);
      if (!v3)
        break;
      v4 = *(_DWORD *)(v3 + 8);
      if (v4 < result)
        result = v4;
      if (result)
      {
        v1 = (xmlPatternPtr)*((_QWORD *)v1 + 2);
        if (v1)
          continue;
      }
      return result;
    }
  }
  return -1;
}

int xmlPatternFromRoot(xmlPatternPtr comp)
{
  if (comp)
  {
    while (*((_QWORD *)comp + 7))
    {
      if ((*((_BYTE *)comp + 33) & 1) != 0)
      {
        LODWORD(comp) = 1;
        return (int)comp;
      }
      comp = (xmlPatternPtr)*((_QWORD *)comp + 2);
      if (!comp)
        return (int)comp;
    }
  }
  LODWORD(comp) = -1;
  return (int)comp;
}

uint64_t xmlStreamCtxtAddState(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  uint64_t result;
  _DWORD *v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;

  v6 = *(unsigned int *)(a1 + 16);
  if ((int)v6 < 1)
  {
LABEL_5:
    v9 = *(int *)(a1 + 20);
    if ((int)v6 >= (int)v9)
    {
      v10 = xmlRealloc(*(void **)(a1 + 32), 16 * v9);
      if (!v10)
        return 0xFFFFFFFFLL;
      *(_QWORD *)(a1 + 32) = v10;
      LODWORD(v6) = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) *= 2;
    }
    else
    {
      v10 = *(_DWORD **)(a1 + 32);
    }
    v10[2 * (_DWORD)v6] = a2;
    v11 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v11 + 1;
    v10[(2 * v11) | 1] = a3;
    return (*(_DWORD *)(a1 + 16) - 1);
  }
  result = 0;
  v8 = *(_DWORD **)(a1 + 32);
  while ((*v8 & 0x80000000) == 0)
  {
    ++result;
    v8 += 2;
    if (v6 == result)
      goto LABEL_5;
  }
  *v8 = a2;
  v8[1] = a3;
  return result;
}

uint64_t xmlPatternAdd(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;

  v8 = *(_DWORD *)(a1 + 36);
  v9 = *(int *)(a1 + 40);
  if (v8 >= (int)v9)
  {
    v10 = (char *)xmlRealloc(*(void **)(a1 + 48), 48 * v9);
    if (!v10)
      return 0xFFFFFFFFLL;
    *(_QWORD *)(a1 + 48) = v10;
    v8 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 40) *= 2;
  }
  else
  {
    v10 = *(char **)(a1 + 48);
  }
  v11 = 0;
  v12 = &v10[24 * v8];
  *(_DWORD *)v12 = a2;
  *((_QWORD *)v12 + 1) = a3;
  *((_QWORD *)v12 + 2) = a4;
  *(_DWORD *)(a1 + 36) = v8 + 1;
  return v11;
}

void xmlCompileStepPattern(uint64_t *a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  int v5;
  const xmlChar *v6;
  uint64_t v7;
  unsigned int v8;
  xmlChar *v9;
  unsigned __int8 *v11;
  unsigned int v12;
  char v13;
  unsigned __int8 *v14;
  unsigned int v15;
  xmlChar *v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  char v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  xmlDict *v28;
  unsigned __int8 *v29;
  void *v30;
  uint64_t v31;
  int v32;
  xmlDict *v33;
  unsigned __int8 *v34;
  void *v35;
  xmlDict *v36;
  void *v37;
  xmlDict *v38;
  void *v39;

  for (i = *a1 + 1; ; ++i)
  {
    v3 = *(unsigned __int8 *)(i - 1) - 9;
    if (v3 > 0x37)
      goto LABEL_12;
    if (((1 << (*(_BYTE *)(i - 1) - 9)) & 0x800013) == 0)
      break;
    *a1 = i;
  }
  if (v3 == 37)
  {
    *a1 = i;
    v4 = a1[4];
    v5 = 2;
LABEL_11:
    xmlPatternAdd(v4, v5, 0, 0);
    return;
  }
  if (v3 == 55)
  {
    if ((*(_BYTE *)(a1[4] + 32) & 2) == 0)
    {
      *a1 = i;
LABEL_9:
      xmlCompileAttributeTest(a1);
      return;
    }
    goto LABEL_65;
  }
LABEL_12:
  v6 = (const xmlChar *)xmlPatScanNCName((const xmlChar **)a1);
  v7 = *a1;
  v8 = *(unsigned __int8 *)*a1;
  if (!v6)
  {
    if (v8 == 42)
    {
      v14 = (unsigned __int8 *)(v7 + 1);
LABEL_24:
      *a1 = (uint64_t)v14;
      v4 = a1[4];
      v5 = 8;
      goto LABEL_11;
    }
LABEL_65:
    *((_DWORD *)a1 + 4) = 1;
    return;
  }
  v9 = (xmlChar *)v6;
  if (v8 > 0x20 || ((1 << v8) & 0x100002600) == 0)
  {
    v13 = 0;
  }
  else
  {
    v11 = (unsigned __int8 *)(v7 + 1);
    while (v8 <= 0x20 && ((1 << v8) & 0x100002600) != 0)
    {
      *a1 = (uint64_t)v11;
      v12 = *v11++;
      v8 = v12;
    }
    v7 = (uint64_t)(v11 - 1);
    v13 = 1;
  }
  if (v8 == 42)
  {
LABEL_59:
    *((_DWORD *)a1 + 4) = 1;
    goto LABEL_60;
  }
  if (v8 != 58)
  {
    if (!xmlPatternAdd(a1[4], 2, (uint64_t)v6, 0))
      return;
LABEL_60:
    if (!v9)
      return;
    goto LABEL_61;
  }
  *a1 = v7 + 1;
  v15 = *(unsigned __int8 *)(v7 + 1);
  if (v15 != 58)
  {
    if (v15 == 32)
      v20 = 1;
    else
      v20 = v13;
    if ((v20 & 1) == 0 && (v15 > 0xD || ((1 << v15) & 0x2600) == 0))
    {
      v21 = xmlPatScanName((const xmlChar **)a1);
      if (*v9 == 120 && v9[1] == 109 && v9[2] == 108 && !v9[3])
      {
        v36 = *(xmlDict **)(a1[4] + 8);
        if (v36)
          v37 = (void *)xmlDictLookup(v36, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", -1);
        else
          v37 = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        v25 = v37;
      }
      else
      {
        if (*((int *)a1 + 14) < 1)
        {
          LODWORD(v23) = 0;
LABEL_70:
          v25 = 0;
        }
        else
        {
          v22 = 0;
          v23 = 0;
          while (!xmlStrEqual(*(const xmlChar **)(a1[6] + v22 + 8), v9))
          {
            ++v23;
            v22 += 16;
            if (v23 >= *((int *)a1 + 14))
              goto LABEL_70;
          }
          v28 = *(xmlDict **)(a1[4] + 8);
          v29 = (unsigned __int8 *)a1[6];
          if (v28)
            v30 = (void *)xmlDictLookup(v28, *(const xmlChar **)&v29[v22], -1);
          else
            v30 = xmlStrdup(*(const xmlChar **)&v29[v22]);
          v25 = v30;
        }
        if ((int)v23 >= *((_DWORD *)a1 + 14))
          goto LABEL_108;
      }
      if (!*(_QWORD *)(a1[4] + 8))
        xmlFree(v9);
      if (v21)
      {
        v31 = a1[4];
        v32 = 2;
LABEL_102:
        if (!xmlPatternAdd(v31, v32, (uint64_t)v21, (uint64_t)v25))
          return;
        v9 = 0;
        goto LABEL_109;
      }
      goto LABEL_104;
    }
    goto LABEL_59;
  }
  *a1 = v7 + 2;
  if (!xmlStrEqual(v6, (const xmlChar *)"child"))
  {
    if (xmlStrEqual(v9, (const xmlChar *)"attribute"))
    {
      v24 = (unsigned __int8 *)a1[4];
      if (!*((_QWORD *)v24 + 1))
      {
        xmlFree(v9);
        v24 = (unsigned __int8 *)a1[4];
      }
      if ((v24[32] & 2) == 0)
        goto LABEL_9;
      goto LABEL_65;
    }
    goto LABEL_59;
  }
  if (!*(_QWORD *)(a1[4] + 8))
    xmlFree(v9);
  v16 = (xmlChar *)xmlPatScanName((const xmlChar **)a1);
  v17 = *a1;
  v18 = *(unsigned __int8 *)*a1;
  if (!v16)
  {
    if (v18 == 42)
    {
      v14 = (unsigned __int8 *)(v17 + 1);
      goto LABEL_24;
    }
    goto LABEL_65;
  }
  v9 = v16;
  if (v18 != 58)
  {
    if (!xmlPatternAdd(a1[4], 3, (uint64_t)v16, 0))
      return;
    goto LABEL_61;
  }
  *a1 = v17 + 1;
  v19 = *(unsigned __int8 *)(v17 + 1);
  if (v19 > 0x20 || ((1 << v19) & 0x100002600) == 0)
  {
    v21 = xmlPatScanName((const xmlChar **)a1);
    if (*v9 == 120 && v9[1] == 109 && v9[2] == 108 && !v9[3])
    {
      v38 = *(xmlDict **)(a1[4] + 8);
      if (v38)
        v39 = (void *)xmlDictLookup(v38, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", -1);
      else
        v39 = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      v25 = v39;
      goto LABEL_98;
    }
    if (*((int *)a1 + 14) < 1)
    {
      LODWORD(v27) = 0;
LABEL_90:
      v25 = 0;
    }
    else
    {
      v26 = 0;
      v27 = 0;
      while (!xmlStrEqual(*(const xmlChar **)(a1[6] + v26 + 8), v9))
      {
        ++v27;
        v26 += 16;
        if (v27 >= *((int *)a1 + 14))
          goto LABEL_90;
      }
      v33 = *(xmlDict **)(a1[4] + 8);
      v34 = (unsigned __int8 *)a1[6];
      if (v33)
        v35 = (void *)xmlDictLookup(v33, *(const xmlChar **)&v34[v26], -1);
      else
        v35 = xmlStrdup(*(const xmlChar **)&v34[v26]);
      v25 = v35;
    }
    if ((int)v27 < *((_DWORD *)a1 + 14))
    {
LABEL_98:
      if (!*(_QWORD *)(a1[4] + 8))
        xmlFree(v9);
      if (v21)
      {
        v31 = a1[4];
        v32 = 3;
        goto LABEL_102;
      }
LABEL_104:
      if (*(_BYTE *)*a1 == 42)
      {
        ++*a1;
        v21 = 0;
        v9 = 0;
        if (!xmlPatternAdd(a1[4], 7, (uint64_t)v25, 0))
          return;
        goto LABEL_109;
      }
      v21 = 0;
      v9 = 0;
    }
LABEL_108:
    *((_DWORD *)a1 + 4) = 1;
LABEL_109:
    if (v25 && !*(_QWORD *)(a1[4] + 8))
      xmlFree(v25);
    if (v21 && !*(_QWORD *)(a1[4] + 8))
      xmlFree(v21);
    goto LABEL_60;
  }
  *((_DWORD *)a1 + 4) = 1;
LABEL_61:
  if (!*(_QWORD *)(a1[4] + 8))
    xmlFree(v9);
}

void xmlCompileAttributeTest(uint64_t *a1)
{
  uint64_t i;
  unsigned int v3;
  BOOL v4;
  uint64_t v5;
  xmlChar *v7;
  const xmlChar *v8;
  int v9;
  xmlChar *v10;
  unsigned int v11;
  uint64_t v12;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  xmlDict *v18;
  unsigned __int8 *v19;
  void *v20;
  xmlDict *v21;
  void *v22;

  for (i = *a1 + 1; ; ++i)
  {
    v3 = *(unsigned __int8 *)(i - 1);
    v4 = v3 > 0x20;
    v5 = (1 << v3) & 0x100002600;
    if (v4 || v5 == 0)
      break;
    *a1 = i;
  }
  v7 = (xmlChar *)xmlPatScanNCName((const xmlChar **)a1);
  v8 = (const xmlChar *)*a1;
  v9 = *(unsigned __int8 *)*a1;
  if (v7)
  {
    v10 = v7;
    if (v9 != 58)
    {
      xmlPatternAdd(a1[4], 4, (uint64_t)v7, 0);
      return;
    }
    *a1 = (uint64_t)(v8 + 1);
    v11 = v8[1];
    v4 = v11 > 0x20;
    v12 = (1 << v11) & 0x100002600;
    if (!v4 && v12 != 0)
    {
      if (!*(_QWORD *)(a1[4] + 8))
        xmlFree(v7);
      goto LABEL_19;
    }
    v14 = xmlPatScanName((const xmlChar **)a1);
    if (*v10 == 120 && v10[1] == 109 && v10[2] == 108 && !v10[3])
    {
      v21 = *(xmlDict **)(a1[4] + 8);
      if (v21)
        v22 = (void *)xmlDictLookup(v21, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", -1);
      else
        v22 = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      v17 = v22;
    }
    else
    {
      if (*((int *)a1 + 14) < 1)
      {
        LODWORD(v16) = 0;
LABEL_32:
        v17 = 0;
      }
      else
      {
        v15 = 0;
        v16 = 0;
        while (!xmlStrEqual(*(const xmlChar **)(a1[6] + v15 + 8), v10))
        {
          ++v16;
          v15 += 16;
          if (v16 >= *((int *)a1 + 14))
            goto LABEL_32;
        }
        v18 = *(xmlDict **)(a1[4] + 8);
        v19 = (unsigned __int8 *)a1[6];
        if (v18)
          v20 = (void *)xmlDictLookup(v18, *(const xmlChar **)&v19[v15], -1);
        else
          v20 = xmlStrdup(*(const xmlChar **)&v19[v15]);
        v17 = v20;
      }
      if ((int)v16 >= *((_DWORD *)a1 + 14))
      {
        if (!*(_QWORD *)(a1[4] + 8))
          xmlFree(v10);
        goto LABEL_49;
      }
    }
    if (!*(_QWORD *)(a1[4] + 8))
      xmlFree(v10);
    if (v14)
    {
      if (!xmlPatternAdd(a1[4], 4, (uint64_t)v14, (uint64_t)v17))
        return;
      goto LABEL_50;
    }
    if (*(_BYTE *)*a1 == 42)
    {
      ++*a1;
      v14 = 0;
      if (!xmlPatternAdd(a1[4], 4, 0, (uint64_t)v17))
        return;
      goto LABEL_50;
    }
    v14 = 0;
LABEL_49:
    *((_DWORD *)a1 + 4) = 1;
LABEL_50:
    if (v17 && !*(_QWORD *)(a1[4] + 8))
      xmlFree(v17);
    if (v14 && !*(_QWORD *)(a1[4] + 8))
      xmlFree(v14);
    return;
  }
  if (v9 != 42)
  {
LABEL_19:
    *((_DWORD *)a1 + 4) = 1;
    return;
  }
  if (!xmlPatternAdd(a1[4], 4, 0, 0) && *(_BYTE *)*a1)
    ++*a1;
}

void *xmlPatScanNCName(const xmlChar **a1)
{
  const xmlChar *v2;
  const xmlChar *v3;
  unsigned int v4;
  uint64_t v5;
  signed int v7;
  signed int v8;
  void *result;
  BOOL v10;
  const xmlChar *i;
  BOOL v14;
  BOOL v16;
  xmlDict *v17;
  int len;

  len = 0;
  v2 = *a1;
  v3 = *a1;
  while (1)
  {
    v4 = *v3;
    v10 = v4 > 0x20;
    v5 = (1 << v4) & 0x100002600;
    if (v10 || v5 == 0)
      break;
    *a1 = ++v3;
    LODWORD(v2) = (_DWORD)v2 + 1;
  }
  v7 = xmlStringCurrentChar(0, v3, &len);
  v8 = v7;
  if (v7 > 255)
  {
    if (xmlCharInRange(v7, &xmlIsBaseCharGroup))
      v10 = 1;
    else
      v10 = (v8 - 12330) > 0xFFFFFFF6;
    if (!v10 && v8 != 12295 && (v8 - 40870) < 0xFFFFAE5A)
      return 0;
  }
  else if ((v7 - 192) >= 0x17
         && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
         && v7 != 95
         && v7 <= 247
         && (v7 - 216) >= 0x1F)
  {
    return 0;
  }
  for (i = v3; ; v8 = xmlStringCurrentChar(0, i, &len))
  {
    if (v8 > 255)
    {
      if (xmlCharInRange(v8, &xmlIsBaseCharGroup))
        v14 = 0;
      else
        v14 = (v8 - 12321) >= 9;
      v16 = v14 && v8 != 12295 && (v8 - 19968) >= 0x51A6;
      if (!v16 || xmlCharInRange(v8, &xmlIsDigitGroup))
        goto LABEL_47;
    }
    else if ((v8 - 192) < 0x17
           || (v8 & 0xFFFFFFDF) - 65 < 0x1A
           || (v8 - 48) < 0xA
           || v8 > 247
           || (v8 - 216) < 0x1F)
    {
      goto LABEL_47;
    }
    if ((v8 - 45) <= 0x32 && ((1 << (v8 - 45)) & 0x4000000000003) != 0)
      goto LABEL_47;
    if (v8 >= 256)
      break;
    if (v8 != 183)
      goto LABEL_53;
LABEL_47:
    i += len;
  }
  if (xmlCharInRange(v8, &xmlIsCombiningGroup) || xmlCharInRange(v8, &xmlIsExtenderGroup))
    goto LABEL_47;
LABEL_53:
  v17 = (xmlDict *)a1[3];
  if (v17)
    result = (void *)xmlDictLookup(v17, v3, (int)i - (int)v2);
  else
    result = xmlStrndup(v3, (int)i - (int)v2);
  *a1 = i;
  return result;
}

void *xmlPatScanName(const xmlChar **a1)
{
  const xmlChar *v2;
  const xmlChar *v3;
  unsigned int v4;
  uint64_t v5;
  signed int v7;
  signed int v8;
  void *result;
  BOOL v10;
  const xmlChar *i;
  BOOL v14;
  BOOL v16;
  xmlDict *v17;
  int len;

  len = 0;
  v2 = *a1;
  v3 = *a1;
  while (1)
  {
    v4 = *v3;
    v10 = v4 > 0x20;
    v5 = (1 << v4) & 0x100002600;
    if (v10 || v5 == 0)
      break;
    *a1 = ++v3;
    LODWORD(v2) = (_DWORD)v2 + 1;
  }
  v7 = xmlStringCurrentChar(0, v3, &len);
  v8 = v7;
  if (v7 > 255)
  {
    if (xmlCharInRange(v7, &xmlIsBaseCharGroup))
      v10 = 1;
    else
      v10 = (v8 - 12330) > 0xFFFFFFF6;
    if (!v10 && v8 != 12295 && (v8 - 40870) < 0xFFFFAE5A)
      return 0;
  }
  else if ((v7 - 192) >= 0x17
         && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
         && v7 <= 247
         && (v7 - 216) >= 0x1F
         && v7 != 95
         && v7 != 58)
  {
    return 0;
  }
  for (i = v3; ; v8 = xmlStringCurrentChar(0, i, &len))
  {
    if (v8 > 255)
    {
      if (xmlCharInRange(v8, &xmlIsBaseCharGroup))
        v14 = 0;
      else
        v14 = (v8 - 12321) >= 9;
      v16 = v14 && v8 != 12295 && (v8 - 19968) >= 0x51A6;
      if (!v16 || xmlCharInRange(v8, &xmlIsDigitGroup))
        goto LABEL_48;
    }
    else if ((v8 - 192) < 0x17
           || (v8 & 0xFFFFFFDF) - 65 < 0x1A
           || (v8 - 48) < 0xA
           || v8 > 247
           || (v8 - 216) < 0x1F)
    {
      goto LABEL_48;
    }
    if ((v8 - 45) <= 0x32 && ((1 << (v8 - 45)) & 0x4000000000003) != 0)
      goto LABEL_48;
    if (v8 >= 256)
      break;
    if (v8 != 183)
      goto LABEL_54;
LABEL_48:
    i += len;
  }
  if (xmlCharInRange(v8, &xmlIsCombiningGroup) || xmlCharInRange(v8, &xmlIsExtenderGroup))
    goto LABEL_48;
LABEL_54:
  v17 = (xmlDict *)a1[3];
  if (v17)
    result = (void *)xmlDictLookup(v17, v3, (int)i - (int)v2);
  else
    result = xmlStrndup(v3, (int)i - (int)v2);
  *a1 = i;
  return result;
}

_OWORD *xmlNewStreamComp(int a1)
{
  unsigned int v1;
  _OWORD *v2;
  _OWORD *v3;
  void *v4;

  if (a1 <= 4)
    v1 = 4;
  else
    v1 = a1;
  v2 = xmlMalloc(0x20uLL);
  v3 = v2;
  if (v2)
  {
    *v2 = 0u;
    v2[1] = 0u;
    v4 = xmlMalloc(32 * v1);
    *((_QWORD *)v3 + 2) = v4;
    if (v4)
    {
      *((_DWORD *)v3 + 2) = 0;
      *((_DWORD *)v3 + 3) = v1;
    }
    else
    {
      xmlFree(v3);
      return 0;
    }
  }
  return v3;
}

uint64_t xmlStreamCompAddStep(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t result;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;

  result = *(unsigned int *)(a1 + 8);
  v11 = *(int *)(a1 + 12);
  if ((int)result < (int)v11)
  {
    v12 = *(char **)(a1 + 16);
LABEL_5:
    *(_DWORD *)(a1 + 8) = result + 1;
    v14 = &v12[32 * (int)result];
    *(_DWORD *)v14 = a5;
    *((_QWORD *)v14 + 1) = a2;
    *((_QWORD *)v14 + 2) = a3;
    *((_DWORD *)v14 + 6) = a4;
    return result;
  }
  v13 = (char *)xmlRealloc(*(void **)(a1 + 16), v11 << 6);
  if (v13)
  {
    v12 = v13;
    *(_QWORD *)(a1 + 16) = v13;
    result = *(unsigned int *)(a1 + 8);
    *(_DWORD *)(a1 + 12) *= 2;
    goto LABEL_5;
  }
  return 0xFFFFFFFFLL;
}

void xmlRelaxNGFree(xmlRelaxNGPtr schema)
{
  _QWORD *v2;
  xmlDoc *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;

  if (schema)
  {
    v2 = (_QWORD *)*((_QWORD *)schema + 1);
    if (v2)
      xmlRelaxNGFreeGrammar(v2);
    v3 = (xmlDoc *)*((_QWORD *)schema + 2);
    if (v3)
      xmlFreeDoc(v3);
    v4 = (_QWORD *)*((_QWORD *)schema + 6);
    if (v4)
    {
      do
      {
        v5 = (_QWORD *)*v4;
        xmlRelaxNGFreeDocument(v4);
        v4 = v5;
      }
      while (v5);
    }
    v6 = (_QWORD *)*((_QWORD *)schema + 7);
    if (v6)
    {
      do
      {
        v7 = (_QWORD *)*v6;
        xmlRelaxNGFreeInclude(v6);
        v6 = v7;
      }
      while (v7);
    }
    v8 = (void *)*((_QWORD *)schema + 9);
    if (v8)
    {
      if (*((int *)schema + 16) >= 1)
      {
        v9 = 0;
        do
          xmlRelaxNGFreeDefine(*(int **)(*((_QWORD *)schema + 9) + 8 * v9++));
        while (v9 < *((int *)schema + 16));
        v8 = (void *)*((_QWORD *)schema + 9);
      }
      xmlFree(v8);
    }
    xmlFree(schema);
  }
}

void xmlRelaxNGFreeGrammar(_QWORD *a1)
{
  xmlHashTable *v2;
  xmlHashTable *v3;

  if (a1[1])
    xmlRelaxNGFreeGrammar();
  if (a1[2])
    xmlRelaxNGFreeGrammar();
  v2 = (xmlHashTable *)a1[7];
  if (v2)
    xmlHashFree(v2, 0);
  v3 = (xmlHashTable *)a1[6];
  if (v3)
    xmlHashFree(v3, 0);
  xmlFree(a1);
}

void xmlRelaxNGFreeDefine(int *a1)
{
  uint64_t v2;
  void (*v3)(_QWORD);
  void *v4;
  int v5;
  void *v6;
  void *v7;
  void *v8;
  xmlRegexp *v9;

  if (!a1)
    return;
  if (*a1 == 7)
  {
    if (*((_QWORD *)a1 + 9))
    {
      v2 = *((_QWORD *)a1 + 5);
      if (v2)
      {
        v3 = *(void (**)(_QWORD))(v2 + 48);
        if (v3)
          v3(*(_QWORD *)(v2 + 8));
      }
    }
  }
  v4 = (void *)*((_QWORD *)a1 + 5);
  if (v4)
  {
    v5 = *a1;
    if (*a1 != 19)
      goto LABEL_11;
    xmlRelaxNGFreePartition(v4);
    v4 = (void *)*((_QWORD *)a1 + 5);
    if (v4)
    {
      v5 = *a1;
LABEL_11:
      if (v5 == 17)
        xmlHashFree((xmlHashTablePtr)v4, 0);
    }
  }
  v6 = (void *)*((_QWORD *)a1 + 2);
  if (v6)
    xmlFree(v6);
  v7 = (void *)*((_QWORD *)a1 + 3);
  if (v7)
    xmlFree(v7);
  v8 = (void *)*((_QWORD *)a1 + 4);
  if (v8)
    xmlFree(v8);
  v9 = (xmlRegexp *)*((_QWORD *)a1 + 13);
  if (v9)
    xmlRegFreeRegexp(v9);
  xmlFree(a1);
}

int xmlRelaxParserSetFlag(xmlRelaxNGParserCtxtPtr ctxt, int flag)
{
  if (!ctxt)
    return -1;
  if ((flag & 1) != 0)
  {
    *((_DWORD *)ctxt + 62) |= 1u;
    --flag;
  }
  if ((flag & 2) != 0)
  {
    *((_DWORD *)ctxt + 62) |= 2u;
    flag -= 2;
  }
  if (flag)
    return -1;
  else
    return 0;
}

int xmlRelaxNGInitTypes(void)
{
  int result;
  xmlGenericErrorFunc v1;
  void **v2;

  if ((xmlRelaxNGTypeInitialized & 1) != 0)
    return 0;
  xmlRelaxNGRegisteredTypes = (uint64_t)xmlHashCreate(10);
  if (xmlRelaxNGRegisteredTypes)
  {
    xmlRelaxNGRegisterTypeLibrary((xmlChar *)"http://www.w3.org/2001/XMLSchema-datatypes", xmlRelaxNGSchemaTypeHave, xmlRelaxNGSchemaTypeCheck, xmlRelaxNGSchemaTypeCompare, xmlRelaxNGSchemaFacetCheck, xmlRelaxNGSchemaFreeValue);
    xmlRelaxNGRegisterTypeLibrary((xmlChar *)"http://relaxng.org/ns/structure/1.0", xmlRelaxNGDefaultTypeHave, xmlRelaxNGDefaultTypeCheck, xmlRelaxNGDefaultTypeCompare, 0, 0);
    result = 0;
    xmlRelaxNGTypeInitialized = 1;
  }
  else
  {
    v1 = *__xmlGenericError();
    v2 = __xmlGenericErrorContext();
    v1(*v2, "Failed to allocate sh table for Relax-NG types\n");
    return -1;
  }
  return result;
}

void xmlRelaxNGRegisterTypeLibrary(xmlChar *name, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  xmlGenericErrorFunc v12;
  void **v13;
  void **v14;
  void **v15;
  xmlGenericErrorFunc v16;
  void **v17;

  if (a4 && a3 && name && xmlRelaxNGRegisteredTypes)
  {
    if (xmlHashLookup((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, name))
    {
      v12 = *__xmlGenericError();
      v13 = __xmlGenericErrorContext();
      v12(*v13, "Relax-NG types library '%s' already registered\n", (const char *)name);
    }
    else
    {
      v14 = (void **)xmlMalloc(0x38uLL);
      if (v14)
      {
        v15 = v14;
        v14[6] = 0;
        *((_OWORD *)v14 + 1) = 0u;
        *((_OWORD *)v14 + 2) = 0u;
        *(_OWORD *)v14 = 0u;
        *v14 = xmlStrdup(name);
        v15[1] = 0;
        v15[2] = a2;
        v15[3] = a3;
        v15[4] = a4;
        v15[5] = a5;
        v15[6] = a6;
        if (xmlHashAddEntry((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, name, v15) < 0)
        {
          v16 = *__xmlGenericError();
          v17 = __xmlGenericErrorContext();
          v16(*v17, "Relax-NG types library failed to register '%s'\n", (const char *)name);
          if (*v15)
            xmlFree(*v15);
          xmlFree(v15);
        }
      }
      else
      {
        xmlRngVErrMemory(0, (const xmlChar *)"adding types library\n");
      }
    }
  }
}

uint64_t xmlRelaxNGSchemaTypeHave(int a1, xmlChar *name)
{
  if (name)
    return xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema") != 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t xmlRelaxNGSchemaTypeCheck(int a1, xmlChar *name, const xmlChar *a3, xmlSchemaValPtr *a4, xmlNode *a5)
{
  uint64_t result;
  xmlSchemaType *PredefinedType;
  int v10;
  unsigned int v11;

  result = 0xFFFFFFFFLL;
  if (name && a3)
  {
    PredefinedType = xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema");
    if (PredefinedType)
    {
      v10 = xmlSchemaValPredefTypeNode(PredefinedType, a3, a4, a5);
      if (v10 >= 1)
        v11 = 0;
      else
        v11 = -1;
      if (!v10)
        v11 = 1;
      if (v10 == 2)
        return 2;
      else
        return v11;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t xmlRelaxNGSchemaTypeCompare(int a1, xmlChar *name, const xmlChar *a3, xmlNode *a4, xmlSchemaVal *a5, const xmlChar *a6, xmlNode *a7)
{
  uint64_t result;
  xmlSchemaType *PredefinedType;
  xmlSchemaType *v14;
  int v15;
  int v16;
  xmlSchemaValPtr y;
  xmlSchemaValPtr val;

  y = 0;
  val = 0;
  result = 0xFFFFFFFFLL;
  if (name && a3 && a6)
  {
    PredefinedType = xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema");
    if (!PredefinedType)
      return 0xFFFFFFFFLL;
    v14 = PredefinedType;
    if (a5)
    {
      val = a5;
    }
    else
    {
      v15 = xmlSchemaValPredefTypeNode(PredefinedType, a3, &val, a4);
      result = 0xFFFFFFFFLL;
      if (v15 || !val)
        return result;
    }
    if (xmlSchemaValPredefTypeNode(v14, a6, &y, a7))
    {
      if (val != a5)
        xmlSchemaFreeValue(val);
      return 0xFFFFFFFFLL;
    }
    v16 = xmlSchemaCompareValues(val, y);
    if (val != a5)
      xmlSchemaFreeValue(val);
    xmlSchemaFreeValue(y);
    if (v16 == -2)
      return 0xFFFFFFFFLL;
    else
      return v16 == 0;
  }
  return result;
}

uint64_t xmlRelaxNGSchemaFacetCheck(int a1, xmlChar *name, const xmlChar *a3, const xmlChar *a4, const xmlChar *a5, xmlSchemaVal *a6)
{
  uint64_t result;
  xmlSchemaTypePtr PredefinedType;
  xmlSchemaType *v13;
  xmlSchemaFacetPtr v14;
  xmlSchemaFacet *v15;
  int v16;
  int v17;

  result = 0xFFFFFFFFLL;
  if (name && a5)
  {
    PredefinedType = xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema");
    if (!PredefinedType)
      return 0xFFFFFFFFLL;
    v13 = PredefinedType;
    v14 = xmlSchemaNewFacet();
    if (!v14)
      return 0xFFFFFFFFLL;
    v15 = v14;
    if (xmlStrEqual(a3, (const xmlChar *)"minInclusive"))
    {
      v16 = 1000;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"minExclusive"))
    {
      v16 = 1001;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"maxInclusive"))
    {
      v16 = 1002;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"maxExclusive"))
    {
      v16 = 1003;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"totalDigits"))
    {
      v16 = 1004;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"fractionDigits"))
    {
      v16 = 1005;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"pattern"))
    {
      v16 = 1006;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"enumeration"))
    {
      v16 = 1007;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"whiteSpace"))
    {
      v16 = 1008;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"length"))
    {
      v16 = 1009;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"maxLength"))
    {
      v16 = 1010;
    }
    else
    {
      if (!xmlStrEqual(a3, (const xmlChar *)"minLength"))
      {
LABEL_30:
        xmlSchemaFreeFacet(v15);
        return 0xFFFFFFFFLL;
      }
      v16 = 1011;
    }
    v15->type = v16;
    v15->value = a4;
    if (xmlSchemaCheckFacet(v15, v13, 0, name))
      goto LABEL_30;
    v17 = xmlSchemaValidateFacet(v13, v15, a5, a6);
    xmlSchemaFreeFacet(v15);
    if (v17)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

void xmlRelaxNGSchemaFreeValue(int a1, xmlSchemaValPtr val)
{
  xmlSchemaFreeValue(val);
}

uint64_t xmlRelaxNGDefaultTypeHave(int a1, xmlChar *str1)
{
  if (!str1)
    return 0xFFFFFFFFLL;
  if (xmlStrEqual(str1, (const xmlChar *)"string"))
    return 1;
  return xmlStrEqual(str1, (const xmlChar *)"token") != 0;
}

uint64_t xmlRelaxNGDefaultTypeCheck(int a1, xmlChar *str1, uint64_t a3)
{
  if (!a3)
    return 0xFFFFFFFFLL;
  if (xmlStrEqual(str1, (const xmlChar *)"string"))
    return 1;
  return xmlStrEqual(str1, (const xmlChar *)"token") != 0;
}

uint64_t xmlRelaxNGDefaultTypeCompare(int a1, xmlChar *str1, xmlChar *a3, uint64_t a4, uint64_t a5, xmlChar *a6)
{
  uint64_t v10;
  xmlChar *v11;
  const xmlChar *v12;
  xmlChar *v13;

  if (xmlStrEqual(str1, (const xmlChar *)"string"))
    return xmlStrEqual(a3, a6);
  if (!xmlStrEqual(str1, (const xmlChar *)"token"))
    return 0xFFFFFFFFLL;
  if (!xmlStrEqual(a3, a6))
  {
    v11 = xmlRelaxNGNormalize(0, a3);
    v12 = xmlRelaxNGNormalize(0, a6);
    v13 = (xmlChar *)v12;
    if (v11 && v12)
    {
      v10 = xmlStrEqual(v11, v12) != 0;
    }
    else
    {
      v10 = 0xFFFFFFFFLL;
      if (!v11)
        goto LABEL_12;
    }
    xmlFree(v11);
LABEL_12:
    if (v13)
      xmlFree(v13);
    return v10;
  }
  return 1;
}

void xmlRelaxNGCleanupTypes(void)
{
  xmlSchemaCleanupTypes();
  if (xmlRelaxNGTypeInitialized == 1)
  {
    xmlHashFree((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, (xmlHashDeallocator)xmlRelaxNGFreeTypeLibrary);
    xmlRelaxNGTypeInitialized = 0;
  }
}

void xmlRelaxNGFreeTypeLibrary(void **a1)
{
  void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      xmlFree(v2);
    xmlFree(a1);
  }
}

xmlRelaxNGParserCtxtPtr xmlRelaxNGNewParserCtxt(const char *URL)
{
  _OWORD *v2;
  _OWORD *v3;

  if (!URL)
    return 0;
  v2 = xmlMalloc(0x100uLL);
  v3 = v2;
  if (v2)
  {
    v2[14] = 0u;
    v2[15] = 0u;
    v2[12] = 0u;
    v2[13] = 0u;
    v2[10] = 0u;
    v2[11] = 0u;
    v2[8] = 0u;
    v2[9] = 0u;
    v2[6] = 0u;
    v2[7] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *v2 = 0u;
    v2[1] = 0u;
    *((_QWORD *)v2 + 16) = xmlStrdup((const xmlChar *)URL);
    *((_QWORD *)v3 + 1) = *__xmlGenericError();
    *(_QWORD *)v3 = *__xmlGenericErrorContext();
  }
  else
  {
    xmlRngPErrMemory(0, (const xmlChar *)"building parser\n");
  }
  return (xmlRelaxNGParserCtxtPtr)v3;
}

_DWORD *xmlRngPErrMemory(uint64_t a1, const xmlChar *a2)
{
  uint64_t v3;
  void (*v4)(void *, const char *, ...);
  void *v5;
  char v7;

  if (a1)
  {
    v3 = a1;
    a1 = *(_QWORD *)(a1 + 24);
    if (a1)
      v4 = 0;
    else
      v4 = *(void (**)(void *, const char *, ...))(v3 + 8);
    v5 = *(void **)v3;
    ++*(_DWORD *)(v3 + 68);
    if (a2)
      return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x12u, 2, 3, 0, 0, a2, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a2);
    return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x12u, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n", v7);
  }
  v4 = 0;
  v5 = 0;
  if (!a2)
    return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x12u, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n", v7);
  return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x12u, 2, 3, 0, 0, a2, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a2);
}

xmlRelaxNGParserCtxtPtr xmlRelaxNGNewMemParserCtxt(const char *buffer, int size)
{
  xmlRelaxNGParserCtxt *v2;
  xmlRelaxNGParserCtxt *v5;

  v2 = 0;
  if (buffer && size >= 1)
  {
    v5 = (xmlRelaxNGParserCtxt *)xmlMalloc(0x100uLL);
    v2 = v5;
    if (v5)
    {
      *((_OWORD *)v5 + 14) = 0u;
      *((_OWORD *)v5 + 15) = 0u;
      *((_OWORD *)v5 + 12) = 0u;
      *((_OWORD *)v5 + 13) = 0u;
      *((_OWORD *)v5 + 10) = 0u;
      *((_OWORD *)v5 + 11) = 0u;
      *((_OWORD *)v5 + 8) = 0u;
      *((_OWORD *)v5 + 9) = 0u;
      *((_OWORD *)v5 + 6) = 0u;
      *((_OWORD *)v5 + 7) = 0u;
      *((_OWORD *)v5 + 4) = 0u;
      *((_OWORD *)v5 + 5) = 0u;
      *((_OWORD *)v5 + 2) = 0u;
      *((_OWORD *)v5 + 3) = 0u;
      *(_OWORD *)v5 = 0u;
      *((_OWORD *)v5 + 1) = 0u;
      *((_QWORD *)v5 + 20) = buffer;
      *((_DWORD *)v5 + 42) = size;
      *((_QWORD *)v5 + 1) = *__xmlGenericError();
      *(_QWORD *)v2 = *__xmlGenericErrorContext();
    }
    else
    {
      xmlRngPErrMemory(0, (const xmlChar *)"building parser\n");
    }
  }
  return v2;
}

xmlRelaxNGParserCtxtPtr xmlRelaxNGNewDocParserCtxt(xmlDocPtr doc)
{
  xmlDocPtr v1;
  xmlDoc *v2;
  xmlRelaxNGParserCtxt *v3;
  xmlRelaxNGParserCtxt *v4;

  if (!doc)
    return 0;
  v1 = xmlCopyDoc(doc, 1);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = (xmlRelaxNGParserCtxt *)xmlMalloc(0x100uLL);
  v4 = v3;
  if (v3)
  {
    *((_OWORD *)v3 + 14) = 0u;
    *((_OWORD *)v3 + 15) = 0u;
    *((_OWORD *)v3 + 12) = 0u;
    *((_OWORD *)v3 + 13) = 0u;
    *((_OWORD *)v3 + 10) = 0u;
    *((_OWORD *)v3 + 11) = 0u;
    *((_OWORD *)v3 + 8) = 0u;
    *((_OWORD *)v3 + 9) = 0u;
    *((_OWORD *)v3 + 6) = 0u;
    *((_OWORD *)v3 + 7) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    *((_OWORD *)v3 + 5) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *(_OWORD *)v3 = 0u;
    *((_OWORD *)v3 + 1) = 0u;
    *((_QWORD *)v3 + 17) = v2;
    *((_DWORD *)v3 + 63) = 1;
    *(_QWORD *)v3 = *__xmlGenericErrorContext();
  }
  else
  {
    xmlRngPErrMemory(0, (const xmlChar *)"building parser\n");
    xmlFreeDoc(v2);
  }
  return v4;
}

void xmlRelaxNGFreeParserCtxt(xmlRelaxNGParserCtxtPtr ctxt)
{
  void *v2;
  _QWORD *v3;
  xmlHashTable *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  xmlDoc *v13;

  if (ctxt)
  {
    v2 = (void *)*((_QWORD *)ctxt + 16);
    if (v2)
      xmlFree(v2);
    v3 = (_QWORD *)*((_QWORD *)ctxt + 22);
    if (v3)
      xmlRelaxNGFreeDocument(v3);
    v4 = (xmlHashTable *)*((_QWORD *)ctxt + 13);
    if (v4)
      xmlHashFree(v4, 0);
    v5 = (_QWORD *)*((_QWORD *)ctxt + 14);
    if (v5)
    {
      do
      {
        v6 = (_QWORD *)*v5;
        xmlRelaxNGFreeDocument(v5);
        v5 = v6;
      }
      while (v6);
    }
    v7 = (_QWORD *)*((_QWORD *)ctxt + 15);
    if (v7)
    {
      do
      {
        v8 = (_QWORD *)*v7;
        xmlRelaxNGFreeInclude(v7);
        v7 = v8;
      }
      while (v8);
    }
    v9 = (void *)*((_QWORD *)ctxt + 24);
    if (v9)
      xmlFree(v9);
    v10 = (void *)*((_QWORD *)ctxt + 27);
    if (v10)
      xmlFree(v10);
    v11 = (void *)*((_QWORD *)ctxt + 19);
    if (v11)
    {
      if (*((int *)ctxt + 36) >= 1)
      {
        v12 = 0;
        do
          xmlRelaxNGFreeDefine(*(int **)(*((_QWORD *)ctxt + 19) + 8 * v12++));
        while (v12 < *((int *)ctxt + 36));
        v11 = (void *)*((_QWORD *)ctxt + 19);
      }
      xmlFree(v11);
    }
    v13 = (xmlDoc *)*((_QWORD *)ctxt + 17);
    if (v13)
    {
      if (*((_DWORD *)ctxt + 63))
        xmlFreeDoc(v13);
    }
    xmlFree(ctxt);
  }
}

void xmlRelaxNGFreeDocument(_QWORD *a1)
{
  void *v2;
  xmlDoc *v3;
  uint64_t v4;
  xmlDoc *v5;
  void *v6;
  uint64_t v7;

  v2 = (void *)a1[1];
  if (v2)
    xmlFree(v2);
  v3 = (xmlDoc *)a1[2];
  if (v3)
    xmlFreeDoc(v3);
  v4 = a1[4];
  if (v4)
  {
    v5 = *(xmlDoc **)(v4 + 16);
    if (v5)
      xmlFreeDoc(v5);
    v6 = *(void **)(v4 + 72);
    if (v6)
    {
      if (*(int *)(v4 + 64) >= 1)
      {
        v7 = 0;
        do
          xmlRelaxNGFreeDefine(*(int **)(*(_QWORD *)(v4 + 72) + 8 * v7++));
        while (v7 < *(int *)(v4 + 64));
        v6 = *(void **)(v4 + 72);
      }
      xmlFree(v6);
    }
    xmlFree((void *)v4);
  }
  xmlFree(a1);
}

xmlRelaxNGPtr xmlRelaxNGParse(xmlRelaxNGParserCtxtPtr ctxt)
{
  const char *v2;
  xmlDoc *Memory;
  const xmlChar *v4;
  const char *v5;
  xmlRelaxNGParserCtxtPtr v6;
  int v7;
  const char *v8;
  xmlDoc *v9;
  xmlDoc *v10;
  xmlNodePtr RootElement;
  xmlHashTable *v12;
  const xmlChar *v13;
  uint64_t v14;
  _DWORD *v15;
  _OWORD *v16;
  uint64_t v17;
  __int128 v19;

  xmlRelaxNGInitTypes();
  if (!ctxt)
    return 0;
  v2 = (const char *)*((_QWORD *)ctxt + 16);
  if (!v2)
  {
    v8 = (const char *)*((_QWORD *)ctxt + 20);
    if (v8)
    {
      Memory = xmlReadMemory(v8, *((_DWORD *)ctxt + 42), 0, 0, 0);
      if (Memory)
      {
        Memory->URL = xmlStrdup((const xmlChar *)"in_memory_buffer");
        *((_QWORD *)ctxt + 16) = xmlStrdup((const xmlChar *)"in_memory_buffer");
        goto LABEL_9;
      }
      v5 = "xmlRelaxNGParse: could not parse schemas\n";
      v6 = ctxt;
      v7 = 1065;
    }
    else
    {
      Memory = (xmlDoc *)*((_QWORD *)ctxt + 17);
      if (Memory)
        goto LABEL_9;
      v5 = "xmlRelaxNGParse: nothing to parse\n";
      v6 = ctxt;
      v7 = 1022;
    }
    v4 = 0;
    goto LABEL_32;
  }
  Memory = xmlReadFile(v2, 0, 0);
  if (!Memory)
  {
    v4 = (const xmlChar *)*((_QWORD *)ctxt + 16);
    v5 = "xmlRelaxNGParse: could not load %s\n";
    v6 = ctxt;
    v7 = 1065;
LABEL_32:
    xmlRngPErr((uint64_t)v6, 0, v7, v5, v4, 0);
    return (xmlRelaxNGPtr)Memory;
  }
LABEL_9:
  *((_QWORD *)ctxt + 17) = Memory;
  v9 = xmlRelaxNGCleanupDoc((uint64_t)ctxt, Memory);
  if (!v9)
  {
LABEL_21:
    xmlFreeDoc(*((xmlDocPtr *)ctxt + 17));
    Memory = 0;
LABEL_22:
    *((_QWORD *)ctxt + 17) = 0;
    return (xmlRelaxNGPtr)Memory;
  }
  v10 = v9;
  RootElement = xmlDocGetRootElement(v9);
  if (!RootElement)
  {
    if (*((_QWORD *)ctxt + 16))
      v13 = (const xmlChar *)*((_QWORD *)ctxt + 16);
    else
      v13 = (const xmlChar *)"schemas";
    xmlRngPErr((uint64_t)ctxt, (uint64_t)v10, 1022, "xmlRelaxNGParse: %s is empty\n", v13, 0);
    goto LABEL_21;
  }
  Memory = (xmlDoc *)xmlRelaxNGParseDocument((uint64_t)ctxt, (uint64_t)RootElement);
  if (!Memory)
  {
    xmlFreeDoc(*((xmlDocPtr *)ctxt + 17));
    goto LABEL_22;
  }
  v12 = (xmlHashTable *)*((_QWORD *)ctxt + 13);
  if (v12)
    xmlHashScan(v12, (xmlHashScanner)xmlRelaxNGComputeInterleaves, ctxt);
  if (*((int *)ctxt + 17) >= 1)
  {
    xmlRelaxNGFree((xmlRelaxNGPtr)Memory);
    *((_QWORD *)ctxt + 17) = 0;
    xmlFreeDoc(v10);
    return 0;
  }
  v14 = *(_QWORD *)&Memory->type;
  if (v14)
  {
    v15 = *(_DWORD **)(v14 + 24);
    if (v15)
    {
      if (*v15 != 20)
      {
        v16 = xmlRelaxNGNewDefine((uint64_t)ctxt, 0);
        v17 = *(_QWORD *)&Memory->type;
        if (v16)
        {
          v15 = v16;
          *(_DWORD *)v16 = 20;
          *((_QWORD *)v16 + 6) = *(_QWORD *)(v17 + 24);
          *(_QWORD *)(v17 + 24) = v16;
        }
        else
        {
          v15 = *(_DWORD **)(v17 + 24);
        }
      }
      xmlRelaxNGTryCompile((uint64_t)ctxt, (uint64_t)v15);
    }
  }
  Memory->name = (char *)v10;
  *((_QWORD *)ctxt + 17) = 0;
  v19 = *((_OWORD *)ctxt + 7);
  *((_QWORD *)ctxt + 14) = 0;
  *(_OWORD *)&Memory->next = v19;
  *((_QWORD *)ctxt + 15) = 0;
  LODWORD(Memory->doc) = *((_DWORD *)ctxt + 36);
  *(_QWORD *)&Memory->compression = *((_QWORD *)ctxt + 19);
  *((_QWORD *)ctxt + 19) = 0;
  if (*((_DWORD *)ctxt + 56) == 1)
    LODWORD(Memory->children) = 1;
  return (xmlRelaxNGPtr)Memory;
}

_DWORD *xmlRngPErr(uint64_t a1, uint64_t a2, int a3, const char *a4, const xmlChar *a5, xmlChar *a6)
{
  uint64_t v8;
  void (*v9)(void *, const char *, ...);
  void *v10;

  if (a1)
  {
    v8 = a1;
    a1 = *(_QWORD *)(a1 + 24);
    if (a1)
      v9 = 0;
    else
      v9 = *(void (**)(void *, const char *, ...))(v8 + 8);
    v10 = *(void **)v8;
    ++*(_DWORD *)(v8 + 68);
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  return __xmlRaiseError((xmlStructuredErrorFunc)a1, v9, v10, 0, a2, 0x12u, a3, 2, 0, 0, a5, a6, 0, 0, 0, a4, (char)a5);
}

xmlDoc *xmlRelaxNGCleanupDoc(uint64_t a1, xmlDoc *doc)
{
  xmlDoc *v2;
  xmlNodePtr RootElement;

  v2 = doc;
  RootElement = xmlDocGetRootElement(doc);
  if (RootElement)
  {
    xmlRelaxNGCleanupTree(a1, (uint64_t)RootElement);
  }
  else
  {
    xmlRngPErr(a1, (uint64_t)v2, 1022, "xmlRelaxNGParse: %s is empty\n", *(const xmlChar **)(a1 + 128), 0);
    return 0;
  }
  return v2;
}

_OWORD *xmlRelaxNGParseDocument(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  _OWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _OWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  uint64_t i;

  v4 = xmlMalloc(0x50uLL);
  v5 = v4;
  if (v4)
  {
    v4[3] = 0u;
    v4[4] = 0u;
    v4[1] = 0u;
    v4[2] = 0u;
    *v4 = 0u;
    v6 = *(_QWORD *)(a1 + 80);
    *(_QWORD *)(a1 + 80) = 0;
    if (*(_QWORD *)(a2 + 72)
      && *(_DWORD *)(a2 + 8) == 1
      && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"grammar")
      && xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      v7 = xmlRelaxNGParseGrammar(a1, *(_QWORD *)(a2 + 24));
      *((_QWORD *)v5 + 1) = v7;
      if (!v7)
        goto LABEL_14;
    }
    else
    {
      v8 = xmlRelaxNGNewGrammar(a1);
      *((_QWORD *)v5 + 1) = v8;
      if (!v8)
      {
LABEL_14:
        xmlRelaxNGFree((xmlRelaxNGPtr)v5);
        return 0;
      }
      v9 = *(_QWORD *)(a1 + 48);
      *(_QWORD *)v8 = v9;
      if (v9)
      {
        v10 = *(_QWORD *)(v9 + 8);
        if (v10)
        {
          do
          {
            v11 = v10;
            v10 = *(_QWORD *)(v10 + 16);
          }
          while (v10);
          *(_QWORD *)(v11 + 16) = v8;
        }
        else
        {
          *(_QWORD *)(v9 + 8) = v8;
        }
        *(_QWORD *)(a1 + 48) = v8;
        xmlRelaxNGParseStart(a1, a2);
        *(_QWORD *)(a1 + 48) = v9;
      }
      else
      {
        *(_QWORD *)(a1 + 48) = v8;
        xmlRelaxNGParseStart(a1, a2);
      }
    }
    *(_QWORD *)(a1 + 80) = v6;
    v12 = *(int **)(*((_QWORD *)v5 + 1) + 24);
    if (v12)
    {
      xmlRelaxNGCheckCycles(a1, v12, 0);
      if ((*(_BYTE *)(a1 + 64) & 0x80) == 0)
      {
        xmlRelaxNGSimplify(a1, *(_QWORD *)(*((_QWORD *)v5 + 1) + 24), 0);
        v13 = *((_QWORD *)v5 + 1);
        for (i = *(_QWORD *)(v13 + 24); i; *(_QWORD *)(v13 + 24) = i)
        {
          if (*(_DWORD *)i != -1)
            break;
          if (!*(_QWORD *)(i + 64))
            break;
          i = *(_QWORD *)(i + 48);
        }
        xmlRelaxNGCheckRules(a1, (unsigned int *)i, 16, -1);
      }
    }
  }
  else
  {
    xmlRngPErrMemory(a1, 0);
  }
  return v5;
}

void xmlRelaxNGComputeInterleaves(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  size_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  _QWORD *v11;
  _OWORD *v12;
  _OWORD *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  xmlHashTable *v24;
  const xmlChar *v25;
  const xmlChar *v26;
  xmlHashTable *v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  void ***v32;
  void **v33;
  int v34;
  int v35;
  char *v36;
  char *v37;

  if (*(_DWORD *)(a2 + 68))
    return;
  v4 = *(_QWORD *)(a1 + 48);
  if (v4)
  {
    v5 = 0;
    do
    {
      v4 = *(_QWORD *)(v4 + 64);
      v5 += 8;
    }
    while (v4);
  }
  else
  {
    v5 = 0;
  }
  v6 = (char *)xmlMalloc(v5);
  if (!v6)
  {
    xmlRngPErrMemory(a2, (const xmlChar *)"in interleave computation\n");
    return;
  }
  v7 = v6;
  v8 = *(_QWORD *)(a1 + 48);
  if (!v8)
  {
    LODWORD(v9) = 0;
    v10 = 0;
LABEL_18:
    v12 = xmlMalloc(0x20uLL);
    if (!v12)
      goto LABEL_60;
    v13 = v12;
    *v12 = 0u;
    v12[1] = 0u;
    *(_DWORD *)v12 = v9;
    *((_QWORD *)v12 + 1) = xmlHashCreate(v9);
    v35 = v10;
    if (!(_DWORD)v9)
    {
      v17 = 1;
LABEL_69:
      *((_QWORD *)v13 + 3) = v7;
      *(_QWORD *)(a1 + 40) = v13;
      if (v35)
        *(_WORD *)(a1 + 98) |= 8u;
      if (v17 == 2)
      {
        v34 = 3;
      }
      else
      {
        if (v17 != 1)
          return;
        v34 = 1;
      }
      *((_DWORD *)v13 + 4) = v34;
      return;
    }
    v14 = 0;
    v15 = v9;
    v36 = v7;
    v37 = v7 + 8;
    v16 = 1;
    v17 = 1;
    while (1)
    {
      v18 = *(_QWORD *)&v7[8 * v14++];
      v19 = v15;
      if (v14 < v15)
      {
        v20 = v37;
        do
        {
          if (*(_QWORD *)v20)
          {
            if (!xmlRelaxNGCompareElemDefLists(*(_QWORD *)(v18 + 8), *(_QWORD ***)(*(_QWORD *)v20 + 8)))
              xmlRngPErr(a2, *(_QWORD *)(a1 + 8), 1021, "Element or text conflicts in interleave\n", 0, 0);
            if (!xmlRelaxNGCompareElemDefLists(*(_QWORD *)(v18 + 16), *(_QWORD ***)(*(_QWORD *)v20 + 16)))xmlRngPErr(a2, *(_QWORD *)(a1 + 8), 1001, "Attributes conflicts in interleave\n", 0, 0);
          }
          v20 += 8;
          --v15;
        }
        while (v16 != v15);
      }
      v21 = *(uint64_t **)(v18 + 8);
      if (v21)
      {
        v22 = *v21;
        if (*v21)
          break;
      }
      v17 = 0;
      v15 = v19;
LABEL_58:
      ++v16;
      v7 = v36;
      v37 += 8;
      if (v14 == v15)
        goto LABEL_69;
    }
    v23 = v21 + 1;
    v15 = v19;
    while (*(_DWORD *)v22 != 4)
    {
      if (*(_DWORD *)v22 == 3)
      {
        v24 = (xmlHashTable *)*((_QWORD *)v13 + 1);
        v25 = (const xmlChar *)"#text";
        goto LABEL_35;
      }
      v17 = -1;
LABEL_55:
      v30 = *v23++;
      v22 = v30;
      if (!v30)
        goto LABEL_58;
    }
    v25 = *(const xmlChar **)(v22 + 16);
    v26 = *(const xmlChar **)(v22 + 24);
    if (v25)
    {
      if (v26)
      {
        v24 = (xmlHashTable *)*((_QWORD *)v13 + 1);
        if (!*v26)
LABEL_35:
          v26 = 0;
        if (xmlHashAddEntry2(v24, v25, v26, (void *)v14))
          v17 = -1;
        goto LABEL_55;
      }
      v24 = (xmlHashTable *)*((_QWORD *)v13 + 1);
      goto LABEL_35;
    }
    if (v26)
    {
      v27 = (xmlHashTable *)*((_QWORD *)v13 + 1);
      if (*v26)
        goto LABEL_49;
    }
    else
    {
      v27 = (xmlHashTable *)*((_QWORD *)v13 + 1);
    }
    v26 = 0;
LABEL_49:
    v28 = xmlHashAddEntry2(v27, (const xmlChar *)"#any", v26, (void *)v14);
    if (*(_QWORD *)(*(v23 - 1) + 80))
      v29 = 2;
    else
      v29 = v17;
    if (v28)
      v17 = -1;
    else
      v17 = v29;
    goto LABEL_55;
  }
  v9 = 0;
  v10 = 0;
  while (1)
  {
    v11 = xmlMalloc(0x18uLL);
    *(_QWORD *)&v7[8 * v9] = v11;
    if (!v11)
      break;
    if (*(_DWORD *)v8 == 3)
      ++v10;
    *v11 = v8;
    *(_QWORD *)(*(_QWORD *)&v7[8 * v9] + 8) = xmlRelaxNGGetElements(a2, (_DWORD *)v8, 2);
    *(_QWORD *)(*(_QWORD *)&v7[8 * v9++] + 16) = xmlRelaxNGGetElements(a2, (_DWORD *)v8, 1);
    v8 = *(_QWORD *)(v8 + 64);
    if (!v8)
      goto LABEL_18;
  }
LABEL_60:
  xmlRngPErrMemory(a2, (const xmlChar *)"in interleave computation\n");
  if ((_DWORD)v9)
  {
    v31 = v9;
    v32 = (void ***)v7;
    do
    {
      v33 = *v32;
      if (*v32)
      {
        if (v33[1])
        {
          xmlFree(v33[1]);
          v33 = *v32;
        }
        xmlFree(v33);
      }
      ++v32;
      --v31;
    }
    while (v31);
  }
  xmlFree(v7);
}

_OWORD *xmlRelaxNGNewDefine(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  _OWORD *result;
  uint64_t v8;
  uint64_t v9;

  v4 = *(int *)(a1 + 148);
  if ((_DWORD)v4)
  {
    if ((int)v4 <= *(_DWORD *)(a1 + 144))
    {
      *(_DWORD *)(a1 + 148) = 2 * v4;
      v5 = xmlRealloc(*(void **)(a1 + 152), 16 * v4);
      if (!v5)
        goto LABEL_8;
      *(_QWORD *)(a1 + 152) = v5;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 144) = 0x1000000000;
    v6 = xmlMalloc(0x80uLL);
    *(_QWORD *)(a1 + 152) = v6;
    if (!v6)
      goto LABEL_8;
  }
  result = xmlMalloc(0x70uLL);
  if (result)
  {
    result[5] = 0u;
    result[6] = 0u;
    result[3] = 0u;
    result[4] = 0u;
    result[1] = 0u;
    result[2] = 0u;
    *result = 0u;
    v8 = *(_QWORD *)(a1 + 152);
    v9 = *(int *)(a1 + 144);
    *(_DWORD *)(a1 + 144) = v9 + 1;
    *(_QWORD *)(v8 + 8 * v9) = result;
    *((_QWORD *)result + 1) = a2;
    *((_WORD *)result + 48) = -1;
    return result;
  }
LABEL_8:
  xmlRngPErrMemory(a1, (const xmlChar *)"allocating define\n");
  return 0;
}

uint64_t xmlRelaxNGTryCompile(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  uint64_t result;
  unsigned int v6;
  uint64_t v7;

  if (!a2)
    return 0xFFFFFFFFLL;
  v2 = a2;
  while (1)
  {
    v4 = *(_DWORD *)v2;
    if ((*(_DWORD *)v2 | 0x10) == 0x14)
    {
      result = xmlRelaxNGIsCompilable((int *)v2);
      if ((*(_WORD *)(v2 + 98) & 0x40) != 0 && *(__int16 *)(v2 + 96) != -25)
      {
        *(_QWORD *)(a1 + 232) = 0;
        return xmlRelaxNGCompile(a1, (int *)v2);
      }
      v4 = *(_DWORD *)v2;
    }
    else
    {
      result = 0;
    }
    v6 = v4 + 1;
    if (v6 > 0x15)
      return result;
    if (v6)
      break;
    v2 = *(_QWORD *)(v2 + 48);
    if (!v2)
      return 0xFFFFFFFFLL;
  }
  if (((1 << v6) & 0x1007FE) != 0)
    return 0;
  v7 = *(_QWORD *)(v2 + 48);
  if (v7)
  {
    while (1)
    {
      result = xmlRelaxNGTryCompile(a1, v7);
      if ((_DWORD)result)
        break;
      v7 = *(_QWORD *)(v7 + 64);
      if (!v7)
        return 0;
    }
  }
  return result;
}

void xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc err, xmlRelaxNGValidityWarningFunc warn, void *ctx)
{
  if (ctxt)
  {
    *((_QWORD *)ctxt + 2) = warn;
    *((_QWORD *)ctxt + 3) = 0;
    *(_QWORD *)ctxt = ctx;
    *((_QWORD *)ctxt + 1) = err;
  }
}

int xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc *err, xmlRelaxNGValidityWarningFunc *warn, void **ctx)
{
  int v4;

  if (!ctxt)
    return -1;
  if (err)
    *err = (xmlRelaxNGValidityErrorFunc)*((_QWORD *)ctxt + 1);
  if (warn)
    *warn = (xmlRelaxNGValidityWarningFunc)*((_QWORD *)ctxt + 2);
  v4 = 0;
  if (ctx)
    *ctx = *(void **)ctxt;
  return v4;
}

void xmlRelaxNGSetParserStructuredErrors(xmlRelaxNGParserCtxtPtr ctxt, xmlStructuredErrorFunc serror, void *ctx)
{
  if (ctxt)
  {
    *((_QWORD *)ctxt + 2) = 0;
    *((_QWORD *)ctxt + 3) = serror;
    *(_QWORD *)ctxt = ctx;
    *((_QWORD *)ctxt + 1) = 0;
  }
}

void xmlRelaxNGDump(FILE *output, xmlRelaxNGPtr schema)
{
  uint64_t v4;
  const char *v5;
  const char *v6;
  size_t v7;
  uint64_t v8;
  int v9;
  const char *v10;
  size_t v11;
  const char *v12;
  size_t v13;

  if (output)
  {
    if (schema)
    {
      fwrite("RelaxNG: ", 9uLL, 1uLL, output);
      v4 = *((_QWORD *)schema + 2);
      if (v4)
      {
        v5 = *(const char **)(v4 + 136);
        if (v5)
          fprintf(output, "%s\n", v5);
        else
          fputc(10, output);
      }
      else
      {
        fwrite("no document\n", 0xCuLL, 1uLL, output);
      }
      v8 = *((_QWORD *)schema + 1);
      if (v8)
      {
        fwrite("<grammar", 8uLL, 1uLL, output);
        fwrite(" xmlns=\"http://relaxng.org/ns/structure/1.0\"", 0x2CuLL, 1uLL, output);
        v9 = *(_DWORD *)(v8 + 32);
        if (v9)
        {
          if (v9 == 2)
          {
            v10 = " combine=\"interleave\"";
            v11 = 21;
          }
          else if (v9 == 1)
          {
            v10 = " combine=\"choice\"";
            v11 = 17;
          }
          else
          {
            v10 = " <!-- invalid combine value -->";
            v11 = 31;
          }
          fwrite(v10, v11, 1uLL, output);
        }
        fwrite(">\n", 2uLL, 1uLL, output);
        if (*(_QWORD *)(v8 + 24))
        {
          fwrite("<start>\n", 8uLL, 1uLL, output);
          xmlRelaxNGDumpDefine(output, *(_QWORD *)(v8 + 24));
          v12 = "</start>\n";
          v13 = 9;
        }
        else
        {
          v12 = " <!-- grammar had no start -->";
          v13 = 30;
        }
        fwrite(v12, v13, 1uLL, output);
        v6 = "</grammar>\n";
        v7 = 11;
      }
      else
      {
        v6 = "RelaxNG has no top grammar\n";
        v7 = 27;
      }
    }
    else
    {
      v6 = "RelaxNG empty or failed to compile\n";
      v7 = 35;
    }
    fwrite(v6, v7, 1uLL, output);
  }
}

void xmlRelaxNGDumpTree(FILE *output, xmlRelaxNGPtr schema)
{
  xmlDoc *v3;
  const char *v4;
  size_t v5;

  if (output)
  {
    if (schema)
    {
      v3 = (xmlDoc *)*((_QWORD *)schema + 2);
      if (v3)
      {
        xmlDocDump(output, v3);
        return;
      }
      v4 = "no document\n";
      v5 = 12;
    }
    else
    {
      v4 = "RelaxNG empty or failed to compile\n";
      v5 = 35;
    }
    fwrite(v4, v5, 1uLL, output);
  }
}

int xmlRelaxNGValidatePushElement(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem)
{
  int v3;
  xmlRelaxNGValidCtxtPtr v5;
  xmlNs *ns;
  xmlRegExecCtxt *v7;
  const xmlChar *name;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  xmlRegexp *v13;
  xmlRegExecCtxtPtr v14;
  int v15;
  xmlChar *v16;
  int v17;

  v3 = -1;
  if (ctxt && elem)
  {
    v5 = ctxt;
    if (*((_QWORD *)ctxt + 17))
    {
LABEL_4:
      *((_QWORD *)v5 + 21) = elem;
      *((_DWORD *)v5 + 40) = 0;
      ns = elem->ns;
      v7 = (xmlRegExecCtxt *)*((_QWORD *)v5 + 17);
      name = elem->name;
      if (ns)
        v9 = xmlRegExecPushString2(v7, name, ns->href, v5);
      else
        v9 = xmlRegExecPushString(v7, name, v5);
      v3 = v9;
      if ((v9 & 0x80000000) == 0)
      {
        v17 = *((_DWORD *)v5 + 40);
        if (v17)
          return (v17 >> 31) | 1;
        else
          return 0;
      }
      v16 = (xmlChar *)elem->name;
      ctxt = v5;
      v15 = 38;
LABEL_19:
      xmlRelaxNGAddValidError((uint64_t)ctxt, v15, v16, 0, 0);
      return v3;
    }
    v10 = *((_QWORD *)ctxt + 5);
    if (!v10 || (v11 = *(_QWORD *)(v10 + 8)) == 0 || (v12 = *(_QWORD *)(v11 + 24)) == 0)
    {
      v15 = 34;
      v16 = 0;
      goto LABEL_19;
    }
    v13 = *(xmlRegexp **)(v12 + 104);
    if (!v13)
    {
      v3 = 0;
      *((_QWORD *)v5 + 22) = v12;
      return v3;
    }
    v14 = xmlRegNewExecCtxt(v13, (xmlRegExecCallbacks)xmlRelaxNGValidateProgressiveCallback, v5);
    if (v14)
    {
      xmlRelaxNGElemPush((uint64_t)v5, (uint64_t)v14);
      goto LABEL_4;
    }
  }
  return v3;
}

void xmlRelaxNGAddValidError(uint64_t a1, int a2, xmlChar *cur, xmlChar *a4, int a5)
{
  char *v10;
  char *v11;
  int v12;
  uint64_t v13;
  char *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  _QWORD *v19;
  int v20;
  int *v21;
  int v22;
  char *v23;
  __int128 *v24;
  __int128 v25;

  if (!a1 || (*(_DWORD *)(a1 + 56) & 8) != 0)
    return;
  if ((*(_DWORD *)(a1 + 56) & 3) == 1)
  {
    v10 = *(char **)(a1 + 88);
    if (!v10)
    {
      *(_QWORD *)(a1 + 80) = 0x800000000;
      v11 = (char *)xmlMalloc(0x140uLL);
      *(_QWORD *)(a1 + 88) = v11;
      if (!v11)
        goto LABEL_25;
      v10 = v11;
      *(_QWORD *)(a1 + 72) = 0;
    }
    v12 = *(_DWORD *)(a1 + 80);
    v13 = *(int *)(a1 + 84);
    if (v12 < (int)v13)
    {
      v14 = *(char **)(a1 + 72);
      if (!v14)
        goto LABEL_19;
      goto LABEL_16;
    }
    *(_DWORD *)(a1 + 84) = 2 * v13;
    v18 = (char *)xmlRealloc(v10, 80 * v13);
    *(_QWORD *)(a1 + 88) = v18;
    if (v18)
    {
      v10 = v18;
      v12 = *(_DWORD *)(a1 + 80);
      v14 = &v18[40 * v12 - 40];
      *(_QWORD *)(a1 + 72) = v14;
      if (!v14)
      {
LABEL_19:
        v20 = v12;
        v21 = (int *)&v10[40 * v12];
        *v21 = a2;
        if (a5)
        {
          *(_QWORD *)&v10[40 * v12 + 24] = xmlStrdup(cur);
          a4 = xmlStrdup(a4);
          v22 = 1;
        }
        else
        {
          v22 = 0;
          *(_QWORD *)&v10[40 * v20 + 24] = cur;
        }
        v23 = &v10[40 * v20];
        *((_QWORD *)v23 + 4) = a4;
        *((_DWORD *)v23 + 1) = v22;
        v24 = *(__int128 **)(a1 + 96);
        if (v24)
          v25 = *v24;
        else
          v25 = 0uLL;
        *(_OWORD *)&v10[40 * v20 + 8] = v25;
        *(_QWORD *)(a1 + 72) = v21;
        ++*(_DWORD *)(a1 + 80);
        return;
      }
LABEL_16:
      v19 = *(_QWORD **)(a1 + 96);
      if (v19 && *((_QWORD *)v14 + 1) == *v19 && *(_DWORD *)v14 == a2)
        return;
      goto LABEL_19;
    }
LABEL_25:
    xmlRngVErrMemory(a1, (const xmlChar *)"pushing error\n");
    return;
  }
  if (*(_DWORD *)(a1 + 80))
    xmlRelaxNGDumpValidError(a1);
  v15 = *(uint64_t **)(a1 + 96);
  if (v15)
  {
    v16 = *v15;
    v17 = v15[1];
  }
  else
  {
    v16 = 0;
    v17 = 0;
  }
  if (!(v16 | v17))
    v16 = *(_QWORD *)(a1 + 168);
  xmlRelaxNGShowValidError(a1, a2, v16, v17, cur, a4);
}

void xmlRelaxNGValidateProgressiveCallback(int a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  xmlRegexp *v7;
  xmlRegExecCtxtPtr v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  int *v19;
  uint64_t v20;
  char v21;

  if (!a4)
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "callback on %s missing context\n", a2);
    return;
  }
  v6 = *(_QWORD *)(a4 + 168);
  *(_DWORD *)(a4 + 160) = 1;
  if (!a3)
  {
    if (*a2 == 35)
      return;
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "callback on %s missing define\n");
    goto LABEL_23;
  }
  if (*(_DWORD *)a3 != 4)
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "callback on %s define is not element\n");
LABEL_23:
    if (!*(_DWORD *)(a4 + 68))
      *(_DWORD *)(a4 + 68) = 37;
    goto LABEL_27;
  }
  if (*(_DWORD *)(v6 + 8) != 1)
  {
    xmlRelaxNGAddValidError(a4, 23, 0, 0, 0);
    if ((*(_BYTE *)(a4 + 56) & 1) == 0)
      xmlRelaxNGDumpValidError(a4);
LABEL_27:
    *(_DWORD *)(a4 + 160) = -1;
    return;
  }
  v7 = *(xmlRegexp **)(a3 + 104);
  if (!v7)
  {
    *(_DWORD *)(a4 + 160) = 0;
    *(_QWORD *)(a4 + 176) = a3;
    return;
  }
  v8 = xmlRegNewExecCtxt(v7, (xmlRegExecCallbacks)xmlRelaxNGValidateProgressiveCallback, (void *)a4);
  if (!v8)
    goto LABEL_27;
  xmlRelaxNGElemPush(a4, (uint64_t)v8);
  v9 = xmlRelaxNGNewValidState(a4, v6);
  if (!v9)
    goto LABEL_27;
  v10 = *(_QWORD *)(a4 + 96);
  *(_QWORD *)(a4 + 96) = v9;
  v11 = *(_QWORD *)(a3 + 72);
  if (!v11)
    goto LABEL_12;
  v12 = xmlRelaxNGValidateAttributeList(a4, v11);
  if (v12)
  {
    *(_DWORD *)(a4 + 160) = -1;
    xmlRelaxNGAddValidError(a4, 24, *(xmlChar **)(v6 + 16), 0, 0);
  }
  v9 = *(_QWORD **)(a4 + 96);
  if (!v9)
  {
    v13 = *(int **)(a4 + 104);
    if (v13)
    {
      v14 = *(_DWORD *)(a4 + 56);
      v15 = v14;
      if (*v13 < 1)
      {
LABEL_36:
        *(_DWORD *)(a4 + 56) = v15 | 1;
        xmlRelaxNGLogBestError(a4);
        v18 = 1;
      }
      else
      {
        v16 = 0;
        while (1)
        {
          v17 = *(_QWORD *)(*((_QWORD *)v13 + 1) + 8 * v16);
          *(_QWORD *)(a4 + 96) = v17;
          *(_QWORD *)(v17 + 8) = 0;
          if (!xmlRelaxNGValidateElementEnd(a4, 0))
            break;
          ++v16;
          v13 = *(int **)(a4 + 104);
          if (v16 >= *v13)
          {
            v15 = *(_DWORD *)(a4 + 56);
            goto LABEL_36;
          }
        }
        v18 = 0;
      }
      v19 = *(int **)(a4 + 104);
      if (*v19 >= 1)
      {
        v20 = 0;
        do
        {
          xmlRelaxNGFreeValidState(a4, *(_QWORD **)(*((_QWORD *)v19 + 1) + 8 * v20++));
          v19 = *(int **)(a4 + 104);
        }
        while (v20 < *v19);
      }
      xmlRelaxNGFreeStates(a4, (void **)v19);
      *(_QWORD *)(a4 + 104) = 0;
      v21 = v18 ^ 1;
      if (v12)
        v21 = 1;
      if ((v21 & 1) == 0)
        *(_DWORD *)(a4 + 160) = -1;
      *(_DWORD *)(a4 + 56) = v14;
    }
  }
  else
  {
LABEL_12:
    v9[1] = 0;
    if (xmlRelaxNGValidateElementEnd(a4, 1))
      *(_DWORD *)(a4 + 160) = -1;
    xmlRelaxNGFreeValidState(a4, *(_QWORD **)(a4 + 96));
  }
  if (*(_DWORD *)(a4 + 160) == -1 && (*(_BYTE *)(a4 + 56) & 1) == 0)
    xmlRelaxNGDumpValidError(a4);
  *(_QWORD *)(a4 + 96) = v10;
}

_DWORD *xmlRelaxNGElemPush(uint64_t a1, uint64_t a2)
{
  _DWORD *result;
  int v5;
  uint64_t v6;

  result = *(_DWORD **)(a1 + 152);
  if (result || (*(_DWORD *)(a1 + 148) = 10, result = xmlMalloc(0x50uLL), (*(_QWORD *)(a1 + 152) = result) != 0))
  {
    v5 = *(_DWORD *)(a1 + 144);
    v6 = *(int *)(a1 + 148);
    if (v5 < (int)v6)
    {
LABEL_6:
      *(_DWORD *)(a1 + 144) = v5 + 1;
      *(_QWORD *)&result[2 * v5] = a2;
      *(_QWORD *)(a1 + 136) = a2;
      return result;
    }
    *(_DWORD *)(a1 + 148) = 2 * v6;
    result = xmlRealloc(result, 16 * v6);
    *(_QWORD *)(a1 + 152) = result;
    if (result)
    {
      v5 = *(_DWORD *)(a1 + 144);
      goto LABEL_6;
    }
  }
  return xmlRngVErrMemory(a1, (const xmlChar *)"validating\n");
}

int xmlRelaxNGValidatePushCData(xmlRelaxNGValidCtxtPtr ctxt, const xmlChar *data, int len)
{
  int v3;
  xmlRegExecCtxt *v5;
  unsigned int v6;

  v3 = -1;
  if (ctxt)
  {
    if (data)
    {
      v5 = (xmlRegExecCtxt *)*((_QWORD *)ctxt + 17);
      if (v5)
      {
        while (1)
        {
          v6 = *data;
          if (v6 > 0x20)
            goto LABEL_8;
          if (((1 << v6) & 0x100002600) == 0)
            break;
          ++data;
        }
        if (!*data)
          return 1;
LABEL_8:
        if ((xmlRegExecPushString(v5, (const xmlChar *)"#text", ctxt) & 0x80000000) == 0)
          return 1;
        xmlRelaxNGAddValidError((uint64_t)ctxt, 39, (xmlChar *)" TODO ", 0, 0);
        return -1;
      }
    }
  }
  return v3;
}

int xmlRelaxNGValidatePopElement(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem)
{
  int v3;
  int v5;
  unsigned int v6;
  uint64_t v7;
  xmlRegExecCtxt *v8;
  uint64_t v9;
  int v10;

  v3 = -1;
  if (ctxt && elem && *((_QWORD *)ctxt + 17))
  {
    v5 = *((_DWORD *)ctxt + 36);
    v6 = v5 - 1;
    if (v5 < 1)
    {
      v8 = 0;
    }
    else
    {
      *((_DWORD *)ctxt + 36) = v6;
      v7 = *((_QWORD *)ctxt + 19);
      v8 = *(xmlRegExecCtxt **)(v7 + 8 * v6);
      *(_QWORD *)(v7 + 8 * v6) = 0;
      if (v5 == 1)
        v9 = 0;
      else
        v9 = *(_QWORD *)(*((_QWORD *)ctxt + 19) + 8 * (v5 - 2));
      *((_QWORD *)ctxt + 17) = v9;
    }
    v10 = xmlRegExecPushString(v8, 0, 0);
    if (v10)
      v3 = (v10 >> 31) | 1;
    else
      xmlRelaxNGAddValidError((uint64_t)ctxt, 22, (xmlChar *)&byte_1B0865C1A, 0, 0);
    xmlRegFreeExecCtxt(v8);
  }
  return v3;
}

int xmlRelaxNGValidateFullElement(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem)
{
  int v4;
  _QWORD *v6;

  if (!ctxt)
    return -1;
  v4 = -1;
  if (elem)
  {
    if (*((_QWORD *)ctxt + 22))
    {
      v6 = xmlRelaxNGNewValidState((uint64_t)ctxt, (uint64_t)elem->parent);
      if (v6)
      {
        v6[1] = elem;
        *((_QWORD *)ctxt + 12) = v6;
        *((_DWORD *)ctxt + 17) = 0;
        if (!xmlRelaxNGValidateDefinition((uint64_t)ctxt, *((_QWORD *)ctxt + 22)))
        {
          if (*((_DWORD *)ctxt + 17))
            v4 = -1;
          else
            v4 = 1;
        }
        xmlRelaxNGFreeValidState((uint64_t)ctxt, *((_QWORD **)ctxt + 12));
        *((_QWORD *)ctxt + 12) = 0;
      }
    }
  }
  return v4;
}

_QWORD *xmlRelaxNGNewValidState(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  xmlNodePtr v6;
  xmlNodePtr RootElement;
  uint64_t v8;
  unsigned int v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  void *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD v18[10];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  memset(v18, 0, sizeof(v18));
  if (a2)
  {
    v4 = *(_QWORD *)(a2 + 88);
    if (v4)
    {
      v5 = 0;
      do
      {
        if (v5 <= 0x13)
          *((_QWORD *)v18 + v5) = v4;
        ++v5;
        v4 = *(_QWORD *)(v4 + 48);
      }
      while (v4);
      v6 = 0;
    }
    else
    {
      LODWORD(v5) = 0;
      v6 = 0;
    }
  }
  else
  {
    RootElement = xmlDocGetRootElement(*(const xmlDoc **)(a1 + 48));
    if (!RootElement)
      return 0;
    v6 = RootElement;
    LODWORD(v5) = 0;
  }
  v8 = *(_QWORD *)(a1 + 112);
  if (v8 && (v9 = *(_DWORD *)v8 - 1, *(int *)v8 >= 1))
  {
    *(_DWORD *)v8 = v9;
    v10 = *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * v9);
  }
  else
  {
    v11 = xmlMalloc(0x38uLL);
    v10 = v11;
    if (!v11)
      goto LABEL_30;
    v11[6] = 0;
    *((_OWORD *)v11 + 1) = 0u;
    *((_OWORD *)v11 + 2) = 0u;
    *(_OWORD *)v11 = 0u;
  }
  v10[4] = 0;
  v10[5] = 0;
  if (a2)
  {
    v6 = *(xmlNodePtr *)(a2 + 24);
    v12 = a2;
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 48);
  }
  *v10 = v12;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = 0;
  if (!(_DWORD)v5)
    goto LABEL_34;
  v13 = (void *)v10[6];
  if (v13)
  {
    if (*((_DWORD *)v10 + 5) >= (int)v5)
      goto LABEL_28;
    v13 = xmlRealloc(v13, 8 * v5);
    if (v13)
    {
      v10[6] = v13;
      *((_DWORD *)v10 + 5) = v5;
LABEL_28:
      *((_DWORD *)v10 + 4) = v5;
      if (v5 > 0x13)
      {
        v15 = *(_QWORD *)(a2 + 88);
        if (v15)
        {
          v16 = 0;
          do
          {
            *(_QWORD *)(v10[6] + v16) = v15;
            v15 = *(_QWORD *)(v15 + 48);
            v16 += 8;
          }
          while (v15);
        }
      }
      else
      {
        memcpy(v13, v18, 8 * v5);
        LODWORD(v5) = *((_DWORD *)v10 + 4);
      }
LABEL_34:
      *((_DWORD *)v10 + 6) = v5;
      return v10;
    }
  }
  else
  {
    if (v5 <= 4)
      v14 = 4;
    else
      v14 = v5;
    *((_DWORD *)v10 + 5) = v14;
    v13 = xmlMalloc(8 * v14);
    v10[6] = v13;
    if (v13)
      goto LABEL_28;
  }
LABEL_30:
  xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
  return v10;
}

uint64_t xmlRelaxNGValidateDefinition(uint64_t a1, uint64_t a2)
{
  int **v4;
  xmlGenericErrorFunc v5;
  void **v6;
  int *v7;
  int **v8;
  int v9;
  uint64_t v10;
  xmlGenericErrorFunc v11;
  void **v12;
  int *v13;
  int v14;
  uint64_t v15;
  int v16;
  int *v17;
  int v18;
  _QWORD *v19;
  xmlGenericErrorFunc v20;
  void **v21;
  int **v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  void **v29;
  xmlGenericErrorFunc v30;
  void **v31;
  int v33;

  v4 = (int **)(a1 + 96);
  if (*(_QWORD *)(a1 + 96) && *(_QWORD *)(a1 + 104))
  {
    v5 = *__xmlGenericError();
    v6 = __xmlGenericErrorContext();
    v5(*v6, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10667);
    xmlRelaxNGFreeValidState(a1, *(_QWORD **)(a1 + 96));
    *(_QWORD *)(a1 + 96) = 0;
  }
  v8 = (int **)(a1 + 104);
  v7 = *(int **)(a1 + 104);
  if (!v7)
    goto LABEL_7;
  v9 = *v7;
  if (*v7 != 1)
  {
    *(_QWORD *)(a1 + 104) = 0;
    v14 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 56) = v14 | 1;
    if (v9 <= 0)
    {
      *(_DWORD *)(a1 + 56) = v14;
      goto LABEL_47;
    }
    v33 = v14;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    while (1)
    {
      *(_QWORD *)(a1 + 96) = *(_QWORD *)(*((_QWORD *)v7 + 1) + 8 * v15);
      *(_QWORD *)(a1 + 104) = 0;
      v18 = xmlRelaxNGValidateState(a1, a2);
      v19 = *(_QWORD **)(a1 + 96);
      if (v19 && *v8)
      {
        v20 = *__xmlGenericError();
        v21 = __xmlGenericErrorContext();
        v20(*v21, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10704);
        xmlRelaxNGFreeValidState(a1, *(_QWORD **)(a1 + 96));
        v19 = 0;
        *(_QWORD *)(a1 + 96) = 0;
      }
      if (!v18)
        break;
      if (v19)
      {
        xmlRelaxNGFreeValidState(a1, v19);
        goto LABEL_21;
      }
      v26 = *v8;
      if (*v8)
      {
        if (*v26 >= 1)
        {
          v27 = 0;
          do
          {
            xmlRelaxNGFreeValidState(a1, *(_QWORD **)(*((_QWORD *)v26 + 1) + 8 * v27++));
            v26 = *(int **)(a1 + 104);
          }
          while (v27 < *v26);
        }
        v25 = a1;
        goto LABEL_33;
      }
LABEL_35:
      if (++v15 >= *v7)
      {
        *(_DWORD *)(a1 + 56) = v33;
        if (v17)
        {
          xmlRelaxNGFreeStates(a1, (void **)v7);
          v10 = 0;
          *(_QWORD *)(a1 + 104) = v17;
          goto LABEL_54;
        }
        if (v16 >= 2)
        {
          v10 = 0;
          *v7 = v16;
          *v8 = v7;
          goto LABEL_54;
        }
        if (v16 == 1)
        {
          *(_QWORD *)(a1 + 96) = **((_QWORD **)v7 + 1);
          xmlRelaxNGFreeStates(a1, (void **)v7);
          v10 = 0;
          goto LABEL_54;
        }
LABEL_47:
        xmlRelaxNGFreeStates(a1, (void **)v7);
        v29 = *(void ***)(a1 + 104);
        if (v29)
        {
          xmlRelaxNGFreeStates(a1, v29);
          *(_QWORD *)(a1 + 104) = 0;
        }
        v10 = 0xFFFFFFFFLL;
LABEL_54:
        if (*v4 && *v8)
        {
          v30 = *__xmlGenericError();
          v31 = __xmlGenericErrorContext();
          v30(*v31, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10770);
          xmlRelaxNGFreeValidState(a1, *(_QWORD **)(a1 + 96));
          v8 = v4;
LABEL_57:
          *v8 = 0;
        }
        return v10;
      }
    }
    v23 = *v8;
    if (*v8)
    {
      if (!v17)
      {
        *v8 = 0;
        if (v16 >= 1)
        {
          v28 = 0;
          do
          {
            xmlRelaxNGAddStates(a1, v23, *(_QWORD *)(*((_QWORD *)v7 + 1) + v28));
            v28 += 8;
          }
          while (8 * v16 != v28);
        }
        v17 = v23;
        goto LABEL_35;
      }
      if (*v23 >= 1)
      {
        v24 = 0;
        do
        {
          xmlRelaxNGAddStates(a1, v17, *(_QWORD *)(*((_QWORD *)v23 + 1) + 8 * v24++));
          v23 = *(int **)(a1 + 104);
        }
        while (v24 < *v23);
      }
      v25 = a1;
      v26 = v23;
LABEL_33:
      xmlRelaxNGFreeStates(v25, (void **)v26);
      v22 = (int **)(a1 + 104);
    }
    else if (v17)
    {
      xmlRelaxNGAddStates(a1, v17, (uint64_t)v19);
LABEL_21:
      v22 = v4;
    }
    else
    {
      *(_QWORD *)(*((_QWORD *)v7 + 1) + 8 * v16) = v19;
      v22 = v4;
      ++v16;
    }
    *v22 = 0;
    goto LABEL_35;
  }
  *(_QWORD *)(a1 + 96) = **((_QWORD **)v7 + 1);
  xmlRelaxNGFreeStates(a1, (void **)v7);
  *(_QWORD *)(a1 + 104) = 0;
LABEL_7:
  v10 = xmlRelaxNGValidateState(a1, a2);
  if (*(_QWORD *)(a1 + 96))
  {
    if (!*v8)
      return v10;
    v11 = *__xmlGenericError();
    v12 = __xmlGenericErrorContext();
    v11(*v12, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10679);
    xmlRelaxNGFreeValidState(a1, *(_QWORD **)(a1 + 96));
    *(_QWORD *)(a1 + 96) = 0;
  }
  v13 = *v8;
  if (*v8 && *v13 == 1)
  {
    *(_QWORD *)(a1 + 96) = **((_QWORD **)v13 + 1);
    xmlRelaxNGFreeStates(a1, (void **)v13);
    goto LABEL_57;
  }
  return v10;
}

void xmlRelaxNGFreeValidState(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  int v5;
  uint64_t v6;
  _QWORD *v7;
  void *v8;

  if (a2)
  {
    if (a1
      && ((v4 = *(_QWORD **)(a1 + 112)) != 0 || (v4 = xmlRelaxNGNewStates(a1, 40), (*(_QWORD *)(a1 + 112) = v4) != 0)))
    {
      v5 = *(_DWORD *)v4;
      v6 = *((int *)v4 + 1);
      if (*(_DWORD *)v4 >= (int)v6)
      {
        v7 = xmlRealloc((void *)v4[1], 16 * v6);
        if (!v7)
        {
          xmlRngVErrMemory(a1, (const xmlChar *)"adding states\n");
          return;
        }
        v4[1] = v7;
        *((_DWORD *)v4 + 1) = 2 * v6;
        v5 = *(_DWORD *)v4;
      }
      else
      {
        v7 = (_QWORD *)v4[1];
      }
      *(_DWORD *)v4 = v5 + 1;
      v7[v5] = a2;
    }
    else
    {
      v8 = (void *)a2[6];
      if (v8)
        xmlFree(v8);
      xmlFree(a2);
    }
  }
}

xmlRelaxNGValidCtxtPtr xmlRelaxNGNewValidCtxt(xmlRelaxNGPtr schema)
{
  _OWORD *v2;
  _OWORD *v3;

  v2 = xmlMalloc(0xC0uLL);
  v3 = v2;
  if (v2)
  {
    v2[10] = 0u;
    v2[11] = 0u;
    v2[8] = 0u;
    v2[9] = 0u;
    v2[6] = 0u;
    v2[7] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *v2 = 0u;
    v2[1] = 0u;
    *((_QWORD *)v2 + 5) = schema;
    *((_QWORD *)v2 + 1) = *__xmlGenericError();
    *(_QWORD *)v3 = *__xmlGenericErrorContext();
    *((_QWORD *)v3 + 10) = 0;
    *((_QWORD *)v3 + 11) = 0;
    *((_QWORD *)v3 + 9) = 0;
    if (schema)
      *((_DWORD *)v3 + 16) = *((_DWORD *)schema + 6);
    *((_QWORD *)v3 + 16) = 0;
    *((_DWORD *)v3 + 17) = 0;
    *((_QWORD *)v3 + 13) = 0;
    *((_QWORD *)v3 + 14) = 0;
  }
  else
  {
    xmlRngVErrMemory(0, (const xmlChar *)"building context\n");
  }
  return (xmlRelaxNGValidCtxtPtr)v3;
}

_DWORD *xmlRngVErrMemory(uint64_t a1, const xmlChar *a2)
{
  uint64_t v3;
  void (*v4)(void *, const char *, ...);
  void *v5;
  char v7;

  if (a1)
  {
    v3 = a1;
    a1 = *(_QWORD *)(a1 + 24);
    if (a1)
      v4 = 0;
    else
      v4 = *(void (**)(void *, const char *, ...))(v3 + 8);
    v5 = *(void **)v3;
    ++*(_DWORD *)(v3 + 32);
    if (a2)
      return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x13u, 2, 3, 0, 0, a2, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a2);
    return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x13u, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n", v7);
  }
  v4 = 0;
  v5 = 0;
  if (!a2)
    return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x13u, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n", v7);
  return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x13u, 2, 3, 0, 0, a2, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a2);
}

void xmlRelaxNGFreeValidCtxt(xmlRelaxNGValidCtxtPtr ctxt)
{
  void **v2;
  void *v3;
  int v4;
  uint64_t v5;
  _QWORD *v6;
  void *v7;
  void *v8;
  int v9;
  uint64_t i;
  void **v11;
  void *v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  xmlRegExecCtxt *v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  uint64_t v20;

  if (ctxt)
  {
    v2 = (void **)*((_QWORD *)ctxt + 13);
    if (v2)
    {
      xmlFree(v2[1]);
      xmlFree(v2);
    }
    v3 = (void *)*((_QWORD *)ctxt + 14);
    if (v3)
    {
      v4 = *(_DWORD *)v3;
      if (*(int *)v3 >= 1)
      {
        v5 = 0;
        do
        {
          v6 = *(_QWORD **)(*((_QWORD *)v3 + 1) + 8 * v5);
          if (v6)
          {
            v7 = (void *)v6[6];
            if (v7)
              xmlFree(v7);
            xmlFree(v6);
            v3 = (void *)*((_QWORD *)ctxt + 14);
            v4 = *(_DWORD *)v3;
          }
          ++v5;
        }
        while (v5 < v4);
      }
      xmlFree(*((void **)v3 + 1));
      xmlFree(v3);
    }
    v8 = (void *)*((_QWORD *)ctxt + 16);
    if (v8)
    {
      v9 = *((_DWORD *)ctxt + 30);
      if (v9 >= 1)
      {
        for (i = 0; i < v9; ++i)
        {
          v11 = *(void ***)(*((_QWORD *)ctxt + 16) + 8 * i);
          if (v11)
          {
            xmlFree(v11[1]);
            xmlFree(v11);
            v9 = *((_DWORD *)ctxt + 30);
          }
        }
        v8 = (void *)*((_QWORD *)ctxt + 16);
      }
      xmlFree(v8);
    }
    v12 = (void *)*((_QWORD *)ctxt + 11);
    if (v12)
      xmlFree(v12);
    v13 = *((_QWORD *)ctxt + 19);
    if (v13)
    {
      v14 = *((_DWORD *)ctxt + 36);
      v15 = v14 - 1;
      if (v14 >= 1)
      {
        *((_DWORD *)ctxt + 36) = v15;
        v16 = *(xmlRegExecCtxt **)(v13 + 8 * v15);
        *(_QWORD *)(v13 + 8 * v15) = 0;
        if (v14 == 1)
          goto LABEL_28;
        v17 = *(_QWORD *)(*((_QWORD *)ctxt + 19) + 8 * (v14 - 2));
        while (1)
        {
          *((_QWORD *)ctxt + 17) = v17;
          if (!v16)
            break;
          xmlRegFreeExecCtxt(v16);
          v18 = *((_DWORD *)ctxt + 36);
          v19 = v18 - 1;
          if (v18 < 1)
            break;
          *((_DWORD *)ctxt + 36) = v19;
          v20 = *((_QWORD *)ctxt + 19);
          v16 = *(xmlRegExecCtxt **)(v20 + 8 * v19);
          *(_QWORD *)(v20 + 8 * v19) = 0;
          if (v18 == 1)
LABEL_28:
            v17 = 0;
          else
            v17 = *(_QWORD *)(*((_QWORD *)ctxt + 19) + 8 * (v18 - 2));
        }
      }
      xmlFree(*((void **)ctxt + 19));
    }
    xmlFree(ctxt);
  }
}

void xmlRelaxNGFreeStates(uint64_t a1, void **a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  if (a2)
  {
    if (a1)
    {
      v4 = *(_QWORD **)(a1 + 128);
      if (v4)
      {
        v5 = *(int *)(a1 + 124);
        if (*(_DWORD *)(a1 + 120) < (int)v5)
        {
LABEL_9:
          v6 = *(int *)(a1 + 120);
          *(_DWORD *)(a1 + 120) = v6 + 1;
          v4[v6] = a2;
          return;
        }
        v4 = xmlRealloc(v4, 16 * v5);
        if (v4)
        {
          *(_QWORD *)(a1 + 128) = v4;
          *(_DWORD *)(a1 + 124) *= 2;
          goto LABEL_9;
        }
        xmlRngVErrMemory(a1, (const xmlChar *)"storing states\n");
      }
      else
      {
        *(_QWORD *)(a1 + 120) = 0x2800000000;
        v4 = xmlMalloc(0x140uLL);
        *(_QWORD *)(a1 + 128) = v4;
        if (v4)
          goto LABEL_9;
        xmlRngVErrMemory(a1, (const xmlChar *)"storing states\n");
        v4 = *(_QWORD **)(a1 + 128);
        if (v4)
          goto LABEL_9;
      }
    }
    xmlFree(a2[1]);
    xmlFree(a2);
  }
}

void xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc err, xmlRelaxNGValidityWarningFunc warn, void *ctx)
{
  if (ctxt)
  {
    *(_QWORD *)ctxt = ctx;
    *((_QWORD *)ctxt + 1) = err;
    *((_QWORD *)ctxt + 2) = warn;
    *((_QWORD *)ctxt + 3) = 0;
  }
}

void xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt, xmlStructuredErrorFunc serror, void *ctx)
{
  if (ctxt)
  {
    *((_QWORD *)ctxt + 2) = 0;
    *((_QWORD *)ctxt + 3) = serror;
    *(_QWORD *)ctxt = ctx;
    *((_QWORD *)ctxt + 1) = 0;
  }
}

int xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc *err, xmlRelaxNGValidityWarningFunc *warn, void **ctx)
{
  int v4;

  if (!ctxt)
    return -1;
  if (err)
    *err = (xmlRelaxNGValidityErrorFunc)*((_QWORD *)ctxt + 1);
  if (warn)
    *warn = (xmlRelaxNGValidityWarningFunc)*((_QWORD *)ctxt + 2);
  v4 = 0;
  if (ctx)
    *ctx = *(void **)ctxt;
  return v4;
}

int xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
  int result;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  int v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  int v12;
  _QWORD *v13;
  _BOOL4 v14;
  int v15;
  _QWORD *v17;
  int v18;
  xmlElementType type;
  _xmlNode *children;
  xmlDocPtr v22;
  BOOL v23;
  xmlValidCtxt v24;

  result = -1;
  if (ctxt && doc)
  {
    *((_QWORD *)ctxt + 6) = doc;
    v5 = *((_QWORD *)ctxt + 5);
    if (v5)
    {
      *((_DWORD *)ctxt + 17) = 0;
      v6 = *(_QWORD *)(v5 + 8);
      if (v6)
      {
        v7 = xmlRelaxNGNewValidState((uint64_t)ctxt, 0);
        *((_QWORD *)ctxt + 12) = v7;
        v8 = xmlRelaxNGValidateDefinition((uint64_t)ctxt, *(_QWORD *)(v6 + 24));
        v9 = *((_QWORD *)ctxt + 12);
        if (v9 && v7[1])
        {
          if (!xmlRelaxNGSkipIgnored((uint64_t)ctxt, *(_QWORD *)(v9 + 8)) || v8 == -1)
            goto LABEL_25;
        }
        else
        {
          v10 = (int *)*((_QWORD *)ctxt + 13);
          if (!v10)
            goto LABEL_25;
          if (*v10 < 1)
          {
            v14 = 1;
          }
          else
          {
            v11 = 0;
            v12 = -1;
            do
            {
              v13 = *(_QWORD **)(*((_QWORD *)v10 + 1) + 8 * v11);
              if (!xmlRelaxNGSkipIgnored((uint64_t)ctxt, v13[1]))
                v12 = 0;
              xmlRelaxNGFreeValidState((uint64_t)ctxt, v13);
              ++v11;
              v10 = (int *)*((_QWORD *)ctxt + 13);
            }
            while (v11 < *v10);
            v14 = v12 == -1;
          }
          if (!v14 || v8 == -1)
          {
LABEL_25:
            v17 = (_QWORD *)*((_QWORD *)ctxt + 12);
            if (v17)
            {
              xmlRelaxNGFreeValidState((uint64_t)ctxt, v17);
              *((_QWORD *)ctxt + 12) = 0;
            }
            if (v8)
            {
              xmlRelaxNGDumpValidError((uint64_t)ctxt);
              if (*((_DWORD *)ctxt + 16) != 1)
              {
                v15 = v8;
                goto LABEL_39;
              }
            }
            else if (*((_DWORD *)ctxt + 16) != 1)
            {
              goto LABEL_36;
            }
            memset(&v24.node, 0, 88);
            v24.valid = 1;
            v24.warning = (xmlValidityWarningFunc)*((_QWORD *)ctxt + 2);
            *(_OWORD *)&v24.userData = *(_OWORD *)ctxt;
            v18 = xmlValidateDocumentFinal(&v24, doc);
            if (v18 == 1)
              v15 = v8;
            else
              v15 = -1;
            if (v8 || v18 != 1)
            {
LABEL_39:
              type = doc->type;
              if (type != XML_HTML_DOCUMENT_NODE && type != XML_DOCUMENT_NODE)
              {
                if (type != XML_ELEMENT_NODE)
                {
LABEL_54:
                  if (v15 == -1)
                    return 1;
                  else
                    return v15;
                }
                doc->version = 0;
              }
              children = doc->children;
              if (children)
              {
                while (1)
                {
                  do
                  {
                    v22 = (xmlDocPtr)children;
                    if (children->type != XML_ELEMENT_NODE)
                      break;
                    children->psvi = 0;
                    children = children->children;
                  }
                  while (children);
                  while (1)
                  {
                    children = v22->next;
                    if (children)
                      break;
                    v22 = (xmlDocPtr)v22->parent;
                    if (v22)
                      v23 = v22 == doc;
                    else
                      v23 = 1;
                    if (v23)
                      goto LABEL_54;
                  }
                }
              }
              goto LABEL_54;
            }
LABEL_36:
            if (*((_DWORD *)ctxt + 17))
              v15 = -1;
            else
              v15 = 0;
            goto LABEL_39;
          }
        }
        xmlRelaxNGAddValidError((uint64_t)ctxt, 35, 0, 0, 0);
        v8 = -1;
        goto LABEL_25;
      }
      xmlRelaxNGAddValidError((uint64_t)ctxt, 34, 0, 0, 0);
    }
    v15 = -1;
    goto LABEL_39;
  }
  return result;
}

void xmlRelaxNGFreeInclude(_QWORD *a1)
{
  void *v2;
  xmlDoc *v3;
  xmlRelaxNG *v4;

  v2 = (void *)a1[1];
  if (v2)
    xmlFree(v2);
  v3 = (xmlDoc *)a1[2];
  if (v3)
    xmlFreeDoc(v3);
  v4 = (xmlRelaxNG *)a1[4];
  if (v4)
    xmlRelaxNGFree(v4);
  xmlFree(a1);
}

void xmlRelaxNGFreePartition(void *a1)
{
  void *v2;
  int v3;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  void *v7;
  xmlHashTable *v8;

  if (a1)
  {
    v2 = (void *)*((_QWORD *)a1 + 3);
    if (v2)
    {
      v3 = *(_DWORD *)a1;
      if (*(int *)a1 >= 1)
      {
        v4 = 0;
        do
        {
          v5 = *(_QWORD **)(*((_QWORD *)a1 + 3) + 8 * v4);
          if (v5)
          {
            v6 = (void *)v5[1];
            if (v6)
              xmlFree(v6);
            v7 = (void *)v5[2];
            if (v7)
              xmlFree(v7);
            xmlFree(v5);
            v3 = *(_DWORD *)a1;
          }
          ++v4;
        }
        while (v4 < v3);
        v2 = (void *)*((_QWORD *)a1 + 3);
      }
      xmlFree(v2);
    }
    v8 = (xmlHashTable *)*((_QWORD *)a1 + 1);
    if (v8)
      xmlHashFree(v8, 0);
    xmlFree(a1);
  }
}

_BYTE *xmlRelaxNGNormalize(uint64_t a1, _BYTE *a2)
{
  _BYTE *v2;
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  _BYTE *result;
  unsigned int v8;
  _BYTE *i;
  char v11;

  if (!a2)
    return 0;
  v2 = a2;
  v4 = 0;
  v5 = a2;
  do
  {
    v6 = *v5++;
    v4 += 0x100000000;
  }
  while (v6);
  result = xmlMallocAtomic(v4 >> 32);
  if (result)
  {
    while (1)
    {
      v8 = *v2;
      if (v8 > 0x20 || ((1 << v8) & 0x100002600) == 0)
        break;
      ++v2;
    }
    for (i = result; ; ++i)
    {
      if (v8 > 0x20u)
        goto LABEL_19;
      if (((1 << v8) & 0x100002600) == 0)
        break;
      while (v8 <= 0x20u)
      {
        if (((1 << v8) & 0x100002600) == 0)
        {
          if (!(_BYTE)v8)
            goto LABEL_21;
          break;
        }
        v11 = *++v2;
        LOBYTE(v8) = v11;
      }
      LOBYTE(v8) = 32;
LABEL_20:
      *i = v8;
      LOBYTE(v8) = *v2;
    }
    if (!(_BYTE)v8)
    {
LABEL_21:
      *i = 0;
      return result;
    }
LABEL_19:
    ++v2;
    goto LABEL_20;
  }
  xmlRngVErrMemory(a1, (const xmlChar *)"validating\n");
  return 0;
}

void xmlRelaxNGCleanupTree(uint64_t a1, uint64_t a2)
{
  xmlNode *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  _BYTE *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const xmlChar *v14;
  const char *v15;
  const xmlChar *v16;
  const char *v17;
  const xmlChar *v18;
  xmlChar *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  const char *v23;
  xmlChar *String;
  xmlChar *v25;
  xmlURIPtr v26;
  xmlURI *v27;
  uint64_t v28;
  unsigned int v29;
  BOOL v30;
  int v31;
  uint64_t v33;
  const xmlChar *v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  const char *v38;
  xmlChar *Base;
  uint64_t v40;
  xmlChar *v41;
  xmlChar *Prop;
  xmlChar *v43;
  xmlChar *v44;
  xmlChar *v45;
  xmlChar *v46;
  uint64_t v47;
  xmlChar *v48;
  xmlChar *v49;
  xmlChar *v50;
  xmlURIPtr v51;
  xmlURI *v52;
  xmlChar *v53;
  xmlChar *v54;
  xmlNode *v55;
  xmlNode *v56;
  xmlNode *v57;
  xmlChar *v58;
  xmlChar *v59;
  xmlChar *v60;
  uint64_t v61;
  xmlDoc *v62;
  xmlDoc *v63;
  xmlChar *v64;
  const xmlNode *v65;
  xmlNode *v66;
  _QWORD *v67;
  int v68;
  uint64_t v69;
  xmlDocPtr v70;
  xmlNodePtr v71;
  char v72;
  xmlChar *v73;
  xmlChar *v74;
  uint64_t v75;
  _QWORD *v76;
  _QWORD *v77;
  xmlChar *v78;
  const xmlNode *RootElement;
  xmlNode *v80;
  void *v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  const char *v87;
  uint64_t v88;
  xmlChar *v89;
  xmlChar *v90;
  uint64_t v91;
  int v92;
  const char *v93;
  const xmlDoc *v94;
  int v95;
  unsigned int v96;
  uint64_t v97;
  uint64_t v98;
  xmlNodePtr v99;
  _xmlNode *children;
  xmlNode *v101;
  int v102;
  xmlNs *ns;
  int v104;
  int v105;
  int v106;
  unsigned __int8 *v107;
  xmlChar *v108;
  int v109;
  int v110;
  xmlChar *v111;
  xmlNode *v112;
  xmlNode *Sibling;
  xmlNode *next;
  uint64_t v115;
  uint64_t v116;
  _QWORD *v117;
  _QWORD *v118;
  xmlChar *Content;
  xmlChar *v120;
  xmlChar *v121;
  xmlChar *v122;
  xmlNsPtr v123;
  int v124;
  unsigned int v125;
  uint64_t v126;
  BOOL v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  int v131;
  const char *v132;
  int v133;
  uint64_t v134;
  int v135;
  int v136;
  int v137;
  uint64_t v138;
  xmlNode *node;
  _QWORD *v140;
  xmlDocPtr cur;
  xmlDocPtr cura;
  xmlDocPtr curb;
  xmlDoc *doc;
  xmlDocPtr doca;
  xmlChar *prefix;

  if (!a2)
    return;
  v4 = 0;
  v5 = a2;
  while (1)
  {
LABEL_3:
    v6 = v5;
    if (v4)
    {
      xmlUnlinkNode(v4);
      xmlFreeNode(v4);
    }
    v7 = *(_DWORD *)(v6 + 8);
    if ((v7 - 3) >= 2)
      break;
    v8 = *(_BYTE **)(v6 + 80);
    if (v8)
    {
      while (1)
      {
        v9 = *v8;
        if (v9 > 0x20)
          break;
        if (((1 << v9) & 0x100002600) == 0)
        {
          if (*v8)
            break;
          goto LABEL_51;
        }
        ++v8;
      }
LABEL_54:
      v4 = 0;
      goto LABEL_55;
    }
LABEL_51:
    v28 = *(_QWORD *)(v6 + 40);
    v4 = (xmlNode *)v6;
    if (!v28)
      goto LABEL_257;
    v4 = (xmlNode *)v6;
    if (*(_DWORD *)(v28 + 8) != 1)
      goto LABEL_257;
    if (xmlStrEqual(*(const xmlChar **)(v28 + 16), (const xmlChar *)"value"))
      goto LABEL_54;
    if (xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v6 + 40) + 16), (const xmlChar *)"param"))
      v4 = 0;
    else
      v4 = (xmlNode *)v6;
LABEL_55:
    v5 = *(_QWORD *)(v6 + 24);
    if (v5)
    {
      v29 = *(_DWORD *)(v5 + 8);
      v30 = v29 > 0x11;
      v31 = (1 << v29) & 0x20060;
      if (v30 || v31 == 0)
        continue;
    }
    goto LABEL_257;
  }
  v4 = (xmlNode *)v6;
  if (v7 != 1)
    goto LABEL_257;
  v10 = *(_QWORD *)(v6 + 72);
  if (!v10 || !xmlStrEqual(*(const xmlChar **)(v10 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    v33 = *(_QWORD *)(v6 + 40);
    v4 = (xmlNode *)v6;
    if (!v33)
      goto LABEL_257;
    v4 = (xmlNode *)v6;
    if (*(_DWORD *)(v33 + 8) != 1)
      goto LABEL_257;
    if (!xmlStrEqual(*(const xmlChar **)(v33 + 16), (const xmlChar *)"name")
      && !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v6 + 40) + 16), (const xmlChar *)"value"))
    {
      v4 = (xmlNode *)v6;
      if (!xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v6 + 40) + 16), (const xmlChar *)"param"))
        goto LABEL_257;
    }
    v34 = *(const xmlChar **)(*(_QWORD *)(v6 + 40) + 16);
    v35 = a1;
    v36 = v6;
    v37 = 1035;
    v38 = "element %s doesn't allow foreign elements\n";
    goto LABEL_68;
  }
  v11 = *(_QWORD *)(v6 + 88);
  if (v11)
  {
    while (1)
    {
      v12 = v11;
      v11 = *(_QWORD *)(v11 + 48);
      v13 = *(_QWORD *)(v12 + 72);
      if (v13 && !xmlStrEqual(*(const xmlChar **)(v13 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        goto LABEL_35;
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"name"))
        break;
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"type"))
      {
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"value"))
          goto LABEL_35;
        v16 = *(const xmlChar **)(v6 + 16);
        v17 = "data";
        goto LABEL_32;
      }
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"href"))
      {
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"externalRef"))
          goto LABEL_35;
        v16 = *(const xmlChar **)(v6 + 16);
        v17 = "include";
        goto LABEL_32;
      }
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"combine"))
      {
        v14 = *(const xmlChar **)(v6 + 16);
        v15 = "start";
        goto LABEL_30;
      }
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"datatypeLibrary"))
      {
        String = xmlNodeListGetString(*(xmlDocPtr *)(v6 + 64), *(const xmlNode **)(v12 + 24), 1);
        if (String)
        {
          v25 = String;
          if (*String)
          {
            v26 = xmlParseURI((const char *)String);
            if (v26)
            {
              v27 = v26;
              if (!v26->scheme)
                xmlRngPErr(a1, v6, 1118, "Attribute %s URI %s is not absolute\n", *(const xmlChar **)(v12 + 16), v25);
              if (v27->fragment)
                xmlRngPErr(a1, v6, 1117, "Attribute %s URI %s has a fragment ID\n", *(const xmlChar **)(v12 + 16), v25);
              xmlFreeURI(v27);
            }
            else
            {
              xmlRngPErr(a1, v6, 1050, "Attribute %s contains invalid URI %s\n", *(const xmlChar **)(v12 + 16), v25);
            }
          }
          xmlFree(v25);
        }
        goto LABEL_35;
      }
      if (!xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"ns"))
      {
        v18 = *(const xmlChar **)(v12 + 16);
        v19 = *(xmlChar **)(v6 + 16);
        v20 = a1;
        v21 = v6;
        v22 = 1113;
        v23 = "Unknown attribute %s on %s\n";
        goto LABEL_34;
      }
LABEL_35:
      if (!v11)
        goto LABEL_69;
    }
    if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"element")
      || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"attribute")
      || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"ref")
      || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"parentRef"))
    {
      goto LABEL_35;
    }
    v14 = *(const xmlChar **)(v6 + 16);
    v15 = "param";
LABEL_30:
    if (xmlStrEqual(v14, (const xmlChar *)v15))
      goto LABEL_35;
    v16 = *(const xmlChar **)(v6 + 16);
    v17 = "define";
LABEL_32:
    if (!xmlStrEqual(v16, (const xmlChar *)v17))
    {
      v18 = *(const xmlChar **)(v12 + 16);
      v19 = *(xmlChar **)(v6 + 16);
      v20 = a1;
      v21 = v6;
      v22 = 1034;
      v23 = "Attribute %s is not allowed on %s\n";
LABEL_34:
      xmlRngPErr(v20, v21, v22, v23, v18, v19);
      goto LABEL_35;
    }
    goto LABEL_35;
  }
LABEL_69:
  if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"externalRef"))
  {
    if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"include"))
    {
      Prop = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"href");
      if (Prop)
      {
        v43 = Prop;
        Base = xmlNodeGetBase(*(const xmlDoc **)(v6 + 64), (const xmlNode *)v6);
        v44 = xmlBuildURI(v43, Base);
        if (!v44)
        {
          xmlRngPErr(a1, v6, 1041, "Failed to compute URL for include %s\n", v43, 0);
          xmlFree(v43);
          v4 = (xmlNode *)v6;
          if (!Base)
            goto LABEL_257;
          goto LABEL_98;
        }
        doc = (xmlDoc *)v44;
        xmlFree(v43);
        if (Base)
          xmlFree(Base);
        v45 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
        v46 = (xmlChar *)doc;
        if (!v45)
        {
          v47 = v6;
          while (1)
          {
            v47 = *(_QWORD *)(v47 + 40);
            if (!v47 || *(_DWORD *)(v47 + 8) != 1)
              break;
            v48 = xmlGetProp((const xmlNode *)v47, (const xmlChar *)"ns");
            if (v48)
            {
              v45 = v48;
              goto LABEL_144;
            }
          }
          v45 = 0;
        }
LABEL_144:
        if (*(int *)(a1 + 208) >= 1)
        {
          v75 = 0;
          while (!xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(*(_QWORD *)(a1 + 216) + 8 * v75) + 8), (const xmlChar *)doc))
          {
            if (++v75 >= *(int *)(a1 + 208))
              goto LABEL_148;
          }
          v84 = a1;
          v85 = 0;
          v86 = 1044;
          v87 = "Detected an Include recursion for %s\n";
          goto LABEL_220;
        }
LABEL_148:
        cura = xmlReadFile((const char *)doc, 0, 0);
        if (!cura)
        {
          v84 = a1;
          v85 = v6;
          v86 = 1065;
          v87 = "xmlRelaxNG: could not load %s\n";
          goto LABEL_220;
        }
        v76 = xmlMalloc(0x28uLL);
        v77 = v76;
        if (!v76)
        {
          xmlRngPErrMemory(a1, (const xmlChar *)"allocating include\n");
          xmlFreeDoc(cura);
          goto LABEL_221;
        }
        v76[4] = 0;
        *(_OWORD *)v76 = 0u;
        *((_OWORD *)v76 + 1) = 0u;
        v76[2] = cura;
        v78 = xmlStrdup((const xmlChar *)doc);
        *v77 = *(_QWORD *)(a1 + 120);
        v77[1] = v78;
        v140 = v77;
        *(_QWORD *)(a1 + 120) = v77;
        if (v45)
        {
          RootElement = xmlDocGetRootElement(cura);
          if (RootElement)
          {
            v80 = (xmlNode *)RootElement;
            if (!xmlHasProp(RootElement, (const xmlChar *)"ns"))
              xmlSetProp(v80, (const xmlChar *)"ns", v45);
          }
        }
        v81 = *(void **)(a1 + 216);
        if (v81
          || (*(_QWORD *)(a1 + 208) = 0x400000000, v81 = xmlMalloc(0x20uLL), (*(_QWORD *)(a1 + 216) = v81) != 0))
        {
          v82 = *(_DWORD *)(a1 + 208);
          v83 = *(int *)(a1 + 212);
          if (v82 < (int)v83)
            goto LABEL_175;
          *(_DWORD *)(a1 + 212) = 2 * v83;
          v81 = xmlRealloc(v81, 16 * v83);
          *(_QWORD *)(a1 + 216) = v81;
          if (v81)
          {
            v82 = *(_DWORD *)(a1 + 208);
LABEL_175:
            *((_QWORD *)v81 + v82) = v140;
            *(_QWORD *)(a1 + 200) = v140;
            *(_DWORD *)(a1 + 208) = v82 + 1;
            goto LABEL_176;
          }
        }
        xmlRngPErrMemory(a1, (const xmlChar *)"allocating include\n");
LABEL_176:
        v94 = (const xmlDoc *)xmlRelaxNGCleanupDoc(a1, cura);
        if (!v94)
        {
          v77 = 0;
          *(_QWORD *)(a1 + 200) = 0;
          goto LABEL_221;
        }
        v95 = *(_DWORD *)(a1 + 208);
        v96 = v95 - 1;
        if (v95 >= 1)
        {
          *(_DWORD *)(a1 + 208) = v96;
          v97 = *(_QWORD *)(a1 + 216);
          if (v95 == 1)
            v98 = 0;
          else
            v98 = *(_QWORD *)(v97 + 8 * (v95 - 2));
          *(_QWORD *)(a1 + 200) = v98;
          *(_QWORD *)(v97 + 8 * v96) = 0;
        }
        v99 = xmlDocGetRootElement(v94);
        if (v99)
        {
          if (v99->ns)
          {
            if (v99->type == XML_ELEMENT_NODE)
            {
              curb = (xmlDocPtr)v99;
              if (xmlStrEqual(v99->name, (const xmlChar *)"grammar"))
              {
                if (xmlStrEqual(*(const xmlChar **)(*(_QWORD *)&curb->compression + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                {
                  children = *(_xmlNode **)(v6 + 24);
                  if (children)
                  {
                    while (1)
                    {
                      v101 = children;
                      if (!children->ns)
                        goto LABEL_215;
                      node = children;
                      if (children->type != XML_ELEMENT_NODE)
                        goto LABEL_210;
                      v102 = xmlStrEqual(children->name, (const xmlChar *)"start");
                      v101 = node;
                      ns = node->ns;
                      if (!v102)
                        goto LABEL_200;
                      if (!xmlStrEqual(ns->href, (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                        break;
                      v104 = xmlRelaxNGRemoveRedefine((uint64_t)curb->children, 0);
                      v101 = node;
                      if (v104)
                        goto LABEL_210;
                      xmlRngPErr(a1, v6, 1107, "xmlRelaxNG: include %s has a start but not the included grammar\n", v46, 0);
LABEL_209:
                      v101 = node;
LABEL_210:
                      if (v101->ns)
                      {
                        if (v101->type == XML_ELEMENT_NODE)
                        {
                          v109 = xmlStrEqual(v101->name, (const xmlChar *)"div");
                          v101 = node;
                          if (v109)
                          {
                            v110 = xmlStrEqual(node->ns->href, (const xmlChar *)"http://relaxng.org/ns/structure/1.0");
                            v101 = node;
                            if (v110)
                            {
                              children = node->children;
                              if (children)
                                continue;
                            }
                          }
                        }
                      }
LABEL_215:
                      while (1)
                      {
                        children = v101->next;
                        if (children)
                          break;
                        v101 = v101->parent;
                        if (v101 == (xmlNode *)v6)
                          goto LABEL_217;
                      }
                    }
                    v101 = node;
                    ns = node->ns;
LABEL_200:
                    if (!ns)
                      goto LABEL_215;
                    if (v101->type != XML_ELEMENT_NODE)
                      goto LABEL_210;
                    v105 = xmlStrEqual(v101->name, (const xmlChar *)"define");
                    v101 = node;
                    if (!v105)
                      goto LABEL_210;
                    v106 = xmlStrEqual(node->ns->href, (const xmlChar *)"http://relaxng.org/ns/structure/1.0");
                    v101 = node;
                    if (!v106)
                      goto LABEL_210;
                    v107 = xmlGetProp(node, (const xmlChar *)"name");
                    if (v107)
                    {
                      v108 = v107;
                      xmlRelaxNGNormExtSpace(v107);
                      if (!xmlRelaxNGRemoveRedefine((uint64_t)curb->children, v108))
                        xmlRngPErr(a1, v6, 1013, "xmlRelaxNG: include %s has a define %s but not the included grammar\n", (const xmlChar *)doc, v108);
                      xmlFree(v108);
                      v46 = (xmlChar *)doc;
                    }
                    else
                    {
                      v46 = (xmlChar *)doc;
                      xmlRngPErr(a1, v6, 1053, "xmlRelaxNG: include %s has define without name\n", (const xmlChar *)doc, 0);
                    }
                    goto LABEL_209;
                  }
LABEL_217:
                  v77 = v140;
LABEL_221:
                  if (v45)
                    xmlFree(v45);
                  if (v77)
                  {
                    xmlFree(v46);
                    *(_QWORD *)(v6 + 104) = v77;
                    goto LABEL_225;
                  }
                  xmlRngPErr(a1, v6, 1043, "Failed to load include %s\n", v46, 0);
                  ((void (*)(xmlChar *))xmlFree)(v46);
LABEL_256:
                  v4 = (xmlNode *)v6;
                  goto LABEL_257;
                }
              }
            }
          }
          v84 = a1;
          v85 = v6;
          v86 = 1038;
          v87 = "xmlRelaxNG: included document %s root is not a grammar\n";
        }
        else
        {
          v84 = a1;
          v85 = v6;
          v86 = 1022;
          v87 = "xmlRelaxNG: included document is empty %s\n";
        }
LABEL_220:
        xmlRngPErr(v84, v85, v86, v87, (const xmlChar *)doc, 0);
        v77 = 0;
        goto LABEL_221;
      }
      v35 = a1;
      v36 = v6;
      v37 = 1052;
      v38 = "xmlRelaxNGParse: include has no href attribute\n";
      v34 = 0;
LABEL_68:
      xmlRngPErr(v35, v36, v37, v38, v34, 0);
      v4 = (xmlNode *)v6;
      goto LABEL_257;
    }
    if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"element")
      && !xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"attribute"))
    {
      if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"name")
        || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"nsName")
        || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"value"))
      {
        if (!xmlHasProp((const xmlNode *)v6, (const xmlChar *)"ns"))
        {
          v88 = v6;
          while (1)
          {
            v88 = *(_QWORD *)(v88 + 40);
            if (!v88 || *(_DWORD *)(v88 + 8) != 1)
              break;
            v89 = xmlGetProp((const xmlNode *)v88, (const xmlChar *)"ns");
            if (v89)
            {
              v90 = v89;
              xmlSetProp((xmlNodePtr)v6, (const xmlChar *)"ns", v89);
              xmlFree(v90);
              goto LABEL_241;
            }
          }
          xmlSetProp((xmlNodePtr)v6, (const xmlChar *)"ns", (const xmlChar *)&byte_1B0865C1A);
        }
LABEL_241:
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"name"))
        {
          prefix = 0;
          Content = xmlNodeGetContent((const xmlNode *)v6);
          if (Content)
          {
            v120 = Content;
            v121 = xmlSplitQName2(Content, &prefix);
            if (v121)
            {
              v122 = v121;
              v123 = xmlSearchNs(*(xmlDocPtr *)(v6 + 64), (xmlNodePtr)v6, prefix);
              if (v123)
              {
                xmlSetProp((xmlNodePtr)v6, (const xmlChar *)"ns", v123->href);
                xmlNodeSetContent((xmlNodePtr)v6, v122);
              }
              else
              {
                xmlRngPErr(a1, v6, 1097, "xmlRelaxNGParse: no namespace for prefix %s\n", prefix, 0);
              }
              xmlFree(v122);
              xmlFree(prefix);
            }
            xmlFree(v120);
          }
        }
        if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"nsName") || (*(_BYTE *)(a1 + 65) & 2) == 0)
          goto LABEL_225;
        v129 = a1;
        v130 = v6;
        v131 = 1085;
        v132 = "Found nsName/except//nsName forbidden construct\n";
      }
      else
      {
        v133 = xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"except");
        if (v6 != a2 && v133)
        {
          v134 = *(_QWORD *)(v6 + 40);
          if (!v134)
            goto LABEL_225;
          v135 = *(_DWORD *)(a1 + 64);
          if (xmlStrEqual(*(const xmlChar **)(v134 + 16), (const xmlChar *)"anyName"))
          {
            v136 = *(_DWORD *)(a1 + 64) | 0x100;
          }
          else
          {
            v138 = *(_QWORD *)(v6 + 40);
            if (!v138 || !xmlStrEqual(*(const xmlChar **)(v138 + 16), (const xmlChar *)"nsName"))
              goto LABEL_225;
            v136 = *(_DWORD *)(a1 + 64) | 0x200;
          }
          *(_DWORD *)(a1 + 64) = v136;
          xmlRelaxNGCleanupTree(a1, v6);
          v4 = 0;
          *(_DWORD *)(a1 + 64) = v135;
          goto LABEL_257;
        }
        if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"anyName"))
          goto LABEL_225;
        v137 = *(_DWORD *)(a1 + 64);
        if ((v137 & 0x100) != 0)
        {
          v129 = a1;
          v130 = v6;
          v131 = 1066;
          v132 = "Found anyName/except//anyName forbidden construct\n";
        }
        else
        {
          if ((v137 & 0x200) == 0)
            goto LABEL_225;
          v129 = a1;
          v130 = v6;
          v131 = 1084;
          v132 = "Found nsName/except//anyName forbidden construct\n";
        }
      }
      xmlRngPErr(v129, v130, v131, v132, 0, 0);
      goto LABEL_225;
    }
    v53 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"name");
    if (!v53)
      goto LABEL_225;
    v54 = v53;
    if (*(_QWORD *)(v6 + 24))
    {
      v55 = xmlNewDocNode(*(xmlDocPtr *)(v6 + 64), *(xmlNsPtr *)(v6 + 72), (const xmlChar *)"name", 0);
      if (v55)
      {
        v56 = v55;
        xmlAddPrevSibling(*(xmlNodePtr *)(v6 + 24), v55);
        v57 = xmlNewText(v54);
        xmlAddChild(v56, v57);
LABEL_135:
        v72 = 0;
        goto LABEL_137;
      }
    }
    else
    {
      v71 = xmlNewChild((xmlNodePtr)v6, *(xmlNsPtr *)(v6 + 72), (const xmlChar *)"name", v53);
      if (v71)
      {
        v56 = v71;
        goto LABEL_135;
      }
    }
    xmlRngPErr(a1, v6, 1008, "Failed to create a name %s element\n", v54, 0);
    v56 = 0;
    v72 = 1;
LABEL_137:
    xmlUnsetProp((xmlNodePtr)v6, (const xmlChar *)"name");
    xmlFree(v54);
    v73 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
    if (v73)
    {
      v74 = v73;
      if ((v72 & 1) == 0)
        xmlSetProp(v56, (const xmlChar *)"ns", v73);
      xmlFree(v74);
    }
    else if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"attribute"))
    {
      xmlSetProp(v56, (const xmlChar *)"ns", (const xmlChar *)&byte_1B0865C1A);
    }
    goto LABEL_225;
  }
  Base = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
  if (!Base)
  {
    v40 = v6;
    while (1)
    {
      v40 = *(_QWORD *)(v40 + 40);
      if (!v40 || *(_DWORD *)(v40 + 8) != 1)
        break;
      v41 = xmlGetProp((const xmlNode *)v40, (const xmlChar *)"ns");
      if (v41)
      {
        Base = v41;
        goto LABEL_91;
      }
    }
    Base = 0;
  }
LABEL_91:
  v49 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"href");
  if (!v49)
  {
    xmlRngPErr(a1, v6, 1052, "xmlRelaxNGParse: externalRef has no href attribute\n", 0, 0);
    v4 = (xmlNode *)v6;
    if (!Base)
      goto LABEL_257;
LABEL_98:
    ((void (*)(xmlChar *))xmlFree)(Base);
    goto LABEL_256;
  }
  v50 = v49;
  v51 = xmlParseURI((const char *)v49);
  if (!v51)
  {
    xmlRngPErr(a1, v6, 1041, "Incorrect URI for externalRef %s\n", v50, 0);
    if (Base)
      xmlFree(Base);
    ((void (*)(xmlChar *))xmlFree)(v50);
    goto LABEL_102;
  }
  v52 = v51;
  if (v51->fragment)
  {
    xmlRngPErr(a1, v6, 1041, "Fragment forbidden in URI for externalRef %s\n", v50, 0);
    if (Base)
      xmlFree(Base);
    xmlFreeURI(v52);
    ((void (*)(xmlChar *))xmlFree)(v50);
LABEL_102:
    v4 = (xmlNode *)v6;
    goto LABEL_257;
  }
  xmlFreeURI(v51);
  v58 = xmlNodeGetBase(*(const xmlDoc **)(v6 + 64), (const xmlNode *)v6);
  v59 = xmlBuildURI(v50, v58);
  if (v59)
  {
    v60 = v59;
    xmlFree(v50);
    if (v58)
      xmlFree(v58);
    if (*(int *)(a1 + 184) >= 1)
    {
      v61 = 0;
      while (!xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(*(_QWORD *)(a1 + 192) + 8 * v61) + 8), v60))
      {
        if (++v61 >= *(int *)(a1 + 184))
          goto LABEL_116;
      }
      v91 = a1;
      v92 = 1033;
      v93 = "Detected an externalRef recursion for %s\n";
      goto LABEL_171;
    }
LABEL_116:
    doca = xmlReadFile((const char *)v60, 0, 0);
    if (!doca)
    {
      v91 = a1;
      v92 = 1065;
      v93 = "xmlRelaxNG: could not load %s\n";
LABEL_171:
      xmlRngPErr(v91, 0, v92, v93, v60, 0);
LABEL_253:
      xmlRngPErr(a1, v6, 1032, "Failed to load externalRef %s\n", v60, 0);
      if (Base)
        xmlFree(Base);
      ((void (*)(xmlChar *))xmlFree)(v60);
      goto LABEL_256;
    }
    v62 = (xmlDoc *)xmlMalloc(0x30uLL);
    if (!v62)
    {
      xmlRngPErr(a1, (uint64_t)doca, 2, "xmlRelaxNG: allocate memory for doc %s\n", v60, 0);
      xmlFreeDoc(doca);
      goto LABEL_253;
    }
    v63 = v62;
    *(_OWORD *)&v62->name = 0u;
    *(_OWORD *)&v62->last = 0u;
    *(_OWORD *)&v62->_private = 0u;
    v62->name = (char *)doca;
    v64 = xmlStrdup(v60);
    v63->_private = *(void **)(a1 + 112);
    *(_QWORD *)&v63->type = v64;
    LODWORD(v63->parent) = 1;
    cur = v63;
    *(_QWORD *)(a1 + 112) = v63;
    if (Base)
    {
      v65 = xmlDocGetRootElement(doca);
      if (v65)
      {
        v66 = (xmlNode *)v65;
        if (!xmlHasProp(v65, (const xmlChar *)"ns"))
          xmlSetProp(v66, (const xmlChar *)"ns", Base);
      }
    }
    v67 = *(_QWORD **)(a1 + 192);
    if (v67 || (*(_QWORD *)(a1 + 184) = 0x400000000, v67 = xmlMalloc(0x20uLL), (*(_QWORD *)(a1 + 192) = v67) != 0))
    {
      v68 = *(_DWORD *)(a1 + 184);
      v69 = *(int *)(a1 + 188);
      if (v68 < (int)v69)
      {
        v70 = cur;
LABEL_185:
        v67[v68] = v70;
        *(_QWORD *)(a1 + 176) = v70;
        *(_DWORD *)(a1 + 184) = v68 + 1;
LABEL_247:
        if (!xmlRelaxNGCleanupDoc(a1, doca))
        {
          *(_QWORD *)(a1 + 176) = 0;
          goto LABEL_253;
        }
        v124 = *(_DWORD *)(a1 + 184);
        v125 = v124 - 1;
        if (v124 >= 1)
        {
          *(_DWORD *)(a1 + 184) = v125;
          v126 = *(_QWORD *)(a1 + 192);
          if (v124 == 1)
            v128 = 0;
          else
            v128 = *(_QWORD *)(v126 + 8 * (v124 - 2));
          *(_QWORD *)(a1 + 176) = v128;
          *(_QWORD *)(v126 + 8 * v125) = 0;
        }
        if (Base)
          xmlFree(Base);
        xmlFree(v60);
        *(_QWORD *)(v6 + 104) = cur;
LABEL_225:
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"div"))
        {
          v111 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
          v112 = *(xmlNode **)(v6 + 24);
          if (v112)
          {
            Sibling = (xmlNode *)v6;
            do
            {
              if (v111 && !xmlHasProp(v112, (const xmlChar *)"ns"))
                xmlSetProp(v112, (const xmlChar *)"ns", v111);
              next = v112->next;
              xmlUnlinkNode(v112);
              Sibling = xmlAddNextSibling(Sibling, v112);
              v112 = next;
            }
            while (next);
          }
          if (v111)
            xmlFree(v111);
          v115 = *(_QWORD *)(v6 + 96);
          v4 = (xmlNode *)v6;
          if (v115)
          {
            v116 = *(_QWORD *)(v6 + 40);
            v4 = (xmlNode *)v6;
            if (v116)
            {
              v117 = (_QWORD *)(v116 + 96);
              do
              {
                v118 = v117;
                v117 = (_QWORD *)*v117;
              }
              while (v117);
              *v118 = v115;
              *(_QWORD *)(v6 + 96) = 0;
              v4 = (xmlNode *)v6;
            }
          }
          goto LABEL_257;
        }
        goto LABEL_54;
      }
      *(_DWORD *)(a1 + 188) = 2 * v69;
      v67 = xmlRealloc(v67, 16 * v69);
      *(_QWORD *)(a1 + 192) = v67;
      v70 = cur;
      if (v67)
      {
        v68 = *(_DWORD *)(a1 + 184);
        goto LABEL_185;
      }
    }
    xmlRngPErrMemory(a1, (const xmlChar *)"adding document\n");
    goto LABEL_247;
  }
  xmlRngPErr(a1, v6, 1041, "Failed to compute URL for externalRef %s\n", v50, 0);
  if (Base)
    xmlFree(Base);
  xmlFree(v50);
  v4 = (xmlNode *)v6;
  if (v58)
  {
    ((void (*)(xmlChar *))xmlFree)(v58);
    goto LABEL_256;
  }
  do
  {
LABEL_257:
    v5 = *(_QWORD *)(v6 + 48);
    if (v5)
      goto LABEL_3;
    v6 = *(_QWORD *)(v6 + 40);
    if (v6)
      v127 = v6 == a2;
    else
      v127 = 1;
  }
  while (!v127);
  if (v4)
  {
    xmlUnlinkNode(v4);
    xmlFreeNode(v4);
  }
}

uint64_t xmlRelaxNGRemoveRedefine(uint64_t a1, const xmlChar *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *Prop;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  xmlNodePtr RootElement;

  if (a1)
  {
    v3 = a1;
    v4 = 0;
    while (1)
    {
      v5 = v3;
      v3 = *(_QWORD *)(v3 + 48);
      v6 = *(_QWORD *)(v5 + 72);
      if (a2)
      {
        if (!v6
          || *(_DWORD *)(v5 + 8) != 1
          || !xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"define")
          || !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v5 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          goto LABEL_17;
        }
        Prop = xmlGetProp((const xmlNode *)v5, (const xmlChar *)"name");
        xmlRelaxNGNormExtSpace(Prop);
        if (Prop)
        {
          if (xmlStrEqual(a2, Prop))
          {
            xmlUnlinkNode((xmlNodePtr)v5);
            xmlFreeNode((xmlNodePtr)v5);
            v4 = 1;
          }
          xmlFree(Prop);
        }
      }
      else
      {
        if (!v6
          || *(_DWORD *)(v5 + 8) != 1
          || !xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"start")
          || !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v5 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
LABEL_17:
          if (*(_QWORD *)(v5 + 72)
            && *(_DWORD *)(v5 + 8) == 1
            && xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"include")
            && xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v5 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            v8 = *(_QWORD *)(v5 + 104);
            if (v8)
            {
              v9 = *(_QWORD *)(v8 + 16);
              if (v9)
              {
                v10 = *(_QWORD *)(v9 + 24);
                if (v10)
                {
                  if (xmlStrEqual(*(const xmlChar **)(v10 + 16), (const xmlChar *)"grammar"))
                  {
                    RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v8 + 16));
                    if (xmlRelaxNGRemoveRedefine(RootElement->children, a2) == 1)
                      LODWORD(v4) = 1;
                  }
                }
              }
            }
            if (xmlRelaxNGRemoveRedefine(*(_QWORD *)(v5 + 24), a2) == 1)
              v4 = 1;
            else
              v4 = v4;
          }
          goto LABEL_30;
        }
        xmlUnlinkNode((xmlNodePtr)v5);
        xmlFreeNode((xmlNodePtr)v5);
        v4 = 1;
      }
LABEL_30:
      if (!v3)
        return v4;
    }
  }
  return 0;
}

unsigned __int8 *xmlRelaxNGNormExtSpace(unsigned __int8 *result)
{
  uint64_t i;
  unsigned int v2;
  BOOL v3;
  uint64_t v4;
  unsigned __int8 *j;
  uint64_t v7;
  unsigned __int8 k;
  unsigned __int8 v9;
  unsigned int v10;
  unsigned __int8 v11;
  unsigned __int8 *v12;
  unsigned __int8 v13;

  if (!result)
    return result;
  for (i = 0; ; ++i)
  {
    v2 = result[i];
    v3 = v2 > 0x20;
    v4 = (1 << v2) & 0x100002600;
    if (v3 || v4 == 0)
      break;
  }
  if (i)
  {
    for (j = &result[i]; ; ++j)
    {
      v7 = *j;
      if (v7 > 0x20)
      {
        k = *j;
      }
      else if (((1 << v7) & 0x100002600) != 0)
      {
        for (k = *j; k <= 0x20u; k = v9)
        {
          v7 = k;
          if (((1 << k) & 0x100002600) == 0)
            goto LABEL_17;
          v9 = *++j;
        }
      }
      else
      {
        k = *j;
LABEL_17:
        if (!v7)
          goto LABEL_30;
      }
      *result++ = k;
    }
  }
  while (1)
  {
LABEL_21:
    v10 = *result;
    if (v10 > 0x20)
      goto LABEL_29;
    v11 = *result;
    v12 = result;
    if (((1 << v10) & 0x100002600) != 0)
      break;
    if (!*result)
      return result;
LABEL_29:
    ++result;
  }
  while (1)
  {
    if (v11 > 0x20u)
      goto LABEL_27;
    if (((1 << v11) & 0x100002600) == 0)
      break;
    v13 = *++v12;
    v11 = v13;
  }
  if (v11)
  {
LABEL_27:
    result = v12;
    goto LABEL_21;
  }
LABEL_30:
  *result = 0;
  return result;
}

_QWORD *xmlRelaxNGParseGrammar(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  xmlChar *Prop;
  xmlChar *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  const char *v22;
  const xmlChar *v23;
  _OWORD *v24;
  _QWORD *v25;
  int v26;
  xmlHashTablePtr v27;
  int v28;
  uint64_t v29;
  const char *v30;
  char *v31;
  uint64_t v32;
  xmlHashTable *v33;
  xmlHashTable *v34;
  char __str[16];
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = xmlRelaxNGNewGrammar(a1);
  v5 = v4;
  if (!v4)
    return v5;
  v6 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)v4 = v6;
  if (v6)
  {
    v7 = (_QWORD *)(v6 + 8);
    v8 = *(_QWORD *)(v6 + 8);
    if (v8)
    {
      do
      {
        v9 = v8;
        v8 = *(_QWORD *)(v8 + 16);
      }
      while (v8);
      v7 = (_QWORD *)(v9 + 16);
    }
    *v7 = v4;
  }
  *(_QWORD *)(a1 + 48) = v4;
  xmlRelaxNGParseGrammarContent(a1, a2);
  *(_QWORD *)(a1 + 48) = v5;
  v10 = v5[3];
  if (!v10)
  {
    xmlRngPErr(a1, a2, 1039, "Element <grammar> has no <start>\n", 0, 0);
    v10 = v5[3];
    if (!v10)
      goto LABEL_42;
  }
  if (!*(_QWORD *)(v10 + 64))
    goto LABEL_42;
  v11 = 0;
  v12 = -1;
  v13 = v10;
  do
  {
    v14 = *(_QWORD *)(v13 + 8);
    if (v14
      && (v15 = *(_QWORD *)(v14 + 40)) != 0
      && (v16 = xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"start"), v14 = *(_QWORD *)(v13 + 8), v16))
    {
      Prop = xmlGetProp(*(const xmlNode **)(v14 + 40), (const xmlChar *)"combine");
      if (Prop)
      {
        v18 = Prop;
        if (xmlStrEqual(Prop, (const xmlChar *)"choice"))
        {
          if (v12)
          {
            v12 = 1;
LABEL_29:
            xmlFree(v18);
            goto LABEL_22;
          }
        }
        else
        {
          if (!xmlStrEqual(v18, (const xmlChar *)"interleave"))
          {
            v19 = *(_QWORD *)(v13 + 8);
            v20 = a1;
            v21 = 1114;
            v22 = "<start> uses unknown combine value '%s''\n";
            v23 = v18;
            goto LABEL_28;
          }
          if (v12 != 1)
          {
            v12 = 0;
            goto LABEL_29;
          }
        }
        v19 = *(_QWORD *)(v13 + 8);
        v20 = a1;
        v21 = 1104;
        v22 = "<start> use both 'choice' and 'interleave'\n";
        v23 = 0;
LABEL_28:
        xmlRngPErr(v20, v19, v21, v22, v23, 0);
        goto LABEL_29;
      }
    }
    else
    {
      xmlRngPErr(a1, v14, 1107, "Internal error: start element not found\n", 0, 0);
    }
    if (v11)
      xmlRngPErr(a1, *(_QWORD *)(v13 + 8), 1054, "Some <start> element miss the combine attribute\n", 0, 0);
    v11 = 1;
LABEL_22:
    v13 = *(_QWORD *)(v13 + 64);
  }
  while (v13);
  v24 = xmlRelaxNGNewDefine(a1, *(_QWORD *)(v10 + 8));
  if (v24)
  {
    v25 = v24;
    v26 = (v12 + 1) >= 2 ? 17 : 19;
    *(_DWORD *)v24 = v26;
    *((_QWORD *)v24 + 6) = v5[3];
    v5[3] = v24;
    if ((v12 + 1) <= 1)
    {
      if (*(_QWORD *)(a1 + 104) || (v27 = xmlHashCreate(10), (*(_QWORD *)(a1 + 104) = v27) != 0))
      {
        *(_OWORD *)__str = 0u;
        v37 = 0u;
        v28 = *(_DWORD *)(a1 + 96);
        *(_DWORD *)(a1 + 96) = v28 + 1;
        snprintf(__str, 0x20uLL, "interleave%d", v28);
        if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 104), (const xmlChar *)__str, v25) < 0)
        {
          v29 = v25[1];
          v30 = "Failed to add %s to hash table\n";
          v31 = __str;
          v32 = a1;
          goto LABEL_41;
        }
      }
      else
      {
        v29 = v25[1];
        v30 = "Failed to create interleaves hash table\n";
        v32 = a1;
        v31 = 0;
LABEL_41:
        xmlRngPErr(v32, v29, 1046, v30, (const xmlChar *)v31, 0);
      }
    }
  }
LABEL_42:
  v33 = (xmlHashTable *)v5[6];
  if (v33)
    xmlHashScan(v33, (xmlHashScanner)xmlRelaxNGCheckCombine, (void *)a1);
  v34 = (xmlHashTable *)v5[7];
  if (v34)
    xmlHashScan(v34, (xmlHashScanner)xmlRelaxNGCheckReference, (void *)a1);
  *(_QWORD *)(a1 + 48) = v6;
  return v5;
}

_OWORD *xmlRelaxNGNewGrammar(uint64_t a1)
{
  _OWORD *v2;
  _OWORD *v3;

  v2 = xmlMalloc(0x40uLL);
  v3 = v2;
  if (v2)
  {
    v2[2] = 0u;
    v2[3] = 0u;
    *v2 = 0u;
    v2[1] = 0u;
  }
  else
  {
    xmlRngPErrMemory(a1, 0);
  }
  return v3;
}

uint64_t xmlRelaxNGParseStart(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t **v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!*(_QWORD *)(a2 + 72) || *(_DWORD *)(a2 + 8) != 1)
    goto LABEL_17;
  v4 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"empty");
  v5 = *(_QWORD *)(a2 + 72);
  if (v4)
  {
    if (xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      v6 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
      if (v6)
      {
        v7 = v6;
        *(_DWORD *)v6 = 0;
        if (!*(_QWORD *)(a2 + 24))
          goto LABEL_18;
        v8 = "element empty is not empty\n";
        v9 = a1;
        v10 = a2;
        v11 = 1024;
        goto LABEL_8;
      }
      return 0xFFFFFFFFLL;
    }
    v5 = *(_QWORD *)(a2 + 72);
  }
  if (v5
    && *(_DWORD *)(a2 + 8) == 1
    && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"notAllowed")
    && xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    v12 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
    if (!v12)
      return 0xFFFFFFFFLL;
    v7 = v12;
    *(_DWORD *)v12 = 1;
    if (*(_QWORD *)(a2 + 24))
    {
      v8 = "element notAllowed is not empty\n";
      v9 = a1;
      v10 = a2;
      v11 = 1055;
LABEL_8:
      xmlRngPErr(v9, v10, v11, v8, 0, 0);
    }
  }
  else
  {
LABEL_17:
    v7 = xmlRelaxNGParsePatterns(a1, a2, 1);
  }
LABEL_18:
  v13 = *(_QWORD *)(a1 + 48);
  v16 = *(_QWORD *)(v13 + 24);
  v14 = (uint64_t **)(v13 + 24);
  v15 = v16;
  if (v16)
  {
    do
    {
      v17 = v15;
      v15 = *(_QWORD *)(v15 + 64);
    }
    while (v15);
    v14 = (uint64_t **)(v17 + 64);
  }
  *v14 = v7;
  v18 = *(_QWORD *)(a2 + 48);
  if (v18)
  {
    xmlRngPErr(a1, v18, 1105, "start more than one children\n", 0, 0);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t xmlRelaxNGCheckCycles(uint64_t a1, int *a2, uint64_t a3)
{
  int *v4;
  uint64_t v6;
  int v7;
  int v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;

  if (!a2)
    return 0;
  v4 = a2;
  v6 = (a3 + 1);
  while (1)
  {
    v7 = *v4;
    if (*v4 == 4)
    {
      v11 = *((_QWORD *)v4 + 6);
      v12 = a1;
      v13 = v6;
      goto LABEL_13;
    }
    if (v7 != 13 && v7 != 11)
    {
      v11 = *((_QWORD *)v4 + 6);
      v12 = a1;
      v13 = a3;
LABEL_13:
      result = xmlRelaxNGCheckCycles(v12, v11, v13);
      goto LABEL_15;
    }
    v9 = *((__int16 *)v4 + 48);
    if (v9 == -1)
    {
      *((_WORD *)v4 + 48) = a3;
      result = xmlRelaxNGCheckCycles(a1, *((_QWORD *)v4 + 6), a3);
      *((_WORD *)v4 + 48) = -2;
      goto LABEL_15;
    }
    if (v9 == (_DWORD)a3)
      break;
    result = 0;
LABEL_15:
    v4 = (int *)*((_QWORD *)v4 + 8);
    if ((_DWORD)result)
      v14 = 1;
    else
      v14 = v4 == 0;
    if (v14)
      return result;
  }
  xmlRngPErr(a1, *((_QWORD *)v4 + 1), 1099, "Detected a cycle in %s references\n", *((const xmlChar **)v4 + 2), 0);
  return 0xFFFFFFFFLL;
}

uint64_t xmlRelaxNGSimplify(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int v20;

  if (!a2)
    return result;
  v4 = a2;
  v5 = result;
  v6 = 0;
  while (1)
  {
    v7 = *(_DWORD *)v4;
    if (*(int *)v4 > 10)
    {
      if (v7 == 13 || v7 == 11)
      {
        if (*(__int16 *)(v4 + 96) != -3)
        {
          *(_WORD *)(v4 + 96) = -3;
          result = xmlRelaxNGSimplify(v5, *(_QWORD *)(v4 + 48), v4);
        }
        goto LABEL_64;
      }
    }
    else
    {
      if (!v7)
      {
        *(_QWORD *)(v4 + 56) = a3;
        if (a3)
        {
          if ((*(_DWORD *)a3 - 15) < 2)
            goto LABEL_73;
          if ((*(_DWORD *)a3 & 0xFFFFFFFE) == 0x12)
          {
LABEL_61:
            if (v6)
            {
              *(_QWORD *)(v6 + 64) = *(_QWORD *)(v4 + 64);
            }
            else if (*(_QWORD *)(a3 + 48) == v4)
            {
              v6 = 0;
              *(_QWORD *)(a3 + 48) = *(_QWORD *)(v4 + 64);
            }
            else if (*(_QWORD *)(a3 + 72) == v4)
            {
              v6 = 0;
              *(_QWORD *)(a3 + 72) = *(_QWORD *)(v4 + 64);
            }
            else
            {
              v6 = 0;
              if (*(_QWORD *)(a3 + 80) == v4)
                *(_QWORD *)(a3 + 80) = *(_QWORD *)(v4 + 64);
            }
            goto LABEL_64;
          }
        }
        goto LABEL_63;
      }
      if (v7 == 1)
      {
        *(_QWORD *)(v4 + 56) = a3;
LABEL_7:
        if (!a3)
          goto LABEL_63;
        v8 = *(_DWORD *)a3;
        if (*(_DWORD *)a3 > 0x13u)
          goto LABEL_63;
        if (v8 == 17)
          goto LABEL_61;
        v6 = v4;
        if (((1 << v8) & 0xD8300) != 0)
        {
          v20 = 1;
          goto LABEL_74;
        }
        goto LABEL_64;
      }
    }
    *(_QWORD *)(v4 + 56) = a3;
    v10 = *(_QWORD *)(v4 + 48);
    if (v10)
    {
      result = xmlRelaxNGSimplify(v5, v10, v4);
      v7 = *(_DWORD *)v4;
    }
    if (v7 != 7)
    {
      v11 = *(_QWORD *)(v4 + 72);
      if (v11)
        result = xmlRelaxNGSimplify(v5, v11, v4);
    }
    v12 = *(_QWORD *)(v4 + 80);
    if (v12)
      result = xmlRelaxNGSimplify(v5, v12, v4);
    if (*(_DWORD *)v4 == 4)
    {
      v13 = *(_QWORD *)(v4 + 48);
      if (v13)
      {
        while (1)
        {
          result = xmlRelaxNGGenerateAttributes(v5, v13);
          v14 = *(_QWORD *)(v4 + 48);
          if ((_DWORD)result != 1)
            break;
          v13 = *(_QWORD *)(v14 + 64);
          *(_QWORD *)(v4 + 48) = v13;
          *(_QWORD *)(v14 + 64) = *(_QWORD *)(v4 + 72);
          *(_QWORD *)(v4 + 72) = v14;
          if (!v13)
            goto LABEL_41;
        }
        if (v14)
        {
          while (1)
          {
            v15 = *(_QWORD *)(v14 + 64);
            if (!v15)
              break;
            result = xmlRelaxNGGenerateAttributes(v5, *(_QWORD *)(v14 + 64));
            if ((_DWORD)result == 1)
            {
              *(_QWORD *)(v14 + 64) = *(_QWORD *)(v15 + 64);
              *(_QWORD *)(v15 + 64) = *(_QWORD *)(v4 + 72);
              *(_QWORD *)(v4 + 72) = v15;
            }
            else
            {
              v14 = v15;
            }
          }
        }
      }
    }
LABEL_41:
    v16 = *(_DWORD *)v4;
    if ((*(_DWORD *)v4 & 0xFFFFFFFE) == 0x12)
      break;
LABEL_52:
    if (!v16)
      goto LABEL_58;
    if (v16 == 1)
      goto LABEL_7;
    if (v16 != 2)
      goto LABEL_63;
    v19 = *(_DWORD **)(v4 + 48);
    if (!v19 || *v19 != 1)
      goto LABEL_63;
    result = xmlRelaxNGTryUnlink(v4, (_QWORD *)a3, v6);
    v6 = result;
LABEL_64:
    v4 = *(_QWORD *)(v4 + 64);
    if (!v4)
      return result;
  }
  v17 = *(_QWORD *)(v4 + 48);
  if (v17)
  {
    if (!*(_QWORD *)(v17 + 64))
    {
      if (!(a3 | v6))
      {
        *(_DWORD *)v4 = -1;
        goto LABEL_63;
      }
      if (v6)
      {
        *(_QWORD *)(v17 + 64) = *(_QWORD *)(v4 + 64);
        v18 = v6;
        v4 = v17;
      }
      else
      {
        *(_QWORD *)(a3 + 48) = v17;
        v17 = *(_QWORD *)(v4 + 64);
        v18 = *(_QWORD *)(v4 + 48);
        v4 = v18;
      }
      *(_QWORD *)(v18 + 64) = v17;
    }
    v16 = *(_DWORD *)v4;
    goto LABEL_52;
  }
  *(_DWORD *)v4 = 0;
LABEL_58:
  if (!a3)
  {
LABEL_63:
    v6 = v4;
    goto LABEL_64;
  }
  if ((*(_DWORD *)a3 - 15) >= 2)
  {
    if ((*(_DWORD *)a3 - 17) <= 2)
      goto LABEL_61;
    goto LABEL_63;
  }
LABEL_73:
  v20 = 0;
LABEL_74:
  *(_DWORD *)a3 = v20;
  return result;
}

uint64_t xmlRelaxNGCheckRules(uint64_t a1, unsigned int *a2, uint64_t a3, int a4)
{
  unsigned int *v6;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  const xmlChar *v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t i;
  _QWORD *v27;
  _QWORD *v28;
  xmlHashTable *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  const char *v33;
  int v34;
  const char *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t *v41;
  xmlHashTable *v42;
  const char *v43;
  const xmlChar *v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t j;
  _QWORD **v51;
  unint64_t v52;
  void *v53;
  unsigned int v55;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  uint64_t v65;
  int v66;

  if (!a2)
    return 0;
  v6 = a2;
  v8 = 0;
  v9 = a3 | 8;
  v10 = (32 * (_DWORD)a3) & 0x40 | a3;
  v11 = (16 * (_DWORD)a3) & 0x20 | a3;
  v63 = a3 | 4;
  v64 = a3 | 2;
  v62 = a3 | 1;
  while (2)
  {
    v12 = *v6;
    switch((int)v12)
    {
      case 0:
        if ((a3 & 8) != 0)
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1071, "Found forbidden pattern data/except//empty\n", 0, 0);
        if ((a3 & 0x10) != 0)
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1090, "Found forbidden pattern start//empty\n", 0, 0);
        goto LABEL_171;
      case 2:
        v22 = (_DWORD *)*((_QWORD *)v6 + 7);
        v21 = a3;
        if (v22)
        {
          if (*v22 == 5)
            v21 = v9;
          else
            v21 = a3;
        }
        v19 = *((_QWORD *)v6 + 6);
        v20 = a1;
        v12 = 2;
        goto LABEL_167;
      case 3:
        if ((a3 & 4) != 0)
        {
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1083, "Found forbidden pattern list//text\n", 0, 0);
          if ((a3 & 8) == 0)
          {
LABEL_33:
            if ((a3 & 0x10) == 0)
              goto LABEL_80;
            goto LABEL_79;
          }
        }
        else if ((a3 & 8) == 0)
        {
          goto LABEL_33;
        }
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1077, "Found forbidden pattern data/except//text\n", 0, 0);
        if ((a3 & 0x10) == 0)
          goto LABEL_80;
LABEL_79:
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1095, "Found forbidden pattern start//text\n", 0, 0);
        goto LABEL_80;
      case 4:
        xmlRelaxNGCheckGroupAttrs(a1, (uint64_t)v6);
        if ((a3 & 8) != 0)
        {
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1070, "Found forbidden pattern data/except//element(ref)\n", 0, 0);
          if ((a3 & 4) == 0)
          {
LABEL_37:
            if ((a3 & 1) == 0)
              goto LABEL_39;
            goto LABEL_38;
          }
        }
        else if ((a3 & 4) == 0)
        {
          goto LABEL_37;
        }
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1079, "Found forbidden pattern list//element(ref)\n", 0, 0);
        if ((a3 & 1) == 0)
        {
LABEL_39:
          if (xmlRelaxNGCheckRules(a1, *((_QWORD *)v6 + 9), 0, *v6))
            xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1015, "Element %s attributes have a content type error\n", *((const xmlChar **)v6 + 2), 0);
          if (xmlRelaxNGCheckRules(a1, *((_QWORD *)v6 + 6), 0, *v6) == -1)
          {
            xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1016, "Element %s has a content type error\n", *((const xmlChar **)v6 + 2), 0);
            v18 = -1;
            goto LABEL_172;
          }
LABEL_80:
          v18 = 2;
          goto LABEL_172;
        }
LABEL_38:
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1068, "Found forbidden pattern attribute//element(ref)\n", 0, 0);
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1068, "Found forbidden pattern attribute//element(ref)\n", 0, 0);
        goto LABEL_39;
      case 5:
        if ((a3 & 0x10) == 0)
        {
          v23 = 5;
          goto LABEL_87;
        }
        v30 = *((_QWORD *)v6 + 1);
        v31 = a1;
        v32 = 1089;
        v33 = "Found forbidden pattern start//data\n";
        goto LABEL_86;
      case 7:
        if ((a3 & 0x10) != 0)
        {
          v30 = *((_QWORD *)v6 + 1);
          v31 = a1;
          v32 = 1096;
          v33 = "Found forbidden pattern start//value\n";
LABEL_86:
          xmlRngPErr(v31, v30, v32, v33, 0, 0);
          v23 = *v6;
        }
        else
        {
          v23 = 7;
        }
LABEL_87:
        xmlRelaxNGCheckRules(a1, *((_QWORD *)v6 + 6), a3, v23);
        v18 = 1;
        goto LABEL_172;
      case 8:
        if ((a3 & 4) != 0)
        {
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1081, "Found forbidden pattern list//list\n", 0, 0);
          if ((a3 & 8) == 0)
          {
LABEL_49:
            if ((a3 & 0x10) == 0)
              goto LABEL_51;
            goto LABEL_50;
          }
        }
        else if ((a3 & 8) == 0)
        {
          goto LABEL_49;
        }
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1074, "Found forbidden pattern data/except//list\n", 0, 0);
        if ((a3 & 0x10) == 0)
        {
LABEL_51:
          v19 = *((_QWORD *)v6 + 6);
          v12 = *v6;
          v20 = a1;
          v21 = v63;
          goto LABEL_167;
        }
LABEL_50:
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1093, "Found forbidden pattern start//list\n", 0, 0);
        goto LABEL_51;
      case 9:
        if ((a3 & 1) != 0)
        {
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1067, "Found forbidden pattern attribute//attribute\n", 0, 0);
          if ((a3 & 4) == 0)
          {
LABEL_54:
            if ((a3 & 0x20) == 0)
              goto LABEL_55;
            goto LABEL_93;
          }
        }
        else if ((a3 & 4) == 0)
        {
          goto LABEL_54;
        }
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1078, "Found forbidden pattern list//attribute\n", 0, 0);
        if ((a3 & 0x20) == 0)
        {
LABEL_55:
          if ((a3 & 0x40) == 0)
            goto LABEL_56;
          goto LABEL_94;
        }
LABEL_93:
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1086, "Found forbidden pattern oneOrMore//group//attribute\n", 0, 0);
        if ((a3 & 0x40) == 0)
        {
LABEL_56:
          if ((a3 & 8) == 0)
            goto LABEL_57;
          goto LABEL_95;
        }
LABEL_94:
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1087, "Found forbidden pattern oneOrMore//interleave//attribute\n", 0, 0);
        if ((a3 & 8) == 0)
        {
LABEL_57:
          if ((a3 & 0x10) == 0)
            goto LABEL_58;
          goto LABEL_96;
        }
LABEL_95:
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1069, "Found forbidden pattern data/except//attribute\n", 0, 0);
        if ((a3 & 0x10) == 0)
        {
LABEL_58:
          if ((a3 & 2) != 0)
            goto LABEL_170;
          goto LABEL_97;
        }
LABEL_96:
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1088, "Found forbidden pattern start//attribute\n", 0, 0);
        if ((a3 & 2) != 0)
          goto LABEL_170;
LABEL_97:
        if (!*((_QWORD *)v6 + 2) && !*((_QWORD *)v6 + 10))
        {
          if (*((_QWORD *)v6 + 3))
          {
            v34 = 1056;
            v35 = "Found nsName attribute without oneOrMore ancestor\n";
          }
          else
          {
            v34 = 1000;
            v35 = "Found anyName attribute without oneOrMore ancestor\n";
          }
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), v34, v35, 0, 0);
        }
LABEL_170:
        xmlRelaxNGCheckRules(a1, *((_QWORD *)v6 + 6), v62, *v6);
LABEL_171:
        v18 = 0;
        goto LABEL_172;
      case 11:
      case 13:
        if ((a3 & 8) != 0)
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1076, "Found forbidden pattern data/except//ref\n", 0, 0);
        if (!*((_QWORD *)v6 + 6))
        {
          if (*v6 == 13)
          {
            v13 = a1;
            v14 = "Internal found no define for parent refs\n";
            v15 = 0;
          }
          else
          {
            if (*((_QWORD *)v6 + 2))
              v15 = (const xmlChar *)*((_QWORD *)v6 + 2);
            else
              v15 = (const xmlChar *)"null";
            v13 = a1;
            v14 = "Internal found no define for ref %s\n";
          }
          xmlRngPErr(v13, *((_QWORD *)v6 + 1), 1101, v14, v15, 0);
        }
        v36 = *((__int16 *)v6 + 48);
        if (v36 < -3)
        {
          if (v36 == -4)
            v18 = 2;
          else
            v18 = v36 + 15;
        }
        else
        {
          *((_WORD *)v6 + 48) = -4;
          v18 = xmlRelaxNGCheckRules(a1, *((_QWORD *)v6 + 6), a3, *v6);
          *((_WORD *)v6 + 48) = v18 - 15;
        }
        goto LABEL_172;
      case 15:
      case 16:
        if ((a3 & 8) != 0)
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1075, "Found forbidden pattern data/except//oneOrMore\n", 0, 0);
        if ((a3 & 0x10) != 0)
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1094, "Found forbidden pattern start//oneOrMore\n", 0, 0);
        v16 = xmlRelaxNGCheckRules(a1, *((_QWORD *)v6 + 6), v64, *v6);
        if (v16 == 2)
          v17 = 2;
        else
          v17 = -1;
        if (!v16)
          v17 = 0;
        if (v16 == -1)
          v18 = -1;
        else
          v18 = v17;
        goto LABEL_172;
      case 17:
        if ((*((_WORD *)v6 + 49) & 0x20) != 0 || *(_DWORD *)(a1 + 68))
          goto LABEL_166;
        v60 = v10;
        v24 = xmlRelaxNGIsNullable((uint64_t)v6);
        v25 = *((_QWORD *)v6 + 6);
        v59 = v11;
        for (i = 0; v25; v25 = *(_QWORD *)(v25 + 64))
          ++i;
        v65 = 8 * i;
        v27 = xmlMalloc(8 * i);
        if (!v27)
        {
          xmlRngPErrMemory(a1, (const xmlChar *)"building choice\n");
          v11 = v11;
          v10 = v60;
          goto LABEL_166;
        }
        v28 = v27;
        v58 = v9;
        if (v24)
        {
          v29 = 0;
          v66 = 0;
        }
        else
        {
          v29 = xmlHashCreate(10);
          v66 = 1;
        }
        v37 = *((_QWORD *)v6 + 6);
        v61 = a1;
        if (!v37)
          goto LABEL_144;
        v38 = 0;
        do
        {
          v39 = xmlRelaxNGGetElements(a1, (_DWORD *)v37, 0);
          v28[v38] = v39;
          if (!v39 || (v40 = *v39) == 0)
          {
            v66 = 0;
            goto LABEL_143;
          }
          if (v66 != 1)
            goto LABEL_143;
          v41 = v39 + 1;
          do
          {
            if (*(_DWORD *)v40 != 4)
            {
              if (*(_DWORD *)v40 != 3)
              {
                v47 = -1;
                goto LABEL_142;
              }
              v42 = v29;
              v43 = "#text";
              goto LABEL_134;
            }
            v43 = *(const char **)(v40 + 16);
            v44 = *(const xmlChar **)(v40 + 24);
            if (v43)
            {
              if (!v44 || !*v44)
              {
                v42 = v29;
LABEL_134:
                v44 = 0;
                goto LABEL_135;
              }
              v42 = v29;
            }
            else
            {
              if (!v44 || !*v44)
              {
                v42 = v29;
                v43 = "#any";
                goto LABEL_134;
              }
              v42 = v29;
              v43 = "#any";
            }
LABEL_135:
            v45 = xmlHashAddEntry2(v42, (const xmlChar *)v43, v44, (void *)v37);
            if (v45)
              break;
            v46 = *v41++;
            v40 = v46;
          }
          while (v46);
          if (v45)
            v47 = -1;
          else
            v47 = 1;
LABEL_142:
          v66 = v47;
          a1 = v61;
LABEL_143:
          ++v38;
          v37 = *(_QWORD *)(v37 + 64);
        }
        while (v37);
LABEL_144:
        if (i)
        {
          v48 = 0;
          v49 = 0;
          do
          {
            if (v48 && v28[v48])
            {
              for (j = 0; j != v48; ++j)
              {
                v51 = (_QWORD **)v28[j];
                if (v51 && !xmlRelaxNGCompareElemDefLists(v28[v48], v51))
                  v49 = 1;
              }
            }
            ++v48;
          }
          while (v48 != i);
          v52 = 0;
          v9 = v58;
          do
          {
            v53 = (void *)v28[v52 / 8];
            if (v53)
              xmlFree(v53);
            v52 += 8;
          }
          while (v65 != v52);
          xmlFree(v28);
          if (v49)
            *((_WORD *)v6 + 49) |= 4u;
        }
        else
        {
          xmlFree(v28);
          v9 = v58;
        }
        v11 = v59;
        v10 = v60;
        if (v66 == 1)
        {
          *((_WORD *)v6 + 49) |= 0x10u;
          *((_QWORD *)v6 + 5) = v29;
          a1 = v61;
        }
        else
        {
          a1 = v61;
          if (v29)
            xmlHashFree(v29, 0);
        }
        *((_WORD *)v6 + 49) |= 0x20u;
LABEL_166:
        v19 = *((_QWORD *)v6 + 6);
        v12 = *v6;
        v20 = a1;
        v21 = a3;
LABEL_167:
        v18 = xmlRelaxNGCheckRules(v20, v19, v21, v12);
LABEL_172:
        v6 = (unsigned int *)*((_QWORD *)v6 + 8);
        if (a4 <= 16)
        {
          if (a4 == 2)
          {
            if (v18 == -1)
              v8 = 0xFFFFFFFFLL;
            else
              v8 = 1;
            if (!v6)
              return v8;
          }
          else
          {
            if (a4 != 8)
              goto LABEL_180;
            v8 = 1;
            if (!v6)
              return v8;
          }
          continue;
        }
        if (a4 == 17)
        {
          if (v18 == 2 || (_DWORD)v8 == 2)
            v55 = 2;
          else
            v55 = 0;
          if (v18 == 1)
            v55 = 1;
          if ((_DWORD)v8 == 1)
            v55 = 1;
LABEL_201:
          if (v18 == -1)
            v55 = -1;
          if ((_DWORD)v8 == -1)
            v8 = 0xFFFFFFFFLL;
          else
            v8 = v55;
        }
        else if (a4 != 19)
        {
LABEL_180:
          if (v18 == 2 && (_DWORD)v8 == 2)
            v55 = 2;
          else
            v55 = -1;
          if (!v18)
            v55 = v8;
          if (!(_DWORD)v8)
            v55 = v18;
          goto LABEL_201;
        }
        if (v6)
          continue;
        return v8;
      case 18:
        if ((a3 & 8) != 0)
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1072, "Found forbidden pattern data/except//group\n", 0, 0);
        if ((a3 & 0x10) != 0)
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1091, "Found forbidden pattern start//group\n", 0, 0);
        v18 = xmlRelaxNGCheckRules(a1, *((_QWORD *)v6 + 6), v11, *v6);
        xmlRelaxNGCheckGroupAttrs(a1, (uint64_t)v6);
        goto LABEL_172;
      case 19:
        if ((a3 & 4) != 0)
        {
          xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1080, "Found forbidden pattern list//interleave\n", 0, 0);
          if ((a3 & 8) == 0)
          {
LABEL_74:
            if ((a3 & 0x10) == 0)
              goto LABEL_76;
            goto LABEL_75;
          }
        }
        else if ((a3 & 8) == 0)
        {
          goto LABEL_74;
        }
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1073, "Found forbidden pattern data/except//interleave\n", 0, 0);
        if ((a3 & 0x10) == 0)
        {
LABEL_76:
          v19 = *((_QWORD *)v6 + 6);
          v12 = *v6;
          v20 = a1;
          v21 = v10;
          goto LABEL_167;
        }
LABEL_75:
        xmlRngPErr(a1, *((_QWORD *)v6 + 1), 1073, "Found forbidden pattern start//interleave\n", 0, 0);
        goto LABEL_76;
      default:
        v19 = *((_QWORD *)v6 + 6);
        v20 = a1;
        v21 = a3;
        goto LABEL_167;
    }
  }
}

uint64_t xmlRelaxNGParseGrammarContent(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  const xmlChar *v5;
  const xmlChar *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned __int8 *Prop;
  xmlChar *v13;
  _OWORD *v14;
  void *v15;
  uint64_t v16;
  const xmlChar *v17;
  const xmlChar *v18;
  uint64_t v19;
  uint64_t v20;
  xmlNodePtr RootElement;
  xmlNodePtr v22;
  int v23;
  const xmlChar *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  const char *v28;
  xmlHashTable *v29;
  _QWORD *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  const xmlChar *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  const char *v39;

  if (a2)
  {
    v3 = a2;
    v4 = 0;
    v5 = (const xmlChar *)"define";
    v6 = (const xmlChar *)"include";
    while (1)
    {
      if (!*(_QWORD *)(v3 + 72) || *(_DWORD *)(v3 + 8) != 1)
        goto LABEL_35;
      v7 = xmlStrEqual(*(const xmlChar **)(v3 + 16), (const xmlChar *)"start");
      v8 = *(_QWORD *)(v3 + 72);
      if (v7)
      {
        if (xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          v9 = *(_QWORD *)(v3 + 24);
          if (v9)
          {
            if (xmlRelaxNGParseStart(a1, v9))
              v4 = 0xFFFFFFFFLL;
            else
              v4 = v4;
          }
          else
          {
            xmlRngPErr(a1, v3, 1106, "start has no children\n", 0, 0);
          }
          goto LABEL_37;
        }
        v8 = *(_QWORD *)(v3 + 72);
      }
      if (!v8 || *(_DWORD *)(v3 + 8) != 1)
        goto LABEL_35;
      v10 = xmlStrEqual(*(const xmlChar **)(v3 + 16), v5);
      v11 = *(_QWORD *)(v3 + 72);
      if (!v10)
        goto LABEL_24;
      if (!xmlStrEqual(*(const xmlChar **)(v11 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        break;
      Prop = xmlGetProp((const xmlNode *)v3, (const xmlChar *)"name");
      if (Prop)
      {
        v13 = Prop;
        xmlRelaxNGNormExtSpace(Prop);
        if (xmlValidateNCName(v13, 0))
          xmlRngPErr(a1, v3, 1049, "define name '%s' is not an NCName\n", v13, 0);
        v14 = xmlRelaxNGNewDefine(a1, v3);
        if (!v14)
        {
          xmlFree(v13);
LABEL_52:
          v4 = 0xFFFFFFFFLL;
          goto LABEL_37;
        }
        v15 = v14;
        *(_DWORD *)v14 = 10;
        *((_QWORD *)v14 + 2) = v13;
        v16 = *(_QWORD *)(v3 + 24);
        if (v16)
        {
          v17 = v5;
          v18 = v6;
          v19 = *(_QWORD *)(a1 + 80);
          *(_QWORD *)(a1 + 80) = v13;
          *((_QWORD *)v14 + 6) = xmlRelaxNGParsePatterns(a1, v16, 0);
          *(_QWORD *)(a1 + 80) = v19;
          v6 = v18;
          v5 = v17;
        }
        else
        {
          xmlRngPErr(a1, v3, 1012, "define has no children\n", 0, 0);
        }
        v29 = *(xmlHashTable **)(*(_QWORD *)(a1 + 48) + 48);
        if (!v29)
        {
          v29 = xmlHashCreate(10);
          *(_QWORD *)(*(_QWORD *)(a1 + 48) + 48) = v29;
          if (!v29)
          {
            v32 = a1;
            v33 = v3;
            v34 = "Could not create definition hash\n";
            v35 = 0;
LABEL_51:
            xmlRngPErr(v32, v33, 1011, v34, v35, 0);
            goto LABEL_52;
          }
        }
        if (xmlHashAddEntry(v29, v13, v15) < 0)
        {
          v30 = xmlHashLookup(*(xmlHashTablePtr *)(*(_QWORD *)(a1 + 48) + 48), v13);
          if (v30)
          {
            do
            {
              v31 = v30;
              v30 = (_QWORD *)v30[11];
            }
            while (v30);
            v31[11] = v15;
            goto LABEL_37;
          }
          v32 = a1;
          v33 = v3;
          v34 = "Internal error on define aggregation of %s\n";
          v35 = v13;
          goto LABEL_51;
        }
      }
      else
      {
        xmlRngPErr(a1, v3, 1014, "define has no name\n", 0, 0);
      }
LABEL_37:
      v3 = *(_QWORD *)(v3 + 48);
      if (!v3)
        return v4;
    }
    v11 = *(_QWORD *)(v3 + 72);
LABEL_24:
    if (v11
      && *(_DWORD *)(v3 + 8) == 1
      && xmlStrEqual(*(const xmlChar **)(v3 + 16), v6)
      && xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v3 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      v20 = *(_QWORD *)(v3 + 104);
      if (v20)
      {
        RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v20 + 16));
        if (RootElement)
        {
          v22 = RootElement;
          if (xmlStrEqual(RootElement->name, (const xmlChar *)"grammar"))
          {
            if (v22->children)
            {
              if (xmlRelaxNGParseGrammarContent(a1))
                v23 = -1;
              else
                v23 = 0;
            }
            else
            {
              v23 = 0;
            }
            if (!*(_QWORD *)(v3 + 24) || !xmlRelaxNGParseGrammarContent(a1))
            {
              if (v23)
                v4 = 0xFFFFFFFFLL;
              else
                v4 = v4;
              goto LABEL_37;
            }
            goto LABEL_60;
          }
          v36 = a1;
          v37 = v3;
          v38 = 1038;
          v39 = "Include document root is not a grammar\n";
        }
        else
        {
          v36 = a1;
          v37 = v3;
          v38 = 1022;
          v39 = "Include document is empty\n";
        }
        xmlRngPErr(v36, v37, v38, v39, 0, 0);
LABEL_60:
        v4 = 0xFFFFFFFFLL;
        goto LABEL_37;
      }
      v25 = a1;
      v26 = v3;
      v27 = 1042;
      v28 = "Include node has no data\n";
      v24 = 0;
    }
    else
    {
LABEL_35:
      v24 = *(const xmlChar **)(v3 + 16);
      v25 = a1;
      v26 = v3;
      v27 = 1036;
      v28 = "grammar has unexpected child %s\n";
    }
    xmlRngPErr(v25, v26, v27, v28, v24, 0);
    v4 = 0xFFFFFFFFLL;
    goto LABEL_37;
  }
  xmlRngPErr(a1, 0, 1037, "grammar has no children\n", 0, 0);
  return 0xFFFFFFFFLL;
}

_OWORD *xmlRelaxNGCheckCombine(_OWORD *result, uint64_t a2, const xmlChar *a3)
{
  _OWORD *v5;
  int v6;
  int v7;
  const xmlNode **v8;
  xmlChar *Prop;
  xmlChar *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  const char *v14;
  const xmlChar *v15;
  xmlChar *v16;
  void *v17;
  _OWORD *v18;
  unsigned int v19;
  int v20;
  _QWORD *v21;
  _OWORD *v22;
  _QWORD *v23;
  xmlHashTablePtr v24;
  int v25;
  char __str[16];
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)result + 11))
    return result;
  v5 = result;
  v6 = 0;
  v7 = -1;
  v8 = (const xmlNode **)result;
  do
  {
    Prop = xmlGetProp(v8[1], (const xmlChar *)"combine");
    if (Prop)
    {
      v10 = Prop;
      if (xmlStrEqual(Prop, (const xmlChar *)"choice"))
      {
        if (v7)
        {
          v7 = 1;
LABEL_15:
          xmlFree(v10);
          goto LABEL_16;
        }
      }
      else
      {
        if (!xmlStrEqual(v10, (const xmlChar *)"interleave"))
        {
          v11 = *((_QWORD *)v5 + 1);
          v12 = a2;
          v13 = 1114;
          v14 = "Defines for %s use unknown combine value '%s''\n";
          v15 = a3;
          v16 = v10;
          goto LABEL_14;
        }
        if (v7 != 1)
        {
          v7 = 0;
          goto LABEL_15;
        }
      }
      v11 = *((_QWORD *)v5 + 1);
      v12 = a2;
      v13 = 1010;
      v14 = "Defines for %s use both 'choice' and 'interleave'\n";
      v15 = a3;
      v16 = 0;
LABEL_14:
      xmlRngPErr(v12, v11, v13, v14, v15, v16);
      goto LABEL_15;
    }
    if (v6)
      xmlRngPErr(a2, *((_QWORD *)v5 + 1), 1054, "Some defines for %s needs the combine attribute\n", a3, 0);
    v6 = 1;
LABEL_16:
    v8 = (const xmlNode **)v8[11];
  }
  while (v8);
  result = xmlRelaxNGNewDefine(a2, *((_QWORD *)v5 + 1));
  if (result)
  {
    v17 = result;
    v18 = 0;
    v19 = v7 + 1;
    if ((v7 + 1) >= 2)
      v20 = 17;
    else
      v20 = 19;
    *(_DWORD *)result = v20;
    v21 = result + 3;
    v22 = v5;
    do
    {
      result = (_OWORD *)*((_QWORD *)v22 + 6);
      if (result)
      {
        if (*((_QWORD *)result + 8))
        {
          result = xmlRelaxNGNewDefine(a2, *((_QWORD *)result + 1));
          if (!result)
            break;
          *(_DWORD *)result = 18;
          *((_QWORD *)result + 6) = *((_QWORD *)v22 + 6);
        }
        v23 = v18 + 4;
        if (!v18)
          v23 = v21;
        *v23 = result;
        v18 = result;
      }
      *((_QWORD *)v22 + 6) = v17;
      v22 = (_OWORD *)*((_QWORD *)v22 + 11);
    }
    while (v22);
    *((_QWORD *)v5 + 6) = v17;
    if (v19 <= 1)
    {
      if (*(_QWORD *)(a2 + 104) || (v24 = xmlHashCreate(10), (*(_QWORD *)(a2 + 104) = v24) != 0))
      {
        *(_OWORD *)__str = 0u;
        v27 = 0u;
        v25 = *(_DWORD *)(a2 + 96);
        *(_DWORD *)(a2 + 96) = v25 + 1;
        snprintf(__str, 0x20uLL, "interleave%d", v25);
        result = (_OWORD *)xmlHashAddEntry(*(xmlHashTablePtr *)(a2 + 104), (const xmlChar *)__str, v17);
        if ((result & 0x80000000) != 0)
          return xmlRngPErr(a2, *((_QWORD *)v5 + 1), 1046, "Failed to add %s to hash table\n", (const xmlChar *)__str, 0);
      }
      else
      {
        return xmlRngPErr(a2, *((_QWORD *)v5 + 1), 1046, "Failed to create interleaves hash table\n", 0, 0);
      }
    }
  }
  return result;
}

_DWORD *xmlRelaxNGCheckReference(_DWORD *result, uint64_t a2, const xmlChar *a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  int v10;
  xmlHashTable *v11;

  if ((*((_WORD *)result + 49) & 0x100) == 0)
  {
    v5 = result;
    v6 = *(_QWORD *)(a2 + 48);
    if (!v6)
    {
      v7 = *((_QWORD *)result + 1);
      v8 = "Internal error: no grammar in CheckReference %s\n";
      goto LABEL_6;
    }
    if (*((_QWORD *)result + 6))
    {
      v7 = *((_QWORD *)result + 1);
      v8 = "Internal error: reference has content in CheckReference %s\n";
LABEL_6:
      v9 = a2;
      v10 = 1;
      return xmlRngPErr(v9, v7, v10, v8, a3, 0);
    }
    v11 = *(xmlHashTable **)(v6 + 48);
    if (!v11 || (result = xmlHashLookup(v11, a3)) == 0)
    {
      v7 = v5[1];
      v8 = "Reference %s has no matching definition\n";
      v9 = a2;
      v10 = 1101;
      return xmlRngPErr(v9, v7, v10, v8, a3, 0);
    }
    do
    {
      v5[6] = result;
      v5 = (_QWORD *)v5[11];
    }
    while (v5);
  }
  return result;
}

uint64_t *xmlRelaxNGParsePatterns(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;

  if (!a2)
    return 0;
  v4 = a2;
  v6 = 0;
  v7 = 0;
  v8 = *(_QWORD *)(a1 + 88);
  do
  {
    if (*(_QWORD *)(v4 + 72)
      && *(_DWORD *)(v4 + 8) == 1
      && xmlStrEqual(*(const xmlChar **)(v4 + 16), (const xmlChar *)"element")
      && xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v4 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      v9 = (uint64_t *)xmlRelaxNGParseElement(a1, v4);
      if (!v9)
        return 0;
      v10 = v9;
      if (v7)
      {
        if (a3 == 1 && *(_DWORD *)v7 == 4 && v7 == v6)
        {
          v11 = (uint64_t *)xmlRelaxNGNewDefine(a1, v4);
          v7 = v11;
          if (!v11)
            return v7;
          *(_DWORD *)v11 = 18;
          v11[6] = (uint64_t)v6;
        }
        v6[8] = (uint64_t)v10;
        v9 = v7;
      }
      v10[7] = v8;
      v7 = v9;
    }
    else
    {
      v12 = xmlRelaxNGParsePattern(a1, v4);
      if (v12)
      {
        v10 = v12;
        if (v7)
          v6[8] = (uint64_t)v12;
        else
          v7 = v12;
      }
      else
      {
        v10 = v6;
      }
    }
    v4 = *(_QWORD *)(v4 + 48);
    v6 = v10;
  }
  while (v4);
  return v7;
}

_OWORD *xmlRelaxNGParseElement(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  _OWORD *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;

  v4 = xmlRelaxNGNewDefine(a1, a2);
  v5 = v4;
  if (!v4)
    return v5;
  *(_DWORD *)v4 = 4;
  *((_QWORD *)v4 + 7) = *(_QWORD *)(a1 + 88);
  v6 = *(_QWORD *)(a2 + 24);
  if (!v6)
  {
    v17 = "xmlRelaxNGParseElement: element has no children\n";
    v18 = a1;
    v19 = a2;
    v20 = 1017;
LABEL_27:
    xmlRngPErr(v18, v19, v20, v17, 0, 0);
    return v5;
  }
  if (xmlRelaxNGParseNameClass(a1, *(_QWORD *)(a2 + 24), (uint64_t)v4))
  {
    v6 = *(_QWORD *)(v6 + 48);
    if (!v6)
    {
      v17 = "xmlRelaxNGParseElement: element has no content\n";
      v18 = a1;
      v19 = a2;
      v20 = 1020;
      goto LABEL_27;
    }
  }
  v7 = 0;
  v8 = *(_QWORD *)(a1 + 80);
  v9 = (uint64_t **)(v5 + 3);
  *(_QWORD *)(a1 + 80) = 0;
  do
  {
    v10 = xmlRelaxNGParsePattern(a1, v6);
    if (v10)
    {
      v11 = v10;
      v10[7] = (uint64_t)v5;
      switch(*(_DWORD *)v10)
      {
        case 0xFFFFFFFF:
          v14 = a1;
          v15 = a2;
          v16 = "RNG Internal error, noop found in element\n";
          goto LABEL_21;
        case 0:
        case 1:
        case 3:
        case 4:
        case 5:
        case 7:
        case 8:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0xE:
        case 0xF:
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
          if (v7)
          {
            if (*(_DWORD *)v7 == 4 && *v9 == v7)
            {
              v12 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
              *v9 = v12;
              v13 = (uint64_t **)(v5 + 3);
              if (v12)
              {
                *(_DWORD *)v12 = 18;
                v13 = (uint64_t **)(v12 + 6);
              }
              *v13 = v7;
            }
            v7[8] = (uint64_t)v11;
          }
          else
          {
            *v9 = v10;
          }
          goto LABEL_23;
        case 2:
          v14 = a1;
          v15 = a2;
          v16 = "RNG Internal error, except found in element\n";
          goto LABEL_21;
        case 6:
          v14 = a1;
          v15 = a2;
          v16 = "RNG Internal error, param found in element\n";
          goto LABEL_21;
        case 9:
          v10[8] = *((_QWORD *)v5 + 9);
          *((_QWORD *)v5 + 9) = v10;
          break;
        case 0x14:
          v14 = a1;
          v15 = a2;
          v16 = "RNG Internal error, start found in element\n";
LABEL_21:
          xmlRngPErr(v14, v15, 1018, v16, 0, 0);
          break;
        default:
          break;
      }
    }
    v11 = v7;
LABEL_23:
    v6 = *(_QWORD *)(v6 + 48);
    v7 = v11;
  }
  while (v6);
  *(_QWORD *)(a1 + 80) = v8;
  return v5;
}

uint64_t *xmlRelaxNGParsePattern(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  int v7;
  uint64_t v8;
  _OWORD *v9;
  _OWORD *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  _OWORD *v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  const xmlChar *name;
  xmlChar *v24;
  int v25;
  uint64_t v26;
  _OWORD *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  _OWORD *v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  _OWORD *v48;
  unsigned __int8 *Prop;
  const xmlChar *v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  uint64_t v56;
  unsigned __int8 *v57;
  xmlChar *v58;
  xmlChar *v59;
  _OWORD *v60;
  _QWORD *v61;
  unsigned int (*v62)(_QWORD, _QWORD);
  xmlHashTable *v63;
  _QWORD *v64;
  int v65;
  uint64_t v66;
  _OWORD *v67;
  unsigned __int8 *v68;
  unsigned __int8 *v69;
  xmlChar *v70;
  unsigned __int8 *v71;
  uint64_t (*v72)(_QWORD, _QWORD);
  int v73;
  const char *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  const xmlChar *v78;
  int v79;
  uint64_t v80;
  const char *v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  const xmlChar *v85;
  xmlChar *v86;
  const xmlNode *v87;
  _OWORD *v88;
  _OWORD *v89;
  _OWORD *v90;
  xmlChar *v91;
  _QWORD *v92;
  int v93;
  uint64_t v94;
  _OWORD *v95;
  _xmlNode *children;
  uint64_t v97;
  uint64_t *v98;
  uint64_t v99;
  uint64_t *v100;
  uint64_t v101;
  xmlChar *Content;
  unsigned int (*v103)(_QWORD, _QWORD, xmlChar *, uint64_t *, uint64_t);
  int v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  _OWORD *v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  _OWORD *v115;
  unsigned __int8 *v116;
  const xmlChar *v117;
  const char *v118;
  uint64_t v119;
  uint64_t v120;
  int v121;
  uint64_t *v122;
  uint64_t v123;
  _OWORD *v124;
  xmlHashTable *v125;
  const xmlChar *v126;
  __int128 v127;
  uint64_t v128;

  if (!*(_QWORD *)(a2 + 72) || *(_DWORD *)(a2 + 8) != 1)
    goto LABEL_257;
  v4 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"element");
  v5 = *(_QWORD *)(a2 + 72);
  if (v4)
  {
    if (xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
      return (uint64_t *)xmlRelaxNGParseElement(a1, a2);
    v5 = *(_QWORD *)(a2 + 72);
  }
  if (!v5 || *(_DWORD *)(a2 + 8) != 1)
    goto LABEL_257;
  v7 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"attribute");
  v8 = *(_QWORD *)(a2 + 72);
  if (!v7)
  {
LABEL_23:
    if (v8 && *(_DWORD *)(a2 + 8) == 1)
    {
      v16 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"empty");
      v17 = *(_QWORD *)(a2 + 72);
      if (v16)
      {
        if (xmlStrEqual(*(const xmlChar **)(v17 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          v18 = xmlRelaxNGNewDefine(a1, a2);
          v10 = v18;
          if (!v18)
            return (uint64_t *)v10;
          *(_DWORD *)v18 = 0;
          if (!*(_QWORD *)(a2 + 24))
            return (uint64_t *)v10;
          v19 = "empty: had a child node\n";
          v20 = a1;
          v21 = a2;
          v22 = 1025;
          goto LABEL_31;
        }
        v17 = *(_QWORD *)(a2 + 72);
      }
      if (v17 && *(_DWORD *)(a2 + 8) == 1)
      {
        v25 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"text");
        v26 = *(_QWORD *)(a2 + 72);
        if (v25)
        {
          if (xmlStrEqual(*(const xmlChar **)(v26 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            v27 = xmlRelaxNGNewDefine(a1, a2);
            v10 = v27;
            if (!v27)
              return (uint64_t *)v10;
            *(_DWORD *)v27 = 3;
            if (!*(_QWORD *)(a2 + 24))
              return (uint64_t *)v10;
            v19 = "text: had a child node\n";
            v20 = a1;
            v21 = a2;
            v22 = 1109;
            goto LABEL_31;
          }
          v26 = *(_QWORD *)(a2 + 72);
        }
        if (v26 && *(_DWORD *)(a2 + 8) == 1)
        {
          v32 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"zeroOrMore");
          v33 = *(_QWORD *)(a2 + 72);
          if (v32)
          {
            if (xmlStrEqual(*(const xmlChar **)(v33 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
            {
              v10 = xmlRelaxNGNewDefine(a1, a2);
              if (!v10)
                return (uint64_t *)v10;
              v34 = 15;
LABEL_51:
              *(_DWORD *)v10 = v34;
              if (*(_QWORD *)(a2 + 24))
              {
                v35 = a1;
LABEL_53:
                v36 = (_OWORD *)xmlRelaxNGParsePatterns(v35);
LABEL_54:
                *((_QWORD *)v10 + 6) = v36;
                return (uint64_t *)v10;
              }
              goto LABEL_80;
            }
            v33 = *(_QWORD *)(a2 + 72);
          }
          if (v33 && *(_DWORD *)(a2 + 8) == 1)
          {
            v37 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"oneOrMore");
            v38 = *(_QWORD *)(a2 + 72);
            if (v37)
            {
              if (xmlStrEqual(*(const xmlChar **)(v38 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
              {
                v10 = xmlRelaxNGNewDefine(a1, a2);
                if (!v10)
                  return (uint64_t *)v10;
                v34 = 16;
                goto LABEL_51;
              }
              v38 = *(_QWORD *)(a2 + 72);
            }
            if (v38 && *(_DWORD *)(a2 + 8) == 1)
            {
              v39 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"optional");
              v40 = *(_QWORD *)(a2 + 72);
              if (v39)
              {
                if (xmlStrEqual(*(const xmlChar **)(v40 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                {
                  v10 = xmlRelaxNGNewDefine(a1, a2);
                  if (!v10)
                    return (uint64_t *)v10;
                  v34 = 14;
                  goto LABEL_51;
                }
                v40 = *(_QWORD *)(a2 + 72);
              }
              if (v40 && *(_DWORD *)(a2 + 8) == 1)
              {
                v41 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"choice");
                v42 = *(_QWORD *)(a2 + 72);
                if (v41)
                {
                  if (xmlStrEqual(*(const xmlChar **)(v42 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                  {
                    v10 = xmlRelaxNGNewDefine(a1, a2);
                    if (!v10)
                      return (uint64_t *)v10;
                    v43 = 17;
LABEL_78:
                    *(_DWORD *)v10 = v43;
                    if (*(_QWORD *)(a2 + 24))
                    {
                      v35 = a1;
                      goto LABEL_53;
                    }
LABEL_80:
                    name = *(const xmlChar **)(a2 + 16);
                    v19 = "Element %s is empty\n";
                    v20 = a1;
                    v21 = a2;
                    v22 = 1023;
                    goto LABEL_32;
                  }
                  v42 = *(_QWORD *)(a2 + 72);
                }
                if (v42 && *(_DWORD *)(a2 + 8) == 1)
                {
                  v44 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"group");
                  v45 = *(_QWORD *)(a2 + 72);
                  if (v44)
                  {
                    if (xmlStrEqual(*(const xmlChar **)(v45 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                    {
                      v10 = xmlRelaxNGNewDefine(a1, a2);
                      if (!v10)
                        return (uint64_t *)v10;
                      v43 = 18;
                      goto LABEL_78;
                    }
                    v45 = *(_QWORD *)(a2 + 72);
                  }
                  if (v45 && *(_DWORD *)(a2 + 8) == 1)
                  {
                    v46 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"ref");
                    v47 = *(_QWORD *)(a2 + 72);
                    if (v46)
                    {
                      if (xmlStrEqual(*(const xmlChar **)(v47 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                      {
                        v48 = xmlRelaxNGNewDefine(a1, a2);
                        v10 = v48;
                        if (!v48)
                          return (uint64_t *)v10;
                        *(_DWORD *)v48 = 11;
                        Prop = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"name");
                        *((_QWORD *)v10 + 2) = Prop;
                        if (Prop)
                        {
                          xmlRelaxNGNormExtSpace(Prop);
                          if (!xmlValidateNCName(*((const xmlChar **)v10 + 2), 0))
                          {
LABEL_117:
                            if (*(_QWORD *)(a2 + 24))
                              xmlRngPErr(a1, a2, 1103, "ref is not empty\n", 0, 0);
                            v63 = *(xmlHashTable **)(*(_QWORD *)(a1 + 48) + 56);
                            if (v63
                              || (v63 = xmlHashCreate(10), (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 56) = v63) != 0))
                            {
                              if ((xmlHashAddEntry(v63, *((const xmlChar **)v10 + 2), v10) & 0x80000000) == 0)
                                return (uint64_t *)v10;
                              v64 = xmlHashLookup(*(xmlHashTablePtr *)(*(_QWORD *)(a1 + 48) + 56), *((const xmlChar **)v10 + 2));
                              if (v64)
                              {
LABEL_123:
                                *((_QWORD *)v10 + 11) = v64[11];
                                v64[11] = v10;
                                return (uint64_t *)v10;
                              }
                              v78 = (const xmlChar *)*((_QWORD *)v10 + 2);
                              if (v78)
                                v74 = "Error refs definitions '%s'\n";
                              else
                                v74 = "Error refs definitions\n";
                              v75 = a1;
                              v76 = a2;
                              v77 = 1098;
                              goto LABEL_258;
                            }
                            v74 = "Could not create references hash\n";
                            v75 = a1;
                            v76 = a2;
                            v77 = 1098;
                            goto LABEL_143;
                          }
                          v50 = (const xmlChar *)*((_QWORD *)v10 + 2);
                          v51 = "ref name '%s' is not an NCName\n";
                          v52 = a1;
                          v53 = a2;
                          v54 = 1100;
                        }
                        else
                        {
                          v51 = "ref has no name\n";
                          v52 = a1;
                          v53 = a2;
                          v54 = 1102;
                          v50 = 0;
                        }
                        xmlRngPErr(v52, v53, v54, v51, v50, 0);
                        goto LABEL_117;
                      }
                      v47 = *(_QWORD *)(a2 + 72);
                    }
                    if (v47 && *(_DWORD *)(a2 + 8) == 1)
                    {
                      v55 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"data");
                      v56 = *(_QWORD *)(a2 + 72);
                      if (v55)
                      {
                        if (xmlStrEqual(*(const xmlChar **)(v56 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                        {
                          v57 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"type");
                          if (v57)
                          {
                            v58 = v57;
                            xmlRelaxNGNormExtSpace(v57);
                            if (xmlValidateNCName(v58, 0))
                              xmlRngPErr(a1, a2, 1112, "data type '%s' is not an NCName\n", v58, 0);
                            v59 = xmlRelaxNGGetDataTypeLibrary(a2);
                            if (!v59)
                              v59 = xmlStrdup((const xmlChar *)"http://relaxng.org/ns/structure/1.0");
                            v60 = xmlRelaxNGNewDefine(a1, a2);
                            v10 = v60;
                            if (!v60)
                            {
                              xmlFree(v59);
                              xmlFree(v58);
                              return (uint64_t *)v10;
                            }
                            *(_DWORD *)v60 = 5;
                            *((_QWORD *)v60 + 2) = v58;
                            *((_QWORD *)v60 + 3) = v59;
                            v61 = xmlHashLookup((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, v59);
                            if (!v61)
                            {
                              xmlRngPErr(a1, a2, 1116, "Use of unregistered type library '%s'\n", v59, 0);
                              *((_QWORD *)v10 + 5) = 0;
                              goto LABEL_158;
                            }
                            *((_QWORD *)v10 + 5) = v61;
                            v62 = (unsigned int (*)(_QWORD, _QWORD))v61[2];
                            if (v62)
                            {
                              if (v62(v61[1], *((_QWORD *)v10 + 2)) == 1)
                              {
                                if (xmlStrEqual(v59, (const xmlChar *)"http://www.w3.org/2001/XMLSchema-datatypes")
                                  && (xmlStrEqual(*((const xmlChar **)v10 + 2), (const xmlChar *)"IDREF")
                                   || xmlStrEqual(*((const xmlChar **)v10 + 2), (const xmlChar *)"IDREFS")))
                                {
                                  *(_DWORD *)(a1 + 224) = 1;
                                }
LABEL_158:
                                v87 = *(const xmlNode **)(a2 + 24);
                                if (v87)
                                {
                                  v88 = 0;
                                  while (xmlStrEqual(v87->name, (const xmlChar *)"param"))
                                  {
                                    if (xmlStrEqual(v59, (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                    {
                                      xmlRngPErr(a1, a2, 1058, "Type library '%s' does not allow type parameters\n", v59, 0);
                                      while (1)
                                      {
                                        v87 = v87->next;
                                        if (!v87)
                                          return (uint64_t *)v10;
                                        if (!xmlStrEqual(v87->name, (const xmlChar *)"param"))
                                          goto LABEL_173;
                                      }
                                    }
                                    v89 = xmlRelaxNGNewDefine(a1, a2);
                                    if (v89)
                                    {
                                      v90 = v89;
                                      *(_DWORD *)v89 = 6;
                                      v91 = xmlGetProp(v87, (const xmlChar *)"name");
                                      *((_QWORD *)v90 + 2) = v91;
                                      if (!v91)
                                        xmlRngPErr(a1, a2, 1059, "param has no name\n", 0, 0);
                                      *((_QWORD *)v90 + 4) = xmlNodeGetContent(v87);
                                      v92 = v88 + 4;
                                      if (!v88)
                                        v92 = (_QWORD *)v10 + 9;
                                      *v92 = v90;
                                      v88 = v90;
                                    }
                                    v87 = v87->next;
LABEL_173:
                                    if (!v87)
                                      return (uint64_t *)v10;
                                  }
                                  if (!xmlStrEqual(v87->name, (const xmlChar *)"except"))
                                    goto LABEL_215;
                                  v95 = xmlRelaxNGNewDefine(a1, a2);
                                  if (v95)
                                  {
                                    *(_DWORD *)v95 = 2;
                                    children = v87->children;
                                    *((_QWORD *)v10 + 6) = v95;
                                    if (children)
                                    {
                                      v97 = 0;
                                      v98 = (uint64_t *)(v95 + 3);
                                      do
                                      {
                                        v99 = xmlRelaxNGParsePattern(a1, children);
                                        if (v99)
                                        {
                                          v100 = (uint64_t *)(v97 + 64);
                                          if (!v97)
                                            v100 = v98;
                                          *v100 = v99;
                                          v97 = v99;
                                        }
                                        children = children->next;
                                      }
                                      while (children);
                                    }
                                    else
                                    {
                                      xmlRngPErr(a1, (uint64_t)v87, 1030, "except has no content\n", 0, 0);
                                    }
                                    v87 = v87->next;
                                    if (v87)
                                    {
LABEL_215:
                                      name = v87->name;
                                      v19 = "Element data has unexpected content %s\n";
                                      v20 = a1;
                                      v21 = (uint64_t)v87;
                                      v22 = 1009;
                                      goto LABEL_32;
                                    }
                                  }
                                }
                                return (uint64_t *)v10;
                              }
                              v85 = (const xmlChar *)*((_QWORD *)v10 + 2);
                              v81 = "Error type '%s' is not exported by type library '%s'\n";
                              v82 = a1;
                              v83 = a2;
                              v84 = 1111;
                              v86 = v59;
                            }
                            else
                            {
                              v81 = "Internal error with type library '%s': no 'have'\n";
                              v82 = a1;
                              v83 = a2;
                              v84 = 1026;
                              v85 = v59;
                              v86 = 0;
                            }
                            xmlRngPErr(v82, v83, v84, v81, v85, v86);
                            goto LABEL_158;
                          }
                          v74 = "data has no type\n";
                          v75 = a1;
                          v76 = a2;
                          v77 = 1110;
LABEL_143:
                          v78 = 0;
LABEL_258:
                          xmlRngPErr(v75, v76, v77, v74, v78, 0);
                          return 0;
                        }
                        v56 = *(_QWORD *)(a2 + 72);
                      }
                      if (v56 && *(_DWORD *)(a2 + 8) == 1)
                      {
                        v65 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"value");
                        v66 = *(_QWORD *)(a2 + 72);
                        if (v65)
                        {
                          if (xmlStrEqual(*(const xmlChar **)(v66 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                          {
                            v67 = xmlRelaxNGNewDefine(a1, a2);
                            v10 = v67;
                            if (!v67)
                              return (uint64_t *)v10;
                            *(_DWORD *)v67 = 7;
                            v68 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"type");
                            v69 = v68;
                            if (v68)
                            {
                              xmlRelaxNGNormExtSpace(v68);
                              if (xmlValidateNCName(v69, 0))
                                xmlRngPErr(a1, a2, 1112, "value type '%s' is not an NCName\n", v69, 0);
                              v70 = xmlRelaxNGGetDataTypeLibrary(a2);
                              if (!v70)
                                v70 = xmlStrdup((const xmlChar *)"http://relaxng.org/ns/structure/1.0");
                              *((_QWORD *)v10 + 2) = v69;
                              *((_QWORD *)v10 + 3) = v70;
                              v71 = (unsigned __int8 *)xmlHashLookup((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, v70);
                              v69 = v71;
                              if (!v71)
                              {
                                xmlRngPErr(a1, a2, 1116, "Use of unregistered type library '%s'\n", v70, 0);
                                v73 = 0;
                                *((_QWORD *)v10 + 5) = 0;
                                goto LABEL_194;
                              }
                              *((_QWORD *)v10 + 5) = v71;
                              v72 = (uint64_t (*)(_QWORD, _QWORD))*((_QWORD *)v71 + 2);
                              if (v72)
                              {
                                v73 = v72(*((_QWORD *)v71 + 1), *((_QWORD *)v10 + 2));
                                if (v73 != 1)
                                  xmlRngPErr(a1, a2, 1111, "Error type '%s' is not exported by type library '%s'\n", *((const xmlChar **)v10 + 2), v70);
LABEL_194:
                                v101 = *(_QWORD *)(a2 + 24);
                                if (!v101)
                                {
                                  *((_QWORD *)v10 + 4) = xmlStrdup((const xmlChar *)&byte_1B0865C1A);
                                  return (uint64_t *)v10;
                                }
                                if ((*(_DWORD *)(v101 + 8) - 3) > 1 || *(_QWORD *)(v101 + 48))
                                {
                                  v19 = "Expecting a single text value for <value>content\n";
                                  v20 = a1;
                                  v21 = a2;
                                  v22 = 1108;
                                }
                                else
                                {
                                  Content = xmlNodeGetContent((const xmlNode *)a2);
                                  *((_QWORD *)v10 + 4) = Content;
                                  if (Content)
                                  {
                                    if (!v69)
                                      return (uint64_t *)v10;
                                    if (v73 != 1)
                                      return (uint64_t *)v10;
                                    v103 = (unsigned int (*)(_QWORD, _QWORD, xmlChar *, uint64_t *, uint64_t))*((_QWORD *)v69 + 3);
                                    if (!v103)
                                      return (uint64_t *)v10;
                                    v128 = 0;
                                    if (v103(*((_QWORD *)v69 + 1), *((_QWORD *)v10 + 2), Content, &v128, a2) == 1)
                                    {
                                      if (v128)
                                        *((_QWORD *)v10 + 9) = v128;
                                      return (uint64_t *)v10;
                                    }
                                    name = (const xmlChar *)*((_QWORD *)v10 + 4);
                                    v24 = (xmlChar *)*((_QWORD *)v10 + 2);
                                    v19 = "Value '%s' is not acceptable for type '%s'\n";
                                    v20 = a1;
                                    v21 = a2;
                                    v22 = 1051;
                                    goto LABEL_33;
                                  }
                                  v19 = "Element <value> has no content\n";
                                  v20 = a1;
                                  v21 = a2;
                                  v22 = 1120;
                                }
                                goto LABEL_31;
                              }
                              xmlRngPErr(a1, a2, 1026, "Internal error with type library '%s': no 'have'\n", v70, 0);
                            }
                            v73 = 0;
                            goto LABEL_194;
                          }
                          v66 = *(_QWORD *)(a2 + 72);
                        }
                        if (v66 && *(_DWORD *)(a2 + 8) == 1)
                        {
                          v79 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"list");
                          v80 = *(_QWORD *)(a2 + 72);
                          if (v79)
                          {
                            if (xmlStrEqual(*(const xmlChar **)(v80 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                            {
                              v10 = xmlRelaxNGNewDefine(a1, a2);
                              if (!v10)
                                return (uint64_t *)v10;
                              v43 = 8;
                              goto LABEL_78;
                            }
                            v80 = *(_QWORD *)(a2 + 72);
                          }
                          if (v80 && *(_DWORD *)(a2 + 8) == 1)
                          {
                            v93 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"interleave");
                            v94 = *(_QWORD *)(a2 + 72);
                            if (v93)
                            {
                              if (xmlStrEqual(*(const xmlChar **)(v94 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                              {
                                return xmlRelaxNGParseInterleave(a1, a2);
                              }
                              v94 = *(_QWORD *)(a2 + 72);
                            }
                            if (v94 && *(_DWORD *)(a2 + 8) == 1)
                            {
                              v104 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"externalRef");
                              v105 = *(_QWORD *)(a2 + 72);
                              if (v104)
                              {
                                if (xmlStrEqual(*(const xmlChar **)(v105 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                {
                                  return (uint64_t *)xmlRelaxNGProcessExternalRef(a1, a2);
                                }
                                v105 = *(_QWORD *)(a2 + 72);
                              }
                              if (v105 && *(_DWORD *)(a2 + 8) == 1)
                              {
                                v106 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"notAllowed");
                                v107 = *(_QWORD *)(a2 + 72);
                                if (v106)
                                {
                                  if (xmlStrEqual(*(const xmlChar **)(v107 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                  {
                                    v108 = xmlRelaxNGNewDefine(a1, a2);
                                    v10 = v108;
                                    if (!v108)
                                      return (uint64_t *)v10;
                                    *(_DWORD *)v108 = 1;
                                    if (!*(_QWORD *)(a2 + 24))
                                      return (uint64_t *)v10;
                                    v19 = "xmlRelaxNGParse: notAllowed element is not empty\n";
                                    v20 = a1;
                                    v21 = a2;
                                    v22 = 1055;
                                    goto LABEL_31;
                                  }
                                  v107 = *(_QWORD *)(a2 + 72);
                                }
                                if (v107 && *(_DWORD *)(a2 + 8) == 1)
                                {
                                  v109 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"grammar");
                                  v110 = *(_QWORD *)(a2 + 72);
                                  if (v109)
                                  {
                                    if (xmlStrEqual(*(const xmlChar **)(v110 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                    {
                                      v111 = *(_QWORD *)(a1 + 48);
                                      v127 = *(_OWORD *)(a1 + 48);
                                      *(_QWORD *)(a1 + 56) = v127;
                                      v112 = xmlRelaxNGParseGrammar(a1, *(_QWORD *)(a2 + 24));
                                      if (v111)
                                        *(_OWORD *)(a1 + 48) = v127;
                                      if (v112)
                                        return *(uint64_t **)(v112 + 24);
                                      return 0;
                                    }
                                    v110 = *(_QWORD *)(a2 + 72);
                                  }
                                  if (v110 && *(_DWORD *)(a2 + 8) == 1)
                                  {
                                    v113 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"parentRef");
                                    v114 = *(_QWORD *)(a2 + 72);
                                    if (v113)
                                    {
                                      if (xmlStrEqual(*(const xmlChar **)(v114 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                      {
                                        if (!*(_QWORD *)(a1 + 56))
                                        {
                                          v74 = "Use of parentRef without a parent grammar\n";
                                          v75 = a1;
                                          v76 = a2;
                                          v77 = 1063;
                                          goto LABEL_143;
                                        }
                                        v115 = xmlRelaxNGNewDefine(a1, a2);
                                        v10 = v115;
                                        if (!v115)
                                          return (uint64_t *)v10;
                                        *(_DWORD *)v115 = 13;
                                        v116 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"name");
                                        *((_QWORD *)v10 + 2) = v116;
                                        if (v116)
                                        {
                                          xmlRelaxNGNormExtSpace(v116);
                                          if (!xmlValidateNCName(*((const xmlChar **)v10 + 2), 0))
                                          {
LABEL_264:
                                            if (*(_QWORD *)(a2 + 24))
                                              xmlRngPErr(a1, a2, 1064, "parentRef is not empty\n", 0, 0);
                                            v125 = *(xmlHashTable **)(*(_QWORD *)(a1 + 56) + 56);
                                            if (v125
                                              || (v125 = xmlHashCreate(10),
                                                  (*(_QWORD *)(*(_QWORD *)(a1 + 56) + 56) = v125) != 0))
                                            {
                                              v126 = (const xmlChar *)*((_QWORD *)v10 + 2);
                                              if (!v126 || (xmlHashAddEntry(v125, v126, v10) & 0x80000000) == 0)
                                                return (uint64_t *)v10;
                                              v64 = xmlHashLookup(*(xmlHashTablePtr *)(*(_QWORD *)(a1 + 56) + 56), *((const xmlChar **)v10 + 2));
                                              if (v64)
                                                goto LABEL_123;
                                              v78 = (const xmlChar *)*((_QWORD *)v10 + 2);
                                              v74 = "Internal error parentRef definitions '%s'\n";
                                              v75 = a1;
                                              v76 = a2;
                                              v77 = 1060;
                                              goto LABEL_258;
                                            }
                                            v74 = "Could not create references hash\n";
                                            v75 = a1;
                                            v76 = a2;
                                            v77 = 1060;
                                            goto LABEL_143;
                                          }
                                          v117 = (const xmlChar *)*((_QWORD *)v10 + 2);
                                          v118 = "parentRef name '%s' is not an NCName\n";
                                          v119 = a1;
                                          v120 = a2;
                                          v121 = 1061;
                                        }
                                        else
                                        {
                                          v118 = "parentRef has no name\n";
                                          v119 = a1;
                                          v120 = a2;
                                          v121 = 1062;
                                          v117 = 0;
                                        }
                                        xmlRngPErr(v119, v120, v121, v118, v117, 0);
                                        goto LABEL_264;
                                      }
                                      v114 = *(_QWORD *)(a2 + 72);
                                    }
                                    if (v114
                                      && *(_DWORD *)(a2 + 8) == 1
                                      && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"mixed")
                                      && xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                    {
                                      if (*(_QWORD *)(a2 + 24))
                                      {
                                        v122 = xmlRelaxNGParseInterleave(a1, a2);
                                        v10 = v122;
                                        if (!v122)
                                          return (uint64_t *)v10;
                                        v123 = v122[6];
                                        if (v123)
                                        {
                                          if (*(_QWORD *)(v123 + 64))
                                          {
                                            v124 = xmlRelaxNGNewDefine(a1, a2);
                                            if (v124)
                                            {
                                              *(_DWORD *)v124 = 18;
                                              *((_QWORD *)v124 + 6) = *((_QWORD *)v10 + 6);
                                              *((_QWORD *)v10 + 6) = v124;
                                            }
                                          }
                                        }
                                        v36 = xmlRelaxNGNewDefine(a1, a2);
                                        if (!v36)
                                          return (uint64_t *)v10;
                                        *(_DWORD *)v36 = 3;
                                        *((_QWORD *)v36 + 8) = *((_QWORD *)v10 + 6);
                                        goto LABEL_54;
                                      }
                                      v74 = "Mixed is empty\n";
                                      v75 = a1;
                                      v76 = a2;
                                      v77 = 1023;
                                      goto LABEL_143;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_257:
    v78 = *(const xmlChar **)(a2 + 16);
    v74 = "Unexpected node %s is not a pattern\n";
    v75 = a1;
    v76 = a2;
    v77 = 1115;
    goto LABEL_258;
  }
  if (!xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    v8 = *(_QWORD *)(a2 + 72);
    goto LABEL_23;
  }
  v9 = xmlRelaxNGNewDefine(a1, a2);
  v10 = v9;
  if (v9)
  {
    *(_DWORD *)v9 = 9;
    *((_QWORD *)v9 + 7) = *(_QWORD *)(a1 + 88);
    v11 = *(_QWORD *)(a2 + 24);
    if (v11)
    {
      v12 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 64) = v12 | 1;
      if (!xmlRelaxNGParseNameClass(a1, v11, (uint64_t)v9) || (v11 = *(_QWORD *)(v11 + 48)) != 0)
      {
        v13 = xmlRelaxNGParsePattern(a1, v11);
        if (v13)
        {
          v14 = *(_DWORD *)v13 + 1;
          if (v14 <= 0x15)
          {
            v15 = 1 << v14;
            if ((v15 & 0x1FFF76) != 0)
            {
              *((_QWORD *)v10 + 6) = v13;
              *(_QWORD *)(v13 + 56) = v10;
            }
            else
            {
              if ((v15 & 0x200088) != 0)
              {
                v28 = "attribute has invalid content\n";
                v29 = a1;
                v30 = a2;
                v31 = 1003;
              }
              else
              {
                v28 = "RNG Internal error, noop found in attribute\n";
                v29 = a1;
                v30 = a2;
                v31 = 1005;
              }
              xmlRngPErr(v29, v30, v31, v28, 0, 0);
            }
          }
        }
        if (*(_QWORD *)(v11 + 48))
          xmlRngPErr(a1, a2, 1002, "attribute has multiple children\n", 0, 0);
      }
      *(_DWORD *)(a1 + 64) = v12;
      return (uint64_t *)v10;
    }
    v19 = "xmlRelaxNGParseattribute: attribute has no children\n";
    v20 = a1;
    v21 = a2;
    v22 = 1004;
LABEL_31:
    name = 0;
LABEL_32:
    v24 = 0;
LABEL_33:
    xmlRngPErr(v20, v21, v22, v19, name, v24);
  }
  return (uint64_t *)v10;
}

_OWORD *xmlRelaxNGParseNameClass(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _OWORD *v6;
  int v7;
  uint64_t v8;
  _OWORD *v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned __int8 *Content;
  uint64_t v16;
  const xmlChar *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  xmlChar *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  xmlChar *v25;
  const xmlChar *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  const xmlChar *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  xmlChar *Prop;
  const xmlChar *v37;
  _OWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  if (!*(_QWORD *)(a2 + 72))
    goto LABEL_83;
  v6 = (_OWORD *)a3;
  if (*(_DWORD *)(a2 + 8) == 1)
  {
    v7 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"name");
    v8 = *(_QWORD *)(a2 + 72);
    if (v7)
    {
      if (xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
      {
LABEL_5:
        v6 = (_OWORD *)a3;
        if (*(_DWORD *)a3 != 4)
        {
          v6 = (_OWORD *)a3;
          if (*(_DWORD *)a3 != 9)
          {
            v9 = xmlRelaxNGNewDefine(a1, a2);
            v6 = v9;
            if (!v9)
              return v6;
            *((_QWORD *)v9 + 7) = a3;
            if ((*(_DWORD *)(a1 + 64) & 1) != 0)
              v10 = 9;
            else
              v10 = 4;
            *(_DWORD *)v9 = v10;
          }
        }
        goto LABEL_22;
      }
      v8 = *(_QWORD *)(a2 + 72);
    }
    if (!v8)
      goto LABEL_83;
    v6 = (_OWORD *)a3;
    if (*(_DWORD *)(a2 + 8) == 1)
    {
      v11 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"anyName");
      v12 = *(_QWORD *)(a2 + 72);
      if (v11)
      {
        if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          goto LABEL_5;
        v12 = *(_QWORD *)(a2 + 72);
      }
      if (!v12)
        goto LABEL_83;
      v6 = (_OWORD *)a3;
      if (*(_DWORD *)(a2 + 8) == 1)
      {
        v6 = (_OWORD *)a3;
        if (xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"nsName"))
        {
          v6 = (_OWORD *)a3;
          if (xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            goto LABEL_5;
          }
        }
      }
    }
  }
LABEL_22:
  if (!*(_QWORD *)(a2 + 72) || *(_DWORD *)(a2 + 8) != 1)
    goto LABEL_83;
  v13 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"name");
  v14 = *(_QWORD *)(a2 + 72);
  if (!v13)
    goto LABEL_30;
  if (!xmlStrEqual(*(const xmlChar **)(v14 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    v14 = *(_QWORD *)(a2 + 72);
LABEL_30:
    if (v14 && *(_DWORD *)(a2 + 8) == 1)
    {
      v22 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"anyName");
      v23 = *(_QWORD *)(a2 + 72);
      if (v22)
      {
        if (xmlStrEqual(*(const xmlChar **)(v23 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          *((_QWORD *)v6 + 2) = 0;
          *((_QWORD *)v6 + 3) = 0;
LABEL_35:
          v24 = *(_QWORD *)(a2 + 24);
          if (v24)
            *((_QWORD *)v6 + 10) = xmlRelaxNGParseExceptNameClass(a1, v24, *(_DWORD *)a3 == 9);
          goto LABEL_49;
        }
        v23 = *(_QWORD *)(a2 + 72);
      }
      if (v23 && *(_DWORD *)(a2 + 8) == 1)
      {
        v34 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"nsName");
        v35 = *(_QWORD *)(a2 + 72);
        if (v34)
        {
          if (xmlStrEqual(*(const xmlChar **)(v35 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            *((_QWORD *)v6 + 2) = 0;
            Prop = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"ns");
            *((_QWORD *)v6 + 3) = Prop;
            if (!Prop)
              xmlRngPErr(a1, a2, 1057, "nsName has no ns attribute\n", 0, 0);
            if ((*(_BYTE *)(a1 + 64) & 1) != 0)
            {
              v37 = (const xmlChar *)*((_QWORD *)v6 + 3);
              if (v37)
              {
                if (xmlStrEqual(v37, (const xmlChar *)"http://www.w3.org/2000/xmlns"))
                  xmlRngPErr(a1, a2, 1122, "Attribute with namespace '%s' is not allowed\n", *((const xmlChar **)v6 + 3), 0);
              }
            }
            goto LABEL_35;
          }
          v35 = *(_QWORD *)(a2 + 72);
        }
        if (v35
          && *(_DWORD *)(a2 + 8) == 1
          && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"choice")
          && xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          v6 = (_OWORD *)a3;
          if (*(_DWORD *)a3 != 17)
          {
            v38 = xmlRelaxNGNewDefine(a1, a2);
            v6 = v38;
            if (!v38)
              return v6;
            *((_QWORD *)v38 + 7) = a3;
            *(_DWORD *)v38 = 17;
          }
          v39 = *(_QWORD *)(a2 + 24);
          if (!v39)
          {
            v27 = "Element choice is empty\n";
            v28 = a1;
            v29 = a2;
            v30 = 1007;
            v31 = 0;
            goto LABEL_48;
          }
          v40 = 0;
          while (1)
          {
            v41 = xmlRelaxNGParseNameClass(a1, v39, v6);
            if (!v41)
              break;
            if (v40)
            {
              if ((_OWORD *)v41 == v6)
                break;
              *(_QWORD *)(v40 + 64) = v41;
            }
LABEL_81:
            v39 = *(_QWORD *)(v39 + 48);
            v40 = v41;
            if (!v39)
              goto LABEL_49;
          }
          v41 = v40;
          goto LABEL_81;
        }
      }
    }
LABEL_83:
    xmlRngPErr(a1, a2, 1006, "expecting name, anyName, nsName or choice : got %s\n", *(const xmlChar **)(a2 + 16), 0);
    return 0;
  }
  Content = xmlNodeGetContent((const xmlNode *)a2);
  xmlRelaxNGNormExtSpace(Content);
  if (xmlValidateNCName(Content, 0))
  {
    v16 = *(_QWORD *)(a2 + 40);
    if (v16)
    {
      v17 = *(const xmlChar **)(v16 + 16);
      v18 = "Element %s name '%s' is not an NCName\n";
      v19 = a1;
      v20 = a2;
      v21 = Content;
    }
    else
    {
      v18 = "name '%s' is not an NCName\n";
      v19 = a1;
      v20 = a2;
      v17 = Content;
      v21 = 0;
    }
    xmlRngPErr(v19, v20, 1019, v18, v17, v21);
  }
  *((_QWORD *)v6 + 2) = Content;
  v25 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"ns");
  v26 = v25;
  *((_QWORD *)v6 + 3) = v25;
  if ((*(_BYTE *)(a1 + 64) & 1) != 0 && v25 && xmlStrEqual(v25, (const xmlChar *)"http://www.w3.org/2000/xmlns"))
    xmlRngPErr(a1, a2, 1122, "Attribute with namespace '%s' is not allowed\n", v26, 0);
  if ((*(_BYTE *)(a1 + 64) & 1) == 0
    || !v26
    || *v26
    || !xmlStrEqual(*((const xmlChar **)v6 + 2), (const xmlChar *)"xmlns"))
  {
    goto LABEL_49;
  }
  v27 = "Attribute with QName 'xmlns' is not allowed\n";
  v28 = a1;
  v29 = a2;
  v30 = 1121;
  v31 = v26;
LABEL_48:
  xmlRngPErr(v28, v29, v30, v27, v31, 0);
LABEL_49:
  if (v6 == (_OWORD *)a3)
    return (_OWORD *)a3;
  v32 = *(_QWORD *)(a3 + 80);
  if (v32)
  {
    do
    {
      v33 = v32;
      v32 = *(_QWORD *)(v32 + 64);
    }
    while (v32);
    *(_QWORD *)(v33 + 64) = v6;
  }
  else
  {
    *(_QWORD *)(a3 + 80) = v6;
  }
  return v6;
}

_OWORD *xmlRelaxNGParseExceptNameClass(uint64_t a1, uint64_t a2, int a3)
{
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v8;
  _OWORD *v9;
  int v10;
  _OWORD *v11;
  _OWORD *v12;
  _QWORD *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;

  if (!*(_QWORD *)(a2 + 72)
    || *(_DWORD *)(a2 + 8) != 1
    || !xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"except")
    || !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    v14 = "Expecting an except node\n";
    v15 = a1;
    v16 = a2;
    v17 = 1028;
LABEL_21:
    xmlRngPErr(v15, v16, v17, v14, 0, 0);
    return 0;
  }
  if (*(_QWORD *)(a2 + 48))
    xmlRngPErr(a1, a2, 1029, "exceptNameClass allows only a single except node\n", 0, 0);
  if (!*(_QWORD *)(a2 + 24))
  {
    v14 = "except has no content\n";
    v15 = a1;
    v16 = a2;
    v17 = 1027;
    goto LABEL_21;
  }
  v6 = xmlRelaxNGNewDefine(a1, a2);
  v7 = v6;
  if (v6)
  {
    *(_DWORD *)v6 = 2;
    v8 = *(_QWORD *)(a2 + 24);
    if (v8)
    {
      v9 = 0;
      if (a3)
        v10 = 9;
      else
        v10 = 4;
      do
      {
        v11 = xmlRelaxNGNewDefine(a1, v8);
        if (!v11)
          break;
        v12 = v11;
        *(_DWORD *)v11 = v10;
        if (xmlRelaxNGParseNameClass(a1, v8, v11))
        {
          v13 = v9 + 4;
          if (!v9)
            v13 = v7 + 3;
          *v13 = v12;
          v9 = v12;
        }
        v8 = *(_QWORD *)(v8 + 48);
      }
      while (v8);
    }
  }
  return v7;
}

uint64_t *xmlRelaxNGParseInterleave(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t *v5;
  xmlHashTablePtr v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  char __str[16];
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
  v5 = v4;
  if (v4)
  {
    *(_DWORD *)v4 = 19;
    if (*(_QWORD *)(a1 + 104) || (v6 = xmlHashCreate(10), (*(_QWORD *)(a1 + 104) = v6) != 0))
    {
      *(_OWORD *)__str = 0u;
      v14 = 0u;
      v7 = *(_DWORD *)(a1 + 96);
      *(_DWORD *)(a1 + 96) = v7 + 1;
      snprintf(__str, 0x20uLL, "interleave%d", v7);
      if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 104), (const xmlChar *)__str, v5) < 0)
        xmlRngPErr(a1, a2, 1045, "Failed to add %s to hash table\n", (const xmlChar *)__str, 0);
    }
    else
    {
      xmlRngPErrMemory(a1, (const xmlChar *)"create interleaves\n");
    }
    v8 = *(_QWORD *)(a2 + 24);
    if (v8)
    {
      v9 = 0;
      while (1)
      {
        if (*(_QWORD *)(v8 + 72)
          && *(_DWORD *)(v8 + 8) == 1
          && xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"element")
          && xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v8 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          v10 = xmlRelaxNGParseElement(a1, v8);
          if (v10)
            goto LABEL_16;
        }
        else
        {
          v10 = xmlRelaxNGParsePattern(a1, v8);
          if (v10)
          {
LABEL_16:
            *(_QWORD *)(v10 + 56) = v5;
            v11 = (uint64_t *)(v9 + 64);
            if (!v9)
              v11 = v5 + 6;
            *v11 = v10;
            v9 = v10;
          }
        }
        v8 = *(_QWORD *)(v8 + 48);
        if (!v8)
          return v5;
      }
    }
    xmlRngPErr(a1, a2, 1048, "Element interleave is empty\n", 0, 0);
  }
  return v5;
}

_OWORD *xmlRelaxNGProcessExternalRef(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _OWORD *v5;
  _OWORD *v6;
  const xmlNode *RootElement;
  xmlNode *v8;
  xmlChar *Prop;
  _BOOL4 v10;
  xmlChar *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  xmlHashTable *v16;
  uint64_t v17;
  xmlHashTablePtr v18;

  v2 = *(_QWORD *)(a2 + 104);
  if (!v2)
    return 0;
  v3 = a2;
  v5 = xmlRelaxNGNewDefine(a1, a2);
  v6 = v5;
  if (v5)
  {
    *(_DWORD *)v5 = 12;
    if (*(_QWORD *)(v2 + 24))
    {
LABEL_4:
      *((_QWORD *)v6 + 6) = *(_QWORD *)(v2 + 24);
      return v6;
    }
    RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v2 + 16));
    if (RootElement)
    {
      v8 = (xmlNode *)RootElement;
      Prop = xmlGetProp(RootElement, (const xmlChar *)"ns");
      v10 = Prop == 0;
      if (!Prop)
      {
        while (1)
        {
          if (*(_DWORD *)(v3 + 8) != 1)
          {
LABEL_14:
            v10 = 0;
            goto LABEL_15;
          }
          v12 = xmlGetProp((const xmlNode *)v3, (const xmlChar *)"ns");
          if (v12)
            break;
          v3 = *(_QWORD *)(v3 + 40);
          if (!v3)
            goto LABEL_14;
        }
        Prop = v12;
        xmlSetProp(v8, (const xmlChar *)"ns", v12);
      }
      xmlFree(Prop);
LABEL_15:
      v13 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 64) = v13 | 0x80;
      v14 = xmlRelaxNGParseDocument(a1, v8);
      *(_QWORD *)(v2 + 32) = v14;
      *(_DWORD *)(a1 + 64) = v13;
      if (v14)
      {
        v15 = *(_QWORD *)(v14 + 8);
        if (v15)
        {
          *(_QWORD *)(v2 + 24) = *(_QWORD *)(v15 + 24);
          v16 = *(xmlHashTable **)(v15 + 56);
          if (v16)
          {
            v17 = *(_QWORD *)(a1 + 48);
            if (v17)
            {
              if (!*(_QWORD *)(v17 + 56))
              {
                v18 = xmlHashCreate(10);
                *(_QWORD *)(*(_QWORD *)(a1 + 48) + 56) = v18;
                if (!v18)
                {
                  xmlRngPErr(a1, 0, 1098, "Could not create references hash\n", 0, 0);
                  if (!v10)
                    goto LABEL_4;
                  goto LABEL_24;
                }
                v16 = *(xmlHashTable **)(v15 + 56);
              }
              xmlHashScan(v16, (xmlHashScanner)xmlRelaxNGParseImportRef, (void *)a1);
            }
          }
        }
      }
      if (!v10)
        goto LABEL_4;
LABEL_24:
      xmlUnsetProp(v8, (const xmlChar *)"ns");
      goto LABEL_4;
    }
    xmlRngPErr(a1, v3, 1031, "xmlRelaxNGParse: %s is empty\n", *(const xmlChar **)(a1 + 128), 0);
    return 0;
  }
  return v6;
}

xmlChar *xmlRelaxNGGetDataTypeLibrary(uint64_t a1)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  xmlChar *Prop;
  xmlChar *v5;
  xmlChar *v6;

  v1 = a1;
  if (!*(_QWORD *)(a1 + 72) || *(_DWORD *)(a1 + 8) != 1)
    goto LABEL_11;
  v2 = xmlStrEqual(*(const xmlChar **)(a1 + 16), (const xmlChar *)"data");
  v3 = *(_QWORD *)(v1 + 72);
  if (v2)
  {
    if (xmlStrEqual(*(const xmlChar **)(v3 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
      goto LABEL_10;
    v3 = *(_QWORD *)(v1 + 72);
  }
  if (!v3
    || *(_DWORD *)(v1 + 8) != 1
    || !xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"value")
    || !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v1 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    goto LABEL_11;
  }
LABEL_10:
  while (1)
  {
    Prop = xmlGetProp((const xmlNode *)v1, (const xmlChar *)"datatypeLibrary");
    if (Prop)
      break;
LABEL_11:
    v1 = *(_QWORD *)(v1 + 40);
    if (!v1 || *(_DWORD *)(v1 + 8) != 1)
      return 0;
  }
  v5 = Prop;
  if (*Prop)
  {
    v6 = xmlURIEscapeStr(Prop, (const xmlChar *)":/#?");
    if (!v6)
      return v5;
  }
  else
  {
    v6 = 0;
  }
  xmlFree(v5);
  return v6;
}

uint64_t xmlRelaxNGParseImportRef(void *userdata, uint64_t a2, xmlChar *name)
{
  uint64_t result;
  const xmlChar *v6;
  const char *v7;

  *((_WORD *)userdata + 49) |= 0x100u;
  result = xmlHashAddEntry(*(xmlHashTablePtr *)(*(_QWORD *)(a2 + 48) + 56), name, userdata);
  if ((result & 0x80000000) != 0)
  {
    result = (uint64_t)xmlHashLookup(*(xmlHashTablePtr *)(*(_QWORD *)(a2 + 48) + 56), *((const xmlChar **)userdata + 2));
    if (result)
    {
      *((_QWORD *)userdata + 11) = *(_QWORD *)(result + 88);
      *(_QWORD *)(result + 88) = userdata;
    }
    else
    {
      v6 = (const xmlChar *)*((_QWORD *)userdata + 2);
      if (v6)
        v7 = "Error refs definitions '%s'\n";
      else
        v7 = "Error refs definitions\n";
      return (uint64_t)xmlRngPErr(a2, 0, 1098, v7, v6, 0);
    }
  }
  return result;
}

uint64_t xmlRelaxNGTryUnlink(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  if (a3)
  {
    *(_QWORD *)(a3 + 64) = *(_QWORD *)(a1 + 64);
  }
  else if (a2)
  {
    if (a2[6] == a1)
    {
      a3 = 0;
      a2[6] = *(_QWORD *)(a1 + 64);
    }
    else if (a2[9] == a1)
    {
      a3 = 0;
      a2[9] = *(_QWORD *)(a1 + 64);
    }
    else
    {
      a3 = 0;
      if (a2[10] == a1)
        a2[10] = *(_QWORD *)(a1 + 64);
    }
  }
  else
  {
    *(_DWORD *)a1 = -1;
    return a1;
  }
  return a3;
}

uint64_t xmlRelaxNGGenerateAttributes(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t i;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  int v8;
  BOOL v10;

  if (*(_DWORD *)(a1 + 68))
    return 0xFFFFFFFFLL;
  result = 1;
  if (a2)
  {
    for (i = a2; ; i = v5)
    {
      v4 = *(_DWORD *)i;
      if ((*(_DWORD *)i - 10) >= 0xA)
      {
        v7 = v4 > 8;
        v8 = (1 << v4) & 0x1F9;
        if (!v7 && v8 != 0)
          return 0;
      }
      else
      {
        v5 = *(_QWORD *)(i + 48);
        if (v5)
        {
          v6 = *(_QWORD *)(i + 48);
          do
          {
            *(_QWORD *)(v6 + 56) = i;
            v6 = *(_QWORD *)(v6 + 64);
          }
          while (v6);
          continue;
        }
      }
      if (i == a2)
        return 1;
      while (1)
      {
        v5 = *(_QWORD *)(i + 64);
        if (v5)
          break;
        i = *(_QWORD *)(i + 56);
        if (i)
          v10 = i == a2;
        else
          v10 = 1;
        if (v10)
          return 1;
      }
    }
  }
  return result;
}

void xmlRelaxNGCheckGroupAttrs(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  uint64_t v5;
  unsigned int v6;
  uint64_t i;
  void **v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  uint64_t j;
  BOOL v17;
  uint64_t v18;
  _QWORD **v19;
  void **v20;

  v2 = *(_DWORD *)a2 == 18 || *(_DWORD *)a2 == 4;
  if (v2 && (*(_WORD *)(a2 + 98) & 0x20) == 0 && !*(_DWORD *)(a1 + 68))
  {
    v5 = *(_QWORD *)(a2 + 72);
    if (v5)
    {
      v6 = 0;
      do
      {
        ++v6;
        v5 = *(_QWORD *)(v5 + 64);
      }
      while (v5);
    }
    else
    {
      v6 = 0;
    }
    for (i = *(_QWORD *)(a2 + 48); i; i = *(_QWORD *)(i + 64))
      ++v6;
    v8 = (void **)xmlMalloc(8 * v6);
    if (v8)
    {
      v9 = v8;
      v10 = v6;
      v11 = *(_QWORD *)(a2 + 72);
      if (v11)
      {
        v12 = 0;
        do
        {
          v9[v12++] = xmlRelaxNGGetElements(a1, (_DWORD *)v11, 1);
          v11 = *(_QWORD *)(v11 + 64);
        }
        while (v11);
        v13 = v12;
      }
      else
      {
        v13 = 0;
      }
      v14 = *(_QWORD *)(a2 + 48);
      if (v14)
      {
        v15 = &v9[v13];
        do
        {
          *v15++ = xmlRelaxNGGetElements(a1, (_DWORD *)v14, 1);
          v14 = *(_QWORD *)(v14 + 64);
        }
        while (v14);
      }
      if ((_DWORD)v10)
      {
        for (j = 0; j != v10; ++j)
        {
          if (v9[j])
            v17 = j == 0;
          else
            v17 = 1;
          if (!v17)
          {
            v18 = 0;
            do
            {
              v19 = (_QWORD **)v9[v18];
              if (v19 && !xmlRelaxNGCompareElemDefLists((uint64_t)v9[j], v19))
                xmlRngPErr(a1, *(_QWORD *)(a2 + 8), 1040, "Attributes conflicts in group\n", 0, 0);
              ++v18;
            }
            while (j != v18);
          }
        }
        v20 = v9;
        do
        {
          if (*v20)
            xmlFree(*v20);
          ++v20;
          --v10;
        }
        while (v10);
      }
      xmlFree(v9);
      *(_WORD *)(a2 + 98) |= 0x20u;
    }
    else
    {
      xmlRngPErrMemory(a1, (const xmlChar *)"building group\n");
    }
  }
}

_QWORD *xmlRelaxNGGetElements(uint64_t a1, _DWORD *a2, int a3)
{
  BOOL v3;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  _DWORD *v10;
  _QWORD *v11;
  unsigned int v12;
  _QWORD *v14;
  uint64_t v15;
  BOOL v16;

  if (*(_DWORD *)(a1 + 68))
    v3 = 1;
  else
    v3 = a2 == 0;
  if (v3)
    return 0;
  v7 = 0;
  LODWORD(v8) = 0;
  v9 = 0;
  v10 = a2;
  while (1)
  {
    v11 = v10;
    if (!a3)
    {
      v12 = *v10;
      if (v12 - 3 < 2)
        goto LABEL_14;
      goto LABEL_23;
    }
    if (a3 != 1)
      break;
    v12 = *v10;
    if (v12 == 9)
      goto LABEL_14;
LABEL_23:
    if (v12 - 10 <= 9 && (v10 = (_DWORD *)v11[6]) != 0)
    {
      v15 = v11[6];
      do
      {
        *(_QWORD *)(v15 + 56) = v11;
        v15 = *(_QWORD *)(v15 + 64);
      }
      while (v15);
    }
    else
    {
LABEL_31:
      if (v11 == (_QWORD *)a2)
        return v9;
      while (1)
      {
        v10 = (_DWORD *)v11[8];
        if (v10)
          break;
        v11 = (_QWORD *)v11[7];
        if (v11)
          v16 = v11 == (_QWORD *)a2;
        else
          v16 = 1;
        if (v16)
          return v9;
      }
    }
  }
  if (a3 != 2)
  {
    v12 = *v10;
    goto LABEL_23;
  }
  v12 = *v10;
  if (v12 > 8 || ((1 << v12) & 0x1B8) == 0)
    goto LABEL_23;
LABEL_14:
  if (!v9)
  {
    v9 = xmlMalloc(0x58uLL);
    if (!v9)
    {
      xmlRngPErrMemory(a1, (const xmlChar *)"getting element list\n");
      return v9;
    }
    v7 = 10;
    goto LABEL_30;
  }
  if (v7 > (int)v8)
  {
LABEL_30:
    v9[(int)v8] = v11;
    v8 = (int)v8 + 1;
    v9[v8] = 0;
    goto LABEL_31;
  }
  v14 = xmlRealloc(v9, 8 * ((2 * v7) | 1));
  if (v14)
  {
    v7 *= 2;
    v9 = v14;
    goto LABEL_30;
  }
  xmlRngPErrMemory(a1, (const xmlChar *)"getting element list\n");
  xmlFree(v9);
  return 0;
}

uint64_t xmlRelaxNGCompareElemDefLists(uint64_t a1, _QWORD **a2)
{
  uint64_t result;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  result = 1;
  if (a1)
  {
    if (a2)
    {
      if (*(_QWORD *)a1)
      {
        v5 = *a2;
        if (*a2)
        {
          while (1)
          {
            v6 = a2 + 1;
            if (v5)
              break;
LABEL_8:
            v8 = *(_QWORD *)(a1 + 8);
            a1 += 8;
            if (!v8)
              return 1;
            v5 = *a2;
          }
          while (1)
          {
            result = xmlRelaxNGCompareNameClasses(*(_QWORD **)a1, v5);
            if (!(_DWORD)result)
              break;
            v7 = (_QWORD *)*v6++;
            v5 = v7;
            if (!v7)
              goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

uint64_t xmlRelaxNGCompareNameClasses(_QWORD *a1, _QWORD *a2)
{
  int v2;
  uint64_t result;
  xmlGenericErrorFunc v6;
  void *v7;
  const char *v8;
  _BYTE *v9;
  _BYTE *v10;
  const char *v11;
  xmlGenericErrorFunc v12;
  void *v13;
  _OWORD v14[3];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = 0;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v27 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  DWORD2(v15) = 9;
  v2 = *(_DWORD *)a1 - 2;
  memset(v14, 0, sizeof(v14));
  switch(v2)
  {
    case 0:
      if (xmlRelaxNGCompareNameClasses(a1[6], a2))
        return 0;
      goto LABEL_17;
    case 1:
      return *(_DWORD *)a2 != 3;
    case 2:
    case 7:
      if (*(_DWORD *)a2 == 3)
        return 1;
      v8 = "\x01";
      v9 = (_BYTE *)a1[3];
      if (a1[2])
        v8 = (const char *)a1[2];
      *(_QWORD *)&v28 = v8;
      if (v9 && *v9)
      {
        *((_QWORD *)&v31 + 1) = &v24;
        *(_QWORD *)&v25 = v9;
      }
      else
      {
        *((_QWORD *)&v31 + 1) = 0;
      }
      if (!xmlRelaxNGElementMatch((uint64_t)v14, a2, (uint64_t)&v27)
        || (result = a1[10]) != 0 && (result = xmlRelaxNGCompareNameClasses(result, a2), (_DWORD)result))
      {
LABEL_17:
        if (*(_DWORD *)a2 == 9 || *(_DWORD *)a2 == 4)
        {
          v11 = (const char *)a2[2];
          v10 = (_BYTE *)a2[3];
          if (!v11)
            v11 = "\x01";
          *(_QWORD *)&v28 = v11;
          *((_QWORD *)&v31 + 1) = &v24;
          if (v10)
          {
            if (*v10)
              *(_QWORD *)&v25 = v10;
            else
              *((_QWORD *)&v31 + 1) = 0;
          }
          else
          {
            *(_QWORD *)&v25 = "\x01";
          }
          if (xmlRelaxNGElementMatch((uint64_t)v14, a1, (uint64_t)&v27))
          {
            result = a2[10];
            if (result)
              return xmlRelaxNGCompareNameClasses(result, a1);
          }
          else
          {
            return 1;
          }
        }
        else
        {
          v12 = *__xmlGenericError();
          v13 = *__xmlGenericErrorContext();
          v12(v13, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 3886);
          return 0;
        }
      }
      return result;
    default:
      v6 = *__xmlGenericError();
      v7 = *__xmlGenericErrorContext();
      v6(v7, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 3855);
      return 0;
  }
}

uint64_t xmlRelaxNGElementMatch(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  const xmlChar *v6;
  const xmlChar *v7;
  uint64_t v8;
  xmlChar *v9;
  xmlChar *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t result;
  xmlGenericErrorFunc v16;
  void **v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;

  v6 = (const xmlChar *)a2[2];
  if (v6 && !xmlStrEqual(*(const xmlChar **)(a3 + 16), v6))
  {
    v9 = (xmlChar *)a2[2];
    v10 = *(xmlChar **)(a3 + 16);
    v11 = a1;
    v12 = 13;
    goto LABEL_23;
  }
  v7 = (const xmlChar *)a2[3];
  if (!v7)
  {
    if (!*(_QWORD *)(a3 + 72))
      goto LABEL_16;
    v9 = (xmlChar *)a2[2];
    if (!v9)
      goto LABEL_16;
    goto LABEL_15;
  }
  v8 = *(_QWORD *)(a3 + 72);
  if (!*v7)
  {
    if (!v8)
      goto LABEL_16;
    v9 = (xmlChar *)a2[2];
    if (!v9)
      v9 = *(xmlChar **)(a3 + 16);
LABEL_15:
    v11 = a1;
    v12 = 19;
LABEL_22:
    v10 = 0;
    goto LABEL_23;
  }
  if (!v8)
  {
    v9 = *(xmlChar **)(a3 + 16);
    v11 = a1;
    v12 = 15;
    goto LABEL_22;
  }
  if (!xmlStrEqual(*(const xmlChar **)(v8 + 16), v7))
  {
    v9 = *(xmlChar **)(a3 + 16);
    v10 = (xmlChar *)a2[3];
    v11 = a1;
    v12 = 17;
LABEL_23:
    xmlRelaxNGAddValidError(v11, v12, v9, v10, 0);
    return 0;
  }
LABEL_16:
  v13 = a2[10];
  if (!v13)
    return 1;
  if (*(_DWORD *)v13 == 17)
  {
    if (a1)
    {
      v14 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(a1 + 56) = v14 | 1;
    }
    else
    {
      v14 = 0;
    }
    v20 = *(_QWORD *)(v13 + 80);
    if (!v20)
    {
LABEL_41:
      if (!a1)
        return 0;
      if (*(int *)(a1 + 80) >= 1)
        xmlRelaxNGPopErrors(a1, 0);
      goto LABEL_48;
    }
    while (1)
    {
      v21 = xmlRelaxNGElementMatch(a1, v20, a3);
      if (v21 == 1)
        goto LABEL_33;
      if (v21 < 0)
      {
LABEL_44:
        if (a1)
          *(_DWORD *)(a1 + 56) = v14;
        return 0xFFFFFFFFLL;
      }
      v20 = *(_QWORD *)(v20 + 64);
      if (!v20)
        goto LABEL_41;
    }
  }
  if (*(_DWORD *)v13 == 2)
  {
    if (a1)
    {
      v14 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(a1 + 56) = v14 | 1;
    }
    else
    {
      v14 = 0;
    }
    v18 = *(_QWORD *)(v13 + 48);
    if (v18)
    {
      while (1)
      {
        v19 = xmlRelaxNGElementMatch(a1, v18, a3);
        if (v19 == 1)
          break;
        if (v19 < 0)
          goto LABEL_44;
        v18 = *(_QWORD *)(v18 + 64);
        if (!v18)
          goto LABEL_33;
      }
      if (!a1)
        return 0;
LABEL_48:
      result = 0;
      *(_DWORD *)(a1 + 56) = v14;
      return result;
    }
LABEL_33:
    if (a1)
      *(_DWORD *)(a1 + 56) = v14;
    return 1;
  }
  v16 = *__xmlGenericError();
  v17 = __xmlGenericErrorContext();
  v16(*v17, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 9768);
  return 0xFFFFFFFFLL;
}

void xmlRelaxNGDumpValidError(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  const xmlChar **v10;
  const xmlChar **v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  char v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *v23;
  int v24;

  if (*(int *)(a1 + 80) >= 1)
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(a1 + 88);
      if (v4 <= 4)
      {
        v24 = v4;
        v6 = (int *)(v5 + 40 * v3);
        if (v3)
        {
          v7 = 0;
          v8 = v5 + 40 * v3;
          v9 = (_QWORD *)(v8 + 8);
          v10 = (const xmlChar **)(v8 + 24);
          v11 = (const xmlChar **)(v8 + 32);
          while (1)
          {
            v12 = *(_QWORD *)(a1 + 88);
            if (*v6 == *(_DWORD *)(v12 + v7)
              && *v9 == *(_QWORD *)(v12 + v7 + 8)
              && xmlStrEqual(*v10, *(const xmlChar **)(v12 + v7 + 24))
              && xmlStrEqual(*v11, *(const xmlChar **)(v12 + v7 + 32)))
            {
              break;
            }
            v7 += 40;
            if (v2 == v7)
              goto LABEL_11;
          }
          v4 = v24;
        }
        else
        {
LABEL_11:
          xmlRelaxNGShowValidError(a1, *v6, *(_QWORD *)(v5 + 40 * v3 + 8), *(_QWORD *)(v5 + 40 * v3 + 16), *(const xmlChar **)(v5 + 40 * v3 + 24), *(xmlChar **)(v5 + 40 * v3 + 32));
          v4 = v24 + 1;
        }
      }
      v13 = v5 + 40 * v3;
      v15 = *(_BYTE *)(v13 + 4);
      v14 = (_DWORD *)(v13 + 4);
      if ((v15 & 1) != 0)
      {
        v16 = v5 + 40 * v3;
        v19 = *(void **)(v16 + 24);
        v18 = (_QWORD *)(v16 + 24);
        v17 = v19;
        if (v19)
          xmlFree(v17);
        *v18 = 0;
        v20 = v5 + 40 * v3;
        v23 = *(void **)(v20 + 32);
        v22 = (_QWORD *)(v20 + 32);
        v21 = v23;
        if (v23)
          xmlFree(v21);
        *v22 = 0;
        *v14 = 0;
      }
      ++v3;
      v2 += 40;
    }
    while (v3 < *(int *)(a1 + 80));
  }
  *(_DWORD *)(a1 + 80) = 0;
}

void xmlRelaxNGPopErrors(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;

  v4 = *(_DWORD *)(a1 + 80);
  if (v4 > a2)
  {
    v5 = a2;
    v6 = 40 * a2;
    do
    {
      v7 = *(_QWORD *)(a1 + 88);
      v8 = v7 + v6;
      if ((*(_BYTE *)(v7 + v6 + 4) & 1) != 0)
      {
        v9 = *(void **)(v8 + 24);
        if (v9)
          xmlFree(v9);
        *(_QWORD *)(v8 + 24) = 0;
        v10 = v7 + v6;
        v11 = *(void **)(v10 + 32);
        if (v11)
          xmlFree(v11);
        *(_QWORD *)(v10 + 32) = 0;
        *(_DWORD *)(v8 + 4) = 0;
        v4 = *(_DWORD *)(a1 + 80);
      }
      ++v5;
      v6 += 40;
    }
    while (v5 < v4);
  }
  *(_DWORD *)(a1 + 80) = a2;
  if (a2 <= 0)
    *(_QWORD *)(a1 + 72) = 0;
}

void xmlRelaxNGShowValidError(uint64_t a1, int a2, uint64_t a3, uint64_t a4, const xmlChar *a5, xmlChar *a6)
{
  const char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  void (__cdecl *v16)(void *, xmlErrorPtr);
  void (*v17)(void *, const char *, ...);
  void *v18;
  xmlChar *v19;
  char __str;
  _BYTE v21[999];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 56) & 8) == 0)
  {
    bzero(v21, 0x3E6uLL);
    __str = 0;
    switch(a2)
    {
      case 0:
        return;
      case 1:
        v12 = "out of memory\n";
        goto LABEL_34;
      case 2:
        snprintf(&__str, 0x3E8uLL, "failed to validate type %s\n");
        goto LABEL_39;
      case 3:
        snprintf(&__str, 0x3E8uLL, "Type %s doesn't allow value '%s'\n");
        goto LABEL_39;
      case 4:
        snprintf(&__str, 0x3E8uLL, "ID %s redefined\n");
        goto LABEL_39;
      case 5:
        snprintf(&__str, 0x3E8uLL, "failed to compare type %s\n");
        goto LABEL_39;
      case 6:
        v12 = "Internal error: no state\n";
        goto LABEL_34;
      case 7:
        v12 = "Internal error: no define\n";
        goto LABEL_34;
      case 8:
        snprintf(&__str, 0x3E8uLL, "Extra data in list: %s\n");
        goto LABEL_39;
      case 10:
        v12 = "Internal: interleave block has no data\n";
        goto LABEL_34;
      case 11:
        v12 = "Invalid sequence in interleave\n";
        goto LABEL_34;
      case 12:
        snprintf(&__str, 0x3E8uLL, "Extra element %s in interleave\n");
        goto LABEL_39;
      case 13:
        snprintf(&__str, 0x3E8uLL, "Expecting element %s, got %s\n");
        goto LABEL_39;
      case 15:
        snprintf(&__str, 0x3E8uLL, "Expecting a namespace for element %s\n");
        goto LABEL_39;
      case 17:
        snprintf(&__str, 0x3E8uLL, "Element %s has wrong namespace: expecting %s\n");
        goto LABEL_39;
      case 19:
        snprintf(&__str, 0x3E8uLL, "Expecting no namespace for element %s\n");
        goto LABEL_39;
      case 21:
        snprintf(&__str, 0x3E8uLL, "Expecting element %s to be empty\n");
        goto LABEL_39;
      case 22:
        snprintf(&__str, 0x3E8uLL, "Expecting an element %s, got nothing\n");
        goto LABEL_39;
      case 23:
        v12 = "Expecting an element got text\n";
        goto LABEL_34;
      case 24:
        snprintf(&__str, 0x3E8uLL, "Element %s failed to validate attributes\n");
        goto LABEL_39;
      case 25:
        snprintf(&__str, 0x3E8uLL, "Element %s failed to validate content\n");
        goto LABEL_39;
      case 26:
        snprintf(&__str, 0x3E8uLL, "Element %s has extra content: %s\n");
        goto LABEL_39;
      case 27:
        snprintf(&__str, 0x3E8uLL, "Invalid attribute %s for element %s\n");
        goto LABEL_39;
      case 28:
        snprintf(&__str, 0x3E8uLL, "Datatype element %s has child elements\n");
        goto LABEL_39;
      case 29:
        snprintf(&__str, 0x3E8uLL, "Value element %s has child elements\n");
        goto LABEL_39;
      case 30:
        snprintf(&__str, 0x3E8uLL, "List element %s has child elements\n");
        goto LABEL_39;
      case 31:
        snprintf(&__str, 0x3E8uLL, "Error validating datatype %s\n");
        goto LABEL_39;
      case 32:
        snprintf(&__str, 0x3E8uLL, "Error validating value %s\n");
        goto LABEL_39;
      case 33:
        v12 = "Error validating list\n";
        goto LABEL_34;
      case 34:
        v12 = "No top grammar defined\n";
        goto LABEL_34;
      case 35:
        v12 = "Extra data in the document\n";
        goto LABEL_34;
      case 36:
        snprintf(&__str, 0x3E8uLL, "Datatype element %s contains no data\n");
        goto LABEL_39;
      case 37:
        snprintf(&__str, 0x3E8uLL, "Internal error: %s\n");
        goto LABEL_39;
      case 38:
        snprintf(&__str, 0x3E8uLL, "Did not expect element %s there\n");
        goto LABEL_39;
      case 39:
        snprintf(&__str, 0x3E8uLL, "Did not expect text in element %s content\n");
LABEL_39:
        if (!__str)
          snprintf(&__str, 0x3E8uLL, "Unknown error code %d\n", a2);
        v21[998] = 0;
        v19 = xmlCharStrdup(&__str);
        v13 = xmlEscapeFormatString((void **)&v19);
        break;
      default:
        v12 = "Unknown error !\n";
LABEL_34:
        v13 = (char *)xmlCharStrdup(v12);
        break;
    }
    v14 = v13;
    if (v13)
    {
      if (!*(_DWORD *)(a1 + 68))
        *(_DWORD *)(a1 + 68) = a2;
      if (a4)
        v15 = a4;
      else
        v15 = a3;
      v16 = *(void (__cdecl **)(void *, xmlErrorPtr))(a1 + 24);
      if (v16)
        v17 = 0;
      else
        v17 = *(void (**)(void *, const char *, ...))(a1 + 8);
      v18 = *(void **)a1;
      ++*(_DWORD *)(a1 + 32);
      __xmlRaiseError(v16, v17, v18, 0, v15, 0x13u, a2, 2, 0, 0, a5, a6, 0, 0, 0, v14, (char)a5);
      xmlFree(v14);
    }
  }
}

uint64_t xmlRelaxNGIsNullable(uint64_t a1)
{
  __int16 v2;
  uint64_t result;
  __int16 v4;
  uint64_t v5;
  uint64_t v6;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = *(_WORD *)(a1 + 98);
  if ((v2 & 1) != 0)
    return 1;
  if ((v2 & 2) != 0)
    return 0;
  result = 0xFFFFFFFFLL;
  switch(*(_DWORD *)a1)
  {
    case 0xFFFFFFFF:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0x10:
      result = xmlRelaxNGIsNullable(*(_QWORD *)(a1 + 48));
      goto LABEL_6;
    case 0:
    case 3:
      goto LABEL_9;
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      goto LABEL_20;
    case 0x11:
      v6 = *(_QWORD *)(a1 + 48);
      if (!v6)
        goto LABEL_20;
      while (1)
      {
        result = xmlRelaxNGIsNullable(v6);
        if ((_DWORD)result)
          goto LABEL_6;
        v6 = *(_QWORD *)(v6 + 64);
        if (!v6)
          goto LABEL_20;
      }
    case 0x12:
    case 0x13:
    case 0x14:
      v5 = *(_QWORD *)(a1 + 48);
      if (!v5)
        return 1;
      break;
    default:
      return result;
  }
  while (1)
  {
    result = xmlRelaxNGIsNullable(v5);
    if ((_DWORD)result != 1)
      break;
    v5 = *(_QWORD *)(v5 + 64);
    if (!v5)
      return result;
  }
LABEL_6:
  if ((_DWORD)result)
  {
    if ((_DWORD)result != 1)
      return result;
    v2 = *(_WORD *)(a1 + 98);
LABEL_9:
    v4 = v2 | 1;
    result = 1;
  }
  else
  {
LABEL_20:
    result = 0;
    v4 = *(_WORD *)(a1 + 98) | 2;
  }
  *(_WORD *)(a1 + 98) = v4;
  return result;
}

uint64_t xmlRelaxNGIsCompilable(int *a1)
{
  int v2;
  __int16 v3;
  uint64_t result;
  uint64_t v5;
  int v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = *a1;
  v3 = *((_WORD *)a1 + 49);
  if (*a1 == 4)
  {
    if ((v3 & 0xC0) == 0)
    {
      v5 = *((_QWORD *)a1 + 6);
      if (v5)
      {
        while (1)
        {
          v6 = xmlRelaxNGIsCompilable(v5);
          if (v6 != 1)
            break;
          v5 = *(_QWORD *)(v5 + 64);
          if (!v5)
          {
            v7 = *((_WORD *)a1 + 49) & 0x80;
            if ((*((_WORD *)a1 + 49) & 0x80) == 0)
              v7 = 64;
            goto LABEL_20;
          }
        }
        if (v6)
          goto LABEL_4;
        v7 = *((_WORD *)a1 + 49) & 0xFF3F | 0x80;
LABEL_20:
        *((_WORD *)a1 + 49) = v7;
      }
    }
LABEL_4:
    if (!*((_QWORD *)a1 + 10))
      return *((_QWORD *)a1 + 2) != 0;
    return 0;
  }
  if ((v3 & 0x40) != 0)
    return 1;
  if ((v3 & 0x80) != 0)
    return 0;
  result = 0xFFFFFFFFLL;
  switch(v2)
  {
    case -1:
      result = xmlRelaxNGIsCompilable(*((_QWORD *)a1 + 6));
      goto LABEL_31;
    case 0:
    case 3:
      goto LABEL_35;
    case 1:
    case 2:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 19:
      goto LABEL_10;
    case 10:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 20:
      v8 = *((_QWORD *)a1 + 6);
      if (!v8)
        return result;
      while (1)
      {
        result = xmlRelaxNGIsCompilable(v8);
        if ((_DWORD)result != 1)
          goto LABEL_31;
        v8 = *(_QWORD *)(v8 + 64);
        if (!v8)
          goto LABEL_34;
      }
    case 11:
    case 12:
    case 13:
      if (*((__int16 *)a1 + 48) == -20)
        return 1;
      *((_WORD *)a1 + 48) = -20;
      v9 = *((_QWORD *)a1 + 6);
      if (!v9)
        return result;
      break;
    default:
      return result;
  }
  while (1)
  {
    result = xmlRelaxNGIsCompilable(v9);
    if ((_DWORD)result != 1)
      break;
    v9 = *(_QWORD *)(v9 + 64);
    if (!v9)
      goto LABEL_34;
  }
LABEL_31:
  if ((_DWORD)result == 1)
  {
LABEL_34:
    v3 = *((_WORD *)a1 + 49);
LABEL_35:
    *((_WORD *)a1 + 49) = v3 | 0x40;
    return 1;
  }
  if (!(_DWORD)result)
  {
    v3 = *((_WORD *)a1 + 49);
LABEL_10:
    result = 0;
    *((_WORD *)a1 + 49) = v3 | 0x80;
  }
  return result;
}

uint64_t xmlRelaxNGCompile(uint64_t a1, int *a2)
{
  int *v2;
  int v4;
  uint64_t result;
  const char *v6;
  uint64_t v7;
  xmlAutomata *v8;
  xmlAutomataState *v9;
  xmlAutomataState *v10;
  xmlAutomata *v11;
  const xmlChar *v12;
  uint64_t v13;
  xmlAutomataState *v14;
  uint64_t v15;
  xmlAutomataState *v16;
  uint64_t v17;
  xmlAutomataState *v18;
  uint64_t v19;
  uint64_t v20;
  xmlAutomataState *v21;
  xmlAutomataState *v22;
  uint64_t v23;
  xmlAutomataState *v24;
  uint64_t v25;
  uint64_t v26;
  xmlAutomataPtr v27;
  xmlAutomataStatePtr v28;
  xmlAutomataState *v29;
  xmlAutomataStatePtr v30;
  uint64_t v31;
  uint64_t v32;
  xmlAutomataPtr v33;
  xmlAutomataStatePtr InitState;
  xmlAutomataState *v35;
  xmlRegexp *v36;
  __int128 v37;

  if (!a2)
    return 0xFFFFFFFFLL;
  v2 = a2;
  while (2)
  {
    v4 = *v2;
    switch(*v2)
    {
      case -1:
        v2 = (int *)*((_QWORD *)v2 + 6);
        if (!v2)
          return 0xFFFFFFFFLL;
        continue;
      case 0:
        v8 = *(xmlAutomata **)(a1 + 232);
        v9 = *(xmlAutomataState **)(a1 + 240);
        goto LABEL_55;
      case 1:
      case 2:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 19:
        if ((v4 - 1) > 0x12)
          v6 = "unknown";
        else
          v6 = off_1E6173FD8[v4 - 1];
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "RNG internal error trying to compile %s\n", v6);
        return 0;
      case 3:
        v10 = xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), *(xmlAutomataStatePtr *)(a1 + 240), 0);
        *(_QWORD *)(a1 + 240) = v10;
        xmlRelaxNGCompile(a1, *((_QWORD *)v2 + 6));
        xmlAutomataNewTransition(*(xmlAutomataPtr *)(a1 + 232), *(xmlAutomataStatePtr *)(a1 + 240), *(xmlAutomataStatePtr *)(a1 + 240), (const xmlChar *)"#text", 0);
        goto LABEL_30;
      case 4:
        v11 = *(xmlAutomata **)(a1 + 232);
        if (v11)
        {
          v12 = (const xmlChar *)*((_QWORD *)v2 + 2);
          if (v12)
            *(_QWORD *)(a1 + 240) = xmlAutomataNewTransition2(v11, *(xmlAutomataStatePtr *)(a1 + 240), 0, v12, *((const xmlChar **)v2 + 3), v2);
        }
        if ((*((_WORD *)v2 + 49) & 0x40) == 0)
        {
          v13 = *(_QWORD *)(a1 + 232);
LABEL_51:
          result = xmlRelaxNGTryCompile(a1, v2);
          *(_QWORD *)(a1 + 232) = v13;
          return result;
        }
        v13 = *(_QWORD *)(a1 + 232);
        if (*((__int16 *)v2 + 48) == -25)
          goto LABEL_51;
        v31 = *(_QWORD *)(a1 + 240);
        *((_WORD *)v2 + 48) = -25;
        v32 = *((_QWORD *)v2 + 6);
        v33 = xmlNewAutomata();
        *(_QWORD *)(a1 + 232) = v33;
        if (!v33)
          return 0xFFFFFFFFLL;
        xmlAutomataSetFlags((uint64_t)v33, 1);
        InitState = xmlAutomataGetInitState(*(xmlAutomataPtr *)(a1 + 232));
        *(_QWORD *)(a1 + 240) = InitState;
        if (v32)
        {
          do
          {
            xmlRelaxNGCompile(a1, v32);
            v32 = *(_QWORD *)(v32 + 64);
          }
          while (v32);
          v35 = *(xmlAutomataState **)(a1 + 240);
        }
        else
        {
          v35 = InitState;
        }
        xmlAutomataSetFinalState(*(xmlAutomataPtr *)(a1 + 232), v35);
        v36 = xmlAutomataCompile(*(xmlAutomataPtr *)(a1 + 232));
        *((_QWORD *)v2 + 13) = v36;
        if (!xmlRegexpIsDeterminist(v36))
        {
          xmlRegFreeRegexp(*((xmlRegexpPtr *)v2 + 13));
          *((_QWORD *)v2 + 13) = 0;
        }
        xmlFreeAutomata(*(xmlAutomataPtr *)(a1 + 232));
        result = 0;
        *(_QWORD *)(a1 + 232) = v13;
        *(_QWORD *)(a1 + 240) = v31;
        return result;
      case 10:
      case 11:
      case 12:
      case 13:
      case 18:
        v7 = *((_QWORD *)v2 + 6);
        if (!v7)
          return 0;
        while (1)
        {
          result = xmlRelaxNGCompile(a1, v7);
          if ((_DWORD)result)
            break;
          v7 = *(_QWORD *)(v7 + 64);
          if (!v7)
            return 0;
        }
        return result;
      case 14:
        v14 = *(xmlAutomataState **)(a1 + 240);
        v15 = *((_QWORD *)v2 + 6);
        v16 = v14;
        if (v15)
        {
          do
          {
            xmlRelaxNGCompile(a1, v15);
            v15 = *(_QWORD *)(v15 + 64);
          }
          while (v15);
          v16 = *(xmlAutomataState **)(a1 + 240);
        }
        xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), v14, v16);
        return 0;
      case 15:
        v10 = xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), *(xmlAutomataStatePtr *)(a1 + 240), 0);
        *(_QWORD *)(a1 + 240) = v10;
        v17 = *((_QWORD *)v2 + 6);
        v18 = v10;
        if (v17)
        {
          do
          {
            xmlRelaxNGCompile(a1, v17);
            v17 = *(_QWORD *)(v17 + 64);
          }
          while (v17);
          v18 = *(xmlAutomataState **)(a1 + 240);
        }
        xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), v18, v10);
LABEL_30:
        v8 = *(xmlAutomata **)(a1 + 232);
        v9 = v10;
        goto LABEL_55;
      case 16:
        v19 = *((_QWORD *)v2 + 6);
        if (!v19)
        {
          v21 = *(xmlAutomataState **)(a1 + 240);
LABEL_53:
          v22 = v21;
          goto LABEL_54;
        }
        do
        {
          xmlRelaxNGCompile(a1, v19);
          v19 = *(_QWORD *)(v19 + 64);
        }
        while (v19);
        v20 = *((_QWORD *)v2 + 6);
        v21 = *(xmlAutomataState **)(a1 + 240);
        if (!v20)
          goto LABEL_53;
        do
        {
          xmlRelaxNGCompile(a1, v20);
          v20 = *(_QWORD *)(v20 + 64);
        }
        while (v20);
        v22 = *(xmlAutomataState **)(a1 + 240);
LABEL_54:
        xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), v22, v21);
        v8 = *(xmlAutomata **)(a1 + 232);
        v9 = v21;
LABEL_55:
        v30 = xmlAutomataNewEpsilon(v8, v9, 0);
        result = 0;
        *(_QWORD *)(a1 + 240) = v30;
        return result;
      case 17:
        v23 = *((_QWORD *)v2 + 6);
        if (v23)
        {
          v24 = 0;
          v25 = *(_QWORD *)(a1 + 240);
          do
          {
            *(_QWORD *)(a1 + 240) = v25;
            result = xmlRelaxNGCompile(a1, v23);
            if ((_DWORD)result)
              goto LABEL_59;
            if (v24)
              xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), *(xmlAutomataStatePtr *)(a1 + 240), v24);
            else
              v24 = *(xmlAutomataState **)(a1 + 240);
            v23 = *(_QWORD *)(v23 + 64);
          }
          while (v23);
        }
        else
        {
          v24 = 0;
        }
        result = 0;
LABEL_59:
        *(_QWORD *)(a1 + 240) = v24;
        return result;
      case 20:
        if (xmlRelaxNGIsCompilable(v2) != 1 || *((__int16 *)v2 + 48) == -25)
          return 0;
        v37 = *(_OWORD *)(a1 + 232);
        *((_WORD *)v2 + 48) = -25;
        v26 = *((_QWORD *)v2 + 6);
        v27 = xmlNewAutomata();
        *(_QWORD *)(a1 + 232) = v27;
        if (!v27)
          return 0xFFFFFFFFLL;
        xmlAutomataSetFlags((uint64_t)v27, 1);
        v28 = xmlAutomataGetInitState(*(xmlAutomataPtr *)(a1 + 232));
        *(_QWORD *)(a1 + 240) = v28;
        if (v26)
        {
          do
          {
            xmlRelaxNGCompile(a1, v26);
            v26 = *(_QWORD *)(v26 + 64);
          }
          while (v26);
          v29 = *(xmlAutomataState **)(a1 + 240);
        }
        else
        {
          v29 = v28;
        }
        xmlAutomataSetFinalState(*(xmlAutomataPtr *)(a1 + 232), v29);
        if (xmlAutomataIsDeterminist(*(xmlAutomataPtr *)(a1 + 232)))
          *((_QWORD *)v2 + 13) = xmlAutomataCompile(*(xmlAutomataPtr *)(a1 + 232));
        xmlFreeAutomata(*(xmlAutomataPtr *)(a1 + 232));
        result = 0;
        *(_OWORD *)(a1 + 232) = v37;
        return result;
      default:
        return 0;
    }
  }
}

FILE *xmlRelaxNGDumpDefine(FILE *result, uint64_t a2)
{
  FILE *v3;
  xmlGenericErrorFunc v4;
  void *v5;
  xmlGenericErrorFunc v6;
  void *v7;
  uint64_t i;
  const char *v9;
  uint64_t j;
  uint64_t k;
  size_t v12;
  uint64_t m;
  uint64_t n;
  uint64_t ii;
  uint64_t jj;
  uint64_t kk;
  uint64_t mm;
  uint64_t nn;
  uint64_t i1;
  uint64_t i2;
  uint64_t i3;
  uint64_t i4;
  uint64_t i5;

  if (a2)
  {
    v3 = result;
    switch(*(_DWORD *)a2)
    {
      case 0xFFFFFFFF:
        for (i = *(_QWORD *)(a2 + 48); i; i = *(_QWORD *)(i + 64))
          result = (FILE *)xmlRelaxNGDumpDefine(v3, i);
        return result;
      case 0:
        v9 = "<empty/>\n";
        goto LABEL_63;
      case 1:
        v9 = "<notAllowed/>\n";
        goto LABEL_67;
      case 2:
      case 6:
      case 0x14:
        v4 = *__xmlGenericError();
        v5 = *__xmlGenericErrorContext();
        return (FILE *)((uint64_t (*)(void *, const char *, ...))v4)(v5, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 7849);
      case 3:
        v9 = "<text/>\n";
        goto LABEL_24;
      case 4:
        fwrite("<element>\n", 0xAuLL, 1uLL, result);
        if (*(_QWORD *)(a2 + 16))
        {
          fwrite("<name", 5uLL, 1uLL, v3);
          if (*(_QWORD *)(a2 + 24))
            fprintf(v3, " ns=\"%s\"", *(const char **)(a2 + 24));
          fprintf(v3, ">%s</name>\n", *(const char **)(a2 + 16));
        }
        for (j = *(_QWORD *)(a2 + 72); j; j = *(_QWORD *)(j + 64))
          xmlRelaxNGDumpDefine(v3, j);
        for (k = *(_QWORD *)(a2 + 48); k; k = *(_QWORD *)(k + 64))
          xmlRelaxNGDumpDefine(v3, k);
        v9 = "</element>\n";
        v12 = 11;
        goto LABEL_68;
      case 5:
      case 7:
        v6 = *__xmlGenericError();
        v7 = *__xmlGenericErrorContext();
        return (FILE *)((uint64_t (*)(void *, const char *, ...))v6)(v7, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 7845);
      case 8:
        fwrite("<list>\n", 7uLL, 1uLL, result);
        for (m = *(_QWORD *)(a2 + 48); m; m = *(_QWORD *)(m + 64))
          xmlRelaxNGDumpDefine(v3, m);
        v9 = "</list>\n";
LABEL_24:
        v12 = 8;
        goto LABEL_68;
      case 9:
        fwrite("<attribute>\n", 0xCuLL, 1uLL, result);
        for (n = *(_QWORD *)(a2 + 48); n; n = *(_QWORD *)(n + 64))
          xmlRelaxNGDumpDefine(v3, n);
        v9 = "</attribute>\n";
        goto LABEL_55;
      case 0xA:
        fwrite("<define", 7uLL, 1uLL, result);
        if (*(_QWORD *)(a2 + 16))
          fprintf(v3, " name=\"%s\"", *(const char **)(a2 + 16));
        fwrite(">\n", 2uLL, 1uLL, v3);
        for (ii = *(_QWORD *)(a2 + 48); ii; ii = *(_QWORD *)(ii + 64))
          xmlRelaxNGDumpDefine(v3, ii);
        v9 = "</define>\n";
        goto LABEL_59;
      case 0xB:
        fwrite("<ref", 4uLL, 1uLL, result);
        if (*(_QWORD *)(a2 + 16))
          fprintf(v3, " name=\"%s\"", *(const char **)(a2 + 16));
        fwrite(">\n", 2uLL, 1uLL, v3);
        for (jj = *(_QWORD *)(a2 + 48); jj; jj = *(_QWORD *)(jj + 64))
          xmlRelaxNGDumpDefine(v3, jj);
        v9 = "</ref>\n";
        v12 = 7;
        goto LABEL_68;
      case 0xC:
        fwrite("<externalRef>", 0xDuLL, 1uLL, result);
        for (kk = *(_QWORD *)(a2 + 48); kk; kk = *(_QWORD *)(kk + 64))
          xmlRelaxNGDumpDefine(v3, kk);
        v9 = "</externalRef>\n";
        v12 = 15;
        goto LABEL_68;
      case 0xD:
        fwrite("<parentRef", 0xAuLL, 1uLL, result);
        if (*(_QWORD *)(a2 + 16))
          fprintf(v3, " name=\"%s\"", *(const char **)(a2 + 16));
        fwrite(">\n", 2uLL, 1uLL, v3);
        for (mm = *(_QWORD *)(a2 + 48); mm; mm = *(_QWORD *)(mm + 64))
          xmlRelaxNGDumpDefine(v3, mm);
        v9 = "</parentRef>\n";
        goto LABEL_55;
      case 0xE:
        fwrite("<optional>\n", 0xBuLL, 1uLL, result);
        for (nn = *(_QWORD *)(a2 + 48); nn; nn = *(_QWORD *)(nn + 64))
          xmlRelaxNGDumpDefine(v3, nn);
        v9 = "</optional>\n";
        v12 = 12;
        goto LABEL_68;
      case 0xF:
        fwrite("<zeroOrMore>\n", 0xDuLL, 1uLL, result);
        for (i1 = *(_QWORD *)(a2 + 48); i1; i1 = *(_QWORD *)(i1 + 64))
          xmlRelaxNGDumpDefine(v3, i1);
        v9 = "</zeroOrMore>\n";
        goto LABEL_67;
      case 0x10:
        fwrite("<oneOrMore>\n", 0xCuLL, 1uLL, result);
        for (i2 = *(_QWORD *)(a2 + 48); i2; i2 = *(_QWORD *)(i2 + 64))
          xmlRelaxNGDumpDefine(v3, i2);
        v9 = "</oneOrMore>\n";
LABEL_55:
        v12 = 13;
        goto LABEL_68;
      case 0x11:
        fwrite("<choice>\n", 9uLL, 1uLL, result);
        for (i3 = *(_QWORD *)(a2 + 48); i3; i3 = *(_QWORD *)(i3 + 64))
          xmlRelaxNGDumpDefine(v3, i3);
        v9 = "</choice>\n";
LABEL_59:
        v12 = 10;
        goto LABEL_68;
      case 0x12:
        fwrite("<group>\n", 8uLL, 1uLL, result);
        for (i4 = *(_QWORD *)(a2 + 48); i4; i4 = *(_QWORD *)(i4 + 64))
          xmlRelaxNGDumpDefine(v3, i4);
        v9 = "</group>\n";
LABEL_63:
        v12 = 9;
        goto LABEL_68;
      case 0x13:
        fwrite("<interleave>\n", 0xDuLL, 1uLL, result);
        for (i5 = *(_QWORD *)(a2 + 48); i5; i5 = *(_QWORD *)(i5 + 64))
          xmlRelaxNGDumpDefine(v3, i5);
        v9 = "</interleave>\n";
LABEL_67:
        v12 = 14;
LABEL_68:
        result = (FILE *)fwrite(v9, v12, 1uLL, v3);
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t xmlRelaxNGValidateAttributeList(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  if (!a2)
    return 0;
  v2 = a2;
  v4 = 0;
  v5 = 0;
  v6 = a2;
  do
  {
    if (*(_DWORD *)v6 == 9)
    {
      if (xmlRelaxNGValidateAttribute(a1, v6))
        v5 = 0xFFFFFFFFLL;
      else
        v5 = v5;
    }
    else
    {
      v4 = 1;
    }
    v6 = *(_QWORD *)(v6 + 64);
  }
  while (v6);
  if (v4)
  {
    do
    {
      if (*(_DWORD *)v2 != 9)
      {
        if (!*(_QWORD *)(a1 + 96) && !*(_QWORD *)(a1 + 104))
        {
          xmlRelaxNGAddValidError(a1, 6, 0, 0, 0);
          return 0xFFFFFFFFLL;
        }
        v7 = xmlRelaxNGValidateDefinition(a1, v2);
        if (v7 < 0)
          v5 = 0xFFFFFFFFLL;
        else
          v5 = v5;
        if (v7 == -1)
          return v5;
      }
      v2 = *(_QWORD *)(v2 + 64);
    }
    while (v2);
  }
  return v5;
}

uint64_t xmlRelaxNGValidateElementEnd(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(v4 + 8);
  if (v5 && (v6 = xmlRelaxNGSkipIgnored(a1, v5), (*(_QWORD *)(v4 + 8) = v6) != 0))
  {
    if (a2)
      xmlRelaxNGAddValidError(a1, 26, *(xmlChar **)(*(_QWORD *)v4 + 16), *(xmlChar **)(v6 + 16), 0);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v8 = *(unsigned int *)(v4 + 16);
    if ((int)v8 < 1)
    {
      return 0;
    }
    else
    {
      v9 = *(_QWORD *)(v4 + 48);
      v7 = 0xFFFFFFFFLL;
      while (!*(_QWORD *)v9)
      {
        v7 = (v7 - 1);
        v9 += 8;
        if (!--v8)
          return 0;
      }
      if (a2)
        xmlRelaxNGAddValidError(a1, 27, *(xmlChar **)(*(_QWORD *)v9 + 16), *(xmlChar **)(*(_QWORD *)v4 + 16), 0);
    }
  }
  return v7;
}

uint64_t xmlRelaxNGLogBestError(uint64_t result)
{
  unsigned int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  int v10;

  v1 = *(unsigned int **)(result + 104);
  if (v1)
  {
    v2 = *v1;
    if ((int)v2 >= 1)
    {
      v3 = 0;
      v4 = *((_QWORD *)v1 + 1);
      v5 = -1;
      v6 = 1000000;
      do
      {
        v7 = *(_QWORD *)(v4 + 8 * v3);
        if (v7)
        {
          if (*(_QWORD *)(v7 + 8))
          {
            if (v5 == -1 || v6 > 100000)
            {
              v5 = v3;
              v6 = 100000;
            }
          }
          else
          {
            v10 = *(_DWORD *)(v7 + 24);
            if (v5 == -1 || v6 > v10)
            {
              v5 = v3;
              v6 = v10;
            }
          }
        }
        ++v3;
      }
      while (v2 != v3);
      if ((v5 & 0x80000000) == 0 && v5 < (int)v2)
      {
        *(_QWORD *)(result + 96) = *(_QWORD *)(v4 + 8 * v5);
        return xmlRelaxNGValidateElementEnd(result, 1);
      }
    }
  }
  return result;
}

uint64_t xmlRelaxNGValidateAttribute(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v5;
  uint64_t i;
  uint64_t v7;
  const xmlChar *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  xmlChar *String;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  xmlChar *v20;
  xmlChar *v21;

  v2 = *(_QWORD *)(a1 + 96);
  if (*(int *)(v2 + 24) < 1)
    return 0xFFFFFFFFLL;
  v5 = *(_DWORD *)(v2 + 16);
  if (*(_QWORD *)(a2 + 16))
  {
    if (v5 >= 1)
    {
      for (i = 0; i < *(int *)(v2 + 16); ++i)
      {
        v7 = *(_QWORD *)(*(_QWORD *)(v2 + 48) + 8 * i);
        if (!v7 || !xmlStrEqual(*(const xmlChar **)(a2 + 16), *(const xmlChar **)(v7 + 16)))
          goto LABEL_13;
        v8 = *(const xmlChar **)(a2 + 24);
        if (v8 && *v8)
        {
          v9 = *(_QWORD *)(v7 + 72);
          if (!v9)
            goto LABEL_13;
        }
        else
        {
          v9 = *(_QWORD *)(v7 + 72);
          if (!v9)
            goto LABEL_23;
        }
        if (xmlStrEqual(v8, *(const xmlChar **)(v9 + 16)))
        {
LABEL_23:
          String = xmlNodeListGetString(*(xmlDocPtr *)(v7 + 64), *(const xmlNode **)(v7 + 24), 1);
          v15 = *(_QWORD **)(a1 + 96);
          v16 = v15[4];
          v17 = v15[1];
          v15[1] = v7;
          v15[4] = String;
          v15[5] = 0;
          v18 = *(_QWORD *)(a2 + 48);
          if (v18)
          {
            do
            {
              v12 = xmlRelaxNGValidateValue(a1, v18);
              if ((_DWORD)v12)
                break;
              v18 = *(_QWORD *)(v18 + 64);
            }
            while (v18);
            goto LABEL_30;
          }
LABEL_31:
          v12 = 0;
          v20 = String;
          goto LABEL_32;
        }
LABEL_13:
        v2 = *(_QWORD *)(a1 + 96);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (v5 < 1)
    return 0xFFFFFFFFLL;
  i = 0;
  while (1)
  {
    v10 = *(_QWORD *)(v2 + 48);
    v11 = *(_QWORD *)(v10 + 8 * i);
    if (v11)
      break;
LABEL_20:
    if (++i >= *(int *)(v2 + 16))
      return 0xFFFFFFFFLL;
  }
  if (xmlRelaxNGAttributeMatch((_QWORD *)a2, *(_QWORD *)(v10 + 8 * i)) != 1)
  {
    v2 = *(_QWORD *)(a1 + 96);
    goto LABEL_20;
  }
  String = xmlNodeListGetString(*(xmlDocPtr *)(v11 + 64), *(const xmlNode **)(v11 + 24), 1);
  v15 = *(_QWORD **)(a1 + 96);
  v16 = v15[4];
  v17 = v15[1];
  v15[1] = v11;
  v15[4] = String;
  v19 = *(_QWORD *)(a2 + 48);
  if (!v19)
    goto LABEL_31;
  do
  {
    v12 = xmlRelaxNGValidateValue(a1, v19);
    if ((_DWORD)v12)
      break;
    v19 = *(_QWORD *)(v19 + 64);
  }
  while (v19);
LABEL_30:
  v15 = *(_QWORD **)(a1 + 96);
  v20 = (xmlChar *)v15[4];
LABEL_32:
  if (v20)
    v21 = v20;
  else
    v21 = String;
  if (v21)
  {
    xmlFree(v21);
    v15 = *(_QWORD **)(a1 + 96);
  }
  v15[4] = v16;
  v15[1] = v17;
  if (!(_DWORD)v12)
  {
    v12 = 0;
    *(_QWORD *)(v15[6] + 8 * i) = 0;
    --*(_DWORD *)(*(_QWORD *)(a1 + 96) + 24);
  }
  return v12;
}

uint64_t xmlRelaxNGAttributeMatch(_QWORD *a1, uint64_t a2)
{
  const xmlChar *v4;
  uint64_t result;
  const xmlChar *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  xmlGenericErrorFunc v11;
  void **v12;

  v4 = (const xmlChar *)a1[2];
  if (v4)
  {
    result = xmlStrEqual(v4, *(const xmlChar **)(a2 + 16));
    if (!(_DWORD)result)
      return result;
  }
  v6 = (const xmlChar *)a1[3];
  if (v6)
  {
    v7 = *(_QWORD *)(a2 + 72);
    if (*v6)
    {
      if (!v7)
        return 0;
      result = xmlStrEqual(v6, *(const xmlChar **)(v7 + 16));
      if (!(_DWORD)result)
        return result;
    }
    else if (v7)
    {
      return 0;
    }
  }
  v8 = a1[10];
  if (!v8)
    return 1;
  if (*(_DWORD *)v8 != 17)
  {
    if (*(_DWORD *)v8 == 2)
    {
      v9 = *(_QWORD *)(v8 + 48);
      if (v9)
      {
        while (xmlRelaxNGAttributeMatch(v9, a2) != 1)
        {
          v9 = *(_QWORD *)(v9 + 64);
          if (!v9)
            return 1;
        }
        return 0;
      }
    }
    else
    {
      v11 = *__xmlGenericError();
      v12 = __xmlGenericErrorContext();
      v11(*v12, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 9117);
    }
    return 1;
  }
  v10 = *(_QWORD *)(v8 + 80);
  if (!v10)
    return 0;
  while (1)
  {
    result = xmlRelaxNGAttributeMatch(v10, a2);
    if ((_DWORD)result == 1)
      break;
    v10 = *(_QWORD *)(v10 + 64);
    if (!v10)
      return 0;
  }
  return result;
}

uint64_t xmlRelaxNGValidateValue(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  xmlChar *v7;
  uint64_t v8;
  unsigned int v9;
  unsigned __int8 *i;
  unsigned int v11;
  xmlGenericErrorFunc v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  xmlChar *v18;
  xmlChar *v19;
  unsigned int v20;
  unsigned int v21;
  BOOL v22;
  uint64_t v23;
  BOOL v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  xmlChar *v36;
  int v37;
  int v38;
  xmlChar *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v43;
  uint64_t (*v44)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, unsigned __int8 *, _QWORD);
  int v45;
  uint64_t v46;
  xmlChar *v47;
  const xmlChar *v48;
  xmlChar *v49;
  int v50;

  v3 = a1;
  while (2)
  {
    v4 = *(_QWORD *)(a1 + 96);
    v5 = *(unsigned __int8 **)(v4 + 32);
    switch(*(_DWORD *)a2)
    {
      case 0:
        if (!v5)
          return 0;
        v9 = *v5;
        if (!*v5)
          return 0;
        for (i = v5 + 1; ; ++i)
        {
          if (v9 > 0x20)
            return 0xFFFFFFFFLL;
          if (((1 << v9) & 0x100002600) == 0)
            break;
          v11 = *i;
          v9 = v11;
        }
        if (!v9)
          return 0;
        return 0xFFFFFFFFLL;
      case 2:
        v15 = *(_QWORD *)(a2 + 48);
        if (!v15)
          return 0;
        v14 = 0;
        while (xmlRelaxNGValidateValue(v3))
        {
          v15 = *(_QWORD *)(v15 + 64);
          if (!v15)
            return v14;
        }
        return 0xFFFFFFFFLL;
      case 3:
        return 0;
      case 5:
        v14 = xmlRelaxNGValidateDatatype(a1, *(xmlChar **)(v4 + 32), a2, *(_QWORD *)(v4 + 8));
        if (!(_DWORD)v14)
          xmlRelaxNGNextValue(v3);
        return v14;
      case 7:
        if (xmlStrEqual(*(const xmlChar **)(v4 + 32), *(const xmlChar **)(a2 + 32)))
          goto LABEL_27;
        v7 = *(xmlChar **)(a2 + 16);
        if (v7)
        {
          v43 = *(_QWORD *)(a2 + 40);
          if (v43)
          {
            v44 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, unsigned __int8 *, _QWORD))(v43 + 32);
            if (v44)
            {
              v45 = v44(*(_QWORD *)(v43 + 8), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 72), v5, **(_QWORD **)(v3 + 96));
              if ((v45 & 0x80000000) == 0)
              {
                if (v45 == 1)
                {
LABEL_27:
                  xmlRelaxNGNextValue(v3);
                  return 0;
                }
                return 0xFFFFFFFFLL;
              }
              v7 = *(xmlChar **)(a2 + 16);
            }
          }
          a1 = v3;
          v6 = 5;
          goto LABEL_6;
        }
        v47 = xmlRelaxNGNormalize(v3, *(_BYTE **)(a2 + 32));
        v48 = xmlRelaxNGNormalize(v3, v5);
        v49 = (xmlChar *)v48;
        if (v47 && v48)
        {
          if (xmlStrEqual(v47, v48))
            v50 = 0;
          else
            v50 = -1;
        }
        else
        {
          v50 = -1;
          if (!v47)
            goto LABEL_103;
        }
        xmlFree(v47);
LABEL_103:
        if (v49)
          xmlFree(v49);
        if (!v50)
          goto LABEL_27;
        return 0xFFFFFFFFLL;
      case 8:
        v16 = *(_QWORD *)(a2 + 48);
        v17 = *(_QWORD *)(v4 + 40);
        v18 = xmlStrdup(*(const xmlChar **)(v4 + 32));
        if (v18 || (v18 = xmlStrdup((const xmlChar *)&byte_1B0865C1A)) != 0)
        {
          v19 = v18;
          while (1)
          {
            v20 = *v19;
            if (v20 > 0x20)
              goto LABEL_40;
            if (((1 << v20) & 0x100002600) != 0)
            {
              do
              {
                *v19++ = 0;
                v21 = *v19;
                v22 = v21 > 0x20;
                v23 = (1 << v21) & 0x100002600;
                v24 = v22 || v23 == 0;
              }
              while (!v24);
            }
            else
            {
              if (!*v19)
              {
                v35 = *(_QWORD *)(v3 + 96);
                *(_QWORD *)(v35 + 40) = v19;
                v36 = v18;
                do
                {
                  v24 = v36 == v19;
                  v38 = *v36++;
                  v37 = v38;
                }
                while (!v24 && !v37);
                v39 = v36 - 1;
                *(_QWORD *)(v35 + 32) = v36 - 1;
                if (v16)
                {
                  do
                  {
                    v40 = *(_QWORD *)(v3 + 96);
                    if (*(_QWORD *)(v40 + 32) == *(_QWORD *)(v40 + 40))
                      *(_QWORD *)(v40 + 32) = 0;
                    v41 = xmlRelaxNGValidateValue(v3);
                    if ((_DWORD)v41)
                    {
                      v14 = v41;
                      goto LABEL_94;
                    }
                    v16 = *(_QWORD *)(v16 + 64);
                  }
                  while (v16);
                  v35 = *(_QWORD *)(v3 + 96);
                  v39 = *(xmlChar **)(v35 + 32);
                  if (v39)
                    goto LABEL_74;
LABEL_92:
                  v14 = 0;
                }
                else
                {
LABEL_74:
                  if (v39 == *(xmlChar **)(v35 + 40))
                    goto LABEL_92;
                  xmlRelaxNGAddValidError(v3, 8, v39, 0, 0);
                  v14 = 0xFFFFFFFFLL;
                }
LABEL_94:
                xmlFree(v18);
                v46 = *(_QWORD *)(v3 + 96);
                *(_QWORD *)(v46 + 32) = v5;
                *(_QWORD *)(v46 + 40) = v17;
                return v14;
              }
LABEL_40:
              ++v19;
            }
          }
        }
        a1 = v3;
        v6 = 6;
LABEL_5:
        v7 = 0;
LABEL_6:
        xmlRelaxNGAddValidError(a1, v6, v7, 0, 0);
        return 0xFFFFFFFFLL;
      case 0xA:
      case 0x12:
        v8 = *(_QWORD *)(a2 + 48);
        if (!v8)
          return 0;
        while (!xmlRelaxNGValidateValue(v3))
        {
          v8 = *(_QWORD *)(v8 + 64);
          if (!v8)
            return 0;
        }
        return 0xFFFFFFFFLL;
      case 0xB:
      case 0xD:
        a2 = *(_QWORD *)(a2 + 48);
        if (a2)
          continue;
        v6 = 7;
        goto LABEL_5;
      case 0xE:
        if (!v5 || !*v5)
          return 0;
        v25 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v25 | 1;
        v26 = xmlRelaxNGValidateValue(a1);
        *(_DWORD *)(v3 + 56) = v25;
        if (v26)
          *(_QWORD *)(*(_QWORD *)(v3 + 96) + 32) = v5;
        goto LABEL_79;
      case 0xF:
        goto LABEL_49;
      case 0x10:
        v27 = *(_QWORD *)(a2 + 48);
        if (!v27)
          goto LABEL_49;
        do
        {
          v28 = xmlRelaxNGValidateValue(v3);
          if ((_DWORD)v28)
            return v28;
          v27 = *(_QWORD *)(v27 + 64);
        }
        while (v27);
        v4 = *(_QWORD *)(v3 + 96);
        v5 = *(unsigned __int8 **)(v4 + 32);
LABEL_49:
        if (!v5 || !*v5)
          return 0;
        v29 = 0;
        v30 = *(_DWORD *)(v3 + 56);
        *(_DWORD *)(v3 + 56) = v30 | 1;
        do
        {
          if (v29 == v5)
            break;
          v29 = v5;
          if (v5 == *(unsigned __int8 **)(v4 + 40))
            break;
          v31 = *(_QWORD *)(a2 + 48);
          if (v31)
          {
            while (!xmlRelaxNGValidateValue(v3))
            {
              v31 = *(_QWORD *)(v31 + 64);
              if (!v31)
              {
                v4 = *(_QWORD *)(v3 + 96);
                goto LABEL_58;
              }
            }
            *(_QWORD *)(*(_QWORD *)(v3 + 96) + 32) = v29;
            break;
          }
LABEL_58:
          v5 = *(unsigned __int8 **)(v4 + 32);
        }
        while (v5);
        *(_DWORD *)(v3 + 56) = v30;
        goto LABEL_79;
      case 0x11:
        v32 = *(_QWORD *)(a2 + 48);
        v33 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v33 | 1;
        if (!v32)
          goto LABEL_76;
        while (1)
        {
          v34 = xmlRelaxNGValidateValue(v3);
          if (!(_DWORD)v34)
            break;
          *(_QWORD *)(*(_QWORD *)(v3 + 96) + 32) = v5;
          v32 = *(_QWORD *)(v32 + 64);
          if (!v32)
          {
            v14 = v34;
            *(_DWORD *)(v3 + 56) = v33;
            if ((v33 & 1) == 0)
              xmlRelaxNGDumpValidError(v3);
            return v14;
          }
        }
LABEL_76:
        *(_DWORD *)(v3 + 56) = v33;
LABEL_79:
        if (*(int *)(v3 + 80) >= 1)
          xmlRelaxNGPopErrors(v3, 0);
        return 0;
      default:
        v12 = *__xmlGenericError();
        v13 = __xmlGenericErrorContext();
        v12(*v13, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 9029);
        return 0xFFFFFFFFLL;
    }
  }
}

uint64_t xmlRelaxNGNextValue(uint64_t result)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;

  v1 = *(_QWORD *)(result + 96);
  v4 = *(_QWORD *)(v1 + 32);
  v2 = (_QWORD *)(v1 + 32);
  v3 = v4;
  if (v4 && (v5 = *(_BYTE **)(*(_QWORD *)(result + 96) + 40)) != 0)
  {
    v6 = (_BYTE *)(v3 - 1);
    while (*++v6)
      ;
    while (1)
    {
      if (v6 == v5)
      {
        *v2 = 0;
        return result;
      }
      if (*v6)
        break;
      ++v6;
    }
    *v2 = v6;
  }
  else
  {
    *v2 = 0;
    v2[1] = 0;
  }
  return result;
}

uint64_t xmlRelaxNGValidateDatatype(uint64_t a1, xmlChar *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t (*v7)(uint64_t, uint64_t, xmlChar *, uint64_t *, uint64_t);
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  xmlChar *v14;
  int v15;
  uint64_t v16;
  void (*v17)(_QWORD);
  uint64_t v19;
  unsigned int (*v20)(_QWORD, _QWORD, _QWORD, _QWORD, xmlChar *, uint64_t);
  uint64_t v21;
  void (*v22)(_QWORD);
  __int128 v23;
  uint64_t v24;

  v24 = 0;
  if (!a3)
    return 0xFFFFFFFFLL;
  v5 = *(_QWORD **)(a3 + 40);
  if (!v5)
    return 0xFFFFFFFFLL;
  v7 = (uint64_t (*)(uint64_t, uint64_t, xmlChar *, uint64_t *, uint64_t))v5[3];
  if (!v7)
    goto LABEL_12;
  v10 = *(_DWORD **)(a3 + 72);
  if (v10 && *v10 == 6)
  {
    v11 = v5[1];
    v12 = *(_QWORD *)(a3 + 16);
    v13 = &v24;
    v14 = a2;
  }
  else
  {
    v11 = v5[1];
    v12 = *(_QWORD *)(a3 + 16);
    v14 = a2;
    v13 = 0;
  }
  v15 = v7(v11, v12, v14, v13, a4);
  if (v15 < 0)
  {
LABEL_12:
    xmlRelaxNGAddValidError(a1, 2, *(xmlChar **)(a3 + 16), 0, 0);
    if (v24)
    {
      v17 = (void (*)(_QWORD))v5[6];
      if (v17)
        v17(v5[1]);
    }
    return 0xFFFFFFFFLL;
  }
  if (v15 == 1)
  {
    v19 = *(_QWORD *)(a3 + 72);
    if (v19)
    {
      while (*(_DWORD *)v19 == 6)
      {
        v20 = (unsigned int (*)(_QWORD, _QWORD, _QWORD, _QWORD, xmlChar *, uint64_t))v5[5];
        if (v20)
        {
          if (v20(v5[1], *(_QWORD *)(a3 + 16), *(_QWORD *)(v19 + 16), *(_QWORD *)(v19 + 32), a2, v24))
            v16 = 0xFFFFFFFFLL;
          else
            v16 = 0;
          if ((_DWORD)v16)
          {
LABEL_27:
            if ((_DWORD)v16)
              goto LABEL_32;
            break;
          }
        }
        else
        {
          v16 = 0;
        }
        v19 = *(_QWORD *)(v19 + 64);
        if (!v19)
          goto LABEL_27;
      }
    }
    if (*(_QWORD *)(a3 + 48))
    {
      v21 = *(_QWORD *)(a1 + 96);
      v23 = *(_OWORD *)(v21 + 32);
      *(_QWORD *)(v21 + 32) = a2;
      *(_QWORD *)(v21 + 40) = 0;
      v16 = xmlRelaxNGValidateValue(a1);
      *(_OWORD *)(*(_QWORD *)(a1 + 96) + 32) = v23;
    }
    else
    {
      v16 = 0;
    }
  }
  else if (v15 == 2)
  {
    xmlRelaxNGAddValidError(a1, 4, a2, 0, 1);
    v16 = 2;
  }
  else
  {
    xmlRelaxNGAddValidError(a1, 3, *(xmlChar **)(a3 + 16), a2, 1);
    v16 = 0xFFFFFFFFLL;
  }
LABEL_32:
  if (v24)
  {
    v22 = (void (*)(_QWORD))v5[6];
    if (v22)
      v22(v5[1]);
  }
  return v16;
}

uint64_t xmlRelaxNGSkipIgnored(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  int v3;
  _BYTE *v4;
  unsigned int v5;

  for (; a2; a2 = *(_QWORD *)(a2 + 48))
  {
    v2 = *(_DWORD *)(a2 + 8);
    if (v2 > 0x14)
      break;
    v3 = 1 << v2;
    if ((v3 & 0x180180) == 0)
    {
      if ((v3 & 0x18) == 0)
        return a2;
      if ((*(_BYTE *)(a1 + 56) & 4) == 0)
      {
        v4 = *(_BYTE **)(a2 + 80);
        if (v4)
        {
          while (1)
          {
            v5 = *v4;
            if (v5 > 0x20)
              return a2;
            if (((1 << v5) & 0x100002600) == 0)
            {
              if (*v4)
                return a2;
              break;
            }
            ++v4;
          }
        }
      }
    }
  }
  return a2;
}

_QWORD *xmlRelaxNGNewStates(uint64_t a1, int a2)
{
  uint64_t v3;
  int v4;
  BOOL v5;
  int v6;
  _QWORD *v7;
  unsigned int v8;
  _DWORD *v9;
  void *v10;

  v3 = *(_QWORD *)(a1 + 128);
  if (!v3 || (v4 = *(_DWORD *)(a1 + 120), v5 = __OFSUB__(v4, 1), v6 = v4 - 1, (v6 < 0) ^ v5))
  {
    if (a2 <= 16)
      v8 = 16;
    else
      v8 = a2;
    v9 = xmlMalloc(8 * (v8 - 1) + 16);
    v7 = v9;
    if (v9)
    {
      *v9 = 0;
      v9[1] = v8;
      v10 = xmlMalloc(8 * v8);
      v7[1] = v10;
      if (!v10)
      {
        xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
        xmlFree(v7);
        return 0;
      }
    }
    else
    {
      xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
    }
  }
  else
  {
    *(_DWORD *)(a1 + 120) = v6;
    v7 = *(_QWORD **)(v3 + 8 * v6);
    *(_DWORD *)v7 = 0;
  }
  return v7;
}

uint64_t xmlRelaxNGValidateState(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __int128 *v4;
  __int128 **v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  xmlGenericErrorFunc v10;
  void **v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  const xmlChar **v20;
  int v21;
  int v22;
  __int128 *v23;
  __int128 *v24;
  uint64_t v25;
  xmlChar *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  xmlChar *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int128 *v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  _QWORD *v47;
  int v48;
  int *v49;
  int *v50;
  _QWORD *v51;
  uint64_t v52;
  int v53;
  xmlHashTable *v54;
  uint64_t v55;
  int v56;
  const char *v57;
  int *v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  _QWORD **v63;
  _DWORD *v64;
  __int128 *v65;
  uint64_t v66;
  int v67;
  int **v68;
  int *v69;
  int *v70;
  uint64_t v71;
  _QWORD *v72;
  _QWORD *v73;
  _QWORD *v74;
  _QWORD *v75;
  __int128 *v76;
  uint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  int *v80;
  xmlHashTable *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  const char *v87;
  void *v88;
  int *v89;
  int v90;
  uint64_t v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const xmlChar *v96;
  const xmlChar *v97;
  xmlChar *v98;
  uint64_t v99;
  int v100;
  int *v101;
  int v102;
  xmlChar *v103;
  int *v104;
  uint64_t v105;
  _QWORD *v106;
  int *v107;
  int *v108;
  uint64_t v109;
  int v110;
  int v111;
  int v112;
  uint64_t v113;
  int v114;
  int *v115;
  uint64_t v116;
  int v117;
  uint64_t v118;
  int v119;
  int *v120;
  uint64_t v121;
  int v122;
  int v123;
  uint64_t v124;
  _QWORD *v125;
  uint64_t v126;
  int v127;
  xmlChar *v128;
  uint64_t v129;
  int v130;
  int *v131;
  uint64_t v132;
  const xmlChar *v133;
  const xmlChar *v134;
  xmlHashTable *v135;
  const xmlChar **v136;
  int v137;
  uint64_t v139;
  uint64_t v140;
  __int128 *v141;
  _QWORD *v142;
  _QWORD *v143;
  uint64_t v144;
  int v145;
  uint64_t v146;
  void **v147;
  uint64_t v148;
  uint64_t v149;
  int v150;
  _QWORD *v151;
  int v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int *v160;
  uint64_t v161;
  int *v162;
  int v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  char v167;
  __int128 *v168;
  int v169;
  _QWORD *v170;
  int v171;
  uint64_t v172;
  int *v173;
  uint64_t v174;
  uint64_t v175;
  char v176;
  uint64_t v177;
  uint64_t v178;
  int v179;
  int v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  __int128 *v184;
  int *v185;
  uint64_t v186;
  xmlChar *v187;
  int *v188;
  uint64_t v189;
  uint64_t v190;
  char v191;
  char v192;
  uint64_t v193;
  int v194;
  uint64_t v195;
  uint64_t v196;
  _QWORD *v197;
  uint64_t v198;
  __int128 *v199;
  uint64_t v200;
  int v201;
  _QWORD *v202;
  uint64_t v203;
  int v204;
  __int128 v205;
  int *v206;
  __int128 v207;

  v2 = a1;
  if (a2)
  {
    v5 = (__int128 **)(a1 + 96);
    v4 = *(__int128 **)(a1 + 96);
    if (v4)
      v6 = *((_QWORD *)v4 + 1);
    else
      v6 = 0;
    v7 = 0;
    ++*(_DWORD *)(a1 + 60);
    switch(*(_DWORD *)a2)
    {
      case 0xFFFFFFFF:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0x14:
        v8 = *(void **)(a2 + 48);
        goto LABEL_8;
      case 1:
        goto LABEL_251;
      case 2:
      case 6:
        v10 = *__xmlGenericError();
        v11 = __xmlGenericErrorContext();
        v10(*v11, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10628);
        goto LABEL_251;
      case 3:
        for (; v6; v6 = *(_QWORD *)(v6 + 48))
        {
          v12 = *(_DWORD *)(v6 + 8);
          v13 = v12 > 8;
          v14 = (1 << v12) & 0x198;
          if (v13 || v14 == 0)
            break;
        }
        v7 = 0;
        *((_QWORD *)v4 + 1) = v6;
        goto LABEL_252;
      case 4:
        v7 = *(unsigned int *)(a1 + 80);
        v16 = xmlRelaxNGSkipIgnored(a1, v6);
        if (v16)
        {
          v17 = v16;
          if (*(_DWORD *)(v16 + 8) == 1)
          {
            if (*(_QWORD *)(v16 + 104) != a2)
            {
              if ((int)xmlRelaxNGElementMatch(v2, (_QWORD *)a2, v16) > 0)
              {
                v18 = *(_DWORD *)(v2 + 80);
                if (v18)
                {
                  if (v18 > (int)v7)
                    xmlRelaxNGPopErrors(v2, v7);
                  while (1)
                  {
                    v20 = *(const xmlChar ***)(v2 + 72);
                    if (!v20)
                      break;
                    v19 = *(_DWORD *)v20;
                    if (*(_DWORD *)v20 == 13)
                    {
                      if (xmlStrEqual(v20[4], *(const xmlChar **)(v17 + 16)))
                        goto LABEL_32;
                      v20 = *(const xmlChar ***)(v2 + 72);
                      v19 = *(_DWORD *)v20;
                    }
                    if (v19 == 19)
                    {
                      if (xmlStrEqual(v20[3], *(const xmlChar **)(v17 + 16)))
                        goto LABEL_32;
                      v19 = **(_DWORD **)(v2 + 72);
                    }
                    if ((v19 & 0xFFFFFFFE) != 0x16)
                      break;
LABEL_32:
                    xmlRelaxNGValidErrorPop(v2);
                  }
                }
                v21 = *(_DWORD *)(v2 + 56);
                if ((v21 & 4) != 0)
                  *(_DWORD *)(v2 + 56) = v21 - 4;
                v22 = *(_DWORD *)(v2 + 80);
                v23 = (__int128 *)xmlRelaxNGNewValidState(v2, v17);
                if (v23)
                {
                  v24 = *v5;
                  *v5 = v23;
                  v25 = *(_QWORD *)(a2 + 72);
                  if (v25 && xmlRelaxNGValidateAttributeList(v2, v25))
                  {
                    xmlRelaxNGAddValidError(v2, 24, *(xmlChar **)(v17 + 16), 0, 0);
                    v7 = 0xFFFFFFFFLL;
                  }
                  else
                  {
                    v7 = 0;
                  }
                  if (*(_QWORD *)(a2 + 104))
                  {
                    v204 = v21;
                    v168 = v24;
                    v169 = v22;
                    v207 = *(_OWORD *)(v2 + 96);
                    v170 = xmlRelaxNGNewValidState(v2, v17);
                    *(_QWORD *)(v2 + 96) = v170;
                    *(_QWORD *)(v2 + 104) = 0;
                    v171 = xmlRelaxNGValidateCompiledContent((_DWORD *)v2, *(xmlRegexpPtr *)(a2 + 104), v170[1]);
                    v172 = *(_QWORD *)(*(_QWORD *)(v2 + 96) + 8);
                    *(_OWORD *)(v2 + 96) = v207;
                    xmlRelaxNGFreeValidState(v2, v170);
                    if (v171)
                      v7 = 0xFFFFFFFFLL;
                    else
                      v7 = v7;
                    v173 = *(int **)(v2 + 104);
                    if (v173)
                    {
                      v22 = v169;
                      v24 = v168;
                      v21 = v204;
                      if (*v173 < 1)
                      {
LABEL_324:
                        *(_DWORD *)(v2 + 56) |= 1u;
                        xmlRelaxNGLogBestError(v2);
                        v176 = 1;
                      }
                      else
                      {
                        v174 = 0;
                        while (1)
                        {
                          v175 = *(_QWORD *)(*((_QWORD *)v173 + 1) + 8 * v174);
                          *(_QWORD *)(v2 + 96) = v175;
                          *(_QWORD *)(v175 + 8) = v172;
                          if (!xmlRelaxNGValidateElementEnd(v2, 0))
                            break;
                          ++v174;
                          v173 = *(int **)(v2 + 104);
                          if (v174 >= *v173)
                            goto LABEL_324;
                        }
                        v176 = 0;
                      }
                      v185 = *(int **)(v2 + 104);
                      if (*v185 >= 1)
                      {
                        v186 = 0;
                        do
                        {
                          xmlRelaxNGFreeValidState(v2, *(_QWORD **)(*((_QWORD *)v185 + 1) + 8 * v186++));
                          v185 = *(int **)(v2 + 104);
                        }
                        while (v186 < *v185);
                      }
                      goto LABEL_381;
                    }
                    v184 = *v5;
                    if (*v5)
                      *((_QWORD *)v184 + 1) = v172;
                    v22 = v169;
                    if ((_DWORD)v7)
                    {
                      v7 = 0xFFFFFFFFLL;
                      v24 = v168;
                      v21 = v204;
LABEL_376:
                      xmlRelaxNGFreeValidState(v2, v184);
                      goto LABEL_386;
                    }
                    v24 = v168;
                    v21 = v204;
                  }
                  else
                  {
                    v177 = *(_QWORD *)(a2 + 48);
                    if (v177 && xmlRelaxNGValidateDefinitionList(v2, v177))
                    {
                      if (*v5)
                      {
                        xmlRelaxNGAddValidError(v2, 25, *(xmlChar **)(v17 + 16), 0, 0);
                      }
                      else
                      {
                        *(_QWORD *)(v2 + 96) = v24;
                        xmlRelaxNGAddValidError(v2, 25, *(xmlChar **)(v17 + 16), 0, 0);
                        *(_QWORD *)(v2 + 96) = 0;
                      }
                      v7 = 0xFFFFFFFFLL;
                    }
                    v188 = *(int **)(v2 + 104);
                    if (v188)
                    {
                      if (*v188 < 1)
                      {
LABEL_372:
                        *(_DWORD *)(v2 + 56) |= 1u;
                        xmlRelaxNGLogBestError(v2);
                        v176 = 1;
                      }
                      else
                      {
                        v189 = 0;
                        while (1)
                        {
                          *(_QWORD *)(v2 + 96) = *(_QWORD *)(*((_QWORD *)v188 + 1) + 8 * v189);
                          if (!xmlRelaxNGValidateElementEnd(v2, 0))
                            break;
                          ++v189;
                          v188 = *(int **)(v2 + 104);
                          if (v189 >= *v188)
                            goto LABEL_372;
                        }
                        v176 = 0;
                      }
                      v185 = *(int **)(v2 + 104);
                      if (*v185 >= 1)
                      {
                        v190 = 0;
                        do
                        {
                          xmlRelaxNGFreeValidState(v2, *(_QWORD **)(*((_QWORD *)v185 + 1) + 8 * v190));
                          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 104) + 8) + 8 * v190++) = 0;
                          v185 = *(int **)(v2 + 104);
                        }
                        while (v190 < *v185);
                      }
LABEL_381:
                      xmlRelaxNGFreeStates(v2, (void **)v185);
                      *(_QWORD *)(v2 + 104) = 0;
                      if ((_DWORD)v7)
                        v191 = 0;
                      else
                        v191 = v176;
                      if ((v191 & 1) != 0)
                      {
                        v192 = 0;
                        v7 = 0xFFFFFFFFLL;
LABEL_389:
                        *(_DWORD *)(v2 + 56) = v21;
                        *(_QWORD *)(v2 + 96) = v24;
                        if (v24)
                          *((_QWORD *)v24 + 1) = xmlRelaxNGSkipIgnored(v2, *(_QWORD *)(v17 + 48));
                        if ((v192 & 1) == 0)
                        {
                          if ((v21 & 1) != 0)
                            goto LABEL_252;
                          xmlRelaxNGDumpValidError(v2);
                          goto LABEL_233;
                        }
                        if (*(_DWORD *)(v2 + 80) <= v22)
                        {
LABEL_233:
                          v7 = 0;
LABEL_252:
                          --*(_DWORD *)(v2 + 60);
                          return v7;
                        }
                        v126 = v2;
                        v127 = v22;
LABEL_232:
                        xmlRelaxNGPopErrors(v126, v127);
                        goto LABEL_233;
                      }
LABEL_386:
                      if ((_DWORD)v7)
                      {
                        v192 = 0;
                      }
                      else
                      {
                        *(_QWORD *)(v17 + 104) = a2;
                        v192 = 1;
                      }
                      goto LABEL_389;
                    }
                    v184 = *v5;
                    if ((_DWORD)v7)
                    {
                      v7 = 0xFFFFFFFFLL;
                      goto LABEL_376;
                    }
                  }
                  v7 = xmlRelaxNGValidateElementEnd(v2, 1);
                  goto LABEL_376;
                }
              }
              goto LABEL_209;
            }
            *((_QWORD *)v4 + 1) = xmlRelaxNGSkipIgnored(v2, *(_QWORD *)(v16 + 48));
            if (!(_DWORD)v7)
              goto LABEL_252;
            v136 = *(const xmlChar ***)(v2 + 72);
            if (!v136)
              goto LABEL_233;
            while (1)
            {
              v137 = *(_DWORD *)v136;
              if (*(_DWORD *)v136 == 13)
              {
                if (xmlStrEqual(v136[4], *(const xmlChar **)(v17 + 16)))
                  goto LABEL_247;
                v136 = *(const xmlChar ***)(v2 + 72);
                v137 = *(_DWORD *)v136;
              }
              if (v137 != 19)
                goto LABEL_246;
              if (!xmlStrEqual(v136[3], *(const xmlChar **)(v17 + 16)))
              {
                v137 = **(_DWORD **)(v2 + 72);
LABEL_246:
                if ((v137 & 0xFFFFFFFE) != 0x16)
                  goto LABEL_233;
              }
LABEL_247:
              xmlRelaxNGValidErrorPop(v2);
              v7 = 0;
              v136 = *(const xmlChar ***)(v2 + 72);
              if (!v136)
                goto LABEL_252;
            }
          }
          v99 = v2;
          v100 = 23;
          v98 = 0;
        }
        else
        {
          v98 = *(xmlChar **)(a2 + 16);
          v99 = v2;
          v100 = 22;
        }
        xmlRelaxNGAddValidError(v99, v100, v98, 0, 0);
LABEL_209:
        if ((*(_BYTE *)(v2 + 56) & 1) == 0)
          xmlRelaxNGDumpValidError(v2);
LABEL_251:
        v7 = 0xFFFFFFFFLL;
        goto LABEL_252;
      case 5:
        if (!v6)
          goto LABEL_47;
        v26 = 0;
        v27 = v6;
        do
        {
          v28 = *(_DWORD *)(v27 + 8);
          if ((v28 - 3) >= 2)
          {
            if (v28 == 1)
            {
              v128 = *(xmlChar **)(*(_QWORD *)(v6 + 40) + 16);
              v129 = v2;
              v130 = 28;
              goto LABEL_226;
            }
          }
          else
          {
            v26 = xmlStrcat(v26, *(const xmlChar **)(v27 + 80));
          }
          v27 = *(_QWORD *)(v27 + 48);
        }
        while (v27);
        if (!v26)
        {
LABEL_47:
          v26 = xmlStrdup((const xmlChar *)&byte_1B0865C1A);
          if (!v26)
            goto LABEL_155;
        }
        v29 = xmlRelaxNGValidateDatatype(v2, v26, a2, *(_QWORD *)(*(_QWORD *)(v2 + 96) + 8));
        v7 = v29;
        if (!(_DWORD)v29)
        {
          v38 = *v5;
          goto LABEL_218;
        }
        if ((_DWORD)v29 != -1)
          goto LABEL_219;
        v30 = *(xmlChar **)(a2 + 16);
        v31 = v2;
        v32 = 31;
        goto LABEL_216;
      case 7:
        if (!v6)
          goto LABEL_58;
        v26 = 0;
        v33 = v6;
        do
        {
          v34 = *(_DWORD *)(v33 + 8);
          if ((v34 - 3) >= 2)
          {
            if (v34 == 1)
            {
              v128 = *(xmlChar **)(*(_QWORD *)(v6 + 40) + 16);
              v129 = v2;
              v130 = 29;
              goto LABEL_226;
            }
          }
          else
          {
            v26 = xmlStrcat(v26, *(const xmlChar **)(v33 + 80));
          }
          v33 = *(_QWORD *)(v33 + 48);
        }
        while (v33);
        if (!v26)
        {
LABEL_58:
          v26 = xmlStrdup((const xmlChar *)&byte_1B0865C1A);
          if (!v26)
            goto LABEL_155;
        }
        v35 = *(_QWORD *)(v2 + 96);
        v36 = *(_QWORD *)(v35 + 32);
        *(_QWORD *)(v35 + 32) = v26;
        v37 = xmlRelaxNGValidateValue(v2, a2);
        v7 = v37;
        v38 = *(__int128 **)(v2 + 96);
        *((_QWORD *)v38 + 4) = v36;
        if (!(_DWORD)v37)
        {
LABEL_218:
          *((_QWORD *)v38 + 1) = 0;
          goto LABEL_219;
        }
        if ((_DWORD)v37 != -1)
          goto LABEL_219;
        v30 = *(xmlChar **)(a2 + 16);
        v31 = v2;
        v32 = 32;
        goto LABEL_216;
      case 8:
        if (!v6)
          goto LABEL_69;
        v26 = 0;
        v39 = v6;
        do
        {
          v40 = *(_DWORD *)(v39 + 8);
          if ((v40 - 3) >= 2)
          {
            if (v40 == 1)
            {
              v128 = *(xmlChar **)(*(_QWORD *)(v6 + 40) + 16);
              v129 = v2;
              v130 = 30;
LABEL_226:
              xmlRelaxNGAddValidError(v129, v130, v128, 0, 0);
              if (v26)
                xmlFree(v26);
              goto LABEL_251;
            }
          }
          else
          {
            v26 = xmlStrcat(v26, *(const xmlChar **)(v39 + 80));
          }
          v39 = *(_QWORD *)(v39 + 48);
        }
        while (v39);
        if (!v26)
        {
LABEL_69:
          v26 = xmlStrdup((const xmlChar *)&byte_1B0865C1A);
          if (!v26)
          {
LABEL_155:
            xmlRngVErrMemory(v2, (const xmlChar *)"validating\n");
            goto LABEL_251;
          }
        }
        v41 = xmlStrlen(v26);
        v42 = *(_QWORD *)(v2 + 96);
        v205 = *(_OWORD *)(v42 + 32);
        *(_QWORD *)(v42 + 32) = v26;
        *(_QWORD *)(v42 + 40) = &v26[v41];
        v43 = xmlRelaxNGValidateValue(v2, a2);
        v7 = v43;
        v44 = *(_QWORD *)(v2 + 96);
        *(_OWORD *)(v44 + 32) = v205;
        if ((_DWORD)v43 == -1)
        {
          v31 = v2;
          v32 = 33;
          v30 = 0;
LABEL_216:
          xmlRelaxNGAddValidError(v31, v32, v30, 0, 0);
        }
        else if (!(_DWORD)v43 && v6)
        {
          *(_QWORD *)(v44 + 8) = *(_QWORD *)(v6 + 48);
        }
LABEL_219:
        ((void (*)(xmlChar *))xmlFree)(v26);
        goto LABEL_252;
      case 9:
        v9 = xmlRelaxNGValidateAttribute(a1, a2);
        goto LABEL_75;
      case 0xA:
      case 0x12:
        v9 = xmlRelaxNGValidateDefinitionList(a1, *(_QWORD *)(a2 + 48));
        goto LABEL_75;
      case 0xE:
        v45 = *(_DWORD *)(a1 + 80);
        v46 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v46 | 1;
        v47 = xmlRelaxNGCopyValidState(a1, v4);
        if (xmlRelaxNGValidateDefinitionList(v2, *(_QWORD *)(a2 + 48)))
        {
          if (*v5)
            xmlRelaxNGFreeValidState(v2, *v5);
          *(_QWORD *)(v2 + 96) = v47;
        }
        else
        {
          v101 = *(int **)(v2 + 104);
          if (v101)
          {
            xmlRelaxNGAddStates(v2, v101, (uint64_t)v47);
          }
          else
          {
            v131 = (int *)xmlRelaxNGNewStates(v2, 1);
            *(_QWORD *)(v2 + 104) = v131;
            if (!v131)
            {
              xmlRelaxNGFreeValidState(v2, v47);
              *(_DWORD *)(v2 + 56) = v46;
              if (*(_DWORD *)(v2 + 80) > v45)
                xmlRelaxNGPopErrors(v2, v45);
              goto LABEL_251;
            }
            xmlRelaxNGAddStates(v2, v131, (uint64_t)v47);
            xmlRelaxNGAddStates(v2, *(int **)(v2 + 104), *(_QWORD *)(v2 + 96));
            *(_QWORD *)(v2 + 96) = 0;
          }
        }
        *(_DWORD *)(v2 + 56) = v46;
        if (*(_DWORD *)(v2 + 80) <= v45)
          goto LABEL_233;
        v126 = v2;
        v127 = v45;
        goto LABEL_232;
      case 0xF:
        goto LABEL_83;
      case 0x10:
        v48 = *(_DWORD *)(a1 + 80);
        if (xmlRelaxNGValidateDefinitionList(a1, *(_QWORD *)(a2 + 48)))
          goto LABEL_251;
        if (*(_DWORD *)(v2 + 80) > v48)
          xmlRelaxNGPopErrors(v2, v48);
LABEL_83:
        v49 = (int *)xmlRelaxNGNewStates(v2, 1);
        if (!v49)
          goto LABEL_251;
        v50 = v49;
        if (*v5)
        {
          v51 = xmlRelaxNGCopyValidState(v2, *v5);
          xmlRelaxNGAddStates(v2, v50, (uint64_t)v51);
        }
        else
        {
          v104 = *(int **)(v2 + 104);
          if (*v104 >= 1)
          {
            v105 = 0;
            do
            {
              v106 = xmlRelaxNGCopyValidState(v2, *(__int128 **)(*((_QWORD *)v104 + 1) + 8 * v105));
              xmlRelaxNGAddStates(v2, v50, (uint64_t)v106);
              ++v105;
              v104 = *(int **)(v2 + 104);
            }
            while (v105 < *v104);
          }
        }
        v107 = 0;
        v61 = *(_DWORD *)(v2 + 56);
        *(_DWORD *)(v2 + 56) = v61 | 1;
        while (2)
        {
          v108 = *(int **)(v2 + 104);
          if (v108)
          {
            if (*v108 < 1)
              goto LABEL_257;
            v109 = 0;
            v110 = 0;
            v111 = *v50;
            do
            {
              *(_QWORD *)(v2 + 96) = *(_QWORD *)(*((_QWORD *)v108 + 1) + 8 * v109);
              *(_QWORD *)(v2 + 104) = 0;
              v112 = xmlRelaxNGValidateDefinitionList(v2, *(_QWORD *)(a2 + 48));
              v113 = *(_QWORD *)(v2 + 96);
              if (v112)
              {
                if (v113)
                {
                  xmlRelaxNGFreeValidState(v2, *(_QWORD **)(v2 + 96));
                  *(_QWORD *)(v2 + 96) = 0;
                }
              }
              else if (v113)
              {
                v114 = xmlRelaxNGAddStates(v2, v50, v113);
                *(_QWORD *)(v2 + 96) = 0;
                if (v114 == 1)
                  v110 = 1;
              }
              else
              {
                v115 = *(int **)(v2 + 104);
                if (v115)
                {
                  if (*v115 >= 1)
                  {
                    v116 = 0;
                    do
                    {
                      if (xmlRelaxNGAddStates(v2, v50, *(_QWORD *)(*((_QWORD *)v115 + 1) + 8 * v116)) == 1)
                        v110 = 1;
                      ++v116;
                      v115 = *(int **)(v2 + 104);
                    }
                    while (v116 < *v115);
                  }
                  xmlRelaxNGFreeStates(v2, (void **)v115);
                  *(_QWORD *)(v2 + 104) = 0;
                }
              }
              ++v109;
            }
            while (v109 < *v108);
            v107 = v108;
            if (!v110)
            {
LABEL_257:
              xmlRelaxNGFreeStates(v2, (void **)v108);
              goto LABEL_258;
            }
LABEL_199:
            v123 = *v50 - v111;
            if (v123 == 1)
            {
              *(_QWORD *)(v2 + 96) = xmlRelaxNGCopyValidState(v2, *(__int128 **)(*((_QWORD *)v50 + 1) + 8 * v111));
              continue;
            }
            if (v107 || (xmlRelaxNGNewStates(v2, v123), (v107 = *(int **)(v2 + 104)) != 0))
            {
              *v107 = 0;
              if (v111 < *v50)
              {
                v124 = v111;
                do
                {
                  v125 = xmlRelaxNGCopyValidState(v2, *(__int128 **)(*((_QWORD *)v50 + 1) + 8 * v124));
                  xmlRelaxNGAddStates(v2, v107, (uint64_t)v125);
                  ++v124;
                }
                while (v124 < *v50);
              }
              *(_QWORD *)(v2 + 104) = v107;
              continue;
            }
LABEL_258:
            v7 = 0;
            *(_QWORD *)(v2 + 104) = v50;
LABEL_259:
            *(_DWORD *)(v2 + 56) = v61;
            goto LABEL_252;
          }
          break;
        }
        v117 = xmlRelaxNGValidateDefinitionList(v2, *(_QWORD *)(a2 + 48));
        v118 = *(_QWORD *)(v2 + 96);
        if (v117)
        {
          xmlRelaxNGFreeValidState(v2, *(_QWORD **)(v2 + 96));
          *(_QWORD *)(v2 + 96) = 0;
        }
        else
        {
          v111 = *v50;
          if (v118)
          {
            v119 = xmlRelaxNGAddStates(v2, v50, v118);
            *(_QWORD *)(v2 + 96) = 0;
            if (v119 == 1)
              goto LABEL_199;
          }
          else
          {
            v120 = *(int **)(v2 + 104);
            if (v120)
            {
              if (*v120 < 1)
              {
                v122 = 0;
              }
              else
              {
                v121 = 0;
                v122 = 0;
                do
                {
                  if (xmlRelaxNGAddStates(v2, v50, *(_QWORD *)(*((_QWORD *)v120 + 1) + 8 * v121)) == 1)
                    v122 = 1;
                  ++v121;
                  v120 = *(int **)(v2 + 104);
                }
                while (v121 < *v120);
              }
              if (v107)
                xmlRelaxNGFreeStates(v2, (void **)v120);
              else
                v107 = v120;
              *(_QWORD *)(v2 + 104) = 0;
              v108 = v107;
              if (!v122)
                goto LABEL_257;
              goto LABEL_199;
            }
          }
        }
        v108 = v107;
        if (!v107)
          goto LABEL_258;
        goto LABEL_257;
      case 0x11:
        v52 = xmlRelaxNGSkipIgnored(a1, v6);
        v53 = *(_DWORD *)(v2 + 80);
        if ((*(_WORD *)(a2 + 98) & 0x10) != 0)
        {
          v54 = *(xmlHashTable **)(a2 + 40);
          if (v54)
          {
            v55 = v52;
            if (v52)
            {
              v56 = *(_DWORD *)(v52 + 8);
              if ((v56 - 3) >= 2)
              {
                if (v56 != 1)
                {
LABEL_249:
                  v103 = *(xmlChar **)(v55 + 16);
                  a1 = v2;
                  v102 = 38;
                  goto LABEL_250;
                }
                v132 = *(_QWORD *)(v52 + 72);
                v133 = *(const xmlChar **)(v52 + 16);
                if (v132)
                {
                  v8 = xmlHashLookup2(*(xmlHashTablePtr *)(a2 + 40), v133, *(const xmlChar **)(v132 + 16));
                  if (v8)
                    goto LABEL_8;
                  v134 = *(const xmlChar **)(*(_QWORD *)(v55 + 72) + 16);
                  v133 = (const xmlChar *)"#any";
                  v135 = v54;
                }
                else
                {
                  v135 = *(xmlHashTable **)(a2 + 40);
                  v134 = 0;
                }
                v8 = xmlHashLookup2(v135, v133, v134);
                if (v8)
                {
LABEL_8:
                  v9 = xmlRelaxNGValidateDefinition(v2, v8);
LABEL_75:
                  v7 = v9;
                  goto LABEL_252;
                }
                v57 = "#any";
              }
              else
              {
                v57 = "#text";
              }
              v8 = xmlHashLookup2(v54, (const xmlChar *)v57, 0);
              if (!v8)
                goto LABEL_249;
              goto LABEL_8;
            }
          }
        }
        v66 = *(_QWORD *)(a2 + 48);
        v67 = *(_DWORD *)(v2 + 56);
        *(_DWORD *)(v2 + 56) = v67 | 1;
        v68 = (int **)(v2 + 104);
        if (v66)
        {
          v69 = 0;
          do
          {
            v4 = (__int128 *)xmlRelaxNGCopyValidState(v2, v4);
            v7 = xmlRelaxNGValidateDefinition(v2, v66);
            if ((_DWORD)v7)
            {
              xmlRelaxNGFreeValidState(v2, *(_QWORD **)(v2 + 96));
            }
            else
            {
              if (!v69)
                v69 = (int *)xmlRelaxNGNewStates(v2, 1);
              if (*v5)
              {
                xmlRelaxNGAddStates(v2, v69, (uint64_t)*v5);
              }
              else
              {
                v70 = *v68;
                if (*v68)
                {
                  if (*v70 >= 1)
                  {
                    v71 = 0;
                    do
                    {
                      xmlRelaxNGAddStates(v2, v69, *(_QWORD *)(*((_QWORD *)v70 + 1) + 8 * v71++));
                      v70 = *(int **)(v2 + 104);
                    }
                    while (v71 < *v70);
                  }
                  xmlRelaxNGFreeStates(v2, (void **)v70);
                  *(_QWORD *)(v2 + 104) = 0;
                }
              }
            }
            *v5 = v4;
            v66 = *(_QWORD *)(v66 + 64);
          }
          while (v66);
          if (!v69)
          {
            *(_QWORD *)(v2 + 104) = 0;
            *(_DWORD *)(v2 + 56) = v67;
            if ((_DWORD)v7)
            {
              if ((v67 & 1) == 0)
                xmlRelaxNGDumpValidError(v2);
              goto LABEL_252;
            }
            goto LABEL_213;
          }
          xmlRelaxNGFreeValidState(v2, v4);
          *(_QWORD *)(v2 + 104) = v69;
        }
        else
        {
          v5 = (__int128 **)(v2 + 104);
        }
        *v5 = 0;
        *(_DWORD *)(v2 + 56) = v67;
LABEL_213:
        if (*(_DWORD *)(v2 + 80) <= v53)
          goto LABEL_233;
        v126 = v2;
        v127 = v53;
        goto LABEL_232;
      case 0x13:
        v58 = *(int **)(a2 + 40);
        if (!v58)
        {
          v102 = 10;
          v103 = 0;
LABEL_250:
          xmlRelaxNGAddValidError(a1, v102, v103, 0, 0);
          goto LABEL_251;
        }
        v59 = *(_DWORD *)(a1 + 80);
        v60 = *v58;
        v61 = *(_DWORD *)(a1 + 56);
        v206 = *(int **)(a2 + 40);
        if ((*(_WORD *)(a2 + 98) & 8) != 0)
        {
          *(_DWORD *)(a1 + 56) = v61 | 4;
          if ((_DWORD)v60 == 2)
          {
            if (v4)
            {
              v62 = xmlRelaxNGSkipIgnored(a1, *((_QWORD *)v4 + 1));
              v58 = v206;
              *((_QWORD *)v4 + 1) = v62;
            }
            v63 = (_QWORD **)*((_QWORD *)v58 + 3);
            v64 = (_DWORD *)**v63;
            if (*v64 == 3)
              v64 = (_DWORD *)*v63[1];
            v7 = xmlRelaxNGValidateDefinition(v2, v64);
            if (!(_DWORD)v7 && *v5)
            {
              v65 = *v5;
              *((_QWORD *)v65 + 1) = xmlRelaxNGSkipIgnored(v2, *((_QWORD *)v65 + 1));
            }
            goto LABEL_259;
          }
        }
        v201 = v59;
        v72 = xmlMalloc(8 * v60);
        if (!v72)
          goto LABEL_155;
        v73 = v72;
        bzero(v72, 8 * v60);
        v74 = xmlMalloc(8 * v60);
        if (!v74)
          goto LABEL_155;
        v75 = v74;
        bzero(v74, 8 * v60);
        v76 = *(__int128 **)(v2 + 96);
        v77 = xmlRelaxNGSkipIgnored(v2, *((_QWORD *)v76 + 1));
        v202 = v75;
        v195 = v77;
        if (!v77)
        {
          v79 = 0;
          v200 = 0;
          goto LABEL_261;
        }
        v78 = v73;
        v200 = 0;
        v79 = v77;
        break;
      default:
        goto LABEL_252;
    }
    while (1)
    {
      *((_QWORD *)*v5 + 1) = v79;
      v80 = v206;
      v81 = (xmlHashTable *)*((_QWORD *)v206 + 1);
      v82 = v79;
      if (!v81 || (v206[4] & 1) == 0)
      {
        if ((int)v60 < 1)
        {
          LODWORD(v83) = 0;
        }
        else
        {
          v83 = 0;
          while (1)
          {
            v84 = *(_QWORD *)(*((_QWORD *)v80 + 3) + 8 * v83);
            if (v84)
            {
              v85 = xmlRelaxNGNodeMatchesList(v79, *(_QWORD ***)(v84 + 8));
              v79 = v82;
              v80 = v206;
              if (v85)
                break;
            }
            if (v60 == ++v83)
              goto LABEL_254;
          }
        }
        goto LABEL_139;
      }
      v86 = *(_DWORD *)(v79 + 8);
      if ((v86 - 3) < 2)
      {
        v87 = "#text";
        goto LABEL_133;
      }
      if (v86 != 1)
        goto LABEL_254;
      v95 = *(_QWORD *)(v79 + 72);
      v96 = *(const xmlChar **)(v79 + 16);
      if (v95)
      {
        v88 = xmlHashLookup2(v81, v96, *(const xmlChar **)(v95 + 16));
        v89 = v206;
        v79 = v82;
        if (v88)
          goto LABEL_134;
        v81 = (xmlHashTable *)*((_QWORD *)v206 + 1);
        v97 = *(const xmlChar **)(*(_QWORD *)(v82 + 72) + 16);
        v96 = (const xmlChar *)"#any";
      }
      else
      {
        v97 = 0;
      }
      v88 = xmlHashLookup2(v81, v96, v97);
      v89 = v206;
      v79 = v82;
      if (!v88)
      {
        v81 = (xmlHashTable *)*((_QWORD *)v206 + 1);
        v87 = "#any";
LABEL_133:
        v88 = xmlHashLookup2(v81, (const xmlChar *)v87, 0);
        v89 = v206;
        v79 = v82;
        if (!v88)
          goto LABEL_254;
      }
LABEL_134:
      LODWORD(v83) = (_DWORD)v88 - 1;
      if ((v89[4] & 2) != 0)
      {
        v90 = xmlRelaxNGNodeMatchesList(v79, *(_QWORD ***)(*(_QWORD *)(*((_QWORD *)v89 + 3) + 8 * (int)v83) + 8));
        v79 = v82;
        if (!v90)
          LODWORD(v83) = v60;
      }
LABEL_139:
      if ((int)v83 < (int)v60)
      {
        v91 = v202[(int)v83];
        v92 = v91 ? (uint64_t *)(v91 + 48) : &v78[(int)v83];
        *v92 = v79;
        v202[(int)v83] = v79;
        v93 = *(_QWORD *)(v79 + 48);
        v94 = v93 ? *(_QWORD *)(v79 + 48) : v79;
        v200 = v94;
        v79 = xmlRelaxNGSkipIgnored(v2, v93);
        if (v79)
          continue;
      }
LABEL_254:
      v76 = *v5;
      v73 = v78;
      v75 = v202;
LABEL_261:
      if ((int)v60 < 1)
      {
        v167 = 1;
        v141 = v76;
        goto LABEL_332;
      }
      v194 = v61;
      v139 = 0;
      v203 = 0;
      v60 = v60;
      v193 = v79;
      v140 = v79;
      v141 = v76;
      v196 = v60;
      v197 = v73;
LABEL_263:
      v142 = xmlRelaxNGCopyValidState(v2, v141);
      *(_QWORD *)(v2 + 96) = v142;
      if (v142)
      {
        v143 = *(_QWORD **)(*((_QWORD *)v206 + 3) + 8 * v139);
        v144 = v75[v139];
        if (v144)
        {
          v203 = *(_QWORD *)(v144 + 48);
          *(_QWORD *)(v144 + 48) = 0;
        }
        v142[1] = v73[v139];
        v145 = xmlRelaxNGValidateDefinition(v2, *v143);
        v76 = *(__int128 **)(v2 + 96);
        if (!v145)
        {
          if (v76)
          {
            v140 = xmlRelaxNGSkipIgnored(v2, *((_QWORD *)v76 + 1));
            xmlRelaxNGFreeValidState(v2, v141);
            v141 = *(__int128 **)(v2 + 96);
            *(_QWORD *)(v2 + 96) = 0;
            if (!v140)
              goto LABEL_307;
            v146 = *(_QWORD *)(a2 + 56);
            if (*(_DWORD *)v146 == 10)
            {
              if (xmlStrEqual(*(const xmlChar **)(v146 + 16), (const xmlChar *)"open-name-class"))
                goto LABEL_307;
            }
            xmlRelaxNGAddValidError(v2, 12, *(xmlChar **)(v140 + 16), 0, 0);
            v179 = 0;
            *(_QWORD *)(v2 + 96) = v141;
            v7 = 0xFFFFFFFFLL;
            v180 = v201;
            v181 = v195;
            v182 = v200;
            v61 = v194;
            goto LABEL_338;
          }
          v147 = *(void ***)(v2 + 104);
          if (!v147)
            goto LABEL_325;
          v148 = *(unsigned int *)v147;
          if ((int)v148 <= 0)
          {
            xmlRelaxNGFreeStates(v2, v147);
            *(_QWORD *)(v2 + 104) = 0;
            v73 = v197;
LABEL_360:
            if (v140)
              v187 = *(xmlChar **)(v140 + 16);
            else
              v187 = (xmlChar *)"noname";
            xmlRelaxNGAddValidError(v2, 12, v187, 0, 0);
            v181 = v195;
            v182 = v200;
            v61 = v194;
            v179 = 0;
            *v5 = v141;
            v7 = 0xFFFFFFFFLL;
            v180 = v201;
LABEL_338:
            *(_DWORD *)(v2 + 56) = v61;
            if (v182 && v182 != v181)
            {
              do
              {
                v183 = *(_QWORD *)(v182 + 56);
                if (!v183)
                  break;
                *(_QWORD *)(v183 + 48) = v182;
                v182 = v183;
              }
              while (v183 != v181);
            }
            if (v179 && *(_DWORD *)(v2 + 80) > v180)
              xmlRelaxNGPopErrors(v2, v180);
            xmlFree(v73);
            ((void (*)(_QWORD *))xmlFree)(v75);
            goto LABEL_252;
          }
          v198 = v139;
          v199 = v141;
          v149 = 0;
          v150 = 0;
          v151 = v147[1];
          v152 = -1;
          v153 = -1;
          while (1)
          {
            v154 = v151[v149];
            v155 = xmlRelaxNGSkipIgnored(v2, *(_QWORD *)(v154 + 8));
            if (v155)
            {
              if (v150)
              {
                v150 = 1;
              }
              else
              {
                v159 = *(_DWORD *)(v154 + 24);
                if (v152 == -1)
                {
                  v150 = 0;
                  v153 = v149;
                  v152 = *(_DWORD *)(v154 + 24);
                }
                else
                {
                  v150 = 0;
                  if (v159 <= v152)
                    v153 = v149;
                  if (v159 < v152)
                    v152 = *(_DWORD *)(v154 + 24);
                }
              }
            }
            else
            {
              v156 = *(_DWORD *)(v154 + 24);
              if (v150)
                v157 = v153;
              else
                v157 = v149;
              if (v150)
                v158 = v152;
              else
                v158 = *(_DWORD *)(v154 + 24);
              if (v156 <= v158)
                v153 = v149;
              else
                v153 = v157;
              if (v156 >= v158)
                v152 = v158;
              else
                v152 = *(_DWORD *)(v154 + 24);
              v150 = 1;
              if (!v152)
              {
LABEL_300:
                v140 = v155;
                xmlRelaxNGFreeValidState(v2, v199);
                v160 = *(int **)(v2 + 104);
                v161 = *((_QWORD *)v160 + 1);
                if (v153 == -1)
                {
                  v164 = v161 + 8 * *v160;
                  v141 = *(__int128 **)(v164 - 8);
                  *(_QWORD *)(v164 - 8) = 0;
                  v162 = *(int **)(v2 + 104);
                  v163 = *v162 - 1;
                  *v162 = v163;
                }
                else
                {
                  v141 = *(__int128 **)(v161 + 8 * v153);
                  *(_QWORD *)(v161 + 8 * v153) = 0;
                  v162 = *(int **)(v2 + 104);
                  v163 = *v162;
                }
                v60 = v196;
                v73 = v197;
                v75 = v202;
                if (v163 >= 1)
                {
                  v165 = 0;
                  do
                  {
                    xmlRelaxNGFreeValidState(v2, *(_QWORD **)(*((_QWORD *)v162 + 1) + 8 * v165++));
                    v162 = *(int **)(v2 + 104);
                  }
                  while (v165 < *v162);
                }
                xmlRelaxNGFreeStates(v2, (void **)v162);
                *(_QWORD *)(v2 + 104) = 0;
                v139 = v198;
                if (!v150)
                  goto LABEL_360;
LABEL_307:
                v166 = v75[v139];
                if (v166)
                  *(_QWORD *)(v166 + 48) = v203;
                if (++v139 == v60)
                {
                  v76 = *v5;
                  v167 = 1;
                  goto LABEL_331;
                }
                goto LABEL_263;
              }
            }
            if (v148 == ++v149)
              goto LABEL_300;
          }
        }
        v167 = 0;
LABEL_331:
        v79 = v193;
        v61 = v194;
LABEL_332:
        if (v76)
        {
          v178 = v79;
          xmlRelaxNGFreeValidState(v2, v76);
          v79 = v178;
        }
        *v5 = v141;
        *((_QWORD *)v141 + 1) = v79;
        if ((v167 & 1) != 0)
        {
          v7 = 0;
          v179 = 1;
LABEL_337:
          v180 = v201;
          v181 = v195;
          v182 = v200;
          goto LABEL_338;
        }
      }
      else
      {
LABEL_325:
        *v5 = v141;
        *((_QWORD *)v141 + 1) = v193;
        v61 = v194;
      }
      xmlRelaxNGAddValidError(v2, 11, 0, 0, 0);
      v179 = 0;
      v7 = 0xFFFFFFFFLL;
      goto LABEL_337;
    }
  }
  xmlRelaxNGAddValidError(a1, 7, 0, 0, 0);
  return 0xFFFFFFFFLL;
}

uint64_t xmlRelaxNGAddStates(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const xmlChar *v13;
  const xmlChar *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;

  result = 0xFFFFFFFFLL;
  if (a2 && a3)
  {
    v7 = *a2;
    v8 = a2[1];
    if (*a2 >= (int)v8)
    {
      v9 = xmlRealloc(*((void **)a2 + 1), 16 * v8);
      if (!v9)
      {
        xmlRngVErrMemory(a1, (const xmlChar *)"adding states\n");
        return 0xFFFFFFFFLL;
      }
      *((_QWORD *)a2 + 1) = v9;
      a2[1] = 2 * v8;
      v7 = *a2;
    }
    if (v7 > 0)
    {
      v10 = 0;
      while (1)
      {
        v11 = *(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * v10);
        if (v11)
        {
          if (v11 == a3)
            goto LABEL_24;
          if (*(_QWORD *)a3 == *(_QWORD *)v11
            && *(_QWORD *)(a3 + 8) == *(_QWORD *)(v11 + 8)
            && *(_DWORD *)(a3 + 24) == *(_DWORD *)(v11 + 24))
          {
            v12 = *(unsigned int *)(a3 + 16);
            if (v12 == *(_DWORD *)(v11 + 16) && *(_QWORD *)(a3 + 40) == *(_QWORD *)(v11 + 40))
            {
              v13 = *(const xmlChar **)(a3 + 32);
              v14 = *(const xmlChar **)(v11 + 32);
              if (v13 != v14)
              {
                if (!xmlStrEqual(v13, v14))
                  goto LABEL_15;
                v12 = *(unsigned int *)(a3 + 16);
              }
              if ((int)v12 < 1)
              {
LABEL_24:
                xmlRelaxNGFreeValidState(a1, (_QWORD *)a3);
                return 0;
              }
              v15 = *(_QWORD **)(a3 + 48);
              v16 = *(_QWORD **)(v11 + 48);
              while (*v15 == *v16)
              {
                ++v16;
                ++v15;
                if (!--v12)
                  goto LABEL_24;
              }
            }
          }
        }
LABEL_15:
        ++v10;
        v7 = *a2;
        if (v10 >= *a2)
        {
          v17 = v7;
          goto LABEL_26;
        }
      }
    }
    v17 = v7;
LABEL_26:
    v18 = *((_QWORD *)a2 + 1);
    *a2 = v7 + 1;
    *(_QWORD *)(v18 + 8 * v17) = a3;
    return 1;
  }
  return result;
}

void xmlRelaxNGValidErrorPop(uint64_t a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  char v7;
  uint64_t v8;
  void *v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  _QWORD *v14;
  void *v15;

  v1 = *(_DWORD *)(a1 + 80);
  if (v1 <= 0)
  {
    *(_QWORD *)(a1 + 72) = 0;
  }
  else
  {
    v2 = v1 - 1;
    *(_DWORD *)(a1 + 80) = v1 - 1;
    v3 = *(_QWORD *)(a1 + 88);
    v4 = v3 + 40 * (v1 - 2);
    if (v1 == 1)
      v4 = 0;
    *(_QWORD *)(a1 + 72) = v4;
    v5 = v3 + 40 * v2;
    v7 = *(_BYTE *)(v5 + 4);
    v6 = (_DWORD *)(v5 + 4);
    if ((v7 & 1) != 0)
    {
      v8 = v3 + 40 * v2;
      v11 = *(void **)(v8 + 24);
      v10 = (_QWORD *)(v8 + 24);
      v9 = v11;
      if (v11)
        xmlFree(v9);
      *v10 = 0;
      v12 = v3 + 40 * v2;
      v15 = *(void **)(v12 + 32);
      v14 = (_QWORD *)(v12 + 32);
      v13 = v15;
      if (v15)
        xmlFree(v13);
      *v14 = 0;
      *v6 = 0;
    }
  }
}

uint64_t xmlRelaxNGValidateCompiledContent(_DWORD *data, xmlRegexpPtr comp, uint64_t a3)
{
  int v5;
  xmlRegExecCtxt *v6;
  int v7;
  uint64_t v8;
  const xmlChar *v9;
  uint64_t result;
  int v11;
  int v12;

  if (!comp)
    return 0xFFFFFFFFLL;
  v5 = data[46];
  v6 = xmlRegNewExecCtxt(comp, (xmlRegExecCallbacks)xmlRelaxNGValidateCompiledCallback, data);
  data[46] = 0;
  if (!a3)
    goto LABEL_17;
  while (1)
  {
    *(_QWORD *)(*((_QWORD *)data + 12) + 8) = a3;
    v7 = *(_DWORD *)(a3 + 8);
    if ((v7 - 3) < 2)
    {
      if (!xmlIsBlankNode((const xmlNode *)a3) && xmlRegExecPushString(v6, (const xmlChar *)"#text", data) < 0)
      {
        a3 = *(_QWORD *)(a3 + 40);
        v11 = 39;
        goto LABEL_16;
      }
      goto LABEL_12;
    }
    if (v7 != 1)
      goto LABEL_12;
    v8 = *(_QWORD *)(a3 + 72);
    v9 = *(const xmlChar **)(a3 + 16);
    if (!v8)
      break;
    if (xmlRegExecPushString2(v6, v9, *(const xmlChar **)(v8 + 16), data) < 0)
      goto LABEL_15;
LABEL_12:
    a3 = *(_QWORD *)(a3 + 48);
    if (!a3)
      goto LABEL_17;
  }
  if ((xmlRegExecPushString(v6, v9, data) & 0x80000000) == 0)
    goto LABEL_12;
LABEL_15:
  v11 = 38;
LABEL_16:
  xmlRelaxNGAddValidError((uint64_t)data, v11, *(xmlChar **)(a3 + 16), 0, 0);
LABEL_17:
  v12 = xmlRegExecPushString(v6, 0, 0);
  if (v12 == 1)
  {
    *(_QWORD *)(*((_QWORD *)data + 12) + 8) = 0;
    xmlRegFreeExecCtxt(v6);
    result = data[46];
  }
  else
  {
    if (!v12)
    {
      xmlRelaxNGAddValidError((uint64_t)data, 22, (xmlChar *)&byte_1B0865C1A, 0, 0);
      if ((data[14] & 1) == 0)
        xmlRelaxNGDumpValidError((uint64_t)data);
    }
    xmlRegFreeExecCtxt(v6);
    result = 0xFFFFFFFFLL;
  }
  data[46] = v5;
  return result;
}

uint64_t xmlRelaxNGValidateDefinitionList(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  xmlChar *v6;
  int v7;

  v2 = a1;
  if (a2)
  {
    v3 = a2;
    LODWORD(v4) = 0;
    while (*(_QWORD *)(v2 + 96) || *(_QWORD *)(v2 + 104))
    {
      v5 = xmlRelaxNGValidateDefinition(v2, v3);
      if (v5 < 0)
        v4 = 0xFFFFFFFFLL;
      else
        v4 = v4;
      if (v5 != -1)
      {
        v3 = *(_QWORD *)(v3 + 64);
        if (v3)
          continue;
      }
      return v4;
    }
    a1 = v2;
    v7 = 6;
    v6 = 0;
  }
  else
  {
    v6 = (xmlChar *)"NULL definition list";
    v7 = 37;
  }
  xmlRelaxNGAddValidError(a1, v7, v6, 0, 0);
  return 0xFFFFFFFFLL;
}

_QWORD *xmlRelaxNGCopyValidState(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  unsigned int v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  int v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int v13;
  uint64_t v14;

  if (!a2)
    return 0;
  v4 = *(_QWORD *)(a1 + 112);
  if (v4 && (v5 = *(_DWORD *)v4 - 1, *(int *)v4 >= 1))
  {
    *(_DWORD *)v4 = v5;
    v6 = *(_QWORD **)(*(_QWORD *)(v4 + 8) + 8 * v5);
  }
  else
  {
    v7 = xmlMalloc(0x38uLL);
    v6 = v7;
    if (!v7)
    {
      xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
      return v6;
    }
    v7[6] = 0;
    *((_OWORD *)v7 + 1) = 0u;
    *((_OWORD *)v7 + 2) = 0u;
    *(_OWORD *)v7 = 0u;
  }
  v8 = (void *)v6[6];
  v9 = *((_DWORD *)v6 + 5);
  v11 = a2[1];
  v10 = a2[2];
  v12 = *a2;
  v6[6] = *((_QWORD *)a2 + 6);
  *((_OWORD *)v6 + 1) = v11;
  *((_OWORD *)v6 + 2) = v10;
  *(_OWORD *)v6 = v12;
  v6[6] = v8;
  *((_DWORD *)v6 + 5) = v9;
  v13 = *((_DWORD *)a2 + 4);
  if (v13 >= 1)
  {
    if (v8)
    {
      if (v9 >= v13)
      {
LABEL_15:
        memcpy(v8, *((const void **)a2 + 6), 8 * *((int *)a2 + 4));
        return v6;
      }
      v8 = xmlRealloc(v8, 8 * *((int *)a2 + 5));
      if (v8)
      {
        *((_DWORD *)v6 + 5) = *((_DWORD *)a2 + 5);
        v6[6] = v8;
        goto LABEL_15;
      }
    }
    else
    {
      v14 = *((int *)a2 + 5);
      *((_DWORD *)v6 + 5) = v14;
      v8 = xmlMalloc(8 * v14);
      v6[6] = v8;
      if (v8)
        goto LABEL_15;
    }
    xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
    *((_DWORD *)v6 + 4) = 0;
  }
  return v6;
}

void xmlRelaxNGValidateCompiledCallback(uint64_t a1, const char *a2, _DWORD *a3, uint64_t a4)
{
  int v5;

  if (!a4)
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "callback on %s missing context\n", a2);
    return;
  }
  if (a3)
  {
    if (*a3 == 4)
    {
      v5 = xmlRelaxNGValidateDefinition(a4, a3);
      if (v5)
        *(_DWORD *)(a4 + 184) = v5;
      return;
    }
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "callback on %s define is not element\n");
  }
  else
  {
    if (*a2 == 35)
      return;
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "callback on %s missing define\n");
  }
  if (!*(_DWORD *)(a4 + 68))
    *(_DWORD *)(a4 + 68) = 37;
}

uint64_t xmlRelaxNGNodeMatchesList(uint64_t a1, _QWORD **a2)
{
  _QWORD *v3;
  _QWORD *i;
  int v6;
  uint64_t result;
  unsigned int v8;
  _QWORD *v9;

  if (!a2)
    return 0;
  v3 = *a2;
  if (!v3)
    return 0;
  for (i = a2 + 1; ; ++i)
  {
    v6 = *(_DWORD *)(a1 + 8);
    if (v6 != 1)
      break;
    if (*(_DWORD *)v3 == 4)
    {
      result = xmlRelaxNGElementMatch(0, v3, a1);
      if ((_DWORD)result == 1)
        return result;
    }
LABEL_11:
    v9 = (_QWORD *)*i;
    v3 = v9;
    if (!v9)
      return 0;
  }
  if ((v6 - 3) > 1)
    goto LABEL_11;
  v8 = *(_DWORD *)v3 - 3;
  if (v8 >= 6 || ((0x35u >> v8) & 1) == 0)
    goto LABEL_11;
  return 1;
}

const xmlChar *__cdecl xmlSAX2GetPublicId(void *ctx)
{
  return 0;
}

const xmlChar *__cdecl xmlSAX2GetSystemId(const xmlChar *ctx)
{
  uint64_t v1;

  if (ctx)
  {
    v1 = *((_QWORD *)ctx + 7);
    if (v1)
      return *(const xmlChar **)(v1 + 8);
    else
      return 0;
  }
  return ctx;
}

int xmlSAX2GetLineNumber(void *ctx)
{
  uint64_t v1;

  if (ctx)
  {
    v1 = *((_QWORD *)ctx + 7);
    if (v1)
      LODWORD(ctx) = *(_DWORD *)(v1 + 52);
    else
      LODWORD(ctx) = 0;
  }
  return (int)ctx;
}

int xmlSAX2GetColumnNumber(void *ctx)
{
  uint64_t v1;

  if (ctx)
  {
    v1 = *((_QWORD *)ctx + 7);
    if (v1)
      LODWORD(ctx) = *(_DWORD *)(v1 + 56);
    else
      LODWORD(ctx) = 0;
  }
  return (int)ctx;
}

int xmlSAX2IsStandalone(void *ctx)
{
  uint64_t v1;

  if (ctx)
  {
    v1 = *((_QWORD *)ctx + 2);
    if (v1)
      LODWORD(ctx) = *(_DWORD *)(v1 + 76) == 1;
    else
      LODWORD(ctx) = 0;
  }
  return (int)ctx;
}

int xmlSAX2HasInternalSubset(void *ctx)
{
  uint64_t v1;

  if (ctx)
  {
    v1 = *((_QWORD *)ctx + 2);
    if (v1)
      LODWORD(ctx) = *(_QWORD *)(v1 + 80) != 0;
    else
      LODWORD(ctx) = 0;
  }
  return (int)ctx;
}

int xmlSAX2HasExternalSubset(void *ctx)
{
  uint64_t v1;

  if (ctx)
  {
    v1 = *((_QWORD *)ctx + 2);
    if (v1)
      LODWORD(ctx) = *(_QWORD *)(v1 + 88) != 0;
    else
      LODWORD(ctx) = 0;
  }
  return (int)ctx;
}

void xmlSAX2InternalSubset(void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  const xmlDoc *v5;
  xmlNode *IntSubset;
  xmlDtd *v10;
  xmlDoc *v11;
  xmlDtdPtr v12;

  if (ctx)
  {
    v5 = (const xmlDoc *)*((_QWORD *)ctx + 2);
    if (v5)
    {
      IntSubset = (xmlNode *)xmlGetIntSubset(v5);
      if (IntSubset)
      {
        if (*((_DWORD *)ctx + 13))
          return;
        v10 = (xmlDtd *)IntSubset;
        xmlUnlinkNode(IntSubset);
        xmlFreeDtd(v10);
        v11 = (xmlDoc *)*((_QWORD *)ctx + 2);
        v11->intSubset = 0;
      }
      else
      {
        v11 = (xmlDoc *)*((_QWORD *)ctx + 2);
      }
      v12 = xmlCreateIntSubset(v11, name, ExternalID, SystemID);
      *(_QWORD *)(*((_QWORD *)ctx + 2) + 80) = v12;
      if (!v12)
        xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2InternalSubset");
    }
  }
}

_DWORD *xmlSAX2ErrMemory(uint64_t *a1, const char *a2)
{
  uint64_t v3;
  void (__cdecl *v4)(void *, xmlErrorPtr);
  _DWORD *result;

  *((_DWORD *)a1 + 34) = 2;
  v3 = *a1;
  if (*a1 && *(_DWORD *)(v3 + 216) == -554844497)
    v4 = *(void (__cdecl **)(void *, xmlErrorPtr))(v3 + 248);
  else
    v4 = 0;
  result = __xmlRaiseError(v4, (void (*)(void *, const char *, ...))a1[21], (void *)a1[20], a1, 0, 1u, 2, 2, 0, 0, (const xmlChar *)"out of memory\n", 0, 0, 0, 0, a2, (char)"out of memory\n");
  *((_DWORD *)a1 + 34) = 2;
  *((_DWORD *)a1 + 68) = -1;
  *((_DWORD *)a1 + 83) = 1;
  return result;
}

void xmlSAX2ExternalSubset(void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  uint64_t (*v8)(_QWORD, const xmlChar *, const xmlChar *);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  xmlCharEncoding v19;
  uint64_t v20;
  xmlChar *v21;
  xmlDict *v22;

  if (ctx
    && (unint64_t)ExternalID | (unint64_t)SystemID
    && (*((_DWORD *)ctx + 39) || *((_DWORD *)ctx + 108)))
  {
    if (*((_DWORD *)ctx + 6))
    {
      if (*((_QWORD *)ctx + 2))
      {
        if (*(_QWORD *)ctx)
        {
          v8 = *(uint64_t (**)(_QWORD, const xmlChar *, const xmlChar *))(*(_QWORD *)ctx + 32);
          if (v8)
          {
            v9 = v8(*((_QWORD *)ctx + 1), ExternalID, SystemID);
            if (v9)
            {
              v10 = v9;
              xmlNewDtd(*((xmlDocPtr *)ctx + 2), name, ExternalID, SystemID);
              v11 = *((_QWORD *)ctx + 7);
              v13 = *((_DWORD *)ctx + 16);
              v12 = *((_DWORD *)ctx + 17);
              v14 = *((_QWORD *)ctx + 9);
              v15 = *((_DWORD *)ctx + 102);
              v16 = *((_QWORD *)ctx + 5);
              *((_QWORD *)ctx + 5) = 0;
              v17 = xmlMalloc(0x28uLL);
              *((_QWORD *)ctx + 9) = v17;
              if (!v17)
              {
                xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2ExternalSubset");
                *((_QWORD *)ctx + 7) = v11;
                *((_DWORD *)ctx + 16) = v13;
                *((_DWORD *)ctx + 17) = v12;
                *((_QWORD *)ctx + 9) = v14;
                *((_DWORD *)ctx + 102) = v15;
                goto LABEL_23;
              }
              *((_QWORD *)ctx + 8) = 0x500000000;
              *((_QWORD *)ctx + 7) = 0;
              xmlPushInput((xmlParserCtxtPtr)ctx, (xmlParserInputPtr)v10);
              v18 = *((_QWORD *)ctx + 7);
              if (*(int *)(v18 + 48) >= 4)
              {
                v19 = xmlDetectCharEncoding(*(const unsigned __int8 **)(v18 + 32), 4);
                xmlSwitchEncoding((xmlParserCtxtPtr)ctx, v19);
              }
              if (!*(_QWORD *)(v10 + 8))
                *(_QWORD *)(v10 + 8) = xmlCanonicPath(SystemID);
              *(_QWORD *)(v10 + 52) = 0x100000001;
              v20 = *(_QWORD *)(*((_QWORD *)ctx + 7) + 32);
              *(_QWORD *)(v10 + 24) = v20;
              *(_QWORD *)(v10 + 32) = v20;
              *(_QWORD *)(v10 + 72) = 0;
              xmlParseExternalSubset((xmlParserCtxtPtr)ctx, ExternalID, SystemID);
              if (*((int *)ctx + 16) >= 2)
              {
                do
                  xmlPopInput((xmlParserCtxtPtr)ctx);
                while (*((int *)ctx + 16) > 1);
              }
              xmlFreeInputStream(*((xmlParserInputPtr *)ctx + 7));
              xmlFree(*((void **)ctx + 9));
              *((_QWORD *)ctx + 7) = v11;
              *((_DWORD *)ctx + 16) = v13;
              *((_DWORD *)ctx + 17) = v12;
              *((_QWORD *)ctx + 9) = v14;
              *((_DWORD *)ctx + 102) = v15;
              v21 = (xmlChar *)*((_QWORD *)ctx + 5);
              if (!v21)
                goto LABEL_23;
              v22 = (xmlDict *)*((_QWORD *)ctx + 57);
              if (v22)
              {
                if (xmlDictOwns(v22, v21))
                {
LABEL_23:
                  *((_QWORD *)ctx + 5) = v16;
                  return;
                }
                v21 = (xmlChar *)*((_QWORD *)ctx + 5);
              }
              xmlFree(v21);
              goto LABEL_23;
            }
          }
        }
      }
    }
  }
}

xmlParserInputPtr xmlSAX2ResolveEntity(void *ctx, const xmlChar *publicId, const xmlChar *systemId)
{
  xmlParserCtxt *ExternalEntity;
  uint64_t v5;
  const xmlChar *v6;
  xmlChar *v7;

  ExternalEntity = (xmlParserCtxt *)ctx;
  if (ctx)
  {
    v5 = *((_QWORD *)ctx + 7);
    if (!v5 || (v6 = *(const xmlChar **)(v5 + 8)) == 0)
      v6 = (const xmlChar *)*((_QWORD *)ctx + 35);
    v7 = xmlBuildURI(systemId, v6);
    ExternalEntity = (xmlParserCtxt *)xmlLoadExternalEntity((const char *)v7, (const char *)publicId, ExternalEntity);
    if (v7)
      xmlFree(v7);
  }
  return (xmlParserInputPtr)ExternalEntity;
}

xmlEntityPtr xmlSAX2GetEntity(void *ctx, const xmlChar *name)
{
  const xmlDoc *v4;
  xmlEntityPtr result;
  xmlEntity *DocEntity;
  const xmlDoc *v7;

  if (!ctx)
    return 0;
  if (*((_DWORD *)ctx + 84) || (DocEntity = xmlGetPredefinedEntity(name)) == 0)
  {
    v4 = (const xmlDoc *)*((_QWORD *)ctx + 2);
    if (!v4 || v4->standalone != 1)
      return xmlGetDocEntity(v4, name);
    if (*((_DWORD *)ctx + 84) == 2)
    {
      v4->standalone = 0;
      result = xmlGetDocEntity(v4, name);
      *(_DWORD *)(*((_QWORD *)ctx + 2) + 76) = 1;
      return result;
    }
    DocEntity = xmlGetDocEntity(v4, name);
    if (!DocEntity)
    {
      v7 = (const xmlDoc *)*((_QWORD *)ctx + 2);
      v7->standalone = 0;
      DocEntity = xmlGetDocEntity(v7, name);
      if (DocEntity)
        xmlFatalErrMsg_0(ctx, 103, "Entity(%s) document marked standalone but requires external subset\n", name);
      *(_DWORD *)(*((_QWORD *)ctx + 2) + 76) = 1;
    }
  }
  return DocEntity;
}

_DWORD *xmlFatalErrMsg_0(_DWORD *result, int a2, const char *a3, const xmlChar *a4)
{
  _DWORD *v4;

  v4 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
    v4[6] = 0;
    v4[38] = 0;
    if (!v4[112])
      v4[83] = 1;
  }
  return result;
}

xmlEntityPtr xmlSAX2GetParameterEntity(xmlEntityPtr ctx, const xmlChar *name)
{
  if (ctx)
    return xmlGetParameterEntity((xmlDocPtr)ctx->name, name);
  return ctx;
}

void xmlSAX2EntityDecl(void *ctx, const xmlChar *name, int type, const xmlChar *publicId, const xmlChar *systemId, xmlChar *content)
{
  int v9;
  xmlEntityPtr v10;
  uint64_t v11;
  const xmlChar *v12;
  void (*v13)(_QWORD, const char *, ...);

  if (!ctx)
    return;
  v9 = *((_DWORD *)ctx + 84);
  if (v9 != 2)
  {
    if (v9 != 1)
    {
      xmlFatalErrMsg_0(ctx, 104, "SAX.xmlSAX2EntityDecl(%s) called while not in subset\n", name);
      return;
    }
    v10 = xmlAddDocEntity(*((xmlDocPtr *)ctx + 2), name, type, publicId, systemId, content);
    if (!v10)
    {
      if (*((_DWORD *)ctx + 105) && (!*((_DWORD *)ctx + 83) || *((_DWORD *)ctx + 68) != -1))
      {
        *((_DWORD *)ctx + 34) = 107;
        __xmlRaiseError(0, 0, 0, ctx, 0, 1u, 107, 1, 0, 0, name, 0, 0, 0, 0, "Entity(%s) already defined in the internal subset\n", (char)name);
      }
      return;
    }
    goto LABEL_10;
  }
  v10 = xmlAddDtdEntity(*((xmlDocPtr *)ctx + 2), name, type, publicId, systemId, content);
  if (v10)
  {
LABEL_10:
    if (systemId && !v10->URI)
    {
      v11 = *((_QWORD *)ctx + 7);
      if (!v11 || (v12 = *(const xmlChar **)(v11 + 8)) == 0)
        v12 = (const xmlChar *)*((_QWORD *)ctx + 35);
      v10->URI = xmlBuildURI(systemId, v12);
    }
    return;
  }
  if (*((_DWORD *)ctx + 105))
  {
    if (*(_QWORD *)ctx)
    {
      v13 = *(void (**)(_QWORD, const char *, ...))(*(_QWORD *)ctx + 168);
      if (v13)
        v13(*((_QWORD *)ctx + 1), "Entity(%s) already defined in the external subset\n", (const char *)name);
    }
  }
}

void xmlSAX2AttributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname, int type, int def, const xmlChar *defaultValue, xmlEnumerationPtr tree)
{
  int v14;
  int v15;
  xmlChar *v16;
  int v17;
  xmlDtd *v18;
  xmlAttribute *v19;
  xmlDoc *v20;
  xmlChar *prefix;

  prefix = 0;
  if (ctx && *((_QWORD *)ctx + 2))
  {
    v14 = xmlStrEqual(fullname, (const xmlChar *)"xml:id");
    if (type != 2 && v14)
    {
      v15 = *((_DWORD *)ctx + 38);
      xmlErrValid(ctx, 540, "xml:id : attribute type should be ID\n", 0, 0);
      *((_DWORD *)ctx + 38) = v15;
    }
    v16 = xmlSplitQName((xmlParserCtxtPtr)ctx, fullname, &prefix);
    *((_DWORD *)ctx + 56) = 1;
    v17 = *((_DWORD *)ctx + 84);
    if (v17 == 2)
    {
      v18 = *(xmlDtd **)(*((_QWORD *)ctx + 2) + 88);
    }
    else
    {
      if (v17 != 1)
      {
        xmlFatalErrMsg_0(ctx, 1, "SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n", v16);
        xmlFree(v16);
        xmlFreeEnumeration(tree);
        return;
      }
      v18 = *(xmlDtd **)(*((_QWORD *)ctx + 2) + 80);
    }
    v19 = xmlAddAttributeDecl((xmlValidCtxtPtr)((char *)ctx + 160), v18, elem, v16, prefix, (xmlAttributeType)type, (xmlAttributeDefault)def, defaultValue, tree);
    if (!*((_DWORD *)ctx + 56))
      *((_DWORD *)ctx + 38) = 0;
    if (v19)
    {
      if (*((_DWORD *)ctx + 39))
      {
        if (*((_DWORD *)ctx + 6))
        {
          v20 = (xmlDoc *)*((_QWORD *)ctx + 2);
          if (v20->intSubset)
            *((_DWORD *)ctx + 38) &= xmlValidateAttributeDecl((xmlValidCtxtPtr)((char *)ctx + 160), v20, v19);
        }
      }
    }
    if (prefix)
      xmlFree(prefix);
    if (v16)
      xmlFree(v16);
  }
}

_DWORD *xmlErrValid(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  uint64_t v5;
  uint64_t v6;
  void (__cdecl *v7)(void *, xmlErrorPtr);

  v5 = (uint64_t)result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    v6 = *(_QWORD *)result;
    if (*(_QWORD *)result && *(_DWORD *)(v6 + 216) == -554844497)
      v7 = *(void (__cdecl **)(void *, xmlErrorPtr))(v6 + 248);
    else
      v7 = 0;
    result = __xmlRaiseError(v7, *(void (**)(void *, const char *, ...))(v5 + 168), *(void **)(v5 + 160), (_QWORD *)v5, 0, 4u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
    *(_DWORD *)(v5 + 152) = 0;
  }
  return result;
}

void xmlSAX2ElementDecl(void *ctx, const xmlChar *name, int type, xmlElementContentPtr content)
{
  uint64_t v5;
  int v6;
  xmlDtdPtr *v7;
  xmlElement *v8;
  xmlDoc *v9;

  if (ctx)
  {
    v5 = *((_QWORD *)ctx + 2);
    if (v5)
    {
      v6 = *((_DWORD *)ctx + 84);
      if (v6 == 2)
      {
        v7 = (xmlDtdPtr *)(v5 + 88);
      }
      else
      {
        if (v6 != 1)
        {
          xmlFatalErrMsg_0(ctx, 1, "SAX.xmlSAX2ElementDecl(%s) called while not in subset\n", name);
          return;
        }
        v7 = (xmlDtdPtr *)(v5 + 80);
      }
      v8 = xmlAddElementDecl((xmlValidCtxtPtr)((char *)ctx + 160), *v7, name, (xmlElementTypeVal)type, content);
      if (!v8)
        *((_DWORD *)ctx + 38) = 0;
      if (*((_DWORD *)ctx + 39))
      {
        if (*((_DWORD *)ctx + 6))
        {
          v9 = (xmlDoc *)*((_QWORD *)ctx + 2);
          if (v9)
          {
            if (v9->intSubset)
              *((_DWORD *)ctx + 38) &= xmlValidateElementDecl((xmlValidCtxtPtr)((char *)ctx + 160), v9, v8);
          }
        }
      }
    }
  }
}

void xmlSAX2NotationDecl(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId)
{
  uint64_t v5;
  const char *v6;
  int v7;
  xmlDtdPtr *v8;
  xmlNotation *v9;
  xmlDoc *v10;

  if (ctx)
  {
    v5 = *((_QWORD *)ctx + 2);
    if (v5)
    {
      if (!((unint64_t)publicId | (unint64_t)systemId))
      {
        v6 = "SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\n";
LABEL_17:
        xmlFatalErrMsg_0(ctx, 105, v6, name);
        return;
      }
      v7 = *((_DWORD *)ctx + 84);
      if (v7 == 2)
      {
        v8 = (xmlDtdPtr *)(v5 + 88);
      }
      else
      {
        if (v7 != 1)
        {
          v6 = "SAX.xmlSAX2NotationDecl(%s) called while not in subset\n";
          goto LABEL_17;
        }
        v8 = (xmlDtdPtr *)(v5 + 80);
      }
      v9 = xmlAddNotationDecl((xmlValidCtxtPtr)((char *)ctx + 160), *v8, name, publicId, systemId);
      if (!v9)
        *((_DWORD *)ctx + 38) = 0;
      if (*((_DWORD *)ctx + 39) && *((_DWORD *)ctx + 6))
      {
        v10 = (xmlDoc *)*((_QWORD *)ctx + 2);
        if (v10->intSubset)
          *((_DWORD *)ctx + 38) &= xmlValidateNotationDecl((xmlValidCtxtPtr)((char *)ctx + 160), v10, v9);
      }
    }
  }
}

void xmlSAX2UnparsedEntityDecl(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId, const xmlChar *notationName)
{
  int v7;
  xmlEntityPtr v8;
  void (*v9)(uint64_t, const char *);
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  const xmlChar *v13;

  if (!ctx)
    return;
  v7 = *((_DWORD *)ctx + 84);
  if (v7 != 2)
  {
    if (v7 != 1)
    {
      xmlFatalErrMsg_0(ctx, 1, "SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n", name);
      return;
    }
    v8 = xmlAddDocEntity(*((xmlDocPtr *)ctx + 2), name, 3, publicId, systemId, notationName);
    if (!v8)
    {
      if (*((_DWORD *)ctx + 105))
      {
        if (*(_QWORD *)ctx)
        {
          v9 = *(void (**)(uint64_t, const char *))(*(_QWORD *)ctx + 168);
          if (v9)
          {
            v10 = *((_QWORD *)ctx + 1);
            v11 = "Entity(%s) already defined in the internal subset\n";
LABEL_21:
            v9(v10, v11);
            return;
          }
        }
      }
      return;
    }
LABEL_10:
    if (systemId && !v8->URI)
    {
      v12 = *((_QWORD *)ctx + 7);
      if (!v12 || (v13 = *(const xmlChar **)(v12 + 8)) == 0)
        v13 = (const xmlChar *)*((_QWORD *)ctx + 35);
      v8->URI = xmlBuildURI(systemId, v13);
    }
    return;
  }
  v8 = xmlAddDtdEntity(*((xmlDocPtr *)ctx + 2), name, 3, publicId, systemId, notationName);
  if (v8)
    goto LABEL_10;
  if (*((_DWORD *)ctx + 105))
  {
    if (*(_QWORD *)ctx)
    {
      v9 = *(void (**)(uint64_t, const char *))(*(_QWORD *)ctx + 168);
      if (v9)
      {
        v10 = *((_QWORD *)ctx + 1);
        v11 = "Entity(%s) already defined in the external subset\n";
        goto LABEL_21;
      }
    }
  }
}

void xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
{
  uint64_t v5;
  _xmlNode *children;
  xmlChar *v8;
  xmlNodePtr v9;
  xmlNode *v10;
  xmlNode *v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  xmlChar *v15;
  xmlChar *v16;
  xmlChar **v17;
  uint64_t v18;
  xmlDtd *v19;
  xmlChar *v20;
  xmlElementPtr DtdQElementDesc;
  xmlElementPtr v22;
  int v23;
  xmlChar **v24;
  BOOL v25;
  int v26;
  xmlElementPtr v27;
  const xmlChar **v28;
  xmlAttribute *attributes;
  uint64_t v30;
  const xmlChar *v32;
  xmlChar *v33;
  xmlChar *v34;
  xmlChar *v35;
  xmlChar *v36;
  const xmlChar *v37;
  const xmlChar **v38;
  const xmlChar *v39;
  const xmlChar *v40;
  xmlAttributePtr DtdQAttrDesc;
  xmlChar *v43;
  xmlChar *v44;
  const xmlChar *v45;
  const xmlChar **v46;
  const xmlChar *v47;
  xmlChar *v48;
  xmlChar *v49;
  xmlChar **v50;
  BOOL v51;
  xmlNsPtr v52;
  xmlNsPtr v53;
  const xmlChar *href;
  xmlNode *node;
  const xmlChar **v56;
  int v57;
  xmlChar *prefix;
  xmlChar memory[16];
  __int128 v60;
  __int128 v61;
  __int16 v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (ctx)
  {
    if (fullname)
    {
      v5 = *((_QWORD *)ctx + 2);
      if (v5)
      {
        children = (_xmlNode *)*((_QWORD *)ctx + 10);
        if (*((_DWORD *)ctx + 39))
        {
          if (!*(_QWORD *)(v5 + 88))
          {
            v12 = *(_QWORD **)(v5 + 80);
            if (!v12 || !v12[9] && !v12[10] && !v12[11] && !v12[12])
            {
              xmlErrValid(ctx, 94, "Validation failed: no DTD found !", 0, 0);
              *((_DWORD *)ctx + 39) = 0;
            }
          }
        }
        prefix = 0;
        v8 = xmlSplitQName((xmlParserCtxtPtr)ctx, fullname, &prefix);
        v9 = xmlNewDocNodeEatName(*((xmlDocPtr *)ctx + 2), 0, v8, 0);
        if (v9)
        {
          v10 = v9;
          v11 = (xmlNode *)*((_QWORD *)ctx + 2);
          if (v11->children)
          {
            if (!children)
              children = v11->children;
          }
          else
          {
            xmlAddChild(v11, v10);
          }
          *((_DWORD *)ctx + 104) = -1;
          if (*((_DWORD *)ctx + 109))
          {
            v13 = *((_QWORD *)ctx + 7);
            if (v13)
            {
              v14 = *(_DWORD *)(v13 + 52);
              if (v14 >= 0xFFFF)
                LOWORD(v14) = -1;
              v10->line = v14;
            }
          }
          if (nodePush((xmlParserCtxtPtr)ctx, v10) < 0)
          {
            xmlUnlinkNode(v10);
            xmlFreeNode(v10);
LABEL_63:
            if (prefix)
              xmlFree(prefix);
            return;
          }
          if (children)
          {
            if (children->type == XML_ELEMENT_NODE)
              xmlAddChild(children, v10);
            else
              xmlAddSibling(children, v10);
          }
          if (*((_DWORD *)ctx + 13))
          {
LABEL_33:
            if (atts)
            {
              v15 = (xmlChar *)*atts;
              v16 = (xmlChar *)atts[1];
              if (*((_DWORD *)ctx + 13))
              {
                if (v15)
                {
                  v17 = (xmlChar **)(atts + 3);
                  do
                  {
                    xmlSAX2AttributeInternal((uint64_t *)ctx, v15, v16, 0);
                    v15 = *(v17 - 1);
                    v16 = *v17;
                    v17 += 2;
                  }
                  while (v15);
                }
              }
              else if (v15 && v16)
              {
                v24 = (xmlChar **)(atts + 3);
                do
                {
                  if (*v15 != 120 || v15[1] != 109 || v15[2] != 108 || v15[3] != 110 || v15[4] != 115)
                    xmlSAX2AttributeInternal((uint64_t *)ctx, v15, v16, 0);
                  v15 = *(v24 - 1);
                  v16 = *v24;
                  v24 += 2;
                  if (v15)
                    v25 = v16 == 0;
                  else
                    v25 = 1;
                }
                while (!v25);
              }
            }
            if (*((_DWORD *)ctx + 39) && *((_DWORD *)ctx + 52) == -1412623820)
            {
              v26 = xmlValidateDtdFinal((xmlValidCtxtPtr)((char *)ctx + 160), *((xmlDocPtr *)ctx + 2));
              if (v26 <= 0)
              {
                *((_DWORD *)ctx + 38) = 0;
                if (v26 < 0)
                  *((_DWORD *)ctx + 6) = 0;
              }
              *((_DWORD *)ctx + 38) &= xmlValidateRoot((xmlValidCtxtPtr)((char *)ctx + 160), *((xmlDocPtr *)ctx + 2));
              *((_DWORD *)ctx + 52) = -1412623819;
            }
            goto LABEL_63;
          }
          node = children;
          v18 = *((_QWORD *)ctx + 2);
          v19 = *(xmlDtd **)(v18 + 80);
          if (v19 || *(_QWORD *)(v18 + 88))
          {
            v20 = prefix;
            DtdQElementDesc = xmlGetDtdQElementDesc(v19, v8, prefix);
            if (DtdQElementDesc)
            {
              v22 = DtdQElementDesc;
              v23 = 1;
              goto LABEL_68;
            }
            v27 = xmlGetDtdQElementDesc(*(xmlDtdPtr *)(*((_QWORD *)ctx + 2) + 88), v8, v20);
            if (v27)
            {
              v22 = v27;
              v23 = 0;
LABEL_68:
              v28 = atts + 2;
              while (1)
              {
                v57 = v23;
                attributes = v22->attributes;
                v30 = *((_QWORD *)ctx + 2);
                if (*(_DWORD *)(v30 + 76) == 1)
                {
                  if (*(_QWORD *)(v30 + 88))
                  {
                    if (*((_DWORD *)ctx + 39) && attributes != 0)
                    {
                      v56 = v28;
                      do
                      {
                        if (attributes->defaultValue
                          && xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(*((_QWORD *)ctx + 2) + 88), attributes->elem, attributes->name, attributes->prefix) == attributes&& !xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(*((_QWORD *)ctx + 2) + 80), attributes->elem, attributes->name, attributes->prefix))
                        {
                          v32 = attributes->prefix;
                          if (v32)
                          {
                            v33 = xmlStrdup(v32);
                            v34 = xmlStrcat(v33, (const xmlChar *)":");
                            v35 = xmlStrcat(v34, attributes->name);
                          }
                          else
                          {
                            v35 = xmlStrdup(attributes->name);
                          }
                          v36 = v35;
                          if (!v35)
                          {
                            xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2StartElement");
                            v28 = v56;
                            break;
                          }
                          if (atts && (v37 = *atts) != 0)
                          {
                            v38 = v56;
                            while (!xmlStrEqual(v37, v36))
                            {
                              v39 = *v38;
                              v38 += 2;
                              v37 = v39;
                              if (!v39)
                                goto LABEL_88;
                            }
                          }
                          else
                          {
LABEL_88:
                            xmlErrValid(ctx, 538, "standalone: attribute %s on %s defaulted from external subset\n", v36, (xmlChar *)attributes->elem);
                          }
                          xmlFree(v36);
                          v28 = v56;
                        }
                        attributes = attributes->nexth;
                      }
                      while (attributes);
                    }
                  }
                  attributes = v22->attributes;
                }
                if (attributes)
                  break;
LABEL_115:
                if (v57 == 1)
                {
                  v22 = xmlGetDtdQElementDesc(*(xmlDtdPtr *)(*((_QWORD *)ctx + 2) + 88), v8, v20);
                  v23 = 0;
                  if (v22)
                    continue;
                }
                goto LABEL_120;
              }
              while (1)
              {
                if (!attributes->defaultValue)
                  goto LABEL_114;
                v40 = attributes->prefix;
                if (v40)
                {
                  if (xmlStrEqual(v40, (const xmlChar *)"xmlns"))
                    goto LABEL_99;
                  if (attributes->prefix)
                    goto LABEL_98;
                }
                if (!xmlStrEqual(attributes->name, (const xmlChar *)"xmlns"))
                {
LABEL_98:
                  if ((*((_BYTE *)ctx + 432) & 4) == 0)
                    goto LABEL_114;
                }
LABEL_99:
                DtdQAttrDesc = xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(*((_QWORD *)ctx + 2) + 80), attributes->elem, attributes->name, attributes->prefix);
                if (DtdQAttrDesc == attributes || DtdQAttrDesc == 0)
                {
                  v62 = 0;
                  v60 = 0u;
                  v61 = 0u;
                  *(_OWORD *)memory = 0u;
                  v43 = xmlBuildQName(attributes->name, attributes->prefix, memory, 50);
                  if (!v43)
                  {
                    xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2StartElement");
                    break;
                  }
                  v44 = v43;
                  if (atts && (v45 = *atts) != 0)
                  {
                    v46 = v28;
                    while (!xmlStrEqual(v45, v44))
                    {
                      v47 = *v46;
                      v46 += 2;
                      v45 = v47;
                      if (!v47)
                        goto LABEL_110;
                    }
                  }
                  else
                  {
LABEL_110:
                    xmlSAX2AttributeInternal((uint64_t *)ctx, v44, (xmlChar *)attributes->defaultValue, v20);
                  }
                  if (v44 != memory && v44 != attributes->name)
                    xmlFree(v44);
                }
LABEL_114:
                attributes = attributes->nexth;
                if (!attributes)
                  goto LABEL_115;
              }
            }
          }
LABEL_120:
          if (atts)
          {
            v48 = (xmlChar *)*atts;
            if (*atts)
            {
              v49 = (xmlChar *)atts[1];
              if (v49)
              {
                v50 = (xmlChar **)(atts + 3);
                do
                {
                  if (*v48 == 120 && v48[1] == 109 && v48[2] == 108 && v48[3] == 110 && v48[4] == 115)
                    xmlSAX2AttributeInternal((uint64_t *)ctx, v48, v49, prefix);
                  v48 = *(v50 - 1);
                  v49 = *v50;
                  v50 += 2;
                  if (v48)
                    v51 = v49 == 0;
                  else
                    v51 = 1;
                }
                while (!v51);
              }
            }
          }
          v52 = xmlSearchNs(*((xmlDocPtr *)ctx + 2), v10, prefix);
          v53 = v52;
          if (node && !v52)
            v53 = xmlSearchNs(*((xmlDocPtr *)ctx + 2), node, prefix);
          if (prefix && !v53)
          {
            v53 = xmlNewNs(v10, 0, prefix);
            xmlNsWarnMsg(ctx, 201, "Namespace prefix %s is not defined\n", prefix, 0);
          }
          if (v53)
          {
            href = v53->href;
            if (href)
            {
              if (*href || v53->prefix)
                xmlSetNs(v10, v53);
            }
          }
          goto LABEL_33;
        }
        if (prefix)
          xmlFree(prefix);
        xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2StartElement");
      }
    }
  }
}

void xmlSAX2AttributeInternal(uint64_t *ctxt, xmlChar *name, xmlChar *a3, const xmlChar *a4)
{
  xmlChar *v8;
  xmlChar *v9;
  xmlChar *v10;
  xmlChar *v11;
  int v12;
  xmlChar *v13;
  xmlURIPtr v14;
  xmlURI *v15;
  xmlNs *v16;
  xmlDocPtr v17;
  xmlURIPtr v18;
  xmlURI *v19;
  xmlNsPtr v20;
  _xmlAttr *v21;
  xmlNs *ns;
  xmlAttrPtr v23;
  xmlNodePtr v24;
  xmlNodePtr NodeList;
  _xmlNode *v26;
  xmlDocPtr v27;
  xmlValidCtxt *v28;
  xmlChar *v29;
  xmlChar *v30;
  xmlChar *v31;
  xmlChar *v32;
  warningSAXFunc v33;
  warningSAXFunc v34;
  xmlNs *v35;
  xmlDocPtr v36;
  xmlChar *prefix;

  prefix = 0;
  if (*((_DWORD *)ctxt + 13))
  {
    v8 = xmlStrdup(name);
    prefix = 0;
    if (!v8)
    {
LABEL_16:
      xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
      goto LABEL_104;
    }
  }
  else
  {
    v9 = xmlSplitQName((xmlParserCtxtPtr)ctxt, name, &prefix);
    if (!v9)
      goto LABEL_16;
    v8 = v9;
    if (!*v9)
    {
      if (xmlStrEqual(prefix, (const xmlChar *)"xmlns"))
        xmlNsErrMsg(ctxt, 35, "invalid namespace declaration '%s'\n", name, 0);
      else
        xmlNsWarnMsg(ctxt, 106, "Avoid attribute ending with ':' like '%s'\n", name, 0);
      if (prefix)
        xmlFree(prefix);
      prefix = 0;
      xmlFree(v8);
      v8 = xmlStrdup(name);
      if (!v8)
        goto LABEL_16;
    }
  }
  if (!a3 && *((_DWORD *)ctxt + 13) && htmlIsBooleanAttr(name))
  {
    a3 = xmlStrdup(name);
    v10 = a3;
  }
  else
  {
    *((_DWORD *)ctxt + 56) = 1;
    v11 = xmlValidCtxtNormalizeAttributeValue((xmlValidCtxtPtr)(ctxt + 20), (xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], name, a3);
    v10 = v11;
    if (*((_DWORD *)ctxt + 56) != 1)
      *((_DWORD *)ctxt + 38) = 0;
    if (v11)
      a3 = v11;
  }
  v12 = *((_DWORD *)ctxt + 13);
  if (!v12 && !prefix)
  {
    if (*v8 == 120 && v8[1] == 109 && v8[2] == 108 && v8[3] == 110 && v8[4] == 115 && !v8[5])
    {
      v13 = a3;
      if (*((_DWORD *)ctxt + 7)
        || (++*((_DWORD *)ctxt + 98),
            v13 = xmlStringDecodeEntities((xmlParserCtxtPtr)ctxt, a3, 1, 0, 0, 0),
            --*((_DWORD *)ctxt + 98),
            v13))
      {
        if (*v13)
        {
          v14 = xmlParseURI((const char *)v13);
          if (v14)
          {
            v15 = v14;
            if (!v14->scheme)
            {
              if (*ctxt)
              {
                v34 = *(warningSAXFunc *)(*ctxt + 168);
                if (v34)
                  v34((void *)ctxt[1], "xmlns: URI %s is not absolute\n", (const char *)v13);
              }
            }
            xmlFreeURI(v15);
          }
          else if (*ctxt)
          {
            v33 = *(warningSAXFunc *)(*ctxt + 168);
            if (v33)
              v33((void *)ctxt[1], "xmlns: %s not a valid URI\n", (const char *)v13);
          }
        }
        v16 = xmlNewNs((xmlNodePtr)ctxt[10], v13, 0);
        if (v16)
        {
          if (*((_DWORD *)ctxt + 39))
          {
            if (*((_DWORD *)ctxt + 6))
            {
              v17 = (xmlDocPtr)ctxt[2];
              if (v17)
              {
                if (v17->intSubset)
                  *((_DWORD *)ctxt + 38) &= xmlValidateOneNamespace((xmlValidCtxtPtr)(ctxt + 20), v17, (xmlNodePtr)ctxt[10], a4, v16, v13);
              }
            }
          }
        }
        xmlFree(v8);
        if (v10)
LABEL_132:
          ((void (*)(xmlChar *))xmlFree)(v10);
LABEL_133:
        if (v13 == a3)
          return;
        goto LABEL_105;
      }
      xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
      ((void (*)(xmlChar *))xmlFree)(v8);
      goto LABEL_122;
    }
    goto LABEL_70;
  }
  if (v12 || !prefix)
  {
    if (!prefix)
    {
LABEL_70:
      v20 = 0;
      goto LABEL_72;
    }
LABEL_62:
    v20 = xmlSearchNs((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], prefix);
    if (v20)
    {
      v21 = *(_xmlAttr **)(ctxt[10] + 88);
      if (v21)
      {
        while (1)
        {
          if (v21->ns)
          {
            if (xmlStrEqual(v8, v21->name))
            {
              ns = v21->ns;
              if (v20 == ns || xmlStrEqual(v20->href, ns->href))
                break;
            }
          }
          v21 = v21->next;
          if (!v21)
            goto LABEL_72;
        }
        xmlNsErrMsg(ctxt, 42, "Attribute %s in %s redefined\n", v8, (xmlChar *)v20->href);
        *((_DWORD *)ctxt + 6) = 0;
        if (!*((_DWORD *)ctxt + 112))
          *((_DWORD *)ctxt + 83) = 1;
        ((void (*)(xmlChar *))xmlFree)(v8);
        goto LABEL_102;
      }
    }
    else
    {
      xmlNsErrMsg(ctxt, 201, "Namespace prefix %s of attribute %s is not defined\n", prefix, v8);
    }
LABEL_72:
    v23 = xmlNewNsPropEatName((xmlNodePtr)ctxt[10], v20, v8, 0);
    if (v23)
    {
      if (*((_DWORD *)ctxt + 7) || *((_DWORD *)ctxt + 13))
      {
        if (a3)
        {
          v24 = xmlNewDocText((const xmlDoc *)ctxt[2], a3);
          v23->children = v24;
          v23->last = v24;
          if (v24)
            v24->parent = (_xmlNode *)v23;
        }
      }
      else
      {
        NodeList = xmlStringGetNodeList((const xmlDoc *)ctxt[2], a3);
        v23->children = NodeList;
        if (NodeList)
        {
          do
          {
            v26 = NodeList;
            NodeList->parent = (_xmlNode *)v23;
            NodeList = NodeList->next;
          }
          while (NodeList);
          v23->last = v26;
        }
      }
    }
    if (!*((_DWORD *)ctxt + 13)
      && *((_DWORD *)ctxt + 39)
      && *((_DWORD *)ctxt + 6)
      && (v27 = (xmlDocPtr)ctxt[2]) != 0
      && v27->intSubset)
    {
      if (*((_DWORD *)ctxt + 7))
      {
        v28 = (xmlValidCtxt *)(ctxt + 20);
      }
      else
      {
        ++*((_DWORD *)ctxt + 98);
        v29 = xmlStringDecodeEntities((xmlParserCtxtPtr)ctxt, a3, 1, 0, 0, 0);
        --*((_DWORD *)ctxt + 98);
        if (v29)
        {
          v30 = v29;
          v31 = xmlValidNormalizeAttributeValue((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], name, v29);
          if (v31)
          {
            v32 = v31;
            xmlFree(v30);
            v30 = v32;
          }
          *((_DWORD *)ctxt + 38) &= xmlValidateOneAttribute((xmlValidCtxtPtr)(ctxt + 20), (xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], v23, v30);
          ((void (*)(xmlChar *))xmlFree)(v30);
          goto LABEL_102;
        }
        v28 = (xmlValidCtxt *)(ctxt + 20);
        v27 = (xmlDocPtr)ctxt[2];
      }
      *((_DWORD *)ctxt + 38) &= xmlValidateOneAttribute(v28, v27, (xmlNodePtr)ctxt[10], v23, a3);
    }
    else
    {
      if ((ctxt[54] & 8) != 0)
        goto LABEL_102;
      if (*((_DWORD *)ctxt + 7))
      {
        if (*((_DWORD *)ctxt + 84))
          goto LABEL_102;
      }
      else if (*((_DWORD *)ctxt + 37) == 2)
      {
        goto LABEL_102;
      }
      if (xmlStrEqual(name, (const xmlChar *)"xml:id"))
      {
        if (xmlValidateNCName(a3, 1))
          xmlErrValid(ctxt, 539, "xml:id : attribute value %s is not an NCName\n", a3, 0);
      }
      else if (!xmlIsID((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], v23))
      {
        if (xmlIsRef((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], v23))
          xmlAddRef((xmlValidCtxtPtr)(ctxt + 20), (xmlDocPtr)ctxt[2], a3, v23);
        goto LABEL_102;
      }
      xmlAddID((xmlValidCtxtPtr)(ctxt + 20), (xmlDocPtr)ctxt[2], a3, v23);
    }
LABEL_102:
    if (v10)
      xmlFree(v10);
LABEL_104:
    v13 = prefix;
    if (!prefix)
      return;
    goto LABEL_105;
  }
  if (*prefix != 120 || prefix[1] != 109 || prefix[2] != 108 || prefix[3] != 110 || prefix[4] != 115 || prefix[5])
    goto LABEL_62;
  v13 = a3;
  if (*((_DWORD *)ctxt + 7)
    || (++*((_DWORD *)ctxt + 98),
        v13 = xmlStringDecodeEntities((xmlParserCtxtPtr)ctxt, a3, 1, 0, 0, 0),
        --*((_DWORD *)ctxt + 98),
        v13))
  {
    if (!*v13)
      xmlNsErrMsg(ctxt, 204, "Empty namespace name for prefix %s\n", v8, 0);
    if (*((_DWORD *)ctxt + 105) && *v13)
    {
      v18 = xmlParseURI((const char *)v13);
      if (v18)
      {
        v19 = v18;
        if (!v18->scheme)
          xmlNsWarnMsg(ctxt, 100, "xmlns:%s: URI %s is not absolute\n", v8, a3);
        xmlFreeURI(v19);
      }
      else
      {
        xmlNsWarnMsg(ctxt, 99, "xmlns:%s: %s not a valid URI\n", v8, a3);
      }
    }
    v35 = xmlNewNs((xmlNodePtr)ctxt[10], v13, v8);
    xmlFree(prefix);
    if (v35)
    {
      if (*((_DWORD *)ctxt + 39))
      {
        if (*((_DWORD *)ctxt + 6))
        {
          v36 = (xmlDocPtr)ctxt[2];
          if (v36)
          {
            if (v36->intSubset)
              *((_DWORD *)ctxt + 38) &= xmlValidateOneNamespace((xmlValidCtxtPtr)(ctxt + 20), v36, (xmlNodePtr)ctxt[10], a4, v35, a3);
          }
        }
      }
    }
    xmlFree(v8);
    if (v10)
      goto LABEL_132;
    goto LABEL_133;
  }
  xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
  xmlFree(prefix);
  ((void (*)(xmlChar *))xmlFree)(v8);
LABEL_122:
  v13 = v10;
  if (v10)
LABEL_105:
    xmlFree(v13);
}

_DWORD *xmlNsWarnMsg(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    return __xmlRaiseError(0, 0, 0, result, 0, 3u, a2, 1, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
  }
  return result;
}

void xmlSAX2EndElement(void *ctx, const xmlChar *name)
{
  xmlNode *v3;
  xmlDoc *v4;

  if (ctx)
  {
    v3 = (xmlNode *)*((_QWORD *)ctx + 10);
    *((_DWORD *)ctx + 104) = -1;
    if (*((_DWORD *)ctx + 39))
    {
      if (*((_DWORD *)ctx + 6))
      {
        v4 = (xmlDoc *)*((_QWORD *)ctx + 2);
        if (v4)
        {
          if (v4->intSubset)
            *((_DWORD *)ctx + 38) &= xmlValidateOneElement((xmlValidCtxtPtr)((char *)ctx + 160), v4, v3);
        }
      }
    }
    nodePop((xmlParserCtxtPtr)ctx);
  }
}

void xmlSAX2Reference(void *ctx, const xmlChar *name)
{
  xmlDoc *v3;
  xmlNode *v4;
  xmlNode *v5;

  if (ctx)
  {
    v3 = (xmlDoc *)*((_QWORD *)ctx + 2);
    if (*name == 35)
      v4 = xmlNewCharRef(v3, name);
    else
      v4 = xmlNewReference(v3, name);
    v5 = v4;
    if (!xmlAddChild(*((xmlNodePtr *)ctx + 10), v4))
      xmlFreeNode(v5);
  }
}

void xmlSAX2ProcessingInstruction(void *ctx, const xmlChar *target, const xmlChar *data)
{
  uint64_t v4;
  xmlNodePtr v5;
  xmlNode *v6;
  uint64_t v7;
  int v8;
  int v9;
  xmlNode *v10;

  if (ctx)
  {
    v4 = *((_QWORD *)ctx + 10);
    v5 = xmlNewDocPI(*((xmlDocPtr *)ctx + 2), target, data);
    if (v5)
    {
      v6 = v5;
      if (*((_DWORD *)ctx + 109))
      {
        v7 = *((_QWORD *)ctx + 7);
        if (v7)
        {
          v8 = *(_DWORD *)(v7 + 52);
          if (v8 >= 0xFFFF)
            LOWORD(v8) = -1;
          v5->line = v8;
        }
      }
      v9 = *((_DWORD *)ctx + 84);
      if (v9 == 2)
      {
        v10 = *(xmlNode **)(*((_QWORD *)ctx + 2) + 88);
      }
      else if (v9 == 1)
      {
        v10 = *(xmlNode **)(*((_QWORD *)ctx + 2) + 80);
      }
      else if (v4)
      {
        v10 = (xmlNode *)v4;
        if (*(_DWORD *)(v4 + 8) != 1)
        {
          xmlAddSibling((xmlNodePtr)v4, v6);
          return;
        }
      }
      else
      {
        v10 = (xmlNode *)*((_QWORD *)ctx + 2);
      }
      xmlAddChild(v10, v6);
    }
  }
}

void xmlSAX2CDataBlock(void *ctx, const xmlChar *value, int len)
{
  xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4);
}

int xmlSAXDefaultVersion(int version)
{
  int result;

  if ((version - 3) < 0xFFFFFFFE)
    return -1;
  result = xmlSAX2DefaultVersionValue;
  xmlSAX2DefaultVersionValue = version;
  return result;
}

void xmlSAX2InitDefaultSAXHandler(xmlSAXHandler *hdlr, int warning)
{
  void (*v4)(void *, const char *, ...);

  if (hdlr && !hdlr->initialized)
  {
    xmlSAXVersion(hdlr, xmlSAX2DefaultVersionValue);
    v4 = xmlParserWarning;
    if (!warning)
      v4 = 0;
    hdlr->warning = v4;
  }
}

void xmlSAX2InitDocbDefaultSAXHandler(xmlSAXHandler *hdlr)
{
  if (hdlr)
  {
    if (!hdlr->initialized)
    {
      hdlr->internalSubset = xmlSAX2InternalSubset;
      hdlr->isStandalone = xmlSAX2IsStandalone;
      hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
      hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
      hdlr->resolveEntity = xmlSAX2ResolveEntity;
      hdlr->getEntity = xmlSAX2GetEntity;
      hdlr->entityDecl = xmlSAX2EntityDecl;
      *(_OWORD *)&hdlr->notationDecl = 0u;
      *(_OWORD *)&hdlr->elementDecl = 0u;
      hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
      hdlr->startDocument = xmlSAX2StartDocument;
      hdlr->endDocument = xmlSAX2EndDocument;
      hdlr->startElement = xmlSAX2StartElement;
      hdlr->endElement = xmlSAX2EndElement;
      hdlr->reference = xmlSAX2Reference;
      hdlr->cdataBlock = 0;
      hdlr->externalSubset = 0;
      hdlr->characters = xmlSAX2Characters;
      hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
      hdlr->processingInstruction = 0;
      hdlr->comment = xmlSAX2Comment;
      hdlr->warning = xmlParserWarning;
      hdlr->error = xmlParserError;
      hdlr->fatalError = xmlParserError;
      hdlr->getParameterEntity = 0;
      hdlr->initialized = 1;
    }
  }
}

void docbDefaultSAXHandlerInit(void)
{
  xmlSAXHandler *v0;

  v0 = (xmlSAXHandler *)__docbDefaultSAXHandler();
  xmlSAX2InitDocbDefaultSAXHandler(v0);
}

_DWORD *xmlNsErrMsg(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    return __xmlRaiseError(0, 0, 0, result, 0, 3u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
  }
  return result;
}

xmlChar *xmlSAX2DecodeAttrEntities(xmlParserCtxtPtr ctxt, const xmlChar *a2, unint64_t a3)
{
  const xmlChar *v4;
  int v5;
  xmlChar *result;

  v4 = a2;
  while ((unint64_t)v4 < a3)
  {
    v5 = *v4++;
    if (v5 == 38)
    {
      ++ctxt->depth;
      result = xmlStringLenDecodeEntities(ctxt, a2, (int)a3 - (int)a2, 1, 0, 0, 0);
      --ctxt->depth;
      return result;
    }
  }
  return 0;
}

void xmlSchematronFree(xmlSchematronPtr schema)
{
  xmlDoc *v2;
  void *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  xmlXPathCompExpr *v9;
  void *v10;
  void *v11;
  xmlPattern *v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;

  if (schema)
  {
    v2 = (xmlDoc *)*((_QWORD *)schema + 2);
    if (v2 && !*((_DWORD *)schema + 2))
      xmlFreeDoc(v2);
    v3 = (void *)*((_QWORD *)schema + 11);
    if (v3)
      xmlFree(v3);
    v4 = (_QWORD *)*((_QWORD *)schema + 9);
    if (v4)
    {
      do
      {
        v5 = (_QWORD *)*v4;
        v6 = (_QWORD *)v4[4];
        if (v6)
        {
          do
          {
            v7 = (_QWORD *)*v6;
            v8 = (void *)v6[3];
            if (v8)
              xmlFree(v8);
            v9 = (xmlXPathCompExpr *)v6[4];
            if (v9)
              xmlXPathFreeCompExpr(v9);
            v10 = (void *)v6[5];
            if (v10)
              xmlFree(v10);
            xmlFree(v6);
            v6 = v7;
          }
          while (v7);
        }
        v11 = (void *)v4[3];
        if (v11)
          xmlFree(v11);
        v12 = (xmlPattern *)v4[5];
        if (v12)
          xmlFreePattern(v12);
        v13 = (void *)v4[6];
        if (v13)
          xmlFree(v13);
        xmlFree(v4);
        v4 = v5;
      }
      while (v5);
    }
    v14 = (_QWORD *)*((_QWORD *)schema + 8);
    if (v14)
    {
      do
      {
        v15 = (_QWORD *)*v14;
        v16 = (void *)v14[2];
        if (v16)
          xmlFree(v16);
        xmlFree(v14);
        v14 = v15;
      }
      while (v15);
    }
    xmlDictFree(*((xmlDictPtr *)schema + 5));
    xmlFree(schema);
  }
}

xmlSchematronParserCtxtPtr xmlSchematronNewParserCtxt(const char *URL)
{
  xmlSchematronParserCtxt *v2;
  xmlSchematronParserCtxt *v3;
  xmlDict *v4;
  xmlXPathContextPtr v5;

  if (!URL)
    return 0;
  v2 = (xmlSchematronParserCtxt *)xmlMalloc(0x90uLL);
  v3 = v2;
  if (!v2)
  {
    __xmlSimpleError(0x10u, 2, 0, 0, (const xmlChar *)"allocating schema parser context");
    return v3;
  }
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *(_OWORD *)v2 = 0u;
  *(_DWORD *)v2 = 1;
  v4 = xmlDictCreate();
  *((_QWORD *)v3 + 6) = v4;
  *((_QWORD *)v3 + 1) = xmlDictLookup(v4, (const xmlChar *)URL, -1);
  *((_QWORD *)v3 + 13) = 0;
  v5 = xmlXPathNewContext(0);
  *((_QWORD *)v3 + 8) = v5;
  if (!v5)
  {
    __xmlSimpleError(0x10u, 2, 0, 0, (const xmlChar *)"allocating schema parser XPath context");
    xmlSchematronFreeParserCtxt(v3);
    return 0;
  }
  v5->flags = 1;
  return v3;
}

void xmlSchematronFreeParserCtxt(xmlSchematronParserCtxtPtr ctxt)
{
  xmlDoc *v2;
  xmlXPathContext *v3;
  void *v4;

  if (ctxt)
  {
    v2 = (xmlDoc *)*((_QWORD *)ctxt + 2);
    if (v2 && !*((_DWORD *)ctxt + 6))
      xmlFreeDoc(v2);
    v3 = (xmlXPathContext *)*((_QWORD *)ctxt + 8);
    if (v3)
      xmlXPathFreeContext(v3);
    v4 = (void *)*((_QWORD *)ctxt + 11);
    if (v4)
      xmlFree(v4);
    xmlDictFree(*((xmlDictPtr *)ctxt + 6));
    xmlFree(ctxt);
  }
}

xmlSchematronParserCtxtPtr xmlSchematronNewMemParserCtxt(const char *buffer, int size)
{
  _OWORD *v2;
  _OWORD *v5;
  xmlXPathContextPtr v6;

  v2 = 0;
  if (buffer && size >= 1)
  {
    v5 = xmlMalloc(0x90uLL);
    v2 = v5;
    if (v5)
    {
      v5[7] = 0u;
      v5[8] = 0u;
      v5[5] = 0u;
      v5[6] = 0u;
      v5[3] = 0u;
      v5[4] = 0u;
      v5[1] = 0u;
      v5[2] = 0u;
      *v5 = 0u;
      *((_QWORD *)v5 + 4) = buffer;
      *((_DWORD *)v5 + 10) = size;
      *((_QWORD *)v5 + 6) = xmlDictCreate();
      v6 = xmlXPathNewContext(0);
      *((_QWORD *)v2 + 8) = v6;
      if (!v6)
      {
        __xmlSimpleError(0x10u, 2, 0, 0, (const xmlChar *)"allocating schema parser XPath context");
        xmlSchematronFreeParserCtxt((xmlSchematronParserCtxtPtr)v2);
        return 0;
      }
    }
    else
    {
      __xmlSimpleError(0x10u, 2, 0, 0, (const xmlChar *)"allocating schema parser context");
    }
  }
  return (xmlSchematronParserCtxtPtr)v2;
}

xmlSchematronParserCtxtPtr xmlSchematronNewDocParserCtxt(xmlDocPtr doc)
{
  xmlSchematronParserCtxt *v2;
  xmlSchematronParserCtxt *v3;
  xmlXPathContextPtr v4;

  if (!doc)
    return 0;
  v2 = (xmlSchematronParserCtxt *)xmlMalloc(0x90uLL);
  v3 = v2;
  if (!v2)
  {
    __xmlSimpleError(0x10u, 2, 0, 0, (const xmlChar *)"allocating schema parser context");
    return v3;
  }
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *(_OWORD *)v2 = 0u;
  *((_QWORD *)v2 + 2) = doc;
  *((_QWORD *)v2 + 6) = xmlDictCreate();
  *((_DWORD *)v3 + 6) = 1;
  v4 = xmlXPathNewContext(doc);
  *((_QWORD *)v3 + 8) = v4;
  if (!v4)
  {
    __xmlSimpleError(0x10u, 2, 0, 0, (const xmlChar *)"allocating schema parser XPath context");
    xmlSchematronFreeParserCtxt(v3);
    return 0;
  }
  return v3;
}

xmlSchematronPtr xmlSchematronParse(xmlSchematronParserCtxtPtr ctxt)
{
  const char *v2;
  xmlDocPtr File;
  xmlDoc *v4;
  int v5;
  const char *v6;
  xmlDocPtr Memory;
  const xmlChar *v8;
  int v9;
  xmlNodePtr RootElement;
  uint64_t v11;
  _OWORD *v12;
  _OWORD *v13;
  xmlDict *v14;
  uint64_t v15;
  uint64_t v16;
  const xmlChar *v17;
  const char *v18;
  xmlSchematronParserCtxtPtr v19;
  int v20;
  xmlChar *Content;
  xmlChar *v23;
  uint64_t v24;
  xmlChar *NoNsProp;
  xmlChar *v26;
  xmlChar *v27;
  void *v28;
  uint64_t v29;
  void *v30;
  void *v31;
  const xmlChar *v32;
  int v33;
  uint64_t v34;
  xmlChar *v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *i;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t k;
  uint64_t v43;
  uint64_t v44;
  xmlChar *v45;
  xmlChar *v46;
  uint64_t v47;
  _QWORD *j;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  xmlSchematronParserCtxtPtr v56;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  xmlChar *v60;
  xmlChar *v61;
  xmlChar *v62;
  xmlSchematronParserCtxtPtr v63;
  int v64;
  xmlChar *v65;
  uint64_t v66;
  const xmlChar *v67;
  xmlSchematronParserCtxtPtr v68;
  const char *v69;
  uint64_t v70;
  uint64_t v71;
  xmlPatternPtr v72;
  int v73;
  _OWORD *v74;
  _QWORD *v75;
  int v76;

  if (!ctxt)
    return 0;
  *((_DWORD *)ctxt + 14) = 0;
  v2 = (const char *)*((_QWORD *)ctxt + 1);
  if (v2)
  {
    File = xmlReadFile(v2, 0, 2);
    if (File)
    {
      v4 = File;
      v5 = 0;
LABEL_8:
      v9 = 1;
      goto LABEL_9;
    }
    v17 = (const xmlChar *)*((_QWORD *)ctxt + 1);
    v18 = "xmlSchematronParse: could not load '%s'.\n";
    v19 = ctxt;
    v20 = 1757;
LABEL_40:
    xmlSchematronPErr((uint64_t)v19, 0, v20, v18, v17);
    return 0;
  }
  v6 = (const char *)*((_QWORD *)ctxt + 4);
  if (v6)
  {
    Memory = xmlReadMemory(v6, *((_DWORD *)ctxt + 10), 0, 0, 2);
    if (Memory)
    {
      v4 = Memory;
      Memory->URL = xmlStrdup((const xmlChar *)"in_memory_buffer");
      v8 = xmlDictLookup(*((xmlDictPtr *)ctxt + 6), (const xmlChar *)"in_memory_buffer", -1);
      v5 = 0;
      *((_QWORD *)ctxt + 1) = v8;
      goto LABEL_8;
    }
    v18 = "xmlSchematronParse: could not parse.\n";
    v19 = ctxt;
    v20 = 1766;
    goto LABEL_39;
  }
  v4 = (xmlDoc *)*((_QWORD *)ctxt + 2);
  if (!v4)
  {
    v18 = "xmlSchematronParse: could not parse.\n";
    v19 = ctxt;
    v20 = 1758;
LABEL_39:
    v17 = 0;
    goto LABEL_40;
  }
  v9 = 0;
  v5 = 1;
LABEL_9:
  *((_DWORD *)ctxt + 6) = v5;
  RootElement = xmlDocGetRootElement(v4);
  if (!RootElement)
  {
    xmlSchematronPErr((uint64_t)ctxt, (uint64_t)v4, 1759, "The schema has no document element.\n", 0);
    v13 = 0;
    if (!v9)
      return (xmlSchematronPtr)v13;
    xmlFreeDoc(v4);
    return 0;
  }
  v11 = (uint64_t)RootElement;
  if (RootElement->type != XML_ELEMENT_NODE
    || !RootElement->ns
    || !xmlStrEqual(RootElement->name, (const xmlChar *)"schema")
    || !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v11 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v11 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
  {
    xmlSchematronPErr((uint64_t)ctxt, v11, 1759, "The XML document '%s' is not a XML schematron document", *((const xmlChar **)ctxt + 1));
    v13 = 0;
    goto LABEL_26;
  }
  v12 = xmlMalloc(0x60uLL);
  v13 = v12;
  if (!v12)
  {
    ++*((_DWORD *)ctxt + 14);
    __xmlSimpleError(0x10u, 2, 0, 0, (const xmlChar *)"allocating schema");
    goto LABEL_26;
  }
  v12[4] = 0u;
  v12[5] = 0u;
  v12[2] = 0u;
  v12[3] = 0u;
  *v12 = 0u;
  v12[1] = 0u;
  v14 = (xmlDict *)*((_QWORD *)ctxt + 6);
  *((_QWORD *)v13 + 5) = v14;
  xmlDictReference(v14);
  *((_QWORD *)ctxt + 9) = v13;
  v15 = *(_QWORD *)(v11 + 24);
  if (!v15)
    goto LABEL_22;
  while (1)
  {
    if (*(_DWORD *)(v15 + 8) == 1)
    {
      v16 = *(_QWORD *)(v15 + 72);
      if (v16)
      {
        if (xmlStrEqual(*(const xmlChar **)(v16 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          break;
        }
      }
    }
    v15 = *(_QWORD *)(v15 + 48);
    if (!v15)
      goto LABEL_22;
  }
  if (*(_DWORD *)(v15 + 8) == 1
    && *(_QWORD *)(v15 + 72)
    && xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"title")
    && (xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v15 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")|| xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron")))
  {
    Content = xmlNodeGetContent((const xmlNode *)v15);
    if (Content)
    {
      v23 = Content;
      *((_QWORD *)v13 + 6) = xmlDictLookup(*((xmlDictPtr *)v13 + 5), Content, -1);
      xmlFree(v23);
    }
    v15 = *(_QWORD *)(v15 + 48);
    if (!v15)
      goto LABEL_22;
    while (1)
    {
      if (*(_DWORD *)(v15 + 8) == 1)
      {
        v24 = *(_QWORD *)(v15 + 72);
        if (v24)
        {
          if (xmlStrEqual(*(const xmlChar **)(v24 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
            || xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
          {
            break;
          }
        }
      }
      v15 = *(_QWORD *)(v15 + 48);
      if (!v15)
        goto LABEL_22;
    }
  }
  while (*(_DWORD *)(v15 + 8) == 1)
  {
    if (!*(_QWORD *)(v15 + 72)
      || !xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"ns")
      || !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v15 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
    {
      break;
    }
    NoNsProp = xmlGetNoNsProp((const xmlNode *)v15, (const xmlChar *)"prefix");
    v26 = xmlGetNoNsProp((const xmlNode *)v15, (const xmlChar *)"uri");
    v27 = v26;
    if (!v26 || !*v26)
      xmlSchematronPErr((uint64_t)ctxt, v15, 1759, "ns element has no uri", 0);
    if (!NoNsProp || !*NoNsProp)
      xmlSchematronPErr((uint64_t)ctxt, v15, 1759, "ns element has no prefix", 0);
    if (!NoNsProp || !v27)
    {
      if (!v27)
        goto LABEL_84;
      goto LABEL_83;
    }
    xmlXPathRegisterNs(*((xmlXPathContextPtr *)ctxt + 8), NoNsProp, v27);
    v28 = (void *)*((_QWORD *)ctxt + 11);
    if (v28)
    {
      v29 = *((int *)ctxt + 21);
      if (*((_DWORD *)ctxt + 20) + 2 >= (int)v29)
      {
        v30 = xmlRealloc(v28, 32 * v29);
        if (!v30)
          goto LABEL_81;
        *((_QWORD *)ctxt + 11) = v30;
        *((_DWORD *)ctxt + 21) *= 2;
      }
    }
    else
    {
      *((_DWORD *)ctxt + 21) = 10;
      v31 = xmlMalloc(0xA0uLL);
      *((_QWORD *)ctxt + 11) = v31;
      if (!v31)
      {
LABEL_81:
        __xmlSimpleError(0x10u, 2, 0, 0, (const xmlChar *)"allocating parser namespaces");
        goto LABEL_82;
      }
      *((_DWORD *)ctxt + 20) = 0;
    }
    *(_QWORD *)(*((_QWORD *)ctxt + 11) + 16 * *((int *)ctxt + 20)) = xmlDictLookup(*((xmlDictPtr *)ctxt + 6), v27, -1);
    v32 = xmlDictLookup(*((xmlDictPtr *)ctxt + 6), NoNsProp, -1);
    v33 = *((_DWORD *)ctxt + 20);
    *(_QWORD *)(*((_QWORD *)ctxt + 11) + 8 * ((2 * v33) | 1)) = v32;
    *((_DWORD *)ctxt + 20) = v33 + 1;
    *(_QWORD *)(*((_QWORD *)ctxt + 11) + 16 * (v33 + 1)) = 0;
    *(_QWORD *)(*((_QWORD *)ctxt + 11) + 16 * (v33 + 1) + 8) = 0;
LABEL_82:
    ++*((_DWORD *)v13 + 14);
LABEL_83:
    xmlFree(v27);
LABEL_84:
    if (NoNsProp)
      xmlFree(NoNsProp);
    while (1)
    {
      v15 = *(_QWORD *)(v15 + 48);
      if (!v15)
        goto LABEL_22;
      if (*(_DWORD *)(v15 + 8) == 1)
      {
        v34 = *(_QWORD *)(v15 + 72);
        if (v34)
        {
          if (xmlStrEqual(*(const xmlChar **)(v34 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
            || xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
          {
            break;
          }
        }
      }
    }
  }
LABEL_92:
  if (*(_DWORD *)(v15 + 8) != 1
    || !*(_QWORD *)(v15 + 72)
    || !xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"pattern")
    || !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v15 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
  {
    xmlSchematronPErr((uint64_t)ctxt, v15, 1759, "Expecting a pattern element instead of %s", *(const xmlChar **)(v15 + 16));
    goto LABEL_112;
  }
  v35 = xmlGetNoNsProp((const xmlNode *)v15, (const xmlChar *)"id");
  if (!v35)
    v35 = xmlGetNoNsProp((const xmlNode *)v15, (const xmlChar *)"name");
  if (!v35 || (v36 = *((_QWORD *)ctxt + 9)) == 0)
  {
    if (!v35)
      goto LABEL_122;
    goto LABEL_121;
  }
  v37 = xmlMalloc(0x18uLL);
  if (!v37)
  {
    ++*((_DWORD *)ctxt + 14);
    __xmlSimpleError(0x10u, 2, v15, 0, (const xmlChar *)"allocating schema pattern");
LABEL_121:
    xmlFree(v35);
    goto LABEL_122;
  }
  v38 = v37;
  v37[1] = 0;
  v37[2] = 0;
  *v37 = 0;
  v37[2] = v35;
  v41 = *(_QWORD **)(v36 + 64);
  v40 = (_QWORD *)(v36 + 64);
  for (i = v41; i; i = (_QWORD *)*i)
    v40 = i;
  *v40 = v37;
  k = *(_QWORD *)(v15 + 24);
  if (!k)
    goto LABEL_110;
  while (1)
  {
    if (*(_DWORD *)(k + 8) == 1)
    {
      v43 = *(_QWORD *)(k + 72);
      if (v43)
      {
        if (xmlStrEqual(*(const xmlChar **)(v43 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(k + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          break;
        }
      }
    }
    k = *(_QWORD *)(k + 48);
    if (!k)
      goto LABEL_110;
  }
  v76 = 0;
  v75 = v38 + 1;
LABEL_124:
  if (*(_DWORD *)(k + 8) != 1
    || !*(_QWORD *)(k + 72)
    || !xmlStrEqual(*(const xmlChar **)(k + 16), (const xmlChar *)"rule")
    || !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(k + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(k + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
  {
    xmlSchematronPErr((uint64_t)ctxt, k, 1759, "Expecting a rule element instead of %s", *(const xmlChar **)(k + 16));
    goto LABEL_149;
  }
  v45 = xmlGetNoNsProp((const xmlNode *)k, (const xmlChar *)"context");
  if (!v45)
  {
    v56 = ctxt;
    v57 = k;
    v58 = "rule has no context attribute";
    goto LABEL_157;
  }
  v46 = v45;
  if (!*v45)
  {
    xmlSchematronPErr((uint64_t)ctxt, k, 1759, "rule has an empty context attribute", 0);
LABEL_160:
    xmlFree(v46);
    goto LABEL_161;
  }
  v47 = *((_QWORD *)ctxt + 9);
  if (!v47)
    goto LABEL_160;
  v72 = xmlPatterncompile(v45, *((xmlDict **)ctxt + 6), 1, *((const xmlChar ***)ctxt + 11));
  if (!v72)
    xmlSchematronPErr((uint64_t)ctxt, k, 1759, "Failed to compile context expression %s", v46);
  v74 = xmlMalloc(0x38uLL);
  if (!v74)
  {
    ++*((_DWORD *)ctxt + 14);
    __xmlSimpleError(0x10u, 2, k, 0, (const xmlChar *)"allocating schema rule");
    goto LABEL_160;
  }
  v74[1] = 0u;
  v74[2] = 0u;
  *v74 = 0u;
  *((_QWORD *)v74 + 2) = k;
  *((_QWORD *)v74 + 3) = v46;
  *((_QWORD *)v74 + 5) = v72;
  *((_QWORD *)v74 + 6) = 0;
  *(_QWORD *)v74 = 0;
  v50 = *(_QWORD **)(v47 + 72);
  v49 = (_QWORD *)(v47 + 72);
  for (j = v50; j; j = (_QWORD *)*j)
    v49 = j;
  v51 = v75;
  *v49 = v74;
  *((_QWORD *)v74 + 1) = 0;
  v52 = *v75;
  if (*v75)
  {
    do
    {
      v53 = v52;
      v52 = *(_QWORD *)(v52 + 8);
    }
    while (v52);
    v51 = (_QWORD *)(v53 + 8);
  }
  *v51 = v74;
  if (!*(_QWORD *)(k + 24))
  {
LABEL_147:
    v56 = ctxt;
    v57 = k;
    v58 = "rule has no assert nor report element";
LABEL_157:
    xmlSchematronPErr((uint64_t)v56, v57, 1759, v58, 0);
    goto LABEL_161;
  }
  v54 = *(_QWORD *)(k + 24);
  while (1)
  {
    if (*(_DWORD *)(v54 + 8) == 1)
    {
      v55 = *(_QWORD *)(v54 + 72);
      if (v55)
      {
        if (xmlStrEqual(*(const xmlChar **)(v55 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v54 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          break;
        }
      }
    }
    v54 = *(_QWORD *)(v54 + 48);
    if (!v54)
      goto LABEL_147;
  }
  v73 = 0;
  while (1)
  {
    if (*(_DWORD *)(v54 + 8) != 1)
    {
LABEL_181:
      v66 = v54;
      v67 = *(const xmlChar **)(v54 + 16);
      v68 = ctxt;
      v69 = "Expecting an assert or a report element instead of %s";
LABEL_182:
      xmlSchematronPErr((uint64_t)v68, v66, 1759, v69, v67);
      goto LABEL_183;
    }
    if (*(_QWORD *)(v54 + 72)
      && xmlStrEqual(*(const xmlChar **)(v54 + 16), (const xmlChar *)"assert")
      && (xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v54 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")|| xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v54 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron")))
    {
      ++v73;
      v60 = xmlGetNoNsProp((const xmlNode *)v54, (const xmlChar *)"test");
      if (!v60)
        goto LABEL_191;
      v61 = v60;
      if (*v60)
      {
        v71 = v54;
        v62 = xmlNodeGetContent((const xmlNode *)v54);
        v63 = ctxt;
        v64 = 1;
        goto LABEL_179;
      }
    }
    else
    {
      if (*(_DWORD *)(v54 + 8) != 1
        || !*(_QWORD *)(v54 + 72)
        || !xmlStrEqual(*(const xmlChar **)(v54 + 16), (const xmlChar *)"report")
        || !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v54 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v54 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
      {
        goto LABEL_181;
      }
      ++v73;
      v65 = xmlGetNoNsProp((const xmlNode *)v54, (const xmlChar *)"test");
      if (!v65)
      {
LABEL_191:
        v68 = ctxt;
        v66 = v54;
        v69 = "assert has no test attribute";
        v67 = 0;
        goto LABEL_182;
      }
      v61 = v65;
      if (*v65)
      {
        v71 = v54;
        v62 = xmlNodeGetContent((const xmlNode *)v54);
        v63 = ctxt;
        v64 = 2;
LABEL_179:
        if (xmlSchematronAddTest((uint64_t)v63, v64, (uint64_t)v74, v71, v61, (uint64_t)v62))
          goto LABEL_183;
        goto LABEL_193;
      }
    }
    xmlSchematronPErr((uint64_t)ctxt, v54, 1759, "assert has an empty test attribute", 0);
LABEL_193:
    xmlFree(v61);
LABEL_183:
    if (!*(_QWORD *)(v54 + 48))
      break;
    v54 = *(_QWORD *)(v54 + 48);
    while (1)
    {
      if (*(_DWORD *)(v54 + 8) == 1)
      {
        v70 = *(_QWORD *)(v54 + 72);
        if (v70)
        {
          if (xmlStrEqual(*(const xmlChar **)(v70 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
            || xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v54 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
          {
            break;
          }
        }
      }
      v54 = *(_QWORD *)(v54 + 48);
      if (!v54)
        goto LABEL_194;
    }
  }
LABEL_194:
  if (!v73)
    goto LABEL_147;
LABEL_161:
  ++v76;
LABEL_149:
  for (k = *(_QWORD *)(k + 48); k; k = *(_QWORD *)(k + 48))
  {
    if (*(_DWORD *)(k + 8) == 1)
    {
      v59 = *(_QWORD *)(k + 72);
      if (v59)
      {
        if (xmlStrEqual(*(const xmlChar **)(v59 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(k + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          goto LABEL_124;
        }
      }
    }
  }
  if (!v76)
LABEL_110:
    xmlSchematronPErr((uint64_t)ctxt, v15, 1759, "Pattern has no rule element", 0);
LABEL_122:
  ++*((_DWORD *)v13 + 15);
LABEL_112:
  while (1)
  {
    v15 = *(_QWORD *)(v15 + 48);
    if (!v15)
      break;
    if (*(_DWORD *)(v15 + 8) == 1)
    {
      v44 = *(_QWORD *)(v15 + 72);
      if (v44)
      {
        if (xmlStrEqual(*(const xmlChar **)(v44 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          goto LABEL_92;
        }
      }
    }
  }
LABEL_22:
  if (*((_DWORD *)v13 + 15))
  {
    *((_QWORD *)v13 + 2) = v4;
    if ((v9 & 1) == 0)
      *((_DWORD *)v13 + 2) = 1;
    goto LABEL_29;
  }
  xmlSchematronPErr((uint64_t)ctxt, v11, 1759, "The schematron document '%s' has no pattern", *((const xmlChar **)ctxt + 1));
LABEL_26:
  if (v9)
    xmlFreeDoc(v4);
  if (v13)
  {
LABEL_29:
    if (*((_DWORD *)ctxt + 14))
    {
      xmlSchematronFree((xmlSchematronPtr)v13);
      return 0;
    }
    *((_QWORD *)v13 + 11) = *((_QWORD *)ctxt + 11);
    *((_DWORD *)v13 + 20) = *((_DWORD *)ctxt + 20);
    *((_QWORD *)ctxt + 11) = 0;
  }
  return (xmlSchematronPtr)v13;
}

_DWORD *xmlSchematronPErr(uint64_t a1, uint64_t a2, int a3, const char *a4, const xmlChar *a5)
{
  ++*(_DWORD *)(a1 + 56);
  return __xmlRaiseError(*(xmlStructuredErrorFunc *)(a1 + 136), *(void (**)(void *, const char *, ...))(a1 + 120), *(void **)(a1 + 112), (_QWORD *)a1, a2, 0x10u, a3, 2, 0, 0, a5, 0, 0, 0, 0, a4, (char)a5);
}

void xmlSchematronSetValidStructuredErrors(xmlSchematronValidCtxtPtr ctxt, xmlStructuredErrorFunc serror, void *ctx)
{
  if (ctxt)
  {
    *((_QWORD *)ctxt + 12) = 0;
    *((_QWORD *)ctxt + 13) = serror;
    *((_QWORD *)ctxt + 10) = ctx;
    *((_QWORD *)ctxt + 11) = 0;
  }
}

xmlSchematronValidCtxtPtr xmlSchematronNewValidCtxt(xmlSchematronPtr schema, int options)
{
  _OWORD *v4;
  _OWORD *v5;
  xmlXPathContextPtr v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const xmlChar *v10;
  const xmlChar *v11;

  v4 = xmlMalloc(0x70uLL);
  v5 = v4;
  if (v4)
  {
    *v4 = 0u;
    v4[1] = 0u;
    v4[5] = 0u;
    v4[6] = 0u;
    v4[3] = 0u;
    v4[4] = 0u;
    v4[2] = 0u;
    *(_DWORD *)v4 = 2;
    *((_QWORD *)v4 + 3) = schema;
    v6 = xmlXPathNewContext(0);
    *((_QWORD *)v5 + 4) = v6;
    *((_DWORD *)v5 + 1) = options;
    if (v6)
    {
      if (*((int *)schema + 20) >= 1)
      {
        v7 = 0;
        v8 = 0;
        do
        {
          v9 = *((_QWORD *)schema + 11);
          v10 = *(const xmlChar **)(v9 + v7);
          if (!v10)
            break;
          v11 = *(const xmlChar **)(v9 + v7 + 8);
          if (!v11)
            break;
          xmlXPathRegisterNs(*((xmlXPathContextPtr *)v5 + 4), v11, v10);
          ++v8;
          v7 += 16;
        }
        while (v8 < *((int *)schema + 20));
      }
    }
    else
    {
      __xmlSimpleError(0x10u, 2, 0, 0, (const xmlChar *)"allocating schema parser XPath context");
      xmlSchematronFreeValidCtxt((xmlSchematronValidCtxtPtr)v5);
      return 0;
    }
  }
  else
  {
    __xmlSimpleError(0x11u, 2, 0, 0, (const xmlChar *)"allocating validation context");
  }
  return (xmlSchematronValidCtxtPtr)v5;
}

void xmlSchematronFreeValidCtxt(xmlSchematronValidCtxtPtr ctxt)
{
  xmlXPathContext *v2;
  xmlDict *v3;

  if (ctxt)
  {
    v2 = (xmlXPathContext *)*((_QWORD *)ctxt + 4);
    if (v2)
      xmlXPathFreeContext(v2);
    v3 = (xmlDict *)*((_QWORD *)ctxt + 1);
    if (v3)
      xmlDictFree(v3);
    xmlFree(ctxt);
  }
}

int xmlSchematronValidateDoc(xmlSchematronValidCtxtPtr ctxt, xmlDocPtr instance)
{
  uint64_t v3;
  int result;
  xmlNodePtr RootElement;
  xmlNode *Node;
  int v8;
  uint64_t k;
  int v10;
  xmlGenericErrorFunc v11;
  void **v12;
  xmlNode *v13;
  uint64_t m;
  _QWORD *n;
  _QWORD *i;
  _QWORD *j;
  xmlGenericErrorFunc v18;
  void **v19;
  char __str[1000];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!ctxt)
    return -1;
  v3 = *((_QWORD *)ctxt + 3);
  if (!v3)
    return -1;
  result = -1;
  if (instance && *(_QWORD *)(v3 + 72))
  {
    *((_DWORD *)ctxt + 4) = 0;
    RootElement = xmlDocGetRootElement(instance);
    if (RootElement)
    {
      Node = RootElement;
      v8 = *((_DWORD *)ctxt + 1);
      if (!v8 || (v8 & 1) != 0)
      {
        do
        {
          for (i = *(_QWORD **)(*((_QWORD *)ctxt + 3) + 72); i; i = (_QWORD *)*i)
          {
            if (xmlPatternMatch((xmlPatternPtr)i[5], Node) == 1)
            {
              for (j = (_QWORD *)i[4]; j; j = (_QWORD *)*j)
                xmlSchematronRunTest((uint64_t)ctxt, (uint64_t)j, instance, Node, i[5]);
            }
          }
          Node = (xmlNode *)xmlSchematronNextNode((uint64_t)Node);
        }
        while (Node);
      }
      else
      {
        for (k = *(_QWORD *)(*((_QWORD *)ctxt + 3) + 64); k; k = *(_QWORD *)k)
        {
          v10 = *((_DWORD *)ctxt + 1);
          if ((v10 & 9) == 0)
          {
            if ((v10 & 4) != 0)
            {
              v11 = *__xmlGenericError();
              v12 = __xmlGenericErrorContext();
              v11(*v12, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/schematron.c", 1460);
            }
            else
            {
              bzero(__str, 0x3E8uLL);
              if (*(_QWORD *)(k + 16))
              {
                snprintf(__str, 0x3E7uLL, "Pattern: %s\n", *(const char **)(k + 16));
                fputs(__str, (FILE *)*MEMORY[0x1E0C80C10]);
              }
            }
          }
          v13 = Node;
          do
          {
            for (m = *(_QWORD *)(k + 8); m; m = *(_QWORD *)(m + 8))
            {
              if (xmlPatternMatch(*(xmlPatternPtr *)(m + 40), v13) == 1)
              {
                for (n = *(_QWORD **)(m + 32); n; n = (_QWORD *)*n)
                  xmlSchematronRunTest((uint64_t)ctxt, (uint64_t)n, instance, v13, k);
              }
            }
            v13 = (xmlNode *)xmlSchematronNextNode((uint64_t)v13);
          }
          while (v13);
        }
      }
      return *((_DWORD *)ctxt + 4);
    }
    else
    {
      v18 = *__xmlGenericError();
      v19 = __xmlGenericErrorContext();
      v18(*v19, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/schematron.c", 1684);
      ++*((_DWORD *)ctxt + 4);
      return 1;
    }
  }
  return result;
}

void xmlSchematronRunTest(uint64_t a1, uint64_t a2, xmlDoc *a3, const xmlNode *a4, uint64_t a5)
{
  xmlXPathContext *v9;
  xmlXPathObjectPtr v10;
  xmlXPathObject *v11;
  int v12;
  int v13;
  _BYTE *v14;
  int v15;
  _DWORD *p_nodeNr;
  int BOOLval;
  xmlChar *stringval;
  uint64_t LineNo;
  xmlChar *NodePath;
  uint64_t v21;
  uint64_t v22;
  xmlChar *v23;
  int v24;
  const xmlChar **p_name;
  xmlChar *NoNsProp;
  const xmlNode *v27;
  xmlXPathContext *v28;
  xmlXPathObjectPtr v29;
  xmlNodeSetPtr nodesetval;
  xmlNs *ns;
  const xmlChar *prefix;
  xmlChar *v33;
  xmlChar *v34;
  int v35;
  unsigned int v36;
  xmlGenericErrorFunc v38;
  void **v39;
  const char *v40;
  void (__cdecl *v41)(void *, xmlErrorPtr);
  void (*v42)(void *, const char *, ...);
  int v43;
  const xmlChar *v44;
  xmlChar *v45;
  uint64_t v46;
  char __str[1000];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v9 = *(xmlXPathContext **)(a1 + 32);
  v9->doc = a3;
  v9->node = (xmlNodePtr)a4;
  v10 = xmlXPathCompiledEval(*(xmlXPathCompExprPtr *)(a2 + 32), v9);
  if (v10)
  {
    v11 = v10;
    switch(v10->type)
    {
      case XPATH_UNDEFINED:
      case XPATH_POINT:
      case XPATH_RANGE:
      case XPATH_LOCATIONSET:
      case XPATH_USERS:
        goto LABEL_3;
      case XPATH_NODESET:
      case XPATH_XSLT_TREE:
        p_nodeNr = &v10->nodesetval->nodeNr;
        if (!p_nodeNr || !*p_nodeNr)
          goto LABEL_3;
        goto LABEL_19;
      case XPATH_BOOLEAN:
        BOOLval = v10->BOOLval;
        xmlXPathFreeObject(v10);
        if (!BOOLval)
          break;
        goto LABEL_20;
      case XPATH_NUMBER:
        if (!xmlXPathIsNaN(v10->floatval) && v11->floatval != 0.0)
          goto LABEL_19;
        goto LABEL_3;
      case XPATH_STRING:
        stringval = v10->stringval;
        if (stringval && *stringval)
          goto LABEL_19;
LABEL_3:
        xmlXPathFreeObject(v11);
        break;
      default:
LABEL_19:
        xmlXPathFreeObject(v11);
LABEL_20:
        v12 = *(_DWORD *)(a2 + 8);
        if (v12 == 2)
          ++*(_DWORD *)(a1 + 16);
        v15 = 1;
        goto LABEL_23;
    }
  }
  v12 = *(_DWORD *)(a2 + 8);
  if (v12 != 1)
  {
    v15 = 2;
LABEL_23:
    v14 = (_BYTE *)(a1 + 4);
    v13 = *(_DWORD *)(a1 + 4);
    if ((v13 & 5) == 1)
    {
      if (v12 == 2)
        return;
      goto LABEL_27;
    }
LABEL_26:
    if ((v13 & 4) != 0)
    {
      v38 = *__xmlGenericError();
      v39 = __xmlGenericErrorContext();
      v38(*v39, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/schematron.c", 1383);
      return;
    }
LABEL_27:
    bzero(__str, 0x3E8uLL);
    if (v12 == v15)
      return;
    goto LABEL_28;
  }
  v14 = (_BYTE *)(a1 + 4);
  v13 = *(_DWORD *)(a1 + 4);
  ++*(_DWORD *)(a1 + 16);
  if ((v13 & 5) != 1)
  {
    v12 = 1;
    v15 = 2;
    goto LABEL_26;
  }
  bzero(__str, 0x3E8uLL);
LABEL_28:
  LineNo = xmlGetLineNo(a4);
  NodePath = xmlGetNodePath(a4);
  if (!NodePath)
    NodePath = (xmlChar *)a4->name;
  v21 = *(_QWORD *)(a2 + 16);
  if (!v21 || (v22 = *(_QWORD *)(v21 + 24)) == 0)
  {
LABEL_72:
    if (*(_DWORD *)(a2 + 8) == 1)
      v40 = "node failed assert";
    else
      v40 = "node failed report";
    v23 = xmlStrdup((const xmlChar *)v40);
    goto LABEL_76;
  }
  v23 = 0;
  do
  {
    v24 = *(_DWORD *)(v22 + 8);
    if (v24 == 1)
    {
      if (!*(_QWORD *)(v22 + 72)
        || !xmlStrEqual(*(const xmlChar **)(v22 + 16), (const xmlChar *)"name")
        || !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v22 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(_QWORD *)(v22 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
      {
        goto LABEL_40;
      }
      v46 = a5;
      NoNsProp = xmlGetNoNsProp((const xmlNode *)v22, (const xmlChar *)"path");
      v27 = a4;
      if (NoNsProp)
      {
        v28 = *(xmlXPathContext **)(a1 + 32);
        v28->doc = a4->doc;
        v28->node = (xmlNodePtr)a4;
        v45 = NoNsProp;
        v29 = xmlXPathEval(NoNsProp, v28);
        if (v29)
        {
          if (v29->type == XPATH_NODESET && (nodesetval = v29->nodesetval) != 0 && nodesetval->nodeNr >= 1)
            v27 = *nodesetval->nodeTab;
          else
            v27 = 0;
          xmlXPathFreeObject(v29);
        }
        else
        {
          v27 = 0;
        }
        if (!v27)
          v27 = a4;
        xmlFree(v45);
      }
      ns = v27->ns;
      if (ns)
      {
        prefix = ns->prefix;
        if (prefix)
        {
          v33 = xmlStrcat(v23, prefix);
          v23 = xmlStrcat(v33, (const xmlChar *)":");
        }
      }
      p_name = &v27->name;
      a5 = v46;
    }
    else
    {
      if ((v24 - 3) > 1)
        goto LABEL_40;
      p_name = (const xmlChar **)(v22 + 80);
    }
    v34 = xmlStrcat(v23, *p_name);
    v23 = v34;
    if (v34)
    {
      v35 = xmlStrlen(v34);
      if (v35 >= 1)
      {
        v36 = v23[v35 - 1];
        if (v36 <= 0x20 && ((1 << v36) & 0x100002600) != 0)
        {
          while (v36 <= 0x20u && ((1 << v36) & 0x100002600) != 0)
          {
            if (v35 == 1)
            {
              v35 = 0;
              break;
            }
            LOBYTE(v36) = v23[v35 - 2];
            --v35;
          }
          v23[v35] = 32;
          v23[v35 + 1] = 0;
        }
      }
    }
LABEL_40:
    v22 = *(_QWORD *)(v22 + 48);
  }
  while (v22);
  if (!v23)
    goto LABEL_72;
LABEL_76:
  snprintf(__str, 0x3E7uLL, "%s line %ld: %s\n", (const char *)NodePath, LineNo, (const char *)v23);
  if ((*v14 & 8) != 0)
  {
    v41 = *(void (__cdecl **)(void *, xmlErrorPtr))(a1 + 104);
    if (v41)
      v42 = 0;
    else
      v42 = *(void (**)(void *, const char *, ...))(a1 + 88);
    if (*(_DWORD *)(a2 + 8) == 1)
      v43 = 4000;
    else
      v43 = 4001;
    if (a5)
      v44 = *(const xmlChar **)(a5 + 16);
    else
      v44 = 0;
    __xmlRaiseError(v41, v42, *(void **)(a1 + 80), 0, (uint64_t)a4, 0x1Cu, v43, 2, 0, LineNo, v44, NodePath, v23, 0, 0, "%s", (char)__str);
  }
  else
  {
    fputs(__str, (FILE *)*MEMORY[0x1E0C80C10]);
  }
  xmlFree(v23);
  if (NodePath)
  {
    if (NodePath != a4->name)
      xmlFree(NodePath);
  }
}

uint64_t xmlSchematronNextNode(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  int v3;
  uint64_t v4;
  int v5;

  v1 = a1;
  result = *(_QWORD *)(a1 + 24);
  if (result)
  {
    v3 = *(_DWORD *)(result + 8);
    if (v3 != 17)
    {
      if (v3 != 14)
        return result;
      v1 = result;
    }
  }
  v4 = *(_QWORD *)(v1 + 48);
  result = v1;
  if (!v4)
    goto LABEL_14;
  while (1)
  {
    result = v4;
    v5 = *(_DWORD *)(v4 + 8);
    if (v5 != 17 && v5 != 14)
      break;
    v4 = *(_QWORD *)(v4 + 48);
    if (!v4)
    {
LABEL_14:
      while (1)
      {
        result = *(_QWORD *)(result + 40);
        if (!result)
          break;
        if (*(_DWORD *)(result + 8) == 9)
          return 0;
        if (*(_QWORD *)(result + 48))
          return *(_QWORD *)(result + 48);
      }
      return result;
    }
  }
  return result;
}

_OWORD *xmlSchematronAddTest(uint64_t a1, int a2, uint64_t a3, uint64_t a4, xmlChar *str, uint64_t a6)
{
  xmlXPathCompExprPtr v12;
  xmlXPathCompExprPtr v13;
  _OWORD *result;
  _QWORD *v15;
  _QWORD *v16;

  v12 = xmlXPathCtxtCompile(*(xmlXPathContextPtr *)(a1 + 64), str);
  if (!v12)
  {
    xmlSchematronPErr(a1, a4, 1759, "Failed to compile test expression %s", str);
    return 0;
  }
  v13 = v12;
  result = xmlMalloc(0x30uLL);
  if (!result)
  {
    ++*(_DWORD *)(a1 + 56);
    __xmlSimpleError(0x10u, 2, a4, 0, (const xmlChar *)"allocating schema test");
    return 0;
  }
  *result = 0u;
  result[1] = 0u;
  result[2] = 0u;
  *((_DWORD *)result + 2) = a2;
  *((_QWORD *)result + 2) = a4;
  *((_QWORD *)result + 3) = str;
  *((_QWORD *)result + 4) = v13;
  *((_QWORD *)result + 5) = a6;
  *(_QWORD *)result = 0;
  v15 = *(_QWORD **)(a3 + 32);
  if (v15)
  {
    do
    {
      v16 = v15;
      v15 = (_QWORD *)*v15;
    }
    while (v15);
    *v16 = result;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = result;
  }
  return result;
}

void xmlFreeMutex(xmlMutexPtr tok)
{
  if (tok)
  {
    pthread_mutex_destroy((pthread_mutex_t *)tok);
    free(tok);
  }
}

void xmlFreeRMutex(xmlRMutexPtr tok)
{
  if (tok)
  {
    pthread_mutex_destroy((pthread_mutex_t *)tok);
    pthread_cond_destroy((pthread_cond_t *)((char *)tok + 80));
    free(tok);
  }
}

int xmlGetThreadId(void)
{
  return pthread_self();
}

void xmlFreeGlobalState(uint64_t a1)
{
  xmlResetError((xmlErrorPtr)(a1 + 856));
  free((void *)a1);
}

xmlChar *__cdecl xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix, xmlChar *memory, int len)
{
  const xmlChar *v4;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  xmlChar *v12;
  unint64_t v13;

  v4 = ncname;
  if (ncname && prefix)
  {
    v8 = strlen((const char *)ncname);
    v9 = strlen((const char *)prefix);
    v10 = v9;
    if (memory && v8 + v9 + 2 <= len)
    {
      v13 = (unint64_t)(v9 + v8) << 32;
    }
    else
    {
      v11 = (v9 + v8);
      v12 = (xmlChar *)xmlMallocAtomic(((v11 << 32) + 0x200000000) >> 32);
      if (!v12)
      {
        __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building QName");
        return 0;
      }
      memory = v12;
      v13 = v11 << 32;
    }
    memcpy(memory, prefix, v10);
    memory[v10] = 58;
    memcpy(&memory[v10 + 1], v4, v8);
    memory[(uint64_t)(v13 + 0x100000000) >> 32] = 0;
    return memory;
  }
  return (xmlChar *)v4;
}

xmlChar *__cdecl xmlSplitQName2(const xmlChar *name, xmlChar **prefix)
{
  int v4;
  xmlChar *result;
  uint64_t v6;
  xmlChar *v7;

  if (!prefix)
    return 0;
  *prefix = 0;
  if (!name)
    return 0;
  v4 = *name;
  if (v4 == 58)
    return 0;
  v6 = 1;
  if (!*name)
    return 0;
  while (v4 != 58)
  {
    v4 = name[v6++];
    if (!v4)
      return 0;
  }
  v7 = xmlStrndup(name, (int)v6 - 1);
  *prefix = v7;
  if (!v7)
  {
    __xmlSimpleError(2, 2, 0);
    return 0;
  }
  result = xmlStrdup(&name[v6]);
  if (!result)
  {
    __xmlSimpleError(2, 2, 0);
    result = *prefix;
    if (*prefix)
    {
      xmlFree(result);
      result = 0;
      *prefix = 0;
    }
  }
  return result;
}

const xmlChar *__cdecl xmlSplitQName3(const xmlChar *name, int *len)
{
  const xmlChar *v2;
  int v3;
  uint64_t v4;

  v2 = 0;
  if (name && len)
  {
    v3 = *name;
    if (v3 == 58)
      return 0;
    v4 = 1;
    if (!*name)
    {
      return 0;
    }
    else
    {
      while (v3 != 58)
      {
        v3 = name[v4++];
        if (!v3)
          return 0;
      }
      *len = v4 - 1;
      return &name[v4];
    }
  }
  return v2;
}

int xmlValidateNCName(const xmlChar *value, int space)
{
  const xmlChar *v3;
  const xmlChar *i;
  unsigned int v5;
  const xmlChar *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v14;
  int v15;
  signed int v16;
  BOOL v17;
  signed int v20;
  signed int v21;
  BOOL v22;
  BOOL v24;
  BOOL v26;
  int len;

  if (!value)
    return -1;
  v3 = value;
  if (space)
  {
    for (i = value; ; ++i)
    {
      v5 = *i;
      if (v5 > 0x20 || ((1 << v5) & 0x100002600) == 0)
        break;
    }
  }
  else
  {
    v5 = *value;
    i = value;
  }
  len = 0;
  if (v5 - 97 < 0x1A || v5 == 95 || v5 - 65 <= 0x19)
  {
    do
    {
      v8 = i;
      v10 = *++i;
      v9 = v10;
      v11 = (v10 & 0xFFFFFFDF) - 65;
    }
    while (v10 - 48 < 0xA
         || v11 < 0x1A
         || v9 - 45 <= 0x32 && ((1 << (v9 - 45)) & 0x4000000000003) != 0);
    if (space)
    {
      v14 = 2;
      while (v9 <= 0x20 && ((1 << v9) & 0x100002600) != 0)
        v9 = v8[v14++];
    }
    if (!v9)
      return 0;
  }
  v15 = xmlStringCurrentChar(0, value, &len);
  v16 = v15;
  if (space)
  {
    if (v15 <= 255)
    {
      while (v16 <= 0x20 && ((1 << v16) & 0x100002600) != 0)
      {
        v3 += len;
        v16 = xmlStringCurrentChar(0, v3, &len);
        if (v16 >= 256)
          goto LABEL_44;
      }
      goto LABEL_38;
    }
  }
  else if (v15 < 256)
  {
LABEL_38:
    if ((v16 - 192) < 0x17
      || (v16 & 0xFFFFFFDF) - 65 < 0x1A
      || v16 > 247
      || (v16 - 216) < 0x1F
      || v16 == 95)
    {
      goto LABEL_55;
    }
    return 1;
  }
LABEL_44:
  if (xmlCharInRange(v16, &xmlIsBaseCharGroup))
    v17 = 1;
  else
    v17 = (v16 - 12330) > 0xFFFFFFF6;
  if (!v17 && v16 != 12295 && (v16 - 40870) < 0xFFFFAE5A)
    return 1;
  do
  {
    while (1)
    {
      do
      {
        do
        {
LABEL_55:
          while (1)
          {
            v3 += len;
            v20 = xmlStringCurrentChar(0, v3, &len);
            v21 = v20;
            if (v20 > 255)
              break;
            v22 = (v20 - 192) >= 0x17 && (v20 & 0xFFFFFFDF) - 65 >= 0x1A;
            if (v22 && (v20 - 48) >= 0xA && v20 <= 247 && (v20 - 216) >= 0x1F)
              goto LABEL_79;
          }
          if (xmlCharInRange(v20, &xmlIsBaseCharGroup))
            v24 = 0;
          else
            v24 = (v21 - 12321) >= 9;
          v26 = v24 && v21 != 12295 && (v21 - 19968) >= 0x51A6;
        }
        while (!v26 || xmlCharInRange(v21, &xmlIsDigitGroup));
LABEL_79:
        ;
      }
      while ((v21 - 45) <= 0x32 && ((1 << (v21 - 45)) & 0x4000000000003) != 0);
      if (v21 >= 256)
        break;
      if (v21 != 183)
        goto LABEL_89;
    }
  }
  while (xmlCharInRange(v21, &xmlIsCombiningGroup) || xmlCharInRange(v21, &xmlIsExtenderGroup));
LABEL_89:
  if (space && v21 <= 255)
  {
    do
    {
      if (v21 > 0x20)
        break;
      if (((1 << v21) & 0x100002600) == 0)
        break;
      v3 += len;
      v21 = xmlStringCurrentChar(0, v3, &len);
    }
    while (v21 < 256);
  }
  return v21 != 0;
}

int xmlValidateQName(const xmlChar *value, int space)
{
  const xmlChar *v3;
  const xmlChar *i;
  unsigned int v5;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  int v12;
  unsigned __int8 *v15;
  unsigned int v16;
  int v17;
  signed int v18;
  BOOL v19;
  signed int v22;
  signed int v23;
  BOOL v24;
  BOOL v26;
  BOOL v28;
  signed int v30;
  signed int v31;
  signed int v32;
  BOOL v33;
  BOOL v35;
  BOOL v37;
  int len;

  if (!value)
    return -1;
  v3 = value;
  if (space)
  {
    for (i = value; ; ++i)
    {
      v5 = *i;
      if (v5 > 0x20 || ((1 << v5) & 0x100002600) == 0)
        break;
    }
  }
  else
  {
    v5 = *value;
    i = value;
  }
  len = 0;
  if (v5 - 97 < 0x1A || v5 == 95 || v5 - 65 <= 0x19)
  {
    do
    {
      v9 = *++i;
      v8 = v9;
      v10 = (v9 & 0xFFFFFFDF) - 65;
      v11 = v9 - 48 >= 0xA && v10 >= 0x1A;
    }
    while (!v11 || v8 - 45 < 2 || v8 == 95);
    if (v8 != 58)
    {
LABEL_34:
      if (space)
      {
        v15 = (unsigned __int8 *)(i + 1);
        while (v8 <= 0x20 && ((1 << v8) & 0x100002600) != 0)
        {
          v16 = *v15++;
          v8 = v16;
        }
      }
      if (!v8)
        return 0;
      goto LABEL_40;
    }
    v12 = i[1];
    if ((v12 - 97) < 0x1A || v12 == 95 || (v12 - 65) <= 0x19)
    {
      for (i += 2; ; ++i)
      {
        v8 = *i;
        if (v8 - 48 >= 0xA
          && (v8 & 0xFFFFFFDF) - 65 >= 0x1A
          && (v8 - 45 > 0x32 || ((1 << (v8 - 45)) & 0x4000000000003) == 0))
        {
          break;
        }
      }
      goto LABEL_34;
    }
  }
LABEL_40:
  v17 = xmlStringCurrentChar(0, value, &len);
  v18 = v17;
  if (space)
  {
    if (v17 <= 255)
    {
      while (v18 <= 0x20 && ((1 << v18) & 0x100002600) != 0)
      {
        v3 += len;
        v18 = xmlStringCurrentChar(0, v3, &len);
        if (v18 >= 256)
          goto LABEL_53;
      }
LABEL_47:
      if ((v18 - 192) < 0x17
        || (v18 & 0xFFFFFFDF) - 65 < 0x1A
        || v18 > 247
        || (v18 - 216) < 0x1F
        || v18 == 95)
      {
        goto LABEL_64;
      }
      return 1;
    }
  }
  else if (v17 < 256)
  {
    goto LABEL_47;
  }
LABEL_53:
  if (xmlCharInRange(v18, &xmlIsBaseCharGroup))
    v19 = 1;
  else
    v19 = (v18 - 12330) > 0xFFFFFFF6;
  if (!v19 && v18 != 12295 && (v18 - 40870) < 0xFFFFAE5A)
    return 1;
  do
  {
    while (1)
    {
      do
      {
        do
        {
LABEL_64:
          while (1)
          {
            v3 += len;
            v22 = xmlStringCurrentChar(0, v3, &len);
            v23 = v22;
            if (v22 > 255)
              break;
            v24 = (v22 - 192) >= 0x17 && (v22 & 0xFFFFFFDF) - 65 >= 0x1A;
            if (v24 && (v22 - 48) >= 0xA && v22 <= 247 && (v22 - 216) >= 0x1F)
              goto LABEL_88;
          }
          if (xmlCharInRange(v22, &xmlIsBaseCharGroup))
            v26 = 0;
          else
            v26 = (v23 - 12321) >= 9;
          v28 = v26 && v23 != 12295 && (v23 - 19968) >= 0x51A6;
        }
        while (!v28 || xmlCharInRange(v23, &xmlIsDigitGroup));
LABEL_88:
        ;
      }
      while ((v23 - 45) <= 0x32 && ((1 << (v23 - 45)) & 0x4000000000003) != 0);
      if (v23 >= 256)
        break;
      if (v23 != 183)
        goto LABEL_98;
    }
  }
  while (xmlCharInRange(v23, &xmlIsCombiningGroup) || xmlCharInRange(v23, &xmlIsExtenderGroup));
LABEL_98:
  if (v23 == 58)
  {
    v3 += len;
    v30 = xmlStringCurrentChar(0, v3, &len);
    v31 = v30;
    if (v30 <= 255)
    {
      if ((v30 - 192) < 0x17
        || (v30 & 0xFFFFFFDF) - 65 < 0x1A
        || v30 == 95
        || v30 > 247
        || (v30 - 216) < 0x1F)
      {
        goto LABEL_111;
      }
      return 1;
    }
    if (!xmlCharInRange(v30, &xmlIsBaseCharGroup)
      && (v31 - 12330) <= 0xFFFFFFF6
      && v31 != 12295
      && (v31 - 40870) < 0xFFFFAE5A)
    {
      return 1;
    }
    while (1)
    {
LABEL_111:
      v3 += len;
      v32 = xmlStringCurrentChar(0, v3, &len);
      v23 = v32;
      if (v32 > 255)
      {
        if (xmlCharInRange(v32, &xmlIsBaseCharGroup))
          v35 = 0;
        else
          v35 = (v23 - 12321) >= 9;
        v37 = v35 && v23 != 12295 && (v23 - 19968) >= 0x51A6;
        if (!v37 || xmlCharInRange(v23, &xmlIsDigitGroup))
          continue;
      }
      else
      {
        v33 = (v32 - 192) >= 0x17 && (v32 & 0xFFFFFFDF) - 65 >= 0x1A;
        if (!v33 || (v32 - 48) < 0xA)
          continue;
        if (v32 > 247 || (v32 - 216) < 0x1F)
          continue;
      }
      if ((v23 - 45) > 0x32 || ((1 << (v23 - 45)) & 0x4000000000003) == 0)
      {
        if (v23 >= 256)
        {
          if (!xmlCharInRange(v23, &xmlIsCombiningGroup) && !xmlCharInRange(v23, &xmlIsExtenderGroup))
            break;
        }
        else if (v23 != 183)
        {
          break;
        }
      }
    }
  }
  if (space && v23 <= 255)
  {
    do
    {
      if (v23 > 0x20)
        break;
      if (((1 << v23) & 0x100002600) == 0)
        break;
      v3 += len;
      v23 = xmlStringCurrentChar(0, v3, &len);
    }
    while (v23 < 256);
  }
  return v23 != 0;
}

int xmlValidateName(const xmlChar *value, int space)
{
  const xmlChar *v3;
  const xmlChar *i;
  unsigned int v5;
  const xmlChar *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v14;
  int v15;
  signed int v16;
  BOOL v17;
  signed int v20;
  signed int v21;
  BOOL v22;
  BOOL v24;
  BOOL v26;
  int len;

  if (!value)
    return -1;
  v3 = value;
  if (space)
  {
    for (i = value; ; ++i)
    {
      v5 = *i;
      if (v5 > 0x20 || ((1 << v5) & 0x100002600) == 0)
        break;
    }
  }
  else
  {
    v5 = *value;
    i = value;
  }
  len = 0;
  if ((v5 & 0xFFFFFFDF) - 65 < 0x1A || v5 == 95 || v5 == 58)
  {
    do
    {
      v8 = i;
      v10 = *++i;
      v9 = v10;
      v11 = (v10 & 0xFFFFFFDF) - 65;
    }
    while (v10 - 48 < 0xA
         || v11 < 0x1A
         || v9 - 45 <= 0x32 && ((1 << (v9 - 45)) & 0x4000000002003) != 0);
    if (space)
    {
      v14 = 2;
      while (v9 <= 0x20 && ((1 << v9) & 0x100002600) != 0)
        v9 = v8[v14++];
    }
    if (!v9)
      return 0;
  }
  v15 = xmlStringCurrentChar(0, value, &len);
  v16 = v15;
  if (space)
  {
    if (v15 <= 255)
    {
      while (v16 <= 0x20 && ((1 << v16) & 0x100002600) != 0)
      {
        v3 += len;
        v16 = xmlStringCurrentChar(0, v3, &len);
        if (v16 >= 256)
          goto LABEL_45;
      }
      goto LABEL_38;
    }
  }
  else if (v15 < 256)
  {
LABEL_38:
    if ((v16 - 192) < 0x17
      || (v16 & 0xFFFFFFDF) - 65 < 0x1A
      || v16 > 247
      || (v16 - 216) < 0x1F
      || v16 == 95
      || v16 == 58)
    {
      goto LABEL_56;
    }
    return 1;
  }
LABEL_45:
  if (xmlCharInRange(v16, &xmlIsBaseCharGroup))
    v17 = 1;
  else
    v17 = (v16 - 12330) > 0xFFFFFFF6;
  if (!v17 && v16 != 12295 && (v16 - 40870) < 0xFFFFAE5A)
    return 1;
  do
  {
    while (1)
    {
      do
      {
        do
        {
LABEL_56:
          while (1)
          {
            v3 += len;
            v20 = xmlStringCurrentChar(0, v3, &len);
            v21 = v20;
            if (v20 > 255)
              break;
            v22 = (v20 - 192) >= 0x17 && (v20 & 0xFFFFFFDF) - 65 >= 0x1A;
            if (v22 && (v20 - 48) >= 0xA && v20 <= 247 && (v20 - 216) >= 0x1F)
              goto LABEL_80;
          }
          if (xmlCharInRange(v20, &xmlIsBaseCharGroup))
            v24 = 0;
          else
            v24 = (v21 - 12321) >= 9;
          v26 = v24 && v21 != 12295 && (v21 - 19968) >= 0x51A6;
        }
        while (!v26 || xmlCharInRange(v21, &xmlIsDigitGroup));
LABEL_80:
        ;
      }
      while ((v21 - 45) <= 0x32 && ((1 << (v21 - 45)) & 0x4000000002003) != 0);
      if (v21 >= 256)
        break;
      if (v21 != 183)
        goto LABEL_90;
    }
  }
  while (xmlCharInRange(v21, &xmlIsCombiningGroup) || xmlCharInRange(v21, &xmlIsExtenderGroup));
LABEL_90:
  if (space && v21 <= 255)
  {
    do
    {
      if (v21 > 0x20)
        break;
      if (((1 << v21) & 0x100002600) == 0)
        break;
      v3 += len;
      v21 = xmlStringCurrentChar(0, v3, &len);
    }
    while (v21 < 256);
  }
  return v21 != 0;
}

int xmlValidateNMToken(const xmlChar *value, int space)
{
  const xmlChar *v3;
  const xmlChar *i;
  unsigned int v5;
  BOOL v8;
  unsigned int v9;
  BOOL v10;
  uint64_t v11;
  BOOL v12;
  const xmlChar *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v19;
  int v20;
  signed int v21;
  char v22;
  BOOL v23;
  BOOL v25;
  signed int v26;
  signed int v27;
  BOOL v28;
  BOOL v30;
  BOOL v32;
  int len;

  if (!value)
    return -1;
  v3 = value;
  if (space)
  {
    for (i = value; ; ++i)
    {
      v5 = *i;
      if (v5 > 0x20 || ((1 << v5) & 0x100002600) == 0)
        break;
    }
  }
  else
  {
    v5 = *value;
    i = value;
  }
  len = 0;
  v8 = v5 - 48 >= 0xA && (v5 & 0xFFFFFFDF) - 65 >= 0x1A;
  if (!v8
    || ((v9 = v5 - 45, v10 = v9 > 0x32, v11 = (1 << v9) & 0x4000000002003, !v10) ? (v12 = v11 == 0) : (v12 = 1), !v12))
  {
    do
    {
      v13 = i;
      v15 = *++i;
      v14 = v15;
      v16 = (v15 & 0xFFFFFFDF) - 65;
    }
    while (v15 - 48 < 0xA
         || v16 < 0x1A
         || v14 - 45 <= 0x32 && ((1 << (v14 - 45)) & 0x4000000002003) != 0);
    if (space)
    {
      v19 = 2;
      while (v14 <= 0x20 && ((1 << v14) & 0x100002600) != 0)
        v14 = v13[v19++];
    }
    if (!v14)
      return 0;
  }
  v20 = xmlStringCurrentChar(0, value, &len);
  v21 = v20;
  if (space)
  {
    if (v20 <= 255)
    {
      while (v21 <= 0x20 && ((1 << v21) & 0x100002600) != 0)
      {
        v3 += len;
        v21 = xmlStringCurrentChar(0, v3, &len);
        if (v21 >= 256)
          goto LABEL_50;
      }
      goto LABEL_44;
    }
  }
  else if (v20 < 256)
  {
LABEL_44:
    if ((v21 - 192) < 0x17
      || (v21 & 0xFFFFFFDF) - 65 < 0x1A
      || v21 > 247
      || (v21 - 216) < 0x1F
      || (v21 - 48) < 0xA)
    {
      goto LABEL_60;
    }
    v22 = 1;
    goto LABEL_102;
  }
LABEL_50:
  if (xmlCharInRange(v21, &xmlIsBaseCharGroup))
    v23 = 0;
  else
    v23 = (v21 - 12321) >= 9;
  v25 = v23 && v21 != 12295 && (v21 - 19968) >= 0x51A6;
  if (!v25 || xmlCharInRange(v21, &xmlIsDigitGroup))
  {
    while (1)
    {
LABEL_60:
      while (1)
      {
        v3 += len;
        v26 = xmlStringCurrentChar(0, v3, &len);
        v27 = v26;
        if (v26 <= 255)
          break;
        if (xmlCharInRange(v26, &xmlIsBaseCharGroup))
          v30 = 0;
        else
          v30 = (v27 - 12321) >= 9;
        v32 = v30 && v27 != 12295 && (v27 - 19968) >= 0x51A6;
        if (v32 && !xmlCharInRange(v27, &xmlIsDigitGroup))
          goto LABEL_84;
      }
      v28 = (v26 - 192) >= 0x17 && (v26 & 0xFFFFFFDF) - 65 >= 0x1A;
      if (v28 && (v26 - 48) >= 0xA && v26 <= 247 && (v26 - 216) >= 0x1F)
      {
LABEL_84:
        if ((v27 - 45) > 0x32 || ((1 << (v27 - 45)) & 0x4000000002003) == 0)
        {
          if (v27 >= 256)
          {
            if (!xmlCharInRange(v27, &xmlIsCombiningGroup) && !xmlCharInRange(v27, &xmlIsExtenderGroup))
            {
LABEL_94:
              if (space && v27 <= 255)
              {
                do
                {
                  if (v27 > 0x20)
                    break;
                  if (((1 << v27) & 0x100002600) == 0)
                    break;
                  v3 += len;
                  v27 = xmlStringCurrentChar(0, v3, &len);
                }
                while (v27 < 256);
              }
              return v27 != 0;
            }
          }
          else if (v27 != 183)
          {
            goto LABEL_94;
          }
        }
      }
    }
  }
  v22 = 0;
LABEL_102:
  if ((v21 - 45) <= 0x32 && ((1 << (v21 - 45)) & 0x4000000002003) != 0)
    goto LABEL_60;
  if ((v22 & 1) != 0)
  {
    if (v21 == 183)
      goto LABEL_60;
  }
  else if (xmlCharInRange(v21, &xmlIsCombiningGroup) || xmlCharInRange(v21, &xmlIsExtenderGroup))
  {
    goto LABEL_60;
  }
  return 1;
}

void xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme)
{
  if (scheme <= XML_BUFFER_ALLOC_HYBRID && ((1 << scheme) & 0x13) != 0)
    *__xmlBufferAllocScheme() = scheme;
}

xmlBufferAllocationScheme xmlGetBufferAllocationScheme(void)
{
  return *__xmlBufferAllocScheme();
}

void xmlFreeNs(xmlNsPtr cur)
{
  xmlChar *href;
  xmlChar *prefix;

  if (cur)
  {
    href = (xmlChar *)cur->href;
    if (href)
      xmlFree(href);
    prefix = (xmlChar *)cur->prefix;
    if (prefix)
      xmlFree(prefix);
    xmlFree(cur);
  }
}

void xmlSetNs(xmlNodePtr node, xmlNsPtr ns)
{
  if (node)
  {
    if (node->type - 1 <= 1)
      node->ns = ns;
  }
}

xmlDtdPtr xmlNewDtd(xmlDocPtr doc, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  xmlDtd *v8;
  xmlDtd *v9;
  xmlRegisterNodeFunc *v10;

  if (doc && doc->extSubset)
    return 0;
  v9 = (xmlDtd *)xmlMalloc(0x80uLL);
  v8 = v9;
  if (v9)
  {
    *(_OWORD *)&v9->entities = 0u;
    *(_OWORD *)&v9->SystemID = 0u;
    *(_OWORD *)&v9->doc = 0u;
    *(_OWORD *)&v9->elements = 0u;
    *(_OWORD *)&v9->last = 0u;
    *(_OWORD *)&v9->next = 0u;
    *(_OWORD *)&v9->_private = 0u;
    *(_OWORD *)&v9->name = 0u;
    v9->type = XML_DTD_NODE;
    if (name)
      v9->name = xmlStrdup(name);
    if (ExternalID)
      v8->ExternalID = xmlStrdup(ExternalID);
    if (SystemID)
      v8->SystemID = xmlStrdup(SystemID);
    if (doc)
      doc->extSubset = v8;
    v8->doc = doc;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v10 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlDtd *))*v10)(v8);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building DTD");
  }
  return v8;
}

xmlDtdPtr xmlCreateIntSubset(xmlDocPtr doc, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  _xmlNode *children;
  xmlDtd *v9;
  xmlDtd *v10;
  xmlChar *v11;
  xmlChar *v12;
  xmlChar *v13;
  _xmlNode **p_children;
  _xmlNode *v15;
  _xmlNode *last;
  xmlChar *v17;
  xmlChar *v19;
  _xmlNode **p_prev;
  _xmlNode *prev;
  _xmlNode **p_next;
  xmlRegisterNodeFunc *v23;

  if (doc)
  {
    children = doc->children;
    if (children)
    {
      while (children->type != XML_DTD_NODE)
      {
        children = children->next;
        if (!children)
          goto LABEL_5;
      }
      return 0;
    }
LABEL_5:
    if (doc->intSubset)
      return 0;
  }
  v9 = (xmlDtd *)xmlMalloc(0x80uLL);
  v10 = v9;
  if (!v9)
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building internal subset");
    return v10;
  }
  *(_OWORD *)&v9->entities = 0u;
  *(_OWORD *)&v9->SystemID = 0u;
  *(_OWORD *)&v9->doc = 0u;
  *(_OWORD *)&v9->elements = 0u;
  *(_OWORD *)&v9->last = 0u;
  *(_OWORD *)&v9->next = 0u;
  *(_OWORD *)&v9->_private = 0u;
  *(_OWORD *)&v9->name = 0u;
  v9->type = XML_DTD_NODE;
  if (name)
  {
    v11 = xmlStrdup(name);
    v10->name = v11;
    if (!v11)
    {
      __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building internal subset");
      goto LABEL_24;
    }
  }
  if (ExternalID)
  {
    v12 = xmlStrdup(ExternalID);
    v10->ExternalID = v12;
    if (!v12)
    {
      __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building internal subset");
      v17 = (xmlChar *)v10->name;
      if (v17)
LABEL_23:
        xmlFree(v17);
LABEL_24:
      xmlFree(v10);
      return 0;
    }
  }
  if (SystemID)
  {
    v13 = xmlStrdup(SystemID);
    v10->SystemID = v13;
    if (!v13)
    {
      __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building internal subset");
      v19 = (xmlChar *)v10->name;
      if (v19)
        xmlFree(v19);
      v17 = (xmlChar *)v10->ExternalID;
      if (!v17)
        goto LABEL_24;
      goto LABEL_23;
    }
  }
  if (doc)
  {
    doc->intSubset = v10;
    v10->parent = doc;
    v10->doc = doc;
    p_children = &doc->children;
    v15 = doc->children;
    if (v15)
    {
      if (doc->type == XML_HTML_DOCUMENT_NODE)
      {
        v15->prev = (_xmlNode *)v10;
        v10->next = v15;
      }
      else
      {
        while (v15->type != XML_ELEMENT_NODE)
        {
          v15 = v15->next;
          if (!v15)
          {
            last = doc->last;
            last->next = (_xmlNode *)v10;
            v10->next = 0;
            v10->prev = last;
            p_children = &doc->last;
            goto LABEL_35;
          }
        }
        v10->next = v15;
        prev = v15->prev;
        p_prev = &v15->prev;
        v10->prev = prev;
        p_next = &prev->next;
        if (prev)
          p_children = p_next;
        *p_children = (_xmlNode *)v10;
        p_children = p_prev;
      }
    }
    else
    {
      doc->children = (_xmlNode *)v10;
      p_children = &doc->last;
    }
LABEL_35:
    *p_children = (_xmlNode *)v10;
  }
  if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
  {
    v23 = __xmlRegisterNodeDefaultValue();
    ((void (*)(xmlDtd *))*v23)(v10);
  }
  return v10;
}

void xmlFreeDtd(xmlDtdPtr cur)
{
  _xmlDoc *doc;
  xmlDict *dict;
  xmlDeregisterNodeFunc *v4;
  _xmlNode *children;
  _xmlNode *next;
  unsigned int type;
  BOOL v8;
  int v9;
  xmlChar *name;
  xmlChar *SystemID;
  xmlChar *ExternalID;
  xmlNotationTable *notations;
  xmlElementTable *elements;
  xmlAttributeTable *attributes;
  xmlEntitiesTable *entities;
  xmlEntitiesTable *pentities;

  if (!cur)
    return;
  doc = cur->doc;
  if (doc)
    dict = doc->dict;
  else
    dict = 0;
  if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
  {
    v4 = __xmlDeregisterNodeDefaultValue();
    ((void (*)(xmlDtdPtr))*v4)(cur);
  }
  children = cur->children;
  if (children)
  {
    do
    {
      next = children->next;
      type = children->type;
      v8 = type > 0x11;
      v9 = (1 << type) & 0x39000;
      if (v8 || v9 == 0)
      {
        xmlUnlinkNode(children);
        xmlFreeNode(children);
      }
      children = next;
    }
    while (next);
  }
  name = (xmlChar *)cur->name;
  if (name)
  {
    if (dict)
    {
      if (xmlDictOwns(dict, name))
        goto LABEL_22;
      name = (xmlChar *)cur->name;
    }
    xmlFree(name);
  }
LABEL_22:
  SystemID = (xmlChar *)cur->SystemID;
  if (!SystemID)
    goto LABEL_27;
  if (dict)
  {
    if (xmlDictOwns(dict, SystemID))
      goto LABEL_27;
    SystemID = (xmlChar *)cur->SystemID;
  }
  xmlFree(SystemID);
LABEL_27:
  ExternalID = (xmlChar *)cur->ExternalID;
  if (ExternalID)
  {
    if (!dict)
    {
LABEL_31:
      xmlFree(ExternalID);
      goto LABEL_32;
    }
    if (!xmlDictOwns(dict, ExternalID))
    {
      ExternalID = (xmlChar *)cur->ExternalID;
      goto LABEL_31;
    }
  }
LABEL_32:
  notations = (xmlNotationTable *)cur->notations;
  if (notations)
    xmlFreeNotationTable(notations);
  elements = (xmlElementTable *)cur->elements;
  if (elements)
    xmlFreeElementTable(elements);
  attributes = (xmlAttributeTable *)cur->attributes;
  if (attributes)
    xmlFreeAttributeTable(attributes);
  entities = (xmlEntitiesTable *)cur->entities;
  if (entities)
    xmlFreeEntitiesTable(entities);
  pentities = (xmlEntitiesTable *)cur->pentities;
  if (pentities)
    xmlFreeEntitiesTable(pentities);
  xmlFree(cur);
}

xmlNodePtr xmlNewDocText(const xmlDoc *doc, const xmlChar *content)
{
  xmlNodePtr result;

  result = xmlNewText(content);
  if (result)
    result->doc = (_xmlDoc *)doc;
  return result;
}

xmlNodePtr xmlAddNextSibling(xmlNodePtr cur, xmlNodePtr elem)
{
  xmlNodePtr v3;
  xmlElementType type;
  _xmlNode *next;
  _xmlDoc *doc;
  __int128 v7;
  _xmlNode *v8;
  xmlChar *v9;
  xmlChar *v10;

  if (cur)
  {
    v3 = cur;
    cur = 0;
    if (elem)
    {
      if (v3->type != XML_NAMESPACE_DECL)
      {
        cur = 0;
        if (v3 != elem && elem->type != XML_NAMESPACE_DECL)
        {
          xmlUnlinkNode(elem);
          type = elem->type;
          if (type == XML_ATTRIBUTE_NODE)
          {
            return xmlAddPropSibling((uint64_t)v3, (uint64_t)v3, (uint64_t)elem);
          }
          else
          {
            if (type != XML_TEXT_NODE)
              goto LABEL_14;
            if (v3->type == XML_TEXT_NODE)
            {
              xmlNodeAddContent(v3, elem->content);
              xmlFreeNode(elem);
              return v3;
            }
            next = v3->next;
            if (next && next->type == XML_TEXT_NODE && v3->name == next->name)
            {
              v9 = xmlStrdup(elem->content);
              v10 = xmlStrcat(v9, v3->next->content);
              xmlNodeSetContent(v3->next, v10);
              xmlFree(v10);
              xmlFreeNode(elem);
              return v3->next;
            }
            else
            {
LABEL_14:
              doc = v3->doc;
              if (elem->doc != doc)
                xmlSetTreeDoc(elem, doc);
              elem->prev = v3;
              v7 = *(_OWORD *)&v3->parent;
              *(_OWORD *)&elem->parent = v7;
              v3->next = elem;
              v8 = elem->next;
              if (v8)
                v8->prev = elem;
              if ((_QWORD)v7)
              {
                if (*(xmlNodePtr *)(v7 + 32) == v3)
                  *(_QWORD *)(v7 + 32) = elem;
              }
              return elem;
            }
          }
        }
      }
    }
  }
  return cur;
}

xmlNodePtr xmlNewReference(const xmlDoc *doc, const xmlChar *name)
{
  xmlNode *v4;
  xmlNode *v5;
  const xmlChar *v6;
  int v7;
  uint64_t v8;
  xmlChar *v9;
  xmlEntityPtr DocEntity;
  xmlRegisterNodeFunc *v11;

  if (!name)
    return 0;
  v4 = (xmlNode *)xmlMalloc(0x78uLL);
  v5 = v4;
  if (v4)
  {
    *(_QWORD *)&v4->line = 0;
    *(_OWORD *)&v4->content = 0u;
    *(_OWORD *)&v4->nsDef = 0u;
    *(_OWORD *)&v4->next = 0u;
    *(_OWORD *)&v4->doc = 0u;
    *(_OWORD *)&v4->name = 0u;
    *(_OWORD *)&v4->last = 0u;
    *(_OWORD *)&v4->_private = 0u;
    v4->type = XML_ENTITY_REF_NODE;
    v4->doc = (_xmlDoc *)doc;
    if (*name == 38)
    {
      v6 = name + 1;
      v7 = xmlStrlen(v6);
      v8 = v7 - 1;
      if (v6[v8] != 59)
        LODWORD(v8) = v7;
      v9 = xmlStrndup(v6, v8);
    }
    else
    {
      v9 = xmlStrdup(name);
    }
    v5->name = v9;
    DocEntity = xmlGetDocEntity(doc, v9);
    if (DocEntity)
    {
      v5->content = DocEntity->content;
      v5->children = (_xmlNode *)DocEntity;
      v5->last = (_xmlNode *)DocEntity;
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v11 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v11)(v5);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building reference");
  }
  return v5;
}

xmlChar *__cdecl xmlNodeListGetString(xmlDocPtr doc, const xmlNode *list, int inLine)
{
  return xmlNodeListGetStringInternal(doc, (uint64_t)list, inLine, 0);
}

xmlChar *xmlNodeListGetStringInternal(xmlDoc *a1, uint64_t a2, int a3, int a4)
{
  xmlChar *v4;
  uint64_t v6;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  int v11;
  xmlChar *v12;
  xmlChar *v13;
  xmlEntityPtr DocEntity;
  uint64_t StringInternal;
  xmlChar *v16;
  xmlChar *v17;
  xmlChar *v18;
  xmlChar *v19;
  xmlChar add[2];

  v4 = 0;
  if (a2 && a4 <= 40)
  {
    v6 = a2;
    v8 = *(_QWORD *)(a2 + 40);
    v9 = !v8 || *(_DWORD *)(v8 + 8) != 2;
    v4 = 0;
    v10 = (a4 + 1);
    while (1)
    {
      v11 = *(_DWORD *)(v6 + 8);
      if ((v11 - 3) < 2)
        break;
      if (v11 == 5)
      {
        if (!a3)
        {
          strcpy((char *)add, "&");
          v18 = xmlStrncat(v4, add, 1);
          v19 = xmlStrcat(v18, *(const xmlChar **)(v6 + 16));
          strcpy((char *)add, ";");
          v13 = xmlStrncat(v19, add, 1);
          goto LABEL_19;
        }
        DocEntity = xmlGetDocEntity(a1, *(const xmlChar **)(v6 + 16));
        if (!DocEntity)
        {
          v12 = *(xmlChar **)(v6 + 80);
          goto LABEL_10;
        }
        StringInternal = xmlNodeListGetStringInternal(a1, DocEntity->children, 1, v10);
        if (StringInternal)
        {
          v16 = (xmlChar *)StringInternal;
LABEL_22:
          v4 = xmlStrcat(v4, v16);
          xmlFree(v16);
        }
      }
LABEL_23:
      v6 = *(_QWORD *)(v6 + 48);
      if (!v6)
        return v4;
    }
    v12 = *(xmlChar **)(v6 + 80);
    if (!a3)
    {
      if (v9)
        v17 = xmlEncodeEntitiesReentrant(a1, v12);
      else
        v17 = (xmlChar *)xmlEncodeAttributeEntities((uint64_t)a1, (char *)v12);
      v16 = v17;
      if (!v17)
        goto LABEL_23;
      goto LABEL_22;
    }
LABEL_10:
    v13 = xmlStrcat(v4, v12);
LABEL_19:
    v4 = v13;
    goto LABEL_23;
  }
  return v4;
}

xmlChar *__cdecl xmlNodeListGetRawString(const xmlDoc *doc, const xmlNode *list, int inLine)
{
  const xmlNode *v4;
  xmlChar *v6;
  xmlElementType type;
  const xmlChar *content;
  xmlChar *v9;
  xmlEntityPtr DocEntity;
  xmlChar *RawString;
  xmlChar *v12;
  xmlChar *v13;
  xmlChar *v14;
  xmlChar add[2];

  if (list)
  {
    v4 = list;
    v6 = 0;
    while (1)
    {
      type = v4->type;
      if (type - 3 >= 2)
      {
        if (type == XML_ENTITY_REF_NODE)
        {
          if (!inLine)
          {
            strcpy((char *)add, "&");
            v13 = xmlStrncat(v6, add, 1);
            v14 = xmlStrcat(v13, v4->name);
            strcpy((char *)add, ";");
            v9 = xmlStrncat(v14, add, 1);
            goto LABEL_14;
          }
          DocEntity = xmlGetDocEntity(doc, v4->name);
          if (!DocEntity)
          {
            content = v4->content;
LABEL_5:
            v9 = xmlStrcat(v6, content);
LABEL_14:
            v6 = v9;
            goto LABEL_15;
          }
          RawString = xmlNodeListGetRawString(doc, DocEntity->children, 1);
          if (!RawString)
            goto LABEL_15;
LABEL_12:
          v12 = RawString;
          v6 = xmlStrcat(v6, RawString);
          xmlFree(v12);
        }
      }
      else
      {
        content = v4->content;
        if (inLine)
          goto LABEL_5;
        RawString = xmlEncodeSpecialChars(doc, content);
        if (RawString)
          goto LABEL_12;
      }
LABEL_15:
      v4 = v4->next;
      if (!v4)
        return v6;
    }
  }
  return 0;
}

xmlAttrPtr xmlNewNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name, const xmlChar *value)
{
  if (name)
    return xmlNewPropInternal((uint64_t)node, ns, (xmlChar *)name, value, 0);
  else
    return 0;
}

xmlAttrPtr xmlNewDocProp(xmlDocPtr doc, const xmlChar *name, const xmlChar *value)
{
  xmlAttr *v6;
  xmlAttr *v7;
  _xmlDict *dict;
  const xmlChar *v9;
  xmlNodePtr NodeList;
  _xmlNode *v11;
  xmlRegisterNodeFunc *v12;

  if (!name)
    return 0;
  v6 = (xmlAttr *)xmlMalloc(0x60uLL);
  v7 = v6;
  if (v6)
  {
    *(_OWORD *)&v6->doc = 0u;
    *(_OWORD *)&v6->atype = 0u;
    *(_OWORD *)&v6->last = 0u;
    *(_OWORD *)&v6->next = 0u;
    *(_OWORD *)&v6->_private = 0u;
    *(_OWORD *)&v6->name = 0u;
    v6->type = XML_ATTRIBUTE_NODE;
    if (doc && (dict = doc->dict) != 0)
      v9 = xmlDictLookup(dict, name, -1);
    else
      v9 = xmlStrdup(name);
    v7->name = v9;
    v7->doc = doc;
    if (value)
    {
      NodeList = xmlStringGetNodeList(doc, value);
      v7->children = NodeList;
      v7->last = 0;
      if (NodeList)
      {
        do
        {
          v11 = NodeList;
          NodeList->parent = (_xmlNode *)v7;
          NodeList = NodeList->next;
        }
        while (NodeList);
        v7->last = v11;
      }
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v12 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlAttr *))*v12)(v7);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building attribute");
  }
  return v7;
}

void xmlFreePropList(xmlAttrPtr cur)
{
  _xmlAttr *next;

  if (cur)
  {
    do
    {
      next = cur->next;
      xmlFreeProp(cur);
      cur = next;
    }
    while (next);
  }
}

int xmlRemoveProp(xmlAttrPtr cur)
{
  _xmlNode *parent;
  xmlAttr *properties;
  xmlAttr *v3;
  _xmlAttr *next;

  if (!cur)
    return -1;
  parent = cur->parent;
  if (!parent)
    return -1;
  properties = parent->properties;
  if (properties != cur)
  {
    while (properties)
    {
      v3 = properties;
      properties = properties->next;
      if (properties == cur)
      {
        next = cur->next;
        v3->next = next;
        if (next)
          goto LABEL_12;
        goto LABEL_13;
      }
    }
    return -1;
  }
  next = cur->next;
  parent->properties = next;
  if (next)
  {
    v3 = 0;
LABEL_12:
    next->prev = v3;
  }
LABEL_13:
  xmlFreeProp(cur);
  return 0;
}

xmlNodePtr xmlNewDocPI(xmlDocPtr doc, const xmlChar *name, const xmlChar *content)
{
  xmlNode *v6;
  xmlNode *v7;
  _xmlDict *dict;
  const xmlChar *v9;
  xmlRegisterNodeFunc *v10;

  if (!name)
    return 0;
  v6 = (xmlNode *)xmlMalloc(0x78uLL);
  v7 = v6;
  if (v6)
  {
    *(_QWORD *)&v6->line = 0;
    *(_OWORD *)&v6->content = 0u;
    *(_OWORD *)&v6->nsDef = 0u;
    *(_OWORD *)&v6->next = 0u;
    *(_OWORD *)&v6->doc = 0u;
    *(_OWORD *)&v6->name = 0u;
    *(_OWORD *)&v6->last = 0u;
    *(_OWORD *)&v6->_private = 0u;
    v6->type = XML_PI_NODE;
    if (doc && (dict = doc->dict) != 0)
      v9 = xmlDictLookup(dict, name, -1);
    else
      v9 = xmlStrdup(name);
    v7->name = v9;
    if (content)
      v7->content = xmlStrdup(content);
    v7->doc = doc;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v10 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v10)(v7);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building PI");
  }
  return v7;
}

xmlNodePtr xmlNewPI(const xmlChar *name, const xmlChar *content)
{
  return xmlNewDocPI(0, name, content);
}

xmlNodePtr xmlNewDocRawNode(xmlDocPtr doc, xmlNsPtr ns, const xmlChar *name, const xmlChar *content)
{
  xmlNodePtr v6;
  xmlNode *v7;
  xmlNodePtr v8;
  _xmlNode *next;
  xmlNodePtr v10;

  v6 = xmlNewDocNode(doc, ns, name, 0);
  v7 = v6;
  if (v6)
  {
    v6->doc = doc;
    if (content)
    {
      v8 = xmlNewText(content);
      if (v8)
      {
        v8->doc = doc;
        v7->children = v8;
        next = v8->next;
        if (next)
        {
          do
          {
            v10 = next;
            v8->parent = v7;
            next = next->next;
            v8 = v10;
          }
          while (next);
        }
        else
        {
          v10 = v8;
        }
        v10->parent = v7;
        v7->last = v10;
      }
      else
      {
        v7->children = 0;
        v7->last = 0;
      }
    }
  }
  return v7;
}

xmlNodePtr xmlNewDocFragment(xmlDocPtr doc)
{
  xmlNode *v2;
  xmlNode *v3;
  xmlRegisterNodeFunc *v4;

  v2 = (xmlNode *)xmlMalloc(0x78uLL);
  v3 = v2;
  if (v2)
  {
    *(_QWORD *)&v2->line = 0;
    *(_OWORD *)&v2->content = 0u;
    *(_OWORD *)&v2->nsDef = 0u;
    *(_OWORD *)&v2->next = 0u;
    *(_OWORD *)&v2->doc = 0u;
    *(_OWORD *)&v2->name = 0u;
    *(_OWORD *)&v2->last = 0u;
    *(_OWORD *)&v2->_private = 0u;
    v2->type = XML_DOCUMENT_FRAG_NODE;
    v2->doc = doc;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v4 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v4)(v3);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building fragment");
  }
  return v3;
}

xmlNodePtr xmlNewTextChild(xmlNodePtr parent, xmlNsPtr ns, const xmlChar *name, const xmlChar *content)
{
  xmlNodePtr result;
  unint64_t v6;
  xmlDoc *doc;
  _xmlNode **p_last;
  _xmlNode *last;

  result = 0;
  if (parent && name)
  {
    result = 0;
    HIDWORD(v6) = parent->type - 1;
    LODWORD(v6) = HIDWORD(v6);
    switch((v6 >> 1))
    {
      case 0u:
        doc = parent->doc;
        if (!ns)
          ns = parent->ns;
        goto LABEL_8;
      case 4u:
      case 6u:
        doc = (xmlDoc *)parent;
        goto LABEL_8;
      case 5u:
        doc = parent->doc;
LABEL_8:
        result = xmlNewDocRawNode(doc, ns, name, content);
        if (result)
        {
          result->type = XML_ELEMENT_NODE;
          result->parent = parent;
          result->doc = parent->doc;
          if (parent->children)
          {
            last = parent->last;
            p_last = &parent->last;
            last->next = result;
            result->prev = last;
          }
          else
          {
            parent->children = result;
            p_last = &parent->last;
          }
          *p_last = result;
        }
        break;
      default:
        return result;
    }
  }
  return result;
}

xmlNodePtr xmlNewCharRef(xmlDocPtr doc, const xmlChar *name)
{
  xmlNode *v4;
  xmlNode *v5;
  const xmlChar *v6;
  int v7;
  uint64_t v8;
  xmlChar *v9;
  xmlRegisterNodeFunc *v10;

  if (!name)
    return 0;
  v4 = (xmlNode *)xmlMalloc(0x78uLL);
  v5 = v4;
  if (v4)
  {
    *(_QWORD *)&v4->line = 0;
    *(_OWORD *)&v4->content = 0u;
    *(_OWORD *)&v4->nsDef = 0u;
    *(_OWORD *)&v4->next = 0u;
    *(_OWORD *)&v4->doc = 0u;
    *(_OWORD *)&v4->name = 0u;
    *(_OWORD *)&v4->last = 0u;
    *(_OWORD *)&v4->_private = 0u;
    v4->type = XML_ENTITY_REF_NODE;
    v4->doc = doc;
    if (*name == 38)
    {
      v6 = name + 1;
      v7 = xmlStrlen(v6);
      v8 = v7 - 1;
      if (v6[v8] != 59)
        LODWORD(v8) = v7;
      v9 = xmlStrndup(v6, v8);
    }
    else
    {
      v9 = xmlStrdup(name);
    }
    v5->name = v9;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v10 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v10)(v5);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building character reference");
  }
  return v5;
}

xmlNodePtr xmlNewTextLen(const xmlChar *content, int len)
{
  xmlNode *v4;
  xmlNode *v5;
  xmlRegisterNodeFunc *v6;

  v4 = (xmlNode *)xmlMalloc(0x78uLL);
  v5 = v4;
  if (v4)
  {
    *(_OWORD *)&v4->_private = 0u;
    *(_OWORD *)&v4->name = 0u;
    *(_QWORD *)&v4->line = 0;
    *(_OWORD *)&v4->content = 0u;
    *(_OWORD *)&v4->nsDef = 0u;
    *(_OWORD *)&v4->next = 0u;
    *(_OWORD *)&v4->doc = 0u;
    *(_OWORD *)&v4->last = 0u;
    v4->type = XML_TEXT_NODE;
    v4->name = "text";
    if (content)
      v4->content = xmlStrndup(content, len);
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v6 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v6)(v5);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building text");
  }
  return v5;
}

xmlNodePtr xmlNewDocTextLen(xmlDocPtr doc, const xmlChar *content, int len)
{
  xmlNodePtr result;

  result = xmlNewTextLen(content, len);
  if (result)
    result->doc = doc;
  return result;
}

xmlNodePtr xmlNewCDataBlock(xmlDocPtr doc, const xmlChar *content, int len)
{
  xmlNode *v6;
  xmlNode *v7;
  xmlRegisterNodeFunc *v8;

  v6 = (xmlNode *)xmlMalloc(0x78uLL);
  v7 = v6;
  if (v6)
  {
    *(_QWORD *)&v6->line = 0;
    *(_OWORD *)&v6->content = 0u;
    *(_OWORD *)&v6->nsDef = 0u;
    *(_OWORD *)&v6->next = 0u;
    *(_OWORD *)&v6->doc = 0u;
    *(_OWORD *)&v6->name = 0u;
    *(_OWORD *)&v6->last = 0u;
    *(_OWORD *)&v6->_private = 0u;
    v6->type = XML_CDATA_SECTION_NODE;
    v6->doc = doc;
    if (content)
      v6->content = xmlStrndup(content, len);
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      v8 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v8)(v7);
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"building CDATA");
  }
  return v7;
}

void xmlSetListDoc(xmlNodePtr list, xmlDocPtr doc)
{
  xmlNodePtr v2;

  if (list)
  {
    v2 = list;
    if (list->type != XML_NAMESPACE_DECL)
    {
      do
      {
        if (v2->doc != doc)
          xmlSetTreeDoc(v2, doc);
        v2 = v2->next;
      }
      while (v2);
    }
  }
}

void xmlNodeAddContent(xmlNodePtr cur, const xmlChar *content)
{
  int v4;

  if (cur)
  {
    if (content)
    {
      v4 = xmlStrlen(content);
      xmlNodeAddContentLen(cur, content, v4);
    }
  }
}

void xmlNodeSetContent(xmlNodePtr cur, const xmlChar *content)
{
  xmlElementType type;
  int v5;
  xmlChar *v6;
  _xmlAttr **p_properties;
  BOOL v8;
  _xmlDoc *doc;
  xmlDict *dict;
  xmlNode *children;
  xmlChar *v12;
  xmlNode *v13;
  xmlNodePtr NodeList;
  _xmlNode *next;
  _xmlNode *v16;

  if (!cur)
    return;
  type = cur->type;
  if (type > XML_DOCUMENT_FRAG_NODE)
    return;
  v5 = 1 << type;
  if ((v5 & 0x1F8) != 0)
  {
    v6 = cur->content;
    p_properties = &cur->properties;
    if (v6)
      v8 = v6 == (xmlChar *)p_properties;
    else
      v8 = 1;
    if (v8)
      goto LABEL_13;
    doc = cur->doc;
    if (doc)
    {
      dict = doc->dict;
      if (dict)
      {
        if (xmlDictOwns(dict, v6))
        {
LABEL_13:
          children = cur->children;
          if (children)
            xmlFreeNodeList(children);
          cur->children = 0;
          cur->last = 0;
          if (content)
            v12 = xmlStrdup(content);
          else
            v12 = 0;
          cur->content = v12;
          *p_properties = 0;
          cur->nsDef = 0;
          return;
        }
        v6 = cur->content;
      }
    }
    xmlFree(v6);
    goto LABEL_13;
  }
  if ((v5 & 0x806) != 0)
  {
    v13 = cur->children;
    if (v13)
      xmlFreeNodeList(v13);
    NodeList = xmlStringGetNodeList(cur->doc, content);
    cur->children = NodeList;
    if (NodeList)
    {
      next = NodeList->next;
      if (next)
      {
        do
        {
          v16 = next;
          NodeList->parent = cur;
          next = next->next;
          NodeList = v16;
        }
        while (next);
      }
      else
      {
        v16 = NodeList;
      }
      v16->parent = cur;
      cur->last = v16;
    }
    else
    {
      cur->last = 0;
    }
  }
}

xmlNode *xmlAddPropSibling(uint64_t a1, uint64_t a2, uint64_t a3)
{
  xmlNode *v3;
  _xmlNode *next;
  uint64_t v6;
  uint64_t v7;
  xmlChar *v8;
  const xmlChar *v9;
  xmlAttributePtr PropNodeInternal;
  xmlDoc *doc;
  _xmlNode *parent;

  if (*(_DWORD *)(a2 + 8) != 2)
    return 0;
  v3 = (xmlNode *)a3;
  if (*(_DWORD *)(a3 + 8) != 2)
    return 0;
  next = (_xmlNode *)a2;
  if (a1)
  {
    if (*(_DWORD *)(a1 + 8) != 2)
      return 0;
  }
  v6 = *(_QWORD *)(a3 + 72);
  v7 = *(_QWORD *)(a2 + 40);
  v8 = *(xmlChar **)(a3 + 16);
  if (v6)
    v9 = *(const xmlChar **)(v6 + 16);
  else
    v9 = 0;
  PropNodeInternal = xmlGetPropNodeInternal(v7, v8, v9, 1);
  doc = next->doc;
  if (v3->doc != doc)
    xmlSetTreeDoc(v3, doc);
  parent = next->parent;
  v3->parent = parent;
  v3->prev = (_xmlNode *)a1;
  if (!a1)
  {
    v3->next = next;
    goto LABEL_16;
  }
  v3->next = *(_xmlNode **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = v3;
  next = v3->next;
  if (next)
LABEL_16:
    next->prev = v3;
  if (!v3->prev && parent)
    parent->properties = (_xmlAttr *)v3;
  if (PropNodeInternal && PropNodeInternal->type != XML_ATTRIBUTE_DECL)
    xmlRemoveProp((xmlAttrPtr)PropNodeInternal);
  return v3;
}

xmlNodePtr xmlAddPrevSibling(xmlNodePtr cur, xmlNodePtr elem)
{
  xmlNodePtr v3;
  xmlElementType type;
  xmlChar *v5;
  xmlChar *v6;
  _xmlNode *prev;
  _xmlDoc *doc;
  _xmlNode *parent;
  _xmlNode *v10;

  if (cur)
  {
    v3 = cur;
    cur = 0;
    if (elem)
    {
      if (v3->type != XML_NAMESPACE_DECL)
      {
        cur = 0;
        if (v3 != elem && elem->type != XML_NAMESPACE_DECL)
        {
          xmlUnlinkNode(elem);
          type = elem->type;
          if (type == XML_ATTRIBUTE_NODE)
          {
            return xmlAddPropSibling((uint64_t)v3->prev, (uint64_t)v3, (uint64_t)elem);
          }
          else
          {
            if (type != XML_TEXT_NODE)
              goto LABEL_14;
            if (v3->type == XML_TEXT_NODE)
            {
              v5 = xmlStrdup(elem->content);
              v6 = xmlStrcat(v5, v3->content);
              xmlNodeSetContent(v3, v6);
              xmlFree(v6);
              xmlFreeNode(elem);
              return v3;
            }
            prev = v3->prev;
            if (prev && prev->type == XML_TEXT_NODE && v3->name == prev->name)
            {
              xmlNodeAddContent(prev, elem->content);
              xmlFreeNode(elem);
              return v3->prev;
            }
            else
            {
LABEL_14:
              doc = v3->doc;
              if (elem->doc != doc)
                xmlSetTreeDoc(elem, doc);
              parent = v3->parent;
              elem->parent = parent;
              elem->next = v3;
              elem->prev = v3->prev;
              v3->prev = elem;
              v10 = elem->prev;
              if (v10)
                v10->next = elem;
              if (parent)
              {
                if (parent->children == v3)
                  parent->children = elem;
              }
              return elem;
            }
          }
        }
      }
    }
  }
  return cur;
}

xmlNodePtr xmlAddSibling(xmlNodePtr cur, xmlNodePtr elem)
{
  xmlNodePtr last;
  xmlElementType type;
  _xmlNode *parent;
  xmlElementType v6;
  _xmlDoc *doc;
  _xmlNode *v10;

  if (!cur)
    return 0;
  last = 0;
  if (elem)
  {
    type = cur->type;
    if (type != XML_NAMESPACE_DECL)
    {
      last = 0;
      if (cur != elem && elem->type != XML_NAMESPACE_DECL)
      {
        if (type == XML_ATTRIBUTE_NODE
          || (parent = cur->parent) == 0
          || !parent->children
          || (last = parent->last) == 0
          || last->next)
        {
          do
          {
            last = cur;
            cur = cur->next;
          }
          while (cur);
        }
        xmlUnlinkNode(elem);
        v6 = elem->type;
        if (last->type != XML_TEXT_NODE || v6 != XML_TEXT_NODE)
        {
          if (v6 == XML_ATTRIBUTE_NODE)
            return xmlAddPropSibling((uint64_t)last, (uint64_t)last, (uint64_t)elem);
          goto LABEL_21;
        }
        if (last->name != elem->name)
        {
LABEL_21:
          doc = last->doc;
          if (elem->doc != doc)
            xmlSetTreeDoc(elem, doc);
          v10 = last->parent;
          elem->next = 0;
          elem->prev = last;
          elem->parent = v10;
          last->next = elem;
          if (v10)
            v10->last = elem;
          return elem;
        }
        xmlNodeAddContent(last, elem->content);
        xmlFreeNode(elem);
      }
    }
  }
  return last;
}

xmlNodePtr xmlAddChildList(xmlNodePtr parent, xmlNodePtr cur)
{
  xmlNodePtr v2;
  xmlNode *v3;
  xmlElementType type;
  _xmlNode *last;
  xmlNode *next;
  _xmlNode *v8;
  _xmlNode *v9;
  _xmlNode **p_next;
  _xmlDoc *doc;
  _xmlDoc *v12;

  if (!parent)
    return 0;
  v2 = cur;
  v3 = 0;
  if (cur && parent->type != XML_NAMESPACE_DECL)
  {
    type = cur->type;
    if (type == XML_NAMESPACE_DECL)
      return 0;
    if (parent->children)
    {
      if (type == XML_TEXT_NODE)
      {
        last = parent->last;
        if (last->type == XML_TEXT_NODE && cur->name == last->name)
        {
          xmlNodeAddContent(last, cur->content);
          next = v2->next;
          xmlFreeNode(v2);
          v2 = next;
          if (!next)
            return parent->last;
        }
      }
      v8 = parent->last;
      v8->next = v2;
      v2->prev = v8;
    }
    else
    {
      parent->children = cur;
    }
    p_next = &v2->next;
    v9 = v2->next;
    if (v9)
    {
      v3 = v2;
      do
      {
        v3->parent = parent;
        doc = parent->doc;
        if (v3->doc != doc)
        {
          xmlSetTreeDoc(v3, doc);
          v9 = *p_next;
        }
        v3 = v9;
        p_next = &v9->next;
        v9 = v9->next;
      }
      while (v9);
    }
    else
    {
      v3 = v2;
    }
    v3->parent = parent;
    v12 = parent->doc;
    if (v3->doc != v12)
      xmlSetTreeDoc(v3, v12);
    parent->last = v3;
  }
  return v3;
}

xmlAttrPtr xmlHasNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace)
{
  return (xmlAttrPtr)xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, nameSpace, 1);
}

xmlNodePtr xmlGetLastChild(xmlNodePtr parent)
{
  if (parent)
  {
    if (parent->type == XML_NAMESPACE_DECL)
      return 0;
    else
      return parent->last;
  }
  return parent;
}

unint64_t xmlChildElementCount(unint64_t parent)
{
  unsigned int v1;
  BOOL v2;
  int v3;
  uint64_t v5;

  if (parent)
  {
    v1 = *(_DWORD *)(parent + 8);
    v2 = v1 > 0xD;
    v3 = (1 << v1) & 0x2A42;
    if (v2 || v3 == 0)
      return 0;
    v5 = *(_QWORD *)(parent + 24);
    if (!v5)
    {
      return 0;
    }
    else
    {
      parent = 0;
      do
      {
        if (*(_DWORD *)(v5 + 8) == 1)
          ++parent;
        v5 = *(_QWORD *)(v5 + 48);
      }
      while (v5);
    }
  }
  return parent;
}

xmlNodePtr xmlFirstElementChild(xmlNodePtr parent)
{
  xmlElementType type;
  BOOL v2;
  int v3;

  if (parent)
  {
    type = parent->type;
    v2 = type > XML_HTML_DOCUMENT_NODE;
    v3 = (1 << type) & 0x2A42;
    if (v2 || v3 == 0)
    {
      return 0;
    }
    else
    {
      for (parent = parent->children; parent; parent = parent->next)
      {
        if (parent->type == XML_ELEMENT_NODE)
          break;
      }
    }
  }
  return parent;
}

xmlNodePtr xmlLastElementChild(xmlNodePtr parent)
{
  xmlElementType type;
  BOOL v2;
  int v3;

  if (parent)
  {
    type = parent->type;
    v2 = type > XML_HTML_DOCUMENT_NODE;
    v3 = (1 << type) & 0x2A42;
    if (v2 || v3 == 0)
    {
      return 0;
    }
    else
    {
      for (parent = parent->last; parent; parent = parent->prev)
      {
        if (parent->type == XML_ELEMENT_NODE)
          break;
      }
    }
  }
  return parent;
}

xmlNodePtr xmlPreviousElementSibling(xmlNodePtr node)
{
  xmlElementType type;
  BOOL v2;
  int v3;

  if (node)
  {
    type = node->type;
    v2 = type > XML_XINCLUDE_END;
    v3 = (1 << type) & 0x1801FA;
    if (v2 || v3 == 0)
    {
      return 0;
    }
    else
    {
      do
        node = node->prev;
      while (node && node->type != XML_ELEMENT_NODE);
    }
  }
  return node;
}

xmlNodePtr xmlNextElementSibling(xmlNodePtr node)
{
  xmlElementType type;
  BOOL v2;
  int v3;

  if (node)
  {
    type = node->type;
    v2 = type > XML_XINCLUDE_END;
    v3 = (1 << type) & 0x1841FA;
    if (v2 || v3 == 0)
    {
      return 0;
    }
    else
    {
      do
        node = node->next;
      while (node && node->type != XML_ELEMENT_NODE);
    }
  }
  return node;
}

xmlNodePtr xmlReplaceNode(xmlNodePtr old, xmlNodePtr cur)
{
  xmlNodePtr result;
  xmlElementType type;
  xmlElementType v6;
  BOOL v7;
  char v8;
  _xmlNode *parent;
  _xmlNode *next;
  _xmlNode *prev;
  _QWORD *p_properties;
  xmlNode *v13;
  xmlNode *properties;
  xmlNode *last;

  result = 0;
  if (old && old != cur)
  {
    type = old->type;
    if (type == XML_NAMESPACE_DECL || !old->parent)
    {
      return 0;
    }
    else
    {
      if (!cur || (v6 = cur->type, v6 == XML_NAMESPACE_DECL))
      {
        xmlUnlinkNode(old);
        return old;
      }
      v7 = type == XML_ATTRIBUTE_NODE;
      v8 = !v7;
      if (v6 == XML_ATTRIBUTE_NODE)
        v7 = v8;
      if (v7)
        return old;
      xmlUnlinkNode(cur);
      xmlSetTreeDoc(cur, old->doc);
      parent = old->parent;
      next = old->next;
      cur->parent = parent;
      cur->next = next;
      if (next)
        next->prev = cur;
      prev = old->prev;
      cur->prev = prev;
      if (prev)
        prev->next = cur;
      if (parent)
      {
        if (cur->type == XML_ATTRIBUTE_NODE)
        {
          properties = (xmlNode *)parent->properties;
          p_properties = &parent->properties;
          v13 = properties;
        }
        else
        {
          if (parent->children == old)
            parent->children = cur;
          last = parent->last;
          p_properties = &parent->last;
          v13 = last;
        }
        if (v13 == old)
          *p_properties = cur;
      }
      old->parent = 0;
      old->next = 0;
      result = old;
      old->prev = 0;
    }
  }
  return result;
}

xmlNsPtr xmlCopyNamespace(xmlNsPtr cur)
{
  if (cur && cur->type == XML_NAMESPACE_DECL)
    return xmlNewNs(0, cur->href, cur->prefix);
  else
    return 0;
}

xmlNsPtr xmlCopyNamespaceList(xmlNsPtr cur)
{
  xmlNsPtr v1;
  xmlNs *v2;
  xmlNs *v3;
  xmlNs *v4;

  if (cur)
  {
    v1 = cur;
    v2 = 0;
    v3 = 0;
    do
    {
      if (v1->type == XML_NAMESPACE_DECL)
        v4 = xmlNewNs(0, v1->href, v1->prefix);
      else
        v4 = 0;
      cur = v4;
      if (v2)
      {
        v2->next = v4;
        cur = v3;
      }
      v1 = v1->next;
      v2 = v4;
      v3 = cur;
    }
    while (v1);
  }
  return cur;
}

xmlAttrPtr xmlCopyProp(xmlNodePtr target, xmlAttrPtr cur)
{
  return xmlCopyPropInternal(0, (uint64_t)target, (uint64_t)cur);
}

xmlAttrPtr xmlCopyPropInternal(xmlDoc *a1, uint64_t a2, uint64_t a3)
{
  xmlAttrPtr v5;
  uint64_t v6;
  const xmlChar *v7;
  xmlAttrPtr v8;
  xmlNsPtr v9;
  uint64_t v10;
  xmlNsPtr v11;
  xmlNsPtr v12;
  xmlNsPtr v13;
  xmlNode *v14;
  xmlNode *v15;
  xmlNode *v16;
  xmlDtd *v17;
  xmlNode *v18;
  xmlNode *v19;
  xmlDoc *v20;
  xmlNode *v21;
  xmlChar *StringInternal;
  xmlChar *v23;

  if (!a3)
    return 0;
  if (a2)
  {
    if (*(_DWORD *)(a2 + 8) == 1)
    {
      a1 = *(xmlDoc **)(a2 + 64);
LABEL_10:
      v7 = *(const xmlChar **)(a3 + 16);
      goto LABEL_11;
    }
    return 0;
  }
  if (a1)
    goto LABEL_10;
  v6 = *(_QWORD *)(a3 + 40);
  if (v6 || (v6 = *(_QWORD *)(a3 + 24)) != 0)
  {
    a1 = *(xmlDoc **)(v6 + 64);
    goto LABEL_10;
  }
  v7 = *(const xmlChar **)(a3 + 16);
  a1 = 0;
LABEL_11:
  v8 = xmlNewDocProp(a1, v7, 0);
  v5 = v8;
  if (!v8)
    return v5;
  v9 = 0;
  v8->parent = (_xmlNode *)a2;
  if (!a2)
    goto LABEL_24;
  v10 = *(_QWORD *)(a3 + 72);
  if (!v10)
    goto LABEL_24;
  v11 = xmlSearchNs(*(xmlDocPtr *)(a2 + 64), (xmlNodePtr)a2, *(const xmlChar **)(v10 + 24));
  if (!v11)
  {
    v13 = xmlSearchNs(*(xmlDocPtr *)(a3 + 64), *(xmlNodePtr *)(a3 + 40), *(const xmlChar **)(*(_QWORD *)(a3 + 72) + 24));
    if (!v13)
      goto LABEL_25;
    v14 = 0;
    v15 = (xmlNode *)a2;
    do
    {
      v16 = v14;
      v14 = v15;
      v15 = v15->parent;
    }
    while (v15);
    if (v14 == *(xmlNode **)(a2 + 64))
      v14 = v16;
    v12 = xmlNewNs(v14, v13->href, v13->prefix);
    goto LABEL_23;
  }
  v9 = v11;
  if (!xmlStrEqual(v11->href, *(const xmlChar **)(*(_QWORD *)(a3 + 72) + 16)))
  {
    v12 = xmlNewReconciledNs(*(xmlDocPtr *)(a2 + 64), (xmlNodePtr)a2, *(_QWORD *)(a3 + 72));
LABEL_23:
    v9 = v12;
  }
LABEL_24:
  v5->ns = v9;
LABEL_25:
  v17 = *(xmlDtd **)(a3 + 24);
  if (v17)
  {
    v18 = xmlStaticCopyNodeList(v17, v5->doc, (_xmlDoc *)v5);
    v5->children = v18;
    v5->last = 0;
    if (v18)
    {
      do
      {
        v19 = v18;
        v18 = v18->next;
      }
      while (v18);
      v5->last = v19;
    }
  }
  if (a2)
  {
    if (*(_QWORD *)(a2 + 64))
    {
      v20 = *(xmlDoc **)(a3 + 64);
      if (v20)
      {
        if (v20->ids)
        {
          v21 = *(xmlNode **)(a3 + 40);
          if (v21)
          {
            if (xmlIsID(v20, v21, (xmlAttrPtr)a3))
            {
              StringInternal = xmlNodeListGetStringInternal(*(xmlDoc **)(a3 + 64), *(_QWORD *)(a3 + 24), 1, 0);
              if (StringInternal)
              {
                v23 = StringInternal;
                xmlAddID(0, *(xmlDocPtr *)(a2 + 64), StringInternal, v5);
                xmlFree(v23);
              }
            }
          }
        }
      }
    }
  }
  return v5;
}

xmlAttrPtr xmlCopyPropList(xmlNodePtr target, xmlAttrPtr cur)
{
  xmlAttrPtr v2;
  xmlAttrPtr result;
  _xmlAttr *v6;
  xmlAttr *v7;
  xmlAttrPtr v8;

  v2 = cur;
  if (!target)
  {
    if (cur)
      goto LABEL_9;
    return 0;
  }
  if (target->type != XML_ELEMENT_NODE || cur == 0)
    return 0;
LABEL_9:
  v6 = 0;
  v7 = 0;
  do
  {
    result = xmlCopyPropInternal(0, (uint64_t)target, (uint64_t)v2);
    if (!result)
      break;
    v8 = result;
    if (v6)
    {
      v6->next = result;
      result->prev = v6;
      result = v7;
    }
    v2 = v2->next;
    v6 = v8;
    v7 = result;
  }
  while (v2);
  return result;
}

xmlNodePtr xmlCopyNode(xmlNodePtr node, int recursive)
{
  return xmlStaticCopyNode(node, 0, 0, recursive);
}

xmlNodePtr xmlStaticCopyNode(xmlNodePtr result, xmlDoc *a2, xmlNode *a3, int a4)
{
  uint64_t v7;
  int v8;
  xmlNode *v9;
  xmlNode *v10;
  const xmlChar *v11;
  const xmlChar *v12;
  xmlDict *dict;
  unsigned int v14;
  const xmlChar *v15;
  xmlRegisterNodeFunc *v16;
  int v17;
  xmlNs *v18;
  uint64_t v19;
  xmlNsPtr v20;
  xmlNsPtr v21;
  xmlNode *v22;
  xmlNode *v23;
  int v24;
  xmlAttr *v26;
  xmlEntityPtr DocEntity;
  uint64_t v28;
  uint64_t v29;
  _QWORD *p_private;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  xmlRegisterNodeFunc *v34;

  if (!result)
    return result;
  v7 = (uint64_t)result;
  v8 = result->type - 2;
  result = 0;
  switch(v8)
  {
    case 0:
      return (xmlNodePtr)xmlCopyPropInternal(a2, (uint64_t)a3, v7);
    case 7:
    case 11:
    case 19:
      return (xmlNodePtr)xmlCopyDoc((xmlDocPtr)v7, a4);
    case 8:
    case 10:
    case 12:
    case 13:
    case 14:
    case 15:
      return result;
    case 16:
      return (xmlNodePtr)xmlCopyNamespaceList((xmlNsPtr)v7);
    default:
      v9 = (xmlNode *)xmlMalloc(0x78uLL);
      if (!v9)
      {
        __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"copying node");
        return 0;
      }
      v10 = v9;
      *(_QWORD *)&v9->line = 0;
      *(_OWORD *)&v9->content = 0u;
      *(_OWORD *)&v9->nsDef = 0u;
      *(_OWORD *)&v9->next = 0u;
      *(_OWORD *)&v9->doc = 0u;
      *(_OWORD *)&v9->name = 0u;
      *(_OWORD *)&v9->last = 0u;
      *(_OWORD *)&v9->_private = 0u;
      v9->type = *(_DWORD *)(v7 + 8);
      v9->doc = a2;
      v9->parent = a3;
      v11 = *(const xmlChar **)(v7 + 16);
      v12 = "text";
      if (v11 == "text")
        goto LABEL_18;
      v12 = "textnoenc";
      if (v11 == "textnoenc")
        goto LABEL_18;
      v12 = "comment";
      if (v11 == "comment")
        goto LABEL_18;
      if (v11)
      {
        if (a2 && (dict = a2->dict) != 0)
          v12 = xmlDictLookup(dict, v11, -1);
        else
          v12 = xmlStrdup(*(const xmlChar **)(v7 + 16));
LABEL_18:
        v10->name = v12;
      }
      v14 = *(_DWORD *)(v7 + 8);
      if (v14 == 1)
      {
        v10->line = *(_WORD *)(v7 + 112);
      }
      else
      {
        v15 = *(const xmlChar **)(v7 + 80);
        if (v15 && (v14 > 0x14 || ((1 << v14) & 0x180020) == 0))
          v10->content = xmlStrdup(v15);
      }
      if (!a3)
        goto LABEL_80;
      if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
      {
        v16 = __xmlRegisterNodeDefaultValue();
        ((void (*)(xmlNode *))*v16)(v10);
      }
      result = xmlAddChild(a3, v10);
      if (result == v10)
      {
LABEL_80:
        if (!a4)
          goto LABEL_73;
        v17 = *(_DWORD *)(v7 + 8);
        if (v17 == 19 || v17 == 1)
        {
          v18 = *(xmlNs **)(v7 + 96);
          if (v18)
            v10->nsDef = xmlCopyNamespaceList(v18);
        }
        v19 = *(_QWORD *)(v7 + 72);
        if (v19)
        {
          v20 = xmlSearchNs(a2, v10, *(const xmlChar **)(v19 + 24));
          if (!v20)
          {
            v21 = xmlSearchNs(*(xmlDocPtr *)(v7 + 64), (xmlNodePtr)v7, *(const xmlChar **)(*(_QWORD *)(v7 + 72) + 24));
            if (v21)
            {
              v22 = v10;
              do
              {
                v23 = v22;
                v22 = v22->parent;
              }
              while (v22);
              v20 = xmlNewNs(v23, v21->href, v21->prefix);
            }
            else
            {
              v20 = xmlNewReconciledNs(a2, v10, *(_QWORD *)(v7 + 72));
            }
          }
          v10->ns = v20;
        }
        v24 = *(_DWORD *)(v7 + 8);
        if (v24 == 19 || v24 == 1)
        {
          v26 = *(xmlAttr **)(v7 + 88);
          if (v26)
          {
            v10->properties = xmlCopyPropList(v10, v26);
            v24 = *(_DWORD *)(v7 + 8);
          }
        }
        if (v24 == 5)
        {
          if (a2 && *(xmlDoc **)(v7 + 64) == a2)
            DocEntity = *(xmlEntityPtr *)(v7 + 24);
          else
            DocEntity = xmlGetDocEntity(a2, v10->name);
          v10->children = (_xmlNode *)DocEntity;
          v10->last = (_xmlNode *)DocEntity;
          goto LABEL_73;
        }
        if (a4 == 2 || (v28 = *(_QWORD *)(v7 + 24)) == 0)
        {
LABEL_73:
          if (!a3 && __xmlRegisterCallbacks)
          {
            if (*__xmlRegisterNodeDefaultValue())
            {
              v34 = __xmlRegisterNodeDefaultValue();
              ((void (*)(xmlNode *))*v34)(v10);
            }
          }
          return v10;
        }
        v29 = xmlStaticCopyNode(*(_QWORD *)(v7 + 24), a2, v10, 2);
        if (v29)
        {
          p_private = &v10->_private;
          do
          {
            v31 = p_private[4];
            if (v31 != v29)
            {
              if (v31)
              {
                *(_QWORD *)(v29 + 56) = v31;
                v32 = (uint64_t *)(v31 + 48);
              }
              else
              {
                v32 = p_private + 3;
              }
              *v32 = v29;
              p_private[4] = v29;
            }
            if (*(_DWORD *)(v28 + 8) == 5 || (v33 = *(_QWORD *)(v28 + 24)) == 0)
            {
              while (1)
              {
                v33 = *(_QWORD *)(v28 + 48);
                if (v33)
                  break;
                v28 = *(_QWORD *)(v28 + 40);
                p_private = (_QWORD *)p_private[5];
                if (v28 == v7)
                  goto LABEL_73;
              }
              v29 = (uint64_t)p_private;
            }
            p_private = (_QWORD *)v29;
            v29 = xmlStaticCopyNode(v33, a2, v29, 2);
            v28 = v33;
          }
          while (v29);
        }
        xmlFreeNode(v10);
        return 0;
      }
      return result;
  }
}

xmlNodePtr xmlDocCopyNode(xmlNodePtr node, xmlDocPtr doc, int recursive)
{
  return xmlStaticCopyNode(node, doc, 0, recursive);
}

xmlNodePtr xmlDocCopyNodeList(xmlDocPtr doc, xmlNodePtr node)
{
  return xmlStaticCopyNodeList((xmlDtdPtr)node, doc, 0);
}

xmlNode *xmlStaticCopyNodeList(xmlDtdPtr dtd, _xmlDoc *a2, _xmlDoc *a3)
{
  xmlDtdPtr v5;
  xmlDtdPtr v6;
  _xmlNode *v7;
  xmlNode *v8;
  xmlDtdPtr v9;

  if (!dtd)
    return 0;
  v5 = dtd;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  do
  {
    if (v5->type != XML_DTD_NODE)
    {
      v9 = (xmlDtdPtr)xmlStaticCopyNode(v5, a2, a3, 1);
      if (!v9)
        goto LABEL_18;
      if (!v8)
        goto LABEL_14;
      goto LABEL_10;
    }
    if (a2 && !a2->intSubset)
    {
      v9 = xmlCopyDtd(v5);
      if (!v9)
      {
LABEL_18:
        xmlFreeNodeList(v8);
        return 0;
      }
      v9->doc = a2;
      v9->parent = a3;
      v6 = v9;
      if (!v8)
      {
LABEL_14:
        v7 = 0;
        v8 = (xmlNode *)v9;
LABEL_15:
        v9->prev = v7;
        v7 = (_xmlNode *)v9;
        goto LABEL_6;
      }
LABEL_10:
      if (v7 == (_xmlNode *)v9)
        goto LABEL_6;
      v7->next = (_xmlNode *)v9;
      goto LABEL_15;
    }
LABEL_6:
    v5 = (xmlDtdPtr)v5->next;
  }
  while (v5);
  if (v6)
    a2->intSubset = v6;
  return v8;
}

xmlNodePtr xmlCopyNodeList(xmlNodePtr node)
{
  return xmlStaticCopyNodeList((xmlDtdPtr)node, 0, 0);
}

xmlDtdPtr xmlCopyDtd(xmlDtdPtr dtd)
{
  xmlDtdPtr v2;
  xmlEntitiesTable *entities;
  xmlNotationTable *notations;
  xmlElementTable *elements;
  xmlAttributeTable *attributes;
  xmlEntitiesTable *pentities;
  _xmlNode *children;
  _xmlNode *v9;
  _xmlNode *DtdQElementDesc;
  int properties_high;
  xmlHashTable *v12;
  _xmlNode **p_next;

  if (!dtd)
    return 0;
  v2 = xmlNewDtd(0, dtd->name, dtd->ExternalID, dtd->SystemID);
  if (v2)
  {
    entities = (xmlEntitiesTable *)dtd->entities;
    if (entities)
      v2->entities = xmlCopyEntitiesTable(entities);
    notations = (xmlNotationTable *)dtd->notations;
    if (notations)
      v2->notations = xmlCopyNotationTable(notations);
    elements = (xmlElementTable *)dtd->elements;
    if (elements)
      v2->elements = xmlCopyElementTable(elements);
    attributes = (xmlAttributeTable *)dtd->attributes;
    if (attributes)
      v2->attributes = xmlCopyAttributeTable(attributes);
    pentities = (xmlEntitiesTable *)dtd->pentities;
    if (pentities)
      v2->pentities = xmlCopyEntitiesTable(pentities);
    children = dtd->children;
    if (children)
    {
      v9 = 0;
      while (1)
      {
        switch(children->type)
        {
          case XML_COMMENT_NODE:
            DtdQElementDesc = (_xmlNode *)xmlStaticCopyNode(children, 0, 0, 0);
            if (!DtdQElementDesc)
              goto LABEL_28;
            goto LABEL_30;
          case XML_ELEMENT_DECL:
            DtdQElementDesc = (_xmlNode *)xmlGetDtdQElementDesc(v2, children->name, (const xmlChar *)children->nsDef);
            if (DtdQElementDesc)
              goto LABEL_30;
            goto LABEL_28;
          case XML_ATTRIBUTE_DECL:
            DtdQElementDesc = (_xmlNode *)xmlGetDtdQAttrDesc(v2, *(const xmlChar **)&children->line, children->name, (const xmlChar *)children->psvi);
            if (DtdQElementDesc)
              goto LABEL_30;
            goto LABEL_28;
          case XML_ENTITY_DECL:
            properties_high = HIDWORD(children->properties);
            if ((properties_high - 1) >= 3)
            {
              if ((properties_high - 4) >= 2)
                goto LABEL_28;
              v12 = (xmlHashTable *)v2->pentities;
              if (!v12)
                goto LABEL_28;
            }
            else
            {
              v12 = (xmlHashTable *)v2->entities;
              if (!v12)
                goto LABEL_28;
            }
            DtdQElementDesc = (_xmlNode *)xmlHashLookup(v12, children->name);
            if (DtdQElementDesc)
            {
LABEL_30:
              p_next = &v9->next;
              if (!v9)
                p_next = &v2->children;
              *p_next = DtdQElementDesc;
              DtdQElementDesc->next = 0;
              DtdQElementDesc->prev = v9;
              DtdQElementDesc->parent = (_xmlNode *)v2;
              v2->last = DtdQElementDesc;
              children = children->next;
              v9 = DtdQElementDesc;
              if (!children)
                return v2;
            }
            else
            {
LABEL_28:
              children = children->next;
              if (!children)
                return v2;
            }
            break;
          default:
            goto LABEL_28;
        }
      }
    }
  }
  return v2;
}

xmlDocPtr xmlCopyDoc(xmlDocPtr doc, int recursive)
{
  xmlDocPtr v4;
  xmlDocPtr v5;
  char *name;
  const xmlChar *encoding;
  const xmlChar *URL;
  _xmlDtd *intSubset;
  xmlNode *v10;
  _xmlNs *oldNs;
  _xmlNode *children;
  xmlNode *v13;
  xmlNode *v14;

  if (!doc)
    return 0;
  v4 = xmlNewDoc(doc->version);
  v5 = v4;
  if (v4)
  {
    v4->type = doc->type;
    name = doc->name;
    if (name)
      v5->name = xmlMemStrdup(name);
    encoding = doc->encoding;
    if (encoding)
      v5->encoding = xmlStrdup(encoding);
    URL = doc->URL;
    if (URL)
      v5->URL = xmlStrdup(URL);
    v5->charset = doc->charset;
    *(_QWORD *)&v5->compression = *(_QWORD *)&doc->compression;
    if (recursive)
    {
      v5->children = 0;
      v5->last = 0;
      intSubset = doc->intSubset;
      if (!intSubset)
      {
LABEL_13:
        oldNs = doc->oldNs;
        if (oldNs)
          v5->oldNs = xmlCopyNamespaceList(oldNs);
        children = doc->children;
        if (children)
        {
          v13 = xmlStaticCopyNodeList((xmlDtdPtr)children, v5, v5);
          v5->children = v13;
          v5->last = 0;
          if (v13)
          {
            do
            {
              v14 = v13;
              v13 = v13->next;
            }
            while (v13);
            v5->last = v14;
          }
        }
        return v5;
      }
      v10 = (xmlNode *)xmlCopyDtd(intSubset);
      v5->intSubset = (_xmlDtd *)v10;
      if (v10)
      {
        xmlSetTreeDoc(v10, v5);
        v5->intSubset->parent = v5;
        goto LABEL_13;
      }
      xmlFreeDoc(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t xmlGetLineNo(const xmlNode *node)
{
  return xmlGetLineNoInternal((uint64_t)node, 0);
}

uint64_t xmlGetLineNoInternal(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  BOOL v10;
  uint64_t LineNoInternal;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v2 = -1;
  if (a1 && a2 <= 4)
  {
    v3 = (a2 + 1);
    while (1)
    {
      v4 = *(_DWORD *)(a1 + 8);
      if (v4 <= 8 && ((1 << v4) & 0x18A) != 0)
        break;
      v6 = *(_QWORD *)(a1 + 56);
      if (v6
        && ((v7 = *(_DWORD *)(v6 + 8), v8 = v7 > 8, v9 = (1 << v7) & 0x18A, !v8) ? (v10 = v9 == 0) : (v10 = 1), !v10)
        || (v6 = *(_QWORD *)(a1 + 40)) != 0 && *(_DWORD *)(v6 + 8) == 1)
      {
        v3 = (v3 + 1);
        a1 = v6;
        if ((_DWORD)v3 != 6)
          continue;
      }
      return -1;
    }
    v2 = *(unsigned __int16 *)(a1 + 112);
    if (v2 == 0xFFFF)
    {
      if (v4 == 1)
      {
        v12 = *(_QWORD *)(a1 + 24);
        if (v12)
          goto LABEL_26;
      }
      else if (v4 == 3)
      {
        LineNoInternal = *(_QWORD *)(a1 + 104);
        if (LineNoInternal)
        {
LABEL_28:
          if (LineNoInternal == -1)
            v14 = 0xFFFFLL;
          else
            v14 = LineNoInternal;
          if (LineNoInternal != 0xFFFF)
            return v14;
          return v2;
        }
      }
      v12 = *(_QWORD *)(a1 + 48);
      if (!v12)
      {
        v13 = *(_QWORD *)(a1 + 56);
        if (!v13)
          return v2;
        goto LABEL_27;
      }
LABEL_26:
      v13 = v12;
LABEL_27:
      LineNoInternal = xmlGetLineNoInternal(v13, v3);
      goto LABEL_28;
    }
  }
  return v2;
}

xmlChar *__cdecl xmlGetNodePath(const xmlNode *node)
{
  const xmlNode *v1;
  xmlChar *v2;
  void *v3;
  void *v4;
  size_t v5;
  _xmlNode *parent;
  _xmlNode *v7;
  int v8;
  int v9;
  xmlNs *ns;
  const char *prefix;
  int v12;
  xmlNs *v13;
  _xmlNode *v14;
  int v15;
  _xmlNode *v16;
  int v17;
  _xmlNode *v18;
  _xmlNode *v19;
  xmlElementType type;
  BOOL v21;
  _xmlNode *prev;
  int v23;
  xmlNs *v24;
  xmlNs *v25;
  _xmlNode *next;
  xmlNs *v27;
  xmlNs *v28;
  xmlChar *v29;
  xmlChar *v30;
  void *v31;
  uint64_t v33;
  char __str[16];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!node)
    return 0;
  v1 = node;
  if (node->type == XML_NAMESPACE_DECL)
    return 0;
  v2 = (xmlChar *)xmlMallocAtomic(0x1F4uLL);
  if (!v2)
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"getting node path");
    return v2;
  }
  v3 = xmlMallocAtomic(0x1F4uLL);
  if (!v3)
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"getting node path");
    ((void (*)(xmlChar *))xmlFree)(v2);
    return 0;
  }
  v4 = v3;
  v40 = 0;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v5 = 500;
  *(_OWORD *)__str = 0u;
  v35 = 0u;
  *v2 = 0;
  while (1)
  {
    switch(v1->type)
    {
      case XML_ELEMENT_NODE:
        ns = v1->ns;
        if (!ns)
          goto LABEL_22;
        prefix = (const char *)ns->prefix;
        if (prefix)
        {
          snprintf(__str, 0x63uLL, "%s:%s", prefix, (const char *)v1->name);
          HIBYTE(v40) = 0;
LABEL_22:
          v12 = 1;
        }
        else
        {
          v12 = 0;
        }
        parent = v1->parent;
        prev = v1->prev;
        if (prev)
        {
          v23 = 0;
          do
          {
            if (prev->type == XML_ELEMENT_NODE)
            {
              if (!v12
                || xmlStrEqual(v1->name, prev->name)
                && ((v24 = prev->ns, v25 = v1->ns, v24 == v25) || v24 && v25 && xmlStrEqual(v25->prefix, v24->prefix)))
              {
                ++v23;
              }
            }
            prev = prev->prev;
          }
          while (prev);
          if (v23)
          {
            v9 = v23 + 1;
            goto LABEL_86;
          }
        }
        next = v1->next;
        if (next)
        {
          while (1)
          {
            if (next->type == XML_ELEMENT_NODE)
            {
              if (!v12)
                break;
              if (xmlStrEqual(v1->name, next->name))
              {
                v27 = next->ns;
                v28 = v1->ns;
                if (v27 == v28 || v27 && v28 && xmlStrEqual(v28->prefix, v27->prefix))
                  break;
              }
            }
            next = next->next;
            if (!next)
            {
              v9 = 0;
              goto LABEL_86;
            }
          }
          v9 = 1;
        }
        else
        {
          v9 = 0;
        }
        goto LABEL_86;
      case XML_ATTRIBUTE_NODE:
        v13 = v1->ns;
        if (v13)
        {
          if (v13->prefix)
            snprintf(__str, 0x63uLL, "%s:%s");
          else
            snprintf(__str, 0x63uLL, "%s", v1->name, v33);
          HIBYTE(v40) = 0;
        }
        v9 = 0;
        parent = v1->parent;
        goto LABEL_86;
      case XML_TEXT_NODE:
      case XML_CDATA_SECTION_NODE:
        parent = v1->parent;
        v7 = v1->prev;
        if (v7)
        {
          v8 = 0;
          do
          {
            if (v7->type - 3 < 2)
              ++v8;
            v7 = v7->prev;
          }
          while (v7);
          if (v8)
          {
            v9 = v8 + 1;
            goto LABEL_86;
          }
        }
        break;
      case XML_PI_NODE:
        snprintf(__str, 0x63uLL, "processing-instruction('%s')", (const char *)v1->name);
        HIBYTE(v40) = 0;
        parent = v1->parent;
        v14 = v1->prev;
        if (v14)
        {
          v15 = 0;
          do
          {
            if (v14->type == XML_PI_NODE && xmlStrEqual(v1->name, v14->name))
              ++v15;
            v14 = v14->prev;
          }
          while (v14);
          if (v15)
          {
            v9 = v15 + 1;
            goto LABEL_86;
          }
        }
        v18 = v1->next;
        if (v18)
        {
          do
          {
            if (v18->type == XML_PI_NODE)
            {
              v9 = xmlStrEqual(v1->name, v18->name) != 0;
              if (v9)
                goto LABEL_86;
            }
            else
            {
              v9 = 0;
            }
            v18 = v18->next;
          }
          while (v18);
        }
        else
        {
          v9 = 0;
        }
        goto LABEL_86;
      case XML_COMMENT_NODE:
        parent = v1->parent;
        v16 = v1->prev;
        if (!v16)
          goto LABEL_49;
        v17 = 0;
        do
        {
          if (v16->type == XML_COMMENT_NODE)
            ++v17;
          v16 = v16->prev;
        }
        while (v16);
        if (v17)
        {
          v9 = v17 + 1;
        }
        else
        {
LABEL_49:
          v19 = v1->next;
          if (v19)
          {
            do
            {
              type = v19->type;
              v19 = v19->next;
              if (v19)
                v21 = type == XML_COMMENT_NODE;
              else
                v21 = 1;
            }
            while (!v21);
            v9 = type == XML_COMMENT_NODE;
          }
          else
          {
            v9 = 0;
          }
        }
        goto LABEL_86;
      case XML_DOCUMENT_NODE:
      case XML_HTML_DOCUMENT_NODE:
        if (*v2 == 47)
          goto LABEL_98;
        parent = 0;
        v9 = 0;
        goto LABEL_86;
      default:
        ((void (*)(void *))xmlFree)(v4);
        goto LABEL_102;
    }
    while (1)
    {
      v1 = v1->next;
      if (!v1)
        break;
      if (v1->type - 3 < 2)
      {
        v9 = 1;
        goto LABEL_86;
      }
    }
    v9 = 0;
LABEL_86:
    if (xmlStrlen(v2) + 120 <= v5)
      goto LABEL_90;
    v5 = 2 * v5 + xmlStrlen(v2) + 120;
    v29 = (xmlChar *)xmlRealloc(v2, v5);
    if (!v29)
      break;
    v30 = v29;
    v31 = xmlRealloc(v4, v5);
    if (!v31)
    {
      __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"getting node path");
      xmlFree(v4);
      ((void (*)(xmlChar *))xmlFree)(v30);
      return 0;
    }
    v2 = v30;
    v4 = v31;
LABEL_90:
    if (v9)
      snprintf((char *)v4, v5, "%s%s[%d]%s");
    else
      snprintf((char *)v4, v5, "%s%s%s");
    snprintf((char *)v2, v5, "%s", v4);
    v1 = parent;
    if (!parent)
    {
LABEL_98:
      xmlFree(v4);
      return v2;
    }
  }
  __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"getting node path");
  ((void (*)(void *))xmlFree)(v4);
LABEL_102:
  ((void (*)(xmlChar *))xmlFree)(v2);
  return 0;
}

xmlNodePtr xmlDocSetRootElement(xmlDocPtr doc, xmlNodePtr root)
{
  _xmlNode *v2;
  xmlNode *children;

  v2 = 0;
  if (doc && root)
  {
    if (root->type == XML_NAMESPACE_DECL)
    {
      return 0;
    }
    else
    {
      xmlUnlinkNode(root);
      xmlSetTreeDoc(root, doc);
      root->parent = (_xmlNode *)doc;
      children = doc->children;
      if (children)
      {
        v2 = doc->children;
        while (v2->type != XML_ELEMENT_NODE)
        {
          v2 = v2->next;
          if (!v2)
          {
            xmlAddSibling(children, root);
            return 0;
          }
        }
        xmlReplaceNode(v2, root);
      }
      else
      {
        v2 = 0;
        doc->children = root;
        doc->last = root;
      }
    }
  }
  return v2;
}

void xmlNodeSetLang(xmlNodePtr cur, const xmlChar *lang)
{
  xmlNs *v4;

  if (cur && cur->type - 3 >= 0x13)
  {
    v4 = xmlSearchNsByHref(cur->doc, cur, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
    if (v4)
      xmlSetNsProp(cur, v4, (const xmlChar *)"lang", lang);
  }
}

xmlNsPtr xmlSearchNsByHref(xmlDocPtr doc, xmlNodePtr node, const xmlChar *href)
{
  _xmlNs *oldNs;
  xmlElementType type;
  xmlNodePtr v9;
  xmlElementType v10;
  const xmlChar *v12;
  xmlChar *v13;
  const xmlChar *v14;
  xmlChar *prefix;
  _xmlNs *v16;

  if (!node)
    return 0;
  oldNs = 0;
  if (!href || node->type == XML_NAMESPACE_DECL)
    return oldNs;
  if (xmlStrEqual(href, (const xmlChar *)"http://www.w3.org/XML/1998/namespace"))
  {
    if (doc)
      goto LABEL_6;
    if (node->type == XML_ELEMENT_NODE)
    {
      v16 = (_xmlNs *)xmlMalloc(0x30uLL);
      oldNs = v16;
      if (v16)
      {
        *(_OWORD *)&v16->href = 0u;
        *(_OWORD *)&v16->_private = 0u;
        *(_OWORD *)&v16->next = 0u;
        v16->type = XML_NAMESPACE_DECL;
        v16->href = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        oldNs->prefix = xmlStrdup((const xmlChar *)"xml");
        oldNs->next = node->nsDef;
        node->nsDef = oldNs;
      }
      else
      {
        __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"searching namespace");
      }
      return oldNs;
    }
    doc = node->doc;
    if (doc)
    {
LABEL_6:
      oldNs = doc->oldNs;
      if (oldNs)
        return oldNs;
      return (xmlNsPtr)xmlTreeEnsureXMLDecl((uint64_t)doc);
    }
    return 0;
  }
  type = node->type;
  v9 = node;
  while (1)
  {
    v10 = v9->type;
    if (v10 != XML_ELEMENT_NODE)
    {
      if (v10 - 5 < 2 || v10 == XML_ENTITY_DECL)
        return 0;
      goto LABEL_30;
    }
    oldNs = v9->nsDef;
    if (oldNs)
      break;
LABEL_23:
    if (v9 != node)
    {
      oldNs = v9->ns;
      if (oldNs)
      {
        v14 = oldNs->href;
        if (v14)
        {
          if (xmlStrEqual(v14, href))
          {
            prefix = (xmlChar *)oldNs->prefix;
            if ((type != XML_ATTRIBUTE_NODE || prefix)
              && xmlNsInScope((uint64_t)node, (uint64_t)v9, prefix) == 1)
            {
              return oldNs;
            }
          }
        }
      }
    }
LABEL_30:
    oldNs = 0;
    v9 = v9->parent;
    if (!v9)
      return oldNs;
  }
  while (1)
  {
    v12 = oldNs->href;
    if (v12)
    {
      if (xmlStrEqual(v12, href))
      {
        v13 = (xmlChar *)oldNs->prefix;
        if ((type != XML_ATTRIBUTE_NODE || v13) && xmlNsInScope((uint64_t)node, (uint64_t)v9, v13) == 1)
          return oldNs;
      }
    }
    oldNs = oldNs->next;
    if (!oldNs)
      goto LABEL_23;
  }
}

xmlAttrPtr xmlSetNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name, const xmlChar *value)
{
  const xmlChar *href;
  xmlAttributePtr v9;
  xmlAttributePtr PropNodeInternal;
  xmlNode *children;
  xmlNodePtr *p_children;
  _xmlDoc *doc;
  xmlNodePtr v14;
  xmlNodePtr v15;

  if (ns)
  {
    href = ns->href;
    if (!href)
      return 0;
  }
  else
  {
    href = 0;
  }
  PropNodeInternal = xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, href, 0);
  if (!PropNodeInternal)
    return xmlNewPropInternal((uint64_t)node, ns, (xmlChar *)name, value, 0);
  v9 = PropNodeInternal;
  if (PropNodeInternal->atype == XML_ATTRIBUTE_ID)
  {
    xmlRemoveID(node->doc, (xmlAttrPtr)PropNodeInternal);
    v9->atype = XML_ATTRIBUTE_ID;
  }
  p_children = &v9->children;
  children = v9->children;
  if (children)
    xmlFreeNodeList(children);
  *p_children = 0;
  v9->last = 0;
  v9->nexth = (_xmlAttribute *)ns;
  if (value)
  {
    doc = node->doc;
    v14 = xmlNewText(value);
    if (v14)
    {
      v14->doc = doc;
      *p_children = v14;
      do
      {
        v15 = v14;
        v14->parent = (_xmlNode *)v9;
        v14 = v14->next;
      }
      while (v14);
    }
    else
    {
      v15 = 0;
      *p_children = 0;
    }
    v9->last = v15;
  }
  if (v9->atype == XML_ATTRIBUTE_ID)
    xmlAddID(0, node->doc, value, (xmlAttrPtr)v9);
  return (xmlAttrPtr)v9;
}

xmlChar *__cdecl xmlNodeGetLang(xmlChar *cur)
{
  const xmlNode *v1;

  if (cur)
  {
    v1 = (const xmlNode *)cur;
    if (*((_DWORD *)cur + 2) == 18)
    {
      return 0;
    }
    else
    {
      while (1)
      {
        cur = xmlGetNsProp(v1, (const xmlChar *)"lang", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        if (cur)
          break;
        v1 = v1->parent;
        if (!v1)
          return 0;
      }
    }
  }
  return cur;
}

xmlChar *__cdecl xmlGetNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace)
{
  xmlChar *result;

  result = (xmlChar *)xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, nameSpace, 1);
  if (result)
    return xmlGetPropNodeValueInternal((uint64_t)result);
  return result;
}

void xmlNodeSetSpacePreserve(xmlNodePtr cur, int val)
{
  xmlNs *v4;
  const char *v5;

  if (cur)
  {
    if (cur->type - 3 >= 0x13)
    {
      v4 = xmlSearchNsByHref(cur->doc, cur, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      if (v4)
      {
        if (!val)
        {
          v5 = "default";
          goto LABEL_9;
        }
        if (val == 1)
        {
          v5 = "preserve";
LABEL_9:
          xmlSetNsProp(cur, v4, (const xmlChar *)"space", (const xmlChar *)v5);
        }
      }
    }
  }
}

void xmlNodeSetName(xmlNodePtr cur, const xmlChar *name)
{
  xmlElementType type;
  BOOL v5;
  int v6;
  _xmlDoc *doc;
  xmlDict *dict;
  const xmlChar *v10;
  xmlChar *v11;
  const xmlChar *v12;

  if (cur && name)
  {
    type = cur->type;
    v5 = type > XML_DOCB_DOCUMENT_NODE;
    v6 = (1 << type) & 0x3C3D18;
    if (v5 || v6 == 0)
    {
      doc = cur->doc;
      if (doc && (dict = doc->dict) != 0)
      {
        v10 = cur->name;
        if (v10 && !xmlDictOwns(doc->dict, v10))
          v11 = (xmlChar *)cur->name;
        else
          v11 = 0;
        v12 = xmlDictLookup(dict, name, -1);
      }
      else
      {
        v11 = (xmlChar *)cur->name;
        v12 = xmlStrdup(name);
      }
      cur->name = v12;
      if (v11)
        xmlFree(v11);
    }
  }
}

void xmlNodeSetBase(xmlNodePtr cur, const xmlChar *uri)
{
  xmlElementType type;
  int v5;
  xmlChar *name;
  xmlChar *v7;
  xmlNsPtr v8;
  xmlNs *v9;
  xmlChar *v10;
  xmlChar *v11;

  if (cur)
  {
    type = cur->type;
    if (type > XML_DOCB_DOCUMENT_NODE)
      goto LABEL_12;
    v5 = 1 << type;
    if ((v5 & 0x1FDDF8) != 0)
      return;
    if ((v5 & 0x202200) != 0)
    {
      name = (xmlChar *)cur[1].name;
      if (name)
        xmlFree(name);
      if (uri)
        v7 = xmlPathToURI(uri);
      else
        v7 = 0;
      cur[1].name = v7;
    }
    else
    {
LABEL_12:
      v8 = xmlSearchNsByHref(cur->doc, cur, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      if (v8)
      {
        v9 = v8;
        v10 = xmlPathToURI(uri);
        if (v10)
        {
          v11 = v10;
          xmlSetNsProp(cur, v9, (const xmlChar *)"base", v10);
          xmlFree(v11);
        }
        else
        {
          xmlSetNsProp(cur, v9, (const xmlChar *)"base", uri);
        }
      }
    }
  }
}

xmlChar *__cdecl xmlNodeGetBase(const xmlDoc *doc, const xmlNode *cur)
{
  const xmlNode *v2;
  const xmlDoc *v3;
  _xmlNode *children;
  const xmlChar *name;
  _xmlNode **p_children;
  const xmlChar *URL;
  const xmlChar *v8;
  xmlChar *v9;
  xmlElementType type;
  xmlChar *NsProp;
  xmlChar *v13;
  xmlChar *v14;
  xmlChar *v15;
  char v16;

  if (!((unint64_t)doc | (unint64_t)cur))
    return 0;
  v2 = cur;
  v3 = doc;
  if (cur)
  {
    if (cur->type == XML_NAMESPACE_DECL)
      return 0;
  }
  if (!doc)
  {
    v3 = cur->doc;
    if (!v3)
    {
      v16 = 1;
      goto LABEL_24;
    }
  }
  if (v3->type == XML_HTML_DOCUMENT_NODE)
  {
    children = v3->children;
    if (children)
    {
      while (1)
      {
        name = children->name;
        if (!name)
          return 0;
        if (children->type == XML_ELEMENT_NODE)
        {
          if (!xmlStrcasecmp(name, (const xmlChar *)"html") || !xmlStrcasecmp(children->name, (const xmlChar *)"head"))
          {
            p_children = &children->children;
            goto LABEL_15;
          }
          if (!xmlStrcasecmp(children->name, (const xmlChar *)"base"))
            return xmlGetProp(children, (const xmlChar *)"href");
        }
        p_children = &children->next;
LABEL_15:
        children = *p_children;
        if (!*p_children)
          return 0;
      }
    }
    return 0;
  }
  if (!cur)
  {
    URL = v3->URL;
    if (URL)
      goto LABEL_20;
    return 0;
  }
  v16 = 0;
LABEL_24:
  v9 = 0;
  do
  {
    type = v2->type;
    if (type == XML_ELEMENT_NODE)
    {
      NsProp = xmlGetNsProp(v2, (const xmlChar *)"base", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      if (NsProp)
      {
        v13 = NsProp;
        if (v9)
        {
          v14 = xmlBuildURI(v9, NsProp);
          xmlFree(v9);
          xmlFree(v13);
          v9 = v14;
          if (!v14)
            return v9;
        }
        else
        {
          v9 = NsProp;
        }
        if (!xmlStrncmp(v9, (const xmlChar *)"http://", 7)
          || !xmlStrncmp(v9, (const xmlChar *)"ftp://", 6)
          || !xmlStrncmp(v9, (const xmlChar *)"urn:", 4))
        {
          return v9;
        }
      }
    }
    else if (type == XML_ENTITY_DECL)
    {
      v8 = (const xmlChar *)v2[1]._private;
      return xmlStrdup(v8);
    }
    v2 = v2->parent;
  }
  while (v2);
  if ((v16 & 1) != 0)
    return v9;
  URL = v3->URL;
  if (!URL)
    return v9;
  if (v9)
  {
    v15 = xmlBuildURI(v9, URL);
    xmlFree(v9);
    return v15;
  }
LABEL_20:
  v8 = URL;
  return xmlStrdup(v8);
}

xmlChar *__cdecl xmlGetProp(const xmlNode *node, const xmlChar *name)
{
  xmlChar *result;

  result = (xmlChar *)xmlHasProp(node, name);
  if (result)
    return xmlGetPropNodeValueInternal((uint64_t)result);
  return result;
}

int xmlNodeBufGetContent(xmlBufferPtr buffer, const xmlNode *cur)
{
  int result;
  uint32x2_t *v5;
  int NodeContent;
  uint64_t v7;
  int v9;

  result = -1;
  if (buffer && cur)
  {
    v5 = xmlBufFromBuffer((uint32x2_t *)buffer);
    NodeContent = xmlBufGetNodeContent((xmlBufPtr)v5, cur);
    v7 = xmlBufBackToBuffer((uint64_t)v5);
    v9 = NodeContent < 0 || v7 == 0;
    return v9 << 31 >> 31;
  }
  return result;
}

xmlChar *xmlGetPropNodeValueInternal(uint64_t a1)
{
  int v1;
  uint64_t v2;
  xmlChar *result;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 == 16)
    return xmlStrdup(*(const xmlChar **)(a1 + 88));
  if (v1 != 2)
    return 0;
  v2 = *(_QWORD *)(a1 + 24);
  if (!v2)
    return xmlStrdup((const xmlChar *)&byte_1B0865C1A);
  if (!*(_QWORD *)(v2 + 48) && (*(_DWORD *)(v2 + 8) - 3) <= 1)
    return xmlStrdup(*(const xmlChar **)(v2 + 80));
  result = xmlNodeListGetStringInternal(*(xmlDoc **)(a1 + 64), v2, 1, 0);
  if (!result)
    return xmlStrdup((const xmlChar *)&byte_1B0865C1A);
  return result;
}

void xmlNodeSetContentLen(xmlNodePtr cur, const xmlChar *content, int len)
{
  xmlElementType type;
  int v7;
  xmlChar *v8;
  _xmlAttr **p_properties;
  BOOL v10;
  _xmlDoc *doc;
  xmlDict *dict;
  xmlNode *children;
  xmlChar *v14;
  xmlNode *v15;
  xmlNodePtr NodeList;
  _xmlNode *next;
  _xmlNode *v18;

  if (!cur)
    return;
  type = cur->type;
  if (type > XML_NOTATION_NODE)
    return;
  v7 = 1 << type;
  if ((v7 & 0x11F8) != 0)
  {
    v8 = cur->content;
    p_properties = &cur->properties;
    if (v8)
      v10 = v8 == (xmlChar *)p_properties;
    else
      v10 = 1;
    if (v10)
      goto LABEL_13;
    doc = cur->doc;
    if (doc)
    {
      dict = doc->dict;
      if (dict)
      {
        if (xmlDictOwns(dict, v8))
        {
LABEL_13:
          children = cur->children;
          if (children)
            xmlFreeNodeList(children);
          cur->children = 0;
          cur->last = 0;
          if (content)
            v14 = xmlStrndup(content, len);
          else
            v14 = 0;
          cur->content = v14;
          *p_properties = 0;
          cur->nsDef = 0;
          return;
        }
        v8 = cur->content;
      }
    }
    xmlFree(v8);
    goto LABEL_13;
  }
  if ((v7 & 0x806) != 0)
  {
    v15 = cur->children;
    if (v15)
      xmlFreeNodeList(v15);
    NodeList = xmlStringLenGetNodeList(cur->doc, content, len);
    cur->children = NodeList;
    if (NodeList)
    {
      next = NodeList->next;
      if (next)
      {
        do
        {
          v18 = next;
          NodeList->parent = cur;
          next = next->next;
          NodeList = v18;
        }
        while (next);
      }
      else
      {
        v18 = NodeList;
      }
      v18->parent = cur;
      cur->last = v18;
    }
    else
    {
      cur->last = 0;
    }
  }
}

void xmlNodeAddContentLen(xmlNodePtr cur, const xmlChar *content, int len)
{
  xmlElementType type;
  int v7;
  xmlChar *v8;
  _xmlAttr **p_properties;
  _xmlDoc *doc;
  xmlDict *dict;
  int v12;
  _xmlNode *last;
  xmlNode *v14;
  xmlNode *v15;

  if (cur)
  {
    if (len >= 1)
    {
      type = cur->type;
      if (type <= XML_NOTATION_NODE)
      {
        v7 = 1 << type;
        if ((v7 & 0x11F8) != 0)
        {
          if (content)
          {
            v8 = cur->content;
            p_properties = &cur->properties;
            if (v8 == (xmlChar *)&cur->properties
              || (doc = cur->doc) != 0
              && (dict = doc->dict) != 0
              && (v12 = xmlDictOwns(dict, v8), v8 = cur->content, v12))
            {
              cur->content = xmlStrncatNew(v8, content, len);
              *p_properties = 0;
              cur->nsDef = 0;
            }
            else
            {
              cur->content = xmlStrncat(v8, content, len);
            }
          }
        }
        else if ((v7 & 0x802) != 0)
        {
          last = cur->last;
          v14 = xmlNewTextLen(content, len);
          if (v14)
          {
            v15 = v14;
            if (xmlAddChild(cur, v14) == v14 && last && last->next == v15)
              xmlTextMerge(last, v15);
          }
        }
      }
    }
  }
}

xmlNodePtr xmlTextMerge(xmlNodePtr first, xmlNodePtr second)
{
  xmlNode *v3;

  if (!first)
    return second;
  v3 = first;
  if (second && first->type == XML_TEXT_NODE && second->type == XML_TEXT_NODE && second->name == first->name)
  {
    xmlNodeAddContent(first, second->content);
    xmlUnlinkNode(second);
    xmlFreeNode(second);
  }
  return v3;
}

xmlNsPtr *__cdecl xmlGetNsList(const xmlDoc *doc, const xmlNode *node)
{
  const xmlNode *v2;
  uint64_t v3;
  char *v4;
  int v5;
  xmlNs *i;
  char *v7;
  uint64_t v8;
  const xmlChar *prefix;
  const xmlChar *v10;
  char *v11;

  if (!node)
    return 0;
  v2 = node;
  if (node->type == XML_NAMESPACE_DECL)
    return 0;
  LODWORD(v3) = 0;
  v4 = 0;
  v5 = 10;
  do
  {
    if (v2->type == XML_ELEMENT_NODE)
    {
      for (i = v2->nsDef; i; i = i->next)
      {
        if (!v4)
        {
          v7 = (char *)xmlMalloc(8 * (v5 + 1));
          if (!v7)
            goto LABEL_21;
          v4 = v7;
          *(_QWORD *)&v7[8 * (int)v3] = 0;
        }
        if ((int)v3 < 1)
        {
LABEL_14:
          if ((int)v3 >= v5)
          {
            v11 = (char *)xmlRealloc(v4, 8 * ((2 * v5) | 1));
            if (!v11)
            {
LABEL_21:
              __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"getting namespace list");
              return 0;
            }
            v4 = v11;
            v5 *= 2;
          }
          *(_QWORD *)&v4[8 * (int)v3] = i;
          v3 = (int)v3 + 1;
          *(_QWORD *)&v4[8 * v3] = 0;
        }
        else
        {
          v8 = 0;
          while (1)
          {
            prefix = i->prefix;
            v10 = *(const xmlChar **)(*(_QWORD *)&v4[v8] + 24);
            if (prefix == v10 || xmlStrEqual(prefix, v10))
              break;
            v8 += 8;
            if (8 * v3 == v8)
              goto LABEL_14;
          }
        }
      }
    }
    v2 = v2->parent;
  }
  while (v2);
  return (xmlNsPtr *)v4;
}

uint64_t xmlNsInScope(uint64_t a1, uint64_t a2, xmlChar *str2)
{
  _BOOL4 v3;
  uint64_t v6;
  int v7;
  _QWORD *v9;
  const xmlChar *v10;
  BOOL v11;

  v3 = a1 != a2;
  if (!a1 || a1 == a2)
  {
LABEL_22:
    if (v3)
      return 0xFFFFFFFFLL;
    else
      return 1;
  }
  v6 = a1;
  while (1)
  {
    v7 = *(_DWORD *)(v6 + 8);
    if (v7 == 1)
      break;
    if ((v7 - 5) < 2 || v7 == 17)
      return 0xFFFFFFFFLL;
LABEL_17:
    v6 = *(_QWORD *)(v6 + 40);
    v3 = v6 != a2;
    if (v6)
      v11 = v6 == a2;
    else
      v11 = 1;
    if (v11)
      goto LABEL_22;
  }
  v9 = *(_QWORD **)(v6 + 96);
  if (!v9)
    goto LABEL_17;
  while (1)
  {
    v10 = (const xmlChar *)v9[3];
    if (!((unint64_t)str2 | (unint64_t)v10) || str2 && v10 && xmlStrEqual(v10, str2))
      return 0;
    v9 = (_QWORD *)*v9;
    if (!v9)
      goto LABEL_17;
  }
}

int xmlReconciliateNs(xmlDocPtr doc, xmlNodePtr tree)
{
  int result;
  int v5;
  int v6;
  _QWORD *v7;
  _QWORD *v8;
  xmlNodePtr v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  xmlNsPtr v13;
  xmlNs *v14;
  _QWORD *v15;
  _QWORD *v16;
  _xmlAttr *i;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  xmlNsPtr v21;
  xmlNsPtr v22;
  _QWORD *v23;
  _QWORD *v24;
  xmlNode *children;

  if (!tree)
    return -1;
  result = -1;
  if (doc && tree->type == XML_ELEMENT_NODE && doc->type == XML_DOCUMENT_NODE && tree->doc == doc)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = tree;
    while (1)
    {
      if (v9->ns)
      {
        if (!v6)
        {
          v10 = xmlMalloc(0x50uLL);
          if (!v10)
          {
LABEL_67:
            __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"fixing namespaces");
            return -1;
          }
          v8 = v10;
          v11 = xmlMalloc(0x50uLL);
          if (!v11)
            goto LABEL_66;
          v7 = v11;
          v6 = 10;
        }
        if (v5 < 1)
        {
          LODWORD(v12) = 0;
        }
        else
        {
          v12 = 0;
          while ((xmlNs *)v8[v12] != v9->ns)
          {
            if (v5 == ++v12)
              goto LABEL_20;
          }
          v9->ns = (xmlNs *)v7[v12];
        }
        if ((_DWORD)v12 == v5)
        {
LABEL_20:
          v13 = xmlNewReconciledNs(doc, tree, (uint64_t)v9->ns);
          if (v13)
          {
            v14 = v13;
            if (v6 <= v5)
            {
              v6 *= 2;
              v15 = xmlRealloc(v8, 8 * v6);
              if (!v15)
              {
LABEL_68:
                __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"fixing namespaces");
                ((void (*)(_QWORD *))xmlFree)(v7);
                return -1;
              }
              v8 = v15;
              v16 = xmlRealloc(v7, 8 * v6);
              if (!v16)
              {
LABEL_66:
                __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"fixing namespaces");
                ((void (*)(_QWORD *))xmlFree)(v8);
                return -1;
              }
              v7 = v16;
            }
            v7[v5] = v14;
            v8[v5++] = v9->ns;
            v9->ns = v14;
          }
        }
      }
      if (v9->type == XML_ELEMENT_NODE)
      {
        for (i = v9->properties; i; i = i->next)
        {
          if (i->ns)
          {
            if (!v6)
            {
              v18 = xmlMalloc(0x50uLL);
              if (!v18)
                goto LABEL_67;
              v8 = v18;
              v19 = xmlMalloc(0x50uLL);
              if (!v19)
                goto LABEL_66;
              v7 = v19;
              v6 = 10;
            }
            if (v5 < 1)
            {
              LODWORD(v20) = 0;
            }
            else
            {
              v20 = 0;
              while ((xmlNs *)v8[v20] != i->ns)
              {
                if (v5 == ++v20)
                  goto LABEL_41;
              }
              i->ns = (xmlNs *)v7[v20];
            }
            if ((_DWORD)v20 == v5)
            {
LABEL_41:
              v21 = xmlNewReconciledNs(doc, tree, (uint64_t)i->ns);
              if (v21)
              {
                v22 = v21;
                if (v6 <= v5)
                {
                  v6 *= 2;
                  v23 = xmlRealloc(v8, 8 * v6);
                  if (!v23)
                    goto LABEL_68;
                  v8 = v23;
                  v24 = xmlRealloc(v7, 8 * v6);
                  if (!v24)
                    goto LABEL_66;
                  v7 = v24;
                }
                v7[v5] = v22;
                v8[v5++] = i->ns;
                i->ns = v22;
              }
            }
          }
        }
      }
      children = v9->children;
      if (!children || v9->type == XML_ENTITY_REF_NODE)
      {
        if (v9 == tree)
          goto LABEL_60;
        children = v9->next;
        if (!children)
        {
          while (v9 != tree)
          {
            if (v9->parent)
              v9 = v9->parent;
            if (v9 == tree || (children = v9->next) == 0)
            {
              children = v9->parent;
              if (children)
                continue;
            }
            if (children == tree)
              break;
            goto LABEL_59;
          }
LABEL_60:
          if (v8)
            xmlFree(v8);
          if (v7)
            xmlFree(v7);
          return 0;
        }
      }
LABEL_59:
      v9 = children;
      if (!children)
        goto LABEL_60;
    }
  }
  return result;
}

xmlNsPtr xmlNewReconciledNs(xmlDocPtr doc, xmlNodePtr node, uint64_t a3)
{
  xmlNsPtr result;
  int i;
  char __str[16];
  __int128 v9;
  __int128 v10;
  __int16 v11;
  uint64_t v12;

  result = 0;
  v12 = *MEMORY[0x1E0C80C00];
  if (a3 && node->type == XML_ELEMENT_NODE)
  {
    if (*(_DWORD *)(a3 + 8) == 18)
    {
      result = xmlSearchNsByHref(doc, node, *(const xmlChar **)(a3 + 16));
      if (result)
        return result;
      v11 = 0;
      v9 = 0u;
      v10 = 0u;
      *(_OWORD *)__str = 0u;
      if (*(_QWORD *)(a3 + 24))
        snprintf(__str, 0x32uLL, "%.20s", *(const char **)(a3 + 24));
      else
        strcpy(__str, "default");
      if (!xmlSearchNs(doc, node, (const xmlChar *)__str))
        return xmlNewNs(node, *(const xmlChar **)(a3 + 16), (const xmlChar *)__str);
      for (i = 1; i != 1001; ++i)
      {
        if (*(_QWORD *)(a3 + 24))
          snprintf(__str, 0x32uLL, "%.20s%d");
        else
          snprintf(__str, 0x32uLL, "default%d");
        if (!xmlSearchNs(doc, node, (const xmlChar *)__str))
          return xmlNewNs(node, *(const xmlChar **)(a3 + 16), (const xmlChar *)__str);
      }
    }
    return 0;
  }
  return result;
}

xmlAttrPtr xmlHasProp(const xmlNode *node, const xmlChar *name)
{
  xmlAttr *properties;
  _xmlDoc *doc;
  xmlDtd *intSubset;
  xmlDtd *extSubset;

  if (!node)
    return 0;
  properties = 0;
  if (!name || node->type != XML_ELEMENT_NODE)
    return properties;
  properties = node->properties;
  if (!properties)
  {
LABEL_7:
    doc = node->doc;
    if (doc)
    {
      intSubset = doc->intSubset;
      if (intSubset)
      {
        properties = (xmlAttr *)xmlGetDtdAttrDesc(intSubset, node->name, name);
        if (properties
          || (extSubset = doc->extSubset) != 0
          && (properties = (xmlAttr *)xmlGetDtdAttrDesc(extSubset, node->name, name)) != 0)
        {
          if (properties->psvi)
            return properties;
        }
      }
    }
    return 0;
  }
  while (!xmlStrEqual(properties->name, name))
  {
    properties = properties->next;
    if (!properties)
      goto LABEL_7;
  }
  return properties;
}

xmlAttributePtr xmlGetPropNodeInternal(uint64_t a1, xmlChar *str2, const xmlChar *a3, int a4)
{
  xmlAttributePtr v5;
  const xmlChar *name;
  uint64_t v10;
  uint64_t v11;
  const xmlChar *v12;
  xmlChar *v13;
  xmlChar *v14;
  xmlChar *v15;
  xmlChar *v16;
  const xmlDoc *v17;
  xmlDtd *v18;
  const xmlChar *v19;
  const xmlChar *v20;
  const xmlChar *v21;
  xmlNsPtr *NsList;
  xmlNsPtr *v23;
  xmlNsPtr v24;
  xmlNsPtr *v25;
  xmlAttributePtr DtdQAttrDesc;
  xmlDtd *v27;
  xmlNs *v28;

  if (!a1)
    return 0;
  v5 = 0;
  if (!str2 || *(_DWORD *)(a1 + 8) != 1)
    return v5;
  v5 = *(xmlAttributePtr *)(a1 + 88);
  if (!v5)
  {
LABEL_15:
    if (!a4)
      return 0;
    v10 = *(_QWORD *)(a1 + 64);
    if (!v10 || !*(_QWORD *)(v10 + 80))
      return 0;
    v11 = *(_QWORD *)(a1 + 72);
    if (v11 && (v12 = *(const xmlChar **)(v11 + 24)) != 0)
    {
      v13 = xmlStrdup(v12);
      v14 = xmlStrcat(v13, (const xmlChar *)":");
      v15 = xmlStrcat(v14, *(const xmlChar **)(a1 + 16));
      v16 = v15;
      if (!v15)
        return 0;
    }
    else
    {
      v16 = 0;
      v15 = *(xmlChar **)(a1 + 16);
    }
    if (a3)
    {
      v17 = (const xmlDoc *)xmlStrEqual(a3, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      if (!(_DWORD)v17)
      {
        NsList = xmlGetNsList(v17, (const xmlNode *)a1);
        if (!NsList)
        {
          if (v16)
            xmlFree(v16);
          return 0;
        }
        v23 = NsList;
        v24 = *NsList;
        if (*NsList)
        {
          v25 = NsList;
          while (1)
          {
            if (xmlStrEqual(v24->href, a3))
            {
              DtdQAttrDesc = xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(v10 + 80), v15, str2, (*v25)->prefix);
              if (DtdQAttrDesc)
                break;
              v27 = *(xmlDtd **)(v10 + 88);
              if (v27)
              {
                DtdQAttrDesc = xmlGetDtdQAttrDesc(v27, v15, str2, (*v25)->prefix);
                if (DtdQAttrDesc)
                  break;
              }
            }
            v28 = v25[1];
            ++v25;
            v24 = v28;
            if (!v28)
              goto LABEL_40;
          }
          v5 = DtdQAttrDesc;
        }
        else
        {
LABEL_40:
          v5 = 0;
        }
        xmlFree(v23);
        goto LABEL_46;
      }
      v5 = xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(v10 + 80), v15, str2, (const xmlChar *)"xml");
      if (v5)
      {
LABEL_46:
        if (v16)
          xmlFree(v16);
        if (!v5 || v5->defaultValue)
          return v5;
        return 0;
      }
      v18 = *(xmlDtd **)(v10 + 88);
      if (v18)
      {
        v19 = (const xmlChar *)"xml";
        v20 = v15;
        v21 = str2;
LABEL_31:
        v5 = xmlGetDtdQAttrDesc(v18, v20, v21, v19);
        goto LABEL_46;
      }
    }
    else
    {
      v5 = xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(v10 + 80), v15, str2, 0);
      if (v5)
        goto LABEL_46;
      v18 = *(xmlDtd **)(v10 + 88);
      if (v18)
      {
        v20 = v15;
        v21 = str2;
        v19 = 0;
        goto LABEL_31;
      }
    }
    v5 = 0;
    goto LABEL_46;
  }
  if (a3)
  {
    while (1)
    {
      if (v5->nexth)
      {
        if (xmlStrEqual(v5->name, str2))
        {
          name = v5->nexth->name;
          if (name == a3 || xmlStrEqual(name, a3))
            break;
        }
      }
      v5 = (xmlAttributePtr)v5->next;
      if (!v5)
        goto LABEL_15;
    }
  }
  else
  {
    while (v5->nexth || !xmlStrEqual(v5->name, str2))
    {
      v5 = (xmlAttributePtr)v5->next;
      if (!v5)
        goto LABEL_15;
    }
  }
  return v5;
}

xmlChar *__cdecl xmlGetNoNsProp(const xmlNode *node, const xmlChar *name)
{
  xmlChar *result;

  result = (xmlChar *)xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, 0, 1);
  if (result)
    return xmlGetPropNodeValueInternal((uint64_t)result);
  return result;
}

int xmlUnsetProp(xmlNodePtr node, const xmlChar *name)
{
  xmlNode *PropNodeInternal;
  xmlAttr *v3;

  PropNodeInternal = (xmlNode *)xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, 0, 0);
  if (!PropNodeInternal)
    return -1;
  v3 = (xmlAttr *)PropNodeInternal;
  xmlUnlinkNode(PropNodeInternal);
  xmlFreeProp(v3);
  return 0;
}

int xmlUnsetNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name)
{
  const xmlChar *href;
  xmlNode *PropNodeInternal;
  xmlAttr *v6;

  if (ns)
    href = ns->href;
  else
    href = 0;
  PropNodeInternal = (xmlNode *)xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, href, 0);
  if (!PropNodeInternal)
    return -1;
  v6 = (xmlAttr *)PropNodeInternal;
  xmlUnlinkNode(PropNodeInternal);
  xmlFreeProp(v6);
  return 0;
}

xmlAttrPtr xmlSetProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value)
{
  int v6;
  xmlNode *v7;
  xmlNs *v8;
  const xmlChar *v9;
  uint64_t v11;
  xmlChar *v12;
  xmlNsPtr v13;

  if (!node || !name || node->type != XML_ELEMENT_NODE)
    return 0;
  v6 = *name;
  if (v6 == 58)
    goto LABEL_5;
  v11 = 1;
  if (!*name)
    goto LABEL_5;
  while (v6 != 58)
  {
    v6 = name[v11++];
    if (!v6)
      goto LABEL_5;
  }
  v12 = xmlStrndup(name, (int)v11 - 1);
  v13 = xmlSearchNs(node->doc, node, v12);
  if (v12)
    xmlFree(v12);
  if (v13)
  {
    v9 = &name[v11];
    v7 = node;
    v8 = v13;
  }
  else
  {
LABEL_5:
    v7 = node;
    v8 = 0;
    v9 = name;
  }
  return xmlSetNsProp(v7, v8, v9, value);
}

int xmlTextConcat(xmlNodePtr node, const xmlChar *content, int len)
{
  xmlElementType type;
  BOOL v5;
  int v6;
  xmlChar *v10;
  _xmlDoc *doc;
  xmlDict *dict;
  int v13;
  xmlChar *v14;

  if (!node)
    return -1;
  type = node->type;
  v5 = type > XML_COMMENT_NODE;
  v6 = (1 << type) & 0x198;
  if (v5 || v6 == 0)
    return -1;
  v10 = node->content;
  if (v10 == (xmlChar *)&node->properties
    || (doc = node->doc) != 0 && (dict = doc->dict) != 0 && (v13 = xmlDictOwns(dict, v10), v10 = node->content, v13))
  {
    v14 = xmlStrncatNew(v10, content, len);
  }
  else
  {
    v14 = xmlStrncat(v10, content, len);
  }
  node->content = v14;
  node->properties = 0;
  if (v14)
    return 0;
  else
    return -1;
}

xmlBufferPtr xmlBufferCreate(void)
{
  xmlBuffer *v0;
  xmlBuffer *v1;
  xmlChar *v2;

  v0 = (xmlBuffer *)xmlMalloc(0x20uLL);
  v1 = v0;
  if (v0)
  {
    v0->use = 0;
    v0->size = *__xmlDefaultBufferSize();
    v1->alloc = *__xmlBufferAllocScheme();
    v2 = (xmlChar *)xmlMallocAtomic(v1->size);
    v1->content = v2;
    if (v2)
    {
      bzero(v2, v1->size);
      v1->contentIO = 0;
    }
    else
    {
      __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"creating buffer");
      xmlFree(v1);
      return 0;
    }
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"creating buffer");
  }
  return v1;
}

xmlBufferPtr xmlBufferCreateSize(size_t size)
{
  xmlBuffer *v1;
  xmlBuffer *v3;
  xmlBufferAllocationScheme v4;
  unsigned int v5;
  xmlChar *v6;

  if (size > 0x7FFFFFFE)
    return 0;
  v3 = (xmlBuffer *)xmlMalloc(0x20uLL);
  v1 = v3;
  if (!v3)
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"creating buffer");
    return v1;
  }
  v3->use = 0;
  v4 = *__xmlBufferAllocScheme();
  if (size)
    v5 = size + 1;
  else
    v5 = 0;
  v1->size = v5;
  v1->alloc = v4;
  if (!size)
  {
    v1->content = 0;
    goto LABEL_12;
  }
  v6 = (xmlChar *)xmlMallocAtomic((size + 1));
  v1->content = v6;
  if (v6)
  {
    bzero(v6, v1->size);
LABEL_12:
    v1->contentIO = 0;
    return v1;
  }
  __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"creating buffer");
  xmlFree(v1);
  return 0;
}

xmlChar *__cdecl xmlBufferDetach(xmlChar *buf)
{
  xmlChar *v1;

  if (buf)
  {
    v1 = buf;
    if (*((_DWORD *)buf + 4) == 2)
    {
      return 0;
    }
    else
    {
      buf = *(xmlChar **)buf;
      *(_QWORD *)v1 = 0;
      *((_QWORD *)v1 + 1) = 0;
    }
  }
  return buf;
}

xmlBufferPtr xmlBufferCreateStatic(void *mem, size_t size)
{
  xmlBufferPtr result;
  unsigned int v4;

  result = 0;
  if (mem)
  {
    v4 = size;
    if (size - 0x80000000 >= 0xFFFFFFFF80000001)
    {
      result = (xmlBufferPtr)xmlMalloc(0x20uLL);
      if (result)
      {
        result->use = v4;
        result->size = v4;
        result->alloc = XML_BUFFER_ALLOC_IMMUTABLE;
        result->content = (xmlChar *)mem;
      }
      else
      {
        __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"creating buffer");
        return 0;
      }
    }
  }
  return result;
}

void xmlBufferSetAllocationScheme(xmlBufferPtr buf, xmlBufferAllocationScheme scheme)
{
  BOOL v2;
  BOOL v3;

  if (buf)
  {
    if ((buf->alloc & 0xFFFFFFFE) == 2)
    {
      v2 = 1;
      v3 = 0;
    }
    else
    {
      v2 = scheme >= XML_BUFFER_ALLOC_HYBRID;
      v3 = scheme == XML_BUFFER_ALLOC_HYBRID;
    }
    if ((v3 || !v2) && scheme != XML_BUFFER_ALLOC_IO)
      buf->alloc = scheme;
  }
}

void xmlBufferFree(xmlBufferPtr buf)
{
  xmlBufferAllocationScheme alloc;
  xmlChar *contentIO;

  if (buf)
  {
    alloc = buf->alloc;
    if (alloc == XML_BUFFER_ALLOC_IO)
    {
      contentIO = buf->contentIO;
      if (!contentIO)
      {
        contentIO = buf->content;
        if (!buf->content)
          goto LABEL_12;
      }
    }
    else
    {
      contentIO = buf->content;
      if (alloc == XML_BUFFER_ALLOC_IMMUTABLE || contentIO == 0)
        goto LABEL_12;
    }
    xmlFree(contentIO);
LABEL_12:
    xmlFree(buf);
  }
}

void xmlBufferEmpty(xmlBufferPtr buf)
{
  xmlChar *content;
  xmlBufferAllocationScheme alloc;
  xmlChar *contentIO;

  if (buf)
  {
    content = buf->content;
    if (buf->content)
    {
      buf->use = 0;
      alloc = buf->alloc;
      if (alloc == XML_BUFFER_ALLOC_IO)
      {
        contentIO = buf->contentIO;
        if (contentIO)
        {
          buf->size += (_DWORD)content - (_DWORD)contentIO;
          buf->content = contentIO;
          *contentIO = 0;
          return;
        }
      }
      else if (alloc == XML_BUFFER_ALLOC_IMMUTABLE)
      {
        buf->content = (xmlChar *)&byte_1B0865C1A;
        return;
      }
      *content = 0;
    }
  }
}

int xmlBufferShrink(xmlBufferPtr buf, unsigned int len)
{
  unsigned int v2;
  unsigned int use;
  size_t v5;
  xmlBufferAllocationScheme alloc;
  xmlChar *contentIO;
  xmlChar *v9;
  unint64_t v10;
  int v11;
  xmlChar *v12;
  unsigned int v13;

  if (!buf)
    return -1;
  v2 = len;
  if (len)
  {
    use = buf->use;
    v5 = use - len;
    if (use < len)
      return -1;
    buf->use = v5;
    alloc = buf->alloc;
    if (alloc == XML_BUFFER_ALLOC_IMMUTABLE)
    {
      buf->content += len;
      v13 = buf->size - len;
      goto LABEL_13;
    }
    if (alloc != XML_BUFFER_ALLOC_IO || (contentIO = buf->contentIO) == 0)
    {
      memmove(buf->content, &buf->content[len], v5);
      buf->content[buf->use] = 0;
      return v2;
    }
    v9 = &buf->content[len];
    buf->content = v9;
    v10 = buf->size - v2;
    buf->size = v10;
    v11 = (_DWORD)v9 - (_DWORD)contentIO;
    if (v9 - contentIO >= v10)
    {
      memmove(contentIO, v9, v5);
      v12 = buf->contentIO;
      buf->content = v12;
      v12[buf->use] = 0;
      v13 = buf->size + v11;
LABEL_13:
      buf->size = v13;
    }
  }
  return v2;
}

int xmlBufferGrow(xmlBufferPtr buf, unsigned int len)
{
  xmlBufferAllocationScheme alloc;
  int result;
  unsigned int size;
  unsigned int use;
  const char *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  size_t v12;
  xmlChar *contentIO;
  xmlChar *v14;
  xmlChar *v15;
  xmlChar *v16;

  if (!buf)
    return -1;
  alloc = buf->alloc;
  if (alloc == XML_BUFFER_ALLOC_IMMUTABLE)
    return 0;
  use = buf->use;
  size = buf->size;
  if (size - use > len)
  {
    result = 0;
    buf->content[use + len] = 0;
    return result;
  }
  if (2147483646 - use >= len)
  {
    v9 = use + len;
    v10 = v9 + 100;
    if (v9 > 0x7FFFFF9B)
      v10 = 0x7FFFFFFF;
    if (size >> 30)
      v11 = 0x7FFFFFFF;
    else
      v11 = 2 * size;
    if (size > len)
      v12 = v11;
    else
      v12 = v10;
    if (alloc == XML_BUFFER_ALLOC_IO && (contentIO = buf->contentIO) != 0)
    {
      v14 = (xmlChar *)(buf->content - contentIO);
      v15 = (xmlChar *)xmlRealloc(contentIO, (size_t)&v14[v12]);
      if (v15)
      {
        buf->contentIO = v15;
        v16 = &v14[(_QWORD)v15];
LABEL_22:
        buf->content = v16;
        buf->size = v12;
        v16[buf->use] = 0;
        buf->content[buf->use + len] = 0;
        return buf->size + ~buf->use;
      }
    }
    else
    {
      v16 = (xmlChar *)xmlRealloc(buf->content, v12);
      if (v16)
        goto LABEL_22;
    }
    v8 = "growing buffer";
    goto LABEL_24;
  }
  v8 = "growing buffer past INT_MAX";
LABEL_24:
  __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)v8);
  return -1;
}

int xmlBufferDump(FILE *file, xmlBufferPtr buf)
{
  const void *content;
  FILE *v4;

  if (buf)
  {
    content = buf->content;
    if (buf->content)
    {
      if (file)
        v4 = file;
      else
        v4 = (FILE *)*MEMORY[0x1E0C80C20];
      content = (const void *)fwrite(content, 1uLL, buf->use, v4);
      if ((unint64_t)content >= 0x7FFFFFFF)
        LODWORD(content) = 0x7FFFFFFF;
    }
  }
  else
  {
    LODWORD(content) = 0;
  }
  return (int)content;
}

const xmlChar *__cdecl xmlBufferContent(const xmlChar *buf)
{
  if (buf)
    return *(const xmlChar **)buf;
  return buf;
}

int xmlBufferLength(const xmlBuffer *buf)
{
  unsigned int use;

  if (!buf)
    return 0;
  use = buf->use;
  if (use >= 0x7FFFFFFF)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      xmlBufferLength_cold_1(use);
    return 2147483646;
  }
  return use;
}

int xmlBufferResize(xmlBufferPtr buf, unsigned int size)
{
  xmlBufferPtr v2;
  xmlBufferAllocationScheme alloc;
  unsigned int v4;
  const char *v5;
  unsigned int v6;
  xmlChar *contentIO;
  unint64_t v8;
  xmlChar *v9;
  xmlChar *v10;
  xmlChar *v11;
  xmlChar *v12;

  if (buf)
  {
    v2 = buf;
    alloc = buf->alloc;
    if (alloc == XML_BUFFER_ALLOC_IMMUTABLE)
    {
LABEL_39:
      LODWORD(buf) = 0;
      return (int)buf;
    }
    v4 = buf->size;
    if (v4 <= size)
    {
      if (size >= 0x7FFFFFF6)
      {
        v5 = "growing buffer past INT_MAX";
LABEL_38:
        __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)v5);
        goto LABEL_39;
      }
      switch(alloc)
      {
        case XML_BUFFER_ALLOC_DOUBLEIT:
        case XML_BUFFER_ALLOC_IO:
          if (v4)
            v6 = buf->size;
          else
            v6 = size + 10;
          while (1)
          {
            if (v6 >= size)
              goto LABEL_15;
            if (v6 >> 30)
              goto LABEL_37;
            v6 *= 2;
          }
        case XML_BUFFER_ALLOC_EXACT:
          v6 = size + 10;
          goto LABEL_25;
        case XML_BUFFER_ALLOC_HYBRID:
          if (buf->use >= 0x1000)
          {
            v6 = buf->size;
            if (v4 < size)
            {
              do
              {
                if (v6 >> 30)
                  goto LABEL_37;
                v6 *= 2;
              }
              while (v6 < size);
LABEL_15:
              if (alloc == XML_BUFFER_ALLOC_IO)
              {
                contentIO = buf->contentIO;
                if (contentIO)
                {
                  v8 = v2->content - contentIO;
                  if (v8 > v6)
                  {
                    memmove(contentIO, v2->content, v2->use);
                    v9 = v2->contentIO;
                    goto LABEL_35;
                  }
                  v12 = (xmlChar *)xmlRealloc(contentIO, v8 + v6);
                  if (v12)
                  {
                    v2->contentIO = v12;
                    v9 = &v12[v8];
                    goto LABEL_35;
                  }
                  goto LABEL_37;
                }
              }
            }
          }
          else
          {
            v6 = size;
          }
LABEL_25:
          if (!v2->content)
          {
            v10 = (xmlChar *)xmlMallocAtomic(v6);
LABEL_29:
            v9 = v10;
            if (!v10)
              goto LABEL_37;
LABEL_35:
            v2->content = v9;
            v2->size = v6;
            v9[v2->use] = 0;
            break;
          }
          if (v4 - v2->use <= 0x63)
          {
            v10 = (xmlChar *)xmlRealloc(v2->content, v6);
            goto LABEL_29;
          }
          v11 = (xmlChar *)xmlMallocAtomic(v6);
          if (v11)
          {
            v9 = v11;
            memcpy(v11, v2->content, v2->use);
            xmlFree(v2->content);
            goto LABEL_35;
          }
LABEL_37:
          v5 = "growing buffer";
          goto LABEL_38;
        default:
          v6 = size + 10;
          goto LABEL_15;
      }
    }
    LODWORD(buf) = 1;
  }
  return (int)buf;
}

int xmlBufferAdd(xmlBufferPtr buf, const xmlChar *str, int len)
{
  int v3;
  unsigned int v5;
  unsigned int use;
  unsigned int v8;
  const char *v10;

  v3 = -1;
  if (buf)
  {
    if (str)
    {
      v5 = len;
      if (len >= -1 && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)
      {
        if (!len)
          return 0;
        if ((len & 0x80000000) == 0 || (v5 = xmlStrlen(str), (v5 & 0x80000000) == 0))
        {
          if (v5)
          {
            use = buf->use;
            if (v5 >= buf->size - use)
            {
              if (v5 >= (use ^ 0x7FFFFFFF))
              {
                v10 = "growing buffer past INT_MAX";
              }
              else
              {
                if (xmlBufferResize(buf, v5 + use + 1))
                {
                  use = buf->use;
                  goto LABEL_13;
                }
                v10 = "growing buffer";
              }
              v3 = 2;
              __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)v10);
              return v3;
            }
LABEL_13:
            memmove(&buf->content[use], str, v5);
            v3 = 0;
            v8 = buf->use + v5;
            buf->use = v8;
            buf->content[v8] = 0;
            return v3;
          }
          return 0;
        }
      }
    }
  }
  return v3;
}

int xmlBufferAddHead(xmlBufferPtr buf, const xmlChar *str, int len)
{
  unsigned int v3;
  int v4;
  xmlChar *contentIO;
  xmlChar *v8;
  int32x2_t v9;
  unsigned int use;
  unsigned int v11;
  const char *v12;

  if (!buf)
    return -1;
  v3 = len;
  v4 = -1;
  if (len >= -1 && str && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)
  {
    if (!len)
      return 0;
    if (len < 0)
      v3 = xmlStrlen(str);
    if ((int)v3 >= 1)
    {
      if (buf->alloc == XML_BUFFER_ALLOC_IO)
      {
        contentIO = buf->contentIO;
        if (contentIO)
        {
          if ((xmlChar *)(buf->content - contentIO) > (xmlChar *)v3)
          {
            v8 = &buf->content[-v3];
            buf->content = v8;
            memmove(v8, str, v3);
            v4 = 0;
            v9 = vadd_s32(*(int32x2_t *)&buf->use, vdup_n_s32(v3));
            *(int32x2_t *)&buf->use = v9;
            buf->content[v9.u32[0]] = 0;
            return v4;
          }
        }
      }
      use = buf->use;
      if (v3 >= buf->size - use)
      {
        if (v3 >= (use ^ 0x7FFFFFFF))
        {
          v12 = "growing buffer past INT_MAX";
        }
        else
        {
          if (xmlBufferResize(buf, v3 + use + 1))
          {
            use = buf->use;
            goto LABEL_19;
          }
          v12 = "growing buffer";
          v4 = 2;
        }
        __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)v12);
        return v4;
      }
LABEL_19:
      memmove(&buf->content[v3], buf->content, use);
      memmove(buf->content, str, v3);
      v4 = 0;
      v11 = buf->use + v3;
      buf->use = v11;
      buf->content[v11] = 0;
    }
  }
  return v4;
}

int xmlBufferCat(xmlBufferPtr buf, const xmlChar *str)
{
  if (buf && str && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)
    return xmlBufferAdd(buf, str, -1);
  else
    return -1;
}

int xmlBufferCCat(xmlBufferPtr buf, const char *str)
{
  if (buf && str && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)
    return xmlBufferAdd(buf, (const xmlChar *)str, -1);
  else
    return -1;
}

void xmlBufferWriteCHAR(xmlBufferPtr buf, const xmlChar *string)
{
  if (buf && string && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)
    xmlBufferAdd(buf, string, -1);
}

void xmlBufferWriteChar(xmlBufferPtr buf, const char *string)
{
  if (buf && string && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)
    xmlBufferAdd(buf, (const xmlChar *)string, -1);
}

void xmlBufferWriteQuotedString(xmlBufferPtr buf, const xmlChar *string)
{
  const xmlChar *v3;
  const xmlChar *v4;
  xmlBufferAllocationScheme v5;
  uint64_t i;
  xmlBuffer *v7;
  const xmlChar *v8;
  int v9;
  xmlBufferAllocationScheme alloc;
  const char *v11;
  xmlBufferAllocationScheme v12;

  if (!buf || buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)
    return;
  v3 = string;
  if (!xmlStrchr(string, 0x22u))
  {
    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)
      return;
    xmlBufferAdd(buf, (const xmlChar *)"\"", -1);
    alloc = buf->alloc;
    if (!v3 || alloc == XML_BUFFER_ALLOC_IMMUTABLE)
      goto LABEL_22;
    v7 = buf;
    v8 = v3;
    v9 = -1;
    goto LABEL_20;
  }
  v4 = xmlStrchr(v3, 0x27u);
  v5 = buf->alloc;
  if (v4)
  {
    if (v5 != XML_BUFFER_ALLOC_IMMUTABLE)
      xmlBufferAdd(buf, (const xmlChar *)"\"", -1);
LABEL_7:
    for (i = 0; v3[i]; ++i)
    {
      if (v3[i] == 34)
      {
        if (i)
          xmlBufferAdd(buf, v3, i);
        xmlBufferAdd(buf, (const xmlChar *)"&quot;", 6);
        v3 += i + 1;
        goto LABEL_7;
      }
    }
    if (!i)
      goto LABEL_21;
    v7 = buf;
    v8 = v3;
    v9 = i;
LABEL_20:
    xmlBufferAdd(v7, v8, v9);
LABEL_21:
    alloc = buf->alloc;
LABEL_22:
    if (alloc != XML_BUFFER_ALLOC_IMMUTABLE)
    {
      v11 = "\"";
LABEL_24:
      xmlBufferAdd(buf, (const xmlChar *)v11, -1);
      return;
    }
    return;
  }
  if (v5 != XML_BUFFER_ALLOC_IMMUTABLE)
  {
    xmlBufferAdd(buf, (const xmlChar *)"'", -1);
    v12 = buf->alloc;
    if (v3 && v12 != XML_BUFFER_ALLOC_IMMUTABLE)
    {
      xmlBufferAdd(buf, v3, -1);
      v12 = buf->alloc;
    }
    if (v12 != XML_BUFFER_ALLOC_IMMUTABLE)
    {
      v11 = "'";
      goto LABEL_24;
    }
  }
}

int xmlGetDocCompressMode(const xmlDoc *doc)
{
  if (doc)
    return doc->compression;
  else
    return -1;
}

void xmlSetDocCompressMode(xmlDocPtr doc, int mode)
{
  if (doc)
  {
    if (mode < 0)
    {
      doc->compression = 0;
    }
    else if (mode < 0xA)
    {
      doc->compression = mode;
    }
    else
    {
      doc->compression = 9;
    }
  }
}

int xmlGetCompressMode(void)
{
  return xmlCompressMode;
}

void xmlSetCompressMode(int mode)
{
  int v1;

  if (mode >= 9)
    v1 = 9;
  else
    v1 = mode;
  if (mode < 0)
    v1 = 0;
  xmlCompressMode = v1;
}

xmlDOMWrapCtxtPtr xmlDOMWrapNewCtxt(void)
{
  xmlDOMWrapCtxt *v0;
  xmlDOMWrapCtxt *v1;

  v0 = (xmlDOMWrapCtxt *)xmlMalloc(0x20uLL);
  v1 = v0;
  if (v0)
  {
    *(_OWORD *)&v0->_private = 0u;
    *(_OWORD *)&v0->namespaceMap = 0u;
  }
  else
  {
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"allocating DOM-wrapper context");
  }
  return v1;
}

void xmlDOMWrapFreeCtxt(xmlDOMWrapCtxtPtr ctxt)
{
  _QWORD *namespaceMap;

  if (ctxt)
  {
    namespaceMap = ctxt->namespaceMap;
    if (namespaceMap)
      xmlDOMWrapNsMapFree(namespaceMap);
    xmlFree(ctxt);
  }
}

void xmlDOMWrapNsMapFree(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  if (a1)
  {
    v2 = (_QWORD *)a1[2];
    if (v2)
    {
      do
      {
        v3 = (_QWORD *)*v2;
        xmlFree(v2);
        v2 = v3;
      }
      while (v3);
    }
    v4 = (_QWORD *)*a1;
    if (*a1)
    {
      do
      {
        v5 = (_QWORD *)*v4;
        xmlFree(v4);
        v4 = v5;
      }
      while (v5);
    }
    xmlFree(a1);
  }
}

int xmlDOMWrapRemoveNode(xmlDOMWrapCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr node, int options)
{
  int v4;
  xmlNodePtr properties;
  xmlElementType type;
  xmlNodePtr v10;
  xmlElementType v11;
  xmlNs *i;
  xmlNs *ns;
  int v14;
  xmlNs **v15;
  xmlNsPtr v16;
  uint64_t v17;
  xmlNs **v18;

  v17 = 0;
  v18 = 0;
  v4 = -1;
  if (!doc)
    return v4;
  properties = node;
  if (!node || node->doc != doc)
    return v4;
  if (!node->parent)
    return 0;
  type = node->type;
  v4 = 1;
  if (type > XML_COMMENT_NODE)
    return v4;
  if (((1 << type) & 0x1B8) != 0)
  {
    xmlUnlinkNode(node);
    return 0;
  }
  if (((1 << type) & 6) == 0)
    return v4;
  xmlUnlinkNode(node);
  v4 = 0;
  while (1)
  {
    while (1)
    {
      v10 = properties;
      v11 = properties->type;
      if (v11 != XML_ATTRIBUTE_NODE)
      {
        if (v11 != XML_ELEMENT_NODE)
          goto LABEL_38;
        if (!ctxt)
        {
          for (i = properties->nsDef; i; i = i->next)
          {
            if (xmlDOMWrapNSNormAddNsMapItem2((void **)&v18, (int *)&v17 + 1, (int *)&v17, (uint64_t)i, (uint64_t)i) == -1)v4 = -1;
          }
        }
      }
      ns = v10->ns;
      if (!ns)
        goto LABEL_35;
      if (v18)
      {
        v14 = v17;
        if ((int)v17 >= 1)
          break;
      }
LABEL_25:
      if (ctxt)
      {
        v16 = 0;
      }
      else
      {
        v16 = xmlDOMWrapStoreNs((uint64_t)doc, ns->href, ns->prefix);
        if (v16)
        {
          if (xmlDOMWrapNSNormAddNsMapItem2((void **)&v18, (int *)&v17 + 1, (int *)&v17, (uint64_t)v10->ns, (uint64_t)v16) == -1)v4 = -1;
        }
        else
        {
          v4 = -1;
        }
      }
      v10->ns = v16;
LABEL_35:
      if (v10->type != XML_ELEMENT_NODE)
        goto LABEL_38;
      properties = (xmlNodePtr)v10->properties;
      if (!properties)
        goto LABEL_37;
    }
    v15 = v18 + 1;
    while (ns != *(v15 - 1))
    {
      v15 += 2;
      if (!--v14)
        goto LABEL_25;
    }
    v10->ns = *v15;
    if (v10->type != XML_ELEMENT_NODE)
      break;
LABEL_37:
    properties = v10->children;
    if (!properties)
    {
LABEL_38:
      while (1)
      {
        properties = v10->next;
        if (properties)
          break;
        v10 = v10->parent;
        if (!v10)
          goto LABEL_40;
      }
    }
  }
  if (v10)
    goto LABEL_38;
LABEL_40:
  if (v18)
    xmlFree(v18);
  return v4;
}

uint64_t xmlDOMWrapNSNormAddNsMapItem2(void **a1, int *a2, int *a3, uint64_t a4, uint64_t a5)
{
  int v9;
  int v10;
  void *v11;
  int v13;
  uint64_t v14;

  v9 = *a3;
  v10 = *a2;
  v11 = *a1;
  if (*a3 >= *a2)
  {
    if (v10)
      v13 = 2 * v10;
    else
      v13 = 3;
    v11 = xmlRealloc(v11, 16 * v13);
    if (!v11)
    {
      __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)"realloc ns map item");
      return 0xFFFFFFFFLL;
    }
    *a1 = v11;
    *a2 = v13;
    v9 = *a3;
  }
  v14 = 0;
  *((_QWORD *)v11 + 2 * v9) = a4;
  *((_QWORD *)*a1 + 2 * v9 + 1) = a5;
  *a3 = v9 + 1;
  return v14;
}

xmlNsPtr xmlDOMWrapStoreNs(uint64_t a1, const xmlChar *a2, const xmlChar *a3)
{
  const xmlChar **v5;
  const xmlChar *v6;
  const xmlChar *v7;
  xmlNsPtr v8;

  v5 = (const xmlChar **)xmlTreeEnsureXMLDecl(a1);
  if (v5)
  {
    while (1)
    {
      v6 = *v5;
      if (!*v5)
        break;
      v5 = (const xmlChar **)*v5;
      v7 = (const xmlChar *)*((_QWORD *)v6 + 3);
      if ((v7 == a3 || xmlStrEqual(v7, a3)) && xmlStrEqual(v5[2], a2))
        return (xmlNsPtr)v5;
    }
    v8 = xmlNewNs(0, a2, a3);
    *v5 = (const xmlChar *)v8;
    return v8;
  }
  return (xmlNsPtr)v5;
}

int xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt, xmlNodePtr elem, int options)
{
  xmlElementType type;
  int v5;
  char v6;
  int v7;
  uint64_t v8;
  int v9;
  xmlNodePtr i;
  xmlNs *v11;
  _BOOL4 v12;
  _xmlNode *parent;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  const xmlChar *v17;
  uint64_t v18;
  const xmlChar *v19;
  const xmlChar *v20;
  const xmlChar *v21;
  xmlNs *ns;
  uint64_t v23;
  uint64_t v25;
  const xmlChar *prefix;
  const xmlChar *v27;
  xmlNs **p_next;
  xmlNs *next;
  _xmlNode *v30;
  int v31;
  xmlNs **v32;
  uint64_t *v33;
  xmlNs **p_nsDef;
  xmlNode *properties;
  xmlElementType v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t *v41;
  xmlNs **v43;
  int v44;
  xmlNs **v45;
  xmlNs *v46;
  _xmlDoc *doc;
  uint64_t v48;
  xmlNs **v49;
  uint64_t *v50;
  xmlNs *nsDef;

  v49 = 0;
  v50 = 0;
  v48 = 0;
  if (!elem || !elem->doc)
    return -1;
  type = elem->type;
  v5 = -1;
  if (type == XML_ELEMENT_NODE)
  {
    v6 = options;
    doc = elem->doc;
    v7 = 0;
    v8 = 0;
    v5 = 0;
    nsDef = 0;
    v9 = -1;
    for (i = elem; ; i = properties)
    {
      if (type != XML_ATTRIBUTE_NODE)
      {
        if (type != XML_ELEMENT_NODE)
          goto LABEL_81;
        ++v9;
        if (i->nsDef)
        {
          v11 = 0;
          nsDef = i->nsDef;
          v12 = 1;
          while (1)
          {
            if (!v7)
            {
              parent = elem->parent;
              if (parent
                && (_xmlNode *)parent->doc != parent
                && xmlDOMWrapNSNormGatherInScopeNs(&v50, (uint64_t)parent) == -1)
              {
                v5 = -1;
              }
              v7 = 1;
            }
            v14 = v50;
            if ((v6 & 1) == 0 || !v50 || (v15 = *v50) == 0)
            {
LABEL_30:
              ns = i->ns;
              v23 = (uint64_t)nsDef;
              if (v12 && ns != 0)
                v12 = ns != nsDef;
              if (v14)
              {
                v25 = *v14;
                if (*v14)
                {
                  do
                  {
                    if (*(int *)(v25 + 36) >= -1 && *(_DWORD *)(v25 + 32) == -1)
                    {
                      prefix = nsDef->prefix;
                      v27 = *(const xmlChar **)(*(_QWORD *)(v25 + 24) + 24);
                      if (prefix == v27 || xmlStrEqual(prefix, v27))
                        *(_DWORD *)(v25 + 32) = v9;
                    }
                    v25 = *(_QWORD *)v25;
                  }
                  while (v25);
                  v23 = (uint64_t)nsDef;
                }
              }
              if (!xmlDOMWrapNsMapAddItem(&v50, -1, v23, v23, v9))
                v5 = -1;
              p_next = &nsDef->next;
              v11 = nsDef;
LABEL_47:
              next = *p_next;
              goto LABEL_48;
            }
            while (1)
            {
              if (*(int *)(v15 + 36) < -1 || *(_DWORD *)(v15 + 32) != -1)
                goto LABEL_28;
              v16 = (uint64_t)nsDef;
              v17 = nsDef->prefix;
              v18 = *(_QWORD *)(v15 + 24);
              v19 = *(const xmlChar **)(v18 + 24);
              if (v17 != v19)
              {
                if (!xmlStrEqual(v17, v19))
                  goto LABEL_28;
                v16 = (uint64_t)nsDef;
                v18 = *(_QWORD *)(v15 + 24);
              }
              v20 = *(const xmlChar **)(v16 + 16);
              v21 = *(const xmlChar **)(v18 + 16);
              if (v20 == v21)
                goto LABEL_26;
              if (xmlStrEqual(v20, v21))
                break;
LABEL_28:
              v15 = *(_QWORD *)v15;
              if (!v15)
              {
                v14 = v50;
                goto LABEL_30;
              }
            }
            v16 = (uint64_t)nsDef;
            v18 = *(_QWORD *)(v15 + 24);
LABEL_26:
            if (xmlDOMWrapNSNormAddNsMapItem2((void **)&v49, (int *)&v48 + 1, (int *)&v48, v16, v18) == -1)
            {
              v5 = -1;
              goto LABEL_28;
            }
            next = nsDef->next;
            if (v11)
            {
              v11->next = next;
              p_next = &nsDef->next;
              goto LABEL_47;
            }
            i->nsDef = next;
LABEL_48:
            nsDef = next;
            if (!next)
            {
              v8 = (uint64_t)i;
              if (!v12)
                goto LABEL_78;
              goto LABEL_56;
            }
          }
        }
        v8 = (uint64_t)i;
      }
LABEL_56:
      if (i->ns)
      {
        if (!v7)
        {
          v30 = elem->parent;
          if (v30
            && (_xmlNode *)v30->doc != v30
            && xmlDOMWrapNSNormGatherInScopeNs(&v50, (uint64_t)v30) == -1)
          {
            v5 = -1;
          }
          v7 = 1;
        }
        if (v49)
        {
          v31 = v48;
          if ((int)v48 >= 1)
          {
            v32 = v49 + 1;
            while (i->ns != *(v32 - 1))
            {
              v32 += 2;
              if (!--v31)
                goto LABEL_70;
            }
            i->ns = *v32;
          }
        }
LABEL_70:
        v33 = v50;
        if (v50)
        {
          while (1)
          {
            v33 = (uint64_t *)*v33;
            if (!v33)
              break;
            if (*((_DWORD *)v33 + 8) == -1 && i->ns == (xmlNs *)v33[2])
            {
              p_nsDef = (xmlNs **)(v33 + 3);
              goto LABEL_77;
            }
          }
        }
        p_nsDef = &nsDef;
        if (xmlDOMWrapNSNormAcquireNormalizedNs((uint64_t)doc, v8, (uint64_t)i->ns, (uint64_t *)&nsDef, &v50, v9, i->type == XML_ATTRIBUTE_NODE) == -1)v5 = -1;
LABEL_77:
        i->ns = *p_nsDef;
      }
LABEL_78:
      if (i->type != XML_ELEMENT_NODE)
        goto LABEL_81;
      properties = (xmlNode *)i->properties;
      if (!properties)
      {
LABEL_98:
        properties = i->children;
        if (!properties)
        {
LABEL_81:
          while (i != elem)
          {
            v36 = i->type;
            if (v36 == XML_ELEMENT_NODE)
            {
              v37 = v50;
              if (v50)
              {
                v38 = *v50;
                if (*v50)
                {
                  v40 = v50 + 1;
                  v39 = v50[1];
                  if (!v39)
                    goto LABEL_111;
                  do
                  {
                    if (*(_DWORD *)(v39 + 36) < v9)
                      break;
                    v41 = *(uint64_t **)(v39 + 8);
                    *v40 = (uint64_t)v41;
                    if (v41)
                      v37 = v41;
                    *v37 = 0;
                    *(_QWORD *)v39 = v50[2];
                    v37 = v50;
                    v50[2] = v39;
                    v40 = v37 + 1;
                    v39 = v37[1];
                  }
                  while (v39);
                  v38 = *v37;
                  if (*v37)
                  {
LABEL_111:
                    do
                    {
                      if (*(_DWORD *)(v38 + 32) >= v9)
                        *(_DWORD *)(v38 + 32) = -1;
                      v38 = *(_QWORD *)v38;
                    }
                    while (v38);
                  }
                }
              }
              --v9;
            }
            properties = i->next;
            if (properties)
              goto LABEL_80;
            i = i->parent;
            if (v36 == XML_ATTRIBUTE_NODE && i->type == XML_ELEMENT_NODE)
              goto LABEL_98;
          }
          v43 = v49;
          if (v49)
          {
            v44 = v48;
            if ((int)v48 >= 1)
            {
              v45 = v49;
              do
              {
                v46 = *v45;
                v45 += 2;
                xmlFreeNs(v46);
                --v44;
              }
              while (v44);
            }
            xmlFree(v43);
          }
          if (v50)
            xmlDOMWrapNsMapFree(v50);
          return v5;
        }
      }
LABEL_80:
      type = properties->type;
    }
  }
  return v5;
}

uint64_t xmlDOMWrapNSNormGatherInScopeNs(uint64_t **a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t *v6;
  _QWORD *v7;
  const xmlChar *v8;
  const xmlChar *v9;
  char v10;
  _QWORD *v11;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = a2;
  v3 = 0xFFFFFFFFLL;
  if (a2 && !*a1 && *(_DWORD *)(a2 + 8) != 18)
  {
    while (1)
    {
      if (v2 == *(_QWORD *)(v2 + 64))
        return 0;
      if (*(_DWORD *)(v2 + 8) == 1)
      {
        v5 = *(_QWORD **)(v2 + 96);
        if (v5)
          break;
      }
LABEL_19:
      v3 = 0;
      v2 = *(_QWORD *)(v2 + 40);
      if (!v2)
        return v3;
    }
    while (1)
    {
      v6 = *a1;
      if (*a1 && (v7 = (_QWORD *)*v6) != 0)
      {
        while (1)
        {
          v8 = (const xmlChar *)v5[3];
          v9 = *(const xmlChar **)(v7[3] + 24);
          if (v8 == v9 || xmlStrEqual(v8, v9))
            break;
          v7 = (_QWORD *)*v7;
          if (!v7)
            goto LABEL_13;
        }
        v10 = 0;
      }
      else
      {
LABEL_13:
        v10 = 1;
      }
      v3 = 0xFFFFFFFFLL;
      v11 = xmlDOMWrapNsMapAddItem(a1, 0, 0, (uint64_t)v5, -1);
      if (!v11)
        break;
      if ((v10 & 1) == 0)
        *((_DWORD *)v11 + 8) = 0;
      v5 = (_QWORD *)*v5;
      if (!v5)
        goto LABEL_19;
    }
  }
  return v3;
}

_QWORD *xmlDOMWrapNsMapAddItem(uint64_t **a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  _QWORD *result;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  _QWORD *v14;
  const char *v15;

  result = 0;
  if (!a1 || (a2 - 1) < 0xFFFFFFFE)
    return result;
  v11 = *a1;
  if (!*a1)
  {
    v12 = (uint64_t *)xmlMalloc(0x18uLL);
    if (!v12)
    {
      v15 = "allocating namespace map";
      goto LABEL_17;
    }
    v11 = v12;
    *v12 = 0;
    v12[1] = 0;
    v12[2] = 0;
    *a1 = v12;
  }
  result = (_QWORD *)v11[2];
  if (!result)
  {
    result = xmlMalloc(0x28uLL);
    if (result)
      goto LABEL_9;
    v15 = "allocating namespace map item";
LABEL_17:
    __xmlSimpleError(2u, 2, 0, 0, (const xmlChar *)v15);
    return 0;
  }
  v11[2] = *result;
LABEL_9:
  result[4] = 0;
  *(_OWORD *)result = 0u;
  *((_OWORD *)result + 1) = 0u;
  v13 = *v11;
  if (*v11)
  {
    if (a2 == -1)
    {
      v14 = (_QWORD *)v11[1];
      ++v11;
      result[1] = v14;
      *v14 = result;
    }
    else
    {
      *(_QWORD *)(v13 + 8) = result;
      *result = v13;
    }
  }
  else
  {
    *v11++ = (uint64_t)result;
  }
  *v11 = (uint64_t)result;
  result[2] = a3;
  result[3] = a4;
  *((_DWORD *)result + 8) = -1;
  *((_DWORD *)result + 9) = a5;
  return result;
}

uint64_t xmlDOMWrapNSNormAcquireNormalizedNs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t **a5, int a6, int a7)
{
  uint64_t result;
  _BYTE *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  const xmlChar *v19;
  const xmlChar *v20;
  xmlChar *v21;
  xmlChar *v22;
  xmlNsPtr v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  const xmlChar *v27;
  const xmlChar *v28;
  xmlNsPtr v29;
  xmlNsPtr v30;
  xmlChar *href;
  xmlChar *prefix;
  void *v33;
  void *v34;
  _OWORD *v35;

  result = 0xFFFFFFFFLL;
  if (a3 && a4 && a5)
  {
    *a4 = 0;
    v15 = *(_BYTE **)(a3 + 24);
    if (v15 && *v15 == 120 && v15[1] == 109 && v15[2] == 108 && !v15[3])
    {
      v35 = xmlTreeEnsureXMLDecl(a1);
      *a4 = (uint64_t)v35;
      if (v35)
        return 0;
      else
        return 0xFFFFFFFFLL;
    }
    else
    {
      v16 = *a5;
      if (*a5 && (v17 = *v16) != 0)
      {
        while (1)
        {
          if (*(int *)(v17 + 36) >= -1 && *(_DWORD *)(v17 + 32) == -1)
          {
            v18 = *(_QWORD *)(v17 + 24);
            v19 = *(const xmlChar **)(v18 + 16);
            if (v19)
            {
              if (*v19 && (!a7 || *(_QWORD *)(v18 + 24)))
              {
                v20 = *(const xmlChar **)(a3 + 16);
                if (v19 == v20)
                  goto LABEL_22;
                if (xmlStrEqual(v19, v20))
                  break;
              }
            }
          }
          v17 = *(_QWORD *)v17;
          if (!v17)
            goto LABEL_23;
        }
        v18 = *(_QWORD *)(v17 + 24);
LABEL_22:
        result = 0;
        *(_QWORD *)(v17 + 16) = a3;
        *a4 = v18;
      }
      else
      {
LABEL_23:
        v21 = *(xmlChar **)(a3 + 16);
        v22 = *(xmlChar **)(a3 + 24);
        if (a2)
        {
          v23 = xmlDOMWrapNSNormDeclareNsForced(a2, v21, v22, 0);
          if (v23)
          {
            v24 = (uint64_t)v23;
            v25 = *a5;
            if (*a5)
            {
              v26 = *v25;
              if (*v25)
              {
                while (1)
                {
                  if (*(_DWORD *)(v26 + 36) < a6 && *(_DWORD *)(v26 + 32) == -1)
                  {
                    v27 = *(const xmlChar **)(a3 + 24);
                    v28 = *(const xmlChar **)(*(_QWORD *)(v26 + 24) + 24);
                    if (v27 == v28 || xmlStrEqual(v27, v28))
                      break;
                  }
                  v26 = *(_QWORD *)v26;
                  if (!v26)
                    goto LABEL_42;
                }
                *(_DWORD *)(v26 + 32) = a6;
              }
            }
LABEL_42:
            if (xmlDOMWrapNsMapAddItem(a5, -1, a3, v24, a6))
            {
              result = 0;
              *a4 = v24;
              return result;
            }
            v33 = *(void **)(v24 + 16);
            if (v33)
              xmlFree(v33);
            v34 = *(void **)(v24 + 24);
            if (v34)
              xmlFree(v34);
            ((void (*)(uint64_t))xmlFree)(v24);
          }
        }
        else
        {
          v29 = xmlDOMWrapStoreNs(a1, v21, v22);
          if (v29)
          {
            v30 = v29;
            if (xmlDOMWrapNsMapAddItem(a5, -1, a3, (uint64_t)v29, -3))
            {
              result = 0;
              *a4 = (uint64_t)v30;
              return result;
            }
            href = (xmlChar *)v30->href;
            if (href)
              xmlFree(href);
            prefix = (xmlChar *)v30->prefix;
            if (prefix)
              xmlFree(prefix);
            ((void (*)(xmlNsPtr))xmlFree)(v30);
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}

